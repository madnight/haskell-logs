00:00:58 <mstksg> > comparing recip 10 5
00:00:59 <lambdabot>   LT
00:01:06 <mstksg> > 10 `comparing recip` 5
00:01:07 <lambdabot>   <hint>:1:15: parse error on input `recip'
00:01:09 <mstksg> alas.
00:06:57 <yitz> > let (>/<) = comparing recip in 10 >/< 5
00:06:58 <lambdabot>   LT
00:07:13 <yitz> > let cmprecip = comparing recip in 10 `cmprecip` 5
00:07:14 <lambdabot>   LT
00:14:51 <mstksg> a little less expressive? or maybe it's in the eye of the beholder
00:15:14 <mikeplus64> @hoogle a -> m (m a)
00:15:15 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> forall a. Data a => a -> m a
00:15:15 <lambdabot> Data.Sequence inits :: Seq a -> Seq (Seq a)
00:15:15 <lambdabot> Data.Sequence tails :: Seq a -> Seq (Seq a)
00:17:03 <Twey> Why is there a RecordWildCards extension *and* a NoRecordWildCards extension?
00:17:32 <hvr> Twey: so that you can turn it off too
00:17:55 <dmwit> Twey: All extensions have a No variant.
00:18:08 <Twey> Oh, really?  That's future-compatibly useful.
00:18:08 <dmwit> (In fact, NoMonomorphismRestriction is just the No variant of MonomorphismRestriction. =)
00:18:16 <Twey> Ha
00:18:16 <Twey> Nice.
00:18:32 <mstksg> maybe it's to negate an extension specified in a cabal file
00:18:59 <Twey> Perhaps
00:19:08 <Twey> It makes sense if there's one for every extension.
00:28:36 <hape01_> What is the conceptual name for the left hand side argument in  "Option{..} <- cmdArgs defOption"?  If it is regular record syntax, what is the semantics of it?
00:29:02 <hvr> hape01_: pattern match with record wildcards?
00:30:05 <hape01_> Is it?
00:30:49 <johnw> it's just a record wildcard
00:31:13 <hape01_> hvr, johnw: thx, i have to investigate on this a bit more
00:33:31 <raymank26> hi all! I have this type "type Matrix= V.Vector (V.Vector Int)" I would like to change individual element using Control.Lens. How to do this?
00:33:52 <raymank26> V is Data.Vector of course
00:40:10 <gasche> tikhon: I don't think the OCaml community claimed that module systems are replacement for type classes
00:41:13 <gasche> (I'm referring to your discussion with n-dolio some hours ago)
00:41:58 <gasche> in fact they're doing vastly different things, so I'm not sure they can be compared
01:02:48 * hackagebot data-extra 2.3.0 - Extra utilities for working on Data.* types.  http://hackage.haskell.org/package/data-extra-2.3.0 (ChrisDone)
01:08:18 <Cale> raymank26: There's a lens for Vectors in Data.Vector.Lens
01:10:44 <supki> raymank26: Vector is an instance of Ixed, so  vector & ix x . ix y .~ value  should work
01:13:24 <Cale> ghci> set (ordinals [2,4]) 10 (fromList [1,2,3,4,5])
01:13:24 <Cale> fromList [1,2,10,4,10]
01:17:55 <CTH_HACKMASTERS> test test
01:18:03 <CTH_HACKMASTERS> hello
01:18:06 <Cale> hi
01:18:11 <CTH_HACKMASTERS> i have a haskell problem
01:18:16 <Ghoul_> hi there
01:18:27 <Cale> Feel free to ask any questions you might have
01:18:41 <Cale> http://lpaste.net/new/haskell if you want to paste code
01:18:56 <Ghoul_> You'll get approximately 1095 different answers
01:19:00 <CTH_HACKMASTERS> i :
01:19:04 <Cale> haha
01:19:11 <CTH_HACKMASTERS> im figuring out how 2 express it
01:19:13 <CTH_HACKMASTERS> give me a minute
01:20:27 <CTH_HACKMASTERS> i want to convert a string like this: "abcdefg" to pairs like these [('a', 'b'), ('b', 'c'), ('c', 'd') etc. ]
01:20:46 <Cale> zip xs (tail xs)
01:20:55 <CTH_HACKMASTERS> give me a minute imma test it
01:21:35 <Cale> zip`ap`tail, the Aztec god of adjacent pairs ;)
01:21:37 <CTH_HACKMASTERS> ok nice
01:21:38 <CTH_HACKMASTERS> it works
01:22:11 <CTH_HACKMASTERS> now if i wanna do it with a large section of the string at a time, like this: "abcde" to ['a', 'b', 'c'], ['b', 'c', 'd'] etc
01:22:37 <Cale> Ah, in that case, you could work with tails
01:22:45 <Cale> > tails "abcdefg"
01:22:46 <lambdabot>   ["abcdefg","bcdefg","cdefg","defg","efg","fg","g",""]
01:22:56 <CTH_HACKMASTERS> ok
01:22:57 <Cale> > map (take 3) (tails "abcdefg")
01:22:59 <lambdabot>   ["abc","bcd","cde","def","efg","fg","g",""]
01:23:17 <Cale> > zipWith const (map (take 3) (tails "abcdefg")) (drop 3 "abcdefg")
01:23:18 <lambdabot>   ["abc","bcd","cde","def"]
01:23:22 <Cale> > zipWith const (map (take 3) (tails "abcdefg")) (drop 2 "abcdefg")
01:23:23 <lambdabot>   ["abc","bcd","cde","def","efg"]
01:23:58 <CTH_HACKMASTERS> tails isn't "in scope"
01:24:03 <Cale> It's in Data.List
01:24:06 <CTH_HACKMASTERS> so
01:24:10 <CTH_HACKMASTERS> import Data.List or what?
01:24:10 <Cale> import Data.List
01:24:11 <CTH_HACKMASTERS> ok
01:24:12 <CTH_HACKMASTERS> tyvm
01:33:34 <CTH_HACKMASTERS> hey guuuys
01:33:50 <CTH_HACKMASTERS> when i use this code: zipWith const (map (take 3) (tails "abcdefg")) (drop 3 "abcdefg") it skips the last letter
01:33:51 <CTH_HACKMASTERS> like
01:34:00 <CTH_HACKMASTERS> abcde becomes abc bcd
01:34:10 <CTH_HACKMASTERS> whats up with that?
01:34:44 <CTH_HACKMASTERS> brb 2 min
01:34:52 <quicksilver> zipWith always goes on the shortest list, CTH_HACKMASTERS
01:35:21 <quicksilver> > zipWith (++) ["a","b"] ["Z","Y","X"]
01:35:22 <lambdabot>   ["aZ","bY"]
01:35:45 <johnw> joeyh: ping?
01:41:16 <mel-> Hi
01:41:58 <Cale> CTH_HACKMASTERS: You missed my next line, I originally miscounted
01:43:16 <CTH_HACKMASTERS> oh
01:43:20 <CTH_HACKMASTERS> its working now
01:43:23 <CTH_HACKMASTERS> THANK YOU <3
01:43:52 <mel-> Is there something special about importing modules in ghci in contrast to loading it from a file which is to be compiled with ghc? I have a 'module Foo' in 'Foo.hs' which simply defines 'foo = 1'. I can use this dummy module fine with ghc (i.e. 'import Foo', use 'foo'). But this does not work from ghci. I do 'import Foo' (ghci stays quiet) but evaluating 'foo' yields in 'Not in scope' and evaluating Foo.foo
01:43:54 <mel-> triggers 'attempting to use Foo (./Foo.hs) which is not loaded'.
01:43:59 <mel-> What am I missing? Thanks!
01:44:26 <xunie-laptop> I'm looking for a function that takes a function, applies it over a list and only returns the lowest members of that list. If the function evaluates 'a' as 1, 'b' as '2' and 'c' as 3 and the list is "abca"? It should obviously return both 'a's.
01:44:30 <xunie-laptop> Does such a function exist?
01:45:18 <mel-> xunie-laptop: never seen such a function, but it shouldn't be hard to write.
01:46:02 <xunie-laptop> Hard for a newbie...
01:46:12 <mel-> seems you need to sort the list based on (the function's evaluation result) and then take the first element of that list
01:46:50 <mel-> xunie-laptop: see http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:sortBy
01:47:06 <mel-> xunie-laptop: with sortBy you can sort a list while passing your own comparison function.
01:47:24 <xunie-laptop> mel-, thanks a lot!
01:47:24 <mel-> xunie-laptop: when you have sorted the list, pick the first (or last element) of that sorted list.
01:47:32 <xunie-laptop> I figured that. :P
01:48:07 <mel-> xunie-laptop: (i am assuming here that it's not too much of an overhead to do the full sort)
01:48:42 <xunie-laptop> It will in the future once my dataset grows.
01:49:21 <xunie-laptop> But shouldn't haskell be lazy with take 5 $ sortBy?
01:49:46 <xunie-laptop> Of course not.
01:49:52 <mel-> xunie-laptop: i'm not sure how sortBy assembles the list. i.e. if it is lazy.
01:49:55 <xunie-laptop> It's sorting so it checks all elements.
01:50:11 <mel-> right.
01:50:26 <mel-> so, maybe when you are there, you can optimize it.
01:50:32 <mel-> but for now that should work just fine.
01:50:35 <xunie-laptop> Yeah.
01:50:48 <xunie-laptop> I'm going for code clarity since I'm new at Haskell. :3
01:50:49 <xunie-laptop> Thanks.
01:51:08 <mel-> you're welcome.
01:51:14 <mbrock> clarity is always good (:
01:52:42 <mbrock> code should be written primarily for people to understand, and only secondarily to impress the ladies
01:53:57 <mel-> (or the gents, for that matter)
01:54:40 <mbrock> that comes third for me personally but good point :/
01:54:56 <quicksilver> well, there are sort algorithms which are lazy
01:55:06 <quicksilver> so it's only O(n) to pick the minimum element if you do head . sort
01:55:14 <quicksilver> instead of O(n log n)
01:55:35 <quicksilver> however the difference between the two is not life-changing in most cases
01:55:54 <mbrock> the textbook quicksort implementation works like that, right?
01:57:49 * hackagebot command-qq 0.1.0.0 - Quasiquoters for external commands  http://hackage.haskell.org/package/command-qq-0.1.0.0 (MatveyAksenov)
01:57:54 <mr-> doesn't quicksort have to sort the whole list before it can produce the first element?
01:58:12 <mel-> anyone has an idea about my module importing problem (above)?
01:58:57 <mr-> mel, try :m +Foo
01:59:06 <xunie-laptop> mr-, not if I understand the algorithm correctly.
02:00:26 <mr-> mel-, or rather: :load foo.hs
02:00:51 <mbrock> it does the pivoting thing, so there should be recursions in the evaluation tree that aren't forced
02:01:19 <mbrock> if you look at the equation for it, it's clear that only the "left" recursions are needed to take the head
02:01:30 <mel-> So, :load Foo.hs works, :m +Foo does not (`Could not find module Foo').
02:01:36 <mr-> mbrock: that's right, sorry
02:01:51 <mel-> So, what is the problem here? It seems ghci behaves differently wrt module importing.
02:01:55 <mr-> mel-: yes, because it does not know where to look for Foo
02:01:58 <mel-> Is this made precise anywhere?
02:02:18 <johnw> start ghci with "-i <dir where Foo lives>"
02:03:24 <mel-> mr-: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/separate-compilation.html says: The search path by default contains a single directory: “.” (i.e. the current directory). -- So i take it, this does only apply to ghc, not to ghci?
02:04:48 <mr-> mel-, I don't know. I can't get it to work with -i either
02:05:01 <mel-> johnw: does not work either: (I gues you mean 'ghci -i.' no?) Could not find module Foo
02:05:08 <mel-> mr-: good. :)
02:05:25 <quicksilver> :m doesn't look for files at all
02:05:29 <quicksilver> :m just changes the scope
02:05:50 <quicksilver> :m gives your ghci command line scope access to already-loaded modules (a bit like 'import') but it doesn't load anything.
02:06:08 <mel-> i see
02:06:30 <mel-> so, when I start ghci, things like e.g. Data.Maybe is automatically loaded, but not in scope.
02:06:41 <mel-> (correct?)
02:07:02 <quicksilver> yes
02:07:09 <mel-> is there a difference between doing 'import Something' and ":m +Something"?
02:07:15 <mel-> (in ghci)
02:07:24 <quicksilver> (well ghci does also load packages on demand but that's a different level of abstraction)
02:07:35 <quicksilver> no, import was added as a synonym for :m recently
02:08:07 <mr-> oh, cool. I thought I'd remembered import not working in ghci :-)
02:08:57 <mel-> So, how can I get what I want? i.e.: I am developing a haskell module. I want to try it out interactively. Shall I (and can I always) simply load the Hs file? Or can I have an equivalent of 'import Something' in to-be-compiled files?
02:09:15 <hape01_> mel: In my opinion  import xxxx  and  :m +xxxx  is identical in GHCI
02:09:38 * mel- nods
02:10:06 <quicksilver> :load the hs file is the normal way
02:10:19 <mel-> okay, thank you!
02:10:27 <quicksilver> and that will compile if necessary and load other files as needed
02:37:50 * hackagebot console-program 0.3.1.1 - Interpret the command line and contents of a config file as commands and options  http://hackage.haskell.org/package/console-program-0.3.1.1 (AriePeterson)
02:43:10 <raymank26> supki: thanks. It's magic O_o
02:46:23 <veryrandomname> is there some datatype that has this kind of composition? compose f g = \a b -> f a (g a b) I think its an Reader Arrow, but I'm not sure
02:47:45 <bennofs> @pl \f g a b = f a (g a b)
02:47:46 <lambdabot> (line 1, column 10):
02:47:46 <lambdabot> unexpected "="
02:47:46 <lambdabot> expecting pattern or "->"
02:47:50 <bennofs> @pl \f g a b -> f a (g a b)
02:47:50 <lambdabot> liftM2 (.)
02:48:15 <quchen> Is there some order in which patterns are checked? For example if I have a function `f :: Int -> Maybe a -> a` with `f 0 (Just x) = x`, will the "Int" parameter be strict? The comparison to 0 is unnecessary in this case after all.
02:48:44 <quchen> In other terms, is there some left-to-right order in pattern matching?
02:51:25 <johnw> how could that matter?
02:53:56 <bennofs> Does it make any sense to unpack newtype fields and to make them strict?
02:54:08 <donri> quchen: i think it will be forced because it has to to match, and it has to match even if you don't use it
02:54:11 <quicksilver> johnw: it would be observable in terms of what error message you got out of _|_ I guess
02:54:41 <quicksilver> quchen: why do you think the comparison with 0 is unnecessary?
02:54:49 <quchen> donri: Oh, you're right. I missed that there may be another pattern involving (Just x).
02:54:53 <quicksilver> quchen: if the Int isn't 0 then that branch must not be taken.
02:55:08 <quicksilver> quchen: even if there is no other branch, the correct response will be an unmatched pattern error
02:55:21 <bennofs> let f ~0 (Just x) = x in f undefined (Just 3)
02:55:22 <quicksilver> the branch may not be taken if the first parameter is non-0.
02:55:23 <bennofs> > let f ~0 (Just x) = x in f undefined (Just 3)
02:55:25 <lambdabot>   3
02:55:29 <quchen> quicksilver: I see it now and am slightly embarassed about missing it ;-)
02:55:36 <quicksilver> :)
02:55:43 <t7> i have an ethical dilemma
02:56:04 <bennofs> > let f ~0 (Just x) = x in f 10 (Just 3)
02:56:05 <lambdabot>   3
02:56:08 <bennofs> that's funny
02:56:11 <quchen> quicksilver: ALTHOUGH
02:56:33 <t7> i have a structure like a list and a state which depends on all elements in the list, in order
02:56:54 <t7> i could store the current state as an element in the list structure to save me from calculating it over and over again
02:57:08 <t7> but that seems impure :|
02:57:11 <mr-> bennofs: whati, what? How does that work? ;-)
02:57:15 <t7> because it could be stateless
02:57:16 <quchen> quicksilver: Suppose I've got "f 0 (Just x) = x; f y Nothing = y". If I apply that function to a Nothing, it is clear that the "Just" branch is not to be taken. Will the first parameter be forced?
02:57:29 <quchen> quicksilver: I am un-embarassed now.
02:57:40 <quicksilver> quchen: that is, I think, a reasonable question.
02:57:51 * hackagebot cabal2nix 1.54 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.54 (PeterSimons)
02:57:54 <quicksilver> I would guess that implementation-defined.
02:57:56 <quchen> quicksilver: That is the question I meant to ask in the first place, but then got lost in thinking my question was dumb :>
02:57:58 <arkeet> it matches parameters in order, I thought.
02:58:06 <quicksilver> patterns are checked in order
02:58:07 <quchen> quicksilver: Hmm, I'll have a look at the report I guess
02:58:15 <bennofs> mr-: It is a lazy pattern. So it's not checked until variables matched in it are evaluated. Because ~0 doesn't have any variables in it, the pattern will neber be checked
02:58:16 <quicksilver> but I don't recall it being specified if all patterns must be matched
02:58:24 <quchen> quicksilver: But "0" isn't really a pattern anyway
02:58:33 <quicksilver> quchen: in the sense of the report it is
02:58:37 <quicksilver> it is an odd pattern certainly
02:58:43 <quchen> Oh? I thought it was sugar
02:58:45 <quicksilver> but I don't think that really matters for your question
02:58:55 <arkeet> hmm
02:58:55 <quicksilver> it could be [] and the same question is still interesting
02:58:57 <arkeet> now I'm not so sure.
02:59:11 <quicksilver> quchen: logically it's sugar but the report defines it as a pattern.
02:59:18 <bennofs> > let f 0 ~(Just x) = x in f Nothing -- mr-: Gives an error because x is evaluated (=> Pattern checked)
02:59:19 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
02:59:19 <lambdabot>    arising from a use o...
02:59:25 <bennofs> > let f 0 ~(Just x) = x in f 0 Nothing -- mr-: Gives an error because x is evaluated (=> Pattern checked)
02:59:26 <lambdabot>   *Exception: <interactive>:3:5-21: Irrefutable pattern failed for pattern (D...
02:59:38 <quchen> Well it does matter whether it's a pattern or sugar, because suppose "f 0 (Just x)  ===  f y (Just x) | x == 0", then applying it to Nothing would not force the y
03:00:00 <bennofs> > let f 0 ~(Just x) = 0 in f 0 Nothing -- mr-: Doesn't give an error because x is never evaluated, hence the pattern isn't checked
03:00:01 <lambdabot>   0
03:00:18 <johnw> I suppose so
03:00:21 <quchen> s/x==0/y==0
03:00:22 <mr-> bennofs: interesing.
03:00:58 <mr-> bennofs: For now that translates to "~ is dangerous" for me
03:01:33 <bennofs> mr-: Yes, it's called irrefutable pattern and should only be used when your sure that the pattern matches. (For example, in ~(a,b)).
03:02:04 <arkeet> interesting!!
03:02:17 <mr-> Cool, thanks
03:02:23 <arkeet> the f 0 (Just x) version matches the 0 first
03:02:31 <arkeet> while f n (Just x) | n == 0 doesn't
03:02:42 <quchen> Oh.
03:02:44 <quchen> So it's not sugar
03:02:46 <quchen> Hm.
03:02:54 <bennofs> arkeet: But that's even defined in the report, isn't it?
03:02:56 <quchen> Alright, I'm going to waste that byte and add a bang pattern
03:02:58 <johnw> but I wonder if the Haskell report actually says  that
03:03:01 <bennofs> that f n (Just x) | n == 0 doesn't match n == 0 first
03:03:09 <arkeet> you can test this by making a type that's an instance of Eq and Num, that blows up on equality tests.
03:03:10 <johnw> (i.e., whether it gives a specific ordering)
03:03:11 <donri> f ((== 0) -> n) (Just x)  -- what about this? :)
03:03:31 <quicksilver> well what GHC does is one thing
03:03:37 <quicksilver> (I bet it forces all the patterns)
03:03:46 <donri> arkeet: can't you just put some bottoms in there
03:03:47 <quicksilver> but I was pondering what the standard requires
03:03:50 <bennofs> donri: Is that haskell?
03:03:55 <donri> bennofs: view patterns
03:03:59 <donri> ghc ext
03:04:04 <arkeet> donri: yes, in the Eq instance.
03:04:21 <arkeet> interesting, the view pattern version does the same thing as the guards.
03:04:32 <donri> arkeet: f (error "1") (error "2") see what error is forced?
03:04:42 <arkeet> wait, never mind
03:05:13 <arkeet> f ((==0) -> True) (Just x)  -- donri: I think this is what you meant.
03:05:22 <donri> quite
03:05:28 <donri> it's what i wrote in my mind ;)
03:05:39 <arkeet> it's "1" for the 0 pattern and the view pattern, and "2" for the guard.
03:06:12 <bennofs> So view patterns let me write (x ^? _SomePrism -> Just value) as a pattern? Sounds awesome
03:06:30 <arkeet> no x
03:06:40 <arkeet> the thing on the left of -> is  a function.
03:06:44 <donri> :t preview -- is nice for this
03:06:44 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
03:06:45 <arkeet> preview _SomePrism  works.
03:07:02 <bennofs> :) That's nice
03:07:12 <donri> didn't the original view patterns proposal include a special syntax for maybe?
03:07:28 <arkeet> > let f (preview _head -> Just a) = Just a; f _ = Nothing in [f [], f [1]]
03:07:29 <lambdabot>   Illegal view pattern:  preview _head -> Just a
03:07:29 <lambdabot>  Use -XViewPatterns to enabl...
03:07:32 <arkeet> argh
03:07:58 <arkeet> when did it become 3am. good night =)
03:08:09 <donri> :t _head
03:08:10 <lambdabot> Cons (->) f s s a a => LensLike' f s a
03:08:15 <johnw> I like how it parses it enough to know what it is, even though it's not enabled
03:09:17 <arkeet> well I suppose it became 3am at 3am.
03:09:37 <donri> it's not 3 am for some 15 hours, dude
03:09:38 <mr-> give or take..
03:09:50 <chexxor> I remove the ([]), but I don't understand the diff tween these two expressions. Help? -- every n xs = firstLetter : every n restLetters AND every n xs = [firstLetter : every n restLetters]
03:11:03 <arkeet> > 1 : [2]
03:11:04 <lambdabot>   [1,2]
03:11:05 <arkeet> > [1 : [2]]
03:11:07 <lambdabot>   [[1,2]]
03:11:14 <donri> chexxor: [expr] is a singleton list containing expr. x:xs is the expression x prepended to the list expression xs
03:11:28 <donri> chexxor: so in the second case you have a list of lists
03:12:13 <chexxor> Ok, so this is same as first one? -- firstLetter : every n restLetters : []
03:12:29 <johnw> that would be [1,[2]]
03:13:22 <arkeet> that would be a type error, most likely.
03:13:30 <chexxor> yeah
03:13:41 <chexxor> thanks, I'll play in ghci, as you showed
03:13:58 <donri> > [1,2] : []
03:13:59 <lambdabot>   [[1,2]]
03:14:05 <arkeet> just remember, in x : xs,  if x is a thing, then xs is a list of things.
03:14:13 <arkeet> and x : y : xs parses as x : (y : xs)
03:14:30 <arkeet> and in firstLetter : (every n restLetters : [])
03:14:39 <arkeet> every n restLetters : []  would be a list of lists of letters.
03:14:39 <johnw> > 1 : [2] : []
03:14:41 <lambdabot>   No instance for (GHC.Show.Show t0)
03:14:41 <lambdabot>    arising from a use of `M723509849.sho...
03:14:51 <johnw> ah, right
03:14:55 <arkeet> so firstLetter : (every n restLetters : []) wouldn't work.
03:14:57 <chexxor> I am getting confused with the list's pattern -matching syntax
03:15:37 <jmcarthur> [a,b,c] ==> a:b:c:[]
03:15:57 <jmcarthur> a:(b:(c:[]))
03:16:31 <chexxor> if I can't use head, what's the next best way to get the first element of a list?
03:16:32 <jmcarthur> (:) a ((:) b ((:) c []))
03:16:44 <chexxor> because head crashes on empty list
03:16:47 <jmcarthur> it depends
03:16:54 <arkeet> chexxor: first think about what it should do when the list is empty.
03:16:54 <jmcarthur> what will you do if the list is empty?
03:16:57 <raichoo1> !list
03:16:58 <monochrom> raichoo1: http://hackage.haskell.org/packages/archive/pkg-list.html
03:17:16 <raichoo1> huh. I though that gave an oleg link. narf ^^
03:17:31 <chexxor> hmm...
03:18:00 <chexxor> then return.... nothing? hmmm, idk exactly
03:18:04 <arkeet> !list
03:18:04 <monochrom> arkeet: http://lpaste.net
03:18:24 <donri> :t listToMaybe
03:18:25 <lambdabot> [a] -> Maybe a
03:18:32 <arkeet> aka safeHead
03:18:37 <donri> worst name ever ;)
03:18:40 <arkeet> safeFromJust :: Maybe a -> Maybe a
03:18:41 <johnw> or headMay
03:18:45 <chexxor> lol
03:18:47 <johnw> or just head, if you use safe-failure
03:19:03 <jmcarthur> chexxor: ^^ will give the first element if it exists. you can use fmap and stuff to get to the value from there if pattern matching doesn't make sense
03:19:07 <arkeet> but actually, how to handle [] depends on what you're really trying to do.
03:19:19 <jmcarthur> @hackage safe-failure
03:19:19 <lambdabot> http://hackage.haskell.org/package/safe-failure
03:19:23 <chexxor> yeah, I'm starting to see that...
03:19:55 <jesyspa> If I have a parser and lexer (both using parser combinators) is there any "common" way to auto-generate parsers for each lexer alternative?  For example, if my data Token = Identifier String | Arrow, can I avoid writing out pIdentifier :: Parser String, pArrow :: Parser ()?  I've heard of TH, but I'm wondering if there's a simpler solution.
03:20:46 <jmcarthur> johnw: do you use safe-failure? do you like it?
03:20:57 <jmcarthur> i haven't given a very serious look to the various error handling packages
03:21:05 <johnw> I'm a big fan of the failure package, but I haven't yet started using it; it's on my list for the next project
03:21:11 <jmcarthur> i've always been fine with Either
03:21:14 <johnw> (haven't yet started using safe-failure, that is)
03:21:18 <johnw> well, a Failure can be Either
03:21:30 <jmcarthur> how does Control.Failure actually differ from mtl's MonadError?
03:21:31 <arkeet> you guys are so negative. I should make a package called success
03:21:50 <johnw> Failure is just a type class for any value or monad which has a way to represent failure
03:21:56 <mr-> arkeet: success is the rule, failure the exception!
03:22:03 <johnw> so, Either, IO (using exceptions), Maybe, etc.
03:22:04 <jmcarthur> ah, there is no catch
03:22:09 <johnw> right
03:22:13 <johnw> it's not error handling, just error representation
03:22:26 <jmcarthur> so really it's just a generalized version of fail
03:22:39 <bennofs> We should really make a success package, providing a product type called (:>) :)
03:22:48 <arkeet> :>
03:22:51 <jmcarthur> without the pattern matching sugar
03:23:19 <johnw> it's not exactly the same as fail
03:23:48 <johnw> say you had a MaybeT with five statements in it, and the fourth one failed.  With fail, you'd just get a Nothing.  With 'failure' you always have the option to analyze the result as an Either and pick out the reason for the failure
03:23:59 <jmcarthur> ew...   (MonadTrans t, Failure e m, Monad (t m)) => Failure e (t m)
03:24:27 <jmcarthur> so if i want a transformer with its own Failure instance i have to use overlapping instances :(
03:24:31 <arkeet> =(
03:25:07 <johnw> please log issues if you think something can be improved
03:25:15 <johnw> snoyberg and I are acutally going to be actively working on this library next month
03:25:30 <arkeet> failure is not an option!
03:25:31 <johnw> wer'e gearing up for that work at the moment, and a consideration like that is something I'll bring up
03:25:32 <bennofs> jmcarthur: That instance does rarely do what you want
03:25:48 <johnw> in fact, I'll open an issue now
03:25:50 <arkeet> (it's mandatory!)
03:26:12 <donri> Option is not failure! (but Maybe it is)
03:26:19 <arkeet> =(
03:26:41 <arkeet> 'night
03:26:54 <donri> hah, like you'll *actually* go to bed
03:27:10 <johnw> jmcarthur: https://github.com/snoyberg/failure/issues/2
03:27:28 <jmcarthur> man, i never considered what i actually expect fail to do for transformers (i rarely depend on fail intentionally)
03:27:58 <jmcarthur> in fact, fail is ad hoc enough that i only ever use it in a monomorphic context
03:28:05 <exicer> Could someone help me understand the "then" operator (>>) ?
03:28:08 <jmcarthur> because i don't know what it will do otherwise
03:28:19 <exicer> What is it used for ?
03:28:53 <jmcarthur> exicer: performing some action and then another without getting the result from the first
03:29:05 <donri> one problem with 'fail' is the default fail = error, which is often left in
03:29:22 <jmcarthur> donri: i think i may have implemented fail explicitly only once
03:29:24 <RichyB> exicer, (action1 >> action2) is an action which, when run, will do the things that action1 would do, then does the things that action2 would do, with the result that action2 would give.
03:29:37 <jmcarthur> donri: it's not like i normally have anything better to do for it
03:30:13 <donri> yeah, it really should be a separate class
03:30:26 <jmcarthur> exicer: (a >> b) has the effects of both a and b, in order, but only the result of b
03:30:45 <jmcarthur> (trying to clean up my first explanation)
03:30:59 <jmcarthur> separate MonadFail ftw
03:31:21 <jmcarthur> totally not backward compatible though :(
03:31:22 <donri> but then that might make the desugaring of do notation rather more complex
03:31:28 <arkeet> jmcarthur: and we can call it MonadZero.
03:31:31 <donri> if you want the type inferred based on refutability
03:31:41 <jmcarthur> arkeet: mzero is different, IMO
03:31:48 <jmcarthur> arkeet: no error message argument
03:31:56 <jmcarthur> donri: yeah
03:32:07 <bennofs> donri: That'd be nice. Then we can also make do notation without bindings only require Applicative!
03:32:13 <jmcarthur> donri: well, not the type really. just the pattern it generates
03:32:28 <donri> bennofs: quite
03:32:36 <arkeet> that would be cool.
03:32:40 <jmcarthur> yeah, that'd be awesome
03:32:46 <donri> bennofs: well bindings would be ok
03:33:10 <jmcarthur> for bindings to be okay would require something really fancy
03:33:17 <bennofs> Right, just not bindings dependend on other bindings?
03:33:28 <donri> quite
03:33:44 <jmcarthur> not only that
03:33:52 <bennofs> That's reminds me of arrow syntax
03:34:01 <donri> yes, that's what i'm thinking
03:34:04 <bennofs> jmcarthur: That's not enough?
03:34:04 <hashcat> hi, is there a better choice to do meta programming rather than template haskell?
03:34:05 <jmcarthur> do { x <- foo; bar x }   -- depends on what bar is
03:34:24 <jmcarthur> hmm... maybe that is enough
03:34:25 <donri> although i think the type could in theory be inferred without different syntactical arrows
03:34:34 <jmcarthur> ah, no, it's not enough
03:34:49 <bennofs> jmcarthur: Show me an example where my rule fails
03:35:11 <donri> http://hackage.haskell.org/packages/archive/applicative-quoters/0.1.0.8/doc/html/Control-Applicative-QQ-ADo.html
03:35:40 <jmcarthur> bennofs: for the example i gave above,   bar 0 = Just x; bar _ = Nothing
03:35:45 <exicer> Hmm. I don't quite get the type signature of (>>) then
03:35:51 <donri> "Note the only expression which has the bound variables in scope is the last one."
03:35:56 <exicer> (>>) :: Monad m => m a -> m b -> m b
03:36:13 <exicer> Ah, it actually seems that I just don't understand actions
03:36:13 <mr-> exicer: do you understand >>= ?
03:36:24 <exicer> mr-: I believe so..
03:36:35 <jmcarthur> bennofs: if the effects of bar depend on x, then the rule doesn't work
03:37:14 <bennofs> jmcarthur: Well, it would require something like dataflow analysis, to see which effects depend on values.
03:37:38 <donri> exicer: if you say (m a) is the effects (m) coupled with the result (a) then (>>) sequences the effects, discarding the result of the LHS
03:37:42 <exicer> So if I do ['a'] >> [1]
03:37:43 <jmcarthur> bennofs: yeah, and it would no longer be just syntax sugar
03:37:45 <exicer> I just get 1 ?
03:37:57 <bennofs> Hmm, but maybe then we've just got Arrow
03:38:00 <jmcarthur> bennofs: it would have to go into the definitions of all the subexpressions
03:38:10 <donri> exicer: you still get the effects of the LHS
03:38:22 <donri> > "abc" >> [1]
03:38:23 <lambdabot>   [1,1,1]
03:38:28 <donri> > "abc" >> [1,2]
03:38:30 <lambdabot>   [1,2,1,2,1,2]
03:38:41 <exicer> ..okay, I did not expect that
03:39:18 <exicer> So what is the "effect" for the a list ?
03:39:25 <jmcarthur> > Nothing >> Just x
03:39:30 <lambdabot>   Nothing
03:39:35 <donri> > [ rhs | lhs <- "abc", rhs <- [1,2] ]
03:39:37 <lambdabot>   [1,2,1,2,1,2]
03:39:38 <jmcarthur> > Just a >> Just x
03:39:40 <lambdabot>   Just x
03:39:50 <donri> exicer: it's basically like that list comprehension
03:40:06 <exicer> donri: Okay.. but what does it mean?
03:40:09 <exicer> Why is that a useful thing ?
03:40:18 <donri> exicer: it still traverses the lhs, that's the "effect" of the list monad, but it doesn't include it in the result
03:40:28 <jmcarthur> > "abc" >>= \x -> [1,2,3] >>= \y -> return (x, y)
03:40:30 <lambdabot>   [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
03:41:23 <exicer> donri: Hm, okay
03:41:57 <donri> exicer: not sure it's used that often for the list monad in particular. very useful in many other monads though!
03:42:08 <exicer> Heh, well I can believe that
03:42:08 <donri> > [] >> [1,2]
03:42:10 <lambdabot>   []
03:42:17 <donri> "lists as failure"
03:42:24 <donri> > Nothing >> Just 1
03:42:25 <lambdabot>   Nothing
03:42:30 <exicer> Is there a good explanation of the effects of various monads you could point me to ?
03:42:47 <exicer> I suppose IO would be a good one for me to try and understand first
03:42:59 <donri> exicer: the Source link in the haddocks for the monads ;)
03:43:13 <donri> @src [] (>>=)
03:43:14 <lambdabot> xs >>= f     = concatMap f xs
03:43:29 <jmcarthur> exicer: IO is a weird monad because its effects are basically not definable in haskell without IO itself
03:43:31 <exicer> donri: I need examples! The docs seem to be written for people who alraedy know what they are talking about :p
03:44:06 <bennofs> > Left 3 >> Right 4
03:44:07 <lambdabot>   Left 3
03:44:08 <exicer> jmcarthur: Hm, okay
03:44:19 <bennofs> > Right a >> Right 4
03:44:21 <lambdabot>   Right 4
03:44:22 <donri> @src concatMap
03:44:22 <lambdabot> concatMap f = foldr ((++) . f) []
03:44:46 <bennofs> > Right 3 >> Right 5 >> Right 6 >> Right 7
03:44:48 <lambdabot>   Right 7
03:44:51 <donri> > concapMap (const [1,2]) "abc"
03:44:52 <lambdabot>   Not in scope: `concapMap'
03:44:52 <lambdabot>  Perhaps you meant one of these:
03:44:52 <lambdabot>    `concatMap' (...
03:44:54 <bennofs> > Right 3 >> Right 5 >> Left fail >> Right 6 >> Right 7
03:44:55 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable1 m0)
03:44:55 <lambdabot>    arising from a use...
03:44:59 <donri> > concatMap (const [1,2]) "abc"
03:44:59 <bennofs> > Right 3 >> Right 5 >> Left 1 >> Right 6 >> Right 7
03:45:00 <lambdabot>   [1,2,1,2,1,2]
03:45:01 <lambdabot>   Left 1
03:45:22 <donri> exicer: do you understand const?
03:45:24 <donri> @src const
03:45:24 <lambdabot> const x _ = x
03:45:37 <exicer> donri: I don't think I have come across it
03:45:53 <donri> > map (const [1,2]) "abc"
03:45:54 <quicksilver> exicer: http://www.haskell.org/haskellwiki/All_About_Monads
03:45:54 <lambdabot>   [[1,2],[1,2],[1,2]]
03:46:05 <wojtekM_> @src <$>
03:46:06 <lambdabot> f <$> a = fmap f a
03:46:06 <donri> > concat (map (const [1,2]) "abc")
03:46:06 <quicksilver> exicer: (is an explanation of the effects of various monads)
03:46:07 <lambdabot>   [1,2,1,2,1,2]
03:46:08 <exicer> > Nothing >> Just 'a' >> Nothing
03:46:09 <quicksilver> it's quite long though
03:46:09 <lambdabot>   Nothing
03:46:25 <exicer> quicksilver: I'll have a read.
03:46:27 <wojtekM_> Sorry list, I couldn't resist, this is so cool.
03:46:39 <quicksilver> you could skip ahead to the later chapters, exicer
03:46:51 <quicksilver> chapters 9-16 go through particular monads
03:47:28 <exicer> quicksilver: Ok cool. I'll see how I get on :)
03:48:07 * hackagebot http-conduit 1.9.4.3 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.4.3 (MichaelSnoyman)
03:48:20 <wojtekM_> Is there an  'at' src in ghci?
03:48:44 <donri> nope, lambdabot has a hand written db
03:48:50 <bennofs> wojtekM_: What should it do?
03:48:51 <donri> it doesn't know everything
03:49:05 <wojtekM_> display source
03:49:14 <donri> your best bet is to find the haddocks on hackage and click the Source link on the right
03:49:42 <wojtekM_> bennofs: a command in ghci to display source like src does
03:50:27 <donri> you can use hoogle on the command-line to find some of those haddock links though, and you can use the command line from ghci
03:52:01 <wojtekM_> well, so basically 'no' is my answer :-)
03:52:31 <donri> well you *can* set up lambdabot locally and use it from the command line and ghci, i think
03:53:25 <wojtekM_> well, okay, but ghci knows the context (loaded modules)
03:53:29 <donri> but as i said, the database is not complete, and often even not the same as what's actually in the libraries
03:54:00 <donri> it doesn't actually scan the files and find the source for you
03:54:25 <wojtekM_> okay, I'm good
03:54:58 <donri> wojtekM_: https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source
03:56:16 <bennofs> To use hayoo from GHCi, you can type: :def hayoo return . mappend "":!firefox http://holumbus.fh-wedel.de/hayoo/hayoo.html?query="
03:56:31 <bennofs> and :hayoo blah will open hayoo in firefox :)
04:00:35 <wojtekM_> I do not have a web browser on my server.
04:01:13 <SaBer> wojtekM_: not even links or lynx?
04:01:20 <wojtekM_> Hey, never mind. I can find the source code if I have to.
04:01:24 <wojtekM_> Lynx I do have
04:01:44 <chexxor> arkeet and johnw - Thanks for your help! I made big progress! Got one implementation working and will figure out the second one tomorrow.
04:01:58 <chexxor> afk
04:05:27 <carp> mee: hi I just read the tim sweeney presentation 'The Next Mainstream Programming Language' that you linked yesterday. Its interesting, thanks. I saw a link to it on the Haskell site previously but skipped over it initially.
04:11:58 <simukis_> `at-pl` does no type checking :(
04:13:23 <petapetapeta> What is the idiomatic way of first replacing som characters in a string and then splitting with a specific character?
04:13:49 <hpaste_> petapetapeta pasted “Replace & split” at http://lpaste.net/8052496306230263808
04:14:00 <petapetapeta> IS the current way I'm doing it
04:16:16 <quicksilver> well that looks reasonable although you don't need to name the intermediate value m_new unless you want it for some reason
04:16:28 <quicksilver> fields = split "," (replace "." "" m)
04:17:11 <petapetapeta> Okay :) Thank you
04:19:30 <bennofs> Hmm, using Arrows Syntax with StaticArrow comes closes to Applicative do
04:23:22 <kier> @type (<*>) . (\f x -> f <*> pure x)
04:23:23 <lambdabot> (a -> a1 -> b) -> (a1 -> a) -> a1 -> b
04:27:53 <Placinta> Hi. Is there a function similar to fromJust, if the value given to it is Nothing, it throws an exception with custom string I define?
04:28:21 <hpc> :t (maybe . error)
04:28:21 <lambdabot> [Char] -> (a -> b) -> Maybe a -> b
04:28:24 <kier> fromMaybe (error "something went wrong!") maybeValue
04:28:25 <mr-> maybe?
04:28:35 <hpc> er, fromMaybe was it
04:28:41 <hpc> :t (fromMaybe . error)
04:28:42 <lambdabot> [Char] -> Maybe b -> b
04:28:46 <hpc> > fromMaybe Nothing
04:28:47 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
04:28:48 <lambdabot>    arising from a use ...
04:28:58 <Placinta> fromMaybe returns a default value
04:30:28 <quicksilver> right, and hpc is suggesting you use 'error "foo"' as the default value
04:30:41 <Placinta> That means the value in the Maybe has to be string
04:30:49 <quicksilver> no it does not.
04:30:54 <quchen> Is there a version of GroupBy that allows multiple different groups? For example, I'd like to group "aabbeeezzz" according to both "is vowel" and "is in the second half of the alphabet", giving me ["aa", "bb", "eee", "zz"]
04:31:18 <quicksilver> :t fromMaybe (error "value not present") (1 :: Int)
04:31:19 <lambdabot>     Couldn't match expected type `Maybe a0' with actual type `Int'
04:31:20 <lambdabot>     In the second argument of `fromMaybe', namely `(1 :: Int)'
04:31:20 <lambdabot>     In the expression: fromMaybe (error "value not present") (1 :: Int)
04:31:46 <quicksilver> :t \x -> fromMaybe x (error "value not present") (1 :: Int)
04:31:46 <lambdabot> (Int -> t) -> t
04:31:52 <quicksilver> !
04:31:55 * quicksilver feels slow today
04:32:22 <quicksilver> :t fromMaybe (error "value not present")
04:32:23 <lambdabot> Maybe a -> a
04:32:28 <quicksilver> ^^ no string requirement
04:32:35 <quicksilver> > fromMaybe (error "value not present") (Just 1)
04:32:36 <lambdabot>   1
04:33:01 <quicksilver> quchen: sure, just specify that equivalence relation
04:33:37 <quchen> quicksilver: What do you mean with that? (I understand the single words, but not the sentence)
04:33:37 <quicksilver> groupBy (\a b -> (isVowel a && isVowel b) || (isSecondHalf a && isSecondHalf b) || a == b)
04:33:57 <quicksilver> if you can meaningfully group by it, it must be an equivalence relation
04:34:01 <quicksilver> just pass that to groupBy
04:34:04 <quchen> Oh, right.
04:34:14 <quchen> Thanks again. :-)
04:34:33 <Placinta> Thanks quicksilver
04:42:32 <Placinta> Couldn't match expected type `ByteString' with actual type `ByteString'. Now I've seen everything. Could this be because of lazy vs strict versions?
04:43:10 <quicksilver> yes, Placinta
04:43:22 <quicksilver> almost certainly is exactly that. Since those two types have hte same name.
04:43:25 <quicksilver> it's a bit annoying.
04:44:48 <bergmark> hmm i thought you'd get one of them qualified in the error message since you didn't import both of them
04:45:47 <Placinta> quicksilver: Yep, that was the case. Like bergmark, I expected some namespace hints though.
04:48:01 <Ghoul_> does haskell writeFile open the file in text or binary mode?
04:49:30 <Cale> text
04:49:38 <Ghoul_> bugger
04:49:58 <Ghoul_> is there an easy way to do the same, except in binary mode?
04:50:28 <Ghoul_> I have a Haskell powered test suite and its giving test failures because Windows is inserting a lot of extra \r's in text mode! haha
04:50:57 <Cale> Well, if you want binary mode in the first place, you're probably better off using Data.ByteString
04:51:14 <Cale> But you could also use withFile and the stuff in System.IO to set the Handle mode
04:51:29 <Ghoul_> So, if I use the ByteString writeFile, it'll be binary mode?
04:51:41 <Cale> withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
04:51:50 <Cale> yeah
04:53:28 <wojtekM_> Is there a Haskell implementation of Java Object Serialization Stream Protocol? I couldn't find one.
04:54:20 <wojtekM_> What I need is _de_serialization.
04:54:55 <kier> does it need to be compatible with Java's protocol, or are you just looking for a similar serialisation toolkit?
04:55:49 <wojtekM_> It has to be exactly Java serialization
04:56:24 <kier> ah, I'm afraid I don't know of a package that does that.
04:56:57 <kier> It's likely that the problem of trying to map Java's type system onto Haskell's is inhibiting the creation of one
04:57:29 <Cale> It's quite possible that you're the first one to need it.
04:57:32 <wojtekM_> Actually, Java type system is limited.
04:57:48 <Cale> I doubt that the problem is that Java types are too hard to express here :)
04:58:10 <Cale> (at the very least, a parser for this format seems quite doable, if a reasonable bit of work)
04:59:44 <wojtekM_> Cale: days, weeks, months? (Roughly)
05:00:05 <Cale> I would expect days
05:00:30 <Cale> http://docs.oracle.com/javase/7/docs/platform/serialization/spec/protocol.html#10258 gives a grammar
05:03:06 <Cale> http://hackage.haskell.org/package/attoparsec -- you might want to use this library to implement the parser
05:09:32 <Taneb> I think when you get to three nested foldrs, you start wondering if you are doing the right thing
05:11:13 <Cale> Define things
05:11:31 <Cale> (rather than using them in place)
05:12:19 <mbrock> java object deserialization sounds a little fun
05:14:56 <mbrock> http://stackoverflow.com/posts/16470856/revisions
05:16:43 <mbrock> there's a scary python implementation, doing some special-casing of common collection classes
05:17:32 <LazinCajun> i have a beginner question about why this particular implementation of elem using foldr terminates with an infinite list.  I think I have a grasp on why foldr can terminate, and i understand why elem can terminate (strictness of ||=), but I don't get this :
05:17:34 <LazinCajun> elem' y ys  = foldr (\x acc -> if x==y then True else acc) False ys
05:18:44 <mbrock> @src foldr
05:18:44 <lambdabot> foldr f z []     = z
05:18:44 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:19:25 <mbrock> if f doesn't touch the accumulator parameter, it won't be evaluated
05:20:20 <mbrock> so the recursion will finish leaving (foldr f z xs) as an uneval'ed thunk to be garbage collected
05:21:50 <LazinCajun> ouch my brain
05:22:46 <LazinCajun> ok that makes some sense, but i need to think about it a bit more carefully.  thanks
05:22:52 <mbrock> infinity is known to cause brain pain in us puny mortals -- you can try thinking about elem 3 [1, 2, 3, undefined]
05:23:15 <mbrock> you can even try manually expanding the foldr equation
05:23:42 <mbrock> after some steps you'll get if 3==3 then True else undefined
05:23:54 <mbrock> which evaluates to True without exploding
05:24:16 <jmcarthur_mobile> That's the way to go. Don't think about thunks. Just reduce the expression by hand.
05:24:38 <jmcarthur_mobile> Thanks are for thinking about GHC. Reduction is for thinking about Haskell.
05:24:54 <jmcarthur_mobile> Thunks *
05:24:55 <LazinCajun> ahhh ok! I was trying to do just that, but for some reason i was skipping the 3==3 step, and going straight to if 4==3 then true else acc (when acc==True), and I couldn't figure out how it would end.  derp! thanks :)
05:24:59 <LazinCajun> got it now
05:26:15 <mbrock> jmcarthur_mobile: good point
05:27:56 <jmcarthur_mobile> You are allowed to start thinking about thunks when you are reading core from GHC.
05:28:26 <mbrock> LazinCajun: it takes a bit of mental rewiring to grok the implications of lazy evaluations... but it's fundamentally pretty simple
05:30:25 <identity> Is there any real reason to use parsec over attoparsec in general?
05:30:42 <identity> I know there's a reason to use attoparsec over parsec in many cases, speed, bytestrings, etc
05:32:52 <LazinCajun> mbrock: all it takes is advil and caffeine
05:32:54 <jpcooper> hello
05:33:23 <jpcooper> does anyone know of some recent papers on the subject of writing fast code in Haskell for data processing and the like?
05:34:55 <identity> jpcooper: Have you read all the stuff on parallel and concurrent haskell?
05:35:46 <jpcooper> I've read bits and bobs. I'm not looking for things focussed only on parallelism, though
05:36:18 <identity> jpcooper: www.slideshare.net/tibbe/highperformance-haskell you might want to check that one out. I liked it, anyway. It's not a paper, but slides
05:36:24 <identity> not sure if you can use it, though.
05:36:58 <jpcooper> this looks good. Thanks
05:38:17 <countoren> hello
05:39:26 <countoren> im trying to make vim tagbar works with hasktags but it seems that it not working , im getting empty tagbar window altho i have tags file in my project path
05:42:34 <donri> countoren: maybe try lushtags
05:42:47 <Kaini> @pl \a b c = a * b * c
05:42:47 <lambdabot> (line 1, column 8):
05:42:47 <lambdabot> unexpected "="
05:42:47 <lambdabot> expecting pattern or "->"
05:42:54 <Kaini> @pl \a b c -> a * b * c
05:42:54 <lambdabot> ((*) .) . (*)
05:43:35 <countoren> i tryed lasgtags b4 and it worked
05:43:44 <Kaini> :t multiply
05:43:44 <lambdabot> Not in scope: `multiply'
05:43:49 <countoren> but i want to use hasktags
05:44:07 <donri> countoren: why?
05:44:11 <countoren> im not sure if there confilcts between the 2
05:45:19 <countoren> becuase lashtags generate tags the same file im working on
05:45:41 <countoren> this what  u told me  (donri)
05:47:17 <timbod> Does anyone else find profiling in haskell frustrating? I'm fine with the fact that everything must be compiled with profiling enabled, but it's annoying that I have to sort this out manually.
05:47:59 <timbod> cabal can work out which packages need to be installed, it would seem reasonble that it could work out which packages need to be re-installed with profiling turned on.
05:48:41 <ocharles> timbod: I find the result of profiling more frustrating
05:48:50 <timbod> ocharles: How is that?
05:48:51 <ocharles> i don't care about the work required to enable profiling
05:49:02 <ocharles> timbod: A single text file is not particularly managable
05:49:12 <donri> countoren: yes, but why are you trying to use hasktags with tagbar?
05:49:12 <ocharles> when I profile in Perl, for example - I get all my source files rendered as HTML
05:49:23 <ocharles> and I can click through each subroutine to work out what parts took the most time, etc
05:49:24 <timbod> You'd like some sort of gui like kcachegrind?
05:49:28 <ocharles> yea, I guess
05:49:38 <ocharles> though I have only seen kcachegrind and never really used it
05:49:40 <ParahSail1n> ive always said that the defaults for cabal should be library_profiling true
05:49:42 <donri> countoren: tagbar is for tags in the buffer, hasktags is for tags in a project
05:50:00 <timbod> kcachegrind is awesome in the C/C++ world.
05:50:14 <timbod> ParahSail1n: That would address my problem in a simple way.
05:50:24 <simukis_> (if only library_profiling didn't increase library build times… twice?)
05:50:25 <donri> countoren: use lushtags for tagbar and hasktags for normal tag operations :)
05:50:51 <countoren> o
05:51:04 <timbod> cabal is clever enough to work out what needs to be installed - it ought to work out what profiling libs need to be installed.
05:51:44 <timbod> But I suspect this is tied in with ghc-pkg somehow.
05:52:33 <timbod> The package only records whether a library is present, and not whether theres a profiling version of it.
05:53:21 <simukis_> Well… like somebody already suggested me… there's 2 solutions: 1. remove all packages and reinstall them; 2. use sandbox (to build profiling libraries for your project only);
05:54:35 <countoren> i dont understand why those two needs to be saperted (hasktags and lashtags) there is no 1 plugin that can control all tags in project and give me the tagbar window?
05:54:40 <timbod> simukis_: Yes - I use cabal-dev, which helps alot.
05:54:42 <bennofs> @@ There is @hackage tkyprof (Regarding profiling GUI), unfortunaly the yesod dependency hell currently makes it impossible to install it with just cabal install tkyprof (I didn't try manually changing version bounds)@@
05:54:42 <lambdabot>  There is http://hackage.haskell.org/package/tkyprof (Regarding profiling GUI), unfortunaly the yesod dependency hell currently makes it impossible to install it with just cabal install tkyprof (I
05:54:42 <lambdabot> didn't try manually changing version bounds)
05:55:14 <ocharles> i haven't heard of that
05:55:16 * ocharles checks it out
05:55:26 <timbod> I'm not suprised - look at the dependency list!
05:55:49 <timbod> bennofs: The screenshots look good.
05:55:56 <ocharles> oh nice, that's a step in the right direction
05:56:21 <ocharles> still not quite annotated source code
05:56:59 <bennofs> my cabal configure command gets so long when using profiling :P
06:00:17 <yitz> bennofs: you can use cabal install --constraint='pkg==1.2.3'
06:00:53 <bennofs> yitz: Can I even avoid upper version bounds with that method?
06:01:19 <yitz> bennofs: you can use multiple constraint arguments. i usually create a text file, use a shell loop to to wrap them in --constraint=, then keep adding constraints to the file until it compiles
06:01:50 <yitz> bennofs: oh and of course i do that inside a sandbox. new cabal from git *highly* recommended, or use cabal-dev or hsenv
06:02:07 <yitz> bennofs: you can put in whatever constraints you want
06:02:21 <wojtekM_> How do I get Word16 from two Word8 in an endian safe fashion?
06:02:33 <bennofs> I mean, if I have a project which depends on some_package < 2.3, can I do --constraint="some_package > 2.4" ?
06:02:37 <bennofs> yitz: ^^
06:03:04 <yitz> bennofs: you can also do --constraint='pkg +my-flag' to set cabal flags for packages. that is something you can't even do in build-depends in the cabal file.
06:03:42 <ocharles> wojtekM_: the largeword package can do that, iirc
06:03:43 <yitz> bennofs: umm. well it won't build then. you can only build one version of a package in each sandbox (currently)
06:03:56 <ocharles> ghc: panic! (the 'impossible' happened)
06:03:58 <ocharles> wahey
06:04:11 <yitz> bennofs: this is for the kind of cabal hell where a solution exists but cabal install can't find it. that's the usual case.
06:04:30 <yitz> ocharles: yay! good work! you're famous!
06:05:31 <bennofs> yitz: I did cabal install tkyprof in a clean sandbox, so --constraint won't help I think
06:05:50 <bennofs> (Because cabal can see all required package at once, so it should find a solution)
06:06:23 <bergmark> bennofs: then you might have to bump the deps of some package, unfortunately
06:12:43 <yitz> bennofs: i use it in sandboxes all the time.
06:12:48 <wojtekM_> ocharles: looks like an overkill
06:13:07 <yitz> bennofs: but if cabal solves the problem for you without that, then great!
06:13:11 <wojtekM_> In general, fromIntegral is supposed to be used for such conversions?
06:13:41 <wojtekM_> or should I have said coercions?
06:14:20 <wojtekM_> for example from Word8 to Word16?
06:15:35 <yitz> wojtekM_: for that it's fine. the other way - you'll have truncation problems.
06:31:53 <FardadJalili> I want a function which filters a list and collects very nth member.
06:32:03 <FardadJalili> s n xs = [snd p | p <- zip [1..] xs, fst p `mod` n == 0]
06:32:18 <FardadJalili> what is the elegant way to right this?
06:32:38 <FardadJalili> write* (facepalm)
06:36:46 <quicksilver> FardadJalili: "map head . iterate (drop n)" perhaps
06:36:55 <quicksilver> Franciman: not that I think your way is bad
06:37:12 <quicksilver> > map head . iterate (drop 7) $ [1..]
06:37:14 <lambdabot>   [1,8,15,22,29,36,43,50,57,64,71,78,85,92,99,106,113,120,127,134,141,148,155...
06:38:37 <tikhon> > map head . iterate (drop 7) $ [1..10]
06:38:38 <lambdabot>   [1,8,*Exception: Prelude.head: empty list
06:39:38 <tikhon> you could use chunk from Data.List.Split
06:40:33 <hpaste_> David pasted “Static Scotty” at http://lpaste.net/92065
06:43:18 <dmp1ce> I created a simple Scotty website which hosts static content here: http://lpaste.net/92065.  The issue I have with it is that I cannot change the static files.  Even if I restart the server the original file is returned.  I have to remove the file to force it to change.  Is there a flush function or something to clear the server cache?
06:43:56 <FardadJalili> > map head . iterate (drop 7) [1..7]
06:43:57 <lambdabot>   Couldn't match expected type `a0 -> [[b0]]'
06:43:57 <lambdabot>              with actual type `...
06:44:02 <zomg> dmp1ce: I'm not sure if that's actually related to the server. I had a similar issue with a local VM + a wai app with definitely no caching anywhere
06:44:11 <FardadJalili> > map head . iterate (drop 7) $ [1..7]
06:44:12 <lambdabot>   [1,*Exception: Prelude.head: empty list
06:44:47 <FardadJalili> > map (take 1) . iterate (drop 7) $ [1..7]
06:44:49 <lambdabot>   [[1],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[...
06:45:07 <simukis_> > map listToMaybe . iterate (drop 7) $ [1..7]
06:45:08 <lambdabot>   [Just 1,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Not...
06:45:53 <simukis_> > fromJust . sequence . catMaybes . map listToMaybe . iterate (drop 7) $ [1..7]
06:45:54 <lambdabot>   No instance for (GHC.Show.Show a0)
06:45:54 <lambdabot>    arising from a use of `M475741584.sho...
06:46:13 <dmp1ce> zomg: OK.  I am also using a VM.
06:46:13 <tikhon> catMaybes won't terminate
06:46:49 <dmp1ce> zomg: What did you end up doing?
06:46:54 <tikhon> also, take a look at the type of catMaybes
06:46:58 <tikhon> :t catMaybes
06:46:59 <lambdabot> [Maybe a] -> [a]
06:47:10 <tikhon> so fromJust and sequence don't make sense here
06:47:44 <simukis_> tikhon: yeah, it doesn't. I was just putting everything from head with assumption it's [Maybe a] -> [Maybe a].
06:47:59 <kier> > takeWhile (not . null) . map (take 1) . iterate (drop 7) $ [1..10]
06:48:00 <lambdabot>   [[1],[8]]
06:48:20 <FardadJalili> kier: thanks
06:48:32 <tikhon> honestly, this is the sort of function which might actually look better with explicit recursion and pattern matching
06:48:51 <zomg> dmp1ce: no idea, I recompiled my app, emptied browser caches, etc. the issue was gone later and it never resurfaced (not yet anyway) :P
06:48:52 <b2coutts> #haskell is an interesting choice of IDE :P
06:48:55 <OODavo> How would I go about printing an Integer in exponential notation? I know of showEFloat, but the Integer I have is so big that converting it to a Double just gives me Infinity.
06:49:13 <FardadJalili> tikhon: Using list comprehension like I did, is it considered bad haskell?
06:49:22 <tikhon> FardadJalili: in general, no
06:49:28 <FardadJalili> [snd p | p <- zip [1..] xs, fst p `mod` n == 0]
06:49:41 <tikhon> however, I'd be a little suspicious of using explicit indices and mod like that
06:50:00 <FardadJalili> aha
06:50:12 <bscarlet> tikhon: why?
06:50:15 <tikhon> but definitely use list comprehensions if you think they make the code look better
06:50:37 <tikhon> it feels a bit too indirect for the actual logic you want, but maybe it's just me
06:51:21 <FardadJalili> tikhon: I felt like that too, actually. That's why i said I don't know how to really do this in haskell. So I asked
06:53:20 <dmp1ce> zomg: You are absolutely correct.  When I run from the host machine, static files update as expected.
06:59:07 <mbrock> > map (snd . head) $ groupBy ((==) `on` fst) (zip ([1..] >>= replicate 2) [0..10])
06:59:10 <lambdabot>   [0,2,4,6,8,10]
06:59:12 <mbrock> :/
06:59:51 <taylanub> Are type classes basically like collections of "generics" in CLOS ?  Haskell's `class' statement seems equivalent to a group of `defgeneric' forms in CLOS.
07:01:07 <taylanub> (Well, type classes only declare, don't implement.)
07:01:32 <mbrock> type class instance dispatching is a little different
07:01:33 <identity> !where hpaste
07:01:38 <identity> @where hpaste
07:01:38 <lambdabot> http://lpaste.net/new/haskell
07:03:08 <mbrock> e.g. with the Read typeclass, dispatch is on the return type
07:03:29 <tomejaguar> Can someone tell me where in the Report Haskell is defined as being non-strict?
07:04:14 <mbrock> :t read "5"
07:04:15 <lambdabot> Read a => a
07:04:24 <kier> :t concatMap
07:04:25 <lambdabot> (a -> [b]) -> [a] -> [b]
07:04:32 <mbrock> :t read "5" :: Int
07:04:32 <lambdabot> Int
07:04:43 <taylanub> Ah, interesting.
07:04:45 <kier> @hoogle (MonadPlus m) => (a -> m b) -> m a -> m b
07:04:46 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
07:04:46 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
07:04:46 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
07:04:54 <kier> @hoogle (MonadPlus m) => (a -> m b) -> [a] -> m b
07:04:55 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
07:04:55 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
07:04:55 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
07:05:47 <mbrock> also, normally you can't treat instances of different typeclasses as both belonging to some "superclass"
07:06:07 <taylanub> Still, the concepts seem essentially almost the same, so I wonder why this analogy isn't drawn more often, given that CLOS generics are quite simple/intuitive to understand.
07:06:36 <mbrock> they might be just similar enough to cause confusion :)
07:06:39 <tikhon> most people coming to Haskell don't know lisp, and typeclasses are also quite simple and intuitive
07:07:03 <Narvius2> I personally am a Lisper and will probably stay one, but Haskell has surely expanded my horizons. :)
07:07:08 <Narvius2> That said, I have a silly question:
07:07:18 <mbrock> if you think about typeclasses as OO-like, then you'd expect to be able to have a [Frobbable] where Frobbable is a typeclass
07:07:34 <FardadJalili> @pl count xs= map snd (foldr (map . add) (zip [0..9] [0,0..]) xs)
07:07:34 <lambdabot> count = map snd . foldr (map . add) (zip [0..9] [0,0..])
07:07:36 <geekosaur> tomejaguar, http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1260006.2
07:07:37 <mbrock> but in Haskell you can only do that with some trickery
07:07:45 <tikhon> yeah, the naming is unfortunate; if only the OOP people had called their classes something else :)
07:08:04 <geekosaur> it is odd that that seems to be the only mention... I'd have expected something earlier
07:08:40 <tikhon> it's mentioned in passing in the preface
07:08:49 <apfelbox> Hi, I have a pretty basic question, I am afraid:
07:08:59 <apfelbox> Couldn't match type `IO' with `Ghc'
07:08:59 <apfelbox>     Expected type: Ghc ModGuts
07:08:59 <apfelbox>       Actual type: IO ModGuts
07:09:14 <apfelbox> How can I solve this?
07:09:29 <augur> can anyone familiar with iteratees give me an crash course that doesnt involve IO?
07:09:56 <Narvius2> I was just making something with monads, specifically a stack of transformers. And every transformer has a corresponding run*T function. And when I made a newtype for my transformer stack, and derived all the various Monad instances I needed... runMyMonad also suddenly came from somewhere. What are those run* functions and who do they do in general? :O
07:10:36 <tikhon> how did you define your newtype?
07:10:39 <tikhon> did it look like this:
07:10:57 <tikhon> newtype MyMonad a = MyMonad { runMyMonda :: ... }
07:11:07 <Narvius2> newtype MyMonad = { runMyMonad :: [silly long stack} } deriving (Monad, MonadIO... and so on)
07:11:09 <Narvius2> Yes
07:11:20 <tikhon> the field runMyMonad can be used as a function
07:11:39 <Narvius2> It IS a function
07:11:45 <Narvius2> But where does the result come from?
07:11:46 <Narvius2> What is it?
07:11:53 <tikhon> it's a function that unwraps the newtype
07:11:58 <tikhon> try it with a simpler example:
07:12:05 <tikhon> newtype Foo = Foo { runFoo :: Int }
07:12:14 <tikhon> then you can do runFoo (Foo 10) or something
07:12:17 <Narvius2> Yes.
07:12:21 <byorgey> Narvius2: see: "record syntax"
07:12:26 <Narvius2> I know that...
07:12:39 <tikhon> then what's the question about runMyMonad?
07:12:44 <donri> it's confusing because many "run" functions don't really "run" anything, but some do
07:13:22 <Narvius2> I guess it's just a general lack of understanding how transformer stacks work. :/
07:13:28 <taylanub> Is it true that the only substantial difference between Miranda and Haskell is that Haskell has type classes and Miranda doesn't ?  Otherwise it just seems like syntax.
07:13:51 <gasche> taylanub: Haskell's type system is vastly more advanced now
07:13:59 <taylanub> Hrm, OK.
07:14:00 <Narvius2> For example, it's still a bit mythical to me how "runStateT (runStateT (runReaderT (runWriterT (runMyMonad m)) d) us)" works.
07:14:02 <gasche> so no, it's deeply untrue
07:14:26 <gasche> Narvius2: "run" is the name we're used to give to functions that allow a value to "escape" the monad
07:14:30 <tac> taylanub: the licensing on Miranda is another difference. Miranda was not a free language. Also, no one uses Miranda. Another big difference.
07:14:37 <tikhon> Haskell also has some fancy concurrency and parallelism stuff which I suspect Miranda never did
07:14:46 <gasche> for the State monad for example, that corresponds to "running the imperative program with some initial state"
07:15:07 <gasche> well
07:15:07 <Narvius2> Hence no runIO.
07:15:22 <taylanub> tac: Oh yeah, I meant to ask differences in the languages themselves only.
07:15:23 <mbrock> Narvius2: disregarding monad transformers, look at the newtype for Reader
07:15:43 <gasche> taylanub: the question makes about as much sense as "is it true that C++ is like C, with classes added?"
07:15:48 <tac> the run functions don't actually do anything. Things like Reader and State are just wrapped up functions, and run* unwraps them so they can have arguments applied to them
07:15:50 <mbrock> Narvius2: newtype Reader r a = Reader { runReader :: r -> a }
07:16:02 <taylanub> Ouch, is the difference really that big ?
07:16:09 <tac> runReader ^ all it does it "grab what's inside the reader object"
07:16:23 <Narvius2> Yus.
07:16:27 <gasche> taylanub: well the comparison has its merits, at least
07:16:43 <tikhon> taylanub: I wouldn't be surprised if, counting GHC extensions, the difference is *bigger*
07:16:52 <taylanub> :\
07:17:06 <gasche> taylanub: if you're interested in the history of Haskell, there is a very nice paper named "Being Lazy with Class"
07:17:24 <taylanub> Thanks.
07:17:36 <danilo2> Hi! Does anybody know PARSEC and could help me with a problem? I'm writing a ident based gramar (indentations are used to show the blocks of code) and "f a" i equals to haskells function call.
07:17:36 <danilo2> But the parser is somehow dividing the tokens in wrong places. Is there anybody, who could look into it?
07:17:39 <mbrock> I think "runReader" gets it name as a field, not a projection function
07:17:40 <benj_> tac, sure if you only apply the first argument (the Reader) then it only grabs it. But supply more args and it will "run" it.
07:17:46 <gasche> it's a bit old (I'd say beginning of the 2000ies), so some of the recent development are not mentioned
07:18:32 <mbrock> for example, you can say: Reader { runReader x = x * 2 }
07:18:37 <tac> benj_: "running it" just means you are applying arguments to the creamy insides. But still in that case too, all it does is expose the warm gewy insides of the object.
07:18:44 <mbrock> here runReader is simply the field that defines the way to run the reader
07:18:46 <tac> It's a projection operation, the same as fst or (!!0)
07:18:59 <donri> mbrock: though you need a lambda there
07:19:07 <mbrock> oh, sorry :)
07:19:28 <tac> You never really *run* anything in Haskell, to be clear.
07:19:32 <tomejaguar> geekosaur: Is that ("a function argument is evaluated only when required") really the definition of non-strict?  I would have expected something somewhat more formal.
07:19:39 <Narvius2> The sad thing is I know all that about the record syntax, and I can't really articulate my problem.
07:19:43 <Narvius2> Apparently. :/
07:19:54 <gasche> tac, mbrock: I think those are implementation considerations
07:20:04 <Narvius2> I guess I'll just need to read like two dozen random articles before understanding the thing that bugs me.
07:20:08 <divyansr> @type (.)
07:20:09 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:20:25 <gasche> that the monad is often defined as a record wrapping its implementation, with the run function conveniently being the projector
07:20:29 <donri> Narvius2: i suspect it's the monads that bug you, not the transformers :)
07:20:35 <Narvius2> xD
07:20:36 <Narvius2> Likely.
07:20:53 <gasche> I expect that in some cases people could expose a run that is not an identity/unwrapping, but actually exposes a different interface than the monad's implementation
07:21:03 <Narvius2> A few days ago my reaction to "get" not taking any arguments was "the hell?! How does it know where to take stuff from? >:C"
07:21:23 <geekosaur> tomejaguar, I don't think you can get any more "formal" without hardwiring implementation details
07:21:40 <Narvius2> Now I am grudgingly semi-familiar with how that works.
07:21:44 <gasche> (eg. one could think of a monadic parser library that would internally propagate a lot of information in complex forms, and expose a simple (input -> result option * input) run function)
07:22:20 <tomejaguar> geekosaur: I was expecting something in terms of _|_
07:22:33 <donri> Narvius2: it's basically fancy function compisition wrapped inside monads. the >>= definitions for these monads thread the stuff through by using these "run" functions all through
07:22:49 <Narvius2> Yeah, now I know that. :)
07:22:58 <Narvius2> The past few days have been quite the mental journey. :P
07:23:14 <FardadJalili> Can we change a function like test x = | x = ' ' | otherwise = '*' into a better one liner? (sorry for being a newbie)
07:23:27 <tikhon> Narvius2: perhaps the best thing to do would be to implement the State monad yourself. (Don't even bother with the transformer part for now.)
07:23:51 <Narvius2> True. I might want to do that.
07:23:52 <geekosaur> pretty sure it goes out of its way to avoid discussing _|_ at all; _|_ is am emergent behavior, not part of the formal specification
07:24:21 <tikhon> FardadJalili: wait, what exactly is that function supposed to do?
07:24:25 <gasche> tomejaguar: there are clear, formal definition of call-by-name and call-by-need
07:24:37 <gasche> but the Haskell specification wishes more freedom in term of evaluation order
07:24:39 <tomejaguar> geekosaur: the report talks about _|_ a lot
07:24:52 <FardadJalili> tikhon: { (True,' '), (False,'*') } in the mathematical sense of a function
07:24:58 <gasche> so I guess they could choose something informal to get more slack
07:25:05 <FardadJalili> tikhon: change True to ' ' and False to '*'
07:25:06 <tikhon> ah
07:25:15 <tikhon> you could use an if expression
07:25:29 <tikhon> \ cond -> if cond then ' ' else '*'
07:25:31 <FardadJalili> I always here that people don't like if expression :)
07:25:37 <FardadJalili> hear*
07:25:43 <gasche> well it's much clearer than a guard in that case
07:26:03 <tikhon> that's not because if-expressions are always bad, it's because new Haskell programmers tend to really overuse them
07:26:09 <tomejaguar> gasche: It's less formal, but also unclear.  For example, what does "needed" mean in that definition.
07:26:22 <gasche> tomejaguar: there is a formal definition of strict
07:26:26 <tikhon> much of the time, pattern matching or guards would look better; in this case, the if expression does
07:26:29 <gasche> and I guess you could define non-strict as "not strict"
07:26:45 <FardadJalili> tikhon: thanks a lot.
07:26:46 <gasche> evaluation is strict when "f _|_" is always _|_
07:26:47 <tomejaguar> gasche: Sure but what does that mean?  Does it mean there is one function that is not strict?
07:26:53 <tomejaguar> Does it mean all functions are not strict?
07:26:55 <tomejaguar> Clearly not.
07:26:56 <tikhon> basically, all style rules are just heuristics; you should always do whatever looks best, but that takes a fair amount of expreience
07:27:08 <tac> yeah, geekosaur, I'm fairly confident the report talks about _|_ to some degree. It is natural when working with an unusual language like Haskell to clarify points like that.
07:27:17 <tikhon> for now, the best thing is to get somebody to review your code after you've written it
07:27:25 <Narvius> tomejaguar: The only thing that ever happens is that the IO action bound to "main" is executed. Everything else happens because of that.
07:27:58 <Narvius> There was this, "do let stuff = sum [1..]; return ()"
07:28:17 <tikhon> tomejaguar: if f ⊥ = ⊥ is true for any f, it means all functions are strict
07:28:56 <tikhon> that is, if it's true for *all* functions f
07:29:05 <tomejaguar> Sure, but what does /non/ strict mean?
07:29:05 <gasche> hm
07:29:22 <FardadJalili> put a lambda before it, haha
07:29:40 <FardadJalili> \f -> if f ⊥ = ⊥ ..
07:30:09 <gasche> tomejaguar: you could define this with something like referential transparency
07:30:38 <gasche> if f = \x -> C[x],  then (f e) is _|_ exacly when C[e] is
07:30:40 <tikhon> FardadJalili: ⊥ represents things like code that doesn't terminate, so you can't check for it. However, you're right that a lambda lets you "delay" an expression, so \ _ -> ⊥ is different from ⊥ in a strict language.
07:30:43 <Franciman> <quicksilver> Franciman: not that I think your way is bad
07:30:46 <Franciman> what are you referring to?
07:31:08 <quicksilver> Franciman: sorry, that was my client completing the wrong nick
07:31:16 <Franciman> oh ok ;)
07:32:04 <gasche> tikhon: I pinged you earlier in the day about type-classes and OCaml
07:32:41 <tikhon> oh, I must have missed that
07:33:23 <tikhon> they certainly use modules as a replacement for things like Ord
07:34:08 <tikhon> and, consequently, they use functors to make things like sets and maps work
07:34:15 <tikhon> which is really the main thing I was thinking of
07:34:20 <gasche> well
07:34:42 <tikhon> similarly for monads
07:34:47 <dpwright> Not sure if this is the right place to ask this as it's a bit specific, but is there any way to get the list of [Blocks] out of a Pandoc?
07:34:53 <gasche> while I think type-classes would be a worthwile addition to OCaml (and I don't think that there is a consensus that would say the contrary)
07:35:00 <gasche> I'm not sure this example is the best
07:35:14 <tikhon> well, maybe not a consensus, but I've certainly talked to people who seemed somewhat against typeclasses
07:35:24 <gasche> I prefer to use either OCaml's functors or Coq's type-classes to model Map and Set than Haskell type-classes
07:35:41 <tikhon> and in favor of the more explicit code for things like monads
07:35:54 <gasche> because Haskell type-classes *need* the assumption (limitation?) that there is a single instance per type to be correct
07:36:13 <satc> INLINE vs INLINABLE ?
07:36:16 <gasche> (applicative or generative) functors and (dependent-record using) type-classes lift that limitation
07:36:27 <gasche> which allows to introduce, say, local instance declarations in the language
07:36:28 <tikhon> yeah, that was also the main issue some people brought up
07:36:55 <hpaste_> identity pasted “why doesn't parsec return a parsing error?” at http://lpaste.net/92066
07:37:09 <identity> Someone feel like taking a stab at the paste above? problem describe inside.
07:37:12 <tikhon> however, I think having a unique instance per type is a good compromise, especially because using a newtype is fairly easy and doesn't impose all that much conceptual/syntactic overhead
07:37:23 <hpaste_> ocharles pasted “Untoucheable type variable?” at http://lpaste.net/92067
07:37:26 <gasche> well newtype does impose a lot of overhead on the type system
07:37:37 <tikhon> does it?
07:37:42 <gasche> see the recent contorsions to get newtype-deriving not be unsound
07:37:52 <tikhon> oh, that's fair enough
07:38:02 <hpaste_> ocharles revised “Untoucheable type variable?”: “No title” at http://lpaste.net/92067
07:38:03 <gasche> (which are nice, but still add a layer of complexity)
07:38:13 <tikhon> but that's more a matter of the deriving and not newtypes themselves
07:38:17 <ocharles> Can anyone help me make sense of the error in http://lpaste.net/edit/92067 ?
07:38:23 <ocharles> I have no idea what an "untouchable" type variable
07:38:24 <ocharles> is
07:38:33 <ocharles> Also don't know how to use my keyboard, it seems
07:38:35 <gasche> but the newtype trick is much less useful without newtype-deriving
07:38:57 <tikhon> well, that depends: you could just always wrap/unwrap at the boundary of your map or set
07:39:10 <gasche> I think the clean long-term answer is to move to Coq-style typeclasses, with instance construction witnesses appearing in the type-level constraint
07:39:11 <tikhon> a little more awkward than using a functor, but manageable
07:39:11 <ocharles> http://lpaste.net/92067 even
07:39:21 <tikhon> yeah, that sounds good
07:39:28 <tikhon> would it compromise inference though?
07:39:47 <ocharles> I think it's that constraint on Mergeable, but I have no idea why
07:39:55 <gasche> well not much more than lots of other things present in Haskell :p
07:40:32 <tikhon> it seems like the ability to have more than one possible instance would unavoidably require specifying which one you're using at any given point
07:40:44 <tikhon> but I wouldn't be surprised if there's some reasonably simple way to minimize that
07:40:45 <gasche> at any given point which has several instance in scope
07:40:48 <tikhon> I haven't used enough Coq to know for sure
07:41:10 <gasche> if you keep the current haskell type to have unique instances, there is no reason not to infer it at use sites
07:41:19 <gasche> then you pay for what you use
07:41:30 <gasche> s/haskell type/haskell style/
07:41:31 <tomejaguar> tikhon: there's always explicit dictionary passing!
07:42:36 <gasche> in any case, I'm not sure it makes sense to compare Haskell type classes and ML functors because they do rather different things, being nearly orthogonal
07:42:39 <tikhon> basically, I'd be pretty happy as long as I could keep overloaded literals, Read, Monad and such without having to write too many more annotations
07:42:56 <dpwright> (nm, I was being stupid -- you just pattern match)
07:43:25 <gasche> type-classes do a form of type-based code inference which ML languages presently lack (and which Scala has under the form of implicits)
07:43:29 <tikhon> I don't think it's fair to call them nearly orthogonal: there is enough overlap in real-world usage to make them pretty comparable
07:44:16 <identity> anyone for my parsec problem?
07:44:33 <identity>  http://lpaste.net/92066
07:44:48 <tikhon> and things like associated types move them closer to each other
07:45:55 <gasche> well
07:46:32 <gasche> you could add associated types to records instead of type-classes, to separate the two aspects
07:46:40 <gasche> that would correspond to Scala's path-dependent types, I think
07:47:03 <tikhon> yeah, I was thinking it might be possible to unify Haskell's modules and Haskell's records with something like that
07:47:05 <gasche> but in practice the "unique instance" limitation of Haskell type-classes makes type-checking associated types easier for type-classes than arbitrary records
07:47:11 <Sculptor> yo
07:47:12 <tikhon> but I haven't given too much thought to the details
07:47:43 <gasche> Coq does a reasonable job of using dependent records as a unifying construct (though it also has modules and functors)
07:48:01 <tikhon> my understanding was that people don't use Coq modules very much in favor of records
07:48:17 <gasche> I think Haskell modules are mostly a lost cause, but Backpack is very interesting if you haven't looked at it yet
07:49:05 <tikhon> and the fact that the module system is poor leads to some unfortunately organized code, like some parts of the containers library
07:49:19 <bartavelle> identity, sepBy1
07:49:32 <tikhon> there's a lot of structure there that simply doesn't get expressed in the language
07:49:46 <bartavelle> "many1 digit" can fail, and the parser succeed, because sepBy is ok with not matching anything
07:50:52 <identity> bartavelle: Hmm. I'll try it out.
07:52:24 <identity> bartavelle: sepBy1 didn't do it, I'm afraid. It also doesn't fit the grammar, so to speak. Phone numbers aren't necessarily split with spaces when I have to parse them
07:52:48 <bartavelle> it did work for me, but now you changed the requirements :)
07:52:53 <bartavelle> also it can be any number of spaces
07:53:40 * monochrom has a cunning plan!
07:54:15 <ocharles> monochrom: uh oh, that sounds like someone is trying to be clever
07:54:18 <ocharles> that never ends well
07:54:30 <identity> bartavelle: I didn't necessarily specify any requirements. In my data, digit groupings will only be split with at most 1 space. using sepBy1, I still get a 'Number Nothing ""'
07:54:40 <hpaste_> Placinta pasted “Rank error?” at http://lpaste.net/92070
07:55:05 <Placinta> Can anyone tell me what I'm doing wrong
07:55:31 <geekosaur> a cunning plan in a punning clan
07:55:42 <bartavelle> hum it does work for the first sample you sent
07:55:47 <bartavelle> number <- filter (not . isSpace) <$> many1 (satisfy (\x -> isDigit x || isSpace x))
07:55:52 <bartavelle> will work for any amount of spaces
07:56:49 <mikeplus64> Placinta: like the message says you can use the language extension RankNTypes or Rank2Types to make that valid, but you probably want instead data AppState m = AppState { sqlPool :: ..., heistState :: HeistState m }
07:57:12 <identity> bartavelle: I'm not sure what you mean. The problem is that the parser is parsing stuff(at least, not returning a parsing error) it shouldn't be parsing.
07:57:19 <identity> in this case, the "some random garbage"
07:57:32 <bartavelle> not at all
07:57:53 <bartavelle> with sepBy1 I get a parsing error
07:58:24 <bartavelle> you need many1 AND sepBy1
07:58:28 <bartavelle> concat <$> (many1 digit `sepBy1` char ' ')
07:59:43 <Placinta> mikeplus64: Thanks, that seems to be what I want.
08:00:01 <identity> What the hell. Now it works as intended with sepBy1. Thanks. I may have forgotten to save the file after modifying it, though I thought I made sure
08:00:56 <bartavelle> identity, depending on the source of your data you might want to use something more generic than (char ' ')
08:01:07 <bartavelle> in case you get tabs, or several spaces
08:01:30 <hpaste_> danilo2 pasted “parsec problem” at http://lpaste.net/92071
08:02:05 <hpaste_> danilo2 revised “parsec problem”: “No title” at http://lpaste.net/92071
08:02:30 <hpaste_> danilo2 revised “parsec problem”: “No title” at http://lpaste.net/92071
08:03:51 <danilo2> Hi ! could you please look at the Parsec problem I've psoted here:  http://lpaste.net/92071 ? I'm trying to create python like grammar (indentation based), but it does not work good if I define empty operator ("") - whcih is a function evaluatino (like haskells functions - "f a")
08:09:53 <bartavelle> that doesn't seem straightforward to use it with the expression parser generator
08:10:17 <bartavelle> binary "" will always match, right ?
08:11:42 <hape_> <-  pulls out the argument out of an Monad, inside a do Block.  But which function I can take as an equivalent for this outside an do Block?
08:11:45 <hape_> > liftM2 (+) (Just 1) (Just 2)
08:11:47 <lambdabot>   Just 3
08:11:53 <hape_> If I want to get 3 only
08:12:06 <tikhon> hape_: this is going to depend on the monad
08:12:07 <tomejaguar> What do you want to do with the 3?
08:12:14 <tikhon> with Maybe, you could pattern match against the value
08:12:26 <hape_> i mean  in an expression
08:12:35 <identity> If you're sure youre not dealing with Nothing, you can use fromJust
08:12:38 <tikhon> but you can't have a general function like Maybe a -> a without breaking sometimes—what would you do if given a Nothing?
08:12:39 <bartavelle> fromJust, but this is partial
08:12:51 <tikhon> > fromJust (Just 1)
08:12:52 <tomejaguar> > fmap show (liftM2 (+) (Just 1) (Just 2))
08:12:52 <lambdabot>   1
08:12:53 <lambdabot>   Just "3"
08:12:54 <dmp1ce> zomg: Whiching to ZFS file sharing fixed this issue for me.  I'm using Vagrant, btw.
08:12:55 <tikhon> > fromJust Nothing
08:12:56 <lambdabot>   *Exception: Maybe.fromJust: Nothing
08:13:02 <hape_> > fromJust $ liftM2 (+) (Just 1) (Just 2)
08:13:03 <lambdabot>   3
08:13:10 <hape_> > fromJust $ liftM2 (+) (Just 0) (Just 0)
08:13:11 <lambdabot>   0
08:13:19 <hape_> > fromJust $ liftM2 (+) (Just 0) (Nothing)
08:13:20 <lambdabot>   *Exception: Maybe.fromJust: Nothing
08:13:23 <hape_> That is perfect
08:13:29 <dmp1ce> zomg: NFS I mean
08:13:35 <hape_> It depends on the Monad.
08:13:56 <identity> hape_: Indeed it does. You can always do something like
08:13:58 <hape_> There is no function which does  not depend on the monad and return the monad's argument, no matter which monat it is?
08:14:00 <identity> @hoogle Maybe a -> a
08:14:00 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
08:14:00 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
08:14:00 <lambdabot> Data.Monoid First :: Maybe a -> First a
08:14:19 <tomejaguar> hape_: How can there be?  Sometimes there *is* no value.  Sometimes there is more than one.
08:14:32 <bartavelle> hape_ what would this mean for the list monad ? and this is an easy one
08:14:33 <hape_> I would accept excetions if there is none for sure
08:14:34 <tomejaguar> You have to lift your pure functions into the monad, not the values out of the monad.
08:14:57 <identity> hape_: Perhaps if you explained what you were trying to do exactly, someone could give you a more proper solution
08:15:22 <identity> In reality, you should never really have use for such a function. Due to the type system, you will always be working with one monad or the other. Not "some monad"
08:15:41 <kier> hape_: a monadic type (e.g. of IO String) only means "this is an IO value that is in some way related to a String", not that "this value contains a String"
08:15:42 <identity> @hoogle m a -> a
08:15:42 <lambdabot> Language.Haskell.TH.Syntax Q :: (forall m. Quasi m => m a) -> Q a
08:15:42 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
08:15:42 <lambdabot> Data.Monoid getDual :: Dual a -> a
08:16:02 <kier> hape: it doesn't provide any guarantee that it's possible to "pull" a value out of it
08:16:20 <hape_> ok I feel I understand now better, thanks to all :-)
08:17:43 <mbrock> hape_: if you're curious about a general t a -> a structure, check out Comonad :)
08:19:38 <hape_> mbrock: as You have seen I am struggeling with basics these days, but hopefully some day I will touch Comonad, too :-)
08:20:21 <qwerty1793> hi is there an identity element for cons (:)? i.e. is there an x such that  x:xs == xs for any list xs. Of course this means that x must be a member of every type so the only thing that I could think of is bottom
08:20:36 <tomejaguar> qwerty1793: no
08:20:38 <scshunt> qwerty1793: there is not
08:20:54 <michaelhf> Are there any good resources on how to write monadic combinators?
08:25:36 <danilo2> Does anybody has got simple Parsec grammar example implementation of python liek language (indentations + function call by placing two expressions next to each other, like (f a+1)
08:25:38 <danilo2> ?
08:26:14 <bartavelle> I have a complicated example that supports your function call scheme
08:26:21 <bartavelle> but not indentation
08:26:49 <hape_> The type of the function that does not exist, is   (Monad m) => m a -> a     which "would" be the equivalent of   <-   in do notations, outside do notations. But it is not existing. I can live without then :)
08:27:11 <danilo2> bartavelle: the problem is with the identations :( when I combine them with this function call scheme it does nto work, if you dont mind, pleasel ook here: http://lpaste.net/92071
08:27:45 <hpaste_> danilo2 revised “parsec problem”: “No title” at http://lpaste.net/92071
08:28:17 <bartavelle> Danilo2 I already answered, I think you can't use "AST.callConstructor" in the expression builder
08:28:32 <bartavelle> binary "" is probably meaningless, as it will always match (at least, I believe)
08:29:47 <danilo2> bartavelle: I didnt see it, Im sorry - AST.callConstructor is somethingl ike Type Cosntructor and it works, the problem is with this binary "", but how can I then implement function call, which is also an expression? I want to be able to supoprt code like "a = b c"
08:30:25 <bartavelle> you should probably have a "Statement" type, with Statement = FunctionCall Text Expression | Otherstuff
08:30:42 <bartavelle> and have a statement parser using the expression parser
08:30:50 <bartavelle> well
08:30:57 <bartavelle> or not :)
08:31:02 <bartavelle> if you want it to also be an expression
08:31:20 <bartavelle> perhaps have "expr' = functionParser <|> expr"
08:31:22 <danilo2> bartavell: I want it to be an expression, f.e: "(a+b) f
08:31:23 <danilo2> "
08:31:27 <danilo2> Is also a function call
08:31:30 <bartavelle> ahhh
08:31:53 <bartavelle> then put your function call in a terminal
08:32:30 <danilo2> bartavelle: Coudl you explain this sentence? :)
08:33:17 <bartavelle> well, add the facility to parse such lines in the "term" parser
08:33:34 <bartavelle> this smell hackish but this is what I did for my puppet parser
08:34:09 <danilo2> bartavelle: I'll test it. brb
08:34:44 <bartavelle> not sure how this will turn out as the "function name" being an expression, this might match all the time
08:35:12 <bartavelle> ah except that you can't have arbitrary whitespaces
08:38:27 <danilo2> bartavelle: puuting it in as part of term choose parser gives wrong resutls, for exmaple for: "def f:\n    a x", as calling the (def f:\n    a) x etc
08:38:57 <bartavelle> ah yes
08:39:29 <bartavelle> but this is the same ;)
08:39:37 <danilo2> bartavelle: I've almost did it, bit it has one problem
08:40:02 <bartavelle> whta is the meaning, in your grammar, of "def a:\n\tb\n\tc" ?
08:40:44 <hpaste_> danilo2 revised “parsec problem”: “No title” at http://lpaste.net/92071
08:40:52 <danilo2> bartavelle: Ichanged the simpleSpace = many1 (satisfy (`elem` "\t\f\v ")) and then the code almsot works
08:41:47 <danilo2> bartavelle: http://lpaste.net/92071 - this parses untill the first block line and stps parsing, because it greedy applies the operator
08:42:13 <bartavelle> but what does it mean ?
08:42:31 <pxqr> is there an yi user here?
08:42:54 <danilo2> bartavelle: Ok, so I changed the logic to do something like that - after expression, the "lexeme" function does not eats newline characters, so I tell explicite, that after each expression there should be newline
08:43:07 <bartavelle> if it mean "run function a, then run function b, then define g, then run d", you have statements and expressions, not just expressions
08:43:17 <danilo2> bartavelle: this gives me one good behavior - if there is a line under line it is nNOT interpreted as function call
08:44:08 <danilo2> bartavelle: I do not know yet if this is good way, but I'm trying to solve it like this, burt maybe there is a lot easier way somehow - I bet somebody have written python parser in Parsec or something simmilar
08:44:14 <danilo2> bartavelle: there must be easier way ;)
08:44:21 <bartavelle> well if you are writing a python parser
08:44:27 <bartavelle> you *certainly* don't just have expressions
08:44:33 <danilo2> bartavelle: Not python - something little simmilar
08:45:55 <bartavelle> what would be the AST for the first 3 lines of your sample ?
08:46:07 <bartavelle> I understand it as something like
08:46:27 <bartavelle> FunctionDefinition "f" [FunctionCall "a", FunctionCall "b"]
08:46:57 <bartavelle> am I right ?
08:47:29 <danilo2> bartavelle: It should be FunctionDefinition "f" [identifier "a", identifier "b"]. Function call is only possible if there is more (or) 1 argument provided.
08:47:59 <bartavelle> what does it mean to just have an identifier ?
08:48:01 <danilo2> so if there would be "a x" instead of "a" - it would be a function call
08:48:06 <bartavelle> ok
08:48:50 <danilo2> bartavelle: Lets say currently nothing - a kind of "mixin" to a function
08:49:04 <danilo2> bartavelle: but dont dig into it :D
08:49:05 <bartavelle> but in that case you'd probably need something like "data Statement = FunctionDefinition String [Statement] | Identifier String | FunctionCall String [Expression] | VariableAssignment String Expression | ... "
08:49:13 <bartavelle> those are not expressions
08:49:16 <bartavelle> as
08:49:25 <bartavelle> or perhaps they are :)
08:49:36 <bartavelle> is "f (def: ...)" valid ?
08:49:38 <danilo2> bartavelle: they are - see : a=(b=(c=d))
08:49:44 <danilo2> (assigment is an expression
08:50:21 <danilo2> function definition is also  "g (def f(x):x+1)" - is something like evaluating g with lambda
08:50:31 <bartavelle> ok
08:53:36 * hackagebot diagrams-builder 0.4.0.1 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.4.0.1 (BrentYorgey)
08:57:47 <danilo2> bartavelle: I hhave to go now. I'll be later- if you'll have any idea - I'll read it later :)
08:58:03 <bartavelle> good luck
08:58:25 <danilo2> bartavelle: Thank you and thanks for help
08:58:27 <danilo2> :)
08:59:50 <FUZxxl> This might be a bit offtopic, but maybe you can help me with this problem: http://stackoverflow.com/questions/18381354/what-sorting-techniques-can-i-use-when-comparing-elements-is-expensive
09:00:48 <osfameron> the orcish manouvre?
09:00:57 <FUZxxl> osfameron: ???
09:01:42 <osfameron> is what it's called in Perl -- you basically map a transformation to each element, sort on the transformed value, and then return the original values
09:01:48 <monochrom> that is a very vague question. don't tell me what is expensive. tell me what is cheap.
09:01:57 <osfameron> http://www.nntp.perl.org/group/perl.beginners/2001/05/msg1250.html for example
09:02:35 <FUZxxl> monochrom: Comparison is sometimes expensive, sometimes cheap. Comparison is expensive when keys are (almost) equal.
09:02:44 <FUZxxl> Think about comparing files.
09:03:33 <monochrom> perhaps I am unclear. let me try again.
09:03:37 <zomg> dmp1ce: yep vagrant for me as well, some kind of odd networking caching issue in vagrant perhaps
09:03:38 <FUZxxl> There is a function expensive :: t -> t -> Bool that can tell you whether a comparison would be expensive
09:05:22 <monochrom> you have a situation, comparison is expensive, or, some comparisons are expensive. ok, I acknowledge that.
09:05:29 <FUZxxl> yes.
09:05:53 <S3Xinfo> http://s3x.info/legs-up-full-view-of-beautiful-shaved-pussy-3/
09:05:55 <monochrom> but that information is close to useless. ok, we want to avoid comparison. so, don't use comparison. but what else can we use? you don't say.
09:06:17 <Jentrep> Is zomg on? :)
09:06:22 <monochrom> if I don't know what operation is cheap, I don't know what to try.
09:06:27 <zomg> Jentrep: yep
09:06:34 <FUZxxl> The point of this question, perhaps written out in an unclear way, was this:
09:06:45 <joelteon> if I use parMap with a function that returns an IO action, will the actions be executed in parallel or in sequence?
09:06:53 <zomg> Jentrep: I was wondering the other day why you were looking for me in particular as I don't recall being any kind of Haskell expert that people would seek ;)
09:08:10 <FUZxxl> I know that comparison of certain elements in the set is expensive. I know that there is no way to get around actually comparing these elements. What sorting algorithm can I use that actively minimizes the amount of times I am doing expensive computations?
09:09:21 <FUZxxl> monochrom: There is no different way to get *any* information about the array except comparing elements.
09:10:08 <FUZxxl> Still, one sorting algorithm could compare a and b ten times while the other one does so only once.
09:11:16 <FUZxxl> So, which algorithm should I use for the purpose of this problem?
09:11:31 <FUZxxl> Which sort
09:11:33 <monochrom> then I don't know.
09:11:47 <FUZxxl> That's a good answer. Thank you.
09:13:50 <Letchik> Is [1..]::[Int] a finite list?
09:14:06 <monochrom> yes
09:14:08 <quicksilver> I am not aware of any sort algorithms that are tuned to let you avoid comparing expensive elements, FUZxxl
09:14:33 <FUZxxl> quicksilver: okay. That's good (well, maybe not so good) to hear.
09:14:33 <Letchik> Does it end when the computer reaches maximum value of Int type?
09:14:42 <quicksilver> FUZxxl: although, often in cases like that there is a fast function which will allow you to definitely distinguish some cases
09:14:49 <monochrom> > maxBound :: Int
09:14:50 <lambdabot>   2147483647
09:14:52 <quicksilver> and you can call that first
09:15:02 <monochrom> > [2147483646 .. ] :: [Int]
09:15:03 <lambdabot>   [2147483646,2147483647]
09:15:09 <monochrom> that ends the list
09:15:10 <quicksilver> > length ([1..]::[Int])
09:15:17 <lambdabot>   mueval-core: Time limit exceeded
09:15:21 <quicksilver> bother :)
09:15:26 <Letchik> monochrom: Is that implementation-dependent?
09:15:29 <quicksilver> last time we had a 32-bit lambdabot it could do that in time
09:15:33 <quicksilver> this must be a slower machine.
09:15:46 <monochrom> I think no, Haskell 2010 requires it.
09:16:09 <Letchik> Does ghc fully implement Haskell 2010?
09:16:55 <monochrom> that is an XY question. GHC definitely implements this small part of Haskell 2010. I have just shown you a test.
09:17:16 <monochrom> (why jump to "fully"? do you really need it?)
09:17:32 <Jentrep> oh hey zomg
09:17:46 <Jentrep> sorry about that I was looking for you for JS and Haskell
09:17:47 <Jentrep> :)
09:17:51 <wojtekM_> I have a feeling that I'm spending too much time formatting the code. Am I alone in that?
09:17:59 <Letchik> monochrom: Ok, thx for answers.
09:18:15 <leroux> wojtekM_: Nope. I've been looking for good styling guides for Haskell.
09:18:19 <FUZxxl> quicksilver: Yes, I know. I have such a function. A shortcut is available in almost any case. If it isn't, the comparison takes a long time. Some sorting algorithms would perform the same comparison twice. If this happens to a slow comparison, I could save a lot of time with a different algorithm.
09:18:22 <monochrom> "For any type that is an instance of class Bounded as well as Enum, the following should hold:" "enumFrom x = enumFromTo x maxBound"
09:18:33 <leroux> wojtekM_: Finally found one though. https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
09:20:00 <Jentrep> you ther zomg? :P
09:20:10 <wojtekM_> How about Attoparsec alternatives? :-)
09:20:53 <zomg> Jentrep: yeah
09:20:58 <zomg> Jentrep: just doing some other stuff on the side
09:21:54 <FZ> what's the purpose of the regex-base package? ("Interface API" ?)
09:23:23 <monochrom> to provide types etc
09:25:22 <FUZxxl> Thank you for your help.
09:25:31 <FUZxxl> (no sarcasm intended)
09:25:33 <donri> interface interface!
09:26:22 <donri> regex-posix uses the interface interface to interface the portable operating system interface style regular expressions!
09:27:02 <FUZxxl> Needs more interface
09:27:15 <monochrom> it sometimes strikes me how much of programming is just interfacing.
09:29:15 <tac> monochrom: Business programming is really bad with that
09:29:41 <FZ> I see; I had thought "Interface" was referring to the library-user rather than the library-developer
09:29:50 <tac> I think of impedance mismatch between systems as "trying to shove a 40-sided polygon into a 36-sided hole"
09:31:21 <monochrom> you have just explained why we end up with http://this-plt-life.tumblr.com/post/44462204757/simon-peyton-jones-adding-the-io-monad-to-haskell
09:32:04 <FZ> is it that bad? :(
09:32:16 <monochrom> :)
09:32:34 <joelteon> :t asAppliedTo
09:32:45 <joelteon> rats :(
09:32:50 <monochrom> @botsnack
09:33:08 <monochrom> she's probably still computing [1..] :: [Int] :)
09:33:17 <joelteon> probably
09:33:32 <lambdabot> (a -> b) -> a -> a -> b
09:33:32 <lambdabot> :)
09:33:56 <joelteon> there we go.
09:33:58 <WraithM> lol
09:35:32 <FZ> lambdabot knows ":)" ?
09:36:00 <joelteon> @botsnack
09:36:00 <lambdabot> :)
09:36:01 <joelteon> yes
09:39:34 <clahey> What does asAppliedTo do?  Is it const?  Is it asAppliedTo f a' a'' = f a''?
09:39:40 <haasn> it's const
09:39:53 <clahey> The point is to set the type?
09:39:56 <haasn> yes
09:40:01 <haasn> :t id `asAppliedTo` ()
09:40:02 <lambdabot> () -> ()
09:42:20 <ReinH> hai
09:42:52 <haasn> clahey: const f a' a'' = f a'' -- incidentally
09:43:47 <clahey> Oh yeah.
09:43:54 <clahey> I meant to ask if it was f a'.
09:44:11 <clahey> @pl x f a' a'' = f a'
09:44:11 <lambdabot> x = (const .)
09:44:53 <tomejaguar> Is there a zipWithLongest somewhere?
09:45:16 <tikhon> tomejaguar: how would that work?
09:45:52 <tomejaguar> it would have a default value for when one of the list ends
09:46:00 <tomejaguar> when both of the lists have ended it terminates
09:46:43 <tikhon> I doubt that's defined anywhere prominent
09:47:02 <tikhon> @hoogle (a -> b -> c) -> a -> b -> [a] -> [b] -> [c]
09:47:02 <lambdabot> No results found
09:47:25 <pxqr> tikhon: zipWith?
09:47:42 <tikhon> pxqr: a hypothetical zipWithLongest
09:51:26 <hiptobecubic> zipLongest def [1,3,5] [2,4,6,8] = [1,2,3,4,5,6,def,8] ?
09:52:49 <tromp__> zipWithLongest might need 2 defaults
09:53:00 <tikhon> hence my type signature above
09:53:13 <tromp__> or a function (Maybe a) -> (Maybe b) -> c
09:53:29 <pxqr> heh, single undefined ruin yi startup
09:53:32 <S11001001> Either a b -> c
09:53:33 <pxqr> in config
09:53:48 <aristid> S11001001: that won't take both.
09:54:14 <S11001001> aristid: then two functions
09:54:21 <S11001001> it's worth excluding "neither"
09:55:11 <S11001001> and Either a b -> c gives rise to the nice (either (,def) (def,)) argument form
09:55:11 <aristid> data InclusiveSum a b = Left a | Right b | Both a b
09:56:31 <pxqr> InclusiveSum is isomorphic to Data.Algorithm.Diff.Diff
09:56:42 <pxqr> oh, no
09:57:12 <pxqr> ok, InclusiveSum a a = Diff a
10:01:15 <augur> i almost understand iteratees \o/
10:01:24 <augur> im going to rewrite the website's page on them
10:01:35 <augur> not immediately, but soon
10:01:57 <FZ> dumb question but how does ghc --make figure out where to find the module dependencies?
10:02:19 <monochrom> it does a preliminary parse of files
10:03:29 <monochrom> it uses the import statements to hunt more files
10:03:38 <tikhon> FZ: are you asking about where in the filesystem it looks?
10:03:58 <FZ> tikhon: yes
10:04:01 <bergmark> FZ: it looks for Foo.Bar at Foo/Bar.hs, also in directories supplied by -i, and in packages supplied by -package, and in the base package
10:04:18 <FZ> ah I see, so there's a naming scheme I'd have to follow; thanks
10:05:37 <aristid> augur: you understand iteratees now that nobody is using them anymore?:)
10:05:45 <augur> aristid: :P
10:05:52 <augur> well snap's server uses them!
10:06:11 <augur> but it might be useful to understand them anyway, as background for pipes, etc.
10:06:16 <augur> plus as a concept they're interesting
10:06:54 <aristid> augur: well actually iteratees by themselves are OK
10:07:05 <aristid> augur: it's the enumerators built on them that suck IMHO :P
10:07:40 <augur> the enumerators built on them?
10:07:59 <paolino> is understanding iteratees an iteratee ? I cannot take them altogether
10:09:16 <aristid> augur: enumerators are IIRC just functions that take iteratees, right?
10:09:25 <augur> aristid: maybe!
10:09:45 <aristid> augur: oh so you only looked at iteratees, which are... consumers, right?
10:09:45 <augur> aristid: yes
10:09:52 <augur> yes as in
10:10:01 <augur> yes they are functions that take iteratees
10:10:11 <augur> but they also return iteratees
10:10:49 <aristid> augur: and i think they are both confusing and hard to work with :)
10:11:01 <augur> aristid: that's because noone's properly explained them ever :)
10:11:12 <augur> ive got a nice little model in my head that makes them quite easy to work with
10:11:16 <aristid> augur: no, that's because pipes are so much cooler! :)
10:11:19 <augur> :P
10:11:41 <mstksg> are haskell's strings basically the same as c's null terminated strings?  in that they have all of the inherent performance problems?
10:11:47 <tikhon> no
10:11:54 <tikhon> they have worse performance problems
10:12:06 <tikhon> Haskell's strings are lazy linked lists of unicode code points
10:12:43 <mstksg> so it has all of the problems of null terminated strings, plus more
10:12:47 <tikhon> > take 3 $ 'a' : 'b' : 'c' : 'd' : undefined : []
10:12:48 <lambdabot>   "abc"
10:12:53 <tac> > chr 256
10:12:54 <lambdabot>   '\256'
10:12:57 <tac> > chr 1256
10:12:58 <lambdabot>   '\1256'
10:13:08 <tac> !haskell chr 256
10:13:10 <tikhon> no—you can't accidentally go past the end of a Haskell string
10:13:10 <sudlowbot> '\256'
10:13:15 <tac> !haskell chr 1256
10:13:15 <sudlowbot> '\1256'
10:13:31 <haasn> > text [chr 1256]
10:13:32 <lambdabot>   Ө
10:13:32 <tikhon> but yeah, if you want performance, use Data.Text
10:13:46 <n-dolio> They also don't consider characters to be 8 bits.
10:14:01 <tac> @type text
10:14:01 <lambdabot> String -> Doc
10:14:10 <tac> @which Doc
10:14:11 <lambdabot> Unknown command, try @list
10:14:28 <mstksg> i was just reading an article about performance problems null termed strings and it reminded me of haskell strings.  but i guess there are some non-performance differences
10:14:50 <tikhon> oh yes, loads of non-performance differences
10:15:01 <tikhon> C strings are easy to mess up in small or even catastrophic ways
10:15:09 <haasn> the closest thing to a C-style string would be a ForeignPtr Word8 or whatever
10:15:09 <tikhon> and have left a legacy of security problems in their wake
10:15:14 <tikhon> Haskell strings are just slow
10:15:38 <pxqr> tikhon: and takes about 40 times more space
10:15:46 <n-dolio> Well, there are some other subtleties, as well.
10:16:02 <tac> Aren't Text's treated closer to how strings are in traditional languages?
10:16:11 <haasn> them being nonstrict is the big thing imo, also the fact that Char ≠ Word8
10:16:24 <aristid> tikhon: but haskell strings make up for it by being ridiculously slow instead of slightly slow.
10:16:26 <n-dolio> Like, it's sometimes not correct to operate on strings character-wise, but that's what String is geared toward.
10:16:31 <mstksg> still all lists do suffer from the schlemiel painter problem
10:16:51 <haasn> aristid: not for all operations, eg. consing
10:16:56 <tikhon> eh, Haskell strings are fast enough for tasks that don't involve processing large amounts of text
10:17:25 <haasn> unless you have good fusion that's much easier for a list than, say, reallocating a strict Text buffer for every cons operation
10:17:39 <tikhon> things like taking user input—a classic place for C strings to bite you—are perfectly fine
10:17:56 <tikhon> but yeah, for text processing, the performance is abysmal
10:17:58 <aristid> haasn: true!
10:18:17 <pxqr> consing is usually done by some builder combinators and very cheap, doesn't it?
10:18:21 <aristid> haasn: however, lazy Text should be prett decent for that as well.
10:18:25 <aristid> pxqr: in C?
10:18:34 <aristid> pxqr: String has no builders.
10:18:47 <pxqr> aristid: builders is C ?
10:19:06 <aristid> pxqr: no...
10:19:24 <pxqr> aristid: no, I mean that "cons is not O(1)" is not a sufficient for performance.
10:19:47 <pxqr> aristid: 40 times difference in space usage?
10:20:38 <haasn> (aren't we essentially in an age where memory is cheaper than processing power?)
10:21:03 <tikhon> memory is also sloooow
10:21:15 <tikhon> and linked lists are not cache friendly
10:21:21 <haasn> yeah true
10:21:30 <n-dolio> I suspect you don't want to repeatedly cons onto even lazy Text.
10:21:37 <tikhon> if anything, performance-wise, we're in the an age where memory is *more* expensive
10:21:48 <Apocalisp> When I have [a] in whnf, has it already evaluated to the point where it knows if it's empty or nonempty?
10:21:51 <pxqr> well in C one char takes 2 bytes. String takes Cons { 1 + 1 + Char 1 {1} + 1} = 5 words = 40 bytes
10:22:26 <tikhon> pxqr: do you mean a one-char string or each char in a string?
10:22:38 <sclv_> Apocalisp: well whnf means you know the 'outermost constructor'
10:22:51 <sclv_> so based on that you should be able to figure it out :-)
10:22:52 <pxqr> yes, one-char string cost is about 40 bytes
10:22:59 <pxqr> if I right
10:23:24 <Apocalisp> sclv_: Thanks, that confirms what I already know then :)
10:23:41 <n-dolio> I think 40 bytes might be an overestimate.
10:24:07 <n-dolio> Given that (very) small Strings are supposed to be a bit more efficient than small Texts.
10:25:45 <pxqr> n-dolio: ghc rts has a pool for chars. so it might be 40 - 16 = 24 bytes.
10:26:19 <n-dolio> Are you counting a whole word for the constructor tag?
10:26:22 <pxqr> though i don't know how it works
10:26:40 <pxqr> n-dolio: doesn't it takes a word?
10:26:49 <n-dolio> I kind of doubt it.
10:26:53 <sclv_> http://stackoverflow.com/questions/3254758/memory-footprint-of-haskell-data-types
10:26:59 <n-dolio> But I can't remember.
10:27:29 <sclv_> but i'm pretty sure something like list uses tagging
10:27:31 <n-dolio> Hmm, I guess it does.
10:27:37 <sclv_> so you don't pay the full cost
10:28:16 <n-dolio> It's a huge waste for Char, for instance, though.
10:28:33 <sclv_> right -- but we have different sorts of tagging
10:28:43 <n-dolio> Because Char# is well under even a Word32, and there's only one constructor.
10:28:43 <sclv_> so pointer tagging for example means we don't actually indirect to the nil
10:29:01 <n-dolio> So it would seem like they'd do something a little better. But maybe they don't.
10:29:15 <pxqr> does ghc perform pointer tagging? STG is taggles by design
10:29:28 <sclv_> yes but they introduced tagging somewhere in 6.x
10:29:38 <n-dolio> Yeah, well nil only exists once in a program anyway, too.
10:29:54 <sclv_> right -- nil is free regardless, as the link points out
10:29:56 <n-dolio> So even without tagging, you shouldn't really count it, except the pointer to it.
10:30:04 <pxqr> n-dolio: but nil values still lifted
10:30:34 <sclv_> doesn't matter. that's the indirection.
10:31:15 <sclv_> also bear in mind that haskell chars are unicode code points
10:31:22 <sclv_> so comparing that to a c char is misleading
10:35:21 <hiptobecubic> > 'é'
10:35:22 <lambdabot>   '\233'
10:35:35 <pxqr> yi looks promising, but i'm still not sure I able to use it
10:36:24 <pxqr> > show ( "аa" :: Text)
10:36:57 <lambdabot>   Not in scope: type constructor or class `Text'
10:40:08 <joelteon> does anybody else have a problem with vim2hs making vim incredibly slow when there's a long string in the source coed?
10:40:28 <n-dolio> joelteon: Yes.
10:40:40 <joelteon> Any idea why that is?
10:40:55 <n-dolio> The syntax highlighting uses a lot of 0-width matches. I think it's that.
10:41:08 <auguste2> would it be wrong to say that monads are only about keeping track of state?
10:41:29 <n-dolio> Those are very expensive, but they only have range on a single line. So generally you'll only notice when the lines are long.
10:41:48 <joelteon> Yeah, turning off syntax fixed it
10:43:43 * hackagebot diagrams-haddock 0.1.1.2 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.1.1.2 (BrentYorgey)
10:44:01 <n-dolio> I've worked some on a highlighting mode that tries not to use those, but it's not really ready for prime time.
10:44:05 <haasn> auguste2: what state is [] keeping track of?
10:44:25 <mbrock> FUZxxl: have you thought about doing something like finding the strongly connected components of the graph made up by cheapness relation?
10:44:41 <mbrock> FUZxxl: not sure if that makes sense or is a good idea
10:45:27 <mbrock> FUZxxl: but then you would have disjoint sets of things, within which it's cheap to do the comparison
10:45:35 <mbrock> FUZxxl: and then you could sort those sets
10:45:43 <mbrock> FUZxxl: and then ??? and then profit
10:46:22 <n-dolio> joelteon: What version of vim are you using, by the way?
10:46:29 <tikhon> auguste2: yeah, that would be wrong.
10:46:30 <joelteon> n-dolio: 7.4, I think
10:46:35 <joelteon> let me brew update
10:46:37 <n-dolio> Okay.
10:46:48 <auguste2> tikhon: what is a counter example?
10:46:57 <n-dolio> 7.4 and late 7.3 has a new regex engine that may either be worse or better, I'm not sure.
10:47:00 <tikhon> auguste2: well, [] (which is the list type), was brought up earlier
10:47:12 <n-dolio> So you could try setting it to the old engine, and it might get better (but still slow).
10:47:19 <tikhon> auguste2: then Maybe and Cont come to mind
10:47:48 <tikhon> (where Cont is short for continuation, a monad abstracting over code written in continuation-passing style)
10:48:11 <tikhon> Either also doesn't really keep track of any state
10:48:24 <tikhon> Then there's the Identity monad, which doesn't do anything at all
10:49:13 <tikhon> a monad is mainly an algebraic notion; it doesn't have any particular "use case", so to speak
10:49:37 <tikhon> in fact, it's a notion that happens to be useful for a bunch of different tasks, not just maintaining and managing state
10:49:59 <tikhon> did any of that help as an explanation?
10:50:25 <absurdity> Hi.
10:51:48 <auguste2> tikhon, yes. but how could I put the concept of monads into one sentence? it’s about propagating additional information while composing functions?
10:52:10 <tikhon> even that is a bit too specific
10:52:18 <arkeet> that's too generic
10:52:45 <arkeet> that could conceivably apply to applicatives and arrows
10:52:50 <auguste2> aren’t generic and specific antonyms?
10:52:55 <tikhon> right
10:53:10 <tikhon> part of your description covers too many different abstractions
10:53:15 <geekosaur> it's hard to put into one sentence. it's an abstraction to a level brains don't seem to work with so well.
10:53:29 <tikhon> but also, a monad does not necessarily have to propagate additional information
10:53:54 <mbrock> it's something for which the do notation makes sense ;)
10:54:40 <levi> It's something that fits the Monad type class's signatures and obeys the monad laws. ;)
10:55:51 <arkeet> it's a monoid in the category of endofunctors ;)
10:56:13 <arkeet> (well, that's a monad, not a Monad.)
10:56:44 <tikhon> auguste2: have you seen "You Could have Invented Monads"?
10:57:00 <tikhon> @where You Could have Invented Monads
10:57:00 <lambdabot> I'm right here, silly.
10:57:07 <tikhon> ah, that was too much to hope :/
10:57:11 <levi> Asking what a Monad is is kind of like asking what a Set is. There's a simple correct answer that doesn't lead to much intuitive understanding, and then a lot of intuitive answers that really only cover one aspect of how they're used.
10:57:12 <pmade> auguste2: In such an abstract concept talking about what a monad *is* is like talking about what a class is in an OOPL.  When you get to specific instances it makes a lot more sense.
10:57:13 <tikhon> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
10:57:18 <bennofs> @google You could have invented monads
10:57:19 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
10:57:20 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
10:58:33 <pmade> or what levi said.
10:59:40 <arkeet> well, classes are probably more intuitive than monads ;)
10:59:47 <levi> A Set is an incredibly simple thing, but you can represent a whole lot of different kinds of concepts with sets.
10:59:55 <arkeet> because it's a specific thing.
11:00:10 <tikhon> ultimately, the best option is not to try pigeonholing monads to any particular purpose but to use them for a bit and gain a working intuition before looking at the formal definition
11:00:11 <arkeet> or rather, it's not as much of an abstraction.
11:00:18 <arkeet> agreed :)
11:00:24 <arkeet> well, you can look at the formal definition.
11:00:36 <arkeet> you should know what the Monad class looks ilke.
11:00:46 <tikhon> eh, I don't know: when I was starting out with OOP, I would not have been able to saliently answer "what is a class?"
11:01:00 <arkeet> tikhon: but you probably could now, right
11:01:09 <tikhon> oh yeah, I know all about coalgebras now :P
11:01:32 <tikhon> but yeah, I could probably come up with a reasonable definition too
11:01:51 <tikhon> maybe
11:02:16 <tikhon> but since class is a relatively complicated notion, I would probably be missing some details
11:02:39 <tikhon> or, at least, classes in practice: you have static fields, static functions, initializers, destructors...
11:02:43 <mbrock> OO is made to kinda sorta map onto common sense ontology though
11:02:55 <mbrock> so you learn the metaphor first and then the thousand weird implementation details
11:02:55 <levi> Depends on how general you want to be about what a class is. It's not nearly as well-defined as what a monad is.
11:03:27 <tikhon> then again, if you don't mind being that wishy-washy, maybe you could come up with a similar definition for what a monad is
11:05:04 <levi> Well, that's what I meant earlier. There are lot of ways to say mostly-right things about what monads are that leave out some important detail or other.
11:06:20 <levi> I think mostly the trouble is developing the intuition to *recognize* monads and then the intuition to put them to practical use. That development ultimately comes more from practice than clever explanations.
11:06:37 <tikhon> yeah, that's probably true
11:07:02 <tikhon> I have my own ideas about how to explain it more intuitively, but no reason a piori to believe my explanations would be any more helpful than the ones already out there
11:07:30 <tikhon> still, I'm not entirely convinced it's inherently more difficult to grasp than, say, OOP ideas; the OOP community is just less worried about absolute correctness
11:07:50 <levi> It's a name for a certain kind of structure that happens to be pretty useful as a way to model things in programming languages.
11:08:07 <tikhon> hey-oh, great explanation for what a class is :P
11:08:08 <levi> tikhon: That's definitely a factor.
11:08:33 <auguste2> levi, and it has to do with composing things, right?
11:08:42 <levi> auguste2: Yes.
11:08:42 <tikhon> auguste2: yes
11:08:55 <levi> That much you can say with certainty about monads!
11:08:58 <tikhon> the thing is that a *whole bunch* of other abstractions also deal with composing things
11:09:08 <tikhon> one way to think about it
11:09:25 <tikhon> is that a monad is some type m that lets you compose functions of the form a -> m b
11:09:41 <tikhon> like for Maybe, we can combine a -> Maybe b and b -> Maybe c into a -> Maybe c
11:09:58 <tikhon> this turns out to be surprisingly useful
11:10:17 <tikhon> (there's actually a bit more structure to it, but this is—I think—a good place to start)
11:11:25 <auguste2> the german wikipedia says something like it’s like a sequence of statements in an imperative language but you can program the semicolon
11:12:04 <tikhon> that's an even more vague analogy
11:12:05 <levi> I think it's also helpful to recognize that a *lot* of things have the Monad structure already, and just need an instance defined for them. It's more of a structural thing that you can discover about a pre-existing structure than something you have to specifically create.
11:12:30 <tikhon> but, if you think about it, the semi-colon is basically a special kind of composition operator
11:12:33 <levi> Some structures can even form a monad in several different ways.
11:12:46 <tikhon> so it definitely comes back to composition
11:12:57 <elliott> auguste2: the only real way to put the concept of monads into one sentence that will make sense to you is to already know them.
11:13:10 <elliott> you can't put the concept of Haskell into one sentence that will make you learn the language by reading it, either :)
11:13:25 <elliott> are you reading a Haskell tutorial?
11:13:30 <elliott> most of them cover monads
11:13:31 <levi> It might also help to step back and develop an intuition for things like Monoid and Functor first.
11:13:42 <elliott> (admittedly to varying degrees of success, but LYAH's introduction is okay)
11:14:51 <levi> Since Monad is another kind of the same general class of abstraction that Monoid and Functor belong to, and they are a bit simpler and easier to wrap your head around.
11:17:26 <hpaste_> mbrock pasted “Sort avoiding specific comparisons (for FUZxxl)” at http://lpaste.net/92076
11:17:51 <mbrock> do you think that could be useful?
11:18:41 <mbrock> sorting the connected groups seems like a decent idea to me, then you'll only do slow comparisons in the merge step
11:19:20 <mbrock> speedup will of course depend on the size of your connected groups
11:22:50 <mbrock> hmm that code could be simpler...
11:24:26 <auguste2> would it make sense to learn a bit of category theory?
11:24:42 <monochrom> no
11:24:51 <tikhon> it's certainly not necessary, but it could be fun
11:25:11 <lingxiao> hey all, I have a question that is really bothering me..
11:25:29 <auguste2> could it be useful in other fields?
11:25:33 <lingxiao> Let's say I have a function that composes two monads `co :: Monad m => m a -> m a -> m a`
11:25:34 <monochrom> yes
11:26:10 <monochrom> please don't call that "compose two monads". please say "compose two monadic actions". m is the monad, m a is not.
11:26:23 <lingxiao> oops sorry, thanks for the correction
11:26:31 <ericmoritz> >=> and <=< compose monadic actions btw ;)
11:27:07 <lingxiao> but now I find that the first monad is wrapped inside a monad tranformer `a :: t m a`
11:27:08 <levi> Composing monads is what you're doing when you build monad stacks.
11:27:34 <resnik> if you have a function f::(a -> m b) and g::(m b -> m c) and h::(c -> m d) can you compose f g h with some starting m a by using (>>=) and (.) ?
11:27:35 <lingxiao> Oh word... here `co` has some sort of domain specific logic
11:28:18 <lingxiao> so I want a function `co' :: (MonadTrans t, Monad m) => t m a -> m a -> t m a`
11:29:18 <lingxiao> but I'm not sure how, I tried some of the stuff from MFunctor, but couldn't conceptualize what I'm really try to do to know how to use it, if it's relevant at all
11:29:30 <ParahSailin> g . f >>= h
11:29:45 <monochrom> you may have to write the new co afresh. it cannot be derived from the old co.
11:30:06 <lingxiao> hmm.. that means `co'` is tied to the choice of `t`?
11:30:20 <lingxiao> I guess I was trying to keep things as modular as possible and was wondering if there is such a way..
11:30:39 <levi> auguste2: I think it's useful to at least learn what category theory is about. Some sort of abstract algebraic experience would be very helpful, whether it's category theory or just a more abstract algebra than the one you learned in grade school.
11:31:13 <levi> And you don't have to be *adept* at it, just familiar with the concepts.
11:32:05 <auguste2> thanks, that sounds like a valuable advice
11:34:57 <hpaste_> mbrock revised “Sort avoiding specific comparisons (for FUZxxl)”: “Cleanup of avoiding sort for FUZxxl” at http://lpaste.net/92076
11:35:03 <ski> resnik : as ParahSailin said, which is equal to `h =<< g . f'
11:35:13 <augur> question about state machines: if two states q and q' have identical out-going transitions, can they be collapsed into a single state?
11:35:31 <levi> It's certainly not mandatory, and you'll pick up a lot of algebraic concepts just from learning haskell, even if you wouldn't be able to recognize them as such.
11:37:59 <monochrom> augur: yes
11:38:43 <monochrom> unless they have different final-state status
11:39:34 <augur> monochrom: that's what i figured, and i convinced myself pretty well, but i wanted confirmation :)
11:41:34 <bos> the new IO manager in GHC HEAD is so jaw-droppingly fast.
11:41:57 <ludamad> bos: What exactly does the IO manager do ? /noob-question
11:42:16 <bos> ludamad: manages the IO that haskell programs perform.
11:42:30 <bos> sort of like what its name suggests :-)
11:42:31 <troydm> ludamad: schedules i/o operations
11:42:56 <tikhon> to be fair, it isn't immediately obvious what "manage IO" means
11:43:09 <ludamad> ok :-) followup bos, what was slower about it before ?
11:43:24 <bos> ludamad: we hadn't extended it to use multiple cores.
11:43:29 <ludamad> Ahh
11:44:45 <troydm> bos: btw thanks for the great book, recently read it :)
11:45:03 <bos> sure!
11:45:13 <bos> let me put into perspective how good the new IO manager is.
11:45:22 <ludamad> that'd be nice
11:45:31 <augur> is there a ref for the haskellwiki syntax?
11:45:36 <bos> with ghc 7.6.3, the current release: i can handle 31000 http requests per second with 16 cores.
11:45:46 <bos> with ghc HEAD: 390,000 requests per second.
11:45:54 <Clint> should someone be harassing bos about hpaste?
11:45:54 <bos> sorry, 398,000
11:46:09 <ludamad> Nice.
11:46:18 <ludamad> Sounds like it'll benefit my http server.
11:46:23 <joelteon> so the new IO manager is quite good, apparently
11:46:58 <bos> ooh, i just tweaked an RTS option and got that up to 450,000 requests per second.
11:47:01 <napping> bos: did that take any special configuration? The paper mentioned some stuff about disabling SMT and pinning to cores
11:47:09 <napping> OS-level configuration, I mean
11:47:38 <aristid> bos: that's on the traditional pong-http benchmark?
11:47:43 <bos> napping: this is without any attempt to tune.
11:47:53 <bos> aristid: yes, this is hitting stock acme-http
11:50:14 <petapetapeta> Any recommended learning material which can help me become a better Haskell programmer? I've written parsers, interpreters and used monads(although I'm not entirely comfortable using them)
11:50:58 <S_J> whats the easiest GUI to get  going with in haskell?
11:51:16 <Ralith> petapetapeta: stop worrying about learning material and start doing projects
11:51:24 <Ralith> larger ones, if necessary
11:52:19 <petapetapeta> Ralith: That might be an idea. But I'm afraid that if I have some bad habits they'll be reinforced
11:52:47 <petapetapeta> that is - writing non-idiomatic code and thinking OO instead of functional
11:53:01 <petapetapeta> Any ideas for a good beginner project?
11:53:49 <Ralith> petapetapeta: You shouldn't hesitate to write code for fear of establishing bad habits if you've already got that much study behind you.
11:53:56 <mbrock> FUZxxl: turns out that code does a whole lot more expensive comparisons than Data.List.sort :D
11:54:44 <Ralith> petapetapeta: post code samples and ask for critiques if it worries you.
11:54:51 <wojtekM_> higher fixity means stronger binding?
11:54:54 <elliott> petapetapeta: you can post reasonable amounts of code to the code review stack exchange and/or in here for review
11:55:09 <elliott> (no guarantee you'll get a response, though, but it's a good idea)
11:55:22 <petapetapeta> elliott: I've never seen that before! Thanks!
11:55:50 <petapetapeta> Ralith: That is a very good point. I guess I better stop reading the learning material and do some projects
11:55:55 <elliott> for few-line things this channel will probably give a quicker response, the stack exchange is probably better for longer code
11:56:07 <elliott> but yeah, you sound like you know the language well enough to just go out and code to me
11:56:12 <ski> wojtekM_ : yep
11:56:24 <elliott> beyond that, just read interesting stuff about Haskell :P
11:56:42 <elliott> some chapters of Real World Haskell might interest you if you haven't read it, the Typeclassopedia is a must-read at some point, etc.
11:57:14 <Ralith> petapetapeta: project ideas: a raytracer, a compiler, a realtime graphics demo
11:57:21 <wojtekM_> ski: Thanks
11:57:37 <mbrock> FUZxxl: of course the merge fold is no good :( it immediately mixes up the equivalence classes
11:58:12 <petapetapeta> Ralith:  Those sound quite cool :) Thanks!
11:58:17 <bootcode> hi all
11:58:24 <donri> bos: interesting how bad it performed on ghc 7.6; stepcut got much better results when he wrote acme-http with less cores and older ghc IIRC
11:58:30 <petapetapeta> elliott: I will try reading some of it. Any recommendations?
11:58:45 <donri> bos: or maybe your benchmarking methods differ
11:58:46 <wojtekM_> hpaste.org is dead?
11:59:18 <bootcode> regarding FFI: I want to allocate in Haskell a buffer, return it to C, and let C free it. Is Ptr good for this?
11:59:42 <elliott> petapetapeta: not really beyond what I already said :) you can read Haskell Weekly News or /r/haskell and the like for links to things
11:59:48 <elliott> just use the language and read about it and you'll get better
12:00:00 <bootcode> I read the docs and not sure if the stuff malloc-ed in Haskell might get moved by GC
12:00:07 <donri> bos: for reference, 200k rq/s in the sample session http://hub.darcs.net/stepcut/acme-http
12:00:21 <lispy> bootcode: To get cleaned up it needs a finalizer
12:00:53 <bootcode> lispy: even if I call free() on it from C?
12:00:53 <joelteon> one million requests in five seconds
12:00:56 <joelteon> that's quite good
12:00:56 <lispy> bootcode: (the exception being things like alloca that are stack based and get cleaned up that way)
12:01:13 <lispy> bootcode: Unless I've forgotten something important that should work fine
12:01:22 <petapetapeta> elliott: Cool :) It would indeed make sense to use those
12:01:25 <Ralith> petapetapeta: if you're interested in a compiler in particular, I recommend checking out http://hackage.haskell.org/package/llvm-general/
12:01:43 <Ralith> #haskell-llvm may also be of interest
12:01:45 <lispy> bootcode: although it's usually better to let the same side that allocated it also clean it up
12:02:00 <lispy> bootcode: tends to make the whole thing easier conceptually
12:02:21 * lispy => lunch
12:02:40 <petapetapeta> Ralith: I think I want to move a bit away from the compiler part of haskell. Been working quite a long with it lately, but it made me realize how cool haskell is!
12:03:05 <wojtekM_> Where could I paste some code so that you told me if I'm writing haskell?
12:03:16 <joelteon> gist is good
12:03:26 <elliott> @paste
12:03:26 <lambdabot> Haskell pastebin: http://lpaste.net/
12:03:29 <elliott> is the standard
12:03:49 <Ralith> petapetapeta: "part of haskell"?
12:04:11 <Ralith> petapetapeta: ooh, I forgot my current favorite kind of project: offline procedural graphics!
12:04:48 <petapetapeta> Ralith: In my experience writing compilers is much in the same vein as interpreters and parsers.
12:04:56 <petapetapeta> And I want to try a different type of project :)
12:05:11 <petapetapeta> Ralith: Uhh never heard about that
12:05:22 <Ralith> insofar as that they're all a matter of translating X into Y yeah they have a lot in common
12:05:37 <dwcook> I've heard that GeneralizedNewtypeDeriving is unsafe, but I would rather not write all new instances for all my newtypes. Should I go ahead and use it anyway?
12:05:41 <Ralith> it's a very very deep field, of course, but you are right to pursue your interests
12:05:58 <dwcook> If it helps, I don't currently use any other extensions.
12:06:07 <wojtekM_> https://gist.github.com/wojtnar/6311403 - is this acceptable code?
12:06:21 <petapetapeta> Ralith: I think I want to explore some different fields with Haskell before going deeply into a single one :)
12:06:39 <levi> dwcook: Should be fine.
12:07:03 <Ralith> petapetapeta: for example: implement http://math.andrej.com/2010/04/21/random-art-in-python/ in idiomatic Haskell. For good results, you may want to use http://hackage.haskell.org/package/random-fu and http://hackage.haskell.org/package/JuicyPixels .
12:07:26 <dwcook> levi, thanks.
12:07:42 <Ralith> graphical demos are always fun because the results are so direct and tinkerable
12:08:02 <petapetapeta> Ralith: Oh that looks very very interesting!
12:08:16 <Ralith> \o/
12:09:50 <petapetapeta> I'm gonna try that one :)
12:10:45 <wojtekM_> Anybody?
12:12:13 <napping> seems a bit odd
12:12:30 <napping> especially sL which is used only once
12:12:31 <levi> petapetapeta: Diagrams is a pretty cool library for vector graphics.
12:13:21 <wojtekM_> napping: ok, I have a bunch of similar functions with more bytes
12:13:37 <napping> why now "where w8 = fromIntegral <$> anyWord8", rather than abstracting only part
12:14:01 <Taneb> I am suddenly worried that Cont is the monad I need right now
12:14:28 <Ralith> petapetapeta: \o/
12:14:33 <Ralith> oh wait I already did that one
12:14:36 <Ralith> oh well generic yay
12:14:41 <petapetapeta> Ralith: haha :D
12:14:49 <napping> what's the type of anyWord8?
12:14:56 <petapetapeta> levi: I will look into! I already have so much to look into by now
12:15:34 <Ralith> petapetapeta: note that the main challenges therein are twofold: understanding the core of what the python program does in a very OOPy way, and translating it to idiomatic Haskell.
12:16:03 <augur> is there lambdacase in haskell yet?
12:16:07 <augur> i dont remember
12:16:20 <geekosaur> yes
12:16:27 <augur> hows it?
12:16:30 <wojtekM_> napping: let me try again
12:16:36 <geekosaur> if by haskell you mean ghc 7.6.3 and later
12:16:47 <augur> geekosaur: sure
12:16:48 <petapetapeta> Ralith: Yeah okay. So it will force me to think in a functional way
12:16:55 <petapetapeta> that is probably a good idea :)
12:17:41 <Ralith> I can't easily envisage any way you might get a working haskell impl without solving those problems one way or another, so yeah
12:17:55 <Ralith> just note that if you're making a typeclass you're doing something wrong.
12:17:56 <Taneb> Wait, I think I can get away with Either
12:18:06 <Ralith> probably.
12:18:09 <petapetapeta> Ralith: Okay :) I will keep that in mind
12:19:28 <Taneb> But Either would actually make this really ugly
12:19:40 <levi> Unless making a typeclass is the right thing to do. :P
12:21:03 <napping> wojtekM_: Making a where-binding just to give a long function a shorter name just seems like a bad idea, if the name is worth abbreviating it's probably worth doing it consistently in a longer scope
12:22:35 <Ralith> napping: I disagree. A particular use might call for a very short abbreviation indeed, which would be inappropriate for a widely visible name.
12:23:34 <Zenol> is it bad to writing fmap instead of map, liftM, liftA, etc?
12:23:49 <levi> I don't think so.
12:24:43 <bergmark> Zenol: i mostly use fmap
12:25:28 <ski> if you use `map' when you're handling lists, then this fact (that you're handling lists) stands out in the code
12:25:42 <Zenol> because I rerely use map, and never liftM.
12:25:44 <ski> (of course, it might be evident regardless)
12:25:46 <hape01> augur: the documentation mentions lambda-case: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#lambda-case
12:25:49 <napping> Ralith: Sure, but I doubt a single short function qualifies
12:25:52 <wojtekM_> https://gist.github.com/wojtnar/6311403 - better now?
12:26:01 <augur> hape01: cool thanks
12:26:04 <joelteon> downloads from haskell.org are going pretty slow for me. has anybody else noticed that
12:26:32 <napping> in particular, if you are defining a bunch of serialzation combinators for different sizes of words, that could be it's own module with some unexported abbreviations
12:26:44 <wojtekM_> Ralith: I have a bunch of those functions word16, word32, word64. I abbreviate in the same way in all.
12:27:35 <napping> in that case making one un-exported top-level binding is better than a bunch of where-clauses -- assuming you are defining these in a module that doesn't define other stuff
12:27:56 <johncrayton> Is there a sort of identity monad? I often write code that doesn't use a monad, using where = etc, and then find I want to thread some state later and so I want everything in do <- notation. Can I use a monad upfront, even if I'm not doing anything monadic?
12:28:23 <clahey> johncrayton, Identity
12:28:39 <petapetapeta> joelteon: I don't have any problem
12:28:46 <wojtekM_> napping: I could do that, thanks
12:28:55 <johncrayton> clahey: do people often use that for what I want? Or am I doing it all wrong in the first place?
12:29:16 <clahey> johncrayton, I don't think people usually do it that way, but it's an interesting idea.
12:29:37 <levi> Actually, I think often people use it that way.
12:29:45 <clahey> Oh, cool.
12:30:10 <napping> wojtekM_: you might also consider a definition along the line of concatBits hi lo = shiftL (fromIntegral hi) (bitSize lo) .|. fromIntegral lo
12:30:36 <napping> dunno if it optimizes decently, but then you get something like word16be = concatBits <$> word8 <*> word8
12:30:37 <levi> Libraries provide a monad stack for the common case where you want effects, so Identity trivially provides a base monad to use for them.
12:30:37 <S_J> :t maybe
12:30:38 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:30:58 <hape01> > :set -XLambdaCase
12:31:10 <hape01> > (\case 1 -> 100; 2 -> 200; 3->300) 2
12:31:11 <napping> also, have you looked at how binary and cereal define these things (I assume you're just redoing them for practice)
12:31:23 <hape01> > is dead?
12:31:31 <lambdabot>   <hint>:1:1: parse error on input `:'
12:31:31 <lambdabot>   can't find file: L.hs
12:31:31 <lambdabot>   <hint>:1:9:
12:31:31 <lambdabot>      parse error (possibly incorrect indentation or mismatched ...
12:31:38 <joelteon> cmon lambdabot, get it together.
12:31:52 <levi> I think something in mueval has regressed recently.
12:32:19 <hape01> > [1..5]
12:32:20 <lambdabot>   [1,2,3,4,5]
12:32:26 <hape01> > (\case 1 -> 100; 2 -> 200; 3->300) 2
12:32:27 <lambdabot>   <hint>:1:3: parse error on input `case'
12:32:30 <levi> I have been playing around with it for a project recently and it seems to have odd behavior like that in edge cases.
12:32:56 <hape01> How give Language extension -XLambdaCase to  >  ?
12:33:17 <levi> I think L.hs is its session state file. It's erroring on something and not writing a new one, thus the L.hs error the next time you use it.
12:34:44 <wojtekM_> napping: I am doing this for Attoparsec. I couldn't find readily available functions. Pracise, also. Looking at cereal now.
12:35:26 <napping> is attoparsec-binary yours then?
12:36:11 <bos> donri: stepcut's numbers were over localhost - mine are between two machines. that explains the difference.
12:36:32 <wojtekM_> Oh. How could I have missed that?
12:37:11 <ski> Taneb : ?
12:37:23 <wojtekM_> I know, I was initially undecided between Parsec and Attoparsec.
12:37:35 <Taneb> ski, I think Cont is the monad I want for this particular situation
12:37:43 <ski> the situation being ?
12:37:53 <napping> I wonder if parsec has ever been used for binary data
12:38:14 <carter> napping if you want performance, you probably shoudln
12:38:47 <wojtekM_> napping: I decided for Atto
12:39:00 <napping> yeah, that's why I doubt anyone has tried
12:39:01 <wojtekM_> napping: okay, my code is terrible, I'm down
12:39:06 <Taneb> ski, something I actually probably ought to use Either for
12:39:21 <napping> wojtekM_: I wouldn't be surprised if yours ended up more efficient, as elegeant as attoparsec-binary seems to be
12:40:00 <napping> though I guess using take to grab the right number of bytes and somehow casting is probably best, and maybe I'm overestimating - anyway, run benchmarks if you care
12:41:06 <wojtekM_> napping: Thanks for the compassion
12:42:01 <wojtekM_> napping: Now let me silently delete the gist
12:42:48 <ski> @type either (cont . const) return
12:42:48 <lambdabot> Either r a -> Cont r a
12:43:25 <arkeet> :t cont
12:43:25 <lambdabot> ((a -> r) -> r) -> Cont r a
12:43:55 <Taneb> ...actually, I could well use Cont
12:43:58 <Taneb> Aaaah
12:44:07 <Taneb> Screw it, I'm using Cont, if anything to get the experience
12:47:18 <S_J> > map (+10) [1..10]
12:47:19 <lambdabot>   [11,12,13,14,15,16,17,18,19,20]
12:48:35 <tnks> silly question, is there a way to get ghci to display the interface of a type class?
12:49:18 <ski> try `:info MyTypeClass' (`info' can be abbreviated to `i') ?
12:49:27 <tnks> ski: thanks.
12:49:31 <tnks> I forgot about :i
12:50:29 <wojtekM_> Cannot do something like this: import Data.Attoparsec.Binary (word16be as word16)?
12:51:24 <byorgey> nope, sadly
12:51:59 <scshunt> wojtekM_: no, but you can just do "word16be = word16"
12:52:07 <wojtekM_> ha! at last something that cannot be done
12:52:16 <wojtekM_> okay
12:54:50 <Tekmo> Has anybody ever explored adding referencing counting for managing external resources in Haskell (i.e. handles, sockets, etc.)?
12:55:25 <S_J> how do you mean Tekmo?
12:55:58 <tomejaguar> Tekmo: that's a very good question.  I have been wondering myself.
12:56:14 <Tekmo> This is related to resource allocation using `pipes`
12:56:37 <Tekmo> I'd like something to be able to detect when the last reference to some allocated resource is gone and *promptly* deallocate the resource
12:57:52 <Tekmo> So instrumenting the garbage collector is insufficient for this purpose because then the handle or socket will only get freed whenever garbage collection occurs
12:58:52 <levi> Tekmo: Control.Monad.Trans.Resource from conduit apparently uses them for resourceForkIO
12:59:37 <NemesisD> hey guys. i'm trying to statically link a project and it uses the mysql package. i've added ld-options: -static, extra-libraries: pthread mysqlclient and i'm getting a linker error "undefined reference to compress" in libmysqlclient.a(my_compress.o)
12:59:46 <NemesisD> anyone know what might be going on? i'm lost
12:59:58 <Tekmo> levi: Yes, but this must be done manually.  I would like something automatic, like garbage collection but prompter
13:01:12 <jfischoff> Tekmo: I wonder if you could use the FFI to do that?
13:01:26 <jfischoff> oh and hey :)
13:01:32 <Tekmo> jfischoff: Hi! :)
13:01:50 <Tekmo> jfischoff: The issue is that I want it to be able to take advantage of Haskell's ability to trace references
13:02:02 <jfischoff> trace?
13:02:15 <Tekmo> jfischoff: Let me use a concrete example
13:02:22 <Tekmo> jfischoff: I allocate some Handle from a file
13:02:40 <Tekmo> jfischoff: I want that Handle to be finalized shortly after the last reference to the Handle is lost within Haskell
13:02:56 <Tekmo> jfischoff: ... using the same machinery that Haskell uses to detect that something needs to be garbage collected
13:03:05 <jfischoff> yeah sounds trick :)
13:03:07 <jfischoff> y
13:04:33 <levi> I think that reference counting might interact badly with laziness, in general.
13:04:41 <donri> bos: ah, cool
13:04:57 <Zenol> liftM concat . sequence . map (mapM myFct) T.T
13:05:17 <Zenol> if anyone have a short way to write that...
13:05:50 <Tekmo> Is T.T an emoticon or a module T that exports a constructor T?
13:06:12 <levi> Tracing references is entirely different from reference counting.
13:06:24 <donri> Zenol: sequence . map is just mapM no?
13:06:26 <NemesisD> bos: oh hey. you're actually probably the best person to ask about statically linking mysql-simple
13:06:34 <donri> @hoogle concatMapM
13:06:34 <lambdabot> No results found
13:06:36 <donri> :(
13:06:38 <Tekmo> Well, whatever it is called, what I want is the ability to release a resource when there are no more references to it
13:07:24 <levi> That's reference counting. But it works by incrementing a count when you take a reference, and decrementing it when you release the reference.
13:07:25 <NemesisD> the mysql docs say that if you see undefined references to compress/uncompress to compile with -lz, but passing -lz to ghc doesn't seem to fly, nor does adding "z" to extra libraries
13:08:00 <Tekmo> levi: No, I want this done automatically
13:08:10 <Tekmo> levi: The same way ghc does garbage collection: automatically
13:08:23 <levi> It can be done automatically. It *is* a form of garbage collection.
13:08:26 <donri> Tekmo: i think the problem is that you want RAII with a tracing GC
13:08:26 <Tekmo> levi: But I want it to occur more promptly than garbage collection typically occurs
13:08:34 <Tekmo> levi: Right, it's a form of garbage collection
13:08:58 <Tekmo> levi: But the problem is that instrumenting the existing garbage collector won't work for this particular purpose because the current garbage collector only runs when the program is low on memory
13:09:13 <jfischoff> ah not low on resources
13:09:14 <levi> So you want a separate garbage collector just for handles.
13:09:18 <Tekmo> levi: I'd like to have some sort of "parallel" collection going on that occurs on a regular basis that releases these resources automatically
13:09:19 <Tekmo> Exactly
13:09:48 <jfischoff> maybe that is not what you want
13:10:04 <jfischoff> maybe it is better to have a pool you manage yourself?
13:10:17 <jfischoff> opening and closing handles is not that efficent
13:10:24 <Tekmo> The problem is that a managed pool doesn't work in the scenario I have in mind: `pipes`
13:10:27 <levi> I think such a collector could have simpler invariants, as it doesn't mutate anything, but you'd still have to trace a potentially large heap area for references.
13:10:46 * jfischoff nods
13:11:15 <Zenol> donri: Ah, yes, sequence.map = MapM x.x
13:11:55 <Tekmo> So has there been any research into using garbage collection to manage handles and other similar resources?
13:11:56 <paolino> is it possible to access a IntMap (IntMap a) with a lens ?
13:12:24 <levi> I'm sure there has been, but I'm not familiar with it.
13:12:25 <Tekmo> paolino: at . at, I think
13:12:50 <Tekmo> paolino: Or maybe it's: at i1 . at i2
13:12:54 <paolino> at 1 uses Just a as value
13:13:36 <Tekmo> paolino: So maybe: at (Just i1) . at (Just i2)
13:13:41 <supki> paolino: ix i1 . ix i2
13:13:57 <supki> paolino: alternatively  at i1 . traverse . at i2 . traverse
13:14:34 <paolino> traverse is for Maybe ?
13:15:08 <supki> traverse is for anything Traversable
13:15:13 <supki> in that case it's Maybe, yes
13:16:19 <paolino> thanks
13:16:59 <donri> Tekmo: duno about haskell but it sounds what you're after is idiomatic rust, where garbage is promptly freed via either reference counting or static region analysis
13:17:41 <elliott> GC is generally considered too erratic to entrust with more limited resource management.
13:18:07 <elliott> e.g. Python will close file handles when they're GC'd, and probably many other languages too, but they still have facilities for more direct resource management because it's not considered enough.
13:18:24 <pentace> Does that first comment in that ticket http://ghc.haskell.org/trac/ghc/ticket/8154 imply that the semantics of (open) type instances has changed in the recent GHC version?
13:18:30 <donri> it's an implementation detail of cpython not shared by pypy
13:18:30 <auguste2> what is considered the best introduction to category theory out there?
13:18:35 <donri> thus the "with" statement
13:18:46 <elliott> donri: well, sure. but I doubt that is the main reason anyone cares :p
13:18:48 <arkeet> auguste2: with what purpose/background?
13:18:50 <tac> auguste2: might get better help in ##categorytheory
13:18:53 <NemesisD> any of you guys know about static linking and/or mysql?
13:18:56 <arkeet> a lot of people here seem to be partial to Awodey.
13:19:05 <tac> auguste2: But a lot of people like Awodey... like arkeet said.
13:20:03 <levi> How is Pierce's category theory book?
13:20:22 <pentace> Or is it just a really old bug being finally fixed?
13:20:30 <tac> levi: It's all right. Less than great, though, I think.
13:21:09 <donri> pentace: there's some work for overlapping type instances for 7.8 IIUC
13:21:15 <Placinta> What do I have to do to make ghci work, when I import Paths_pkgname, but it doesnt find it?
13:21:45 <donri> Placinta: :set -idist/build/autogen
13:22:03 <pentace> donri: You mean it's only a temporary change?
13:22:17 <ski> auguste2 : "Conceptual Mathematics" by Schanuel and Lawvere might be interesting
13:22:18 <levi> I've got a copy of Lawvere & Schanuel's "Conceptual Mathematics: A first introduction to categories" which is definitely oriented to the non-expert.
13:22:25 <levi> Heh.
13:22:34 <Tekmo> elliott: So why is it too erratic?  Could one provide a command to mandatorily issue a check to ensure promptness?
13:22:42 <arkeet> levi: I think I looked at that once.
13:22:46 <arkeet> and liked what I saw.
13:22:58 <donri> pentace: uh or i'm misremembering but relevant: https://github.com/ghc/ghc/blob/master/docs/users_guide/7.8.1-notes.xml#L31
13:23:28 <wojtekM_> Thank you list. I will be back.
13:23:42 <levi> I'm enjoying it so far, though it certainly takes its time.
13:24:06 <donri> Tekmo: https://en.wikipedia.org/wiki/RAII#Reference_counting
13:24:23 <elliott> Tekmo: because GC isn't very reliable by nature :)
13:24:49 <Tekmo> elliott: I mean issuing a mandatory GC cycle for the handle garbage collector
13:25:01 <Tekmo> elliott: Sort of like `performGC`
13:25:08 <Placinta> donri: Is that ghci specific, or is it possible to set from source as well?
13:25:38 <donri> Placinta: ghc[i] specific. i suppose you could use OPTIONS_GHC but, don't ;)
13:25:52 <donri> Placinta: why do you need it in the source?
13:26:05 <pentace> donri: Yes, I know about closed type families. But to me it looks like the "old", open type families will change there semantics in the new GHC version, because some instance definitions are not compilable anymore.
13:26:28 <donri> pentace: might get less noise and more attention in #ghc btw
13:26:40 <pentace> Ah, thanks
13:27:02 <Zenol> is (, Int) a fonctor? Not really no?
13:27:16 <Placinta> donri: Well when I import Paths_pkgname without doing cabal build, I get an error. I want to be able to develop as well as make sure that on install, everything works properly.
13:27:17 <ski> it's a functor, but not a `Functor'
13:28:13 <Placinta> donri: I'm looking for a way to do local dev, as well as correct deployment
13:28:38 <donri> Placinta: cabal build is what generates that file, so you need to run it. but you can add a .ghci file to the project with that :set line to make it a bit easier. the upcoming cabal-install fixes all this with the new 'repl' command anyway.
13:29:12 <Zenol> ski: What do you means by 'functor' ?
13:29:27 <donri> Placinta: (you can also add that module to exposed-modules if you want it available everywhere)
13:30:25 <donri> Zenol: what do you mean by (, Int)? (a,) is a Functor ...
13:30:35 <ocharles> Does anyone have any pointers to reading about the technique of doing 'instance a ~ Foo blah => Class (Some a)' rather than 'instance Class (Some (Blah a))'?
13:30:43 <ocharles> I've seen it done a few times, and I believe it helps inference or something
13:30:45 <donri> > fmap succ (1,2)
13:30:47 <lambdabot>   (1,3)
13:30:55 <ocharles> but i was wondering if there was some clear writing on the subject
13:31:11 <Tekmo> ocharles: It's really simple
13:31:23 <ocharles> i know the how of it
13:31:31 <ocharles> (instance resolution happens before considering context)
13:31:44 <ocharles> but i was hoping to develop intuition on why that becomes necessary or what problems it prevents
13:31:54 <Tekmo> ocharles: It's purely to avoid `FlexibleInstances`
13:32:11 <Placinta> donri: If I set the flag in .ghci file, how dow I load an .hs file that is insde src/Web/myfile.hs?
13:32:21 <donri> but requires type families or gadts instead?
13:32:44 <donri> Placinta: :load src/Web/myfile.hs
13:32:52 <ocharles> i'm pretty certain that still requires FlexibleInstances. I was motivated to ask this looking at https://github.com/ermine-language/ermine/blob/master/src/Ermine/Builtin/Type.hs
13:32:59 <ocharles> but my question isn't really about that file
13:33:00 <donri> Placinta: might want :set -isrc:dist/build/autogen instead
13:33:08 <ocharles> i believe lens does this trick a lot too
13:34:38 <Placinta> donri: Is the .ghci file loaded when I do :cd into the relavant dir?
13:35:11 <donri> ocharles: that's using type families though. maybe you're thinking of type families vs fundeps vs plain mptcs
13:35:27 <ocharles> hmm, http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/equality-constraints.html indicates this is to get fun. dep. like behaviour
13:35:34 <donri> Placinta: don't think so, but don't know
13:35:50 <ocharles> but i've seen this without associated types, i thought
13:35:53 <Placinta> donri: How do I load the .ghci file then
13:36:21 <Tekmo> ocharles: Why don't you just ask the authors why they did it?
13:37:01 <donri> or just ask edwardk, the master of type inference behavior
13:37:19 <jfischoff> edwardk: ping ^
13:37:24 <ocharles> Tekmo: probably a better approach :)
13:37:31 <levi> Tekmo: Oleg's site has a paper on 'Lightweight Monadic Regions'
13:37:56 <Tekmo> levi: I read that and it does not solve the `pipes` problem
13:38:23 <ocharles> http://stackoverflow.com/questions/11553705/haskell-equality-constraint-in-instance looks like it might be what i want
13:38:38 <aristid> Tekmo: how did you resolve the lens laws issues?:)
13:39:15 <Tekmo> aristid: I haven't yet, but the law violations are definitely important
13:39:30 <ocharles> thanks for that answer, kosmikus !
13:39:33 <ocharles> :)
13:39:54 <Tekmo> aristid: For example, those law violations mean that `zoom` is not a monad morphism
13:39:56 <Zenol> donri: return 5 :: (Int, Int) ?
13:40:00 <Zenol> > return 5 :: (Int, Int) ?
13:40:01 <lambdabot>   <hint>:1:25:
13:40:01 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
13:40:11 <Zenol> > return 5 :: (Int, Int)
13:40:12 <lambdabot>   No instance for (GHC.Base.Monad ((,) GHC.Types.Int))
13:40:12 <lambdabot>    arising from a use ...
13:40:13 <aristid> Tekmo: and the improper lenses don't give a way out, right?
13:40:14 <donri> Zenol: return is not part of Functor
13:40:22 <Tekmo> aristid: Which makes sense when you think about it: `zoom (splitsAt 5) m1 >> zoom (splitsAt 5) m2 /= zoom (splitsAt 5) (m1 >> m2)`
13:40:26 <Zenol> ah, yehm pure is applicative.
13:40:32 <Tekmo> aristid: Improper lens is just something edward made up
13:40:39 <Tekmo> aristid: Like affine traversals
13:40:42 <aristid> Tekmo: :)
13:40:50 <donri> Zenol: and yeah, no, can't have applicative or monad tuple at least not without some identity like monoid
13:40:58 <Tekmo> aristid: Calling it an improper lens doesn't resolve the problem
13:41:18 <aristid> Tekmo: i mean i guess the thing is, zoom is still a useful function for pipes, right?
13:41:19 <Tekmo> aristid: The issue still remains: `zoom` is not a monad morphism when you pass it a law-breaking lens/isomorphism
13:41:25 <donri> Zenol: oh that's in base apparently, Monoid a => Applicative ((,) a)
13:41:31 <aristid> Tekmo: right.
13:41:39 <Tekmo> aristid: There are two scenarios I'm considering
13:41:50 <donri> Zenol: but Int isn't a Monoid
13:41:50 <Tekmo> aristid: One is to provide them and warn users of them that `zoom` is not a monad morphism in conjunction with them
13:42:10 <Tekmo> aristid: The second is to provide `zoom` "pre-applied" to the lenses (conceptually), where there is no pretext of being a monad morphism
13:42:35 <Tekmo> aristid: In other words: splittingAt :: Int -> StateT ... -> StateT
13:42:36 <donri> > pure 5 :: (Sum Int, Int)
13:42:37 <lambdabot>   (Sum {getSum = 0},5)
13:42:38 <aristid> Tekmo: would you do that for the law-abiding ones as well?
13:42:43 <donri> ^ Zenol
13:42:49 <Tekmo> aristid: As far as I can tell, none of them are law-abiding
13:42:54 <aristid> Tekmo: oh.
13:43:05 <Tekmo> aristid: It's really easy to tell if they break the laws
13:43:10 <NemesisD> is it possible to completely statically link a haskell binary such that the only thing that must match between dev and production is the architecture?
13:43:14 <Tekmo> aristid: Just ask yourself if `zoom` would be a monad morphism when using that lens
13:43:15 <ocharles> we haven't written a law abiding Iso (Producer ...) (Producer ..) ?
13:43:23 <Tekmo> ocharles: It's conceptually not possible
13:43:28 <NemesisD> i get tons of warnings like Using 'setnetent' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
13:43:29 <aristid> Tekmo: heh for me that would not be the easiest way to tell :)
13:43:30 <ocharles> oh :(
13:43:37 <Tekmo> aristid: It sounds hard, but its not
13:43:38 <Zenol> donri: Thanks :)
13:43:38 <ocharles> I thought my tar one was valid once i re-emitted the header
13:44:14 <Tekmo> ocharles: Think of it this way: does "zoom tarEntry (return ()) == return ()"?
13:44:57 <Tekmo> So really whether or not the law violations are a bad thing completely depends on whether or not you care if `zoom` obeys the moand morphism laws
13:45:07 <aristid> well i dunno
13:45:17 <aristid> i think the roundtripping for Isos is an important law in itself.
13:45:41 <Tekmo> aristid: Yes, but you don't necessarily have to provide an `Iso`
13:45:53 <aristid> fair.
13:46:08 <Tekmo> aristid: After all, I could specialize those lenses to the minimal type that `zoom` requires, which uses `Focusing s m` as the base functor
13:46:20 <Tekmo> aristid: Then there's no pretext of being a lens or an isomorphism
13:46:21 <aristid> ocharles: want to know how i convinced Tekmo that splittingAt 5 was not a valid Iso?:)
13:46:25 <ocharles> Tekmo: i can't see why that property doesn't hold
13:46:30 <ocharles> aristid: yes please!
13:46:42 <ocharles> i have only been skimming emails recently
13:46:45 <ski> Zenol : "functor" in the sense of category -- if by `(,Int)' we mean a type function that given a type `T', gives the type `(T,Int)', then we can certainly define a sensible "mapping function" of type `(a -> b) -> ((a,Int) -> (b,Int))' which satisfy the functor laws, so in this sense, it is a functor
13:46:52 <aristid> ocharles: what does ([], [1]) round-trip to?
13:46:53 <Tekmo> ocharles: This was completely in IRC, which is probalby why you missed it
13:46:59 <aristid> ocharles: it was on irc.
13:47:00 <ocharles> but i have got a date for my pipes talk on the 18th of sept, so I better understand this if I decide to bring it up ;)
13:47:01 <ski> Zenol : sorry, in the sense of category theory, i meant to write
13:47:03 <ocharles> ah, ok
13:47:20 <Tekmo> Anyway, that's not a totally big deal
13:47:22 <ocharles> aristid: what do you mean by ([], [1])?
13:47:27 <aristid> ocharles: it will round-trip to ([1], [])
13:47:28 <Tekmo> aristid: Because I can always restrict it to something like:
13:47:28 <ocharles> A producer that yields twice?
13:47:55 <aristid> ocharles: i'm not totally following the pipes types there.
13:47:56 <arkeet> ocharles: the splittingAt thing.
13:48:19 <Tekmo> aristid: splitsAt :: (Monad m) => (Producer a m (Producer a m r) -> Focusing s m (Producer a m (Producer a m r))) -> Producer a m r -> Focusing s m (Producer a m r)
13:48:20 <aristid> ocharles: splittingAt conceptually is pair-of-lists<->list
13:48:22 <Tekmo> ... or something like that
13:48:32 <Tekmo> aristid: Remember that `zoom` does not specifically require a lens or iso
13:48:39 <Tekmo> aristid: It only requires a morphism between `StateT` computations
13:48:40 <aristid> Tekmo: right.
13:48:42 <arkeet> at least it's an iso when restricted to images
13:49:00 <Tekmo> aristid: So I can always provide the restricted version, which has no laws worth mentioning
13:49:12 <aristid> Tekmo: except you can't use it with zoom
13:49:16 <Tekmo> aristid: You can
13:49:21 <Tekmo> aristid: That type is what zoom expects
13:49:24 <aristid> Tekmo: i mean without breaking the monad morphism
13:49:30 <Tekmo> aristid: Right, it stil breaks the monad morphism
13:49:53 <Tekmo> aristid: Here's the key point I'm tryign to make: ANY subsetting function will not be a monad morphism
13:50:19 <Tekmo> aristid: Forget zoom for a second
13:50:19 <S_J> Hmm, multithreading breaks that nice sequential world into things that depend on timing. wouldnt ti be possible to write a scheduler on top of the OS scheduler where you could schedule things completely yourself?
13:50:35 <Tekmo> aristid: Let's assume that I had some function `restrictTo` that limited a parser to `n` elements
13:50:43 <aristid> Tekmo: ok?
13:50:56 <Tekmo> aristid: Then by definition: `restrictTo n p1 >> restrictTo n p2 /= restrictTo n (p1 >> p2)`
13:51:08 <Tekmo> aristid: So `restrictTo` can never be a monad morphism
13:51:22 <Tekmo> aristid: ... whether or not it is implemented using `zoom` or lenses internally
13:51:26 <aristid> but _1 is valid for zoom, right?
13:51:44 <Tekmo> Forget about the lenses for a scond
13:51:57 <Tekmo> Just think about some opaque function named `restrictTo`
13:52:14 <Tekmo> We don't know how it works internally.  All we know is that it restricts a parser to n elements
13:52:16 <aristid> Tekmo: i fully see why it isn't a valid monad morphism. well, "fully" overstates my comprehension, but
13:52:59 <aristid> Tekmo: i'm just now getting confused on the lines of "but when does zoom ever _work_?"
13:53:20 <Tekmo> aristid: Zoom works on _1, just like you said
13:53:37 <Tekmo> aristid: zoom _1 m1 >> zoom _1 m2 = zoom _1 (m1 >> m2)
13:54:16 <aristid> Tekmo: but zoom _Left would be invalid i suppose? (i bet it wouldn't typecheck in the first place)
13:54:47 <donri> :t zoom
13:55:03 <aristid> lambdabot: y u slow
13:55:03 <Tekmo> aristid: I'm not sure
13:55:27 <Tekmo> aristid: I think it would type-check and work
13:55:32 <Tekmo> aristid: and obey the relevant laws
13:55:46 <aristid> Tekmo: i'm confused what "subsetting" means
13:55:55 <Tekmo> aristid: It would probably end up bringing in some sort of `Monoid` constraint to handle the case where the state was `Right` as a sensible default
13:56:07 <Tekmo> aristid: I use "subsetting" to mean "restricting the parser to a subset of the input"
13:57:12 <Tekmo> aristid: I just checked and I was right.  It uses a `Monoid` constraint on the `Right` type variable in case the state is a `Right`
13:57:33 <aristid> Tekmo: i mean it sounds to me right now, ignoring my usual confusion for the moment, that the pre-composed zooms without pretension as to morphism laws would be the sensible thing
13:57:45 <Tekmo> aristid: Yeah, I think so, too
13:58:03 <Tekmo> aristid: Alternatively, to rephrase the subsetting so that it does form a monad morphism
13:58:22 <Tekmo> aristid: What I mean by that is to define a subset as starting at a particular place in the input, so that future subsets refer to the same starting point
14:00:41 <clahey> Where is the haskell pastebin?
14:01:09 <elliott> @paste
14:01:09 <lambdabot> Haskell pastebin: http://lpaste.net/
14:01:36 <napping> Tekmo: what did you want for resource handling? Things like generationalGC work against promptly finding garbage
14:02:07 <hpaste_> clahey pasted “ghc gives a bug” at http://lpaste.net/92082
14:02:34 <clahey> Does anyone know what's going on with this piece of code?
14:02:42 <Tekmo> napping: An automatic collector only for handles or similar resources that cleans them up with reasonable promptness and that you can flush more rapidly by manually triggering a collection
14:02:57 <clahey> ghc reports a kind incompatibility when matching types and then panics.
14:03:05 <napping> but what can retain handles?
14:03:33 <napping> maybe with-style combinators for uses, plus refcounting the underlying resources?
14:03:35 <clahey> The Expected type and Actual type match, but it says that there's a kind incompatibility.
14:04:01 <elliott> clahey: you could show the error
14:04:15 <Tekmo> napping: That's a good question.  I didn't think that through.  I was thinking "collect it when there are no more ways to read or write to it
14:04:22 <clahey> Unfortunately it's on another machine, but I'll try.
14:04:54 <napping> at the very least, I think you'd need some kind of regions on the haskell side to delimit the lifetime of references into your little heap
14:05:15 <donri> soooo any reason why i shouldn't put INLINABLE on all-the-things? why isn't this the default?!
14:05:17 <clahey> Okalee dokalee.
14:05:28 <clahey> elliott, Trying it on this different machine gave a useful error message.
14:06:11 <Tekmo> napping: Actually, now that I think about it, regions might work for my specific use case.  Give me some more time to digest this
14:06:13 <elliott> clahey: I expected as much -- usually errors like that are just bugs in the error reporting's clarity
14:06:22 <elliott> fixed already, if that machine has a newer version :)
14:06:45 <petapetapeta> When using JuicyPixels, how do I convert an Int to Pixel8?
14:07:51 <ericmoritz> how's my code? https://gist.github.com/ericmoritz/6311847
14:08:20 <clahey> elliott, Indeed.
14:10:28 <paolino> petapetapeta, fromIntegral
14:10:34 <enthropy> clahey: you're missing parentheses like  lift (computation parameter
14:11:11 <petapetapeta> paolino: thought I had tried that earlier. Tried it again now and it worked! Thanks
14:11:17 <enthropy> ah that's already been addressed
14:11:41 <donri> ericmoritz: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Version.html ;)
14:11:56 <clahey> enthropy, Yep.  Eventually figured it out.
14:12:01 <clahey> Is there a better way to write:
14:12:05 <notdan> @ty (+)
14:12:05 <lambdabot> Num a => a -> a -> a
14:12:29 <clahey> computation >>= \parameter -> lift $ function parameter  ?
14:12:56 <enthropy> computation >>= lift . function -- is pretty clear
14:13:22 <ericmoritz> donri: that code was for the exercise
14:13:23 <enthropy> unlike most things you'll get out of lambdabot's @pl
14:13:31 <ski> or `lift . function =<< computation'
14:13:35 <donri> ericmoritz: suspected as much, thus the wink :)
14:13:35 <ericmoritz> donri: thanks for the link nonetheless.
14:14:19 <donri> @pl computation >>= \parameter -> lift $ function parameter
14:14:22 <lambdabot> computation >>= (lift $) . function
14:14:22 <lambdabot> optimization suspended, use @pl-resume to continue.
14:15:10 <clahey> ski, Yeah, I rewrote it that way on my own so that the ordering was more clear.
14:15:20 <clahey> I think I might switch to always using =<< so that it matches .
14:15:46 <clahey> Unless there's a common flip (.) that I'm not thinking of for some reason.
14:15:59 <donri> :t (>>>)
14:16:00 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
14:16:25 <augur> anyone wanna vet this iteratees tutorial?
14:16:47 <donri> possibly Tekmo ;)
14:17:08 <clahey> One advantage of =<< is that it matches well when you have a <- at the beginning of the line.
14:18:21 <ski> aye
14:18:50 <donri> it doesn't match the ordering of effects though
14:18:57 <donri> > const Nothing =<< undefined
14:18:58 <lambdabot>   *Exception: Prelude.undefined
14:18:59 <clahey> donri, True.
14:19:42 <donri> which isn't really worse than a strict function
14:19:45 <Kinnison> > const Nothing =<< return undefined
14:19:46 <lambdabot>   Nothing
14:19:53 <monochrom> switch to right-to-left to match the ordering :)
14:20:54 <clahey> I mean, right to left matches computation order of .
14:21:15 <tomejaguar> Kinnison++
14:21:35 <clahey> Well, actually, because of laziness, it doesn't, huh...
14:21:59 <donri> :t (<=<)
14:22:00 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
14:22:06 <tomejaguar> clahey: Ordering depends on the monad, but yes =<< is the monadic equivalent of $
14:22:13 <tomejaguar> :t ($)
14:22:13 <lambdabot> (a -> b) -> a -> b
14:22:16 <tomejaguar> :t (=<<)
14:22:17 <lambdabot> Monad m => (a -> m b) -> m a -> m b
14:22:20 <ski> > return Nothing =<< return undefined
14:22:21 <lambdabot>   Nothing
14:22:34 <clahey> :t (>>=)
14:22:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:22:51 <hpaste_> WraithM pasted “Writer wonad in type classes” at http://lpaste.net/92083
14:23:02 <clahey> =<< is the equivalent of $ and <=< is the equivalent of .  ?
14:23:06 <tomejaguar> Yes
14:23:07 <donri> > const Nothing <$> undefined
14:23:08 <lambdabot>   No instance for (GHC.Show.Show (f0 (Data.Maybe.Maybe a0)))
14:23:08 <lambdabot>    arising from ...
14:23:22 <donri> > const Nothing $ undefined
14:23:24 <lambdabot>   Nothing
14:24:08 <WraithM> I explain my problem in my lpaste. I'm curious if I'm over-thinking stuff or just doing it wrong.
14:24:21 <donri> > const undefined <$> Nothing
14:24:22 <lambdabot>   Nothing
14:24:26 <clahey> Huh, so a =<< b c can be rewritten as a <=< b $ c
14:24:37 <ski> WraithM : the type `w' which satisfies `Monoid w' in the signature of `test' need not be equal to `String'
14:24:53 <clahey> And if it's lift . a =<<, that makes the .s and <=< go together.   lift . a <=< b $ c
14:24:57 <clahey> Fascinating.
14:25:16 <ski> WraithM : if you say `test :: Monoid w => ..w..', you're claiming that `test' works for *any* choice of `w' (which is in class `Monoid') which the *caller* of `test' chooses
14:25:34 <ski> WraithM : you (the writer of `test') does not get to decide that `w' must be the type `String'
14:25:41 <WraithM> I see
14:25:49 <WraithM> Is there a good way to express that?
14:25:56 <ski> now, it's not clear what you really wanted to express
14:26:14 <monochrom> test :: a -> Writer String Bool
14:26:18 <donri> WraithM: type families or fundeps
14:26:24 <Tekmo> augur: I'm back.  Want me to read your tutorial?
14:26:26 <ski> perhaps you wanted the type you wrote, in which case the implementation is not allowed
14:26:35 <ski> perhaps you wanted what monochrom said
14:26:37 <monochrom> in fact, I am not even convinced of the value of the type class Test altogether
14:26:43 <augur> Tekmo: hey. sure, give me a bit, im adding more fun stuff :p
14:27:08 <tomejaguar> clahey: personally I use <=< and . in preference to =<< and function application
14:27:14 <ski> yes, that's a separate issue : possibly it's better to not use a class at all (but the same kind of issue as above can still be valid)
14:27:25 <WraithM> ski, monochrom: I originally wrote it like monochrom did. However, I want to generalize the writer and use it with different kinds of logs.
14:27:42 <ski> WraithM : such as ?
14:28:10 <monochrom> yeah, show 3 concrete examples
14:28:25 <donri> WraithM: then you need an associated type or a multi-parameter type class with a functional dependency
14:28:33 <monochrom> do not generalize until you have 3 concrete examples
14:28:39 <clahey> tomejaguar, I like it.
14:28:47 <WraithM> How about I write some examples and come back
14:28:55 <ski> sure
14:29:01 <WraithM> Cool
14:29:27 <donri> and quite possibly monochrom is right, but also: it's an opportunity to learn about type families and fundeps!
14:30:19 <monochrom> it's an opportunity for information overload and stopping production
14:30:36 <donri> my philosophy is "write the most complex and advanced thing that could ever work, *then* dumb it down to the simplest thing that could possibly work" ;)
14:30:46 <WraithM> lol
14:31:29 <clahey> Now I need to write a system for having an idle function that I turn on and off.
14:31:40 <clahey> "turn on this idle function, unless it's already queued."
14:31:52 <Tekmo> How do you turn a function on?
14:32:11 <clahey> Sorry, idle IO computation.
14:32:14 <donri> with smooth talk
14:32:31 <jfischoff> Is the HList TypeCast mechanism more powerful than equality constraints, or even comparable?
14:32:34 <Tekmo> How do you turn an IO computation on?
14:32:57 <clahey> Tekmo, It's an IO Bool that I want to run over and over again until it returns False.
14:33:10 <donri> no one knows. anytime anyone tried to understand an IO computation, it launched missiles.
14:33:14 * jfischoff lusts for a modern HList
14:33:33 <Tekmo> jfischoff: You mean `(,)` and `()`?
14:33:40 <monochrom> use a global IORef to turn on/off an IO action
14:33:40 <clahey> But I want to be able to have a reference to it that lets me turn it on and off.
14:33:58 <Tekmo> clahey: So the idea is that you have some thread running in the background
14:34:10 <Tekmo> clahey: That executes this action only when some criterion is true
14:34:24 <jfischoff> Tekmo: I don't know, do you mean (a, (b, (c, ())))?
14:34:29 <clahey> Tekmo, Not a thread, actually.  It's going to run in an idle function in the Gtk main loop.
14:34:30 <Tekmo> jfischoff: Yes
14:34:52 <Tekmo> clahey: YOu can use STM for this purpose
14:35:05 <jfischoff> Tekmo: yes with prelude like functions
14:35:07 <Tekmo> clahey: Probably even an `MVar` would suffice
14:35:15 <Tekmo> clahey: However, I'll stick to STM for simplicity
14:35:26 <jfischoff> "functions" ~ inductive type classes
14:35:35 <WraithM> donri: Just out of curiosity's sake (maybe type familes / fundeps are secretly what I've been looking for all my life) could you send me a link to stuff that explains that business?
14:35:36 <clahey> Tekmo, I don't think I want to be running in a different thread, so STM is overkill, I think.
14:35:52 <Tekmo> clahey: YOu have a `TVar Bool` that you initialize to either `True` or `False` that is responsible for signaling whether or not that `IO` action should proceed
14:35:57 <Tekmo> clahey: I didn't say anything about threads
14:36:21 <Tekmo> clahey: So wait, then I have a question for you
14:36:28 <clahey> Tekmo, But when I set it to False, I don't want the idle function to fire over and over again and just poll that TVar.
14:36:43 <Tekmo> clahey: It won't
14:36:46 <Tekmo> clahey: That's the magic of STM
14:37:00 <Tekmo> clahey: YOu can write it so that it will block and sleep until the `TVar` status switches
14:37:13 <clahey> Tekmo, But if it blocks and sleeps, the rest of my main loop can't run.
14:37:21 <clahey> Thus the TVar will never change status.
14:37:24 <Tekmo> clahey: I think you have contradictory goals
14:37:36 <Tekmo> clahey: You want it to not poll, but you don't want to use concurrency either
14:37:40 <tomejaguar> jfischoff: Yes I quite want something like that
14:37:45 <Tekmo> clahey: I don't think you can simultaneously satisfy those two criteria
14:38:00 <clahey> Tekmo, Are you familiar with the Gtk main loop?
14:38:00 <donri> WraithM: perhaps http://byorgey.wordpress.com/2010/07/06/typed-type-level-programming-in-haskell-part-ii-type-families/
14:38:05 <Tekmo> clahey: Yes, vaguely
14:38:22 <WraithM> donri: Thanks!
14:38:27 <donri> WraithM: (and the previous post it links in the first paragraph)
14:38:59 <WraithM> Could it be possible that I want a Multiparameter Typeclass?
14:39:38 <donri> WraithM: that's one way, but you'd need a fundep on it to get the type inference you wanted
14:39:39 <clahey> Tekmo, So, in the end, the answer is that it's not polling or using concurrency, it's using IO signalling.
14:39:56 <Tekmo> clahey: So who is responsible for running this `IO` action?
14:39:57 <clahey> Not IO the Monad, but actual file IO.
14:40:30 <clahey> Tekmo, The Gtk main loop launches it over and over again until either it returns False or some data comes in over IO.
14:40:42 <Tekmo> clahey: That's the definition of polling
14:41:13 <donri> WraithM: basically you could have class Test t w | t -> w, and then instance Test Int String, which says that the 'w' is always String if the 't' is Int
14:41:36 <Tekmo> clahey: So does the GTK main loop run anything else in between each invocation of the `IO` action?
14:41:56 <monochrom> you do not even know whether you need the t->w part
14:42:04 <clahey> Tekmo, It depends on whether there's any user input.
14:42:05 <monochrom> have you seen examples?
14:42:26 <Tekmo> clahey: So GTK polls for user input?
14:42:49 <WraithM> I've seen nothing of fundeps/multiparameter typeclasses/type familes. This is all new to me.
14:42:49 <donri> WraithM: or equivalently with type families, class Test t where type Log t; test :: Monoid (Log t) => ..., instance Test Int where type Log Int = String
14:43:17 <WraithM> ooooh, interesting
14:43:17 <Tekmo> What is the specific `IO` action you are trying to run?
14:43:26 <clahey> Tekmo, I would disagree about it being polling since each time the `IO` action runs it's not checking a value over and over again, it's doing more and more computation.
14:44:08 <donri> WraithM: basically type families are functions on the type level and functional dependencies let you express that certain parameters in a [multi-parameter] type class depend on each other
14:44:18 <Tekmo> clahey: Do both the `IO` action and the on/off switch live in separate GTK callbacks?
14:44:30 <clahey> Tekmo, Yep.
14:44:45 <Tekmo> clahey: So you want to ask how to coordinate them so that the `IO` action will not run if the on/off switch has toggled to off?
14:44:52 <clahey> Tekmo, We're having a semantic argument, right?  Or are we having a discussion of what the right way to implement them?
14:45:04 <clahey> Tekmo, I wasn't asking anything.
14:45:20 <Tekmo> clahey: Oh, I thought it was a question
14:45:27 <clahey> No, I was just discussing what the next step.
14:45:46 <clahey> The plan was to have an IOVar that contains the id of the gtk+ idle callback.
14:46:01 <xico> hi. what is the simple way to add a directory where to find modules in ghc api? (like -ixxx in ghc)
14:46:10 <clahey> Switching the off switch is just calling "gtk, cancel this callback" and then setting the id to 0.
14:46:34 <clahey> Switching the on switch is just setIOVar v =<< gtkStartFunction.
14:47:27 <clahey> Well, switching the on switch has to check if it's already running and then turn it on.
14:47:31 <clahey> The part I have to figure out is how to structure the data, not what the code should do.
14:48:03 <napping> what else is there to figure out?
14:48:10 <xico> (i guess setSessionDynFlags)
14:48:38 <monochrom> xico: setSessionDynFlags and in DynFlags the field importPaths
14:48:57 <clahey> napping, I just am still new to writing practical haskell, so figuring out the data structures is still taking some thought for me.
14:49:30 <clahey> I guess it's just data Runnable = Runnable {id :: Int, IO Bool :: computation}
14:50:01 <xico> monochrom: thanks
14:50:04 <napping> clahey: isn't IORef (Maybe <Id>) youre data structure?
14:50:34 <clahey> napping, Well, (IORef (Maybe <Id>), IO Bool)
14:50:54 <Tekmo> clahey: Why not just store the `IO Bool` action directly and just change it
14:50:57 <clahey> napping, I did forget about the IORef, and I don't know what the type of Id is in haskell, but in C it's an int that just gets set to 0.
14:51:02 <Peaker> Why are tupled constraints prefered over curried constraints?
14:51:07 <Tekmo> clahey: In other words, when you want to turn it off, just put a `return False` action in its place
14:51:32 <napping> Why do you need the pair like that?
14:51:49 <napping> Do you want to also keep a reference to the currently-installed action if there is one?
14:51:53 <clahey> napping, So I can do startRunnable runnable
14:52:14 <Peaker> "Foo a => Bar a =>" or: "(Foo a, Bar a) =>" ?
14:52:18 <napping> oh, you can have multiple actions installed?
14:52:30 <Tekmo> Peaker: You can curry constraints?
14:52:36 <ski> Peaker : probably hysterical raisins ?
14:52:48 <Peaker> Tekmo: yeah
14:52:54 <monochrom> tuple is more elementary than currying
14:53:03 <Peaker> monochrom: why?
14:53:33 <clahey> napping, I'm trying to build everything as reusable bits.
14:53:50 <tomejaguar> Can you actually write curried constraints?
14:53:55 <Peaker> monochrom: LC builds tuples from currying
14:54:05 <monochrom> AxB is a simpler space than whatever^A
14:54:14 <shachaf> tomejaguar: Not in Haskell 2010, but in GHC it's permitted.
14:54:21 <Tekmo> monochrom: What if I arbitrarily decide that functions are "simpler"
14:54:21 <ski> Peaker : though type systems usually have a primitive "structural connective" `,' on the left of `|-' ..
14:54:26 <Peaker> shachaf: does it need any extension enabled?
14:54:27 <shachaf> (Which is good, because it's the reasonable thing to do.)
14:54:36 <shachaf> Peaker: Not last time I checked.
14:54:41 <shachaf> (You might consider that a bug.)
14:55:49 <monochrom> "LC builds tuples from currying" --> this only states that currying is closer to a foundation
14:56:20 <clahey> monochrom, I would say that it's an ambiguous English sentence which could mean either thing.
14:57:10 <napping> monochrom: How is "more elementary" different from "closer to a foundation"?
14:57:28 <Tekmo> Nobody has defined what "simpler" means
14:57:32 <monochrom> by requiring less education
14:58:13 <napping> clahey: mixing up the fact that you have an IO action and that you might want to install it as an idle callback in a data structure doesn't sound like making things more reusable
14:58:14 <dmj`> @src seq
14:58:14 <lambdabot> Source not found. Are you on drugs?
14:58:30 <monochrom> in fact, so far, for all existing foundations and a promising future one, the sentence "closer to foundation => requires more education" seems to hold
14:58:30 <dmj`> lambdabot: yes
14:58:41 <ski> @index seq
14:58:42 <lambdabot> Prelude, Control.Parallel
14:59:11 <napping> I don't see that g_idle_add is guaranteed to return non-zero ids (or, indeed, say if they can be recycled if the function is unregistered by returning FALSE)
15:00:09 <Tekmo> clahey: How many times will you be reusing this idiom within your own project?
15:00:20 <clahey> Tekmo, Probably just the once right now.
15:00:52 <Tekmo> clahey: I think you had it right the first time
15:01:00 <Tekmo> clahey: Just store a callback ID in the data structure
15:01:11 <Tekmo> clahey: Then the on/off callback either enables or disables the other callback
15:01:46 <Tekmo> clahey: That seems to me like idiomatic GTK code
15:01:53 <napping> clahey: using http://hackage.haskell.org/packages/archive/glib/0.12.4/doc/html/System-Glib-MainLoop.html ?
15:02:10 <clahey> napping, Yeah.
15:02:59 <Peaker> monochrom: in a Haskell context, currying has to be learned very very early anyway
15:03:00 <clahey> Tekmo, It has to be an IORef Id since the "enable this callback" takes an IO Bool and returns the Id.
15:03:36 <Tekmo> clahey: Oh I see.  You need to reenable it again later on
15:03:42 <Tekmo> clahey: I thought it just temporarily disabled the callback
15:03:43 <tomejaguar> I guess tuples avoid needing higher order functions
15:03:48 <clahey> Tekmo, Yep.
15:03:56 <clahey> Tekmo, idleAdd and idleRemove.
15:03:57 <tomejaguar> that's probably a benefit.
15:04:00 <napping> As far as I can tell, that's re-add, not re-eanble
15:04:03 <ski> tomejaguar ?
15:04:21 <tomejaguar> (a, b) -> c is easier to understand than a -> b -> c I think.
15:04:31 <tomejaguar> Although I'm not sure because since learning Haskell I now understand everything.
15:04:39 <napping> clahey: that really should be IORef (Maybe HandleId)
15:05:03 <Tekmo> napping: clahey needs the `IO` action again so he can reinstantiate it later on
15:05:13 <Tekmo> napping: That's why he had that in his data structure
15:05:20 <napping> which IO action?
15:05:35 <Tekmo> napping: The one he passes to `idleAdd`
15:05:46 <Tekmo> napping: Once he calls `idleRemove` that callback is gone permanently
15:05:51 <clahey> napping, I wasn't sure since in C, it just uses 0 to mean that.
15:06:03 <Tekmo> napping: So if he wants to turn it back on again he needs to save the original `IO` action
15:06:17 <clahey> napping, But yeah, Maybe is definitely more haskelly.
15:06:22 <napping> I thought this was so far a one-off kind of thing, adding a fixed action?
15:07:15 <clahey> Well, in that case it would need to have a parameter to the fixed action, but that would be less reusable.
15:08:04 <Tekmo> clahey: What would a reusable interface look like to you?
15:08:14 <clahey> I could do data Runnable = Runnable (Maybe HandlerId) (IOArray ThingToBeProcessed)
15:08:56 <monochrom> to a large extent, speaking just for myself, in Haskell I agree to A->B->C only because (A,B)->C incurs an extra bit of inefficiency. provided I plan to fully apply anyway.
15:09:13 <clahey> But Runnable = Runnable (IORef (Maybe HandlerId)) (IO Bool)    and just pass in    (runCalculation thingToBeProcessed)  seems more reusable.
15:09:49 <napping> why are you processing IOArrays in an idle loop?
15:10:13 <monochrom> (therefore, for example, in SML, where binary operators are like int*int -> int, I do not miss currying a tiny bit)
15:10:22 <Tekmo> napping: Because clahey makes work for idle hands
15:10:43 <clahey> Tekmo, I should just code it and put it on lpaste, but I'm concentrating on other stuff.
15:10:58 <napping> that sounds like the sort of background processing it would be easier to put in threads
15:11:14 <clahey> napping, I could do that.
15:11:41 <ski> (though `map' is curried in SML ..)
15:12:07 <clahey> napping, So, the reason not to is that it's better to call all your Gtk related functions in the same thread, and the calculation calls some Gtk related functions.
15:12:10 <monochrom> yes, if I anticipate partial application like "map (map f) . join", I am fine with currying
15:12:35 <monochrom> I am saying currying needs not be prevalent
15:12:37 <napping> yeah, that needs to run on the thread
15:12:46 * ski agrees
15:13:05 <clahey> napping, I was originally planning to write a result of the calculation to a pixel on the screen.
15:13:11 <Tekmo> monochrom: The problem with not doing currying by default is that you have to spend more time thinking about when to curry and not to curry
15:13:28 <Tekmo> monochrom: Currying by default requires significantly less cognitive overhead
15:13:29 <clahey> napping, Basically there's a state for each pixel and it also updates the color of that pixel.
15:13:50 <khyperia> Heh, just found out there's actually a guy named "Haskell Brooks Curry"... all three of his names are programming languages, plus the concept of currying.
15:13:54 <monochrom> the problem with currying by default is that you have to spend more time deciding on parameter order.
15:14:01 <jophish_> Yo yo yo
15:14:19 <clahey> monochrom, Only if you care about partial application.
15:14:19 <jophish_> Is there a function f in the prelude such that f g = g . g?
15:14:21 <napping> "have to"?
15:14:23 <Tekmo> monochrom: No you don't.  The worst case scenario is you ignore parameter order and you still do no worse than tupling everything
15:14:31 <monochrom> ok fine
15:14:31 <luite> khyperia: what a wonderful coincidence eh ;)
15:14:38 <napping> currying should anwyays be an isomorphism
15:14:53 <clahey> napping, I'm currently switching to updating a Pixbuf and writing that to the screen every so often.  However, I think I still want the calculation to mark parts of the screen as needing to be redrawn.
15:15:26 <jophish_> foldl1 (.) (take i $ repeat g)
15:15:29 <ski> khyperia : yeah :) (though currying proably ought to be called schönfinkelizing or something similar)
15:15:50 <clahey> napping, I could have a cross thread queue (I can't remember the word used in haskell for this) of screen regions to invalidate.
15:15:57 <khyperia> heh, wikipedia page on currying says "Because of this, some say it would be more correct to name it schnfinkeling"
15:16:09 <jophish_> @pl f g = g . g
15:16:09 <lambdabot> f = join (.)
15:16:44 <khyperia> is there a list of @ commands somewhere for lambdabot that I could look at?
15:16:49 <khyperia> and what they do?
15:16:53 <ski> i recall reading an ML guy who thought that currying should generally be used only when the function does some non-trivial work before accepting the next argument
15:17:02 <clahey> ski, khyperia: I especially love that that's an example of Stigler's law of eponymy, which of course wasn't discovered by Stigler.
15:17:10 <wojtekM_> Attoparsec. How do I access the already parsed things?
15:17:21 <clahey> ski, Ugh, I so disagree.
15:17:41 <Clint> wojtekM_: you need a stateful parser, you mean?
15:17:44 <clahey> Anyway, time for me to go.  Talk to you all soon.
15:18:47 <tomejaguar> ski: In Haskell that's basically irrelevant due to laziness.
15:19:11 <ski> cl_away : even if i disagree, it's still an interesting viewpoint
15:19:11 <ski> tomejaguar : nope
15:19:14 <tomejaguar> No?
15:19:38 <tomejaguar> Oh
15:19:39 <ski> you can have also in Haskell functions which "does some non-trivial work before accepting the next argument"
15:19:52 <tomejaguar> there may be thunks in the body which become evaluated
15:20:19 <tomejaguar> Well it only does it when the function call is forced
15:20:23 <khyperia> Jargon clarification question: "Thunk" means "evaluating the lazy value"?
15:20:32 <tomejaguar> which it can't be unless its fully applied (ignoring seq)
15:20:57 <tomejaguar> khyperia: thunk is basically a store for a possibly-as-yet-unevaluated value
15:21:08 <khyperia> ah
15:21:31 <tomejaguar> When you say let x = f y a thunk for x will be created
15:21:34 <ski> the difference is that with laziness, that work will only be invoked (the first time) when the next argument is given (modulo `seq'), as opposed to in an eager language, where that work would be done regardless of whether the computed function value was later used (i.e. applied) or not
15:21:39 <tomejaguar> when that thunk is fored f y will be evaluated
15:22:00 <tomejaguar> ski: right yes
15:22:19 <tomejaguar> let g = f x in (g y, g y') possibly does less work than (f x y, f x y')
15:22:35 <khyperia> yeah, I understand lazy stuff, but just questioning what "thunk" meant... I get it now, thanks.
15:23:12 <ski> e.g. you could imagine a function taking as first argument a description of a regular expression, and then "compiles" it into a function that when given a string, is optimized to match the string to the specific regular expression previously given
15:23:15 <khyperia> or, uh, "non-strict" is another term for it, right?
15:23:34 <ski> khyperia : "non-strict" is wider than "lazy"
15:23:40 <tomejaguar> khyperia: lazy is a particular implementation of non-strict
15:23:44 <khyperia> ah
15:23:50 <tomejaguar> but as we discovered earlier today, no one knows what non-strict means
15:24:40 <spaceships> please describe an evaluation style that is non-strict but not lazy
15:24:48 <tomejaguar> speculative evaluation
15:25:00 <khyperia> Another question that I saw being debated a bit back, and I understood nothing: What are the *basics* of _|_ ? Like, what the heck *is* it?
15:25:05 <napping> and call-by-name
15:25:23 <tomejaguar> where function call tries to evaluate its argument strictly but if it doesn't reach a value it stops and returns
15:25:37 <spaceships> cool, thanks
15:25:39 <tomejaguar> napping: that is a better example!
15:25:46 <napping> so how do you say people don't know what non-strict means?
15:25:56 <tomejaguar> i asked this morning on this channel
15:26:01 <tomejaguar> we couldn't come up with an actual definition
15:26:15 <monochrom> "thunk" means expression. in this context.
15:26:27 <alpha123> tomejaguar: Are there any languages like that? Also from any standpoint other than the implementation, is that any different from lazy?
15:26:35 <monochrom> expression : thunk :: bits :: electric signals
15:26:52 <tomejaguar> alpha123: denotationally it's the same.  operationally (i.e. from the implemenation standpoint) it is different, as you say
15:26:55 <napping> monochrom: how do you think expressions capture lazy evaluation?
15:27:13 <ski> khyperia : `_|_' is a sign we use to denote the "value" of a non-terminating computation
15:27:48 <khyperia> ah
15:27:51 <Ghoul_> it's also a subtle middle finger
15:27:53 <ski> khyperia : using it, we can distinguish between `2 : _|_' and `2 : _|_ : []', e.g.
15:28:50 <monochrom> napping: answer: http://www.vex.net/~trebla/haskell/lazy.xhtml
15:28:54 <khyperia> is there an origin to the symbol, or did someone just say "hey, underscore pipe underscore is a nice collection of symbols"?
15:28:57 <ski> (the former being a list whose head element is `2', and the rest of the list computation fails to terminate; while the latter is a list with two elements, the head being `2', the next being a non-terminating computation)
15:30:13 <ski> khyperia : also see monochrom's link for elaboration
15:31:28 <napping> monochrom: graph reduction isn't just "expression"
15:31:42 <monochrom> to be non-strict but not lazy: be crazy. to evaluation "const joy sad", evaluate all of "const", "joy", "sad" in parallel. be prepared to abort the "sad" branch when the other two branches finish.
15:32:14 <spaceships> monochrom: lovely
15:33:51 <Ghoul_> paralell laziness sounds interesting
15:34:51 <alpha123> tomejaguar: Cool. Thanks, just curious.
15:35:21 <xenocons> :t groupBy
15:35:21 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
15:36:32 <monochrom> napping: ok, "expression" alone doesn't capture lazy. it doesn't capture any evaluation order. what I do to the expression, that captures evaluation order. but it suffices to describe evaluation order at the expression level, by stating what I do to the expression. I don't have to go down one more level, the thunk level, which begins talking about mutable pointer cells and bits and blocks of memory
15:37:20 <napping> but you do have to go beyond the expression level, and there's no need to go down to bits to talk about mutable thunks
15:37:35 <napping> I think "thunk" is a perfectly reasonable term when you start bringing up those complexities
15:38:32 <monochrom> if you give me this expression, "(\x y -> x) (1+2) (3+4)", I can already say, "deal with 1+2 first", or I can already say, "deal with substitution first". that already tells you my evaluation order. where is thunk in this?
15:39:33 <monochrom> seriously have you finished reading my article? it shows no need for thunks.
15:39:42 <napping> In replacing 1+2 or 3+4 with the results of evaluation
15:40:01 <levi> I think the term you want instead of thunk is redex, if you want to avoid implementation details.
15:40:06 <monochrom> that still requires no thunk
15:41:05 <monochrom> it's a term rewriting system. (\x y -> x) (1+2) (3+4) --> (\x y -> x) (3) (3+4).
15:41:38 <Ghoul_> has anyone  ever done work into simulating laziness without thunks
15:41:39 <S_J> how important is uniformity 9in quickcheck? like just using something like rand() % 100 in C code. that breaks uniformity a little but maybe it is ok still?
15:41:44 <Ghoul_> like, compile time analysis?
15:41:45 <monochrom> if you want me to s/expression/term/, I can do that
15:42:10 <Ghoul_> I would be interested if there was a paper on such things or similar
15:43:12 <ski> S_J : can be important
15:43:43 <khyperia> I'm starting to learn monads and IO and such, and can someone tell me if this is sane code (as in doing it 'right')? main = getLine >>= return.(read::String->Float) >>= return.cos >>= print
15:44:40 <blackdog> khyperia: you might as well combine the read and the cos
15:44:48 <wojtekM_> Clint: I'm trying to parse java serialization. In the same stream, there are class definitions, and objects. To parse object data I need to access its class definition.
15:44:57 <khyperia> yeah, by doing "return.cos.read", right?
15:45:09 <ski> S_J : e.g. if you want to check that, for any two given lists, if they are sorted then their merging is also sorted, then the check for whether the input lists are sorted may bias your distribution so that most of the lists you test are either the empty list or singleton lists
15:45:19 <blackdog> the purpose of separating IO and pure code is so that you can have your "computational engine" non-IO-y.
15:45:34 <khyperia> but in general, is that averagely alright for how a monad thingy might work?
15:46:04 <blackdog> khyperia: it's not so bad. sometimes using do notation makes it more readable, but i think it's ok
15:46:17 <khyperia> alright
15:46:55 <ski> khyperia : would be better as `main = print . cos . (read :: String -> Float) =<< getLine'
15:47:15 <khyperia> what is "=<<"?
15:47:21 <ski> @src =<<
15:47:28 <ski>   f =<< ma = ma >>= f
15:47:34 <lambdabot> f =<< x = x >>= f
15:47:38 <khyperia> oh, neat
15:47:43 <ski> @botsnack
15:47:43 <lambdabot> :)
15:48:42 <ski> khyperia : generally, in `return (...) >>= ...' or `... >>= return . (...) >>= ...' it is better to rewrite to avoid the `return'
15:48:54 <Taslem> もしもし
15:49:31 <spaceships> moshi moshi but i forget what it means
15:49:39 <ski> e.g. instead of `do x <- return (...); ..x..' consider `do let {x = ...}; ..x..'
15:49:53 <monochrom> if you worrying about sharing, I can do that too. in my article, since you have a graphical web browser, I use a graphical notation. but if you want textual, that's just let-in
15:50:13 <ski> (spaceships : some kind of greeting, i vaguely seem to recall)
15:50:35 <monochrom> (\x y -> x*x) (1+2) (3+4) --> let x=1+2 in x*x --> let x=3 in x*x --> 9
15:51:16 <flazz> how does join (+) the same as (\x -> x + x)?
15:51:35 <ski> by `Monad ((->) rho)'
15:51:45 <monochrom> see also Launchbury's "a natural semantics for lazy evaluation". still no thunks, just a lot of let's. http://www.cse.ogi.edu/~jl/Papers/lazySem.ps
15:51:54 <ski> @src (->) return
15:51:55 <lambdabot> return = const
15:51:55 <ski> @src (->) (>>=)
15:51:55 <lambdabot> f >>= k = \ r -> k (f r) r
15:52:48 <monochrom> or rather, just a lot of bindings
15:53:37 <ski> flazz : `join :: forall a. m (m a) -> m a', if `m' is a `Monad'. so in case `m' is `(->) rho' we get `join :: (->) rho ((->) rho a) -> (->) rho a', iow `join :: (rho -> (rho -> a)) -> (rho -> a)'
15:53:56 <spaceships> g
15:54:20 * spaceships coughs
15:54:30 <flazz> rho is the domain?
15:54:39 <ski> yes, the "environment"
15:58:08 <jophish_> yo yo yo
15:59:31 <jophish_> If I were to write a compiler for a language with a syntax very similar to Haskell, are there any good starting places for a parser (The compiler will be written in Haskell)? Are there any existing Haskell parsers to which I could add a few extra keywords/AST nodes and remove some functionality?
16:00:46 <levi> Well, there's haskell_src_exts.  I'm not sure how easy it is to extend.
16:00:53 <Nisstyre> jophish_: there are probably some programs that can parse Haskell using parsec
16:00:59 <Nisstyre> those would be easy to extend
16:01:09 <jophish_> levi: yeah, it didn't look that trivial
16:01:20 <jophish_> Nisstyre: searching for a parsec haskell parser is quite tricky :)
16:01:21 <levi> I understand UHC is a very extensible compiler.
16:01:47 <Nisstyre> jophish_: you could write your own (maybe not trivial if you've never used parsec before and don't have much experience writing parsers)
16:01:48 <levi> It's built on the uu_parsing combinators and attributes grammars.
16:02:27 <Nisstyre> jophish_: parsing is really not the most important part of a language implementation anyway
16:02:31 <jophish_> Nisstyre: I don't think it would be that challenging, but it would be repeating a lot of work done before
16:02:32 <Nisstyre> so I'd focus on the other parts now
16:02:39 <Nisstyre> and then figure out a parser later
16:02:53 <jophish_> Nisstyre: It's tricky to implement the other parts without an AST
16:03:04 <Nisstyre> jophish_: you can have an AST without a parser
16:03:06 <levi> You don't need a real parser to build an AST.
16:03:28 <S11001001> @info (|||)
16:03:28 <lambdabot> (|||)
16:03:47 <ski> there is no lambdabot `info' command
16:03:48 <khyperia> That looks like a sideways hamburger.
16:04:22 <jophish_> I suppose, manually specifying an sat would be a pain
16:04:30 <jophish_> I could get it from a syntax other than haskell
16:05:14 <Nisstyre> jophish_: well, it might be annoying to manually test it, but you can implement everything without a parser just fine
16:06:28 <khyperia> Most annoying bit of making a compiler: Transforming stack-based IL and/or expression trees into register-based IL.
16:08:36 <jophish_> I'm using llvm as a backend. The transformation from AST shouldn't be that hard. I've done it some times before
16:09:42 <Nisstyre> jophish_: not to be overly critical or anything, but what's special about your language?
16:12:10 <jophish_> Nisstyre: a new keyword 'domain' used in place of 'type' which enables some extra functionality for the types, syntax @identifier to turn identifier into a special string for the compiler
16:12:16 <jophish_> It's really nothing major, at the oment
16:12:18 <jophish_> moment*
16:12:49 <jophish_> The compiled language won't have runtime currying or higher order functions
16:12:57 <jophish_> they must be resolvable at compile time
16:13:34 <bennofs> A haskell program: segmentation fault (core dumped) :O
16:13:37 <joelteon> so GHC actually takes awhile to build
16:18:00 <bennofs> The PolyKinds extension is so broken in GHC 7.4 :(
16:18:20 <flazz> ski: i think my mind is blowing, i have to check the source now
16:18:37 <Nisstyre> bennofs: why aren't you using 7.6?
16:18:51 <bennofs> Nisstyre: I am, but travis-ci isn't :(
16:18:57 <Nisstyre> ah ok
16:19:46 <bennofs> I got it to compile, but now the test cases fail with a segmentation fault on 7.4 (they run fine on 7.6)
16:19:48 <Nisstyre> bennofs: have you found any good uses for PolyKinds and DataKinds?
16:19:58 <Nisstyre> I thought about using them to make a type level AST
16:20:53 <bennofs> Nisstyre: PolyKinds is usefull with proxy, it lets me for example write:  testInstances (Proxy :: Proxy MyFavoriteFunctorType) [functor, applicative, monad] (in QuickCheck)
16:21:12 <Nisstyre> oh, neat
16:21:58 <bennofs> Wow, I have an even better error message than a GHC panic: Who can beat "internal error: PAP object entered" (at runtime)
16:22:09 <elliott> @quote ghc brain
16:22:10 <lambdabot> ghc says: My brain just exploded.
16:22:39 <joelteon> @quote ghc
16:22:39 <lambdabot> ghc says: absApply: Duff function
16:22:42 <joelteon> what
16:23:25 <ski> flazz : start by `join mma = mma >>= id', and unfold that by the above definition of `(>>=)', what do you get ?
16:26:00 <bennofs> Wasn't there somebody working on getting GHC 7.6 on travis-ci?
16:34:21 <wojtekM_> Looks like I can not have state in Attoparsec, is that right?
16:34:41 <wojtekM_> For stateful parsing I need monad transformer?
16:37:27 <janua> Hello. I have a boolean, and am inside a monad, how would I do something if this bool is True, and nothing if it is false. What i am having a problem with is that I can do this, but I want to only do something if its True, and then always do the last step of the do block, if that makes sense
16:38:14 <S11001001> janua: b <- whoops got a m Bool
16:38:31 <S11001001> next line: if b then (do a m () thing) else return ()
16:38:38 <S11001001> next line the last step or whatever
16:38:58 <janua> Oh, else return ()
16:39:21 <janua> That's what I was looking for, thanks S11001001! Hmmm, haven't i seen you before? :P
16:39:24 <Clint> :t when
16:39:25 <lambdabot> Monad m => Bool -> m () -> m ()
16:39:34 <janua> I think i would prefer to use that, when
16:39:39 <janua> That looks like what I was looking for
16:40:07 <S11001001> yeah that is better
16:41:17 <janua> S11001001: Although I liked you answer a lot as I can see whats happening with the return ()
16:42:12 <S11001001> eh, derived combinators rock
16:44:10 <mm_freak> the name "return" is a bit misleading
16:44:24 <mm_freak> reading it as "theActionThatReturns" may help
16:45:07 <monochrom> there was a recent long thread on haskell-cafe on exactly "what would you call it, given a chance?"
16:45:50 <mm_freak> "pure" is fine…  a computation without effects can really only do that:  return a result
16:46:13 <monochrom> it quickly deviated from that question
16:46:55 <mm_freak> i suppose "return" is also fine, but it constantly misleads people who are used to it meaning to exit a function
16:47:40 <monochrom> oh! part of that thread was arguing whether e.g. getLine :: IO String is pure
16:48:26 <mm_freak> well, it is pure, but denotes something with side effects =)
16:49:22 <monochrom> yes, the debate was exactly cutting that sentence into two halves
16:49:41 <mm_freak> i think the only potentially impure constructs in haskell start with "unsafe" or "foreign"
16:57:32 <MrRacoon>  /win 7
16:58:40 <monochrom> /win 8
17:00:22 <flazz> ski: makes sense! is bind on (-> r) once inhabited (while obeying the monad laws)?
17:01:27 <ski> "once inhabited" meaning ?
17:01:41 <acowley> Dear hvr and supki: You guys rock. I have new haskell-mode with cabal repl support and ghc-mod support for sandboxes up and running.
17:02:13 <monochrom> you are the luckiest programmer in the world :)
17:02:41 <acowley> Me?
17:02:51 <monochrom> yes
17:03:16 <blackdog> acowley: how is it?
17:03:24 <acowley> A-mazing
17:03:38 <acowley> I have a sandboxed environment for doing some Arduino things I may demo next week
17:03:40 <blackdog> what does the new haskell mode offer?
17:03:50 <acowley> so being able to verify the code using SBV within emacs is awesome
17:04:03 <blackdog> i've started making choices about things like doctest based entirely on ghc-mod not being able to see inside the doctest comments :)
17:04:15 <acowley> I also have compatibility with GLFW-b reinstalled so I can do graphics things from interactive-mode
17:04:26 <acowley> blackdog: The main thing I wanted is support for cabal repl
17:04:43 <watermind> mm_freak: depends how pedantic you want to be about the definition of pure
17:04:55 <acowley> Yeah, cabal sandboxes are fantastic, but ghc-mod not supporting them was pretty much a deal breaker
17:05:05 <acowley> the only use for sandboxes without ghc-mod support is installing other people's stuff
17:05:11 <acowley> s/installing/building
17:05:48 <acowley> But with that minor tweak to ghc-mod from supki, ghc-mod is happy with cabal sandboxes. And thanks to hvr, haskell-interactive-mode can use cabal repl…. so everybody wins!
17:05:52 <watermind> mm_freak: many functions throw exceptions... semantically their supposed to be _|_, but truthfully they do cause an effect (raising an exception), one which can access ed in IO
17:06:01 <watermind> they're*
17:06:33 <bennofs> Does anybody know what's the status of GHC 7.6 on travis-ci?
17:06:57 <acowley> bennofs: I think the issue for that on github is still stalled?
17:07:23 <acowley> bennofs: https://github.com/travis-ci/travis-ci/issues/882
17:15:53 <acowley> Downside: I am going to fill up my HDD with sandboxes
17:25:48 <Zenol> ok, UTF8 stuff is hell
17:26:04 <joelteon> yes
17:26:05 <joelteon> quite
17:26:08 <monochrom> no
17:26:47 <Zenol> I have an UTF8 input, I wan't an ISO-5589-1 output. Any way I try to do it, half of the characters are wrong.
17:27:03 <edwardk> Zenol: heh. at least you don't have to recognize it both forward _and_ backwards. ;) http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/src/Data-Monoid-Lexical-UTF8-Decoder.html#UTF8
17:27:37 <monochrom> that means ISO-5589-1 is the hell
17:28:13 <monochrom> this is why I distrust other people's blame assignment
17:28:25 <arkeet> Zenol: what do you do with characters that aren't in iso-8859-1? (I assume you meant 8859)
17:28:33 <Zenol> By "utf8" stuff I mean the existence of lot's of different encoding.
17:28:43 <arkeet> utf8 is a specific encoding.
17:28:56 <arkeet> that can encode any unicode character.
17:29:11 <monochrom> you've got to learn to say what you mean
17:29:15 <arkeet> most of those can't be encoded in iso8859-1
17:29:42 <Zenol> arkeet: I know, but non of them will appear.
17:29:52 <Zenol> the m
17:30:15 <Zenol> the … has an iso8859-1 encoding?
17:30:21 <monochrom> anyway, this is why I distrust other people's wording, too
17:30:34 <monochrom> no
17:30:52 <Zenol> U+0085 … &#133; Next Line from http://en.wikipedia.org/wiki/List_of_Unicode_characters
17:30:58 <arkeet> this is a haskell question, right?
17:31:16 <Zenol> arr, not, but this one is a haskell question
17:31:37 <Zenol> What happen when I write putStrLn instead of ByteString.putStrLn . B.pack ?
17:31:42 * arkeet is progressively more confused
17:32:27 <monochrom> … is U+2026. U+0085 is a control character called "next line".
17:33:17 <Zenol> monochrom: Ok, so the wiki is broken, or firefox is broken. I searched for ... :/
17:34:22 <arkeet> Zenol: ByteString doesn't know anything about unicode. it's just a bunch of bytes.
17:34:31 <arkeet> and I'm pretty sure those things have different types.
17:34:50 <Zenol> :t putStrLn
17:34:51 <lambdabot> String -> IO ()
17:34:58 <monochrom> B.pack converts U+2026 to 0x26
17:35:06 <Zenol> :t Data.ByteString.putStrLn . Data.ByteString.pack
17:35:07 <lambdabot> [Word8] -> IO ()
17:35:16 <arkeet> String and [Word8] are pretty different.
17:35:18 <Zenol> :t Data.ByteString.putStrLn . Data.ByteString.Char8.pack
17:35:19 <lambdabot> String -> IO ()
17:35:29 <arkeet> don't use Char8.
17:35:54 <monochrom> > Data.ByteString.Char.8.pack "\x2026"
17:36:24 <monochrom> I killed lambdabot
17:36:30 <Zenol>  Data.ByteString.Char8.pack "\x2026"
17:36:35 <arkeet> monochrom: you wrote Char.8
17:36:43 <monochrom> > Data.ByteString.Char8.pack "\x2026"
17:36:56 <lambdabot>   Not in scope: data constructor `Data.ByteString.Char'Not in scope: `pack'
17:36:57 <lambdabot>  ...
17:36:57 <monochrom> I killed lambdabot again
17:36:57 <lambdabot>   Not in scope: `Data.ByteString.Char8.pack'
17:37:05 <arkeet> it was dead to begin with
17:37:54 <arkeet> anyway, it's only by luck that unicode coincides with iso 8859-1 in the first 256 code points.
17:38:03 <Zenol> oho, this is this "&" a saw before.
17:38:29 <arkeet> and … isn't one of those.
17:39:22 <Zenol> luck or because 8859-1 was a widely used 8bits encoding? :p
17:39:30 <dpwright> Is there a way to pattern match on a list type without using cons?  I currently have: f (x:xs) = foldl' g "" (x:xs), but I'd rather something like: f (List l) = foldl' g "" l
17:39:31 <Zenol> but ok, so maybe what I tried was working.
17:39:44 <arkeet> dpwright: f l = ...
17:39:53 <dpwright> it might not be a list though
17:39:58 <arkeet> the type will tell you it's a list.
17:40:22 <arkeet> foldl' only accepts a list, so nothing else will typecheck.l
17:40:49 <Zenol> hum. Maybe I should explain what I'm trying to do instead. I need to output ISO-8859-1 XML, and I use Data.XML.Light to build the XML tree.
17:40:50 <arkeet> the wonders of static typing.
17:41:11 <arkeet> you mean Text.XML.Light?
17:41:20 <Zenol> Arg, Text, yes.
17:41:45 <arkeet> so it outputs a string.
17:41:45 <dpwright> ...ah yes, being silly -- there was a type that could either hold a value or a list, but of course you can tell them apart by their type constructors
17:41:47 <arkeet> a String.
17:41:55 <dpwright> thanks arkeet
17:42:28 * monochrom decides not to pursue
17:42:34 <Zenol> yes. I don't really understand what should be in to input string and what is at the output. They said they are working with utf8 if I recall.
17:42:49 <arkeet> a String holds a list of unicode characters.
17:43:07 <Zenol> If I putStrLn <=< myStuff <=< getContents everything is fine with utf8 everywhere.
17:43:09 <arkeet> (utf-8 is not unicode.)
17:43:27 <arkeet> putStrLn outputs utf-8.
17:43:28 <monochrom> which package is Text.XML.Light?
17:43:31 <arkeet> xml
17:43:54 <Zenol> oh, so I need something from unicod to ISO-8859-1 ?
17:44:10 <wewela> Hello, I forgot the means of ! in the statement "data Point = Point !Double !Double",  could you help me please, thanks.
17:44:17 <arkeet> you need to encode it as iso-8859-1, yes.
17:44:25 <arkeet> wewela: strict fields.
17:44:42 <arkeet> or rather, it makes the constructor strict in those arguments.
17:44:51 <monochrom> if you intend to output ISO-8859-1, in fact ByteString.Char8 suffices
17:44:52 <wewela> thank you so much ,arkeet.
17:45:08 <arkeet> monochrom: well, that is true. but it is also awful.
17:45:46 <monochrom> at the onset, the decision to entertain any iso-8859-1 user is already awful
17:45:58 <arkeet> true.
17:46:09 <Zenol> arkeet: I tried stuff with converter <- ICU.open "ISO-8859-1" Nothing from Data.Text.ICU but it wasn't fantastic.
17:47:03 <Zenol> Hum, or it was because ... haven't a ISO-8859-1 code.
17:47:28 <monochrom> when faced with awful users, my only two sane choices are: tell them to go home, or satisfy them by the cheapest way and move on
17:47:39 <arkeet> fair enough.
17:48:41 <Zenol> monochrom: Like Char8.putStrLn . Char8.pack?
17:48:57 <monochrom> System.IO can also output iso-8859-1 if you first hSetEncoding
17:49:25 <Zenol> I realy would like to produce UTF-8 XML. But the xml is processed by ugly perl scripts that do not support utf8.
17:49:29 <arkeet> why do you want iso-8859-1?
17:50:03 <arkeet> then put iconv in front of the perl scripts.
17:50:11 <monochrom> hehe
17:50:51 <Zenol> hum, the xml header is iso-8859-1 :/
17:50:57 <arkeet> hSetEncoding latin1  would be better than Char8, I think.
17:51:06 <arkeet> at least it'll error if you try to pass it an invalid character.
17:51:31 <Zenol> arkeet: I would like the character to be skiped :p
17:51:32 <monochrom> you can easily do some tests, no?  (Char8.putStrLn . Char8.pack) "\x00a9 \x00b1 \x00d6" etc etc
17:51:41 <arkeet> Zenol: then Char8 isn't for you.
17:53:13 <Zenol> What would be better is replacing any non latin1 character by it's XML encoding, but I don't really know how to check if the character is in a String.
17:53:30 <monochrom> use filter (> '\255') to skip
17:53:35 <Fuuzetsu> > :t let f :: Num a => a => a => a; f = (+) in f
17:53:36 <lambdabot>   <hint>:1:1: parse error on input `:'
17:53:48 <Fuuzetsu> :t let f :: Num a => a => a => a; f = (+) in f
17:53:49 <lambdabot> Num a => a -> a -> a
17:53:52 <Fuuzetsu> why is this allowed?
17:53:59 <arkeet> because ghc is silly.
17:54:01 <Fuuzetsu> According to the report, this syntax should not even be legal
17:54:35 <arkeet> Zenol: you could go through the string and escape anything abouve 0x7f
17:55:17 <S11001001> Fuuzetsu: that is wonderful.
17:55:58 <arkeet> let f c = if c < '\x007f' then c else "&#" ++ show (ord c) ++ ";" in f =<< "abcあ"
17:56:06 <arkeet> > let f c = if c < '\x007f' then c else "&#" ++ show (ord c) ++ ";" in f =<< "abcあ"
17:56:07 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:56:07 <lambdabot>              with actual type...
17:56:08 <Fuuzetsu> S11001001: discovered by mistake apparently
17:56:14 <arkeet> > let f c = if c < '\x007f' then [c] else "&#" ++ show (ord c) ++ ";" in f =<< "abcあ"
17:56:15 <lambdabot>   "abc&#12354;"
17:56:16 <S11001001> > @ty fmap :: Functor f => (a => b) => f a => f b
17:56:17 <lambdabot>   <hint>:1:1: parse error on input `@'
17:56:18 <S11001001> @ty fmap :: Functor f => (a => b) => f a => f b
17:56:19 <lambdabot>     Illegal constraint: a (Use -XConstraintKinds to permit this)
17:56:19 <lambdabot>     In an expression type signature: Functor f => a => b => f a => f b
17:56:19 <lambdabot>     In the expression: fmap :: Functor f => a => b => f a => f b
17:56:27 <S11001001> guess the parens break the chain
17:56:50 <Zenol> arkeet: :o
17:57:09 <arkeet> hm, that < should be <=
17:57:16 <Fuuzetsu> oh okay, fixed in HEAD http://ghc.haskell.org/trac/ghc/ticket/7697
17:57:20 <S11001001> @ty (+) :: Num a => a => a => a
17:57:21 <lambdabot> Num a => a -> a -> a
17:57:22 <monochrom> I wonder who is &#12345; :)
17:57:27 <arkeet> > chr 12345
17:57:28 <lambdabot>   '\12345'
17:57:33 <arkeet> > text (chr 12345)
17:57:34 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
17:57:35 <lambdabot>  Expected type...
17:57:36 <arkeet> > text [chr 12345]
17:57:36 <lambdabot>   〹
17:57:46 <arkeet> I see a box. =(
17:57:53 <arkeet> > text [chr 12354]
17:57:54 <lambdabot>   あ
17:59:13 <monochrom> it is Chinese. you probably don't have a Chinese font
17:59:47 <monochrom> ah, but I can show you
18:00:26 <Zenol> Oh, so we all i'm not the only one to have only a Japanese font ? x)
18:02:06 <monochrom> arkeet: http://www.vex.net/~trebla/tmp/12345.png
18:02:31 <arkeet> that's chinese?
18:02:40 <monochrom> also, admire my ⊔ for "join" and ¬  for "leave" :)
18:02:51 <arkeet> heh
18:03:16 <arkeet> ah yeah, it's in cjk symbols and punctuation.
18:03:21 <monochrom> not shown, but nick changes are α
18:03:25 <arkeet> haha
18:05:37 <jmcarthur_mobile> Wow, my phone, of all things, is getting these unicode symbols right
18:06:53 <monochrom> precisely because the phone doesn't let you choose your fonts
18:07:10 <arkeet> my phone shows chinese variants of cjk characters in japanese text. =(
18:07:32 <monochrom> well, a bit more than that, but it definitely starts from that
18:08:03 <jmcarthur_mobile> This client gives me a choice, actually. I guess it's just preinstalled stuff. I imagine I could add more if I wanted to though...
18:08:14 <arkeet> things like 誤 look entirely different.
18:08:22 <Zenol> arkeet: Thanks you very much. I used your function of the output, just before writing it on stdout. It's not fantastic for <[!CDATA[ but I can't easily introduce special character inside the XML tree (I have to create raw text block just around those characters, and I'm to lazy).
18:08:22 <arkeet> it would be unrecognizable if I didn't know.
18:09:05 <monochrom> well, my point is, on linux desktops for example, where you are so free to choose, you actually start subtracting, not adding
18:10:12 <danharaj> sclv: when is your adjunctions talk going to be online?
18:10:15 <monochrom> (well, in the surface you add. but in truth, you add one font you like, which happens to have poor coverage, and you disable all other fonts. that's the subtraction)
18:10:41 <monochrom> (whereas on a phone you don't disable, you probably can't)
18:11:28 <arkeet> you can't even mess with the fonts on android without rooting.
18:12:44 <Zenol> arkeet: Yes but android let take care of your phone if you want.
18:13:04 <Zenol> Some others won't let you do anything :(
18:14:14 <jmcarthur_mobile> I am under the impression that on android you just have to put fonts in the right location to pick them up. Only need to mess with the rom to delete preinstalled fonts
18:14:51 * Zenol just remembered it is the haskell channel.
18:14:58 <jmcarthur_mobile> As did i
18:21:01 <mm_freak> watermind: i prefer not to start a long and tiring debate about what "pure" means…  for me it means "referentially transparent", and that's a useful definition =)
18:23:09 <mm_freak> btw, i'd like some thoughts about this:  runX :: (Monad m) => (forall m'. (Monad m') => X m' a) -> m a
18:23:24 <mm_freak> as opposed to:  runX :: (Monad m) => X Identity a -> m a
18:23:45 <elliott> sounds pointlessly restrictive.
18:24:39 <mm_freak> well, it forces you not to look under the hood
18:24:43 <ski> the former is more expressive
18:24:56 <ski> (depending on `X', i suppose)
18:25:00 <elliott> that second runX signature seems pointless.
18:25:03 <elliott> unless you use fail
18:25:32 <mm_freak> it was a contrived example…  i'm using this in netwire 5
18:25:41 <ski> hm
18:26:02 <mm_freak> http://hub.darcs.net/ertes/netwire/browse/Control/Wire/Session.hs
18:26:16 <ski> i suppose the `forall m. Monad m => m a' feels a bit trivial as well
18:26:17 <mm_freak> where:  type WireP s e a b = forall m. (Monad m) => Wire s e m a b
18:26:32 <mm_freak> and the P stands for "pure"
18:27:25 <mm_freak> traditionally you would require m = Identity, but i require m to be polymorphic instead and just instantiate it as Identity in reactimate
18:28:01 <mm_freak> one implication is that you can't use runIdentity
18:28:27 <ski> requiring the argument to be polymorphic in `m' means that you can instantiate it to something else than `Identity' locally -- depending on the exact type of the argument, this may give more expressive power to the function
18:28:54 <mm_freak> yeah, that was the motivation
18:29:09 <mm_freak> so i guess it was a good idea
18:30:39 <ski> i used rank-2 polymorphism in "PoorManDebug" <http://lpaste.net/10060> for such an effect
18:30:41 <elliott> mm_freak: that WireP is bad.
18:30:57 <elliott> mm_freak: edwardk explained why for a similar type recently
18:31:08 <elliott> it's only right in positive position, not negative
18:31:15 <elliott> and you can't do
18:31:17 <elliott> [WireP s e a b]
18:31:22 <elliott> or even Maybe (WireP s e a b)
18:32:07 <ski> elaborate on "only right in positive position" ?
18:32:33 <mm_freak> elliott: hmm, good point
18:33:06 * tabemann peeks
18:33:07 <tabemann> in
18:33:14 <mm_freak> newtype Wire s e c a b = Wire (forall m. (Monad m, c m) => … )
18:33:19 * ski pokes
18:33:20 <mm_freak> perhaps that's the answer =)
18:33:21 <ski> out
18:33:26 * mm_freak pukes
18:33:35 <tabemann> about "referentially transparent", that can invite debate in itself... i.e. does that mean at *runtime* or at *compile-time*?
18:33:47 <joelteon> newtype Wire p u k e s = Wire ...
18:34:01 <elliott> mm_freak: you could just use Identity. :p
18:34:17 <ski> tabemann : "referentially transparent" is about the reference of sub-expressions within contexts
18:34:31 <mm_freak> elliott: or i could just dispense with the type alias
18:34:53 <ski> mm_freak : how is `m' used in `Wire s e m a b' ?
18:34:59 <mm_freak> it's meant as a convenience
18:35:26 <mm_freak> ski: it's not used by netwire itself and intended for framework developers who may send event information via a Reader or construct a GUI via a Writer
18:35:45 <tabemann> ski: and the compile-time part is that for something to be RT that should apply statically to code independent of its actual execution
18:36:07 <ski> mm_freak : well, i was thinking more along lines of : is it used positively only ? negatively only ? both ? -- that kind of stuff
18:36:37 <mm_freak> what does that even mean?
18:36:42 <tabemann> i.e. if an expression could ever evaluate differently in different executions of a program with the same arguments, it is not RT, even if in a single execution of the program the same arguments will result in the same return value
18:36:55 <mm_freak> it's used corecursively, if you will
18:36:55 <ski> in `m A -> m B', `m' is used both positively and negatively
18:37:05 <mm_freak> ski: the type is (simplified):  newtype Wire m a b = Wire { stepWire :: a -> m (Maybe b, Wire m a b) }
18:37:26 <ski> ok, so positively (afaiu)
18:37:50 <tabemann> (with results like, e.g. code using Int isn't RT because it can't rely on the size of RT)
18:38:10 <tabemann> s/size of RT/size of Int
18:38:23 <ski> mm_freak : then your `forall m. Monad m => Wire s e m a b' might be equivalent to `Wire s e Identity a b'
18:38:36 * ski ponders
18:38:43 <mm_freak> ski: it's definitely not:  runIdentity works in one and not the other
18:39:40 <ski> @type let foo :: (forall m. Monad m => m a) -> a; foo ma = runIdentity ma in foo
18:39:41 <lambdabot> (forall (m :: * -> *). Monad m => m a) -> a
18:40:09 <mm_freak> i mean inside the wire
18:40:21 <arkeet> tabemann: that depends on what you mean by RT ;)
18:40:30 <mm_freak> arkeet: Referentially Transparent
18:40:36 <arkeet> mm_freak: I know that.
18:40:48 <tabemann> arkeet: I honestly feel that the must-be-RT-statically position is kind of... extreme
18:40:53 <arkeet> me too.
18:40:54 <mm_freak> it means that when i say "sucks", then i mean it =P
18:41:10 <arkeet> "RT" shouldn't mean "platform-independent".
18:41:13 <arkeet> that misses the point.
18:41:27 <mm_freak> i never thought of it to mean that
18:41:42 <arkeet> me either.
18:41:45 * tabemann is fine with RT being "must evaluate to the same value *or bottom* for the same arguments in a given execution of a program on a particular machine"
18:41:52 * arkeet too
18:41:57 <tabemann> mm_freak: you obviously haven't been reading conal's blog
18:42:06 <arkeet> conal:)
18:42:13 <conal> :)
18:42:15 <mm_freak> tabemann: i'm actually reading it regularly
18:42:27 <mm_freak> but yeah, i skipped a few articles =)
18:42:36 <ski> afaiu, "RT" applies to contexts, not to expressions
18:42:51 <conal> i'm working on a new series of posts
18:43:03 <sclv> danharaj: soon, i imagine. if rick encoded one then i think he'll have the other done shortly
18:43:04 <mm_freak> conal might think, i skipped those about FRP =P
18:43:12 <conal> … about compiling haskell to hardware
18:43:14 <ski> mm_freak : not sure what you mean by "inside the wire"
18:43:28 <danharaj> sclv: cool
18:43:37 <sclv> conal: awesome, i'm excited to see how your work has progressed
18:43:40 <mm_freak> conal: but you may be pleased to know that netwire 5 exposes an FRP interface that strictly respects continuous time/discrete event semantics =)
18:43:55 <sclv> and rather than play follow along in yr repo i thought i'd wait until you explained how you used the category machinery
18:44:00 <tabemann> conal: do you mean hardware DSLs in Haskell, or literall compiling Haskell to hardware?
18:44:09 <sclv> so i could get the condensed story :-)
18:44:12 <conal> mm_freak: oh -- good news. does net wire have a denotation at all?
18:44:32 <conal> tabemann: literally haskell to hardware.
18:44:51 <arkeet> like something you could burn on an FPGA?
18:44:57 <mm_freak> conal: it does…  some of it (events) is specified in code…  i'm not quite sure how to formalize behaviors yet
18:45:01 <danharaj> reduceron!
18:45:24 <conal> mm_freak: formalize their meaning?
18:45:45 <mm_freak> yeah
18:47:17 <monochrom> ski: "referential transparency" is not referentially transparent :)
18:47:44 <mm_freak> conal: the traditional view is, type Behavior a = Time -> a, but that doesn't include inhibition…  in the new version production/inhibition is required to occur on non-zero length intervals
18:48:01 <ski> monochrom : surely that must be meaningless, since "referential transparency" isn't a context, but an expression/phrase
18:48:04 <ski> (:
18:48:26 <mm_freak> i'm not using inhibition for events anymore and introduced a new concept, which for lack of a better term i called "occasions" aka non-instantaneous events
18:48:43 * monochrom tries to think of how to make "referential transparency" a context
18:49:09 <ski> perhaps "is not referentially transparent" would work ? (imagine a hole at the beginning)
18:49:29 <monochrom> ah, that works
18:49:54 <monochrom> "___ is not referentially transparent" is not referentially transparent \∩/
18:51:06 <monochrom> anyway, I also like how people say "equal" without first syncing on what they define as "equal"
18:51:28 <mm_freak> conal: if you're interested, here is a short introduction and its code:  http://hub.darcs.net/ertes/netwire
18:51:43 * ski is reminded of : "yields absurdity when precomposed with its quotation" yields absurdity when precomposed with its quotation
18:52:13 <mm_freak> the semantics are in Control.Wire.Semantics, but are currently very limited
19:09:01 <lispy> ski: I can't read that without going insane :)
19:10:14 <ski> iirc, it's from Smullyan
19:10:23 <ski> @where smullyan
19:10:23 <lambdabot> Raymond Merril Smullyan, "To mock a mockingbird : and other logic puzzles including an amazing adventure in combinatory logic","The riddle of Scheherazade and other amazing puzzles, ancient & modern"
19:10:23 <lambdabot> ,"What is the name of this book : The riddle of dracula and other logical puzzles"
19:13:19 <b2coutts> what would be the logical data structure to use in haskell for storing an 8x8 grid of things?
19:13:46 <tabemann> what do you need to do to this grid
19:13:55 <tabemann> if you're constructing it all at once, an Array
19:14:20 <tabemann> if you need to do arbitrary updates in pure code, use a Map with coordinates as keys
19:14:36 <tabemann> if you need to do arbitrary updates, but you don't mind being in IO or ST, use an IOArray or STArray
19:14:37 <ski> (or maybe `STArray' ?)
19:14:55 <tabemann> okay, ST is pure, yes
19:15:19 <ski> well, the outside of it isn't monadic
19:15:27 <b2coutts> oh, the Map is an interesting idea
19:15:30 <b2coutts> thanks
19:15:35 <Sonarpulse> Map?
19:15:47 <ski> @index Map
19:15:47 <lambdabot> Data.Map
19:15:49 <Sonarpulse> Don't think that is correct
19:15:53 <tabemann> you probably will get worse space and time complexity with a Map than with an STArray, though
19:16:03 <mm_freak> and if you need to do heavy computation on the array, use repa
19:16:05 <Sonarpulse> what is this grid for exactly?
19:16:22 <b2coutts> it's a chessboard
19:16:24 <Sonarpulse> eh, repa will be fine, but you won't reap data paralell advantages with 8x8
19:16:41 <Sonarpulse> ah
19:16:46 <Sonarpulse> repa does have nice 2D indexing
19:16:48 <Sonarpulse> but no mutation
19:17:00 <mm_freak> Sonarpulse: depends on the individual computation
19:17:07 <khyperia> I just read this in the prelude docs... what does "map ($ 0) xs" do?
19:17:10 <Fuuzetsu> b2coutts: are you dcoutts's brother?
19:17:13 <Sonarpulse> mm_freak: very true
19:17:15 <khyperia> :t ($ 0)
19:17:16 <lambdabot> Num a => (a -> b) -> b
19:17:23 <johnw> khyperia: it takes a list of functions and applies 0 as an argument to each of them
19:17:26 <b2coutts> Fuuzetsu: haha, I wonder this every time he talks when I happen to be in the channel
19:17:34 <khyperia> ahh
19:17:38 <b2coutts> I don't have a brother, but my father's name is dave, so...
19:17:48 <Fuuzetsu> dcoutts is Duncan
19:17:55 <b2coutts> :(
19:17:58 <b2coutts> I guess he's not my dad then
19:18:05 <mm_freak> i'd probably just use a repa array anyway
19:18:11 <mm_freak> because of the indexing
19:18:14 * ski was thinking of some kind of coutts converter ..
19:18:25 <mm_freak> you might also use a regular vector with a few lenses for indexing
19:18:25 <Sonarpulse> seeing that data.array is crap (but also does indexing)
19:18:32 <tabemann> back
19:18:42 <Sonarpulse> I guess repa
19:18:49 <johnw> b2coutts: for a chess board, you could also use a large Integer instead
19:18:49 <b2coutts> right now I'm still considering Data.Map just for how nice the code would be
19:19:04 <b2coutts> johnw: a _single_ integer?
19:19:16 <Sonarpulse> what would your keys be?
19:19:20 <johnw> sure, there are exactly 12 different kinds of pieces on the board
19:19:21 <b2coutts> like, encoding the entire chessboard into one?
19:19:28 <b2coutts> Sonarpulse: (Int, Int)
19:19:34 <johnw> that's 4 bits to store each piece
19:19:36 <Sonarpulse> use repa
19:19:36 <johnw> > 64 * 4
19:19:36 <khyperia> so basically, ([operator] [value]) applies [value] to the... *second* argument of the operator's function? So like (\x -> x [operator] [value])?
19:19:37 <lambdabot>   256
19:19:47 <johnw> you need a 256 bit board to fully represent a chess position
19:19:48 <b2coutts> well yeah, but that sounds both ugly and inefficient
19:19:49 <ski> > map ($ 0) [f,g 1,(** 2)] :: [Expr]
19:19:50 <lambdabot>   [f 0,g 1 0,0**2]
19:19:50 <Sonarpulse> repa is strictly better than Data.Map for this as they are both immutable
19:19:51 <elliott> (+ 123) is (\x -> x + 123).
19:19:59 <elliott> (123 +) is (\x -> 123 + x)
19:20:06 <tabemann> johnw: does that include storing the data necessary for en passant and castling?
19:20:06 <johnw> you'd use masking to access and set, which lens can make elegant
19:20:07 <elliott> the argument goes where it's omitted. simple
19:20:11 <mm_freak> Sonarpulse: for "this"?
19:20:23 <Sonarpulse> for a chess board
19:20:25 <mm_freak> remember that Map doesn't copy the whole map when updating a single element
19:20:26 <Sonarpulse> mm_freak
19:20:30 <johnw> tabemann: pawns which can still en passant would be a 13th piece type, and kings which can castle a 14th
19:20:32 <mm_freak> while repa does
19:20:38 <mm_freak> well, no, actually not
19:20:45 <Sonarpulse> that's true
19:20:46 <khyperia> elliott, does the compiler get confused when it sees (- 2) and think it's (-2) or does it detect the space?
19:20:48 <ski> khyperia : yes, `(** 2)' is `\x -> x ** 2'
19:20:52 <mm_freak> in repa you would use a delayed array for updates
19:20:59 <Sonarpulse> but chess piece enum can fit in unboxed vector
19:21:01 <mm_freak> so in the end repa may actually be the right answer
19:21:07 <johnw> b2coutts: http://stackoverflow.com/questions/1831386/programmer-puzzle-encoding-a-chess-board-state-throughout-a-game
19:21:15 <ski> @type (- 2)
19:21:16 <lambdabot> Num a => a
19:21:19 <johnw> lots of good reading there
19:21:29 <ski> khyperia : `(- blah)' is an exception
19:21:38 <khyperia> @type ((-) 2)
19:21:38 <lambdabot> Num a => a -> a
19:21:40 <b2coutts> I've been down this road before, in C++
19:21:55 <ski> > map ((-) 2) [-3 .. 3]
19:21:56 <lambdabot>   [5,4,3,2,1,0,-1]
19:22:00 <ski> > map (subtract 2) [-3 .. 3]
19:22:01 <lambdabot>   [-5,-4,-3,-2,-1,0,1]
19:22:07 <BMeph_> ...and rooks which can still castle , a 15th. :)
19:22:12 <johnw> right
19:22:21 <johnw> and the blank square is the 16th
19:22:38 <b2coutts> this also doesn't account for stalemates
19:22:48 <BMeph_> johnw: Smo0oth! ;)
19:22:49 <johnw> that would require position analysis over time
19:22:50 <b2coutts> chess is really a very ugly game
19:22:57 <b2coutts> maybe I should just write an AI for go or something
19:23:02 <johnw> i've actually written all this code in Lisp
19:23:06 <tabemann> go is much harder than chess
19:23:08 <tabemann> much harder
19:23:18 <khyperia> > (map ((-) 2) [-3 .. 3]) == (map (\v -> subtract v 2) [-3 .. 3])
19:23:19 <lambdabot>   True
19:23:29 <mm_freak> b2coutts: start with a tictactoe AI
19:23:38 <mm_freak> chess and go are very difficult
19:23:41 <b2coutts> blegh
19:23:43 * khyperia should probably boot ghci instead of fiddling with lambdabot
19:23:56 <elliott> khyperia: - is a horrible special case
19:24:02 <khyperia> heh
19:24:08 <Sonarpulse> well is go "more regular"
19:24:09 <b2coutts> ticTacToeAI :: Map State State
19:24:17 <Sonarpulse> then the challenge is worthwhile
19:24:37 <b2coutts> anyway, go may be harder to write an AI for, but at least it isn't full of arbitrary exceptions
19:24:43 <mm_freak> b2coutts: tttAI :: Board -> Board
19:25:37 <mm_freak> b2coutts: if you want something nontrivial, for which an AI is much easier to write, check out checkers
19:25:39 <tabemann> okay, go is harder than chess simply in that you can write a chess AI that can play effectively against master chess players, but so far you can't with go; but yes, it's probably far less regular to implement
19:26:30 <b2coutts> I thought people had written such go AIs already
19:26:36 <scshunt> nope
19:26:40 <scshunt> go is hard
19:26:46 <scshunt> chess is pretty easy compared
19:27:03 <jmcarthur> some good things have come out of the research to make good go AI though
19:27:22 <scshunt> go has an extremely large number of available moves in any game state, and a surprisingly small number can be written off immediately
19:27:25 <jmcarthur> UCT comes to mind
19:27:46 <mm_freak> b2coutts: go's complexity grows much faster than chess' with each level of analysis
19:27:50 <jmcarthur> well, at least the popularization of UCT. it may not originally come from go AI
19:27:56 <scshunt> jmcarthur: UCT?
19:28:10 <johnw> Unified Chess Theory?
19:28:35 <jmcarthur> Upper Confidence bounds applied to Trees
19:28:57 <jmcarthur> the abbreviation is terrible, i know
19:29:47 <spaceships> i don't believe writing chess ai to beat grand masters is easy, even though i'll agree that writing go ai is harder
19:29:49 <jmcarthur> UCT works very well with laziness, too :)
19:29:58 <jmcarthur> since it's all about a lazily growing tree
19:30:13 * BMeph_ much prefers Loewr and Upper Significance bounds.... ;)
19:30:22 <b2coutts> are the best chess AIs just breadth-first searches with a ton of ricing?
19:30:23 <BMeph_> *Lower
19:30:42 <johnw> b2coutts: there are lots of algorithmic optimizations, like alpha-beta pruning and many others I've forgotten now
19:30:43 <tabemann> spaceships: it's not easy, but it's feasible with what we know today
19:31:01 <jmcarthur> b2coutts: no, they are more sophisticated than that
19:31:11 <johnw> plus, you weight probabilities by analyzing the game history of your target oponent
19:31:14 <jmcarthur> b2coutts: but not tremendously so
19:31:34 <johnw> i'm sure the Internet is rich with stories of people's adventures writing chess computers
19:31:43 <johnw> some people dedicate enormous amounts of time to it
19:32:41 <jmcarthur> most good chess AIs have minimax search with alpha beta pruning, tons of openings hardcoded in, special code paths for end-game situations, tons and tons of heuristics to evaluate the values of game states, and so on
19:35:06 <mm_freak> a simple minimax chess AI can actually play, but it doesn't employ any strategy, so it's easy to defeat
19:35:15 <mm_freak> you can practice your tactics though
19:35:33 <jmcarthur> i like the idea of UCT because it's a monte carlo algorithm with a fairly principled way of guiding it toward better moves without starving other moves
19:35:35 <johnw> it's also a good way to play out chess games
19:35:47 <johnw> (meaning, "white to mate in 4" type puzzles)
19:36:19 <jmcarthur> in other words, it's easy to bang out :)
19:36:23 <tabemann> heh
19:37:04 * spaceships grumbles
19:37:45 <jmcarthur> one of those words needs to be singular
19:38:04 <spaceships> can you explain UCT a bit more?
19:39:06 <jmcarthur> i can't explain it better than https://www.lri.fr/~sebag/Examens_2008/UCT_ecml06.pdf
19:39:19 <jmcarthur> i definitely can't explain the math
19:39:45 <jmcarthur> i can explain how to use the magic formula, but i think you can figure that part out anyway
19:39:54 <spaceships> cool, checking it out
20:14:13 <tabemann> yeesss - my algorithm works!
20:14:26 <tabemann> and with very minimal debugging too
20:20:54 <joeyh> if I have data Whatever = Normal | Unusual, and a case that matches both Normal and Unusual, ghc -Wal complains that I am missing a case matching _. To fix it I probably end up using _ -> for the Normal case. Anyone else find this annoying? I'd rather get a warning from ghc if I later extend Whatever with another constrictor, so I remember to update my case statement.
20:24:29 <johnw> joeyh: can you show me your code?
20:24:39 <johnw> are you matching by ViewPattern, or just a regular pattern match?
20:30:54 <joeyh> hmm, it doesn't always do it. interesting
20:31:12 <roconnor> joeyh: what you are describing doesn't sound correct
20:31:22 <geekosaur> normally it's impossible to have a case that matches two distinct constructors
20:31:34 <geekosaur> unless those actually have parameters with distinctive patterns
20:31:39 <roconnor> maybe I didn't understand
20:31:53 <geekosaur> and even then the problem is not what you described... that error message suggests a third constructor
20:32:53 <joeyh> no, I had 2 cases, one for each constructor
20:33:06 <joeyh> ghc's message seemed to suggest I have a third one, to handle _ , for some reason
20:33:27 <geekosaur> I think you'd need to show actual code at this point
20:33:51 <arkeet> @paste
20:33:52 <lambdabot> Haskell pastebin: http://lpaste.net/
20:33:53 <roconnor> joeyh: my understanding is that GHC won't do taht
20:34:02 <arkeet> put your code here --^
20:39:34 <hpaste_> joeyh pasted “non-exhaustive” at http://lpaste.net/92101
20:39:47 <joeyh> so, it was == testing actually
20:39:52 <joeyh> cases are ok
20:40:16 <sclv> right
20:40:28 <leroux> joeyh: You should try defining any instance of Show for that.
20:40:34 <leroux> And then just using print or show.
20:40:45 <joeyh> this is a contrived example
20:40:49 <sclv> there's no way around that -- you use an "otherwise" clause
20:41:17 <sclv> ghc won' "see through" the Eq typeclass to know that your guards are exhaustive
20:41:26 <joeyh> "    In an equation for `showWhatever': Patterns not matched:
20:41:27 <joeyh> "
20:41:40 <joeyh> it seems to be able to determine it can't find anything
20:41:50 <dwcook> A case expression would be better there, probably
20:42:03 <joeyh> indeed, but in real life can require some annoying refactoring
20:42:20 <sclv> they're the preferred style precisely because you get better exhaustiveness checking
20:42:43 <joeyh> otoh I suppose I can leave off Eq and force that
20:43:32 <leroux> joeyh: You can just do an `otherwise = error "Shouldn't happen"`.
20:43:43 <elliott> sclv: and also because you avoid boolean blindness.
20:43:55 <joeyh> yeah, but then you add a constructor and your code is suddenly crashy
20:44:40 <sclv> elliott: oh true. if your data constructors actually have any contents its better to actually extract them directly. that's the _main_ reason in fact.
20:44:44 <roconnor> joeyh: if you are using -Wall it won't compile when you add another constructor
20:44:59 <joeyh> will with | otherwise
20:45:00 <sclv> well it will compile with a warning
20:45:08 <sclv> you will need -Werror to force it to not comple
20:45:12 * sclv hates the -Werror
20:45:16 <roconnor> oh
20:45:28 <roconnor> I find using == in guards very strange
20:45:32 <dwcook> I kinda wish you got a pattern matching function a la maybe/either for free with your types
20:45:32 <roconnor> I almost never do that
20:45:58 <joeyh> ok, I think I see how the Eq instance makes determining exhastivity intractable
20:46:33 <roconnor> joeyh: you can define your own Eq where _ == _ = False and it is perfectly legit(ish)
20:46:34 <dwcook> Come to think of it, I think TH could do that
20:46:40 <sclv> dwcook: agreed. i think there are some toy languages that do that. (often because they don't have real pattern matching :-P)
20:46:52 <roconnor> dwcook: for strictly positive inductive data types
20:46:57 <joeyh> very ish
20:47:03 <dwcook> roconnor, what does that mean?
20:47:09 <elliott> it could inline the (==) instance in common cases
20:47:11 <elliott> and discover it's exhaustive
20:47:16 <elliott> but why bother when it's so unidiomatic?
20:47:40 <sclv> roconnor: that's a strong condition -- sure you need it?
20:48:10 <dwcook> roconnor, give an example of a type for which what I suggested would not work.
20:48:12 <roconnor> dwcook: I means finding a recursive elimination operator for data Dom = Dom -> Dom is going to be hard. :)
20:48:14 <sclv> data Whatever a = Foo a | Bar (a -> Int)
20:48:22 <dwcook> Ahhh, I see.
20:48:27 <sclv> that one should work though, right?
20:48:31 <johnw> sclv: my first use for -Werror: stopping other people from ignoring the warnings they add to code
20:48:36 <johnw> s/first/favorite
20:49:09 <sclv> i've gone years ignoring a deprecation warning i added to my own code
20:49:15 <sclv> it was very satisfying
20:49:21 <johnw> i'm way too OCD for that
20:49:23 <roconnor> dwcook: and Dom is actually useful for defining the untyped lambda calculus.
20:49:51 <dwcook> roconnor, actually, I misread - Is that truly a valid declaration?
20:50:01 <dwcook> Gah, sorry for the unicode noise, my terminal is lame
20:50:03 <roconnor> joeyh: there is some precidence for Eq defining a partial equivalence relation.
20:50:09 <joeyh> I wonder if ghc's warning message in this case could at least be improved. It seems to say "Patterns not matched: [none]"
20:50:15 <roconnor> dwcook: valid and somewhat useful
20:50:17 <sclv> data Dom = Dom (Dom -> Dom) maybe ?
20:50:22 <sclv> you need a constructor
20:50:25 <roconnor> right
20:50:27 <roconnor> sorry
20:50:32 <roconnor> what sclv said
20:50:51 <sclv> you can define the one-step eliminator easily enough tho?
20:51:06 <dwcook> Ah, in that case the "free" function would just have the form ((Dom -> Doom) -> a) -> Dom
20:51:23 <dwcook> s/Doom/Dom/
20:51:29 <dwcook> Wait
20:51:32 <roconnor> dwcook: shouldn't the result be a?
20:51:37 <dwcook> ((Dom -> Dom) -> a) -> Dom -> a
20:51:40 <dwcook> Yeah
20:51:56 <roconnor> hmm
20:52:13 <dwcook> To be honest I'm not sure how useful that function is
20:52:18 <sclv> in that case not very
20:52:24 <roconnor> I guess with Maybe and Either I can't tell the difference between a one step eliminator and a full recursive eliminator. :D
20:52:27 <sclv> but its legit
20:52:34 <dwcook> But it could be useful for lists, for example
20:52:59 <dwcook> (a -> [a] -> b) -> b -> [a] -> b
20:53:12 <sclv> right -- that's defined in some utility packages as 'list'
20:54:24 <dwcook> I think that generalizes foldr actually
20:56:22 <BMeph_> dwcook: FSVO "generalizes," since you're substituting one specific typw for another. :)
20:56:28 <BMeph_> *type
20:57:17 <dwcook> I mean in the sense that you can write foldr with that function
20:57:24 <dwcook> Let me try that actually
20:58:02 <roconnor> you won't be able to write foldr without using fix
20:58:18 <tabemann> http://stackoverflow.com/questions/18344688/efficiently-implementing-equal-in-scheme-without-direct-access-to-pointer-value/18364831#18364831 < hmm, where do I put this so it doesn't get lost...
20:59:31 <sclv> roconnor: or just direct recursion :-)
21:00:21 <sclv> tabemann: you can "star" it in stackoverflow to keep it on a list of saved answers
21:02:10 <tabemann> sclv: okay, found how to do that
21:04:24 <dwcook> > let { list cons _ (x:xs) = x `cons` xs ; list _ null [] = null ; foldr cons null xs = list f null xs where f x xs = x `cons` list f null xs } in foldr (:) [] [1..10]
21:04:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
21:04:51 <dwcook> I'm not sure if that is actually considered "generalizing"
21:12:53 <sepia> anyone know how to get gloss to work with ghcjs?
21:13:31 <sepia> i have gloss installed on my vagrant VM, but that probably won't work because that's not .hs files
21:13:41 <sepia> tried using gloss source code, but got this error:
21:13:56 <sepia> Graphics/Gloss/Internals/Interface/Backend.hs:31:2:
21:13:56 <sepia>      error: #error No default backend defined
21:14:13 <sepia> so maybe how can i define a backend for gloss?
21:21:40 <NemesisD> is there any reason why i should prefer a TChan over a TQueue if I don't need dupChan/cloneChan
21:23:22 <sepia> http://hackage.haskell.org/packages/archive/gloss/latest/doc/html/src/Graphics-Gloss-Internals-Interface-Backend.html
21:25:02 <flazz> is there a convention on monad transformers to put the monad as the second to last type variable?
21:25:59 <shachaf> Not only a convention but a necessity.
21:26:24 <shachaf> :t lift
21:26:25 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
21:27:26 <flazz> ok, so t has all other type varaible applied by the time you call lift?
21:27:41 <sepia> or is any way in general to use ghcjs with a library
21:27:44 <sepia> there*
21:27:51 <tabemann> NemesisD: at least Hackage says that you can get better amortized performance out of TQueue, even though worst-case performance can vary
21:30:09 <zq> isn't the default import search path == "."?
21:30:14 <zq> in ghci, that is
21:30:32 <mm_freak> zq: one of them
21:31:13 <mm_freak> but "." may not be what you expect…  in X.Y.Z, located in abc/X/Y/Z.hs, the "." really refers to abc, not to abc/X/Y
21:31:22 <zq> "import Module" isn't working
21:31:36 <zq> despite there being a ./Module.hs
21:31:57 <zq> rephrase: cwd of ghci is same as path to Module.hs
21:32:03 <mm_freak> what's the name of the module that tries to import?
21:32:12 <zq> prelude?
21:32:23 <mm_freak> module XXX where import Module
21:32:25 <mm_freak> what's XXX?
21:32:30 <zq> oh. hah.
21:32:48 <zq> i wanted to test out what "module Module (module Module) where foo = 42" did
21:33:06 <zq> i thought about :browse Module.hs, but that didn't work
21:33:07 <mm_freak> that's the same as "module Module where foo = 42"
21:34:23 <zq> meh
21:34:55 <mm_freak> it's useful if you want to export everything and also reexport some other modules
21:35:08 <mm_freak> module X (module X, module Data.List) where import Data.List; …
21:35:33 <Twey> module Module (module Module, Module (Module), module') where data Module module' = Module module'; module' = Module "module"
21:35:40 <zq> i see, but i'm still quite confused about how the import system of ghci works
21:35:50 <zq> eg, what the diff b/n :l and import is
21:36:13 <NemesisD> uuuuugh
21:36:19 <blackdog> Twey: that's just perverse :)
21:36:28 <Twey> ‘Module’ no longer looks like a word
21:36:38 <NemesisD> trying to make a pull request to a project that uses unicode symbols for everything
21:36:45 <blackdog> oh, i'll have your module. i love module!
21:37:02 <mm_freak> zq: you probably want to use :m
21:37:03 <Twey> NemesisD: M-x set-input-method Agda RET :þ
21:37:13 <NemesisD> lol
21:37:21 <mm_freak> zq: :m and import are mostly equivalent, except that import is more powerful
21:37:25 <NemesisD> i think im just going to code it like a sane person and then find and replace after
21:37:45 <Twey> NemesisD: Try it with the Agda input method.  You soon get used to it.
21:37:48 <mm_freak> zq: one important difference is that :l actually refers to files, while :m does it properly and refers to modules
21:39:11 <Twey> mm_freak: A fun difference is that GHC complains about everything being exported twice
21:39:27 <Twey> (if you also export things normally)
21:39:29 <zq> mm_freak: so all 3 of :l, :m, and import search through either the default search path(s) or the dirs given by -i, right?
21:40:15 <NemesisD> i use vim
21:40:17 <mm_freak> zq: good question…  in my > five years of haskell experience i haven't dealt with search paths =)
21:40:25 <Twey> NemesisD: Oh, sorry :þ
21:41:02 <zq> mm_freak: a simpler question: why does :l Module.hs work but not import Module?
21:41:36 <mm_freak> zq: one way this could happen is when Module.hs contains the module X.Module, not Module
21:41:46 <mm_freak> :l will work then, but :m/import will fail
21:43:11 <zq> here's what i'm doing: 'echo "module Randomname (foo) where foo = 42" > Randomname.hs; ghc Randomname.hs'
21:43:28 <mm_freak> ghc?
21:43:30 <zq> then ghci, :m Randomname, and ghci still can't find it
21:43:58 <zq> ghc to generate Randomname.hi, which i suspect might be needed for ghci to import/:m it
21:44:16 <mm_freak> you don't need to do that
21:44:37 <mm_freak> anyway, :l actually alters the search path in relation to the loaded file
21:44:51 <zq> maybe, but i haven't invoked :l
21:44:57 <mm_freak> you have
21:45:02 <zq> where?
21:45:07 <mm_freak> by saying "ghci Randomname.hs"
21:45:11 <zq> i havent
21:45:19 <mm_freak> oh, sorry
21:45:23 <zq> okay, more clarity: echo "module Randomname (foo) where foo = 42" > Randomname.hs; ghc Randomname.hs; ghci
21:45:30 <mm_freak> yeah, that's what i mean
21:45:32 <zq> sorry for the confusion
21:45:40 <mm_freak> since there was no :l in the current directory, it may not even search there
21:45:44 <mm_freak> let me try it out
21:46:26 <zq> http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/loading-source-files.html says that default search path is "."
21:48:50 <mm_freak> from what i'm observing :m/import only load registered modules, unless they were imported by a loaded module
21:48:55 <zq> oops, i mean http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/separate-compilation.html#search-path
21:49:35 <mm_freak> in other words, 'import' in a source file works slightly differently
21:49:36 <zq> "The search path by default contains a single directory: “.” (i.e. the current directory). The following options can be used to add to or change the contents of the search path:"
21:49:49 <zq> :(
21:49:56 <mm_freak> remember that there is a difference between file and module
21:50:07 <mm_freak> the documentation talks about files for :l
21:50:13 <zq> yeah, seeing that now
21:50:48 <zq> so for an arbitrary *.hs, is it possible to list out its exports?
21:51:02 <mm_freak> yes, :load it
21:51:05 <mm_freak> then :bro
21:51:29 <mm_freak> ghci blah.hs, then :bro
21:51:39 <mm_freak> or:  ghci, then :l blah.hs, then :bro
21:51:42 <zq> :bro for :browse
21:51:49 <mm_freak> yeah
21:52:13 <mm_freak> you can use the shortest unique prefix for commands
21:52:42 <zq> wondering why ghci doesn't have a default search path
21:53:10 <zq> mm_freak: thanks, anyhow
21:53:11 <mm_freak> it does, but unlike most languages :l is actually a hack
21:53:27 <scshunt> heh
21:53:33 <zq> how so?
21:53:58 <mm_freak> haskell has a proper module system…  imports reference modules, not files
21:54:19 <mm_freak> "loading files" is a weird concept
21:54:26 <zq> shit, so  it doesn't make sense to "import <filename"
21:54:28 <zq> >
21:54:35 <scshunt> nope, not in the slightest
21:54:40 <NemesisD> is something like this tail call optimizable: runMonitor = ... when foo $ runMonitor
21:55:00 <zq> still stuck in python where there's a 1-to-1 correspondence b/n modules and files
21:55:04 <mm_freak> NemesisD: it is already tail-called
21:55:17 <Twey> @src when
21:55:17 <lambdabot> when p s = if p then s else return ()
21:55:26 <mm_freak> NemesisD: whether this will work depends on the strictness of (>>=)
21:55:27 <Twey> That's a tail-call
21:55:38 <mm_freak> so it depends on the monad
21:55:48 <NemesisD> IO :)
21:55:53 <mm_freak> yes, it works for IO
21:56:01 <mm_freak> (>>=) is non-strict in its second argument
21:57:20 <mm_freak> zq: when you write a haskell package module names do correspond to files…  but when you say "import Data.Map", then there is no /search path/, but a registered package that somehow contains a module named Data.Map
21:57:36 <mm_freak> zq: in fact cabal even requires you to give proper package dependencies
21:57:40 <mm_freak> (almost proper)
21:57:47 <NemesisD> what's that extension that binds variables for all the fields in a record?
21:58:42 <mm_freak> NemesisD: RecordWildcards or something?
21:59:07 <mm_freak> {..}
21:59:20 <mm_freak> but it shadows your field names, so you may not want to use it =)
21:59:34 <NemesisD> lol apparently there's also a Record puns
21:59:40 <mm_freak> ah, yeah
21:59:44 <mm_freak> that's the one i meant actually
22:00:21 <mm_freak> choose which one is better:  f (X {..}) = abc + def
22:00:26 <mm_freak> vs.: f x = abc x + def x
22:00:34 <mm_freak> i prefer the latter, which doesn't require any extension =)
22:01:11 <NemesisD> i've got a somewhat special case here in which all the fields of a record are going to be used and most of them are going to go right to a function call in sequence
22:01:21 <NemesisD> also i think the first one you posted is wildcards and not puns
22:01:27 <johnw> you don't need parens on f (X {..})
22:01:36 <mm_freak> NemesisD: in that case you can use applicative style
22:02:08 <NemesisD> mm_freak: how can i use applicative to destructure the fields out of the record
22:02:26 <mm_freak> g x = f (a x) (b x) (c x) (d x) (e x) ⇒ g = f <$> a <*> b <*> c <*> d <*> e
22:03:54 <mm_freak> johnw: it looks even weirder without the parens
22:03:57 <NemesisD> ehhh
22:04:08 <johnw> mm_freak: I'm used to it now
22:04:19 <johnw> now the with-parens version looks weird to me
22:04:26 <mm_freak> NemesisD:
22:04:31 <mm_freak> > sin 3 + cos 3
22:04:32 <lambdabot>   -0.8488724885405782
22:04:40 <mm_freak> > liftA2 (+) sin cos 3
22:04:41 <lambdabot>   -0.8488724885405782
22:05:17 <mm_freak> it's a reader monad…  i mean a true reader monad, not Reader =)
22:06:08 <johnw> why is the monad instance for (->) e "truer" than Reader?  aren't they the same underlying type?
22:06:23 <ski> both are environment monads
22:06:23 <mm_freak> johnw: i'm joking =)
22:06:32 <johnw> ah, ok :)
22:06:41 <johnw> we don't take our monads lightly here
22:06:42 <mm_freak> but using Reader (not ReaderT) seems weird to me
22:06:48 <mm_freak> because it's really just using a function
22:06:59 <mm_freak> and you can use the monadic interface, if you don't want to repeat arguments all the time
22:07:10 <johnw> Reader can sotemise result in vastly more comprehensible error messages at least
22:07:17 <mm_freak> > (do x <- sin; y <- cos; z <- id; return (x, y, z)) 5
22:07:18 <lambdabot>   (-0.9589242746631385,0.28366218546322625,5.0)
22:07:26 <mm_freak> 'id' = 'get'
22:07:34 <mm_freak> uhm
22:07:35 <mm_freak> ask
22:07:42 <mm_freak> 'f' = 'asks f'
22:09:16 <mm_freak> one advantage of using ((->) e) is that you get some useful instances
22:09:41 <mm_freak> > (id <> reverse) "abc"
22:09:42 <lambdabot>   "abccba"
22:10:41 <mm_freak> > (id <> pure "-" <> reverse) "abc"
22:10:42 <lambdabot>   "abc-cba"
22:10:50 <mm_freak> that's sometimes a nice alternative to Writer =)
22:11:22 <johnw> whoa
22:12:08 <johnw> guess i never thought of mixing operators with reader like that, that's cool
22:13:59 <ski> > sortBy (comparing length `mappend` comparing (map toLower)) (words "The quick brown fox jumps over the lazy dog")
22:14:00 <lambdabot>   ["dog","fox","The","the","lazy","over","brown","jumps","quick"]
22:16:45 <joelteon> neat
22:21:31 <dickfeynman> Hi everyone, I have a question about the following line of code: filter (<5) [1..]
22:21:59 <ski> using `mappend' in this way is due to Cale, see <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx>
22:22:02 <zhulikas> what's the question?
22:22:18 <johnw> byorgey's posted about htat too
22:22:26 <dickfeynman> I notice that GHCI goes into a infinite loop, even though it's "obvious to humans" that the result must be a finite list.
22:22:28 <ski> probably something like "why doesn't the list end ?"
22:22:52 <zhulikas> it's obvious to humans that result is infinite
22:22:55 <zhulikas> oh wait
22:22:56 <zhulikas> yeah
22:22:57 <zhulikas> it is :D
22:22:58 <ski> yes, `filter' has no way of knowing that the list it gets is increasing
22:23:35 <dickfeynman> Is this really equivalent to the halting problem i.e. is there no way the interpreter can be expected to know the result?
22:23:36 <zhulikas> you could instead do
22:23:40 <zhulikas> > take 4 [1..]
22:23:41 <lambdabot>   [1,2,3,4]
22:23:58 <dickfeynman> Ah, but when I generate the list by using [1..], I'm using the property that these are ordinals and strictly increasing (otherwise filtering is also not possible!)
22:24:15 <ski> (and we don't want a compiler to "optimize" non-termination here into the list ending, since that would mean that the same program could terminate in one implementation and not terminate in another (or with different optimization settings enabled))
22:24:27 <mm_freak_> dickfeynman: the result of filter (< 5) [1..] is not [1..4]
22:24:31 <ski> dickfeynman : so use `takeWhile' ?
22:24:33 <zhulikas> > takeWhile (<5) [1..]
22:24:34 <lambdabot>   [1,2,3,4]
22:24:36 <mm_freak_> the result is 1 : 2 : 3 : 4 : undefined
22:24:41 <mm_freak_> which is a different list
22:25:13 <ski> dickfeynman : "Is this really equivalent to ..." -- yes, in general it is
22:25:19 <mm_freak_> it would be wrong for the compiler to "breaktimize" it to [1..4]
22:25:39 <shachaf> [1..] isn't an infinite list.
22:25:57 <shachaf> Well, it is if it's :: [Integer]. But not in general, e.g. :: [Int]
22:25:57 <joelteon> [1,1..] is
22:26:32 <shachaf> Yes, many things are. But not necessarily the thing that was being talked about.
22:27:14 <dickfeynman> Hmm, interesting.
22:27:23 <ski> > [maxBound ..]
22:27:24 <lambdabot>   [()]
22:28:38 <dickfeynman> mm_freak_: How do I see that the result of the code is 1:2:3:4:undefined?
22:28:52 <mm_freak_> dickfeynman: by understanding what 'filter' does
22:28:52 <joelteon> You don't
22:28:56 <joelteon> oh
22:29:00 <joelteon> never mind, misunderstood the question
22:29:17 <mm_freak_> @src filter
22:29:17 <lambdabot> filter _ []     = []
22:29:17 <lambdabot> filter p (x:xs)
22:29:17 <lambdabot>     | p x       = x : filter p xs
22:29:17 <lambdabot>     | otherwise = filter p xs
22:29:38 <mm_freak_> the base case is never matched in your case (i'm assuming [Integer])
22:29:52 <mm_freak_> and the recursive case will never conclude
22:41:47 <dickfeyman> I don't quite understand lazy evaluation, but if Haskell generates the infinite list "lazily" (and by using the the knowledge that these are ordinals and the list is strictly increasing) is it not possible to "reason" that the list must terminate?
22:42:48 <ski> it doesn't use "the knowledge that these are ordinals and the list is strictly increasing"
22:43:18 <ski> only the actual list elements, as found by the process that generates them, can be inspected
22:43:23 <dickfeyman> ski: How else can it generate the list from [1..] ?
22:43:43 <ski> `[1 ..]' is sugar for `enumFrom 1'
22:44:38 <ski> in the case of `Integer' it is probably defined as something like
22:44:47 <ski>   enumFrom n = n : enumFrom (succ n)
22:45:56 <ski> iow, `[1 ..]' reduces to `1 : [succ 1 ..]', which reduces to `1 : [2 ..]', which reduces to `1 : 2 : [succ 2 ..]', &c.
22:46:15 <ski> only the list constructors (`:') and the elements (`1',`2',&c.) can be inspected
22:46:47 <ski> the internal state of `[1 ..]',`[succ 1 ..]',`[2 ..]',`[succ 2 ..]',&c. can't be inspected (directly)
22:47:15 <ski> the only thing that can be done with such a thing (which has list type) is to try to match it (with a list pattern)
22:48:20 <ski> that will cause as much evaulation of it as is required to determine whether it is the empty list `[]' or a non-empty list `x : xs' (where `x' and `xs' are not evaluated further)
22:49:14 <ski> you can decide to further inspect `x' (causing it to be evaluated), and also to inspect `xs' (causing one more list node to be generated, say `y : ys')
22:50:13 <ski> when one attempts to print a list of numbers, it in turn will compute element after element of the list, to be able to print it
22:50:24 <mm_freak_> dickfeyman: you seem to be thinking operationally…  try to think denotationally
22:50:34 <mm_freak_> filter applied to an infinite list can never yield a finite list
22:51:09 <mm_freak_> consider this list:  filter (== 1) (repeat 0)
22:51:18 <mm_freak_> if you think in sets the answer would be the empty set
22:51:29 <mm_freak_> but lists are not sets and the answer is undefined
22:51:58 <dickfeyman> mm_freak_: That's okay, but I'm trying to understand why the infinite list should even be generated beyond some point (if it's generated lazily)
22:52:15 <dickfeyman> mm_freak_: Hmm
22:52:16 <mm_freak_> dickfeyman: it's not generated…  it's just a model
22:52:35 <mm_freak_> what actually ends up in memory depends on how you pattern-match on such a list
22:52:40 <mm_freak_> > head (repeat 1)
22:52:40 <ski> dickfeyman : because `filter' can't know that some later elements in the list won't satisfy the predicate
22:52:41 <lambdabot>   1
22:53:18 <mm_freak_> "repeat 1" is a model:  let ones = 1 : ones
22:53:42 <mm_freak_> when you ask:  "how does 'ones' match against x : xs?", the answer will be: x = 1, xs = ones
22:55:20 <mm_freak_> when you ask, "how does 'filter (== 0) (repeat 1)' match against x : xs?", you won't get an answer, because filter will never conclude…  that's how it is defined
22:57:48 <NemesisD> what do you guys think of packageimports
22:58:02 <mm_freak_> NemesisD: useful for small non-cabalized scripts
22:58:17 <mm_freak_> not of much use otherwise, IMO
23:00:17 <NemesisD> fair
23:00:27 <NemesisD> this guy i'm doing a pull request for has an odd style
23:00:49 <NemesisD> https://github.com/roelvandijk/terminal-progress-bar/blob/master/src/System/ProgressBar.hs
23:01:56 <mm_freak_> probably a former agda programmer =)
23:02:25 <dickfeynman> Thanks for the help, particularly @mm_freak and @ski
23:02:45 <mm_freak_> dickfeynman: not sure if you received everything i wrote before timing out =)
23:03:17 <mm_freak_> dickfeynman: the gist is: everything is a only a model until you pattern-match
23:03:30 * ski would prefer not being prefixed by an `@'
23:03:39 <dickfeynman> mm_freak_: Am on a kinda bad connection, so I'm also looking at the channel logs :)
23:04:08 <mm_freak_> good idea =)
23:05:03 <dickfeynman> Cool, I'll mull over these ideas.
23:05:28 <dickfeynman> I've just started playing with Haskell.
23:18:09 <padrian> Hello Haskellers
23:18:24 <padrian> consider this
23:18:33 <padrian> :t fmap (*) [1,2,3,4]
23:18:34 <lambdabot> Num a => [a -> a]
23:18:42 <dickfeynman> @src maximum
23:18:42 <lambdabot> maximum [] = undefined
23:18:42 <lambdabot> maximum xs = foldl1 max xs
23:19:31 <padrian> how you can tell by looking only on Num a => [a -> a] it's a function?
23:19:45 <johnw> it's a list of functions
23:19:49 <johnw> that's what [a -> a] means
23:20:55 <ski> `a -> a' is the type of functions taking arguments of type `a' and yielding results of type `a'
23:21:06 <padrian> so the [a -> a] or [a -> a -> a] is just a list of function, the second one is telling that will take 2 param and return a
23:21:06 <ski> `[...]' is the type of lists with elements of type `...'
23:21:13 <ski> hence what johnw said
23:21:25 <ski> yep
23:21:41 <padrian> so the -> is function?
23:21:52 <padrian> :t (->)
23:21:52 <lambdabot> parse error on input `->'
23:22:05 <ski> the `->' is the type constructor for the function type
23:22:29 <ski> `Int -> Bool' is sugar for `(->) Int Bool'
23:22:55 <padrian> :i (->)
23:22:56 <ski> `Int -> Bool' itself is not a function, it's a type : the type of functions from `Int' to `Bool'
23:23:02 <ski> :kind (->)
23:23:05 <ski> er
23:23:08 <ski> @kind (->)
23:23:08 <lambdabot> * -> * -> *
23:23:32 <ski> says that `(->)' takes two arguments, two (concrete) types, and gives back a type
23:23:36 <ski> @kind Int
23:23:37 <lambdabot> *
23:23:57 <ski> `*' is roughly the "type of (concrete) types"
23:24:06 <Ralith> is @djinn intelligent enough to alwyas select the definition which ignores less information, e.g. in Maybe a -> a -> a?
23:24:19 <ski> @kind Maybe
23:24:20 <lambdabot> * -> *
23:24:21 <ski> @kind Maybe Int
23:24:21 <lambdabot> *
23:24:37 <ski> preflex: xseen augustss
23:24:37 <preflex>  augustss was last seen on freenode/#haskell 12 days, 9 hours, 46 minutes and 52 seconds ago, saying: Hi
23:24:38 <padrian> @kind Just a
23:24:38 <johnw> @djinn Maybe a -> a -> a
23:24:38 <lambdabot>     Not in scope: type constructor or class `Just'
23:24:39 <lambdabot>     A data constructor of that name is in scope; did you mean -XDataKinds?
23:24:39 <lambdabot> Not in scope: type variable `a'
23:24:39 <lambdabot> f a b =
23:24:39 <lambdabot>     case a of
23:24:40 <lambdabot>     Nothing -> b
23:24:42 <lambdabot>     Just c -> c
23:24:53 <padrian> @kind Just 3
23:24:54 <lambdabot>     Illegal literal in type (use -XDataKinds to enable): 3
23:25:05 <padrian> @kind Just 3::Int
23:25:06 <lambdabot>     Illegal literal in type (use -XDataKinds to enable): 3
23:25:11 <ski> `Just' is not a type, it's a value (a data constructor)
23:25:45 <ski> `@kind' (`:kind' in GHCi) is to be used with type expressions, not ordinary (value) expressions
23:25:54 <padrian> what is @kind purpose? is not  like :t
23:25:54 <Twey> padrian: A ‘kind’ is a type of types.  Just 3 has type Maybe Int (for example), which has kind *.
23:26:14 <Twey> @kind Maybe Int
23:26:15 <lambdabot> *
23:26:23 <ski> @type Just "False"
23:26:24 <lambdabot> Maybe [Char]
23:27:20 <mm_freak_> padrian: read "*" as "Type"
23:27:26 <mm_freak_> Maybe :: Type -> Type
23:27:30 <mm_freak_> Int :: Type
23:27:37 <mm_freak_> Maybe Int :: Type
23:27:55 <mm_freak_> just like:  sin :: Double -> Double, pi :: Double, sin pi :: Double
23:28:09 <mm_freak_> kinds : types = types : values
23:29:23 <ski> ".. : .. = .. : .." standing for ".. is to (or corresponds to) .. as .. is to .."
23:29:43 <padrian> @src (->)
23:29:43 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
23:29:51 <mm_freak_> (->) is primitive
23:30:03 <ski> `(->)' is primitive, just like `Int' is primitive
23:30:23 <johnw> Int is primitive?
23:30:27 <haasn> yes
23:30:28 <padrian> :) thanks! :)
23:30:29 <johnw> I thought only I# was
23:30:34 <ski> johnw : to Haskell, it is
23:30:35 <haasn> that's a GHC internal type
23:30:39 <mm_freak_> Int isn't primitive in a fundamental sense
23:30:42 <johnw> oh, I see
23:30:44 <mm_freak_> but (->) is fundamentally primitive
23:31:03 <padrian> @src <*>
23:31:04 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:31:14 <mm_freak_> @src Maybe <*>
23:31:14 <lambdabot> Source not found. I am sorry.
23:31:19 <mm_freak_> @src <*> Maybe
23:31:19 <lambdabot> Source not found. Take a stress pill and think things over.
23:31:26 <mm_freak_> @src (<*>) Maybe
23:31:27 <lambdabot> Source not found. Just what do you think you're doing Dave?
23:31:34 <mm_freak_> @src Maybe (<*>)
23:31:34 <lambdabot> (<*>) = ap
23:31:48 <padrian> but... <*> is just an applicative functor?
23:31:58 <haasn> mm_freak_: heh
23:31:58 <mm_freak_> padrian: it's an applicative operator
23:32:09 <mm_freak_> an applicative functor is a type constructor, like Maybe
23:32:14 <haasn> @src Applicative
23:32:15 <lambdabot> class Functor f => Applicative f where
23:32:15 <lambdabot>     pure  :: a -> f a
23:32:15 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
23:32:30 <padrian> mm_freak: yes, its an operator
23:33:27 <mm_freak_> padrian: that's not the point…  a functor is a type, not a value, but (<*>) is a value
23:33:36 <padrian> so this def, f (a -> b) -> f a -> f b is telling.... take a function inside another function (a -> b) and produce a function from f a to f b?
23:33:57 <mm_freak_> close
23:34:04 <mm_freak_> "f" means "functor", not "function"
23:34:37 * hackagebot stringable 0.1.2 - A Stringable type class, in the spirit of Foldable and Traversable  http://hackage.haskell.org/package/stringable-0.1.2 (JohnWiegley)
23:34:43 <mm_freak_> for example it takes a Maybe (a -> b) and turns it into a Maybe a -> Maybe b
23:34:59 <mm_freak_> in this case Maybe is the functor
23:35:11 <padrian> yes, but if you take out the context
23:35:25 <ski> > Just chr <*> Just 97
23:35:26 <lambdabot>   Just 'a'
23:35:51 <ski> in this case, the type of `(<*>)'
23:36:10 <ski> is `Maybe (Int -> Char) -> Maybe Int -> Maybe Char'
23:36:41 <ski> note that `Int -> Char' is not a function
23:36:47 <ski> it's a *type* of functions
23:37:18 <ski> (namely the type of functions taking values of type `Int' as inputs, and yielding values of type `Char' as outputs)
23:37:29 <padrian> Int -> Char mens that you could replace with a function? :(
23:37:40 <ski> so "a function inside another function (a -> b)" isn't quite right
23:37:48 <latro`a_> well, no; Nothing is of type Maybe (Int -> Char), among many other types
23:39:28 <ski>   (<*>) :: Maybe (Int -> Char) -> Maybe Int -> Maybe Char  -- means that `(<*>)' is a function that taken as input a "`Maybe' of" a function from `Int's to `Char's and (returns a new function taking as input) a `Maybe' of `Int', and returning as output a `Maybe' of `Char'
23:40:14 <ski> padrian : the thing to the right of the `::', the *type*, is not a value. it *describes* the (general) shape of values
23:40:44 <ski> in the case of functions, the "shape" means what kind of things it can take as input and what kind of things it can give as output
23:40:55 <padrian> (<*>) cuz a functor does not take 2 args?
23:41:06 <ski> i don't understand the question
23:41:31 <padrian> ski: yes, :: on right describe the *type*
23:42:14 <mm_freak_> padrian: you seem to confuse type level and value level
23:42:21 <mm_freak_> functors are on the type level
23:42:47 <mm_freak_> examples of functors:  Maybe, IO, STM, Either e, …
23:43:11 <mm_freak_> and a functor takes one argument, a type:  Maybe :: * -> *
23:43:31 <Walther> I have still close to no idea on how IO works in haskell
23:43:45 <mm_freak_> Walther: nobody knows how it works
23:43:57 <mm_freak_> if you know how it works, you're doing something wrong =)
23:43:57 <Walther> every example tends to focus on "remember to keep the io separate" and "keep the code pyre" etc
23:44:25 <Walther> but I haven't got a clue how I'd go about writing a simple number-guessing game
23:44:26 <ski> how it works is partly up to the OS
23:44:52 <Walther> you know, those that you write at third grade in python for the lulz of it
23:45:08 <mm_freak_> Walther: just write it
23:45:40 <mm_freak_> literally, don't think, just go ahead and write code
23:45:41 <padrian> mm_freak: type level like Int, Double and value level (is that a concrete value)?
23:46:10 <mm_freak_> padrian: values (like integers, strings, functions, etc). live on the value level
23:46:24 <mm_freak_> types (like Int, String, X -> Y, etc.) live on the type level
23:46:26 <Walther> Could you show me a oneliner example on lambdabot, taking an input and conparing it to predetermined value
23:46:33 <Walther> it doesn't have to evaluate
23:46:42 <mm_freak_> do x <- getLine; if x == y then … else …
23:46:42 <Walther> comparing*
23:46:49 <Walther> hmm
23:47:00 <ski> Walther : use e.g. `getLine' (or `readLn') to get a number guess, compare it with the actual hidden number, either print a message using `putStrLn' and start over again, or print that the user won, not starting over again ?
23:47:17 <mm_freak_> x is a string, you may want to 'read' it first
23:47:26 <padrian> mm_freak ok.. so the functor is just a type
23:47:26 <mm_freak_> if read x == y then … else …
23:47:41 <mm_freak_> padrian: exactly, and it is a type of kind * -> *
23:47:44 <mm_freak_> Int can't be a functor
23:47:44 <dmj`> IO is like the state monad
23:47:47 <dmj`> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
23:47:49 <Walther> or define secret randomint deriving show?
23:47:53 <ski> Walther : you can use `randomRIO' initially to generate a random number
23:48:02 <Cale> :t randomRIO
23:48:02 * Maxdamantus doesn't like that other things on the type level are called types.
23:48:02 <lambdabot> Random a => (a, a) -> IO a
23:48:31 <Walther> or would deriving show still require the int to be 'read'
23:48:38 <mm_freak_> Maxdamantus: we call everything on the value level a value, including functions =)
23:48:50 <Walther> ...probably, as it'd still be an int?
23:48:51 <Cale> Walther: hm?
23:48:52 <mm_freak_> by extension you would call everything on the type level a type, including functions
23:49:01 <padrian> mm_freak, ski: thanks!
23:49:02 <Maxdamantus> mm_freak_: yeah, but a "type" usually describes a class of values.
23:49:08 <ski> padrian : yes. some types are "numeric types", like `Int',`Float',`Integer',`Double',`Rational'
23:49:24 <Maxdamantus> mm_freak_: you don't have a level below value that you can make an analogue for.
23:49:34 <Cale> Walther: deriving Show is something which you add to the definition of a new datatype in order that the compiler write some code for you to turn values of that type into strings
23:49:36 <mm_freak_> Maxdamantus: in agda terms a type is a citizen of Set1
23:49:47 <mm_freak_> Set -> Set : Set1
23:49:53 <Walther> Cale: ah right, i'm making fruit salad again
23:49:57 <mm_freak_> uhm
23:49:59 <ski> padrian : there's a basic "type class" `Num' for the most basic numeric operations (and then there's more numeric type classes for more "advanced" numeric operations that not all numeric types support)
23:50:00 <mm_freak_> no, that's wrong
23:50:01 <Walther> (mixing apples and oranges, heh(
23:50:31 <ski> padrian : some types "belong" to the type class `Num', namely those that support the numeric operations described in that type class
23:50:37 <Cale> Walther: If you'd like, I could write you a small example guess-the-number game
23:50:52 <ski> padrian : similarly, a functor in Haskell is simply a type which supports the (sole) operation of the type class `Functor'
23:50:56 <Walther> thanks, but i'd probably prefer trying it on my own
23:51:20 <Walther> only way to learn haskell is to write it
23:51:26 <Cale> okay :)
23:51:39 <Walther> It's quite different from Python and Java
23:51:40 <mm_freak_> Maxdamantus: i understand your point, but i fail to see the distinction between a value function and a type function
23:51:45 <Walther> and I like it.
23:51:52 <Cale> Walther: have you seen http://www.haskell.org/haskellwiki/Introduction_to_IO
23:52:06 <ski> mm_freak_ : we commonly say "concete type" for a type which is inhabitable, i.e. which is capable of having values
23:52:09 <Walther> have read lyah abd skimmed through parts of rwh
23:52:10 <ski> er
23:52:11 <ski> Maxdamantus ^
23:52:20 <Maxdamantus> mm_freak_: the simplest description of kinds would probably be "the types of type-level entities"
23:52:24 <Walther> haven't actyally written much apart from toying with hakyll
23:52:44 <Maxdamantus> because they describe classes of type-level entities.
23:52:44 <dpwright> I am interfacing with the FFI, and I'd like to keep the "FFI" bits as limited as I can.  I have a function that expects to take a [CChar], so I'd like to convert from some Haskell format to that at the last minute
23:52:48 <Walther> thanks, will read the link
23:53:07 <mm_freak_> Maxdamantus: when ambiguous we have "type constructor" vs. "concrete type"
23:53:18 <mm_freak_> otherwise just saying "type" is fine
23:53:36 <ski> Walther : note that in Java syntax, `Maybe Int' would be written as `Maybe<Int>'
23:53:47 <Maxdamantus> But it takes away the meaning from "type" :(
23:53:58 <Maxdamantus> What type of thing is that?
23:53:59 <dpwright> what Haskell type should I be passing around?  ByteString looked good, but they might not be strings, and ByteString provides toCString type function which converts to a CString, which is expected to be NULL terminated
23:53:59 <ski> (what does ?)
23:54:06 <padrian> ski : thanks for your kindness and help
23:54:21 <ski> padrian : np
23:54:36 <dpwright> [Word8] or similar would probably do the job, but just wondering if there's a particular type that everyone uses for buffers of arbitrary data
23:54:37 <Maxdamantus> IO can't be a type of thing.
23:54:37 <mm_freak_> Maxdamantus: again, i understand your point…  a type should be a citizen of *
23:54:40 <Maxdamantus> anyway, afk
23:54:47 <mm_freak_> but "type constructor" is such a mouthful
23:54:57 <mm_freak_> saying "type" is convenient
23:55:26 <ski> also, `Either Int' clearly isn't a type constructor, no ?
23:55:38 <Maxdamantus> I'm sure someone could've thought of something concise earlier :p .. dunno
23:55:51 <ski> (at least not in any similar sense as in which `Left' is a data constructor)
