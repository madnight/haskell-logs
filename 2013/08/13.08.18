00:03:09 <maxiepoo> :t (uncurry (||) .) . (&&&)
00:03:09 <lambdabot>     Couldn't match type `(c0, c'0)' with `Bool'
00:03:09 <lambdabot>     Expected type: (Bool, c0) -> (Bool, c'0) -> (Bool, Bool)
00:03:09 <lambdabot>       Actual type: (Bool, c0) -> (Bool, c'0) -> (Bool, (c0, c'0))
00:04:18 <hpaste> dmj pasted “bitonic” at http://lpaste.net/91927
00:04:29 <dmj`> in log(n)
00:08:45 <dmj`> aw crap, length is O(n)
00:08:54 <arkeet> of course.
00:08:57 <arkeet> it's a linked list.
00:09:14 <dmj`> should I use vector instead?
00:09:20 <arkeet> for what?
00:09:27 <dmj`> binary search
00:09:37 <arkeet> maybe.
00:09:43 <arkeet> lists would be pretty bad for that.
00:10:31 <arkeet> but there are some pure functional data structures you could use too.
00:10:33 <arkeet> like Data.Sequence
00:12:47 <Taneb> Today I learn about memoization
00:12:51 <dmj`> finger trees, I've heard good things.
00:19:11 <dmj`> length :: Seq a -> Int
00:19:15 <dmj`> O(1). The number of elements in the sequence.
00:25:26 <johnw> finger trees must be related to palm trees somehow
00:26:04 <arkeet> =)
00:26:12 <arkeet> @quote johnw finger trees must be related to palm trees somehow
00:26:12 <lambdabot> No quotes match. Take a stress pill and think things over.
00:26:15 <arkeet> @remember johnw finger trees must be related to palm trees somehow
00:26:15 <lambdabot> It is stored.
00:33:03 <adas> what does the type `Stream s m Char => ParsecT s u m ()` mean? Does it mean `s` and `m` must be an instance of typeclass `Stream`?
00:33:43 <arkeet> Stream is a 3-parameter typeclass.
00:33:47 <Saizan> there has to be an instance for "Stream s m Char"
00:37:04 <adas> Saizan: you mean there has to be an instance for "Stream [Char] m Char"?
00:39:48 <Saizan> adas: i meant s, but you can take s = [Char] if you want
00:41:59 <Saizan> i said "has to be" in the "if you want to use a function of that type you have to provide such an instance" sense, not in the "parsec provides one" sense
00:43:30 <adas> ah ok. didn't realize you meant it that way. - }. got it now though
00:44:36 <jophish_> Yo yo yo
00:44:53 <jophish_> Is there a flag I can pass to ghc to get it to output a llvm bitcode module?
00:47:45 <jophish_> ah, never mind. ghc doesn't seem to like llvm head at the moment
00:49:45 <jophish_> -fllvm and -keep-llvm-files were what I was looking for.
01:19:15 <adas> im using Text.Parsec to parse an email address. For the prefix that comes before '@' i have `email=many1 alphaNum` and i can have `char '@'` for the `@` symbol. But is there a way to connect them both?
01:22:25 <Gracenotes> connect? do you know about applicative parsers? *>, <*, <*>, etc.
01:22:37 <Gracenotes> also, you could just use a regex, http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html
01:23:32 <jophish_> "pushes the limits of what it is sensible to do with regular expressions" hahaha
01:24:06 <adas> Gracenotes: i tried using *> but it only give me the end of the email id. Like if i tried parse email "" "xxx@yy.com" it only give me ".com"
01:24:20 <Gracenotes> also, can it go without saying you will never use such a parser in any kind of production environment?
01:24:23 <aloiscochard> dammed, this regular expression
01:24:48 <aloiscochard> must be quite cool if you have something to fix in this regexp
01:24:57 <Gracenotes> email addresses can contain punctuation, more than one @ sign, a hex-encoded IP address as a domain, and that's just the tip of the iceberg
01:25:25 <xunie-laptop> Oh wow.
01:25:32 <johnw> oh yeah, RFC822 is a head trip
01:25:37 <aloiscochard> it's like if I'm discovering today what a email address is
01:25:38 <johnw> oops, showing my age
01:25:39 <johnw> 2822
01:25:45 <xunie-laptop> I never knew that, Gracenotes. Thanks for giving me the Gracenotes' version of email addresses. :P
01:25:46 <shesek> aloiscochard, as he explains on that page, it is not maintained as-is
01:25:52 <shesek> its generated from a set of smaller regexes
01:25:54 <adas> Gracenotes: im not tryin to parse email using parsec so i can use it somewhere. Im just tryin to learn Parsec !
01:26:00 <Gracenotes> heh, sure
01:26:23 <aloiscochard> shesek: that's cheating!
01:26:24 <aloiscochard> ;-)
01:27:11 <shesek> heh, yeah, it would be much more hardcore if he wrote that by hand :P
01:27:20 <Gracenotes> adas: how does something like this seem: liftA2 (,) (many1 alphaNum *> char '@') (...domain bit...)
01:27:46 <mauke> http://mauke.hopto.org/stuff/perl/rfc822
01:27:56 <mauke> http://mauke.hopto.org/stuff/perl/rfc2822
01:29:16 <Gracenotes> it's also reasonable to break down parse expressions into e.g. let statements, to give them names but still let them compose
01:29:40 <Gracenotes> adas: er, sorry, I actually missed the point there, it's (many1 alphaNum <* char '@')
01:29:43 <Gracenotes> the other one
01:30:24 <Gracenotes> > (Just 3 <* Just "banana", Just 3 <* Nothing)
01:30:25 <lambdabot>   (Just 3,Nothing)
01:31:24 <johnw> now you've made me want a banana
01:33:44 <Gracenotes> @src (<*)
01:33:45 <lambdabot> (<*) = liftA2 const
01:34:48 <Gracenotes> also... although it's Applicative... in do notation it would be '\fa fb -> do { a <- fa; fb; return a }'
01:38:48 <Gracenotes> adas: there is a nice blog post, although it is out of date in the particulars, I think it is a nice overview of thinking about it. http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/
01:45:53 <adas> Gracenotes: thank for the link
02:07:17 <Cho0fool> Hello.
02:09:32 <isomorphic> I have an FFI function that is defined in terms of a pointer to a type with an empty data declaration.  Should I still be able to use the function?
02:09:33 <Cho0fool> How can i enable cabal "jobs" option?
02:10:08 <Cho0fool> I;ve just uncommented it but now i;m getting cabal: Command.optionToFieldDescr: feature not implemented
02:10:15 <Cho0fool> s/;/'/
02:11:38 <Cho0fool> cabal-install version 1.16.0.2
02:12:02 <Cho0fool> I guess jobs option does not implemented yet...
02:12:05 <Cho0fool> Is it true?
02:12:18 <johnw> just use -j on the command-line
02:12:23 <johnw> cabal install -j <foo>
02:12:45 <Cho0fool> johnw: Oh, thanks. But can i specify it via cabal config?
02:12:53 <johnw> that doesn't work with 1.16.0.2
02:12:59 <Cho0fool> Okay, got it,
02:22:13 <johnw> why isn't Map.unionWith typed as unionWith :: Ord k => (a -> a -> b) -> Map k a -> Map k a -> Map k b, instead of unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a?  The current type seems unnecessarily restrictive
02:22:24 <johnw> oh, wait, never mind
02:22:36 <elliott> what is the answer?
02:22:45 <johnw> well, I was thinking that it prevents unionWith (,)
02:22:50 <johnw> but then I realize that some keys are unique to each map
02:22:58 <elliott> oh, right.
02:23:01 <johnw> and (a -> a -> a) is the only way to always have an answer then
02:29:08 <elliott> johnw: what you want is Align.
02:29:41 <elliott> oh. you literally uploaded the these package. you should know this :P
02:29:49 <johnw> haha
02:30:05 <johnw> i didn't write it, I just fixed it at one point
02:30:15 <elliott> http://hackage.haskell.org/packages/archive/these/0.3/doc/html/Data-Align.html has a Map instance
02:30:24 <elliott> and alignWith correponds to unionWith
02:30:33 <johnw> that's great, thanks elliott!
02:30:38 <johnw> i always wondered when these might be useful
02:31:10 <elliott> :)
02:33:01 <elliott> hm, does Data.Map have something like malign?
02:33:04 <elliott> = unionWith mappend
02:33:10 <elliott> I guess it's just unionWith mappend.
02:33:28 <johnw> yeah, but i have a weird case
02:33:41 <johnw> my bin-op is either "pick right" or "drop from map"
02:34:08 <johnw> so I'm going to map the incoming maps to Just x, then unionWith a function that can produce Nothing, and then fold the map to drop all the Nothings
02:34:27 <johnw> i.e.: https://gist.github.com/6260766
02:34:33 <elliott> also, you should figure out proper Unalign laws and more instances for it.
02:34:33 <johnw> can these make that simpler I wonder?
02:35:33 <johnw> yeah, alignWith is pretty perfect, except I don't want a map of the same shape as a result, but maybe it will save me from having to map Just around my contents
02:36:47 <elliott> the Align Map instance has to be partial :(
02:36:55 <elliott> (it uses unionWith and a map, like your code)
02:37:03 <johnw> is there a nub for Map k (Maybe a)?
02:37:09 <elliott> Map should provide something like alignWith.
02:37:13 <elliott> hmm
02:37:15 <johnw> i want an applicative catMaybess...
02:37:33 <johnw> catMaybesM :: f (Maybe a) -> f a
02:37:35 <elliott> johnw: f (Maybe a) -> f a is given to you by Align, I think.
02:37:38 <elliott> you can't do it with Applicative.
02:38:00 <elliott> hmm, or maybe not.
02:38:05 <elliott> rwbarton would know.
02:38:07 <johnw> feels like it should though
02:38:25 <elliott> oh
02:38:34 <johnw> mapMaybe
02:38:39 <elliott> \f -> alignWith f (nil :: f Void)
02:38:49 <elliott> :: (These Void a -> b) -> f a -> f b
02:38:57 <elliott> data These Void a = This Void | That a | These Void a
02:39:02 <johnw> interesting!
02:39:03 <elliott> ~ Either Void a
02:39:09 <elliott> ~ a
02:39:12 <elliott> uh.
02:39:19 <elliott> wait, what am I saying.
02:39:37 <elliott> okay, I'm too tired to work this out.
02:39:53 <MrRacoon> sounds like Either
02:40:25 <elliott> I wonder how easy it is to hack on GHC from Windows. I guess spj does it.
02:43:50 <johnw> elliott: very nice: https://gist.github.com/6260796
02:44:09 <elliott> (f .) . g makes me sad. :(
02:44:16 <johnw> why is that?
02:44:16 <elliott> I bet that's slower, also.
02:44:19 <elliott> it does two passes.
02:44:21 <elliott> Map is spine-strict.
02:44:36 <johnw> hmm
02:44:52 <johnw> how come you dislike (f .) . g?
02:45:05 <johnw> do you like .:, or do you just go for points at that point?
02:45:56 <elliott> it's ugly. I also dislike (.:), but I don't know if I have a particularly good reason to. you can write it as (result.result) f g or (fmap.fmap) f g, that way I'll just think you're Conal :p
02:46:05 <elliott> people can write whatever they want, though.
02:46:19 <johnw> i use (f .) . g enough now that it reads as easily as anything else
02:46:40 <elliott> how about (g & mapped.mapped %~ f).
02:46:43 <johnw> so, how would you avoid the double pass?
02:46:52 <elliott> the way you originally wrote it, without alignWith
02:47:06 <johnw> oh, you mean just using all Map code?
02:47:09 <elliott> hmm, maybe this is fewer passes since you avoid mapping the values?
02:47:17 <elliott> no, wait, you don't.
02:47:18 <elliott> since alignWith does
02:48:09 <elliott> I think Align should have mapMaybe if it doesn't already imply having mapMaybe.
02:48:09 <johnw> so, mapMaybe id $ unionWith f (Map Just x  (Map Just y) would be quicker?
02:48:30 <elliott> oh, I see.
02:48:35 <elliott> ok, alignWith is probably as good as it gets.
02:48:48 <elliott> without getting at Map's constructors
02:49:14 <elliott> strictness makes APIs necessarily either inefficient or larger and less compositional, news at 11
02:53:45 <johnw> elliott: agcreed
03:09:35 <johnw> elliott: I'd need (Foldable f, Unfoldable f) to generalize catMaybes, I think
03:09:43 <johnw> or Buildable, or whatever it should be
03:09:48 <Rarrikins> Why would the following happen? Not in scope: `ys'; Perhaps you meant one of these: `xs' (line 19), `ys' (line 20), `zs' (line 20)
03:09:57 <johnw> because Foldable gives me toList, but I need a class that gives fromList
03:10:05 <johnw> then I can implement as fromList . catMaybes . toList
03:10:47 <elliott> it should be its own typeclass
03:10:56 <hpaste> Kaini pasted “Unhappy with fn” at http://lpaste.net/91928
03:11:13 <elliott> class Functor f => MaybeFunctor f where mapMaybe :: (a -> Maybe b) -> f a -> f b
03:11:19 <johnw> right, like in https://www.fpcomplete.com/user/gbaz/building-up-to-a-point-via-adjunctions
03:11:22 <elliott> since it's just a functor from the kleisli category of Maybe blah blah blah
03:11:40 <elliott> and then that gives you catMaybes.
03:11:48 <elliott> (interdefinable)
03:11:51 <Taneb> Can't you do it with Alternative?
03:12:03 <Kaini> Is there a more elegant way to express fn? Especially using "sequence  mapM" and ((,) key )  feels wrong.
03:12:10 <Taneb> No wait, you need MonadPlus :/
03:12:12 <Kaini> http://lpaste.net/91928
03:12:29 * elliott dislikes the toList view of Foldable
03:12:40 <elliott> the foldMap view is so much more beautiful.
03:12:51 <Kaini> Ok, i need another IRC client, that doesn't cut < $ > ...
03:13:48 <johnw> haha
03:13:53 <johnw> that's definitely an unfriendly #haskell client
03:15:13 <elliott> hmm, Buildable makes me a little sad.
03:15:14 <elliott> too ordered.
03:16:23 <johnw> ordered?
03:17:08 <elliott> yes. it has the biased structure of a list
03:17:16 <johnw> ah
03:17:16 <elliott> compared to foldMap which is beautiful on trees
03:17:22 <johnw> good point
03:18:33 <elliott> maybe something like soEasy :: Buildable f => (forall b. (b -> b -> b) -> b -> (a -> b) -> b) -> f a
03:18:44 <elliott> equivalently, soEasy :: Buildable f => (forall b. Monoid b => (a -> b) -> b) -> f a
03:19:14 <elliott> the relationship to foldMap :: (Foldable f, Monoid b) => (a -> b) -> f a -> b is clear.
03:19:29 <elliott> in fact, you can recast foldMap as
03:19:56 <elliott> soHard :: Foldable f => f a -> (forall b. Monoid b => (a -> b) -> b)
03:20:11 <elliott> soEasy :: Buildable f => (forall b. Monoid b => (a -> b) -> b) -> f a
03:20:38 <elliott> it still supports fromList
03:21:03 <elliott> fromList xs = soEasy (\inj -> foldr (mappend . inj) mempty) xs)
03:21:22 <elliott> soEasy f = fromList . f pure
03:21:32 <elliott> hmm, this is nice.
03:21:57 <johnw> foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
03:22:02 <johnw> isn't that the same as soHard?
03:22:10 <elliott> yes, but I flipped the argument
03:22:14 <johnw> ah, ok
03:22:17 <elliott> to make it obvious that it and soEasy are precisely dual
03:22:23 <johnw> right
03:22:27 <johnw> code it!  upload it!
03:22:43 <johnw> or I'll upload it for you, clearly I do that :)
03:23:15 <elliott> well, unfortunately you lose the obvious connection to foldr/build fusion.
03:23:21 <elliott> but maybe this is nice in other ways.
03:25:14 <elliott> johnw: also, re the NonEmpty thing at the end of the article, that becomes the fact that some "f"s only work with Semigroup, not Monoid.
03:25:25 <elliott> I wonder if the article author uses IRC.
03:27:34 <johnw> i can't remember whether I'm the manitainer of these now or not...
03:35:04 <Rarrikins> > let f _ = do { yz <- Nothing; f ys } in 5
03:35:05 <lambdabot>   Not in scope: `ys'
03:35:05 <lambdabot>  Perhaps you meant one of these:
03:35:05 <lambdabot>    `yz' (line 1), `y' (...
03:45:47 * tabemann wacht auf
03:45:57 <johnw> jetzt?
03:46:03 <tabemann> ja
03:46:08 <johnw> guten morgen
03:46:52 <johnw> ich muss jetzt schlafen, weil es ganz frӱh ist hier
03:47:06 <tabemann> slept way too much yesterday, so now naturally can't sleep, and don't have anything better to do than to work on my Scheme (having spent the last week working way too much on various benchmarky thingies)
03:47:57 <johnw> oh yeah, you were looking at core loop unrolling and such
03:48:41 <tabemann> I was primarily looking at interthread communication speed in different languages and environments and such
03:49:22 <johnw> what was the final consensus?
03:50:02 <tabemann> that Haskell, with all threads limited to one capability and using MVars is really, really fast, and C, with pthreads, as expected is really, really slow
03:50:50 <tabemann> I did notice that even with all threads limited to one capability, using TMVars resulted in an order of magnitude slower switching than with MVars on one capability
03:51:17 <johnw> isn't C with pthreads "one-thread-per-OS-thread"?
03:51:23 <tabemann> yes
03:51:47 <johnw> and did your switching test involve lots of contention for one resource?
03:51:55 <tabemann> yes
03:52:05 <johnw> yeah, that's pretty much worst-case-scenario for STM
03:53:02 <Russel-Athletic> hiho, i am kind of confused what gui libraries exists and work, i tried gtk but this doesn't support gtk3 glade files, qthaskell doesn't seem to be maintained anymore and wxhaskell doesn't have a gui builder
03:53:30 <aloiscochard> tabemann: what do you mean by one capability?
03:53:35 <tabemann> note that in *Java* on Windows using BlockingQueues only gained 3 us over using TxnQueues (with one entry) in Multiverse STM (specifically ~5 us and ~8 us respectively)
03:54:16 <tabemann> aloiscochard: "capabilities" in GHC Haskell mean OS threads that are currently running Haskell code
03:54:32 <aloiscochard> tabemann: I see, ty
03:54:44 <tabemann> note that there may be more OS threads than capabilities in GHC Haskell, but those other OS threads are running non-Haskell code
03:55:07 <aloiscochard> the thing is that os thread are quite expensive compared to haskell light thread, right?
03:55:17 <Russel-Athletic> so what gui library is generally used?
03:55:21 <tabemann> much, much more expensive
03:55:32 <Yaniel> aren't OS threads always
03:55:33 <tabemann> wait
03:55:42 <tabemann> "capabilities" don't count "bound threads"
03:55:57 <johnw> tabemann: and you know that the "main" thread is always bound, right?
03:56:01 <tabemann> which are OS threads that only execute a single Haskell thread
03:56:12 <aloiscochard> very interesting
03:56:15 <tabemann> johnw: now I do, which was something I actually ran into when doing my tests
03:56:28 <johnw> that can have performance considerations
03:56:31 <aloiscochard> was wondering the impact of using TMVar vs MVar yesterday, I'm happy to get the info now ;-)
03:56:45 <johnw> aloiscochard: don't take that as the final word on performance of those two
03:56:52 <tabemann> or rather "bound threads" are Haskell threads which only run in their own OS thread (but which can also run non-Haskell code)
03:56:56 <johnw> he's testing against worst-case STM behavior
03:57:04 <tabemann> yeah, don't rely on this
03:57:14 <aloiscochard> johnw: ok, I see. I should test with my concrete use case.
03:57:19 <tabemann> for anything where one wants to do more than one "synchronized" thing at once, use STM
03:57:28 <johnw> if you don't expect contention, STM can win
03:57:53 <johnw> plus, STM enforces more sanity
03:58:21 <aloiscochard> johnw, tabemann : let's say I write a network server, I want request to be put in a queue by a master thread, and then the queue processed by multipe workers. STM sounds like a good fit, right?
03:58:27 <tabemann> STM can easily have better performance than coarse-grained locking... while simultaneously is not nearly as bug-prone as fine-grained locking
03:59:10 <johnw> aloiscochard: in that case I might use MVar if you are going to have *lots* of short-lived threads, owing to the fairness guarantee and the high contention on the shared queue structure
03:59:52 <tabemann> but if you're also having those threads simultaneously synchronizing on other resources, then STM might be a good choice
03:59:54 <johnw> my rule of thumb is: code it all in STM, test performance, switch to MVar where it matters
04:00:19 <johnw> tabemann: true, if you are doing anything that introduces a complex scenario, STM is a huge logical win
04:00:34 <tabemann> remember, MVars don't have `orElse` and can't be locked simultaneously
04:00:39 <johnw> *if* MVar even buys you anything
04:00:43 <aloiscochard> johnw: I see, make sense. thanks for the tips!
04:01:12 <johnw> and orElse = <|> for STM, which is quite handy
04:02:07 <johnw> aloiscochard: STM will also force more discipline on you, so that when you switch parts to MVar (if you even can), the code will already be in good form
04:02:51 <tabemann> anywhere where you find yourself having to use multiple locking resources in a nested fashion, be they MVars or Chans or like, consider using STM
04:02:58 <johnw> plus, retry is just too magical not to use sometimes :)
04:03:36 <johnw> whenever I use it, it feels like hand-waving.  "Hey computer, just make all this work and be efficient, mmk?"
04:04:05 <aloiscochard> johnw: ok, so it's sounds like it's really a good idea to always start with STM, and once you optimize switch some part to MVar
04:04:13 <tabemann> (for my ThreadGroups that I implemented recently I did decide to go with nested MVars... but that was over something where there would both be heavy contention *and* I could firmly guarantee lock ordering...)
04:04:23 <johnw> aloiscochard: that works for me, it's just very good to know when and why to switch
04:04:31 <johnw> Marlow's book on Concurrency and Parallelism is a great resource
04:04:41 <tabemann> the one thing is that you can't mix STM and MVars, as MVars need to be in the IO monad
04:04:41 * aloiscochard add it to read later!
04:05:21 <aloiscochard> oh interesting tabemann, so you can't really have half/half design
04:05:25 <Jeanne-Kamikaze> just ordered it yesterday \o/
04:05:30 <johnw> aloiscochard: not fully true
04:05:35 <johnw> I mix STM and MVars
04:05:39 <johnw> you just can't interleave them really
04:05:50 <aloiscochard> ok, that will make sense once I face the case
04:05:53 <johnw> like, you can't touch an MVar _within_ an STM block
04:05:59 <aloiscochard> I see
04:06:02 <johnw> but you can use STM within a modifyMVar
04:06:31 * tabemann forgot that you could use STM within modifyMVar there
04:07:16 <tabemann> one thing about STM that MVars don't give you is safety w.r.t. consistency in the face of exceptions
04:07:23 <johnw> the other thing with MVar is that unless you use modifyMVar almost always, you have to be very careful about async exceptions
04:07:31 <johnw> with STM, that is pretty much a non-issue
04:07:51 <johnw> haha
04:07:59 <johnw> i wrote that before I read what you said, tabemann
04:08:12 <johnw> I see we've probably faced similar issues :)
04:09:03 <tabemann> I haven't actually run into that much in Haskell, but have done a lot of multithreaded code in C++...
04:09:06 <johnw> aloiscochard: and most definitely, check out Marlow's async library.  it's gorgeous
04:09:41 <aloiscochard> johnw: sure, I discovered it few days ago, while naively looking for a Future implementation in haskell :-)
04:09:48 <johnw> with STM, async, and a TBQueue (STM bounded channel), there's almost nowhere you can't go! :)
04:10:08 <johnw> aloiscochard: yep, async would be the ticket for that
04:10:19 <johnw> he describes it in depth in his book too
04:10:34 <johnw> one of the best things about async is its attention to exception safety
04:10:39 <aloiscochard> it's very different from the approach taken by scala and the akka thing, so it took me a bit of time to see how to design concurrent app with haskell
04:10:40 <tabemann> part of his book is basically constructing Async from the underlying primitives
04:10:48 <_arjun> hi
04:11:04 <johnw> aloiscochard: Haskell has Cloud Haskell (aka distributed-process), if you are looking rfo something akin to Akka
04:11:22 <aloiscochard> in fact, it's bit like the "old style" but as you have pure function and effect tracking... that thread style is very nice to use
04:11:23 <_arjun> i was reading a book, where author wrote a factorial function like this
04:11:32 <_arjun> factorial :: (Integral a) => a -> a factorial 0 = 1 factorial n = n * factorial (n - 1)
04:11:46 <aloiscochard> johnw: yep I've seen a SPJ talk about it, but as I need only concurrency on single node, i want to learn the traditional haskell way of doing
04:11:52 <_arjun> why he didn't write like this
04:12:03 <_arjun> factorial :: Int->Int factorial 0 = 1 factorial n = n * factorial (n - 1)
04:12:04 <aloiscochard> johnw: I've seen there is an in-memory impl of haskell cloud though
04:12:21 <arkeet> _arjun: because the former is more general.
04:12:23 <johnw> yes, you can use cloud haskell for in-node actors
04:12:33 <arkeet> it can be used with other instances of Integral, such as Integer, Word32, etc.
04:12:51 <arkeet> _arjun: you should learn about type classes =)
04:12:57 <_arjun> arkeet: so Integral is a class
04:12:59 <arkeet> yes
04:13:22 <_arjun> arkeet: thanks :)
04:13:32 <tabemann> especially if you're using factorial you don't want to limit the user to using Int, because in many cases they really *would* want to use Integer
04:13:58 <_arjun> tabemann: k
04:14:08 <tabemann> due to Int having just too small of a range for many factorials, even on 64-bit
04:14:21 <johnw> _arjun: the Integral version gives you factorial that works for anything "integer-like", or Integral
04:14:44 <johnw> you get the Int -> Int version just by passing in an Int
04:15:10 <arkeet> @let factorial 0 = 1; factorial n = n * factorial (n - 1)
04:15:10 <arkeet> hello lambdabot.
04:15:10 <arkeet> :t factorial
04:15:10 <arkeet> > factorial 30 :: Int
04:15:11 <lambdabot> Not in scope: `factorial'
04:15:11 <lambdabot>  Defined.
04:15:11 <lambdabot>   Not in scope: `factorial'
04:15:11 <arkeet> > factorial 30 :: Integer
04:15:17 <lambdabot>   265252859812191058636308480000000
04:15:27 <arkeet> > factorial 30 :: Int
04:15:31 <lambdabot>   1409286144
04:15:34 <arkeet> :t factorial
04:15:35 <lambdabot> (Eq a, Num a) => a -> a
04:21:58 <kuribas> Is hackage also for experimental packages, or only for finished packages?
04:22:17 <johnw> kuribas: it's really up to you, there are no controls
04:22:38 <johnw> but if you're really working with bleeding edge stuff, GitHub might be easier on everyone
04:22:52 <donri> kuribas: you can document the stability in the cabal file
04:22:59 <donri> stability: freeform
04:22:59 <donri>     The stability level of the package, e.g. alpha, experimental, provisional, stable.
04:23:14 <osa1> can anyone help me compiling this simple persist app http://lpaste.net/91930 ?
04:23:28 <kuribas> donri: What is in development, and far from complete?  alpha?
04:23:53 <tabemann> the main thing about "stability" is that I've seen stuff that is probably more heavily used but which is still marked as "experimental", so to differentiate between that and stuff which really is experimental...
04:24:29 <johnw> osa1: it looks like you need to derive a persist field intsance for ZonedTime
04:24:31 <donri> kuribas: but not much to gain from putting it on hackage if it's not needed for distribution
04:24:42 <osa1> johnw: it's already derived here http://hackage.haskell.org/packages/archive/persistent/1.2.3.0/doc/html/Database-Persist-Sql.html
04:25:07 <johnw> huh
04:25:13 <osa1> importing that doesn't change anything
04:25:25 <johnw> import Database.Persist.Sql doesn't help?
04:25:26 <kuribas> donri: It might already be useful, if you are willing to use an unstable API.
04:25:46 <osa1> johnw: nope
04:26:02 <johnw> wow, you've got me stumped on that one
04:26:13 <johnw> i wonder if it's because "update" is a function in persistent
04:26:16 <johnw> try another name
04:26:20 <johnw> no, that wouldn't eb it
04:26:25 <donri> kuribas: then sure, alpha perhaps. it's freeform though, you can put anything there
04:26:26 <johnw> it's going to turn into entryUpdate
04:26:33 <osa1> yeah
04:26:39 <donri> stability: don't let your grandma use this
04:28:01 <johnw> you've got me!
04:28:09 <johnw> i'd love to know the answer when you find it
04:28:17 <osa1> not sure where to ask
04:28:20 <johnw> one sec
04:28:24 <osa1> I asked same question 2 days ago and got no answers
04:28:50 <kuribas> I want to make a haskell implementation of metafont that produces outlines instead of bitmaps.
04:29:24 <johnw> btw, importing Data.Time.Clock should be redundant there
04:29:31 <johnw> Data.Time brings it all in
04:29:47 <kuribas> And a graphical UI where you can manipulate variables interactively.
04:29:48 <osa1> ok
04:29:58 <johnw> what if you imported ZonedTime(..)?
04:30:48 <S_J> does anyone know how to exit GLUT properly? there is leaveMainLoop but can I bind as a callback to soemthing like onExit?
04:31:00 <kuribas> My hope is that if I have implemented the hard math stuff, I could get some contributors to help.
04:31:30 <osa1> same
04:32:02 <johnw> osa1: ask here: https://groups.google.com/forum/#!forum/yesodweb
04:32:21 <johnw> someone should know the answer there
04:33:35 <byorgey> kuribas: you should come hang out in #diagrams, you will find many interested people there =)
04:34:34 <S_J> kuribas: what are you doing?
04:35:08 <arkeet> <kuribas> I want to make a haskell implementation of metafont that produces outlines instead of bitmaps.
04:35:59 <osa1> johnw: asked, waiting for my message to get approved
04:36:37 <kuribas> byorgey: Ok :)
04:44:23 <madjestic> is there a general consensus on whether a ghc-mode's REPL or haskell-process-load-file REPL should be used?  The functionality seems the same on the surface with the biggest difference ghc-mode REPL having a shortkey to start, while the latter needs a M-x process
04:44:30 <madjestic> (emacs)
04:46:05 <hpc> madjestic: my opinion on the matter is to do screen, C-|, then open vim in one and ghci in the other
04:46:08 <hpc> ;)
04:47:14 <madjestic> hpc: I've been using vim for about 8 months and trying to learn emacs-way now.  But thanks for the input anyways
04:47:14 <hpc> (more to the point, if either of those modes offers a persistent split-screen of text editing and ghci, i would approve of it)
04:49:17 <madjestic> hpc: splitting a screen is not an issue: xmonad + vim is doing the job all-right
04:49:40 <madjestic> but my current goal is to get an afficient emacs set up
04:51:09 <qjin> If you've been using vim for 8 months, you may want to try EVIL: http://www.emacswiki.org/emacs/Evil
04:51:43 <xunie-laptop> Speaking of terminals. I've been staring at this wallpaper with xeyes under my terminal for DAYS now: http://i.imgur.com/38WDbYO.png
04:54:53 <S_J> Does it hold to say that a flat program design is geenrally better than a hierarchial one? (Maybe in here that will always be answered YES and in #java NO)
04:56:04 <hpc> S_J: my rule is write code that looks like what it does
04:56:21 <hpc> if your problem is extremely heirarchical, you would be silly to write a flat program
04:56:23 <donri> i put a monad in your monad so you can join while you join. haskell is not 'flat' ;)
04:56:31 <hpc> also that
05:22:55 * hackagebot hspec-test-framework 0.0.0 - Run test-framework tests with Hspec  http://hackage.haskell.org/package/hspec-test-framework-0.0.0 (SimonHengel)
05:23:16 <akegalj> i installed vim2hs. When editing .hs file in vim and ":syntax on" i get http://lpaste.net/90908
05:23:51 <osfameron> there are vim extensions to do SLIME like passing text into another window, using screen or (perhaps even better) tmux
05:27:55 * hackagebot hspec-test-framework-th 0.0.0 - Run test-framework tests with Hspec  http://hackage.haskell.org/package/hspec-test-framework-th-0.0.0 (SimonHengel)
05:27:55 <S_J> user error (unknown GLUT call glutCloseFunc, check for freeglut)
05:30:29 <S_J> anyone use GLUT on windows?
05:32:22 <DMcGill> are you using freeglut or the proprietary verion? They have different features
05:32:36 <S_J> proprietary
05:32:54 <S_J> And I need to close it.
05:32:55 * hackagebot hspec-meta 1.7.0 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.7.0 (SimonHengel)
05:32:57 * hackagebot querystring-pickle 0.1.0 - Picklers for de/serialising Generic data types to and from query strings  http://hackage.haskell.org/package/querystring-pickle-0.1.0 (BrendanHay)
05:33:14 <S_J> (I assume I use proprietary since it tells me to check for freeglut)
05:33:31 <DMcGill> probably the easiest thing would be to switch to freeglut
05:33:53 <DMcGill> if that's not an option, then you need to change your framework/functions you call in order to not try and use freeglut's features
05:34:41 <S_J> well to switch to freeglut how would I do?
05:34:48 <M-ou-se> what would be a good way to get the (decimal) digits of an integer in an list? (109 -> [1,0,9]) I now have "map (read . (:[])) $ show 109 :: [Int]", which works. I was wondering if there is an easier/better/more elegant way
05:34:48 <S_J> switch DLL:s?
05:35:57 <DMcGill> S_J: I'm pretty sure that's all it would take. It might affect your licence somehow too, I've no idea on that side of things.
05:36:25 <DMcGill> M-ou-se: do you mind saying why you're trying to get them? There might be an easier way.
05:36:42 <applicative> kuribas: i just looked up about metafont; amusingly the wikipedia objects to their demo "This image was uploaded in a raster graphics format such as PNG, GIF, or JPEG. However, it contains information that could be stored more efficiently and/or accurately in the SVG format, as a vector graphic. If possible, please upload an SVG version of this image."
05:37:17 <applicative> i suppose this sort of complaint isn't so strong against an actual font
05:37:55 * hackagebot hexpat-pickle-generic 0.1.0 - Picklers for de/serialising Generic data types to and from XML  http://hackage.haskell.org/package/hexpat-pickle-generic-0.1.0 (BrendanHay)
05:37:57 <M-ou-se> DMcGill: a math/programming 'assignment'/challenge. counting the number of integers in a range for which the product of the decimal digits is a given number.
05:38:24 <kuribas> applicative: yes, exactly.
05:39:25 <kuribas> applicative: The current solution is to run an outline approximation on the bitmaps, but they do a poor job.
05:40:13 <jophish_> Yo yo yo.
05:40:29 <applicative> I see, this objection to metafont in particular is is common?
05:40:40 <applicative> yo jophish_
05:41:02 <jophish_> I'm a big fan of clang-format for c++ code formatting. In general, for any input where the tokens output from the lexer are the same, it will generate the same output string. Is there a tool similar to this for Haskell?
05:41:17 <jophish_> in short I'm looking for a code formatter
05:41:26 <DMcGill> M-ou-se: haskell wiki has an example of:
05:41:29 <jophish_> stylish-haskell doesn't seem to quite do everything
05:41:30 <DMcGill> :t map Char.digitToInt . show
05:41:30 <lambdabot> Couldn't find qualified module.
05:41:37 <DMcGill> :t map digitToInt . show
05:41:38 <lambdabot> Show a => a -> [Int]
05:41:49 <kuribas> applicative: yes
05:41:50 <DMcGill> where digitToInt is in Data.Char
05:42:04 <applicative> jophish_: you want to feed ugly haskell in and get sparkling haskell out?
05:42:16 <jophish_> applicative: pretty much.
05:42:24 <hpc> has anyone else been having trouble with this bug? http://ghc.haskell.org/trac/ghc/ticket/3231
05:42:28 <kuribas> applicative: I think no commercial fonts are made with metafont.
05:42:32 <DMcGill> :t map (product . map digitToInt . show)
05:42:32 <lambdabot> Show a => [a] -> [Int]
05:42:39 <jophish_> the master plan is to use this with git filter, to make sure that the repo is always in a consistent fashion
05:42:42 <M-ou-se> DMcGill: thanks
05:42:54 <hpc> i am testing one of my packages on windows and keep hitting "*** Exception: terminateProcess: permission denied (Permission denied)"
05:43:21 <DMcGill> but I think you can be a little more clever about this: filtering odd and even numbers for example will drastically reduce your search space
05:44:33 <applicative> jophish_: I remember this coming up before a long time ago -- no doubt it has many times -- and people getting very defensive ... but maybe there's somethign now; haskell-src-exts has a lot of the material
05:57:55 * hackagebot cpphs 1.17.1 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.17.1 (MalcolmWallace)
05:59:53 <applicative> jophish_: here is a more radical plan https://github.com/Peaker/lamdu
06:15:24 <wojtekM_> Hello, list. I am a newbie and I have a question.
06:16:10 <Cho0fool_> Any Yesod experts around? Asked same question in #yesod but no dice with answer:
06:16:13 <Cho0fool_> What yesod executes as main function while in devel mode?
06:16:17 <Cho0fool_> It's certainly not app/main.hs.
06:16:33 <Cho0fool_> (I mean scaffolded yesod site.)
06:17:31 <wojtekM_> Data.Concurrent.Chan. Would it make sense to have separate ReadEnd and WriteEnd? Then, compiler could ensure that a given thread reads, writes, or both?
06:19:40 <wojtekM_> readChan and writeChan each touch only one end.
06:21:11 <donri> wojtekM_: the "both" case might get a bit more complicated, but i don't see why it wouldn't be possible
06:21:40 <wojtekM_> For both one could pass the whole channel
06:21:45 <S_J> Do I need mingw for FREEGLUT?
06:22:12 <donri> wojtekM_: wait, which package is this? i thought you meant Control.Concurrent
06:22:31 <wojtekM_> Yes, Control.Concurrent.Chan
06:22:36 <hpaste> ghorn pasted “variadic function in monad question” at http://lpaste.net/91933
06:23:12 <donri> wojtekM_: ok then i'm not sure what you're asking :)
06:23:20 <ghorn__> i know why this ^ doesn't work, but I don't see the right way to do it
06:23:36 <ghorn__> it's about variadic functions
06:24:14 <countoren> hello
06:24:49 <wojtekM_> I would like to have a channel that is composed of two ends. I would pass ReadEnd to threads that are supposed to read, WriteEnd to threads that are supposed to write, BothEnds to threads that would read and write.
06:25:59 <donri> ghorn__: you could put a functional dependency on a -> b in the class
06:26:30 <ghorn__> wojtekM_: you could make a channel and only pass a function which reads or writes to/from that channel, instead of the channel itself
06:26:48 <hpaste> donri annotated “variadic function in monad question” with “something like this” at http://lpaste.net/91933#a91934
06:26:53 <donri> not tested
06:27:40 <countoren> i know it might not be pure haskell , but im trying to load lushtags and tagbar with ctags to my vim in order to read my haskell code . but in the tag bar i get only functions of this file and i cannot jump to external functions . im not sure what im doing wrong
06:28:06 <donri> countoren: lushtags doesn't do external tags
06:28:13 <countoren> o
06:28:15 <donri> countoren: use hasktags for that
06:28:27 <donri> countoren: vim2hs can do it for you
06:28:37 <countoren> have link?
06:29:09 <S_J> is freeglut not for windows?
06:29:35 <donri> countoren: https://github.com/dag/vim2hs/blob/master/doc/vim2hs.txt#L143
06:29:51 <countoren> thanks man
06:29:54 <countoren> ill check it out
06:30:05 <countoren> btw
06:30:13 <ghorn__> donri: is it possible to make it infer both ways, so I could put a signature on either the right or left?
06:30:18 <countoren> i have haskell mode for vim installed
06:30:26 <countoren> i guess i wont need it
06:30:32 <donri> ghorn__: that would be ambiguous in your case
06:31:01 <donri> ghorn__: b ~ Int can be either a ~ Int or a ~ Blah ()
06:31:21 <wojtekM_> Haskell almigty! Thanks. Now it seems obvious.
06:33:06 <donri> ghorn__: otherwise i think you could do "a -> b, b -> a" or use type families instead of MPTCs
06:34:30 <donri> countoren: the vim haskell-mode is sort of old and not that great, other addons do the same better and are maintained
06:34:47 <joe9> I am using emacs to write haskell code. but, am not able to figure out where I can see the messages from the inferior ghc process. I see the code with warnings turn color to pink.
06:34:53 <joe9> but, am not able to figure out why.
06:35:43 <donri> countoren: i recommend neco-ghc, vim-hdevtools and syntastic with hdevtools
06:37:04 <donri> countoren: (and vim2hs, until i've published the rewrite ;))
06:43:35 <merijn> wojtekM_: The luxury of first class IO ;)
06:44:57 <hpaste> kryft pasted “Newbie parsec trouble” at http://lpaste.net/91935
06:45:33 <wojtekM_> I aready discovered System.Timeout earlier today.
06:45:59 <kryft> Parsec question: shouldn't "lookahead nameLineStart" fail on the line that begins with "# N: serial number"?
06:47:09 <kryft> (See my paste above)
06:47:52 <wojtekM_> Please allow another question. Is it possible to attempt reading from more then one channel, with timeout, without polling?
06:50:38 <ghorn__> is only purpose of the timeout to handle multiple channels?
06:51:11 <ghorn__> if so, you could spawn one thread per channel and have them all make blocking reads on their channels
06:52:57 <donri> the async package might make that easy
06:53:49 <donri> uh maybe not timeout. it makes "racing" easy (cancel losers)
06:54:21 <merijn> wojtekM_: Yes, but not with standard Chan
06:54:37 <merijn> wojtekM_: You will want Control.Concurrent.STM.TChan (transactional channel)
06:54:40 <kryft> The 'junk' parser is specifically intended to skip that line because nameLineStart should fail there, but apparently it succeeds. Oh hmm, does it have something to do with 'lookahead nameLineStart' not consuming any input?
06:54:55 <donri> kryft: manyTill is zero or more, not one or more
06:55:56 <merijn> wojtekM_: STM has orElse which will first try the first action and if that retries, it will try the second, if both retry it will retry everything. However the STM implementation is smart so it won't *actually* retry the transaction unless one of the STM variables used in it has changed since the last time
06:56:23 <merijn> wojtekM_: So you'd do like "readTChan chan1 `orElse` readTChan chan2" and it would just return whichever returned first
06:58:52 <applicative> wojtekM_: I take it you've seen s. marlow's new book on concurrent haskell?
06:59:11 <kryft> donri: Hmm, how does that cause the problem? The end parser should still succeed for manyTill to succeed, right?
06:59:32 <Adeon> what's this new book
06:59:34 <donri> kryft: maybe i misunderstood
07:00:23 <wojtekM_> s. marlow's book is on the way to me.
07:00:34 <applicative> Adeon: http://chimera.labs.oreilly.com/books/1230000000929/index.html
07:00:50 <Jeanne-Kamikaze> Adeon, http://www.amazon.com/dp/1449335942/ref=pe_385040_30332200_pe_309540_26725410_item
07:01:20 <merijn> wojtekM_: Anyway, reading up on STM can't hurt, even if you don't end up using it, you can do neat things with it :)
07:01:29 <kryft> donri: My intention is for 'junk' to parse everything in the part of the file included in the paste, but apparently it stops before the line that begins with "N: serial"
07:01:32 <Adeon> woah, that's recent
07:01:40 <Jeanne-Kamikaze> yeah
07:02:23 <kryft> donri: I can only assume that it stops because 'lookahead nameLineStart', the end parser for manyTill, succeeds at that point, but I don't understand why it succeeds
07:03:17 <wojtekM_> Okay, so I either: spawn a helper thread per channel, or embrace STM. Is that correct?
07:05:00 <Cho0fool_> A bit strange question, just encountered that beahvour by myself: In which cases i have to annotate string literal with String type like ("string" :: String)
07:05:11 <Cho0fool_> Why isn't it obvous for compiler?
07:06:59 <mauke> Cho0fool_: when you're using OverloadedStrings
07:09:22 <Cho0fool_> mauke: Ok, does dhc extensions file local or if in one file some one enables overloadedstring then all files connected that file got pollutted by it?
07:09:31 <Cho0fool_> By connected i mean linked together.
07:09:56 <mauke> they're local
07:10:02 <wojtekM_> I do already have a vague idea now STM works.
07:11:00 <Cho0fool_> mauke: Thanks, got it.
07:14:00 <Cho0fool_> mauke: For some reason it still can't figure out the type of string literal even without that ghc extesion enabled.
07:14:13 <geekosaur> @where hpaste
07:14:13 <lambdabot> http://lpaste.net/new/haskell
07:14:13 <Cho0fool_> I have some extesions specified in cabal file also.
07:14:16 <geekosaur> ^^ show code
07:14:28 <Cho0fool_> mauke: Do these(in cabal file) are global for each file?
07:14:47 <mauke> yes
07:15:46 <Cho0fool_> Hm, why yesod guys have put these extesions both in files and cabal file. :/
07:16:39 <Polarina> Cho0fool_, I for example had issues with hlint when I didn't put the Arrows extension in the file.
07:16:48 <kryft> donri: Ok, duh, I fixed the problem; I basically needed to add a 'try $' at the beginning of nameLineStart to ensure that it doesn't consume any input if it can't parse everything that it should parse
07:16:54 <Polarina> Cho0fool_, not related to yesod though.
07:17:37 <Cho0fool_> Polarina: Well, i call it hlint oriented programming, which is not a good thing tbh. :D
07:19:06 <Polarina> :)
07:25:30 <kryft> Ugh, now I'm getting hGetContents: invalid argument (invalid byte sequence) when I try to parse my file. Googling suggests that this is probably some kind of encoding problem. My system should be using UTF-8; I haven't generated the file I'm parsing myself, but it should only contain ASCII characters.
07:25:42 <kryft> Suggestions?
07:26:09 <geekosaur> use od -c to verify your assumtpion (in particular that something hasn't stuck a byte order mark at the start or something)
07:26:19 <mauke> or xxd
07:26:21 <mauke> or vim
07:26:23 <geekosaur> or xd  hhd / whatever your system has
07:26:38 <geekosaur> vim may hide it
07:27:08 <geekosaur> (maybe not the BOM, but various other things it will try to be "smart" about, which in this case is the last thing you want)
07:27:40 <geekosaur> (same with emacs unless you switch the buffer-file-encoding to raw and possibly use hexl mode)
07:29:01 <kryft> geekosaur: Hmm, what am I supposed to get out of the od -c output?
07:31:06 <merijn> kryft: Are the LANG, LC_ALL and LC_CTYPE environment variables set properly?
07:33:20 <kryft> merijn: LANG was set to en_US.UTF-8, and I set LC_ALL to the same (and restarted ghci of course), but LC_CTYPE is still unset; I'll try setting that as well
07:34:14 <kryft> Hmm, no, apparently I still get the same exception
07:34:15 <mauke> generally you don't want to set LC_ALL
07:34:54 <geekosaur> kryft, if it's truly all ASCII then you shouldn't see anything other than ASCII characters and newlines (\n / 0a) and possibly carriage returns (\r / 0d)
07:35:29 <geekosaur> any nul (\0 | 00) characters are usually a sign that something isn't what you expect, likewise any hex in the range 80 .. ff
07:37:04 <kryft> Ah.
07:38:40 <kryft> file -bi says that the file is iso-8859-1
07:41:12 <kryft> All right, converting the file to utf-8 with iconv -f ISO8859-1 -t UTF-8 removed the exception
07:41:15 <kryft> Thanks for the help
07:44:53 <bennofs> http://hackage.haskell.org/packages/archive/QuickCheck/2.6/doc/html/src/Test-QuickCheck-Arbitrary.html#Arbitrary Why is quickcheck using error as default for arbitrary?
07:47:41 <applicative> you would think 'no instance Arbitrary X...' would be a more pleasant error.
07:49:57 <ion> You would think no default definition would be a more pleasant error.
07:50:14 <bennofs> Or warning, without -Werror
07:50:54 <applicative> i think we can infer that a fight on an mailing list led to this result...
07:51:04 <applicative> on an old mailing list, rather
07:51:34 <jophish_> hmm, cabal seems to be ignoring extra-libraries in Project.cabal
07:51:54 <jophish_> ghc-options seem to be being disregarded too
07:58:03 * hackagebot bytestring-plain 0.1.0.0 - Plain byte strings ('ForeignPtr'-less 'ByteString's)  http://hackage.haskell.org/package/bytestring-plain-0.1.0.0 (HerbertValerioRiedel)
08:03:20 <jophish_> It seems to use the flags when compiling the test executable
08:08:28 <jmcarthur> jophish_: did you only put it in one executable/library/test-suite section?
08:09:38 <jophish_> jmcarthur: ah. It wasn't in any! it was in the global section, with name and version
08:09:54 <jophish_> using extra libraries in an executable section works great
08:10:10 <jmcarthur> ah, that would do it
08:10:16 <jmcarthur> surprised it didn't complain about that, really
08:10:21 <jophish_> One more question, Is this something I can change from the command line?
08:10:36 <jmcarthur> not sure about extra-libraries, but yes to ghc-options
08:10:55 <jmcarthur> --ghc-options=...
08:11:36 <jophish_> The overall issue is that I'm linking haskell with llvm, and on this system llvm is linked with libc++, rather than libstdc++
08:11:47 <jophish_> ghc likes to link with libstdc++
08:12:02 <jophish_> I'm really after some global flag saying what to link everything with
08:12:23 <jophish_> so I can have the whole haskell platform using libc++ instead of libstdc++
08:12:35 <jmcarthur> i don't know how to do that
08:13:19 <jophish_> It'd probably involve changing lib/ghc.../settings
08:13:31 <jophish_> and recompiling haskell-platform with libc++
08:14:11 <jophish_> for the time being it's easier to link in both. This will be a problem later though when I try to link to my c++ code
08:15:28 <merijn> jophish_: Maybe you can set a global option i your .cabal/config?
08:17:34 <jophish_> merijn: that's certainly better than making this project specific
08:18:49 <jophish_> also ideally it shouldn't require any configuration on the user side, rather be some ghc configuration
08:22:08 <jmcarthur> if the requirement is that the entire platform be linked this way, that sounds infeasible
08:26:07 <osa1> which DB library is preferred generally to be used with snap?
08:28:03 <Cho0fool_> mauke: Can i disable overloaded strings only in single file?
08:28:57 <Cho0fool_> Currently i'm having overloaded strings extension inabled on cabal file level, and thats convinient, but in one particular file it gets in my way.
08:29:29 <flebron> hi :) how can i check where this code is leaking space? http://ideone.com/zkNULw . i'm getting a stack overflow when passing a 20 x 20 array.
08:29:57 <merijn> flebron: RWH has a chapter on profiling Haskell code and tracking space usage
08:30:17 <jophish_> jmcarthur: why's that infeasible? There must be some line of configuration which says "pass these flags to the c compiler". All that needs to be done is to add "-stdlib=libc++" to those flags
08:30:39 <jmcarthur> i am unaware of a global configuration option to do that
08:33:03 <bitonic> jophish_: “-optc”?
08:33:10 <Cho0fool_> mauke: Found it.
08:35:05 <Cho0fool_> Is it possible to type annotate do {x <- foo} form?
08:35:36 <Cho0fool_> Annotate 'x'.
08:35:52 <ion> Annotate?
08:36:00 <ion> Ah, sorry. I missed “type”
08:36:16 <Cho0fool_> Like do {(x::String) <- foo}
08:36:38 <Cho0fool_> GHC kindly tells me about ScopedTypeVariables extesion.
08:36:46 <Cho0fool_> Is it possible only with extensions?
08:36:47 <ion> x <- foo :: Blah Foo (where Blah is the monad you’re using) or x :: Foo <- foo if you’re okay with ScopedTypeVariables or whatsitsname
08:37:21 <Cho0fool_> ion: Okay, thank you.
08:38:02 <jophish_> bitonic: ghc likes to pass in -lstdc++ manually
08:38:12 <jophish_> it's compiling with gcc instead of g++, so this makes sense
08:38:47 <Cho0fool_> ion: What whould be Blah in case foo of type GHandler sub master a ?
08:38:49 <jmcarthur> jophish_: anyway, the main reason i said that seems infeasible is that i don't think it would make sense for a cabal package to rebuild everything the end user has installed already
08:38:59 <Cho0fool_> ion: Sorry i'm not very familiar with monads yet.
08:39:37 <jophish_> jmcarthur: ah, I wasn't after that. I meant as a setting for my system, every package I build will use libc++. This only requires it because I have llvm build on my system with libc++
08:39:45 <jmcarthur> ah
08:39:57 <ion> cho0fool: Either figure out the concrete values for sub and master in question or just use the ScopedTypeVariables style.
08:40:10 <jmcarthur> well then, what you want sounds more feasible, but i still don't know of a way to do it, sadly
08:42:17 <jophish_> jmcarthur: hopefully it'll just require changing a few options when compiling ghc and haskell platform
08:42:32 <donri> is there any way to quickcheck polymorphic properties over all instances [known or in scope]?
08:44:01 <hpc> you could probably do something similar
08:44:26 <hpc> by having your test take a higher-ranked type, and then test that over specific instances
08:44:32 <c_wraith> donri: I think you can get instances of a class in scope at compile-time with TH
08:44:54 <donri> oh i need to RTFM, how did i miss .Poly and polyQuickCheck
08:45:57 <donri> although that just defaults types to Integer?
08:45:59 <c_wraith> donri: looks like reify in TH does give you a list of instances in scope.
08:46:13 <donri> c_wraith: yeah i was thinking that could work
08:49:57 <jmcarthur> if it's polymorphic then it can't be relying on specific properties of the type, so i would think any type which has the necessary instances would be about as good as any other
08:50:23 <jmcarthur> as long as its instances obey whatever laws you expect them to obey (which can be tested separately)
08:50:44 <donri> well the idea is to test those laws for all instances in one go? :)
08:51:12 <jmcarthur> ah. for that, i like to just make a polymorphic property and then in my test suite instantiate it multiple ways as multiple tests
08:51:13 <donri> say (Arbitrary a, Binary a) => a -> Bool = \a -> (decode . encode) a == a
08:52:10 <donri> jmcarthur: i could do that but there'll be a lot of instances like in this Binary example
08:52:33 <donri> and easy to miss instances
08:53:11 <jmcarthur> TH may be your best bet then
08:53:33 <donri> i was hoping there was code for it somewhere already, but yeah. thanks folks
08:53:34 <jmcarthur> if you want to guarantee that you don't miss any
08:53:46 <c_wraith> well, you still need to make sure they're in scope.
08:53:51 <c_wraith> You could always miss an import.
08:54:21 <donri> c_wraith: not really a problem for testing instances included with your own class
08:54:37 <donri> unless you have orphans
08:55:20 <jmcarthur> donri: or you define a data type elsewhere and make it an instance there
08:56:03 <Boyec> Hello, what is syntax of calling `f(a)` the way like `a some-magic-symbols f`?
08:56:30 <donri> jmcarthur: sure, but not relevant in my case :)
08:57:17 <donri> Boyec: there is no syntax for that and no "standard" operator. there's (&) in lens
08:57:33 <danharaj> :t (&)
08:57:34 <lambdabot> a -> (a -> b) -> b
08:57:35 <donri> > a & f
08:57:36 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
08:57:36 <lambdabot>    arising from a us...
08:57:49 <donri> :t f
08:57:50 <lambdabot> FromExpr a => a
08:58:05 <supki_> > a & f :: Expr
08:58:06 <lambdabot>   f a
08:59:20 <Boyec> Ok, thx
08:59:47 <kryft> Uh.. "unexpected end of input; expecting end of line, end of input or "I:""
09:01:35 <kryft> I'm surprised that you can get unexpected end of input when you're expecting end of input
09:02:54 <seanparsons> console
09:04:50 <aloiscochard|off> seanparsons: scala>
09:05:03 <seanparsons> aloiscochard|off: ?
09:05:11 <seanparsons> Dammit.
09:05:14 <seanparsons> Sorry.
09:05:30 <seanparsons> I'm actually baffled as to how this got keyboard focus.
09:05:44 <aloiscochard|off> seanparsons: hehe, I was just kidding nw
09:08:04 * hackagebot hexpat-pickle-generic 0.1.1 - Picklers for de/serialising Generic data types to and from XML  http://hackage.haskell.org/package/hexpat-pickle-generic-0.1.1 (BrendanHay)
09:08:06 * hackagebot querystring-pickle 0.1.1 - Picklers for de/serialising Generic data types to and from query strings  http://hackage.haskell.org/package/querystring-pickle-0.1.1 (BrendanHay)
09:12:18 <osa1> johnw: https://groups.google.com/forum/#!topic/yesodweb/_izmS3Kz8rA
09:12:45 <skypers> hey
09:13:04 * hackagebot hexpat-pickle-generic 0.1.2 - Picklers for de/serialising Generic data types to and from XML  http://hackage.haskell.org/package/hexpat-pickle-generic-0.1.2 (BrendanHay)
09:13:16 <skypers> do you know how to add module  directory to  ghci in order to make imports resolve?
09:17:53 <skypers> I mean, without using cabal-dev ??
09:18:04 * hackagebot querystring-pickle 0.1.2 - Picklers for de/serialising Generic data types to and from query strings  http://hackage.haskell.org/package/querystring-pickle-0.1.2 (BrendanHay)
09:18:09 <donri> skypers: ghci -isrc
09:18:36 <skypers> thank you
09:20:00 <skypers> huh
09:20:12 <skypers> Warning: ignoring unrecognised input `../ark-misc'
09:20:13 <skypers> damn :D
09:25:58 <Cho0fool_> How can i sort data.map?
09:26:10 <Cho0fool_> Say bay some value.
09:26:32 <donri> Cho0fool_: you can't, you have to convert it to another type
09:27:12 <Cho0fool_> donri: Convert to another type -> Sort -> Convert to map -> sorted map?
09:27:38 <donri> Cho0fool_: a Map is always sorted by keys
09:27:54 <donri> Cho0fool_: what do you actually want?
09:28:04 * hackagebot querystring-pickle 0.1.3 - Picklers for de/serialising Generic data types to and from query strings  http://hackage.haskell.org/package/querystring-pickle-0.1.3 (BrendanHay)
09:28:06 * hackagebot hexpat-pickle-generic 0.1.3 - Picklers for de/serialising Generic data types to and from XML  http://hackage.haskell.org/package/hexpat-pickle-generic-0.1.3 (BrendanHay)
09:29:12 <donri> Cho0fool_: sorting a Map doesn't really make sense. maybe you want a list of all values in some order?
09:29:56 <aristid> changing the key changes how a map is sorted, though.
09:30:27 <Cho0fool_> donri: Why is doesn't make sense? We can traverse Map right? And in some cases it matters which keys will be processed first.
09:31:40 <donri> Cho0fool_: well then what you want is to sort the traversal :)
09:32:10 <Cho0fool_> donri: What does it mean?
09:33:31 <donri> Cho0fool_: it means convert to list, sort the list, traverse the list
09:34:34 <donri> Cho0fool_: possibly you actually want a different data structure, don't know. Map is not optimal for this
09:38:03 <skypers> hey
09:38:15 <skypers> I use cabal-dev install ./foo
09:38:21 <skypers> cabal-dev install ./bar
09:38:23 <skypers> now
09:38:34 <skypers> I’d like to test both the library at the same time
09:38:37 <skypers> how could I do that ?
09:38:51 <skypers> (I don’t find the ghci option to add the two paths)
09:40:00 <skypers> any idea?
09:40:00 <Redz> how can i convert between Data.ByteString.Lazy and Data.ByteString?
09:40:41 <donri> skypers: maybe something like, ghci -package-db cabal-dev/*.conf (i forgot if it actually is *.conf, see what's in there)
09:41:28 <donri> Redz: there's fromStrict/toStrict in the Lazy module
09:41:56 <skypers> ghc: invalid package database file cabal.config
09:42:00 <skypers> not that :D
09:43:39 <Redz> donri: thank you.
09:45:51 <donri> skypers: well it might be *.db or something, ls cabal-dev/
09:47:13 <skypers> cat cabal.config
09:47:13 <skypers> package-db: /home/skp/dev/demo/ark/cabal-dev/packages-7.6.3.conf
09:47:32 <skypers> a package db is just a dir ?
09:47:33 <skypers> funny
09:47:57 <S_J> What do you put as the path to haskell-mode in .emacs?
09:48:11 <S_J> I didn install haskell-mode but dont know where it is stored
09:48:15 <skypers> ok
09:48:21 <skypers> now ghci is running
09:48:48 <skypers> how could I :l  ou .m + the package ?
09:51:42 <jophish_> Compiling c++ with cabal, this still seems to be an issue: http://www.haskell.org/pipermail/libraries/2008-February/009100.html
09:52:15 <jophish_> Is there any way to pass c++ specific flags currently?
09:53:05 * hackagebot querystring-pickle 0.1.4 - Picklers for de/serialising Generic data types to and from query strings  http://hackage.haskell.org/package/querystring-pickle-0.1.4 (BrendanHay)
10:23:05 * hackagebot pretty-show 1.6.1 - Tools for working with derived `Show` instances and generic  inspection of values.  http://hackage.haskell.org/package/pretty-show-1.6.1 (IavorDiatchki)
10:33:12 <triyo_> I have the following code whereby I wish to do a nested update on a field using the record syntax http://lpaste.net/91939 … Line 31, I get this error: Couldn't match expected type `Location' with actual type `Arc' In the first argument of `_latitude', namely `(_homeLocation p)
10:33:40 <mauke> { } binds tightest
10:34:24 <triyo_> mauke: so to tight in my case?
10:34:35 <joelteon> I feel like a moron. case foo of Nothing -> return Nothing; Just k -> f k
10:34:42 <joelteon> how do I simplify that into a maybe call?
10:34:56 <mauke> maybe (return Nothing) f
10:35:14 <osfameron> isn't that fmap f ?
10:35:22 <c_wraith> no
10:35:23 <mauke> depends on the type of f
10:35:24 <joelteon> it isn't actually fmap f
10:35:27 <joelteon> I thought it was, but it isn't
10:35:27 <c_wraith> there's a retrun
10:35:30 <joelteon> I'll try that mauke
10:35:31 <c_wraith> *return
10:35:38 <c_wraith> fmap f = maybe Nothing f
10:35:45 <c_wraith> the return changes it entirely
10:36:01 <joelteon> yeah, that does it
10:36:04 <mauke> fmap f = maybe Nothing (Just . f)
10:36:12 <c_wraith> err, right
10:36:23 <c_wraith> So both cases are wrong
10:36:26 <osfameron> ah
10:36:35 <mauke> :t maybe def
10:36:36 <Cho0fool_> What is shelly's FilePath? Isn't it a String?
10:36:36 <lambdabot> Default b => (a -> b) -> Maybe a -> b
10:37:23 <dagano> i have an abstract nonsense question : i don't know much about category theory .. but i keep seeing that list is a functor...how is this the case given the category theory definition (roughly) of a mapping between categories. .what are the categories? what are the objects in each?
10:37:45 <dagano> can anyone recommend some reading to get a rough handle on this?
10:37:45 <mauke> :t maybe def `asAppliedTo` (undefined :: String -> IO Int)
10:37:45 <lambdabot> (String -> IO Int) -> Maybe String -> IO Int
10:38:24 <triyo_> Anyone have any hint regarding my record syntax question pls?
10:38:29 <mauke> dagano: no, but I know that Functor is really endofunctors
10:38:43 <ski> dagano : the two categories are both the category `Hask' with Haskell types as objects and functions between them as morphisms
10:38:44 <mauke> also, apparently there's a category Hask where the objects are types?
10:39:04 <mauke> triyo_: use more parens
10:39:06 <shachaf> Objects are overrated.
10:39:26 <shachaf> They're only there so that we can talk about the arrows.
10:39:35 <shachaf> The arrows are functions.
10:39:39 <triyo_> mauke: around which parts exactly?
10:39:46 <ski> triyo_ : i think mauke meant `(_latitude (_homeLocation p)) { ... }'
10:40:41 <triyo_> ski: thanks
10:40:43 <dagano> @ski .. thanks
10:40:43 <lambdabot> Maybe you meant: wiki src ask
10:40:46 <dagano> hah
10:41:30 <ski> dagano : as mauke said, the type class `Functor' only captures functors from `Hask' to `Hask'
10:41:33 <shachaf> dagano: Let's take Maybe as an example because the syntax is simpler.
10:41:48 <dagano> ok
10:41:49 <shachaf> It has two parts. One is the type itself, which e.g. turns the type "Int" into the type "Maybe Int"
10:41:57 <shachaf> That's the "object mapping"
10:42:02 <ski> @kind Maybe
10:42:03 <lambdabot> * -> *
10:42:11 <dagano> agreed
10:42:26 <shachaf> The other part is the "arrow mapping", which turns a function into a function.
10:42:35 <shachaf> fmap :: (Int -> Char) -> Maybe Int -> Maybe Char
10:43:06 <dagano> so you can lift an int fcn Int -> Int to operating 'within' a maybe type?
10:43:09 <dagano> is that accurate?
10:43:38 <shachaf> Sure, we can go with that.
10:43:49 <shachaf> But you can also take a function of any type whatsoever.
10:44:02 <ski> you can lift a morphism from `A' to `B' into a morphism from `F A' to `F B', for any objects `A' and `B', where `F' is the functor
10:44:04 <dagano> yeah i just meant as an instance
10:44:26 <FreeFull> For all monads, you can lift an  a -> a function up to  a -> m a   or   m a -> m a
10:44:35 <FreeFull> And Maybe happens to be a monad
10:44:52 <dagano> monad is just a more strict transformation?
10:44:56 <FreeFull> :t (return .)
10:44:56 <lambdabot> Monad m => (a -> b) -> a -> m b
10:45:01 <dagano> than functor?
10:45:04 <shachaf> Any reason you're bringing that up?
10:45:38 <FreeFull> I don't know
10:45:53 <jmcarthur> i don't think monads are a great introduction to category theory :)
10:46:11 <FreeFull> But you can't do    (a -> b) -> a -> m b   with just fmap
10:48:04 <shachaf> jmcarthur: Well, I think most introductions to category theory mention monads.
10:48:18 <shachaf> But only after functors and such are well understood.
10:48:33 <dagano> is a monad just a functor with some extra restrictions?
10:48:47 <byorgey> dagano: with some extra operations
10:48:49 <dagano> ie category maps to itself
10:48:50 <dagano> etc
10:49:04 <shachaf> Every monad is a functor with some extra things.
10:49:18 <dagano> i try to think about categories as algebraic objects .. but i think maybe that confuses me
10:49:24 <shachaf> You can often add these extra things to a functor in more than one way.
10:49:37 <shachaf> dagano: Think of a category as a generalization of a monoid.
10:50:02 <dagano> schachaf . yeah that's pretty much my way of looking at it
10:50:15 <shachaf> With a monoid, you can multiply any two objects without caring about what they are. With a category, they have to "match".
10:50:34 <dagano> and the set of the monoid <=> the category with a single object
10:50:51 <dagano> or "single object of the category"
10:51:01 <shachaf> For example, take matrices and matrix multiplication. You can't multiply two arbitrary matrices -- you have to have n×m and m×o or something along those lines.
10:51:25 <dagano> i think i'll ultimately have to take a more pragmatic approach to all this ... if my goal is to USE THESE THINGS. but the abstract stuff is interesting
10:51:25 <shachaf> No, the object doesn't correspond to a set. The object is just boring.
10:51:35 <shachaf> Yes, I don't recommend caring about any of this very much if your goal is to learn Haskell.
10:52:38 <dagano> are there many researchers in this room?
10:52:55 <dagano> in this area?
10:53:39 <dagano> ps shachaf thanks for the help ..
10:57:34 <EarlGray> Are there some standard means to deal with sorted sequences for fast lookup?
10:58:14 <EarlGray> I mean something like binary search tree, but I need to compare by
10:58:24 <EarlGray> my custom function
10:59:10 <EarlGray> Ideally, that should be something like AVL tree interface from AvlTree package
10:59:21 <c_wraith> EarlGray: what are your actual *needs*?
10:59:46 <EarlGray> I need to look up a range for a point fast
11:00:33 <EarlGray> I have a list of sorted ranges, now I'm trying to use it for fast search
11:00:58 <ReinH> edwardk: so... it didn't take me very long to get stuck :D
11:01:14 <c_wraith> so you have a list of ranges (non-overlapping?), and want to determine which of them a particular point is in?
11:01:26 <EarlGray> yep, they're non-overlapping
11:01:32 <edwardk> ReinH: heh
11:01:35 <ReinH> edwardk: but I did work my way through the comomad instance of Store and I think I understand what's going on there
11:01:46 <edwardk> ReinH: sweet =)
11:01:58 <edwardk> did you see the post on pretext tel posted?
11:02:02 <ReinH> no?
11:02:06 <edwardk> and the reddit chatter that ensued
11:02:22 <EarlGray> And it's guaranteed that they don't have gaps between ranges
11:02:29 <ReinH> checking
11:02:45 <edwardk> check reddit.com/r/haskell for a post on pretext. he does a pretty good job of reverse engineering what it must be
11:02:45 <c_wraith> EarlGray: I feel like I've seen a library to do this on hackage.
11:03:32 <edwardk> though he does derive more complicated versions than they need to be
11:03:38 <edwardk> that gets resolved in the chatter on reddit
11:04:47 <ReinH> edwardk: it took me a while to figure out what a store of a store was, but you're just creating a lazy stream
11:05:23 <ReinH> edwardk: and Store (==0) 0 encodes the initial state (false everywhere except at 0)
11:06:01 <ReinH> edwardk: so if I were going to do GoL I might use a Store (== V2 0 0) (V2 0 0) instead?
11:06:14 <jmcarthur> EarlGray: are you, perhaps, really wanting an interval tree?
11:06:33 <jmcarthur> EarlGray: if so, i think there are a couple packages that have those
11:06:44 <tabemann> (==) for IOArrays tests values or identity?
11:06:48 <jmcarthur> oh they are non-overlapping, so i guess there is an optimization there
11:07:14 <jmcarthur> tabemann: if you think carefully about the type then you can answer that yourself
11:08:05 <tabemann> oh wait, identity of course - I was actually thinking of a different type
11:08:09 <ReinH> edwardk: ... which would be a trivial GoL universe that dies on the first generation, which raises another point: how would you encode more complex starting conditions?
11:08:31 <EarlGray> ok, I think I'm fine with AvlTree and its forkL
11:08:55 <tabemann> i.e. does it behave the same way for plain Arrays'
11:08:59 <tabemann> *Arrays
11:09:14 <jmcarthur> again, think about the type :)
11:09:24 <jmcarthur> this one may be a little harder to see, though
11:10:53 <jmcarthur> for IOArrays, it must be identity since to compare the values would require IO
11:11:04 <jmcarthur> for Arrays, it must be value since to compare identity would require IO!
11:12:13 <jmcarthur> as evidenced by the fact that you can construct an Array in a purely functional way without ever assigning it an ID or providing some sort of ID supply
11:12:14 <ski> in a sense, the values in an `IOArray a' doesn't reside in the `IOArray a' itself, but in the hidden state hiding in the `IO', hence you can't access them without using `IO'
11:12:26 <tabemann> what's more interesting for what I'm doing, though, is that some of the values in the array being compared would contain IORefs or IOArrays, so hence overall I would be partially comparing value and partially comparing identity...
11:12:56 <jmcarthur> for IOArrays and IORefs, the identities are the only meaningful values, so this isn't so strange to me
11:13:25 <jmcarthur> you can think of an IORef as a sort of token that represents a mutable state rather than the mutable state itself
11:13:30 <jmcarthur> so you're really just comparing the tokens
11:13:32 <ski> you may think of an `IORef a' and an `IOArray a' as simply an index (/ reference) into the `IO' state, so if you only got (one of) the former, then you can only compare the index/reference
11:14:24 <tabemann> why does R7RS-small encourage me to enable the comparison of closures?!
11:14:39 <ski> perhaps ask #scheme ?
11:15:24 <edwardk> back
11:15:41 <tabemann> specifically it says that eqv? must return #f if two values would behave differently from any arguments, but says nothing about it returning #t... but then in some examples has it returning #t...
11:15:44 <ReinH> edwardk: hai
11:16:00 <edwardk> ReinH: Got disconnected. I'm at a small airport waiting for my wife to jump out of a perfectly good airplane and i'm cycling through electronics to stay on the internet. ;)
11:16:37 <ReinH> edwardk: no worries :)
11:16:43 <ReinH> edwardk: so experiment is extract but applied over some functor. OF COURSE.
11:16:44 <ski> tabemann : afaiu, it's allowed, but not required, to return `#t' for two extensionally equivalent procedures
11:16:47 <jmcarthur> tabemann: sounds like the spec is ambiguous is the appropriate ways, to me
11:16:47 <ReinH> things are starting to fall into place now
11:16:53 <edwardk> ReinH: yep
11:16:56 <jmcarthur> *in the appropriate
11:17:12 <edwardk> well, its 'peeks' applied to some functor
11:17:16 <edwardk> :t Control.Comonad.Store.peeks
11:17:17 <lambdabot> Control.Comonad.Store.Class.ComonadStore s w => (s -> s) -> w a -> a
11:17:23 <edwardk> :t Control.Comonad.Store.experiment
11:17:24 <lambdabot> (Functor f, Control.Comonad.Store.Class.ComonadStore s w) => (s -> f s) -> w a -> f a
11:17:45 <ReinH> edwardk: I'm not sure I caught it before but I figured out the obvious fact that Store (==0) 0 is a creating a "false everywhere but 0 codomain"
11:17:53 <edwardk> ReinH: =)
11:18:03 <ReinH> edwardk: which lead me to ask: how would you encode a different starting universe?
11:18:05 <edwardk> i had a verbose version, but decided that the concise uncommented version was better
11:18:21 <ReinH> edwardk: like, Store (== V2 0 0) (V2 0 0) might be a trivial GoL universe that dies on the first generation
11:18:26 <ReinH> how would you encode an 5 pentomino or etc?
11:18:34 <edwardk> you'd supply another function that returned true whenever you wanted
11:18:57 <edwardk> :t Data.Set.elem
11:18:57 <tabemann> ski: the big thing is that when comparing inside closures with eqv?, internal values that would result in #f with eqv? include things like pairs, vectors, bytevectors, and strings which would always return false with eqv?
11:18:58 <lambdabot>     Not in scope: `Data.Set.elem'
11:18:58 <lambdabot>     Perhaps you meant `Data.List.elem' (imported from Data.List)
11:19:02 <edwardk> :t Data.Set.member
11:19:03 <lambdabot> Ord a => a -> S.Set a -> Bool
11:19:10 <ReinH> right, check for membership in some structure of live cells
11:19:15 <ReinH> makes sense
11:19:17 <edwardk> Store (`member` blah) 0
11:19:27 <edwardk> Store (`member` blah) (0,0)   , etc.
11:19:29 <tabemann> but some reason it seems wrong for me to actually be able to compare closures at all, since closures should maintain some semblance of modularity w.r.t. their contents
11:19:36 <ReinH> edwardk: makes. sense. :)
11:20:12 <jmcarthur> tabemann: i don't think the intent is to just be able to compare the function pointer and captured variables, but to have some idea of the *values* of the functions be comparable
11:20:15 <ski> tabemann : i'm not sure what "enable" in "enable the comparison of closures" refers to
11:20:24 <ReinH> edwardk: that's crazy simple :)
11:20:32 <edwardk> tabemann: the idea that a lambda carries a notion of equality in scheme/lisp is one of the biggest barriers to optimizing that language well
11:20:35 <edwardk> tabemann: it means _so_ many optimizations are not sound
11:21:28 <ReinH> edwardk: So I spent a few hours yesterday going over the Store and trying to figure out the shape of a hashlife comonad and I just couldn't make the leap
11:21:36 <jmcarthur> edwardk: but the spec is fairly conservative about it. a valid implementation of equality for functions would be to just return false all the time, at least according to tabemann's quote from R7RS-small
11:22:08 <edwardk> jmcarthur: r7rs perhaps, but r5rs and r4rs require a location per lambda, etc.
11:22:14 <jmcarthur> ah
11:22:24 <jmcarthur> well, then this sounds like an improvement
11:22:47 <ReinH> edwardk: maybe there's some way you could prod me in the right direction without giving it away
11:22:48 <tabemann> a location per lambda (it's been a bit since I looked at R5RS)... that seems... unnecessary
11:23:21 <tabemann> maybe I could make closure comparison just return #f all the time, and implement it later if I really feel like it
11:23:39 <edwardk> yeah. i have kind of tuned out the scheme community since the r6rs debacle, and since nobody on the r7rs committee seems to have been involved in the community til now, i've had somewhat.. low hopes and just taken to using racket for my few scheme-like wants/needs.
11:24:20 <jmcarthur> i had memoization of higher order functions on the mind yesterday. i am a terrible person. there is no way such a thing would be worthwhile...
11:24:45 <edwardk> ReinH: i'd recommend skimming the hashlife material mostly. i haven't actually done this construction with store mind you
11:24:47 <jmcarthur> i mean by value, not by identity
11:25:09 <Cho0fool_> Hm...
11:25:11 <ReinH> edwardk: I mean, I can implement hashlife imperatively.
11:25:14 <Cho0fool_> @undo do {a <- foo; show a}
11:25:14 <lambdabot> foo >>= \ a -> show a
11:25:15 <lingxiao> hey all, I have a really basic question.. when case checking against some `monoid`, how do I check for the `mempty` case?
11:25:23 <edwardk> jmcarthur: well, you can always use observable equality in haskell for it
11:25:24 <Cho0fool_> nextRandom >>= \ a -> show a
11:25:26 <Cho0fool_> Couldn't match type `[]' with `IO'
11:25:26 <lingxiao> like when I do `case a of mempty -> ...`
11:25:30 <Cho0fool_> Why is that?
11:25:36 <Cho0fool_> nextRandom :: IO uuid-1.2.13:Data.UUID.Internal.UUID
11:25:41 <geekosaur> you don;t, since mempty is not a constructor and what it represents depends on the type
11:25:44 <lingxiao> it seems like mempty is just the name of a variable
11:25:45 <ReinH> edwardk: I *think* the difference is that I need a tree of stores rather than a stream of stores?
11:25:49 <jmcarthur> edwardk: right, hence my qualification that i mean by value
11:25:53 <ReinH> maybe?
11:25:53 <ski> edwardk : hm, i thought jcowan was often in #scheme, commenting on various issues
11:26:03 <geekosaur> and yes, because it's not a constructor it's just a local variable binding in a pattern match
11:26:06 <merijn> Cho0fool_: Because show returns String (or [Char]) and >>= wants a function that returns IO something
11:26:19 <geekosaur> if an Eq constraint is acceptable then you can compare == mempty
11:26:33 <geekosaur> instead of using a pattern match
11:26:46 <Cho0fool_> merijn:  nextRandom >>= \ a -> return $ show a
11:26:47 <ski> Cho0fool_ : you may want `do a <- nextRandom; return (show a)' or something like that
11:27:12 <Cho0fool_> nextRandom >>= return . show
11:27:19 <Cho0fool_> Looks werid.
11:28:09 <merijn> Cho0fool_: Yes, that's just fmap
11:28:20 <danharaj> :t (show <$>)
11:28:21 <lambdabot> (Functor f, Show a) => f a -> f String
11:28:31 <ski>   return . show =<< nextRandom  -- is the same, and may read more nicely
11:28:54 <ski> (but yes, `foo >>= return . bar' is `liftM bar foo')
11:29:01 <Cho0fool_>  show <$> nextRandom -- That on more nice, but i don't get it.
11:29:13 <merijn> Cho0fool_: <$> is just infix fmap
11:29:14 <ski> what don't you get ?
11:29:24 <Cho0fool_> ski: <$>
11:29:34 <merijn> "fmap show nextRandom" and "show `fmap` nextRandom" would work too
11:29:44 <c_wraith> :t (<$>)
11:29:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:29:49 <c_wraith> it's just a function
11:30:03 <Cho0fool_> :source (<$>)
11:30:09 <Cho0fool_> :src (<$>)
11:30:20 <c_wraith> It's the same as fmap
11:30:27 <c_wraith> The implementation is different for every type
11:30:57 <ReinH> edwardk: I'm guessing you didn't get the last thing I said to you? No worries :)
11:31:03 <cdxr> Cho0fool_: Did you intend print instead of show?
11:31:08 <Cho0fool_> c_wraith: Ah.
11:31:10 <Cho0fool_> cdxr: No.
11:31:14 <edwardk> ReinH: probably not, had to switch to another gadget ;)
11:31:18 <ReinH> lmao
11:31:24 <ReinH> edwardk: I *think* the difference is that I need a tree of stores rather than a stream of stores?
11:31:51 <mbrock> edwardk, ReinH: i made a weird Comonad instance for Pretext using a lot of undefineds :D
11:31:52 <edwardk> ah yes, i tried replying with an enigmatic 'maybe…' but guess it didn't get through.
11:31:57 <Cho0fool_> merijn: I just thought i can operate monads only ith <- and >>= =<< .
11:31:58 <ReinH> edwardk: heh
11:32:00 <edwardk> mbrock: heh
11:32:03 <ReinH> mbrock: lol
11:32:26 <Cho0fool_> So i can put something out of IO with just fmap?
11:32:40 <ski> Cho0fool_ : not "out of"
11:32:44 <mbrock> i think it works correctly if you use it with lazy functors
11:32:44 <c_wraith> no, fmap transforms something in IO.
11:33:01 <ski> you can "operate on the result" with `fmap'/`liftM'/`(<$>)'
11:33:06 <Cho0fool_> show <$> nextRandom :: IO String
11:33:12 <Cho0fool_> I see, thanks guys.
11:33:13 <merijn> Cho0fool_: IO is not just a Monad, it's also a Functor and an Applicative
11:33:18 <merijn> Cho0fool_: If you look at fmap
11:33:19 <ReinH> edwardk: basically my thought is that rather than extending from one "universe" to the next, each cell I need to check needs to come from its own "universe" so that I can share those universes using loeb?
11:33:19 <merijn> :t fmap
11:33:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:33:41 <merijn> Cho0fool_: Since IO is a functor, you can think of it as "fmap :: (a -> b) -> IO a -> IO b"
11:34:05 <jmcarthur> Cho0fool_: it turns out that for IO, fmap is indeed implemented in terms of return and bind, so you're not doing anything especially new with it
11:34:36 <ski> @src IO fmap
11:34:36 <lambdabot> fmap f x = x >>= (return . f)
11:34:44 <merijn> Cho0fool_: The thing with IO is that it's not so much about getting something *out* of IO, it's how to get other things *in*
11:35:00 <Cho0fool_> merijn: Got it.
11:37:24 <ReinH> edwardk: lol this is fun :D
11:37:27 <edwardk> bah
11:37:43 <edwardk> anyways i said mbrock: extract = runIdentity . experiment Identity -- right before i got disconnected
11:37:47 <edwardk> @let import Control.Comonad.Store
11:37:48 <lambdabot>  .L.hs:37:1:
11:37:48 <lambdabot>      Control.Comonad.Store: Can't be safely imported!
11:37:48 <lambdabot>      The p...
11:37:58 <edwardk> @let import Control.Comonad.Trans.Store
11:37:58 <lambdabot>  .L.hs:37:1:
11:37:59 <lambdabot>      Control.Comonad.Trans.Store: Can't be safely imported!
11:37:59 <lambdabot>     ...
11:38:05 <edwardk> bah
11:38:19 <ReinH> edwardk: right, extract is experiment in the Identity functor. I understood that reference!
11:38:27 <mbrock> yeah i saw your derivations on reddit, very cool
11:38:27 <edwardk> :t Control.Comonad.Store.experiment (Control.Comonad.Store.store id)
11:38:28 <lambdabot> Control.Comonad.Store.Class.ComonadStore s w => w a -> Control.Comonad.Trans.Store.StoreT s Identity a
11:38:53 <edwardk> and you can convert to another store using Store id as the experiment
11:39:06 <ReinH> edwardk: is that also (ala Identity experiment) ?
11:39:13 <ReinH> I'm starting to love ala and au
11:39:40 <edwardk> the instance for Bazaar is the exact same, just change out Functor constraints for Applicative
11:39:44 <edwardk> and everything remains the same
11:39:53 <edwardk> Identity is also Applicativ
11:40:01 <edwardk> the composition of two Applicative functors is Applicative
11:40:10 <edwardk> :t ala Identity experiment
11:40:10 <lambdabot> Not in scope: `experiment'
11:40:19 <edwardk> :t ala Identity Control.Comonad.Store.experiment
11:40:20 <lambdabot> Control.Comonad.Store.Class.ComonadStore s w => w s -> s
11:40:23 <edwardk> looks right
11:40:25 <joelteon> :t ala
11:40:38 <joelteon> oh
11:40:43 <edwardk> :t alaf Identity Control.Comonad.experiment
11:40:44 <lambdabot> Not in scope: `Control.Comonad.experiment'
11:40:47 <edwardk> :t alaf Identity Control.Comonad.Store.experiment
11:40:48 <lambdabot> Control.Comonad.Store.Class.ComonadStore s w => (s -> s) -> w s -> s
11:40:52 <edwardk> :t alaf Identity Control.Comonad.Store.experiment . const
11:40:53 <lambdabot> Control.Comonad.Store.Class.ComonadStore s w => s -> w s -> s
11:40:57 <edwardk> thats peek and peeks
11:41:50 <edwardk> ReinH: i stole ala/alaf from djahandarie who stole them from conor mcbride.
11:42:03 <ReinH> huh
11:42:24 <edwardk> i named, since ala is french, i went with au for a le and   auf for the same in german, getting a double pun off the existing alaf
11:42:36 <ReinH> hah
11:43:07 * hackagebot querystring-pickle 0.1.5 - Picklers for de/serialising Generic data types to and from query strings  http://hackage.haskell.org/package/querystring-pickle-0.1.5 (BrendanHay)
11:43:21 <merijn> The most critical thing in development and science is finding nice puns for your names...
11:43:23 <edwardk> it works best linguistically with ala though
11:43:57 <joelteon> what's the type of ala
11:43:58 <merijn> Unfortunately my Shakespeare knowledge is insufficient to sneak a reference in my title...
11:44:08 <edwardk> merijn: there are only two hard problems in computer science, naming things and cache invalidation
11:44:11 <edwardk> :t ala
11:44:13 <ReinH> and off by one errors
11:44:20 <joelteon> heh, I get it
11:44:26 <edwardk> ReinH: nah, we're in haskell, that is mostly solved
11:44:33 <ReinH> edwardk: :p
11:47:01 <sumedh> Newcomer to Haskell here. I'm building a voice-controlled app. What's the best way to integrate sound with Haskell? I just need basic play/record functionality for now
11:47:30 <merijn> sumedh: Which platform(s)?
11:47:46 <sumedh> merijn: Targetting the Raspberry Pi
11:47:59 <ReinH> edwardk: wait, didn't you say that a bazaar was like a bunch of stores?
11:48:07 <sumedh> merijn: But my dev environment is Mac OS X
11:48:13 <merijn> sumedh: I would basically investigate what everyone is using for sound on the Pi and then look into using that from Haskell
11:48:23 <edwardk> it is a store that can have a bunch of 'states' in it
11:48:48 <merijn> sumedh: If you're lucky bindings already exist for some library, if not then creating FFI bindings in haskell is pretty easy
11:48:54 <edwardk> (s -> f s) -> f a   -- because f is applicative it can make that out of whole cloth from an 'a'
11:49:02 <edwardk> it doesn't need to have _any_ 's's
11:49:38 <edwardk> otoh it can have many of them and use all of them under your f (since it can smash together the f's applicatively) to make your a.
11:49:39 <sumedh> merijn: Many people have recommended using portaudio (there is a Haskell wrapper for the C portaudio library). The installation looks good, the program compiles, but I get a segmentation fault while running a sample program.
11:50:16 <ReinH> edwardk: is that at all relevant to my problem?
11:50:57 <sumedh> merijn: the segfault is on Mac. I'm trying it on the Pi, maybe it will work better
11:51:00 <merijn> sumedh: Right, that's a lot more specific, I don't know anything about the pi or portaudio, but the first step would be to find out whether portaudio is crashing or the haskell code
11:51:34 <edwardk> ReinH: nope
11:51:42 <merijn> sumedh: You should probably trying using gdb to check out the core dump and see where it crashes
11:51:47 <sumedh> merijn: If my test program compiles fine, can I assume that the C library has been linked in correctly? Or does that happen at runtime?
11:52:11 <merijn> sumedh: If the linker can't find the library you'd get "missing symbol foo" errors
11:52:26 <merijn> sumedh: If you don't get those, you can probably assume it linked fine
11:52:36 <ReinH> edwardk: wah wah
11:53:05 <sumedh> merijn: hmm then I suspect it's an issue outside haskell. I'll try to get the portaudio stuff working independently of haskell first. thanks for your help. :)
11:53:08 <mbrock> is there a Pretext for which this fails? :) extract (Pretext k) = k const undefined
11:55:58 <jophish_> I don't suppose that stylish haskell has any support for aligning things like case expressions? Do you know of any tool that does?
12:01:17 <wojtekM_> My conclusions after half a day of Haskell exploration:
12:01:31 <wojtekM_> - Coding in Haskell means lots and lots of dollars
12:01:42 <wojtekM_> - STM is utterly cool
12:01:57 <Taneb> <wojtekM_> - Coding in Haskell means lots and lots of dollars <-- brilliant! I have a life plan now!
12:02:11 <zomg> Coding in Haskell has so far netted me 0 dollars
12:02:21 <sumedh> merijn: Quick update: my program runs fine and generates audio if I run it through "runghc", but it seg faults if I invoke the compiled version. What could cause this?
12:02:53 <zomg> Building a SaaS with haskell as the backend lang though
12:03:04 <zomg> so depending on how well that goes it might change to some small amount of money
12:03:07 <zomg> =)
12:03:28 <mbrock> cool!
12:03:46 <merijn> sumedh: Hmmm, that's odd
12:04:22 <wojtekM_> @zomg So you are using only parentheses?
12:04:22 <lambdabot> Unknown command, try @list
12:05:38 <wojtekM_> @zomg So you are using only parentheses?
12:05:39 <lambdabot> Unknown command, try @list
12:05:56 <ski> try removing the `@' ?
12:06:04 <wojtekM_> oh, sorry, thanks
12:06:33 <wojtekM_> simply start line with nick?
12:06:51 <wojtekM_> ski does it work?
12:06:53 <ski> yes, perhaps followed by a colon or a comma
12:07:03 <wojtekM_> ski: like that?
12:07:13 <wojtekM_> yeah! thanks
12:07:45 <ski> many IRC clients will fill in the nickname, and often a colon/comma for you, if you type the first characters of the nickname, and then hit `TAB'
12:08:18 <wojtekM_> I'm using emacs client, and indeed - tab works
12:08:38 <ski> (and many IRC clients will alert the user and highlight the line when someone mentions their nickname as the first thing in a line)
12:08:51 <wojtekM_> Now seriously. Could STM.orElse return Either a b?
12:08:58 <zomg> wojtekM_: huh? :p
12:09:10 <fryguybob> wojtekM_: Sure
12:09:38 <ski> @type Control.Monad.STM.orElse
12:09:39 <lambdabot> GHC.Conc.Sync.STM a -> GHC.Conc.Sync.STM a -> GHC.Conc.Sync.STM a
12:09:50 <wojtekM_> Now STM.orElse requires both channels to be the same type
12:09:57 <tabemann> coding in Haskell has netted me many dollar *signs*, but no dollars so far
12:10:07 <ski> @type \ma mb -> Control.Monad.STM.orElse (liftM Left ma) (liftM Right mb)
12:10:07 <lambdabot> GHC.Conc.Sync.STM a1 -> GHC.Conc.Sync.STM b -> GHC.Conc.Sync.STM (Either a1 b)
12:10:12 <zomg> oh lol.
12:10:18 <zomg> I get it now
12:10:20 <zomg> :P
12:10:20 <tabemann> it has also convinced me that concurrency without STM is just horrible
12:10:58 <tabemann> and that M:N threads are indeed far superior to 1:1 threads
12:11:38 <dagano> am i here?
12:11:46 <ski> no
12:11:47 <ski> you're there
12:12:00 <dagano> noooooo (thanks, new terminal irc client .. had to test)
12:12:01 <TTimo> define here
12:12:32 <dagano> here := point in eucliden 3space
12:13:37 <startling> dagano, oh. then you are emphatically not here.
12:14:14 <tabemann> I wouldn't consider IRC channels belonging to IRC nets with more than one server as belonging to *any* point in Euclidean 3-space
12:14:36 <dagano> hah . neither would i
12:16:58 <mbrock> that makes us inhabitants of a rather strange space
12:17:06 <mbrock> let's call it ... dum dum dum ... CYBER-space!
12:17:15 <mbrock> :O
12:18:11 <ReinH> :/
12:21:17 <wojtekM_> Control.Distributed aka "Clould Haskell", is it ready for prime time?
12:32:54 <tabemann> so in case it exists I don't have to search for it, is there a function that is like zipWith but can return a chosen value of the two lists are not equal in length?
12:33:13 * hackagebot hlint 1.8.50 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.50 (NeilMitchell)
12:39:04 <Cho0fool_> What the average GC time for haskell programs?
12:39:06 <Cho0fool_> %GC     time      34.4%  (34.4% elapsed)
12:39:09 <Cho0fool_> Is it okay?
12:48:00 <k00mi> Cho0fool_: quite high, it should be well below 10%
12:48:42 <alastor__> is it correct to think of type classes as (roughly) what mixins are in OO-languages? i mean a set of functions that are given to all types that implement (maybe not perfect term) a type class?
12:49:48 <ski> hm, doesn't mixins allow implementation in them ?
12:49:54 <Cho0fool_> k00mi: What can i do about? Can parallel save me from that?
12:50:32 <geekosaur> not correct, but less utterly wrong than some. thing about typeclasses is they in many ways work backwards from what you expect in OOP
12:51:15 <jesyspa> Is it correct to think of them as (roughly) what concepts were supposed to be in C++? :P
12:52:05 <S_J> is it possible to load bitmaps or gifs with glut?
12:52:10 * ski doesn't know concepts in supposed-to-be-C++
12:52:36 <k00mi> Cho0fool_: no, profiling will help you fix the problem
12:53:27 <ski> alastor__ : i think interfaces are sortof right, though with several "buts"
12:54:01 <alastor__> ski but, in general, interfaces are just signatures, right?
12:54:45 <Cho0fool_> k00mi: I'm not sure how can i profile my haskell programs. Can you give me a few hints where to start? Alreade have done +RTS -s, nothing usefull besides GC time.
12:55:09 <ski> alastor__ : e.g. in Haskell `Ord a => ..a..a..' is different from `(Ord a,Ord b) => ..a..b..', while with interfaces i think it's hard to distinguish between those
12:56:03 <ski> alastor__ : yes, interfaces has no implementation. so with type classes
12:56:31 <alastor__> hmm i see, thanks ski
12:56:36 <jesyspa> alastor__: xs :: Eq a => [a] would allow you to have both an Int and a Bool in xs if we were talking about interfaces, but you can't have that with typeclasses.
12:56:40 <ski> (modulo defaults -- which imo ought to be thought of as executable laws)
12:57:36 <k00mi> Cho0fool_: this seems good: http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/profiling.html
12:58:13 <ski> (i see jesyspa's point is perhaps a better way to approach my "e.g. in Haskell ...")
12:58:41 <notasi> could somebody answer a quick question? I'm trying to understand how the type ((->) a) is made a functor.  If I understand correctly, ((->)a) is the type of a function which takes a single paremeter of type a
12:58:57 <notasi> So that ((->) Int) Int would be the same as Int -> Int
12:59:03 <ski> alastor__ : however, a Java interface *is* a type, while a Haskell type class is a *predicate* on types
12:59:27 <notasi> SO what would the type of fmap be for these kinds of functors?
12:59:30 <ski> alastor__ : also, type classes can have multiple arguments, yielding *relations* between types
12:59:39 <k00mi> Cho0fool_: or rather, the newer version: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/profiling.html
12:59:51 <jesyspa> alastor__: Yeah, better put: List<Eq> li in Java lets you insert true and 3 into li; xs :: Eq a => [a] in Haskell does *not* allow xs = [True, 3].
13:00:06 <ski> notasi : the type of `fmap' for a given functor `f' must be `forall a b. (a -> b) -> (f a -> f b)'
13:01:07 <ski> notasi : renaming `a',`b' to `b',`c' in there and plugging `(->) a' for `f', the type becomes `forall b c. (b -> c) -> ((->) a b -> (->) a c)', iow `(b -> c) -> ((a -> b) -> (a -> c))'
13:01:14 <ski> @type (.)
13:01:15 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:01:55 <alastor__> jesyspa: oh i see so in haskell you only allow one type to be used which would raise an error if you tried to use two different types even though both implement said type class.
13:02:29 <ski> jesyspa : a complication here is that `Eq a => [a]' isn't actually the type you were looking for ..
13:02:46 <jesyspa> ski: Drat.  Which one was I looking for?
13:03:26 <ski> jesyspa : you were (i believe) looking for : `xs :: [a]' for some particular type `a' where `Eq a' is known
13:03:32 <notasi> so fmap for those functions would be fmap = . or more explicitly fmap f g = (\x -> f $ g x). Thanks
13:03:47 <jesyspa> alastor__: Don't trust me on this, but I read xs :: Eq a => [a] as "for every type a in Eq, xs has type [a]".  I'll probably be told now how that's wrong. :P
13:04:02 <ski> jesyspa : perhaps one could state this as `xs :: Eq a *> [a]' (in any case, note that there's no intended implicit `forall a. ' in this case)
13:04:55 <jesyspa> ski: Ehh, the [True, 3] example is a little too Java-ish, I think; I can't really come up with a way to even formulate it in Haskell.
13:05:16 <ski> jesyspa : yes, "for every type a in Eq, xs has type [a]" is a correct reading of `xs :: Eq a => [a]', but the only (non-silly) example of such an `xs' is the empty list -- which was why i thought that you didn't intend this here
13:06:08 <jesyspa> ski: Hmm, let's say you have a function f :: Eq a => [a] -> [a], f x = ...  What would you say the type of x is?
13:06:12 <ski> jesyspa : if you define `define Equatable = forall a. Eq a => WrapEq a', then you could say `[WrapEq True,WrapEq 3]'
13:06:38 <jesyspa> I must admit I've never even heard of the define keyword...  Is it an extension?
13:06:50 <ski> er
13:06:57 <ski> `data Equatable = ...'
13:07:00 <ski> sorry
13:07:46 <ski> notasi : yes, though `fmap = (.)' will avoid the syntax error :)
13:08:08 <jesyspa> ski: Ah, okay.  Well, I'll have to read up on what happens when you place the forall there; I'm not that far yet.
13:08:27 <shlevy> I need a function that takes 2 lists of lists and results in a list of lists containing every combination of "concat some list from A and some list from B"
13:08:33 <ski> jesyspa : anyway, you need the `ExistentialQuantification' extension for this `Equatable'
13:08:46 <shlevy> Does that exist? It seems like it or its building blocks are general enough to be used often
13:08:55 <c_wraith> Also, that existential is entirely useless. When are you going to get to that point, ski?
13:09:00 <shlevy> And it kind of makes me think of the list monad
13:09:33 <ski> > liftM2 (++) ["ab","c"] ["0","12","345"]  -- shlevy ?
13:09:34 <lambdabot>   ["ab0","ab12","ab345","c0","c12","c345"]
13:09:51 <shlevy> ski: Ah yes perfect!
13:10:00 <shlevy> I knew the monad connaction was right :)
13:10:01 <shlevy> Thank you
13:10:10 <ski> > [xs ++ ys | xs <- ["ab","c"] , ys <- ["0","12","345"]]  -- the same thing, as a list comprehension
13:10:11 <lambdabot>   ["ab0","ab12","ab345","c0","c12","c345"]
13:10:51 <jesyspa> (++) <$> ["ab","c"] <*> ["0","12","345"] -- also works, right?
13:11:03 <ocharles> woohoo, asteroids clone in netwire finished and blogged about!
13:11:08 <ski> c_wraith : i don't know, we'll see ?
13:11:20 <ski> jesyspa : yep
13:11:30 <c_wraith> ski: I suppose it's not 100% useless.  You can use it to test if an Eq instance is reflexive or not. >_>
13:12:23 <jesyspa> ski: But, in the f :: Eq a => [a] -> [a], f x = ... , what would you say the type of x is?  Seeing as for every instantiation it has a type, but you can't use it.
13:12:48 <ski> jesyspa : do you intend an implicit `forall a.' there or not ?
13:13:30 <jesyspa> ski: Err, let's say yes.
13:13:43 <ski> if you do, then it's working for any `a'; if you don't, then you're talking about some specific `a' (perhaps determined previously)
13:14:14 <c_wraith> I know of one fully-defined value for that type forall a. [a]
13:14:22 <mebaran151> Hey #haskell, I'm working in a simple Writer monad but do not understand how to use listen or listens.  Ideally I'd like to extract the built up log for use in the rest of the computation.  Seems like this is what listen is designed to do but I do not know how to use it
13:14:23 <ski> the usual interpretation in Haskell is the former (unless the type variable(s) in question are already in scope, there's an extension for that)
13:14:47 <jesyspa> ski: If I do, is the type of x exists a. Eq a => [a] or something?
13:15:01 <c_wraith> mebaran151: if you want to do that, it's very likely you'd be happier with State than Writer
13:15:04 <ski> but often when discussing code, it's useful to talk about types of sub-expressions, in terms of unknown, "but not arbitrary", types
13:15:55 <mebaran151> c_wraith: I started with state but I thought it would be nicer to work in Writer, as writer seemd safer with regard to operations; all I want to do is append to the log and sometimes read it back
13:15:56 <notasi> I have another question from the typeclassopedia, in the functor exercises in number 5, what does it mean when it says "the composition of two functors"?
13:16:30 <mebaran151> Am I misinterpreting the use case of listen and listens?
13:16:38 <ski> jesyspa : if you do intend the `forall a.' then the type signature is really `f :: forall a. Eq a => [a] -> [a]', and can be pronounced as "for every type `a' which is in class `Eq', `f' can take a list of `a's, and return a list of `a's"
13:16:39 <elliott> notasi: the functor given by newtype Compose f g a = Compose (f (g a))
13:16:44 <elliott> (a functor whenever f and g are)
13:17:08 <jesyspa> ski: Thanks, I see.
13:18:49 <ski> notasi : `Maybe' is a functor, and `Either e' is also a functor (for any `e'), the type function which given any type (say `x') first transforms it with `Either e', and then with `Maybe', iow `Maybe (Either e)' is the composition of the two type functions `Maybe' and `Either e'
13:21:47 <c_wraith> mebaran151: you can use listen to get the value written by an action - but the control flow is a bit weird.  You don't build up a written value then get it out with listen. You pass listen the action you want to extract the written value from.
13:22:03 <c_wraith> mebaran151: doing it with state gives you much more linear control flow.
13:22:26 <ski> @type listen
13:22:26 <lambdabot> MonadWriter w m => m a -> m (a, w)
13:22:47 <ski> @type liftM ($) . listen
13:22:47 <lambdabot>     Couldn't match type `(a1, w0)' with `a0 -> b0'
13:22:48 <lambdabot>     Expected type: m0 a1 -> m0 (a0 -> b0)
13:22:48 <lambdabot>       Actual type: m0 a1 -> m0 (a1, w0)
13:22:56 <edwardk> ReinH: back
13:23:01 <ski> @type liftM (uncurry ($)) . listen
13:23:02 <lambdabot> MonadWriter b m => m (b -> r) -> m r
13:23:08 <Taslem> Can lambdabot turn list comprehensions into the corresponding do notation? Is that always possible?
13:23:20 <ski> @undo [() | False]
13:23:20 <lambdabot> if False then [()] else []
13:23:35 <edwardk> Taslem: it is possible. i don't think anyone bothered though
13:23:41 <edwardk> Taslem: its fairly mechanical
13:23:50 <Taslem> @undo [x | x <- [1,2,3]]
13:23:50 <lambdabot> concatMap (\ x -> [x]) [1, 2, 3]
13:23:55 <Taslem> @undo [x | x <- [1,2,3], x <- [1,2,3]]
13:23:56 <lambdabot> concatMap (\ x -> concatMap (\ x -> [x]) [1, 2, 3]) [1, 2, 3]
13:24:03 <S_J> is there a good channel to discuss Haskell & openGL/graphics?
13:24:10 <monochrom> I can do it for you
13:24:13 <geekosaur> @. redo undo [x | x <- [1,2,3], x <- [1,2,3]]
13:24:13 <lambdabot> Plugin `compose' failed with: Unknown command: "redo"
13:24:14 <edwardk> S_J: there is #haskell-game
13:24:19 <geekosaur> hm
13:24:45 <ski> `do', not `redo'
13:24:55 <ski> (not that it helps in this case, though)
13:24:58 <geekosaur> @. do undo [x | x <- [1,2,3], x <- [1,2,3]]
13:24:58 <lambdabot> concatMap (\ x -> concatMap (\ x -> [x]) [1, 2, 3]) [1, 2, 3]
13:25:00 <geekosaur> bah
13:25:08 <monochrom> "do, or undo. there is no redo." :)
13:25:11 <geekosaur> right, it only comprehends >>= and friends
13:25:19 <Taslem> @. do undo undo [x | x <- [1,2,3], x <- [1,2,3]]
13:25:20 <lambdabot> undo (concatMap (\ x -> concatMap (\ x -> [x]) [1, 2, 3]) [1, 2, 3])
13:25:25 <Taslem> @. do undo pl undo [x | x <- [1,2,3], x <- [1,2,3]]
13:25:26 <lambdabot> pl undo (concatMap (\ x -> concatMap (\ x -> [x]) [1, 2, 3]) [1, 2, 3])
13:25:37 <Taslem> @. pl undo [x | x <- [1,2,3], x <- [1,2,3]]
13:25:40 <ski> @remember monochrom "do, or undo. there is no redo." :)
13:25:40 <lambdabot> concatMap (const (concatMap (: []) [1, 2, 3])) [1, 2, 3]
13:25:40 <lambdabot> optimization suspended, use @pl-resume to continue.
13:25:40 <lambdabot> It is forever etched in my memory.
13:25:54 <Taslem> @pl-resume
13:26:00 <lambdabot> concatMap (const (concatMap (: []) [1, 2, 3])) [1, 2, 3]
13:26:01 <lambdabot> optimization suspended, use @pl-resume to continue.
13:26:01 <geekosaur> you'd need an extra @. in there to chain 3
13:26:06 <geekosaur> but I forget how it's done
13:26:08 <Taslem> Ah I see that
13:26:16 <Taslem> @. do @. pl undo [x | x <- [1,2,3], x <- [1,2,3]]
13:26:16 <lambdabot> Plugin `compose' failed with: Unknown command: "@."
13:26:26 <ski> @. type . do undo [x | x <- [1,2,3], x <- [1,2,3]]
13:26:27 <Taslem> @.. do pl undo [x | x <- [1,2,3], x <- [1,2,3]]
13:26:27 <lambdabot> Num b => [b]
13:26:27 <lambdabot> undo [x | x <- [1, 2, 3], x <- [1, 2, 3]]
13:26:46 <geekosaur> @. type . do undo [x | x <- [1,2,3], x <- [1,2,3]]
13:26:47 <lambdabot> Num b => [b]
13:26:59 <monochrom> [f x y | x<-m, y<-n] = do { x<-m; y<-n; return (f x y) }
13:27:06 <dolio> @pl concatMap
13:27:06 <lambdabot> (=<<)
13:27:07 <wojtekM_> Would somebody smar be kind enough to fix aeson-schema build error? It is way, way over my head.
13:27:29 <Taslem> @undo [ x | x <- [2,4..], x <- [3,6..] ]
13:27:29 <lambdabot> concatMap (\ x -> concatMap (\ x -> [x]) [3, 6 ..]) [2, 4 ..]
13:28:00 <monochrom> = do { _ <- [2,4..], x <- [3,6..]; return x }
13:28:06 <Taslem> @pl concatMap (\ x -> concatMap (\ y -> [y]) [3, 6 ..]) [2, 4 ..]
13:28:09 <lambdabot> concatMap (const (concatMap (: []) [3,6..])) [2,4..]
13:28:09 <lambdabot> optimization suspended, use @pl-resume to continue.
13:29:44 <ReinH> edwardk: ping
13:29:50 <edwardk> pong
13:30:04 <ReinH> edwardk: so for hashlife, I feel like I'm missing a key insight. But I don't know what that key insight is. :(
13:30:30 <jophish_> I have: foo :: Monad m => m a and bar :: Monad m => m [a]. Is there a cons-like function to do something along the lines of foo:bar
13:30:31 <edwardk> doh
13:30:36 <ReinH> edwardk: can I just throw some things out there and you can tell me if they make any sense?
13:30:39 <jophish_> I couldn't find anything on hoogle for this?
13:30:45 <edwardk> throw some code in a paste
13:30:51 <ReinH> edwardk: I'm not even at that point yet
13:30:54 <jophish_> If there isn't a function for this, what would be the neatest way of doing it?
13:31:23 <mbrock> :t liftM2 (:)
13:31:23 <lambdabot> Monad m => m a1 -> m [a1] -> m [a1]
13:31:33 <ReinH> edwardk: am I correct in thinking that I can't do it using Store?
13:31:49 <jophish_> mbrock: ah, of course. Thank you
13:32:31 <edwardk> ReinH: not sure. haven't thought it through that far. i would presume you can do it with stores where you may grow to larger stores each step or something but i haven't actually worked out the model as i mentioned the other day
13:32:45 <edwardk> my old hashlife was very much imperative soup
13:33:11 <mbrock> jophish_: np :)
13:33:13 <ReinH> edwardk: would using a different functor for experiment (or Pretext) make a difference?
13:33:24 <ReinH> something with the desired "shape"?
13:33:30 <edwardk> phone working yet? ;)
13:33:45 <ReinH> edwardk: hah, one sec
13:36:59 <thetallguy> Is there an extension that enables where clauses on type families?
13:38:23 <thetallguy> I ran into this code, which doesn't compile with 7.6.3:   type family If (switch :: Bool) (true :: k) (false :: k) :: k where  \n   If True  t f = t  \n  If False t f = f
13:39:09 <elliott> you need ghc head
13:39:16 <ReinH> edwardk: pm
13:39:19 <elliott> though that type family doesn't appear to need that syntax
13:41:55 <ReinH> edwardk: brb
13:42:12 <thetallguy> I wish the wiki had versioning
13:42:37 <c_wraith> Oh.  Hmm.  yeah, that type family is closed by virtue of overlapping instances being forbidden.
13:43:32 <c_wraith> though I suppose the error message is clearer if the type family is closed.
13:44:24 <ReinH> edwardk: argh, I'll have to take a rain check :(
13:45:10 <edwardk> rein check it is
13:46:12 <ReinH> there it is
13:46:18 <ReinH> :D
13:46:29 <c_wraith> the puns.. they come in a torrent
13:49:56 <edwardk> c_wraith: sounds messy
13:52:19 <edwardk> anyways you probably don't want to use the store rep
13:57:54 <dagano> what is 'pure' doing in an applicativefunctor context?
13:59:05 <ski> it's embedding a value "trivially" in an applicative functor "environment"
13:59:09 <ion> pure creates an applicative value/action that has no effects other than returning the value that was the parameter to pure.
13:59:49 <dagano> > pure (+2) <*> (Just 2)
13:59:50 <lambdabot>   Just 4
14:00:07 <ski> for a `Maybe'-action there's two possible forms, `Just x', which represents success with result `x', and `Nothing', which represents (anonymous) failure
14:00:09 <notasi> > pure 3 :: Maybe Int
14:00:10 <lambdabot>   Just 3
14:00:29 <ion> pure f <*> pure x = pure (f x)
14:00:30 <ski> so `pure' for `Maybe' just wraps the given value in `Just'
14:00:39 <dagano> > pure 3 :: [Int]
14:00:40 <lambdabot>   [3]
14:01:05 <ski> for lists, the "no effects" case means "return a single value"
14:01:50 <dagano> if i don't 'typecast it', does using pure with <*> create a context/functor wrapping based on the other operand?
14:01:59 <ski> proper list-effects would be zero values (empty list, representing failure), or multiple values (list with more than one element, representing ambiguity/choice/nondeterminism)
14:02:59 <ski> dagano : which applicative functor it uses depends on the context of the `pure foo' call -- usually this context will determine which applicative functor is to be used
14:03:21 <ski> in simple examples in an interactor, an explicit type ascription may be needed to disambiguate
14:03:30 <startling> or not!
14:03:33 <startling> :t pure 12
14:03:33 <lambdabot> (Num a, Applicative f) => f a
14:03:41 <startling> > pure 12
14:03:43 <lambdabot>   No instance for (Control.Applicative.Applicative f0)
14:03:43 <lambdabot>    arising from a use ...
14:04:00 <merijn> > pure 12 :: Maybe Int
14:04:01 <lambdabot>   Just 12
14:04:02 <ski> dagano : in `pure (+ 2) <*> Just 2', the right part fixes the applicative functor to be `Maybe'
14:04:03 <startling> (in GHCI it'll probably default to IO)
14:04:24 <dagano> ski: that makes sense .. thanks
14:04:35 <merijn> dagano: It's better not to think of it as "typecasting" as that's not what going on, think of it as "clarifying the type to the compiler"
14:05:06 <notasi> > pure (join (*)) <*> [1..10]
14:05:07 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
14:05:14 <merijn> dagano: i.e. the ":: Maybe Int" says "I know this can have many possible types, but I want you to know that I *meant* Maybe Int"
14:05:16 <dagano> merijn: yeah i had some hesitation using that term .. casting implies taking it from one to another ... kind of 'state-ish'
14:05:24 <ski> dagano : note that since `pure :: Applicative i => a -> i a', `pure' is "overloaded on the result type"
14:05:50 <merijn> dagano: Usually people just call them "type annotations"
14:06:02 * ski calls them "type ascriptions"
14:06:15 <ski> (i think i saw that term in an ML context)
14:06:41 <dagano> thanks folks .. clearing up the fog, as usual
14:06:51 <ski> happy to help
14:07:05 <ion> > join (*) <$> [1..10]
14:07:05 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
14:07:10 <ion> > (^2) <$> [1..10]
14:07:11 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
14:07:38 <dagano> woah i don't know that other operator
14:07:49 <ion> (<$>)? That’s just fmap.
14:07:58 <dagano> ah
14:08:01 <fylwind> you save 1 character when typing it :)
14:08:06 <ion> f <$> x = pure f <*> x
14:08:13 <dagano> !!!!! my time is valuable
14:08:15 <notasi> you don't have to hit the shift key when typing fmap though
14:08:25 <edwardk> johnw: ping
14:08:29 <ciaranm> don't you have a <$> button on your keyboard?
14:08:38 <Hafydd> Pressing shift doesn't take any time if you do it in parallel.
14:08:49 <edwardk> ciaranm: doesn't everyone? it sits next to the <*> button.
14:08:58 <notasi> I have an APL keyboard
14:09:06 <fylwind> shift makes my pinky hurt after a while
14:09:38 * ski has to press `AltGr' here to produce an `$'
14:09:45 <Hafydd> Toughen up. You've been spending too much time chatting informally on IRC.
14:10:25 <merijn> > (*) <$> Just 2 <*> Just 2 -- <$> looks nice here, compard to pure
14:10:27 <lambdabot>   Just 4
14:10:38 <ion> ski: I sincerely recommend the US International (AltGr dead keys) layout.
14:10:59 <Hafydd> @src <$>
14:10:59 <lambdabot> f <$> a = fmap f a
14:11:04 <Hafydd> @src <*>
14:11:04 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:11:17 <merijn> Hafydd: <*> has no source, it depends on the Applicative
14:11:18 <notasi> <*> has to be implemented for each instance of Applicative
14:11:32 <Hafydd> :t <*>
14:11:33 <lambdabot> parse error on input `<*>'
14:11:37 <notasi> :t (<*>)
14:11:37 <ski> ion : `AltGr' being a dead key ?
14:11:38 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:12:15 <ski> > pure (*) <*> Just 2 <*> Just 3
14:12:16 <lambdabot>   Just 6
14:12:44 <Hafydd> > [(+1), (+2)] <*> [10,100]
14:12:45 <lambdabot>   [11,101,12,102]
14:12:51 <ion> ski: Yeah. You type åäö with AltGr but ` \ directly, $ | with shift etc. It’s an alternative compromise to the fi/se layout that i have been very happy with.
14:13:13 <Cho0fool_> notasi: Impressive.
14:14:02 <ion> Not to mention ; directly
14:14:09 <ski> ion : where would `|' be ? on the left of the digit row ? or on the left of `z' (with `<',`>' mayhaps to the right of `m' ?)
14:14:29 <ion> ski: Exactly like in the normal US layout.
14:14:42 <mhitza> can someone help me decipher the error message http://lpaste.net/91941 ? Why the first one can't be inferred to, and what the second one means
14:17:34 <dagano> > pure (++"!!") <*> ["a","b"]
14:17:35 <lambdabot>   ["a!!","b!!"]
14:17:56 <dagano> fmap (++'!') "ab"
14:18:05 <dagano> > fmap (++'!') "ab"
14:18:05 <startling> dagano, pure f <*> x is f <$> x
14:18:06 <lambdabot>   Couldn't match expected type `[a0]'
14:18:06 <lambdabot>              with actual type `GHC.Type...
14:18:18 <startling> that second one is problematic because of
14:18:21 <startling> :t (++)
14:18:22 <lambdabot> [a] -> [a] -> [a]
14:18:23 <dagano> > fmap (++"!) "ab"
14:18:24 <lambdabot>   <hint>:1:17:
14:18:24 <lambdabot>      lexical error in string/character literal at end of input
14:18:29 <dagano> > fmap (++"!") "ab"
14:18:30 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
14:18:30 <lambdabot>  Expected type...
14:18:38 <dagano> sorry i'm clogging the chat window .. i'll go to ghci
14:18:41 <startling> > fmap (++ "!") ["a", 'b"]
14:18:42 <lambdabot>   <hint>:1:25:
14:18:42 <lambdabot>      lexical error in string/character literal at end of input
14:18:47 <startling> ugh
14:18:57 <startling> > fmap (++ "!") ["a", "b"]
14:18:58 <lambdabot>   ["a!","b!"]
14:19:01 <geekosaur> dagano: you can also /msg or /query lambdabot for a private session
14:19:48 <notasi> :k ZipList
14:19:49 <lambdabot> * -> *
14:19:56 <ski> ion : hm, iiuc `gnome-keyboard-properties', "English (US) English (international AltGr dead keys)" appear to require `AltGr' (i.e. `ISO_Level3_Shift') for `|'
14:20:12 <notasi> take 10 $ pure 3 :: ZipList [Int]
14:20:14 <merijn> dagano: It fails because "(++"!") :: String -> String", but fmap over a String expects Char -> Char
14:20:15 <notasi> > take 10 $ pure 3 :: ZipList [Int]
14:20:16 <lambdabot>   Couldn't match expected type `Control.Applicative.ZipList
14:20:17 <lambdabot>                  ...
14:20:47 <startling> > take 10 . getZipList $ pure 3
14:20:48 <merijn> oh, I'm too slow :p
14:20:48 <lambdabot>   [3,3,3,3,3,3,3,3,3,3]
14:21:01 <notasi> oops, forgot to unwrap
14:21:06 <startling> yep.
14:21:23 <ion> ski: shift-\ (where \ is to the right from h j k l ; ')
14:21:41 <ski> hm, i see
14:23:31 <Cho0fool_> :t flip . fmap .  fmap . flip . fmap . (***)
14:23:32 <lambdabot> (Functor f, Arrow a1) => a1 b1 c -> b -> (b -> f a) -> f ((a -> a1 b' c') -> a1 (b1, b') (c, c'))
14:23:56 <Cho0fool_> :t fmap .  fmap . fmap . (***)
14:23:57 <lambdabot> (Functor f, Functor f1, Functor f2, Arrow a) => a b c -> f (f1 (f2 (a b' c'))) -> f (f1 (f2 (a (b, b') (c, c'))))
14:25:00 <Cho0fool_> :t (***) . fmap . (***) . (&&&)  . fmap . fmap . (***)
14:25:00 <lambdabot> (Functor f, Functor f1, Functor f2, Arrow a) => a b c -> (b' -> c') -> (f (b'1 -> c'1), b') -> (f ((f1 (f2 (a b'2 c'3)) -> c'2, b'1) -> (f1 (f2 (a b'2 c'3)) -> (f1 (f2 (a (b, b'2) (c, c'3))), c'2),
14:25:01 <lambdabot> c'1)), c')
14:25:04 <Cho0fool_> Whoa.
14:25:08 <Cho0fool_> Sorry for spam.
14:25:35 <applikat1v> mhitza: isnt something like this more what you mean? http://lpaste.net/91942
14:26:21 <mhitza> applikat1v, actually no
14:26:54 <mhitza> I have something like withCommandLine $ withGui $ do ... in my code, where I'd like withCommandLine to define the implicit parameter to use in the final function
14:27:49 <applikat1v> right, so you define withCommandLine :: (?hiddenParam :: XYZ) => ...
14:28:17 <ski> @type (fmap .) . (***)
14:28:17 <lambdabot> Functor f => (b -> c) -> (b' -> c') -> f (b, b') -> f (c, c')
14:28:25 <applikat1v> then do param <- fmap parse getArgs; let ?hiddenParam = param ; ...}
14:28:52 <mhitza> applikat1v, is what you'r hinting at something akin to http://lpaste.net/91943 ?
14:29:38 <applikat1v> callB is what i'm thinking of; i don't really understand callA
14:29:41 <ski> applikat1v : hm, i would've assumed something like `withCommandLine :: ((?hiddenParam :: XYZ) => ...) -> ...' would be appropriate ..
14:30:11 <applikat1v> ski: oh maybe
14:30:20 <applikat1v> ski: did you see the first one?
14:30:34 <applikat1v> i was trying to reason about this http://lpaste.net/91941
14:30:45 <ski> i only saw from "<applikat1v> mhitza: isnt something like this ..."
14:32:51 <hpaste> dmj pasted “bitonic” at http://lpaste.net/91944
14:33:07 <dagano> (*) <$> (fromEnum getChar) <*> (fromEnum getChar)
14:33:13 <hpaste> dmj revised “bitonic”: “bitonic finger tree” at http://lpaste.net/91944
14:33:14 <dagano> why not?
14:33:17 <ski> applikat1v : in <http://lpaste.net/91941> `?implicit' is locally set by `callA', while in `<http://lpaste.net/91942> it is locally referred to by `callA'
14:33:37 <ski> @type fromEnum getChar
14:33:37 <lambdabot>     No instance for (Enum (IO Char)) arising from a use of `fromEnum'
14:33:38 <lambdabot>     Possible fix: add an instance declaration for (Enum (IO Char))
14:33:38 <lambdabot>     In the expression: fromEnum getChar
14:33:38 <mhitza> applikat1v, I've added better names http://lpaste.net/91941 but I still don't know what I'm doing wrong :(
14:34:08 <ski> dagano : try `(*) <$> liftM fromEnum getChar <*> liftM fromEnum getChar' ?
14:34:48 <dagano> ski:  oh getChar does getChar yield a Char or an IO Char?
14:35:03 <Taslem> @type getChar
14:35:04 <lambdabot> IO Char
14:35:32 <dagano> yeah i have trouble understanding "IO Char"
14:35:43 <dagano> IO is a type constructor and Char is a parameter?
14:36:10 <mhitza> dagano,  IO is the context, Char is the value
14:36:12 <ski> mhitza : i think `defineImplicit :: IO () -> IO ()' ought to be `defineImplicit :: ((?implicit :: String) => IO ()) -> IO ()' (or maybe something like `defineImplicit :: (forall a. Show a => (?implicit :: String) => IO ()) -> IO ()')
14:36:33 <geekosaur> yes. you can informally understand this that getChar returns a runnable action which at rumtime will fetch a character. note that it does *not* actually return a Char itself
14:36:33 <mhitza> ski, ok, let me try that out
14:36:37 <applikat1v> right, some signature like that
14:36:53 <dmj`> arkeet: rewrote the bitonic sequence with finger trees (aka Data.Sequence)
14:37:00 <geekosaur> one can use do notation or the >>= operator to chain these actions
14:37:36 <S_J> Can't exec program: /usr/bin/ghci.exe
14:37:37 <S_J> Process haskell exited abnormally with code 1
14:37:37 <S_J> Can't exec program: /usr/bin/ghci.exe
14:37:43 <ski> dagano : a value of type `IO Char' is a "recipe" (or "list of (I/O) instructions", if you prefer) of how to do Input/Output interactions with the OS to obtain an `Char' -- depending on the time and state of the system when these instructions are followed, you may get differing results
14:37:48 <S_J> is that bc of permission? what do I do?¨
14:38:19 <geekosaur> so: (getChar >>= \c -> putChar c) or (getChar >>= putChar) or (do c <- getChar; putChar c) are chained actions which will get a character and then display it
14:38:53 <geekosaur> (all of them are identical, in fact; do notation is translated by the compiler into >>=)
14:39:27 <dagano> that's helpful
14:39:47 <ski> @quote recipe
14:39:48 <lambdabot> ski says: <ski> `getLine :: IO String' is a recipe for how to interact with the world to acquire a `String'  <ski> the recipe is not the cake
14:39:48 <mhitza> ski, with your first proposed signature it seems to work (although it required RankNTypes)
14:39:53 <dagano> do notation is nicer than that other monster
14:40:10 * ski grins
14:40:22 <ReinH> dagano: an IO a is often called an "IO action that returns an a", and for any Monad m, m a is often called a "monadic action that produces an a"
14:40:25 <applikat1v> suddenly vector is a boot package, or whatever you call it, in ghc-head; this messes with my plan
14:40:56 <ReinH> dagano: this gets across the important point that the value provided by getChar is not a Char, it is a way to get a Char from some IO context when evaluated
14:41:07 <ski> mhitza : `defineImplicit :: ((?implicit :: String) => IO ()) -> IO ()' declares that `defineImplicit' will accept an `IO'-action (with "uninteresting" `()' result), which may depend on an implicit parameter with name `implicit' and type `String'
14:41:16 <dagano> which helps you to stay 'pure'?
14:42:03 <ReinH> dagano: the important distinction is that getChar does not perform IO itself. Like ski said, it creates a "recipe" or "action" that must be evaluated. That evaluation is what performs the IO.
14:42:08 <mhitza> ski, that's clear, albeit not the fact why it requires RankNTypes. Not having dealt much with extensions up until now, I'm reading into that now
14:42:34 <ski> mhitza : sorry, the second alternative above was meant to be `defineImplicit :: (forall a. Show a => (?implicit :: a) => IO ()) -> IO ()' actually -- this is in case you don't want the provided `IO'-action (the argument of `defineImplicit') to know that `?implicit' has type `String', only letting it know that it has a type which is in type class `Show' (so that stuff like `show',`print' can be applied to it)
14:43:34 <ReinH> dagano: one way to demonstrate this is:
14:43:35 <ski> mhitza : this second form (with `forall a.' "inside" the left of the main `->' in the type) is a proper "Rank-2" type
14:43:43 <ReinH> :t fmap putChar getChar
14:43:44 <lambdabot> IO (IO ())
14:43:44 <dagano> how do you look at the intersection between functional purity and the need for IO/state?
14:44:04 <ski> mhitza : but even if you don't use `forall' there, and only `=>', it's still handled by the same machinery as rank-`n' types
14:44:06 <dagano> ReinH: ok
14:44:06 <notasi> :t join $ fmap putChar getChar
14:44:07 <lambdabot> IO ()
14:44:15 <ReinH> dagano: this will not get a character or put a character
14:44:30 <arkeet> :t putChar =<< getChar
14:44:31 <lambdabot> IO ()
14:44:31 <ReinH> it is just a sequence of IO actions, not the actual IO itself
14:44:40 <ReinH> you have to join them in order to do any actual IO
14:44:47 <ReinH> :t join $ fmap putChar getChar
14:44:48 <lambdabot> IO ()
14:44:59 <dagano> ReinH:  is join same as bind?
14:45:01 <ski> mhitza : a function of type `forall a. Int -> [a] -> Maybe a' (e.g.) is *polymorphic*, it will work for *any* actual type we use in place of `a'
14:45:10 <ReinH> :t join -- dagano
14:45:11 <lambdabot> Monad m => m (m a) -> m a
14:45:12 <notasi> :t getChar >>= putChar
14:45:12 <lambdabot> IO ()
14:45:13 <arkeet> join (fmap f x)  =  f =<< x
14:45:16 <ski> (mhitza : the type itself might be called a "universal type")
14:45:22 <S_J> :t join
14:45:23 <lambdabot> Monad m => m (m a) -> m a
14:45:27 <dagano> :t (=<<)
14:45:27 <lambdabot> Monad m => (a -> m b) -> m a -> m b
14:45:39 <S_J> > Join $ Just Nothing
14:45:40 <lambdabot>   Not in scope: data constructor `Join'
14:45:41 <dagano> ah ok
14:45:50 <ReinH> dagano: join combines the two IO contexts together
14:45:52 <S_J> > join $ Just Nothing
14:45:52 <mhitza> ski, stupid question maybe, but how would it differ if "forall a" wouldn't be part of the signature?
14:45:53 <lambdabot>   Nothing
14:46:03 <S_J> isnt join a pretty bad name?
14:46:07 <S_J> @src join
14:46:07 <lambdabot> join x =  x >>= id
14:46:22 <ski> mhitza : however, if you have a function with a type like `(forall a. Maybe a -> [a]) -> Integer', then such a function is not in itself a polymorphic function; it is a function that *expects* a polymorphic function as argument !
14:46:38 <S_J> > Just 5 >>= return . (+1)
14:46:39 <lambdabot>   Just 6
14:46:45 <S_J> > Just 5 >>= return . id
14:46:46 <lambdabot>   Just 5
14:46:51 <ski> mhitza : well, (normally), if you omit the (outermost) `forall's, they will be implicitly inserted
14:46:55 <ReinH> dagano: another way to think of it is that (>>=) = join.fmap
14:46:56 <notasi> I'm trying to figure out the Monad instance of ((->) a) now, I get that return is const, but I can't figure out bind. I tried (.) but the types are wrong. Could somebody give me a hint?
14:47:04 <startling> :t const 12 :: (forall a. Maybe a -> [a])
14:47:04 <augur> > liftM (+1) (Just 5)
14:47:05 <lambdabot>     No instance for (Num [a1]) arising from the literal `12'
14:47:05 <lambdabot>     Possible fix: add an instance declaration for (Num [a1])
14:47:05 <lambdabot>     In the first argument of `const', namely `12'
14:47:05 <lambdabot>   Just 6
14:47:13 <ski> mhitza : so `foo :: Int -> [a] -> Maybe a' will (normally) be interpreted as `foo :: forall a. Int -> [a] -> Maybe a'
14:47:16 <arkeet> notasi: look at what the type *should* be.
14:47:19 <augur> (+1) `ap` Just 5
14:47:23 <startling> :t const 12 :: (forall a. Maybe a -> [a]) -> Integer
14:47:24 <lambdabot> (forall a. Maybe a -> [a]) -> Integer
14:47:24 <jophish_> How simply can this be done, there doesn't seem to be anything in the prelude for it: [a] -> (a -> b) -> [(a,b)]
14:47:28 <augur> > (+1) `ap` Just 5
14:47:28 <arkeet> notasi: and then try to come up with an implementation that matches the type.
14:47:29 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (a0 -> b0)'
14:47:29 <lambdabot>              wit...
14:47:34 <notasi> I did, I got (e -> a) -> (a -> (e -> b)) -> (e -> b) for ((->) e)
14:47:39 <elliott> jophish_: use map.
14:47:53 <augur> > (+1) <$> Just 5
14:47:54 <lambdabot>   Just 6
14:48:00 <augur> poor lambda bot today.. :x
14:48:07 <jophish_> elliott: yeah, that's what I have at the moment
14:48:08 <ski> S_J : you might think of `join' as joining (or collapsing together) two "monadic levels"
14:48:15 <notasi> he needs a work out once in a while
14:48:27 <arkeet> notasi: ok, so if I give you f :: e -> a, g :: a -> e -> b, and e :: e
14:48:33 <ski> S_J : in the `Maybe' case, it's `join :: Maybe (Maybe a) -> Maybe a'
14:48:34 <arkeet> notasi: can you produce me something of type b?
14:48:35 <ReinH> dagano: fmap putChar getChar is, informally "an IO context that puts (an IO context that gets a Char)"
14:48:56 <arkeet> (>>=) f g e = ...
14:48:58 <ReinH> dagano: you can't print "an IO context that gets a Char". You can only print a Char.
14:49:03 <ski> mhitza : and btw, it was not a stupid question
14:49:14 <ReinH> dagano: so you have to evaluate "an IO context that gets a Char" somehow, and that is what join does
14:49:25 <augur> ski, S_J: the way I like to think about it is, "m (m a)" means "a way to compute a way to compute an a", then join says "if i can compute a way to compute an a, then I can compute an a"
14:49:36 <applikat1v> > map (even &&& id) [1..10]
14:49:37 <lambdabot>   [(False,1),(True,2),(False,3),(True,4),(False,5),(True,6),(False,7),(True,8...
14:49:42 <arkeet> (or,  f >>= g = \e -> ...)
14:49:45 <mhitza> ski, but will the the forall a implicitly inserted even for a function of type `(a -> a) -> a -> a` for the first function? as in the function `(a -> a)` will become `(forall a. a -> a)` or that is where rankntypes play a role?
14:49:53 <ski> mhitza : however, this implicit insertion of `forall's will *only* happen on the top/outside of the whole type in a type signature, never "inside" it
14:49:54 <ReinH> dagano: getChar >>= putChar wires the two together automatically
14:49:58 <S_J> :t (&&&)
14:49:59 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
14:50:00 <aristid> augur: but it's not join :: m a -> a :P
14:50:01 <ReinH> dagano: does that make ense?
14:50:08 <dagano> ReinH: a lot more than it did
14:50:19 <augur> aristid: fortunately neither is what you just wrote :)
14:50:25 <S_J> > map ((+1) &&& id) [1,2,3,4]
14:50:26 <augur> aristid: join :: m (m a) -> m a
14:50:27 <lambdabot>   [(2,1),(3,2),(4,3),(5,4)]
14:50:31 <ReinH> dagano: consider the Monad instance for [a] (lists)
14:50:43 <ReinH> dagano: where fmap is map and join is concat
14:50:44 <aristid> augur: i know the type of join.
14:50:57 <aristid> augur: your verbal description of it however is closer to what i wrote.
14:51:02 <S_J> I dont get that, a b c, what type is that? is an arrow a container of 3 types?
14:51:13 <augur> aristid: not at all. "a" means "an a", "m" means "a way to compute"
14:51:22 <ski> @type let f :: (forall a. Maybe a -> [a]) -> Integer; f g = genericLength (g Nothing) * genericLength (g (Just ())) in f
14:51:23 <lambdabot> (forall a. Maybe a -> [a]) -> Integer
14:51:26 <arkeet> S_J: a  is a type constructor that takes 2 arguments.
14:51:30 <arkeet> S_J: such as (->)
14:51:34 <Cho0fool_> extend f w@ ~(_ :| aas) = f w :| case aas of ...
14:51:36 <ski> S_J : depens on what `a' is ..
14:51:44 <Cho0fool_> What does ~ and :| means?
14:51:58 <aristid> augur: aha, well i think you should use a verb other than compute.
14:52:00 <ski> augur : *nod*
14:52:06 <applikat1v> > map (id &&& ord) "jophish_"
14:52:07 <arkeet> Cho0fool_: ~ is a lazy pattern match. :| is a constructor
14:52:07 <lambdabot>   [('j',106),('o',111),('p',112),('h',104),('i',105),('s',115),('h',104),('_'...
14:52:08 <augur> aristid: thats the usual way of viewing it
14:52:22 <aristid> augur: for IO?
14:52:25 <arkeet> Cho0fool_: for ~ see http://www.haskell.org/haskellwiki/Lazy_pattern_match
14:52:26 <augur> aristid: yes
14:52:30 <augur> aristid: for all monads!
14:52:37 <aristid> augur: then i would despair
14:52:45 <jophish_> applikat1v: oh super. Thanks
14:52:49 <Cho0fool_> arkeet: Constructor?
14:52:53 <augur> aristid: then you shall despair :)
14:52:59 <aristid> augur: since when is [a] "a way to compute an a". or Const () a?
14:53:01 <arkeet> Cho0fool_: yes, like Just or (:)
14:53:21 <ski> mhitza : for `f :: (a -> a) -> a -> a' it will only be `f :: forall a. (a -> a) -> a -> a'
14:53:23 <augur> aristid: since [a] meant "a nondeterministic way to compute an a"
14:53:41 <ReinH> arkeet: [a] is a non-deterministic way to compute an a
14:53:46 <arkeet> ReinH: not me
14:53:48 <arkeet> ;)
14:53:50 <ReinH> woops :)
14:53:55 <ski> mhitza : if you intend `f :: (forall a. a -> a) -> a -> a' e.g. (or `f :: (forall a. a -> a) -> (forall a. a -> a)'), then you need `RankNTypes'
14:54:07 <Cho0fool_> arkeet: Ah, i see, thanks for explanation.
14:54:09 <applikat1v> > map (liftM2 (,) id ord) "jophish_"
14:54:10 <aristid> i don't think monads are or should be viewed as restricted to computing values.
14:54:10 <lambdabot>   [('j',106),('o',111),('p',112),('h',104),('i',105),('s',115),('h',104),('_'...
14:54:20 <aristid> even if in some contrived way you can do so for lists.
14:54:28 <augur> aristid: its the standard way of thinking about them.
14:54:33 <augur> at least in haskell world!
14:55:00 <arkeet> Cho0fool_: constructors are words that start with a capital letter or operators that start with :
14:55:03 <aristid> augur: and there i always read that standard way of thinking about them is as a typeclass with two functions and some laws :P
14:55:14 <arkeet> Cho0fool_: (you can think of : as a "uppercase symbol")
14:55:19 <augur> no thats the standard definition of them :)
14:55:22 <ski> aristid : i, for one, prefer generalizing "computing values" to apply to every monad !
14:55:40 <aristid> ski: so how do you contort that to work for Const ()?
14:55:42 <augur> definitions and conceptual schemas are distinct things
14:56:15 <augur> aristid: thats a way to compute an a and throw it away!
14:56:23 <arkeet> no, that's a way to compute no a's
14:56:24 <arkeet> =)
14:56:29 <augur> same thing :)
14:56:31 <aristid> augur: except under lazy evaluation it isn't actually computed.
14:56:39 <ski> if you want, you could think of `Const c' as a "blind computation"
14:56:42 <augur> aristid: mathematics doesnt have lazy evaluation
14:56:44 <arkeet> note: Const () ~ (Void ->)
14:56:58 <arkeet> ski: but Const c isn't a monad unless c is iso to ()
14:57:49 <mhitza> ski, could you maybe detail how you knew from my initial error (Unbound implicit parameter (?implicit::String)) where the problem resided, and why RankNTypes was required?
14:58:05 <augur> aristid: to be fair, i think "compute" is the wrong word too
14:58:09 * applikat1v was unaware that the mathematicians had eagerly evaluated all the digits of e.g. pi
14:58:22 <joelteon> heh, pi is lazy
14:58:25 <aristid> augur: yet you use it?
14:58:26 <augur> computation is about algorithmic processes and its no fair talking about denotations
14:58:35 <aristid> applikat1v: that's what we pay them for!
14:58:37 <augur> aristid: its the standard conceptual schema!
14:58:45 <monochrom> I know all 10 digits appearing in pi :)
14:58:45 <aristid> augur: where is that written?
14:58:54 <applikat1v> > pi
14:58:55 <lambdabot>   3.141592653589793
14:58:59 <arkeet> > pi :: CReal
14:58:59 <lambdabot>   3.1415926535897932384626433832795028841972
14:59:01 <monochrom> (P.S. that sentence works for all bases :) )
14:59:02 <mhitza> ski, because now I understand what problem RankNTypes now solve (thanks for that), but why that was the solution it's still obscure to me :)
14:59:03 <augur> aristid: conventional standards rarely need to be written
14:59:09 <applikat1v> ha
14:59:14 <augur> aristid: anyway, its a useful metaphor
14:59:20 <augur> its not "correct" but its "correct enough"
14:59:26 <arkeet> > showCReal 1000 pi
14:59:26 <ski> mhitza : (it appeared) you wanted `callA' to define `?implicit' for the benefit of its argument. hence that argument must have a type which declares that it is prepared to expect an implicit argument `?implicit'
14:59:27 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
14:59:48 <aristid> augur: meh, i think it's mostly misleading.
14:59:52 <arkeet> I once tried to make a lazy showCReal, but ran into rounding issues.
14:59:55 <augur> aristid: i dont see how
14:59:59 <arkeet> lazy as in produced a lazy infinite string.
15:00:04 <ski> mhitza : so, the type of `callA' would have too look something like `((?implicit :: ...) => ...) -> ...'
15:00:17 <aristid> arkeet: there's nothing generally impossible about it though, is there?:)
15:00:18 <arkeet> unless, of course, the decimal expansion was finite.
15:00:25 <arkeet> this was the hard part.
15:00:40 <ski> mhitza : and this is `RankNTypes', because the `=>' here doesn't occur "at the top" (after the top `forall', if any)
15:00:47 <arkeet> > showCReal 5 1.000000001
15:00:48 <lambdabot>   "1.0"
15:00:52 <arkeet> that was the hard part.
15:01:02 <arkeet> > showCReal 5 0.999999999
15:01:03 <lambdabot>   "1.0"
15:01:16 <augur> aristid: i bet moggi and wadler talk about styles of computation in the earlier haskell papers
15:01:24 <aristid> showCReal 1 is all the digits you'll ever need
15:01:26 <ReinH> dagano: ping
15:01:45 <arkeet> if the decimal expansion appeared to terminate, you couldn't tell if the last digit was correct, or if it was really rounded up because there were lots of 9s following.
15:02:22 <arkeet> and that killed the idea.
15:02:26 <ski> mhitza : do you follow ?
15:02:27 <applikat1v> augur: the use of 'computation' in connection with  'monad' is from moggi, but presumably he didn't know what to say
15:02:33 <aristid> arkeet: just force it to not terminate?
15:02:48 <mhitza> ski, yes I do up to this point, but I'm preparing my next question :)
15:03:00 <arkeet> aristid: well the way I was doing it was repeatedly calling showCReal with larger and larger numbers of digits.
15:03:16 <aristid> applikat1v: do you think "computation" is a good word there, yourself?
15:03:20 <ReinH> I don't get to show him the awesome dice rolling list monad analogy :(
15:03:22 <arkeet> aristid: but it's impossible to tell, even with any finite number of digits, whether it should continue as, say, 4999999999... or 500000000...
15:03:31 <applikat1v> aristid: not really, it doesn't really mean much does it?
15:03:36 <aristid> applikat1v: indeedy
15:03:53 <aristid> arkeet: hmmm
15:04:03 <arkeet> and if you were trying to be conservative, but it really stops at 5, then it would never ever produce that 5.
15:04:42 <aristid> arkeet: if you by convention decide to end all terminating numbers with 99999... would that work?
15:04:47 <arkeet> no.
15:04:50 <aristid> :(
15:04:56 <arkeet> the problem is you don't know it terminates.
15:05:03 <arkeet> it could be 500000000000000000000000000001... for all you know.
15:05:03 <mhitza> ski, so what seems mysterious to me now is that with the last piece of code http://lpaste.net/91941 my `proxy` function obscured the type of `useImplicit` so `defineImplicit` shouldn't receive a conforming function. Yet it compiles and runs just as well
15:05:06 <arkeet> (with a billion 0s)
15:05:21 <aristid> sneaky numbers hiding their digits!
15:05:38 <arkeet> what would be nice is if there was a version of showCReal that didn't round to nearest.
15:05:43 <arkeet> then I could do it.
15:05:47 <arkeet> maybe.
15:05:49 <arkeet> maybe not.
15:05:51 <arkeet> probably not.
15:06:11 <aristid> displaying numbers is hard, let's go shopping
15:06:12 * ski . o O ( "Does Every Real Number Have a Decimal Expansion?" by Luitzen Egbertus Jan Brouwer in 192[01] )
15:06:53 <aristid> ski: crazy name that guy had
15:07:04 <ski> dutch
15:07:06 <aristid> sounds dutch and latin at the same time
15:07:41 * ski has been reading a biography on Brouwer
15:07:57 <aristid> ski: and what was his answer?
15:08:00 <Cho0fool_> arkeet: Im still don't understand. Okay contructors are legitmate to use on lhs of `=' but what about these <@> and where on earhth that :| was defined?
15:08:30 <luite> weird dutchlanders
15:08:33 <applikat1v> Brouwer, the absolute master.
15:08:35 <ski> aristid : that we have no reason to expect that it can be proved
15:08:35 * haasn actually has no idea how the real numbers are defined
15:08:40 <aristid> luite: true dat
15:08:57 <ReinH> haasn: hai
15:09:12 <Cho0fool_> arkeet: https://github.com/ekmett/comonad/blob/master/examples/History.hs#L32
15:09:12 <applikat1v> is luite short of Luitzen ?!?
15:09:19 <arkeet> Cho0fool_: :| is defined as part of the type.
15:09:24 <WanderingMonad> @applikat1v: I was thinking the same thing.
15:09:24 <lambdabot> Unknown command, try @list
15:09:42 <aristid> applikat1v: i think Luite is luite's actual name
15:09:44 <haasn> ReinH: hi
15:09:56 <arkeet> Cho0fool_: the @ is an as-pattern.
15:10:07 <WanderingMonad> applikat1v: "OH GOD, HE FOUND US"
15:10:20 <eikke> anyone knows AlphaHeavy?
15:10:20 <Cho0fool_> arkeet: But what does it means when @ in the <>?
15:10:51 <arkeet> in   extend f w@~(_ :| aas)
15:11:03 <arkeet> it just calls the second argument w, as well as matching it against _ :| aas
15:11:06 <arkeet> er, ~(_ :| aas)
15:11:19 <ski> haasn : three common ways are : (a) a(n infinite) sequence of intervals with rational end-points, each one enclosed in the previous one, with interval-length converging to zero; (b) a sequence of rational numbers, "converging to a real number" (defined as being a "Cauchy-sequence"); (c) partitioning the set of rationals into two non-empty sets, every element of the former being less than every element of the latter (Dedekind cuts)
15:11:30 <arkeet> > let f xxs@(x:xs) = (xxs,x,xs) in f [1,2,3]
15:11:31 <lambdabot>   ([1,2,3],1,[2,3])
15:11:41 <Cho0fool_> arkeet: Yep, it's clear.
15:11:49 <luite> applikat1v: it's my real name, i dunno about the connection between the names
15:11:49 * applikat1v uses 'free choice sequences' so he can just make stuff up
15:12:16 <arkeet> Cho0fool_: I assume :| is a constructor for NonEmpty. http://hackage.haskell.org/packages/archive/semigroups/latest/doc/html/Data-List-NonEmpty.html
15:12:24 <barrucadu> Cho0fool_: <@> is just an operator: http://hackage.haskell.org/packages/archive/comonad/3.1/doc/html/Control-Comonad.html#v:-60--64--62-
15:12:27 <Cho0fool_> > let f xxs<@>(x:xs) = (xxs,x,xs) in f [1,2,3]
15:12:28 <lambdabot>   <hint>:1:5: Parse error in pattern: f
15:12:36 <ski> aristid : also expressable as : if we can prove it, then we can decide every mathematical proposition (law/principle of excluded/third middle, aka principle of omniscience)
15:12:39 <arkeet> oh. <@> is just an operator.
15:12:58 <haasn> ski: I looked at the “Dedekind-complete” characterization on wikipedia
15:13:01 <aristid> ski: sounds like an awesome prove to have.
15:13:07 <aristid> *proof
15:13:11 <Ghoul_> how do I manage a compile time constant with regards a cabal build
15:13:21 <arkeet> Cho0fool_: data NonEmpty a = a :| [a]
15:13:28 <arkeet> or, another way to write it:
15:13:32 <arkeet> data NonEmpty a = (:|) a [a]
15:13:34 <Ghoul_> like, let's say I want to build a thing with cabal, but I want to change a value in the source code without touching the actual source. Is there an easy way to do this?
15:13:35 <arkeet> (:|) is the constructor.
15:13:37 <Cho0fool_> arkeet: Ahhh, got it all now. Thank you.
15:14:06 <Cho0fool_> arkeet: Was confues by <@> but hten realized that this is function name(operator).
15:14:24 <Cho0fool_> confused*
15:14:29 <ski> aristid : this is called a "Brouwerian counter-example", not to be confused with a proper counter-example (i.e. showing that falsity follows from assuming the proposition in question)
15:16:06 <ski> applikat1v : i've been pondering making a library for free choice sequences in Haskell ..
15:17:00 <quchen> notasi: Hey, if you're still looking for how >>= for `(->) r` works, I had this markdown file lying around and just uploaded it: https://github.com/quchen/articles/blob/master/reader_instance_derived.md
15:17:28 <arkeet> notasi: for a lot of monads, it's easier to figure out what  join  is, and then use  x >>= f = join (fmap f x)
15:17:31 <quchen> notasi: It takes the idea of ">>= first takes out a value and then applies a function to it" to write the instance, and then boils it down to the short version.
15:17:34 <prophile> @pl a -> (() -> a)
15:17:35 <lambdabot> (line 1, column 5):
15:17:35 <lambdabot> unexpected '>'
15:17:35 <lambdabot> expecting operator
15:17:37 <arkeet> e.g. for (e -> ), join has type (e -> e -> a) -> (e -> a)
15:17:38 <prophile> uh
15:17:42 <prophile> :hoogle a -> (() -> a)
15:17:49 <prophile> @hoogle a -> (() -> a)
15:17:50 <lambdabot> Control.Parallel.Strategies demanding :: a -> Done -> a
15:17:50 <lambdabot> Control.Parallel.Strategies sparking :: a -> Done -> a
15:17:50 <lambdabot> Prelude asTypeOf :: a -> a -> a
15:17:54 <prophile> :|
15:18:09 <arkeet> then again,
15:18:17 <arkeet> @djinn (e -> a) -> (a -> e -> b) -> (e -> b)
15:18:17 <lambdabot> f a b c = b (a c) c
15:18:19 <applikat1v> @pl prophile a () = a
15:18:19 <lambdabot> (line 1, column 14):
15:18:19 <lambdabot> unexpected ' '
15:18:19 <lambdabot> expecting variable, "(", operator or end of input
15:18:25 <notasi> arkeet: I figured it out on my own, and luckily my implementation matched up with yours
15:18:29 <arkeet> =)
15:18:34 <applikat1v> grr
15:19:21 <prophile> applikat1v: I know it's trivial, just wondering if there was a void-like way of ignoring the parameter in a library
15:19:49 <ski> aristid : a "Brouwerian counter-example" to a proposition is a reduction (i.e. implication) from the proposition to one of a few "Omniscience principles" (these being constructive non-beliefs), of which "Principle of Omniscience / Law of Excluded Middle", that `A \/ not A' for every `A', is the most well-known
15:20:54 <applikat1v> lot of new 'supported-languages' in ghc-head, EmptyCase, NegativeLiterals, NullaryTypeClasses -- kind of negative these
15:21:10 <Cho0fool_> @djinn a -> b
15:21:10 <lambdabot> -- f cannot be realized.
15:21:24 <Cho0fool_> @hoogle a -> b
15:21:24 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:21:24 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
15:21:24 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
15:21:24 <ski> (if case the omniscience principle in question is "Markov's Principle", that for every *dedidable* predicate `P' on naturals, if `not forall n. P(n)' then `exists n. not P(n)', then it's called a "Markovian counter-example")
15:21:33 <elliott> ooh, what is NegativeLiterals?
15:21:41 <Cho0fool_> @djinn (a -> b) -> a -> b
15:21:42 <lambdabot> f a = a
15:22:02 <applikat1v> dunno, elliott I thought you might know...
15:22:05 <ski> applikat1v : ohh, `EmptyCase' :)?
15:22:25 <applikat1v> and the more familiar seeming AutoDeriveTypeable and TypeHoles
15:22:49 <applikat1v> f  = case -> 3
15:23:00 <applikat1v> f  = case of -> 3 ?
15:23:16 <ski> oh, i thought it was `case ... of {}'
15:23:31 <elliott> ski: it is
15:23:53 <applikat1v> oh i see it http://ghc.haskell.org/trac/ghc/ticket/2431
15:23:58 * applikat1v tries
15:24:35 <ski> (another of the omniscience principles is "Limited Principle of Omniscience" (LPO) : for every infinite sequence of booleans, either every element is `False', or there is an element which is `True')
15:25:47 <applikat1v> indeed elliott ski, this typechecks http://sprunge.us/YORK
15:27:31 <ski> mhitza : your `proxy $ useImplicit' doesn't pass the knowledge that `useImplicit' depends upon an implicit parameter `?implicit' to `proxy' (hence it can't manipulate it by locally changing it before invoking it's argument, here `useImplicit'), but `proxy $ useImplicit' itself still depends on this implicit parameter
15:28:13 <ski> (mhitza : when that implicit parameter is received in `proxy $ useImplicit', it will directly be passed implicity to `useImplicit' before invoking `proxy' on the result)
15:28:55 <ski> mhitza : hence `defineImplicit' is still passed an argument that expects to be fed an implicit parameter `?implicit', so it all works out
15:29:38 <ski> elliott,applikat1v : nice :)
15:30:06 <mhitza> ski, so I'm safe to stack any number (and types of functions) between `defineImplicit` and `useImplicit` without breaking that contract? Or are there ways I could brake that?
15:31:11 <ski> mhitza : hm, i suppose it depends on how you "stack" them
15:31:23 <ski> i think for most "normal" simple cases, it would work out fine
15:31:32 <elliott> ski: I think case x of {} just compiles down to (error "foo") though :(
15:31:56 <ski> elliott : it ought to force `x' first, imo
15:32:10 <elliott> ski: yes
15:32:38 <ski> (so that in case `x' had been faked by an `error ...', that would get a chance to be raised as the reason for the evaluation failing)
15:33:09 <mhitza> ski, well I'm thinking just in terms of "normal" stacking (as with my given examples). Thanks for the time in responding to my questions
15:33:12 <ski> iow, `case x of !_ -> error "can't be reached"' would be fine
15:35:51 <ski> mhitza : i think if you had a function with type like `foo :: MonadBlah m => (m a -> m a) -> ...', where the function argument was supposed to be applied over and over again, a number of times, in a nested fashion, so that `foo f ...' would amount to roughly `..(f (f (..(f (...))..)))..' for some number of nested `f's, then you couldn't expect to pass on a (locally *changeable*) implicit parameter through these nested calls
15:36:15 <ski> mhitza : but i don't think this kind of situation would occur that often
15:37:04 <mhitza> ski, I haven't implemented the implicitparams in my code yet, but the function that uses it is invoked from `loop a f = f a >>= \a' -> loop a' f`
15:37:12 <mhitza> maybe that's the exact case you mention?
15:37:31 <ski> i think that as long as you don't locally change implicit parameters, or don't nest the body in this fashion, it will probably work just fine
15:38:13 <mhitza> oh, no I will use the ImplicitParams to send runtime configuration, where a ReaderT would just complicate the code
15:38:48 <ski> @type let loop a f = f a >>= \a -> loop a f in loop
15:38:49 <lambdabot> Monad m => a -> (a -> m a) -> m b
15:39:49 <tabemann> @hoogle (!)
15:39:50 <lambdabot> Prelude (!!) :: [a] -> Int -> a
15:39:50 <lambdabot> Data.List (!!) :: [a] -> Int -> a
15:39:50 <lambdabot> Data.IntMap.Strict (!) :: IntMap a -> Key -> a
15:40:05 <lightquake> is there a better way to write fmap join . sequence $ map f xs?
15:40:28 <Cho0fool_> @hoogle Monad m => a -> (a -> m a) -> m b
15:40:29 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
15:40:29 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
15:40:29 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:40:36 <lightquake> oh, I guess there's join <$> mapM f xs
15:40:58 <ParahSail1n> @src mapM
15:40:58 <lambdabot> mapM f as = sequence (map f as)
15:41:31 <ski> @type \f xs -> fmap join . sequence (map f xs)
15:41:31 <lambdabot> Monad m => (a2 -> a -> m (m a1)) -> [a2] -> a -> [m a1]
15:41:32 <dagano> @src id
15:41:33 <lambdabot> id x = x
15:41:56 <osa1> so I got this exception "Data.Text.Fusion.Common.index: Index too large" any ideas when is it thrown?
15:42:45 <ski> Cho0fool_ : `fullSubst :: Monad m => (var -> m var) -> m var -> m a' sometimes occurs
15:43:10 <bennofs> @where stacktrace
15:43:11 <lambdabot> compile with -prof -fprof-auto -rtsopts and run with +RTS -xc
15:43:24 <bennofs> osa1: ^^
15:44:04 <ski> @type \f xs -> join <$> mapM f xs
15:44:04 <lambdabot> (Monad f, Functor f) => (a1 -> f [a]) -> [a1] -> f [a]
15:44:12 <osa1> bennofs: does that work: cabal-dev install --enable-executable-profiling --enable-library-profiling --disable-documentation --ghc-option=-fprof-auto --ghc-option=-rtsopts ?
15:44:15 <osa1> I'm using cabal
15:44:21 <ski> lightquake : i think i've called it `concatMapM'
15:44:43 <lightquake> ski_: >>=M? :D
15:44:45 <Cho0fool_> ski: fullSubst subst ma = do a <- ma; fullSubst subst (subst a)
15:44:50 <bennofs> osa1: I guess it does
15:44:51 <alastor__> I'm trying to declare a new new to be a parent type of another type: data *Entry a = Post a | Article a* is this the correct way to translate my thinking into haskell code? i'm tyring to make a type Entry  comprise types Post and Article, much in the same way Integer and Natural are both Real numbers
15:45:00 <dagano> > liftA2 (*) (Just 3) (Just 3)
15:45:01 <lambdabot>   Just 9
15:45:06 <osa1> okay, I think that worked. I see lots of stack traces printed
15:45:07 <ski> @type \f as -> concat `liftM` mapM f as
15:45:07 <lambdabot> Monad m => (a1 -> m [a]) -> [a1] -> m [a]
15:45:27 <osa1> is there a way to make them printed only when an exception thrown=
15:45:41 <ParahSail1n> @ty fmap concatMap
15:45:41 <lambdabot> Functor f => f (a -> [b]) -> f ([a] -> [b])
15:45:43 <jmcarthur> :t \f xs -> join `liftM` Data.Traversable.mapM f xs
15:45:44 <lambdabot> (Monad m, Monad m1, Traversable m1) => (a1 -> m (m1 a)) -> m1 a1 -> m (m1 a)
15:45:45 <osa1> otherwise I'm afraid this program never makes it to the point where exception is thrown(going very slow)
15:45:54 <jmcarthur> err
15:46:00 <jmcarthur> :t \f xs -> join <$> Data.Traversable.mapM f xs
15:46:01 <lambdabot> (Monad m, Monad f, Functor f, Traversable m) => (a1 -> f (m a)) -> m a1 -> f (m a)
15:46:07 <jmcarthur> grosser
15:46:19 <merijn> alastor__: Well, it's certainly not wrong, the other approach would be something like "data Category = Post | Article; data Entry a = Entry Category a"
15:46:31 <ski> Cho0fool_ : yes. the name comes from when `m' is an expression monad, with the type parameter expressing occurances of variables in an expression, then `fullSubst' reapplies a given substitution (mapping from variables to expressions which may contain variables) to a given expression (with variables), yielding an expression with no variables left (and hence we can use any "variable" type we like here)
15:46:34 <jmcarthur> :t \f xs -> join <$> Data.Traversable.traverse f xs
15:46:34 <lambdabot> (Monad m, Applicative f, Traversable m) => (a1 -> f (m a)) -> m a1 -> f (m a)
15:46:42 <jmcarthur> that's not so bad
15:47:00 <ski> Cho0fool_ : e.g. `data Expr var = Var var | Add (Expr var) (Expr var) | Neg (Expr var)'
15:47:26 <merijn> alastor__: Which is bettery depends on your goal
15:49:09 <alastor__> merijn: i've tried the code i've mentioned: *data Entry a = Post a | Article a* but it's causing an error: "Multiple declarations of Post". Why this error message since I'm not changing anything about Post, but rather creating another type based from it. It should no more be concerned than an Int is if I create another type called NumberOrString that gathers Ints and Strings.
15:49:29 <ski> alastor__ : note that in `data Entry a = Post a | Article a', `Post' and `Article' wouldn't be types, but (data) constructors -- so, a value of type `Entry a' will either be a value of type `a', together with a tag saying that it's a "post"; or a value of type `a', together with a tag saying that it's an "article"
15:49:52 <merijn> alastor__: Oh, do you have another datatype with a Post constructor?
15:50:06 <merijn> alastor__: You can't have multiple constructors with the same name (at least not in the same module)
15:52:14 * Cho0fool_ amused by first page of #haskell log http://ircbrowse.net/browse/haskell?events_page=1&events_per_page=100
15:52:34 <alastor__> hmm I see thanks merijn , ski
15:52:49 <tabemann> well.... implemented closure comparing so that it SUCCEEDS at comparing closures as long as *no constant* within the functions being compared is A) a primitive or B) a continuation - and as either is unlike to be a constant...
15:53:24 <merijn> alastor__: If you define the other datatype in a different module you could use qualified imports to use the same constructor name twice, but it's a bit inconvenient
15:53:44 <tabemann> (if either is found as a constant it must fail, because there's no way to compare primitives as they are just Haskell closures, and comparing continuations would be very likely to result in infinite loops)
15:58:01 <monochrom> do not deceive yourself by re-using a name. you can't deceive the computer. "data Joy = Bool | Char" does not mean boolean, character, or joy.
15:58:45 <monochrom> "data Joy = Bool | Char" boils down to "data X = A | B".
15:59:28 <monochrom> use meaningless names to discover true meanings
16:02:35 <prophile> this is maybe a stretch, but can https://gist.github.com/prophile/28fa0dfe4fb3ed8163bd be written without the IORefs using recursive do?
16:05:51 <arkeet> prophile: I don't know how recursive do would help with anything.
16:06:05 <arkeet> well
16:06:10 <arkeet> I don't really know what that's supposed to do.
16:06:40 <jmcarthur> prophile: does the x even mean anything or is it just a dummy value?
16:06:58 <danharaj> that x is required because the function that accepts a callback need not use it
16:07:05 <prophile> exactly
16:07:13 <prophile> return x until the callback is called, then return that
16:07:19 <jmcarthur> oh i see
16:07:34 <danharaj> probably you could do this with ContT.
16:07:34 <jmcarthur> yeah, this doesn't sound like anything related to MonadFix
16:07:53 <danharaj> :t callCC
16:07:54 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
16:08:13 <arkeet> seems like all it can do, really, is return the argument of the last time the argument to bind is called.
16:08:15 <arkeet> with x as a default.
16:08:17 <danharaj> That type is way more descriptive when it's correct.
16:08:48 <arkeet> since there's not much else you can do with a value of type IO ().
16:09:02 <jmcarthur> arkeet: bind could use forkIO, so the result could vary over time
16:09:14 <jmcarthur> each time you read it
16:09:14 <danharaj> that is true
16:09:14 <arkeet> urgh
16:09:22 <prophile> I've seen IORefs eaten before with the use of recursive do
16:09:26 <danharaj> so I'm going to say no it can't be done without an ioref
16:09:29 <prophile> just in cases where the result hasn't "leaked" so to speak
16:09:42 <prophile> didn't think so, just thought I'd give it a shot
16:14:04 <ski> @let newCyclicIORef f = mfix (Data.IORef.newIORef . f)
16:14:05 <lambdabot>  .L.hs:142:26:
16:14:05 <lambdabot>      Not in scope: `Data.IORef.newIORef'
16:14:05 <lambdabot>      Perhaps you mean...
16:16:51 <JordiGH> Hi, I'm trying to learn Haskell. As an exercise, I thought it would be fun to try to implement Rijndael. The algorithm is very easy to describe as a sequence of functions that are themselves simple. However, I wouldn't like my implementation to be completely slow.
16:17:35 <sipa> compared to anything in C/asm, it probab
16:17:43 <sipa> yly will be anyway :)
16:18:03 <JordiGH> The problem is bitwise operations. While I'm sure there are modules I can import that will do some of the bitwise operations, out of purely academic interest, is there some sort of fairly primitive Haskell operation that maps directly into hardware bitwise operations?
16:18:32 <JordiGH> Or do people just end up implementing bitwise modules in C?
16:19:05 <mgsloan> JordiGH: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bits.html
16:19:19 <JordiGH> Yes, I know the modules exist. Are they just implemented in С?
16:19:49 <mgsloan> The basic number types are implemented with ghc primitives
16:20:33 <arkeet> have a look at the source for that module :)
16:20:39 <arkeet> instance Bits Int where ...
16:20:44 <JordiGH> Also, for bitstreams, should I use [Bits]? I keep thinking that consed lists will end up becoming linked lists in the underlying implementation.
16:20:46 <arkeet> lots of primitive magic
16:21:26 <Cho0fool_> Inablilty to use negative numbers in pattern matching without parens bugs me.
16:21:53 <JordiGH> I guess there's Bits Words32, which might be sufficient for Rijndael.
16:23:20 <Cho0fool_> Hm, i can't use negative numbers without parens and without confusing compiler anywhere. Well, that undersandable
16:23:25 <haasn> what's a simple way to get a shuffle :: RandomGen g => [a] -> g -> ([a], g) -- function?
16:23:30 <haasn> or shuffleIO :: [a] -> IO [a]
16:23:45 <haasn> I don't care about running any sort of crypto or laplace experiments or anything
16:23:58 <arkeet> haasn: http://hackage.haskell.org/packages/archive/random-shuffle/0.0.4/doc/html/System-Random-Shuffle.html
16:24:04 <haasn> thanks
16:24:12 <jmcarthur> JordiGH: those are mostly primitives, so neither C nor Haskell
16:53:18 <BMeph> BBL - WeenDoze needs a Restart... :\
16:55:17 <dpwright> I have a proxy set up using the pipes module as follows: socketReadS 4096 >-> splitNewlines >-> interpret >-> handle >-> socketWriteD
16:56:37 <dpwright> I would like to combine the first two steps into a function , so that it looks more like read >-> interpret >-> handle >-> write, but defining read as read = socketReadS 4096 >-> splitNewlines and then trying just to use it in-place doesn't work
16:57:32 <dpwright> is there a way to compose proxies and then use the result of that composition in a session like that?
16:57:36 <elliott> the name "read" is taken.
16:57:37 <elliott> :t read
16:57:37 <lambdabot> Read a => String -> a
16:57:53 <dpwright> (socketReadS is a Producer, and splitNewlines a Pipe, by the way)
16:58:17 <elliott> try picking another name.
16:58:39 <dpwright> elliott: I've done "import Prelude hiding (read)" in the file I'm working in
16:59:01 <elliott> oh.
16:59:08 <elliott> try showing the compiler error.
16:59:11 <dpwright> the message I'm getting is a type error:
16:59:25 <arkeet> @where lpaste -- put it here.
16:59:25 <lambdabot> http://lpaste.net/new/haskell
16:59:29 <arkeet> along with the code, I guess.
16:59:52 <dpwright> ah, ok, was about to type it in place, but I guess it's easier to put the whole thing up if I put it there
17:01:50 <elliott> @flush
17:01:51 <elliott> @quit
17:02:05 <elliott> @paste
17:02:19 <lambdabot> Haskell pastebin: http://lpaste.net/
17:05:24 <hpaste> dpwright pasted “Proxy composition compile error” at http://lpaste.net/91948
17:05:47 <hpaste> dpwright revised “Proxy composition compile error”: “Proxy composition compile error” at http://lpaste.net/91948
17:07:21 <dpwright> I think I'm just composing things wrong, but I also wonder whether it's related to the fact that one of those proxies is a Producer and the other a Pipe, so their types are a bit different.  It looks like it's to do with the () the proxies take as their first parameter though..
17:08:14 <dpwright> oh wait
17:08:25 <dpwright> ... I forgot, read is taking the socket as a parameter
17:08:42 <dpwright> which is now going to be passed to the whole (readSocketS >-> splitNewlines)
17:09:13 <dpwright> yeah, changing read to "read s = socketReadS 4096 s >-> splitNewlines" fixed it
17:09:30 <dpwright> thanks!
17:16:25 <ricky_> Hello, everybody. I'm new and have had trouble using cabal
17:16:49 <Guest97639> Every time I I try to use cabal install, I get dependency errors, and I have tried this for multiple packages
17:17:02 <Guest97639> Does anyone know what I'm probably doing wrong?
17:17:41 <davean> Guest97639: Do you have package manager installed packages?
17:18:52 <Guest97639> What do you mean by "package manager installed packages"? What could I enter at the command line to confirm what you're asking?
17:20:20 <byorgey> Guest97639: it's almost impossible to answer your question in general.  If you paste the output from a particular attempt we can probably help you figure out what's going on
17:20:39 <Guest97639> Okay, I'll try again and paste my error
17:21:00 * danharaj loebs a bomb at edwardk
17:21:05 <byorgey> @where paste
17:21:05 <lambdabot> http://lpaste.net/new/haskell
17:21:14 <shachaf> hi maxiepoo
17:21:42 <maxiepoo> shachaf: hey
17:21:44 <shachaf> You were at SEAHUG yesterday, right?
17:21:57 <maxiepoo> yeah
17:22:08 <edwardk> I just posted https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication-part-3    can folks take a proof-reading pass?
17:22:12 <maxiepoo> I remember you
17:23:04 <shachaf> Uh oh.
17:23:24 <Guest97639> Okay, so on one of the packages I tried with sudo and now it worked.
17:23:32 <Guest97639> I installed roots (just a random package from hackage)
17:23:41 <shachaf> OK, you probably shouldn't be using sudo with cabal-install.
17:23:44 <Guest97639> What should I enter at ghci to be able to use the methods
17:23:58 <byorgey> you definitely shouldn't be using sudo with cabal-install.
17:24:00 <Guest97639> Oh, okay. Hmmm...
17:24:08 <byorgey> @where paste
17:24:08 <lambdabot> http://lpaste.net/new/haskell
17:24:21 <byorgey> Guest97639: ^^^ can you paste the output you get when you install without sudo?
17:24:47 <Guest97639> cabal: ghc-pkg: /Users/richardlevan/.ghc/x86_64-darwin-7.6.3/package.conf.d/: openBinaryTempFile: permission denied (Permission denied)
17:26:15 <byorgey> Guest97639: for some reason some files/directories in your .ghc directory are owned by root.
17:26:58 <byorgey> they should not be.
17:27:12 <byorgey> Guest97639: use  sudo chown -R  to change the owner back to you.
17:27:18 <Guest97639> So where is .ghc? Also, as a newbie I'm kind of confused by where everything is stored. Why is it that different libraries and parts of Haskell seem to be scattered across the filesystem?
17:27:37 <byorgey> /Users/richardlevan/.ghc
17:28:05 <Guest97639> (I'm using OSX, for reference)
17:28:15 <byorgey> Guest97639: that's true of everything.  executables go one place, library files go another, documentation goes somewhere else...
17:28:28 <byorgey> that's just the way POSIX systems tend to be organized.
17:29:02 <Guest97639> Gotcha. To me it seems difficult because I don't always know how to find where the problem is. How do experienced users deal with this?
17:31:17 <Guest97639> But on a more specific note, I tried cabal install (without sudo) on another package, AC-Colour. Here is the resulting error:
17:31:31 <Guest97639> cabal: Could not resolve dependencies: trying: AC-Colour-1.1.4 rejecting: base-3.0.3.2, 3.0.3.1 (global constraint requires installed instance) rejecting: base-4.6.0.1/installed-6c3... (conflict: base => ghc-prim==0.3.0.0/installed-d52..., AC-Colour => ghc-prim>=0.1.0.0 && <0.3) rejecting: base-4.6.0.1, 4.6.0.0, 4.5.1.0, 4.5.0.0, 4.4.1.0, 4.4.0.0, 4.3.1.0, 4.3.0.0, 4.2.0.2, 4.2.0.1, 4.2.0.0, 4.1.0.0, 4.0.0.0 (global constraint req
17:33:16 <elliott> that package is too old to work with your GHC.
17:33:20 <elliott> considera nother package, e.g. the colour package
17:33:39 <Guest97639> Okay, thanks. I figured something like that might be the case.
17:33:50 <Guest97639> But why is the package up on Hackage if it is likely not going to work?
17:33:58 <Guest97639> And how in general can one tell good packages from bad packages?
17:34:06 <Guest97639> Is the system really this confusing, or am I just a total newbie?
17:34:27 <elliott> I don't think it's confusing here. I can see itw as last uploaded in 2011, and Hackage built it for GHC 7.2, in http://hackage.haskell.org/package/AC-Colour.
17:34:39 <elliott> the error message says you have ghc-prim 0.3, but it depends on ghc-prim <0.3.
17:34:53 <elliott> actually, packages rarely depend on ghc-prim. so this compiler version conflict is not common
17:35:10 <elliott> it's on Hackage because it worked when it was uploaded :)
17:37:06 <Guest97639> What is the solution? Is there no way to use AC-Colour if I already have ghc-prim 0.3?
17:37:36 <Guest97639> Okay, maybe it was just a bad idea to randomly select a package from hackage to get cabal to work. :)
17:38:55 <Guest97639> How do I check my version of ghc, of base, and of other things like this?
17:39:00 <elliott> you could probably loosen the bound by using "cabal unpack" and modifying the cabal file.
17:39:03 <elliott> but I wouldn't bother.
17:39:11 <elliott> Guest97639: ghc --version, ghc-pkg list
17:40:15 <Guest97639> perfect, thanks
17:40:32 <Guest97639> The Glorious Glasgow Haskell Compilation System, version 7.6.3. Nice :D
17:42:13 <applicative> Guest97639: you can get some clues what the going package for somethings is by looking at http://packdeps.haskellers.com/reverse
17:42:28 <applicative> pardon characteristically idiotic typing
17:42:32 <Guest97639> Is there a chance that my dependencies are already ruined somehow, and the best thing would be to flush all Haskell things from my system and reinstall?
17:43:03 <applicative> does ghc-pkg check say something is broken?  what os are you using?
17:44:39 <dagano> can i update ghc with a ghc flag command?
17:44:53 <applicative> update ghc?
17:45:02 <dagano> i have an old release
17:45:07 <Guest97639> ghc-pkg check returns the following:
17:45:08 <Guest97639> Warning: haddock-interfaces: /Library/Haskell/ghc-7.6.3/lib/haskell-platform-2013.2.0.0/doc/html/haskell-platform.haddock doesn't exist or isn't a file Warning: haddock-html: /Library/Haskell/ghc-7.6.3/lib/haskell-platform-2013.2.0.0/doc/html doesn't exist or isn't a directory
17:45:09 <elliott> Guest97639: so far I haven't heard anything indicative of brokenness from what you said.
17:45:13 <applicative> dagano: you can get a new one.
17:45:21 <elliott> installing AC-Colour would give me the same error
17:45:32 <applicative> Guest97639: that's just haddock subtleties, ie documentation
17:45:53 <dagano> applicative: :) thanks .. i was wondering if ghc had an internal software update method..
17:45:56 <applicative> dagano: what operating system do you use?
17:46:06 <dagano> applicative: debian/ubuntu
17:46:09 <applicative> dagano: no, but it's pretty easy to install
17:46:18 <applicative> i was going to say, except on windows
17:46:25 <dagano> applicative:  yeah i guess apt-get is fine
17:46:48 <applicative> dagano: you can get a more recent one, there is the general linux binary thingy just a sec
17:47:15 <applicative> dagano: http://www.haskell.org/ghc/download_ghc_7_6_3
17:47:36 <dagano> applicative: sweet, thanks
17:47:52 <applicative> dagano: you might look at e.g. http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
17:48:23 <Guest97639> Is there a list of all Haskell-related command line tools? I've used ghc, ghci, ghc-pkg, cabal... I'm wondering if there are others I should know about
17:48:38 <applicative> though there's no reason to install all of the platform.  your existing cabal executable may work just fine with the new ghc, if not you need to build it with the bootstrap.sh as monochrom explains
17:49:12 <Clint> hmm, http://www.haskell.org/ghc/distribution_packages is stale
17:49:46 <applicative> dagano: if you have a cabal evertyhing else you might get from the haskell platform is cabal-installable if you just keep an eye on the C libraries as monochrom again notes
17:50:54 <Clint> alternately the .debs take care of that for you
17:51:15 <applicative> Guest97639: those are the main universally employed executables; there is also runhaskell a/k/a runghc which runs scripts like python x.py
17:51:27 <applicative> that is without compiling in the usual sense
17:51:35 <dagano> applicative: ok thanks .. i have a pretty solid, working version ... and i don't even know what changes have happened in a .2 span ..
17:52:26 <applicative> you might as well have ghc 7.6 if only because bytestring will cause trouble
17:56:37 <Guest97639> There is a package I'd like to install here: http://hackage.haskell.org/packages/archive/data-ordlist/0.4.5/doc/html/Data-List-Ordered.html
17:56:47 <Guest97639> But I'm confused about what to put after "cabal install" on the command line
17:56:59 <carter> the package name
17:57:05 <carter> data-ordist in this case
17:57:12 <applicative> cabal install data-ordlist
17:57:40 <applicative> Guest97639: if you do 'cabal unpack data-ordlist', then cd data-ordlist, you would just type cabal install
17:58:22 * hackagebot tasty-th 0.1.0 - Automagically generate the HUnit- and Quickcheck-bulk-code using Template Haskell.  http://hackage.haskell.org/package/tasty-th-0.1.0 (BennoFuenfstueck)
17:58:31 <applicative> if you are building your own package you would do things like 'cabal configure --enable-tests' 'cabal build' etc
17:58:58 <applicative> from inside the directory with the .cabal file
17:59:13 <begriffs> Haskell debugging question: is there a way to modify a recursive function so that as it runs you can trace its call history? For instance, I'd like to see the changing value of 'n' printed out as the following function calls itself.
17:59:14 <begriffs> collatz :: Integer -> Integer
17:59:15 <begriffs> collatz n
17:59:16 <begriffs>   | n < 2     = 1
17:59:17 <begriffs>   | even n    = collatz $ n `div` 2
17:59:18 <begriffs>   | otherwise = collatz $ n * 3 + 1
17:59:39 <applicative> Guest97639: if you have an .hs file in a directory 'cabal init' will walk you through writing a cabal file
18:00:04 <applicative> begriffs: the quick and dirty way is import Debug.Trace
18:00:34 <applicative> even n = collatz (trace "even" (n `div` 2)) or wherever
18:00:52 <Guest97639> So I did 'cabal unpack data-ordlist'. But this wasn't put in my current directory. How do I cd to data-ordlist?
18:00:58 <begriffs> applicative: can you do it without modifying the code inside collatz, by maybe creating a new debuggable function out of it, and calling the new function instead?
18:01:39 <begriffs> Or by passing in a sneaky modification of the argument type that shows itself when it is accessed or something strange like that?
18:02:15 <applicative> i think youll have better luck with e.g. a sneaky myeven x = trace "even" (even x)
18:02:39 * applicative profess no expertise on debug.trace
18:02:46 <applicative> @quote chromatic
18:02:46 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
18:03:02 <Guest97639> applicative: Why do I want to write a cabal file? What is that?
18:03:23 <applicative> it's instructions how to build the package.
18:04:06 <applicative> Guest97639: you dont need it, it massively simplifies building your own things once they get above a certain complexity, or of course if you want them on hackage
18:04:07 <Guest97639> applicative: Hmmm... what is meant by "build the package"? Are the tools not immediately useable once I've installed them?
18:04:49 <applicative> Guest97639: no, I was thinking ahead to when you write your own package colours-Guest97639
18:05:18 <applicative> but anything on hackage you build and install by saying 'cabal install somepackage', yes
18:05:34 <Guest97639> Haha, I would like to get there at some point! I think Haskell is amazingly beautiful, so I'm trying to get all this package management / command line stuff behind me :)
18:08:28 * hackagebot tasty-th 0.1.1 - Automagically generate the HUnit- and Quickcheck-bulk-code using Template Haskell.  http://hackage.haskell.org/package/tasty-th-0.1.1 (BennoFuenfstueck)
18:11:52 <begriffs> applicative: ohh, this package looks interesting Debug.Hood.Observe
18:13:11 <applicative> there is a debugger inside ghci that seems not to be widely used, though occasionally someone exhibits its cool features
18:13:24 <krez> hello haskellites
18:14:09 <Guest97639> applicative: I just tried 'cabal install data-ordlist', but the following happened:  openBinaryTempFile: permission denied (Permission denied) Failed to install data-ordlist-0.4.5 cabal: Error: some packages failed to install: data-ordlist-0.4.5 failed during the final install step. The exception was: ExitFailure 1
18:15:19 <ski> hm, are the hpastes available somewhere ?
18:15:40 <applicative> i see, Guest97639 there is still something wrong with the setup but permissions are always over my head
18:16:07 <Guest97639> applicative: I see, thanks
18:16:12 <applicative> hi krez
18:17:12 <applicative> oh here's http://packdeps.haskellers.com/reverse in order of 'popularity', which might be of some interest orienting yourself with hackage http://sprunge.us/TaZJ
18:17:48 <Guest97639> applicative: One thing though, I thought at first that "openBinaryTempFile" was some shell thing, but I see it on Hoogle. Do you know how I could find it and thus change the permissions?
18:18:44 <applicative> yes the error is coming from Haskell, but I take it is because it is being told no by the system.
18:19:26 * applicative is a shell-dyslexiac, he just waits for geekosaur to explain
18:23:55 <Clint> Guest97639: you could trace the program execution to find out what it's trying to open
18:24:15 <Guest97639> Clint: Sounds interesting. How do I do that?
18:25:13 <Clint> Guest97639: strace or ktrace or truss or whatever system call tracer your platform happens to have
18:25:19 <ski> ah, mirrored to lpaste
18:25:59 <erisco> > null . takeWhile (<1) $ [1..]
18:26:00 <lambdabot>   True
18:26:13 <ski> begriffs : you could alternatively try my "PoorManDebug" idea at <http://lpaste.net/10060>
18:27:55 <begriffs> ski: how do I use that? (I'm a beginner)
18:28:44 <applicative> wow, ski that is some styling layout there
18:29:01 <begriffs> ski: sorry, I didn't see the example…now I do
18:31:04 <ski> begriffs : you have to "instrument" the code you want to debug the recursive calls of, using this, by introducing a "dummy" monad `m', and by calling an extra argument instead of calling recursively
18:31:04 <applicative> nice, 30 lines of imports followed by 19 of 'code'
18:31:41 <krez> test
18:32:02 * ski bows
18:32:33 <dmwit> Guest97639: Ugh, don't trace cabal-install, just ask cabal-install to tell you what it's doing.
18:32:56 <dmwit> Guest97639: Add -v, -vv, or -vvv to ask it for more details about the commands it plans to execute.
18:33:13 <applicative> oo -vvv really?
18:33:19 <elliott> aka -v3
18:33:33 * applicative has confessed shell dyslexia already
18:33:37 <ski> begriffs : the trace is a tree with a pair of corresponding input and output in each node, and one subtree for each recursive call directly made
18:34:06 <applicative> ski: this my father's Writer monad
18:34:17 <begriffs> ski: have you tried using this Hood observer thing? http://www.ittc.ku.edu/csdl/fpg/software/hood.html
18:34:28 <Guest97639> dmwit: Thanks, I was looking up how to trace and it was getting pretty ugly. I just want to run Haskell, not take a course on operating systems...
18:34:35 <ski> begriffs : i'm aware of Hood, yes
18:34:39 <applicative> Writer is not a constructor, ski ...
18:35:05 <dmwit> Guest97639: Learning to trace is great fun, and works on any program. But cabal-install is well-designed, and so it has more intelligent reporting than what a trace will give you.
18:35:06 <ski> @hackage hood
18:35:06 <lambdabot> http://hackage.haskell.org/package/hood
18:35:22 <ski> applicative : it was when i wrote the code :)
18:35:38 <Guest97639> dmwit: Oh haha, sorry for misjudging it then! Any good resources for learning to trace?
18:36:11 <dmwit> The man page?
18:36:17 <applicative>       (b,ts) = runWriter $ (`ff` a) $ \a -> let (t,b) = f a in writer (b,[t])
18:36:28 <ski> yep
18:37:19 <ski> (though i didn't get that about your father ..)
18:37:55 <Guest97639> dmwit: The man page isn't very descriptive...
18:38:37 <dmwit> Really? What man page are you looking at?
18:38:43 <dmwit> man strace is loooong
18:39:01 <Guest97639> dmwit: man trace. Would dtrace or dtruss be better? I am on OS X by the way
18:39:10 <dmwit> Oh, I have no idea what tool is good on OSX.
18:39:42 <Guest97639> dmwit: Is pretty much everybody here on Linux, and is it implied I ought to be using Linux to have things work right? :P
18:39:49 <dmwit> Anyway, as I said, cabal-install's own reports will be better than what you'll get from a trace.
18:40:08 <dmwit> Linux is the best-supported operating system. But I know at least some people develop in Haskell on OSX and Windows.
18:40:16 <dmwit> With great perseverance, anything is possible.
18:40:22 <elliott> OS X is pretty well-supported.
18:40:32 <dmwit> tell that to the gtk2hs maintainer
18:40:45 <elliott> gtk isn't very well-supported :)
18:40:49 <elliott> (on OS X.)
18:42:07 <applicative>         dtruss prints details on process system calls. It is like a DTrace ver-
18:42:08 <applicative>        sion of truss, and has been designed to be less intrusive than truss.
18:42:20 <danharaj> Haskell on OS X is rather painless
18:42:23 <applicative> seems to be the os x variant
18:42:49 <Guest97639> elliott: Ha, so it's a graphics thing that won't work well. I've heard graphics on haskell is poor in general. Is this true? Today I saw some short code to generate a Mandelbrot set in Haskell, but it used asterisks in the terminal. How hard would it be to do it GUI with color?
18:43:15 <applicative> to make an image is easy.
18:43:17 <elliott> easy. use gloss or diagrams.
18:43:28 <elliott> GTK is just one thing, and its support on OS X has nothing to do with Haskell
18:44:02 <dmwit> http://projects.haskell.org/diagrams/gallery/Mandelbrot.html
18:45:21 <Twey> I notice a lot of stuff (Writer &c.) is defined in terms of transformers now.  Back when I was learning Haskell, there was discussion of replacing all the monads with transformers, but it kept being put off because it introduced a significant degradation of performance.  How was that solved?
18:45:32 <elliott> it probably wasn't.
18:45:39 <Twey> Oh :þ
18:45:49 <applicative> Guest97639: here's some gloss examples, http://gloss.ouroborus.net/
18:46:15 <applicative> hah, that's probably right, Twey
18:46:21 <Guest97639> Useful links, thanks.
18:46:27 <Twey> What changed everyone's minds, then?
18:46:40 <Twey> Just Moore's law?
18:46:43 <Guest97639> But I just got openBinaryTempFile permission denied when I tried to cabal install gloss. :(
18:47:01 <dmwit> dat aliasing
18:47:02 <Guest97639> I know it's a system detail on OS X somehow, but does anyone have recommendations? Should I perhaps just re-install Haskell?
18:47:17 <dmwit> ASK CABAL WHAT IT'S TRYING TO DO
18:47:24 <applicative> Guest this is something about the general setup.  did you look to see what the last command is, using verbose ... cabal install blah -vvv
18:47:29 <dmwit> I am shouting now because we've suggested it several times.
18:47:35 <applicative> oh, like dmwit said
18:47:40 <applicative> ;)
18:48:27 <Guest97639> Ok, will do! Haha a lot of this stuff isn't yet that obvious to me :)
18:48:33 <applicative> Twey: edwardk will be able to explain it all; he seems to curate this history as well as the mtl library
18:48:48 <edwardk> ?
18:48:57 <edwardk> history of mtl/transformers?
18:49:20 <Twey> edwardk: Reasoning between switching from concrete monads to monad transformers
18:49:25 <Guest97639> Okay, so i added -v and a lot of new stuff appeared. I won't paste all of it, but here's from the first place I see some sort of error:
18:49:26 <Guest97639> No c2hs found No cpphs found No ffihugs found Using gcc version 4.2.1 found on system at: /usr/bin/gcc Using ghc version 7.6.3 found on system at: /usr/bin/ghc Using ghc-pkg version 7.6.3 found on system at: /usr/bin/ghc-pkg No greencard found Using haddock version 2.13.2 found on system at: /usr/bin/haddock Using happy version 1.18.10 found on system at: /usr/bin/happy No hmake found Using hpc version 0.6 found on system at: /usr
18:49:27 <edwardk> i seem to be stuck as the amanuensis for that tale
18:49:28 <applicative> oh Twey studied haskell before Writer became WriterT... Identity
18:49:31 <Twey> s/between/regarding/
18:50:14 <applicative> Twey said he remembered performance being a problem with MooT Identity over mere Moo monads
18:50:47 <dmwit> Guest97639: Put it all up on lpaste.
18:50:49 <dmwit> ?hpaste
18:50:49 <lambdabot> Haskell pastebin: http://lpaste.net/
18:51:05 <lightquake> what happened to hpaste?
18:51:15 <dmwit> ISPs lol
18:51:33 <applicative> lightquake: its LAMBDApaste
18:51:49 <dmwit> edwardk: I trust you are using "amanuensis" in the "protecting the multiverse" sense rather than the "good at transcription" sense. ;-)
18:52:07 <hpaste> Ricky pasted “cabal install errors” at http://lpaste.net/91950
18:52:45 <Guest97639> I just tried to paste my terminal output but I got the following result: A web handler threw an exception. Details: /home/chris/hpaste/cache/paste-91950.html: openFile: resource busy (file is locked)
18:53:56 <edwardk> dmwit: meaning i've had to write down the tale of how mtl evolved into its current state far to many times ;)
18:53:58 <hpaste> Ricky pasted “cabal install errors” at http://lpaste.net/91951
18:54:08 <dmwit> Guest97639: I suggest you ls -l ~/.ghc/x86_64-darwin-7.6.3/package.conf.d
18:54:12 <Guest97639> Ok, I just did it again and it worked
18:54:20 <erisco> null . filter (<1) $ [1..]
18:54:24 <erisco> > null . filter (<1) $ [1..]
18:54:27 <shachaf> You might also consider changing your nick to something less generic than Guest97639. :-)
18:54:27 <Guest97639> epic 271 line paste..
18:54:31 <lambdabot>   mueval-core: Time limit exceeded
18:54:43 <erisco> mm yes that is what I was thinking of... not takeWhile
18:54:46 <Guest97639> Good idea :) How do I change my nick?
18:54:52 <applicative> edwardk: i apologize; i'm looking for one of the paragraphs already written; i didnt actually mean to awaken you
18:55:09 <Twey> Heh
18:56:08 <Twey> chrisdone: 014619 < Guest97639> I just tried to paste my terminal output but I got the following result: A web handler threw an exception. Details: /home/chris/hpaste/cache/paste-91950.html: openFile:  resource busy (file is locked)
18:56:38 <shachaf> Depends on your IRC client.
18:56:43 <dmwit> Guest97639: Er, actually, ls -ld is probably more helpful than ls -l in this case.
18:56:50 <applicative> ah well, the google corporation is failing me, Twey
18:56:50 <Twey> chrisdone: emacs analysis was interesting, by the way; did you get a corresponding vi(m) one?
18:56:58 <Twey> applicative: Yeah, me too :-\
18:57:18 <dmwit> Have you tried chrisdone's IRC search thing?
18:58:14 <Guest97639> I was linked from some Haskell page to webchat.freenode.net. This is my first time using an IRC client
18:58:37 <dmwit> Try /nick whatever
18:58:38 <Guest97639> I'm glad I found you guys. :) I was going kind of crazy having things not work by myself
18:59:03 <Guest97639> hm
18:59:30 <rickyl> hey
18:59:32 <rickyl> alright, new name
19:00:02 <rickyl> I guess confusingly that's a lowercase "L", not a 3 minus 2 :P
19:00:30 <applicative> @leet rickyl
19:00:30 <lambdabot> RICxYl
19:01:09 <rickyl> I'm lost, what's "@leet"? Is lambdabot suggesting a new name?
19:01:10 <Twey> dmwit: It's pretty hard to search for
19:01:36 <dmwit> rickyl: No, it's just a joke. Let's see that ls output, please.
19:02:22 <rickyl> dmwit: I'm a bit lost now. Output from what and where do you want to see?
19:03:00 <dmwit> 21:53 < dmwit> Guest97639: I suggest you ls -ld ~/.ghc/x86_64-darwin-7.6.3/package.conf.d
19:03:18 <dmwit> (I'm only editing history a tiny, tiny bit here. ;-)
19:03:39 <rickyl> drwxr-xr-x  7 root  staff  238 Aug 18 19:21 /Users/richardlevan/.ghc/x86_64-darwin-7.6.3/package.conf.d
19:03:42 <rickyl> is what is returned
19:03:44 <Clint> there's your problem
19:03:45 <dmwit> Perhaps that should not be owned by root.
19:04:05 <dmwit> Is it possible you have done some "sudo cabal" stuff or "sudo ghc-pkg" stuff? If so, don't do that again.
19:04:35 <applicative> why the devil , hm.
19:04:43 <dmwit> And in the meantime, you will want to chown -R richardlevan:richardlevan ~/.ghc (as root).
19:04:50 <rickyl> Yeah, that is probably what happened
19:05:02 <applicative> oh it's the .ghc directory itself, strange
19:05:12 <rickyl> I guess I was mirroring "sudo apt-get install" and I thought I had to use sudo for things of this nature
19:05:27 <dmwit> Yeah, that's a pretty common early mistake, I think.
19:05:43 <Twey> I do see a bunch of people recommending rewriting monad transformer stacks as monolithic monads, though.  Maybe it was just decided that writing your own monad is acceptable where performance matters, and transformers are a nicer default.
19:05:47 <applicative> rickyl: if you were doing cabal install --global blah that might make sense, but dont do that either
19:06:15 <dmwit> ...also, beware that ~/.ghc will get expanded differently by your shell and by root's shell.
19:06:29 <dmwit> So that command may not quite be precise if you prefer using su to sudo or whatever.
19:06:38 <applicative> Twey: often these monolithic monads just newtype some transformers thing
19:06:58 <dmwit> gotta run
19:06:59 <dmwit> g'luck
19:07:17 <rickyl> Hm, two things I'm lost on now. In "chown -R richardlevan:richardlevan ..." what is the colon for and my name repeated? Also, what does it mean that ~/.ghc might get expanded differently?
19:07:21 <applicative> rickyl: maybe chown ~/.cabal too
19:07:26 <rickyl> Okay, thanks for the help dmwit!
19:07:41 <dmwit> the colon is to set both user and group
19:07:51 <applicative> i think can just do sudo chown -R /Users/.../.ghc
19:08:01 <applicative> woops forgot your name
19:08:04 <dmwit> ~ isn't a real path, it's expanded by your shell
19:08:15 <dmwit> so what applicative is saying avoids that subtlty
19:08:39 <applicative> sudo chown -R applicative .ghc , inside my home directory works I think
19:08:45 <dmwit> *subtlety
19:09:02 <applicative> in the past for some reason i couldn't call gcc without sudo and did that frequently
19:09:12 <applicative> it was so much easier than figuring out anything about the gcc
19:09:49 <chenwl> what is 'free' mean in the term 'free monad'
19:10:03 <applicative> not restricted by any equalities or laws
19:10:22 <rickyl> Okay, I succeeded in chown
19:10:30 <shachaf> https://en.wikipedia.org/wiki/Free_object
19:10:56 <shachaf> That article might not help you much but that's what it means. :-)
19:11:02 <applicative> the usual abstract definitions are worthless; the concept way predates category theory for example
19:12:57 <rickyl> Ahhh after I changed ownership of .ghc recursively, cabal install is working! Awesome, thanks :D
19:13:18 <chenwl> any examples of simple free monad? compare it with Maybe Error monads may help
19:13:54 <rickyl> Okay, so I succeeded in cabal install gloss. But now that it is on my machine, how can I start seeing some visuals? Should I enter things in ghci, or what's the standard way of exploring a new package?
19:14:01 <applicative> the jargon is 'the free monad on such and such functor', compare, the free group on one generator
19:15:07 <Twey> applicative: Is that sufficient to collapse the stack?
19:15:47 <applicative> Twey: no, it just wraps it, you mean like the 'snap monad' or whatever
19:16:23 <rickyl> (If what I'm asking is just too obvious, can somebody point me to a good resource to read?)
19:16:46 <Twey> applicative: Oh, ‘monolithic’ here was regarding the implementation (i.e. one monad that does everything, rather than a transformer stack)
19:16:49 <alastor__> could anyone throw a quick glance at this http://pastie.org/8248902 and tell me whats wrong? careful: newbie code ahead
19:17:03 <byorgey> rickyl: it depends on the package.  check out  http://gloss.ouroborus.net/  for info and examples on using gloss.
19:17:54 <applicative> Twey: so here like line 146 https://github.com/snapframework/snap-core/blob/master/src/Snap/Internal/Types.hs
19:17:58 <Twey> alastor__: The type error is caused by the fact that your expression is parsed as tail . (take (l - 1) [x])
19:18:20 <Twey> alastor__: The value of take (l - 1) [x] is a list, not a function, so it doesn't make sense to compose it with another function (tail)
19:19:14 <Twey> There are plenty of other problems, though :þ  Try to avoid using partial functions like ‘tail’ in favour of pattern-matching, and make sure your patterns are exhaustive.  In this case you have two patterns for [x] and no patterns for [] or the general (x : xs) case.
19:20:31 <alastor__> Twey: i see, thank you
19:20:34 <Twey> Likewise, computations on list length are generally to be avoided; code that traverses the list with a fold or direct recursion are generally more elegant and performant.
19:21:26 <Twey> Lists are singly-linked lists, not arrays, so ‘length’ is an O(n) computation (and for a potentially infinite n).
19:33:15 <haasn> Is there a haskell library for reading and/or generating QR codes?
19:33:31 <dmj`> http://hackage.haskell.org/package/qrcode
19:36:37 <dmj`> haasn: I've never used it
19:36:48 <haasn> I'll have a look
19:50:29 <haasn> an.. interesting use of Bounded to be polymorphic in the output type
20:33:27 <oldthird> #join python
20:34:29 <shiona> *hssss*
20:48:09 <AfC> Can someone suggest a good (Haskell centric, perhaps) critique of why Go language might not be ideal?
20:48:10 <AfC>  (not trolling; people here want to know why I'm not enthusiastic and I honestly can't remember. I just know I decided I wasn't interested in it a while ago and moved on. To Haskell, in fact)
20:52:28 <atticus> Hey, does anyone know what's up with learnyouahaskell.com being down?
20:56:37 <djahandarie> atticus, not sure why, but it looks like both of the listed nameservers for that domain are down.
20:58:32 <Gracenotes> there was a quite good stackoverflow post I had read on game theoretic treatment of types, like djinn. anyone else remember anything like this?
20:59:14 <Gracenotes> it might have been for a specific type
21:00:07 <johnw> edwardk: pong
21:00:19 <Twey> Gracenotes: I don't know the one you're talking about, but one of these might be relevant to you: http://www.cs.bath.ac.uk/~gam23/papers.html
21:00:32 <Twey> AfC: https://plus.google.com/109566665911385859313/posts/FAmNTExSLtz
21:01:39 <AfC> Twey: heh. That's a thread hijack if I've ever seen one
21:03:02 <Gracenotes> hm, apparently, also, the conclusion is that "Haskell is a nightmare to program in. Perio."
21:03:03 <Gracenotes> d.
21:03:12 <Twey> A hijack of Simon Marlow proportions :þ
21:03:28 <Twey> Gracenotes: Yeeah, ignoring the general stupidity in between the interesting discussion of concurrency models :þ
21:04:10 <atticus> djahandarie: That's too bad. I use that website as my go-to when I forget something about Haskell. That tutorial was my entire learning experience for this language.
21:04:41 <Gracenotes> buy the book!
21:04:49 <Gracenotes> or not. I'm not sponsored.
21:05:09 <Twey> I think the domain expired
21:05:11 <leroux> Oh, is learn you a haskell down?
21:05:22 <leroux> Someone save it then...
21:05:47 <leroux> No, it's not.
21:05:52 <atticus> Gracenotes: I promise I will, once I have money (in a few months)
21:06:12 <TTimo> expires august 30th
21:06:21 <johnw> it's not loading for me
21:06:27 <atticus> leroux: It's working for you?
21:06:34 <leroux> ping No.
21:06:35 <johnw> http://www.downforeveryoneorjustme.com/learnyouahaskell.com
21:06:37 <johnw> says down
21:07:07 <atticus> johnw: Wow, new favorite website.
21:08:01 <leroux> Looks like its nameservers are down.
21:10:45 <gienah> it lives! http://web.archive.org/web/20130430065626/http://learnyouahaskell.com/
21:11:05 <Gracenotes> yeah, better scrape anything anyway
21:11:30 <Gracenotes> or not, it's not like no one else has the content
21:12:25 <Gracenotes> hum, hope things turn out okay. registrars can be not-nice to deal with.
21:12:37 <elliott> this has happened before, I think.
21:12:42 <elliott> BONUS kind of disappeared, as far as I know.
21:12:50 <AfC> Gracenotes: I did a wget of LYAH to read while I was doing some transoceanic flights (the book hadn't arrived yet); I can tarball it and put it somewhere if you need it
21:13:09 * gienah just gave a link to it
21:13:48 <johnw> https://github.com/pvorb/learn-you-a-haskell
21:15:12 <CADD> Gracenotes: hehe, i own a copy. and one for the (old version of) practical haskell. hell i even got a copy of HoTT just to support the research.. :)
21:16:53 <CADD> s/practical haskell/RWH/
21:16:54 <CADD> lol
21:18:32 <CADD> i even made my old college get a copy of LYAH and RWH because why not? :)
21:19:03 * Gracenotes is reading Parallel and Concurrent Haskell in dead tree form
21:19:11 <johnw> good, isn't it?
21:19:13 <arkeet> now make them PCPiH =)
21:19:17 <johnw> i bought the PDF
21:19:50 <arkeet> I forgot "get".
21:21:54 <CADD> Gracenotes: oh man, i still need to read that one
21:22:09 <elliott> arkeet: PCPiH?
21:22:20 <arkeet> Parallel and Concurrent(ry
21:22:43 <CADD> lol, now that is a reminder there to not use a web irc client.. :) irrsi4lyfe
21:22:59 <arkeet> well, just avoid irccloud.com =)
21:23:20 <Gracenotes> great advertising
21:23:35 <CADD> yeah, i have been temped by some of the irc offerings. mostly about the fact that i can be always logged in and not miss out on the fun.
21:23:46 <apples> arkeet: why's that?
21:23:48 <Gracenotes> it's the IRC equivalent of flying a plane with a banner overhead.
21:23:49 <johnw> CADD: you can do that with a bouncer
21:24:11 <arkeet> apples: that's what that flood of quits was.
21:24:20 <CADD> johnw: you are right, but that just means i have to set up another server. do you have anny recommendations for services?
21:24:32 <johnw> i use znc on a VM running on a dedicated Linux server
21:24:33 <arkeet> I use znc.
21:24:41 <arkeet> on a vps
21:24:45 <apples> arkeet: ah, ok :)
21:24:49 <CADD> mm.. i might get around to it eventually..
21:24:52 <Gracenotes> I use Digital Ocean and irssi, because I previously used a university server and irssi.
21:24:56 <johnw> it's really not difficult
21:24:56 <CADD> thanks for the recommendations guys
21:25:05 <CADD> i know, ive done it plenty before :)
21:25:12 <Gracenotes> it's also useful for general-purpose computing, probably
21:25:47 <CADD> Gracenotes: that is a very sweet deal there
21:25:57 <Gracenotes> I would use tmux and mosh, but for the latter ssh works on my phone, from my laptop, from my work computer, etc.
21:26:05 <Gracenotes> mosh only easily works from my laptop
21:26:23 <Gracenotes> although, both can work simultaneously. anywho.
21:28:22 <leroux> I do => irssi/(phone <-> irccloud) <-> znc <-> freenode (any irc server)
21:44:06 <alastor__> why doesn't this elementAt :: (Int b) => [a] -> b -> a work as a function signature?
21:44:21 <shachaf> Because Int isn't a type class.
21:44:38 <startling> alastor__, what do you think it should mean?
21:45:31 <alastor__> startling: i thought that when we enclose a Type and a variable before the '=>' operator and then use that variable in the actual signature, we are somehow binding that variable to the type we've specified
21:45:54 <startling> alastor__, not quite. what are you reading to learn haskell?
21:46:11 <alastor__> Lyah and doing 99 haskell questions
21:46:22 <startling> alastor__, read the section on typeclasses again.
21:46:41 <alastor__> sure. my bad. thanks startling , shachaf
21:46:42 <startling> oh, lyah is down?
21:46:53 <alastor__> i mean the actual physical book
21:46:57 <arkeet> alastor__: the thing on the left of => isn't a type, it's a class.
21:47:12 <startling> alastor__: yeah. I was going to link you to that part but I couldn't.
21:47:26 <shachaf> arkeet: Well, a constraint.
21:47:45 <Saulzar> Does anyone know how this is possible - I have a cabal library and a cabal executable, and I'm getting an unknown symbol error linking the library
21:47:49 <shachaf> Oh, to the left of => and of the variable.
21:48:16 <startling> Saulzar: what's the library?
21:49:09 <Saulzar> It's my own library - it's purely haskell, the symbol is something created by template haskell I guess
21:49:43 <johnw> Saulzar: how odd, just got that myself right this second
21:50:39 <Saulzar> It's ghc 7.6 and I'm using TH to generate some  cloud haskell stuff boilerplate
21:50:50 <Saulzar> 7.6.2 rather
21:50:57 * arkeet thinks Saulzar should show us a build log.
21:51:27 <Saulzar> Loading package distributed-ssh-0.1 ... linking ... ghc: /home/oliver/Projects/cabal-dev//lib/distributed-ssh-0.1/ghc-7.6.2/HSdistributed-ssh-0.1.o: unknown symbol `distributedzmsshzm0zi1_PatternsziDerive_staticDict_info'
21:52:02 <johnw> yeah, that's pretty much the same thing that I have, just a different library
21:52:15 <shachaf> preflex: zdec distributedzmsshzm0zi1_PatternsziDerive_staticDict_info
21:52:15 <preflex>  distributed-ssh-0.1_Patterns.Derive_staticDict_info
21:52:24 <johnw> i've solved this in the past, just have to remember how
21:53:05 <Saulzar> I'm not sure what the info thing is - but distributed-ssh-0.1_Patterns.Derive_staticDict is a type class method
21:53:18 <Saulzar> class Serializable a => HasDict a where     staticDict :: Static (SerializableDict a)
21:53:41 <shachaf> _info is an info table -- you can expect symbols to end with it.
21:55:01 <johnw> in my case the symbol is _persistentzm1zi2zi1zi1_DatabaseziPersistziClassziPersistField_zdfPersistFieldMap1_info
21:55:18 <Saulzar> Also a class method?
21:55:30 <johnw> preflex: zdec _persistentzm1zi2zi1zi1_DatabaseziPersistziClassziPersistField_zdfPersistFieldMap1_info
21:55:30 <preflex>  _persistent-1.2.1.1_Database.Persist.Class.PersistField_$fPersistFieldMap1_info
21:55:47 <johnw> well, PersistField is a type class at any rate
21:56:39 <Saulzar> Yeah I figured it out ..
21:56:44 <johnw> do tell
21:57:04 <Saulzar> I neglected to include a module in the other-modules: field in cabal
21:57:14 <johnw> interesting
22:02:22 <edwardk> johnw: reping
22:02:28 <johnw> edwardk: repong
22:13:07 <johnw> weird, my error was transient
22:13:14 <johnw> just needed to cabal clean in my project dir and rebuild
23:02:40 <edwardk> @ask dolio what ever happened to that pts branch/version you had using bound?
23:02:40 <lambdabot> Consider it noted.
23:03:56 <dolio> It is the current head version, isn't it?
23:04:45 <dolio> Oh, but it wasn't pts, it was upts.
23:06:22 <Saizan> that one's cute, it does reduction with an environment rather than substution at every step
23:06:41 <Saizan> which is what the other bound examples do
23:48:22 <ben_> hi guys I can't for the life of me remember how to get all of the accessors when calling a function... it's somehting like fn obj{...} = accessora isn't it?
23:49:29 <apples`> ben_: you need the RecordWildCards extension
23:49:37 <apples`> (if i'm understanding correctly)
23:53:03 <ben_> apples`, thanks was that the right syntax?
23:54:10 <MrRacoon> Hey, I need a function like mapConcurrently but i need to filter the results, is there a filterConcurrently I'm not seeing?
23:55:07 <apples`> ben_: yeah, assuming obj is capitalized
23:57:53 <ben_> thanks again apples` :-)
23:57:57 <apples`> no prob
23:58:50 * hackagebot diagrams-pdf 0.1.0.0 - PDF backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-pdf-0.1.0.0 (alpheccar)
