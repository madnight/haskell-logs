00:19:49 * hackagebot generic-deriving 1.6 - Generic programming library for generalised deriving.  http://hackage.haskell.org/package/generic-deriving-1.6 (JosePedroMagalhaes)
00:19:51 * hackagebot generic-deriving 1.6.1 - Generic programming library for generalised deriving.  http://hackage.haskell.org/package/generic-deriving-1.6.1 (JosePedroMagalhaes)
00:49:49 * hackagebot witty 0.0.0 - A network server to show bottlenecks of GHC  http://hackage.haskell.org/package/witty-0.0.0 (KazuYamamoto)
00:52:52 <PatrickRobotham> kvda: Write a typeclass and make Text and Maybe Text instances of it.
00:59:49 * hackagebot feed 0.3.9.1 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  http://hackage.haskell.org/package/feed-0.3.9.1 (SigbjornFinne)
01:05:41 <PatrickRobotham> kvda: You could also write a function that accepts the type Either Text (Maybe Text)
01:12:55 <johnw> isn't there a library that generalizes STM for any pure transformer stack
01:12:56 <johnw> ?
01:13:04 <johnw> i thought it was called stm-lifted, but now I can't find it
01:14:37 <johnw> maybe I was just thinking about lifted-async
01:26:29 <ocharles> mm_freak: opted for just getting the blog post out - http://ocharles.org.uk/blog/posts/2013-08-01-getting-started-with-netwire-and-sdl.html
01:26:34 <ocharles> hopefully I've done a good enough job!
01:26:39 <ocharles> haasn, RichyB ^
01:35:47 <Ghoul_> yay! 1-day turnaround on fixing the broken local documentation on windows+firefox
01:36:11 * Ghoul_ claps to everyone involved with cabal+haddock and friends.
01:36:55 <dcoutts_> Ghoul_: oh great
01:37:30 <Ghoul_> the local documentation index is a beautiful tool to have ;)
01:51:07 <mm_freak> ocharles: reading it
01:55:02 <mm_freak> ocharles: you have a bunch of typos in there you should fix
01:55:14 <mm_freak> "cabal configure && cabal configure"
01:55:29 <mm_freak> "pure 20" in code, "pure 10" in the corresponding explanation
01:58:51 <merijn> If that was supposed to be "cabal configure && cabal build", then you should upgrade cabal-install :)
02:12:28 <augur> is there a symbolic integration library available?
02:17:19 <supki> ocharles: keyDown definition cries for lenses :)
02:37:09 <haasn> supki: we've been through this before!
02:38:37 <haasn> supki: keyDown = elemOf (folded . to SDL.symKey)
02:41:06 <supki> yes
02:41:18 <mstksg> is there a command line haddock explorer of installed packages?
02:41:30 <supki> now I wonder how that non-lens nonsense made it into the blog entry!
02:41:50 <Tritlo> hey
02:42:03 <Tritlo> is it possible to declare a type synonym for a function
02:42:19 <arkeet> what does that mean?
02:42:35 <quchen> mstksg: Haddock explorer? If you want to see docs for all installed packages, there's the doc dir in your .cabal
02:42:42 <arkeet> if you mean you want something like  type Foo = X -> Y
02:42:44 <arkeet> youc an do that
02:42:48 <Tritlo> i,e, I have some thing like  a -> ( [a] -> [Float] ->b), and I want to be able to write a -> Learner i.e
02:43:07 <arkeet> I doubt you have something like that.
02:43:32 <Tritlo> Im programming AdaBoost
02:43:40 <Tritlo> and the learners take in examples and weights
02:44:44 <merijn> Tritlo: Yeah, that works
02:45:12 <merijn> Tritlo: "type Learner a b = [a] -> Float b; foo :: a -> Learner a b"
02:45:21 <merijn> eh
02:45:36 <merijn> Tritlo: "type Learner a b = [a] -> [Float] -> b; foo :: a -> Learner a b"
02:45:46 <merijn> Missed a couple of arrows there
02:46:02 <Tritlo> hmm
02:46:19 <Tritlo> I did that first, and it complained that I couldn't use a and b, but now it works
02:46:21 <Tritlo> thanks
02:46:34 <merijn> Tritlo: Did you have the a and b before the = too?
02:46:57 <yesthisisuser> i am thinking about the fixed point combinator. if a have a function fix f = f (fix f)
02:47:04 <merijn> Tritlo: If you had "type Learner = [a] -> [Float] -> b" then it wouldn't know where a and b came from
02:47:12 <yesthisisuser> and on the type level: a newtype X f = X (f (X f))
02:47:21 <yesthisisuser> the type of f is (a -> a) -> a
02:47:33 <Tritlo> ah, that must have been it
02:47:34 <yesthisisuser> and the kind of X is (* -> *) -> *
02:48:00 <arkeet> yesthisisuser: yes, you have just discovered Mu
02:48:15 <yesthisisuser> is it correct to say that the type of f is "isomorphic" to the kind of X
02:48:17 <Tritlo> merijn: thanks
02:48:30 <arkeet> no, it is not
02:48:41 <arkeet> (no matter how many quote marks you put it in)
02:48:50 <yesthisisuser> arkeet: lol.. ok thanks
02:48:53 <supki> arkeet: isn't Mu ~ forall a. (f a -> a) -> a
02:48:55 <supki> ?
02:49:01 <mstksg> quchen: i can't seem to find it; is this something i hvae to enable?
02:49:19 <yesthisisuser> arkeet: what is their relation?
02:49:41 <supki> I guess Mu is isomorphic to Fix anyway
02:50:01 <quchen> mstksg: Yes. By default it's in .cabal/share/doc/, but only if you installed documentation for your local libraries.
02:50:13 <quchen> That's done by setting the `documentation` flag in your cabal.conf.
02:50:23 <yesthisisuser> isn't Mu something like X f = X (f (X f))
02:50:28 <quchen> Or `library-documentation` maybe.
02:51:11 <supki> yesthisisuser: well, recursion-schemes package calls that Fix
02:51:17 <mstksg> quchen: ah, thanks, i found it.  so do i need to reinstall everything?
02:51:34 <quchen> mstksg: If you want the docs, that's probably the easiest way, yes.
02:51:36 <Tritlo> merijn: And when I declare a Learner, I have to specify a and b, right?
02:51:38 <arkeet> @src Mu
02:51:39 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
02:51:57 <quchen> mstksg: I suggest you just keep it in mind for the next time you install a new GHC+HP though.
02:52:03 <quchen> I mean how often do you really need local docs
02:52:39 <mstksg> quchen: well, sometimes i just want a quick reference for a function and its haddock descriptions
02:52:44 <mstksg> and type signature etc.
02:53:01 <mstksg> and i don't want to open a new browser window and search through hoogle
02:53:07 <mstksg> click to the documentation, etc.
02:53:31 <merijn> Tritlo: You can do just things like "foo :: Learner Int Char" which will be equivalent to "foo :: [Int] -> [Float] -> Char"
02:53:40 <quchen> mstksg: That's pretty much what using the local docs feels like.
02:53:46 <quchen> Only without Hoogle.
02:54:02 <ocharles> mm_freak: thanks, I proofed it a few times, but I always miss things :(
02:54:09 <merijn> Tritlo: Basically, Learner just takes two arguments that it fills in in the a's and b's of "[a] -> [Float] -> b"
02:54:19 <mstksg> quchen: i just always hate breaking out of my full screen terminal flow
02:54:43 <mstksg> muddle with gui's and mouse clicking :/
02:55:01 <ocharles> supki: I wanted to focus on one library at a time - this is for newcomers afterall
02:55:10 <quchen> Well, that's something you'll always have to put up with.
02:55:11 <Tritlo> merijn: And can I set restrictions on the a and b, e.g. Eq b?
02:56:13 <quchen> Using Hoogle doesn't really require much mouse clicking for me though. Got a Hoogle desktop, Ctrl+L to the location bar, "h foobar" to search foobar, see the first couple of results, go back to editor.
02:56:16 <merijn> Tritlo: Not inside the Learner (i.e. not trivially) but "foo :: Eq b => Learner Char b" works, yes
02:57:09 <mstksg> quchen: i just like staying on the command line for all eternity :)
02:57:35 <chexxor> I'm frustrated with this formula - what's the best way ask for help, or the best way to learn it?
02:58:07 <chexxor> doubleEveryOther [1,2,3] == [1,4,3] -- for arbitrary size list, doubling starts from right side
02:58:12 <quchen> mstksg: You can also invoke Hoogle from the command line, but I'm not sure what that searches. http://hackage.haskell.org/package/hoogle
02:58:42 <donri> it searches what you index, which by default is the same as online hoogle
02:58:45 <mstksg> quchen: i've tried that but it seems to only give type signatures
02:59:06 <typoclass> mstksg: i think there's a switch that will print out a little more
02:59:07 <donri> https://www.fpcomplete.com/hoogle is better though because it indexes all of "stackage"
02:59:09 <quchen> Well if you want Haddock-HTML you'll need a browser.
02:59:28 <mstksg> plenty of command line browsers i'm comofrtable using :)
02:59:31 <typoclass> mstksg: try "hoogle --info something"
02:59:34 <quchen> Try invoking it with `hoogle --info` and see whether you like that better
03:00:15 <typoclass> chexxor: hello, so doubleEveryOther is the function you want to implement?
03:00:16 <mstksg> typoclass, quchen: thanks, i think that's exactly what i was looking for :)
03:01:19 <chexxor> typoclass: yeah
03:01:39 <chexxor> typoclass: should I paste my progress somewhere?
03:01:58 <typoclass> chexxor: yes good idea. try lpaste
03:02:00 <typoclass> @where paste
03:02:01 <lambdabot> http://lpaste.net/new/haskell
03:02:32 <hpaste> chexxor pasted “doubleEveryOther” at http://lpaste.net/5921792781923123200
03:05:05 <supki> chexxor: does "arbitrary size list" includes infinite lists?
03:05:15 <supki> s/includes/include/
03:05:39 <chexxor> supki: well, I'm expecting 100 or less - supposed to be for credit card number validation
03:06:52 <typoclass> chexxor: alright! i think that you'll have an easier time if you reverse the list, then go through it from left to right, then at the end reverse it again. i think it doesn't really work to go through a list from right to left. (and yes, this will exclude infinite lists, because to reverse one, you'd have to start at the end, etc.)
03:07:28 <chexxor> typoclass: I don't know how to reverse a list
03:07:30 <supki> yeah, that's why I asked
03:07:35 <merijn> chexxor: reverse? :)
03:07:38 <merijn> :t reverse
03:07:39 <lambdabot> [a] -> [a]
03:08:02 <typoclass> > let f = map toUpper in (reverse . f . reverse) "cat" -- an example. reverse list, uppercase letters, reverse again
03:08:03 <lambdabot>   "CAT"
03:08:17 <donri> > reverse [0..]
03:08:21 <lambdabot>   mueval-core: Time limit exceeded
03:08:35 <typoclass> > length [0..]
03:08:38 <lambdabot>   mueval-core: Time limit exceeded
03:10:09 <supki> > [1..10] & reversed . itraversed . indices odd *~ 2
03:10:10 <lambdabot>   Couldn't match expected type `(a0
03:10:11 <lambdabot>                                 -> Contro...
03:10:17 <chexxor> typoclass: in which clause would I put the reverse? doubleEveryOther (xs) ?
03:10:59 <haasn> > [1..10] & reversed . traversed . indices odd *~ 2
03:11:00 <lambdabot>   Couldn't match expected type `(a0
03:11:00 <lambdabot>                                 -> Contro...
03:11:12 <supki> wrong indices :(
03:11:21 <Hafydd> :t (&)
03:11:22 <lambdabot> a -> (a -> b) -> b
03:11:27 <haasn> > [1..10] & reversed . traversed . Lens.indices odd *~ 2
03:11:29 <Hafydd> :k Traversable
03:11:29 <lambdabot>   [2,2,6,4,10,6,14,8,18,10]
03:11:30 <lambdabot> (* -> *) -> Constraint
03:11:43 <supki> chexxor: doubleEveryOther = reverse . magic . reverse, you only need to implement magic
03:11:51 <Hafydd> Lens got added back, I see.
03:11:52 <hpaste> typoclass annotated “doubleEveryOther” with “doubleEveryOther (annotation)” at http://lpaste.net/5921792781923123200#a91405
03:12:04 <haasn> Hafydd: not all of it, I think
03:12:07 <haasn> :t Lens.zipper
03:12:07 <lambdabot> Couldn't find qualified module.
03:12:10 <haasn> :t zipper
03:12:11 <lambdabot> Not in scope: `zipper'
03:12:12 <Hafydd> Hmmh. I see.
03:12:18 <haasn> :t Control.Lens.Zipper.zipper
03:12:18 <edwardk> it may be using lens HEAD
03:12:19 <lambdabot> Couldn't find qualified module.
03:12:22 <supki> zipper is not in lens anymore
03:12:26 <haasn> oh
03:12:33 <edwardk> we haven't finished bundling up zippers as a separate package
03:12:33 <quchen> Double reversal for doubling every other number? Eek. (Why not use zip and cycle?)
03:12:39 <typoclass> chexxor: here is a starting point ^^ you'd need to fill in the "..."
03:12:45 <mm_freak> ocharles: no worries…  i like your documenting approach, but pay more attention to details =)
03:12:54 <chexxor> typoclass: I haven't used 'where' before - it wasn't in the lesson notes, so I presume there's another way?
03:13:15 <mm_freak> ocharles: also one thing to note is that the FRP interface to netwire 5 will not expose the underlying automaton anymore
03:13:17 <haasn> ‘reversed’ is redundant for setting, right? due to lens laws
03:13:27 <mm_freak> ocharles: so you should probably mention it's netwire 4
03:13:30 <typoclass> chexxor: yes absolutely. have you seen "let ... in ..."? "... where ..." is basically the same. i'll update the lpaste
03:13:37 <edwardk> :t reversed
03:14:11 <edwardk> yes
03:14:23 <edwardk> > [1..10]^..reversed
03:14:24 <lambdabot>   [[10,9,8,7,6,5,4,3,2,1]]
03:14:39 <edwardk> > [1..10] & reversed.traverse +~ 1
03:14:40 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
03:14:47 <edwardk> > [1..10] & traverse +~ 1
03:14:49 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
03:14:56 <hpaste> typoclass annotated “doubleEveryOther” with “doubleEveryOther (annotation) (annotation)” at http://lpaste.net/5921792781923123200#a91406
03:15:28 <haasn> :t mapMOf_ reversing print
03:15:30 <lambdabot> (Show a, Reversing (a -> Accessor (Sequenced () IO) a)) => a -> IO ()
03:15:37 <edwardk> you can also use 'backwards'
03:15:43 <haasn> oh
03:15:46 <edwardk> > [1..10]^..backwards traverse
03:15:47 <typoclass> quchen: how do you mean zip and cycle? (he wants to do something to every other number, starting from the end of the list)
03:15:47 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
03:16:04 <edwardk> backwards just takes the traversal and runs its effects the other way
03:16:31 <edwardk> reversed actually transforms something into its flipped direction, so its doing a lot more work
03:16:41 <haasn> :t reversing
03:16:42 <lambdabot> Reversing t => t -> t
03:16:45 <haasn> oh no wonder
03:17:03 <edwardk> :t mapMOf (backwards traverse)
03:17:03 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
03:17:13 <ocharles> mm_freak: ok, but the reasoning of automaton still applies to netwire 5, right?
03:17:19 <ocharles> it helped me understand how this fit together
03:17:30 <haasn> I guess this kind of spam is what #haskell-lens is meant for
03:17:42 <ocharles> mm_freak: it's less attention to details more "be careful when you decide to change constants after writing prose"
03:17:46 <ocharles> :)
03:18:15 <chexxor> typoclass: I'm freaking out here. I expected to use only stuff mentioned in the lesson notes. Now I'm afraid I have to read those other two books - LYAH, and RWH
03:18:42 <edwardk> #haskell-lens is mostly gory details about how to implement stuff, bot-spam and whatever folks want to ramble on about ;)
03:18:53 <haasn> chexxor: I'd recommend a good read of LYAH regardless :)
03:19:17 <chexxor> typoclass: you think 'let' and 'where' are super-basic things?
03:19:43 <supki> > [1..10] & backwards (itraversed . Lens.indices odd) *~ 2
03:19:48 <lambdabot>   [1,4,3,8,5,12,7,16,9,20]
03:19:50 <haasn> chexxor: ‘let’ and ‘where’ are pretty basic; but they're also pretty simple.  “let <definitions> in <expr>” is just introducing new definitions in the scope of <expr>?
03:19:53 <supki> not the same
03:19:53 <merijn> chexxor: They're just local declarations. Do you know any other languages?
03:19:56 <haasn> s/?//
03:20:01 <typoclass> chexxor: more or less. i'd say basic, but maybe not super-basic. but don't worry, we'll get through this :-)
03:20:09 <edwardk> supki: oh you want the indexes to change
03:20:15 <supki> yes
03:20:34 <supki> ibackwards? :)
03:20:41 <edwardk> then you are probably stuck ;)
03:20:51 <supki> =(
03:20:54 <hpaste> typoclass annotated “doubleEveryOther” with “doubleEveryOther (annotation) (annotation) (annotation)” at http://lpaste.net/5921792781923123200#a91407
03:20:58 <haasn> :t reindexed -- ?
03:21:11 <chexxor> typoclass: I feel like I failed, so I need to take a break to recover my ego. Probably tomorrow.
03:21:14 <haasn> Indexable j p => (i -> j) -> (Indexed i a b -> r) -> p a b -> r
03:21:29 <haasn> chexxor: don't worry about it!
03:21:43 <chexxor> typoclass: I really appreciate it.
03:21:43 <haasn> chexxor: this channel is meant to help you learn new things
03:21:45 <edwardk> > ([1..10]^@..reversed.traversed, [1..10]^@..backwards traversed)
03:21:46 <lambdabot>   ([(0,10),(1,9),(2,8),(3,7),(4,6),(5,5),(6,4),(7,3),(8,2),(9,1)],[(9,10),(8,...
03:22:07 <edwardk> yeah you can always reindex it
03:22:23 <chexxor> I'm out for food - ttyl haasn  and typoclass
03:22:27 <haasn> oh, so ‘backwards’ flips the index too
03:22:34 <typoclass> chexxor: ^^ here is a third possibility. it's probably the easiest. all three annotations are pretty much the same (only the third one will make 'f' a function visible from everywhere; in annotations 1 and 2, function 'f' will only be visible inside of doubleEveryOther. this really only matters if you have like 20 functions in your module and want to start cleaning up)
03:22:54 <typoclass> chexxor: in other words, go with the third :-)
03:23:25 <haasn> > [1..10] & backwards traversed . Lens.indices odd *~ 1000
03:23:27 <lambdabot>   [1,2000,3,4000,5,6000,7,8000,9,10000]
03:23:29 <edwardk> the problem is backwards doesn't know your 'index' is positional. it might be the key in a map
03:23:41 <edwardk> you definitely don't want those to reverse when you read the values!
03:23:49 <chexxor> typoclass: ah! that looks more familiar - I can work with this
03:24:06 <edwardk> hence backwards has the only semantics it _can_ have
03:24:21 <edwardk> which is it just changes the order in which you visit key/value pairs
03:24:25 <edwardk> doesn't renumber the keys
03:25:09 <merijn> chexxor: "where" just defines a function that only exists in the scope of another function. i.e. the "f" only exists inside the "doubleEveryOther", you can just as easily write it as another top level function, though
03:27:44 <haasn> edwardk: isn't indexing64 a bit overkill?
03:28:07 <edwardk> its for containers like lazy bytestrings where you can have big big values
03:28:35 <edwardk> given that you can often walk them in logarithmic time and they can have self-sharing it isn't as absurd as you think
03:28:50 <haasn> hmm fair enough
03:28:59 <haasn> I guess 2^31-sized bytestring isn't all that absurd either
03:29:06 <edwardk> it exists because if it didn't someone would have to rewrite it ;)
03:29:07 <haasn> we have more memory than that nowadays
03:32:39 <edwardk> sure, though you can in general compose something that needs 2^n bit indexing with just O(n) small data structures in memory via sharing
03:46:00 <mstksg> is there a safe `read`?  Read a => String -> Maybe a, instead of throwing an exception?
03:47:18 <supki> mstksg: Text.Read.readMaybe
03:47:40 <mstksg> supki: thanks
03:51:58 <bennofs> But Text.Read.readMaybe is only available on GHC 7.6 and later, right?
03:52:03 <RichyB> There's also reads :: (Read a) => Reads a, which is a type synonym for reads :: (Read a) => String -> [(a, String)]
03:52:39 <typoclass> bennofs: yes it's somewhat new
03:52:39 <haasn> bennofs: yes, you can write it yourself though:  \x -> case reads x of [(a, "")] -> Just a; _ -> Nothing
03:52:42 <bennofs> @hoogle readMay
03:52:42 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
03:52:42 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
03:53:01 <bennofs> @hoogle (Read a) => String -> Maybe a
03:53:01 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
03:53:02 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
03:53:02 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
03:53:10 <haasn> hoogle isn't updated
03:53:14 <bennofs> Does hoogle not index safe?
03:53:35 <typoclass> bennofs: hoogle doesn't index a lot of things, for some reason. try hayoo
03:53:37 <typoclass> @where hoogle
03:53:38 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
03:53:40 <haasn> hayoo finds readMay
03:53:45 <RichyB> IIRC you can compose reads parsers together and use it like a parser combinator library, but you probably don't want to because worst-case performance can be abysmal and it's safer to go with Parsec, Happy or ReadP or something.
03:54:05 <bennofs> haasn: I know, I used hayoo just to find out it was really called readMay
03:55:15 <RichyB> If your ReadS parser contains anything which ever returns more than one item in the list of possible parses then you can get exponential time burnt backtracking when parsing errors occur.
03:55:59 <Kinnison> Parsec/AttoParsec are much nicer once you're beyond the "is this an integer or not?" question IMO
03:56:35 <RichyB> Agreed.
03:58:30 <RichyB> You can feed Parsec a list of tokens of any type, not just Chars. Write a separate lexer (possibly also using Parsec, it's nice for that too), feed the output into Parsec and you get rid of the "is this an integer or not?" question too. :)
04:02:14 <hpc> of course, then you have to thread location info from lexer to parser
04:02:28 <hpc> in order to get nice error messages
04:02:56 <magneticduck> hey, does anybody here understand sox? :< I'm having a bunch of trouble
04:03:36 <magneticduck> first off, is there any command that actually ADDS two audio files? (As if you added the waves of both of them)
04:04:10 <magneticduck> because it seems like scaling the volume of something by 0.5 and then adding it to a copy of itself.. yeilds not the original file, but a copy of the file with the volume still at 0.5 -.-
04:05:08 <magneticduck> also, let's say I want to mix a whole list of files into one file, each with the same weight
04:05:11 <magneticduck> how would I do that
04:05:26 <magneticduck> if anybody has solutions not involving sox I'm ears for that too
04:05:59 <magneticduck> whoops sorry, back now
04:06:19 <hpc> magneticduck: try adding two 30-second files; one has a tone at the start, one has a tone at the end
04:06:25 <hpc> see what kind of shape it comes up with?
04:06:52 * hpc would bet it ends up with two half-volume tones
04:07:11 <magneticduck> ah k
04:07:13 <magneticduck> I'll try that
04:07:27 <magneticduck> well that seems probable
04:07:35 <magneticduck> because it seems to be averaging them out
04:07:42 <magneticduck> so, how would I actually add two files?
04:08:06 <hpc> it sounded like you had already done it before
04:08:13 <magneticduck> what do you mean?
04:08:15 <hpc> "because it seems like scaling the volume of something by 0.5 and then adding it to a copy of itself.."
04:08:16 <magneticduck> no, I haven't
04:08:31 <magneticduck> scaling the volume of something by 0.5 and then adding it to a copy of itself
04:08:36 <magneticduck> results in a file with 0.5 volume!
04:08:42 <vimes> Hello. Very new to Haskell, following along "learnyouahaskell" but I'm stuck because a line won't compile.
04:08:45 <magneticduck> consistent with my theory that sox is taking the average of the sounds
04:08:51 <vimes> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
04:08:51 <magneticduck> vimes: www.hpaste.org
04:08:55 <magneticduck> oh, k
04:08:56 <vimes> this line doesn't compile
04:09:04 <magneticduck> yeah, that wouldn't
04:09:11 <vimes> but this one does: [ x | x <- [50..100], x `mod` 7 == 3]
04:09:15 <magneticduck> "if" isn't a function, and you don't use it in syntax like that
04:09:27 <vimes> oh
04:09:30 <magneticduck> perhaps make your "if" clause into a function, or use if'
04:09:35 <magneticduck> @type if'
04:09:36 <lambdabot>     Not in scope: if'
04:09:36 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
04:09:41 <magneticduck> uhh
04:09:58 <magneticduck> uhhhh
04:10:03 <sp3ctum_> vimes, that defines the list based on itself
04:10:04 <magneticduck> yeah, just make the if clause into a function =P
04:10:07 <typoclass> magneticduck: how do you mean? what's wrong with «if x < 10 then "BOOM!" else "BANG!"»?
04:10:20 <magneticduck> oh sorry, I must be tired
04:10:23 * magneticduck shuts up
04:10:32 <sp3ctum> it's legal
04:10:42 <supki> @let boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
04:10:43 <lambdabot>  Defined.
04:10:54 <supki> > boomBangs [5..15]
04:10:56 <sp3ctum> vimes, perhaps you want something like x <- [1..100] instead of x <- xs +
04:10:58 <sp3ctum> ?
04:10:58 <lambdabot>   mueval-core: Time limit exceeded
04:11:05 <quchen> typoclass: Oh, I missed the "from the back" part.
04:11:07 <vimes> ok but the error I get is parse error after the equal sign
04:11:12 <vimes> it just doesn't evaluate any of it
04:11:17 <magneticduck> um
04:11:21 <magneticduck> you're using a code file
04:11:21 <quchen> typoclass: Then I guess it's impossible to do lazily though. :-/
04:11:26 <magneticduck> or evaluating it in GHCi
04:11:37 <vimes> er
04:11:39 <vimes> yeah I am
04:11:42 <magneticduck> GHCi?
04:11:43 <supki> > boomBangs [5..15]
04:11:44 <vimes> should I be using something else?
04:11:47 <lambdabot>   mueval-core: Time limit exceeded
04:11:51 <supki> ?
04:11:51 <magneticduck> then you need a "let" before writing the statement
04:11:59 <magneticduck> "let boomBangs xs = .."
04:12:12 <sp3ctum> oops, I misread too
04:12:16 <magneticduck> or forget about GHCi and use a code file
04:12:22 <hpc> > let boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x] in boomBangs [1,2,3]
04:12:24 <lambdabot>   ["BOOM!","BOOM!"]
04:12:24 <typoclass> vimes: oh, in ghci you have a slightly different syntax. (you are basically inside of a big do block, if you've already come across do blocks.) so yes, add a "let" at the front
04:12:27 <vimes> hey the parse error moved along to the else statement
04:12:35 <vimes> getting somewhere =]
04:13:01 <magneticduck> hehe
04:13:13 <magneticduck> what exactly is the error
04:13:24 <vimes> ok I put apotophes on all the things
04:13:27 <vimes> new errors
04:13:42 <typoclass> vimes: please paste the code and the error that you got. use lpaste if it's more than one line
04:13:44 <typoclass> @where paste
04:13:44 <lambdabot> http://lpaste.net/new/haskell
04:13:48 <vimes> if else and then are now not in scope
04:14:12 <magneticduck> make it into a code file, or paste the exact lines you're writing into GHCi
04:14:22 <vimes> ok I don't know how so give me a moment
04:14:39 <typoclass> vimes: sure, don't worry
04:15:06 <hpaste> vimes pasted “stuff ” at http://lpaste.net/91408
04:15:27 <magneticduck> oh, sorry about that man
04:15:30 <magneticduck> don't use if'
04:15:32 <magneticduck> xD
04:15:35 <vimes> lol
04:15:36 <vimes> ok
04:15:37 <magneticduck> lol, don't use any 's
04:15:39 <magneticduck> >_>
04:16:06 <vimes> hey
04:16:08 <vimes> no errors
04:16:11 <vimes> thanks everyone
04:16:12 <sp3ctum> don't forget boomBangs in the start!
04:16:14 <magneticduck> lol, I thought it was a problem with the parsing of the if clause
04:16:32 <magneticduck> which is why I suggested the functional if
04:16:35 <magneticduck> but I messed up on the name
04:17:33 <magneticduck> what exactly does that function do anyway
04:17:43 <sp3ctum> an infinite loop
04:17:44 <vimes> http://learnyouahaskell.com/starting-out#im-a-list-comprehension
04:17:51 <vimes> ctrl f boomBangs
04:18:00 <magneticduck> self-defines an empty list at infinity I guess
04:18:06 <magneticduck> >_>
04:18:14 <vimes> but er, you've completly solved my problem so thanks
04:18:21 <sp3ctum> vimes, does it run?
04:18:25 <vimes> yes
04:18:34 <vimes> defines a function and then I use it and it does it
04:18:42 <sp3ctum> what does print xs say?
04:19:05 <magneticduck> ikr
04:19:10 <hpaste> vimes pasted “more stuff” at http://lpaste.net/91409
04:19:11 <magneticduck> that code should not run
04:19:23 <vimes> er
04:19:40 <magneticduck> oh I see
04:19:42 <magneticduck> kk
04:19:42 <quchen> That code sould run.
04:19:52 <magneticduck> yeah
04:19:55 <magneticduck> forgot about the function
04:20:20 <magneticduck> I certainly botched that whole thing up
04:20:23 <magneticduck> not one of my finest moments
04:20:44 <magneticduck> anyway, does anybody know how to ADD audio files?
04:20:48 <magneticduck> with sox or something else?
04:21:04 <vimes> well you solved a problem in 10 minutes I've been staring at for 2 hours
04:21:10 <magneticduck> heheh
04:21:22 <magneticduck> well we could have done better
04:21:40 <sp3ctum> only after we had stared at a similar thing for a long time :3
04:22:49 <magneticduck> hmmm, I could hack something out by changing volumes around post addition
04:22:51 <magneticduck> ..
04:23:14 <magneticduck> the end result I'm looking for is to generate an audio file with a bunch of frequencies at various relative intensities
04:24:07 <magneticduck> if only sox had some sort of weighted addition method...
04:24:35 <magneticduck> maybe I should actually learn about how to use sox
04:25:26 <magneticduck> ah I found it, the "mix" option
04:29:42 <magneticduck> I am so mad, there is already a sox wrapper for haskell
04:29:46 <quchen> GHC mentions "stupid theta" in its source. Apparently it's a thing.
04:29:50 <magneticduck> lesson learned: search hoogle before making your own binding
04:30:44 <quchen> I should do some research on stupid thetas and then put it in the folder of silly mathy thins, next to retarded Green's functions, degenerate matrices and the likes of those.
04:30:58 <magneticduck> aahah
04:31:44 <quchen> algTcStupidTheta = stupid,
04:31:52 <quchen> I'm starting to enjoy this file :>
04:32:11 <magneticduck> well I'm actually past the point of no return
04:32:27 <magneticduck> learning a pre existing binding to sox will take more time than it will take to finish my own binding
04:34:26 <mxf> hi #haskell, does anyone of you have a local copy of "http://cale.yi.org/index.php/How_To_Use_Monad_Transformers"? web.archive.org fails me
04:35:05 <magneticduck> I get a 404 too
04:41:43 <merijn> mxf: I don't know, but monad transformers aren't that hard (easy to say once you get them ;)), did you have a specific question about them?
04:41:58 <ocharles> mxf: I can mail you my print out, but that probably won't help
04:43:14 <merijn> mxf: The simplest/shortest explanation I can give is about two lines ;) Do you understand how "State s a" works as "s -> (a, s)"?
04:43:31 <mxf> merijn, it's not that I don't understand them, but more how to use them correctly. I get a feeling, i might be overdoing it and hoped that article could shed some light on that
04:44:21 <mxf> ocharles, heh
04:44:24 <merijn> mxf: oh, it's probably unlikely you're overdoing it, but in case of doubt you can always paste an example you're not sure about and ask a second opinion :)
04:44:47 <mxf> merijn, i will come back to that, thanks :)
04:45:13 <merijn> I tend to use State/Reader/RWS quite a lot (Writer not so much)
04:48:49 <watermind> how can I tell whether ghc is using libraries installed via my disto packaging system, or the newer ones install with cabal install?
04:49:05 <watermind> and how is it supposed to know which it should be using?
04:49:50 <donri> watermind: if you never sudo cabal you could tell from ghc-pkg list
04:49:56 <donri> you'll have two package databases
04:50:47 <watermind> donri: let me check
04:50:52 <donri> watermind: and best use cabal to build your projects; it lets you define precise dependencies
04:54:43 <donri> watermind: sorry i misunderstood your question originally. when you compile with ghc, it will tell you what packages and versions it is loading.
04:54:45 <watermind> donri: I have to start doing that...
04:55:47 <watermind> donri: ghc-pkg did list the serveral versions it had available though... so at list I can tell it is accessing those installed  with cabal  which is a good start
04:56:04 <watermind> do you know what the red and blue colours in that list mean?
04:56:22 <donri> watermind: i think red means broken, forgot what blue means
04:56:32 <typoclass> afaik blue means hidden
04:56:42 <donri> ah that makes sense
04:59:33 <watermind> I have a ton of hlint versions... but I don't see a cabal option to ghet rid of the old ones
04:59:41 <watermind> are we supposed to deleted them by hand?
05:00:17 <MasseR> You can ghc-pkg unregister libraries
05:01:02 <watermind> MasseR: but wouldn't that only remove them from ghc's database rather than uninstall them?
05:01:09 <MasseR> Yes
05:01:32 <donri> watermind: yes, the files are left in place, but ghc and cabal won't know about them
05:01:36 <watermind> I'd actually prefer to have them removed... no point in having all these versions lingering around
05:01:54 <donri> @hackage cabal-uninstall -- haven't tried it though
05:01:54 <lambdabot> http://hackage.haskell.org/package/cabal-uninstall -- haven't tried it though
05:02:04 <watermind> hmmm
05:02:54 <watermind> cabal-uninstall returns an internal error, so I rather not trust it :P
05:03:18 <donri> what returns internal error exactly?
05:05:30 <watermind> cabal-unsinstall --help
05:05:37 <watermind> *uninstall
05:05:44 <typoclass> watermind: i think everyone just does "ghc-pkg unregister" followed by rm'ing the file. (or using your distro's package manager, if applicable)
05:05:59 <watermind> typoclass: yeap that's what I'm doing now
05:06:16 <donri> i just leave the files, i have plenty space and often clean out ~/.ghc anyway :p
05:06:24 <MasseR> Me too
05:07:07 <watermind> by the way, how dangerous is a ghc update? my distro as ghc 7.6.x available now but most other ghc distro packages were not updated
05:07:25 <watermind> what do I need to have a minimal system so that I can just then cabal install everything else?
05:07:43 <donri> watermind: the code seems to treat any single argument as a package name. pass no arguments for usage
05:07:47 <byorgey> watermind: ghc, and cabal
05:08:27 <donri> i think ghc comes with Cabal, which you can use to bootstrap cabal-install
05:08:31 <watermind> byorgey: would the cabal I have installed now do? i.e. the one installed with cabal-install and compiled with ghc 7.4.x
05:08:54 <byorgey> yes, it should be OK
05:09:15 <typoclass> watermind: you could just install the haskell platform, which your distro probably has packages for
05:09:59 <merijn> watermind: You need either ghc+cabal or Haskell Platform with the ghc you want(provided it exists for your distro)
05:10:07 <watermind> typoclass: openSUSE hasn't been great at keeping it updated, there's two repos, one supposedly with platform but it was kind of old... let me check
05:10:10 <merijn> watermind: From there you can get everything with cabal install
05:12:31 <donri> seems only rc1 of the latest platform has a repo for suse
05:13:02 <watermind> I'm also on openSUSE 12.1 (pretty old) which doesn't help
05:13:36 <watermind> there's platform available for 12.3, for 12.1 I have this: http://download.opensuse.org/repositories/devel:/languages:/haskell/openSUSE_12.1/x86_64/
05:14:19 <typoclass> watermind: you can also install ghc by getting the tar.gz from the website. it's easy to install. same for the platform, i think
05:14:39 <donri> watermind: that's not a correct haskell-platform
05:14:45 <watermind> I know :/
05:14:52 <donri> watermind: there is no platform version with ghc 7.6 and cabal 0.14
05:15:02 <watermind> donri: that's why I was asking what I need for a minimal system that'll work
05:15:14 <watermind> donri: I have the latest cabal installed via cabal-install
05:16:12 <donri> watermind: you just need ghc, and then you can download the tarball for cabal-install and run the bootstrap script
05:16:53 <watermind> donri: well if that works then the cabal-install I have on my system should also work no?
05:17:12 <donri> watermind: it should, yes.
05:18:00 <donri> cabal-install is supposed to be able to handle multiple versions of ghc at the same time, and non-ghc compilers even
05:18:25 <donri> so it shouldn't be tied to the ghc that compiled it
05:18:38 <watermind> cool
05:29:23 <watermind> will I then have to reinstall all/most libraries I cabal-install'ed with 7.4.x so that they work with 7.6.x?
05:29:37 <donri> all, yes
05:29:42 <watermind> :/
05:30:04 <donri> cabal install world might work
05:33:50 <watermind> weird, I tried that just to see what it said and it complained with "Warning: The following 'world' packages will be ignored because they refer to, packages that cannot be found: agda"
05:34:07 <watermind> and it had agda like that, in lowercase
05:34:56 <simukis_> any suggestions how to achieve `(m a, m a, m a) -> m (a, a, a)`?
05:35:11 <watermind> simukis_: put it in a list and sequence?
05:35:27 <bennofs> @ty each id
05:35:28 <lambdabot> Each f s t (f b) b => s -> f t
05:35:49 <bennofs> > each id (Just 3, Just 4, Just 6)
05:35:51 <lambdabot>   Just (3,4,6)
05:36:03 <simukis_> bennofs: awesome!
05:36:11 <bennofs> (each is from lens)
05:37:14 <quchen> sequenceT3 (a,b,c) = do { a' <- a; b' <- b; c' <- c; return (a',b',c') }
05:37:20 <quchen> No lens required.
05:37:29 <quchen> (It's a huge dependency if that's all you want to do.)
05:38:35 <donri> watermind: means you did cabal install agda at some point
05:39:10 <bennofs> > let sequenceT3 (a,b,c) = (,,) <$> a <*> b <*> c in sequenceT3 (Just 3, Just 4, Just Nothing)
05:39:11 <lambdabot>   Just (3,4,Nothing)
05:39:12 <donri> i think it's smart enough to find Agda for you, but maybe stupid enough to write it as agda to the world file
05:39:19 <donri> dcoutts: known?
05:39:35 <quchen> bennofs: Good point.
05:39:57 <dcoutts> donri: sorry, context? details?
05:40:35 <watermind> donri: maybe, but I would expect to also see it in ghc-pkg list, and there's no agda there, only Agda-2.x.x
05:40:35 <donri> dcoutts: it seems cabal install agda will find and install Agda, but writes 'agda' to world file and cabal install world does not find Agda
05:40:49 <watermind> donri: no no, it does find Agda
05:41:10 <donri> you said it says "Warning: The following 'world' packages will be ignored because they refer to, packages that cannot be found: agda"
05:41:11 <watermind> donri: sorry didn't explain well... it finds Agda, but also mentions some "agda"
05:41:17 <donri> hm ok
05:41:31 <watermind> which isn't listed in ghc-pkg list
05:41:33 <donri> do you have both agda and Agda in the world file?
05:41:38 <watermind> let me see
05:41:42 <donri> .cabal/world
05:42:54 <watermind> donri: yes... I'll just remove agda I guess
05:52:02 <danr> @type liftM3 (,,) -- simukis__
05:52:04 <lambdabot> Monad m => m a1 -> m a2 -> m a3 -> m (a1, a2, a3)
06:03:38 <bennofs> @ty liftA3
06:03:38 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
06:04:42 <donri> :t sequenceAOf each
06:04:44 <lambdabot> Each f s t (f b) b => s -> f t
06:04:50 <Peaker> Making an Ord instance for an arbitrary user-defined GADT of a bunch of constructors seems like a pain
06:05:51 <Peaker> A <= _ = True ; _ <= A = False ; B <= _ = True ; _ <= B = False ; ...
06:07:03 <merijn> I have a values x and y and I want to cast x to y, how can I get force cast to select the right type without a type annotation?
06:07:11 <donri> Peaker: do you need all those False cases?
06:07:35 <Peaker> donri, how would B <= A work?
06:08:05 <donri> Peaker: wrongly. ignore me :)
06:08:12 <Peaker> It's too ugly to put in "production code". I'm looking for a better way
06:08:59 <typoclass> merijn: you mean asTypeOf or something like that?
06:09:02 <merijn> "foo x y = case cast x of Just a -> .." how do I add the constraint for "cast x" to be "Maybe b" with b is the type of y?
06:09:30 <merijn> typoclass: oh, that looks like what I need
06:09:46 <merijn> "case cast x `asTypeOf` Just y", I guess
06:11:36 <FreeFull> Hmm, I suppose asTypeOf is just const with a specific type signature?
06:12:06 <merijn> FreeFull: Yes
06:12:18 <typoclass> FreeFull: afaik yes. at the value level it's id or const or something like that. the type level is what makes it useful
06:12:42 <FreeFull> const :: a -> a -> a
06:13:07 <Peaker> merijn, why do you need to "manually" force the type? ambiguous type-class constraints?
06:13:59 <merijn> Peaker: Check whether I got a certain exception
06:14:36 <merijn> Peaker: Which means casting the existential in SomeException to some other type
06:14:59 <danr> Peaker: some simple GADTs can have their Ord instance derived: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/deriving.html
06:15:13 <hpaste> merijn pasted “catchExcept” at http://lpaste.net/91414
06:15:19 <merijn> i.e. that code
06:15:26 <Peaker> danr, I know, but not mine
06:15:50 <merijn> i.e. I have a cleanup case that I don't want to run on some exception
06:16:27 <merijn> Peaker: I'd be open to better solutions to that function :)
06:16:29 <danr> Peaker: ok, then I understand your pain XD
06:16:36 <danr> maybe write some TH code that generates it for you? :)
06:16:56 <Peaker> Nah, I'll just redesign it so I don't need the GADT
06:17:37 <Peaker> I had a "Set Trigger" where Trigger is a GADT of various reified predicates as data constructors, with differing result data in each case. Instead I will try a record of differently-typed triggers in it
06:20:02 <b0bbi10> hi
06:20:11 <Peaker> people write TH that requires its users to import stuff :-(
06:20:48 <b0bbi10> did someone here read the book 'programming in haskell' and 'learn you haskell for a great good' as introductory books?
06:21:13 <merijn> b0bbi10: I haven't read the first one, but LYAH is a good intro
06:23:14 <b0bbi10> many people on the Internet say that LYAH a good place to start, but some are also recommending 'programming in haskell'
06:23:25 <b0bbi10> just try to figure out which one to read first :D
06:23:37 <b0bbi10> trying*
06:23:52 <Yaniel> 'real world haskell' looks nice
06:24:38 <merijn> b0bbi10: Well, most people recommend LYAH since there's a free online version
06:25:01 <typoclass> b0bbi10: lyah is a good introduction (and it's free). i don't know if 'programming in haskell' is a better starting point or not, but lyah is a good starting point
06:25:02 <b0bbi10> I picked that one as second book after reading either 'programming in haskell' or/ and 'learn you a haskell for great good'
06:25:11 <b0bbi10> ok
06:25:20 <merijn> Yaniel: imo, RWH is nice, but it glosses over some important basics. I tend to recommend reading LYAH first, then skipping the intro chapters of RWH and using the practical examples in RWH
06:25:23 <hape01> what is the way to remove/uninstall a binary distribution of GHC on Ubuntu? (I upgraded from 12.10 to 13.04 and now libgmp.so.3 is needed by GHC 7.6.3 but not existing in 13.04 any more)
06:34:19 <jwoc> ello
06:35:56 <typoclass> jwoc: hi
06:38:38 <quchen> hape01: sudo apt-get remove ...?
06:39:53 <b0bbi10> so install haskell, do I only need the 'haskell' package or should I also install the 'haskell standard distribution' package also? (fedora)
06:40:32 <b0bbi10> to*
06:40:51 <donri> b0bbi10: haskell-platform or @haskell
06:41:34 <b0bbi10> thx
06:44:17 <hape01> sorry, i was not precise enough, I had installed the generic binary distribution via ./configure and make install, i didn't use apt-get install..., and now i want to remove that again to get the package directly via apt-get install
06:48:03 <quchen> hape01: did you `make install` or `sudo make install` it?
06:48:23 <quchen> i.e. is it a local or global installation
06:49:51 <quchen> Also, what did you configure/install? GHC? Platform?
06:52:40 <hape01> quchen: don't remember unfortunatelly
06:53:00 <quchen> hape01: What does `which ghc` output?
06:53:14 <hape01> /usr/local/bin/ghc
06:53:42 <quchen> Alright, go into that folder and delete (or move) ghc, happy, alex, haddock
06:53:53 <hape01> I'll do
06:53:56 <quchen> cabal too
06:54:07 <quchen> (Yes, this is going to be dirty) :-)
06:55:07 <merijn> edwardk: I saw you went with 0.2 for the new exceptions release, so I guess that means you're not following the PVP? Which scheme do you prefer for future updates?
06:55:37 <quchen> Then search for a folder called "ghc-7.6.3", it should be in some "lib" dir. Remove that one as well.
06:55:49 <edwardk> i follow the PVP, but there is a semantics issue here. You added a member to a class, so if anyone else wrote an instance, they'd now have a partially defined class
06:55:57 <merijn> ah
06:55:57 <quchen> Then delete ~/.cabal and ~/.ghc
06:56:01 <quchen> And that should be it
06:56:14 <merijn> I need to read the PVP better :)
06:56:44 <edwardk> basically i bump if you can't defend against the change with defensive programming: qualified imports, etc.
06:57:23 <hape01> quchen: They're gone :-)
06:57:40 <quchen> hape01: Time to try out your fancy package manager now! :-)
06:57:55 <merijn> oh, blah
06:58:10 <merijn> I suck at remembering details like updating changes notes >.>
06:58:28 <quchen> git diff > changelog.txt
06:58:29 <quchen> :-P
07:01:36 <hape01> quchen: it's is working, I removed the individual "generic binary" installation as desribed by You and now the already distro-packaged installed version 7.6.2 is active again and usable under Ubuntu 13.04. Thank You for Your help!! Wow!
07:01:54 <quchen> You're welcome.
07:02:26 <quchen> By the way, you should not only install GHC but also the Haskell Platform, in case you haven't done that.
07:03:47 <hape01> yep
07:05:41 <quchen> hape01: Well then,    echo 'main = putStrLn "hello world"' | runghc
07:06:18 <hape01> quchen, yes, hello world comes out
07:06:28 <hape01> sudo apt-get install haskell-platform
07:06:45 <hape01> that is  yet unclear to me, why this does not exist
07:06:53 <hape01> in Ubuntu 13.04
07:07:11 <hape01> E: Unable to locate package haskell-platform
07:07:22 <ion> Do you have universe in your software sources?
07:07:29 <hape01> let me check
07:07:49 <tikhon> maybe the package is called something else?
07:08:20 <hape01> yes, i've "universe" checked
07:08:31 <hape01> (has been already)
07:09:44 <ion> Try running aptdcon -c
07:10:17 * hackagebot markup-preview 0.1.0.0 - A simple markup document preview (markdown, textile, reStructuredText)  http://hackage.haskell.org/package/markup-preview-0.1.0.0 (MariusGhita)
07:11:08 <hape01> ion: thx but did not bring haskell-platformm into scope unfortunately
07:11:38 <hape01> there is a discussion ongoing: http://askubuntu.com/questions/286764/how-to-install-haskell-platform-for-ubuntu-13-04
07:16:16 <hseg> Question: Trying to figure out the type of traverse.traverse However, I don't see how I can simplify the following type:
07:17:58 <hseg> traverse.traverse :: (Applicative f, Applicative f', Traversable t, Traversable t', f b ~ f' (t' b')) => (a' -> f' b') -> t (t' a') -> f (t b)
07:20:08 <hseg> The type I've found posted online is traverse.traverse :: (Applicative f, Traversable t, Traversable t') => (a -> f b) -> t (t' a) -> f (t (t' b))
07:21:00 <mauke> looks obvious
07:21:18 <mauke> f b ~ f' (t' b')  ==>  f ~ f', b ~ t' b'
07:22:44 <hseg> Why couldn't it be f b ~ f' (t' b') ==> f ~ Compose f' t', b ~ b'?
07:23:21 <mauke> what's Compose?
07:23:22 <byorgey> because f' (t' b') and Compose f' t' b'  are entirely different types.
07:23:28 <byorgey> Compose is not built into the type system.
07:23:42 <merijn> byorgey: Sadly :(
07:24:17 <byorgey> hseg: in fact, Haskell's type system has been carefully designed so that  f a ~ g b ==> (f ~ g, a ~ b)  holds
07:24:42 <merijn> Will closed type families support partial application?
07:25:18 <hseg> So I'm assuming that this means that there is no constraint Compose f g x ~ f (g x)?
07:25:39 <hseg> s/I'm assuming/I assume/
07:25:55 <mauke> what's Compose?
07:26:03 <merijn> mauke: Data.Functor.Compose?
07:26:25 <merijn> :t Data.Functor.Compose
07:26:26 <lambdabot>     Not in scope: data constructor `Data.Functor.Compose'
07:26:32 <merijn> :t Data.Functor.Compose.Compose
07:26:32 <lambdabot> f (g a) -> Data.Functor.Compose.Compose f g a
07:27:30 <mauke> newtype Compose :: * -> * -> * where Compose :: f (g a) -> Compose f g a what
07:27:35 <hseg> I think so. It basically composes types
07:28:26 <merijn> mauke: Yes, it's functor composition
07:28:51 <hseg> mauke, it's newtype Compose :: (* -> *) -> (* -> *) -> * = Compose f g x
07:29:23 <mauke> oh, right
07:30:45 <hseg> Anyway, since we can't yet insert new rules into the typechecker, we can safely assume as byorgey said, that f a ~ g b ==> f ~ g, a ~ b
07:37:42 <tikhon> has anyone here played around with threepenny-gui?
07:40:23 * hackagebot cblrepo 0.8.0 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.8.0 (MagnusTherning)
07:43:58 <zvrba> hm
07:44:08 <zvrba> I've upgraded haskell platform to 2013.2
07:44:18 <zvrba> I have a cabal project (managed by eclipse)
07:44:29 <zvrba> and now it complains about cannot satisfy -package-id array-0.4.0.0-9176f59bdae9e661360f185d8825258e
07:44:40 <zvrba> the array package is not mentioned with a version in the cabal file
07:44:44 <zvrba> and I've done cabal clean
07:44:51 <zvrba> so, what's going wrong and how to fix it?
07:45:12 <mauke> what does 'ghc-pkg check' say?
07:45:51 <zvrba> mauke: it complains about cache being out of date
07:46:12 <zvrba> i have to run recache
07:47:10 <merijn> Is there a way to make cabal report Build-Depends that aren't used?
07:47:17 <zvrba> mauke: and it complains for haddock files not being found.
07:47:20 <zvrba> a bunch of warnings
07:47:32 <dcoutts> merijn: you can ask ghc to dump minimal imports
07:48:59 <merijn> dcoutts: That's something different, no? Cabal currently reports if I import something from a package that is not in my build-depends, but is there a way to do the reverse?
07:49:15 <zvrba> mauke: ok, I had to delete .dist_buildwrapper stuff
07:49:15 <dcoutts> merijn: not easily at the moment
07:49:34 <merijn> ok, so I should just comment them all out and readd until it build without complaining?
07:50:12 <dcoutts> merijn: that'd work, obviously a bit of a pain
07:51:34 <donri> cabal init with existing sources will attempt to figure out the deps for you
07:52:00 <merijn> donri: Yeah, but then I'd have to wipe my cabal file all the time
07:53:38 <edwardk> @tell danharaj i'll have you know i spent the last 24 hours obsessed with Kan lifts in Haskell. damn you =P
07:53:38 <lambdabot> Consider it noted.
07:54:17 <danharaj> edwardk: I have to wait 'till the weekend to be obsessed with them with you :P
07:54:30 <merijn> ugh
07:54:30 <edwardk> heh
07:54:58 <merijn> ok, I think I just finished writing the scariest module in my haskell carreer, let's hope it's bug free and I will never have to touch it again :>
07:55:11 <edwardk> mostly just the pain of trying different translations for them. i'll have to get to the office and have dolio bang one out effortlessly =P
07:55:29 <mauke> merijn: is it Data.Reflection?
07:55:33 <edwardk> merijn: if it doesn't work just add more unsafeCoerce until it does
07:56:04 <merijn> mauke, edwardk: No, I have a an uninterruptibleMask to exported function ratio of 1 :>
07:56:18 <edwardk> heh
07:56:23 <edwardk> yeah that'll go bad
07:56:44 <merijn> Granted, it only exports like 3-4 functions
07:58:04 <mauke> what the heck is D/SD/PD
07:58:24 <merijn> oh
07:58:38 <merijn> edwardk: I just realised it already went bad while looking over the code :p
07:58:59 <edwardk> see told ya
08:00:44 <merijn> edwardk: Luckily I'm a masochist when it comes to threads :)
08:01:35 <supki> mauke: 2n / 2n + 1 / 2n - 1 ?
08:02:07 <supki> I like "useful" part of the haddock title
08:02:09 <merijn> Incidentally, this is exactly the reason why I have dumped all my mask/uninterruptibleMask calls into a single module :p
08:03:33 <watermind> is Oleg's extensible effects library on hackage?
08:12:32 <sclv_> oh cute "relative adjoints can also be expressed as absolute kan lifts; in fact, they are the same"
08:12:51 <mel-> Hi, can I use wxformbuilder with wxHaskell? I can't find any documentation on that except for very few and  old (>= 2 years) newsgroup entries.
08:14:45 <lingxiao> edwardk may I ask you a question about machines? :)
08:14:56 <lingxiao> edwardk:  may I ask you a question about machines? :)
08:15:16 <watermind> sclv_: what's a relative adjoint?
08:15:53 <watermind> sclv_: found a link
08:15:56 <watermind> nevermind
08:16:29 <watermind> hmm interesting
08:19:22 <edwardk> lingxiao yes
08:19:25 <edwardk> lingxiao: yes
08:19:58 <edwardk> but i have an appointment to run to so i may not bang out a reply before i leave
08:20:15 <lingxiao> sweet. it's a "how would I do this.." kind of question if it's ok. the link to the question is here: http://stackoverflow.com/questions/17997131/using-data-machine-how-can-you-compose-two-processt-together-that-modifies-two
08:20:38 <lingxiao> but basically.. how would I compose two processT that modifies different underlying State monads?
08:21:12 <lingxiao> And it's totally fine if you can't answer now, it just gives me more time to think about it :)
08:23:31 <edwardk> well, one way to do it is to just keep one state monad with a bigger state.
08:23:39 <edwardk> and use lenses to focus in on parts of it
08:23:51 <edwardk> alas, i never made an instance of Zoom for Plan
08:26:15 <lingxiao> "one state monad with a bigger state".. does that mean one processT over a StateT (StateT...) stack?
08:26:27 <scshunt> win 13
08:26:49 <lingxiao> or like one State with a tuple of states... bascially everything in one Process
08:26:56 <donri> scshunt: I think you mean /13
08:26:57 <applicative> lingxiao: i think he means something like (Int,[Int])
08:27:23 <edwardk> lingxiao: http://stackoverflow.com/a/17998262/34707
08:27:23 <lingxiao> applicative : yeah haha I realized as soon as I typed the StateT(..) thing
08:27:38 <edwardk> i replied with the general idea
08:27:51 <applicative> lingxiao: then, if i remember, zoom p1 and zoom p2 will suddenly fit together
08:27:53 <applicative> oh
08:28:15 <applicative> oh indeed
08:28:33 <lingxiao> edwardk : ah awesome, always really nice to have the author answer my question. Thanks :)
08:30:06 <cdk> @unmtl a -> EitherT e (StateT s m) b
08:30:06 <lambdabot> a -> EitherT e (StateT s m) b
08:30:11 <cdk> @unmtl EitherT e (StateT s m) b
08:30:11 <lambdabot> EitherT e (StateT s m) b
08:30:14 <lingxiao> I guess I'm just being very hard-headed about making the logic as modular as possible, which is why I had two processT, one modifiying Int and another [Int]
08:30:20 <edwardk> with that you can then drive it with source [1..6] ~> p1 _1 ~ p2 _2
08:30:28 <piron> ?unmtl ErrorT e (StateT s m) b
08:30:28 <lambdabot> (StateT s m) (Either e b)
08:30:41 <edwardk> with a composite state as a tuple
08:30:45 <piron> ?unmtl StateT s m (Either e b)
08:30:46 <lambdabot> s -> m ((Either e b), s)
08:30:51 <edwardk> the problem is ultimately that you need to 'start' both states with something
08:34:03 <lingxiao> I guess in my mind I wanted to be able to build two different processes from three modular components: p1 = ProcessT (StateT a) a b, p2 = ProcessT (StateT [a]) a c, p3 = ProcessT (StateT Bool) a d
08:34:46 <lingxiao> and p12 = p1 ~> p2, p13 = p1 ~> p3.  where p1 = ProcessT (StateT a) a a, so the p1 above is wrong, my bad
08:34:58 <piron> I bet you can write a function that takes a ProcessT (StateT a) and a lens between s/a and turns it into a ProcessT (StateT s).
08:35:07 <edwardk> sure
08:35:07 <piron> Hell, I bet lens already provides that function somwehere.
08:35:10 <lingxiao> to so put both Int and [Int] into one process was less modular than I wanted
08:35:16 <edwardk> thats the Zoom instance i said was missing =)
08:35:28 <edwardk> you can probably concoct one and add it to machines
08:35:48 <lingxiao> oh haha, I should read better/know more LOLz
08:36:06 <piron> I would say it's pretty modular. The definitions of p1, p2, p3 needn't change; only the definition of your operator to combine them needs to change.
08:36:11 <ion> I know about three lolz and five roflz.
08:36:14 <piron> (And even there the change is a pretty uniform one.)
08:36:52 <lingxiao> ion: HAha
08:37:37 <ParahSailin> i have a function that tries a couple different approaches to succeed in getting an answer-- i have it written as a ContT, and am wondering if there is another sort of control structure to use
08:37:41 <lingxiao> edwardk: ok awesome thanks for the pointers, you're like a fairy sprinkling gold dusts every time I talk to you
08:38:02 <edwardk> np
08:38:02 <ParahSailin> basically i have a sequence of Maybes, and i try one after another until i get a Just, and return
08:38:13 <ParahSailin> so its sort of the opposite of the Maybe monad
08:39:14 <piron> ParahSailin: Why not just []? Or, if you must, LogicT
08:39:31 <tikhon> wait, so you just want the first one that's Just? how about mapMaybe?
08:40:05 <piron> :t mconcat :: [First a] -> First a
08:40:05 <lambdabot> [First a] -> First a
08:40:14 <piron> :t mapMaybe
08:40:14 <lambdabot> (a -> Maybe b) -> [a] -> [b]
08:40:38 <supki> @ty preview (folded._Just)
08:40:39 <lambdabot> (Foldable f, MonadReader (f (Maybe a)) m) => m (Maybe a)
08:41:10 <tikhon> oh, I guess if you already have the Maybe values, just do catMaybes
08:41:22 <tikhon> and take the first one
08:41:40 <k00mi> the First monoid does just that
08:41:43 <k00mi> with mconcat
08:41:55 <k00mi> ah piron already mentioned it
08:42:22 <piron> I think I would upgrade my Maybes into []s and just use [] as a Monad.
08:42:35 <ParahSailin> i think this is pretty legible, http://lpaste.net/91417
08:44:21 <piron> LogicT, observeOne, and (<|>) are my new suggestions.
08:45:22 <ParahSailin> @hoogle observOne
08:45:22 <lambdabot> No results found
08:45:24 <ParahSailin> @hoogle observeOne
08:45:24 <lambdabot> No results found
08:46:05 <piron> ?hackage logict
08:46:05 <lambdabot> http://hackage.haskell.org/package/logict
08:46:25 <piron> It's actually just called observe, I guess.
08:46:45 <piron> observeManyT 1
08:46:50 <piron> is probably better
08:47:03 <ParahSailin> thanks for suggestion
08:51:02 <stevejb> hello, can someone try compiling the following code: https://gist.github.com/stephenjbarr/6132611
08:51:03 <danharaj> does anyone know what the easiest way to decode a non-toplevel JSON value with Aeson is?
08:51:15 <danharaj> decode expects an Object or an Array and I need to decode… not that.
08:51:31 <piron> I find the "n == 1" case in the source of observeManyT a bit dodgy.
08:56:27 <piron> stevejb: You might get a bit more help if you say what you're expecting to happen and what happens instead when *you* compile.
08:57:03 <stevejb> piron: thanks. So, on my debian VM it compiles and then can be run with ./integrator +RTS -N10
08:57:16 <stevejb> on my ubuntu machine, I get an error (pasting into hpaste
08:57:56 <supki> danharaj: Data.Aeson.Parser.value, I think
08:58:33 <hpaste> stevejb pasted “error compiling on ubuntu” at http://lpaste.net/6677206413221036032
08:59:18 <stevejb> piron: does it work for you?
08:59:45 <piron> stevejb: Have you tried the suggested fix in that error message?
09:00:00 <stevejb> piron: I guess I am having trouble understanding it
09:00:51 <piron> Change the type signature of parMapChunk so that it says "(Eq b, NFData b) =>" instead of "NFData b =>".
09:01:43 <stevejb> piron: okay, that was what I expected to happen. Thank you for the help. I am still new at this
09:02:24 <stevejb> I am curious as to why one version of ghc was able to figure this out but the other was not
09:02:55 <piron> I suspect one version of GHC has Eq as a superclass of NFData, or gives parMap a different type, or some similar thing.
09:03:12 <piron> (That is, I blame a library change, not a GHC change.)
09:03:19 <stevejb> piron: that makes sense
09:03:26 <stevejb> piron: thanks for your help!
09:03:36 <piron> :)
09:04:17 <stevejb> piron: Haskell is so cool! Awesome community. Insanely fast. What more can you ask for? ;)
09:05:32 <Clint> a pony
09:05:49 <piron> ?hackage pony
09:05:49 <lambdabot> http://hackage.haskell.org/package/pony
09:05:52 <Lethalman> rotfl
09:06:37 <Lethalman> stevejb, some decent gui
09:06:54 <stevejb> Lethalman: the FP complete stuff looks cool. I just use Emacs
09:07:02 <piron> Is there a major GUI library that does not have Haskell bindings?
09:07:10 <Lethalman> stevejb, gui != ide
09:07:16 <Lethalman> I meant a gui toolkit
09:07:22 <Lethalman> piron, gtk3
09:07:22 <stevejb> Lethalman: ah okay.
09:08:03 <piron> Lethalman: Okay, it's available in gtk2hs' darcs, but not released yet.
09:08:16 <tikhon> the pony package is full of lies—it seems to contain unicorns
09:08:30 <Lethalman> piron, they don't want to use GI, I don't like much the idea of not using GI
09:08:46 <tikhon> talking about GUI libraries, has anyone looked at threepenny-gui?
09:08:50 * piron nods agreeably
09:08:55 <applicative> oh really, there'll be an gtk3hs so to say
09:09:15 <piron> applicative: yes
09:09:21 <applicative> nice
09:09:34 <applicative> I thought the labor would be too gruesome for anyone to undertake
09:09:37 <applicative> maybe it was...
09:10:08 <applicative> gruesome
09:11:28 <danharaj> supki: how do I use value to go from ByteString to Maybe a?
09:14:20 <stevejb> :t map
09:14:21 <lambdabot> (a -> b) -> [a] -> [b]
09:15:19 <supki> danharaj: well, that's just an attoparsec parser
09:15:40 <supki> I don't know why aeson does not export convenient interface for using it
09:15:42 <danharaj> supki: yeah, it seems way more cumbersome than decode. Soooo I'll just wrap my value in brackets and extract the head.
09:19:25 <parcs> what does unsafeDupableInterleaveIO (unsafeInterleaveIO foo) do?
09:19:58 <Taneb> parcs, scare people
09:21:53 <sm> chrisdotcode_: does ircbrowse.com search not handle underscores ? searching for SDL_INIT_CDROM fails
09:22:26 <chrisdotcode_> sm: heh.
09:22:35 <chrisdotcode_> sm:  you mean "chrisdone", but he's not here right now :)
09:25:45 <sm> chrisdotcode_: ah, beg your pardon
09:25:57 <chrisdotcode_> no worries
09:28:00 <sm> would anyone know why building SDL 0.6.5 with macports libsdl-devel 1.3.0 fails with undeclared SDL_INIT_CDROM ? Do I need to install some other libsdl-* lib ?
10:02:34 <kini> is a let expression in whnf?
10:03:10 <ocharles> mm_freak: just hit something of a gotcha in netwire - it seems quite easy to accidentally break the entire game down by using events  in the main gameWire
10:03:24 <ocharles> e.g., I just did: playCollisionSound chunk . when (uncurry (||)) -< collisions
10:03:42 <ocharles> if there are no collisions, then the whole game terminates. I needed a <|> id there to stop that, but nothing in the types helped me know to do that
10:03:51 <ocharles> is that just something I'll have to get used to?
10:05:37 <bergmark> kini: no
10:05:45 <bergmark> > let x = undefined in ()
10:05:46 <lambdabot>   ()
10:05:48 <merijn> ocharles: "when" is just return () if the condition doesn't hold, no?
10:06:06 <ocharles> merijn: no, when is Left when the condition doesn't hold
10:06:17 <kini> bergmark: I see
10:06:17 <merijn> ocharles: Oh, netwire when?
10:06:21 <ocharles> yea, sorry
10:06:37 <merijn> ocharles: If when inhibits so does everything following it
10:06:42 <ocharles> U jkn
10:06:44 <ocharles> erm...
10:06:46 <ocharles> I know* :)
10:06:55 <ocharles> but my problem is that becomes less clear in arrow notation
10:06:59 * ocharles pastses
10:07:01 <merijn> right
10:07:16 <hpaste> ocharles pasted “gameWire” at http://lpaste.net/91418
10:07:28 <ocharles> on line 9 it looks like it should do the right thing, but it needs <|> id to never inhibit
10:07:56 <ocharles> and nothing in the type system helped me with that, leading to a good 5 minutes of "WTF SDL WHY ARE YOU BROKEN oh it's my fault"
10:08:20 <ocharles> I guess there is event though
10:08:56 <ocharles> but it says "you shouldn't use this" so I didn't :)
10:14:05 <Sonarpulse> anybody know of a function to do with (delayed repa arays) :: [Array _ DIM_N a] -> Array _ DIM-N+1 a
10:14:55 <sm> ocharles: thanks for the article, are you using SDL on mac by chance ?
10:16:10 <ocharles> sm: nope, Linux
10:16:19 <ocharles> sm: glad you liked the post!
10:20:05 <mm_freak> ocharles: this is expected behavior
10:20:19 <mm_freak> you have to make clearer semantics of your application
10:20:47 <mm_freak> if "terminate if the game inhibits" is not the semantics you want, you should overthink your main loop
10:20:53 <mm_freak> but i think that's pretty good semantics
10:20:57 <ocharles> right, I thought that might be one solution
10:22:15 <ocharles> mm_freak: but if I do want those semantics, is event a better option than  <|> id  ?
10:23:00 <ocharles> i suppose there's not much in it
10:24:25 <mm_freak> ocharles: first ask yourself when you want to quit and whether this should be handled by the wire itself
10:25:59 <ocharles> right, having the option of producing an indication of quitting in the output of the wire itself
10:27:36 <enthropy> Sonarpulse: use toFunction / fromFunction? Maybe there's a better way though
10:28:47 <enthropy> hmm, except toFunction isnt    toFunction :: Array r sh1 a -> (sh1, sh2 -> a)
10:29:33 <applicative> sm I seem to have ocharles' 'Challenge3.hs' working on os x
10:36:39 <sm> applicative: how do you have SDL installed ?
10:36:43 <sm> I mean the c library
10:39:05 <applicative> sm yes i got it from homebrew
10:39:29 <applicative> sm what i don't know is if I applied some option ; i am using 64 bit ghc
10:40:07 <sm> ah, homebrew. I'm giving that a try, but it will require some work (xcode.. disk space..)
10:41:03 <applicative> sm you dont need xcode now, you can get the 'command line tools' from the dubious developer site
10:41:09 <applicative> sm or so i think
10:41:09 <sm> I figure SDL_INIT_CDROM is defined in macports' libsdl-sound lib or thereabouts, and that fails to install because the smpeg macport is currently broken
10:41:20 <applicative> oh.
10:44:29 * sm tries command line tools for xcode from developer.apple.com
10:47:00 <applicative> oh you found it https://developer.apple.com/downloads/index.action
10:47:04 <applicative> sm I mean
10:49:17 <haasn> I've found a mistake in marlow's book :(
10:49:40 <applicative> all simons are infallible surely
10:50:24 <sm> so true, you must be mistaken haasn
10:51:08 <haasn> in chapter 3, he references an earlier function (parMap) and shows a new way to define it; as “parMap f xs = map f xs `using` parList rseq”. However, it should be: “parMap f xs = map f xs `using` parList rpar”
10:51:27 <haasn> who do I bug to get this fixed?
10:51:41 <applicative> i think its too late
10:51:45 <applicative> whats the mistake?
10:51:53 <applicative> oh i missed last remark
10:51:55 <donri> http://oreilly.com/catalog/errata.csp?isbn=0636920026365
10:55:32 <watermind> donri: oh, I didn't know it had been released
10:55:41 <watermind> s/released/published
10:57:06 <haasn> Hmm. It says to enter a page number. I have no idea what page it's on
10:58:21 <applicative> oh i have the pdf somewhere
10:59:00 <monochrom> Marlow may reply, "fixed in HEAD" :)
10:59:01 <applicative> what chapter or section is it haasn
10:59:10 <applicative> of course, its all he ever says
10:59:26 <monochrom> there is a lambdacat for that :)
10:59:30 <haasn> applicative: chapter 3, second section
10:59:38 <haasn> or uh
10:59:41 <haasn> no idea how to count this stuff
11:00:01 <haasn> “A Strategy for Evaluating a List in Parallel”
11:00:59 <monochrom> http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg#!i=965006902&k=6djpLdS
11:01:34 <Sonarpulse> how do you convert a repa array back to a Juicy Pixels image?
11:02:15 <Sonarpulse> @hackage Codec.Picture.Repa seems to only go the otherway
11:02:16 <lambdabot> http://hackage.haskell.org/package/Codec.Picture.Repa seems to only go the otherway
11:02:27 <applicative> haasn right, sentence beginning And indeed, with Strategies, we can express it exactly this way:
11:02:33 <applicative> on page 34 of the book
11:02:34 <Sonarpulse> @module Codec.Picture.Repa seems to only go the otherway
11:02:34 <lambdabot> Unknown command, try @list
11:02:50 <Sonarpulse> @hackage juicyPixels-repa
11:02:50 <lambdabot> http://hackage.haskell.org/package/juicyPixels-repa
11:02:54 <Sonarpulse> ^ that will work
11:03:18 <piron> ?hackage JuicyPixels-repa
11:03:18 <lambdabot> http://hackage.haskell.org/package/JuicyPixels-repa
11:03:19 <haasn> applicative: thanks, submitted
11:03:31 <Sonarpulse> thanks
11:04:08 <Sonarpulse> I tried build an array by and, but the datatype seems to want a storable vector, as it reads with mmap
11:07:45 <haasn> oh wait
11:07:53 <haasn> I think this version is correct, actually
11:08:08 <haasn> the rpar would be redundant since the other combinator already introduces it. I feel stupid now :(
11:09:37 <monochrom> submit an erratum to your bug report :)
11:09:51 * monochrom loves meta games :)
11:14:09 <haasn> I don't think the service allows that =(
11:15:20 <monochrom> the other day, we were just saying: we need version control for commit messages in version control :)
11:15:20 <haasn> it hasn't been sufficiently generalized and made powerful enough
11:15:38 <haasn> monochrom: include .git in version control!
11:15:53 <monochrom> yikes
11:15:58 <haasn> better yet
11:16:04 <haasn> have both a git repo and a darcs repo in the same directory
11:16:19 <haasn> include _darcs in git and vice versa
11:16:29 <monochrom> "if darcs watch git, who watches darcs?"
11:16:50 <haasn> “git does, and laziness makes it all work out”
11:16:56 <Heffalump> mercurial has a new concept of superceding
11:17:14 <Heffalump> which I think is good enough for version controlling commits, and doesn't lead to needing infinite layers
11:17:31 <Heffalump> we'll probably implement something like it in darcs when sufficient round tuits are available
11:17:40 <roconnor> darcs++
11:18:02 <Heffalump> people wishing to supply round tuits are of course always welcome!
11:19:27 <roconnor> @wn tuit
11:19:28 <lambdabot> No match for "tuit".
11:19:51 <bscarlet> I've got a supply of them coming in next someday.
11:19:52 <haasn> Oh. as in “getting around to it”
11:27:50 <mike4_> does a byte have weight?
11:27:57 <mike4_> can I weigh a byte?
11:28:26 <piron> Yes, there are tight bounds on the maximum amount of information there can be per unit mass.
11:29:29 <mike4_> i see
11:30:07 <mike4_> i would weigh it in electron mass?
11:30:18 <monochrom> huh? wrong channel
11:30:45 * hackagebot diagrams-gtk 0.6.0.1 - Backend for rendering diagrams directly to GTK windows  http://hackage.haskell.org/package/diagrams-gtk-0.6.0.1 (BrentYorgey)
11:30:55 <mike4_> were can i ask?
11:31:19 <monochrom> I don't know. and not my problem.
11:31:42 <arkeet> ##physics maybe
11:31:54 <mike4_> ok monochrom I thought you said  wrong channel
11:32:07 <mike4_> ok arkeet
11:32:09 <simukis_> mike4_: Yes, you can actually weigh a byte. It's weight is neligible though.
11:32:12 * sm achieves success with apple command line developer tools for xcode + brew install sdl + cabal install SDL
11:32:12 <donri> it is also the wrong channel to ask what the right channel is ;)
11:33:40 <mike4_> well we deal with bytes in here one way or another. someone may know how much does one byte weigh, possibly...
11:33:43 --- mode: ChanServ set +o monochrom
11:33:50 --- kick: mike4_ was kicked by monochrom (mike4_)
11:33:59 --- mode: monochrom set +b $a:mike4_
11:34:03 --- mode: monochrom set -o monochrom
11:34:10 <sm> ahaha too soon, osx sdl strikes back! file was built for archive which is not the architecture being linked (i386)
11:35:30 <sclv_> a byte weighs eight bits
11:35:37 <monochrom> this is what is wrong with you constructivists. asserting that this is a wrong channel does not require naming a right channel.
11:36:25 <sclv_> that's not a constructivist vs. intuitonist issue.
11:36:31 <elliott> monochrom: that's fine! just define the wrong channel as not the right channel.
11:36:35 <elliott> then you don't have to.
11:37:03 <sclv_> the thing is if its not not the wrong channel, it still doesn't mean its the right channel!
11:37:22 <sclv_> or not not the right channel rather
11:37:30 <applicative> sm, I think brew remove sdl then ... this part i don't know for sure
11:37:38 <applicative> brew install sdl --universal
11:38:04 <applicative> let me study the 'brewfile' sm
11:38:24 <sm> oh hi applicative.. thanks for the tip earlier, getting closer
11:38:52 <sm> the new brew-installed libs seems to be for x86_64, and the older libs I see in /usr/local are i386
11:39:23 <applicative> sm: yes   option :universal
11:39:36 <applicative> sm, this is appears in sdl.rb
11:39:40 <sm> and arch says I'm i386. Huh, surprising. Thanks
11:39:46 <applicative> so it should take the --universal flag
11:40:02 <applicative> sm: oh the question is I think, just what ghc you are using
11:40:03 <sclv_> applicative btw i emailed sof about the hdirect page and he replied that he's not interested in getting it up again, because it is dated, etc. but does plan to release an updated version of hdirect code to github soon
11:40:16 <applicative> oh
11:40:27 <applicative> oh he has a new hdirect altogether ?
11:40:49 <sclv_> maybe just fixed compile errors and bitrot, not sure
11:41:08 <applicative> sm what ghc do you have 32 or 64 bit
11:41:15 <applicative> > maxBound :: Int
11:41:16 <lambdabot>   2147483647
11:41:21 <applicative> small ...
11:41:27 <applicative> fickle lambdabot
11:42:42 <ion> > ceiling $ do logBase 2 . fromIntegral $ do maxBound :: Int :: Double :: Integer
11:42:43 <lambdabot>   31
11:42:46 <sm> applicative: ghc +RTS --info says ("Build architecture", "i386"), does that tell you ?
11:42:47 <Gracenotes> 32-bit VMs are a lot easier to run in
11:43:06 <Gracenotes> I assume that is where she is
11:46:02 <applicative> when we read  file was built for archive which is not the architecture being linked (i386)
11:46:09 <applicative> which is whch?
11:46:26 <piron> ion: Fun.
11:46:27 <whoever> hi all, need some help with bluetile config , i am trincg to start blue tile and add the doc to gnome panel, instead of use the workspake
11:46:31 <whoever> can someone assist
11:46:54 <piron> ion: Why does that work? Something screwy about type annotations that gets de-ambiguated by do blocks or something?
11:46:56 <whoever> or even to use bluetile and hide the doc
11:47:03 <piron> whoever: You might like #xmonad.
11:47:23 <applicative> yes whoever if anyones around in #xmonad they will know
11:47:27 <whoever> piron: thats what i have tried befor
11:47:31 <applicative> darn
11:47:42 <sm> applicative: the SDL libs built by brew are for 64 bit
11:47:54 <piron> whoever: Wait a bit (4-6 hours). If nobody responds in that time, try sending an email to the mailing list, or ask again in-channel.
11:47:55 <whoever> and i thaught i could use bluetile much like xmonad without haveinv to install xmonad
11:48:04 <applicative> sm right thats what i was thinking, but there is an option --universal
11:48:35 <applicative> so that brew install sdl --universal should have worked, if i understand
11:48:39 <sm> ok. I guess I installed a 32 bit ghc. And osx 10.7 is not "64 bit" as I thought, but both 32 and 64 bit
11:48:51 <applicative> right, os x is a madhouse
11:49:15 <applicative> but in theory you should be okay with a sdl that is also-32-bit
11:49:22 <sm> do folks generally install the 32 or 64 bit ghc ?
11:49:41 <lispy> sm: 64bit unless windows
11:49:43 <applicative> sm my impression is that on os x 32 bit is more reliable
11:49:55 <applicative> oh
11:50:04 <lispy> sm: I don't know if 7.8 will be usable, but at least on windows the 64bit build can't actually link anything
11:50:39 <lispy> sm: and the solution there is probably to use the system wide linker (actually gnu ld), and I think that change is there for some platforms.
11:51:00 <sm> ok. On mac, I figure 32 bit would probably be generally more reliable/efficient so usually choose that one
11:51:22 <applicative> sm that was at least in the past the general view
11:51:34 <monochrom> osx is somewhat a madhouse. some past thread on haskell-cafe said, 32-bit GHC had some problems, 64-bit GHC had some other problems
11:51:46 <applicative> i think thats right
11:51:54 <lispy> Maybe I'm a bad one to ask. I use ghc on osx for random things but I do all my "real" haskell work on linux
11:52:33 <sm> but if I want to link with brew-installed libs.. and not deal with special brew config.. perhaps ghc 64 bit will be a better choice
11:52:55 <sm> ok, removed and reinstalled sdl with --universal and it links. Hurrah
11:53:07 <sm> let's run it before I declare victory..
11:53:11 <applicative> oh great
11:53:26 <sm> lol, smart.. stack trace now :)
11:54:29 <hpaste> sm pasted “osx sdl install” at http://lpaste.net/91420
11:55:56 <applicative> sm if you do cabal unpack sdl there is an examples folder with a subdirectory MacOS
11:56:18 <applicative> sm if youi swap out the Main.hs there for whichever, I found it works
11:56:46 <applicative> better would be a demo file cabalized with cabal-macosx
11:57:24 <sm> applicative: ah, I remember.. so looks like my SDL is good now, but ocharles' netwire examples don't have the special SDL-on-mac magic
11:57:33 <sm> a pity that's still required
11:57:56 <sm> cabal-macosx, good idea
11:59:12 <piron> sm: https://github.com/banthar/Go-SDL/issues/19 looks relevant and suggests a workaround
11:59:33 <applicative> sm yes, for some reason directly calling a gui app tends to be a disaster, the Makefile in the sdl demo for os x has a trivial wrapper
12:01:07 <applicative> oh piron right, it looks similar to the indirection in the sdl demo folder
12:04:51 <applicative> SDL uses Objective-C and Cocoa to open a UI window; this means that Cocoa must be initialized, and in particular, an NSAutoReleasePool be in place.  This initialization is done in libSDLmain.
12:05:01 <applicative> and so on
12:05:02 <sm> piron: thanks. The workaround doesn't work here ("No available video device")
12:05:14 <piron> bummer
12:05:17 <whoever> Proteumus: got it , now i just gotta rembmer the keymaping
12:05:18 <sm> it sounds like this might be (could it be ?) solved in SDL 1.3
12:05:46 <whoever> oops auto coplete
12:05:57 <whoever> piron: got it , now i just gotta rembmer the keymaping
12:06:21 <piron> Great!
12:06:30 <applicative> sm did you try the example Main.hs in SDL-0.6.5/Examples/MacOSX
12:08:00 <sm> applicative: doing that now, I suppose I might as well press on
12:08:27 <applicative> the original example in the folder needs ../image.bmp which of course it doesn't supply
12:08:50 <sm> let me ask you though, do you think cabal-macosx solves this SDL init issue ? If so I'll also try and get that fixed
12:09:50 <applicative> sm no i thought about that it's more complicated than I remembered
12:09:50 <piron> applicative: File a bug!
12:10:35 <ion> piron: In “do … :: Type”, the type annotation ends the do block or something along those lines.
12:10:59 <sm> well, after using the wrapper (my own template from before) it runs. VICTORY
12:11:32 <piron> applicative: For bonus points, just send them a patch fixing it. It looks like image.bmp is in the repository, so you probably just need to add it to the appropriate stanza in the cabal file.
12:12:34 <piron> > do 3 :: Int + 5
12:12:35 <lambdabot>   <hint>:1:15: Illegal literal in type (use -XDataKinds to enable): 5
12:12:40 <applicative> sm awesome
12:12:42 <piron> hm, right
12:12:58 <piron> okay, how about
12:13:11 <piron> > do [3] :: [Int]; [5]
12:13:12 <lambdabot>   [5]
12:13:21 <piron> Doesn't seem to end the do block...
12:13:27 <applicative> man that's some revolting type  Int + 5
12:13:54 <sm> thanks for the help all. I have housecleaned my mac to get this running, which is good :)
12:14:13 <applicative> > do [3,4] :: [Int]; [5]
12:14:14 <lambdabot>   [5,5]
12:14:17 <piron> Oh, maybe that's not fair because ; is otherwise unallowed.
12:14:32 <piron> > let x = do [3] :: Int; y = 5 in y
12:14:33 <lambdabot>   <hint>:1:26: parse error on input `='
12:20:54 <clj_newb_2345> i just implemented (not used) parsec
12:20:59 <clj_newb_2345> and it was a mind blowingly awesome experience
12:21:07 <clj_newb_2345> what are other cool haskell libraries worth understanding how they're implemented?
12:21:10 <MedDev> The hell.  I'm running ghc --make MyFile.hs and it's not linking an executable?  I'm using the exact same arguments as I was to build another executable.
12:21:22 <ocharles> sm: did you get everything working?
12:21:30 <sm> ocharles: yes
12:21:37 <MedDev> ah nevermind forgot to name the module Main :|
12:21:59 <byorgey> MedDev: if the module has a name other than Main you can also pass the option  -main-is MyFile   to ghc
12:22:14 <ocharles> sm: excellent! what was the magic sauce?
12:23:07 <piron> clj_newb_2345: If you haven't had a look at Okasaki's thesis/book, that's a pretty awesome one.
12:23:23 <piron> And finger trees, mmmm...
12:23:31 <clj_newb_2345> piron: purely functional data structures?
12:23:37 <piron> the very one
12:23:51 <clj_newb_2345> i was thinking more laong the lines of things of the form "there's this shitty way to do X; there's this really cool monadic way to do X instead"
12:24:05 <piron> Sure, sure.
12:24:05 <sm> ocharles: a wrapper like http://hub.darcs.net/Lemmih/hssdl/browse/Examples/MacOSX . I think I have a cabalised variant too
12:24:12 <clj_newb_2345> parsec changes the way that I think about parsing
12:24:16 <piron> Ah, how about quickcheck?
12:24:24 <clj_newb_2345> I want something that will change the way that I think about XYZ , where XYZ = common tak
12:24:27 <clj_newb_2345> s/tak/task
12:24:32 <piron> XYZ = testing
12:24:59 <clj_newb_2345> I'm going to study fruit next
12:25:04 <clj_newb_2345> and see what this purely functional GUI is about
12:25:07 <ocharles> sm: oh, fun
12:25:17 <piron> That sounds pretty good.
12:25:51 * hackagebot diagrams-haddock 0.1.1.1 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.1.1.1 (BrentYorgey)
12:26:06 <jfischoff> ^ so cool
12:26:19 <piron> Implementing zippers for a few types can be good fun, too. XYZ = containers (and what other languages call iterators)
12:26:36 <jfischoff> automatic differentiation
12:26:51 <piron> Good one!
12:27:45 <jfischoff> the type class induction used in JSON-RPC
12:28:05 <jfischoff> uniplate
12:28:15 <piron> I think he's gone.
12:28:19 <jfischoff> oh well
12:34:45 <RpR> <sigh> Newbie Haskell questions about hashtables if anyone has a moment and a kind soul to help out.  https://gist.github.com/RayRacine/6134465
12:37:02 <geekosaur> (a) by design you cannot escape ST. (b) hash tables are rarely what you actually want in Haskell; most commonly one uses Map.
12:38:45 <whoever> what hook controles the number of workspaces that bluetile or xmonad uses ? it is showing 32 but if i just launch gnome its 4
12:39:01 <monochrom> consider both Data.Map (package name: containers) and Data.HashMap (package name: unordered-containers). use actual measurement, do not use "conventional wisdom" aka prejudice.
12:39:49 <MedDev> whoever, ask in #xmonad?
12:39:52 <geekosaur> whoever: there's a #xmonad channel. but: xmonad creates workspaces based on the "workspaces" element of the XConfig record. gnome and kde have separate window managers which create different defauults
12:39:58 <RpR> geekosaur: So a 'filterAboveThreshold' cannot be written?
12:40:14 <geekosaur> also, if you aren't using an appropriate config, neither gnome nor kde will see xmonad's workspaces/
12:40:45 <RpR> monochrom: will look at.
12:40:51 <geekosaur> RpR, I did not say that, are you under the impression that your data structure can only bcorrect if it is *named* "hash table"?
12:40:54 <whoever> MedDev: , geekosaur I am using bluetile, that is basicly a config  and is written in haskel
12:41:32 <whoever> and there doesn't seem to bee to much in the way of docs, and has beeen around for about 5 years
12:41:35 <geekosaur> hrm. if you got a bluetile package from your OS or from cabal then it's probably obsolete. bluetile was merged into xmonad several years ago
12:42:27 <whoever> greymalkin: so i should be in the #xmonad
12:42:32 <whoever> ok, thx
12:42:55 <RpR> geekosaur: Only saying, given the assumption that of the St s (HashTable T0 T1), given that data structure there is no application of s or mode of doing a runST, etc in such a manner that one can construct 'filterAboveThreshold' as given in the gist.
12:43:21 <geekosaur> it would have to be in ST
12:44:39 <geekosaur> it can be done, but it is somewhat painful; usually it's better to use a key/value type that doesn't require IO or ST
12:44:45 <MedDev> whoever, what geekosaur said :) bluetile is obsolete by a long shot. try looking at the wiki http://www.haskell.org/haskellwiki/Xmonad/Using_xmonad_in_Gnome that should give a good idea of running a hybrid system
12:45:15 <MedDev> whoever, why would you not just want to use xmonad proper anyway?
12:45:20 <RpR> geekosaur: thx.
12:45:22 <geekosaur> which is why monochrom and I suggested alternatives that don't require you to mess with ST
12:50:58 <cschneid> Are there good presentations about haskell programming from a practical place?  Similar to how ruby conferences post a bunch of talks after the fact, and screencasts like RubyTapas exist?
12:51:10 <cschneid> similar in the haskell community?  -- super pragmatic types of sources
12:51:23 <jfischoff> specifically what do you want?
12:51:34 <merijn> What qualifies as "super pragmatic"?
12:51:41 <jfischoff> web stuff?
12:51:44 <cschneid> as in, people writing code and talking their way through it.
12:51:58 <jfischoff> so just screencasts?
12:52:01 <cschneid> how do I build anything bigger than a toy program, when do I reach for various tools, what tradeoffs
12:52:10 <cschneid> yes, screencasts may be an answer. Conf talks may be as well.
12:52:20 <cschneid> just not plugged into the community to know where to look
12:52:24 <jfischoff> Here is the problem
12:52:43 <jfischoff> I work at company that has a relatively large haskell code base
12:52:48 <jfischoff> but I can't talk about it
12:52:56 <jfischoff> and in general that is the case
12:53:08 <carter> jfischoff: luckily theres me
12:53:13 <carter> :)
12:53:29 <jfischoff> true, but I think it is asking for a lot actually
12:53:49 <watermind> jfischoff: midn if I what kind of company it is? just curious
12:53:51 <carter> who's asking what?
12:54:00 <carter> theres CUFP talks
12:54:02 <jfischoff> IMVU
12:54:30 <watermind> oh interesting
12:54:51 <cschneid> carter: I want to figure out how I'd build a moderately sized program. For instance, a zeromq program that subs to a socket, does work (maybe database or file access), spits out stuff on other sockets.  I don't get how to start architecting that.
12:55:06 <carter> cschneid architecting is hard
12:55:26 <cschneid> like, I know monad transformers exist, which may solve one or more of my problems, but from what I've read, they can easily introduce new ones
12:55:42 <carter> i don't really use monad transformers ever really
12:55:47 <carter> otoh i don't do web dev really
12:55:59 <watermind> does Oleg effects library  presently obsoletes monad transformers?
12:56:10 <cschneid> sure. You get what I'm saying though, I have a huge pile of tools, but no idea how to build something out of them :)
12:56:13 <watermind> or are monad trasformers still better for any purposes?
12:56:18 <cschneid> it's the roughest part of learning any new language imo
12:56:32 <carter> seriously: i never use monad transforms
12:56:37 <carter> lots of people do
12:56:46 <carter> ok, maybe I did once last falll
12:56:46 <watermind> I've just skimmed the paper and it seems pretty cool
12:56:53 <watermind> but haven't tried the library yet
12:56:56 <sipa> A programmer had a problem, amd thought: "I kmow, I'll use monads!". Now he has to lift all his problems.
12:57:03 <watermind> so I don't know about error messages and the like
12:57:13 <carter> read the nicely written libs
12:57:16 <carter> and example applications
12:57:18 <carter> people have
12:57:34 <carter> doug beardsley (mightybyte) and the snap folks have a bunch i think
12:58:29 <cschneid> I'm not super interested in web, but more generally building from scratch.
12:58:36 <carter> building what
12:58:41 <carter> whats the goal
12:58:56 <carter> specify what a project you'd want to work on would be
12:58:56 <NemesisD> hi guys. i'm getting a "file is locked" error when an opening a file with fast logger. I'm 80% sure this is an error due to lazy evaluation but i don't know how to troubleshoot it https://github.com/MichaelXavier/vigilance/blob/master/src/Utils/Vigilance/Main.hs#L38 and https://github.com/MichaelXavier/vigilance/blob/master/src/Utils/Vigilance/Notifiers/Log.hs#L34
12:59:11 <cschneid> I had a description. Basically a daemon process that listens on a zero mq socket, does work, including perhaps database access, file access, logging, etc. and then spits answers back out across a different socket.
12:59:15 <NemesisD> the error is vigilance: log/vigilance.log: openFile: resource busy (file is locked)
12:59:19 <cschneid> carter: ^^
12:59:23 <carter> ok
12:59:27 <NemesisD> do i need to force evaluation on the logger or something?
12:59:36 <carter> cschneid hrmm
12:59:42 <carter> what i'd do naively
12:59:48 <carter> is have one thread listening
12:59:59 <carter> which sends work to via a stmchan queue thingy
13:00:01 <carter> to another thread
13:00:30 <carter> which processes the queue, for simplicity say sychrnounously
13:00:35 <carter> then sends the responses
13:00:42 <carter> on that other socket
13:01:24 <cschneid> I haven't done threading work yet :-/ Does each thread have its own "main" that exists inside the IO monad, and can do logging & such?
13:01:35 <carter> cschneid read the lib docs
13:01:39 <carter> they're well written
13:01:45 <carter> HELL, get the simon marlow book :)
13:02:06 <cschneid> ok. I'll pick it up
13:02:15 <jfischoff> @hoogle forkIO
13:02:15 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
13:02:15 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
13:02:16 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
13:02:46 <jfischoff> so you just pass in a IO () action to make a thread
13:03:41 <cschneid> I suppose I don't know how to do stuff like logging in a haskell program. a Writer monad (or similar approach) inside the calculations, then actually spit it out to IO when you get back up that high in the system?
13:03:50 <carter> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html
13:04:02 <jfischoff> don't use Writer for logging
13:04:02 <carter> cschneid i have the answer for you
13:04:07 <carter> there more then one good way to do it
13:04:27 <carter> i actually never use any of the reader / writer monads too
13:04:43 <carter> theres no golden "one true way"
13:04:51 <carter> theres a diverse range of good haskell styles
13:04:57 <cschneid> of which I know none :)
13:05:03 <carter> read libraries
13:05:06 <carter> try and write things
13:05:09 <carter> ask questions when you're stuck
13:05:12 <Adeon> I smash keys until programs fall out
13:05:20 <carter> Adeon that must take a while
13:05:25 <cschneid> ya, which is why I started asking for screencasts / waklthroughs as people build code
13:05:47 <carter> cschneid the nyc haskel meetup talks are all recorded
13:06:10 <carter> as are some (i think) of the Bay area haskell ones, though jfischoff  would know better than I
13:06:12 <jfischoff> have a seperate thread for logging. Make a shared queue. It should be bounded and non blocking, I think. Its better to loss logging messages than stop the running of the application
13:06:44 <jfischoff> I have been busy with baby recently so can't say really
13:07:38 <jfischoff> there is that much special about making a Haskell networking other than it is alot easier because of STM
13:08:27 <carter> jfischoff *isnt?
13:08:34 <jfischoff> oops yeah
13:08:45 <carter> ie: same ole same ole, now with a type system
13:08:59 <jfischoff> at least at first
13:09:57 <carter> well yeah
13:10:03 <carter> thres fancy stuff for parallel
13:10:05 <carter> and other bits too
13:10:14 <carter> really best on planet stuff
13:10:17 <carter> more coming
13:10:20 <jfischoff> yeah
13:10:52 * hackagebot haeredes 0.1 - Confirm delegation of NS and MX records.  http://hackage.haskell.org/package/haeredes-0.1 (MichaelOrlitzky)
13:10:56 <NemesisD> anyone know where i should start troubleshooting when i get an error that a resource is locked when opeing the file
13:11:12 <k00mi> cschneid: there are some screencast thingies on youtube, though I didn't watch any so can't tell you what's good
13:11:22 <mauke> NemesisD: what's the error message?
13:12:04 <k00mi> cschneid: also, that question gets asked on reddit from time to time, so you might search through http://www.reddit.com/r/haskell/
13:12:48 <NemesisD> mauke: error: vigilance: log/vigilance.log: openFile: resource busy (file is locked) relevant lines of code probably: https://github.com/MichaelXavier/vigilance/blob/master/src/Utils/Vigilance/Main.hs#L38 and https://github.com/MichaelXavier/vigilance/blob/master/src/Utils/Vigilance/Notifiers/Log.hs#L34
13:13:35 <mauke> NemesisD: that doesn't say a "resource is locked"
13:13:38 * mauke rolls eyes
13:14:24 <NemesisD> sorry. typo
13:14:52 <mauke> NemesisD: how many instances of the program are running?
13:15:10 <NemesisD> mauke: just the one
13:15:56 <NemesisD> mauke: i will have at least 2 threads writing to that file but to simplify things i've reduced it to just opening 1 fast-logger for now
13:16:14 <carter> what ghc version is this?
13:16:21 <roconnor> Is there a common name for the J monad?  I'm aware of the Search monad, but that seems like J Bool specifically.
13:16:29 <NemesisD> carter: 7.6.3
13:16:32 <carter> ahhh
13:16:33 <carter> huh
13:16:35 <mauke> NemesisD: try strace?
13:18:22 <NemesisD> hmm might be this inappropriate ioctl for device
13:18:54 <hpaste> NemesisD pasted “strace file locked” at http://lpaste.net/91424
13:20:27 <NemesisD> things seem to go wrong on the fstat call
13:21:26 <MedDev> how can I have ghci search the directory ./.. for modules instead of just ./?
13:22:08 <mauke> NemesisD: that's bizarre
13:23:13 <NemesisD> mauke: yeah. is the mismatch of modes significant? it creates it with 0666 and fstat(8, {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
13:23:22 <NemesisD> like its created with the wrong mode? i'm out of my element
13:23:37 <mauke> NemesisD: umask
13:24:17 <NemesisD> hmm
13:25:18 <NemesisD> man what could be using that file. this is weird
13:25:34 <geekosaur> MedDev, :set -i..
13:26:18 <NemesisD> mauke: ah i noticed it opens that file twice
13:26:30 <mauke> yes, but I don't see any locking attempts
13:27:19 <mauke> the ioctl TCGETS thing is isatty(), btw
13:28:38 <NemesisD> mauke: oh, so its just verifying that its a regular file. the error isn't a problem?
13:28:41 <MedDev> geekosaur, thanks :)
13:29:12 <mauke> NemesisD: right
13:31:21 <NemesisD> mauke: so what would i see in the strace if it was locking? i ran strace with no special arguments except -s 64 for larger strings
13:31:50 <mauke> I would've expected something like flock or fcntl
13:33:20 <geekosaur> don't you also get a message about "locked" when the problem is the haskell program has it open for write still when you open for read, and that's not done with an OS lock call but internally in the IO manager?
13:33:47 <NemesisD> mauke: hmm, i notice it opens with O_WRONLY and O_NONBLOCK, the docs for open says if O_NONBLOCK is set  An open() for writing only will return an error if no process currently has the file open for reading.
13:33:59 <NemesisD> not sure i understand that
13:34:12 <mauke> geekosaur: ooh, interesting
13:34:41 <mauke> NemesisD: that should only apply to fifos
13:34:47 <NemesisD> who is reading the file though, this file is opened twice with O_WRONLY|O_CREAT|O_NOCTTY|O_APPEND|O_NONBLOCK, 0666
13:35:21 <cschneid> ok, purchased parallel and concurrent programming in haskell. brb, reading :)
13:36:10 <geekosaur> entirely possible the same thing that blocks open for read while open for write also blocks concurrent opens for write
13:36:38 <NemesisD> geekosaur: i could buy that
13:37:03 <geekosaur> so you'd have to check your program logic (and beware of lazy I/O!)
13:37:05 <NemesisD> though there must be some way for fast-logger to concurrently append to the logfile
13:37:15 <NemesisD> that is one thing i'm pretty terrible at doing
13:37:41 <geekosaur> many people do consider this behavior (required by the standard, I think) as a misfeature
13:37:52 <merijn> NemesisD: Just have a single thread appending to the file and have everything else send things to that thread?
13:38:08 <NemesisD> geekosaur: though interestingly enough, those 2 instances get fds 7 and 8 and i see no read(7/8 or write(7/8 attempts in the strace
13:38:35 <NemesisD> merijn: i'll do that if i have to but i'd like to rule out a simpler error before i go to the more exotic solution
13:39:37 <NemesisD> i'm also not entirely sure why that file is opened twice, i only make 1 open call as far as i know
13:40:03 <merijn> NemesisD: I would actually consider that the simpler solution
13:40:12 <merijn> Concurrent file access is a terrible mess
13:40:37 <merijn> Unless you have an experimental transactional FS, in which case, good on you :)
13:40:58 <ocharles> mm_freak: hmm, I think I just wanted that different event semantics you mentioned, about running both wires. I wanted to do: after 1 &&& asSoonAs (not . keyDown' SDL.SDLK_SPACE) -- with the idea that my cooldown is at least 1 second, and the user has to toggle the space key.
13:41:14 <ocharles> But if they toggle during that 1s cooldown, that information is lost because 'after 1' is inhibiting
13:41:29 <ocharles> I wonder if I want to multicast
13:41:59 <merijn> ocharles: Maybe you want to change the inhibition to "hold at least 1s"
13:42:04 <NemesisD> merijn: i don't necessarily disagree, it just seems like since fast-logger is line oriented that it should work
13:42:14 <ocharles> merijn: not sure I follow
13:42:39 <mm_freak> ocharles: see holdFor
13:42:42 <merijn> ocharles: Rather than have a wire inhibit for 1s, have it produce the same value for one second, which still lets you see any inputs
13:43:05 <merijn> They just won't be visible "downstream"
13:43:18 <clahey> Hey all.
13:43:26 <clahey> Is this the right place to ask about blaze?
13:43:31 <ocharles> clahey: certainly
13:44:46 <ocharles> merijn: nope, still don't think I'm seeing it :( let me paste the whole shooting event
13:44:48 <hpaste> ocharles pasted “Shooting event” at http://lpaste.net/91425
13:44:54 <ocharles> that has the semantics I want
13:44:59 <ocharles> so maybe that's fine
13:45:12 <ocharles> (I can probably lose some parethesis)
13:45:39 <clahey> I was missing OverloadedStrings.
13:46:38 <merijn> ocharles: I'm not familiar with multicast
13:47:23 <ocharles> merijn: it seems to be what I want, which is to step all wires and inhibit if any inhibit
13:47:32 <ocharles> http://hackage.haskell.org/packages/archive/netwire/4.0.7/doc/html/Control-Wire-Trans-Combine.html#g:2
13:47:48 <NemesisD> merijn: so if i were to push logging to 1 thread, would it be like a Chan Text that I pass around to everything that needs to log?
13:47:50 <ocharles> I think I'll stick with this for now and move on to working out how to create bullets
13:47:58 <merijn> ocharles: Lemme see if I get this right
13:48:28 <merijn> ocharles: Pressing space should toggle shooting on or off, but the toggle can only change after 1s of shooting?
13:48:41 <ocharles> merijn: not quite
13:49:06 <merijn> NemesisD: "Reader (Chan Text)" seems to work for me
13:49:22 <ocharles> merijn: space shoots one bullet, at which point you're in a colodown of 1s. to shoot again, you must have released the spacebar after the instant the bullet was shot
13:49:32 <ocharles> merijn: you can release in the 1s cooldown or after
13:49:58 <merijn> but you can't repress until 1s is over?
13:49:58 <ocharles> so i think to model the 'or', multicast is the right approach. it's just a bit annoying that I have to 'arr head' it back to id
13:50:16 <ocharles> merijn: you can, that just means that when 1s is up you'll immediately fire
13:50:24 <merijn> Right
13:50:55 <hape01> cabal install -j .... is so wow! fast
13:51:07 <ocharles> hape01: it'll be even faster when we get parallel ghc --make :)
13:51:26 <hape01> ocharles: that is for christmas then I guess
13:51:52 <merijn> ocharles: Where are --> and once from, again?
13:52:22 <ocharles> merijn: Control.Wire.Trans.Switch and Control.Wire.Prefab.Event
13:55:21 <merijn> ocharles: Right, so it produces when you press space, which goes into once and then switches to cooldown followed by isShooting
13:55:36 <ocharles> yea
13:55:54 <merijn> And the idea is that cooldown doesn't produce a value for isShooting until either 1s has gone OR space is pressed, whichever happens last
13:56:24 <ocharles> until 1s has passed since t0, and the space bar has been released since t0
13:56:29 <ocharles> which i think is what you said
13:57:01 <merijn> yeah
13:59:07 <merijn> And the problem is that "after 1" inhibiting stops values from reaching "not . keyDown"
13:59:53 <ocharles> merijn: yep, and if you switch it round the cooldown would only happen when you release the space bar
14:00:14 <ocharles> (though multicast does what I want, just making sure you didn't miss that)
14:03:01 <merijn> ocharles: I have a better idea, I just need to find the puzzle pieces in the API :p
14:04:51 <ocharles> merijn: :)
14:04:57 <ocharles> merijn: i look forward to seeing what you come up with!
14:05:50 <merijn> oh
14:05:58 <merijn> I completely missed the easy part
14:09:28 <merijn> Something along the lines of: "(gotEvent (after 1) &&& asSoonAs (not . keyDown' SDL.SDLK_SPACE)) >>> arr (uncurry (&&))"
14:09:45 <merijn> And then you need to make it hold/inhibit until that returns true
14:09:53 <merijn> Actually
14:10:23 <merijn> "(&&) <$> gotEvent (after 1) <*> asSoonAs (not . keyDown' SDL.SDLK_SPACE)" would be simpler
14:10:36 <ocharles> but that means the wire is no longer an event
14:10:43 <ocharles> because it's not (a -> a)
14:10:55 <ocharles> well, Event Keysym, anyway
14:11:16 <ocharles> which is not the end of the world either, but i was trying to stick to netwire idioms
14:11:58 <merijn> ocharles: Well, if you find a way to make that one inhibit, then turning it into an event is a matter of "fmap snd (thatWire &&& id)" or something
14:12:07 <merijn> mm_freak probably knows a better way
14:12:14 <merijn> I'm not that familiar with the netwire API
14:12:19 <mrcylinder> hey folks
14:12:52 <mrcylinder> toki.burn3r.de
14:13:13 <haasn> it just occurred to me that it would be useful to have a version of ($) that associates to the left, to turn “f (a b c) (d e f)” into “f ? a b c ? d e f”
14:13:25 <mauke> €
14:13:46 <elliott> haasn: you haven't heard cale advocate for that before?
14:13:51 <elliott> (($) being infixl)
14:13:52 <c_wraith> haasn: in fact, many people think ($) should associate to the left.  Because it would enable new things, and right-associating doesn't
14:13:53 <haasn> elliott: apparently not
14:14:10 <haasn> yeah, a $ (b $ c) is easily just (a . b) $ c
14:14:16 <c_wraith> well.  new syntactic things with just prelude imported.
14:27:31 <sclv_> @remember elliott halting problem, n. the property which makes stating anything about programs impossible, according to at least one person in any room
14:27:31 <lambdabot> Okay.
14:28:04 <Taneb> print "hello world"
14:28:09 <Taneb> What does that do? nobody knows
14:28:12 <Taneb> Halting problem.
14:28:15 <b2coutts> sclv_: hahahaha
14:28:28 <tikhon> strictly, that's more like Rice's theorem
14:29:01 <tikhon> it's the theorem that says static analysis is a field of masochists
14:29:46 <shoret> and c++ code writing is a field of sadists
14:30:24 <b2coutts> it's somehow more comforting to think of horrible code being produced by sadism rather than incompetence
14:30:58 <haasn> I don't know why a world full of sadists comforts you any more
14:31:06 <fuzzy_id> hi
14:31:59 <fuzzy_id> i'd like to play a bit with infix, infixl and infixr
14:32:14 <fuzzy_id> is there a way to declare a fixity in the interpreter?
14:32:35 <fuzzy_id> i had something like
14:32:35 <b2coutts> haasn: I guess it implies there's a certain to order to the world, and that the people around me know what they're doing
14:32:45 <fuzzy_id> let min = (-)
14:33:01 <fuzzy_id> in my mind and give play around with that…
14:33:18 <haasn> fuzzy_id: let (...) = foo; infixr 7 ... -- would be an example
14:33:44 <haasn> has to be in the same statement as the definition though if I'm not mistaken
14:34:25 <fuzzy_id> yep, that example works
14:34:47 <shoret> i was just saying c++ makes static analysis hell, that's all
14:35:14 <fuzzy_id> is infix[rl] only applicable to operators?
14:35:28 <merijn> fuzzy_id: nope
14:35:38 <merijn> fuzzy_id: "infixl `elem` 2" works
14:35:39 <haasn> infixr `foo` -- works
14:35:51 <haasn> well, with a number
14:36:15 <haasn> but the number comes before the operator :)
14:36:36 <fuzzy_id> ok
14:39:26 <fuzzy_id> that's strange: why does the interpreter treat "let foo = (-)" [newline] "infixl 7 `foo`" [newline] and "let foo = (-); infixl 7 `foo`" [newline] differently?
14:40:06 <fuzzy_id> i thought this should be equivalent
14:40:24 <geekosaur> because each line is a new declaration
14:40:32 <geekosaur> or expression
14:40:44 <geekosaur> you can use :{ :} to do multiline stuff in ghci
14:40:47 <donri> fuzzy_id: :{ and :} around multiline definitions
14:41:08 <fuzzy_id> ok
14:41:29 <fuzzy_id> so `;' doesn't mark the end of an expression then?
14:42:17 <fuzzy_id> … statement separator
14:42:45 <geekosaur> it's... complex. things like "let" actually want to invoke layout on a block, but you cn't use layout without multiline mode
14:43:00 <enthropy> fuzzy_id: doesn't the one with the semicolon work?
14:43:14 <fuzzy_id> enthropy: yep it does indeed
14:43:16 <geekosaur> you can imagine that what you're doing there is:  let { foo = whatever; infixl 4 foo }
14:43:41 <geekosaur> you can study the language report to see how the brace insertion stuff works
14:44:38 <fuzzy_id> geekosaur: ok, thanks!
14:44:58 <geekosaur> but the short version is that certain things (let, do, case ... of) take a block, and braces get inserted as needed to make something a block.
14:45:05 <fuzzy_id> your answer doesn't let it seem like magic :)
14:45:09 <haasn> fuzzy_id: for the same reason “let f [] = 0; f (x:xs) = 1 + f xs” and “let f [] = 0 <newline> let f (x:xs) = 1 + f xs” are treated differently in GHCi
14:46:21 <fuzzy_id> so the first is treated like “let {f [] = 0; f (x:xs) = 1 + f xs}”, right?
14:46:53 <Zenol> Question : What would happens if I have a C++ app calling haskell functions in diferent threads, at the same time?
14:49:42 <Zenol> (using ghc ffi)
14:49:45 <twomashi2> foldl (<*>) (Just (,)) [Just 1,Just 2] — anyone know how to make this work?
14:50:23 <b2coutts> :t <*>
14:50:24 <lambdabot> parse error on input `<*>'
14:50:29 <b2coutts> :t (<*>)
14:50:30 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:51:02 <twomashi2> The output should be Just (1,2)
14:51:52 <c_wraith> twomashi2: folds don't have the right type for that sort of thing.
14:52:07 <donri> > sequenceOf each (Just 1,Just 2)
14:52:09 <lambdabot>   Just (1,2)
14:52:22 <haasn> twomashi2: while that works for two-element lists, what would happen for lists of different lengths?
14:52:44 <donri> > sequenceOf each [Just 1,Just 2]
14:52:45 <lambdabot>   Just [1,2]
14:52:51 <twomashi2> haasn: use (,,,,) in the seed etc
14:53:05 <arkeet> > sequence [Just 1, Just 2]
14:53:07 <lambdabot>   Just [1,2]
14:53:23 <twomashi2> :t each
14:53:26 <haasn> twomashi2: but the type would have to be something like :: [a] -> ... arbitrarily sized tuple that we don't know in advance
14:53:35 <FreeFull> :t each
14:53:45 <FreeFull> :t Control.Lens.each
14:53:46 <lambdabot> (Indexable (Index t) p, Each f s t a b) => p a (f b) -> s -> f t
14:53:53 <arkeet> twomashi2: getting a tuple from a list is generally not a thing you really do.
14:54:17 <twomashi2> arkeet: I know the size in advance. Just golfing for my own education really
14:54:18 <haasn> twomashi2: remember, different sized tuples are different, completely unrelated types
14:55:17 <haasn> even beyond typing issues, there's no way to generate a sequence of all tuple constructors
14:55:19 <FreeFull> > (3,4) & each .~ 5
14:55:20 <lambdabot>   (5,5)
14:55:26 <arkeet> > (undefined,undefined) & partsOf each .~ [1,2]
14:55:28 <donri> > (,)<$>(!!0)<*>(!!1)$[1,2]
14:55:28 <FreeFull> > [1,2,3,4] & each .~ 5
14:55:29 <lambdabot>   (1,2)
14:55:30 <lambdabot>   (1,2)
14:55:30 <lambdabot>   can't find file: L.hs
14:55:41 <FreeFull> > [1,2,3,4] & each .~ 5
14:55:43 <lambdabot>   [5,5,5,5]
14:56:00 <haasn> > liftM2 (,) head last [1,2]
14:56:01 <lambdabot>   (1,2)
14:56:20 <haasn> > (head &&& last) [1,2]
14:56:20 <lambdabot>   (1,2)
14:56:21 <donri> > (1,2,3) & partsOf each %~ reverse
14:56:23 <lambdabot>   (3,2,1)
14:56:23 <b2coutts> foldl (<*>) (Just (:)) [Just 1, Just 2]
14:56:28 <b2coutts> > foldl (<*>) (Just (:)) [Just 1, Just 2]
14:56:29 <lambdabot>   Couldn't match type `[a0]' with `[a0] -> [a0]'
14:56:29 <lambdabot>  Expected type: Data.Maybe.M...
14:56:36 <FreeFull> > ap (,) reverse [1,2,3]
14:56:37 <lambdabot>   ([1,2,3],[3,2,1])
14:56:41 <twomashi2> haasn: im relying on having the type statically in advance ie (,,,)
14:56:49 <FreeFull> > (,) <*> reverse [1,2,3]
14:56:50 <lambdabot>   Couldn't match expected type `[a0 -> b0]'
14:56:50 <lambdabot>              with actual type `a1...
14:56:53 <FreeFull> > (,) <*> reverse $ [1,2,3]
14:56:54 <lambdabot>   ([1,2,3],[3,2,1])
14:57:08 <arkeet> > (undefined::(Int,Int)) & partsOf each .~ [1,2]
14:57:09 <lambdabot>   (1,2)
14:57:10 <donri> twomashi2: but the length of the list isn't reflected in its type
14:57:13 <arkeet> interesting!
14:57:32 <arkeet> > (undefined::(Int,Int)) & partsOf each .~ [1]
14:57:34 <lambdabot>   (1,*Exception: Prelude.undefined
14:57:55 <arkeet> :t each
14:58:19 <FreeFull> For some reason :t doesn't work with Lens stuff unless you provide the whole name
14:58:39 <donri> :t _1
14:58:40 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
14:58:55 <FreeFull> Well, it doesn't work for some lens stuff
14:58:58 <haasn> FreeFull: maybe lambdabot's .ghci differs from its L.hs (the latter being used for @run, the former for :t)
14:59:00 <FreeFull> And works for other lens stuff
14:59:02 <enthropy> haasn: ghc tuples only go up to 62 according to the error I get from $(tupE $ replicate 70 [| 'a' |])
14:59:02 <FreeFull> It's really weird
14:59:23 <FreeFull> haasn: If each wasn't in scope it would error
14:59:30 <FreeFull> Rather than just not returning anything
14:59:32 <FreeFull> :t moomer
14:59:33 <lambdabot> Not in scope: `moomer'
14:59:40 <haasn> FreeFull: yeah that's the weird part
14:59:45 <Peaker> Man, I miss good runtime debugging in this type inference engine
15:00:02 <haasn> enthropy: I thought it was 64. Good to know, in case I ever want to work with >62 sized tuples :)
15:00:24 <arkeet> @let fromList :: Each f s s a a => [a] -> s; fromList xs = set (partsOf each) xs undefined
15:00:24 <lambdabot>  Parse failed: MultiParamTypeClasses is not enabled
15:00:27 <arkeet> what
15:00:44 <arkeet> elliott: =(
15:00:55 * hackagebot g-npm 0.1.0 - Generate Gentoo ebuilds from NodeJS/npm packages.  http://hackage.haskell.org/package/g-npm-0.1.0 (JesusRivero)
15:01:36 <arkeet> >>> fromList [1,2,3] :: (Int,Int,Int)
15:01:36 <arkeet> (1,2,3)
15:02:17 <arkeet> I guess the type signature isn't necessary
15:02:18 <twomashi2> arkeet: you did it :) any non lens version?
15:02:22 <twomashi2> (dont hit me)
15:02:26 <arkeet> @let fromList xs = set (partsOf each) xs undefined
15:02:28 <lambdabot>  Defined.
15:02:36 <arkeet> > fromList [1,2,3] :: (Int,Int,Int)
15:02:40 <lambdabot>   mueval-core: Time limit exceeded
15:02:42 <arkeet> > fromList [1,2,3] :: (Int,Int,Int)
15:02:45 <lambdabot>   mueval-core: Time limit exceeded
15:02:48 <arkeet> =(
15:02:50 <arkeet> :t fromList
15:02:58 <arkeet> hello.
15:03:00 <arkeet> @type fromList
15:03:08 <tikhon> I think lambdabot hates you now
15:03:10 <arkeet> I know.
15:03:11 <tikhon> you made it work too hard
15:03:11 <arkeet> > fromList [1,2,3] :: (Int,Int,Int)
15:03:15 <lambdabot>   mueval-core: Time limit exceeded
15:03:18 <tikhon> :t fromList
15:03:20 <arkeet> =(
15:03:26 <arkeet> :t head
15:03:27 <lambdabot> [a] -> a
15:03:27 <tikhon> !
15:03:33 <arkeet> elliott: I blame you.
15:03:50 <arkeet> it's probably choking on some ghci output.
15:03:53 <tikhon> assigning blame is a healthy first step to solving the problem
15:03:59 <arkeet> :t L.fromList
15:04:00 <lambdabot> Each (Control.Lens.Internal.Bazaar.BazaarT (->) Mutator b b) s t b b => [b] -> t
15:04:43 <chirpsalot> tikhon: the next step is scouring other people's code for the problem, because it couldn't possibly be your fault :).
15:04:54 <arkeet> I wonder why it puts that for the first parameter for Each.
15:05:02 <arkeet> my ghci just infers a variable there.
15:05:16 <bennofs> > L.fromList [1,2,3] :: (Int, Int, Int)
15:05:20 <lambdabot>   (1,2,3)
15:05:23 <bennofs> oh cool
15:05:24 <arkeet> weird
15:05:34 <adrian_> Hello Haskellers
15:05:35 <arkeet> anyway, partsOf is awful.
15:05:39 <bennofs> I always used undefined & partsOf each .~ [1,2,3]
15:05:43 <adrian_> I have a novice question
15:05:47 <arkeet> bennofs: that's what this is
15:06:01 <bennofs> arkeet: But it feels better if it's provided by the library :D
15:06:08 <arkeet> it definitely doesn't! :D
15:06:08 <adrian_> given the askPassword :: MaybeT IO () askPassword = do lift $ putStrLn "Insert your new password:"                  value <- msum $ repeat getValidPassword                  lift $ putStrLn "Storing in database..."
15:06:32 <bennofs> adrian_: Please use lpaste for longer code pastes
15:06:35 <donri> > fromList (1,2,3) :: [Int]
15:06:36 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
15:06:36 <lambdabot>              with actual typ...
15:06:37 <bennofs> @where lpaste
15:06:37 <lambdabot> http://lpaste.net/new/haskell
15:06:46 <arkeet> donri: weird.
15:06:59 <arkeet> my ghci accepts it but returns undefined.
15:07:05 <bennofs> :O
15:07:05 <arkeet> well, an error.
15:07:15 <adrian_> lpaste askPassword :: MaybeT IO () askPassword = do lift $ putStrLn "Insert your new password"                  value <- msum $ repeat getValidPassword                  lift $ putStrLn "Storing in database..."
15:07:30 <arkeet> this isn't lpaste.
15:07:37 <bennofs> @index fromList
15:07:37 <lambdabot> Data.HashTable, Data.IntMap, Data.IntSet, Data.Map, Data.Set
15:07:40 <bennofs> @where lpaste
15:07:40 <lambdabot> http://lpaste.net/new/haskell
15:07:42 <arkeet> bennofs: I defined it above.
15:07:43 <bennofs> go there
15:08:12 <elflord> which module does the "openURL" function belong ?
15:08:21 <bennofs> Ah, so L is lambdabot-local module? I thought it was lens
15:08:24 <elflord> it's not in Network.HTTP
15:08:25 <adrian_> is something that is removing any if statement from imperative programming
15:08:26 <arkeet> @hoogle openURL
15:08:26 <lambdabot> No results found
15:08:30 <yitz> @. type run text . ('(':) . (++")") . intercalate "," $ replicate 62 "True"
15:08:32 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:08:35 <arkeet> @where hayoo
15:08:35 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
15:08:43 <adrian_> but how to call askPassword :) ?
15:08:55 <elflord> and the old Text.HTML.Download seems to be deprecated
15:08:59 <Zenol> Did I said something wrong? :(
15:09:03 <arkeet> adrian_:
15:09:06 <arkeet> :t runMaybeT
15:09:07 <lambdabot> Not in scope: `runMaybeT'
15:09:09 <arkeet> uh
15:09:10 <yitz> @. type run text . ('(':) . (++")") . intercalate "," $ replicate 10 "True"
15:09:12 <lambdabot> (Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool)
15:09:15 <bennofs> @@ (@ping) Does this stil work?
15:09:15 <lambdabot> Plugin `compose' failed with: Unknown command: ""
15:09:18 <yitz> @. type run text . ('(':) . (++")") . intercalate "," $ replicate 30 "True"
15:09:20 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:09:26 <c_wraith> Hmm.  Wonder if you can use as-bindings in type family pattern matches on lifted data types.  This sounds exceptionally unlikely, but I'm going to try.
15:09:27 <adrian_> http://lpaste.net/91426
15:09:33 <hpc> :t text
15:09:34 <lambdabot> String -> Doc
15:09:38 <arkeet> adrian_: runMaybeT :: MaybeT IO a -> IO (Maybe a)
15:09:42 <yitz> hmm. well, in a pm, it does go up to exactly 62,
15:09:54 <elflord> hoogle openURL doesnt return any results
15:09:55 <pantsman> am I just being an idiot, or is the happstack "crash cours" HSP section quite out-of-date and broken?
15:10:09 <arkeet> elflord: where are you seeing openURL?>
15:10:15 <arkeet> maybe it was defined earlier in the thing you are reading.
15:10:15 <devinus> what would you guys call the generic function used in a reducer?
15:10:23 <adrian_> arkeet : yes, is wrapped around maybeT
15:10:34 <elflord> http://neilmitchell.blogspot.fr/search/label/tagsoup
15:10:36 <arkeet> adrian_: yes, so unwrap it with runMaybeT
15:10:39 <elflord> i'm testing tagsoup
15:10:56 <adnap> Can any (Monoid a) => Applicative a be a Monoid with mempty = pure mempty and mappend = liftA2 mappend ?
15:11:00 <c_wraith> yeah, doesn't work at all.
15:11:14 <bennofs> adnap: I think it can
15:11:27 <adrian_> arkeet: heheh is working
15:11:41 <merijn> adnap: yes
15:11:48 <adnap> I typed the constraint wrong, but whatever
15:11:48 <arkeet> elflord: and it's not in Text.HTML.Download?
15:12:09 <merijn> adnap: eh, assuming you meant "Monoid a, Applicative f => Monoid (f a)"
15:12:12 <elflord> I can't find Text.HTML.Download
15:12:17 <arkeet> it's in tagsoup
15:12:20 <adnap> I did
15:13:25 <adnap> Can I automatically derive an instance for specific types?
15:13:38 <arkeet> adnap: what instances for what types?
15:14:00 <arkeet> also, Monoid a => Applicative a  is a kind error
15:14:16 <adnap> Monoid instance given instances of Applicative and Monoid instances
15:14:20 <adnap> I know!!
15:14:27 <arkeet> so what do you really mean?
15:14:53 <adnap> I already pointed that out. Scroll up; it should be obvious
15:15:16 <elflord> it's not in tagsoup
15:15:25 <arkeet> it most definitely is
15:15:43 <arkeet> adnap: oh, I missed the context.
15:15:52 <bennofs> adnap: You can generate that instance using TemplateHaskell or GHC.Generics or Data.Data I think
15:15:53 <arkeet> sort of.
15:15:54 <arkeet> part of it.
15:16:05 <adnap> Given specific Applicative f and Monoid m, can I automatically derive Monoid (f m) ?
15:16:33 <arkeet> ghc doesn't provide anything that lets you do that.
15:17:48 <enthropy> adnap: did it break when you tried OverlappingInstances?
15:18:02 <adrian_> arkeet: thanks! wish ya nice day
15:18:38 <arkeet> you can write the instance yourself of course.
15:19:11 <arkeet> although for certain f, that would over lap.
15:19:24 <arkeet> e.g. f = [] or (,) e
15:19:24 <L8D> How do I flush the stdout in haskell?
15:19:40 <bennofs> @ty stdout
15:19:41 <lambdabot> Not in scope: `stdout'
15:19:44 <bennofs> @ty hFlush
15:19:45 <lambdabot> Not in scope: `hFlush'
15:19:48 <bennofs> Hmm
15:19:53 <bennofs> @hoogle hFlush
15:19:53 <lambdabot> System.IO hFlush :: Handle -> IO ()
15:19:54 <lambdabot> GHC.IO.Handle hFlush :: Handle -> IO ()
15:19:54 <lambdabot> GHC.IO.Handle hFlushAll :: Handle -> IO ()
15:19:56 <arkeet> L8D: hFlush stdout
15:20:02 <L8D> K thanks
15:20:04 <arkeet> from System.IO
15:20:19 <arkeet> you may also be interested in changing the buffering mode
15:20:29 <arkeet> with hSetBuffering
15:20:44 <L8D> O_O
15:21:33 <mel-> anyone familiar with installing wxHaskell (through cabal)? it fails with this error: http://pastebin.com/M74zGzUy
15:21:36 <mauke> The paste M74zGzUy has been copied to http://lpaste.net/91427
15:22:44 <arkeet> mel-: you do have wxwidgets 2.9, right?
15:23:02 <sm> ocharles, applicative: I've uploaded the cabal-friendly SDL magic to http://hub.darcs.net/simon/hssdl-osx-template
15:23:11 <arkeet> what does `wx-config --list` say?
15:23:29 <mel-> arkeet: mhhh, fedora 18 ships with 2.8. so that's probably the problem.. thanks.
15:23:56 <arkeet> mel-: you could try an older version of wxHaskell then
15:24:09 <arkeet> like 0.13.x
15:24:41 <mel-> i wonder why. it doesn't have packages for wxhaskell, nor recent packages for wxgtk. it's no as if these package were having new releases every day.
15:25:40 <ocharles> sm: awesome, nice work
15:26:03 * Zenol still wondering if something can be done for multithreading calls of haskell function through ffi
15:27:45 <c_wraith> man.  type families *really* need as-patterns.  >_>
15:28:14 <bennofs> Type Families really need GHC 7.8 too :D
15:29:04 <monochrom> just a few months ago, when we were at 7.4, we said "type families really need 7.6"
15:29:23 <c_wraith> I really want to match on the type ((n ': ns@(_ ': _) :: [Nat])
15:29:29 <hpc> type families really need gadts
15:30:02 <c_wraith> But that's a syntax error. :(
15:30:06 <monochrom> we are on to a track of always wanting the next version in the future!
15:30:26 <bennofs> monochrom: And in those times, we also said HP needs GHC 7.6. Now HP has it, and we want 7.8! :D
15:31:38 <bennofs> But, I want the next version now, not in the future!
15:31:49 <c_wraith> also, it's a syntax error due to being missing a )
15:31:50 <c_wraith> oops
15:36:17 <forwardbackslash> morning
15:44:04 <xico> hi
15:44:08 <forwardbackslash> hello
15:44:23 <xico> is there an infixl (a->b)->a->b ?
15:44:48 <c_wraith> popular question today.
15:45:06 <c_wraith> And the answer is: not in any semi-standard library
15:45:16 <xico> thanks :)
15:45:43 <forwardbackslash> Isn't it ($)?
15:45:49 <monochrom> ($) is made infixr
15:45:53 <forwardbackslash> Oh wait that's infixr.
15:45:55 <forwardbackslash> Yes. :P
15:46:17 <forwardbackslash> Speaking of $, I miss F#'s |>.
15:46:25 <liyang> &
15:47:06 <thebnq> is there a way to get ghc to simplify constant functions before execution
15:47:20 <thebnq> like, sum [1..10]
15:47:22 <augur> infixl ($) is silence
15:47:33 <hpc> thebnq: that's not a "constant function"
15:47:50 <hpc> thebnq: also, just use -O2 and it will do what it can
15:48:01 <thebnq> hpc: sorry, is it if its foo = sum [1..10]
15:48:11 <hpc> thebnq: still not a constant function ;)
15:48:13 <forwardbackslash> That's not a constant function either.
15:48:28 <forwardbackslash> foo = const $ sum [1..10] -- :)
15:48:34 <hpc> anyhoo, you should wait for measurable slowness before you start dealing with optimization
15:48:41 <hpc> and then do only what profiling says to do
15:48:42 <thebnq> hm
15:48:46 <augur> fwiw
15:48:55 <augur> thebnq is looking for supercompilation
15:49:01 <augur> and afaik theres no ghc supercompiler
15:49:26 <thebnq> oh i see
15:49:43 <augur> supercompilation is still a kind of new thing
15:49:50 <hpc> if you absolutely MUST have it done at compile-time, there's template haskell
15:49:55 <hpc> but oh god, don't use it for that :P
15:50:18 <merijn> @google conal everything is a function in haskell
15:50:20 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
15:50:20 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
15:50:45 <augur> i wonder where the EIAF idea came from
15:50:48 <merijn> thebnq: See that post for why that isn't a constant function and why there is no such thing as a "constant function" in haskell
15:51:00 <merijn> augur: Read that blog post too :p
15:51:28 <merijn> augur: Conal was wondering that too, that's why he did an informal poll to find out :p
15:52:10 <merijn> augur: Also, what he's looking for isn't supercompilation (well, maybe it is, I have no clue what that fancy term means), he wants constant folding
15:52:12 <josephle> augur: perhaps somebody thought you could extrapolate from the idea that "every category can be represented with only arrows"
15:52:25 * josephle guesses wildly
15:52:50 <augur> merijn: supercompilation is compilation that evaluates as far as possible
15:52:57 <thebnq> i guess the point of memoization
15:53:00 <thebnq> its*
15:53:12 <napping> josephle: I think people were cofusing elements and exponentials
15:53:56 <augur> to some extent its true that everything is a function, but only under an advanced notion of "is"
15:54:08 <whoever_> need some help with getting xmonad to run in gnome http://www.haskell.org/haskellwiki/Xmonad/Using_xmonad_in_Gnome, followed 2.5 installed gnome-paneel, and set the config and xmonad will not start or error out when i login selecting gnome-classic  on ubuntu 12.04, can someone assist
15:54:29 <merijn> augur: According to wikipedia "supercompilation" is "Semantics-based program transformation", while constant folding falls under that, lots of other things do to
15:54:36 <napping> and I think thats a notion of function incompatible with considering (a -> b) a function
15:54:48 <Gracenotes> I think "Everything is a function" came from "Everything is an object"
15:55:03 <arkeet> everything is a value
15:55:04 <thebnq> i think that also comes from "everything is a list"
15:55:07 <arkeet> functions are overrated
15:55:12 <augur> merijn: most supercompiler work im familiar with (which is admittedly almost none, except mostly what a friend who did a phd on it told me about) is evaluation at compile time
15:55:21 <augur> but theres a talk on vimeo about it from some haskell meeting
15:55:23 <augur> lemme find it
15:55:24 <Gracenotes> People like grand universal ideas, but don't make them too universal; worse is better :)
15:55:34 <merijn> augur: Well, yes, because constant folding is fairly easy :)
15:55:38 <Zenol> can't it come from the fact that you can build the whole math structur from ensemble or functions, as you prefer?
15:55:48 <merijn> augur: Compared to other supercompilation techniques
15:56:03 <Gracenotes> No one has made a Haskell JIT yet, afaik
15:56:14 <augur> http://vimeo.com/15833948 or http://vimeo.com/16753555
15:56:22 <napping> Zenol: sure, but those are then functions different from our (a -> b) types
15:56:24 <Gracenotes> I know we like things static, but..
15:56:27 <josephle> merijn: should the compiler throw div-by-0 or should the runtime throw it?
15:56:48 <josephle> I can never tell which one is the correct behavior
15:56:53 <xico> nan
15:56:55 <xico> +inf
15:56:58 <xico> -inf
15:57:09 <Gracenotes> in Java, it's both. If you're working in C, then div-by-0 is undefined, so anything can happen.
15:57:22 <merijn> josephle: The language should just not allow div-by-0 :)
15:57:23 <jfischoff> if the compiler can detect it why not?
15:57:41 <jfischoff> stupid fields
15:57:53 <jfischoff> aren't rings enough?
15:57:58 <Gracenotes> (I'm assuming we're talking about integers)
15:58:32 <napping> Is there a nice way to make an indexed map over trees from recursion-schemes or lens stuff?
15:58:41 <napping> like ([a] -> a -> b) -> Tree a -> Tree b
15:58:42 <Zenol> jfishchoff> You won't replace all vector space by modules
15:58:47 <Zenol> you won't, beleave me :)
15:59:44 <forwardbackslash> gotta go; see you later
16:00:07 <Gracenotes> > round (1.0/0.0)
16:00:08 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
16:00:25 <Gracenotes> > length . show $ round (1.0/0.0)
16:00:27 <lambdabot>   309
16:00:45 <Zenol> only 309? :)
16:00:56 <Gracenotes> close enough
16:01:00 <mel-> now I have installed wxwidgets 2.9 and wxhaskell fails to build with a different error: http://lpaste.net/91428 :-(
16:22:01 <jaaso> carmack talking about haskell http://www.twitch.tv/bethesda
16:23:18 <applicative> mel- it's not clear what the collapse was, you might try to build it with a --verbose=3 flag or whatever.   Have you seen Peaker's repository https://github.com/Peaker/wxHaskell it seems to be the most current
16:25:06 <insejn> I'm getting the following error when trying to build git-annex via cabal: http://lpaste.net/91429
16:25:54 <insejn> how do I tell it to use base only (instead of haskell*)
16:26:02 <L8D> Perhaps you need to add `base' to the build-depends in your .cabal file.
16:29:31 <applicative> presumably the git-annex-whatever.cabal file does have base
16:29:34 <applicative> ?
16:31:47 <insejn> L8D, applicative: yes, it does contain the base dependency
16:32:15 <L8D> does it have the haskell2010 dep?
16:32:32 <insejn> L8D: nope
16:32:41 <L8D> add it
16:32:51 <elliott> jaaso: hah, inane twitch comments are even funnier when they're about haskell.
16:33:51 <insejn> L8D: aren't they incompatible? That's what I was thinking after reading this: http://stackoverflow.com/questions/10474413/ghc-package-conflicts
16:33:59 <insejn> (last entry)
16:36:07 * hackagebot notmuch-web 0.1.2 - A web interface to the notmuch email indexer  http://hackage.haskell.org/package/notmuch-web-0.1.2 (JohnLenz)
16:36:09 * hackagebot fixed-storable-array 0.3.1.0 - Fixed-size wrapper for StorableArray, providing a  Storable instance  http://hackage.haskell.org/package/fixed-storable-array-0.3.1.0 (CarlHowells)
16:47:31 <chrisdotcode> is there an Either-like type for non-errors?
16:47:42 <chrisdotcode> Like if I want to represent two possibilities in one value.
16:47:55 <saml__> chrisdotcode, Maybe a
16:48:00 <saml__> > Just 1
16:48:01 <lambdabot>   Just 1
16:48:31 <chrisdotcode> saml__: yeah, but for example, I have types a and b. I want to be like Either a b, but Left generally contains errors
16:48:49 <mel-> chrisdotcode: isn't that only 'semantics'?
16:48:59 <mel-> i.e., when you do not use Left for 'errors', where's the problem?
16:49:32 <saml__> data Or a b = Get a | Or b
16:50:01 <xenocons> hello, i wrote a parser for a specification (albeit adhoc), what 'methodology' do i use to validate that my parser code will work for the rest of time (given the specification never changes) i think i am looking for some form of verification but unsure where to look for guidance
16:52:35 <roboguy_> is there a reason IO can't be an instance of Semigroup, with (<>) = (>>)?
16:53:06 <saml__> i guess
16:53:46 <saml__> xenocons, write automated tests?
16:54:06 <saml__> wait you have a single input, a spec.
16:54:17 <Ghoul_> chrisdotcode: Either isn't really only used for errors. That's just convenience. Either does exactly what you want and is named appropriately :)
16:54:24 <saml__> why not generate AST once and use that generated as bootstrap/
16:55:54 <Ghoul_> You'll find lazy functions actually tend to use exceptions rather than Either, and I much prefer that way. It allows faster prototyping when you know things wont fail.
16:56:01 <elliott> chrisdotcode: yes, just use Either.
16:56:04 <elliott> or define your own type
16:56:42 <xenocons> saml__: ive got an AST, and the parsing definetly works, what i am unsure about is the test cases, is this the most 'formal' way to validate correct parsing?
16:57:27 <xenocons> (i have a requirement for correctness of the parser, ive never had to really think about this before)
16:57:28 <saml__> input changes?
16:57:45 <saml__> i don't know
16:57:57 <xenocons> input does change, within the boundaries of the specification (that is an assumption but aparently that isnt my problem)
16:58:02 <Ghoul_> I always feel like theres a syntax gap for anonymous guard functions
16:58:05 <saml__> i just feed f bad inputs and good inputs and check output
16:58:16 <xenocons> saml__: thats normally what i do
16:58:31 <saml__> smart is in choosing those inputs
16:58:38 <xenocons> do you have a way to determine you have parsed in inputs that cover all possible aspects of the functions?
16:58:40 <Ghoul_> Say I have a function that returns a few different things and I want to dispatch them in different directions using pattern matching
16:58:48 <Ghoul_> whats the best way to go about that?
16:59:15 <hpaste> geekosaur annotated “xmonad.hs” with “xmonad.hs (annotation)” at http://lpaste.net/91430#a91432
16:59:18 <Ghoul_> I guess `case ... of`, but that feels really strange for do notation.
16:59:22 <geekosaur> er oops
16:59:41 <chrisdotcode> Ghoul_, elliott: thanks :)
17:10:10 <danharaj1> \o/ hello dolio
17:11:16 <twomashi2> anyone who does alot of work at the command line: https://github.com/ssadler/hsl
17:13:25 <merijn> Ghoul_: how come? I use case/of quite frequently in do notation
17:16:21 <Ghoul_> my "that feels really strange" doesn't have any justification past personal taste
17:16:37 <Ghoul_> heh, sorry.
17:17:30 <lingxiao> hi all, does anyone know of any parsers that does lexing And parsing at the same time?
17:17:57 <lingxiao> or an article, tutorial, or anything resembling a sensible implementation?
17:18:22 <listofoptions> lingxiao: lr or ll?
17:19:55 <lingxiao> lr is better but I'll read anything on ll
17:20:01 <lingxiao> as well*
17:21:51 <Saizan> parsec LangageDef based parsers work like that
17:24:11 <edwardk> danharaj: Rift = CoT
17:24:23 <listofoptions> I have a tutorial on imperitave style parsers, but for parsec/attoparsec iirc it's pretty much self explanatory
17:25:19 <listofoptions> s/a tutorial/many tutorials
17:25:29 <danharaj> edwardk: and Lift is unfortunately named :P
17:25:33 <edwardk> heh
17:25:37 <edwardk> Lift is also interesting
17:25:45 <edwardk> but it doesn't seem to have the raw power than Rift does
17:26:02 <edwardk> on the plus side i get to add both to kan-extensions
17:26:20 <edwardk> i also worked out a Profunctor Rift with dolio
17:26:24 <danharaj> ooh
17:26:31 <benzrf> hello
17:26:36 <edwardk> so we should get 3 new constructions out of today's work ;)
17:26:49 <benzrf> how the heck do haskell exceptions work?!
17:26:51 <danharaj> edwardk: I am excited to be the spark that set fire to that barrel of gasoline :P
17:27:01 <arkeet> benzrf: which exceptions?
17:27:06 <edwardk> well, one of them was an old construction that now i can identify more formally where it comes from
17:27:27 <benzrf> arkeet: one sec let me think of something quickly
17:27:27 <danharaj> edwardk: ah, the extraction of an adjunction from a comonad and then flipping it around to give a monad transformer?
17:27:33 <edwardk> yeah
17:27:34 <benzrf> arkeet: how about when you try to fold an empty list?
17:28:20 <danharaj> edwardk: This weekend I am going to be spending quite a bit of time on Kans and Kifts to get a good feel for them. They are serious abstractional firepower.
17:28:31 <lingxiao> listofoptions: is there a link to the imperitive parser you're talking about?
17:28:54 <lingxiao> Saizan: thanks for the pointer, I'll look into it
17:29:01 <edwardk> i'll probably write up an article now that we've shaken loose what the hell they mean
17:29:24 <listofoptions> benzrf: data Woops = Woops String deriving (Typeable) ... instance Exception Woops...somewhere in your code do: throw $ Woops "I woopsied..."
17:29:28 <edwardk> since there is basically nothing on kan lifts on the internet other than my articles on Co/CoT, and 2 short blurbs on nlab,
17:29:44 <listofoptions> lingxiao: gimme a sec, buried in bookmarks
17:29:49 <danharaj> edwardk: cool. I would love to see the exposition in the 2-category of profunctors in particular.
17:30:13 <benzrf> listofoptions: what does that do?
17:30:13 <arkeet> benzrf: well, you shouldn't use foldx1
17:30:24 <danharaj> edwardk: Are there any subtleties about global and absolute kan extensions in *?
17:30:45 <arkeet> benzrf: generally, you should try to avoid partial functions like that, or head
17:31:04 <arkeet> you can only catch such things in IO
17:31:14 <edwardk> there is some pain with Rift/Lift in Hask that center on that actually
17:31:25 <listofoptions> benzrf: it's async throwing for haskell and arkeet is correct
17:31:31 <zRecursive> :t (***)
17:31:32 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
17:31:43 <benzrf> I am confused
17:31:45 <benzrf> ;_;
17:31:52 <benzrf> does it actually mess with flow control?
17:32:03 <benzrf> *flow
17:32:13 <edwardk> we also were able to derive the definitions of Ran and Lan from the same approach as we got Rift and Lift and showed them equivalent to the end/coend definitions.
17:32:21 <listofoptions> benzrf: only on the catching function
17:32:24 <arkeet> it will in the sense that it will make your program crash.
17:32:28 <arkeet> unless you catch it. (in IO.)
17:32:35 <benzrf> listofoptions: what, exactly, does it do?
17:32:41 <benzrf> is throw magic
17:32:44 <benzrf> @src throw
17:32:44 <lambdabot> throw exception = raise# exception
17:32:47 <benzrf> ._.
17:32:51 <arkeet> it's not that kind of throw.
17:33:01 <benzrf> what is raise#?
17:33:09 <arkeet> it's magic. also, ignore that.
17:33:16 <benzrf> T_T
17:33:18 <listofoptions> lmao
17:33:19 <edwardk> thats when dolio had the intuiton to do a similar trick to the Rift definition and I wound up looking directly at CoT
17:33:45 <Ghoul_> things followed by # are usually primops I think
17:33:45 <danharaj> edwardk: that must have been a nice moment
17:33:51 <benzrf> primops?
17:33:54 <arkeet> yeah, raise# would be a primop
17:33:58 <Ghoul_> so raise# indicates its a function defined at the lowest level by the compiler
17:34:04 <benzrf> q_q
17:34:05 <Ghoul_> or something like that.
17:34:19 <listofoptions> benzrf: http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Control-Exception.html
17:34:20 <arkeet> but ignore that.l
17:34:35 <benzrf> why is this necessary?
17:34:37 <arkeet> Control.Exception is the thing to look at, I suppose.
17:34:39 <Ghoul_> You shouldn't look for the definition of raise# because it tends to be "raise = undefined" as with all the other primops because they are replaced by the compiler
17:34:44 <edwardk> danharaj: it came after a few hours of reading things off the definition wrong, so when everything worked, i was pretty darn happy
17:34:49 <benzrf> what do exceptions _do_?
17:34:55 <benzrf> do they actually mess with program flow?
17:34:59 <benzrf> are they Real Exceptions?
17:35:02 <arkeet> there are a couple different kinds of exceptions.
17:35:09 <Ghoul_> benzrf: look at `bracket` and you'll see uses for these kinds.
17:35:18 <edwardk> benzrf: an exception does mess with control flow, they are real exceptions, but the 'stack' you are working on isn't really the stack you might expect
17:35:29 <arkeet> because of laziness
17:35:30 <benzrf> edwardk: i DIDN'T EXPECT ANY STACK
17:35:31 <benzrf> oops
17:35:52 <edwardk> benzrf: if you work entirely in IO, and throw using throwIO then pretty much all your intuitions hold
17:35:53 <benzrf> I'm familiar enough with haskell to know that there's no real flow
17:35:58 <arkeet> there is a flow.
17:36:02 <arkeet> :p
17:36:03 <benzrf> @src throwIO
17:36:03 <lambdabot> Source not found. Are you on drugs?
17:36:06 <benzrf> arkeet: not predictable
17:36:07 <benzrf> sorry
17:36:10 <arkeet> it is predictable.
17:36:14 <benzrf> ok, well
17:36:14 <edwardk> if you just use 'throw' then the exception is thrown when that thunk is forced
17:36:16 <benzrf> it's not what you say
17:36:16 <benzrf> >:P
17:36:21 <Ghoul_> The "are you on drugs" thing is lame.
17:36:30 <edwardk> that could happen much later, outside of say, any "encosing" finally block!
17:36:34 <edwardk> so be careful
17:36:45 <arkeet> @index throw
17:36:45 <lambdabot> Control.Exception
17:36:49 <geekosaur> Ghoul_, it's just using openbsd's "insults" errors
17:37:07 <geekosaur> (most notably used by its /bin/login which is why some of them refer to passwords)
17:37:11 <arkeet> benzrf: there are bottoms, and then there are IO exceptions.
17:37:21 <arkeet> bottoms are things that explode and crash your program when you try to evaluate them.
17:37:23 <benzrf> ._.
17:37:31 <listofoptions> lingxiao: http://www.cs.engr.uky.edu/~lewis/essays/compilers/rec-des.html
17:37:32 <edwardk> exceptions themselves can really only be handled once you are down in IO, so typically it happens way out in some kind of outer loop
17:37:41 <arkeet> or, well, evaluating them throws some IO exception.
17:37:51 <lingxiao> liftofoptions: thanks!
17:38:08 <benzrf> this all feels
17:38:08 <benzrf> ...
17:38:10 <arkeet> that is, if you evaluate them using something like evaluate
17:38:13 <benzrf> non-orthogonal
17:38:51 <listofoptions> lingxiao: I hope that helps, it's kinda only useful if you have something like c++/c/pascal style references
17:39:14 <arkeet> benzrf: in the view of denotational semantics, bottoms like  head []  and  fix id  are all the same
17:39:27 <benzrf> I don't know what denotational semantics is
17:39:30 <benzrf> -.-;
17:39:31 <arkeet> you don't get any meaningful result
17:39:36 <arkeet> whether it's a crash or an infinite loop
17:39:38 <benzrf> @src head
17:39:38 <lambdabot> head (x:_) = x
17:39:38 <lambdabot> head []    = undefined
17:39:41 <lingxiao> listofoptions: I'm actually not super familiar with parsing/scanning stuff in general so every little bit pushes it along
17:39:44 <lingxiao> :)
17:39:51 <arkeet> so you can't catch such things in pure code
17:40:36 <arkeet> benzrf: that's fine, I'm just tossing out key phrases.
17:41:18 <arkeet> anyway, if you try to evaluate some error thing like head []
17:41:33 <arkeet> I feel like I'm repeating myself.
17:42:06 <listofoptions> lingxiao: http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec.html should help
17:43:05 <arkeet> > head []
17:43:06 <lambdabot>   *Exception: Prelude.head: empty list
17:43:12 <lingxiao> listofoptions: nice! hey man may I ask if you are pretty familiar with this stuff and if I could ask you a very specific question that is really stumping me?
17:43:57 <lingxiao> it's totally fine if you can't answer off the top of your head, but if you could it'd be like Gold to me
17:44:33 <geekosaur> the difference betwen exceptions and bottoms is that exceptions can be caught; bottoms sometimes may be exceptions, but other times (infinite loop, hardware failure, power outage, Linux OOM killer, ...) don't have anything you meaninhgful you can catch and may not be recoverable even if they did
17:44:46 <geekosaur> but exceptions can only be caught in IO
17:45:29 <luite> geekosaur: you can catch some infinite loops though
17:46:02 <arkeet> geekosaur: I disagree that hardware failures and power outages are bottoms. :p
17:46:03 <Eduard_Munteanu> You just need to let them run at least an infinite time. :P
17:46:14 <geekosaur> I was speaking operationally; an infinite loop that is caught by ghc and converted to an exception isn't really an infinite loop, is it? :)
17:46:16 <arkeet> (they're side effects!)
17:46:36 <arkeet> he left.
17:46:43 <zRecursive> :
17:46:48 <geekosaur> your computation doesn't finish, it "produces" bottom :p
17:47:05 <ezrios> are question marks allowed in haskell function names?
17:47:08 <listofoptions> i'm not incredibly familiar with Haskell, C++ is kinda my baby :P
17:47:55 <listofoptions> though boost is still black magic/necromancy to me still
17:47:59 <zRecursive> The baby will grown :)
17:48:22 <listofoptions> zRecursive: C++11
17:48:38 <zRecursive> I heard of C++ is huge
17:48:39 <nerrz> I am having trouble with the interactive command, what does this error mean?  *** Exception: /bin/sh: runInteractiveCommand: resource exhausted (Too many open files)
17:49:07 <zRecursive> ulimit ?
17:51:05 <k00mi> ezrios: no, but as an operator
17:52:50 <Ghoul_> Question marks would be cool
17:53:29 <Ghoul_> :t (?)
17:53:29 <lambdabot> Not in scope: `?'
17:53:44 <geekosaur> nerrz: what were you doing to get that?
17:53:47 <listofoptions> :k (->)
17:53:48 <lambdabot> * -> * -> *
17:54:01 <geekosaur> ? is an operator character, not an identifier character
17:54:02 <listofoptions> that always amuses me
17:54:28 <geekosaur> ?? -> ? -> *
17:54:28 <lambdabot> Plugin `compose' failed with: Unknown command: ""
17:54:37 <geekosaur> bah humbug
17:55:18 <nerrz> geekosaur: I am mapping a funcion that will call scp if the file was updated, and I need interactive since scp requires the password as stdin
17:56:13 * hackagebot orders 0.1.0.0 - basic orders  http://hackage.haskell.org/package/orders-0.1.0.0 (DavidDarais)
17:56:49 <ezrios> k00mi: thanks
17:57:22 <edwardk> danharaj: https://github.com/ekmett/profunctor-extras/commit/98ba64f7749f821a8772323c19a4a555820ed736 is the profunctor one. i'll add some morphisms in a sec
17:58:03 <danharaj> edwardk: cool. I'm currently converting some client scripts into Haskell for work but hopefully I'll have time to marvel at the glory tonight.
17:58:34 <geekosaur> nerrz: apparently you are doing it in a way that leaks file descriptors
17:58:52 <geekosaur> the OS only lets you have so many, and then things start failing
17:59:07 <nerrz> geekosaur: what do you mean by that?
17:59:26 <geekosaur> ... oh dear
17:59:28 <tabemann> you have to make sure your files are closed when you are done with them
17:59:52 <nerrz> ok, I added a waitForProccess on the function and I got rid of the error
17:59:58 <tabemann> and the GC *won't* make sure they're closed, as there is no guarantee the GC will actually GC them at any point before the program's exist
17:59:58 <nerrz> thanks
18:00:00 <tabemann> *exit
18:00:47 <zacts> why is the haskell wiki and hackage often down?
18:00:51 <tabemann> opening tons of processes that open files themselves without waiting for them to complete is another way to do it...
18:01:04 <tabemann> they did do a migration recently...
18:01:14 * hackagebot mpretty 0.1.0.0 - a monadic, extensible pretty printing library  http://hackage.haskell.org/package/mpretty-0.1.0.0 (DavidDarais)
18:01:16 * hackagebot stm-conduit 2.1.1 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.1.1 (ClarkGaebel)
18:01:36 <geekosaur> we're getting free hosting from a university
18:01:38 <zRecursive> danharaj: can haskell do client script well ?
18:01:52 <zacts> ok
18:01:58 <danharaj> zRecursive: Haskell does everything well.
18:02:23 <zRecursive> danharaj: but the start up time for script ?
18:02:35 <danharaj> zRecursive: The script runs for an hour sooooo
18:02:54 <roboguy_> is there a zip that's generalized to Functors or something like that?
18:02:56 <Ghoul_> will there be much overhead if I have a data with (a -> b) versus using a typeclass
18:03:05 <zRecursive> danharaj: would you mind showing me a haskell client script ?
18:03:18 <danharaj> zRecursive: I don't have one of my own to show.
18:03:27 <Ghoul_> is it recommended for something that is hit very frequently like a parser?
18:03:55 <zRecursive> danharaj: it is ok just showing a pseudo-code snippets ?
18:04:20 <zRecursive> @paste
18:04:20 <lambdabot> Haskell pastebin: http://hpaste.org/
18:04:45 <monochrom> hugs has fast startup time
18:04:51 <danharaj> zRecursive: The script pulls http requests from our server and parses them.
18:05:01 * zRecursive in fact i have many CL scripts which i want to change
18:06:25 <zRecursive> monochrom: hugs seems not updated for a lone time
18:06:39 <danharaj> hugs is still Haskell98
18:06:47 <danharaj> which is fine and solid and mostly complete
18:08:01 <balthamos89> does anyone know of a good way to match a string against a list of regexes lazily?
18:08:16 <arkeet> what do you mean by lazily?
18:08:32 <monochrom> hugs works
18:08:53 <balthamos89> arkeet: as in the string im trying to match may not terminate
18:09:19 <zRecursive> danharaj: can hugs compile xmonad ?
18:09:25 <danharaj> idk
18:09:30 <arkeet> balthamos89: then how would it ever match?
18:09:32 <danharaj> probably?
18:09:41 <danharaj> wait isn't hugs an interpreter
18:09:45 <monochrom> yes
18:10:05 <balthamos89> arkeet: such as "foobar........" =~ "foobar"
18:10:09 <zRecursive> monochrom: anyone uses hugs now ?
18:10:20 <startling> there's not really a reason to.
18:10:27 <arkeet> balthamos89: ok, then how would it ever fail to match?
18:10:27 <monochrom> why is it important?
18:10:54 <monochrom> "scripting language, fast startup time" ==> sounds like hugs to me
18:11:01 * arkeet wonders what balthamos89 is really doing
18:11:08 <balthamos89> arkeet: it wouldn't in this case, but the string im actually using is from IO
18:11:09 <geekosaur> I don't think anyone has ever tried. I don't know if it supports the necessary extensions (especially now that darcs xmonad is starting to use some gncisms that postdate hugs)
18:11:25 <arkeet> balthamos89: I mean, if you have an infinite string, how can you ever know it doesn't contain "foobar"?
18:11:33 <geekosaur> *ghcisms
18:12:09 <clahey> Is there a library function that does func (a:b:rest) = (a,b):func rest  ?
18:12:19 <clahey> Or is that easy to build some how?
18:12:24 <balthamos89> arkeet: thats why i want to match against a list of possible regexes, and take one that is there (if it exists)
18:12:24 <zRecursive> geekosaur: i guess hugs cannot build xmonad
18:12:31 <arkeet> clahey: you just wrote it, I think.
18:12:37 <balthamos89> arkeet: im trying to make a haskell implementation of Expect
18:12:55 <clahey> arkeet, I did.  I just prefer building functions over writing them.
18:13:08 * geekosaur wonders if async has stuff that would be helpful for that
18:13:12 <monochrom> you seem to keep changing your requirements or contriving unsatisfiable requirements
18:13:32 <monochrom> first you asked for "scripting, fast startup time", ok that sounds like hugs
18:13:40 <arkeet> clahey: and if the list's length is odd?
18:13:56 <clahey> arkeet, Meh.  I'm fine with it crashing in my implementation.
18:14:33 <arkeet> > uncurry zip . partitionEithers . zipWith id (cycle [Left,Right]) $ [1,2,3,4,5,6]
18:14:34 <lambdabot>   [(1,2),(3,4),(5,6)]
18:14:40 <zRecursive> monochrom: nothing just curious ! In fact i want to know if i can use haskell to do script things instead of CL
18:14:42 <monochrom> then it seems, unsatisfied with the existence of a solution, you added "but xmonad". ok, but I haven't heard anyone complained about "xmonad reconfiguration time too long because of ghc", so why add that requirement?
18:15:13 <arkeet> this will just drop the last element if it's odd
18:15:20 <clahey> arkeet, Beautiful.
18:15:41 <clahey> arkeet, Since I'm writing it for someone else, I will use the implemented version, but I love it.
18:15:45 <arkeet> clahey: you may also be interested in Data.List.Split.chunksOf
18:15:51 <arkeet> which returns a list of lists, not tuples
18:16:03 <arkeet> > chunksOf 2 [1..13]
18:16:04 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13]]
18:16:05 <clahey> That is closer to what I want.
18:16:09 <zRecursive> monochrom: if hugs can build xmonad, then it will convince me hugs is NOT a toy
18:16:26 <alpha123> (Unless xmonad uses GHC extensions)
18:16:38 <arkeet> since when was hugs a toy?
18:16:39 <geekosaur> so why is it you want to use something that hasn't been updated in something like 6 years?
18:16:51 <geekosaur> nobody claimed it was a toy. they claimed it was *unmaintained*
18:16:57 <monochrom> ok, then suit yourself, I have no further comment, I am not paid to convince you.
18:17:03 <arkeet> unmaintained it definitely is.
18:17:40 <darinm> when someone installs things with cabal --global, where does it install the packages and package database? I know when they do it with --user it puts things in ~/.cabal and ~/.ghc
18:18:08 <geekosaur> darinm: depends on how ghc was installed. "ghc-pkg list" shows you the paths to both the global and user package registries
18:18:15 <zRecursive> CLISP is unmaintained for many years so that we want to abandon it
18:18:24 <monochrom> darinm: read my http://www.vex.net/~trebla/haskell/sicp.xhtml
18:18:26 <darinm> geekosaur: yeah, unfortunately I don't have it available atm
18:18:45 <darinm> if they do a usual install of ghc to something like /usr/local, where does it go with --global?
18:19:44 <balthamos89> arkeet: i guess i'll just thread off multiple searches under timeout
18:19:55 <geekosaur> something like /usr/local/lib/ghc-VERSION/package.conf.d (and packages could be under /usr/local/lib or /usr/local/lib/ghc-VERSION)
18:19:58 <zRecursive> darinm: `ghc-pkg list` ?
18:20:15 <darinm> zRecursive: yeah, don't have it installed atm :]
18:20:29 <darinm> geekosaur: thanks
18:26:25 <balthamos89> is it possible to return nested groups in regexes?
18:29:18 <monochrom> I think no
18:30:01 <balthamos89> it looks like it just flattens the grouping
18:32:05 <balthamos89> > "testing foobar 123" =~ "((foo)(bar)) 123" :: [[String]]
18:32:06 <lambdabot>   Not in scope: `=~'
18:32:06 <lambdabot>  Perhaps you meant one of these:
18:32:06 <lambdabot>    `==' (imported from ...
18:32:22 <balthamos89> bleh
18:32:23 <balthamos89> [["foobar 123","foobar","foo","bar"]]
18:33:08 <geekosaur> every other regex implementation I'm aware of flattens as well
18:34:20 <BMeph> MOAR BRACKETZ!!
18:34:29 <balthamos89> so is there a reliable way to figure out which expression matched if it was something like "(pattern1)|(pattern2)|(pattern3)"
18:34:42 <balthamos89> you could use grouping, so long as none of the inner patterns use them
18:37:37 <elliott> I think Ruby or something had a way to get nested groups.
18:39:40 <geekosaur> I am not sure what the problem is here
18:40:23 <balthamos89> i want to match a string against a list of regexes
18:40:25 <geekosaur> in "(pattern1)|(pattern2)|(pattern3)" you have 3 captures; the one that matches will have a nonempty value
18:40:45 <geekosaur> the others, having not been triggered, will be reflected in the capture output as empty strings
18:41:04 <balthamos89> right, but if i have "(pat(something here)tern1)|(pattern2)|(pattern3)" i cant use that
18:41:32 <edwardk> balthamos89: you can always build a binary tree of nested parens on the way down and then binary search for which one matched, but for any real scale that isn't worth it, plus thats a lot of work to put on the regex engine ;)
18:41:41 <geekosaur> I believe you can but you have to count parens. (Surprise! unless you use pcre and named captures, *all* of them do that to you)
18:42:05 <edwardk> alternately you could just use a parsing combinator
18:42:18 <edwardk> or rather a bunch of them
18:42:25 <geekosaur> if you use one of the extended pcre libraries, you can name your captures and use the names to determine which one matched
18:42:37 <geekosaur> or, as is usually done in haskell, give up on regex and use a parser
18:42:56 <geekosaur> regex got to be popular because perl made regex easy back when both regex and parsers were hard
18:43:13 <geekosaur> haskell makes parsers easy. parsers turn out to be a lot nicer than regexes in many cases
18:44:41 <balthamos89> i think a parser would be overkill for doing rather simple regexes
18:45:16 <geekosaur> but you're not doing simple things with regexes
18:45:30 <Zenol> parsec is really easy (if you stick to the basis) even for simple things.
18:45:43 <geekosaur> you're trying to do something that regex *does not do well* unless you use some very recent nonstandard extensions (named captures)
18:45:44 <Zenol> but got to sleep. 'night everybody.
18:45:58 <balthamos89> true
18:46:44 <geekosaur> this is not a haskell issue. you have the same problem in perl or python or ruby, again unless you switch to named captures (Haskell defaults to POSIX regexes which don't have the named captures extension, but there are regex libraries that let you use anything in pcre)
18:47:37 <balthamos89> all im really trying to do is "source text" =~ ["pattern1", "pattern2", "pattern3"]
18:48:19 <geekosaur> in the absence of named captures, you have to count parentheses to know where all the captures are. it's a flaw of regexes
18:48:35 <geekosaur> and it's something parsers do well, where regexes fail at it
18:49:41 <geekosaur> if you;re absolutely insistent on doing it with regexes instead of doing it correctly, install one of the pcre libraries on hackage and use pcre's named captures
18:50:30 <balthamos89> im trying to write a haskell implementation of Expect, if you're familiar with the library
18:50:48 <enthropy> balthamos89: couldn't you filter that list of captures using the individual patterns of interest?
18:51:00 <geekosaur> quite familiar with both the original and the perl (and somewhat less familiarly, python) reimplementations
18:51:14 * hackagebot profunctor-extras 3.3.3 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-3.3.3 (EdwardKmett)
18:51:26 <geekosaur> about the only good thing to be said about expect is that it gets the job done. it's uuuuuuuglt
18:51:56 <balthamos89> enthropy: i could, but that requires another run through the regex engine
18:53:48 <balthamos89> geekosaur: yea expect is a bit rough, but for testing/automation its the only thing i can think of
18:54:04 <dainanaki> Is there a way to get cabal to shut up about package reinstalls? I've got a cabal-dev sandbox that I am installing a bunch of packages into that are modified frequently (by me), so I'd like to not see cabal warn me about that every single time.
18:56:15 * hackagebot MonadRandom 0.1.11 - Random-number generation monad.  http://hackage.haskell.org/package/MonadRandom-0.1.11 (BrentYorgey)
19:01:15 * hackagebot profunctor-extras 3.3.3.1 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-3.3.3.1 (EdwardKmett)
19:12:35 <nerrz> when interacting with the stdin of a program, how do I send an enter key?
19:12:56 <geekosaur> '\r'
19:13:54 <nerrz> geekosaur: thanks
19:34:42 <Gracenotes> "Languages talk about being multi-paradigm as if it's a good thing, but multi-paradigm means you can do the bad thing if you feel you really need to, and programmers are extremely bad at doing the time-scale integration of the cost of doing something that they know is negative." --from Carmack's talk
19:35:31 <ezrios> which talk?
19:35:46 <h4199> He has probably seen the truth of that played out in front of him more times than I care to imagine
19:36:02 <h4199> and the keynote from this year's quakecon
19:36:06 <Gracenotes> it's linked from /r/haskell (comments to timestamp)
19:36:11 <ezrios> ah shit, I missed it ._.
19:36:15 <ezrios> why did I turn my stream off
19:36:23 <h4199> you can rewind
19:38:09 <Gracenotes> I like the integration phrasing
19:47:38 <adnap> Hey
19:48:32 <adnap> I'm sorry that I had to go earlier. I was talking about auto-deriving (Applicative f, Monoid a) => Monoid (f a).
19:49:54 <adnap> Can someone re-explain in detail how to do this? Also, can one write generic instances of type classes like the Monoid one above that work for any Applicative and Monoid?
19:50:29 <Saizan> you can, but you shouldn't
19:51:05 <Saizan> because instance resolution is committed-choice, it dispatches instances by looking at the head only
19:51:21 <adnap> Saizan: Please explain why. I guess it has something to do with overlapping instances?
19:51:34 <Saizan> so that's going to overlap with any Monoid (Foo a) instance, even when Foo is not Applicative
19:51:38 <adnap> Saizan: I don't understand "it dispatches..."
19:51:53 <adnap> Saizan: I don't see why
19:51:57 <Saizan> adnap: s/dispatches/picks/
19:52:17 <adnap> If there is an Applicative constraint, how could that be circumvented for Foo?
19:53:14 <Saizan> if we only have your proposed instance, then what's going to happen is that it'll error out complaining about no Applicative instance for Foo
19:53:45 <enthropy> if your `instance (Applicative f, Monoid a) => Monoid (f a)' is in a module compiled with -XOverlappingInstances, you'll get the methods for `instance Monoid (Foo a)' used instead
19:53:47 <Saizan> and the only way to write the specific Foo instance would be OverlappingInstances, which are bad
19:55:16 <adnap> I don't even know about OverlappingInstances
19:55:31 <adnap> Why can't you just import some module with only one generic class instance?
19:56:17 <Saizan> enthropy: you can just declare the Monoid (Foo a) in a module with OverlappingInstances instead btw
19:56:51 <Saizan> adnap: you can define it, but it's going to overlap with instances for a lot of stuff, hence it's not a good idea
19:57:02 <adnap> I don't understand. Where are the instances?
19:57:06 <Gracenotes> what would the autogenerated instance for [] be?
19:57:14 <adnap> I don't know how to even auto-derive stuff in the first place
19:57:51 <Saizan> oh, sorry, i'm not talking about deriving
19:57:53 <enthropy> > map Sum [1,2] <> map Sum [3,4,5]
19:57:55 <lambdabot>   [Sum {getSum = 1},Sum {getSum = 2},Sum {getSum = 3},Sum {getSum = 4},Sum {g...
19:57:58 <Saizan> i'm talking about the generic instance
19:58:17 <Gracenotes> how is the Monoid a instance important for Monoid [a], in this formulation
19:58:20 * Gracenotes doesn't have context
19:58:24 <adnap> I didn't even know if generic instances were possible. That was one of my questions
19:58:29 <enthropy> adnap: if your proposed instance were chosen that list would have 6 elements instead of 5
19:58:45 <Gracenotes> or the Applicative instance for []
19:58:49 <Saizan> adnap: yep, my answer was "they are in theory possible, but they are a bad idea"
19:59:07 <adnap> I want details that help me understand
19:59:17 <adnap> enthropy: I don't understand <>
19:59:25 <enthropy> <> is `mappend`
19:59:46 <tabemann> note that mappend is a bad name, so what <> is being used for may look nothing like appending
20:00:07 <enthropy> you're just not squinting hard enough
20:00:08 <adnap> I know what mappend does
20:00:27 <Saizan> adnap: btw, ghc's manual has a nice description of what OverlappingInstances does
20:04:12 <adnap> Is there a way to just say something like "deriving instance Monoid (A B)" for specific applicative A and Monoid B?
20:04:27 <enthropy> Saizan: do you know if it is intentional that you can make Language.Haskell.TH.Syntax.Name for things that aren't exported from a module?
20:05:15 <elliott> adnap: no, but mempty = pure mempty; mappend = liftA2 mappend is pretty short
20:05:40 <adnap> elliott: I know
20:05:47 <adnap> I was just curious
20:06:08 <adnap> But there is a way to write generic instances?
20:06:31 <adnap> And also some way to import them where they are already written?
20:06:48 <adnap> (Even though it is bad as Saizan says)
20:07:03 * tabemann curses Scheme for being dynamically typed... writing primitives in Haskell for it for functions with parameters of count 3+ is getting increasingly prohibitive...
20:07:22 <enthropy> adnap: you've seen that ghc complains that your    instance (Applicative f, Monoid m) => Monoid (f m)  overlaps existing instances?
20:07:30 <adnap> enthropy: No
20:07:40 <adnap> enthropy: I didn't even know you could write that literally
20:07:55 <adnap> ...without specifying f and m
20:08:13 <enthropy> well just write the instance, and you'll see that ghc won't accept expressions like  "abc" <> "def"
20:09:05 <adnap> So... Char is a Monoid?
20:09:49 <enthropy> it's not, but the rules for selecting which instance to use (called dispatch earlier) don't care that Char is not an instance of Monoid
20:10:30 <adnap> enthropy: Why not?
20:10:54 <adnap> The generic instance has a Monoid constraint, so it wouldn't work
20:11:56 <Gracenotes> instance Monoid [a] -- Defined in `Data.Monoid'
20:12:21 <adnap> Okay, so that would work for [Char]...
20:12:52 <Saizan> Monoid [Char] and instance (Applicative f, Monoid m) => Monoid (f m) conflict on [Char]
20:12:58 <Saizan> because the context is ignored
20:12:59 <adnap> And you all are saying "instance (Applicative f, Monoid m) => Monoid (f m)" would overlap that?
20:13:08 <adnap> Saizan: It shouldn't be ignored!
20:13:16 <adnap> Why is it ignored?
20:13:19 <Saizan> and it's ignored because otherwise instance resolution would be too fragile
20:13:35 <Saizan> it'd depend on the existence of other instances, breaking confluence
20:13:38 <geekosaur> lots of newcomers think it shouldn't be. lots of newcomers don't understand type resolution, especially when contexts are in play
20:14:13 <adnap> How could the code even compile if the Data.Monoid instance wasn't visible and the "instance (Applicative f, Monoid m)..." instance was selected?
20:14:42 <Saizan> adnap: consider this, in a module i use "abc" <> "def" and the Monoid [a] instance is picked, in another i define Monoid Char and then the other instance gets picked, that breaks the guarantee that there's only one instance for a given type
20:15:43 <isomorphic> > 1 + 1
20:15:44 <lambdabot>   2
20:15:52 <adnap> Saizan: Yeah, I understand.
20:16:15 <adnap> Saizan: Given two instances which would both work, it makes sense that there would be a conflict
20:16:17 <arkeet> when checking for overlapping instances, stuff on the left of => is ignored
20:16:26 <arkeet> I guess you already said that
20:16:30 <enthropy> geekosaur: there should be a way to accomplish this http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap without so much boilerplate
20:16:41 <adnap> arkeet: Yeah. Now I'm trying to understand why that isn't stupid
20:16:41 <Saizan> (well, i guess in this case it'd still pick the Monoid [a] one because it's more specific, but you can build similar cases for that problem)
20:16:51 <enthropy> the boilerplate in that case being you replicating all Show instances
20:17:11 <arkeet> adnap: it's because you could potentially always make the left side of => be satisfied
20:17:16 <arkeet> and then your things would really overlap
20:17:38 <geekosaur> adnap: it's been demonstrated ithat if you allow that kind of overlap, you can do things like breaking Data.Map which relies on there being a single Ord instance for a given type in a given program.
20:17:57 <geekosaur> if different modules can pick different Ord instances for the same type, Map breaks *very* badly
20:18:02 <adnap> Okay, so I get that there is a problem with overlapping, but what if there is not and--what if there is only one instance to choose from, but it wouldn't actually work due to things on the left of => not being satisfied?
20:19:08 <Saizan> adnap: the fact "this is instance is not there" can always be falsified in another module, you'd need whole-program analysis to do that reasoning consistently
20:19:11 <adnap> I agree that two overlapping instance should not be allowed to be uesd at the same time
20:21:58 <Gracenotes> what does at the same time mean?
20:22:31 <Gracenotes> say, both available for the same type in the same module?
20:22:39 <Gracenotes> yeah, that can get messy
20:22:40 <adnap> Yeah, I guess
20:22:46 <adnap> I'm surprised it's even allowed
20:23:14 <adnap> How would the type system know which was appropriate? It seems like one instance would have to take precedence
20:23:47 <Gracenotes> a lot of GHC extensions should probably have Unsafe in the name
20:25:34 <Gracenotes> or Arbitrary, or UnsoundSometimes
20:26:33 <pharaun> how rough is FlexibleContexts? i found i had to use it for records + functions
20:27:20 <adnap> Saizan: But surely you can't compile code that uses instances with types that don't satisfy the instance's constraints
20:29:22 <c_wraith> pharaun: FlexibleContexts and FlexibleInstances are perfectly well-understood and perfectly safe
20:29:56 <c_wraith> pharaun: they just do things technically forbidden by the spec because it wasn't obvious when it was first written (more than 20 years ago) if those things would be useful or easy.
20:30:24 <zRecursive> FlexibleContexts ?
20:30:51 <Saizan> adnap: that doesn't hurt nor save you here
20:31:27 <geekosaur> zRecursive: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules
20:31:34 <pharaun> c_wraith: ahh i see, thanks :)
20:31:50 <zRecursive> geekosaur: never touch it, thx
20:32:04 <Saizan> adnap: suppose we have your instance added, then "foo :: (Applicative f, Monoid a) => f a -> f a -> f a; foo = (<>)" should presumably be accepted
20:32:05 <adnap> Saizan: Huh?
20:32:47 <zRecursive> :t (<>)
20:32:48 <lambdabot> Monoid m => m -> m -> m
20:32:51 <Saizan> adnap: but then i can call it like "foo [()] [(),()]"
20:33:06 <Saizan> adnap: which is not going to be the same as (<>)
20:33:37 <Saizan> adnap: i.e. we can use the same instance at two different types without any clear place where to check we don't
20:34:29 <adnap> Saizan: What? foo = (<>), So how is "foo [()] [(), ()]" not the same as "(<>) [()] [(), ()]"?
20:34:47 <Saizan> sorry, different instances for the same type, not same instance at two different types
20:35:28 <Saizan> adnap: because with foo you're going to use the generic Applicative instance, while with (<>) [()] [(), ()] we use the Monoid [a] one
20:36:18 <adnap> Saizan: Is your point that ignoring anything to the left of => is okay, since the constraints will be automatically required for any function which needs them?
20:37:01 <Saizan> adnap: no, what made you think that?
20:37:50 <adnap> Saizan: You deciding to define a function foo which behaves like (<>), but adds an Applicative and Monoid constraint
20:38:56 <Saizan> adnap: i declared foo like that so that it'd use the generic (Applicative f, Monoi a) => Monoid (f a) instance for the (<>) in its body
20:39:00 <Ghoul_> @pl (\x -> (fst x) <= 0)
20:39:03 <lambdabot> flip ((<=) . fst) 0
20:39:03 <lambdabot> optimization suspended, use @pl-resume to continue.
20:39:15 <adnap> Saizan: Why would it?
20:39:27 <adnap> I'm so confused
20:39:33 <Saizan> adnap: because that's the only one that applies..
20:39:40 <adnap> WTF
20:40:10 <adnap> I'm just going to try to write some examples
20:41:22 <enthropy> ghc is sanely rejects Saizan's example, but maybe it'd work if you had [incoherent] instance Monoid [a]
20:42:26 <Saizan> enthropy: which part?
20:42:28 <LordBrain> Is there a link for Saizan's code? I am just stumbling into the room here.
20:42:49 <Saizan> enthropy has the code, apparently :)
20:43:20 <Saizan> but i suspect putting a module boundary somewhere would fix the problem, if any
20:43:48 <adnap> It's just so crazy trying to have this conversation without referencing the same code
20:44:20 <hpaste> enthropy pasted “adnap” at http://lpaste.net/91440
20:44:24 <Ghoul_> > snd . (<=0) $ (3,-1)
20:44:25 <lambdabot>   Couldn't match type `GHC.Types.Bool' with `(a0, c0)'
20:44:25 <lambdabot>  Expected type: (t0, t...
20:44:37 <Ghoul_> > (<=0) . snd $ (3,-1)
20:44:38 <lambdabot>   True
20:44:50 <adnap> Okay, what the hell
20:45:00 <adnap> I already said I think OverlappingInstances is bad
20:46:00 <Saizan> enthropy: ah, cool, they made it more resilient
20:46:35 <enthropy> Saizan: that used to be accepted?
20:46:47 <Saizan> enthropy: i think so, but icbw
20:47:23 <crdueck> @unmtl MaybeT (State s) a
20:47:23 <lambdabot> (State s) (Maybe a)
20:47:27 <Saizan> maybe it only worked for existentials?
20:48:21 <LordBrain> This is off topic a bit, but when it comes to instances, I do not recall if any what the issue is/was with having explicit imports and hides from modules?
20:48:25 <enthropy> might be related to this code which worked with earlier (6.12?) ghcs but doesn't work anymore http://hackage.haskell.org/packages/archive/xmonad-extras/0.9.2/doc/html/XMonad-Config-Alt-Internal.html
20:48:46 <enthropy> LordBrain: I think that's rather on topic
20:49:00 <LordBrain> ok, nevertheless
20:49:31 <LordBrain> the question remains in my mind
20:49:34 <enthropy> the issue is probably the same as that 'foo' in the paste above
20:50:33 <hpaste> Saizan annotated “adnap” with “adnap (annotation)” at http://lpaste.net/91440#a91441
20:50:34 <LordBrain> the issue with explicit instance imports?
20:50:50 <enthropy> that if you allow multiple instances to match a given type it's kind of ambiguous at which point the instance gets decided
20:50:56 <Saizan> enthropy: that's accepted http://lpaste.net/raw/91441
20:52:21 <enthropy> and the point at which that instance gets decided can change the result you get
20:52:29 <LordBrain> i was hoping someone might point me to a mailing list discussion  or wiki page or something.
20:52:46 <enthropy> Saizan: so with some unsafeCoerce/cast you can get the original Foo out of that
20:53:26 <adnap> http://ideone.com/d4rO6t
20:53:30 <Saizan> enthropy: yeah, you can add a Typeable constraint inside Foo
20:53:41 <parcs_> could 'unsafeDupablePerformIO (unsafeInterleaveIO foo)' evaluate foo twice?
20:53:44 <adnap> So, obviously when it comes to runtime, "Applicative f" is not ignored
20:54:07 <Saizan> adnap: ah, sure
20:54:18 <Saizan> adnap: it's not even runtime
20:54:22 <Saizan> adnap: it's still typechecking
20:54:25 <adnap> Yeah, compile time
20:54:38 <adnap> Clearly I wasn't being listened to earlier
20:54:47 <Saizan> adnap: it only gets ignored when deciding which instance to use, but after that it checks that the constraints hold
20:54:53 <adnap> Or I was just making no sense at all
20:55:32 <Saizan> you weren't being clear on what point you were trying to make about it not getting ignored
20:55:50 <Saizan> and i did say it gets checked, above
20:57:03 <adnap> Okay, so the whole issue of ignoring things to the left of => is moot without OverlappingInstances, right?
20:57:19 <adnap> It has no effect
20:58:05 <enthropy> you're allowed to put things to the left of => to the right of => due to -XMultiParamTypeClasses though
20:59:05 <enthropy> so you aren't as limited with respect to classes as it seems
20:59:07 <Saizan> adnap: well, it still means more instances overlap than you'd expect otherwise, they are just not allowed at all without OverlappingInstances
20:59:20 <Saizan> enthropy: what do you mean?
20:59:38 <adnap> Saizan: Oh, yeah
21:00:10 <adnap> Saizan: Which reminds me that I still don't understand why there are errors in http://lpaste.net/91440
21:00:36 <adnap> Saizan: Well, I understand why, but I don't understand...
21:00:43 <adnap> ...why it is the way it is
21:00:53 <enthropy> Saizan: you know this trick: http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap right?
21:00:56 <adnap> Why things to the left of => are ignored when selecting instances
21:01:45 <carter> dysinger blah, i need someone else to take the lead on explaining to the brew folks
21:02:03 <carter> i don't have the right patience or way of explaining
21:02:12 <Saizan> enthropy: yeah
21:02:26 <dysinger> carter: lulz
21:04:06 <enthropy> Saizan: I'm trying to say that you can use that idea in some cases where you might otherwise want things to the left of => to count
21:04:42 <Saizan> enthropy: yep, i get it now
21:04:59 <carter> pleasseeee
21:05:35 <adnap> Did someone already explain why ignoring things before => is good?
21:05:45 <enthropy> yes
21:05:56 <adnap> Who was it. I will read it
21:06:03 <enthropy> 23:13:10*          Saizan | it'd depend on the existence of other instances, breaking confluence
21:06:27 <adnap> Okay, that doesn't make any sense
21:06:33 <adnap> ...to me
21:07:16 <c_wraith> ok, the doc pages on ConstraintKinds *really* should specify that you need to import GHC.Prim to get the Constraint kind in scope..
21:07:17 <adnap> "confluence: An act or process of merging."
21:08:14 <Saizan> adnap: http://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)
21:10:15 <adnap> lol: "This suggests that the arithmetic rewriting system a confluent one."
21:10:30 <kryft> I had to compile haskell platform from source on a linux machine where I don't have root privileges. Everything went fine, but during make install I had a lot of warnings like "Warning: haddock-html: ~/share/doc/foo/html doesn't exist or isn't a directory"
21:11:00 <kryft> Does this imply that some documentation that should have been generated during the compilation didn't get generated?
21:11:02 <geekosaur> sounds like you used ~ somewhere you shouldn't have
21:11:20 <kryft> it's not literally ~
21:11:22 <geekosaur> keep in mind that arbitrary programs do not understand ~, only shells and a very few other programs do
21:11:43 <geekosaur> oh
21:12:01 <adnap> Saizan: Okay, I understand the meaning of "confluence", but I still don't understand your statement. It's too vague
21:12:05 <levi> Ahh, I should have looked at wikipedia earlier when I wasn't sure what people meant by confluence relating to type classes.
21:12:26 <kryft> I didn't use ~ anywhere, but I didn't feel like typing /home/users/kryft for some reason (it's not *that* long)
21:13:03 <kryft> Erm I mean I didn't feel like typing the absolute path here in the channel just now :)
21:14:12 <Saizan> adnap: i don't have an example for your proposed system OTOH, you could try to prove it guarantees confluence and see if you succeed :)
21:14:57 <chexxor> I can't understand the error message I'm getting. Any hints? -- doubleEveryOther (xs) = [2*x y | (x:y:ys) <- reverse xs]
21:15:24 <carter> chexxor whats the error message?
21:15:25 <chexxor> Couldn't match expected type `Integer' with actual type `[t0 -> Integer]'
21:15:27 <carter> we need that too
21:15:35 <carter> 2*x y
21:15:39 <carter> try 2*x *y
21:15:40 <carter> or something
21:15:55 <levi> chexxor: You're applying 2*x to y, as if 2*x was a function.
21:15:56 <chexxor> ah, but it said "In the pattern: x : y : ys"
21:16:02 <carter> ignore that
21:16:05 <carter> try this first
21:16:36 <carter> whats the new error message?
21:16:50 <chexxor> Couldn't match expected type `Integer' with actual type `[Integer]'
21:16:51 <carter> dysinger i'm glad kirin dave chimed in
21:17:01 <levi> Because it's comparing the type of the pattern with the type of the expression to the left of the |
21:17:08 <enthropy> chexxor: that doesn't doubleEveryOther thoguh
21:17:26 <chexxor> enthropy: it's a WIP, heh
21:18:01 <enthropy> you might try something like:  f (x:y:ys) = x*2:y:f ys; f x = x
21:19:46 <carter> that'd work nicely
21:19:49 <chexxor> enthropy: it has to start from the right, so I have to reverse the list first
21:19:56 <carter> why's that?
21:20:04 <carter> try enthropy's way :)
21:21:51 <enthropy> you can always throw a reverse or two in there, but it might be worth looking into whether you can change how you're making the list you're feeding into doubleEveryOther
21:26:57 <chexxor> playing around with this is killing me - I can't just throw numbers around to see what happens
21:27:39 <chexxor> the only feedback I get is compiler errors
21:29:02 <chexxor> This is disturbing me. Because I have to actually write working code, rather than writing out a "good-enough" solution
21:29:04 <enthropy> chexxor: well the type error is better than a runtime error from a dynamic language in that it applies to a much larger number of possible inputs to your function
21:30:28 <chexxor> enthropy: right I agree, but the compiler doesn't give me a warm fuzzy feeling
21:30:29 <enthropy> chexxor: there's also -fdefer-type-errors, which could help you're trying to use ghci with parts of a module that are correct
21:30:58 <c_wraith> ...  Is there any type with a fully polymorphic kind?  I find myself in the position of wanting type-level undefined.
21:31:02 <enthropy> but you still have a couple functions that aren't quite consistent yet
21:31:03 <c_wraith> Wait, does Any do that?
21:31:15 <chexxor> enthropy: thanks. I'll keep trying
21:32:41 <tabemann> silly opinion question:
21:32:54 <tabemann> what's a better name for a Scheme in Haskell than SCMHS
21:33:14 <enthropy> c_wraith: and if you add things like (ty :: aUniqueKindName), that doesn't work?
21:33:27 <c_wraith> Huh.  Any *does* work.
21:33:36 <c_wraith> enthropy: I need a concrete type, not a type variable
21:33:59 <c_wraith> And Any is sufficiently magical to unify with any kind.
21:34:03 * enthropy thought Any was kind *
21:34:18 <c_wraith> Apparently not, since I just used it someplace where it unified with * -> * -> *
21:34:31 <c_wraith> actually, it was * -> k -> *
21:34:59 <edwardk> Any (unfortunately) currently inhabits all kinds
21:35:02 <tabemann> and... what's a better place to put a Scheme impl. in the module tree than just Scheme.Foo?
21:35:19 <edwardk> this means that as it stands you can't do much interesting with product kinds
21:36:06 <edwardk> c_wraith: the existing behavior of Any will change soon, so don't rely on it in code you want to have live across future compilers
21:36:37 <c_wraith> edwardk: oh, thanks for the warning.  Is there a type intended to work as a type-level undefined?
21:36:42 <edwardk> no
21:36:56 <edwardk> because it breaks eta-expansion at the type level
21:37:01 <carter> tabemann where?
21:37:04 <carter> hackage?
21:37:08 <carter> or in your local stuff?
21:37:19 <carter> github is fine for things too :)
21:37:31 <carter> Scheme has other meanings in math though...
21:37:37 <carter> Language.Scheme. something
21:37:40 <carter> woudl be beetter
21:37:47 <edwardk> The existence of Any currently prevents us from refining a type that inhabits say the kind (*,*)   to know that it must be '(a,b) for some type a and some type b
21:38:01 <c_wraith> Ah, yes.  That is problematic
21:39:02 <c_wraith> I guess I'll just stick (,) in there.  It unifies with the right kind, even if it's..  really pretty wrong, semantically.
21:39:16 <elliott> just define your own data?
21:39:23 <elliott> data Foo (a :: *) (b :: k) or such
21:39:40 <c_wraith> "data Proxy2 a b" suffices, with PolyKinds turned on
21:40:03 <tabemann> back
21:40:15 <c_wraith> I guess that's much better semantically.
21:40:36 <tabemann> carter: okay, I'll put it under Language.Scheme, but I need to give it a name that isn't just something like HScheme (I've counted at least four things via Google with that name)
21:40:49 <carter> tabemann lets pause for a moment
21:40:56 <tabemann> and yeah, I'd plan on putting it in Hackage once I'm done
21:40:56 <carter> is this a hobby project or "serious scheme"
21:41:19 <tabemann> I'm trying to do a full R7RS-small, with the intent that it is highly embeddable in Haskell applications
21:41:25 <carter> tok
21:41:39 <Saizan> c_wraith: Any is fine as type-level undefined if you never pattern-match on it
21:42:01 <carter> how about after you've got R7RS small working and fast, pester me and i'll help you brain storm on it
21:42:21 <MrRacoon> ls
21:42:23 <carter> tabemann: you should also ahve a variant thats compiled stupidly using llvm-general :)
21:42:23 <tabemann> I've got the working name scmhs, but in retrospect it sounds stupid
21:42:24 <MrRacoon> :P
21:42:45 <carter> schemish-lang
21:42:48 <c_wraith> Saizan: sure, it work now, and was fine for my use case. The issue is edwardk's comment that Any will be changed in the future.
21:42:48 <carter> :)
21:42:52 <c_wraith> *works
21:42:58 <tabemann> I'm taking too much advantage of the GHC runtime environment and of idiomatic Haskell things, such as monad transformer stacks
21:43:07 <carter> there are ways :)
21:43:15 <carter> is it on github?
21:43:26 <Saizan> c_wraith: yeah, but afaik it's getting changed to a type family
21:43:27 <carter> the thing about putting a project on hackage is
21:43:36 <tabemann> not yet (I'll have to learn git first, as I use svn personally)
21:43:38 <carter> "whats the support load i'm willing to take"
21:43:42 <carter> ok
21:43:42 <levi> chexxor: What's the whole specification of the problem you're trying to solve?
21:44:12 <Saizan> c_wraith: so pattern matching is the one thing you'll lose
21:44:22 <tabemann> i.e. if I put it on Hackage I should expect to be maintaining it for the rest of my life, basically
21:44:23 <carter> like… some of the stuff i'm going to push to hackage in the near future, is kinda stuff i'm going to work full time on
21:44:24 <carter> and support
21:44:33 <carter> if you want it to still work for that time scall
21:44:43 <carter> theres lots of rando mini libs and bit rotted things too
21:44:43 <c_wraith> Saizan: a 0-arg type family?
21:45:18 <Saizan> c_wraith: yeah
21:45:23 <c_wraith> interesting.
21:45:43 <c_wraith> That kind of enforces the idea of it as a type that doesn't exist
21:47:31 <tabemann> okay, Language.Scheme.Amoeba (very random name)
21:47:49 <nukeesimo> ciao
21:47:53 <nukeesimo> !list
21:47:53 <monochrom> nukeesimo: http://okmij.org/ftp
21:48:21 <carter> hehe
21:48:28 <tabemann> is it a problem that Tanenbaum wrote a distributed OS named Amoeba back when?
21:51:28 <tabemann> okay, no, Language.Scheme.Arachnid - the name Arachnid doesn't seem to be taken by anything major in computing yet
21:53:43 <carter> cool
22:00:09 <bigos> - interpStm(prog,[]); 8 7 80 val it = [("b",80),("a",8)] : table
22:06:11 <dmj> how do I force the thunk produced by unsafeInterleaveIO ?
22:06:20 <hpaste> dmj pasted “understanding interleaver” at http://lpaste.net/91445
22:06:42 <c_wraith> Err.  The exact same way as any other?
22:06:43 <hpaste> dmj revised “understanding interleaver”: “understanding interleaver” at http://lpaste.net/91445
22:07:21 <dmj> c_wraith: seek?
22:07:24 <dmj> oops, seq
22:07:31 <c_wraith> Ok, why are you using unsafeInterleaveIO?
22:07:47 <c_wraith> The *only* thing it does for you there is prevent the IO from happening
22:07:55 <c_wraith> If you want the IO to happen, don't use unsafeInterleaveIO
22:08:56 <dmj> c_wraith: In that code it writes the get request to stdout and sends html to browser, w/o it just hangs.
22:08:59 <ion> dmj: Ignoring the unsafeInterleaveIO strangeness: to have a value evaluated when an IO action is executed, see Control.Exception.evaluate
22:09:40 <c_wraith> dmj: I suspect you either have a bug, or want to use threads
22:09:48 <dmj> c_wraith: I can post entire example, using forkIO
22:10:00 <dmj> ion: i'll try that
22:10:52 <hpaste> dmj revised “understanding interleaver”: “http code” at http://lpaste.net/91445
22:10:54 <ion> Whatever that code is trying to do, it’s evil. :-P
22:11:39 <c_wraith> dmj: by the way, don't use the PortNumber constructor.  It doesn't do what you think it does.
22:12:05 <dmj> c_wraith: hmmm noted, I'll look into that
22:12:22 <dmj> ion: the goal is to use iteratees eventually. baby steps :)
22:12:56 <c_wraith> dmj: use the Num or Enum instance instead.  They actually work cross-platform
22:13:32 <dmj> c_wraith: ok, should I be using withSocketsDo as well? Is it just a windows things?
22:13:45 <zRecursive> :t withSocketsDo
22:13:47 <lambdabot> Not in scope: `withSocketsDo'
22:14:12 <dmj> @hoogle withSocketsDo
22:14:13 <lambdabot> Network.Socket.Internal withSocketsDo :: IO a -> IO a
22:14:13 <lambdabot> Network.Socket withSocketsDo :: IO a -> IO a
22:14:13 <lambdabot> Network withSocketsDo :: IO a -> IO a
22:14:29 <c_wraith> withSocketsDo is only needed on windows, but it's harmless on other OSes
22:15:13 <c_wraith> dmj: I'm *completely* certain unsafeInterleaveIO isn't what you want.  I'm just not certain what it is you do want.
22:17:19 <dmj> c_wraith: ideally, I'd want to use a *simple* iteratee implementation, that will allow me to parse the requests with attoparsec. What I don't know how to do is connect iteratees to read from a socket.
22:17:19 <dmj>  
22:17:19 <dmj>  
22:17:21 <c_wraith> It really looks like you don't want anything special.  You're already running in a handler thread.  You can't close the handle before you write the response to the client.
22:18:03 <c_wraith> Just write the response to the client.
22:21:10 <chexxor> levi:
22:21:14 <chexxor> levi: http://www.cis.upenn.edu/~cis194/hw/01-intro.pdf
22:22:03 <dmj> c_wraith: yea but I want to act on parsed data from the client.
22:22:03 <dmj>  
22:22:22 <c_wraith> so?
22:22:26 <c_wraith> That changes nothing
22:24:30 <dmj> c_wraith: but won't iteratees stop heap-build up? Make resource uses more predictable. i.e. if someone POSTs a lot of data, or does a file upload.
22:25:43 <dmj> @src unsafeInterleaveIO
22:25:43 <lambdabot> Source not found. Maybe if you used more than just two fingers...
22:25:48 <c_wraith> maybe.  Depends on what you're doing with the data.
22:26:20 <c_wraith> But I think you're looking two steps ahead, and not even thinking about what you need to do to make your stuff work *now*.
22:28:04 <harovali> I wrote     putStrLn  1    and I get the following suggestion from the compiler "Possible fix: add an instance declaration for (Num String)". I'd like to follow that, how's that done ?
22:28:09 <Ghoul_> if I have a thing called a SocketSerializer and it operates on the typeclass Socket
22:28:22 <Ghoul_> would it be more appropriate for it to have the name Socket.Serializer or SocketSerializer
22:28:48 <Ghoul_> where Socket is a module that contains things like the typeclass Socket and things like TCPSocket, UDPSocket etc.
22:28:58 <startling> harovali, that's nonsense advice.
22:29:22 <startling> harovali: I'm guessing you want "print", not "putStrLn"
22:29:25 <startling> > print 1
22:29:26 <lambdabot>   <IO ()>
22:29:37 <Ghoul_> harovali: try `putStrLn . show 1` or `print`
22:29:54 <Ghoul_> @src print
22:29:54 <lambdabot> print x = putStrLn (show x)
22:29:59 <Ghoul_> ^ They are the same :)
22:30:17 <startling> > putStrLn . show 1 -- Ghoul_
22:30:18 <lambdabot>   Couldn't match type `[GHC.Types.Char]' with `a0 -> GHC.Base.String'
22:30:18 <lambdabot>  Expect...
22:30:42 <Ghoul_> Oh, that doesn't work?
22:30:55 <Ghoul_> > putStrLn . show $ 1
22:30:56 <lambdabot>   <IO ()>
22:30:59 <Ghoul_> > putStrLn . show 1
22:31:00 <lambdabot>   Couldn't match type `[GHC.Types.Char]' with `a0 -> GHC.Base.String'
22:31:00 <lambdabot>  Expect...
22:31:06 <Ghoul_> There's the gotcha. My bad.
22:31:44 <dmj> c_wraith: well, the initial goal was to read/write to/from a web server. I guess the next step would be parsing the actual http request. Then do an eval function which would prob pass around a map in a state monad for the cache, log with a writer and use a reader to reference the httpRequest, while building a response. Then figure out how to handle persistent connections.
22:32:27 <harovali> Ghoul_: thanks  startling: thanks
22:33:17 <startling> you probably don't want to use State for the cache.
22:33:20 <harovali> function application is right-associative, right ?
22:33:31 <harovali> I meant left associative
22:33:33 <dmj> c_wraith: I just don't want to make the wrong decision from the beginning, but I guess that can't be helped sometimes :)
22:33:46 <dmj> startling: why
22:34:38 <dmj> startling: ah, io ref wouldn't use as much memory?
22:34:44 <Ghoul_> > (^3) . (*2) 1
22:34:45 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
22:34:46 <lambdabot>    arising from a use ...
22:34:54 <startling> dmj, it interferes with laziness (everything needs to be evaluated to give you an answer, because any part can change the state) and would make it harder to do things in parallel needlessly.
22:36:19 * Ghoul_ kicks lambdabot
22:36:19 <Ghoul_> > (^3) . (*2) 1
22:36:19 <Ghoul_> @botsnack
22:36:19 <Ghoul_> Bot overboard!
22:36:20 <lambdabot> :)
22:36:20 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
22:36:21 <lambdabot>    arising from a use ...
22:36:35 <startling> Ghoul_, you're having trouble with (.)
22:36:38 <startling> :t (.)
22:36:38 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:36:44 <startling> :t (* 2) 1
22:36:45 <lambdabot> Num a => a
22:36:45 <Ghoul_> Damnit, sorry
22:36:48 <Ghoul_> my BNC broke
22:37:22 <mikeplus64> startling: the error is pretty bizarre though, probably some lambdabot stuff (maybe defaulting to some grotesque Num instance involving Typeable?)
22:37:42 <startling> yeah, it's definitely strange.
22:37:51 <Neqoxec> Ghoul_: what are you using haskell and a BNC cable for?
22:38:03 <mikeplus64> >>> :t (^3) . (*1) 1
22:38:04 <mikeplus64> (^3) . (*1) 1 :: (Num c, Num (a -> c)) => a -> c
22:38:21 <Ghoul_> hah
22:38:32 <startling> still not what you want, though.
22:38:37 <startling> (probably)
22:38:40 <mikeplus64> Ghoul_: you probably want ((^3) . (*1)) 1
22:39:12 <Ghoul_> or just a $, I was checking whether it was left or right assosciative to answer the question by harovali
22:40:03 <mikeplus64>  oh
22:40:05 <Ghoul_> and the answer seems to be that it's right associative from what I can tell :)
22:42:05 <startling> > f g h a
22:42:06 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr a1)
22:42:07 <lambdabot>    arising from a u...
22:42:12 <johnw> $ associates to the right
22:42:15 <startling> > f g h a :: Expr
22:42:16 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a1)
22:42:16 <lambdabot>    arising from a us...
22:43:59 <dmj> > (^3) <$> (*1) $ 1
22:44:00 <lambdabot>   1
22:51:01 <Ghoul_> is `newtype Store a = Store { unstore :: a }` equivalent to `newtype Store a = Store  where unstore :: a` ?
22:51:26 <mikeplus64> :t (negate + negate)
22:51:27 <lambdabot> (Num (a -> a), Num a) => a -> a
22:55:12 <c_wraith> hmm.  Is it better to have a type variable that can only usefully take the types Array or UArray, or some promoted data type indicating there are only two options, and using a type family to convert that to Array or UArray as needed?
22:56:20 <dmj> Ghoul_: are you sure the latter one is valid?
22:56:23 <Saizan> c_wraith: the former probably gives better inference
22:56:29 <Ghoul_> No I'm not.
22:56:38 <c_wraith> In theory there could be more instances of IArray, but my code is already doing stuff that only works for those two, like using a type family to get the correct backing type for unsafeFreeze to not be a copy.
22:56:48 <Ghoul_> but if there's an equivalent version which doesn't use braces I'd like to use it
22:57:01 <startling> Ghoul_, there really isn't.
22:57:09 <Ghoul_> Ah, oh well.
22:57:10 <startling> well
22:57:34 <startling> you could do have "unstore (Store a) = a" later.
22:58:53 <dmj> Ghoul_: why no braces?
22:59:27 <Ghoul_> I think they make the code uglier
22:59:30 <Ghoul_> that's all.
23:01:36 <arkeet> he's afraid of the dentist.
23:02:14 <Ghoul_> haha
23:03:55 <arkeet> that's not funny, dental phobia is a serious thing =(
23:04:21 <dmj> cycle "{}"
23:05:47 <Ghoul_> dmj is an evil human being.
23:06:09 <Fuuzetsu> Is there a mapFilter somewhere in base? I'd like to get rid of ‘map quux $ filter foo $ map bar xs’ or at least to shorten it
23:06:15 <Ghoul_> or he's just a C++ programmer.
23:06:17 <Ghoul_> Can't tell sometimes.
23:07:01 <arkeet> :t (catMaybes .) . map
23:07:04 <lambdabot> (a1 -> Maybe a) -> [a1] -> [a]
23:07:15 <arkeet> that's sort of like a filterMap
23:07:24 <dmj> Ghoul_: :) the past is the past
23:07:32 <Fuuzetsu> I guess
23:07:32 <arkeet> well, it's a direct generalization of filter when a = (), since Maybe a ~ Bool
23:07:35 <arkeet> er, Maybe ()
23:08:27 <arkeet> @let filterMap f = catMaybes . map f
23:08:27 <lambdabot>  Defined.
23:08:31 <arkeet> and of course
23:08:35 <arkeet> :t \f -> filterMap (Just . f)
23:08:36 <lambdabot> (a1 -> a) -> [a1] -> [a]
23:08:39 <arkeet> that's map.
23:08:41 <startling> arkeet, check out concatMap
23:08:49 <startling> er
23:08:54 <startling> Fuuzetsu: ^
23:08:59 <arkeet> concatMap would do it too.
23:09:05 <arkeet> where instead of a you put [a]
23:09:07 <startling> Fuuzetsu: anyway, it doesn't matter a whole lot.
23:09:26 <ion> Also, (=<<) = concatMap
23:09:32 <arkeet> wait.
23:09:36 <arkeet> what I said about filter isn't quite right.
23:10:00 <startling> it should only iterate once across the list, anyhow, since Haskell is lazily evaluated.
23:10:30 <Fuuzetsu> startling: it's just for aesthetic value
23:10:35 <ion> > [0..] >>= \n -> n^2 <$ guard (even n)
23:10:37 <lambdabot>   [0,4,16,36,64,100,144,196,256,324,400,484,576,676,784,900,1024,1156,1296,14...
23:12:35 <Gracenotes> the mailing list post to haskell for the IEEE conferences ended up in my Promotions tab in gmail
23:12:37 <zRecursive> :t guard
23:12:38 <lambdabot> MonadPlus m => Bool -> m ()
23:13:19 <Fuuzetsu> For a second there I though you had a dedicated tab for job promotions
23:13:22 <Fuuzetsu> thought*
23:15:28 <pharaun> heh
23:17:42 <dmj> req = string "GET" *> return GET <|> string "PUT" *> return PUT
23:18:08 <Gracenotes> people are promoting various things to me, for commercial reasons evidently
23:21:47 <ion> dmj: GET <$ string "GET" <|> PUT <$ string "PUT"
23:22:01 <ion> With OverloadedStrings: GET <$ "GET" <|> PUT <$ "PUT"
23:22:16 <ion> (I don’t actually remember if Parsec has that IsString instance.)
23:24:03 <startling> I don't think it does.
23:25:18 <hpaste> chexxor pasted “doubleEveryOther” at http://lpaste.net/91448
23:25:32 <startling> > "GET" :: Text.Parsec.Stream s m Char => String -> Text.Parsec.ParsecT s u m String
23:25:33 <lambdabot>   Not in scope: type constructor or class `Text.Parsec.Stream'Not in scope: t...
23:30:41 <enthropy> chexxor: you're missing a ' in line 4
23:30:58 <chexxor> ah!
23:31:04 <ion> I think AttoParsec has such an instance.
23:37:17 <dmj> @def g = 1
23:37:18 <lambdabot>  Defined.
23:37:58 <dmj> @def double xs = zipWith (\a b -> if even b then a else 2*a) xs [0..]
23:37:59 <lambdabot>  Defined.
23:38:03 <dmj> double [1..10]
23:38:22 <dmj> > double [1..10]
23:38:23 <lambdabot>   Ambiguous occurrence `double'
23:38:23 <lambdabot>  It could refer to either `L.double', defined...
23:38:48 <dmj> @def doubler xs = zipWith (\a b -> if even b then a else 2*a) xs [0..]
23:38:49 <lambdabot>  Defined.
23:38:55 <dmj> > doubler [1..10]
23:38:58 <lambdabot>   mueval-core: Time limit exceeded
23:40:10 <timthelion> Is there a web server for haskell that is primarily for static pages, but would allow me to add dynamic pages+session handling if I want?  I'd have to say, that from a naive standpoint apache+PHP is simple to set up, and I'd be happy with that except for my fear of PHP
23:40:24 <dmj> http://jaspervdj.be/hakyll/
23:40:29 <carter> hakyll is nice
23:40:34 <carter> but doesn't let you add new pages dynamcially...
23:40:40 <carter> or am i out of date on that?
23:40:53 <johnw> there is a WAI app for serving static pages that's dead easy to use
23:41:02 <johnw> and then from there you can add dynamic stuff
23:41:27 <timthelion> dmj: Thanks, looks promissing
23:41:29 <johnw> http://hackage.haskell.org/package/wai-app-static
23:41:35 <timthelion> johnw: thanks :)
23:41:53 <johnw> hakyll doesn't actually serve the pages, though
23:41:58 <johnw> it does generate them
23:42:09 <enthropy> once you have a web server compiled in haskell, it's pretty simple to serve up static content
23:43:37 <timthelion> enthropy: well, that would require me to CHOOSE the way I want to generate dynamic pages.  For now, I just want to throw some static elm code online(a game) but perhaps in the future I'd like to post high scores...
23:44:02 <dmj> scope creep
23:45:21 <dmj> timthelion: how do you plan on saving scores? sessions seems to imply user logins.
23:46:43 <timthelion> dmj: perhaps old arcade style: "You have gotten a high score, type in your name to be featured on the list." It could be a 5 line text file for all I care ;)
23:47:51 <ion> So a high score submitted by either your game or a simple invocation of curl from the command line is fine?
23:48:19 <timthelion> ion: I thought about that ;)
23:48:48 <timthelion> ion: but is there really a *reasonable* way to prevent cheating?
23:48:49 <zRecursive> @package mighttpd2
23:48:49 <lambdabot> http://hackage.haskell.org/package/mighttpd2
23:50:21 <timthelion> zRecursive: that looks like it might fit my bill, if I understand the "reverse proxy function" bit, then I could choose my dynamic pages web server later.
23:50:21 <hpaste> chexxor revised “doubleEveryOther”: “doubleEveryOther” at http://lpaste.net/91448
23:50:28 <chexxor> How to make the first '2' into a '4'?
23:51:02 <timthelion> ion: if you do everything client side sessions and loggin or not, is ther _any_ way to prevent cheeting?
23:51:02 <dmj> timthelion: that's cool. you could send an ajax post, use aeson to convert to a haskell type and save it with acid-state for persistence.
23:51:18 <dmj> timethelion: you might be interested in scotty.
23:51:23 <dmj> @package scotty
23:51:23 <lambdabot> http://hackage.haskell.org/package/scotty
23:58:22 <zRecursive> timthelion: mighttpd2 runs my old CGI python app well
23:59:26 <timthelion> zRecursive: :)  I like it so far.  It makes sense :)
