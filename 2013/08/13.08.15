00:00:00 <edwardk> :t [1,2,3]^!act print
00:00:01 <lambdabot> IO ()
00:00:13 <edwardk> :t [1,2,3]^!traverse.act print
00:00:14 <lambdabot> IO ()
00:00:30 <edwardk> the former will print the list, the latter will traverse and print each element
00:00:45 <scshunt> ah, neat
00:00:54 <edwardk> so you can compose actions with getters and folds yielding actions or 'monadic folds'
00:01:06 <edwardk> and they dumb down traversals to folds so they compose too, etc.
00:01:13 <edwardk> but you can only 'read' with them
00:01:34 <edwardk> attempting to close the loop and provide writing turn out to cause all sorts of corner cases that are ill-posed
00:01:49 <scshunt> hmmm, I need to have a shower. I'm going to chew on this while I do so :)
00:01:52 <edwardk> so i've chosen for now to stick to the dialect i can reason about uniformly throughout my code
00:02:12 <edwardk> and leave 'monadic lenses' to those who are happier about playing fast and loose with their ability to reason about code ;)
00:02:37 <edwardk> even something as seemingly simple as a monadic lens to access the target of an IORef is dangerous
00:03:01 <scshunt> my thought here is a series of lenses for an actual database, so that you could design lenses which update a structure and its database entry in parallel
00:03:12 <edwardk> bcause you might have that IORef lead to itself transitively, so as you modify and come out the chain you can break laws
00:03:22 <edwardk> so you have to know global properties about your world state to do so
00:03:38 <scshunt> I don't like reasoning about IORef's :P
00:03:41 <edwardk> well, here we can talk about the structure of analytics which was being designed with lens-based offline storage in mind
00:03:47 <edwardk> but it takes an odd approach
00:03:56 <scshunt> anyway, shower!
00:04:46 <edwardk> basically i just mmap in the underlying storage for the data and then within the context in which i know its legal i can lens it to my heart's content, the log-structured style in which it is inserted ensures i can always get some nternally consistent copy of the data as a set of contiguous memory mapped regions of disk
00:05:12 <edwardk> so all the lens stuff would just happen inside some withDB :: … block
00:14:57 <ReinH> haasn: so right now I'm using Graphics.Pgm to write out a simple greyscale pgm file and then netpbm to convert to png
00:15:00 <ReinH> works
00:15:01 <ReinH> quite fast too
00:15:27 <ReinH> https://dl.dropboxusercontent.com/u/632742/rule90.png
00:15:28 <ReinH> wewt
00:35:17 * hackagebot filecache 0.2.0 - A Linux-only cache system associating values to files. The values are discarded when the files are modified.  http://hackage.haskell.org/package/filecache-0.2.0 (SimonMarechal)
00:35:57 <raymank26> hi all! What's wrong with my code? http://pastebin.com/V3tmV04W
00:36:03 <mauke> The paste V3tmV04W has been copied to http://lpaste.net/91857
00:40:17 * hackagebot yesod-dsl 0.1.1.5 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.5 (TeroLaitinen)
00:40:31 <mauke> raymank26: you're trying to use x/y as if they were doubles
00:40:53 <raymank26> but why not?
00:41:43 <raymank26> In my case type constructor Vector a accepts only Fractional types
00:41:49 <raymank26> including Double
00:44:27 <mauke> yes, but it also accepts other types
00:44:37 <mauke> and most types aren't Double
00:45:40 <raymank26> hm..
00:45:49 <raymank26> thank you
00:47:15 <ReinH> edwardk: ping
00:51:59 <nhanho>  /msg NickServ VERIFY REGISTER nhanho iufojmokyxzd
00:52:04 <nhanho> ah crap
00:52:06 <nhanho> sorry
00:52:42 <nhanho> anyway, would this be the right channel to ask silly question, or should I try the beginner mailing list for that?
00:53:05 <sipa> you can ask silly questions all you want
00:53:39 <sipa> as long as 1) you don't expect an immediate answer  2) you don't ask to ask :)
00:56:43 <nhanho> okay, thanks. Here comes: I'm trying to understand, when I'm defining, says, "data Fruit = Banana | Apple", Fruit would be the type, but what is Banana and Apple?
00:57:10 <scshunt> edwardk: what's the reason for the MonadReader instance in view?
00:58:33 <nhanho> in other words, I'm coming from an imperative background where stuffs are supposed to be built up from some primitive type (int, str etc), and obviously with that declaration, Banana and Apple isn't something of a primitive type, what are they?
00:58:56 <klugez> nhanho: Constructors. Possible values of that type.
00:59:46 <nhanho> I got the data constructor case, but on the possible values cases, exactly what value would they be?
01:00:02 <supki> scshunt: that way you can ask for parts of environment inside ReaderT
01:00:06 <sipa> Banana, or Apple
01:00:09 <supki> scshunt: see 'use'
01:00:22 <supki> (that's for MonadState)
01:00:28 <sipa> nhanho: so far, they are similar to enums in some other languages
01:00:35 <arkeet> nhanho: think of it as a souped up enum.
01:00:43 <klugez> nhanho: A constructor with no parameters is a value in itself. Like enum value in some other languages.
01:00:43 <arkeet> (souped up because you can give the constructors arguments.)
01:01:17 <sipa> and they are as primitive as you can get
01:01:33 <sipa> Bool is defined as data Bool = True | False
01:01:55 <arkeet> False | True, actually. (it matters for the derived instances)
01:02:01 <sipa> indeed!
01:02:41 <edwardk> scshunt: we have 'use' to get access to part of your state in a MonadState
01:02:56 <edwardk> scshunt: do x <- use _1; _1 .= x
01:03:10 <edwardk> scshunt: 'view' is analogous. it lets you access the environment in a reader
01:03:31 <edwardk> it happens to be that view is also the combinator you use to just do it in (->) s
01:03:37 <edwardk> because (->) s  forms a reader monad
01:04:17 <edwardk> by generalizing view the prefix combinator folks expect we are able to avoid making up some other name for the version that looks in the environment and is otherwise just a generalization of view
01:04:34 <edwardk> now you can use view deep in a transformer stack
01:09:58 <nhanho> what happens if I then define "data Fruit = Banana | Apple" and "data YellowFruit = Banana" ? In ghci, the latter declaration seems to override the Banana in the first case
01:10:53 <ReinH> edwardk: so... comonadic actions on a cellular automata... shouldn't they be parallelizable?
01:11:09 <nhanho> I meant, "x = Banana" would make x a YellowFruit, and I can't even force it to be a Fruit
01:11:10 <edwardk> yes
01:11:31 <edwardk> you just need a smarter cellular automaton rep =P
01:11:39 <edwardk> hence my statement about the tree
01:11:45 <ReinH> right
01:11:48 <edwardk> then a few sparks and you're on your way
01:11:54 <ReinH> makes sense
01:12:08 <edwardk> in fact...
01:12:11 <klugez> nhanho: In a file that would be a compilation error. Ghci just let's you redefine things.
01:12:12 <Saizan> nhanho: yeah, constructors only belong to one type
01:12:49 <nhanho> oh, so they aren't actually like enum or the primitive, since you can actually have "Number = 1 | 2 |3" and "OddNumber = 1" at the same time, right?
01:12:53 <edwardk> http://hackage.haskell.org/packages/archive/representable-functors/3.1/doc/html/Control-Comonad-Representable-Store.html is a 'Representable' store comonad
01:13:19 <ReinH> I see
01:13:22 <ReinH> except not really
01:13:26 <shachaf> nhanho: 1 is syntax sugar for a class method, more or less.
01:13:43 <edwardk> that would tabulate the result for you, so in theory you could generate the results from the previous 'generation' and then move to the next
01:13:43 <edwardk> consider the difference between data Pair a = Pair a a    and (Bool -> a)
01:13:45 <shachaf> class Num a where 0, 1, 2, ... :: a
01:13:47 <edwardk> the former 'memoizes
01:13:54 <shachaf> (Except it's actually fromInteger :: Integer -> a.)
01:13:54 <edwardk> because it has a place to store each a
01:13:56 <klugez> nhanho: No, you can't have the same constructor in two types. (In the same module.)
01:14:05 <shachaf> It acts like a constructor with a bit more sugar.
01:14:09 <edwardk> with me?
01:14:27 <edwardk> so if you store something in a pair and then take it out based on a bool, you have memoized a function
01:14:43 <ReinH> I think so
01:15:03 <edwardk> now we can generalize this trick so that we can make a tree that represents a function from an Int or Integer
01:15:24 <edwardk> then the fact that our automaton can be viewed as Store Int Bool means
01:16:11 <edwardk> we can have data Store Int Bool = Store (Int -> Bool) Int   with the Int -> Bool represented using that trick
01:16:19 <edwardk> storeT :: (Functor w, Representable g) => w (Key g -> a) -> Key g -> StoreT g w a
01:17:12 <nhanho> okay, thanks
01:17:33 <edwardk> store :: Representable g => (Key g -> a)	-> Key g -> Store g a  -- looks like you're constructing a normal store
01:17:36 <nhanho> why can't I have "data Nuum = 1" ?
01:17:52 <shachaf> Why would you be able to?
01:18:02 <edwardk> nhanho: because 1 is magic
01:18:17 <edwardk> why can't you name your class 1 in c?
01:20:39 <nhanho> hmm, where I can get more info on the magic of 1 (no sarcasm intended)?
01:20:46 <ReinH> edwardk: so this uses the instance Keyed ((->) a)?
01:20:52 <shachaf> The Haskell Report.
01:21:01 <shachaf> It's not a big deal so don't worry about it.
01:21:43 <edwardk> not quite
01:21:47 <edwardk> the instance is on 'g'
01:21:54 <edwardk> g is like Pair
01:22:03 <edwardk> Key Pair = Bool
01:22:23 <nhanho> but I mean, it seems like "data Something = (some literal like int/ str here) " just doesn't work at all, and that seems really counter-intuitive to me
01:22:55 <ReinH> edwardk: so Key g -> as is out "computation", in this case rule evaluation?
01:22:57 <shachaf> The short answer is that those are taken.
01:23:01 <ReinH> *our
01:23:25 <shachaf> You can't write data Foo = Nothing because Nothing is already taken by Maybe.
01:23:25 <edwardk> yeah, the store then tabulates the functin from (Key g -> a)   by building (g a) out of it
01:23:43 <ReinH> because g is a representable functor
01:23:56 <shachaf> Oh, now I understand where the name "tabulate" comes from.
01:24:09 <shachaf> It's like making a lookup table out of a function.
01:24:10 <edwardk> nhanho: numeric literals are handled by overloading the Num class. To pattern match on them you need an instance of Num and Eq.
01:24:21 <edwardk> nhanho: but they aren't the names of your constructors
01:24:34 <edwardk> constructors 'start with an upper case letter'. 1 isn't upper case.
01:25:02 <shachaf> Now I won't mix up tabulate and, uh, the other one.
01:26:18 <ReinH> edwardk: so we're essentially memoizing the rule?
01:26:50 <edwardk> Store g  here replaces your ListZipper
01:27:04 <edwardk> its a tree-like structure for the zipper
01:27:16 <edwardk> in lens it'd be a magma
01:27:58 <edwardk> > [1..3]^.magma traverse
01:28:00 <lambdabot>   .. <$> Magma 0 1 <*> (.. <$> Magma 1 2 <*> (.. <$> Magma 2 3 <*> pure ..))
01:28:09 <nhanho> thanks alot! Last quick question: constructor starts with an upper case letter, but can non-constructor start with upper-case letter too?
01:28:21 <edwardk> nhanho: no
01:28:54 <nhanho> wait, so Nothing would be a constructor too?
01:29:01 <edwardk> Nothing is a data constructor
01:29:06 <edwardk> that means you can pattern match on it
01:29:09 <edwardk> > Nothing
01:29:10 <lambdabot>   Nothing
01:29:26 <edwardk> > let foo Nothing = True; foo (Just a) = False in foo Nothing
01:29:27 <lambdabot>   True
01:29:41 <edwardk> notice that 'True' and 'False' also start with an upper case letter
01:30:27 <nhanho> so, why is "data Nuum = Noo Float" allowed, but "data Nuum = Noo Nothing" not?
01:30:30 <edwardk> Uppercae = Constructor, lowercase = variable
01:30:37 <shachaf> nhanho: Because Nothing isn't a type.
01:30:39 <edwardk> Float is a type
01:30:41 <edwardk> Nothing is a value
01:30:56 <edwardk> Nothing is a data constructor. float is a type constructor
01:30:58 <shachaf> data A = B C D E...
01:31:16 <shachaf> A is a type. C,D,E,... are types. B isn't a type -- it's a data constructor.
01:31:35 <nhanho> oh I see, thanks alot!
01:31:41 <arkeet> the syntax is a little confusing.
01:31:51 <arkeet> at first.
01:32:04 <arkeet> GADT syntax is clearer, but more verbose:  data A where B :: C -> D -> E -> A
01:32:16 <edwardk> :t data Nuum where Noo :: Float -> Nuum  -- is perhaps more explanatory
01:32:16 <lambdabot> parse error on input `data'
01:32:25 <edwardk> Noo takes a Float and gives you a Nuum
01:32:46 <arkeet> I wonder what edwardk thought :t would do.
01:33:08 <shachaf> arkeet: You mean, what he thinks the type of :t is?
01:33:09 <edwardk> arkeet: i started saying one thing and switched
01:33:12 <edwardk> i do that a lot ;)
01:33:19 <arkeet> edwardk: I figured. I do too.
01:33:26 <ReinH> edwardk: so for a quick refresher, Store s a = Store (s -> a) s which, intuitively, is a way to get an a from an s, and a current s?
01:33:32 <arkeet> but usually I remember to clear the line when I switch.
01:33:40 <edwardk> ReinH: yep
01:33:46 <ReinH> so basically a store of a keyed by s and a current position
01:33:53 <edwardk> so if s = Int, you can have your whole list
01:33:58 <edwardk> with instant access to any value
01:34:01 <edwardk> but you have to recompute it
01:34:16 <ReinH> but... how does that work for the list zipper, which is infinite in both directions?
01:34:21 <ReinH> or for the Store equivalent
01:34:46 <edwardk> by replacing (s -> a)   with a representable functor 'with representation s' then we build a tree like structure to access it
01:35:01 <hpaste> scshunt pasted “Monad lenses?” at http://lpaste.net/91859
01:35:17 <scshunt> edwardk: I'm going to assume you've already found the problem with that, curious as to what it is :P
01:35:23 <ReinH> edwardk: how does it build a tree?
01:35:25 <edwardk> ReinH: choose s = Integer
01:36:01 <ReinH> ok
01:36:08 <edwardk> ReinH: you can tabulate Bool, right? with Pair, so we just need a few more things, 1   is easy its just tabulated with Identity
01:36:36 <edwardk> pairs are also easy you tabulate the left thing wrapped around the tabulation of the right
01:36:52 <edwardk> addition becomes multiplication, multiplication becomes composition,
01:37:13 <arkeet> scshunt: what are the laws?
01:37:36 <arkeet> that's where the issue is, I think.
01:38:10 <scshunt> arkeet: should be the same as the regular lens laws, modulo monadic actions
01:38:11 <edwardk> (m a -> FM f m b) -> s -> FM f m t       doesn't compose very well ;)
01:38:22 <arkeet> heh.
01:38:34 <edwardk> the shape of the input function (m a -> FM f m b)   doesn't match s -> FM f m t
01:38:37 <edwardk> there is an extra m
01:38:39 <arkeet> I just noticed that.
01:38:52 <scshunt> hmm
01:38:56 <arkeet> scshunt: what does "modulo monadic actions" mean, anyway?
01:38:59 <arkeet> you can't ignore them.
01:39:02 <scshunt> why did baz compile, anyway?
01:39:15 <arkeet> because foo and bar are very polymorphic.
01:39:33 <arkeet> as are sample and sampleM
01:39:37 <arkeet> try some real life examples ;)
01:39:39 <edwardk> because you have way too polymorphic examples
01:39:45 <scshunt> ah
01:40:04 <scshunt> I was just using them as litmus tests and forgot to remove them :)
01:41:08 <edwardk> ReinH: anyways, see representable-tries or memo-combinators or better yet try to write the instances yourself for a bunch of stock types, doing Int is just a _really_ big tree. fortunately its lazy
01:41:18 <scshunt> arkeet: if your lense accesses, say, the contents of a file, then a put and a get are not the same as the identity function
01:41:20 <edwardk> Integer is an even bigger tree ;)
01:41:24 <scshunt> even notwithstanding races with other processes
01:41:37 <arkeet> scshunt: indeed!
01:42:48 <ReinH> edwardk: oh, Pair is really BoolTrie?
01:42:57 <edwardk> yeah
01:43:11 <ReinH> which is a memoized Bool -> a
01:43:12 <ReinH> obv
01:43:17 <edwardk> yep
01:43:17 <FreeFull> Integers are implement as trees by libgmp at least
01:43:36 <edwardk> it is addictive once you've done a few
01:43:47 <FreeFull> For something Int-sized I'd rather use some binary representation instead
01:44:00 <FreeFull> Which you can easily do using pure types too
01:44:08 <edwardk> you can then see that a complex number is just a representable functor with representation data C = E | I          (or Bool)
01:44:24 <edwardk> ReinH: if you carry this too far it leads you to my algebra package
01:44:29 <edwardk> or to linear
01:44:33 <edwardk> both are based on that idea
01:44:36 <ReinH> oh and it's just keyed by Bool
01:44:38 <ReinH> fucking duh
01:45:07 <shachaf> If you carry it too far it can lead you to any of edwardk's packages.
01:45:15 <shachaf> Carrying things too far is sort of how they work.
01:45:16 <FreeFull> Wait, why is it Bool and not Either?
01:45:19 <FreeFull> Wait
01:45:20 <edwardk> yeah
01:45:20 <FreeFull> I mean
01:45:27 <FreeFull> Why is it Bool, and not a tuple?
01:45:27 <edwardk> thats pretty much all i do
01:46:04 <FreeFull> Because given a bool, you can extract either of the components?
01:46:09 <edwardk> FreeFull: we're talking about the tabulation of any function _from_ Integer
01:46:33 <edwardk> (Integer -> a)  is isomorphic to a data structure full of 'a's its just infinitely big
01:46:46 <edwardk> (Bool -> a)    is isomorphic to data Pair a = Pair a a
01:47:01 <FreeFull> Ah, I usually see (Nat -> a) instead of (Integer -> a)
01:47:01 <shachaf> (Integer -> Bool) -> a, on the other hand...
01:47:10 <edwardk> FreeFull: thats fine too
01:47:28 <FreeFull> Yeah, there are mappings from Nat to Integer
01:48:07 <edwardk> anyways the tree-like structure of Integer the implementation in gmp doesn't help build the memo-trie
01:51:04 <Chris325> So i was reading a haskell book, was quite nice but I was surprised to see that monads are incompatible with functional programming
01:51:24 <arkeet> they are??
01:51:37 * arkeet wonders what he's been doing with monads in haskell the whole time
01:52:20 <ReinH> o_O
01:52:24 <Tinned_Tuna> Chris325: Not sure if trolling.
01:54:24 <Chris325> Yeah it says in the book that they're replacing monads with list comprehensions?
01:54:34 <arkeet> ?????
01:54:46 <AllInOne> Welcome to TV OnLine Http://AllINONE.NIX.VN
01:55:11 <ReinH> Chris325: what book?
01:56:23 <Chris325> Well, I guess it makes sense because functional programming has no place in the industry
01:56:31 <ReinH> yep, trolling
01:56:34 <ReinH> nice try
01:56:42 --- mode: ChanServ set +o edwardk
01:56:52 <Chris325> Am I wrong?
01:56:56 --- mode: ChanServ set +o edwardk
01:57:02 <ReinH> I don't engage with trolls, sorry
01:57:11 <Chris325> you already have
01:57:17 <ReinH> ignored
01:57:34 --- mode: edwardk set +b *!~Chris@122-59-82-97.jetstream.xtra.co.nz
01:57:34 --- kick: Chris325 was kicked by edwardk (Your behavior is not conducive to the desired environment.)
01:58:06 <dudlitee> I kind of see what chris means, Monads are pretty much the same as classes in javs
01:58:09 <dudlitee> java
01:58:18 <arkeet> ????
01:58:18 <ReinH> More trolling?
01:58:21 <dudlitee> with less functions
01:58:28 <ReinH> dudlitee: what is a monad?
01:58:38 --- mode: ChanServ set +o shachaf
01:59:01 <dudlitee> They don't exist
01:59:10 <dudlitee> Lies spread by the government
01:59:15 <dudlitee> propaganda
01:59:16 <ReinH> another troll
01:59:16 --- mode: shachaf set +b *!*dudlitee@*.jetstream.xtra.co.nz
01:59:16 --- kick: dudlitee was kicked by shachaf (dudlitee)
01:59:20 <ReinH> it must be Thursday
01:59:24 <arkeet> it is!
01:59:28 <arkeet> oh crap, it is!
01:59:30 <arkeet> good night.
02:00:04 <hashcat> ReinH: Monads is just another abstraction of procedure.
02:00:26 <ReinH> hashcat: what does that mean?
02:00:37 --- mode: shachaf set +b *!*@122-62-237-10.jetstream.xtra.co.nz
02:01:16 <arkeet> can't be coincidence that they both had nearly the same hostname.
02:01:39 <ReinH> shachaf: btw chris was @122-59-82-97.jetstream.xtra.co.nz
02:01:42 <ReinH> so you might need a wider ban
02:01:52 <shachaf> I saw.
02:01:55 <ReinH> kk
02:01:56 <arkeet> but they were here simultaneously.
02:02:00 <hashcat> ReinH: I've wrote an short article:http://37.139.7.8/en/blog/?p=33
02:03:11 <hashcat> ReinH: because I've been asked many times
02:03:51 <ReinH> hashcat: That doesn't make any sense.
02:03:57 <ReinH> Even taking the language barrier into account
02:04:12 <arkeet> well, you didn't get the Monad definition right, to start.
02:04:43 <ReinH> :t (>>=)
02:04:43 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:04:54 <arkeet> and then it also didn't make any sense.
02:04:59 <ReinH> close but no cigar
02:05:02 <sordina> Just checking, doesn anyone know why netwire inhibits values down the line from a fifo?
02:05:47 <aloiscochard> oh my, an other monad post
02:06:04 <ReinH> aloiscochard: this one doesn't even bother with presenting a coherent idea
02:06:13 <Peaker> hashcat, no more monad tutorials, please...
02:06:17 <ReinH> so I guess the barrier to entry is a lot lower than I thought
02:06:21 <Peaker> hashcat, the world has enough
02:06:31 <hashcat> ReinH: naively, monads is just a set of silly rules
02:06:39 <ReinH> hashcat: yes, that is very naive.
02:06:53 <ReinH> it's also a meaningless statement
02:06:54 <arkeet> @quote endofunctors
02:06:54 <lambdabot> flebron says: <flebron> Monoidal objects in the monoidal category of endofunctors on a category. I took a small detour through tensor products to understand monoidal categories better, with one
02:06:54 <lambdabot> example of such a product. <mauke> I have no idea what you just said
02:06:57 <prophile> monads are functors with a "remove layer from onion" operation
02:06:59 <hashcat> Peaker: but not as short as mine :D
02:07:06 <arkeet> hmm.
02:07:13 <arkeet> @quote endofunctors
02:07:13 <lambdabot> flebron says: <flebron> Monoidal objects in the monoidal category of endofunctors on a category. I took a small detour through tensor products to understand monoidal categories better, with one
02:07:13 <lambdabot> example of such a product. <mauke> I have no idea what you just said
02:07:17 <ReinH> hashcat: also not as wrong as yours
02:07:17 <arkeet> oh well.
02:07:27 <Peaker> hashcat, but yours is short because it doesn't actually describe what monads are, why they're useful, etc
02:08:22 <ReinH> Peaker: getting the types right would have been a good start
02:08:31 <ReinH> it sort of goes downhill after that though
02:08:55 <hashcat> Peaker: you're right, I just try to provide a intuition to imperative programmer
02:08:58 <ReinH> I feel like there's a slight possibility that this is a very sophisticated Poe
02:09:04 <arkeet> it never defines or uses c :: IO Int  =(
02:09:37 <shachaf> arkeet: If it did one without the other, I could see the problem.
02:09:41 --- mode: shachaf set -o shachaf
02:09:53 <arkeet> well it gives the type signature
02:11:25 <ReinH> arkeet: it could be *anything*
02:11:28 <ReinH> just think of the possibilities
02:12:00 <ReinH> well, not anything
02:12:02 <ReinH> but you know what I mean
02:12:05 <ReinH> it's full of possibility
02:12:23 <arkeet> being potentially anything is as good as being nothing
02:12:24 <arkeet> :c
02:12:37 <ReinH> it could do all kinds of things!
02:12:51 <ReinH> it could read a value from input as an integer
02:12:58 <ReinH> it could write stuff somewhere and then return an integer
02:13:08 <ReinH> isn't that exciting?
02:13:23 <arkeet> could it help me go to bed? (and then return an integer)
02:13:33 <ReinH> perhaps!
02:13:36 <arkeet> !!
02:13:52 <arkeet> ok.
02:13:54 <arkeet> I will try it out.
02:14:06 <arkeet> [01:59:07] <arkeet> good night.
02:16:34 <kallisti> a monad is looking through a window at a foggy city street on a rainy day.
02:20:30 * hackagebot git-annex 4.20130815 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130815 (JoeyHess)
02:21:59 <merijn> oh good, I got on IRC just in time for the daily monad analogy hour
02:22:06 <elflord> an html is encoding with charset=iso-8859-1, how can i use readFile on it ? i get exceptions sometimes
02:22:33 <merijn> elflord: Use Data.ByteString.readFile, then use functions from Text.Encoding to decode to Text
02:23:10 <elflord> merijn, thanks man again, could you just show me oneliner if possitble ?
02:23:26 <elflord> i've also read about the text-icu package
02:24:05 <merijn> elflord: The problem you are having that "readFille :: IO String" assumes a specific encoding (which is probably not iso-8859-1), and thus errors if it encounters wrong characters
02:24:18 <FreeFull> Probably assumes utf-8
02:24:26 <merijn> elflord: You probably want to read this first: http://www.joelonsoftware.com/articles/Unicode.html
02:24:35 <elflord> merijn, alright !
02:24:54 <elflord> merijn, i'll do that. the default encoding depends my my bash env settings ?
02:25:11 <elflord> merijn, i mean locals
02:25:20 <elflord> merijn, i mean LOCALES
02:25:26 <elflord> ?
02:25:55 <merijn> elflord: Yeah, I think the default for readFile is to follow your locale (that or just hard default to UTF-8)
02:26:22 <elflord> ok
02:27:11 <merijn> elflord: Data.ByteString.readFile will let you read the file as pure bytes, and then you can use either Data.Text.Encoding or Data.Text.ICU to decode the ByteString to Text (you can convert Text to String, but that's probably useless, Text is much more efficient than String)
02:27:43 <elflord> merijn, got it. very clearly explained
02:28:33 <osfameron> elflord: are you named after the vim colorscheme?
02:29:19 <elflord> osfameron, haha yes
02:30:04 <Hafydd> readFille :: IO Fille
02:45:45 <tim_> hello
02:45:54 <tim_> i have a function
02:45:55 <tim_> (%) :: (Complex c, Integral i) => [[c]] -> i -> i -> c
02:46:06 <tim_> this raises
02:46:10 <tim_> Illegal polymorphic or qualified type: Integral i => [[c]] -> i -> i -> c
02:46:29 <tim_> can somebody help me to understand this?
02:47:11 <tim_> please :)
02:47:26 <bscarlet> Well, I can try
02:48:12 <tim_> would be great
02:49:12 <shachaf> You should usually post the full code and full error if possible.
02:49:15 <bscarlet> I can reproduce it. Now to understand it.
02:49:20 <shachaf> In this case, the issue is that Complex isn't a type class.
02:49:38 <shachaf> It's just a type (constructor). So you don't write Complex c => ...
02:50:11 <merijn> "(%) :: Integral i => [[Complex c]] -> i -> i -> Complex c" most likely
02:50:27 <merijn> Potentially with some constraint on c
02:53:01 <tim_> bscarlet: merijn shachaf thank you
02:54:06 <shachaf> We do?
03:05:09 <ReinH> edwardk: I'm hitting a mental brick wall with the representable stuff
03:07:52 <FreeFull> @hoogle clamp
03:07:52 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Parameters Clamp :: Clamping
03:07:52 <lambdabot> Graphics.Rendering.OpenGL.GL.Colors clampColor :: ClampTarget -> StateVar ClampMode
03:07:52 <lambdabot> Graphics.Rendering.OpenGL.GL.Colors ClampFragmentColor :: ClampTarget
03:08:17 <FreeFull> @hoogle Num a => a -> a -> a -> a
03:08:18 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexAttributes Color3 :: a -> a -> a -> Color3 a
03:08:18 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Color3 :: a -> a -> a -> Color3 a
03:08:18 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexAttributes Normal3 :: a -> a -> a -> Normal3 a
03:09:03 <mr-> FreeFull: is that even remotely what you expected? :-)
03:11:51 <FreeFull> mr-: Nope =P
03:11:59 <FreeFull> But considering hoogle, yes
03:12:56 <FreeFull> @hoogle clip
03:12:56 <lambdabot> package Clipboard
03:12:56 <lambdabot> package clippard
03:12:56 <lambdabot> package clipper
03:13:45 <silasm> !John
03:13:46 <FreeFull> I guess the Num constraint is actually too much
03:13:52 <FreeFull> You only need Ordering to implement it
03:13:58 <FreeFull> :t max
03:13:59 <lambdabot> Ord a => a -> a -> a
03:14:12 <quchen> What's the use of something like "module Foo (module Foo, bar)"? Is it a module that exports everything it defines, plus certain reexports?
03:14:15 <silasm> wrong channel, sorry if I pinged anyone.
03:14:26 <FreeFull> :t let f a b = min b . max a in f
03:14:26 <lambdabot> Ord c => c -> c -> c -> c
03:15:04 <FreeFull> > f a b = min b . max a in f 0.0 1.0 0.5
03:15:05 <lambdabot>   <hint>:1:7: parse error on input `='
03:15:11 <FreeFull> > let f a b = min b . max a in f 0.0 1.0 0.5
03:15:12 <lambdabot>   0.5
03:15:15 <FreeFull> > let f a b = min b . max a in f 0.0 1.0 3
03:15:16 <lambdabot>   1.0
03:15:23 <FreeFull> > let f a b = min b . max a in f 0.0 1.0 (-0.4)
03:15:24 <lambdabot>   0.0
03:16:09 <FreeFull> Of course, this means that you can clamp lists
03:16:15 <FreeFull> Although I don't know the use of that
03:16:27 <FreeFull> > let f a b = min b . max a in f [3,4] [5,6] [1,2]
03:16:28 <lambdabot>   [3,4]
03:16:31 <FreeFull> > let f a b = min b . max a in f [3,4] [5,6] [3,5]
03:16:32 <lambdabot>   [3,5]
03:16:35 <FreeFull> > let f a b = min b . max a in f [3,4] [5,6] [4,5]
03:16:36 <lambdabot>   [4,5]
03:16:38 <FreeFull> > let f a b = min b . max a in f [3,4] [5,6] [4,10]
03:16:39 <lambdabot>   [4,10]
03:20:32 * hackagebot hmatrix 0.15.0.1 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.15.0.1 (AlbertoRuiz)
03:22:17 <quchen> Argh, HLint cannot recognize LambdaCase because Cabal doesn't support it yet, it seems
03:22:59 <quchen> Cabal's HEAD has it though.
03:27:50 <hashcat> hmatrix is still GPL !
03:30:30 <hashcat> I know some works dependent on hmatrix is released under BSD3 because someone says hmatrix will released under BSD
03:31:27 <exicer> Uh, silly question - how can I import my own module into ghci ?
03:32:21 <hashcat> Add search path to ghci
03:33:06 <hashcat> or simply change current directory
03:33:15 <od-> im trying to find the best combination of 6 items from a set of 200. is this a combinatorial optimization problem or linear?
03:34:02 <exicer> hashcat: I'm clearly doing something wrong - I'm in the correct directory, but can't import the file
03:35:04 <hashcat> excicer: How did you import? What error did ghci respond?
03:35:27 <exicer> So I have a file test.hs
03:35:36 <exicer> how do I import it ?
03:35:38 <aleator> od-: Sounds like integer linear program to me.
03:36:02 <od-> ok cool thanks ill look into it
03:36:22 <hashcat> excier: I guess you have to load it before import it
03:36:49 <exicer> hashcat: facepalm. I am too used to python
03:36:52 <exicer> thanks
03:37:15 <hashcat> exicer: have fun
03:39:26 <MouseTheLuckyDog> Is a syntax diagram version of the Haskell grammar available someplace?
03:40:53 <hashcat> aleator: Integer linear programming should have inequality
03:42:13 <hashcat> MouseTheLuckyDog: I can think of ghc-vis
03:43:19 <hashcat> MouseTheLuckyDog: http://felsin9.de/nnis/ghc-vis/#interactive_usage
03:44:32 <MouseTheLuckyDog> hashcat: At first blush no. I want the actual grammar that Haskell uses as a syntax diagram.
03:45:57 <MouseTheLuckyDog> Also known as railroad diagrams.
03:46:40 <merijn> hashcat, exicer: No, you don't have to load before importing, but module names must always be capitalised and file names must be identical to module name
03:47:02 <merijn> hashcat, exicer: So you can't import "test.hs" because that could only contain a module named "test", which is illegal
03:47:47 <merijn> exicer: You can either "load" the file, using ":l test.hs" which just reads in the entire file and plays it back in ghci, or you rename it to "Test.hs" with the module name "Test" and in the current directory do "import Test"
03:52:58 <hashcat> merijn: Thanks for advice. I've never notice that name can't be import.
03:53:23 <hashcat> merijn: but you still need to load it before importing
03:55:08 <hashcat> merijn: I just tried to make sure that. ghci can't not find module before you load it
04:00:31 <swi> Greetings.
04:02:20 <swi> It's seems i forgot from what i have read about haskell. I want to save result from openURI function. How can i do this? I'v tried print putStr it' but allwasy get error for type unmatching
04:02:58 <hpc> swi: what's the type of openURI?
04:03:38 <swi> String -> IO (Either String Data.ByteString.Internal.ByteString)
04:05:15 <hpc> oh, i see now
04:05:27 <hpc> you're actually doing (print putStr it')
04:05:43 <hpc> just use (print it')
04:06:00 <hpc> if you want to save the whole (Either String ByteString) result
04:06:05 <swi> actualy i have   content <- openURI url and content then  of  Either String BS.ByteString
04:06:41 <swi> hpc: yep. print is working. But what if i need to save content to file ?
04:06:43 <hpc> if you have the ByteString directly, use the BS IO functions
04:07:02 <hpc> http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString.html#g:26
04:07:14 <hpc> BS.writeFile is probably what you want
04:07:24 <swi> but it' give me error
04:07:56 <swi> Couldn't match expected type `BS.ByteString with actual type `Either String BS.ByteString' In the expression: BS.writeFile "file" content
04:08:23 <hpc> you need to match on (Either String ByteString) to know which you have
04:08:35 <hpc> (String if it's errored, or ByteString file contents)
04:08:54 <hpc> and then decide what to do with both; you probably want to print the error and exit with ExitFailure, for instance
04:08:56 <swi> yes. and i forgot how to do it
04:09:24 <hpc> case content of {Left err -> ...; Right data -> ...}
04:09:42 <hpc> except on multiple lines and data is a keyword
04:10:45 <hashcat> swi, hpc: or use "either :: (a -> c) -> (b -> c) -> Either a b -> c"
04:11:29 <kloplop321> So, given a type class, `Something a`, where there's one function which takes a dummy variable (to obtain a constant), how do I call that function from another function within the same type class instance? I try to do (undefined :: a) but it seems that the ":: a" can be anything and it complains about ambiguity in the default implementation
04:13:34 <swi> hpc: yep. that's work. Thanks!
04:14:04 <swi> hashcat: hm.. dont understand how either:: can be used here
04:14:49 <hpc> swi: instead of case x of {Left l -> f l; Right r -> g r}, you would write (either l r x)
04:15:31 <hashcat> swi: that's it!
04:16:42 <hashcat> hpc: it should be (either f g x) not (either l r x)
04:16:54 <hpc> close enough ;)
04:16:54 <swi> indeed
04:17:11 <hashcat> hpc: :D
04:17:54 <exicer> could anyone recommend a guide to quickcheck ?
04:18:10 <swi> hashcat: nice!
04:19:06 <hpc> exicer: in theory, the docs should work
04:19:07 <hpc> http://hackage.haskell.org/packages/archive/QuickCheck/2.6/doc/html/Test-QuickCheck.html
04:19:56 <Work_jack> exicer: http://www.cse.chalmers.se/edu/year/2012/course/TDA452/FPLectures/Vid/ If you watch through this series of lectures, they cover QuickCheck rather extensively as they go
04:22:35 <exicer> Work_jack: Cool, will give them a watch
04:23:00 <exicer> hpc: Unfortunatley I'm not good enough at Haskell for the docs to be super useful (unless I already kinda know what the thing does). I need examples!
04:23:09 <Work_jack> I recommend you do! It's an excellent resource
04:24:50 <kloplop321> In other words, how do I refer to the type of the type signature of the instance of a typeclass, within a default function implementation?
04:25:08 <hpc> exicer: basically, you make a value of a type that's an instance of Testable, and then you give it to quickcheck
04:25:09 <kloplop321> In other words, how do I refer to the type signature of the instance of a typeclass, within a default function implementation?*
04:25:38 <hpc> Excureo: this includes functions, so you can do something like (quickcheck \x y -> x == y) -- i think that works
04:25:43 <hpc> > (quickcheck \x y -> x == y)
04:25:44 <lambdabot>   <hint>:1:13: parse error on input `\'
04:25:49 <hpc> > (quickcheck $ \x y -> x == y)
04:25:50 <lambdabot>   Not in scope: `quickcheck'
04:25:50 <lambdabot>  Perhaps you meant one of these:
04:25:50 <lambdabot>    `quickCheck'...
04:25:58 <hpc> > (quickCheck $ \x y -> x == y)
04:26:00 <lambdabot>   <IO ()>
04:26:35 <hpc> in ghci, that outputs "+++ OK, passed 100 tests."
04:26:52 <hpc> because it defaults the types to (), and () always equals ()
04:27:04 <Peaker> defaulting to () is so terrible :)
04:27:27 <Work_jack> Peaker: Tell me about it :) “Hey my sorting function works! ...wait a second”
04:27:32 <byorgey> kloplop321: perhaps you want the ScopedTypeVariables extension? I am not 100% sure I understand the question though.
04:27:40 <hpc> exicer: to take different things as arguments to a "testing function", make instances of Arbitrary - http://hackage.haskell.org/packages/archive/QuickCheck/2.6/doc/html/Test-QuickCheck.html#g:7
04:27:43 <flux> wouldn't it make sense to do 100 _different_ tests :-)
04:27:44 <byorgey> kloplop321: perhaps you can give an example?
04:27:52 <hpc> exicer: use the source to see how that works
04:27:57 <kloplop321> byorgey: one moment.
04:28:05 <donri> is there a way to see the "computed unfolding size" of some code, ie. that which controls automatic inlining?
04:28:05 <exicer> Huh, okay
04:28:06 <exicer> hpc: Ah, okay
04:29:17 <exicer> hpc: That actually makes sense
04:29:20 <Peaker> I wish QuickCheck's "Gen"/arbitrary stuff was separated to its own package.  It's much nicer than System.Random
04:29:43 <hpc> Peaker: despite not being random ;)
04:29:47 <donri> Peaker: i wish they'd merge the generics branch already!
04:30:14 <Peaker> hpc, well, ok :) I want the API of System.Random to be more like QuickCheck's Gen
04:30:49 <hpc> wait, i am wrong; Gen is random
04:31:02 <hpc> or, kind of
04:31:04 <hpc> choose :: Random a => (a, a) -> Gen a
04:32:17 <kloplop321> byorgey: https://gist.github.com/kloplop321/6240143
04:33:23 <kloplop321> Where an instance implements that someConstant like `someConstant _ = Whatever { ... }`
04:38:15 <merijn> kloplop321: This looks like a typeclass that can be trivially replaced with just some normal higher order functions
04:38:43 <jonkri> I have a Map, and I want to generate a random value (using an IO calculation) and use it as a key for the map only if the key does not already exists. If the key exists, I want to start over, by generating a new value. What would be an elegant way of doing this?
04:39:00 <kloplop321> merijn: Perhaps, it would be nice to know how exactly. I'd like the constant to travel with the specific type.
04:40:33 <merijn> kloplop321: Is "someConstant" the same for all values a?
04:40:42 <kloplop321> No. It is different per type.
04:40:52 <merijn> kloplop321: Yeah, but within in a type it's he same, right?
04:40:52 <kloplop321> It is the same type of constant, but the value is different.
04:40:56 <kloplop321> Yes.
04:41:25 <kloplop321> Given a Potato, that constant will be the same for all Potato's
04:41:56 <jonkri> Okay, I don't need elegant. As long as the solution is not ugly, I'm okay. :-)
04:42:19 <merijn> actually, I don't think there's enough specifics here to figure out what you want
04:43:20 <kloplop321> merijn: I could do this easily with template specialization in C++, it is the type that matters, not the value.
04:47:09 <tim_> http://pastebin.com/iz6yWnJu
04:47:16 <mauke> The paste iz6yWnJu has been copied to http://lpaste.net/91860
04:47:25 <tim_> Could not deduce (c ~ [Complex c])
04:47:25 <tim_>     from the context (Integral i, RealFloat c)
04:47:25 <tim_>       bound by the type signature for
04:47:26 <tim_>                  rk4
04:47:56 <tim_> why 'could not deduce' in the rk4 function?
04:48:36 <tim_> rk4 should take a function of the type defined above
04:48:47 <tim_> as well as a number and a matrix
04:58:14 <merijn> kloplop321: Oh, there's plenty of ways to do it, I'm just not convinced which one is the right approach, since your problem description is too vague
04:59:48 <kloplop321> Hmm.. I have an idea.
05:02:26 <hape02> I have no clue  ---  is it:   I have (no clue)     or  (I have no) clue     ?
05:02:48 <hape02> I prefer (I have no) clue
05:03:11 <hape02> Saying:     I have no $ clue
05:05:30 <kloplop321> merijn: I am pretty sure it should work out if I was able to, from a default implementation, get the current type signature of the type instance.
05:05:44 * hackagebot uri 0.1.6.2 - Library for working with URIs  http://hackage.haskell.org/package/uri-0.1.6.2 (JaroslavGridin)
05:13:32 <kloplop321> merijn: Here's my current example, with all the types mocked out and the functions involved. http://lpaste.net/91862 Simply, I want to specify the type signature of the current type instance, such that I have access to the non-default `session` function.
05:13:56 <kloplop321> If you replace "ses" with undefined, it'll compile, so it is a matter of just getting that one type right.
05:18:22 <romm> by "current" you mean Storable in your example?
05:24:12 <twoolie> hi all, who would I speak to about submitting patches to parsec?
05:24:19 <kloplop321> romm, Yes, suppose `instance Storable Tacos where` and `session _ = def { stuffSet = "Whatever" } ` I want it so that within the get function, it can call Tacos's session to get the effective constant, using the type to select the right function.
05:26:25 <kloplop321> http://lpaste.net/91863 This is a simplified example (which seems to be compile-able.)
05:27:02 <jonkri_> twoolie: How about the maintainer? <http://hackage.haskell.org/package/parsec-3.1.3>
05:27:48 <hpaste> supki annotated “No title” with “No title (annotation)” at http://lpaste.net/91862#a91864
05:27:55 <supki> kloplop321: like that?
05:28:20 <supki> I'm not sure I understand why you passing undefined though
05:28:51 <kloplop321> Because the details don't matter as much as the types and correct resolution of the current type.
05:29:02 <supki> I suggest using Proxy then
05:29:06 <supki> @hackage tagged
05:29:06 <lambdabot> http://hackage.haskell.org/package/tagged
05:29:07 <kloplop321> Proxy?
05:29:18 <supki> data Proxy s = Proxy
05:29:27 <kloplop321> Yes, a "Phantom Type" is what I am looking for.
05:29:29 <kloplop321> To match to.
05:30:01 <supki> that way session would be :: Proxy a -> KVStoreSession
05:30:06 <supki> and you can avoid undefined
05:30:21 <kloplop321> I'm just doing this for example sake.
05:30:38 <kloplop321> in reality it would be setting things on top of the defaults for KVStoreSession
05:32:50 <twoolie> jonkri_: thanks, I've tracked down an email addy for him.
05:41:03 <luite> is it possible with test-suite to list the failed tests at the end of a run?
05:41:38 <romm> kloplop321, i'm pretty new, so i might misunderstand you, but shouldn't 'session x' run the session implementation of the Storable instance anyway?
05:41:45 <hpaste> kloplop321 pasted “self type problem” at http://lpaste.net/91865
05:42:34 <kloplop321> romm: yes, that's the point
05:42:54 <romm> and you don't want it do that, yes?
05:43:00 <kloplop321> I do..
05:43:10 <kloplop321> romm: but making it select the right instance is the problem, how do I get the instance's type from within a default implementation?
05:44:01 <romm> why do you need it? what's wrong with 'ses = session' ?
05:44:27 <romm> it should infer the type from the parameter you pass to it, no?
05:44:28 <kloplop321> because I'm not passing the value in, I just want to get a constant (per the instance) out.
05:44:37 <kloplop321> It says it is ambiguous.
05:44:47 <kloplop321> Because it wouldn't know what instance to select.
05:45:12 <romm> but session receives a parameter
05:45:46 <kloplop321> The parameter has no meaning, it is merely the type, since a typeclass must have the relevant type (in this case Storable a, so a) in everything.
05:45:46 <romm> (if i'm boring you tell me to stop... i just found a good opportunity to learn :) )
05:46:33 <kloplop321> You aren't boring me, romm, I am new too.
05:50:32 <supki> kloplop321: wait, didn't my annotation work for you?
05:51:24 <jonkri_> What should I do if I find myself needing two keys for my Map? :-P
05:51:43 <kloplop321> supki: OH! I didn't see that you added {-# LANGUAGE ScopedTypeVariables #-}, so I didn't try it :/
05:51:57 <kloplop321> Thank you supki
05:52:21 <supki> :)
05:52:31 <kloplop321> I really appreciate it! Now to read the docs for the implications of it.
05:54:07 <kloplop321> supki: and my original sources compile now!
05:55:34 <jonkri_> Ah, I just found IxSet.
05:57:30 <Kaini2> Is there a sortBy that works with Maybe - I am looking for something similar to (a -> a -> f Ordering) -> [a] -> f [a]
05:57:42 <donri> jonkri_: see also data-store and tables
05:58:38 <jonkri_> donri: Thanks! I'm going to use it with acid-state.
05:58:46 <donri> @hoogle (a -> a -> f Ordering) -> [a] -> f [a]
05:58:46 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
05:58:46 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
05:58:46 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
05:59:10 <donri> jonkri_: they all include safecopy instances
06:02:30 <jonkri_> donri: Which one would you spontaneously recommend for the general case? :->
06:07:25 <donri> jonkri_: maybe data-store which is the only one i have yet to try myself ;)
06:07:47 <merijn> jonkri_: What's your use case?
06:08:06 <donri> jonkri_: ixset is the slowest and least type safe but the most mature and convenient to use [until you need a lens for it]
06:08:52 <jonkri_> donri: ;-)
06:08:52 <merijn> I would argue that if you want acid-state, you probably don't want IxSet and if you want IxSet, your probably don't want acid-state
06:08:59 <jonkri_> merijn: A simple one right now. I basically want to have a "Map" with two keys, and be able to look up elements based on either key. The elements themselves is just a record.
06:10:05 <donri> jonkri_: tables has a nice lens api but is currently buggy and requires quite a bit of boilerplate (though so does data-store, but perhaps a bit less)
06:10:07 <merijn> jonkri_: Sounds more of use case for using a key value store like Berkeley DB
06:10:41 <donri> does bdb give you multiple keys / indexing?
06:11:01 <merijn> donri: If you want that, you probably want an SQL database (SQLite?)
06:11:17 <merijn> donri: berkeley DB should index yes, else it'd be a pretty crappy database
06:11:51 <merijn> Using acid-state as a key value store combines the worst of both worlds
06:12:25 <donri> not necessarily
06:12:43 <merijn> donri: How so?
06:13:26 <merijn> I would argue the worst limitation of key value stores is that they're key value stores (i.e. they can only deal with key value pairs) and the worst limitation of acid-state is that everything has to fit in memory
06:13:36 <donri> well you basically get redis with zero setup, no latency imposing network layer and rich types and get to write your queries in haskell (e.g. with lens)
06:13:51 <merijn> donri: Who said anything about redis?
06:14:07 <merijn> If we're talking no setup localhost key value stores the first response should be bdb
06:15:03 <merijn> A proper key value database like bdb lets you grow as big as your disk allows (i.e. only limitation is the key-value bit) and just acid-state lets you persist arbitrary haskell heap-objects
06:15:21 <merijn> (at the cost of always needing to fit in memory)
06:15:34 <merijn> There doesn't seem to be a compelling reason to try to do the former using the latter
06:16:15 <donri> AFAIK bdb is just a Map on disk, there's no multiple keys or indexing. you'd have to manage that yourself, ie. reimplement ixset et all and with disk access times.
06:16:17 <quicksilver> mostly I agree with merijn but you missed of the transactional point
06:16:31 <quicksilver> sqlite and acid-state are both transactional
06:16:45 <quicksilver> which is a good thing for certain use cases
06:16:47 <merijn> quicksilver: bdb supports transactions, I thought
06:16:56 <merijn> quicksilver: It does, I just checked
06:17:07 <quicksilver> oh, fancy that
06:17:08 <quicksilver> :)
06:17:11 <quicksilver> live and learn.
06:17:28 <donri> as you say it's just key-value pairs; there's no support for having keys computed from the values transparently
06:18:01 <merijn> I'm sure there is a proper embeddable key value store for that too
06:18:41 <jonkri_> I want both to use native Haskell data types and storing them in RAM.
06:19:50 <jonkri_> Maybe I should rethink my design, and find a way to get rid of the two keys. What are the options for indexing things in acid-state except [(a, b)] lists and Maps?
06:20:41 <jonkri_> I mean, how is it usually done?
06:21:07 <jonkri_> By the way: How can the documentation for BerkeleyDB say "It is not free for commercial use."?
06:21:57 <merijn> jonkri_: Why couldn't it say that?
06:22:03 <donri> jonkri_: it's "usually" done with ixset because the other two are quite new
06:22:17 <donri> merijn: it also says BSD3
06:22:46 <jonkri_> merijn: Because the bindings are BSD, and Berkeley DB is AGPL.
06:22:47 <merijn> donri: You mean haskell bindings or bdb itself
06:23:02 <donri> i mean the page for that package on hackage
06:23:09 <donri> i don't know what *they* mean
06:23:21 <merijn> You'd have to ask the authors, I guess
06:23:30 <jonkri_> They probably consider AGPLv3 not to be "free for commercial use".
06:23:49 <donri> that's debatable though
06:24:03 <jonkri_> donri: Let's not. :->
06:24:12 <merijn> Berkeley DB AGPL? That sounds very unlikely
06:24:21 <jonkri_> merijn: Since Oracle, I suspect.
06:24:27 <donri> https://en.wikipedia.org/wiki/Berkeley_DB#Licensing
06:24:33 <merijn> dbd used to be the Sleepycat License
06:24:58 <jonkri_> As of Berkeley DB release 6.0, the Oracle Corporation has relicensed Berkeley DB under the GNU AGPL v3.
06:25:25 <merijn> Yeah, I saw
06:25:28 <Kinnison> buh
06:25:30 <merijn> Oh well, no bdb then
06:25:35 <merijn> (for me)
06:25:37 <jonkri_> "As of July 2011, Oracle's list price for commercial Berkeley DB licenses varies between 900 and 13,800 USD per processor."
06:25:46 <jonkri_> Say what you will about Oracle, but they do know how to make money. :-P
06:25:54 <tikhon> they have *absurd* margins
06:27:38 <quicksilver> merijn: well you can still use the sleepycat version under its license.
06:28:13 <quicksilver> jonkri_: yes, oracle quoted us over 250KGBP/year to replace our use of postgres.
06:28:19 <quicksilver> we declined that kind offer.
06:28:43 <merijn> quicksilver: :)
06:29:07 <donri> what's a good alternative to bdb then?
06:30:12 <quicksilver> the last version licensed under not-AGPL, donri, was still a good db
06:30:27 <quicksilver> (if AGPL is indeed a problem for your intended use)
06:30:46 <tikhon> and the AGPL doesn't *necessarily* have to be a problem
06:30:58 <quicksilver> right. no problem at all for lots of people.
06:31:45 <donri> quite. i'm torn on the whole copyleft issue myself. i kind of feel all [public] software should be free, but i also feel i don't have the right to require it. :p
06:32:15 <tikhon> idiologically, I'm all for the (A)GPL, but I'm too easily cowed to use BSD :/
06:32:17 <merijn> donri: Well, I tend to think GPL for applications, BSD for libraries
06:32:39 <tikhon> merijn: yeah, that's a good rule. Or maybe LGPL?
06:32:40 <donri> also we're probably getting off-topic here
06:32:58 <merijn> donri: On the off chance my GPL application becomes really popular I might want to dual license it for money, which means all libraries I use in it should allow that
06:33:20 <tikhon> given that a bunch of people here publish packages on Hackage, it's a reasonable topic
06:33:42 <merijn> Given that no one is asking haskell questions anyway, I think this is on topic enough
06:34:17 <tikhon> and license preference is an important thing for the community to work out
06:34:36 <donri> merijn: well i'm basically anti-copyright in ideology, so both copyleft and proprietary seem "unethical" to me
06:34:36 <merijn> Well, so far the majority seems to prefer BSD
06:34:37 <tikhon> Haskell people do tend to gravitate towards BSD-style licenses, I think
06:35:03 <tikhon> donri: it's hard to say because, in a very practical sense, the GPL is like anti-copyright
06:35:23 <maurer> tikhon: Hm? The creator still has the ability to license it under other licenses
06:35:31 <merijn> Moderately relevant: http://packdeps.haskellers.com/licenses
06:35:34 <donri> tikhon: gpl relies *heavily* on copyright, it would never work without it
06:35:38 <maurer> tikhon: It isn't really anti-copyright at all
06:35:44 <tikhon> right, but that's an implementation detail
06:36:12 * hackagebot sequor 0.3.2 - A sequence labeler based on Collins's sequence perceptron.  http://hackage.haskell.org/package/sequor-0.3.2 (GrzegorzChrupala)
06:36:14 <quicksilver> I believe the party line is "we would rather copyright didn't exist (for computer software) but since it does, we've decided to twist it round to work for us"
06:36:17 <tikhon> the idea is that not only do you ensure everyone can use your software (ie not taking advantage of copyright law to limit it), you also ensure nobody *else* can take advantage of copyright
06:36:35 * geekosaur notes that sqlite appears to be truly PD
06:36:46 <merijn> geekosaur: It is
06:36:50 <donri> quicksilver: i think stallman is in favor of [some] copyright to make gpl possible, arguing that no copyright would lead to source code kept "secret" rather than "copyrighted"
06:37:09 <merijn> Right, I think *this* is starting to go off topic
06:37:13 <tikhon> donri: I'm sure he wouldn't mind just mandating all software be shared, without any broader notion of copyright
06:37:25 <merijn> Because now we're talking politics, rather than technical details of licenses
06:37:42 <donri> tikhon: well such a mandate would be comparable to copyright and thus "unethical" in my view :)
06:37:46 <donri> yeah
06:38:35 <quicksilver> donri: he has said the contrary, but, human beings are not always consistent :)
06:49:58 <arnsholt> Are weird things prone to happen if some of the elements in my UArray are undefined?
06:51:08 <geekosaur> if anything tries to evaluate an undefined element, you'll get an exception
06:51:17 <geekosaur> just traversing the spine is fine
06:51:28 <quicksilver> UArrays should inevitably evaluate, surely?
06:51:41 <geekosaur> oh, hm, right. *U*array
06:51:44 <quicksilver> they're unboxed, they can't store thunks
06:52:06 <geekosaur> so yes, you have potential issues as it's not trappable bottoms
07:16:33 <arnsholt> Hmm. Somehow I managed to get my program to loop infinitely (outputting the <<loop>> thing) but the only thing that was supposed to change was some arrays going from Array to UArray
07:16:58 <arnsholt> Which sounds like it shouldn't happen
07:17:47 <hape02> UArray's are "strict in its elements"
07:17:49 <applicative> Array is lazy; UArray ultra strict
07:18:58 <arnsholt> Hmm. I guess maybe it uncovered an unevaluated infinite loop in my program
07:19:40 <hape02> arnsholt: lpaste.net/new/haskell it here?
07:19:45 <applicative> these are frequently sensible with Array, same as with list, no?
07:21:37 <arnsholt> hape02: It's a big pile of stuff, sec
07:25:23 <tero-> I'd like to have a Data.Aeson.FromJSON instance for an algebraic data type where one field can be either Text or an Int. any tips?
07:25:59 <hpaste> arnsholt pasted “UArray / IArray” at http://lpaste.net/91868
07:26:13 * hackagebot Commando 1.0.0.0 - Watch some files; Rerun a command  http://hackage.haskell.org/package/Commando-1.0.0.0 (LyndonMaydwell)
07:26:19 <arnsholt> That's the relevant files, catted into one chunk
07:26:27 <arnsholt> Last bit isn't haskell, but input
07:26:47 <arnsholt> (I've omitted the test bits from the first file, for brevity's sake)
07:27:35 <tero-> maybe I need to write a custom parser. It doesn't seem to be possible with .:? operator
07:28:47 <applicative> is allPairs the trouble?
07:28:59 <hape02> arnsholt: Is it for sure that "doStuff" happens before handle is closed by "withFile" in:   main = getArgs >>= (\(file:_) -> withFile file ReadMode doStuff)   ?
07:30:54 <arnsholt> It worked before I put in the UArray bits, at least
07:31:11 <arnsholt> applicative: I'm not sure. Either allPairs or the actual distance computation
07:33:28 <applicative> are you using only one dimensional arrays?
07:33:47 <applicative> no i see a 2 d uarray
07:34:46 <arnsholt> Yeah, the main distance computation is mainly 2D stuff
07:34:57 <hape02> arnsholt: http://stackoverflow.com/questions/9406463/withfile-vs-openfile
07:35:36 <hape02> withFile is dangerous...
07:35:53 <applicative> is the problem really io, though hape02 ? or maybe i'm not following
07:36:12 <arnsholt> I'm pretty sure that's not it
07:36:17 <hape02> I guess the file is not read completely when the handle is closed by exiting withFIle
07:36:36 <arnsholt> No, that part worked before I put in the UArrays
07:36:39 <applicative> arnsholt: did something like this work with just Array and now you have added UArray
07:36:41 <applicative> oh
07:36:44 <hape02> race conditions
07:36:58 <arnsholt> (Although I did have the "why is there no output" problem previously =)
07:37:11 <applicative> somewhere your array reasoning was relying on laziness, sensibly enough.
07:37:33 <arnsholt> Oooooh, right
07:37:49 <applicative> i remember this happening to me the first time I used something like UArray; there was some typically haskelly move that defeated me ...
07:38:34 <arnsholt> Building elements of a strict immutable array based on previous elements might not work like I expected it to, does it?
07:38:44 <applicative> exactly
07:38:48 <hape02> in my opinion, withFile and Lazy IO cant work if the doStuff function is placed externally (not in the withFIle expression)
07:39:45 <applicative> arnsholt: if you build a (finite!) Array then you can morph it into a UArray, given suitable types
07:40:09 <arnsholt> Oh, goody. That'd probably do the trick
07:40:16 <applicative> this just requires the Array to be completely evaluated
07:40:34 <applicative> but doing the same with UArray requires it to be completely evaluated before it is produced at all
07:40:55 <arnsholt> That can probably be arranged. The things I'm working with are parses of natural language sentences, so everything's finite =)
07:41:01 <int80_h> there's a lookup function with a type "a -> [(a,b)] -> b -> b" where a default value is supplied if there's no match. It's not in Data.List and hoogles not helping.Anyone know the name and package it's in?
07:41:49 <arnsholt> What's the trick to coercing a plain Array to UArray?
07:42:13 <luite> they have a different representation, so you'd have to copy
07:42:28 <applicative> http://hackage.haskell.org/packages/archive/safe/0.3.3/doc/html/Safe.html lookupJustDef
07:42:41 <applicative> int80_h: ^^ for example?
07:43:03 <merijn> hape02: No, withFile is the opposite of dangerous
07:43:09 <merijn> hape02: openFile is the dangerous one
07:43:22 <merijn> hape02: openFile leaks filedescriptors/handles in case of exception
07:44:01 <applicative> arnsholt: oh yes, it would be copying as luite says; i was thinking first get it working, then reason how to make it better presupposing most calculations are in UArray
07:45:04 <hape02> merijn: withFile and Lazy/IO is not a problem?
07:45:44 <int80_h> applicative: That looks right. Thanks :)
07:45:59 <hape02> merijn: I  followed the intentions in http://stackoverflow.com/questions/9406463/withfile-vs-openfile
07:46:31 <arnsholt> Right. Thanks for the help folks! Hopefully this'll let me fix it tomorrow morning =)
07:46:46 <merijn> hape02: Lazy IO is a problem, that's a separate issue from withFile
07:47:05 <merijn> hape02: If you don't use lazy IO withFile works just fine
07:49:44 <hape02> merijn: I agree.  But the problem mentioned by arnsholt  was in a source code combining withFile and lazy IO  (hGetContents)
08:01:23 <n-dolio> If you don't use withFile, lazy I/O works fine.
08:03:10 * applicative can count on n-dolio to get these priorities right
08:05:37 * applicative is in a laziness-defending mood, looking at the redditors' objections to Data.HashMap.Strict
08:09:10 <kryft> Are there lots of differences between the latest parsec and whatever version was used in chapter 16 of RWH?
08:09:52 <applicative> kryft: no, but the types are different so this leads to oddities
08:10:16 <applicative> kryft: the modules with the same names Text.ParserCombinators.Parsec.Blah have the same 'api'
08:10:23 <applicative> but underneath, things changed.
08:11:22 <kryft> applicative: Hmm, ok. Are there any good tutorials that use the latest version?
08:11:33 <applicative> kryft: if types are not specified yet, one often does well to use a {-#LANGUAGE NoMonomorphismRestriction#-} flag with Parsec3
08:11:41 <coltfred> I'm working through tony morris's course and I can't quite work out why the type of the partially applied "traaverse" is what it is.  The function definition is traaverse :: Moonad m => (a -> m b) -> [a] -> m [b] and traaverse (*) yields traaverse (*) :: Num b => [b] -> b -> [b].  Why?
08:12:06 <coltfred> For reference, this is the haskell file I'm working off of https://github.com/tonymorris/course/blob/master/src/Monad/Moonad.hs
08:12:46 <kier> coltfred: traverse is like a generalisation of mapM from lists to any functor, if that helps
08:12:55 <applicative> kryft: once you figure out a couple things like adding sec3
08:13:09 <applicative>  everything will compile fine
08:13:17 <applicative> adding {-#LANGUAGE NoMonomorphismRestriction#-}
08:13:20 <applicative> i mean
08:13:48 <kryft> Ok, thanks
08:14:09 <coltfred> kier: my confusion comes in because (*) is of type a -> a -> a and the first param of traaverse is a -> m b
08:14:25 <arkeet> yes, so set a = m b
08:14:48 <applicative> set a -> b for m b you mean?
08:14:57 <flebron> Hi. What exercises would you ask a student to test if he understands the concepts of evaluation order and currying? They have not yet learned recursion. The ones I thought were 1) To give functions f, g such that (f . g) is always bottom, and (g . f) is never bottom, 2) To say what happens in head [1, undefined], head [undefined, 1], and (\[x] -> 1) [undefined], and 3) To say what happens in length [1..]. For currying, I've thought of asking for an
08:14:57 <flebron>  adding function, for (.), and (flip (.)). Any other interesting examples?
08:15:04 <arkeet> :t traverse `asAppliedTo` (*)
08:15:04 <lambdabot> (Num a, Traversable t) => (a -> a -> a) -> t a -> a -> t a
08:15:22 <arkeet> :t mapM `asAppliedTo` (*)
08:15:23 <lambdabot> Num a => (a -> a -> a) -> [a] -> a -> [a]
08:15:30 <arkeet> :t mapM
08:15:32 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
08:15:41 <arkeet> oh yeah, set m b = a -> a
08:15:55 <kier> so the m in this case is ((->) a)?
08:15:58 <arkeet> yes
08:16:09 <applicative> i see, b has to be a , m has to be a -> , so to speak
08:16:13 <applicative> kier: exactly
08:16:32 <applicative> the 'reader monad', without the newtype wrappers
08:17:44 <coltfred> the m is bound to a single monad instance inside a function definition correct?
08:18:13 <coltfred> so once m is a -> that's what it is in all instances of m in that function definition?
08:18:37 <arkeet> yes, m is a single thing.
08:19:25 <applicative> (->) Int  and (->) Char are totally different monads.
08:19:41 <arkeet> :t flip . fmap fmap . flip
08:19:41 <lambdabot> Functor f => (a1 -> a -> c) -> f a1 -> a -> f c
08:19:54 <arkeet> is this the same, I wonder
08:19:54 * applicative hadn't known 'asAppliedTo'
08:20:12 <applicative> asAppliedTo f x = let _ = f x in f
08:20:27 <arkeet> aka const
08:20:32 <arkeet> :t asAppliedTo
08:20:33 <lambdabot> (a -> b) -> a -> a -> b
08:21:28 <applicative> @type const traverse (*)
08:21:28 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:21:52 <arkeet> well of course it's a type-restricted const.
08:22:10 <applicative> yes
08:23:00 <applicative> @type (const :: (a -> b) -> a -> a -> b) traverse (*)
08:23:01 <lambdabot> (Num a, Traversable t) => (a -> a -> a) -> t a -> a -> t a
08:23:51 <applicative> well, not too surprising its hard to get any information out of const
08:24:49 <notdan> What's the correct and safe way to convert a string to a ByteString?
08:24:59 <coltfred> So traaverse (*) is partially applying (*) returning a -> a for m b.  Can I then say the m [b] should be a -> [a]?  If so how does the return value become traaverse (*) :: Num b => [b] -> b -> [b]?
08:25:01 <notdan> Something like encodeUtf8 for regular Strings maybe?
08:25:48 <coltfred> Sorry that I keep going back to my slightly diff definition of traaverse... I'm just trying to ensure I have my head wrapped around why exactly the application yields what it does.
08:28:27 <applicative> notdan: isn't it just T.encodeUtf8 . T.pack
08:28:59 <notdan> yeah but doesn't it has additional complexity to it?
08:29:23 * applicative looks up to see if they might fuse. it seems a little unlikely
08:30:47 <applicative> naw, oh well.
08:31:11 <quicksilver> if converting Strings to Bytestring via Text is a CPU bottleneck in your real life program
08:31:20 <quicksilver> than maybe using Strings in the first place was a mistake.
08:31:27 <quicksilver> if it isn't, then why do we even care? :)
08:32:24 <applicative> maybe a bytestring builder
08:32:26 <Franciman> People, to you how should M... get lexed ? Ghc says like three tokens M . and .. But according to the "maximum munch" rule ... is longer so it should be lexed as: M and ...
08:32:38 <Franciman> what you think?
08:32:48 <applicative>  stringUtf8 :: String -> Builder
08:35:34 <applicative> toLazyByteString . stringUtf8 :: String -> L.ByteString
08:35:39 <notdan> quicksilver: I am using functions that operate on strings, unfortunately. Like 'showElement' from Text.XML.Light
08:35:54 <applicative> notdan: I think that must be the way to go ^^
08:36:12 <notdan> hm, bytestring-builder, I didn't know about that package
08:36:15 <notdan> thanks
08:36:24 <applicative> notdan: no its in ByteString now
08:36:45 <applicative> if you have 0.10, which is the platform version
08:36:52 <notdan> o ok
08:36:55 <notdan> yeah, thx
08:36:58 <notdan> will try that now
08:37:11 <applicative> it has a lot of cool stuff
08:57:29 <kuribas> Is there any performance difference in using helper functions, versus a direct formula?  For example: "vectorDistance p q = vectorLength (subVector p q)" instead of "vectorDistance (Point x1 y1) (Point x2 y2) = sqrt((x2-x1)^2 + (y2-y1)^2)"
08:58:06 <ParahSailin> its the same
08:58:09 <tikhon> it depends, but I really doubt there would be a difference: GHC is very good at inlining
08:58:26 <kuribas> I prefer the former because it's clearer.
08:58:46 <tikhon> I would even have an opeartor for subVector
09:00:07 <kuribas> like?
09:00:10 <danr> kuribas: generally, non-recursive functions that are not huge will be inlined if they are fully applied
09:00:10 <applicative> ><
09:00:27 <kuribas> I see.
09:00:48 <Kaini> I just pasted http://lpaste.net/91869 - I think that "content" is _really_ ugly. Any ideas?
09:01:06 <Philippa> kuribas: GHC is free to inline pure functions as much as it likes, so long as it eventually stops doing so :-) So what danr said
09:01:39 <Philippa> (also, this is a case where the sometimes nuanced meanings of 'pure' want stripping away: pure-to-GHC, even if it happens to be some monad's >>=)
09:01:47 <kuribas> Does lazyness make a difference for inlining?
09:01:55 <Philippa> laziness makes inlining easier, yeah
09:02:09 <danr> Kaini: mapM (fmap parseRow . columns) children ?
09:02:09 <Philippa> GHC doesn't have to check whether the parameters would terminate before inlining
09:02:17 <kuribas> ah :)
09:02:58 <Philippa> (rather: terminate /or/ necessarily be demanded)
09:03:34 <danr> Kaini: uh doesn't quite type-check it seems :) it would probably help to spell out the types for the where-bound identifiers here
09:03:37 <Kaini> danr, sorry, this doesn't work (I can paste you the error if you want me to) - I think the problem is, that columns is Maybe as well
09:05:23 <hpaste> Kaini revised “This is so ugly (Line 11)”: “No title” at http://lpaste.net/91869
09:06:11 <Kaini> I've added the types
09:06:49 <ParahSailin> flip parseRow children :: [String] -> Maybe [String]
09:07:12 <ParahSailin> erm no
09:07:36 <kuribas> I could use (->+) for vector addition, but I am not sure it's clearer...
09:08:35 <ParahSailin> map (flip parseRow) children :: [[String]] -> [Maybe [String]]
09:09:48 <Kaini> ParahSailin, let me try this out - nice idea
09:09:51 <quicksilver> I like ^+^ for vector addition, kuribas
09:09:59 <quicksilver> and *^ for scalar/vector multiply
09:10:07 <quicksilver> the ^s remind me on which side I find vectors
09:10:22 <kuribas> Yeah
09:11:02 <quicksilver> and as a bonus, your entire source tree can be reinterpreted as a very happy/surprised story using emoticons
09:11:07 <quicksilver> that's a big win.
09:11:14 <kuribas> :)
09:12:22 <ParahSailin> @src Num
09:12:22 <lambdabot> class  (Eq a, Show a) => Num a  where
09:12:22 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:12:22 <lambdabot>     negate, abs, signum     :: a -> a
09:12:22 <lambdabot>     fromInteger             :: Integer -> a
09:12:25 <kuribas> quicksilver: dotproduct would be (^.^)
09:12:43 <quicksilver> yes
09:13:01 <quicksilver> ^*^ could be cross or tensor, depending what you're doing perhaps.
09:13:20 <Work_jack> I would support that
09:13:24 <kuribas> Just simple 2D geometry.
09:13:35 <kuribas> Basicly a support library for my cubicbezier functions.
09:14:05 <tikhon> Don't be afraid of Unicode: you can use ⊗
09:14:16 <Work_jack> > let (<^-^<) = (*) in 5 * 10
09:14:17 <lambdabot>   50
09:14:28 <kuribas> ^||^ distance?
09:14:58 <quicksilver> well I just used norm(a ^-^ b)
09:15:00 <quicksilver> but you could do
09:22:05 <Hafydd> <(^-^<) (>^-^>) <(^-^<) (>^-^>)
09:22:32 <bergmark> Kaini: sequence =<< ($ children) <$> (<$>) <$> parseRow <$> columns
09:23:40 <yitz> bergmark: my first reaction to that was "ouch". but actually it makes sense when you look at it more closely
09:24:05 <bergmark> well it makes sense in the sense that it typechecks :)~
09:24:10 <yitz> haha
09:24:27 <ParahSailin> did you make that monstrosity with @pl?
09:24:40 <Work_jack> That symbol-to-code ratio is too high for my taste
09:24:47 <Kaini> bergmark, wow
09:24:49 <yitz> bergmark: but then why not just:  sequence =<< ($ children) . (<$>) . parseRow <$> columns
09:25:06 <bergmark> we did it manually
09:25:19 <applicative> catMaybes [mapM pp children | pp <- parseRow <$> columns]
09:25:33 <ParahSailin> i think he wants sequence though, not catmaybes
09:25:49 <applicative> hm
09:25:52 <Kaini> I don't really care as long as it works and is not "ugly"
09:26:12 <yitz> Kaini: beauty is in the eyes of the beholder
09:26:21 * Philippa isn't keen on one-liners in parsing
09:26:32 <Philippa> I mean, if you have a one-liner spec it's pegged against, fair enough?
09:26:43 <ParahSailin> i would have gone wiht sequence =<< map (flip parseRow) children <$> content
09:27:33 <Kaini> ParahSailin, I tried this approach, but couldn't get it working
09:30:46 <Kaini> I think I'll use "sequence =<< ($ children) . () . parseRow  columns" - thank you all
09:31:08 <Kaini> sequence =<< ($ children) . () . parseRow  columns
09:31:27 <Kaini> Um, my client seems to cut < $ >
09:31:53 <bergmark> replace (<$>) with fmap ;)
09:52:46 <monochrom> new CCC http://ro-che.info/ccc/21.html  hahaha
10:03:43 <yitz> monochrom: it's actually been up for over a week. saw it on reddit.
10:04:13 <yitz> monochrom: from the reddit comments: "If I were to awaken after having slept for a thousand years, my first question would be: Has the Riemann hypothesis been proven?" - David Hilbert
10:17:58 <shepheb> is there a canonical best intro to quickcheck and HUnit?
10:20:24 <Work_jack> shepheb: http://www.cse.chalmers.se/edu/year/2012/course/TDA452/FPLectures/Vid/ this covers QuickCheck, but it's no the "canonical" introduction
10:23:33 <Work_jack> *it's not the
10:31:38 * hackagebot Rlang-QQ 0.0.0.0 - quasiquoter for inline-R code  http://hackage.haskell.org/package/Rlang-QQ-0.0.0.0 (AdamVogt)
10:36:38 * hackagebot llvm-general-pure 3.2.7.2 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.2.7.2 (BenjaminScarlet)
10:36:40 * hackagebot llvm-general-pure 3.3.7.2 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.7.2 (BenjaminScarlet)
10:36:42 * hackagebot llvm-general 3.2.7.2 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.7.2 (BenjaminScarlet)
10:36:44 * hackagebot llvm-general 3.3.7.2 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.7.2 (BenjaminScarlet)
10:41:41 <troydm> i've git cloned latest version of process module and i'm trying to compile and install it
10:42:05 <troydm> what's the standard procedure for doing that? this module has some cbits so i guess it contains C source that must be compiled
10:42:31 <c_wraith> troydm: cabal will take care of it
10:42:35 <Polarina> troydm, cabal configure && cabal build # should take care of it for you.
10:42:52 <troydm> tried it
10:42:54 <troydm> but i get
10:42:56 <troydm> config.status: error: cannot find input file: `include/HsProcessConfig.h.in'
10:43:05 <osa1> I can't use ZonedTime or UTCTime as field types in yesod's persistent framework, I'm getting "no instance for sql....." errors, any ideas? same code that is shown in yesod book doesn't work for me.
10:43:12 <troydm> i've cloned it from here https://github.com/ghc/packages-process
10:43:20 <troydm> so i guess it's latest source code
10:44:28 <Polarina> troydm, it seems that you need to run the configure script first.
10:45:17 <troydm> Polarina: i've tried running it but i still get same error
10:45:22 <Polarina> troydm, how did you invoke the configure script?
10:45:32 <troydm> Polarina: autoconf && ./configure
10:47:28 <Polarina> troydm, try autoreconf then ./configure
10:48:54 <troydm> Polarina: worked, thx
10:49:11 <Polarina> troydm, you're welcome.
10:49:56 <troydm> now i'm getting http://pastebin.com/WQb16yKc
10:50:05 <mauke> The paste WQb16yKc has been copied to http://lpaste.net/91872
10:50:18 <troydm> shouldn't this kind of error usually be fixed by now :)
10:55:32 <ReinH> Man, just as soon as I think I understand comonads, Edward tells me I should use representative functors. It's like walking up a down escalator...
10:55:42 <edwardk> representable =)
10:55:55 <ReinH> representable
10:56:02 <ReinH> edwardk: so I stared at that stuff for a few hours
10:56:07 <geekosaur> reprehensible!
10:56:11 <ReinH> edwardk: I think I sort of maybe get what's happening, but not really
10:56:23 <ReinH> edwardk: do you have any examples of their use?
10:56:24 <monochrom> it's a rabbit hole
10:56:38 * hackagebot Rlang-QQ 0.0.0.1 - quasiquoter for inline-R code  http://hackage.haskell.org/package/Rlang-QQ-0.0.0.1 (AdamVogt)
10:56:44 <ReinH> edwardk: I think I get the f a to x -> a isomorphism
10:57:07 <edwardk> ReinH: linear is more or less written by doing all of linear algebra that way
10:57:07 <Polarina> troydm, that issue should be fixed with newer versions of base. Foreign.unsafePerformIO is deprecated.
10:57:58 <troydm> Polarina: oic, so for tests i should do import Foreign hiding (unsafePerformIO) right?
10:58:04 <edwardk> i use the fact that (classically) every vector space is a free vector space, that is it has the form (e -> r) for some basis e, and then just say that if i can find a representable functor with representation e, then that functor is my vector space
10:58:32 <Polarina> troydm, that should work.
10:58:35 <edwardk> so then Complex a   is the vector space with the boolean basis, but wait, there's more!
10:58:49 <ReinH> edwardk: ok I think that made some sense
10:59:16 <edwardk> rather than have to make up some ADT for each basis, what i do instead is choose the lenses of a certain form as my representation/basis
11:00:36 <luite> is there a way to make test-framework print the failed tests at the end of a long run?
11:00:38 <edwardk> it turns out there is a one-to-one correspondence between elements in a polynomially representable functor  and lenses of the form (forall x. Lens' (f x) x)
11:00:50 <edwardk> that is to say the lens describes the paths into your structure
11:01:08 <edwardk> (forall a. Lens' (Complex a) a)   must either retrieve the real part or the imaginary part.
11:01:18 <edwardk> it doesn't know anything else about 'a' so it can't combine them
11:04:24 <edwardk> johnw: ping
11:04:57 <jonkri> Is there something like <http://hackage.haskell.org/packages/archive/containers/0.5.1.0/doc/html/Data-Tree.html>, but that doesn't have a label (like "rootLabel")?
11:05:44 <S11001001> Is the base trunk meant to be unbuildable with ghc 7.6.3?
11:05:44 <edwardk> johnw: feedback re school of haskell. it is great, but one thing i really miss is that there is no way to get feedback within the site. It is a broadcast only medium. If you guys could look into, even adding a simple checkbox to enable disqus  comments on a given tutorial, then I'd literally have no reason to maintain a separate blog
11:06:03 <donri> jonkri: [[a]]? :)
11:06:10 <donri> nowaitno
11:06:10 <jonkri> donri: Hm. :-)
11:06:29 <edwardk> johnw: right now all the comments i'm getting on my tutorial are spread out across twitter, reddit, etc.
11:06:30 <ReinH> edwardk: so you need a Representable f => f r where f has representation e, making it isomorphic to e -> r?
11:06:31 <S11001001> jonkri: do you want Free List then?
11:06:46 <edwardk> ReinH: yeah
11:07:32 <S11001001> jonkri: (whereas IIUC that Tree is Cofree List)
11:07:36 <jonkri> donri, S11001001: I have a structure like MyType { ..., children: [MyType] }
11:07:43 <edwardk> ReinH: the nice thing about the linear approach is that i can make lenses for _x, and _y   and they can be shared across all vector spaces i want to have those components by just making instances of the class that provides them
11:07:50 <edwardk> and then i need no extra basis
11:07:51 <S11001001> jonkri: the ... is the rootLabel
11:07:52 <ReinH> so some functor over the ring, in this case the ring (C, +, *) ?
11:07:54 <jonkri> And I guess I'm just thinking in general if there is some kind of collection type that I can use to make the structure nicer.
11:08:15 <edwardk> class R2 t where _x :: Lens' (t a) a; _y :: Lens' (t a) a
11:08:19 <jonkri> S11001001: Ah, but on the base level of my type I want [MyType], not MyType.
11:08:37 <edwardk> data V2 a = V2 a a; instance R2 V2 where _2 f (V2 a b) = V2 a <$> f b; ...
11:08:46 <edwardk> er where _y f (V2 a b)
11:08:51 <jonkri> Maybe I should have a "Forest a" there?
11:09:09 <ReinH> edwardk: where R2 means "has at least 2 degrees"?
11:09:19 <S11001001> jonkri: maybe
11:09:23 <edwardk> yeah
11:09:30 <jonkri> But that doesn't seem to nice, as my intention is to treat the data structure as a whole.
11:09:35 <edwardk> then R3 has R2 as a subclass
11:09:41 <raisdead> Is there a more consise method to write  `foldl (\total n -> if isNothing n then total + 1 else total) 0` other than `length . filter isNothing`?
11:09:47 <edwardk> so _x,_y  and _z, etc. can be shared across vector spaces
11:10:09 <edwardk> i figured this was a good example of representability being used in anger
11:10:20 <S11001001> jonkri: that's not an accurate characterization of your structure, though.  If the "root" of the tree doesn't have a label, then it's not like any of the other nodes.
11:10:29 <S11001001> type Forest a = [Tree a]
11:10:32 <edwardk> ReinH: acowley uses it to make robots fly and do motion planning really really fast
11:10:48 <ReinH> edwardk: heh
11:10:50 <nabilhassein> I cannot figure out how to use Data.Aeson or Text.JSON to parse something as simple as `msg = "{\"play\" : 1} :: Text` into a valid JSON object. Does anyone have advice?
11:10:50 <edwardk> http://www.youtube.com/watch?v=Zlt6EJVdUN8
11:11:11 <jonkri> S11001001: That's true. I think I'll try that. Thanks! :-)
11:11:40 <ReinH> edwardk: o_O
11:12:25 <edwardk> ReinH: the lab there has some frankly scary videos of formation flying quad-copters too
11:12:32 <ReinH> nice
11:12:35 <edwardk> and quadrotors with claws and stuff
11:12:45 <edwardk> i can see the man-hacks coming for me already
11:13:10 <edwardk> .. and I'm not as good with a pistol as Gordon Freeman ;)
11:14:35 <donri> nabilhassein: what do you mean by "JSON object"?
11:15:47 <donri> nabilhassein: aeson's generic representation is Value, and you can parse a bytestring into a Value using decode and a type signature
11:15:54 <nabilhassein> donri: really I have a custom data type I want to see if the JSON object has fields corresponding to. But currently I cannot even get my `msg` to be accepted as a valid input into any library's data types
11:16:12 <nabilhassein> donri: I can't use Text? I am using a Text-based version of the Websockets protocol
11:16:21 <nabilhassein> I am not sure binary will work. I ran into problems with it previously
11:16:45 <arkeet> I wish GHC could compile multiple modules in parallel. =(
11:17:40 <troydm> so i think i've ended up in cabal hell again http://pastebin.com/KY0pFvw4
11:17:40 <troydm> how do i resolve this?
11:17:40 <mauke> The paste KY0pFvw4 has been copied to http://lpaste.net/91873
11:17:41 <donri> nabilhassein: you'll either need to encodeUtf8 that Text into a ByteString, or use attoparsec directly yourself
11:17:41 <donri> arkeet: there's a gsoc for that this year
11:17:41 <arkeet> cool
11:17:41 <donri> well, two
11:17:52 <troydm> i've installed process-1.2.0.0 and now i want to reinstall yesod-bin module to use that version of process library
11:18:05 <hpaste> jam` pasted “can't make Block a Functor” at http://lpaste.net/91874
11:18:06 <troydm> but i'm getting this opt-applicative problem
11:18:06 <jchee> @djinn Maybe b -> MaybeT m b
11:18:15 <lambdabot> Error: Undefined type MaybeT
11:18:16 <Polarina> Why does my code always look so ugly when I look at it a year later?
11:18:34 <nabilhassein> donri: ah okay, i'll try encodeUtf8. that's much more roundabout than the `encode . show` stuff that I'm doing now, and that doesn't work
11:18:37 <donri> troydm: optparse requires process==1.1
11:18:44 <nabilhassein> donri: er, i meant less roundabout
11:18:49 <troydm> donri: doh :(
11:18:50 <donri> troydm: and, not a good idea to upgrade core/platform packages
11:19:08 <jam`> hey, can you help me with a wee tiny functor I'm trying to make?
11:19:09 <troydm> donri: i'm not upgrading, i'm trying to debug process package
11:19:33 <troydm> donri: i'm getting a weird error with createProcess method on my OpenIndiana installation
11:21:24 <mithsv> Why is unsafeLocalState so slow? An FFI call goes from 10ns to 90ns with it
11:21:51 <quchen> Is there a simple way of enabling antialiasing for Gloss? The internet (and their trac) suggests there isn't :-/
11:22:08 <troydm> donri: so first thing that came up to my mind is to install latest process library and see if problem persists there
11:22:45 <donri> troydm: process is a core library, it would be unwise to upgrade it without upgrading ghc
11:23:20 <nabilhassein> donri: encodeUtf8 returns a strict ByteString, whereas Data.Aeson's decode wants a lazy ByteString
11:23:35 <nabilhassein> I am sure I can use hoogle to find some library function to convert between them
11:23:40 <geekosaur> mithsv, locking I think?
11:23:47 <nabilhassein> but this just seems so strange. There's really no way to parse Text into JSON?
11:24:05 <troydm> donri: yeah, i understand that
11:24:54 <geekosaur> oh, hm, no, it's unsafeDupablePerformIO so it's not dealing with that lock
11:25:09 <donri> nabilhassein: Data.ByteString.Lazy.fromStrict
11:25:13 <geekosaur> still there are likely to be other locks involved
11:25:17 <monochrom> right, it's already faster than unsafePerformIO
11:25:50 <mithsv> i guess i'll just expose both IO and non-IO versions
11:28:16 <donri> nabilhassein: how are you getting Text over websockets? what library is that?
11:29:40 <nabilhassein> donri: thanks, your advice worked perfectly. I'm using this one: http://hackage.haskell.org/package/websockets
11:30:27 <raisdead> @pl g f x = f x x
11:30:30 <lambdabot> g = id (fix (const (flip ap id)))
11:30:30 <lambdabot> optimization suspended, use @pl-resume to continue.
11:31:02 <raisdead> @pl \g f x = f x x
11:31:03 <lambdabot> (line 1, column 8):
11:31:03 <lambdabot> unexpected "="
11:31:03 <lambdabot> expecting pattern or "->"
11:31:10 <donri> nabilhassein: according to that your Text data has to be utf-8 encoded, which is what aeson reads anyway, so it would be redundant to go via text. do you have to?
11:32:47 <arkeet> @pl \g f x -> f x x
11:32:50 <lambdabot> const (flip ap id)
11:32:51 <lambdabot> optimization suspended, use @pl-resume to continue.
11:32:54 <arkeet> @pl g f x = f x x
11:32:57 <lambdabot> g = id (fix (const (flip ap id)))
11:32:57 <lambdabot> optimization suspended, use @pl-resume to continue.
11:33:09 <arkeet> @pl-resume
11:33:15 <lambdabot> g = id (fix (const (flip ap id)))
11:33:15 <lambdabot> optimization suspended, use @pl-resume to continue.
11:33:16 <arkeet> can't it figure out that g = join?
11:33:21 <arkeet> =(
11:33:34 <arkeet> > join f x == f x x
11:33:35 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
11:33:35 <lambdabot>    arising from a us...
11:33:39 <arkeet> > join f x == (f x x :: Expr)
11:33:40 <lambdabot>   True
11:34:19 <enthropy> @pl g = \f x -> f x x
11:34:22 <lambdabot> g = id (fix (const (flip ap id)))
11:34:22 <lambdabot> optimization suspended, use @pl-resume to continue.
11:34:34 <enthropy> @pl g = \x f -> f x x
11:34:37 <lambdabot> g = id (fix (const (ap (flip . flip id) id)))
11:34:37 <lambdabot> optimization suspended, use @pl-resume to continue.
11:34:48 <geekosaur> it's even more broken than usual, I think
11:34:50 <raisdead> arkeet: Thanks I was looking for the name of join
11:35:02 <arkeet> @hoogle (a -> a -> b) -> a -> b
11:35:03 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
11:35:03 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
11:35:03 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
11:35:05 <arkeet> aw.
11:35:26 <tikhon> hoogle treats (->) specially, so it's easier to get confused
11:35:28 <nabilhassein> donri: i might not need to now, but previously, i was sending the data as binary and that made debugging a huge hassle because on the front end, 'console.log' printed out "Binary blob" and there was no way for me to look inside to see what bytes were being sent over the wire
11:35:37 <arkeet> @pl m (m b) -> m b
11:35:37 <lambdabot> (line 1, column 11):
11:35:37 <lambdabot> unexpected '>'
11:35:37 <lambdabot> expecting operator
11:35:41 <arkeet> @hoogle m (m b) -> m b
11:35:41 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
11:35:41 <lambdabot> Test.QuickCheck.Property joinRose :: Rose (Rose a) -> Rose a
11:35:41 <lambdabot> Prelude concat :: [[a]] -> [a]
11:35:41 <tikhon> this also makes finding some of the arrow functions specialized to (->) more difficult
11:36:08 <arkeet> tikhon: yeah =(
11:36:08 <nabilhassein> donri: now that i've fixed that bug, perhaps i can simply send as binary and everything will work. But I'll probably finish debugging everything in terms of Text first, and look into using ByteStrings later
11:41:04 <mkramer> How does Haskell handle types that can be an an instance of a typeclass in more than one way? For instance, Int is a monoid over (+) and (*)
11:41:16 <tikhon> we create newtypes for it
11:41:17 <c_wraith> mkramer: you can only have one instance for a type
11:41:20 <tikhon> ie Sum and Product
11:41:26 <tikhon> newtype Sum = Sum Int
11:41:34 <elliott> mkramer: we cry, mostly.
11:41:42 <c_wraith> in general, if there are two things that make equal sense, neither one gets made the official instance
11:41:46 <tikhon> yeah, there is some crying involved
11:41:47 <elliott> there are some ways to make using the newtypes tikhon mentioned nicer in practice (lens has them)
11:41:49 <c_wraith> and the newtypes tikhon is pointing out come into play
11:41:54 <elliott> but mostly we just hope there's only one reasonable instance.
11:42:02 <elliott> if you run into this a lot with a typeclass then it might be overly broad a typeclass
11:42:05 <tikhon> sometimes you may want to extract the typeclass into a record
11:42:08 <elliott> (Monoid is sort of borderline here)
11:42:33 <tikhon> maybe data Monoid a = { mzero :: a; (<>) :: a -> a -> a }
11:42:44 <tikhon> then pass monoid "instances" around explicitly
11:43:00 <tikhon> there was a package that let you do this automagically for typeclasses that look like algebras
11:43:48 <mkramer> *reading what you all just said
11:49:54 <tikhon> mkramer: the key idea is the crying and gnashing of teeth
11:50:33 <tikhon> and getting made fun of by OCaml developers (who don't really have a leg to stand on) :P
11:50:41 <mkramer> tikhon: LOL :). This was the first thing that came to mind when I read how to declare an instance of a typeclass
11:51:00 <tikhon> fundamentally, it's the compromise we make to get inference
11:51:04 <tikhon> and I think it's more than worth it
11:51:07 <mkramer> Alright, so, if I do want to do it, I could create a newtype SumInt = Int, and then
11:51:18 <mkramer> instance SumInt Monoid where ...
11:51:18 <exicer> I'm trying to use ByteString.Lazy.split, but I don't know how to convert '\n' (a char) to a word8
11:51:19 <elliott> newtype SumInt = SumInt Int, but yes
11:51:24 <elliott> instance Monoid SumInt where, but yes
11:51:46 <mkramer> That's not so bad.
11:52:01 <tikhon> no
11:52:14 <tikhon> honestly, I think it's only a *little* bit worse than having a real module system, for *a lot* of upside
11:53:32 <exicer> So, uh, is there an easy way to convert char to word8 ?
11:53:53 <Clint> in a lossy fashion
11:53:54 <tikhon> exicer: Char represents Unicode code-points, not C-style chars
11:54:24 <exicer> oh
11:54:45 <exicer> so it would be easier to convert everything to Text or something ?
11:54:50 <tikhon> yeah, it's a bit confusing, but the confusion is all C's fault
11:55:02 <tikhon> yes, if you're dealing with what is semantically text, use the Text type
11:55:19 <tikhon> ByteString is for binary data—you would have to worry about encoding
11:55:26 <tikhon> (I assume this is your question)
11:55:47 <arnsholt> tikhon: C, and every single high-level language ever that blurs the distinction between code-points/characters and encoded bytes/byte sequences
11:56:13 <tikhon> Mostly C
11:56:23 <scshunt> edwardk: so I was bored and managed to come up with a sensible composition for the monadic lenses if they weren't written in the overloaded (one-function) type, but instead as the two separate set and get functions. I'm not sure if there is a sensible way to rewrite these into the functor style, though, because the functor gets in my way :(
11:56:59 <arnsholt> Yeah, C is the root of the problem and the HLLs perpetuate it
11:57:04 <edwardk> scshunt: yes: i've done this formulation too. but i can't come up with any that actually give me good guarantees that their composition will preserve the laws
11:57:24 <edwardk> scshunt: consider MLens IO (IORef a) a
11:57:28 <edwardk> individually that is a well defined lens
11:57:34 <tikhon> admittedly, I'm also feeling a bit peeved at C because I just had to spend a couple of weeks dealing with it :P
11:57:37 <exicer> tikhon: So are there bitwise functions and stuff in haskell ?
11:57:45 <tikhon> exicer: yes, but not for Char
11:57:49 <tikhon> Data.Bits
11:57:53 <edwardk> but the monadic lens laws aren't closed for it when you consider it under composition
11:58:07 <arnsholt> tikhon: Look on the bright side. At least it wasn't C++ =)
11:58:16 <tikhon> yes, that is a bright side
11:58:26 <tikhon> and calling out to C++ is much more painful than calling out to C
11:58:35 <arnsholt> Indeed.
11:58:37 <scshunt> edwardk: I don't think you can sensibly make a formulation that for IO will always preserve the laws, because IO could run into environmental changes
11:58:42 <edwardk> exicer: https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication-part-1 does a ton of bit twiddling tom-foolery
11:59:09 <edwardk> scshunt: IO won't necessarily preserve laws, but the _lens_ should only use io actions that would.
11:59:19 <tikhon> that was an interesting article, coincidentally
11:59:19 <arnsholt> For things where C is actually appropriate, I actually don't mind programming in C. Memory managment is annoying, but that's the price you pay
11:59:24 <edwardk> what you run under the lens should be free to do as it will
11:59:33 <tikhon> Rust!
11:59:35 <tikhon> any day now
11:59:55 <tikhon> that said, memory management is one thing and C quite another; C with garbage collection would just be worthless
12:00:13 <tikhon> on the other hand, a nice language with manual memory management could still be interesting
12:00:33 <scshunt> edwardk: assuming set = readIORef and get = writeIORef, you aren't even guaranteed to have the laws
12:00:35 <edwardk> I stick to what i can reason about. the utility of monadic lenses is highly suspect to me given that many constructions i can implement with a monadic lens is no longer canonical, given that the order in which i run things in the nested context can drastically affect the semantics of my lens.
12:00:58 <edwardk> scshunt: correct. there you only get it if you assume isolation.
12:01:21 <scshunt> I think you sort of have to assume isolation between lenses as well
12:01:24 <edwardk> now, something like readTVar, writeTVar so that its a MLens STM (TVar a) a
12:01:41 <edwardk> scshunt: but that is a global property of your program, not a local property of your lens, which means its shit to reason about
12:01:56 <edwardk> lenses compose well because i can reason about them in isolation
12:02:18 <edwardk> monadic lenses do not because they blow up in strange spectacular ways very easily the moment i make small changes elsewhere in my code
12:02:40 <scshunt> I remain unconvinced that things are as bad as you say
12:03:29 <scshunt> I would think that you should at least be able to get the laws if you make an additional assumption of isolation between the lenses in your composition stack. Does this fail somewhere?
12:03:45 <troydm> how do i recreate specific package.cache in ~/.ghc/ directory?
12:03:47 <edwardk> thats okay. i remain convinced they are, and that monadic lenses don't compose in a way that permits the rest of the traversal, etc. framework to be retained.
12:03:56 <arkeet> troydm: ghc-pkg recache?
12:04:05 <scshunt> edwardk: I haven't thought about Traversal, granted
12:04:06 <exicer> So the way people do imports in haskell seem to be very different than in python
12:04:12 <exicer> eg in python it is dicouraged to do import mod *
12:04:15 <troydm> i'm trying to ghc-pkg recache but it doesn't recreates local cache and instead tries to access system wide cache
12:04:18 <exicer> but here that seems to be the norm
12:04:23 <exicer> Is there a reason for that ?
12:04:39 <arkeet> I wonder if ghc-pkg recache --user makes sense.
12:05:14 <edwardk> scshunt: i have to give up too much stuff to get them. i wanted them, but i am happier retaining the ability to reason about some of the much more exotic combinators, which become highly suspect under an MLens interpretation
12:05:34 <scshunt> edwardk: shame
12:05:35 <troydm> arkeet: thx, worked
12:05:44 <scshunt> exicer: 'from mod import *' pulls in every submodule. This is not true of 'import Foo' in Haskell
12:06:18 <edwardk> scshunt: now, that said, i've been able to still use lenses in code that interact with the outside world by creative use of mmapping in files and then using the lenses in a region where that data was mapped in.
12:06:29 <scshunt> in Haskell, "submodules" are just a lexical thing, and there is no actual internal association between "Foo"."Bar"
12:06:32 <edwardk> but my usecases have been somewhat restrcted
12:06:38 <scshunt> edwardk: this is clearly less disgusting ;)
12:09:03 <edwardk> scshunt: it lets me do things like "snapshot $ \r -> r ^. with Column1 (>=) 30 . with Column2 (<=) 40"  for querying and updating, etc.
12:16:36 <kxra> stepcut, donri: this is off topic, but how did javascript get to start being included in browsers? and do you think its a good thing overall?
12:16:51 <raisdead> kxra: Browser wars
12:17:05 <geekosaur> netscape, livescript
12:17:41 <stepcut> kxra: it's a long and boring story :)
12:17:41 <zomg> kxra: it was invented by a browser company, that's how =)
12:17:46 <kxra> raisdead, geekosaur: ah, i see.
12:18:08 <zomg> These seems to be somewhat of a story on wikipedia as you might expect http://en.wikipedia.org/wiki/Livescript#History
12:18:18 <kxra> stepcut: always is after the controversy is over and someone has come out on top and the world has to live with the consequences [=
12:18:45 <ReinH> "1995 - Brendan Eich reads up on every mistake ever made in designing a programming language, invents a few more, and creates LiveScript."
12:18:48 <ReinH> http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
12:19:10 <zomg> ReinH: lol
12:19:41 <raisdead> ReinH: That is the best definition of javascript I have ever found
12:19:41 <monochrom> javascript : netscape :: visual basic : ms word
12:19:42 <zomg> Clearly written by a haskell programmer due to the obvious superiority complex of the writer
12:19:45 <zomg> err
12:20:26 <zomg>  Yukihiro "Mad Matz" Matsumoto creates Ruby to avert some vaguely unspecified apocalypse that will leave Australia a desert run by mohawked warriors and Tina Turner.
12:20:29 <zomg> oh lol
12:20:39 <monochrom> authors of large programs want the large programs to be programmable, "has macros"
12:20:51 <monochrom> well, some users want it, too
12:21:03 <elliott> kxra: this kind of thing may be more appropriate for #haskell-blah
12:21:39 <kxra> elliott: yes definitely. sorry. didn't know that existed
12:21:59 <monochrom> ObTopic: a fraction of haskell programmers are the only authors in the world who do not want Turing-completeness :)
12:22:12 <elliott> kxra: np :)
12:31:24 <johnw> edwardk: that's a great suggestion
12:32:11 <edwardk> johnw: it should be a pretty straightforward engineering thing, other than how to make it look pretty as disqus is pretty easy to embed
12:32:25 <johnw> right, I've added an issue for this to our tracker
12:33:21 <edwardk> trying to see if i can adapt the code from the other day with Rein into a pretty little post on cellular automata. generating images for different rules and initial conditions in response to user clicks would be dead sexy
12:33:59 <edwardk> I intend to kind of blow past the stuff folks have done before and just try to make something look pretty that people can play with, so the pacing may be a bit off, but it should be fun to fiddle with
12:37:20 <shergill> edwardk: looking forward to it
12:37:22 <FreeFull> Is there any Haskell program that will print out all numbers from 1..1000 shorter than   main=forM[1..1000]print
12:37:55 <FreeFull> Oh, dammit
12:38:00 <FreeFull> forM isn't in scope by default
12:38:02 <merijn> FreeFull: You mean with one number per line and no other symbols?
12:38:32 <FreeFull> merijn: Doesn't matter, as long as it includes all the numbers
12:38:50 <Kaini> main=print [1..1000]
12:38:51 <sclv> print [1..100]
12:38:52 <Kaini> :P
12:38:57 <FreeFull> Oh, right =P
12:39:11 <HugoDaniel> hi
12:39:20 <FreeFull> How about newline-separated and no other symbols?
12:39:31 <HugoDaniel> how can i have bidirectional Chan between threads ?
12:39:41 <sclv> then yours is about as efficient as it gets
12:39:55 <FreeFull> HugoDaniel: Chans are bidirectional
12:39:57 <sclv> you can use mapM instead of forM with a few more chars to stay in prelude
12:40:02 <FreeFull> Or rather, infinidirectional
12:40:07 <FreeFull> Any thread can write or read to one
12:40:20 <FreeFull> sclv: Yeah, I have used mapM
12:40:21 <merijn> HugoDaniel: Wrap two chan's in a tuple?
12:40:33 <FreeFull> main=mapM print[1..1000]   is the shortest I can come up with so far
12:40:38 <merijn> have a read that reads from one, writes to the other
12:40:59 <merijn> HugoDaniel: the difference between two sides is then just "Data.Tuple.swap" on the chan
12:41:10 <HugoDaniel> cool
12:41:40 <HugoDaniel> hmm, if i have like 1000 chans to read, how can i poll them really fast ? (or avoid polling at all) ?
12:41:55 <merijn> HugoDaniel: Why do you have 1000 chans to read?
12:42:04 <merijn> HugoDaniel: Can't you have all the producers write to a single chan?
12:43:15 <HugoDaniel> yes i can, but then i would need to keep an id in each message to know what answer corresponds to it when it arrives or no ?
12:43:31 <clahey> That seems better than listening to 1000 chans.
12:43:40 <clahey> (Though I did jump in in the middle
12:44:20 <HugoDaniel> and it could happen that i read an answer that was not for me
12:44:27 <merijn> HugoDaniel: Yeah, I would have 1 channel to read from (wrapped with identities) and then an IntMap of Chan's to answer on
12:44:51 <johnw> HugoDaniel: what if you pass a chan with your request, so that the worker knows exactly where to put the answer
12:45:59 <merijn> johnw: You should kick the ass of whichever of your colleagues is supposed to respond to this competition mailing address, because that person isn't doing their job ;)
12:46:16 <johnw> merijn: oh?
12:46:30 <johnw> I can do some ass foot-planting
12:46:44 <johnw> my guess is they're working on it
12:47:02 <HugoDaniel> johnw: a chan inside a chan ? :D
12:47:46 <merijn> HugoDaniel: Actually, yes, that's a better idea
12:47:48 <HugoDaniel> maybe an mvar will do
12:48:13 <johnw> HugoDaniel: that's a trick used by Cloud Haskell
12:48:15 <merijn> HugoDaniel: Yeah, that should work
12:48:38 <HugoDaniel> allright! cool :)
12:48:59 <HugoDaniel> i was going to use pipes, but then windows doesn't support them and i need this to run on windows :/
12:49:14 <HugoDaniel> thanks for the help, ill try the mvar inside the chan approach
12:49:21 <Kaini> FreeFull, I was thinking of    print=<<readFile"x"   but that has 19 chars like your mapM solution
12:49:22 <takemitsu> Hello, I'm currently looking into hxt. Can someone explain me how to construct an XML-String outside of IO? E.g. how could I turn the following into a String without having to use runX: selem "test" [txt "success"]
12:49:45 <Kaini> (And requires a file with the desired content)
12:49:56 <hpaste> jmbto pasted “fibonacci State monad style” at http://lpaste.net/91875
12:50:08 <FreeFull> :t ap
12:50:08 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:50:18 <sj4nz> HugoDaniel: Have you considered using an existing networking library like zermomq to avoid having to make this wheel?
12:50:24 <FreeFull> No, that won't work because it will be in the list monad
12:50:25 <FreeFull> Hmm
12:50:33 <sj4nz> s/zermomq/zeromq/
12:50:37 <FreeFull> :t mapM
12:50:38 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
12:51:05 <HugoDaniel> sj4nz: zeromq has their own context and thread handling, i want to use ghc runtime since it works nicely and its fast :) also i think zmq can't handle inprocess sockets in windows, but im not sure of this
12:53:09 <jmbto> damn
12:53:26 <jmbto> I forgot get put the state in the tuple
12:54:18 <jmbto> probably swapped the order of the elements in the tuple
12:54:18 <paintcan> i hate it when that happens
12:54:32 <FreeFull> GHC runtime will be especially nice once 7.8.1 comes out
12:54:37 <sj4nz> I believe that ZMQ does support inproc on Windows. The bit of code I read led me to believe that the library was using GHC threads-- or I am confusing Control.Concurrent.Async.async with them.
12:54:40 <FreeFull> Because of the improved IO manager
12:55:39 <NemesisD> i've got some code that pulls a log message off of a chan and logs it. i want the log destination/log level to be changeable via a tmvar or something
12:56:01 <NemesisD> it feels like i could do this with async, but im not sure
12:56:13 <merijn> sj4nz: That seems rather irrelevant, 1) Chan are not usually used for networking, 2) the current libzmq bindings for haskell are kinda obnoxious 3) haskell chan's play much nicer with the threading used in the GHC RTS
12:57:02 <hpaste> jmbto revised “fibonacci State monad style”: “No title” at http://lpaste.net/91875
12:57:08 <FreeFull> NemesisD: You could bundle the destination with the message, and peek at the chan to see if the message is meant for the thread
12:57:10 <sj4nz> If you're never going to interoperate with another system, use the Chan, ZMQ is interesting to me because of the possiblities to reuse distributed components written in different languages.
12:57:18 <jmbto> slightly worse hahaha
12:57:30 <FreeFull> NemesisD: Although it might be easier with STM and TChan
12:59:09 <merijn> btw, what's up with everyone suddenly trying to use ZMQ. I could be getting so much real life karma if I wasn't stuck working on my actual job, rather than my ZMQ stuff >.>
12:59:15 <NemesisD> FreeFull: eh, the sources of the log messages don't need to know where they're going, theyre just tagged as debug or not basically
12:59:28 <sj4nz> The documentation while great for ZMQ in general is not as good for me within Haskell, if that 's the awkwardness of the binding, it is definitely annoying.
12:59:44 <FreeFull> NemesisD: What's the difference between debug or not?
13:00:11 <NemesisD> FreeFull: if the logger is currently set on verbose mode, the message gets written to a file, otherwise it gets dropped
13:01:11 <osa1> any ideas what types can I use for Yesod's persistent framework's datetime field? I'm trying UTCTime and ZonedTime but both fail with "no instance for sql ......" error
13:01:35 <FreeFull> NemesisD: That's easy then
13:01:52 <NemesisD> its like every loop pulling off the chan and running, I should "race" that iteration pulling off of an mvar for the config, loser gets retried
13:01:56 <sj4nz> osa1: I've had to import Data.Time to use UTCTime
13:02:20 <sj4nz> osa1: Which back-end? sqlite? postgresql? etc
13:02:22 <hpaste> jmbto revised “fibonacci State monad style”: “No title” at http://lpaste.net/91875
13:02:23 <FreeFull> NemesisD: I don't think you need any kind of race
13:02:36 <osa1> sj4nz: currently sqlite
13:02:45 <osa1> sj4nz: UTCTime is already imported in my case
13:03:13 <osa1> sj4nz: I tried MySQL also but failed with same error
13:03:15 <NemesisD> FreeFull: my thought there is that i block on an empty log message chan, so if a config change comes in, it shouldn't have to wait behind that to change the output file/verbosity, i think
13:06:45 <dymatic> Guys, quick question. Ranges work on a few different types. What typeclass allows ranges to work?
13:06:52 <tikhon> Enum
13:06:54 <dmj`> Enum
13:06:57 <dymatic> Thanks guys.
13:07:25 <dmj`> :i Enum
13:07:29 <shachaf> A way to figure it out:
13:07:31 <dmj`> > :i Enum
13:07:32 <lambdabot>   <hint>:1:1: parse error on input `:'
13:07:33 <shachaf> :t \x y -> [x..y]
13:07:34 <lambdabot> Enum t => t -> t -> [t]
13:07:48 <FreeFull> lambdabot doesn't do :o
13:07:51 <FreeFull> Or :i
13:08:12 <dymatic> Thanks sha. I tried googling, but it brought up tutorials on Typeclasses and the first chapter of LYAH instead.
13:08:26 <FreeFull> > succ 1.0
13:08:27 <lambdabot>   2.0
13:08:41 <nabilhassein> i've encountered a bit of cabal hell, can anyone help me diagnose how to solve it?
13:08:43 <tikhon> > [1.0, 1.1 .. 10]
13:08:44 <lambdabot>   [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.5000000...
13:08:45 <sj4nz> osa1: What does the model look like? (lpaste?)
13:08:50 <tikhon> > [1.0, 1.1 .. 1.4]
13:08:51 <lambdabot>   [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004]
13:08:57 <osa1> sj4nz: pasting ...
13:09:13 <tikhon> Floating numbers and enum don't *really* mix
13:09:34 <osa1> sj4nz: http://lpaste.net/91878 (sorry for the mess, I was just experimenting)
13:10:09 <shachaf> > [1,3..4] :: [Int]
13:10:09 <lambdabot>   [1,3]
13:10:10 <shachaf> > [1,3..4] :: [Double]
13:10:11 <lambdabot>   [1.0,3.0,5.0]
13:10:21 <FreeFull> dymatic: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Prelude.html#t:Enum
13:10:53 <hpaste> nabilhassein pasted “cabal problems” at http://lpaste.net/91879
13:11:05 <nabilhassein> if anyone can help me solve this, i will be very grateful
13:12:06 <nabilhassein> i don't encounter this error on my own machine. only on the AWS server I'm trying to deploy my simple game to
13:12:10 <FreeFull> > [1.0,1.1..10] :: [CReal]
13:12:11 <lambdabot>   [1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2....
13:12:29 <joelteon> is it possible to take an IO action that might throw an exception and turn it into an EitherT that returns the exception as Left e?
13:13:09 <tikhon> > [1.0,1.1..1.4] :: [CReal]
13:13:10 <lambdabot>   [1.0,1.1,1.2,1.3,1.4]
13:14:26 <merijn> sj4nz: FWIW, I'm working on a pure haskell implementation for ZMQ, but it's slow going due to work getting in the way
13:14:47 <FreeFull> joelteon: Sure, I don't see why not
13:14:56 <FreeFull> As long as IO is at the bottom
13:15:08 <merijn> sj4nz: Just reached the point where I have an implementation for Dealer sockets and can exchange messages with ZMQ2.x, ZMQ3.x and the new protocol (which may become ZMQ4.x?)
13:15:24 <sj4nz> marijn: That'll be exciting. Right now I'm stumbling on ZMQ cooperating with OpenGL in a single process.
13:15:29 <Cale> :t try
13:15:30 <lambdabot> Exception e => IO a -> IO (Either e a)
13:15:37 <Cale> joelteon: You might want to start with that
13:16:09 <merijn> sj4nz: Yeah, the goal is to have threadsafe sockets (i.e. allow multiple haskell threads to access the same socket) and support stuff like STM for the sockets
13:16:41 <jmbto> if I wanted to implement a stateful Fibonacci function with the help of the State monad, what would be be useful info to keep track of the number I want to generate?
13:16:44 <Cale> :t EitherT
13:16:45 <lambdabot> Not in scope: data constructor `EitherT'
13:17:02 <Cale> Okay, so that's not in scope, but in any case, EitherT . try will do what you want.
13:17:48 <merijn> btw, anyone here going to be at Mostly Functional in Edinburgh?
13:18:08 <FreeFull> @hoogle EitherT
13:18:08 <lambdabot> package EitherT
13:18:19 <sj4nz> merijn: Not I.
13:18:39 <FreeFull> Hoogle lies
13:18:52 <Cale> jmbto: Uh, you mean, keeping the previous couple of sums in the state?
13:18:56 <FreeFull> Seems you have to install the either package to get the transformer
13:19:24 <bb010g> I've got a function type "Pixel p => Image p -> [p]" that I'm trying to partially apply to a function type "(Pixel p => Image p -> a) -> DynamicImage -> a", but ghc says that it can't deduce that a ~ [pixel]. I'm confused.
13:19:26 <FreeFull> Which is probably why lambdabot doesn't have it
13:19:59 <shachaf> bb010g: Are you sure about that type?
13:20:00 <Cale> > let fibStep = do (u,v) <- get; put (v,u+v) in execStateT (replicateM 10 fibStep) (0,1)
13:20:01 <lambdabot>   No instance for (GHC.Show.Show (m0 (t0, t0)))
13:20:01 <lambdabot>    arising from a use of `M20...
13:20:07 <Cale> > let fibStep = do (u,v) <- get; put (v,u+v) in execState (replicateM 10 fibStep) (0,1)
13:20:08 <lambdabot>   (55,89)
13:20:10 <shachaf> I recommend that you show your actual code.
13:20:14 * sj4nz waits for a hsenv to freshen itself with persistent
13:20:30 <bb010g> schoppenhauer: Yes. Those are what :t returns in ghci.
13:20:38 <Cale> jmbto: ^^ is that what you mean?
13:20:47 <osa1> sj4nz: have you tried my code? I'm trying it with GHC 7.6.3 and latest yesod
13:20:56 <FreeFull> Cale: Now do the same with matrices
13:21:16 <sj4nz> I just rebuilt a Debian system so it's installing dependencies
13:22:23 <shachaf> bb010g: I'm sure he'll be glad to hear it. But my recommendation stands.
13:22:49 <shachaf> (For example, it might be that there's a forall you're not telling us about.)
13:23:12 <jmbto> Cale, no clue
13:23:18 <merijn> jmbto: tbh, I don't think fibonacci is a good choice/example for working with State
13:23:27 <jmbto> http://lpaste.net/91875 > I did this
13:23:40 <hpaste> bb010g pasted “Type Weirdness” at http://lpaste.net/91880
13:23:47 <FreeFull> I think a good example for working with State is a simple RPN calcuator
13:23:52 <FreeFull> You can use a list as your stack
13:24:03 <merijn> FreeFull++
13:24:17 <merijn> I was just about to suggest implementing a stack of some sort :p
13:24:25 <jmbto> following an example from http://mvanier.livejournal.com/5846.html
13:24:53 <bb010g> shachaf: Sorry, mispelled and didn't check my autocomplete. I've tried listify with a forall pixel. Pixel pixel, but ghci returns the same :t and it gives the same error.
13:26:03 <hpaste> bb010g revised “Type Weirdness”: “Type Weirdness” at http://lpaste.net/91880
13:26:03 <merijn> jmbto: hmm, that tutorial seems needlessly complex
13:26:06 <jmbto> and when I use get, I lose the fibo number I want to generate
13:26:07 <sj4nz> osa1: Is your error around the "last update" literal or is that different?
13:26:08 <Cale> Anyone else having trouble loading jmbto's link?
13:26:27 <shachaf> bb010g: OK, that's better. :-)
13:26:45 <joelteon> thanks Cale, that seems to work
13:26:54 <FreeFull> let pop :: State [a] a; pop = state $ \(x:xs) -> (x,xs) in flip runState [1,2,3] $ do { pop; pop }
13:26:58 <osa1> sj4nz: http://lpaste.net/91882
13:27:03 <FreeFull> >let pop :: State [a] a; pop = state $ \(x:xs) -> (x,xs) in flip runState [1,2,3] $ do { pop; pop }
13:27:04 <shachaf> bb010g: I suspect what you're trying isn't possible. It's like an existential variable escaping.
13:27:10 <FreeFull> > let pop :: State [a] a; pop = state $ \(x:xs) -> (x,xs) in flip runState [1,2,3] $ do { pop; pop }
13:27:11 <lambdabot>   (2,[3])
13:27:13 <FreeFull> Third try
13:27:30 <jmbto> I was wondering how you can keep track of the number I want to generate without losing it when getting the state
13:27:38 <FreeFull> Probably don't need the type singature since I made use of pop
13:27:42 <merijn> First thing I thought of with "pop; pop" was Community :)
13:27:56 <b52> Anyone aware of a library to access my webcam under Linux?
13:27:58 <bb010g> shachaf: Existensial variable escapes??
13:27:58 <Cale> jmbto: When you get the state, you shouldn't lose anything.
13:28:24 <jmbto> Cale, that depends on what I chose to be the state
13:28:31 <sj4nz> osa1: Ok, Now I have the same error. Progress. :)
13:28:32 <FreeFull> b52: You'll probably want something to do with v4l2
13:28:34 <jmbto> and the result
13:28:42 <FreeFull> Or something that builds on top of it
13:29:02 <jmbto> so my implementation isn't good at all
13:29:09 <Cale> bb010g: The type you've given to dynamicMap requires a to be chosen without knowledge of the type pixel. It can't depend on pixel.
13:29:23 <shachaf> bb010g: Let's try a simpler example. foo :: (forall a. a -> r) -> r
13:29:23 <jmbto> I wanted to understand State
13:29:36 <shachaf> bb010g: Do you see why "foo id" is an error?
13:29:48 <b52> Homecome that hackage has no docs for the v4l2 package?
13:29:53 <Cale> bb010g: More fully, it's  forall a. (forall pixel. (Pixel pixel) => Image pixel -> a) -> DynamicImage -> a
13:30:13 <geekosaur> b52, probably because the buildbot doesn't have the necessary xorg libraries installed
13:30:27 <andrewsw> @pl const(const())
13:30:27 <lambdabot> const (const ())
13:30:28 <geekosaur> if it can't build the package, it can't build the documentation
13:30:39 <dmj`> If I have two folders at the same directory level A/A.hs and B/B.hs. How do I import module A into module B. Is it import A.A inside of B.hs?
13:30:52 <bb010g> shachaf: No. Would id have to have the type (forall a. a -> a)?
13:30:58 <dmj`> ghci doensn't like it :(
13:31:10 <merijn> b52: Hackage can only generate docs for packages that succesfully build on the Hackage server
13:31:29 <FreeFull> dmj`: I think it is A.A but you have to be in the common directory
13:31:31 <geekosaur> you would need ":set -i.." and then it's "import B.B"
13:31:35 <shachaf> bb010g: Yes, but why can't you unify a and r?
13:31:35 <merijn> b52: Unfortunately that means that the documentation for many libraries that can't build on Hackage due to missing dependencies can't be generated
13:31:36 <b52> can i build the docs locally using cabal?
13:31:48 <Cale> dmj`: Module paths will always be from the root of your project.
13:31:51 <geekosaur> oh. other way around, misread. same solution though
13:32:01 <merijn> b52: Yes, I forgot the exact flag, but you can change your cabal config to always build docs and install them locally
13:32:25 <jchee> When I use cabal to configure and build my program (with --enable-library-profiling and --enable-executable-profiling) I get a message "the flag -p requires the program to be built with -prof" when I try to run it with +RTS -p, any idea how I can enable profiling for executables with cabal?
13:32:41 <merijn> b52: Edit ~/.cabal/config and make sure that it has the line "documentation: True" to build documentation for all packages
13:32:51 <FreeFull> :t fix
13:32:52 <lambdabot> (a -> a) -> a
13:32:52 <Cale> dmj`: You'll have to go up to the level where the A and B directories live when you run GHC.
13:33:19 <Cale> dmj`: Because it'll look in A/A.hs for the module A.A
13:33:27 <Cale> relative to where it's been run
13:33:50 <jmbto> <Cale> jmbto: ^^ is that what you mean? > ah yes it is! thank you I didn't notice this
13:33:51 <bb010g> shachaf: I don't know. I'm looking at the Haskell Prime and Haskell Wiki pages, but I still don't get it.
13:33:58 <merijn> b52: (This of course assumes the packages *has* documentation, but that's a separate issue ;))
13:34:17 <shachaf> bb010g: OK, then you need background about how forall works. :-)
13:34:26 <jmbto> but I don't know what's wrong with my implementation
13:34:46 <FreeFull> Tenrecs sound like very haskellish animals
13:34:49 <shachaf> bb010g: Maybe try http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
13:35:02 <merijn> andrewsw: You can also write "const (const ())" as "\_ _ -> ()"
13:35:36 <bb010g> shachaf: Thanks!
13:35:44 <Cale> jmbto: Well, first of all, your type signature for statefulFibo says that the state type is Int
13:35:44 <andrewsw> merijn: heh yeah. we were playing around here and I thought there might be some magic...
13:36:02 <Cale> jmbto: But you seem to assume that it's a pair whose second part is a pair.
13:36:19 <jmbto> yeah must have swapped those
13:36:39 <dmj`> Cale: Very cool, big thanks
13:37:51 <Cale> jmbto: Try removing the type signature and see what type is inferred. You'll find that because you get the state and subsequently return the same value, the state type has to be the same as the result type.
13:38:57 <Cale> oh, you might run into the monomorphism restriction
13:39:31 <jmbto> yup I did
13:39:42 <Cale> and yeah, the inferred type will be a bit general
13:39:58 <Cale> statefulFibo :: (Eq t, Num t, Num a, MonadState (t, (a, a)) m) => m (t, (a, a))
13:40:12 <Cale> If you add {-# LANGUAGE NoMonomorphismRestriction #-} then you can get GHC to infer that
13:40:26 <Cale> But we presumably want a more specific type
13:40:33 <Cale> State (Int, FiboTerms) (Int, FiboTerms)
13:40:34 <Cale> would work
13:40:48 <jmbto> yeah I probably would have never thought of that signature lol
13:41:44 <merijn> Any recommendeded approach on running tests that require interaction of multiple executables from cabal?
13:42:02 <jmbto> very well thanks again for the clues Cale
13:42:57 <Cale> jmbto: Are you okay with the implementation of State, or would you like to go over that?
13:43:26 <jmbto> I will go over State again I think
13:43:42 <startling> what's the point of all these libraries that use conduits but don't expose a conduity way to use them?
13:43:44 <Cale> If you join #haskell-overflow, I can explain it :)
13:44:04 <jmbto> sure
13:44:32 <startling> specifically I'm thinking of http://hackage.haskell.org/package/markdown and http://hackage.haskell.org/package/dom-selector
13:46:37 <bb010g> shachaf: So, dynamicMap doesn't like that I'm trying to "lock down" its forall pixel
13:47:09 <bb010g> shachaf: (sorry, pressed enter) . to a Pixel p?
13:47:28 <merijn> startling: Probably the conduit support for resumable parsing is less sucky than the plain attoparsec approach
13:48:22 <shachaf> bb010g: dynamicMap gets to choose any pixel type it wants (as long as it's an instance of Pixel).
13:49:16 <bb010g> shachaf: How is my listify violating that choice, then?
13:50:13 <shachaf> bb010g: listify says: For any type "pixel" that you (the *user* of listify) wants (so long as it's an instance of Pixel), listify will give you [pixel].
13:50:21 <shachaf> So the user gets to choose.
13:50:57 <shachaf> Hmm, no, that's incomplete.
13:51:25 <shachaf> This is too complicated an example -- do you understand the earlier example I gave?
13:51:34 <shachaf> foo :: (forall a. a -> r) -> r
13:51:35 <merijn> bb010g: The problem is that the 'a' in "dynamicMap" is [pixel], but pixel is not in scope in the type of dynamicMap
13:51:38 <shachaf> foo id -- type error
13:52:23 <aristid> are there canonical QuickCheck Arbitrary instances for Vector somewhere?
13:54:24 <bb010g> shachaf: foo wants a function that takes any and all a's and returns something else, and returns that something else, right? Such as const 5. That takes anything and returns a Num instance. Would that work?
13:54:39 <merijn> bb010g: Let's start even more basic
13:54:58 <merijn> bb010g: "foo :: a", who "decides" what type foo becomes?
13:55:25 <bb010g> merijn: The function you supply?
13:55:43 <shachaf> There's no supplying here.
13:55:44 <merijn> Which function? I didn't show any function or whatever in my example code
13:55:51 <shachaf> Let's add the foralls, to be explicit.
13:55:53 <merijn> bb010g: Forget all conversation before this point
13:55:57 <bb010g> merijn: Ok.
13:56:02 <aristid> oh well I guess i can just use fromList in the property :D
13:56:03 <merijn> shachaf: Actually, I was gonna do that as next step
13:56:10 <merijn> shachaf: For the sake of explicitness
13:56:36 <merijn> bb010g: You have a value "foo :: a" what decides which type the value has?
13:56:37 <sj4nz> osa1: This is stumping me. But then, TemplateHaskell debugging always gets my goat.
13:56:41 <shachaf> This is so much more straightforward in Agda.
13:57:13 <bb010g> merijn: In "foo :: a", whatever uses foo. It's like undefined, and polymorphic?
13:57:29 <shachaf> Right.
13:57:37 <merijn> bb010g: Correct, the key insight is "whatever uses foo"
13:57:59 <shachaf> bb010g: Think of this as a two-person game. You're on one side, merijn is on the other. merijn gives you "foo :: a". Who gets to decide what a is?
13:58:02 <shachaf> The answer (like you said) is that you get to decide. Not merijn. merijn has to live with your decision.
13:58:21 <merijn> bb010g: Now, "foo :: a" is actually short for "foo :: forall a . a", which means "for every type 'a' that you give me I will become a value of that type"
13:58:38 <bb010g> shachaf: That's why undefined is really the only possible forall a. a, right?
13:58:39 <merijn> bb010g: The forall basically says, "whoever gets this, gets to decide what 'a' becomes"
13:58:43 <merijn> bb010g: Yes
13:58:58 <bb010g> merijn: Ok. I get that.
13:59:00 <shachaf> Yes, because you could pick some weird type with no other inhabitants.
13:59:24 <merijn> bb010g: Now, let's go one step further "id :: forall a . a -> a" which says, "for any type you pick, I will become a function from that type, to that type"
14:00:36 <merijn> bb010g: Or slightly more interesting in our case "map :: forall a b . (a -> b) -> [a] -> [b]" ("forall a b. ..." is the same as "forall a . forall b . ...")
14:00:51 <bb010g> merijn: So, for forall a. a -> a, you could only really have id or const undefined?
14:00:53 <shachaf> (You might notice a parallel with another mechanism in Haskell... (\x -> x + 1). Who gets to decide what x is?)
14:00:58 <shachaf> (But anyway I'll let merijn talk.)
14:01:05 <merijn> bb010g: You're forgetting "id = undefined" :)
14:01:43 <merijn> bb010g: But yeah, those are pretty much the only possible definitions of "id"
14:01:57 <merijn> bb010g: Now, the map case is more interesting, because you get to pick *two* types
14:02:24 <merijn> bb010g: The only rule is, that once you pick all a's and b's in the type of map must be the same (obviously, right?)
14:02:34 <enthropy> osa1: maybe the UTCTime you're trying to use is not the same one listed here: http://hackage.haskell.org/packages/archive/persistent/1.2.0.1/doc/html/Database-Persist-Sql.html#t:PersistFieldSql
14:03:18 <bb010g> merijn: Yes. That's why map can't change the function.
14:04:04 <bb010g> merijn: Unless it replaced it with some sort of const (undefined::b).
14:04:18 <merijn> bb010g: Now, next complication step (this is a slight detour, but I hope it'll help me make an easier example) "(==) :: Eq a => a -> a -> Bool"
14:04:25 <johnw> i wonder why forall is so hard to explain in Haskell.  In C++ templates, "forall" is just a template template argument instead of a regular template argument, its meaning is pretty obvious
14:04:49 <merijn> bb010g: Eh, "(==) :: forall a . Eq => a -> a -> Bool"
14:05:04 <merijn> today is not my day, three time's the charm, right?
14:05:05 <startling> I think the implicit forall confuses some things
14:05:13 <merijn> "(==) :: forall a . Eq a => a -> a -> Bool"
14:05:46 <bb010g> merijn: The constriction of the Eq typeclass on a makes it so you can use instances for more useful polymorphism, right?
14:05:54 <shachaf> johnw: I don't know what you're saying but it doesn't sound right.
14:06:18 <merijn> bb010g: This type basically says, you get to pick any type 'a' when you use this function, *but* you also have to provide a proof that 'a' is an instance of Eq
14:06:41 <johnw> shachaf: it may not be.  I'm thinking of template <typename T> foo(); vs. template <template T<typename U>> foo();  Hmm.. I think you are right, I retract
14:07:01 <merijn> bb010g: So the "Eq a =>" puts a restriction on which a's you're allowed to pick when you use (==)
14:07:12 <bb010g> merijn: Ok.
14:07:20 <merijn> bb010g: i.e. you're only allowed to pick a's that are instances of Eq
14:08:06 <bb010g> merijn: That makes sense.
14:08:28 <merijn> bb010g: Right, let's introduce a datatype "data Foo = FooFloat Float | FooInt Int"
14:08:40 <merijn> Simple enough, right?
14:09:08 <merijn> Now, suppose we want to define a function that lets us update the value inside Foo
14:09:17 <bb010g> merijn: Yes. The functions using Foo typed data can pattern match.
14:09:25 <merijn> So we want to do something like "updateFoo (+1)"
14:09:48 <merijn> We don't care whether it is a FooFloat or a FooInt, we just want to +1 it
14:10:05 <merijn> bb010g: But what would the type of updateFoo be?
14:10:42 <merijn> Can you spot why this type doesn't work? "updateFoo :: forall a . Num a => (a -> a) -> Foo -> Foo"
14:10:54 <bb010g> merijn: updateFoo :: forall a. Num a => (a -> a) -> Foo -> Foo
14:11:17 <bb010g> merijn: No, that's what I thought would work. Float and Int are both instances of Num.
14:11:28 <merijn> bb010g: Ah, but who gets to pick the value of a?
14:12:11 <bb010g> merijn: The user, when supplying the function that is guaranteed to work on all Num.
14:12:23 <merijn> bb010g: Ah, but that's where you're wrong!
14:12:40 <merijn> bb010g: Suppose I have "doubleTrouble :: Double -> Double"
14:12:44 <bb010g> merijn: But, they are all Num to Num, meaning suppling something like a Ratio would mess it up!
14:12:53 <bb010g> merijn: Or a Double.
14:13:06 <merijn> bb010g: Yes, but the caller of updateFoo decides which 'a'
14:13:15 <merijn> bb010g: Suppose I call "updateFoo doubleTrouble"
14:13:29 <merijn> bb010g: Double is an instance of Num, so that typechecks
14:13:45 <merijn> bb010g: But clearly a function "Double -> Double" can't modify an Int or Float!
14:14:13 <merijn> bb010g: The problem is that "updateFoo" claims to except a function that works on *a* Num, i.e. a specific one
14:14:30 <bb010g> merijn: Ok. That makes sense. You have to watch your broadness.
14:14:34 <merijn> bb010g: But that's not true, updateFoo has to accept functions that work on *both* Int *and* Float
14:15:01 <bb010g> merijn: So, would you create an IntOrFloat typeclass?
14:15:14 <merijn> bb010g: No, we have a nice extension for this
14:15:24 <merijn> It's called "RankNTypes"
14:15:40 <merijn> What does this extension do? It lets us write types like this
14:16:01 <merijn> "updateFoo :: (forall a . Num a => a -> a) -> Foo -> Foo"
14:16:18 <nooodl> @hoogle (Monad m) => (a -> b) -> a -> m b
14:16:18 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
14:16:18 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
14:16:18 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
14:16:21 <merijn> bb010g: Do you see the difference between this and our previous attempt to write a type for updateFoo?
14:16:35 <nooodl> does this have a name? i guess it's (return .) but that isn't very nice
14:16:52 <epta> Attoparsec question: is there a way to have some optional ignoring parser? Like `many thing <* otherThing' which will not fail when there is no otherThing after thing.
14:17:01 <shachaf> nooodl: What could be nicer than (return .)?
14:17:02 <lpsmith> noodl, fmap return works too
14:17:08 <merijn> lpsmith: No, wrong type
14:17:31 <shachaf> merijn: (.) = fmap
14:17:36 <bb010g> merijn: The forall was moved inside the Num function. How does that make it work?
14:17:38 <merijn> oh, right
14:17:49 <nooodl> oh it's just arr for Kleisli arrows
14:18:03 <startling> epta, presumably there's an "optional" combinator?
14:18:10 <merijn> bb010g: Well, the forall is no longer part of updateFoo's type, it's part of the type of updateFoo's first argument
14:18:10 <shachaf> @arr
14:18:10 <lambdabot> Smartly me lass
14:18:26 <merijn> bb010g: So who gets to pick the value of 'a'?
14:18:26 <startling> epta, then it's 'many thing <* optional otherThing'
14:19:20 <bb010g> merijn: The argument supplied to the Num function?
14:19:38 <merijn> bb010g: The *user* of that function
14:19:47 <merijn> bb010g: Which, as it happens, is updateFoo
14:20:00 <merijn> bb010g: So updateFoo is allowed to pick either Int or Float, as needed
14:20:03 <epta> startling: but it produces redundant Maybe
14:20:19 <startling> epta, so? you're throwing it out.
14:20:27 <bb010g> merijn: So, that makes sure that it's either Int or Float?
14:20:32 <shachaf> @src optional
14:20:32 <lambdabot> optional v = Just <$> v <|> pure Nothing
14:20:47 <sj4nz> osa1: I've run out of time to attack this. But I'm sure I'll be bitten by this kind of bug in the future so this isn't wasted time.
14:20:58 <epta> startling: right, thanks
14:21:24 <bb010g> merijn: And that's why it has to be implicit and not implied?
14:21:52 <osa1> sj4nz: thanks for taking your time and trying
14:21:58 <nooodl> i wish ∘ was written the other way around in mathematics :(
14:22:15 <startling> nooodl, it's not as nice.
14:22:49 <shachaf> nooodl: Sometimes people write ; for flipped ∘
14:22:50 <merijn> bb010g: Well, that ensures that updateFoo is allowed to pick which it needs. You'll notice that "updateFoo doubleTrouble" is now a type error, as the type "Double -> Double" doesn't match the forall there
14:23:10 <nooodl> yeah i just don't like how f . g . h is "h then g then f"
14:24:18 <nooodl> i forget which operator haskellers often use for "flipped (.)", but i think lambdabot has it?
14:24:28 <shachaf> (>>>), maybe?
14:24:32 <hpaste> merijn pasted “RankNTypes” at http://lpaste.net/91883
14:24:33 <bb010g> merijn: Ok. So, in the dynamicMap source, it wants to make sure that whatever Pixel pixel => Image pixel is supplied to the function is a member of DynamicImage?
14:24:36 <shachaf> That's way too long and ugly.
14:24:50 <merijn> bb010g: Ok, now let's go to your question
14:24:56 <merijn> Can you relink the code?
14:25:37 <shachaf> merijn: That space before the "." is weird.
14:25:44 <nooodl> should get rid of Ord and use (>)!
14:25:58 <merijn> shachaf: I always write it like that :(
14:26:13 <epta> How can I make a parser for digits except the last one? `many digit <* digit' is not the right answer :[
14:26:14 <shachaf> I noticed.
14:27:38 <ReinH> nooodl: &
14:27:51 <nooodl> ReinH: oh that might be it
14:27:57 <nooodl> > 3 & (+2) & (^2)
14:27:59 <lambdabot>   25
14:28:01 <nooodl> yup
14:28:10 <ReinH> & is a flipped $
14:28:55 <bb010g> merijn: Do I need to have listify ensure that the pixel used has a DynamicImage Image pixel instance?
14:29:11 <nooodl> i wonder if it'd be noticeable easier/harder to read code using (&) and (>>>) instead of ($) and (.), once you're used to it
14:29:21 <merijn> bb010g: I lost the link to your example and I can't be arsed to search in the backlog, can you link it again?
14:30:29 <bb010g> merijn: http://lpaste.net/91880
14:30:40 <bb010g> merijn: And the DynamicImage source is here: http://hackage.haskell.org/packages/archive/JuicyPixels/3.1/doc/html/src/Codec-Picture-Types.html
14:31:05 <ReinH> edwardk: I expected you to be done by now :p
14:31:05 <nooodl> epta: maybe just use "many1 digit" then apply init to the result?
14:31:07 <merijn> bb010g: Right, let's continue 1 step at a time, the type of dynamicMap is:
14:31:07 <merijn> "dynamicMap :: forall a . (forall pixel . (Pixel pixel) => Image pixel -> a) -> DynamicImage -> a"
14:31:28 <edwardk> ReinH: at work
14:31:37 <merijn> bb010g: So, the two questions for you are: 1) Who gets to pick 'a'? 2) Who gets to pick 'pixel'?
14:31:50 <edwardk> ReinH: i do have the code written. i'm currently trying to make SoH actually render it for to the web though
14:32:04 <bb010g> 1) The user of dynamicMap. 2) dynamicMap.
14:32:17 <merijn> bb010g: Bingo
14:32:18 <ReinH> edwardk: ah :) I was just kidding anyway
14:32:25 <merijn> bb010g: Now, take a look at your listify type
14:33:06 <merijn> bb010g: The return value of listify == the result of dynamicMap's argument == 'a'
14:33:22 <merijn> bb010g: Can you spot the problem? :)
14:33:38 <edwardk> i also wanted to turn the memoization of the store into a one-liner, so i need to figure out verbiage
14:34:12 <ReinH> edwardk: nice :)
14:34:19 <ReinH> can I see what you have so far?
14:34:48 <bb010g> merijn: listify takes any sort of Image?
14:34:52 <edwardk> ReinH: not sure how to do a limited audience viewing on the SoH =/
14:35:06 <ReinH> edwardk: ah, no worries, I was thinking a private gist or something?
14:35:08 <ReinH> but no worries
14:35:13 <edwardk> oh sure
14:35:37 <aristid> ReinH: what are you talking about? :)
14:35:48 <b52> does anyone know how to set a frameinterval using the v4l2 binding?
14:35:56 <ReinH> aristid: cellular automata with comonads
14:36:11 <aristid> ReinH: ah.
14:36:12 <edwardk> ReinH: https://gist.github.com/ekmett/d91edee0828d2c37aa8e
14:36:18 <edwardk> code definitely doesn't compile yet
14:36:22 <bb010g> merijn: It makes sure that p is an instance of Pixel?
14:36:24 <edwardk> was still breaking down the structure of it
14:36:34 <merijn> bb010g: listify (correctly) lets dynamicMap decide value "pixel" will have in "Image pixel", but since listify returns '[pixel]', the choice dynamicMap makes also determines the return type of listify (i.e. the 'a' in dynamicMap)
14:36:40 <djahandarie> Anyone who was around back in the day, does anyone know when lambdabot was first created?
14:36:58 <merijn> bb010g: But, we just observed that the user of dynamicMap gets to decide what 'a' is!
14:37:03 <ReinH> heh
14:37:06 <edwardk> also the pacing is way fast, but i wanted to showcase the excitement, tc.
14:37:21 <shachaf> djahandarie: Check the logs?
14:37:25 <shachaf> djahandarie: Looks like 2002.
14:37:34 <djahandarie> Oh, right, forgot we had those.
14:37:35 <bb010g> merijn: Oh! So, how should I type listify?
14:37:40 <shachaf> I think it was Pseudonym at the time.
14:37:41 <merijn> bb010g: So now we have a problem, dynamicMap wants to pic the value of "pixel", but dynamicMap is not allowed to pick the value of 'a'
14:37:47 <sclv> djahandarie: it was described in dons' thesis i think
14:37:50 <sclv> on plugins
14:38:02 <merijn> bb010g: Well, listify must not have "pixel" in it's return tpe
14:38:24 <merijn> bb010g: Because as long as 'pixel' is not in the return type, dynamicMap can pick whatever it likes
14:38:55 <edwardk> ReinH: the big headache is writing it in the editor, and then going over to see if it worked, etc.
14:38:57 <merijn> bb010g: What should listify return instead? That depends on what you wish to do with the results
14:39:16 <ReinH> edwardk: [f (s - 1), f s, f (s + 1)] oh that makes sense now
14:39:30 <edwardk> =)
14:39:33 <sclv> hmm, just looked. not in the plugins paper
14:40:02 <ReinH> edwardk: is -1 to the left? because you might need to reverse it for the usual "endianness"
14:40:15 <edwardk> i probably have to flop it
14:40:19 <edwardk> i figured i'd render one and look
14:40:29 <ReinH> yep no worries
14:40:34 <merijn> bb010g: Probably you want to have a look at the JuicyPixels API and look for a conversion function that can change any Pixel into a specific one
14:40:40 <sclv> djahandarie: ah here's the paper describing lambdabot http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.113.1406
14:40:45 <ReinH> edwardk: rule 110 is a good one to check
14:40:51 <edwardk> yeah
14:41:00 <edwardk> it was one of the few i know what to expect for
14:41:00 <ReinH> it's also turing complete
14:41:07 <merijn> bb010g: i.e. if you have "convert :; (Pixel a, Pixel b) => a -> b" then you could use that to have listify pick which Pixel the return value should be converted too
14:41:07 <edwardk> in some fashion
14:41:16 <ReinH> edwardk: well, it either is or it isn't :p
14:41:36 <edwardk> well, it is turing complete if you build this horrendous machinery to fire an initial state at it and interpret it
14:41:43 <ReinH> right
14:41:45 <ReinH> just like GoL
14:41:52 <merijn> bb010g: This works, because dynamicMap is only allowed to pic a value for 'pixel' that is an instance of Pixel, so if you have a function that can turn *any* Pixel into a *specific* pixel, you can just make sure listify only returns Pixel's of that type
14:42:00 <edwardk> and the way they describe that machinery is really quite sketchy =P
14:42:27 <edwardk> cue the random attacks on ANKOS in general, but i'm not current enough to care ;)
14:43:00 <ReinH> :D
14:43:00 <ReinH> edwardk: I just think it's fun to make the pretty pictures
14:43:03 <bb010g> merijn: I might be able to manage that. Thanks. I think I get foralls now!
14:43:20 <merijn> I should start charging for explanations :p
14:43:32 <ReinH> merijn: if you had a nickel...
14:43:47 <bb010g> merijn: You could take Bitcoin.
14:43:47 <merijn> bb010g: Basically, anything that can turn an arbitrary pixel into some *known* type will work for listify
14:44:25 <mescalinum> what's an efficient and short way to generate a fibonacci sequence? i.e. without a recursive function, but possibly by generating the i-th element of a list as sum of the previous two (is this thing possible in haskell?)
14:45:59 <schoppenhauer> oh god. somebody highlighted me.
14:46:51 <ReinH> "Next time I'll talk about a way to make it perform well for the normal case by using a zipper, and then how to make it perform well on strange topologies with representable functors."
14:46:55 <ReinH> damn you Edward
14:47:01 <ReinH> that's the part I was looking forward to :p
14:47:13 <merijn> mescalinum: Lazy magic!
14:47:14 <shachaf> schoppenhauer: For some reason people seem to type my name with "sch" a lot.
14:47:36 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- mescalinum: Like this!
14:47:37 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:47:52 <lingxiao> hey all: does anyone know any sample bits of code that uses `ListT` ?
14:48:12 <lingxiao> despite its criticism. This could be a snippet in an article, part of a pacakge, or what have you
14:48:14 <epta> mescalinum: also take a look at http://www.haskell.org/haskellwiki/Memoization
14:48:50 <mescalinum> merijn: cool! very clever. didn't think of using zip
14:49:02 <ReinH> it's fun to generalize that definition as well
14:49:18 <ReinH> higher order fib sequences, over the reals, etc
14:49:28 <edwardk> johnw: when i try to copy the lightweight snap example i get  "IOException: PORT: getEnv: does not exist (no environment variable)"
14:49:38 <edwardk> ReinH: i'll do the memoization in this post
14:49:48 <edwardk> i just figured i'd throw down words while i was thinking them in case i didn't
14:49:50 <merijn> @quote optimised.fibo
14:49:50 <lambdabot> No quotes match. My pet ferret can type better than you!
14:49:52 <edwardk> right now i want to get the executable done
14:49:56 <ClaudiusMaximus> mescalinum: http://www.haskell.org/haskellwiki/The_Fibonacci_sequence#Using_2x2_matrices is cute too
14:49:56 <merijn> eh
14:49:56 <edwardk> the words are easy
14:50:11 <merijn> @quote _pizza_ fibonacci
14:50:12 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
14:50:18 <ReinH> over any semigroup, really
14:50:24 <ReinH> edwardk: right :)
14:50:36 <ReinH> lmao
14:52:52 <ReinH> if you use Char instead you get fibonacci words
14:54:49 <ReinH> iirc if you use Dual Char you get a binary string that converges on the rabbit constant
14:55:38 <ReinH> edwardk: btw you never use the mime argument :)
14:55:51 <edwardk> ReinH: you are on way old code =)
14:55:56 <ReinH> my bad
14:56:11 <ReinH> I'll just wait then :)
14:57:24 <edwardk> one sec. i'll try to paste a newer one to you
14:57:29 <ReinH> :D
14:57:32 <ReinH> you're the best
15:01:24 <ClaudiusMaximus> any tips for rewriting FORTRAN77 code in Haskell?  assume my FORTRAN77 knowledge is next to nothing.  or should I rather investigate FFI options, and incrementally port the subroutines?
15:02:19 <johnw> edwardk: that is not good at all
15:02:24 <johnw> edwardk: I wonder if PORT isn't provided when running a snippet right now?
15:02:25 <edwardk> i can get it to run a normal program but nothing that wants a port in my own tutorials
15:02:30 <johnw> yeah, that might have been a recent change
15:02:30 <johnw> i'll make an issue and talk to chrisdone about that
15:02:30 <edwardk> so if i take the tutorial example which i can run in the main blog post
15:02:30 <c_wraith> ClaudiusMaximus: step 1) ask for more money.  :)
15:02:39 <edwardk> i can't run it in my own article =(
15:02:40 <edwardk> which kind of destroys the article
15:02:47 <DMcGill> ClaudiusMaximus: don't do it like this whatever you do: http://hackage.haskell.org/packages/archive/BASIC/0.1.5.0/doc/html/Language-BASIC.html
15:03:10 <edwardk> as i almost have a working cellular automaton-image generating program that fits on the screen as a punchline
15:03:11 <ReinH> DMcGill: that's brilliant
15:03:42 <DMcGill> actual Haskell code: do{10 PRINT "hello world"; 20 GOTO 10}
15:03:46 <DMcGill> or something like that anyway
15:03:57 <theWinner> F# chan is snoozing right now, so I'm asking here is F# has an Either type like Haskell
15:04:03 <theWinner> *if
15:04:34 <Fuuzetsu> For a minute there, I thought you were referring to F# with a -chan honorific…
15:04:41 <DMcGill> this post suggests now: http://hestia.typepad.com/flatlander/2012/02/discriminated-unions-in-f.html
15:04:56 <DMcGill> not*
15:05:18 <ClaudiusMaximus> c_wraith: want to give me some money to port this for my own benefit?  http://www.math.washington.edu/~marshall/zipper.html
15:05:34 <c_wraith> ClaudiusMaximus: sorry, my budget for helping with that is $-1
15:05:49 <ClaudiusMaximus> c_wraith: aww
15:05:49 <ReinH> Fuuzetsu: F# sama is napping
15:06:25 <scshunt> c_wraith: you're already overbudget :(
15:06:29 <Fuuzetsu> There needs to be more Haskell-tan images.
15:06:58 <c_wraith> scshunt: yes, but fortunately not by much.
15:08:02 <ReinH> Fuuzetsu: oh god is that a thing?
15:08:10 <ReinH> some cute japanese girl wearing a lambda tshirt?
15:08:12 <luite> ClaudiusMaximus: neat :)
15:08:34 <Fuuzetsu> ReinH: The only one I found is a rather upstuck lady with ∀ hair-pin
15:09:14 <ReinH> ha
15:09:30 <ClaudiusMaximus> luite: yeah, but a big interacting mess of fortran executables isn't my idea of fun..
15:09:31 <joelteon> heh, but it's really only for women
15:10:15 <Fuuzetsu> ReinH: http://fuuzetsu.co.uk/images/haskell-tan.jpeg
15:10:52 <ClaudiusMaximus> luite: ..so i'll probably end up using it once to generate a few hi-res rasters with coordinates in, then forget about porting it
15:14:03 <theWinner> hmm, so f# doesn't have an Either type, not even in the PowerPack
15:14:05 <theWinner> blooddy ell
15:14:25 <Fuuzetsu> bloody ℓ
15:14:35 <Fuuzetsu> is it not trivial to roll it yourself?
15:15:32 <shachaf> theWinner: It does have one, according to MSDN.
15:15:34 <monochrom> wait, F# has a power pack?! :)
15:15:37 <shachaf> But that's not really on-topic in here.
15:15:51 <theWinner> ah, here it is - http://msdn.microsoft.com/en-us/library/ee353439.aspx
15:15:53 <theWinner> Choice
15:16:17 <theWinner> sort of meh, IMO
15:16:24 <theWinner> oh well, sry for the OT
15:16:33 <theWinner> F# chan is bone dry
15:20:33 <ReinH> Fuuzetsu: that's pretty disappointing :(
15:22:22 <Fuuzetsu> ReinH: If I ever learn to draw, I'll make sure to do it justice
15:31:49 * hackagebot sizes 2.1.3 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.1.3 (JohnWiegley)
15:44:39 <adnap> Why can't I write a function like "f = 2 <$"?
15:45:01 <adnap> There is a parse error unless I write it like "f = (<$) 2"
15:45:39 <Fuuzetsu> wrap it all in parenthesis for a section
15:45:39 <Fuuzetsu> (2 <$)
15:45:52 <FreeFull> Sections always have parentheses
15:49:48 <adnap> FreeFull: What is a section?
15:50:19 <arkeet> adnap: an operator applied on one side
15:50:36 <arkeet> like (1 +) or (<$ 2)
15:50:42 <arkeet> or (2 <$)
15:50:55 <arkeet> but the syntax for them requires the parentheses
15:51:48 <arkeet> if % is an operator, then (x %) = \y -> x % y, and (% x) = \y -> y ^ x
15:51:50 <arkeet> er, y % x
15:52:04 <FreeFull> (/2) is the same as (\x -> x/2)
15:52:06 <arkeet> (there's an extension, I think, that makes (x %) mean (%) x
15:52:16 <FreeFull> And (2/) is the same as (\x -> 2/x)
15:52:25 <arkeet> (so that you can have unary operators)
15:53:03 <FreeFull> :t (\x y -> (x`y`))
15:53:03 <lambdabot> t -> (t -> t1 -> t2) -> t1 -> t2
15:53:21 <arkeet> apparently lambdabot doesn't have it.
15:53:44 <arkeet> :t (\x y -> \z -> y x z)
15:53:45 <lambdabot> t1 -> (t1 -> t2 -> t) -> t2 -> t
15:53:49 <arkeet> :t (\x y -> y x)
15:53:50 <lambdabot> t1 -> (t1 -> t) -> t
15:58:10 <tomejaguar> Is there a record constructor syntax in Haskell?  Something like "data T = { foo :: A, bar :: B }; t = { foo = myA, bar = myB }"?
15:58:22 <arkeet> tomejaguar: you need to give a constructor name.
15:58:30 <arkeet> data T  = C {foo :: A, bar :: B}
15:58:36 <tomejaguar> ah yeah
15:58:36 <arkeet> t = C { foo = myA, bar = myB }
15:58:36 <tomejaguar> ok
15:58:53 <tomejaguar> and if I leave any of the records out, it will be undefined?
15:58:56 <arkeet> yes
15:59:04 <tomejaguar> That's somewhat annoying
15:59:19 <arkeet> I can't remember if it warns you.
15:59:35 <tomejaguar> This is basically record update syntax applied to undefined, isn't it?
15:59:36 <arkeet> yeah it does.
15:59:36 <josephle> arkeet: I've done that before. I believe you don't get a warning
15:59:40 <josephle> oh it does?
15:59:52 <arkeet> I just tried in ghci
16:00:00 <arkeet> 7.6.3, maybe older versions didn't
16:00:02 <josephle> interesting, well I was using an older version
16:00:35 <arkeet> Warning: Fields of `T' not initialised: ...
16:00:55 <arkeet> tomejaguar: I don't think you can successfully apply record updates to undefined.
16:01:03 <arkeet> > data T = T { a :: Int }
16:01:04 <lambdabot>   <hint>:1:1: parse error on input `data'
16:01:07 <arkeet> @let data T = T { a :: Int }
16:01:08 <lambdabot>  Defined.
16:01:12 <arkeet> hm
16:01:15 <arkeet> @let deriving instance Show T
16:01:15 <lambdabot>  Parse failed: StandaloneDeriving is not enabled
16:01:20 <arkeet> oh blah.
16:01:22 <arkeet> @Undefine
16:01:22 <lambdabot> Undefined.
16:01:25 <arkeet> @let data T = T { a :: Int } deriving SHow
16:01:26 <lambdabot>  .L.hs:141:17:
16:01:26 <lambdabot>      Not in scope: type constructor or class `SHow'
16:01:26 <lambdabot>      Perha...
16:01:27 <arkeet> @let data T = T { a :: Int } deriving Show
16:01:28 <lambdabot>  Defined.
16:01:29 <arkeet> okay.
16:01:37 <arkeet> > T {a = 1}
16:01:38 <lambdabot>   Ambiguous occurrence `a'
16:01:38 <lambdabot>  It could refer to either `L.a', defined at L.hs:1...
16:01:42 <arkeet> > T {L.a = 1}
16:01:46 <lambdabot>   mueval-core: Time limit exceeded
16:01:49 <arkeet> > T {L.a = 1}
16:01:53 <lambdabot>   mueval-core: Time limit exceeded
16:01:54 <arkeet> =(
16:02:05 <arkeet> > T {L.a = 1}
16:02:08 <lambdabot>   T {a = 1}
16:02:10 <arkeet> > (undefined :: T) {L.a = 1}
16:02:13 <lambdabot>   *Exception: Prelude.undefined
16:02:18 <arkeet> as I thought.
16:02:24 <arkeet> it has to match on the constructor before it can update.
16:02:35 <arkeet> and of course, matching on undefined is an error.
16:02:35 <elliott> you can if it's a newtype.
16:02:42 <arkeet> of course.
16:02:58 <arkeet> @let newtype N = N {blah :: Int}
16:02:59 <lambdabot>  Defined.
16:03:03 <arkeet> > undefined { blah = 5 }
16:03:04 <lambdabot>   No instance for (GHC.Show.Show L.N)
16:03:04 <lambdabot>    arising from a use of `M996284455.sh...
16:03:07 <arkeet> oh great.
16:03:13 <arkeet> @let newtype N' = N' {blah :: Int} deriving Show
16:03:14 <lambdabot>  .L.hs:145:17:
16:03:14 <lambdabot>      Multiple declarations of `blah'
16:03:14 <lambdabot>      Declared at: .L.hs:1...
16:03:17 <arkeet> @let newtype N' = N' {blah' :: Int} deriving Show
16:03:18 <lambdabot>  Defined.
16:03:19 <arkeet> > undefined { blah' = 5 }
16:03:22 <lambdabot>   N' {blah' = 5}
16:03:28 <tomejaguar> That's interesting
16:03:30 <josephle> fancy that
16:03:31 <tomejaguar> I wouldn't have expected that
16:03:36 <arkeet> well, it makes sense.
16:03:39 <tomejaguar> Does it?
16:03:47 <arkeet> N' undefined = undefined
16:03:50 <arkeet> because it's a newtype.
16:03:58 <tomejaguar> No, I mean I wouldn't have expected the first one to fail
16:03:59 <WanderingMonad> Hi, #haskell! Post-LYAH newbie here. I'm having an issue running some of the book's code -- anyone willing to take a quick look?
16:04:01 <arkeet> the constructor is always "there"
16:04:03 <arkeet> oh, I see.
16:04:11 <arkeet> well, for data types, it's still possible to have multiple constructors.
16:04:13 <WanderingMonad> Gah...
16:04:18 <FreeFull> :t blah
16:04:19 <lambdabot> N -> Int
16:04:20 <tomejaguar> That itself is very weird!
16:04:30 <tomejaguar> How can you have record syntax with multiple constructors?
16:04:30 <WanderingMonad> s/the book's code/Write Yourself a Scheme's
16:04:33 <tomejaguar> Surely that's meaningless
16:04:34 <FreeFull> :t Z
16:04:35 <lambdabot> Not in scope: data constructor `Z'
16:04:43 <arkeet> tomejaguar: no, it just makes the accessors into partial functions
16:04:48 <arkeet> that fail when the constructor doesn't match
16:04:54 <tomejaguar> Yeah
16:05:02 <tomejaguar> Seems bad to me
16:05:03 <tomejaguar> oh well
16:05:10 <tomejaguar> Thanks for the explanation
16:05:16 <arkeet> @let data Weird = A {foo :: Int} | B {foo :: Int, bar :: Bool} deriving (Eq,Show)
16:05:17 <lambdabot>  Defined.
16:05:23 <FreeFull> Sound.ALSA.Mixer makes use of it for PerChannel
16:05:54 <arkeet> > (foo (A 5), foo (B 3 True), bar (B 3 True), bar (A 5))
16:06:31 <arkeet> uh
16:06:34 <arkeet> > foo (A 5)
16:06:34 <josephle> WanderingMonad: throw it up on lpaste
16:06:34 <FreeFull> > 5
16:06:34 <WanderingMonad> josephle: Will do, one sec!
16:06:35 <lambdabot>   (5,3,True,*Exception: No match in record selector bar
16:06:36 <lambdabot>   5
16:06:38 <lambdabot>   5
16:06:41 <arkeet> there we go.
16:06:58 <FreeFull> lambdabot was stuck in a time pocket or something
16:07:06 <tomejaguar> Now that's /very/ weird and magic
16:07:16 <arkeet> but yeah, partial functions are not nice, and as a corollary, record syntax with multiple constructors is not nice.
16:09:12 <hpaste> WanderingMonad pasted “WYAS, "Eval., Pt. 2"” at http://lpaste.net/91889
16:09:21 <tomejaguar> arkeet: so what happens if you try to /update/ with foo?
16:09:36 <arkeet> probably the same.
16:09:44 <tomejaguar> > (A 4) { foo = 5 }
16:09:47 <lambdabot>   A {foo = 5}
16:09:59 <tomejaguar> > (B 4 True) { foo = 5 }
16:10:01 <arkeet> i.e. error when the field doesn't exist.
16:10:02 <lambdabot>   B {foo = 5, bar = True}
16:10:09 <WanderingMonad> josephle: On the one hand, I can see why GHC might get confused by the "overlap", but unless I've missed something, I don't think they actually do...
16:10:14 <arkeet> > (A 4) {bar = True}
16:10:17 <lambdabot>   *Exception: <interactive>:3:1-18: Non-exhaustive patterns in record update
16:10:17 <tomejaguar> and if the type of foo doesn't match I guess that doesn't type check
16:10:32 <tomejaguar> yes
16:10:33 <arkeet> well, you can't have fields of different types with the same name.
16:10:38 <arkeet> that's an error when declaring the type.
16:10:41 <tomejaguar> indeed
16:10:47 <tomejaguar> ok record syntax is even odder than I thought
16:11:04 <arkeet> just don't use it with multiple constructors ;)
16:11:11 <josephle> WanderingMonad: if I'm reading it correctly, the pattern right before your broken one will most definitely match [Atom "if", pred,...]
16:11:39 <josephle> WanderingMonad: try moving that pattern above the (Atom func : args) one
16:11:45 <josephle> your broken one that is
16:11:55 <tomejaguar> yeah but the reason I use Haskell is that the compiler doesn't let me do weird things
16:12:00 <tomejaguar> unless they're record syntax
16:12:15 <arkeet> it's no more weird than head :: [a] -> a
16:12:21 <tomejaguar> agreed
16:12:28 <arkeet> I think.
16:13:09 <WanderingMonad> josephle: Hell, I think you're right -- GHC throws me the book's error message for bad [Atom func : args] calls...I'll edit the lpaste with that code so you can see it.
16:13:37 <hpaste> WanderingMonad revised “WYAS, "Eval., Pt. 2"”: “No title” at http://lpaste.net/91889
16:14:57 <WanderingMonad> josephle: Weirdly enough, I don't think the book actually says you're supposed to replace the [func : args] matcher with the if-clause one.
16:15:06 <josephle> WanderingMonad: yep, they're overlapped. You should move the //FIX ME// case above the (List (Atom func : args)) case
16:16:18 <josephle> WanderingMonad: the func case is the catch-all after you're sure the List isn't either a quote or an 'if'
16:17:23 <WanderingMonad> josephle: That's exactly what it was. :) Thanks for your help!
16:17:37 <josephle> WanderingMonad: no problem :)
16:18:50 * WanderingMonad is off to learn some more Haskell so he can be less of a nublet in the future...
16:20:06 <FreeFull> I am pondering about messing around with GADTs just to blow GHC's brain
16:29:26 <adnap> @hoogle a -> b -> b
16:29:26 <lambdabot> Prelude seq :: a -> b -> b
16:29:26 <lambdabot> GHC.Conc.Sync par :: a -> b -> b
16:29:26 <lambdabot> GHC.Conc par :: a -> b -> b
16:29:54 <adnap> > seq undefined 3
16:29:55 <lambdabot>   *Exception: Prelude.undefined
16:30:18 <tac-tics> > seq 3 undefined
16:30:19 <lambdabot>   *Exception: Prelude.undefined
16:30:24 <adnap> > const 3 undefined
16:30:25 <lambdabot>   3
16:30:26 <luite> putStrLn ('a':undefined) -- should this print the 'a' if the output is buffered?
16:30:27 <tac-tics> (You just can't win in this world)
16:30:42 <monochrom> if you plan to blow GHC's brain, be careful not to blow your brain first :)
16:30:53 <adnap> > par undefined 3
16:30:54 <lambdabot>   Not in scope: `par'
16:30:54 <lambdabot>  Perhaps you meant one of these:
16:30:54 <lambdabot>    `Sym.var' (imported...
16:30:58 <Cale> luite: yes
16:31:10 <Cale> luite: It should print it immediately before the error message
16:31:13 <monochrom> the recent Monad Reader article on GADT is pretty nice
16:31:14 <adnap> > (flip const) undefined 3
16:31:15 <lambdabot>   3
16:31:29 <adnap> Is there a function in Prelude with the defintion "flip const"?
16:31:40 <luite> Cale: yeah i thought so too, but it doesn't, only when you disable buffering it prints it
16:32:22 <tac-tics> > snd (,) 2 3
16:32:23 <lambdabot>   Couldn't match expected type `(a0, a2 -> a3 -> t0)'
16:32:23 <lambdabot>              with actua...
16:32:24 <Cale> adnap: No, but it's the same thing as const id
16:32:37 <tac-tics> > snd . (,) $ 2 3
16:32:38 <lambdabot>   Couldn't match type `b0 -> (a0, b0)' with `(a1, c0)'
16:32:38 <lambdabot>  Expected type: a0 -> ...
16:32:58 <nooodl> > (snd . (,)) 2 3
16:32:59 <lambdabot>   Couldn't match type `b0 -> (a0, b0)' with `(a1, a2 -> t0)'
16:32:59 <lambdabot>  Expected type: ...
16:33:10 <Cale> luite: Oh, interesting
16:33:10 <nooodl> > (snd .: (,)) 2 3
16:33:11 <lambdabot>   Not in scope: `.:'
16:33:11 <lambdabot>  Perhaps you meant one of these:
16:33:11 <lambdabot>    `.' (imported from D...
16:33:12 <elflord> how to turn a list of [IO Text]  to [Text]
16:33:20 <nooodl> huh it isn't? i thought lambdabot had that
16:33:20 <elflord> ?
16:33:23 <Cale> luite: I guess I can see why that might be
16:33:35 <geekosaur> elflord, best you can manage there is IO [Text]
16:33:39 <Cale> elflord: sequence
16:33:40 <geekosaur> @quote /bin/ls
16:33:40 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
16:33:41 <adnap> Cale: Whoa, I don't understand what is going on
16:33:45 <nooodl> elflord: if you mean IO [Text], sequence
16:33:49 <adnap> Cale: ...with "const id"
16:34:03 <elflord> i mean [IO Text]
16:34:12 <Cale> adnap: Look at the types
16:34:15 <elflord> i've used a list comprehension of functions
16:34:22 <geekosaur> elflord, no, that's what you are starting with
16:34:24 <elflord> IO functions
16:34:26 <geekosaur> you can't make the IO go away
16:34:30 <adnap> Cale: I am
16:34:31 <nooodl> [IO Text] -> IO [Text] is possible
16:34:32 <geekosaur> the best you can do is sequence it to the outside
16:34:36 <nooodl> [IO Text] -> [Text] isn't
16:34:50 <Cale> Well, then you just run the IO [Text] and you have a [Text] (but this is inside of another IO action)
16:34:50 <elflord> ok let me check sequence
16:34:52 <geekosaur> then use >>= to bind over the IO
16:35:20 <Cale> do vs <- sequence myListOfIOActions; doSomethingWith vs
16:35:29 <luite> Cale: it's not that the program quits due to the exception, if you catch it, and the output is buffered, the 'a' still goes missing
16:35:30 <Cale> vs :: [Text]
16:35:38 <luite> main = putStrLn ('a':undefined) `E.catch` \(e::E.SomeException) -> putStrLn "b"
16:35:39 <adnap> @src const
16:35:39 <lambdabot> const x _ = x
16:35:40 <luite> prints just b
16:35:42 <Cale> luite: yeah, I noticed that
16:36:02 <geekosaur> hrm. I would expect stdout to get flushed eventually
16:36:17 <luite> geekosaur: if the 'a' was copied to the buffer it would have to appear before the 'b'
16:36:20 <geekosaur> no promises as to when, or if it ends up somehow interleaved with stderr
16:36:27 <luite> both go to stdout here
16:36:28 <Cale> This is something we need Simon Marlow for :)
16:37:31 <geekosaur> or maybe just a close look at what putStrLn is up to
16:38:13 <maurer> luite: My guess would be that under the surface putStrLn might try to grab whole chunks
16:38:14 <adnap> const id _ = id is the same as (\x y -> id y)
16:38:15 <geekosaur> havr to admit I'd expect at least the 'a' to end up in an output buffer though
16:38:22 <maurer> luite: e.g. if it does something like (x1:x2:x3:x4:x5:x6:x7:x8:rest) and then sends them all out
16:38:23 <Cale> I think the issue is that writeBlocks doesn't protect itself from the possible error, and ends up not committing.
16:38:43 <maurer> @src putStrLn
16:38:43 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
16:38:49 <maurer> @src putStr
16:38:49 <lambdabot> putStr s  = hPutStr stdout s
16:38:49 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO-Handle-Text.html#writeBlocks
16:39:06 <geekosaur> mauere, @src has nothing to do with what ghc actually does
16:39:21 <luite> Cale: yeah that seems to be it
16:39:22 <geekosaur> er, maurer
16:39:29 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO-Handle-Text.html#hPutStr -- you can see how writeBlocks gets invoked here in hPutStr'
16:39:41 <geekosaur> mostly I think it's lifted from the haskell98 report
16:40:46 <luite> Cale: perhaps not commitBuffer, it doesn't need to flush (no newline)
16:41:08 <adnap> What are you guys talking about?
16:41:23 <luite> adnap: buffered putStrLn loses output if it gets an exception
16:42:22 <adnap> luite: Even if you recover from the exception?
16:42:27 <luite> adnap: yes
16:42:30 <adnap> Oh
16:42:49 <adnap> luite: I guess we agree that shouldn't happen?
16:43:13 <Cale> luite: well, it should call commitBuffer without the flush argument set
16:43:44 <luite> oh right
16:44:31 <adnap> In "putStr ('a':undefined)", where is the recovery?
16:44:44 <luite> main = putStrLn ('a':undefined) `E.catch` \(e::E.SomeException) -> putStrLn "b"
16:44:47 <luite> prints b
16:44:53 <adnap> luite: Ah
16:45:09 <Cale> btw, you can write \(SomeException e) -> ...
16:45:44 <adnap> I think in that example you can just write const (putStrLn "b")
16:46:02 <Cale> adnap: no, it needs to know which type of exception to catch
16:46:11 <adnap> Cale: Oh
16:46:34 <adnap> Cale: Why not all of them?
16:46:40 <Cale> That's what SomeException is for
16:47:14 <Cale> Even if you're catching all of them, you have to be explicit about that, because it needs to resolve which instance of the Exception class is being used.
16:47:54 <Cale> catch :: Exception e => IO a -> (e -> IO a) -> IO a
16:48:15 <nooodl> what do the "some" and "many" functions in Control.Applicative do, generally?
16:48:19 <Cale> Since e doesn't occur in the result type, if it's ambiguous, there's no way for it to be resolved later.
16:48:47 <adnap> Cale: Why can't it work for any e that is an instance of Exception?
16:48:48 <Cale> nooodl: In the context of parsing libraries,  many p  will be a parser which parses zero or more copies of p
16:48:59 <Cale> nooodl: and  some p  will be a parser which parses one or more copies of p
16:49:13 <Cale> adnap: It can, but it has to know which e
16:49:24 <Cale> adnap: So that it can pick the instance of Exception
16:49:33 <Cale> eventually
16:49:35 <nooodl> ah, is that all they're defined to do?
16:49:50 <Cale> nooodl: Well, they're generalised to any Alternating instance
16:49:53 <Cale> nooodl: But yes.
16:50:06 <Cale> er, Alternative*
16:50:17 <nooodl> i knew about their use in parsing libraries but wondered if they make sense for [] or Maybe... or anything else
16:50:18 <luite> adnap: all exceptions are wrapped in a SomeException that also has the Typeable dictionary for it
16:50:26 <Cale> nooodl: You can see their usual definitions in the documentation
16:50:34 <Cale> They don't make sense for [] or Maybe
16:50:44 <luite> adnap: with that dict, you can cast it back to the original type
16:50:47 <Cale> But some other Alternative monads would presumably work.
16:51:08 <luite> adnap: (at least exceptions that use the Control.Exception library)
16:51:37 <Cale> I've only ever seen a use for them in the context of parsing
16:52:05 <Cale> Er, Alternative functors* :)
16:52:46 <Cale> Yeah, Control.Exception is quite clever
16:52:51 <Cale> I really like it, actually.
16:53:10 <Cale> You can add your own refinements to the exception hierarchy after the fact.
16:53:27 <adnap> Cale: Is e a class?
16:53:33 <Cale> Exception is a class
16:53:43 <Cale> e is a type of exception
16:53:44 <adnap> Cale: I'm trying to relate this to something I know.
16:53:55 <adnap> Cale: Like, Monad m => m a -> ...
16:53:57 <johnw> adnap: it kind of works like OO-polymorphism with inheritance
16:54:04 <adnap> Here
16:54:04 <Cale> class (Typeable e, Show e) => Exception e where
16:54:08 <luite> adnap: Exception is the class of things that can be converted to/from SomeException
16:54:10 <Cale>   toException :: e -> SomeException
16:54:13 <adnap> It's like one has Monad m => m -> ...
16:54:14 <Cale>   fromException :: SomeException -> Maybe e
16:54:31 <Cale> data SomeException = forall e . Exception e => SomeException e
16:55:13 <Cale> Both toException and fromException have default implementations:
16:55:17 <Cale>     toException = SomeException
16:55:17 <Cale>     fromException (SomeException e) = cast e
16:56:03 <Cale> However, you can override these in order to define new "superclasses" to existing sets of exceptions.
16:56:26 <Cale> Or new "subclasses" as well.
16:56:29 <adnap> :t cast
16:56:30 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
16:56:41 <adnap> 0_0
16:56:44 <Cale> That gives Nothing, unless the types are the same.
16:57:15 <Cale> This gives you runtime type reflection, basically.
16:58:00 <Cale> You can have something of an unknown Typeable type, and then decide what to do if it's, say, an Integer, vs. what to do if it's something else.
16:58:04 <adnap> It seems like in Exception e => e..., e is a type which is an instance of the Exception class, and this would be analogous to working with the type Maybe, which is an instance of Monad, rather than values of type Maybe
16:58:27 <Cale> hmm?
16:58:35 <Cale> I'm not sure what you're getting at
16:58:42 <Cale> Let me dig up an example...
16:58:45 <adnap> Exception e => e... is analogous to Monad m => m...
16:59:11 <djahandarie> Analogous in that they're syntactically similar?
16:59:16 <adnap> djahandarie: Yes
16:59:25 <djahandarie> Yes, they are syntactically similar. :P
16:59:30 <adnap> Sorry, this is really confusing me
17:00:00 <adnap> What functions have types like Monad m => (m -> b) -> b?
17:00:03 <hpaste> Cale pasted “Refining the IO Exception type” at http://lpaste.net/91892
17:00:17 <djahandarie> adnap, nothing, because m can never be inhabited.
17:00:44 <adnap> But Exception can
17:00:55 <Cale> So, in this module of mine, I define a bunch of more specific versions of the IOError type, each of which is meant to represent just one of the possible kinds of IOError
17:01:13 <djahandarie> 1. Monad m constrains the types the varaible m can be. 2. Monad m is defined in such a way that m must have kind * -> *, and 3. types with kind * -> * cannot be inhabited by values.
17:01:35 <djahandarie> (Those are the steps taken to deduce m cannot be inhabited by values.)
17:01:47 <Cale> and then I add instances of Exception for them, which will cause them to be thrown identically to the underlying IOError
17:02:09 <Cale> but they will only catch the IOErrors which match the appropriate predicate
17:02:19 <adnap> So, Exception and Monad don't have the same number of "sockets"?
17:02:31 <Cale> e.g. AlreadyExists will only be caught if the IOError satisfies isAlreadyExistsError
17:02:57 <Cale> adnap: Monads are type constructors
17:03:20 <Cale> adnap: If m is a monad, then it's a kind error for v :: m, because m :: * -> * rather than *
17:03:29 <Cale> It's like asking whether there's a value of type Maybe
17:03:30 <djahandarie> adnap, I don't know what you mean by that, but Monad m forces m to have kind * -> *, while Exception e forces e to have kind *, which is why we know e can have values.
17:04:00 <adnap> ...
17:04:08 <Cale> adnap: Are you just confused about what typeclasses are about?
17:04:18 <adnap> I understand typeclasses
17:04:31 <Cale> adnap: I'll admit this is *really* fancy if it's one of the first examples you've seen
17:04:36 <adnap> I know Monad is a typeclass
17:04:47 <Cale> Also, things like Show, right?
17:04:49 <adnap> Yeah
17:04:54 <Cale> class Show a where show :: a -> String
17:04:58 <adnap> I have written typeclasses
17:05:00 <Cale> okay
17:05:04 <adnap> Er, instances of typeclasses
17:05:23 <Cale> Okay, so, in the case of Show, the parameter to Show has to have kind *
17:05:30 <Cale> and so it's going to be a type with values
17:05:51 <Cale> with Monad, the parameter m is used as a type level function in the methods, e.g. return :: a -> m a
17:05:54 <Hafydd> instance Show Void where
17:06:11 <Cale> So m itself can't have values, but must be something which takes a type (of kind *) and gives a type (of kind *)
17:06:26 <adnap> "Monad m is defined in such as way that m must have kind * -> *" translates to "Monad Maybe is defined in such a way that Maybe must have kind * -> *". So Maybe has kind * -> *, Since Mabybe Int takes Int -> Maybe Int
17:06:39 <tabemann> I recently read something on how Haskell sucks so bad because it doesn't have parameterized modules (and how horribly limited type classes are), and I'm considering starting a thread on LtU that is with the premise that, in practice, type classes are *better* than parameterized modules (based to a good degree on my experience as an OCaml programmer in the past)
17:07:05 <Cale> adnap: return :: Int -> Maybe Int  would be a specialisation of  return :: (Monad m) => a -> m a
17:07:29 <Cale> tabemann: There's a paper which explains how they're equivalent.
17:07:37 <Cale> tabemann: Of course, they're not quite equivalent in practice
17:07:41 <djahandarie> adnap, your translation was correct. Maybe has kind * -> *. Maybe Int has kind *.
17:07:58 <Cale> Each makes certain things more natural and others less.
17:08:01 <djahandarie> Which is why Maybe Int is inhabited by values, like Nothing and Just 3, Just 5, etc., etc.
17:08:06 <adnap> Maybe has kind * -> *...
17:08:13 <adnap> I don't get it exactly
17:08:18 <Cale> Monad has kind (* -> *) -> Constraint
17:08:23 <tabemann> Cale: from reading the Okasaki book he basically translates his original SML parameterized modules directly into Haskell type classes and instances
17:08:28 <Cale> Show has kind * -> Constraint
17:08:31 <djahandarie> Cale, I think maybe that was a little too soon...
17:08:38 <Cale> Possibly :)
17:08:43 <adnap> Ugggj
17:08:52 <djahandarie> adnap, all that Maybe has kind * -> * means is that it eats another type
17:08:53 <Cale> hehe, sorry if that's confusing
17:08:54 <tabemann> the thing is at least from my own experience parameterized modules are much harder to use *in practice*, especially if one wants to use them nearly as fine-grained as type classes are typically used in Haskell
17:09:00 <c_wraith> Pfft.  Constraint requires imports to even talk about
17:09:27 <djahandarie> adnap, e.g., Maybe Int, Maybe String, etc., etc.
17:09:29 <Cale> c_wraith: Yeah, that's somewhat unfortunate, imo.
17:09:33 <Cale> c_wraith: I think the constraint kind should just be in scope if you turn on the extension.
17:09:40 <adnap> djahandarie: * -> * is like a function from types to types ,right?
17:09:43 <djahandarie> adnap, yup.
17:09:48 <c_wraith> I feel the same about Nat and Symbol with DataKinds
17:09:51 <geekosaur> :k Maybe
17:09:51 <lambdabot> * -> *
17:09:58 <djahandarie> The functions aren't interesting at all, though.
17:09:58 <geekosaur> :k Monad
17:09:59 <lambdabot> (* -> *) -> Constraint
17:10:02 <adnap> So, Maybe has kind * -> * because it takes any type T, and makes Maybe T
17:10:03 <geekosaur> oyyyy
17:10:15 <Hafydd> Is Constraint part of Haskell, or a GHC extension?
17:10:21 <geekosaur> GHC extension
17:10:22 <adnap> Exception has kind * because it... what?
17:10:27 <Cale> :k Exception
17:10:28 <lambdabot> * -> Constraint
17:10:38 <Cale> Exception is similar to Show in that regard:
17:10:40 <Cale> :k Show
17:10:40 <lambdabot> * -> Constraint
17:10:43 <adnap> Exception makes no new type
17:10:46 <arkeet> instances of Exception have kind *
17:10:48 <adnap> It just puts a constraint on the type
17:10:55 <adnap> I get it!
17:10:56 <arkeet> Exception itself is a thing that accepts things of kind *
17:10:58 <Cale> adnap: Monad doesn't make a new type either
17:11:04 <arkeet> (and generates a Constraint)
17:11:06 <Cale> adnap: But instances of Monad do.
17:11:41 <adnap> Cale: Okay, so
17:11:47 <adnap> :t traceShow
17:11:48 <lambdabot> Not in scope: `traceShow'
17:11:52 <adnap> :t putStr
17:11:53 <lambdabot> String -> IO ()
17:11:57 <adnap> No...
17:12:04 <Cale> An instance of Exception is a type whose values we can throw and catch
17:12:10 <Cale> :t Control.Exception.throw
17:12:10 <lambdabot> Exception e => e -> a
17:12:14 <Cale> :t Control.Exception.catch
17:12:14 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
17:12:17 <jmcarthur> tabemann: parameterized modules and type classes have a lot in common, but just can't quite subsume each other. using one to replace the other is painful either way
17:12:17 <Cale> :t Control.Exception.throwIO
17:12:18 <lambdabot> Exception e => e -> IO a
17:12:37 <adnap> I hate this site: http://hoogle.org/
17:12:43 <jmcarthur> tabemann: consider the ByteString mess we have, for example. would be easy to get a handle on with parameterized modules. with type classes, we would have a mess like ListLike
17:12:43 <Cale> why?
17:12:45 <Cale> oh
17:12:47 <Cale> hah
17:12:55 <adnap> Firefox has it saved somehow
17:13:03 <adnap> And I always go there accidentally because it's the first item
17:13:05 <c_wraith> Why are Nat and Symbol crammed in with the DataKinds extension, anyway?  I mean, ok, they are examples of moving values to the type level but..  They're still different.
17:13:12 <djahandarie> adnap, maybe this example will help.    Monad m => m -> Int   is non-sensical, because Monad m has kind (* -> *) -> Constraint which means m has kind * -> * which means the function makes no sense because all types which show up on either side of the arrow need to have kind *.
17:13:23 <Cale> adnap: If you visit the correct one enough times, it should bump the incorrect one down
17:13:29 <adnap> Cale: Nope
17:13:38 <Cale> I believe it sorts by number of visits
17:13:43 <Cale> Or something
17:14:02 <arkeet> Monad m => m -> Int is a kind error.
17:14:20 <arkeet> because m must have kind * -> *, but (->) has kind * -> * -> *
17:14:26 <adnap> djahandarie: In order for something to be an instance of Monad, it must have one socket (or kind * -> *)
17:14:46 <djahandarie> adnap, yes, although I suggest you ditch the socket terminology because no one else uses that :P
17:14:47 <Cale> one type parameter
17:14:52 <adnap> data Foo = Foo can be an Exception
17:15:01 <Cale> That is correct, it can
17:15:10 <Cale> and in fact, all you need to do to make it one is to write
17:15:15 <Cale> instance Exception Foo
17:15:41 <adnap> Isn't it possible to write a function f :: Show s => s -> String, where f = show?
17:15:49 <arkeet> it is.
17:15:59 <Hafydd> How about data Foo = Foo deriving (Exception)?
17:16:05 <Cale> oh, you'll need to add  deriving (Typeable, Show)
17:16:07 <arkeet> Hafydd: Exception isn't a derivable class.
17:16:10 <adnap> So, why does catch need to know which instance of Show it is dealing with? show can deal with any instance of Show
17:16:19 <Hafydd> Why isn't it?
17:16:31 <adnap> Er..
17:16:32 <arkeet> Hafydd: because there is a small, special set of derivable classes.
17:16:35 <arkeet> Exception isn't in it.
17:16:42 <adnap> Why does catch need to know which instance of Exception it is dealing with?
17:16:52 <adnap> show can deal with any instance of Show
17:17:03 <arkeet> adnap: ??
17:17:05 <Hafydd> There was an extension that allowed some kind of generalised deriving.
17:17:10 <arkeet> Hafydd: for newtypes only.
17:17:14 <adnap> :t catch
17:17:15 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
17:17:29 <Cale> adnap: Because which exceptions it will catch depend on it.
17:17:40 <adnap> :t catch const
17:17:41 <lambdabot>     Couldn't match expected type `IO a0'
17:17:41 <lambdabot>                 with actual type `a1 -> b0 -> a1'
17:17:41 <lambdabot>     In the first argument of `catch', namely `const'
17:17:41 <Cale> adnap: *Usually* you don't want to just catch every exception.
17:17:50 <adnap> :t const catch
17:17:50 <lambdabot> Exception e => b -> IO a -> (e -> IO a) -> IO a
17:17:54 <Hafydd> Well, it seems like the kind of thing that should be added to that list.
17:17:58 <Cale> adnap: There is some exceptional case which your handler will know how to handle.
17:19:09 <adnap> Er...
17:19:09 <adnap> :t catch
17:19:09 <Hafydd> We don't want the Python equivalent of "class X (Exception): pass" to be shorter.
17:19:10 <adnap> Why can't a be IO a and b be (e -> IO a) in const :: a -> b -> a?
17:19:11 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
17:19:11 <adnap> Oh
17:19:12 <adnap> Nevermind
17:19:13 <arkeet> lol
17:19:14 <Cale> Hafydd: Exception doesn't really need to be derivable because writing instances of it is so easy. Though, perhaps we could say that any class which wouldn't otherwise be derivable, but for which an empty instance declaration is sufficient because there are default method implementations for every method could be derivable.
17:19:50 <Cale> However, it's common to define classes which have default method implementations which are cyclic -- each member is defined in terms of the last, so that you only have to define one of the bunch.
17:20:10 <Cale> and so deriving one of those with an empty instance would be bad
17:20:15 <djahandarie> :t const :: IO a -> (e -> IO a) -> IO a
17:20:16 <lambdabot> IO a -> (e -> IO a) -> IO a
17:20:23 <adnap> I still don't get why e must be specified in catch
17:20:38 <Cale> adnap: Because we need to know which exceptions to catch!
17:20:40 <arkeet> because the exception type may contain different exception?
17:20:42 <arkeet> s
17:20:45 <adnap> Who cares
17:20:47 <Cale> adnap: We're only going to catch exceptions of type e
17:20:50 <adnap> If you're going to ignore it
17:20:59 <arkeet> how do you know to ignore it?
17:21:09 <adnap> Always ignore it
17:21:12 <arkeet> what?
17:21:18 <Cale> adnap: catch uses fromException internally to determine whether the exception matches or not
17:21:33 <Cale> and so you need to know *which* fromException to use
17:21:58 <adnap> So...
17:21:59 <adnap> :t catch
17:22:00 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
17:22:14 <adnap> Why can't you just take whatever comes in first and produce that?
17:22:21 <arkeet> ??
17:22:34 <Cale> adnap: huh?
17:22:40 <Cale> adnap: I'm confused.
17:23:05 <adnap> Oh, nevermind
17:23:15 <Cale> adnap: Suppose e = AssertionFailed, for instance
17:23:24 <adnap> catch takes the (e -> IO a) you give it and returns the IO a after passing the exception
17:23:36 <Cale> adnap: So, you've written  catch x (\(AssertionFailed s) -> print s)
17:23:55 <Cale> catch *must* supply an AssertionFailed value to your function, or else it's a type error
17:24:20 <adnap> What about catch x (\_ -> print "hello")?
17:24:32 <Cale> That won't work
17:24:33 <adnap> That's a type error?
17:24:36 <arkeet> then GHC will complain about an ambiguous type.
17:24:46 <arkeet> unless you specify the type of the handler.
17:25:05 <Cale> Yes, it's an ambiguous type error, similar in nature to   show . read $ "hello"
17:25:25 <arkeet> Cale: except the latter will accidentally "work" in ghci
17:25:27 <c_wraith> adnap: the reason you can't leave it polymorphic is that the type actually matters. It needs to know what instance of Exception to use.
17:25:45 <Cale> Well, yeah, ExtendedDefaultRules will make that "work" in ghci
17:25:55 <arkeet> =(
17:26:21 <Cale> If you :set -XNoExtendedDefaultRules (that's tab-completable), you can see the actual error
17:26:35 <Cale> You'll get:
17:26:41 <Cale>     No instance for (Show b0) arising from a use of `show'
17:26:44 <Cale> as well as
17:26:48 <Cale>     No instance for (Read b0) arising from a use of `read'
17:27:11 <Cale> Because it doesn't know which type to read, and then it doesn't know which type to show it as :)
17:27:56 <Cale> adnap: Make sense?
17:28:26 <Cale> adnap: So similarly, catch needs to have a specified type in order that it can apply fromException.
17:28:27 <arkeet> if you want to catch *any* exception, you can always catch x ((\_ -> blah) :: SomeException -> IO whatever)
17:28:28 <adnap> Cale: Not yet
17:28:43 <Cale> Since the type of catch doesn't include an e in the result type
17:28:45 <arkeet> but usually you don't want that.
17:28:52 <Cale> The type of exception to be caught can't be determined later
17:29:01 <Cale> It *has* to be determined at the call site of catch
17:29:08 <arkeet> at compile time
17:29:28 <Cale> Not just at compile time, but also it can't be deferred to higher level code
17:29:36 <arkeet> yes
17:30:30 <Cale> Well, I suppose you could awkwardly find a way to make that happen, but that's beside the point :)
17:31:07 <adnap> > let f :: Show s => Int -> (s -> Int) -> Int; f _ _ = 42 in f undefined undefined
17:31:08 <lambdabot>   42
17:31:21 <adnap> :t catch
17:31:22 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
17:31:25 <Cale> If you call catch normally, because you're losing sight of the e type variable, the instance selection needs to be able to take place with the information you've provided by giving the handler function
17:31:50 <Cale> and so if the handler function is too polymorphic, instance selection won't get enough information to be able to pick an instance of Exception
17:31:56 <arkeet> adnap: that only accidentally worked because lambdabot has extended dfault rules (so it picked s = ())
17:31:58 <Cale> so it won't know how to implement fromException
17:33:02 <Cale> Also note that if you had ExtendedDefaultRules on, and you made () into an exception type, you could get  catch x (\_ -> ...) to "work", but it would only catch exceptions of type ()
17:34:15 <adnap> > let f :: Show s => Int -> (s -> Int) -> Int; f x g = g undefined in f undefined (\_ -> 42)
17:34:16 <lambdabot>   42
17:34:21 <adnap> I thin I'm starting to get it
17:34:30 <adnap> The implementation of catch gets to call g
17:35:42 <adnap> Hm...
17:35:44 <arkeet> > let f :: (Show s, Num s, Bounded s) => Int -> (s -> Int) -> Int; f = undefined in f 0 (\_ -> 42)
17:35:45 <lambdabot>   No instance for (GHC.Show.Show s0) arising from a use of `f'
17:35:45 <lambdabot>  The type vari...
17:35:56 <arkeet> The type variable `s' is ambiguous
17:35:57 <arkeet> or something.
17:36:20 <arkeet> (there's no type in the default list that satisfies all those constraints.)
17:36:20 <Cale> adnap: See, fromException :: SomeException -> Maybe e gets to decide whether or not *any* type of exception will be caught as an exception of type e.
17:36:44 <Cale> adnap: This lets you make new types of exception, which if you catch them, you'll also be catching many others which perhaps already existed.
17:36:55 <adnap> I'm slow
17:37:08 <adnap> I haven't read everything you said or posted yet
17:37:27 <Cale> If fromException produces Nothing, then the exception won't be caught by a handler of type e
17:37:43 <Cale> (by a handler looking for exceptions of type e)
17:37:58 <adnap> :t fromException
17:37:58 <lambdabot> Exception e => SomeException -> Maybe e
17:38:13 <Cale> If fromException produces Just v, then the exception handler looking for an exception of type e will catch the exception, and v will be provided to the handler
17:38:16 <arkeet> (and when it's uncaught, it just gets re-thrown.)
17:39:09 <adnap> What is a SomeException?
17:39:13 <arkeet> which lets you use another handler elsewhere. although it's probably better to use something like catches when you have multiple handlers.
17:39:13 <Cale> and so by cleverly defining fromException, you can decide on whole sets of exceptions you want to be caught by a handler of type e, and you can also refine an existing exception type, producing Nothing in cases where the exceptional value doesn't match some conditions you're looking for
17:39:20 <arkeet> adnap: it's an existential type, for "any instance of Exception"
17:39:54 <adnap> Cale: You wrote "fromException (SomeException e)" in http://lpaste.net/91892
17:40:00 <arkeet> data SomeException = forall e. Exception e => SomeException e
17:40:05 <adnap> Ijay
17:40:07 <arkeet> or (maybe more clearly in GADT syntax)
17:40:09 <adnap> Okay
17:40:15 <Cale> adnap: That's right. SomeException is the data constructor for the SomeException type
17:40:18 <arkeet> data SomeException where SomeException :: forall e. Exception e -> SomeException
17:40:33 <adnap> Agh
17:40:43 <Cale> So, if you're not familiar with the IOError type
17:40:44 <arkeet> er, that should be
17:40:48 <arkeet> data SomeException where SomeException :: forall e. Exception e => e -> SomeException
17:41:07 <Cale> It's a type which represents all the various kinds of errors which can happen from the standard IO library
17:41:08 <chexxor> Q: assume I define Person like this - `data Person = Person String Int Thing`
17:41:13 <adnap> SomeException has a thing in it which is an instance of Exception...
17:41:16 <Cale> things like files not existing and stuff like that
17:41:33 <Cale> It was part of Haskell 98, and is kind of sort of legacy, but things still throw IOErrors
17:41:38 <chexxor> Then I say: `brent :: Person` --- Is Person a type constructor here?
17:41:42 <arkeet> adnap: but you don't know which instance it is until you try casting it (which is why Typeable is there)
17:41:45 <arkeet> chexxor: no
17:41:47 <arkeet> it's a type.
17:41:50 <adnap> How can the first instance of Exception be written?
17:41:57 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Error.html#t:IOError -- if you look here
17:42:09 <Cale> You can see that there are a whole bunch of predicates on the IOError type
17:42:14 <chexxor> `brent = Person "Brent" 31 SealingWax` -- And here, Person is a type constructor?
17:42:19 <Cale> letting you test whether the error is a particular sort
17:42:22 <adnap> fromException has to deal with SomeException's, which contain instances of Exception
17:42:25 <arkeet> chexxor: it's a constructor.
17:42:28 <Cale> these predicates were also in Haskell 98
17:42:32 <latro`a> data constructor
17:42:32 <adnap> and fromException is a member of Exception
17:42:33 <arkeet> it's a value/data constructor, not a type constructor.
17:44:30 <arkeet> type constructors are things like Maybe
17:44:31 <arkeet> that take types and make new types
17:44:31 <latro`a> it can be confusing because frequently type constructors and data constructors have the same name
17:44:32 <latro`a> Maybe is nice for explanation because it doesn't do this
17:44:32 <Cale> adnap: My goal with this module was to show how to make refinements of the IOError type for representing one of these sorts of errors at a time
17:44:32 <adnap> Cale: I don't know about the IOError type.
17:44:33 <arkeet> Cale: ah, by writing your own non-default Exception instances?
17:44:33 <adnap> Cale: I have never used exceptions
17:44:33 <Cale> adnap: Well, look at the documentation I just linked
17:44:33 <Cale> arkeet: yes
17:44:33 <adnap> Cale: I am lookign at your example
17:44:33 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Error.html#t:IOError
17:44:33 <arkeet> (and Typeable, I suppose)
17:44:33 <Cale> ^^
17:44:34 <Cale> arkeet: The standard instance of Typeable is good enough
17:44:34 <arkeet> oh
17:44:34 <Cale> http://lpaste.net/91892
17:44:35 <Cale> is my code
17:44:36 <chexxor> Type constructors are only seen in type definitions?
17:44:49 <Cale> chexxor: They're only seen in types, yes.
17:44:53 <arkeet> ah right, it's only the default fromException that uses cast.
17:45:11 <adnap> :t error
17:45:12 <lambdabot> [Char] -> a
17:45:15 <arkeet> then, I wonder why Typeable is a superclass of Exception?
17:45:30 <arkeet> maybe because we didn't have default signatures back then.
17:45:47 <adnap> Oh...'kay
17:45:52 <adnap> :t ioError
17:45:53 <lambdabot> IOError -> IO a
17:46:16 <Cale> adnap: For example, if you try to hGetLine on a handle which has already reached the end of file, it will throw an IOError, say e, and isEOFError e will be True
17:46:45 <Cale> adnap: and ioeGetHandle e will let you get the Handle that it occurred on
17:46:47 <adnap> Cale: So, everything after will fail if the exception is not caught
17:46:51 <Cale> and various other things will be set up
17:46:58 <adnap> Cale: It's like calling exit
17:46:58 <Cale> that's right
17:47:15 <Cale> So, if we want to catch this error condition
17:47:31 <Cale> We could go and use catch with the type e set to IOError
17:47:38 <Cale> but then we'll also catch lots of other errors
17:47:58 <Cale> for example, isFullError, indicating that the disk is full, perhaps
17:48:22 <adnap> Cale: One can only catch the errors that the IO action throws, right?
17:48:23 <Cale> Well, not likely in a read, but depending on where we put the handler ;)
17:48:42 <Cale> actually, it's possible for other threads to throw exceptions at us, but we can ignore that, so yeah
17:48:55 <adnap> Cale: So, if an IO action only throws one exception, it's safe to write catch to handle any IOError, expecting that one will only get the one
17:49:10 <adnap> Cale: Oh, I see
17:49:14 <adnap> Cale: (about threads)
17:49:24 <Cale> adnap: That is somewhat true. But! We might not *want* to handle those other errors, and instead re-throw them.
17:49:31 <arkeet> Cale: but aren't those a different type of exception?
17:49:37 <arkeet> AsyncException
17:49:38 <arkeet> or something
17:49:49 <Cale> Rather than doing that explcitly, we can create types which represent the finer exceptions, and only catch the exceptions we're actually looking for
17:49:57 <arkeet> never mind.
17:50:00 <adnap> :t toException
17:50:01 <lambdabot> Exception e => e -> SomeException
17:50:02 <arkeet> I was confused.
17:50:14 <arkeet> and you can throw any type of exception to another thread, I guess.
17:50:15 <arkeet> :T throwTo
17:50:18 <arkeet> :t throwTo
17:50:19 <lambdabot> Exception e => GHC.Conc.Sync.ThreadId -> e -> IO ()
17:50:44 <flazz> is there a term to describe the type that a fold or catamorphism maps to?
17:50:54 <Cale> so looking at the AlreadyExists instance at http://lpaste.net/91892
17:51:00 <Cale> the interesting bit is:
17:51:06 <Cale>   fromException (SomeException e)
17:51:06 <Cale>     | Just ioe <- cast e,
17:51:06 <Cale>       isAlreadyExistsError ioe = Just (AlreadyExists ioe)
17:51:06 <Cale>     | otherwise                = Nothing
17:51:13 <adnap> I am looking at that
17:51:17 <adnap> One thing I don't get is
17:51:29 <adnap> The | * <- *, * = * pattern
17:51:45 <Cale> This will cast the exception e to an IOError type. Just ioe won't match if the exception e isn't an IOError, because that's how cast works.
17:51:52 <Cale> That's a pattern guard
17:52:02 <arkeet> flazz: well, the type underlying an algebra is called its carrier. I dunno if that helps.
17:52:09 <Cale> So, it matches cast e against the pattern  Just ioe
17:52:10 <adnap> Cale: So, all pattern matches must succeed?
17:52:14 <Cale> yeah
17:52:19 <adnap> All the ones between commas
17:52:33 <adnap> Cool
17:52:36 <Cale> Since ioe is being used as an IOError in the next line
17:53:02 <Cale> cast's type will be  cast :: a -> Maybe IOError
17:53:28 <Cale> and only if e actually is an IOError will that Just ioe match, otherwise, we'd get Nothing
17:53:44 <adnap> Cale: I can't find the definition of isAlreadyExistsError
17:53:46 <Cale> Well, it's (Typeable a) => a -> IOError
17:53:54 <Cale> oh, I linked that documentation several times
17:54:10 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Error.html#t:IOError
17:54:11 <adnap> Oh, it's in IOError or something
17:54:16 <flazz> arkeet: so fold on a list means that list is the carrier?
17:54:27 <arkeet> no, the type of its elements.
17:54:45 <arkeet> :t foldr
17:54:46 <lambdabot> (a -> b -> b) -> b -> [a] -> b
17:54:54 <flazz> a is the carrier?
17:54:54 <arkeet> uh
17:55:15 <adnap> Cale: Okay, I understand your example
17:55:19 <Cale> cool :)
17:55:46 <Cale> So, yeah, we create these new types which just match one sort of IOError at a time, even though IOError was this big monolithic exception type
17:55:47 <adnap> Cale: You use a bunch of IOError -> Bool functions on a wrapped up IOError to either return a Just or Nothing for the wrapped up IOError
17:55:52 <Cale> We could also go the other way around
17:56:03 <Cale> and try many different casts
17:56:09 <arkeet> no, that was wrong.
17:56:33 <adnap> Cale: Does one always have to use cast on a SomeException?
17:56:35 <Cale> (and succeed if any of them do)
17:56:44 <adnap> Cale: Er, Exception rathre
17:56:48 <adnap> A value of Exception
17:57:01 <arkeet> :t foldr
17:57:01 <lambdabot> (a -> b -> b) -> b -> [a] -> b
17:57:33 <Cale> adnap: Well, normally, if you have an exception of unknown type, you can apply fromException to it in order to see if the exception matches, but as we've seen, fromException is allowed to be clever
17:57:45 <Cale> adnap: cast is less clever, it only looks for an exact match in types
17:58:08 <adnap> So...
17:58:15 <adnap> You could do isJust (fromException e)
17:58:18 <Cale> I could have used fromException just as well as I used cast here
17:58:20 <Cale> yeah
17:58:33 <adnap> I don't understand why cast is different
17:58:34 <Cale> Well, if I used isJust, I'd have to use fromJust
17:58:41 <arkeet> [a] is the universal F-algebra for some F (namely, F b = (a * b) + 1)
17:59:10 <arkeet> (a -> b -> b, b) is some other F-algebra.
17:59:12 <Cale> adnap: cast has nothing to do with exceptions specifically
17:59:17 <Cale> adnap: It's part of Typeable
17:59:18 <arkeet> their carries are [a] and b, respectively.
17:59:21 <arkeet> carriers.
17:59:32 <Cale> cast :: (Typeable a, Typeable b) => a -> Maybe b
17:59:54 <arkeet> I'm probably screwing something up so I'll quit.
18:00:07 <arkeet> tbh I rarely ever hear the term "carrier"
18:00:28 <arkeet> hm, I already messed it up. a lot.
18:00:46 <arkeet> it doesn't help that one usually refers to an algebra and its carrier by the same name.
18:00:49 <Cale> Typeable lets us get a value level representation of the type of something, and cast (which is implemented using unsafeCoerce) will check whether these representations match and then unsafeCoerce the thing.
18:00:51 <adnap> fromException could return Just values for only select values of an instance of type Exception, where cast will succeed on any value with some type which is an instance of Exception
18:00:55 <arkeet> (leaving the algebra structure implicit)
18:01:10 <monochrom> "carrier" refers to the object. but of course the arrow is more interesting
18:01:21 <arkeet> yeah.
18:01:26 <arkeet> it's usually easier to just name the object though ;)
18:01:32 <Cale> cast will succeed with Just v if and only if the type of its argument matches the type which v needs to be
18:02:06 <Cale> and that distinction is made based on runtime type information from the Typeable class
18:02:16 <Cale> rather than compile time type information
18:02:21 <arkeet> did anything come of the proposal for  class Typeable where blah :: Maybe (Is a b) ?
18:02:38 <adnap> :t SomeException
18:02:39 <lambdabot> Exception e => e -> SomeException
18:02:52 <Cale> :t cast
18:02:53 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
18:03:00 <Cale> :t typeOf
18:03:01 <lambdabot> Typeable a => a -> TypeRep
18:03:07 <arkeet> or something.
18:03:28 <Cale> arkeet: That's an interesting proposal.
18:03:39 <adnap> Er...
18:03:45 <arkeet> Cale: I forget where it was, but you can ask shachaf about it.
18:03:46 <tabemann> just having dynamic type under the hood reminds me too much of Java
18:04:01 <Cale> tabemann: Well, it's more above the hood.
18:04:12 <arkeet> oh yeah.
18:04:13 <Cale> tabemann: Typeable isn't really even built in! :)
18:04:20 <arkeet> blah :: Typeable a, Typeable b => Maybe (Is a b)
18:04:21 <arkeet> or something
18:04:33 <Cale> Though the instance-deriving mechanism for it is.
18:04:42 <arkeet> although it really will be built-in in 7.8
18:04:43 <Cale> and cast kind of is, in that it uses unsafe primitives
18:04:52 <tabemann> just that cast uses unsafeCoerce scares me, as what stops you from just creating your own Typeable instances
18:05:04 <arkeet> tabemann: that's why that's disallowed in safe haskell
18:05:08 <tabemann> and making two types seemingly match when they really don't
18:05:13 <arkeet> and in fact it will be illegal in ghc 7.8
18:05:19 <tabemann> good
18:05:19 <Cale> tabemann: I think they might eventually disallow writing Typeable instances by hand altogether
18:05:22 <Cale> yeah
18:05:31 <arkeet> well, illegal because Typeable will be a black box.
18:05:36 <tabemann> Typeable needs to be something built into the runtime and compiler itself
18:05:48 <arkeet> it will be!
18:05:56 <arkeet> but it's cute how it doesn't have to be.
18:05:58 <Cale> It just needs to have its methods hidden by the module boundary, but still derivable
18:06:05 <danharaj> edwardk: Categories are monads in the 2-category of spans of some ambient category. *mind blown*
18:06:08 <adnap> Do you work on GHC or something?
18:06:10 <tabemann> it's not having to be is only possible thanks to the sin that is unsafeCoerce
18:06:16 <Cale> adnap: I don't.
18:06:23 <Cale> adnap: But I read GHC's code from time to time
18:06:36 <arkeet> danharaj: that's not so bad when you realize that quivers are (endo)spans in that same category.
18:06:46 <Cale> Mostly when I want to answer a question definitively about how something currently works :)
18:06:55 <arkeet> so that categories are just monoid objects in quivers.
18:07:12 <danharaj> arkeet: I just find it thoroughly satisfying.
18:07:17 <arkeet> =)
18:07:35 <arkeet> monads are just lax bifunctors out of 1
18:07:36 <arkeet> !
18:07:42 <arkeet> re
18:07:43 <arkeet> er
18:07:45 <danharaj> yes
18:07:45 <arkeet> functors out of the bicategory 1
18:07:50 <Cale> tabemann: But at least, the typeclass machinery is a rather nice way to have runtime type information which travels *separately* from the values.
18:08:11 * tabemann wonders just where he learns all this category theory stuff, when his own background is merely basic algebra, discrete math, and calculus...
18:08:14 <danharaj> arkeet: I knew what you meant, did not even pick up on the inaccuracy.
18:08:26 <arkeet> heh
18:08:44 <arkeet> wikipedia and nlab are things.
18:08:54 <adnap> fromException (SomeException e) | isJust (fromException e) = Just (BlahException 5) | otherwise = Nothing relies on e
18:09:03 <adnap> e's fromException to return a Just
18:09:17 <tabemann> Cale: it certainly is
18:09:25 <Cale> adnap: See, that's going to be ambiguous
18:09:32 <chexxor> thanks for the constructor help, I found the haskell wiki has a page for constructors
18:09:45 <Cale> adnap: Right, I should have said, you can't use isJust
18:09:45 <tabemann> well, and some propositional logic too...
18:09:47 <adnap> And cast would tell you that e is a specific instance of Exception and doesn't rely on its fromException
18:09:49 <danharaj> arkeet: I can never keep track of lax, pseudo, etc. functors, actually.
18:10:00 <Cale> adnap: Because again, you need to know which fromException is being used
18:10:04 <arkeet> lax just means the things that are normally isomorphisms don't have to be.
18:10:46 <Cale> adnap: and that code doesn't give the compiler any information about which fromException to use
18:10:46 <adnap> Cale: Could you just put a type signature in?
18:11:27 <Cale> yes, you could
18:11:30 <arkeet> lax monoidal functor, etc
18:11:31 <Cale> You could explicitly say what type the result of fromException e had
18:11:31 <adnap> Cale: And you would catch a subset of the exceptions that you would catch with cast, right?
18:11:40 <adnap> Cale: 'Cause cast would catch exceptions which would return Nothing when passed to fromJust
18:11:42 <Cale> Well, sort of :)
18:11:44 <Cale> By overriding toException, you can add new exception types which look like old ones as well.
18:11:55 <Cale> and will be caught by old exception handlers
18:12:09 <Cale> Well, my types are examples of that :)
18:12:17 <adnap> :t toException
18:12:18 <lambdabot> Exception e => e -> SomeException
18:12:36 <Cale> An exception handler which is looking for an IOError will catch an AlreadyExists exception that's thrown, for example
18:12:49 <Cale> Because  toException (AlreadyExists e) = toException e
18:12:54 <adnap> I see
18:12:57 <Cale> and that e is an IOError
18:12:58 <danharaj> arkeet: right, but I forget which direction is lax and which is colax.
18:13:00 <adnap> Wait!
18:13:04 <danharaj> And I also forget if oplax is the same thing as colax.
18:13:32 <adnap> Cale: How does the original instance of Exception implement toException, with no other instances toException to use?
18:13:46 <arkeet> danharaj: I've never heard of colax.
18:14:08 <arkeet> and yeah, good luck figuring out lax/oplax except by knowing already.
18:14:10 <arkeet> :(
18:14:19 <Cale> adnap: Which one do you mean by "the original instance"?
18:14:27 <Cale> The one for IOError?
18:14:44 <adnap> Cale: Suppose there are no instances of Exception yet and you are writing the first one. How do you implement toException?
18:15:07 <arkeet> adnap: you don't need any existing instances to write it.
18:15:09 <elliott> you write instance Exception SomeException
18:15:14 <arkeet> ^
18:15:15 <elliott> toException is then exceptionally easy.
18:15:19 <arkeet> the defaults are enough.
18:15:20 <elliott> wow, that pun was unintentional.
18:15:39 <arkeet> elliott: it was probably subconsciously intentional.
18:15:44 <elliott> yes
18:15:44 <adnap> SomeException is an instance of Exception?
18:15:47 <arkeet> yes
18:15:48 <elliott> yes
18:15:52 <arkeet> where toException = id and fromException = Just
18:16:00 <adnap> What?!
18:16:03 <adnap> Isn't that cheating
18:16:07 <danharaj> why is it cheating
18:16:08 <arkeet> how is it cheating?
18:16:13 <Cale> adnap: The *default* instance, which is a perfectly good one 99% of the time, is  toException = SomeException,  fromException (SomeException e) = cast e
18:16:26 <Cale> That's what you get if you just write:
18:16:26 <adnap> 'Cause if you're writing an instance of Exception for SomeException, you can't use the fact that it is an Exception, right?
18:16:35 <hpaste> applicative pasted “vector-bytestring benchmarks” at http://lpaste.net/91893
18:16:37 <Cale> instance Exception MyNewExceptionType
18:16:37 <arkeet> sure you can!
18:16:39 <arkeet> it's recursive!
18:16:56 <Cale> For SomeException, toException is id
18:16:58 <adnap> Can you do that with a Monad instance? For example, use bind in the definition of bind?
18:17:02 <Cale> instance Exception SomeException where
18:17:02 <Cale>     toException se = se
18:17:02 <Cale>     fromException = Just
18:17:16 <danharaj> adnap: bind is recursive in many monads
18:17:19 <Cale> adnap: You certainly can!
18:17:31 <arkeet> and often do!
18:17:38 <danharaj> Cale: we need to talk about kidnapping you and bringing you to NYC for a couple of months :3
18:17:43 <adnap> Oh...
18:17:43 <arkeet> class methods aren't any more special than regular functions.
18:17:45 <Cale> danharaj: I know...
18:17:53 <arkeet> they can be recursive. and even mutually recursive.
18:17:56 <danharaj> Cale: if you need help kidnapping yourself I know a guy...
18:18:12 <shachaf> danharaj: You're kidnapping Cale?
18:18:14 <shachaf> Not if we get to him first!
18:18:54 <adnap> :t catch
18:18:55 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
18:18:59 <Cale> danharaj: I've been really bad about interacting with the other people in the company lately, have had lots of distractions at home here. It would probably be good for me to go and visit for a while. I want to be back in Canada around January/February though, since a friend of mine is coming to stay in Ottawa, and so she'll be able to visit if I'm there :)
18:19:23 <Cale> But I'd need to arrange a place to stay in NYC
18:19:24 <danharaj> Cale: That is understandable.
18:19:31 <adnap> Who are company buddies?
18:19:44 <adnap> Er... coworkers
18:20:01 <danharaj> Cale: I've been thinking about moving into the city anyway so if you could provide being a roommate for a few months that could possibly work out for everyone involved.
18:20:05 <tabemann> cow orkers
18:20:16 <Cale> danharaj: Yeah, that sounds possible :)
18:20:29 <danharaj> I'll message you tomorrow when we can be more concrete :p
18:20:56 <danharaj> BTW watch out for edwardk he might try to intercept you en route and take you to Boston.
18:21:02 * arkeet is more discrete.
18:21:10 <Cale> ahaha
18:21:14 <arkeet> heh
18:21:31 <danharaj> Currently the only thing keeping him away are Canadian Mounties and Bears.
18:21:52 <arkeet> where is Cale now?
18:21:54 <adnap> Is elliott edwardk?
18:21:57 <arkeet> no
18:22:06 <arkeet> but maybe he should be!
18:22:10 <danharaj> It is possible?
18:22:19 <edwardk> =P
18:22:43 <adnap> danharaj: It's not
18:22:44 <danharaj> The universe makes more sense when you identify people who understand lense as a single entity.
18:22:55 <Cale> shachaf = edwardk
18:22:58 <adnap> If they have different numbers of atoms...
18:23:06 <adnap> You can't create or destroy any
18:23:10 <edwardk> yeah, but it makes me/shachaf/elliott seem like a rather insane composite entity
18:23:14 <edwardk> i guess that isn't far off
18:23:17 <arkeet> adnap: it's easy to create and destroy atoms.
18:23:20 <arkeet> it happens all the time.
18:23:30 <adnap> arkeet: No, only change their energy
18:23:30 <danharaj> edwardk: you are each a lens into the whole thing
18:23:45 <arkeet> adnap: no...
18:24:01 <Cale> A friend of mine used to IRC as multiple people and have conversations.
18:24:18 <arkeet> adnap: number of atoms is not a conserved quantity.
18:24:24 <shachaf> Twist: Cale is this friend (and so is arkeet).
18:24:26 <arkeet> if it was, nuclear fusion/fission wouldn't exist.
18:25:00 <Cale> Guys, what if we're all the same person, and we're deluding ourselves?
18:25:22 <shachaf> Which person? I could believe that we're all arkeet.
18:25:25 <tabemann> on one board I've been on in the past we would insist that we are all the same person to new users
18:25:35 <tabemann> s/are/were
18:25:50 <arkeet> shachaf: it doesn't matter which representative you choose for a quotient.
18:26:24 <Cale> adnap: So, you can see from the instance for SomeException that fromException will always produce a Just, and so trying to catch a SomeException will always succeed.
18:26:35 <Cale> (if there's any exception to be had at all)
18:26:50 <shachaf> arkeet: But "is" isn't an equivalence relation.
18:27:05 <Cale> adnap: and of course, its toException doesn't have to do anything.
18:27:21 <arkeet> shachaf: but is is is?
18:27:47 <adnap> Cale: I see
18:30:02 <adnap> > putStr "hi" `catch` (\_ -> putStr "there")
18:30:03 <lambdabot>   No instance for (GHC.Exception.Exception e0)
18:30:03 <lambdabot>    arising from a use of `Cont...
18:30:05 <adnap> I can't write that
18:30:51 <Cale> But you *can* write  putStr "hi" `catch` (\(SomeException e) -> putStr "there")
18:30:53 <adnap> > putStr "hi" `catch` (\(SomeException e) -> putStr "there")
18:30:54 <lambdabot>   <IO ()>
18:31:04 <adnap> Why?!
18:31:06 <adnap> Ahhhh
18:31:21 <haasn> ambiguous type
18:31:23 <Cale> The same reason I've been telling you over and over for the last couple hours :)
18:31:42 <adnap> 'Cause catch needs to know what exceptions to pass or something
18:31:53 <Cale> Yeah, it needs to know which fromException to use
18:32:06 <adnap> :t fromException
18:32:07 <lambdabot> Exception e => SomeException -> Maybe e
18:32:23 <adnap> Why does it use fromExcetion?
18:32:26 <Cale> and thus which exceptions will actually be caught and handled
18:32:39 <danharaj> edwardk: were you aware that your Rift of two profunctors is the right adjoint of profunctor composition?
18:32:48 <Cale> It uses fromException to decide whether the exception is one which the handler is interested in, based on the type of the handler
18:32:58 <NemesisD> i've got some confusion about how stm works. in something like a TChan, readTChan blocks until it can get something out of the chan. in the implementation it looks like it retries when it is empy
18:33:02 <adnap> Cale: Okay, I get it
18:33:03 <Cale> The handler you wrote at first is too polymorphic, so it wouldn't know which instance to pick
18:33:21 <NemesisD> when it retries is it actively doing anything, using CPU time or should i not interpret retry like that
18:33:42 <edwardk> danharaj: no, but it sounds plausible
18:33:59 <adnap> Cale: Thank you for your godly patience
18:34:03 <haasn> when an expression ‘retries’ it discards all potential writes and waits for something else to change
18:34:12 <danharaj> edwardk: I bumped into it in an n-cat cafe post about profunctor equipments and I said "Hey I know what you are!".
18:34:14 <edwardk> danharaj: feel free to toss together docs to that effect in Data.Profunctor.Rift. the 3 other people who can read them will love that =)
18:34:19 <danharaj> hahaha
18:34:21 <NemesisD> haasn: ok so its an inactive wait kinda thing
18:34:28 <haasn> NemesisD: that is my understanding of it, yes
18:34:47 <edwardk> in all seriousness. i used to underestimate the pedagogical benefit of having good examples like that around
18:34:50 <haasn> NemesisD: “The implementation may block the thread until one of the TVars that it has read from has been udpated. (GHC only) ”
18:34:54 <edwardk> because most of this stuff is nigh ungoogleable
18:35:07 <edwardk> and anything that lowers the bar you have to meet to understand it is good
18:35:26 <danharaj> edwardk: To be honest, that coincidence makes me more confused. It's so mysterious.
18:35:38 <NemesisD> oh ok. seems like orElse could be a good choice for me. i've got some code that loops on a TChan, but if a config change comes in (on a TMVar), i need it to stop waiting on that queue to handle that
18:36:19 <NemesisD> hmm actually orElse wouldn't work because the two don't return the same type
18:36:33 <NemesisD> one its STM QueueItem, the other STM Config
18:37:14 <edwardk> gotta run
18:38:21 <fryguybob> NemesisD: You can always use Either or add some other further computation to get them to the same type.
18:38:35 <NemesisD> fryguybob: yeah i was just going to say that. seems pretty slick
18:39:29 <NemesisD> now i just need to go back and actually use TMChan because in real life i'm using a plain old Chan right now ;)
18:41:21 <danharaj> hmmm
18:41:35 <danharaj> this means profunctors over a category form a closed symmetric monoidal category.
18:41:47 <danharaj> Which means they can be a model of linear lambda calculus!
18:42:11 <adnap> danharaj: What is linear lambda calculus?
18:42:28 <danharaj> it is lambda calculus where you are restricted in how you can use your inputs.
18:43:01 <adnap> danharaj: Does "linear" have anything to do with linear functions?
18:43:12 <arkeet> no.
18:43:13 <arkeet> linear logic
18:43:27 <danharaj> it sort of does
18:43:38 <danharaj> if you have a variable on the lhs then you can only use it once in the rhs.
18:43:38 <tabemann> Nemesis: do liftM Foo (takeTMVar fooTMVar) `orElse` liftM Bar (readTChan barTChan)
18:43:45 <tabemann> NemesisD*
18:43:45 <xenocons> haskell f = map (g . x) . map ( f . n) == map ( (g . x) . ( f . n)) right?
18:43:46 <danharaj> plus more rules for other constructions.
18:43:52 <arkeet> i.e. linear logic
18:44:00 <danharaj> arkeet: right but it's sort of like a linear polynomial
18:44:05 <danharaj> vaguely
18:44:51 <arkeet> I thought the "linear" in linear logic was referring to non-branchiness and such
18:45:07 <danharaj> well isn't that analogous to linear polynomials too? :P
18:45:11 <NemesisD> tabemann: ah so you're lifting into the either monad?
18:45:20 <sclv> at a minimum its a neat coincidence
18:45:21 <adnap> I wonder if I will ever force myself to learn math topics in here that don't seem useful to programming, but evidently many people choose to learn
18:45:27 <arkeet> I dunno.
18:45:38 <sclv> i guess the place to check is the girard
18:45:40 <tabemann> NemesisD: you could use EIther for that, yes
18:45:43 <tabemann> Either*
18:45:48 <latermuse> xenocons: yes
18:46:07 <NemesisD> ab9rf: not sure how else that would work, orElse needs them to be the same type
18:46:27 <NemesisD> tabemann: i mean*
18:46:32 <haasn> xenocons: composition is also associative, so that's the same as map (g . x . f . n)
18:46:42 <adnap> Why are you intersted in category theory?
18:46:44 <xenocons> latermuse: awesome, and in ML (ocaml,F#) map f . map g <> map ( f . g )
18:46:46 <xenocons> haasn: ah cool
18:47:02 <haasn> xenocons: it's a general Functor law, fmap f . fmap g = fmap (f . g) -- not just for lists
18:47:13 <xenocons> oo
18:47:22 <danharaj> because category theory is the theory of computation
18:47:30 <tabemann> NemesisD: if you use Right and Left in the LiftMs, your types would both be STM (Either Foo Bar) where Foo and Bar may be any type
18:47:32 <arkeet> no, category theory is the theory of categories
18:47:53 <danharaj> yes, that's what I said
18:47:56 <NemesisD> tabemann: sweet
18:47:57 <adnap> What is interesting about that?
18:47:59 <arkeet> no it isn't =(
18:48:03 <danharaj> it totally is!
18:48:24 <arkeet> what you said is no more true than saying monads are a theory of IO, say.
18:48:26 <haasn> my main interest in category theory is being able to understand edwardk libraries
18:48:26 <danharaj> fixing a category fixes a type theory fixes a logic fixes a category
18:48:27 <monochrom> what is computation?
18:48:36 <latermuse> haasn: goodluck
18:48:42 <arkeet> category theory is much more than that!
18:48:43 <danharaj> and gives a notion of reduction
18:48:43 * tabemann feels like he will need to learn a lot of category theory to understand edwardk libraries
18:48:50 <arkeet> (or much less, depending on your point of view.)
18:48:52 <sclv> haasn: the problem is a bunch of edwardk libraries serve the purpose of helping people to understand category theory
18:48:53 * sj4nz wonders if computation is solved by prunes.
18:48:57 <arkeet> tabemann: nah, not really.
18:48:59 <sclv> more than anything else
18:49:13 <tac> tabemann: I'm not sure many Haskellers at all know much category theory
18:49:13 <sclv> the more useful libraries you don't need cat theory for
18:49:25 <arkeet> unless you're hitting some explicit category things (wtf is a kan extension, for example), you won't.
18:49:25 <monochrom> you need to learn a lot of edwardk libraries to understand category theory
18:49:28 <arkeet> haha
18:49:29 <adnap> I want to know if I would enjoy just reading a book about category theorm. I imagine that I will be constantly distracting by the thought, "I want to program"
18:49:32 <arkeet> monochrom++
18:49:37 <tac> If I'm not thinking of someone else, I think I've even asked edwardk, and he admitted to knowing not a ton about it, either
18:49:42 <adnap> Bleh. Sorry about the grammar
18:49:47 <arkeet> tac: he's so modest.
18:49:49 <tac> (Though maybe he was being humble or lying to me or something :P)
18:49:55 * monochrom is learning a bit of free monad now
18:49:56 <latermuse> adnap: I find a piece of paper to be more useful when reading cat theory books
18:49:57 <danharaj> tac: edwardk has an oracle for category theory in dolio.
18:49:59 <sclv> yeah the stuff we have in haskell is really pretty beginner level stuff is my sense
18:50:07 <sclv> as in its stuff that you'll get in maclane
18:50:11 <arkeet> category theory is certainly useful for understanding the *motivation* for a lot of things.
18:50:13 <tabemann> the problem with me learning category theory is my underlying math background is pretty minimal, so there's probably so much I'd need to learn just *before* learning category theory
18:50:17 <sclv> s/my/a/
18:50:28 <latermuse> tabemann: start with set theory
18:50:30 <arkeet> tabemann: yeah, it helps to have a supply of examples.
18:50:42 <arkeet> latermuse: well, you don't need a lot of set theory.
18:50:45 <sclv> tabemann: in case you missed it the other day i misled you
18:50:55 <monochrom> yes, if you lack math background, you may lack concrete examples to guide your learning of category theory.
18:50:57 <adnap> Well, another thing... "polynomial types"
18:51:00 <tac> I've been learning a lot of category theory for math-y stuff. I have come to the conclusion category is only really useful in "the very long run"
18:51:01 <sclv> there's a trivial example of one type with many monad instances, the writer monad.
18:51:01 <arkeet> you hardly need more than naive set theory with functions and products and stuff
18:51:04 <latermuse> arkeet: its still a good base for programming in general and helps a bit with cat theory
18:51:08 <haasn> monochrom: free monads are nice when you start recognizing them all over the place
18:51:11 <monochrom> concrete before abstract. specific before general. don't learn category theory first.
18:51:12 <adnap> What subject does "polynomial types" fit into?
18:51:14 <sclv> so i repeated a bad thing unthinkingly
18:51:18 <sclv> and lots of people here corrected me :-)
18:51:31 <tabemann> hmm... where to start with set theory...
18:51:32 <dolio> I feel like people think I know more category theory than I actually do.
18:51:46 <arkeet> dolio: I get that all the time with everything.
18:51:49 <arkeet> =(
18:51:52 <latermuse> tabemann: here is a good resource for set theory: http://gauravtiwari.org/2013/08/10/set-theory-functions-and-real-number-system/
18:52:03 <sj4nz> My mind blew when I hit the section in the Haskell wikibook when it talked about taking the derivative of a type.
18:52:09 * hackagebot diagrams-postscript 0.7.0.1 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-0.7.0.1 (BrentYorgey)
18:52:13 <tabemann> sclv: the conclusion I came to from that discussion is that every type does have a unique monad... but a type is defined by its interface, so if you change the interface you change the type (I might be totally wrong here)
18:52:14 <danharaj> dolio: well you know enough co(end) calculus to turn definitions into code it seems
18:52:22 <danharaj> er (co)end
18:52:26 <sclv> dolio: you're good at sniffing out ppl misusing it at least
18:52:27 <tabemann> s/unique/unique or no
18:52:27 <byorgey> adnap: I would say "type theory"
18:52:43 <arkeet> e.g. you don't really need to know anything about cardinality, or number systems
18:52:44 <haasn> sj4nz: I'm still intrigued by T^7 = T
18:52:48 <monochrom> my personal path was: abstract algebra (groups, rings, fields) -> universal algebra -> category theory
18:52:48 <dolio> There are a lot of things in category theory that end up being actually useful for fooling around with types, though.
18:53:03 <sclv> right out subset of cat theory we can compute with is 'weird'
18:53:04 <dolio> Changing types into other isomorphic types that are better for certain things.
18:53:06 <arkeet> my path was math -> ????
18:53:10 <sj4nz> haasn: 1^7=1 so that's not surprising to me.
18:53:14 <sclv> there's lots of totally standard cat theory things we never run into
18:53:16 <latermuse> monochrom: thats a pretty good progression
18:53:19 <arkeet> sj4nz: but T isn't 1.
18:53:23 <sj4nz> True. :)
18:53:27 <haasn> sj4nz: where T is the type of trees
18:53:28 <danharaj> sclv: examples?
18:53:28 <sclv> because in our categories we don't have lots of common limits iirc
18:53:30 <haasn> binary trees iirc
18:53:40 <sclv> danharaj: equalizers
18:53:42 <sclv> i think
18:53:44 <haasn> sj4nz: of course ()^7 = ()  :)
18:53:45 <danharaj> well yeah we don't really have pullbacks or equalizers in *
18:53:47 <byorgey> haasn: yes, binary trees
18:53:52 <danharaj> but you can construct other categories that do and use them in your code!
18:54:01 <startling> tabemann, http://jeremykun.com/2011/07/09/set-theory-a-primer/ is good
18:54:04 <sclv> well maybe you can :-)
18:54:16 * sj4nz is getting a little far away from his OpenGL work to fall into the category theory rabbit hole...
18:54:19 <danharaj> I am working with FinSet right now, in particular FinSet -> *
18:54:28 <sclv> oh that sounds fun
18:54:35 <sclv> is this for any particular project?
18:54:45 <danharaj> sclv: Languages with variable binders.
18:54:48 <dolio> Like, when you see CPSing, and oleg talking about 'finally tagless' stuff, and the prompt monad, and what have you....
18:54:52 <sclv> just in general?
18:54:58 <danharaj> for now, yeah
18:55:00 <arkeet> FinSet, or its skeleton?
18:55:04 <sj4nz> Personal project to build a notetaking system that doesn't suck.
18:55:10 <arkeet> (I guess they're equivalent.)
18:55:17 <dolio> You can relate all that back to theorems in category theory that say, 'this is isomorphic to this.'
18:55:19 <danharaj> arkeet: a skeleton of FinSet I should say. Every category is equivalent to its skeleton.
18:55:39 <dolio> And learning new theorems like that give you new ways to build those optimizations.
18:55:45 <sj4nz> To set the bar high, I'm thinking of not relying on the usual component libraries like GTK, wx, QT and so on.
18:55:48 <tac> Let's work in a univalent universe. Every category is equal to its skeleton :O
18:55:48 <sclv> we also have lots of tools that we don't have in cat theory in general
18:55:50 <haasn> dolio: you need a lemma (sorry)
18:56:03 <sclv> because as much as hask lacks a bunch of stuff, it also has a bunch of 'nice' properties that you don't get in general
18:56:05 <arkeet> tac: that sounds evil
18:56:09 <startling> some stuff about functions (re: set theory) has pretty basic applications to haskell
18:56:15 <sclv> like typically having products and coproducts, etc.
18:56:22 <startling> it's useful to say whether a function is injective or surjective.
18:56:24 <roconnor> tac: I don't think equivalent is the same as isomorphic
18:56:28 <danharaj> sclv: you can pretend Hask is sitting inside some nice topos.
18:56:34 <danharaj> and topos theory is quite rich.
18:56:40 <startling> roconnor: well, they're isomorphic. :)
18:56:41 <sclv> danharaj: right. i have that intuition. but i need moar topos theory
18:56:55 <roconnor> a category is isomorphic to it's skeleton?
18:57:03 <roconnor> *its
18:57:04 <dolio> No, it's equivalent.
18:57:09 * hackagebot stable-memo 0.2.2 - Memoization based on argument identity  http://hackage.haskell.org/package/stable-memo-0.2.2 (JakeMcArthur)
18:57:10 <tac> hm
18:57:21 <tac> *supposes he should work through more of the CT chapter in the book*
18:57:26 <arkeet> dolio: assuming the axiom of choice.
18:57:31 <startling> isn't isomorphism an equivalence relation?
18:57:35 <dolio> But univalent identity of categories would be equivalence anyway.
18:57:37 <sclv> and i think topoi are maybe a bit too powerful?
18:57:46 <dolio> arkeet: Really?
18:57:53 <arkeet> I think so?
18:57:57 <danharaj> There are size issues.
18:58:14 <roconnor> dolio: really?
18:58:22 <arkeet> depends on how you define skeleton.
18:58:23 <dolio> Yes, of course.
18:58:36 <sclv> danharaj: well a topos has all finite limits right?
18:58:41 <danharaj> sclv: yeah
18:58:42 <arkeet> http://ncatlab.org/nlab/show/skeleton
18:58:45 <sclv> so we fail
18:58:53 <danharaj> sclv: well you can't use them in your code, but you can reason about semantics with them.
18:59:14 <roconnor> dolio: I don't find that obvious
18:59:16 <dolio> roconnor: Well, you'd need a theory with categories-as-types, which would have to be directed.
18:59:16 <sclv> i sort of see that.
18:59:38 <roconnor> dolio: I thought we were talking about the type of catories within a univalent type theory.
18:59:41 <dolio> But the whole point of univalence is that identity is up to whatever higher dimensionality is appropriate for something.
18:59:43 <roconnor> *categories
18:59:50 <roconnor> dolio: right
19:00:02 <dolio> So, if something is a category, then equivalence of categories is the notion of identity for them.
19:00:16 <roconnor> dolio: that doesn't seem right.
19:00:42 <dolio> Isomorphism is too strict. It's for sets.
19:00:48 <roconnor> We define a category to be a set-enriched category where a set is at level 1 of the univalent heirarchy?
19:01:19 <dolio> Well, it's either 2 or 0, I think, depending on how you start numbering.
19:01:27 <roconnor> right level0
19:01:34 <Cale> adnap: Oh, no problem :)
19:01:59 <sclv> wait is the claim that categories are equivalent to their skeletons in general?
19:02:45 <dolio> roconnor: Equvalence of objects of a category is isomorphism, is that what you're thinking?
19:02:53 <sclv> ah its by definition
19:03:23 <dolio> Or, identity.
19:03:34 <dolio> But identity of categories themselves is isomorphism up to isomorphism.
19:04:06 <roconnor> I just thing that * --> *  and * ==> * cannot be considered equal, even in an univalent setting because they are totally different
19:04:10 <roconnor> *think
19:04:47 <roconnor> and if I wrote Category in Coq they would be discriminatable
19:04:58 <roconnor> and Coq is compatible with univalence.
19:05:20 <dolio> What is * ==> *?
19:05:29 <roconnor> two object, two arrows
19:06:09 <dolio> Coq doesn't have types that are categories in a univalence sense.
19:07:07 <roconnor> data EnrichedCategory V := {Obj : Type; Arr : Obj -> Obj -> V; ... }
19:07:17 <sclv> arkeet, danharaj: rewinding the stack apparently girard did use the "linear algebra" analogy for linear logic at some point: http://en.wikipedia.org/wiki/Affine_logic
19:07:59 <arkeet> pah
19:08:04 <arkeet> real mathematicians make analogies between analogies.
19:08:18 <dolio> To create the category you're describing in a way that interacts with univalence, you need a type with two values, and the identity type between those two values has two inhabitants.
19:08:29 <sclv> yeah i mean one would have to dig deep in his stuff to see where the term is introduced and under what motivation
19:08:32 <danharaj> cool
19:08:43 <sclv> but clearly 'affine' was introduced by analogy via linear algebra
19:08:45 <dolio> And it has to be a directed identity type, because it's a category.
19:08:50 <Cale> dolio: uh...
19:08:52 <dolio> Instead of a groupoid.
19:08:59 <Cale> Wait, what?
19:09:10 <roconnor> dolio: I guess I've been talking about a different definition of category (WRT univalence)
19:09:16 <Cale> A category isn't a type
19:09:33 <Cale> I mean, not just straightforwardly, with the identity types giving the arrows
19:09:44 <Cale> Types only give rise to groupoids like that
19:09:51 <dolio> Directed homotopy type theory would have types that are categories.
19:09:52 <Cale> because you can always invert a path
19:09:56 <Cale> yeah
19:10:18 <Cale> But in plain HoTT, you'd represent a category somewhat more classically than that still :)
19:10:30 <roconnor> ya, like this:
19:10:31 <roconnor> data EnrichedCategory V := {Obj : Type; Arr : Obj -> Obj -> V; ... }
19:10:45 <Cale> Something like that, yeah
19:10:46 <dolio> Yes, but then you're not necessarily going to have univalence imply that equivalent categories are identical.
19:10:48 <tabemann> stupid question
19:11:02 <roconnor> dolio: which is what I've been saying all along :P
19:11:08 <tabemann> what's the difference between using forkFinally and forkWithUnmask in the initial state of the thread created?
19:11:11 <roconnor> dolio: but I get it now
19:11:12 <Cale> well...
19:11:32 <roconnor> if we are going to have equivalent categories are identical, you need directed homotopy type theory.
19:12:35 <Cale> You do get that an isomorphism of categories and an equivalence of categories are the same thing
19:14:19 <tabemann> and also, why is there no forkFinally counterpart for forkOn (is there a reason for this, or is this just an oversight)?
19:14:35 <tabemann> (writing it is trivial, of course, but I'm wondering why it's not already there)
19:14:49 <sclv> tabemann: skimming the docks and thinking about it
19:15:02 <sclv> forkIOWithUnmask inherits the mask state of the parent
19:15:10 <Cale> See section 9.1 of the HoTT book... you define a precategory to be something like what roconnor is doing, and then a category to be a precategory where the map (a = b) -> Iso(a,b) is an equivalence.
19:15:14 <sclv> while forkFinally always has a masked state to begin with
19:15:31 <sclv> except it maybe doesn't? because it calls the mask inside the fork
19:15:34 <Cale> where Iso(a,b) is the type of isomorphisms between objects a and b in the category
19:15:57 <sclv> so it executes the action in a masked state, but it might take a moment to 'mask up'
19:16:04 <tabemann> I thought that forkIO also inherits the mask state, as the source code for forkFinally uses forkIO
19:16:06 <Cale> and later, they show that categories are equivalent iff they are isomorphic
19:16:11 <sclv> tabemann: right.
19:16:19 <sclv> but then if you look at the source, it calls mask 'right away'
19:16:30 <sclv> which might not be 'right away enough' i guess tho
19:16:48 <sclv> like theoretically you might have to mask before forking to be really safe, and forkFinally doesn't do that?
19:16:51 <tabemann> forkFinally calls mask *before* calling forkIO
19:16:59 <Cale> (Lemma 9.4.14)
19:17:00 <sclv> oh you're right i misread
19:17:05 <sclv> so that's the difference then!
19:17:40 <tabemann> what I'm wondering about is why isn't there a counterpart for forkOn, considering it's trivial to write - does forkOn behave differently from forkIO here or something?
19:17:44 <Cale> and they show that equality of categories coincides with equivalence
19:17:59 <Cale> So, it doesn't take much, even in ordinary HoTT to make things work nicely
19:18:31 <sclv> not as far as i know, but this stuff is confusing
19:18:37 <sclv> my suspicion is its an oversight
19:18:43 <Cale> You just need to add a condition which relates the isomorphisms in the category itself to the identity types.
19:19:06 <Cale> (between the objects)
19:19:50 <tabemann> I bet no one thought of a need for forkOnFinally before
19:20:29 <roconnor> Cale: interesting
19:20:30 <sclv> just noticed that Girard dedicated "Linear Logic" to Jean van Heijenoort. Nice!
19:21:01 <tabemann> (I need it because I'm writing a little library to allow semiautomatic grouping of threads onto capabilities, and I need the "finally" to decrement the thread counts for capabilities when the corresponding threads are done)
19:21:15 <sclv> i'd like to read something serious at some point on how van Heijenoort's work relates to later development in proof theory
19:21:39 <sclv> afaik he didn't publish much of it.
19:21:50 <sclv> but it seems prescient
19:23:01 <tabemann> (damn my code would be nicer if I didn't need to either pass around a "capability pool" or resort to either A) reader monads or B) the goddamn unsafePerformIO hack)
19:23:18 <tunixman> HEllo! I was having some troubles compiling pronk and was wondering if anyone might be able to help. I think it's because of a change to the Hastache API but I can't tell what to change.
19:23:27 <sclv> tabemann: people often suggest using the frequently ignored implicit params solution
19:23:55 <tabemann> well, it's not really my code but I'm thinking of use cases here, and I'm wishing that I didn't need to expose a "capability pool" to the user in the first place
19:24:14 <tunixman> Here is a gist: https://gist.github.com/tunixman/6246715
19:24:43 <tabemann> when will GHC get *safe* mutable top-level state...
19:25:26 <sclv> tabemann: probably never :-)
19:25:31 <sclv> its terribly controversial!
19:25:44 <sclv> and every time someone makes a proposal it gets shot down in flames
19:26:01 <sclv> because the notion of 'top level' is somewhat ill-defined
19:26:23 <tabemann> well both reader monads and the unsafePerformIO hack are horribly lacking as solutions too
19:26:36 <sclv> tabemann: well look at implicit parameters!
19:26:45 <danharaj> implicit parameters kind of suck
19:26:45 <sclv> also explicit threading is way less horrible than you might imagine
19:26:54 <sclv> yeah but for this use they're kind of ok
19:27:00 <tabemann> don't they require each level down in your call tree also have implicit parameters, to pass them along?
19:27:21 <Cale> roconnor, dolio: It's kind of a less evil way of demanding all categories be skeletal. It's also nice in that because you still have this notion of precategory, you can still have a somewhat more classical perspective on things through that, which doesn't identify these notions. It's possible for a precategory to be equivalent to a category without actually being a category for instance.
19:27:36 <tabemann> for the purposes of this library I'm leaving it up to the user as to what solution they want to pass around the CapabilityPool, for lack of any good single solution
19:27:52 <sclv> fair enough :-)
19:27:57 <tabemann> but I don't like it because it means the user can create *two* CapabilityPools, which completely defeats the purpose of the library
19:28:31 <Cale> (but precategories which are isomorphic to categories are categories)
19:29:14 <tunixman> So I'm trying pinning dependency versions in the cabal file to at least narrow things down anyway.
19:29:57 <tunixman> It does seem to change the compilation errors around a bit.
19:32:23 <dolio> Cale: Yeah, it's interesting. Is there also a way to build some kind of truncation operation that gives you a category from a precategory?
19:32:32 <johannh> Hey, does anyone know of a package for manipulating (convolving, shifting, etc.) discrete probability distributions?
19:33:22 <dolio> From the other truncations they already have.
19:33:50 <Cale> dolio: You should be able to do that, yes. At the very least, as a higher inductive type, where you create paths between the objects of the category from isomorphisms in the precategory.
19:39:26 <tabemann> nother thing missing - forkFinallyWithUnmask
19:40:07 <Tene> tabemann: What's so lacking about Reader?
19:40:51 <tabemann> Tene: that you basically have to have all your code that needs the value inside the Reader monad or ReaderT monad transformer, and at least I myself am not a fan of all monad transformer stacks
19:41:20 <tabemann> s/all/tall
19:42:20 <tabemann> (well, they're okay if one wraps one's stack on a newtype, and then defines all the operations one needs as being in terms of that newtype...)
19:42:39 <tabemann> (aside from liftIO, where then one will just need to implement MonadIO)
19:44:42 <tunixman> So I got it building by pinning a couple of versions in the Cabal file and sumbitted a pull request, but that does feel an awful lot like cheating.
20:07:15 * hackagebot crypto-api 0.12.2.2 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.12.2.2 (ThomasDuBuisson)
20:07:18 * hackagebot DRBG 0.5.1 - Deterministic random bit generator (aka RNG, PRNG) based  HMACs, Hashes, and Ciphers.  http://hackage.haskell.org/package/DRBG-0.5.1 (ThomasDuBuisson)
20:07:20 * hackagebot entropy 0.2.2.2 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.2.2.2 (ThomasDuBuisson)
20:12:16 * hackagebot clckwrks 0.18.2 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.18.2 (JeremyShaw)
20:12:18 * hackagebot cipher-aes128 0.4.1 - AES128 using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.4.1 (ThomasDuBuisson)
20:28:53 * tabemann wonders who really needs forkThreadGroupFinallyWithUnmask, but he's implementing anyways
20:37:43 <begriffs> I've got a question about Haskell types. If I write 4 == "4" it's a type error, but is there a way I can define some type classes or something so that the expression will return false?
20:38:04 <begriffs> Not like it's a good idea, but just to understand how things work.
20:38:23 <tabemann> that won't work, period
20:38:33 <tabemann> because (==) :: Eq a => a -> a -> Bool
20:38:53 <tabemann> both values on each side of == *must* have the same type
20:39:16 <ion> The only way to make that typecheck is to have a Num instance for String (because 4 :: Num a => a), but you don’t want to do that.
20:39:23 <begriffs> What if I made a type that could be either of [Char] or Num?
20:39:39 <tabemann> ion: I don't think even that would work
20:39:40 <ion> > Left 4 == Right "4"
20:39:41 <lambdabot>   False
20:39:42 <tabemann> :t (==)
20:39:42 <lambdabot> Eq a => a -> a -> Bool
20:39:52 <ion> begriffs: You already have one.
20:40:43 <shachaf> tabemann: Yes, it would work.
20:41:21 <tabemann> shachaf: how? the type isn't Num a => a -> a -> Bool
20:41:44 <tabemann> and even then
20:41:50 <shachaf> tabemann: This is left as an exercise to the reader.
20:41:50 <tabemann> no that *still* wouldn't work
20:42:04 <shachaf> I bet you could figure it out if you tried it and looked at the error messages.
20:42:19 <shachaf> @let instance Num [a] where fromInteger _ = []; (+) = undefined; (*) = undefined; abs = undefined; signum = undefined
20:42:19 * hackagebot clckwrks 0.18.3 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.18.3 (JeremyShaw)
20:42:20 <lambdabot>  Defined.
20:42:22 <shachaf> > 4 == "4"
20:42:25 <lambdabot>   False
20:42:32 <shachaf> But, like begriffs said, not a good idea.
20:43:08 <begriffs> I'm a total novice, just learning Haskell and trying to see how types work
20:43:52 <shachaf> begriffs: Numbers are kind of magic so I recommend not worrying about them too much at first.
20:44:04 <tabemann> shachaf: how can a have two different types in Eq => a -> a -> Bool, even when both have instances for Num?
20:44:09 <shachaf> You can't e.g. make «True == "True"» ever work.
20:44:42 <shachaf> tabemann: I bet you could figure it out!
20:45:23 <shachaf> (The answer is: It can't.)
20:45:37 <shachaf> (Well, a doesn't *have* a type -- it *is* a type. And it's only one type.)
20:46:23 <begriffs> The Left 4 /= Right "4" thing looks kind of unpromising because Left 4 /= Right 4 too.
20:46:36 <tabemann> oh dammit I figured it out
20:46:57 <tabemann> 4 is actually of type Num a => a, and it's being automatically converted to [Char] as that has a Num instance
20:47:48 <tabemann> > (4 :: Int) == "4"
20:47:49 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:47:49 <lambdabot>              with actual type ...
20:48:10 <lpsmith> I suppose you could define an "IsString
20:48:20 <lpsmith> instance for Int or whatever
20:48:50 <tabemann> why did I forget that 4 by itself was polymorphic in type...
20:49:00 <lpsmith> not a terribly good idea either,  and it doesn't really do what begriffs is really asking for
20:49:08 <xenocons> has someone got a link that documents the difference between haskell map f . map g = map (f . g) and ocaml?
20:49:10 <shachaf> Yes, you could do that too. But then you have to deal with defaulting (and with going outside Haskell 2010).
20:50:31 <xenocons> as it seems my assumption was stupid: as i was just advised via twitter map f . map g = map (f . g) holds for ML too, not just haskell
20:51:01 <xenocons> someone help me find how my assumption was so wrong here, heh
20:51:04 <tabemann> where did you get the idea that they weren't equivalent in OCaml?
20:51:15 <xenocons> im not sure :{
20:51:39 <shachaf> xenocons: If you're asking about ocaml, maybe you should ask in an ocaml channel. :-)
20:51:40 <tabemann> the only difference I see between the two in OCaml is that they'd scale differently, whereas in Haskell, thanks to lazy evaluation, they'd scale the same
20:51:43 <xenocons> i refuse to believe it was a dream
20:51:59 <xenocons> shachaf: asking more about the difference between haskell and ML
20:52:05 <tabemann> well, forget even that
20:52:11 <slack1256> what if 'f or g' have side effects?
20:52:17 <slack1256> the ordering would matter then not?
20:52:33 <xenocons> ahh, hmmm
20:52:40 <tabemann> the big difference between ML and Haskell is ML is impure and strict and Haskell is pure and lazy and ML has parameterized modules and Haskell has type classes
20:52:49 <shachaf> In Haskell I can tell you that it's a functor law. They should be the same.
20:53:12 <begriffs> Can you make a type that builds itself differently based on what is used to make it? Something like Magic "4" notices it's getting a [Char] and so it does read argument :: Int whereas Magic 4 sees it's getting an Int so it keeps it that way. Then define equality between Magics.
20:53:15 <shachaf> So if they're not the same in ocaml, you won't find the difference here.
20:53:28 <xenocons> hmm
20:53:40 <shachaf> begriffs: I don't quite understand what you're asking but it sounds like a bad idea.
20:53:51 <shachaf> Learn more Haskell and about the Haskell way of doing things first. :-)
20:54:00 <begriffs> :)
20:54:06 <johnw> begriffs: you could have a data type with MagicString and MagicInt constructors, and then define equality between Magic (the type).  That is one way of expressing heterogeneity.  But it doesn't work with the same-named constructor
20:54:40 <johnw> i.e., data Magic = MagicString String | MagicInt Int ; instance Eq Magic where (MagicString x) == (MagicString y) == x == y, etc.
20:54:51 <tabemann> you *could* do this:
20:55:12 <johnw> nor would most of us *want* it to work, mind you
20:55:36 <tabemann> data Magic = Magic (forall a. Show a => a) (my syntax may be a bit off)
20:55:50 <johnw> tabemann: that's cute :)
20:55:59 <johnw> instance Eq Magic where x == y = show x == show y
20:56:54 <tabemann> yeah
20:57:51 <tabemann> that does sound like quite an abuse of existential types and Show, though
20:57:59 <shachaf> If you're going for an existential (since what you wrote doesn't make sense), I should say this isn't a good example of an existential, since Magic = String.
20:58:45 <tabemann> I just didn't remember where to place the forall and the Show a =>, having not used existential types much, but of course you'd have to wrap your value in the Magic constructor for this to work
20:58:53 <johnw> Magic only renders the string when you test for equality -- and every time you test for equality
20:59:02 <shachaf> begriffs: People are giving sort of answers to your question, but I bet it's not the question you should be asking.
20:59:22 <xenocons> what about fmap? does this preserve identity? fmap f . fmap g = fmap (f . g) ?
20:59:35 <xenocons> (im slightly barking up trees, but humor me)
21:00:00 <johnw> xenocons: that is the second Functor law
21:00:03 <tabemann> xenocons: yes
21:00:12 <xenocons> heh, ok
21:01:05 <begriffs> shachaf: yeah I would rather not circumvent the type system. It's there to help me. It's just a thought experiment. I'll continue reading and seeing how things should really be done.
21:02:02 <tabemann> if it's something you could do in, say, a dynamically typed language but can't do in Haskell due to its type system, it's probably something that's a bad idea in those dynamically typed languages in the first place
21:02:17 <tabemann> with a few exceptions such as the monomorphism restriction (which can be turned off)
21:02:28 <tabemann> (but is on by default because it has performance implications)
21:02:40 <shachaf> Or sometimes it's a great idea in that language but should be done differently in Haskell.
21:02:42 <johnw> has does the monomorphism restriction relate to things you can do in dynamic languages?
21:02:47 <shachaf> Or sometimes it's a great idea in that language and there's no good way of doing it in Haskell.
21:03:15 <johnw> s/has/how
21:03:17 <tabemann> shachaf: the main case I can think of that is where you don't have proper tuple types and thus have to make do with arrays or lists in their place
21:03:19 <shachaf> Such a sweeping "anything which is hard to do in Haskell isn't worth doing" statement seems suspicious to me.
21:03:43 <johnw> perhaps the better statement is, "If Haskell is making something hard to do, it's worth thinking about why."
21:03:52 <shachaf> Yes.
21:04:12 <haasn> you can implement ‘dynamic typing’ in any statically typed language; but it generally isn't a good idea - for the same reasons that using ‘dynamically typed languages’ generally isn't a good idea
21:05:04 <Gracenotes> it's so hard to mutate things in Haskell. it's so easy in Java... what's up with that.
21:05:12 <tabemann> you can put everything in one huge variant type, but all you've done is lost all the safety haskell types give you and gained a lot of manual checking
21:05:27 <Gracenotes> it's just a single operator. not all these fancy utility functions and monads.
21:06:00 <lispy> UpdateAssignmentFactoryBuilder
21:06:01 <joelteon> Huh, wow. You can kinda unsafeCoerce using GeneralizedNewtypeDeriving without actually using unsafeCoerce.
21:06:19 <begriffs> Sorry to stir up the language warfare. Just wanted to play around with a weird example.
21:06:23 <lispy> joelteon: yes
21:06:36 <joelteon> no wonder it's dangerous
21:07:02 <tabemann> Gracenotes: the question is, do you *want* uncontrolled assignment
21:07:14 <joelteon> yep
21:07:17 <Gracenotes> unsafe coerce is safe with GND, no?
21:07:24 <slack1256> isn't only dangerous when using type families?
21:07:37 <slack1256> or is always buggy?
21:07:42 <shachaf> No, it's dangerous with GADTs also.
21:07:46 <shachaf> And maybe other extensions.
21:08:06 * slack1256 wouldn't live without mtl and GND.
21:08:10 <shachaf> I think anything that lets you write e.g. foo :: (forall p. p S -> p T) -> Void
21:08:13 <shachaf> Or something like that.
21:08:21 <lispy> http://joyoftypes.blogspot.com/2012/08/generalizednewtypederiving-is.html
21:08:27 <joelteon> Nice, and you can cause segfaults with it too.
21:12:53 <tabemann> what would it take to make GHD safe - make using it with type families and GADTs not compile, or would that not be enough?
21:12:57 <tabemann> s/GHD/GND
21:13:14 <joelteon> apparently they're making roles
21:13:24 <tabemann> I've heard about that
21:17:23 <adas> could someone please tell me if  haskell has a standard library for parsing JSON?
21:17:32 <dmj`> aeson
21:17:46 <dmj`> @where aeson
21:17:46 <lambdabot> I know nothing about aeson.
21:17:53 <haasn> @hackage aeson
21:17:53 <lambdabot> http://hackage.haskell.org/package/aeson
21:17:55 <slack1256> de facto standard
21:18:08 <haasn> @hackage aeson-lens :)
21:18:08 <lambdabot> http://hackage.haskell.org/package/aeson-lens :)
21:18:18 <edwardk> @hackage lens-aeson
21:18:18 <lambdabot> http://hackage.haskell.org/package/lens-aeson
21:18:48 <haasn> oh, yes
21:18:49 <haasn> how confusing
21:19:08 <adas> which is easy to use?
21:19:36 <johnw> i would recommend lens-aeson
21:19:41 <johnw> if only because the author of lens maintains it :)
21:20:04 <cmears> does aeson-lens not obey the lens laws?
21:20:16 <edwardk> haasn: aeson-lens is full of illegal lenses
21:20:24 <edwardk> so we wrote lens-aeson
21:20:32 <tac> What's the point of the laws if you break them? T_____T
21:20:53 <haasn> makes sense, it also has prisms so that increases the cool factor significantly
21:20:55 <edwardk> tac: because they tell you that if you obey them the lens police won't come and arrest you
21:20:59 * johnw codes his lenses while listening to, "I fought the law and the law won"
21:21:02 <edwardk> you don't want to be thrown in prism
21:21:03 <haasn> and seems easier to use
21:21:35 * haasn codes his traversals while listening to “do what you want cause a pirate is free”
21:22:02 <dmj`> adas: here is a getting-started tutorial: https://www.fpcomplete.com/school/text-manipulation/json
21:22:23 * tac also grumbles about how the examples are full of Maybes.
21:22:41 <edwardk> tac: aeson?
21:22:46 <edwardk> tac: or lens-aeson
21:22:54 <tac> lens-aeson :P
21:23:18 <haasn> you sure you don't mean aeson-lens? :P
21:23:19 <tac> Because the parsing is piece-meal. It's a necessary consequence.
21:23:39 <edwardk> "{\"a\": 1, \"b\": 3}" & key "a"._Integer *~ 100
21:23:39 <edwardk> {"a":100,"b":3}
21:25:03 <haasn> [from Data.Attoparsec.Number]     (+) = binop (((I$!).) . (+)) (((D$!).) . (+)) -- what
21:25:17 <haasn> okay, I'm a fan of pointless programming but that's just overdoing it :P
21:25:30 <CADD> lol
21:26:37 * tabemann can't parse that
21:26:50 <adas> dmj`: thaks for the link
21:26:51 <haasn> tabemann: it's just (\x y -> I $! x + y) -- and stuff
21:27:21 <tabemann> then why not write that!
21:27:28 <haasn> don't ask me~
21:27:29 <haasn> !*
21:27:46 <tabemann> and people say Haskell is hard to read...
21:28:36 <tabemann> (anything that looks like it was generated by @pl is simply bad)
21:28:46 <haasn> @pl like this
21:28:46 <lambdabot> like this
21:29:27 <tabemann> @pl \x y -> x + y
21:29:27 <lambdabot> (+)
21:29:37 <tabemann> just checking that was right lambabot feature
21:29:41 <tabemann> *lambdabot
21:30:23 <dmj`> adas: np
21:30:47 <tac> @pl id
21:30:47 <lambdabot> id
21:31:02 <gnuvince> @pl \x y -> not (x || y)
21:31:02 <lambdabot> (not .) . (||)
21:31:59 <gnuvince> :t (not .)
21:32:00 <lambdabot> (a -> Bool) -> a -> Bool
21:33:13 <johnw> :t (&&) `on` not
21:33:13 <lambdabot> Bool -> Bool -> Bool
21:33:22 <johnw> hmm, n/m
21:35:55 * tabemann simply can't wrap his brain around anything beyond the most basic point-less style
21:36:33 <haasn> I just recognized “(f .) . g” from having seen it before, as “f .: g” or “\x -> f . g x” or “\x y  -> f (g x y)”
21:36:48 <johnw> yep
21:36:54 <CADD> @pointless (f .) . g
21:36:54 <lambdabot> (f .) . g
21:36:58 <CADD> lol
21:37:07 <johnw> I don't think @pl knows about .:
21:37:11 <haasn> @pl \f g -> (f .) . g
21:37:11 <lambdabot> (.) . (.)
21:37:13 <CADD> ah
21:37:29 <haasn>  @pl is a no-op for expressions which don't contain any bound variables
21:37:31 <tabemann> does lambdabot have a feature to convert things in pointless style into something more readable?
21:37:38 <haasn> @unpl (.) . (.)
21:37:38 <lambdabot> (\ i b c f -> i (b c f))
21:38:11 <haasn> hmm
21:38:13 <haasn> @unpl (((I$!).) . (+))
21:38:13 <lambdabot> (\ e h -> (I) $! (e + h))
21:38:25 <haasn> a few excessive parens, but still nice
21:38:54 <tabemann> @unpl binop (((I$!).) . (+)) (((D$!).) . (+))
21:38:55 <lambdabot> binop (\ g m -> (I) $! (g + m)) (\ j p -> (D) $! (j + p))
21:40:02 <ReinH> Now I just want it to tell me a more idiomatic way to do things where I currently use a lot of $
21:40:06 <ReinH> without totally removing the points
21:40:08 <arkeet> such as?
21:40:42 * tabemann likes to use a lot of $
21:40:43 <ReinH> I don't have a specific example in mind
21:40:48 <ReinH> I just feel like I use $ too often
21:41:12 <johnw> a $ b $ c $ d == a . b . c $ d
21:41:43 <haasn> f $ x = x & f -- done
21:41:49 <ReinH> johnw: you can say =, they're equations :p
21:41:56 <johnw> ah, good point
21:42:41 <haasn> a `id` b `id` c `id` d -- look ma, no $
21:42:44 <applicative> ReinH: import Prelude hiding ((/)) ; (/) = ($)
21:43:04 <applicative> unless youre one of those people who actually uses /
21:43:25 <tabemann> of course I only use `div`
21:43:35 <tabemann> who needs (/), and for that matter, real numbers
21:43:39 <applicative> good work tabemann
21:44:20 <applicative> i guess for games and things they need / ...
21:44:31 <tabemann> well
21:44:50 * haasn .oO(  x / y  =  x & id /~ y -- if only  )
21:44:52 <applicative> lift/ putStrLn "hi"
21:44:57 <tabemann> in my producer-consumer test I did use (/) for calculating timing... that's the only time I remember using it (in Haskell) recently
21:45:17 <applicative> you can use P./ hah
21:46:25 * applicative senses this idea will never catch on...
21:47:25 <haasn> lift> putStrLn "hi"
21:47:37 <applicative> beats the almight $
21:47:41 <applicative> almighty
21:47:53 <haasn> okay time to sleep
21:48:00 * applicative agrees
21:50:02 <xenocons> turns out that composition laws are not as easy to grasp at the intuitive level than i had wrongfully assumed
21:50:11 <xenocons> this weekend: http://www.haskell.org/haskellwiki/Typeclassopedia
21:52:18 * applicative warms to haasns lift> putStrLn "hi", reasoning, I'd still have < after all
21:53:53 * begriffs So I got a little further in my misguided quest to define a "Magic" type where equality comparisons compare the results of "showing" values. I'm getting an error, does anyone know what's wrong? Here's how I define things.
21:54:08 <begriffs> data Magic = forall a. (Show a) => Magic a
21:54:30 <johnw> the correct form was given earlier, actually
21:54:43 <begriffs> instance Eq Magic where ; x == y = show x = show y
21:54:46 <johnw> 22:55 <tabemann> data Magic = Magic (forall a. Show a => a) (my syntax may be a bit off)
21:55:17 <johnw> note that using show is the only way to you can use whatever value gets put into a Magic
21:55:22 <begriffs> But the instance Eq line gives an error "parse error on input `='"
21:55:25 <johnw> so it's not any different from String, as shachaf pointed out
21:55:50 <begriffs> Found out that none of this works at all unless I start ghci with -XExistentialQuantification
21:55:52 <applicative> yes, but this is a good lesson.
21:56:08 <johnw> well, there is that, indeed
21:56:53 <applicative> begriffs: as you just wrote it, it's an 'existential type', yes
21:57:13 <applicative> you construct a Magic by inserting anything Showable behind Magic
21:57:22 <monochrom> x == y = show x == show y
21:57:24 <applicative> Majic True, Magic 2
21:57:39 <monochrom> actually, that's still wrong
21:57:49 <applicative> yes you want to pattern match
21:57:49 <begriffs> So was my data definition wrong? Is that why the instance Eq failed?
21:57:52 <monochrom> Magic x == Magic y = show x == show y
21:58:13 <applicative> the show one is legitimate begriffs but it's an unusually dull type as you will see soon
21:59:23 <tabemann> back
21:59:28 <tabemann> that should be:
21:59:51 <tabemann> instance Eq Magic where (Magic x) == (Magic y) = show x == show y
21:59:55 <monochrom> yeah
22:00:54 <applicative> is that different>
22:00:55 <begriffs> Strange, I'm even having trouble building Magics. When I do "Magic 1" it complains No instance for (Show Magic) arising from a use of `print'
22:00:56 <begriffs>     Possible fix: add an instance declaration for (Show Magic)
22:00:56 <monochrom> @bots
22:00:57 <lambdabot> :)
22:00:57 <begriffs>     In a stmt of an interactive GHCi command: print it
22:01:02 <applicative> from what monochrom said
22:01:24 <applicative> have you made a Show instance for Magic?
22:01:25 <tabemann> instance Show Magic where show (Magic x) = show x
22:02:06 <monochrom> not different. just lack of sync.
22:02:18 <applicative> http://sprunge.us/fRFe typechecks begriffs
22:02:21 <begriffs> Ohh cool, so the Magic show just passes the problem to the original.
22:02:24 <Ghoul_> > Magic 2
22:02:25 <lambdabot>   Not in scope: data constructor `Magic'
22:02:30 <Ghoul_> What's a magic?
22:02:48 <monochrom> see scroll buffer
22:03:30 <shachaf> newtype Magic a r = Magic (forall s. Reifies s a => Proxy s -> r), naturally.
22:03:32 <Ghoul_> Oh i see
22:03:42 <applicative> Oh i see
22:04:00 <ReinH> o_O
22:04:01 <arkeet> Oh i see
22:04:04 <monochrom> you don't need to make a Show instance for Magic.
22:04:14 <applicative> can it be derived?
22:04:32 <monochrom> no, GHC doesn't like to derive anything for existential types
22:04:45 <Ghoul_> arkeet the ninja troll
22:04:49 <monochrom> err wait, I may be wrong
22:05:18 <applicative> oh, it will do StandaloneDeriving I see.
22:05:26 <applicative> show (Magic 1) is :  Magic 1
22:05:27 <tabemann> damn I'm trying to make this work in ghci and it isn't working
22:05:57 <tabemann> after setting -XRankNTypes it accepts data Magic = Magic (forall a. Show a => a)
22:05:59 <monochrom> use ghci very carefully
22:06:04 <tabemann> but it isn't letting me do anything with it
22:06:14 <tabemann> oh wait
22:06:17 <tabemann> ExistentialQuantification
22:06:20 <monochrom> that is a different type
22:06:33 <applicative> there are few cases of (forall a. Show a => a)
22:06:43 <applicative> as there are few things you can do with Magic
22:06:44 <monochrom> and I mean non-isomorphic, if you thought I were anal
22:07:20 <monochrom> the correct syntax is in your scroll buffer
22:07:59 <begriffs> So do I need the Reifies and Proxy, or is that just a convenience?
22:08:06 <shachaf> begriffs: Sorry, that was a joke.
22:08:20 <shachaf> Another type also called Magic.
22:08:48 <shachaf> On the other hand that type is a good deal more useful than this String Magic, which is mostly just a bad idea.
22:09:19 <tabemann> monochrom: oh got it
22:09:19 <applicative> there are more interesting existential types though
22:09:26 <johnw> begriffs: the Reifies stuff gives you a way to store values in that Magic type which can be recovered later, but that's some deep voodoo and should be left until later
22:09:40 <shachaf> Store values?
22:09:43 * tabemann never said this Magic type was a good idea
22:09:53 <shachaf> I shouldn't have brought it up at all.
22:09:54 <johnw> shachaf: I can't think of a way to say it that would make sense to begriffs
22:10:02 <tabemann> relying on show for things like equality and conversions probably isn't the best plan
22:10:24 <johnw> "it reifies values as types and carries that type in the instance dictionary so that it can reflected back to a value later"
22:10:29 <applicative> begriffs: an example of a nice existential type is, say
22:10:38 <tabemann> having a Show instance does make sense, having an Eq instance does not
22:10:46 <shachaf> But on the other hand the existential Show type should probably not have been brought up either. :-) Oh well.
22:10:52 <applicative> data Stream a = forall s . Stream s (s -> Maybe (s,a))
22:11:04 <applicative> which is 'isomorphic' to the list type
22:11:09 <monochrom> that type is probably like quantum mechanics. i.e., no matter how you explain it to 5-year-olds, it's going to be wrong
22:11:22 <monochrom> or like category theory XD
22:11:27 <shachaf> I'm not sure that's exactly correct... But eh, it's not the topic anyway.
22:11:32 <applicative> here, it is easy to construct a Stream value, pick anything and a function from that kind of thing to a pair etc
22:11:37 <shachaf> I wrote an explanation of this Magic type on stackoverflow.com recently, though.
22:12:03 <applicative> begriffs: but here, clearly, there's a lot I can do with the Stream you construct. -- anything I can do with a list
22:12:16 <johnw> shachaf: link?
22:12:33 <shachaf> Uh...
22:12:45 <begriffs> So after putting all this together, the result doesn't seem to work. (Magic 1) == (Magic "1") evaluates to false.
22:12:47 <applicative> with magic, all i can do is, say, compare the lengths of the values of show...
22:12:50 <shachaf> johnw: http://stackoverflow.com/a/17794883/712548
22:12:59 <applicative> > show 1 == show "1"
22:12:59 <monochrom> the Stream type is used in fusion
22:13:00 <lambdabot>   False
22:13:06 <shachaf> begriffs: Because (show 1) is "1", but (show "1") is "\"1\""
22:13:09 <applicative> > show 1 == "1"
22:13:10 <lambdabot>   True
22:13:20 <tabemann> > show "1"
22:13:21 <lambdabot>   "\"1\""
22:13:28 <tabemann> show 1
22:13:35 <tabemann> >show 1
22:13:51 <tabemann> > show 1
22:13:52 <lambdabot>   "1"
22:13:58 <arkeet> > fix show
22:13:59 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
22:14:02 <johnw> shachaf: oh yeah, I read that a couple weeks ago.  It was a good explanation.  It helped me understand the magic that edwardk is using in reflection
22:14:02 <applicative> the stream fusion is the slightly fancier forall s. Stream s (s-> Maybe (Either s (s,a))
22:14:06 <monochrom> the paper is called something like "from List to Stream to a lot of steam"
22:14:37 <applicative> which includes the fateful Skip constructor Just (Left s)
22:15:05 <Ghoul_> does Eq need to include GT and LT ?
22:15:16 <Ghoul_> or is that only Ord?
22:15:21 <tabemann> Ghoul_: that's Ord, not Eq
22:15:25 <shachaf> Try asking Hoogle or ghci.
22:15:26 <Ghoul_> ah, cool
22:16:13 <Ghoul_> I wouldn't know how to ask ghci that
22:16:26 <monochrom>  :info Eq
22:16:36 <monochrom> also, :info GT
22:16:48 <applicative> also :i Ord
22:16:54 <monochrom> yeah
22:17:14 <tabemann> okay, should be going to bed
22:17:33 <tabemann> (forgive me for bringing up Magic with existential types)
22:17:38 <johnw> haha
22:17:40 <johnw> sleep well :)
22:17:42 <Ghoul_> anyone know if theres a color wraper for ghci?
22:17:47 <Ghoul_> like, to make it easier to read.
22:18:06 <Ghoul_> nevermind, google is great :)
22:18:26 <begriffs> Thanks for the help
22:18:32 <applicative> oh is Magic all your fault tabemann ?
22:18:53 <tabemann> applicative: I was the one who suggested using existential types with a Show instance
22:19:20 <applicative> it's remarkable how inevitable the idea is; it happens again and again; thus shachaf's irritation, i guess
22:19:57 <applicative> data Thing = forall a . Thing a
22:20:03 <applicative> it could be worse, maybe
22:20:05 <johnw> well, the lack of any way to express general heterogeneity (rather than heterogeneity along a single vector, like Show) is a striking difference from many common languages
22:20:13 <tabemann> the idea is common because it provides an "obvious" solution to a pattern that is common in OO languages without using variant types
22:20:18 <arkeet> Ghoul_: I never found the various full coloring stuff very good
22:20:21 <johnw> I even wondered how to do it myself when I first came to Haskell
22:20:25 <johnw> before realizing I didn't actually ever need it
22:20:32 <arkeet> you can do stuff that nicely colors and indents the output but then you don't get incremental output
22:20:40 <arkeet> Ghoul_: I am perfectly satisfied with a colored prompt.
22:20:59 <tabemann> to me almost all cases thereof are better handled with variant types, and the arbitrary, unbounded subtyping allowed by OO languages is actually a *bad* thing
22:21:19 <johnw> two other things I very rarely use in Haskell but used commonly before: regexps and equality tests
22:21:45 <applicative> i use regexps in my editor all the time..
22:22:03 <applicative> ah, you're against equality tests
22:22:06 * tabemann doesn't like regexps in any languages, but finds that some APIs just force him to use them in cases
22:22:16 <johnw> me too, but not in my Haskell.  it's actually easier to bang out a little parsec when I need it.  Which does make regex-application quite attractive
22:22:19 * applicative approves, or tries to
22:23:10 <arkeet> Ghoul_: to get a bold red prompt, I use  :set prompt "\ESC[31;1m>>> \ESC[0m"
22:23:17 <applicative> ooo
22:23:51 <applicative> to get a prompt with all the module names on the previous line use
22:23:52 <applicative> :set prompt "\ESC[31m[%s]\ESC[m\n\ESC[34m>>> \ESC[m"
22:23:59 <applicative> only, it's very brittle
22:23:59 <arkeet> heh
22:24:20 <Ghoul_> the red prompt is very cool
22:24:31 <arkeet> I tried a few colours and decided red worked the best for me.
22:24:44 <Ghoul_> but theres something retarded about ghci in MinGW, that is, I can "play snake" with the cursor
22:24:49 <Ghoul_> it doesnt restrain to the line :(
22:24:54 <johnw> applicative: I can't say I'm for or against them, but I just don't find them as necessary as in C++ (which I'm testing for equality and identity all the time it seems)
22:25:04 <arkeet> ah yeah, get a better terminal emulator ;(
22:25:09 <Ghoul_> im using mintty
22:25:14 <Ghoul_> which is the best, I've found
22:25:14 * applicative is sold on arkeet's red prompt
22:25:16 <shachaf> arkeet: Write a lazy syntax highlighter so you can have http://slbkbs.org/lazy-syntax.png
22:25:39 <arkeet> shachaf: I'm interested
22:25:50 <shachaf> arkeet: Great! I'm glad someone is interested in writing it.
22:25:58 <arkeet> is that a fake screenshot?
22:25:59 <applicative> johnw: yes, i was just thinking of the famous boolean blindness post of R Harper, which did make an impression on me
22:26:10 <johnw> applicative: me too
22:26:12 <arkeet> how disappointing, then.
22:26:30 <arkeet> make it wrap and indent nicely too
22:26:42 <arkeet> bonus points for querying the terminal for its width.
22:26:43 <shachaf> arkeet: No, it's real.
22:26:45 <arkeet> oh.
22:26:56 <shachaf> But it's a very rudimentary parser.
22:26:58 <applicative> Harper is so good; how can he be so wrong about Haskell? boo hoo
22:27:40 <Ghoul_> extra extra points for input coloring
22:28:00 <Ralith> applicative: what's he say about haskell?
22:28:31 <applicative> oh he's always bashing it, there are a few posts on Existential Type or whatever its called
22:29:04 <applicative> our crowd always shows up and declares him wrong, wrongly
22:29:37 <shachaf> arkeet: Writing streaming parsers that go character-by-character is annoying.
22:29:55 <tabemann> that kind of reminds me of how jon harrop shows up just about everywhere to bash haskell (and extoll the virtues of ocaml and mention his company)
22:30:03 <shachaf> (You want characters-by-character because «^C» and «[^C» and «["^C» and so on are all different.)
22:30:35 <shachaf> That reminds me of how everyone shows up in #haskell to bash Harrop when he hasn't even been mentioned.
22:30:38 <applicative> Ralith: the one http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/ has a very interesting reply from augustss http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html to which harper responds in the comments
22:30:58 * applicative misses Harrop 
22:31:38 <tabemann> why? did he come in here in the past?
22:31:45 <pharaun> whos harrop
22:32:04 <applicative> pharaun: a really awesome anti-haskell troll
22:32:24 <applicative> it was a 14th career after a 13th career as a lisp troll
22:32:29 * hackagebot pubsub 0.1.0.0 - simple mechanism for publish-subscribe  http://hackage.haskell.org/package/pubsub-0.1.0.0 (MarkWotton)
22:32:34 <pharaun> applicative: ah
22:32:45 <applicative> then he got married and became sensible
22:32:58 <pharaun> haha marriage has a way of doing that to folks i guess
22:33:30 <shachaf> arkeet: Is there any good parser library for doing character-by-character parsing like that?
22:33:32 <tabemann> he must have gotten married quite recently, as I've seen plenty of his posts on stackoverflow in the last few years
22:34:48 <arkeet> shachaf: not yet!
22:35:22 <shachaf> Oh, you're interested in writing that too?
22:35:23 <shachaf> Great!
22:35:29 <arkeet> great! when will it be done?
22:38:05 <tabemann> okay g'night
22:47:53 <edwardk> monochrom:	re stream fusion it was "From Lists to Streams to Nothing at All" http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.7401
22:48:23 <arkeet> the title reminds me of that scene from the simpsons.=(
22:49:28 <monochrom> I prefer steam. it's more funny. stream and steam, and fusion. :)
22:51:28 <shachaf> With stream fusion, instead of calling something a "good consumer" or "good producer", you can say that it's a "stream player".
22:51:34 <shachaf> OK, that doesn't work so well with the r.
22:51:44 <applicative> hey, edwardk I found the new 'generalized stream fusion' version of vector fwiw https://github.com/mainland/vector
22:53:20 <shachaf> I,I from lists to streams to stream to steam to team to tea to ea to a to nothing at all
22:53:21 <edwardk> shachaf: hahah
22:53:43 <applicative> it seems to make Vector Word8 as good as the irritating ByteString, which was pleasing ...
22:54:24 <edwardk> applicative: it should make it better in the end
22:55:04 <monochrom> I like "stream player" :)
22:55:09 <applicative> i havent figured out the new types yet, but consoled myself by running a few benchmarks
22:55:12 <newsham> ?tell edwardk http://www.thenewsh.com/~newsham/x/machine/kmett-shuffle.c
22:55:12 <lambdabot> Consider it noted.
22:55:19 <monochrom> consider also "streaming player" :)
22:55:48 <edwardk> newsham: that'd be it. the no-prize has already been claimed though =)
22:55:57 <edwardk> the second no-prize is still open though.
22:56:16 <newsham> if its not simple bitwise stuff, i'm out!
22:56:17 <edwardk> i've written the second post, but i'm going to wait until i can re-read it with slightly more awake eyes before shipping it
22:56:33 <edwardk> newsham: also given that presentation you can quickly see that they are inverses
22:56:59 <edwardk> newsham: http://www.reddit.com/r/haskell/comments/1kecqt/revisiting_matrix_multiplication_part_i_by_edward/cbo8qwy
22:57:18 <newsham> so I get No No-Prize?
22:57:28 <edwardk> you get no no-prize =)
22:57:37 <edwardk> but you get the pleasure of a job well done
22:58:21 * applicative is sorry to say that newsham's text is more legible than the haskell on reddit
22:58:27 <shachaf> No prize is its own reward.
22:59:17 <newsham> applicative: in fairness, my code is borrowed from the original post
22:59:35 <mgsloan> stream players are certainly more productive than steam players
22:59:37 <newsham> i dont like the way they wrote each swap, but then I noticed they did it to reuse the same constant
22:59:52 <newsham> if you wrote it differently it owuld be more obvious but then you'd bake in more constants and prob generate worse asm
23:00:17 <edwardk> yeah
23:02:42 <applicative> well, actually the argument of riotnerd is really nice; i take it back about newsham
23:03:34 <edwardk> had i taken more time to get the first post structured, i would have preferred to have done the proof like that Bird style
23:04:53 <applicative> the definition of swapN would be better if he had --> and <-- , or like nonsense, for the unsafeShifts
23:05:32 <johnw> edwardk: did you start your little snap example with ``` haskell active web?
23:06:03 <edwardk> johnw: i managed to fix that part, though i had to find that the hard way the docs don't say to do anything different that i could find
23:06:22 <edwardk> now i'm stalled out because it times out i think.
23:06:25 <applicative> ``` haskell active web ???
23:06:28 <edwardk> so i need to figure out what to do differently
23:07:06 <johnw> ok, closing the issue
23:07:14 <johnw> applicative: school of haskell markup
23:07:55 <newsham> wait.. dont you have the answer to your first challenge in the code for the 2nd challenge?
23:08:33 <edwardk> newsham: i have half shuffles there
23:08:44 <edwardk> it follows from that if you work through it of course ;)
23:08:56 <edwardk> but if you look at it as a wall of text.. ;)
23:09:16 <edwardk> also the 2nd challenge is a bit harder
23:09:23 <edwardk> coz you have to actually work out new masks/shifts
23:10:41 <edwardk> the no-prizes are a way for me to gauge what stuff people are paying attention to, to draw a little bit of help from the community and are for a little bit of fun
23:16:07 <newsham> i'm guessing i'm just left shifting all the constant masks (not m1 and m2 though) by 1.
23:16:36 <edwardk> newsham: i haven't done it. give it a try
23:17:23 <newsham> i could give it a shot, but i'd rather work it through by manipulating the expressions, if i was going to implement it.
23:17:55 <newsham> i would start by taking the shift out of i5 and working backwards from there.
23:22:15 <edwardk> newsham: sounds good.
23:22:30 * hackagebot clckwrks-plugin-page 0.2.1 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.2.1 (JeremyShaw)
23:27:30 * hackagebot clckwrks-cli 0.2.6 - a command-line interface for adminstrating some aspects of clckwrks  http://hackage.haskell.org/package/clckwrks-cli-0.2.6 (JeremyShaw)
23:41:53 <newsham> edwardk: I think I got it. http://www.thenewsh.com/~newsham/x/machine/kmett-shuffle2.hs  but I don't have lense stuff around for testing...
23:43:06 <newsham> the right-most masks got shifted, and the constant shifts got incremented
23:43:37 <edwardk> newsham: that roughly fits with my expectations
23:43:57 <edwardk> newsham: i'll check it when i wake up, but it sounds like you earned a no-prize =)
23:44:12 <newsham> woot.  i'm put it on no shelf
23:44:18 <shelf> hey now
23:44:35 <shelf> don't do that
23:44:41 <kloplop321> So, I was trying to do something that would result in a `Maybe (a, b)`, so I tried to do `(,) <$> pure a <*> someMaybeFunc a` but that results in a `(a, Maybe b)`, I'd rather not have to do a case of for the second part, what am I misunderstanding?
23:45:26 <Ralith> :t \f x y -> f <$> x <*> y
23:45:27 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
23:45:55 <Ralith> kloplop321: :t someMaybeFunc
23:46:09 <kloplop321> Maybe b
23:46:11 <newsham> reward #2: sleep.. cheers
23:46:27 <Ralith> kloplop321: that is wrong
23:46:57 <kloplop321> well, it conflicts with the above type definition, so it would be `Maybe a` according to that type definition by lambdabot
23:47:10 <kloplop321> though in my example, it would be `Maybe b`
23:47:17 <Ralith> 'Maybe a' is not a function
23:47:24 <kloplop321> Oh
23:47:33 <kloplop321> `a1 -> Maybe a`
23:47:45 <Ralith> someMaybeFunc always returns Nothing?
23:47:49 <kloplop321> No.
23:47:52 <Ralith> then that is wrong.
23:47:53 <kloplop321> It can return Nothing.
23:47:56 <kloplop321> How so?
23:48:21 <Ralith> a function which may return a value other than Nothing cannot have type 'a1 -> Maybe a'
23:48:54 <kloplop321> Then how do you interpret the end `Maybe a`?
23:49:19 <Ralith> what is "the end `Maybe a`"?
23:49:36 <kloplop321> The return type of the fully evaluated function.
23:49:36 <dpwright> I'm trying to compile this snippet using the pipes-network module: https://gist.github.com/jhickner/5589907 but I get "No instance for (pipes-3.2.0:Control.Proxy.Class.Proxy ProxyFast) arising from a use of `socketReadS'"... this seems to be an issue that came up some time ago looking at the pipes-network issues history, but it looks as if it should be fixed by now.  Has anybody come across this?
23:49:52 <Ralith> which function?
23:49:57 <kloplop321> someMaybeFunc
23:50:05 <Ralith> I don't know what the type of someMaybeFunc is.
23:50:14 <kloplop321> I said it was `a1 -> Maybe a`
23:50:18 <Ralith> yes, but you are wrong.
23:50:29 <kloplop321> You aren't teaching me how.
23:50:31 <shachaf> dpwright: If the package version is mentioned, then you probably have multiple versions of the package.
23:50:34 <shachaf> Don't.
23:50:51 <Ralith> you should load your file in ghci and enter ':t someMaybeFunc'
23:50:57 <Ralith> that will tell you what its type really is.
23:51:31 <dpwright> shachaf -- thanks, I *do* have two versions of the package.  I'll try removing one of them.
23:52:41 * hackagebot Commando 1.0.0.2 - Watch some files; Rerun a command  http://hackage.haskell.org/package/Commando-1.0.0.2 (LyndonMaydwell)
23:52:46 <kloplop321> Ralith: someMaybeFunc :: FromJSON b => KVEntity -> Maybe b
23:53:25 <kloplop321> I do not see how this conflicts at all with what I said.
23:53:52 <shachaf> It conflicts because you didn't quantify a1 and a, so people assumed you meant ":: forall a1 a. ..."
23:53:58 <shachaf> (Which is also what Haskell assumes.)
23:54:08 <hape02> @hoogle KVEntity
23:54:08 <lambdabot> No results found
23:54:21 <Gracenotes> metasyntactic concrete types: use uppercase
23:55:11 <kloplop321> I do not know how to use forall. Though I, in my original example, was using a and b, whereas to be consistent with the lambdabot output, I used the types specified for what came out there.
23:55:54 <dpwright> shachaf -- perfect, that fixed it.  thanks!
23:56:17 <Ralith> kloplop321: 'a' and 'b' as used in the lambdabot output are free variables, not constants.
23:56:23 <kloplop321> I know that.
23:56:34 <kloplop321> But it used f a1 -> f a -> f b
23:56:55 <Ralith> KVEntity as used in the type of someMaybeFunc is not a free variable
23:57:27 <Ralith> 'b' as used in the type of someMaybeFunc is constrained by a typeclass.
23:57:54 <kloplop321> Basically, I want to make a `Maybe (KVEntity, b)` instead of a `(KVEntity, Maybe b)` which the applicative `(,) <$> pure a <$> someMaybeFunc a` produces in type signature, which surprised me.
23:59:25 <kloplop321> Currently I am using a `case someMaybeFunc e of`, when I thought I could use the applicatives to make the whole thing a Maybe instead of the internal value.
