00:07:15 * hackagebot sparse 0.6 - A playground of sparse linear algebra primitives using Morton ordering  http://hackage.haskell.org/package/sparse-0.6 (EdwardKmett)
00:14:27 <Palmik> Does anyone know what's wrong with Hackage? The documentation of one of my packages has not been compiled since the 4th of July.
00:22:11 <johnw> more than likely hscolour failed due to an out of memory error or something like that
00:22:20 <johnw> it happens to some of my packages too
00:22:22 <johnw> check the log
00:42:08 <Palmik> johnw: There is no log (like there usually is on build failure for example).
00:45:54 <applicative> Zenol: what s this 'dvp' format?
00:53:32 <Zenol> applicative: something uninteresting (xml format) used by a dozen of frenches.
00:54:32 <Zenol> applicative: and the spec are internal to the team of writers.
00:57:29 <Zenol> applicative: But I'm really interested in advice and highlight of badly writen parts / too verbose parts.
01:19:13 <mcstar> can someone briefly explain to me how does 'monadic sharing' help counteract code explosion in 'multi stage programming'?
01:19:36 <johnw> where did you read that?
01:20:22 <mcstar> 'a methodology for generating verified combinatorial circuits' by kiselyov, swadi, taha
01:20:58 <johnw> ah, haven't read it
01:21:02 <mcstar> they cite an article in preparation, which i cant really find, probably never appeared in a journal
01:21:34 <mcstar> i just dont see why writing pure computation in a monadic style will reduce code explosion
01:21:45 <mcstar> and the article treats this issue as a black box, they cite the lib
01:22:03 <johnw> i'm not sure what kind of "explosion" you mean
01:22:06 <mcstar> sry, writing it in a monadic style is only a requirement, not the solution
01:22:08 <johnw> lines of code?
01:22:22 <mcstar> johnw: eliminating code duplication i recon
01:22:54 <johnw> well, it does let you factor out common "context" among a group of functions
01:23:08 <johnw> and if you have several contexts, it can really help (exceptions, state, environment, etc)
01:24:02 <mcstar> i wonder if they used a similar thing to  Jason Eckhardt, Roumen Kaiabachev, Oleg Kiselyov,
01:24:04 <mcstar> Kedar N. Swadi, and Walid Taha. Monadic multi-stage
01:24:06 <mcstar> programming. In preparation, July 2004.
01:24:18 <mcstar> sry, my middle button is misbehaving
01:24:24 <mcstar> i wanted to paste something different
01:25:07 <mcstar> i wonder if they used a similar thing to Control.Monad.Sharing, or if it is conceptually the same thing at all
01:29:37 <johnw> neat, i'll read up on that
01:31:29 <kryft> Uhh.. I have a record type, and when I try to call one of the field accessors (or whatever they're called) in ghci, the function never returns; any idea what's going on here?
01:33:46 <mcstar> kryft: you should paste the snippet to the fav. haskell pastebin
01:37:08 <johnw> sounds like you have a recursively defined value
01:39:24 <kryft> johnw: Ah
01:40:15 <kryft> I think I may have used the same name for a type and a value constructor
01:40:53 <mcstar> thats not a problem in itself
01:42:19 <johnw> yeah, that's typical
01:50:11 <kryft> Hmm, apparently it's something else, because I renamed the value constructor and now I'm getting the problem again
01:51:31 <hpaste> kryft pasted “Record accessor hanging” at http://lpaste.net/92167
01:51:51 <johnw> which accessor?
01:52:13 <kryft> Any of them apparently
01:52:25 <kryft> (Well, I tried song, will, activeSongs)
01:53:34 <johnw> instead of func $ evasion player, and accuracy attack
01:53:37 <johnw> can you try func $!?
01:54:05 <johnw> the thunk created by calling func may be inadvertantly tying the knot here
01:54:18 <johnw> or wait
01:54:19 <johnw> better yet
01:54:26 <johnw> make the type of evasion and accuracy strict
01:54:31 <johnw> evasion :: !Int
01:54:33 <johnw> etc.
01:55:51 <kryft> Ah, I didn't actually try calling modifyEvasionWith though
01:56:32 <johnw> oh, wait
01:56:34 <johnw> i think I may see it
01:56:39 <johnw> lines 59-61
01:57:01 <johnw> oh, maybe not
01:57:47 <kryft> johnw: Ok, so basically if I do let foo = blankPlayer in ghci, then the accessors work
01:58:35 <kryft> johnw: Oh no, I was very stupid :)
01:58:42 <kryft> I doubt there's anything wrong with the code I pasted
01:58:50 <johnw> ok
01:59:02 <mcstar> if you can 'show' the player, you can definitely access any field of it
01:59:05 <kryft> johnw: I did let foo = blankPlayer, and then did let foo = foo { ..}
01:59:15 <johnw> aha
01:59:19 <johnw> that's what I meant originally :)
01:59:28 <kryft> johnw: Right, yes
01:59:50 <kryft> johnw: I was just staring at the code and didn't realize I could have done it in ghci
02:01:12 <kryft> Apparently some imperative thinking crept in :P
02:04:24 <kryft> johnw: Incidentally, earlier I had data Singing = Quiet | Song | --etc (instead of Singing = Quiet | OneSong Song), and the compiler didn't complain, but isn't it then ambiguous whether, say, SongSharp is Song or Singing?
02:04:39 <kryft> s/is/has the type
02:08:05 <johnw> what is SongSharp?
02:11:23 <kryft> johnw: It's a value constructor for Song (data Song = SongSharp | ..)
02:11:46 <johnw> and why would that get confusied with Singing?
02:14:43 <arkeet> kryft: one Song is a constructor of Singing. the other Song is a type, which has SongSharp as a constructor.
02:14:50 <arkeet> the two Songs apparently are unrelated.
02:15:17 <arkeet> as you had written it, anyway.
02:15:19 <kryft> arkeet: Ah, right, so the code wouldn't have done what I intended
02:16:15 <kryft> And I do need Singing = Quiet | OneSong Song to be able to have a Singing value like OneSong SongSharp
02:17:10 <kryft> Right, value constructors and type constructors live in separate namespaces
02:17:48 <kryft> Thanks
02:19:24 <arkeet> indeed. np
03:01:43 <Taneb> preflex: seen bonus
03:01:43 <preflex>  bonus was last seen on #haskell 2 years, 117 days, 14 hours, 33 minutes and 44 seconds ago, saying: yeah i think that's better as well
03:03:39 <haasn> edwardk: you mentioned there being a variant of ContT that has a MonadFix instance?
03:04:30 <kuribas> How do you quickcheck or test functions that aren't exported by the module?
03:07:12 <donri> kuribas: by exporting them from an .Internal module
03:07:31 <donri> (yeah, it kinda sucks)
03:07:47 <haasn> edwardk: in particular http://www.reddit.com/r/haskell/comments/1jk06q/goto_in_haskell/ <edwardkmett> You can make a variant of it that is MonadFixable. I've built this before for an "assembler" eDSL.
03:08:10 <kuribas> donri: Ah I see.
03:08:24 <donri> i wish we had like, `import internal`, that always just-worked except with -XSafe
03:08:45 <kuribas> donri: Isn't it better to keep them inside a module for extra optimizations, such as inlining?
03:09:35 <donri> kuribas: you can always put pragmas on 'em
03:09:42 <kuribas> ok
03:10:40 <donri> INLINABLE is a good default for key functions
03:12:45 * hackagebot diagrams-pdf 0.3 - PDF backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-pdf-0.3 (alpheccar)
03:13:10 <Taneb> Does a Raspberry Pi have what it takes to compile GHC 7.6?
03:13:47 <johnw> shapr would know
03:14:13 <Taneb> Yeah, I think I payed for like half of his pi one day when I was bored and felt rich
03:19:23 <circle> who would be interested in making a new haskell interpreter in Java?
03:19:31 <circle> called Jaskell
03:20:46 <identity> circle: Why?
03:21:04 <circle> because?
03:21:10 <Rembane> circle: Haskell on the JVM?
03:21:14 <circle> yes
03:22:31 <Rembane> Do it!
03:25:57 <latermuse> is it possible to use M.unionsWith to do something like this? M.Map T.Text String -> M.Map T.Text Int -> [String, Int]
03:26:54 <valyagolev> @type Data.Map.unionsWith
03:26:55 <latermuse> im trying: M.unionWith (,) map1 map2
03:26:56 <lambdabot> Ord k => (a -> a -> a) -> [M.Map k a] -> M.Map k a
03:27:16 <latermuse> but M.unionWith (,) map1 map2 doesnt seem to work
03:27:31 <johnw> and it can't
03:27:38 <johnw> what if map1 has a key that map2 doesn't?
03:27:45 <johnw> you want alignWith
03:28:10 * hackagebot lens-datetime 0.1 - Lenses for Data.Time.* types  http://hackage.haskell.org/package/lens-datetime-0.1 (MihalyBarasz)
03:28:30 <latermuse> johnw: alignWith is not in the Data.Map library
03:28:51 <latermuse> I dont mind making my own function to do this. I was just hoping there was a premade something or other that could do it
03:29:57 <latermuse> Map k a -> Map k b -> [a,b]
03:30:09 * latermuse shrugs.
03:30:31 <valyagolev> @type (&&&)
03:30:33 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
03:31:01 <valyagolev> @type \a b - > elems (a &&& b)
03:31:02 <lambdabot> parse error on input `-'
03:31:07 <valyagolev> @type \a b -> elems (a &&& b)
03:31:08 <lambdabot>     Could not deduce (Arrow Array) arising from a use of `&&&'
03:31:08 <lambdabot>     from the context (Ix i)
03:31:08 <lambdabot>       bound by the inferred type of
03:31:25 <donri> latermuse: intersectionWith?
03:31:34 <valyagolev> @type \a b -> Data.Map.elems (a &&& b)
03:31:34 <johnw> it's in the "these" package
03:31:35 <lambdabot>     No instance for (Arrow M.Map) arising from a use of `&&&'
03:31:37 <lambdabot>     Possible fix: add an instance declaration for (Arrow M.Map)
03:31:39 <lambdabot>     In the first argument of `M.elems', namely `(a &&& b)'
03:31:49 <donri> :t M.intersectionWith (,)
03:31:51 <lambdabot> Ord k => M.Map k a -> M.Map k b -> M.Map k (a, b)
03:32:34 <latermuse> hmm. intersectionWith might just do the trick
03:33:50 <latermuse> well the program compiled. looks like I will use interseciton with, then drop the (M.Map k) part, leaving me with a list of [(a,b)]
03:33:53 <latermuse> thanks fellas!
03:35:30 <donri> :t \a b -> zip (M.values a) (M.values b)
03:35:33 <lambdabot> Couldn't find qualified module.
03:35:40 <latermuse> feels hacky, but this seems to have dropped the (M.Map k): map snd $ M.toList
03:36:19 <donri> :t \a b -> zip (M.elems a) (M.elems b)
03:36:19 <lambdabot> M.Map k a -> M.Map k1 b -> [(a, b)]
03:36:36 <donri> latermuse: ^ that's what you want. you should've said you only wanted the elements in the first place :p
03:36:50 <arkeet> zipping the values sounds just wrong
03:37:08 <latermuse> the type is right, but I dont think the zip is a good idea
03:37:46 <latermuse> I ended up with this: map snd . M.toList . M.intersectionWith (,) $ map1 map2
03:37:51 <donri> latermuse: well then use the intersection plus Map.elems rather than toList and map snd
03:38:10 <latermuse> ahh good idea
03:38:11 <valyagolev> is zip going to preserve grouping by keys?
03:38:16 <arkeet> no
03:38:50 <donri> yeah you're right of course
03:38:56 <donri> don't #haskell before morning coffee, bbl
03:38:57 <latermuse> oh wait, i dont think the elems will work
03:39:19 <latermuse> toList and map snd is what ill use. thanks guys!
03:39:20 <valyagolev> why wouldn't they/
03:39:27 <valyagolev> @t elems
03:39:27 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
03:39:33 <valyagolev> @?
03:39:38 <arkeet> what if one map has keys the other doesn't?
03:39:44 <valyagolev> @type elems
03:39:44 <lambdabot> Ix i => Array i e -> [e]
03:39:52 <donri> @check \m -> map snd (M.toList m) == M.elems m
03:39:53 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary.Arbitrary
03:39:53 <lambdabot>                     (D...
03:39:55 <latermuse> if one map has different keys, then it wont match up if i use elems
03:39:56 <donri> :(
03:40:06 <arkeet> :t M.intersectionWith (,)
03:40:06 <lambdabot> Ord k => M.Map k a -> M.Map k b -> M.Map k (a, b)
03:40:14 <arkeet> ah, donri already said it.
03:40:35 <valyagolev> @source M.elems
03:40:35 <lambdabot> Unknown command, try @list
03:40:39 <valyagolev> @list
03:40:39 <lambdabot> What module?  Try @listmodules for some ideas.
03:40:49 <valyagolev> I think there was a command that gave source?
03:40:51 <hape01> @src M.elems
03:40:52 <lambdabot> Source not found. stty: unknown mode: doofus
03:40:56 <arkeet> there is @src but it is very dumb.
03:41:01 <valyagolev> @src Data.Map.elems
03:41:01 <lambdabot> Source not found. Take a stress pill and think things over.
03:41:04 <arkeet> @where @src
03:41:04 <lambdabot> I know nothing about @src.
03:41:05 <arkeet> @where src
03:41:06 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
03:41:11 <donri> latermuse: eh the intersection will discard keys not in both maps
03:41:19 <donri> latermuse: there's no sensible way to do what you want
03:41:30 <arkeet> what does he want?
03:41:33 <valyagolev> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/src/Data-Map-Base.html#elems
03:41:43 <latermuse> i dont mind discarding keys not in both maps
03:41:49 <donri> he wants a list of pairs of elements from two maps
03:41:56 <donri> latermuse: well then elems is fine?
03:42:24 <valyagolev> maybe you want Map a b -> Map a c -> [(Maybe b, Maybe c)]
03:42:39 <donri> heh
03:43:34 <donri> [Either (a,b) (Either a b)] yay! ;)
03:43:53 <arkeet> :(
03:43:56 <valyagolev> [[Either a b]]
03:44:08 <donri> ([a],[b]) :p
03:44:23 <valyagolev> this one is got going to group by key :(
03:44:43 <donri> well grouping by key is nonsensical if the keys don't align :p
03:45:31 <arkeet> can we have some unionWith-alike with (Maybe a -> Maybe b -> Maybe c) -> Map k a -> Map k b -> Map k c
03:46:10 <arkeet> (with the rule that the argument must return Nothing when given Nothings)
03:46:22 <arkeet> you know, thinking of Map k a as a function k -> Maybe a
03:49:55 <johnw> arkeet: it's kind of called alignWith
03:50:09 <johnw> (These a b -> c) -> Map k a -> Map k b -> Map k c
03:50:20 <arkeet> what's These
03:50:29 <johnw> either This a, That b, or These a b
03:50:33 <arkeet> ok.
03:50:38 <arkeet> I like having Maybe c there, but ok.
03:50:50 <donri> [ (M.lookup k a, M.lookup k b) | k <- M.keysSet a <> M.keysSet b ]
03:50:50 <johnw> i'm sure you can write a fromThese
03:51:09 <arkeet> but it would generalize both intersectionWith and unionWith.
03:51:23 <arkeet> and differenceWith.
03:51:23 <donri> :t \a b -> [ (M.lookup k a, M.lookup k b) | k <- M.keysSet a <> M.keysSet b ]
03:51:24 <arkeet> I suppose.
03:51:24 <lambdabot>     Couldn't match expected type `[k0]' with actual type `S.Set k0'
03:51:25 <lambdabot>     In the return type of a call of `M.keysSet'
03:51:25 <lambdabot>     In the first argument of `(<>)', namely `M.keysSet a'
03:51:26 <valyagolev> @type \a b f -> (uncurry f) <$> (fmap (,) a <*> b)
03:51:27 <lambdabot> Applicative f => f a -> f b1 -> (a -> b1 -> b) -> f b
03:51:39 <johnw> arkeet: I only say this because I use alignWith for this exact same purpose not 5 days ago :)
03:51:41 <arkeet> we need a lens that can do these sorts of generalizations of liftA2 and whatnot.
03:51:50 <donri> :t \a b -> [ (M.lookup k a, M.lookup k b) | k <- Data.Set.toList (M.keysSet a <> M.keysSet b) ]
03:51:51 <lambdabot> Ord k => M.Map k a -> M.Map k a1 -> [(Maybe a, Maybe a1)]
03:52:10 <latermuse> johnw: could you paste your alignWith code?
03:52:11 <arkeet> lens covers Functor => Foldable => Traversable, but not Functor => Applicative => Monad
03:52:14 <johnw> sure
03:52:16 <arkeet> mostly Applicative would be interesting.
03:52:17 <latermuse> thanks
03:52:38 <johnw> https://gist.github.com/6333233
03:53:29 <latermuse> johnw: what library is alignWith from?
03:53:33 <johnw> these
03:53:37 <johnw> @hackage these
03:53:38 <lambdabot> http://hackage.haskell.org/package/these
03:53:50 <latermuse> oh! I thought you were joking earlier haha
03:53:53 <johnw> it works for any Alignable structure
03:54:18 <latermuse> ah i got it
03:56:19 <valyagolev> is These really nice to use? or just a pattern-matching helper?
03:56:33 <johnw> well, it saves you from having to write alignWith, mainly
03:56:44 <johnw> it's not really about the These database
03:56:46 <johnw> data type
03:56:50 <valyagolev> hm, what's a Prism
03:57:17 <johnw> a prism is something gives you a view into a data structure, or a way to create a data structure by supplying what would be viewed
03:57:20 <johnw> like _Left
03:57:29 <johnw> > Left 40 ^. _Left
03:57:30 <lambdabot>   No instance for (Data.Monoid.Monoid a0)
03:57:30 <lambdabot>    arising from a use of `e_140'
03:57:30 <lambdabot>  T...
03:57:34 <johnw> > Left 40 ^.. _Left
03:57:37 <lambdabot>   [40]
03:58:06 <donri> oic newtype These a b = Either (a,b) (Either a b)
03:58:32 <valyagolev> oh, it's in lens. I'm still waiting for a good moment to read the docs
03:59:36 <haasn> mm_freak_: I decided not to use netwire for my VN thing after all, I need the power of Monad
04:01:11 <johnw> > _Left._Right # 10
04:01:13 <lambdabot>   Left (Right 10)
04:01:16 <valyagolev> I like noticing how people use I/you pronouns in docs. I think I often mix pronouns up when I write documentation
04:01:18 <johnw> > Left (Right 10) & _Left._Right .~ "Hello"
04:01:20 <lambdabot>   Left (Right "Hello")
04:01:39 <donri> valyagolev: basically a prism is an (a -> b, b -> Maybe a) for example _Left = (Left, \e -> case e of Left a -> Just a; _ -> Nothing)
04:02:02 <valyagolev> I see, yeah. Thank you! Looking at http://hackage.haskell.org/packages/archive/lens/3.7.2/doc/html/Control-Lens-Prism.html
04:02:17 <johnw> donri: good explanation
04:02:21 <donri> valyagolev: why are you looking at lens 3.7
04:02:32 <valyagolev> That's what google gave me
04:02:43 <arkeet> they got better in 3.8
04:02:53 <johnw> 3.9.0.2
04:02:59 <arkeet> that's the latest, yes.
04:03:02 <johnw> is where all the cool kids hangout
04:03:04 <arkeet> but 3.8 introduced teh profunctor stuff.
04:03:09 <donri> i have a keyword "h" in firefox for "hackage.haskell.org/package/%s" :)
04:03:10 <arkeet> no, the cool kids hang out in HEAD.
04:03:12 <valyagolev> I just changed to "latest" in the url
04:03:28 <arkeet> or in k.hs
04:03:33 <johnw> donri: thanks for reminding me to create a TextExpander snippet for tat
04:03:37 <arkeet> or whatever the last one was
04:03:44 <valyagolev> well I had no idea in which package to look, I Hoogled and got nothing, so then google gave me this:)
04:04:17 <donri> valyagolev: hayoo works better when you don't know the package
04:04:43 <valyagolev> never heard of this one, thanks
04:13:27 * hackagebot git-gpush 2.1.0.0 - More intelligent push-to-GitHub utility.  http://hackage.haskell.org/package/git-gpush-2.1.0.0 (JohnWiegley)
04:13:29 * hackagebot git-monitor 2.1.0.0 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-2.1.0.0 (JohnWiegley)
04:13:31 * hackagebot gitlib 2.1.0.0 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-2.1.0.0 (JohnWiegley)
04:13:33 * hackagebot gitlib-cmdline 2.1.0.0 - Gitlib repository backend that uses the git command-line tool.  http://hackage.haskell.org/package/gitlib-cmdline-2.1.0.0 (JohnWiegley)
04:13:35 * hackagebot gitlib-cross 2.1.0.0 - Run tests between repositories  http://hackage.haskell.org/package/gitlib-cross-2.1.0.0 (JohnWiegley)
04:16:16 <valyagolev> I thought of using git-monitor to do snapshots on save/lostFocus in sublime instead of watching from console
04:16:45 <johnw> i use git-monitor continually for all my work-related repositories
04:16:54 <johnw> it has saved me too many times to count so far
04:17:21 <valyagolev> did I understand correctly that it doesn't mess with your actual commits and index?
04:17:24 <johnw> i use "multitail" to spawn several of them at once in a terminal window
04:17:26 <johnw> right
04:17:32 <johnw> it's completely "side-band"
04:17:36 <valyagolev> cool
04:17:56 <johnw> in fact, to see your snapshot log you have to run: git log refs/snapshots/refs/heads/master
04:18:18 <johnw> (although, you almost always want log -p, to see your minute-to-minute changes)
04:18:37 * hackagebot gitlib-libgit2 2.1.0.0 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-2.1.0.0 (JohnWiegley)
04:18:39 * hackagebot gitlib-s3 2.1.0.0 - Gitlib repository backend for storing Git objects in Amazon S3  http://hackage.haskell.org/package/gitlib-s3-2.1.0.0 (JohnWiegley)
04:18:41 * hackagebot gitlib-sample 2.1.0.0 - Sample backend for gitlib showing the basic structure for any backend.  http://hackage.haskell.org/package/gitlib-sample-2.1.0.0 (JohnWiegley)
04:18:43 * hackagebot gitlib-test 2.1.0.0 - Test library for confirming gitlib backend compliance  http://hackage.haskell.org/package/gitlib-test-2.1.0.0 (JohnWiegley)
04:19:14 <valyagolev> does Haskell have hackatrons like clojure-cup or something?
04:19:36 <johnw> maybe hacphi?  or bayhac?
04:20:02 <donri> i just use persistent undo with undotree in vim
04:20:15 <valyagolev> oh cool. too bad they already happened in 2013
04:20:34 <valyagolev> hm, they also seem offline :(
04:21:10 <donri> which stores changes even between saves
04:21:34 <osfameron> oh, git-monitor is in haskell?
04:21:34 <johnw> what happens when you exit your editor?
04:21:38 <johnw> osfameron: yes
04:21:50 <donri> johnw: doesn't matter, it's persistent
04:21:54 <johnw> ah
04:21:54 <osfameron> does it have any docs?
04:22:04 <johnw> osfameron: you just run "git-monitor" within a repository
04:22:13 <johnw> there's just --help other than that
04:22:14 <osfameron> https://github.com/fpco/gitlib/ doesn't seem to be particularly well endowed with them...
04:22:20 <johnw> no, that's on my TODO list
04:22:27 <osfameron> how do you install it?
04:22:28 <johnw> in September I intend to write many docs for gitlib
04:22:31 <johnw> cabal install git-monitor
04:22:58 <osfameron> cool!  I will have a play with that soon (new hard drive crash has inspired periodic interest in looking at range of backup tools ;-)
04:23:10 <johnw> there's also #gitlib, if you ever want help with gitlib hacking
04:23:25 <osfameron> thanks
04:23:39 <johnw> I concurrently use 5 different backup methods while I  work
04:23:52 <donri> does things like this help in face of a hard drive crash though?
04:24:05 <donri> yeah you need "external" backups too
04:24:13 <johnw> Emacs saves every single version of every file I ever edit; git-monitor; CrashPlan; Time Machine; periodic rsync to a ZFS filesystem which then uses snapshots
04:24:25 <osfameron> luckily *most* important stuff I have is in gmail, dropbox, or github
04:24:42 <johnw> each day, all of that gets rsync'd to a VPS that I rent solely for backup data
04:24:47 <donri> johnw: is that every save or every edit in emacs?
04:24:52 <johnw> donri: every save
04:25:00 <johnw> between saves, I have the undo buffer
04:25:12 <donri> johnw: is that persistent?
04:25:15 <johnw> yes
04:25:21 <donri> cool
04:25:34 <johnw> so, technically git-monitor is overkill
04:25:50 <johnw> but, (a) you can never have enough backup, and (b) git is a much nicer tool for forensically examining recent change history
04:25:56 <donri> i think there are undotree plugins for emacs too, you should try it :)
04:26:05 <johnw> I have; too different
04:26:26 <donri> too different to what?
04:27:02 <johnw> to what I'm used to
04:27:32 <osfameron> can you get git-monitor to automatically push the commits it generates?
04:27:45 <donri> does it actually make commits?
04:27:50 <johnw> yes
04:28:08 <donri> ah, on an orphan branch?
04:28:14 <johnw> osfameron: interesting idea; I guess you could add that to a post-commit hook
04:28:17 <johnw> donri: right
04:28:34 <johnw> donri: not orphan per se, it shares history with your current branch
04:28:48 <johnw> for each branch, there is a snapshot ref refs/snapshots/refs/heads/branch
04:28:55 <donri> oh
04:29:07 <johnw> so if you do git log --all, you'll see them
04:29:25 <johnw> they get clobbered each time you re-run git-monitor
04:29:31 <johnw> so that git gc will ultimately clean them up
04:29:46 <osfameron> git-monitor only checks Git-tracked files?
04:29:53 <johnw> right
04:29:59 <osfameron> so it won't add new files transparently?
04:30:03 <johnw> correct
04:30:09 <osfameron> ah.  hmm
04:30:14 <johnw> i had to draw a line somewhere
04:30:22 <johnw> i could add that as an option, though
04:30:57 <osfameron> as its purpose is to save you from yourself, it would be a good option, at least for my use-case
04:31:39 <johnw> ok, adding two things to my list: save untracked (but not ignored) files, and allow for a post-commit script option
04:31:50 <osfameron> \o/
04:32:39 <johnw> writing Git utilities in Haskell is pretty fun, actually
04:32:56 <johnw> compared to earlier experiences in mainly untyped languages, or in C++, it's nice having the types to guide correctness
04:33:11 <osfameron> yeah, sounds like a great real-world example of using it
04:33:32 <johnw> well, it was also written as a demo, so yeah :)
04:33:44 * osfameron had been vaguely thinking of writing someting like this in Perl
04:34:02 <johnw> i had written it in C++ before, and was using that version for a while
04:34:04 <mm_freak_> haasn: do you?
04:34:07 <johnw> but I trust the Haskell one more
04:34:21 <osfameron> (where you don't have the type correctness, but there are a lot of decent git libraries to help)
04:34:34 <mm_freak_> haasn: monadic FRP doesn't work too well
04:35:08 <johnw> mm_freak_: is that because effects are unpredictably replicated?
04:35:42 <mm_freak_> johnw: mainly because we didn't yet figure out how to do it =)
04:35:49 <haasn> mm_freak_: I want to branch on the result of a choice
04:36:06 <johnw> mm_freak_: fair enough; I'm pretty eager to try FRP coding sometime
04:36:10 <mm_freak_> haasn: you mean like ArrowChoice? =)
04:38:38 <haasn> mm_freak_: as in:  menu [("Option 1", putStrLn "you chose 1" >> quit), "Option 2", option2)] -- where menu :: [(String, m b)] -> m b -- or something
04:39:03 <mm_freak_> haasn: that's a switch
04:39:26 <mm_freak_> netwire allows switching based on a signal
04:39:45 <mm_freak_> in non-AFRP you would call that dynamic switching
04:39:50 <haasn> ah
04:40:13 <mm_freak_> at least netwire and reactive-banana support it
04:40:29 <danilo2> Hi! Is it possible to customize the way HUnit prints its errors? Normally we can see something like: "expected: [[1,2],[[3],[4]]]", but I want it tu use pretty print for shownig what was expected. Is it possible?
04:41:01 <johnw> pretty x @?= pretty y
04:41:11 <haasn> I'll give it a shot, then -- if I just use a plain-old monad stack the problem is ‘boring’ either way
04:41:14 <johnw> or make your own pretty operator
04:41:37 <mm_freak_> danilo2: there is certainly some PrettyPrint class somewhere
04:41:44 <mm_freak_> newtype Pretty a = Pretty a
04:41:51 <mm_freak_> instance (PrettyPrint a) => Show (Pretty a)
04:42:20 <mm_freak_> haasn: if you know how netwire works internally then everything is a switch =)
04:42:35 <mm_freak_> but that's a bad way to look at it, because it discretizes time
04:43:30 <danilo2> johnw: the idea with "pretty x @?= pretty y" could work :) thank you
04:43:42 <mm_freak_> haasn: you may also think in modes:  menu mode, display mode, quit mode, etc.
04:43:51 <mm_freak_> in that case you can use 'context'
04:44:10 <danilo2> mm_freak_: yes there are a lot of pretty printers out there, but I was talking about integrating them with messages from HUnit :)
04:44:35 <mm_freak_> danilo2: since HUnit uses Show i just showed you a way to do it =)
04:46:04 <danilo2> mm_freak_: ok, I got it now - I missunderstood firstly what you've shown, thanks :)
04:56:33 <haasn> mm_freak_: switching looks interesting
04:57:31 <mm_freak_> haasn: FRP without switching is basically just a simplistic animation pattern
04:57:43 <haasn> yeah makes sense
04:58:43 * hackagebot genprog 0.1.0.1 - Genetic programming library  http://hackage.haskell.org/package/genprog-0.1.0.1 (JanSnajder)
04:59:55 <haasn> mm_freak_: so how exactly do I deal with user input? eg. say I want to have a wire that goes through a list of values, moving to the next one each time I press a certain key
05:00:06 <haasn> (and then inhibiting when it gets to the end)
05:02:04 <mm_freak_> haasn: let the wire produce as long as it should be active
05:02:06 <mm_freak_> use (-->)
05:02:11 <mm_freak_> w1 --> w2 --> w3
05:02:23 <mm_freak_> when w1 inhibits, it's w2's turn
05:02:25 <haasn> yes, but how does the wire know when it's time to ‘switch’?
05:02:31 <haasn> where does user input fit into this
05:02:44 <mm_freak_> user input depends on whether you want to use netwire 4 or 5
05:02:56 * haasn .oO( higher = better? )
05:03:06 <mm_freak_> yes, but 5 is not released yet
05:03:21 <haasn> as long as it works
05:03:23 <mm_freak_> http://hub.darcs.net/ertes/netwire ⇐ code and tutorial
05:03:39 <mm_freak_> it works, but i might make some minor interface changes here and there
05:03:50 <kuribas> @pl (\x m -> x * (n-m+1)/m)
05:03:54 <mm_freak_> most of the API is stabilized though
05:04:07 <lambdabot> join . ((/) .) . (. ((+ 1) . (-) n)) . (*)
05:04:07 <lambdabot> optimization suspended, use @pl-resume to continue.
05:04:25 <kuribas> lambdabot: never mind
05:05:46 <kuribas> > let binCoeff n = scanl (\x m -> x * (n-m+1) `quot`m) 1 [1..n] in binCoeff 6
05:05:51 <lambdabot>   [1,6,15,20,15,6,1]
05:05:51 <mm_freak_> haasn: read the tutorial and then choose…  it explains events and switching…  the section on inhibition is not finished yet, but it's pretty much like in netwire 4…  the only difference is that production/inhibition intervals are expected to be non-zero length
05:06:08 <mm_freak_> i.e. you can't represent instantaneous/discrete events using it
05:06:23 <haasn> I'll give it a read, thanks
05:12:54 <eevar> data Socket = Socket (SocketType x) Int String  -- I want to do something like this, where SocketType has instances Push, Pull, Publish, Subscribe and so on, to hold common data and write generic functions. Can I just fix my syntax, or do I need to rething the whole idea?
05:14:21 <pentace> You need to give Socket a parameter x, no?
05:16:25 <eevar> pentace: but will that do? I end up with "Predicate 'SocketType x' used as a type trying that.
05:16:54 <eevar> I have no idea if my syntax is off though, or if it just won't work
05:17:25 <pentace> To be honest, I don't quite understand the problem in your question :S
05:20:18 <pentace> eevar: As far as the syntax is concerned, your data type definition is correct, except for a type variable x not being in scope
05:20:40 <k00mi> eevar: SocketType is a typeclass?
05:22:00 <eevar> http://pastebin.com/xGCjx7M7
05:22:05 <mauke> The paste xGCjx7M7 has been copied to http://lpaste.net/92168
05:23:41 <eevar> k00mi: yup
05:23:54 * hackagebot algebraic-classes 0.3.2 - Conversions between algebraic classes and F-algebras.  http://hackage.haskell.org/package/algebraic-classes-0.3.2 (SjoerdVisscher)
05:25:44 <arcatan> hmm. when using http-conduit with transfer-encoding: chunked, when does it yield the chunks?
05:27:12 <hpaste> k00mi annotated “pastebin.com/xGCjx7M7” with “pastebin.com/xGCjx7M7 (annotation)” at http://lpaste.net/92168#a92169
05:27:26 <k00mi> eevar: ^
05:29:04 <kuribas> Is floating point math slower than integer math on modern CPU's?
05:29:19 <eevar> k00mi: thanks
05:30:51 <k00mi> eevar: you can't restrict the parameters to type/data constructors (without extensions), so usually you make a "smart constructor" that has the desired restrictions
05:31:03 <k00mi> like mkSocket
05:34:38 <eevar> k00mi: never would have figured that out on my own :)
05:37:38 <eevar> already spent ages looking for parametrized constructor and whatnot
05:41:05 <k00mi> you could do that with GADTs
05:42:08 <eevar> k00mi: hehe. pearls before swine ;)
05:42:26 <eevar> really not an inkling what I'm doing here
05:45:21 <k00mi> eevar: you also don't need the Sender/Reciever classes, just make send :: Socket Push -> String -> IO ()
05:45:59 <eevar> i have a gazillion different type class instances, tho
05:46:08 <k00mi> ah
05:46:28 <k00mi> I thought you only have Push and Pull ;)
05:47:06 <mekeor> any nicer way to do http://codepad.org/EOcjSsWm ? oh, uh, pattern guards, right?
05:48:52 <mekeor> oh, pattern guards are part of haskell2010? cool.
05:50:14 <mekeor> mekeor: also take a look at view patterns while you're at it ;)
06:05:45 <haasn> mm_freak_: what's ‘Quit’? Is that like Void?
06:06:30 <haasn> no, wait, that doesn't make sense
06:18:43 <pentace> mekeor: Are the former three "..." the same?
06:41:35 <quchen> I've got a custom list I'd like to apply a parser on, i.e. I don't want to parse a [Char] but a [MyType] instead. Is there a library to do that?
06:43:56 <jmcarthur> quchen: you can get parsec to do it, i think
06:44:18 <pentace> yes, Parsec can handle user tokens
06:44:49 <jmcarthur> quchen: i think you just want to use   Parsec [MyType] ()  instead of  Parsec String ()
06:45:20 <quchen> jmcarthur: Oh, I didn't know Parsec could do that.
06:45:35 <quchen> type Parser = Parsec String ()
06:45:43 <quchen> Haha. Well that was easier than I thought it would be :-)
06:45:53 <quchen> (That's from Text.Parsec.String)
07:13:06 <dreixel> does cabal just ignore fields that don't make sense? such as "exposed-moduls" (notice the typo)
07:13:15 <dreixel> this leads to some hard to spot bugs
07:13:50 <bergmark> dreixel: you'll get a warning
07:14:05 <geekosaur> it used to complain and exit. this led to problems when a new cabal came out and packages started using the new fields... and cabal aborted reading the package list
07:14:25 <geekosaur> so you not only couldn't install the new packages, you couldn't install anything else either
07:18:26 <haasn> What's the canonical way to get HTTP functionality in ‘pipes’? In particular, the result is going to be json, so I figure that will be easy to merge with pipes-aeson as well
07:19:56 <haasn> or should I just use http-conduit?
07:22:57 <dennis> hi
07:23:41 <Taneb> Hello, dennis
07:24:03 <dennis> is there a way to map over the values of a Data.Map map and have a map as result in O(n) ?#
07:24:37 <dennis> Currently im converting the map to a list to iterate over it and do a Map.fromList at the end to get the resulting map back
07:25:11 <dennis> and Map.fromList is O(n*log(n))
07:25:25 <Rarrikins> Map.map is O(n)
07:25:36 <Rarrikins> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/containers-0.3.0.0/Data-Map.html#v%3Amap
07:26:13 <Rarrikins> There's also mapWithKey, though you can't change the keys.
07:27:22 <donri> gah wasted time debugging why something was more strict than it should be. well the problem is i'm using :set -interactive-print in ghci and my print function is strict. :p
07:27:50 <dennis> oh thx seems liek a just overread that oO
07:28:54 <Rarrikins> If you want to change both keys and values, there's fromAskList, which is O(n) instead of O(log n), but it's unsafe unless you're sure the input is sorted.
07:29:05 <Rarrikins> fromAscList
07:29:09 <Rarrikins> No problem.
07:33:13 <jmcarthur> donri: yeah that's bitten me before, too
07:42:20 <haasn> I wonder if there's some ‘RSS’ library that provides a function which will periodically poll an RSS feed for me and run a user-supplied function on every new item it finds
07:42:52 <haasn> like poll :: Url -> (something -> IO a) -> IO ()
07:47:43 <jmcarthur> you could just use forkIO and a loop with a blocking rss library
07:50:08 <haasn> jmcarthur: oh, I didn't mean for this to be concurrent
07:50:24 <haasn> but yes, a blocking rss library is essentially the same thing
07:50:25 * hackagebot penny-lib 0.21.0.0 - Deprecated - use penny package instead  http://hackage.haskell.org/package/penny-lib-0.21.0.0 (OmariNorman)
07:50:27 * hackagebot penny-lib 0.22.0.0 - Deprecated - use penny package instead  http://hackage.haskell.org/package/penny-lib-0.22.0.0 (OmariNorman)
07:55:25 * hackagebot penny-bin 0.22.0.0 - Deprecated - use penny package instead  http://hackage.haskell.org/package/penny-bin-0.22.0.0 (OmariNorman)
08:05:30 * hackagebot penny 0.24.0.0 - Extensible double-entry accounting system  http://hackage.haskell.org/package/penny-0.24.0.0 (OmariNorman)
08:16:54 <sm> haasn: not a library, but you can find code like that in rss2irc
08:17:08 <haasn> sm: yeah, I saw that; I guess I'll cannibalize it - thanks anyway
08:17:34 <sm> if you rewrite it, let me know!
08:17:41 <haasn> I see you're the maintainer of this. Do you think it could be reasonable to factor this out into a library?
08:18:06 <sm> sure, maybe
08:18:31 <sm> could it fit into the feed lib ?
08:21:27 <haasn> perhaps. I'll have to understand your code first
08:22:08 <haasn> hmm
08:22:26 <haasn> does ‘feed’ actually contain the HTTP stuff, or does it just assume you pass it the feed as ByteString etc.?
08:23:45 <haasn> it turns out I don't need to use RSS after all, there's a JSON api that provides the same information
08:28:24 <sm> ah.. that's probably easier
08:28:43 <sm> json is simpler and better-supported than atom/rss feeds
08:30:46 * hackagebot multext-east-msd 0.1.0.0 - MULTEXT-East morphosyntactic descriptors  http://hackage.haskell.org/package/multext-east-msd-0.1.0.0 (JanSnajder)
08:35:46 * hackagebot multext-east-msd 0.1.0.1 - MULTEXT-East morphosyntactic descriptors  http://hackage.haskell.org/package/multext-east-msd-0.1.0.1 (JanSnajder)
08:40:46 * hackagebot multext-east-msd 0.1.0.2 - MULTEXT-East morphosyntactic descriptors  http://hackage.haskell.org/package/multext-east-msd-0.1.0.2 (JanSnajder)
08:40:48 * hackagebot aws-sign4 0.0.0.1 - Amazon Web Services (AWS) Signature v4 HTTP request signer  http://hackage.haskell.org/package/aws-sign4-0.0.0.1 (ChrisDornan)
08:52:32 <aegis__> hey folks! read learnyouahaskell I fell on that line: "data Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647" and I was wondering if I could define a type in the following way: "data Bit = 0 | 1"; I understand the code from lyah only serves to represent a concept and not actual haskell syntax but I was wondering if it was at all possible...
08:53:19 <geekosaur> nope
08:53:36 <geekosaur> you could use something like B0 | B1
08:53:36 <aegis__> geekosaur: any reason why?
08:54:04 <aegis__> geekosaur: yep, I tried Zero | One, no problem, but I wanted to use the actual constants
08:54:27 <geekosaur> if you have a 1 somewhere in your program, what type is it?
08:54:52 <aegis__> geekosaur: well it's a polymorphic constant, that casts to an Int, a Float etc depending on the context
08:55:11 <geekosaur> the mechanism for things being possibly multiple types is typeclasses (and numeric literals already use that, in fact; they're coerced to instances of Integral or Num as appropriate)
08:55:52 * hackagebot multext-east-msd 0.1.0.3 - MULTEXT-East morphosyntactic descriptors  http://hackage.haskell.org/package/multext-east-msd-0.1.0.3 (JanSnajder)
08:55:54 * hackagebot aws-elastic-transcoder 0.0.0.1 - Haskell suite for the Elastic Transcoder service  http://hackage.haskell.org/package/aws-elastic-transcoder-0.0.0.1 (ChrisDornan)
08:55:56 * hackagebot sparse 0.7 - A playground of sparse linear algebra primitives using Morton ordering  http://hackage.haskell.org/package/sparse-0.7 (EdwardKmett)
08:56:33 <Targen> You could always do this (if you hate yourself, of course): instance Num Bool where fromInteger 0 = False; fromInteger _ = True
08:56:46 <geekosaur> prhaps if you study how Haskell's type system and type inference works, you'll get an idea of why you can't just arbitrarily declare that 1 can be either a Num or a Bit
08:56:57 <aegis__> Targen: right, thanks!
08:57:07 <geekosaur> (note that doing what Targen just suggested is a road to extreme pain)
08:57:16 <Targen> Indeed.  Just say no.
08:57:24 <Targen> That line of thought ends in PHP.
08:57:35 <geekosaur> and you won't understand why unless you understand how types work in Haskell
08:58:27 <aegis__> yep it was more for a theoretical point of view, I would never do that O_o I think I get it; numbers are polymorphic constants in Haskell so it doens't make sense to use them as data constructor
09:00:32 <aegis__> Targen: Many lines of thought end in PHP
09:00:37 <Targen> Constructors for data declarations are new things being defined in that data declaration.  Numeric literals are already “defined”, so you can’t overload them as in `data X = 0 | 1`.  But they’re meant to be overloaded —hence the Num class—, so you can do magic with them by defining instances of Num.
09:01:07 <Targen> aegis__: Likewise with genocide ;)
09:03:22 <aegis__> Targen: does it make sense to say that the syntax data X = A | B | C is sugar for defining functions A, B and C that take one or more parameters and return a value of type X?
09:03:40 <Targen> The nicest instance of Num instance magic I’ve seen is in the unittyped package.  Numbers with postfix physical units that work almost like on paper.  Very fun.  Horrible errors when you do things wrong, though.
09:04:48 <Targen> aegis__: Yep, except “sugar” is typically used for when there is some other (usually more verbose) way to spell it out, and that’s not exactly so in this case.
09:05:06 <aegis__> Targen: yep, that's the only way to define it
09:05:25 <aegis__> Targen: thanks for your patience :-)
09:05:32 <Targen> :)
09:05:42 <k00mi> aegis__: those constructors aren't functions, they are just values
09:05:46 <k00mi> of type X
09:06:37 <aegis__> k00mi: yeah well in my example they are values but in the case of data Maybe a = Just a | Nothing, Just is a function; by the way, is there a difference in haskell ebtween a "value" and a function that takes no argument? I mean, conceptualy
09:06:37 <k00mi> if you have type X a = A a | B a then A und B are functions, yes
09:07:41 <k00mi> aegis__: yes, a function is a value of type  a -> b
09:07:56 * Maxdamantus wonders what (*) would do in such a system.
09:08:28 <aegis__> k00mi: so saying that "x = True" is a function that takes no argument is correct?
09:08:33 <k00mi> no
09:08:38 <Targen> aegis__: A function is just a value of a particular type.  `Left 'a'` has the type `Either Char Int` (and many others of course) and `\ 'x' -> 'y'` has the type `(->) Char Char`.
09:09:07 <aegis__> Targen: right, sorry, silly me
09:09:39 <k00mi> aegis__: x :: Bool, there is no (->) in that type so it is no function
09:10:29 <meretrix> Is there a simpler way to write the following?
09:10:32 <meretrix> :t bimap concat concat . unzip
09:10:32 <lambdabot> [([a], [a1])] -> ([a], [a1])
09:10:40 <Maxdamantus> ah, it has its own multiplication operator.
09:12:18 <Targen> aegis__: A topic you’ll soon encounter is GADTs, which let you define constructors thus: `data X where A :: Char -> X; B :: Int -> X` (as opposed to the usual `data X = A Char | B Int`)  It’s more explicit (and lets you do things regular data declaratons can’t do, and the semantics are more complicated and so on), but it’s more transparent in that indeed the constructors are just new terms that allow you to introduce values of the type being defined
09:12:18 <Targen> .
09:12:59 <Targen> Maxdamantus: It combines units in the expected way.  It’s very pleasant!
09:13:36 <Maxdamantus> Targen: yeah, but it can't instance Num, because (*) :: a -> a -> a
09:13:52 <Targen> Indeed.
09:13:54 <aegis__> Targen: thanks, I'll look that up!
09:17:14 <aegis__> Targen: holy shit, type functions; I'm gonna go grab a coffee -->
09:18:44 <Targen> aegis__: I didn’t understand it until I read the phrase «pattern matching causes type refinement» — good luck!
09:19:51 <aegis__> Targen: I think the main issue with haskell is that when you switch to another language (i.e. Go) you feel the type system is a black hole
09:22:17 <Targen> aegis__: Having an expressive type system in the compiler catches many errors, but a more important effect is having it in your head drives software structure and design.  You can carry that to other languages to great benefit.
09:25:08 <k00mi> aegis__: how far into LYAH are you? GADTs are fairly advanced, you don't need these to program in haskell (in fact, they are not even part of standard haskell)
09:25:58 * hackagebot lens-datetime 0.1.1 - Lenses for Data.Time.* types  http://hackage.haskell.org/package/lens-datetime-0.1.1 (MihalyBarasz)
09:26:10 <aegis__> k00mi: well i'm jumping back and forth between LYAH, Haskell, the craft of functional programming, the official doc and the standard library source code; atm I'm focussing on the type system
09:30:04 <k00mi> I wouldn't learn GADTs before being fluent in haskell, there are more important things to learn
09:31:53 <Targen> Indeed.
09:32:12 <Targen> I probably shouldn’t have mentioned them. :)
09:34:42 <aegis__> k00mi: Ok I'll keep that in mind; I intend to study the type system before I go any further in haskell though; I am quite fascinated by the theory behind it
09:37:36 <k00mi> well, if you're out of things to learn about the unextended type system, you can start with GADTs ;)
09:41:43 <Clint> how should i make a null Parser with optparse-applicative?
09:45:34 <dmwit> What is a null parser?
09:46:38 <Clint> dmwit: i want a (command) with no options or arguments
09:48:01 <dmwit> pure, then?
09:48:31 <aegis__> Another quick question: the type of (10, 8) is (Num a, Num b) => (a, b), it makes sense as numbers are polymorphic constants; however, in let x = (10, 8), :t x = (Integer, Integer). The value x couldn't itself be polymorphic? And why does haskell coerces the numbers to Integer and not Float? some kind of precedence rule here?
09:49:03 <geekosaur> MonoLocalBinds and defaulting
09:49:04 <aegis__> k00mi: it should keep me busy for a little while :p
09:49:21 <geekosaur> actually that's ghci so more likely just the monomorphism restriction
09:49:24 <geekosaur> @where dmr
09:49:24 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
09:50:04 <Clint> dmwit: er, yes, thanks
09:50:45 <Nisstyre> aegis__: number literals are polymorphic but in order to avoid excessive type signatures they default if there is no other information about their type available
09:50:58 * hackagebot TCache 0.10.0.11 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.10.0.11 (AlbertoCorona)
09:51:48 <aegis__> Nisstyre: so theoretically 'x' should be polymorphic, but to avoid the overhead they default to Integer?
09:52:05 <aegis__> Nisstyre: could be*
09:52:07 <sipa> not to avoid overhead; to make it usable
09:52:21 <dmwit> aegis__: Please do read geekosaur's wiki link.
09:52:22 <geekosaur> brief summary: x doesn't have a type signature or parameters so it's forced monomorphic. defaulting controls the type that's chosen for it, the candidates are tried in order until a compatible type is found and the default is (Integer, Double) so it uses Integer
09:52:42 <dmwit> Nisstyre: You, too, maybe, since what you said wasn't quite precise. There's nothing special about number literals here.
09:52:55 <aegis__> dmwit: ?
09:53:08 <geekosaur> [25 16:49] <geekosaur> @where dmr
09:53:09 <geekosaur> [25 16:49] <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
09:53:10 <Nisstyre> dmwit: yeah I realize that, I shouldn't have said literals
10:00:35 <apfelbox> hi
10:00:59 <apfelbox> I am trying myself on invoking ghc through the api
10:01:21 <apfelbox> I look at the haste compiler as an example
10:01:28 <apfelbox> Currently I am getting the following error:
10:01:54 <apfelbox> Couldn't match type `IO' with `Ghc' Expected type: Ghc () Actual type: IO ()
10:02:01 <apfelbox> How can I lift the value from IO to Ghc?
10:03:00 <mjhoy> I have a question about Control.Exception.handle, and Prelude.read. How do I handle the exception? http://pastie.org/pastes/8268644/text
10:03:18 <bennofs> apfelbox: use liftIO from the MonadUtils module
10:03:33 <bennofs> (import monadutils qualified, because liftIO might clash)
10:04:42 <dancingrobot84> Hello! Is there anybody using Scotty web framework? How do you do code reloading on changes?
10:05:22 <aegis__> dmwit: re, sorry, were you saying?
10:06:11 <dmwit> um
10:06:23 <dmwit> Would you like me to repeat the link a third time, or...?
10:06:33 <dmwit> Not trying to be grumpy, just not sure what you want from me.
10:07:28 <aegis__> dmwit: well you were telling me to not look at a link then I got disconnected, so I was wondering why I shouldn't look at it
10:07:52 <dmwit> I definitely didn't.
10:08:04 <dmwit> I was saying you *should* look at the link.
10:08:18 <aegis__> dmwit: oops sorry misread; I'll read that
10:08:41 <aegis__> dmwit: Monomorphism restriction, right?
10:08:46 <dmwit> right =)
10:09:25 <aegis__> dmwit: on what you said: "Nisstyre: You, too, maybe, since what you said wasn't quite precise. There's nothing special about number literals here."; => what's the actual explanation for the type of let x = (10, 8) then?
10:09:44 <dmwit> Like geekosaur said: monomorphism restriction + defaulting. =)
10:10:12 <geekosaur> [25 16:52] <geekosaur> brief summary: x doesn't have a type signature or parameters so it's forced monomorphic. defaulting controls the type that's chosen for it, the candidates are tried in order until a compatible type is found and the default is (Integer, Double) so it uses Integer
10:10:25 <geekosaur> but read the wiki page for the full story
10:10:33 <aegis__> dmwit: oh ok thanks, missed that it was directed to me as he didn't mention my nickname
10:10:36 <geekosaur> including *why* it does this, and how to turn it off if it bugsyou
10:11:21 <aegis__> geekosaur: ok, thanks! :)
10:13:30 <Targen> If you turn it off by default (say, in ~/.ghc/ghci.conf) things will make a lot more sense, but you’ll be constantly annoyed by ambiguous type errors.
10:14:41 <mjhoy> repeating myself, just in case: would love any help on why this doesn't catch the exception http://pastie.org/pastes/8268644/text
10:15:34 <geekosaur> mjhoy, laziness
10:15:56 <dmwit> mjhoy: no exception is thrown
10:16:43 <dmwit> mjhoy: You may like readIO.
10:16:51 <lpaste> \o/
10:17:02 <mjhoy> geekosaur, dmit: ah! thank you.
10:17:27 <dmwit> (And its partner, readLn.)
10:19:02 <monochrom> a bot should use \∩/ instead of \o/
10:19:23 <shachaf> lpaste should be hpaste
10:19:33 <monochrom> why?
10:19:35 <Hafydd> Why is \∩/ more bot-like?
10:19:49 <monochrom> becasue ∩ is bot head
10:20:08 <Hafydd> What is bot head?
10:20:29 <geekosaur> \♣/
10:20:38 <monochrom> that is a deep philosophical question
10:20:52 <Hafydd> Is it something from the theory of computation?
10:20:53 <geekosaur> Hafydd, ever seen Robbie the Robot from Forbidden Planet?
10:21:07 <Hafydd> No, I haven't.
10:21:15 <monochrom> what is human head? what is life?
10:21:28 <shachaf> What are birds? We just don't know.
10:21:39 <monochrom> hehe
10:22:07 <geekosaur> http://en.wikipedia.org/wiki/Robby_the_Robot dome head (and sensors which is why I suggested the club above :)
10:22:43 <Hafydd> Oh. Well, who say an android has to resemble a stereotypically inaccurate android?
10:22:59 <shachaf> If monochrom says it then I believe it.
10:24:11 <Hafydd> > head undefined -- bot head
10:24:12 <lambdabot>   *Exception: Prelude.undefined
10:24:24 <shachaf> Clearly, a bot should look like Big Robot Bil.
10:25:43 <apfelbox> bennofs: thank you! it finally compiles \o/
10:31:25 <shachaf> http://images.wikia.com/theneverhood/images/8/84/Bill2.jpg confirms monochrom's theory.
10:31:52 <Targen> What’s everyone’s favorite Haskell joke?
10:31:55 <Targen> Mine:
10:31:57 <Targen> > fix error
10:31:58 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
10:32:18 <mcstar> knock knock
10:32:42 <Targen> who’s there?
10:33:00 <ciaranm> you won't know who's there until you force evaluation by inviting them in
10:33:18 <mcstar> yep, you need seq or something
10:33:18 <monochrom> mine is http://article.gmane.org/gmane.comp.lang.haskell.cafe/91920/
10:35:19 <bennofs> I liked "Haskell will do what you want in "just a seq"" :D
10:35:51 <HugoDaniel> :D
10:38:09 <joelteon> i pronounce it "seek"
10:39:21 <dmwit> ?quote oldilock
10:39:21 <lambdabot> Sgeo says: What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
10:40:24 <jmcarthur> that would be better with impredicative types
10:40:35 <jmcarthur> Maybe (forall a b. b -> Either a b)
10:41:02 <monochrom> then, "seq, and you will be fine"
10:41:34 <dmwit> jmcarthur: What inhabitants does that rule out that forall a b. Maybe (b -> Either a b) allows?
10:43:28 <jmcarthur> dmwit: yours > mine > the one from the quote
10:43:49 <jmcarthur> dmwit: the quoted one leaves them free, so who knows what else it could be
10:44:05 <jmcarthur> and yours is simpler than mine
10:44:14 <Hafydd> Hahah, I just got the "fix error" one.
10:45:42 <Targen> It’s my favorite term. :)
10:46:10 <edwardk> matrix multiplication part 6: https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication/part-6   this one is remarkably self-contained.
11:01:20 <heatsink> What's the name for functions whose result is smaller than their argument, so that iterating the function will eventually terminate?
11:01:33 <heatsink> And functions that don't have this property
11:02:37 <mcstar> monotone decreasing, but you need boundedness for termination
11:03:17 <heatsink> thanks
11:03:28 <mcstar> well, thats not enough, really
11:03:55 <heatsink> I had term algebra in mind
11:04:15 <heatsink> With finite terms, there's no infinite sequence of decreasing-size terms
11:05:16 <heatsink> So I think that's enough
11:06:03 <heatsink> in this case.
11:11:05 * hackagebot DistanceUnits 0.1.0.0 - A comprehensive distance library  http://hackage.haskell.org/package/DistanceUnits-0.1.0.0 (MattGambogi)
11:16:05 * hackagebot sparse 0.7.0.1 - A playground of sparse linear algebra primitives using Morton ordering  http://hackage.haskell.org/package/sparse-0.7.0.1 (EdwardKmett)
11:20:16 <pxqr> i think it could be useful if haddock can add "minimal complete definition blah-blah" automagically
11:23:09 <applicative> heatsink: are you thinking of 'structurally recursive' functions, or definitions rather?
11:23:47 <pentace> pxqr: How would a minimal complete definition look like?
11:23:48 <jmcarthur> pxqr: difficult, since sometimes it's an either-or
11:25:29 <burp> persistent question: how do I specify more complicated PersistFields in mkPersist? something like this "mapField (Map Text (Double,Double))" throws an error Not in scope: type constructor or class `Double,Double', just "Map Text Double" works
11:26:00 <pxqr> jmcarthur: but GHC do some kind of check for default implementation; isn't it similar to that?
11:27:29 <pxqr> pentace: no, I mean we have enough information in code; clause "minimal complete definition" is derivable from the class definition (i guess)
11:27:35 <hpc> pxqr: an automatic check on default implementations would be a halting problem thing
11:27:57 <jmcarthur> pxqr: ghc's check is not very good
11:28:01 <mgsloan> burp: A type synonym should do the trick
11:28:12 <pxqr> jmcarthur: what do you mean?
11:28:18 <mgsloan> burp: Better yet, a newtype!
11:28:20 <edwardk> pxqr: often we have multiple overlapping definitions. e.g. comonad defines duplicate/fmap in terms of extend and vice versa
11:28:22 <jmcarthur> pxqr: if all my default implementations are cyclic with each other, ghc will not complain if i write an empty instance
11:28:28 <pentace> pxqr: Oh, you're talking about type classes
11:28:38 <applicative> mgsloan: is it a bug? I was going to suggest trying Pair = (Double,Double) ...
11:28:41 <burp> mshroyer: oh good idea!
11:29:04 <edwardk> pxqr: so putting the 'minimum correct definition' in that case in automatically will be actively misleading
11:29:05 <pxqr> ok, it might be not so simple :)
11:29:07 <jmcarthur> pxqr: for example, ghc will not complain if i only implement sizeOf and alignment for Storable, even though i also have to define at least one peek method and at least one poke method
11:29:28 <mgsloan> applicative: Persistent doesn't support all of Haskell syntax for types - I think it's just constructors and application really
11:29:40 <pxqr> jmcarthur: Eq suffer from that problem?
11:29:55 <applicative> ah, I see mgsloan
11:30:13 <mgsloan> Same for shakespearean templates
11:30:49 <applicative> burp: data Coord = Coord {-#UNPACK#-} !Double {-#UNPACK#-} !Double , just for amusement
11:30:55 <jmcarthur> pxqr: i don't know. it is conceivable that it could
11:31:05 <jmcarthur> pxqr: if (==) and (/=) both have defaults
11:31:27 <pxqr> jmcarthur: yes, I have no warnings
11:31:48 <pxqr> `data Foo = Foo; instance Eq Foo' for e.g.
11:32:07 <burp> applicative, mgsloan: I have just a type synonym now, what would a new data construct or newtype have as advantage?
11:32:19 <edwardk> ReinH: how goes?
11:32:44 <mgsloan> burp: The advantage of a newtype is that elsewhere in the code you can be sure that you are dealing with that particular type of map
11:33:17 <mgsloan> burp: Likely if you're storing something like that as a database field, you'll also be passing around values of that type.  So, you can gain type safety by making it a newtype
11:33:18 <burp> mgsloan: oh yea, that is certainly handy
11:35:34 <mgsloan> burp: With the GeneralizedNewtypeDeriving extension, you can use "deriving (PersistField, PersistFieldSql)" on your newtype
11:36:04 <mgsloan> (and you'll probably want to derive other instances as well)
11:37:00 <jmcarthur> Data.Vector.Storable.Mutable.unsafeToForeignPtr is so misleading!
11:37:18 <jmcarthur> it gives you the foreign ptr, the offset into it, and its length
11:37:22 <burp> I'll consider it for later. I already have some code for the type itself, and with a newtype I must add some unpacking/matching to it
11:37:26 <Targen> Is there some concrete set of guidelines for sane use of GeneralizedNewtypeDeriving spelled out somewhere?
11:37:33 <jmcarthur> but the offset is always zero, because the implementation actually just advances the pointer when you slice
11:37:52 <jmcarthur> so you can't use it to determine the offset relative to the fptr you constructed it with in the first place
11:39:43 <jmcarthur> yet this also means i can't rely on the implementation to stay the same, so to do what i want to have to store extra information alongside the mvector *and* add that offset, in case it ever changes to be nonzero :(
11:40:19 <jmcarthur> ah i guess i could just track *everything* and not worry about the offset
11:41:29 <lightquake> hm
11:42:00 <lightquake> what do you call a haskell term that consists of a single identifier like 'x' or 'map' as opposed to 'x + y' or 'f x'? I want to use 'variable' but they don't really vary
11:42:19 <elliott> lightquake: function parameters vary as much as they do in mathematics :)
11:42:25 <elliott> but for "map", perhaps "constant"
11:42:28 <lightquake> true!
11:44:43 <joelteon> I get "The build-tool has reset ENV. --env=std required." whenever I try to install anything with cabal
11:44:47 <joelteon> I just installed ghc 7.4 from homebrew
11:46:11 <lilred> hey guys, is there a pure functional way to check if two lists contain the same items without sorting them?
11:46:29 <lilred> assume that the lists don't have duplicates
11:46:37 <sipa> yes, by sorting them, and then comparing :D
11:47:12 <lilred> sipa: the data isn't sortable, sadly :|
11:47:14 <tromp__> test whether all elements in one are in the other, and vice versa
11:47:23 <tromp__> much slower though
11:47:39 <sipa> lilred: loop over all combinations, and count how many matches you find
11:47:41 <luite> lilred: same xs ys = all (`elem` ys) xs && all (`elem` xs) ys
11:47:55 <lilred> Thank you guys :D
11:47:58 <S11001001> lilred: even a partial ordering can improve your time, if you have one.
11:48:11 <lilred> it's dumb but I hadn't realized that the absence of duplicates would come in handy
11:48:12 <luite> lilred: note that that does assume no duplicates
11:48:16 <nooodl> couldn't you just compare their lengths instead of the "vice versa" part? (if you can assume they don't have duplicates)
11:48:25 <tromp__> yes, you could
11:48:35 <lilred> timing is okay, this is a very rare edge case and the lists shouldn't be more than 4-5 elements in length
11:48:51 <lilred> I'm implementing a hash array-mapped trie in F#, it's surprisingly complex
11:49:32 <jmcarthur> surprised you find yourself in a situation where you have to check for duplicates in two lists without any sort of ordering for this problem
11:49:45 <luite> nooodl: oh that's true, the results are slightly different depending on how the assumption is violated :)
11:50:04 <lilred> jmcarthur: I'm implementing a map data structure that doesn't require data to be orderable, only equatable
11:50:24 <jmcarthur> oh, i see, you're in the buckets
11:50:25 <lilred> jmcarthur: and in the case of collisions everything is sorted in a list
11:51:17 <lilred> I'm still torn on whether I should rely on the language-defined hash function or if I should use sip hash
11:51:30 <jmcarthur> i'm usually surprised when a hash table doesn't use some sort of tree in its leaves instead of a linked list
11:51:44 <jmcarthur> which means i'm just usually surprised :)
11:52:05 <lilred> jmcarthur: the problem is that the data is not comparable, and the buckets hold collisions
11:52:18 <deech> Hi all, I'm new to creating bindings to C++ libraries. I have the library functions extern'd so it's callable from C but I can't figure out how to create the Haskell binding.
11:52:28 <jmcarthur> it's truly not comparable, or you're just not requiring it to be comparable?
11:52:35 <lilred> jmcarthur: so you'd need a second hash function to get anywhere, and then you still have the edge case where something is a collision according to both hash functions
11:52:44 <lilred> not required
11:52:52 <jmcarthur> no, i don't think the second hash function would be a reasonable thing to do ;)
11:53:00 <lilred> jmcarthur: then what would you do?
11:53:13 <Targen> That’s when you need a third hash function.  Duh. ;)
11:53:18 <jmcarthur> i realize there are some cases where this is unavoidable (only have Eq available, no Ord)
11:53:32 <jmcarthur> but i generally try to stay away from such cases
11:53:50 <lilred> I'm doing this in F#, and there are a couple idiosyncracies in the main libraries that I have to work around of
11:53:57 <lilred> as an example, I think IP addresses are not comparable
11:53:58 <jmcarthur> ah
11:54:36 <jmcarthur> deech: is there a question?
11:55:12 <Toodai> Hello, maybe its too much to ask, but can you explain that http://rosettacode.org/wiki/Combinations#Haskell first one solution(with map)?
11:55:26 <deech> jmcarthur: Yes, how do I create a binding from C++ extern'd functions to Haskell?
11:55:31 <Toodai> I don't understand how combinations can be achieved that way.
11:56:05 <jmcarthur> deech: google "haskell FFI"
11:56:23 <jmcarthur> deech: your question is too complicated and general to answer here
11:56:43 <jmcarthur> oh C++
11:56:44 <deech> jmcarthur: yes, I did that. The resources I found tell you how to bind to C header files, not C++.
11:56:44 <jmcarthur> i misread
11:56:46 <jmcarthur> now i understand
11:57:24 <jmcarthur> http://www.haskell.org/haskellwiki/Cxx_foreign_function_interface
11:58:12 <Targen> What sort of data with an equality relation cannot be ordered even if the ordering has no useful meaning in terms of whatever the type is meant to model?
11:58:38 <jmcarthur> Targen: IORef is one example
11:58:47 <deech> Ok, I'll look at those. But I already have C callable extern'd functions so I've dealt with name-mangling issues. I was hoping there was a simple way.
11:59:06 <jmcarthur> deech: if you already have C functions then i don't see what's so unique about this
12:00:04 <jmcarthur> i admit i have never written a binding to a C++ library
12:00:54 <deech> jmcarthur: They're not C, the C++ headers look like `extern "C" { void blah () }`. So in my C file I can just import the header and do `blah()`.
12:01:15 <deech> jmcarthur: I'll dig around. Thanks for your help.
12:02:35 <jmcarthur> sorry i couldn't help more specifically
12:02:42 <Targen> jmcarthur: Would it be too terrible to define an ordering based on some implementation detail, if such an ordering is explicitly intended only to permit using more performant algorithms?
12:03:18 <deech> jmcarthur: Actually I think http://www.haskell.org/haskellwiki/IO_inside#Interfacing_with_C.2FC.2B.2B_and_foreign_libraries_.28under_development.29 is what I was looking for. Apparently GHC can take a C++ header file!
12:03:28 <fylwind> you could ... but what are you trying to do here? stuff them into a Map?
12:03:33 <Targen> At some point there must be a memory address or somesuch.
12:04:14 <Targen> I’m not saying this is a good idea :)  Just a thought.
12:04:15 <paolino> anyone using gtkglext with cairo ?
12:05:01 <Targen> fylwind: Indeed, that sort of thing.  The Ord constraint is really just a matter of performance, no?
12:06:06 * hackagebot SimpleGL 0.9.1 - A Simple Graphics Library from the SimpleH framework.  http://hackage.haskell.org/package/SimpleGL-0.9.1 (MarcCoiffier)
12:06:15 <jmcarthur> Targen: what implementation detail would you use for IORefs?
12:06:31 <fylwind> you have to make sure it's well-ordered ... other than that just document that the ordering is "implementation-defined and subject to change"
12:06:38 <jmcarthur> Targen: remember, even their pointers can change due to the copy-collecting GC
12:06:38 <fylwind> otoh, you could just use a hash table
12:07:16 <mcstar> Toodai: well, it just says that to get the m-element combination of n different things, is to get the m-elment combinations of the rest of the elements, and the combinations, prepended with the first element, of the m-1-element combinations of the rest
12:07:47 <jmcarthur> Targen: if the proposal is to annotate it with something else or use some other collection then i counter by saying i could just do the same thing in haskell
12:07:48 <mcstar> thats (one) way to decompose the problem
12:08:28 <jmcarthur> Targen: and further that the right default is to keep it smaller and simpler, and if you really need Ord then you can add Ord using whatever keys you want elsewhere
12:08:33 <mcstar> the inclusion of a 'pivot' element separates the problem into two dijunct subproblems
12:08:52 <Targen> jmcarthur: Indeed, that’s a great point.  I suppose it’s a non-issue.
12:08:58 <mcstar> well, i wanted to say, the selection of a pivot element..
12:10:19 <edwardk> Targen: the problem is IORefs move
12:10:43 <joelteon> do you guys actually test the lower/upper bounds of your dependencies or do you just restrict it to the current major+minor version?
12:10:49 <edwardk> Targen: so there is no stable address or anything you can refer to. they get picked up and put down in new locations by the RTS all the time
12:10:58 <Targen> edwardk: Yeah, I was thinking they could be annotated with some “serial number”, but as jmcarthur says, might as well do that over-the-board.
12:11:11 <edwardk> Targen: that creates a new serialization bottleneck
12:11:18 <edwardk> and takes more space
12:11:28 <Targen> And breaks long-lived programs.
12:11:32 <edwardk> yep
12:11:34 <Targen> Terrible idea, I know :)
12:12:27 <jmcarthur> joelteon: some people are better about it than others
12:12:46 <jmcarthur> joelteon: i'm pretty bad about it, so i normally just start with a tight bound and then loosen it as i upgrade to future versions of things
12:13:10 <bergmark> joelteon: if i find out i need to add an upper bound i add only the latest unless i know better
12:13:40 <bergmark> it gets pretty hard to keep track of these things after a while
12:14:01 <jmcarthur> edwardk: i'm curious what your process it like to maintain so many packages
12:14:05 <jmcarthur> *is like
12:14:21 <edwardk> joelteon: my usual rule of thumb is that i set dependencies on my own packages by the first digit of the major version number, and on everyone else's by the last so I can comply with the PVP. Then if someone asks or I have enough experience with the package I'll usually lower the bound to cover a few more haskell platforms
12:14:22 <joelteon> yeah, well, I dunno
12:14:29 <joelteon> that makes sense
12:15:09 <Toodai> mcstar: Well, sole non recursive pare just returns head of list. How that causes permutations?
12:15:12 <edwardk> jmcarthur: before i split my major version into breaksme.mightbreakothers it was quite painful
12:15:43 <edwardk> but that change cut out about 95% of the spam i had to send hackage
12:15:53 <mcstar> part?
12:16:09 <Toodai> mcstar: Yes, part.
12:16:13 <mcstar> it need not cause permutation, it computes combinations
12:16:51 <Toodai> mcstar: Sorry, wrond term.
12:17:43 <mcstar> i dont see how 'it just returns head'
12:18:07 <Toodai> comb m (x:xs)
12:18:11 <Toodai> x <-- head
12:18:17 <mcstar> yes
12:18:45 <Toodai> It applies joins head with each head of heads?
12:18:59 <Toodai> It joins*
12:19:25 <mcstar> that part of the equation is the left hand side, which says 'i define this thing with what i write on the right side'
12:20:02 <Toodai> Quite complex algorythm to grasp.
12:20:17 <mcstar> Toodai: do you know that the (:) deconstructs the list, which is the second argument of comb?
12:21:16 <Toodai> I wish haskell has trace like in lisp, to actuall ysee wants going on. mcstar, yes i'm familiar with haskell just can't grok this algo.
12:21:29 <joelteon> haskell has trace
12:21:30 <mcstar> import Debug.Trace
12:21:35 <mcstar> you will have trace
12:21:42 <Toodai> It jsut blows stack in my non TCO silly head.
12:21:43 <geekosaur> Toodai, ghc-vis or ghood?
12:21:44 <joelteon> and traceShow
12:21:59 <geekosaur> (or just hood)
12:22:01 <mcstar> but it is a simple algorith, you dont need it
12:22:25 <mcstar> i still dont see how 'it just returns head'
12:22:41 <mcstar> probably im wrong about what i think you dont understand
12:26:07 * hackagebot hoogle 4.2.20 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.20 (NeilMitchell)
12:26:58 <Toodai> Oh my god, i think i get it.
12:29:48 <fylwind> it's like reading a math equation isn't it :)
12:31:33 <mcstar> map (x:) makes it look more like an algorithm...
12:32:09 <mcstar> and the corner cases...
12:32:29 <fylwind> you can write map (x:) (comb (m-1) xs) as a kind of product
12:32:45 <mcstar> hm, edge case...
12:33:14 <fylwind> well that's what the curly brace is for when you define a function recursively :)
12:34:15 <mcstar> fylwind: what do you mean?
12:35:38 <mcstar> do you mean a piecewise definition in maths?
12:35:49 <fylwind> yea
12:36:07 * hackagebot SimpleH 1.0 - A light, clean and powerful Haskell utility library  http://hackage.haskell.org/package/SimpleH-1.0 (MarcCoiffier)
12:37:39 <notdan> cabal-install 1.17 doesn't seem to complain if you forget to include a module in the other-modules list
12:37:53 <notdan> instead it complains when you want to build something against that very library
12:38:47 <bergmark> yep, pretty annoying
12:44:02 <fylwind> mcstar: http://mathb.in/8915
12:44:35 <fylwind> it certainly doesn't make it any easier to comprehend :(
12:51:42 <fylwind> @pf FTree x' (ZTree (c' ((l', p, Node x c <| r) : a)))
12:51:42 <lambdabot> Maybe you meant: pl bf
12:51:51 <fylwind> @pl FTree x' (ZTree (c' ((l', p, Node x c <| r) : a)))
12:51:51 <lambdabot> FTree x' (ZTree (c' ((l', p, Node x c <| r) : a)))
12:51:54 <mcstar> x \in S, S' = S \ {x} thats how i would have said it
12:53:14 <fylwind> that works
12:53:48 <mcstar> honestly, i would not have thought of defining S in terms of S' since S is on the LHS
12:54:02 <mcstar> it is similar to the k+n pattern that was dropped
12:54:48 <fylwind> but math is OK with implicit equations :)
12:55:09 <mcstar> probably, it is just unusual for me to see
12:55:56 <mcstar> but i think that 2d formatted math formula helps. in this case anyway
12:57:01 <mcstar> lets ask Toodai_ , do you find the maths formula helpful?
12:57:23 <monochrom> think of "where S = {x} ∪ S'" as a view pattern
12:57:46 <fylwind> Epigram is 2D though; it's not very keyboard friendly :(
12:58:32 <fylwind> well I read it as: pick a arbitrary element x from S, and call the remaining set S'
12:58:38 <fylwind> s/a arb/an arb/
12:59:15 <mcstar> 'pick the arbitrary element, x' :D
12:59:58 <valyagolev> you can probably use "exists x : s \in S" as a clause, would probably look more like a matched pattern
13:00:22 <valyagolev> x \in S
13:02:00 <valyagolev> otoh I can't get coq's dialect of math from my head for some reason
13:04:23 <aegis__> Quick question: is "deriving" magic?
13:04:27 <haasn> no
13:04:35 <haasn> but GeneralizedNewtypeDeriving is evil sorcery
13:04:49 <notdan> Nah, it's not that evil
13:04:50 <notdan> imho
13:05:05 <haasn> it lets you write unsafeCoerce :(
13:05:07 <mcstar> why is it not magic?
13:05:09 <fylwind> so how does order affect pattern matching of functions?
13:05:34 <haasn> fylwind: patterns are tried in the order they're defined
13:05:53 <mcstar> i dont think you can pattern match on functions, they are opaque
13:06:02 <haasn> fylwind: so eg. case foo of x -> "yes"; y -> "no" -- will always return "yes"
13:06:03 <fylwind> function arguments i mean
13:06:12 <haasn> or what did you mean?
13:06:23 <fylwind> i was re: mcstar
13:06:46 <fylwind> but yeah, i always felt it was somewhat odd that pattern matching is order-dependent
13:07:00 <aegis__> haasn: so deriving should only be used on the standard lib typeclasses Eq, Ord, Enum etc, but no others
13:07:07 <joelteon> fylwind: how would you match "everything else"?
13:07:13 <mcstar> in the case case it is not odd imhow
13:07:15 <mcstar> imho
13:07:38 <monochrom> pattern matching is order-dependent
13:07:57 <fylwind> based of specificity perhaps?
13:08:02 <monochrom> no
13:09:02 <haasn> fylwind: consider “isZero :: Int -> Bool”
13:09:24 <monochrom> > case [1] of _ -> "no specific"; x:xs -> "specific"
13:09:26 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
13:09:38 <haasn> fylwind: suppose patterns had to be defined in a way that order doesn't matter; which would require enumerating every possible constructor
13:09:47 <haasn> fylwind: this function would be pretty tough to define :)
13:10:01 <monochrom> > case [1] of { _ -> "not specific"; x:xs -> "specific" }
13:10:03 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
13:10:15 <haasn> monochrom: ???
13:10:29 <fylwind> it's just that i'm used to having lines in haskell being nearly order-independent, that's all
13:10:29 <mcstar> @undef
13:10:30 <lambdabot> Undefined.
13:10:44 <fylwind> > 0
13:10:45 <lambdabot>   0
13:10:46 <mcstar>  > case [1] of { _ -> "not specific"; x:xs -> "specific" }
13:10:47 <haasn> fylwind: yeah; it makes perfect sense though - pattern matches are not definitions after all
13:10:54 <haasn> fylwind: lines in a ‘do’ block are pretty order-dependent too :)
13:11:03 <mcstar> > case [1] of { _ -> "not specific"; x:xs -> "specific" }
13:11:04 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
13:11:06 <fylwind> yea but that's clearly demarcated
13:11:07 * hackagebot xkbcommon 0.0.0 - Haskell bindings for libxkbcommon  http://hackage.haskell.org/package/xkbcommon-0.0.0 (AukeBooij)
13:11:27 <monochrom> last attempt
13:11:31 <monochrom> > case [()] of { _ -> "not specific"; x:xs -> "specific" }
13:11:32 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
13:11:35 <haasn> > case [1] of { [] -> "specific"; x:xs -> "specific" }
13:11:36 <lambdabot>   "specific"
13:11:41 <mcstar> > fix lambdabot
13:11:42 <lambdabot>   Not in scope: `lambdabot'
13:11:48 <haasn> monochrom: note your code produces a warning in GHCi for me, maybe that's tripping up lambdabot
13:12:00 <haasn> I don't suppose it has error-on-warnings on?
13:12:03 <aegis__> > case [1] of { x:xs -> "specific"; _ -> "not specific" }
13:12:04 <lambdabot>   "specific"
13:12:43 <mcstar> haasn: you kind of missed the 'not'
13:13:00 <aristid> monochrom: iirc ghc tries case alternatives in order, so your case would _always_ return "not specific", which would trigger a warning? (untested)
13:13:01 <aegis__> monochrom: I think it was throwing an error because you were using a not-specific pattern before a specific
13:13:09 <aegis__> "[GhcError {errMsg = \"<interactive>:3:1:\\n    Pattern match(es) are overlapped\\n    In a case alternative: (x : xs) -> ...\"}]""
13:13:10 <haasn> mcstar: but [] is a specific pattern match :)
13:13:36 <mcstar> true...
13:13:50 <monochrom> all of you make my point, thank you
13:14:39 <haasn> aegis__/elliott: I feel lambdabot should still run code in the case of warnings, but output them afterwards (perhaps via an extra command to display the full warning :)
13:14:44 <monochrom> and this is why I refuse -Wall -Werror
13:14:52 <haasn> yes -Werror is what I meant
13:15:02 <aegis__> haasn: true, if I run it locally in ghci I get the warning as well as the result
13:15:25 <mcstar> yes, everyone has a ghci instance running locally
13:15:47 <elliott> it doesn't use -Werror.
13:15:52 <elliott> it's just buggy.
13:15:58 <elliott> it shouldn't even be giving the warnings
13:16:06 <haasn> ok
13:16:11 <aegis__> mcstar: I meant that lambdabot could output the same as ghci...
13:16:52 <haasn> mcstar: speaking of which, I've always wanted to have one or multiple GHCi instances running as a daemon
13:17:15 <aristid> elliott: is it just my impression, or has lambdabot gotten more buggy lately?
13:18:17 <fylwind> @botsnack
13:18:17 <lambdabot> :)
13:18:35 <haasn> ideally I'd want to have a console command that would eg. hook into my GHCid-thing, run a command, output its result and exit
13:18:51 <elliott> aristid: just one or two bugs that people keep tripping up. not unexpected when the codebase fast-forwards about two years in one day
13:19:12 <haasn> so I could run, say, “:t someExpression” directly from my terminal :)
13:19:18 <elliott> the most important one is probably @pl being broken, but I honestly have no idea what could have caused it and know nothing about the @pl code, so I haven't looked into it yet.
13:19:27 <fylwind> what do you mean fast-forward?
13:19:39 <elliott> fylwind: the lambdabot codebase was about two years behind
13:19:43 <aristid> elliott: when was that fast-forward?
13:19:53 <valyagolev> haasm, that should be easy, I think
13:20:02 <elliott> uh, whenever I took over. two months or so?
13:20:08 <elliott> bugs got fixed at the same time too, though :)
13:20:28 <danilo2> Hi! What Command line option parser would you recommend if I'm writing a compiler and I want to use an option parser, which would be flexible and powerfull? I've found out a list of haskell's options parsers (http://www.haskell.org/haskellwiki/Command_line_option_parsers) but I would love to hear your recomendation :)
13:23:53 <Targen> CmdArgs is nice (ish), but I’ve never used it for something that complex.
13:24:08 <donri> danilo2: optparse-applicative
13:26:13 <danilo2> donri: I'm looking ito it right now :) thank you - it is not even listed on this "official list" :) I forget to add - I would love to see automatic help generation etc - if is it possible with any of these libraries.
13:27:08 <danilo2> donri: Ouch it is listed, sorry for that :)
13:27:12 <haasn> valyagolev: I'm mainly stuck on how to inferface with it properly, ie. to detect when a command's output is completed, and how to deal with stuff like passing through ^C to terminate diverging expressions
13:27:20 <aegis__> is there anything like jsfiddle / mathb.in for haskell?
13:27:27 <aegis__> or play.golang
13:28:02 <haasn> aegis__: there's tryhaskell.org but it's really limited
13:28:12 <haasn> I think there are some pastebins that do some degree of program execution, too
13:28:24 <nooodl> codepad.org, ideone
13:28:25 <haasn> ooh, maybe we could have something that's based on ghcjs and ends up running your haskell expressions directly in your browser
13:28:45 <aegis__> haasn: yep limited :(
13:28:45 <nooodl> both of those handle a whole bunch of languages; ideone a ridiculous amount of them
13:28:48 <nooodl> (even brainfuck!)
13:30:43 <aegis__> haasn: that would be pretty cool :-)
13:30:46 <aegis__> nooodl: thanks!
13:31:51 <aegis__> nooodl: but I feel they are both a bit messy; a clean playground like play.golang.org with a share feature would be great
13:32:42 <nooodl> yeah, ideone is especially messy
13:34:50 <valyagolev> haasn, hm, yeah, as a second thought I think it's easy for the easy cases
13:38:42 <lpaste> barrucadu pasted “Monomorphism restriction?” at http://lpaste.net/92173
13:38:44 <barrucadu> I seem to have run afoul of the monomorphism restriction whilst trying something (specifically, I wanted to see if GHC *could* derive the type for my fixEq), but I'm having difficulty understanding exactly what it is. Could someone possibly explain it with reference to my fixEq?
13:40:46 <heatsink> First, note that the polymoprhic type of fixEq is (Eq a) => (a -> a) -> a -> a
13:41:05 <mgsloan> aegis_: Have you tried out the school of haskell?
13:41:08 <monochrom> yes it is the monomorphism restriction. fixEq :: Eq a => (a->a) -> a -> a. the monomorphism restriction doesn't like the Eq
13:41:08 <heatsink> To make this monomorphic, the compiler has to choose a type for 'a'
13:41:20 <mgsloan> aegis__: Posts don't need to be tutorials, sharing snippets is fine, e.g: https://www.fpcomplete.com/user/mgsloan/ghci
13:42:00 <zq> is there a identifying the module that defines a given function?
13:42:01 <heatsink> But (except for special cases that don't apply here) it refuses to arbitrarily choose types when that would determine how type class constraints are satisfied
13:42:19 <zq> (aside from hoogle)
13:42:45 <monochrom> ghci's :info may help
13:44:25 <barrucadu> heatsink: So, in a sense, the Eq makes it "too polymorphic" for the compiler to choose a sutiable type?
13:44:37 <barrucadu> There are lots of Eq things, so it can't choose one
13:47:01 <heatsink> It's not the polymorphism, it's the overloading.
13:47:26 <heatsink> The Eq allows the compiler's choice to influence the function's behavior
13:47:40 <barrucadu> Right
13:47:43 <heatsink> That doesn't happen for polymorphic functions without type class constraints.
13:49:31 <ReinH> So I finally understand why a lens is a costate comonad coalgebra. Yay!
13:49:38 <ReinH> Helps when you read the actual paper.
13:50:14 <ReinH> I didn't realize that coalgebra just means a -> w a, for instance.
13:55:00 <aegis__> mshroyer: oh cool thanks, I'll check that
13:55:17 <aegis__> mgsloan: oh cool thanks, I'll check that
13:55:24 <aegis__> mshroyer: wrong nickname :<
13:56:38 <deech> Hi all, Gtk2Hs currently uses Graphics.UI.Gtk as it's module structure. Is that the accepted way of publishing a GUI binding?
13:58:54 <roconnor> ReinH: which actual paper?
14:00:11 <deech> WxHaskell also uses Graphics.UI. Answered my own question. Thanks!
14:00:19 <ReinH> roconnor: yours, actually! http://arxiv.org/abs/1103.2841
14:00:35 * roconnor was wondering if there was another paper I wasn't aware of. :)
14:00:45 <roconnor> ReinH: yay
14:00:50 <ReinH> roconnor: your ideas intrigue me. I would like to subscribe to your newsletter :)
14:01:01 <aristid> roconnor: can't be yours if he says "actual" ;)
14:02:14 <roconnor> ReinH: https://r6.ca/blog/feed.atom
14:02:18 <roconnor> for subscription
14:02:19 <ReinH> roconnor: :D
14:02:32 <ReinH> aristid: :p
14:02:45 <ReinH> aristid: it's on arxiv for whatever that's worth :p
14:03:19 <roconnor> aristid: the issue is that I'm still working on writing the "actual" paper.
14:03:39 <NemesisD> i'm looking to use the version string of my library in the code and only have to update it in one place. anyone know how I could do that?
14:03:40 <ReinH> roconnor: 404 on that link
14:03:46 <roconnor> ReinH: hmm
14:03:55 <ReinH> roconnor: what's the link to your blog proper?
14:04:06 <NemesisD> i.e. if my package is 1.0, i want a client in my package to report a user agent of mypackage 1.0
14:04:21 <Makoryu> Is it bad form to pass an infinite stream of getLine callbacks into a function that produces (interleaved) textual output
14:04:23 <roconnor> oops
14:04:36 <roconnor> ReinH: http://r6.ca/blog/feed.atom
14:04:41 <roconnor> ReinH: http://r6.ca/blog/ is the blog proper.
14:04:46 <ReinH> oh heh
14:04:50 <ReinH> silly https
14:04:59 <ReinH> great thanks
14:05:48 <roconnor> Makoryu: sounds fairly reasonable to me.
14:06:48 <bobthenameless>  K[]/j #erlang
14:07:24 <ReinH> roconnor: http://r6.ca/blog/20120708T122219Z.html <3
14:08:10 <ReinH> Beware of bugs in the above code. I have only ~~proved it correct~~ compiled it, not tried it.
14:08:23 <edwardk> aristid: ouch. well, it could be one of my many many unfinished papers =
14:08:51 <ReinH> edwardk: hai
14:08:56 <edwardk> heya ReinH a
14:09:10 <ReinH> edwardk: so I'm reading roconnor's paper on multiplates
14:09:14 <ReinH> edwardk: and Store makes so much more sense now.
14:09:29 <aristid> edwardk: was it really so mean? was just meant to be a stupid joke
14:09:30 <edwardk> i may finally get around to putting an actual multiplication algorithm in the series on matrix multiplication soon =)
14:09:33 <edwardk> ReinH: good =)
14:09:44 <edwardk> aristid: i meant to put a smiley on that
14:09:52 <ReinH> edwardk: are cartesian stores actually implemented anywhere? Seems like an obvious choice for GoL?
14:10:20 <sinclair|net> hi edwardk
14:10:30 <sinclair|net> edwardk: you're a clever cat, got a second to help me rationalize something
14:10:44 <sinclair|net> ?
14:11:19 <edwardk> ReinH: yes they are. that was the 'FunList' form of Bazaar i mentioned =)
14:11:35 <edwardk> sinclair|net: shoot and i'll follow along as i can
14:11:58 <edwardk> ReinH: Bazaar is just the extension that allows it to work for the infinite case whenever it can
14:12:12 <sinclair|net> edwardk: well, this is just something i have found myself doing lately
14:12:22 <edwardk> which mostly causes roconnor to roll his eyes and look down his nose at me
14:12:33 <edwardk> which is quite comical to watch him try to do at the same time
14:12:35 <sinclair|net> edwardk: its a javascript related thing, but would be applicable in any dynamic language
14:12:46 <sinclair|net> edwardk: consider the following..
14:13:07 <sinclair|net> hash['a'] = { a: 10 }
14:13:14 <ReinH> edwardk: oh right FunList.
14:13:14 <sinclair|net> hash['b'] = { b: 10 }
14:13:30 <sinclair|net> er
14:13:34 <sinclair|net> hash['a'] = { a: 10 }
14:13:41 <sinclair|net> hash['a'] = { b: 10 }
14:13:57 <sinclair|net> hash.get('a') = {a:10, b:10}
14:14:07 <ReinH> wat
14:14:21 <Makoryu> （　°д°）
14:14:28 <sinclair|net> yeah, its weird
14:14:34 <sinclair|net> but it gets weirder
14:14:42 <ReinH> how do you even get javascript to do that?
14:14:46 <ReinH> you can't overload []=?
14:14:53 <Makoryu> I'm reminded of Perl's autovivification
14:15:03 <ReinH> I mean, I could make Ruby do that if I really wanted to
14:15:03 <Makoryu> Well
14:15:17 <sinclair|net> ReinH: its just a object, hash is just a 'thing' in the most general sense of the word
14:15:25 <sinclair|net> anyway...
14:15:39 <sinclair|net> hash['a.a'] = { c: 10 }
14:16:03 <sinclair|net> hash.get('a.a') now is {a:10, b:10, c:10}
14:16:25 <sinclair|net> which is kind of, lexically scoping the value, kinda
14:16:31 <mauke> what
14:16:47 <sinclair|net> mauke: its just a thing
14:16:53 <sinclair|net> maybe ill pastebin it
14:16:55 <mauke> o ok
14:17:57 <ReinH> I don't understand what is happening
14:18:29 <ReinH> that's a weird way to present lexical scoping?
14:18:35 <mauke> "its just a thing"
14:18:36 <edwardk> ReinH: the Cartesian Store is the Bazaar I had there. Buy = Unit, Trade = Battery
14:18:44 <ReinH> edwardk: oh cool :)
14:19:03 <ReinH> edwardk: your mixed store metaphods confuse my simple mind
14:19:06 <edwardk> and so we can use the same reasoning that gives us Context as a Store comonad
14:19:06 <ReinH> *metaphors
14:19:39 <sinclair|net> ReinH: well, im would like some help reasoning about this
14:19:45 <edwardk> s -> Store a s    is a lens,   s -> CartesianStore a s  is a traversal
14:19:57 <sinclair|net> or at least, some analogy to something else done in other languages
14:20:16 <edwardk> using the higher rank versions of things, and just flipping the definitions used in lens    s -> Context a s is a lens and s -> Bazaar a s   is a traversal
14:21:06 <sinclair|net> mauke: ReinH edwardk http://pastebin.com/3cGq7swV
14:21:08 <edwardk> because forall f. Functor f => (a -> f b) -> s -> f t      is the just flip of  as s -> (forall f. Functor f => (a -> f b) -> f t) -- and the right hand side of that is Context a b t  -- when we index context
14:21:10 <mauke> The paste 3cGq7swV has been copied to http://lpaste.net/92176
14:21:10 <johnw> where did you get the name Bazaar from?
14:21:11 <edwardk> similarly
14:21:15 <ReinH> edwardk: right, because traversal needs applicative?
14:21:33 <edwardk> because forall f. Applicative f => (a -> f b) -> s -> f t      is the just flip of  as s -> (forall f. Applicative f => (a -> f b) -> f t) -- and the right hand side of that is Bazaar a b t  -- when we index context
14:21:43 <edwardk> johnw: it was a bizarre type
14:21:49 <edwardk> and a bazaar is a bunch of stores
14:22:03 <ReinH> sinclair|net: ok
14:22:03 <edwardk> and i hated the names Cartesian Store and Kleene Store with a passion
14:22:04 <johnw> haha
14:22:12 <ReinH> johnw: GET IT?
14:22:18 <sinclair|net> ReinH: have you seen something like this before?
14:22:25 <johnw> a real bazaar is more like a flea market, but I can see one thinking of them as "stores"
14:22:27 <edwardk> mostly because they took a simple enough idea and made it dressed up enough in academia to be terrifying
14:22:42 <ReinH> sinclair|net: I mean, it does remind me of lexical scoping
14:22:43 <edwardk> we have a 'Market'  and an 'Exchange' profunctor in lens as well ;)
14:22:50 <edwardk> :t Control.Lens.Internal.Market.Market
14:22:51 <lambdabot> Couldn't find qualified module.
14:22:57 <edwardk> :t Control.Lens.Internal.Prism.Market
14:22:58 <lambdabot> (b -> t) -> (s -> Either t a) -> Control.Lens.Internal.Prism.Market a b s t
14:22:59 <sinclair|net> ReinH: its a fake lexical scoping
14:23:04 <edwardk> :t Control.Lens.Internal.Iso.Exchange
14:23:04 <lambdabot> (s -> a) -> (b -> t) -> Control.Lens.Internal.Iso.Exchange a b s t
14:23:22 <sinclair|net> ReinH: i don't really know what to make of it tho
14:23:38 <edwardk> those are used in clonePrism and cloneIso
14:23:41 <edwardk> :t clonePrism
14:23:48 <edwardk> :t Control.Lens.clonePrism
14:23:49 <lambdabot> (Applicative f, Choice p) => APrism s t a b -> p a (f b) -> p s (f t)
14:24:04 <ReinH> sinclair|net: yeah, my response would be "why are we doing this in the first place?" ;)
14:24:15 <mauke> why doesn't .get take a list of keys?
14:24:49 <edwardk> sinclair|net: i've washed my hands of javascript's quirks. write one javascript interpreter and everyone expects you to to remember them all ;)
14:25:48 <mauke> my $x = {}; for my $key (split /\./, $dotted_key) { merge_into($x, $value_at{$key}); } return $x;
14:26:09 * hackagebot hopenpgp-tools 0.0 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.0 (ClintAdams)
14:27:14 <sinclair|net> edwardk: well, this could apply as much to say, python as it would javascript
14:28:08 <mcstar> what is revolutionary in that paste?
14:28:41 <mcstar> i only see an inconsistent use of "" and ''
14:29:05 <pxqr``> what's the ifdef MACRO for Generics?
14:29:23 <fylwind> is there a tool that can automatically remove unnecessary imports?
14:29:29 <johnw> yes
14:29:40 <johnw> ghc -ddump-minimal-imports Foo.hs
14:29:47 <johnw> this writes out a file with the minimum required imports
14:30:14 <edwardk> fylwind: i just tend to use -Wall when compiling, then the warnings make me do it, but johnw's suggestion works pretty well if you avoid CPP IIRC
14:30:28 <fylwind> that's awesome; now I can be less OCD about these imports :P
14:30:33 <fylwind> thanks
14:31:15 <pxqr``> ok, it's (__GLASGOW_HASKELL__ >= 702)
14:33:14 <erisco> how would garbage collection behave wrt yss in http://lpaste.net/92177 ? we chop off the last element with init, but of course Haskell is lazy, and so unless evalution of yss is forced, does it never free?
14:33:51 <erisco> (the function is for illustrative purposes only)
14:34:16 <luite> erisco: it would retain the original yss until the init yss is fully evaluated
14:34:31 <luite> (or the whole thing goes out of scope of course)
14:35:05 <luite> erisco: but that's only if you hold on to the first element of that thing
14:35:18 <erisco> so if you had the option of lopping off the last element (ie, it doesn't make a difference for the correctness of the algorithm if you do or not)
14:35:44 <luite> erisco: you can do drop 50 (init yss), if you force it to eval the drop 50, it doesn't contain references to the start of yss anymore
14:35:45 <erisco> then it would be better to not call init? after all, we're creating another thunk, yes?
14:36:28 <erisco> luite, that just frees the front though, right?
14:36:32 <luite> yeah
14:36:32 <erisco> I'm talking about the back
14:36:48 <luite> yeah it can only free that if you evaluate the whole spine
14:37:00 <erisco> okay, so it would be worse of me to use init in my case
14:37:04 * arkeet . o O ( don't do init, and just lop everything off at the very end, using say zipWith const )
14:37:51 <erisco> well like I said, nothing actually needs to be removed ... it is just redundant hanging around :)
14:38:02 <aristid> arkeet: why is zipWith const better than init?
14:38:11 <arkeet> aristid: you only have to do it once.
14:38:18 <jmcarthur> and it's lazy
14:38:26 <jmcarthur> err
14:38:35 <jmcarthur> init is too, i guess, but it sucks doing it multiple times
14:39:00 <luite> yeah this recursive use of init is pretty bad :)
14:39:01 <arkeet> precisely
14:39:14 <arkeet> not to mention what happens when yss is too short.
14:39:37 <erisco> if you are talking wrt 'foo' in my example, that function was only to illustrate the effect I was talking about. of course the function is pointless
14:39:42 <arkeet> :)
14:40:49 <luite> init is usually code smell
14:41:43 <arkeet> > (zipWith const <*> drop 1) [1..10]
14:41:45 <lambdabot>   [1,2,3,4,5,6,7,8,9]
14:41:51 <mcstar> reverse . tail . reverse then
14:41:57 <arkeet> that's even worse
14:41:59 <arkeet> =(
14:42:03 <erisco> zip xss (init yss)    where length of yss is one greater than xss
14:42:21 <erisco> the actual dropping of the last element never occurs does it
14:42:25 <arkeet> nope
14:42:35 <arkeet> > zip [1,2,3] (4:5:6:undefined)
14:42:36 <lambdabot>   [(1,4),(2,5),(3,6)]
14:42:38 <erisco> yeah, that is precisely what happens in my algorithm
14:42:48 <arkeet> init still runs. it still traverses the list.
14:42:49 <erisco> so I am better to just not make the init call
14:42:51 <arkeet> it just doesn't do anything.
14:42:53 <erisco> right
14:43:38 <Rileld> I'm looking for the haskell equivalent of a ScheduledExecutorService in java. Does anyone know what I could use?
14:44:29 <arkeet> forkIO and threadDelay?
14:46:06 <arkeet> also check out the async package
14:46:08 <arkeet> @hackage async
14:46:09 <lambdabot> http://hackage.haskell.org/package/async
14:46:49 <seanparsons> That's handy, I was thinking about that exact question earlier today.
14:47:47 <erisco> haddock doesn't insist on jamming the pipe right next to the first character does it? http://www.haskell.org/haddock/doc/html/markup.html
14:48:04 <erisco> "--|" without the space would be much nicer
14:48:12 <arkeet> erisco: it cannot. --| is an operator name
14:48:20 <arkeet> > let (--|) = (+) in 5 --| 3
14:48:21 <lambdabot>   8
14:48:26 <erisco> my syntax highlighter lies :o
14:48:27 <Rileld> arkeet: thanks, they both look useful
14:50:15 <erisco> well then the pipe line gets a line all to itself... comment will start on the next
14:50:29 <johnw> i prefer "-- |"
14:50:49 <arkeet> erisco: hmm, why?
14:50:59 <erisco> "-- |This is my function"  looks so goofy to me
14:51:08 <arkeet> I'd put a space after the |
14:51:12 <johnw> yeah, me too
14:51:17 <erisco> and then the first character on the next line is under the pipe?
14:51:24 <johnw> I put it under the T
14:51:40 <Maior> erisco: there are many like it but this one is mine...
14:51:42 <johnw> I also use {- | foo -} for really long docs
14:51:56 <lpaste> arkeet pasted “No title” at http://lpaste.net/1473107300729225216
14:52:04 <arkeet> looks alright.
14:52:20 <johnw> agree
14:52:40 <edwardk> i use the -- | convention pretty much universally and reserve {-  and -} for commenting out code. no particular reason, but it just avoids code switching
14:52:51 <johnw> that's a good point
14:53:36 <edwardk> I tend to write a one sentence summary right after the | and then put all the examples and any more longwinded explanation below the break.
14:53:49 <edwardk> that encourages me to isolate a short description
14:54:03 <edwardk> but its really more of an artifact of the fact that it looks ugly otherwise ;)
14:54:20 <arkeet> I like one-line summaries.
14:54:31 <arkeet> I have a short memory.
14:54:34 <edwardk> and it isn't like i can claim to be any sort of expert at documentation ;) more the opposite
14:54:36 <arkeet> http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/src/Control-Lens-Lens.html
14:54:46 <erisco> edwardk, do your examples start aligned under the pipe? is there an extra line of whitespace?
14:54:52 <fylwind> so let's say I want to have a polymorphic function baz :: Baz a => a -> Bool, but I want a default definition to be provided if 'a' is an instance of Eq; is there a way to accomplish this?
14:55:09 <edwardk> erisco: usually an extra line of whitespace, then an @ block starts
14:55:14 <arkeet> fylwind: if you made Baz, then DefaultSignatures
14:55:54 <edwardk> i uniformly start the @'s on their own line and use the block of code underneath it  rather than use @'foo' a b c = … @    because haddock formats lines that start with @ and continue in the same line differently from ones that start the @ on the line above
14:55:59 <edwardk> that makes my haddocks very large
14:56:06 <fylwind> arkeet: thanks, i'll take a look
14:56:10 * hackagebot Hs2lib 0.5.8 - A Library and Preprocessor that makes it easier to create shared libs from Haskell programs.  http://hackage.haskell.org/package/Hs2lib-0.5.8 (TamarChristina)
14:56:24 <arkeet> class Baz a where baz :: a -> Bool; default baz :: Eq a => a -> Bool; baz = ...
14:56:40 <edwardk> but it fixes the visual disconnect between having some multiline blocks done with @\nfoo…   and other single line ones with @foo…@
14:57:06 --- mode: ChanServ set +o edwardk
14:57:15 --- mode: edwardk set +b *!b115f95e@gateway/web/freenode/ip.177.21.249.94
14:57:15 --- kick: trixiepat was kicked by edwardk (Your behavior is not conducive to the desired environment.)
14:57:53 --- mode: edwardk set -o edwardk
14:58:24 <edwardk> fylwind: default signatures are the best way i know
14:58:41 <edwardk> bbiab
15:04:19 <beefcube> is any case where one wants to pass in an immutable variable into a function (possibly recursive, or passes that into another), a good candidate case for the Reader monad?
15:05:06 <johnw> beefcube: are all the functions otherwise pure?
15:05:12 <beefcube> yes
15:05:14 <johnw> if so, then the "reflection" library might be cleaner
15:05:17 <beefcube> (assuming so)
15:05:40 <johnw> it tucks the value into a type, so that you don't have to make everything monadic solely to remove an extra variable getting passed around
15:06:04 <Makoryu> What
15:06:09 <Makoryu> That's intense
15:06:14 <johnw> yeah, it's a neat trick
15:06:30 <johnw> fully described in Oleg's paper on "Implicit Configurations", since the reflection docs don't really talk about the motivation
15:06:49 <Makoryu> Can it do this at runtime with user input
15:06:53 <johnw> yes
15:06:56 <johnw> that's actually the whole point of it
15:07:14 <fylwind> arkeet: worked well, thanks again
15:07:16 <johnw> it avoids all the typical global+IORef tricks with unsafePerformIO that people usually resort it
15:07:25 <johnw> s/it/to
15:09:52 <beefcube> johnw: ah, I'm pretty new to reader/writer, and I haven't gone beyond using Maybe/Either, I'm looking at other monads for practical day to day use
15:10:07 <johnw> well, in that case the answer to your first question was "yes" :)
15:10:23 <johnw> Reader makes passing around a common value implicit
15:11:15 * hackagebot abcnotation 0.5 - Haskell representation and parser for ABC notation.  http://hackage.haskell.org/package/abcnotation-0.5 (HansHoglund)
15:19:05 <erisco> is there a better way to get an infinite list of unique objects aside from [1..] ?
15:19:50 <elliott> unique howso?
15:20:29 <johnw> write a mapping function from Integers to values of your type?
15:23:18 <arkeet> erisco: can you be more specific?
15:23:23 <erisco> no
15:23:32 <arkeet> then I can't be more helpful =(
15:23:36 <erisco> :(
15:24:00 <erisco> that's okay
15:24:12 <elliott> I think you can be more specific. like, what are you using the list for?
15:24:12 <barrucadu> erisco: What makes [1..] not great?
15:24:26 <ion> [0..] is obviously better.
15:24:28 <implementation> is there any standard function for  \_ a -> a ? a prettier name for (flip const)?
15:25:07 <erisco> integers can be abused in my example to trivialize, and it makes me look like I'm setting up a strawman
15:25:29 <erisco> but I don't have other compelling infinite lists that aren't just repeated sequences
15:25:46 <johnw> implementation: seq
15:26:01 <edwardk> implementation: const id
15:26:03 <erisco> so I'll use integers, let these hypothetical people judge me, and then get the last laugh
15:26:05 <edwardk> :t const id
15:26:05 <lambdabot> b -> a -> a
15:26:07 <edwardk> er
15:26:12 <danharaj> why doesn't my itunes library search accept perl regexes
15:26:15 <edwardk> thats the one i use anywyas
15:26:18 <ion> > iterate (():) []
15:26:20 <lambdabot>   [[],[()],[(),()],[(),(),()],[(),(),(),()],[(),(),(),(),()],[(),(),(),(),(),...
15:26:32 <erisco> ion, :)
15:26:48 <implementation> johnw: thanks, that's what i was looking for ^^
15:26:49 <Hafydd> curry snd
15:26:53 <erisco> :t iterate
15:26:54 <lambdabot> (a -> a) -> a -> [a]
15:27:01 <erisco> > iterate (+) 1
15:27:02 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> a0
15:27:03 <lambdabot>  Expected t...
15:27:06 <johnw> edwardk: as long as y doesn't refer to x, seq x y is the same as flip const?
15:27:08 <edwardk> ion: of course that is just the naturals
15:27:13 <ion> edwardk: no kidding
15:27:14 <erisco> > iterate (+1) 0
15:27:15 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
15:27:26 <implementation> edwardk, Hafydd: those might work too, but i find them still as ugly as (flip const) xD
15:27:48 <edwardk> johnw: it'd could force a CAF x that would be otherwise left dangling
15:27:55 <johnw> ah, ok
15:28:06 <edwardk> e.g. if x is a top level definition
15:28:14 <roconnor> ReinH: actually it is Conor that rolls his eyes at infinite traversals.  I don't know how I feel about them in Haskell. :D
15:28:45 <roconnor> ReinH: I roll my eyes whenever edward produces a Lens combinator that doesn't necessarily preserve the laws.
15:29:00 <edwardk> they'd probably be on firmer footing if we had Applicative split into 'data and codata applicatives'
15:29:09 <elliott> I still want a formal treatment of infinite traversals.
15:29:11 <S_J> why does readChan return IO a? it seems now when I test it waits until something is available...
15:29:12 <elliott> they're fishy.
15:29:26 <roconnor> elliott: formally there are no infintie traversals :P
15:29:36 <danharaj> what is a traversal formally
15:30:18 <edwardk> roconnor: how do you ever get to use your poor abused eyes for seeing then? i mean your extraocular muscles must be able to bench-press a forklift.
15:30:19 <elliott> roconnor: what if you use codata?
15:30:20 <danharaj> essence of the iterator pattern?
15:30:33 <roconnor> danharaj: formal formal, or informal formal?
15:30:54 <elliott> roconnor: so you can have infinite trees of (<*>) etc.
15:31:02 <danharaj> roconnor: fix (formal $)
15:31:41 <ion> (fix $) (formal $)
15:31:52 <elliott> roconnor: CoInductive Ap F := Embed : forall {A}, F A -> Ap F A  Pure : forall {A}, A ->
15:31:55 <elliott> erm.
15:32:04 <edwardk> danharaj: isn't there a completeness theorem that basically shows you can't fix the formalism and prove anything interesting about it in itself? =)
15:32:15 <elliott> roconnor: CoInductive Ap F := Embed : forall {A}, F A -> Ap F A | Pure : forall {A}, A -> Ap F A | Apply : forall {A B}, Ap F (A -> B) -> Ap F A -> Ap F B.
15:32:23 <elliott> and then forall {A}, Ap F A -> F A or such.
15:32:30 <elliott> with laws.
15:32:37 <elliott> do you get infinite traversals then?
15:32:38 <danharaj> edwardk: I haven't seen the proof that you can embed peano arithmetic in lens-fu
15:32:39 <danharaj> ;)
15:33:32 <roconnor> danharaj: formal formal is in  http://traversable-fincontainer.googlecode.com/files/decompose_traversal_20121203.v
15:33:38 <erisco> > [(s-x,x) | s <- [1..], x <- [10..s]]
15:33:39 <lambdabot>   [(0,10),(1,10),(0,11),(2,10),(1,11),(0,12),(3,10),(2,11),(1,12),(0,13),(4,1...
15:33:45 <roconnor> danharaj: let me know if you want less formal
15:33:51 <danharaj> roconnor: what is a .v file
15:33:56 <roconnor> danharaj: coq.
15:33:59 <danharaj> oh
15:34:01 <danharaj> makes sense
15:34:07 <roconnor> v stands for venacular
15:34:25 <erisco> this uses s-x to derive an element, but this cannot work for any objects in general can it?
15:34:31 <erisco> having second thoughts XD
15:34:45 <edwardk> Lens-Fu is the first category-theory-inspired mixed martial art. Like Brazilian Jiu-Jitsu it borrows from everything and holds few if any traditions sacred. =P
15:35:01 <roconnor> *l*
15:36:02 <edwardk> and i'm sure roconnor has a laugh every time i talk about traversal laws, given that for the longest time i had given up reasoning about 'multi-lenses' as gobbledigook. ;)
15:36:13 <erisco> it seems to be abusing properties of integers to trivialize the more general problem
15:36:46 <erisco> if you could map integers to your objects, then this would work
15:37:48 <erisco> but even if you can, you have the perf concern of indexing
15:38:37 <roconnor> edwardk: have you given much thought to "multiplate" things of (a -> f a') -> (b -> f b') -> ... -> (z -> f z') ?
15:38:58 <roconnor> sort of multi-argument traversals/lenses.
15:39:00 <edwardk> roconnor: yes. sadly they don't give nice combinators =(
15:39:14 <roconnor> at least not in any obvous way
15:39:25 <edwardk> i may eventually introduce some combinators for working with two targets, e.g. generalized bitraverse
15:39:26 <roconnor> I hope there is something clever than can be done in that area.
15:39:45 <edwardk> but you start getting an explosion of different notions
15:39:54 <roconnor> Van laarhoven style is extrodinarily clever.  It will be hard to match.
15:39:55 <johnw> Notion Explosion!
15:40:06 <edwardk> e.g. you can 'bitraverse' Either with a Functor, but need an Applicative to bitraverse the sides of a pair, etc.
15:40:32 <edwardk> i often mix lenses with Bitraversable in real code
15:40:32 <erisco> hmm, you should always be able to map the integers because you're always going to have a list, and that can be indexed
15:40:38 <roconnor> maybe some external sugar (like do notation) is appropriate somehow.
15:41:33 <erisco> so I think that is the real crux... you can generate the necessary indexes, and it will work, but then you have to incur whatever indexing cost. if it is constant, fine. but if it is a list index operation, then that is a problem
15:44:09 <edwardk> roconnor: well, you can already use arrow sugar (backwards) to build big traversals/folds/lenses
15:45:13 <elliott> edwardk: huh, do you have examples of that?
15:45:47 <edwardk> elliott: try it. its easy. the lenses themselves form 'arrows'  in the (->) arrow
15:45:53 <edwardk> but they go the wrong way
15:46:01 <elliott> that's boring.
15:46:05 <elliott> :(
15:46:12 <edwardk> you can mix in uncurry bitraverse    to make it more interesting
15:46:15 <edwardk> :t uncurry bitraverse
15:46:16 <lambdabot>     Not in scope: `bitraverse'
15:46:16 <lambdabot>     Perhaps you meant one of these:
15:46:16 <lambdabot>       `itraverse' (imported from Control.Lens),
15:46:21 <edwardk> :t uncurry Data.Bitraversable.bitraverse
15:46:22 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable t) => (a -> f c, b -> f d) -> t a b -> f (t c d)
15:46:58 <edwardk> then you can x <- uncurry bitraverse -< (y,z)
15:47:23 <edwardk> that gives your diagram a fork
15:48:28 <edwardk> iirc i thought about using it for some of the cofree comonad lenses and decided against it
15:48:38 <edwardk> because it was just gratuitous
15:52:18 * quchen decided to make more use of (:) sections to make the code look happier.
15:53:28 <Peaker> (:[]) doesn't look that happy
15:53:46 <jmcarthur> robot monkey
15:53:54 <quchen> To little spaces! (: [])
15:53:58 <edwardk> (():) looks kind of shocked too
15:54:09 <quchen> It's just the one parenthesis, not the entire thing.
15:54:17 <Peaker> edwardk, I don't think I ever wrote that section :)
15:54:21 <quchen> It's a useful technique in case you don't want to define your own :-> operator :-D
15:54:27 <edwardk> (D:)  looks downright mad
15:54:32 <jmcarthur> Peaker: i... i think i have done that one before
15:54:35 <quchen> (:D)
15:54:50 <jmcarthur> Peaker: it just a hacky peano numerals thing
15:54:51 <edwardk> quchen: that one strikes me as unlikely to typecheck
15:54:53 <jmcarthur> *it was
15:55:15 <edwardk> maybe at the type level using a type family for D that expands to a list of types
15:55:29 <jmcarthur> but that would have to be (':D)
15:55:37 <jmcarthur> if a section is even allowed there...
15:55:38 <arkeet> @quote eat.a.comment
15:55:38 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
15:55:40 <edwardk> but you can't section at the type level
15:55:45 <implementation> (:p)
15:55:49 <arkeet> @quote \(:\[
15:55:49 <lambdabot> byorgey says: now we have the pig operator <^(++)^> as well as the robot monkey operator (:[])
15:55:51 <quchen> edwardk: Hm. (:-D) then.
15:56:56 <quchen> While we're at it we should rename Kleisli monad composition to "fish".
15:57:27 <implementation> we need sharks to hunt them
15:57:36 <quchen> Lens has sharks
15:57:50 <edwardk> quchen: we also have the rat: <<>~
15:58:14 <Peaker> jmcarthur, I wonder why almost no-one goes for lazy numerals that are not peano, lists of binary digits or such
15:58:25 <Peaker> I guess they aren't that useful
15:58:27 <quchen> edwardk: And the happy left snake <^~
15:58:29 <implementation> :t (<<>~)
15:58:29 <lambdabot> Monoid m => Overloading (->) q ((,) m) s t m m -> m -> q s (m, t)
15:58:49 <edwardk> Peaker: mostly because you have a hard time forcing them meaningfully.
15:58:53 <implementation> wtf typefuck
15:59:00 <barrucadu> :t (<^~)
15:59:00 <lambdabot> (Integral e, Num a) => Overloading (->) q ((,) a) s t a a -> e -> q s (a, t)
15:59:05 <johnw> :t (<\o/>)
15:59:06 <lambdabot> parse error on input `)'
15:59:09 <edwardk> implementation: the haddocks show nicer types for that ;)
15:59:35 <implementation> hoogle doesnt even find that one
15:59:51 <edwardk> hoogle doesn't index lens at last check
15:59:55 <quchen> Hoogle doesn't find Lens stuff I think (beyond the package itself)
15:59:58 <edwardk> i think ndm has it in for me ;)
16:00:05 <johnw> fpcomplete.com/hoogle does
16:00:05 <quchen> There are a couple of others missing, like async
16:00:24 <johnw> it has lens, async, all the common stuff (anything in stackage)
16:00:52 <quchen> At least it finds the package now so I can use that to look things up in the package index.
16:01:06 <edwardk> > ("hello","world") & _2 <<>~ "!!"
16:01:08 <lambdabot>   ("world!!",("hello","world!!"))
16:01:09 <jmcarthur> Peaker: lazy binary numerals are significantly more difficult to implement and use effectively
16:01:37 <edwardk> it updates a target monoidally, and gives you the result it made and the reassembled structure
16:02:07 <edwardk> the types are as crazy as they are because it permits a few more things to work with it
16:02:57 <edwardk> notably you can pass it an indexed traversal and then use Indexed on the right hand side of <<>~ to get access to the current index as well as the value
16:03:53 <S11001001> @ty coerce
16:03:55 <lambdabot> (Functor f, Contravariant f) => f a -> f b
16:04:21 <S11001001> @src coerce
16:04:22 <lambdabot> Source not found. stty: unknown mode: doofus
16:06:34 <dwcook> @ty contramap
16:06:35 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
16:10:29 <edwardk> :t contramap (const ()) . fmap (const ())
16:10:31 <lambdabot> (Functor f, Contravariant f) => f a1 -> f a
16:10:42 <edwardk> :t fmap absurd . contramap absurd
16:10:43 <lambdabot> Not in scope: `absurd'
16:10:43 <lambdabot> Not in scope: `absurd'
16:10:49 <edwardk> :t fmap Data.Void.absurd . contramap Data.Void.absurd
16:10:50 <lambdabot> (Functor f, Contravariant f) => f b1 -> f b
16:11:01 <dwcook> @src Data.Void.absurd
16:11:01 <lambdabot> Source not found. Are you typing with your feet?
16:11:02 <edwardk> coerce is the absurd version
16:11:12 <edwardk> absurd (Void a) = absurd a
16:11:22 <aegis__> edwardk: holy mother of god what kind of black sorcery are you doing?
16:11:30 <edwardk> newtype Void = Void Void
16:11:32 <jmcarthur> haha
16:11:45 <quchen> Void !Void! :-D
16:11:51 <jmcarthur> newtype Void = Void (forall a. a)
16:12:29 <quchen> Speaking of the exclamation mark, what's that one for?
16:12:31 <edwardk> jmcarthur: we may switch to that with the new newtype coercions
16:12:32 <aegis__> I should probably quit this irc channel while I'm learning haskell or I am going to freak out -->
16:12:35 <jmcarthur> :D
16:12:47 <haasn> edwardk: isn't this ‘vacuous’?
16:12:53 <edwardk> vacuous = fmap absurd
16:13:03 <edwardk> :t Data.Void.vacuous
16:13:04 <lambdabot> Functor f => f Data.Void.Void -> f a
16:13:04 <jmcarthur> aegis__: no, stay. there is a lot to learn through simple osmosis
16:13:04 <quchen> Oh, the "!" is only for older GHC versions. Nevermind then.
16:13:09 <sipa> :t absurd
16:13:09 <lambdabot> Not in scope: `absurd'
16:13:26 <jmcarthur> quchen: ?
16:13:35 <jmcarthur> quchen: where did the ! first occur in this conversation?
16:13:36 <edwardk> aegis__: Void is simply a data type that shouldn't have any inhabitants. it does, but it serves as a placeholder for the impossible type
16:13:45 <aegis__> jmcarthur: ^^' sure there is
16:13:47 <quchen> jmcarthur: I thought it was "data Void = Void !Void", not "Void Void".
16:13:54 <quchen> And then I wondered why the "!".
16:14:05 <quchen> Now I wonder why the `seq` in `absurd` instrea.
16:14:10 <quchen> instead*
16:14:39 <edwardk> aegis__? fmap :: Functor f => (a -> b) -> f a -> f b   says you can map covariantly, contramap :: Contravariant f => (a -> b) -> f b -> f a   says you can map contravariantly. if you can do both and satisfy the laws for both classes then the type argument must not be used in your type at all.
16:14:48 <Peaker> aegis__, "Functor" means the type variable appears in the type only in positive positions. "Contravariant" means it appears only in negative positions.  The combination/intersection means it doesn't appear at all.  A type var that doesn't appear at all (also called a "phantom type") may be changed (it's a no-op), and the functions above do this changing via the Functor/Contravariant classes
16:14:48 <edwardk> aegis__: therefore we can turn it into anything we want
16:15:23 <edwardk> quchen: we have the data Void = Void !Void  version but only under a CPP check for ghc 6.12
16:15:39 <edwardk> quchen: 6.12 would loop forever on the newtype Void = Void Void version even though that worked before and after 6.12
16:15:57 <quchen> Compiler bug I suppose? Or did something fundamentally change
16:15:57 <aegis__> I'll have to re-read that few times but I think it makes sense, somehow
16:15:58 <jmcarthur> quchen: for data Void = Void !Void, the ! would be necessary because otherwise i could actually construct an infinite value to inhabit the type
16:16:08 <edwardk> quchen: briefly lived compiler bug
16:16:49 <dwcook> Why not just: data Void -- ?
16:16:53 <edwardk> aegis__: basically there is always a function _to_ ()  from any type   a -> ()   can b given by const ()     so we can fmap (const ()) to go from f a -> f ()
16:16:53 <quchen> jmcarthur: Oh right, "data Void = Void Void" is an infinite [()] which has a value
16:17:09 <quchen> dwcook: Non-standard Haskell, needs EmptyTypeDecls
16:17:10 <jmcarthur> dwcook: requires an extension, at least in Haskell 98
16:17:15 <edwardk> and we can contramap (const ()) to go from f () -> f b
16:17:16 <dwcook> Ahh
16:17:17 <jmcarthur> i think 2010 has it
16:17:22 <edwardk> if you can do both, then you can round trip through unit.
16:17:31 <edwardk> otoh, there is absurd :: Void -> a
16:17:39 <quchen> jmcarthur: I suppose what you mentioned is also the reason for the 'seq' in 'absurd'?
16:17:43 <edwardk> which can go _from_ Void to any type since Void shouldn't have any inhabitants
16:17:47 <edwardk> so we can do the opposite
16:17:50 <jmcarthur> quchen: i don't know what definition you are talking about
16:18:01 <edwardk> contramap absurd :: f a -> f Void
16:18:07 <edwardk> then fmap absurd :: f Void -> f b
16:18:07 <quchen> jmcarthur: absurd a = a `seq` spin a where spin (Void b) = spin b
16:18:14 <edwardk> composed they give you f a -> f b
16:18:48 <quchen> edwardk: Did the discussion about adding Void to Base reach a conclusion by the way?
16:18:51 <edwardk> dwcook: EmptyDataDecls were added after i wrote void ;) at the time i was on a haskell 98 kick
16:18:58 <aegis__> edwardk: so () is an alternative notation for Void? thanks for the explanations!
16:19:02 <jmcarthur> quchen: i can't say i know why that is defined that way
16:19:09 <dwcook> I was actually unaware it wasn't Haskell 98, as I don't need to explicitly enable any extensions to use it.
16:19:21 <edwardk> aegis__: no. think of () like the 'set that contains one object' and Void like the set that contains no objects.
16:19:40 <quchen> edwardk: Since it's your package you surely know the reason for the strictness annotation in absurd?
16:19:46 <edwardk> aegis__: there is always a function _to_ () from any type. and there is always a function from Void to every type
16:20:10 <edwardk> quchen: it forced you to get the bottom you were given rather than loop forever.
16:20:16 <dwcook> There's a unique function from {} to any set a, the empty function
16:20:20 <edwardk> they are otherwise semantically indistinguishable
16:20:33 <edwardk> dwcook: it was turned on in Haskell2010
16:21:24 <jmcarthur> newtype Unit = Unit (forall r. (forall a. a -> r) -> r)
16:21:28 <dolio> I don't think 'newtype Void = Void (forall a. a)' helps with newtype coercions unless they add extra magic.
16:21:35 <quchen> edwardk: "Get the bottom you were given"? I read your sentence as "it's a hack that avoids an infinte loop", is that right?
16:21:39 <edwardk> dolio: that is part of the current discussion
16:21:55 <aegis__> edwardk: so the type () has one value, itself written (), and the type Void has no value at all?
16:21:59 <edwardk> basically you get the Void ~R# (forall a.a) in the environment which can only be used to go one way
16:22:08 <edwardk> aegis__: yes
16:22:25 <dolio> You don't want f (forall a. a), though. You want f a.
16:22:28 <dolio> Which is not the same.
16:22:31 <edwardk> quchen: well, say you wrote (error "foo" :: Void)   and called absurd on it
16:22:31 <aegis__> edwardk: might be a stupid question but what's the use of Void then? except mental masturbation
16:22:36 <edwardk> both ways to implement it give you a _|_
16:22:42 <jmcarthur> aegis__: Void *shouldn't* have any values, but in haskell it actually does since _|_ inhabits every type. that said, it's useful to pretend there is not _|_ sometimes
16:22:54 <edwardk> but if i implemented it without the ! then you'd just get the looping forever hit ^C to get your computer back bottom
16:22:57 <edwardk> when you ran it from ghci
16:23:08 <edwardk> and implementing it with the ! causes you to get back the error "foo"
16:23:19 <quchen> edwardk: Ah, I see, makes sense now.
16:23:21 <edwardk> they are semantically the same as bottoms are indistinguishable in theory
16:23:25 <edwardk> but practically very different
16:23:47 <jmcarthur> aegis__: if a function says it returns a Void that means it doesn't return at all, which allows you to handle stuff like dissecting an Either Void Int without resorting to _|_ in one of the cases
16:23:50 <edwardk> aegis__: Void is useful as a placeholder whn you know something doesn't have any uses of the argument
16:23:56 <edwardk> [Void]   is necessarily []
16:24:23 <dwcook> > length [undefined, undefined, undefined]
16:24:24 <lambdabot>   3
16:24:26 <jmcarthur> aegis__: if i pattern match on an Either Void Int, then one of my cases can look like   Left void -> absurd void
16:24:27 <edwardk> if i have data Exp a = Var a | App (Exp a) (Exp a) | Lam (Exp (Maybe a))       and I have Exp Void i know the expression is 'closed'
16:24:34 <edwardk> dwcook: up to people doing stupid things =P
16:24:38 <dwcook> :D
16:24:41 <quchen> Another example would be to have a grammar that has no syntax errors, a parser for that could have type 'Either Void ParsedData' because the parser can never fail.
16:25:11 <quchen> s/a parser/a parsing function
16:25:28 <edwardk> aegis__: the role of Void is to package up a constraint tat the argument shouldn't be inhabited in many places you accept an argument in negative position
16:25:31 <aegis__> jmcarthur: any good article to read that with a fresh brain tomorrow morning?
16:25:40 <Peaker> edwardk, that's a neat trick, I wonder if Haskell had a more flexible type system (with "variants" and similar on-the-spot structural records/etc) if that kind of thing could be encoded in a more flexible and straight-forward way
16:26:16 <Peaker> edwardk, btw, when you pattern-match on Exp Void, GHC doesn't have the equivalent of Agda's () pattern-matcher for Void, does it?
16:26:20 <edwardk> Peaker: probably. i just use 'traverse (const Nothing)'   as an 'isClosed' lint pass
16:26:22 <jmcarthur> at work we have an network rpc library. one of the protocols responds with either an error or a real result. sometimes i know there can be no error, so i can set the error type of Void in my protocol, then the client side can safely use absurd to show demonstrate to the compiler that it expects to never encounter that case
16:26:25 <edwardk> :t traverse (const Nothing)
16:26:26 <lambdabot> Traversable t => t a -> Maybe (t b)
16:26:30 <jmcarthur> arkeet: real-world use case ^^
16:26:51 <edwardk> that says if the container ha no 'a's in it then traversing it can change out the type to any other b you want. otherwise it fails.
16:26:52 <arkeet> me?
16:26:56 <edwardk> :t traverse Left
16:26:57 <lambdabot> Traversable t => t a -> Either a (t b)
16:27:09 <jmcarthur> arkeet: sorry, i meant aegis__
16:27:10 <Peaker> edwardk, the problem is you might have a more complex AST, (e.g: we have holes) and then you might need a lot of type vars for this kind of thing :(
16:27:12 <arkeet> oh ok
16:27:26 <aegis__> jmcarthur: absurd :: Void -> a; if Void doesn't have any value how come can a function take a Void as argument?
16:27:27 <edwardk> that is used all over in lens code as a form of costrength. to find any 'a' in the type and bail
16:27:29 <jmcarthur> aegis__: and if the type in the protocol ever changes, the build for the client will start failing because i was telling the compiler that i didn't expect to hit that case :)
16:27:39 <edwardk> Peaker: thats what i use bound for
16:27:49 <jmcarthur> aegis__: i can write functions that accept it, but i can't write anything that produces it
16:28:01 <Peaker> edwardk, can you say more? :)
16:28:06 <jmcarthur> aegis__: that's why functions like absurd are safe
16:28:21 <edwardk> aegis__: absurd witnesses the logical property of 'ex falso quodlibet' if you can prove falsehood you can prove anything.
16:28:24 <Peaker> btw, anyone in this discussion is going to be in IFL soon?
16:28:35 <edwardk> aegis__: from abhttp://en.wikipedia.org/wiki/Principle_of_explosion
16:28:48 <edwardk> Peaker: you're in luck. i wrote up a tutorial on bound the other day
16:29:01 <edwardk> http://fpcomplete.com/user/edwardk/bound
16:29:13 <Peaker> aegis__, Taking Void as an argument is easy. Giving Void as an argument is the hard part :)
16:29:14 <edwardk> Peaker: that covers how i deal with name capture
16:29:31 <arkeet> absurd :: PinkUnicorn -> a
16:29:39 <Peaker> edwardk, I think I understood that part - and it's a pretty great idea :)  I am wondering about other kinds of subexpressions/leafs in the AST
16:29:43 <aegis__> Peaker: erm, so where to you get a Void value from? where does it arise from?
16:29:52 <arkeet> aegis__: you can't, and that's the point
16:29:52 <arkeet> .
16:30:00 <jmcarthur> aegis__: the point is that it never happens
16:30:27 <arkeet> "if I have a pink unicorn, then I can give you a value of type 'a'".
16:30:32 <aegis__> jmcarthur: so what's the hole freaking point of having a function that takes it if this function will never get called? :°
16:30:34 <jmcarthur> aegis__: sometimes you are using some polymorphic function that would force you to handle some case when you know from context that i can't happen, so by instantiating the type variable to Void you can prove that it won't happen
16:30:34 <Peaker> aegis__, since nobody can ever give you Void, the function can return any type at all, and it would not be a problem, since it could never actually be invoked
16:30:35 <arkeet> this is true, because there are no pink unicorns.
16:30:44 <jmcarthur> *that it can't happen
16:31:07 <quchen> arkeet: There are no proofs for pink unicorns.
16:31:07 <edwardk> aegis__: in the expression type i showed above i can have an Exp Void                in which i know no 'Var's occur that don't reference somthing bound by a lambda outside of them
16:31:08 <johnw> arkeet: like there being no black swans?
16:31:39 <Makoryu> More like married bachelors
16:31:43 <tel> aegis__: I think of absurd as calling the compiler's bluff—"you claim you can give me something that doesn't exist, well then I'm going to give you a non-bottom value of type (forall a . a)"
16:31:48 <Peaker> aegis__, it's less about "Void" values directly, and more about compositions that use it.  For example "f Void" has the "f" part which may be interesting and the "Void" part which means no value is there.  You can then use:  neverCalledEver :: Void -> a     and a Functor instance, to convert "f Void" to "f WhateverYouWant"
16:32:10 <edwardk> aegis__: lets just take the simpler case: data Exp a = Var a | Add (Exp a) (Exp a) | Lit Int    -- Exp String  would be an expression with free variables in it, Add (Var "x") (Lit 12)
16:32:28 <edwardk> if i had an Exp Void   i'd know that 'Var' doesn't happen in that particular expression
16:32:47 <arkeet> I was wondering when the AST example would come.
16:32:50 <edwardk> and i could say that i can transform it vacuously into any other Exp a
16:33:04 <quchen> aegis__: Many functions having a "dangling 'a'" could have Void types that expresses their intention better. For example, "forever :: Monad m => m a -> m b" could be written as "forever :: Monad m => m a -> m Void" because it never produces a value.
16:33:29 <jmcarthur> :t traverse (const Nothing)   -- i love this expression
16:33:30 <lambdabot> Traversable t => t a -> Maybe (t b)
16:33:40 <Peaker> aegis__, consider:   Either a b    if you want to use types to force this Either to have a "b" in it (be Right and not Left), you can set a=Void, and voila.   In a sense, Void is like 0 in maths.  You could ask "What's the point of a number that counts no elements at all?" and the Romans did. But it turns out to be useful :)
16:33:42 <edwardk> without having the ability to think about Void, i'd have to write two Exp types, one for expressions that have variables in them, and one where i've handled all the variables
16:33:48 <arkeet> > traverse (const Nothing) []
16:33:49 <lambdabot>   Just []
16:33:50 <arkeet> > traverse (const Nothing) [1]
16:33:51 <edwardk> jmcarthur: yeah when i figured that out i did a little dance
16:33:51 <lambdabot>   Nothing
16:33:52 <arkeet> nice.
16:34:09 <edwardk> traverse Left is also pretty handy
16:34:15 <jmcarthur> ooh
16:34:16 <arkeet> :t traverse Left
16:34:16 <lambdabot> Traversable t => t a -> Either a (t b)
16:34:20 <quchen> jmcarthur: Care to explain? (I've seen it above and I don't see why it's so special. Does it just turn every Traversable containing "values" into Nothing?)
16:34:26 <arkeet> yep
16:34:30 <edwardk> it provides you with proof there was an 'a' in there, by giving one to you
16:34:30 <jmcarthur> quchen: check out the result type!
16:34:38 <jmcarthur> quchen: see how it's a b instead of an a?
16:34:40 <Targen> What are the design tradeoffs between those two options?  I’ve always wondered why things like putStrLn bother producing a value at all, even unit.
16:34:46 <quchen> jmcarthur: Yes.
16:35:03 <jmcarthur> quchen: that means that if i get a Just out of it then i have proven that the term contains no values of type a
16:35:07 <Peaker> edwardk, traverse (Foo . Left) could also be useful where Foo gives the accumulating-to-Monoid Applicative instance
16:35:07 <arkeet> Targen: putStrLn terminates.
16:35:08 <edwardk> Targen: semantically that is the only correct result. if putStrLn _didn't return_ then it could give back IO a
16:35:15 <jmcarthur> quchen: so now i can coerce it to whatever i want
16:35:16 <Peaker> (don't remember how it's called)
16:35:38 <Targen> Oh, my bad.  I didn’t mean that.
16:35:44 <edwardk> :t System.Exit.exitSuccess
16:35:44 <lambdabot> IO a
16:35:53 <Targen> I should get some sleep. :)  I meant things like ... yeah, that.
16:36:02 <arkeet> :)
16:36:02 <Targen> Why not IO Void?
16:36:02 <edwardk> that is an IO a, because it never comes back, you can pretend it is an expression that gives back any result you want
16:36:12 <edwardk> because you may want to use it in an arbitrary context.
16:36:20 <quchen> jmcarthur: I haven't coerced anything to anything yet, so I don't see the benefit here. Isn't coercion about things that are identical but the compiler doesn't quite know about that?
16:36:22 <edwardk> returning IO Void is forcing the user to use absurd themselves
16:36:30 <tel> quchen: it's a fakeout coerce, "I can turn a -> b so long as you don't actually have any as for me"
16:36:36 <Targen> So it’s a matter of usability?
16:36:38 <edwardk> Void should generally be used in negative position.
16:36:48 <valyagolev> eternalYouth <- System.Exit.exitSuccess
16:36:52 <edwardk> well, its one of needless restriction
16:36:54 <jmcarthur> quchen: coercion doesn't necessarily mean that it's not type checked
16:37:06 <edwardk> forall a. IO a  can be instantiated to IO Void
16:37:11 <jmcarthur> quchen: (this is just a terminology thing. some may disagree, but then i would just use a different word)
16:37:25 <edwardk> so there is no need for naming the concept there
16:37:37 <edwardk> its only when you want to take some IO action that you know will never return as an argument that you should use void
16:37:38 <edwardk> because
16:37:58 <edwardk> IO Void -> IO SomethingElse
16:38:15 <edwardk> uses fewer extensions than (forall a. IO a) -> IO SomethingElse  and infers better
16:38:16 <monochrom> also, in "callCC (\k -> ...) :: m Int", k :: Int -> m a, or you can say k :: Int -> m Void
16:38:19 <quchen> jmcarthur: Is there a simple use case? I still don't understand what that 'traverse (const Nothing)' expression is good for, except the "proving there were no values of type 'a' in the first place".
16:38:26 <edwardk> callCC is an example where it should be a rank-3 type
16:38:27 <aegis__> edwardk: Ok, that makes sense, thanks a lot! So correct me if I am wrong but if you have an instance of Maybe Void you know that you can concert it to any Maybe a type because its value can only be Nothing
16:38:32 <jmcarthur> quchen: that's exactly what it's good for
16:38:46 <quchen> jmcarthur: is it a very general "empty structure" check then?
16:38:54 <aegis__> edwardk: convert*
16:38:54 <jmcarthur> quchen: the first time i encountered it was to show that an AST has no free variables
16:38:56 <edwardk> aegis__: basically if you have Maybe Void then you can be assured that it is either Nothing, or someone did something stupid and put a _|_ in the Just
16:38:59 <quchen> jmcarthur: Like "there's just structure, no values in here"?
16:39:06 <jmcarthur> quchen: yup!
16:39:06 <Peaker> quchen, the structure is only "empty" of a's, it has very interesting things inside it besides the a's
16:39:14 <edwardk> aegis__: in either case you're generally within your rights to ignore the Just case then
16:39:19 <arkeet> > (traverse.traverse) (const Nothing) [[],[]]
16:39:20 <lambdabot>   Just [[],[]]
16:39:23 <johnw> so Maybe Void ~ ()?
16:39:26 <arkeet> > (traverse.traverse) (const Nothing) [[],[2]]
16:39:28 <aegis__> edwardk: a_|_ is a non-terminating function, right?
16:39:28 <lambdabot>   Nothing
16:39:30 <quchen> Peaker: Yes, I meant "empty" as in "no 'a'".
16:39:38 <edwardk> johnw: modulo concerns about distinguishing bottoms.
16:39:40 <Peaker> edwardk, how do you ignore the ruled-out data constructors that have Void in them, when pattern matching?
16:39:45 <edwardk> Either Void a = a, etc.
16:39:49 <joelteon> what's the difference between Void and ()
16:39:53 <Peaker> Haskell lacks Agda's () absurd-pattern-matcher
16:39:56 <edwardk> Peaker: pattern match and just invoke absurd
16:40:00 <jmcarthur> :t either absurd id
16:40:01 <lambdabot> Not in scope: `absurd'
16:40:01 <arkeet> joelteon: () contains one value. Void contains none
16:40:03 <jmcarthur> :(
16:40:05 <joelteon> oh
16:40:07 <Peaker> joelb, Void has 0 values in it.  () has 1.
16:40:10 <johnw> so, if Maybe is 1 + a, and a is 0, then it equals 1, cool
16:40:13 <joelteon> in what situation would you use Void
16:40:15 <quchen> jmcarthur: Ah I see, so suppose you've got an AST and you want to check whether it contains values (in the "has type 'a'" sense), then apply that emptiness checker to it
16:40:24 <jmcarthur> quchen: yeah, that's the idea
16:40:29 <arkeet> joelteon: that's precisely what we've been discussing.
16:40:33 <arkeet> read the scrollback :-)
16:40:34 <joelteon> oh
16:40:45 <quchen> jmcarthur: That's not half as complicated as I imagined it when I read it the first time. :-)
16:40:49 <aegis__> joelteon: grab a coffee before
16:40:51 <jmcarthur> quchen: and since the result allows you to coerce the type variable to something, you can coerce it to Void and use absurd as you interpret the result
16:40:55 <joelteon> no, I'm good
16:41:09 <quchen> jmcarthur: Now you lost me again.
16:41:15 <arkeet> > (traverse.traverse) Left [[],[2,3]]
16:41:16 <lambdabot>   Left 2
16:41:16 <jmcarthur> quchen: so it's a that allows you to avoid the "assert false" style of programming
16:41:28 <jmcarthur> *so it allows
16:41:30 <arkeet> > (traverse.traverse) Left [[],[]]
16:41:31 <quchen> jmcarthur: What's the (your?) definition of 'coerce' here?
16:41:31 <lambdabot>   Right [[],[]]
16:41:33 <monochrom> I void my error cheques with forall a. a
16:41:35 <arkeet> nice.
16:42:04 <jmcarthur> quchen: if a type variable is otherwise unrestricted, i can force it to be whatever i want it to be
16:42:34 <edwardk> :t fmap Data.Void.absurd
16:42:36 <quchen> Right, you can specialize to whatever you like if a variable is free.
16:42:41 <edwardk> :t contramap Data.Void.absurd
16:42:42 <lambdabot> Functor f => f Data.Void.Void -> f b
16:42:43 <lambdabot> Contravariant f => f b -> f Data.Void.Void
16:42:49 <edwardk> :t contramap Data.Void.absurd . fmap Data.Void.absurd
16:42:50 <lambdabot> (Functor f, Contravariant f) => f Data.Void.Void -> f Data.Void.Void
16:42:57 <edwardk> :t  fmap Data.Void.absurd . contramap Data.Void.absurd
16:42:57 <lambdabot> (Functor f, Contravariant f) => f b1 -> f b
16:43:00 <S11001001> edwardk: I was trying to define folded from first principles, went "what the hell now, this is anyvariant, so..." and looked at the original to see that
16:43:06 <edwardk> coerce = fmap Data.Void.absurd . contramap Data.Void.absurd
16:43:15 <edwardk> :t folded
16:43:16 <arkeet> :t  fmap Data.Void.absurd . contramap Data.Void.absurd :: Const r a -> Const r b
16:43:16 <lambdabot> Const r a -> Const r b
16:43:30 <edwardk> :t Control.Lens.folded
16:43:31 <lambdabot> (Applicative f1, Foldable f, Indexable Int p, Contravariant f1) => p a (f1 a) -> f a -> f1 (f a)
16:43:35 <jmcarthur> ah, it's available qualified
16:43:41 <jmcarthur> :t either Data.Void.absurd id
16:43:42 <lambdabot> Either Data.Void.Void c -> c
16:44:06 <quchen> jmcarthur: OOoooh, so when you define "foo = traverse (const Nothing) :: Maybe (t Void)" the code won't compile when you have a structure that possibly contains values?
16:44:21 <jmcarthur> quchen: no, it will compile, but you just get Nothing instead of Just
16:44:22 <tel> quchen: it'll just give you a runtime Nothing
16:44:40 <arkeet> but if it doesn't contain values, then you'll get Just the structure. ;)
16:45:02 <tel> (While talking about Void/absurd, I'd like to bring up how cool defining data Void = Void Void is. Then you get absurd (Void v) = absurd v)
16:45:05 <quchen> Wait what? How does it get from Just to Nothing? Because you can safely unsafeCoerce Just (x :: Void) to Nothing?
16:45:11 <S11001001> edwardk: on my way to defining, eh, intercalateOf :)
16:45:16 <arkeet> tel: and then fix Void.
16:45:25 <arkeet> a newtype would be better, I suppose.
16:45:41 <tel> arkeet: true
16:45:45 <edwardk> S11001001: Folding f a   is used because otherwise backwards folded    doesn't work
16:45:49 <jmcarthur> quchen: if it encounters a value, const Nothing makes it Nothing, and the Applicative magic makes the whole thing Nothing
16:46:04 <edwardk> or one of those things
16:46:07 <jmcarthur> quchen: so it can only be Just if there are not values in it
16:46:23 <edwardk> S11001001: you can view it as a generalized version of just using Const for the fold
16:46:26 <jmcarthur> quchen: it's the Maybe instance of Applicative
16:46:32 <aegis__> so you can still call absurd with: loop = loop; absurd loop ?
16:46:35 <S11001001> edwardk: yeah I got that
16:46:40 <aegis__> even if it will never terminate
16:46:44 <edwardk> aegis__: sure.
16:47:01 <edwardk> aegis__: it is 'logically' uninhabited, but viewed as a logic, haskell is degenerate
16:47:08 <arkeet> :t fix id
16:47:08 <edwardk> we pretend its total a lot of the time though
16:47:08 <lambdabot> a
16:47:12 <edwardk> :t fix
16:47:12 <tel> aegis__: or absurd (fix Void)… which almost reads as a warning
16:47:12 <lambdabot> (a -> a) -> a
16:47:22 <edwardk> fix is a 'logical' fallacy. it is 'assuming the hypothesis'
16:47:36 <S11001001> edwardk: I assume that foldMapOf folded will deliver the same tree of <>s and memptys as foldMap?
16:47:51 <edwardk> so from a logic perspective loop = loop is where your code went wrong, after that ex falso quodlibet. you can prove anything
16:48:05 <edwardk> S11001001: either as foldMap or possibly traverse, they may differ
16:48:08 <edwardk> i don't remember which
16:48:12 <aegis__> edwardk: just to know, how many years of experience do you have in haskell/FP?
16:48:14 <quchen> jmcarthur: Im un-understanding in circles here. So what I understand is that it is an "emptiness check" that allows you to ask your (traversable) structure whether there's any information beyond structural one in it.
16:48:15 <edwardk> i think its the foldMap tre
16:48:17 <jmcarthur> (a -> a) -> a     =>  "for any A, if you can prove 'if A then A', i can prove A"
16:48:24 <edwardk> aegis__: ~6-7
16:48:27 <jmcarthur> quchen: yes.
16:48:45 <erisco> when we talk about the "spine of a list" we're talking about our non-strictness on the elements of that list?
16:48:54 <jmcarthur> quchen: if it gives you Nothing, then there were values contained within. if it gives you Just, there were not, and now you have a copy of the structure with a less restricted type
16:49:21 <lispy> erisco: yeah, like you can use length on a list of undefineds
16:49:25 <Peaker> erisco, we're talking about the list structure, the (:)'s, without the a's
16:49:30 <quchen> jmcarthur: Ah, I see, and then you specialize the 'b' to Void to make it explicit if you want
16:49:32 <lispy> erisco: length is spine strict but not element strict
16:49:36 <jmcarthur> quchen: exactly
16:49:48 <edwardk> :t join Data.Bitraversable.bitraverse
16:49:49 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable t) => (a -> f c) -> t a a -> f (t c c)
16:49:52 <edwardk> :t both
16:49:52 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
16:49:58 <lispy> erisco: the spine itself is the conses
16:50:02 <edwardk> > ("hello","world")^..join Data.Bitraversable.bitraverse
16:50:03 <lambdabot>   Not in scope: `Data.Bitraversable.bitraverse'
16:50:11 <erisco> does the spine include []?
16:50:15 <edwardk> @let import Data.Bitraversable
16:50:16 <lambdabot>  <no location info>:
16:50:16 <lambdabot>      The package (tagged-0.6.1) is required to be truste...
16:50:17 <S11001001> edwardk: looks like foldr
16:50:20 <edwardk> > ("hello","world")^..join bitraverse
16:50:21 <lambdabot>   Not in scope: `bitraverse'
16:50:21 <lambdabot>  Perhaps you meant one of these:
16:50:21 <lambdabot>    `itraverse' ...
16:50:35 <edwardk> shucks
16:50:35 <lispy> erisco: to me it would
16:50:40 <edwardk> it is using an old tagged
16:50:40 <erisco> I'm trying to explain what my 'inf' function does in English words
16:50:49 <edwardk> so Bitraversable won't work on lambdabot
16:50:59 <erisco> this function: http://lpaste.net/92178
16:51:39 <edwardk> aegis__, S11001001 : getting eaten alive by bugs out here. i'll be back in a bit.
16:51:53 <erisco> so I am saying something like... "inf increases the laziness of a function's strictness on the spine of a list"
16:51:59 <erisco> but that sounds kind of nonsensical
16:52:12 <lispy> all it does is delays the pattern match on the cons
16:52:16 <lispy> it will still have to happen
16:52:26 <lispy> and what does inf [] do?
16:52:42 <lispy> > let inf ~(x:xs) = x : inf xs in inf []
16:52:43 <lambdabot>   [*Exception: <interactive>:3:5-28: Irrefutable pattern failed for pattern (...
16:53:12 <lispy> > let inf ~(x:xs) = x : inf xs in inf [1,2,3]
16:53:13 <lambdabot>   [1,2,3,*Exception: <interactive>:3:5-28: Irrefutable pattern failed for pat...
16:53:24 <tel> lispy: inf only matches infinite lists
16:53:27 <quchen> jmcarthur: Alright, back to use cases. (Tell me when it gets annoying :-\ )  Earlier you said "you can coerce it to Void and use absurd as you interpret the result". So suppose you've got a function that produces a `Just <Container full of Void>`, you could then do something like `Just x -> absurd x` and you would ensure on type level that branch is never called?
16:53:46 <jmcarthur> yup
16:54:07 <erisco> tel, well, sort of ... it is guaranteeing the list is infinite
16:54:15 <erisco> which can lead to some interesting compile time optimisations
16:54:24 <erisco> length . take 5 . inf $ undefined
16:54:26 <erisco> for example
16:54:37 <quchen> jmcarthur: Pretty confusing for such an easy type. Or not being very used to Void.
16:54:40 <jmcarthur> quchen: so in the case of evaluating an AST, that means that whenever you encounter a variable node you can just use absurd instead of getting hung up, since you have already proven there are no free variables
16:55:27 <quchen> jmcarthur: Ah, so you have an AST that may contain values of type 'a', but you want to prove that this specific one you just generated does not have the corresponding fields in use.
16:55:37 <jmcarthur> yup
16:55:45 <erisco> I don't use it for that behaviour though, I rather use it to relax other functions which are trying to determine if the list is empty or not
16:55:49 <jmcarthur> maybe not one i just generated
16:55:58 <jmcarthur> if i just generated it then it probably has the right type already
16:56:05 <jmcarthur> :t Right 5
16:56:06 <lambdabot> Num b => Either a b
16:56:06 <erisco> because in recursive definitions, that can lead to a dependency cycle ... so 'inf' just helps the compiler along
16:56:12 <jmcarthur> ^^ a is unrestricted
16:56:27 <tel> erisco nice
16:56:41 <quchen> jmcarthur: For example if you have "data Foo a = Single | Multiple a" and your parser creates a list of "Single". Successive transformations may create 'Multiple' fields, but for the parser you could 'void out' the 'Multiple' branch.
16:56:49 <aegis__> jmcarthur: so "3*3" would be an expression of type Exp Void, i.e.
16:56:52 <quchen> Well that was just Maybe with different names there
16:57:25 <lispy> let inf ys = let ~(x:xs) = ys in x : inf xs
16:58:18 <quchen> jmcarthur: Thanks for your patience by the way :-)
16:58:29 <jmcarthur> oh it's fine. ^_^
16:58:34 <jmcarthur> i do have to go be productive soon though
16:59:27 <tel> erisco how does it differ from foldr (:) undefined
17:00:19 <aegis__> jmcarthur: +1 quchen, it's awesome to have people who take the time to explain; http://tinyurl.com/pwgn9of
17:00:25 <erisco> @src foldr
17:00:26 <lambdabot> foldr f z []     = z
17:00:26 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:00:54 <quchen> Oh, what happened to LPaste, my eyes don't hurt!
17:01:51 <erisco> tel, not sure why you think they are. can you explain?
17:02:15 <nh2> when will we get back hpaste links?
17:02:32 <elliott> we won't. but we have lpaste links
17:02:40 <erisco> tel, foldr is such a function that is checking if the list is empty or not
17:02:42 <jmcarthur> <3 cake
17:02:52 <erisco> > length . take 5 . foldr (:) undefined $ undefined
17:02:53 <lambdabot>   *Exception: Prelude.undefined
17:03:08 <erisco> > let inf ~(x:xs) = x : inf xs
17:03:09 <lambdabot>   not an expression: `let inf ~(x:xs) = x : inf xs'
17:03:21 <erisco> > let inf ~(x:xs) = x : inf xs in length . take 5 . inf $ undefined
17:03:22 <lambdabot>   5
17:04:09 <erisco> 'inf' is basically throwing all the "is this list empty" checks out the window
17:04:17 <tel> erisco yeah, sorry I managed to completely miss the point, ha
17:04:38 <nh2> elliott: why are hpaste links not forwarded to lpaste?
17:04:48 <quchen> nh2: The domain is lost.
17:04:59 <nh2> quchen: seriously?
17:05:04 <quchen> nh2: Yes.
17:05:14 <Clint> for some untold reason
17:05:15 <nh2> how did that happen?
17:05:21 <quchen> nh2: Owner doesn't respond, it points to nirvana right now.
17:06:08 <erisco> tel, and this does have practical application when you have something like   let foo = f x foo   and 'f' is trying to determine if its right arg is empty or not
17:06:11 <nh2> quchen: whois says that bos is the owner
17:06:28 <quchen> nh2: Yes.
17:06:34 <elliott> I think "patience got exhausted" isn't quite the same as "lost".
17:06:38 <Peaker> Data.Functor.Identity is an especially silly module name
17:06:43 <quchen> elliott: "For all practical purposes"
17:06:51 <erisco> tel, let foo = f x (inf foo)  will discard the "is empty" check
17:06:55 <Peaker> "Naming all those types after the Monad type-class was silly, so let's be both silly and non-uniform!"
17:07:04 <elliott> I refuse to subscribe to the idea that it is impossible to get a response from bos about a domain he owns.
17:07:22 <nh2> elliott: yes
17:07:31 <Peaker> elliott, I've got a pull request for bos's aeson rotting away for a long time
17:07:58 <Clint> he was on irc earlier
17:08:05 <elliott> preflex: seen bos
17:08:06 <preflex>  bos was last seen on #ghc 3 days, 4 hours, 30 minutes and 42 seconds ago, saying: i should probably ask for git committer access.
17:08:23 <elliott> https://github.com/bos?tab=activity
17:08:33 <haasn> I want to use http://hackage.haskell.org/packages/archive/happstack-server/7.1.7.1/doc/html/Happstack-Server-SimpleHTTP.html#v:bindPort with an IPv6 socket
17:08:38 <elliott> https://twitter.com/bos31337
17:08:41 <tel> erisco I'm understanding your "increases the laziness" more completely now
17:08:54 <elliott> seriously, someone being busy and not responding to everything in a good amount of time is not the same as them being AWOL.
17:09:01 <haasn> there's simpleHTTPWithSocket which lets me pass my own Socket, but if I just naively listenOn, I get ‘Unsupported socket’
17:10:16 <quchen> elliott: "Hey guys don't have time" is pretty fast to type.
17:12:03 <elliott> ok, if you just want to complain about him, fine. I'm not saying it's ideal, I'm saying I understand being swamped and it's easy to forget about things. if people really want hpaste.org fixed, I am sure it can be done.
17:12:18 <erisco> be really nice if lpaste would evaluate your haskell
17:12:27 <erisco> but check out 'a' here: http://lpaste.net/92179
17:12:27 <elliott> I just don't understand ridiculous hyperbole that amounts to "bos is clearly somewhere in the Antarctic and hpaste.org will be frozen until the universe's days are over"
17:12:29 <ReinH> roconnor: basically my haskell experience for the past few months has been noticing an offhand comment by edwardk and then reading 4 blog posts and a paper to try to understand what he meant
17:12:52 <erisco> I can't explain the behaviour at all... does everyone get "aabacb" ?
17:13:04 <jmcarthur> elliott: i was under the impression that hpaste was actually lost
17:13:10 <Peaker> erisco, why the overlapping patterns there?
17:13:39 <erisco> Peaker, I wasn't sure how powerful the pattern matching system was. They aren't really overlapping per se
17:13:45 <jmcarthur> elliott: like there was some crazy confusion with that resulted in losing the domain name
17:13:51 <Peaker> erisco, why not? because of strictness?
17:13:53 <elliott> jmcarthur: as far as I know bos was contacted about it (over one medium, I think; email maybe?) once or twice and didn't respond within two weeks or so
17:14:06 <Peaker> erisco, the first pattern is a sub-case of the 2nd and 3rd
17:14:07 <erisco> Peaker, yes, _ [] and [] _ cover the case of [] [], but they also cover each other
17:14:18 <elliott> and then it was moved to paste.tryhaskell.org temporarily. then the haskell.org people didn't respond about paste.haskell.org within a few days or a week or something because the haskell.org server move was underway.
17:14:27 <elliott> so it moved again to lpaste.net and the other domain efforts were abandoned
17:14:37 <elliott> I think jumping from this to "hpaste.org is lost forever" is more than a little silly.
17:14:50 <elliott> but I don't think anyone relevant cares enough to actually get it pointing there again
17:14:55 <jmcarthur> elliott: i didn't even realize that bos had anything to do with the domain name
17:15:03 <erisco> Peaker, anyways it is beside the point
17:15:32 <roconnor> ReinH: :D
17:15:57 <ReinH> roconnor: which is why I now know what costate comonad coalgebras are
17:16:00 <roconnor> ReinH: edwardk and friends took lenses and traversals much farther than I even imagined possible.
17:16:20 <roconnor> ReinH: Quiz: what are the laws for a comonad coalgebra.
17:16:25 <ReinH> damn you
17:16:28 <ReinH> let's see
17:16:45 <erisco> Peaker, what I'm really interested in is why 'a' evaluates to what it does
17:16:53 <ReinH> one of them involves extend. And one of them involves duplicate.
17:17:05 <Peaker> erisco, Manually expand things?
17:17:12 <roconnor> ReinH: extract, not extend
17:17:48 <roconnor> ReinH: extract : w a -> a,  duplicate : w a -> w (w a), and a coalg has type a -> w a
17:17:49 <ReinH> well, extend extract = id is an obvious one
17:18:15 <johnw> extract . coalg = id
17:18:18 <roconnor> ReinH: that is a comonad law;  I want the two laws for a coalgebra for a comonad.
17:18:23 <ReinH> ah
17:18:31 <ReinH> let me put on my thinking pants
17:20:00 <johnw> hm.. maybe not
17:20:07 <tel> erisco: http://lpaste.net/92180
17:20:17 <johnw> i can't know what the action of coalg is
17:20:22 <roconnor> johnw: you have one of the laws.
17:20:31 <erisco> tel, you did this by hand? :o
17:20:44 <tel> erisco: hah, yes
17:20:58 <erisco> so diligent
17:21:24 <ReinH> roconnor: it wouldn't be duplicate = coalg.coalg?
17:21:29 <tel> erisco: I've never felt totally comfortable around lazy pattern matches, so it was worth the effort
17:21:40 <roconnor> ReinH: close; That doesn't quite typecheck.
17:21:49 <johnw> coalg . extract = id too?
17:22:01 <carter> elliott jmcarthur  bos is interacting with ghc Trac no, so in theory he *should* reply to emails
17:22:11 <quchen> fmap coalg . coalg?
17:22:20 <ReinH> roconnor: something something fmap
17:22:21 <erisco> ha that is so curious :)
17:22:21 <roconnor> johnw: that doesn't really type check
17:22:30 <roconnor> johnw: or it isn't really one of the laws
17:22:35 <roconnor> quchen: yep
17:22:48 <erisco> I was expecting it to be equivalent to http://lpaste.net/92181 but, surprise
17:22:50 <ReinH> yeah, makes sense
17:22:57 <quchen> roconnor: Good guess for not knowing at all what a costate comonad coalgebra is.
17:23:12 <quchen> roconnor: I know comonads, that's it. Heard of coalgebras.
17:23:18 <johnw> yeah, you can do a lot of with parametricity :)
17:23:20 <roconnor> quchen: this is general coalgebra for a comonad.
17:23:35 <ReinH> quchen: Beware of bugs in the above code: I have merely made it type check, not tried it.
17:23:43 <aegis__> is there any reason why haskell doesn't allow a wildcard in: "instance Foo (Maybe _) where ..."?
17:23:47 <quchen> And coalgebra is what? Just something with a "a -> f a" function?
17:24:01 <quchen> Laws? More functions?
17:24:04 <roconnor> quchen: yep; f needs to be a functor.
17:24:13 <roconnor> quchen: coalgebra for a comonad are a bit more specific.
17:24:16 <quchen> roconnor: Sounds like a pointed functor
17:24:47 <quchen> Is there some introductory blog post you could recommend here?
17:24:48 <roconnor> quchen: well, it is really A -> F A
17:24:50 <johnw> it comes with extra laws
17:25:06 <roconnor> quchen: so the A and F are specific, not polymorpic.
17:25:07 <ReinH> quchen: http://arxiv.org/pdf/1103.2841v2.pdf
17:26:01 <tel> ReinH roconnor That is one of my favorite papers—
17:26:09 <roconnor> :D
17:26:13 <ReinH> tel: confirm
17:26:21 <ReinH> I think I'm going to have to learn modal logic now
17:26:31 <roconnor> tel: too bad the ACM didn't publish it :D.
17:26:35 <ReinH> roconnor: :(
17:26:42 <quchen> ReinH: That looks way ahead of me. Like I said, I'd like to start with (co)algebra instead of biplate lenses ;-)
17:26:43 <tel> ReinH: confirm
17:26:45 <tel> ;)
17:27:00 <roconnor> the ACM and I couldn't come to an agreement on the terms of publication
17:27:04 <erisco> tel, ah it because I messed up in the definition, heh
17:27:32 <tel> roconnor: public domain is a bit much for them, yeah?
17:27:39 <roconnor> tel: thankfully, this means you can still read it for free.
17:28:00 <erisco> tel, when the left list is empty, I am supposed to return the right list, but instead I return empty list
17:28:24 <tel> erisco: oh! that's even easier than what I was tracking down
17:28:25 <erisco> tel, so I really meant this http://lpaste.net/92182
17:28:49 <erisco> and using  let a = alt "abc" (inf a) in a    works as expected
17:29:15 <aegis__> any good book on type theory to advice?
17:29:35 <tel> roconnor: I'm glad you fought for public domain. I am really constantly amazed by the FP literature I can access for free. It's jewel (pearl?) of the community.
17:30:30 <erisco> tel, see how http://lpaste.net/92181 becomes a needless, complicated definition when you can just have http://lpaste.net/92182 and inf? :)
17:30:42 <ReinH> Now I want to find some way to apply all this new knowledge to my chess engine and get Haskell Live back on track.
17:30:49 <ReinH> Something something game tree evaluation...
17:31:04 <haasn> How exactly am I supposed to get from a blaze-html's Html to a blaze-builder's Builder?
17:31:27 <quchen> ReinH: That paper has a pretty awesome explanation of Store!
17:31:35 <haasn> oh, I can search for type signatures on hayoo too
17:31:37 <quchen> ReinH: Not what you linked it for, but nice to see anyway :-)
17:31:40 <erisco> tel, I don't know if it completely supercedes it, but for my uses it does
17:31:51 <ReinH> quchen: yes, it is!
17:32:36 <tel> erisco: haha, it's a great demonstration of the principle in any case. "More lazier infinite lists".
17:34:05 <tac_> Does anyone have any idea why a call to simpleHTTP would fail to ever return?
17:34:07 <tel> erisco I wonder if there's an even cleverer way to write fibs lurking in there…
17:34:22 <roconnor> tac_: TCP timeout?
17:34:36 <erisco> tel, lurking in what? and more clever than the running tuple?
17:34:47 <roconnor> tac_: environment variable overriding the C run time library.
17:35:09 <roconnor> and replacing socket functions with infinite loops
17:35:17 <tac_> hmm
17:35:18 <tel> erisco: the extra laziness you get out of inf, and yeah
17:35:30 <roconnor> tac_: cosmic rays flipping kernel RAM bits.
17:35:38 <roconnor> tac_: you are draming.
17:35:44 <roconnor> *dreaming
17:35:58 <tac_> This is no dream
17:36:01 <tac_> this is a nightmare
17:36:46 <ReinH> tel: it has a similar but not identical structure to fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
17:37:04 <carter> tel! is that who i think it is?
17:37:21 <tel> carter: yes, you convinced me to check out this IRC thing :)
17:37:27 <carter> tel: you need it
17:37:38 <carter> people here are great for haskell style feedback
17:37:57 <carter> you write awesome code
17:38:05 <tac_> roconnor: *** Exception: user error (https not supported)
17:38:12 <carter> but its like having people say "but it could be even awesomer if you X"
17:38:21 <carter> :)
17:38:36 <roconnor> tac_: yeah, that's HTTP-4000 for you.
17:38:43 <tel> ReinH: that's my thought, but that fibs is already lazy enough—unlike erisco's alt
17:39:04 <tac_> WHY DIDN'T IT PRINT THE EXCEPTION???? T________T
17:39:05 <tac_> oh well
17:39:42 <tel> carter: haha, well I'm always trying to write awesomer code
17:39:49 <carter> yes,
17:40:04 <carter> and you need a feedback loop thats outside your own head or twitter :)
17:41:00 <erisco> carter, I've been conversing with a famous person?
17:41:06 <roconnor> ReinH: http://r6.ca/blog/20121209T182914Z.html  has a nice example of using traversal for a task that doesn't appear to have anything to do with traversing.
17:41:08 * erisco collapses in anxiety
17:41:15 <meretrix> tac_: I've found http-conduit to be quite nice.
17:41:30 <carter> erisco: nope, just one of those mythical "haskelling is my day job" people
17:41:40 <tel> erisco: —much closer to the opposite…!
17:41:55 <carter> yeah
17:42:05 <carter> i only know tel because he dmed via reddit once :)
17:43:27 <erisco> tel, ah well how fortunate for you :)
17:43:31 <roconnor> is tel famous?
17:43:46 <erisco> roconnor, word on the street says
17:43:49 <tac_> meretrix: the example I saw used http conduit, but I replaced it with the base package
17:43:50 <carter> only if you kep saying he is
17:43:53 <tac_> because I don't know what a conduit is
17:44:06 <carter> tac_ its a snoyman package
17:44:11 <carter> @hackage conduit
17:44:11 <lambdabot> http://hackage.haskell.org/package/conduit
17:44:43 <erisco> tel, is it a research type of position or more applied?
17:44:54 <tel> I'd like to keep this up if you don't mind, self-fufilling confusion over my fame..!
17:45:02 <tel> or lack thereof
17:45:03 <meretrix> tac_: You actually don't need to use the whole conduit framework (I don't).  I just use it to get a lazy bytestring response.
17:45:04 <carter> both
17:45:10 <carter> :P
17:45:26 <erisco> famous for not being famous
17:45:26 <carter> i have more twitter followers than tel, whtaever that means
17:45:36 <carter> thankfully, less than kmett
17:45:36 <tel> erisco: applied—I use it at a small healthcare company
17:45:37 <carter> :)
17:45:59 <carter> tel: am I still up to date on the approximate business?
17:46:04 <erisco> tel, great! I can say that I've spoken with living proof that Haskell is practical :D
17:46:31 <tel> carter approximately!
17:46:31 <carter> i thought kmett proved that when he wrote category-extras
17:46:40 <carter> :P
17:54:50 <lesur> @Hoogle infixr
17:54:50 <lambdabot> Maybe you meant: hoogle google
17:55:00 <lesur> @hoogle infixer
17:55:00 <lambdabot> No results found
17:55:21 <tac_> In Aeson, is there an easy way to grab a chained key? as in {a : {b : "stuff"}}
17:56:59 <tel> tac_: lens-aeson gives you "{a : {b : "stuff"}}" ^? _JSON . _Object . key "a" . _Object . key "b" . _String
17:57:19 <tac_> Ideally, I'd like to avoid lenses
17:57:22 <tac_> if that's possible
17:58:16 <ReinH> roconnor: oh nice
17:58:17 <tel> You can replicate that functionality with some functions (Value -> Maybe Object), (>=>), and Data.HashMap.lookup
17:59:43 <erisco> @pl \x y -> [x, y]
17:59:43 <lambdabot> (. return) . (:)
18:00:06 <tac_> @type (>=>)
18:00:07 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:00:29 <tel> tac_: it sequences your (a -> Maybe b) types together
18:00:56 <tel> tac_: so you'd get (unObj >=> lookup "a" >=> unObj >=> lookup "b")
18:01:05 <tel> for unObj :: Value -> Maybe Object
18:01:25 <edwardk> tac_: it is still possible to avoid lenses? crap i have to work harder.
18:01:36 <dabblego> "f . g" pronounced out loud: "compose f with g"?
18:01:52 <tac_> dabblego: I always read it "f over g".. some people say "f of g"
18:02:13 <tac_> edwardk: if they didn't lead to spaghetti code types, I might use them :)
18:02:18 <dabblego> tac_: yeah thanks, might go with that
18:02:25 <roconnor> dabblego: "eff composed with gee"
18:02:27 <erisco> edwardk, after providing examples, it is rather funny to see 30 lines of comment on a one liner :P
18:03:03 <erisco> is there any reason to insist that comments be put directly in the source files? *shrug*
18:03:46 <applicative> 'f after g'
18:04:01 <edwardk> erisco: well, it makes it a bit easier to keep things in sync. =)
18:04:16 <pxqr``> which flag suppress 'defined but not used' warning?
18:05:08 <tel> pxqr``: -fno-warn-unused-binds?
18:05:25 <roconnor> tac_: lenses are designed to deal with the chained key problem.
18:05:45 <pxqr``> tel: yep, thanks
18:06:35 <pxqr``> sometimes we use record selectors in derived instances only; but I still love -Wall
18:08:49 <pxqr``> for example: data Foo = FOo { unFoo :: Int } deriving (Show, Generic); though I think ghc shouldn't warn about unused unFoo in this case
18:15:12 <heatsink> edwardk, what's the Barendregt Convention mentioned in your FPComplete article on bound variables?
18:15:32 <edwardk> Give every variable a globally unique name
18:15:39 <heatsink> Oh, that's simple
18:15:43 <edwardk> Yep
18:16:35 <heatsink> I thought that, in the inlining paper, they enforced a weaker no-shadowing rule
18:16:53 <heatsink> that would allow, for instance, f (\x -> x) (\x -> x) where both xes are the same variable
18:17:08 <edwardk> They do.
18:17:19 <edwardk> But that's just a weaker form of the convention
18:17:24 <joelteon> How do I test greater-than/less-than versions of GHC with CPP?
18:17:29 <heatsink> ok
18:17:33 <edwardk> You don't have to worry about shadowing a nested binder
18:17:42 <edwardk> That's the power of barendegt
18:17:53 <edwardk> The price is you screw up occasionally
18:17:55 <heatsink> What's a nested binder?
18:18:20 <edwardk> \x -> \y -> z.
18:18:24 <heatsink> Okay
18:18:39 <edwardk> \ x -> is a binder. It captures x
18:19:03 <edwardk> Forall works like another binder at the type level
18:19:11 <heatsink> yeah
18:19:39 <elliott> edwardk: are you on a phone? :)
18:19:39 <edwardk> In another language exists might be a third
18:19:43 <edwardk> Yes
18:19:57 <edwardk> iPad actually
18:20:23 <erisco> with ghci... when you have imported the 5th module or so, your prompt line is ridiculously long
18:20:30 <edwardk> The fact that it is capitalizing and autocorrecting give it away?
18:20:34 <erisco> how can you hide the imported modules?
18:20:50 <erisco> Control.Applicative Data.Functor Data.List Control.Monad.Instances >
18:20:52 <elliott> I was suspicious from the capitalisation, but then "Forall" happened :p
18:20:52 <erisco> it is a bit much
18:20:53 <heatsink> Okay, I can read more of the article now
18:20:59 <dmj`> erisco: :set prompt ">>= "
18:21:04 <elliott> you should append "Sent from my iPad" to every message.
18:21:10 <heatsink> hah
18:21:19 <edwardk> Hah
18:21:25 <erisco> dmj`, thank-you so much
18:21:25 <Targen> dmj`: That could be confusing :)
18:21:36 <FreeFull> Sent from my jPad
18:21:37 <erisco> dmj`, this has been bugging me all summer
18:21:47 <dmj`> Targen: haha yea I guess :)
18:21:49 <FreeFull> > map succ "iPad"
18:21:50 <lambdabot>   "jQbe"
18:22:03 <edwardk> Clearly what I should do is what Siri transcribe all my messages
18:22:04 <FreeFull> Sent from my jQbe :)
18:22:07 <dmj`> erisco: there's that and also ":m " which will remove all
18:22:11 <edwardk> That worked
18:22:23 <edwardk> Er let I guess
18:24:19 <Targen> Speaking of which... is it possible to change the GHCi multiline prompt text?
18:24:26 <geekosaur> hPad clearly
18:24:36 <edwardk> heatsink: Let me know if you have any questions
18:25:22 <dmj`> erisco: echo ":set prompt >>= " >> ~/.ghci
18:25:43 <krezy> hi there
18:25:51 <heatsink> kay, thanks edwardk
18:27:32 <edwardk> I am trying to figure out how to start an article series on succinct data structures to shame me into finishing analytics
18:29:25 <tragalo> ahh it's a wonderful day
18:29:44 <elliott> eh. I give today about 7/10
18:29:53 <elliott> maybe 6/10.
18:30:09 <ion> I give today about 2/10
18:31:05 <dmj`> 4.5/10
18:31:15 <krezy> weather wise: 8/10 here
18:31:26 * hackagebot haspell 1.1.0 - Haskell bindings to aspell  http://hackage.haskell.org/package/haspell-1.1.0 (JoelTaylor)
18:31:37 <edwardk> So once we throw out the score from the Scandinavian judge it's an average day
18:32:07 <elliott> I can't imagine it ever goes much above 4/10 in Finland
18:32:10 <ion> It *is* an average day.
18:32:11 <edwardk> Silly outliers
18:32:41 <edwardk> What seems like that then falsely inflates your scores
18:33:01 <ion> It’s 10.8 °C outside.
18:33:04 <Targen> 9/10.  It rained for a bit, but that gave us a rainbow.  You can’t beat the tropic.
18:33:06 <tel> erisco: you can also do 'import Yada.Yada.Yada as Y' to keep the names shorter.
18:34:12 <edwardk> I envision Ion's scale as a backwards version of http://hyperboleandahalf.blogspot.com/2010/02/boyfriend-doesnt-have-ebola-probably.html
18:34:38 <ion> hah
18:35:41 <edwardk> The pain is so bad it drove him to master git
18:39:10 <heatsink> Inlining structurally-recursive functions only if their argument is a statically known constructor term prevents code size blowup.  Yay.
18:41:26 * hackagebot WordNet 1.1.0 - Haskell interface to the WordNet database  http://hackage.haskell.org/package/WordNet-1.1.0 (JoelTaylor)
19:13:36 <tac> In GHC with default settings, can you use unicode in strings?
19:13:56 <byorgey> yes.
19:14:12 <johnw> tac: make sure to encode your source file as UTF-8
19:14:20 <edwardk> johnw: ping
19:14:23 <edwardk> oh, hi
19:14:26 <johnw> hi!
19:14:56 <edwardk> johnw: chad scherrer has an apparently dead mathml rendering example on the school of haskell. is it supposed to work?
19:15:10 <edwardk> i was trying to render n choose k in mathml on the site
19:15:17 <johnw> i'm not sure whether we support mathml, let me check
19:15:40 <johnw> I don't think so
19:15:41 <edwardk> the alternative is i waste a bunch of time carving up tiny tex style images
19:15:51 <edwardk> i didn't think so either, but then i found https://www.fpcomplete.com/user/chad/mathml
19:15:58 <johnw> I requested MathJax support a while back, but it's not on the active worklist
19:15:59 <edwardk> which seems to advertise it as a featre
19:16:04 <edwardk> er feature
19:16:28 <johnw> hmm
19:16:30 <johnw> it sure does, doesn't it
19:16:44 <edwardk> and at last check he was one of you =P
19:16:57 <byorgey> MathJax is nice, in my experience
19:17:01 <byorgey> and very easy to set up
19:17:33 <edwardk> i wasn't looking to push yet another task onto the queue, just trying to see if it was me or the site that wasn't doing what it should be
19:17:52 <johnw> it could very well be that that support fell by the wayside at some point
19:18:03 <johnw> it's worth re-raising as an issue for the next version
19:18:06 <tac> ack... how do you put a unicode char point into a string?
19:18:10 <johnw> it's actually on our "wish list" at the moment
19:18:11 <edwardk> fair enough
19:18:25 <tac> like... "\x0000"? Or maybe \u....
19:18:34 <johnw> you know, by far the best way to get stuff on our wish list done is to come work for us and do them :):)
19:18:46 <shachaf> \0 for base 10 or \x0 for base 16.
19:18:59 <edwardk> =P
19:19:07 <Fuuzetsu> johnw: I didn't know you worked part time for marketing department.
19:19:23 <johnw> Fuuzetsu: I have a special dispensation where edwardk is concerned
19:19:37 <Fuuzetsu> One day you might just make it.
19:19:46 <johnw> i'm playing for the long game
19:20:35 <magicman> That one example page... works? There's a rendered equation right under the source listing, at least in my browser.
19:22:50 <edwardk> magicman: it may be that i'm on chrome. let me try some other browser
19:23:17 <elliott> presumably it "supports" MathML by just letting you use the markup
19:23:18 <edwardk> aha that is it
19:23:20 <elliott> rather than actually rendering it or anything
19:23:27 <edwardk> chrome was just ignoring the mathml noise
19:23:28 <elliott> which is useless because nobody supports MathML very well, afaik.
19:23:45 <magicman> Broken in my chrome, works fine in my Opera.
19:24:08 <magicman> Can't be bothered to check other browsers >_>
19:24:24 <edwardk> works in firefox
19:24:38 <edwardk> ok. i'll table it then and just render the ugly images
19:25:17 <edwardk> johnw: bug report: there doesn't seem to be a way to escape the `'s inside `n `choose` k`
19:25:43 <elliott> edwardk: ``n `choose` k``
19:25:49 <elliott> if it's markdown
19:26:57 <edwardk> that doesn't seem to work with snoyman's parser
19:27:32 <edwardk> double quoting the outside leads to what renders like: `n` choose `k`
19:27:48 <edwardk> whereas i was looking for @n `choose` k@ in haddock speak
19:28:04 <edwardk> to keep it an approximation of valid haskell and valid math
19:29:35 <elliott> the parser is broken then :P
19:30:42 <edwardk> elliott: hence 'bug report' =)
19:34:29 <johnw> edwardk: I'd log a bug against snoyberg/markdown
19:39:24 <jfischoff> Why is ghc Generics not patterned after Multirec?
19:41:20 <edwardk> johnw: issue submitted https://github.com/snoyberg/markdown/issues/16
19:42:06 <johnw> thanks!
19:42:18 <edwardk> jfischoff: probably because both are written in such a way to be all but inscrutable to the outsider
19:42:29 <edwardk> jfischoff: so neither group can read each other's code ;)
19:42:40 <jfischoff> heh I guess so
19:43:06 <jfischoff> You can use them as libraries so it doesn't really matter I guess
19:43:09 <edwardk> writing ghc generics code is an exercise in guess work and compiler diving because you can't 'see' the instances it spits out for anything
19:43:31 <danharaj> I had to debug generics code as my first task at work.
19:43:32 <jfischoff> is there the kind!
19:43:42 <danharaj> The bugs that bit me still traumatize me to this day.
19:43:56 <jfischoff> or is it !kind
19:43:58 <edwardk> danharaj: heh it took me days to figure out how to get tinplate to work in lens
19:44:52 <edwardk> danharaj: http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/src/Generics-Deriving-Lens.html i still barely remember why i have to carry the boolean recursion flag through to stop infinite looping at the bottom
19:45:45 <jfischoff> edwardk: try :kind! Rep Foo
19:45:47 <edwardk> i _think_ the first K1 it encounters is a constructure and the other is something else
19:46:20 <edwardk> that would have helped a lot a year ago
19:46:59 <danharaj> edwardk: we came to the conclusion at work that TH is more robust… when GHC releases aren't breaking it.
19:47:32 <edwardk> i'm using ghc.generics as a poor man's data.data in ghc.generics.lens, and we have data.data.lens for when that is more appropriate
19:48:06 <edwardk> at some point i'd like to have the hit-map machinery ported from data.data.lens to ghc.generics.lens but my last attempt made me want to stop and do other things
19:48:19 <carter> i don't even understan this conversation
19:48:40 <carter> admittedly, i tend to write much less generic code than, say, lens
19:49:08 <jfischoff> I consider Generics strictly better, but if I need to anything other the recurse through a bunch of :*: I do something else
19:49:53 <edwardk> ghc.generics gives you the ability to convert your type into a functor-like representation that looks like: Rep (Int,Int) :: * -> * = M1 D GHC.Generics.D1(,) (M1 C GHC.Generics.C1_0(,) (M1 S NoSelector (K1 R Int) :*: M1 S NoSelector (K1 R Int)))
19:50:08 <joelteon> ooh that's intuitive
19:50:21 <edwardk> that lets you introspect on constructor names, sums, products, etc. all the way down, its useful information, but it it damn opaque
19:51:37 <edwardk> Rep Double :: * -> * = M1 D GHC.Generics.D_Double (M1 C GHC.Generics.C_Double (M1 S NoSelector (K1 R Double)))  -- is perhaps less eyebleeding as you don't have to parse the magic (,)'s in there
19:52:19 <danharaj> The generics stuff could make use of DataKinds
19:52:41 <edwardk> M1 D annotates it with the data type, D_Double can be reflected to get information about that, C annotates it with the constructor, etc. M1 S annotates it with the fact that the field of the double has no selector
19:52:57 <edwardk> then it stores a double
19:53:36 <jfischoff> the advantage is you using recursion with type classes instead of TH … if you consider that an advantage :)
19:53:43 <edwardk> the issue is the way they built this, M1 D Foo rather than M1D Foo makes it easy to skip past what you don't want, but hard to know what you didn't handle, and hard to write non-flexible instances
19:54:53 <jfischoff> its pretty much a type class extension field day once you get going.
19:54:58 <edwardk> it is still information you can't really get any other way, so its better than nothing
19:55:16 <edwardk> so long as you only have to deal with non-polymorphically recursive 0 or 1 parameter data types
19:55:38 <jfischoff> which is why multirec is better
19:55:46 <edwardk> probably
19:55:57 <edwardk> i try to avoid generic programming frameworks
19:56:17 <edwardk> Data.Data and GHC.Generics coming bundled with GHC gives me a reason to give some baseline support
19:56:38 <lispy> edwardk: I feel like that comment about generic programming should be @remember'd :)
19:57:42 <jfischoff> edwardk: what's the alternative?
19:58:13 <jfischoff> TH?
19:58:20 <elliott> typing fast
19:58:26 <jfischoff> haha
19:58:47 <edwardk> lispy: about avoiding them?
19:58:56 <edwardk> lispy: i don't consider lens a generic programming framework per se.
19:59:05 <edwardk> it has 2-3 inside it
19:59:06 * lispy nods
19:59:13 <edwardk> but it isn't really a generic programming library =)
19:59:16 <lispy> generic generic programming?
19:59:28 <edwardk> its a generic generic programming library wrapper yeah =)
19:59:45 <edwardk> :t Data.Data.Lens.tinplate
19:59:46 <lambdabot> (Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
19:59:54 <edwardk> :t GHC.Generics.Lens.tinplate
19:59:55 <lambdabot> (Typeable b, Applicative f, GHC.Generics.Generic a, Generics.Deriving.Lens.GTraversal (GHC.Generics.Rep a)) => (b -> f b) -> a -> f a
20:00:26 <edwardk> clearly someone needs to write the equivalent using MultiRec
20:00:26 <edwardk> :t Data.Data.Lens.gtraverse
20:00:28 <lambdabot> (Data a, Applicative f) => (forall d. Data d => d -> f d) -> a -> f a
20:00:44 <edwardk> too bad that last one isn't quite a lens
20:00:49 <edwardk> er traversal
20:01:12 <shachaf> Is it going into HEAD?
20:01:20 <edwardk> gtraverse?
20:01:29 <shachaf> Yes.
20:01:30 <edwardk> probably. i suppose we need a patch
20:01:35 <edwardk> nobody is against it
20:01:57 <jfischoff> edwardk: Typeable? Shouldn't that be HElem b a => …
20:02:28 <jfischoff> well different than that, but where is type level list of types :)
20:07:50 <edwardk> jfischoff for the Generics one?
20:07:57 <jfischoff> yeah
20:08:04 <edwardk> jfischoff: this Typeable version doesn't require overlapping and incoherent instances
20:08:46 <jfischoff> then we are not truly Olegging
20:08:52 <edwardk> correct
20:09:02 <edwardk> i want users to be able to use the code, not just marvel at it ;)
20:09:18 <jfischoff> you've sold out man
20:09:22 <jfischoff> :)
20:09:25 <edwardk> yep
20:09:31 <edwardk> i'm part of the system
20:09:45 <edwardk> i'm just another control
20:10:25 <johnw> edwardk stands with one foot here, and one foot in the Olegverse
20:10:37 <jfischoff> daywalker
20:12:18 <edwardk> johnw: I'm going for a role more like the 'Old One' out of a Fire Upon the Deep, rather than grunting at Ryan Reynolds' jokes like a pre-meltdown Wesley Snipes.
20:13:31 <edwardk> too bad we renamed uponTheDeep
20:13:38 <edwardk> i miss that combinator
20:14:35 <edwardk> > "hello & upon head .~ 'j'
20:14:36 <lambdabot>   <hint>:1:26:
20:14:36 <lambdabot>      lexical error in string/character literal at end of input
20:14:44 <edwardk> > "hello" & upon head .~ 'j'
20:14:45 <lambdabot>   "jello"
20:14:52 <scshunt> edwardk: uponTheDeep?
20:15:37 <edwardk> scshunt: upon used to only go one "level" deep, searching for the solution, so we added uponTheDeep. we since recanted and made uponTheDeep into upon, and renamed the old upon onceUpon.
20:15:49 <scshunt> haha
20:16:12 <edwardk> notice we handed upon a selector function, and it seemed to run it backwards looking for where to make the change
20:16:12 <scshunt> sigh, hoogle, work better
20:16:38 <edwardk> > ("hello",12) & upon snd .~ 34
20:16:39 <lambdabot>   ("hello",34)
20:16:43 <johnw> > Left 10 & upon Left .~ 20
20:16:45 <lambdabot>   Could not deduce (GHC.Num.Num
20:16:45 <lambdabot>                      (Data.Either.Either (Dat...
20:17:00 <johnw> oh, of course that wouldn't work
20:17:02 <edwardk> it need to know the full type.
20:17:14 <johnw> > Left 10 & upon (\Left x-> x) .~ 20
20:17:15 <lambdabot>   Constructor `Data.Either.Left' should have 1 argument, but has been given n...
20:17:16 <edwardk> > (Left 10 :: Either Int ()) & upon Left .~ 20
20:17:17 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable b0)
20:17:17 <lambdabot>    arising from a use ...
20:17:21 <johnw> > Left 10 & upon (\(Left x)-> x) .~ 20
20:17:23 <lambdabot>   Left 20
20:17:28 <edwardk> there
20:17:38 <scshunt> whoa, that's deep magic
20:17:50 <edwardk> scshunt: sclv had the idea
20:17:53 <elliott> > Right 123 & upon (
20:17:54 <lambdabot>   <hint>:1:19:
20:17:54 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
20:17:55 <edwardk> it cheats its ass off
20:17:58 <elliott> > Right 123 & upon (\(Left x) -> x) .~ 20
20:18:00 <lambdabot>   Right 123
20:18:07 <elliott> that has no right to work. disgusting.
20:18:11 <elliott> > Right 123 & upon (\~(Left x) -> x) .~ 20
20:18:12 <lambdabot>   <hint>:1:30: parse error on input `->'
20:18:13 <edwardk> elliott: hahahahahaha
20:18:14 <scshunt> elliott: agreed
20:18:16 <elliott> > Right 123 & upon (\ ~(Left x) -> x) .~ 20
20:18:17 <lambdabot>   Right 123
20:18:22 <elliott> > Left 123 & upon (\ ~(Left x) -> x) .~ 20
20:18:23 <lambdabot>   Left 20
20:18:27 <elliott> ugh.
20:18:32 <elliott> remember when Control.Lens exported upon?
20:18:40 <edwardk> yep. it was glorious
20:18:59 <elliott> I think you actually thought it was useful and a good idea for a few days.
20:19:15 <edwardk> i thought it was hilarious. not a good idea
20:19:51 <elliott> it's normal for people not to remember fevers like that.
20:19:52 <edwardk> scshunt: it works by replacing parts of your structure with exceptions and figuring out which ones fire
20:20:21 <edwardk> scshunt: then it drills in and tries placing another layer of exceptions until it finds out the last thing you touched
20:20:57 <edwardk> scshunt: then it replaces that with the real value you set
20:21:03 <scshunt> edwardk: that...
20:21:06 <shachaf> Oh, it doesn't anymore?
20:21:11 <shachaf> Ah, but Data.Data.Lens still exports it.
20:21:26 <scshunt> edwardk: I'm not sure if that is beautiful or disgusting
20:21:28 * shachaf also misses uponTheDeep.
20:21:30 <elliott> what I like is that upon isn't even the most fucked up version.
20:21:31 <edwardk> scshunt: if you do anything clever like inspect multiple values and pick one, it'll likely replace the first one that gets touched
20:21:34 <jfischoff> what no unsafeCoerce? No wonder it isn't exported ;)
20:22:06 <scshunt> edwardk: why a Traversal and not a Lens?
20:22:12 <edwardk> :t upon
20:22:21 <edwardk> :t Data.Data.Lens.upon
20:22:22 <lambdabot> (Data s, Data a, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
20:22:26 <shachaf> Because it might not exist.
20:22:35 <edwardk> what happens if that function looks at nothing in s?
20:22:39 <scshunt> ah
20:22:44 <scshunt> clearly we need another version
20:22:52 <scshunt> which will find every valid instance in the structure
20:22:55 <scshunt> and replace them
20:23:07 <scshunt> or more generally traverse them
20:23:09 <edwardk> i played with it
20:23:13 <edwardk> it was expensive
20:23:37 <scshunt> that's ok, isn't the point to be hilarious, not fast?
20:23:46 <elliott> wait, did it get removed?
20:23:47 <elliott> :t deepUpon
20:23:48 <lambdabot> Not in scope: `deepUpon'
20:24:03 <shachaf> upon is now what used to be called uponTheDeep
20:24:08 <shachaf> And onceUpon is what used to be called upon
20:24:23 <scshunt> edwardk: suggest calling it uponYeAll, and add aPox = (&)
20:25:03 <edwardk> shachaf: you saw the generalization of both that is happening, right?
20:25:20 <elliott> edwardk: he promised not to murder anyone, remember?
20:25:23 <edwardk> :t join Data.Bitraversable.bitraverse
20:25:26 <edwardk> did he?
20:25:27 <edwardk> good
20:25:29 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable t) => (a -> f c) -> t a a -> f (t c c)
20:25:31 <shachaf> Yep -- I think I mentioned in -lens.
20:25:37 <scshunt> actually no, just pox
20:25:39 <shachaf> elliott: Let's not get carried away here.
20:25:40 <edwardk> ah i probably bopped out right before then
20:25:46 <shachaf> elliott: I promised not to murder arkeet.
20:25:55 <edwardk> ah
20:26:04 <scshunt> clearLasts a = a `pox` uponYeAll last .~ 0
20:26:05 <edwardk> i think he's saying i signed my death warrant
20:26:27 <edwardk> he'll send iggy to my place with a baseball bat
20:31:28 <jfischoff> edwardk: does tables support foreign keys? I can't really tell ?
20:31:41 <edwardk> not really
20:31:56 <jfischoff> ok
20:31:58 <edwardk> tables doesn't really  have any notion of multiple tables
20:32:03 <edwardk> its more like 'table'
20:32:10 <jfischoff> aye
20:32:33 <johnw> only domestic keys
20:33:06 <djahandarie> Strict immigration policy
20:46:16 <Ghoul_> :t Addr
20:46:17 <lambdabot> Not in scope: data constructor `Addr'
20:50:46 <Ghoul_> hayoo is down
20:51:09 <Ghoul_> nevermind, it tricked me.
20:54:01 <erisco> well shoot tel
20:56:53 <erisco> there is an issue with "inheriting" inf... if a recursive function in turn makes a call to another function, that underlying function can ruin everything by having a strict pattern match
20:57:24 <Heather> Hello
20:57:28 <Heather> How to move directory?
20:57:51 <MedDev> wrong channel?
20:58:54 <Heather> MedDev why?
20:59:10 <jfischoff> @hoogle moveDirectory
20:59:10 <lambdabot> System.Posix.Directory removeDirectory :: FilePath -> IO ()
20:59:10 <lambdabot> System.Directory removeDirectory :: FilePath -> IO ()
20:59:10 <lambdabot> System.Posix.Directory.ByteString removeDirectory :: RawFilePath -> IO ()
20:59:23 <jfischoff> @hoogle renameDirectory
20:59:23 <lambdabot> System.Directory renameDirectory :: FilePath -> FilePath -> IO ()
20:59:55 <MedDev> ah, i thought you meant on the OS level lol pardon me Heather :)
20:59:59 <Heather> jfischoff will rename move it to different location?...
21:00:02 <johnw> to move it to another filesystem, you will have to copy and then remove it recursively from the old filesystem
21:00:22 <johnw> but within the same filesystem, renameDirectory will do what you expect
21:00:31 <jfischoff> Heather: ^
21:00:42 <Heather> I see, thank you, will try
21:03:39 <heatsink> I can run a shell command and get the contents of stdout and stderr, but the output can be very large.  Is there a way to run a shell command and get the last 1 kiB of stdout and stderr?
21:05:27 <johnw> you could use process-conduit
21:05:46 <johnw> and then keep a 1 KB bounded cache queue
21:06:00 <johnw> and just keep filling it.  when you reach the end, you have your last 1K left, in constant space
21:08:29 <heatsink> I've seen conduits before in Yesod
21:08:37 <Ghoul_> :t fix
21:08:38 <lambdabot> (a -> a) -> a
21:08:57 <heatsink> Things with more than three type parameters are a little bit scary.
21:08:58 <jfischoff> is there a Haskell AST for MySQL SQL anywhere?
21:09:01 <luite> edwardk: http://hdiff.luite.com/ghcjs/automaton/
21:09:40 <edwardk> luite++
21:09:49 <Ghoul_> how can I pass a parameter to a thing I put through fix?
21:09:55 <heatsink> Thanks, johnw
21:10:25 <Ghoul_> Nevermind, I might just roll my own loop
21:10:39 <edwardk> heatsink: bah
21:10:40 <heatsink> Ghoul, give the thing more parameters
21:10:48 <edwardk> :t Control.Lens.beside
21:10:48 <lambdabot> (Applicative (Data.Profunctor.Rep.Rep q), Applicative f, Data.Profunctor.Rep.Representable q) => Overloading p q f s t a b -> Overloading p q f s' t' a b -> Overloading p q f (s, s') (t, t') a
21:10:48 <lambdabot> b
21:11:03 <heatsink> That's why you're the Old One.
21:11:04 <edwardk> nothing could be clearer
21:11:08 <luite> edwardk: it's not terribly fast yet, this is with notdan's improvements to the diagrams-ghcjs backend (for gsoc) :)
21:11:11 <edwardk> heatsink: hahahaha
21:11:19 <luite> hopefully it's better in a few weeks
21:12:11 <heatsink> > let fixWithParameter p f = fix (f p) in fixWithParameter 5 (:)
21:12:12 <johnw> heatsink: it'll be something like: sourceProcess ... $$ CL.mapM_ (\x -> modifyIORef foo (\y -> take 1024*102 $ y <> x)) ; readIORef foo
21:12:12 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
21:12:15 <erisco> 'f' and 'g' both take a list argument. 'f' determines if the list is non-empty. if so, 'f' calls 'g' with the list. otherwise, 'f' returns an empty list
21:12:18 <edwardk> luite: still it is better than i expected
21:12:42 <edwardk> luite: you're making me want to work on a javascript backend for ermine
21:12:53 <erisco> say that 'g' also makes the same checks. ie, it checks if the list is non-empty and does something on that case, or it is is empty, does something different
21:12:56 <johnw> heatsink: oh, wait, you need to use "under reversed (take 1024*1024) $ y <> x", to always keep the last 1024K
21:13:02 <luite> edwardk: the source: http://hdiff.luite.com/ghcjs/automaton/main.hs.txt
21:13:04 <edwardk> johnw: why under?
21:13:15 <edwardk> :t under reversed
21:13:15 <lambdabot> Reversing t => (t -> t) -> t -> t
21:13:18 <edwardk> :t over reversed
21:13:19 <lambdabot> Reversing b => (b -> b) -> b -> b
21:13:25 <erisco> my question is: given that 'f' has already determined the state of the list, how can you prevent (or help) 'g' from redundantly checking the state?
21:13:27 <luite> edwardk: hehe i wouldn't recommend it ;)
21:13:34 <heatsink> Is under a lens function?
21:13:39 <johnw> i think under was what you used for f . g . f
21:13:45 <edwardk> heatsink: yeah
21:13:53 <johnw> aha
21:13:55 <shachaf> under is like over except the other way around.
21:13:56 <edwardk> under is over . from
21:14:00 <johnw> then, over reversed
21:14:07 <johnw> shachaf: :)
21:14:09 <edwardk> from reversed = reversed
21:14:19 * heatsink would rather not learn lenses and conduits simultaneously
21:14:26 <edwardk> heatsink: heh
21:14:32 <shachaf> You con du it!
21:14:36 <johnw> lensuits!
21:14:36 <Heather> getting unsupported operation on directoryRename
21:14:52 <Heather> doesn't work when I want to move it on another local drive
21:15:12 <johnw> heatsink: well, at the very least 'over reversed' is just an easier way of writing reverse . take 1024*1024 . reverse
21:15:19 <Heather> So I guess I need recursive copy and recursive delete
21:15:36 <erisco> mm, as confusingly as that is worded, I don't think it quite captures what is happening in my case either
21:15:50 <shachaf> dimap reverse reverse, naturally
21:16:09 <johnw> oh, that's quite a nice way to think about it, shachaf
21:16:29 <shachaf> Whoops. Is it?
21:16:30 <edwardk> iso reverse reverse
21:17:05 <johnw> shachaf: when you have endomorphisms, profunctors are a lot like Endo, you can tack on functions of the same type to either side
21:18:05 <heatsink> would the argument of mapM_ be applied to every character in the stream?  If so, then I probably want to do an O(1) operation instead of an O(buffersize) operation
21:18:22 <johnw> heatsink: no, it's applied to each chunk coming out of sourceProcess
21:18:31 <heatsink> ok
21:18:46 <johnw> i have idea what the chunk is, it probably relates to the current buffering mode
21:19:23 <johnw> and that mapM_ is from Data.Conduit.List, which is why I prefixed CL to it
21:19:46 <heatsink> Oh, <> is mappend
21:19:56 <johnw> yeah
21:20:03 <heatsink> I'm not used to the operator
21:20:15 <johnw> i don't really use ++ anymore, since <> works everything that ++ does, and then some
21:21:11 <heatsink> I think I understand most of it now
21:21:15 <edwardk> i mix simply because of precedence
21:21:20 <heatsink> How do you run two conduits concurrently?
21:21:31 <johnw> what kind of concurrency do you mean?
21:21:34 <edwardk> infixr 5 ++
21:21:37 <edwardk> infixr 6 <>
21:21:54 <heatsink> Collecting stdout and stderr of a process into separate buffers
21:22:14 <heatsink> so the program needs to process whichever handle has data available
21:22:46 <johnw> hmm
21:22:48 <johnw> doesn't look like process-conduit has a way to do that
21:23:00 <edwardk> heh that is easy with machines.. it is just everything else that is hard
21:23:11 <johnw> well, you don't have to use process conduit
21:23:18 <erisco> mm might have figure out what to do
21:23:32 <johnw> you could drop down and make the process yourself, the same trick applies
21:24:07 <johnw> in fact, using conduits here is a little gratuitious
21:24:42 <heatsink> Just use a loop that reads (nonblocking) from both handles and checks whether the subprocess has terminated?
21:24:59 <johnw> maybe I'd fork two threads on the stdout and stderr handles, consuming from both and hold the output in an IORef bounded to the last X bytes
21:25:18 <johnw> you can just read from both handles simultaneously
21:25:37 <johnw> and use two IORefs to gather the results
21:25:52 <heatsink> ok
21:26:07 <heatsink> The threads know they're done when the handles are closed
21:26:14 <johnw> right
21:26:21 <heatsink> And the main thread needs to check when the two I/O threads have terminated
21:26:34 <johnw> i recommend using the async library, to manage exceptions properly
21:27:11 <johnw> then you don't need IORefs anymore
21:27:15 <heatsink> Oh yeah, this looks pretty simple
21:27:33 <johnw> you can return the value by way of the async future
21:28:20 <johnw> do { (hout,herr) <- createProc ; out <- async (gather hout); err <- async (gather herr); (,) <$> wait out <*> wait err }
21:28:30 <heatsink> It uses STM?  Why are transactions involved?
21:28:57 <johnw> they eliminate race conditions that are otherwise thorny
21:29:03 <heatsink> I see
21:29:07 <johnw> some parts of async can be done without STM, some parts could not
21:29:15 <heatsink> I like that solution
21:29:23 <johnw> i don't think what I've described will end up using the STM bits
21:29:23 <johnw> but I'm not sure about that
21:29:30 * tabemann remembers that in Marlow's book he implements parts with and without STM, and the STM versions turn out to be much nicer
21:30:17 <heatsink> johnw++
21:32:25 <nonconvergent> Hey, I got ghc from my distribution, and i'm in the process of pulling the whole thing down myself.  But it's left some stuff lying around, like in /usr/local/lib
21:33:45 <nonconvergent> can I just remove them?
21:36:18 <erisco> @pl \x -> fmap (f x) yss
21:36:21 <lambdabot> flip (fmap . f) yss
21:36:21 <lambdabot> optimization suspended, use @pl-resume to continue.
21:36:53 <heatsink> You can remove the /usr/local/lib/ghc-7.6.2/ directory.  Those files are only used by Haskell.
21:37:03 <johnw> erisco: f x ?? yss
21:37:09 <johnw> after importing Control.Lens
21:37:34 <lightquake> what's the best way to write tests that require data too large to be embedded in the source? just pull it in using IO at runtime, or do wacky template haskell things to pull the contents of the file in?
21:38:12 <johnw> i would do IO at runtime, but that's just me
21:38:55 <johnw> erisco: oh, wait, I read too quickly
21:39:05 <johnw> :t f ?? ?? yss
21:39:06 <lambdabot> parse error on input `??'
21:39:57 <johnw> :t (f ??) ?? yss
21:39:57 <lambdabot> Not in scope: `yss'
21:40:06 <erisco> sigh these laziness woes
21:40:18 <johnw> :t \f yss -> (f ??) ?? yss
21:40:19 <lambdabot> (a -> a1 -> b) -> a -> a1 -> b
21:40:26 <erisco> always so close yet so far
21:40:47 <erisco> johnw, you up for some thinking?
21:40:54 <johnw> not really
21:41:00 <edwardk> johnw: what are you trying to do?
21:41:01 <erisco> np :)
21:41:15 <johnw> edwardk: two things at once, and failing
21:41:26 <edwardk> k
21:42:07 <johnw> erisco: sorry, I have a high priority bug on my list, and it's being difficult
21:42:15 <erisco> johnw, no worries man
21:42:23 <johnw> otherwise, I'd love to do some thinking :)
21:44:34 <tabemann> what heuristic is used for determining <<loop>>?
21:44:41 <luite> tabemann: black holes
21:45:02 <erisco> > let x r = x : r in fix x
21:45:03 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0] -> [a0]
21:45:11 <erisco> right that was a dumb example :P
21:45:16 <luite> tabemann: ghc overwrites a closure with a black hole when entering it, when it then tries to enter it again from the same thread it sees the black hole
21:45:31 <luite> tabemann: so the RTS throws NonTermination
21:46:08 <tabemann> I remember reading about that
21:46:47 <tel> erisco: can't you unpack the cons so that g knows its non-empty? f (x:xs) = g x xs
21:46:57 <luite> tabemann: yeah it doesn't really work that way in practice, since writing black holes is deferred (lazy black holes), but that's still the algorithm :)
21:47:49 <erisco> tel, I was trying something along those lines but wasn't panning out
21:48:14 <tel> erisco: what's the whole example?
21:48:22 * tabemann is wondering why his equal? algorithm is succeeding with trees where each node has two branches but infinite-looping with trees where each node has two to three branches...
21:48:26 <dwcook> When is Text preferable to String?
21:48:45 <johnw> dwcook: when you don't need to treat your string like a list
21:49:33 <levi> dwcook: Almost always?
21:49:40 <dwcook> What makes it preferable? Just efficiency, or are there other reasons?
21:49:58 <heatsink> tabemann, is your comparison method structurally recursive?
21:50:26 <tel> dwcook: Data.Text.Encoding v. Data.ByteString.Char8.pack?
21:50:43 <levi> dwcook: It's also wise to different character encodings and such.
21:51:26 <dwcook> tel, I'm actually not familiar with ByteString at all. Is that something I should also consider for certain String usecases?
21:51:42 <levi> johnw: And you can mostly treat Text like a list, too.
21:51:49 <heatsink> Bytestrings are space-efficient
21:52:18 <levi> dwcook: ByteString is mostly for when you have chunks of binary data rather than textual information.
21:52:20 <tabemann> heatsink: it's structurally recursive, and it's using Brent's "teleporting turtle" algorithm for cycle detection, with a backtracking algorithm in the case of cycles of my own
21:52:32 <dwcook> That's mostly what I supposed. So, for example, socket input?
21:52:37 <tel> dwcook: Generally I'd say to use bytestrings only if you're generally referring to some binary data. Which *may* be text, but usually only just before you send it over the network or something like that
21:52:56 <levi> But in the special case where your binary data is ASCII text, you can use Data.ByteString.Char8 to operate efficiently on strings of that sort.
21:53:09 <dwcook> This may actually be relevant to what I'm doing, as a socket server will be involved in the game I'm making.
21:53:20 <tel> dwcook: For handling strings of words then Text. For making basic Haskell tutorials, String.
21:53:28 <dwcook> I see.
21:53:34 <tabemann> note that there is Data.ByteString.UTF8, and this is preferable over Data.ByteString.Char8
21:53:43 <levi> Network code often operates natively on ByteString, since many network protocols deal in binary data.
21:53:47 <erisco> tel, I will give a simplified version
21:53:53 <nonconvergent> heatsink: Looks like it touched more than that.
21:54:04 <dwcook> I think I have a reasonable jumping-off point for further investigation. Thanks all.
21:54:24 <heatsink> So your trees aren't finite trees
21:54:31 <erisco> tel, (that is a disclaimer so you know 'foo' is nonsense) http://lpaste.net/92184
21:54:35 <levi> tabenmann: When would you choose to use Data.ByteString.UTF8 over Data.Text?
21:54:42 <tel> erisco: ha
21:55:05 <tabemann> levi: when one wants to keep your data in a buffer and not have to unnecessarily copy it around or like
21:55:10 <erisco> particularly, foo [1..] [1,2] will hang. how to fix? on line 9, recurse with  inf $ foo xs yss  instead
21:55:20 <erisco> problem? only the caller knows if the 'inf' call is safe
21:55:34 <heatsink> What other files are there, nonconvergent?
21:56:02 <erisco> I got away with it on 'alternate' because the caller guaranteeing the list is infinite makes the right arg non-strict (essentially)
21:56:14 <erisco> but one layer deeper, that information is lost
21:56:33 <nonconvergent> some stuff in /usr/local/share/
21:56:51 <tel> erisco, hm
21:57:27 <erisco> so this is the inheritance problem I'm speaking of
21:57:41 <nonconvergent> as well as /usr/local/lib/ ...but that one I think is because there is no /usr/local/lib/ghc/
21:58:02 <erisco> tel, the best I can think is for 'foo' to take an additional argument that it uses for its recursive call
21:58:09 <erisco> and the caller can apply inf to that
21:58:09 <nonconvergent> And they're gone now.
21:58:16 <nonconvergent> If things go boom, I'll let you know.
21:58:24 <heatsink> okay
21:59:06 <levi> tabemann: Thanks, I hadn't seen Data.ByteString.UTF8 before.
22:01:07 <erisco> tel, troublesome isn't it =\
22:01:28 <tel> erisco: yeah, this is a thorny one
22:01:43 <nonconvergent> Huh.
22:02:22 <erisco> the recursivity of 'foo' is tied to the length of xss, but there is no way for us to establish that link
22:03:32 <erisco> tel, foo could also take 'alternate' as an argument and the caller can fix it up that way
22:03:42 <erisco> but this is quite ugly
22:03:58 <erisco> and of course we can have two versions of foo, but that isn't nice either :P
22:04:15 <erisco> or we can redefine alternate to be lazy on the right argument
22:04:27 <erisco> but then 'alternate' can't benefit from a more concise definition
22:06:15 <erisco> or we can introduce  data ListLength a = Finite [a] | Infinite [a]  but that is rather hideous itself
22:06:46 <johnw> what is Data.ByteString.UTF8 good for?
22:07:14 <johnw> erisco: sounds like you are talking about data and codata
22:07:16 <erisco> if 'foo' knew that xss was infinite, it could instate inf itself
22:07:23 <shachaf> Approximately what it says on the tin.
22:07:37 <erisco> johnw, I don't know what that is
22:07:46 <erisco> johnw, but I'm probably not
22:07:49 <johnw> shachaf: hmm... i mean, what would motivate me to choose it over Text.. /me reads the tin again
22:08:21 <shachaf> Note that a colist is not at all the same thing as data Foo a = Finite (FiniteList a) | Infinite (Stream a)
22:08:59 <johnw> his foo sounds like a "List (data) or Infinite Stream (codata)"
22:09:28 <johnw> oh, I think I see the appeal of utf8-string now
22:09:37 <erisco> doesn't have to sound like anything. I defined it here: http://lpaste.net/92184  and it is meaningless... just illustrates the issue I'm facing
22:09:44 <johnw> you can have a take operation over characters rather than bytes, while only dealing with bytes
22:10:14 <shachaf> But Haskell [] is neither of those.
22:10:25 <johnw> true true
22:12:57 <erisco> tel, I may just have to go with two foo's for now =\
22:16:40 <tel> erisco I just keep wanting to reimplement alternate to be more productive
22:17:03 <tel> erisco but that was your design goal, right, to keep it as is?
22:17:14 <erisco> tel, I can redefine it to be lazy on the right argument, yes
22:17:42 <erisco> and perhaps I should simply do that
22:18:36 <tel> erisco: it's much less pretty, but not nearly as ugly as ListLength or NonEmptyList would be
22:18:54 <erisco> well I can have two definitions of 'foo'
22:19:33 <erisco> but in general this is going to happen... if a function knew its argument was infinite then it could act more lazily
22:19:44 <erisco> which can turn a hanging program into one that produces output
22:19:57 <johnw> erisco: this is an area of research for the Agda folks, btw
22:20:07 <johnw> or rather, the dependently typed community, I should say
22:20:12 <erisco> interesting
22:20:33 <erisco> well, 'inf' goes one level deep... after that, the fact the list is infinite is lost
22:20:44 <johnw> codata is used in a dependently typed, total language to guarantee termination via coinductive recursion, if I recall correctly
22:21:16 <tel> johnw: productivity, not termination
22:21:21 <johnw> ah, right
22:22:35 <tel> I'm still not sure I have my head around how to think of inf correctly. Lazy pattern matching still throws my intuition for a loop
22:22:46 * shachaf likes thinking about Mu and Nu.
22:22:54 <shachaf> (For that, I mean.)
22:23:07 <johnw> what is Nu again?
22:23:30 <tel> it's not exactly a proof of an infinite structure since it uses head/tail which can give bottom
22:23:37 <shachaf> Nu f = exists x. (x, x -> f x)
22:24:09 <johnw> Nu hypothesizes the existence of an F-algebra?
22:24:43 <shachaf> I'm not sure what that means (but that's a coalgebra).
22:24:50 <johnw> oh right
22:25:20 <johnw> i mean, an inhabitant for Nu f would prove the existence of a particular coalgebra for f
22:26:02 <shachaf> Well, sure. That's what it means that it's a member of the tuple.
22:26:19 <johnw> what is an example of the utility for Nu?
22:26:25 <shachaf> There's a particularly interesting coalgebra: addNuF :: Functor f => Nu f -> f (Nu f)
22:26:30 <tel> shachaf I love how "co" Nu is to Mu. They're so clearly the evil siblings of one another.
22:26:54 <shachaf> I think you'll best understand this if you go through some exercises rather than have me answer the question.
22:27:06 <johnw> what would the wording of one such exercise be?
22:27:14 <erisco> tel, I will just change the definition of alternate. funny how simple ideas can spiral out of control
22:27:24 <shachaf> I'll say this: In Haskell, Nu is isomorphic to newtype Mu f = Mu { runMu :: forall r. (f r -> r) -> r }
22:27:37 <shachaf> And they're both isomorphic to newtype Fix f = Fix { runFix :: f (Fix f) }
22:27:47 <johnw> ok, good enough for now :)
22:27:52 <shachaf> I'm not done!
22:27:57 <tel> erisco: haha, it's a really interesting question, though
22:28:08 <johnw> oh, continue!
22:28:12 <shachaf> As a particular example, Fix f ~ Mu f ~ Nu f ~ Nat, where data Nat = Z | S Nat
22:28:48 <elliott> uh, are you sure you meant to say f there?
22:28:55 <shachaf> Er, no.
22:28:59 <shachaf> s/ f / Maybe /g
22:29:33 <shachaf> (I,I s/^/Let f be Maybe in: /)
22:29:47 <tel> a.k.a. (1+X)
22:29:59 <shachaf> Now X is free. Just (1+)
22:30:10 <shachaf> So write all of these: zero, one, two, succ, toInt, fromInt, addF, delF
22:30:12 <shachaf> For Mu and Nu
22:30:46 <shachaf> addF :: Functor f => Mu f -> f (Mu f), delF :: Functor f => f (Mu f) -> Mu f
22:30:58 <shachaf> Also write conversion functions muToNu and nuToMu
22:31:05 <shachaf> Make sure to do it without recursion wherever possible.
22:31:17 <shachaf> (If recursion is necessary, justify it.)
22:32:06 <johnw> thanks, shachaf, will do
22:32:38 <johnw> your earlier discussion about Mu (several weeks ago), plus something I read on SO, was revelatory
22:32:43 <johnw> this feels like the next logical step
22:33:33 <shachaf> johnw: Oh, also write: fold :: Functor f => (f a -> a) -> Fix f -> a
22:33:56 <johnw> ok, I've excerpted this discussion into my task list item
22:33:59 <shachaf> unfold :: Functor f => a -> (a -> f a) -> Fix f
22:34:15 <johnw> shachaf: where/when did you learn about Mu/Nu?  Working on lens?
22:34:29 <shachaf> Doing these exercises, more or less.
22:34:34 <erisco> tel, I described it as: 'inf' does not store "this is an infinite list" on the list itself, so when the length of the list is used to determine the multiplicity of another behaviour, 'inf' doesn't make it knowable that the other behaviour will occur infinitely
22:34:43 <johnw> just out of interest?  or were you reading something that lead here?
22:34:48 <erisco> tel, in English terms I don't know how to make it clearer. does that make sense?
22:34:59 <shachaf> I think edwardk might be to blame.
22:35:03 <johnw> ahhh
22:35:05 <johnw> that explains much
22:35:11 <johnw> he has sent me down a few rabbit holes too
22:35:41 <erisco> tel, "another behaviour" isn't defined well, but that is the best I can think of
22:39:05 <shachaf> You know how to write Nu in Haskell, right?
22:39:32 <johnw> are you asking me?
22:39:49 <shachaf> Anyone else is free to answer, but yes.
22:39:56 <johnw> data Nu f = forall x. (x, x -> f x)?
22:40:05 <johnw> err
22:40:09 <johnw> type Nu f = forall x. (x, x -> f x)?
22:41:12 <shachaf> No. The definition would be type Nu f = exists x. (x, x -> f x)
22:41:28 <shachaf> Except GHC doesn't support first-class existentials, so it has to be written differently.
22:42:12 * hackagebot gloss-examples 1.8.0.2 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.8.0.2 (BenLippmeier)
22:42:14 * hackagebot TCache 0.10.0.12 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.10.0.12 (AlbertoCorona)
22:42:50 <johnw> type Nu f = forall r. (forall x. x -> f r) -> f r?
22:43:42 <shachaf> Now you're just guessing. :-)
22:43:57 <johnw> i derived that from a comment made in http://stackoverflow.com/questions/14299638/existential-vs-universally-quantified-types-in-haskell
22:44:02 <shachaf> type Nu f = forall r. (forall x. x -> (x -> f x) -> r) -> r would work, but you can use an actual "existential"
22:44:08 <shachaf> data Nu f = forall x. Nu x (x -> f x)
22:44:39 <johnw> ok, I will think on that
22:44:43 <mm_freak> haasn: Quit ≡ Bool
22:44:51 <johnw> i want to pay more attention to this, but my high priority bug keeps pulling my mind away
22:45:00 <mm_freak> data Quit = Quit | NoQuit
22:45:57 <johnw> so forgive me if I seem to not be paying full attention; you have me intrigued, but I will have to come back to this when I have more time
22:49:42 <mm_freak> Nu seems isomorphic to:  newtype Nu' f = Nu' (f (Nu' f))
22:50:05 <johnw> that's Mu
22:50:28 <johnw> and I think he said Mu was isomorphic to Nu earlier
22:50:40 <mm_freak> ah, ok
22:51:24 <scshunt> what is the meaning of an existential type?
22:51:47 <mm_freak> i just recognized a familiar pattern:  data Stream a = Stream a (Stream a); data Stream' a = forall s. Stream' (s -> (a, s))
22:51:51 <mm_freak> i just recognized a familiar pattern:  data Stream a = Stream a (Stream a); data Stream' a = forall s. Stream' s (s -> (a, s))
22:52:12 * hackagebot buildbox 2.1.2.4 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-2.1.2.4 (BenLippmeier)
22:52:15 <shachaf> Yes, Stream s = Nu (s,)
22:52:33 <shachaf> Er, I should say "a"
22:52:38 <shachaf> Which is also Mu (a,) but only if you cheat.
22:53:03 <mm_freak> those two are isomorphic as well
22:54:20 <mm_freak> scshunt: universal means caller/destructor chooses, existential means callee/constructor chooses
22:55:05 <mm_freak> universal:  f :: forall a. a -> (a -> a) -> a
22:55:08 <mm_freak> caller chooses 'a'
22:55:34 <johnw> mm_freak: I like that answer
22:56:00 <scshunt> mm_freak: ok so then what use is an existential type?
22:56:36 <scshunt> and then how does shachaf's answer relate?
22:56:47 <mm_freak> scshunt: contrived example:  data X = forall a. X a (a -> a) (a -> String)
22:57:01 <mm_freak> the constructor (the one who constructs an X) chooses 'a'
22:57:11 <mm_freak> the destructor doesn't know anything about 'a'
22:57:39 <mm_freak> if you have an 'X x f gimme', then all the destructor knows is that f and gimme can be applied to x
22:57:40 <scshunt> mm_freak: ohhh
22:58:31 <scshunt> mm_freak: also is destructor actually the correct term? not deconstructor?
22:58:32 <mm_freak> in particular trying to unify a ~ Int will fail, even if the constructor chose a = Int
22:58:49 <mm_freak> scshunt: you could say "pattern matcher"
22:59:05 <mm_freak> the person/code that pattern-matches on X
22:59:45 <tel> I like "constructing an existential forgets the type" and "destructing a universal selects the type"
23:00:08 <mm_freak> in general existentials aren't terribly useful, because there is almost always a simpler non-existential variant
23:00:15 <mm_freak> for example X is isomorphic to [String]
23:00:18 <mm_freak> well
23:00:23 <mm_freak> rather Stream String
23:00:50 <erisco> ghci seems to screw up around the time I am using 'nub'... it seems to have cached things which are not clearing properly
23:00:54 <joelteon> but you could make a heterogeneous list using existential types
23:00:58 <erisco> can I flush it somehow?
23:01:04 <mm_freak> erisco: huh?
23:01:05 <joelteon> assuming there's only certain data you want to extract from the list members
23:01:16 <erisco> mm_freak, it is giving me patently wrong answers
23:01:18 <shachaf> Yes, and you could do it without existentials too.
23:01:25 <joelteon> sure
23:01:26 <erisco> that it wasn't giving just a few lines ago
23:01:33 <erisco> and if I restart, won't be giving again
23:01:41 <joelteon> shachaf: how would you do that without existentials?
23:01:43 <elliott> lpaste the log
23:02:12 <shachaf> That depends on how you would do it with existentials.
23:02:22 <mm_freak> erisco: from the limited information that sounds like a GHC bug, but wrong assumptions about GHCi's behavior are equally likely =)
23:02:23 <shachaf> Maybe the right answer is to not do it.
23:02:27 <scshunt> erisco: I agree with elliott
23:04:57 <erisco> um, well, I'd like to not have to carry along all the custom code I have imported
23:05:26 <mm_freak> erisco: you can always start over by using :m, :l or :r
23:06:15 <nonconvergent> wonderful. Got weird error I don't understand trying to build ghc from the 7.6.3 source on Debian Wheezy using ghc 7.4.1 from their repos.
23:06:38 <nonconvergent> /usr/bin/ld: cannot find -lHSarray-0.3.0.3
23:06:39 <nonconvergent> collect2: error: ld returned 1 exit status
23:40:29 <dmj`> where does one go to get code reviews
23:41:09 <dmj`> for haskell code
23:42:01 <Gracenotes> for small programs, it's usually been here
23:42:42 <dmj`> Gracenotes: want to review my code?
23:42:59 <dmj`> It's not the best
23:43:20 <dmj`> ok so I was trying to make this quasi-database thing
23:43:22 <dmj`> https://github.com/dmjio/adhocdb
23:43:25 <Gracenotes> well, I could take a look, but you're not getting your money back if my suggestions are bad.
23:43:43 <dmj`> Gracenotes: I wouldn't know either way :)
23:43:55 <dmj`> the hardest part was the show instances omg
23:44:20 <jfischoff> are there aeson quickcheck instances defined on hackage/github I could copy easily?
23:44:27 <dmj`> I probably chose the wrong data structure, should've use Data.Map (rb trees) or hashtables pkg
23:45:18 <dmj`> Gracenotes: Used records, used acid-state to persist, and scotty + aeson for a ui
23:45:23 <dmj`> never got around to joins
23:45:26 <Gracenotes> very top-level, be more explicit about imports/exports
23:45:40 <Gracenotes> is possible to do
23:46:30 <dmj`> Gracenotes: In which part? Or do you mean make the modules hierarchical like all other projects on hackage
23:47:35 <Gracenotes> for export: module Foo (symbol1, symbol2, symbol3(...), ...) where
23:47:54 <Gracenotes> for import: from Foo import (symbol1, symbol3), what's needed, or qualified import
23:48:11 <Gracenotes> this might not be an issue for a smaller codebase. hierarchy is also good, too
23:49:32 <nonconvergent> And I think I broke my ghc installation.
23:50:23 <dmj`> Gracenotes: Yea, and look at the grammar, its not defined recursively.
23:51:12 <Gracenotes> does it need to be?
23:51:58 <dmj`> Gracenotes: Maybe with select clauses containing select clauses
23:52:02 <Gracenotes> hm, some of the parsing code does go on a bit long, like for instance updateSetWhere
23:53:01 <dmj`> Gracenotes: yea, all those spaces... should've done more combining
23:53:09 <Gracenotes> rather than having updateSet and updateSetWhere as separate functions, there could be the same code that does the initial parsing for both
23:53:34 <Gracenotes> This is more of an efficiency thing
23:53:47 <Gracenotes> rather than using monads for parsing, it seems like applicatives would work in most cases
23:53:48 <dmj`> yea good point
23:54:10 <steamboat> Hi folks, I'm writing a function cmp which takes (a,b) to a==b as
23:54:10 <steamboat> (==) <$> fst <*> snd
23:54:10 <steamboat> I've been checking this in GHCI. cmp works fine on strings or characters, but cmp (1,1) throws warnings
23:54:23 <Gracenotes> and, with parsing a programming language essentially, it's more work but a bit cleaner overall to do lexing first.
23:54:36 <nonconvergent> Dunno if anyone in here could help with this, but I thing I broke my debian install of ghc and haskel-platform. cabal threw an error and suggested I run ghc-pkg check, which tossed this.
23:54:40 <nonconvergent> http://paste.debian.net/30236/
23:54:58 <dmj`> Gracenotes: do you lex first for your parsers?
23:55:09 <Gracenotes> It seems quite hacky to change against the string "Table does not exist"
23:56:09 <Gracenotes> dmj`: it mainly makes sense to do it with programming languages, where you have lots of whitespace. You don't have that in URLs, email addresses, IRC messages, etc.
23:56:09 <mm_freak> steamboat: liftA2 f fst snd = uncurry f
23:56:23 <dmj`> Gracenotes: Yes, I'd agree. Wasn't too sure about error handling in that case. I just wanted to return to the user, not throw an exception
23:56:26 <Gracenotes> lots of whitespaces, and lots of tokens which are shared.
23:57:24 <dmj`> Gracenotes: Yea, the parser is pretty gross. I've since done a lot more with attoparsec and applicatives with http
23:58:03 <Gracenotes> I mean, it's a really bad idea to have to check exists == tableDoesNotExist in the first place.
23:58:14 <dmj`> Gracenotes: Can't monadic parser combinators forgo the lexing entirely if the language def isn't too complex
23:59:16 <elliott> steamboat: a defaulting warning? turn it off.
23:59:35 <Gracenotes> well, you can forgo lexing, but you end up with boilerplate, mainly what you have there. parsing is slower and conflated with recognizing words.
