00:03:44 <hpaste> chexxor pasted “How to remove intermediate functions?” at http://lpaste.net/91959
00:03:56 <chexxor> Can anyone take a look?
00:07:55 <johnw> i wouldn't remove them
00:08:14 <johnw> you can replace them with "case", but it wouldn't make the code any clearer
00:08:59 <chexxor> cool. Also, Q about Haskell style - using longer names in patterns is ok?
00:09:18 <johnw> in patterns?
00:10:19 <chexxor> yeah, like "severity" "logMessage" "beforeMessage" and "afterMessage"
00:10:27 <chexxor> "leftTree", "rightTree"
00:10:44 <johnw> seems fine to me
00:11:10 <chexxor> cool. All the early Haskell samples I see use "(x : xs)"....
00:11:32 <chexxor> so I have to ask if a,b, x,y,z are used, like in Math
00:11:40 <johnw> they are
00:11:45 <johnw> all depends on you
00:12:02 <Saizan> chexxor: the rule of thumb is that if the scope of an identifier is small then you want a small name
00:12:05 <Polarina> Stay away from the Greek letters.
00:12:18 <johnw> often when using x:xs, btw, the related argument is a polymorphic type so there's nothing identifying about "x", hence x is as good a name as any
00:12:23 <Saizan> chexxor: because then the structure of the code will jump out more
00:12:48 <chexxor> Saizan: interesting! I'll try it.
00:13:27 <Saizan> chexxor: but if the scope is big you want some name that will remind you of what that thing is about when you meet it further away from where it's bound/defined
00:14:12 <Saizan> chexxor: cheers :)
00:14:24 <chexxor> :)
00:14:53 <chexxor> one last Q for now - I want to extract a single value from a type which has many - how do I do that?
00:15:10 <chexxor> I wrote a getMessage function to pattern-match into it
00:15:37 <johnw> that's how
00:15:39 <chexxor> but I wonder if I can just do someVar.Message.val
00:15:54 <johnw> you could do something like that by making it into a record
00:15:57 <johnw> or with lenses
00:16:14 <johnw> but otherwise, pattern matching (case, or a function, or a let) is how you get at sub-parts
00:16:47 <chexxor> so I have to write a get* function every time I want to get a value out?
00:17:10 <johnw> if you don't use a record, yes
00:17:13 <chexxor> seems troublesome... but maybe I'll get used to it
00:17:26 <Saizan> you can also pattern match on the spot
00:17:33 <johnw> data Foo = Foo { fooField1 :: Int, fooField2 :: Char, fooField3 :: Double }
00:17:44 <johnw> now I can use "fodField1 x" for some x :: Foo
00:18:27 <chexxor> thanks for the reference johnw
00:18:51 * hackagebot staticanalysis 0.0.0.2 - Reusable static analysis interfaces and modules.  http://hackage.haskell.org/package/staticanalysis-0.0.0.2 (AndreiLapets)
00:18:53 * hackagebot compilation 0.0.0.2 - Haskell functionality for quickly assembling simple compilers.  http://hackage.haskell.org/package/compilation-0.0.0.2 (AndreiLapets)
00:19:08 <chexxor> Saizan: did you see my lpaste? Can I use an on-the-spot pattern match instead of getMessages?
00:21:39 <edwardk> Saizan: your bound laws are finding there way into my tutorial
00:21:46 <edwardk> er their
00:27:15 <SrPx> Hello guys. Haskell is my last hope. Is there any library for incremental topological sorting for it?
00:29:50 <startling> SrPx: I wish I knew.
00:30:15 <SrPx> What is wrong with humanity...
00:30:22 <ski> alastor__ : in `elementAt :: Integral i => [a] -> i -> a', `Integral' is a "predicate" that applies to types. in this case we say that `elementAt' has type `[a] -> i -> a' for any type satisfying the predicate `Integral' (and for any type `a'). iow `i' must support the operations specified in the type class `Integral'
00:30:30 <startling> Data.Graph's API is pretty ugly and weird. I guess you /could/ do it "incrementally" but it'd be re-sorting the whole thing each time
00:30:41 <ski> (the whole `Integral i' thing to the left of `=>' is known as a "constraint")
00:30:44 <ski> @src Integral
00:30:44 <lambdabot> class  (Real a, Enum a) => Integral a  where
00:30:44 <lambdabot>     quot, rem, div, mod :: a -> a -> a
00:30:44 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
00:30:44 <lambdabot>     toInteger           :: a -> Integer
00:31:09 <SrPx> After 60 years or compute science what is it that a programmer has to implement such a fundamental algorithm himself? What the heck we should have figured out how to dispose those things in a global library or something
00:31:16 <SrPx> We can't even agree in which programming language to use
00:31:19 <SrPx> I hate you all
00:31:57 <ski> (since `Real' and `Enum' are superclasses of `Integral', any type being an instance of `Integral' must already also support the operations of `Real' and `Enum' (or the instance declaration for `Integral' for that type isn't accepted))
00:32:05 <startling> SrPx: Data.Graph will do topological sort
00:32:17 <SrPx> startling: incremental?
00:32:22 <startling> it's the "incremental" part that's hard, if I understand you
00:33:09 <ski> alastor__ : one specific instance of this `elementAt' signature is `elementAt :: Integral Int => [String] -> Int -> String', and since we know `Int' is an instance of `Integral' (iow `Integral Int' is true), we can simplify this to `elementAt :: [String] -> Int -> String'
00:33:44 <SrPx> startling: I don't think so, I have just implemented a rough algorithm in js, ~15 lines. http://www.cs.sunysb.edu/~bender/newpub/BenderFiGi-soda09.pdf From there it is just a matter of optimization
00:34:10 <SrPx> But yea, I have lost a day on the process of finding a paper, understanding it, implementing, debugging. That sucks.
00:34:30 <SrPx> We should not need to subject a programmer to that at this point
00:34:44 <johnw> SrPx: did you see http://www.princeton.edu/~risteski/batch_dynamic.pdf?
00:34:51 <Lethalman> SrPx, it's so funny to read papers and implement algorithms, especially this kind of algorithms
00:34:51 <Lethalman> :)
00:35:01 <Lethalman> why wouldn't you want to do that as a programmer
00:35:13 <SrPx> it is funny but in this case I am making a game and I lost a day to the competitors. that is not OK
00:35:41 <startling> SrPx, why not just re-sort each time? sounds like premature optimization
00:35:47 <SrPx> johnw: yea thanks. I used another paper though, as it was shorter
00:36:04 <SrPx> startling: this one function is dropping my fps from 120 to 30...
00:36:36 <SrPx> startling: so instead of resorting a graph of 1000 nodes 30 times a second I must incrementally update it
00:37:04 <SrPx> as in, without it the fps is great but the spriters are drawn on the wrong order
00:37:27 <johnw> is this a commercial game?
00:37:29 <Saizan> edwardk: cool, to guarantee monad instances work or have you found them useful for more?
00:37:32 <SrPx> sure it is
00:37:37 <johnw> nice
00:37:42 <SrPx> ...? heh
00:38:33 <Saizan> chexxor: you could use a monad comprehension
00:38:43 <Saizan> chexxor: ehm, list comprehension
00:39:43 <Saizan> chexxor: well, it depends on if you want to keep the empty strings in the result of whatWentWrong or not
00:40:30 <chexxor> chexxor: probably don't need to
00:40:55 <Saizan> chexxor: if not you can write "whatWentWrong messages = [ message | LogMessage message _ _ <- inOrder (build filteredMessages) ]"
00:42:45 <Saizan> except i got the order of the fields wrong, but same difference :)
00:43:11 <Saizan> and similarly "filteredMessages = [ logmsg | logmsg@(LogMessage (Error severity) _ _) <- messages, severity >= 50 ]"
00:43:41 <Saizan> i guess there are also nicer ways to do this with lenses and prisms
00:45:26 <chexxor> Saizan: list comprehensions? I'll investigate. Thanks for the lead.
00:47:14 <Saizan> yeah, they are quite handy for filtering and massaging lists like here
00:49:32 <Lethalman> are list comps implemented in terms of filter/map or are they especially optimized by ghc?
00:51:26 <startling> Lethalman, they're a special syntactic form, but you can think of them as filter/map or as (>>=)
00:51:36 <startling> and return, I guess
00:51:49 <Lethalman> startling, yes but I'm asking if they are especially optimized by ghc or they get just rewritten
00:52:06 <levi> They're syntactic sugar.
00:52:24 <Lethalman> levi, ok
00:52:35 <chexxor> Saizan: that's brilliant
00:54:16 <Gracenotes> they are rewritten *and* especially optimized by ghc
00:54:57 <Gracenotes> they get optimized the same as if you did the syntactic translation yourself, which is pretty well, it seems.
01:01:16 <startling> it'd be pretty silly if they weren't optimized the same way as the rest of code.
01:02:08 <dpwright> is there an easy way to "fake" an IO handle?  I want to call runProcess but pipe stdout/stderr to some buffer in memory, and have basically an empty stdin
01:03:19 <dpwright> (it's ok to block until the process is complete)
01:03:46 <levi> dpwright: Yes, you can pipe stdin/stdout
01:04:35 <levi> See System.Process
01:05:40 <levi> There's also the knob package for making handles to memory-backed files.
01:05:48 <dpwright> runInteractiveProcess.. got it.  Don't know how I missed that
01:06:46 <notdan> you can also use dupTo, but I guess runInteractiveProcess is easier and more high-level
01:08:29 <dpwright> notdan: will give runInteractiveProcess a go and see how it goes... I'll bear dupTo in mind as something to look up if I run into difficulty -- thanks!
01:16:57 <levi> What I'd really like to be able to do is dynamically re-bind stdin/stdout during a library call so that I can capture stuff that some silly libraries print to stdout. :P
01:17:28 <ciaranm> dup2 is your friend
01:17:33 <clj_newb_2345> this is a genuine question and not meant to be trolling. When using the maybe monad, why is it better ot define functions as f: A -> Maybe B; g: B -> Maybe C, and use "do x <- ... " with ">>=" ... rather than just define the functions "f: maybe A -> maybe B" "g: maybe B -> maybe C" ?
01:18:14 <ciaranm> clj_newb_2345: it's better for your types to reflect what the function does. also, what you suggested doesn't scale.
01:18:34 <clj_newb_2345> I believe you're right; but I don't now where I'm wrong.
01:18:38 <clj_newb_2345> Why does it not scale?
01:19:04 <ciaranm> well, what if there's already another function b -> m c that you want to use?
01:19:19 <ciaranm> and what if you've got a b -> c that you want to use?
01:19:37 <clj_newb_2345> I see
01:20:45 <levi> Ahh, System.Posix.Redirect wraps up the dup2 stuff in a "nice" way.
01:22:47 <levi> It would be silly to have to wrap the *arguments* to all your functions in Maybe just to optimize the case when you want to chain them together in a specific way.
01:22:55 <ski> clj_newb_2345 : why additionally specify the behviour of your functions when `Nothing' is passed, if they will always return `Nothing' anyway ?
01:28:50 <ski> clj_newb_2345 : another perspective on it :
01:29:01 <ski> every function of type `A -> Maybe B' can be turned into a function of type `Maybe A -> Maybe B', and vice versa, in a way not depending on the actual types `A' and `B'
01:29:15 <ski> however these two processes are not inverses of each other. if you go from `A -> Maybe B' to `Maybe A -> Maybe B' and back, you'll get the original function, but if you try starting with `Maybe A -> Maybe B', you won't necessarily get back the same function
01:29:28 <ski> so, each function of type `A -> Maybe B' can be represented as a function of type `Maybe A -> Maybe B', but not every function of type `Maybe A -> Maybe B' can be represented as one of type `A -> Maybe B'
01:29:37 <ski> so, it makes sense not to use overkill, iow not using the more powerful method of encoding the function, unless it's actually *needed*
01:30:19 <ski> btw, this argument works for most other monads as well, not just the `Maybe' monad
01:30:45 <clj_newb_2345> ski: this makes sense
01:30:46 <clj_newb_2345> thanks
01:31:39 <ski> (if you don't use overkill, then you can usually assume that when the more powerful means is used, it's because it's actually required)
01:32:49 <ski> clj_newb_2345 : if you want, you can try defining conversion functions of types `(a -> Maybe b) -> (Maybe a -> Maybe b)' and `(Maybe a -> Maybe b) -> (a -> Maybe b)'
01:33:03 <ski> (or for any monad `m', if you prefer)
01:33:56 <ski> clj_newb_2345 : as for not scaling, are you familiar with defining data types yet ?
01:35:45 <ski> if so, you could consider a datatype `data Expr = Lit Rational | Add Expr Expr | Sub Expr Expr | Mul Expr Expr | Div Expr Expr' and defining an `eval :: Expr -> Maybe Rational' function that gives `Nothing' if and only if a division by zero occurs
01:37:02 <ski> consider how to define this if you don't use `do' notation or `(>>=)'/`(=<<)'
01:41:24 <Cale> clj_newb_2345: In IO, the contrast between A -> IO B and IO A -> IO B is even more stark. A function of type IO A -> IO B might construct the IO B by executing its parameter of type IO A as many times as it wants, or perhaps in some cases, not at all. A function of type A -> IO B doesn't know where the A came from or how it was constructed. If it was constructed by executing an action of type IO A beforehand, there's n
01:41:25 <Cale> o way it can cause that action to run again.
01:43:53 * hackagebot data-store 0.3.0.7 - Type safe, in-memory dictionary with multidimensional keys.  http://hackage.haskell.org/package/data-store-0.3.0.7 (PetrPilar)
01:47:19 <shelf> wah. i just tuned in, but that was a pretty solid piece of knowledge Cale
01:47:21 <shelf> thanks
01:49:00 * ski grins
02:00:20 <jacco> any hints on what to do after a "cabal.exe unsatisfied constraints", I tried to install cabal-dev on a windows-7 basic machine
02:04:39 <ffog> mhm
02:06:45 <supki> jacco: rerun cabal install with -v3 and paste log at lpaste.net :)
02:12:08 <arnsholt> I assume there's a function which is just "\x -> x `seq` x". What's it called?
02:12:55 <supki> arnsholt: id
02:13:08 <supki> arnsholt: x `seq` x = x
02:14:15 <arnsholt> Hmm. Time to reread what seq does in that case
02:14:25 <startling> I don't think x `seq` x does anything.
02:14:35 <supki> well, it's "Evaluate x when you evaluate x"
02:14:46 <startling> right.
02:15:12 <arnsholt> The idea was to force evaluation of x
02:15:27 <bartavelle> you might want to use bang patterns or $!
02:15:39 <arnsholt> Right
02:16:08 <arnsholt> f $! x forces the x, though, no?
02:16:13 <startling> arnsholt, I don't think you understand what seq does
02:16:19 <arnsholt> I agree =)
02:16:41 <startling> See the first big paragraph here: A common misconception regarding seq is that seq x "evaluates" x. Well, sort of. seq doesn't evaluate anything just by virtue of existing in the source file, all it does is introduce an artificial data dependency of one value on another: when the result of seq is evaluated, the first argument must also (sort of; see below) be evaluated. As an example, suppose x :: Integer, then seq x b behaves
02:16:42 <startling> essentially like if x == 0 then b else b – unconditionally equal to b, but forcing x along the way. In particular, the expression x `seq` x is completely redundant, and always has exactly the same effect as just writing x.
02:16:51 <startling> oops, meant to paste the link, not the paragraph
02:17:01 <startling> the URL is http://www.haskell.org/haskellwiki/Seq
02:17:44 <arnsholt> Ooooh, right
02:17:58 <arnsholt> I'm still coming to terms with this laziness stuff
02:18:41 <startling> it's kind of rough. I'm still coming to terms with it. :)
02:28:06 <quchen> startling: "unconditionally equal to b" is a little too lax I think.
02:30:45 <arnsholt> startling: Yeah, I'm starting to see where I went wrong
02:31:03 <merijn> arnsholt: To make things even more confusing, seq doesn't guarantee an ordering!
02:31:28 <merijn> arnsholt: So in "seq a b" where both a and b are errors, seq can return either error at random
02:31:37 <arnsholt> Fun! =)
02:32:10 <merijn> The only thing you can sensibly say about seq is this: If neither 'a' nor 'b' are undefined, then evaluating "seq a b" will end up evaluating both 'a' and 'b' in some order
02:32:14 <quchen> merijn: Try not to seq errors :-)
02:33:51 <quchen> To be fair, evaluating `a` before `b` in `seq a b` is a valid way of implementing seq. It's just that Haskell doesn't impose such an ordering.
02:33:53 <merijn> Note that if you don't evaluate the result of "seq a b" neither will be evaluated
02:34:31 <merijn> Anyway, back to writing :(
02:37:35 <quicksilver> even what merijn says isn't true
02:37:56 <quicksilver> evaluating 'seq a b' does not need to evaluate a - it just needs to prove it isn't _|_
02:38:10 <quicksilver> if the compiler can statically prove that a is not _|_ then it need not generate any code at all.
02:38:35 <quchen> quicksilver: Is there an example for that?
02:39:02 <quchen> An expression that can be shown to be not bottom without evaluating it?
02:39:19 <quchen> Sounds a bit magical to me
02:39:31 <Taneb> quchen, it evaluates it to Weak Head Normal Form
02:39:36 <Taneb> > seq [undefined] 7
02:39:37 <lambdabot>   7
02:39:38 <eikke> a function which gets Int# as an argument?
02:39:44 <quicksilver> quchen: "True"
02:39:46 <arnsholt> Constant folding would be one way, I guess
02:40:02 <quchen> Taneb: Yes, go on?
02:40:25 <eikke> > let f a b = b a in seq (f 1) 2
02:40:26 <lambdabot>   2
02:40:30 <quicksilver> but in general, strictness analysis and such like
02:40:49 <Taneb> So, if you have [undefined], it evaluates it to "_ : _" and thinks, "Right, that's good enough"
02:40:54 <quicksilver> if (a) and (b) are both non-_|_ then (a+b) is non-_|_
02:41:02 <quchen> Taneb: Sure, but that's evaluation, isn't it?
02:41:04 <quicksilver> and you know that *without* actually evaluting (a+b)
02:41:11 <Taneb> It's partial evaluation
02:41:16 <quicksilver> it's a property of +
02:41:20 <quchen> Taneb: You don't have to evaluate it all the way of course
02:41:58 <Taneb> seq just goes as far as the first thunk
02:42:32 <quchen> If the objection is that merijn said "evaluation" instead of "partial evaluation" that sounds a bit pedantic to me.
02:43:20 <quchen> quicksilver: How is totality a property of (+)?
02:43:23 <quicksilver> no, quchen, that's not my point
02:43:32 <quicksilver> quchen: it's a property of (+) for Ints
02:43:34 <quicksilver> (e.g.)
02:43:41 <quicksilver> it's not a general property of +.
02:43:42 <quchen> And the compiler knows that?
02:43:48 <quicksilver> if it wants to.
02:43:51 <quicksilver> this is hypothetical.
02:43:56 <quchen> Okay, it's knowable.
02:43:59 <quicksilver> I'm not suggesting that GHC actually behaves this way
02:44:00 <Taneb> quchen, aha, I misunderstood you
02:44:09 <quicksilver> but it would be compliant with the standard
02:44:20 <quicksilver> all the standard requires you to do is ascertain that 'a' is not _|_
02:44:21 <quchen> quicksilver: Ah, I understand.
02:44:27 <quicksilver> there may be ways to do that without reducing it to WHNF
02:44:54 <quicksilver> and GHC does do at least *some* rearrangement of evalution based on strictnes analysis.
02:44:57 <quchen> quicksilver: "Suppose there was a {-# TOTAL f #-} pragma, then you didn't have to evaluate the function in order to know whether it's bottom or not"
02:45:02 <quchen> Something along those lines?
02:45:16 <quchen> And then (+) would be such a TOTAL thing etc.
02:45:29 <quchen> Not sure whether I said that right, but I think I get what you said anyway. :-)
02:52:59 <arnsholt> When generating an unboxed array, is there any way to use previously computed elements to compute subsequent elements?
02:54:00 <quicksilver> well, sure, if you compute the elements in a list
02:54:10 <quicksilver> (and stuff them into the array as you go)
02:56:12 <arnsholt> Using something like (//) you mean?
02:56:45 <arnsholt> "array (lower, upper) (seed ++ {- stuff computing based on previous elements -})" seems to hang
02:58:35 <eikke> arnsholt: constructN does that, no?
02:58:57 <eikke> constructN :: Unbox a => Int -> (Vector a -> a) -> Vector a
03:00:06 <arnsholt> That ought to work. I've been using Data.Array.* so far
03:00:51 <quicksilver> arnsholt: well I meant array (lower,upper) {let l = seed : {- stuff computing based on previous elements of *l*, not the array itself -} in l )
03:01:19 <quicksilver> but here are alternatives using other structures including using a boxed array for the remporary storage and then unboxing it
03:01:25 <quicksilver> however constructN look seven better :)
03:01:37 <arnsholt> Right, that'll work. But then I'll pay the penalty of random-accessing lists being stupid, right?
03:01:57 <arnsholt> Yeah, Vector looks neat. But I need 2D, sadly
03:02:24 <quicksilver> use a map or an unboxed array as your temporary for cosntruction then
03:02:43 <quicksilver> sorr
03:02:49 <quicksilver> "or a *boxed* array"
03:07:02 <mstksg> anyone here ever work with publishing RSS feeds?
03:07:16 <mstksg> what are the comparisons for the rss vs feed libraries?
03:07:32 <mstksg> feed library looks like it has good tools for atom feeds and parsing feeds and all around working with feeds in general
03:07:41 <mstksg> but i just need to really generate one.
03:08:30 <mstksg> it looks like rss is specially tailored for rss 2.0 but feeds is more generalized.
03:08:38 <mstksg> i was just wondering if anyone has had experience working with either library
03:19:25 <Spockz> What would be the first occurence of "Attribute Grammars"? I've found these two: http://dl.acm.org.proxy.library.uu.nl/citation.cfm?id=567532.567544&coll=DL&dl=ACM&CFID=354740397&CFTOKEN=12319914 and http://dl.acm.org.proxy.library.uu.nl/citation.cfm?id=907283&CFID=354740397&CFTOKEN=12319914. Although I have found on incremental evaluation of attribute grammar's I have not found an article describing them to start with
03:31:19 <augur> Spockz: attribute grammrs are ancient
03:34:54 <augur> Spockz: attribute grammars are themselves fairly straight forward and obvious formalizations of ideas that have existed for a while in linguistics, at least, and probably also in CS
03:34:55 <Spockz> augur: I have seen an reference to somewhere in 1950's
03:35:04 <augur> yeah that sounds probably right
03:35:14 <Spockz> Sadly, I cannot find it
03:35:21 <augur> chomsky was using what were basically attribute grammars in 1964-ish
03:35:39 <augur> tho it really depends on what counts
03:36:06 <augur> but, the idea is pretty "obvious" and i think people have been using more or less that idea for ages
03:36:21 <Spockz> I just want to give the reader a reference where they can lookup what attribute grammars are, in concept
03:36:34 <augur> well, thats what wikipedia is for :)
03:36:35 <Spockz> and I don't want to bother them with details such as incremental evaluation
03:36:47 <Spockz> I'm not sure that is allowed in a MSc thesis
03:36:55 <augur> oh wel
03:37:00 <augur> you should define them right there then
03:37:17 <augur> you shouldnt refer people to other things
03:37:18 <Spockz> augur: they don't really matter that much either
03:37:37 <augur> if they matter at all you should define them
03:37:56 <augur> if its not TOO important, then the definition can be fairly informal, probably
03:38:12 <Spockz> I'm saying that incremental evaluation has been done for Attribute Grammars and for ML
03:38:25 <Spockz> + method X of incr...
03:38:32 <augur> "An attribute grammar is a CFG where each symbol has associated with it some "attributes" or properties with values, that rewrite rules can refer to."
03:39:11 <augur> aha, ok
03:39:21 <augur> well, in that case, since its just in passing, you can just leave it like that
03:39:25 <augur> you dont need a reference
03:39:43 <Spockz> ok
03:39:47 <Spockz> thank you :)
03:39:56 <augur> you're just mentioning them in passing, and people can google things
03:40:08 <augur> you MIGHT want to put refs for the incremental evaluation things, tho
03:40:16 <augur> infact you ought to
03:40:21 <augur> because you have specific things in mind
03:40:47 <augur> thats sort of the rule of thumb i use: if i have a particular paper, etc. in mind, cite it, and if i have just a general idea or thing in mind, people can use google
03:41:14 <Spockz> augur: yes they are there
03:41:30 <augur> citations are for things that people CANT figure out for themselves, either because they're hard to find, or because they're _your_ intentions, or whatever
03:41:42 <Spockz> right :)
03:42:04 <ciaranm> pfff. every claim you make that you don't justify yourself should be cited.
03:42:36 <augur> ciaranm: right
03:42:43 <augur> but thats what i mean, right
03:42:50 <augur> just mentioning attribute grammars doesnt require a citation
03:42:58 <augur> its a concept, an idea, a thing, and people can look it up
03:43:08 <augur> you dont need to cite the EXISTENCE of AGs
03:43:16 <ciaranm> you cite a recent review paper
03:43:21 <augur> but if you say that something in particular has been done with AGs, you should cite it.
03:43:41 <augur> no, you dont cite recent review papers for existence :P
03:43:51 <augur> because then you need to cite something proving the existence of that paper!
03:43:55 <augur> and the existence of the journal
03:44:00 <augur> and the existence of the idea of a paper and journal
03:44:01 <augur> and
03:44:02 <augur> and
03:44:19 <ciaranm> you sound like a postmodernist
03:45:00 <augur> you're the one saying we should cite to demonstrate implicit existence claims :P
03:45:08 <quicksilver> it is quite common to cite technical terms
03:45:18 <quicksilver> with the paper which first gave them that name, or popularised them
03:45:33 <augur> thats a horrible practice and ought to stop
03:45:36 <quicksilver> one reason for this is to be clear which sense of the term you are using in case it has been used in other ways
03:45:50 <quicksilver> "...computational Monads in the sense of Moggi[1]..."
03:46:10 <augur> quicksilver: thats fine, you have a PARTICULAR thing in mind, fine
03:46:22 <augur> in the sense of MOGGI
03:46:26 <augur> not in some vague general sense
03:46:43 <augur> also, in Spockz's situation
03:46:43 <ciaranm> vague generalities? you sound like a postmodernist
03:47:05 <augur> he's going to cite some papers about specific issues with attribute grammars
03:47:12 <augur> so those papers will do all the explaining necessary
03:47:15 <augur> there's no need to do like...
03:47:36 <augur> "So and so has been done for attribute grammars [1] and ML [2], as in [3] and [4]."
03:47:42 <augur> where [1] and [2] define AGs and ML
03:47:52 <augur> and [3] and [4] describes so-and-so being done for AGs and ML
03:47:57 <augur> thats just silly.
03:48:14 <augur> infact, the citations after each term should be to the so-and-so papers exclusively
03:48:34 <augur> maybe there's some kind of specificity partial order
03:48:37 <Spockz> That is how I have it now
03:48:44 <bennofs> Is it possible to work around the cabal-error "Warning: Your version of HPC (0.6) does not properly handle multiple search paths. " with GHC-7.6?
03:48:56 <augur> where [3] is more specific that [1], so you should use only [3], not [1], if you have both
03:48:58 <augur> you use the lub!
03:49:00 <augur> er..
03:49:02 <augur> glb?
03:49:05 <augur> something.
03:51:47 <rtb> stuck with typeclassopedia functor exercises: anyone knows of documented solutions to these? (only found undocumented source code)
03:51:53 <augur> now, quicksilver, i think you're right that if there's a _common_ ambiguity, fine
03:52:05 <augur> you do what you say. X's in the sense of Y [n]
03:52:23 <augur> but if there's a very clear, well established thing, you dont need it.
03:52:33 <rtb> scratching my head over Functor ITree Exercise atm
03:53:05 <augur> even if there are some very less common usage.
03:53:07 <augur> s
03:53:54 <augur> but again, unless ofcourse you're going to have to cite something else which is more specific, which should then be the only citation
03:54:10 <Saizan> rtb: what part are you stuck on?
03:55:39 <rtb> Saizan: fmap g (Node ts) = Node (map (fmap g) ts)
03:56:09 <Saizan> right
03:56:16 <rtb> Saiz: map + fmap... seems way over my head ..
03:56:42 <rtb> yes but why is it right?
03:57:35 <Saizan> you could also look at it like fmap g (Node ts) = Node (fmap (fmap g) ts), but i don't think it'd help much :)
03:58:31 <rtb> yeah it's a list so fmap is map..
03:58:40 <Saizan> rtb: to see that it's right you should try to prove the laws
03:59:14 <Saizan> e.g. you want fmap id (Node ts) = Node ts
04:00:00 <rtb> that's the next chapter :)... ok I think about that
04:01:31 <Saizan> but intuitively you want to apply g to all the elements, and the map just helps you get inside the list, so you can get to the trees again
04:01:56 <simukis_> \msg edwardk “These will also occur in code samples” appears in the first block of code without any indication it is not a part of code.
04:02:01 <simukis_> uh oh 😃
04:02:43 <rtb> thank you for the reflection Saizan, I think I got that intuition part, will focus on laws..
04:14:12 <bennofs> I'm getting the following error when using hpc: "hpc: can not find vplan-0.1.0.0/Data.VPlan.Time in ["./dist/hpc/mix/vplan-0.1.0.0"]", even if ./dist/hpc/mix/vplan-0.1.0.0/vplan-0.1.0.0/Data.VPlan.Time.mix. Any idea on what I could be doing wrong?
04:14:37 <bennofs> I compiled with cabal configure --enable-tests --enable-library-coverage --enable-library-profiling
04:14:51 <bennofs> and then run cabal build && cabal test
04:16:57 <Saizan> rtb: np
04:19:11 <skypers> hey
04:19:30 <skypers> I have a function that takes a (a -> IO b)
04:19:49 <skypers> I pass it this function : \_ -> rexturn ExitSucces
04:20:00 <skypers> is it possible to review it to use const?
04:20:21 <Saizan> const (return ExitSuccess)
04:20:37 <ciaranm> return (return ExitSuccess)
04:20:52 <skypers> Saizan: I don’t get why
04:21:00 <skypers> const a b returns a
04:21:07 <skypers> so here it returns
04:21:12 <skypers> IO ExitCode
04:21:14 <skypers> oh
04:21:15 <skypers> ok
04:21:15 <skypers> :D
04:21:18 <skypers> thanks :D
04:21:23 <Saizan> np :)
04:21:43 <mbrock> \_ -> x = const x
04:22:03 <skypers> mbrock: it won’t be okay
04:22:28 <skypers> since ou return (a -> (b -> IO c)) here
04:22:32 <skypers> you*
04:23:34 <mbrock> that's the definition of const, it doesn't matter which type x has
04:23:46 <mbrock> and return ExitSuccess is just a value like 8 or "hello"
04:24:17 <skypers> yeah
04:24:28 <skypers> but hm
04:24:29 <skypers> for me
04:24:46 <skypers> oh
04:24:48 <skypers> (=) ?
04:25:24 <skypers> what the heck is that?
04:25:35 <skypers> oooh
04:25:39 <skypers> you were just
04:25:39 <skypers> ahah.
04:25:44 <skypers> misunderstanding.
04:26:10 <skypers> I thought you were just showing up another way to write it
04:26:11 <mbrock> is equal to (:
04:26:40 <mbrock> metalanguage confusion!
04:28:32 <pxqr> is there a haskell aware diff like this one for python http://www.yinwang.org/resources/pydiff1-pydiff2.html ?
04:32:16 <hpc> pxqr: you should write one
04:32:31 <hpc> using the ghc library
04:32:54 <pxqr> hpc: do you mean a ghc plug-in?
04:33:42 <arkeet> shouldn't haskell-src-exts be enough?
04:33:48 <hpc> or that
04:33:50 <veryrandomname> is there something like (!!) for Data.List which returns Maybe a?
04:34:05 <arkeet> > "abcde" ^. ix 3
04:34:07 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
04:34:07 <lambdabot>    arising from a use o...
04:34:09 <arkeet> > "abcde" ^? ix 3
04:34:12 <lambdabot>   Just 'd'
04:34:14 <arkeet> > "abcde" ^? ix 5
04:34:16 <lambdabot>   Nothing
04:34:18 <hpc> @hoogle Int -> [a] -> Maybe a
04:34:18 <lambdabot> Prelude (!!) :: [a] -> Int -> a
04:34:18 <lambdabot> Data.List (!!) :: [a] -> Int -> a
04:34:18 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
04:34:23 <osfameron> pxqr: isn't that just a diff with syntax highlighting?  i.e. coldn't you use vimdiff or similar?
04:34:36 <hpc> veryrandomname: doesn't look like; you should probably consider better algorithms
04:34:43 <hpc> or a different container, or something
04:34:52 <arkeet> or lens
04:35:05 <arkeet> but more likely you shouldn't be using !! at all.
04:36:12 <osfameron> pxqr: oic, pydiff diffs at bytecode level.  didnt get that from the link
04:36:35 <arkeet> not the syntax level?
04:37:21 <arkeet> it would be cool to have a diff that works on (reasonably) general ASTs
04:37:30 <pxqr> the diff is from here: https://github.com/yinwang0/psydiff
04:37:43 <arkeet> a text file is a triival sort of AST, where you have a bunch of lines, each containing a bunch of characters.
04:37:46 <veryrandomname> (!!) is fine for me at the moment, I'm not using it for big lists, only the error is stupid.
04:39:55 <pxqr> if we trying to search difference between two AST's, what the type of operation result will it be?
04:40:21 <pxqr> not a line or pos = { col, row }
04:40:53 <pxqr> ok, it may be line, but we have more information
04:43:09 <arkeet> I'm sure there's something clever.
05:03:57 * hackagebot diagrams-pdf 0.2.0 - PDF backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-pdf-0.2.0 (alpheccar)
05:10:23 <ski> Spockz : which two papers are those two ? (i just get to a login page here)
05:12:33 <quchen> veryrandomname: listToMaybe . drop n
05:12:55 <quchen> veryrandomname: listToMaybe is "safeHead", drop n I'm sure you're familiar with.
05:13:55 <veryrandomname> quchen: nice, thanks :)
05:31:40 <Rogach> Q: Is there big performance difference between Data.Vector.Unboxed ad Data.Vector.Storable? Are they both represented as plain arrays at low level?
05:32:42 <jmcarthur_mobile> The former is struct of arrays. The latter is array of structs.
05:33:13 <jmcarthur_mobile> Both providing roughly the same interface.
05:33:24 <jmcarthur_mobile> Storable is a bit easier to write instances for than Unbox.
05:34:14 <jmcarthur_mobile> Performance differences depend on context.
05:34:52 <Rogach> jmcarthur_mobile: So for simple operations (like lots of random access) performance is the same?
05:35:13 <Rogach> jmcarthur_mobile: I especially like Storable because I can then pass it to/from C without extra pain.
05:35:33 <jmcarthur_mobile> I'm not going to promise that performance will be the same, but it shouldn't be a huge difference.
05:36:16 <jmcarthur_mobile> I think in most cases Unboxed will be slightly faster, but again, it depends.
05:38:17 <Rogach> jmcarthur_mobile: I actually saw the following in Unboxed docs: "In particular, unboxed vectors of pairs are represented as pairs of unboxed vectors".
05:38:44 <jmcarthur_mobile> Right. That is what I meant by struct of arrays.
05:38:51 <Rogach> jmcarthur_mobile: How is that more efficient? For example, if I am doing lots of random accesses, each access will hit 2 locations instead of one.
05:39:05 <Rogach> jmcarthur_mobile: Wouldn't that be bad for caches?
05:39:41 <RichyB> Rogach, depends whether you more often access all attributes of each struct or make many accesses to one attribute of each struct.
05:40:29 <RichyB> Transforming from array-of-structs to struct-of-arrays is recommended sometimes to improve cache locality in the literature around things like OpenCL and OpenMP.
05:40:43 <Rogach> RichyB: Aha. So if I do something like "V.map fst v" (where v :: V.Vector (Int,Int)), it will be faster?
05:41:10 <RichyB> I think so.
05:41:36 <Spockz> ski: Incremental evaluation for attribute grammars with application to syntax-directed editors (1981) and
05:41:39 <Spockz> On attribute grammars and the semantic specification of programming languages (1975)
05:43:57 * hackagebot syb 0.4.1 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.4.1 (JosePedroMagalhaes)
05:46:31 <`Jake`> Is it possible to write something which makes it possible to write "5%" in ghci and get 0.05 back? I suppose not, because it results in a parse error...
05:46:52 <`Jake`> I could just use strings, though, I guess
05:47:22 <mauke> you could write /100 instead of %
05:47:35 <`Jake`> yes, but that's 2 more key presses
05:48:13 <osfameron> don't you have to write 5.0/100.00 ?
05:48:23 <mauke> > 5/100
05:48:24 <lambdabot>   5.0e-2
05:48:27 <bennofs> you can write .05
05:48:29 <bennofs> > .05
05:48:30 <lambdabot>   <hint>:1:1: parse error on input `.'
05:48:31 <`Jake`>  / only works with fractionals
05:48:34 <bennofs> :O I thought you could
05:48:34 <mauke> bennofs: no, you can't
05:48:41 <`Jake`> it infers the type
05:48:49 <osfameron> ghci does some extra inference iirc
05:49:03 <osfameron> you could use 5 % 100 from Data.Fraction(?)
05:49:03 <`Jake`> 5/100 works, though.
05:49:12 <supki> `Jake`: with -XPostfixOperators you can have (5%) being 0.05
05:49:14 <mauke> > 5/100 :: Rational
05:49:15 <lambdabot>   1 % 20
05:49:19 <`Jake`> Thanks, supki
05:50:00 <mbrock> percent = (/ 100) might be nice though verbosier
05:50:40 <`Jake`> but that would be `percent 5' instead of `5 percent'
05:54:23 <edwardk> I just posted https://www.fpcomplete.com/user/edwardk/bound in case anyone feels like doing a proof-reading pass before the world gets in
05:56:01 <mauke> "The Barendregt convention" links to amazon. I am disappoint
05:56:15 <mbrock> if you represent your percentages as multiplying functions, like a % b = (a / 100) * b, then (5 %) is five percent :)
05:56:51 <edwardk> mauke: if you have a better link, let me know
05:56:56 <edwardk> i just wanted to let readers follow up
05:57:16 <mauke> I wanted to follow up!
05:57:30 <mauke> but I didn't want to buy and read a whole book
05:57:35 <edwardk> the secrts of the ghc inliner is a good followup
05:58:07 <edwardk> but barendregt's tome is worth buying ;)
05:58:14 <edwardk> and slogging through
05:59:12 <mauke> heh. the "Expand" label should probably change once clicked on
05:59:43 <edwardk> mauke: thats SoH and out of my control.
06:00:10 <mauke> "Need a globally unique variable supply. (e.g. concurrent-supply"  <- unbalanced (
06:00:25 <ski> Spockz : ty
06:01:01 <mauke> "the Rapier," <- I am bothered by the comma inside the quotes
06:01:02 <edwardk> mauke: fixed
06:01:11 <edwardk> mauke: sadly, english ;)
06:01:23 <mauke> no, american
06:01:35 <edwardk> heh, well, i am =P
06:01:41 <mauke> also, typewriters
06:02:29 <mauke> http://en.wikipedia.org/wiki/Quotation_mark#Punctuation
06:02:42 <edwardk> i wrote most of this sleep while deprived last night
06:04:36 <edwardk> No matter which way I go on that one I'll piss off someone, so I choose to please my third grade teacher ;)
06:04:37 <bennofs> edwardk: "classes you already know: ... to manipulate your syntax tree, an factors out"  Should "an" be "and"?
06:04:45 <edwardk> bennofs: yeah
06:05:08 <edwardk> bennofs: fixed
06:05:59 <DMcGill_> error with makeWrapped: http://lpaste.net/91965
06:06:14 <DMcGill_> I suspect it's probably just another extension I need to add
06:06:18 <edwardk> makeWrapped can't do higher rank
06:06:32 <edwardk> it can't make a valid instance. what would it look like?
06:06:43 <edwardk> we don't have higher rank typeclass arguments yet
06:07:16 <DMcGill_> but I had `fmap k p = Pretext $ fmap k . runPretext p'
06:07:23 <DMcGill_> it's the perfect use! :(
06:07:32 <edwardk> (we actually wind up wanting them when the newtype wrapper stuff comes in and gundry's work on fields comes in)
06:07:46 <edwardk> heh
06:08:07 <mauke> "This is starting to feel like a library, rather than design pattern" <- nice
06:08:12 <edwardk> you can use DeriveFunctor to get deriving Functor for Pretext if that makes you feel better
06:08:26 <edwardk> mauke: =)
06:08:35 <DMcGill_> I know, I wanted to define it all myself though. It was probably a good idea given how it certainly felt nontrivial to me to do.
06:09:17 <edwardk> mauke: i was mostly pleased that i was able to make almost all the code fragments in that introduction compileable
06:09:56 <mauke> "and when we instantiate we can skip past " <- past what?
06:09:58 <edwardk> DMcGill_: yeah, Pretext is a tricky beast. I was rather amused when I came up with it, and now it is all over lens
06:10:18 <edwardk> mauke: i accidentally the whole
06:10:37 * shachaf mumbles something about the secret cost of "deriving (Functor, Foldable, Traversable)"
06:10:45 <shachaf> It's a shame that didn't end up fixed pre-7.8
06:11:28 <mauke> "We do this so often that we hide turn" <- I think you accidentally included used a verb twice
06:11:28 <edwardk> shachaf: wait, twan's patch didn't go in?!
06:11:52 <shachaf> edwardk: Not in 7.6.3
06:11:54 <edwardk> mauke: fixed both
06:12:03 <edwardk> shachaf: oh that
06:12:22 <mauke> .oO( "the whole F'ing tree" )
06:12:23 <shachaf> So it's fixed in HEAD but I doubt we'll see another 7.6.
06:12:25 <edwardk> i thought you meant it wasn't going to be in in 7.8 and i was about to have a conniption fit ;)
06:12:27 <edwardk> mauke: =)
06:12:36 <Okasu> shachaf: Can you elaborate? What cost?
06:12:38 <ketil> Array now depends on the Trustworthy extension, which requires a fairly new GHC - at least newer then 7.0.4, which seems to be installed on a lot of systems.  Should this be considered a bug?  Could use of this trustworthy extension be made conditional on GHC version?
06:12:47 <edwardk> mauke: heh i figure all the F jokes got out of my system by transcribing Conor.
06:12:58 <shachaf> @google derived traversable inefficient
06:13:00 <lambdabot> http://ghc.haskell.org/trac/ghc/ticket/7436
06:13:01 <lambdabot> Title: #7436 (Derived Foldable and Traversable instances become extremely inefficien...
06:13:01 <shachaf> Okasu: ☝
06:13:11 <Okasu> shachaf: Thanks.
06:13:42 <edwardk> ketil: it can be and i do so in all my libs, i'm not sure if array is intended to be installed outside of its source ghc version though as it is sparse of the first wave of split base from the 3 -> 4 cut over
06:13:51 <edwardk> er it is part of
06:14:25 <ketil> Well, installing software really wants to pull it from hackagedb and install it, so if that's not intended, it needs to be prevented, somehow.
06:14:34 <FreeFull> I wonder what the big-O complexity of    c 1 = [1]; c x = x : if x `mod` 2 == 0 then c $ x `div` 2 else c $ x*3 + 1    is
06:14:56 <edwardk> ketil: this happens to template-haskell as well
06:15:21 <edwardk> i really wish there was a way to tell hackage to _not_ let the client upgrade template-haskell
06:15:29 <edwardk> it routinely breaks users of my packages
06:15:44 <ketil> It makes a lot of software uncompilable. Maybe if I restrict array version, it will only pull down older dependencies as well (bytestring, binary, etc etc).  They claim to depend on array-0.4.0.1 which failed to install, but I suspect they aren't that specific about array version.
06:16:00 <edwardk> something has a tight template-haskell bound and then 30 packages later, they get an ill-formed type error out of ghc in a th splice
06:16:30 <edwardk> ketil: well, if there is a hard lower bound on someone's array version there is likely a reason
06:16:39 <edwardk> (unless it was just untested below that)
06:16:58 <ketil> edwardk, sure - but I don't think cabal is really saying there is a bound, even though it sounds like it.
06:17:04 <edwardk> so finding the package that puts the lower bound in, figuring out how to lower it and sending them a patch is one way to fix it, but it requires constant vigilance
06:17:12 <Guest8546> maybe a tool could automatically find the lowest version that still compiles&passes tests
06:17:42 <ciaranm> lower bounds good. upper bounds bad.
06:17:43 <edwardk> ketil: well you should already have an array installed, so it should be trying to satisfy new packages with it. when they have a bound that yours can't meet is when it tries to install a new one and all hell breaks loose
06:18:09 <edwardk> ciaranm: both sides lead to errors. but i confess the upper bound side is 90% of the time too conservative.
06:18:19 <ketil> ....and there is no way to automatically figure out *which* of the packages that specifies the version bound, right?
06:18:43 <ketil> (except looking them up one by one, that is)
06:18:48 <edwardk> ciaranm: in my case i'm able to at least apportion my own major numbers in such a way that i bump the first digit of my major number when i break myself, and the second digit when it could break anyone else per the PVP.
06:18:58 <edwardk> this let me cut the amount of spam i send to hackage by 95%
06:19:08 <edwardk> ketil: sadly backtracking that info is hard
06:19:37 <ketil> Hm, I thought perhaps cabal install -v would tell me more about the reasoning.
06:19:54 <ciaranm> if only there were an algorithm which could produce a minimal set of conflicting conflicts
06:20:10 <edwardk> ketil: basically the solver is a black box, so any reasoning about where it got the constraints is done post hoc outside of it
06:20:27 <edwardk> dcoutts posted about it at some point
06:21:05 <magneticduck> anybody familiar with sox here?
06:21:28 * sinclair|net wishes he knew what people were talking about in this channel
06:21:34 <magneticduck> luls
06:21:38 <magneticduck> sox has nothing to do with haskell actually
06:21:45 <magneticduck> but I can't find anybody on freenode who knows how to do this one thing
06:21:51 <magneticduck> and I really need to know how to do it
06:22:06 <sinclair|net> can i ask a question?
06:22:16 <sinclair|net> what do people in here use haskell for?
06:22:25 <magneticduck> making games, music, doing math
06:22:30 <magneticduck> that's me
06:22:47 <ketil> Oh well, I don't think I have time to fix this. I'll just tell people to upgrade GHC... this lack of backwards compatibility isn't very encouraging for using GHC to write real software.  Sigh.
06:22:52 <merijn> sinclair|net: distributed algorithms, shell scripting, language implementation, web programming, finance
06:22:54 <sinclair|net> i mean, i am from a windows background, years and years of experiance in proceedural programming, C/C++/C#/Java/Python
06:23:07 <sinclair|net> merijn: distributed how?
06:23:11 <edwardk> ketil: what version are you trying to support?
06:23:21 <ketil> 7.0.4
06:23:23 <sinclair|net> merijn: i have a interest in distributed compute
06:23:46 <edwardk> ketil: a lot of packages have moved their support profile forward to 7.4 or so that is probably your problem.
06:23:51 <simukis_> sinclair|net: playing with it and trying to make people in my office to let me use it for a project 😉
06:23:55 <merijn> sinclair|net: There's people working on Cloud Haskell, I'm working a zeromq implementation
06:23:56 <ciaranm> intimidation
06:24:06 <edwardk> even lens gave up on 7.0.4 and only supports it through 3.7 which it maintains a subset of compatibility with
06:24:28 <ketil> edwardk, sure - but a lot of computers out there have old software installed.  I think it is called "enterprise" something. :-)
06:24:36 <sinclair|net> merijn:: what does haskell provide language wise that makes it more suitable than any other language?
06:24:45 <merijn> sinclair|net: Not sucking
06:24:52 <ketil> Enterprise generally is an euphemism for outdated, slow and expensive.
06:24:58 <sinclair|net> merijn: that was a genuine question
06:25:09 <merijn> sinclair|net: It was a genuine answer too :)
06:25:17 <edwardk> ketil: the benefit of expensive is there is usually money in fixing things =P
06:25:21 <tikhon> sinclair|net: more suitable for what?
06:25:28 <simukis_> sinclair|net: that was genuine but somewhat summarised answer.
06:25:46 <sinclair|net> it is a matter of opinion
06:26:08 <tikhon> anything can be construed as a matter of opinion
06:26:08 <merijn> sinclair|net: Good concurrency support in the form of, lightweight threading, good RTS for concurrent programs, expressivenes, conciseness, the ability to use equational reasoning for correctness
06:26:39 <fryguybob> sinclair|net: One possible answer to your question is that Haskell allows equational reasoning which is a powerful property to reduce the complexity of a software project.
06:26:47 <merijn> sinclair|net: Yes, but there's like 15 billion trolls asking "who cares about FP?!" it becomes boring, to answer
06:26:59 <sinclair|net> fryguybob: though modularity ?
06:27:10 <sinclair|net> merijn: im not one of them
06:27:14 <tikhon> Haskell lets you write less code in less time to do more, correctly
06:27:39 <fryguybob> sinclair|net: The compiler will tell you when you get things wrong for a lot of common errors.
06:27:46 <tikhon> and then the resulting code is reasonably fast, especially compared to "high-level" languages like Python
06:27:57 <merijn> sinclair|net: The better I become at programming, the more I realise inheritance is downright the biggest mistake ever made in design, OO programming is a rather terrible idea (unless you recast it as an actor-model like approach) and strong typing is amazing
06:28:03 <fryguybob> sinclair|net: And given a program that is already working, you can manipulate it more easily.
06:28:14 <simukis_> merijn: You're wrong. NULL is.
06:28:16 <sinclair|net> tikhon: one feature i look for in a language is runtime type reflection services, if i understand correctly, Haskell is a typed FP, but can i reflect back on those types?
06:28:26 <merijn> sinclair|net: http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
06:28:37 <tikhon> sinclair|net: depends on how you define "reflection", I suppose, but yes
06:28:41 <merijn> sinclair|net: "Why functional programming matters", it's a good intro
06:29:11 <merijn> sinclair|net: And I will counter that "type reflection" is almost always the completely wrong approach and only used to compensate for lack of expressiveness in the language that uses it
06:29:13 <sinclair|net> merijn: im not for FP because its considered fashionable, i kinda want to solve problems i would find difficult to solve otherwise
06:29:19 <tikhon> that said, unlike Java et al, things like that are seldom necessary
06:29:30 <tikhon> it's like asking for a parking brake on a helicopter
06:29:40 <fryguybob> sinclair|net: With Haskell you can largely avoid the sort of problems that a meta-programming escape hatch opens you up to by having types that can express what you want directly.
06:29:54 <FreeFull> merijn: What about dependent typing?
06:30:17 <edwardk> sinclair|net: we have 'Typeable' you have to explicitly opt in to allowing your type to be reflected upon and to the fact that your function may reflect.
06:30:20 <sinclair|net> tikhon: well, in something like a distributed compute / message based application architecture, being able to provide type information about messages passed over the while is important
06:30:22 * jfischoff hides his face for using syb 'everything'
06:30:31 <shiona> damn you
06:30:37 <shiona> that was on purpose
06:30:48 <merijn> FreeFull: Making the writing of dependently typed code not-suck is still an open research direction
06:31:00 <sinclair|net> tikhon: something C# does well is let me reflect back on types exposed over a service endpoint
06:31:10 <merijn> FreeFull: But in general I find total languages and type derived programming ala Epigram very promising
06:31:18 <merijn> FreeFull: Just not practically useful yet
06:31:18 <sinclair|net> tikhon: ideally, id like to look at something like that in Haskell
06:31:29 <tikhon> sinclair|net: that doesn't have to depend on reflection per se, does it?
06:31:36 <edwardk> sinclair|net: this is a _very_ important distinction between Haskell and other languages.
06:31:36 <edwardk> other languages presume that because subtyping information is present it should be something you can always use, but neglect the fact that it makes one of their guiding principles, Liskov substitutability, a lie.
06:32:00 <sinclair|net> edwardk: i don't follow
06:32:36 <edwardk> jfischoff: clearly you should use biplate instead.
06:32:36 <edwardk> sinclair|net: nothing stops you from using Typeable if you want
06:32:36 <edwardk> most of the uses of reflection are to compensate for a gimped type system
06:32:40 <sinclair|net> edwardk: what do you mean, subtyping information? you mean type metadata? or prototypical approaches to inheritance ?
06:33:41 <sinclair|net> edwardk: sorry, please know i know basically nothing of the Haskell language itself, im literally starting a new
06:33:42 <edwardk> sinclair|net: any sort of isInstanceOf check means you can behave differently for a sub-type of a super-type, which means that inheriting from a supertype can cause divergent behavior in all mainstream OO language designs. this means that liskov's substitutability principle is something you have to check at every function invocation using the body of the function you invoke to make sure it isn't doing anything evil
06:33:54 <edwardk> sinclair|net: this goes beyond full reflection functionality.
06:33:56 <jfischoff> edwardk: heh, biplate fixes everything ;)
06:33:58 <DMcGill_> hey edwardk, do you mind telling me if I'm on the right track here please: `duplicate (Pretext k) = Pretext $ fmap (\a -> Pretext (\s' -> undefined)) . k'
06:34:21 <sinclair|net> edwardk: um, im not sure about that
06:34:25 <edwardk> DMcGill_: want a big hint that doesn't give away the store
06:34:29 <edwardk> DMcGill_: ?
06:34:38 <sinclair|net> edwardk: that may be true with something like C++ RTTI
06:34:53 <bartavelle> sinclair|net, a more mundane answer : you usually define a "Message" type with several distinct contructors, such as data Message = Question String | ShutDown | EnableDebugLevel Int
06:34:59 <DMcGill_> What do you mean? I've done the Store Comonad/saw it in your post already
06:35:00 <sinclair|net> edwardk: tho, i am simply refering to be able to reflect back properties defined on a type at runtime
06:35:07 <bartavelle> then you can use pattern matching to find what kind of message you got
06:35:21 <merijn> sinclair|net: Why not if you can do this "if (x.instanceOf(y)) then a else b" you lose Liskov subtitution
06:35:22 <edwardk> sinclair|net: java isinstanceof, c# can check for subclass membership. if you can recover information from being upcast to 'object' you can trivially violate liskov substitutability
06:35:23 <tikhon> sinclair|net: I'm not sure "properties defined on a type" is really meaningful in Haskell
06:35:33 <edwardk> sinclair|net: this is a well studied subject
06:35:50 <sinclair|net> tikhon: well, im use enquiring about it really
06:35:57 <sinclair|net> edwardk: let me show you something
06:36:03 <edwardk> sinclair|net: i'm simply starting with a lower level issue and pointing out that reflection is doubling down on a bad design goal. it is used as spackle over poor type systems.
06:36:25 <edwardk> sinclair|net: i've written enough c# and java and c++ and what have you to understand the role that reflection plays in those ecosystems.
06:36:40 <sinclair|net> edwardk: https://github.com/sinclairzx81/appex/#json_schema
06:36:49 <tikhon> I think you're trying to make Haskell too much like C#—it is actually completely different
06:36:52 <sinclair|net> edwardk: i apoligize for the ts and node
06:36:57 <edwardk> sinclair|net: and my point is we have Typeable to get type reflection when you want it, but otherwise we deliberately do _not_ want it
06:37:19 <edwardk> if I have a function in haskell foo :: a -> a   i can tell you _VERY_ strong properties about that function.
06:37:21 <kryft> Is there an easy way to serialize (arbitrary) values in haskell? My program parses a text file that changes very rarely, so it might make sense to store the parsed representation instead of re-parsing every time the program is invoked
06:37:36 <edwardk> if I have a function in java :: object -> object I can tell you precisely nothing about it
06:37:38 <tikhon> ie you should ask about the "what" and not the "how"—if you want to do something like use a JSON schema or serialize/deserialize data, ask about that instead of reflection
06:37:39 <sinclair|net> edwardk: i agree you most often don't want it, but in a certain domains, its incredibly useful
06:37:48 <edwardk> sinclair|net: hence why we let you _opt in_
06:38:05 <edwardk> without type erasure we can't have the nice things we want. by letting you opt in we can have both
06:38:14 <sinclair|net> edwardk: did you see that example tho?
06:38:15 <b2coutts> edwardk: is foo :: a -> a necessarily the id function?
06:38:21 <tikhon> trying to use exactly the same methods to accomplish something in Haskell as in C# won't work because they're fundamentally different languages; however, Haskell can do all the same things, just differently
06:38:35 <FreeFull> b2coutts: That or bottom
06:38:35 <edwardk> sinclair|net: ive written hundreds of thousands of lines of similar examples, yes.
06:38:47 <DMcGill_> edwardk: What do you mean by "give away the store"? I've done the Store Comonad/saw it in your post already
06:38:48 <sinclair|net> edwardk: ok cool
06:38:50 <edwardk> b2coutts: either id, or it _|_'s out
06:39:15 <edwardk> DMcGill_: i meant it colloquially. you want a Compose for the result, but otherwise yes you need to fmap underneath
06:39:30 <sinclair|net> edwardk: what im pointing out is its possible to obtain type meta data at runtime (as in that example i posted) that would be awesome
06:40:09 <edwardk> sinclair|net: presume that I'm an n+1 player who has already been in your shoes at one point. ;) I'm saying that we deliberately do not give you this information at all times, but simply compartmentalize where you can get it.
06:40:29 <sinclair|net> edwardk: n+1?
06:40:30 <DMcGill_> ahh, I'd used Identity for the extract but knowing that you need Compose f g where I suspect f === g === (Pretext s) makes it easier
06:40:49 <kryft> Ah, I guess Data.Serialize is what I'm looking for, although I'd need to write a Serialize instance for my types (probably not too hard)
06:40:55 <edwardk> sinclair|net: you can get 'reflection' information on data types in haskell, we have GHC.Generic, Data.Data, Data.Typeable. each of them provides you with a typeclass that lets you inspect certain properties about the types involved
06:41:14 <sinclair|net> oh, well, thats great
06:41:35 <sinclair|net> edwardk: but what do you mean you have been in my shoes tho?
06:41:42 <edwardk> sinclair|net: but if you don't pas those instances in or don't provide them for your type  then you are able to explicitly opt out of such functionality
06:41:51 <jfischoff> sinclair|net: the punch line is we have stuff that is better.
06:41:52 <edwardk> sinclair|net: i mean when i got to haskell i asked the same question.
06:42:03 <sinclair|net> oh
06:42:03 <FreeFull> Typeclasses or annotating your types are the only way to know what you are given when the type is polymorphic
06:42:09 <FreeFull> ways*
06:42:17 <edwardk> sinclair|net: so i've already been down this line of reasoning. trying to convince me i don't understand where you're coming from is beating your head against a wall ;)
06:42:44 <merijn> sinclair|net: The question you need to ask yourself is the following: Seemingly smart people admit the following things: 1) Learning haskell takes some time 2) it requires unlearning most stuff you know and 3) can at times be rather hard
06:42:59 <sinclair|net> edwardk: well, the problem im trying to solve (in whatever language) is to have automate service endpoint mex data generated from the type information itself
06:43:09 <merijn> sinclair|net: Now, there are a couple of explanations for these 3 being true and people here still being huge haskell fans
06:43:13 <merijn> 1) We're all idiots
06:43:14 <edwardk> sinclair|net: my point with liskov substitutability and later with Typeable and id was trying to show that we have these general restrictions because they give us stronger reasoning properties, and you can 'opt in' to the simplistic reflection model
06:43:17 <merijn> 2) Stockholm syndrome
06:43:34 <merijn> 3) There is actually something there that might be hard to convey, but very worthwhile
06:43:42 <sinclair|net> edwardk: see, i will have to read up on these things you mention
06:43:44 <FreeFull> When learning Haskell you need to also sometimes be able to take things at face value rather than looking for deeper meaning that doesn't exist
06:43:44 <edwardk> sinclair|net: i recommend you look into the design of cloud haskell
06:43:59 <sinclair|net> edwardk: yes, i will look into that
06:44:00 <tikhon> sinclair|net: that sounds like something that can be done at compile-time, without anything fancy at runtime
06:44:02 <edwardk> sinclair|net: that will give you some idea of how you can do type recovery on endpoints
06:44:39 <sinclair|net> edwardk: i have noticed that FP programmers in general are a passionate lot
06:44:47 <edwardk> sinclair|net: in practice as you evolve as a haskell programmer, i predict you'll find you'll transition away from trying to abuse reflection for these things and get to the essence of the problem by using th stronger type system properties at your disposal
06:44:49 <tikhon> it's very self-selecting
06:45:08 <edwardk> sinclair|net: well, yes, we're all self-selected for using languages far outside the mainstream. that tends to bring with it a certain passion. ;)
06:45:09 <tikhon> people who aren't passionate end up settling for Java jobs
06:45:16 <sinclair|net> edwardk: is it really abuse of reflection tho ?
06:45:23 <merijn> sinclair|net: That is, because over time people tend to become more and more convinced it is "The Right Way (TM)"
06:45:53 <sinclair|net> edwardk: well, i will have a look at type recovery in cloud haskell,
06:46:17 <edwardk> sinclair|net: by 'abuse of reflection' i simply mean that in many languages you wind up using reflection to compensate for the fact that you can't abstract over certain things in your type system. in haskell we tend to adopt the model that we should improve the type system until we can abstract over them, rather than spackle over everything that looks hard with reflection
06:46:25 <merijn> sinclair|net: But otoh, trying to convince others gets tiresome. If other people want to keep struggling in the salt mines rather than join us in building a tower to the heavens, I just can't always be arsed to explain for the millionth time why FP and haskell are nice
06:46:47 <sinclair|net> edwardk: you know, you are probably right
06:48:16 <sinclair|net> edwardk: that reflection argument im throwing out there is really to do with speeding up development time, and ensuring service contracts are 100% in tune with what the developers intent is
06:48:30 <benj_> the less generous conclusion is that you can abstract over some things in the type system of a language, but people are lazy and reflection appears to be more convenient
06:48:33 <sinclair|net> edwardk: in C# i used reflection, in node, i used the typescript compiler ast
06:48:38 <DMcGill_> what's the extension that lets me do something like: `instance Comonad (Pretext s) where ... (undefined :: s)' i.e. to refer to the same type variable?
06:48:55 <edwardk> sinclair|net: sure. we just tend to achieve that same aim by switching to making appropriate instances, and turn to ghc.generics or data.data when the boilerplate would be too much
06:49:00 <Peaker> does "hint" support data declarations?
06:49:04 <quchen> DMcGill_: ScopedTypeVariables?
06:49:09 <edwardk> DMcGill_: ScopedTypeVariables
06:49:12 <eikke> DMcGill_: ScopedTypEVariables
06:49:18 <quchen> :)
06:49:19 <DMcGill_> thanks
06:49:24 <mauke> ScopedTypoVariables
06:49:33 <bartavelle> ;)
06:49:50 <sinclair|net> edwardk: speaking of the Haskell compiler, how trivial is it to compile on the fly?
06:49:58 <edwardk> benj_: i don't think its laziness, its just that without higher rank types you honestly _have_ to round-trip through object for things, which forces you back to the liskov substitutability issue
06:50:14 <sinclair|net> edwardk: i really should just spend a week getting to know haskell
06:50:18 <edwardk> sinclair|net: we have ghc-api which lets you interpret code, hint, and various other tools
06:50:35 <edwardk> sinclair|net: heh, the rabbit hole goes deep. be careful. that is how i started 6 years ago.
06:50:41 <edwardk> i'm still waiting for my week to end.
06:50:54 <edwardk> er 7 years ago now i guess
06:50:57 <sinclair|net> edwardk: so, its entirely possible to compile and bind haskell as a scripting language?
06:51:06 <edwardk> > 1 + 2
06:51:07 <lambdabot>   3
06:51:11 <edwardk> ^- that is interpreting haskell
06:51:17 <tikhon> sinclair|net: you can even do it *securely*—check out Safe Haskell
06:51:26 <sinclair|net> oh, right
06:52:03 <sinclair|net> tikhon: sorry, is that like being able to run non trusted code in a restricted app domain?
06:52:15 <DMcGill_> > readFile "/ect/passwords.txt" >>= print
06:52:16 <lambdabot>   <IO ()>
06:52:22 <edwardk> mauke: otherwise, the post look good?
06:52:25 <DMcGill_> etc*
06:52:29 <sinclair|net> > 10 + 20
06:52:30 <lambdabot>   30
06:52:37 <sinclair|net> yeah, thats some nice eval
06:52:38 <tikhon> sinclair|net: it's a tool that ensures untrusted code doesn't do anything unsafe; you can use it to heavily restrict what sort of code can be run
06:52:43 <mauke> edwardk: sorry, got distracted with one-shot continuations and perl
06:52:54 <eikke> edwardk: on a writing roll lately? :-)
06:53:15 <edwardk> sinclair|net: basically SafeHaskell lets you know the module can't do anything to subvert the typesystem and can't run 'unsafe' IO actions behind your back
06:53:16 <sinclair|net> tikhon: ok cool :)
06:53:40 <DMcGill_> is there some page were I can see all the school of haskell posts? People (mostly edwardk) have been writing faster than I can read them so I've been feverishly bookmarking
06:54:00 <DMcGill_> but I couldn't see a page that just lists them in date order like it does their own blog posts
06:54:12 <sinclair|net> edwardk: ok, cool, hey, since you seem to be from my background, can you recommend any good resources to help me get started?
06:54:14 <edwardk> DMcGill_: yeah https://www.fpcomplete.com/recent-content
06:54:28 <DMcGill_> great
06:54:30 <edwardk> https://www.fpcomplete.com/user breaks it down by user
06:54:45 <edwardk> sinclair|net: real world haskell
06:55:08 <edwardk> sinclair|net: mixing that with the more whimsical learn you a haskell for great good will usually get you up to an operational understanding of haskell code
06:55:29 <sinclair|net> edwardk: i have experiance with F# btw
06:55:47 <sinclair|net> well, "some" experiance
06:56:02 <Philippa> sinclair|net: you'll be glad to know we don't /always/ pronounce that "F*&# that" :p
06:56:23 <edwardk> then you really need to learn about monads, functors, and general higher kinded types. there are a number of thoughts you can't think in f# that are intimately connected to how one thinks in haskell.
06:56:36 <edwardk> so in many ways you have more bad habits to unlearn than someone who never saw f# ;)
06:56:37 <sinclair|net> haskell developers don't like F# ?
06:57:09 <tikhon> they probably like it more than C#
06:57:12 <Philippa> sinclair|net: there's a bunch of technical reasons that... well, F# isn't quite the C++ unto Haskell's Smalltalk, but you're starting to look at that kind of conceptual and utility gap
06:57:14 <sinclair|net> Philippa: does #flipcode ring any bells?
06:57:31 <edwardk> sinclair|net: f# is a nice language insofar as its goal is to run an ml-like language on the .net runtime. however, it sacrifices almost all of the benefits of ml-like languages due to the lack of a real module system, but still pays all the costs of rigidly ordered definitions
06:57:40 <Philippa> sinclair|net: Been a while since I opped up in there, but yep. You may know edwardk better as Harmless, too
06:57:57 <sinclair|net> Philippa: oh wow, it is you
06:58:09 <sinclair|net> Philippa: i haven't been in #flipcode since like 2004
06:58:12 <edwardk> sinclair|net: 15 years ago i used to write a column on "harmless algorithms" on flipcode
06:58:29 <satc> @hoogle @pl \f g a . (f =<< g a)
06:58:29 <lambdabot> Parse error:
06:58:29 <lambdabot>                 ^
06:58:30 <edwardk> mostly on visible surface determination and lighting calculations
06:58:35 <Philippa> sinclair|net: trust me, for me? This barely counts as a small world incident :-)
06:58:40 <satc> @hoogle @pl \f g a -> (f =<< g a)
06:58:40 <lambdabot> Parse error:
06:58:40 <lambdabot>                  ^
06:59:08 <tikhon> satc: what do you expect that to do?
06:59:11 <edwardk> wow i guess its getting closer to 20 year ago now, ouch.
06:59:13 <quchen> satc: You can't Hoogle for function definitions (even if that code worked).
06:59:14 <Philippa> but yeah, a fair few flipcoders have been through here over the years
06:59:19 <Philippa> edwardk: we're oooooold!
06:59:22 <sinclair|net> Philippa: well, its awesome to know there are some recognizable characters around here :)
06:59:29 <satc> @pl \f g a -> (f =<< g a)
06:59:29 <lambdabot> (.) . (=<<)
06:59:34 <satc> sorry my mistake
06:59:42 * sinclair|net wonders is DirtyPunk is still around
06:59:47 <satc> @pl \a -> (f =<< g a)
06:59:48 <lambdabot> (f =<<) . g
06:59:50 <mauke> :t (>=>)
06:59:51 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:59:56 <shergill> probably not the right room (i'm also in ##physics), but i was wondering if anyone here is familiar with the concept of symplecticity (wrt hamiltonian dynamics)
07:00:12 <shergill> and would be willing to give me some pointers
07:00:22 <satc> @hoogle (>=>)
07:00:22 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
07:00:25 <edwardk> sinclair|net: there are a number of us ex-flippers on irc.enterthegame.com #flipcode
07:00:32 <quchen> shergill: Not the right room. (Also: maybe.)
07:00:45 <edwardk> shergill: yes familiar, but little time to give pointers.
07:00:57 <Philippa> edwardk: if you're going to put it like that I guess I should show up for an hour or two again
07:01:11 <sinclair|net> edwardk: yes, i used to spend a lot of time in that channel many years ago
07:01:15 <shergill> edwardk: got any reading references instead?
07:01:21 <sinclair|net> back when i was all about graphics
07:01:37 <Philippa> you weren't the only one!
07:01:43 <sinclair|net> :)
07:01:47 <exicer> I've got two lists of Maybe [Int] that I would like to zip together with a function. What should I be looking at ?
07:01:57 <DMcGill_> zipWith
07:02:07 <opqdonut> liftA2 (zipWith f)
07:02:08 <eikke> edwardk: Sparse/Matrix.hs, line 106 (doc of 'values'), should read 'values' i.s.o. 'keys'
07:02:10 <DMcGill_> > zipWith (+) [1,2,3] [4,5,6]
07:02:11 <lambdabot>   [5,7,9]
07:02:14 <edwardk> shergill: we should probably talk some time when i can find out more of 'what you already know' so i can try to tune my recommendations. sclv would be a good resource too
07:02:20 <opqdonut> > liftA2 (zipWith (+)) (Just [1,2,3]) (Just [3,4,5])
07:02:20 <edwardk> eikke: patch!
07:02:21 <lambdabot>   Just [4,6,8]
07:02:23 <edwardk> =)
07:02:26 <tikhon> exicer: liftA2
07:02:28 <eikke> ok
07:02:36 <eikke> reading through the library, awaiting more articles ;)
07:02:37 <opqdonut> exicer: see my previous line
07:02:43 <tikhon> exicer: or <$> and <*>
07:02:52 <edwardk> eikke: heh. have i been building enough anticipation? =)
07:02:56 <tikhon> > zipWith (+) <$> Just [1,2,3] <*> Just [3,4,5]
07:02:57 <lambdabot>   Just [4,6,8]
07:03:14 <quicksilver> quchen: satc : well you should be able to do something like this, but it doesn't work for some reason... @. hoogle type \f g a -> (f =<< g a)
07:03:14 <tikhon> > zipWith (+) <$> Just [1,2,3] <*> Nothing
07:03:17 <lambdabot>   Nothing
07:03:25 <exicer> Cool, thanks
07:03:41 <eikke> edwardk: I've been working on efficient matrix multiplication for a while as well, but more going the 'using simd' road, so yeah, I'm interested
07:03:48 <shergill> edwardk: ok thanks :). would you have time this week at some point? if so i'll ping you later
07:03:50 <edwardk> sinclair|net: anyways DirtyPunk lurks in #flipcode over there
07:04:03 <quchen> quicksilver: Right, that hoogles the type. (Or is supposed to, at least.)
07:04:04 <edwardk> shergill: yeah follow up with me here or with sclv
07:04:12 <Associat0r> hey sinclair|net
07:04:18 <quchen> shergill: Sent you a private query.
07:04:43 <edwardk> eikke: right now i'm going for 'elegant but possible also fast, though at a distinctive point on the pareto frontier favoring ridiculously sparse matrices'
07:04:54 <FreeFull> :t (.)
07:04:55 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:04:55 <satc> For working with positive numbers is it better to use rem over mod?
07:05:18 <eikke> mine were sparse as well, which was tricky :)
07:05:24 <sinclair|net> Associat0r: oh, hi
07:05:56 <sinclair|net> Associat0r: seems everyone from the past has turned to FP
07:06:34 <edwardk> sinclair|net: well, first sweeney, and now carmack too ;)
07:07:00 <sinclair|net> edwardk: yeah, i saw his most recent quake con
07:07:32 <quchen> Let's hope he releases Holfenstein some day :-)
07:07:51 <quchen> (It's not finished, he's just playing around afaik)
07:07:59 <merijn> sinclair|net: Did you see Sweeney's talk on "the next big programming language" for game programming?
07:08:16 <shergill> sclv: ping
07:08:17 <sinclair|net> merijn: nope, is it online
07:08:21 <sinclair|net> youtube?
07:08:24 <FreeFull> sinclair|net: Rob Pike and Ken Thompson don't seem to have turned to FP
07:08:51 <merijn> sinclair|net: Not sure the talk is online, the slides are here http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
07:08:52 <edwardk> sinclair|net: I'm a shameless FP-in-general/Haskell-in-particular partisan these days, which should make me sad. As a scientist I'm supposed to be objective. But there is also a time at which you have enough evidence to say one alternative is objectively better than the other.
07:09:08 <sinclair|net> merijn: thanks, ill have a read
07:09:13 <merijn> sinclair|net: The slides are pretty interesting on their own
07:09:28 <dmwit> satc: yes
07:10:06 <tikhon> it should also make you sad that many people *aren't* interested in FP, mostly because it's different and seems hard to learn
07:10:50 <ski> sinclair|net : "Subtyping, Subclassing, and Trouble with OOP" by Oleg Kiselyov at <http://okmij.org/ftp/Computation/Subtyping/> might perhaps be interesting
07:11:07 <FreeFull> One of the things that attracted me to functional and concatenative programming languages is that they focus on composition
07:11:21 <quchen> edwardk: I don't think being opinionated "these days" is a bad thing. (Also not for a scientist.) A bad thing would be if someone showed you evidence that Haskell sucks and you'd go "but I like it anyway and I'll ignore what you said".
07:11:23 <sinclair|net> ski: thanks bookmarked :)
07:11:36 <ski> (in general, Oleg is usually interesting)
07:11:44 <DMcGill_> Uh, so pro: I have a seemingly working instance for Comonad (Pretext s) but con: it uses undefined
07:11:45 <DMcGill_> http://lpaste.net/91966
07:11:55 <DMcGill_> using undefined in finalised code seems so very wrong
07:12:20 * eikke attended a talk by Oleg last week
07:12:25 <ski> @quote standard.operating.procedure
07:12:26 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
07:12:39 <tikhon> DMcGill_: it might just mean that the type system can't easily encode some invariant in your code; that's fine. Consider using `error` with a meaningful message instead of `undefined` though.
07:13:09 <shergill> quchen: from #emacs's fsbot: "suck is a unit vector. A given foo doesn't suck LESS, it just sucks in a direction a given hacker finds less disagreeable"
07:13:48 <tikhon> euh, that sounds like an algebraic restatement of TANSTAAFL
07:13:49 <ski> DMcGill_ : how's `Pretext' defined ?
07:14:06 <DMcGill_> ski: newtype Pretext s a = Pretext {runPretext :: forall f. Functor f => (s -> f s) -> f a}
07:14:06 <shergill> tikhon: ?
07:14:15 <DMcGill_> it's from edwardk's automata SoH post
07:14:17 <tikhon> "there ain't no such thing as a free lunch"
07:14:22 <shergill> ah
07:14:31 <shergill> hmm yeah
07:14:33 <tikhon> it's a mantra the "worse is better" crowd seems to like
07:14:41 <tikhon> also Heinlein
07:14:45 <quicksilver> edwardk is allowed to be opinionated only for as long as he keeps being right.
07:14:55 <quicksilver> it's an indulgence granted him :)
07:15:22 <shergill> tikhon: also wolpert and macready
07:15:53 <edwardk> quchen: heh, well, i said i'm supposed to feel bad. not that i do ;)
07:15:59 <merijn> Also, most haskell people don't seem to argue haskell is the best language (in fact, they seem to very actively look for things that are better than sucky old haskell), it's just the haskell seems to have significantly less suck than the rest :p
07:16:20 <tikhon> I think it's a fundamentally flawed principle
07:16:21 <merijn> Even though it still has a bunch of suck
07:16:47 <edwardk> DMcGill_: consider replacing return' :: a -> Pretext s a  with return' :: a -> Pretext a a
07:16:52 <edwardk> and see if you can make it defined ;)
07:17:08 <edwardk> i call return' "sell" in lens for historical reasons
07:17:37 <DMcGill_> edwardk: ok, but is there some specific problem with the undefined here? It seems to work.
07:17:42 <tikhon> if you think about it as an optimization problem, it assumes everything is on the frontier and moving around is just a matter of making trade-offs
07:17:44 <edwardk> yes, there is a problem =)
07:17:54 <edwardk> it'll bite you when you use it nontrivially
07:18:39 <tikhon> but, of course, in the real world not all things are on the frontier: some things are strictly sub-optimal in every way
07:19:01 <shergill> tikhon: agreed
07:19:07 <DMcGill_> by which I mean I tested it once with the simplest possible case ;)
07:19:07 <DMcGill_> aha
07:19:44 <shergill> one could argue of averaging over all possible universes, but i mostly only care about the current one i inhabit
07:20:20 <Sculptor> yo
07:20:38 <satc> @hoogle Integral a, Integral b => a -> b
07:20:39 <lambdabot> Parse error:
07:20:39 <lambdabot>   Integral a, Integral b => a -> b
07:20:39 <lambdabot>             ^
07:20:45 <satc> @hoogle (Integral a, Integral b) => a -> b
07:20:46 <ski> shergill : hm, that "suck is a unit vector. ..." reminds me of Brouwers end-to-means principle ..
07:20:46 <lambdabot> Prelude div :: Integral a => a -> a -> a
07:20:46 <lambdabot> Prelude gcd :: Integral a => a -> a -> a
07:20:46 <lambdabot> Prelude lcm :: Integral a => a -> a -> a
07:20:48 <edwardk> :t fromIntegral
07:20:49 <lambdabot> (Integral a, Num b) => a -> b
07:21:04 <edwardk> satc: is that what you want/
07:23:29 <edwardk> tikhon: i try to keep my attention towards the Pareto frontier. in general i find it a wonderful thing when i can find a solution that simply dominates the others. e.g. in sufficiently 'big data' as knuth once noted space usage often approximately equals time usage, so compression is almost always a win, etc.
07:23:43 <shergill> ski: i'm unfamiliar with that
07:26:45 <FreeFull> satc: Integrals have to be Reals, and Reals have to be Nums, so that is guaranteed to allow you to convert between any two Integrals
07:28:19 <skypers> hi folks!
07:28:41 <skypers> how would you deal with events without considering IO monad?
07:28:46 <skypers> I mean
07:28:56 <skypers> treatEvents :: (Event -> ?) -> ?
07:29:08 <skypers> I don’t want side effects
07:29:34 <tikhon> if you don't want side-effects, how do you have events?
07:29:43 <DMcGill_> edwardk: uuh, this looks suspiciously easy: `duplicate p = fmap (const p) p'
07:29:45 <ludamad> Well you can 'update' a structure based on the event
07:29:45 <merijn> skypers: Where would these events come from? And what do you want to do with them?
07:30:02 <tikhon> ludamad: but where would you get the events from?
07:30:04 <DMcGill_> the possibility of code that typechecks but that isn't correct scares and confuses me
07:30:12 <skypers> 16:29 < ludamad> Well you can 'update' a structure based on the event
07:30:13 <DMcGill_> perhaps I need to move to Agda
07:30:21 <skypers> this is what I expect, yeah
07:30:38 <tikhon> if the events come from some sort of IO source, they lead to side-effects
07:30:40 <skypers> events will come from SDL I guess
07:30:47 <edwardk> DMcGill_: if you use const you throw out information.
07:30:52 <skypers> yeah
07:30:53 <edwardk> DMcGill_: you'll fail the laws then
07:30:57 <DMcGill_> yeah, thought so :(
07:31:02 <skypers> I think I’ll like something like
07:31:11 <tikhon> you can treat the events just like any pure value, but it probably won't be useful without some sort of IO
07:31:18 <skypers> treatEvents :: (Event -> IO ?) -> IO ?
07:31:28 <tikhon> yeah, that makes more sense
07:31:47 <skypers> tikhon: I could simply take a function that returns an altered version of the whole program?
07:31:51 <skypers> or a Reader?
07:31:53 <ski> shergill : roughly, it's about what he called a "causal sequence". you have some end/goal you want to reach, and you have noticed that it commonly seems to follow from a means. however (in his analogy) this usually means not that the means is fully parallel (and like directed) with the intended end, but it makes some small acute angle to it
07:32:19 <DMcGill_> skypers: you want treatEvents :: Event -> State -> State surely?
07:32:27 <merijn> DMcGill_: Why?
07:32:34 <DMcGill_> whatever representation your program uses
07:32:36 <merijn> DMcGill_: Not if he wants to do IO for certain events
07:32:39 <skypers> well
07:32:41 <skypers> for sure
07:32:44 <skypers> I’ll have IO
07:32:51 <skypers> because treatEvents will fetch events from IO
07:32:56 <ski> shergill : i.e. the means has mostly the intended effect, but also has some small side-effects in other dimensions
07:33:05 <DMcGill_> no, feed events TO treatEvents
07:33:11 <DMcGill_> treatEvents changes your model
07:33:13 <ski> shergill : later, this means become an end in itself, repeating the process. after a couple of steps, it may happen that the actual course followed makes an obtuse angle to the original end
07:33:15 <skypers> you mean
07:33:23 <skypers> fetch the events
07:33:25 <DMcGill_> then you take the result from treatEvents and display it or whatever
07:33:31 <skypers> then pass them to treatEvents ?
07:33:32 <DMcGill_> no IO needed inside treatEvents
07:33:34 <DMcGill_> yes
07:33:37 <skypers> hm
07:33:40 <skypers> ok
07:33:45 <skypers> so maybe something like
07:33:47 <merijn> DMcGill_: There is if his handling does IO...
07:34:02 <skypers> treatEvents :: Event -> a -> a
07:34:02 <DMcGill_> true, but that might well not be the case
07:34:10 <skypers> where a is something that can be altered
07:34:11 <shergill> ski: sure, especially if the side-effects compound
07:34:17 <merijn> skypers: Yeah
07:34:48 <skypers> what’s the need for State here?
07:35:01 <merijn> skypers: There's never a *need* for State, but sometimes it's nice
07:35:13 <DMcGill_> if your program is simple enough that your loop looks something like `events <- getEvents; newWorld = treatEvents events oldWorld; display newWorld; *repeat*'
07:35:13 <skypers> I don’t really understand when
07:35:15 <mbrock> DMcGill_ wasn't referring to State as in "the State monad"
07:35:16 <DMcGill_> that's really nice
07:35:17 <merijn> skypers: You could rewrite it as "treatEvents :: Event -> State a ()"
07:35:31 <mbrock> he meant Event -> MyGameState -> MyGameState
07:35:39 <DMcGill_> yeah skypers sorry, that was needlessly ambiguous of me. mbrock is quite right
07:35:47 <skypers> ok
07:35:58 <skypers> so we’re okay then
07:36:50 <skypers> btw, State is for computation that returns a value and another computation, right?
07:37:08 <skypers> I know the typical example; I mean random generator
07:37:11 <mbrock> if you're curious about more sophisticated ways to do event-based programming in a pure way, check out "functional reactive programming"
07:37:18 <ski> shergill : so, the point is, if we aren't careful, after a couple of steps, the means selected may actually counter the original goal
07:37:53 <DMcGill_> skypers: State is just returning two values, one of which gets threaded through the computations
07:37:56 <DMcGill_> doesn't need to be a computation
07:38:32 <DMcGill_> something like: let (a, s') = function1 s; (b, s'') = function2 s' in (a+b, s'')
07:38:52 <DMcGill_> would be do {a <- function1; b <- function 2; return (a+b)} using the State monad
07:39:10 * hackagebot hi 0.0.4 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-0.0.4 (DaisukeFujimura)
07:39:19 <DMcGill_> I'm pretty sure the haskell wiki, RWH and LYAH all have sections on the State monad.
07:39:28 <skypers> yeah
07:39:36 <skypers> and describes it as something for generators
07:39:49 <DMcGill_> see how each new s or s' is just passed to the next function? State simply abstracts that
07:40:11 <DMcGill_> for RNGs, the current state is the next computation but that needent be the cast
07:40:19 <DMcGill_> case*
07:40:27 <skypers> I see
07:40:27 <shergill> ski: you could even tie it with approaches which might be locally optimal, but not only are they globally suboptimal, they're less robust to multi-modal distributions and so more likely to be stuck in local peaks
07:40:31 <skypers> sounds great
07:40:41 <skypers> I’m learning how to correctly use all mtl monads
07:40:58 <skypers> I know Writer for monoids, Reader I’m quite confusing it, and State never used
07:42:08 <DMcGill_> they're all similar enough in that there is an extra value hidden in the monad that gets passed around. In Writer you can only add to it using mappend, in Reader you can only read it and in State you can read, write and modify it.
07:42:48 <skypers> DMcGill_: so what’s RWS for?
07:42:50 <shergill> ski: of course all that can be for nought if you know before hand that your distribution is, say, unimodal. i'm willing to concede that there are attributes of haskell which make it better for certain kinds of workflows and projects, and that *some* of those constraints follow from how most humans are and what our common intellectual bottlenecks are, but probably not *all*
07:44:17 <dmwit> skypers: RWS is for when you have one of each. =)
07:44:21 <DMcGill_> skypers: it's my understanding that that's just three values in the state - one you can read, one you can mappend to and one you can modify at will. The three monads all at the same time really.
07:45:26 <mbrock> I found it quite enlightening to reimplement Reader, Writer, and State
07:45:29 <ski> shergill : elaborate on unimodal vs. milti-modal ?
07:45:45 <DMcGill_> ^^ what mbrock said
07:45:55 <DMcGill_> I'd really recommend it
07:46:32 <mbrock> it turns out not to take much code at all, and you're forced to understand more clearly how they work :)
07:46:42 <quchen> skypers: RWS just combines all three of them. Instead of using RWS, you could also use State and keep track of "the state", "the monoid to write to" and "the environment" explicitly. That has some drawbacks though, for example it would allow you to modify the environment.
07:47:43 <quchen> skypers: In terms of transformers, I don't think there's much of a difference between Reader (Writer (State)) and RWS, beyond that the latter can have a hand-tailored Monad instance that may be more efficient.
07:47:50 <shergill> ski: think about it from optimization. optimizing a monotonic function is easy, you just keep following the gradient. but when the function has more than one peak (or trough) then things get trickier. like you said you may be initially be going in generally the right direction, but over time your moves may lead you to suboptimality
07:48:02 <shergill> which in present context would correspond to getting stuck in a local peak
07:48:05 <bartavelle> is that even possible to use "builtin" gcc functions without using the FFI and paying for a function call ?
07:48:34 <geekosaur> ghc doesn't use gcc as a backend
07:48:41 <quchen> skypers: RWS is really just "r -> s -> (a, s, w)", i.e. all three mashed together.
07:48:56 <bartavelle> so the only hack would be hacking ghc ?
07:49:20 <DMcGill_> ok edwardk I give up with Comonad (Pretext s), do you have the answer to hand? I even looked at lens' Pretext but it seems to be quite different to this formulation.
07:49:40 <tikhon> bartavelle: you might be able to write something in C--, I think
07:49:48 <geekosaur> you're missing an implication there. ghc does not use gcc at all; there is no guarantee that gcc internals will even work
07:49:57 <geekosaur> even if youy go the FFI route
07:49:59 <tikhon> there was a talk at the NY Haskell group about this, but I missed it
07:50:22 <tikhon> but yeah, this also assumes you can replicate the builtin without relying on GCC
07:50:22 <bartavelle> geekosaur, ah, interesting, it seems to link though
07:50:24 <DMcGill_> and given that I'm now three days behind on articles I feel I should probably move on :)
07:50:25 <bartavelle> didn't test the result
07:50:40 <geekosaur> some of them may. some of them are actually instructons to gcc's code generator, which isn't being used
07:51:03 <eikke> yes, so there's nothing to call into
07:51:08 <bartavelle> tikhon, ok, seems to hard for me then ;)
07:51:15 <geekosaur> some of them may have bothg aspects, or rely on parts of gcc's runtime that aren't active
07:51:25 <tikhon> bartavelle: what exactly did you want to do?
07:51:40 <bartavelle> https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication-part-2 / No-Prize opportunity #3
07:51:42 <geekosaur> so, while it might be possible in some cases, it's risky and may be fragile across gcc or even ghc versions
07:51:50 <bartavelle> seemed really simple, but now I can see it's not
07:52:56 <tikhon> does __builtin_clz just end up using a SIMD instruction or something?
07:53:05 <tikhon> or a normal instruction, come to think of it
07:53:19 <bartavelle> it is a normal instruction
07:53:23 <tikhon> yeah
07:53:27 <eikke> even using cmm wouldn't work I think, unless the codegen already knows about clz
07:53:28 <ski> shergill : well, not only suboptimally, but actually some times moving downslope
07:53:49 <tikhon> I think getting GHC to output some particular instruction might be tricky
07:53:54 <eikke> indeed
07:54:01 <ski> shergill : but ok. and the modality ?
07:54:02 <tikhon> you could try modifying the resulting assembly by hand to run the benchmarks :)
07:54:11 <tikhon> how hard can it be?
07:54:19 <eikke> I tossed something related to SPJ during a drink at last ICFP -> inline assembly for Haskell :-P
07:54:39 <bartavelle> eikke : that would be quite useful in many situations
07:54:43 <mauke> http://mauke.hopto.org/stuff/haskell/hell.hs
07:54:51 <eikke> I had such situation at hand right before :)
07:55:00 <satc> @hoogle (a -> IO ()) -> (a -> IO ()) -> a -> IO ()
07:55:01 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:55:01 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:55:01 <lambdabot> Graphics.Rendering.OpenGL.GL.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:55:28 <tikhon> maybe just try it *with* the FFI, to see how fast it is?
07:55:34 <bartavelle> it is slow
07:55:36 <eikke> mauke: that's evil :P (although I did +- the same in Python once to access cpuid)
07:55:48 <shergill> ski: well multimodal just means you have more than one peak. so you could get stuck in the wrong peak
07:55:51 <geekosaur> (and yes, saying which one changes things. that one is both an instruction to the code gen and provided as a (necessarily slower) function)
07:56:05 <enthropy> there's also this http://hackage.haskell.org/package/harpy
07:56:06 <mauke> eikke: how do you do it in python?
07:56:11 <geekosaur> (and diddling the flags register in a function is ... iffy)
07:56:35 <ski> shergill : oh, i see
07:56:40 <ski> ty
07:56:58 <eikke> mauke: https://gist.github.com/NicolasT/244744/
07:57:06 <geekosaur> (because function call setup/teardown conceivably may modify the flags!)
08:00:03 <mauke> eikke: whoa, that's a lot of code
08:00:17 <satc> IO a -> IO b -> IO a
08:00:24 <eikke> mauke: it does more than your code as well ;-)
08:00:27 <satc> @hoogle IO a -> IO b -> IO a
08:00:28 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
08:00:28 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
08:00:28 <lambdabot> Control.OldException finally :: IO a -> IO b -> IO a
08:00:50 <dagano> basic question about purity : I understand basic def of purity as always getting the same output for a given input..when it comes to IO, is it just not pure because the state of the machine can influence the input.  i mean, naively, i can supply the same value to getChar right?
08:01:10 <eikke> bartavelle: you could try using LLVM? not sure what the overhead of calling an LLVM
08:01:13 <eikke> 'function' is
08:01:32 <mauke> dagano: supply? getChar isn't a function
08:02:49 <shergill> ski: np
08:02:55 <dagano> mauke: it is a computation? ie a recipe for how to get a char?
08:03:28 <DMcGill_> satc: what function of that type are you looking for? Run both IO actions and return the result of the first?
08:04:04 <mbrock> dagano: getChar is just a constant value
08:04:09 <mauke> dagano: well, that's what it represents. from inside Haskell it's a value of type IO Char, which is abstract
08:04:30 <mbrock> the recipe is always the same :)
08:04:58 <mauke> yeah, it's like that "ls" quote
08:05:01 <quchen> @quote ski getline
08:05:01 <lambdabot> ski says: <ski> `getLine :: IO String' is a recipe for how to interact with the world to acquire a `String'  <ski> the recipe is not the cake
08:05:06 <DMcGill_> @pl fun f s = f s a
08:05:06 <lambdabot> fun = flip flip a
08:05:11 <mbrock> and if you do, e.g., getChar >>= \x -> print x, then you just have two recipes tied together
08:05:27 <ski> @quote /bin/ls
08:05:27 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
08:05:51 <dagano> ski: nice . interesting
08:06:03 <mbrock> so you build up a big complex recipe, and then at some point you return it out through "main"
08:06:11 <dagano> i'm just trying to get a handle on purity .. is a fcn pure iff it has no side effects?
08:06:14 <dagano> is that pretty much it?
08:06:28 <mbrock> what happens after that is anyone's guess, and purity isn't relevant anymore (:
08:06:44 <ski> yep
08:07:02 <ski> dagano : every function in Haskell is pure
08:07:10 <mbrock> yeah, a pure function is basically a mapping from the domain to the codomain
08:07:27 <mbrock> if the domain is finite then you can write the function as a lookup table
08:07:33 <ski> (including `putStr :: String -> IO ()')
08:08:30 <dagano> ok thanks, channel
08:12:50 <merijn> dagano: Similarly, this also explains why "putStrLn" is pure, it is a function that returns a "recipe" for printing it's argument. Provide the same argument, get the same recipe (i.e. pure/referentially transparent) :)
08:14:37 <exicer> Could anyone critique a (probably terrible) program I have written ?
08:14:41 <exicer> Its only 80 lines or so
08:14:46 <mauke> "this code sucks!"
08:14:56 <merijn> dagano: btw, the clearer definition of "pure" would be "referentially transparent", a function is referentially transparent if the same input argument always produce the same result. Which means that you can replace any name/expression with the definition of that name and not change the meaning/result of the code
08:15:08 <Taneb> exicer, paste it somewhere and we'll have a look :)
08:15:34 <mbrock> 80 lines of haskell is massive ;)
08:15:48 <exicer> I'm sure its wildly inefficient, and could be much less!
08:16:01 <exicer> http://lpaste.net/91968
08:16:08 <dagano> i like the recipe analogy : so if i have f = Char -> IO () and i supply it two values : a1, a2 ... if a1 == a2, i get the same 'recipe' (namely, try to write a1 to the screen), but it can't be described as a pure fcn mapping input -> screen, because the state of the machine can intervene and the screen output is not guaranteed?
08:16:16 <merijn> dagano: i.e. given the definition "map f (x:xs) = f x : xs" means I can replace "map (+1) (1:xs)" with "(+1) 1 : map (+1) xs" and get the same result
08:16:41 <quchen> exicer: max 80 characters per line, please. :-)
08:16:54 <exicer> Ah, good point
08:16:58 <exicer> I got a bit carried away..
08:17:01 <merijn> dagano: It *is* a pure mapping, the thing is that IO can't be executed in Haskell
08:17:03 <mauke> dagano: right, that's why putChar doesn't return a screen
08:17:14 <merijn> dagano: Haskell can only chain IO together
08:17:19 <quchen> exicer: Also have a look at the bottom, LPaste automatically applies HLint to your code and gives you suggestions.
08:17:31 <exicer> Huh, didn't know that
08:17:49 <merijn> dagano: You might wonder "But what executes IO then?" and the answer is "the runtime system", which is not pure at all (since it does things like threading, IO, etc.)
08:17:51 <exicer> I suppose I should get HLint then
08:18:03 <dagano> AH, CLARITY!!
08:18:10 <merijn> dagano: It's jusst that the *interface* between the runtime and haskell *is* pure
08:18:18 <quchen> exicer: makeMP is not total, it will crash when you give it inputs of length <= 3. That's not good.
08:18:31 <Taneb> exicer, in line 33, why not use Data.Text.lines?
08:18:33 <quchen> Also it assumes the input texts are always given in an informally specified ordering.
08:18:47 <merijn> dagano: In fact, IO is really just a DSL for using haskell to create imperative programs for the runtime to execute
08:19:01 <exicer> Taneb: Good question..
08:19:25 <exicer> quchen: Hm okay. So I should raise an exception instead ?
08:19:30 <quchen> exicer: Another good thing to do is to compile your program with -W, GHC warns about quite a few pitfalls.
08:19:31 <exicer> if it is less
08:19:55 <quchen> exicer: That's up to you. Exceptions are generally a bad idea, think of using Maybe, or better yet, a dedicated data type.
08:19:57 <merijn> dagano: Hence the reason why many people here consider Haskell their favorite imperative language :)
08:20:11 <exicer> quchen: Okay. I don't know anything about compiler options at this point. Any others I should know about /
08:20:29 <quchen> exicer: e.g. instead of requiring "id:first:second:party", make a type "data MP = MP <id> <first> <second> .."
08:20:31 <exicer> quchen: Hmm, okay. One thing I struggled a bit with was having so many maybes everywehre..
08:20:34 <quchen> And then fill the list with MPs
08:21:10 <dagano> merijn: thanks for the help, more basic questions to come
08:21:17 <quchen> exicer: Line 42 is just fmap: fmap (\x -> MP x first second party) $ handleInt id
08:21:35 <quchen> exicer: Gotta go now though.
08:21:51 <merijn> dagano: It's really neat insight, I keep meaning to write an "IO as recipes/program fragments" explanation of the IO monad, but I keep procrastinating it :)
08:21:53 <exicer> quchen: No problem, thanks for the help :)
08:23:04 <merijn> dagano: Actually, using the "getLine-as-ls" example you can extend the analogy by saying that >>= is your shell's pipe | operator :)
08:23:28 <merijn> "getLine >>= putStrLn" being similar to "ls | cat"
08:24:11 <dagano> merijn: yes.  bind is just sequencing operations.
08:26:19 <mauke> heh
08:26:39 <mauke> the next time someone wants to learn about IO and >>=, I should ask them if they're familiar with perl's DBIx::Class
08:27:33 <mauke> https://metacpan.org/module/DBIx::Class::ResultSet#DESCRIPTION has a similar structure
08:27:56 <quicksilver> I secretly feed haskell propaganda into #dbix-class
08:28:38 <tikhon> hmm, to somebody unfamiliar with DBIx::Class: what's so Haskellish about it?
08:28:40 <mauke> a resultset represents a "recipe" for getting data from a DB. you can chain ->search on it to refine your results
08:28:44 <mbrock> exicer: I don't have time to read it carefully but generally it's really nice if you can get the type signatures to be kinda descriptive
08:28:54 <mauke> and what ->search returns is simply a new resultset
08:29:27 <mauke> only at the very end do you actually run it, and that's where DBIx::Class collects all your search conditions and generates SQL
08:29:31 <ski> merijn : strictly speaking, i think "referential transparency" isn't quite that. according to Quine (quoted) in "Referential transparency, definiteness and unfoldability" by Harald Søndergaard,Peter Sestoft in 1990 at <http://www.cs.tufts.edu/~nr/cs257/archive/peter-sestoft/ref-trans.pdf>, "referentially transparent" is a predicate which can be applied to *contexts*, and which holds whenever that context "preserves substitutivity of identity" (a
08:29:51 <mbrock> exicer: using type synonyms, custom data types, and skillful factoring... :) it's a fun way to design programs, thinking "how can I make this type signature more informative?"
08:30:09 <ski> (possibly missing bit : ".. <http://www.cs.tufts.edu/~nr/cs257/archive/peter-sestoft/ref-trans.pdf>, "referentially transparent" is a predicate which can be applied to *contexts*, and which holds whenever that context "preserves substitutivity of identity" (a big mouthful)")
08:30:20 <merijn> ski: Right, but that seems a bit overkill for providing an intuitive explanation of what referential transparency means to newbies :)
08:30:30 <tikhon> ski: there was an epic argument about this either on StackOverflow or haskell-cafe (or, if I remember correctly, both). I think it's a contentious issue :P.
08:30:33 <ski> @where purely-functional
08:30:33 <lambdabot> "What is a Purely Functional Language?" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>
08:31:05 <mbrock> exicer: dividing the code into two modules, one for "parsing" and one for "computing" might also be nice
08:32:09 <ski> merijn : yes, i agree we don't seem to have much better alternatives (at least not in so far i understand the concepts yet) -- just noting that it would be nice with something better
08:32:13 <mbrock> it's appropriate to be careful about quoting when you're quoting Quine :)
08:32:23 <ski> tikhon : link ?
08:32:54 <tikhon> Here's the SO question: http://stackoverflow.com/questions/210835/what-is-referential-transparency
08:33:23 <exicer> mbrock: Could you go into a bit more detail with the type synonyms and so on? This is the first haskell program I've written :p
08:33:33 <mbrock> exicer: oh, cool :)
08:34:33 <tikhon> ski: also, some reddit discussions: http://www.reddit.com/r/haskell/comments/x8rr6/uday_reddy_on_referential_transparency_and_fp/
08:34:45 <tikhon> http://www.reddit.com/r/haskell/comments/xgq27/uday_reddy_sharpens_up_referential_transparency/
08:35:07 <mbrock> exicer: for example, textToVotes returns a Maybe (Int, [Int]), which is a rather general type to someone who's not familiar with exactly how your code works
08:36:23 <exicer> mbrock: Ahh, okay
08:36:38 <mbrock> exicer: sometimes just a simple type alias can help readability, e.g., type Vote = Int (I don't know if that example makes sense in your code)
08:36:55 <eikke> bartavelle: did you check what __builtin_clz gets compiled into?
08:37:02 <danharaj> type aliases hurt readability
08:37:17 <danharaj> because they force you to look up the type synonym in order to understand the code
08:37:54 <danharaj> newtypes are better because at least then instances of the newtype are tagged with constructors
08:38:12 <ski> merijn : possibly it doesn't matter so much if we conflate different concepts that happen to coincide in Haskell
08:38:40 <mbrock> yeah, I agree that newtypes are usually better...
08:38:46 <mbrock> and safer
08:38:48 <tomejaguar> type aliases can be a useful refactoring step
08:39:07 <mbrock> yep, kinda what I meant to say
08:39:19 <ski> (however, i'm not sure whether this would be the case for "referential transparency", which is about contexts rather than expressions)
08:40:05 <exicer> So newtypes are like lesser aliases ?
08:40:58 <mauke> @quote mauke newtype
08:40:58 <lambdabot> mauke says: <mauke> a newtype is like an existing type but wearing glasses and a fake mustache  <mauke> and a sign saying "you've never seen me before"
08:41:46 <exicer> Hah, okay
08:41:56 <magneticduck> ahha
08:42:03 <mbrock> :D e.g. newtype Cents = Cents Integer is a nice way to make it explicit that you're dealing with cents and not just any integer value
08:42:22 <exicer> That makes sense
08:42:28 <magneticduck> well, for most people, a simple "type Cents = Integer" would be acceptable
08:42:45 <magneticduck> but if the Cents has some special properities (e.g., you want it to be a number in a different way
08:42:53 * eikke seems not to be part of most people
08:43:12 <magneticduck> you are not part of most people?
08:43:14 <mbrock> yeah, but then you can have type Dollars = Integer and accidentally use one as the other :)
08:43:22 <magneticduck> *ahem*
08:43:28 <magneticduck> well
08:43:38 <magneticduck> most people in my small experience just use Type for something like that
08:43:40 <magneticduck> *type
08:43:43 <eikke> magneticduck: if something is Cents, I would newtype-wrap whatever, not type Cents = whatever
08:43:58 <magneticduck> newtype is when you want to make some real changes in how it's implemented in some typeclasses
08:44:09 <merijn> magneticduck: Or prevent arguments to a certain function
08:44:14 <magneticduck> and remember, if you're using a newtype cents... it's not going to be a number by default
08:44:15 <eikke> magneticduck: disagree
08:44:19 <magneticduck> >:<
08:44:21 <mbrock> it's also for type safety and abstraction!
08:44:31 <ski> tikhon : ty
08:44:36 <magneticduck> yes, I see your point
08:44:38 <merijn> i.e. don't allow Cents to be passed to a function taking Dollars when both are "newtype Cents = Cents Int" and "newtype Dollars = Dollars Int"
08:44:41 <magneticduck> it would be a cleaner way of doing it
08:44:57 <magneticduck> but it seems to me that in a lot of cases, it isn't worth the extra effort to make it a newtype
08:45:31 <mauke>  deriving (Eq, Ord, Read, Show, Num)
08:45:34 <magneticduck> yeah
08:45:37 <magneticduck> well
08:45:40 <eikke> there's not much effort, and making a Num instance (using GeneralizedNTDeriving) reduces it even more
08:45:46 <tikhon> magneticduck: it's not that much extra effort, especially if you use GeneralizedNewtypeDeriving (although that's a slightly dangerous extension)
08:45:48 <cschneid> is there an easy way to say "I will but a literal 10 in my code", and have the type system automatically coerce that to a Cents instance?
08:45:49 <mbrock> i like to do things like have newtypes for UserId and PostId (or whatever), so there's a type error when I pass a post id instead of a user id, it's one of the pleasures of Haskell :)
08:45:52 <tikhon> the newtype package is also nice, from what I've heard
08:45:53 <merijn> exicer: See also: http://www.haskell.org/haskellwiki/Newtype
08:45:55 <magneticduck> then why is there always a syntax for making "types"?
08:46:07 <magneticduck> I mean, I understand what you're all saying
08:46:14 <magneticduck> and it makes sense
08:46:16 <mbrock> cschneid: yeah, in this particular case you can just derive Num, I think
08:46:20 <merijn> magneticduck: I tend to use "type" for hiding very long types
08:46:22 <tikhon> cschneid: that's exactly what giving your newtype a Num instance does
08:46:30 <cschneid> sweet.
08:46:30 <magneticduck> ah, just to shorten stuff
08:46:31 <mbrock> cschneid: because integer literals are generic
08:46:35 <magneticduck> alright
08:46:37 <merijn> magneticduck: "type Foo a = a -> Maybe a -> Either e a -> Bar"
08:46:37 <eikke> cschneid: yes, that's how all numeric literals are handled, using fromIntegral (otoh)
08:46:44 <mbrock> cschneid: 10 expands to fromIntegral 10, basically
08:46:49 <cschneid> sweet.
08:46:51 <magneticduck> mkay
08:46:56 <magneticduck> well I'll stop using types in my code then
08:47:00 <merijn> magneticduck: Now I can write "Foo a -> Foo a -> Foo a" rather than a really ugly type signature
08:47:04 <mbrock> there's a language option to do the same with "string literals"
08:47:14 <tikhon> I really love overloaded literals
08:47:16 <cschneid> but yeah, I need to type more things I do. I also need to go grok how to write foldable instances for the problem I'm working on
08:47:23 <eikke> magneticduck: there *are* good cases for 'type', instead of newtype
08:47:36 <exicer> merijn: Cheers, I'll have a look.
08:47:38 <merijn> magneticduck: Well, I occasionally use types for semantic clarity, but if you have things that could be confused it's a nicer API to enforce protection against this
08:47:56 <cschneid> hey, what module / library should I use for a generic tree?  I have a tree that I want to build, and each node in the tree has a few bits of data.
08:48:11 <merijn> "type Foo a = StateT MyState IO a" for example
08:48:28 <tikhon> cschneid: Data.Tree, maybe?
08:48:43 <eikke> magneticduck: data Person = ...; type People = Set Person (just making something up here...), there's not much use in newtype'ing 'People'
08:48:58 <magneticduck> yeah
08:49:16 <magneticduck> I wasn't giving much thought to composite types
08:49:23 <tikhon> cschneid: it basically defines data Tree a = Node a [Tree a]
08:49:24 <magneticduck> type constructors
08:49:29 <cschneid> tikhon: ok, I'm terrible. I started looking for Trie since logically that's what I'm building. But for my first impl, I want a more generic style
08:49:32 <merijn> magneticduck: The difference with these examples that you can't accidentally "pass the wrong type"
08:49:42 <mbrock> newtype is for introducing a new concept you could say
08:49:43 <cschneid> tikhon: yeah, that's what I have built manually using types, but I figure  a library would make it cleaner
08:49:56 <merijn> magneticduck: They're just nicer/clearer ways to write a type, whereas Cents/Dollars lets you accidentally make semantic mistakes
08:50:05 <tikhon> cschneid: don't worry: I wrote a pretty large program with my own hand-rolled trees before discovering Data.Tree myself :)
08:50:36 <cschneid> tikhon: but yeah, that 'a' type is perfect for what I need. I basically have the same shape, except I merged the `a` type with the [Tree] part.
08:50:49 <cschneid> ok, time to do day job work. And consider how I want to do this later
08:50:53 <mbrock> the concept Cents is not substitutable for the concept Int :)
08:51:15 <mbrock> but People = Set Person makes sense as an equivalence
08:56:00 <Peaker> my biggest gripe with shake was that the lack of safety when changing the build system itself.  But if I add the hash-of-all-actual-inputs to my output filenames, then changes in the build script should be safe. Unfortunately, I think shake requires deciding the output file name before looking at any of the inputs
08:58:04 <cschneid> mbrock: how would you model the idea of "currency" which could manifest as Cents, Dollars, MegaDollars
08:58:15 <cschneid> mbrock: or similarly Volt, Milivolt, etc.
09:02:22 <tikhon> cschneid: you would have to normalize values somehow
09:02:50 <cschneid> tikhon: so one option is newtype each one: newtype Cents, newtype Dollars, etc. And have explicit functions to convert between
09:03:03 <cschneid> tikhon: another is to convert to Cents at the borders of my app, and not worry about it till spinning them back out
09:03:07 <tikhon> yes
09:03:17 <cschneid> tikhon: and I've seen the ... unittyped library which attempts to get clever at this with crazy type sigs I don't understand
09:03:21 <tikhon> take a look at http://hackage.haskell.org/package/unittyped for a fancy type-based
09:03:24 <tikhon> er
09:03:27 <tikhon> yeah, that library
09:03:45 <cschneid> I have to say I have no idea what's going on in it, but it was sorta slick to play with
09:04:02 <cschneid> I like looking at our overly large ruby app I work on, and thinking about how to reimplement in haskell.
09:04:06 <tikhon> I haven't used it, but my understanding is that it takes the normalization approach with some fancy type-level computation to smooth everything out
09:04:19 <cschneid> (and steal ideas back to ruby land like immuatable values, and "stronger" typing [within the realm of what ruby can do])
09:04:39 <cschneid> I do love learning new languages :)
09:04:39 <tikhon> I don't think Ruby can do very much though, unfortunately :/
09:04:48 <cschneid> tikhon: it can't, but you can borrow ideas back for sure.
09:04:54 <tikhon> ie all the unittyped stuff is in the type system
09:05:32 <cschneid> but like even the idea of separating calculations from io is powerful. The idea of a maybe type is powerful, etc.  All borrowable back to ruby
09:05:43 <tikhon> oh yeah, no questions there
09:05:56 <tikhon> I remember seeing a pretty good set of slides about exactly that, in Ruby.
09:06:01 <cschneid> I think I'm pretty far from convincing coworkers to do haskell yet :)
09:06:05 <tikhon> but I can't remember what the talk was called :(
09:07:09 <Peaker> cschneid, not sure there's much benefit to something like "Maybe" in a dynamic language without sum type support
09:07:29 <cschneid> Peaker: well, you can mimic a lot of that with the type system.  And conciously forcing yourself to avoid nil is a good idea no matter way
09:07:30 <cschneid> what
09:07:31 <tikhon> Peaker: at the very least, you can write functions like map and such
09:07:38 <cschneid> s/type system/ object system/ sorry
09:08:14 <cschneid> it doesn't help to go TOO far into it, but you can at least get better error messages, as opposed to just transmitting a nil across a ton of code (god I hate that)
09:08:32 <Peaker> cschneid, Not sure a Maybe's Nothing will generate a much nicer error than a nil
09:08:51 <cschneid> Peaker: hah, maybe an either then :)
09:09:11 <cschneid> but yeah, I don't know, but it's worth thinking about, and ruby already half-assedly implements maybe with its .try(:method, args) syntax.
09:09:17 <cschneid> at least the chaining support
09:09:33 <ocharles> Peaker: I agree. once you get sum types you get a lot of power
09:09:41 <ocharles> but without that, emulating them rarely works well
09:09:44 <cschneid> what do you mean sum types?
09:09:57 <ocharles> cschneid: the ability for their to be different values under the same type
09:10:08 <ocharles> data Maybe a = Just a | Nothing -- two distinct types of values for 'Maybe a'
09:10:13 <cschneid> ahh, like data Foo = Foo | Bar?
09:10:17 <ocharles> yep
09:10:30 <ocharles> read '|' as '+' :)
09:10:38 <cschneid> right. I just didn't know the general term for that :)
09:10:48 <ocharles> (data Foo = Foo Bar Baz is called a product type)
09:12:40 <mbrock> cschneid: one basic idea is to have a Money typeclass defining toCents
09:14:59 <cschneid> mbrock: I see that sometiems, like the Sum type and the Product type that define getSum and such, what's the term to figure out how that works?
09:15:10 <cschneid> or are those just clever names for record syntax
09:15:44 <DMcGill_> cschneid: those are Monoids
09:15:58 <cschneid> DMcGill_: well, they're just data types that implement the monoid interface right
09:16:06 <DMcGill_> the easiest explaination is to consider the All and Any monoids
09:16:25 <DMcGill_> yep. The key is their definition of mappend - both All and Any are just newtypes for Bool
09:16:55 <byorgey> cschneid: 'getSum' and 'getProduct' are just record syntax.
09:17:10 <DMcGill_> > All True <> All False
09:17:12 <lambdabot>   All {getAll = False}
09:17:20 <DMcGill_> > Any True <> Any False
09:17:24 <lambdabot>   Any {getAny = True}
09:17:26 <byorgey> it's a common idiom for auto-generating an unwrapping function for a newtype
09:17:54 <ski> > mempty :: Product Integer
09:17:54 <ski> > mempty :: Sum Integer
09:17:55 <lambdabot>   Product {getProduct = 1}
09:17:55 <lambdabot>   Sum {getSum = 0}
09:18:01 <byorgey> DMcGill_: were you asking about monoids, or about record syntax?
09:18:07 <byorgey> er, cschneid, rather
09:19:28 <bartavelle> in https://www.fpcomplete.com/user/edwardk/cellular-automata#a-glimpse-down-the-rabbit-hole , it says that writing the Comonad instance is for the advanced haskeller
09:19:44 <bartavelle> is the fact that it typechecks sufficient to convince me I did it right ?
09:20:15 <cschneid> byorgey: just understanding what getSum really was. It's the autogenerated function to unwrap that data type
09:20:27 <byorgey> cschneid: right.
09:20:30 <bartavelle> because it doesn't seem that hard, and I do not understand much of the things in this article ...
09:22:14 <bartavelle> except that my definition of extract might be partial now that I look at it ...
09:23:01 <applicative> hah, this is for 'Pretext' bartavelle
09:23:02 <applicative> ?
09:23:05 <bartavelle> yes
09:23:21 <applicative> oh I see yeah.
09:23:28 <applicative> I was doing it with someone the other day
09:23:28 <bartavelle> I have absolutly no intuition for that Comonad stuff, so I thought it might help
09:23:37 <bartavelle> but I guess this didn't help at all :)
09:23:53 <bartavelle> can I just choose any functor I'd like for implementing extract ?
09:24:08 <skypers> 16:45 < mbrock> I found it quite enlightening to reimplement Reader, Writer, and State
09:24:13 <skypers> I will for sure!
09:24:51 <applicative> bartavelle: yes, it's existential; but i'm not looking at it so may be in a muddle
09:24:54 <applicative> we used Identity
09:25:00 <bartavelle> ahhhhhhhh
09:25:10 <applicative> wait maybe i shouldn't have said that if youi haven't done it yet ;)
09:25:33 <bartavelle> I used list, but as I have no clue what "extract" means, it might be partial
09:25:39 <bartavelle>     extract p = head (runPretext p (:[]))
09:25:45 <bartavelle> not sure what "head" will run with
09:26:02 <applicative> how did you do duplicate bartavelle >
09:26:02 <applicative> ?
09:26:10 <bartavelle>     duplicate l = fmap (const l) l
09:26:34 <bartavelle> It'll be nicer with Identity
09:26:42 <DMcGill_> bartavelle: I was talking to edwardk about this earlier, apparently that duplicate violates the laws and loses information
09:26:57 <bartavelle> ah :(
09:27:04 <bartavelle> there are laws now !!!! :)
09:27:28 <DMcGill_> your extract seems equivalent to using Identity though. I've given up for now on defining duplicate, even with the hint to use Compose :( Applicative, can just just tell me the answer please?
09:27:56 <bartavelle> what's Compose ?
09:28:01 <DMcGill_> @hoogle Compose
09:28:23 <DMcGill_> http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Data-Functor-Compose.html
09:28:38 <applicative> Compose f g a = Compose (f (g a))
09:28:53 <lambdabot> Data.Functor.Compose Compose :: f (g a) -> Compose f g a
09:28:53 <lambdabot> Data.Functor.Compose newtype Compose f g a
09:28:53 <lambdabot> package compose-trans
09:29:00 <DMcGill_> I suspect you make use of the fact that Pretext s (Pretext s a) ~~ Compose (Pretext s) (Pretext s) a and is a functor
09:29:10 <bartavelle> ah
09:29:12 <DMcGill_> but I couldn't figure it out any further
09:29:56 <DMcGill_> since, unlike in extract where you get to pick the functor, in duplicate you don't.
09:30:12 <bartavelle> yeah it must work for all
09:30:40 <applicative> which tells us what we can use; just fmap ...
09:31:40 <bartavelle> applicative: can you explain "intuitively" what Pretext represents and/or what's wrong with the "const" approach ?
09:32:21 <applicative> I'm not going to try to explain Pretext
09:33:01 <applicative> did you see the next post, developing this a bit, the one not by kmett>
09:33:28 <bartavelle> I suppose I did not, is it linked in the kmett post ?
09:33:54 <bartavelle> Piponi post from 2006 ?
09:35:05 <DMcGill_> bartavelle: https://www.fpcomplete.com/user/tel/pretext-by-experiments-and-guesses
09:35:12 <bartavelle> ah thanks
09:35:14 <yakov> hello :)
09:35:31 <applicative> oh there it is; hard to find from the fpcomplete frontpage
09:35:48 <DMcGill_> I don't know how to get to https://www.fpcomplete.com/recent-content from the frontpage
09:35:49 <yakov> whom I should disturb if I want to change record on Hackage and don't want upload new version of package? :-)
09:36:02 <yakov> my email expired long ago and i noticed it today
09:36:11 <yakov> the email which is listed @ hackage
09:39:00 <applicative> byorgey: hey nice pdf backend now, I see.
09:39:13 * hackagebot SimpleH 0.9.1 - A light, clean and powerful Haskell utility library  http://hackage.haskell.org/package/SimpleH-0.9.1 (MarcCoiffier)
09:40:35 <yakov> oh, this is cool. i can edit cabal files now! long time since i was on hackage!
09:41:57 <yakov> oh, no, that sucks. can't "publish new version" with just email updated for some reason. fuck.
09:44:35 <mebaran151> I've got a quick question about hspec; is it possible to run an IO action before the all the items in a describe block?  I have an expensive DB query I would like to run once for a suite tests.
09:45:26 <mebaran151> Also in cabal, is it possible to have the build-depends for the test exactly mirror the build-depends of the project, except it would add a couple of extra dependencies for the tests (like hspec, etc)
09:46:13 <ParahSailin> @src when
09:46:13 <lambdabot> when p s = if p then s else return ()
09:46:42 <applicative> why not define spec :: DataBaseThing -> Spec; main = dataBaseQuery >>= hspec . spec?
09:46:52 <Okasu> > Boost - A light, clean and powerful CPP utility library
09:46:53 <lambdabot>   <hint>:1:16: parse error on input `,'
09:47:16 <_arjun> what is this in Haskell, a variable or a function
09:47:17 <_arjun> conanO'Brien = "It's a-me, Conan O'Brien!"
09:47:31 <mebaran151> applicative: I have that but then I can't use the nifty spec discovery tool.  Also it seems like a kludget to spearate the query from the describe block
09:47:32 <Okasu> Sorry, just joking, about that impertinently named SimpleH library. :)
09:47:49 <_arjun> how do we differentiate between variables and fucntions
09:47:58 <joelteon> _arjun: many things areb oth
09:48:04 <joelteon> foo = \x -> x is a variable and a function
09:48:05 <tomejaguar> _arjun: Why do you need to differentiate?
09:48:05 <glguy> _arjun: Functions have the type "a -> b"
09:48:14 <applicative> mebaran151: ah, hm...
09:48:33 <joelteon> in conanO'Brien = "It's a-me, Conan O'Brien!", conanO'Brien is a value
09:48:42 <_arjun> joelteon: so it was both?
09:48:43 <S11001001> _arjun: and insofar as variables can "vary", it's not a variable either
09:48:48 <joelteon> yeah
09:48:57 <prophile> in a pure language, values are just nullary functions
09:49:02 <glguy> _arjun: your conan'oBrien was a value, not a function
09:49:03 <glguy> http://conal.net/blog/posts/everything-is-a-function-in-haskell
09:49:23 <ReinH> zomg good morning
09:49:40 <hiptobecubic> I'm not entirely convinced it's worth making a distinction between them, since functions are first class and thus also value
09:49:41 <ReinH> time to beat my head against the wall that is comonads again
09:50:13 <ReinH> glguy: You can say that everything is a function or that everything is a value. They are isomorphic :p
09:50:25 <glguy> Not everything is a function, so you can't
09:50:41 <glguy> check out that blog post I linked to
09:50:44 <mauke> ReinH: if you use function to mean value, what do you call functions?
09:50:57 <ReinH> functions.
09:50:58 <ReinH> :D
09:51:09 <mauke> that doesn't make sense
09:51:19 <FreeFull> https://www.fpcomplete.com/user/edwardk/bound   I like this
09:51:37 <glguy> FreeFull: this isn't #facebook ^_^
09:51:38 <notdan> holy shit another article by edwardk?
09:51:49 <notdan> glguy: it's haskell-related though...
09:51:50 <edwardk> FreeFull: =)
09:51:52 <ciaranm> it must be a day ending in y
09:51:53 <edwardk> notdan: i was busy
09:52:04 <glguy> notdan: It's a joke about "like"
09:52:11 <notdan> glguy: oh, sorry
09:52:18 <applicative> oh, someone is working on Pattern Synonyms for ghc??
09:52:22 <applicative> wowzer
09:52:30 <edwardk> FreeFull: i've been touting bound for a while, so i figured it was worth writing up for the SoH
09:52:36 <ciaranm> i hear rasmus lerdorf captured edwardk and put a bomb next to his heart, and it goes off if his article publishing rate ever drops below 60wpm
09:52:36 <notdan> edwardk: do you have spare articles lying around or do you just keep writing them every day? how do you manage to be so productive
09:52:41 <prophile> edwardk doesn't write articles, he just sneezes and interesting articles appear
09:52:44 <ReinH> glguy: it's still true that everything is a function. It's just more useful to only talk abuot non-nullary functions as being functions.
09:52:45 <edwardk> notdan: i wrote that last night
09:52:59 <notdan> awesome, I like bound library
09:53:10 <edwardk> ciaranm: it also goes off if someone exposes the pl!@)#(*!)@#kkj3k1l3
09:53:57 <hiptobecubic> edwardk, you mean Graduate School of Haskell. Some of us are still plowing through our Associate's
09:54:00 <ReinH> edwardk: dude seriously stop that shit. You are making the rest of us look bad.
09:54:11 <ReinH> Just bring it back a bit.
09:54:12 <tikhon> ooh, the pattern synonym proposal looks very nice
09:54:15 <edwardk> ReinH: =)
09:54:25 <ReinH> edwardk: :D
09:54:40 <tikhon> pattern matching over abstract types is something I'm wishing for in my code at the moment
09:54:50 <joelteon> so everything is *not* a function
09:54:58 <glguy> ReinH: That simply isn't the Haskell definition of function which makes it less interesting for using in Haskell discussion
09:55:03 <FreeFull> edwardk: It's definitely worth reading
09:55:04 <edwardk> my goal is to show how deep the rabbit hole goes in the hopes that it entices more of the kind of people i like to talk to into haskell ;)
09:55:11 <prophile> joelteon: no, but not everything is a function?
09:55:21 <joelteon> right
09:55:22 <joelteon> that's what i meant
09:55:25 <ReinH> glguy: what is the haskell definition of a function?
09:55:28 <byorgey> applicative: re: diagrams PDF backend, yep, but I had nothing to do with it! =)  thanks go to alpheccar.
09:55:46 <prophile> ReinH: a morphism in Hask perhaps
09:55:48 <ReinH> byorgey: hey! diagrams is awesome so thanks for being involved with that.
09:55:53 <edwardk> byorgey: *whip* back to the diagrams mines with you. we need hierarchical backends ;)
09:56:10 <edwardk> byorgey: but seriously, i do love diagrams
09:56:13 <glguy> ReinH: functions are values with type "_ -> _"
09:56:27 <nicoo> [5~/sb end
09:56:31 <byorgey> ReinH: thanks! =)
09:56:33 <nicoo> Oops
09:56:33 <FreeFull> Return, just return!
09:56:49 <byorgey> edwardk: I was thinking about hierarchical backends this morning in the shower, does that count?
09:56:57 <edwardk> byorgey: you are forgiven for dropping all my rantings on projective geometry on the ground ;)
09:57:02 <byorgey> hahaha
09:57:05 <ReinH> glguy: and where is that defined?
09:57:10 <byorgey> hey, I learned a lot from those rantings!
09:57:31 <byorgey> it's just that I don't know how to give projective transformations a monoid action on Envelopes.
09:57:34 <byorgey> =)
09:57:36 <edwardk> sure
09:57:36 <ReinH> byorgey: how's diagrams-canvas doing?
09:58:20 <byorgey> ReinH: fryguybob was maybe going to take a look at it to see about improving the efficiency.  jbracker_ is working on an alternative, diagrams-sunroof.
09:58:24 <mbrock> ls
09:58:29 <mbrock> sorry
09:58:39 <edwardk> byorgey: hrmm, i'll have to play with that
09:59:09 <byorgey> who knows where these particular efforts will go, but in the grand scheme of things we are committed to having nice support for diagrams-in-the-browser
09:59:46 <jbracker_> sunroof should work
09:59:57 <jbracker_> but i have not worked on it for some time
09:59:59 <jbracker_> because of gsoc
10:00:11 <danilo2> Hi! In haskell we have got monoids, which define mappend method. mappend for lists is simply (++). Is there any typeclass, that defines something, which is equal to (:) for lists?
10:00:39 <byorgey> jbracker_ has been unable to work on his awesome thing because his other awesome things have taken up all his time
10:00:51 <jbracker_> XD
10:00:59 <jbracker_> thats a nice way to put it
10:00:59 <edwardk> danilo2: it isn't for the faint of heart, but there is a Cons class in lens
10:01:12 <edwardk> danilo2: it defines a relationship between cons, uncons, head and tail.
10:01:26 <edwardk> :t cons 1 [2,3]
10:01:27 <lambdabot> Num t => [t]
10:01:30 <edwardk> > cons 1 [2,3]
10:01:31 <lambdabot>   [1,2,3]
10:01:32 <FreeFull> danilo2: So something like   (Cons c) -> a -> c a -> c a   right?
10:01:36 <FreeFull> :t cons
10:01:39 <edwardk> :t cons
10:01:47 <ReinH> byorgey: diagrams-sunroof eh
10:01:48 <FreeFull> :t Control.Lens.cons
10:01:49 <lambdabot> Cons Control.Lens.Internal.Review.Reviewed Identity s s a a => a -> s -> s
10:01:52 <edwardk> cons is sufficiently scary lambdabot is afraid to show it
10:02:15 <byorgey> ReinH: https://github.com/jbracker/diagrams-sunroof
10:02:32 <FreeFull> Sometimes lambdabot won't show type signatures unless you give the module name. I don't know why
10:02:35 <edwardk> basically Cons can be instantiated so that your type supports either cons-only, head/tail/uncons-only or both, and that makes it complicated
10:02:37 <edwardk> hence 'not for the faint of heart'
10:03:00 <byorgey> jbracker_: what's the status of blank-canvas?  is sunroof a replacement/successor to blank-canvas?  Or are they different?
10:03:04 <FreeFull> :t Control.Lens.uncons
10:03:05 <lambdabot> Cons (->) (Accessor (First (a, s))) s s a a => s -> Maybe (a, s)
10:03:11 <edwardk> there is a similar class for Snoc, with support for snoc,  unsnoc/init/last or both
10:03:18 <FreeFull> > uncons [1,2,3]
10:03:19 <lambdabot>   Just (1,[2,3])
10:03:36 <edwardk> by setting it up that way you can just provide one _Cons prism
10:03:50 <edwardk> > [1,2,3]^?_Cons
10:03:51 <lambdabot>   Just (1,[2,3])
10:03:54 <edwardk> > []^?_Cons
10:03:56 <lambdabot>   Nothing
10:04:00 <ReinH> byorgey: neat
10:04:03 <edwardk> > _Cons # (1,[2,3])
10:04:04 <lambdabot>   [1,2,3]
10:04:04 <FreeFull> > unsnoc [1,2,3]
10:04:06 <lambdabot>   Just ([1,2],3)
10:04:07 <edwardk> and it goes both ways
10:04:15 <ReinH> FreeFull: go snoc yourself
10:04:21 <hiptobecubic> edwardk, what is ^? ?
10:04:33 <FreeFull> ReinH: You succ
10:04:33 <edwardk> by using a prism as the building block the laws relating cons, uncons, head and tail are implicit
10:04:52 <edwardk> hiptobecubic: ^? takes a traversal and returns the (first) result of it if it exists.
10:05:03 <edwardk> > []^?traverse
10:05:04 <lambdabot>   Nothing
10:05:08 <edwardk> > [1]^?traverse
10:05:09 <lambdabot>   Just 1
10:05:12 <edwardk> > [1,2]^?traverse
10:05:13 <lambdabot>   Just 1
10:05:25 <hiptobecubic> interesting
10:05:32 <ParahSailin> how should i decide whether to use Control.Monad.State.Lazy vs Strict
10:05:40 <hiptobecubic> How is Cons a traversal?
10:05:44 <ReinH> FreeFull: there it is :)
10:05:52 <edwardk> we use it with prisms, traversals, folds, etc. as a pattern matching primitive
10:05:58 <edwardk> ParahSailin: use strict unless you need to tie yourself in crazy infinite loops
10:06:04 <edwardk> _Cons is a prism, very prism is a valid traversal
10:06:10 <edwardk> :t _Cons
10:06:11 <lambdabot> Cons p f s t a b => Overloaded p f s t (a, s) (b, t)
10:06:17 <FreeFull> > map succ "ReinH"
10:06:18 <lambdabot>   "SfjoI"
10:06:43 <edwardk> that isn't a pretty type =)
10:06:52 <hiptobecubic> edwardk, i was just going to say....
10:06:58 <ParahSailin> edwardk: thanks
10:07:06 <ParahSailin> edwardk: thats what i'd been using
10:07:08 <FreeFull> Most types in lens aren't pretty
10:07:17 <edwardk> _Cons :: Prism [a] [b] (a,[a]) (b,[b])   is the prism for the (:) constructor
10:07:19 <FreeFull> It is an amazing library though
10:07:20 <ReinH> edwardk: I was thinking you could use LZ78 to output the automata diagrams as gifs ;)
10:07:42 <edwardk> it pattern matches on the (:) constructor, if it fails to match you are allowed to change the type of your list because it is necessarily nil
10:07:55 <edwardk> ReinH: =P
10:08:37 <FreeFull> > uncons []
10:08:39 <lambdabot>   Nothing
10:08:42 <edwardk> hiptobecubic: every prism is a valid traversal. consider traverse on (Either a)   it necessarily traverses the right hand side, right?
10:08:49 <edwardk> > Right 2 ^? traverse
10:08:51 <lambdabot>   Just 2
10:08:56 <FreeFull> > uncons ([]::[Int]) :: Maybe [Char]
10:08:57 <jbracker_> byorgey: Sunroof and blank canvas are incompatible, but in terms of abilities, sunroof is a superset of blank canvas
10:08:57 <lambdabot>   Couldn't match type `(GHC.Types.Int, [GHC.Types.Int])'
10:08:57 <lambdabot>                with ...
10:08:58 <ParahSailin> edwardk: why does mtl then have .Lazy as the one exposed in Control.Monad.State?
10:09:09 <edwardk> :t uncons ([] :: Int)
10:09:09 <lambdabot>     Couldn't match expected type `Int' with actual type `[a1]'
10:09:10 <lambdabot>     In the first argument of `uncons', namely `([] :: Int)'
10:09:10 <lambdabot>     In the expression: uncons ([] :: Int)
10:09:22 <edwardk> :t _Cons Left
10:09:23 <lambdabot> Cons (->) (Either (a, s)) s t a b => s -> Either (a, s) t
10:09:25 <byorgey> jbracker_: OK.  So we should be focusing efforts on diagrams-sunroof instead of diagrams-canvas?
10:09:27 <edwardk> :t _Cons Left []
10:09:28 <lambdabot> Either (a, [a]) [b]
10:09:39 <lingxiao> edwardk : may I ask you a question about Plan.hs in Machines when you have a momment?
10:09:42 <edwardk> :t _Cons Left ([] :: Int)
10:09:43 <lambdabot>     Couldn't match expected type `Int' with actual type `[a1]'
10:09:43 <lambdabot>     In the second argument of `_Cons', namely `([] :: Int)'
10:09:43 <lambdabot>     In the expression: _Cons Left ([] :: Int)
10:09:46 <lingxiao> if not I can try to catch you later
10:09:50 <ReinH> edwardk: you just have to violate a patent or two
10:09:50 <jbracker_> byorgey: Definitly
10:09:53 <edwardk> :t _Cons Left ([] :: [Int])
10:09:53 <lambdabot> Either (Int, [Int]) [b]
10:09:54 <FreeFull> edwardk: A list isn't an Int
10:09:54 <byorgey> ok.
10:09:55 <FreeFull> Silly
10:09:56 <edwardk> there
10:10:18 <FreeFull> > _Cons Left []
10:10:19 <lambdabot>   Right []
10:10:19 <edwardk> it either matches and gives you an int and a list, or it doesn't match and so it lets you use your [] as any type you want
10:10:50 <edwardk> we're using Left as an 'escape hatch' from our traversal.
10:10:55 <ReinH> I wish you could define |a| = length a
10:11:06 <edwardk> ReinH: write agda ;)
10:11:11 <ReinH> edwardk: :)
10:11:24 <edwardk> lingxiao: sure, though context switching to machines is hard. whats up?
10:11:58 <lingxiao> edwardk : thanks! Hopefully the question is simple enough so you don't have to dig too deep into it.
10:12:22 <jbracker_> byorgey: The current state is that it does work, but it's still bugy
10:12:27 <lingxiao> So reading Plan.hs, I see that the a in `PlanT k o m a` is the result of the computation?
10:12:37 <lingxiao> `(a -> m r) ->   -- Done a`
10:12:48 <lingxiao> and the functor instance parametrize over `a`
10:13:04 <lingxiao> but when I do something like `(+1) <$> source [1..3]`
10:13:44 <lingxiao> It looks like the functor instance is  parameterized over the value that's yielded
10:13:50 <lingxiao> I am wondering how you did that
10:14:15 <edwardk> a source is a Machine not a Plan
10:14:41 <edwardk> a Plan is a monad over the type of 'internal state it has at any given moment in time'
10:14:52 <lingxiao> ahh.. it says: `MachineT m k o`
10:15:06 <edwardk> when we compile to a machine PlanT k o m a   becomes MachineT m k o
10:15:11 <aristid> edwardk: what happened to the idea of unifying Machine and Plan?:)
10:15:14 <glguy> edwardk: In the bound example Deriving.hs your Let and Lam constructors have an Int field, but I can't tell what that Int is for. Am I overlooking something?
10:15:17 <edwardk> and the 'a' gets tucked away and becomes inaccessible
10:15:20 <edwardk> aristid: it didn't work
10:15:55 <satc> How do I import macros from a c file. Suppose I have #define pi 3.14 inside c? I am not using hsc but just foreignfunctioninterface and importing using foreign import ccall ...
10:16:04 <aristid> edwardk: how 'bout closing it then?:) https://github.com/ekmett/machines/issues/14
10:16:08 <lingxiao> so conceptually a machine should never `return` value? because I see `step` has no value constructor of form `Done v` in it
10:16:19 <edwardk> glguy: the Int is the index into the variables bound by the pattern in the Lam case, the Int is the index into the list of let bindings in the Let case
10:16:20 <edwardk> glguy: this is the 'generalized generalized' debruijn idea allowing simultaneous substitution for many variables
10:16:24 <edwardk> you can instantiate the entire binding group at the same time
10:16:38 <edwardk> closed
10:17:00 <edwardk> lingxiao: yeah a machine communicates solely through its inputs and outputs
10:17:07 <edwardk> it has no 'final' value
10:17:09 <lingxiao> is there a reason a `plan` could finish evaluating and `return` a value? aside from the fact that it makes certain typeclass instances easier to implement?
10:17:53 <edwardk> lingxiao: its needed so you can write a plan monadically.   do x <- await; yield (x + 1)   and then tie it up into a machine with something like 'repeatedly'
10:18:16 <edwardk> the alternative style of writing machines directly is quite horrid
10:19:01 <edwardk> and we build plans in CPS'd style, so we can re-associate in O(1) but we build machines un-CPS'd so they can be interpreted multiple times fast
10:19:22 <edwardk> er so we can re-associate (>>=)'s in Plan in O(1)
10:20:06 <lingxiao> edwardk : ah gotcha, thanks for the fast response! and design pearls
10:20:28 <edwardk> this prevents you from articulating the problem pipes where you have a some bind built by composition and then bind it to a result. in pipes this results in asymptotic slowdown
10:20:57 <edwardk> the half-cps'd design of machines was concocted to avoid this scenario
10:21:38 <Jentrep> Is zomg on? :)
10:25:21 <simon> @pl liftM concat (mapM f xs)
10:25:21 <lambdabot> fmap join (mapM f xs)
10:27:33 <bennofs> @ty \f xs -> fmap join (mapM f xs)
10:27:33 <lambdabot> (Monad f, Functor f) => (a1 -> f [a]) -> [a1] -> f [a]
10:28:27 <bennofs> @ty \f xs -> mapM (join . f) xs
10:28:28 <lambdabot> Monad m => (a -> m (m b)) -> [a] -> m [b]
10:29:14 * hackagebot ftphs 1.0.9 - FTP Client and Server Library  http://hackage.haskell.org/package/ftphs-1.0.9 (JohnGoerzen)
10:32:25 <simon> so... concatMapM = mapM . (join :) :P
10:32:45 <simon> oops, :)->.)
10:34:27 <FreeFull> :t mapM . (join .)
10:34:28 <lambdabot> Monad m => (a -> m (m b)) -> [a] -> m [b]
10:35:04 <FreeFull> :t concatMap
10:35:04 <lambdabot> (a -> [b]) -> [a] -> [b]
10:36:51 <satc> Any expert in ffi. How do I import
10:36:51 <arkeet> :t (=<<)
10:36:52 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:37:02 <satc> Any expert in ffi. How do I import #defines from c file?
10:37:13 <Jentrep> no zomg? :9
10:37:17 <Jentrep> :9
10:37:19 <Jentrep> :(
10:39:14 * hackagebot markup-preview 0.2 - A simple markup document preview (markdown, textile, reStructuredText)  http://hackage.haskell.org/package/markup-preview-0.2 (MariusGhita)
10:39:23 <ReinH> edwardk: "by Simon and Simon" lmao
10:39:27 <edwardk> ReinH: =)
10:39:36 <edwardk> was waiting for someone to click the link
10:41:21 <edwardk> @pl \l a -> b l a t
10:41:22 <lambdabot> flip flip t . b
10:41:25 <ReinH> edwardk: http://media.tumblr.com/05178b10412f3b539d2b0982fe1a2478/tumblr_inline_mfciu0kPVq1rrc78e.gif
10:41:26 <edwardk> blech
10:41:38 <edwardk> ReinH: =)
10:41:46 <ReinH> edwardk: and then http://i.imgur.com/xDfo0.gif
10:42:08 <edwardk> cookies are a sometimes food ;)
10:42:13 <ReinH> lmao
10:42:20 <Jentrep> HAs anyone use Happstack?
10:42:25 <Jentrep> Any reviews on it?
10:42:28 <Jentrep> *used
10:42:37 <Jentrep> http://happstack.com/page/view-page-slug/1/happstack
10:43:20 <S_J> How does multicore programming work? Can you explicitly say: If I have 2 cores then run this on core 1 and this on core 2?
10:44:06 <S_J> Are Control.Concurrent.Chan threadsafe? or do I need lock them when I read and write to them?
10:44:14 <ksf> edwardk, http://arxiv.org/abs/1102.3730.pdf
10:44:33 <ksf> (you sound like you're looking for a calculus that's nice to implement)
10:44:48 <ReinH> S_J: I would strongly recommend http://chimera.labs.oreilly.com/books/1230000000929
10:45:32 <simukis_> S_J: How about Control.Concurrent.STM.TChan?
10:46:44 <ReinH> S_J: it is possible to to create a thread with core affinity, yes
10:47:05 <ReinH> but usually the haskell scheduler can do a better job than you can of figuring out which core should run which thread / spark
10:48:08 <ReinH> S_J: but seriously, read that free ebook
10:48:24 <lorozic> hey guys, can anyone tell me what's the difference between hindley-milner and weak polymorphic lambda calculus?
10:48:40 <applicative> hah, chapter 14.7 "The Philosophy of Distributed Failure
10:48:52 <FreeFull> simon: I think concatMapM should be :: (a -> [m b]) -> [a] -> m [b]    or possibly   :: (a -> m [b]) -> [a] -> m [b]
10:49:05 <FreeFull> :t mapM . (sequence .)
10:49:05 <lambdabot> Monad m => (a -> [m a1]) -> [a] -> m [[a1]]
10:49:20 <FreeFull> :t fmap concat . mapM . (sequence .)
10:49:21 <lambdabot> (a -> [[a1]]) -> [a] -> [[a1]]
10:49:39 <applicative> @google "weak polymorphic lambda calculus"
10:49:43 <lambdabot> No Result Found.
10:50:12 <lorozic> i think they're the same but thought you guys might know
10:50:13 <ReinH> applicative: weak.
10:50:15 <FreeFull> :t \xs -> fmap concat (mapM . (sequence .) $ xs)
10:50:16 <lambdabot> (a -> [[a1]]) -> [a] -> [[a1]]
10:50:45 <FreeFull> hmm, something is wrong
10:50:56 <ReinH> applicative: kind of disappointing that he devotes 4 pages of a 300 page book to distributed failure
10:51:12 <Philippa> lorozic: context?
10:51:15 <ReinH> when ime failure is THE hardest thing in distributed systems and also THE most important...
10:51:28 <ReinH> applicative: maybe Haskell programs fail less?
10:51:29 <ReinH> ;)
10:51:39 <lorozic> Philippa: writing a paper on haskell, just need to know what to look for
10:52:46 <Philippa> yeah, I mean: what context did you see "weak polymorphic lambda calculus" in? Because that's not a term Google recognises, nor one I do. And I generally know my stuff to some extent: is it a term introduced in a course you're doing or something?
10:53:10 <Philippa> (there /is/ weak lambda-omega, in which you have the simply-typed lambda calculus at type level but you don't have type lambdas/applications in terms)
10:53:18 <Philippa> (it's not very polymorphic as such, though)
10:53:26 <lorozic> Philippa: Sorry :P I have an article about it, just a sec
10:54:08 <Philippa> H-M is rank-1 polymorphism where you instantiate type variables every time a variable is used and generalise at let statements
10:54:14 * hackagebot markup-preview 0.2.0.1 - A simple markup document preview (markdown, textile, reStructuredText)  http://hackage.haskell.org/package/markup-preview-0.2.0.1 (MariusGhita)
10:54:29 <Philippa> (and otherwise do exactly the same you'd do to give type inference for the simply-typed lambda calculus)
10:54:57 <saml> [1, 2, 0, 3, -1, 4] ==> [1, 2, 4]  how do I do that?  0 is ignored. -1 pops the last
10:55:27 <lorozic> Herman Geuevers, Introduction to Type Theory
10:55:35 <lorozic> thats the article
10:55:35 <ksf> saml, that looks like a complete hack.
10:55:52 <ksf> don't use the same type for data and instructions.
10:55:53 <saml> push 1, push 2, noop, push 3, pop, push 4
10:56:01 <saml> yah
10:56:19 <ksf> but you essentially just described it: write a stack-based interpreter.
10:56:31 <ksf> (then reverse the stack)
10:56:35 <lorozic> I think it's really the same thing, I've read about the weak polymorphic case and just wanted to know if HM is the same so I can write stuff :P I'll just check out HM in detail then, thanks
10:56:47 <saml> this is just   "a/b/./c/../d" => "a/b/d"
10:56:54 <saml> 0 is .  and -1 is ..
10:57:39 <ksf> hindley milner is the first-order fragment of system f with let polymorphism.
10:58:06 <ksf> ...introducing let is a trick to always know the type of the function when applying.
10:58:26 <x-s4nd3r> is there a nullbyte alternative for *nix that works on latest php versions? please i need help
10:58:32 <Philippa> lorozic: That looks like the rank-1 fragment of System F. Hindley-Milner has a built-in let statement and complete, sound type inference
10:58:33 <ksf> without types, let and lambda are equivalent, but it makes a difference in type inference because let knows its argument.
10:58:48 <Saizan> ksf: first-rank
10:58:57 <ksf> yep.
11:00:40 <lorozic> Philippa: I'll check it out then, thanks for the help
11:01:15 <edwardk> saml: just write a version of the function that takes the 'current stack' as one argument, and interpret
11:01:44 <Philippa> ksf: I like the take that agundry's papers explain there, myself - effectively the let statement forms a chunk of the context and you can place quantifiers within it so as to have scope
11:01:52 <tomejaguar> let is like a local-only lambda?
11:02:16 <Philippa> tomejaguar: let is a 'simple' binding statement - let x = y in z
11:02:43 <zebr> hmm, google seems to be a bit stumped by hackage. it breadcrumbs Text.Regex as hackage.haskell.org > Bool > Bool > Regex
11:03:11 <Philippa> you know that any constraints on x per se will arise in y, and you can let each usage in z collect its own separate set of constraints so long as they're satisfiable - which is rank-1 universal polymorphism in a nutshell
11:03:17 <tomejaguar> ksf said "let knows its argument".  I took this to mean it's like a lambda that can only be called from one place.
11:03:54 <edwardk> eval xs (n:ys) | n <= 0 = eval (drop (-n) xs) ys;    | otherwise = eval (n:xs) ys;     eval xs [] = reverse xs
11:04:03 <tomejaguar> Type theory is phenomenally complex.  I didn't realise this before I used Haskell.
11:04:07 <Saizan> heh, in some sense that's true, let is like an already-applied lambda
11:04:08 <Philippa> so when you desugar let, that would become (\x. z) y - so y is "the argument", aka "the bound term"
11:04:26 <edwardk> saml: ^- that
11:04:55 <Philippa> tomejaguar: it's an area of ongoing research and it's a viable foundation for mathematics. Of *course* it's phenomenally complex if you want to dig that far
11:05:01 <ksf> tomejaguar, when you have \x -> f x, the type of x is unknown. it could be anything, really, you don't know. when you have let x = ... in f x, you can infer x's type from ...
11:05:10 <Philippa> "that far" - you can build the entire of constructive mathematics in terms of it
11:05:21 <ksf> up to hindley milner should be possible.
11:05:34 <ksf> it was possible for me, so any random idiot can do it.
11:06:15 <tomejaguar> I wish mathematicians would take type theory seriously
11:06:15 <Philippa> I'm not keen on "if I can do it, anyone can" in general? It's not too difficult if you can understand type inference on monomorphic types, though
11:06:49 <tomejaguar> by which I mean "the majority of" mathematicians
11:06:55 <tomejaguar> not just an enlightened handful
11:07:04 <Philippa> one way to define let is "any time I see x inside z, I can substitute in y and pretend I'm just doing STLC"
11:07:17 <Philippa> (assuming barendregt convention, etc etc)
11:07:36 <saml> > let mkPathStr elems stack = case elems of (x:xs) -> if x == "." then mkPathStr xs stack else if x == ".." then mkPathStr xs (tail stack) else mkPathStr xs (x : stack); case [] -> reverse stack  in  mkPathStr ["a", "b", ".", "c", "..", "d"] []
11:07:40 <lambdabot>   <hint>:1:177: parse error on input `->'
11:07:43 <Philippa> under that definition, let is just a way of knowingly introducing a sub-problem and re-using it. The forall comes "for free"
11:08:01 <joelteon> saml: s/case []/[]/
11:08:04 <ksf> TBH, I didn't use the hindley-milner algorithm in my implementation, I judged it to be too confused to grok.
11:08:06 <zebr> hi all. i want to run regular expressions over phoneme strings, so standard character matching doesn't work; instead i want to compile a custom 'flavour' of regex that matches objects by predicates of my own choosing. will i need to build a completely new regex matching system, or is there an existing framework i could use?
11:08:17 <ksf> ...collecting constraints and then solving them is so much easier.
11:08:30 <Philippa> ksf: I don't rate the original presentation as such these days, no. Lots of ways to tidy it up
11:09:00 <ksf> *to bother to grok
11:09:06 <Philippa> tomejaguar: most mathematicians try to avoid doing 'serious' set theory if they can, no?
11:09:37 <tomejaguar> True, but they still acknowledge it has an office in pure mathematics departments.
11:09:41 <ksf> zebr, maybe use a parser combinator library?
11:09:54 <Philippa> but type theory does have the upside of having tenuous-but-growable connections to an engineering discipline that's essentially about engineering proofs
11:10:04 <danharaj> Set theory is just a fancy subfield of logic :P
11:10:05 <tomejaguar> I doubt most graduating pure mathematics students have ever heard of type theory, at least in the UK.
11:10:05 <ksf> zebr, most accept any kind of token type, not just characters.
11:10:34 <Philippa> tomejaguar: I know a maths grad who had to be taught how to write a proper proof by one of the compsci PhD students locally, yeah
11:10:57 <tomejaguar> Hahaha
11:11:23 <zebr> ksf: hmm, that could work
11:11:35 <ksf> you mean mathematics, unlike computer science, isn't a hard science? shocking :)
11:13:31 <tomejaguar> hard: convince your colleague.  harder: convince the journal referee.  hardest: convince a computer.
11:14:28 <Philippa> nah, the computer'll accept "go fix yourself" as a proof of anything you like. Convincing the computer /when it's been programmed to be the right kind of picky/ is the hardest
11:15:18 * danharaj needs to use "go fix yourself" as an insult at icfp
11:15:19 <tomejaguar> I see you've been programmed to be the right kind of picky :)
11:15:42 <edwardk> > fix error
11:15:44 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:16:03 <c_wraith> fix *is* a bit of a logical fallacy
11:16:08 <Philippa> tomejaguar: what makes you say that?
11:16:10 <ReinH> edwardk: > fix turtle
11:16:31 <Philippa> c_wraith: A proof of any circular argument you like? What could possibly go wrong?
11:16:34 <edwardk> yo dawg, i heard you liked exceptions...
11:16:34 <tomejaguar> Philippa: you made my comment more precise (some would say more accurate)
11:16:49 <c_wraith> Philippa: seems fine to me!
11:16:53 <Philippa> tomejaguar: sorry, I'm guessing you've not met Eliza :-)
11:16:55 <haasn> > fix id :: Void
11:16:56 <lambdabot>   Not in scope: type constructor or class `Void'
11:16:59 <ksf_> fix is just a hack in lieu of a solution to the halting problem.
11:17:01 <haasn> well you get the idea
11:17:10 <edwardk> :t fix id
11:17:11 <lambdabot> a
11:17:26 <edwardk> haasn: just using the polymorphic result there is enough to show it can be Void
11:17:26 <tomejaguar> Philippa: ah, I get it now!
11:17:27 <c_wraith> :t \_ -> fix id
11:17:28 <lambdabot> t -> a
11:17:29 <Philippa> nothing wrong with fix. Plenty wrong with fix /at its usual type/
11:17:36 <c_wraith> look, I implemented unsafeCoerce!
11:17:52 <edwardk> Philippa: only if you want totality. logical fallacies make useful combinators
11:18:14 <edwardk> fix = assuming the hypothesis
11:18:18 <haasn> c_wraith: better patch it into lens
11:18:28 <monochrom> nothing wrong with fix's usual type
11:18:28 <haasn> “Switch to pure version of unsafeCoerce”
11:18:28 <fylwind> :t fix
11:18:29 <lambdabot> (a -> a) -> a
11:18:46 <edwardk> haasn: we can compile with -fsafe and we just don't unsafeCoerce then
11:19:35 <edwardk> fylwind: if a entails a, then a!
11:20:01 <ReinH> edwardk: the begging the question operator
11:20:07 <ReinH> *combinator
11:20:13 <Philippa> edwardk: *nod*. I might settle for paraconsistency.
11:20:13 <edwardk> ReinH: yep
11:20:26 <monochrom> the wrongness is in some humans saying that every type system is a proof system.
11:20:33 <ReinH> edwardk: now we just need a post hoc ergo propter hoc combinator
11:20:53 <Philippa> monochrom: nah - in implying /meaningful/ proof system
11:21:20 <edwardk> monochrom: its just not necessarily a useful one
11:21:45 <Philippa> there's a reasonable point of view from which you can't escape curry-howard, it just might not help much
11:21:49 <danharaj> GHC's kind system is inconsistent but still useful
11:21:59 <monochrom> ok, correction. the wrongness is in some humans saying that every type system is a meaningful proof system.
11:22:02 <Philippa> (C: a language which accepts "or I'll format your HDD" as a proof)
11:22:42 <tomejaguar> What should the type of fix be?
11:22:51 <monochrom> (a->a) -> a
11:23:05 <fylwind> does having a consistent proof system imply that the language is not Turing-complete?
11:23:12 <haasn> monochrom: depends on what the meaning of “proof system” in this context is, I guess; the type system of haskell still proves stuff, just not the things we care about when doing curry-howard
11:23:39 <edwardk> fylwind: in general, yes, but turing completeness is overrated.
11:23:56 <edwardk> fylwind: you can still write code in a 'partiality monad' that you can iterate for n steps, etc.
11:24:01 <Philippa> fylwind: one can always talk about doing turing complete things without doing them. If you have another machine to hand that understands how to do the things you're talking about...
11:24:12 <edwardk> fylwind: and you can still deal with streams of input via codata and what not
11:24:20 <haasn> there's a difference between “terminates” and “provably terminates (by mechanism X)”, though
11:24:31 <c_wraith> The only thing you need turing completeness for is creating accidental infinite loops.
11:24:32 <ksf_> in particular, a type system doesn't need to be turing complete to say meaningful things about the language it covers.
11:24:36 <c_wraith> Overall, that's not a positive.
11:24:38 <Philippa> and too many people don't know about productivity
11:24:41 <ksf_> (unless you're in the dependently typed camp)
11:24:44 <ReinH> edwardk: yeah if you could just reverse the arrow of time that would be great
11:24:48 <ksf_> it all depends on "meaningful".
11:25:01 <edwardk> ReinH: use the backwards state monad version of IO.
11:25:08 <ReinH> coIO
11:25:13 <haasn> Philippa: reminds me of how it's possible to “do IO” in a pure language by talking about it, as long as you have another machine that understands how to do IO
11:25:18 <fylwind> what's wrong with dependent types? (not that I know much about them)
11:25:25 <Philippa> haasn: exactly
11:25:38 <ksf_> fylwind, nothing in particular.
11:25:48 <ksf_> except that you still need a Ph.D to use those languages.
11:25:50 <ReinH> I'm using codependent typign now. You've probably never heard of it.
11:26:03 <ReinH> Is that actually a thing? It has to be a thing.
11:26:11 <fylwind> it will be now
11:26:11 <tikhon> fylwind: it depends
11:26:15 <edwardk> fylwind: dependent types are perfectly fine. they are just verbose, and they don't solve the turing completeness issue, just let you get a little closer to the edge.
11:26:24 <Philippa> ReinH: is that for relational programming?
11:26:30 <ReinH> Philippa: it is for making jokes
11:26:31 <haasn> I guess the major practical problem with dependent typing is that type inference doesn't work very well?
11:26:35 <ReinH> and maybe for other things I am unaware of :)
11:26:43 <ReinH> Philippa: OH I GET IT
11:26:45 <ReinH> well played
11:26:57 * ReinH golf claps
11:27:21 <Philippa> haasn: Type inference isn't complete and it's taken a long time for some good writeups of what it'll get you to happen. I'm not sure that's the same thing.
11:27:42 <Philippa> (it won't magically infer which function you meant to apply at the type level for you, most of the time, sure)
11:27:58 <tikhon> type inference can't be the main thing—witness how many popular languages don't have it!
11:28:05 <tikhon> we're just spoiled here
11:28:32 <ksf_> those languages don't have as detailed types as we're used to, either.
11:28:39 <Philippa> haasn: type inference is potentially a lot better for 'client' code in an environment with a lot of existing libraries, too
11:28:40 <haasn> Philippa: well, if we took all of haskell98's type system and embedded it into a dependent type system (if that makes sense), would type inferencing work in all situations where it does in h98?
11:28:47 <ksf_> others are just being amended with at least local inference
11:29:25 <monochrom> some programmers flock to untyped languages precisely because they don't want to hand-write types
11:29:37 <Philippa> haasn: Pattern unification is stronger than ordinary unification, yeah. Dependent languages tend to have very different approaches to recursion
11:29:49 <hiptobecubic> monochrom, some programmer do just about anything.
11:29:51 <Philippa> Some languages'll let you get type classes in easily, others won't
11:30:00 <tikhon> monochrom: yeah, before I discovered Haskell, I mostly liked dynamically typed languages because they weren't stupidly verbose
11:30:05 <Philippa> that's because type classes are a very specific approach to proof search
11:30:09 <merijn> haasn: Haskell98's type system is already "embedded" in dependent types
11:30:15 <tikhon> that's not *only* a function of type inference, but that was probably a large part of it
11:31:06 <Philippa> (in particular, type classes let you make the assumption that you'll always prove it /the same way/ for a given set of types, so you don't need to carry the proofs around as much as you might otherwise)
11:31:13 <Philippa> (or do equivalence checks on them, or...)
11:32:07 <Philippa> tikhon: type inference, parametric polymorphism and type classes
11:32:08 <Philippa> IOW: not only do you have inference, but it'll infer a lot of things and make them play together well where they can't in, say, C
11:32:32 <ksf_> type classes. I do need to understand how they work on the implementation side. OTOH, first I need to figure out how to properly do ADTs and pattern matching.
11:33:15 <ksf_> the paper trail is sending me down a rocky road into type systems based on curry-howard correspondence to sequent calculus, there...
11:33:39 <S_J> writeChan and readChan, do I need to lock? or is that done automatically?
11:33:40 <tikhon> On top of all that, the only real statically typed languages I knew were C++ and Java—both wantonly verbose. Even stripped of static type information, they would still be extremely awkward.
11:34:04 <ksf_> C at least has short identifiers.
11:34:23 <ksf_> whereas java at least gives you (utterly verbose) lambdas.
11:34:48 <edwardk> a => b    is better than a -> b in the sense that the compiler is free to realize that it can commute that a =>   with any other -> and suck it out to the top level ensuring local sharing for values under the =>  rather than when you share functions built with ->
11:34:51 <monochrom> S_J: automatically
11:35:12 <ksf_> button.register( new ButtonCallback { bool buttonCallback(...) { ... } } );
11:35:17 <edwardk> the price of this is that each 'a' must have one unique possible meaning
11:35:36 <edwardk> the singleton nature of class dictionaries is enforced by confluence
11:35:39 <tikhon> ksf_: gah, that brings up memories of Swing that I had happily repressed :P
11:36:39 <fylwind> template<class T, class U> inline static typename common_type<T, U>::type add(const T& t, const U& u) { ... }
11:36:46 <fylwind> that's not verbose at all :)
11:36:48 <tikhon> my Swing experience is probably the chief reason I'm so bullish on FRP now
11:41:05 <zebr> i just built a package by hand; can i use cabal to get it into right directory? Setup.hs install seems to require sudo, whereas cabal seems to be user-local
11:41:25 <dcoutts> zebr: ./Setup configure --user
11:41:27 <ksf_> zebr, --user
11:41:36 <zebr> ah, thanks a lot
11:42:05 <ksf_> it's not just a matter of what directory it installs to, but also which libraries it will depend on.
11:42:17 <ksf_> --system won't use root's user library database.
11:42:24 <ksf_> but only the system one.
11:42:39 <zebr> ah, makes sense
11:42:41 <ksf_> the behaviour of both tools is different due to hysterical raisins.
11:42:51 <monochrom> zebr: see my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#install
11:43:26 <monochrom> also, it's --global, not --system
11:43:55 <ksf_> details schmetails :)
11:45:42 <bennofs> Is the :complete command supposed to be included in GHCi 7.6.3?
11:45:54 <monochrom> no
11:46:22 <bennofs> Why not ? :( The ticket (http://ghc.haskell.org/trac/ghc/ticket/5687) seems quite old
11:46:37 <monochrom> I don't know
11:47:42 <monochrom> http://ghc.haskell.org/trac/ghc/ticket/5442 is even older
11:56:18 <hpaste_> satc pasted “ForeignPtr.newForeignPtr” at http://lpaste.net/91971
11:56:55 <satc> I am using Foreign.ForeignPtr.Safe and I am getting this error http://lpaste.net/91971 . Any thoughs by ffi experts out there? I was suggested on irc to use safe and not to use the concurrent one.
11:57:02 <monochrom> oh, you again
11:58:13 <monochrom> try to avoid going through C or calling back into haskell
11:58:28 <edwardk> or call the version of newForeignPtr it mentions in the error ;)
11:58:45 <monochrom> we covered that last time. it is too week.
11:58:52 <satc> monochrom: I am not calling back anywhere. and all my imports are marked as safe.
11:58:55 <edwardk> ah
11:59:12 <monochrom> err, too weak. the Concurrent one's "finalizer" is just IO() not Ptr->IO()
11:59:45 <monochrom> it led to all kinds of misguided "so how to ForeignPtr -> Ptr"?
12:00:12 <satc> monochrom: Yeah. This was the discussion last time and some one suggested to use ForeignPtr.Safe.
12:00:34 <edwardk> sounds messy. good luck =)
12:01:47 <satc> monochrom: By the way, How do I know c function calls back into haskell? If c function takes a haskell function as argument?
12:02:54 <bscarlet> monochrom: naive question: Why not (\p -> Foreign.Concurrent.newForeignPtr p (myFinalizer p)) ?
12:03:55 <monochrom> yes, that way you already have p. last time it was addForeignPtrFinalizer
12:04:21 <bscarlet> ah
12:04:44 <ocharles> Does anyone have any advice on ensuring that serialization covers all fields of a piece of data? For example, with applicative deserialization, we have to do Foo <$> parseBar <*> parseBaz -- we can't forget to parse a field. However, when serializing (e.g., with cereal's Put monad) there is no such guarantee
12:04:47 <monochrom> this whole business smacks of a long chain of XY problems
12:04:55 <ocharles> does anyone know of any techinques to get such guarantee in types?
12:05:11 <edwardk> ocharles: use ghc.generics
12:05:13 <d-snp_> I want to build a haskell application in such a way that it is easy to package in for example a .deb, is there a guide for that or something?
12:05:19 <ocharles> I wonder if you could do it with GHC generics and the reducing the alternative representation down to ()
12:05:36 <ocharles> edwardk: heh, snap. but serialization is just an example - I often don't have a generic approach that I can use
12:05:39 <d-snp_> so, it's installable by people who don't have a compiler (let alone ghc) installed
12:06:00 <tomejaguar> ocharles: You could reflect the parts of the value that you have serialised in a phantom type
12:06:15 <c_wraith> d-snp_: the default configuration of ghc produces executables that only link to system libs dynamically.
12:06:28 <edwardk> ocharles: i tend to use ghc.generics as my baseline implementation for this sort of thing, go through and set up default signatures in terms of a ghc.generics version and go from there. then fill in the non-generic cases by hand overriding the default
12:06:47 <ocharles> edwardk: hmm, I see.
12:06:58 <d-snp_> c_wraith: so I could just build the application, and the executable would run on any system with just the haskell package for their platform installed?
12:07:17 <ocharles> my current problem is "serializing" something from Haskell into a PostgreSQL database. Doing so requires various inserts/updates, and some inserts may depend on the values of other fields
12:07:23 <ocharles> that's why ghc.generics didn't see like the best fit
12:07:25 <ocharles> but maybe it is
12:07:31 <edwardk> example (for serialization!) http://hackage.haskell.org/packages/archive/bytes/0.10.2/doc/html/src/Data-Bytes-Serial.html see the gserialize defaults, etc.
12:07:37 <c_wraith> d-snp_: really, most ghc-compiled programs shouldn't need the platform.
12:07:51 <edwardk> *nods*
12:07:58 <d-snp_> alright, that's great
12:08:39 <d-snp_> I'm going to attempt to build a file backed message queue in Haskell
12:09:01 <edwardk> ocharles: anyways we don't have linear types in general so you can't make sure a user does something with each argument easily
12:09:07 <ocharles> Alright, I'll see if I can phrase this with GHC.Generics somehow and see if I can get some type system help. I've introduced bugs by forgetting to insert data once too many times now, so it's time to get some type help
12:09:10 <c_wraith> d-snp_: in particular, check out the .deb for pandoc.  It's a haskell program that doesn't depend on any haskell environment
12:09:51 <ocharles> edwardk: i see. not familiar with linear types so i'll add that to the reading list :)
12:10:18 <danharaj> edwardk: clearly we need first class contexts
12:10:20 <edwardk> ocharles: when in doubt you can use a TH splice at compile time to 'reify' the data ytpe into something you can inspect, and then do some reasoning about it then to build your super-snazzy db-based serializer with all sorts of ad hoc logic
12:12:07 <edwardk> hrmm i wonder if stackage includes enough of criterion that i can show benchmarks on SoH. that seems kinda cruel though
12:13:00 <ocharles> edwardk: ok, I tend to avoid TH until the very last resort. so i've never had to use it yet ;)
12:13:12 <danharaj> edwardk: actually, is there a language with explicit manipulation of contexts as a data type? That'd be cool.
12:13:29 <danharaj> I mean you can fake it by explicitly indexing your types with contexts and restricting your functions but it's kludgy as hell.
12:13:30 <edwardk> danharaj: sounds like you want php ;)
12:13:36 <danharaj> haha god no
12:14:03 <zomg> Might as well run it using my haskell php evaluator
12:14:05 <zomg> err
12:14:37 <danharaj> The Haskell 98 report stipulates that compiling to php is a compiler error.
12:14:55 <edwardk> danharaj: good. i was worried
12:15:08 <danharaj> edwardk: compiling to C++ templates is still on the table, however.
12:15:36 <edwardk> that's fine. thats where i came from. me and templates, we're buds.
12:15:46 <danharaj> I thought you moved to Haskell because templates got a restraining order.
12:16:14 <edwardk> well, sure, she doesn't want to see me right _now_, but that doesn't mean she won't come around.
12:16:50 <danharaj> hey, while I'm compiling, would you mind reviewing my first TH splice and telling me how to make it less brittle?
12:16:52 <danharaj> http://lpaste.net/91972
12:17:05 <edwardk> i think my girl c++ is still a little bitter about that whole jit++ thing. i wasn't jitting around on her, really.
12:17:09 <quchen> I have two equal types of data, but I'd like to distinguish them at compile-time to avoid errors (addresses of different kinds of servers). More precisely, I want the type system to reject calling functions with wrapper A when it expects wrapper B. For that reason, I can't use a sum type (as that would require me to pattern match, i.e. reject wrong constructors at runtime). However, some functions should be allowed to be called with either,
12:17:09 <quchen>  and in the function body I need to unwrap the addresses. A typeclass "class Wrap where unwrap :: f a -> a" would do the trick, but smells like an antipattern here. What's the canonical solution?
12:17:11 <danharaj> also how I can use GHC.TypeLits KindParam without having to export it explicitly to the splice sight.
12:17:59 <edwardk> danharaj: that makes me go crosseyed. what is the high level overview?
12:18:17 <edwardk> ok. brittle fix #1
12:18:31 <danharaj> edwardk: You give it a string of digit symbols and it makes a class for addition modulo the base.
12:18:34 <edwardk> don't use mkName for a name you know here, use ''Foo or 'Foo instead
12:18:40 <danharaj> oh
12:18:46 <danharaj> Right that's how you directly quote a name.
12:18:49 <quchen> I think what I basically want is overloading record fields there.
12:18:52 <edwardk> that way if the user doesn't have it in scope it still works
12:18:55 * danharaj notes that is kind of not obvious from the spec.
12:18:58 <edwardk> yep
12:19:06 <edwardk> see the way lens builds its splices
12:19:36 <danharaj> edwardk: what is the type of '<foo>?
12:19:56 <danharaj> I assume it is monadic.
12:20:08 <edwardk> conT ''Lens   will will work, etc.
12:20:32 <danharaj> thanks for the tip, I'll fix it up tonight :)
12:20:56 <edwardk> it isn't monadic, it just gives you a Nae
12:20:58 <edwardk> er Name
12:21:03 <danharaj> ah
12:21:11 <danharaj> I figured it might be Q Name or whatever.
12:21:11 <scshunt> danharaj: it's in the Q monad
12:21:16 <edwardk> ' vs " is if its a type or term name
12:21:18 <roboguy_> how do you reinstall all installed cabal packages?
12:21:48 <roboguy_> I tried "cabal install --reinstall world --dry-run" but it has a problem with "bin-package-db-0.0.0.0/installed-bf4"
12:21:51 <edwardk> scshunt: >>> :t 'Left
12:21:52 <edwardk> 'Left :: Name
12:21:58 <scshunt> oh :(
12:22:20 <edwardk> >>> 'Left
12:22:20 <edwardk> Data.Either.Left
12:22:54 <edwardk> but the real benefit is that unlike a manually qualified name doing it this way seems to ensure it can always find its target, even out of scope at the splice site
12:23:06 <scshunt> yep
12:23:17 <edwardk> without using ' TH is ridiculously brittle
12:23:20 <scshunt> you can only otherwise do that with Deep Magic
12:23:25 <danharaj> edwardk: btw, I think I figured out how to syntactically represent FinSet -> *. I give you a set of ground representable functors and basic colimit constructors and then you can take a fixpoint of (FinSet -> *) -> (FinSet -> *) using those to get a nested data type encoding of an arbitrary colimit… I think. I need to work out the details tonight.
12:23:35 <scshunt> it's because the names generated by ' and '' are not capturable
12:23:46 <scshunt> they do not require lookup
12:24:22 <edwardk> danharaj: Did Saizan mention to you that the idea of Bound instances forming left modules over monads made it into the bound docs?
12:24:46 <danharaj> edwardk: no but I noticed it in your school of haskell post though
12:25:22 <danharaj> edwardk: there is a paper by ahrens and zsido on the connection between substitution monads and abstract syntax.
12:25:27 <edwardk> danharaj: my apologies if i didn't properly track down the provenance of the idea =)
12:25:38 <danharaj> hm?
12:25:50 <edwardk> wasn't sure how it was spawned between you
12:26:05 <danharaj> oh I threw papers at him :P
12:26:08 <edwardk> ok
12:26:12 <danharaj> But one of them was written by his advisor
12:26:13 <danharaj> so....
12:26:32 <edwardk> wasn't sure if it was that, or if it was your baby or his, or if one of you had visitation rights… sounds like you just introduced him to the mother ;)
12:27:31 <danharaj> you'd probably be able to read the paper by Hirschowitz and Magessi in 20 minutes btw it's really nice and straightfortward
12:27:32 <Saizan> yeah, danharaj wasn't that committed to marry her :)
12:27:42 <danharaj> and it has haskell code!
12:28:04 <danharaj> ok my compile is done, back to work :P
12:28:08 <edwardk> danharaj: send me a link and i'll throw it on the pile that is threatening to avalanche
12:29:07 <danharaj> http://web.math.unifi.it/users/maggesi/ic-final/ic.pdf
12:29:18 <danharaj> edwardk: you should use papers to organize your avalanche so it is nice and orderly when it occurs
12:29:24 <edwardk> danharaj: oh, i read this
12:29:43 <Saizan> http://arxiv.org/abs/1202.3499 <- this one is more general, bit a big harder to read
12:29:50 <Saizan> *but a bit
12:30:40 <Saizan> danharaj: a complete syntax for FinSet -> * would be cool
12:32:39 <danharaj> Saizan: my handwavy argument is that every functor is a colimit of representables (and since representables are FinSet^Op, limits of FinSets) and taking a fixpoint of a functor is a colimit so hopefully I can use those two facts to demonstrate a complete syntax with no garbage terms.
12:33:53 <danharaj> if that works out I have a few loose ends to think about. for one, what it means that FinSet -> * is the classifying topos of the theory of objects, and how it relates to operads, lawvere theories, and monad modules. :P
12:34:03 <Peaker> is there a nice combinator like: breakOn :: Eq a => [a] -> [a] -> ([a], [a])   (analog to splitOn)
12:34:21 <Peaker> actually the result should be in a Maybe
12:34:42 <Saizan> every functor is a colimit of representables? that's true in general?
12:35:06 <danharaj> no
12:35:12 <danharaj> but it is true for C -> Set
12:35:28 <danharaj> and I am pretending * is Set-like enough.
12:35:48 <danharaj> It's a consequence of the Yoneda lemma.
12:35:59 <Saizan> what isn't?:)
12:36:09 <danharaj> hehe
12:36:26 <edwardk> Saizan: mostly stuff involving semigroupoids where the Y-L doesn't hold. ;)
12:36:34 <edwardk> Saizan: or was that rhetorical?
12:36:43 <danharaj> edwardk: why can't I just adjoin identities to a semigroupoid
12:37:19 <edwardk> danharaj: its that a semifunctor isn't guaranteed to preserve identities, so you get many semi-adjunctions, etc.
12:37:26 <applicative> roboguy_: you can do ghc-pkg unregister x-0.1.2 for all of them; or delete the .ghc directory
12:37:35 <edwardk> and everything ceases to be canonical
12:38:03 <edwardk> it is amazing how few things pick up a 'one true meaning' without the preservation of identities.
12:38:22 <danharaj> that's cool
12:38:29 <Saizan> oh, btw a relative left adjoint on j is cocontinous when j is, if anyone was wondering :)
12:38:31 <danharaj> edwardk: It's amazing because that's what the yoneda lemma *says*
12:38:51 <edwardk> danharaj: yep. if you have a semigroupoid and the Y-L holds, then you have a category
12:39:06 <edwardk> its a nice way to go back and forth
12:39:33 <edwardk> so i guess again its a consequence of the Y-L =)
12:39:38 <identity> Say I have a type, that looks something like: type Foo a = Map a (Map a Int) - how can I restrict a to be a member of Ord, as Map requires? So that I do not have to put this restriction on all my functions that use this type, as it is implicit
12:39:48 <edwardk> identity: you don't
12:40:02 <identity> edwardk: Can you elaborate?
12:40:19 <edwardk> identity: we push it out to the use site because it tends to lead to use passing around fewer unnecessary dictionaries and getting more reusable components
12:40:36 <danharaj> edwardk: Now I wonder what the iterations of the yoneda embedding look like for semigroupoids.
12:40:56 <edwardk> danharaj: write it up and tell me ;)
12:41:09 <merijn> identity: Even if you could add that restriction, you would still need to add it to all your functions
12:41:21 <danharaj> edwardk: maybe if I ever go into a phd program :P
12:41:24 <identity> Hmm. Why would I need to do that?
12:41:30 <identity> Wouldn't the restriction be implicit?
12:41:51 <identity> Is there a name for something like this? I guess I'll live without it, but I'm just wondering if I'm looking for some feature that you gurus already have a name for
12:41:59 <merijn> identity: No, but I had terrible day at work so I can't be arsed to easily followable explanation right now
12:42:13 <identity> merijn: Haha, no worries :)
12:42:14 <elliott> identity: you could do it with GADTs if you can deal with constructor (un)wrapping. you still probably shouldn't
12:42:15 <merijn> Maybe someone else will volunteer
12:42:21 <danharaj> edwardk: god damnit now I am utterly intrigued by semigroupoids
12:42:25 <monochrom> identity: you have to put the restriction on all your functions
12:42:53 <edwardk> danharaj: hold up i'll give you a commit bit ;)
12:43:01 <danharaj> haha
12:43:04 <identity> Alright. that's enough for me, then. I'll just do that :)
12:43:20 <merijn> danharaj: Haha, you got suckered into being one of edwardk's worker bees :p
12:43:52 <danharaj> merijn: I have thus far managed to resist his siren song by being extremely lazy and/or swamped with work
12:44:03 * danharaj is now imagining edwardk as a mermaid
12:44:09 <Peaker> identity, you could have a type that "contains" the Ord restriction in it, but: A) When that type is the result rather than an argument, you'd still need the Ord constraint, B) If there are multiple arguments the constraint would be stored in all of them (Wasteful). It would also be stored in data structures (wasteful).
12:44:28 <edwardk> merijn: i used to do all of this myself. i've finally gotten to the point where about 15% of the commits to my repos come from other people. it is glorious
12:44:44 <edwardk> because they tend to be the big bug fix kind of commits
12:45:01 <identity> Peaker: I see.
12:45:40 <monochrom> I am, in fact, not thrilled with programmers wanting to cut corners on types like this. when you give me "joy :: a -> Map a (Map a Int)", you have to tell me "ah, but need Ord a" one way or another. either tell me in the type, or tell me in the natural language doc.
12:45:47 <danharaj> edwardk: the top hit for "semigroupoid yoneda lemma" is a log of this irc chat from just now
12:46:00 <icarot> So guys. What about this Monad being a Monad in the category of Endofunctors. (word on the street).
12:46:12 <monochrom> but no, some programmers want to cut that information away and not let me know.
12:46:27 <identity> monochrom: That's true, yeah. It would be hard to expose the fact that the type hides an implicit restriction like that without exposing internals of the api etc
12:46:33 <icarot> Which totally doesn't make sense at all. But I'm sure someone is going to come in here fmap.fmap.fmap ing me to oblivion with natural transformations and what not.
12:46:36 <icarot> <3 you all.
12:46:37 <Saizan> icarot: monoid in the category of endofunctors
12:46:43 <edwardk> identity: there are several answers to your question. the easiest and morally correct is you shouldn't do that, the next up is if you put it on the data type, it doesn't do what you mean, the third up is to say you _can_ do it with a GADT, but once you work through the consequences of doing it to a GADT and all the classes you lose, you'll realize it was a terrible idea and you should have taken the easy 'don't do that' answer.
12:46:46 <icarot> *waits patiently*
12:46:59 <danharaj> edwardk: on the other hand I found this cool paper http://arxiv.org/pdf/math/0409475.pdf
12:47:10 <edwardk> identity: the round trip time through that circular road of misery is rather long though
12:47:12 * danharaj is becoming uncannily good at googling for papers
12:47:14 <identity> edwardk: Haha. I will take the 'don't do that' answer then :)
12:47:25 <edwardk> bookmarked
12:47:38 <icarot> Okay, whoops for a second I thought Saizan was edwardk, so I read his response about GADT as having something to do with Monads. Funny. Anyway, continue Seizan.
12:47:48 <icarot> danharaj, yes.
12:48:02 <icarot> Though the only paper I'm reading right now is the classic Wadler one.
12:48:10 <icarot> the one from the 90's on Monads
12:48:26 <danharaj> don't you mean by Moggi
12:48:50 <monochrom> a natural transformation law (for join): join . fmap (fmap f) = fmap f . join.  hope you're happy :)
12:48:52 <edwardk> wadler wrote a bunch of post-moggi stuff on the topic
12:49:10 <edwardk> basically popularizing monads right up until mark p jones got us constructor classes
12:49:22 <ReinH> Oh. Quantaloids. Of course.
12:49:35 <monochrom> wait, what is constructor class?
12:49:58 <edwardk> i wish i'd named the semigroupoids package semicategories in retrospect
12:50:05 <edwardk> the vocabulary would be much more accessible
12:50:09 <danharaj> quantaloids sound like a star trek macguffin
12:50:30 <WraithM> Quantaloids, so hot right now, quantaloids.
12:50:37 <ReinH> danharaj: they totally do
12:50:42 <geekosaur> or possibly doctor who
12:50:44 <edwardk> it would also be more correct in the non-small semigroupoid case
12:51:05 <ReinH> danharaj: something something dilithium something soemthing quantaloids
12:51:21 <danharaj> edwardk: was that a pun on accessible cardinals
12:51:26 <icarot> monochrom: .. I.. was.. joking about that. I didn't even know you could express it that tersely in terms of fmap. That was great.
12:51:47 <edwardk> ouch
12:52:23 <merijn> preflex: seen roconnor
12:52:23 <preflex>  roconnor was last seen on #haskell 1 day, 19 hours, 47 minutes and 27 seconds ago, saying: I should get back to work.
12:52:46 <ksf_> .oO( If my goal is to have a small codebase, the type-level and value-level calculus should share most of their implementation)
12:53:34 <barrucadu> Are there any papers in particular I should look at if I want to learn arrows?
12:53:56 <merijn> barrucadu: "Generalising Monads to Arrows"? :)
12:54:04 <ksf_> I guess whatever the monad reader has on them should suffice
12:54:44 <ReinH> danharaj: http://www.youtube.com/watch?v=yHiUitciuJ8
12:54:45 <madmaxx> YouTube Title: 	Family guy Emperor something something..... Views: 431,062 Length: 0:10 User: 		RedV1001
12:55:03 <danharaj> seen it :P
12:55:06 <ReinH> :p
12:55:32 <ReinH> I have also just been reminded of the Family Guy Star Wars episode
12:55:37 <ReinH> which I will have to watch again
12:56:02 <barrucadu> merijn: Awesome, thanks.
12:56:55 <ReinH> ksf_: wait, is .oO a thought bubble?
12:57:41 <tomejaguar> ReinH: yeah but it looks like a sad Bender
12:57:47 <ReinH> hah
12:57:49 <ReinH> well TIL
13:05:10 <bennofs> Why is GHC's build staged? Isn't one build enough?
13:06:08 <danharaj> bennofs: do you mean GHC building a binary or the process of building GHC itself?
13:06:43 <bennofs> danharaj: building GHC itself.
13:07:22 <ksf_> bennofs, consistency.
13:08:10 <ksf_> bootstrapping is a fickle process, and if you do it multi-stage you don't have to worry about strange bugs and interactions as much.
13:10:31 <bennofs> ksf_: Couldn't I just build GHC HEAD, with say, GHC 7.6.3 in one pass?
13:10:58 <ksf_> but then you could produce a dysfunctional compiler and not notice.
13:11:17 <ksf_> see the second stage as the first test case.
13:11:36 <guymann> compilers compiling compilers compiling compilers compiling compilers compiling compilers
13:12:36 <ksf_> and IIRC the stage1 compiler is also smaller, and uses less features than the second stage. that is, stage1 can be compiled by a haskell complier, stage2 needs some GHC extensions.
13:12:50 <ksf_> but you'd have to ask an actual ghc dev about that.
13:16:10 <orzo> Can I get anyone comment on this library i'm cooking up? http://jerkface.net/~joe/Control-Bijection.html
13:16:13 <applicative> somehow the idea of 'runhugs stage1.hs' is pleasing ksf_
13:16:31 <orzo> it's much easier to use than http://hackage.haskell.org/packages/archive/TypeCompose/0.6.4/doc/html/Data-Bijection.html
13:17:13 <elliott> why use (Bijection c a b) rather than (c -> Bijection a b)?
13:19:07 <orzo> I don't know, could i still use the withDependentContext trick then?  I think i prefer 'Bijection' to refer to the one that has the context
13:20:57 <elliott> well, you could also say (Bijection (c,a) (c,b)) or something
13:21:03 <elliott> I guess that's not the same though.
13:21:15 <orzo> no its not
13:21:39 <orzo> Bijection (c,a) (c,b) wouldn't tell the type system that c is unaltered
13:22:56 <elliott> it all seems weird :)
13:23:00 <applicative> clearly type ContextTransform c t a b = c -> Either a b -> t
13:23:13 <applicative> should be type ContextTransform s t a b = s -> Either a b -> t
13:23:22 <orzo> heh
13:23:49 <jfischoff> orzo: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.153.9383&rep=rep1&type=pdf
13:24:02 <orzo> i've seen that
13:24:17 <orzo> i'm not terribly impressed frankly, have you tried to use it?
13:24:20 <orzo> heh
13:24:24 <jfischoff> yeah it sucks
13:24:44 <orzo> my context addition and control structures make it a lot easier to work with
13:24:54 <jfischoff> hmm
13:25:31 <orzo> as you caqn tell from my example "+++/++" -> [3,2] compared to their example "reverse list"
13:26:40 <owen__> hey guys, I'm looking to get into FRP and I'm looking for suggestions
13:27:03 <owen__> (Netwire/reactive-banana/anything else)
13:27:24 <identity> Isn't there some way to do f (x, y) (z, _) = (x + z, y) with arrows?
13:29:41 <Heffalump> is there an easy way to browse the versions of packages in past Haskell Platform releases? It seems fiddly to extract it from the github history, and I can only find the latest one on any obvious webpage.
13:31:12 <tibbe> .
13:31:14 <joelteon> identity: (+) &&& const?
13:31:59 <joelteon> > (+) &&& const $ (1, 2) (3, 4)
13:32:00 <lambdabot>   Couldn't match expected type `(t2, t3) -> a0'
13:32:00 <lambdabot>              with actual type...
13:32:02 <orzo> you gotta shuffle the things around
13:32:06 <joelteon> :t (+) &&& const
13:32:07 <lambdabot> Num a => a -> (a -> a, b -> a)
13:32:13 <joelteon> oh no, it's (+) *** const
13:32:15 <orzo> i have scootLeft in my lib
13:32:16 <joelteon> I always get those confused
13:32:27 <orzo> dunno what arrow thingy it corresponds to if any
13:33:04 <joelteon> huh, well, it's sort of that but not really
13:33:10 <joelteon> because (***) is unary
13:33:18 <joelteon> err, it provides a unary function
13:33:21 <joelteon> wow, don't even listen to me
13:34:17 * hackagebot securemem 0.1.3 - abstraction to an auto scrubbing and const time eq, memory chunk.  http://hackage.haskell.org/package/securemem-0.1.3 (VincentHanquez)
13:34:40 <orzo> (x,y),(z,_) -> scootLeft -> (((x,y),z),_) -> first scootRight -> ((x,(y,z)),_) -> first second swapA -> ((x,(z,y)),_) -> ...
13:37:00 <identity> Disregard it, it is unnecessary :)
13:38:43 <orzo> i was thinking i'd add a template haskell gadget for permutation bijections
13:39:18 * hackagebot crypto-cipher-tests 0.0.4 - Generic cryptography cipher tests  http://hackage.haskell.org/package/crypto-cipher-tests-0.0.4 (VincentHanquez)
13:41:26 <notasi> could somebody help me understand why "data Foo a = Foo (a Int)" has kind (* -> *) -> * and not just * -> * ?
13:41:41 <mauke> because a takes a parameter
13:41:44 <merijn> notasi: "(a Int)" you're passing Int to a
13:41:54 <tikhon> think about the valid types you could plug in for a
13:42:06 <tikhon> Foo (Maybe Int)
13:42:07 <glguy> notasi: did you mean to write: data Foo a = Foo a Int ?
13:42:23 <notasi> so you could have type Foo Maybe, but not Foo Int
13:42:29 <merijn> notasi: Yes
13:42:30 <notasi> Thanks, I think I get it
13:43:03 <merijn> notasi: Because the constructor Foo takes "Maybe Int" as argument in case of "Foo Maybe"
13:43:19 <tikhon> funny thought: Foo Maybe is completely valid but looks odd
13:44:04 <tikhon> because you normally do not see a higher-kinded type like Maybe without also having a concrete type for it somewhere else in the signature
13:44:08 <bennofs> >  let f = _1 ((fst <&>) . (+)) in f (1,"ads") (3,Just ())
13:44:09 <lambdabot>   (4,"ads")
13:44:16 <merijn> tikhon: Hah, "Foo Just" is valid too*
13:44:18 * hackagebot crypto-cipher-types 0.0.4 - Generic cryptography cipher types  http://hackage.haskell.org/package/crypto-cipher-types-0.0.4 (VincentHanquez)
13:44:28 <merijn> * - Provided you turn on DataKinds
13:44:48 <merijn> Although probably not without explicit kind signature on Foo...
13:44:54 <tikhon> wait, wouldn't that be Foo 'Just or something?
13:45:20 <merijn> tikhon: The ' is only necessary to disambiguate ambiguous types like [Int], otherwise it's optional
13:45:26 <tikhon> ah, okay
13:45:53 <tikhon> so, more things for a hypothetical underhanded Haskell contest :P
13:46:03 <tikhon> (which would not work nearly as well as the C version, I'm afraid)
13:46:36 <osfameron> tikhon: doesn't that just make it more challenging?
13:46:50 <c_wraith> Haskell can do lots of underhanded evil things! They're just more conspicuous.
13:47:08 <tikhon> conspicuous and underhanded are (at least for this) opposed
13:47:32 <tikhon> the idea behind the underhanded C contest is to write a program that looks completely innocent but does something evil
13:47:37 <c_wraith> That's why you need to insert them into the middle of code people don't expect to be clean.
13:47:42 <c_wraith> Like..  Evil Storable instances.
13:47:55 <c_wraith> People expect Storable to be well-behaved..  but there's no guarantee!
13:48:05 <dagano> Q : yes or no : i know you can have a monadic implementation of a parser, is it safe to say that a parser IS a monad?
13:48:17 <c_wraith> But the code can be littered with pointer manipulations and memory copies, and it doesn't look out of place.
13:48:33 <tomejaguar> dagano: no
13:48:46 <tomejaguar> In the same way it is not safe to say that a parser IS a type
13:49:06 <tikhon> dagano: the parser type (ie Parsec's Parser) forms a monad
13:49:18 <dagano> ie would you say a parser inhabits a type rather than IS a type?
13:49:29 <tikhon> yes
13:49:37 <tikhon> just like a number *inhabits* Int
13:49:44 <merijn> dagano: "a parser type" may be a monad, a parser is not a monad
13:49:54 <applicative> dagano: just say instance Monad Parser where ... and have done with ordinary language
13:50:21 <dagano> applicative: yeah .. all kinds of traps in ordinary language
13:50:34 <merijn> dagano: There are implementations of parsers (and thus parser types) that are not monadic
13:50:43 <merijn> Like shift-reduce parsers
13:50:57 <merijn> Well, maybe you could make a monadic shift-reduce parser, I dunno
13:51:29 <dagano> thanks, channel
13:57:08 <skypers> I talked about event programming before
13:57:31 <skypers> something like Event -> (Event -> a -> a) -> a
13:57:39 <skypers> is this a cool way to use State monad?
13:59:19 <ocharles> urgh, you can't use GHC Generics with GADTs?
14:01:47 <danharaj> nope
14:02:00 <danharaj> template_haskell_reasons
14:02:17 <dreixel> ocharles: need some help with GHC.Generics?
14:02:20 <ocharles> well there goes the ghc.generics approach to db serialization :(
14:02:35 <danharaj> ocharles: we use ghc.generics for our ORM at work.
14:02:36 <danharaj> it is ok.
14:02:53 <dreixel> ah, no, GADTs won't work, I'm afraid.
14:02:58 <dreixel> at least not out of the box.
14:03:18 <ocharles> dreixel: I'm trying to work out a way to serialize some data from Haskell into a DB. I want to make the compiler help me ensure that I have considered all fields of the data, even if I decide to say "don't care"
14:03:44 <ocharles> edwardk suggested I try ghc.generics, but the data itself is in a GADT, so it doesn't seem possible
14:03:57 <Peaker> skypers, not sure that type relates to state monad at all
14:03:57 <dreixel> ocharles: GADTs are problematic for generics in general
14:04:21 <ocharles> https://github.com/metabrainz/musicbrainz-data/blob/master/src/MusicBrainz/Types/Internal.hs#L561 is what ultimately needs to go in
14:05:38 <skypers> Peaker: I don’t really know how to use State monad…
14:06:16 <Polarina> skypers, go ahead and poke around with it. :)
14:06:25 <Peaker> skypers, that's ok, but (Event -> (Event -> a -> a) -> a) isn't likely an opportunity to
14:06:48 <skypers> so I just should keep it that way?
14:07:03 <skypers> btw, the fact of altering an object with a fold, is it a common pattern?
14:07:11 <applicat1ve> owen__: ocharles probably has view on the best frp library http://ocharles.org.uk/blog/posts/2013-08-18-asteroids-in-netwire.html
14:07:23 <Peaker> skypers, not enough information :)
14:07:24 <jesyspa> Event -> (Event -> a -> a) -> a -- how can this even work?  f e g = fix $ g e ?  Or am I missing something about Event?
14:07:27 <Peaker> skypers, but it's possible
14:07:32 <ocharles> applicat1ve: d'aww
14:07:40 <applicat1ve> ;)
14:07:48 <skypers> jesyspa: what is fix again?
14:08:03 <danharaj> idk that post convinced me arrow frp sucks :P
14:08:04 <jesyspa> skypers: I doubt it's what you want, but fix finds the fixed point; (a -> a) -> a
14:08:07 <skypers> jesyspa: it’s a -> (Event -> a -> a) -> a
14:08:09 <applicat1ve> hm, maybe owen__ has vanished anyway
14:08:15 <owen__> i'm here
14:08:17 <jesyspa> skypers: Oh, that clarifies.
14:08:22 <skypers> the fixed point?
14:08:23 <ocharles> dreixel: what techniques are available to work around gadts?
14:08:24 <owen__> ocharles: I'm here
14:08:40 <skypers> I need to inquire about that fix function
14:08:48 <jesyspa> skypers: f (fix f) is equal to fix f.  Don't worry, I must have misread; it's not relevant to what you're doing.
14:08:55 <owen__> ocharles: why did you choose netwire over everything else?
14:09:20 <ocharles> dreixel: also, you're José right?
14:09:25 <owen__> do you think I need a firm grasp of arrows before I jump into netwire?
14:09:28 <ocharles> owen__: it seemed conceptually simple
14:09:34 <ocharles> owen__: netwire was the first time i used arrows
14:09:41 <ocharles> owen__: i didn't understand arrow notation when i started learning it
14:09:45 <dreixel> ocharles: yes (though I'd rather go by Pedro)
14:09:46 <merijn> tbh, Arrows aren't that hard
14:09:56 <skypers> jesyspa: as I understand in hackage
14:10:01 <merijn> the arrow notation is a bit tricky, but it's not used that often
14:10:09 <ocharles> dreixel: ah, ok :) well hi - nice to speak to you again! (we met briefly at london haskell)
14:10:11 <skypers> fix is similar to const, but in the reverse way?
14:10:27 <dreixel> ocharles: for example, José Pedro Magalhães and Johan Jeuring. Generic Programming for Indexed Datatypes. In Proceedings of the 7th ACM SIGPLAN Workshop on Generic Programming (WGP'11), pp. 37–46, ACM, 2011. http://dreixel.net/research/pdf/gpid.pdf
14:10:29 <merijn> owen__: I recommend the "Generalising Monads to Arrows" paper, it's really readable (at least the first half) and that should teach you enough
14:10:35 <dreixel> ocharles: yes, I remember :)
14:10:46 <owen__> merijn: thanks
14:10:51 <owen__> will do
14:10:53 <ocharles> ah that paper sounds right up my street, from that title
14:10:57 <skypers> that means
14:10:59 <skypers> fix f
14:11:01 <dreixel> ocharles: but I'll have a better look tomorrow. maybe your GADT is simple enough to allow some workaround
14:11:08 <skypers> it takes a x, and returns that x?
14:11:27 <ocharles> dreixel: my gadt may even be complete abuse of a gadt and not the best way to express what i'm doing, too
14:11:37 <skypers> fix f = let x = f x in x
14:11:38 <merijn> owen__: It introduces all the combinators one by one plus some examples how you can use them. The second half goes into laws and what not and becomes a bit more complicated, but the first half should be plenty to understand the typeclass and use it
14:11:39 <applicat1ve> > fix (1:)
14:11:40 <ocharles> but i think it works well
14:11:40 <skypers> woah
14:11:41 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:11:46 <skypers> that’s weird
14:12:05 <merijn> skypers: :)
14:12:10 <skypers> > fix (+1)
14:12:17 <lambdabot>   mueval-core: Time limit exceeded
14:12:18 <applicat1ve> good luck
14:12:19 <joelteon> > fix (\f x -> if x == 1 then 1 else x * f x) 10
14:12:20 <lambdabot>   *Exception: stack overflow
14:12:26 <joelteon> oh, whoops
14:12:31 <joelteon> > fix (\f x -> if x == 1 then 1 else x * f (x - 1)) 10
14:12:32 <lambdabot>   3628800
14:12:34 <skypers> fix (+)
14:12:37 <joelteon> factorial!
14:12:40 <applicat1ve> > fix error -- #haskell favorite
14:12:41 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:12:41 <ocharles> owen__: I don't really use any arrow stuff, other than &&& and ***, which can be understood diagramatically quite easily. I don't use ArrowChoice or anything, and make a lot of use of Alternative/Applicative instead
14:12:43 <dreixel> ocharles: right. Do you need the index there?
14:12:48 <skypers> woh:D
14:12:52 <joelteon> because you *can't* fix error, you get infinite errors
14:12:59 <skypers> I don’t understand fix.
14:13:01 <skypers> like
14:13:01 <joelteon> or as many as you're willing to evaluate
14:13:05 <skypers> don’t understand at all.
14:13:06 <dreixel> or could Tree be a kind * datatype?
14:13:14 <merijn> skypers: It's just relying on the fact that you don't need it's argument to partially return a value
14:13:33 <merijn> > let ones = 1:ones in ones -- skypers: Does this make some sense?
14:13:34 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:13:41 <monochrom> skypers: see my http://www.vex.net/~trebla/haskell/fix.xhtml
14:14:11 <ocharles> dreixel: i'm not sure. i believe i was using it more like a phantom type to unify various other things later, i'll have to explore the code more
14:14:17 <ocharles> it's been a while since i wrote this
14:15:09 <dreixel> ocharles: it seems, at least, that it would work with the techniques described in that paper. we use similar stuff in our modelling of musical harmony GADTs
14:15:18 <dagano> @quote referential transperency
14:15:19 <lambdabot> No quotes for this person. stty: unknown mode: doofus
14:15:30 <dagano> poop
14:15:45 <tomejaguar> Arrows are actually incredibly easy.  Easier than monads for sure.
14:15:59 <merijn> dagano: No spaces, now it's look from quotes by referential :p
14:16:00 <monochrom> @quote referential.transparency
14:16:01 <lambdabot> dibblego says: Java programmers prefer referential transparency too, they just call it "design patterns" or something
14:16:11 <ocharles> dreixel: and does this work build ghc.generics, or is it a different generics library?
14:16:15 <ocharles> i've only scanned the abstract so far
14:16:18 <Peaker> dibblego says the silliest things
14:16:22 <dreixel> ocharles: a different one.
14:16:24 <danharaj> Arrows are monads.
14:16:28 <dreixel> not significantly different, though
14:16:30 <ocharles> ah, instant-generics
14:16:31 <monochrom> if you write two words "@quote x y", it takes "x" as author rather than part of sentence
14:16:40 <dagano> ok thank you
14:16:46 <joelteon> @quote
14:16:46 <lambdabot> mbishop says: Nambla calculus? you implement numbers using little boys?
14:16:48 <ocharles> alright, i'll give it a read and see where i get with that
14:16:53 <ocharles> thanks for the pointers, dreixel
14:16:57 <dagano> hahahaha nambla calculus
14:16:59 <dreixel> np
14:17:08 <monochrom> hmm! what is nambla calculus?
14:17:09 <dreixel> I'll have a look at it tomorrow too
14:17:11 <tomejaguar> danharaj: ?
14:17:14 <applicat1ve> hah
14:17:17 <n-dolio> It was also spelled "transperency" the first time.
14:17:20 <joelteon> @quote otters
14:17:20 <lambdabot> otters says: heh, F# is just the unboxed version of F
14:17:31 <applicat1ve> monochrom: mbl = man-boy love
14:17:32 <ocharles> dreixel: cool. i'll be around until 6pm utc for sure though probably not in the evening. feel free to @tell or whatever
14:17:41 <monochrom> yikes, transperency?!
14:17:41 <dreixel> will do
14:17:47 <monochrom> @quote referential.transperency
14:17:47 <lambdabot> No quotes match. Maybe you made a typo?
14:17:47 <joelteon> trans-parent-see
14:18:19 <skypers> is fix part of a class?
14:18:23 <applicat1ve> grrr, ghc-head failed to build ... and it was almost there ...
14:18:31 <merijn> skypers: No, just a function
14:18:37 <danharaj> tomejaguar: https://www-mmm.is.s.u-tokyo.ac.jp/~ichiro/papers/arrows.pdf
14:18:41 <merijn> skypers: Althought there is a MonadFix class for monadic fix
14:18:48 <skypers> my goad
14:18:51 <monochrom> head : unsafe :: ghc head : ghc unsafe :)
14:18:56 <danharaj> arrows are just strong monads in the 2-category of profunctors. what's the problem?
14:18:56 <skypers> I don’t even understand function fix
14:19:00 <skypers> so monad one…
14:19:04 <merijn> skypers: Which, unsurprisingly has the type "mfix :: MonadFix m => (a -> m a) -> m a
14:19:13 <joelteon> it's just fix with an m
14:19:13 <monochrom> fix and monad are unrelated
14:19:13 <skypers> yeah
14:19:16 <merijn> skypers: monochrom's explanation is pretty clear
14:19:43 <monochrom> if you want mfix, http://www.haskell.org/haskellwiki/MonadFix
14:19:50 <monochrom> but you will ignore all my advices
14:20:22 <merijn> monochrom: I don't think he wants anything beyond just answers to curiosity?
14:20:25 <tomejaguar> danharaj: Is that actually true?
14:20:31 <danharaj> yes
14:20:43 <tomejaguar> That's brilliant.
14:20:47 <danharaj> it's pretty cool yes
14:21:37 <ocharles> danharaj: oh *now* you tell me
14:21:48 <danharaj> ocharles: hm?
14:22:02 <ocharles> </sarcasm> <!-- re category theory jokes -->
14:22:52 <skypers> I just want to understand it
14:23:08 <skypers> it does nothing to do with my event programming problem of course
14:23:18 <tomejaguar> danharaj: I'm a bit puzzled why you say "monad in the ..." rather than "monoid object in the ..."
14:23:24 <tomejaguar> is there a crucial distinction I'm missing?
14:24:06 <merijn> skypers: Did you read monochrom's fix link? (Not the MonadFix one)
14:24:17 <skypers> yeah
14:24:20 <zzing> If I have two definitions of a series of functions if k = 0 vs if k ≠ 0, what is the best way to keep the definitions separate, but still having a definition that allows me to use one of these functions once where it will automatically refer to the right version.
14:24:20 <skypers> the recursive thing
14:24:21 <skypers> well
14:24:28 <skypers> let x = f x in x
14:24:29 <elliott> tomejaguar: a monad in C is a monoid in the category of endofunctors on C?
14:24:31 <skypers> it sounds like
14:24:35 <skypers> segfault
14:24:35 <skypers> :DD
14:24:36 <skypers> for me
14:24:47 <danharaj> tomejaguar: a monad in a 2-category, not a monoid in a functor category.
14:24:55 <elliott> oh, I didn't read context.
14:25:01 <merijn> skypers: It's not different from "let ones = 1:ones in ones" though
14:25:19 <notasi> > take 10 $ fix (1:)
14:25:21 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
14:25:22 <danharaj> elliott: we should start a learndb for haskell so I can write *_unreasons entries.
14:25:28 <merijn> skypers: The thing is that "\ones -> 1:ones" can return the "1:" bit before looking at the value of ones
14:25:51 <chidy> @src drop
14:25:51 <lambdabot> drop n xs     | n <= 0 =  xs
14:25:51 <lambdabot> drop _ []              =  []
14:25:51 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
14:26:01 <cas__> addsource drop
14:26:45 <merijn> skypers: "fix (1:)" = "1:fix (1:)" = "1:1:fix (1:)" = "1:1:1:fix (1:)", etc.
14:26:58 <skypers> hm
14:26:59 <skypers> so
14:27:04 <skypers> let x = f x in x
14:27:08 <skypers> this is hard for me to read
14:27:28 <skypers> because there’s no value here
14:27:29 <joelteon> yeah, I don't remember why it's defined like that
14:27:31 <applicat1ve> well, it means f ( f ( f ...))
14:27:32 <skypers> just a function
14:27:36 <joelteon> it's operationally similar to fix f = f (fix f)
14:27:39 <Polarina> @remember danharaj arrows are just strong monads in the 2-category of profunctors. what's the problem?
14:27:39 <lambdabot> Nice!
14:27:44 <monochrom> that is bloody why my article begin with easy-to-read concrete code
14:27:58 <skypers> so it takes a function
14:28:07 <skypers> and apply its result to itself
14:28:11 <skypers> applies*
14:28:17 <skypers> recursively
14:28:27 <skypers> but from where the value comes?
14:28:40 <joelteon> the value is the result of the function call
14:28:57 <monochrom> that is also bloody why my article doesn't use this broken doomed "intuitive" "explanation", but rather reliable code rewriting.
14:29:04 <skypers> > take 4 $ fix (++" hi?")
14:29:07 <applicat1ve> > take 1 (fix (1:))
14:29:08 <joelteon> skypers: i'm thinking read the article
14:29:08 <lambdabot>   [1]
14:29:11 <lambdabot>   mueval-core: Time limit exceeded
14:29:11 <skypers> WHAT
14:29:15 <tomejaguar> danharaj: It looks like a monad in a 2-category is a monoid object in the "2-cell category" of C (whatever the right name for that is)
14:29:18 <tomejaguar> Is that right?
14:29:22 <joelteon> > take 4 $ fix ("ha"++)
14:29:23 <lambdabot>   "haha"
14:29:30 <merijn> skypers: (++"hi?") doesn't return anything before recursing
14:29:34 <joelteon> yeah
14:29:43 <notasi> > fix (const "Hello, world!")
14:29:44 <applicat1ve> fix (1:) = 1: (fix (1:)); so take 1 (fix (1:)) is [1]
14:29:44 <lambdabot>   "Hello, world!"
14:29:50 <tomejaguar> Ah "one can define a monad on an object a of a bicategory K as just a monoid in the endomorphism category K(a,a)"
14:30:00 <joelteon> :t fix se
14:30:00 <lambdabot>     Not in scope: `se'
14:30:01 <lambdabot>     Perhaps you meant one of these:
14:30:01 <lambdabot>       `seq' (imported from Prelude),
14:30:01 <joelteon> :t fix seq
14:30:01 <dagano> :t (<*>)
14:30:02 <lambdabot> b -> b
14:30:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:30:14 <skypers> hm
14:30:22 <skypers> gonna try in my ghci
14:30:31 <c_wraith> :t loeb
14:30:32 <lambdabot> Not in scope: `loeb'
14:30:36 <danharaj> tomejaguar: that's probably right in a sense
14:30:57 <skypers> fix (+1) never ends?
14:31:02 <skypers> because it’s
14:31:07 <skypers> 1+1+1+1+1+…
14:31:07 <skypers> ?
14:31:20 <tomejaguar> danharaj: It's right in the sense of the nLab so I'm inclined to believe it: http://ncatlab.org/nlab/show/monad
14:31:22 <applicat1ve> yes, and + is strict, so it needs the second arguments
14:31:24 <monochrom> fix (+1) "ends" iff x=x+1 "ends"
14:31:36 <jesyspa> skypers: Do you know a number x such that 1+x == x?  Plus the strictness, of course.
14:36:11 <merijn> jesyspa: (+) is not always strict
14:36:21 <merijn> jesyspa: Defining non-strict peano arithmetic is rather easy
14:37:13 <applicat1ve> it's strict for the builtin numbers, not intrinsically strict
14:37:20 <monochrom> this is why I carefully said: fix (+1) "ends" iff x=x+1 "ends". also, I leave it to you to define "ends", this part is also non-unique
14:37:51 <applicat1ve> if you do fix (+1) i don't think it will suddenly hit on lazy naturals
14:37:56 <applicat1ve> i mean, in ghci
14:38:07 <notasi> > take 10 $ fix $ (0:) . scanl (+) 1
14:38:08 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
14:38:41 <monochrom> for that one, see my http://www.vex.net/~trebla/haskell/scanl.xhtml
14:39:13 <kuribas> What's the time complexity of log(2) + log(3) + log(4) + ... + log(n)?
14:39:30 <kuribas> Is it n log(n)?
14:39:34 <joelteon> yeah
14:39:39 <joelteon> oh, sorry, wrong window
14:39:41 <joelteon> kuribas: I'm not sure
14:39:47 <kuribas> no problem
14:40:14 <applicat1ve> > take 10 $ fix $ (1:) . scanl1 (+)
14:40:15 <monochrom> yes, it's n log n
14:40:15 <lambdabot>   [1,1,2,4,8,16,32,64,128,256]
14:40:35 <tomejaguar> Why is it n log n?
14:40:46 <tomejaguar> log(n) takes log(n) time to evaluate?
14:41:19 <monochrom> oh, you interpret the question literally :)  then you're right to doubt my answer
14:41:33 <c_wraith> n log n seems wrong, no matter what the assumptions are.
14:41:54 <applicat1ve> its the same as log (n!), no?
14:42:21 <tomejaguar> Ah I see. I guess kuribas meant what is the order of log 2 + ... + log n.
14:42:31 <tomejaguar> Which is an entirely different question.
14:42:37 <monochrom> right
14:42:43 <applicat1ve> yes, it was a little confusing
14:43:03 <monochrom> I confess to not knowing the real question
14:45:13 <kuribas> I meant, if I have an algorithm taking O(n)=log(n), how much time does it take to evaluate on n times on 1..n data?
14:45:28 <S_J> Can someone answer this. Control.Concurrent.Chan, readChan and WriteChan, is it threadsafe? are they locked under the hood? or do I need to protect the Channel when I access it?
14:45:51 <merijn> heh
14:45:56 <tomejaguar> kuribas: that's still somewhat confused terminology, but we're pretty sure your answer is n log n.
14:46:07 <merijn> Num requires negation? I guess you can't make Peano an instance without undefined/error then?
14:46:25 <applicat1ve> right
14:46:33 <kuribas> tomejaguar: ok, thanks.
14:47:20 <tikhon> merijn: you couldn't write a reasonable fromInteger either
14:47:50 <jmcarthur_mobile> Yes you can.
14:47:53 <monochrom> readChan and writeChan are thread safe. I thought I already answered it many hours ago
14:48:01 <jmcarthur_mobile> Or, well, you can for literals
14:48:13 <merijn> jmcarthur_mobile: oh? how?
14:48:24 <elliott> monochrom: you did
14:48:32 <S_J> monochrom: sorry, I didnt see it.
14:48:38 <S_J> And how is that achieved?
14:48:45 <jmcarthur_mobile> But I guess it has to support negative number anyway, even though the literal desugaring doesn't use that feature of fromIntegral
14:48:53 <monochrom> what is with people who ignore all my answers? even when I make sure to include their names?
14:48:57 <jmcarthur_mobile> *fromInteger
14:49:04 <joelteon> monochrom: more buzzwords
14:49:06 <kuribas> tomejaguar: Like inserting elements in an empty search tree one at a time.
14:49:19 <jmcarthur_mobile> merijn: I was too hasty with that response
14:49:21 <merijn> monochrom: You're shadowbanned in #haskell ;)
14:49:22 <enthropy> jmcarthur_mobile: that's for   data Peano = Z | S Peano, no?
14:49:33 <ent> a
14:49:49 <enthropy> jmcarthur_mobile: not the more useful  data Z = Z; data S a = S a
14:49:52 <jmcarthur_mobile> enthropy: see above
14:50:07 <jmcarthur_mobile> Oh maybe I totally lacked context too
14:50:30 <merijn> enthropy: How is that more useful?
14:50:36 <tomejaguar> kuribas: yes, you mean an operation whose time complexity is O(log n)
14:51:46 <kuribas> yes
14:51:51 <monochrom> I forgot the elementary proof for log(2) + ... + log(n) ∈ Ω(n log n)
14:51:57 <clahey> Can anyone explain to me non O(n) lazy integers?
14:52:07 <enthropy> merijn: well I don't see too much use for lazy numbers
14:52:10 <S_J> monochrom: sorry, I must get a better client that mirc.
14:52:30 <clahey> lazy naturals, I mean.
14:52:34 <enthropy> sometimes you want to say something like (length x > 3)
14:52:52 <applicat1ve> clahey: they are just the default 'data Nat = Zero | Succ Nat'
14:53:00 <merijn> enthropy: No, I mean how is "data Z = Z; data S a = S a" more useful than "data Peano = Z | S Peano"?
14:53:03 <applicat1ve> clahey: or am I not understanding
14:53:13 <clahey> applicat1ve, That's O(n)
14:53:18 <monochrom> enthropy: consider genericLength x > 3
14:53:45 <monochrom> you are of course right about length x > fromIntegral 3
14:53:56 <applicat1ve> what operation is O(n) ?  /me looks at the transcript
14:53:59 <enthropy> merijn: I mean that I don't come across many situations where data Peano would be useful
14:54:23 <enthropy> monochrom: I just write    not (null (drop 3 x))
14:54:23 <merijn> enthropy: DataKinds and typefamilies working on type level numbers! :)
14:54:37 <monochrom> that is the best :)
14:54:43 <clahey> applicat1ve, Well, (< n) is O(n)
14:55:14 <monochrom> yikes, "fromIntegral 3" is redundant
14:55:17 <applicat1ve> m < n follows m, no?
14:56:10 <clahey> applicat1ve, I guess you can't do (<) :: Nat -> Integer -> Bool.
14:56:15 <clahey> But similar.
14:56:28 <clahey> lessThanInteger ::.
14:56:50 <applicat1ve> Zero < n = True; S m < S n = m < n  etc
14:56:57 <enthropy> merijn: you use ghc-7.7? DataKinds sounds like it improves things, but in a bit of experimentation with it on ghc 7.6 I've done doesn't show that
14:57:09 <clahey> applicat1ve, Right.  That's O(n).
14:57:36 <clahey> Or O(m) or whatever.
14:57:43 <applicat1ve> clahey, in any case, i don't have to develop the whole second argument
14:57:44 <clahey> I was hoping for O(log m) or something.
14:58:34 <applicat1ve> hm, maybe we can binarize these 'lazy conaturals'
14:58:51 <tomejaguar> monochrom: Integrate log x
14:58:52 <merijn> enthropy: I experiment on 7.7, but I use DataKinds on 7.6 too
14:59:01 <merijn> enthropy: Just lose out on closed type families in 7.6
14:59:15 <monochrom> nice, thanks tomejaguar
14:59:20 <applicat1ve> whats wrong with datakinds on ghc 7.6 ? enthropy
14:59:40 <clahey> applicat1ve, Yeah, that's what I was thinking about.
15:00:38 <clahey> applicat1ve, Clearly you have data Nat = Zero | something
15:03:46 <clahey> So, I've been working on ways to represent the iterations required to escape for a point on the mandelbrot set.
15:03:52 <clahey> Since the values of that are the conaturals.
15:04:22 <clahey> And I thought of instead of using a lazy natural, just having a list of the values and treating that kind of like a lazy natural.
15:04:46 <clahey> And so I thought of storing a tree of values instead of a list.
15:05:06 <clahey> A tree read bredth first.
15:05:58 <clahey> So you could have the naturals be  Nat = Tail | Branch Nat nat
15:06:05 <clahey> Nat = Tail | Branch Nat Nat
15:06:46 <clahey> And  > n = find the nth position in the tree and if you hit a Tail on the way there, return False.
15:07:06 <clahey> But I haven't yet calculated the formula for the path to the nth position and so I haven't finalized it.
15:07:15 <clahey> And I have to leave, but I'm going to continue thinking about this.
15:07:18 <S_J> what is a unification algorithm?
15:07:32 <monochrom> oh! I now remember the elementary proof. it doesn't even need integrals. log(1) + ... + log(floor(n/2)) + ... + log(n) (n terms) >= log(floor(n/2)) + ... + log(floor(n/2)) (floor(n/2)+1 terms)
15:07:33 <enthropy> applicat1ve: not sure.
15:07:59 <SeanMHickman> Does lens generalize splitAt?
15:08:43 <levi> S_J: An algorithm for solving symbolic equations.
15:09:25 <exicer> Is there a haskell socketio implementation ?
15:09:33 <exicer> I had a quick google but found nothing
15:10:25 <levi> exicer: I don't think so, and I'm not sure you really want one. Unless it's changed greatly in the recent past, it has lots of poor behavior at edge cases.
15:10:58 <exicer> levi: Just something I was familiar with. I was using it to keep an angularjs front end's data in sync with the backend
15:11:07 <exicer> I was wondering how I would do something similar in haskell
15:11:14 <tomejaguar> monochrom: k(2n-k) <= n^2.  Nice.
15:11:25 <levi> I found sockjs to be a better solution to providing websocket-like interfaces when actual websockets aren't available.
15:11:35 <exicer> levi: Huh, not used that.
15:12:02 <levi> It's a bit simpler and better-specified, so probably easier to make a Haskell implementation for.
15:12:51 <exicer> Right right. I think my haskell abilities are probably a bit rubbish for doing something like that for a few weeks :P
15:14:14 <levi> Well, once I get a bit further along with the back-end stuff I'm hacking on right now, I may take another stab at it, but last time I looked at it I was unsure of where to start with all the major Haskell web servers using different streaming mechanisms.
15:14:46 <skypers> is there a way with cabal-dev to add a project to track it?
15:14:49 <skypers> something like
15:14:55 <skypers> cabal-dev track ./foo ./bar
15:15:10 <skypers> and a cabal-dev compile or something just compile all tracked project?
15:15:20 <levi> There appear to be reasonable websocket implementations for Yesod/WAI's conduits and the Iteratees that Snap uses.
15:15:51 <skypers> I’d like to test several libs at the same time, but I often update them, so it’s not comfy right now
15:16:39 <hape01> > liftM (+1) Just 1
15:16:40 <lambdabot>   No instance for (GHC.Show.Show a0)
15:16:40 <lambdabot>    arising from a use of `M951406369.sho...
15:17:18 <hape01> > Just 2
15:17:19 <lambdabot>   Just 2
15:17:31 <tikhon> > liftM (+1) (Just 1)
15:17:32 <lambdabot>   Just 2
15:17:39 <tikhon> :t liftM (+1) Just 1
15:17:40 <lambdabot> (Num (Maybe a), Num a) => Maybe a
15:17:42 <hape01> thx
15:17:56 <tikhon> that was an absolutely *horrible* error message
15:18:21 <tikhon> > (+1) <$> Just 1
15:18:22 <lambdabot>   Just 2
15:18:31 <tikhon> I think the (<$>) version is prettier, coincidentally
15:19:16 <skypers> any idea for my design issue?
15:19:20 * hackagebot hath 0.0.4 - Hath manipulates network blocks in CIDR notation.  http://hackage.haskell.org/package/hath-0.0.4 (MichaelOrlitzky)
15:19:23 <augur> tikhon: ofcourse, the idiom brackets version is best!
15:19:31 <levi> > (+) <$> Just 1 <$> Just 2
15:19:32 <lambdabot>   Couldn't match expected type `a0 -> b0'
15:19:32 <lambdabot>              with actual type `Data...
15:19:34 <augur> (| (+1) (Just 1) |)
15:19:46 <tikhon> > (+) <$> Just 1 <*> Just 2
15:19:47 <augur> or if we have quasi brackets
15:19:48 <lambdabot>   Just 3
15:19:51 <levi> > (+) <$> Just 1 <*> Just 2
15:19:51 <S_J> does getLine "destroy" threads?
15:19:52 <lambdabot>   Just 3
15:20:03 <augur> (| |( 1 )| + |( 1 )| |)
15:20:07 <levi> I knew the right thing, but my fingers didn't. :P
15:20:23 <augur> or better yet, quasi quote brackets!
15:20:23 <tikhon> augur: a bit too much noise, methinks
15:20:43 <augur> `( ,1 + ,1 )
15:21:02 <tikhon> and that's too lispy :P
15:21:13 <augur> tikhon: too lispy, but it works nicely, i think
15:21:28 <augur> `( ... ) is inside the special bracket mode
15:21:38 <augur> where normal application becomes <*>
15:21:38 <tikhon> for quasiquoting or for idiom brackets?
15:21:46 <augur> and the final function is pure'd
15:22:04 <tikhon> hmm
15:22:05 <augur> , is for dropping out of this mode but leaving behind a pure
15:22:24 <tikhon> wouldn't (| 1 + Just 2 |) work correctly with normal idiom brackets?
15:22:28 <augur> so that `( ,1 + ,2 ) == pure (+) <*> pure 1 <*> pure 2
15:22:37 <augur> tikhon: no, i dont think so
15:22:43 <augur> unless idiom brackets are type driven
15:23:10 <augur> also im not sure how deep the idiom goes
15:23:19 <skypers> I have some cabalized projects in different dir, i.e. ./foo ./bar and ./zoo. I often update them and bar depends on foo and zoo depends on both foo and bar. How could I use ghci the best way here?
15:23:34 <augur> is (| 1 + Just 2 |) the same thing as pure (+) <*> 1 <*> Just 2
15:23:35 <augur> or is it
15:23:39 <tikhon> hmm
15:23:43 <augur> pure (+) <*> Just 1 <*> Just 2
15:23:48 <tikhon> Just 1 + Just 2 works, so I think you're right
15:23:48 <augur> or is it even more perversely
15:23:57 <tikhon> (| Just 1  + Just 2 |), I mean
15:24:04 <augur> pure (+) <*> ... <*> (pure Just <*> pure 2)
15:24:09 <levi> SHE's idiom brackets apparently do allow you to do infix operators.
15:24:15 <augur> levi: yeah
15:24:17 <joelteon> do idiom brackets work?
15:24:23 <tikhon> yeah, with SHE, (| Just 1 + Just 2 |) works
15:24:24 <joelteon> are they in HEAD or something?
15:24:26 <levi> With SHE, they do.
15:24:36 <joelteon> there's a difficult acronym to google
15:24:36 <tikhon> joelteon: there's a preprocessor that adds them called SHE
15:24:36 <augur> tikhon: aha, so it only goes down the spine
15:24:40 <augur> it doesnt go into args
15:24:42 <augur> thats interesting
15:24:47 <tikhon> yes
15:24:55 <tikhon> roughly, you need 1 set of brackets per "pure"
15:24:55 <augur> so you could infact do
15:25:00 <augur> (| pure 1 + pure 2 |)
15:25:11 <tikhon> yes
15:25:25 <tikhon> well, ignoring type inference, I guess :P
15:25:26 <blochchain> say I want to test if a string ends with punctuation and i use a function like "endsPunc xs = [isSuffixOf] <*> [".", "!", "?"] <*> xs"    is it considered better form to put things in brackets or use "pure"?
15:25:34 <augur> (| pure 1 + (| pure 2 + pure 3 |) |)
15:25:41 <tikhon> blochchain: use <$>
15:25:41 <joelteon> strathclyde, huh?
15:25:43 <joelteon> that's a fancy name
15:25:50 <applicat1ve> joelteon: there's no attempt to implement them in ghc i don't think.
15:25:54 <tikhon> isSuffixOf <$> [".", "!", "?"] <*> xs
15:25:59 <augur> joelteon: its a school in glasgow
15:26:10 <augur> so it aint THAT fancy
15:26:14 <augur> its more drunk and scottish
15:26:16 <tikhon> just hard to spell and pronounce
15:26:27 <augur> its neither of those things, cmon
15:26:29 <joelteon> oh i see
15:26:30 <applicat1ve> strathclyde is where the action is
15:26:54 <augur> strathclyde has conor mcbride
15:26:55 <tikhon> they actually do functional programming stuff there—that's fancy as far as I'm concerned :P
15:26:55 <augur> :D
15:27:05 <augur> not just FP
15:27:09 <augur> DTP!
15:27:09 <applicat1ve> joelteon: https://github.com/michaelt/her/blob/master/script/test.hs
15:27:17 <augur> but its all in ascii
15:27:26 <tikhon> yes, but *functional* DTP
15:27:34 <Polarina> blochchain, endsPunc xs = last xs `elem` ['.', '!', '?']
15:27:35 <applicat1ve> unlike that oodtp?
15:27:36 <joelteon> down to puck
15:27:39 <tikhon> we have some dependently typed stuff here, but it's more like dependently typed C
15:27:45 <augur> i refuse to acknowledge the existence of anything else, tikhon
15:29:20 * hackagebot postgresql-orm 0.1 - An ORM (Object Relational Mapping) and migrations DSL for PostgreSQL.  http://hackage.haskell.org/package/postgresql-orm-0.1 (AmitLevy)
15:29:58 <tomejaguar> strathclyde is where neil ghani is
15:31:21 <augur> yes
15:31:44 <monochrom> (GHC)  now that roles are in HEAD, heads will roll :)
15:32:22 <augur> btw
15:32:22 <augur> http://www.strictlypositive.org/Idiom-abort.pdf
15:32:25 <augur> thats the silly version
15:32:32 <augur> http://www.strictlypositive.org/Idiom.pdf
15:32:34 <augur> heres the long version
15:33:11 <monochrom> oh, the first idiom paper!
15:33:35 <augur> the invention of applicative functors, iinm :)
15:34:02 <monochrom> yeah
15:34:09 <ocharles> Setup: dist/doc/html/instant-generics/haddock-prolog22584.txt: invalid
15:34:12 <ocharles> any idea what that means?
15:34:45 <S_J> is there some mailbxo support for concurrency in haskell?
15:35:50 <monochrom> ocharles: if you now do "Setup clean" and build again from fresh, and you still get that error, then I don't know. (so, I'm just guessing some transient file inconsistency)
15:36:14 <ocharles> monochrom: nope, i'm installing from clean (installing via nixos)
15:36:21 <ocharles> i think it might be http://hackage.haskell.org/trac/hackage/ticket/626
15:40:11 <levi> S_J: Yes, but where to point you depends on what you mean by 'mailbox'
15:52:03 <levi> S_J: Most concurrent things are built on the MVar primitive, which is like a single-slot mailbox.
15:55:54 <S_J> whats a good property for insertlast in a doubly linked list?
15:56:38 <heatsink> O(1) execution time
15:56:48 <heatsink> I'm not actually sure what you're asking for.
15:56:54 <copumpkin> doubly linked lists are not popular in immutable land
15:58:32 <`Jake`> Can I run a process with System.Process and then after its execution see how long it took?
15:59:11 <heatsink> You can get the current time before and after running it
15:59:22 <zzing> If I have  f 0 = … and f x = …  is it possible to have a single where clause for both of them?
15:59:34 <monochrom> no
15:59:35 <`Jake`> Yeah, that's what I thought of as alternative. I was just wondering if there was a built-in way.
15:59:54 <identity> `Jake`: Sure. You can use System.Time, etc.
16:00:19 <notasi> zzing: you might want to try guards
16:00:22 <S_J> How could I hold a "pointer" to the last tiem of a doubly linked list? seems i can just get the first elem i o(1) no the last...
16:00:27 <`Jake`> ok, thanks
16:01:31 <heatsink> S_J, it is no different than holding a reference to the first item.
16:01:35 <zzing> notasi, I was going to use guards, but the thing that the guards have to worry about has to be in a where clause
16:01:35 <identity> `Jake`: It's pretty easy to write a wrapper for it. timed io = do {now <- getClockTime; io; after <- getClockTime; return $ diffClockTimes after now}
16:01:38 <identity> something like that, anyway.
16:01:52 <identity> minus the rturn
16:01:54 <identity> return*
16:01:56 <`Jake`> thanks
16:02:08 <monochrom> zzing: that one is no problem
16:03:29 <monochrom> "f x | joy = cool  | otherwise = awesome   where { joy = x>0; cool = x+1; awesome = x+2}" is totally allowed
16:06:03 <S_J> lol, i made a tree rather than a doubly linked list. how would you define a doubly linked list in haskell. data DLL item = Empty | Node item (DLL item) (DLL item). i mean i guess it works if you just make a tree with one long left branch a right branch but then you point to the middle of the list kind of. how would you do?
16:06:46 <identity> S_J: As has been pointed out, doubly-linked lists are not very popular in immutable land
16:06:48 <geekosaur> painfully
16:07:28 <geekosaur> either you "tie the knot" (see Tying_the_knot in the haskell wiki, IIRC) or you have to regenerate the whole list to add a node
16:07:52 <levi> If you wanted a static structure that you could quickly walk back and forth without making any changes to it, you could construct such a thing in Haskell, but it's not a very common thing to want.
16:08:04 <geekosaur> Data.Seq
16:08:12 <geekosaur> possibly
16:08:22 <geekosaur> also, zippers
16:08:29 <identity> yeah, was just going to say zippers
16:08:50 <levi> Well, you commonly want to move back and forth quickly, but you usually *also* want to make updates and share structure.
16:08:51 <Hrumph> hi
16:08:56 <Hrumph> i'm have a problem
16:09:04 <monochrom> the next two weeks you will be answering much questions on zippers and differentiation :)
16:09:15 <dmj`> S_J: Maybe a Deque
16:09:29 <dmj`> S_J: *Data.Dequeue
16:09:51 <Hrumph> i have defined a class QClass x. inside the class i have an internal data type (i.e. data InternalType x)
16:10:22 <Hrumph> then in an instance i try to define the type (i.e. data InternalType User = UserConstructor Int Int
16:10:32 <geekosaur> @where hpaste
16:10:32 <lambdabot> http://lpaste.net/new/haskell
16:10:33 <Hrumph> i can't seem to access UserConstructor....
16:10:58 <identity> I just glanced at Tying_the_knot on the wiki. If he looks at it, he'll just gasp at all the crazy talk and insane code being written by cale and the others and decide to use another datastructure
16:11:00 <Hrumph> what's the trick?
16:11:28 <`Jake`> Hrumph: post your code on lpaste, that'll make it easier
16:11:31 <Hrumph> ok
16:11:34 <Cale> Hah, anything on that page written by me was back when I was just learning Haskell :)
16:11:59 <identity> Cale: Yeah, go ahead. Make me feel bad.
16:12:03 <Cale> Yeah, you can tell it was taken from the old hawiki
16:12:24 <Cale> Back when the Haskell wiki was a moinmoin, because we were using CamelCase links :)
16:12:34 <WanderingMonad> levi: I'm still learning Haskell myself (and I remember enough about zippers from LYAH to think that those are probably S_J's best bet), so forgive me if I know not whereof I speak, but couldn't you also just code up a "dummy function" that ids as you walks?
16:13:01 <WanderingMonad> s/walks/walk
16:13:20 <`Jake`> I don't even remember reading about zippers in lyah
16:13:27 <`Jake`> at all
16:13:36 <geekosaur> identity, yeh, I was not encouraging use of doubly linked lists there :)
16:14:18 <identity> I like how he tried to make a doubly linked list and then was all like "Hey, I made a tree! Oops!"
16:14:19 <Cale> At the time, I just barely understood what was going on with the doubly linked list code there, which I think was written by Derek Elkins. Eventually it made me realise the interpretation of values as pointers.
16:14:24 <geekosaur> there's a very basic intro to zippers in the xmonad codebase (documentation for XMonad.StackSet) but the one-hole derivative stuff is not part of it
16:14:41 <Cale> There's a hrule or two which are missing because the page was edited, I didn't write the original example.
16:14:42 <hpaste_> Hrumph pasted “My Problem (or one of them)” at http://lpaste.net/91977
16:14:57 <WanderingMonad> `Jake`: I double-checked to make sure I wasn't imagining things, and Chapter 15 is given over entirely to zippers. :)
16:15:12 <Cale> I wrote the bad version :)
16:15:13 <Cale> hehe
16:15:27 <Cale> and then Derek showed me how to compare it to the good one
16:15:29 <`Jake`> WanderingMonad: Yeah, I just googled it too. I think I even remember some of the pictures, actually.
16:16:00 <SrPx> So when you guys will have a 2 liner quicksort that actually compares to C's quicksort in speed? :D
16:16:34 <identity> do I smell troll?
16:17:05 <Peaker> SrPx, C's quicksort is far from 2 lines
16:17:15 <Maior> dnftt...
16:17:22 <Cale> SrPx: well, there's probably a version of quicksort which is of comparable length to the C version and works in-place.
16:17:25 <Philippa> Anyone got a nice in-place array quicksort in <10 lines to show?
16:17:29 <Peaker> SrPx, With a few imperative-programming libraries, the Haskell quicksort can look much like C's
16:17:44 <Philippa> it can be considerably neater than C's for the same algo
16:17:53 <Philippa> remember: we get inlining for free
16:17:57 <Cale> If you're sorting *lists* specifically, quicksort is a particularly bad algorithm.
16:18:04 <SrPx> identity: a little trolling is healthy for a channel
16:18:11 <SrPx> Peaker: that is not what I said
16:18:18 <SrPx> Peaker: twice
16:18:24 <dmj`> SrPx: Have you checked out haskell vectors?
16:18:27 <Cale> Bottom-up mergesort is about as easy to write, and much more efficient, and has a better worst case.
16:18:36 <identity> Did you guys read the arguments from the author of protobuf explaining his move from Haskell to C++, by the way?
16:18:49 <Peaker> SrPx, Quicksort is an algorithm that requires more than  2 lines to describe in all languages I know of (assuming reasonable line breaks)
16:18:52 <SrPx> Peaker: I just when you will show a "short quicksort implenentation" that is not several times slower than C's implementation
16:19:07 <SrPx> Peaker: 1 line in LiveScript, 2 lines in haskell: quicksort [] = [] quicksort (p:xs) = quicksort (filter (< p) xs) ++ [p] ++ quicksort (filter (>= p) xs)
16:19:17 <Peaker> SrPx, that's not quicksort
16:19:31 <SrPx> Peaker: oh sure, that is not the true quicksort. that is my point
16:19:33 <identity> SrPx: Why does haskell have to have a short version of quicksort that is close to C's in performance?
16:19:39 <Peaker> SrPx, I am not sure you have a point :)
16:19:39 <levi> If you look at ghc-vis and its associated documentation, there's a doubly-linked list there that you can examine and see that it's actually making a doubly-linked list.  Pretty nifty.
16:19:41 <Cale> Peaker: sure it is :)
16:19:46 <SrPx> identity: when did I say it had to?
16:19:56 <Hrumph> can anyone help me with my problem?
16:20:00 <Peaker> Cale, quicksort is specific -- it includes the in-place swapping stuff
16:20:02 <SrPx> Peaker: I didn't make a point, I made a question
16:20:03 <Cale> It's just not in-place quicksort. It has the *idea* behind quicksort.
16:20:27 <Peaker> SrPx, sounds like what you *mean* to ask, "is there an efficient-as-C sort function in 2 lines of Haskell?" regardless of "quicksort" specifically?
16:20:28 <c_wraith> Peaker: the original definition does not have that.  It describes a pattern, not an implementation.
16:20:37 <Peaker> Cale, only part of the idea, since the swapping is its own idea
16:20:47 <Cale> In fact, I didn't *really* understand the imperative in-place version of the algorithm until I saw the Haskell version :)
16:20:48 <SrPx> Peaker: that is a valid question actually, but it was not the original question
16:21:12 <dmj`> SrPx: I can get equivalent C speeds using vectors for certain operations. http://gist.github.com/dmjio/6166076
16:21:14 <Peaker> SrPx, the original question ("quicksort in 2 lines") is silly, no language has the ("true") quicksort in 2 lines
16:21:31 <SrPx> Cale: I can't get the in-place haskell version, it seems alien. But I attribute it to my lack of familiarity with the language so no point here
16:21:33 <c_wraith> I mean, any C algorithm for sorting an immutable singly-linked list is going to be way slower than sorting an array in-place.
16:21:49 <SrPx> Peaker: so the answer is "never". And that is it.
16:21:52 <Philippa> any of you want to golf an in-place array quicksort with explicit partition and pivot-choice functions?
16:21:57 <Peaker> SrPx, yes
16:22:07 <Philippa> because I suspect it still comes out pretty short if you care to
16:22:24 <Hrumph> i can't access an instance data type definition outside of the instance code how do i work around that?
16:22:29 <Cale> Personally, I view the swapping as a purely coincidental feature of the in-place version, which is only locally relevant. Once each of the batches of swaps is done, it's as if there are two separate filtered lists.
16:22:33 <SrPx> dmj`: cool link. Fusion?
16:22:34 <identity> Philippa: Wasting time on golfing code into ugliness for the sake of some random troll would be pretty silly
16:22:50 <Philippa> identity: doesn't have to get that ugly
16:23:14 <dmj`> SrPx: yes, indeed.
16:23:20 <Philippa> and really, we ought to have one on a wiki somewhere by now because this /does/ come up, because some people have fair reason to want to work with mutable arrays in an FPL sometimes
16:23:54 <identity> Philippa: I feel like there's plenty of documentation regarding the mutable arrays/vectors etc in the libraries' documentation
16:23:55 <Philippa> not everyone uses the trollish phrasing, and you can get code that's equivalent to the C and /much/ more readable in fewer lines
16:24:15 <identity> (That is, for general use. Not necessarily for quicksort )
16:24:59 <Philippa> examples are good, especially ones that demonstrate useful idioms we can get away with that people aren't used to - eg functions being cheap in first-order contexts too
16:25:15 <Peaker> Philippa, I think C is pretty good with that kind of stuff, I'm not sure it'd be much more readable than C
16:25:59 <Philippa> Peaker: the idiomatic C version inlines your partition and pivot-choice, that along fuglifies it
16:26:17 <pxqr> why does old-locale called old-locale if there is no 'new-locale'?
16:26:36 <identity> pxqr: yeah, I wondered about that a few days ago as well.
16:26:38 <c_wraith> I *still* want a GHC pragma to inline a function's argument if it's known at compile time.  I feel like the machinery is already in place.  But things have reached the point where getting something like that probably means I need to implement it myself.  And I don't want to mess with GHC.
16:26:52 <levi> The original Quicksort: http://penguin.ewu.edu/cscd300/Topic/AdvSorting/p321-hoare.pdf
16:28:11 <geekosaur> pxqr, whoever was redoing the time code made an incorrect assumption (old-locale was only used by old-time)
16:28:55 <pxqr> geekosaur: seems so :)
16:29:10 <geekosaur> so they deprecated and renamed the old time and locale packages at the same time, without thinking about it or looking into it enough
16:29:14 <Maior> er, forgive me, I'm still flailing my way around Haskell, and I'm feeding the troll, but `Prelude> let qs (x:xs) = (qs (filter (<x) xs)) ++ [x] ++ (qs (filter (>=x) xs)) ; qs [] = []` seems pretty short and two lines...
16:29:18 <pxqr> i just thought there is new locale package.
16:29:20 <Maior> (if ugly)
16:29:46 <Maior> I keep falling back to () instead of remembering how to use $ and .
16:29:55 <Philippa> c_wraith: I'd certainly like to know the usual rules of thumb for when that'll happen. Parsec 2 did some 'fun' stuff with how it defined its functions to let the inliner+case/ctor speed things up
16:29:55 <notasi> :t (.)
16:29:56 <lambdabot> (b -> c) -> (a -> b) -> a -> c
16:30:07 <notasi> @src ($)
16:30:07 <lambdabot> f $ x = f x
16:30:08 <Philippa> ('fun' as in "I eventually worked out WTF it was written that way" :p )
16:30:22 <Maior> notasi: sure, they just don't come naturally
16:30:35 <Philippa> (otherwise legible, but it's important to remember that sooner or later GHC /does/ give functions arity)
16:30:50 <c_wraith> Philippa: well, what I'm thinking of requires exporting the code the way the {-
16:31:01 <Maior> notasi: /win 41
16:31:04 <Maior> er sorry
16:31:16 <Peaker> c_wraith, you can implement optimization passes as GHC plugins, without diving too deep into the GHC src (afaik)
16:31:18 <levi> Maior: Sure, but the 'troll' was about that version not posessing the in-place updates and randomized pivot choice of the 'true quicksort'.
16:31:20 <c_wraith> Philippa: the {-# INLINEABLE #-} pragma does..  So I don't think it's the same thing parsec 2 was doing.
16:31:27 <Maior> levi: oh. ugh.
16:31:35 <Peaker> c_wraith, though I'm not sure what you mean by "inline an argument", you mean w.r.t currying?
16:31:38 <Maior> levi: quite glad I missed that then, sorry
16:31:57 <Philippa> c_wraith: oh, don't assume parsec 2 wasn't also using pragmas
16:32:09 <c_wraith> Philippa: sure, but it predates INLINEABLE
16:32:16 <Maior> came in at the tail end and was just a bit "well, er, it's been a while, but I swear it's trivially two lines..."
16:32:31 <FreeFull> :t fmapM
16:32:32 <lambdabot>     Not in scope: `fmapM'
16:32:32 <lambdabot>     Perhaps you meant one of these:
16:32:32 <lambdabot>       `mapM' (imported from Control.Monad.Writer),
16:32:37 <FreeFull> :t fmap
16:32:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:32:40 <FreeFull> :t mapM
16:32:40 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
16:33:00 <FreeFull> @src mapM
16:33:00 <lambdabot> mapM f as = sequence (map f as)
16:33:25 <FreeFull> I guess you can't do it for arbitrary functors
16:33:54 <c_wraith> Peaker: As an example, I mean something like taking map (+1), expanding the definition with (+1) showing up everywhere, then letting the standard simplifier stuff take over.  Larger code sizes, but probably better performance.  Like all inlining.
16:34:14 <FreeFull> I wonder if it would be possible for arbitrary monads
16:34:25 <FreeFull> So something like   (a -> m b) -> n a -> m (n b)
16:34:48 <FreeFull> Probably not though
16:34:48 <glguy> ?type traverse
16:36:19 <WanderingMonad> FreeFull: @hoogle (a -> m b) -> n a -> m (n b)
16:36:53 <FreeFull> WanderingMonad: I'm thinking that's impossible, and only n (m b) would be possible
16:38:25 <FreeFull> glguy is probably right and you could make a tmapM
16:38:36 <WanderingMonad> Ah, I see what you're getting at. I was a bit confused at first -- I thought Data.Traversable traverse fit, but after a few close reads of the type signature, I realized the difference.
16:39:08 <FreeFull> WanderingMonad: Yeah, by n I meant another monad
16:39:14 <WanderingMonad> FreeFull: Feel free to ignore this newbie's blind groping about. :)
16:39:55 <SrPx> Philippa: golf is not quite it, tho
16:40:05 <SrPx> I love you guys, you are my hope for humanity
16:40:16 <SrPx> that is why I come here all the time pushing your nerves
16:40:53 <SrPx> this channel has probably some of the best programmers around
16:41:04 <SrPx> keep pushing it (:
16:42:48 <blochchain> does anyone have a link to a good guide on splitting long lines?
16:42:55 <blochchain> aka indentation and where to split
16:43:58 <Philippa> blochchain: imagine you're a poet: what would you emphasise as separate subexpressions?
16:44:00 <jophish_> applicat1ve: here?
16:44:07 <Philippa> (and while you're there: would it make sense to name them?)
16:44:19 <flebron> Is there a standard way to write a set of configuration properties?
16:44:34 <flebron> (say. data Config = Config { fileName :: String, .... })
16:44:35 <jophish_> regex-applicative seems to behave oddly when using findLongestPrefix and few
16:44:41 <adas> can someone please tell the difference betewen an applicative and a monad. They seem similar.
16:44:42 <blochchain> Philippa, i'm looking more for guidelines as to what's valid
16:44:48 <blochchain> i'm having compilation problems
16:45:26 <notasi> :t (<*>)
16:45:28 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:45:33 <notasi> :t (>>=)
16:45:34 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:45:49 <Philippa> blochchain: ah. Honestly? Quickest way to understand it is to read the Haskell Report section on the layout rule and check which grammar productions use the braces and semicolons inserted by layout
16:47:03 <identity> blochchain: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
16:47:11 <identity> follow this style guide and you will never go wrong.
16:48:09 <flebron> adas: I understand them quite differently, so I may not be the best person to ask. In the case of an applicative, you might get into a situation where you have a function f, and you have an f a, and a function g : a -> b. That's fine, you can (fmap g) :: f a -> f b. Now, what happens if you have a g :: a -> b -> c? (fmap g) :: f a -> f (b -> c). Now you've got a function inside a functor. How do you apply a function that is inside a functor? Not all
16:48:09 <flebron>  such functions are so appliable, the ones that are, we call Applicative. Applicative lets you go from f (a -> b) to f a -> f b. It lets a functor "distribute over" the Hom functor, also known as "->".
16:48:13 <elliott> (well, you might go wrong if you follow the advice about making every data type field strict by default.)
16:48:17 <danharaj> I stopped at 80 character line limits.
16:50:07 <flebron> For monads, I understand them computationally. You have a computation m a that means "A computation in the m monad, which results in a value of type a". You want to be able to chain these computations, so you have an x :: m a, and a function f :: a -> m b (i.e. the f creates its own monadic effects), so you can already do (since monads are functors, even if not in the Haskell typeclass sense) (fmap f) :: m a -> m (m b). A monad is the thing that lets
16:50:07 <flebron>  you compose those two monadic things, m (m a). So you have join :: m (m a) -> m a. You had some computation, and some other computation, and you now want to compose them into a single computation. m (m a) -> m a.
16:51:20 <flebron> So I understand monads as "define your own concept of computation, and tell how such computations can be composed". I understand applicative functors as "I want to also apply functions that are themselves in the functor, not just values".
16:53:12 <flebron> (Categorically, the reason these are called "monads" is because m (m a) -> m a is similar to a monoid operation, M x M -> M. This is made explicit by the usual saying, "a monad is a monoid (object) in the (monoidal) category of endofunctors (of Hask)".
16:53:13 <flebron> )
16:54:50 <WanderingMonad> flebron: You forgot the "What's the problem?" part. :P
16:55:06 <Philippa> flebron: so both get notions of computation. Applicatives have function application, but not necessarily higher-order. Monads get you higher-order
16:55:08 <zzing> Is there any way of making literate haskell groff compatible?
16:55:11 <FreeFull> In Haskell you usually work with bind and return rather than fmap and join
16:55:24 <FreeFull> Although it all ends up isomorphic anyway
16:55:47 <flebron> Right, I understand them as (join, id) because I got them from category theory, but they're equivalent. bind is (join id).
16:55:51 <Philippa> right, bind is just the innards of how this particular language desugars let^Wdo
16:55:52 <flebron> Err, join is bind id :)
16:56:20 <FreeFull> Actually, you need return either way
16:56:28 <Philippa> join can also be dubbed "runMonadM" :p
16:56:52 <flebron> Yeah, return is needed (I call it id, but I should call it eta).
16:57:06 <FreeFull> Philippa: runMonadMonad
16:57:27 <flebron> We need to go deeper (into the monad).
16:57:27 <zzing> It would be nice if I could have an lhs file have .code   .ncode   pair, would make it nice and groff compatible
16:57:42 <FreeFull> :t Control.Category.id
16:57:43 <lambdabot> Category cat => cat a a
16:57:55 <flebron> Oh, so while teaching a class last week, I found out the noisy way that GHCi needs code files to end in .hs to load them.
16:58:03 <Philippa> FreeFull: the M is to match an existing convention though - the version of a function that runs inside the monad. You /can/ get the string out of IO - into an outer layer of IO :p
16:58:39 <FreeFull> Philippa: M does stand for Monad though, so you just had said Monad twice
16:58:57 <FreeFull> If you want to stick to the convention you'd just do runM
16:59:11 <Philippa> nope: stands for "monadic"
16:59:21 <FreeFull> Although there is no sense to have a runM when there is no non-monadic run
16:59:44 <Philippa> but there are for many specific monads. Just not IO
16:59:53 <Philippa> (well, we pronounce that one unsafePerformIO)
17:00:06 <FreeFull> I've never said anything about IO
17:00:46 <flebron> I find it funny that Haskell lets you know at first sight that a function is evil, the most evil of them all being unsafeCoerce :: a -> b.
17:00:46 <Philippa> occasionally the one nobody defined would be id, but same difference: just about everything people use as a Monad instance in Haskell has or could trivially have one
17:02:59 <evincar> flebron: The funnier thing is interpreting it as a logical proposition. "Everything implies everything else!"
17:03:45 <Philippa> flebron: you clearly haven't considered the implications of unsafePerformIO sufficiently
17:04:05 <flebron> I know it's the same thing due to pointers and memory references :p
17:04:20 <c_wraith> unsafePerformIO is a better unsafeCoerce than unsafeCoerce is an unsafePerformIO
17:04:41 <Philippa> we get people complaining about the launchMissiles example sometimes, but they tend to forget that the people who originally came out with it both remember the cold war and know full well the amount of military funding that's gone into computing
17:04:43 <Hrumph> why is it that instances aren't exported and imported the same way as everything else?
17:04:48 <c_wraith> Any time you unsafeCoerce an IO object into running, it has a good chance of crashing. :)
17:04:57 <Hrumph> i'm trying to understand why taht language design decision makes sense
17:05:00 <geekosaur> Hrumph, instances are global, you can't pick and choose
17:05:05 <c_wraith> Hrumph: because very bad things happen when you don't make them global
17:05:25 <geekosaur> and the reason is because, if I can choose which Ord instance to use for a type, I can make a Data.Map that is completely broken
17:05:36 <geekosaur> (for example)
17:05:39 <c_wraith> You can see some of those bad things in action in cases where GHC bugs allow you to use multiple inconsistent instances.
17:05:53 <Philippa> Hrumph: the entire typeclass system is predicated on a global mapping from constraints to instances
17:06:00 <flebron> I've used unsafeCoerce once haha, it was to quickly read a double into an uarray of char :p
17:06:01 <haasn> c_wraith: can't you just unsafeCoerce IO a -> MyIO a where MyIO is defined the same way as IO; then implement unsafePerformIO in terms of MyIO?
17:06:30 <c_wraith> haasn: how does that help you actually execute the action, though?
17:06:36 <Philippa> haasn: "can't you just write a haskell interpreter?"
17:06:44 <Philippa> (rather, a haskell /IO/ interpreter)
17:06:58 <elliott> you can unsafeCoerce to run IO without crashing on GHC, at least
17:07:09 <zzing> flebron, you become a man / woman when you use unsafeCoerce ten times in a module
17:07:12 <c_wraith> haasn: on the other hand, if you unsafeCoerce IO a to () -> a, it will run - but it's liable to crash.
17:08:04 <levi> Hrumph: You can watch SPJ explain type classes to the Oregon Programming Languages Summer School now.
17:08:44 <levi> Hrumph: http://www.cs.uoregon.edu/research/summerschool/summer13/curriculum.html
17:09:35 <danharaj> what is the homotopy type theory channel?
17:09:39 <danharaj> Cale: boop ^
17:10:04 <c_wraith> Man, I need to go to one of the summer schools.  I live nearby, I *know* the guy who runs them..
17:10:18 <levi> Probably ##hott
17:11:07 <danharaj> makes sense
17:17:27 <Ghoul_> @pl (\x -> P.isSomeAllocEffect x || P.isSomeReadEffect x)
17:17:27 <lambdabot> liftM2 (||) P.isSomeAllocEffect P.isSomeReadEffect
17:18:15 <Cale> danharaj: it's ##hott
17:18:20 <danharaj> ty
17:18:39 <danharaj> I wanted to ask about how higher inductive types relate to quotient types and how far into the book I have to read to find out the answer.
17:22:03 <Peaker> c_wraith: about the inlining -- isn't that just ordinary inlining?
17:24:05 <Peaker> doh, accidental disc
17:24:26 <c_wraith> Peaker: It's a specific subcase of inlining that makes sense in cases where normal inlining does not. Specifically, it makes sense when given a huge recursive function, even one that can't have a worker/wrapper transform done usefully.
17:24:32 <zzing> Can I use guards on items in where statements?
17:24:35 <c_wraith> yes
17:24:50 <Peaker> c_wraith: why?
17:24:57 <Peaker> c_wraith: I don't see the difference from normal inlining
17:26:20 <blochchain> is there any way to do dropWhile from the end of a list without reversing it?
17:26:51 <c_wraith> Peaker: have you worked with the stencil convolution API in repa?
17:26:52 <zzing> I am having an issue with my guards: https://gist.github.com/iaefai/f9acd47e9c4fc826e525    it says conflicting definitions on all of them (line 6 to 13)
17:27:05 <Peaker> c_wraith: no
17:27:13 <SS_JJ> is it not possible to remove an element froma Data.Sequence in O(1)
17:27:17 <c_wraith> Peaker: it uses quasi-quoting to build the convolution algorithm at compile time, to avoid the overhead of tons of repeated function calls.
17:27:25 <MrRacoon> fa;sjdf;l~.
17:27:38 <flebron> Say I'm reading getArgs and finding something I don't like. What's the usual way to report an error to stderr and exitWith (ExitFailure k)?
17:27:44 <Cale> danharaj: They are like higher dimensional quotient types. You get ordinary constructors (like we have in Haskell), and then you're allowed to have constructors which create paths (equations) between terms, and then paths between paths, and so on.
17:27:45 <MrRacoon> whoops
17:28:24 <danharaj> Cale: how do you compute / pattern match with that
17:28:30 <c_wraith> Peaker: It'd be nice if you could just use a pragma to tell GHC to generate code inlining a particular argument if it's known at compile time.
17:28:33 --- mode: ChanServ set +o elliott
17:28:35 --- mode: elliott set -b lambdakind*!*@*$##fixyourconnection
17:28:36 --- mode: elliott set -o elliott
17:28:49 <joelteon> i have never seen comments in a ban mask before
17:29:02 <elliott> it's a redirect
17:29:15 <danharaj> hey, emails can have comments
17:29:34 <Peaker> c_wraith: to "inline an argument" you need to inline the whole function, don't you?  So you're talking about the predicate for inlining-or-not, rather than any different way of inlining, right?
17:30:28 <lightquake> aeson is the 'right' json library to use, right?
17:30:41 <Peaker> it's called literal banning
17:30:50 <Peaker> lightquake: probably :)
17:31:09 <Cale> danharaj: To construct a function out of such a type, you basically have to say where each of the path constructors are sent, as paths in the codomain between where the corresponding point constructors are sent. i.e. you have to prove that the endpoints of the path are equal in the codomain.
17:31:13 <c_wraith> Peaker: perhaps the best analog to this is the SPECIALIZE pragma.  Except instead of specializing on the type of something, you specialize on a value passed to a function.
17:31:24 <danharaj> Cale: ah I see.
17:31:37 <danharaj> Cale: Now how do I embed higher inductive types into haskell ;)
17:31:37 <Cale> Or, you have to *pick* a proof of that, since there can be more than one, and they may not be equivalent
17:31:52 <Cale> Uh, not easily
17:32:02 <Cale> You can barely do it usefully in Agda and Coq
17:32:11 <Cale> and even there, they're cheating
17:32:27 <Peaker> c_wraith: IIRC, specialize doesn't inline - but rather makes a copy of the function (for a particular type/instances)
17:32:34 <Peaker> c_wraith: is that what you mean for the arg too?
17:32:54 <jophish_> yo yo yo
17:33:41 <jophish_> Is there a shorter way of saying: do{a <- f; b <- g; return (h a b)}
17:33:57 <Peaker> h <$> f <*> g
17:34:14 <c_wraith> Peaker: optimally, it'd create a copy and let the simplifier decide whether to inline or not at the use site.
17:34:24 <jophish_> It's correct to map do{a<-f; return h a} as (f >>= return . h), right?
17:34:30 <geekosaur> or liftA2 h f g, or liftM2 h f g
17:34:40 <Peaker> jophish_: you mean:  return (h a), right?
17:34:47 <jophish_> ah yes
17:34:59 <jophish_> humans make the best compilers :)
17:35:05 <jophish_> Thanks Peaker, geekosaur
17:35:05 <lightquake> jophish_: yes, assuming you add those parentheses
17:35:11 <lightquake> @undo do {a <- f; return $ h a}
17:35:11 <lambdabot> f >>= \ a -> return $ h a
17:35:11 <Peaker> jophish_: then yes.  and if you run that by hlint, it will tell you that "x >>= return . f" should be replaced by "fmap f x
17:35:43 <Peaker> @pl f >>= \ a -> return $ h a
17:35:46 <lambdabot> (return $) . h =<< f
17:35:46 <lambdabot> optimization suspended, use @pl-resume to continue.
17:35:52 <flebron> So getProgName returns "foo" for a running ./foo. Is there something that returns "./foo"? That is, the full pathname to whatever I'm executing.
17:36:02 <Peaker> funny that @pl doesn't simplify ($) sections
17:36:27 <zzing> :t all
17:36:28 <lambdabot> (a -> Bool) -> [a] -> Bool
17:36:42 <zzing> :t and
17:36:43 <lambdabot> [Bool] -> Bool
17:36:53 <Peaker> @src all
17:36:53 <lambdabot> all p =  and . map p
17:39:05 <zzing> Is there @src and
17:39:08 <zzing> @src and
17:39:08 <lambdabot> and   =  foldr (&&) True
17:39:23 <zzing> Is there any better way to write this? https://gist.github.com/iaefai/f9acd47e9c4fc826e525
17:44:19 <flebron> Is readFile frowned upon, since we have Text.* instead of String?
17:45:17 <slack1256> if the file is small enough, it shouldn't matter
17:45:19 <geekosaur> zzing: does that even work? where scopes over guards
17:45:58 <adas> will GADTs become the standard in future?
17:46:40 <slack1256> adas: become parto of the haskell standard? or common feature of all compilers?
17:47:15 <geekosaur> more precisely, scopes over all definitions for a function, so it should reject the second one because it's already "closed" that definition with a where clause
17:49:28 <Cale> adas: Well, at minimum.
17:49:42 <Cale> adas: Hopefully we can reach higher than that :D
17:49:46 <zzing> geekosaur, it compiels
17:49:49 <adas> slack1256: Right now the only way to use GADTs is to specify that you want to use the GADT syntax using the LANGUAGE pragma. I was wondering if in the future, it has a strong chance of becoming a part of the haskell standard so that using a LANGUAGE pragma might not be required
17:49:58 <Cale> GADTs are already implemented in GHC, which makes them pretty much "standard"
17:50:22 <adas> Cale: you mean something more advanced than GADTs?
17:50:22 <Cale> The LANGUAGE pragmas are part of the standard now.
17:50:26 <Cale> yeah
17:51:00 <Cale> Personally, I'm hoping that higher inductive types from homotopy type theory eventually get 1) implemented properly *somewhere*, and 2) eventually make their way into a practical programming language.
17:51:12 <zzing> geekosaur, with the second one if κ is removed, then it complains it is not in scope - :. it is only defined in the first one in this case.
17:52:09 <adas> Cale: you lost me at homotopy. But i think i get the point. basically something more powerful than gadts
17:53:00 <TimUK> hey!
17:53:21 <Cale> adas: Yeah, it's basically GADTs where you can also have constructors that generate (proofs/witnesses of) equations between terms of the type, and then if you like, even equations between the proofs of equations and so on.
17:53:23 <TimUK> anyone awake? got a quick question f;)
17:53:40 <Cale> TimUK: There're 1100 people in the channel, someone's going ot be awake ;)
17:53:42 <Cale> to*
17:53:43 <zzing> TimUK, nobody here, nothing to see here
17:53:52 <TimUK> ah damn 8_(
17:53:59 <flebron> Can one have "let foo = bar\n  baz = quux" inside a do stmt?
17:54:07 <Cale> flebron: yes
17:54:08 <zzing> TimUK, you can ask if you pick the right one:    math  OR maths
17:54:09 <haasn> I'm not awake but I might still be able to answer your question
17:54:25 <Cale> flebron: Just make sure that foo and baz are properly aligned (start in the same column)
17:54:27 <haasn> zzing: ‘maths’ is clearly the right one, ‘math’ is left
17:54:35 <TimUK> ah maths!!
17:54:53 <zzing> haasn, quite nice answer
17:55:05 <apples`> Cale: where does the homotopy come in? (as someone who knows more algebraic topology than type theory)
17:55:27 <TimUK> so anyhoo! all i am trying to do is make a recurrive function that tells me how many time a number and be divided by another one.. but I can't figure it out. This is what I got so far! howMany :: Int -> Int -> Int howMany n y     | mod n y /= 0 = y     | otherwise = howMany (mod n y) y
17:56:13 <haasn> do you mean ‘div’ not ‘mod’?
17:56:26 <haasn> also you can give ‘mod n y’ a local name in order to avoid writing it twice :)
17:57:28 <haasn> oh, you'd want ‘mod’ for the first and ‘div’ for hte second I think
17:57:35 <TimUK> hmm, maybe, div. i was going to test if there was a remainder, if there wasn't then i was going to divide it again  and so on ... then return how many times this took place
17:57:40 <haasn> yeah
17:57:45 <haasn> > div 10 5
17:57:46 <lambdabot>   2
17:57:48 <haasn> > mod 10 5
17:57:49 <lambdabot>   0
17:57:52 <haasn> > divMod 10 5 -- :)
17:57:53 <lambdabot>   (2,0)
17:58:32 <haasn> and actually you don't even need to recurse in that case, since the answer is already 2...
17:58:35 * haasn is a bit confused
17:59:04 <haasn> are you trying to implement your own division function from ‘scratch’?
17:59:17 <haasn> it seems to be like the recursive approach would be based on repeated subtraction
17:59:27 <elliott> I think TimUK is implementing log (effectively).
18:01:03 <haasn> yeah that makes sense
18:01:06 <TimUK> well what i wanted to find out was given a certain number say 252, and another say 2, how many times i could keep dividing it so 252 mod 2 = 0 then 126 mod 2 = 0 then 63 mod 2 = 1 then stop
18:01:19 <haasn> then elliott is right :)
18:02:08 <haasn> except it still isn't log; logBase 2 251 ≈ logBase 2 252
18:02:15 <haasn> but howMany 251 2 = 0
18:03:22 <TimUK> am i on the right track that i would need a recursive function to work this out?
18:03:26 <arkeet> > decodeFloat 252
18:03:27 <lambdabot>   (8866461766385664,-45)
18:03:29 <arkeet> ok.
18:03:36 <haasn> TimUK: a recursive function would certainly work
18:03:50 <TimUK> cool
18:03:56 <`Jake`> It's not really a problem, but can someone tell me why runProcess will only run a process for me if the excutable is NOT in the current directory?
18:04:38 <arkeet> `Jake`: are you sure it's just not a "current directory isn't in $PATH" thing?
18:04:52 <arkeet> not just
18:04:59 <haasn> > lengthOf (takingWhile not bits) 252
18:05:01 <lambdabot>   2
18:05:02 <haasn> > lengthOf (takingWhile not bits) 251
18:05:04 <lambdabot>   0
18:05:10 <haasn> hooray
18:05:11 <arkeet> nice
18:05:30 <zzing> "on Unix systems the execvp semantics is used, where if the filename does not contain a slash (/) then the PATH environment variable is searched for the executable."
18:05:37 <`Jake`> Ah, thanks
18:06:13 <gnuvince> :t takingWhile
18:06:25 <arkeet> gnuvince: it's from lens
18:06:31 <gnuvince> arkeet: thanks
18:07:00 <elliott> `Jake`: do ./foo
18:07:01 <elliott> instead of foo
18:07:08 <TimUK> thanks for your help all night!
18:08:05 <`Jake`> Yeah, that works, thanks. It still confuses me that it dodn't work with ~/{..}/foo, though
18:08:13 <elliott> because ~ is shell syntax
18:08:15 <elliott> need to say /home/foo
18:08:33 <`Jake`> oh
18:08:34 <`Jake`> ok
18:08:36 <haasn> edwardk: we need digits :: (Num n, Integral n) => n -> IndexedTraversal' Int n n -- or whatever
18:08:42 <haasn> edwardk: such that digits 2 = bits
18:08:44 <haasn> (effectively)
18:08:45 <edwardk> haasn: yes, we do
18:08:48 <edwardk> haasn: patch!
18:08:56 <edwardk> its a little trickier though
18:09:03 <edwardk> you also need something like maxBound
18:09:16 <edwardk> so you can detect when the digit rolls over
18:09:25 <edwardk> > maxBound / 3 :: Int
18:09:26 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
18:09:26 <lambdabot>    arising from a use o...
18:09:30 <edwardk> > maxBound `div` 3 :: Int
18:09:31 <lambdabot>   715827882
18:09:43 <haasn> not sure I understand
18:10:06 <arkeet> > 251 ^. base 2
18:10:07 <lambdabot>   Could not deduce (GHC.Num.Num GHC.Base.String)
18:10:07 <lambdabot>    arising from the literal ...
18:10:08 <edwardk> > logBase 3 (fromIntegral (maxBound :: Int))
18:10:09 <lambdabot>   19.558822360291316
18:10:14 <haasn> > base 2 # 251
18:10:16 <lambdabot>   "11111011"
18:10:18 <arkeet> yeah.
18:10:19 <elliott> haasn: isn't that effectively base?
18:10:30 <arkeet> except base does a string.
18:10:33 <elliott> sure.
18:10:38 <edwardk> if you went more than 19 trits in then you'd start overwriting
18:10:39 <arkeet> and strings are awful.
18:10:40 <elliott> base should be built on top of it, I guess.
18:10:44 <haasn> elliott: yeah you could probably use that codebase
18:10:47 <haasn> with modifications
18:10:51 <edwardk> bits isn't sufficient
18:11:06 <edwardk> you need to start at the lsb and run until you run out of ability to specify in the number size
18:11:08 <arkeet> and make it also handle balanced ternary.
18:11:09 <edwardk> or it isn't a traversal
18:11:31 <haasn> edwardk: how does Bits do it?
18:11:35 <edwardk> :t bits
18:11:43 <arkeet> :t elliott
18:11:43 <lambdabot> Not in scope: `elliott'
18:11:50 <edwardk> :t Data.Bits.Lens.bits
18:11:51 <lambdabot> (Num b, Applicative f, Indexable Int p, Bits b) => p Bool (f Bool) -> b -> f b
18:11:56 <haasn> edwardk: via, ‘hasBit’ it seems
18:12:01 <elliott> no clue what's going on there
18:12:01 <elliott> > bits
18:12:03 <lambdabot>   No instance for (Control.Lens.Internal.Indexed.Indexable
18:12:03 <lambdabot>                   ...
18:12:15 <arkeet> > const () bits
18:12:16 <lambdabot>   No instance for (Control.Lens.Internal.Indexed.Indexable
18:12:16 <lambdabot>                   ...
18:12:20 <edwardk> it uses the Bits instance to toggle and checks for when it stops changing the value
18:12:30 <haasn> ew
18:12:40 <haasn> well, Bounded would certainly be a reasonable compromise imo
18:12:51 <edwardk> that turns out to be safer than dealing with actually using the # of bits reported by Bits, because that just crashes you
18:12:53 <elliott> bits should work on Integer.
18:12:56 <arkeet> I want my ^
18:12:58 <edwardk> whereas my way i can get the fold to work on Integer
18:13:05 <elliott> as a traversal.
18:13:12 <elliott> then I'd start believing in infinite traversals
18:13:13 <edwardk> elliott: i wish you luck reassembling an infinite number of steps
18:13:26 <edwardk> elliott: the issue is integer is strict
18:13:40 <elliott> we should be able to magically tell whether it ends in all 0s or all 1s or something!
18:13:51 <haasn> > (10^100 :: Integer) ^.. taking 10 bits
18:13:52 <lambdabot>   [False,False,False,False,False,False,False,False,False,False]
18:13:53 <elliott> hmm, what's ...0101010101?
18:13:57 <elliott> I should know my p-adics better, I guess.
18:14:12 <edwardk> elliott: http://fsl.cs.uiuc.edu/pubs/rosu-2006-icfp.pdf
18:14:25 <edwardk> elliott: that show you can't ;)
18:14:28 <edwardk> er shows
18:14:41 <elliott> obviously it's impossible. I still want it.
18:15:06 <haasn> we just need to port lens to the Haskell + stream oracle environment
18:16:04 <elliott> someone should make a lazy Integer.
18:16:05 <danharaj> edwardk: I wonder what happens if you bound the entropy of a stream.
18:16:09 <danharaj> for deciding equality.
18:16:43 <danharaj> perhaps logarithmically
18:17:23 * edwardk is annoyed. the optimal bounds for unioning k streams uses a b-tree. b-tree + morton order is dangerous patent territory
18:17:27 <danharaj> nevermind silly question
18:17:51 <elliott> yay, patents
18:17:53 <danharaj> edwardk: argue that haskell code is a mathematical equation ;)
18:18:12 <edwardk> so now i need to go back and rederive a version of demaine's optimal merges that _doesn't_ use a b-tree =(
18:18:38 <danharaj> don't lie, you are thrilled by the puzzle
18:19:16 <edwardk> http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.36.9963&rep=rep1&type=pdf is the paper
18:19:26 <edwardk> no, mostly because i'm kinda sick of b-tree alternatives =P
18:19:46 <edwardk> i spent 3 months on it earlier this year and then burned out and stopped coding for a month to recover
18:19:52 <danharaj> wow
18:20:24 <edwardk> in case you wondered why my productivity dipped so hard
18:20:57 <edwardk> dealing with the patent mine-field around analytics was annoyingly stressful
18:21:19 <elliott> you should just buy up the owners of the patents for your evil empire.
18:21:58 <edwardk> assassins may be cheaper. it is an _evil_ empire.
18:22:21 <edwardk> otoh i suppose it is more evil to feed the patent trolls
18:22:33 <tabemann> deathbots
18:22:52 <edwardk> tabemann: i have acowley working on those.
18:23:33 <edwardk> they can fly in formation, grab things in passing, and swoop through the air with claws, but the machine guns so far have been a bust.
18:24:05 <tabemann> air-to-surface missiles might be kind of expensive and/or involving heavy time investment
18:24:39 <monochrom> guess what? that sounds like another patent mine-field :)
18:24:48 <Philippa> edwardk: if they can grab necks you're sorted, no?
18:25:08 <edwardk> monochrom: mine-fields! that's it!
18:25:26 <edwardk> put the patents in the middle of the mine field, hunger games style.
18:25:44 <tabemann> I doubt there are many current patents on antipersonnel mines, and antipersonnel mines are cheap
18:25:50 <monochrom> um, patents don't move by themselves. they feel pretty safe.
18:25:52 <Philippa> edwardk: then tell the winner they don't get shit: the minefield has prior art in the form of scattering bear traps
18:25:53 <elliott> edwardk: maybe you should just become rich enough to overthrow the US government and reassign all patents to yourself
18:26:44 <Philippa> elliott: I don't want to live in a world 12 hours after the US was unanimously declared a rogue state by all other nations, just sayin'...
18:26:45 <geekosaur> caltrops?
18:27:01 <edwardk> elliott: my efforts to get rich have been… a bumpy ride
18:28:08 <elliott> Philippa: that's easy. edwardk just has to take over everywhere else too.
18:28:12 <elliott> think big.
18:28:26 <startling> someone should write a Bits instance for [()]
18:28:35 <Hrumph> bill gates just submitted a bs patent application http://appft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=1&f=G&l=50&s1=%2220130188887%22.PGNR.&OS=DN/20130188887&RS=DN/20130188887
18:28:54 <edwardk> Hrumph: has does a lot of them through intellectual ventures
18:29:00 <edwardk> er he does
18:29:21 <Hrumph> i'm 100% against software patents but if the patents are like the ones here the situation is evern worse than i imagined
18:29:37 <danharaj> Why is that patent bullshit
18:29:40 <Hrumph> its just a wishlist of features with nothing in the way of proven implementation
18:30:19 <Hrumph> what i said
18:30:20 <AfC> The situation is worse than you imagined
18:32:07 * geekosaur looks at favicon for site with just a touch of irony
18:32:17 <geekosaur> (and a bit more sadness)
18:35:03 <haasn> patents? what are those? *continues coding*
18:35:25 <startling> they're a little bit like pants.
18:39:05 <jophish_> Is it possible to write this a little more neatly: f >>= ((a>>b) >>) . return
18:39:35 <applicat1ve> @unpl f >>= ((a>>b) >>) . return
18:39:35 <lambdabot> (f >>= \ g -> (a >> b) >> (return g))
18:39:41 <FreeFull> :t \f a b -> f >>= ((a>>b)>>) . return
18:39:42 <lambdabot> Monad m => m b -> m a1 -> m a -> m b
18:40:22 <applicat1ve> let konst a b c = a in liftM3 konst
18:40:23 <applicat1ve> boo
18:40:36 <Peaker> jophish_: f >>= <X> . return   -->   fmap <X> f
18:40:47 <lpsmith> ಠ_ಠ https://github.com/lpsmith/postgresql-simple/commit/1a390f5e1129edae493605a4101098eb844a58a7
18:40:55 <applicat1ve> :t \x y z -> x <* y <* z
18:40:56 <lambdabot> Applicative f => f a -> f b1 -> f b -> f a
18:40:56 <Peaker> jophish_: and (<$>)=fmap; so:   ((a>>b) >>) <$> f
18:41:11 <lpsmith> So why does constant folding tend not to work in GHC?
18:41:42 <ski> `((a >> b) >>)' is `(a >> b >>)'
18:41:54 <edwardk> @tell fryguybob it roundtripped through something that ate my ''s
18:41:55 <lambdabot> Consider it noted.
18:42:15 <FreeFull> ski: (a >> b >>) isn't valid syntax afaik
18:42:23 <ski> @type \a b -> ((a >> b) >>)
18:42:23 <lambdabot> Monad m => m a1 -> m a -> m b -> m b
18:42:31 <FreeFull> :t (a >> b >>)
18:42:32 <lambdabot>     Couldn't match expected type `m0 a1' with actual type `Expr'
18:42:32 <lambdabot>     In the first argument of `(>>)', namely `a'
18:42:32 <lambdabot>     In the first argument of `(>>)', namely `a >> b'
18:42:35 <applicat1ve> i think ski was making a mathematical statement
18:42:40 <ski> nope
18:42:42 <FreeFull> :t \a b -> (a >> b >>)
18:42:42 <lambdabot> Monad m => m a1 -> m a -> m b -> m b
18:42:51 <FreeFull> Huh, it is valid syntax
18:43:01 <ski> it works here because `>>' is left-associative
18:43:01 <FreeFull> I guess it's fine because it's the same operator
18:43:21 <jophish_> Thanks! This may just make the code a little harder to grok though. This is for parsec. The actual code I'm dealing with is: do{ a; s <- f; b; c; d; return s}
18:43:21 <applicat1ve> jophish_: if x <* y <* z is what you mean, that's a pretty  standard kind of thing to write, esp with parsers
18:43:21 <Peaker> FreeFull: I think it isn't for missing-right-arg sections with infixr's, but (>>) is infixl
18:43:24 <fryguybob> edwardk: Omm'nomm''
18:43:24 <ski> and `(^ b ^ c)' would work since `^' is right-associative
18:44:00 <Peaker> :t ([] ++ [] ++)
18:44:00 <lambdabot>     The operator `++' [infixr 5] of a section
18:44:00 <lambdabot>         must have lower precedence than that of the operand,
18:44:00 <lambdabot>           namely `++' [infixr 5]
18:44:06 <Peaker> :t (++ [] ++ [])
18:44:07 <lambdabot> [a] -> [a]
18:44:12 <edwardk> fryguybob: i think i fixed it
18:44:24 <applicat1ve> a *> f <* b <* c <* d
18:44:29 <edwardk> fryguybob: good catch
18:44:44 <FreeFull> jophish_: I don't think you can write it much cleaner than that
18:45:14 <ski> .. though imho, `(a ^ b ^)' ought to expand to `\x -> a ^ b ^ x' (or maybe to `(a ^) . (b ^)')
18:45:30 <fryguybob> edwardk: I was reading the code and the shadowing didn't seem right.
18:45:37 <edwardk> fryguybob: yeah
18:46:02 <edwardk> fryguybob: it went from a pdf to slides to text to the markdown to the page and lost a bit in translation ;)
18:46:36 <ski> FreeFull : not since it's the same operator, but since `(a >> b >> x)' would be parsed as `((a >> b) >> x)' with `x' being the right argument of the top operator -- that's why `(a >> b >>)' works
18:47:10 <jophish_> applicat1ve: <* is just for applicative, right?
18:47:13 <ski> (iow, `(a >> b >>)' is simply parsed as `((a >> b) >>)', nothing mysterious about it)
18:47:16 <fryguybob> edwardk: Humm, it is still different from the paper.
18:47:29 <edwardk> fryguybob: where?
18:48:18 <edwardk> oh e''
18:48:18 <fryguybob> should be: | v `elem` fvs = Lam v' (sub e'')
18:48:28 <elliott> why on earth is (>>) left-associative anyway?
18:48:34 <fryguybob> and:  e'' = subst v (Var v') e'
18:49:04 <LordBrain> by >> we just mean the standard monadic sequencing operator, right?
18:49:32 <ski> elliott : `>>=' is as well
18:49:49 <LordBrain> as in:   do { a; b}    <===>  a>>b
18:49:49 <ski> (though you usually don't notice that)
18:49:51 <edwardk> ok updated again =)
18:50:03 <ski> @undo do { a; b }
18:50:03 <lambdabot> a >> b
18:50:15 <ski> LordBrain : yep
18:50:27 <FreeFull> @do a >> b
18:50:27 <lambdabot> do { a; b}
18:50:44 <jophish_> Thanks all.
18:50:45 <LordBrain> left associativity makes sense to me, but maybe i haven't thought it all out... what's the argument for right-associativity?
18:50:52 <jophish_> what a great channel
18:51:10 <LordBrain> to make it more like . ?
18:51:30 <edwardk> infixl 1 >>=, >>
18:51:36 <edwardk> LordBrain: that
18:51:40 <edwardk> you want to be able to mix them
18:51:42 <ski> @quote or.undo
18:51:42 <lambdabot> monochrom says: "do, or undo. there is no redo." :)
18:51:53 <elliott> LordBrain: do notation right-associates
18:52:00 <elliott> and it's usually more efficient.
18:52:21 <startling> "more efficient"? why?
18:52:21 <ski> LordBrain : the argument for right-associativity is probably the same as for `++'
18:52:22 <LordBrain> oh in that case, it does seem strange that >> would be left associative
18:52:58 <ski> edwardk : hm, that might be it
18:53:15 <LordBrain> i always thoguht >> and >>= would associate the same
18:53:51 <edwardk> LordBrain: oh you wanted arguments _for_ right associativity
18:53:59 <elliott> I think they should both be infixr
18:54:10 <elliott> (>>=) is "infixr in practice"
18:54:13 <edwardk> yeah
18:54:36 <haasn> I wonder which monads would benefit more from left vs. right associative (>>)
18:54:43 <ski> well, `ma >>= amb >>= bmc' parsing as `(ma >>= amb) >>= bmc' is sorta reasonable
18:55:11 <elliott> ski: well, ok, but how much does that actually come up?
18:55:12 <edwardk> haasn: right associative is always a win for a free monad
18:55:15 <elliott> and can't you use (>=>)?
18:55:18 <jmcarthur> i think it makes sense for >> to be left associative, the same as the applicative combinators
18:55:19 <applicat1ve> jophish_: oh, i didn't see what you said; *> are 'applicative combinators' but parsec and co all have applicative instances
18:55:22 <haasn> edwardk: is this what codensity does?
18:55:30 <haasn> right-associates binds, that is
18:55:31 <LordBrain> @undo do { x<-a; b x; c}
18:55:31 <lambdabot> a >>= \ x -> b x >> c
18:55:33 <edwardk> haasn: hence why codensity free is good
18:55:39 <ski> elliott : yes, `bmc =<< amb =<< ma' would possibly be more common here
18:55:56 <edwardk> it is too big, but it is good ;)
18:56:15 <monochrom> if you use IO, you want a>>(b>>c), since you want the effects of a to happen before the computer even cares about b>>c
18:56:26 <ski> hm, reverse state ?
18:56:54 <LordBrain> i dont think that situation is so uncommon ski
18:57:03 <monochrom> if you use Control.Monad.State.Lazy, you want (a>>b)>>c, since the effect of c may be all you need.
18:57:30 <hpaste_> jophish pasted “Why not?” at http://lpaste.net/91978
18:58:15 <LordBrain> a>>(b>>c) Doesn't that read compute b>>c then a?
18:58:37 <jophish_> I presume that this is wrong somehow, it seems like a pretty nice thing to have, <* at least
18:58:38 <monochrom> usually no
18:58:54 <ski> jophish_ : i've called `(<*)', `before'
18:59:01 <LordBrain> if you want the effects of a to happen before c, you would want left associative (a >> b) >> c
18:59:32 <monochrom> do you know IO?
18:59:38 <LordBrain> maybe not hah
18:59:51 <monochrom> putStrLn "hello" >> undefined   -- what will this do?
19:00:12 <jophish_> ski: why not (<*), just because of clashes?
19:00:32 <monochrom> it is very important. because it decides what happens to main = putStrLn "hello" >> main
19:00:49 <ski> LordBrain : usually `a >> (b >> c)' (meaning `a >>= \_ -> b >>= \_ -> c') would mean roughly : first analyze `a' and "execute" it (ignoring the monadic result), then consider the `b >> c' part by first analyzing `a' and executing it, then finally `c'
19:00:53 <LordBrain> well the latter will repeat hello indefinitely
19:00:59 <ski> jophish_ : dunno
19:01:11 <LordBrain> the former i admit i am vague
19:01:18 <ski> jophish_ : perhaps it's not too bad with something like `(<*)'
19:01:25 <jophish_> perhaps (<<) would be better
19:01:59 <monochrom> good. now suppose we use your method, "in x>>y, compute y first". therefore, in putStrLn "hello" >> main, compute main first, don't print hello yet. what will happen?
19:02:00 <LordBrain> i'd expect the former to throw an exceptoin
19:02:17 <LordBrain> that's  the opposite of my method
19:02:22 <LordBrain> that was your method
19:02:43 <monochrom> no, not my method
19:02:57 <LordBrain> i said left associate, and i assumed the inner most parenthesis would be computed first.
19:03:05 <LordBrain> that's the left most thing
19:03:21 <LordBrain> where did i go wrong?
19:03:24 <ski> LordBrain : the ordering of the effects is actually not directly connected to the associativity
19:03:35 <monochrom> ok, 0*(49483045+2039483), do you compute (49483045+2039483) first?
19:03:47 <applicat1ve> of course
19:03:50 <ski> LordBrain : "inner most parenthesis would be computed first" doesn't hold
19:04:13 <LordBrain> ok ski, but is it then just the opposite?
19:04:19 <monochrom> operator precedences and parentheses are only for parsing, not for computing order
19:04:20 <applicat1ve> i dont have to compute 0, it's already computed
19:04:22 <ski> in some cases it may hold, but generally, it doesn't
19:04:34 <LordBrain> maybe it depends on whether the parameters are lazy or strict
19:04:52 <monochrom> highschool says "computing order" because they think you are not ready for the parsing story
19:05:03 <monochrom> so they simply and merge parsing and computing
19:05:30 <haasn> (you get taught operator precedence in highschool?)
19:05:34 <monochrom> but in Haskell you know better.  x : (y : z)  does not compute y:z first
19:06:00 <LordBrain> well, that operator is lazy in its second argument
19:06:02 <ski> LordBrain : conceptually, computation start by considering the "top" of the expression -- if that's a function that's *strict* in its arguments, then evaluation will actually "first" start by evaluating the arguments before reducing the function call (conceptually, the function is called first, then the arguments forced, and finally the function body resumes execution)
19:06:11 <haasn> monochrom: doesn't that depend on the implementation, as long as it doesn't change nonstrictness?
19:06:15 <monochrom> joy = "hello" ++ ("there" ++ joy)  you don't compute ("there" ++ joy) first
19:06:37 <monochrom> well, I guess SML does
19:06:54 <ski> LordBrain : so the effect of a strict function is what appears to be "arguments first" -- but this doesn't hold for non-strict functions
19:07:50 <LordBrain> yes, and a non-strict function will break that false rule i employed... the idea of parentheticals first, but a strict one wouldnt.
19:07:56 <ski> > take 1 (0 : error "no more")
19:07:57 <lambdabot>   [0]
19:08:21 <monochrom> IO's >> is non-strict in the second argument
19:08:36 <ski> monochrom : well, we have to be careful here ..
19:08:39 <LordBrain> i guess i know it in practice, because i dont have problems thinking main = putStrLn "hello >> main will never print anything...
19:09:28 * hackagebot postgresql-simple 0.3.6.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.6.0 (LeonSmith)
19:09:29 <monochrom> ski, non-strict as in: main = putStrLn "hello" >> main  is not flat-out bottom. I am very careful.
19:10:47 <ski> monochrom : hm, i retract; you are correct
19:11:13 <elliott> (return () >>) is strict, no?
19:11:29 <monochrom> for Control.Monad.State.Lazy, you want (a >> b) >> c, because the situation is reversed. you prefer undefined>>c to do something useful
19:11:30 <ski> yep
19:11:38 <monochrom> http://lpaste.net/41790/
19:11:46 <monochrom> gen = gen >> modify (() :)
19:12:10 <FreeFull> ski: take 1 (0 : error "no more")   wouldn't be enough to tell a fully strict take apart from a take which returns a fully-lazy list
19:12:24 <ski> elliott : i think saying that an operator `<+>' is strict in the right argument would typically mean that `(x <+>)' is strict, for all `x'
19:13:34 <FreeFull> ski: take 1 $ take 2 (0 : error "no more")   would be enough though
19:14:42 <LordBrain> ski, but as monochrom just stated, >> is non-strict in its second argument
19:14:58 <monochrom> that is not exactly what I said. you have omissions
19:15:12 <LordBrain> you said for IO
19:15:13 <monochrom> IO's >> is non-strict in its second argument
19:15:17 <ski> (i was thinking about the rough sense in which "`(>>)' is strict in right-argument, which is also in tail-position")
19:15:24 <elliott> ski: fair
19:15:36 <monochrom> Control.Monad.State.Lazy is non-strict in its first argument, strict in its second
19:16:14 <ski> (which i think is really about properties of a side-effectful language, which translates into `do' notation for the `IO'-monad in Haskell)
19:16:14 <monochrom> err, Control.Monad.State.Lazy's >> is non-strict in its first argument, strict in its second
19:16:17 <LordBrain> i didn't even know we had that much freedom
19:16:51 <LordBrain> i mean in having different semantics for different instances of monad
19:20:25 <LordBrain> i should have realized
19:20:55 <LordBrain> after all its really the defniition that determins strictness, not the type signature, despite the bang sugar
19:21:18 <ski> yeah, the bang doesn't occur in the type signature
19:21:33 <LordBrain> that too
19:22:04 <LordBrain> but even if you didnt use bang, and used variations of seq.., it wouldn't necessarily occur in the pattern
19:22:55 <LordBrain> i've been looking at a lot of different languages lately, i guess i am turning myself into a jack of all trades expert of none...
19:23:33 <zomg> LordBrain: not a bad thing necessarily
19:34:17 <Ghoul_> is there a way to get the execution directory, as opposed to the current working directory?
19:34:50 <LordBrain> a platform independent way, or just a way for such and such platform?
19:35:06 <Ghoul_> a platform independant way
19:35:24 <Ghoul_> im modding a build system to work on windows, and it looks for bin/program but on unix and windows that has a different result
19:35:44 <Maxdamantus> Windows has something like %path%
19:35:51 <Ghoul_> I /think/ this is because windows executes the thing looking for bin/program from inside bin, whereas unix treats it from where the makefile is located maybe?
19:36:28 <Maxdamantus> er, nvm .. irrelevant.
19:36:37 <Ghoul_> well, I'd prefer to do it platform independently through the haskell part of the build system, if such a thing exists
19:37:37 * geekosaur wonders if windows does a path search on bin/program (unix doesn't, the slash is taken to mean look only in .)
19:38:19 <Ghoul_> program is in long/path/to/repo/bin
19:38:20 <LordBrain> does System.Environment.getExecutablePath meet your needs?
19:38:21 <Ghoul_> not unix bin
19:38:30 <Ghoul_> it might, thanks, let me take a look
19:38:42 <geekosaur> yes, that's not my point, my point is that if it contains slashes it's not going to do a path search on unix
19:39:01 <geekosaur> but on some other OSes it does; I just don't know if windows is one of them
19:40:00 <Maxdamantus> What do you mean by "long/path/to/repo"?
19:40:05 <Maxdamantus> Is it meant to be absolute?
19:40:17 <Maxdamantus> (probably with a slash at the beginning)
19:40:20 <geekosaur> also to consider: unixy make has the concept of a vpath which will be checked for some things
19:40:27 <Ghoul_> nope. I think I have a solution, so we'll see..
19:40:43 <LordBrain> getExecutablePath wasn't what you are looking for?
19:41:12 <geekosaur> (not just executables; it was an early version of separating the build dir from the source dir, and not a very reliable one)
19:41:22 <Ghoul_> it is, but I ran into another problem - i have to detect the platform and automatically append .exe now
19:41:29 <Ghoul_> (which I know how to do)
19:41:53 <LordBrain> actually you can use getProgName, it will have the exe on there or not
19:42:24 <LordBrain> well, i havent tested, but i expect it would
19:44:54 <Makoryu> Where might I turn for information about representing and manipulating logical inference rules?
19:46:01 <zzing> Makoryu, natural deduction?
19:47:14 <Makoryu> I guess
19:52:49 <Ghoul_> Damnit buildbox guys, damnit!
19:52:57 <Ghoul_> It wasn't even my fault
19:53:18 <Ghoul_> the package BuildBox has a "mkdir -p" deep within its source which stops it from working on windows :(
19:57:30 <tabemann> that reminds me of the product at my company I was recently working on which was apparently portable between Windows and Linux, being based on a Linux-only product and being written in Java, but it happens to have executing cmd.exe buried in it
19:57:40 <Ghoul_> lol
19:57:56 <Ghoul_> well I've replaced their stuff with createDirectoryIfMissing, but now I have to go whine to the guy who made the package
19:58:20 <tabemann> even if they were really only meaning for this version of it run on Windows, just the fact that they were calling cmd.exe sounds like bad code to me
20:01:03 <tabemann> (we only discovered this when we tried to run it under Linux, as our JProbe license server went kaputt and the only working JProbe license we had was on a Linux box...)
20:06:32 <zzing> tabemann, we need to port the glory of cmd.exe to linux
20:06:45 <geekosaur> someone probably has already...
20:07:02 <LordBrain> freedos...
20:07:28 <LordBrain> there were a variety of options last i checked for getting cmd.exe on linux
20:07:53 <jophish_> Is there a function f x = [x] in the prelude?
20:08:01 <jophish_> I couldn't see one on hoogle
20:08:29 <zzing> jophish_ looks like a list instance of fmap :P
20:08:33 <tabemann> @hoogle a -> [a]
20:08:33 <lambdabot> Prelude repeat :: a -> [a]
20:08:33 <lambdabot> Data.List repeat :: a -> [a]
20:08:33 <lambdabot> Test.QuickCheck.Arbitrary shrinkNothing :: a -> [a]
20:08:59 <TTimo> good evening (where applicable) .. anyone has some good tutorials/articles/howtos on using haskell within a larger C++ codebase?
20:09:01 <LordBrain> if you want a singleton, you could just do (:[])
20:09:25 <tabemann> unfortunately we couldn't probably do this with this Linux box, as it was a special Linux box set up with all kinds of GE stuff on it...
20:09:52 <jophish_> zzing: could you elaborate a little on that, please?
20:10:05 <jophish_> LordBrain: ah, it looks like a face too, brilliant
20:10:29 <zzing> jophish_, fmap is a typeclass, probably odn't want to go into it yet
20:10:41 * geekosaur wonders if that quote's still in lb
20:10:44 <geekosaur> @quote :[]
20:10:44 <lambdabot> Plugin `quote' failed with: user error (parseRegex for Text.Regex.TDFA.String failed:":[]" (line 1, column 4):
20:10:44 <lambdabot> unexpected end of input
20:10:44 <lambdabot> expecting Failed to parse bracketed string or "]")
20:10:52 <geekosaur> oops
20:10:57 <geekosaur> and wrong anyway
20:10:58 <LordBrain> jophish_, assuming the compiler can infer that a list is expected, you could use return
20:11:03 <geekosaur> @quote :\[.*\]
20:11:03 <lambdabot> psykotic says: (:[]) is the happy monkey operator
20:11:13 <zzing> pure ftw
20:11:21 <geekosaur> @quote :\[.*\]
20:11:27 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
20:11:33 <geekosaur> that one
20:11:55 <zzing> That is amazing
20:11:56 <maxiepoo> :t return
20:11:57 <lambdabot> Monad m => a -> m a
20:12:06 <zzing> :t pure
20:12:06 <maxiepoo> :t return :: a -> [a]
20:12:07 <lambdabot> Applicative f => a -> f a
20:12:07 <lambdabot> a -> [a]
20:12:47 <zzing> maxiepoo, did you expect something different from the type you gave it?
20:12:57 <maxiepoo> nope :)
20:13:14 <geekosaur> zzing, that's a common way to verify what you're thinking wither you get the same type out or you get a type error
20:13:19 <jophish_> Ah, I see
20:13:31 <jophish_> for example map (+1) (pure 1)
20:13:35 <geekosaur> er. s/ wither/; either/
20:13:36 <zzing> Now I have to implement a deduction operator from subjective logic, this is not going to be fun
20:14:03 <jophish_> Thanks again people
20:14:52 <zzing> I have nine different cases of conditionals that determine what the value of K is, is there a nice syntax other than a lot of if/else I can use?
20:15:12 <johnw> zzing: show the code you have now?
20:15:31 <zzing> johnw, there is no code yet for this operator
20:15:37 <ParahSail1n> zzing, use the guards
20:15:51 <zzing> This is inside of a function, and I found that where does n't like guards
20:16:35 <ParahSail1n> case () of _ | bla -> hodor ... | bla2 -> derp
20:16:46 <LordBrain> aah hodor
20:17:05 <zzing> http://folk.uio.no/josang/papers/JPD2005-ECSQARU.pdf   page 5/6 where it says case I, II.A.1, …  is the definition
20:17:11 <startling> is a haskell compiler allowed to make "undefined" and friends not terminate rather than handing you a nice error?
20:17:34 <ParahSail1n> what would it do instead
20:17:36 <LordBrain> good q
20:17:40 <johnw> startling: isn't non-termination one of the meanings of undefined?
20:17:46 <johnw> undefined = let x = x in x
20:17:51 <LordBrain> he means in terms of the standard
20:18:03 <johnw> i would think Haskell doesn't address that question
20:18:16 <johnw> it sounds purely operational to me
20:18:18 <LordBrain> are you writing a haskell compiler?
20:18:32 <startling> johnw, I mean the literal value "undefined", not anything else you might say is equivalent.
20:18:38 <startling> LordBrain: no. just idly wondering.
20:18:40 <startling> > undefined
20:18:41 <lambdabot>   *Exception: Prelude.undefined
20:18:51 <ski>   undefined | False = undefined  -- used in Hugs, iirc
20:19:16 <ski> startling : perhaps look up the "imprecise exceptions" paper
20:19:57 <zzing> Is there any symbol that can be apart of an identifier that can mean 'not'?    I am trying to say  x, y given x, y given not x. The first two I can say x, and yx. What can I call y given not x?
20:20:49 <startling> zzing: "not x" could be "x -> Void", depending on your semantics.
20:21:01 <zzing> startling, this is purely in an identifier
20:21:04 <startling> oh.
20:21:46 <ParahSail1n> zzing, not sure what you want
20:21:48 <LordBrain> you mean as a convention?
20:21:57 <zzing> quite
20:22:04 <LordBrain> i dont think there is an existing convention
20:22:17 <LordBrain> you could use ' i guess
20:22:26 <zzing> That is perfect actually
20:22:30 <ski> zzing : `x',`x_y',`nx_y' perhaps ?
20:22:49 <tabemann> LordBrain: but that is contrary to the typical use of ' so far
20:23:00 <zzing> an _ would be a good second choice
20:23:03 <tabemann> in all identifiers I've seen so far, they just prefix them with "not"
20:23:16 * ski idly wonders whether zzing is hand-djinning
20:23:19 <zzing> tabemann, the benefit is that ' also means not in some boolean logic representations
20:23:20 <tabemann> _ has the problem, though, that it has its own general meaning already
20:23:22 <LordBrain> i you cant use ' as the first character of the identifier
20:23:23 <zzing> ski_?
20:23:38 <LordBrain> but i guess you could consider y' to be not y
20:23:46 <ski> @djinn (x -> y) -> (x -> Not y) -> Not x
20:23:46 <lambdabot> f a b c = b c (a c)
20:23:47 <zzing> In this specific case
20:23:54 <LordBrain> it does conflict with the strict convention, where y' is the strict version of y
20:24:05 <tabemann> _ means a function which takes a function and which eats some value returned by it or doesn't take some value that a corresponding function without _ takes and passes on
20:24:15 <zzing> LordBrain, but is that convension only?
20:24:29 <zzing> ski_, you lost me
20:24:36 <tabemann> I'd personally just go with "not", as in "notElem" for instance
20:24:41 <ski>   f x_y x_ny x = x_ny x (x_y x)  -- renaming the parameters
20:24:42 <LordBrain> its only convention as far as i know, but it is used in prelude etc
20:24:47 <zzing> I am typing this a lot :-)
20:25:10 <LordBrain> if your context makes it clear, then i think it should be fine
20:25:25 <ski> zzing : `djinn' is a simple tool to automatically give an implementation given a type (of a restricted language of types)
20:25:28 <zzing> I think it does
20:25:49 <zzing> ski, isn't that related to a genie?
20:26:19 <ski> etymologically, yes
20:26:25 <ski> @wn djinn
20:26:26 <lambdabot> *** "djinn" wn "WordNet (r) 3.0 (2006)"
20:26:26 <lambdabot> djinn
20:26:26 <lambdabot>     n 1: (Islam) an invisible spirit mentioned in the Koran and
20:26:26 <lambdabot>          believed by Muslims to inhabit the earth and influence
20:26:26 <lambdabot>          mankind by appearing in the form of humans or animals [syn:
20:26:28 <lambdabot>          {genie}, {jinni}, {jinnee}, {djinni}, {djinny}, {djinn}]
20:26:39 <ski> @where djinn
20:26:39 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
20:27:05 <LordBrain> if you have unicode turned on, you might be able to get away with overstrike... i'd have to experiment to see if htat works... as i dont usually use unicode.
20:27:19 <zzing> I use greek in this
20:28:10 * tabemann considers unicode in code to be a bad idea, simply because it's difficult to type... even when there is support for it, as then you have to do things like enter character names to enter single characters
20:28:14 <LordBrain> well, its all preference, i think ' is fine, but it does get used for a lot of different things.
20:29:16 <zzing> enter character names?
20:29:21 <zzing> I just switch keyboards
20:29:26 <zzing> virtual keyboards that is
20:29:30 <LordBrain> i've seen ' used as a simulated state, as in let x=blah, x''= f blah, x'''=g blah
20:29:47 <zzing> Anyone used haskell code in a groff file before?
20:30:08 <jmcarthur> tabemann: a unicode character can be much clearer than a word, though, sometimes
20:30:10 <tabemann> for all the different "mathematical" symbols out there, to not only get them on one keyboard, but expect anyone who might touch one's code to be able to too, is a bit much
20:30:30 <jmcarthur> tabemann: so if it takes no more keystrokes to type it than the word would be, it can be worth it
20:31:09 <LordBrain> yeah, i think good old ascii is still the best usually.
20:31:23 <tabemann> that requires *remembering* the name of the character, which in practice might mean having to look up the name in a chart
20:31:34 <tabemann> where then one's probably just better off typing in the name in ASCII instead
20:31:48 <jmcarthur> editor support is enough to look up a new character
20:32:19 <jmcarthur> to be clear, i use plain ascii in my haskell code because i think it's more convenient
20:32:29 <jmcarthur> but i can't really imagine writing agda without unicode
20:32:35 <zzing> tabemann, ever use APL?
20:32:52 <jmcarthur> actually i can
20:32:53 <jmcarthur> it sucks
20:32:58 <tabemann> I've neither used nor planned to use APL myself
20:33:19 <zzing> jmcarthur, I have heard of experts using it to write one line marvels
20:33:27 <zzing> in what would take a lot more code otherwise
20:33:58 * tabemann personally isn't a fan of one line marvels, in any language
20:34:08 <jmcarthur> that sounds rather absolutist
20:34:40 <jmcarthur> zzing: well, i was talking about agda, not apl
20:34:53 <jmcarthur> not many nice one-liners in agda, actually
20:35:10 <zzing> jmcarthur, ever used idris?
20:35:19 <jmcarthur> i have not yet, but i intend to give it a shot
20:35:32 <applicative_tmp> i was going to say, not much unicode in idris
20:35:35 <zzing> Both interesting conceptions
20:35:45 <tabemann> well, the one-line marvels I've seen have tended to be things that would probably have better put in more, readable code rather than compressed into one line (e.g. the many things in extended pointless style in Haskell)
20:36:04 <zzing> tabemann, point free?
20:36:16 <jmcarthur> i find point free style much more clear than pointful style (within reason)
20:36:26 <tabemann> zzing: pointless means point free, but with different connotations
20:36:34 <zzing> haha
20:37:01 <zzing> Apparently my school is replacing Miranda with Python this year.
20:37:19 <tabemann> to me once things get beyond foo . bar . baz $ quux, they might be better written differently in many cases...
20:37:32 <jmcarthur> i have a hypothesis that dislike of point free style tends to correlate highly with preference for strict evaluation
20:37:42 <jmcarthur> is that accurate for you, tabemann?
20:38:01 <tabemann> zzing: I can see why they'd switch away from Miranda in this day and age, but why to *Python* of all things? (of course, MIT switched from Scheme to Python...)
20:38:15 <applicative_tmp> oh no, replacing miranda with python
20:38:19 <johnw> i do think pointfree code favors a "data flow" interpretation of the function
20:38:21 <zzing> tabemann, good question. I would have rather they did a haskell course
20:38:36 <jmcarthur> johnw: exactly
20:39:30 <jmcarthur> johnw: wait, actually, i misread what you said and now don't think i quite buy it
20:39:34 <tabemann> johnw: my main problem with pointfree code is code where the internal data types of their elements is not entirely clear; usually I can understand code that is just like foo . bar . baz $ quux, but when it becomes things like (foo .) . bar . (. baz) $ quux my eyes glaze over
20:40:28 <jmcarthur> or at least, i'm at a point where i'm undecided as opposed to just agreeing
20:40:39 <johnw> :)
20:40:43 <Hafydd> @unpl (foo .) . bar . (. baz) $ quux
20:40:44 <lambdabot> (\ m -> foo (bar (\ p -> quux (baz p)) m))
20:40:54 <johnw> by data flow I mean that pointfree "pulls" the incoming data through a series of transformations
20:41:09 <jmcarthur> yeah that's exactly the interpretation that i would disagree with
20:41:11 <johnw> you never name the data, so it's all about the transformations
20:41:20 <johnw> how would you phrase it?
20:41:23 <Hafydd> How did it choose "m" and "p", I wonder?
20:42:04 <tabemann> Hafydd: and yeah, it would have taken way too much thinking on my parent to figure out what (foo .) . bar . (. baz) $ quux actually meant
20:42:10 <jmcarthur> trying to work my thoughts appropriately. bear with me
20:42:12 <jmcarthur> *word
20:42:12 <tabemann> *part
20:42:25 <johnw> :t (f .) . (. g)
20:42:26 <lambdabot> (Show b, Show a, FromExpr c, FromExpr b1) => (b1 -> b) -> a -> c
20:42:29 <Hafydd> Heh. You sound like your parents are spoiling you.
20:42:55 <tabemann> neither of my parents know any Haskell, so...
20:42:56 <johnw> @unpl (f .) . (. g)
20:42:56 <lambdabot> (\ e j -> f (e (g j)))
20:43:28 <Hafydd> That's why it takes so much thinking.
20:43:40 <tabemann> my brain really doesn't have an @unpl feature, and I need it to evaluate pointfree style that looks like that
20:43:42 <johnw> yeah, the pointful expression is much better in that case
20:44:03 <Ghoul_> when using `try` I get something like this
20:44:06 <Ghoul_> No instance for (Exception e1) arising from a use of `try'
20:44:19 <johnw> I'm not terribly opposed to (f .) . g, just because I use it a lot and I'm used to it; but I'm not sure it ever actually buys me anything over a lambda
20:44:19 <ski> @type \(f,g) -> (f .) . (. g)
20:44:20 <lambdabot> (b -> c, a -> b1) -> (b1 -> b) -> a -> c
20:44:25 <Ghoul_> I don't care about the result and I don't want to catch the exception. How can I proceed?
20:44:35 <tabemann> have you done: import Control.Exception (Exception)?
20:44:45 <jmcarthur> johnw: i'll just turn my 180 into a 360 and agree with that statement again. it's an accurrate description of a typical thought process with point free style. something about it feels wrong, but i can't find any real fault with it.
20:44:46 <johnw> Ghoul_: use a type signature
20:44:56 <johnw> try ... :: Either SomeException a
20:45:02 <ski> `(f .)' is `result f', and `(. g)' is `argument f' -- SEC-combinators
20:45:02 <blochchain> isn't it a little odd that you can't have a global variable in haskell, considering that a global variable could be considered a function that takes no arguments? also, you could do it in a workaround manner using myvar _ = myval
20:45:07 <johnw> some packages on Hackage have a "tryAny"
20:45:33 <ski> hence `(f .) . (. g)' transforms the result of a given function with `f', and transforms the argument with `g'
20:45:39 <jmcarthur> i like (f . ) . (. g), but only in a context where i am quite clearly transforming a function (the first argument to that expression) and not trying to describe some two-argument function that way
20:46:01 <geekosaur> blochchain, you can have a zero-parameter top level binding just fine. it's not a *variable* though; nor is yours
20:46:10 <ski> jmcarthur : *nod*
20:46:25 <jmcarthur> that is,  (f .) . (. g) $ h  is pretty clear to me, but  ((f .) . (. g)) h x  is kind of weird
20:46:30 <blochchain> geekosaur, i hadn't seen that in LYAH, interesting. is there a good source i should read on the topic?
20:46:34 <tabemann> blochchain: the problem with globals is that GHC Haskell doesn't support *top-level mutable state*, because it can't evaluate IO a at the top-level outside main
20:47:22 <tabemann> resulting in the /unsafePerformIO hack/, and idiom that you probably shouldn't learn
20:47:26 <tabemann> s/and/an
20:47:29 <jmcarthur> blochchain: there's a fairly common hack for that
20:47:43 <jmcarthur> i don't even think it's too bad, except that you have to import unsafe functions to do it
20:47:56 <geekosaur> blochchain, I'm not sure what you're asking. maybe the difference between bindings and variables? (a variable can change. a binding can be shadowed by a different binding, but its value can't be changed)
20:48:05 <jmcarthur> JHC offers it as a feature
20:48:48 * ski . o O ( `ACIO' )
20:48:48 <jmcarthur> geekosaur: my first interpretation was a top level IORef, but i guess that doesn't fit what was said after that
20:48:54 <tabemann> I've run into cases so far that I've wanted to use the unsafePerformIO hack, but so far have chosen to avoid it (because it apparently has problems that there's no guarantee that instances of it will be evaluated *before* main is)
20:49:19 <jmcarthur> tabemann: i can't think of any cases where i actually needed it to run before main. on demand has always been fine for me
20:50:26 <tabemann> hmm
20:50:36 <tabemann> maybe it would work for me in the case I wanted it...
20:50:40 <ski> @wiki Top level mutable state
20:50:40 <lambdabot> http://www.haskell.org/haskellwiki/Top_level_mutable_state
20:50:52 <tabemann> (but I still don't like the idea of it)
20:50:56 <ski> details various options
20:51:08 <tabemann> yeah, I've read that page
20:51:13 <jmcarthur> for that matter, it's not even that it's not a guarantee to evaluate before main, it's that it's pretty much guaranteed *not* to evaluate before main
20:51:42 <tabemann> hmm
20:52:36 <jmcarthur> you can always just force it immediately before doing anything else, if that's important
20:52:49 <jmcarthur> unless it's a library, in which case you are at the mercy of a responsible user
20:54:45 <jmcarthur> in some code i wrote: "-- TODO This stuff is stupid. Do something more straightforward."  and later, above another attempt: "-- ... This is my idea of 'more straightforward'?"
20:55:32 <tabemann> <jmcarthur> unless it's a library, in which case you are at the mercy of a responsible user
20:55:38 <tabemann> that's the last thing I saw
20:55:53 <jmcarthur> that was the last relevant thing i said. i changed the subject to something random after that
20:55:54 <tabemann> now that I think about it, at least if what one does in the unsafePerformIO hack is pure, what *is* the problem with it really?
20:56:07 <ski> (oh, it's a travisb)
20:56:13 <sclv> if its pure then why do it?
20:56:18 <jmcarthur> nothing, really
20:56:33 <sclv> in fact if its pure then it doesn't need to be behind an unsafeperformio at all
20:57:32 <orzo> i've done some template haskell magic to give me two-way lambdas: $(bij [| \(x,y) -> (y,x) |])
20:57:38 <tabemann> I mean, for instance, if you put a newTVarIO in your unsafePerformIO - you aren't actually producing any side effects aside from constructing a TVar, which is not visible to anyone except those who access said TVar
20:57:40 <orzo> Is there anyway i can make the notation less verbose?
20:57:45 <ski> sclv : depends on whether the implementation can be written without `IO', or perhaps just that it's behaviourally pure
20:57:50 <orzo> short of actually parsing a string
20:59:12 <ski> i tend to think a precondition of `unsafePerformIO ma' to be that there is some `a' with `ma = return a'
20:59:13 <orzo> $(bij [| \(x,(y,z)) -> (x,y,z) |]) also implies the other direction \(x,y,z)->(x,(y,z)) for example
20:59:56 <johnw> ski: right, then IO is just the carrier of the value, and the effects are irrelevant
21:00:20 <tabemann> which for most uses of the unsafePerformIO hack is the case
21:00:37 <ski> yes, a bit like how `runST' encapsulates *local* side-effects, but not checked by the type system
21:00:56 <tabemann> because most cases of it are just places where you want to use newIORef, newMVar, newTVarIO, etc. at the top level
21:01:16 <tabemann> the only problem I see with the unsafePerformIO hack is this
21:01:48 <tabemann> what if it gets evaluated twice, due to two threads trying to evaluate it almost precisely but exactly at the same time, so that one cannot block out the other with blackholing
21:02:30 <tabemann> so if you have foo = unsafePerformIO $ newTVar 0, you might end up with *two* TVars
21:02:35 <tabemann> s/newTVar/newTVarIO
21:02:45 <ski> well, in case of `newIORef a', there is the problem that different executions generate unequal references -- so you'd need to prevent duplication of the side-effect
21:03:21 <tabemann> so to do this kind of thing safely with the unsafePerformIO hack, you'd have to make sure to force it once before anyone else can touch it
21:03:49 <tabemann> but the problem is that requires someone else calling code which does that, which cannot be guaranteed to be the case
21:04:12 <tabemann> hmm
21:04:14 <ski> (different executions due to code rearrangement by the implementation duplicating or merging the call of `unsafePerformIO . newIORef')
21:05:06 <tabemann> I was almost thinking that the unsafePerformIO hack just *might* be safe enough, but now that I think about this side of it...
21:05:46 <Ghoul_> theres an unsafePerformIO hack in the mmap package
21:05:52 <Ghoul_> that destroys windows ability to use it properly :(
21:06:17 * ski prefers the Mercury tradition of naming potentially unsafe stuff something starting with `promise', rather than `unsafe', as in Haskell
21:06:47 <Ghoul_> unsafe sounds more extreme
21:06:47 <applicative_tmp> oh, really>
21:06:56 <ski> (as in `promise_pure',`promise_deterministic', and `promise_equivalent_solutions')
21:07:04 <tabemann> promise doesn't sound as... threatening
21:07:09 * applicative_tmp remembers conal suggesting 'proveSafeBlah'
21:07:18 <Ghoul_> applicative_tmp: was that directed at me?
21:07:21 <ski> yeah, but it's unclear exactly what is unsafe, and under which proof obligations it's actually safe
21:07:22 <tabemann> and proveSafe is more verbose
21:07:33 <applicative_tmp> oh, no the promiseSafe bit, Ghoul_
21:07:39 <Ghoul_> oh, okay.
21:07:53 <Ghoul_> laziness + someones usage of unsafePerformIO may have caused this glitch here: http://stackoverflow.com/questions/17292048/segfault-reading-lazy-bytestring-past-218-bytes
21:08:10 <ski> yes, `promisePureIO' might be a nicer name for `unsafePerformIO'
21:08:17 <applicative_tmp> proveSafePerformIO
21:08:58 <Ghoul_> just call it unsafeNukeSmallCountry and everyone will use it properly, that is, never
21:09:19 <tabemann> unsafeLaunchMissiles
21:09:32 <applicative_tmp> oh, I don't know; we'll use it in America; elsewhere they will show more restraint
21:09:51 <Ghoul_> cue: http://e.asset.soup.io/asset/1242/4622_4515_350.jpeg
21:09:53 <thoughtpolice> the problem is the unsafePerformIO hack is in fact, unsafe (for other reasons.) but in the case of GHC, CAFs are actually atomic and locked properly in the -threaded RTS, so you should be fine (this is only true post 7.4+ technically due to a bug)
21:10:36 <tabemann> thoughtpolice: what other reasons?
21:10:56 <thoughtpolice> the main problems IMO are that 1) it's implementation dependent (e.g. you need NOINLINE), and 2) polymorphic references, although granted most people know 2) is bad by now
21:11:29 <thoughtpolice> you can make it safe to use, but that still doesn't mean it's actually safe. if you want something to abstract over it, use safe-globals
21:11:36 <thoughtpolice> (the package safe-globals, that is)
21:11:57 <ski>   "A call to the function `promise_only_solution(Pred)' constitutes a promise on the part of the caller that `Pred' has at most one solution, i.e. that `not some [X1, X2] (Pred(X1), Pred(X2), X1 \= X2)'.  `promise_only_solution(Pred)' presumes that this assumption is satisfied, and returns the X for which Pred(X) is true, if there is one."
21:12:02 <tabemann> it doesn't seem like people care much these days about implementation dependence (considering how *much* code that is entirely GHC-dependent gets written), and as for polymorphic references, that can be easily avoided
21:12:03 <ski>   "Note that misuse of this function may lead to unsound results: if the assumption is not satisfied, the behaviour is undefined.  (If you lie to the compiler, the compiler will get its revenge!)"
21:12:13 <ski> (is from docs for `promise_only_solution')
21:12:34 <thoughtpolice> the problem is it's unclear if NOINLINE will ever change. what if eventually we need a second pragma to make sure GHC *really* doesn't do something weird?
21:13:10 <thoughtpolice> then all the old code is waiting to break. this is not safe, although i'll admit you probably have a decently safe bet on this
21:13:53 <tabemann> which is why we need to have to actually explicitly make mutable top-level state part of GHC, like in JHC
21:14:12 <Ghoul_> tabemann: have you read bens paper?
21:14:24 <ski> thoughtpolice : yeah, while `promise_only_solution' e.g. isn't implementation dependent, it's just that it has an explicit proof obligation on the part of the programmer; if not satisfied the behaviour is undefined
21:14:35 <tabemann> I've only read the page on haskellwiki
21:14:36 * hackagebot test-sandbox 0.0.1.3 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.0.1.3 (BenjaminSurma)
21:14:48 <ski> (but if the proof obligation is met, then you know it is safe)
21:16:24 <tabemann> the problem is that in Haskell we have left many such things to the implementation, because those who did the standardizing preferred not to deal with them
21:16:30 <tabemann> so now we have things that truly are unsafe
21:16:43 <tabemann> not merely safe under conditions that have to be guaranteed by the programmer
21:17:08 <dmj`> Couldn't match type `Data.ByteString.Lazy.Internal.ByteString' with `bytestring-0.10.0.2:Data.ByteString.Lazy.Internal.ByteString. Anyone seen this before?
21:17:27 <tabemann> (e.g. how they seemed to treat unsafePerformIO as if it really wasn't part of Haskell)
21:17:35 <ski> tabemann : yep
21:17:41 <arkeet> dmj`: importing something built against a different version of bytestring?
21:18:20 <Ghoul_> tabemann: it's widely considered an error though
21:18:21 <dmj`> arkeet: Just codec.compression.gzip and data.binary. I'll check the bs versions
21:18:56 <Ghoul_> unless you are performance hacking or writing something pure that messes around with pointers for performance
21:19:14 <Ghoul_> /s/or/ie:/
21:20:25 <Hafydd> unless you are perfiemance hacking ie writing something pure that messes around with pointers fie perfiemance
21:21:34 <Ghoul_> dammit
21:26:05 <tabemann> in the end, though, unsafePerformIO bothers me less than unsafeCoerce
21:26:19 <scshunt> but the former builds the latter
21:26:56 <Ghoul_> when would you need to use unsafeCoerce?
21:27:04 <edwardk> tabemann: you can implement unsafePerformIO _with_ unsafeCoerce. it is glorious.
21:27:17 <edwardk> =)
21:27:30 <Ghoul_> can you do the opposite with peek/poke?
21:27:55 <edwardk> dmj: you have two versions of it linked into what you're using. e,g. you have a lib written against an old one but ghci is picking the new one.
21:28:09 <scshunt> edwardk: did you mean the other way around?
21:28:21 <tabemann> the only "legitimate" use for unsafeCoerce I have ever heard of is if someone wants to basically fmap a big data structure with a function that merely swaps around a newtype and its contents
21:28:23 <edwardk> dmj`: use     ghci Blah.hs -package bytestring-0.10.0.2  and see what happens
21:28:47 <tabemann> and it's cheaper that plain fmap with even just a data constructor because you don't actually traverse the data structure
21:29:58 <edwardk> scshunt: no you can unsafeCoerce IO to a function from something because it is State# RealWorld -> (# State# RealWorld, a #)  -- so if you pick almost any N represented source, and try to evaluate the result as an unboxed tuple it works
21:30:25 <edwardk> scshunt: worse, you can even fake it as a function from () and it'll run the IO action before crashing on you from the GC going haywire
21:30:46 <edwardk> ion demonstrated this when a lens bug turned out to be a ghc bug that let you define unsafeCoerce with nothing more than Haskell 98
21:31:23 <edwardk> let unsafeCoerce v = z where z :: v; z = v where aux = const v  -- used to work
21:31:26 * tabemann remembered reading something where someone was sure that he could derive unsafeCoerce with Haskell 98 + GeneralizedNewtypeDeriving, but hadn't at the time of writing quite worked it out
21:31:41 <edwardk> tabemann: there is no GND in that code =)
21:32:14 <scshunt> edwardk: haha
21:32:17 <edwardk> it was purely a 'forgotten skolem escape check' issue
21:32:24 <edwardk> scshunt: lens gets the best bug reports
21:32:27 <edwardk> glguy++
21:32:51 <edwardk> http://ghc.haskell.org/trac/ghc/ticket/7453 was the issue we put in
21:33:13 <scshunt> edwardk: GHC literally implements RealWorld as a boxed real world?
21:33:29 <edwardk> amusingly if you replace aux    with aux _ = v    it doesn't work
21:34:12 <edwardk> scshunt: no, its unboxed, but the coercion using the trick above smashes the right things on the stack long enough to run an IO action before dying
21:34:20 * applicative_tmp wonders what  -DTICKY_TICKY  does
21:34:21 <scshunt> ah, haha
21:34:38 * scshunt will probably never quite understand how Acme.RealWorld works and/or what it actually does
21:34:39 <edwardk> let unsafeCoerce v = z where z :: v; z = v where aux = const v in (unsafeCoerce (putStrLn "evil IO action") :: () -> ()) ()
21:34:43 <arkeet> haha, how does that even work?
21:35:55 * tabemann was slightly disturbed when he learned that GHC actually implemented Haskell as a completely impure language at the runtime level, and only had types, laziness, and aggressive inlining hiding this
21:36:45 <scshunt> tabemann: doesn't it also have memoization?
21:36:53 <applicative_tmp> to think that this pure lambda calculus is implemented in a combination of atoms and the void!
21:37:07 <applicative_tmp> what a hack!
21:37:20 <blochchain> is Data.Text not default in GHC?
21:37:28 <applicative_tmp> no, its a library
21:37:35 <edwardk> blochchain: it is a library, written by bos
21:37:37 <applicative_tmp> or what do you mean, 'default', blochchain
21:37:43 <blochchain> do i need to install it?
21:37:51 <edwardk> it is included in the "haskell platform" if you installed that you have it
21:37:56 <applicative_tmp> ah it does come with Haskell Platform,
21:37:58 <tabemann> scshunt: when one is speaking of individual expressions, implemented as zero-argument functions, yes
21:38:03 <edwardk> if you installed ghc directly all bets are off
21:38:08 <applicative_tmp> other wise 'cabal install text' blochchain
21:38:30 <applicative_tmp> blochchain: 'ghc-pkg list text' will tell you if you have it
21:38:51 <blochchain> thanks
21:39:36 <tabemann> applicative_tmp: I mean learning that the typical arguments about what "IO" is are entirely off in reality - that IO just acts to maintain order between impure function calls
21:44:18 <scshunt> tabemann: sure
21:44:22 <scshunt> but that's not the point
21:44:43 <scshunt> any haskell compiler will eventually compile down to von neumann model
21:44:51 <scshunt> but the language abstracts that away
21:45:01 <scshunt> (unless you need to get rid of the abstraction, in which case the language is there to help you out)
21:45:10 <scshunt> s/the language is/extensions are/
21:47:36 <carter> scshunt  how does haskell hide the imperative cpus?
21:47:51 <carter> i can totally exploit the properties of my CPU to write super fast code in haskell
21:48:14 <carter> tabemann: yup, IO is a great tool for order
21:48:18 <carter> ish
21:48:19 <scshunt> carter: right. But you don't have to in order to write code without caring about efficiency
21:48:26 <carter> yes
21:48:29 <scshunt> the point of abstraction is to allow for improved reasoning
21:48:31 <carter> yes
21:48:43 <carter> good haskell libraries let their users not have to think about the cpu model
21:48:52 <carter> they provide the nice composable performant abstractions
21:48:52 <scshunt> hence things like relegating IO to its own monad
21:48:57 <scshunt> and laziness by default
21:49:22 <carter> laziness is a bit more subtle than that
21:49:33 <carter> I think that the general concensus, is laziness in the large is good
21:49:40 <carter> in the small, strict is king
21:49:41 <johnw> yes, it certainly is
21:49:48 <scshunt> laziness makes it easier to reason
21:49:54 <scshunt> sometimes the penalty is not worth it though
21:49:58 <carter> scshunt except when it isnt
21:49:59 <johnw> and it allows for better decoupling of algorithmic concerns
21:50:08 <scshunt> carter: example?
21:50:25 <carter> strict accumulator over a lazy stream
21:50:38 <carter> accumulator --- the small
21:50:47 <carter> stream : the coupling point in a larger system
21:50:50 <carter> or any EDSL
21:51:01 <carter> we compose systems lazily
21:51:09 <tabemann> the biggest problem where I see laziness as being a problem is accumulators
21:51:12 <carter> yes
21:51:13 <carter> hence
21:51:16 <carter> strict in the small
21:51:16 <tabemann> s/problem where/place where
21:51:19 <carter> lazy in the large
21:51:28 <LordBrain> laziness makes some algorithms nicer to code, i'm not sure it is really easier to reason tho, that's debatable..
21:51:29 <carter> we use laziness to make compositional libs
21:51:39 <carter> LordBrain: look at what i'm saying :)
21:51:55 <tabemann> LordBrain: but gluing together strict code has its own problems
21:51:58 <carter> yes
21:52:06 <carter> hence my claim :)
21:52:23 <tabemann> as even if the strict code is pure, you can't just have data flowing from generator to consumer in a seamless fashion
21:52:42 <carter> yeah
21:52:55 <carter> you want your insides of a compoenent to be strict
21:53:01 <LordBrain> well somebody has to commit to laziness if we are ever going to get it just right
21:53:10 <carter> LordBrain read what I said
21:53:21 <carter> lazy in the large / systems compostion side
21:53:29 <carter> strict inside the pieces
21:53:31 <johnw> i feel like the people who clamor "strictness by default" are just opting for mental laziness instead
21:53:40 <carter> thats a bit strong
21:53:43 <johnw> but maybe that's a bit too inflammatory
21:53:48 <carter> indeed
21:53:52 <johnw> i've read it enough times that it bugs me sometimes, osrry
21:53:57 <carter> sorry
21:54:03 <carter> :)
21:54:05 <carter> tried
21:54:08 <carter> *tired
21:54:31 <johnw> laziness imposes a different tax
21:54:33 <tabemann> it's taken me a while to get used to laziness, but from constructing, in parallel, both strict and lazy versions of the same list-manipulation functions, in the end the lazy versions were much easier to reason about and most likely had better complexity
21:54:39 <johnw> but I think it really is a preferable one overall
21:54:58 <carter> yeah
21:55:07 <johnw> i use to love the SERIES library in Common Lisp, but man was that super hard to use within a strict-by-default environment
21:55:07 <carter> its also easier to add strictness to code than to add laziness
21:55:22 <LordBrain> well, the real win for laziness is like carter says, gluing together code
21:55:33 <carter> which is what johnw  said too !
21:55:42 <johnw> yep
21:55:47 <carter> like, you can transliaterate a BNF to a parser stat :)
21:55:53 <johnw> strict algorithms have to embed considerations like "only generate 10 numbers from this series"
21:55:58 <Ralith> tabemann: it's when you get beyond list-manipulation functions that the issue becomes less obvious :P
21:56:11 <johnw> with laziness you take that decision out of the core algorithm and make it something the caller can decide as needed
21:56:12 <LordBrain> you can write much nicer looking code if you rely on the laziness, but i wouldn't say it is easier to reason about, in fact it is probably harder.
21:56:27 <carter> depends on the code though
21:56:40 <johnw> in fact, I was just saying to mgsloan yesterday
21:56:47 <johnw> that laziness has totally changed the way I use "let"
21:56:55 <carter> oh?
21:57:04 <applicative_tmp> johnw: oh you've used the SERIES library? I was reading about it in connection with repa
21:57:04 <johnw> in Lisp and C++, I have to take great care to initialize values in the places where I will actually use them, to avoid needless work
21:57:05 <LordBrain> it's definitely prettier.. or can be, done right
21:57:05 <carter> lets do have lazy patterns right?
21:57:17 <johnw> whit Haskell, I just group everything logically, and laziness takes care of only using what is needed
21:57:56 <johnw> so, like 90% of the time laziness frees my mind, and then 10% of the time is occupies the whole of it
21:58:19 <LordBrain> yeah, but then you can end up with a space leak after the fact, and it is harder to track that down...
21:58:32 <johnw> indeed, that is the "tax" I mentioned above
21:58:33 <carter> LordBrain have you had those space leaks yet?
21:58:35 <carter> I did once
21:58:38 <carter> a year and a half ago
21:58:47 <johnw> but over time, you get better at finding space leaks
21:58:48 <LordBrain> yes
21:58:54 <johnw> it's like learning to read C++ template error messages
21:58:54 <carter> its why i use strict Containers lib now
21:59:03 <carter> not the lazy stuf
21:59:36 * hackagebot exceptions 0.3 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.3 (EdwardKmett)
21:59:39 <tabemann> back
21:59:39 <LordBrain> well if we can get the tools right, ideally, we can really address that problem
22:00:00 <LordBrain> or at least we can hope
22:00:06 <johnw> the funny thing is though, with the production code I'm writing now -- which is nearly all monadic -- I never even think about space leaks anymore, nor do I run into them.  It's not quite the "ever-present" problem that some say it is
22:00:27 <tabemann> from reading about them, most space leaks basically seem to be non-strict accumulators and holding some reference to data structures that are supposed to be GCed... or is there something more to it that I'm missing
22:00:28 <LordBrain> because if it wasn't for the debugging  space leak problem, i think laziness would kick strictness's ass...
22:00:50 <Adeon> my dad is lazier than your dad
22:01:16 <LordBrain> my dad's so lazy he hasn't even breathed in years.
22:01:45 <carter>  tabemann : yup, that plus these days everyone makes their datastructures have strict fields by default :)
22:02:27 <elliott> not "everyone". :(
22:02:38 <elliott> "foo :: !String" makes me really sad. it doesn't even solve the problem it's trying to.
22:02:51 <carter> well, yeah, you should never use String :)
22:02:53 <johnw> i don't make my fields strict by default either
22:03:05 <elliott> I think lazy by default is actually the right thing for datatype fields.
22:03:08 <carter> depends
22:03:10 <elliott> but you need to really know when it's wrong.
22:03:20 <carter> lazy spine or strict spine
22:03:33 <carter> eg: you can have a list with strict values + lazy spine
22:03:38 <carter> strict spine but lazy valeus
22:03:39 <carter> both laz
22:03:40 <carter> y
22:03:43 <carter> boths strict
22:04:21 <carter> lazy spine is good for streaming
22:04:28 <carter> strict spine is good for collections
22:04:37 * hackagebot exceptions 0.3.1 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.3.1 (EdwardKmett)
22:04:40 <LordBrain> it would be really awesome if the compiler could actually catch a space leak.
22:04:41 <johnw> well, collections that accumulate, for certain
22:04:47 * tabemann is still wondering whether he should put his strict list library in hackage; but from reading more he wonders what use it has, and most cases where it does have a use, it would be simpler to just use deepSeq before, say, transferring data to another thread
22:05:05 <johnw> like when you insert into a map using a fold, then strict spine is necessary
22:05:10 <edwardk> tabemann: strict in spine or values or both?
22:05:18 <tabemann> edwark: both
22:06:03 <LordBrain> if the Conduit library provides lazy pull semantics without leaks, then why couldn't we have something like that go on under the hood?
22:06:34 <johnw> LordBrain: Conduit achieves that by forcing you to act on values "one at a time"
22:06:51 <pharaun> hm best way to do matching nested parens? for parsec
22:06:53 <johnw> so you generally don't use a conduit to accumulate a bunch of values into a new structure, and then pass around that structure
22:06:59 <johnw> if you did, you might very well have the same problem
22:07:20 <pharaun> so far i've got single deep braces parsing via between but i'm uncertain of ( a ( b ) )
22:07:25 <johnw> pharaun: I think the Token module has a function for that
22:07:30 <pharaun> token? ok
22:07:38 <pharaun> digging into that
22:07:52 <johnw> it's like balanced, or bounded, or something...
22:08:11 <johnw> i'm not sure if it handles nesting though, I haven't used it
22:08:47 <pharaun> i got first level to work via  between (char '(') (char ')') (parser stuff)
22:08:53 <pharaun> but yeah i'm going to look for balanced/bound
22:09:43 <johnw> ah, it's called between
22:09:50 <johnw> :t Text.Parsec.Combinator.between
22:09:51 <lambdabot> Text.Parsec.Prim.Stream s m t => Text.Parsec.Prim.ParsecT s u m open -> Text.Parsec.Prim.ParsecT s u m close -> Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m a
22:10:01 <johnw> braces  = between (symbol "{") (symbol "}")
22:10:05 <pharaun> ahh, yeah using that, i guess i just need to figure out how to call between repeatedly in a context that makes sense for me
22:10:11 <pharaun> yup :)
22:12:08 <blochchain> is there a function in the standard library to test if two lists share elements?
22:13:18 <applicative_tmp> > [1,2] // [2,3]
22:13:19 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i0 e0'
22:13:19 <lambdabot>              with actual...
22:13:22 <applicative_tmp> bah
22:13:39 <applicative_tmp> > [1,2] \\ [2,3]
22:13:40 <lambdabot>   [1]
22:13:54 <applicative_tmp> ah the old right-left thing
22:15:41 <applicative_tmp> blochchain: \\ is in Data.List
22:19:08 <lispy> > let x .-. y = x \\ y `union` y \\ x in [1,2] .-. [2,3]
22:19:10 <lambdabot>   Precedence parsing error
22:19:10 <lambdabot>      cannot mix `Data.List.\\' [infix 5] and `Data...
22:19:27 <lispy> > let x .-. y = (x \\ y) `union` (y \\ x) in [1,2] .-. [2,3]
22:19:28 <lambdabot>   [1,3]
22:19:52 <latermuse> lispy, what library is that (.-.) operator from?
22:20:17 <Makoryu> @info (.-.)
22:20:17 <lambdabot> (.-.)
22:20:19 <Makoryu> Dang
22:20:23 <latermuse> haha
22:20:26 <lispy> latermuse: I just defined it in that command
22:20:46 <latermuse> ohh i see
22:20:48 <lispy> > let (._.) x y = (x \\ y) `union` (y \\ x) in [1,2] .-. [2,3]  -- equivalent definition
22:20:49 <lambdabot>   <hint>:1:9: parse error on input `)'
22:20:49 <latermuse> haha :)
22:20:59 <lispy> > let (.-.) x y = (x \\ y) `union` (y \\ x) in [1,2] .-. [2,3]  -- equivalent definition
22:21:00 <lambdabot>   [1,3]
22:21:03 <lispy> (sorry, typo!)
22:22:33 <latermuse> Its a join, right?
22:23:05 <lispy> I'm not sure
22:23:25 <lispy> [a] != Set a, especially in the handling of duplicates
22:23:46 <lispy> > let (.-.) x y = (x \\ y) `union` (y \\ x) in [1,2,1] .-. [2,3]
22:23:47 <lambdabot>   [1,1,3]
22:24:05 <applicative_tmp> ah, Data.Set has a proper intersection
22:24:25 <lispy> yeah, it's mostly intersection but it could be buggy in corner cases
22:27:29 <satc> @pl \a -> f (\b -> (a,b))
22:27:30 <lambdabot> f . (,)
22:27:43 <ahihi> > let common xs ys = not $ Data.Set.null $ (Data.Set.intersection `on` Data.Set.fromList) xs ys in common [1,2,3] [3,4,5]
22:27:44 <lambdabot>   Not in scope: `Data.Set.null'
22:27:44 <lambdabot>  Perhaps you meant `Data.List.null' (imported...
22:27:51 <ahihi> boo
22:28:26 <lispy> :t S.intersection
22:28:26 <lambdabot> Ord a => S.Set a -> S.Set a -> S.Set a
22:28:37 <lispy> ahihi: use S instead of Data.Set
22:29:07 <ahihi> > let common xs ys = not $ S.null $ (S.intersection `on` S.fromList) xs ys in common [1,2,3] [3,4,5]
22:29:08 <lambdabot>   True
22:29:18 <applicative_tmp> > > let disjoint xs ys = S.null (S.intersection (S.fromList xs) (S.fromList  ys)) in disjoint "Athens" "Jerusalem"
22:29:19 <lambdabot>   <hint>:1:1: parse error on input `>'
22:29:25 <applicative_tmp> > let disjoint xs ys = S.null (S.intersection (S.fromList xs) (S.fromList  ys)) in disjoint "Athens" "Jerusalem"
22:29:26 <lambdabot>   False
22:30:46 <applicative_tmp> i suppose that's no worse than what you'd cook up using only list functions
22:32:39 <latermuse> > map(chr.fromIntegral)[0x48,0x65,0x6c,0x6c,0x6f,0x20,0x57,0x6f,0x72,0x6c,0x64]
22:32:40 <lambdabot>   "Hello World"
22:35:44 <zzing> Is there a structure that is like a list, but is guaranteed to have 1 or more items instead of 0 or more?
22:36:24 <maxiepoo> http://www.haskell.org/haskellwiki/Non-empty_list
22:37:45 <zzing> Those would be helpful merci
22:39:00 <johnw> there is a package containing NonEmpty
22:39:06 <johnw> i believe it's semigroups
22:39:28 <johnw> basically the structure is (a,[a])
22:41:02 <zzing> As long as it smells like a list and acts like a list, except for it is non-empty guaranteed :P
22:45:13 <Hrumph> zzing i don't understand how this would work algebraicall
22:45:28 <zzing> Hrumph??
22:45:53 <blochchain> is there a package that estimates or stores a word's syllable count?
22:46:06 <Hrumph> the empty string is an identity element for strings which are a semi-group or something
22:46:24 <Hrumph> if you add inverse elements to strings you get a free group
22:46:42 <Hafydd> Heh, inverse strings.
22:46:43 <zzing> Hrumph, well this isn't going to be a monoid at the very least :P
22:46:54 <Hafydd> Backspace characters?
22:47:21 <Hrumph> so i'm trying to to imagine some kind of matching algbraic strcuture that goes along with the non-empty requirement
22:48:06 <zzing> Hrumph, I don't see any requirement of a semi-group to have an identity element
22:48:28 <Hrumph> true
22:48:41 <blochchain> Hrumph, is there a type class for things with identities? i'm confused by the fact that String isn't a Monoid
22:49:03 <dibblego> > mempty :: String
22:49:04 <lambdabot>   ""
22:49:05 <zzing> blochchain, String is a monoid
22:49:13 <zzing> Because a String is a [Char]
22:49:33 <blochchain> ah
22:49:53 <pentace> blochchain: The hyphenation package might be what you're looking for
22:49:53 <dibblego> there is a type-class for things that are semigroups but not monoids and it is in the semigroupoids package
22:50:01 <haasn> (of course, Monoid provides more than just an identity - it also provides associativity claims)
22:50:04 <blochchain> how do you list a type's classes in GHCi?
22:50:10 <dibblego> sorry, the semigroups package
22:50:20 <dibblego> blochchain: :i String
22:50:23 <haasn> blochchain: :i will usually pick them up if you have both in scope
22:50:23 <LordBrain> does :info
22:50:51 <LordBrain> if you look at the haddock, it lists them under instances
22:50:52 <haasn> it doesn't catch Monoid String though, apparently
22:51:01 <haasn> that shows up under :i []
22:51:18 <zzing> The reason I needed a non-empty list is there is a multinomial opinion in subjective logic that would essentially require it
22:51:25 <blochchain> dibblego, all that gives me is type String = [Char] 	-- Defined in `GHC.Base'
22:51:35 <dibblego> non-empty list is as necessary as [] in every-day programming
22:51:37 <haasn> there are plenty of valid reasons to require nonempty lists, hence it being provided by numerous packages :)
22:51:46 <dibblego> blochchain: yes sorry, :info [] with import Data.Monoid should work
22:51:54 <applicative_tmp> > execWriter $ do {tell "hi" ; tell " "; tell "there, "; tell "blochchain"}
22:51:55 <lambdabot>   "hi there, blochchain"
22:52:24 <haasn> I wonder if lens + NonEmpty makes them nearly as easy to work with as regular lists
22:53:31 <supki> well, lens HEAD kind of does
22:53:39 <Hafydd> lens tail
22:53:40 <haasn> what's new in lens HEAD?
22:53:45 <haasn> that would be relevant, I mean
22:53:58 <supki> Ix/*WithIndex instances
22:54:06 <haasn> well for starters lens already offers generalized versions of list-based folds (eg. sumOf, lengthOf and so forth)
22:54:08 <supki> Ixed, even
22:54:10 <haasn> ah okay
22:54:55 <haasn> it also has Cons, but you'd probably need to write your own instance for NonEmpty
22:55:19 <haasn> which gives you access to _head, _tail and stuff
22:56:18 <blochchain> i got it working
22:56:22 <blochchain> thanks
22:56:41 <blochchain> surely i'm not the first to come up with a safe form of "last" for Monoids, right?
22:56:43 <haasn> :t Data.Foldable.fold
22:56:43 <lambdabot> (Foldable t, Monoid m) => t m -> m
22:56:56 <startling> blochchain: huh?
22:57:01 <haasn> > Data.Foldable.fold ["hi", " ", "there, ", "applicative"]
22:57:02 <lambdabot>   "hi there, applicative"
22:57:05 <blochchain> i wonder if it's in Data.Monoid, i'll check
22:57:30 <startling> blochchain: oh, you mean "the last thing in a list, or mempty if it's empty"?
22:57:52 <haasn> sounds like Maybe is a better abstraction for that than Monoid
22:58:08 <startling> yeah.
22:58:10 <haasn> together with fromMaybe (Sum 0) eg.
22:58:25 <Targen> data EvenLessEmpty a = a :|| NonEmpty a
22:58:25 <startling> > preview _last [1, 2]
22:58:29 <lambdabot>   Just 2
22:58:35 <Targen> I mean, it’s a matter of time.
22:59:22 * haasn .oO( data NonEmpty a = forall (n :: Nat). (n > 0) => NonEmpty (Vec n a)   )
23:00:21 <haasn> hey, RebindableSyntax overloads [a, b, c] notation doesn't it?
23:00:32 <applicative_tmp> i think it doesnt yet?
23:00:34 * startling .oO( data NonEmpty a = forall (n :: Nat) => NonEmpty (Vec (S n) a) )
23:02:04 <blochchain> startling, yes
23:02:20 <blochchain> haasn, for folding it doesn't much matter, using Maybe would be a drag
23:02:23 <haasn> applicative_tmp: looks like it doesn't
23:02:46 <haasn> hmm
23:02:49 <haasn> :t view _last
23:02:52 <lambdabot> (MonadReader s m, Snoc (->) (Accessor a) s s a a) => m a
23:03:08 <startling> haasn, I don't think that works
23:03:12 <startling> > view _last [1]
23:03:14 <lambdabot>   No instance for (Data.Monoid.Monoid a0)
23:03:14 <lambdabot>    arising from a use of `e_11'
23:03:14 <lambdabot>  Th...
23:03:18 <haasn> :t view _last `asAppliedTo` []
23:03:19 <lambdabot> Monoid a => [a] -> a
23:03:20 <startling> Yeah. It's a prism, not a lens
23:03:26 <haasn> err
23:03:32 <haasn> :t view _tail `asAppliedTo` [] -- is what I meant
23:03:33 <lambdabot> [a] -> [a]
23:03:44 <haasn> > view _tail [1..10]
23:03:47 <lambdabot>   [2,3,4,5,6,7,8,9,10]
23:03:47 <haasn> > view _tail []
23:03:49 <lambdabot>   []
23:04:09 <startling> > (view _last `asAppliedTo` []) [1, 2, 3]
23:04:10 <lambdabot>   No instance for (Data.Monoid.Monoid a0)
23:04:10 <lambdabot>    arising from a use of `e_1123'
23:04:10 <lambdabot>  ...
23:04:20 <haasn> the other one works too, either way, but not in the same way
23:04:26 <startling> > (view _last `asAppliedTo` []) [Sum 0]
23:04:32 <lambdabot>   Sum {getSum = 0}
23:04:34 <haasn> > view _last ["hello", "startling"]
23:04:35 <lambdabot>   "startling"
23:04:40 <haasn> > view _last [] :: String
23:04:41 <lambdabot>   ""
23:04:46 <startling> oh, I see what it does. Neat.
23:04:48 <haasn> blochchain: ^
23:10:54 <Targen> So um, hi.  I’m in an uncomfortable situation with type families and I’m not sure what to do about it.  I’m trying to write a simple overloaded function to turn stuff into JSON but allowing instances to include Yesod’s typesafe URIs.
23:12:10 <Targen> The thing is, the function that takes such URIs and spits out text isn’t just laying around.  It comes from getUrlRender :: MonadHandler m => m (Route (HandlerSite m) -> Text)
23:12:57 <Targen> HandlerSite is a type family in MonadHandler that gives the Yesod foundation data type for each instance of MonadHandler.
23:13:50 <Targen> So I try this: class MonadHandler m => ToHAL m a where renderHAL :: (Route (HandlerSite m) -> Text) -> a -> Value
23:15:12 <Targen> The idea is that it’d be nice to constrain instances to be unable to have Handler effects, but still allow them to use the URI-rendering function that comes from the Handler context.
23:16:21 <Targen> And then, to actually take some data and turn it into a Value, something like toHAL value = (`renderHAL` value) <$> getUrlRender
23:17:15 <Targen> But then I get a nasty error: it can’t deduce HandlerSite m ~ HandlerSite m0 because type families are not injective and yadda yadda yadda.
23:19:08 <Targen> As far as I can tell, it’s a symptom of the overloaded function not mentioning the type parameter from the typeclass in its signature, so it’s ambiguous and the non-injective type family application naturally doesn’t help figure out what instance to use.
23:19:31 <Targen> So I figured out a hack — a nasty hack.
23:20:19 <Targen> class MonadHandler m => ToHAL m a where renderHAL :: m b -> (Route (HandlerSite m) -> Text) -> a -> Value
23:21:11 <Targen> toHAL value = let c = c >>= return in (flip (renderHAL c) v <$> getUrlRender) `asTypeOf` c
23:21:42 <Targen> (`c` could’ve been just `return undefined`)
23:22:06 <arkeet> :t (>>= return)
23:22:07 <lambdabot> Monad m => m b -> m b
23:22:17 <Targen> What’s the proper way to do this sort of thing?
23:22:20 <arkeet> Targen: it could have been `undefined`
23:23:02 <Targen> arkeet: Indeed, but then it doesn’t fix the ambiguity — not sure why.
23:29:20 <Targen> It’s not so nasty since there is nothing that could possibly be done with the passed MonadHandler computation (ignoring unsafePerformIO), but it still feels like a very ugly hack.
23:29:40 * hackagebot aws-route53 0.0.1 - Route53 plugin for the aws package  http://hackage.haskell.org/package/aws-route53-0.0.1 (AmitLevy)
23:32:47 <dpwright> I have a single string representing the command-line arguments to a command I want to run
23:33:19 <dpwright> I want to split it up into an array of arguments, a bit like the shell usually does for you when you type them in
23:33:30 <dpwright> does anybody know of a library/function that already does this?
23:34:36 <dpwright> ie "argOne argTwo \"argThree is long\"" becomes ["argOne", "argTwo", "argThree is long"]
23:37:37 <slack1256> > words "argOne argTwo \"argThree is long\""
23:37:52 <lambdabot>   ["argOne","argTwo","\"argThree","is","long\""]
23:38:16 <dpwright> yeah, that's what I'm using at the moment :-(
23:38:56 <slack1256> > let phase = "argOne argTwo \"argThree is long\""
23:38:57 <lambdabot>   not an expression: `let phase = "argOne argTwo \"argThree is long\""'
23:39:03 <johnw> i've looked for such a function, but not found one yet
23:39:06 <slack1256> > phase = "argOne argTwo \"argThree is long\""
23:39:07 <lambdabot>   <hint>:1:7: parse error on input `='
23:39:13 <Ralith> dpwright: why do you want to do that, instead of letting the shell split it up?
23:39:16 <johnw> guess somebody just needs to write a POSIX shell argument parser
23:39:52 <dpwright> Ralith: I am writing a little RPC thing, so I'm receiving this data over TCP and then trying to run it with runInteractiveProcess
23:40:17 <johnw> dpwright: you can always just spawn bash
23:40:26 * slack1256 should go back to study instead of procastinate on #haskell
23:40:29 <johnw> like with Shelly: run_ "/bin/bash" ["-c", argString]
23:40:37 <dpwright> johnw: I am doing this in Windows :-(
23:40:43 <johnw> cmd.exe then
23:40:52 <dpwright> and I want the handles
23:40:55 <dpwright> I suppose that might work
23:41:14 <dpwright> doesn't that pop up a window on windows or something?
23:41:15 <Targen> Not very fun to use Bash to parse the arguments in "$(rm -rf ~)"
23:41:31 <Ralith> dpwright: why not runInteractiveCommand?
23:42:44 <dpwright> Ralith: Oh, actually, that might do the job!  So long as I don't find myself needing to mess about with the environment...
23:42:59 <dpwright> I'll give that a go, thanks
23:43:31 <Ralith> dpwright: note that this will also do things like expand environment variables, and is probably a huge gaping security hole if the connection isn't trusted.
23:44:36 <dpwright> Ralith: Yeah, I'm aware that from a security standpoint this is pretty dumb.  I'm using it so that the linux vm I run inside virtualbox can do things on the windows machine that's hosting it, so I'll probably be restricting it to just that ip or something
23:45:10 <Ralith> kk
23:45:33 <Ralith> then you are of course trusting everything on the VM
23:47:02 <dpwright> there is that... it's my personal workstation though.  If someone has access to that I'm probably already screwed :-D
23:47:29 <Ralith> ^^
23:49:47 <dpwright> Ralith: That worked perfectly -- and seemed to have access to environment variables which runInteractiveProcess didn't and which I wanted, so that's good -- thanks!
23:50:11 <Ralith> \o/
23:59:23 <dreixel> ocharles: I've been looking at your datatype again. is it only the Tree type that you're interested in?
