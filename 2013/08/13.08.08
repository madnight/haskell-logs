00:06:13 <scshunt> ok, I want to set up the dream environment for working in Haskell, ideally around vim. What am I missing?
00:06:42 <blackdog> scshunt: ghc-mod
00:06:46 <scshunt> suggestions can include: editor tools, things for keeping track of packages (especially making local packages available from each other), shell tricks, anything
00:07:00 <blackdog> ObDig: also, you're missing emacs.
00:07:06 <scshunt> unlikely
00:07:14 <blackdog> look deep into your heart :)
00:07:37 <blackdog> but for srs, check out ghc-mod. lots of neat IDE-like features - checking in the editor, completions, type info, that sort of thing.
00:07:49 <blackdog> works fine with emacs & vim, and probably some lesser editors.
00:08:20 <zvrba> the page mentions also sublime text
00:08:40 <blackdog> zvrba: yeah, was hoping carter would be around to get cranky with me about the dig :)
00:09:23 <zvrba> bah. i'm using eclipse :p
00:27:33 <levi> EclipseFP is pretty slick.
00:27:33 <scshunt> any other suggestions?
00:28:09 <earthy> visual haskell has bitrotted but was great
00:28:10 <levi> I think there's some syntastic integration with vim.
00:29:31 <maxiepoo> well if you want to get basic you can customize ghci with ~/.ghc/ghci.conf
00:35:43 <tdammers> scshunt: hasktags, hlint, cabal-dev, ack-grep, in case those weren't obvious already
00:40:03 <scshunt> what does ack-grep do that :vim doesn't?
00:45:21 <scshunt> what does ack-grep do that :vim doesn't?
01:07:10 <tdammers> scshunt: idk, never used :vim really
01:07:43 <tdammers> I prefer tools that work everywhere, not just inside one particular program
01:08:06 <tdammers> even if it's the program that accounts for about 50% of my waking hours
01:09:51 <scshunt> :vim accepts ** in paths, which has so far been the largest productivity gain when searching for me
01:28:31 <levi> ack-grep is really nice.
01:31:36 <hpaste> m_hyperbolic pasted “Error” at http://lpaste.net/91660
01:31:57 <m_hyperbolic> Would somebody take a look at this error? I don't understand what the problem is :)
01:34:43 <quchen> m_hyperbolic: The problem is that the next word after 'where' defines the indentation block.
01:35:10 <hpaste> quchen annotated “Error” with “Error (annotation)” at http://lpaste.net/91660#a91661
01:36:26 <m_hyperbolic> quchen: Ahh I see. Indentation. Thanks!
01:37:07 <quchen> m_hyperbolic: "Parse error" without any further comments is quite often indentation-related.
01:37:31 <quchen> If you had made a proper syntax error, like forgetting to close the a parenthesis, it would tell you it expects one.
01:37:49 <m_hyperbolic> Ok. That is good to know
01:37:58 <quchen> "parse error (possibly incorrect indentation or mismatched brackets)"
01:51:08 <moofy> o/
01:51:54 <tdammers> scshunt: zsh understands ** too
01:52:28 <moofy> zsh keeps throwing me by expecting flags to be escaped
01:53:00 <tdammers> what do you mean, flags escaped?
01:53:11 <tdammers> foo -b --bar --baz=quux works fine
01:53:40 <moofy> i can't remember what it was, might have been something in make
01:53:43 <moofy> but needed \
01:54:08 <tdammers> hmm
01:54:25 <tdammers> zsh is supposed to be scripting-compatible with bash, so I don't know...
01:54:47 <moofy> i remember trying it in bash to compare and it was fine
01:56:11 <vian> hello
01:56:31 <Jeanne-Kamikaze> yo
01:56:55 <vian> whenever i type "10 'mod 2" in ghci
01:57:19 <vian> it says Perhaps you intended to use -XTemplateHaskell
01:57:24 <vian> it doesn't work
01:57:27 <twanvl> you probably want "10 `mod` 2"
01:57:40 <vian> yeah, i mean that
01:57:49 <vian> 10 'mod' 2 doesn't work
01:57:55 <vian> mod 10 2 works
01:57:56 <Jeanne-Kamikaze> ` not '
01:58:05 <donri> vian: backtick not apostrophe
01:58:11 <vian> ah
01:58:13 <vian> i see
01:58:17 <vian> sorry
01:58:32 <vian> i thought it looked different
01:58:37 <vian> thank you
01:58:42 <donri> np
01:59:11 <vian> thanks Jeanne and donri, see you later
01:59:51 <donri> makes me wonder how you quote a name like a' with TH
02:00:23 <moofy> using grave accents in a language sits uneasily with me :/
02:00:31 <moofy> programming*
02:00:37 <moofy> S'fine in french.
02:02:21 <earthy> ` is the marker for the number of generic type arguments in the CLR
02:02:29 <earthy> that weirded me out at first
02:02:46 <moofy> yeah I still don't entirely get it
02:02:55 <moofy> but then I'm new to this all
02:03:07 * moofy is reading about lambda calculus
02:03:29 <donri> i tend to think haskell's syntax is batshit in general; the backticks are among the saner parst
02:03:32 <donri> parts
02:04:11 <moofy> Heh
02:04:36 <moofy> I have a background in typography and most programming languages have things that annoy me
02:04:42 <moofy> but that's weirdly one of the bigger ones.
02:04:59 <pharaun> what would you use instead of the ` ?
02:05:38 <moofy> something with less ambiguity, that someone has come in here mistaking a ` for a ' shows there's a problem there
02:05:39 <donri> pharaun: s-exps? :)
02:06:16 <moofy> I guess you could say the same for l and | sometimes too
02:06:18 <dpwright> couldn't that apply to almost anything, though?
02:06:19 <pharaun> donri: i can never make up my mind on what i think of s-exprs :)
02:06:21 <donri> moofy: python deprecated the backtick for such reasons i think
02:06:22 <dpwright> ; and : look pretty similar too
02:06:24 <adnap> Hey
02:06:26 <moofy> ish
02:06:41 <moofy> but accents and quotes get horribly handled on computers
02:06:45 <moofy> far more than ; and ;
02:06:49 <moofy> : even*
02:06:50 <dpwright> backticks read fairly naturally to me, probably because I do quite a lot of bash/shell stuff as well and you use them a lot there
02:06:53 <dpwright> and in ruby
02:06:54 <pharaun> some of it is font as well
02:07:09 <pharaun> for me ` and ' is very district
02:07:11 <adnap> Here, http://blog.sigfpe.com/2007/01/monads-hidden-behind-every-zipper.html, there is no fmap instance for Zipper. What is it? Is it fmap f (Zipper as bs) = Zipper (fmap f as) (fmap f bs) ?
02:07:13 <donri> pharaun: well they're extremely easy to manipulate without a complex parser. haskell is extremely hard to even syntax highlight usefully.
02:07:22 <pharaun> donri: fair enough
02:07:23 <moofy> after all most people still use ' and " instead of ‘’ and “” in text
02:07:34 <pharaun> donri: i've been hearing/reading about clojure and s-exprs
02:07:55 <donri> the more code i write the less i care about its presentation and the more i care about how i can manipulate it with automation
02:08:10 <moofy> that's important true
02:08:23 <moofy> but it's also important to think about how someone learns a language
02:08:43 <pharaun> i have not seriously used a language with s-exprs yet so i don't know how i will think about them
02:08:51 <moofy> if you can remove ambiguity that doesn't need to be there with no detriment to function then that's a good thin
02:08:52 <pharaun> but the idea sounds nice in theory, in reality, i don't know yet :)
02:08:58 <donri> pharaun: me either to be honest :)
02:09:21 <moofy> Hell that's what interface/experience design is all about and that's a whole industry
02:09:42 <donri> moofy: s-exprs are probably very beginner friendly
02:09:52 <pharaun> so far i've found haskell syntax to be alright enough, not always as readable as say python, but at same time i've found it to be expressive enough usually
02:09:57 <pharaun> i don't know how s-exprs will stack up yet
02:10:29 <donri> pharaun: yes, you can have much fun with haskell's syntax. i'm just not sure it's actually a good thing :p
02:10:37 <pharaun> hehe
02:10:44 <moofy> s-exprs? Not sure I've got that far yet :p
02:10:53 <donri> moofy: ever heard of the lisp family?
02:11:00 <moofy> I'm going through the 'learn you a haskell'
02:11:03 <moofy> I have
02:11:14 <donri> moofy: s-exp isn't something haskell uses/has
02:11:15 <moofy> I tried a tiny bit of racket but stopped out of lack of help
02:11:17 <CADD> moofy: <3 sexprs
02:11:36 <donri> moofy: it's what the lisp syntax is called
02:11:38 <moofy> everything in that expects you to have a tame professor to ask >_<
02:11:42 <moofy> I see
02:11:58 <CADD> donri: no, its a concept. they stand for "symbolic expressions"
02:11:59 <quchen> Problem with S-expressions are the parentheses. For the most part you can ignore them, but sometimes you need to take them into account explicitly. Compare (lambda (x y) (* x y)) with \x y -> x*y.
02:12:05 <donri> CADD: i know
02:12:23 <donri> quchen: i don't see the problem
02:12:27 <quchen> Indentation helps, but even then there's a lot of (unnecessary) parentheses noise.
02:12:46 <CADD> quchen: very true, but the ease of macros pays off for that in the long run. plus you can emulate that kind of syntax with macros anyway.. lol
02:12:48 <donri> quchen: the sexp form is super easy to manipulate with an editor, the haskell one not so much
02:12:53 <quchen> But I get that having them around all the time (opposed to introducing sugar for them) also has its benefits.
02:13:14 <moofy> Yeah that got to me
02:13:17 <CADD> quchen: oh yeah
02:13:30 <pharaun> arrow question. Is it possible to have a "takeWhile" version of arrow ?
02:13:31 <moofy> I'm sure you could make lisp look beautiful
02:13:32 <quchen> CADD: Don't get me wrong, I love the idea behind Lisp.
02:13:51 <donri> i'm not even sure i think macros are a big selling point for sexps
02:13:54 <CADD> quchen: i never claimed you didnt! :)
02:14:16 <moofy> I care too much about beauty in programming I think :/
02:14:32 <quchen> CADD: I never claimed you claimed I didn't!
02:14:36 <quchen> Anyway, OT. :-)
02:14:38 <moofy> this is what happens when you went to art school then try to learn how to program
02:15:02 <quchen> moofy: Beauty in programming is rarely about syntax.
02:15:12 <CADD> moofy: well, im glad you are here in #haskell.. i would consider it beautiful
02:15:17 <CADD> quchen: oh how true.
02:15:22 <CADD> quchen: look at python! lol
02:15:46 <moofy> Oh sure
02:16:12 <moofy> But when I see something that just appears to be manifestly an ugly design decision it annoys me
02:16:24 <moofy> git is pretty good at that...
02:16:45 <CADD> moofy: yeah, git vs darcs is an interesting convo
02:17:08 <CADD> moofy: its funny when people raise their nose to darcs, and mutter something about it being written in haskell
02:17:19 <quchen> sortBy (comparing length <> comparing)  <--  I consider this to reflect a great deal of beauty, but not on first sight for example. The code isn't beautiful at all.
02:17:24 <CADD> moofy: but then i like to remind them it was origionally implemented in c++
02:17:27 <moofy> haskell gets a bad rap
02:17:36 <CADD> moofy: ugh, does it ever..
02:17:48 <CADD> moofy: but its getting better every day
02:17:58 <moofy> Being pretty much self taught i think I managed to avoid a lot of the drama
02:18:18 <moofy> thogh I imagine that means I make lots of horrific mistakes that some rigour would have crushed
02:18:57 <quchen> At least Haskell is hated for its awesomeness-induced incomprehensibility and not that it is inherently bad. It's therefore the best even among the hated languages. :-P
02:19:06 <moofy> yeah
02:19:10 <moofy> Monads
02:19:15 <moofy> I have no idea what a monad is.
02:19:19 <donri> the content addressable data store of git is sort of beautiful
02:19:20 <CADD> moofy: exactly, me too. but i still have friends that look at me weird about the haskell thing
02:19:20 <quchen> And you don't need to.
02:19:27 <donri> it's just not very good for version control
02:19:29 <moofy> I think I'd like a pet snake named monad though
02:19:45 <quchen> This is my dog Kleisli :-D
02:19:52 <CADD> moofy: and think i "evangelize" whenever i tell them that haskell has a great solution to the problem that they are solving that was solved long ago with haskell
02:20:06 <quchen> Blub paradox …
02:20:07 <CADD> quchen: nice! XD
02:20:12 <CADD> quchen: pretty much
02:20:14 <quchen> CADD: I just made that up though.
02:20:25 <quchen> I should get a dog and correct that
02:20:29 <CADD> quchen: oh. now my heart is broken.
02:20:35 <CADD> quchen: but you also gave me a good idea
02:20:42 <CADD> moofy: monads are not that hard
02:20:48 <moofy> Depends on the problem really
02:20:59 <CADD> moofy: really all they are is a data struct with two "methods", bind and return
02:21:00 <adnap> Well?
02:21:06 <moofy> I just found it after trying to do things with java and finding it horrible
02:21:53 <Work_jack> CADD: Obeying certain laws of course
02:22:21 <CADD> Work_jack: :)
02:22:39 <donri> and function is a monad but not sure you'd call it a data structure
02:22:59 <moofy> It does require a big rethink of how you address problems though
02:23:01 <CADD> donri: you are totally right. but to a newbie it is a good analogy
02:23:08 <donri> yeah nitpicking
02:23:14 <tdammers> CADD: "all they are is a data struct with two methods" is actually the best explanation IMO
02:23:14 <moofy> I keep having to go to khan academy and remember things I forgot from school
02:23:19 * Work_jack apologizes for nitpicking 
02:23:19 <CADD> donri: hey, thats me too. mr pedantic
02:23:20 <moofy> to make haskell work
02:23:27 <CADD> tdammers: even better!
02:23:28 <quchen> I'm not sure what exactly a data structure is, so I can't say whether a function is one or not.
02:23:42 <jtanguy> is there a way to define the set of injective functions?
02:23:47 <CADD> Work_jack:  no need. im mr. pedantic as well
02:23:54 <donri> me either. but it's opaque in haskell anyway
02:24:08 <CADD> donri: yeah, it kind of is.
02:24:12 <tdammers> quchen: Monads in Haskell, not Monads in CT
02:24:18 <tdammers> Monad is a typeclass
02:24:31 <tdammers> instances of Monad are data types
02:24:41 <CADD> moofy: if you want the best "monad tutorial" on the net. (imo the only one you should read)
02:24:44 <tdammers> hence, "data structure"
02:24:58 <donri> technically instances are type constructors ;)
02:24:59 <CADD> @@ moofy @google typeclassopedia
02:25:00 <lambdabot>  moofy
02:25:00 <lambdabot>  http://www.haskell.org/haskellwiki/Typeclassopedia
02:25:00 <lambdabot>  Title: Typeclassopedia - HaskellWiki
02:25:11 <donri> monads are kind * -> *
02:25:20 <quchen> The best monad tutorial on the net is the one where you write your own code.
02:25:21 <CADD> ooo.. i like lambdabot 5.0.. so snappy!
02:25:22 <tdammers> yeah, ok true
02:25:31 <tdammers> the point is
02:25:33 <CADD> quchen: oh too true
02:25:54 <quchen> You can read ">>= is like a pipe" 10000 times without understanding it.
02:25:59 <tdammers> approaching the Monad concept from the type signatures up, like you can do with pretty much every other Haskell concept, works pretty well
02:26:36 <tdammers> the type of return is (Monad m) => a -> m a -- read the type signature, and figure out what that means
02:27:13 <tdammers> return converts a value into a value of the monadic type m, parametrized by the original type
02:27:46 <tdammers> and that's really all you can say about `return` without going into the specifics of any particular monad I'd think
02:27:51 <quchen> tdammers: That didn't work very well for >>= when I tried. "Alright I get it but why would that thing be useful and why does it have to have such a complicated type" - dark times! :-D
02:28:03 <donri> i think for me the source of confusion was a lack of fluency with type classes (i understood them but forgot to consider their implications) and do notation
02:28:10 <tdammers> quchen: idk, letting go of the metaphors and just focusing on the types helped me a lot
02:28:33 <moofy> eep
02:28:35 <moofy> that link
02:28:38 <moofy> first diagram
02:28:48 <donri> learning to recognize that do desugars to >>= *and* that >>= is a different function for every monad!
02:28:59 <CADD> moofy: lol. im not expecting you to get it first go. i dont think many people do.
02:29:06 <quchen> moofy: Haha, use an adblocker on that or something :P
02:29:08 <mr-> Learning how do notation is desugared did the trick for me too :-)
02:29:15 <CADD> moofy: just save it. come back to it time and time again. eventually it will make sense
02:29:42 <CADD> donri: yup
02:30:03 <CADD> donri: do notation is nice, but limiting
02:30:10 <CADD> donri: and obscuring
02:30:14 <quchen> moofy: By far the most important ones in that diagram are Monoid, Functor, Monad when you start Haskell. The rest is just "also there".
02:30:21 <tdammers> IMO, the problem is that usually the Monad concept is introduced using one of the usual monads - Maybe, List, State, etc.
02:30:24 <donri> similarly monad transformers. "how the heck does (lift . lift) work" well those lift functions are actually two different functions!
02:30:38 <tdammers> and then you form your intuitions based on the first of these instances that you understand
02:30:44 <tdammers> and the other ones don't make any sense at all
02:31:05 <moofy> Hmm. I think I need more mathematical grounding
02:31:35 <CADD> moofy: http://www.amazon.com/Book-Abstract-Algebra-Edition-Mathematics/dp/0486474178/ref=sr_1_2?ie=UTF8&qid=1375163696&sr=8-2&keywords=abstract+algebra
02:31:40 <tdammers> but if you let go of the concrete instances, and just reason in terms of the abstract types, a better intuition can form
02:31:45 <CADD> moofy: my absolute favorite intro to higher math
02:31:56 <CADD> moofy: but you really dont
02:32:12 <moofy> I think I have a problem with my basic understanding of maths sometimes
02:32:15 <CADD> moofy: you can understand what a monad is without understanding what a semigroupoid is..
02:32:16 <quchen> moofy: You absolutely need no training beyond what you would need in other languages to understand all of the things in the diagram.
02:32:25 <moofy> never having studied compsci or maths at university
02:32:37 <moofy> okay
02:32:39 <quchen> moofy: You also don't need to study compsci for Haskell.
02:32:53 <donri> tdammers: not sure about that; it's hard to think abstractly about something novel. i think the best thing is to teach using concrete instances but show how it fits together in the abstraction
02:33:09 <tdammers> donri: yeah, probably
02:33:31 <CADD> donri: couldnt agree more. especially for beginners
02:33:42 <quchen> moofy: I never heard any word presented in that diagram in university, I'm not a compsci student. To use a hammer you don't need to know how to make one. Same thing with CT and monads.
02:34:54 <Maior> er thanks to all above
02:34:58 <Maior> I think I get monads now
02:35:04 <adnap> Hey
02:35:08 <Maior> typeclassopedia *massively useful*
02:35:17 <adnap> I don't understand bind' here: blog.sigfpe.com/2007/01/monads-hidden-behind-every-zipper.html
02:35:51 <Maior> particularly making me realise that "the IO monad is a bit magical" is because of the IO, not because it's a monad
02:36:42 <CADD> Maior: hehe
02:36:45 <moofy> I wish I could use haskell more easily in some of the other things i'm interested in
02:36:53 <quchen> adnap: What is the context? How did you encounter the problem? What do you expect the code presented to do? What have you tried? -- Telling us about these makes it way easier to understand your problem, and how to answer it.
02:37:01 <Maior> now I just need to understand Yesod
02:37:19 <CADD> Maior: dont, use happstack. i tried understanding yesod
02:37:21 <blackdog> moofy: what are you interested in?
02:37:36 <blackdog> you can use haskell to great effect for some surprisingly grungy stuff.
02:37:41 <moofy> At the moment? Mostly using Processing and openFrameworks
02:37:42 <CADD> Maior: happstack just feels like haskell + webserver. yesod is a whole new language
02:37:42 * hackagebot Capabilities 0.1.0.0 - Separate and contain effects of IO monad.  http://hackage.haskell.org/package/Capabilities-0.1.0.0 (BaldurBlondal)
02:38:04 <Maior> CADD: noted, cheers
02:38:25 <tdammers> yeah, yesod is quite stubborn and opaque occasionally
02:38:33 <adnap> quchen: How is "bind' f x = let Zipper a b = fmap f x in foldl1 plus (stagger left' b ++ stagger1 right' a)" a valid expression? "a" and "b" aren't defined
02:38:33 <CADD> Maior: check out acid-state.. its AMAZING!
02:38:33 <blackdog> moofy: heh, if your problem statement is "coding in Processing and C++" you're right, haskell might not help that much
02:38:36 <tdammers> still, not bad, and quite impressive actually
02:39:09 <Maior> CADD: it's been a few years since I did much functional (lots of Standard ML, plus various bits of lambda calculus and church stuff) and I've been using Django for the last year or two lots, but want to be implementing a lot of core logic in Haskell because ye gods I miss types
02:39:28 <quchen> adnap: The "let" defines `a` and `b` by pattern matching. The result of `fmap f x` is matched against `Zipper a b`, and that's where they get their values from.
02:39:31 <moofy> well, I guess that's unfair
02:39:32 <YoungFrog> gnus
02:39:34 <YoungFrog> err
02:39:36 <YoungFrog> sorry
02:39:39 <quchen> > let Just x = Just 3 in x -- adnap
02:39:41 <lambdabot>   3
02:39:55 <moofy> making visuals quickly, and that happens to be mostly using java in processing and c++ in openframeworks
02:40:06 <adnap> quchen: But the "in" part of "let" mentions "a" and "b"
02:40:13 <moofy> because they make it easy(er) to play with things and have a result
02:40:20 <CADD> Maior: i can completely understand that.. once you go types, you never go back.. :)
02:40:23 <moofy> I wouldn't know where to start making visuals with haskell
02:40:24 <adnap> quchen: Oh, I see
02:40:50 <CADD> Maior: i have very strong opinions about python. most of them are not good.. :)
02:41:01 <Maior> CADD: heh
02:41:04 <CADD> Maior: but these days, you cant avoid it.. *sobs*
02:41:24 <adnap> > let [3,x] = map (+2) [1,8] in x
02:41:26 <lambdabot>   10
02:41:43 <adnap> > let [_,x] = map (+2) [undefined,8] in x
02:41:44 <lambdabot>   10
02:41:48 <quchen> > let (a,b) = fmap (*7) (1,2) in show a ++ ":" ++ show b -- adnap: this is more similar to the example you posted. Again, a and b are defined in the "let" part and can be used in there "in" section.
02:41:49 <lambdabot>   "1:14"
02:41:54 <adnap> > let [3,x] = map (+2) [42,8] in x
02:41:55 <lambdabot>   *Exception: <interactive>:3:5-27: Irrefutable pattern failed for pattern [3...
02:42:23 <skilpat> Anyone know if there's a way to debug the way instance resolution is handled in GHC? I'm getting a "no instance for ..." error and I can't understand what the instance backtrace is.
02:42:59 <quchen> adnap: map (+2) [42,8] = [50,8], which does not match [3,x], hence pattern match failure.
02:43:08 <quchen> > let [_,x] = map (+2) [42,8] in x
02:43:10 <lambdabot>   10
02:43:25 <adnap> > let x' = let [x] = fmap (+2) [5] in x in 'x
02:43:26 <lambdabot>   Syntax error on 'x
02:43:26 <lambdabot>  Perhaps you intended to use -XTemplateHaskell
02:43:31 <adnap> > let x' = let [x] = fmap (+2) [5] in x in x'
02:43:33 <lambdabot>   7
02:44:21 <CADD> skilpat: when it says "no instance for X Y", that means that X does not have the ability fo process Y. its like attempting to add together two strings.
02:44:33 <CADD> @@ skilpat @run (+) "lol" "nope"
02:44:34 <lambdabot>  skilpat   No instance for (GHC.Num.Num [GHC.Types.Char])
02:44:34 <lambdabot>    arising from a use of `GH...
02:45:08 <quchen> "No instance Show" is a special case, which means you forgot a parameter for a function. :>
02:45:19 <quchen> > (+2)
02:45:20 <lambdabot>   <Integer -> Integer>
02:45:31 <quchen> Argh, Lambdabot, you are too powerful
02:45:35 <CADD> :)
02:46:09 <skilpat> Right, I know what the error means, but I don't know *why* it's searching for this particular instance and not a different one. I've got a lot of overlap and undecidable instances and whatnot.
02:46:32 <CADD> skilpat: ooh. well at that point you should post example code
02:46:37 <skilpat> So I'm wondering whether there's a way to see the instance search backtrace that results in this instance.
02:46:46 <adnap> @let stagger f [] = []
02:46:48 <lambdabot>  Defined.
02:46:49 <CADD> skilpat: ghci has a nice debugger
02:46:56 <adnap> @let stagger f (x:xs) = x : map f (stagger f xs)
02:46:57 <lambdabot>  Defined.
02:47:04 <adnap> :t stagger
02:47:05 <lambdabot> (a -> a) -> [a] -> [a]
02:47:19 <adnap> > stagger (+2) [1..5]
02:47:23 <lambdabot>   mueval-core: Time limit exceeded
02:47:45 <moofy> That's a point actually
02:48:22 <begin007> Hello. How does one convert a LocalTime into a CalendarTime? I'm trying to convert a LocalTime value to a string
02:49:42 <adnap> stagger (+2) (1:[2,3,4,5]) =  = 1 : map (+2) (stagger (+2) (2:[3,4,5])) = 1 : map (+2) (2 : map (+2) (stagger (+2) [3,4,5]) ...
02:50:27 <elliott> stagger = foldr (\x xs -> x : map f xs) []
02:50:39 <elliott> *stagger f
02:50:46 <donri> begin007: you should be able to formatTime a LocalTime directly
02:50:54 <elliott> > let stagger f = foldr (\x -> (x :) . map f) [] in stagger (+2) [1..5]
02:50:55 <lambdabot>   [1,4,7,10,13]
02:51:39 <begin007> donri: Thank you!
02:53:42 <adnap> > let stagger' f = scan r (\x -> (x :) . map f) []
02:53:43 <lambdabot>   not an expression: `let stagger' f = scan r (\x -> (x :) . map f) []'
02:53:54 <adnap> > let stagger' f = scan r (\x -> (x :) . map f) [] in stagger' (+2) [1..5]
02:53:56 <lambdabot>   Not in scope: `scan'
02:53:56 <lambdabot>  Perhaps you meant one of these:
02:53:56 <lambdabot>    `scanl' (imported ...
02:54:02 <adnap> > let stagger' f = scanr (\x -> (x :) . map f) [] in stagger' (+2) [1..5]
02:54:03 <lambdabot>   [[1,4,7,10,13],[2,5,8,11],[3,6,9],[4,7],[5],[]]
02:54:04 <moofy> well was nice chatting. bye
02:56:00 <adnap> stagger f [x,y,z] = [x, f y, (f . f) z]
03:01:41 <quchen> > let stagger f = zipWith ($) (iterate (.f) id) in stagger (+1) [0,0,0,0,0] -- Another solution, adnap
03:01:42 <lambdabot>   [0,1,2,3,4]
03:01:49 <adnap> In "bind' f x = let Zipper a b = fmap f x in foldl1 plus (stagger left' b ++ stagger1 right' a)", what is the type of "bind'"?
03:07:34 <adnap> I think "bind' :: (a -> Zipper b) -> Zipper a -> Zipper b"
03:32:13 <dobblego> chrisdone: ping
03:52:16 <tonyday567> :k (*)
03:52:17 <lambdabot> Not in scope: type constructor or class `*'
03:54:07 <quchen> tonyday567: (*) is a function, and it has a type. Try  :t (*)
03:54:41 <quchen> On the other hand, generic kinds are also denoted "*". But then you're asking the kind of a kind, which is similar to asking the type of a type variable.
03:54:43 <tonyday567> I was thinking about * as in kind, and whether it has a kind
03:55:40 <tonyday567> ok so dont do that
03:55:42 <quchen> expressions have types, types have kinds, kinds have … something I don't remember the name of and that isn't in Haskell. :-)
03:55:57 <hpc> kinds have sorts
03:56:06 <quchen> I think I heard that Agda goes arbitrarily high in this ........and there is your answer :-)
03:56:17 <hpc> but at that point you are better served by saying "the level above kinds is Set3"
03:56:38 <hpc> or even "the level above Set2 is Set3"
03:56:55 <zRecursive> How to understand "types have kinds" ?
03:57:11 <Work_jack> In the same way you understand "values of types"
03:57:15 <Work_jack> *have types
03:57:25 <tonyday567> :k (->)
03:57:25 <lambdabot> * -> * -> *
03:57:41 <quchen> hpc: I think at some point the English synonyms for "type" are exhausted so thet SetX notation makes sense :-D
03:57:45 <tonyday567> but the -> in that isnt :t ->
03:58:19 <hpc> tonyday567: it's (->) in the same way that multiplication is (*)
03:58:46 <tonyday567> yeah, but what does the -> in * -> * mean?
03:59:06 <zRecursive> Work_jack: values can be grouped by its types, then types can be grouped by kinds ?
04:00:25 <Work_jack> I'm not sure what you mean by "grouped", but you can say that 'a', 'b', 'c' inhabit Char: in the same way IO and [] both inhabit * → *
04:00:58 <hpc> tonyday567: that's a different (->) from "the type of value-level functions"
04:01:13 <hpc> specifically, it's "the kind of type-level functions"
04:01:47 <tonyday567> yeah, ok, so * -> * should be read syntactically,, theres * and then there's * -> *
04:02:07 <hpc> and then * is just a wart of history
04:02:11 <hpc> (imo)
04:02:39 <hpc> things are slowly improving though - there used to be kinds of ?, ??, #, and (#)
04:02:45 <Work_jack> * is called a billion things, Set, U, Type, ...
04:02:48 <hpc> and i think they are all gone now
04:03:05 <hpc> :k Show -- and we have new "normal" names for new kinds
04:03:06 <lambdabot> * -> Constraint
04:03:08 <quchen> tonyday567: Expressions have types, and types classify the domain of what the expression does. For example, a function of the type "a -> a" is something that maps values of type a to values of type a.   Now kinds:  Kinds classify "type expressions". For example, (* -> *) stands for a type-level function that maps anything of kind (*) to something of type (*). For example Maybe has kind (* -> *), because it maps a type (e.g. Int) to a new type (Maybe Int).
04:03:14 <elliott> hpc: they exist
04:03:17 <elliott> just different names
04:03:34 <hpc> :k (=>) -- this should be :: Constraint -> *, btw
04:03:35 <lambdabot> parse error on input `=>'
04:03:37 <zRecursive> Work_jack: "IO and [] both inhabit * → *"  same as "IO and []" are constructors ?
04:03:41 <hpc> :(
04:03:42 * elliott finds "expressions/values first and then types to classify values" upsetting
04:04:11 <elliott> much prefer types defining what a value is (giving rise to meaning), and then kinds similarly defining what types are. but anyway.
04:04:36 <Work_jack> zRecursive: IO and [] are "type constructors"
04:04:44 <quchen> elliott: I don't quite understand that.
04:04:52 <Work_jack> You can construct (IO Int) by applying IO to the type Int
04:05:02 <zRecursive> yeah
04:05:26 <zRecursive> so is same as * -> *
04:05:42 <tonyday567> quchen: thx,, -> means the common sense of mapping
04:05:51 <Work_jack> They have the same kind, yes
04:06:00 <quchen> elliott: Is what you mean that types give a meaning to an otherwise meaningless expression? Like giving a random bit sequence a definitive interpretation as an Int?
04:06:02 <zRecursive> ok, thx
04:07:02 <elliott> quchen: I mean I don't think it makes sense (or rather it's not my preferred perspective) to say that we have this massive set of all values -- "hello", 3, 3.4, getLine -- and then we say types classify them by dividing them up.
04:07:16 <elliott> quchen: instead I think we start with types, and they define what a value is -- a value is something that has a type, so to speak.
04:07:37 <elliott> the fact that 3 isn't actually a value unless you know its type speaks to the fact that this is more natural for Haskell, I think: 3::Int is not 3::Rational etc.
04:08:10 <elliott> (IOW, the structure of values is inherently defined by types. we're not just bolting types on to an underlying untyped language, types are what we start with, and the notion of a value without its type is meaningless.)
04:08:32 <quchen> So you see a type as a necessary condition for values to exist here?
04:08:54 <elliott> sure. in Haskell.
04:09:22 <quchen> Makes sense. I'll try to incorporate that next time.
04:09:33 <elliott> similarly e.g. hole-driven development supports this perspective. you start with a type and then think about the value. (so, I'm also not a huge fan of type inference, because you can argue the information is flowing in the wrong direction)
04:09:37 <quchen> What about outside of Haskell? Why did you mention that specifically?
04:09:41 <elliott> this is all arguably more a pet peeve than anything though :)
04:10:08 <elliott> quchen: well, there are languages that are closer to bolting types on to an untyped language, like incremental type system kinda stuff, I think Typed Racket is an example of this?
04:10:34 <quchen> elliott: Ah, I thought you meant in the mathematical sense.
04:11:10 <quchen> My concern with the "types are required for values" is that then kinds are required for types and so on.
04:11:28 <quchen> So I thought you mean that.
04:11:32 <hpc> quchen: at some point, everything becomes part of a single SetX
04:11:49 <hpc> for haskell, there are no kind functions or silliness like that, so everything is in Sort *
04:12:01 <zRecursive> Is kinds same as Class's Class in OOP world ?
04:12:18 <hpc> zRecursive: not even remotely
04:12:44 <hpc> zRecursive: for one, Class extends Object
04:12:50 <zRecursive> it is called meta-class ?
04:13:17 <hpc> and for second, OOP is really not at all similar to HM types
04:13:37 <zRecursive> sure
04:13:47 <Work_jack> zRecursive: I recommend that you think about kinds later (until you don't need to find analogies to OOP anymore), kinds are not that important anyway
04:13:54 <quchen> I don't think Haskell has much that resembles classes from OOP. You can have an hour-long discussion whether Haskell is OOP in some way, but it's boring and in the best case possible and unidiomatic.
04:14:10 <tonyday567> what am i missing if i think of a type as a set?
04:14:11 <zRecursive> Work_jack: ok
04:14:36 <Work_jack> tonyday567: Read the book on Homotopy Type Theory on the difference
04:14:43 <quchen> Work_jack: Excellent advice.
04:14:50 <elliott> tonyday567: maybe not much.
04:14:50 <tonyday567> kk
04:14:54 <elliott> depends on how you think of them as sets.
04:14:56 <quchen> Just read a research-level 500 page book and you'll understand. :s
04:15:12 <Work_jack> He doesn't need to read all of it obviously
04:15:18 <elliott> the HoTT book is intended to be accessible to people who don't know type or homotopy theory. but I agree it might not help much.
04:15:21 <Work_jack> there is an /introduction/ to type theory in the beginning
04:15:50 <tonyday567> i suppose in conjunction with the concept of mapping, so * -> * seems like a mapping from one set to another
04:16:30 <tonyday567> and a set defines all possible values
04:16:34 <quchen> I hope it's right to say that (* -> *) are arrows in Hask?
04:16:46 <quchen> With * being the objects
04:17:11 <quchen> So (* -> *) are mappings from types to types in the categorical sense
04:17:12 <Work_jack> tonyday567: http://homotopytypetheory.org/book/ read "1.1 Type theory versus set theory", it is not difficult to comprehend at all
04:17:29 <johnw> quchen: I don't think that's right
04:17:56 <johnw> the arrows in Hask are functions, which map objects (types, inhabited by values) to other objects.  A kind (* -> *) corresponds more to a functor, if it obeys the laws
04:17:57 <quchen> johnw: Can you correct it? (Is it even correctable?)
04:18:22 <johnw> in that it maps a type to another type, albeit both types are in the same category
04:18:27 <quchen> johnw: Aaah, right. Objects in Hask are `a`, morphisms are `a -> b`.
04:18:36 <chrisdone> dobblego: poke
04:18:36 <quchen> I was one level too high in the hierarchy there.
04:20:25 <dobblego> chrisdone: hey, I see your article on writing an IRC server and I am trying to design a beginner exercise for a network server for a two-player game but I am unsure what might be best for a beginner. I thought maybe you might have an opinion on the matter e.g. just have a server that spawns a thread for each connecting client, then create games between them, or some other model
04:22:44 * hackagebot LibZip 0.11.1 - Bindings to libzip, a library for manipulating zip archives.  http://hackage.haskell.org/package/LibZip-0.11.1 (SergeyAstanin)
04:24:09 <adnap> elliott: http://ideone.com/XUKIsd
04:27:08 <chrisdone> dobblego: no specific opinion comes to my mind. i suppose there's at least a choice between "make the threads pure" and have a single pure state, versus having them all be e.g. in STM. depends on the nature of the game, but i'm not qualified to be asked such questions =)
04:27:39 <dobblego> chrisdone: yeah, I thought of that and have decided to go with MVar for the first attempt — cheers
04:39:46 <allsystemsarego> where can I find a good Arrow tutorial, the one on the Haskell wiki is a non-starter
04:40:16 <chrisdone> the one on haskell.org is the one i read
04:40:23 <chrisdone> http://www.haskell.org/arrows/
04:40:53 <chrisdone> hm, maybe it wasn't that
04:41:03 <chrisdone> there wasn't anything to learn about arrows really, they don't do much
04:41:13 <allsystemsarego> I'll start reading this one, thanks
04:42:27 <allsystemsarego> well, I'm just trying to wrap my head around a simple snippet of code which contains *** that's all
04:42:42 <chrisdone> ahh
04:43:04 <dobblego> allsystemsarego: is it using the (->) arrow?
04:43:04 <chrisdone> well in general i'd estimate you'll only ever use arrows for tuple manipulation
04:43:17 <chrisdone> what's the code?
04:43:41 <merijn> allsystemsarego: The wikibook on Arrows is nice
04:43:42 <allsystemsarego> give me a minute I'll put it on lpaste
04:44:07 <merijn> allsystemsarego: https://en.wikibooks.org/wiki/Haskell/Understanding_arrows
04:45:00 <hpaste> allsystemsarego pasted “odd vs even” at http://lpaste.net/91664
04:45:28 <allsystemsarego> merijn, thanks I'll check that too
04:45:54 <allsystemsarego> chrisbuchholz, dobblego ^^ lpaste
04:46:14 <allsystemsarego> sorry chrisdone ^^
04:46:15 <dobblego> allsystemsarego: yeah that is the (->) arrow instance
04:46:41 <merijn> allsystemsarego: "(f *** g) (x,y)" -> "(f x, g y)"
04:46:49 <allsystemsarego> aaah
04:46:50 <dobblego> so in this context, (***) has this type (a -> b) -> (c -> d) -> (a, c) -> (b, d)
04:47:15 <chrisdone> :t (***)
04:47:18 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
04:47:44 <chrisdone> Arrow a => a b c,  you replace a with (->) everywhere and you get: a -> b
04:47:55 <chrisdone> er, b -> c =)
04:47:58 <allsystemsarego> it's starting to make sense now
04:52:00 <quchen> :t (***) `asAppliedTo` (undefined :: a -> b)
04:52:02 <lambdabot> (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
04:59:12 <adnap> Which is better (f or f')? http://ideone.com/hEGDWS
05:01:38 <Taneb> I'd probably be a better programmer if I found writing some code that puts a square on a screen that you can move back and forth less fulfilling :/
05:02:38 <johnw> never quite got over Logo, eh? :)
05:03:59 <quchen> adnap: The one that's better readable.
05:04:41 <quchen> adnap: By the way, you can write `take (lengh xs) xs'` better as `zipWith const xs' xs`. It's more lazy and only traverses the list once.
05:05:08 <adnap> quchen: Well, f requires 22 LOC of f' requires 2
05:05:24 <adnap> *and f'
05:06:04 <Taneb> johnw, I'm translating ocharles' netwire introduction to use free-game
05:06:16 <quchen> The one-liner 139 characters long. If your function is longer than 80-100, it's a pretty safe bet that you should break it up in multiple lines.
05:07:14 <johnw> quchen: you mean, if you can't tweet each line of code, it's too long?
05:07:36 <adnap> quchen: It's just a single foldr
05:08:01 <quchen> johnw: Yes. Although that line is tweetable (139 chars) and still to long. Tweetability is therefore necessary, but not sufficient.
05:08:34 <merijn> Taneb: Well, once graphics programming is less of a sucky task, it will be
05:08:48 <merijn> Taneb: Right not it's fullfilling because doing graphics is *hard* and it sucks
05:08:51 <Taneb> merijn, :D
05:08:53 <quchen> adnap: Looking at that line, I have no idea what it does, and it would take me some effort to find out. Readability matters, there's no need to cram everything in one line.
05:08:57 <merijn> @quote from.first.principles
05:08:57 <lambdabot> No quotes match.
05:09:04 <merijn> @quote colored.dots
05:09:04 <lambdabot> No quotes match. Just what do you think you're doing Dave?
05:09:06 <merijn> awww
05:09:14 <adnap> quchen: Do you know what f does?
05:09:25 <Taneb> merijn, I can literally press the left and right keys to make this square go back and forth and just giggle to myself going "I made this"
05:09:30 <quchen> adnap: No idea.
05:09:43 <adnap> quchen: So, you don't know what f or f' does
05:10:04 <merijn> Lambdabot seems to have lost my quote, I'll just readd it
05:10:17 <merijn> @remember Brend I have created a revolutionary AI from first principles! Also, can anyone tell me how to draw coloured dots on the screen?
05:10:17 <lambdabot> Done.
05:10:26 <quchen> No. But if I had to find out, I'd rather not have a 139 char expression without descriptive names to walk through.
05:10:58 <merijn> That's how I feel all the time
05:11:30 <quchen> merijn: You want to draw coloured dots all the time?
05:11:42 <merijn> Taneb: I actually started working on a "less sucky UI" library, but then I ran into a bug with reactive-banana so I had to shelve that until Apfelmus gets around to fixing it
05:12:05 <quchen> Ah, that's a shame. I was looking forward to that lib.
05:12:06 <adnap> quchen: f is not a 139 character expression, but f' is, yet you don't understand f either
05:12:47 <quchen> "f" doesn't explain anything to me. All I can see is that "f" somehow applies a zipper's contents to itself in some way.
05:13:07 <quchen> f' is just noise.
05:14:18 <merijn> quchen: Well, tell Apfelmus to fix his library, I looked into doing it myself, but the reactive-banana internals scare me like a little kid
05:14:35 <merijn> (like a little kid seeing something scary, not like me seeing a little kid)
05:14:38 <merijn> Although...
05:14:46 <quchen> HEINRICH get your shit together!    <- I did what I could :-P
05:15:09 <adnap> f, f' :: [(a, a -> [a] -> b)] -> [b]. Both functions take pair element's (a) function (a -> [a] -> b) and apply it to the element (a) and all the other elements ([a]) excluding the current element (a). The results are collected ([b])
05:15:27 <adnap> *paired
05:15:35 <chrisdone> kids  are scary, they're dangerous people. not afraid of being wrong and are learning machiines, like some lovecraftian nightmare aliens. don't trust kids
05:16:04 <tdammers> *my* kids aren't scary
05:16:06 <tdammers> :P
05:16:14 <chrisdone> they take over society and turn over everything we know. kids are the enemy!
05:16:41 <tdammers> by the time they take over, I'll be glad to not be in charge of the mess I left anymore
05:16:56 <tdammers> enemy? more like janitor.
05:17:06 <quchen> adnap: The point is that you should be able to tell from the code what the function does. Comments can also help.
05:17:18 <adnap> quchen: I can. You can't I guess
05:17:25 <quchen> I can only estimate that it would take me ages to decypher that source.
05:17:46 <quchen> And it will take you the same time in 2 weeks when you've forgotten how you came up with it.
05:17:56 <adnap> quchen: I guess it would take you ages to decipher http://blog.sigfpe.com/2007/01/monads-hidden-behind-every-zipper.html too, since mose of the source comes from there
05:18:02 <adnap> *most
05:18:17 <quchen> No, that code is well-written.
05:18:26 <quchen> It also features explanations.
05:18:42 <adnap> Well, check them out. The first 17 lines are from the blog post
05:19:19 <quchen> Those lines are readable.
05:19:22 <quchen> f and f' aren't.
05:19:31 <quchen> Quick, what does `g f z xs = foldr (\x g a = g (f a x)) id xs z` do?
05:19:36 <quchen> Same problem.
05:20:01 <quchen> Eh, make that `i f z xs = foldr (\x g a = g (f a x)) id xs z`, which fixes the obvious type error.
05:20:25 <supki> quchen: what about the obvious syntax error? :]
05:20:29 <quchen> God dammit. `g f z xs = foldr (\x g a -> g (f a x)) id xs z`
05:20:35 <supki> there
05:20:35 <quchen> Stop making me spam! :_D
05:20:50 <quchen> supki: I had to refactor the "where" in to make it a one-liner.
05:21:01 <quchen> That's where the = sneaked in.
05:24:47 <mapreduce> @tell tabemann I don't really know that book but you might like the currently pre-release Functional Programming in Scala - http://www.manning.com/bjarnason/
05:24:47 <lambdabot> Consider it noted.
05:25:17 <JAVACODER> wow more than 1000 users !
05:29:17 <adnap> quchen: Will you try to understand if I explain f to you?
05:30:11 <quchen> adnap: That's not my point. Code style should always so that I can find out how something works just by looking at the code. I believe you when you say I could understand it with your explanations, but really those explanations should be in the code, and not on IRC.
05:30:57 <adnap> quchen: Well, do you mind if I just explain on IRC?
05:31:00 <merijn> quchen: Alternatively, if you can't get Heinrich to fix reactive-banana you could convince mm_freak to add proper FRP event support to netwire :p
05:32:05 <quchen> merijn: If I keep swearing here the mods will be angry, so I can't ask mm_freak as well now. Wait until tomorrow or something. :>
05:32:38 <quchen> adnap: Your question was which version is better. My answer is that f is better than f', but still not good.
05:33:29 <adnap> quchen: Can I find the Comonad instance of Zipper on Hackage somewhere?
05:34:01 <quchen> Comonads are on Hackage, I don't think there's a predefined (basic) zipper based on them.
05:34:20 <quchen> comonad is by edwardk, who has his own zipper package, which is somewhat complex.
05:34:35 <quchen> The comonad part of the code is fine.
05:36:13 <Taneb> Aaaah why do less things have a MonadFix instance than what would be ideal
05:39:31 <hpaste> quchen pasted “foldo/foldr, readable vs unreadable.” at http://lpaste.net/91665
05:39:37 <quchen> adnap: ^
05:41:28 <theredlol> Hello :)
05:41:55 <theredlol> I was wondering what the prefered way for printing UTF-8 characters is
05:42:24 <theredlol> I know of Data.Text and the UTF8 packages, but I can't find any information that really made sense as to what is prefered.
05:43:08 <quchen> Text is the right way to go if you want to process longer strings (say > 100 characters).
05:43:35 <quchen> It comes with handy encoding functions that let you take pretty much anything and put it in a Text object, which is then encoding independent.
05:44:03 <adnap> quchen: I don't understand either definition. I thought foldr takes 3 arguments
05:44:19 <theredlol> Okay. I am very new to haskell, so I was just wondering :) I am trying to use parsec, and I have read that parsec uses Text internally, am I right?
05:44:48 <theredlol> I tried to use Text, but I must have done something wrong somewhere, I will go back and check :)
05:44:51 <quchen> adnap: Yes, it does. foldr addToFoldlAcc id xs z = (foldr addToFoldlAcc id xs) z
05:45:23 <quchen> theredlol: Parsec can handle multiple data sources, most importantly String, ByteString, Text.
05:45:54 <theredlol> okay :)
05:45:54 <quchen> For learning purposes, String is probably the easiest one. In production, others are probably more efficient.
05:46:21 <theredlol> ALSO! I have anther question, I just need to paste you the code.....
05:46:26 <quchen> @where paste
05:46:26 <lambdabot> http://lpaste.net/new/haskell
05:46:38 <theredlol> yeah :)
05:46:41 <theredlol> Can I use gist?
05:46:44 <quchen> Sure.
05:46:49 <theredlol> Thanks :D
05:46:51 <quchen> Just not pastebin, it's full of adspam.
05:47:25 <quchen> The nice thing about lpaste is that it automatically gives you code improvement suggestions, and it can automatically announce things on this channel.
05:48:02 <theredlol> quchen: I know, but I have Gist incorporated into vim, so I prefer to use it :s
05:49:35 <theredlol> https://gist.github.com/6184282
05:50:07 <adnap> quchen: I don't understand your paste
05:50:21 <theredlol> I run that and I get this error: texterror: <stdout>: commitAndReleaseBuffer: invalid argument (invalid character)
05:50:58 <adnap> What is the "derivative" of a type?
05:51:17 <adnap> Referenced here: http://comonad.com/reader/2008/the-pointed-set-comonad/
05:51:27 <quchen> theredlol: Works for me: http://i.imgur.com/VZJJCdZ.png
05:51:31 <theredlol> This is taken from a Stackoverflow question, I am just curiose as to why this fails. It is the same problem that I was having earlier.
05:52:02 <theredlol> quchen: http://stackoverflow.com/questions/2086842/using-haskell-to-output-a-utf-8-encoded-bytestring
05:52:17 <theredlol> quchen: answer number one works, number two doesn't.
05:52:28 <theredlol> Also, nice work space :)
05:52:51 <quchen> Sublime + Solarized, nothing special really
05:53:14 <theredlol> quchen: It doesn't have to be special to be nice.
05:53:31 <quchen> There are many workspaces like it, but this one is mine.
05:53:41 <quchen> Ah, so the problem in the question there is that it uses BS.Char8, which I've conveniently written something about yesterday.
05:53:59 <quchen> There you go: https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
05:54:19 <theredlol> quchen: :O
05:54:49 <theredlol> Thanks! I don't know what that means, but I have been searching for a long time for what was causing the error.
05:55:19 <quchen> The problem is that Char8 assumes ASCII and truncates. It does not deal with encodings, it just ignores them.
05:55:31 <quchen> Anything past 0xff will be messed up by it.
05:55:57 <merijn> theredlol: The short answer is "any time you write "Data.ByteString.Char8" in your code, your code is probably wrong"
05:55:58 <theredlol> So how do I disable it?
05:56:21 <theredlol> merijn: I will make a note of that.
05:56:22 <merijn> theredlol: Use Text and Text.Encoding
05:56:40 <quchen> Text.Encoding gives you functions like `decodeUtf8 :: ByteString -> Text`
05:56:50 <quchen> That will properly deal with Unicode that comes bytewise.
05:56:54 <merijn> theredlol: http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text-Encoding.html
05:57:18 <merijn> theredlol: And use this to convert String into Text: http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html#v:pack
05:57:37 <merijn> theredlol: Basically, ByteString has everything to do with Byte and nothing to do with String
05:57:38 <quchen> merijn: For transparency sake, I'm missing an example in my text above for when Char8 might be the way to go. I remember you mentioning something, could you tell me about it?
05:57:41 <theredlol> I am very slow, so I might have missed it, but why did the examle that is USING Data.Text Fail for me?
05:58:02 <merijn> quchen: Char8 exists for writing ASCII literal bytestrings for use in stuff like network protocols
05:58:04 <quchen> theredlol: No idea, as I mentioned, it worked for me
05:58:13 <merijn> theredlol: Which example?
05:58:22 <theredlol> https://gist.github.com/6184282
05:58:27 <theredlol> I run that and I get this error: texterror: <stdout>: commitAndReleaseBuffer: invalid argument (invalid character)
05:58:36 <merijn> theredlol: Oh! Oh!
05:58:55 <theredlol> :D
05:59:07 <theredlol> I take that as a good thing!
05:59:33 <merijn> theredlol: Run this in your shell and tell me what it says: "echo $LANG $LC_ALL $LC_CTYPE"
06:02:33 <theredlol> Sorry
06:02:36 <theredlol> I timed out.
06:02:51 <quchen> <merijn> theredlol: Run this in your shell and tell me what it says: "echo $LANG $LC_ALL $LC_CTYPE"
06:03:21 <merijn> quchen: Anyway, to be more concrete, things like HTTP/ZMQ/SMTP, etc. use ASCII text for commands, but you want to communicate with the socket using ByteStrings, so you frequently have to convert ASCII strings to ByteString here, which is when the OverloadedStrings instance of ByteString makes sense
06:03:34 <theredlol> By locals are all set to UTF-8
06:03:40 <theredlol> en_US.UTF-8 en_US.UTF-8
06:03:51 <merijn> hmmm, that's weird....
06:03:58 <merijn> Which OS?
06:04:03 <quchen> theredlol: Maybe you saved the source file using another encoding? ISO or something?
06:04:09 <theredlol> merijn: I am using OpenBSD latest stapshot
06:04:17 <merijn> And which GHC version?
06:04:55 <theredlol> The Glorious Glasgow Haskell Compilation System, version 7.6.3
06:05:02 <theredlol> let me try something....
06:05:25 <merijn> hmm, odd
06:05:53 <theredlol> yes.
06:06:01 <merijn> theredlol: Although, if you have a String literal in your code, you might as well use putStrLn
06:06:02 <quchen> And it's reproducible and all?
06:06:07 <merijn> Does that produce the same error?
06:06:08 <theredlol> I think this is an issue with my terminal?
06:06:17 <merijn> theredlol: Might be
06:06:47 <theredlol> term is set ot screen-256color
06:07:10 <theredlol> i have attempted running it innside and outside of tmux
06:07:28 <theredlol> terminal emulator is rvxt-unicode
06:08:12 <tdammers> hmm, yeah, I had issues with this particular combo myseldf
06:08:16 <theredlol> The error is reproduable
06:08:34 <theredlol> On my system that is.
06:09:03 <tdammers> maybe check if you have the right terminfo definitions on the remote system?
06:09:41 <theredlol> tdammers: It is my localmachine, and what would the tests involve?
06:10:04 <tdammers> oh, you're running screen locally
06:10:14 <theredlol> I know that my terminal supports UTF-8 as I have no problems `cat`ing the textfile
06:10:17 <tdammers> does it help if you manually export TERM inside the screen session?
06:10:43 <tdammers> (as to make it whatever rxvt wants, instead of screen)
06:10:44 <yitz> theredlol: do a hexdump -C of that file and paste it
06:10:48 <theredlol> tdammers: What do you want me tto export me to?
06:10:56 <theredlol> yitz: Got it
06:12:07 <tdammers> theredlol: try rxvt-256color
06:12:12 <theredlol> https://pastee.org/uvywc
06:12:16 <johnw> theredlol: did you check the source file's encoding?
06:12:26 <tdammers> or just fire up a terminal outside screen and do echo $TERM
06:12:38 <theredlol> johnw: yes. I have vim set to encode all my files as unicode
06:13:23 <theredlol> tdammers: I have tested it both outside and inside the tmux session
06:13:41 <tdammers> hmm, ok, I pass
06:17:03 <theredlol> .url -raw http://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txt
06:17:07 <theredlol> curl -raw http://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txt
06:17:35 <theredlol> It displays all the characters correctly, so I suppose we can rule out that it is something to do with my terminal.
06:18:13 <lingxiao> hi all, I have (I presume) a basic question about CPS, I was wondering someeone might answer?
06:18:46 <johnw> lingxiao: just ask
06:19:03 <merijn> Right, with a bit of luck, pipes will soon have mtl instances for MonadState, MonadReader and MonadWriter :>
06:19:19 <theredlol> Is there somewhere I should post a bug report about this?
06:19:21 <lingxiao> cool, I am confused about how a sum type translates to a CPS, for example
06:19:37 <merijn> theredlol: Check the hackage page for the text module and follow the "bug report" link?
06:20:08 <lingxiao> the type `data Step a b r = Stop  | Yield b r  | Await (a -> r)`
06:20:30 <quchen> theredlol: But running `main = putStrLn "čušpajž日本語"` works?
06:20:36 <quchen> i.e. the whole thing without Text
06:21:19 <lingxiao> how might that be translated into CPS form?
06:21:34 <lingxiao> I presume it looks something like (..) -> (..) -> (..)
06:21:45 <lingxiao> question 1. What goes in the parens and why
06:21:47 <theredlol> quchen: no: texterror.hs: <stdout>: commitBuffer: invalid argument (invalid character)
06:22:18 <quchen> echo "čušpajž日本語"?
06:22:19 <lingxiao> question 2. How does `->` translate to `|` in Non-CPS style
06:22:54 <theredlol> quchen: in the terminal or in a hs file?
06:22:58 <quchen> Terminal
06:23:03 <theredlol> Works.
06:23:34 <quchen> Hm. Well then it's a GHC issue I think.
06:24:01 <johnw> lingxiao: so, basic CPS is: a -> b transformed into a -> (b -> c) -> c, so it is just a matter of identifying a, b and c, I would think.  Can you take an example using Step and "decompose" it down to the functions being called?
06:24:20 <yitz> theredlol: you are importing two different modules as T
06:24:52 <theredlol> yitz: I know.
06:25:06 <lingxiao> johnw : what do you mean by "decomposing it down tot he functions being called"?
06:25:29 <theredlol> quchen: Since none of you can reproudce it, should I assume that it is local to the OpenBSD package?
06:25:31 <lingxiao> do you mean write a function that sends Step a b r -> Step a b r for example?
06:25:42 <gertc> hlint tells me Monad Law, left identity ?
06:25:56 <quchen> gertc: return x >>= f = f x
06:26:15 <johnw> well, Step decomposes to: Either () (Either (b,r) (a -> r)), then you have your functions that work with this type.  Just keep boiling it down until all you have left are plain functions and basic types
06:26:26 <yitz> theredlol: try it as a String, without Text, using putStrLn from the Prelude. does that work?
06:26:42 <quchen> yitz: No, he tried it before
06:26:46 <johnw> then take a code example that uses these functions, and rewrite it in those terms, and the use of CPS should become clear
06:26:55 <gertc> quchen: ok and what is bad about that?
06:26:57 <yitz> quchen: oh it did *not* work? hmm.
06:26:57 <quchen> yitz: pure "echo ..." in the terminal also works
06:27:08 <quchen> Prelude.putStrLn doesn't.
06:27:09 <lingxiao> johnw : ahh I see your drift, thanks a lot!
06:27:12 <yitz> got it.
06:27:18 <theredlol> Um.
06:27:33 <gertc> quchen: check uid (x:xs) acid = query' acid (LookupKey x) >>= \(Just set) -> return (uid `member` set) >>= \r -> if (r == True) then (check uid xs acid) else (return False)
06:27:46 <theredlol> Let me go into the openbsd room and ash about it
06:27:53 * hackagebot IntervalMap 0.3.0.2 - Maps from Intervals to values, with efficient search.  http://hackage.haskell.org/package/IntervalMap-0.3.0.2 (ChristophBreitkopf)
06:28:18 <theredlol> Oh I can't.
06:29:42 <arnsholt> I was told to use +RTS -xc to track down where an undefined array element was accessed, but the stack traces that get printed don't really make much sense to me. What's GHC.Arr.CAF?
06:29:50 <yitz> theredlol: try this in ghci:  putStrLn $ Data.ByteString.pack [0xc4,0x8d,0x75,0xc5,0xa1,0x70,0x61,0x6a,0xc5,0xbe,0xe6,0x97,0xa5,0xe6,0x9c,0xac,0xe8,0xaa,0x9e]
06:30:22 <quchen> gertc: Let me refactor that a little.
06:30:54 <theredlol> Test
06:31:00 <gertc> quchen: ok
06:31:01 <yitz> theredlol: pong
06:31:21 <donri> arnsholt: -xc won't be very useful without certain profiling flags like say -fprof-auto-calls
06:31:40 <yitz> theredlol: did you see my last message about trying entering it as hex?
06:32:25 <theredlol> yitz: no, I timed out
06:32:30 <yitz> theredlol: try this in ghci:  putStrLn $ Data.ByteString.pack [0xc4,0x8d,0x75,0xc5,0xa1,0x70,0x61,0x6a,0xc5,0xbe,0xe6,0x97,0xa5,0xe6,0x9c,0xac,0xe8,0xaa,0x9e]
06:32:34 <theredlol> Sorry :/
06:32:55 <eduardo_> applicative: hi, are you there? Sorry. I was away. I saw that you've wrote me something, but I couldn't read it.
06:33:38 <arnsholt> donri: Oh, that gave a better stack trace at least. I only had "-prof -fprof-auto -rtsopts" at the outset (what I was told to add =)
06:33:46 * arnsholt goes to read about profililng options
06:33:47 <merijn> Is it ugly to create a typeclass for the sole reason that it lets me combine multiple ugly constraints into a single clean one?
06:33:53 <yitz> ah wait
06:33:57 <theredlol> yitz: https://pastee.org/mwe2k
06:34:05 <johnw> merijn: why not use a constraint synonym?
06:34:21 <johnw> type MyConstraint a = (Monad a, Applicative a, Functor a)
06:34:28 <applicative> eduardo_: oh hi.  I think I just said i was using the homebrew wxmac
06:34:36 <hpaste> quchen pasted “gertc: refactoring, using the monad law” at http://lpaste.net/91666
06:34:39 <applicative> eduardo_: which wx 2.9.something
06:34:40 <merijn> johnw: That means adding ConstraintKinds and FlexibleContexts to every single module using it
06:34:41 <yitz> theredlol: try this in ghci:  putStrLn . Data.ByteString.Char9.unpack $ Data.ByteString.pack [0xc4,0x8d,0x75,0xc5,0xa1,0x70,0x61,0x6a,0xc5,0xbe,0xe6,0x97,0xa5,0xe6,0x9c,0xac,0xe8,0xaa,0x9e]
06:34:47 <yitz> theredlol: yeah i know sorry about that
06:34:49 <johnw> merijn: yeah, I just added that to the cabal file :)
06:35:05 <johnw> constraint kinds are going to become commonplace in my code anyway, so I bit the bullet
06:35:10 <donri> arnsholt: probably better not to use -fprof-auto for this, it only adds noise
06:35:36 <quchen> gertc: Eh, line 28 should read "f x", not "f y"
06:36:07 <yitz> oh darn that's also wrong
06:36:20 <eduardo_> applicative: did you tap a formula or something? When I used homebrew I got wxwidgets I got an older version
06:36:24 <quchen> gertc: `x <- return y` puts something in the monad by using `return`, and then immediately pulls out that value using `<-`. That makes the whole procedure redundant.
06:36:37 <theredlol> yitz: You mean Char8 right?
06:36:40 <theredlol> Because that works.
06:36:40 <adrian2> dear Haskellers... I have a small problem understanding how to unzip a tuple... given [(2, "D"), (4, "C"), (3, "D")] I want to pack as [(5, "D"), (4, "C")] by suming all the duplicates
06:36:57 <gertc> quchen: did you hpaste somthing? i did not see it
06:37:05 <quchen> gertc: http://lpaste.net/91666
06:37:15 <theredlol> yitz: http://stackoverflow.com/questions/2086842/using-haskell-to-output-a-utf-8-encoded-bytestring
06:37:26 <quchen> adrian2: use `groupBy` to get the elements together, then you can use a map to sum up the numbers.
06:37:35 <yitz> theredlol: i'm really sorry. one more try:  putStrLn . Data.Text.unpack . Data.Text.Encoding.decodeUtf8 $ Data.ByteString.pack [0xc4,0x8d,0x75,0xc5,0xa1,0x70,0x61,0x6a,0xc5,0xbe,0xe6,0x97,0xa5,0xe6,0x9c,0xac,0xe8,0xaa,0x9e]
06:37:36 <theredlol> yitz: the first answer there works, the second doesnt
06:37:39 <adrian2> :t groupBy
06:37:40 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
06:37:59 <arnsholt> donri: Right
06:38:06 <quchen> adrian2: In your case, you want to group the tuples by their second element. (hint hint) :-)
06:38:11 <Taneb> :(
06:38:19 <arnsholt> I think I just figured it out, as well. PEBKAC =)
06:38:21 <applicative> eduardo_: if you do brew formula wxmac the formula should come up in your editor
06:38:23 <adrian2> quchen: yes, by the snd
06:38:46 <arnsholt> (I think. Don't think Array.assocs does what I wanted it to do)
06:39:08 <chrisdone> it's not Array.assocs. it's a very naughty boy
06:39:42 <yitz> theredlol: i actually did try it myself here. but i did it on several lines, using lets, and tried to convert it to a one-liner for irc by hand. this should teach me a lesson never to do that. :)
06:39:43 <merijn> johnw: I guess I can just say "screw it, everyone wishing to use ZMQ should join me in the modern GHC age"
06:41:17 <johnw> I would :)
06:41:21 <gertc> quchen: i am thinking hold on :)
06:41:59 <quchen> adrian2: Oh, I misread your question, you don't want to only group, you also want to sort. So what you need is first to sort the list by the second elements (so all the "D" are next to each other), then group (so all the "D" get their own sublist), and then finally calculate a sum value out of all those sublists.
06:42:21 <adrian2> quchen, yes ! :)
06:42:30 <merijn> johnw: But hdevtools throws a hissy fit if I only add it to the cabal file :\
06:42:31 <quchen> adrian2: So you're left with `calculateSums . groupBy (second element) . sortBy (second element)
06:42:33 <quchen> `
06:42:46 <theredlol> yitz: *** Exception: <stdout>: hPutChar: invalid argument (invalid character)
06:43:07 <quchen> adrian2:  Now fill in the holes piece by piece. Start with the sorting and see whether you can make it work.
06:43:10 <eduardo_> applicative: the version I got with homebrew was 2.9.4. The version wxHaskell supposedly requires is 2.9.5.
06:43:15 <quchen> gertc: :-)
06:43:20 <yitz> theredlol: aha. so there is definitely something wrong with your ghc build then. those were valid characters for sure.
06:43:45 <adrian2> quchen, okay... but I find somehow difficult to work with tuples
06:43:51 <johnw> merijn: I changed my hdevtools runner to add -X... for every option I use these days
06:43:56 <Taneb> Is a MonadFix instance for Free f known to be impossible, or has just no-one bothered?
06:44:13 <theredlol> yitz: thanks :) THen I just need to inform the openBSD gufs
06:44:13 <quchen> adrian2: Do you understand `sortBy`?
06:44:48 <latermuse> :q
06:44:52 <latermuse> doh
06:44:54 <yitz> theredlol: right. actually you should file a bug on the GHC trac. isn't openBSD an officially supported platform?
06:44:56 <quchen> adrian2: `sortBy` takes a comparison function and sorts a list with it. For example, `sortBy (\x y -> x > y)` will sort a list in descending order.
06:45:33 <quchen> adrian2: In your case, you want to sort by the snd element of a tuple.
06:45:44 <theredlol> yitz: I would think so?
06:45:52 <quchen> So how would the (\x y -> ...) look like here?
06:46:03 <merijn> Taneb: It's a trap! One moment you're thinking "I'll just submit a quick pull request with this code to edwardk", next thing you know he gives you push permissions and makes you maintain his packages!
06:46:03 <adrian2> quchen: I got this after doing let f x = map (\x -> (length x, head x)) (group x) over f "DDCCCCDDD"
06:46:03 <theredlol> yitz: How would I submit a bug report?
06:46:16 <lasticot> hi, I'm trying to code program that would echo everything you have entered so far each time you enter something new. For instance: < hello > hello >how are you
06:46:27 <Taneb> merijn, I've already got push permissions for like 6 of them
06:46:29 <quchen> adrian2: That looks correct.
06:46:44 <lasticot> > hellohow are you
06:46:45 <lambdabot>   Not in scope: `hellohow'Not in scope: `are'
06:46:45 <lambdabot>  Perhaps you meant one of these...
06:46:58 <merijn> johnw: Is it possible to have directory specific hdevtools configs?
06:47:11 <Taneb> merijn, zippers, lens, semigroupoids, comonads-fd, streams, and tables
06:47:19 <yitz> theredlol: ohh. no, only freebsd appears on the dowload page. :(
06:47:24 <Taneb> I'm in too deep already :(
06:47:51 <lasticot> but I don't understand how to store the string while the program is waiting for more entries?
06:48:01 <dmwit> lasticot: main = interact id -- ?
06:48:03 <gertc> quchen: ok thx funny how i can always make it more complicated then it really is lol :)
06:48:06 <theredlol> Ah, damn. Can I ash how big cloning the tree would bee?
06:48:22 <dmwit> lasticot: "interact" is a great way to get started writing simple Haskell programs without worrying too much about how to do IO
06:48:34 <yitz> theredlol: http://ghc.haskell.org/trac/ghc/wiki/ReportABug
06:48:59 <quchen> gertc: Nothing to be afraid of. I can show you code of myself which tries to build the Collatz tree by creating small trees and then appending them to each other in each step. It's horrible and reminds me of the humble beginnings. :-)
06:49:01 <yitz> theredlol: but maybe you're right. if it's not officially supported, you would just go to the "openbsd gurus".
06:49:02 <dmwit> lasticot: Just write a String -> String function that takes input and produces output and hand that function off to interact.
06:49:30 <yitz> theredlol: see if they (or you?) could officially support an openbsd build. that would be great!
06:49:50 <theredlol> yitz: One of them are saying that it could be because openbsd only partly supports UTF
06:50:05 <theredlol> yitz: There are a openBSD package for GHC
06:50:05 <theredlol> :)
06:50:24 <applicative> dmwit: he wants to accumulate input ?
06:50:56 <lasticot> dmwit, applicative: yes I do
06:51:17 <lasticot> isn't it possible with interact?
06:51:40 <yitz> theredlol: even if there were *no* support for utf8 on openbsd you could still patch ghc to output the correct bytes. someone just has to look into what is going wrong on that platform and how to fix it.
06:52:45 <lasticot> I maybe missing knowledge on how to use stuff like monad transformer and state monad. I've got the feeling that they are necessary to solve my problem but I don't understand how
06:52:56 <dmwit> I don't think they are necessary.
06:53:03 <adrian2> quchen: sortBy (\x y -> x > y) is just a function x over y?
06:53:05 <dmwit> But maybe I don't understand what "I want to accumulate input" means.
06:53:07 <theredlol> yitz: Yeah, that is what I think too. I may build ghc from source and see if that works
06:53:11 <applicative> well main = loop []; loop xs = do {x <-  getLine; let zs = xs++x; putStrLn zs; loop zs
06:53:26 <quchen> adrian2: It sorts a list by looking at which one is bigger.
06:53:27 <dmwit> lasticot: Can you describe again the top-level behavior you want your program to have?
06:53:31 <applicative> well main = loop []; loop xs = do {x <-  getLine; let zs = xs++x; putStrLn zs; loop zs}
06:53:41 <quchen> > sortBy (\x y -> x > y) [1..10] -- adrian2
06:53:42 <lambdabot>   Couldn't match expected type `GHC.Types.Ordering'
06:53:42 <lambdabot>              with actual ...
06:54:15 <adrian2> quchen: okay, thanks. I will go back and try again your excellent sugentions
06:54:15 <dmwit> lasticot: (...but if the goal of this project is to learn about monad transformers and the state monad, then of course avoiding them isn't good advice!)
06:54:23 <merijn> johnw: Right, clearly there is only one solution
06:54:24 <quchen> Argh. Okay, we need to `compare`. Which makes things more complicated right now. Eek.
06:54:25 <dmwit> lasticot: (The best advice depends on your goals a little bit!)
06:54:31 <johnw> merijn: what's that?
06:54:43 <merijn> johnw: Modify the syntastic integration of hdevtools to parse cabal files for flags and extensions!
06:54:50 <johnw> oooh
06:54:54 <johnw> i would love that
06:55:15 <merijn> johnw: You should pay me, all this haskell yak shaving is stopping me from working :p
06:55:19 <johnw> merijn: here's the list I currently use: https://gist.github.com/6184784
06:55:28 <merijn> heh, I should just kickstart myself
06:55:33 <theredlol> Ah hamn
06:55:34 <jtanguy> adrian2: hint: `sort = sortBy compare`
06:55:45 <applicative> lasticot: the example above works as planned.
06:55:55 <theredlol> I can't build it here, I will have to wait till Sunday
06:55:55 <hpaste> lasticot pasted “example” at http://lpaste.net/91667
06:56:25 <merijn> For 1-2k I will work for a month on fixing my vim indenter further, add cabal parsing to syntastic and implement haskell folding ;)
06:56:31 <applicative> lasticot: let loop xs = do {x <-  getLine; putStrLn (xs++x); loop (xs++x)
06:56:36 <tikhon> johnw: what is this going to be used for--why do you have -Wall as an extension?
06:56:39 <applicative> lasticot: then try loop [] in ghci
06:56:39 <dmwit> lasticot: Aha! Okay.
06:56:42 <latermuse> >print$map(chr.fromIntegral)[0x48,0x65,0x6c,0x6c,0x6f,0x20,0x57,0x6f,0x72,0x6c,0x64]
06:56:52 <johnw> tikhon: so that hdevtools shows me warnings, even if the project doesn't enable them
06:56:58 <jtanguy> quchen: one thing I like is `on` from Data.Function
06:57:00 <tikhon> ah
06:57:05 <dmwit> lasticot: You can still do that with interact, and I think it's a good exercise to think about how. =)
06:57:25 <dmwit> lasticot: You might like functions like lines, unlines, and scanl.
06:57:28 <jtanguy> when working with tuples
06:57:30 <merijn> johnw: "-Wall" with no "-fno-warn-unused-do-bind"? Brave man!
06:57:35 <quchen> jtanguy: In this case, there's also `comparing` from Data.Ord, which is (comparing `on`). But I didn't want to throw too many new names around
06:57:48 <quchen> Eh, (compare `on`).
06:57:51 <johnw> The only downside of passing all of those options down to hdevtools, is that sometimes hdevtools says that my code compiles fine, but when I go to build it with Cabal it doesn't because I haven't added the option yet that it depends on
06:57:51 <lasticot> applicative, dmwit: ok ok I will look at the solution and try to do it with interact thank you
06:57:54 * hackagebot github 0.7.1 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.7.1 (JohnWiegley)
06:57:59 <merijn> johnw: I'm still in doubt whether I should keep the shadowing warning, the syntastic errors for shadowing tend to annoy me
06:58:05 <applicative> dmwit: ah i see with interact its some sort of scan
06:58:09 <johnw> merijn: I do selectively disable warnings in some modules with OPTIONS_GHC
06:58:18 <dmwit> applicative: Yes, it's a particularly simple scan, even. =)
06:58:23 <johnw> the problem with shadowing is that it can fool the reader
06:58:30 <dmwit> Heck, it might just be "inits".
06:58:31 <johnw> they think they know what "first" means, but maybe I've shadowed it out of vie
06:58:32 <johnw> w
06:58:42 <dmwit> lasticot: So I guess you should look at what "tails" and "inits" do, too.
06:58:52 <johnw> so I like to know when I'm shadowing
06:59:04 <tikhon> Hmm, I'll really have to play around with hdevtools one of these days. I never did have much luck with ghc-mod.
06:59:39 <merijn> johnw: Sure, but other times you have "swap (s, w) = (w, s)" (where s and w are "semantically significant") in a where clause of a function that has an s defined to and then synastic complains
06:59:52 <merijn> johnw: And I dunno how to say "ignore this specific complaint!"
07:01:00 <applicative> -fwarn-name-shadowing
07:01:13 <applicative> no no-warn in this case merijn ?
07:01:21 <merijn> applicative: Yes, but disables *all* of them
07:01:28 <applicative> ahawkins:
07:01:32 <applicative> ah rather
07:01:39 <yitz> theredlol: ok yes openbsd is officially supported. yay! the maintainer is listed as Matthias Kilian
07:01:39 <applicative> sorry ahawkins
07:02:10 <applicative> well, i'm with johnw, Dont Do IT
07:02:11 <applicative> it
07:02:18 <yitz> theredlol: so please file a bug on the ghc trac, and keep track of work on the bug there so that it will be documented and not forgotten.
07:02:40 <dmwit> applicative, lasticot: (spoilers, so rot13'd) znva = vagrenpg (hayvarf . znc pbapng . vavgf . yvarf)
07:02:55 <yitz> theredlol: but you still have to get the openbsd people to actually work on the bug because that platform is not the highest priority for the ghc core team.
07:03:12 <applicative> hayvarf .. varf
07:03:14 <applicative> got that one
07:03:14 <merijn> applicative: Easier said than done, naming things sucks!
07:03:15 <yitz> theredlol: dcoutts says that this bug is almost certainly an issue with iconv.
07:03:35 <merijn> Clearly there is only one solutions
07:03:46 <merijn> Pointfree all day, every day!
07:03:50 <applicative> merijn: yes, i know, i'm pretending to have high principles
07:03:54 <dcoutts> theredlol: ghc's normal I/O stuff uses iconv for the conversion
07:04:12 <applicative> iconv my enemy!
07:04:25 <dcoutts> theredlol: and in fact by default it uses the current locale encoding
07:04:49 <dcoutts> theredlol: so if that's not UTF8 then you would indeed have problems printing some unicode chars to stdout or a file or whatever
07:05:06 <dcoutts> so also worth checking your locale setting
07:05:22 <yitz> dcoutts: they checked that, it's all utf-8
07:05:27 <dcoutts> ok
07:05:28 <dcoutts> good
07:06:16 <theredlol> !
07:06:45 <theredlol> yitz: I think I saw iconv somewhere
07:06:48 <theredlol> brb
07:09:37 <adrian2> :t sortBy
07:09:38 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
07:09:58 <adrian2> :t sortBy (\x y -> x > y) [1..10]
07:09:59 <lambdabot>     Couldn't match expected type `Ordering' with actual type `Bool'
07:10:00 <lambdabot>     In the expression: x > y
07:10:00 <lambdabot>     In the first argument of `sortBy', namely `(\ x y -> x > y)'
07:10:01 <haasn> dmwit: I like that solution
07:10:12 <theredlol> dcoutts: So recompiling the iconv hearders would help?
07:10:33 <quchen> adrian2: sortBy needs a "comparison" function like "compare" to work. (>) gives you a Bool, but sortBy needs an `Ordering`.
07:10:44 <quchen> adrian2: I wrote that down wrong above I'm afraid.
07:11:05 <quchen> adrian2: Someone gave the hint `sort = sortBy compare`, maybe that helps?
07:11:11 <adrian2> quchen: no problem... I learn every time from mistakes
07:11:29 <adrian2> :t sortBy compare
07:11:30 <lambdabot> Ord a => [a] -> [a]
07:11:32 <adrian2> :)
07:11:43 <quchen> What you want is to compare the snd of a list of tuples. So that would be `sortBy (\x y -> compare (???) (???))`
07:11:54 <quchen> Now what do you have to put in the ??? there?
07:12:07 <ocharles> compare `on` snd?
07:12:15 <lasticot> dmwit: I don't have the actual code but are you taking advantage of the buffering system?
07:12:31 <quchen> ocharles: That introduces `on` which is refactoring which isn't the point here. (Also, `comparing snd` is better.)
07:12:34 <tdammers> quchen: I'd rather ask myself: in `sortBy (\??? ??? -> compare x y)`, what would I have to put in the ???'s?
07:12:46 <ocharles> oh sorry quchen, I missed the backscroll. I thought you were asking that question :)
07:12:54 * hackagebot MFlow 0.3.1.0 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.3.1.0 (AlbertoCorona)
07:13:33 <quchen> tdammers: That would also work, yes. It won't be as straightforward to refactor to `comparing` though.
07:14:17 <tdammers> quchen: of course not. But pattern matching feels more elegant in this case.
07:15:17 <haasn> tdammers: (snd -> x) (snd -> y) -- of course :)
07:15:26 <quchen> You guys …
07:16:02 <yitz> > let rot13 c | c >= 'a' && c <= 'z' = toEnum . (\a -> 96 + (a - 83) `mod` 26) $ fromEnum c | otherwise = c in map rot13 "abc, def" -- dmwit, just sayin' ...
07:16:03 <lambdabot>   "nop, qrs"
07:18:04 <haasn> hmm
07:22:09 <haasn> yitz: aagh, I can't find a beautiful lensy way to do this that doesn't violate laws
07:23:15 <haasn> “iso chr ord” and “iso (+96) (subtract 96)” the easy bits, but then I ideally want a traversal to restrict it to the range 'a' - 'z', and another traversal for (`mod` 26), but the latter two violate the lens laws
07:26:51 <elliott> iso chr ord is just enum and violates the laws anyhow
07:28:30 <haasn> > maxBound ^. enum :: Char
07:28:32 <lambdabot>   *Exception: Prelude.chr: bad argument: 2147483647
07:28:47 <haasn> I guess the difference is when ‘enum’ violates the laws you get an error in one of the cases
07:28:49 <jtanguy> let rot13 c = Data.Map.findWithDefault c c (Data.Map.fromList $ zip ['a'..'z'] ['z','y'..'a']) in map rot13 "abc, nop"
07:29:16 <yitz> it would be fitting if the lens library had a combinator ebg13 that does rot13
07:31:36 <yitz> or some cryptic operator whose meaning would be immediately obvious to those already initiated into the secret lens society
07:32:02 <jtanguy> > let rot13 c = Data.Map.findWithDefault c c (Data.Map.fromList $ zip ['a'..'z'] ['z','y'..'a']) in map rot13 "#szhpvoo ilxph!"
07:32:03 <lambdabot>   Not in scope: `Data.Map.findWithDefault'Not in scope: `Data.Map.fromList'
07:32:20 <yitz> @type M.findWithDefault
07:32:21 <lambdabot> Ord k => a -> k -> M.Map k a -> a
07:32:24 <geekosaur> I think it's imported qualified as M
07:32:33 <jtanguy> oh yes of course
07:32:37 <theredlol> Does this seem okay? http://ghc.haskell.org/trac/ghc/ticket/8118
07:32:52 <jtanguy> > let rot13 c = M.findWithDefault c c (M.fromList $ zip ['a'..'z'] ['z','y'..'a']) in map rot13 "#szhpvoo ilxph!"
07:32:54 <lambdabot>   "#haskell rocks!"
07:32:59 <jtanguy> yay!
07:33:02 <theredlol> I have never posted a bug report before.
07:35:24 <yitz> theredlol: great, thanks.
07:36:13 <theredlol> yitz: Okay. I need to go now, I will see you later.
07:36:56 <jtanguy> oops, what i've done is not rot13 at all, should be (['a'..'z']) and (['n'..'z']++['a'..'m'])
07:39:52 <jtanguy> > let rot13 c = M.findWithDefault c c (M.fromList $ zip ['a'..'z'] (['n'..'z']++['a'..'m'])) in take 4 $ iterate (map rot13) "abc"
07:39:54 <lambdabot>   ["abc","nop","abc","nop"]
07:40:03 <jtanguy> that's more like it
07:41:31 <jtanguy> adrian2: have you found the solution of your problem?
07:41:33 <haasn> > let rot13 c = M.fromList (zip ['a'..'z'] $ ['n'..'z']++['a'..'m']) ^. at c . non c in take 4 $ iterate (map rot13) "abcxyz"
07:41:35 <lambdabot>   ["abcxyz","nopklm","abcxyz","nopklm"]
07:42:07 <haasn> lens, deprecating Data.X utility functions since 2013
07:42:22 <edwardk> *2012
07:42:28 <applicative> Summer 2012
07:42:29 <applicative> oh
07:42:31 <haasn> oh it's that old already?
07:42:34 <edwardk> yeah
07:42:39 <edwardk> started it just over a year ago
07:43:01 <yitz> ok edwardk no one could figure out how to write rot13 nicely. what do you say? you can limit it to lower case only.
07:43:05 <adrian2> jtanguy: sorry I've got distracted... but right now I'm doing a custom Compare function for the sortBy
07:44:06 <haasn> edwardk: I really want a ‘modulo n’ traversal, but laws :(
07:45:02 <applicative> who needs quickcheck when you have secret decoder ring from Cheerios
07:45:17 <applicative> a secret decoder ring rather
07:45:58 <yitz> applicative: it's really disappointing that @check doesn't work anymore on lambdabot. almost as bad as @vixen.
07:46:17 <applicative> oh, that's annoying. not so sure about vixen
07:46:41 <adrian2> hey guy... thanks, gotta go... I will post my solution once I find one :D
07:49:19 <edwardk> > let a%b=([a..b]++); q=0%64$78%90$65%77$91%96$110%122$97%109$[123..] in map (toEnum.(q!!).fromEnum) "hello" :: String
07:49:20 <lambdabot>   "uryyb"
07:49:37 <edwardk> blech
07:49:56 <edwardk> haasn's version is pretty good
07:49:59 <merijn> edwardk: Are you secretly a perl programmer? :)
07:50:15 <edwardk> merijn: yes
07:50:30 <edwardk> How do you think i found haskell?
07:50:54 <edwardk> Pugs seemed like it was the only interesting thing written in Haskell when I found the community ;)
07:51:02 <merijn> >.>
07:51:07 <quchen> Is there some way to un-tell someone something? I just wrote a message to a pretty random person.
07:51:09 <haasn> edwardk: don't tell me we have you to thank for the mangler
07:51:13 <Maior> quchen: no
07:51:21 <edwardk> haasn: nope. marlow
07:51:30 <quchen> Well then let's hope he doesj't encounter Lambdabot ever.
07:51:41 <tikhon> quchen: do it in wetware--tell them to ignore the previous message :)
07:51:44 <haasn> conjecture: all well-known haskell programmers are secretly perl lovers
07:52:18 <sm> haskell: perl done right
07:52:30 <tikhon> My view is that Haskell and Perl share at least one core philosophy: expressiveness
07:52:42 <tikhon> the complete opposite of the Java/Python crowd
07:52:51 <quchen> And dangerously complex special character operators!
07:52:58 <tikhon> Tim Toady and friends
07:53:04 <haasn> yes, they share (<<>~)
07:53:05 <sm> yeah it's all about the power of your operators
07:53:35 <haasn> @quote mappend.operator
07:53:35 <lambdabot> elliott says: |\/|/-\|-|-|=|\||} is my preferred mappend operator
07:53:45 <yitz> tikhon: well i originally found haskell via python
07:54:06 <haasn> that should be > instead of } to make it actually legal :(
07:55:08 <haasn> > "hello" |\/|/-\|-|-|=|\||> "world"
07:55:12 <lambdabot>   mueval-core: Time limit exceeded
07:55:14 <haasn> oh no
07:55:29 <haasn> elliott: !!
07:55:46 <elliott> it works if you try enough times.
07:56:26 <yitz> tikhon: the core devs of python were discussing haskell on the mailing list. they were busy stealing features from haskell, like list comprehensions.
07:56:28 <haasn> edwardk: do you think there's any hope in the future for a less lawful traversal which can traverse the same element multiple times, or modify its own structure?
07:56:58 <tikhon> yitz: Features? Sure. The core philosophy? Not at all. Quite the opposite, really.
07:57:08 <yitz> right
07:57:30 <tikhon> not many features, either
07:57:32 <edwardk> haasn: the issue is I can't reason about them
07:57:32 <merijn> tikhon: Actually, I still stand by most of the Zen of Python
07:57:34 <tikhon> they even hate lambdas
07:57:47 <merijn> tikhon: No, lambda's just don't make much sense in python
07:58:09 <merijn> tikhon: You can define functions in any scope, so just define one
07:58:13 <edwardk> haasn: and they compose like crap with all the other lens-variants
07:58:23 <aristid> merijn: are you even going so far as to defend the statement/expression division? :P
07:58:23 <tikhon> and yet they make plenty of sense in other languages (even JavaScript!)
07:58:50 <aristid> tikhon: javascript "lambdas" can contain statements
07:58:52 <tikhon> I remember even simple things--say a named tuple of functions--to be annoying
07:59:31 <merijn> Anyhoo
07:59:32 <merijn> -blah
07:59:40 <piotrm_> haskell is hard
08:00:01 <merijn> Programming is hard, haskell is fairly easy
08:00:05 <haasn> haskell is a monoid
08:00:05 <tikhon> is it?
08:00:12 <lasticot> applicative, dmwit: ok I've got it now. of the two solution which one should be prefered? What are the thing to consider?
08:00:23 <applicative> haskell is easy, then hard, then easy again, then ..
08:00:34 <haasn> applicative: http://www.haskell.org/haskellwiki/Humor/LearningCurve
08:00:41 <tikhon> I've found programming much easier than many other things--most other things, I suppose. That's why I'm here :).
08:00:58 <tikhon> Both in this IRC channel and in life
08:01:03 <haasn> I think programming is much easier than electrical engineering! Maybe that's why I'm a programmer and not an electrical engineer
08:01:06 <Arkantos> Programming is hard, haskell is fairly easy <---- both are easy
08:01:17 <elliott> only monoids are easy.
08:01:32 <elliott> monoids and pointless arguments about what is easy on IRC.
08:01:33 <yitz> piotrm_: some unis are using haskell for their intro programming course. people who learn haskell as their first language find it easy. the problem is if you've been using imperative languages for too long, there's a lot to unlearn.
08:01:38 <merijn> haasn: I guess I'm stuck in the applicative plane atm :p
08:02:03 <haasn> merijn: Nice! I'm still in the poiintless-pointfree plane
08:02:06 <haasn> but it's missing a ‘lens’ plane
08:02:14 <piotrm_> ahh, I've used basic, c, scheme, ocaml, java, and others. haskell is still hard
08:02:31 <haasn> Haskell is just unusual, if you're used to those sort of languages
08:02:38 <applicative> lasticot: oh you figured out dmwit's interact one?
08:02:39 <tikhon> honestly, I find OCaml harder to use than Haskell
08:02:59 <lasticot> applicative: yes :-)
08:03:04 <haasn> tikhon: oh, was your “is it?” a reply to “haskell is a monoid”?
08:03:04 <merijn> piotrm_: How come you think haskell is harder than ocaml?
08:03:07 <applicative> ah good, lasticot
08:03:18 <tikhon> haasn: no, that was about whether programming is actually hard
08:03:24 <tikhon> (it isn't)
08:03:34 <merijn> tikhon: Actually, you're right, programming is easy too
08:03:36 <applicative> lasticot: I think that the question which is better would arise as you complicate the program
08:03:39 <haasn> programming is less hard, more soft and slimy
08:03:39 <merijn> Thinking is hard
08:03:42 <piotrm_> ohh, I'm making small talk, it is hard because I haven't used it for as long as ocaml, I hope it will become less hard in time
08:04:04 <tikhon> programming saves you from thinking too much—just offload anything you can to the computer
08:04:16 <tikhon> and you get immediate feedback about whether things work
08:04:31 <applicative> lasticot: adding State is distasteful but probably would 'scale' better than either
08:04:47 <haasn> tikhon: when using lens, of course, this feedback is offset by the amount of time it takes to understand the error message
08:05:00 <tikhon> details
08:05:33 <lasticot> applicative: ok
08:06:13 <applicative> lasticot: but maybe its too opaque for the moment; maybe not; just a sec
08:07:03 <haasn> I guess the only thing that kind of irks me about dmwit's solution is the grandiose abuse of lazy IO; which works fine in this case but might pose problems when scaling
08:07:47 <lasticot> applicative: basically I was hoping to code a snake game from there, I had trouble understanding how to update a state depending on the inputs. I may be able to do it now
08:08:00 <hpaste> applicative annotated “example” with “example with StateT” at http://lpaste.net/91667#a91668
08:08:56 <applicative> lasticot: here's with StateT ^^^
08:09:20 <adrian2_> :) I have some partial clue about my problem
08:09:26 <adrian2_> sortBy (compare `Data.Function.on` (snd)) [(1, "D"), (2, "F"), (2, "D")]
08:09:27 <lasticot> applicative: thank you I'm gonna go through this :-)
08:09:37 <adrian2_> now I have to do the groupBy
08:10:02 <haasn> compare `on` f = comparing f
08:10:06 <applicative> lasticot: I added the deluxe 'quit' feature
08:10:24 <lasticot> applicative: ^^
08:10:26 <adrian2_> :i comparing
08:10:39 <adrian2_> :t comparing
08:10:40 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
08:10:49 <merijn> Why is there no "modify :: (s -> (s, a)) -> StateT s m a" or something? :\
08:10:51 <adrian2_> haasn: thanks
08:11:00 <haasn> merijn: you want ‘state’
08:11:08 <merijn> haasn: Nope
08:11:20 <haasn> :t state -- what's wrong with it?
08:11:30 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
08:11:30 <merijn> I don't think so, at least?
08:11:47 <merijn> oh!
08:12:00 <merijn> bah, no
08:12:36 <adrian2_> :D any help with the groupBy () [(1, "D"), (2, "D"), (2, "F")]
08:13:12 <jtanguy> adrian2_: it's the same deal as sortBy
08:13:22 <jtanguy> previously you had sort
08:13:26 <jtanguy> :t sort
08:13:26 <lambdabot> Ord a => [a] -> [a]
08:13:28 <merijn> haasn: I want to conditionally update state and get a result back, I guess that type is not what I wanted, more of a "(s -> Bool) -> m s -> StateT s m s", I guess
08:13:52 <jtanguy> which you wanted to customize through sortBy to sort on the second element of the tuple
08:13:53 <preop> quit
08:14:03 <merijn> I guess I'lll actually have to write code...
08:14:03 <merijn> bother
08:14:21 <jtanguy> now you have group, which groups together consecutive equal elements
08:14:23 <jtanguy> :t gtoup
08:14:24 <lambdabot>     Not in scope: `gtoup'
08:14:24 <lambdabot>     Perhaps you meant one of these:
08:14:24 <lambdabot>       `BSC.group' (imported from Data.ByteString.Char8),
08:14:25 <jtanguy> :t group
08:14:26 <lambdabot> Eq a => [a] -> [[a]]
08:15:12 <jtanguy> and you want to customize with groupBy to group on the second elements of the tuples
08:15:30 <jtanguy> :t groupBy
08:15:31 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
08:16:05 <jtanguy> here group = groupBy (==)
08:16:59 <adrian2_> jtanguy: yes... but my criteria is the snd
08:17:13 <adrian2_> groupBy (==) [(1,"D"),(2,"D"),(2,"F")] == [[(1,"D")],[(2,"D")],[(2,"F")]]
08:18:39 <jtanguy> remember what you did with sortBy
08:18:43 <jtanguy> :t sortBy
08:18:44 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
08:18:46 <jtanguy> :t groupBy
08:18:47 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
08:19:46 <jtanguy> sortBy (\x y -> (???) == (???))
08:19:58 <adrian2_> jtanguy: :) my brain just stop working on this one  :(
08:21:12 <adrian2_> groupBy (\x y -> (snd x) == (snd y)) [(1,"D"),(2,"D"),(2,"F")]
08:21:21 <adrian2_> [[(1,"D"),(2,"D")],[(2,"F")]]
08:21:23 <adrian2_> :(
08:21:36 <jtanguy> no you're on the way
08:21:46 <jtanguy> :t (groupBy (\x y -> (snd x) == (snd y)) [(1,"D"),(2,"D"),(2,"F")])
08:21:46 <lambdabot> Num a => [[(a, [Char])]]
08:23:06 <jtanguy> remember the original plan quchen proposed was `calculateSums . groupBy (second element) . sortBy (second element)`
08:24:17 <jtanguy> now you have to write calculateSums, which transforms [(1,"D"),(2,"D")] into (3,"D")
08:24:47 <adrian2_> yes... zip would help?
08:25:40 <jtanguy> here you want to reduce a list of (Int, String) to a single element
08:26:34 <adrian2_> let calculateSum = (\x y -> (fst(x)+fst(y), snd(x))
08:27:30 <jtanguy> yes!
08:27:58 <adrian2_> calculateSum x y = (\x y -> (fst(x)+fst(y)), snd(x))
08:28:14 <jtanguy> you're close
08:28:27 <adrian2_> jtanguy: you make me look smart :D
08:29:09 <adrian2_> now I have to iterate through the :t [[(1,"D"),(2,"D")],[(2,"F")]]
08:29:41 <adrian2_> which I have no ideea :(
08:30:03 <jtanguy> not the whole list of lists, just every sub-list
08:30:08 <merijn> Any people familiar with pipes-4? Is there a better wait to turn an Effect into Producer than "forever (effect >>= yield)"?
08:30:53 <jtanguy> you have a list of tuples :: [a] -- where a :: (Int, String)
08:31:16 <jtanguy> you have a function to combine two elements a -> a -> a
08:31:34 <adrian2_> jtanguy: yes
08:31:39 <jtanguy> the type of function you want to use is called a fold
08:32:16 <adrian2_> Ohh.... gee the old pal... fold
08:32:26 <jtanguy> :t foldr
08:32:26 <adrian2_> let me try it
08:32:27 <lambdabot> (a -> b -> b) -> b -> [a] -> b
08:32:30 <jtanguy> sure
08:34:01 <adrian2_> ohh... why tuples are soo 4D
08:34:32 <hpaste> haasn pasted “lasticot's problem” at http://lpaste.net/91669
08:34:37 <haasn> applicative: here's my attempt ^
08:34:47 <tikhon> 4D?
08:35:40 <adrian2_> tikhon: for me is like 4D from 3D world
08:35:55 <adrian2_> in haskell... anyway...
08:36:12 <Fuuzetsu> Haskell confirmed for the first 4D language
08:36:23 <adrian2_> hehehe
08:36:27 <jtanguy> adrian2_: have you found it?
08:36:52 <adrian2_> noo.... please help me, since I can't resist and I have to leave the office
08:36:57 <jtanguy> me too :
08:36:59 <jtanguy> :)
08:37:01 <jtanguy> so
08:37:12 <jtanguy> you have calculateSum :: a -> a -> a
08:37:19 <applicative> haasn: awesome!
08:37:23 <jtanguy> and your sub-lists [a]
08:37:35 * applicative tries to write it with pipes-4
08:37:45 <adrian2_> jtanguy: yes :)
08:38:10 <jtanguy> foldr takes a combining function (a -> b -> a), a starting accumulator b, and your list [a]
08:38:17 <jtanguy> and returns a value of type b
08:38:58 <aristid> xplat: is your md5 pipe thing public somewhere?
08:39:19 <jtanguy> you want to combine all your elements by taking the first element, combining with the next element, etc.
08:40:08 <jtanguy> so you want to do a foldr (calculateSum) (head list) (tail list)
08:40:34 <jtanguy> where list is one of your sub-lists [(1,"D"),(2,"D")]
08:40:54 <exicer> So I'm confused by how a function defined for a type class knows how to find the implementation.
08:41:06 <exicer> Eg List is a subclass of functor, so it has to define fmap
08:41:23 <exicer> if I do fmap f [blah], how does haskell know which fmap to use ?
08:41:59 <jtanguy> exicer: yes, because you told it which function to use for fmap when you told it that lists are functors
08:42:22 <exicer> so it looks through the definition I made when it sees the argument is of that type ?
08:42:24 <jtanguy> adrian2_: here you are in a special case of foldr1
08:43:12 <exicer> I guess that is the only way it can work, it just surprised me a bit :P
08:43:17 <jtanguy> adrian2_: are you still here?
08:43:45 <adrian2_> jtanguy: gotta go... I will work this based on you help
08:43:59 <jtanguy> no problem ;)
08:44:23 <adrian2_> jtanguy: have a nice evening :)
08:44:43 <jtanguy> exicer: instances of a typeclass are quite different from subtypes
08:44:51 <jtanguy> adrian2_: you too ^^
08:45:37 <jtanguy> exicer: when you say `instance Functor List`, you have to prove it why it is a Functor, by providing the implementations of the required functions
08:46:04 <merijn> heh
08:46:07 <hpaste> applicative annotated “lasticot's problem” with “lasticot's problem 4.0” at http://lpaste.net/91669#a91670
08:46:12 <exicer> jtanguy: Okay - I think I get that, but I'm a bit imprecise with the terminology :)
08:46:20 <jtanguy> :)
08:46:31 <applicative> haasn: ^^^
08:46:36 <jtanguy> i have to go, kthxbye ^^
08:46:42 <merijn> Ok, I really can't figure out how to turn an "Effect m a" into "Producer a m r" with pipes...
08:47:47 <haasn> applicative: doesn't seem as clean for some reason :P
08:48:07 <haasn> but I guess the absence of the runIdentityP and phantom () parameter and stuff is a win
08:48:39 <applicative> haasn: yes, because of for instead of >-> >->
08:48:51 <applicative> haasn: or is that what you mean?
08:49:00 <haasn> yeah
08:49:11 <haasn> oh, btw, maybe you can help me figure out why this doesn't work:
08:49:20 <applicative> yes, its part of the new way, stdoutD or whatever used 'forever'
08:49:24 <haasn> replacing ‘yield a; go a’ by ‘liftM2 (>>) yield go’
08:49:33 <haasn> err
08:49:37 <haasn> ‘liftM2 (>>) yield go a’
08:50:01 <haasn> oh it does work
08:50:06 <haasn> looks like I forgot the ‘a’ the first time around as well
08:50:22 <haasn>   where go x = mappend x <$> request () >>= liftA2 (>>) respond go
08:50:25 <haasn> much cleaner :)
08:51:55 <haasn> go x = fmap (x <>) await >>= liftA2 (>>) yield go -- even cleaner I guess
08:51:57 <DMcGill> is there one of sequence or traverse or something that's equivalent to `foldl (*>)' or `foldl (>>)'?
08:52:12 <merijn> DMcGill: sequence_ ?
08:52:20 <merijn> DMcGill: and/or traverse_
08:52:28 <merijn> :t F.traverse_
08:52:30 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
08:52:33 <DMcGill> I need the value at the end though
08:52:37 <DMcGill> I have
08:52:59 <DMcGill> > let last = runIdentity . foldl1 (*>) . map Identity in last [1,2,3]
08:52:59 <haasn> :t fmap last . sequence
08:53:00 <lambdabot>   3
08:53:00 <lambdabot> (Monad f, Functor f) => [f b] -> f b
08:53:46 <merijn> DMcGill: last <$> sequence x ?
08:54:00 <DMcGill> I'm trying to define my own `last`
08:54:24 <DMcGill> using Identity
08:54:39 <DMcGill> for, well, no real reason
08:55:05 <DMcGill> it doesn't have to be Identity I suppose, but I'm trying to get a little practice in with Traversable, Foldable, Applicative and co
08:55:24 <haasn> :t ala Last foldMap
08:55:25 <elliott> try using Last.
08:55:26 <lambdabot> Foldable t => t (Maybe a) -> Maybe a
08:55:33 <haasn> oh not quite
08:55:57 <DMcGill> Last sounds like what I want
08:56:11 <haasn> but close enough :)
08:57:57 <DMcGill> > ala (Last . Just) foldMap $ [1,2,3]
08:57:58 <lambdabot>   Occurs check: cannot construct the infinite type:
08:57:58 <lambdabot>    a0 = Data.Maybe.Maybe a0
08:58:24 <haasn> DMcGill: ‘ala’ ignores its first parameter, it's only used to get the right Wrapped instance
08:58:37 <DMcGill> or rather then just `foldMap (Last . Just)`
08:58:39 <DMcGill> cool, thanks
08:58:44 <DMcGill> that's problem 1 of the 99 problems down!
08:59:22 <haasn> DMcGill: getLast . foldMap (Last . Just)
08:59:33 <donri> i need a name for "strict mode" that isn't "strict" :p (e.g. -Werror)
08:59:47 <DMcGill> stern
09:00:35 <donri> "restrictive" a bit long
09:01:21 <byorgey> "prudish"
09:01:37 <DMcGill> "naggy"
09:01:54 <DMcGill> frigid
09:01:57 <donri> maybe i'll just go with "unpermissive" and call -fdefer-type-errors permissive :p
09:02:27 <DMcGill> "restrictive" a bit too long, maybe I'll just go with "unpermissive" - donri
09:02:28 <tikhon> I like "naggy"
09:02:36 <donri> haha
09:02:56 <DMcGill> I do actually like "stern" tbh
09:03:01 * hackagebot data-extra 2.1.0 - Extra utilities for working on Data.* types.  http://hackage.haskell.org/package/data-extra-2.1.0 (ChrisDone)
09:03:09 <lykos> I have a quick question about the Leksah IDE
09:03:10 <DMcGill> it converys the message, is a really common word
09:03:20 <lykos> It's rather silly, but I can't seem to find the terminal output in the program.
09:03:37 <lykos> As in, when I run ( main = putStrLn "hello there")
09:03:53 <lykos> I just get some value ( =========127=========)
09:04:44 <donri> DMcGill: also need an antomyn and maybe "lenient" would be boring / too related to "strict"... how about grim vs gentle :D
09:05:05 <DMcGill> stern/forgiving?
09:05:12 <DMcGill> gentle could work
09:05:18 <tdammers> smooth
09:05:20 <tdammers> :P
09:05:29 <tdammers> moxious :D
09:05:30 <DMcGill> nah, I like lenient
09:05:47 <haasn> “tsun” and “dere”
09:05:47 <DMcGill> "willingToTurnABlindEye"
09:06:08 <byorgey> lykos: there should be a separate tab for the terminal output I think?
09:06:11 <DMcGill> "mayLetYouOffThisOnce"
09:06:55 <DMcGill> the antonym to 'strict' has always been 'nonstrict' or 'lazy' though, I don't really think that 'lenient' is reserved for it
09:07:06 <donri> DMcGill: that's why i don't want to use strict
09:07:19 <donri> it's used in most other languages to mean "restrictive" though
09:08:38 <monochrom> poker face, lolcat
09:08:41 <DMcGill> ah, well I couldn't really speak for that
09:08:47 <Demos> what about just pedantic
09:09:00 <donri> hm i like it
09:09:03 <DMcGill> pedantic/groovy?
09:09:08 <donri> need a good antonym though
09:09:08 <monochrom> oh, I know. angry bird, lol cat. :)
09:09:13 <DMcGill>  /laidback
09:09:32 <Demos> how about -javascript
09:09:42 <donri> ;)
09:10:02 <geekosaur> -agda / -php
09:10:35 <donri> enforcing/permissive it's what selinux uses :p
09:10:40 <lykos> byorgey: I can't find it
09:11:49 <lykos> byorgey: also, it doesn't seem to be giving errors when I use invalid syntax
09:15:29 <xplat> aristid: not currently, why, you want it?
09:15:50 <aristid> xplat: i'm curious how you achieved the good performance :)
09:16:07 <aristid> xplat: you should use a real hash though. md5 is lame! :)
09:16:17 <xplat> aristid: i did the simplest thing possible and the libraries did the rest
09:16:27 <aristid> xplat: did you use vector?
09:16:28 <monochrom> which real hash do you recommend?
09:16:43 <aristid> monochrom: SHA-256 :)
09:17:25 <hpaste> haasn revised “lasticot's problem”: “lasticot's problem” at http://lpaste.net/91669
09:17:28 <xplat> aristid: i used cryptohash, i have no idea what it uses under the hood.  it's not some kind of homemade md5, i was just happy there wasn't a lot of added overhead
09:17:45 <aristid> xplat: oh so you basically just pipified cryptohash?
09:17:54 <hpaste> DMcGill pasted “SecondLast monoid” at http://lpaste.net/91672
09:17:57 <exicer> What is the name of (->) ?
09:18:01 <exicer> If I were to google for it
09:18:05 <xplat> aristid: more like foldified
09:18:26 <DMcGill> I know it's stupidly engineered and using monoids is entirely unnecessary, but is that a reasonably good way of doing it?
09:18:28 <aristid> xplat: hpaste it:P
09:18:44 <finity> exicer: Hmm. Abstraction? Implication?
09:18:46 <Demos> exicer, I think reader
09:19:01 <xplat> probably i can do that with the key module, the rest is simply wrappers or stuff that was already posted on the list
09:19:11 <exicer> Thanks!
09:19:16 <xplat> of course this is 'simply wrappers' too ...
09:22:02 <xplat> hpaste.org is being very slow
09:22:09 <DMcGill> use lpaste.org
09:22:17 <DMcGill> lpaste.net even
09:22:18 <DMcGill> sorry
09:22:37 <DMcGill> hpaste.org got moved
09:23:14 <aristid> xplat: it's slow because chrisdone moved to a new server and hpaste.org still points to the old one, which is not running anymore ;)
09:23:59 <xplat> i see how it could take a while to load in that case
09:27:19 <geekosaur> and I think has no control over where the DNS for hpaste.org points
09:27:45 <donri> bos controls that domain IIRC
09:28:07 <DMcGill> I want to make a Monoid `newtype NthLast (n :: Nat) a = NthLast (Either Int a)` such that `mempty :: NthLast n a = Left (sing :: n)', mappend (Left 0) (Right a) = Right 0; mappend (Left n) (Right a) = Left (n-1)
09:28:25 <DMcGill> what kind of extension/singleton library do I need?
09:29:13 <DMcGill> there's a typo or two in my above sketch, but I hope it's clear what I mean
09:29:40 <DMcGill> or is it just a terrible idea?
09:31:21 <DMcGill> I think I need to keep a list really, so that `getNthLast $ [Right 1, Right 2, Right 3] <> [Right 4, Right 5] :: NthLast 3 Int' behaves as expected
09:32:05 <hpaste> xplat pasted “multihash analyzer” at http://lpaste.net/91673
09:32:37 <xplat> aristid: ^
09:33:03 <dmwit> enthropy: I created http://ghc.haskell.org/trac/ghc/ticket/8119 based on our discussion the other day.
09:34:20 <aristid> hmm:)
09:36:22 <enthropy> dmwit: so you are piron then?
09:36:58 <hpaste> applicative annotated “lasticot's problem” with “lasticot's problem 4.0 (annotation)” at http://lpaste.net/91669#a91674
09:37:03 <aristid> xplat: it looks like F.Fold was _made_ for wrapping crypto hashes :D
09:37:32 <dmwit> enthropy: Oops, I guess my secret identity is out. =P
09:37:32 <applicative> haasn: this may be more whats intended now; something i'm doing wrong still
09:37:34 <dmwit> (yes)
09:37:47 <dmwit> ?where rot13 -- yitz, just sayin'
09:37:47 <lambdabot> (let e[a,b,c]=zip[a..c]$[b..c]++[a..]in map$fromMaybe<*>(`lookup`(e"anz"++e"ANZ")))
09:37:54 <dmwit> (I helped write that!)
09:39:10 <mauke> tr/A-Za-z/N-ZA-Mn-za-m/r
09:39:30 <enthropy> dmwit: I think ghc-7.4 didn't have this bug
09:39:38 <dmwit> enthropy: Oh, really?
09:40:31 <dmwit> enthropy: Cool, you're right!
09:40:40 <xplat> aristid: there's several senses in which that is true, although the most obvious one would be a slight exaggeration
09:40:47 <aristid> dmwit: i love the fromMaybe<*> trick
09:40:54 <dmwit> Maybe I should relabel it a bug instead of a feature request, then.
09:40:58 <aristid> :t (<*>) fromMaybe
09:40:59 <lambdabot> (a -> Maybe a) -> a -> a
09:41:09 <bryanvick> can anyone recommend intro papers on parer combinators/monadic parsers?
09:41:29 <dmwit> aristid: cute, huh? =D
09:41:35 <aristid> xplat: i love exaggeration more than anything in the world
09:41:59 <dmwit> bryanvick: I still recommend the Parsec tutorial, even though it is getting more and more out of synch with the actual API.
09:42:09 <dmwit> bryanvick: The big ideas still shine through quite nicely, though, I think.
09:42:19 <bryanvick> dmwit: thanks
09:42:45 <monochrom> yikes, piron = dmwit?!
09:42:53 <dmwit> bryanvick: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
09:42:54 <enthropy> dmwit: another example is http://code.haskell.org/~aavogt/flip_zipWithN/
09:43:14 <xplat> aristid: your words and actions speak with a single voice :)
09:44:04 <dmwit> enthropy: Oof. That's a bit more to digest.
09:45:08 <enthropy> the inferred types in the comments of the P4.hs are lies if you use ghc-7.6
09:46:24 <DMcGill> Why is it whenever I program Haskell for more than about half an hour I end up with about 20 tabs open to Hackage pages, many of the duplicates?
09:46:44 <banister_> cos your'e a noob
09:46:45 <banister_> jk :)
09:47:03 <ReinH> DMcGill: hackage is the tvtropes of programming
09:47:32 <DMcGill> I think it's because I've added hoogle to chrome search, so I can just do `alt-tab, ctrl-t, "hoogle blah", enter'
09:47:47 <cschneid> hmm, how do you add hoogle to chrome?
09:47:56 <Maior> DMcGill: I went one further and added it to Alfred
09:48:07 <Maior> DMcGill: alt+space, hoogle blah
09:48:09 <aristid> cschneid: chrome will automatically recognize it as a search engine.
09:48:35 <aristid> cschneid: you have to rename it to "hoogle" instead of the default which is the full domain name
09:50:45 <cschneid> aristid: nice. figured that out
09:56:50 <applicative> I wonder if theres a text version of the parsec tutorial around? someone like bryanvick should just update it and get it over with
09:57:55 <sm> the FunGEn game engine's main module is Graphics.UI.Fungen. I think renaming to Fungen is better, any thoughts ?
09:58:13 <haasn> Fungi
09:58:28 <geekosaur> (it's fungible)
09:59:02 <applicative> FunGEnT
09:59:20 * sm facepalms
10:03:24 <ReinH> GenFun
10:03:35 <ReinH> for all your generic fun monad needs
10:03:47 <ReinH> or for generating fun. I think that's the joke, isn't it.
10:03:49 <ReinH> woops
10:04:57 <sm> ReinH: it came from Function Game Engine, but I too think of it as Fun Generator
10:05:24 <sm> in an sort of optimistic forward-looking way
10:07:33 <ReinH> :D
10:07:49 <sm> ok.. leaving it under Graphics.UI for now, I don't want to bump the major version today
10:07:51 <ReinH> sm: it's a lazy fun generator
10:08:04 <sm> aha.. how to force it ??
10:08:13 <ReinH> this kills the fun
10:08:26 <ReinH> something something deepseq
10:09:13 <sm> The fun will now be strictly applied. Begin enjoyment.
10:09:27 <ReinH> lmao
10:09:38 <ReinH> ah Haskell jokes
10:13:47 <hpaste> applicative annotated “lasticot's problem” with “lasticot's problem 4.0, sensible” at http://lpaste.net/91669#a91675
10:14:30 <applicative> haasn: here's the right way, I'd think. I forgot about P.scanl
10:14:31 <haasn> applicative: neat
10:14:40 <haasn> yes P.scanl is exactly the function I was missing in pipes 3.x
10:14:48 <applicative> and thus made a mountain out of a molehill ...
10:14:50 <applicative> yeah
10:15:03 <haasn> your previous version was a mess :P
10:15:14 <applicative> haha
10:15:26 <applicative> when in doubt, add state
10:15:47 <haasn> now only needs P.fold = P.scanl mappend mempty
10:15:49 <haasn> or similar
10:15:51 <applicative> all program logic should be a matter of carefully adjusting the depth of lift $ lift $
10:16:12 <haasn> with ‘hoist’ thrown in for good measure
10:16:18 <applicative> I regret that I have but one 'lift' to give for  my programming language
10:16:50 <zomg> liftM4 = unliftM1 . liftM5
10:17:12 * haasn wants unlift
10:17:29 <ReinH> applicative: but... but... that's why you write convenience accessors for monad transformer stacks...
10:17:36 <ReinH> so you don't have to remember that shit
10:17:40 <haasn> :: MonadTrans t m a => t m a -> m a -- think about all the useless runFooT functions this would replace! :)
10:18:08 <applicative> what about all the ones that need r or s ...
10:18:13 <joelteon> runFoot
10:18:21 <ReinH> now with more fun
10:19:44 <haasn> applicative: simple, just add a Reifies t s constraint ;)
10:21:24 <xplat> it seems almost pointless to use pipes for that since you pull the entire stdin into memory anyway
10:23:17 <xplat> i guess if you use something other than strings it could make sense
10:24:01 <xplat> like running total of some numbers
10:25:01 <dmwit> :t guard
10:25:02 <lambdabot> MonadPlus m => Bool -> m ()
10:25:20 <dmwit> :t (<$)
10:25:21 <lambdabot> Functor f => a -> f b -> f a
10:25:35 <dmwit> :t \a b c -> a <$ b == c
10:25:36 <lambdabot>     Precedence parsing error
10:25:36 <lambdabot>         cannot mix `<$' [infixl 4] and `==' [infix 4] in the same infix expression
10:25:48 <haasn> :t set mapped
10:25:48 <lambdabot> Functor f => b -> f a -> f b
10:27:10 <haasn> > mempty :: Text
10:27:11 <lambdabot>   Not in scope: type constructor or class `Text'
10:27:23 <haasn> > mempty :: T.Text
10:27:25 <lambdabot>   Not in scope: type constructor or class `T.Text'
10:27:35 <haasn> doesn't lambdabot have this?
10:29:01 <dmwit> :t undefined :: Data.Text.Text
10:29:02 <lambdabot> Data.Text.Internal.Text
10:29:08 <dmwit> > mempty :: Data.Text.Text
10:29:10 <lambdabot>   Not in scope: type constructor or class `Data.Text.Text'
10:29:12 <dmwit> Seems not.
10:29:14 <haasn> heh
10:36:19 <haasn> applicative: how come “for P.stdin (lift . putStrLn)” is more idiomatic than “P.stdin >-> P.stdout”?
10:36:58 <haasn> it seems like your code would be valid as “main = run $ P.stdin >-> P.scanl (<>) "" >-> P.stdout”
10:38:09 <haasn> also, a minor deviation from the built-in P.scanl and the ‘fold’ I defined in my pipes-3 version is that P.scanl outputs "" first before collecting any input, so you get a blank line at the beginning
10:38:43 <haasn> sounds like pipes is missing a P.scanl1 :)
10:39:29 <applicative> haasn: right, he has gotten rid of P.stdout if I understand
10:39:58 <applicative> one is to do for ... lift.putStrLn instead of >-> P.stdout
10:40:22 <applicative> haasn, this is what sent  me on a wild goose chase, on reflection. I was trying to do without >->
10:40:48 <applicative> haasn: yeah I noticed that about P.scanl
10:42:54 <applicative> stdout can be defined as foreverK (lift.putStrLn) haasn
10:43:02 <applicative> or something like that
10:43:10 * hackagebot esqueleto 1.3 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3 (FelipeLessa)
10:50:40 <hackage> When submitting packages to Hackage, how does one enable links to the modules? I submitted one some hours ago and they're not there yet, do I wait?
10:51:21 <monochrom> hackage has become self-aware!
10:51:37 <hackage> Probably the least threatening entity to become self-aware :)
10:52:19 <haasn> until it figures out how to engineer biochemical weapons using lens type signatures
10:52:30 <geekosaur> just wait; every so often the buildbot builds modules and generates the documentation, if the build succeeds (this does depend on any necessary C libraries being on the buildbot) the doc links will be updated
10:52:37 <hackage> Right, figured as much
10:52:41 <hackage> Thanks geekosaur
10:52:44 <monochrom> there is probably nothing you can do. delayed building and build failures are causes of docs not showing up on hackage.
10:53:38 <hackage> I'd also like to write about the package a bit so I guess I need to start a blog or something, I need suggestions about a good blog for writing about Haskell :)
10:53:47 <monochrom> and build failures are caused by some C libs not available on hackage
10:54:24 <applicative> hackage: oh my god!
10:54:49 <hackage> I hope I'm not scaring fellow users
10:55:12 <hpaste> applicative annotated “lasticot's problem” with “lasticot's problem 4.0 retro” at http://lpaste.net/91669#a91676
10:55:20 <edwardk> :t iso Unsafe.Coerce.unsafeCoerce Unsafe.Coerce.unsafeCoerce
10:55:20 <lambdabot> (Functor f, Profunctor p) => p a (f b) -> p s (f t)
10:55:51 <haasn> applicative: I still have P.stdout in HEAD, fwiw; also note that the stdout version that comes with it does a lot more than just lift . putStrLn
10:56:09 <applicative> haasn: oh maybe i was reasoning a priori
10:57:05 <haasn> applicative: in particular, it goes via ‘try’ and then checks for an IOError {ioe_type = G.ResourceVanished}
10:57:09 <applicative> oh no I don't see it in Pipes.PRelude
10:57:17 <haasn> https://github.com/Gabriel439/Haskell-Pipes-Library/blob/master/src/Pipes/Prelude.hs
10:57:17 <applicative> oh oh, yes, pipes safe?
10:57:27 <applicative> gah
10:57:28 <haasn> this is the HEAD , right?
10:58:09 <applicative> hah, patch Added 'toHandle' and 'stdout' two days ago
10:58:14 <haasn> oh :)
10:58:39 <applicative> but that means, they were brought back. maybe this makes sense. the dumb one is easy to write; this does more
10:58:53 * haasn will have to read into Pipes.Tutorial 4.0-style again to figure out what ‘for’ is and what it's done to my familiar ‘>->’
10:59:33 <applicative> it uses the stuff flowing downstream as if it were the return value
10:59:38 <applicative> 'for'
11:00:02 <applicative> so you bind x -> Pipe a b c d to the xs flowing downstream
11:00:14 <munro> https://gist.github.com/munro/7f033e1f6cea70a52fdc <-- hey, I was wondering if someone could give me feedback on how I'm writing logic...  I'd like things to flow top to bottom, left to right... or should I just give that up?
11:00:57 <haasn> but why are we suddenly using x -> Pipe a b c d -- instead of Pipe .. x ..?
11:01:15 <applicative> haasn: or as i think the docs say, it replaces each 'response' in a producer
11:01:42 <applicative> haasn: i'm not sure i grasped all the reasons, there were many; one is efficiency,
11:02:08 <applicative> the 'for' that I wrote has nothing recursive about it,
11:02:16 <applicative> but >-> P.stdout does
11:02:38 <haasn> no wonder I'm so confused; efficiency doesn't exist in my imaginary world
11:02:50 <applicative> basically in ye olde a >-> b >-> c >-> d half the pipes are non-terminating
11:03:03 <applicative> haasn: i'm behind you 100%
11:03:11 <applicative> with you i mean
11:03:48 <edkk> guys. what is the name of "f g x = if g x == x then x else f g (g x)", and is this fn in the standard lib?    (inb4 'the name is f' :p)
11:04:18 <monochrom> it probably has no name
11:04:31 <haasn> I uh.. have no idea how that function would be useful and/or common enough to be in sort of standard library
11:04:40 <haasn> oh
11:04:43 <haasn> wait, now I get it
11:04:58 <DMcGill> it looks like some sort of fix? Only with eq rather than sharing
11:05:00 <haasn> it attempts to find a fixed point
11:05:34 <edkk> I'm (thinking of) using it for a fn maxFlow :: FlowGraph -> FlowGraph
11:05:37 <monochrom> it is not in the standard library
11:05:44 <edkk> kk. thanks :)
11:06:08 <DMcGill> edkk: depending on how maxFlow is implemented, the function `fix' could work
11:06:47 <applicative> haasn: at the end of this letter https://groups.google.com/d/msg/haskell-pipes/t2A0U3sF1CM/-dl8RBE629EJ
11:07:07 <edkk> DMcGill: mm. I tried to do it with fix, but I couldn't quite grok it
11:09:33 <DMcGill> let gravitate10 n | n > 10 = n - 1; n < 10 = n + 1; n == 10 = n in fix gravitate 10 5
11:09:40 <aloiscochard> hi hackers, I'm setting up my first haskell project and following that guide: http://bob.ippoli.to/archives/2013/01/11/getting-started-with-haskell/#setup-cabal which say I should turn on library-profiling, does that still make sense?
11:09:40 <DMcGill> > let gravitate10 n | n > 10 = n - 1; n < 10 = n + 1; n == 10 = n in fix gravitate 10 5
11:09:41 <lambdabot>   Not in scope: `gravitate'
11:09:42 <lambdabot>  Perhaps you meant `gravitate10' (line 1)
11:09:46 <DMcGill> > let gravitate10 n | n > 10 = n - 1; n < 10 = n + 1; n == 10 = n in fix gravitate10 5
11:09:47 <lambdabot>   Could not deduce (GHC.Classes.Ord (GHC.Integer.Type.Integer -> t))
11:09:47 <lambdabot>    arisi...
11:10:15 <haasn> DMcGill: s/;/|/g
11:10:49 <DMcGill> > let gravitate10 n | n > 10 = n - 1 |  n < 10 = n + 1 | n == 10 = n in fix gravitate10 5
11:10:50 <lambdabot>   Could not deduce (GHC.Classes.Ord (GHC.Integer.Type.Integer -> t))
11:10:50 <lambdabot>    arisi...
11:11:04 <haasn> :t fix
11:11:05 <lambdabot> (a -> a) -> a
11:11:11 <haasn> doesn't take another parameter
11:11:13 <haasn> it's not like iterate
11:11:28 <DMcGill> > let gravitate10 n | n > 10 = n - 1 |  n < 10 = n + 1 | n == 10 = n in fix gravitate10
11:11:31 <lambdabot>   mueval-core: Time limit exceeded
11:11:40 <DMcGill> I wasn't expecting that to work :/
11:11:55 <DMcGill> I saw a good factorial example using fix
11:12:16 <DMcGill> which I thought I recreated for gravitate10, hmm one sec
11:13:21 <haasn> > fix (\f n -> if n < 2 then 1 else n * f (n-1)) 5 -- hopefully not this =P
11:13:22 <lambdabot>   120
11:13:49 <DMcGill> > fix (\f n | n > 10 = f (n - 1) |  n < 10 = f (n + 1) | n == 10 = f n) 5
11:13:50 <lambdabot>   <hint>:1:11: parse error on input `|'
11:13:54 <DMcGill> that was it, yes
11:14:02 <DMcGill> what do you mean "hopefully not"?
11:14:08 <haasn> because that's not really the same thing at all
11:14:19 <haasn> the fixed point here is on the argument ‘f’, not ‘n’
11:14:24 <DMcGill> I've very much confused myself here, sorry
11:14:45 <haasn> hmm
11:14:53 <DMcGill> in short: I don't really grok `fix' right now either
11:16:56 <haasn> > head . head . dropWhile ((< infinity) . genericLength) . group . iterate (`div` 2) $ 100
11:17:00 <lambdabot>   mueval-core: Time limit exceeded
11:17:03 <haasn> aaaw
11:17:18 <haasn> oh, I think genericLength is implemented the wrong way for that to work
11:17:23 <haasn> @src genericLength
11:17:23 <lambdabot> genericLength []    = 0
11:17:23 <lambdabot> genericLength (_:l) = 1 + genericLength l
11:17:29 <haasn> hmm no, should work
11:17:52 <enthropy> @type infinity
11:17:54 <lambdabot> Natural
11:18:11 * hackagebot standalone-haddock 1.1.3 - Generate standalone haddock documentation for a set of packages  http://hackage.haskell.org/package/standalone-haddock-1.1.3 (RomanCheplyaka)
11:18:22 <haasn> oh, oops; (<infinity) is a bit excessive
11:18:32 <haasn> > head . head . dropWhile ((<= (1 :: Natural)) . genericLength) . group . iterate (`div` 2) $ 100
11:18:34 <lambdabot>   0
11:19:05 <haasn> I think the explicit version edkk gave is way prettier :)
11:19:33 * haasn was going for a pointless version
11:19:44 <tikhon> > infinity
11:19:45 <lambdabot>   *Exception: stack overflow
11:19:47 <tikhon> right
11:20:06 <tikhon> where does Natural come from?
11:20:13 <tikhon> (I can guess how it's implemented.)
11:20:18 <haasn> "numbers" Data.Number.Natural
11:20:26 <haasn> it's just peano
11:20:39 <tikhon> neat
11:21:57 <banister> ReinH: can you try explaining state monad to me? :D the fact that it relies on partially applied functions as well as being a monad means it's 1 concept too many for me to intuit at my current level of noobhood :)
11:22:17 <c_wraith> banister: no, it's just a single-argument function.  no partial application.
11:22:30 <monochrom> > (\(#) -> True # False) (&&)
11:22:31 <lambdabot>   False
11:22:37 <c_wraith> State s a ≈ s -> (a, s)
11:22:39 <haasn> banister: State s a = s -> (a, s)
11:22:41 <c_wraith> It's just a function
11:22:43 <banister> c_wraith: hmm it's more that the LYAH example uses: a <- pop    and push 5   etc
11:22:46 <tikhon> > fix (1:)
11:22:47 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:22:50 <tikhon> hmm
11:22:55 <tikhon> > infinity
11:22:57 <lambdabot>   *Exception: stack overflow
11:23:00 <haasn> banister: so the ‘State s’ Monad functions are just ways to compose functions of the form s -> (a, s)
11:23:01 <enthropy> > let f z = z `div` 2 in  fix (\g y -> if f y == y then y else g (f  y)) 100
11:23:02 <lambdabot>   0
11:23:10 <banister> c_wraith: so in that case they're partially applied right?
11:23:17 <c_wraith> banister: no.  They're composed.
11:23:34 <tikhon> why does
11:23:48 <tikhon> why does lambdabot print out part of an infinite list, but not part of infinity?
11:24:03 <tikhon> like S (S (S...
11:24:11 <haasn> banister: you could do it by hand; push x s = ((), x:s); pop (s:s') = (s, s');  and then instead of do { a <- pop; push a } you'd have \s -> let (a, s') = pop s in push a s'
11:24:14 <c_wraith> tikhon: it all depends on the show instance.
11:24:18 <enthropy> > 5 :: Natural
11:24:19 <lambdabot>   5
11:24:22 <tikhon> aha
11:24:30 <tikhon> I just assumed the derived show instance
11:24:41 <c_wraith> but by enthropy's example, it clearly isn't
11:24:47 <tikhon> yeah
11:25:08 <tikhon> > read "∞" :: Natural
11:25:09 <lambdabot>   No instance for (GHC.Read.Read Data.Number.Natural.Natural)
11:25:09 <lambdabot>    arising from...
11:25:12 <tikhon> aww
11:25:14 <haasn> seems like that module could use a showNat :: Natural -> String -- function
11:25:23 <haasn> tikhon: now that would be plain evil :)
11:25:31 <tikhon> @let (∞) = infinity
11:25:32 <lambdabot>  Parse failed: Illegal character ''\136''
11:25:34 <tikhon> !
11:25:42 <c_wraith> Must be a letter
11:25:47 <tikhon> that worked on my computer in the past
11:25:47 <haasn> let oo = infinity
11:25:51 <c_wraith> @let ∞ = infinity
11:25:51 <lambdabot>  Parse failed: Illegal character ''\136''
11:25:57 <tikhon> ∞ works like an operator
11:25:58 <c_wraith> nope, just lambdabot choking on unicode
11:25:59 <nicoo> @let (+) = infinity
11:25:59 <lambdabot>  .L.hs:141:29:
11:25:59 <lambdabot>      Ambiguous occurrence `+'
11:25:59 <lambdabot>      It could refer to either `L...
11:26:03 <haasn> tikhon: lambdabot doesn't-- what c_wraith said
11:26:09 <monochrom> > (\(∞) -> True # False) (&&)
11:26:10 <lambdabot>   Couldn't match type `GHC.Types.Bool'
11:26:10 <lambdabot>                with `Control.Lens.Inte...
11:26:12 <monochrom> err
11:26:17 <monochrom> > (\(∞) -> True ∞ False) (&&)
11:26:18 <lambdabot>   False
11:26:22 <monochrom> \∩/
11:26:26 <nicoo> :D
11:26:27 <tikhon> > let (∞) = infinity
11:26:28 <lambdabot>   not an expression: `let (∞) = infinity'
11:26:33 <mauke> @undefine
11:26:33 <lambdabot> Undefined.
11:26:34 <tikhon> :(
11:27:01 <jmlaios> hello guys I have this http://lpaste.net/91677
11:27:10 <jmlaios> the simplest
11:27:13 <tikhon> too many Haskell tools choke on completely reasonable Unicode code
11:27:13 <jmlaios> hhtp get
11:27:20 <tikhon> haskell-mode, stylish...
11:27:23 <tikhon> lambdabot
11:27:48 <jmlaios> and i want to parse only 10 lines of the txt file
11:28:36 <jmlaios> how to parse the i inputstream line by line
11:28:41 <jmlaios> any ideas?
11:28:47 <geekosaur> tikhon, lambdabot at least has some reason, since IRC isn't really unicode aware
11:28:57 <tikhon> yeah, fair enough
11:29:18 <mauke> preflex: zenc ∞
11:29:19 <preflex>  z221eU
11:29:30 <mauke> preflex can do it
11:29:30 <monochrom> lambdabot didn't choke on my unicode input
11:29:55 <geekosaur> right, but you have to add "is this utf8 or iso8859-1" on every input path
11:29:55 <tikhon> I ran into that trying to make my nick to Тихон
11:30:32 <mauke> geekosaur: ... so?
11:30:46 <geekosaur> and of course you can't just do it globally because of the parts of IRC that don't handle it
11:31:17 <mauke> what do you mean?
11:33:11 * hackagebot Modulo 0.2.0.0 - Modular arithmetic via Numeric-Prelude  http://hackage.haskell.org/package/Modulo-0.2.0.0 (NikolayMurzin)
11:34:04 <geekosaur> I may be overthinking this since I don't think you can get into latin1 vs utf8 in things like the nick
11:34:38 <monochrom> that is right
11:34:53 <ion> On IRC, the nick is in SF7, not latin1.
11:35:24 <haasn> I thought ‘latin1’ doesn't exist
11:35:40 <mauke> it does
11:35:41 <geekosaur> I didn;t feel like typing out iso8859-1 again
11:35:42 <ion> I thought ‘haasn’ doesn’t exist
11:35:43 <mauke> ISO 8859-1
11:36:43 <c_wraith> latin1 is just deprecated as a name.
11:36:53 <c_wraith> Not invalid, just not the preferred name.
11:37:00 <tikhon> in favor of ISO/IEC 8859-1?
11:37:03 <c_wraith> yeah
11:37:08 <tikhon> much easier to remember!
11:37:18 <c_wraith> that's why they picked it
11:37:22 <mauke> also, latin9 is ISO 8859-15
11:37:48 <ion> Hmm. If i ever write an IRC client, i’ll make it {de,en}code nicks in SF7.
11:37:55 <ion> That would be fun.
11:38:14 <mauke> ISO 9899:1999
11:38:38 <tikhon> I wrote a chat client which supported LaTeX math in nicks. Good times.
11:39:23 <mauke> LᴀTᴇX
11:39:35 <c_wraith> \LaTex is easier to type.
11:39:49 <ion> What is this \LaTex thing?
11:39:52 <monochrom> what is SF7?
11:40:19 <tikhon> it's a typesetting system
11:40:31 <c_wraith> It's really a bunch of macros on top of TeX
11:40:40 <c_wraith> Designed for writing books and academic papers
11:40:42 <geekosaur> SF7, SS7...
11:41:36 <monochrom> how is it related to IRC and nicks?
11:42:51 <monochrom> am I a moron for not knowing this?
11:43:11 * hackagebot Modulo 0.2.0.1 - Modular arithmetic via Numeric-Prelude  http://hackage.haskell.org/package/Modulo-0.2.0.1 (NikolayMurzin)
11:43:16 <ion> monochrom: A variant of ASCII for Finnish and Swedish. In it, {|[\ stand for äöÄÖ and }^]~ stand for something else i’m not sure of. Some of those must be å and Å. This is why the nick user{ is equivalent to the nick USER[
11:43:25 <ion> s/variant/modified version/
11:43:30 <monochrom> oh, that one
11:43:58 <ion> tikhon: I know what \LaTeX is but i’m confused about this \LaTex thing. ;-)
11:46:24 <monochrom> oh, "typesetting" refers to LaTeX, not SF7
11:46:37 <c_wraith> yes
11:46:49 <haasn> monochrom: oh! I made that mistake too. I was still confused
11:47:44 <foxnewsnetwork> sorry if this is a dumb question, but I'm using the PostgresSimple package and I'm having trouble implementing the FromRow typeclass on an object which may have null values in the database. Anyone know how I can get get field to give me a Maybe value?
11:50:55 <hpaste> enthropy pasted “liftIO for IO-taking functions?” at http://lpaste.net/91678
11:55:03 <haasn> does http://hackage.haskell.org/packages/archive/monad-control/0.3.2.1/doc/html/Control-Monad-Trans-Control.html seem relevant?
11:55:09 <haasn> enthropy: ^
11:56:08 <haasn> actually I have no idea
11:59:21 <ion> After a bit of research, i think SF7 is ISO646-FI.
12:00:03 <tikhon> oh yeah, makes sense—entirely intuitive
12:00:06 <c_wraith> the -FI meaning "Finland"?
12:00:27 <ion> c_wraith: Yeah. ISO646-SE is identical, too. IRC was developed in Finland.
12:00:43 * carter EVERYONE: its still possible to register for ICFP programming contest
12:00:45 <carter> http://research.microsoft.com/en-us/events/icfpcontest2013/
12:00:52 <tikhon> woah
12:00:56 <tikhon> I've already registered
12:01:03 <tikhon> who else is doing it?
12:01:11 <carter> i allegedly might
12:01:16 <ion> ISO646-FI:  !"#¤%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZÄÖÅ^_`abcdefghijklmnopqrstuvwxyzäöå‾
12:01:26 <tikhon> the problem is that I haven't been able to rustle up anyone else to work with
12:01:38 <carter> tikhon you already registered?
12:01:42 <carter> i'm already on a team
12:01:56 <tikhon> I registered, yeah
12:02:03 <tikhon> I thought the deadline was sometime yesterday
12:02:11 <simukis_> too many steaps to register :(
12:02:12 <carter> they changed their minds
12:02:15 <tikhon> aha
12:02:16 <carter> idk
12:02:20 <Adeon> when does the contest start exactly
12:02:26 <acowley> carter: Does the individual doing the GSoC on records have a blog or anything?
12:02:28 <tikhon> tomorrow at 5 PDT
12:02:28 <carter> "the deadline has already passed, but you can still registers"
12:02:36 <carter> acowley: adam gundry?
12:02:54 <carter> acowley there was stuff on an emailing list
12:02:59 <carter> and stuff on trac wiki
12:03:09 <carter> acowley: pester edwardk  about it
12:03:13 <acowley> carter: I meant specifically for the project, but I can search based on the name
12:03:16 <edwardk> ^-- ?
12:03:27 <acowley> here we go, http://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Plan
12:03:28 <carter> edwardk: the lensy fields stuff
12:03:34 <edwardk> what about lensy fields?
12:03:42 <edwardk> oh
12:03:45 <edwardk> gundry
12:03:47 <carter> yes
12:03:49 <acowley> edwardk: I'm just curious what's happening with that
12:03:50 <edwardk> yeah thats coming along
12:03:57 <haasn> lensy fields?
12:03:58 <acowley> edwardk: carter got a bunch of people on twitter very excited
12:04:09 <carter> it was an accident
12:04:22 <carter> i just said things might land in 7.8 allegedly
12:04:36 <carter> or at least i allege i alleged that
12:04:38 <acowley> I'd be really impressed if a SoC for this year got into 7.8
12:04:44 <haasn> oh, the ghc proposal
12:06:29 <edwardk> anyways, the proposal as it stands would let field accessors be used directly as data-lens/fclabels/accessors style lenses
12:06:38 <edwardk> and let them be upgraded to lens style lenses with a combinator
12:06:51 <edwardk> so you could in theory retire most of your lens template haskell code
12:07:10 <edwardk> this would work for any field that didn't have a higher rank type.
12:07:25 <edwardk> and you'd get the ability to use the same field name across multiple data types
12:07:43 <edwardk> overall its a pretty solid proposal
12:07:50 <acowley> same name at different types?
12:07:55 <edwardk> yeah
12:07:59 <acowley> awesome
12:08:28 <acowley> Now we just need to make headway on Foldable and Traversable in the Prelude and we'll have a real programming language here!
12:08:31 <edwardk> we're trying to make it so that when you use the combinator to lift a field accessor into a lens-style lens it can even do type-changing assignment
12:08:44 <edwardk> that can work, the question is getting folks to understand the complexities
12:08:57 <edwardk> we're going to target 7.10 for Foldable/Traversable
12:09:12 <edwardk> the committee is all on board, we just need some time to implement it
12:09:26 <edwardk> and we formed the committee too close to the release of 7.8
12:09:29 <acowley> I think tying a prelude to a LANGUAGE pragma is probably the right thing
12:09:38 <edwardk> meh
12:10:04 <edwardk> i just want to fix the Prelude so base doesn't export two versions: a good version and a dumb version of every combinator and then force everyone to have the dumb version in scope ;)
12:10:12 <edwardk> we can play games with splitting the Prelude up in 7.12
12:10:12 <haasn> we still need to figure out “over l f . over l' g” where l/l' share types, no?
12:10:32 <edwardk> haasn: no thats solved too, but won't be in this release
12:10:47 <haasn> what was the name for that solution again?
12:10:54 <acowley> Hm, yeah. I think the racket people have the right idea with language pragmas, but compatibility between such "languages" is an issue
12:10:56 <haasn> is it in HEAD?
12:11:10 <edwardk> https://github.com/ekmett/lens/issues/197 describes the shape of the solution
12:11:16 <edwardk> with the new machinery its easier
12:12:05 <edwardk> we can take a data type Foo a = Foo { quux :: a, quaffle :: a }   and make another one where the variables are independent per field, data ExposedFoo a b = ExposedFoo { quux :: a, quaffle b }
12:12:13 <edwardk> then there is an isomorphism between Foo a and ExposedFoo a a
12:12:30 <edwardk> now instead of working with myFoo & quux .~ 12 & quaffle .~ 34
12:12:50 <edwardk> you instead use myFoo & exposed %~ \r -> r & quux .~ 12 & quaffle .~ 34
12:13:07 <haasn> ah
12:13:11 <edwardk> so your intermediate steps can go through ExposedFoo a b   instead of having to change both 'a's at the same time
12:13:22 <edwardk> the name is exposed    so that we can have the 'over exposed' pun ;)
12:13:37 <edwardk> but also because it exposes the type parameters for each lens
12:13:58 <edwardk> this is the minimalist solution that can work today.
12:14:37 <edwardk> r { x = s, y = t} can desugar into the moral equivalent of that eventually, but for now, it can suffice to just have type changing lenses available and we can retrofit the exposed machinery on after
12:18:46 <c_wraith> edwardk: why default to data-lens style lenses?
12:18:46 <edwardk> c_wraith: foo . bar    means the opposite in lens as with function composition
12:18:46 <c_wraith> oh
12:18:46 <edwardk> le bar . le foo   or whatever can be done
12:18:46 <c_wraith> Ok, that's a pretty good reason
12:18:46 <edwardk> where le embeds a field accessor into a lens
12:18:46 <edwardk> brb
12:18:46 <c_wraith> is it bad that I read it as "little endian" >_>
12:18:46 <acowley> Whoa, that's kind of a wild solution
12:19:18 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
12:19:20 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
12:19:20 --- names: list (clog EvilPenguin paddymahoney mjs2600 sleepynate ulfdoz nominolo bananagram Thra11 Qfwfq_ sxn tauntaun LMolr kmrhb tearful rachit7 TaylorJoe ehaliewicz copumpkin phytobiological2 papyrus schell hrehf_ ByronJohnson dav petapetapeta dgpratt manung BeardedCoder hannese lazyvalue seliopou Rarrikins favonia flebron foxnewsnetwork Alpha64_ ecube nexx paullik bamboo acowley wole resnik FreeFull Luser Zenol twanvl_ azm Okasu hattusili_III banister jssanders)
12:19:20 --- names: list (mizu_no_oto Taneb senorflor virvel k0001 piotrm0 mellum Neqoxec lcfrs sferry aloiscochard venice c_wraith OlegYch edkk harovali1 ozataman_ scshunt insejn Velpoman cdidd uvelichitel conehead message144 ijp Desheng edwardk ts33kr Guest85956 konundra fizbin schlicht_ kylcarte solrize_ d_arcy Tritlo milessabin_ ptc wbruce gentleben exitmouse joelb kadoban rmrf flux0r pkrnj vk_ primitive arborist ErkiDerLoony h4199 bos_ jorick _justjust Ankhers bryanvick tommd)
12:19:20 --- names: list (chidy joehillen simukis_ eduardo_ nimish datura cfricke Krakarn c-rog bogdanp BobFunk trism dubsg burp YoungFrog alszar marsam threesome chirpsalot ljsc mhooge zvrba tiffany lpvb Apocalisp breck7 b1collector DMcGill morolin coeus bytbox levi jamestastic lunarjar raichoo Eduard_Munteanu Shin-LaC ghorn yogurt_truck Caztiel kobain WraithM resttime osa1 Nshag matheus23 Twey corkexaminer paintcan wting Demos beckerb Arkantos Afish danharaj jang1 Moataz-E cads)
12:19:20 --- names: list (DexterLB totos__ shesek vijaykiran pmade tadeo skchrko adrian2 dabradley DrCode chenwl_ tehroflmaoer alang LazyTechGuy lambdanaut glosoli b2coutts balnaves morazow federkasten jchild wolfnn udoprog joneshf-laptop csakatoku gertc mirsal Pullphinger bartavelle amathew mgile JobV spion Wuzzy whaletechno erochester thalassarche Quadrescence pygospa aoh arnsholt danald walter dgvncsz0f Pranz dschoepe akurei shreesh Noldorin Nik05 elediaz Ov3rload jonkri)
12:19:22 --- names: list (JuanDaugherty caleb_9 Wizek mceier kstuart edsko M-ou-se chuzz nooodl Sculptor egblu3 tomh- tpsinnem q66 Entroacceptor pkkm seschwar_ k00mi snikkers ioanel kofno zacts lemao peddie_ kennyd ssbr fikusz thunderrd phyrex1an zl64c djcoin xexonixxexillion mantovani cynick taruti jobstijl sdx23 julmae diabel232 bduc arkx donri hamishmack so Mon_Ouie dwierenga mokus kludge` perlite Bwild cronject Kuraitou fergusnoble tg doomlord Alice3 aford xcv m3ga dented42)
12:19:22 --- names: list (SoupE brandonw tudalex allsystemsarego steshaw threesteps marr xinming predator117 adnap solrize folone joe9 danvet Reite Kabaka nilg shintah stepkut rodrigovidal zhulikas goldkatze vili Spaceghost [mth] doshitan Jonno_FTW otto_s Philonous preflex mauke shanse wtw hiptobecubic sellout- NihilistDandy peddie brisbin augur hiroakip Igloo dreixel_ RichyB Boney drbean apaku biscarch gpampara brainwash plucas meretrix apples` miloshadzic crdueck tsou andrewsw)
12:19:22 --- names: list (smlgs joneshf-work Counter-Strike dolio callen rasmusto epta enthropy jlaire isomorphic mcbonz Natch ktosiek zrot dkasak_ joefiorini Tinned_Tuna davidt_ ceii niko foxnorth Amadiro tensorpudding gbeshers swistak35 simon eacameron supersym finity anon123 seq99`` xymox tikhon bbloom uu1101 Luke hive-mind s00pcan xilo saml MrFahrenheit otulp Cerise Puffton weie_ mannyv ismlages torkjak idoru sunfun cheezey phienone ccxCZ Tehnix listofoptions jaimef machisuji)
12:19:22 --- names: list (linux_noob_666 gthorslund felipe_ Adios neena DT` cognominal bicgena charlesofarrell_ uranther steshaw_ ski bsmt nkpart EpicOut Athas joogi Liskni_si tomaw rpenguin_ pjstadig hpc aristid guerrilla iulian flowsnake dpwright KitB tulcod ousado osfameron sgso purefn1 junsuijin ivan` chrisdotcode_ mlamari jlamothe blackdog adimit mgsloan1 sirspazzolot alpounet dju marienz yam araujo leifw [swift] Mortomes McManiaC shergill tavelram dmwit epsylon parcs Excureo)
12:19:22 --- names: list (DarkFox algae scottschecter Tarential dino- mee hape01 cajla Work_jack palmje mrshoe Ke FireFly saep Bio kakos tridactyla SegFaultAX pdxleif BigEndian Ycros n-dolio jrslepak frontendloader _br_ yiannis_t Hafydd hiratara dsantiago Maxdamantus rfw obcode jeff_s1 wunki monochrom ninegrid amatsu `0660 tertl3 Jaxan ozataman vsayer LevelOneDev Nimatek gereedy Enigmagic twn ethercrow jdoliner dogmaT dexter1 tomejaguar cmears centrinia adlan annulus- orospakr)
12:19:22 --- names: list (gambogi Squid_Tamer munro Khady robinbb-freenode oldmanstan Adeon DustyDin1o jbauman IanKelling SLi leroux carter bobry demolithion satshaba1 satshabad brixen dyreshark mmathis maksbotan gilbertw1 lambdabot bscarlet Iceland_jack lenstr Will| tahu mimi_vx PHO_ mikee Jello_Raptor vehk eyck ab9rf canissimia idnar stass Gracenotes threedaymonk Sunhay_ DigitalKiwi wollw acfoltzer stvc MoALTz cschneid jml ParahSail1n Lemmih qz mietek blakesmith mstksg lightquake)
12:19:23 --- names: list (isenmann solancile floatingman canta mjo mortberg Raynos tylergillies_ c_14 stepcut nik_89 thorsten` raft tshirtman reactormonk helgikrs fxrh inr Cale valdyn dqd colah jyyou xnyhps wormphlegm dropdrive sclv anhall djahandarie osnr machisuji_ mike2 Tekerson sajith KaneTW arkeet tunixman heath kloeri Odd_Bloke FUZxxl mxf knyppeld1nan divarvel froztbyte Draconx _janne BMeph akraut etherfreak vvv_ drewr Erstarrung MouseTheLuckyDog jrib zero7 davean sevvie zebr)
12:19:23 --- names: list (hdevalence|away flazz Raynes iteratee_ quicksilver bd__ chrisdone trafficone theorbtwo dsirenko_ Bigcheese Ralith go|dfish pikhq d3lxa si14 alej stelleg hellome nullcone_ Sabey upgrayeddd chexxor lopex bentrevor sordina1 dcoutts vnz pettter lattenwald drdo qwandor hiyakashi tdammers Baughn_ ciaranm srcerer AntiSpamMeta Morgawr michaf gnuvince zoktar etrepum spligak albel727 descender hpd seneca nitrodex _flow_ cods eL_Bart0 shutdown_-h_now wilfredh)
12:19:23 --- names: list (puzza007 chickenflu warpy Xorlev ortmage ps-auxw bbee akahn xorox90_ lokydor chrisbuchholz talzeus_ shennyg kav vivekrai Ghoul_ Vertue IbnFirnas jodaro_ xrl gdeest ehd DrSyzygy stevejb` joeyh kini stevejb troydm waterlaz Licenser hfaafb nwf jhh banjiewen dthibodeau mykhal blz37 palaga doomlord_ NeatBasis_ ggherdov mak` mikecaruso Eridius|vacation gseitz sepeth kloplop321 farn yano aleator milli brett Internet13 bcoppens Martty knz cmsd2 destiny vpm)
12:19:23 --- names: list (neurocyte ivan\ nonconvergent mmaruseacph2 Khisanth rgrinberg thebnq s_quark zomg arbn petantik bogner electrogeek BrianHV newsham earthy vobi karatekid sclv_ Belgarion0 bezik tero- edwtjo mero de-Vri-es vvein levitation[A] koala_man JustAPerson apples nanothief_ maoe f8l Th0mas tomprince wto linduxed noplamodo thorkilnaur__ averell nxorg8 thirsteh mlinksva kxra redjohn dan_johnsin SaBer melter neektza1 latro`a zerokarmaleft myme1 janinge ggreg otterdam)
12:19:23 --- names: list (ocharles ysuzuki aess saiam elgot resure mechairoi Valodim awruef hackagebot Philippa WhereIsMySpoon Svedrin byorgey `bps liori mlh ahihi asjo kshannon h_chiro_ goodmanio stiell alexander__b mel- warpaint int-e sm dakrone Tribal Bynbo7 sleepybug flux kaw ReinH joar bogner_ tych0 Deewiant tippenein Mayzie noam_ dustinswan zxq9 noddy plhk saiam^ Phlogistique jmcarthur nuttycom1 joshc ido ninzine phryk gemelen Hardolaf peltchu akiress_ MasseR gbluma_ Jimi`)
12:19:23 --- names: list (Laney mixi thetallguy2 Elision mapreduce schlumpi theDon zaphar_p1 kqr1 Gothmog_ kranius cow-orke1 k0ral pcapriotti deggis javawizard slobo_ SHODAN s4msung bstrie mux a11235 xplat ahf BlastHardcheese geoffh jlewis duairc JPohlmann integral Brando753 tvaalen Cryovat brendan rce brainproxy othiym23 davorak_ suiside drmegahertz agundry Plex- ent zenzike_ dixie_ saurik luite Saizan lispy hvr ofan mviljamaa Maior thorsten1 jlouis fayden MetaCosm shiona wchun)
12:19:23 --- names: list (ernst mollerstrand statusfa1led Boreeas ehamberg mami_ tswett bholst_ Yawgmoth_ ChongLi companion_cube bind Sourceless shepheb flori skypers smarter Zariel supki guymann liyang joachifm vmeson briden joelteon ski_ hiredman jroesch Dtgr Ornedan schoppenhauer mornfall CosmicRay Soft kaol ttm pqmodn_ malorie_ dilinger_ Gilly thoughtpolice ryanakca mr- Razz ziman thetallguy aninhumer pr xenophon zorzar `^_^v raid Edoxile sohum ClaudiusMaximus hpaste nikola)
12:19:24 --- names: list (zw01 greymalkin fall_ Nickeeh yan_ Blkt aformeny bgamari dsp_ swook` Watcher7 ejls Yaniel killy9999 xaimus macron luminous jaspervdj confound_ Zesler mkrull Eliel ft anachron SirChurchill Ezku b_jonas johnw kosmikus almondjelly copton jix Riussi_ lahwran Fubar^ mononofu pyykkis natte notdan zeiris_ ParahSailin horlicks Draggor lpsmith mikeplus64 fry bigs kooga barrucadu haasn robbert majoh betawaffle gds Ptival inarru geal taylorgb ipuustin Walther ccasin)
12:19:24 --- names: list (jayne Reisen bitraten davorb-cellphone ibid Jaak CindyLinz aszlig zaiste def-lkb_ arcatan Spockz tromp_ cjay jamwt dmp1ce yeltzooo necroyeti willb1 Dashkal Chousuke nlogax mjrosenb Starfire_ mrd_ Ulrar petekaz`` davd tessier fryguybob caligula__ b52 __main__ asante MK_FG gbarboza dlundy deavid elliott bergmark poucet XMunkki_ bqp ericmj pharaun Vq seantallen birkenfeld cruxeternus sp3ctum Clint mendez_ Dybber mgaare magicman anders^^_ isomorphismes)
12:19:24 --- names: list (geekosaur wagle sipa pnielsen Kinnison n00dle tamiko dextrey OrangeDuck wavewave @ChanServ dumbhat LeaChim fabjan chrra mattp__ lulf Proteumus relrod Rembane pfoetchen prophile sunnavy_ finnrobi pi8029 away_sondr3 TML ve genisage wereHamster gridaphobe klugez ion dario^CIP ljhms_ solirc Rutger`_ cross danr pyrtsa jliikka solarus nicoo jkpl liszt profmakx petanqk opqdonut stomp SuperNoeMan bxc rs0 Kneiva_ TheSpectre Sagi \q kryft)
12:22:31 <S_J> whats the best intro to functional reactive programming?
12:22:31 <tikhon> ooh, I don't know of any one good article to read
12:22:51 <tikhon> how do you feel about academic papers?
12:23:32 <tikhon> honestly, I'd just skim whatever random sources you can find and then try writing something simple with Reactive Banana
12:37:42 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
12:37:42 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
12:37:42 --- names: list (clog adrian2_ haasn morolin slack1256 uniquenick pantsman gentleben nan` exicer mhooge bogdanp twanvl Peaker S_J EvilPenguin paddymahoney sleepynate ulfdoz nominolo bananagram Thra11 Qfwfq_ sxn tauntaun LMolr kmrhb tearful rachit7 TaylorJoe ehaliewicz copumpkin phytobiological2 papyrus schell hrehf_ ByronJohnson dav petapetapeta dgpratt manung BeardedCoder hannese lazyvalue seliopou Rarrikins favonia flebron Alpha64_ ecube nexx paullik bamboo acowley wole)
12:37:42 --- names: list (resnik FreeFull Luser Zenol azm Okasu hattusili_III banister jssanders mizu_no_oto Taneb senorflor virvel k0001 piotrm0 Neqoxec lcfrs sferry aloiscochard venice c_wraith OlegYch edkk harovali1 ozataman_ scshunt Velpoman cdidd uvelichitel conehead message144 ijp Desheng edwardk ts33kr Guest85956 konundra fizbin schlicht_ kylcarte solrize_ d_arcy milessabin_ ptc exitmouse joelb kadoban flux0r pkrnj vk_ primitive arborist ErkiDerLoony h4199 bos_ jorick)
12:37:42 --- names: list (_justjust Ankhers bryanvick tommd chidy joehillen simukis_ eduardo_ nimish datura cfricke Krakarn c-rog BobFunk trism dubsg burp YoungFrog alszar marsam threesome chirpsalot ljsc zvrba tiffany lpvb Apocalisp breck7 b1collector DMcGill coeus bytbox levi jamestastic lunarjar raichoo Eduard_Munteanu Shin-LaC ghorn yogurt_truck Caztiel kobain WraithM resttime Nshag matheus23 Twey corkexaminer paintcan wting beckerb Arkantos Afish danharaj jang1 Moataz-E cads)
12:37:42 --- names: list (DexterLB totos__ shesek vijaykiran pmade tadeo skchrko adrian2 dabradley DrCode chenwl_ tehroflmaoer alang LazyTechGuy lambdanaut glosoli b2coutts balnaves morazow federkasten jchild wolfnn udoprog joneshf-laptop csakatoku gertc mirsal Pullphinger bartavelle amathew mgile JobV spion Wuzzy whaletechno erochester thalassarche Quadrescence pygospa aoh arnsholt danald walter dgvncsz0f Pranz dschoepe akurei shreesh Noldorin Nik05 elediaz Ov3rload jonkri)
12:37:42 --- names: list (JuanDaugherty caleb_9 Wizek mceier kstuart edsko M-ou-se chuzz nooodl Sculptor egblu3 tomh- tpsinnem q66 Entroacceptor pkkm seschwar_ k00mi snikkers ioanel kofno zacts lemao peddie_ kennyd ssbr fikusz thunderrd phyrex1an zl64c djcoin xexonixxexillion mantovani cynick taruti jobstijl sdx23 julmae diabel232 bduc arkx donri hamishmack so Mon_Ouie dwierenga mokus kludge` perlite Bwild cronject Kuraitou fergusnoble tg doomlord Alice3 aford xcv m3ga dented42)
12:37:42 --- names: list (SoupE brandonw tudalex allsystemsarego steshaw threesteps marr xinming predator117 adnap solrize folone joe9 danvet Reite Kabaka nilg shintah stepkut rodrigovidal goldkatze vili Spaceghost [mth] doshitan Jonno_FTW otto_s Philonous preflex mauke shanse wtw hiptobecubic NihilistDandy peddie brisbin augur hiroakip Igloo dreixel_ RichyB Boney drbean apaku biscarch gpampara brainwash plucas meretrix apples` miloshadzic crdueck tsou andrewsw smlgs joneshf-work)
12:37:43 --- names: list (Counter-Strike dolio callen rasmusto epta enthropy jlaire isomorphic mcbonz Natch ktosiek zrot dkasak_ joefiorini Tinned_Tuna davidt_ ceii niko foxnorth Amadiro tensorpudding gbeshers swistak35 simon eacameron supersym finity anon123 seq99`` xymox tikhon bbloom uu1101 Luke hive-mind s00pcan xilo saml MrFahrenheit otulp Cerise Puffton weie_ mannyv ismlages torkjak idoru sunfun cheezey phienone ccxCZ Tehnix listofoptions jaimef machisuji gthorslund felipe_)
12:37:43 --- names: list (Adios neena DT` cognominal bicgena charlesofarrell_ uranther steshaw_ ski bsmt nkpart EpicOut Athas joogi Liskni_si tomaw rpenguin_ pjstadig hpc aristid guerrilla iulian flowsnake dpwright KitB tulcod ousado osfameron sgso purefn1 junsuijin ivan` chrisdotcode_ mlamari jlamothe blackdog adimit mgsloan1 sirspazzolot alpounet dju marienz yam araujo leifw [swift] Mortomes McManiaC shergill tavelram dmwit epsylon parcs Excureo DarkFox algae scottschecter)
12:37:43 --- names: list (Tarential dino- mee hape01 cajla Work_jack palmje mrshoe Ke FireFly saep Bio kakos tridactyla SegFaultAX pdxleif BigEndian Ycros n-dolio jrslepak frontendloader _br_ yiannis_t Hafydd hiratara dsantiago Maxdamantus rfw obcode jeff_s1 wunki monochrom ninegrid amatsu `0660 tertl3 Jaxan ozataman vsayer LevelOneDev Nimatek gereedy Enigmagic twn ethercrow jdoliner dogmaT dexter1 tomejaguar cmears centrinia adlan annulus- orospakr gambogi Squid_Tamer munro Khady)
12:37:43 --- names: list (robinbb-freenode oldmanstan Adeon DustyDin1o jbauman IanKelling SLi leroux carter bobry demolithion satshaba1 satshabad brixen dyreshark mmathis maksbotan gilbertw1 lambdabot bscarlet Iceland_jack lenstr Will| tahu mimi_vx PHO_ mikee Jello_Raptor vehk eyck ab9rf canissimia idnar stass Gracenotes threedaymonk Sunhay_ DigitalKiwi wollw acfoltzer stvc MoALTz cschneid jml ParahSail1n Lemmih qz mietek blakesmith mstksg lightquake isenmann solancile floatingman)
12:37:43 --- names: list (canta mjo mortberg Raynos tylergillies_ c_14 stepcut nik_89 thorsten` raft tshirtman reactormonk helgikrs fxrh inr Cale valdyn dqd colah jyyou xnyhps wormphlegm dropdrive sclv anhall djahandarie osnr machisuji_ mike2 Tekerson sajith KaneTW arkeet tunixman heath kloeri Odd_Bloke FUZxxl mxf knyppeld1nan divarvel froztbyte Draconx _janne BMeph akraut etherfreak vvv_ drewr Erstarrung MouseTheLuckyDog jrib zero7 davean sevvie zebr hdevalence|away flazz Raynes)
12:37:43 --- names: list (iteratee_ quicksilver bd__ chrisdone trafficone theorbtwo dsirenko_ Bigcheese Ralith go|dfish pikhq d3lxa si14 alej stelleg hellome nullcone_ Sabey upgrayeddd chexxor lopex bentrevor sordina1 dcoutts vnz pettter lattenwald drdo qwandor hiyakashi tdammers Baughn_ ciaranm srcerer AntiSpamMeta Morgawr michaf gnuvince zoktar etrepum spligak albel727 descender hpd seneca nitrodex _flow_ cods eL_Bart0 shutdown_-h_now wilfredh puzza007 chickenflu warpy Xorlev)
12:37:43 --- names: list (ortmage ps-auxw bbee akahn xorox90_ lokydor chrisbuchholz talzeus_ shennyg kav vivekrai Ghoul_ Vertue IbnFirnas jodaro_ xrl gdeest ehd DrSyzygy stevejb` joeyh kini stevejb troydm waterlaz Licenser hfaafb nwf jhh banjiewen dthibodeau mykhal blz37 palaga doomlord_ NeatBasis_ ggherdov mak` mikecaruso Eridius|vacation gseitz sepeth kloplop321 farn yano aleator milli brett Internet13 bcoppens Martty knz cmsd2 destiny vpm neurocyte ivan\ nonconvergent)
12:37:43 --- names: list (mmaruseacph2 Khisanth rgrinberg thebnq s_quark zomg arbn petantik bogner electrogeek BrianHV newsham earthy vobi karatekid sclv_ Belgarion0 bezik tero- edwtjo mero de-Vri-es vvein levitation[A] koala_man JustAPerson apples nanothief_ maoe f8l Th0mas tomprince wto linduxed noplamodo thorkilnaur__ averell nxorg8 thirsteh mlinksva kxra redjohn dan_johnsin SaBer melter neektza1 latro`a zerokarmaleft myme1 janinge ggreg otterdam ocharles ysuzuki aess saiam)
12:37:43 --- names: list (elgot resure mechairoi Valodim awruef hackagebot Philippa WhereIsMySpoon Svedrin byorgey `bps liori mlh ahihi asjo kshannon h_chiro_ goodmanio stiell alexander__b mel- warpaint int-e sm dakrone Tribal Bynbo7 sleepybug flux kaw ReinH joar bogner_ tych0 Deewiant tippenein Mayzie noam_ dustinswan zxq9 noddy plhk saiam^ Phlogistique jmcarthur nuttycom1 joshc ido ninzine phryk gemelen Hardolaf peltchu akiress_ MasseR gbluma_ Jimi` Laney mixi thetallguy2 Elision)
12:37:43 --- names: list (mapreduce schlumpi theDon zaphar_p1 kqr1 Gothmog_ kranius cow-orke1 k0ral pcapriotti deggis javawizard slobo_ SHODAN s4msung bstrie mux a11235 xplat ahf BlastHardcheese geoffh jlewis duairc JPohlmann integral Brando753 tvaalen Cryovat brendan rce brainproxy othiym23 davorak_ suiside drmegahertz agundry Plex- ent zenzike_ dixie_ saurik luite Saizan lispy hvr ofan mviljamaa Maior thorsten1 jlouis fayden MetaCosm shiona wchun ernst mollerstrand statusfa1led)
12:37:43 --- names: list (Boreeas ehamberg mami_ tswett bholst_ Yawgmoth_ ChongLi companion_cube bind Sourceless shepheb flori skypers smarter Zariel supki guymann liyang joachifm vmeson briden joelteon ski_ hiredman jroesch Dtgr Ornedan schoppenhauer mornfall CosmicRay Soft kaol ttm pqmodn_ malorie_ dilinger_ Gilly thoughtpolice ryanakca mr- Razz ziman thetallguy aninhumer pr xenophon zorzar `^_^v raid Edoxile sohum ClaudiusMaximus hpaste nikola zw01 greymalkin fall_ Nickeeh yan_)
12:37:43 --- names: list (Blkt aformeny bgamari dsp_ swook` Watcher7 kryft \q Sagi TheSpectre Kneiva_ rs0 bxc SuperNoeMan stomp opqdonut petanqk profmakx liszt jkpl nicoo solarus jliikka pyrtsa danr cross Rutger`_ solirc ljhms_ dario^CIP ion klugez gridaphobe wereHamster genisage ve TML away_sondr3 pi8029 finnrobi sunnavy_ prophile pfoetchen Rembane relrod Proteumus lulf mattp__ chrra fabjan LeaChim dumbhat @ChanServ wavewave OrangeDuck dextrey tamiko n00dle Kinnison pnielsen sipa)
12:37:43 --- names: list (wagle geekosaur isomorphismes anders^^_ magicman mgaare Dybber mendez_ Clint sp3ctum cruxeternus birkenfeld seantallen Vq pharaun ericmj bqp XMunkki_ poucet bergmark elliott deavid dlundy gbarboza MK_FG asante __main__ b52 caligula__ fryguybob tessier davd petekaz`` Ulrar mrd_ Starfire_ mjrosenb nlogax Chousuke Dashkal willb1 necroyeti yeltzooo dmp1ce jamwt cjay tromp_ Spockz arcatan def-lkb_ zaiste aszlig CindyLinz Jaak ibid davorb-cellphone bitraten)
12:37:43 --- names: list (Reisen jayne ccasin Walther ipuustin taylorgb geal inarru Ptival gds betawaffle majoh robbert barrucadu kooga bigs fry mikeplus64 lpsmith Draggor horlicks ParahSailin zeiris_ notdan natte pyykkis mononofu Fubar^ lahwran Riussi_ jix copton almondjelly kosmikus johnw b_jonas Ezku SirChurchill anachron ft Eliel mkrull Zesler confound_ jaspervdj luminous macron xaimus killy9999 Yaniel ejls)
12:38:37 <adrian2_> I don't get something... after hours.... how to sum this structure [[(1,"D"),(2,"D")],[(2,"F")]]
12:39:01 <danr> adrian2_: do you want to sum the numbers in it?
12:39:06 <danr> or what do you want to do with your strings?
12:39:19 <aloiscochard> is it possible to get VI key binding in ghci?
12:40:21 <adrian2_> danr: I want to pack it to something [(3, "D"), (2, "F")]
12:40:51 <supki> aloiscochard: yes, add "editMode: Vi" to ~/.haskeline
12:40:51 <dmwit> adrian2_: What will you do with [[(1,"D"),(2,"F")],[(2,"F")]]?
12:45:04 <adrian2_> dmwit: this should be sorted and then groupped by first
12:45:04 <aloiscochard> supki: yeah awesome! work like a charm, ty
12:45:04 <adrian2_> f = sortBy (compare `on` (snd)) [(1, "D"), (2, "F"), (2, "D")]
12:45:04 <adrian2_> s = groupBy (\x y -> (snd x) == (snd y)) g
12:45:04 <adrian2_> g = sortBy
12:45:04 <Peaker> adrian2_, you have a list of list of tuples, it isn't clear what behavior you want from your outer list, I think that's what dmwit was trying to ask
12:45:04 <adrian2_> but I get this structure... v :: [[(Integer, [Char])]]
12:47:23 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
12:47:23 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
12:47:23 --- names: list (clog b0c1 lukexi gabor yfyf erochester floatingman1 kingugo adrian2_ haasn morolin slack1256 pantsman gentleben nan` exicer mhooge bogdanp twanvl Peaker S_J EvilPenguin paddymahoney sleepynate ulfdoz nominolo bananagram Thra11 Qfwfq_ sxn tauntaun kmrhb tearful rachit7 TaylorJoe ehaliewicz copumpkin phytobiological2 papyrus hrehf_ ByronJohnson dav petapetapeta dgpratt manung BeardedCoder hannese lazyvalue seliopou Rarrikins flebron Alpha64_ ecube nexx paullik)
12:47:23 --- names: list (bamboo acowley wole resnik FreeFull Luser Zenol azm hattusili_III banister jssanders mizu_no_oto Taneb virvel k0001 Neqoxec lcfrs sferry aloiscochard venice c_wraith OlegYch edkk harovali1 ozataman_ scshunt Velpoman cdidd uvelichitel conehead message144 ijp Desheng edwardk ts33kr Guest85956 konundra fizbin schlicht_ kylcarte d_arcy milessabin_ ptc exitmouse joelb kadoban flux0r pkrnj vk_ primitive arborist ErkiDerLoony h4199 bos_ jorick _justjust Ankhers)
12:47:23 --- names: list (bryanvick tommd chidy joehillen eduardo_ nimish datura cfricke Krakarn c-rog BobFunk trism dubsg burp YoungFrog alszar marsam threesome chirpsalot ljsc zvrba tiffany lpvb Apocalisp breck7 b1collector DMcGill coeus bytbox levi jamestastic lunarjar raichoo Eduard_Munteanu Shin-LaC ghorn yogurt_truck Caztiel kobain WraithM resttime Nshag matheus23 Twey corkexaminer paintcan wting beckerb Arkantos Afish danharaj jang1 Moataz-E cads DexterLB totos__ shesek)
12:47:23 --- names: list (vijaykiran pmade tadeo skchrko adrian2 dabradley DrCode chenwl_ tehroflmaoer alang LazyTechGuy lambdanaut glosoli b2coutts balnaves morazow federkasten jchild wolfnn udoprog joneshf-laptop csakatoku gertc mirsal Pullphinger bartavelle amathew mgile JobV spion Wuzzy whaletechno thalassarche Quadrescence pygospa aoh arnsholt danald walter dgvncsz0f Pranz dschoepe akurei shreesh Noldorin Nik05 elediaz Ov3rload jonkri JuanDaugherty caleb_9 Wizek mceier kstuart)
12:47:23 --- names: list (edsko M-ou-se chuzz nooodl Sculptor egblu3 tomh- tpsinnem q66 Entroacceptor pkkm seschwar_ k00mi snikkers ioanel kofno zacts lemao peddie_ kennyd ssbr fikusz thunderrd phyrex1an zl64c djcoin xexonixxexillion mantovani cynick taruti jobstijl sdx23 julmae diabel232 bduc arkx donri hamishmack so Mon_Ouie dwierenga mokus kludge` perlite Bwild cronject Kuraitou fergusnoble tg doomlord Alice3 aford m3ga dented42 SoupE brandonw tudalex allsystemsarego steshaw)
12:47:23 --- names: list (threesteps marr xinming predator117 adnap folone joe9 Reite Kabaka nilg shintah stepkut rodrigovidal goldkatze vili Spaceghost [mth] doshitan Jonno_FTW otto_s Philonous preflex mauke shanse wtw hiptobecubic NihilistDandy peddie brisbin augur hiroakip Igloo dreixel_ RichyB Boney drbean apaku biscarch gpampara brainwash plucas meretrix apples` miloshadzic crdueck tsou andrewsw smlgs joneshf-work Counter-Strike dolio callen rasmusto epta enthropy jlaire)
12:47:23 --- names: list (isomorphic mcbonz Natch ktosiek zrot dkasak_ joefiorini Tinned_Tuna davidt_ ceii niko foxnorth Amadiro tensorpudding gbeshers swistak35 simon eacameron supersym finity anon123 seq99`` xymox tikhon bbloom uu1101 Luke hive-mind s00pcan xilo saml MrFahrenheit otulp Cerise Puffton weie_ mannyv ismlages torkjak idoru sunfun cheezey phienone ccxCZ Tehnix listofoptions jaimef machisuji gthorslund felipe_ Adios neena DT` cognominal bicgena charlesofarrell_ uranther)
12:47:24 --- names: list (steshaw_ ski bsmt nkpart EpicOut Athas joogi Liskni_si tomaw rpenguin_ pjstadig hpc aristid guerrilla iulian flowsnake dpwright KitB tulcod ousado osfameron sgso purefn1 junsuijin ivan` chrisdotcode_ mlamari jlamothe blackdog adimit mgsloan1 sirspazzolot alpounet dju marienz yam araujo leifw [swift] Mortomes McManiaC shergill tavelram dmwit epsylon parcs Excureo DarkFox algae scottschecter Tarential dino- mee hape01 cajla Work_jack palmje mrshoe Ke FireFly)
12:47:24 --- names: list (saep Bio kakos tridactyla SegFaultAX pdxleif BigEndian Ycros n-dolio jrslepak frontendloader _br_ yiannis_t Hafydd hiratara dsantiago Maxdamantus rfw obcode jeff_s1 wunki monochrom ninegrid amatsu `0660 tertl3 Jaxan ozataman vsayer LevelOneDev Nimatek gereedy Enigmagic twn ethercrow jdoliner dogmaT dexter1 tomejaguar cmears centrinia adlan annulus- orospakr gambogi Squid_Tamer munro Khady robinbb-freenode oldmanstan Adeon DustyDin1o jbauman IanKelling SLi)
12:47:24 --- names: list (leroux carter bobry demolithion satshaba1 satshabad brixen dyreshark mmathis maksbotan gilbertw1 lambdabot bscarlet Iceland_jack lenstr Will| tahu mimi_vx PHO_ mikee Jello_Raptor vehk eyck ab9rf canissimia idnar stass Gracenotes threedaymonk Sunhay_ DigitalKiwi wollw acfoltzer stvc MoALTz cschneid jml ParahSail1n Lemmih qz mietek blakesmith mstksg lightquake isenmann solancile floatingman canta mjo mortberg Raynos tylergillies_ c_14 stepcut nik_89 thorsten`)
12:47:24 --- names: list (raft tshirtman reactormonk helgikrs fxrh inr Cale valdyn dqd colah jyyou xnyhps wormphlegm dropdrive sclv anhall djahandarie osnr machisuji_ mike2 Tekerson sajith KaneTW arkeet tunixman heath kloeri Odd_Bloke FUZxxl mxf knyppeld1nan divarvel froztbyte Draconx _janne BMeph akraut etherfreak vvv_ drewr Erstarrung MouseTheLuckyDog jrib zero7 davean sevvie zebr hdevalence|away flazz Raynes iteratee_ quicksilver bd__ chrisdone trafficone theorbtwo dsirenko_)
12:47:24 --- names: list (Bigcheese Ralith go|dfish pikhq d3lxa si14 alej stelleg hellome nullcone_ Sabey upgrayeddd chexxor lopex bentrevor sordina1 dcoutts vnz pettter kryft \q Sagi TheSpectre Kneiva_ rs0 bxc SuperNoeMan stomp opqdonut petanqk profmakx liszt jkpl nicoo solarus jliikka pyrtsa danr cross Rutger`_ solirc ljhms_ dario^CIP ion klugez gridaphobe wereHamster genisage ve TML away_sondr3 pi8029 finnrobi sunnavy_ prophile pfoetchen Rembane relrod Proteumus lulf mattp__ chrra)
12:47:24 --- names: list (fabjan LeaChim dumbhat @ChanServ wavewave OrangeDuck dextrey tamiko n00dle Kinnison pnielsen sipa wagle geekosaur isomorphismes anders^^_ magicman mgaare Dybber mendez_ Clint sp3ctum cruxeternus birkenfeld seantallen Vq pharaun ericmj bqp XMunkki_ poucet bergmark elliott deavid dlundy gbarboza MK_FG asante __main__ b52 caligula__ fryguybob tessier davd petekaz`` Ulrar mrd_ Starfire_ mjrosenb nlogax Chousuke Dashkal willb1 necroyeti yeltzooo dmp1ce jamwt cjay)
12:47:24 --- names: list (tromp_ Spockz arcatan def-lkb_ zaiste aszlig CindyLinz Jaak ibid davorb-cellphone bitraten Reisen jayne ccasin Walther ipuustin taylorgb geal inarru Ptival gds betawaffle majoh robbert barrucadu kooga bigs fry mikeplus64 lpsmith Draggor horlicks ParahSailin zeiris_ notdan natte pyykkis mononofu Fubar^ lahwran Riussi_ jix copton almondjelly kosmikus johnw b_jonas Ezku SirChurchill anachron ft Eliel mkrull Zesler confound_ jaspervdj luminous macron xaimus)
12:47:24 --- names: list (killy9999 Yaniel ejls Watcher7 swook` dsp_ bgamari aformeny Blkt yan_ Nickeeh fall_ greymalkin zw01 nikola hpaste ClaudiusMaximus sohum Edoxile raid `^_^v zorzar xenophon pr aninhumer thetallguy ziman Razz mr- ryanakca thoughtpolice Gilly dilinger_ malorie_ pqmodn_ ttm kaol Soft CosmicRay mornfall schoppenhauer Ornedan Dtgr jroesch hiredman ski_ joelteon briden vmeson joachifm liyang guymann supki Zariel smarter skypers flori shepheb Sourceless bind)
12:47:24 --- names: list (companion_cube ChongLi Yawgmoth_ bholst_ tswett mami_ ehamberg Boreeas statusfa1led mollerstrand ernst wchun shiona MetaCosm fayden jlouis thorsten1 Maior mviljamaa ofan hvr lispy Saizan luite saurik dixie_ zenzike_ ent Plex- agundry drmegahertz suiside davorak_ othiym23 brainproxy rce brendan Cryovat tvaalen Brando753 integral JPohlmann duairc jlewis geoffh BlastHardcheese ahf xplat a11235 mux bstrie s4msung SHODAN slobo_ javawizard deggis pcapriotti k0ral)
12:47:24 --- names: list (cow-orke1 kranius Gothmog_ kqr1 zaphar_p1 theDon schlumpi mapreduce Elision thetallguy2 mixi Laney Jimi` gbluma_ MasseR akiress_ peltchu Hardolaf gemelen phryk ninzine ido joshc nuttycom1 jmcarthur Phlogistique saiam^ plhk noddy zxq9 dustinswan noam_ Mayzie tippenein Deewiant tych0 bogner_ joar ReinH kaw flux sleepybug Bynbo7 Tribal dakrone sm int-e warpaint mel- alexander__b stiell goodmanio h_chiro_ kshannon asjo ahihi mlh liori `bps byorgey Svedrin)
12:47:24 --- names: list (WhereIsMySpoon hackagebot awruef Valodim mechairoi resure elgot saiam aess ysuzuki ocharles otterdam ggreg janinge myme1 zerokarmaleft latro`a neektza1 melter SaBer dan_johnsin redjohn kxra mlinksva thirsteh nxorg8 averell thorkilnaur__ noplamodo linduxed wto tomprince Th0mas f8l maoe nanothief_ apples JustAPerson koala_man levitation[A] vvein de-Vri-es mero edwtjo tero- bezik Belgarion0 sclv_ karatekid vobi earthy newsham BrianHV electrogeek bogner petantik)
12:47:24 --- names: list (arbn zomg s_quark thebnq rgrinberg Khisanth mmaruseacph2 nonconvergent ivan\ neurocyte vpm destiny cmsd2 knz Martty bcoppens Internet13 brett milli aleator yano farn kloplop321 sepeth gseitz Eridius|vacation mikecaruso mak` ggherdov NeatBasis_ doomlord_ palaga blz37 mykhal dthibodeau banjiewen jhh nwf hfaafb Licenser waterlaz troydm stevejb kini joeyh stevejb` DrSyzygy ehd gdeest xrl jodaro_ IbnFirnas Vertue Ghoul_ vivekrai kav shennyg talzeus_ chrisbuchholz)
12:47:24 --- names: list (lokydor xorox90_ akahn bbee ps-auxw ortmage Xorlev warpy chickenflu puzza007 wilfredh shutdown_-h_now eL_Bart0 cods _flow_ nitrodex seneca hpd descender albel727 spligak etrepum zoktar gnuvince michaf Morgawr AntiSpamMeta srcerer ciaranm Baughn_ tdammers hiyakashi qwandor drdo lattenwald)
12:48:12 <haasn> seems my previous messages didn't get through
12:48:28 <haasn> “I could never make much sense of reactive-banana personally” “netwire appeals to me more for some reason” “despite me being unable to use either effectively” re: frp
12:48:31 <adrian2_> dmwit yes, for [(,)]
12:48:41 <adrian2_> but I have this
12:48:51 <adrian2_> f = sortBy (compare `on` (snd)) [(1, "D"), (2, "F"), (2, "D")]
12:48:57 <adrian2_> g = f
12:49:02 <adrian2_> s = groupBy (\x y -> (snd x) == (snd y)) g
12:49:06 <acowley> haasn: That's quite a testimonial! :P
12:49:09 <dmwit> Solution: don't have that.
12:49:22 <adrian2_> ret1: -- [(1,"D"),(2,"D"),(2,"F")]
12:49:33 <adrian2_> ret2: -- [[(1,"D"),(2,"D")],[(2,"F")]]
12:49:39 <Peaker> haasn, what approaches are they?
12:49:50 <adrian2_> I want to compact the last list
12:49:51 <Peaker> reactive-banana is like conal's old Reactive library?  And netwire is arrows?
12:50:05 <haasn> Peaker: I'm not sure what conal's old reactive library is like but netwire is arrows, yes
12:50:10 <Peaker> adrian2_, can't you just concat that list into a single list?
12:50:11 <tikhon> ooh, I never liked arrowized FRP
12:50:19 <dmwit> adrian2_: I'm very serious. Don't bother with the previous stuff. There's already a combinator that does all three steps in one go; why split out two steps spuriously?
12:50:26 <Peaker> I dislike arrows too -- at least their form in Control.Arrow is rather useless
12:50:36 <haasn> reactive-banana seems somewhat more explicit with the Effect model and has you build up a graph in ‘main’ and confusing stuff like that
12:50:39 <tikhon> Reactive Banana uses the "classical" FRP model of Events and Behaviors
12:50:47 <haasn> s/Effect/Event/
12:50:54 <adrian2_> dmwit: cuz i'm novice in haskell
12:50:55 <tikhon> yeah, the actual library is not ideal, but I like the underlying model
12:51:20 <tikhon> and I'm willing to deal with a bit more surrounding complexity to have a nicer underlying model
12:51:29 <adrian2_> it started with http://www.haskell.org/haskellwiki/99_questions/Solutions/10
12:52:15 <dmwit> I don't see why the history of your solution should affect the quality of mine.
12:53:02 <adrian2_> let say I have this .... [(4,'a'),(1,'b'),(2,'c'),(2,'a'),(1,'d'),(4,'e')] I wanna compress the list based on the char key and sum the occurences
12:53:32 <haasn> probably some foldr involving a Map
12:53:34 <haasn> is what I'd use
12:53:39 <acowley> adrian2_: That is basically what dmwit solved
12:53:50 <S_J> > sort [("\154\235rn","String","D\230Q"),("\172i","Double","H")] == sort [("\172i","Double","H"), ("\154\235rn","String","D\230Q")]
12:53:51 <lambdabot>   True
12:54:00 <S_J> > [("\154\235rn","String","D\230Q"),("\172i","Double","H")] == [("\172i","Double","H"), ("\154\235rn","String","D\230Q")]
12:54:01 <lambdabot>   False
12:54:07 <dmwit> > M.fromListWith (+) [('a',4), ('b',1), ('c',2), ('a',2), ('d',1), ('e',4)]
12:54:08 <lambdabot>   fromList [('a',6),('b',1),('c',2),('d',1),('e',4)]
12:54:44 <haasn> oh, Data.Map has this already
12:54:48 <Peaker> > M.fromListWith (+) . map swap $ [(4,'a'),(1,'b'),(2,'c'),(2,'a'),(1,'d'),(4,'e')]
12:54:49 <lambdabot>   fromList [('a',6),('b',1),('c',2),('d',1),('e',4)]
12:54:53 <haasn> I was just wondering what M.fromList does on multiple keys
12:55:04 <chrisdone> dmwit: hmm?
12:55:04 <chrisdone> > let avg x y = (x+y)/2; xs = [5,7,8,9,10,2,4,3::Rational] in (round (foldr1 avg xs),round (sum xs/fromIntegral (length xs)))
12:55:05 <lambdabot>   (6,6)
12:55:12 <chrisdone> dmwit: seems good. am i missing something obvious here?
12:55:17 <Peaker> > M.fromList [(1,2),(1,3)]
12:55:18 <lambdabot>   fromList [(1,3)]
12:55:50 <S_J> why isnt sort in prelude?
12:55:55 <S_J> @src sort
12:55:55 <lambdabot> sort = sortBy compare
12:56:14 <dmwit> > let avg x y = (x+y)/2; xs = [0,0,0,0,0,0,0,0,1024] in (foldr1 avg xs, sum xs / fromIntegral (length xs)) :: (Rational, Rational)
12:56:15 <S_J> @src sortBy
12:56:15 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
12:56:15 <lambdabot>   (4 % 1,1024 % 9)
12:56:23 <dmwit> chrisdone: You are missing something here. =)
12:56:30 <haasn> S_J: (that's not the actual definition ‘base’ uses, btw)
12:56:38 <chrisdone> dmwit: hmm
12:56:45 <adrian2_> dmwit: thank... and fromListWith is imported from where? :)
12:56:50 <luite> chrisdone: hehe quite a coincidence that you got the same answer :)
12:56:54 <dmwit> ?hoogle fromListWith
12:56:54 <lambdabot> Data.IntMap.Strict fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
12:56:54 <lambdabot> Data.IntMap.Lazy fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
12:56:54 <lambdabot> Data.Map.Lazy fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
12:56:58 <S_J> wow, i hope not since that is O(N^2) right?
12:57:06 <dmwit> adrian2_: Well, Data.Map is the one I was using.
12:57:28 <adrian2_> cool
12:57:30 <haasn> S_J: in the worst case, I think it is
12:58:43 <Peaker> chrisdone, 1 `avg` (2 `avg` 3)  isn't the same as average [1,2,3]   (1 gets 0.5 in the final say, 2 and 3 get 0.25 each)
12:58:46 <dmwit> haasn: in all cases
12:59:02 <chrisdone> Peaker: yeah
12:59:07 <haasn> dmwit: in the best case it's O(n), no?
12:59:18 <dmwit> ...yes, I am very wrong.
12:59:20 <dmwit> As usual.
13:00:01 <adrian2_> dmwit:  thanks!!!
13:00:44 <adrian2_> dmwit: is possible to have an insight on how this function is defined? fromListWith
13:00:54 <adrian2_> from GHCi
13:00:55 <dmwit> chrisdone: Have you seen http://squing.blogspot.com/2008/11/beautiful-folding.html ?
13:01:19 <dmwit> adrian2_: Not from ghci, but you can look at the source by unpacking the "containers" package or by looking at the source links on the Hackage documentation.
13:01:39 <chrisdone> dmwit: no
13:07:46 <adrian2_> dmwit: thanks!!
13:13:07 <jnhnum1_> is there a nice way to, given list of state monads,  get a list of the intermediate states?  so something like (MonadState s m) => [m a] -> m [s]
13:14:19 <c_wraith> jnhnum1_: you want to just throw away the a values?
13:15:14 <jnhnum1_> I guess so - in my use case they're actually all m ()
13:15:17 <c_wraith> :t mapM (>> get)
13:15:18 <lambdabot> MonadState b m => [m a] -> m [b]
13:15:25 <S_J> if i have a list of (String,String,String) andI want to eliminate all that are duplicate sof the first param, ie if ("","Int","32") exists, throw away ("",String","hello").
13:15:27 <jnhnum1_> oh
13:15:49 <S_J> is that most efficielty solved with a Map? because otherwise it is O(N^2) right?
13:15:50 <jnhnum1_> thanks
13:15:57 <Peaker> jnhnum1_, nitpick: "monad" refers to the *type*, i.e: the type constructor (State s) is a monad.  a value of type: "State s a" is a "state action" or "monadic action", not a "monad"
13:15:57 <jnhnum1_> I guess that is pretty simple
13:16:15 <jnhnum1_> blah pedantry
13:16:27 <c_wraith> Eh, it matters some.
13:16:56 <Peaker> S_J, or a Set
13:17:04 <chrisdone> @let ca ip1 xip1 cai = (xip1 + i*cai) / (i + 1) where i = ip1-1
13:17:05 <Peaker> S_J, or a sort
13:17:05 <lambdabot>  Defined.
13:17:08 <jnhnum1_> ok
13:17:11 <chrisdone> > round (foldr (\(i,xi) cai -> ca i xi cai) 0 (zip [1..] [1,2,3]) :: Rational)
13:17:15 <lambdabot>   mueval-core: Time limit exceeded
13:17:19 <chrisdone> > round (foldr (\(i,xi) cai -> ca i xi cai) 0 (zip [1..] [1,2,3]) :: Rational)
13:17:23 <lambdabot>   mueval-core: Time limit exceeded
13:17:25 <jnhnum1_> I will try to use the proper terminology next time
13:17:28 <chrisdone> i hate you lambdabot
13:17:33 <chrisdone> @slap lambdabot
13:17:34 <lambdabot> I'd rather not; lambdabot looks rather dangerous.
13:17:47 <chrisdone> anyway, what's wrong with my cumulative moving average function?
13:17:54 <Peaker> jnhnum1_, I don't think its pedantry, we speak of both actions and monads a lot, so it can actually help
13:17:57 <c_wraith> jnhnum1_: in any case, yeah, the solution to your question isn't too bad.
13:18:08 <chrisdone> > round (foldr (\(i,xi) cai -> ca i xi cai) 0 (zip [1..] [1,2,3]) :: Rational)
13:18:11 <lambdabot>   mueval-core: Time limit exceeded
13:18:13 <chrisdone> > 1
13:18:14 <lambdabot>   1
13:18:19 <chrisdone> o_o o
13:18:40 <chrisdone> dmwit: what's up with my ca function?
13:21:35 <chrisdone> hmm. invoking it separately seems ok
13:21:44 <chrisdone> must be the order
13:21:51 <chrisdone> yeah
13:21:56 <chrisdone> foldl is the right of it
13:22:49 <Peaker> > snd . foldr (\x (cnt,avg) -> (cnt+1, (x + avg*cnt) / (cnt+1))) (0, 0) $ [1..5]
13:22:50 <lambdabot>   3.0
13:23:50 <Peaker> that works with foldl' just as well
13:24:08 <chrisdone> > foldl' (\cai (i,xi) -> ca i xi cai) 0 (zip [1..] [1..5])
13:24:12 <lambdabot>   3.0
13:24:28 <chrisdone> yeah, yours is an optimization
13:24:37 <chrisdone> i was copying from wikipedia because i have no education
13:24:56 <Peaker> chrisdone, I just wrote what came to mind (tagging the avg with the count of how many it averaged)
13:26:13 <chrisdone> Peaker: yeah i don't have any intuition for that at all
13:27:00 <chrisdone> the maths part of my brain is a large empty hall containing a monkey on a bicycle
13:27:06 <tippenein> lol
13:27:10 <Peaker> chrisdone, weighted average of  (weightx, x) and (weighty, y)   is:   let total = weightx+weighty  ;  x * (weightx/total) + y * (weighty/total)
13:27:17 <chrisdone> i have to work hard to understand simple things like this fully
13:27:51 <donri> isn't this wrong now http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/data-type-extensions.html#infix-tycons
13:28:08 <Peaker> chrisdone, so if you want a uniform average, and you have one element vs. 5 elements,  then the 1 element has a weight of 1, and the 5 elements have a weight of 5,  so (1/6) * element + (5/6) * others
13:29:02 <Peaker> which also yields ordinary average between two things with same weight:  (1/2) * first   +  (1/2) * second
13:29:14 <chrisdone> Peaker: oh that's neat
13:30:18 <Peaker> chrisdone, so the foldr just tags the avg-so-far with its increasing weight, and then:   x + avg*cnt      gives x a weight of 1, and 'avg' a weight of cnt
13:31:12 <chrisdone> Peaker: right
13:31:45 <dmwit> chrisdone: I see you addressed a question to me. Luckily it seems Peaker is answering you, so I don't have to. =)
13:33:07 <chrisdone> Peaker: yeah that's nice, thanks for explaining. i'll know who to ask next time =)
13:33:46 <dmwit> Does anyone have a link explaining how exceptions and the FFI get along?
13:34:19 <Peaker> chrisdone, :-)
13:35:15 <reks> http://moveword.blogspot.com
13:40:21 <cschneid> I'd like to pattern match based on the first part of a string, match ("foo" : xs) = putStrLn "foo matched"
13:40:24 <cschneid> that doesn't typecheck though
13:40:42 <cschneid> if I build the matching list with ('f':'o':'o':xs) that works. But that's silly.
13:40:58 <cschneid> is there a way to do that?
13:41:55 <b2coutts> cschneid: the intuitive way you might expect to do this is with ("foo" ++ xs)
13:42:08 <cschneid> right, but that doesn't work.
13:42:12 <Gracenotes> use pattern guards and isPrefixOf
13:42:29 <b2coutts> however, only works with data constructors; : is a list constructor, whereas ++ is not
13:42:30 <tippenein> cschneid: this is a pretty good answer http://stackoverflow.com/questions/1602243/pattern-matching-string-prefixes-in-haskell
13:42:37 <b2coutts> s/only/this only/
13:43:16 <haasn> ViewPatterns sounds like the right tool for the job
13:43:23 <haasn> as mentioned by tippenein's link
13:44:05 <Gracenotes> (Some people, when faced with a problem, think "I'll add more syntax". Success thereof probably depends on how general the syntax is.)
13:44:33 <haasn> the verbose form is presents is needlessly complicated, too, a simple “case .. of” can replace the ViewPatterns stuff
13:44:46 <johnw> the rex package, if you don't mind template haskell, solves the problem pretty generally by letting you pattern match on regexps, effectively
13:44:51 <haasn> Gracenotes: others think “I'll pester edwardk to add a new lens combinator for it”
13:44:59 <cschneid> cool. so the answer is: "don't do that", and "here are other ways"
13:45:34 <haasn> cschneid: there's nothing wrong with 'f':'o':'o', obviously :)
13:45:39 <chrisdone> λ> do r <- newIORef 1; bench 5 (do i <- readIORef r; modifyIORef r (+1); print i; threadDelay (1000*1000*i))
13:45:39 <chrisdone> 1
13:45:39 <chrisdone> 2
13:45:42 <chrisdone> 3
13:45:46 <chrisdone> 4
13:45:49 <chrisdone> 5
13:45:52 <cschneid> haasn: sure, just weird to write a string like that :)
13:45:52 <chrisdone> ((),3.002670999999s)
13:45:56 <chrisdone> dmwit: back in business
13:46:18 <dmwit> chrisdone: =)
13:48:16 * hackagebot ply-loader 0.3.1 - PLY file loader.  http://hackage.haskell.org/package/ply-loader-0.3.1 (AnthonyCowley)
13:48:18 * hackagebot data-extra 2.1.1 - Extra utilities for working on Data.* types.  http://hackage.haskell.org/package/data-extra-2.1.1 (ChrisDone)
13:51:01 <chrisdone> dmwit: johnw had some fun experience with the FFI and exceptions
13:51:12 <johnw> yeah, where by fun he means the opposite of fun
13:51:26 <chrisdone> iirc haskell callbacks from the FFI can't throw exceptions back into the haskell runtime?
13:51:33 <johnw> right
13:51:46 <chrisdone> pretty valuable to know
13:51:53 <monochrom> yikes
13:51:57 <osa1> hi all. I want to start working on GHC and I need some help. basically what I want to do is to query where a name is defined. is there a way to do that on GHC souce code? for simple programs I just load modules into GHCi and run :info command but now I'm not sure how can I do that.
13:51:58 <osa1> for example, there is a name `isProfiled` used in ghc/InteractiveUI.hs and I want to see it's definition.
13:52:04 <johnw> if you have Haskell -> C -> Haskell (via a FunPtr), the inner Haskell will SIGSEGV if it throws an exception into C
13:52:32 <dmwit> johnw: dangit
13:52:37 <dmwit> johnw: That's not what I want to hear. =P
13:52:52 <johnw> I had to wrap all my callbacks with code that turned exceptions into result codes
13:52:52 <dmwit> johnw: (But sort of what I was guessing.)
13:52:54 <haasn> edwardk: why is there a “timingOut” in the example given for ‘repeated’: >>> timingOut $ 5^..taking 20 repeated
13:53:17 <haasn> and several others
13:53:25 * int-e wonders what the FFI spec says about exceptions
13:53:56 <dmwit> johnw: http://sourceforge.net/mailarchive/message.php?msg_id=31254375
13:54:16 <dmwit> ?where report
13:54:16 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
13:54:43 <int-e> "If an evaluation triggered by an external invocation of an exported Haskell value returns with"
13:54:46 <dmwit> int-e: undefined
13:54:46 <int-e> an exception, the system behaviour is undefined. Thus, Haskell exceptions have to be caught
13:54:49 <int-e> within Haskell and explicitly marshalled to the foreign code.
13:54:52 <dmwit> yep
13:55:01 <dmwit> Okay, that's a pretty definitive answer.
13:55:02 <dmwit> Thanks.
13:55:17 <dmwit> I should have thought of going straight to the source. =)
13:56:02 <monochrom> I guess that's necessary. after all, what would you tell the C code instead?
13:57:39 <int-e> tough. you could sleep forever instead of crashing.
13:57:56 <int-e> which probably wouldn't make anybody happy either.
13:58:21 <dmwit> monochrom: Yeah, I was having trouble imagining a good way of saying something to the C code, too.
13:59:19 <monochrom> I have tried C -> Haskell, the Haskell code has Int divide-by-0, the GHC runtime aborted it rather than segfault.
13:59:21 <chrisdone> int-e: http://fuuka.warosu.org/data/jp/img/0109/35/1369467443327.jpg
13:59:31 <johnw> ok, I guess SIGABRT is possible too
14:00:53 <crdueck> osa1: you might get an answer here, but you should probably try #ghc for ghc-hacking specific questions
14:03:34 <dmwit> int-e++ johnw++
14:32:17 <zomg> uh, is there some kind of file caching if I use runhaskell?
14:32:54 <zomg> I have a relatively simple wai app which serves some files from the filesystem, and for whatever reason it just keeps serving an older version of the file..
14:33:13 <zomg> this is on localhost, and I tried three different browsers and they all got the old file so it couldn't be a browser cache issue either
14:33:17 * hackagebot openpgp-crypto-api 0.6.1 - Implement cryptography for OpenPGP using crypto-api compatible libraries  http://hackage.haskell.org/package/openpgp-crypto-api-0.6.1 (StephenWeber)
14:33:28 <hpc> zomg: try clearing cache anyway
14:34:10 <zomg> hpc: that was the first thing I tried
14:34:20 <gertc> is there a standerd way to go from a Netwerk.URI to a list of query url parameters? ?p1=hello,p2=world -> [("p1","hello"),("p2","world")]
14:37:47 <quchen> gertc: This package seems to be relevant: http://hackage.haskell.org/packages/archive/uri/0.1.6.1/doc/html/Text-URI.html
14:38:03 <quchen> I don't know how 'standard' it is though.
14:40:56 <gertc> or is it that trival to get a list?
14:42:42 <haasn> looks like Network.URI doesn't care about individual parameters or anything
14:42:50 <haasn> but just has a single String for the entire ‘query’ section
14:43:50 <gertc> http://hackage.haskell.org/package/network-2.4.1.2 i dont know why they are several uri things around?
14:44:07 <byorgey> the 'uri' package is not very standard
14:44:37 <byorgey> it only has 3 reverse dependencies.
14:44:56 <gertc> ok so i should stick with http://hackage.haskell.org/packages/archive/uri/0.1.6.1/doc/html/Text-URI.html ?
14:45:34 <gertc> how do you check reverse dependencies ?
14:46:03 <geekosaur> http://packdeps.haskellers.com/reverse
14:46:29 <sclv_> wow i am bad at that game
14:46:34 <byorgey> gertc: if it does what you want, sure.
14:47:06 <byorgey> sclv_: what game?
14:47:45 <sclv_> wrong channel, whoops. the youtube missle defenders easter egg
14:47:51 <sclv_> we were discussing it on -blah
14:53:18 <S_J> how do I make my quickcheck tests run by cabal fail or pass? now cabal reports PASS whether they fail or succeed
14:53:18 * hackagebot llvm-general-pure 3.2.7.0 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.2.7.0 (BenjaminScarlet)
14:53:20 * hackagebot llvm-general-pure 3.3.7.0 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.7.0 (BenjaminScarlet)
14:53:57 <donri> S_J: you need to exitFailuer
14:54:23 <byorgey> S_J: cabal decides on PASS vs FAIL by the exit value of the test executable
14:54:50 <donri> S_J: or use a framework that does it for you like any of: HTF, hspec, tasty, test-framework
14:58:18 * hackagebot llvm-general 3.2.7.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.7.0 (BenjaminScarlet)
14:58:20 * hackagebot llvm-general 3.3.7.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.7.0 (BenjaminScarlet)
14:59:43 <S_J> main = do
14:59:43 <S_J>      prop_inverses
15:00:06 <S_J> For HUnit you can pass all your unittests to one function, quickcheck does not have the same?
15:03:18 * hackagebot openpgp-crypto-api 0.6.2 - Implement cryptography for OpenPGP using crypto-api compatible libraries  http://hackage.haskell.org/package/openpgp-crypto-api-0.6.2 (StephenWeber)
15:04:14 <Peaker> S_J, tasty and test-framework/etc let you wrap up QuickCheck tests as "Test" thingies you can group up and get nice reports on
15:04:41 <clahey> So, a common thing to do in concurrent programming is to have a queue to move data from one thread to another.
15:04:56 <clahey> Is there such a queue implemented effectively in haskell?
15:05:03 <johnw> yes
15:05:04 <johnw> several
15:05:07 <clahey> Or is such a thing just not how you would do things?
15:05:08 <johnw> TChan is my favorite
15:05:15 <johnw> then there is Chan, TQueue, TBQueue, etc.
15:06:00 <johnw> @hoogle Chan
15:06:00 <lambdabot> Control.Concurrent.Chan data Chan a
15:06:00 <lambdabot> Control.Concurrent.Chan module Control.Concurrent.Chan
15:06:00 <lambdabot> package chan-split
15:09:46 <clahey> First match from google search for TChan was very much not what I was looking for.
15:09:47 <clahey> johnw, So, Chan is basically TChan with atomically wrapped around each of the functions?
15:09:47 <clahey> In concept, not in implementation of course.
15:10:10 <c_wraith> no
15:10:19 <c_wraith> It's Chan *in* STM
15:10:24 <c_wraith> you add the atomically calls yourself
15:10:48 <c_wraith> Which is important for letting you do things like "read from whichever three of these TChans has a value ready first"
15:11:04 <johnw> or even "sniff through this TChan to see if it has what I'm looking for"
15:11:09 <clahey> c_wraith, Right.  I was saying it the other way around.  You could implement Chan in terms of TChan by adding atomically.
15:11:09 <c_wraith> That's incredibly hard with Chan, incredibly easy with TChan
15:11:21 <luite> on the other hand, STM lacks fairness
15:11:30 <johnw> true
15:11:39 <clahey> A good point.
15:12:05 <quchen> luite: Completely? Therefore, is it not safe to have a TChan to distribute work to N workers somewhat evenly?
15:12:31 <quchen> luite: I'm asking because I have this program that has a thread per network connection, and sometimes I need to send a certain signal down one of them.
15:12:43 <clahey> quchen, If only some of the workers are working, but the queue is empty, does it matter?
15:12:44 <quchen> Right now I'm using a TChan do do it (for no good reason really).
15:12:56 <clahey> Oh, I suppose it does if it's not CPU resources you're concerned about.
15:13:11 <quchen> clahey: The thing is that the network integrity depends on that different workers receive the signal.
15:13:21 * hackagebot llvm-general-pure 3.2.7.1 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.2.7.1 (BenjaminScarlet)
15:13:21 * hackagebot llvm-general 3.2.7.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.7.1 (BenjaminScarlet)
15:13:25 <quchen> clahey: I haven't had issues yet, but I just want to be somewhat safe.
15:13:35 <luite> quchen: with a regular MVar you have a queue of waiters, STM doesn't have queues, transactions can be restarted, so it's really hard to make any fairness guarantees
15:13:42 <clahey> quchen, I was assuming you had multiple workers to distribute CPU resources, not to distribute other resources.
15:13:58 <quchen> clahey: No, it's structural concurrency, not for speedup.
15:14:15 <quchen> clahey: But you're right, if it was for speedup the thing would just solve itself.
15:14:46 <quchen> luite: Good point. I'll just change it to Chan, which wile apparently less performant than TQueue makes a better channel for my needs there.
15:14:48 <clahey> So, if I want to do a bunch of purely functional computations in side threads and pass the information to a main thread, will the computations repeat themselves if the queue retries...   Oh, I know the answer.
15:15:12 <quchen> If STM retries, nothing happens except that it retries.
15:15:17 <quchen> s/if/when
15:15:24 <MOMI> Hi.How is  GHCI support coming along for ARM based device, where can I read more about it.Thanks.:9
15:15:29 <luite> quchen: asl long as you don't need the nonblocking isEmptyChan
15:15:37 <clahey> Do the computation in IO and then atomically post the answer to the thread.
15:15:53 <quchen> 25, male, germa...oh wait ;-)
15:16:20 <quchen> luite: I only need read/write, to API wise all chans will do.
15:16:58 <quchen> I just saw "TQueue is the fastest" and instantly went "I NEED THAT" … for like 10 signals per second sent down the pipeline ;-)
15:17:01 <clahey> quchen, I was imagining something like: do {job <- readTChan jobQueue; writeTChan (result job)}
15:17:30 <clahey> That's missing a resultQueue, but you get what I mean.
15:18:02 <clahey> If the writeTChan retried, it would do a new readTChan which would mean that result would get recalculated.
15:18:36 <clahey> But I can just do {job <- atomically (readTChan jobQueue); atomically (writeTChan resultQueue (result job)) }
15:19:29 <clahey> I guess what I'm asking is whether, in implementation, that would end up recalculating (result job) but I don't think it will.
15:20:02 <c_wraith> clahey: it will create a new thunk, but it won't evaluate either of them
15:20:55 <clahey> c_wraith, Oh, it'll post the thunk to the channel?
15:20:59 <c_wraith> yes
15:21:03 <clahey> In other words making it totally useless.
15:21:17 <c_wraith> if you're expecting to use them for parallelism, yes
15:22:40 <clahey> So, what I'm trying to do is have a window on screen and have it respond to mouse events while calculating information to display in the window.
15:22:48 <clahey> Let's say each pixel's information is independent.
15:23:47 <clahey> I was originally going to write it as a state based mechanism in a single thread that updated a little bit of state in IO (probably using IOArray).
15:24:05 <clahey> Then I would run that IO () over and over again checking the time until it used up 10 ms.
15:24:28 <clahey> Then return control to the main loop which would do any user interaction and then call my idle function again which would run for 10 ms.
15:24:47 <clahey> But someone suggested I look into Orc or STM for doing something concurrent like this.
15:25:02 <clahey> But I'm trying to figure out what this might look like.
15:27:30 <mel-> Hi
15:27:30 <clahey> So I was thinking of having the main thread send jobs that are requests to update portions of the screen and then have the helper threads do computations and send them back.
15:28:17 <clahey> Now that I think about it though, for the main thread to get the information it would have to either poll or have something hooked into the Gtk main loop.
15:28:56 <monochrom> see my http://www.vex.net/~trebla/haskell/gtk-interact.xhtml
15:29:02 <clahey> So maybe I just need to use Gtk's concurrency model, as much as it is kinda primitive.
15:29:35 <mel-> say I am using Gtk2hs and want to define a data type which holds a Gtk widget as a value. at some point I initialize instances of this data type to default 'empty' values. what would be the equivalent of a NULL pointer in C for a GtkWidget* type? I'm looking for a 'widget value' in Haskell/Gtk2hs which stands for 'no valid widget'.
15:31:43 <clahey> mel-, Presuming it's fairly haskelly, you would have the type be Maybe Widget and Nothing would stand for no valid widget.
15:32:07 <clahey> monochrom, postGUIAsync is a Gtk thing I assume?
15:32:17 <stickles> asd
15:32:24 <monochrom> it is gtk2hs's
15:32:28 <clahey> monochrom, That's what I meant when I said the Gtk concurrency model, but I see you can use the queue to get information the other way.
15:32:37 <mel-> clahey: that would work, yes.... thanks!
15:32:47 <clahey> monochrom, Right.
15:32:58 <clahey> In gtk it would be "g_idle_add"
15:33:29 <quchen> clahey: Sorry, had to leave earlier. I appreciate your advice, but I think I didn't describe my problem enough. For completeness sake, here's what I'm doing: An individual has connections to N other nodes and keeps track of both the number of its neighbours, and the number of nodes it is neighboured by. If there's a deficiency, it should tell one of the workers to send a signal of sorts "hey, please add me" to the network, which then bounce
15:33:30 <quchen> s over several relays before some other client accepts the request. The fairness problem now comes up when I always send such requests to the same part of the network, for that reason I wanted to know how safe in that respect using TQueue was.
15:33:51 <quchen> Anyway, that's been answered, just wanted to conclude the conversation. :-)
15:34:30 <clahey> monochrom, Ah, a supervisor thread that starts worker threads.
15:34:52 <clahey> But it only ever launches one extra worker thread.
15:35:05 <clahey> So there's a supervisor thread that sits there doing nothing most of the time.
15:37:18 <clahey> Oh, I guess it has to both monitor the worker thread and kill it if necessary.
15:42:19 <clahey> monochrom, Is there an issue where a thread is in the middle of actually writing out a TMVar at the end of an "atomically" block and leaves things in an inconsistent state?
15:42:47 <monochrom> I wrote it before the very nice lib "async" occurred. today I may use "async" and get a simpler program
15:42:59 <c_wraith> If that ever happens, it's a bug in STM
15:43:40 <c_wraith> No matter what happens, an STM transaction should commit or roll back.
15:49:31 <owen> is there any way to do this more elegantly: foldl f x (replicate n f)
15:50:38 <c_wraith> err.  you're folding f over n copies of f?
15:50:41 <clahey> c_wraith, Excellent.  I wasn't sure how that would interact with things outside of the STM framework, but if that works, that's fantastic.
15:51:17 <owen> i just want to do f to an x n times
15:51:27 <c_wraith> iterate f x !! n
15:51:50 <c_wraith> > iterate (+1) 0 !! 10
15:51:51 <lambdabot>   10
15:52:19 <owen> > 1+1
15:52:20 <lambdabot>   2
15:52:29 <owen> lol, thats awesome
15:52:40 <Saizan> remember that "iterate f x !! n" is going to use O(n) stack for a strict f
15:52:50 <c_wraith> yeah, that's the only downside.
15:52:56 <c_wraith> Works best for nonstrict f or small n
15:53:06 <owen> any other non-recursive solns?
15:53:33 <c_wraith> well. All solutions are recursive.  Some just hide it better than others.
15:53:42 <owen> yeah, thats what i mean
15:54:13 <owen> there most be something idomatic that everyone uses
15:54:17 <Saizan> foldl' (\a _ -> f a) x (replicate n ()) -- :)
15:54:31 <c_wraith> hah.  that one's stricter!
15:54:32 <Saizan> the iterate thing is the most common i'd say
15:54:41 <owen> that seems worse than just writing the recursion explicitly
15:54:42 <ClaudiusMaximus> terate succ 0 !! 100000000 ~~>> <interactive>: out of memory (requested 1048576 bytes)  ; strictly (iterate succ 0) !! 100000000 ~~>> 100000000
15:54:50 <ClaudiusMaximus> where  strictly [] = [] ; strictly (x:xs) = x `seq` (x : strictly xs)
15:55:23 <Saizan> yeah, i wonder if strictly is buildable out of Control.Parallel.Strategies
15:55:35 <Saizan> owen: ouch! i'm offended
15:55:39 <clahey> How do I specify that I want to calculate a value strictly?
15:56:07 <clahey> seq?
15:56:34 <owen> \s?
15:56:57 <owen> i mean i like it
15:57:12 <owen> its just less readable i think
15:57:17 <Saizan> clahey: seq is close but it's not exactly that
15:57:34 <Saizan> clahey: though that's what you're going to use
15:58:19 * hackagebot esqueleto 1.3.1 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.1 (FelipeLessa)
15:58:36 <Saizan> clahey: if you have d = x `seq` y then x is going to get evaluated to WHNF before d is
15:58:53 <clahey> So I would do something like do {job <- atomically readTChan jobChannel; result `seq` atomically writeTChan resultChannel result where result = calculate job }
15:59:06 <clahey> Add lots of parentheses.
15:59:35 <ClaudiusMaximus> clahey: seq (or -XBangPatterns), or $! (which uses seq), or deepseq or $!! when WHNF (weak head normal form) isn't enough (but at that point you probably should have considered strict data structures and profiled to work out exactly where things are too lazy, as deepseq is a bit of a sledgehammer)  see also evaluate :: a -> IO a
15:59:38 <Saizan> clahey: yeah, if evaluating result up to the outermost constructor is enough for you
16:00:08 <clahey> Saizan, Hmm, which it probably isn't.
16:00:23 <maruchan> In ghci, why doesn't import Date.Time give an error if it fails? I do ghc-pkg list | grep time and see time-1.4, and I do ghci -package time-1.4 but I still don't get fromGregorian when I import Date.Time. Ideas?
16:00:57 <c_wraith> maruchan: what version of GHC?
16:01:10 <maruchan> c_wraith: 7.4
16:01:12 <geekosaur> there's at least one buggy ghc version where ghci import gives no error on failure
16:01:20 <c_wraith> maruchan: some version of ghc have issues with "import Module" doing something different from ":m + Module"
16:01:39 <c_wraith> Especially related to instances.
16:02:04 <applicative> Data.Time , not Date.Time maruchan
16:02:13 <drovenbaker> how does haskell compare to c/c++ in terms of speed and efficiency?
16:02:22 <maruchan> applicative: haha, just figured that out from the :m + message
16:02:25 <clahey> Saizan: Because then it will still create a slightly more evaluated chunk and pass that to the main thread where it will try to use the value to set the color of a pixel it will then calculate the data in the main thread.
16:02:26 <applicative> Data.Time.Calendar
16:03:07 <clahey> Saizan ClaudiusMaximus, Maybe I actually want deepseq?
16:03:20 <applicative> drovenbaker: I don't think c is the thing we're trying to beat mostly. It's enough that e.g. java is clobbered ;)
16:03:40 <clahey> And python is absolutely blown away.
16:03:54 <drovenbaker> applicative: python is blown away?
16:04:32 <clahey> ClaudiusMaximus, Oh, but instead I can use a strict data structure to be the type of object that I pass across to the main thread.
16:04:37 <drovenbaker> I know little to nothing about haskell, but it looks like a cool language and I'm interested in the pros vs other languages
16:05:26 <clahey> ClaudiusMaximus, So if I need to pass back a tuple (x, y, color) I just create a strict type containing those three values and have the resultChan pass those types of objects.
16:06:25 <ClaudiusMaximus> drovenbaker: i can write haskell code to solve problems much more speedily and efficiently than i can write c/c++ to solve the same problems; for the parts that need to run fast computing numerical things i can use the FFI to C code, or use OpenCL
16:06:43 <ClaudiusMaximus> clahey: yeah, and make sure color is a strict type too
16:07:01 <applicative> drovenbaker: where the python is a thin veneer over C python can do well; otherwise haskell will tend to be faster, but that's not surprising since it's compiled http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=python3&data=u64q
16:07:17 <applicative> not that these benchmarks are too decisive.
16:07:22 <quchen> drovenbaker: Haskell often has performance comparable to other natively compiled languages. That, however, should not be the reason for picking up a new language. Haskell is interesting, and that's what you should learn it for. That said, good night.
16:08:16 <clahey> ClaudiusMaximus, Ah, no way to say "This type should be deeply strict"
16:08:20 <drovenbaker> So the advantages of haskell is it's speed and small code complexity?
16:08:24 <clahey> ClaudiusMaximus, Why is this preferable to using deepseq?
16:09:23 <clahey> drovenbaker, Modularity is a big part of decreasing code complexity.
16:09:32 <ClaudiusMaximus> clahey: because deepseq requires you to instance NFData, and more importantly if you deepseq something that's already fully evaluated you waste time traversing the whole thing again
16:09:56 <clahey> drovenbaker, Then there's provability, though I'm not sure how often that's used.
16:10:16 <clahey> ClaudiusMaximus, Ah, not recalculating, just walking over the data to check.
16:10:21 <ClaudiusMaximus> yep
16:11:08 <clahey> ClaudiusMaximus, Does NFData do what things like Show does where you can just say that you're NFData and if all of your fields are NFData, then you are?
16:11:36 <Peaker> clahey, you mean "does NFData have deriving?"
16:11:40 <clahey> Peaker, Yes.
16:11:53 <Peaker> clahey, No, but the "derive" package can do that for you
16:11:58 <Peaker> (with template haskell)
16:13:10 <ClaudiusMaximus> drovenbaker: nonstrict evaluation is awesome, referential transparency is awesome too, and don't forget the awesome type system too
16:14:07 <applicative> drovenbaker: it is a miracle that such a beatiful language should have such an awesome compiler.
16:14:18 <clahey> I love that when I get a program to compile, it pretty much always does what I wanted it to.
16:14:26 <Ghoul_> ^ that omg
16:14:36 <Ghoul_> That feeling I've had more in haskell than any other language
16:14:42 <Ghoul_> by 2 magnitudes.
16:14:48 <drovenbaker> ClaudiusMaximus:  What is haskell typically used for? i.e. which industries use it heavily?
16:15:49 <Ghoul_> I think its used in web
16:15:53 <cmccann> drovenbaker: AWESOME industries is what
16:15:57 <cmccann> like you have no idea
16:16:20 <clahey> I know we have the monthly haskell get togethers at akamai.  I'm pretty sure it's used some there.
16:16:38 <clahey> And I know someone that works in the financial industry.
16:17:00 <Ghoul_> honestly I think haskell is probably used the most to improve haskell haha
16:17:08 <ClaudiusMaximus> drovenbaker: http://www.haskell.org/haskellwiki/Haskell_in_industry
16:17:21 <Ghoul_> But, with that being said, you hear about it in finance/stat tracking a bit
16:17:33 <cmccann> to be fair most of the industrial Haskell use seems to be in industries that aren't much for talking about software they use internally
16:17:56 <acowley> You hear about it a lot in robotics, too… right?
16:17:56 <cmccann> there's not much that hits anywhere near the consumer market other than a handful of startups maybe
16:18:01 <Philippa> cmccann: that's kinda the big thing, yeah. Big-stakes stuff where reliability matters, but /competitive/ big stakes stuff
16:18:04 <applicative> it's a little irritating that, hopefully things like fpcomplete will improve the situation, as galois of course did
16:18:05 <luite> drovenbaker: currently /r/haskell on reddit has posts for job openings for financial, biotech/medicine, web (a few times) and compiler/data processing stuff
16:18:47 <Philippa> the biotech/medicine may well be effectively compiler/data processing stuff in nature as well, not that I've checked
16:18:47 <Ghoul_> ive often heard haskell is the most desirable language to write a compiler in
16:19:04 <Philippa> I dunno about that, but I've not built the compiler for my language yet :p
16:19:04 <luite> Philippa: it's dynamical systems simulation work
16:19:13 <Philippa> luite: ah, fair enough
16:19:20 <Ghoul_> and I know someone on this channel is writing a huge commercial actionscript compiler using it, but I forget who
16:19:33 * applicative is somehow not helped by the expression 'dynamical systems simulation'
16:19:41 <drovenbaker> Thanks the help guys, seems like a cool language
16:19:45 <luite> hmm, dunno about actionscript
16:19:53 <applicative> Ghoul_: well, if there's a Haskell php compiler why not?
16:20:18 <Philippa> applicative: "dynamic system" is a fairly general term of art, so I'd assume it's meaning doing so at that level of generality
16:20:22 <luite> mtasc was written in ocaml
16:20:23 <cmccann> applicative: I think that's the technical term for "really complicated shit"
16:20:30 <acowley> applicative: People differentiatin' their doodads and simulating things
16:20:40 <flux0r> wait...is there really a php compiler?
16:21:05 <mauke> hphp
16:21:23 <luite> applicative: that's as much info as they give (dynamical systems in the differential equations sense)
16:22:09 <flux0r> is that facebook
16:22:28 <applicative> flux0r: maybe that's not the word for it, it generates haskell, which is compiled
16:22:31 <Ghoul_> Im not sure about facebook, but I heard about google using it before
16:22:33 <Philippa> luite: which makes sense, given that control systems are a potential application
16:22:34 <applicative> https://github.com/jhartikainen/hs-language-php I think this is the one
16:22:52 <acowley> Check out gbaz's work on delayed differential equations
16:23:13 <acowley> …and I'm blanking on the package name
16:23:15 <flux0r> no...facebook uses something called hphp that they pronounce hip hop...it's not the same thing
16:23:16 <flux0r> haha
16:23:43 <flux0r> that's close enough to a compiler
16:23:44 <flux0r> cool
16:24:55 <hpaste> Peaker pasted “GHC panics on this...” at http://lpaste.net/91681
16:25:19 <Peaker> ghc 7.6.2 and 7.6.3 both panic on this. anyone has older/newer GHC's to test it out with?
16:26:09 <Ghoul_> Peaker: thats an interesting thing to error on
16:26:39 <acowley> Peaker: Panic on 7.6.1, too
16:26:57 <Peaker> acowley, thanks
16:27:14 <Ghoul_> carter: ping
16:27:16 <applicative> frankly I don't blame it; i'm kind of panicking too
16:27:27 <Ghoul_> I know you have 7.8 lying around, maybe you can help this man out ^
16:28:27 <luite> i get kind incompatibilities
16:28:31 <luite> with head
16:28:35 <flux0r> 7.4.2 on windows gives a kind compatibility error
16:30:24 <ClaudiusMaximus> Peaker: annotated - 7.4 seems fine (kind error)
16:30:49 <Peaker> ClaudiusMaximus, 7.4.?
16:31:02 <ClaudiusMaximus> Peaker: .1 and .2
16:31:03 <applicative> oh Peaker, it doesnt panic on my 7.7
16:31:59 <Peaker> thankshttp://ghc.haskell.org/trac/ghc/ticket/8120
16:32:18 <applicative> it gives this error with last week's HEAD http://sprunge.us/JiJT
16:32:39 <Peaker> yeah, a kind error is to be expected
16:33:06 <Peaker> costed me quite a bit of time to minimize my source for the bug report (and to install newest ghc stable to see if it was fixed)... can finally get back to my business
16:34:11 <applicative> i've seen this panic before, kind system hysteria so to say
16:36:07 <meretrix> Is there any package with a pretty print function that works in ghci and will print record syntax with each value on a separate line?
16:36:09 * tabemann hopes he sold his coworkers on STM....
16:37:37 <Peaker> @package groom
16:37:38 <lambdabot> http://hackage.haskell.org/package/groom
16:37:38 <acowley> meretrix: Doesn't haskell-mode have an interactive mode variant that does this?
16:37:38 <Peaker> meretrix, http://hackage.haskell.org/packages/archive/groom/0.1.2/doc/html/Text-Groom.html
16:37:38 <meretrix> acowley: I'll have to look, I guess it's not on by default.
16:37:38 <meretrix> Thanks, I'll check out groom too.
16:37:38 <tabemann> why isn't lambdabot responding when I /msg it?
16:37:50 <tabemann> it messaged me saying I had a message and that I should /msg it @message to read it, but it doesn't do anything when I do
16:37:50 <applicative> i do /query lambdabot
16:37:54 <applicative> oh
16:38:00 <tabemann> oh now it did
16:38:02 <tabemann> it was just slow
16:40:53 <tabemann> (well, at least my STM lecture went over better than my Haskell lecture...)
16:40:54 <themuffinman> I'm looking to build a small army of nano quadrocopter drones fitted with machine guns and hire them out to the highest bidder. How do you suggest I go about doing this?
16:41:28 <Ghoul_> @faq can haskell do that?
16:41:28 <lambdabot> The answer is: Yes! Haskell can do that.
16:41:43 <tabemann> (but STM is much easier to fit into an hour or so than even the very basic concepts of Haskell)
16:42:31 <Ghoul_> I never found stm confusing or hard
16:43:08 <Ghoul_> Maybe I should buy and read one of those books. it probably only becomes confusing once someone tells you all the really fine details about it.
16:43:09 <themuffinman> I want to cross breed badgers with robot geese to produce godless maurauding killing machines. Can haskell do that?
16:43:15 <tabemann> the first third of my lecture was basically explaining, in case my coworkers didn't already know, why locking and conditions *really fucking suck*
16:43:30 <Ghoul_> @faq can haskell cross breed badgers with robot geese to produce godless maurauding killing machines?
16:43:30 <lambdabot> The answer is: Yes! Haskell can do that.
16:43:42 <Ghoul_> themuffinman: last question. Those are ridiculous and dont belong here hrnng.
16:45:03 <tabemann> the rest was basically explaining what STM is, why one wants STM, how it works, how to program in it, and going over a couple concurrency problems using it (and comparing with locking versions of those problems)
16:45:07 <themuffinman> I apologize if I have caused offence. I was merely curious about the capabilities of haskell as a language for wreaking havoc. I shall dimish into the east...
16:45:56 <Ghoul_> (did I scare him away, or did he come here to troll?)
16:46:14 <tabemann> well, I didn't present specific implementations of the locking versions of those problems, but explained why they were hard
16:46:48 <Ghoul_> "lockless" implies less locks though, right?
16:46:50 <tabemann> (just going over locking implementions of dining philosophers could have easily eaten up an hour)
16:46:55 <Ghoul_> Not completely lock free..
16:46:59 <acowley> Ghoul_: That was some relatively good-natured trolling
16:47:31 <tabemann> Ghoul_: but when there are locks in STM, they are entirely hidden from the programmer, and the programmer can program as if they don't exist
16:49:05 * tabemann doesn't know if GHC's STM uses locks or not
16:49:26 <FreeFull> I wonder if typeOf from Data.Dynamic is a good way to find out what types ghci defaults to
16:50:03 <FreeFull> Probably not
16:50:13 <applicative> trace (show (typeOf x)) x
16:50:15 <DiegoNolan> what is the difference between intmap and intset?
16:50:38 <c_wraith> DiegoNolan: whether it has values associated with the Ints
16:50:48 <acowley> one maps Ints to things, the other just maintains a set of Ints
16:50:58 <DiegoNolan> ah
16:51:06 <acowley> IntSet ~ IntMap ()
16:51:08 <DiegoNolan> that was a stupid question
16:51:46 <acowley> Someone just asked us about breeding badgers with robot geese, and you think your question was stupid?
16:52:36 <c_wraith> ...  what did you answer?
16:52:50 <DiegoNolan> ?
16:53:09 <DiegoNolan> i'm saying i see how silly of a question it was the names clearly explain the differences
16:53:54 <c_wraith> yet it was still a better question than asking if acowley can breed badgers with robot geese. :)
16:53:55 <DiegoNolan> i can't seem to find IntMap in cabal
16:54:00 <c_wraith> it's in containers
16:54:49 <acowley> c_wraith: I started a long answer about the practical difficulties typically encountered when dealing with robot geese, then moved on to the anatomical compatibility problems and how you have to develop protocols to keep the badgers relaxed… then I realized it was a troll :(
16:55:21 <Ghoul_> But its OK because we have the badger-protocol package for that
16:55:34 <acowley> Acme strikes again?!
16:58:56 <erisco> when making a template function, is there some way to alias types?
16:59:12 <c_wraith> template function?
16:59:18 <erisco> oh damn sorry
16:59:20 <erisco> wrong channel
17:23:13 <benzrf> hey
17:26:29 <benzrf> hello
17:26:43 <benzrf> where can I find a pair of functions of the type (a -> Bool) -> (a -> Bool) -> (a -> Bool)
17:26:55 <benzrf> for use with filter
17:31:09 <pentace> benzrf: What exaclty are you trying to do?
17:31:31 <benzrf> pentace: I want to 'compose' predicates
17:32:15 <benzrf> i.e. pass (elem 2) and (elem 3) to a hypothetical 'predicateAnd' function and get back a function that checks both
17:32:15 <pentace> @pl \p q x -> p x || q x
17:32:15 <lambdabot> liftM2 (||)
17:32:23 <benzrf> ._.
17:32:26 <benzrf> ugh
17:32:31 <benzrf> I don't know anything about function lifting
17:32:33 <benzrf> .pl
17:32:36 <benzrf> @help pl
17:32:36 <lambdabot> pointless <expr>. Play with pointfree code.
17:32:38 <geekosaur> time to learn, then
17:32:44 <benzrf> :O
17:33:05 <benzrf> @type liftM2
17:33:05 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:33:25 <benzrf> ah
17:33:29 <benzrf> so using functions as monads?
17:33:39 <FreeFull> benzrf: liftM2 is like fmap but with more parameters
17:33:50 <FreeFull> And yeah, it's using the function monad
17:34:02 <FreeFull> Also known as the Reader monad
17:34:33 <FreeFull> :t join (.)
17:34:33 <lambdabot> (c -> c) -> c -> c
17:34:42 <FreeFull> :t join
17:34:42 <lambdabot> Monad m => m (m a) -> m a
17:35:07 <zRecursive> :t liftA2
17:35:08 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
17:35:24 <pentace> > filter ((||) <$> even <*> odd) [1..10]
17:35:25 <zRecursive> more general
17:35:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
17:35:57 <FreeFull> ((||) <$> even <*> odd) has to be the most useless predicate =P
17:36:01 <FreeFull> :t ((||) <$> even <*> odd)
17:36:01 <lambdabot> Integral a => a -> Bool
17:36:28 <pentace> I couldn't come up with a better example quickly :P
17:37:15 <pentace> > filter ((&&) <$> even <*> (<7)) [1..10]
17:37:16 <lambdabot>   [2,4,6]
17:37:37 <edwardk> Philippa: http://www.cse.chalmers.se/~bernardy/PP.pdf
17:38:09 <edwardk> > [1..10]^..traverse.filtered even.filtered (<7)
17:38:11 <lambdabot>   [2,4,6]
17:38:21 * hackagebot retry 0.3.0.0 - Retry combinators for monadic actions that may fail  http://hackage.haskell.org/package/retry-0.3.0.0 (OzgunAtaman)
17:38:57 <Philippa> edwardk: thanks. Have opened, will leave for another night as I'm kinda worn out
17:39:53 <Philippa> edwardk: anything in particular I should be looking out for beyond general shiny?
17:40:01 <edwardk> Philippa: basically its the sort of bottom up tree-adjoining model that i like, but it has a really interesting observation about the charts that occur in practice in CYK/Valiant parsing that gives them nifty asymptotics in practice
17:40:35 <edwardk> in parallelizable O(log^3 n) in a not so tight analysis that looks like log^2 n in practice
17:41:24 <Philippa> cool
17:41:25 <zzing> Is there a nice stable library to create graphs? Specifically, I need to generate a probability density function graph.
17:41:58 <Philippa> ...dammit brain, don't throw me "smart" ideas that are probably interestingly-phrased bullshit right now
17:51:54 <zrathustra> hi guys, I have a friend who is into haskell and it's his birthday today - is there anything I could get him that's haskell-related?
17:52:21 <hpc> http://www.amazon.com/Learn-You-Haskell-Great-Good/dp/1593272839/
17:52:39 <ion> If he’s already into Haskell he probably doesn’t need a tutorial book.
17:52:49 <hpc> LYAH is a good book regardless
17:52:54 <zrathustra> yea he's already read it
17:53:43 <pentace> Did he read Real World Haskell as well?
17:54:00 <zrathustra> yea
17:54:01 <enthropy> zzing: http://hackage.haskell.org/package/Chart is decent. If you already know gnuplot there are a couple bindings for that (one in hmatrix I think)
17:54:04 <geekosaur> how about the one that just came out?
17:54:15 <zrathustra> anything just related to functional programming in general?
17:54:21 <zrathustra> other than SICP
17:54:45 <mirari> purely functional data structures?
17:54:55 <mirari> Okasaki
17:55:30 <zzing> enthropy, looks decent, not sure if I can get gtk2hs going (mac)
17:55:43 <dobblego> On this blog post http://chrisdone.com/posts/hulk-haskell-irc-server there is a Map Ref Client, however, there is no instance Ord Ref, so how can this be? What am I missing?
17:55:57 <zrathustra> @mirari: thanks!
17:55:57 <lambdabot> Unknown command, try @list
17:56:08 <zrathustra> mirari: thanks!
17:56:53 <mirari> zrathustra dare I suggest a Scala or Clojure book if he is into functional programming in general
17:57:13 <zrathustra> oh that'd be great too
17:57:24 <zzing> Is there a way to represent infinity?
17:57:42 <enthropy> > 1/0
17:57:42 <lambdabot>   Infinity
17:57:57 <zzing> :t (1/0)
17:57:58 <lambdabot> Fractional a => a
17:58:00 <mirari> In that case; Programming Scala and the Joy of Clojure
17:58:17 <zzing> :t (1%0)
17:58:17 <lambdabot> Integral a => Ratio a
17:58:25 <haasn> :t infinity
17:58:25 <zzing> > 1%0
17:58:26 <lambdabot> Natural
17:58:26 <lambdabot>   *Exception: Ratio has zero denominator
17:58:45 <zzing> I am using rationals, so I was just checking :-)
17:58:49 <mirari> zrathustra: Also ML for the Working Programmer, Types and Programming Languages
17:58:52 <zzing> Have to use floats for this part
18:07:29 * tabemann is somehow disappointed that Accelerate doesn't support AMD GPUs, even though he himself has an nVIDIA GPU...
18:07:40 <tabemann> (I'm reading Simon Marlow's book)
18:08:49 <johnw> tabemann: well, it is a research endeavor at the moment, so they'd be coding it to what they have available, right?
18:09:06 <haasn> aren't there cross-platform APIs for this kind of stuff?
18:09:07 <johnw> I think it's not quite at the point where we can expect commercial completeness
18:09:14 <haasn> like OpenCL
18:09:22 <johnw> yeah, but I hear OpenCL bites hard
18:09:33 <johnw> carter I'm sure will expound on that for us :)
18:09:38 <tabemann> haasn: I'm not sure how feasible compiling with OpenCL at runtime is
18:11:07 <haasn> okay
18:11:41 <tabemann> I didn't know that OpenCL bit though
18:12:27 <johnw> I would like it to use OpenCL if only to take advantage of those AMD GPUs on the new Mac Pro coming out
18:13:04 <tabemann> it would be a good idea to support OpenCL just to be more broadly usable, even if it has inferior performance
18:14:20 <tabemann> even if it had to actually at runtime generate *source code* and *compile* it... even though that would probably result in terrible latency (but then GPU computation tends to have quite a bit of latency anyways)
18:20:58 <zzing> If I have an instance Show Opinion, and I want to export that in my module, how might I do that?
18:22:06 <edwardk> zzing: all instances get exported. all the time
18:22:15 <zzing> ok, awesome
18:22:16 <edwardk> if you import that module you get all of its instances transitively
18:22:48 <tabemann> even if you don't want them
18:22:59 <edwardk> tabemann: to do otherwise would damage confluence
18:23:06 <tabemann> (GHC considers all instances to be global for a given GHC instance)
18:24:00 <edwardk> tabemann: well, the 98 report says that two different instances anywhere in the program is an error.
18:24:10 <edwardk> so its right to do so
18:24:20 <tabemann> even though there's now things like overlapping instances
18:24:22 <edwardk> one might argue its wrong not to check more aggressively
18:24:36 <edwardk> overlapping instances almost never work as well as one might want them to
18:25:12 <edwardk> if you define them both in the same module and don't use constraint kinds and the sun and the moon are Taurus and mercury is in retrograde it all works
18:25:18 <tabemann> somehow the idea of overlapping instances just seems bad to me, but apparently in practice it has its uses (like undecidable instances)
18:25:25 <applicative> with an improved check, if you make an overlapping instance, all of hackage burns up
18:25:29 <applicative> confluenza
18:25:31 <danharaj> undecidable instances is hella better behaved
18:26:04 <applicative> undecidably instances is awesome, it sounded so scary before I say what it was
18:26:15 <applicative> undecidable instances is pretty good too
18:26:20 <tabemann> it just means that you're turning off GHC's termination checker, right?
18:26:37 <edwardk> undecidable instances are usually okay. the requirement that you are shrinking on all arguments of an MPTC is somewhat insane, but technically required to avoid cycles
18:26:49 <tabemann> so in theory you could make GHC not terminate, but it opens up many cases where GHC is too conservative otherwise
18:27:12 <danharaj> edwardk: maybe we should stop fooling around and use datalog as our class constraint language :P
18:27:47 <edwardk> well, the worst case of what'll happen isn't that ghc won't terminate its that it'll put a little strict fragment of code that will loop forever chasing the constraint in a loop
18:28:37 <tabemann> at least it's not the missile-launching horror that is TH
18:28:40 <edwardk> the decidability thing is a check that constructing those dictionaries takes a bounded amount of time
18:29:33 <edwardk> since they are strict, shrinking by one type constructor on all arguments is a sufficient condition to ensure termination, but it isn't the only one
18:29:37 <danharaj> doesn't ghc have a limit on how deep it goes trying to make dictionaries even if you do have undecidable instances?
18:29:48 <edwardk> thats compile time, not the runtime
18:29:51 <danharaj> ah
18:30:23 <edwardk> that depth limit is why if you use type-int you can only compute with numbers up to about 2^20th in binary and 2^70th in hex
18:31:01 <danharaj> you've checked, huh?
18:31:10 <edwardk> (and coincidentally why had a make the hex version rather than a decimal one) ;) not quite big enough to compute Int64s at the type level otherwise without increasing the size of the stack
18:31:12 <edwardk> yep
18:31:20 <edwardk> i was originally going to stop with binary ;)
18:31:38 <danharaj> edwardk: When are you going to implement IEEE754 like you did in days of yore :P
18:31:46 <edwardk> unlikely
18:31:56 * tabemann for some reason isn't attracted to the idea of doing computation, at compile time, *with types*
18:32:12 <johnw> tabemann: never got into C++ templates did you? :)
18:32:26 <tabemann> johnw: I used C++ templates for what they were meant to be used for :)
18:32:30 <adnap> edwardk: I understand blog.sigfpe.com/2007/01/monads-hidden-behind-every-zipper.html that you linked. I made http://ideone.com/hEGDWS to solve my problem and it works. However, the most modern Zipper on Hackage seems to be http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Control-Lens-Zipper.html, and I don't understand it. Should I learn how to use this one? Can I use it like a comonad as I did in my code example?
18:33:00 * tabemann is still horrified from learning that with TH you can make GHC launch missiles *at compile time*
18:33:19 <edwardk> tabemann: well, i've been thinking it could be fun to make a type level checker for DLAL, so we can make a little EDSL in which you can check at compile time that all functions written in that EDSL execute in polynomial time
18:33:19 <edwardk> but doing that encoding in typeclasses is … daunting
18:33:22 * hackagebot BlogLiterately-diagrams 0.1.2.1 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.2.1 (BrentYorgey)
18:33:25 <sipa> tabemann: can you make it run IO?
18:33:31 <tabemann> sipa: yep
18:33:38 <edwardk> :t zipper
18:33:39 <lambdabot> Not in scope: `zipper'
18:33:45 <edwardk> damn lambdabot is on 3.10
18:34:01 <edwardk> adnap: you might want to look at the zippers in 3.8
18:34:08 <edwardk> they were much less scary
18:34:31 <tabemann> DLAL?
18:34:35 <edwardk> hey are being split into a separate package explicitly so we can provide both old and new style
18:34:35 <adnap> edwardk: Can you understand my solution, f', without Zippers? I don't know which one is faster
18:34:58 <edwardk> dual light affine logic
18:34:59 <ddinh> Is there a way to convert ints to word8s?
18:35:08 <zzing> tabemann, what they were meant for? Quite a difference as to how they are used now.
18:35:23 <ddinh> can't find anything with int -> word8 type on hoogle
18:35:51 <luite> fromIntegral
18:35:52 <tabemann> I'm used to using C++ templates to basically provide a bloated version of generic typing, with some other features more akin to parameterized modules in MLs
18:35:56 <arkeet> ddinh: fromIntegral
18:36:03 <ddinh> Oh, thanks.
18:36:06 <ddinh> It's polymorphic?
18:36:10 <edwardk> i would recommend using Zipper a = Zipper [a] a [a]    -- that way its clear that the second list is non-empty
18:36:11 <arkeet> :t fromIntegral
18:36:12 <lambdabot> (Integral a, Num b) => a -> b
18:36:29 <zzing> unsafeCoerce :-)
18:36:34 <arkeet> zzing: :-(
18:36:41 <zzing> I have used that before
18:36:41 <tabemann> unsafeCoerce is bad and wrong
18:36:47 <ddinh> Thanks!
18:36:54 <gertc> (hlint )what does too strict if mean? t <- if c then create a else create b
18:37:05 <arkeet> gertc: create (if c then a else b)
18:37:12 <edwardk> adnap: you can also look up an old zipper-from-any-traversable implementation i did forever ago. one sec
18:37:28 <tabemann> I'd argue that it's worse than unsafePerformIO, because there are some basic guidelines one can follow to make that still be pure, but with unsafeCoerce you just have to *know* the underlying representation
18:37:34 <gertc> arkeet: thx :)
18:37:55 <ion> Well, you *know* the underlying representation for newtypes is the same.
18:38:03 <edwardk> adnap: http://hackage.haskell.org/packages/archive/comonad-extras/3.0.1/doc/html/Control-Comonad-Store-Zipper.html
18:38:04 <tabemann> but that's just newtypes
18:38:30 <tabemann> and because they're newtypes, one should *know* that there is no performance hit from pattern matching them, so there should be no need for unsafeCoerce
18:38:37 <edwardk> tabemann: i've never used it more than 200 times in one package if it makes you feel better.
18:38:42 <c_wraith> tabemann: that's not true.
18:39:05 <c_wraith> tabemann: map (unNewType) ≈ unsafeCoerce
18:39:06 <zzing> What is the way to solve an ambiguous module name? There are two packages Data.Accessor is in: stateref-0.3 and data-accessor-0.2.2.3, I assume there should be a way to specify which one
18:39:16 <c_wraith> tabemann: but the map sure is slower
18:39:25 <edwardk> tabemann: 'fmap Sum'
18:39:28 <edwardk> i need to traverse that whole container doing nothing and come out the other side having done no work, destroyed all my sharing and wasted time
18:39:36 <tabemann> oh I see
18:39:47 <tabemann> unsafeCoercing a data structure of newtypes...
18:40:05 <ion> zzing: ghc-pkg hide oneofthem
18:40:08 <tabemann> now this is why we need Coercible, as I've mentioned before
18:40:20 <edwardk> tabemann: i'm currently trying to come up with a sound way to do that using the new role inference with richard eisenberg
18:40:26 <arkeet> wasn't there an extension that let you specify the package for imports?
18:40:31 <tabemann> as then one can have what one can legitimately do with unsafeCoerce, but safely
18:40:37 <edwardk> that way you can perhaps compose together witnesses of representational equality and them map that over a functor in O(1)
18:41:05 <edwardk> zzing: you can use PackageImports and then import "data-accessor" Data.Accessor
18:41:15 <arkeet> yeah, -XPackageImports
18:41:16 <tabemann> you could make it so that, for class Coercible a b where coerce :: a -> b, all newtype-non-newtype pairs are automatically added,
18:41:23 <zzing> ok
18:41:24 <zzing> meci
18:41:31 <haasn> edwardk: why is there a “timingOut” in the example given for ‘repeated’: >>> timingOut $ 5^..taking 20 repeated
18:41:33 <edwardk> it muddles your code with provenance information though
18:41:40 <tabemann> then with Coercible there should be no need for unsafeCoerce
18:41:58 <zzing> Chart is compiled and works, thaknj you for the suggestion
18:41:58 <edwardk> haasn: timingOut is used to ensure the test doesn't take an unbounded amount of time in the presence of an error.
18:42:19 <edwardk> when we had bugs in taking it could loop forever, causing travis to take a half hour or so to report back
18:42:25 <haasn> oh
18:42:34 <edwardk> now it reports back a timeout failure in 30 seconds or whatever if that loops too long
18:42:51 <haasn> that makes sense. It was strange to see it as part of documentation, I didn't realize travis attempts to run these examples
18:43:04 <tabemann> edwardk: Coercible wouldn't ensure that *all* representationally equal values could be interconverted in zero time, but it would make sure that pairs that *are* members can be
18:43:22 <edwardk> all those (>>>) lines are actually doctests that get executed every time we commit. all the extra signatures also get verified programmatically from time to time by glguy
18:43:30 <tabemann> for instance you could have instance Coercible a b => Coercible [a] [b] where....
18:44:03 <arkeet> ...=> Coercible (f a) (f b)
18:44:28 <tabemann> arkeet: what about unboxed types, would that still work for them?
18:44:30 <edwardk> tabemann: well, what I'd want is something like data (a :: x)@R ==# (b :: x)@R where Like :: (a ~R# b) -> a ==# b; instance Category (==#) where id = Like; Like . Like = Like
18:44:58 <edwardk> tabemann: then you can make something like fmapLike :: (a ==# b) -> f a -> f b into an extra member of Data.Functor.Functor (only exported from there, not all the other places)
18:45:22 <edwardk> and we can make deriving Functor populate it with code that exploits the representational role of the type argument
18:46:23 * tabemann is trying to parse all that...
18:46:34 <edwardk> so that users who want to use something like vacuous from Data.Void can get O(1) behavior, and an expensive 'fmap Sum' can become an O(1) fmapLike (newtyped Sum) for the subset of users who care
18:46:56 <tabemann> the question is, what if something is a Functor and is also something like an unboxed array... can we still trust it to work with them?
18:46:58 <edwardk> that gives composable, reversible, coercions
18:47:04 <edwardk> yes
18:47:09 <edwardk> its representational equality
18:48:10 <tabemann> is the ":: x" so that it can work on kinds other than *?
18:48:29 <tabemann> or things like Nat?
18:48:33 <edwardk> the trick here is that the default definition of fmapLike is to just fmap . cast    for some cast :: (a ==# b) -> a -> b
18:48:35 <ion> What’s ~R#?
18:48:50 * tabemann barely understands half of that, ~R# included
18:48:54 <edwardk> so for any Functor that isn't properly roled and for which the instance wasn't built by deriving nothing happens
18:49:18 <edwardk> ion: thats based on the Role stuff going in. http://ghc.haskell.org/trac/ghc/wiki/Roles
18:49:22 <ion> thanks
18:49:29 <edwardk> thats also a bit of pseudo-code since ~R# isn't being exposed to the user level
18:49:53 <danharaj> I noticed Stephanie Weirich is involved in like 90% of the awesome stuff that goes into GHC :P
18:50:17 <edwardk> a.) she's awesome, b.) she has some pretty awesome grad students
18:51:09 * tabemann barely understand half of the awesome that is going into GHC at the moment; he can barely wrap his brain around GADTs, and has yet to wrap his brain around type families, much the less stuff like polykinds and whatnot
18:51:24 <danharaj> yes it seems like she has made a haskell ninja factory down at upenn.
18:51:43 <edwardk> tabemann: basically thats saying (==#) takes two arguments that can have any kind so long as both kinds agree, and it only cares about equality on them up to representational equality.
18:51:53 <tabemann> edwardk: I gathered that
18:52:41 <johnw> edwardk: GADTs are just syntactic sugar for a Yenoda embedding, or are they something more?
18:52:46 <edwardk> in practice the ==# type would probably have to be implemented using good old fashioned type equality, then hiding the data constructor in an Unsafe module and just exporting combinators with the right API, etc. making it more painful than the direct encoding
18:53:31 <tonyday567> :t fst . (\i -> (i,i))
18:53:32 <lambdabot> b -> b
18:53:43 <tonyday567> :t id
18:53:44 <lambdabot> a -> a
18:54:02 <edwardk> johnw: well, there is an old standby: https://personal.cis.strath.ac.uk/patricia.johann/tlca07-rev.pdf that describes how to derive the power of them in general
18:54:02 <tonyday567> :t id = fst . (\i -> (i,i))
18:54:03 <lambdabot> parse error on input `='
18:54:07 <arkeet> :t join (,)
18:54:08 <lambdabot> a -> (a, a)
18:54:24 <danharaj> :t (,)
18:54:25 <lambdabot> a -> b -> (a, b)
18:54:30 <edwardk> johnw: but with System Fc in the mix, etc. and the way they are encoded, and all the current tricks i'd be sticking my neck out pretty far to say they are just that ;)
18:55:00 <arkeet> :t extract
18:55:01 <lambdabot> Not in scope: `extract'
18:55:11 <edwardk> tony: that should hold in any cartesian category
18:55:14 <johnw> edwardk: OK, good to know
18:55:19 <tonyday567> is there a way to check you have an equivalent function?  Like id == fst . (\i -> (i,i))
18:55:39 <danharaj> @djinn a -> a
18:55:39 <lambdabot> f a = a
18:55:42 <edwardk> tonyday567: you're looking for a notion of 'extensional equality' but you can't solve that in general
18:55:46 <arkeet> tonyday567: you can apply them to something (by hand) and see if they come out the same
18:55:57 <tabemann> isn't doing that with *all* functions solving the halting problem?
18:56:03 <pentace> @check \x -> id x == fst (join (,) x)
18:56:04 <edwardk> here you can get by on the free theorem and 'fast and loose reasoning'
18:56:06 <lambdabot>   +++ OK, passed 100 tests.
18:56:10 <edwardk> tabemann: hence why you can't do it in general
18:56:18 <arkeet> sometimes you can tell just from the type, assuming your function is total and whatever
18:56:22 <edwardk> pentace: notice it defaulted to using () invalidating your test ;)
18:56:24 <arkeet> or whatever
18:56:35 <pentace> aww
18:56:37 <edwardk> here we can use the free theorem for (a -> a) and the fact that it terminated
18:56:45 <danharaj> freeorem
18:56:47 <tonyday567> via check, great!
18:56:56 <arkeet> quickcheck isn't a proof
18:57:00 <arkeet> =)
18:57:08 <arkeet> @check \x -> x /= 10000
18:57:11 <lambdabot>   +++ OK, passed 100 tests.
18:57:15 <edwardk> tonyday567: quickcheck may give false positives but it won't tell you there is a problem when there isn't
18:57:28 <edwardk> er false negatives
18:57:30 <tabemann> quickcheck doesn't require one to either learn coq or agda, or figure out how to prove it with pen and paper
18:57:32 <arkeet> unless you accidentally check something different
18:57:42 <arkeet> > id x
18:57:43 <lambdabot>   x
18:57:47 <arkeet> > fst (join (,) x)
18:57:48 <lambdabot>   x
18:58:09 <edwardk> my usual approach is to keep adding type parameters until i can't generalize any more and let the free theorem force me into the only implementation that is left
18:58:38 <edwardk> i write general code because it is easier to write and more likely correct than specific code
18:59:02 <arkeet> general code makes fewer assumptions that can be violated.
18:59:21 <tonyday567> edwardk true positives is what I need right now
18:59:30 <tabemann> more specific code can be generated for you by the compiler with inlining as needed anyways
18:59:36 <tabemann> there's no reason to not let the compiler do its job
19:00:19 <BMeph> edwardk: Happy Birthday! Share a slice of cake w/ Donald Bellisario!! :)
19:00:24 <edwardk> tonyday567: well, the equivalence of fst . (\x -> (x,x)  and id follows in any cartesian category from the definition of products and the diagonal morphism, and Hask and Set are both cartesian
19:00:55 <danharaj> isn't there some noise about haskell only having weak products
19:01:28 <edwardk> danharaj: only if you want to get anal retentive about _|_s and here the equality holds under 'fast and loose reasoning'
19:01:43 <danharaj> kk :P
19:01:44 <edwardk> so so long as both functions are giving back defined results their results will match
19:02:04 <danharaj> fast and loose reasoning is for people who don't tie knots
19:02:18 <edwardk> danharaj: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.59.8232&rep=rep1&type=pdf
19:02:24 <edwardk> danharaj: no, even if you do
19:02:31 <danharaj> yes idk why I said that
19:02:32 <edwardk> that paper makes what i just said rigorous
19:02:35 <danharaj> it's for people who don't seq
19:02:40 <edwardk> even if you do
19:02:50 <edwardk> you can recover free theorems in the presence of seq as well
19:03:01 <edwardk> http://www.iai.uni-bonn.de/~jv/p76-voigtlaender.pdf
19:03:05 <danharaj> o rly
19:03:06 <BMeph> edwardk: Heh-heh... "anal retentive about _|_s" - I see what you did there! ;)
19:03:12 <edwardk> =)
19:03:13 <tonyday567> :t getLine >>= \i -> return (i,i)
19:03:13 <lambdabot> IO (String, String)
19:03:18 <danharaj> I didn't know you had interesting free theorems in the presence of seq.
19:03:29 <tabemann> doesn't reasoning with equality of things containing undefines break down in the presence of seq?
19:03:31 <tonyday567> :t fst $ getLine >>= \i -> return (i,i)
19:03:31 <lambdabot>     Couldn't match type `IO' with `(,) a0'
19:03:32 <lambdabot>     Expected type: (a0, String)
19:03:32 <lambdabot>       Actual type: IO String
19:03:39 <danharaj> oh hey that's the name of this paper
19:03:41 <danharaj> what are the odds????
19:03:52 <tonyday567> I'm trying to get at the first String
19:03:57 <edwardk> tabemann: not quite. voightlaender's paper goes into how they weaken.
19:04:08 <geekosaur> tonyday567, how much Haskell do you know?
19:04:25 <BMeph> danharaj: Late edit: "those who abstain from seqs," you mean. ;)
19:04:26 <ion> tonyday567: fmap fst
19:04:34 <tonyday567> geekosaur relatively little
19:04:40 <tabemann> you want: liftM fst $ getLine >>= \i -> return (i, i)
19:04:40 <geekosaur> @where lyah
19:04:41 <lambdabot> http://www.learnyouahaskell.com/
19:04:44 <edwardk> tonyday567: the fst :: (a,b) -> b   but    getLine >>= \i -> (i,i) :: IO (a,b)          (a,b) and IO (a,b) don't match.
19:04:57 <ion> tonyday567: fmap :: (a -> b) -> IO a -> IO b
19:05:04 <edwardk> we can use 'fmap' :: (a -> b) -> f a -> f b    to turn fst into a function you can apply there
19:05:17 <edwardk> then fmap fst :: IO (a,b) -> IO a
19:05:20 <danharaj> edwardk: btw do you know of a nice account of parametricity in category theoretic terms?
19:05:22 <tonyday567> geekosaur have read thru lyah but that doesnt mean it sticks
19:05:28 <edwardk> can be applied to getLine >>= \i -> return (i,i)
19:05:28 <tabemann> liftM is for Monads what fmap is for Functors, and that is just because Functor hasn't been made a superclass of Monad
19:05:34 <geekosaur> you can't just use an IO, you can't just "reach inside it", you effectively need to use callbacks on them. fmap / liftM wraps a callback around the IO action to do what you specify
19:05:48 <tabemann> but most "good" things that are instances of Monad should also be instances of Functor
19:06:02 <geekosaur> (although to a limited extent you can pretend it's "reaching inside")
19:06:05 <arkeet> tabemann: not all?
19:06:12 <geekosaur> @quote /bin/ls
19:06:13 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
19:06:17 <edwardk> danharaj: uday reddy talks a bit about the similarity of (di)naturality and parametricity in idealized algol i think. dan doel has a post on comonad.com which i think is copied in the pdf folder post-crash
19:06:31 <tabemann> arkeet: it would be all if Functor *were* a superclass of Monad
19:06:37 <danharaj> edwardk: ok cool
19:06:48 <arkeet> tabemann: it is all because you said "should"
19:06:50 <arkeet> =)
19:06:56 <edwardk> danharaj: both of them are trying to capture the same concept but the notion of naturality you get from parametricity isn't alwyas the notion of naturality you want for the category you are describing
19:07:08 <tonyday567> :t fmap fst $ getLine >>= \i -> return (i,i)
19:07:08 <lambdabot> IO String
19:07:17 <danharaj> edwardk: ah I think I read that post by dolio
19:07:29 <arkeet> :t getLine >>= \i -> return (fst (i,i))
19:07:29 <lambdabot> IO String
19:07:34 <geekosaur> arkeet, that just means if there are any things people care about that are Monad but not Functor, that should be fixed. (since at this point waiting for AFM feels like waiting for Godot)
19:07:45 <geekosaur> er, FAM
19:07:51 <danharaj> edwardk: I was wondering what the resolution to that failure of parametricity was.
19:07:54 <arkeet> I don't know what FAM is.
19:08:05 <geekosaur> Functor -> Applicative -> Monad
19:08:05 <danharaj> after the fact, but I don't think he went that far with it.
19:08:31 <geekosaur> aka making all Monads automatically Functor and Applicative
19:08:55 <gnuvince-> @pl \a b -> not (a && b)
19:08:55 <lambdabot> (not .) . (&&)
19:08:55 <arkeet> sure.
19:09:00 <edwardk> you may also want to read (or re-read) the baez et al. rosetta stone paper. it talks a bit about dinaturality in the context of proof trees, which is kind of like the notion of parametricity we use, you might think of parametricity as a sort of 'internal naturality' or something but that is totally non-rigorous
19:09:51 <edwardk> geekosaur: its going in
19:10:16 <edwardk> everyone agreed, unanimously, the committee all agreed, david i think even banged out the patch
19:10:46 <arkeet> edwardk: !
19:11:01 * tabemann didn't know that it was that far along
19:11:04 <arkeet> this is the first I've heard of itl.
19:11:12 <ion> Is the patch available for reading somewhere?
19:11:21 <danharaj> I think I missed that section of the rosetta paper.
19:11:29 <edwardk> arkeet: we're hoping to be able to get it in 7.8, get foldable/traversable in 7.10, and maybe split-base for 7.12
19:11:38 <edwardk> danharaj: its near the end
19:11:45 <danharaj> ah that may be why :P
19:11:48 <arkeet> what is it about foldable/traversable?
19:11:49 <edwardk> ion: not sure, there is a ghc trac issue
19:11:50 <tabemann> I presume they are going to be providing default definitions of fmap and (<*>) for Monad, for all the other Monads out there that have not defined them yet?
19:11:54 <danharaj> a paper with that many ideas tends to get digested over many readings
19:12:09 * danharaj is the cow of programmers
19:12:14 <edwardk> arkeet: generalizing the combinators in Prelude to the ones from Foldable/Traversable and moving Foldable/Traversable/Monoid into Prelude
19:12:19 <arkeet> ah
19:12:33 <maxiepoo> :t foldM
19:12:34 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
19:12:34 <danharaj> edwardk: shouldn't Foldable/Traversable be made obsolete by lens? ;)
19:12:56 <edwardk> danharaj: nope, they are all still relevant for reference if nothing else. i have to get the combinators i make 'Of' versions of from somewhere! ;)
19:13:05 * tabemann has wrapped his brain around Foldable and Traversable, but has yet to wrap his brain around Lenses....
19:13:06 <danharaj> ah good point!
19:13:12 <edwardk> also traverse is kind of canonical lens stuff =)
19:13:22 <danharaj> Lenses are just lenses in the category of edwardk's github page. What's the problem?
19:13:24 <edwardk> > sumOf both (1,2)
19:13:25 <lambdabot>   3
19:13:36 <edwardk> > sumOf (traverse.both) [(1,2),(3,4)]
19:13:37 <lambdabot>   10
19:13:56 <danharaj> > sumOf traverse (1,2)
19:13:58 <lambdabot>   2
19:14:01 <maxiepoo> :t sumOf
19:14:02 <lambdabot> Num a => Getting (Endo (Endo a)) s a -> s -> a
19:14:04 <danharaj> wait
19:14:12 <edwardk> traverse on a pair traverses the second element =P
19:14:13 <arkeet> danharaj: traverse for pairs just traverses the second element.
19:14:16 <edwardk> unify the types
19:14:21 <danharaj> that is gross
19:14:25 <edwardk> it has to be that way
19:14:29 <danharaj> yes I know
19:14:32 <edwardk> and you'll claw that instance out of my cold dead hands
19:14:35 <danharaj> haha ok
19:14:40 <danharaj> I don't have claws tho :(
19:14:42 <arkeet> > sumOf traverse ("hello",2)
19:14:44 <lambdabot>   2
19:15:02 <edwardk> > sumOf _1 (42,12390)
19:15:03 <lambdabot>   42
19:15:19 <danharaj> edwardk: fill in this sentence for me: Lens is just a ______ in the _-category of _______. What's the ______?
19:16:11 <danharaj> > sumOf (traverse.both.traverse) ([1,2,3], [11,22,33])
19:16:12 <lambdabot>   Couldn't match expected type `(t0 a0, t0 a0)'
19:16:12 <lambdabot>              with actual type...
19:16:20 <arkeet> something about store comonad coalgebras?
19:16:40 <arkeet> > sumOf (both.traverse) ([1,2,3],[11,22,33])
19:16:41 <lambdabot>   72
19:16:41 <danharaj> sumOf (traverse.both.traverse) [([1,2,3], [11,22,33])]
19:16:43 <danharaj> yes
19:16:46 <edwardk> A lens is just a family of morphisms between representable profunctors
19:16:59 <danharaj> ok now you have my attention :p
19:17:27 <edwardk> An isomorphism is just a family of morphisms between profunctors
19:17:40 <edwardk> A prism is just a family of morphisms between corepresentable profunctors
19:18:04 <danharaj> A traversal...
19:18:40 <edwardk> A traversal is just a family of morphisms between profunctors that are representable by an strong lax semimonoidal endofunctor
19:18:46 <edwardk> er by a
19:19:10 <johnw> heh
19:19:31 <johnw> semimonoidal?
19:19:35 <johnw> so its a semiapplicative?
19:19:36 <edwardk> er monoidal
19:19:42 <tabemann> now how do I use lenses without knowing category theory? heh
19:19:48 <danharaj> edwardk: by family of morphisms do you mean a family of natural transformations?
19:19:54 <arkeet> tabemann: import Control.Lens  ;-)
19:20:02 <edwardk> tabemann: by just calling functions that look like they should fit
19:20:02 <arkeet> danharaj: dinatural, presumably.
19:20:13 <arkeet> wait.
19:20:14 <arkeet> no.
19:20:20 <arkeet> it's that thing.
19:20:23 <johnw> When you peer into the lens, it peers into you.
19:20:33 <edwardk> danharaj: its an odd construction. it uses parametricity to bundle up something strange.
19:20:38 <danharaj> hmmm
19:21:26 <edwardk> type Iso s t a b = forall p. Profunctor p => p a b -> p s t -- ignoring the gory details to make it compatible with traverse -- but every such morphism must be constructed by using dimap    of some function (s -> a) and some function (b -> t)
19:21:33 <edwardk> so that Iso is isomorphic to a pair of functions
19:21:40 <edwardk> which can be recovered by choosing an appropriate Profunctor
19:22:04 <edwardk> when a = b, s = t, then that is the notion of an isomorphism people expect
19:22:19 <arkeet> otherwise it's a family of isomorphisms.
19:22:31 <arkeet> er.
19:22:33 <edwardk> as it is it is an 'isomorphism family', because a and b are related, and s and t are related in the fashion both roconnor and i blogged about way back in the day
19:22:40 <arkeet> yeah
19:22:52 <arkeet> I haven't thought about this stuff in a while.
19:23:01 <edwardk> so its a 'one way trip' through the isomorphism family that can pick a different arrow to come back along
19:23:18 <edwardk> :t swapped
19:23:42 <edwardk> :t iso (snd &&& fst) (snd &&& fst)
19:23:42 <lambdabot> (Functor f, Profunctor p) => p (b, a) (f (a1, b1)) -> p (a, b) (f (b1, a1))
19:24:01 <edwardk> the 'Functor' comes in because we want that to compose with traverse, _1, etc.
19:24:09 <edwardk> but otherwise you can read off what i said above
19:24:23 <edwardk> an iso degrades into a lens by choosing p = (->)
19:24:30 <danharaj> hm
19:24:38 <arkeet> not quite (->)
19:24:49 <edwardk> well, with the extra f involved, it is exactly (->)
19:24:59 <edwardk> without the extra f its choosing p to be a representable profunctor
19:25:00 <arkeet> oh sure, with that one.
19:25:03 <arkeet> yes
19:25:14 <danharaj> ok that sorta makes sense
19:25:28 <danharaj> are 'iso's that aren't constructed from inverses still well behaved in any way?
19:25:42 <arkeet> they don't satisfy the iso laws. =)
19:25:46 <danharaj> well yes :P
19:25:52 <danharaj> but is there a nice free theorem for that type
19:26:03 <arkeet> otherwise it's just a pair of functions.
19:26:16 <edwardk> the forall p f (Profunctor p, Profunctor f) => p a (f b) -> … construction adds no power over and above the p a b     form, because we can use the fact that profunctor composition exists to construct any such p a (f b) as a new profunctor anyways
19:26:25 <arkeet> I guess that's the free theorem.
19:26:26 <edwardk> and we can choose Identity to make it go away
19:26:31 <danharaj> yes I suppose you're right
19:27:12 <edwardk> danharaj: the laws aren't enforceable there, but in the case of the iso construction there isn't anything else non-_|_ producing you can do
19:28:34 <edwardk> p a (f b) is equivalent to profunctor composition of UpStar f with p, UpStar f is representable by f, composition of representable profunctors is representable and (->) is the unit for profunctor composition.
19:28:42 <edwardk> showing the equality another way
19:28:45 <arkeet> (it should have been called DownStar =( )
19:28:51 <danharaj> profunctors are such cool
19:29:38 <edwardk> i was really happy when all the theory for this shook out
19:29:39 <arkeet> profunctors are nothing but kleisli arrows for the "free cocomplete category" monad
19:30:10 <edwardk> hrmm, the monad for going back and forth to the yoneda embedding or whatever it'd be?
19:30:13 <arkeet> where "free cocomplete category" = yoneda embedding
19:30:37 <edwardk> hadn't heard that description of profunctors before
19:31:06 <arkeet> it's just saying that a profunctor from C to D is a functor from C to Set^(D^op)
19:31:16 <arkeet> which agrees with the usual definition by adjointness
19:31:20 <edwardk> sure
19:31:38 <edwardk> that part i grok
19:31:48 <zzing> :t infinity
19:31:49 <lambdabot> Natural
19:31:55 <arkeet> > infinity
19:31:56 <lambdabot>   *Exception: stack overflow
19:31:59 <arkeet> =(
19:32:10 <zzing> infinity :: Natural?
19:32:15 <arkeet> yes
19:32:17 <zzing> :t (1/0)
19:32:17 <danharaj> :t to infinity
19:32:17 <lambdabot> Fractional a => a
19:32:17 <lambdabot>     Couldn't match expected type `s0 -> a0' with actual type `Natural'
19:32:17 <lambdabot>     In the first argument of `to', namely `infinity'
19:32:17 <lambdabot>     In the expression: to infinity
19:32:24 <danharaj> :t and beyond
19:32:25 <lambdabot>     Not in scope: `beyond'
19:32:25 <lambdabot>     Perhaps you meant `second' (imported from Control.Arrow)
19:32:29 <danharaj> soon
19:32:41 <danharaj> we just need to trick edwardk into defining a 'beyond' combinator
19:32:48 <edwardk> =P
19:32:54 <sclv> > infinity < 10
19:32:55 <lambdabot>   False
19:32:58 <danharaj> it should be easy because it is a preposition
19:33:03 <arkeet> edwardk: I guess the advantage of that view is that profunctor composition has an obvious definition this way.
19:33:03 <sclv> > infinity ^ 2 < 10
19:33:04 <lambdabot>   False
19:33:08 <edwardk> danharaj: true
19:33:10 <sclv> > infinity - infinity < 10
19:33:17 <arkeet> other than that I don't know what you get.
19:33:29 <sclv> > infinity - 1 < infinity
19:33:33 <sclv> > 10 < infinity
19:33:34 <lambdabot>   True
19:33:39 <edwardk> arkeet: yeah that little coend doesn't seem so unnatural then
19:33:40 <danharaj> arkeet: yoneda is one of those things that gives you everything by giving you nothing
19:33:47 <arkeet> =)
19:34:00 <sclv> > infinity `div` infinity < 10
19:34:10 <sclv> this infinity is pretty lame
19:34:38 <edwardk> of course, every sort of 'cut' like thing looks like that and you can fish around something dinatural/coendish when you try hard enough
19:34:53 <tabemann> sclv: how do you know that two different infinities have the same cardinality?
19:34:54 <edwardk> :t infinity
19:34:55 <lambdabot> Natural
19:35:01 <edwardk> naturally
19:35:14 <sclv> tabemann: practice!
19:35:22 <edwardk> tabemann: check to see if they are both greater than 1, if so, subtract one and try again
19:35:24 <edwardk> =)
19:35:30 <edwardk> come back to me when you finish
19:35:30 <tabemann> hah
19:35:34 <levi> How about a real infinity? :P
19:35:37 <danharaj> http://i.imgur.com/QI5fDjh.jpg  <— me right now
19:36:04 <arkeet> > [0..infinity]
19:36:05 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
19:36:07 <johnw> tabemann: I usually look for the subscript on the ℵ :)
19:36:53 <dolio> You should be asking: what's cardinality?
19:37:04 <sclv> this one it should actually be able to figure out:
19:37:05 <sclv> > 10 < infinity - (infinity `div` 2)
19:37:09 <lambdabot>   mueval-core: Time limit exceeded
19:37:15 <dolio> Sounds like an outdated concept to me.
19:37:43 <tabemann> sclv: operations on infinity are meaningless unless you have a concept of cardinality, which I highly doubt Haskell has in its "infinity"
19:37:45 <edwardk> tabemann: besides here they are purporting to be Natural. so they are lying.
19:38:09 <sclv> no these operations are all perfectly constructive and meaningful
19:38:23 <sclv> this is just a crummy implementation of infinity :-P
19:38:35 <sclv> its infinity a la peano
19:38:36 <sclv> i assume
19:38:47 <edwardk> tabemann: and if you instead accept the fact that they are doing so by living in the one point compactification of the naturals, then there is only one cardinality that fits. they are both necessarily countably infinite
19:39:08 <johnw> "countably infinite"
19:39:28 <edwardk> johnw: never said the term made any sense
19:39:37 <johnw> http://mathworld.wolfram.com/CountablyInfinite.html
19:39:54 <johnw> it's just curious, but I get it now
19:40:07 <sclv> i think countably unboundedly hueg is a more accurate term
19:40:11 <johnw> my mental model of a guy counting out a set of infinite stones just didn't work
19:40:41 <johnw> i feel like the word "transfinite" should come into play here
19:40:45 <sclv> > 1 < many
19:40:46 <lambdabot>   Ambiguous occurrence `many'
19:40:46 <lambdabot>  It could refer to either `L.many', defined at ...
19:40:56 <haasn> my intuition is that a set is countably infinite when it's isomorphic to ℕ
19:41:10 <johnw> haasn: I think that's what the page I linked to is saying
19:41:26 <haasn> johnw: I just loaded it. Indeed it is, and that's the canonical definition as far as I'm aware
19:41:35 <edwardk> haasn: good intuition
19:42:02 <sclv> > 10 < many `div` 2
19:42:03 <lambdabot>   Ambiguous occurrence `many'
19:42:03 <lambdabot>  It could refer to either `L.many', defined at ...
19:42:10 <sclv> > 10 < many' `div` 2
19:42:13 <lambdabot>   True
19:42:22 <sclv> there we go, much clearer
19:42:26 <sclv> > [1..many]
19:42:27 <lambdabot>   Ambiguous occurrence `many'
19:42:27 <lambdabot>  It could refer to either `L.many', defined at ...
19:42:31 <sclv> > [1..many']
19:42:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:42:58 <maxiepoo> :t many'
19:42:58 <lambdabot> Natural
19:43:19 <haasn> > many' < infinity
19:43:24 <sclv> > 10^100 < many'
19:43:28 <lambdabot>   mueval-core: Time limit exceeded
19:43:34 <tabemann> > ((many' + 1) - many')
19:43:36 <sclv> dumb nats :-P
19:43:38 <lambdabot>   mueval-core: Time limit exceeded
19:44:09 <sclv> can't even calculate with many in finite time!
19:44:36 <sclv> we could calculate with countable infinity perfectly well if only we had clocks that were uncountably fast
19:44:36 <haasn> I guess you need much' time to do so
19:44:47 <tabemann> > many' - many'
19:45:48 <tabemann> > 1
19:45:49 <lambdabot>   1
19:46:18 <tabemann> interesting... it just didn't evaluate "many' - many'", without reporting time limit exceeded
19:47:06 <haasn> tabemann: lambdabot can be quite strange at times
19:47:23 <haasn> it seems to omit type signatures a lot in recent times as well
19:47:47 <tabemann> for a sec I thought I actually made lambdabot hang or something
19:49:42 <tabemann> > (many' - many')
19:49:51 <tabemann> > ((many' + 1) - many')
19:49:54 <lambdabot>   mueval-core: Time limit exceeded
19:50:12 <tabemann> okay, so one results in time limit exceeded, but the other results in silent failure... why?
19:51:38 <dmwit> I'm guessing it's just a lambdabot thing.
19:51:45 <sclv> random
19:51:55 <dmwit> Probably if you try each of them a dozen more times you'll get one or two that work for each.
19:53:01 <tabemann> > (many' - many')
19:53:05 <lambdabot>   mueval-core: Time limit exceeded
19:55:06 <tabemann> random question
19:55:40 <tabemann> how is Natural internally represented, as I presume it's not actually S (... Z) in the internal representation
19:56:05 <Cale> Which Natural?
19:56:22 <tabemann> the one we've been using
19:56:37 <haasn> it is actually S (... Z)
19:57:17 <Cale> http://hackage.haskell.org/packages/archive/numbers/3000.1.0.3/doc/html/src/Data-Number-Natural.html#Natural -- I think it's probably this one
19:57:20 <tabemann> so it really is the naive impl. of a Natural (where you literally have data Nat = Z | S Nat)?
19:57:24 <haasn> tabemann: yes
19:57:27 <zzing> :t (1/0)
19:57:27 <lambdabot> Fractional a => a
19:57:32 <haasn> tabemann: nothing clever going on
19:57:51 <zzing> > 1/0
19:57:52 <haasn> Cale's source is accurate
19:57:52 <startling> :t Z
19:57:52 <lambdabot>   Infinity
19:57:53 <lambdabot> Not in scope: data constructor `Z'
19:58:06 <zzing> > Infinity
19:58:07 <lambdabot>   Not in scope: data constructor `Infinity'
19:58:51 <haasn> :t Data.Number.Natural.Z
19:58:51 <lambdabot>     Not in scope: data constructor `Data.Number.Natural.Z'
19:58:59 <haasn> oh, it isn't exported
19:59:07 <Cale> zzing: A mildly unfortunate feature of the show instance for floating point types is that there are a few values it prints as something other than valid Haskell code.
19:59:17 <Cale> zzing: It will read them though, I believe
19:59:21 <zzing> Cale, I am just going to use 1/0
19:59:23 <Cale> > read "Infinity" :: Doublw
19:59:24 <lambdabot>   Not in scope: type constructor or class `Doublw'
19:59:24 <lambdabot>  Perhaps you meant `Double...
19:59:24 <Cale> > read "Infinity" :: Double
19:59:25 <lambdabot>   Infinity
19:59:36 <haasn> (not that Show/Read have to conform to valid haskell expressions)
19:59:58 <Cale> Yeah, it's just nice if they can.
20:00:34 <Cale> Since typically, you'd like to be able to copy paste a shown data structure and use it as an argument to something while testing, for instance.
20:00:42 <zzing> I have a problem with an error: https://gist.github.com/iaefai/6b5c90aa6b7449f613cc   the repository with the two files: https://github.com/iaefai/SubjectiveLogic     It comes down to a constructor in one module (and exported), and imported into another but ghci saying it doesn't exist.
20:01:22 <tabemann> haasn: what's the point of not exporting it though? isn't the whole point of that representation of naturals is how you can then reason on it, e.g. in dependently typed languages
20:01:53 <Cale> zzing: Are you sure you have the right version of the SubjectiveLogic module?
20:02:11 <tabemann> if you're not exporting it you might as well represent it like an Integer - you'd get a far more compact representation that way
20:02:11 <Cale> oh
20:02:12 <zzing> Cale, yes, just updated the repository from my sources
20:02:14 <Cale> right, it's not exported
20:02:14 <haasn> tabemann: I don't know. I would have exported them, if only so you can pattern match on nats. I guess the intended use of the library is for stuff like genericLength
20:02:23 <zzing> hmm?
20:02:25 <Cale> SubjectiveLogic doesn't export Opinion's data constructor
20:02:26 <dmwit> zzing: Perhaps you would like to export Opinion(Opinion) or Opinion(..) instead of just Opinion.
20:02:27 <haasn> > genericLength [1..] > (50 :: Natural) -- tabemann
20:02:28 <lambdabot>   True
20:02:32 <Cale> It only exports the type abstractly
20:02:39 <haasn> > genericLength [1..] > (50 :: Integer)
20:02:40 <lambdabot>   *Exception: stack overflow
20:02:52 <Cale> You'll want to put Opinion(..) in the export list if you want to export the data constructors of the type
20:02:53 <zzing> Cale, can you elaborate more on that?
20:02:58 <zzing> ok
20:03:04 <mstksg> is there a way to say load a configuration file (yaml, json, etc.) using TH at compile-time?
20:03:20 <dmwit> mstksg: Yes, and there's a SO question about this.
20:03:22 <dmwit> Let's see here...
20:03:52 <dmwit> http://stackoverflow.com/q/6402158/791604
20:04:11 <mstksg> dmwit: thanks :) i appreciate it. must have been googling for the wrong things
20:04:20 * tabemann considers TH's ability to launch missiles at compile time a misfeature
20:04:24 <mstksg> is this a good idea?
20:04:31 <dmwit> I've heard worse.
20:04:45 <mstksg> i feel like it's a deal with the devil to avoid wrapping everything in IO
20:05:07 <dmwit> Oh, is that the only goal?
20:05:10 <dmwit> Why not use dyre, then?
20:05:13 <mstksg> yeah, it is
20:05:14 <tabemann> at least when you're launching missiles in code at runtime you know you're in side-effecting code, but with TH you can launch missiles anywhere!
20:05:19 <mstksg> oh, i'll look into that
20:05:37 <erisco> is there a name for a fixed list ie one that cannot be cons to?
20:05:51 <erisco> I'm just going to call them fixed lists otherwise
20:06:05 <mstksg> there are configuration things like host name, environment stuff, etc. that really won't change throughout run time/through the same machine
20:06:18 <dmwit> erisco: but... why?
20:06:27 <tabemann> the question is do you *really* need TH
20:06:48 <dmwit> mstksg: Okay, don't bother with dyre, then. =P
20:06:48 <tabemann> plenty of programs load configuration at runtime without compiling it into the executable
20:06:55 <erisco> dmwit, mm, what I'm implementing isn't in Haskell, but I am borrowing concepts
20:07:15 <dmwit> "list you can't cons to" isn't a concept in Haskell.
20:07:34 <erisco> oaky
20:07:35 <tabemann> erisco: an Array or Vector
20:07:55 <tabemann> (both of which have very different behavior from lists)
20:08:20 <tabemann> if you just want a list but don't want anyone consing it, wrap it in a newtype
20:08:25 <tabemann> and then implement your own accessors
20:08:52 <dmwit> I feel that all this advice is a bit hokey, because we don't yet understand the question well enough.
20:09:06 <zzing> :t (1/2)
20:09:07 <lambdabot> Fractional a => a
20:09:13 <zzing> > show (1/2)
20:09:14 <lambdabot>   "0.5"
20:09:18 <mstksg> i'm just trying to cheat and hold all my configurations in an instance of a data type that a module would export
20:09:28 <cdk> any recommended haskell tag generator plugins for vim?
20:09:51 <dmwit> mstksg: Really, TH seems fine to me.
20:10:08 <dmwit> I was just suggesting dyre because I like the idea of it, not because it seems to be a better fit for your project.
20:10:28 <mstksg> is this style of providing configurations a bad idea?
20:10:39 <tabemann> it sounds like there's much better ways of doing it
20:11:13 <mstksg> how do people normally do it?  without having to tie everything to IO?
20:11:15 <zzing> Why is ExistentialQuantification the name of the extension that allows forall b. in data declarations? Shouldn't it be universal instantitation?
20:11:21 <mstksg> or a Reader
20:11:36 <tabemann> it doesn't seem like you'll gain much out of using TH, and you'll instead get all of TH's baggage of generally brittle and dangerous code
20:11:47 <tabemann> read it in a file, haul it around with a Reader(T)
20:11:52 <tabemann> s/in/from
20:13:16 <mstksg> that sounds like the more sensible answer
20:13:53 <Ghoul_> is it possible to build a single haskell file into an object file utilizing cabal
20:14:03 <Ghoul_> so that its persistant between, ie: ghc, lhc, and any future compilers
20:14:09 <mstksg> i just already kind of made a huge mess with transformer stacks because when i started this project i didn't know how to use them this well. so maybe a huge refactoring is in order
20:14:39 <zzing> :t fromRational
20:14:40 <lambdabot> Fractional a => Rational -> a
20:14:43 <tabemann> I can understand wanting to avoid building too big of a stack myself
20:15:08 <tabemann> I myself am hesitant to use monad transformers for that reason, even though I'm using them for my latest project because they're a good fit for it
20:15:28 <tabemann> but the downsides of monad transformers definitely are outweighed by the downsides of TH
20:15:42 <monochrom> Ghoul_: make it a library package, then it can be registered with ghc
20:16:02 <Ghoul_> is there any other way?
20:16:15 <Ghoul_> I want to utilize cabals ability to know how to interface with lots of haskell compilers, without making it a real package
20:16:16 <mstksg> i don't think my actual stack would be too big, it's just that my old, only slightly less experienced self wrote myself into a hole and i'm going to have to rewrite a lot of things.  but i guess that's how you learn
20:16:48 <geekosaur> Ghoul_, cabal manages compilers' package (module) systems
20:17:02 <monochrom> I have not heard of any other way
20:17:04 <mstksg> oh i could also cheat and use cpp couldn't i
20:17:21 <mstksg> is that any less evil?
20:17:32 <monochrom> perhaps you can modify cabal's source code to not insist on "package"
20:17:36 <tabemann> cpp is ugly and has stupid downsides (forget about using prime)
20:17:44 <tabemann> cpp is less dangerous though
20:18:08 <tabemann> and cpp is unlikely to break with future versions of GHC, unlike TH
20:18:22 <Ghoul_> hmm, I could.
20:18:51 <Ghoul_> The thing is though, since im writing a cmake project for my project, I may as well try and make it as generic as possible
20:19:10 <Ghoul_> since the C++ side isn't locked into gcc and such, I thought it'd be cool if the haskell side wasn't ghc specific
20:19:18 <Philippa> mstksg: figuring out where the stack(s) being used change is often the biggest deal
20:19:39 <Philippa> not that there isn't rewriting to do, but the rest is usually fairly mechanical after that once you've figured out what new discipline you're going to follow
20:19:46 <alpha123> Ghoul_: Hugs isn't maintained any more AFAIK, so being GHC-specific is not really a bad thing.
20:20:15 <tabemann> (it doesn't seem as if people really try to write portable Haskell code these days)
20:20:22 <Ghoul_> intel should make a haskell compiler
20:20:28 <Ghoul_> if they made one it would kick ass.
20:20:38 <Ghoul_> they have the machinery behind ICC -- who saw that thing on reddit?
20:21:00 <Ghoul_> anyway, thanks for the advice
20:21:22 <mstksg> Philippa: thanks, i'll keep that in mind
20:21:50 <tabemann> the problem with Intel making a Haskell compiler is that, if it were a viable option, then we'd have to deal with incompatibilities between it and GHC
20:21:56 <alpha123> Ghoul_: GHC is crazily smart, I think even Intel would have a hard time topping it.
20:22:19 <tabemann> and thus it would become non-viable to take advantage of the huge feature-set that is specific to GHC
20:22:32 <mstksg> can we just standardize ghc into haskell already. what's taking them so long
20:22:37 <tabemann> unless Intel decided to implement it too, and even then there would likely be an in impedance mismatch
20:22:38 <Ghoul_> ^ lol that
20:22:48 <Philippa> mstksg: because we haven't standardised GHC into GHC yet
20:22:52 <alpha123> tabemann: I think if Intel (or anyone else for that matter) made a Haskell compiler it would pretty much have to be GHC-compatible to be at all useful.
20:23:07 <Philippa> tabemann: having them start with a Core compiler might be a thing
20:23:19 <Philippa> but for how frequently Core changes, anyway
20:23:24 <Ghoul_> the research compiler they made used ghc's smart core generator and intels extremely good backend assembler to produce code which was near C in all tests
20:24:10 <LordBrain> intell's making a haskell compiler?
20:24:18 <Ghoul_> nah, there was a paper on reddit
20:24:39 <Ghoul_> Here: http://www.reddit.com/r/haskell/comments/1j2k4a/measuring_the_haskell_gap_pdf/
20:25:13 <zzing> Is there a stable linear algebra library? I am in need of a point type and probably determinants and distance functions shortly thereafter.
20:25:53 <tabemann> there is linear
20:26:08 <tabemann> but that only really works for *small* vectors and matrices
20:26:33 <tabemann> small being dimensions <= 4
20:26:56 <zzing> What a coincidence
20:27:05 <zzing> I am using 2d right now :-)
20:28:42 <Ghoul_> lol haskells type system seems to be turing complete
20:28:42 <zzing> What does this mean? Warning: Linear.Affine: We do not support associated types in instances yet.
20:28:44 <Ghoul_> https://github.com/seliopou/typo
20:29:44 <jmcarthur> Ghoul_: i am not convinced that Typo is turing complete
20:29:44 <zzing> rather cool
20:29:57 <tabemann> at least the advantage to doing compile-time computation with types rather than with TH is then you know your code will be safe and not brittle
20:30:32 <jmcarthur> Ghoul_: haskell's type system with some set of ghc extensions is probably turing complete. haskell's type system by itself isn't though
20:30:47 <tabemann> unless you turn on undecidable instances, where then your *compiler* can compute bottom!
20:30:49 <pharaun> is there any good way to deal with TH without it being brittle n' stuff?
20:31:56 <dpwright> I'm sure there's a really simple answer to this, but: I quite often do something like the following: "do {a <- firstThing; b <- secondThing; twoArgumentFunc a b}"
20:32:00 <tabemann> jmcarthur: of course; many by "haskell" mean "GHC haskell" and not "haskell 98" or "haskell 2010" these days
20:32:19 <dpwright> I'd like to do something like "firstThing >>= secondThing >>= twoArgumentFunc"
20:32:48 <ion> dpwright: join (liftM2 f g h), that should be called bind2 and exist in Control.Monad. :-P
20:32:56 <enthropy> tabemann: if anything I think TH is more robust. If you look here http://hackage.haskell.org/packages/archive/xmonad-extras/0.10.1/doc/html/XMonad-Config-Alt-Internal.html the TH still works, just the type-level stuff broke sometime after ghc-7
20:33:10 <augur> dpwright: how does that parenthesize?
20:33:50 <dpwright> I suppose if the second thing was the *first* argument to the function, something like "firstThing >>= (secondThing >>= twoArgumentFunc)" would work?
20:34:00 <augur> iol: i dont think that's really quite correct. it should just be liftM2, since f is going to produce just an `m c`
20:34:09 <tabemann> enthropy: neither is safe to future GHC updates, yes; strictly speaking type-level computation is *safer*, as it is inherently non-side effecting and can't modify arbitrary code arbitrary ways
20:34:12 <enthropy> zzing: it probably means the generated haddock html documentation is missing those parts
20:34:16 <augur> dpwright: not quite
20:34:26 <augur> better question tho, dpwright, is whats the type of twoArgumentFunc?
20:34:33 <dpwright> but the way I was imagining it is some syntax that just lets me take the results from a few things and use them as parameters to a function down the line
20:34:34 <zzing> What are associated types?
20:34:51 <enthropy> tabemann: in practice you need to set some large value like -fcontext-stack=81
20:34:54 <enthropy> or maybe higher
20:35:08 <dpwright> ummm
20:35:09 <enthropy> actually this isn't really about what happens in practice :)
20:35:18 <ezrios> dpwright: how will you bind against a function with two arguments?
20:35:22 <roboguy_> dpwright: I would use the applicative style for that
20:35:25 <augur> dpwright: let me give you an example, btw.
20:35:31 <tabemann> the question I have is: now, why do you *really* want to compute something at compile-time, anyways?
20:36:03 <zzing> What would be an example of a package that can allow me to draw a grid, and circles on said grid and output an image file?
20:36:04 <augur> dpwright: suppose i wanted to apply (*) to the elements of two lists, to get the result of doing all the pair-wise multiplications
20:36:10 <enthropy> zzing: an extension being used http://www.haskell.org/haskellwiki/GHC/Type_families
20:36:15 <zzing> Looked at chart, but can only use that for real charts
20:36:24 <enthropy> zzing: diagrams
20:36:24 <dpwright> augur: Yes
20:36:28 <augur> dpwright: i could do that a few ways:   [0,1,2] >>= \x -> [3,4,5] >>= \y -> return (x * y)
20:36:30 <augur> or i could do
20:36:43 <augur> do x <- [0,1,2] ; y <- [3,4,5] ; return (x * y)
20:36:49 <augur> or i could simply do
20:36:56 <augur> liftM2 (*) [0,1,2] [3,4,5]
20:37:07 <augur> > liftM2 (*) [0,1,2] [3,4,5]
20:37:08 <lambdabot>   [0,0,0,3,4,5,6,8,10]
20:37:40 <augur> in fact, because monads are also applicatives, i could also use applicative notation
20:37:53 <augur> (*) <$> [0,1,2] <*> [3,4,5]
20:37:57 <augur> > (*) <$> [0,1,2] <*> [3,4,5]
20:37:58 <lambdabot>   [0,0,0,3,4,5,6,8,10]
20:38:08 <enthropy> tabemann: you're already sold on the value of having a type system right?
20:38:27 <dpwright> ok, roboguy_ mentioned applicatives too -- I've not really used that notation much yet so I'm not all that familiar with it
20:38:35 <tabemann> zzing: http://hackage.haskell.org/package/cairo
20:38:52 <augur> dpwright: the spirit of applicative notation is to represent the idea of a "style" of computation
20:39:04 <augur> dpwright: <*> is applicative application. its type is
20:39:07 <augur> :t (<*>)
20:39:07 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:39:09 <zzing> tabemann, probably too low level
20:39:17 <roboguy_> augur, dpwright: since there wasn't a return in his original example, I assume the function is something like "Monad m => a -> b -> m a" for some a, b and c so I think he might need join as well
20:39:29 <augur> dpwright: if you blur your eyes and hallucinate away the f, it's just the type of ($) for function application
20:39:53 <augur> dpwright: but the f is there to indicate that what we really have is an f-y function, an f-y argument, an f-y return value
20:40:01 <augur> where f is a kind of style of computation
20:40:13 <dpwright> right
20:40:15 <augur> for lists, its a "nondeterministic" function/argument/return value
20:40:26 <tabemann> enthropy: maybe I'm more used to the more traditional uses of type systems, as opposed to treating them as just a way to compute things arbitrarily (as opposed to merely theorem-proving things in terms of types)
20:40:29 <augur> or another way of saying it is an f-y way to compute a function/argument/return value
20:42:22 <augur> dpwright: you can also imagine that you have a way to go from a pure value to a computation quite easily
20:42:37 <augur> obviously if you have a number, you must have a way to computer a number -- you've already got one
20:42:44 <augur> so you have pure :: a -> f a
20:43:11 <augur> dpwright: so imagine say.. applying a pure function to a pure argument. like maybe
20:43:23 <augur> > pure (*) <*> pure 2 <*> pure 3
20:43:24 <lambdabot>   No instance for (Control.Applicative.Applicative f0)
20:43:24 <lambdabot>    arising from a use ...
20:43:32 <augur> derp
20:43:33 <augur> :D
20:43:43 <augur> > pure (*) <*> pure 2 <*> pure 3 :: Maybe Integer
20:43:44 <lambdabot>   Just 6
20:44:16 <augur> the maybe applicative is kind of computations that can fail (it is so because Maybe is also a monad and all monads are applicatives, so...)
20:44:23 <augur> but what we've done "in spirit"
20:44:31 <augur> is applied the (*) function to 2
20:44:40 <augur> but in that special "possibly failing" way
20:44:49 <augur> and then applied that to 3, again in that special, possibly failing way
20:45:00 <dpwright> hmm
20:45:17 <ezrios> > pure (*) <*> pure 2 <*> Nothing
20:45:17 <lambdabot>   Nothing
20:45:28 <augur> often you'll have lots of f-y values already, and you want to apply a single function to them
20:45:32 <augur> so you write this a lot:
20:45:43 <augur> pure f <*> x <*> y <*> z
20:45:43 <augur> etc
20:45:49 <augur> but that just looks ugly, with that pure f there
20:45:56 <augur> so there's a utility function <$>
20:46:05 <augur> f <$> x <*> y <*> z
20:46:25 <augur> f <$> x = pure f <*> x
20:46:30 <augur> so you can do things like
20:46:48 <augur> > (*) <$> pure 2 <*> pure 3 :: Maybe Integer
20:46:49 <lambdabot>   Just 6
20:46:49 <tabemann> (<$>) = fmap
20:46:53 <augur> tabemann: that too :)
20:47:44 <augur> dpwright: this is actually so lovely and convenient that some people want to go further, and let you just write things like (*) (pure 2) (pure 3)
20:47:46 <augur> or even
20:47:48 <augur> pure 2 * pure 3
20:48:00 <dpwright> I have come across the (<$>) = fmap thing in RWH, and used it a tinsy bit when it seemed appropriate
20:48:07 <edwardk> carter: around?
20:48:10 <augur> there's this thing called idiom brackets that let you do that
20:48:15 <dpwright> but still kinda getting my head around it
20:48:38 <augur> dpwright: it helps to play around with these things for some very simple things
20:49:06 <dpwright> so is the difference between that pure/applicative way of doing things, and doing the same thing in the Maybe monad, that you avoid having to type the function name on every line?
20:49:17 <augur> dpwright: for instance, try to write an evaluator for Hutton's razor, and implement some extra things that could lead to, say, errors, or variable bindings, or non-determinism, or state
20:49:33 <augur> dpwright: well no
20:49:39 <edwardk> carter: i need a nice fast sparse boolean matrix multiplier. if only i knew someone who cared about that sort of thing.
20:50:08 <NemesisD> i've got a daatatype like Active { latCheckIn :: POSIXTIME } | Paused | Notifying | Triggered, is there anything that would make deriving Ord for this do something unexpected?
20:50:08 <augur> dpwright: the applicative technique is often used when there's a kind of uniformity of how different things are computed
20:50:27 <edwardk> dpwright: using the more general combinators mean you can use it in other monads/applicatives just as easily.
20:50:37 <edwardk> dpwright: so the knowledge of how to do this transfers
20:51:07 <NemesisD> i'm getting really weird behavior in 2 libraries that use Ord to index on a field with that type and it seems to not ever be able to find Notifying
20:51:23 <edwardk> that way when later you want to concatenate the result of two IO actions (++) <$> getLine <*> getLine   can just spill from your fingertips without thought =P
20:52:02 <augur> edwardk: i still think it'd be nice if we had proper idiom brackets :\
20:52:02 <NemesisD> the ord instance seems pretty hard to screw up
20:52:04 <jmcarthur> every time i read about normalization of HOAS terms i am disappointed by the treatment of lambda bodies. the reductions under the lambda are never shared.
20:52:08 <dpwright> edwardk: aha!
20:52:22 <dpwright> yeah
20:52:23 <geekosaur> NemesisD, depends. ever seen how Map Double a behaves?
20:52:28 <edwardk> i personally don't feel the need for them
20:52:34 <dpwright> because that sounds like basically exactly what I want to do, actually
20:52:43 <augur> edwardk: so that you could basically override haskell's application syntax and really just write   (| getLine ++ getLine |)
20:52:58 <dpwright> but at the start of this conversation it looked a bit scarily syntax-y
20:53:07 <scshunt> ugh, I'm the worst at software design
20:53:08 <scshunt> that is all
20:53:19 <NemesisD> geekosaur: no. is it bad?
20:53:19 <edwardk> now, if someone wanted to generalize do sugar so that it was smarter and automatically upgraded to using the applicative combinators when you did a do block with no intermediate variable usage, and only had occurences of the bound variables on the last line after return, i'd be totally there ;)
20:53:20 <dpwright> augur's explanation, and then your bringing it back into the IO monad, helped me see what's going on there
20:53:45 <augur> dpwright: you should still write versions of hutton's razor
20:53:48 <edwardk> augur: except now i have to keep track of which arguments are being automagically lifted and what things aren't, etc.
20:54:06 <dobblego> omg are we fixing do-notation?
20:54:12 <NemesisD> geekosaur: not sure how POSIXTime is implemented, i think something integer like
20:54:16 <augur> edwardk: well fortunately it's so mechanical that we could mechanize away your remembering :)
20:54:20 <geekosaur> between NaNs and floating point errors, it's pretty unsafe
20:54:33 <augur> dobblego: i'd like to! i think idris has infixes in idiom brackets
20:54:34 <edwardk> dobblego: not likely, but its a long running dream of mine. we _are_ at least getting applicative as a superclass of monad, so lets start there ;)
20:54:37 <jmcarthur> has anybody seen a normalizer for HOAS/PHOAS/some-other-"shallow"-embedding that shares the reductions of lambda bodies?
20:54:54 <edwardk> augur: you can use a quasiquoter or SHE for it today
20:55:14 <augur> edwardk: for infixes tho? i didnt know SHE's idiom brackets supported infixes. hm!
20:55:30 <augur> dpwright: if you dont know what hutton's razor is, lemme know. :p
20:55:32 <edwardk> i don't know about infixes in general
20:55:36 <geekosaur> POSIXTime appears to be NominalDiffTime which is a Data.Fixed from the looks of it
20:55:37 <NemesisD> geekosaur: guess i'll roll my own Ord
20:55:40 <dobblego> did I once see a church-encoded MaybeT on hackage or similar?
20:55:42 <dpwright> augur, edwardk -- thanks a lot for your help and your detailed explanation... I sort of get it but I'm going to mull over it a bit more and maybe play in the repl a bit :-)
20:55:45 <geekosaur> so it *should* work
20:55:54 <edwardk> dpwright: np
20:55:56 <geekosaur> (since it's an Integer with a scale factor)
20:56:00 <dpwright> augur: I don't... but it's lunchtime ;-) I'll look into it when I get back :-D
20:56:02 <applicative> oh yeah, they support (|readFile x, readFile y|) augur
20:56:34 <augur> edwardk: i think probably there should also be something like an unbracketter for pure values.   (| xs * (ys - |( 1 )|) |)
20:56:38 <augur> :D
20:56:43 <augur> |(|)(()(|||(||())(||
20:56:47 <edwardk> applicative: i keep going 'thats a strange catamorphism!'
20:56:51 <augur> dpwright: ill be here!
20:57:07 <augur> applicative: is that a pair?
20:57:09 <NemesisD> geekosaur: i'm going to feel bad if its the ord instance. i stopped using "tables" in favor of "data-store" because this same query was broken, i think
20:57:18 <applicative> augur: yes
20:57:21 <applicative> edwardk: ah
20:57:22 <augur> applicative: crazy
20:57:28 <augur> i dont accept this pair notation :|
20:57:39 <edwardk> NemesisD: did you put an issue in on tables over it?
20:57:53 <Rarrikins> > 0x1122334455667788
20:57:54 <lambdabot>   1234605616436508552
20:57:55 <edwardk> NemesisD: that way in 8 months when i get around to caring about tables again i can fix it and try to woo you back ;)
20:58:02 <augur> dpwright: but do do the razor. its very minimal, and therefore very useful for sharpening intuitions
20:58:02 <geekosaur> I have no idea how the Ord instance for Data.Fixed hbehaves
20:58:21 <applicative> i guess (|xs * (|x - ~1|) |) is the other you mention; not an ideal decision, I think
20:58:32 <daniel-s> Hi
20:58:41 <daniel-s> I have read the first three chapters of this book: http://book.realworldhaskell.org/
20:58:41 <applicative> hi daniel-s
20:58:47 <scshunt> what is this (| |) sense?
20:58:49 <daniel-s> I really don't think I "get" it
20:58:50 <NemesisD> edwardk: i'd hate to see the acid-state migration that would make that work ;)
20:58:56 <scshunt> daniel-s: get what, exactly?
20:58:58 <applicative> scshunt: idiom brackets
20:59:03 <daniel-s> also, I certainly don't get Monads
20:59:12 <NemesisD> edwardk: i tried to produce a minimal case to reproduce it and couldn't
20:59:13 <augur> applicative: i think probably something like quasiquotes in scheme might be better, ultimately.
20:59:15 <applicative> daniel-s: have you tried learn you a haskell?
20:59:24 <daniel-s> scshunt: I understand that you have a function, and the idea that you don't have any external state
20:59:26 <augur> `(xs * (ys - ,1))
20:59:27 <applicative> augur: this isnt scheme
20:59:29 <jmcarthur> applicative: NumInstances for this stuff ;)
20:59:32 <NemesisD> it only reproduces in this clusterF of a project
20:59:37 <augur> applicative: i just mean notationally
20:59:38 <enthropy> http://hackage.haskell.org/packages/archive/applicative-quoters/0.1.0.8/doc/html/Control-Applicative-QQ-Idiom.html
20:59:39 <ezrios> daniel-s: http://www.haskell.org/haskellwiki/Monads_as_containers http://www.haskell.org/haskellwiki/Monads_as_computation
20:59:39 <applicative> oh i see augur
20:59:45 <daniel-s> scshunt: I don't get how I would use Haskell to actually construct any program
20:59:47 <ezrios> after reading those two documents things started to make sense
20:59:53 <augur> applicative: the `, pairing is nice and quite
20:59:55 <NemesisD> i feel like i'm getting gaslighted by my own project "nobody will believe you that this is a bug"
20:59:59 <augur> quiet*
20:59:59 <scshunt> daniel-s: Ah!
21:00:02 <scshunt> daniel-s: Keep reading, then
21:00:07 <applicative> daniel-s: I think it's not prudent trying to grok monads in general
21:00:19 <applicative> all at once before using a few...
21:00:21 <daniel-s> ezrios: I feel a little disappointed, because I saw the Youtube video "don't fear the monad"
21:00:27 <augur> applicative: or maybe unicode :D
21:00:35 <ezrios> with brian beckman?
21:00:43 <geekosaur> monads are simple but they don't have an everyday intuition associated with them
21:00:45 <applicative> ah, yeah I think mc bride is anti unicode
21:00:50 <daniel-s> I understood everything he discussed about monoids, but didn't get the Monad part at the end. I still don't get it
21:00:58 <ezrios> it was actually quite mathy, at least compared to those two wiki articles
21:01:00 <edwardk> daniel-s: to get started you can mostly ignore monads. RWH kind of skips describing them for several chapters
21:01:02 <augur> applicative: i dont think he's anti unicode so much as he's mr fumbly fingers.
21:01:04 <daniel-s> ezrios: Yep
21:01:04 <mapreduce> daniel-s: Haskell's basically split in two, the 'do language' you use to tell it to do stuff, and the normal language you use to compute values.
21:01:22 <edwardk> and just lets you get by by pretending that you have some magic syntax for working with IO actions in the meantime
21:01:27 <ezrios> daniel-s: You may want to also take a look at "the trivial monad"
21:01:28 <mapreduce> daniel-s: So the bit you don't get is likely the do language.
21:01:34 <mapreduce> known as do-notation.
21:01:54 <applicative> i repaired the she machinery augur just for the brackets. I was trying to make it a file you could use locally with cabal but there's some subtlety
21:01:57 <augur> applicative: he's said quite a lot that when you do it live as much as he does, you need to get it right first time, ideally, and its bad enough with ascii nevermind latex-like unicode input
21:02:09 <augur> applicative: ey?
21:02:37 <daniel-s> I'm kind of disappointed, because I have developed a piece of code in Python. I basically made every mistake in Fowler's refactoring book. I think I can really appreciate the need for simple, state-less functions in developing testable code.
21:02:54 <hpaste> applicative pasted “her.sh” at http://lpaste.net/91686
21:02:57 <NemesisD> i think it must be sort of milestone in my haskell education that every time I swee RWH now I read it as RWST
21:02:57 <hpaste> applicative pasted “her.sh” at http://lpaste.net/91687
21:03:33 <hpaste> applicative annotated “her.sh” with “test.hs” at http://lpaste.net/91687#a91688
21:04:02 <ezrios> daniel-s: you may want to familiarize yourself more with thinking in a functional paradigm before looking into monads
21:04:12 <ezrios> if you are finding difficulty in seeing how you can write a program in haskell
21:04:16 <augur> there really ought to be some standard system for haskell parsing gadgetry that doesn't require preprocessing or bypassing the compiler
21:04:37 <scshunt> daniel-s: my suggestion for dealing with monads is to ignore them at first
21:04:46 <applicative> augur: ah i see, my just remembering something from a video agda tutorial / course
21:04:55 <augur> applicative: yes :)
21:04:58 <augur> the OPLSS course
21:05:04 <scshunt> daniel-s: begin by getting familiar with do notation for IO, and just treat it as magic syntax
21:05:18 <jmcarthur> daniel-s: i would like to echo these suggestions to just ignore monads for now. they are overhyped, both positively and negatively.
21:05:52 <edwardk> applicative: what is missing from getting that to work?
21:05:58 <scshunt> daniel-s: once you're familiar with the do notation, look at how it desugars, and maybe look for places that you could shorten your code by using >>= or >> instead of a do block
21:06:02 <edwardk> applicative: that is remarkably self-contained
21:06:02 <applicative> augur so heres mcb's 'wee parser' http://lpaste.net/91688 which will run if the other file is in the same dir
21:06:06 <Philippa> do is just a slightly weird way to write a limited version of let. It's like that because things like IO only support that kind of let, but they get to be something that isn't ordinary haskell
21:06:12 <applicative> edwardk: it works
21:06:20 <scshunt> daniel-s: once you can do that, going to other monads isn't all that hard
21:06:28 <ezrios> Philippa: what?
21:06:29 <jmcarthur> daniel-s: they only thing making them truly special in haskell is the syntax sugar. the only reason they are highlighted so much is because one of the commons ones is magical (and therefore to be ignored as long as possible...).
21:06:38 <augur> applicative: wee parser :)
21:06:40 <ezrios> Philippa: I don't see how that is the case
21:06:43 <applicative> edwardk: well, okay its a little fragile
21:07:08 <applicative> it would be awesome to have (|  ,   ,    |)
21:07:24 <Philippa> ezrios: go desugar some do statements for the Identity monad and compare that to the usual desugaring for single-variable let in the pure lambda calculus
21:07:25 <daniel-s> OK. Thanks everyone.
21:07:29 <augur> applicative: thats why we need a proper parser gadget
21:07:33 <applicative> i'm not really sure how practical it is; i like it for sentimental and ideological reasons...
21:07:40 <bryanvick> daniel-s: I struggled w/ Haskell the first time. Groked scheme, then came back, much easier this time
21:07:41 <applicative> augur: yes
21:08:17 <jmcarthur> applicative: i would be happy enough with a few standard functions of the form   tupleA2 :: Applicative f => (f a, f b) -> f (a, b)
21:08:23 <augur> applicative: we ought to be able to specify things like (| ... |) as circumfix operators, which have a well-defined effect on the translation into "true AST" code
21:08:25 <applicative> edwardk: I couldn't figure out how I could stuff it in a cabal package and run it before building, but there must be a way
21:08:30 <jmcarthur> e.g. liftA2 (,)  and so on
21:08:31 <augur> it would be relatively simple to do
21:08:50 <edwardk> applicative: ah you're running into issues with things like needing attoparsec prebuilt and what not?
21:09:08 <edwardk> oh i guess it doesn't use anything
21:09:20 <augur> you just build up a surface AST like normal, and then run specified expansions
21:09:38 <startling> > (_1 >=> _2) (Just 1, Just 2)
21:09:39 <lambdabot>   Couldn't match type `Data.Maybe.Maybe' with `p0 a0'
21:09:39 <lambdabot>  Expected type: (Data.M...
21:09:47 <startling> oh
21:09:54 <startling> > (_1 id >=> _2 id) (Just 1, Just 2)
21:09:56 <lambdabot>   Just (1,2)
21:10:03 <edwardk> augur: we call them 'quasiquoters'
21:10:07 <applicative> edwardk: I didn't look into it, I was wanting it to run with runhaskell rather than being compiled, thinking it would be 'light weight'; I'm not sure that was a particularly sensible goal
21:10:11 <arkeet> :t _1 id
21:10:12 <lambdabot> (Functor f, Field1 s t (f b) b) => s -> f t
21:10:17 <arkeet> :t both id
21:10:18 <lambdabot> Applicative f => (f b, f b) -> f (b, b)
21:10:22 <augur> edwardk: is that really quasiquoting tho? its more a macro system
21:10:28 <startling> both doesn't compose well though.
21:10:36 <applicative> edwardk: probably its just a question of putting some magic in Setup.hs
21:10:38 <arkeet> I was just looking at the type.
21:10:51 <arkeet> :t traverse id -- oh yeah that's sequence
21:10:52 <lambdabot> (Applicative f, Traversable t) => t (f b) -> f (t b)
21:10:58 <edwardk> [augur| getLine ++ getLine |]
21:11:00 <augur> edwardk: or do you mean that you could do this with quasiquoting and internal evaluation?
21:11:01 <startling> > (_1 id >=> _2 id >=> _3 id) (Just 1, Just 2, Just 3) -- i.e., you can't do this with 'both'.
21:11:02 <lambdabot>   Just (1,2,3)
21:11:06 <edwardk> that
21:11:07 <arkeet> I know.
21:11:10 <buckmaster> Template Haskell newbie seeks experienced coder for companionship and debugging! Enjoys long walks on beach and code that works. Apply here stackoverflow.com/q/18121154 Sorry to bug you all!
21:11:38 <edwardk> > sequenceOf each (Just 1, Just 2, Just 3)
21:11:39 <lambdabot>   Just (1,2,3)
21:11:48 <augur> edwardk: i dont really know how TH works, to be honest
21:12:03 <applicative> oh does it work, this TH?
21:12:09 <arkeet> :t sequenceA >=> sequenceA
21:12:09 <lambdabot>     Not in scope: `sequenceA'
21:12:09 <lambdabot>     Perhaps you meant one of these:
21:12:09 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
21:12:14 <arkeet> :t T.sequenceA >=> T.sequenceA
21:12:15 <lambdabot> (Monad m, Applicative m, Traversable t) => t (m (m a)) -> m (t a)
21:12:27 <edwardk> augur: with TH you basically can specify the parser to use for the body of the splice in an expression, pattern or declaration context.
21:12:29 <startling> :t each
21:12:41 <pharaun> ahh finally
21:12:50 <pharaun> i think my mind is finally starting to bend to the arrows way
21:12:58 <augur> edwardk: fair enough, but i wasnt really thinking of specifying parsers, rather, specifying AST transformations
21:13:01 <NemesisD> whats the policy on swearing in this channel?
21:13:31 <edwardk> NemesisD: if people start getting offended, an op might say something
21:13:51 <augur> edwardk: you'd want to use the normal haskell parser, but just change function applications appropriately. App f x ought to become App (App <*> f) x
21:13:52 <augur> etc
21:13:56 <augur> in whatever the AST is
21:14:23 <edwardk> augur: sure. there is a quasi-quoter that can just borrow the haskell-src-exts parser
21:14:33 <edwardk> and so you can upgrade it to do your AST transformations
21:14:39 <ezrios> NemesisD: that generally seems to be the case across a number of channels as well
21:14:55 <augur> edwardk: does TH just convert to normal haskell source and pass it on to GHC?
21:15:07 <NemesisD> i'd better not then
21:15:18 <edwardk> basically you get to do anything you want in TH with the text and splice in something at that site
21:15:25 <joelteon> what do you guys like to use for parsing command line options?
21:15:25 <augur> ive heard that you can use TH as an actual quote system for runtime code manipulation but that surely must be different
21:15:27 <scshunt> augur: to a Haskell AST, not true source
21:15:35 <Philippa> NemesisD: some of the ops swear. Swearing specifically at people will be viewed more negatively.
21:15:37 <scshunt> augur: you can also do that
21:15:47 <augur> so it does both. ok.
21:15:48 <edwardk> augur: example: http://hackage.haskell.org/packages/archive/haskell-src-meta/0.2/doc/html/Language-Haskell-Meta-QQ-ADo.html
21:16:02 <edwardk> [$ado| a <- "foo"; b <- "bar"; (a,b) |]
21:16:11 <augur> i just dont like the idea of using quasiquotation for syntactic gadgetry, not in a compiled setting anyway
21:16:14 <edwardk> and http://hackage.haskell.org/packages/archive/haskell-src-meta/0.2/doc/html/Language-Haskell-Meta-QQ-Idiom.html
21:16:15 <scshunt> augur: TH is a library that contains a Haskell representation of the Haskell AST and functions to manipulate it
21:16:25 <augur> because you'd have to interpret the result, iinm
21:16:39 <scshunt> and a series of compiler extensions allowing you to go to and from the representation
21:16:45 <scshunt> it's not interpreted
21:16:56 <augur> scshunt: hm
21:17:04 <edwardk> [i| getLine ++ getLine |]
21:17:19 <Philippa> ezrios: did my suggestion make sense of what I said re do notation, btw?
21:17:24 <augur> i wish there were a nice tutorial on the core principles of TH
21:17:25 <edwardk> augur: you only interpret the result at compile time
21:17:33 <edwardk> then it is compiled code
21:17:34 <augur> edwardk: thats what i mean tho
21:17:36 <joelteon> cmdargs seems a little gross
21:17:36 <scshunt> when you do a splice, the compiler compiles its contents, executes them, and splices them into the compilation
21:17:37 <augur> oh oh ok
21:17:42 <edwardk> joelteon: it is
21:17:46 <joelteon> what's good
21:18:03 <ezrios> Philippa: somewhat, I don't think I am getting it though
21:18:04 <Clint> optparse-applicative?
21:18:09 <edwardk> it just interleaves with type checking to generate more code
21:18:19 <edwardk> optparse-applicative isn't terrible
21:18:22 <joelteon> hmm, ok
21:18:36 <edwardk> its a bit hard to get started with, but it does most of what i want
21:18:41 <joelteon> yeah it looks better
21:18:44 <joelteon> and fairly simple
21:18:49 <edwardk> and it has the benefit of being sane
21:19:04 <augur> edwardk: is there a minimalist intro to TH?
21:19:12 <augur> a kind of huttons razor of TH?
21:19:26 <edwardk> augur: i read a bunch of stuff by igloo on it way back when i first found it
21:19:32 <edwardk> and then kept up with the changes as they happened
21:19:39 <scshunt> I just learned by doing
21:19:48 <scshunt> wanted a raw string literals
21:19:48 <augur> i dont want to learn to use TH
21:19:49 <benzrf> hey
21:19:52 <tabemann> if Haskell only had something akin to hygienic macros...
21:19:54 <scshunt> so I wrote a quasiquoter for them
21:19:55 <augur> i want to learn how TH makes sense underlyingly
21:19:57 <edwardk> http://www.haskell.org/haskellwiki/Template_Haskell has a lot of resources
21:20:06 <scshunt> augur: what do you mean by that?
21:20:09 <augur> how it works, why it makes sense, etc.
21:20:10 <benzrf> I wrote this: http://bpaste.net/show/121270 to solve this: http://www.spoj.com/submit/PRIME1/
21:20:22 <benzrf> it says it exceeds the time limit. tips on making it speedier?
21:20:40 <scshunt> it is actually pretty simple in its workings
21:20:46 <scshunt> no voodoo
21:20:46 <augur> scshunt: hutton's razor, for instance, is a nice minimal little language that can be used to introduce all sorts of complicated ideas without getting too bogged down by a million features
21:20:47 <edwardk> augur: http://www.haskell.org/wikiupload/2/24/Template_Haskell-A_Report_From_The_Field.ps may give you a feel for it. it was written back in the stone age though
21:21:05 <ezrios> Philippa: oooh I think I see it now
21:21:16 <ezrios> I am not sure I understand what you mean by "let in the lambda calculus" though
21:21:26 <augur> scshunt: i mean for things like evaluation, or DSLs, or compilation
21:21:26 <edwardk> the other stuff at that url above may be a better intro to 'modern' template haskell though. where they've since fixed a lot of the warts
21:21:35 <augur> so it'd be nice if there were a TH equivalent
21:22:01 <Philippa> ezrios: the usual desugaring - let x = y in z => (\x. z) y
21:22:37 <augur> edwardk: checking out the links
21:22:40 <edwardk> ezrios: "let in the lambda calculus" as in you need to let the lambda calculus into your heart and drive out the evil Turing machines. If you don't do that, you'll never go clear.
21:22:42 <Philippa> (note that this doesn't buy you recursion and if you want to bind multiple variables you have to nest lets)
21:23:19 <benzrf> :\
21:23:34 <Philippa> edwardk: I think I see your latest money-making scheme. Best get it classified as a religion real quick :p
21:23:41 <edwardk> Philippa: =)
21:23:58 <Philippa> "but it says Church right here, yerhonour!"
21:24:00 <edwardk> Philippa: It is important to maintain the separation of Church and state.
21:24:17 <applicative> joelteon: ReadArgs is the must-have package ...
21:24:35 <Philippa> anyway, I should be asleep
21:24:52 <ezrios> hm, so should I
21:25:07 <ezrios> my fault for watching the director of the NSA bullshit the black hat conference ._.
21:25:37 <applicative> joelteon: http://hackage.haskell.org/package/ReadArgs 'Youll never import System.Environment again'
21:25:40 <NemesisD> my minimal reproducible case for this bug is 77 lines long :(
21:25:46 <twoolie> does anyone know how to have parsec parse something to Either a b ?
21:26:28 <benzrf> help o_o
21:26:32 <scshunt> twoolie: The same as any other type
21:26:46 <adnap> edwardk: What is with "zipper :: Traversable t => t a -> Maybe (Zipper t a)" returning a Maybe?
21:27:09 <edwardk> adnap: extract (zipper []) otherwise = ?
21:27:25 <edwardk> you can only get a zipper into something that has at least one 'hole'
21:27:40 <augur> iinm, the Reader applicative and Reader monad are more or less the same thing but with swapped args right?
21:28:07 <dobblego> augur: ?
21:28:15 <augur> (<*>) :: (r -> a -> b) -> (r -> a) -> (r -> b)   vs   (>>=) :: (a -> r -> b) -> (r -> a) -> (r -> b)
21:28:17 <edwardk> sure, if you think about it that makes sense, because the ability to commute under the kleisli arrow is just the swapping of arguments.
21:28:59 <augur> that should be e, really, not r, just for aesthetic reasons. oh well!
21:29:13 <augur> and (<*>) == flip (>>=) i think?
21:29:23 <applicative> twoolie: well,  fmap Left p <|> fmap Right q for example
21:29:44 <twoolie> scshunt: I can't find any parsec combinators that result in ParsecT s u m (Either a b). does it have something to do with alternative (<|>) ?
21:30:09 <twoolie> applicative: thanks
21:30:28 <edwardk> so to go one way its just a matter of using f (a -> b) -> a -> f b -- but (a -> f b) -> f (a -> b) only works when f is representable   e.g. Reader
21:30:59 <edwardk> :t (>>=) . flip
21:31:00 <lambdabot> (a -> b1 -> c) -> ((a -> c) -> b1 -> b) -> b1 -> b
21:31:24 <augur> :P
21:31:33 <edwardk> :t flip
21:31:33 <lambdabot> (a -> b -> c) -> b -> a -> c
21:32:27 <edwardk> anyways if you look around you should spot S in there
21:32:48 <augur> yeah, i think both <*> and >>= for Reader are S
21:33:03 <augur> just with different positions for the parameter position
21:33:22 <augur> for some reason, NL semanticists love to make the param the last damn argument
21:33:39 <twoolie> one last question: is there a Parsec total primitive for read?
21:33:42 <augur> which means you cant use any convenient notational conventions or anything
21:33:59 <edwardk> :t \ x y z -> x z(y z)
21:33:59 <lambdabot> (t2 -> t1 -> t) -> (t2 -> t1) -> t2 -> t
21:34:19 <Saizan> twoolie: you could make one using reads
21:34:26 <augur> i much prefer   f e (x e)    to    f (x e) e
21:34:51 <edwardk> :t (\ x y z -> x z(y z)) `asTypeOf` (<*>)
21:34:52 <lambdabot> Applicative ((->) t) => (t -> a -> b) -> (t -> a) -> t -> b
21:35:05 <augur> huh
21:35:19 <augur> :t (\x y z -> x (y z) x) `asTypeOf (>>=)
21:35:19 <lambdabot> parse error on input `('
21:35:22 <augur> D:
21:35:34 <augur> :t (\x y z -> x (y z) z) `asTypeOf (>>=)
21:35:35 <lambdabot> parse error on input `('
21:35:41 <augur> :(
21:35:44 <ezrios> you are missing a `
21:35:49 <augur> oh so i am
21:35:53 <augur> :t (\x y z -> x (y z) z) `asTypeOf` (>>=)
21:35:53 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> b0
21:35:55 <lambdabot>     Expected type: ((a0 -> b0) -> a0 -> b0)
21:35:55 <lambdabot>                    -> (a0 -> a0 -> b0) -> a0 -> b0
21:35:59 <ezrios> welp
21:36:01 <ezrios> that is beyond me
21:36:03 <pentace> @pl  \ x y z -> x z(y z)
21:36:03 <lambdabot> ap
21:37:59 <augur> i imagine that the monad instance is required for elegant update of the environment tho
21:38:27 <augur> well, for some definition of elegant
21:38:41 <adnap> edwardk: http://hackage.haskell.org/packages/archive/comonad-extras/3.0.1/doc/html/Control-Comonad-Store-Zipper.html doesn't export a data Contructor, so how does one write a function w a -> b for extend? With sigfpe's Zipper, I wrote "g (Zipper a ((x, h):b)) = h x (map fst $ a ++ b)
21:38:44 <edwardk> :t  (\arb ra r -> arb (ra r) r) `asTypeOf` (=<<)
21:38:44 <lambdabot> Monad ((->) t) => (a -> t -> b) -> (t -> a) -> t -> b
21:38:53 <edwardk> you meant (=<<)
21:39:04 <augur> edwardk: oh yes
21:39:43 <edwardk> adnap: it is a ComonadStore instance,
21:39:52 <twoolie> Saizan: thanks for the advice, but I found a way to do it with LiftA
21:39:58 <adnap> edwardk: Does this Zipper allow one to access the unfocused list elements?
21:40:22 <edwardk> pos: where you are, peek: get a value, seeks: move relative, peeks: read a value relative
21:40:35 <edwardk> yep
21:40:37 <augur> better to write   eval (Lam x b `App` y) = do y' <- eval y ; extend x y ; eval b
21:40:47 <augur> or something like that
21:41:39 <edwardk> pos: basically that zipper is where i got the idea for how lens zippers work
21:41:47 <augur> than to write whatever the hell the applicative variant would be
21:41:55 <edwardk> there i track a path down through something like that traversable zipper
21:42:25 <adnap> edwardk: So, I have to build the unfocused elements into a list with seek, pos, and peek?
21:43:27 <edwardk> pos $ fromMaybe $ zipper [1,2,3]  -- will tell you where you are. you can look around relative to that position with peek to read off values. the issue is i never gave you any way to tell how many elements there are
21:43:32 <edwardk> that was kind of dumb of m
21:43:42 <edwardk> oh i do give size
21:44:32 <adnap> This seems way more cumbersome than the Zipper from the blog
21:44:40 <edwardk> so zipper1 [1,2,3] & seeks (+1) lets you move around.
21:44:45 <edwardk> adnap: it is cumbersome
21:44:49 <edwardk> thats why i replaced it
21:45:19 <NemesisD> man hspec needs to get that parallel execution patch
21:45:28 <NemesisD> heavy use of quickcheck really slows down the test suite
21:45:44 <adnap> I have [(a, a -> [a] -> b)] and I want to produce [b] by applying each a's a -> [a] -> b to itself and the other a's (excluding itself)
21:45:51 <edwardk> >>> rezip $ zipper ("hello","world") & downward _1 & fromWithin traverse & focus .~ 'j' & rightmost & focus .~ 'y'
21:45:51 <edwardk> ("jelly","world")
21:45:57 <edwardk> that is how i think of zippers today
21:46:03 <tabemann> why the f should a single *map* function, implemented as a Scheme primitive, have to take up 94 lines of code (compared to how few the Haskell map takes up)... of course then I have to handle *arbitrary number of lists mapped over* and that I'm operating directly on Scheme primitives at a low level, but still... blarg
21:46:06 <adnap> edwardk: I saw that
21:46:12 <adnap> edwardk: It's neat
21:46:38 <edwardk> you can do things like get a list of zippers simultaneously traversing all paths down, etc.
21:46:58 <edwardk> so you can non-deterministically hunt for things, filtering out cases as they cease to be viable
21:47:34 <augur> edwardk: i dont know what you're talking about but it sounds fun
21:47:51 <NemesisD> that sounds sweet, but i've seen easier to read functions in my time
21:48:16 <adnap> edwardk: Can I solve my problem easily with the new Zipper?
21:48:34 <edwardk> >>> rezip $ zipper ("hello","world") & downward _1 & fromWithin traverse & focus .~ 'j' & rightmost & focus .~ 'y' & upward & focus.elements odd %~ toUpper
21:48:34 <edwardk> ("jElLy","world")
21:48:39 <edwardk> what is your goal? again?
21:48:40 <adnap> edwardk: Is there an easy way to grab everything left of the focus and everything right of the focus?
21:48:48 <edwardk> oh you want to see all the other elements
21:48:48 <adnap> edwardk: I have [(a, a -> [a] -> b)] and I want to produce [b] by applying each a's a -> [a] -> b to itself and the other a's (excluding itself)
21:48:59 <roboguy_> tabemann: wait this is for just the normal map function?
21:49:36 <tabemann> roboguy_: yes - except Scheme map takes the form of (map f l0 ...), i.e. it can map over any number of lists
21:50:05 <tabemann> and I wanted to special-case out mapping over a single list, as there were optimizations I could make in that case
21:50:06 <edwardk> you can do it but it is an imperative mess
21:51:02 <tabemann> there were other things that made it more complex, e.g. that I had to handle returns from Scheme into Haskell, which required pushing continuations onto the Scheme return stack at each step....
21:51:04 <roboguy_> tabemann: still, I can't imagine it taking that many lines. how much of it is the optimizations you mentioned?
21:51:07 <edwardk> tooth will tell you what position you're at, you can seek to leftmost, and walk left to right reading focus until 'tug leftward' fails to give back Just a new zipper, thn take the elements except the one at the specified tooth, etc.
21:51:21 <edwardk> like i said, it _can_ be written
21:51:25 <edwardk> not sure it should be written ;)
21:51:38 <edwardk> the way i'd usually do it with the zippers code is a bit trickier.
21:51:44 <adnap> Well, I can solve my problem with a fold too
21:51:59 <hpaste> tabemann pasted “Scheme map as a primitive in Haskell” at http://lpaste.net/91689
21:52:55 <roboguy_> tabemann: why is it a primitive?
21:53:18 <tabemann> roboguy_: as I wanted to optimize map, as it would be quite a bit slower if I implemented it in Scheme
21:53:26 <roboguy_> ah
21:53:39 <tabemann> as it is getting compiled to native code that way, whereas if it were a Scheme func. it would be in Scheme VM instructions
21:53:44 <edwardk> with a conventional list zipper or the lens 3.8 zipper what you want is easy
21:54:39 <adnap> @let f' xs = let (_, xs'', _) = foldr (\h (as, xs', b:bs) -> (b:as, h b (as ++ bs) : xs', bs)) ([], [], map fst xs) (map snd xs) in reverse xs''
21:54:40 <lambdabot>  Defined.
21:54:58 <adnap> > f [(2, const), (3, \x -> sum . map (+ x)), (1, const)]
21:54:59 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr t)
21:54:59 <lambdabot>    arising from the ...
21:55:02 <adnap> > f' [(2, const), (3, \x -> sum . map (+ x)), (1, const)]
21:55:03 <lambdabot>   Ambiguous occurrence f'
21:55:03 <lambdabot>  It could refer to either L.f', defined at L.hs:148...
21:55:14 <mauke> @undefine
21:55:14 <lambdabot> Undefined.
21:55:35 <adnap> @let f xs = let (_, xs'', _) = foldr (\h (as, xs', b:bs) -> (b:as, h b (as ++ bs) : xs', bs)) ([], [], map fst xs) (map snd xs) in reverse xs''
21:55:36 <lambdabot>  Defined.
21:55:41 <mauke> @undefine
21:55:41 <adnap> > f [(2, const), (3, \x -> sum . map (+ x)), (1, const)]
21:55:41 <lambdabot> Undefined.
21:55:42 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr t)
21:55:42 <lambdabot>    arising from the ...
21:55:51 <edwardk> adnap: clearly you should just use loeb
21:56:00 <adnap> edwardk: What is "loeb"?
21:56:10 <ion> I’m not sure he has the loebs for it.
21:56:13 <mauke> clearly you should stop redefining existing functions
21:56:21 <edwardk> @let loeb x = fmap (\a -> a (loeb x)) x
21:56:22 <lambdabot>  Defined.
21:56:24 <edwardk> :t loeb
21:56:25 <lambdabot> Functor f => f (f b -> b) -> f b
21:56:30 <adnap> I'm sorry. I didn't know
21:56:59 <adnap> @let loeb xs = let (_, xs'', _) = foldr (\h (as, xs', b:bs) -> (b:as, h b (as ++ bs) : xs', bs)) ([], [], map fst xs) (map snd xs) in reverse xs''
21:57:00 <lambdabot>  .L.hs:147:32:
21:57:00 <lambdabot>      Couldn't match type `[b0] -> b0' with `(a0, b1)'
21:57:00 <lambdabot>      Exp...
21:57:25 <ion> …
21:57:35 * tabemann has yet to wrap his brain around just *what* loeb actually does, or for that matter, what its type signature means
21:58:05 <mauke> spreadsheet of functions
21:58:08 <edwardk> > loeb [ (!!2), const 3, (!!1) ]
21:58:11 <lambdabot>   [3,3,3]
21:58:21 <adnap> @waka loeb xs = let (_, xs'', _) = foldr (\h (as, xs', b:bs) -> (b:as, h b (as ++ bs) : xs', bs)) ([], [], map fst xs) (map snd xs) in reverse xs''
21:58:22 <lambdabot> http://www.haskell.org/haskellwiki/loeb_xs_=_let_(_,_xs'',__)_=_foldr_(\h_(as,_xs',_b:bs)_->_(b:as,_h_b_(as_++_bs)_:_xs',_bs))_([],_[],_map_fst_xs)_(map_snd_xs)_in_reverse_xs''
21:58:24 <edwardk> that is what i mean by using loeb instead
21:58:26 <adnap> let @waka loeb xs = let (_, xs'', _) = foldr (\h (as, xs', b:bs) -> (b:as, h b (as ++ bs) : xs', bs)) ([], [], map fst xs) (map snd xs) in reverse xs''
21:58:35 <adnap> @let waka xs = let (_, xs'', _) = foldr (\h (as, xs', b:bs) -> (b:as, h b (as ++ bs) : xs', bs)) ([], [], map fst xs) (map snd xs) in reverse xs''
21:58:36 <lambdabot>  Defined.
21:58:38 <ion> adnap: Btw, lambdabot also works in private.
21:58:40 <adnap> :t waka
21:58:40 <lambdabot> [(a, a -> [a] -> a1)] -> [a1]
21:58:44 <edwardk> think of it like a spreadsheet where you can access other cells in the spreadsheed
21:58:56 <adnap> ion: Oh! I didn't know that!
21:59:26 <adnap> NOT
21:59:41 <edwardk> ?
22:00:03 <adnap> Everyone always tells me "lambdabot works in private" instead of just "shut up"
22:00:23 <edwardk> adnap: they try to be nice. if you want me to tell you to shut up… ;)
22:01:18 <adnap> edwardk: When I use lambdabot in the channel, it's because I want people to see what I'm doing
22:01:36 <adnap> edwardk: And there are no clear rules about using it that I know of
22:02:37 <mauke> when someone spams a channel, it's also because they want people to see what they're doing
22:02:49 <edwardk> adnap: around the time those comments start flying is around when it starts annoying some folks. spam is spam
22:03:11 <edwardk> thats usually a good sign to move it to #haskell-overflow or what not
22:03:20 <adnap> Sometimes I just mess up. I thought of something: I could use lambdabot in private until I have it right, and then use it in public
22:03:36 <edwardk> adnap: thats what i usually do actually
22:03:59 <edwardk> i still make an ass out of myself typospamming lambdabot from time to time though ;)
22:04:04 <adnap> > waka [(2, const), (3, \x -> sum . map (+ x)), (1, const)]
22:04:07 <lambdabot>   [2,9,1]
22:04:36 <augur> adnap: there is no point to other people seeing what you're doing unless they might have some sense of its goals, where you're stuck, etc.
22:04:53 <augur> lambdabot ought to be used to demonstrate ideas
22:05:05 <adnap> augur: I have been describing what my goal is for a while
22:05:22 <adnap> I have reached it, but I don't know if my path is the best
22:05:27 <augur> adnap: the goal of the use of lambdabot, not your overall goal
22:05:47 <adnap> augur: ?
22:07:08 <edwardk> @let iloeb x = imap (\i a -> a i (iloeb x) ) x in iloeb
22:07:08 <lambdabot>  Parse failed: Parse error: in
22:07:21 <edwardk> @let iloeb x = imap (\i a -> a i (iloeb x) ) x
22:07:21 <lambdabot>  Defined.
22:07:24 <edwardk> :t iloeb
22:07:25 <lambdabot> FunctorWithIndex i f => f (i -> f b -> b) -> f b
22:07:48 <edwardk> there, now it is a spreadsheet that can tell you the index of the current cell
22:08:19 <johnw> edwardk: is loeb for reader just flip fix?
22:08:24 <johnw> loeb (\x f -> if x > 0 then f (x - 1) else x) 10 ==> 0
22:08:38 <johnw> compare:
22:08:44 <edwardk> > iloeb [const, const]
22:08:47 <lambdabot>   [0,1]
22:08:49 <edwardk> :t flip fix
22:08:49 <lambdabot> b -> ((b -> c) -> b -> c) -> c
22:08:51 <johnw> fix (\f x -> if x > 0 then f (x - 1) else x) 10 ==> 0
22:08:55 <edwardk> :t loeb
22:08:56 <lambdabot> Functor f => f (f b -> b) -> f b
22:09:00 <johnw> ah, it is!
22:09:02 <jnhnum1_> the 2.0 version of lens had an "at" indexed lens which allowed easily updating the values in maps.  Is there any way of doing something like that now?
22:09:08 <johnw> oh, no
22:09:11 <johnw> not quite
22:09:12 <edwardk> not quite
22:09:15 <johnw> loeb is (a -> ((a -> b) -> b)) -> a -> b
22:09:31 <johnw> i guess not flip fix then
22:09:31 <edwardk> M.fromList [(1,2)] & at 3 .~ Just 4
22:09:36 <edwardk> > M.fromList [(1,2)] & at 3 .~ Just 4
22:09:36 <johnw> but the arguments to the lambda are flipped
22:09:37 <lambdabot>   fromList [(1,2),(3,4)]
22:09:41 <shachaf> jnhnum1_: "at" is still around.
22:09:42 <startling> jnhnum1_, "At" still exists
22:09:43 <edwardk> jnhnum1_: its still there
22:09:52 <edwardk> at is just overloaded to work with all sorts of containers, not just Map now.
22:09:58 <jnhnum1_> oh ok
22:10:00 <edwardk> Control.Lens.At has a ton of instances
22:10:05 <edwardk> and its re-exported by Control.Lens
22:10:13 <startling> > view (at 12) $ M.fromList [(12, "jnhnum!")]
22:10:14 <lambdabot>   Just "jnhnum!"
22:10:38 <jnhnum1_> yeah I guess when I googled data map lens, I ... found the module named "Data.Map.Lens" which no longer exists
22:10:42 <shachaf> jnhnum1_: (Hey, I met you on a train once! Thanks to edwardk.)
22:10:42 <jnhnum1_> so I assumed the contents also didn't exist any more
22:10:49 <jnhnum1_> yup!
22:11:09 <adnap> Are you guys old?
22:11:12 <edwardk> yeah by 3.8 or so Data.Map.Lens had all of its combinators generalized to where there wasn't anything to keep in the module any more!
22:11:31 <edwardk> adnap: getting older by the day
22:11:46 <shachaf> Eventually Control.Lens will only export a single class with a single method.
22:11:47 <ion> edwardk: Oh, you too?
22:11:51 <adnap> I'm 24
22:16:21 <jnhnum1_> yeah, I have to admit that the Control.Lens library is rather intimidatingly generic
22:16:49 <edwardk> jnhnum1_: unapologetically so. one of the design goals was to ensure that everything that could work with anything else, did.
22:17:17 <edwardk> so if you reach for a tool, and try to use it in a situation and there is an extension of the semantics that should give that unambiguous meaning, it should work
22:17:39 <edwardk> > view both ("hello","world")
22:17:41 <lambdabot>   "helloworld"
22:17:54 <startling> :t both
22:17:55 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
22:17:56 <edwardk> as to smash them together with the monoid, because how else can it give back one target
22:17:58 <shachaf> Sometimes things that can't work with other things still do.
22:18:03 <edwardk> shachaf: =)
22:18:05 <startling> edwardk, ???
22:18:15 <edwardk> :t view
22:18:15 <lambdabot> MonadReader s m => Getting a s a -> m a
22:18:23 <shachaf> startling: view = foldOf
22:18:25 <edwardk> :t view both
22:18:26 <lambdabot> (Monoid a, MonadReader (a, a) m) => m a
22:18:31 <startling> oh, I see.
22:18:42 <startling> neat
22:18:43 * shachaf thinks the MonadReader thing is very bad pedagogically.
22:18:52 <startling> it's nice though
22:18:56 <shachaf> (But I don't really have a better suggestion. The whole preuse thing is probably worse.)
22:19:03 <edwardk> it is too convenient to give up =P
22:19:19 <edwardk> i rather routinely use it down in the bowels of transformer stacks
22:20:07 <johnw> > ("Hello", "World") & both .~ "Hmm"
22:20:08 <lambdabot>   ("Hmm","Hmm")
22:20:31 <edwardk> > (1,2) & both .~ "magic"
22:20:32 <lambdabot>   ("magic","magic")
22:20:34 <johnw> I'm sure what I really expected to happen there, given the "view" behavior
22:20:41 <jnhnum1_> blah I have no idea how to use hoogle to find the lens functions I would want
22:20:41 <johnw> not sure
22:20:51 <shachaf> jnhnum1_: Hoogle isn't so great at it.
22:21:09 <shachaf> For one, it doesn't index lens at all (haskell.org/hoogle doesn't, anyway).
22:21:16 <edwardk> jnhnum1_: my best advice is to read the tutorials on lens.github.io, watch the videos out there, and learn the way around the haddocks.
22:21:29 <edwardk> the haddocks for lens show alternate ways to think about a lot of stuff
22:21:41 <johnw> fpcomplete.com/hoogle indexes it
22:21:44 <shachaf> I wrote a short heuristic for where to find the lens function you want once, but maybe that can be expanded into something helpful...
22:21:51 <edwardk> most importantly, if you know how to do it with a Traversable, or a Foldable, you can generally just add 'Of' and take a traversal or a fold
22:21:56 <johnw> for example: https://www.fpcomplete.com/hoogle?q=%28.~%29
22:21:56 <edwardk> > sum [1,2]
22:21:57 <lambdabot>   3
22:22:01 <shachaf> johnw: Yes, but the other Hoogle issue is that the types are too weird for Hoogle.
22:22:03 <edwardk> > sumOf both (1,2)
22:22:04 <lambdabot>   3
22:22:06 <shachaf> (For type->name search.)
22:22:11 <johnw> shachaf: yes, that's very true
22:22:19 <edwardk> so a lot of the combinators are named by analogy
22:22:23 <johnw> I really wouldn't know what types to enter in anyway
22:22:45 <edwardk> then we try to make the rest generic enough that once you know their names and how to use them you can use them everywhere
22:22:48 <shachaf> edwardk: Hmm, remember when sumOf worked like view?
22:22:52 <shachaf> I guess it doesn't do that anymore.
22:22:54 <edwardk> still does
22:22:58 <edwardk> oh wait
22:23:01 <edwardk> it doesn't
22:23:06 <shachaf> It's a fold now.
22:23:08 <edwardk> because we foldl' 'd it
22:23:29 <edwardk> silly efficiency concerns
22:23:30 <startling> :t sumOf
22:23:31 <lambdabot> Num a => Getting (Endo (Endo a)) s a -> s -> a
22:23:43 <edwardk> :t  ala Sum . foldMapOf
22:23:44 <lambdabot> Accessing (->) (Sum a) e a -> e -> a
22:23:52 <startling> > sumOf _1 (1, "x")
22:23:53 <lambdabot>   1
22:23:59 <edwardk> > ala Sum (foldMapOf both) (1,2)
22:24:00 <lambdabot>   3
22:24:02 <startling> or do you mean something else?
22:24:13 <edwardk> > ala Sum (foldMapOf _1) ("hello","world")
22:24:14 <lambdabot>   "hello"
22:24:18 <shachaf> > sumOf _1 (x, True)
22:24:19 <lambdabot>   0 + x
22:24:21 <edwardk> that is what he meant
22:24:29 <shachaf> Yes, that.
22:25:16 <isomorphismes> in LYAH does xs mean "plural of x" ?
22:25:35 <johnw> isomorphismes: pretty much
22:25:36 <jnhnum1_> so are there some lens functions that do stuff with lenses to a Maybe?
22:25:42 <isomorphismes> johnw: thanks
22:25:42 <edwardk> foldMapOf l f = getConst . l (Const . f)    so if you look at it, we're just putting on and taking off a newtype wrapper
22:25:54 <edwardk> jnhnum1_: ?~
22:25:59 <edwardk> that can be used to set its target
22:26:13 <edwardk> also 'non' can be composed in to make it convenient to give it a default value when it is missing
22:26:15 <isomorphismes> He uses boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x] but
22:26:23 <jnhnum1_> oh ok
22:26:26 <edwardk> > M.fromList [(1,2)] & at 3 . non 0 +~ 2
22:26:26 <isomorphismes> > odd [50..100]
22:26:27 <lambdabot>   fromList [(1,2),(3,2)]
22:26:27 <lambdabot>   No instance for (GHC.Num.Num t0) arising from the literal `50'
22:26:27 <lambdabot>  The type va...
22:26:28 <jnhnum1_> what about like
22:26:39 <edwardk> > M.fromList [(1,2)] & at 1 . non 0 -~ 2
22:26:41 <lambdabot>   fromList []
22:26:43 <jnhnum1_> composing with a lens in such a way that if the target is a Nothing, then the result lens does nothing
22:26:45 <jnhnum1_> I guess that is probably
22:26:46 <jnhnum1_> not possible
22:26:49 <jnhnum1_> makes no sense
22:26:53 <edwardk> jnhnum1_: you can do it
22:26:58 <edwardk> you get a 'traversal' though.
22:27:02 <edwardk> at n . traverse
22:27:15 <edwardk> we have a name for that though   'ix'
22:27:24 <startling> (and all you can do with it is set or preview)
22:27:29 <edwardk> which is more general and works on some containers that can't be made an instance of "At"
22:27:40 <edwardk> > [1..10] & ix 20 .~ 30
22:27:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
22:27:44 <edwardk> > [1..10] & ix 2 .~ 30
22:27:46 <lambdabot>   [1,2,30,4,5,6,7,8,9,10]
22:27:51 <startling> > preview (ix "jnhnum") $ M.fromList [("jnhnum", 1)]
22:27:52 <lambdabot>   Just 1
22:28:19 <edwardk> jnhnum1_: a 'traversal' is a lens that can have zero or more targets, not just 1.
22:28:45 <jnhnum1_> oh ok
22:29:27 <edwardk> > M.fromList [(1,M.fromList [("jnh","num1")])] ^. at 1 . non mempty . at "jnh"
22:29:29 <lambdabot>   Just "num1"
22:29:37 <edwardk> > M.fromList [(1,M.fromList [("jnh","num1")])] ^. at 2 . non mempty . at "jnh"
22:29:38 <lambdabot>   Nothing
22:30:04 <edwardk> > M.fromList [(1,M.fromList [("jnh","num1")])] & at 2 . non mempty . at "jnh" .~ "num2"
22:30:05 <lambdabot>   Couldn't match type `Data.Maybe.Maybe
22:30:05 <lambdabot>                         (Control.Lens...
22:30:10 <edwardk> > M.fromList [(1,M.fromList [("jnh","num1")])] & at 2 . non mempty . at "jnh" ?~ "num2"
22:30:11 <lambdabot>   fromList [(1,fromList [("jnh","num1")]),(2,fromList [("jnh","num2")])]
22:30:30 <jnhnum1_> ok thanks that illustrates the usage pretty well
22:30:34 <adnap> I like this: http://adit.io/posts/2013-07-22-lenses-in-pictures.html
22:30:49 <edwardk> non is useful for chains of maps.   ?~ is useful to set a member irrespective of if it was there before.
22:31:48 <edwardk> that was really a rather excellent post
22:36:49 <NemesisD> anyone remember the package that provided a fast set and hashmap with the tradeoff that there were no update operations? only fromList
22:38:07 <NemesisD> quickset
22:48:54 <jnhnum1_> so I have another possible usecase for lenses that I don't know how to do
22:49:04 <edwardk> shoot
22:49:34 <jnhnum1_> you have a lens to some algebraic data type, and you want a lens to a parameter of one of the constructors
22:49:55 <jnhnum1_> so it's kind of like
22:49:59 <jnhnum1_> generalized Maybe :P
22:50:21 <edwardk> > Left 12 ^? _Left
22:50:22 <lambdabot>   Just 12
22:50:24 <edwardk> > Right 12 ^? _Left
22:50:26 <lambdabot>   Nothing
22:50:32 <edwardk> > _Left # 4
22:50:34 <lambdabot>   Left 4
22:50:39 <edwardk> _Left is a prism
22:51:04 <jnhnum1_> oh ok
22:51:05 <edwardk> it is a traversal you can 'run backwards' because it and the target will completely describe the whole structure if it matches
22:51:14 <jnhnum1_> heh I guess this is like automatically generated then when I uses makeLenses on my data types?
22:51:15 <edwardk> > _Left . _Right # 4
22:51:16 <lambdabot>   Left (Right 4)
22:51:24 <edwardk> there is a separate makePrisms
22:51:28 <jnhnum1_> oh
22:51:31 <Ghoul_> I always crack when i see the inception meme usage in the lenses in pic tuts
22:51:40 * haasn .oO( makeEverything )
22:52:12 <jnhnum1_> I still need to read more before I grok traversals sufficiently for "running them backwards" to make any sense to me :/
22:52:30 <jnhnum1_> but I will do that!
22:52:33 <haasn> “location.x `over` (+10) $ player1” <- *yuck*
22:52:39 <haasn> player1 & location.x +~ 10
22:52:47 <edwardk> jnhnum1_: a traversal lets you visit part of a structure. a prism is a traversal such that the traversal itself describes 'all the rest of the structure'
22:53:06 <edwardk> haasn: thats the one downside of that otherwise excellent intro
22:53:17 <zRecursive> lens is so complicated
22:53:22 <edwardk> > _Just # 12
22:53:23 <haasn> jnhnum1_: if you think of a traversal like matching against a constructor, then you can think of a prism like using that constructor to construct the data type in the first place
22:53:23 <lambdabot>   Just 12
22:53:39 <edwardk> (#) is able to use the prism like a smart constructor
22:53:43 <shachaf> jnhnum1_: By the way, there's a channel for lens, if you want a longer discussion on something.
22:53:53 <jnhnum1_> shachaf: oh there is?
22:53:58 <jnhnum1_> that sounds like the best channel ;)
22:54:01 <ElectroStatik> Hello all
22:54:03 <edwardk> #haskell-lens usually has about 90 people in it
22:54:35 <ElectroStatik> So here's a not tech question for all you folks who like linguistics
22:54:42 <zRecursive> no lens, life is still living :)
22:55:01 <ElectroStatik> What is an english idiom for a rumor that gets around
22:55:10 <ElectroStatik> translating from latin
22:55:14 <ElectroStatik> Rumor volat
22:55:26 <shachaf> ElectroStatik: I don't think this is a good channel for that.
22:55:42 <zRecursive> @wn rumor
22:55:44 <lambdabot> *** "rumor" wn "WordNet (r) 3.0 (2006)"
22:55:44 <lambdabot> rumor
22:55:44 <lambdabot>     n 1: gossip (usually a mixture of truth and untruth) passed
22:55:44 <lambdabot>          around by word of mouth [syn: {rumor}, {rumour}, {hearsay}]
22:55:45 <lambdabot>     v 1: tell or spread rumors; "It was rumored that the next
22:55:47 <lambdabot>          president would be a woman" [syn: {rumor}, {rumour},
22:55:49 <lambdabot>          {bruit}]
22:56:17 <ElectroStatik> that's a def. lamdabot
22:56:54 <zRecursive> i choose "gossip" though
22:57:16 <Rarrikins> In a fold lambda, what is the other argument besides the accumulator called?
22:57:29 <ElectroStatik> it has to be an idiom though. No one is writing programs to look at semantics in language?
22:57:46 <NemesisD> anyone ever used fast-logger
22:57:47 <edwardk> ElectroStatik: can you move this to #haskell-blah ?
22:57:48 <ElectroStatik> Comn machine learning folk
22:57:51 <shachaf> ElectroStatik: This channel is for talking about Haskell.
22:58:08 <augur> ElectroStatik: there's a whole book on computational semantics using haskell :)
22:58:21 <johnw> NemesisD: I do
22:58:24 <ElectroStatik> Ok fine, no one wants to humor me
22:58:29 <ElectroStatik> gday then
22:58:32 <johnw> NemesisD: except that I use it by way of monad-logger
22:59:11 <NemesisD> johnw: is it supposed to do datetime logging by default?
22:59:20 <NemesisD> mkLogger's docs say Creates a Logger from the given handle. (ondemandDateCacher zonedDateCacheConf) is used as a Date getter.
22:59:43 <NemesisD> but i don't see any timestamps in my logs
22:59:47 <johnw> NemesisD: when you call runLoggingT, you pass your own logging function; it can produce whatever information you want
23:00:04 <johnw> I don't remember if runStdoutLoggingT uses timestamps or not; I think it does
23:00:40 <NemesisD> hmm. yeah i'm not using monad-logger at this point, just holding onto a logger from fast-logger
23:01:15 <NemesisD> but iit seems like it would add timestamps since the logger is aware of clock caching
23:05:38 <NemesisD> oh nope. i don't know how i missed it. it exports loggerDate :: Logger -> IO ZonedDate. you have to format it yourself
23:14:08 <Ghoul_> :t build
23:14:08 <lambdabot>     Not in scope: `build'
23:14:08 <lambdabot>     Perhaps you meant `buildG' (imported from Data.Graph)
23:14:29 <Ghoul_> http://www.haskell.org/haskellwiki/Correctness_of_short_cut_fusion#foldr.2Fbuild
23:14:32 <Ghoul_> What's build?
23:19:20 <edwardk> Ghoul_: probably build from foldr/build fusion
23:20:00 <edwardk> foldr :: (a -> b -> b) -> b -> [a] -> b
23:20:13 <edwardk> build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
23:20:31 <edwardk> foldr c n (build g) = g c n
23:21:14 <maxiepoo> :t (*>)
23:21:15 <lambdabot> Applicative f => f a -> f b -> f b
23:21:29 <maxiepoo> :t (>>)
23:21:30 <lambdabot> Monad m => m a -> m b -> m b
23:22:07 <Ghoul_> edwardk: is it a real function?
23:22:24 <edwardk> Ghoul_: yes
23:23:13 <edwardk> :t GHC.Base.build
23:23:14 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
23:25:09 <Ghoul_> Oh I see
23:33:15 <krakrjak> edwardk: what's a good approach to solving the overlapping record names when using record syntax?
23:33:35 <edwardk> well when the new records proposal goes in, that gets solved once and for all
23:34:22 <krakrjak> That's awesome!
23:34:32 <edwardk> i personally don't try to solve it directly, but rather just let the field names be different, and make a class for HasId t where _id :: Lens' t Int -- or something
23:34:33 <krakrjak> Until then...  what's a nice approach?
23:34:34 <sopvop> which new proposal?
23:34:43 <edwardk> and then instantiate it for each of the types i need to
23:35:14 <edwardk> makeClassy largely removes the pressure on me there
23:35:16 <krakrjak> aaahhh ok, that's not bad.  I was going to punt with class name prefixes...  still don't like it.
23:35:24 <edwardk> sopvop: gundry's GSOC proposal
23:35:58 <edwardk> krakrjak: makeFields takes field names mangled with the class nae, and looks for a class with the unmangled name, if it finds it it instantiates it for your data type
23:36:59 <krakrjak> edwardk: I'm not sure I follow...
23:37:00 <supki> oh, so that's what makeFields does
23:37:00 <edwardk> its a bit of a trade-off. i tend to prefer the Classy style, because i can reason about the laws for all the fields of a type at once, whereas some others prefer the Fields style
23:38:22 <edwardk> krakrjak: data Foo a = Foo { _fooBar :: Bar, _fooBaz :: Baz a } ; makeFields ''Foo -- will make instances HasBar (Foo a) where bar = ..   instance HasBaz (Foo a) a where baz = ..
23:38:33 <edwardk> (and the classes HasBar and HasBaz if needed)
23:39:01 <edwardk> otoh, makeClassy won't make the instances for you.
23:39:34 <krakrjak> That's pretty darn sweet.
23:39:44 <krakrjak> edwardk: is that in Crontrol.Lens?
23:39:46 <edwardk> it'd make class HasFoo t a | t -> a where foo :: Lens' t (Foo a); fooBar :: Lens' t Bar, fooBaz :: Lens' t (Baz a)
23:40:00 <edwardk> and it'd instantiate it for instance HasFoo (Foo a) a
23:40:20 <edwardk> giving you all the functionality for Foo grouped together
23:41:32 <edwardk> this is convenient because if you had data Quux = Quux { _quuxFoo :: Foo Int, … }   then you can makeClassy or makeLenses on Quux   and then instantiate the 'subtyping' relationship yourself:
23:41:55 <edwardk> instance HasFoo Quux Int where foo = quuxFoo
23:42:11 <edwardk> and now you can automagically use fooBar and fooBaz as lenses into your Quux
23:42:28 <edwardk> because they all get lifted through the 'foo' lens
23:42:42 <edwardk> and yeah all of this is exported by Control.Lens
23:42:48 <edwardk> it is in Control.Lens.TH
23:43:31 <supki> I think this explanation should be exported by C.L.TH too
23:43:49 * sopvop finally found new records proposal
23:43:54 <sopvop> Looks reasonable
23:43:57 <krakrjak> I think so as well!  Thanks for the help edward, I'll let you know how it goes.
23:43:59 <scshunt> link?
23:44:04 <sopvop> http://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Plan
23:45:38 <krakrjak> so when using this technique alongside Aeson do I have to do anything special to get the right instances so FromJSON and ToJSON operate on the correct field names?
23:47:15 <krakrjak> nm....  bad question.  I figured it out while squinting really hard.
23:47:53 <edwardk> sopvop: we need to clean it up a bit, its getting dated.
23:48:19 <edwardk> the latest version would let data.accessor/data-lens/fclabels etc all work directly off the field accessor name
23:48:20 <sopvop> but general Idea about "has field" constraints stays?
23:48:41 <scshunt> edwardk: suggest adding library support to declaring a record accessor directly
23:48:42 <edwardk> and would let lens-style lenses be obtained with just a simple combinator that takes the field name as the argument
23:48:58 <edwardk> "le foo"    would say give you a lens style lens for any field accessor foo
23:49:13 <edwardk> with no template haskell required
23:49:53 <sopvop> will that also help me with records encoding to database/json/whatnot?
23:49:59 <edwardk> yes
23:50:13 <scshunt> edwardk: I haven't looked through all the gritty bits, but am I correct in saying that with that minor foible, the result is that record syntax becomes just sugar?
23:50:17 <edwardk> because you can share field names, but you can also reduce the TH based overhead of setting up lenses
23:51:00 <edwardk> scshunt: not quite, this version wouldn't fully eliminate the benefits of record sugar, but if we ever did the 'over exposed' trick from the lens issues it would be
23:51:14 <edwardk> also there are some issues w.r.t. fields that have a higher rank type
23:52:12 <scshunt> edwardk: of course the point isn't to eliminate the benefits. I'm asking if it does allow you to declare something export-equivalent to some record declaration without needing it to be a record
23:52:16 <scshunt> what's over exposed?
23:52:19 <sopvop> edwardk: are GSOC status updates somewhere on secret mailing list?
23:52:32 <edwardk> scshunt: ah, well, 'sort of'
23:53:07 <edwardk> sopvop: mostly just direct emails
23:53:20 <adrian2> ..
23:53:26 <sopvop> Oh well, will wait for results then :)
23:53:32 <edwardk> scshunt: https://github.com/ekmett/lens/issues/197
23:54:07 <sopvop> edwardk -- first makes great library, then changes language to make library better.
23:54:34 <zvrba> hm
23:54:43 <zvrba> i see that xmonad's config file is haskell.
23:55:00 <zvrba> but how do changes take effect without recompiling the whole of xmonad?
23:55:19 <zvrba> i.e., how does it interpret the configuration?
23:55:26 <adrian2> the new FP IDE from is rolled out next month... any toughs about the cloud/paying subscription?
23:55:35 <scshunt> edwardk: remind me what the ~ in the class declaration is?
23:55:41 <edwardk> @hackage dyre
23:55:41 <lambdabot> http://hackage.haskell.org/package/dyre
23:55:57 <edwardk> zvrba: dyre above is a sort of generic tool for doing things like the xmonad config
23:55:58 <krakrjak> zvrba: it actually does build it all again.  My roomie declares the configuration is the code....
23:56:25 <edwardk> the docs for that describe the shape of how it is done
23:56:33 <zvrba> ok, thanks for the link :)
23:56:35 <zvrba> will read it :)
23:57:10 <zvrba> what is the state of 64-bit ghc for windows?
23:59:30 <shachaf> I think Andreas isn't wrong about Control.Arrow but that that's more because Arrow is a bad abstraction than because abstraction is bad.
23:59:56 <shachaf> I.e. "level of abstraction" implies some kind of total ordering or something. The problem isn't with the "level", it's with Arrow.
