00:01:32 <wunki> levi: ok, I will try that, thanks :)
00:01:36 <orzo> Cale: so it's got a lot of   variable <- get stuff, and i wish it would just dump that to the screen as bytes are read
00:01:48 <Cale> wunki: System.Directory.doesFileExist :: FilePath -> IO Bool
00:02:07 <orzo> Cale: i know it is reading the bytes, because it reads it sequentially, but i guess that doesnt mean values are actually used
00:02:41 <Saizan> wunki, levi: he can't because it's monadic
00:03:01 <orzo> Cale: there's an error that i cannot locate: demandInput: not enough bytes
00:03:13 <Cale> orzo: Well, there are typically data dependencies in do-blocks which make the evaluation *almost* happen in the same order
00:03:50 <orzo> the problem is his syntax spec in the do block must have an error in it and its really hard to debug this
00:04:46 <orzo> if it weren't pure, i'd just output messages as i go and narrow down where it's failing
00:06:36 <Cale> Well, if you put a line in the do block like  trace "foo" (return ())  it ought to print in sequence with the rest of the computation being done.
00:08:59 <adnap> Can you pattern match a float value of "Infinity"?
00:09:53 <adnap> *Float
00:10:07 <Cale> no, but you can guard with isInfinite
00:10:20 <orzo> Cale: that's actually helping, thanks.  Seems like a no brainer but it didnt occur to me
00:10:27 <Cale> I suppose you'd need to use  x | isInfinite x && x > 0
00:10:31 <adnap> I think Infinity and Nan should have literal representations
00:10:35 <adnap> *NaN
00:10:48 <Cale> Or you could just use  x | x == 1/0
00:10:55 <mauke> >=
00:11:42 <arkeet> you could unsafeCoerce to a Word32.
00:11:43 <arkeet> :>
00:12:10 <mauke> > toRational (1/0)
00:12:11 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
00:12:22 <startling> what
00:12:33 <mauke> > fromRational (toRational (1/0))
00:12:34 <lambdabot>   Infinity
00:12:44 <mauke> excellent
00:12:49 * adnap laughs
00:12:50 <mauke> that means there is a literal form of infinity
00:13:08 <startling> lovely.
00:13:08 <adnap> > read "Infinity"
00:13:09 <lambdabot>   *Exception: Prelude.read: no parse
00:13:13 <adnap> > read "Infinity" :: Float
00:13:14 <lambdabot>   Infinity
00:14:21 <adnap> You can't pattern match (1/0)
00:15:07 <adnap> But you can pattern match any other Float besides Infinity, -Infinity, and NaN
00:15:24 <shachaf> Exact floating point equality is rarely what you want anyway.
00:18:50 <startling> I have a lot of tests and I want them in multiple files. How should I organize them? test/Test/Whatever.hs in the project root feels hacky
00:18:59 <adnap> > let inf :: Float; inf = read "Infinity"; f :: Float -> Float; f x | x == inf = 42 | otherwise = x in f (read "Infinity")
00:19:00 <lambdabot>   42.0
00:20:50 <mauke> > case 1/0 of 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216 -> "yay"
00:20:51 <lambdabot>   "yay"
00:20:58 <startling> :D
00:21:02 <Yaniel> wat
00:21:51 <arkeet> length . takeWhile (>0) . iterate (`div` 2) $ 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216
00:21:57 <arkeet> > length . takeWhile (>0) . iterate (`div` 2) $ 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216
00:21:59 <lambdabot>   1025
00:22:02 <arkeet> > 2^1024
00:22:03 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
00:22:28 <adnap> mauke: Oh, I see. I could pattern match on that long-ass number
00:22:35 <mauke> exactly
00:22:37 <arkeet> > fromRational (-1/0)
00:22:39 <lambdabot>   *Exception: Ratio has zero denominator
00:22:41 <arkeet> er
00:22:43 <startling> haha
00:22:49 <arkeet> > toRational (-1/0)
00:22:50 <lambdabot>   (-1797693134862315907729305190789024733617976978942306572734300811577326758...
00:22:53 <startling> > fromRational (1/0)
00:22:54 <lambdabot>   *Exception: Ratio has zero denominator
00:23:08 <startling> oh, so fromRational cares but nothing else does. cool.
00:23:09 <arkeet> > reverse.show $ toRational (-1/0)
00:23:10 <lambdabot>   "1 % )612731422426923653538403617974839542749932892685486015053361732728045...
00:23:16 <adnap> > fromRational . toRational $ (-1/0)
00:23:17 <lambdabot>   -Infinity
00:23:25 <mauke> startling: no, Rational's / cares
00:23:29 <startling> oh
00:23:30 <mauke> I hope
00:23:37 <startling> but Float's doesn'
00:23:38 <startling> t
00:23:57 <arkeet> Float is IEEE754. mostly.
00:24:07 <adnap> Mostly?
00:24:20 <startling> IEEE754 seems like a bad idea in haskell
00:24:37 <arkeet> > abs (-0 :: Float)
00:24:38 <lambdabot>   -0.0
00:24:41 <arkeet> it's supposed to be +0
00:24:55 <startling> heh
00:25:05 <adnap> Is there an editor that type checks Haskell while you write it?
00:25:54 <arkeet> http://www.haskell.org/pipermail/haskell-cafe/2013-April/106063.html
00:26:13 <startling> adnap, sounds like an annoying way to work
00:26:27 <arkeet> > signum (-0 :: Float)
00:26:28 <lambdabot>   0.0
00:26:31 <arkeet> heh.
00:26:45 <adnap> startling: Why?
00:27:21 <adnap> Maybe something where expressions are red if they don't type check and green if they are?
00:27:33 <arkeet> hdevtools :-)
00:27:46 <adnap> *if they do
00:28:02 <arkeet> and syntastic
00:28:04 <arkeet> for vim
00:28:08 <startling> adnap, what if you get a syntactically valid program that doesn't typecheck while you're writing out the whole program?
00:28:13 <arkeet> checks and highlights errors whenever you save.
00:29:49 <adnap> startling: Then the plugin/editor would tell you it doesn't typecheck; that's it
00:33:26 <notdan> ghc-mod for Emacs (and for vim I think) checks when you save the buffer
00:33:38 <notdan> but you can set it up to check on the fly
00:33:43 <notdan> as it uses flycheck
00:34:16 <adnap> WTF
00:34:31 <notdan> ?
00:34:38 <adnap> > -0
00:34:39 <lambdabot>   0
00:34:43 <arkeet> that's an Integer
00:34:51 <adnap> > -0 :: Float
00:34:52 <lambdabot>   -0.0
00:34:53 <adnap> Oh
00:35:13 <arkeet> > 0/1
00:35:14 <lambdabot>   0.0
00:35:34 <startling> adnap, still sounds distracting. to each their own, though.
00:35:44 <startling> man, ErrorT is so bad
00:35:51 <adnap> startling: Well, you have to compile eventually
00:36:27 <adnap> startling: I think it might save time if you fix a type error as it is happening rather than hunt it down based on GHC output
00:36:30 <levi> wunki: So, you could do this: (flip unless) (error "Could not find the file") =<< doesFileExist $ file cmd
00:37:06 <arkeet> flip foo bar = (`foo` bar)
00:37:19 <adnap> Why is there no isPositive isNegative in Prelude?
00:37:41 <adnap> I guess (> 0) is easy enough
00:37:52 <arkeet> precisely.
00:39:06 <levi> Ahh, (`unless` error "Could not find the file") does look cleaner.
00:42:09 <levi> So, with that it reads a bit nicer with the regular bind: doesFileExist (file cmd) >>= (`unless` error "Could not find the file")
00:45:58 <__---> ²ýේǽෲýల󚸤㉏ĺﴣ
00:46:37 <kixcereal> No, probably not.
00:47:37 <Cale> __---: What encoding is that? It's not UTF-8.
00:48:02 <__---> you gotta learn C to do that
00:48:31 <zvrba> Cale: he probably tried to exploit some irc client.
00:48:37 <kixcereal> And then he leaves?
00:49:04 <dalaing1> he didn't escape an 0x04 properly?
00:49:07 <wunki> levi: will try how that works
00:49:50 <adnap> > let norm :: Float -> Float -> Float; norm x y | x == y = 0 | x < y = 1 | otherwise = -1 in [norm 3 5, norm 5 3, norm (read "-Infinity") (read "Infinity")]
00:49:50 <lambdabot>   [1.0,-1.0,1.0]
00:53:16 <arkeet> > let norm :: Float -> Float -> Float; norm x y = signum (y - x) in [norm 3 5, norm 5 3, norm (read "-Infinity") (read "Infinity")]
00:53:18 <lambdabot>   [1.0,-1.0,1.0]
00:53:43 <arkeet> adnap: these would differ in handling stuff like NaN
00:54:11 * hackagebot elm-server 0.9 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.9 (EvanCzaplicki)
00:59:10 <adnap> arkeet: Why doesn't this work:
00:59:16 <adnap> > let norm :: Float -> Float -> Float; norm = signum . flip (-) in [norm 3 5, norm 5 3, norm (read "-Infinity") (read  "Infinity")]
00:59:17 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Float -> GHC.Types.Float))
00:59:17 <lambdabot>    arisi...
00:59:36 <sebzim4500> @undo do isOldestBoy <- withChance 0.5; isYoungestBoy <- withChance 0.5; guard (isYoungestBoy || isOldestBoy);  return (isYoungestBoy, isOldestBoy)
00:59:36 <lambdabot> withChance 0.5 >>= \ isOldestBoy -> withChance 0.5 >>= \ isYoungestBoy -> guard (isYoungestBoy || isOldestBoy) >> return (isYoungestBoy, isOldestBoy)
00:59:43 <arkeet> adnap: because . doesn't work like that
01:00:00 <adnap> Oh
01:00:10 <adnap> 'Cause (-) takes two argumemts
01:11:37 <adnap> There should be something like:
01:12:00 <adnap> trace' :: Show a => a -> a; trace' x = trace (show x) x
01:12:30 <startling> that's traceShow.
01:12:47 <startling> well, roughly. your type is off
01:12:55 <adnap> No, traceShow takes two arguments
01:13:15 <adnap> Something showable and the thing to return
01:13:24 <adnap> I want something where the thing to return is showable
01:13:47 <startling> OK
01:15:11 <mauke> :t join Debug.Trace.traceShow
01:15:12 <lambdabot> Show a => a -> a
01:15:47 <startling> > Debug.Trace.trace "hi" 12
01:15:48 <lambdabot>   Not in scope: `Debug.Trace.trace'
01:16:01 <startling> boring.
01:16:33 <adnap> Whoa, what
01:17:01 <arkeet> > join Debug.Trace.traceShow 5
01:17:03 <lambdabot>   Not in scope: `Debug.Trace.traceShow'
01:17:05 <arkeet> heh
01:17:10 <adnap> Is there a Monad instance for (-> r) ?
01:17:20 <arkeet> no.
01:17:26 <arkeet> (-> r) isn't even a thing you can write.
01:17:30 <adnap> What the heck is join traceShow?
01:17:43 <int-e> \x -> traceShow x x
01:17:43 <arkeet> you may be thinking (->) r
01:17:52 <arkeet> (I was honestly confused)
01:17:55 <adnap> :t join
01:17:55 <lambdabot> Monad m => m (m a) -> m a
01:18:02 <int-e> @pl \x -> f x x
01:18:02 <lambdabot> join f
01:18:19 <adnap> Is there a Monad instance for (->) r ?
01:18:26 <int-e> adnap: yes
01:18:54 <mauke> @unmtl Reader r a
01:18:54 <lambdabot> r -> a
01:19:02 <mauke> enjoy your isomorphism
01:19:10 <adnap> I don't know about Reader
01:19:16 <adnap> Seems kind of dumb
01:19:34 <adnap> ...to wrap a function and call it "Reader"
01:19:58 <mauke> @unmtl State s a
01:19:58 <lambdabot> s -> (a, s)
01:20:01 <mauke> or State
01:20:16 <mauke> @unmtl Writer w a
01:20:16 <lambdabot> (a, w)
01:20:25 <mauke> or Writer (but that's a tuple, not a function)
01:21:22 <adnap> Can lambdabot understand something like @src join for different monads?
01:21:36 <adnap> I want to see the source of join for the (->) r instance
01:21:54 <mauke> @src join
01:21:55 <lambdabot> join x =  x >>= id
01:22:08 <mauke> join is not a method
01:24:01 <startling> adnap, it's very useful
01:24:16 <startling> (re "Seems kind of dumb")
01:25:06 <adnap> What is >>= for functions?
01:25:23 <adnap> startling: How is it more useful than a function r -> a ?
01:25:31 <mauke> @src (->) >>=
01:25:31 <lambdabot> Source not found. stty: unknown mode: doofus
01:25:34 <mauke> @src (->) (>>=)
01:25:34 <lambdabot> f >>= k = \ r -> k (f r) r
01:25:49 <startling> adnap, you can use the Monad combinators
01:25:59 <adnap> startling: You can use them on functions too
01:26:01 <quchen> GHC neither uses MPTCs nor existentials internally, right?
01:26:36 <startling> adnap: oh, you're talking about Reader precisely. Yeah, Reader is kind of annoying but ReaderT is useful
01:34:12 <johnw> I actually use ReaderT much more often than StateT
01:35:25 <startling> ReaderT has nicer laziness properties than StateT anyhow
01:36:38 <adnap> Does the ReaderT monad behave differently than the function monad for functions of type Monad m => r -> m a ?
01:37:01 <johnw> it has the type ReaderT, for one
01:37:09 <adnap> Well, that's not important
01:37:13 <Nisstyre> I wish lambdabot could give you the source of a specific type class method for a type
01:37:21 <johnw> it sure can be when you're trying to work out type errors in deeply nested transformer stacks
01:37:30 <adnap> Nisstyre: It can, as demonstrated by mauke
01:37:46 <adnap> @src Maybe (>>=)
01:37:46 <lambdabot> (Just x) >>= k      = k x
01:37:46 <lambdabot> Nothing  >>= _      = Nothing
01:37:54 <Nisstyre> oh you have to prefix it with the type
01:38:00 <adnap> Yep
01:38:04 <Nisstyre> neat
01:38:50 <adnap> johnw: Maybe all the type wrapping is causing the confusion.
01:39:31 <johnw> adnap: well, I appreciate it being a separate type
01:39:43 <startling> adnap, it behaves differently, yeah
01:39:49 <startling> :t sequence [return] 1
01:39:49 <lambdabot> (Monad m, Num a) => [m a]
01:40:14 <startling> :t runReaderT (sequence [return]) 1
01:40:15 <lambdabot>     Couldn't match expected type `ReaderT r0 m0 a0'
01:40:15 <lambdabot>                 with actual type `a1 -> m1 a1'
01:40:15 <lambdabot>     In the expression: return
01:40:34 <startling> uh
01:40:40 <adnap> Maybe put a $ in there?
01:40:47 <startling> :t runReaderT (sequence [ask]) 1
01:40:48 <lambdabot> (Monad m, Num r) => m [r]
01:41:13 <adnap> @src ReaderT return
01:41:13 <lambdabot> Source not found. My mind is going. I can feel it.
01:41:27 <startling> @src cheats
01:41:27 <lambdabot> Source not found. My mind is going. I can feel it.
01:43:08 <johnw> return = const, I believe
01:43:32 <johnw> well, Reader . const
01:50:08 <quchen> > (sequence [ask]) 1  -- startling
01:50:09 <lambdabot>   [1]
01:51:10 <quchen> > runReader (sequence [ask]) 1  -- Also works, uses Reader instead of (->) directly
01:51:11 <lambdabot>   [1]
01:51:26 <startling> oh
01:51:32 <johnw> (->) r is an instance of MonadReader, isn't it?
01:51:41 <startling> :t runReaderT (sequence [lift Just]) 1
01:51:42 <lambdabot> a -> [Maybe a]
01:51:57 <startling> (sequence [lift Just]) 1
01:52:06 <startling> :t (sequence [lift Just]) 1
01:52:07 <lambdabot>     Couldn't match kind `* -> *' with `*'
01:52:07 <lambdabot>     Expected type: (->) a0 -> [Maybe a0]
01:52:07 <lambdabot>       Actual type: (->) a0 -> [Maybe a0]
01:52:33 <quchen> Cool error
01:53:14 <quchen> johnw: Yes.
01:53:59 <startling> quchen, I was trying to illustrate what ReaderT a m b gives you over a -> m b
01:54:06 <quchen> Nothing?
01:54:16 <quchen> Fancy syntax, that's about it
01:54:49 <johnw> it also keeps arguments out of function types that that function has nothing to do with
01:55:02 <johnw> you can think of it as a kind of "dependency injection"
01:55:28 <johnw> if all my functions needs an "environment" argument, when most of them don't use it, that seems much worse
01:55:29 <startling> oh, I did the wrong thing
01:55:39 <startling> > runReaderT (sequence [lift Nothing]) 1
01:55:40 <lambdabot>   Nothing
01:55:50 <startling> > (sequence [lift Nothing]) 1
01:55:51 <lambdabot>   Couldn't match kind `*' with `* -> *'
01:55:51 <lambdabot>  Expected type: Data.Maybe.Maybe -> [...
01:57:06 <quchen> lift requires MonadTrans, which (->) is not an instance of
01:57:33 <johnw> right, because there couldn't be a base monad that it would know about
01:57:36 <quchen> :t lift -- there's no "t" for (->)
01:57:37 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
01:57:59 <johnw> so that's another point in ReaderT's favor
01:58:41 <quchen> Well, you could always do the binding explicitly. But in Reader's case, that's probably a little verbose. In general though, I sometimes avoid transformers and do it explicitly, e.g. when having an IO (Maybe a).
02:00:21 <quchen> (->) isn't really Reader, it's "look what funny code I can write with the Monad combinators".
02:00:36 <quchen> So Reader has that over (->) as well. :-D
02:04:17 * hackagebot vhd 0.2.1 - Provides functions to inspect and manipulate virtual hard disk (VHD) files.  http://hackage.haskell.org/package/vhd-0.2.1 (VincentHanquez)
02:07:36 <startling> quchen: man, that HN thread is a mess
02:07:54 <quchen> startling: FUD
02:08:28 <startling> quchen, yeah. :/
02:08:37 <Yaniel> hmm?
02:08:45 <quchen> https://news.ycombinator.com/item?id=6190005
02:09:53 <quchen> Recently some guy on Reddit was pissy about Haskell and kept arguing how there are so many lists in Haskell (spoiler: there's only one), and how Haskell makes him use unsafePerformIO so that he hasn't got to pollute his code with IO and ST.
02:09:59 <quchen> I guess it could be worse.
02:10:33 <startling> 'so many lists'?
02:10:37 <pharaun> lol
02:10:56 <Nisstyre> well, I do think that sometimes lists are used when a more specific data structure would be clearer or more efficient
02:11:15 <pharaun> like dict in python
02:11:34 <Nisstyre> pharaun: that people overuse it?
02:11:37 <quchen> Nisstyre: Yes, for example Map Vector Array Sequence. Lists have the very speicif use case of a linked list, because they are linked lists.
02:11:40 <pharaun> Nisstyre: yup
02:11:41 <quchen> (Plus the laziness bonus.)
02:12:08 <pharaun> (i work with python at work) and the dicts are overused
02:12:14 <pharaun> (dicts are nice but ffs)
02:12:16 <Nisstyre> pharaun: yeah that may be true
02:12:45 <pharaun> sometime more specific data structure, other way of representing info is nicer :)
02:12:48 <pharaun> oh well
02:13:11 <startling> first comment: "If you're trying to sell me on Haskell, right there you just made me think "uh, ok, guys, but my code does not live in an ivory tower, and very much needs to deal with the real world, messy data, users, and so on"."
02:13:12 <startling> :/
02:13:34 <startling> child: "The power of Haskell is that it acknowledges the fact that it's a messy world and deals with it with the help of Monads."
02:13:35 <pharaun> i... deal with lots of messy data (parsing) ;p
02:13:35 <startling> :/
02:14:02 <Nisstyre> I think they need to watch this http://youtu.be/z0N1aZ6SnBk
02:14:37 <quchen> http://www.reddit.com/r/programming/comments/1jsv8d/programming_haskell_doesnt_require_any_category/cbi3bwb
02:14:40 <quchen> That was the thread.
02:14:53 <Nisstyre> quchen: I think I saw the same thing linked on HN
02:15:02 <Nisstyre> which is what startling is quoting from I think
02:15:44 <startling> Nisstyre: nah, this is a relatively young thread
02:15:47 <Nisstyre> oh ok
02:15:56 <Nisstyre> I swear I saw the exact same comment on HN
02:16:00 <Nisstyre> maybe it was
02:16:14 <startling> Nisstyre: fwiw I think that reddit comment has a fair complaint
02:17:20 <Nisstyre> "(the most obvious example is String vs ByteString vs Text... though there are many others)"
02:17:33 <Nisstyre> they do realize that ByteString serves a different purpose from Text and String, right?
02:17:40 <quchen> That reminds me,
02:17:42 <quchen> @quote quchen Requiring category theory for writing Haskell is like requiring automata theory to use C.
02:17:42 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
02:17:47 <quchen> @remember quchen Requiring category theory for writing Haskell is like requiring automata theory to use C.
02:17:47 <lambdabot> It is forever etched in my memory.
02:18:05 <startling> Nisstyre: oh, I'm talking about the parent
02:18:33 <quchen> That thread is so full of statements like these that you should really only talk about them with permalinks added :>
02:19:39 <startling> Nisstyre permalinked the one I'm talking about!
02:20:18 <Nisstyre> startling: okay I see
02:44:06 <notdan> Is there a typeclass that is kinda the inverse of MonadIO/MonadControl?
02:44:26 <startling> notdan, what would the inverse of MonadIO be?
02:44:38 <notdan> I want to abstract my code over monads that can be run to IO producing effects
02:45:25 <startling> "run to IO producing effects"? how's that different from MonadIO?
02:47:02 <notdan> @ty liftIO
02:47:03 <lambdabot> MonadIO m => IO a -> m a
02:47:13 <notdan> and I want to have something like m a -> IO a
02:47:38 <notdan> Or even (MonadBase n IO) => m a -> n a
02:48:15 <startling> hmmm
02:52:20 <notdan> Ugh, nvm, this is too weird, I should get a break
02:54:46 <osa1> hi all. let's say I'm compiling and linking my haskell library against a C library and in one of the headers file there is a constant defining version number of that c library. I want to put some compile time conditionals(CPP) based on that number, how can I do that?
02:54:51 <Pad^> hey guys
02:54:56 <Pad^> http://www.reddit.com/r/haskell/comments/1k18i9/new_haskell_library_capabilities_a_brand_new_step/
02:55:00 <Pad^> what do you think of this?
02:56:36 <int-e> too many indirections. http://hackage.haskell.org/package/Capabilities
02:58:27 <Pad^> yeah sorry
02:58:36 <Pad^> I should have pasted the link directly
02:59:08 <notdan> Would it be considered as abuse if I define a (MonadBase m IO) instance for my monad m, even though 'm' clearly is not a "base" monad for IO?
02:59:18 * hackagebot crypto-cipher-types 0.0.1 - Generic cryptography cipher types  http://hackage.haskell.org/package/crypto-cipher-types-0.0.1 (VincentHanquez)
02:59:20 * hackagebot crypto-cipher-tests 0.0.1 - Generic cryptography cipher tests  http://hackage.haskell.org/package/crypto-cipher-tests-0.0.1 (VincentHanquez)
03:03:26 <merijn> notdan: I don't understand why you want this?
03:03:41 <merijn> notdan: Any MonadIO can already be transformed into an IO a
03:03:48 <merijn> It's called
03:03:56 <merijn> :t runStateT
03:03:57 <lambdabot> StateT s m a -> s -> m (a, s)
03:04:01 <merijn> :t runIdentityT
03:04:02 <lambdabot>     Not in scope: `runIdentityT'
03:04:02 <lambdabot>     Perhaps you meant `runIdentity' (imported from Control.Monad.Identity)
03:04:04 <merijn> etc
03:04:18 * hackagebot crypto-cipher-benchmarks 0.0.1 - Generic cryptography cipher benchmarks  http://hackage.haskell.org/package/crypto-cipher-benchmarks-0.0.1 (VincentHanquez)
03:04:20 * hackagebot cipher-aes 0.2.0 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.2.0 (VincentHanquez)
03:04:21 <notdan> Yes, I want ot have that general run function
03:05:07 <merijn> notdan: That can't exist
03:05:42 <merijn> notdan: Because for example StateT takes an "s" as argument, ReaderT an r, "ReaderT r (StateT s m)" takes an s *and* an r as argument
03:05:52 <merijn> notdan: How would you handle all those cases?
03:06:05 <notdan> type families maybe?
03:06:08 <startling> :D
03:08:37 <int-e> Pad^: hmm, it's interesting. I wonder how much of an overhead the intermediate free monad incurs, and I wonder about the meaning and utility of the "Trustworthy" declaration in Capabilities.IO.
03:08:38 <osa1> any ideas on this -> "let's say I'm compiling and linking my haskell library against a C library and in one of the headers file there is a constant defining version number of that c library. I want to put some compile time conditionals(CPP) based on that number, how can I do that?"
03:09:26 <int-e> Pad^: (I expected the restriction to be carried around in a phantom type that will - hopefully - disappear at compile time)
03:09:40 <maurer> osa1: http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/pragmas.html
03:10:17 <maurer> osa1: you may also be interested in
03:10:18 <maurer> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/hsc2hs.html
03:13:09 <Pad^> int-e i'm not the author of the package, but as soon as they wake up, I'll contact them :)
03:15:02 <startling> int-e: re: "Trustworthy": http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/safe-haskell.html
03:23:09 <adnap> startling: Cool!
03:23:17 <adnap> startling: Can you explain " Unfortunately Template Haskell can be used to subvert module boundaries and so could be used gain access to this constructor."?
03:23:29 <startling> nope!
03:24:30 <adnap> np
03:27:40 <shelf> template haskell is a union scab. you get access to all the other less-dogmatic workers in the union, he turns people
03:27:55 <shelf> all of a sudden, you have more constructors than you know what to do with
03:29:20 <enthropy> adnap: http://lpaste.net/91403 is one example
03:32:18 <int-e> startling: So the Capabilities.Internals module is inferred to be unsafe, but it does not actually violate the SafeHaskell requirements as far as I can see, so why isn't it Trustworthy? Going further, the C.IO module is declared safe. The top-level Capabilities module exports both, so is inferred to be unsafe. So you cannot run the restricted IO actions "safely". Maybe that's the intended meaning, maybe it's accidential. So...
03:32:25 <int-e> ...that brings me back to my question, what is the actual interpretation of "safety" used there?
03:33:37 <startling> int-e, it has {-# Trustworthy #-} in it
03:34:53 <int-e> startling: yes, that means that the author declares it to be safe. but it's just that single module.
03:35:28 <startling> int-e: I'm not sure what you're asking.
03:36:23 <int-e> I'm asking about the meaning of "safety" as understood by the author of Capabilities.
03:37:11 <startling> int-e, I have no idea.
03:38:20 <quchen> I guess he wants things like "CanUseNetwork a" instead of "IO a" so you can be sure it won't read your personal files.
03:40:35 <adnap> What if the author of the Danger module imports another one of his modulues containing {-# Trustworthy #-} and a bunch of unsafe things?
03:42:06 <cinimod> I am getting Warning: Couldn't figure out LLVM version! Make sure you have installed LLVM
03:42:26 <cinimod> But my understanding that LLVM is already installed on MACOS (which is what I am on)
03:42:57 <cinimod> I seem to have llvm-cpp-4.2  llvm-g++      llvm-g++-4.2  llvm-gcc      llvm-gcc-4.2
03:42:57 <cinimod>  
03:43:20 <cinimod> /usr/bin/llvm-cpp-4.2
03:43:20 <cinimod>  
03:46:28 <imprger> Lambdabot:
03:49:24 <int-e> startling: I should ask more simply: Why is 'run', which runs a restricted IO action, not exported in the "safe" fragment of Capabilities?
03:50:11 <haskellnoobee> I have several concurrent IO functions which call putStrLn, is it a good idea to use putStrLn exported there http://hackage.haskell.org/packages/archive/monadIO/0.10.1.3/doc/html/src/Control-Concurrent-StdInOut.html  ?
03:50:40 <int-e> (well, s/safe/trustworthy/)
03:58:24 <int-e> adnap: template haskell allows you access to information about data types, including constructors. For example, I have a module with type data TTT = A | B | C, but none of the constructors is exported. I can create a value corresponding to its first constructor like this: $(do TyConI (DataD _ _ _ (NormalC con [] : _) _) <- qReify ''TTT; conE con)
04:01:19 <int-e> do adnaps eat oobmab?
04:01:31 <adnap> Not this one
04:02:49 <adnap> int-e: Thanks for the example, but I think I asked a stupid question. I don't know Template Haskell, so I asked a question whose answers I would not understand.
04:03:30 <int-e> adnap: well, it's accessing a constructor that is not exported, circumventing the restricted export list.
04:04:35 <int-e> I think that fact answers your question, even if you don't want to pick apart the code :)
04:05:29 <merijn> adnap: Basically, the simplified answer is "TH has access to things the export normally wouldnt allow access too, thus letting you break invariants of said module"
04:07:51 <merijn> adnap: Let's take the example of Capabilities mentioned above
04:08:44 <merijn> adnap: Suppose it has a type that only allows network access, but no file access. The constructor might accept any "IO a", but limit what can be done by not exporting that constructor and having a function that restricts what you can do.
04:09:18 <merijn> adnap: If TH lets you get access to that constructor, you can then put an IO action that accesses the disk into a type that should normally only allow network access
04:09:37 <merijn> Make sense?
05:09:28 <Kaini> I have a list of values and want to fill a record's fields with them. Is there an easy way to do this? Or more general - I want to apply a list of values to a function as parameters.
05:09:41 <Kaini> Specifically I want to avoid f (list !! 0) (list !! 1) (list !! 2)
05:10:14 <zvrba> you can pattern match in function definition
05:10:19 <zvrba> f [a,b,c] = ...
05:10:23 <zvrba> f [a,b] = ...
05:10:46 <zvrba> but why would you want to do that instead of simply passing a list?
05:11:04 <zvrba> you don't win anything since a list contains elements of one type
05:12:58 <startling> they might be semantically different.
05:13:08 <startling> though it does seem silly to have a list in the first place.
05:13:24 <Kaini> The record has 8 fields and I do some calculations that modify it quite a bit (using map and zipWith3 ...) and I convert the record to a list to do this easily and now i want to convert it back
05:13:24 <bscarlet> depends on where it came from
05:13:38 <Kaini> maybe my approach is wrong?
05:14:06 <startling> Kaini, you may want to make your datatype a functor
05:15:23 <merijn> Kaini: Can you lpaste some example code?
05:16:18 <bscarlet> @where paste
05:16:19 <lambdabot> http://lpaste.net/new/haskell
05:16:27 <zvrba> I have a question too: I've heard a lot of stories about lazy IO being "evil" so I'm wondering how to do IO efficiently in Haskell?
05:16:49 <zvrba> I want to read a file, line by line, take out an ID from each line and find the maximum of all IDs
05:17:00 <merijn> zvrba: Step 1 is learn what people mean by evil
05:17:01 <chrisdone> use Data.Text.IO
05:17:02 <chrisdone>  
05:17:05 <Kaini> The functor idea is interresting, I've read about them just yesterday :P
05:17:17 <zvrba> then I'll allocate an array, make another pass through the file, parse each line and store it as a record into the array
05:17:41 <merijn> zvrba: The problem with lazy IO is that you might be keeping open file descriptors open some arbitrary time, due to them not being closed until you hit EOF at some point in the future
05:18:09 <merijn> zvrba: Another issue is that "hGetContents :: IO String" can consume huge amounts of space if there's no fusion when handling the resulting huge String
05:18:10 <chrisdone> zvrba: the solution is just to use the right library and use strict IO. lazy IO is one of those "don't use unless you know you need it" things
05:18:12 <zvrba> merijn: but I need two passes through the file. does it mean I have to reopen it when I hit EOF for the 1st time?
05:18:35 <chrisdone> zvrba: if you're working with text, use Data.Text, if you're working with binary data use Data.ByteString. both provide their own IO library
05:18:37 <merijn> zvrba: Basically, if your file is small enough to fit into memory entirely it doesn't really matter what you do
05:18:41 <zvrba> chrisdone: "right" as in Data.Text.IO ?
05:18:47 <phst`> @pl \x y -> f (g (h x) (h y))
05:18:50 <lambdabot> (f .) . flip ((.) . g . h) h
05:18:50 <lambdabot> optimization suspended, use @pl-resume to continue.
05:18:56 <chrisdone> zvrba: if you're working with text,  yeah
05:19:02 <zvrba> merijn: it's not small. a few hundred MB, and 32 bit ghc.
05:19:02 <merijn> phst`: Looks like you want Data.Function.on
05:19:05 <merijn> :t on
05:19:06 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
05:19:30 <merijn> zvrba: conduits/iteratees/pipes are all attempts to do streaming IO without the issues I just mentioned
05:19:31 <FreeFull> :t (+) `on` id
05:19:31 <lambdabot> Num c => c -> c -> c
05:19:36 <zvrba> ok, Data.Text and Data.ByteString
05:19:53 <merijn> :t (+) `on` ord
05:19:54 <lambdabot> Char -> Char -> Int
05:20:13 <startling> > ((+) `on` abs) (-2) (-3)
05:20:14 <lambdabot>   5
05:20:41 <hpaste> Kaini pasted “Functor?” at http://lpaste.net/91711
05:20:57 <Kaini> merijn
05:21:00 <phst`> merijn: thanks
05:21:14 <chrisdone> functors need to be of kind * -> *, e.g. D a
05:21:25 <Kaini> sorry, merijn - here is a paste: http://lpaste.net/91711
05:22:16 <Kaini> And I want that dMul returns a D and not a list
05:22:32 <bscarlet> Kaini: is that a stripped-down example? The generic field names make me question your use of a record.
05:22:54 <FreeFull> :t ap
05:22:55 <lambdabot> Monad m => m (a -> b) -> m a -> m b
05:22:56 <Kaini> Yes, it is
05:23:00 <FreeFull> :t ap (+)
05:23:01 <lambdabot> Num a => (a -> a) -> a -> a
05:23:43 <hpaste> merijn annotated “Functor?” with “Functor? (annotation)” at http://lpaste.net/91711#a91712
05:24:44 <merijn> Kaini: If your datatype should only contain Integers you could write a specialised function rather than use fmap
05:24:54 <bscarlet> merijn: just a tuple? It's (a,a,a,a,a,a), not (a,b,c,d,e,f).
05:25:11 <merijn> bscarlet: And that's not a tuple? :)
05:25:28 <merijn> Granted, the functor instance of tuple is slightly different, but that' trivially solved with a newtype
05:25:28 <chrisdone> that's a fixed length list =p
05:25:38 <bscarlet> merijn: :-) sure, but no more than any other record is a tuple
05:26:16 <FreeFull> Doesn't the functor instance for tuples only operate on the last element of the tuple?
05:26:27 <merijn> FreeFull: See my last comment :)
05:26:27 <FreeFull> > (3,4) `fmap` (+4)
05:26:28 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `(t0, t1)'
05:26:41 <startling> merijn, and every product type is just an Either
05:26:45 <merijn> Also, tuples aren't functor in prelude
05:26:45 <FreeFull> > fmap (+4) (3,4) -- Woops, wrong argument order there
05:26:46 <lambdabot>   (3,8)
05:26:54 <startling> sorry, *sum type
05:26:54 <merijn> I think?
05:27:00 <bscarlet> Kaini: GHC has an extension that would let you derive the Functor instance
05:27:10 <merijn> oh, no they are
05:27:19 <FreeFull> You could also just use lensees
05:27:20 <merijn> bscarlet: Not for his original example
05:27:22 <Kaini> merijn, in fact I've thought about using a tuple instead of a datatype, but I think i'll have the same problem then, since I cannot use map etc. on tuples, i guess
05:27:38 <phst`> @pl \x y -> f (g x y)
05:27:38 <lambdabot> (f .) . g
05:27:41 <bscarlet> merijn: ? There isn't a functor instance in his original example. What am I missing?
05:27:41 <FreeFull> > (3,4,5,1,6,1) & each .~ 3
05:27:43 <lambdabot>   (3,3,3,3,3,3)
05:27:45 <merijn> Kaini: You can write your own map, though, just look at my example
05:27:55 <merijn> bscarlet: It doesn't have a type parameter
05:28:02 <epta> Is there a way to cleanup (remove from scope) specific function, variable, data declaration in long ghci session?
05:28:05 <merijn> bscarlet: Only types of kind * -> * can be functors
05:28:24 <chrisdone> epta: not that i know of
05:28:38 <chrisdone> the ghc interpreter api can do it, but ghci doesn't
05:28:40 <merijn> epta: ":r" reloads the loaded file, but that wipes everything, not just a couple of things
05:29:02 <FreeFull> > (3,4,5,1,6,1) & each .% (+3)
05:29:03 <lambdabot>   Not in scope: `.%'
05:29:03 <lambdabot>  Perhaps you meant one of these:
05:29:03 <lambdabot>    `.' (imported from D...
05:29:14 <FreeFull> > (3,4,5,1,6,1) & each .%~ (+3)
05:29:15 <lambdabot>   Not in scope: `.%~'
05:29:15 <lambdabot>  Perhaps you meant one of these:
05:29:15 <lambdabot>    `#%~' (imported fro...
05:29:19 <FreeFull> Hmm
05:29:23 <FreeFull> I don't remember the operators =P
05:29:38 <merijn> Kaini: I mean, there's no real reason why you have to use "map", right? You could just write your own variation of map to use
05:29:40 <startling> > (3,4,5,1,6,1) & each %~ (+3)
05:29:41 <bscarlet> merijn: talking past each other. I was referring the your example, not the original. I was referring to 'the Functor instance' on lines 6-7 of your example, and there is no other instance.
05:29:41 <lambdabot>   (6,7,8,4,9,4)
05:30:19 <FreeFull> > over each (+3) (3,4,5,1,6,1) -- Same thing
05:30:21 <lambdabot>   (6,7,8,4,9,4)
05:30:21 <Kaini> merijn, yes, you are right
05:30:49 <merijn> bscarlet: oh, right
05:31:21 <Kaini> merijn, I think your soluton, making D a functor is the best
05:31:23 <Kaini> thanks all
05:31:33 <merijn> Kaini: np :)
05:32:22 <merijn> First World Programmer problem: My language is so nice, the hardest part of coding is agonising over naming things and line wrapping
05:33:16 <bscarlet> merijn: perhaps that's the real advantage of pointless code - fewer things to name, hence more efficient coding for lack of agonizing over names
05:34:12 <merijn> bscarlet: It is!
05:34:46 <merijn> I have a function that's just 8 smaller ones composed together using (.) on screen now :D
05:35:12 <bscarlet> sweet
05:35:35 <startling> lens does wonders for that.
05:35:53 <startling> I'm finally getting into prisms; "has" and "preview" are great.
05:39:43 <startling> "has _Left" is way easier than remembering where the hell "isLeft" is
05:51:44 <merijn> Right, to get back to my earlier naming question, is there a naming convention for modules just containing kitchen sink utility functions inside your library?
05:52:11 <startling> I've seen Util and Common
05:52:26 <startling> sometimes I just stick them in Types or Internal.
05:53:17 <merijn> startling: I considered that, but I wanted to keep those clean
05:54:07 <merijn> Maybe I should just name it .KitchenSink
05:57:39 <startling> merijn, MyModule.Lens
06:07:03 <S_J> is there cabal command to run the program? like there is cabal test
06:08:21 <rmyers> i can't seem to find a haskell platform package for a powerpc mac running 10.5.x. does anyone know if it exists?
06:08:51 <S_J> since it builds into dist/build/programname/ it would be nice with a builtin command like cabal run that would run the program
06:11:37 <merijn> rmyers: I don't think platform is being build for powerpc, because the newer xcode's don't support it
06:11:50 <dcoutts_> rmyers: you'll probably have to grab an old ghc and then add the platform libs using cabal
06:12:22 <merijn> Actually, it looks like even ghc doesn't come with powerpc binaries anymore
06:14:09 <merijn> It seems like GHC 7.0.4 was the last one with powerpc binaries, would it be possible to bootstrap 7.6 from there?
06:23:05 <joeyh> merijn: debian has ghc 7.6.3 built for powerpc
06:23:17 <joeyh> (full list: amd64, armel, armhf, hurd-i386, i386, kfreebsd-amd64, kfreebsd-i386, mips, mipsel, powerpc, s390, sparc)
06:23:42 <hpc> i wonder if anyone's built ghc for mainframes :P
06:23:49 <joeyh> see s390 above :)
06:24:15 <hpc> <.<
06:24:41 <rmyers> merijn: dcoutts_: joeyh: thanks for the info, i think i'll just stick to using my debian box instead :)
06:24:59 <gienah> gentoo has ghc 7.6.1 binary for powerpc http://code.haskell.org/~slyfox/ghc-ppc64/
06:26:50 <Zenol> Did someone remember the types/name of function generated with the makeLens call of a snap application?
06:27:39 <hpc> Zenol: could you rephrase the question? it's hard to tell what's being asked
06:29:23 <Zenol> hpc: Sorry. Actualy I found the answer in the Data.Lens.Template makeLens documentation.
06:29:50 <Zenol> although I don't know what's a lens, so I'm not sure how to use it.
06:31:40 <hpc> Zenol: a lens is a pair of functions, one to "get" and one to "set"
06:31:51 <applicative> Zenol is it a record type you are doing 'makeLenses' for?
06:32:20 <hpc> so for a tuple, a "first" lens would be Lens {get = \(x, y) -> x; set = \(x, y) x' -> (x', y)}
06:32:31 <applicative> > (1,"California") ^. _1
06:32:33 <lambdabot>   1
06:32:36 <applicative> > (1,"California") ^. _2
06:32:37 <lambdabot>   "California"
06:32:39 <hpc> (for some hypothetical Lens type)
06:32:50 <hpc> there's more to it, but that's the basic principle
06:33:01 <applicative> > (1,"California") & _2 .~ "Arizona"
06:33:02 <lambdabot>   (1,"Arizona")
06:33:02 <S_J> cbreak: I see in QSettings there a exampels that use an XMLreader and XMLwriter. If I want a usereditable Settings-file in XML Id have to load and save the data to an XML file right? I just dont get what you are saying.
06:33:03 <Zenol> applicative: Yes, it's the "snap" Application.hs file. I makelens a IORef _status. I would like to get it without having to use ioRef <- gets _status in the Snap App App monad.
06:33:23 <hpc> what it gets you, it a nicer way to drill down into data structures than record syntax and the like
06:33:52 <S_J> > fst (1,2)
06:33:53 <lambdabot>   1
06:33:56 <S_J> > snd (1,2)
06:33:57 <lambdabot>   2
06:34:09 <S_J> > fst (1,2,3)
06:34:10 <lambdabot>   Couldn't match expected type `(a0, b0)'
06:34:10 <lambdabot>              with actual type `(t0,...
06:34:20 <applicative> > (1,2,3) ^. _1
06:34:21 <lambdabot>   1
06:34:44 <S_J> > let fst3 (a,_,_) = a in fst 3 (1,2,3)
06:34:45 <lambdabot>   Could not deduce (GHC.Num.Num
06:34:45 <lambdabot>                      ((GHC.Integer.Type.Integ...
06:34:50 <S_J> > let fst3 (a,_,_) = a in fst3 (1,2,3)
06:34:51 <lambdabot>   1
06:35:04 <Zenol> sorry, not Snap, but Handle App App monad.
06:37:24 <applicative> > (1,2,3) & (_1 .~ "Arizona") . (_3 .~ "California")
06:37:25 <lambdabot>   ("Arizona",2,"California")
06:37:52 <Zenol> why can't I find a simple example on how to mutate a field of the "App" structure of a snap application.
06:38:24 <Zenol> All a gets from github is "It's a state monad, so you can do val <- gets _fieldName". Why using lens if I should use this syntax?
06:39:38 <applicative> oh I see yes it is presupposing you know how to use the lens library
06:40:02 <Zenol> applicative: They do not provide how to get a Lens from their monads...
06:40:26 <Zenol> applicative: I would be happy to use lens if I have something that give me a lens from their monad >.< Maybe snapletValue.
06:40:34 <applicative> @type set
06:40:35 <lambdabot> ASetter s t a b -> b -> s -> t
06:40:45 <applicative> @type set _1
06:40:46 <lambdabot> Field1 s t a b => b -> s -> t
06:43:33 <haasn> > (1,2,3) & _1 .~ "hello" & _3 .~ "world" -- look ma, no parens
06:43:35 <lambdabot>   ("hello",2,"world")
06:43:49 <applicative> Zenol: I'm not quite seeing how it all fits together there but
06:44:04 <applicative> haasn: yeah I wondered, and decided to play it safe with lambdabot
06:44:11 <applicative> the horror of lens error messages!
06:44:14 <Fuuzetsu> Shou: I just saw your 1k LOC JS monster with type annotations. Why not use something like ‘fay’?
06:44:33 <Fuuzetsu> (or I think GHCJS is the rage nowadays, I'm unsure)
06:44:54 <applicative> Zenol: you will 'mutate' a value with set or .~
06:45:20 <applicative> > _1 .~ "Hi" $ (1,2)
06:45:22 <lambdabot>   ("Hi",2)
06:45:29 <Shou> Fuuzetsu, ww
06:45:38 <Fuuzetsu> http://www.haskell.org/haskellwiki/The_JavaScript_Problem
06:45:47 <applicative> here (1,2) is your value, _1 corresponds to fieldName
06:45:51 <Shou> I've considered it
06:45:51 <haasn> ghcjs!
06:45:57 <Shou> I think I'll do that next time
06:46:01 <Fuuzetsu> Wow, I didn't know you could use Idris for it!
06:46:14 <haasn> ghcjs is impressive
06:46:30 <haasn> it managed to compiled my gloss+lens examples right down to javascript without them needing alterations (other than changing the name of one import)
06:46:45 <haasn> as a result, you can play pong in the browser
06:46:47 <Fuuzetsu> haasn: and it worked fine?
06:47:02 <haasn> Fuuzetsu: see the result for yourself: http://hdiff.luite.com/gloss/pong/
06:47:07 <Zenol> applicative: Yap, I know that. Although I never used lens I saw guys duing funny things and also tried with lambda bot. But what makes me crasy is I can't find a simple and clear documentation of how snap fits with lens. Thats the snap API/doc that makes me crasy.
06:47:32 <Shou> Don't I need GHC 7.8 for ghcjs?
06:47:39 <applicative> theres a pretty extensive discussion in https://github.com/snapframework/snap/blob/master/src/Snap/Snaplet.hs but it seems incomplete?
06:48:02 <haasn> does snap provide lenses?
06:48:07 <startling> yep
06:48:09 <applicative> haasn: yes
06:48:20 <haasn> well there you go, use those lenses :P
06:48:27 <Zenol> applicative: When you applied makeLens on a datatype with _named fields, you can write something like value ^. fieldName ?
06:48:32 <Fuuzetsu> Shou: 7.7… maybe, 7.8 is not even out until September (?)
06:48:54 <applicative> haasn: well, it seems they give a prototype for how to use them, the snap libraries do well to avoid a lens dependency
06:48:54 <haasn> Zenol: basically, yes
06:49:02 <Zenol> hassn: They are 10 functions that give lens on that documentation, and I don't know which one I should use to the the right lens.
06:49:24 <haasn> applicative: that's typical for lens-providing libraries
06:49:30 <applicative> yes
06:49:44 <applicative> Zenol: right, you detach the _ from the 'actual' fieldname
06:50:09 <Shou> Oh hey, nand contributed to that pong game.
06:50:20 <haasn> Shou: I wrote it :)
06:50:32 <applicative> haasn == nand?
06:50:33 <Zenol> :i (^.)
06:50:37 <haasn> most of it, at any rate
06:50:39 <haasn> applicative: yes
06:50:43 <Zenol> @i (^.)
06:50:43 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect v @ ? .
06:50:44 <applicative> ah, hi nand
06:50:48 <haasn> hi applicative
06:50:55 <Shou> Wait, you're nand? oh neat
06:50:56 * Zenol doesn't know how to use lambdabot.
06:50:58 <applicative> you make more sense to me now
06:51:04 <Zenol> Which package export ^. ? :)
06:51:22 <haasn> Zenol: "lens" Control.Lens
06:51:28 <applicative> Zenol: Control.Lens
06:51:48 <Zenol> thanks :)
06:52:08 <S_J> Do you think it is a good idea to add a run command to cabal? cabal run --runs the appname.exe in dist/build/appname/
06:52:32 <Fuuzetsu> haasn: the ball physics on that are pretty weird (and I suck at pong apparently)
06:52:41 <haasn> Fuuzetsu: I won't deny it
06:53:08 <haasn> I have some modified versions at home that (still completely ignoring actual physics) make for a more fun playing experience by preventing the ball from bouncing up/down rapidly
06:53:26 <haasn> but for the purposes of the demonstration (lens + gloss + State-based imperative programming) it's fairly irrelevant
06:53:29 <imprgrmr> Can I pass multiline statements to Lambdabot?
06:53:41 <startling> imprgrmr: yep
06:53:56 <startling> imprgrmr: :{, then newline, then your code, then newline, then :}
06:54:04 <startling> or
06:54:06 <startling> oh
06:54:08 <startling> misread that
06:54:15 <startling> as "ghci" somehow. :/
06:54:48 <Fuuzetsu> could you not just run it in the Identity monad with the {;} syntax?
06:55:23 <startling> huh?
06:55:50 <Fuuzetsu> nevermind, I thought he wanted multiple statements
06:56:07 <imprgrmr> In Haskell, how to put multiple statements on one line?
06:56:18 <startling> imprgrmr: what's a statement?
06:56:31 <Fuuzetsu> expressions*
06:56:38 <imprgrmr> startling: something like `x=3`
06:56:56 <startling> imprgrmr, I don't think you can.
06:57:46 <k00mi> x = 3; y = 4
06:58:11 <Zenol> In "Snaplet Helper Function" http://hackage.haskell.org/packages/archive/snap/0.6.0.2/doc/html/Snap-Snaplet.html there are the App struct they create. and know i'm in a "Handler App App", and I can't find any explanation on how to get a lens to App so that I can write something ^. fieldname :(
06:58:15 <Fuuzetsu> > let x = 3; y = 4 in x + y
06:58:16 <lambdabot>   7
07:00:07 <S_J> > let (<+++>) xs = map (+3)  xs in <+++> [1,2,3]
07:00:08 <lambdabot>   <hint>:1:34: parse error on input `<+++>'
07:00:15 <S_J> > let (<+++>) xs = map (+3)  xs in (<+++>) [1,2,3]
07:00:16 <lambdabot>   [4,5,6]
07:01:04 <startling> Zenol, have {-# Language TemplateHaskell #-} at the top of the file and makeLenses ''App
07:01:32 <merijn> startling: Shouldn't it be capitalised? i.e. LANGUAGE
07:01:41 <startling> merijn: it doesn't have to be
07:01:52 <merijn> hmm, apparently you're right
07:01:53 <startling> I think it looks nicer without. :)
07:02:28 <osa1> :set +t works but :set -t fails with "unrecognized flag" ?
07:03:17 <osa1> ahh, unset +t
07:03:26 <merijn> ugh
07:03:35 <merijn> Naming things sucks...
07:03:51 <Fuuzetsu> yep
07:04:00 <Shou> ;_;
07:04:34 <Fuuzetsu> @define data Hole = Hole
07:04:35 <lambdabot>  Defined.
07:04:50 <Fuuzetsu> :t (undefined :: Hole) <*> [1, 2, 3]
07:04:51 <lambdabot>     Couldn't match expected type `[a0 -> b0]' with actual type `Hole'
07:04:51 <lambdabot>     In the first argument of `(<*>)', namely `(undefined :: Hole)'
07:04:51 <lambdabot>     In the expression: (undefined :: Hole) <*> [1, 2, 3]
07:05:31 <startling> :t ?hole <*> [1, 2, 3]
07:05:32 <lambdabot> parse error on input `?'
07:05:35 <startling> aw
07:06:08 <Fuuzetsu> startling: ?hole is a thing now? It used to be ‘_’ (-XTypeHoles) last time I checked
07:06:37 <hpc> :t undefined :: ?hole
07:06:37 <lambdabot> parse error on input `?'
07:06:39 <startling> Fuuzetsu, it's -XImplicitParams syntax
07:06:51 <hpc> seems to not be enabled for el bot
07:06:53 <startling> it usually works fine as a hole.
07:10:32 <FreeFull> :t _3
07:10:33 <lambdabot> (Functor f, Field3 s t a b, Indexable Int p) => p a (f b) -> s -> f t
07:10:34 <FreeFull> :t _a
07:10:35 <lambdabot>     Not in scope: `_a'
07:10:35 <lambdabot>     Perhaps you meant one of these:
07:10:35 <lambdabot>       `a' (imported from Debug.SimpleReflect),
07:10:39 <FreeFull> :t a_
07:10:40 <lambdabot>     Not in scope: `a_'
07:10:40 <lambdabot>     Perhaps you meant one of these:
07:10:40 <lambdabot>       `a' (imported from Debug.SimpleReflect),
07:10:42 <FreeFull> :t _a_
07:10:42 <lambdabot>     Not in scope: `_a_'
07:10:42 <lambdabot>     Perhaps you meant `_at' (imported from Control.Lens)
07:11:57 <startling> I love reader. It's so nice.
07:24:34 * hackagebot hakyll 4.3.3.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.3.3.0 (JasperVanDerJeugt)
07:29:06 <Zenol> startling: And how do you get a lens?
07:29:26 <Zenol> startling: In a Handler App App () monad.
07:31:36 <Zenol> I give up, let's use StateT's methods.
07:31:54 <hpc> haha
07:34:13 <sm> morning all. Has anyone got a script to clean out all old package versions from .cabal/.ghc ?
07:34:32 <merijn> Is it bad style to define a newtype just to define an alternative Binary/Serialize instance for some data?
07:35:00 <hpc> sm: pick a small set of packages that you want at X versions, then empty .cabal and .ghc, then install just those
07:35:08 <hpc> and then install your personal projects
07:36:37 <hpc> cabal's version unification will do the rest, generally
07:37:14 <sm> I guess, I was hoping for a quicker less disruptive way to save some disk space
07:37:24 <hpc> ah
07:37:26 <hpc> hmm
07:37:32 <hpc> how much space is it taking up?
07:37:59 <sm> it seems to be all ~/.cabal/lib actually, about 2G in there
07:38:04 <hpc> yikes
07:38:30 <sm> I can easily remove */ghc-7.6.2 for a start
07:38:35 <hpc> ... i have a package called scheeeeeme-0.1
07:38:47 <hpc> or something
07:38:54 <hpc> that folder is in my .caba/lib
07:39:49 <bscarlet> merijn: If the newtype actually describes what's different about the serialization, I would think that to be quite reasonable.
07:39:49 <cschneid> without going into something fancy like lenses, is there a way to update a single field of a record-style data?
07:40:09 <cschneid> ie, "keep this the same, except swap field x's value from [] to [1]."
07:40:15 <edkk> foo f = f { field = [1] }
07:41:39 <cschneid> ahh, the data that comes in has a sorta-record-syntax of its own, allowing field update.  Thank you
07:52:09 <applicative> sm if you have .cabal/config set to build documentation, get rid of the haddocks too
07:54:37 <FreeFull> Seems like the first version of GHC I ever used was 7.4.2
08:01:18 <merijn> cschneid: "f { ... }" is basically "return a copy of f with the fields specified in ... changed"
08:01:32 <cschneid> merijn: right. Which ended up working perfectly
08:20:45 <kqr1> can you set ghci interactive options (like +t) through the command line when you start ghci?
08:20:59 <quchen> Is there some version of HLint that works with LambdaCase, or can I enable it somehow? `hlint -X` doesn't work :-/
08:22:47 <merijn> kqr1: You can have a .ghci file with commands that get run when you start ghci
08:22:56 <kqr1> merijn, that's good enough, thanks
08:31:29 <kqr1> am I using an old version of ghc if it seems I am suffering from this bug: http://ghc.haskell.org/trac/ghc/ticket/7509
08:31:46 <kqr1> (i'm not sure I'm reading the issue tracker properly)
08:31:57 <sm> kqr1: easier way to know: ghc --version :)
08:32:18 <kqr1> oh yeah
08:32:29 <kqr1> i just realised my ghc version is pretty old
08:32:42 <sm> 6.12 ?
08:32:58 <kqr1> nah, 7.4 ish
08:33:07 <kqr1> but i assumed 7.6 at least
08:33:08 <sm> oh that's not so bad
08:33:23 <kqr1> bad enough to be suffering from a fixed bug! not always i get to experience that
08:34:35 * hackagebot vhd 0.2.2 - Provides functions to inspect and manipulate virtual hard disk (VHD) files.  http://hackage.haskell.org/package/vhd-0.2.2 (VincentHanquez)
08:44:37 <Kaini> It might be, that I am blatantly ignorant - but why isn't liftA2 called zipWith?
08:45:45 <startling> Kaini, because that name is already taken.
08:46:21 <applicative> Kaini: it doesn't work like zipWith in most cases
08:46:37 <elliott> because it differs even for the [] instance
08:46:41 <elliott> > zipWith (,) [1,2,3] [4,5,6]
08:46:42 <startling> (that too; you want the ZipList applicative if you want zipwith-like behavior)
08:46:42 <lambdabot>   [(1,4),(2,5),(3,6)]
08:46:46 <elliott> > liftA2 (,) [1,2,3] [4,5,6]
08:46:47 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
08:47:07 <applicative> I wonder if parallel list comprehensions are awake
08:47:12 <startling> > liftA2 (,) (ZipList [1, 2, 3]) (ZipList [4, 5, 6])
08:47:13 <lambdabot>   No instance for (GHC.Show.Show
08:47:13 <lambdabot>                     (Control.Applicative.Zip...
08:47:23 <startling> > getZipList $ liftA2 (,) (ZipList [1, 2, 3]) (ZipList [4, 5, 6])
08:47:24 <lambdabot>   [(1,4),(2,5),(3,6)]
08:47:38 <applicative> > [x + y | x <- [1..10] | x <- [100,200..1000]]
08:47:39 <lambdabot>   Unexpected parallel statement in a list comprehension
08:47:39 <lambdabot>  Use -XParallelListCo...
08:47:41 <applicative> bah
08:47:55 <Kaini> Wait what exactly does liftA2 do?
08:48:02 <startling> @src liftA2
08:48:02 <lambdabot> liftA2 f a b = f <$> a <*> b
08:48:07 <Kaini> I think I don't understand what it does :D
08:48:10 <applicative> for lists, it goes through all combinations
08:48:17 <startling> Kaini, do you understand what (<*>) is?
08:48:20 <banister> applicative: do you ever use Alternative
08:48:23 <startling> :t (<*>)
08:48:24 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:48:27 <applicative> for the first element of xs it goes through all ys, then etc
08:48:31 <banister> also why is it called Alternative?
08:48:46 <Kaini> Yes, i think i know <*>... maybe
08:48:50 <applicative> > [1,2] <|> [3,4]
08:48:51 <lambdabot>   [1,2,3,4]
08:49:06 <Kaini> So, the Applicative defines, what liftM2 does?
08:49:06 <applicative> > [1,2] <|> []
08:49:07 <lambdabot>   [1,2]
08:49:11 <Kaini> and for lists it is all combinations
08:49:16 <applicative> Kaini: what liftA2 does
08:49:28 <startling> banister, one application (ha) of (<|>) is parsing with the first parser and, if it doesn't match, using the second instead
08:49:30 <applicative> Kaini: if the Applicative instance is 'ziplike', it will be a zipwith
08:49:59 <startling> Kaini, the problem is that there are two valid (<*>) for lists
08:50:21 <applicative> and for all treelike structures
08:50:28 <banister> startling: cool dude, thanks
08:50:47 <startling> the first is the same as the monad instance, i.e. "apply every function in the first argument list to everything in the second argument list"
08:51:25 <startling> the second is "apply every function in the first argument list to the corresponding element of the second argument list"
08:51:45 <Kaini> I think i got it
08:51:52 <Kaini> but for Maybe there is only one valid implementation, i guess
08:52:48 <startling> Kaini, ZipList is a newtype around [a] with the latter Applicative instance
08:53:09 <startling> (btw, I think there may be more than one valid instance for Maybe, too...)
08:55:00 <applicative> @set -XParallelListComp
08:55:01 <quchen> startling: Funny, I just thought about how that would look like.
08:55:22 <startling> it'd look like the Monoid instance, presumably
08:55:26 <applicative> > [(x,y) | x <- "abc" | y <- [1,2,3]]
08:55:26 <quchen> startling: It's probably one of those cases that makes you go "why didn't I come up with that" when someone tells you about it.
08:55:27 <lambdabot>   Unexpected parallel statement in a list comprehension
08:55:27 <lambdabot>  Use -XParallelListComp
08:55:39 <applicative> :(
08:55:49 <startling> quchen: oh, ZipList?
08:56:00 <quchen> startling: No, Maybe #2.
08:56:04 <startling> oh, right
08:56:12 <nicoo> > [(x,y) | x <- "abc", y <- [1,2,3]]
08:56:13 <lambdabot>   [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
08:56:19 <nicoo> startling: ^
08:56:35 <startling> the reason I thought of it was that I always use the Monoid instance when I wantto use the Alternative instance. >.>
08:56:42 <quchen> I mean there aren't many way of implementing join for Maybe, I don't think there's a second instance. For lists of length 1, both Applicatives are identical as well, and Maybe is kind of a length-0-1-list.
08:57:04 <applicative> there cant be another monad instance
08:57:18 <applicative> if there are more than one, it is some symmetry
08:57:21 <quchen> applicative: That's what my gut tells me too. :-)
08:58:19 <applicative> functor instances are unique
08:58:34 <quchen> Up to isomorphism I assume
08:59:00 <applicative> I think not, in the case of Functor
08:59:09 <applicative> but I'm forgetting the usual argument.
08:59:23 <quchen> Just think of Either, with fmap mapping over Left or Right
08:59:58 <monochrom> that is not fair. it's a bifunctor.
09:00:32 <quchen> "Needs to be fair" is not a mathematical axiom. :-P
09:01:00 <quchen> monochrom: The talk about Bifunctors got me thinking whether that may be the best solution to the discussion on the mailing lists right now.
09:01:24 <applicative> http://www.haskell.org/pipermail/libraries/2011-February/015704.html quchen
09:01:45 <portnov1> hi all
09:01:47 <ozgura> quchen: what do you mean? 'Either' cannot be an instance of functor. it has the wrong kind
09:01:48 <applicative> quchen: yes Either is a mathematic functor either way, yes
09:02:01 <applicative> hi portnov1
09:02:09 <portnov1> anyone working with conduits?
09:02:16 <ozgura> `Either a` has the correct kind, and that has a single Functor instance
09:02:20 <ozgura> I believe
09:02:41 <portnov1> I want a function like "concat" :: [Source m o] -> Source m o
09:02:50 <portnov1> is there such a function?
09:03:07 <quchen> ozgura: Oh, right.
09:03:16 <startling> portnov1: does Source have an Alternative instance?
09:03:20 <quchen> ozgura: That happens when you leave the type parameters away too often.
09:03:59 <quchen> applicative: Thanks for the proof. I'll just trust the free theorem as usual.
09:04:04 <portnov1> startling: no. And I do not see how it might help...
09:04:27 <portnov1> I want a source, which will output all from 1st source, then all from 2nd, and so on
09:04:47 <startling> Right. Presumably if it had an Alternative instance, (<|>) would do it.
09:05:27 <quchen> Depends on what Source is (I'm not familiar with Conduit). How do you chain Sources together? That would just make it a foldr.
09:05:40 <quchen> foldr chainSource nullSource <list>
09:06:37 <applicative> @type sequence
09:06:38 <lambdabot> Monad m => [m a] -> m [a]
09:06:43 <startling> (=$=), I think.
09:09:32 <hpaste> dmj pasted “snap ffi issue” at http://lpaste.net/91714
09:10:26 <dmj`> Any idea why snap internal code won't load into ghci with that check?
09:11:59 <notdan> dmj`: I think MIN_VERSION_ is a cabal thing
09:12:12 <applicative> dmj`: Is this the clang preprocessor problem?
09:12:37 <notdan> dmj`: yeah, it's a CPP macro set by cabal
09:12:59 <startling> I hate when code won't run in ghci for stupid reasons like that.
09:13:22 <notdan> That is the reason; I am actually not sure how to make it load with ghci. You can try running `ghci -DMIN_VERSION_base(4,6,0)`
09:13:28 <applicative> ah
09:13:30 <notdan> startling: but this is not a stupid reason
09:13:35 <startling> notdan, sure it is
09:13:57 <startling> you should be expected to have an #ifdef there
09:14:23 <notdan> Ah
09:14:25 <dmj`> startling: oh, ifdef compiled it
09:14:38 <notdan> Yeah ifdef is probably better
09:14:48 <dmj`> startling, dan: nice thanks
09:14:52 <notdan> and it's supposed to play well with Cabal too ithink
09:19:08 <dmj`> I'm assuming ghci doesn't play well with the ffi either. Trying to load "set_c_locale" from cbits, or can I explicitly reference ffi c functions with ghci?
09:19:17 <dmj`> foreign import ccall unsafe "set_c_locale" :: set_c_locale :: IO ()
09:19:34 <dmj`> During interactive linking, GHCi couldn't find the following symbol: set_c_locale
09:19:56 <dmj`> -X set_c_locale
09:20:17 <dmj`> I'll just go read RWH
09:20:49 <startling> dmj`, you need to give a parameter to ghci to link
09:21:23 <dmj`> startling: before ghci starts, or can I do during?
09:22:06 <startling> not sure
09:22:47 <startling> looks like before: http://ghc.haskell.org/trac/ghc/ticket/3658
09:22:56 <startling> oh, no,that's something else
09:23:06 <paolino> hello, there is no elemBy in Data.List, is there a reason for it ?
09:24:34 <startling> that is strange. you can do something like "any (== x)", though
09:24:48 <startling> oh, I guess "any" is "elemBy"
09:26:38 <paolino> :t any
09:26:39 <lambdabot> (a -> Bool) -> [a] -> Bool
09:28:20 <paolino> @pl \x -> any (f x) xs
09:28:23 <lambdabot> flip (any . f) xs
09:28:23 <lambdabot> optimization suspended, use @pl-resume to continue.
09:29:06 <paolino> thanks
09:30:41 <nicoo> @let fx f a = fx f (fa)
09:30:41 <lambdabot>  .L.hs:144:16:
09:30:42 <lambdabot>      Not in scope: `fa'
09:30:42 <lambdabot>      Perhaps you meant one of these:
09:30:42 <lambdabot>  ...
09:30:45 <nicoo> @let fx f a = fx f (f a)
09:30:46 <lambdabot>  Defined.
09:30:55 <nicoo> @pl fx
09:30:55 <lambdabot> fx
09:30:59 <nicoo> :(
09:31:48 <Meepy> Hello! I am trying to understand Monoids on http://blog.sigfpe.com/2009/01/haskell-monoids-and-their-uses.html but when I type "a `mappend` mempty` it says "Not in scope: `a`". How do I fix this?
09:32:11 <startling> Meepy, have you defined 'a'?
09:32:24 <Meepy> I am not sure how to instantiate a monoid
09:32:26 <Meepy> >.>
09:32:41 <startling> Meepy, there's no instantiating involved
09:32:55 <startling> Meepy, you just create a value of a type that is an instance of Monoid
09:33:06 <Meepy> Can you give an example?
09:33:09 <Meepy> I am lost :(
09:33:28 <startling> [a] is a monoid, so you can try "[1, 2, 3] `mappend` mempty"
09:33:33 <Meepy> hmm
09:33:38 <startling> > [1, 2, 3] `mappend` mempty
09:33:39 <lambdabot>   [1,2,3]
09:33:55 <Meepy> it works!
09:33:58 <Meepy> THANKS ^_^
09:34:11 <startling> Meepy: no problem. How are you learning haskell?
09:34:23 <nicoo> Meepy: Basically, "not in scope" means "not defined (in the current context)"
09:34:29 <Meepy> I understand that
09:34:46 <Meepy> but I am used that undefined means I need to instantiate it, and I cannot simply "instantiate a Monoid"
09:34:51 <Meepy> at least not in an imperative way
09:34:53 <nicoo> Well, GHC was complaining that the variable a wasn't defined.
09:35:08 <nicoo> Meepy: Yes you can : a <- []
09:35:24 <startling> Meepy, "instantiate" isn't a thing in haskell
09:35:36 <startling> nicoo, what? why would Meepy want to do that?
09:35:59 <nicoo> It's not "instantiate a Monoid" (whatever that means) but "define a with a type that has a Monoid instance"
09:36:00 <jmcarthur> Meepy: think of   a `mappend` mempty   as just a math expression. the 'a' is some variable that you have to plug in
09:36:40 <nicoo> startling: Perhaps I misunderstood what he was doing, then :(
09:37:32 <startling> Meepy, if you think typeclasses are anything like classes in other languages, unthink that!
09:37:50 <Meepy> I know they aren't, I simply wish to understand the reasoning behind it.
09:37:56 <nicoo> s/doing/saying/
09:38:01 <Meepy> they seem to be useful for generics.
09:38:28 <kwos> Guys any idea why this causes a compile error? http://lpaste.net/91715
09:38:30 <nicoo> Meepy: Basically, Monoid designated all types with associated mapend and mempty values
09:38:34 <nicoo> @src Monoid
09:38:34 <lambdabot> class Monoid a where
09:38:34 <lambdabot>     mempty  :: a
09:38:34 <lambdabot>     mappend :: a -> a -> a
09:38:34 <lambdabot>     mconcat :: [a] -> a
09:38:38 <Meepy> I can't figure out a reason why I'd want a Monoid over a function :\
09:39:09 <startling> Meepy, that's not even a thing that makes sense to say, sorry
09:39:17 * nicoo doesn't get what Meepy means :'(
09:39:24 <Meepy> I know it isn't i'm still learning to express myself >:(
09:39:34 <Meepy> sorry
09:39:44 <startling> Meepy, Monoid is a typeclass. Certain types are monoids. One of these types is "list of As" for any type A.
09:39:47 <kwos> "Language not only shapes the way we think, but determines the things that we can thing about"
09:39:50 <kwos> :_
09:40:06 <startling> > [1, 2, 3] `mappend` [4, 5] -- Meepy, so we can mappend two lists
09:40:07 <lambdabot>   [1,2,3,4,5]
09:40:23 <startling> > mempty :: [Int] -- Or we can find a 'mempty' for lists.
09:40:24 <lambdabot>   []
09:40:33 <notdan> kwos: I think the reason behind that is that gmapQ is supposed to take a function of a different type
09:40:36 <quchen> Is there a standard library for cyclic data structures, i.e. ring memory? I need to cache previously sent requests so they can be ignored if they come in a second time, but I don't want to store them forever for memory reasons.
09:40:38 <notdan> @ty gmapQ
09:40:39 <lambdabot> Data a => (forall d. Data d => d -> u) -> a -> [u]
09:40:55 <notdan> there is no (Show d) constraint
09:41:03 <startling> Meepy, Monoid is useful since we can have code that works for any Monoid
09:41:10 <kwos> notdan: it works if I do something like showConstr . toConstr $ x
09:41:20 <startling> Meepy: for example, Map k v is also a monoid
09:41:30 <notdan> hm
09:41:46 <kwos> notdan: well that doesn't use Show
09:42:05 <startling> > M.fromList [("key", "value")] `mappend` M.fromList [("other", "value")] -- Meepy, so we can mappend Maps, too
09:42:06 <lambdabot>   fromList [("key","value"),("other","value")]
09:42:58 <startling> Meepy: the value of this is that we can write code using only "mempty" and "mappend" and then use it for any Monoid that we ever want to use it on
09:43:33 <startling> "mconcat" is a function defined in terms of those that takes a list of things and "mappends" them to each other in order.
09:43:36 <startling> so we can do
09:43:52 <startling> > mconcat [[1], [2, 3], [4]]
09:43:53 <lambdabot>   [1,2,3,4]
09:43:54 <notdan> I don't know, sorry
09:44:39 <startling> > mconcat [M.fromList [("key", "value")], M.fromList [("other", "value")]] -- Meepy: and we can also mconcat some Maps together
09:44:40 <lambdabot>   fromList [("key","value"),("other","value")]
09:45:13 <Meepy> Having trouble wrapping my head around it >.>
09:45:43 <startling> Meepy: it is sort of atypical. You might want to start at a more beginnery place
09:45:51 <startling> @where lyah -- this is a good one
09:45:51 <lambdabot> http://www.learnyouahaskell.com/
09:46:19 <Meepy> I have, i've been on haskell for around a year now
09:46:37 <Meepy> I even tried reading McLane once
09:46:46 <startling> heh
09:46:49 <Meepy> I got stuck at him saying cartesian product is a functor
09:46:59 <Meepy> which ended up killing a few days in itself
09:47:07 <monochrom> McLane has a Haskell book?!
09:47:07 <quchen> That doesn't sound like a Haskell tutorial.
09:47:10 <Meepy> and i still got no idea what a functor is
09:47:20 <Meepy> I want to understand the terminology :|
09:47:21 <applicative> haha
09:47:23 <startling> Meepy, if you're interested in monoids, a basic algebra textbook would be the place. :)
09:47:34 <quchen> @quote quchen category
09:47:34 <lambdabot> quchen says: Requiring category theory for writing Haskell is like requiring automata theory to use C.
09:47:41 <monochrom> that is a rabbit hole and XY problem
09:47:59 <notdan> http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
09:48:06 <rmyers> does anyone have a minute to look at what i might be doing wrong here?
09:48:09 <NemesisD> i was hoping you guys could help me spot whatever i'm doing wrong with configurator: IOException (FilePath "/home/michael/src/mine/vigilance/test/fixtures/empty_config.conf": openFile: does not exist (No such file or directory))
09:48:16 <startling> Meepy: anyway, if you're so hung up on typeclasses, don't worry about them for now. by using them, you'll get used to them.
09:48:21 <NemesisD> ls  ls /home/michael/src/mine/vigilance/test/fixtures/empty_config.conf: finds it
09:48:30 <quchen> rmyers: Don't ask to ask, ask.
09:48:31 <Meepy> I really wish I could understand why I want to use a Monoid
09:48:36 <rmyers> i'm trying to emulate the head command "http://lpaste.net/91716"
09:48:40 <Meepy> each time I end up thinking of a function that does the same thing
09:48:43 <Meepy> but takes more typing
09:48:44 <rmyers> yeah, i wasn't, just broken into 2 lines.
09:49:15 <startling> Meepy, less conceptual overhead is one reason.
09:49:20 <applicative> Meepy well maybe you don't want the monoid abstraction
09:49:34 <applicative> Meepy: one reason we need it is because of monoid constraints on other things
09:49:47 <startling> Meepy: if I have something that I know is a monoid, I don't need to remember the name of the function that combines two things.
09:49:51 <applicative> > "hello" <> " " <> "world"
09:49:51 <lambdabot>   "hello world"
09:49:58 <startling> ^ right
09:50:00 <startling> and also
09:50:06 <startling> > [1, 2, 3] <> [4, 5]
09:50:07 <lambdabot>   [1,2,3,4,5]
09:50:27 <monochrom> monoid just means the binary operator is associative (e.g., (x ++ y) ++ z = x ++ (y ++ z)) and has an identity (e.g., [] ++ x = x, x ++ [] = x, [] is the identity here). THE END
09:50:28 <startling> Meepy: so in some ways it's an overloading mechanism
09:50:42 <Meepy> Is Monoid a functor?
09:50:46 <monochrom> no
09:50:49 <Meepy> T_T
09:50:53 <startling> Meepy: that's not a question that makes sense
09:50:55 <applicative> No, individual types are 'Monoids'
09:51:01 <startling> at least in haskell
09:51:18 <applicative> though the monoid instance is frequently defined for all lists, all maybes etc
09:51:32 <Meepy> all haskell types are monoids?
09:51:36 <startling> no.
09:51:36 <monochrom> no
09:51:37 <notdan> no
09:51:38 <Meepy> ugh
09:51:48 <Meepy> is Num a monoid?
09:51:49 <applicative> Meepy: monoid is a pretty constraint, so you can do it with almost any of them
09:51:54 <monochrom> no
09:51:55 <notdan> Meepy: Num is not a type
09:51:55 <applicative> Num isn't a type
09:51:58 <startling> Meepy: no, Num is another typeclass
09:52:04 <Meepy> is Integer a monoid?
09:52:10 <notdan> Well, kinda
09:52:11 <Fuuzetsu> under adition
09:52:15 <applicative> but if n is a Num type, Sum n is a monoid, as is Product n
09:52:16 <startling> Meepy, let's stop playing the guessing game
09:52:23 <notdan> not by itself
09:52:24 <Meepy> Sorry :|
09:52:26 <monochrom> Integer gives at least two monoids. using +, using *
09:52:49 <applicative> > let one :: Integer ; one = 1 in getSum (one <> one <> one)
09:52:50 <lambdabot>   Couldn't match expected type `Data.Monoid.Sum a0'
09:52:50 <lambdabot>              with actual ...
09:53:05 <applicative> > let one :: Sum Integer ; one = Sum 1 in getSum (one <> one <> one)
09:53:05 <lambdabot>   3
09:53:06 <copumpkin> monochrom: and lots more!
09:53:08 <applicative> right
09:53:20 <Kaini> @pl \a b -> (a, sum b)
09:53:23 <lambdabot> flip ((.) . (,)) sum
09:53:23 <lambdabot> optimization suspended, use @pl-resume to continue.
09:53:54 <monochrom> I'm just too lazy to invent more
09:53:55 <nicoo> Meepy: Most mathematical domains with an internal operator are monoids
09:54:18 <kwos> Is it possible to write a function that takes a value of any type and sort of flattens it out to a list of strings?
09:54:27 <notdan> Meepy: http://book.realworldhaskell.org/read/using-typeclasses.html http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
09:54:28 <monochrom> if you spend your time on math now, you will never get around to haskell
09:54:43 <applicative> kwos: that would be *so* wrong, that I'm sure it's possible
09:54:49 <notdan> I suggest you stop worrying about monoids for now and read about typeclasses in general
09:54:52 <startling> kwos, not sure what you mean. can you give an example input and output?
09:54:56 <kwos> applicative: why would it be wrong?
09:55:10 <moofy> ahoy
09:55:18 <kwos> say you have X { a :: Int, b :: Char, c :: String }
09:55:20 <applicative> moofy ahoy
09:55:22 <quchen> rmyers: It works for me.
09:55:54 <monochrom> Piaget's theory. concrete before abstract. specific before general. actual code before math.
09:55:59 <hpaste> quchen annotated “head.hs” with “head.hs (refactored annotation)” at http://lpaste.net/91716#a91717
09:56:02 <notdan> rmyers: probably a problem with a shell escaping?
09:56:03 <applicative> kwos or maybe just kwos _ = ["hello", "world"]
09:56:19 <kwos> I want to get ["1", "c", "string"] for X 1 'c' "string"
09:56:44 <rmyers> quchen: notdan: interesting, i'll look into that side of the problem. if the code is right, my job is done here. thanks!
09:56:47 <startling> kwos, that's not possible in general without metaprogramming. why do you want this?
09:56:52 <applicative> hm, how about unwords . show, kwos
09:56:55 <notdan> What if you have X { a :: IO (), b :: Int -> Int } ?
09:57:10 <kwos> applicative: similarly, if X had Y { d :: Double, e :: String } I'd like this also to be included...
09:57:25 <kwos> startling: I have a bunch of record types that I want to display as tables
09:57:25 <startling> :t unwords . show -- applicative
09:57:26 <lambdabot>     Couldn't match type `Char' with `[Char]'
09:57:26 <lambdabot>     Expected type: a0 -> [String]
09:57:26 <lambdabot>       Actual type: a0 -> String
09:57:41 <Meepy> Sorry for asking stupid questions, I am trying very hard to learn to make sense, it's hard to learn haskell without understanding the terminology. I end up asking things which make no sense to anyone including myself.
09:57:41 <applicative> sorry, words . show
09:57:43 <kwos> startling: I need a way of flattening them out, and ideally I'd like to do it automatically
09:58:14 <startling> kwos, you could have class Table x where table :: [x -> String]
09:58:26 <quchen> rmyers: You could add a "print args" after "args <- getArgs", that would show you if the argument parsing is somehow going wrong. Other than that I don't know where the error could come from.
09:58:34 <kwos> startling: but then I have to write it for each type
09:58:39 <startling> then you could do instance Table X where table = [a, b, c]
09:58:49 <startling> kwos, yes.
09:59:02 <zzing> Are there any alternatives to recursion / imperative loops that have been developed for looping? Theoretic interest. I recall an article not to long ago that looked like it represented looping in a separate way but I forget what it was.
09:59:03 <applicative> do your types all have Show instances kwos?
09:59:47 <kwos> applicative: yes
09:59:55 <startling> zzing, monad-loops , if that's what you're asking
10:00:02 <kwos> startling: http://lpaste.net/91718 <- this sort of gets there but doesn't use show instances
10:00:33 <rmyers> hmm, thanks. im using double quotes and \n in bash, does that sound right? print args looks good.
10:00:42 <seanparsons> As a cabal noob, I'm a bit baffled as to how leksah depends on gtksourceview3 but it doesn't appear to be part of the packages available to cabal.
10:00:46 <startling> zzing, I don't think that's what you're asking, though.
10:01:03 <startling> zzing, you might want to look at using a Nat eliminator for recursion
10:01:06 <paolino> learning haskell is hyperlinear but people on #haskell grows linearly
10:01:31 <rmyers> quchen: for example: ./head "one \n two \n three"
10:01:39 <zzing> I am going to see if I can find what I saw before, google isn't helpful for finding what a 'nat eliminator' is
10:01:39 <startling> paolino, joining #haskell does not require having finished learning haskell
10:01:40 <notdan> seanparsons: are you installing leksah from Hackage?
10:01:45 <seanparsons> I am.
10:01:56 <seanparsons> Sorry, no.
10:01:57 <dcoutts> seanparsons: I can only see a dependency on gtksourceview2 in the latest leksah version on hackage
10:02:25 <seanparsons> I've got the latest code from git as I wanted to check if something had been improved.
10:02:35 <paolino> startling , for other languages it's been the other way around
10:02:50 <dcoutts> seanparsons: then presumably you'll need to find the dev version of this gtksourceview3 too
10:03:04 <dcoutts> since as you can see, it's not on hackage yet
10:03:06 <startling> paolino: haskell is relatively hard to learn and #haskell is a nice place
10:03:16 <notdan> seanparsons: gtksourceview3 is in the darcs repo http://code.haskell.org/gtksourceview/
10:03:20 <NemesisD> ugh. how the hell do you turn classyprelude's FilePath into a string, i.e. the type that every haskell function operating on paths actually uses
10:03:26 <notdan> but I think it requires some patching
10:03:32 <moofy> All programming is hard to learn :/
10:03:38 <geekosaur> rmyers, bash interprets \ in double quoted strings
10:03:39 <notdan> ask on #leksah
10:03:43 <moofy> and it always makes you feel stupid
10:03:53 <zzing> startling, I got it from a c++ blog post about this: http://bartoszmilewski.com/2013/06/10/understanding-f-algebras/   I do not want to say that it is how I said, just how I remember it being put in the c++ article.
10:03:53 <seanparsons> notdan: Yeah, already on it.
10:03:54 <notdan> seanparsons: also you can skim the google group for more recent builds
10:03:56 <notdan> :)
10:03:59 <geekosaur> hm, no, actually, something different happened there. should have worked, then
10:05:01 <dcoutts> NemesisD: haddock docs say that classyprelude's FilePath is type String
10:05:59 <applicative> its really creepy how long it takes haskell-src-exts to compile
10:06:12 <zzing> applicative, creepy?
10:06:30 <applicative> it's amazingly long, you think its somehow stuck
10:06:42 <startling> zzing, anyway, you know Nat ?
10:06:45 <geekosaur> try compiling atlast sometime :)
10:06:48 <geekosaur> *atlas
10:06:55 <geekosaur> nice freudian typo :p
10:07:03 <zzing> startling, specifically no, I have seen the definition of natural numbers though.
10:07:13 <startling> zzing, right, that's what I'm talking about
10:07:19 <NemesisD> dcoutts: looks like the magic function was "unpack"
10:07:22 <startling> zzing, data Nat = Z | S Nat
10:07:32 <NemesisD> CanPack FilePath Char
10:07:39 <zzing> startling, that is just a church encoding isn't it?
10:07:57 <dcoutts> NemesisD: what package are you using? ClassyPrelude-0.1 ?
10:07:57 <startling> zzing, no. that's a constructive interpretation of Peano's axioms
10:08:14 <paolino> A list with nothing inside
10:08:47 <rmyers> geekosaur: i can't quite seem how to get them to intepret to new lines, with escaping or single quoting.
10:09:03 <startling> zzing, anyway, you can define an eliminator on this type Nat (in the same way that the function 'maybe' is an eliminator of Maybe a) of type "a -> (a -> a) -> Nat -> a"
10:09:10 <rmyers> quchen: what shell are you using? what test string did you use?
10:09:11 <geekosaur> in bash you need to use a bit of magic: $'foo\nbar'
10:09:14 <Fuuzetsu> I have some ‘#elif __GLASGOW_HASKELL__ == 707’ in source here, how are these numbers determined? What would current HEAD be?
10:09:37 * hackagebot cprng-aes 0.4.0 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.4.0 (VincentHanquez)
10:09:44 <startling> zzing, that is: f a _ O = a; f _ a' (S n) = a' $ f n;
10:09:51 <rmyers> geekosaur: oh wow, thanks, that worked.
10:09:53 <geekosaur> otherwise backslash-n will either pass through as those characters, or turn into just n, depending on whether bash is using \ for escape or not
10:10:19 <startling> zzing: sorry, s/O/Z
10:10:39 <applicative> well, I guess 2000 lines of types and instances in Language.Haskell.Exts.Annotated.Syntax are a good excuse for taking a while
10:10:47 <zzing> startling, intuition is weak, haven't had coffee yet.
10:10:50 <rmyers> geekosaur: i guess this little program is much more useful taking input from stdin then as an argument, since that escaping is kind of a pita.
10:10:58 <geekosaur> yep
10:11:00 <zzing> What does an eliminator do exactly?
10:11:13 <startling> zzing, "eliminate x f n" applies f to x n times
10:11:15 <luite> applicative: it also generates a scary amount of code for it
10:11:19 <rmyers> geekosaur: that shall be my next adventure. thanks.
10:11:51 <luite> applicative: i had to redo some parts of ghcjs for it, it used 20GB RAM at first, other modules mostly worked fine :)
10:14:32 <zzing> startling, ultimately I can't intuitively parse that function definition, would have towork out types
10:16:01 <startling> zzing, "eliminate x f 0 = x', 'eliminate x f 1 = f x', 'eliminate x f 2 = f (f x)' ...
10:20:30 <zzing> ok, that makes sense
10:21:02 <zzing> So you could make a factorial look potentially simpler. Is there any other useful things?
10:21:35 <startling> zzing, it turns out to be a general-purpose definition for finite recursion.
10:21:43 <zzing> hmm, very nice
10:22:01 <startling> (I guess infinite recursion, too, in haskell?)
10:22:36 <monochrom> yes if you first construct the infinite number. (how?)
10:23:05 <zzing> > 1/0
10:23:06 <lambdabot>   Infinity
10:23:32 <monochrom> that has the wrong type
10:23:40 <startling> > fix S Z
10:23:41 <lambdabot>   Not in scope: data constructor `S'Not in scope: data constructor `Z'
10:23:59 <startling> I guess that doesn't work though
10:24:10 <monochrom> fix S works, but you have to assume that someone gave you fix.
10:24:11 <startling> since you never get the "outermost' S
10:24:18 <startling> monochrom: yeah.
10:24:31 <applicative> hm, DeriveFunctor would get rid of about 400 lines of Language.Haskell.Exts.Annotated.Syntax
10:24:35 <startling> er, right, fix S was what I meant
10:24:58 <monochrom> if someone gave you fix, you would not be studying Nat elimination
10:26:51 <notdan> Fuuzetsu: current HEAD is 707
10:27:00 <notdan> ghc 7.7
10:27:59 <zzing> Simple question on associativity. Generally, if -> right associative, and we have a -> b -> c, according to an example on the simply typed lambda calculus wiki page, it becomes a -> (b -> c)   but I am not entirely certain how to apply this just by right / left /etc.
10:28:27 <notdan> apply that by right?
10:28:52 <monochrom> I don't understand the question.
10:29:38 <monochrom> operator precedence, right-associative, left-associative, associative are all excuses for omitting parentheses. THE END.
10:29:42 <geekosaur> zzing, the definition of right associative is that a * b * c for some right-associative * is a * (b * c)
10:30:13 <geekosaur> I am not sure what you mean by 'apply this', are you trying to figure out what to do with a -> (b -> c)?
10:30:49 <monochrom> and parenthesis is an excuse for not drawing a parse tree
10:30:52 <applicative> (a -> (b -> (c -> d))) makes it a little clearer why it's 'right'
10:31:31 <zzing> geekosaur, I think it is just doing the bracketing properly
10:31:44 <geekosaur> still not sure what you're asking...
10:32:28 <zzing> geekosaur, probably just have to remember the definition
10:32:48 <zzing> I have trouble remembering the exact way it goes
10:33:07 <startling> monochrom: sure. zzing was just asking about other ways to express recursion (presumably in haskell)
10:33:13 <geekosaur> applicative showed how you apply it in a chain a -> b -> c -> d
10:33:48 <zzing> startling, in haskell and generally
10:42:01 <manek> Hi! I feel this si simple question but I cannot find a very simple and "pure" solution: I've go a function f x = (x, g x), where g :: a -> (Maybe a) and I want f to be f:: a -> (Maybe (a,a)) (so I want to "lift" the Maybe over the tuple)
10:44:22 <NemesisD> grammatical question for you guys: i have a type Watch that has a few fields. I'm making a type that represents a subset of those fields that are user-specifiable. the remainder of the fields will be defaulted to form a Watch. does the name ProtoWatch make sense?
10:44:38 * hackagebot algebraic-classes 0.3 - Conversions between algebraic classes and F-algebras.  http://hackage.haskell.org/package/algebraic-classes-0.3 (SjoerdVisscher)
10:44:39 <c_wraith> :t let g x = Just x ; f x = (,) <$> g x in f
10:44:40 <lambdabot> a -> Maybe (b -> (a, b))
10:44:49 <c_wraith> err, oh, oops.
10:44:51 <c_wraith> darn those typos
10:44:57 <c_wraith> :t let g x = Just x ; f x = (,) x <$> g x in f
10:44:57 <lambdabot> a -> Maybe (a, a)
10:45:05 <c_wraith> manek: ^
10:45:08 <merijn> :t let f x = fmap (x,) (g x) in f
10:45:08 <lambdabot> Illegal tuple section: use -XTupleSections
10:45:12 <merijn> aww
10:45:45 <merijn> Why no tuple sections in lambdabot :(
10:47:31 <manek> c_wraith: Thnak you! What does "in" do in Haskell? I see it for the first time I think
10:47:55 <c_wraith> manek: oh.  it's part of the syntax of let expressions.   let [decls] in [expr]
10:48:04 <Fuuzetsu> notdan: heh, that sucks for me… oh well, thanks
10:48:11 <c_wraith> manek: I only used it there so I could ask for the type of the function f specifically
10:48:15 <manek> c_wraith: hahaha oh of course - I'm sorry :D
10:49:55 <applicative> @type  (. readMaybe) . fmap . (,)
10:49:56 <lambdabot> Not in scope: `readMaybe'
10:49:59 <applicative> bah
10:50:05 <applicative> @type  (. Just) . fmap . (,)
10:50:06 <lambdabot> a -> a1 -> Maybe (a, a1)
10:50:47 <applicative> manek: ^^^ substituting g for Just -- to maximize perversity
10:51:45 <applicative> @type  join . (. Just) . fmap . (,)
10:51:45 <lambdabot>     Couldn't match type `(->) a0' with `Maybe'
10:51:45 <lambdabot>     Expected type: (Maybe a0 -> Maybe (a0, a0)) -> a0 -> a0 -> (a0, a0)
10:51:45 <lambdabot>       Actual type: (Maybe a0 -> Maybe (a0, a0)) -> a0 -> Maybe (a0, a0)
10:51:48 <applicative> ahahahaha
10:51:57 <applicative> @type  join $ (. Just) . fmap . (,)
10:51:58 <lambdabot> a -> Maybe (a, a)
10:53:22 <S_J> --loadStore p = readFile p >>= \s -> return $ SP.parseToStore s
10:53:22 <S_J> loadStore p = readFile p >>= SP.parseToStore
10:53:23 <S_J> why cant i do something like the 2nd? seems cumbersome to take value out and put it back in
10:55:33 <Fuuzetsu> loadStore p = readFile p >>= return . SP.parseToStore
10:55:51 <Fuuzetsu> in fact, I think there's even a combinator that will let you skip the return
10:56:27 <merijn> Fuuzetsu: Yes, fmap :p
10:56:51 <merijn> "x >>= return . f" is just "fmap f x"
10:56:51 <Fuuzetsu> :t flip ap
10:56:52 <lambdabot> Monad m => m a -> m (a -> b) -> m b
10:57:01 <Fuuzetsu> right
10:57:03 <applicative> > join ((. (Just . reverse)) . fmap . (,)) "Haskell"
10:57:04 <lambdabot>   Just ("Haskell","lleksaH")
10:57:27 <applicative> > let = Just . reverse in join ((. g) . fmap . (,)) "Haskell"
10:57:28 <lambdabot>   <hint>:1:5: parse error on input `='
10:57:37 <applicative> > let g = Just . reverse in join ((. g) . fmap . (,)) "Haskell"
10:57:38 <lambdabot>   Just ("Haskell","lleksaH")
10:57:57 <merijn> S_J: "(>>=) :: Monad m => m a -> (a -> m b) -> m b" so the function has to return an m something, if it doesn't you just want "fmap :: Functor f => (a -> b) -> f a -> f b"
10:58:31 <merijn> :t fmap
10:58:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:58:33 <merijn> :t liftM
10:58:34 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
10:58:38 <Fuuzetsu> a.k.a. <$>
10:58:45 <merijn> :t (<$>)
10:58:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:01:23 <FreeFull> mconcat, aka <>
11:01:40 <manek> applicative : Thank you! :)
11:01:45 <danno1> Noob Q;  I am running the SimpleJSON example
11:01:58 <FreeFull> > ap (,) reverse Haskell
11:01:59 <lambdabot>   Not in scope: data constructor `Haskell'
11:01:59 <danno1> with: ± % ghc -o simple Main.hs SimpleJSON.o
11:02:06 <FreeFull> > ap (,) reverse "Haskell"
11:02:07 <lambdabot>   ("Haskell","lleksaH")
11:02:17 <danno1> [1 of 2] Compiling SimpleJSON       ( SimpleJSON.hs, SimpleJSON.o )
11:02:17 <danno1> [2 of 2] Compiling Main             ( Main.hs, Main.o )
11:02:17 <danno1> Linking simple ...
11:02:17 <danno1> SimpleJSON.o:(.data+0x0): multiple definition of `__stginit_SimpleJSON'
11:02:17 <danno1> ./SimpleJSON.o:(.data+0x0): first defined here
11:02:34 <FreeFull> > pure . ap (,) reverse "Haskell" :: Maybe (String, String)
11:02:36 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe
11:02:36 <lambdabot>                             ...
11:02:38 <danno1> That is my result...I am using Linux
11:02:41 <FreeFull> > pure . ap (,) reverse $ "Haskell" :: Maybe (String, String)
11:02:42 <lambdabot>   Just ("Haskell","lleksaH")
11:03:51 <maurer> So, anyone familiar with aeson?
11:04:14 <maurer> When I try to do something that should be fairly simple, it eems to hang forever
11:04:18 <maurer> specifically
11:04:19 <maurer> Prelude> :m Data.Aeson
11:04:19 <maurer> Prelude Data.Aeson> encode $ toJSON 3
11:04:31 <maurer> Just prints
11:04:31 <maurer> "
11:04:37 <maurer> and then hangs indefinitely revving cpu
11:04:44 <maurer> encoding a 3 shouldn't be tricky
11:04:50 <merijn> What's the type of toJSON?
11:05:25 <Iceland_jack> maurer: Read "pitfalls" in Data.Aeson on Hackage
11:05:45 <kier> Would somebody be able to help me on a problem that might involve GADTs/type families, if that have a minute? https://gist.github.com/kierdavis/6201467
11:05:46 <Iceland_jack> Hackage> Note that the JSON standard only allows arrays or objects of things at the top-level.
11:06:07 <Iceland_jack> Hackage> >>> decode "1" ∷ Maybe Int
11:06:07 <Iceland_jack> Hackage> Nothing
11:06:21 <maurer> merijn: toJSON :: (ToJSON a) => a -> Value
11:06:36 <maurer> Iceland_jack: encode 1 also fails
11:06:51 <maurer> Iceland_jack: also this is an attempt to isolate a problem that happens when i try to encode it as part of an object
11:06:56 <maurer> original snipped looked more like
11:07:21 <maurer> encode $ object [(pack "test", toJSON 3)]
11:08:08 <merijn> kier: You probably want to add DataKinds
11:08:23 <jakening> anyone know how to fold a value to a list of its constructors?
11:08:37 <jakening> Seems like Data.Data provides the resources, but I'm not finding it easy to decipher
11:08:55 <merijn> kier: What was the error you got using type families?
11:09:17 <maurer> Iceland_jack: Also, that pitfall seems to only apply to decode, which is working just fine for me. It's encode which is hanging infinitely
11:09:18 <pentace> jakening: What if the constructors have different arities?
11:09:41 <jakening> what then?
11:09:59 <pentace> You can't have them in the same list then
11:10:06 <jakening> I can get a list of constructors, even if they have different arities, for a datatype
11:10:07 <pentace> > [Just, Nothing]
11:10:08 <lambdabot>   Couldn't match expected type `a0 -> Data.Maybe.Maybe a0'
11:10:08 <lambdabot>              with ...
11:10:22 <jakening> I'm imagining a list of Constr
11:10:30 <jakening> so I would think arity doesn't matter
11:10:42 <pentace> :t Constr
11:10:43 <lambdabot>     Not in scope: data constructor `Constr'
11:10:43 <lambdabot>     Perhaps you meant one of these:
11:10:43 <lambdabot>       `Const' (imported from Control.Applicative),
11:10:50 <S_J> can I catch exceptions? like if I open a file that does not exist?
11:11:00 <merijn> S_J: See Control.Exception
11:11:13 <jakening> :t dataTypeConstrs
11:11:13 <lambdabot> DataType -> [Constr]
11:11:13 <merijn> S_J: (So, yes)
11:11:48 <Hafydd> > dataTypeConstrs []
11:11:49 <lambdabot>   Couldn't match expected type `Data.Data.DataType'
11:11:49 <lambdabot>              with actual ...
11:11:55 <Hafydd> > dataTypeConstrs (typeOf [])
11:11:56 <lambdabot>   Couldn't match expected type `Data.Data.DataType'
11:11:56 <lambdabot>              with actual ...
11:11:57 <jakening> :t dataTypeConstrs (dataTypeOf (undefined::Int)
11:11:57 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
11:11:59 <kier> merijn: I'll have a look into DataKinds, and I've posted the error as a comment at https://gist.github.com/kierdavis/6201467#comment-884307
11:12:01 <jakening> :t dataTypeConstrs (dataTypeOf (undefined::Int))
11:12:01 <lambdabot> [Constr]
11:12:22 <Hafydd> > dataTypeConstrs (dataTypeOf [])
11:12:23 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
11:12:23 <lambdabot>    arising from a use ...
11:12:45 <applicative> > dataTypeConstrs (dataTypeOf ([]::[Int]))
11:12:46 <lambdabot>   [[],(:)]
11:13:04 <kier> merijn: argh, I've got to go; let me know if you come up with anything but it's not worth losing sleep over
11:13:07 <Hafydd> Great.
11:13:25 <hiptobecubic> simple puzzle here (http://vpaste.net/xXugS) that I think can be well solved with depth first search on a graph where nodes are stones reachable from neighbors, however it's in the "dynamic programming" puzzle set of the book I'm working in. How would it be modeled with DP?
11:13:40 <jakening> a list of Constr is enough; I can't see an immediate arity problem
11:14:33 <merijn> kier: Right, I suspect that the problem that you're running into is that you're "data One" and "data Twice a" let's Twice accept any type as argument
11:15:06 <FreeFull> > dataTypeConstrs (dataTypeOf (Nothing :: Maybe ()))
11:15:07 <lambdabot>   [Nothing,Just]
11:15:21 <merijn> kier_away: You can use DataKinds to restrict the type to Twice to only allow a specific type, that should remove the issue with the type family, I think?
11:17:33 <danno1> got it
11:18:11 <jakening> :t gunfoldl
11:18:12 <lambdabot>     Not in scope: `gunfoldl'
11:18:12 <lambdabot>     Perhaps you meant one of these:
11:18:12 <lambdabot>       `gunfold' (imported from Data.Data),
11:18:15 <jakening> :t gunfold
11:18:47 <jakening> :t gunfold
11:18:49 <jakening> ...
11:19:03 <Enigmagic> no types for you.
11:19:26 <jakening> The question, I suppose, kind of comes down to what in the world is gunfold and gfoldl?
11:20:32 <Enigmagic> i find the newer ghc.generics easier to understand. i've never managed to use gunfold and the like for anything useful.
11:20:45 <jakening> > gmapQ (id) ([]_
11:20:46 <lambdabot>   <hint>:1:16:
11:20:46 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
11:20:47 <jakening> > gmapQ (id) ([]_
11:20:48 <lambdabot>   <hint>:1:16:
11:20:48 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
11:20:49 <jakening> > gmapQ (id) ([])
11:20:50 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
11:20:50 <lambdabot>    arising from a use ...
11:22:43 <jakening> Enigmagic: any clue how to dig into constructors with ghc.generics?
11:24:53 <Enigmagic> jakening: instance match on C1... what sort of info do you want?
11:26:05 <jkff> Hey folks. Is there a way to profile what types of objects a haskell program is allocating? Heap profiling doesn't do, because it only gives me types of *live* objects - but I'm interested in the breakdown of my huge allocation churn rate
11:26:23 <jkff> I have very low residency but very high allocation/sec rate
11:27:48 <jakening> So suppose I have an Expr datatype for simple lambda calculus parsing
11:28:09 <maurer> OK, now I'm super confused. To figure out what was going on, I grabbed a copy of the aeson source and loaded up data.aeson and data.aeson.encode in it, then invoked fromValue $ toJSON 3
11:28:14 <maurer> and it just worked
11:28:34 <jakening> Given an Expr, I'd like to get a list of subterm Constructors, without exhaustively pattern matching
11:28:34 <maurer> If I load up ghci normally, and load those modules, it does not
11:28:48 <jakening> (because pattern matching gets dull)
11:28:51 <maurer> I've already tried uninstallinga nd reinstalling aeson
11:29:09 <geekosaur> maurer: try ":set -XNoMonomorphismRestriction"
11:29:35 <zvrba> i have a complaint/question about haskell documentation
11:29:39 * hackagebot HTab 1.6.3 - Tableau based theorem prover for hybrid logics  http://hackage.haskell.org/package/HTab-1.6.3 (GuillaumeHoffmann)
11:29:51 <geekosaur> oh, I see there is actually scrollback to be found somewhere...
11:29:53 <zvrba> for example: Data.Either. the webpage just says instance Monad (Either e)
11:30:06 <zvrba> but the monadic semantics of Either is nowhere explained
11:30:17 <zvrba> how is one supposed to find out about it? read the source?
11:30:24 <merijn> @where mmr
11:30:24 <lambdabot> I know nothing about mmr.
11:30:24 <merijn> @where dmr
11:30:24 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:30:38 <merijn> jkff: Extreme numbers of allocations are quite common in haskell
11:31:09 <jkff> merijn: yes I know, but I'm trying to optimize a function to make sure it doesn't allocate
11:31:22 <jkff> Well, actually it's quite evident from its core, but maybe profiling would reveal even more
11:31:24 <S_J> I never thought about the fact that you could view a whole computer program as a function. Seems bovious but... And powerful.
11:32:14 <merijn> zvrba: I think there's really only one way to implement the semantics for Either?
11:32:19 <maurer> geekosaur: still hangs
11:32:34 <merijn> zvrba: It's quite similar to Maybe
11:32:36 <Enigmagic> jakening: hang on a sec
11:32:58 <geekosaur> yeh, when I found the scrollback I discovered it was a hang and not a type error you were complaining about. hangs *could* be a result but not a common one if the DMR were involved
11:33:02 <merijn> zvrba: "(>>=) :: Either e a -> (a -> Either e b) -> Either e b", I can only think of one implementation
11:33:21 <zomg> Has anyone ever built a proxy into a WAI based app? Eg. have /whatever/path to act as a proxy based on some parameters
11:33:27 <merijn> zvrba: Well, two, if you count returning "undefined"
11:33:38 <zomg> I'm looking at the http-proxy package which might do the trick but it looks like it's mostly intended to work as a stand-alone proxy
11:34:14 <maurer> geekosaur: I mean, there's no type error, and if I manually load the library as .hs files instead of a sthe cabal installed chunk, it seems to work
11:34:26 <maurer> geekosaur: Right now I'm trying to figure out why the 'package' would be different
11:34:26 <zvrba> merijn: that doesn't substitute for documentation
11:35:19 <maurer> And in fact, if I build aeson's tests and run them, that hangs too
11:35:44 <geekosaur> interesting
11:37:01 <merijn> zvrba: True, I just think no one thought it important enough to document. I'm sure that pull requests with improved documentation will be very welcome
11:37:07 <zomg> Welp, I suppose I'll just do a http request based on the params in my WAI handler, since this is going to be limited in its functionality rather than a full proxy anyway
11:37:51 <merijn> Is there a variant of error that reports filename + line number?
11:39:05 <Enigmagic> jakening: https://gist.github.com/NathanHowell/6201625
11:39:48 <Enigmagic> jakening: you can use a similar technique to actually construct values too.
11:39:55 <edwardk> :t Control.Exception.assert
11:39:56 <lambdabot> Bool -> a -> a
11:40:01 <geekosaur> merijn, http://new-hackage.haskell.org/package/file-location ?
11:40:30 <geekosaur> although I note it's TH-y
11:40:46 <geekosaur> (suppose that's inescapable given the constraints)
11:41:06 <merijn> edwardk: hmm, I wanted "String -> a"
11:41:10 <edwardk> merijn: you could catch the Assertion failed that comes out of there and refine the string with your message
11:41:19 <merijn> geekosaur: That's ok, as long as it doesn't increase compile time too much
11:41:35 <luite> hmm, but it won't throw if you compile with optimization
11:41:45 <merijn> edwardk: I just want something that's more traceable/reliable then "undefined" for unfinished code :p
11:41:56 <merijn> luite: Don't care, this is for "todo" type things
11:42:16 <merijn> There shouldn't be any in the final code anyway, undefined is just so much harder to track
11:42:21 <geekosaur> the other alternative would be something cpp(hs)-based, with error being a macro using __FILE__ and __LINE__
11:42:31 <edwardk> >>> mapException (\(AssertionFailed s) -> AssertionFailed (init s ++ " but it was awesome")) (assert False undefined)
11:42:33 <edwardk> *** Exception: <interactive>:13:91-96: Assertion failed but it was awesome
11:43:03 <edwardk> the problem is of course, that calling 'assert' in there causes it to take _that_ location ;)
11:43:09 <edwardk> so the better path is to use #define
11:43:26 <notdan> geekosaur: this actually appears to be more sound at first thought
11:44:02 <notdan> TypeHoles from HEAD are great, but I wish I could defer them to runtime
11:44:14 <jakening> Enigmagic: thanks - don't know much about Data.Proxy, so might need a sec with this
11:44:19 <edwardk> #define ERROR(e) error (show __FILE__ ++ ":" ++ show __LINE__ ++ ":" ++ e)
11:44:20 <merijn> edwardk: Thanks, that'll probably be best :)
11:44:20 <edwardk> or some such
11:44:35 <edwardk> with appropriate prophylactic parens, etc.
11:44:45 <Enigmagic> jakening: i'm just using Data.Proxy instead of 'undefined :: f a'... it's not required
11:44:56 <edwardk> merijn: in vector they use something like:
11:44:58 <edwardk> #define BOUNDS_CHECK(f) (Ck.f __FILE__ __LINE__ Ck.Bounds)
11:45:14 <edwardk> to call a function from some module of checks with the file and line as arguments and say why
11:45:23 <elliott> Enigmagic: "Proxy r ->" is an antipattern btw
11:45:36 <elliott> er "Proxy f"
11:45:41 <elliott> you should use "proxy f ->"
11:45:49 <edwardk> in general using proxy r -> .. instead of Proxy r -> … is better
11:45:59 <Enigmagic> elliott: ok, when did this change?
11:46:11 <elliott> since edwardk realised you could do it, I guess :P
11:46:14 <edwardk> you want to return 'Proxy', accept 'proxy'
11:46:29 <edwardk> that way if you have something like [a]   you can pass it to the function that wants any proxy a
11:46:34 <Enigmagic> oh sure.
11:46:52 <edwardk> it greatly cleans up use sites
11:47:30 <Enigmagic> edwardk: ok, i fixed the gist.
11:48:00 <edwardk> data M a s = M a   -- instance Reifies s (Monoid_ a) => Monoid (M a s) where mappend m@(M a) (M b) = M (mappend_ (reflect m) a b)   ...
11:48:06 <edwardk> is much easier than using scoped variables, etc.
11:48:14 <Enigmagic> yeah i get it
11:48:31 <Zenol> :t (5::Int)
11:48:32 <lambdabot> Int
11:48:38 <Zenol> :info MaybeT
11:48:55 <Zenol> :t undefined :: MaybeT IO
11:48:55 <lambdabot>     Not in scope: type constructor or class `MaybeT'
11:48:55 <lambdabot>     Perhaps you meant `Maybe' (imported from Data.Maybe)
11:49:14 <edwardk> :t undefined :: MaybeT IO ()
11:49:14 <lambdabot>     Not in scope: type constructor or class `MaybeT'
11:49:14 <lambdabot>     Perhaps you meant `Maybe' (imported from Data.Maybe)
11:49:22 <edwardk> :t undefined :: EitherT () IO ()
11:49:22 <lambdabot>     Not in scope: type constructor or class `EitherT'
11:49:22 <lambdabot>     Perhaps you meant `Either' (imported from Data.Either)
11:49:40 * hackagebot openpgp 0.6.1 - Implementation of the OpenPGP message format  http://hackage.haskell.org/package/openpgp-0.6.1 (StephenWeber)
11:49:40 <edwardk> MaybeT is in Control.Monad.Trans.Maybe  but it isn't in scope in lambdabot by default
11:49:47 <edwardk> @let import Control.Monad.Trans.Maybe
11:49:48 <lambdabot>  Defined.
11:49:52 <edwardk> :t undefined :: MaybeT IO ()
11:49:52 <lambdabot> MaybeT IO ()
11:49:57 <Zenol> edwardk: Thanks a lot :)
11:50:32 <merijn> See also
11:50:39 <merijn> @unmtl MaybeT IO ()
11:50:39 <lambdabot> IO (Maybe ())
11:50:53 <edwardk> hrmm. i think i might actually be able to ship this hybrid-vectors thing
11:51:27 <Fuuzetsu> when can we expect vectors-Prelude?
11:53:09 <edwardk> please god no
11:54:42 <Fuuzetsu> on that note, generic traverse and fold were agreed upon for base, right?
11:55:00 <edwardk> that'll be going in for 7.10 barring any terrible fusion problems, yes.
11:55:19 <Fuuzetsu> is there even any date for 7.10?
11:55:28 <edwardk> should be next year around september
11:55:47 <Fuuzetsu> I assume AMP for 7.10 as well.
11:55:53 <edwardk> but you'll be able to play with it during 7.9
11:56:18 <edwardk> AMP _may_ make it in in 7.8, david was tackling doing it just a couple weeks ago
11:56:37 <kier> merijn: thanks for the advice, although I've not been able to get it to work for me yet.
11:56:38 <Fuuzetsu> I don't think he managed it but I'm unsure.
11:57:04 <edwardk> well, spj asked me the other week if the committee was in full agreement with AMP because david wanted to move ahead. thats the last i heard.
11:57:35 <edwardk> you can try to sync the vector clock of my info with yours as you will ;)
11:57:44 <kier> merijn: though I did find in some deep corner of the wiki that you can't use different TF construtors in the same group of patterns, and that GADTs should be used instead. I'll see if I can get that working
12:03:29 <merijn> kier: oh, yeah. I didn't think about that, I normally just use type families + GADTs rather than data families
12:07:18 <edwardk> i use data families when i need injectivity and i will 'control all the targets', nd type families in almost all other situations
12:08:37 <kier> what's the difference between type families and data families?
12:08:59 <merijn> kier: Type families are only types, data families produce data types
12:09:39 <edwardk> a ~ b  tells you  f a ~ f b     for a type family f,   but if you have a data family f, then f a ~ f b also tells you a ~ b
12:10:14 <merijn> edwardk: You can do the same with closed type families, no?
12:10:19 <merijn> Or not?
12:10:23 <edwardk> merijn: do we have them? =)
12:10:26 <notdan> merijn: what do you mean by type families + GADTs? What are the situations when you can ditch data families in favour of GADTs?
12:10:57 <merijn> edwardk: In HEAD?
12:11:11 <edwardk> merijn: well, you need the resulting family to be injective, not just closed.
12:11:20 <S_J> > div 10 0
12:11:22 <lambdabot>   *Exception: divide by zero
12:11:25 <mel-> What is a haskellish way of doing this: i have composite data types (via 'data') encapsulating many other values. I want to update values of this data type. This means that most values shall simply be copied over with a few exceptions (those values shall really be modified). Doing this without 'tricks' seems to be quite annoying.
12:11:26 <merijn> edwardk: I saw an announcement a couple of weeks back already that closed type families were done
12:11:41 <merijn> mel-: You probably want lenses
12:11:46 <edwardk> closed type families let you do things like Is a a = True; Is a b = False
12:11:58 <merijn> edwardk: I know <3
12:11:58 <S_J> why is div not a Maybe? because it is not the computation that fails bu the input that is disallowed?
12:12:03 <edwardk> but given Is a x = False, i get no information about x
12:12:05 <S_J> > 10 div 2
12:12:06 <lambdabot>   Could not deduce (GHC.Num.Num
12:12:06 <lambdabot>                      ((GHC.Integer.Type.Integ...
12:12:07 <edwardk> so its not sufficient
12:12:11 <simukis_> is type family = data family as in “type family f, but if you have a data family f”
12:12:15 <simukis_> ?
12:13:16 <danharaj> what
12:13:34 <merijn> notdan: I mean GADTs that carry phantom types, and using type families to make use of those phantom types in other computations
12:13:51 <notdan> ah, I see
12:14:52 <simukis_> danharaj: if that was question to me, I was quoting part of edwardk's message above.
12:15:37 <mel-> merijn: thanks
12:17:46 <zq> how would i instruct ghc to use a local installation of llvm?
12:18:17 <zq> nvm
12:19:15 <merijn> edwardk: Now that you're here anyway, maybe I can borrow your type wizardry :p
12:20:01 <merijn> I have a datatype Foo that has several variants, there is a set of core operations supported by all of them and then there are several variant specific operations
12:21:03 <merijn> I'm not quite sure how to approach this. My initial thought was GADTs + phantom type to encode variants, but that quickly tends to turn into a mess of RankNTypes functions everywhere and would probably require library users to enable RankNTypes too?
12:23:51 <jakening> edwardk: saw on Twitter you were participating in the icfp contest
12:24:03 <jakening> how is it going?
12:24:06 <edwardk> jakening: nah. just complaining about the registration requirement
12:24:28 <jakening> the deadline, you mean?
12:24:31 <edwardk> am camped out in the sand playing with vectors on my laptop
12:24:41 <edwardk> well, the fact that you had to pre-register
12:24:50 <edwardk> that pretty much caused me to shut down caring about it this year
12:24:51 <jakening> sounds like about as much fun
12:25:04 <edwardk> i haven't even looked for the problem statement
12:25:19 <jakening> program synthesis for bitvector functions, basically
12:25:28 <jakening> am right now considering using ersatz, actually
12:26:17 <edwardk> sounds fun
12:27:02 <edwardk> i want to get a tiny little morton ordered array implemented using vector under the hood, so i'm opting out ;)
12:28:06 <jakening> for ersatz??
12:28:32 <edwardk> nah, what i'm working on for my current project instead of paying attention to gsoc ;)
12:29:07 <jakening> gsoc? are you mentoring someone?
12:30:30 <merijn> Is it possible to export a class in a way that prevents other from making instances?
12:30:56 <edwardk> brainfart, i meant the icfp contest. but i'm "mentoring" mikhail glushenkov (who knows more about cabal than i do), and helping out with the record proposal
12:31:04 <Taneb> merijn, can you just export the methods?
12:31:18 <merijn> Taneb: It won't have methods
12:31:32 <edwardk> merijn: don't a proper superclass of it
12:31:36 <edwardk> er dont' export
12:31:50 <merijn> hmm, actually, this might not work without closed typeclasses anyway
12:31:51 <merijn> bollocks
12:32:42 <edwardk> class Closed a | -> a;  instance Closed TypeINeverToldYouAbout   class Closed a => RealFoo a b | b -> a      instance RealFoo TypeINeverToldYouAbout realparametersgohere
12:32:53 <merijn> Basically I'd want something like https://gist.github.com/merijn/6130082 for my earlier problem, but while I've already given up on supporting old GHC's, requiring HEAD seems a bit...overboard
12:33:15 <edwardk> class RealFoo TypeINeverToldYoAbout a => Foo a;  instance RealFoo TypeINeverToldYoAbout a => Foo a
12:33:41 <edwardk> i used it a few years back when working on type-int. look at the hack i used for making closed typeclasses
12:33:55 <applicative> hah, the icfp context looks kind of cool http://lpaste.net/91720
12:41:31 <edwardk> merijn: anyways you should be able to just make class Foo' a where … instance Foo' Int where .. instance Foo' Double where ..     class Foo' a => Foo a; instance Foo' a => Foo a  -- then just expose Foo not Foo'
12:41:53 <edwardk> the user gets no ability to make new Foo's and the instance for 'a' overlaps everything they could try to write anyways
12:42:16 <edwardk> thats easier than my old trick
12:42:49 <S_J> who develops cabal? dont you think there should be a RUN command?
12:43:05 <dcoutts> S_J: patches accepted!
12:43:10 <edwardk> dcoutts++
12:43:32 <dcoutts> S_J: yes I've thought the same for quite a while too
12:44:14 <edwardk> S_J: i tend to just make benchmarks or tests, then run them with cabal bench or cabal test, but then 90% of my code is libraries not executables
12:44:22 <applicative> S_J: here's Main.hs ;) https://github.com/ghc/packages-Cabal/blob/master/cabal-install/Main.hs
12:44:49 * dcoutts notes that's a mirror, not the upstream repo
12:45:01 <applicative> I was just exhibiting it
12:45:08 <dcoutts> 'k np
12:45:42 <applicative> oic I could have linked the correct one https://github.com/haskell/cabal
12:46:20 <applicative> I was thinking 'upstream' was deep in darcs.something.something
12:48:17 <merijn> gah
12:48:35 <merijn> TBQueue has "isEmptyTBQueue" but not "isFullTBQueue"?
12:53:47 <Zenol> Did anyone have an example of using heist to display output from a database (I'm looking for the ability to repeat a small part of the template, to display as many line as I have elements in a list).
12:53:58 <Zenol> something equivalent to yesod's $forall
12:54:44 <chrisdone> blaze is better =p
12:58:51 <Enigmagic> merijn: you could probably make one, no?
12:58:54 <kier> Is there a better way to check if a number is a power of two than just checking if its base 2 logarithm is integral?
12:59:03 <merijn> Enigmagic: No, the constructor isn't exported
12:59:14 <merijn> Enigmagic: So you can't fiddle with the insides
12:59:41 * hackagebot hybrid-vectors 0.1 - Hybrid vectors e.g. Mixed Boxed/Unboxed vectors  http://hackage.haskell.org/package/hybrid-vectors-0.1 (EdwardKmett)
12:59:51 <merijn> I can't imagine I'm the first person to want isFullTBQueue. Seems like an obvious operation for bounded queues
13:00:09 <Enigmagic> merijn: what do you want to do if it's full?
13:00:10 <geekosaur> :t Data.Bits.popCount
13:00:10 <lambdabot> Bits a => a -> Int
13:01:15 <merijn> Enigmagic: I'm writing something and if it's not full it should go back into the queue of things ready for writing, if it is full it should not go back into that queue
13:01:43 <merijn> I can't think of a sane way to implement that without an "isFull" check
13:01:46 <kier> geekosaur: I'd considered Hamming weight but I thought it'd be somewhat OTT for a use this simple
13:02:09 <Enigmagic> merijn: writeTBQueue newQ val <|> unGetTBQueue oldQ val
13:02:36 <merijn> Enigmagic: huh, what is "oldQ"?
13:02:53 <luite> merijn: it retries if the queue is full
13:03:01 <luite> so you can use `orElse`
13:03:10 <merijn> luite: Yes, but I want to check *after* writing
13:03:10 <luite> is <|> in STM = orElse?
13:03:18 <Enigmagic> luite: yes
13:03:18 <shachaf> Yes.
13:03:19 <merijn> luite: i.e. that should never happen in the first place
13:03:21 <shachaf> And empty = retry
13:03:30 <luite> right :)
13:04:11 <merijn> I want "do { writeTBQueue q val; if isFullTBQueue q then foo else bar }"
13:04:45 <merijn> hmm
13:05:11 <merijn> Maybe I can restructure to get away with the lack of isFull, but still, that function should exist! So +1 my libraries@ proposal :p
13:05:13 <Enigmagic> merijn: writeTBQueue will call retry if it's full. so you can use `orElse` or <|> to specify something to do when that happens.
13:05:38 <merijn> Actually, no, I can't restructure it
13:05:50 <merijn> Enigmagic: No, I can't maintain my invariants if I wait for a write to fail
13:06:31 <luite> isQueueFull q = unGetTBQueue q undefined >> readTBQueue q >> return True <|> return False
13:07:24 <Enigmagic> merijn: why is that? there isn't a difference in the STM between checking first and specifying an `orElse` clause.
13:07:30 <merijn> luite: Oh, well thought
13:07:45 <merijn> Enigmagic: I'm checking *after*
13:08:01 <merijn> Enigmagic: See my example do stuff a few lines up
13:08:35 <Enigmagic> merijn: don't check after :P
13:08:47 <merijn> Yes...very useful advice
13:08:58 <luite> merijn: False / True are the wrong way around obviously...
13:09:02 <luite> sorry for that :)
13:09:15 <merijn> luite: Although I think it'll probably be better to wrap TBQueue with a TVar Bool and use that
13:11:13 <luite> merijn: hmm, this check shouldn't have much overhead
13:11:46 <luite> or perhaps i should ask first why would wrapping it be better?
13:12:13 <Zenol> chrisdone : yes but I just have few more lines to write to finish what I'm doing and it would take me too munch time to make Blaze fit into snap/heist
13:12:47 <merijn> luite: Actually I dunno, I'll try this way first
13:13:14 <nejucomo> Is there a "memory handle" abstraction so that I can pass a Handle to a blackbox, then later retrieve a ByteString of data that blackbox code wrote to the handle?
13:13:23 <nejucomo> Preferably, this would not invoke the filesystem at all.
13:14:59 <nejucomo> On posix platforms, with other languages, I've close()'d stdio fds, then used dup2() to create pipes back into my process, then managed those pipes internally...
13:15:03 <luite> merijn: the updates are discarded immediately when the transaction is retried, and i think if it's not full, since you restore the tvars to their original values, they are not viewed as changed
13:15:19 <luite> since the implementation compares values, not some dirty flag
13:15:24 <nejucomo> -but I'd also like something that's platform independent, so I'm hoping that there's a "loopback" feature of Handle that's native to haskell.
13:15:35 <merijn> luite: Actually, your code is wrong :p
13:15:42 <luite> merijn: oh what's wrong?
13:15:52 <merijn> luite: fixity of <|> is 3, >> is 1
13:16:08 <luite> oh that doesn't surprise me
13:16:16 <arkeet> > (0$0<|>)
13:16:17 <lambdabot>   The operator `Control.Applicative.<|>' [infixl 3] of a section
13:16:18 <lambdabot>      must ha...
13:16:25 <arkeet> > (0$0>>)
13:16:26 <lambdabot>   The operator `GHC.Base.>>' [infixl 1] of a section
13:16:26 <lambdabot>      must have lower pre...
13:17:04 <arkeet> I can't remember who showed me that trick.
13:18:11 <nejucomo> -or maybe I should pop up a level: How should I write deterministic unittests targetting code which operates on Handle types?
13:18:52 <luite> arkeet: oh cute :)
13:19:46 <arkeet> nejucomo: if there isn't a single platform-independent thing you can use, you could write one for each platform and abstract it?
13:19:48 <arkeet> I dunno.
13:20:42 <nejucomo> Hrm.  My application is small enough right now that I'm tempted to write an abstraction of handles that allows dependency injection...
13:20:54 <nejucomo> Seems like yak shaving though.  I think I'll find simpler code to write tests for.  ;-)
13:21:01 <arkeet> :-)
13:21:45 <nejucomo> Or I could write tests that do posixy things only…  I think I'll try that.
13:21:53 * nejucomo can't resist a good wooly yak.
13:22:59 <sm> nejucomo: it's a kindness. They get hot, the poor things
13:23:35 <nejucomo> hehe....
13:26:11 <pxqr> is there a lib for making dialogs with user?
13:26:19 <pxqr> like cabal init
13:27:04 <luite> nejucomo: hmm, you can implement IODevice and BufferedIO for some custom handle device
13:27:20 <luite> nejucomo: perhaps somehone has already done so, search for IODevice instances on hackage :)
13:27:35 <nejucomo> luite: Thanks.
13:27:42 <nejucomo> I wasn't familiar with either of those.
13:28:01 <luite> nejucomo: see GHC.IO.Handle, the ghc-specific stuff for buffered IO
13:28:55 <augustss> Howdy!
13:31:46 <joelteon> How do you get all the constructors of a datatype with TH?
13:32:06 <kier> joelteon: reify
13:32:20 <supki> {-# LANGUAGE ExistentialQuantification #-}
13:33:01 <nejucomo> luite: That looks close to the exact layer I was hoping for.
13:33:14 <nejucomo> GHC-specific is much more acceptable than OS-specific code.
13:33:32 <joelteon> oh, I see it
13:34:16 <applicative> hm prolog more 'popular' on github than Dear Language?
13:35:38 <applicative> https://github.com/languages/Prolog vs https://github.com/languages/Haskell  I think theyre having trouble detecting Prolog, or undetecting
13:35:46 <applicative> oh hi augustss !
13:37:37 <BMeph> @remember nejucomo  nejucomo can't resist a good wooly yak.
13:37:38 <lambdabot> I will remember.
13:37:45 <augustss> Hi
13:37:47 * BMeph chortles with evil glee!
13:38:08 <BMeph> Greetings, augustss!
13:39:34 <geekosaur> if it goes bye xtensions, it probably can't tell the prolog from the perl
13:39:38 <geekosaur> *by
13:40:53 <joelteon> is there a quasiquoter to create Decs?
13:41:19 <BMeph> Has anyone ever done an "off-the-cuff" analysis of the type system, to the point where an acceptable programming language choice for it has been proposed? :)
13:41:51 <lingxiao> hey all if i want to cabal install Control.Monad.Product, what's the name Is hould type in?
13:41:54 <lingxiao> I should *
13:42:22 <lingxiao> :t (<$)
13:42:23 <lambdabot> Functor f => a -> f b -> f a
13:42:36 <bscarlet> >:t [d| x = 3 |]
13:42:49 <geekosaur> joelteon: hayoo tells me monad-product
13:42:53 <bscarlet> :t [d| x=3 |]
13:42:54 <lambdabot> parse error on input `='
13:42:55 <geekosaur> er
13:43:01 <geekosaur> lingxiao, sorry
13:43:29 <bscarlet> joelteon: is [d| |] what you're looking for?
13:43:36 <lingxiao> geekosaur: why sorry?
13:43:49 <dmwit> BMeph: huh?
13:43:49 <geekosaur> because I addressed it to the wrong person originally
13:43:55 <geekosaur> "hayoo tells me monad-product"
13:43:56 <lingxiao> unfortunately, I'm getting this: cabal: There is no package named 'monad-product'.
13:44:32 <joelteon> oh, that must be it
13:44:34 <lingxiao> ahh.. its monad-products. the 's'
13:44:37 <geekosaur> oh, typo, sorrty. monad-products
13:44:57 <lingxiao> geekosaur: haha yeah thanks! More importantly thanks for introducing me to hayoo
13:45:04 <geekosaur> 0 for 2, I am today :/
13:45:11 <dwcook> What's a good way to perform an IO action every N seconds?
13:45:12 <monochrom> damn English :)
13:45:25 <merijn> dwcook: How precise does the N seconds need to be?
13:45:29 <merijn> dwcook: Does drift matter?
13:45:34 <monochrom> threadDelay (N*1000000)
13:45:39 <dwcook> merijn, preferably no drift, little constraint on precision
13:45:51 <dwcook> monochrom, that will drift, right?
13:45:56 <merijn> It might, yes
13:46:14 <monochrom> I do not know of a better way
13:46:35 <dwcook> It's a good start anyway. Thanks.
13:46:42 <merijn> dwcook: You'd probably have to query the realtime clock and then adjust for drift
13:46:45 <joelteon> https://gist.github.com/joelteon/6202071
13:46:52 <dwcook> Yeah, was hoping someone had written something for that already.
13:46:56 <joelteon> "Parse error in pattern: $(mkName $ "is" ++ nameBase con)"
13:47:00 <kier> dwcook: I came across the timers package sometime ago, not sure of its details but it might fix the drift issue
13:47:06 <joelteon> why is that? can I not interpolate the name of the function I want to define?
13:47:31 <kier> joelteon: did you enable -XTemplateHaskell / {-# LANGUAGE TemplateHaskell #-}
13:47:43 <dwcook> kier, thanks, I'll check that out.
13:48:04 <joelteon> kier: yes, I did
13:48:23 <joelteon> it's in my cabal file
13:49:57 <kier> joelteon: hmm, I think that $() notation can only be used in certain places (decs, exprs, pats, types) - I'm not sure it's possible to interpolate a name without creating the AST by hand
13:49:57 <bscarlet> joelteon: I don't think you can splice there.
13:50:03 <joelteon> :(
13:50:17 <joelteon> I don't like writing TH by hand
13:50:19 <joelteon> oh well
13:50:38 <pyrtsa> Is there a way to configure (say, by editing a config file) which compiler GHC will by default use for the CPP phase? I'm having troubles installing Haskell Platform on OS X, since Clang is way more strict in accepting lines like "#-}" than GCC is.
13:51:19 <bscarlet> pyrtsa: yes
13:51:28 <pyrtsa> How?
13:51:36 <bscarlet> pyrtsa: I don't remember
13:51:42 <bscarlet> pyrtsa: sorry
13:52:35 <pyrtsa> Hmm. Will need to search the docs more. I'd be glad if someone knew right away.
13:52:56 <bscarlet> pyrtsa: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/options-phases.html
13:53:07 <bscarlet> pyrtsa: -pgmP maybe?
13:53:16 <pyrtsa> Sure, but which config file?
13:53:54 <geekosaur> pyrtsa, there's no global config file for that
13:54:11 <joelteon> how is the pattern Foo{} represented in TH?
13:54:55 <pyrtsa> geekosaur: Okay. Then I guess I'll need to patch the installation of Haskell Platform to use ghc with that option always on. Thanks.
13:55:01 <kier> pyrtsa: You could try setting a bash alias e.g. put "alias ghc='ghc -pgmP=mypreprocessor'" in your .bashrc, assuming that you use bash
13:55:29 <pyrtsa> kier: I'm afraid the installation script of Haskell Platform would ignore that.
13:56:14 <pyrtsa> I'm trying to make it work out of box for Homebrew, so that `brew install haskell-platform` would work for the rest of us OS X users, too.
13:56:25 <kier> pyrtsa: my bad, I assumed you were just referring to standalone building by hand
13:56:31 <bscarlet> joelteon: RecP (mkName "foo" {- or some such -}) []
13:56:50 <bscarlet> joelteon: sorry, that should be "Foo" not "foo"
13:57:18 <geekosaur> pyrtsa: commonly the ghc program is actually a shell script which invokes the real ghc program with various options (so it can be relocated more easily). you may be able to set it in there
13:57:34 <pyrtsa> geekosaur: Oh, thanks. I'll look into that.
13:57:40 <applicative> pyrtsa: I was wondering why clang trouble is cropping up; is this a problem if people use the Installer thingy that comes with the platform
13:57:50 <pyrtsa> applicative: I suppose so.
13:58:08 <geekosaur> isn't it just the already known thing about clang's cpp being stricter than gcc's?
13:58:19 <nejucomo> I'm using HPC for the first time.  It shows many deriving classes in yellow, but when I remove them my unittests no longer compile.  What's going on?
13:58:22 <pyrtsa> I'm using a very new version of Clang from Apple, so it might be a problem lots of devs are going to face soon.
13:58:23 <luite> hmm, unfortunately it's not possible to configure the cpp program through platformConstants
13:58:38 <bscarlet> applicative: I think it comes up with the change to the new XCode, now in beta
13:58:48 <pyrtsa> bscarlet: That.
13:58:53 <nejucomo> (I'm compiling with -fhpc a monolithic application which runs unittests internally, then measuring coverage when I run those unittests.)
13:59:37 <bscarlet> applicative: If I remember right, the new XCode provides a gcc that's actually clang, or something like that. I could be wrong. carter knows more, I think.
13:59:49 <pyrtsa> It seems to me it's high time for the Haskell community to start using a dedicated version of CPP (or no CPP at all), instead of trusting that "gcc -E" does the job just right. (Just saying...)
14:00:29 <luite> pyrtsa: there is cpphs, but there are probably reasons that that's not the default :)
14:00:40 <geekosaur> xcode's gcc has been llvm-gcc-4.2 for a long time. I think the new one kills off llvm-gcc-4.2 and only provides clang, though
14:00:45 <pyrtsa> luite: Yes. :)
14:00:46 <applicative> pyrtsa: someone else said it was an error in clang really, that will (someday) be corrected
14:01:29 <geekosaur> also, pyrtsa, there is cpphs already. (and no, I don't know why it hasn't been adopted globally; it makes much more sense than using one which is, well, intended for C.)
14:01:43 <pyrtsa> applicative: I tried to browse through the bug reports around, and it looks as if there used to be another related bug, but this one is real and not going to change.
14:02:33 <applicative> ah, maybe theres more than one problem; one was that clang's preprocessor didnt know what to do with the flag '-traditional'
14:02:46 <pyrtsa> AFAIK, the CPP is free to ignore any "#pragma ..." lines it doesn't know, but anything else beginning with # should be known to the preprocessor.
14:03:09 <applicative> anyway, but im using os x why dont i have this problem?
14:03:23 <bscarlet> applicative: have you installed the beta of the new XCode?
14:03:30 <pyrtsa> applicative: What's your version of clang?
14:03:43 <applicative> no, the 'command line tools' or whatever is where i got my gcc
14:04:08 <bscarlet> applicative: right. That's what I use, and I don't have the problem either.
14:04:09 <applicative> Apple LLVM version 4.2 (clang-425.0.28) (based on LLVM 3.2svn)
14:04:33 <applicative> gcc version 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)
14:04:38 <pyrtsa> Apple LLVM version 5.0 (clang-500.1.65) (based on LLVM 3.3svn)
14:04:47 <applicative> oooo
14:05:10 <geekosaur> applicative, Apple is (in the unreleased beta Xcode) killing off gcc
14:05:19 <geekosaur> released xcode still has it
14:05:30 <S_J> So I have written a very simple key/value store in haskell. but i want to redo it into something serious. Eventually I want it to be a production strength key/value store. Can anyone point me to some good resources. On filesystems for databases and so on.
14:05:31 <applicative> ah, at last Im seeing
14:06:06 <applicative> this seem bad, wont everything else go wrong too?
14:06:22 <pyrtsa> applicative: Yes, that's what I'm afraid will happen.
14:06:22 <geekosaur> a lot of stuff already works with clang
14:06:24 <osfameron> can you install a gcc with homebrew?
14:06:37 <pyrtsa> obiwanko: That's what I'm doing right now.
14:06:41 <pyrtsa> obiwanko: But...
14:06:45 <geekosaur> probably, but that won't help people installing the official Platform
14:06:57 <pyrtsa> I want to solve this so that installing Haskell Platform won't be a hack for everyone else too!
14:07:15 <geekosaur> pyrtsa, the right answer here is cpphs I think
14:07:37 <applicative> can cpphs behave like the gcc's cpp?
14:07:38 <geekosaur> so you don't have to care which cpp is available, you have one that is more appropriate than any of them
14:07:41 <pyrtsa> geekosaur: Okay, that seems like a big enough change to the Platform that I won't be able to solve it alone.
14:07:57 <pyrtsa> Anyone able to help in my effort?
14:08:17 <geekosaur> clang's cpp is enforcing standard C syntax. we don't *want* standard C syntax in .hs files!
14:08:34 <bscarlet> pyrtsa: I know others know about the problem and have worked on it.
14:09:26 <applicative> geekosaur: is it that in the future llvm-gcc wont exist?
14:09:27 <geekosaur> We want a program that supplies cpp-like macros but doesn't force C syntax on us. which is what cpphs is
14:09:31 <pyrtsa> bscarlet: Okay, good to hear. Should I maybe post my findings to some Trac somewhere? I couldn't find this issue really described anywhere.
14:10:08 <c_wraith> geekosaur: then you have the problem that you're incompatible with .hsc, since hsc2hs actually does generate a program.
14:10:10 <geekosaur> applicative: apple's not distributing it any more, at least. I suspect a full LLVM install will still have it available
14:10:17 <c_wraith> err, a *C* progam
14:10:21 <geekosaur> but apple already only ships a partial llvm
14:10:26 <applicative> yes
14:10:51 <geekosaur> but that's right back to step 1, you'd have to get a full LLVM from somewhere else
14:11:27 <geekosaur> c_wraith, I think that, more precisely, cpphs emulates a traditional (pcc-style) cpp that doesn't care much about syntax.
14:11:38 <applicative> but is it that the people pyrtsa is worried about dont have a preprocessor that does the right thing on their systems?
14:11:51 <geekosaur> it should work fine for C code, if you don't use too many advanced ANSI-isms
14:11:54 <pyrtsa> applicative: I think so.
14:12:03 <Kaini> S_J, read database documentations, learn about (pick whatever you need) transaction logs (forward/backward recovery), distributed systems, serialization issues, authentication
14:12:03 <pyrtsa> applicative: cpphs they obviously could have.
14:12:12 <donri> is there any easy way to get all instances of a type class in haskell-platform?
14:12:16 <geekosaur> yeh, pyrtsa is trying to avoid people having to install a bunch of prerequisites in order to use the Platform
14:12:21 <Kaini> It really depends what you want to do
14:12:26 <Kaini> *+ on
14:12:32 <c_wraith> geekosaur: well, my point was that hsc2hs just runs the C compiler - I guess you could tell it to run cpphs first, then the C compiler.
14:12:55 <geekosaur> I'm thinking the best solution is to just add cpphs to the platform and forget about what C compiler foo might or might be available/usable
14:13:16 <geekosaur> c_wraith, then it's irrelevant
14:13:27 <c_wraith> geekosaur: yes, I see
14:13:35 <applicative> does the script that we call ghc have a variable for a preprocessor?
14:13:38 <geekosaur> render unto C what belongs to C. just don't use that on non-C code
14:13:58 <kier> donri: at compile-time or run-time?
14:14:03 <applicative> render unto C what belongs to C; and unto Haskell what makes sense
14:14:09 <pyrtsa> applicative: "-pgmP cmd -- Use cmd as the C pre-processor (with -cpp only)."
14:17:05 <applicative> but if the platform came with cpphs it might be as simple as adjusting the contents of the ghc script
14:17:08 <applicative> ?
14:17:31 <pyrtsa> applicative: Yes, I guess so.
14:17:46 <geekosaur> that's what I would expect
14:17:59 <applicative> hm, I wonder if mzero has heard about all this.
14:18:07 <geekosaur> that said, there's a bootstrapping issue there I think
14:18:44 <dcoutts> applicative: one reason we've not switched to cpphs already is the license
14:18:48 <geekosaur> you dont want the ghc install to do that, because cpphs may not exist until ghc has been installed and is able to build it
14:18:59 <applicative> what, what's the cpphs license??
14:19:05 <geekosaur> oh, wrong license? d*mm*t
14:19:13 <dcoutts> some people see GPL and freak out
14:19:32 <pyrtsa> Ouch.
14:19:43 <dcoutts> (forgetting that they compile things with gcc which is gpl)
14:19:50 <geekosaur> in a certain sense that's what triggered this discussion, in fact; apple's trying to lose the GPL parts of xcode (namely gcc-based stuff)
14:20:37 <applicative> hm yes, lgpl. and Malcolm Wallace is a gpl enthusiast?
14:20:56 <FreeFull> Today I learned that when you want a head with a default value, you can use foldr const
14:21:02 <FreeFull> > foldr const 0 [1,4,5]
14:21:03 <lambdabot>   1
14:21:05 <FreeFull> > foldr const 0 []
14:21:06 <lambdabot>   0
14:21:15 <applicative> oh lovely
14:22:03 <FreeFull> > foldr const 0 [1..]
14:22:04 <lambdabot>   1
14:22:11 <FreeFull> No problems
14:22:20 <osfameron> cute
14:22:40 <S_J> can someone explain the Parsec types to me: GenParser Char () String; what does that say? abd sometiems there is st instead if ()
14:22:45 <FreeFull> On the other hand, foldl const is the same as const, except the ignored parameter has to be a list
14:23:06 <applicative> S_J do :i GenParser
14:23:17 <maxiepoo> :i GenParser
14:23:25 <geekosaur> not in channel, in ghci
14:23:33 <applicative> haha
14:23:41 <geekosaur> lambdabot doesn't do :i, because it gets quite large at times
14:23:42 <maxiepoo> aw I was hoping lambdabot would do it
14:23:48 <applicative> maybe :i doesn't work for type synonyms
14:23:56 <applicative> no thats silly
14:23:58 <FreeFull> geekosaur: By "at times" you mean "most of the time" =P
14:24:40 <applicative> S_J: the real underlying type is newtype ParsecT s u m a
14:24:46 <FreeFull> applicative: It works fine for type synonyms
14:24:52 <donri> kier: at i'm-just-looking-things-up time :)
14:24:53 <FreeFull> I think it has trouble with type families though
14:24:59 <donri> kier: development time
14:25:01 <geekosaur> IIRC the GenParser type has associated with it a token type (Char here), an optional user-provided state type (which is usually () because it isn't being used), and a result type
14:25:05 <applicative> yeah, i panicked absurdly FreeFull
14:25:38 <applicative> type GenParser tok st = Parsec [tok] st
14:25:54 <applicative> ie type GenParser tok st = ParsecT [tok] () Identity st
14:26:04 <donri> kier: actually the real intent here is to consider what concrete types it might be useful to SPECIALIZE a polymorphic function for
14:26:38 <applicative> bah
14:26:49 <FreeFull> What would be nice is the ability to search through the type signatures of all functions that are in scope
14:26:50 <applicative> ie type GenParser tok st a = ParsecT [tok] st Identity a
14:27:04 <banister> applicative: do you think arrows are worth learning? i read in a few places that they're not (edwardk seems to say this)
14:27:07 <FreeFull> Or at least, all functions that are in :browse somemodule
14:27:08 <kier> donri: I'm afraid I don't know any way to accomplish that off the top of my head
14:27:20 <donri> okies, thanks for listening :)
14:27:29 <applicative> banister: dunno, everyone's down on them, people who like them have to apologize on here all the time.
14:27:33 <FreeFull> banister: You won't need them unless you will
14:27:41 <maxiepoo> FreeFull: like in Agda with holes?
14:27:57 <banister> FreeFull: what are they exactly? :P
14:28:03 <maxiepoo> http://www.haskell.org/haskellwiki/GHC/TypeHoles
14:28:06 <banister> are there any 'arrows for noobs' posts?
14:28:13 <FreeFull> maxiepoo: I mean, like   :search Char   and it returns all functions in scope that match
14:28:22 <banister> FreeFull: assume i just understand monads, what are arrows? :)
14:28:29 <donri> banister: arrow notation can be nice for some things, but Arrow itself is sort of "broken" (well not broken but it's not what it could be)
14:28:36 <maxiepoo> http://www.haskell.org/arrows/
14:28:50 <maxiepoo> old but nice pictures
14:28:51 <applicative> banister: I think people often refer to this http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial
14:28:55 <banister> donri: is it possible to 'fix' them (as they're broken) or is the whole concept somehow inherently flawed?
14:28:55 <FreeFull> banister: Functions and Monads are two different arrows
14:28:57 <BMeph> Has anyone ever done an "off-the-cuff" analysis of the type system, to the point where an acceptable programming language choice for it has been proposed? :)
14:29:01 <kier> personally I see arrows as a generalisation of functions, but I'm not sure what the point of it all is
14:29:12 <FreeFull> And there are also other Arrows but I don't actually know what they are
14:29:13 <donri> banister: it's possible, Cale has promised us a library at some point ;)
14:29:52 <donri> kier: that is the point. but part of the problem is that 'arr' basically kills any generalization, and it's required by the class and used a lot by arrow notation
14:30:02 <BMeph> What I mean is, has anyone studied what you can do in the type system, and figured out, "I could do what the TS needs to do in language X"?
14:30:33 <FreeFull> I'm not sure of Comonads are arrows
14:30:50 <donri> i'm quite sure Comonad is not Arrow :p
14:30:52 <banister> donri: so it's more that the current implementation of arrows is broken? or will cale's thing be different to arrows (in concept) ?
14:31:16 <FreeFull> donri: Doesn't satisfy the laws?
14:31:23 <FreeFull> donri: Is it a Coarrow then?
14:31:26 <maxiepoo> CoKleisli arrows
14:31:50 <donri> banister: mostly the problems are that the tuples (due to 'first') make for shitty performance, and 'arr' makes the arrow abstraction as opaque as normal functions
14:32:19 <donri> FreeFull: they're both classes
14:32:28 <BMeph> Isn't there a paper out there that posits Arrows as a specialization of Applicatives?
14:32:29 <banister> donri: does Cale's thing require a patch to GHC, or it can be written in haskell as-is ?
14:32:45 <donri> banister: IIUC it's a library and a source preprocessor
14:33:05 <applicative> does the patch get rid of tuples ?
14:33:20 <applicative> I mean replace them with somethign more likely to be sensible
14:33:20 <donri> applicative: ISTR yes
14:33:41 <banister> donri: ISTR?
14:33:50 <donri> I seem to recall
14:33:53 <banister> thanks
14:34:09 <donri> i'm not Cale, and I don't know all the details :)
14:34:12 <applicative> arr is clearly pretty deeply entrenched in the Arrow Idea
14:34:14 <maxiepoo> what exactly do arrows represent? scope?
14:34:45 <applicative> an arrow is kind of two-hole type constructor like (->)
14:34:55 <maxiepoo> I understand Category
14:34:58 <applicative> which behaves like (->) in suitable ways
14:35:11 <applicative> maxiepoo: right, its just a category with nice constraints, a little too nice
14:35:45 <BMeph> I don't like that when specifying arrows that work on pair tuples, that it forces one to specify which one of the pair is "worked on" "first".
14:36:15 <applicative> ooh, a wikipedia article has the Laws, maxiepoo http://en.wikipedia.org/wiki/Arrow_(computer_science)
14:36:23 <applicative> it must be science!
14:37:01 <BMeph> It's in Wikipedia; it must be crap, then. ;)
14:37:22 <applicative> i think the laws must be pasted in from somewhere
14:38:13 <geekosaur> my laws are pastede on yey
14:38:50 <maxiepoo> but what I'm saying is Arrows seem really tightly bound to the concept of tuples, but really we're just using tuples as an "implementation" for the concept of scope/bound variables right?
14:38:53 <pyrtsa> geekosaur, bscarlet, applicative: Apparently, there's a file called "settings" in the GHC installation. By replacing "/usr/bin/gcc" with "/usr/local/bin/gcc-4.8" got me past the preprocessor errors. But now it's time to sleep. ->
14:41:44 * applicative wonders how pyrtsa got a gcc-4.8 in /usr/local/bin though
14:42:22 <gertc> i am making a mess again, how can i "check" the following if "check" returns IO Bool instead of Bool.     liftIO (Google.uid $ AccessToken m Nothing) >>= \(Right (Google.Profile a _ _ _ _ _ _ _ _)) -> if check (read . unpack $ a) [0] a2 then loop2 a a1 else WS.sendTextData "check false"
14:43:00 <applicative> bool <- check blah blah ; if bool then ... as before
14:43:48 <applicative> check (read . unpack $ a) [0] a2 >>= \bool -> if bool then then loop2 a a1  else WS.sendTextData "check false"
14:43:50 <gertc> i like to stick with >>= motation if possibel :)
14:44:04 <applicative> too many 'thens' in there, but isn't that right?
14:44:56 <gertc> but that would be a >>= inside a \x -> ... ?
14:45:08 <maxiepoo> yep
14:45:11 <S_J> if i dont want to return a string but return a certain type if the parsing succeeds how would I do that?
14:45:22 <applicative> yes of course, this is haskell, everything can be embedded in \x -> ...
14:45:52 <S_J> P.GenParser Char () String -> HttpRequest -- I dont want a function like toRequest "GET" = GET
14:46:04 <gertc> ok testing someting
14:46:42 <applicative> S_J do thing <- myparser ; if thing == "GET" then return Just GET else Nothing ... or whatever
14:47:26 <maxiepoo> S_J: something like get = reserved "GET" *> pure GET
14:47:28 <S_J> cant i just skip the if thing == "GET" and return GET on parse success?
14:47:46 <applicative> oh if it only succeeds with "GET" yes
14:47:55 <applicative> i started by thinking of a more general case
14:48:45 <applicative> isn't there a swift operator, like GET <$ myparser
14:49:06 <maxiepoo> :t (<$)
14:49:06 <lambdabot> Functor f => a -> f b -> f a
14:49:23 <maxiepoo> yea
14:49:30 <applicative> right, so that makes my string parser a HttpRequest parser
14:54:24 <maxiepoo> :t ($>)
14:54:25 <lambdabot>     Not in scope: `$>'
14:54:25 <lambdabot>     Perhaps you meant one of these:
14:54:25 <lambdabot>       `$' (imported from Data.Function),
14:54:30 <maxiepoo> why
14:54:43 * hackagebot testloop 0.1.1.0 - Quick feedback loop for test suites  http://hackage.haskell.org/package/testloop-0.1.1.0 (RomanGonzalez)
14:54:45 * hackagebot foldl 1.0.0 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.0.0 (GabrielGonzalez)
14:55:18 <hpaste> sj pasted “parsec types” at http://lpaste.net/91726
14:55:52 <S_J> ^^ Is there a good explaination on Parsec types soemwhere. I just want to return GET on success
14:56:30 <geekosaur> maxiepoo, what would ($>) mean?
14:56:48 <maxiepoo> geekosaur: Functor f => f a -> b -> f b
14:57:06 <Peaker> In the async library, once an Async has completed and you have an "a", is there any point to keeping a reference to the "Async a"?
14:57:11 <maxiepoo> f $> x = f *> pure x
14:57:27 <Peaker> in particular, why does waitAny ( http://hackage.haskell.org/packages/archive/async/2.0.1.4/doc/html/Control-Concurrent-Async.html#v:waitAny ) return the "Async a" that already fired?
14:57:31 <Peaker> what can you do with it?
14:57:41 <gertc> ok thx it works but why does my code always look like this :) liftIO (Google.uid $ AccessToken m Nothing) >>= \(Right (Google.Profile a _ _ _ _ _ _ _ _)) -> liftIO (check (read . unpack $ a) [0] a2) >>= \true -> if true then loop2 a a1 else WS.sendTextData (pack "check group false")
14:58:20 <Peaker> oh, I think I see, it has Eq/Ord instances
14:58:38 <Peaker> so you can prune it off your list or such
14:59:16 <Peaker> gertc, instead of an inordinate amount of underscores, you might appreciate a record :)
14:59:27 <maxiepoo> S_J: what is the problem currently
14:59:53 <geekosaur> S_J, not sure what you're up to there but as written your requestParser is just a long way to write getParser
15:00:01 <Peaker> maxiepoo, that would incur an Applicative constraint unnecessarily.   (<$) = fmap . const     and ($>) could be:  flip (<$) but that would be somewhat point-less
15:00:24 <shachaf> I would like ($>) in base.
15:00:29 <shachaf> Right now I import Control.Comonad for it.
15:00:53 <edwardk> i personally don't see much point in moving it into base, but wouldn't fight against it
15:01:51 <S_J> I want to parse http requests. so if i encounter "GET" or "get" I want the type GET to be returned. How do i do that?
15:02:10 <Peaker> shachaf, why not use (<$) ?
15:02:13 <maxiepoo> oh they Type is GET
15:02:36 <maxiepoo> no
15:03:06 <shachaf> Peaker: Sometimes the other order is more natural.
15:03:13 <edwardk> S_J: "GET" <$ (whatever parser you have for "get" or "GET") ;)
15:03:25 <Peaker> shachaf, do you have an example?
15:03:36 <edwardk> e.g. GET <$ (string "get" <|> string "GET")
15:03:36 <shachaf> It's like "x *> pure y" -- "do this, then return that".
15:04:18 <edwardk> Peaker: most of the common usecases are with wfix in comonad
15:05:06 <edwardk> fib d = wfix $ d $> fby 0 . extend (\dfib -> extract dfib + fby 1 dfib)
15:05:56 <maxiepoo> S_J: your code looks fine are you getting an error message or something?
15:06:49 <Peaker> edwardk, what's fby?
15:09:03 <hpaste> sj pasted “parsec error” at http://lpaste.net/91729
15:09:14 <S_J> ^^ error msg, sorry should have psoted before
15:11:03 <geekosaur> oh, I get it
15:11:05 <maxiepoo> what ghc are you using?
15:11:36 <geekosaur> getParser you have declared as taking a Parser as a parameter and returning a bare value
15:12:15 <maxiepoo> ohh
15:12:48 <geekosaur> it should be getParser :: GenParser Char () HttpRequest (or, more simply, just Parser HttpRequest)
15:13:51 <alyx_> http://lpaste.net/91730 how would I refactor this to get rid of the integerOperator/doubleOperator copypasta and the horrible "(\x -> catchError (integerOperator (+) x) (\_ -> doubleOperator (+) x))" bit?
15:15:06 <S_J> maxiepoo: 7.4.2
15:16:28 <maxiepoo> S_J: yeah I'm using 7.6 and I get a nicer error message
15:16:56 <maxiepoo>     No instance for (Text.Parsec.Prim.Stream s0 m0 Char)
15:16:56 <maxiepoo>       arising from a use of `P.string'
15:16:57 <maxiepoo>     The type variables `s0', `m0' are ambiguous
15:16:58 <maxiepoo>     Possible fix: add a type signature that fixes these type variable(s)
15:16:59 <maxiepoo> ...
15:17:19 <S_J> maxiepoo: ok ty. i should get the latest one.
15:17:37 <S_J> could you explain the type P.GenParser Char () String -> HttpRequest to me?
15:17:42 <Peaker> maxiepoo, I think it would have been nicer still to emphasize the ambiguous part -- and put it as the first line of the error or such
15:17:44 <S_J> Char () String?
15:17:49 <geekosaur> S_J, it's wrong
15:17:51 <maxiepoo> Peaker: agreed
15:18:05 <Peaker> S_J, it's not a function
15:18:06 <geekosaur> the type you wrote is: I take a parser and I produce a raw HttpRequest.
15:18:17 <geekosaur> But you are writing a parser, not a function from a parser to something else
15:18:28 <geekosaur> [10 18:12] <geekosaur> it should be getParser :: GenParser Char () HttpRequest (or, more simply, just Parser HttpRequest)
15:19:20 <geekosaur> now, *why* it needs to be that way: you are writing a parser, that is something to be used with the parse function, so your result type must be GenParser something (not just a value).
15:20:08 <geekosaur> the result type is the thing you want to pass back (so, HttpRequest). the other parameters represent parser state (the type of tokens in the input stream, and any additional state)
15:20:37 <maxiepoo> geekosaur: do you mean Parsec instead of Parser?
15:20:52 <geekosaur> possibly, I'm more used to the older Parsec
15:21:00 <geekosaur> where it was just Parser
15:21:41 <geekosaur> not relevant if you're using GenParser anyway
15:22:08 <maxiepoo> oh no Parser is right
15:22:33 <maxiepoo> it's in Text.Parserc.String
15:23:10 <lemao> e.g. handler :: WireP Cmd Ev, how to I implement handler and get a hold of the input Cmd value need to generate the Ev output?
15:31:38 <lukexi> i'm having a super weird problem right now building GHC (using LLVM 3.0 & GHC 7.6.2) wherein tons of layout based code (i.e. http://en.wikibooks.org/wiki/Haskell/Indentation) is suddenly erroring out, e.g. "compiler/coreSyn/CoreUnfold.lhs:425:5: parse error on input `where'"... anyone have any idea what might trigger that??
15:35:55 <Morgawr> I heard there's no way to run ghci on a raspberry pi, is it true? no workarounds? :(
15:36:03 <Morgawr> I wanted to run yesod on my raspberry pi but apparently it requires ghci
15:36:07 <S_J> Was Parsec a novel idea or did such dieas exist before haskell? can it be done in other languages ?
15:36:53 <S_J> Peaker, geekosaur: I mean the type Char () String what does this say about the parser?
15:37:04 <maxiepoo> S_J: parser combinators can definitely be done in other languages but Parsec is nice because it takes advantage of type classes like Applicative, Alternative and Monad
15:37:17 <geekosaur> Char () String is not a type
15:37:25 <geekosaur> GenParser Char () String is a type
15:37:58 <geekosaur> it is the type of a parser which parses Char tokens, carries no user-defined state, and the output of the parse is a String (in the GenParser monad)
15:40:28 <S_J> if not parsing char tokesn, could it parse an Int value!?
15:41:49 <Twey> S_J: Yes.
15:42:33 <Twey> S_J: Note that these are individual tokens; the input must be a *stream* of those tokens.  It doesn't make any sense to parse an Int, but it can make sense to parse a list of Ints.
15:43:37 <Twey> S_J: More commonly, though, you might have a ‘tokenizer’ step that goes through your input first and breaks it into ‘tokens’ that are meaningful to your language, like identifiers, numbers, or strings.
15:44:09 <ubikation> is it possible to mix record syntax with type parameters?
15:44:57 <Twey> ubikation: Yes.
15:45:51 <ubikation> err... I was trying something like data Vector a = Vector { edges :: (Vector), i :: a } but that doesn't seem to work
15:46:52 <Twey> ubikation: You defined Vector as a type constructor, so you need to pass it an argument to get a concrete type
15:47:02 <Twey> E.G. edges ∷ [Vector a] -- (I presume you meant a list)
15:48:10 <ubikation> ah... that makes sense. But I guess that means I can't mix graphs of different types?
15:48:51 <Twey> ubikation: You don't *have* to pass a there.  You can pass any type you like.
15:48:55 <geekosaur> S_J, depends on what you mean by 'parse an Int value'. if you mean, can it extract an Int from a stream of Char tokens, certainly; each token is a digit
15:49:05 <Twey> I suspect you probably don't *want* to mix graphs of different types, though.
15:49:27 <Twey> (though I'll confess I'm not quite sure I understand how your Vector type is supposed to be used)
15:49:50 <ubikation> thank you very much!
15:50:19 <S_J> geekosaur: I meant GenParsr Int () String. COuld it then parse the Int value 1121344 for example?
15:51:46 <geekosaur> conceivably yes. what it would mean is another question
15:52:03 <geekosaur> not one I could answer; it is up to who defined that as a token
16:07:52 <S_J> so I cant have a Parser that either returns a 4-tuple of strings or a 2 tuple
16:08:09 <maxiepoo> sure
16:08:39 <maxiepoo> Either (String, String, String, String) (String, String)
16:09:00 <maxiepoo> though you should probably make your own type for readability's sake
16:11:25 <geekosaur> also consider using stuff that already exists; if you're representing URIs, you may want to look at Network.URI
16:20:29 <niknar> what's a good way to start learning haskell?
16:20:58 <shachaf> @where faq
16:20:58 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
16:21:05 <shachaf> I think that has some good answers.
16:21:09 <S_J> write a bayesian spamfilter. 20-50 LOC interesting, fairly simple
16:22:21 <aristid> ocharles: your Tar-file pipe... isn't that pretty much also "just" a splitting pipe?
16:23:17 <FreeFull> niknar: I started with Learn You A Haskell
16:23:22 <FreeFull> It worked out pretty well for me
16:24:40 <S_J> why does Either not return Fail and Success instead of Left or Roght?
16:25:08 <FreeFull> S_J: Because sometimes it isn't used as Fail and Success
16:28:51 <S_J> why is this:
16:28:55 <S_J> main = do
16:29:03 <S_J> parseRequest parsePOST "POST age String 32"
16:29:09 <S_J> parseRequest parseGET "GET age"
16:29:17 <S_J> only 2nd result is printed.
16:29:28 <S_J> not weird i guess, it is returned
16:31:56 <shelf> i enjoyed doing the 99 exercises
16:31:57 <shelf> in haskell
16:32:02 <shelf> and reading all the crazy approaches
16:33:32 <FreeFull> shelf: Did you do all of the exercises?
16:34:01 <shelf> i think i got to ~40 or 50
16:34:10 <shelf> before i got distracted with trying to do IO
16:34:35 <shelf> byt LYAH didn't have many exercises
16:35:04 <FreeFull> shelf: Note niknar is already gone
16:35:43 <shelf> yeah. i'm just making conversation ( ´ w `)
16:45:50 <ill_logic> Hi all, I was wondering if I could get some help with downloading a file and saving it lazily.
16:46:15 <ill_logic> Looking here: http://hackage.haskell.org/packages/archive/HTTP/4000.0.7/doc/html/Network-HTTP.html why is it fmap 100? I try that and it only gets 100 characters.
16:46:21 <ill_logic> I think
16:46:33 <ill_logic> if I put in 10000 it stalls for a while
16:46:59 <ill_logic> or wait. no, 10000 it gets as many characters, I presume
16:47:12 <ill_logic> if I remove the fmap altogether it stalls. I guess it gets the whole thing at once. not at all lazy
16:47:31 <geekosaur> yes
16:47:44 <geekosaur> simpleHTTP is just that, simple
16:48:14 <ill_logic> Before, I was trying conduit's simple http, but that didn't seem to lazily save either.
16:48:41 <ill_logic> But, it was better than this. I want to keep this basic since i'm not learning, I'd rather do this a basic way just so I understand everything.
16:48:58 <ill_logic> Well, in the Real World Haskell, they describe File IO as being lazy by default.
16:49:04 <ill_logic> Why is HTTP different?
16:49:58 <blackdog> ill_logic: lazy IO is generally not a great idea
16:50:35 <blackdog> changes outside your program can cause it to return different data, which isn't referentially transparent
16:50:49 <ill_logic> I've heard varying opinions on the matter. Is it really a bad idea for something simple like downloading a file? Granted I'm also using async, maybe it gets complicated at that point.
16:50:52 <geekosaur> HTTP is also not the onlym or necessarily, the best way to do. its own documentation suggests Network.Browser...
16:51:07 <geekosaur> *only,
16:51:28 <geekosaur> ...no, that line needs far more correections that that, sigh. x.x
16:53:38 <ill_logic> So I should use Network.Browser to download and save files?
16:54:00 <maurer> When I try to build my code with profiling, I get     Dynamic linking required, but this is a non-standard build (eg. prof).
16:54:12 <maurer> I do not have any desire to dynamic link, but -static doesn't seem to help
16:56:09 <S_J> I know it cannot be done in haskell but is there some sort of typesystem where you can deifn e a type like : data Response = String (V1 | V2 | V3) where V1,V2,V3 are 3 different possibloe strings. So the string can only take 3 distinct values and no other values
16:57:45 <pentace> Why would you want to use strings of you can have data constructors?
16:57:45 <shelf> that can't be done in haskell? why not just three constructors?
16:57:45 <pentace> *if
16:57:48 <kier> S_J: define them as constructors instead?
16:58:27 <arkeet> data Response = V1 | V2 | V3
16:58:28 <blackdog> #haskell, where your questions are answered in glorious polyphony.
16:58:28 <arkeet> easy.
16:58:39 <arkeet> turn them into strings elsewhere.
16:58:44 <FreeFull> S_J: You could then have a Show instance to make your constructors easily convertable to strings if you want thtat
16:58:48 <FreeFull> that*
16:59:36 <tdammers> indeed. Much easier than starting with strings and then constraining their values - better start with the constrained values and figure out the string part from there.
17:23:28 <maurer> So, I have a list, and an expensive predicate, and I want to get an element from the list that satisfies the predicate
17:23:35 <maurer> Right now I'm doing
17:23:41 <maurer> head $ filter p xs
17:23:48 <maurer> Is there a way to parallelize this?
17:26:11 <zomg> Eargh...
17:26:21 <Cale> maurer: You could do  map fst . filter snd . parMap (\x -> (x,p x)) $ xs
17:26:29 <zomg> Why does time-1.4 export a Read instance for UTCTime according to Hackage
17:26:46 <Cale> maurer: Or probably you'd want to use something a little more refined than that.
17:26:49 <zomg> but when attempting to compile something that depends on that, with time-1.4 installed, it tells me there is no Read instance for UTCTime...
17:26:49 <shachaf> Maybe map foo :: (a -> Maybe a) or something like that.
17:26:53 <shachaf> parMap, I mean.
17:26:58 <zomg> fucking dependency hell :|
17:27:18 <shachaf> (And then catMaybes or something.)
17:27:20 <shachaf> I think JaffaCake's new book has an example like that.
17:27:22 <zomg> updated a package and all hell breaks loose...
17:27:36 <zomg> nuked .ghc and .cabal and shit still doesn't work
17:27:38 <zomg> fasdfgh
17:27:39 <zomg> :P
17:31:31 <monochrom> you have to import the right module, not just use the right package
17:32:01 <kier> If a module defines "data a :. b = a :. b", how would I import both the :. type and the :. constructor?
17:32:17 <monochrom> but it suffices to import Data.Time
17:32:45 <zomg> monochrom: well none of the code was changed until this dependency mess I ran into
17:32:56 <zomg> I mean the code is the same, it just somehow decided to break now
17:33:21 <zomg> The thing being I'm not actually seeing a Read instance in the UTCTime definition anywhere (looking at the source)
17:34:02 <monochrom> the instance code is in a hidden module. just bloody import Data.Time. works for me.
17:34:29 <lukexi> make
17:34:42 <lukexi> (heh, oops : ) )
17:34:44 <zomg> monochrom: yep works...
17:34:55 <zomg> monochrom: what I don't understand is how it ever worked with the Data.Time.Clock before
17:34:58 <zomg> :P
17:35:03 <monochrom> also UTCTime has had its Read instance for like two years
17:35:57 <geekosaur> kier: it's kinda ugly. import Foo ((:.)((:.)))
17:36:39 <tdammers> hmm, is it normal for cabal-dev upload to take this long?
17:37:00 <kier> switch from LISP to Haskell, they said. no more parenthesis hell, they said.
17:37:00 <geekosaur> some kind of issue with hackage, is my understanding
17:37:12 <geekosaur> takes forever, evnetulaly throws an error, but succeeds anyway
17:37:24 <geekosaur> kier, your fault for using type operators :p
17:37:54 <geekosaur> in standard haskell there wouldn't be an y parenthesis hel; there... because no type operators
17:38:16 <maurer> shachaf Cale: I tried that, and also tried a catMaybes version that works similarly
17:38:30 <kier> geekosaur: I was forced into it by Vec :o
17:38:36 <maurer> It seems to work, but consumes a ton of stack space and explodes
17:38:38 <maurer> I'm unsure why
17:42:42 <ubikation> does anyone know about how I could represent an adjacency matrix in haskell? I'm not really sure where to start
17:44:46 * hackagebot parcom-lib 0.1.0.0 - A simple parser-combinator library, a bit like Parsec but without the frills  http://hackage.haskell.org/package/parcom-lib-0.1.0.0 (TobiasDammers)
17:44:48 * hackagebot courier 0.1.0.0 - A message-passing library, intended for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.0 (PhilHargett)
17:44:50 * hackagebot courier 0.1.0.1 - A message-passing library, intended for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.1 (PhilHargett)
17:44:52 * hackagebot courier 0.1.0.2 - A message-passing library, intended for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.2 (PhilHargett)
17:47:00 <tdammers> ah, there it is
17:47:21 <tdammers> interestingly, my local cabal-dev still thinks it's uploading
17:51:30 <FreeFull> Heh
17:51:40 <FreeFull> Those versions changed awfully fast
17:53:14 <S_J> ubikation: an IntMap?
17:53:29 <S_J> or use one of the array types
17:58:07 <Twey> ubikation: Depends on the graph, I guess
17:58:49 <Twey> If it's bidirectional I might use something like a Map (Set Integer) Integer; otherwise you might want to use an actual matrix from hmatrix or something, or maybe just an array
17:59:33 <Twey> If it's unweighted you can use a Set (Integer, Integer)
17:59:46 <Twey> (all assuming your nodes are labelled with integers)
18:00:06 <Twey> Or bidirectional Set (Set Integer Integer)
18:01:32 <mekeor> are all three big haskell web frameworks (yesod, snap, happstack) suitable for a serious, big, resilient website? or which one would you recommend?
18:02:00 <danharaj> Snap
18:03:17 <mekeor> danharaj: okay. why?
18:03:47 <danharaj> Because it works and it doesn't have the ten inch layer of Template Haskell on top of it like Yesod does.
18:04:51 <zzing> When the \vdash symbol ( |- ) is used, what does it mean?
18:05:07 <Fuuzetsu> ⊢
18:05:17 <zzing> yes
18:05:41 <Twey> zzing: ‘Gives judgement’
18:06:16 <Fuuzetsu> http://en.wikipedia.org/wiki/Turnstile_(symbol) further reading
18:06:18 <Twey> zzing: Usually of a typing context on the left
18:06:45 <mekeor> danharaj: (a) all three web framework work; (b) TH doesn't have to be a bad thing?!
18:07:07 <zzing> Say an example like this: http://upload.wikimedia.org/math/1/e/2/1e22e9f4e12b82965a189e4c20e0bcbf.png   How would you read that?
18:07:39 <Fuuzetsu> in the context of Γ
18:07:39 <zomg> mekeor: I'm not much of a haskell pro but I was able to use Yesod to deploy a personal hobby project site at least =)
18:07:41 <pdxleif> Personally I'd just write in straight WAI.
18:07:44 <Twey> mekeor: I think they probably are now.  Yesod offers more type-safety for your buck, but it comes at the cost of being full of TH magic.  Snap is a pretty standard Web framework like you're probably used to from other languages.  Happstack is the oldest framework, and I hear it's pretty good now, but I haven't played with it for a long time.
18:08:02 <zomg> I find the TH parts in Yesod mostly can make debugging a bit hard sometimes but haven't really ran into anything totally crazy
18:08:26 <zomg> The type safety in yesod is certainly something I quite like and which is why I haven't really looked at the others that much since they don't offer as much of it.
18:08:35 <Twey> zzing: If the judgement ‘x is of type sigma’ is in context Gamma, Gamma gives rise to the judgement that x is of type sigma
18:09:07 <stepkut> zomg: say what!?! happstack has had more type-safety than yesod since before yesod existed
18:09:19 <zomg> stepkut: haha, I could be horribly wrong too
18:09:29 <zzing> You awoke stepkut! run for the hills!
18:09:46 <stepkut> zomg: type-safe urls, type-safe templates, type-safe database -- all existed in happstack long before yesod
18:09:47 <stepkut> ;)
18:10:17 <zomg> Yeah tbh I don't remember what exactly it was that made me choose Yesod
18:10:23 <zomg> I did look at Happstack as well
18:10:24 <stepkut> better marketing
18:10:28 <zomg> Possibly =)
18:10:32 <stepkut> yesod definitely has better marketing
18:11:04 <Twey> stepkut: Would you go so far as to say Happstack is strictly better than Yesod?
18:11:09 <zomg> Drives more of us web developers into learning about Haskell which I think is only a good thing =)
18:11:09 <stepkut> Twey: not yet
18:11:15 <mekeor> Twey: i see
18:11:26 <Twey> stepkut: What is Happstack missing that Yesod has?
18:11:52 <stepkut> Twey: yesod, for example, is currently faster that happstack by maybe a factor of 2. Also keter (deployment) is nice.
18:12:11 <Twey> Aha
18:12:18 <Twey> Thanks!
18:13:13 <stepkut> Twey: hyperdrive (the upcoming pipes-based HTTP backend) will likely be faster than warp and will provide a far greater level of assurance that it is faster and correct
18:13:25 <zzing> Twey, merci
18:13:53 <zzing> stepkut, what has occurred over the last year with happstack?
18:13:54 <Twey> zzing: De rien
18:14:39 <Twey> zzing: There's a lot of lore and notation in type theory.  I was pretty boggled by it at one point.  I recommend TAPL.
18:14:52 <mekeor> the most important criteria for me actually is that the server is resilient, that is, it can handle loads of requests and is stable as well as scalable etc..
18:14:55 <zzing> I will be looking for that book
18:15:10 <stepkut> zzing: happstack-foundation, a new released of HSP that uses Text and has a quasiquoter, a number of improvements to acid-state, the release and improvement of clckwrks, an (almost complete) conversion of the happstack crashcourse to a new build sytem that can target the kindle, pdf, School of Haskell, etc, and other stuff
18:15:18 <zzing> I have an interest, and might do a masters next year so it would be a good book to find
18:15:41 <stepkut> zzing: the hyperdrive backend has been mostly staled on pipes stabilizing -- but pipes gets better with each release
18:16:06 <zzing> Does sound interesting
18:16:08 <aristid> stepkut: is there a reason why you wouldn't use http-types btw?
18:16:12 <Twey> Wow, Happstack really seems much cooler than I remember.
18:16:13 <stepkut> zzing: and in the meantime, I have come up with an interesting system that can validate the low-level HTTP parser much better than anyone else is currently doing
18:16:53 <mekeor> o.O
18:17:04 <stepkut> aristid: other than being gunshy from being burning by yesod related projects in the past -- no reason that I particularily know of yet
18:17:26 <stepkut> aristid: the decision to use or not use  http-types is still undecided
18:17:34 <zzing> I tried all three main haskell web libraries last year, went with wordpress two months later, and now using jekyll and I am very happy with jekyll :P.
18:17:51 <zomg> I'm currently just building something lightweight on top of plain warp
18:17:53 <aristid> stepkut: it's not yesod related.
18:17:57 <stepkut> aristid: not enough information to tell if it is the rigth solution or not
18:18:02 * mekeor is using happs atm
18:18:07 <zomg> Want to see how well I could build an app without relying on a heavier framework
18:18:18 <zomg> A bit like in nodejs since there you can easily just mix n match whatever =)
18:18:26 <zzing> I do have a small project I was going to use php for
18:18:27 <stepkut> aristid: ah yes.. it seems snoymans name became attached later
18:18:29 <Twey> An HTTP library with session types would be nice
18:18:42 <Twey> Fuuzetsu: Hack project for friend?
18:18:48 <Fuuzetsu> Twey: what
18:18:51 <aristid> stepkut: if you do gather that information and there are things you don't like, let me know please.
18:18:51 <stepkut> aristid: I definitely like the idea of using http-types in the hopes of increasing interoperability
18:18:56 <stepkut> obsolutely
18:19:06 <aristid> stepkut: it only does some very very basic things
18:19:14 <mekeor> zomg: if you just needed a static site generator, why don't you use hakyll? :P
18:19:21 <zomg> mekeor: huh?
18:19:22 <Twey> Fuuzetsu: That guy you were planning on hacking code with.  That might be a nice thing to play with.
18:19:24 <stepkut> at present, hyperdrive does not use it because it keeps the codebase smaller and self-contained -- but hyperdrive is still just proof-of-concept until pipes-4.0.0 comes up
18:19:25 <aristid> really just some core types, but then why reinvent them every fucking time ;)
18:19:30 <stepkut> yeah
18:19:35 <zzing> stepkut, what is your thought on snap?
18:19:43 <zzing> by comaprison of what you know
18:20:04 <mekeor> zomg: you said you're using jekyll... why not hakyll? ;) :D
18:20:06 <Fuuzetsu> Twey: there are multiple people I could hack with… I don't want to touch web-related stuff
18:20:16 <zomg> mekeor: I don't recall mentioning jekyll
18:20:19 <Fuuzetsu> (if I can help him). Ask him. PING Shou
18:20:25 <zzing> mekeor, that is me :P
18:20:32 <mekeor> oh :D haha
18:20:36 <Shou> w-wat
18:20:38 <Fuuzetsu> if I can help it*
18:20:51 <zzing> mekeor, jekyll has a lot of people in #jekyll   is the same true about hakyll?
18:20:52 <Twey> Fuuzetsu: It's not really Web-related; it'd be more session types than anything else
18:20:59 <zomg> Yeah Wordpress is a good choice if you just want something that's easy for the end-user
18:21:01 <Fuuzetsu> Shou: when are you coming to hack
18:21:14 <zomg> but the wordpress codebase is... hateful.
18:21:16 <zomg> lol
18:21:23 <Shou> w-what should I hack on
18:21:28 <zzing> I actually use YAML now for some things like meetings
18:21:33 <zzing> It is filled by a template
18:21:33 <mekeor> zzing: there's #hakyll, yeah. also does the number of people matter if the library just works perfectly without any issues? :D
18:21:44 <zzing> So much better than addhoc
18:21:46 <stepkut> zzing: I've never really been clear of what the point of snap is
18:21:52 <zzing> mekeor, yes because the library never works perfectly
18:22:30 <mekeor> zzing: i was just joking anyway :)
18:22:47 <zzing> mekeor, fairly enough that #hakyll has a number of people comparable to #jekyll
18:22:48 <stepkut> wordpress is *in theory* great if you want something simple for the end-user -- except that due to php, it turns into a nightmare where the plugins and themes don't actually work with each other and break randomly after upgradse
18:23:02 <stepkut> which is why I started clckwrks -- but clckwrks won't be suitable for general use until clckwrks 3.0 :(
18:23:19 <zomg> stepkut: I've been using wordpress for a few years as the platform for my blog and it's been surprisingly painless to upgrade
18:23:20 <Fuuzetsu> Shou: I don't know, Twey is trying to shove some work this way instead of coding it himself.
18:23:22 <zzing> stepkut, how much has clckwrks moved in the last year?
18:23:24 * mekeor finds clckwrks a great idea
18:23:33 <zomg> every single time I've been scared of upgrading it because I expect everything to horribly break
18:23:38 <Twey> stepkut: That's a very high version number for ‘ready for general use’ :þ
18:23:45 <zomg> because that's generally what PHP apps do in my experience
18:23:53 <zomg> but every time it's worked perfectly :P
18:24:05 <zomg> which is even more surprising considering how utterly shit the codebase is...
18:24:06 <zomg> lol
18:24:18 <Twey> Fuuzetsu, Shou: I just figured it would be a nice, smallish, self-contained, but still interesting project if y'all wanted to hack.  No pressure :þ
18:24:19 <zzing> Let us praise how cool the language of PHP is and wonderful design.
18:24:53 <stepkut> Twey: version 1.0 is supposed to be good enough to make Haskell developers happen, version 2.0 is supposed to improve the facilities for theme developers, and 3.0 gets the auto-recomplication and plugin architecture so that you can one-click install themes and plugins and know absolutely nothing about Haskell
18:25:16 <Twey> stepkut: Not a fan of semantic versioning?  :þ
18:25:20 * mekeor things stepkut puts really very much effort into happstack (and clckwrks etc).
18:25:31 <mekeor> stepkut: thank you btw for those great packages :)
18:25:45 <stepkut> Twey: semanantic versioning?
18:25:58 <Twey> stepkut: http://semver.org/
18:26:04 <Shou> Twey, I'd love to work on something. What are you thinking of making?
18:26:42 <zzing> Twey, otherwise known as regular versioning?
18:26:45 <stepkut> zzing: it's gotten a fair bit more refined, but I would like it to be further along. Probably the most exciting change was moving the CMS/blog stuff to be a normal plugin instead of baked in
18:26:53 <stepkut> zzing: and then upgrading everything to the new Text based HSP
18:27:20 <Twey> Shou: I threw up the idea of an HTTP library with session types; I don't think there is one so far
18:27:34 <zzing> One thing I liked in jekyll is the liquid templates
18:27:48 <Twey> zzing: You'd think, right?  But in practice, no, very few people actually do that
18:27:59 <Fuuzetsu> Twey: is it not just the case of adapting this http://www.eecs.harvard.edu/~tov/pubs/haskell-session-types/ (I have not read it yet)
18:28:41 <Twey> Fuuzetsu: Largely; there's some room for experimentation in the adaptation, though
18:30:07 <Twey> zomg: Your Wordpress upgrade painlessness is achieved by the backs of thousands of testers.  :þ
18:30:41 <zzing> Twey, old english called, they want their thorn back
18:31:36 <Twey> zzing: I will never relinquish it.
18:31:42 <zzing> :Ð
18:32:36 <geekosaur> eth that!
18:32:55 <Twey> Heh
18:33:45 <nimish> is there a hackage package for dependent type-like vectors (lists with finite length?)
18:34:47 <Fuuzetsu> there are indexed vectors somewhere if that pleases you
18:34:50 <byorgey> nimish: yes, lots.
18:35:02 <nimish> any recommendations?
18:37:53 <Twey> byorgey: I was just trying to read your blog for clues, but it got replaced by a Tesco advert
18:39:02 <pharaun> i could use some advice regarding arrows - is there any good/easy way to group the data with arrows? IE i have abbbb abbbb abbbb where a and b are different value, i want to break it up into [[a,b,b,b],[a,b,b,b]] so on, is there a good way of doing this in arrows?
18:39:11 <pharaun> i've found a few ways but most of them feel rather awkward
18:40:10 <pharaun> I suspect the path i want is to convert it to list arrow, and then collect and operate on the list, but i'm not sure how to do  the collection step without probably using state ?
18:44:22 <Fuuzetsu> :t groupBy
18:44:23 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
18:45:08 <Fuuzetsu> how about split on 'a' and map ('a':)
18:45:37 <pharaun> so i'll need to convert it to a list then operate upon that?
18:45:56 <Fuuzetsu> I should probably read up.
18:46:09 <pharaun> yeah i think that can work, able to get a list via listA
18:46:23 <pharaun> feels... rather slow, i suspect its just my terminal being dumb :)
18:47:19 <Fuuzetsu> I hope that's not a joke on actual dumb terminals
18:47:40 <pharaun> urxvt seems to not handle tens of thousand long character line very good and become laggish
18:48:49 <Fuuzetsu> printing it is probably not the best way to time it
18:48:52 <pharaun> anyway i think you're right groupBy should be what i want :)
18:49:04 <pharaun> haha nah i'm just printing output as i build this arrow expression
18:50:36 <stepkut> clckwrks upgrades will be tested on the backs of thousands of CPU cycles
18:51:00 <pharaun> that's an awkward name :)
18:51:27 <pharaun> my finger keeps on wanting to say clockworks
18:51:46 <Fuuzetsu> 2cool4vowels
18:53:26 <pharaun> anyway neat
18:55:06 <pharaun> ok trying groupby let's see
19:04:31 <pharaun> Fuuzetsu: group by isn't quite what i needed but it kicked my brain and i think i got a function coming that does what i need :)
19:05:01 <ion> fuuzetsu: twclfrvwls
19:05:43 <Fuuzetsu> pharaun: I recommended split and preppend right after that which seems more suited
19:05:59 <shachaf> n: ndd
19:06:27 <fryguybob> tclfrvwlsrspcs
19:06:49 <MakTa> hey fryguybob
19:06:54 <Fuuzetsu> it's funny how all this is readable…
19:07:08 <pharaun> Fuuzetsu: yeah that's basically what i am doing or something like that :)
19:07:09 <ion> MakTa spams people with we’re-scared-of-people-with-different-skin-pigmentation forum links.
19:07:20 <Fuuzetsu> ^
19:07:23 <MakTa> has nothing to do with skin pigmentation
19:07:28 <MakTa> I am mexican
19:07:29 <MakTa> I am not white
19:07:30 <pharaun> most of what i am finding is splitAt or being *too* narrow but yeah its good
19:07:32 <MakTa> it has to do with race
19:07:34 <MakTa> not skin color
19:07:39 <MakTa> niggers in other words
19:07:41 <MakTa> not blacks
19:07:47 <MakTa> a lot of people from india have black skin
19:07:52 <MakTa> but we have no problem with those people
19:07:55 <MakTa> just negroidals
19:07:56 <MakTa> :D
19:08:00 <Fuuzetsu> MakTa: this is perhaps not the best channel for it though, take it elsewhere
19:08:04 <pharaun> ^
19:08:15 <zomg> !ops
19:08:29 --- mode: ChanServ set +o shachaf
19:08:34 --- mode: shachaf set +b *!*MakTa@187.153.35.*
19:08:35 <Fuuzetsu> rip
19:08:37 <ion> I’m not sure the average IQ on this channel is low enough for you to find manu followers here.
19:08:50 --- mode: shachaf set -o shachaf
19:08:50 <pharaun> manu ?
19:08:55 <Fuuzetsu> many
19:08:59 <Twey> UK football team.
19:09:00 <ion> pharaun: tpoy
19:09:04 <pharaun> ah
19:09:07 <Twey> Also makes perfect sense.
19:09:11 <zzing> What is the best way to have a range of numbers that goes through decimals? for instance, 0..1 every 0.01 increment
19:09:15 * Twey hides.
19:09:16 <pharaun> and *sigh* i just got privmsg'd by that person
19:09:28 <zomg> pharaun: Easy enough to ignore :P
19:09:30 <Twey> zzing: [0, 0.01, .. 1]
19:09:35 <Fuuzetsu> Twey: plsno
19:09:45 <Twey> (beware float inaccuracies)
19:09:49 <Fuuzetsu> enjoy that horrible Enum problem too
19:10:00 <zzing> awesome
19:10:03 <pharaun> zomg yup :) just would be nicer if i didn't have to
19:10:10 <pharaun> oh well
19:10:15 <Twey> Fuuzetsu: Enum problem?
19:10:59 <zzing> Twey, its for a graph
19:11:18 <applicative> > [0, 0.01, .. 1]
19:11:19 <lambdabot>   <hint>:1:11: parse error on input `..'
19:11:20 <pharaun> Fuuzetsu: perfect, found Data.List.Split, this is perfect, thanks :)
19:11:24 <applicative> > [0, 0.01 .. 1]
19:11:25 <lambdabot>   [0.0,1.0e-2,2.0e-2,3.0e-2,3.9999999999999994e-2,4.999999999999999e-2,5.9999...
19:11:28 <applicative> ick
19:11:57 <Fuuzetsu> pharaun: great
19:11:58 <Twey> pharaun: In your particular case you might be able to do it with ‘words’
19:12:15 <Twey> > words ["abbbb", "abbbb", "abbbb"]
19:12:16 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
19:12:16 <lambdabot>              with actual type...
19:12:17 <Twey> Er
19:12:22 <Twey> > words "abbbb abbbb abbbb"
19:12:23 <lambdabot>   ["abbbb","abbbb","abbbb"]
19:12:32 <danno1> Question (Noob): Does the point free style only work with one argument?
19:12:34 <Twey> (the strings are, of course, already lists)
19:12:36 <pharaun> Twey: that was example data :) there's no easy way to identify
19:12:41 <Twey> Ah, okay
19:12:57 <ion> danno1: It becomes exponentially more unreadable with more arguments.
19:13:00 <pharaun> basically its really like "foo", "bar1", "bar2", "foo2", "bar3", "bar4"
19:13:06 <Twey> danno1: Yes, but Haskell has only single-argument functions, so it's okay :þ
19:13:10 <ion> @pl \x y -> length x + length y
19:13:13 <lambdabot> flip ((.) . (+) . length) length
19:13:13 <lambdabot> optimization suspended, use @pl-resume to continue.
19:13:15 <pharaun> Twey: but yeah i'm familiar with words, words is great ;)
19:13:20 <pharaun> s/;)/:)/
19:13:26 <applicative> > map fromRational ([0, 0.01 .. 1::Rational]) :: [Double]
19:13:27 <lambdabot>   [0.0,1.0e-2,2.0e-2,3.0e-2,4.0e-2,5.0e-2,6.0e-2,7.0e-2,8.0e-2,9.0e-2,0.1,0.1...
19:13:29 <danno1> Thanks Ion
19:13:34 <Twey> ion, danno1: That can also be written as on (+) length
19:13:52 <shachaf> :t (+) `on` length
19:13:53 <lambdabot> [a] -> [a] -> Int
19:14:15 <ion> @pl \x y -> length x + 5*y  -- Let me revise my example
19:14:18 <lambdabot> flip ((.) . (+) . length) (5 *)
19:14:18 <lambdabot> optimization suspended, use @pl-resume to continue.
19:14:20 <Twey> ion, danno1: Two-argument point-free functions are not necessarily unreadable, but they can sometimes take more effort to construct, and there is an increasing chance that you'll end up with something horrible.
19:14:20 <haasn> :t liftA2 (+) length
19:14:20 <lambdabot> ([a] -> Int) -> [a] -> Int
19:14:27 <haasn> err
19:14:30 <haasn> :t join (+) length
19:14:31 <lambdabot> Num ([a] -> Int) => [a] -> Int
19:14:51 <applicative> curious Num instance needed...
19:14:56 <Fuuzetsu> > ([1.0,3..10], [1,3..10])
19:14:57 <lambdabot>   ([1.0,3.0,5.0,7.0,9.0,11.0],[1,3,5,7,9])
19:15:05 <haasn> applicative: I want it back :(
19:15:40 <ion> That’s a completely feasible Num instance. [a] ~ Nat, and an Int -> Int instance already exists. ;-)
19:16:02 <Twey> ion: uncurry (+) . (length &&& (5 *))
19:16:03 <haasn> http://hackage.haskell.org/package/NumInstances has it
19:16:05 <Twey> Problem?
19:16:28 <Twey> Oh, wrong number of arguments; never mind.  ☹
19:16:38 <ion> (Well, [()] ~ Nat, but it could be implemented with [a] using a couple of bottoms. :-P)
19:17:46 <haasn> Applicative f => Num (f a) -- for some ‘f’  is a completely well-behaved instance, too
19:18:01 <applicative> oh I wasnt doubting it
19:18:19 <haasn> (Applicative f, Num a) -- I mean
19:20:12 <pharaun> Fuuzetsu: (SL.split . SL.keepDelimsL . SL.whenElt) (isPrefixOf "Chapter") testData
19:20:17 <pharaun> exactly what i needed :)
19:26:51 <applicative> somehow haasn a = fmap read getLine * fmap read getLine + 1
19:27:06 <applicative> isnt striking me as as clear as possible...
19:27:08 <applicative> maybe
19:28:07 <applicative> haasn: is this instance somewhere? conal's 'applicative-numbers' seems more complicated
19:28:36 <haasn> applicative: (*) = liftA2 (*); (+) = liftA2 (+); fromInteger = pure . fromInteger; negate = fmap negate -- and so forth
19:29:06 <applicative> yeah http://sprunge.us/AHQQ
19:29:06 <haasn> so that expands to liftA2 (+) (liftA2 (*) (fmap read getLine) (fmap read getLine) (pure 1)
19:29:58 <haasn> well, it's not a good idea to define that particular instance
19:30:17 <haasn> this matches any type of the form ‘a b’ so you're getting a ton of overlap
19:30:34 <haasn> which is presumably why nobody has defined that particular instance; at least without a newtype wrapper
19:31:19 <applicative> hm, I guess conals package basically writes an instance for your applicative type constructor. (RealFrac etc as well)
19:31:39 <haasn> looks like it
19:41:54 <zzing> I am attempting to use the simple graphing api provided by Chart-0.17. But when I try to provide a function I get a very scary error ( https://gist.github.com/iaefai/2a96c83aaf3a6e5e084d ) in the source file ( https://github.com/iaefai/SubjectiveLogic/blob/master/beta.lhs ) when using ghci.  It relates to the 'PlotPDFType', but I have no clue on how to fix this. Any ideas?
19:43:44 <applicative> oh, zzing use  use -XNoMonomorphismRestriction
19:44:23 <edwardk> carter: ping
19:44:28 <carter> poing
19:44:33 <carter> sup?
19:44:56 <zzing> applicative, thank you, I completely missed it saying that
19:45:03 <applicative> zzing: or rather put {-#LANGUAGE NoMonomorphismRestriction#-} at the top. oh
19:45:13 <zzing> yeah, I do that directive :-)
19:45:21 <edwardk> bit twiddy thing you may care about. was doing path subdivision so i can describe how big the window is for going left/right/left through a tree that is arranged in that sort of 'break it up on powers of two' fashion
19:45:29 <edwardk> so i bothered to write the function to calculate the window
19:45:36 <edwardk> it was just non-trivial enough i figured it was worth sharing
19:45:37 <applicative> you can get rid of it by querying around to specialize some loose type somewhere, so to say, zzing
19:46:08 <carter> ohh
19:46:09 <carter> where?
19:46:13 <carter> link?
19:46:14 <edwardk> @hpaste
19:46:14 <lambdabot> Haskell pastebin: http://hpaste.org/
19:46:16 <edwardk> bah
19:46:35 <hpaste> edwardk pasted “2-fattest path evaluation” at http://lpaste.net/91732
19:47:04 <edwardk> >>> window (R (L (Top 20))) (,)
19:47:04 <edwardk> (8,8)
19:47:24 <edwardk> shows that if you went left from an array of 20 entries and then right you'd start at position 8 for an array of 8 entries wide
19:47:28 <zzing> applicative, now when I do that I still get this: https://gist.github.com/iaefai/2a96c83aaf3a6e5e084d
19:47:33 <zzing> when trying to call fig32
19:47:51 <edwardk> otoh, >>> window (R (Top 20)) (,)
19:47:52 <edwardk> (16,4)
19:47:53 <zzing> I added > fig32 :: (PlotPDFType a) => Maybe a    to try to fix it, but no luck
19:48:08 <edwardk> shows that the right hand side of an array of 20 entries has 4, decomposing in 2-fattest rather than balanced fashion
19:48:20 <carter> 2-fattest?
19:48:39 <edwardk> te 2-fattest number in [0..n) is the number that has the largest number of trailing 0's
19:48:59 <edwardk> its the decomposition you get if you break your array up as if it were in the next larger power of 2 in size
19:49:09 <edwardk> rather than trying to split 'fairly' down the middle
19:49:20 <carter> huh
19:49:52 <edwardk> splitting 20 fairly and going left and then right would yield an array (0,10)    and then (5, 5)
19:50:01 <edwardk> but thats not what we get when we decompose in 2-fattest fashion
19:50:18 <edwardk> see why i figured it was _just_ complicated enough to be worth explaining? =)
19:50:23 <carter> yeah
19:50:34 <carter> this is also designed for your structured case
19:50:44 <edwardk> yeah, where i'm always using morton, etc.
19:50:46 <carter> 3 way decomp
19:50:49 <carter> not 4 way :)
19:50:54 <edwardk> well, right now this is normal decomp
19:50:56 <carter> oh
19:50:58 <carter> hrmmm
19:51:02 <edwardk> you use this on each axis independently
19:51:02 <carter> whats Top mean?
19:51:13 <edwardk> Top 30   is just the path that starts at the top
19:51:18 <edwardk> this is the value level side of things
19:51:22 <carter> ok
19:51:39 <edwardk> the path is my way of tracking the size of my arrays
19:52:06 <edwardk> i was trying to nicely break down the shape in such a fashion that i can use the data-kind version of them as my type-level indexing parameters
19:52:07 <carter> so this is the 1d splitting
19:52:11 <edwardk> yeah
19:52:15 <carter> ok
19:52:17 <edwardk> you use 2 of these
19:52:29 <edwardk> that is your 'cursor' into the larger matrix
19:53:05 <carter> so this is working on the "index" space
19:53:11 <edwardk> yep
19:53:12 <carter> not the address space
19:53:12 <carter> ok
19:53:30 <edwardk> i was just trying to figure out how nicely to describe the masking i have to do on my keys, etc.
19:53:40 <carter> this is sort of shaving bits off
19:53:52 <carter> right?
19:54:04 <edwardk> yeah
19:54:21 <edwardk> then i track in the matrix itself the number size and offset in index space i've shaved off
19:54:28 <zzing> I got this thing to work in ghci by manually doing some things, I think <$> is doing some crazy
19:55:33 <carter> zzing whats it your hacking on?
19:56:16 <zzing> carter, this code: https://github.com/iaefai/SubjectiveLogic/blob/master/beta.lhs    and if I call 'fig32': I get this: https://gist.github.com/iaefai/2a96c83aaf3a6e5e084d
19:56:33 <carter> does it work if you just compile it?
19:56:38 <carter> instead of using ghci?
19:56:39 <lukexi> asking one more time case it rings a bell for anyone here now : ) — I'm building GHC HEAD on using LLVM 3.0 and GHC 7.6.2 and suddenly (i believe since switching to LLVM 3.0 from 3.4) tons of files in the GHC tree are having parse/syntax errors, either because layout is being misinterpreted or because of mixed tabs & spaces. I can super-tediously work around it by manually tab-to-space converting and re-indenting code, but I don't know
19:56:39 <lukexi> to debug it yet.
19:56:46 <zzing> However, if I do    let x = fromJust $ opinion (2%10) (5%10) (3%10) (6%10); graph "betafig32.pdf" 2 x          it works
19:57:13 <zzing> carter, no idea I am not treating this like a separate main module, only in ghci
19:57:19 <carter> lukexi: maybe you got a bad snapshot of head?
19:57:20 <zzing> ghci does compile it, it is runtime
19:57:27 <shachaf> «let Just x = ...» gives you a better error message than «let x = fromJust ...»
19:57:38 <shachaf> (They both crash your program, of course.)
19:57:55 <zzing> shachaf, of course this is just testing :P
19:57:55 <lukexi> carter: that was my suspicion but i've fresh-cloned it a couple of times
19:58:05 <edwardk> carter: so with that you get something like: data Matrix v a = Matrix { leadingZeroes :: {-# UNPACK #-} !Int, y0, x0, height, width :: {-# UNPACK #-}!Word32, matrixBody :: H.Vector U.Vector v (Key, a) }
19:58:08 <carter> lukexi does it work when you're not cross compiling?
19:58:08 <zzing> am I misusing <$> in fig32?
19:58:13 <carter> zzing: its too geenric
19:58:24 <carter> make it a specific type
19:58:26 <shachaf> zzing: OK, but it's shorter, so there's really no reason not to do it here. Just a good habit to get into.
19:58:42 <edwardk> and that has the nice side-effect that when you use Matrix Unbox ()    -- it has no real operational overhead above storing just the key set so boolean matrices can be cheap
19:58:53 <zzing> carter, I have no idea what this thing is supposed ot be for type - this whole function I am using is full of printf style magic
19:59:05 <lukexi> carter: i'll check that now
19:59:23 <carter> edwardk sweeeet
19:59:36 <cschneid> any vim users who can suggest how to auto-compile my project? I could map it, or use something like guard (file system watcher), but is there another approach you like?
19:59:39 <carter> ohh, because () has a cheap rep?
20:00:04 <edwardk> Unboxed.Vector ()   is represented by just its length
20:00:26 <edwardk> so the hybrid just stores an extra length it never even looks at and does a couple extra 'const ()'s
20:01:21 <carter> explain those matrix fields?
20:02:36 <carter> like, what do leadingzeros, y0 x0 mean?
20:02:37 <edwardk> y0 and height would be the results of running the windowing calc on one axis, x0, width on the other.   leadingZeroes is used to say how many bits you should shift the keys to the left to get the current 'most significant bit' in the most significant position
20:03:28 <carter> so thats basically so you can do the right correction on the keys to view them as a submatrix
20:03:29 <carter> right?
20:05:22 <edwardk> so if you give me a lower left quadrant of a matrix, we'll bump leadingZeroes by one, y0 will increase by the 2-fattest number on [0..height), height will reduce by it, but x0 will stay the same, while width will be reduced by the 2-fattest number in [0..width), and the vectors will be trimmed to the contiguous ranges that host their quadrants by a triple of binary searches for where the appropriate bit goes high
20:05:47 <edwardk> yeah
20:06:23 <edwardk> that way i don't rewrite the keys, just track the current 'mask' as a number of bits we're shifting them up by to put the most significant bit currently left in the msb of a word32
20:07:11 <edwardk> lzs is probably badly named
20:07:16 <edwardk> but its how i started thinking about it
20:07:44 <edwardk> and it can use 'bits' to calculate nlzs, for the initial value of it based on nlz (h .|. w)
20:08:36 <carter> ok
20:08:38 <carter> this is neath
20:08:54 <edwardk> i figured this was something that would b relevant to your interests
20:09:55 <carter> thanks
20:10:11 <carter> This gives me a nice story for when i do morton :)
20:12:49 <danharaj> edwardk: What is the relationship between Bound/Nested Data Type variable binding and this presheaf stuff I've found floating around?
20:13:44 <edwardk> carter: anyways with all of that, you get fromList in a single line:
20:13:45 <edwardk> fromList :: G.Vector v a => Word32 -> Word32 -> [(Key, a)] -> Matrix v a
20:13:46 <edwardk> fromList h w xs = Matrix (nlz (h .|. w)) 0 0 h w $ H.modify (Intro.sortBy (compare `on` fst)) (H.fromList xs)
20:13:53 <carter> i need to have some view projection machinery that works with every layout i suport
20:14:17 <lightquake> i'm going to be writing a lot of math-y code, so naturally I want tests. these tests are both going to be 'generate random data, pass it to this function, ensure certain invariants are true' and 'try this function with this specific input set, ensure a certain predicate holds on the output'
20:14:23 <lightquake> which testing library/suite do i want?
20:14:26 <edwardk> of course i had to go off and write 3000 lines of hybrid-vectors code the other day to support that ;)
20:14:36 <carter> edwardk: props
20:14:40 <edwardk> danharaj: no idea. write up an article and tell me ;)
20:14:53 <carter> danharaj what presheaf stuff?
20:14:54 <edwardk> lightquake: quickcheck
20:14:59 <danharaj> edwardk: haha perhaps by the end of the weekend I will know something you do not :P
20:16:10 <edwardk> sure, for one thing you know what 'this presheaf stuff I found' means. i mean that is a baggsian riddle if i ever heard one. "What have I got in my pocket?" =)
20:16:18 <edwardk> er Bagginsian
20:16:32 <danharaj> carter: https://www.era.lib.ed.ac.uk/bitstream/1842/221/1/Abstract_Syn.pdf http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.15.6140&rep=rep1&type=pdf
20:18:11 <danharaj> there are a few more in my papers list :P
20:18:29 <jmcarthur> lightquake: quickcheck for the random inputs. smallcheck is also worth looking at for that. they serve slightly different purposes. for the fixed inputs i have experience, but my understanding is that hunit is the go-to library for that. the whole thing can be glued together with something like test-framework
20:27:03 <carter> roman has that new one called tasty
20:27:17 <carter> jmcarthur any opinion on it?
20:28:42 <jmcarthur> no opinion. i haven't looked at it yet
20:29:18 <danharaj> it has a frivolous name
20:29:18 <carter> he did say he's committed tosupporting it and accepting patches for the next few years
20:29:21 <carter> true
20:29:26 <carter> testy would be worst though
20:29:45 <edwardk> should have been testy
20:29:52 <geekosaur> toasty?
20:29:55 <carter> is roman on channell?
20:31:27 * danharaj wishes there was a test framework in Haskell that accommodated shell scripting well
20:31:37 <danharaj> were*
20:32:17 <Saizan> danharaj: if that paper has the delta operator like others by Fiore, then that should essentially be Scope ()
20:33:17 <danharaj> Saizan: It does. Perhaps it is essentially Scope but keeps track of more information at the type level?
20:35:05 <Saizan> danharaj: well, that really depends on what you use as the category of contexts, if it's just FinSet it's untyped but at least you know how many vars, i guess Scope () is using Hask which makes it particularly uninformative
20:35:33 <danharaj> Saizan: Right. I have a few papers that extend it to typed context and then to typed contexts with quantification over type variables.
20:35:42 <danharaj> (And I'm sure I could find more elaborations on the idea)
20:37:18 <Saizan> oh, also, bound's examples all have a "return", while that framework should handle a more general case too, or at least soeqlog does
20:37:55 <Saizan> danharaj: yeah, afaik the dependent types case is being worked out, or at least i haven't found a publication explicitly fleshing it out
20:39:09 <danharaj> Saizan: I would like to experiment with doing type inference with this sort of machinery, so going from FinSet -> Set to richer structures.
20:39:41 <Saizan> danharaj: ah, that sounds interesting, i want to do unification with it
20:39:49 <danharaj> same difference :P
20:40:00 <Saizan> :P
20:40:51 <danharaj> Saizan: Are you using Agda? I'm thinking of trying to hack it in Haskell with as much singleton nonsense as I can.
20:41:39 <Saizan> danharaj: seen "Second Order Equational Logic"? it's a fairly concrete presentation starting from a model-theory-like signature, but there's a lot for it
20:41:57 <danharaj> Saizan: Ah, I haven't actually read that one yet, but I do have it on my disk.
20:43:05 <Saizan> danharaj: well, atm i haven't done anything explicitly using this stuff, i basically formalized pattern unification for STLC and then noticed the presheaves, so i've looked around and found this stuff
20:43:19 <danharaj> cool
20:43:56 <danharaj> I also found some stuff by Ahrens and Zsido that formalizes stuff in Coq but I am not sure what the relation is between this and their formalism.
20:45:44 <danharaj> Saizan: This is the most complicated construction I've found in this vein http://www.cs.gunma-u.ac.jp/~hamana/Papers/poly.pdf
20:46:53 <Saizan> danharaj: yeah, there's another by fiore where he sketches what you could use for something that has some dependentness in it, but i don't remember the name
20:47:13 <Saizan> danharaj: Second-Order and Dependently-Sorted Abstract Syntax
20:47:17 <Saizan> wasn't hard :)
20:47:40 <danharaj> ah that's cool
20:48:19 <Saizan> that Ahrens and Zsido paper looks interesting from the abstract
20:49:25 <danharaj> indeed
20:49:49 <danharaj> It would be doubly interesting to me if I could program/prove in Coq :P
20:49:50 * hackagebot handa-gdata 0.6.6 - Library and command-line utility for accessing Google services and APIs.  http://hackage.haskell.org/package/handa-gdata-0.6.6 (BrianBush)
20:50:16 <Saizan> heh
20:50:56 <danharaj> Modules over Monads and Initial Semantics is a really quick read that they use in their paper.
20:53:15 <Saizan> oh, that's from my advisor :)
20:53:30 <edwardk> dolio: ping
20:53:40 <dolio> Yo.
20:53:43 <Saizan> (the second author i mean)
20:53:56 <edwardk> dolio: is there a reason i can't seem to find a binary search for where some predicate goes from low to high in vector-algorithms? its all element based
20:54:06 <danharaj> Saizan: haha I guess this discussion would have bumped directly into you eventually :P
20:54:24 <edwardk> i want a binary search-based splitAt in the end, but i could live with just knowing the end-point
20:54:32 <dolio> I probably haven't written one.
20:54:32 <edwardk> i can write it myself, its trivial, but it struck me as odd
20:54:48 <edwardk> the fact that all those searches took elements struck me as odd is all
20:54:59 <carter> edwardk example?
20:55:05 <dolio> I haven't thought about it in a while.
20:55:23 <edwardk> carter: "find the position where we trip over into this quadrant" in morton order
20:55:31 <carter> ok
20:55:34 <carter> ohh
20:55:46 <carter> so no searches that exploit the ordering structure
20:55:52 <edwardk> carter: i can do 2 nested splitAts
20:55:59 <edwardk> well, 3
20:56:01 <carter> but?
20:56:15 <edwardk> but i want to use a binary search based splitAt
20:56:21 <edwardk> hence my inquiry
20:56:25 <edwardk> i'll just write it the boring way
20:56:46 <carter> whats the not boring way?
20:56:53 <carter> splitat is a scan?
20:56:56 <edwardk> yeah
20:57:00 <carter> bleh
20:57:07 <carter> orderedSplitat
20:57:28 <edwardk> nah you want a 'monotoneSpan' or whatever
20:57:50 <edwardk> where it finds an edge where the function goes from low to high
20:57:58 <carter> ok
20:58:09 <edwardk> if the function is monotone it therefore finds the only one, if its not you get an edge
20:58:31 <carter> ahh
20:58:42 <carter> http://hackage.haskell.org/packages/archive/vector-algorithms/0.5.4.2/doc/html/Data-Vector-Algorithms-Search.html ?
20:59:05 <carter> ohhh
20:59:13 <carter> wait, i still don't get it
20:59:24 <Saizan> danharaj: let me know if you flesh out more connections between these views
20:59:45 <edwardk> carter: yeah, those all take elements
20:59:46 <danharaj> Saizan: no problem. It'll come in weekend-like bursts.
20:59:50 <edwardk> rather than a predicate
21:00:09 <edwardk> you can fake the predicate search by using the one with a custom comparator and ignoring your element and what not
21:00:11 <edwardk> but its silly
21:00:12 <dolio> edwardk: I'm not sure all the element-wise ones are covered by that, but I can add them.
21:00:56 <edwardk> dolio: sure. just figured i'd mention it since, vector-algorithms is such a goodie-bag for me otherwise. =)
21:01:09 * danharaj is reading spj's original paper on STG and giggling at every design decision that was overturned over the years
21:01:22 <carter> i need to stare at vector-algorithms I guess :)
21:01:48 <pentace> "Mueval is POSIX-only" :(
21:02:47 <pentace> Is there another, more light-weight option to evaluate simple Haskell expressions?
21:02:54 <carter> ghc
21:02:58 <carter> :)
21:03:03 <danharaj> carter: what is heavyweight then?
21:03:10 <carter> edwardk
21:03:31 <danharaj> was that a zinger?
21:03:34 <carter> yes
21:03:36 <danharaj> zing
21:03:59 <carter> whats Really light weight it a mini language
21:04:02 <carter> thats not haskell
21:04:04 <Hafydd> Are you suggesting edwardk would perform the beta-reduction himself, or is it just a fat joke?
21:04:09 <carter> former
21:04:19 <edwardk> hey, i'm working on becoming less of a fat joke
21:04:35 <carter> i'm saying edwardk evaluation = you'll get a whole library a few days later
21:04:49 <carter> instead of the answer for a teeny expression :)
21:04:59 <Hafydd> Ah, so a software fat joke.
21:05:08 <carter> no
21:05:09 <danharaj> carter: hey, the last time I poked edwardk all I got was a library update.
21:05:41 <carter> only bos and simon marlow have fb poke powers
21:10:11 <NemesisD> question for you guys. i know a project that uses a TVar (Maybe Int) to wait on a HUP signal, on the signal it puts Just 1, on the waiting side, it does a readTVar and if its Just _  it writes Nothing back to the TVar, tretries otherwise
21:10:39 <arkeet> that's called a TMVar.
21:10:47 <johnw> yeah, was juts going to say
21:10:56 <NemesisD> so they're doing tmvar the hard way?
21:10:58 <arkeet> also you should probably use () instead of Int
21:10:59 <johnw> TMVar gives you blocking semantics if the TMVar is empty
21:11:06 <johnw> (or if it's full and your putting)
21:11:08 <cschneid> how do I hunt down an error like this:  Couldn't match type `ByteString' with `ByteString'
21:11:10 <danharaj> idk if that could be called the hard way
21:11:20 <arkeet> cschneid: probably mixing up lazy and strict
21:11:22 <johnw> NemesisD: right
21:11:23 <luite> cschneid: one is lazy one is strict
21:11:27 <cschneid> I checked the function I'm calling, and it's not lazy vs. strict afaik
21:11:44 <johnw> cschneid: it's remotely possible it's a package version mismatch, but I'm betting on lazy vs. strict
21:11:47 <luite> meh i'll bet it is :p
21:12:08 <NemesisD> i now maintain this package and was going to use an MVar, looked up the pattern in this and got confused as to why they went through all this work
21:12:18 <cschneid> import qualified Data.ByteString as SB (pack)
21:12:18 <cschneid> packThingy = SB.pack . map (fromIntegral . ord)
21:12:18 <cschneid> https://github.com/twittner/zeromq-haskell/blob/master/src/System/ZMQ3.hs#L574 -
21:12:47 <NemesisD> now is there a reason in this case to prefer TMVar over MVar?
21:12:47 <cschneid>  Z.setIdentity (Z.restrict $ packThingy "foo") socket
21:12:48 <johnw> cschneid: add a type for packThingy?
21:12:52 <cschneid> all parts there seem fine?
21:12:56 <cschneid> johnw: ok, let
21:12:59 <cschneid> let me give it a go
21:13:25 <johnw> NemesisD: if they're already using STM in places, the use of TMVar can compose with other transactions
21:13:47 <johnw> I tend to prefer all STM, switching down to MVar only if I determine it's truly necessary
21:14:12 <cschneid> argh, same problem
21:14:29 <johnw> cschneid: you are using OverloadedStrings I take it?
21:14:38 <johnw> what type does Z.restrict want?
21:14:42 <cschneid> johnw: I'm not.
21:14:54 <cschneid> the goal is to just turn a String into a ByteString for the purposes of this function call
21:15:09 <johnw> oh, you're mapping [Char] -> [Word8]
21:15:12 <cschneid> johnw: it's the ZMQ link to github I pasted a second ago - it's a ByteString
21:15:20 <NemesisD> johnw: are there inherant reasons to do that or is it just that you use STM enough that you know its going to pay off to use a TMVar?
21:15:32 <cschneid> johnw: well, maybe. Mostly I'm trying to turn a string "foo" into a bytestring that restrict will take
21:15:57 <cschneid> it's a c library, so I wouldn't be too surprised if it is a Word8 based string, so that's cool
21:16:11 <johnw> NemesisD: STM is easier to reason about, and it composes well; I really don't see a reason to use MVar.  It has some better fairness guarantees, and you can use IO while an MVar is "locked", but other than that I find STM better in nearly every way
21:16:49 <johnw> I actually dislike mixing atomicity with IO, and STM makes trying to do so a compile error
21:17:00 <NemesisD> fair enough
21:17:52 <cschneid> johnw: ok, it seems to build, but vim's syntax checker is throwing the error. Sorry for causing you issues
21:17:54 <johnw> cschneid: can you load this module in ghci and type: :t Z.restrict?
21:17:54 <cschneid> :-/
21:18:00 <johnw> ah, ok
21:18:09 <NemesisD> although likely I'm just going to be doing a lot of: void $ atomically $ takeTMVar wakeSig
21:18:12 <NemesisD> inside of io
21:18:26 <johnw> NemesisD: ah, but you're in STM
21:18:32 <johnw> now you can just use a TVar Bool
21:19:02 <johnw> void $ atomically $ check <<= readTVar wakeSig
21:19:07 <johnw> sorry, =<<
21:19:57 <johnw> i mean, that other guy's Just 1 vs. Nothing was just a Bool anyway
21:22:49 <zzing> Is there anything like zip :: [a] -> [b] -> [(a,b)]  except that one of the lists is (a -> b)?
21:23:14 <zzing> The values of b depend on the value of a passed in for each element
21:23:17 <danharaj> :t zipWith ($)
21:23:18 <lambdabot> [b -> c] -> [b] -> [c]
21:24:16 <zzing> :t ($)
21:24:17 <lambdabot> (a -> b) -> a -> b
21:25:20 <johnw> ($) is the function application operator
21:25:29 <johnw> f $ x = f x
21:25:47 <zzing> I know what it is, I am just working out how this transforms zipWith into that
21:25:53 <edwardk> carter: looks like i have something like the quadrants working
21:25:57 <danharaj> :t zipWith
21:25:57 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
21:26:00 <carter> ohhh
21:26:04 <johnw> zipWith ($) combines a list of functions with a list of arguments
21:26:24 <zzing> oh, I don't actually want a list of functions, just the results
21:26:34 <johnw> the result with be a list of results
21:26:42 <johnw> f x = zipWith ($) [f] [x]
21:26:43 <zzing> hmm, now that I think about it map would be maybe more appropriate
21:27:04 <johnw> err, [f x] equals that
21:27:12 <arkeet> :t zipWith `asAppliedTo` ($)
21:27:14 <lambdabot> ((b -> c) -> b -> c) -> [b -> c] -> [b] -> [c]
21:27:24 <arkeet> replace a with b->c in the type of ZipWith.
21:27:26 <arkeet> zipWith.
21:27:56 <pentace> > getZipList $ ZipList [succ, pred, negate] <*> ZipList [1,2,3]
21:27:58 <lambdabot>   [2,1,-3]
21:28:01 <arkeet> if you just want to use one function, then yes, that's the job of map
21:28:09 <danharaj> wait we can tell lambdabot to do unification?
21:28:21 <arkeet> @src asAppliedTo
21:28:21 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:28:24 <arkeet> oh.
21:28:25 <zzing> I am thinking given f :: a -> b, and xs :: [a];   zip xs (map f xs)
21:28:33 <johnw> map f xs = zipWith ($) (repeat f) xs
21:28:35 <arkeet> danharaj: asAppliedTo is a restricted version of const.
21:28:41 <arkeet> :t asAppliedTo
21:28:42 <lambdabot> (a -> b) -> a -> a -> b
21:28:57 <danharaj> tricky
21:29:38 <zzing> Some how the map version is more clear ot me
21:30:45 <hpaste> edwardk pasted “morton ordered sparse binary matrices” at http://lpaste.net/91735
21:31:32 <edwardk> carter: that should actually compile for someone who isn't me ;)
21:31:58 <carter> wooot
21:32:11 <edwardk> you can test it with quadrants (ident 3 :: Mat U.Vector Int)
21:32:19 <edwardk> i probably have some bugs left
21:32:25 <edwardk> because it literally just compiled
21:32:41 <carter> i'll play with it in a few days :)
21:33:10 <edwardk> bah, by then it'll be a full library or something ;)
21:33:30 <carter> hey, i need to get my stuff out tooo
21:33:31 <carter> :)
21:34:49 <edwardk> ok, first bug found. it tries to keep all the entries in the upper left quadrant even when they don't belong there
21:34:54 <edwardk> when using ident 4
21:34:56 <edwardk> ident 3 works
21:34:58 <edwardk> odd
21:38:11 <edwardk> fixed it. i was setting up leading zeroes wrong when it was a power of 2
21:39:04 <hpaste> edwardk revised “morton ordered sparse binary matrices”: “Bug-fixed morton order sparse matrices” at http://lpaste.net/91735
21:39:52 <edwardk> that seems to work correctly everywhere. so now that i have quadrants we can do matrix multiplication and i can get back to valiant
21:40:10 <imprgrmr> Why is the GHC so big? About 130 MB? (the Scala interpreter/compiler is just 12 MB)
21:41:29 <edwardk> imprgrmr: scala gets to run on the jvm. ghc is the moral equivalent of scala + hotspot
21:41:32 <edwardk> now compare again
21:41:57 <edwardk> they should come out about the same actually
21:42:31 <carter> but ghc has faster ffi :)
21:42:34 <edwardk> basically we have to have our whole runtime system
21:42:42 <edwardk> and scala gets to borrow theirs
21:43:03 <carter> yes
21:43:06 <carter> but we can patch ours
21:43:10 <carter> and do cool tricks
21:43:11 <edwardk> that said, we do get somewhat biggish binaries since we statically link, so its not as small as it could be
21:43:41 <edwardk> but the compiler's been growing for 20 years or so
21:45:48 <edwardk> scala has a little while to catch up =)
21:46:18 <imprgrmr> Can I write a smaller GHC so that my version works exactly as the original?
21:47:02 <edwardk> that sounds like a nice lifelong project
21:47:28 <edwardk> there are smaller haskell compilers, none as full featured as ghc
21:48:03 <johnw> edwardk: and won't linking be dynamic by default in 7.8?
21:48:16 <edwardk> will it? hadn't looked
21:48:41 <carter> think so
21:48:43 <johnw> https://lists.fedoraproject.org/pipermail/haskell/2012-November/000055.html
21:49:25 <edwardk> does that cover osx?
21:49:36 <carter> edwardk should be
21:49:37 <johnw> well, I've tried it manually and it all worked fine
21:49:39 <johnw> so I don't see why not
21:49:42 <carter> ghci is doing dylibs by default
21:49:43 <carter> in head
21:49:46 <carter> on most platforms
21:49:52 <carter> os x is one
21:50:08 <gienah> seems so as dynlinking is the default in 7.7.20130809 on linux amd64
21:50:08 <carter> not on freebsd and arm linux  though i think
21:50:20 <edwardk> k
21:52:25 <carter> all amd64 platforms but one of the BSDs that has a linker bug
22:02:32 <lq> P
22:28:15 <hashcat> I saw this in haskell-cafe: http://lpaste.net/91737
22:28:32 <hashcat> How can it be possible?
23:01:46 <isomorphismes> in LYAH he says """you can't use ++ in pattern matches. If you tried to pattern match against (xs ++ ys), what would be in the first and what would be in the second list? It doesn't make much sense. It would make sense to match stuff against (xs ++ [x,y,z]) or just (xs ++ [x]), but because of the nature of lists, you can't do that.""" How would xs ++ [x] differ from xs:x if ++ were allowed?
23:02:15 <isomorphismes> i.e. I thought : was the linking word, not ++
23:02:42 <roboguy_> isomorphismes: I'm not sure I understand. xs:x would match xs to the head of the list and x to the tail
23:03:42 <isomorphismes> Oh neermind it was answered a few sections ago. Sorry
23:05:15 <isomorphismes> roboguy_: x:xs joins an element to a list. xs++ys joins two lists.
23:06:48 <roboguy_> isomorphismes: yeah. so x:xs (which puts an element at the beginning of a list) is different than xs ++ [x], which appends something to the end of a list
23:09:34 <joelteon> prepending is O(1), appending is O(n)
23:09:46 <roboguy_> and xs:x is the same, but with different variable names: it puts xs at the beginning of the list represented by x
23:14:58 * hackagebot ewe 0.1.0.12 - An language to teach a programming  http://hackage.haskell.org/package/ewe-0.1.0.12 (JuanFranciscoCardonaMcCormick)
23:16:19 <arkeet> An language to teach a programming :-)
23:16:54 --- mode: ChanServ set +o mauke
23:16:54 --- mode: mauke set +b $a:MakTa
23:17:18 <pharaun> mauke: just ip ban the guy?
23:18:10 <mauke> pharaun: what would that be good for?
23:18:44 <pharaun> ban evasion? i thought that was the same guy who was in here earlier spouting some crazy stuff
23:18:55 --- mode: mauke set -o mauke
23:20:49 <mauke> you've lost me
23:21:02 <mauke> how is setting an ip ban good for ban evasion?
23:23:42 <pharaun> mauke: heh nvm, probably just me misunderstanding irc, i thought a regular +b on nick only banned the nick, but that they could come back with another nick (ban evasion) while ip would keep em off till they found a new ip?
23:23:59 <mauke> you can't ban on nick or ip
23:24:17 <mauke> a normal ban is matched against nick!user@host
23:24:31 <pharaun> ahh i see
23:24:41 <mauke> $a:foo is for account names
23:24:46 <zomg> Sure you can ban on nick, nick!*@*... but whether it's a good idea is another question :P
23:39:59 * hackagebot ewe 0.1.0.13 - An language to teach a programming  http://hackage.haskell.org/package/ewe-0.1.0.13 (JuanFranciscoCardonaMcCormick)
23:41:38 <imperative_progr> Remember: A website from Ireland is best viewed with Internet Exploder.
23:42:54 <elliott> imperative_progr: does this have something to do with haskell?
23:43:30 <imperative_progr> elliott: Just for fun. It has nothing to do with Haskell.
23:43:39 <mauke> I don't get it
23:44:22 <imperative_progr> mauke: The domain suffix of Ireland is .ie, right?
23:44:35 <mauke> oh
23:44:39 <mauke> you mean explorer
