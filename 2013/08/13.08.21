00:01:09 <Enigmagic> blackdog: i just posted our libxml2 bindings we use for xpath: https://github.com/alphaHeavy/xpathparser
00:01:42 <Enigmagic> may need some work to build... but it's processed millions of pages
00:02:24 <Enigmagic> 10's/100's something like that
00:21:19 <blackdog> Enigmagic: thanks, i'll check it out.
00:30:51 <blackdog> Enigmagic: why so much cut&paste in XPathParsers.hs?
00:37:08 <Enigmagic> blackdog: send a pull request, it works as-is though :P
00:37:27 <Enigmagic> it's 2+ years old and hasn't been touched since
00:37:38 <blackdog> fair enough.
00:46:37 <Gracenotes> when's the ICFP schedule actually going to be available?
00:49:26 <blackdog> Enigmagic: is there a reason you don't return a Maybe? throwing an error due to bad input seems a bit unhaskelly
00:57:54 <Gracenotes> ah. I see, it's called the 'program'
01:01:54 <raymank26> hi all. Why :t (fmap . fmap) :: (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b) ?
01:02:04 <raymank26> how to derive it?
01:05:54 <squimmy> hi all, i have a really naive question and it probably opens a rabbit-hole of related questions, but i heard you guys were friendly, so here goes:
01:06:05 <squimmy> is there such thing as a non-abelian algebraic data type?
01:06:40 <squimmy> (like, i really don't 'get' all this mathsy stuff, but i guess i'm trying to work it out, little-by-little)
01:06:46 <dpwright> I am trying to install contravariant 0.4.3 (as a dependency of blogliterately)
01:06:50 <dpwright> but I get the error:
01:06:51 <Gracenotes> raymank26: it's \f x -> fmap (fmap f) x, yeah
01:06:53 <dpwright> Data/Functor/Contravariant.hs:53:1: tagged-0.6:Data.Proxy can't be safely imported! The module itself isn't safe.
01:07:09 <Gracenotes> just by expanding (.), and then eta-adding the x
01:07:23 <Gracenotes> so you're mapping the outer structure with a function that maps the inner structure, informally speaking
01:07:30 <supki> dpwright: you need older contravariant/newer tagged
01:08:30 <maxiepoo> squimmy: what do you mean by non-abliean? What would be an abelian algebraic data type?
01:08:35 <raymank26> Gracenotes: I'm trying to derive this but I've no luck. fmap . fmap :: ((a ->b) -> f1 a -> f1 b) . ((a -> b) -> f2 a -> f2 b) yes?
01:08:44 <Gracenotes> squimmy: what kind of algebraic structure is/isn't commutative here?
01:09:23 <Gracenotes> raymank26: (.) isn't quite valid in types. What's confusing here is that (f2 a -> f2 b), in your notation, essentially becomes the first (a -> b)
01:09:30 <dpwright> supki: Ah!  I had got confused, because I recently installed pipes, which exports Control.Proxy, so I was looking there for the issue.  It's complaining about Data.Proxy!  Thanks, will try again
01:09:38 <Gracenotes> well, confusing or not, it's the point :p
01:09:55 <raymank26> hm..
01:10:04 <raymank26> well, but is the way to derive it?
01:10:20 <Gracenotes> okay, so you want something more methodical
01:10:25 <supki> dpwright: yeah, they're completely unrelated Proxies
01:12:03 <squimmy> maxiepoo, Gracenotes: the most common examples I see are tuples and unions, which map logically to multiplication and addition, which are abelian.
01:13:11 <Gracenotes> raymank26: sorry, got a bit disconnected
01:13:20 <maxiepoo> squimmy in the sense that Either a b is isomorphic to Either b a ?
01:13:35 <squimmy> i suppose cons lists are ADTs? but they are non-commutative, aren't they?
01:13:43 <maxiepoo> squimmy: or (a, b) is isomorphic to (b, a) ?
01:13:52 <raymank26> Gracenotes: yep
01:13:59 <Gracenotes> Okay, so part of Hindley-Milner, which is the type system/type inference system Haskell is based off of, is polymorphism.
01:14:46 <Gracenotes> What this means is that, whenever a symbol appears (such as fmap), it's initially given a completely fresh and most general set of types that *could* be what it ends up being at runtime, and that set is eventually whittled down.
01:15:06 <maxiepoo> squimmy: then (a -> b) would be non-abelian in that (a -> b) is not isomorphic to (b -> a)?
01:15:14 <maxiepoo> (in general)
01:15:24 <tac> a -> b and b -> a are not isomorphic
01:15:43 <tac> @djinn (a, b) -> (b, a)
01:15:43 <lambdabot> f (a, b) = (b, a)
01:15:46 <squimmy> but a function isn't a data type, it's a function, isn't it?
01:15:55 <Gracenotes> raymank26: so, anyway
01:15:57 <tac> squimmy: function types are types.
01:16:05 <Gracenotes> :t (.)
01:16:06 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:16:50 <squimmy> tac: are all types *data* types? (i don't know)
01:16:57 <tac> yes
01:17:06 <tac> the word "data" in "data type" is superfluous
01:17:18 <squimmy> oh
01:17:40 <tac> but some types are more "data-like" than others.. if you want to put it that way
01:17:48 <tac> But it's not really an important distinction
01:17:54 <earthy> phantom types? :P
01:17:56 <Gracenotes> raymank26: so we have (.) (fmap :: Functor f1 => (a1 -> b1) -> f1 a1 -> f1 b1) (fmap :: Functor f2 => (a2 -> b2) -> f2 a2 -> f2 b2) :: (b -> c) -> (a -> b) -> (a -> c)
01:17:59 <squimmy> that actually clarifies things, thanks
01:18:31 <Gracenotes> squimmy: have you seen http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/ ?
01:18:34 <Gracenotes> three part series
01:18:40 <squimmy> maybe this may be the wrong place to ask, then, but: why are not all languages with 1st-class functions considered to have algebraic data types?
01:19:03 <tac> because algebraic data type means something specific that "having first class functions" doesn't guarantee
01:19:06 <maxiepoo> also something like `data NonAbelian a b = One a | Two b b`
01:19:13 <squimmy> Gracenotes: i have not read this before. i will read it now. thank you.
01:19:26 <Gracenotes> raymank26: does that make sense? well, so the last (::) isn't exactly correct, but the point is that the function instantiated is fully general :)
01:20:07 <tac> Python has first-class functions, but no notion of an algebraic data type (or a static type at all)
01:20:31 <Gracenotes> what this means is, because (.) has type (b -> c) -> (a -> b) -> (a -> c), we can match up a, b, c and with what appears in fmap
01:20:51 <squimmy> good point. but surely you'd need more than just 1st-class functions and strict typing?
01:20:54 <Gracenotes> (this is a lot more formal than you'd normally do it, but, it's fairly mechanical)
01:21:10 <squimmy> are C# delegates algebraic data types?
01:21:13 <tac> no
01:21:15 <tac> they are not
01:21:26 <earthy> they are *weird*
01:21:41 <earthy> (because a C# delegate can have multiple dispatch, IIRC)
01:21:56 <Gracenotes> squimmy: when people say 'algebraic datatype', they usually assume you can do at least addition and multiplication, so to speak. See http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf for a really great comparison
01:21:59 <tac> An algebraic data type is a type declared with a list of constructors. A constructor is either a constant of that type (or type family) or a function whose codomain is that type (or type family)
01:22:00 <Gracenotes> including tradeoffs
01:22:43 <johnw> yeah, algebraic data types admit an "algebra of construction", giving a commutative semiring
01:22:45 <tac> So for a list, you have (essentially)..... [] :: [a]     and (:) : a -> [a] -> [a]
01:23:01 <tac> Anything you can build with [] and (:) is, by definition a List
01:23:18 <Gracenotes> raymank26: so what this means is that we can match up (b -> c) with (Functor f1 => (a1 -> b1) -> f1 a1 -> f1 b1), the first argument, and (a -> b) with (Functor f2 => (a2 -> b2) -> f2 a2 -> f2 b2), the second argument
01:23:20 <squimmy> (tac: sorry, but what's a codomain?)
01:23:36 <Gracenotes> raymank26: hm, following this a bit?
01:23:38 <tac> and conversely, to define a function by recursion on a list, it must be defined for both empty lists (that is, []) and conses (:)'s
01:23:43 <raymank26> Gracenotes: yes
01:23:58 <tac> squimmy: Every function has a type: A -> B for some types A and B. B is the codomain
01:24:01 <earthy> squimmy: there is an encoding of sum types in C#, plus classes and structs are obvious product types
01:24:11 <earthy> squimmy: so you can emulate algebraic datatypes in C#
01:24:26 <tac> Codomain is the "type returned by a function"
01:24:42 <tac> (although if anyone is listening, I'm making a very minor abuse of the word)
01:24:43 <earthy> squimmy: but it is not very intuitive, and the typesystem is not quite strong enough
01:24:45 <squimmy> cool
01:25:08 <Gracenotes> okay, cool. so, for instance (Functor f1 => (a1 -> b1) -> f1 a1 -> f1 b1) is the same as (Functor f1 => (a1 -> b1) -> (f1 a1 -> f1 b1)) in Haskell, due to associativity, so we can match {b == (a1 -> b1), c == Functor f1 => f1 a1 -> f1 b1}
01:25:08 <tac> Algebraic data types are great because they let you define functions by recursion
01:25:10 <earthy> I've translated 'Scrap your zippers' into C#, e.g.
01:25:27 <squimmy> these two links you guys sent look really good. i wasn't able to find anything this accessible by just typing words into google :(
01:25:30 <earthy> but it requires very deliberate type erasure
01:25:30 <squimmy> thanks :)
01:25:43 <Gracenotes> equality means "for this to typecheck, these have to refer to the same type"
01:25:48 <tac> If I have an algebraic type with some constructors, all I need to do in order to define a function on that type is to pattern match with one "branch" of the pattern match for every constructor
01:26:13 <Gracenotes> and, furthermore, with the second argument, {a == (a2 -> b2), b = Functor f2 => f2 a2 -> f2 b2}
01:26:17 <Gracenotes> *b ==
01:27:28 <Gracenotes> You'll notice that b == (a1 -> b1) and also b == Functor f2 => f2 a2 -> f2 b2. This means, doing this further, that Functor f2 => {a1 == f2 a2, b1 == f2 b2}
01:28:23 <Gracenotes> Okay. so popping back up a bit. If we replace all of the single-term type variables with what we've learned they are, in full gory detail
01:28:47 <Gracenotes> We started with: (.) (fmap :: Functor f1 => (a1 -> b1) -> f1 a1 -> f1 b1) (fmap :: Functor f2 => (a2 -> b2) -> f2 a2 -> f2 b2), and (.) :: (b -> c) -> (a -> b) -> (a -> c)
01:29:54 <squimmy> ok i think i'm going to have to go and read thoroughly through the links you have kindly provided me and come back when i don't have so many naive misunderstandings
01:30:15 <squimmy> thank you all very much. your reputation as friendly is well-earned
01:30:21 <tac> squimmy: Don't get discouraged. It's a lot to absorb
01:30:28 <tac> But it's fun once you get the hang of it.
01:31:48 <raymank26> Gracenotes: sorry for disconect
01:31:59 <raymank26> Gracenotes: continue?
01:32:01 <Gracenotes> yes, yes, still typing :)
01:32:07 <raymank26> cool :)
01:32:27 <squimmy> thanks :) the main problem i've been having is finding a starting point. all the information i've been able to find online assumes you already understand everything else
01:33:50 <adnap> Gracenotes: I jus read http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/. I don't know what the point of this is
01:34:12 <Gracenotes> raymank26: now we know this is: (.) (fmap :: (Functor f1, Functor f2) => (f2 a2 -> f2 b2) -> f1 (f2 a2) -> f1 (f2 b2)) (fmap :: Functor f2 => (a2 -> b2) -> f2 a2 -> f2 b2), and as a result, the type of (a -> c) is (Functor f1, Functor f2) => (a2 -> b2) -> f1 (f2 a2) -> f1 (f2 b2)
01:34:19 <jpcooper> hello
01:34:32 <jpcooper> can anyone direct me to a decent paper on the ST monad and why it is "pure"?
01:34:53 <johnw> jpcooper: it's pure because it has no effects beyond its own state
01:34:56 <haasn> it's pure because all mutation is self-contained
01:34:58 <Gracenotes> you'll notice that a1 and b1 are gone, because it turns out (as you see above) they were (f2 a2) and (f2 b2) all along.
01:35:01 <jpcooper> maybe including something on why it doesn't have to be run in the IO monad
01:35:15 <haasn> there's no IO or nondeterminism involved
01:35:17 <Saizan> jpcooper: it got introduced in a paper by SPJ
01:35:25 <jpcooper> haasn: does it need any collusion from the part of GHC?
01:35:27 <edwardk> adnap: you don't understand the point of being able to do arithmetic with types?
01:35:32 <adnap> edwardk: No
01:35:43 <jpcooper> haasn: I understand that, but I don't understand how it is run
01:35:56 <johnw> adnap: it makes understanding zippers much easier
01:36:00 <Saizan> jpcooper: it is run by unsafePerformIO, more or less
01:36:03 <raymank26> Gracentoes: it's confusing. :(
01:36:05 <Gracenotes> raymank26: and because we have fmap . fmap, the first fmap is (b -> c) and the second is (a -> b), so (a -> c) is the final result type. This matches the type of (fmap . fmap) that e.g. ghci gives you
01:36:10 <adnap> johnw: I already understand zippers
01:36:11 <haasn> jpcooper: it's implemented with understanding of GHC's internals
01:36:11 <johnw> in fact, I now grok differentiation because of zippers, rather than the other way around
01:36:18 <Gracenotes> raymank26: yes, I just ran through it very mechanically
01:36:24 <merijn> jpcooper: I thought the "Lazy functional state threads" paper introducing ST was pretty understandable
01:36:25 <jpcooper> I understand
01:36:28 <edwardk> adnap: Bool = 1 + 1, Either () () = 1 + 1      tells you that Bool and Either () () have the same 'number of nicely behaved distinguishable inhabitants'
01:36:29 <jpcooper> thanks
01:36:30 * hackagebot data-pprint 0.2.1.5 - Prettyprint and compare Data values  http://hackage.haskell.org/package/data-pprint-0.2.1.5 (PeterDivianszky)
01:36:32 * hackagebot comonad-transformers 3.1 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-3.1 (EdwardKmett)
01:36:41 <adnap> edwardk: So?
01:36:49 <merijn> jpcooper: It uses some minor Rank2Types, but I think those get explained in the paper too
01:36:57 <haasn> jpcooper: but this is mainly an operational concern that has to due with performance, ie. “true mutation”
01:36:59 <johnw> adnap: fine, don't do arithmetic with typse then
01:37:06 <Gracenotes> raymank26: what confuses you? too many type variables?
01:37:10 <edwardk> adnap: the nice thing about reasoning that way is that you can get to where you can see that '(Bool -> a)'  and 'data Pair a = Pair a a'   are different representations for the same amount of information
01:37:13 <haasn> which is more efficient than the reallocation and stuff you have when working with immutable data types
01:37:19 <jpcooper> yes, makes sense
01:37:24 <jpcooper> thanks for the tips. I should get back to work
01:37:27 <Gracenotes> too many not-easy-distinguishable type variables? -.-
01:37:28 <raymank26> Gracenotes: I thought about it like (.) is like unix pipes. But not in case of fmap . fmap
01:37:31 <haasn> that aside, as far as I'm aware, ST could technically be implemented in terms of pure State and immutable data types, but then you obviously lose the performance benefits
01:37:33 <adnap> edwardk: I understand that
01:37:45 <adnap> edwardk: But it doesn't seem useful
01:38:09 <merijn> haasn: No, you really can't
01:38:16 <raymank26> Gracenotes: particularly why function provided to result of (fmap . fmap) works in "inner" type
01:38:27 <haasn> merijn: Okay. Which part is missing?
01:38:31 <Gracenotes> raymank26: (.) is a bit of a higher-order unix pipe, yes
01:38:36 <edwardk> adnap: this leads to understanding how to implement memoization as a pure function, it leads to knowing 'how many distinct functions there can be of certain types, it leads to ways to look at the generating function for a type and find better representations for it. e.g. if you find the generating function for a type has catalan numbers for coefficients you know you can transform it into a binary tree.
01:38:37 <merijn> haasn: Unless you meant "any code that can be implemented with ST can potentially be implemented in a completely different way using State"
01:38:48 <merijn> haasn: Which is technically true, but also completely meaningless
01:38:53 <edwardk> adnap: well, i happen to have gotten a lot of use out of it. your mileage may vary.
01:38:58 <merijn> haasn: State has no notion of references, ST does
01:39:02 <raymank26> Gracenotes: but pipes work only of "result"
01:39:13 <raymank26> *on
01:39:40 <merijn> haasn: It isn't possible or meaningful to ask what the "location" of something is in State, it is in ST
01:39:43 <Gracenotes> raymank26: let's make it a bit more concrete, perhaps, with [Maybe a] -> [Maybe b]. What this will do is map Just a to Just b and Nothing to Nothing, for every element of a list, given (a -> b)
01:40:00 <merijn> haasn: Effectively ST gives you purely functional pointers + update on pointers
01:40:24 <haasn> merijn: what I meant is that you can code a drop-in replacement for ST that exposes the same API (runST, new/read/writeSTRef) but is entirely pure internally; the main difference being performance (even if by a huge margin)
01:40:38 <raymank26> Gracenotes: I know how to use such function, but I don't understand how haskell derive it :(
01:41:00 <edwardk> adnap: it isn't obvious that data Bazaar s a = Bazaar { runBazaar :: forall f. Applicative f => (s -> f s) -> f a } and  data Bazaar s a = Buy a | Trade s (Bazaar s (s -> a))   are 'the same'. yet that fact really is what lets most of the interesting combinators in lens be written.
01:41:05 <merijn> haasn: Maybe, but then you're just pointing out that they're both monads
01:41:11 <edwardk> adnap: that reasoning comes from the same kind of argument, just more advanced
01:41:22 <Gracenotes> raymank26: We have fmap :: (x -> y) -> [x] -> [y] for lists, right? (using more easily distinguishable variable names). So if we have a function (Maybe a -> Maybe b), this translates to fmap :: (Maybe a -> Maybe b) -> [Maybe a] -> [Maybe b].
01:41:35 <Gracenotes> All you do is substituted x -> Maybe a, y -> Maybe b.
01:42:11 <adnap> edwardk: Okay. I certainly don't understand that
01:42:25 <raymank26> Gracenotes: but why?
01:42:35 <merijn> raymank26: Why what?
01:42:37 <edwardk> adnap: my point is that rabbit hole runs deep. it led to lots of very deep results that makes lens go.
01:42:42 <Gracenotes> so you have fmap . fmap, or \f -> fmap (fmap f). The outer fmap doesn't *know* that the function it's being passed is actually fmap.
01:42:52 <raymank26> Gracenotes: why function composition works on inner type but not on result?
01:42:58 <raymank26> like pipes
01:43:10 <Gracenotes> raymank26: what do you mean by that, result?
01:43:11 <merijn> raymank26: It doesn't work on inner types
01:43:24 <edwardk> adnap: it also leads to the notion of the derivative of a type, zippers, combinatorial species point you to more general notions of abstract data types, etc.
01:43:36 <edwardk> i've used every single one of those things
01:43:51 <adnap> edwardk: How did you learn these things?
01:44:22 <edwardk> adnap: by not listening to my inner voice when it tells me something doesn't look useful until after i've picked up more than a cursory understanding of it ;)
01:44:26 <Gracenotes> hm, if you're asking about (.) in general, again, try to see why (fmap . fmap) is trivially the same as doubleFmap f x = fmap (fmap f) x
01:44:37 <edwardk> and by reading a lot of papers
01:44:43 <adnap> edwardk: Specifically?
01:45:00 <Gracenotes> hm "try to see why [...] trivially", famous last words
01:45:01 <edwardk> adnap: http://strictlypositive.org/diff.pdf
01:45:27 <raymank26> hmm
01:45:31 <raymank26> magic
01:45:32 <johnw> edwardk: I mentioned that about zippers
01:45:45 <Gracenotes> @src (.) -- right
01:45:45 <lambdabot> Source not found. I feel much better now.
01:46:05 <Gracenotes> ಠ_ಠ
01:46:13 <raymank26> :D
01:46:20 <edwardk> generatingfunctionology by herbert wilf lets you see how you can use formal power series to count lots of things, which led to http://kmett.com/reader/2008/generatingfunctorology/ sorry the main comonad.com link for it is down
01:46:23 <adnap> Has anyone done an big-o analysis of zipper?
01:46:47 <Gracenotes> all constant, all the time.
01:47:03 <edwardk> adnap: the zipper turns operations n steps down the list into O(1) operations because the 'head' is already there. instead of O(n)
01:47:05 <raymank26> f (g x) = (f . g) x
01:47:15 <edwardk> you pay to walk there, then you can do whatever you like.
01:47:20 <Gracenotes> yes. other way around, if you're defining it.
01:47:49 <adnap> So, doing some O(1) thing to each element of a zipper is O(n)
01:48:07 <edwardk> adnap: regarding the ring of types that comes up in lots of contexts.
01:48:38 <edwardk> adnap: sure. the zipper just provides you with the ability to 'focalize' positions other than the head of a list, so you can do lots of work there.
01:49:08 <Gracenotes> raymank26: in this case, I called the x there 'f', and added an unrelated 'x'. possibly confusing. but you could see why fmap (fmap f) x has the behavior of taking a function to map a list of anything to a list of anything, and using it to specially map a list of maybes to a list of maybes given a function to map anything to anything (a -> b)
01:49:11 <edwardk> it is an inversion of control, like an iteratee, that lets you pass around an 'open' structure in other code
01:49:29 <raymank26> :D
01:50:05 <juhp> anyone managed to compile conduit with llvm-3.3?
01:50:57 <Gracenotes> raymank26: if you're just passing data along, (.) has some very intuitive meanings, but sometimes it's used a bit more abstractly, idiomatically.
01:51:02 <juhp> I get: opt: /home/petersen/tmp/ghc31835_0/ghc31835_0.ll:8434:15: error: not enough parameters specified for call
01:51:02 <juhp> %ln4Go = call ccc i64 (i8*,i64,i64)* @open( i8* %ln4Gn, i64 0 ) nounwind
01:51:32 <juhp> (for [1 of 8] Compiling System.PosixFile)
01:51:50 <juhp> maybe I should try ghc-7.7
01:52:52 <raymank26> Gracenotes: In case of :t (\x -> fmap (fmap x)) I understand why result type is :: (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:53:00 <Gracenotes> > let mapIfResultPositive = (. filter (>0)) . map in mapIfResultPositive (+10) [-15, -10, -5, 0, 5, 10, 15]
01:53:00 <raymank26> hm...
01:53:01 <lambdabot>   [15,20,25]
01:53:30 <Gracenotes> ^ it's kind of difficult to understnd what (. filter (>0)) . map means, honestly, without thinking about it a bit
01:53:43 <Gracenotes> and without having used this idiom frequently lately
01:54:11 <raymank26> i need some practice for this
01:55:15 <Gracenotes> yeah, there are two maybe orthogonal concepts, which is how fmap composition works, and how (.) can really work for any pair of functions that match (b -> c) and (a -> b)
01:55:52 <hpaste_> johnw pasted “type algebra” at http://lpaste.net/92031
01:56:07 <johnw> adnap: ^^  that's a lens-related example of applying type algebra to understand the equivalence of types
01:56:23 <Gracenotes> maybe one of the key bits is that, in this case, a, b, and c are themselves all functions
01:56:47 <johnw> you can look at any ADT and apply traditional high-school algebra transformations to arrive at other, equivalent representations of the same type
01:56:56 <johnw> in this case, the transformed type is more efficient
01:57:03 <mauke> where did line 10 come from?
01:57:17 <johnw> mauke: algebraic laws for exponents
01:57:25 <johnw> i read it here: http://www.sparknotes.com/math/algebra1/exponents/section3.rhtml
01:57:51 <johnw> "2x^2 +5x^2 = (2 + 5)x^2"
01:58:33 <mauke> > let a = 2; s = 3 in (a^s + (s^a)^s, (a + s^a)^s)
01:58:34 <lambdabot>   (737,1331)
01:58:44 <johnw> huh, what did I miss?
01:59:21 <Gracenotes> raymank26: yeah, if there's any point of confusion, you can ask more if you think my answers sound vaguely correct
01:59:37 <mauke> johnw: your example doesn't use exponents
01:59:47 <johnw> aren't functions exponents in Haskell?
01:59:55 <mauke> 2*x2 + 5*x2 = (2 + 5)*x2
02:00:02 <mauke> this is multiplication
02:00:10 <raymank26> Gracenotes: thank you :)
02:00:11 <johnw> oh
02:00:18 <johnw> thanks for catching that mauke
03:19:40 <hpaste_> jmcarthur pasted “Fusion Sadness” at http://lpaste.net/92032
03:19:45 <h007> haskell function question:
03:20:07 <jmcarthur> ^^ not super important, just sad about it
03:20:24 <jmcarthur> i realize i could just tag my vectors with their lengths manually
03:20:44 <h007> i've read that there's nothing special about function really in haskell, they are just a type e.g. data (->) is the type. so func:: Int -> Int is the same as func :: (->) Int Int
03:21:23 <jmcarthur> they are special because they are primitive, but it is true that we don't really treat them specially
03:21:25 <h007> so what I'm trying to do is define a new function type (if this is possible anyway) e.g. data (-->) a b = (-->) a b
03:21:59 <jmcarthur> that as doable, although it doesn't really define a new function, but a data type with two fields
03:22:05 <h007> so then i want to define a new function like new_func :: (-->) Int Int
03:22:15 <h007> does this make any sense?
03:22:22 <jmcarthur> yes
03:22:52 <jmcarthur> functions are special in the sense that they are primitive, which means you can't actually construct them out of thin air the way you can ADTs
03:22:56 <h007> but then I can't really use the new type as a function type
03:23:00 <jmcarthur> right
03:23:28 <mauke> to write 'x y', x must be a function, i.e. have type (->) A B for some types A, B
03:23:32 <h007> e.g. func:: Int -> Int; func x =x+1  ; new_func:: (-->) Int Int; new_func = ??
03:23:33 <jmcarthur> however, you can define a type that is similar to a function. it just requires an interpreter for whatever representation you use
03:23:38 <h007> how do i define the body?
03:23:52 <mauke> h007: depends on the body of (-->)
03:23:53 <h007> right
03:23:58 <mauke> in your case it's essentially a tuple
03:24:08 <mauke> new_func = 1 --> 2
03:25:17 <h007> mauke: it's like hardcoding the function body for each possible input
03:25:29 <jmcarthur> no, it's just a tuple, really
03:25:33 <mauke> it's not a function
03:25:35 <jmcarthur> that is how you defined it
03:25:57 <jmcarthur> data (-->) a b = a --> b    is the same as   data Foo a b = Foo a b
03:26:33 <mauke> data (,) a b = (,) a b
03:26:42 <mauke> > (,) 1 2
03:26:43 <lambdabot>   (1,2)
03:26:49 <h007> right
03:27:27 <jmcarthur> you could instead define    data a --> b = Fun (a -> b)   which isn't quite the same as making a new function type from scratch, but at least allows you to represent functions as a different type
03:28:00 <jmcarthur> so then you would have   func = Fun (\x -> x+1)
03:28:11 <mauke> type (-->) = (->)
03:28:21 <jmcarthur> yeah but that's not even a new type
03:28:27 <h007> so, to sum up, functions in haskell are defined (internally/as primitive) to work as a type i.e. with kind * -> * -> *, is this right to say?
03:28:30 <mauke> it just occurred to me that all of this needs a recent ghc
03:28:46 <mauke> :k (->)
03:28:47 <lambdabot> * -> * -> *
03:29:08 <jmcarthur> h007: for all practical purposes, yes. ghc does something slighly magical with the kind, but it's not important here
03:29:11 <mauke> :k (->) Int
03:29:12 <lambdabot> * -> *
03:29:25 <jmcarthur> i'm surprised that isn't leaking into mauke's lambdabot session right now
03:30:15 <mauke> > () :: 1
03:30:16 <lambdabot>   <hint>:1:7: Illegal literal in type (use -XDataKinds to enable): 1
03:30:19 <h007> mauke: λ> type (-->) = (->)
03:30:19 <h007> λ> let func::(-->) Int Int; func x = x
03:31:16 <h007> using type synonym for the (type (-->) = (->) ) does make the new operator behave as a function, with pattern matching etc
03:31:16 <jmcarthur> h007: that should work (in recent ghc with extension) but doesn't really do anything special anyway
03:31:37 * hackagebot data-extra 2.2.0 - Extra utilities for working on Data.* types.  http://hackage.haskell.org/package/data-extra-2.2.0 (ChrisDone)
03:31:40 * hackagebot omega 1.5.2 - A purely functional programming language and a proof system  http://hackage.haskell.org/package/omega-1.5.2 (GaborGreif)
03:31:42 <jmcarthur> h007: that's because it is *literally* a function (doesn't even have its own type)
03:40:00 <mr-> Too bad.. data-extra is not in the platform
03:45:11 <jmcarthur> i've been using RecordWildCards for a while now, but i am finding it very error prone
03:45:35 <johnw> how so?
03:45:43 <johnw> i use them a lot
03:46:51 <jmcarthur> in this case, i have a function  proxyToDummy :: proxy a -> a  intended to use with stuff like sizeOf. i was using it with a field from a record, bound by record wild cards, but then i needed to distinguish between two such records in one function, so i switched it to not use record wild cards but forgot to change the use of the field where i was using that function
03:47:10 <jmcarthur> the field was a    Ptr a
03:47:26 <jmcarthur> so it silently changed the result type of that function
03:47:34 <jmcarthur> from  a  to  Ptr a
03:48:02 <jmcarthur> and what do you know, there is a sensible Storable instance for Ptrs, too
03:48:42 <jmcarthur> one might argue that it's proxyToDummy's fault
03:49:02 <mauke> I'd've called it unproxy
03:50:07 <jmcarthur> this name fits with a convention i have of actually calling dummy arguments  dummy
03:50:59 <jmcarthur> but yeah, no particular attachment to the name
03:51:20 <jmcarthur> in any case, i choose to blame RecordWildCards rather than proxyToDummy
03:51:38 * hackagebot throttle 2.0.0 - Throttle TCP/IPv4 connections to a given server at n bytes/second.  http://hackage.haskell.org/package/throttle-2.0.0 (ChrisDone)
04:01:00 <Cale> That's the main downside of that extension. Another smaller one is that it makes code quite hard to syntactically preprocess because it creates bindings without naming them explicitly.
04:01:04 <jmcarthur> maybe the problem really is proxyToDummy. after all, the problematic expression is expressible without RecordWildCards. it's just that RecordWildCards encouraged me to write it that way
04:01:30 <miasma> this looks quite bad http://bpodgursky.wordpress.com/2013/08/21/average-income-per-programming-language/
04:01:39 <Cale> (If your preprocessor needs to know what's in scope, it needs to know about the datatypes involved then)
04:02:19 <johnw> i've also run into a sporadic ghc bug when using "Foo {..} <- someMonadicAction"
04:02:26 <johnw> haven't quite been able to track it down yet
04:02:44 <johnw> so for now, I just never use it in that context
04:03:03 <Cale> That bar graph is really bad.
04:03:10 <Cale> The zero isn't zero.
04:03:12 <jmcarthur> miasma: i suspect it has to do with the fact that he only scraped data from organizations on github. it's a very biased sample.
04:03:40 <jmcarthur> in fact, the intersection of data he could get from github and that he could get from rapleaf
04:03:54 <Cale> If you drew it properly, it would be much flatter
04:04:11 <jmcarthur> oh wow that bar graph is really awful, yes
04:06:20 <miasma> jmcarthur: anyways, does it mean learning haskell is not worth the effort? i mean if you only develop with crappy languages, the code needs more fixing which means more paid work in the future
04:08:07 <merijn> miasma: FWIW there was a poll on earnings by programming language on HN a year or two ago which had haskell as the highest paid with >200k a year
04:08:07 <jmcarthur> if your only goal is to make a lot of money, haskell is probably not worth the effort, but i don't think many are likely to be deluded about that
04:08:23 <merijn> By far the highest on the chart at that time
04:08:29 <johnw> I hear COBOL makes a ton of money
04:08:38 <miasma> jmcarthur: not learning haskell also means you have more spare time to go out with women
04:08:42 <jmcarthur> simply knowing haskell may, in fact, increase your income, statistically, but meh, i made that up :)
04:08:46 <johnw> and I have a feeling that C++ may be the COBOL of the future
04:09:08 <merijn> johnw: I have an acquaintance who is working on disassembling to cobol :)
04:09:10 <miasma> everyone knows you need to use C++ when performance matters
04:09:20 <jmcarthur> i beg to differ
04:09:23 <merijn> miasma: That's utter rubbish
04:09:24 <johnw> miasma: are you being facetious?
04:09:37 <miasma> :P
04:11:48 * hackagebot tianbar 0.2.1.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.2.1.0 (AlexeyKotlyarov)
04:12:03 <merijn> How come so many people insist on writing such terrible blog posts? I mean, I know people keep saying that you should blog to get yourself known, but couldn't they at least try to write sound stuff >.>
04:12:05 <jmcarthur> both those of this blog post and a HN poll are extremely biased sources of data. i think the question is much harder to answer than some like to pretend it is
04:12:15 <merijn> But that's maybe a topic for -blah
04:12:35 <DaveS> is there a library function to pair two lists? [1,2,3] [4,5,6] -> [(1,4),(2,5),(3,6)]
04:12:45 <johnw> zip
04:13:12 <jmcarthur> > zip [1,2,3] [4,5,6]
04:13:13 <lambdabot>   [(1,4),(2,5),(3,6)]
04:13:26 <DaveS> perfect, thanks
04:13:51 <DaveS> > zip [1,2,3] [4,5,6,7]
04:13:53 <lambdabot>   [(1,4),(2,5),(3,6)]
04:35:35 <DarkFox> http://tryhaskell.com/
04:35:36 <DarkFox> wow
04:35:39 <DarkFox> Still......
04:35:58 <daGrevis> yi-0.6.7.0 depends on haskell-src-exts-1.14.0 which failed to install.
04:36:03 <daGrevis> any idea where I can get it?
04:36:51 <bennofs> Any reason "sum/product" in Prelude not using a strict accumulator? (http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#sum)
04:37:51 <Kneiva> daGrevis: why did it failed to install?
04:38:21 <daGrevis> Kneiva, http://vpaste.net/PHMao
04:40:08 <Kneiva> daGrevis: can you see some failure message further up?
04:43:08 <daGrevis> Kneiva, this is the full output http://vpaste.net/zsPol
04:43:15 <daGrevis> a lot of deprecation warning in there (
04:43:37 <DaveS> I'm using haskell-mode in emacs, is the 'let' block supposed to be slightly more indented than the 'in' block?
04:43:59 <DaveS> it's off by 1 column which seems odd
04:48:56 <quchen> bennofs: sum/product work for an arbitrary Num, so strictness annotations may not be necessary (or desirable?) for some types
04:49:56 <Kneiva> daGrevis: "setup: The program happy version >=1.17 is required but it could not be found." see if these suggestions might be of use: http://stackoverflow.com/questions/10095102/yi-failed-to-install
04:50:35 <quchen> bennofs: For example if you have the sum of a list of lazy Nats, you may not have to calculate all the contained numbers to decide whether the sum's result is larger than X
04:52:17 <quchen> (For most use cases a strict version would be useful though, not sure what GHC optimizes that function for Int to for example)
04:53:33 <hvr> DaveS: which indentation mode are you using?
04:54:12 <hvr> DaveS: (see http://haskell.github.io/haskell-mode/manual/latest/#Indentation )
04:55:20 <johnw> does GHC do "sufficiency" optimizations?  Like, when evaluating "sum xs > x", it would actually stop computing the sum once it knows the answer would be true?
04:55:34 <mauke> unlikely
04:55:58 <hvr> johnw: that'd have weird implications for bottom
04:56:07 <quchen> johnw: Hm right, that would only work if sum didn't have an accumulator, a la "sum (x:xs) = x + sum xs
04:56:08 <quchen> "
04:56:09 <hvr> johnw: i.e. what about 'sum [10,undefined] > 9' ?
04:56:26 <johnw> hvr: good point
04:57:07 <mauke> > sum [maxBound, 1]
04:57:08 <lambdabot>   No instance for (GHC.Show.Show a0)
04:57:08 <lambdabot>    arising from a use of `M347883224.sho...
04:57:11 <mauke> > sum [maxBound, 1] :: Int
04:57:12 <lambdabot>   -2147483648
04:58:17 <hvr> mauke: and then there's negative numbers... :-)
04:59:02 <mauke> > sum [1, -2]
04:59:03 <lambdabot>   -1
04:59:27 <quicksilver> you can do that for a suitably defined lazy integer
04:59:44 <quicksilver> you might be entirely happy that S (_|_) > Z
04:59:51 <quchen> johnw: But suppose data Nat = Z | S Nat, then sum [2,undefined] = sum' [S (S Z), undefined] Z = sum' [undefined] SSZ = sum' [] (SSZ + undefined) = SSZ + undefined
04:59:58 <quicksilver> but such constructions are not very general purpose
05:00:15 <quchen> And then the definition of "+" could be evaluated without getting to the undefined, allowing comparison with 1 for example
05:02:16 <quchen> I wonder why that function has an accumulator though. What's the use of that? Isn't the purpose of accumulators (when specified explicitly) that you can make them strict?
05:02:31 <quchen> Otherwise you're just moving the thunk around (instead of keeping it small)
05:03:03 <quchen> "sum (x:xs) = x + sum xs" sounds much more useful to me with respect to lazy nats, as it doesn't have to traverse the entire list for a result
05:07:16 <daGrevis> Kneiva, installed happy. now trying to install yi
05:07:47 <simon> https://gist.github.com/sshine/9b9e5e0f6294ee4f5fb8 -- I'm not sure what kind of type signature I need to add to make Control.Arrow.(first|second) work on tuples.
05:08:00 <simon> (i.e., the same code works when I enter it into ghci.)
05:08:38 <quchen> simon: (-1) is the number "minus one"
05:08:54 <quchen> Use `subtract 1` to do just that
05:08:55 <simon> quchen, ah! I'll go with (1-) then :)
05:09:05 <simon> okay.
05:09:05 <quchen> 1- isn't quite the same as -1
05:09:11 <simon> err, you're right.
05:09:23 <simon> (- 1) then. but thanks for subtract.
05:09:30 <quchen> No, that still won't work I think.
05:09:36 <tiffnya> ((-)1) maybe?
05:09:37 <quchen> The 'subtract' function is made just because of this scenario.
05:09:47 <avh> How would you write a function that turns 'a' into 1, 'b' into 2 and so on?
05:09:58 <quchen> ((-)1) = (-) 1 = (1 -)
05:10:07 <tiffnya> er, right
05:10:20 <simon> avh, idiomatically?
05:10:50 <avh> I just kind of need it to work, but I would like to see how to do it idiomatically
05:11:29 <quchen> > map (\x -> ord x - ord 'a' + 1) "abcdef"  -- avh
05:11:30 <lambdabot>   [1,2,3,4,5,6]
05:11:43 <avh> thanks
05:11:56 <simon> you could do: f c = ord 'a' - c + 1
05:12:04 <simon> err, what quchen said.
05:12:17 <simon> ord c - ord 'a' :P
05:12:50 <avh> didn't know about the ord function
05:13:29 <simon> its inverse is chr.
05:14:14 <quchen> avh: You can also use fromEnum/toEnum.
05:14:25 <quchen> avh: ord/chr are just specialized versions of that.
05:14:49 <carp> Hello, Ive been reading articles that the main Haskell website links to. One of the writers also wrote this short article: http://prog21.dadgum.com/3.html
05:14:53 <DaveS> how does lambdabot work? Just piping commands to ghci or something?
05:15:03 <johnw> DaveS: it's a program
05:15:07 <johnw> you can install it yourself locally
05:15:12 <carp> Its only a page long. What do you guys think about it?
05:15:15 <johnw> it uses mueval for evaluation of expressions
05:15:38 <johnw> which likely uses GHC API underneath, similar to ghci
05:16:59 <mr-> I can confirm that
05:22:22 <bartavelle> carp, I don't think the reason there aren't that many commercial games written in a functional language is that it is "harder" to do
05:22:44 <bartavelle> although there is no denying it will feel "awkward" to someone that is not used to it
05:22:46 <mbrock> carp: doesn't really make sense to me.  his example seems pretty straightforward to implement with a tick :: Game -> [Event] -> Game
05:23:06 <jpcooper> hello
05:23:11 <DaveS> Modern games have a huge tool chain and having to write a bajillion FFIs is just not worth it
05:23:17 <jpcooper> does anyone know about using the cassava (Data.Csv) library in constant memory?
05:23:19 <bartavelle> exactly
05:23:41 <jpcooper> I have a function that takes a record and outputs a record, and would like to output records as they are being read in from stdin
05:23:56 <jmcarthur_mobile> carp: well, there is a #haskell-game channel :) unfortunately I don't have the time to talk about it right now, though
05:24:38 <jmcarthur_mobile> carp: I think the argument has merits, but oversimplifies.
05:25:45 <jmcarthur_mobile> carp: I think part of the difficult is an implicit insistence on doing it "right" in a functional language even when the language isn't forcing you to, compared to an imperative style
05:25:56 <jmcarthur_mobile> *difficulty
05:26:36 <mbrock> physical interaction in a tick-based game loop is pretty tricky to get right imperatively too
05:26:57 <jmcarthur_mobile> And that's basically it. It's harder to have good practices in games because there are many data dependencies. It's not really just a functional programming issue
05:27:31 <jmcarthur_mobile> It's just that imperative style encourages a hack here and a hack there
05:28:26 <mbrock> people coming from the imperative world also sometimes fear "copying"
05:28:48 <mbrock> so if you show them "tick :: Game -> [Event] -> Game" they think "holy cow, you're going to copy the entire game world for every frame?!?"
05:29:08 <mbrock> but which isn't really how it works with immutable data structures
05:29:16 <jmcarthur_mobile> I would even further refine the claim to say that it's harder to *start* writing a game in functional style but harder to *finish* a game in imperative style. The former tends to happen a lot more often, so has more data points
05:30:26 <bartavelle> also you have tons of libraries / commercial middlewares / code samples for C++ games, which certainly helps a lot
05:31:48 <mbrock> I think programming "real applications" is extremely awkward in general :)
05:34:06 <mbrock> pretty much all software breaks horribly if you poke it in a slightly unexpected way, bugs abound...
05:34:45 <mbrock> and the stuff that works robustly does so because of a decade of bug squashing and a million dollars spent on QA
05:34:54 <quicksilver> jmcarthur_mobile: the imperative style also encourages undiscovered bugs
05:35:05 <mauke> the final frontier
05:35:17 <quicksilver> jmcarthur_mobile: what I mean is, in games in particular, there is quite a high tolerance of behaviours that actually aren't what the designer intended.
05:35:32 <mauke> see also: accidental feature
05:35:44 <quicksilver> jmcarthur_mobile: if it basically works, you tune it until it's fun - it doesn't matter if the logical intentions of your initial design were completely subverted by a mutable state error
05:35:54 <mbrock> yay bunny jumping
05:36:54 <quchen> s/bunny/rocket
05:37:29 <mbrock> there's a whole genre of youtube videos involving hilarious game physics bugs
05:37:36 <mbrock> it's way too much fun
05:38:20 <DaveS> my favorite is when the ragdoll invariably collapses into a seizure
05:39:36 <mbrock> http://en.wikipedia.org/wiki/MissingNo. :)
05:39:59 <benj_> skyrim helicopter animal glitches ;D
05:40:27 <DaveS> Or how pacman turns into a game by salvador dali at Level 256
05:42:31 <mauke> http://knowyourmeme.com/memes/get-down-geddan
05:43:47 <Zenol> In haskell code, I see a lots of "go" function, while processing/browsing/transforming ast. Did someone have a simple explanation of the idea behind?
05:44:16 <mbrock> do you have an example?
05:44:49 <quchen> Zenol: "go" is a meaningless name like "foo" and "bar". It's usually something like a "worker" or "thing that does the main job".
05:45:23 <quchen> It basically means "this doesn't deserve a name but I have to refer to it somehow".
05:45:38 <quicksilver> well there is a general pattern
05:45:47 <quicksilver> in which it's used to make a function non-recursive
05:45:58 <quicksilver> this is a rather specific accommodation to GHC's optimiser
05:46:28 <mauke> "go" isn't quite meaningless
05:46:49 <johnw> I use "go" to mean "the worker body for this function"
05:46:51 <mauke> http://www.haskell.org/haskellwiki/Worker_wrapper
05:49:38 <DaveS> mbrock: In the "tick :: Game -> [Event] -> Game" you said that the entire game world doesn't get copied each tick
05:49:40 <DaveS> what does happen?
05:49:42 <Zenol> mauke: In the revWorker case, when you get the first element of the list, the whole list was browsed, and in the first case, it browsed one step further when you nead one more element in the lazy list?
05:50:32 <Zenol> quche: I saw a go function in pandoc writers, but it's just a "dispatcher". I saw more strange use in some parsing libraries but I can't recall which one :(
05:50:51 <quchen> DaveS: Things that aren't changed are not copied. If you change the firs element of [1,2,3], then the [2,3] part is shared by both the old and the new list.
05:50:57 <quchen> There's no need to make a full copy of the entire thing.
05:51:11 <mauke> Zenol: I didn't look at the code
05:51:19 <DaveS> I see, so it basically forks the previous tick?
05:51:27 <DaveS> sort of like source control or something?
05:51:44 <quchen> So "apply f to first element of [1,2,3]" gives you two lists in memory: 1:x and f 1:x where x = [2,3]
05:52:10 <Zenol> mauke: revWorker s (x:xs) = revWorker (x:s) xs instead of reverse (x:xs) = reverse xs ++ [x].
05:52:26 <quchen> DaveS: No, sort of like when you change the first element of a linked list you don't have to touch any of the other entries because they don't reference what you've changed
05:53:08 <quchen> DaveS: On the other hand you can't simply do that with a doubly-linked list, and that's the reason nobody uses those in Haskell: updating one element requires you to re-allocate every single (:) of that list
05:53:40 <DaveS> so what happens when you add something, remove it and then add it again? is all of that stored in the linked list?
05:54:01 <Zenol> mauke: anyway, thanks :)
05:55:40 <quchen> DaveS: If you want to think of it in C terms, a Haskell value is a constant pointer to another value. So "x = 3" creates a pointer "x" which will show you the memory location of a "3" somewhere. With that principle in mind, [1,2,3] actually looks like "1 : rest" where "rest" is "2 : rest'" where rest' is "3 : rest''" where rest'' is "[]"
05:56:32 <quchen> Now if you take the list "1 : rest" and replace the 1 with a 2, you'll get "2 : rest". You have to create a new (:) and put the 2 in there, but the value 'rest' can be shared among both the old and the new list.
05:57:47 <DaveS> does haskell do any sort of automatic memoization?
05:58:13 <merijn> DaveS: No
05:58:46 <merijn> DaveS: But, if you add something, remove something then add it again the tail will be shared
05:58:53 <mbrock> http://en.wikipedia.org/wiki/Persistent_data_structure has some info and examples, DaveS
05:59:06 <carp> Thankyou very much for all the replies
05:59:16 <mbrock> especially the "Trees" example is quite instructive
05:59:24 <merijn> DaveS: i.e. those operations only result in 2 extra allocations (the first new head element and the second new head element) all other items are just reused
05:59:40 <quchen> Does anyone have the link to that site that explains Haskell evaluation using diagrams?
05:59:47 <quchen> With boxes and arrows and stuff
05:59:50 <merijn> DaveS: Since the original list is immutable you don't have to worry about someone changing/updating it
06:00:18 <johnw> DaveS: having persistent data really changes the way you think about memory usage
06:00:58 <companion_cube> lemao: still interested in Datalog's stratification?
06:04:30 <carp> bartavelle mbrock jmcarthur_mobile thankyou
06:06:16 <mbrock> having said all that, I'll add that optimizing Haskell for real-time performance is unknown territory to me and seems somewhat scary
06:06:18 <mike2135> i have x from 0.0 to 100.0 as a string
06:06:37 <mike2135> how do i quickly write a switch for four different output strings, zero low med high, based on the 0-25, 25-50, etc.?
06:06:47 <mike2135> best practices
06:07:20 <mbrock> like in the situation where you need to deliver 60 FPS of complex simulation, while the programming of the domain logic might not be terrible, you'll probably encounter awkwardness in getting it to perform
06:08:23 <mike2135> n/m
06:09:14 <mee> re: writing games in a functional language, lookup "The Next Mainstream Programming Language" slide deck by Tim Sweeney if you haven't seen it before
06:09:50 <DaveS> Yeah, Tim Sweeney just helped write a new paper on some sort of functional language recently
06:10:05 <quchen> mike2: A dirty way of getting a number out of a string is using `read`.
06:10:23 <quchen> Oh, he left and I messaged some other guy. Sorry
06:11:11 <apfelbox> Is there a print function for just printing everything in a reasonably readable way?
06:11:21 <apfelbox> like a debug print
06:11:39 <johnw> it's called "print"
06:11:45 <quchen> :-P
06:12:07 <mauke> @src print
06:12:07 <lambdabot> print x = putStrLn (show x)
06:12:08 <johnw> i know, i know, not the most intuitive name
06:12:17 <mauke> SAQ
06:12:24 <johnw> SAQ?
06:13:34 <merijn> apfelbox: Are you looking for something to use while debugging?
06:13:42 <apfelbox> Yes
06:13:46 <DaveS> @src ord
06:13:46 <lambdabot> Source not found. My brain just exploded
06:13:50 <apfelbox> And I am not always in the IO monad, so..
06:13:59 <merijn> apfelbox: Debug.Trace specifically Debug.Trace.trace :)
06:14:09 <mauke> johnw: self-answering question
06:14:12 <merijn> apfelbox: Completely unsafe, obviously. But great for debugging
06:14:25 <merijn> @quote oasis.of.referential
06:14:25 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
06:14:55 <mike2135> what happened to hpaste?
06:15:00 <quchen> Remember to only go to an oasis to freshen up, not to live there permanently.
06:15:11 <merijn> mike2135: Server got changed, domain name owner not reachable to point to the new host
06:15:16 <quchen> mike2135: "lpaste" now.
06:15:17 <mike2135> weird
06:15:17 <merijn> mike2135: tl;dr use lpaste.net for now
06:15:39 <mauke> johnw: like the other day we had someone in #perl asking how to compute the length of a string
06:15:47 <hpaste_> mike2135 pasted “why does this not work” at http://lpaste.net/92034
06:16:11 <mike2135> ignore clamp
06:16:21 <merijn> mike2135: Eh, you need to be more specific about what "doesn't work" means
06:16:34 <apfelbox> Hmm, not quite. My problem is: I need to (= school assignment) write a ghc plugin to transform haskell code to another language.
06:16:39 <merijn> mike2135: Does your computer catch on fire? Does it crash? Did it convince your cat to murder you
06:16:51 <mike2135> it compiles, the console for xmonad gies me a Prelude.read: no parse
06:16:51 <apfelbox> I am fairly new to both Haskell + GHC but don't have a problem with getting my hands dirty ;-)
06:17:03 <mike2135> any obvious ugliness in the code?
06:17:09 <merijn> mike2135: oh, you're using read somewhere and it...doesn't parse :)
06:17:23 * mike2135 thinks
06:17:25 <apfelbox> But the documentation on GHC plugins is pretty sparse, so I wanted to find my way by just dumping everyone and everything as debug output
06:17:29 <merijn> mike2135: You use "read x" in the first function, what if x is not a float?
06:17:36 <merijn> > read "test" :: Float
06:17:37 <lambdabot>   *Exception: Prelude.read: no parse
06:17:40 <daGrevis> How can I remove packages using cabal?
06:17:40 <mike2135> i thought read x turns it into a float
06:17:42 <merijn> > read "1.0" :: Float
06:17:44 <lambdabot>   1.0
06:17:52 <mike2135> i guess i have to check it
06:17:54 <quchen> mike2135: You can also delete all of the "<=" comparisons. And you should add an "otherwise" clause.
06:18:10 <quchen> OOps, delete the ">", not the "<="
06:18:19 <quchen> That would've been bad :-)
06:18:36 <mike2135> i was about to say
06:18:47 <mike2135> can i write to console what "c" is
06:19:01 <merijn> mike2135: Debug.Trace.trace :)
06:19:10 <mike2135> do i have to use do
06:19:20 <quchen> And doing "==" on floats is generally not a good idea.
06:19:38 <quchen> > 0.3 == 0.1 + 0.2
06:19:39 <merijn> mike2135: No, Debug.Trace.trac is a ugly debugging hack, you can use it anywhere, but isn't safe for non-debug use
06:19:39 <lambdabot>   False
06:20:23 <merijn> apfelbox: You might want to visit #ghc and the ghc mailing list for help with hacking on GHC
06:20:23 <mike2135> i wonder why it can't parse
06:20:46 <mike2135> ugh i dont haev the command on here...wtf
06:20:49 <merijn> apfelbox: People there might be able to provide more constructive help
06:20:58 <mike2135> that would do it
06:22:09 <apfelbox> merijn: thanks :)
06:24:13 <mike2135> "No summary specified" = ?
06:24:38 <mike2135> oh n/m this is outside haskell territory
06:24:55 <DaveS> fiddling with xmonad or something mike?
06:24:58 <mike2135> needed a space
06:25:02 <mike2135>  oh wow! look at that 8-)
06:25:07 <mike2135> gtk volume notifications
06:25:50 <mike2135> fancy
06:27:48 <mike2135> yes xmonad
06:32:41 <mike2135> notify-osd is idiotic, ignores timeout parameter...
06:49:18 <applicative> wow 1159 nicks on the channel and no opaque type errors to interpret?
06:49:53 <mike2135> applicative: only the transparent types hanging out in here ATM
06:49:55 <donri> > fix error
06:49:56 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
06:51:52 * hackagebot ftphs 1.0.9.1 - FTP Client and Server Library  http://hackage.haskell.org/package/ftphs-1.0.9.1 (JohnGoerzen)
06:53:34 <mauke> > fix fail
06:53:35 <applicative> ah i see mike2135
06:53:35 <lambdabot>   ""
06:55:24 <applicative> oh, john goerzen is uploading things again
06:57:14 <edwardk> he lives
06:57:23 <johnw> and so does FTP, apparently
06:59:43 <edwardk> somebody had to write it
07:00:09 <danharaj> who is john goerzen?
07:00:18 <johnw> he wrote offlineimap, among other things
07:00:26 <johnw> and lots of Emacs stuff
07:00:35 <danharaj> ah
07:00:50 <danharaj> Maybe AudreyT will start uploading things again :P
07:00:52 <WraithM> Also, RWH, no?
07:00:54 <tikhon> he was also one of the RWH authors, wasn't he?
07:01:08 <WraithM> Google says yes.
07:01:14 <edwardk> danharaj: the least well known author of RWH
07:01:17 <tikhon> and Google never lies
07:01:33 <edwardk> tikhon: yeah
07:01:46 <shachaf> He's CosmicRay in here.
07:02:15 <tikhon> Doesn't he also work at a somewhat surprising company—making lawnmowers or something?
07:02:34 <edwardk> CosmicRay doesn't go by some permutation of his real name, so nobody knows who he is ;)
07:02:49 <WraithM> lol
07:03:01 <CosmicRay> just the way I like it
07:03:09 <edwardk> heh
07:03:21 <johnw> whois, however, identifies him as such :)
07:03:48 <johnw> CosmicRay: so do you write lawnmower drivers now?
07:03:49 <shachaf> tikhon: That em-dash looks way too much like a regular dash in my font.
07:04:18 <CosmicRay> johnw: heh, excellent memory.  I actually have been working for a different company for the past 1.5 years
07:04:28 <tikhon> Which font? I'm using Deja Vu Sans Mono and I can tell - and — apart. However, – and — are completely indistinguishable.
07:04:50 <tikhon> It's hard to display characters that differ only by width in a monospace font :P
07:05:02 * quicksilver isn't sure how CosmicRay is the least-well-known of the three.
07:05:14 <shachaf> You could write " -- " instead.
07:05:23 <shachaf> It looks better anyway.
07:05:29 <tikhon> No, it looks worse
07:05:31 <CosmicRay> heh, I'm never offended at basking in anonymity ;-)
07:05:38 <tikhon> unless you're using an unfortunate typeface
07:05:51 <quicksilver> well if edwardk just meant your IRC nick is the least well-known then sure :)
07:06:27 <CosmicRay> heh.  I picked this nick when I was 12.  not entirely pleased with it anymore.  but, meh, too late to change, right? ;-)
07:06:41 <tikhon> you just need a catchy, short nick like bos or dons
07:06:49 <edwardk> quicksilver: i didn't mean anything bad by that. just that dons was painfully outspoken n reddit back in the day and dragnetted tons of folks into #haskell, and bos ran around shilling for mailrank and what not, and since both of them were on channel under real names they got instant recognition.
07:07:03 <CosmicRay> tikhon: my initials are jpg.  this leads to confusion ;-)
07:07:11 <tikhon> actually, that would be an awesome nick
07:07:54 <FreeFull> What's the recommended memoization library? There are so many
07:08:07 <mauke> I can never remember
07:08:16 <quchen> I like data-memocombinators.
07:08:22 <quchen> Serves me well at least for simple tasks.
07:08:33 <CosmicRay> or I could use my vaguely unpronounceable (in an unambiguous way, anyhow) gmail username.   rm.rf.dotstar
07:08:39 <shachaf> When you find out, make sure to tell the authors of all the other ones that they can stop bothering with theirs.
07:08:44 <tikhon> in the spirit of Hackage, somebody should now release memocombinators and memocombinators-data to make things a bit more confusing :)
07:08:55 <edwardk> CosmicRay: heh, i switched from "harmless" my pseudonym for ~10-15 years when I joined the channel. it means everything i do now i have to worry about it affecting people's perception of me 10 years down the road, etc. but it has been ridiculously good for name recognition. Switching had the benefit that nobody could find all the dumb stuff I said on the internet before I became a Haskeller though, which is arguably a good thing.
07:08:55 <edwardk>  =)
07:08:57 <FreeFull> CosmicRay: James Paul Grimsonn?
07:09:22 <quchen> CosmicRay: Or you could use CosmicRay because even after not saying a word in forever, people recognize you and tell you who you are and that you're writing lawnmower drivers.
07:09:28 <tomejaguar> edwardk: we can now :)
07:09:46 <shachaf> edwardk considered harmful
07:09:47 <CosmicRay> quchen: I like this :-)
07:09:53 <quchen> (What the heck is a lawnmower driver anyway haha)
07:09:54 <Zenol> I'm writing a writer for pandoc to parse Markdown and generate XML. This XML shouldn't use UTF8 input but latin-1 (because it will be processed by old perl scripts that don't allow UTF8). Pandoc store UTF8 strings as 'String'. Are they some fancy UTF8 to XML/HTML (that replace nbsp by &nbsp;, é by &eacute;, etc.) ? (I'm using Data.XML.Light to generate the XML, which also works with 'String').
07:10:01 <edwardk> tomejaguar: heh i used different ones for different forums mostly. =) Harmless will just find my old Harmless Algorithms series on flipcode
07:10:02 <mbrock> i have a whole roster of pseudonyms spouting all kinds of unspeakable craziness all over the intertubes
07:10:03 <CosmicRay> now all we need is shapr to reappear
07:10:13 <quicksilver> @get-shapr
07:10:14 <lambdabot> shapr!!
07:10:23 <quicksilver> the feature still works but can take some years.
07:10:25 <tikhon> I don't have enough foresight to use a pseudonym
07:10:27 <mbrock> where did shapr go?
07:10:46 <edwardk> mbrock: got married, spends a lot of time in a hackerspace
07:10:55 <johnw> shapr went back to school and is doing projects with his Raspberry Pi
07:10:59 <mbrock> sweet
07:10:59 <quicksilver> https://twitter.com/shapr
07:11:31 <merijn> edwardk: Ironic that you apparently consider the sutff published under harmless as harmful ;)
07:11:59 <edwardk> merijn: its the stuff published under the other nicknames that is harmful ;)
07:12:01 <mbrock> I met him at EuroHaskell 2005 in Gothenburg when I was getting into Haskell, fun guy :)
07:12:33 <jonkri> I have a Data.Tree (from containers), and I want to search that tree for an element that satisfies (a -> Bool), and then return all the labels leading up to that label ([a]). Any pointers would be appreciated. And this is not homework! ;-)
07:12:37 <applicative> oh CosmicRay, hi!
07:12:54 <CosmicRay> hello applicative
07:12:58 <edwardk> mbrock: i hired him and dragged him out to boston for a couple of years, after which he decided he needed a formal education. i wonder if there is a connection
07:13:00 <mbrock> John Hughes tried out his unicycle in the Chalmers corridors...
07:13:19 <merijn> jonkri: What does "leading up to" mean?
07:13:21 <edwardk> mbrock: he has a collection of pictures of famous computer scientists trying to unicycle
07:13:27 <mbrock> haha awesome
07:13:40 <jonkri> merijn: A list of all the parents.
07:13:57 <quchen> merijn: find 1 (Tree 2 (Tree 3 Nil Nil) (Tree 1 Nil Nil)) = [2,1]
07:14:03 <merijn> ah, right
07:14:09 <mike2135> ahaha, i have: notify-send --icon=emblem-cool "Volume changed to x"
07:14:12 <mike2135> when the volume is 100%
07:14:12 <mike2135> try it
07:14:21 <mike2135> all the other ones are normal volume icons
07:14:39 <merijn> edwardk: Man, now I feel boring
07:14:40 <quchen> mbrock: Sounds like you want a zipper to traverse the tree, and then gather the path when you zip up to the root again.
07:15:27 <edwardk> > Node "a" [Node "tree" [], Node "in" [], Node "the" [Node "deep" [Node "dark" []]], Node "forest" []] ^..each.asIndex
07:15:30 <mbrock> if I had one I bet I could sell it to jonkri
07:15:30 <lambdabot>   [[],[0],[1],[2],[2,0],[2,0,0],[3]]
07:15:40 <quchen> Alternatively you could view your tree as a graph and use some graph algorithm.
07:15:54 <CosmicRay> as for why I've been scarce lately...  a combination of factors: my amateur radio hobby, having a job where I'm under an NDA, spending time with my children, and unexpected life events (http://is.gd/pI0hRC)
07:16:02 <quchen> Or alternatively alternatively you could aks a question of the type "I want to do something with data" and edwardk already has a combinator for that :-D
07:16:03 <edwardk> > Node "a" [Node "tree" [], Node "in" [], Node "the" [Node "deep" [Node "dark" []]], Node "forest" []] ^..each.filtered (\x -> length x > 2).asIndex
07:16:04 <lambdabot>   [[0],[2],[2,0],[2,0,0],[3]]
07:16:18 <edwardk> > Node "a" [Node "tree" [], Node "in" [], Node "the" [Node "deep" [Node "dark" []]], Node "forest" []] ^..each.indices (\x -> length x > 2).asIndex
07:16:20 <lambdabot>   Couldn't match expected type `[a0] -> GHC.Types.Bool'
07:16:20 <lambdabot>              with act...
07:16:23 <CosmicRay> also.  I felt like I understood Haskell.  Biggest motivation-killer :-)
07:16:30 <applicative> shapr has been around in recent uh years
07:16:45 <CosmicRay> I follow him on Google+
07:16:45 <edwardk> anyways the one with filtered is right
07:16:51 <applicative> CosmicRay: oh, you havent tried the lens package yet ;)
07:16:58 * hackagebot fay 0.16.0.2 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.16.0.2 (AdamBergmark)
07:17:37 <CosmicRay> applicative: you are an evil person :-)
07:17:58 <quchen> Nerd sniped! :)
07:18:11 <applicative> ha
07:18:21 <quicksilver> frequently my nagging emails from google to remind me that I never visit google+ read "Shae Erisson, Shae Erisson, and Shae Erisson have shared things with you on google+"
07:18:31 <applicative> the channel is principally devoted to comprehending lenses now; not exactly wrongly
07:18:51 <edwardk> quicksilver: i stopped posting things to google+ mostly because of the death of google reader. i have no easy way to do it, so i don't.
07:18:53 <Enigmagic> blackdog: old code, if you want to fix it feel free. the service it runs in already has to deal with exceptions so it didn't matter much.
07:19:29 <edwardk> i pretty much stopped reading blogs and turned that into coding time as a result
07:19:55 <quicksilver> all haskell problems are in two parts: (i) the part that lens already solves and (ii) the feature request for lens
07:20:23 <quicksilver> edwardk: I never posted things because I'm not good at long-form expressions of opinion.
07:20:24 <edwardk> applicative: it is worth noting that the instance for 'each' that implements that is built using a custom Deque type that occupies a full module and was written _just_ for that combinator =)
07:20:30 <quicksilver> edwardk: I still use feedly to read RSS though.
07:20:35 <merijn> @quote merijn replace
07:20:36 <lambdabot> merijn says: after a week you can delete 80% of your code and replace it with whatever edwardk wrote that day ;-)
07:21:07 <quchen> Speaking of which: Are there lenses for tuple-like types yet? Suppose I want to focus on the "a" in "data Foo … = Bar a b | Qux c"
07:21:37 <merijn> quchen: Isn't that a prism?
07:21:39 <edwardk> quchen: you can use makePrisms and then work with _Bar._1 _Bar._2
07:22:06 <edwardk> that will be a traversal, not a lens, but yes its doable.
07:22:23 <edwardk> makePrisms will make a prism to a tuple if the constructor has multiple arguments.
07:22:24 <quchen> edwardk: Really? I thought I had to derive a FieldX instance somehow and that wasn't possible last time I checked
07:22:44 <quchen> edwardk: Sure, but doesn't that only work for single-constructor types?
07:22:57 <edwardk> quchen: no, it should work for multi-parameter constructors these days
07:23:17 <quchen> Please tell me it's a new feature or I've wasted a lot of time on doing this manually
07:23:21 <quchen> ;-(
07:23:29 <edwardk> makePrisms is a 'lens' to one alternative. _Bar is a 'prism' that can see one of the constructors of Foo
07:23:34 <edwardk> its been in for 8 months or so
07:23:40 <quchen> Argh.
07:23:44 <quchen> Thanks anyway :-)
07:23:48 <edwardk> 10 months actually ;)
07:23:59 <quchen> Stop hitting me! :D
07:24:54 <quchen> I thought _Bar is a prism that lets me access whatever is in bar, but that I couldn't use FieldX on its fields.
07:25:11 <quicksilver> edwardk: <<makePrisms is a 'lens' to one alternative>>
07:25:14 <edwardk> lens is designed to show you that if you'd just studied a whole bunch of useless theory, you'd have been able to spot that all the code you've written lately would just be a special case of some lens combinator.
07:25:17 <quicksilver> edwardk: I can't parse that?
07:25:18 <applicative> CosmicRay: a typical demo use of ordinary lenses is maybe still haasn's https://github.com/ekmett/lens/blob/master/examples/Pong.hs
07:25:23 <jonkri> quaestor, edwardk: Thanks.
07:25:41 <quchen> edwardk: Lens purpose: 1. amaze, 2. be useful
07:25:45 <quchen> (In that order)
07:25:49 <CosmicRay> must... resist... being... distracted... all...  morning....   ngggghh
07:25:51 <edwardk> oooooh haasn = nand
07:26:13 <jonkri> edwardk: I guess I should look into lenses, huh? :-)
07:26:15 <quchen> CosmicRay: "All morning"? You expect this to be over by noon? Ha
07:26:15 <edwardk> CosmicRay: https://www.youtube.com/watch?v=cefnmjtAolY&hd=1&t=1m14s
07:26:20 <CosmicRay> hah
07:26:23 <applicative> edwardk: yeah, maybe he's reinventing himself though
07:26:41 <CosmicRay> edwardk: you're not helping!
07:27:16 <applicative> the uptake is amazing for lens; there are 84 dependencies on http://packdeps.haskellers.com/reverse already
07:27:27 <edwardk> quicksilver: a prism splits a data structure into some target or something else. a lens splits it into some target and something else.
07:27:27 <edwardk> quicksilver: _Bar is morally equivalent to saying that your data type is either a Bar constructor or it isn't
07:27:46 <edwardk> applicative: plus it is used in snap, so lots of people pick it up transitively
07:28:02 <zomg> Blah, it doesn't look like I'm ever going to get around to finishing my "haskell for web developers" learning material
07:28:05 <applicative> yes, this is part of the spread of the contagion ;)
07:28:07 <edwardk> and then there is the fact that you can supply lenses without incurring a dependency
07:28:08 <zomg> Maybe I should just post what I have so far to my blog
07:28:09 <zomg> :P
07:28:28 <edwardk> e.g. 'free' has lenses in it, but wouldn't dare pick up the dep
07:28:38 <quchen> Soon the standard will be GHC+HP+Lens I guess.
07:28:50 <applicative> the Lens Platform
07:29:01 <quchen> HaskeLens
07:29:11 <quicksilver> edwardk: Right. OK.
07:29:14 <edwardk> quchen: well, the other big deal is that soon every field accessor will be trivially convertible to a lens after gundry gets done this summer
07:29:39 <quchen> edwardk: Could you explain what that means?
07:29:39 <edwardk> quchen: so we're effectively getting compiler support
07:29:53 <mm_freak_> edwardk: remember our discussion about comonadic FRP?
07:30:00 <quchen> Isn't a field accessor a lens already?
07:30:04 <mm_freak_> http://lpaste.net/92035 ⇐ what are your thoughts on this?
07:30:41 <edwardk> quchen: the field accessors that get generated by record syntax will be directly usable as data-lens, fclabels, data-accessors style lenses, and should be capable of turning into a lens-style lens that supports _type changing assignment_ with a single combinator
07:31:03 <mm_freak_> you could call Sig DeltaStoreT
07:31:35 <edwardk> future work can expand that power to r { s = x, t = y }  changing out types that have to vary together by borrowing more machinery from lens.
07:31:58 * hackagebot hslogger 1.2.2 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.2.2 (JohnGoerzen)
07:32:11 <edwardk> but that is being punted to another year
07:33:37 <quchen> edwardk: Ah, so under certain circumstances I won't have to use MakeLenses anymore because record labels are "more" first-class then?
07:33:48 <edwardk> mm_freak_: http://hackage.haskell.org/packages/archive/free/3.4.2/doc/html/Control-Comonad-Trans-Cofree.html
07:34:36 <edwardk> quchen: yeah
07:34:40 <danharaj> edwardk: what is gundry doing with record field accessors?
07:34:42 <quchen> edwardk: On a related note, will that have something to do with overloading record fields in some way? It sounds like it goes in a similar direction
07:34:54 <edwardk> i'll be able to give you some combinator, say 'le' that takes a field and makes a type changing lens out of it
07:35:04 <mm_freak_> yeah, you could express it as CofreeT over Coreader
07:35:33 <danharaj> imo make it das
07:35:33 <edwardk> quchen: yes this is a consequence of me steering gundry's work on overloading record fields away from magic changes to (.) towards lenses
07:36:29 <quchen> In other words we won't get overloaded records in Haskell but Lens will take good care of that?
07:36:36 <mm_freak_> no, you can't actually
07:36:44 <edwardk> quchen: the combinator is obviously necessary when you work out the types. foo.bar  compose on way for normal fields, but backwards if they are lenses.      le foo . le bar gives you the lens composition
07:36:45 <mm_freak_> it's Time -> X, not (Time, X)
07:36:52 <edwardk> quchen: no w get overloaded records
07:36:58 * hackagebot MissingH 1.2.0.2 - Large utility library  http://hackage.haskell.org/package/MissingH-1.2.0.2 (JohnGoerzen)
07:37:03 <edwardk> the record accessors just become liftable into lenses as well
07:37:12 <edwardk> you get to have both cake _AND_ icecream
07:37:32 <edwardk> mm_freak_: i was figuring the Time's were delta. thats Traced not Env
07:37:39 <quchen> Very nice. Is it going to be in 7.8.1?
07:37:46 <applicative> CosmicRay: if you're still around, it occurs that make Tekmo's tutorial makes a simple straightforward case http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
07:37:47 <edwardk> quchen: i don't know the release time table
07:38:05 <applicative> substituting maybe for make
07:38:20 <quchen> Also, what does "le" stand for? French?
07:38:25 <edwardk> quchen: its short for lens ;)
07:38:37 <edwardk> quchen: and it reads funny to someone who has read too many rage comics.
07:38:39 <tikhon> I'm not sure I could take le foo and le bar entirely seriously :/
07:38:40 <quicksilver> one of my main complains about lens has been how long that word is
07:38:43 <edwardk> tikhon: hah
07:38:49 <edwardk> tikhon: 'lens' is taken for another purpose
07:38:53 <quicksilver> too much of le typing
07:39:05 <quicksilver> edwardk: 1 rage comic is too many.
07:39:12 <tikhon> then again, even le is pretty long
07:39:13 <danharaj> edwardk: maybe you can convince them to add a unary operator for lens conversion
07:39:19 <tikhon> maybe just l :D
07:39:29 <quchen> edwardk: What will be the type of a record accessor then? How much magic is needed for the overloading?
07:39:40 <mm_freak_> yeah…  anyway, i'll experiment with it further
07:39:45 <edwardk> so at a minimum it has to be 2 characters, as single letter names are too common, it can't be infix, and you want a mnemonic, that drives me to le
07:39:54 <mm_freak_> TracedT has a somewhat unfortunate interface
07:39:54 <edwardk> quicksilver: the type is horrid
07:40:00 <tikhon> hmm
07:40:13 <tikhon> yeah, I guess le is the best option
07:40:15 <quicksilver> edwardk: yes, I was making a rather poor pun on 'typing'.
07:40:34 <quchen> data Foo a = Foo { runFoo :: a };  :t runFoo  ==>   Horrid a => Foo a -> a
07:40:40 <edwardk> quicksilver: we get three classes involved, one for getting and one for types you can set to, and one for the notion of an accessor that can be instantiated directly by data-lens, etc.
07:40:50 <edwardk> the set machinery is needed to support type varying assignment through lens
07:41:05 <quicksilver> that was quchen's question actually :)
07:41:15 <quicksilver> but us qu* all look the same.
07:41:17 <edwardk> and th existing use case is caused by the (->) instance for the accessor typeclass
07:41:20 <quicksilver> and the answer is interesting anyway.
07:41:39 <edwardk> heh
07:41:58 * hackagebot graceful 0.1.0.0 - Library to write graceful shutdown / upgrade service.  http://hackage.haskell.org/package/graceful-0.1.0.0 (NoriyukiOhkawa)
07:41:59 <quchen> edwardk: So in general records will become complicated beasts then
07:42:22 <edwardk> they are essentially complex though, that is why all this flailing for simple solutions has failed
07:43:05 <quchen> By complex you mean the overloaded versions, not the current state?
07:43:18 <edwardk> overloaded fields, yes.
07:43:20 <quchen> Current records just feel like sugar to me
07:43:21 <quchen> Ah okay.
07:43:38 <mm_freak_> edwardk: i wonder why you chose w (m -> a) instead of m -> w a
07:44:14 <edwardk> mm_freak_: making the laws work
07:44:34 <edwardk> prove the laws the other way and we can talk ;)
07:45:03 <edwardk> a lot of the transformers i used to have in category-extras were backwards and wrong
07:45:54 <edwardk> if you look at the monadic layering, the comonadic layering for the opposite effect will have the opposite composition
07:46:09 <edwardk> this is the moral equivalent of asking why reader is a -> m b   instead of m (a -> b)
07:46:50 <edwardk> this obsrvation is a consequence of having done the work to check, not how i did the check ;)
07:51:16 <applicative> nice, another quasi-tutorial for new cabal features
08:00:49 * applicative is already defeated trying to use 'cabal repl'
08:03:18 * applicative is now not-so-defeated
08:08:02 <mm_freak_> edwardk: extend f . extend g = extend (f . extend g)
08:08:06 <mm_freak_> what would you call this law?
08:08:41 <edwardk> :t (Control.Comonad.=<=)
08:08:42 <lambdabot> Control.Comonad.Comonad w => (w b -> c) -> (w a -> b) -> w a -> c
08:26:07 <natschil> Hello. I'm currently trying to learn haskell, and I'm slightly confused by the ($) operator/function. Is there any documentation on this function specifically somewhere?
08:26:41 <tikhon> it's just function application
08:26:42 <companion_cube> it's an operator that does nothing
08:26:44 <tikhon> f $ x is the same as f x
08:26:57 <tikhon> you can use it to avoid parentheses everywhere
08:27:05 <tikhon> for example, f (x + 1) can become f $ x + 1
08:27:28 <tikhon> this keeps us from looking too much like lisp :D
08:27:36 <natschil> but how does it work? The explanation I found seemed to suggest that it was regular haskell function... am I wrong about that?
08:27:43 <tikhon> it is
08:27:49 <tikhon> it's defined as
08:27:52 <tikhon> f $ x = f x
08:27:55 <tikhon> @src ($)
08:27:55 <lambdabot> f $ x = f x
08:28:23 <natschil> I didn't know one could define infix functions like that, but that would make sense.
08:28:29 <tikhon> yeah, it's very nice
08:28:33 <natschil>   @src (+)
08:28:39 <natschil> @src(+)
08:28:39 <lambdabot> Unknown command, try @list
08:28:44 <natschil> @src (+)
08:28:45 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:28:46 <tikhon> (+) won't really work because it's polymorphic
08:28:52 <tikhon> :t (+)
08:28:53 <lambdabot> Num a => a -> a -> a
08:29:05 <tikhon> so it has a different definition for Int and for Integer and Double and so on
08:29:20 <tikhon> dozens of different definitions
08:29:30 <natschil> So could I define a function called "foo" that was equivalent to $? or is the behaviour of $ builtin?
08:29:38 <tikhon> yes, you could define a foo like that
08:29:44 <tikhon> foo f x = f x
08:29:50 <tikhon> it wouldn't be terribly useful though
08:30:00 <tikhon> @let foo f x = f x
08:30:02 <lambdabot>  Defined.
08:30:03 <tikhon> :t foo
08:30:04 <lambdabot> (t1 -> t) -> t1 -> t
08:30:06 <tikhon> :t ($)
08:30:06 <lambdabot> (a -> b) -> a -> b
08:30:23 <tikhon> > not True
08:30:24 <lambdabot>   False
08:30:28 <tikhon> > foo not True
08:30:34 <lambdabot>   False
08:30:54 <tikhon> ...
08:30:55 <tikhon> in real life, you do not get a performance penalty like that
08:30:57 <natschil> makes sense. Is the type of the "f" in the original definition of ($) polymorphic?
08:31:00 <natschil> :t ($)
08:31:01 <lambdabot> (a -> b) -> a -> b
08:31:14 <ocharles> Is it possible to export a data constructor for a data family in a type class?
08:31:18 <tikhon> yes, f can be *any* function
08:31:24 <ocharles> or is the type class the only thing that can use that constructor?
08:32:22 <ocharles> When I try and export it I get: "The export item ... attempts to export constructors or class methods that are not visible here"
08:32:23 <quicksilver> ocharles: anyone can use the constructor. It has the typeclass in the type, of course.
08:32:28 <natschil> tikhon: makes sense. I didn't know you could define your own infix functions without using backticks notation, thanks for explaining!
08:32:55 <tikhon> yeah, functions with symbols in their names are infix automatically the way normal ones are prefix
08:33:01 <ocharles> oh, I made a typo on the export
08:33:03 <ocharles> there we go :)
08:33:15 <quicksilver> :)
08:33:29 <applicative> the documentation on this sort of thing is among the most opaque in the ghc docs ocharles
08:34:35 <applicative> ah yes the unforgettable http://www.haskell.org/haskellwiki/GHC/Type_families#Examples
08:34:56 <ocharles> applicative: unfortunately, I agree
08:35:48 <ocharles> Pro tip kids: if you decide you don't like orphan instances, don't wait until you're 4k lines in before fixing it
08:35:55 <ocharles> I haven't seen my project compile for the last 6 hours :(
08:36:33 <ocharles> it is, however, leading to a much nicer code layout
08:36:49 <tikhon> also a good case for using -Wall and fixing warnings when they come up
08:36:55 <ocharles> I already do
08:36:59 <ocharles> I just had that warning turned off
08:37:02 <tikhon> aha
08:37:06 <ocharles> I guess when I started the project I didn't understand the implications
08:37:06 <tikhon> fair enough
08:37:24 <tikhon> the hard way is often the best way to learn
08:37:39 <ocharles> yea. i haven't actually hit a problem due to it, but I understand the controversy enough now
08:38:07 <Demos> having few warnings is good just to let the new, important warnings shine through though
08:38:13 <applicative> is it that everything depended on the instance you are now getting rid of?
08:38:37 <ocharles> applicative: not really, I had my code structured as Foo.Types (which was massive) and then instances in various other modules
08:39:03 <ocharles> so now I've evened it out a bit (each type has all its instances in one file). the downside is there's one place where I have to break recursive imports
08:39:16 <ocharles> which might be my number 1 complaint about ghc
08:39:36 <tikhon> there are pretty good reasons for not allowing recursive modules
08:39:44 <tikhon> or at least not having them by default
08:39:55 <ocharles> doesn't stop me hating the fact that GHC makes it hard :)
08:40:01 <tikhon> and making using them a little annoying and explicit
08:40:03 <tac> recursive modules are bad juju
08:40:07 <applicative> hm, i wonder if there's another organization... that would take 12 hours to find and 6 hours to implement...
08:40:13 <tac> Though it is extremely obnoxious a module must be entirely contained in a single file
08:40:19 <Demos> is a recursive modules just a module that imports itself?
08:40:29 <tikhon> Demos: modules that import each other
08:40:31 <tac> Demos: it's when one module imports a second and that second imports it
08:40:35 <ocharles> I think I can restructure my code to not have this little bit of recursive importing
08:40:39 <Demos> oh, circular modules
08:40:39 <ocharles> but I haven't yet figured out how
08:40:54 <ocharles> but that can wait, hs-boot is doing the job for now
08:40:54 <tikhon> ocharles: you probably should—I've found it leads to much nicer organization
08:41:11 <ocharles> The problem child is modelling a slightly hetrogenous list
08:41:31 <ocharles> There are 6 possible types that go in, so I have a data type that brings in 6 constructors for each type
08:41:35 <applicative> every haskell module already recursively imports itself, that's why everything defined is in scope everywhere. ... kind of ...
08:41:45 <ocharles> so that's 6 imports. and each one of those imports depends on the hetrogenous list
08:42:09 <applicative> suddenly everyone is using hs-boot files. no way i'm learning about them.
08:42:12 <ocharles> there is a definite smell though, because when I add a new type I will have to change that data type to have 7 constructors, not 6
08:42:30 <ocharles> I haven't figured out how to make that data type restrictively more open
08:43:22 <tikhon> eh, I think that having to add an extra constructor is completely reasonable in this sort of case—it makes things more explicit without creating *that* much overhead
08:43:36 <ocharles> well sure, but it creates recursive modules
08:43:49 <ocharles> that's the only real pain point though
08:43:52 <tikhon> hmm
08:44:18 <tikhon> you could have the specific types to be included as type variables in the heterogeneous list type
08:46:14 <ocharles> i think there are a few approaches, but I want to get this thing compiling first :)9
08:47:08 <tikhon> bah, code that compiles is woefully overrated; elegant code that *should* work is so much nicer :P
08:48:13 <latermuse> is the testWireM function from Control.Wire deprecated?
08:51:08 <ekyo> hi, yesod's website seems down (InternalIOException socket: resource exhausted) and I'm looking for a different reference than google's cache. any suggestions?
08:51:33 <tikhon> Hackage?
08:51:36 <tikhon> http://hackage.haskell.org/package/yesod-1.2.0.1
08:52:10 <tikhon> I think it's broken up into a bunch of different packages though
08:52:32 <tikhon> and, of course, this will just be the API documentation
08:52:50 <ekyo> hmm, well seems the examples are there as well. I guess it'll do ;) thanks
08:52:55 <tikhon> also, I suspect you know this, but just in case: https://github.com/yesodweb/yesod/wiki/Cookbook
08:54:05 <ekyo> I didn't but I guess I'll read that during the downtime
08:54:19 <nicknack> I'm trying to install haskell on linux mint. It seems like sudo apt-get install haskell-platform should work, but no package is found! Any suggestions ?
08:55:13 <tikhon> Maybe it's called something else? Try doing an apt-cache search, (or whatever the right search command is).
08:56:54 <nicknack> Hmm, there is haskell-doc, and ghc
08:58:42 <geekosaur> I don't remember what I did on my mint install (and it's a version behind because the ubuntu upstream can't figure out how to do aproper dist-upgrade...)
08:59:09 <ekyo> well I use linux mint and in my install script there's only apt-get update and upgrade before installing haskell-platform haskell-platform-doc haskell-platform-prof hlint ghc-mod
09:00:13 <ekyo> I use cinnamon but that shouldn't affect these packages
09:01:16 <nicknack> ekyo: I'll try those as
09:02:56 <nicknack> E: Unable to locate package haskell-platform
09:03:00 <nicknack> :(
09:27:02 <dwcook> What is the technical reason there's no mechanism for specifying typeclass instances for import?
09:27:20 <tikhon> the "open world assumption"
09:27:38 <tikhon> basically, typeclass instances propagate automatically everywhere
09:27:58 <elliott> dwcook: http://stackoverflow.com/questions/8728596/explicitly-import-instances/8731340#8731340
09:28:03 <tikhon> this ensures that the instances are consistent: if you have a type with Ord, it will *always* have the same comparison function
09:28:35 <tikhon> that has to be one of the most linked-to Haskell questions on StackOverflow
09:28:39 <elliott> tikhon: modulo a GHC bug.
09:28:52 <elliott> (that makes people think it's possible to do it with orphans)
09:28:56 <tikhon> oh
09:28:59 <tikhon> which bug?
09:29:04 <elliott> heh, I'm just plugging my own answer :p
09:29:16 <elliott> tikhon: e.g. http://stackoverflow.com/questions/12735274/breaking-data-set-integrity-without-generalizednewtypederiving/12744568#12744568 should be rejected by the compiler because you have two Ord U instances in scope
09:29:20 <elliott> but it is not
09:29:25 <tikhon> for better or worse, it's the best online resource on the open world assumption
09:29:53 <davd> [newtypes] http://ghc.haskell.org/trac/haskell-prime/wiki/NewtypeDeriving - is there any way to "use" StateT in the second example within the same module? I'm trying to hide the wrapped contents but still need state-like access when the constructor is available.
09:30:50 <tikhon> elliott: I'm confused about why exactly that works
09:30:56 <davd> basically useHidden :: TI () should be able to modify the state, if declared within the same module.
09:31:09 <elliott> because orphan instances are evil.
09:31:13 <tikhon> ah
09:31:20 <elliott> and because GHC is evil.
09:31:31 <tikhon> but shouldn't something kick in to prevent that, like the restriction on overlapping instances or something?
09:31:40 <monochrom> wait, GHC is evil?
09:32:29 <elliott> monochrom: for allowing that program
09:33:48 <n-dolio> Does the report actually say it's an error?
09:34:22 <tikhon> if it doesn't, it just means the report is also evil
09:34:36 <tikhon> and GHC merely complicit
09:35:03 <elliott> n-dolio: I don't know, but augustss does and that's good enough for me.
09:35:04 <monochrom> "A type may not be declared as an instance of a particular class more than once in the program" is this enough?
09:35:13 <elliott> sounds enough
09:35:59 <monochrom> orphaned instances are not evil as long as at link time you enforce uniqueness
09:36:14 <tikhon> and sometimes they're a necessary evil
09:36:24 <tikhon> like when people forget to make monads applicatives
09:36:36 <n-dolio> I just wasn't sure. It's easy to miss that checking when you _use_ an ambiguous instance isn't enough.
09:36:39 <dwcook> I'm afraid I'm not making the connection from what I've read to why that requires that there be no way to specify whether to import a given instance or not.
09:37:06 <n-dolio> Ambiguous instances imported into the same module is sufficient to be a problem.
09:37:31 <monochrom> in fact orphaned instance is hardly the point when it comes to non-uniqueness
09:38:05 <tikhon> dwcook: basically, one of the main invariants with typeclasses is that the instance for any given type has to be consistent throughout your program
09:38:26 <dwcook> Okay, I'm with you so far on that.
09:38:29 <tikhon> if it wasn't, you would have no reliable way of detecting and defending against this, which would lead to lots of subtle bugs
09:38:37 <monochrom> if one file says "data X = X; instance C X ..." and another file says "class C a ...; instance C X ...". see, no orphaned instances. you still have the non-uniqueness problem.
09:38:52 <tikhon> so what happens if you create a set in some module, export the set but do not export the Ord instance it depends on?
09:39:13 <tikhon> then the place you use it happens to have a different Ord instance defined
09:39:16 <monochrom> you are forced to export the Ord instance
09:39:30 <tikhon> monochrom: I'm trying to explain *why* you're forced to export them
09:39:38 <monochrom> oops
09:40:03 <dwcook> Ah, so one part of your program would want to use the one instance, and another another.
09:41:04 <tikhon> and that could break your set in very subtle ways, with no good way of finding or preventing that sort of error
09:41:34 <tikhon> to make this tractable, we'd need some way to encode that two things have a different instance in the type system
09:41:49 <tikhon> and, lo and behold, that's effectively what we have now: to use two different instances, you have to create a newtype!
09:41:59 <tikhon> so it all works out happily
09:42:05 <tikhon> except for the example elliott linked to
09:42:09 <tikhon> where GHC is evil
09:42:13 <dwcook> Or, I suppose, explicitly request functions instead of using typeclass methods
09:42:21 <dwcook> though I imagine that could get cumbersome
09:42:23 <tikhon> yes
09:42:42 <tikhon> or we could copy OCaml and friends and have a better module system
09:42:55 <tikhon> but that's still relatively cumbersome—certainly more awkward than typeclasses
09:43:08 <Zenol> What's the name of the safe head? ([a] -> Maybe a)
09:43:15 <joelteon> safeHead
09:43:20 <tikhon> listToMaybe
09:43:20 <dwcook> listToMaybe I think?
09:43:23 <n-dolio> Better module systems are really no replacement for type classes.
09:43:34 <tikhon> the OCaml people claim it is
09:43:43 <n-dolio> Well, they're wrong.
09:43:43 <tikhon> I don't know if I trust them though—they're pretty shifty
09:43:54 <danharaj> type classes have proof search
09:43:58 <danharaj> modules don't
09:44:00 <tikhon> and the SML people I just ignore outright
09:44:17 <monochrom> @quote monochrom safemaybe
09:44:17 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
09:44:23 <monochrom> @quote monochrom safefromJust
09:44:23 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
09:44:26 <monochrom> :)
09:44:42 <n-dolio> There's overlap, and I'd love to have better modules. But neither is a replacement for the other.
09:44:46 <tikhon> with the obvious implementation: safeFromJust = unsafeCoerce
09:46:01 <monochrom> "boolean blindness" can be extended to "maybe blindness"
09:46:07 <cschneid> I'm writing a snap website. I see lots of available db abstraction layers. Anywhere from basic postgresql-simple to do raw queries to various layers of fancier typechecked data. What should I look into as a beginner?
09:46:16 <tikhon> after all, Maybe is basically Either Bool
09:46:21 <cschneid> tutorials and example code is more important now than the "best".
09:46:37 <dwcook> tikhon, isn't it Either ()?
09:46:44 <tikhon> oh yeah, good point
09:46:52 <joelteon> Nothing, ReallyNothing, or Just a
09:46:57 <dwcook> :D
09:46:59 <monochrom> if you go so far as to write "case safeHead xs of Just x -> ...; Nothing -> ...", why not simply "case xs of x:_ -> ...; [] -> ..."?
09:47:03 <mr-> Either Bool x is basically Either x x ? ;-)
09:47:05 <dwcook> ReallyNothingIsWrongGoBackToBed
09:47:33 <applicative> I use Either ExitCode instead of Maybe, myself
09:47:34 <tikhon> mr-: no, that would be (Bool, x)
09:47:41 <monochrom> safeHead is largely a combination of boolean blindness and an XY problem
09:47:42 <mr-> tikhon: right
09:48:01 <tikhon> I use safeHead when I'm using lists to do backtracking search
09:48:03 <mr-> confused co/product ;-)
09:48:08 <tikhon> well, listToMaybe
09:49:12 <monochrom> but I guess the optimizer simplifies it for you
09:49:18 <Zenol> joelteaon: SafeHead from which library? :p
09:49:45 <Zenol> tikhon, dwcook: Thanks :)
09:51:19 <applicative> Zenol: have you seen the errors library, it exports Safe and a million things like this, so you can be as boolean-blind or either-conscious as you please
10:00:30 <dominik> hello! i have a problem: i want to get all even fibonacci numbers below 4000000. this is how my try looks like: evenfibonacci = [fib n | fib n <- [2,3..], fib n < 4000000]. trying this out in ghci it never terminates... i assume the infinite list never terminates, but shouldnt it terminate because of the terminating condition i gave (fib n < 4000000)?
10:00:36 <Zenol> applicative: Hey, thats look good http://hackage.haskell.org/packages/archive/errors/1.4.2/doc/html/Control-Error-Safe.html !
10:01:10 <merijn> dominik: That's not a terminating condition
10:01:10 <tikhon> dominik: how does the compiler know that fib n is always increasing?
10:01:15 <merijn> dominik: It is a filtering condition
10:01:26 <tikhon> for all it knows, fib 10000000000000000000000000000 could be < 4000000
10:01:45 <merijn> dominik: You are only filtering everything bigger than 4000000, the compiler doesn't know there will only be bigger numbers
10:01:56 <merijn> dominik: You probably want "takeWhile (<4000000)"
10:02:02 <dominik> alright i understand
10:02:26 <merijn> dominik: Which, as the name implies, terminates when the condition is not true :)
10:02:59 <dominik> would i write "takeWhile (<4000000)" instead of "fib n < 4000000"?
10:03:11 <merijn> > takeWhile (<10) [1..20]
10:03:12 <lambdabot>   [1,2,3,4,5,6,7,8,9]
10:03:14 <tikhon> takeWhile takes the list as an argument; it is not part of the list comprehension
10:03:46 <tikhon> also, your fib n <- [2,3..] code won't really work
10:04:01 <merijn> Also, using "fib n" to generate a fibonacci numbers is really inefficient, you're reevaluate everything for every number
10:04:31 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in takeWhile (<40000) fibs
10:04:41 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:05:25 <Zenol> merijn: Now I want all prime numbers below 40 :D
10:05:48 <merijn> Zenol: I can't golf that of the top of my head >.>
10:05:58 <byorgey> > [2..40]
10:05:59 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
10:06:05 <byorgey> that includes all the primes below 40
10:06:22 <tikhon>  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
10:06:22 <merijn> byorgey: *bzzt* :>
10:06:30 <tikhon> >  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
10:06:31 <merijn> byorgey: You don't have any negative primes...
10:06:31 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37]
10:06:43 <byorgey> *negative* primes??
10:06:44 <jesyspa> Is there any particular reason unfoldr (\(x, y) -> Just (x, (y, x+y))) (0,1) isn't something seen often?
10:06:56 <merijn> byorgey: Why not?
10:07:12 <byorgey> I have never heard -5 called a prime.
10:07:24 <tikhon> negative numbers are just nonsense anyhow—who needs more than the naturals?
10:07:35 <merijn> byorgey: This is math, I'm allowed to do anything that I can unambiguously define!
10:07:39 <tikhon> it's just those mathematicians in their ivory towers
10:07:44 <merijn> (And some that I cannot)
10:07:56 <byorgey> merijn: sure!  In that case, here are all the primes below 40:  16, 23
10:08:00 <byorgey> merijn: I used my own definition
10:08:06 <Zenol> up to an inversible of Z, 5  = -5
10:08:17 <merijn> byorgey: Mine doesn't contradict existing theory, though
10:08:38 <byorgey> merijn: well, my claim was that it *does* =)
10:08:58 <Zenol> > (\s -> [s, -s]) <<= [2..40]
10:08:59 <lambdabot>   Not in scope: `<<='
10:08:59 <lambdabot>  Perhaps you meant one of these:
10:08:59 <lambdabot>    `<=' (imported from...
10:09:00 <elliott> -41 is the only negative prime.
10:09:01 <merijn> byorgey: I'll believe you if you can provide a hint of evidence on how
10:09:01 <tikhon> so somehow defining "prime" to be *less* restrictive is qualitatively different from defining it to be *more* restrictive?
10:09:03 <byorgey> e.g. wikipedia says "A prime number (or a prime) is a natural number greater than 1 that has no positive divisors other than 1 and itself."
10:09:04 <elliott> this is the received truth.
10:09:04 <Zenol> > (\s -> [s, -s]) =<< [2..40]
10:09:05 <lambdabot>   [2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,14,-14...
10:09:13 <byorgey> merijn: that is an entirely standard definition.
10:09:14 <Zenol> here you have all prime below 40 :D
10:09:15 <scshunt> elliott: all hail
10:09:26 <TimUK> hey folks! quick question for you. Is there a way of using union (or another function) that would get rid of duplicates, even if the number of elements differ, but the numbers are the same?
10:09:27 <tikhon> Zenol: there are more negative numbers below 40 than that :)
10:09:36 <dominik> alright it works now. thanks everybody!
10:09:36 <byorgey> wolfram mathworld: "A prime number (or prime integer, often simply called a "prime" for short) is a positive integer p>1 that has no positive integer divisors other than 1 and p itself."
10:09:38 <sclv_> here is my less restrictive list of primes below 40
10:09:45 <sclv_> > [1..39]
10:09:46 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:09:48 <ParahSai1in> @ty nub
10:09:49 <lambdabot> Eq a => [a] -> [a]
10:09:52 <Zenol> tikhon: errk, yeh, right x)
10:09:54 <byorgey> sclv_: ooooh, nice optimization
10:09:58 <merijn> TimUK: Sounds you you want Set/IntSet?
10:10:03 <applicative> arent there plenty of prime concepts uses extended ... oh wait
10:10:03 <TimUK> for example here is my list [[2,2],[2],[3],[7]] I would want to get rid of [2]
10:10:06 <tikhon> Zenol: but only if you buy into all this "negative number" nonsense
10:10:10 <merijn> TimUK: (Imagine there was a "like" in there)
10:10:12 <applicative> "In the ring Z of integers, the set of prime elements equals the set of irreducible elements, which is..."
10:10:18 <tikhon> ℤ
10:10:54 <applicative> certainly includes -5
10:11:01 <merijn> booyah!
10:11:08 <merijn> Justified by wikipedia
10:11:44 <applicative> i wonder if we can do primes of some type with the cyclotomic library ;)
10:11:45 <merijn> All cool people do math in Z mod x anyway
10:11:46 <TimUK> cool thanks, i'll check out set/IntSet and see how far I get, cya!
10:12:04 <byorgey> TimUK: perhaps you want  nubBy
10:12:05 <merijn> s/math/arithmetic
10:12:20 <tikhon> merijn: ooh, I'm going to plug my silly library for doing just that: http://hackage.haskell.org/package/modular-arithmetic
10:12:29 <Zenol> merijn: Or Z[funny imaginary] :)
10:12:30 <TimUK> ah cool, i'll check that too, i used nub to get that first list... thanks again
10:13:06 <aupiff> Zenol: what exactly does =<< do? I tried using it in the same way you used it above, and it seems useful! It's just hard for me to google....
10:13:35 <tikhon> it's >>= backwards
10:13:39 <aupiff> Zenol: lol, just found it on Hoogle
10:13:44 <Sculptor> yo
10:13:57 <aupiff> tikhon: thanks! I have read more about monads…
10:14:16 <Zenol> I can't recall which one of >>= and =<< is the the alias of the other x)
10:14:23 <applicative> aupiff: writeFile "a.txt" =<< readFile "b.txt" ; the symbol is really not idea
10:14:27 <applicative> ideal
10:14:46 <applicative> maybe <<$
10:14:54 <applicative> no that uses the almighty $
10:15:00 <tikhon> I think it makes sense given that we are already used to >>=
10:15:28 <applicative> yes, except I read it that way, one wants somethign that has more a function and argument feeling
10:15:51 <tikhon> I think that would be a reasonable case for changing *both* operators
10:16:10 <applicative> i read x =<< y as having a flow from y to x ; of course there's a reason for it suggesting that ...
10:16:17 <tikhon> but I would not like breaking the nice symmetry
10:16:19 <merijn> aupiff: Hoogle is always the first step for haskell operators :)
10:16:20 <Zenol> >>= really looks like "take verything on the left, and push until it fit on the right" :)
10:16:32 <aupiff> merijn: I know that now!
10:16:50 <applicative> writeFile "input" .| getLine
10:17:05 <merijn> But yeah, I find the visual look of =<< and >>= very explanatory :)
10:17:30 <tikhon> also, >>= is already in the logo, so it's too late to change it :P
10:17:36 <Chousuke> You could find all sorts of intuitive descriptions for >>= but I'm sure that for each of those descriptions you can find a monad that breaks it :P
10:17:57 <Chousuke> same for =<<
10:17:58 <merijn> Chousuke: We're not talking descriptions, we're talking aesthetics
10:18:21 <applicative> i was thinking of something different, more like the difference between applicative and monadic 'style'
10:18:22 <merijn> It has a nice funnel look about it
10:18:30 <Chousuke> >>= actually looks better handwritten
10:18:39 <applicative> join $ writeFile "input" <$> getLine
10:19:31 <applicative> maybe something obnoxious like (<$$>) = (=<<)
10:19:43 <applicative> writeFile "input" <$$> getLine
10:21:45 <applicative> (|writeFile ~ "input" getLine @|) is pretty hideous of course
10:24:32 <Zenol> Ah, it might be Z[1+sqrt(-19)/2] :)
10:25:25 <Chousuke> clearly haskell just needs to allow arbitrary notation and guess what you mean from context :P
10:31:52 <applicative> hm, my gutted she-idiom-brackets script seems to mishandle @ :..(
10:32:01 <applicative> boo hoo
10:33:40 <applicative> maybe join should be expressed with double brackets anyway ((| (writeFile "input") getLine ||)
10:34:10 <tikhon> because ((| and ||) obviously match
10:34:11 <applicative> (|| (writeFile "input") getLine ||) rather
10:34:46 <applicative> the syntax mc bride put in for *> is awesome
10:34:47 <applicative>          | Plus (-char '('-) pExp (-char '+'-) pExp (-char ')'-)
10:35:07 <applicative> the part in (- brackets -) is 'commented out' so to speak
10:36:04 <applicative> so his little parser looks like this http://sprunge.us/GABE
10:36:53 <applicative> it's not ideally readable here since parentheses are what we are 'commenting out' with our parser
10:38:07 <Zenol> applicative: http://sprunge.us/GABE?hs is already a bit more readable :p
10:38:54 <applicative> ah, yes; i figured a syntax 'extension' like this might make a hash of it
10:40:09 <Zenol> Looks like writing parser with Attoparsec is even simplier than using parsec :o
10:45:03 <troydm> so, i'm getting a very curious bug
10:45:18 <troydm> i'd paste a code but i'm not sure how to explain it
10:45:49 <tikhon> yeah, we can't really help you much without code or an explanation :)
10:46:13 <monochrom> it suffices to show actual code and state actual observations
10:46:59 <merijn> Simplifying the code to a minimal subset would help
10:47:11 <monochrom> think of it as a science lab report
10:47:45 <troydm> http://lpaste.net/92037 <- so this is the code, it fails to work on my latest OpenIndiana and ghc 7.4.2 with process-1.1.0.1
10:47:59 <troydm> now how it fails, it says that ghc command is not found
10:48:17 <troydm> now the interesting ways to make it work
10:48:29 <troydm> 1) remove createDirectoryIfMissing line
10:48:35 <troydm> 2) remove forkIO
10:48:43 <troydm> 3) remove { env = Just env0 }
10:48:53 <troydm> now i can't explain any of the following
10:49:10 <troydm> nor i can reproduce it outside yesod package
10:50:03 <merijn> Why are you even doing "env = Just env0" if you use getEnvironment and don't modify?
10:50:11 <merijn> Environment is inherited by default
10:50:29 <merijn> Well, the exported parts of it, anyway
10:50:32 <troydm> merijn: i'm not doing it here, it's simplified in test code, in real code some variables are added
10:50:50 <merijn> SO what is the return value you get?
10:51:04 <troydm> merijn: Exit code: 127 is error
10:51:10 <troydm> it should give Exit code: 1
10:51:24 <merijn> Isn't 127 shell error?
10:51:26 <joelteon> isn't 127 interrupt?
10:51:31 <joelteon> or something like that
10:51:40 <troydm> 127 is shell error which states that command isn't found
10:51:51 <troydm> e.g. not in PATH
10:52:16 <joelteon> that's also the exit code of a process when you ctrl-c it
10:52:16 <troydm> now can any1 explain why doing any of three methods above makes PATH work again
10:52:19 <troydm> ?
10:52:31 <monochrom> do you run your program compiled?
10:52:46 <troydm> monochrom: yes, it's basicly yesod-bin package
10:52:47 <dacc> hello, just coming to haskell from scala.  hoping to get a cleaner understanding of scalaz by going back to the source =)
10:52:57 <merijn> Interesting
10:53:01 <monochrom> do you have -threaded or not?
10:53:25 <troydm> monochrom: i'm not sure, i guess since it's yesod-bin package it has -threaded flag on
10:53:44 <tikhon> dacc: that's risky—you might never be happy with Scala again once you understand Haskell
10:53:45 <troydm> monochrom: yup, it's flags are -Wall -threaded
10:53:52 <merijn> troydm: Have you tried logging the value of PATH/which ghc inside the fork?
10:54:10 <troydm> merijn: yes, it's same no all situations
10:54:20 <troydm> *no matter*
10:54:21 <merijn> that's bizarre
10:54:26 <troydm> yeah
10:54:32 <troydm> the bug is rly rly bizzare
10:54:51 <troydm> well platform i'm running this whole thing is also not rly popular
10:54:51 <merijn> I'm suspecting createProcess is f'ing with the environment
10:55:09 <troydm> but to fail like that means something rly bizzare is happening
10:55:32 <applicative> dacc: oh good work.  theres some scalaz experts around sometimes as it happens
10:55:39 <troydm> and i can't even understand how/what is happening or reproduce it outside yesod-bin package
10:56:49 <troydm> this is my test.hs in which i'm trying to reproduce the error http://lpaste.net/92038
10:56:50 <merijn> troydm: I have no time to investigate, you might wanna hunt through the source (starting at createProcess) to see which system call it's using
10:56:57 <troydm> but no matter what i do i can't reproduce it
10:57:00 <troydm> :(
10:57:02 <merijn> wait!
10:57:10 <merijn> It's broken inside the forkIO, right?
10:57:16 <troydm> yeah
10:57:25 <troydm> if forkIO removed it works
10:57:42 <applicative> forkIO makes it oblivous to the path among other things
10:57:45 <merijn> I remember forkIO and the fork system call interacting weirdly
10:58:04 <merijn> troydm: Anyway, finding out the system call it uses would be a good start
10:58:33 <troydm> merijn: well execvpe is syscall it uses to determine the path to executable i guess
10:58:34 <merijn> troydm: OpenIndiana is basically OpenSolaris, no?
10:58:44 <troydm> yeah
10:58:47 <troydm> it's OpenSolaris
10:59:04 <merijn> troydm: Might wanna use dtruss to find out which argument it's passing to fork/exec (and which exec it is using)
10:59:30 <troydm> merijn: i've never played with dtruss, i'll try it
11:01:19 <dacc> tikhon: that wouldn't bother me, but my goal is to switch to functional programming for a living eventually, so i may not get to be picky in the end =)
11:01:34 <dacc> applicative: cool, thanks
11:05:26 <dacc> sure is nice to get away from jvm startup time
11:05:33 <monochrom> eh, ghc 7.4.2 you say?
11:05:49 <tikhon> and the JVM's lack of proper tail calls, among other things
11:06:10 <tikhon> mutually recursive functions galore
11:08:22 <hpaste_> monochrom annotated “No title” with “cannot reproduce” at http://lpaste.net/92037#a92039
11:08:45 <monochrom> troydm: I cannot reproduce your observation. http://lpaste.net/92037#a92039
11:08:56 <dacc> tikhon: indeed, no more @tailrec
11:09:18 <troydm> monochrom: what operating system you are trying that?
11:09:33 <monochrom> ubuntu 13.04 i386 32-bit
11:09:50 <troydm> monochrom: i think it's Solaris related only
11:10:08 <monochrom> that is very likely then
11:10:12 <troydm> monochrom: coz yesod-bin works just fine on linux
11:11:10 <monochrom> ok, I think it is a bug in GHC's Solaris port
11:22:48 <mstksg> is there some kind of tool to automatically narrow-ize your imports so they only import the functions that you use?
11:23:31 <applicative> --ddump-minimal-imports
11:23:31 <mstksg> i know ghc-mod and hlint tells you which ones are not used at all
11:23:43 <c_wraith> so the tool appears to be ghc
11:23:45 <applicative> oh a tool, dunno
11:24:33 <Zenol> The class IsMytype t where toMytype = t -> Mytype design is really usefull.
11:25:17 <c_wraith> Zenol: dunno.  I've found little use for that in the long term. It's not like you can map it over a heterogenous list or something.
11:26:27 <dmwit> I think the entirety of the lens package is predicated on the idea that class IsMytype is pretty useful (but not quite useful enough).
11:26:35 <Zenol> c_wraith: I'm building xml, and some time I have text, some time, node, some type list of nodes, and I want to store convert it in XML. The conversion is always obvious, but verbose (like (: []) . Elem for example).
11:26:51 <Zenol> Now I just type "toXML" and it's easyer to read, to understand, and shorter.
11:27:11 <c_wraith> Hmm, I guess that is what serialization libs do.
11:27:24 <c_wraith> "toTheSerializedForm"
11:27:25 <tikhon> it also allows you to have instances that are recursive, like being able to process functions of arbitrary numbers of arguments
11:27:34 <edwardk> Zenol: the HasFoo classes generated by makeClassy are a generalization of 'IsMyType' by letting you also modify the 'MyType' part of the whole
11:27:36 <Zenol> oh, yes, I guess to.
11:27:46 <tikhon> I did that for my toy interpreted language: I could lift Haskell functions of the right types, no matter how many arguments they had
11:28:05 <sclv_> wait but they don't let you _construct_ a type, right?
11:28:12 <sclv_> or overload the construction of such at least
11:28:20 <edwardk> yeah there you still want something like that
11:28:27 <edwardk> ToContent, etc. in yesod for example
11:28:30 <sclv_> so they're more dual-ish than the opposite
11:29:02 <edwardk> well, we have some stuff in lens where we have prisms that can be downgraded to reviews so you can limit instances of them for construction only if you want to
11:29:06 <edwardk> when there is only an injection
11:29:14 <edwardk> it is kind of a terrifyingly complex usecase for end users
11:29:27 <sclv_> yeah the thing is you want to arbitrarily pick what you're coming from
11:29:31 <sclv_> but know what you're going to
11:29:39 <edwardk> but we get away with it in Control.Exception.Lens making prisms that are upgraded to Equalities in places.
11:29:46 <sclv_> so normal ad-hoc polymorphism is just fine for that
11:29:50 <edwardk> sure
11:31:54 <edwardk> the lens versin would be to make a class AsXml p f t where _Xml :: Over' p f t Xml  -- with way too general looking of a signature. then you can make instance AsXml p f Xml where _Xml = id   -- give you an equality, so you can use literally every lens combinator on it. instance AsXml Reviewed Identity Text where _Xml = unto convertTextToXml; etc.
11:32:06 <edwardk> then you can use  _Xml # whatever   to convert to _Xml
11:32:14 <edwardk> but for some things you can also use it as a prism to project it back out
11:32:55 <edwardk> er sorry
11:33:06 <edwardk> Over' p f Xml t i think
11:33:57 <edwardk> then you can use it to 'read' xml documents of the corresponding type if they parse
11:34:48 <edwardk> instance (Choice p, Applicative f) => AsXml p f XHtml where _Xml = prism ...
11:35:18 <edwardk> that could then check if your xml document is legal xhtml but it can also embed xhtml into xml
11:35:19 <troydm> monochrom: so my investigation on syscalls came to this http://lpaste.net/92041
11:35:57 <c_wraith> Huh.  Heinrich seems to put my mental model for space usage down in writing: http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html  I guess that's an indication that my mental model is appropriate.
11:36:19 <Zenol> @hoogle b -> ([a] -> b) -> [a] -> b
11:36:19 <lambdabot> No results found
11:36:28 <Zenol> :(
11:37:17 <mr-> Zenol: what should that do?
11:37:30 <nooodl> \x _ _ -> x, clearly :)
11:37:43 <c_wraith> the only way it's different from id is the leading b ->
11:38:03 <c_wraith> So, I'm assuming there's some special case (empty list?) where the first value is used, instead of the function
11:38:20 <Zenol> > let nonEmpty b f l = case l of [] -> b; l -> f l
11:38:21 <lambdabot>   not an expression: `let nonEmpty b f l = case l of [] -> b; l -> f l'
11:38:31 <Zenol> @let nonEmpty b f l = case l of [] -> b; l -> f l
11:38:32 <lambdabot>  Defined.
11:38:33 <c_wraith> maybe the function really wants a type like NonEmpty a -> b
11:38:36 <nooodl> :t maybe
11:38:37 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:38:51 <nooodl> :t listToMaybe
11:38:52 <lambdabot> [a] -> Maybe a
11:39:14 <Zenol> :t nonEmpty
11:39:15 <lambdabot> t -> ([t1] -> t) -> [t1] -> t
11:39:21 <nooodl> hm that probably wouldn't work huh
11:39:41 <c_wraith> Zenol: see, that'd by way clearer if you had a real NonEmpty type to distinguish the two different lists
11:39:45 <c_wraith> *be
11:40:10 <Zenol> c_wraith> Yes, but I don't know what's the standard "non mepty list" type.
11:41:54 <dmwit> type NonEmpty a = (a, [a])
11:42:14 <mr-> http://hackage.haskell.org/packages/archive/NonEmptyList/0.0.9/doc/html/Data-List-NonEmpty.html does it like dmwit suggests
11:43:27 <gilligan_> good evening
11:44:19 <dmwit> Yikes, that Monad instance...
11:44:53 <oleo> a true ca
11:44:54 <oleo> cat
11:45:12 <gilligan_> newbie question ?  avg xs = sum xs / fromIntegral $ length xs  .. that's flawed. I just don't understand why and how I would write that correctly ?
11:45:26 <elliott> I recommend using semigroups' NonEmpty.
11:45:31 <tikhon> gilligan_: you just need some parentheses
11:45:35 <dmwit> It parses as avg xs = (sum xs / fromIntegral) $ (length xs).
11:45:39 <dmwit> Do you see the problem now?
11:45:43 <dmwit> (and how to fix it? =)
11:45:45 <c_wraith> gilligan_: $ isn't magic parenthesis.  It's an operator.
11:45:54 <n-dolio> Is that the flaw that he was talking about?
11:45:54 <elliott> whoa, what /is/ that Monad?
11:46:02 <n-dolio> It's flawed in other ways, too.
11:46:05 <dmwit> elliott: It's the list monad.
11:46:16 <c_wraith> n-dolio: the other ways don't keep it from compiling
11:46:20 <elliott> well, okay. it's written pretty weirdly.
11:46:30 <mr-> elliott: Ah, thanks. I was sure i saw a less "experimental" NonEmpty somewhere :-)
11:46:36 <gilligan_> c_wraith,  d'oh
11:46:39 <hpaste_> stevejb pasted “plotPDF type error” at http://lpaste.net/92042
11:46:48 <gilligan_> c_wraith, thank you
11:46:50 <dmwit> elliott: It gives me the heebie-jeebies even though it seems okay after a bit of thought. =)
11:46:50 <gilligan_> ;)
11:46:52 <stevejb> hello, I am trying to use the plotPDF command from Chart to plot a list of functions over the same interval. I just pated the code I am trying to get to work.
11:46:53 <elliott> hmm, semigroups does it the same way.
11:46:55 <elliott> so whatever.
11:47:12 <tikhon> stevejb: you probably need to annotate the types of your inputs
11:47:30 <tikhon> try ([0.0,0.1..2.0] :: [Double])
11:47:34 <dmwit> semigroups' NonEmpty is not happy to be nonempty
11:47:43 <tikhon> (also, note that using .. with Doubles is not a good idea)
11:47:51 <tikhon> > [0.0,0.1..2.0]
11:47:52 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.60...
11:47:59 <tikhon> > last [0.0,0.1..2.0]
11:48:00 <lambdabot>   2.000000000000001
11:48:12 <tikhon> > 2.000000000000001 > 2.0
11:48:13 <lambdabot>   True
11:48:30 <stevejb> I did the :: Double annotation
11:48:31 <stevejb>  
11:48:37 <stevejb> it still cannot match it to [t0]
11:48:40 <dmwit> > 2.000000000000001 > 2.0 + (0.1 - 0.0) / 2
11:48:41 <lambdabot>   False
11:49:07 <tikhon> can you show me just the list with your annotation?
11:49:13 <c_wraith> I'm pretty sure everyone agrees the enum instance for Float/Double is terrible - but it's what's in the language spec.
11:50:00 <edwardk> mr-: you may want to use the http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-List-NonEmpty.html version as it subsumes the old NonEmpty
11:52:05 <stevejb> tikhon: which list? all_info?
11:52:14 <tikhon> the literal list
11:53:06 <stevejb> all_info :: [(Double -> Double, String)]
11:53:09 <tikhon> also, all_info is a list of pairs; I'm not sure how that would work with plotPDF
11:53:30 <tikhon> hmm
11:53:43 <tikhon> did you add an anotation to the first list you pass in?
11:54:33 <stevejb> sorry, I am not following. I see all_info, which other list do you mean?
11:54:42 <tikhon> the [0.0,0.1..2.0] list
11:54:59 <stevejb> ouh yeah, I did added :: [Double]
11:55:23 <tikhon> hmm
11:55:42 <stevejb> I think that plotPDF is trying to to create some kind of Renderable object, and it can't figure out which one
11:56:34 <tikhon> the later errors you have with no instances for Enum and Fractional imply it's something to do with the list of literals
11:56:35 <stevejb> tikhon: ack, got it. I was adding the annotation to the wrong place
11:56:36 <stevejb> works now
11:56:40 <tikhon> ah
11:56:42 <tikhon> okay, cool
11:56:43 <stevejb> thank you for your help
11:56:58 <tikhon> this is the main problem with using typeclasses like this: inference breaks
11:57:06 <troydm> now after some more investigating i have this http://lpaste.net/92043
11:57:12 <tikhon> it's not an issue for most programs, but Chart runs into it quite a bit
12:01:58 <ParahSai1in> @hoogle ($$)
12:01:59 <lambdabot> Text.PrettyPrint.HughesPJ ($$) :: Doc -> Doc -> Doc
12:01:59 <lambdabot> Text.PrettyPrint ($$) :: Doc -> Doc -> Doc
12:01:59 <lambdabot> Language.Haskell.TH.PprLib ($$) :: Doc -> Doc -> Doc
12:02:01 <stevejb> that makes sense given how flexible it is trying to be
12:02:43 <tikhon> oh yeah, it's a nice library, but writing ([0..] :: Double) all over the place is not appealing.
12:02:51 <corkexaminer> trying to RSA-sign some text and finding it difficult -- anybody succeeded in doing this with hackage?
12:02:54 <tikhon> one option to consider is using the extended default rules with it
12:03:35 <c_wraith> corkexaminer: I've done it with some library on hackage.
12:03:43 <corkexaminer> tried various packages with no success -- HsOpenSSL the latest
12:04:16 <corkexaminer> c_wraith: cool -- remember which one (even vaguely)?
12:05:13 <c_wraith> @hackage crypto-pubkey
12:05:13 <lambdabot> http://hackage.haskell.org/package/crypto-pubkey
12:05:31 <c_wraith> the Crypto.PubKey.RSA.PKCS15 module has a function "sign"
12:05:56 <c_wraith> ...  and a function "signSafer" that's more resistant to timing attacks.
12:06:22 <c_wraith> Similar stuff in the OAEP module
12:06:27 <S_J> >Squiggolers
12:06:28 <corkexaminer> c_wraith: yes, I started there, but ran into problems reading in the key from the PEM file
12:06:40 <c_wraith> oh!  I solved that too.
12:07:37 <c_wraith> The private key reads in just fine with the ASN1 stuff
12:07:44 <stevejb> tikhon: do you know if it is possible to add a caption to each plot using plotPDF?
12:07:53 <c_wraith> but public keys as packaged by OpenSSL are not *just* the public key
12:07:58 <c_wraith> They're a wrapper around the public key
12:08:15 <corkexaminer> c_wraith: agh -- ASN1 reader will read in PEM -- wonder bar!
12:08:42 <troydm> where can i report process related bugs?
12:08:59 <edwardk> hrmm, it looks like that catenable steque/heap thing from last night speeds up the sparse matrix multiplier by about 2 orders of magnitude
12:09:23 <corkexaminer> c_wraith: thanks very much
12:09:26 <edwardk> carter: ^-
12:09:32 <carter> edwardk?
12:10:13 <augur> anyone have a good tutorial on iteratees?
12:10:13 <c_wraith> corkexaminer: you may find http://lpaste.net/92044 to be handy.
12:10:19 <carter> edwardk is that a lens operator?
12:10:20 <carter> ohh
12:10:25 <carter> you meant c_wraith
12:10:35 --- mode: ChanServ set +o edwardk
12:10:42 <c_wraith> corkexaminer: it unpacks all the extra public key stuff that OpenSSL puts on PEM public keys
12:11:02 <mauke> lens needs a ☝ operator
12:11:23 <edwardk> carter no i meant the statement i made right above it
12:11:31 <Zenol> This hack xD Text.XML.Light's pretty print isn't really smart. To have a nice output, I have to first output my XML tree without pretty print, parse it again, and then output it with pretty print.
12:11:38 <Ipil> zenol
12:11:38 <carter> edwardk OOOOO
12:12:08 <carter> edwardk: with unbounded nesting of merges?
12:12:11 <edwardk> carter: i build a custom heap that allows for both fusion heap merges but also catenation for when we know one comes later
12:12:13 <edwardk> yeah
12:12:19 <corkexaminer> c_wraith: I am seriously grateful -- doubt if I would have had the time to work that all out
12:12:22 <elliott> now edwardk is a lens operator.
12:12:28 <troydm> guys, where can i report process package related bug?
12:12:29 <edwardk> then we build a Maybe (Heap a)  instead of a Stream
12:12:38 <edwardk> that lets me introspect on the streams knowing they are merges or appends
12:12:49 <c_wraith> corkexaminer: It's stuff I had lying around - glad it could be of use.
12:12:49 <edwardk> basically we get
12:13:16 <Zenol> Ipil: ?
12:13:22 <carter> question: how do i block Private messages from trolls
12:13:28 <carter> Zenol thats the trol
12:13:39 <c_wraith> corkexaminer: you might change it to use PEM instead of DER, but the rest of the code should be the same.
12:13:42 <carter> edwardk block the troll?
12:13:46 <edwardk> data Heap a = Heap !Key a [Heap a] [Heap a] [Heap a]   -- such that it is a non-empty heap, the first list is the pairing heap of heaps we havent sorted, the next heap list is a list of heaps in order that come next, and the last list is a list of heaps we haven't yet reversed yet but come last
12:13:53 <Ipil> zenol  pm
12:14:00 <tikhon> are you using ERC?
12:14:01 --- mode: edwardk set +b lpil!*@*
12:14:09 <carter> tikhon who are you asking about?
12:14:16 <tikhon> oh, about blocking people
12:14:21 <carter> whats erc?
12:14:29 <tikhon> an IRC client
12:14:30 <bennofs> an emacs irc client
12:14:34 <carter> oh
12:14:37 <tikhon> which, I think, a fair number of people here use
12:14:40 <carter> i'm using textual behind znc
12:14:53 <c_wraith> carter, I suspect /ignore blocks private messages - but I've never had to check.
12:14:54 <corkexaminer> c_wraith: just doing it now
12:14:54 --- mode: edwardk set +b *!~Ipil@187.153.74.248
12:14:55 --- kick: Ipil was kicked by edwardk (Your behavior is not conducive to the desired environment.)
12:14:55 <carter> edwardk: i'll be afk for a wee bit
12:14:57 <tikhon> because I have a good idea of how to block people there, and it probably works for pms too
12:15:19 <carter> brb in a while
12:15:22 <c_wraith> corkexaminer: I'm off to get lunch, so you're on your own. You've already got all I know. :)
12:15:29 --- mode: edwardk set -b lpil!*@*
12:16:28 <bgamari> edwardk, Is there any way to get lens to give me, (Functor f, ...) => f (ReifiedLens' (f a) a)?
12:16:40 <bgamari> where each slot of the functor is filled with a lens focused on that slot
12:17:09 <edwardk> bgamari: that isn't sound in general. because the 'path' is dependent on the value not the type
12:17:10 <bgamari> Or does this seem like a terrible idea?
12:17:16 <edwardk> however! there is something _like_ it
12:17:30 <bgamari> ahh
12:17:47 <edwardk> :t holesOf
12:17:57 <edwardk> :t holesOf both
12:17:57 <lambdabot> (b, b) -> [Control.Lens.Internal.Context.Pretext (->) b b (b, b)]
12:18:18 * bgamari looks up the haddocks
12:18:19 <bgamari> Thanks!
12:18:20 <edwardk> that gives you a list of all of the holes in a one-hole contexts of the structure
12:18:29 <edwardk> then you can use the pretext combinators to fill them
12:18:34 <corkexaminer> c_wraith: thanks -- should be able to take it from here
12:18:57 <edwardk> Pretext is basically a glorified store so thats bassically [(b, b -> (b,b))]
12:19:01 <edwardk> er basically
12:19:24 <edwardk> we don't currenty have a version of holes that put the holes right in the original structure, because that isn't always possible
12:19:49 <bgamari> excellent
12:20:01 <bgamari> I think I can probably work through it from here
12:20:03 <bgamari> thanks again!
12:20:41 <edwardk> :t contextsOf
12:20:42 <lambdabot> ATraversal' a a -> a -> [Context a a a]
12:20:54 <edwardk> that is useful when you want to work into a nested structure
12:20:57 <edwardk> e.g. a syntax tree
12:21:08 <edwardk> an for every node in the syntax tree you ant to be able to replace it getting a new one
12:21:33 <edwardk> that will deal with all nodes at all levels in the syntax tree
12:22:47 <NemesisD> hey guys. is it possible to compile and statically link a cabal project on a 64 bit system for a 32 bit target without having to use virtual machines?
12:23:18 <NemesisD> i've got a production system running an old version of scientific linux with ghc 7.0.4 and i just want to compile in a sane environment and dump a binary on that system
12:23:36 <NemesisD> rather than trying to build haskell-platform on a production box or spend all day trying to replicate that environment in a VM
12:27:10 * hackagebot buildwrapper 0.7.5 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.7.5 (JeanPhilippeMoresmau)
12:28:04 <xico> hi. i am using ghc's api to compile and load functions from a module. everything works great, but i have to add a "module " line and an "import " to each loadable script i write. is there a way to have each compiled script to be inside a specific module, exporting specific functions? and is there a way to have each script automatically import a given module?
12:28:57 <troydm> anyway here is the bug i've reported http://ghc.haskell.org/trac/ghc/ticket/8151
12:29:15 <troydm> related that strange forkIO and createSubprocess behavior on Solaris
12:32:10 * hackagebot scion-browser 0.2.18 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.2.18 (JeanPhilippeMoresmau)
12:36:03 <augur> someone explain iteratees to me! D:
12:36:48 <Zenol> Hum, what Ipil wrote is against Freenod rules. At who should I report so that he can be banned from Freenode network?
12:37:04 <augur> what did ipil write?
12:37:05 <geekosaur> #freenode channel
12:37:10 * hackagebot xml-conduit 1.1.0.7 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.1.0.7 (MichaelSnoyman)
12:37:24 <troydm> augur: pm's about white supremacy
12:38:10 <Zenol> geekosaur: Thanks :)
12:38:13 <augur> oy, yes, the racist trolls
12:38:20 <augur> they do this on occassion
12:38:53 <Zenol> Yes, but it's more than simple trolling as "<put a language name> is the best language ever".
12:40:00 <NemesisD> ugh cross-compilation still does not look easy in ghc
12:40:22 <tikhon> but it looks possible?
12:40:37 <NemesisD> evidently, it looks like you have to build a second ghc
12:40:43 <tikhon> oh, that sounds fun
12:41:06 <NemesisD> yeah. the thing i'm trying to avoid is wasting a bunch of time building for 32 bit so this isn't really a solution for me
12:41:11 <Zenol> NemesisD: If I recall what I read, you need a stage1 compiler targetting the platform you target.
12:41:15 <taylorgb_> NemesisD: Did you master your state machines in the end?
12:41:35 <NemesisD> taylorgb_: yeah, then proceeded to not need them ;)
12:41:49 <Zenol> there isn't any -m32 flag for ghc? :(
12:41:59 <taylorgb_> Sounds like functional programming 101
12:42:21 <taylorgb_> Do something complicated then realise you don't need it
12:43:36 <NemesisD> lol something similar happened at my last haskell meetup. half the group announced they were moving to another room to discuss some topic. someone asked what you could use that concept for in Haskell, silence
12:44:44 <taylorgb_> Yeah, I think we've all been there
12:44:46 <tikhon> and then, a few months later, something like lenses falls out :P
12:44:49 <taylorgb_> All part of the learning process
12:45:19 <tikhon> that's the wonderful thing with theory: you can never be really sure that something is not useful
12:45:32 <augur> someone! iteratees! plozzzx
12:45:50 <tikhon> I don't know anything about iteratees. Have you considered using Pipes?
12:45:56 <Zenol> NemesisD: Maybe you can download a 32bit ghc already build and run it?
12:47:27 <NemesisD> Zenol: my package manager has one but i don't know how i'd have it installed alongside the 64 bit one
12:48:13 <Zenol> NemesisD: If you download it you can run it without installing it. I'm afraid both 32bits and 64bits have the same name (namely ghc 7.6.3 if you have the last version)
12:48:50 <Zenol> (And, you need to have configured your distribution to be able to run 32bit)
12:50:15 <NemesisD> man i was hoping there was some i could just tunnel m32 down to the c compiler
12:50:47 <Zenol> which C compiler?
12:51:01 <NemesisD> gcc im assuming
12:51:11 <Zenol> ghc use LLVM
12:51:23 <Zenol> and some custom registery optimisation
12:51:29 <NemesisD> damn
12:51:38 <geekosaur> ghc doesn't normally use the c compiler at all?
12:51:44 <geekosaur> maybe for some FFI stuff
12:51:45 <NemesisD> why is life so hard when you're target environment is garbage
12:52:48 <Zenol> NemesisD: Download http://www.haskell.org/ghc/download_ghc_7_6_3#x86linux, run the stage 2 compiler with your stuff, and you'll be done. You can also install it with ./configure prefix=/usr/local/ghc32/ for example.
12:53:19 <Zenol> then /usr/local/ghc32/bin/ghc-7.6.3 yourstuff.hs -o yourstuff
12:53:32 <NemesisD> Zenol: think i could get cabal to use it?
12:54:35 <Zenol> NemesisD: Hum, I know that you can do cabal --with-ghc=/usr/local/ghc32/bin/ghc-7.6.3 but ...
12:54:55 <NemesisD> that should work
12:54:56 <Zenol> I think you should use cabal-dev or make a copy of you ~/.ghc and ~/.cabal before doing that.
12:55:07 <NemesisD> i'm guessing. lol.
12:55:30 <NemesisD> i use cabal sandbox so i should be good there. i'm going to see if i can unpack my OS's ghc i686
12:55:39 <Zenol> Because, I don't know if cabal will be smart enought to understand that this ghc-7.6.3(32) is'nt the good old ghc-7.6.3(64) he was used to.
12:55:58 <NemesisD> although this doesn't bode well for anyone on my team being able to build this project
12:56:45 <Zenol> NemesisD: What's good if you compile GHC yourself, it that you can add a suffix like ghc-7.6.3-m32 and ghc-7.6.3-m64
12:57:20 <NemesisD> Zenol: i may do that, i just want to see if this will even work
12:57:26 <Zenol> Then, shell script the sandboxed cabal stuff, so that your coworkers have nothing more to do than type ./build. But it's work :p
12:57:41 <NemesisD> my other choice which is probably better is to bug my coworker who knows chef to set up a 32 bit VM
12:58:46 <tikhon> but hey, at least you get to use Haskell at work :)
12:59:25 <tikhon> I love how emacs matched up the ) in my smilie with a frownie face earlier on in the conversation
13:01:20 <Zenol> Let me open some (((((((( for the next smileys you'r going to type :)
13:03:08 <NemesisD> i'm assuming if i run "file /path/to/compiled/binary" and it says 64 bit then this didn't work
13:03:56 <merijn> hmm, anyone know a good source for Shakespeare quotes to pun in my paper title?
13:04:07 <tikhon> Shakespeare plays?
13:04:50 <Zenol> NemesisD: Yes
13:04:57 <merijn> tikhon: pigworker shouldn't be the only one having fun with those!
13:05:19 <tikhon> merijn: I was proposing them as a source of quotes.
13:05:20 <Zenol> NemesisD: I'm trying to run the ghc-7.6.3-i386 version on my 64 bits system, and it's not working as expected :/
13:05:30 <merijn> tikhon: Well, yes, but which ones :p
13:05:44 <tikhon> The comedies are probably better-suited for it.
13:06:04 <NemesisD> ugh this sucks. i don't even know why we have this preference to run 32 bit old ass OSes in production
13:06:24 <tikhon> I guess it also depends on what your paper is about—I can imagine Romeo and Juliet being good for, e.g., generational garbage collection.
13:07:08 <merijn> tikhon: Oh, not relevant know, but I should keep that in mind when I retitle my distributed reference counting paper
13:07:12 <merijn> s/know/now
13:07:48 <Zenol> NemesisD: If I sucess to compile a 32bit hello world, I tell you.
13:08:00 <merijn> tikhon: I'm doing automated runtime prediction/modelling for code, "Curve Fitting for Fun and Profit" might be a bit too generic
13:08:43 <NemesisD> ok maybe you guys could help me identify an alternative plan: what if i set up a *newer* version of the target OS, 32 bit on a VM, should i just be able to specify -static or whatever the flag is in cabal and be able to drop it into production
13:09:04 <NemesisD> so in that situation the build environment will have the same arch as production but probably newer libs
13:09:12 <merijn> NemesisD: Yes, and also static linking is the default for Haskell
13:09:26 <SrPx> Any 3d engine?
13:09:34 <NemesisD> merijn: i thought it only statically linked haskell deps and not stuff like gmp
13:09:34 <merijn> NemesisD: (At least for the haskell libraries, C libraries are dynamically linked as usual)
13:09:52 <NemesisD> merijn: yeah i'll definitely have c deps, such as mysql client
13:10:05 <NemesisD> not my own deps but brought in by the mysql package
13:10:24 <DanBurton> @hoogle (f a -> f b) -> a -> b
13:10:24 <lambdabot> Test.QuickCheck.Arbitrary (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
13:10:25 <lambdabot> Test.QuickCheck (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
13:10:25 <lambdabot> Data.IntMap.Strict alter :: (Maybe a -> Maybe a) -> Key -> IntMap a -> IntMap a
13:10:55 <DanBurton> What would you call this function?
13:10:59 <geekosaur> is that even a sensible type?
13:11:17 <DanBurton> it is if you have something that is both a Monad and a Comonad
13:11:36 <DanBurton> @type let unFmap f = extract . f . return in unFmap
13:11:37 <lambdabot> Not in scope: `extract'
13:11:39 <elliott> it's sensible for some fs
13:12:12 <tikhon> would it be useful though?
13:12:35 <Cale> Maybe 'trace'?
13:13:11 <DanBurton> I'm not sure. It seems like it would be. It should be true that `unFmap (fmap f) == f`, but not necessarily true that `fmap (unFmap f) == f`
13:13:14 <Cale> Let me think, is that what it'd be? ;)
13:14:41 <DanBurton> Well to be honest, I'm actually trying to reason about the function (Monad m, Monad n) => (forall x. t m x -> t n x) -> (forall x. m x -> n x), which might be useful for completely different reasons
13:14:50 <DanBurton> but it's the same idea
13:16:40 <DanBurton> @type let unMFmap f = (undefined :: t m r -> m r) . f . lift in unMFmap
13:16:41 <lambdabot> (Monad m1, MonadTrans t1) => (t1 m1 a -> t m r) -> m1 a -> m r
13:19:28 <merijn> DanBurton: Not really, you can get things out of monads, you can't get things out of functors
13:19:51 <joelteon> well, you can't really get things out of monads
13:19:53 <merijn> (The only condition being you put them back in
13:20:16 <joelteon> right, but then you could use the same argument for fmap :|
13:20:20 <merijn> joelteon: You can as long as the eventual results ends up inside the same monad, which doesn't hold for fmap
13:20:23 <merijn> joelteon: No
13:20:34 <merijn> joelteon: You cannot get something out using fmap
13:20:43 <merijn> joelteon: That's the entire distinction between fmap and >>=
13:20:53 <elliott> "get something out"?
13:21:08 <elliott> fmap gives your function "a"
13:21:09 <merijn> elliott: Yeah, yeah, bad terminology and I don't have a better word
13:21:12 <elliott> (>>=) gives your function "a"
13:21:17 <elliott> what you get "out" is identical
13:21:22 <elliott> (>>=) just lets you put more back in
13:21:35 <levi> merijn: If you can't get things out of Functors, you can't get them out of Monads either. Monads are a proper subset of Functors.
13:22:00 <merijn> levi: I mean in the sense that with monad your behaviour can depend on the getting out
13:22:06 <merijn> levi: In functors it can't
13:23:06 <merijn> If I knew a better way to describe what I mean I would be using that...
13:23:37 <levi> Well, it's not really getting out, though.  Monadic actions get pure values passed to them that they can work with, while Applicative ones don't.  They are just *applied* to something.
13:26:11 <MouseTheLuckyDog> I  have a project I want to use either Haskell or Scala for. I'm leaning Haskell, but  I am storing  "parts of parts" stuff in a database. In Scala I think I could use a java based OODBMS. Does Haskell have a way of dealing with this?
13:26:34 <joelteon> persistent
13:29:45 <DanBurton> levi: "If you can't get things out of Functors, you can't get them out of Monads either. Monads are a proper subset of Functors" is wrong. It is precisely because Monads are a proper subset of Functors that you have additional "getting out" capabilities which you cannot assume of Functors in general
13:30:21 <DanBurton> Comonads are a proper subset of Functors, and they very definitely have a "getting out" ability: extract :: w a -> a
13:30:35 <pentace> MouseTheLuckyDog: What means "'parts of parts' stuff"?
13:30:38 <tikhon> or think about rephrasing that statement with "putting in" instead of "putting out"
13:30:58 <levi> F-algebras introduce things to a functor type, and F-coalgebras remove them.
13:32:19 <levi> Ever Monad is also a Functor.  Not every Functor is also a Monad.  Thus, the set of Monads is *smaller* than the set of Functors.  It is the subset.
13:32:32 <tikhon> that's certainly true
13:32:38 <DanBurton> agreed
13:32:58 <Zenol> NemedisD: Can't get the ghc libraries beeing installed with the 32bit release.
13:32:59 <DanBurton> I suppose it is the statement "you can't get things out of Functors" that is misleading and inaccurate
13:33:01 <joelteon> i still don't understand the distinction, though, because you provide a function a -> m b to bind that is given the value "inside" the monad
13:33:01 <tikhon> hence, some property that does not hold for *every* functor *could* hold for every monad
13:33:16 <joelteon> and you provide a function a -> b to fmap that is given the value "inside" the functor
13:33:34 <Zenol> NemedisD: Sounds like the VM or a true stage 1 cross compiler are better solutions.
13:33:52 <napping> levi: Every Comonad is a Functor, but you can get a value out of any Comonad but not some Functors
13:34:09 <DanBurton> fmap and bind are both arrow transformations. Fmap transforms (a -> b) into (m a -> m b), while bind transforms (a -> m b) into (m a -> m b)
13:35:03 <napping> levi: there can indeed be some monads from which you can't (nontrivally) extract a value, but just saying Monad is more specific doesn't explain that.
13:35:25 <napping> Reminds me of the difference between subtype and subclass in OO
13:35:26 <MouseTheLuckyDog> pentace: For example-- the parts of a car are the engine , the brakes system, ... the parts of the engine are the carburetors, the cylinders ... the parts of the carburetor   are the choke, the gas intake, in other words highly heirarchical data.  RDBMS are very bad at handling such data.
13:36:03 <Zenol> napping: can't nontrivially?
13:36:48 <Sonarpulse> I am working on making some dataypes for http://aoswiki.rakiru.com/index.php/Ace_of_Spades_Protocol
13:36:55 <tikhon> Zenol: not without writing partial functions, at the very least
13:36:59 <levi> napping: What Functor can you not get values out of?
13:37:11 <Sonarpulse> but I think i got out of controll making newtypes for everything
13:37:42 <Sonarpulse> anybody know much about my options for deriving binary/cereal instances?
13:37:46 <Zenol> tikhon: I think it's "can't trivialy".  no . not = id :: Bool -> Bool :p
13:37:53 <pentace> MouseTheLuckyDog: Haskell is very good at storing such data in ADTs and there are packages to store ADTs values in differents kinds of databases
13:38:15 <Sonarpulse> I am thinking just to give up on newtyping things, and make on big sum-of-records for the entire protocol
13:38:18 <napping> levi: newtype Const x a = Const x, for example
13:38:53 <napping> "trivially" being always returning undefined
13:39:06 <MouseTheLuckyDog> joelteon, persistent looks interesting can it handle indexed queries on heirarchical data efficiently?
13:39:12 <joelteon> no idea
13:39:23 <joelteon> I'd use mongo for that, or cassandra or something, there are probably bindings
13:39:29 <joelteon> I haven't messed with a document store in a long time so I couldn't say
13:40:08 <pentace> MouseTheLuckyDog: have a look at the acid-state framework, too
13:40:36 <Sonarpulse> mouseTheLuckyDog: http://acid-state.seize.it/
13:40:46 <Sonarpulse> pentace beat me to it
13:42:12 * hackagebot simple 0.5.0 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.5.0 (AmitLevy)
13:42:59 <slack1256> is there a library with predefined datatypes as in "beautiful folding"?
13:43:42 <levi> napping: You can't always get out *all* the information that goes into a functor; that's only true of values introduced via the initial F-algebra, if I understand correctly.
13:44:32 <applicative> slack1256: I think there's a million, Tekmo made one recently just a sec
13:45:15 <applicative> slack1256: http://hackage.haskell.org/packages/archive/foldl/1.0.0/doc/html/Control-Foldl.html
13:45:50 <slack1256> hahah I should have grep'd for Foldl instead of "beautiful"
13:46:19 <applicative> i'm not sure it's the latest version of foldl.  i was working on benching and optimization a week or two ago.
13:46:32 <BeardedCoder> Emacs users, I'm trying out haskell-unicode as my input method but sometimes it starts placing my currently type character on the far right side of the buffer until I type the next letter. Any ideas?
13:47:08 <Sonarpulse> doing right to left text by mistake?
13:47:14 <Sonarpulse> I am in emacs
13:47:28 <Sonarpulse> and made a few changes to somebody els's unicode syntax haskell
13:47:36 <Sonarpulse> but didn't have this problem
13:48:06 <applicative> slack1256: I think this version has the best pragma voodoo https://github.com/michaelt/Haskell-Foldl-Library/blob/bench/benchmarks/Foldl/Inline.hs
13:49:35 <applicative> slack1256: actually this one is best since it has Fold-interpreters for bytestring an d vector https://github.com/michaelt/Haskell-Foldl-Library/blob/bench/benchmarks/Foldl/Vector.hs
13:52:13 <Zenol> INLINE[1] ?
13:52:28 <applicative> yeah?
13:52:57 <applicative> in this case the idea is to get the 'applicative' combinators to inline asap; then later to inline 'fold'
13:53:08 <applicative> or is that what you were wondering?
13:53:23 <applicative> i'm by no means an expert on INLINE[n] black magic...
13:53:46 <Zenol> I was wondering what's the goal of the n value.
13:53:56 <geekosaur> which pass it applies to
13:54:01 <applicative> it's a count down basically
13:54:26 <Zenol> so [0] is the last one, and 1 the antepelnutian ?
13:54:31 <notasi> @src join
13:54:31 <lambdabot> join x =  x >>= id
13:54:39 <notasi> @src liftm
13:54:39 <lambdabot> Source not found. Do you think like you type?
13:54:41 <slack1256> To me rules with [n] parameter seem incredible fragile. But maybe that is because my inexperience.
13:54:42 <notasi> @src liftM
13:54:42 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
13:55:08 <applicative> slack1256: I don't think anyone thinks they're like having a typesystem or something
13:55:19 <joelteon> Zenol: antépénultième
13:55:20 <applicative> in this case the result is really obvious
13:55:25 <Zenol> 1 ~ last but one, 2 antepenultimate .
13:55:49 <geekosaur> somewhere in the documentation abotu them is a comment about how they know it's horribly ugly and fragile but it's the best they can do for now
13:55:51 <Zenol> joelteon: Yes I know the french word ;)
13:55:55 * applicative like antepelnutian
13:55:59 <joelteon> i've only ever seen it written in french
13:56:06 <applicative> the ancestors of the lilliputions
13:56:10 <applicative> the ancestors of the lilliputians
13:56:33 <applicative> we have 'antepenult' in english. usually when describing where accents fall in foreign languages
13:56:49 <notasi> antepenult is a noun I think and antepenultimate is the adjective
13:56:56 <applicative> yes
13:57:50 <applicative> slack1256: anyway, if you remove the [0] s and [1]s or swap them or whatever; it's a dog, this module
13:58:11 * Zenol was trying to guess the english word from the french word, and failed dismally.
13:58:17 <applicative> with them, it turns out simple microloops such as you might have killed yourself to write by hand
13:59:30 <applicative> even if your fold is e.g. liftA3 sum ((-) <$> maximum <*> minimum) maximum
13:59:40 <applicative> woops
13:59:50 <applicative> even if your fold is e.g. liftA3 (,,) sum ((-) <$> maximum <*> minimum) maximum
14:01:08 <applicative> i notice quite a bit in the statistics library that should properly be written this way, instead of mind-numbing tail recursive 'go moo bah where ...'
14:03:07 <cschneid> applicative: in the liftA3 example there, does it run through the whole list once, or 3 (4?) times?
14:03:20 <cschneid> or is that the discussion w/ the fold library
14:03:41 <applicative> cschneid: the whole idea of 'beautiful folding' was one pass
14:03:55 <applicative> where is that famous post?
14:04:16 <applicative> http://squing.blogspot.com/2008/11/beautiful-folding.html
14:04:47 <applicative> then tekmo and the pipes list sort of came upon the same http://www.haskellforall.com/2013/08/foldl-100-composable-streaming-and.html
14:05:17 <tehroflmaoer> could someone help me out with this type error I'm getting? http://lpaste.net/356517328206168064 details are inside
14:05:45 <applicative> it isn't brought out that the same folds can be used for anything sequential, e.g. vectors bytestrings, thought there is a fold interpreter in pipes-4.0
14:05:47 <geekosaur> "tekmo and the pipes list" sounds like some kind of postmodernist band
14:05:55 <applicative> hah
14:06:04 <edwardk> geekosaur: hah
14:06:14 <edwardk> @remember geekosaur "tekmo and the pipes list" sounds like some kind of postmodernist band
14:06:14 <lambdabot> I will remember.
14:06:27 <applicative> hah
14:07:15 <applicative> strange lpaste number tehroflmaoer
14:07:30 <geekosaur> it does that sometimes
14:07:53 <elliott> it's when you select a private paste
14:08:06 <tehroflmaoer> yeah it's a private paste
14:08:28 * bennofs posts it to facebook
14:09:05 <merijn> tehroflmaoer: Please annotate functions in pastes with types
14:09:19 <merijn> tehroflmaoer: I can't be arsed to guess what something's supposed to do after a work day :)
14:09:42 <tehroflmaoer> ah ok
14:10:18 <merijn> tehroflmaoer: Also, that forces you to think about what you're really doing and has been known to make people realise their mistake :)
14:10:32 <applicative> oic about private paste.
14:11:23 <applicative> tehroflmaoer: it would actually make the errors clearer in this sort of case, to use the types you mean, and not just what ghci would infer
14:11:45 <merijn> tehroflmaoer: oh, in fact, I think I already spotted the error and once you add types to your functions ghc should swiftly point you to the error of your ways :)
14:12:07 <tehroflmaoer> ok cool
14:12:09 <merijn> 10 bucks says GHC will complain about the type you specify for operation :)
14:13:27 <Cale> tehroflmaoer: operation (words line) list, supposing that op == "a" will produce (sort (el:list), True), and el = ... :: Int, so this has type ([Int], Bool)
14:13:51 <Cale> So op_res :: ([Int], Bool)
14:14:16 <merijn> Cale: I was kinda waiting for him to annotate the types and see if he figures it out alone :)
14:14:23 <merijn> Debugging is a valuable skill to learn :p
14:14:31 <tehroflmaoer> yeah, that's what I was going for though?
14:14:41 <tehroflmaoer> I wanted it to have type ([Int], Bool)
14:14:42 <Cale> However, you apply handle_op op_res, and handle_op (list, success) does putStrLn $ median list
14:15:13 <Cale> median list has a result which is quite clearly a number as well
14:15:28 <Cale> putStrLn wants a String
14:15:45 <merijn> I'm out 10 bucks, btw :(
14:16:06 <merijn> That's what I get for trusting instinct instead of types :p
14:16:28 <Cale> You'll also see that you're getting the error "No instance for (Fractional String)" because GHC infers that the result of median must be a String, and median tries to divide something of the same type by 2.
14:16:34 <Cale> (i.e. you're dividing a string by 2)
14:16:44 <applicative> does he want Fractional in there?
14:16:57 <Cale> That'll also be a problem with Int
14:17:03 <tehroflmaoer> yeah i figured that the fractional string was because ghc thought it was a string
14:17:13 * hackagebot bytes 0.11 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.11 (EdwardKmett)
14:17:13 <Cale> You can't divide an Int by 2 using (/) either
14:17:15 <tehroflmaoer> but why does changing printStrLn to print fix it?
14:17:24 <merijn> :t print
14:17:25 <lambdabot> Show a => a -> IO ()
14:17:26 <Cale> Because print = putStrLn . show
14:17:29 <applicative> btw tehroflmaoer length list `mod` 2 == 0  can be replaced by even (length list)
14:17:31 <merijn> :t putStrLn
14:17:32 <lambdabot> String -> IO ()
14:17:54 <merijn> tehroflmaoer: putStrLn wants a String, print accepts anything that is an instance of Show
14:18:17 <merijn> > show 5
14:18:35 <lambdabot>   "5"
14:18:43 <merijn> Nice and fast there, lambdabot
14:18:51 <merijn> @botsnack
14:18:51 <lambdabot> :)
14:20:08 <Cale> tehroflmaoer: If you write top level type signatures for your functions, the error messages you get will be much better in general.
14:20:37 <merijn> Also, it makes you think about what you're *actually* trying to do :)
14:20:41 <Cale> Because GHC will be able to tell where things don't match your intention, rather than globally inferring that something is wrong.
14:20:45 <ParahSailin> anyone work with xml-conduit Stream parsers?
14:21:02 <merijn> ParahSailin: I used it once a while ago? :p
14:21:15 <Cale> (and then reporting it at the first place that it notices, when it could potentially report it in many places)
14:21:32 <tehroflmaoer> ah ok
14:21:37 <hpaste_> applicative annotated “list median” with “list median (annotation)” at http://lpaste.net/356517328206168064#a3945108614506610688
14:21:54 <applicative> here's a bit of the repairs http://lpaste.net/356517328206168064
14:22:16 <applicative> oh the one listed above.  even 'secret pastes' are announced
14:22:17 <tehroflmaoer> I had read I think in LYAH that it was best to not add the type signature unless you had to?
14:22:25 <tehroflmaoer> am I mistaken?
14:22:34 <applicative> i think there's no simple answer
14:23:03 <merijn> tehroflmaoer: I doubt LYAH says that, or at least I hope it doesn't
14:23:03 <applicative> i think it's important when confused to make sure things are specialized to e.g. Int not Num a => ...
14:23:28 <merijn> tehroflmaoer: It's common practice to explicitly specify types for top level definitions
14:23:41 <monochrom> why not do both. omit type, see what is inferred. add type, see if yours is accepted.
14:23:45 <applicative> so for example, if you specialize some things just by hanging (x :: Int) or (xs:: String) in suitable places
14:23:58 <merijn> tehroflmaoer: It functions partially as documentation and partially as sanity check
14:24:15 <applicative> it is definitely bad practice to get the signature from ghci and paste it.
14:24:29 <RevJohnnyHealey> monochrom: I do it in the opposite order, add type to implement, then remove it to see what is inferred.
14:24:31 <applicative> you should get the signature from ghci and specialize it... after pasting ...
14:24:50 <merijn> tehroflmaoer: Also, in case of excessive polymorphism GHC might try harder to make things work than you'd like (like suggesting you want a Fractional instance for String instead of saying "uh, this isn't a String, dude...")
14:24:50 <applicative> RevJohnnyHealey: of course that's informative too
14:25:33 <dmwit> I sometimes wish for a "unifies-with" annotation.
14:25:35 <monochrom> if you now ask, "but which one do I do in production code?", then I ask back, "are you ready to produce production code?". because if you were ready, you would already have the ability of judgement, you would not be asking.
14:25:52 <dmwit> id :< a -> b
14:25:58 <dmwit> id :> Int -> Int
14:26:04 <ParahSailin> @src join
14:26:04 <lambdabot> join x =  x >>= id
14:26:52 <FardadJalili> pattern matching evaluates, right?
14:27:06 <dmwit> Hm, tricky question.
14:27:10 <dmwit> Not really?
14:27:13 <tomejaguar> FardadJalili: pattern matching forces as much of the pattern as it needs to
14:27:28 <monochrom> the correct answer is the tautological answer :)
14:27:30 <tikhon> which is almost a tautology :P
14:27:31 <tomejaguar> or rather as much of the value as it needs to to test if it matches the pattern
14:27:33 <dmwit> If you force the result of something defined with a pattern match, the thing matched on will be forced far enough to know which pattern matches.
14:27:39 <applicative> RevJohnnyHealey: its true you can labor over something you think of as specific and concrete; scrap the signature and realize it's a very abstract combinator
14:27:50 <monochrom> but see my http://www.vex.net/~trebla/haskell/lazy.xhtml
14:28:00 <tehroflmaoer> merijn: ah, I'll try to use types from now on, thanks!
14:28:19 <FardadJalili> so func 0 _ = 0
14:28:37 <FardadJalili> does it only evaluate the first input?
14:28:45 <applicative> tehroflmaoer: you know you can annotate inline so to say, foo x y z = x + (2::Int) * y
14:28:57 <applicative> which forces everything to be Int anyway
14:28:57 <monochrom> yes
14:29:13 <merijn> tehroflmaoer: To give you an indication of the usefulness, I have on multiple occasions debugged people's problems here, without understanding a single thing about what their code was supposed to do :)
14:29:21 <dmwit> When the first input is 0, the second input is not evaluated.
14:29:34 <merijn> tehroflmaoer: Just by looking at their types and seeing they don't add up to something sensible
14:29:36 <FardadJalili> monochrom: and f a b = a + b doesn't evalute at all. Ok, thanks :D
14:29:52 <dmwit> urr
14:29:54 <monochrom> beware of what "a + b" will do
14:30:13 <FardadJalili> what do you mean?
14:30:24 <applicative> merijn: oh it's not like with me; occasionally I can figure out the actual purpose of these programs ...
14:30:24 <merijn> monochrom: Well, "a + b" won't do anything until the result of "f a b" is evaluated, no?
14:30:28 <dmwit> Forcing a + b may or may not force a or b depending on how (+) is defined.
14:30:29 <tikhon> to get the result of a + b, you have to know what a and b are
14:30:36 <dmwit> and (+)
14:30:42 <tikhon> for most types of numbers, anyhow
14:30:46 <merijn> dmwit: Right, but that only happens when the result of f is forced, no?
14:30:57 <dmwit> Nothing ever happens except when things ar eforced.
14:31:00 <dmwit> So the question isn't useful.
14:31:01 <monochrom> there is no such thing as "f a b is evaluated, but a + b is not"
14:31:03 <merijn> ah, true
14:31:10 <applicative> instance Num () where (+) = const
14:31:10 <merijn> nvm, I'm silly
14:31:29 <FardadJalili> but now that I think about it
14:31:38 <FardadJalili> seq is implemented like this
14:31:43 <FardadJalili> seq :: a -> b -> b
14:31:46 <tikhon> seq is actually a primitive
14:31:49 <FardadJalili> seq _ a = a
14:31:52 <dmwit> no
14:31:52 <tikhon> the compiler provides it
14:31:55 <dmwit> seq is not implemented like that
14:32:06 <monochrom> "seq _ a = a" does not evaluate a
14:32:13 <slack1256> althought, that is a primitive is not a bad thing.
14:32:19 <FardadJalili> it is supposed to evaluate the first input
14:32:24 <monochrom> read my http://www.vex.net/~trebla/haskell/lazy.xhtml already
14:32:40 <monochrom> I have no further comments.
14:32:46 <tikhon> to the best of my understanding, you simply can't implement seq directly in Haskell (without resorting to built-in things isomorphic to seq)
14:33:03 <FardadJalili> it means that, the person who said seq is implemented like that was just trying to tell what it is doing? :)
14:33:17 <FardadJalili> monochrom: Ok, don't be hard on me, I read a lot actually ;)
14:33:31 <tikhon> yes, if you ignore how things get evaluated, seq is just const
14:33:48 <monochrom> that is technically wrong, but ok
14:33:54 <tikhon> is it?
14:33:58 <merijn> tikhon: it's flip const
14:34:02 <tikhon> oh
14:34:04 <tikhon> fair enough
14:34:05 <merijn> :t seq
14:34:06 <rtb> data ITree a = Leaf (Int -> a)
14:34:06 <lambdabot> a -> b -> b
14:34:07 <tomejaguar> It would be cool if seq :: WHNFData a => a -> b -> b
14:34:07 <rtb>              | Node [ITree a]
14:34:10 <merijn> :t const
14:34:11 <lambdabot> a -> b -> a
14:34:12 <rtb> sorry
14:34:15 <tomejaguar> for some typeclass WHNFData that could be derived
14:34:18 <tikhon> and "ignore how things get evaluated" is a bit broad
14:34:37 <rtb> I cannot get values into this data construct
14:34:43 <rtb> pls help
14:34:44 <monochrom> const x ⊥ = x, seq ⊥ x = ⊥. This is even after taking into account flipped argument order.
14:34:48 <tikhon> there's two different concerns: performance and correctness; seq is different from const in both
14:34:59 <rtb> typeclassopedia functor exerc 3 or so
14:35:00 <merijn> rtb: "Leaf id" done? :)
14:35:03 <tomejaguar> rtb: What do you mean can't get values into?
14:35:14 <monochrom> and this is not delving into evaluation.
14:35:21 <rtb> like merijn mentioned, I try :)
14:35:24 <S_J> > (1+) . (*7) 4
14:35:25 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
14:35:26 <lambdabot>    arising from a use ...
14:35:29 <S_J> > (1+) . (*7) 4 5
14:35:31 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> a -> c))
14:35:31 <lambdabot>    aris...
14:35:44 <S_J> > (2+) . (*7) $ 5
14:35:45 <lambdabot>   37
14:36:03 <tikhon> so if you don't care about ⊥ (and, in most code, I don't) and you don't care about performance (ditto), seq is basically flip const :D
14:36:24 <c_wraith> yes!
14:36:33 <rtb> so ID without an Int?
14:36:49 <c_wraith> I feel like apfelmus's recent post on space use was really good.
14:36:56 <monochrom> it is very hard to not care about ⊥. every time you use self-reference, you need to care about ⊥
14:37:37 <monochrom> and this is even if you can prove that your self-referencing thing is "terminating" or "productive" or whatever. you still need ⊥
14:37:42 <rtb> ok seems to work, so value itself is a function...
14:37:49 <rtb> beautiful..
14:38:00 <tomejaguar> Is there a correct program that contains _|_ that does not have an equivalent that does not contain _|_?
14:38:16 <tikhon> monochrom: what I mean is that I do not care very much about what happens when my function gets ⊥ as an argument
14:38:21 <monochrom> because the denotational semantics of "xs = 0 : xs" begins by considering the sequence ⊥, 0:⊥, 0:0:⊥, ...  and then take limit
14:38:25 <tikhon> I suppose I usually do care if my program itself terminates
14:38:29 <tikhon> although I'm not always that picky
14:38:39 <monochrom> see my example
14:38:43 <napping> monochrom: sure, but if you can prove it's productive you don't need seq to implement it
14:39:06 <napping> the difference between seq and const is irrelevant only in cases when there was no point to using seq
14:39:12 <monochrom> did I say that you need seq to implement it?
14:39:54 <tikhon> I suppose my point was ultimately just that, for me, there would be no point to use seq in most of my code
14:39:59 <tikhon> and so I don't
14:40:01 <monochrom> and it is not like you use const to implement it either
14:40:06 <carter> tikhon : i have to say, its great having you on IRC a lot more lately
14:40:32 <monochrom> I am saying, on a recent subject, you care about ⊥ even when you know termination
14:40:38 <tikhon> heh, it's probably good to hear from somebody who doesn't have to care much about performance :)
14:40:43 <tomejaguar> monochrom: that I don't understand
14:40:57 <monochrom> just yesterday I had two great examples.
14:41:44 <monochrom> in IO, sometimes you write: main = print 0 >> main. its meaning rests on what happens to print 0 >> ⊥.
14:42:00 <tomejaguar> Does it
14:42:36 <monochrom> "main = print 0 >> main" prints out things because "print 0 >> ⊥" manages to make one printout before giving up
14:43:09 <monochrom> whereas "main = main >> print 0" doesn't print out anything because "⊥ >> print 0" gives up before managing to print
14:43:16 <tomejaguar> It's not clear to me that has anything to do with _|_
14:43:33 <tomejaguar> no thunks which evaluate to _|_ are created in the execution of that progr
14:43:35 <tomejaguar> am
14:43:39 <carter> tomejaguar tomorrow right?
14:43:43 <carter> or am i mixing up handles?
14:43:54 <S_J> > Left 5 >>= return . (+1)
14:43:55 <lambdabot>   Left 5
14:44:06 <S_J> > Right >>= return . (+1)
14:44:07 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
14:44:07 <lambdabot>    arising from a use ...
14:44:10 <monochrom> in contrast, in Control.Monad.State.Lazy, "gen = gen >> modify (0:)" does something useful because "⊥ >> modify (0:)" does something useful
14:44:13 <S_J> > Right 5 >>= return . (+1)
14:44:14 <lambdabot>   Right 6
14:44:41 <monochrom> and "gen = modify (0:) >> gen" doesn't because "modify (0:) >> ⊥" doesn't
14:44:44 <tomejaguar> carter: yes tomorrow!
14:44:54 <carter> tikhon back in cali?
14:45:13 <monochrom> see my http://lpaste.net/41790/
14:45:49 <tomejaguar> I can see how _|_ can help you with an analysis, but i don't see that it's required
14:46:47 <tikhon> carter: I'm flying back in about a week
14:48:32 <monochrom> the dual sentence is also valid. I can see how thunks and evaluation strategy can help you with an analysis, but I don't see that it's required
14:48:58 <tomejaguar> Really?
14:49:06 <tomejaguar> You can do it all in terms of _|_+
14:49:08 <tomejaguar> *?
14:50:44 <monochrom> in fact, suppose you analyze independently of any Haskell compiler/interpreter. then you have to limit yourself to something like the Haskell 2010 Report. which totally does not say thunks or how to evaluate. it only says a few words on how you get ⊥ and not ⊥
14:51:15 <monochrom> in other words, it tries to stay denotational, and avoids being operational
14:52:04 <monochrom> whereas if we were talking in #sml or something, you would be totally right. SML's definition is entirely operational. evaluation strategy is required.
14:52:25 <Cale> I also don't really like using the word "thunks" unless I'm referring to the particular implementation details of how expressions are represented at runtime.
14:52:28 <tomejaguar> Hmm interesting.  I did not know that _|_ was enough.
14:52:49 <Cale> Even when talking operationally, I prefer to just speak of expressions being reduced.
14:53:16 <monochrom> I agree with Cale. see my http://www.vex.net/~trebla/haskell/lazy.xhtml
14:53:29 <Cale> I guess it's similar in nature to how I dislike the abuse of the term "closure" to mean "function".
14:53:43 <monochrom> thunks : expressions :: electrical signals
14:53:47 <monochrom> err
14:53:49 <monochrom> thunks : expressions :: electrical signals : bits
14:54:25 <monochrom> even when you talk operational, you don't always go that low-level
14:55:39 <dmwit> ?src (>>=) State
14:55:39 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:56:01 <dmwit> ?djinn (s -> (a, s)) -> (a -> s -> (b, s)) -> (s -> (b, s))
14:56:01 <lambdabot> f a b c =
14:56:01 <lambdabot>     case a c of
14:56:01 <lambdabot>     (d, e) -> b d e
14:56:29 <monochrom> are you studying State.Lazy vs State.Strict? :)
14:56:40 <DanBurton> Regarding monad laws. Is it fair to say that (join (fmap f x)) should be the same as (f (join x)), where x :: m (m a), f :: m a -> m b?
14:56:47 <dmwit> I am studying gen = gen >> modify (:0) vs. gen = modify (:0) >> gen. =)
14:56:53 <monochrom> here is the nutshell. for State.Lazy, you have ~(d,e) there instead of just (d,e).
14:57:05 <dmwit> aaaah
14:57:13 <dmwit> sneaky =)
14:57:13 <monochrom> THAT IS ALL!
14:57:30 <geekosaur> ?src State (>>=)
14:57:30 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:57:32 <monochrom> of course, in the real code, they use "let" instead of "case" there
14:57:35 <Cale> DanBurton: no, I don't think so.
14:57:47 <DanBurton> in other words, x >>= f = f (join x), whenever you can actually do that
14:58:16 <napping> DanBurton: I think that's only required for f == join
14:58:36 <DanBurton> it's also required when f = fmap g for some g
14:58:43 <Cale> If f = id, it's true.
14:59:19 <napping> well, it's basically one of the laws with join
14:59:25 <napping> and may be implied in other cases
14:59:39 <dmwit> > let f [1] = "no"; f [2] = "no"; f [1,2] = "yes" in ([[1],[2]] >>= f, f (join [[1],[2]]))
14:59:40 <lambdabot>   ("nono","yes")
14:59:44 <dmwit> NEXT
14:59:46 <khyperia> pentace, last night (about 18 hours ago, since timezones are weird), you help me with a lib compiling problem I had... turns out the maintainer just pushed a commit two hours ago fixing my problem, but thanks anyway for the help
15:00:16 <DanBurton> Right, the laws of join are (join . fmap join = join . join) and (join . fmap (fmap f) = fmap f . join), iinm
15:00:26 <DaveS> > (concat $ replicate 10 "NaN") ++ " Batman!"
15:00:27 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaN Batman!"
15:00:58 <DanBurton> when you consider that id = fmap id, then Cale's observation just falls under the second rule
15:01:12 <pentace> khyperia: Ah, nice to hear that :)
15:01:17 <Rarrikins> join . fmap f = f . join
15:01:39 <DanBurton> Rarrikins: that's the question
15:01:50 <dmwit> DanBurton: Did you see my snippet?
15:01:52 <Rarrikins> Ahh, I see :)
15:01:54 <kylcarte> a question: what's the term for the "Foo {..}" syntax? and, is it just equivalent to "Foo { foo = undefined, bar = undefined, ... }" ?
15:02:04 <DanBurton> dmwit: ahh I missed that
15:02:04 <Rarrikins> kylcarte: Record syntax.
15:02:12 <levi> monochrom: I'm not sure why you're trying to make a denotational/operational distinction with regard to _|_. It's used for both types of semantics, isn't it?  Most of the semantics I've looked at have been operational and have included it.
15:02:24 <Cale> kylcarte: That's RecordWildCards, and no.
15:02:26 <Rarrikins> kylcarte: Oh, for that in particular. Not sure yet.
15:02:36 <DanBurton> dmwit: very nice, I might have to steal that
15:02:37 <dmwit> levi: Operational semantics include _|_?
15:02:45 <Cale> kylcarte: It binds the fields of the record to things in local scope which have the appropriate names.
15:03:56 <kylcarte> Cale: ah, okay. Thanks. Sounds similar to Record Puns. How is it different?
15:04:26 <kylcarte> Cale: nvm. I understand. Puns are similar, but for pattern binders
15:04:30 <kylcarte> correct?
15:04:30 <monochrom> that is not what I saw, levi.
15:04:32 <ReinH> hai
15:04:37 <Cale> kylcarte: It's different in that you use the notation {..} instead of explicitly naming the fields you're binding
15:04:52 <Taslem> Is there only one valid definition of (>>=) and return for the list monad?
15:04:53 <levi> dmwit: Am I wrong about that? I could be confusing things I've read; I've sampled broadly but not terribly deeply.
15:05:06 <Cale> kylcarte: and it works in patterns as well, just like puns
15:05:26 <Cale> kylcarte: The difference is just whether the names of the fields are explicitly mentioned.
15:05:32 <dmwit> Usually (these days, at least) operational semantics means giving a small-step semantics, which just says what terms step to other terms.
15:05:53 <DanBurton> But it is a law that (fmap f . return = return . f), and similarly that (extract . fmap f = f . extract), iinm
15:05:53 <dmwit> I would say it's very unusual indeed to say a term steps to _|_, since that would mean _|_ is actually a term in your language.
15:06:02 <monochrom> perhaps you have been looking at: proofs and/or discussions of relations between operational and denotational. they have ⊥, because of the denotational side
15:06:06 <DanBurton> Just trying to make sense of the relationship between extract & join, return & duplicate
15:06:13 <Cale> RecordWildCards has the potential to be much more terse, but it comes at the cost of being somewhat more magical, in that if you use it in a pattern, it binds a bunch of things which aren't otherwise mentioned.
15:06:28 <Rarrikins> Taslem: You can probably convert it to a Maybe with the presence of its first element.
15:06:33 <kylcarte> Cale: I see. Thanks.
15:06:34 <Cale> and if you use it in an expression, it relies on certain names being in scope which again are not otherwise mentioned
15:06:39 <Rarrikins> Taslem: I think that would still satisfy the monad laws.
15:07:12 <Taslem> Rarrikins: What would it do with lists of length more than 1?
15:07:19 <Rarrikins> Taslem: Ignore the tail.
15:07:38 <Taslem> Rarrikins: Then >>= return would modify the list.
15:07:59 <Taslem> Oh, wait. I see
15:08:30 <Taslem> No, wait. You'd have to either drop the tail or keep it the same, where that would make it the wrong type.
15:08:53 <dmwit> :t \xs f -> xs >>= take 1 . f
15:08:54 <lambdabot> [a] -> (a -> [b]) -> [b]
15:09:12 <levi> dmwit: I see that point, but what do you *say* about divergent terms?  Just that they diverge?
15:09:14 <dmwit> > [1,2,3,4] >>= take 1 . return
15:09:15 <lambdabot>   [1,2,3,4]
15:09:51 <dmwit> levi: for example, yes
15:09:54 <Rarrikins> Taslem: I think functions that changed the type of the list would necessitate dropping the tail.
15:10:08 <dmwit> levi: You say there is no value that they step to.
15:10:08 <Rarrikins> Taslem: Hmm, though I suppose they could be converted as well. Never mind.
15:10:18 <Taslem> Right, which is why I was thinking it was unique.
15:10:24 <Taslem> Though I can't figure out how one might prove that.
15:10:55 <dmwit> Taslem: Do you still believe that Rarrikins' proposed alternative does not satisfy the laws?
15:11:02 <Taslem> dmwit: Yes
15:11:11 <Taslem> dmwit: Was your function supposed to be an implementation?
15:11:15 <dmwit> yes
15:11:25 <levi> dmwit: That seems to contrast with the idea that 'well typed programs don't go wrong'; i.e. you have to include bottom in your type if you want that statement to be true.
15:12:02 <dmwit> levi: Not at all. One precise version of that is "every well typed program is either a value or takes a step".
15:12:16 <dmwit> levi: Well, and additionally, if it takes a step, it's still well typed. =)
15:13:19 <dmwit> Taslem: seems to fail the return x >>= f = f x rule
15:14:01 <dmwit> > (\xs f -> xs >>= take 1 . f) (return 1) (replicate 5)
15:14:02 <levi> At that point, it seems a pretty minor distinction between 'this type contains bottom' and 'expressions of this type may step indefinitely without converging to a value'.
15:14:02 <lambdabot>   [1]
15:14:06 <dmwit> > replicate 5 1
15:14:07 <lambdabot>   [1,1,1,1,1]
15:14:17 <dmwit> levi: Nobody says the latter thing.
15:14:50 <dmwit> levi: In fact, it's expected that be true unless you explicitly prove otherwise, and doing so is usually hard. =)
15:15:42 <levi> Well, that's what formal semantics are *for*.
15:15:53 <dmwit> Is it?
15:16:13 <monochrom> "it seems a pretty minor distinction" is correct. because of "seems".
15:16:25 <levi> What is the point of them if not to assign meanings to programs in a manner that allows you to prove things about them?
15:17:01 <khyperia> Oh gosh. This is going to sound really, really dumb, but I just got into FP and I'm learning. I just figured out that "let x = value in expr" is the same as "(\x -> expr) (value)"
15:17:14 <dmwit> levi: Your "assign meanings to programs ... prove things about them" is general enough that to me it doesn't obviously imply "we must want to say that no terms diverge".
15:17:31 <dmwit> khyperia: They're not the same in most languages.
15:17:40 <levi> dmwit: Oh, that's not what I meant; I meant proving things in general, not proving things don't diverge.
15:17:45 <dmwit> khyperia: The former allows x to be more polymorphic, usually.
15:17:59 <khyperia> ah.
15:18:10 <dmwit> levi: Okay, well, if you throw out the idea of proving things don't diverge, why are you so surprised you don't need to talk about not diverging?
15:18:25 <levi> dmwit: I didn't say that either!
15:18:26 <khyperia> I learned lambda calculus a while back, so I'm kinda in the thought process of that and it's untyped nature.
15:18:40 <levi> Proofs about divergence are just one sort of thing you might want to prove.
15:18:57 <Cale> khyperia: But yeah, they're definitely similar.
15:19:00 <dmwit> levi: What *are* you saying, then? I thought this started with "most operational semantics talk about _|_".
15:19:02 <levi> The point of semantics is to prove things *in general*, and that happens to be one interesting case.
15:19:06 <c_wraith> khyperia: they have different pattern-matching semantics, too, if "x" is a pattern, rather than a simple identifier.
15:19:31 <levi> dmwit: Well, apparently I was confused about that part! I am just trying to get to the bottom of my confusion.
15:19:49 <dmwit> khyperia: Right, in the untyped setting, let is often presented as just syntactic sugar for a lambda. =)
15:20:16 <dmwit> (But not always -- e.g. I know of at least one paper that uses "let" to mark allocations.)
15:20:31 <monochrom> haha "bottom of my confusion" pun!
15:20:33 <Sonarpulse> On a completely unrelated note, can a ADT with lots of {#-UNPACK-#} -ing go in registers, or only an unboxed tuple?
15:21:00 <Sonarpulse> (forget the "On a completely unrelated note", bad copy paste)
15:21:34 <levi> Unintentionally punny. :)
15:21:39 <c_wraith> it is completely unrelated, though.  so you're cool.
15:22:00 <c_wraith> And no, ADTs still have a constructor and a memory layout even with all their fields unpacked
15:22:11 <c_wraith> they can still be unevaluated
15:22:24 <dmwit> levi: In any case, I don't think a lot of operational semanticses mention _|_.
15:22:40 <c_wraith> If you want to guarantee you skip the registers, use unboxed tuples.
15:22:47 <c_wraith> err, stay in the registers only
15:23:21 <khyperia> although nothing is ever guaranteed with low-level compiler stuff like that, I would guess.
15:23:59 <khyperia> but "usually" is a pretty safe word, I'd imagine.
15:25:20 <napping> Sonarpulse: http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/
15:25:58 <napping> I think that's the main way constructor arguments end up being passed in registers, and it's unrelated to UNPACK
15:27:11 <levi> dmwit: OK. Maybe the things I've been reading have been more denotationally-oriented than I'd thought.
15:28:42 <Sonarpulse> thanks
15:28:49 <Sonarpulse> napping
15:29:57 <Sonarpulse> you too, c_wraith
15:30:20 <Sonarpulse> I read you can't newtype types of kind #
15:31:30 <Sonarpulse> I get why that might be the case, with polymorphism historically confined to *, but doesn't seem like the best idae
15:33:35 <mpu> Hi, how can I retreive the message in a userError exception
15:34:19 <mpu> I use fail in the IO monad for my interpreter and I would like to retreive the error message to display it nicely.
15:34:31 <napping> Sonarpulse: you'd  have to look up System Fc, seems like making a newtype of something of kind # have kind # might be safe, but I don't know if coercions can coerce things of kind #
15:35:36 <Sonarpulse> well doing (# Int# #) should have kind of the effect of a newtype, right?
15:36:15 <Sonarpulse> and (# (# Int# #) #) and so on
15:36:48 <Sonarpulse> so the basic concept of differentating identicall unboxed types at compile-time is already there
15:37:40 <napping> I don't see how you can conclude that
15:37:56 <napping> in what sense are those unboxed tuples identical?
15:38:18 <Sonarpulse> well i guess I have no idea whether you can nest unboxed tuples
15:38:24 <napping> newtypes are based around a whole system for explicitly representing evidence that various types are in fact identical http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/FC
15:38:54 <napping> those types might happen to be represented in the same way at runtime, but I don't think they are considered equivalent - certainly not until a later stage than Core
15:39:21 <levi> Hmm, TAPL describes bottom, explains why it's useful, and then explains that it adds difficulty to type inference and says it's not going to use it further in the book.  He does keep top, though.
15:39:32 <napping> levi: entirely different bottom
15:40:08 <napping> that's a bottom in a lattice of types, rather than a bottom of a lattice of values in a type
15:40:56 <roconnor> array is insufficently lazy!
15:40:56 <monochrom> yeah
15:41:08 <monochrom> to both sentences :)
15:41:26 <roconnor> > bounds (array (0,10) undefined)
15:41:27 <lambdabot>   *Exception: Prelude.undefined
15:41:28 <Sonarpulse> napping: does Int# -> (# Int# #) become a no-op?
15:41:35 <RevJohnnyHealey> which array?
15:41:44 <monochrom> wait, that looks wrong
15:41:45 <roconnor> that array
15:41:54 <Sonarpulse> if it does, and yet the types are never considered identically, pragmaticcally I don't see a problem
15:42:00 <monochrom> @type array (0, 10) undefined
15:42:01 <lambdabot> (Num i, Ix i) => Array i e
15:42:12 <levi> napping: I see.  That's the bottom I was thinking of, but I see the distinction now that you mention it.
15:42:14 <Sonarpulse> * considered identical
15:42:34 <monochrom> oh, I see what you mean. I have no opinion on this matter, but you may be right
15:43:11 * roconnor is trying to recurssivly use the bounds of an array in building the contents of the array.
15:43:22 <monochrom> > bounds (array (0,10) (replicate 11 undefined))
15:43:23 <lambdabot>   *Exception: Prelude.undefined
15:43:31 <napping> Sonarpulse: the problem is that newtype it self is based on a system for explicitly representing stuff about which types are equivalent, and if that system doesn't work at # then newtype won't either
15:43:45 <napping> at the core level it compiles to Test.foo = GHC.Prim.(##) @ GHC.Prim.Int#
15:43:51 <monochrom> > length (replicate 11 undefined)
15:43:52 <lambdabot>   11
15:44:21 <RevJohnnyHealey> > bounds (array (0,10) $ zip [0..10] (replicate 11 undefined))
15:44:22 <lambdabot>   (0,10)
15:44:58 * RevJohnnyHealey wins
15:45:03 <monochrom> yeah, RevJohnnyHealey, I forgot "array" vs "listArray"
15:45:21 * monochrom hasn't used Array for a long long time!
15:45:27 <napping> while with newtype Wrap = Wrap Int, \x -> Bar x compiles to something like (\(x :: Int) -> x) `cast` (<GHC.Types.Int> -> Sym <(Test.NTCo:Wrap)>)
15:45:30 <roconnor> what I want to write is let arr = array (0,10) [(i,f i)
15:45:39 <roconnor> what I want to write is let arr = array (0,10) [(i,f i) | i <- bounds arr]
15:45:46 <roconnor> is that so unreasonable?
15:46:09 <monochrom> I don't know
15:46:19 <pentace> > let arr = array (0,10) [(i,f i) | i <- bounds arr] in arr ! 0
15:46:20 <lambdabot>   Couldn't match expected type `[i0]' with actual type `(i0, i0)'
15:46:55 <roconnor> @type f
15:46:55 <lambdabot> FromExpr a => a
15:47:06 <pentace> > let arr = array (0,10) [(i,i) | (_, i) <- bounds arr] in arr ! 0
15:47:07 <lambdabot>   Couldn't match expected type `[(t0, e0)]'
15:47:08 <lambdabot>              with actual type `(e...
15:47:21 <roconnor> pentace: er you are right I made an error
15:47:31 <roconnor> let arr = array (0,10) [(i,f i) | i <- range (bounds arr)]
15:47:45 <pentace> :t bounds
15:47:46 <lambdabot> Ix i => Array i e -> (i, i)
15:47:54 <pentace> :t range
15:47:55 <lambdabot> Ix a => (a, a) -> [a]
15:48:09 <pentace> Ah
15:49:44 <joelteon> :i Ix
15:49:49 <joelteon> oh wait, we don't have :i
15:50:01 <roconnor> @info Ix
15:50:02 <lambdabot> Ix
15:51:51 <tomboy65> uhm
15:52:10 <tomboy65> could someone tell me how i convert a Ratio to a decimal fraction?
15:52:24 <joelteon> oh man, cabal sandbox has to be the best thing ever
15:52:28 <tomboy65> for use with putStrLn
15:52:34 <joelteon> @hoogle Num a => Ratio -> (a, a)
15:52:34 <lambdabot> Did you mean: Num a => Ratio a -> (a, a)
15:52:34 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
15:52:34 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
15:52:34 <roconnor> @type realToFrac
15:52:35 <lambdabot> (Fractional b, Real a) => a -> b
15:52:43 <joelteon> yes, lambdabot, I did.
15:53:10 <tomboy65> hmm realToFrac seems good. let's see
15:53:25 <roconnor> tomboy65: tricky.  The most obvous but not robust solution is to convert to decimal.
15:53:45 <roconnor> tomboy65: the less obvious solution is to convert to Fixed E100 or whatever
15:53:52 <roconnor> I think both use realToFrac
15:53:58 <roconnor> er
15:54:05 <khyperia> what does the fat arrow mean in those types? Type of a and b?
15:54:05 <roconnor> my first solution meant to say "covnert to double"
15:54:20 <joelteon> khyperia: the fat arrow denotes a class constraint
15:54:27 <joelteon> a must be an instance of Real, and b must be an instance of Fractional
15:54:32 <khyperia> ah, I see
15:54:55 <joelteon> fun way to impress your friends: Foo a => Bar b => a -> b is the same as (Foo a, Bar b) => a -> b
15:55:08 <joelteon> that's rarely used, though
15:55:17 <monochrom> is that valid syntax?
15:55:21 <joelteon> yes, it is
15:55:39 <DanBurton> TIL curried contexts
15:55:40 <monochrom> that is evil
15:55:42 <khyperia> Too bad I don't have any friends who even know what haskell is, haha
15:55:43 <joelteon> quite
15:56:10 <tomboy65> yup, that was it roconnor . thanks.
15:56:10 <johnw> joelteon: nice
15:56:19 <DanBurton> *constraints
15:56:29 <johnw> I know that Foo a => a -> (Bar b => b) worked
15:56:30 <tomboy65> roconnor: uhm? what did you mean by those last 2 comments? O.O
15:56:32 <joelteon> aren't we going to have constraint synonyms eventually?
15:56:39 <monochrom> yikes
15:56:44 <johnw> joelteon: constraint synonyms are in 7.4
15:56:47 <joelteon> oh
15:56:48 <johnw> I use them often
15:56:50 <joelteon> heh...ok
15:56:52 <roconnor> tomboy65: if you read my first comment carefully, it makes no sense.
15:56:53 <joelteon> I didn't know that
15:56:58 <roconnor> tomboy65: and so I tried to correct it
15:57:08 <johnw> type SuperMonad m = (Functor m, Applicative m, Monad m, MonadPlus m)
15:57:18 <joelteon> SuperMonad :: * -> Constraint
15:57:22 <roconnor> tomboy65: though my correction also is not spelled well.
15:57:26 <joelteon> or is it (* -> *) -> Constraint
15:57:29 <joelteon> yeah, must be
15:57:33 <johnw> yeah
15:57:38 <joelteon> silly me
15:57:47 <DanBurton> Constraint synonyms don't work in some places though. From my experience, class (SuperMonad m) => SuperDuperMonad m where ... doesn't work
15:57:52 <johnw> constraint synonyms work in type families too
15:58:44 <johnw> you can use them to pretty easily implement restricted monads
15:58:49 <Sonarpulse> napping: thanks
15:59:03 <DanBurton> For a little while I resorted to CPP, #define AMonad(m) Monad m, Applicative m
15:59:18 <levi> Ahh, I found a text that actually talks about the *value* bottom as the least fixed point of a generating function. I think this is more in line with the Haskell sense.
15:59:47 <johnw> where I make an "App" monad these days, I typically make a MonadApp synonym, to avoid having to replicate constraints everywhere
16:00:00 <joelteon> that's a clever idea
16:00:03 <johnw> (where App is a transformer, that is)
16:00:36 <johnw> like, here's the synonym I'm using today:
16:00:44 <johnw> type MonadMerchant m = (Failure MerchantError m, MonadLogger m, MonadResource m, MonadBaseControl IO m)
16:00:54 <johnw> and the "app" monad is of course then MerchantT m a
16:01:29 <khyperia> Are there some beginner learning projects that might be good for me to try?
16:01:44 <johnw> khyperia: the best beginner project is a small app that you actually want to make use of yourself
16:01:55 <johnw> my first app was called "una", and is a universal unarchiver
16:02:33 <khyperia> Right.
16:02:35 <johnw> I still use it to this day, and never had to fix a single bug after I was done developing (this was one of the things that sold me on Haskell)
16:02:58 <johnw> considering I'd written the same thing in Python and Ruby and kept finding bugs over time
16:03:04 <joelteon> on the contrary, I'm quite good at introducing logic bugs
16:03:14 <johnw> you mean, type-correct bugs?
16:03:18 <joelteon> yes
16:03:26 <johnw> at least you've proved that your bug exists :)
16:03:34 <joelteon> but haskell does eliminate a whole category of bugs
16:03:43 <johnw> yeah, undefined values used to be the bane of my existence
16:03:49 <joelteon> that we keep running into at work, for example, where the language of choice is ruby
16:03:55 <johnw> I had taken to using boost::optional *everywhere* to eliminate them in C++, but that has its own costs
16:04:18 <lispy> johnw: boost::optional ~ Maybe?
16:04:22 <johnw> yes
16:04:27 <DanBurton> we should rename "Hask" to "FewerBugs", so that way we can talk about abstractions in the category of FewerBugs
16:04:29 <lispy> I should probably use that in my C++
16:04:31 <bennofs> instance Category Bugs where arr = fix error :P
16:04:32 <johnw> a Maybe that does a heap allocation
16:05:01 <mebaran151> hi haskell I have a quick question: I have a series of monadic actions in the state monad, each which act on the result of the last.  I would like to pass this argument implicitly, without explicitly binding and unbinding it on each itereation.  Is there a combinator that would do this for me?
16:05:03 <dmwit> My take: implementing and debugging the Python version simply made johnw more aware of where to pay attention during his Haskell rewrite.
16:05:04 <johnw> boost::optional has a few very helpful uses, so I do recommend it
16:05:14 <johnw> dmwit: correct
16:05:23 <johnw> also, I recommend using newtypes liberally
16:05:23 <lispy> Then again, due to project workload I'm taking a break from C++ projects for a while and doing some gcc hacking now
16:05:23 <bennofs> @ty (>>=)
16:05:24 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:05:26 <napping> mebaran151: like [a -> m a]?
16:05:36 <mebaran151> napping: similar
16:05:36 <johnw> rather than having a function foo :: Int -> Int -> Int, make your function foo :: Length -> WIdth -> Area
16:05:43 <mebaran151> the good news it they are all the same type of function
16:06:07 <dmwit> :t foldM
16:06:08 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:06:11 <khyperia> Is there such a thing as a 2d array, or just a [[a]]?
16:06:15 <napping> foldr (>=>) return ?
16:06:24 <johnw> :t iterateM
16:06:25 <lambdabot>     Not in scope: `iterateM'
16:06:25 <lambdabot>     Perhaps you meant one of these:
16:06:25 <lambdabot>       `iterate' (imported from Data.List),
16:06:28 <mebaran151> foldM looks like it could do it
16:06:29 <johnw> :t Control.Monad.Loops.iterateM
16:06:30 <lambdabot> Not in scope: `Control.Monad.Loops.iterateM'
16:06:32 <joelteon> Repa provides higher-dimensional arrays, doesn't it?
16:06:49 <dmwit> :t foldr (>=>)
16:06:50 <lambdabot> Monad m => (b -> m c) -> [b -> m b] -> b -> m c
16:06:58 <dmwit> :t foldr (>=>) return
16:06:58 <lambdabot> Monad m => [c -> m c] -> c -> m c
16:07:19 <johnw> :t Control.Monad.Loops.concatM
16:07:20 <lambdabot> Monad m => [a -> m a] -> a -> m a
16:07:22 <dmwit> Oh, napping beat me to it.
16:07:36 <johnw> heh, it's the same implementation
16:08:51 <dmwit> khyperia: There are several choices. Array, REPA, or you can define certain inductive types...
16:10:02 <dmwit> data Fun a as = Leaf [as] | Branch (Fun a (a,as)) -- like [[a]], but guaranteed to be rectangular
16:10:51 <dmwit> type Rectangular a = Fun a () -- whoops, forgot the last bit
16:11:19 <khyperia> Alright. Thanks!
16:13:29 <dacc> what would be a good book for after LYAHFGG?
16:13:32 <napping> flip (foldM (flip ($))) may also be illuminating
16:13:39 <johnw> haha
16:13:45 <johnw> dacc: RWH
16:14:05 <dacc> cool thanks
16:15:28 <DanBurton> If I have functions "f, g :: Foo -> Foo" such that forall x. (f (g x)) = x but not forall y. (g (f y)) = y, is it correct to say that "f is g's inverse"?
16:15:29 <joelteon> :t flip (foldM (flip ($)))
16:15:29 <lambdabot> Monad m => [a -> m a] -> a -> m a
16:15:54 <DanBurton> Or rather, f :: Foo -> Bar, g :: Bar -> Foo
16:16:17 <DanBurton> or do they have to be each other's inverses in order to say one is the inverse of the other?
16:17:08 <DanBurton> :t foldM
16:17:09 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:17:11 <johnw> f . g = id, but g . f /= id
16:17:15 <johnw> i'm sure there's a name for that
16:17:22 <WanderingMonad> dacc: I'm also a relative newbie, so take my advice with the appropriate volume of proverbial salt, but I found Write Yourself a Scheme to be quite helpful in illustrating how to construct more complex programs in Haskell.
16:17:38 <DanBurton> johnw: right? I jus have no idea what that name is >,<
16:18:16 <johnw> according to http://www.themathpage.com/aprecalc/inverse-functions.htm, that's not the inverse
16:18:46 <johnw> if we were talking about functors, that would be adjunction
16:19:08 <khyperia> what's the difference between Int and Integer? GHCi is spitting something about "several potential instances" when I try entering "mod -1 2" (to test if mod returns negative for negative input)
16:19:12 <johnw> oh, hey, here's your question: http://answers.yahoo.com/question/index?qid=20100804054840AAYEdai
16:19:30 <johnw> oh, maybe not
16:19:48 <johnw> khyperia: Integer is arbitrarily large, bounded only by system memory
16:20:10 <khyperia> Ah.
16:21:13 <johnw> DanBurton: g may be called the left inverse of f in that scenario you mentioned
16:21:21 <johnw> sorry, f is the left inverse of g
16:21:25 <johnw> according to http://en.wikipedia.org/wiki/Inverse_function
16:26:37 <WanderingMonad> Question: if I need to keep track of how many times a function operates over a value until some condition is met, would IORef be the best way to tie the number of iterations to the final value so it can be returned for output?
16:27:11 <johnw> you mean, across separate invocations of that function?
16:27:15 <c_wraith> WanderingMonad: in general, it's best to use IORef only in cases where you can't pass values around.
16:29:04 <khyperia> F# has an operator "|>" which is defined as "let (|>) x f = f x", does haskell have something similar? (it's useful for "piping" sequence queries around)
16:29:26 <joelteon> you could define one pretty easily
16:29:36 <johnw> lens has &
16:29:39 <johnw> :t (&)
16:29:40 <lambdabot> a -> (a -> b) -> b
16:29:54 <ParahSail1n> @src ($)
16:29:54 <lambdabot> f $ x = f x
16:29:54 <joelteon> but you may not want to depend on lens for (&)
16:30:19 <ParahSail1n> @ty flip ($)
16:30:20 <lambdabot> b -> (b -> c) -> c
16:30:30 <mebaran151> thanks everybody, now I just have one more thing
16:31:10 <WanderingMonad> johnw: No, I mean as in conjunction with something like until, i.e., f x = y, f y = z...until condition = True.
16:31:18 <WanderingMonad> johnw: Context is here: https://www.codeeval.com/browse/45/
16:31:26 <mebaran151> is it possible to make every line of a do statement accumulate into a list such that I can pass it to this function, I would like to allow for arbitrary let statements as well with statements accumulated into a list to be composed and folded
16:32:36 <khyperia> So how would I define that if I don't want to depend on lens? Like so? -  (&) :: a -> (a -> b) -> b [newline] x & f = f x
16:32:37 <WanderingMonad> c_wraith: I got the impression (possibly incorrect from WYAS) that IORef was good for tracking/using values that are related to an I/O function but used within it, if that makes any sense.
16:32:52 <startling> is there a traverseKeys for maps somewhere? maybe in lens?
16:33:01 <startling> :t \a -> ($ a)
16:33:01 <lambdabot> a -> (a -> b) -> b
16:33:07 <startling> ^ khyperia
16:33:14 <khyperia> ah
16:33:17 <khyperia> thanks
16:33:20 <startling> :t \a b -> b a -- this is the same thing
16:33:21 <lambdabot> t1 -> (t1 -> t) -> t
16:33:27 <c_wraith> WanderingMonad: yes, but only if you can't pass the values around instead - mutating an IORef is actually more costly than just passing values around.
16:34:32 <startling> khyperia: probably you want to define "a & f = f a" like you said, though.
16:35:17 <bennofs> @ty flip id
16:35:18 <lambdabot> b -> (b -> c) -> c
16:37:16 <WanderingMonad> c_wraith: I see. So, to clarify, would IORef work for something like this? Say we have f x = y. I'd use IORef to "silently" record that as one iteration of f. If a Bool condition relating to y is True, output the IORef value and y to a file. If False, we iterate over the previous result until the Bool is True, ticking the IORef value up by one for every iteration.
16:37:46 <S11001001> @google essence iterator pattern
16:37:48 <lambdabot> http://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
16:37:48 <lambdabot> Title: The Essence of the Iterator Pattern
16:38:20 <levi> dmwit: So, apparently SML defines a 'semantic object' FAIL in its semantics that is the result of evaluation failures due to missing pattern cases. It's not considered a 'value' though. I think this pretty much clarifies my previous misunderstanding.
16:38:33 <notasi> > let o = flip id in pi `o` sin
16:38:34 <lambdabot>   1.2246063538223773e-16
16:41:23 <S11001001> I'd expect a bigger pie of sin
16:42:18 <mebaran151> is there a ready made monad that will work like this: do { a; b; c} = [a,b,c]
16:42:27 <mebaran151> I'm trying to use / absue do notation for legibility
16:43:36 <elliott> is do { tell a; tell b; tell c } ok?
16:43:39 <elliott> well
16:43:46 <elliott> execWriter $ do { tell a; tell b; tell c }
16:43:47 <elliott> uh.
16:43:52 <startling> tell [a]
16:43:53 <elliott> make that tell [a], tell [b], tell [c], but youc an wrap that
16:44:06 <k00mi> he's gone
16:44:10 <startling> heh
16:46:54 <dmwit> johnw, DanBurton: The term you're looking for is right inverse (resp. left inverse).
16:47:45 <dmwit> https://en.wikipedia.org/wiki/Inverse_function#Left_and_right_inverses
16:48:41 <FreeFull> elliott: No, it has to be     do do do execWriter $ do { do do tell [a]; do do do tell [b]; do do do do tell [c]; }
16:50:09 <FreeFull> do do do execWriter $ do do do do do do { do do tell [do do do a]; do do do tell [do b]; do do do do tell [do do c]; }
16:50:16 <FreeFull> Funny thing is that is valid code
16:50:19 <dmwit> How is do { a; b; c } more readable than [a, b, c]?
16:50:45 <FreeFull> dmwit: No idea
16:51:11 <FreeFull> Clearly this is the most readable though:  do do do execWriter $ do do do do do do { do do tell [do do do a]; do do do tell [do b]; do do do do tell [do do c]; }
16:51:58 <Ralith> is it necessary to make the same joke three times in a row?
16:52:58 <FreeFull> do do do id id id execWriter $ do do do id id id id id $ do do do do do do { do do id id id id tell [do do do id a]; do do do id id id tell [do id id b]; do do do do id id tell [do do id id id c]; } -- Even better
16:53:10 <WanderingMonad> S11001001: Was that paper meant for me? I just finished reading it over, and...um. I just recently finished LYAH and WYAS, so I'm not particularly well-versed in the theoretical foundations of Haskell at anything more than a very, very broad level.
16:53:33 <mm_freak_> > do do Just 3
16:53:34 <lambdabot>   Just 3
16:53:41 <mm_freak_> didn't even know that works
16:53:43 <FreeFull> Pro tip: Confuse newbies by sticking useless do all over the place
16:54:07 <WanderingMonad> S11001001: If it makes any difference, here's the problem I'm working on: https://www.codeeval.com/browse/45/
16:54:20 <c_wraith> WanderingMonad: you can do that in IO - but it really does make code non-composable
16:54:31 <mm_freak_> dmwit: the question is:  how is do { a; b; c } [a, b, c]?
16:55:34 <dmwit> mm_freak_: No, that is not my question.
16:55:45 <dmwit> mm_freak_: Allow for the moment that this might be possible. Why would you want it?
16:55:49 <dmwit> That is my question.
16:56:23 <mm_freak_> dmwit: in general you wouldn't, but i found myself preferring do-notation over list comprehensions from time to time
16:56:35 <mm_freak_> especially in this pattern:  concat [ … | … ]
16:56:47 <dmwit> This is not a comprehension. And you should not use concat with a comprehension.
16:57:00 <dmwit> concat [ foo | e ] = [ v | e, v <- foo ]
16:57:26 <mm_freak_> or simply:  do e; foo
17:00:41 <WanderingMonad> c_wraith: To be honest, I hadn't given that much thought. I mean, I understand why that's a bad thing, but as a newbie, I'm just trying to get a grip on how to get a working Haskell solution to programming challenges like these. I was mostly thinking of using IORef because I had decent code I could work off of from WYAS.
17:01:59 <dmwit> WanderingMonad: Why not just use "iterate"?
17:02:01 <dmwit> :t iterate
17:02:01 <lambdabot> (a -> a) -> a -> [a]
17:03:00 <FreeFull> > iterate (+1) 0
17:03:01 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
17:03:17 <FreeFull> > iterate f x :: [Expr]
17:03:18 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
17:04:14 <WanderingMonad> dmwit, FreeFull: https://www.codeeval.com/browse/45
17:04:41 <FreeFull> WanderingMonad: That shows the problem
17:04:51 <WanderingMonad> dmwit, FreeFull: That's what I'm working on. So I need to iterate my "revAdd" function over its result.
17:05:03 <dmwit> :t until
17:05:03 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
17:05:35 <FreeFull> dmwit: If he uses until he'll have to keep track of how many iterations he's gone through
17:05:42 <dmwit> :t \f -> until (fst . p) (\(n, v) -> (n+1, f v))
17:05:43 <lambdabot>     Couldn't match expected type `(t0, t1) -> (Bool, b0)'
17:05:43 <lambdabot>                 with actual type `Expr'
17:05:43 <lambdabot>     In the second argument of `(.)', namely `p'
17:05:48 <dmwit> FreeFull: Yes. But it's not exactly hard.
17:05:59 <dmwit> :t \f p -> until (fst . p) (\(n, v) -> (n+1, f v))
17:06:04 <lambdabot> Num t => (t1 -> t1) -> ((t, t1) -> (Bool, b)) -> (t, t1) -> (t, t1)
17:06:06 <dmwit> urgh
17:06:14 <dmwit> :t \f p -> until (p . snd) (\(n, v) -> (n+1, f v))
17:06:15 <lambdabot> Num a => (b -> b) -> (b -> Bool) -> (a, b) -> (a, b)
17:07:23 <dmwit> Argument order is funny compared to until, and it doesn't start itself out at 0. But you get the idea.
17:07:27 <hpaste_> stolaruk pasted “Lazy IO question” at http://lpaste.net/92046
17:07:49 <dmwit> :t hFlush
17:07:50 <lambdabot> Not in scope: `hFlush'
17:07:59 <dmwit> ?hoogle hFlush
17:07:59 <lambdabot> System.IO hFlush :: Handle -> IO ()
17:07:59 <lambdabot> GHC.IO.Handle hFlush :: Handle -> IO ()
17:07:59 <lambdabot> GHC.IO.Handle hFlushAll :: Handle -> IO ()
17:08:00 <stolaruk> Could someone please take a look at my code? I have a question, phrased in the comments, about IO
17:08:02 <dmwit> stolaruk: ^^
17:08:09 <FreeFull> :t let addRev = undefined in not . (>100) . length . dropWhile (not . palindrome) . take 101 . iterate addRev
17:08:10 <lambdabot> Not in scope: `palindrome'
17:08:18 <stolaruk> ok cool I'll check that out
17:08:25 <FreeFull> :t let addRev = undefined; isPalindrome = undefined in not . (>100) . length . dropWhile (not . isPalindrome) . take 101 . iterate addRev
17:08:26 <lambdabot> a -> Bool
17:08:32 <stolaruk> thanks
17:08:53 <FreeFull> dmwit: How does this look?
17:09:03 <dmwit> not . (>100), eh? funny way of spelling (<=100) =P
17:09:18 <FreeFull> Wait, no, that doesn't output the right thing
17:09:36 <dmwit> It looks bad, because it doesn't iterate the count and palindrome.
17:09:44 <dmwit> s/iterate/output/
17:10:40 <dmwit> :t \p f v -> until (p . snd) (\(n, v) -> (n+1, f v)) (0, v)
17:10:41 <lambdabot> Num a => (b -> Bool) -> (b -> b) -> b -> (a, b)
17:10:45 <TimUK> hey all!
17:11:28 <Ghoul_> is there an extension to automatically make a let async?
17:11:34 <dmwit> :t let addRev = undefined; isPalindrome = undefined in until (isPalindrome . snd) (\(n, v) -> (n+1, addRev v)) . (,) 0
17:11:35 <lambdabot> Num a => b -> (a, b)
17:11:52 <FreeFull> :t let addRev = undefined; isPalindrome = undefined in head . take 1 . filter (isPalindrome `on` snd) . zipWith [0..] . iterate addRev
17:11:53 <lambdabot>     Couldn't match type `(a0, b0) -> c0' with `Bool'
17:11:53 <lambdabot>     Expected type: (a0, b0) -> Bool
17:11:53 <lambdabot>       Actual type: (a0, b0) -> (a0, b0) -> c0
17:11:54 <TimUK> quick question I know how to get an element out of a list but is there function that lets me take out a certain number of elements from a list?
17:12:11 <dmwit> TimUK: take
17:12:23 <TimUK> but isn't that just the first few
17:12:31 <FreeFull> Oh, right, wrong type for filter
17:12:36 <dmwit> Ghoul_: Perhaps RebindableSyntax.
17:12:36 <FreeFull> :t let addRev = undefined; isPalindrome = undefined in head . take 1 . filter (isPalindrome . snd) . zipWith [0..] . iterate addRev
17:12:54 * FreeFull pokes lambdabot
17:12:55 <Ghoul_> take . snd . splitAt n
17:12:56 <TimUK> somone doing project euler I see ;)
17:12:58 <dmwit> head . take 1 eh? funny way of spelling head =P
17:12:59 <lambdabot>     Couldn't match type `[b1] -> [c0]' with `[(a0, b0)]'
17:12:59 <lambdabot>     Expected type: [a1] -> [(a0, b0)]
17:12:59 <lambdabot>       Actual type: [a1] -> [b1] -> [c0]
17:13:15 <FreeFull> dmwit: Oh, yeah =P
17:13:20 <FreeFull> I'm not thinking much =P
17:13:24 <WanderingMonad> TimUK: CodeEval, actually, but close enough. :P
17:13:43 <FreeFull> :t let addRev = undefined; isPalindrome = undefined in head . take 1 . filter (isPalindrome . snd) . zip [0..] . iterate addRev
17:13:44 <lambdabot> (Enum a, Num a) => b -> (a, b)
17:14:00 <Ghoul_> > let get x n l = take n $ snd $ splitAt x l in get 3 3 [1..10]
17:14:01 <lambdabot>   [4,5,6]
17:14:01 <FreeFull> I blame how late it is
17:14:03 <TimUK> ah! i just did a palindrome on proj euler a couple of days ago thats why ;)
17:14:13 <TimUK> not heard of that will check it out actually
17:14:15 <Ghoul_> @pl (\x n l = take n $ snd $ splitAt x l)
17:14:16 <lambdabot> (line 1, column 9):
17:14:16 <lambdabot> unexpected "="
17:14:16 <lambdabot> expecting pattern or "->"
17:14:28 <Ghoul_> @pl (\x n l -> take n $ snd $ splitAt x l)
17:14:32 <lambdabot> flip ((.) . take) . (id snd .) . splitAt
17:14:32 <lambdabot> optimization suspended, use @pl-resume to continue.
17:14:54 <Ghoul_> mhm, there doesn't look to be a cool way to do it. That's probably the best you can do.
17:14:56 <mm_freak_> TimUK: there are many functions for extracting sublists
17:15:07 <Ghoul_> let get x n l = take n $ snd $ splitAt x l in get 3 3 [1..10] -- is one
17:15:12 <mm_freak_> TimUK: take, takeWhile, span, partition, permutations, subsequences, …
17:15:20 <FreeFull> (id snd .)
17:15:26 <FreeFull> Come on lambdabot, you can do better than that
17:15:28 <dmwit> Ghoul_: Why not just take n . drop x?
17:15:49 <Ghoul_> thats not the same I dont think
17:15:54 <mm_freak_> Ghoul_: it is
17:15:58 <dmwit> ?src splitAt
17:15:58 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
17:16:01 <dmwit> Think again. =)
17:16:07 <Ghoul_> haha, okay
17:16:12 <Ghoul_> yeah, thats probably better
17:16:26 <elliott> that's a bad splitAt. :(
17:16:26 <tabemann> sigh... I think I've figured out the solution to correctly implementing Scheme equal?, but now I've got an algorithm basically thought up in my head (based roughly off Brent's "teleporting turtle" algorithm, but with significant changes) which I don't know if it *really* works, so now I basically think I should create a model implementation outside my Scheme impl. rather than actually trying to implement Scheme equal? with
17:16:26 <tabemann>  it first. Any thoughts?
17:16:27 <mm_freak_> dmwit: is that how it's actually implemented?
17:16:30 <Ghoul_> /s/probably/is most definately/
17:16:32 <dmwit> mm_freak_: no
17:16:36 <dmwit> elliott: It's a specification.
17:16:49 <dmwit> mm_freak_: To be precise: no, not in GHC.
17:16:55 <tabemann> a lot of the "report" versions of functions in GHC.List and Data.List are bad
17:16:56 <mm_freak_> good enough =)
17:17:12 <tabemann> they're not really implemented that way
17:17:51 <FreeFull> tabemann: I have no idea what exactly equal? is supposed to do other than ==
17:18:05 <khyperia> How do I apply a function to itself infinitely (f (f ... (f (x)) ... )) and print out the intermediate result every iteration?
17:18:19 <tabemann> FreeFull: equal? is value equality *with* proper loop detection and resolution (i.e. you can compare arbitrarily cyclic data structures with it)
17:18:25 <TimUK> thanks for the tips peeps, night!
17:18:28 <dwcook> @type iterate
17:18:28 <lambdabot> (a -> a) -> a -> [a]
17:18:39 <applicative_tmp> > iterate (+1) 0
17:18:40 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
17:18:40 <dwcook> khyperia, ^
17:18:47 <dmwit> I find equal? scary. Seems like implementing it correctly requires understanding coinduction.
17:18:47 <khyperia> ah
17:18:54 <mm_freak_> khyperia: for debugging purposes see Debug.Trace, for production you can use 'fix' with monadic code
17:19:07 <mm_freak_> :t fix (putStrLn "blah" >>)
17:19:07 <lambdabot> IO b
17:19:23 <dwcook> Isn't that just forever?
17:19:26 <tabemann> dmwit: it took a lot of thinking on my part to even come to something that *could* be correct, and what I got to is elaborate and I damn sure wouldn't want to prove its correctness
17:19:28 <mm_freak_> dwcook: it is
17:19:30 <applicative_tmp> > fix (text "blah" <>)
17:19:31 <khyperia> all you guys are so very helpful it's wonderful
17:19:37 <lambdabot>   mueval-core: Time limit exceeded
17:19:42 <dwcook> @type forever $ putStrLn "blah"
17:19:43 <lambdabot> IO b
17:19:51 <dmwit> tabemann: ...perhaps you should read about coinduction. =)
17:19:55 <mm_freak_> :t fix . (>>)
17:19:55 <lambdabot> Monad m => m a -> m b
17:19:57 <dmwit> tabemann: There's a nice section on it in TAPL.
17:21:20 <dmwit> dwcook: Presumably the real function being fix'd would call itself with a modified argument, which forever doesn't do.
17:21:48 <dwcook> Ah, right
17:21:56 <mm_freak_> yeah, i used to use this pattern quite a lot:  fix $ \again x -> …
17:21:58 <dmwit> :t \f -> fix (\g v -> putStrLn (show v) >> g (f v))
17:21:59 <lambdabot> Show a => (a -> a) -> a -> IO b
17:22:07 <mm_freak_> then you can say something like 'again (x + 1)'
17:22:19 <dmwit> But much more clear to say
17:22:26 <mm_freak_> nowadays i prefer let
17:22:36 <dmwit> :t let debug f v = putStrLn (show v) >> debug f (f v) in debug
17:22:36 <lambdabot> Show a => (a -> a) -> a -> IO b
17:22:42 <mm_freak_> let loop x = … loop (x + 1) in loop 5
17:22:47 <dmwit> yes
17:23:08 <dmwit> I'm tempted to say fix is a code smell. :3
17:23:25 <johnw> fix can be quite handy sometimes
17:23:27 <dmwit> ...or maybe just bad style
17:23:31 <mm_freak_> it's useful from time to time when you don't actually need a name
17:23:43 <johnw> right, but overuse I agree is bad
17:25:02 * tabemann opens up the requisite chapter in TAPL and... this coinduction stuff is definitely harder for his brain to digest than Brent's algorithm
17:25:27 <c_wraith> I use fix for anonymous IO loops inside a larger do block.
17:25:35 <c_wraith> I haven't found any other use for it.
17:25:49 <dmwit> tabemann: Yes, it's significantly more general.
17:26:04 <johnw> you mean, just as an alternative to let loop x = ... ; loop ...
17:26:09 <c_wraith> johnw: yeah
17:26:10 <dmwit> Hence my comment about "scary". =P
17:26:17 <c_wraith> fix $ \loop -> do
17:26:21 <johnw> right
17:26:44 <c_wraith> I haven't found any other case where it actually makes things seem better than the alternative
17:27:09 <FreeFull> @pl \x -> x == toUpper x
17:27:09 <lambdabot> ap (==) toUpper
17:27:25 <johnw> pa?
17:27:26 <dmwit> fix $ \loop -> e is no more anonymous than let loop = e in loop
17:27:29 <johnw> why does it use ap there?
17:27:41 <c_wraith> because x appears twice
17:27:42 <johnw>  oh, .
17:27:49 <johnw> :t ap
17:27:50 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:28:02 <johnw> for the function monad that's just flip fmap which is flip (.)
17:28:12 <c_wraith> dmwit: it's only named within itself.  I guess that's not anonymous, but it's not externally named.
17:28:44 <dmwit> let loop = e in loop is not externally named.
17:28:55 <johnw> :t join ((==) . toUpper)
17:28:56 <lambdabot> Char -> Bool
17:29:00 <c_wraith> dmwit: true, but not the case I was talking about
17:29:17 <FreeFull> Should I use   ap (==) toUpper   or the lambda? I'm thinking  ap (==) toUpper   will be less clear at first glance about what it does
17:29:30 <mm_freak_> FreeFull: the lambda
17:29:35 <dmwit> FreeFull: "go with your heart"
17:29:46 <johnw> fix lets you write point-free recursion
17:29:48 <mm_freak_> FreeFull: or this:  liftA2 (==) id toUpper
17:29:52 <c_wraith> dmwit: I was talking about the case "let loop = do foo ; bar ; baz ; when quux loop in loop".  Except with a bigger body that's far less amenable to being written on a single line
17:30:04 <FreeFull> I think I'll go with the lambda
17:30:21 <liyang> FreeFull: I've taken up the habit of writing join (*) for (\ x -> x * x), and everyone I work with seem okay with that.
17:30:24 <dmwit> I don't see that single- or multi-line-ness enters into it. You wouldn't write than on a single line with fix, either.
17:30:33 <mm_freak_> johnw: "pointfree" is not really the right term here…  it's rather "nameless" aka anonymous
17:30:59 <c_wraith> dmwit: err.  You're ignoring my point.
17:31:00 <dmwit> No, I think johnw is correct.
17:31:09 <dmwit> c_wraith: Not on purpose. Help me.
17:31:16 <FreeFull> liyang: join is more common though and it's name helps
17:31:19 <mm_freak_> > fix (1:)
17:31:20 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:31:21 * tabemann tends to himself almost prefer point-ful code over point-free beyond eta reduction, partial application, and simple foo . bar $ baz type stuff
17:31:23 <mm_freak_> no point in the first place
17:31:34 <dmwit> mm_freak_: Yes: "join lets you write point-free recursion".
17:31:44 <dmwit> mm_freak_: If you were to translate that to let, it would no longer be point-free.
17:31:46 <FreeFull> mm_freak_: does that do sharing though?
17:31:48 <jfischoff> can one use GHC.Generics with GADTs?
17:31:58 <mm_freak_> <johnw> fix lets you write point-free recursion
17:32:12 <mm_freak_> FreeFull: there was no sharing going on to begin with
17:32:20 <dmwit> mm_freak_: Correct. I agree with johnw; the significant difference between fix and let is that let allows point-free-ness and let doesn't.
17:32:26 <FreeFull> let x = 1:x    there is sharing here
17:32:27 <dmwit> err
17:32:34 <dmwit> ...is that *fix* allows point-free-ness and let doesn't.
17:32:43 <mm_freak_> FreeFull: ah, yes
17:32:48 <c_wraith> dmwit: When you have a big multiline do block that you want to be conditionally recursive, writing it with fix allows you to have it locally named without syntactic contortions
17:32:52 <mm_freak_> FreeFull: fix is implemented using a let
17:32:54 <dmwit> FreeFull: Yes, fix has the appropriate sharing.
17:33:04 <dwcook> > let repeat = fix . (:) in repeat 'hey'
17:33:04 <lambdabot>   Syntax error on 'hey'
17:33:05 <lambdabot>  Perhaps you intended to use -XTemplateHaskell
17:33:07 <dwcook> > let repeat = fix . (:) in repeat "hey"
17:33:08 <lambdabot>   ["hey","hey","hey","hey","hey","hey","hey","hey","hey","hey","hey","hey","h...
17:33:37 <mm_freak_> dmwit: i seem to recall that "point" is just a fancy name for a function argument
17:33:40 <monochrom> my article is the one calling "let x = f x in x" anonymous. blame me.
17:34:07 * tabemann always understood "point" to mean "name-binding"
17:34:16 <mm_freak_> dmwit: but in this case it's not the argument that disappears, but the function's name
17:34:54 <FreeFull> mm_freak_: But the function name does appear on the right hand side
17:34:59 <dmwit> mm_freak_: Come to think of it, I've never seen the definition of point. I, like tabemann, always thought it meant a bound name.
17:35:15 <mm_freak_> i think the distinction is useful
17:35:34 <dmwit> c_wraith: I guess I don't see any contortions in the snippet you posted; so here must be the place we disagree. =)
17:35:36 <mm_freak_> pointfree:  xs = liftA2 (:) id (xs . succ)
17:35:50 <mm_freak_> anonymous, but still with point:  fix (\r x -> x : r (succ x))
17:36:28 <johnw> I thought a point was a discrete value within a function space, i.e., a value in the domain of a function, a distinguished member of a set (where the function I guess would be the intensional predicate). In the case of fix, one of its points is the function it's making recursive
17:36:38 <FreeFull> :t let xs = liftA2 (:) id (xs . succ) in xs
17:36:39 <lambdabot> Enum a => a -> [a]
17:36:55 <FreeFull> > let xs = liftA2 (:) id (xs . succ) in xs 3
17:36:56 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
17:37:00 <mm_freak_> johnw: but that's another level, the following is both anonymous and pointfree:  fix (1:)
17:37:11 <mm_freak_> not anonymous:  let x = 1 : x
17:37:14 <khyperia> I have a [String], and I want to print them out on separate lines. How do I do that?
17:37:21 <johnw> hmm
17:37:21 <mm_freak_> not pointfree:  fix (\r -> 1 : r)
17:37:31 <johnw> i see your point
17:37:32 <johnw> ;)
17:37:33 <dmwit> khyperia: mapM_ putStrLn
17:37:38 <khyperia> thanks again!
17:38:13 <FreeFull> khyperia: You could also use unlines and then putStr
17:39:01 <liyang> Asking for a friend: http://stackoverflow.com/questions/18369827/why-are-type-instances-a-a-and-a-a-a-conflicting-in-ghc-7-8
17:39:04 <FreeFull> mm_freak_: Fix really is cheating though
17:39:22 <mm_freak_> this article seems to confirm it:  http://en.wikipedia.org/wiki/Tacit_programming
17:39:29 <FreeFull> But there is no other way to do pointfree recursion
17:39:32 <mm_freak_> "Outside of the APL and J communities, tacit programming is referred to as point-free style,[1] or more pithily as pointless programming, because of the lack of explicit arguments, or points."
17:40:01 <FreeFull> liyang: I don't see how the two could unify
17:40:32 <c_wraith> liyang: I strongly suspect the issue is how flexible instances are handled...
17:40:45 <liyang> FreeFull: so it should be fine then. If they can unify, that'd be a problem.
17:40:47 <c_wraith> liyang: if it converts the first instance to (a ~ b) => a -> b
17:40:48 <FreeFull> pointfree is easier in a stack-based language
17:41:08 <c_wraith> liyang: then it would convert the first instance to (a ~ b, b ~ c) => a -> b -> c
17:41:09 <FreeFull> Since then you don't have to worry about function composition
17:41:16 <mm_freak_> haskellwiki also confirms my definition of "pointfree"
17:41:21 <c_wraith> liyang: and those *would* overlap, since the contexts aren't considered
17:41:23 <mm_freak_> http://www.haskell.org/haskellwiki/Pointfree
17:41:32 <c_wraith> err, it'd convert the *second* instance.
17:41:45 <monochrom> perhaps from "f x = ..." to "(\x -> ...)" and from "z = 0:z" to "let z=0:z in z" are both expressionify, not anonymize
17:42:14 <monochrom> expressionify or inlineify
17:42:16 <mm_freak_> monochrom: perhaps rather "termify"
17:42:22 <liyang> c_wraith: that's what I suspected. But the problem is that it worked in 7.6 (unintentionally?) and we can't compile it for 7.8 anymore.
17:42:46 <Gaelan> Is there a function in Data.List (or somewhere else, I guess) that will remove the first occurrence of an element?
17:42:48 <Ghoul_> if I use REPA do I also get SIMD?
17:42:50 <c_wraith> liyang: I don't know enough about changes to GHC 7.8...  That's just the only way I can see it deciding those overlap.
17:42:58 <mm_freak_> Gaelan: how do you find that element?
17:42:58 <johnw> hadn't seen this article before: http://buffered.io/posts/point-free-style-what-is-it-good-for/
17:43:14 <Gaelan> mm_freak_: ==
17:43:19 <mm_freak_> :t delete
17:43:20 <lambdabot> Eq a => a -> [a] -> [a]
17:43:35 <mm_freak_> > delete 5 [3,4,5,5,5,6]
17:43:37 <lambdabot>   [3,4,5,5,6]
17:44:03 <c_wraith> liyang: oh, I just realized these are type families - they've been changed quite a lot in 7.8.  It may or may not be a GHC bug it no longer works.
17:44:13 <c_wraith> liyang: that seems like a good question for #ghc
17:44:18 <Gaelan> mm_freak_: Thanks!
17:44:35 <mm_freak_> :t deleteBy
17:45:01 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
17:45:01 <liyang> c_wraith: I know a lot has changed in 7.8. I'll ask in #ghc, thanks.
17:45:39 <notasi> > deleteBy (<) 0 [(-10)..5]
17:45:40 <lambdabot>   [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,2,3,4,5]
17:45:56 <mm_freak_> deleteBy seems weird
17:46:09 <mm_freak_> it should be:  (a -> Bool) -> [a] -> [a]
17:46:22 <nh2> http://stackoverflow.com/questions/18369827/why-are-type-instances-a-a-and-a-a-a-conflicting-in-ghc-7-8
17:46:45 <Rarrikins> @src deleteBy
17:46:45 <lambdabot> deleteBy eq x []        = []
17:46:45 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
17:47:28 <nh2> uh n² functions - we don't likes them, precious
17:47:51 <johnw> the functionses, they burn us!
17:47:59 <FreeFull> mm_freak_: deleteBy (==) should be delete
17:48:16 * tabemann was about to say that
17:48:24 <johnw> @check \xs -> delete xs == deleteBy (==) xs
17:48:25 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary.Arbitrary a0)
17:48:25 <lambdabot>    arising from a ...
17:48:33 <mm_freak_> FreeFull: sure, but it's unnecessarily complicated when your condition doesn't resemble equality
17:48:34 <johnw> @check \xs -> delete xs == deleteBy (==) (xs :: [Int])
17:48:34 <lambdabot>   No instance for (GHC.Classes.Eq
17:48:35 <lambdabot>                     ([[GHC.Types.Int]] -> [...
17:48:44 <mm_freak_> FreeFull: with my type it would be:  delete x = deleteBy (== x)
17:49:00 <FreeFull> @check \x xs -> delete x xs == deleteBy (==) x xs
17:49:01 <mm_freak_> but you could also say deleteBy (> 0) or deleteBy odd
17:49:03 <lambdabot>   +++ OK, passed 100 tests.
17:49:15 <notasi> > filter odd [1..10]
17:49:16 <lambdabot>   [1,3,5,7,9]
17:49:19 <johnw> oh yeah, duh
17:49:35 <tabemann> clearly deleteBy isn't meant to be used with functions other than those which could be reasonably considered as tests of equality
17:49:38 <mm_freak_> delete the first odd number
17:49:39 <FreeFull> notasi: delete(By) only deletes the first thing that matches
17:49:59 <tabemann> if you want to delete more, you probably want filter
17:50:24 <nh2> unions, intersects, nubs, they makes us feel bad. They come from Eq land, where performance dies!
17:50:32 <mm_freak_> with the current deleteby you need to write something stupid like this:  deleteBy (const odd) ()
17:50:46 <notasi> > deleteBy (const odd) () [2,3,4,5,6]
17:50:48 <lambdabot>   No instance for (GHC.Num.Num ()) arising from the literal `2'
17:50:48 <lambdabot>  Possible fix...
17:51:08 <dwcook> > deleteBy (const odd) undefined [2..6]
17:51:09 <lambdabot>   [2,4,5,6]
17:51:17 <mm_freak_> indeed, it's even worse
17:51:21 <mm_freak_> deleteBy is retarded
17:51:35 <notasi> > deleteBy (const even) 0 [1,2,3]
17:51:36 <lambdabot>   [1,3]
17:51:45 <mm_freak_> in fact many of the list *By functions are
17:51:55 <tabemann> you probably only want deleteBy if you know specifically what you are deleting and you know it only occurs once in a list, whereby then you can gain better performance than if you used filter
17:52:31 <FreeFull> tabemann: Or if you only want to delete one occurence and leave the rest alone
17:52:33 <Rarrikins> Or if you actually need to delete the first occurrence for some reason.
17:52:42 <mm_freak_> IIRC there was a library providing saner *By functions
17:52:44 <notasi> > let deleteBy1 p xs = deleteBy (const p) error xs in deleteBy1 (\x -> odd (x*x)) [1..10]
17:52:45 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
17:52:46 <lambdabot>    arising from a use ...
17:53:15 <Rarrikins> You can delete an arbitrary number with iterate and (!!).
17:53:24 <Rarrikins> Which might be nice.
17:53:31 <FreeFull> notasi: error takes an argument
17:53:42 <notasi> > let deleteBy1 p xs = deleteBy (const p) (error "foo") xs in deleteBy1 (\x -> odd (x*x)) [1..10]
17:53:43 <lambdabot>   [2,3,4,5,6,7,8,9,10]
17:53:50 <dwcook> > iterate []
17:53:51 <lambdabot>   Couldn't match expected type `a0 -> a0' with actual type `[a1]'
17:53:55 <Rarrikins> Though you can probably do it more efficiently than restarting at the beginning each time.
17:54:05 <dwcook> Er, woops
17:54:11 <dwcook> Forgot which one iterate was
17:54:23 <notasi> > take 5 $ iterate (\x -> x*x) 2
17:54:24 <lambdabot>   [2,4,16,256,65536]
17:54:36 <mm_freak_> > iterate (^2) 2
17:54:37 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
17:54:49 <mm_freak_> don't be so humble, we're lazy!
17:54:50 <Rarrikins> > (!! 3) . iterate (deleteBy (<) 0) $ [-10..10]
17:54:51 <lambdabot>   [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,4,5,6,7,8,9,10]
17:55:02 <Rarrikins> Deletes the first three numbers where 0 is less than them.
17:55:15 <hpaste_> MedDev pasted “haddock -- create summary for subheading?” at http://lpaste.net/92051
17:55:24 <dwcook> What's the one called that loops a list onto itself?
17:55:33 <notasi> cycle?
17:55:36 <mm_freak_> dwcook: cycle?  mfix?
17:55:39 <dwcook> Ah, cycle
17:55:45 <notasi> cycle [1,2,3]
17:55:47 <FreeFull> > cycle "Meow! "
17:55:47 <notasi> > cycle [1,2,3]
17:55:48 <mm_freak_> depending on what you mean by "loop" =)
17:55:48 <lambdabot>   can't find file: L.hs
17:55:49 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
17:55:52 <Rarrikins> > cycle [5] == repeat 5
17:55:53 <FreeFull> > cycle "Meow! "
17:55:54 <lambdabot>   "Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Me...
17:55:56 <MedDev> I'm trying to create a summary for a subheading in haddock, but can't seem to get it to format correctly.  Could someone check out my paste quick?
17:56:12 <khyperia> what's a good way to generate a random 2d array of Bool?
17:56:12 <tabemann> map (\x -> floor $ (log . fromIntegral $ x) / log 2) $ iterate (^2) 2
17:56:26 <FreeFull> Rarrikins: == on infinite lists won't terminate
17:56:29 <tabemann> > map (\x -> floor $ (log . fromIntegral $ x) / log 2) $ iterate (^2) 2
17:56:30 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,179769313486231590772930519078902473361797697...
17:56:36 <dwcook> I'm sort of curious why cycle [] isn't []
17:56:36 <FreeFull> Rarrikins: At least not if the two match
17:56:40 <Rarrikins> FreeFull: I know ;)
17:56:51 <notasi> > iterate (\x -> x+x) 2
17:56:52 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
17:57:05 <mm_freak_> MedDev: is this in the module declaration's export list?
17:57:08 <FreeFull> > iterate (*2) 2
17:57:09 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
17:57:15 <Rarrikins> > iterate (\xs -> repeat xs) []
17:57:16 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
17:57:32 <MedDev> mm_freak_, no it's right above a big group of functions that are related
17:57:37 <Rarrikins> You and your not accepting infinite types!
17:57:44 <FreeFull> Rarrikins: You could use a tree
17:57:48 <tabemann> > map (\x -> floor $ (log . fromIntegral $ x) / log 2) $ iterate (*2) 2
17:57:49 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:57:52 <Rarrikins> FreeFull: Not a bad idea.
17:58:04 <Rarrikins> I wonder if lambdabot can handle data declarations.
17:58:05 <mm_freak_> MedDev: that's how i do it and it works:  http://hub.darcs.net/ertes/netwire/browse/Control/Wire/Semantics.hs
17:58:06 <MedDev> mm_freak_, ah i guess i was reading the docs wrong it's only for the module exports?
17:58:10 <Rarrikins> > data A = A
17:58:10 <lambdabot>   <hint>:1:1: parse error on input `data'
17:58:18 <FreeFull> @let import Data.Tree
17:58:19 <lambdabot>  Defined.
17:58:20 <Rarrikins> Blah.
17:58:24 <Rarrikins> Oh, that's nice :)
17:58:26 <mm_freak_> MedDev: yeah, i don't think it works outside of the export list at all
17:58:33 <Rarrikins> @let data A = A
17:58:34 <lambdabot>  Defined.
17:58:38 <Rarrikins> > A
17:58:39 <lambdabot>   No instance for (GHC.Show.Show L.A)
17:58:39 <lambdabot>    arising from a use of `M1784318769.s...
17:58:43 <MedDev> :(
17:58:55 <FreeFull> @let instance Show A where show A = A
17:58:55 <lambdabot>  .L.hs:144:18:
17:58:55 <lambdabot>      Couldn't match type `A' with `[Char]'
17:58:55 <lambdabot>      Expected type:...
17:58:57 <notasi> @let data A = A deriving Show
17:58:58 <lambdabot>  .L.hs:143:6:
17:58:58 <lambdabot>      Multiple declarations of `A'
17:58:58 <lambdabot>      Declared at: .L.hs:141:6...
17:58:58 <FreeFull> @let instance Show A where show A = "A"
17:58:59 <lambdabot>  Defined.
17:59:06 <Rarrikins> > A
17:59:06 <mm_freak_> MedDev: i still have the actual documentation outside of the export list using an anchor:  $events
17:59:09 <lambdabot>   A
17:59:11 <Rarrikins> Neat!
18:00:29 <mm_freak_> MedDev: notice that lines 34-36 are ignored by haddock, then comes the $events section (37-40), which is rendered right below the heading…  finally 43-45 are the documentation for the newtype that follow it
18:00:45 <mm_freak_> i think it's a nice and readable style, both for haddock docs and reading the source code
18:01:01 <MedDev> mm_freak_, i see that it's just all of my functions are exported so if i didn't have to type everything twice that'd be nice
18:02:01 <mm_freak_> MedDev: you should type everything twice…  that allows you to sort your types and functions in the source file like you want (i sort: first classes, then types, then values, each sorted alphabetically)
18:02:17 <mm_freak_> then in the export list you define the ordering and sectioning in the documentation, which may not be source code order
18:02:33 <mm_freak_> the alphabetical sorting makes it easier to find things in your source file
18:02:44 <MedDev> ah i see
18:03:02 <MedDev> a method to the madness!
18:03:04 <MedDev> :)
18:03:16 <mm_freak_> =)
18:07:35 * tabemann can't figure out what to call his state data structure for his algorithm other than "State", but he doesn't want to use the same name as the State monad even though he's not actually using the State monad
18:07:39 * DanBurton 's head is reeling from thoughts of MHask, and the difference between indexed (co)monads versus "regular" (co)monads in that category
18:07:41 <tabemann> oh whatever I'll just use "State"
18:08:19 <ion> tabemann: What does the program do?
18:09:10 <tabemann> ion: I mentioned it before, but I'll do so again.. I'm writing a test program which tests the equality of two arbitrary data structures that may be cyclical correctly, before I implement the same thing in my Scheme for equal?
18:09:34 <ion> tabemann: EqualityState
18:09:38 <tabemann> the algorithm is based off of Brent's algorithm, except it's far more elaborate
18:09:42 <ion> or State Equality
18:10:08 <tabemann> EqualityState would work
18:12:21 <tabemann> I was thinking of actually using the State monad, but I really can't, because it would actually make certain things, particularly provisionally descending the stack and then going back to a higher position, a bit more complex
18:12:36 <Clint> can someone help me de-stupidify fakeRunRouteT r = ((CrdT . liftRouteT) .) . (\f u -> (unRouteT . unCrdT $ (r u)) f)
18:12:39 <tabemann> or StateT actually, because my nodes are IOArrays
18:13:08 <ion> clint: Try @unpl
18:13:08 <tabemann> @unpl \r -> ((CrdT . liftRouteT) .) . (\f u -> (unRouteT . unCrdT $ (r u)) f)
18:13:08 <lambdabot> \ r d p -> (CrdT) (liftRouteT (unRouteT (unCrdT (r p)) d))
18:13:31 <ion> Also, whoever wrote that is evil.
18:13:42 <tabemann> that's why point-free is also known as pointless
18:15:32 <Clint> hmm
18:15:54 <khyperia> How the heck do you do integer division? I'm trying to do ((intOne + intTwo) / 2 > intThree), and I have no idea what it's complaining to me about.
18:15:59 <tabemann> `div`
18:16:31 <khyperia> Ah.
18:17:04 <ion> khyperia: “No instance for (Fractional Integer) arising from the use of `/'” means there’s no implementation of fractional division for Integer.
18:17:13 <ion> khyperia: See :i (/) and :i Fractional in ghci.
18:17:14 <khyperia> ahhhh, alright.
18:17:23 <ion> and :i Integer
18:17:49 <ion> The latter lists the classes Integer does implement.
18:18:33 <FreeFull> tabemann: I wonder if using a zipper for your stack could work
18:18:41 * tabemann honestly had to get used to integer division being differentiated from fractional division, not being used to it in any other languages he's worked with (aside from OCaml's / versus /., but all numeric operators are like that in OCaml)
18:19:40 <tabemann> FreeFull: I was planning on just holding onto the top of the stack when provisionally descending it, so that I could just jump right back to it
18:19:40 <Cale> It's quite a good thing that it is imo
18:19:50 <Cale> They're completely different operations conceptually.
18:19:53 <ion> There are two kinds of integer division.
18:20:01 <tabemann> because there's actually more than just one stack that I would be popping and then jumping back up to
18:20:23 <Cale> ion: That too!
18:20:48 <tabemann> Cale: it sometimes bothers me when languages make integer division generate floats, like Python 3, because much of the time when I do division I *want* floor (x / y)
18:20:56 <FreeFull> ion: Depending on how you round?
18:21:02 <tabemann> and flooring a float is less efficient than plain integer division
18:21:16 <tabemann> usually integer division floors, though
18:21:35 <johnw> i like Haskell's distinction of / and div, it makes me think whenever I use / naively
18:22:05 <FreeFull> div goes with mod which isn't there for fractionals
18:22:49 <Cale> What's worse is that many languages only give you rem and quot
18:23:05 <dmwit> Given the discussion at the moment, y'all might like this little module that I cooked up for one of my projects.
18:23:07 <hpaste_> dmwit pasted “Rounding.hs” at http://lpaste.net/92053
18:23:08 <Cale> I have had to implement mod by hand quite often
18:23:31 <Cale> (Well, by quite often, I mean "a couple of times" :)
18:23:40 <ion> freefull: One makes −a / b = −(a / b), the other always rounds down.
18:24:21 <johnw> dmwit: that's very helpful
18:24:27 <johnw> dmwit: do you mind if I add that to data-extra?
18:24:42 <FreeFull> ion: I think div always rounds to negative infinity
18:24:43 <dmwit> I don't mind. Do you need some kind of official statement from me about copyright or something?
18:24:47 <ion> freefull: With the former, the modulo sequence is also a mirror image around 0, with the latter the modulo sequence is unchanged by going over 0.
18:24:52 <FreeFull> > 3 `div` 4
18:24:53 <lambdabot>   0
18:24:57 <FreeFull> > (-3) `div` 4
18:24:58 <lambdabot>   -1
18:25:20 <ion> > map (`divMod` 4) [-5..5]
18:25:21 <FreeFull> > 1 `div` 4
18:25:21 <lambdabot>   [(-2,3),(-1,0),(-1,1),(-1,2),(-1,3),(0,0),(0,1),(0,2),(0,3),(1,0),(1,1)]
18:25:22 <lambdabot>   can't find file: L.hs
18:25:25 <ion> > map (`quotRem` 4) [-5..5]
18:25:26 <lambdabot>   [(-1,-1),(-1,0),(0,-3),(0,-2),(0,-1),(0,0),(0,1),(0,2),(0,3),(1,0),(1,1)]
18:25:27 <FreeFull> > (-1) `div` 4
18:25:29 <lambdabot>   -1
18:25:47 <MedDev> mm_freak_, wayyy better.  sure i had to type a bit, but yeah that system makes much more sense
18:25:54 <johnw> dmwit: maybe, can you comment here: https://github.com/chrisdone/data-extra/issues/1
18:26:49 <jmcarthur> Cale: i think even sadder is that neither quotRem nor divMod are euclidean division
18:28:15 <jmcarthur> https://biblio.ugent.be/input/download?func=downloadFile&fileOId=452146
18:32:35 <johnw> dmwit: thanks!
18:40:09 <tabemann> the last thing I saw was <johnw> i like Haskell's distinction of / and div, it makes me think whenever I use / naively
18:40:40 <dagano> :t mzero
18:40:40 <lambdabot> MonadPlus m => m a
18:46:33 <mapreduce> Does Haskell have any way of converting a Rational to a decimal string, ideally allowing one to specify how many digits are required?
18:47:11 <mapreduce> e.g., theFunc (2 % 3) 4 would give "0.6667"  (not too bothered about rounding)
18:47:43 <roconnor> mapreduce: I was think using realToFrac to convert to Fixed E100, but that only works for statically known lengths
18:48:29 <JordiGH> Is there some kind of fold particularly well suited for run length encoding? Say, taking a list of zeros and ones and convert it to a list that just says how big each streak of zeros and ones is?
18:48:30 <roconnor> mapreduce: looks like showFFloat should work.
18:48:57 <dmwit> :t showCReal
18:48:58 <lambdabot> Int -> CReal -> String
18:49:08 <roconnor> > showFFloat (Just 55) (1/(10^-50)::Rational)
18:49:09 <lambdabot>   Not in scope: `^-'
18:49:09 <lambdabot>  Perhaps you meant one of these:
18:49:09 <lambdabot>    `-' (imported from P...
18:49:17 <roconnor> > showFFloat (Just 55) (1/(10^(-50))::Rational)
18:49:18 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Real.Rational)
18:49:18 <lambdabot>    arising from a u...
18:49:29 <roconnor> booo
18:49:31 <dmwit> I don't think Rationals are RealFloat.
18:49:51 <mapreduce> roconnor: I need to start from a RealFloat for that, which isn't precise enough afaict.
18:50:07 <dmwit> > let r2f :: Rational -> CReal; r2f = realToFloat in showCReal 4 (2/3)
18:50:08 <lambdabot>   Not in scope: `realToFloat'
18:50:08 <lambdabot>  Perhaps you meant one of these:
18:50:08 <lambdabot>    `realToFrac...
18:50:16 <dmwit> > let r2f :: Rational -> CReal; r2f = realToFrac in showCReal 4 (2/3)
18:50:17 <lambdabot>   "0.6667"
18:50:20 <dmwit> but also:
18:50:24 <dmwit> > showCReal 4 (2/3)
18:50:25 <lambdabot>   "0.6667"
18:50:36 <dmwit> > showCReal 104 (2/3)
18:50:37 <lambdabot>   "0.666666666666666666666666666666666666666666666666666666666666666666666666...
18:51:22 <dmwit> oops
18:51:30 <dmwit> > let r2f :: Rational -> CReal; r2f = realToFrac in showCReal 4 (r2f (2/3))
18:51:31 <lambdabot>   "0.6667"
18:51:49 <dmwit> Without that r2f it's not demonstrating a function that works on Rationals at all! =P
18:52:11 <mapreduce> That looks good!
18:52:29 <dmwit> JordiGH: Have you seen the standard hack for that?
18:52:41 <JordiGH> dmwit: No, what is it?
18:52:44 <dmwit> :t map (length &&& head) . group
18:52:44 <lambdabot> Eq a => [a] -> [(Int, a)]
18:52:58 <JordiGH> What's &&& ?
18:53:07 <dmwit> (f &&& g) x = (f x, g x)
18:53:11 <dmwit> ...practically speaking.
18:53:14 <JordiGH> I see...
18:53:20 <dmwit> It's slightly more general, but I've never seen it used for anything else. =P
18:53:38 <b2coutts> :t (&&&)
18:53:39 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
18:53:41 <b2coutts> ah
18:53:53 <b2coutts> still, that's actually really useful
18:54:12 <b2coutts> I wish I'd known this earlier; I've done a bunch of awkward let (a,b) = ... things that would have been much nicer with that
18:54:20 <JordiGH> Aha, so the group function just groups streaks together?
18:55:49 <S11001001> WanderingMonad: insofar as you wish an effect [such as incrementing a counter] to occur alongside some other process, which produces the primary results with the effect [increment] on the side, yes, it's meant for you.
18:56:29 <dmwit> JordiGH: correct
18:56:44 <mapreduce> :t showCReal
18:56:45 <lambdabot> Int -> CReal -> String
18:56:46 <dmwit> b2coutts: Arrow specialized to (->) is great for munging tuples.
18:56:52 <dmwit> :t (***)
18:56:53 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
18:56:53 <dmwit> :t first
18:56:54 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
18:56:55 <dmwit> :t second
18:56:56 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
18:56:58 <dmwit> All very useful.
18:57:03 <mapreduce> I did import Data.Number.CReal in ghci but don't have that function.
18:57:07 <dmwit> There's analogues for Either, too.
18:57:09 <arkeet> :t (***) `asAppliedTo` (undefined :: b -> c)
18:57:10 <lambdabot> (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
18:57:19 <arkeet> :t first `asAppliedTo` (undefined :: b -> c)
18:57:20 <lambdabot> (b -> c) -> (b, d) -> (c, d)
18:57:45 <dmwit> mapreduce: Maybe you misspelled it...?
18:57:47 <arkeet> lens is also pretty good for tuples.
18:57:48 <b2coutts> when I have more spare time I'll learn more than the very basics of haskell
18:57:55 <b2coutts> and learn all these cool arrow, lens, etc things
18:57:59 <dmwit> showCReal goes all the way back to numbers-2007.4.29 which is the first version available on Hackage.
18:58:00 <arkeet> mapreduce: capital C and capital R.
18:58:55 <mapreduce> No, my spelling seems to be ok.
18:59:45 <geekosaur> hm, do you hvae that module installed? certain versions of ghci are buggy and will *silently* fail if a module can't be loaded
19:00:03 <geekosaur> try using ":m + Data.Number.CReal" instead
19:00:07 <mapreduce> Good question.  I did notice that the prompt still says Prelude.
19:00:14 <mapreduce> "Prelude>"
19:00:45 <geekosaur> (:m works or fails reliably, it's early versions of the `import` version that silently lost)
19:01:16 <JordiGH> dmwit: If I hadn't known about &&&, I would have done something like
19:01:17 <JordiGH> :t map (\x -> (length x, head y)). group
19:01:17 <lambdabot>     Couldn't match expected type `[t0]' with actual type `Expr'
19:01:18 <lambdabot>     In the first argument of `head', namely `y'
19:01:18 <lambdabot>     In the expression: head y
19:01:32 <JordiGH> er
19:01:35 <JordiGH> :t map (\x -> (length x, head x)). group
19:01:36 <dmwit> head x, not head y
19:01:36 <lambdabot> Eq t => [t] -> [(Int, t)]
19:01:38 <dmwit> yes
19:02:12 <dmwit> geekosaur: whoa, didn't know about that one
19:02:13 <dmwit> nasty bug
19:02:28 <mapreduce> I can't see any packages with CReal or creal in the name in hackage.
19:02:43 <mapreduce> meant to actually verify that on the website before hitting enter..
19:03:00 <byorgey> mapreduce: I believe it's from the 'numbers' package
19:03:04 <mapreduce> numbers, right.
19:03:29 <tabemann> geekosaur: what's "early"? I'm on 7.4.1 and I sometimes get odd behavior with "import"
19:03:43 <geekosaur> I think that's the bad one
19:03:46 <tabemann> i.e. I'll use "import" and then it behaves as if I didn't do anything
19:03:51 <dmwit> Oh, I think byorgey has some code to emit digit strings from Rationals directly, too, without going via CReal.
19:03:51 <geekosaur> yes
19:04:07 <geekosaur> 7.4.1 fairly certain has the bug; possibly other 7.4s
19:04:13 <mapreduce> That works a treat now.
19:04:19 <mapreduce> dmwit: That could be interesting.
19:04:28 <geekosaur> 7.6 should work properly (at least for `import`...)
19:04:46 <mapreduce> geekosaur: Right, I'm on 7.4.1.
19:04:49 <tabemann> when will Debian get its act together and get 7.6.3 to testing rather than, in its conservativeness, only letting you use it if you have your whole system use unstable....
19:04:51 <tabemann> sigh
19:05:19 <byorgey> I do. Though if all you want to do is emit a certain number of digits it's not that hard.  Just keep multiplying by 10 and then doing divmod by the denominator.
19:05:31 <dwcook> tabemann, isn't that dependent on the package maintainer(s) for the Haskell stuff?
19:05:38 <Zenol> Is someone good at finding a nice operator spelling from how it is used?
19:05:46 <tabemann> dwcook: tis true, I know
19:05:53 <byorgey> in fact my code also figures out the repeating portion of the decimal expansion
19:06:01 <mapreduce> byorgey: That one line explains it far better than various articles I've read. :)
19:06:08 <Zenol> I have stuff like "link" <> ["href" |= url, "title" |= title] |. content, but I don't think |= ad |. are nice names :/
19:06:09 <byorgey> mapreduce: =)
19:06:23 <geekosaur> (note, it's only ghci that's affected. program imports work fine, just `import` at the ghci prompt is buggy)
19:08:11 <JordiGH> Where is &&& ?
19:08:26 <JordiGH> In Arrow?
19:08:29 <geekosaur> Control.Arrow
19:08:51 <Clint> @hoogle (&&&)
19:08:51 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
19:10:12 <flebron> Is there a programming language where values have units, such that I could do 1 meter / 5 seconds = (1 / 5) (meters / second), and multiply that by some time and get the distance travelled in meters?
19:10:50 <mee> flebron: you can implement that in many languages (also, measurement error and other fun stuff)
19:10:52 <geekosaur> there was apparently one on PLATO, but most general purpose languages dont have units baked in
19:11:00 <elliott> take a look at Frink.
19:11:02 <flebron> (I was teaching kids the important of typing your stuff even if Haskell can do it for you, and gave them the example of the space launch where the error was in not converting from feet to meters.)
19:11:04 <elliott> there's also a haskell package for it
19:11:08 <geekosaur> there are libraries for many languages, including Haskell (try the dimensional package)
19:11:29 <geekosaur> (although there may be newer ones now)
19:11:39 <S11001001> WanderingMonad: but yes, it looks like you've gotten more useful & specific help already.
19:12:29 <JordiGH> flebron: You know that's called dimensional analysis, right? It's a free abelian group.
19:13:51 <flebron> I can see how it's a free abelian group, sure.
19:14:54 <applicative> F# is supposed to have swank syntactic support for this flebron
19:15:00 <applicative> did you see https://github.com/adamgundry/inch/blob/master/examples/Units.hs
19:15:12 <byorgey> geekosaur: the 'units' package is quite nice, but currently only works with GHC HEAD =)
19:15:36 <byorgey> because it relies on the new closed type family stuff
19:15:36 <dwcook> I've been using newtypes to statically confirm my units are correct. Is that how that's usually done?
19:15:57 <byorgey> dwcook: yes.
19:18:18 <mapreduce> flebron: It's interesting that international flights still use feet instead of metres.
19:21:05 <JordiGH> Imperial units are deeply entrenched in aviation. I've never known a pilot who doesn't use them.
19:21:27 <JordiGH> Of course, I only know American pilots (e.g. Canadians, USians, and Mexicans)
19:26:41 <mapreduce> I also know only American pilots, Argentines.
19:50:58 * tabemann cringes at "USian"
19:51:41 <pentace> nh2: Re conflicting type instances: I just wanted to add that your sample compiles fine on an old GHC 6.12, so either it's a very old bug or the correct behaviour
19:53:10 <monochrom> @free joy::a->[a]
19:53:11 <lambdabot> $map f . joy = joy . f
19:53:27 <monochrom> @free joy::a->b->[(a,b)]
19:53:27 <lambdabot> $map ($map_Pair f g) . joy x = joy (f x) . g
19:53:31 <scshunt> tabemann: I'm from (North) America, but not the USA!
19:53:51 <monochrom> @free joy::(a,b)->[(a,b)]
19:53:51 <lambdabot> $map ($map_Pair f g) . joy = joy . $map_Pair f g
19:55:47 <tabemann> scshunt: it's just... "USian" implies that we are imperialist pigs to call ourselves "Americans" in our own language, regardless of the nature of American foreign policy in the Americas over the years... sorry
19:56:19 <johnw> tabemann: I don't think this is really a #haskell topic
20:00:32 <pentace> We could make it one by defining data Amercian = ... :P
20:01:32 <monochrom> @free joy::(a,b)->a
20:01:33 <lambdabot> f . joy = joy . $map_Pair f g
20:03:10 <dpwright> I am working with a function in the StateT monad over IO (so the function returns StateT s IO ())
20:04:13 <dpwright> is there a function like "modify", where the function I pass it is in the monad I'm wrapping? something like modifyM :: Monad m => (s -> m s) -> StateT s m ()
20:06:50 <tabemann> modifyState f = do { x <- get ; put $ f x }
20:06:59 <tabemann> whoops
20:07:00 <tabemann> no
20:07:28 <tabemann> I dunno
20:07:35 <joelteon> yeah that's it
20:08:22 <tabemann> it isn't, because f returns a value that's in the *inner* monad, itself containing the value to put
20:08:26 <dpwright> does it not need a lft somewhere?
20:08:54 <dpwright> modifyState f = do { x <- get; let y = lift f; put y }
20:08:56 <dpwright> or something?
20:09:08 <k00mi> modifyM f = do { x <- get; x' <- liftIO $ f x; put x}
20:09:20 <k00mi> or just lift
20:09:38 <tabemann> that should be put x'
20:09:43 <k00mi> right
20:10:10 <dpwright> right
20:10:24 <dpwright> ok, so there's nothing like that in the standard library already?
20:10:51 <tabemann> just searched with hayoo - nothing fits the type signature you gave
20:11:01 <johnw> :t id %= f
20:11:03 <lambdabot> (Show b, MonadState b m, FromExpr b) => m ()
20:11:13 <tabemann> it does sound like a useful function, though, so I'm surprised no one has written it yet
20:11:28 <johnw> it seems a bit specific
20:11:32 <dpwright> yeah, that's why I wondered
20:11:51 <dpwright> I suppose it's specific to the StateT monad, not general for all transformer monads
20:12:32 <dpwright> but I thought StateT might provide something like it... doesn't look like it though
20:13:01 <dpwright> I suppose it's easy enough to add yourself if you need it..
20:13:11 <tabemann> johnw: well, it's pretty analogous to, say, modifyMVar_
20:13:31 <johnw> i wonder if lens has a way of traversing over the current state
20:13:35 <tabemann> actually, we should call this modifyState_, and give a version analogous to modifyMVar:
20:14:15 <dpwright> or just modify_? the original version in State is simply "modify", not "modifyState"
20:14:16 <tabemann> modifyState f = do { x <- get; (x', y) <- lift $ f x; put x'; return y}
20:14:35 <tabemann> modifyLift_ and modifyLift
20:14:46 <dpwright> ah, I see
20:16:30 <scshunt> tabemann: I wouldn't say "imperialist pigs" but possibly "slightly ignorant and not paying attention to the rest of the world"
20:17:05 <johnw> I think would: traverseState (lift . f)
20:17:28 <johnw> i have no idea how those words got swapped like that
20:19:43 <dpwright> johnw: what's traverseState?
20:22:04 <johnw> I'm suggested a more general variant of your modifyList
20:22:05 <johnw> modifyLift
20:22:08 <johnw> suggesting
20:23:27 <johnw> traverseState :: Monad m => (s -> m s) -> StateT s m ()
20:23:51 <johnw> well, I guess that's pretty much the same thing
20:24:41 <dpwright> ah, sorry, I thought you meant traverseState was an existing, defined function and started googling for it, heh
20:24:47 <johnw> oh, sorry!
20:26:14 <tabemann> what's the difference between your traverseState (you should call it traverseState_) and our modifyLift_? - the type signatures are identical
20:26:59 <seydar> what's it called when you have a function that starts like: myfunction arg1 | arg1 == 5 = "cool"
20:27:06 <seydar> what's that thingy called
20:27:20 <tabemann> guards
20:30:30 <tabemann> good... all I have left to do is the goddamn backtracking...
20:32:24 <smith_> Hey... I've got a question. With Text.Regex.Posix's =~~, is it possible to obtain a Maybe with the match text *and* its (MatchOffset, MatchLength) tuple?
20:33:14 <smith_> I know you can get the match text with :: Maybe String and the tuple with :: Maybe (MatchOffset, MatchLength), but I can't see anything that gives both in one go.
20:36:51 <seydar> tabemann: GUARDS
20:36:52 <seydar> thank you
20:38:11 <johnw> smith_: there are lots of RegexContext instances
20:38:50 <johnw> but you're right
20:39:08 <johnw> wait, what about tihs one:
20:39:15 <johnw> RegexLike a b => RegexContext a b (AllTextSubmatches (Array Int) (b, (MatchOffset, MatchLength)))
20:39:25 <johnw> that seems to be redundantly complete
20:40:29 <johnw> but maybe even then you have to extract the strings yourself
20:40:36 <cschneid> Can somebody familiar with snap help me separate my db logic away from my web logic? https://gist.github.com/cschneid/2d754a7af5e31614217a
20:40:52 <cschneid> ideally the db logic wouldn't have the `Handler` type in its signature, but I'm not clear on how to do that
20:40:56 <tabemann> did anyone see what I just said?
20:42:27 <tabemann> <tabemann> you might just have to build a function to do that yourself, as there's no appearance from looking at the Hackage docs that there's something that does that
20:42:27 <tabemann> <tabemann> random question
20:42:28 <tabemann> <tabemann> just how stable are StableNames?
20:42:28 <tabemann> <tabemann> (as with my test implementation of value equality testing with cycle resolution, I'm using IOArrays because I can easily test for identity equality, but if I decided to not use IOArrays could I reliably use StableNames for testing for identity equality?)
20:43:25 <johnw> cool, i've never used StableName before
20:43:31 <johnw> i wondered if Haskell could do that
20:43:44 <tabemann> I did too, and then I just remembered that those existed
20:44:01 * johnw files it away
20:44:17 <tabemann> from what the Hackage page implies, it doesn't provide *perfect* identity comparison, but nearly perfect
20:44:54 <johnw> well, it just means that if two stablenames don't match, it doesn't mean the objects aren't "equal"
20:45:03 <johnw> it's just like using pointer equality testing in C++, it comes with the same proviso
20:45:23 <seydar> so how do i do string equality? is "asdf" == "asdf" actually the preferred way to do it
20:45:29 <johnw> yes
20:45:40 <tabemann> well, what it means is that two objects that have different identities *may* have the same stablename
20:45:48 <tabemann> and also, after something is evaluated, its stablename may change
20:45:55 <johnw>  tabemann: how do you get that?
20:46:00 <johnw> i read it as meaning the opposite
20:46:12 <johnw> two objects with different stable names may be identical
20:46:30 <tabemann> that's what I got from the Hackage page
20:46:37 <Ralith> tabemann: I think you have it backwards.
20:46:39 <johnw> if what you said were true, what would the use of StableName even be?
20:46:53 <Ralith> tabemann: possibly you made an error in phrasing.
20:47:06 <FreeFull> @pl \f g xs -> f xs && g xs
20:47:06 <lambdabot> liftM2 (&&)
20:47:16 <tabemann>     If sn1 :: StableName and sn2 :: StableName and sn1 == sn2 then sn1 and sn2 were created by calls to makeStableName on the same object.
20:47:16 <tabemann> The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that mkStableName may return a different StableName after an object is evaluated.
20:47:36 <tabemann> okay
20:47:37 <tabemann> I see it
20:48:06 <johnw> so, stable names are surjective
20:49:29 <seydar> i'm trying to detect strings that are either empty or have only whitespace. a) is there a dirt simple way to do that, and b) how do i detect whitespace? Data.Ascii isWhitespace?
20:49:52 <heatsink> isspace
20:49:54 <heatsink> in Data.Char
20:50:46 <heatsink> You can use 'any' to test whether any characters in a list are not spaces.
20:51:03 <hpaste_> nabilhassein pasted “unboxed types” at http://lpaste.net/92055
20:51:03 <johnw> :t \xs -> null xs || all isSpace xs
20:51:03 <tabemann> and "all" to test whether all characters are spaces
20:51:04 <lambdabot> [Char] -> Bool
20:51:18 <monochrom> "not (all isSpace) string" or "any (not . isSpace) string"
20:51:27 <johnw> oh, that's good
20:51:35 <monochrom> there is no need to separately test for null. it's implied.
20:51:37 <nabilhassein> hello all, i was doing some reading earlier and ran into an issue I couldn't track down via google. If you look at the code I hpasted: what is kind #?
20:51:43 <johnw> > any (not . isSpace) ""
20:51:44 <lambdabot>   False
20:51:50 <johnw> no, not good enough :(
20:51:53 <heatsink> That's the kind of unboxed types
20:51:55 <FreeFull> > all isSpace ""
20:51:55 <monochrom> err, "not (all isSpace string)
20:51:56 <lambdabot>   True
20:51:58 <FreeFull> > all isSpace "   "
20:51:59 <heatsink> I guess top-level bindings have to be boxed?
20:51:59 <lambdabot>   True
20:52:05 <johnw> nice
20:52:07 <heatsink> Do you know what unboxed types are, nabilhassein?
20:52:28 <FreeFull> > all isSpace "   \t\v"
20:52:29 <lambdabot>   True
20:52:56 <monochrom> oh yikes, I have wrong nots
20:53:14 <nabilhassein> heatsink: i do know what they are, in terms of representation of data in memory
20:53:26 <monochrom> "all isSpace string" or "not (any (not . isSpace) string)"
20:53:28 <FreeFull> johnw: You don't need to test for null xs since any returns True for empty lists
20:53:32 <nabilhassein> but i'm more confused because i try to maintain a mental distinction between Haskell, the language, which has a specification
20:53:51 <nabilhassein> from GHC, a compiler, which implements that language (as well as a bunch of other language extensions)
20:54:03 <nabilhassein> I thought that in Haskell, all types were lifted and that undefined could appear anywhere
20:54:20 <nabilhassein> is that wrong? or is GHC.Prim simply not Haskell as defined in the specification?
20:54:31 <heatsink> Unboxed types are unlifted, and generally not represented concretely by pointers
20:54:35 <tabemann> nabilhassein: well in reality very many if not most people these days work in GHC Haskell, not in "Haskell", if one defines that as purely Haskell 98 or Haskell 2010
20:55:08 <heatsink> There are static constraints on unboxed types, necessary for code generation.
20:55:35 <heatsink> For example, if a variable has an unboxed kind, its type must be statically known
20:56:03 <nabilhassein> okay
20:56:11 <nabilhassein> wait
20:56:19 <nabilhassein> aren't the types of all variables statically known?
20:56:19 <heatsink> I don't think the Haskell specification has unboxed types at all.
20:56:23 <nabilhassein> inferred or annotated?
20:56:33 <heatsink> Statically known without mentioning type variables.
20:57:28 <nabilhassein> hm, i'm not sure i understand
20:57:36 <heatsink> Actually, I think maybe GHC doesn't even allow type variables of kind #
20:58:02 <nabilhassein> so i'm used to thinking about kinds like *, * -> *, etc
20:58:02 <heatsink> Consider the function id :: forall a :: *. a -> a
20:58:03 <seydar> what's the easiest way to get the last character of a string?
20:58:20 <monochrom> > last "abc"
20:58:21 <lambdabot>   'c'
20:58:22 <tabemann> seydar: last
20:58:28 <johnw> > all isSpace ""
20:58:29 <lambdabot>   True
20:58:35 <seydar> thank you
20:59:06 <johnw> that actually makes sense from set theory
20:59:21 <heatsink> nabilhassein, in regular System F, all values have a type that is in kind *
20:59:33 <seydar> i'm doing the exercism stuff
20:59:37 <monochrom> yes. see also my http://www.vex.net/~trebla/homework/empty.html
20:59:41 <seydar> i'm hoping this will get me back on track for my real life priorities
20:59:49 <heatsink> In GHC, values can also have types in kind # (and maybe some others, I don't remember)
21:00:12 <nabilhassein> heatsink: but not in Haskell's type system?
21:00:38 <heatsink> The Haskell language definition doesn't have unboxed types.  They're a GHC extension.
21:01:20 <smith_> johnw: I've been trying to use (AllTextSubmatches [] (b, (MatchOffset, MatchLength))), but I can't for the life of me figure out how to extract the data from me. Any pointers?
21:01:45 <FreeFull> @src all
21:01:45 <lambdabot> all p =  and . map p
21:01:48 <FreeFull> johnw: ^
21:01:56 <FreeFull> @src and
21:01:57 <lambdabot> and   =  foldr (&&) True
21:02:12 <heatsink> To start with, you can think of * and # as behaving the same way.  Some types are in *, and some are in #.  Having two kinds ensures that you don't mix the two.
21:02:15 <nabilhassein> heatsink: ah, that makes sense. I think there's a small error in part of the docs that I read too much into
21:02:17 <monochrom> what is exercism? :)
21:02:35 <heatsink> Boxed types are in *.  Unboxed types are in #.
21:02:35 <nabilhassein> or maybe i just misread it
21:02:44 <heatsink> What part?
21:03:23 <nabilhassein> It was here, let me try to find the exact part: http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
21:03:51 <nabilhassein> "Primitive (unboxed) types cannot be defined in Haskell, and are therefore built into the language and compiler."
21:04:06 <nabilhassein> if I understand correctly now, it should just say that they are built into the compiler
21:04:09 <nabilhassein> NOT built into the language
21:04:47 <smith_> When I try to use it in a pattern match, it seems that AllTextSubmatches suddenly has one constructor argument, not two, even though I know that's not true.
21:05:17 <heatsink> In GHC, some of Haskell 98's "primitive types" are actually derived types.  They're derived using GHC language extensions.
21:06:04 <heatsink> Haskell's Int, for instance, is not a builtin type.  It is defined in terms of GHC's builtin Int# in one of the library files.
21:06:40 <smith_> johnw: http://lpaste.net/92056
21:06:47 <heatsink> So, if you mess around with this level of abstraction, you have to acknowledge that there are language extensions supporting it.
21:06:51 <nabilhassein> heatsink: you mean here? http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/src/GHC-Types.html#Int
21:07:01 <heatsink> Yes
21:07:06 <nabilhassein> okay. that makes sense
21:07:20 <Jookia> Is there a way to have QuickCheck use custom arbitrary definitions, without making a new type?
21:07:28 <nabilhassein> I guess at some point you really have to start reading the C underneath it all?
21:07:41 <heatsink> Not for unboxed types
21:08:07 <heatsink> There's a paper that describes how they fit into Haskell's denotational semantics
21:08:19 <johnw> smith_: drop the [] argument
21:08:24 <nabilhassein> it's nice though, that I am able to pull the relevant documentation and source code up quickly with google. when I read GHC.Prim and see that everything is defined as "let x = x in x" I don't know where to turn
21:08:26 <johnw> the functor is inferred
21:08:29 <nabilhassein> well, i guess i turn to IRC, haha
21:08:54 <heatsink> Ah, those actually have built-in definitions
21:09:16 <nabilhassein> where are they?
21:09:23 <heatsink> i don't know
21:09:25 <nabilhassein> i looked but couldn't find them
21:10:06 <nabilhassein> there is this comment at the top of GHC.Prim: "This is a generated file (generated by genprimopcode). It is not code to actually be used. Its only purpose is to be consumed by haddock."
21:10:24 <heatsink> Here's the paper about the semantics of unboxed types http://research.microsoft.com/Users/simonpj/Papers/unboxed-values.ps.Z
21:10:57 <heatsink> Hmm
21:11:33 <smith_> johnw: That gives me a different error - http://lpaste.net/92057
21:11:56 <heatsink> I saw in the GHC sources there was a special file describing primitive ops
21:12:11 <heatsink> And a custom parser to read the file and generate actual source code
21:12:55 <nabilhassein> do you happen to remember where you saw it?
21:13:07 <heatsink> There's an extra step of compilation before you get the haskell/C/whatever source code
21:13:34 <heatsink> I don't remember where I saw it.  I was looking for something else, so I didn't pay attention.
21:14:09 <nabilhassein> is it related to this? http://ghc.haskell.org/trac/ghc/wiki/Commentary/PrimOps
21:14:18 <johnw> smith_: this works for me:
21:14:19 <johnw> getAllTextSubmatches $ (("blah" :: String) =~ ("a" :: String) :: (AllTextSubmatches [] (String, (MatchOffset, MatchLength))))
21:14:28 <johnw> (the type AllTextSubmatches does take the functor, the constructor doesn't)
21:14:58 <smith_> Ah, ah! I see now. Thanks!
21:15:10 <heatsink> that looks like it
21:15:30 <smith_> Didn't realize I had to use getAllTextSubmatches with it. Thanks again.
21:16:55 <nabilhassein> very interesting. it's late in new york so i can't pursue this any more for now
21:17:09 <nabilhassein> thank you very much! i really appreciate you sharing your knowledge with me
21:17:28 <heatsink> You're welcome to come back when you want to learn more :)
21:39:23 <alkabetz> Why is Prelude’s 'sum' nonstrict in its accumulating parameter?
21:39:28 <johnw> hehe
21:39:36 <johnw> did someone put you up to that question?
21:39:36 <alkabetz> (A pointer to the previous flamewar about this is an acceptable answer.)
21:39:42 <johnw> see yesterday
21:39:46 <alkabetz> johnw: Wait, really?
21:39:49 <johnw> yeah
21:39:51 <johnw> HUGE discussion
21:39:52 <johnw> check the IRC log
21:39:53 <alkabetz> Lolz.
21:40:11 <alkabetz> Okay.  I’m just starting to learn about performance in Haskell, so I was curious.
21:40:23 <alkabetz> I’m sure there’s a good reason; I just want to know what it is.  *goes to check IRC logs*
21:40:29 <johnw> in sort, + is too general for Haskell to assume that strictness is the right answer
21:40:31 <dmwit> I didn't see the discussion yesterday, but the traditional answer is "there's no good reason".
21:40:34 <dmwit> It sucks.
21:40:46 <dmwit> johnw: Yes, but the current default is the wrong default.
21:41:08 <dmwit> By the time you are advanced enough to use lazy numbers, you are advanced enough to know what's up with sum. Until then, strict sum is the right thing to do.
21:41:09 <johnw> I don't disagree, there should at least be a sum', maximum', etc.
21:41:23 <Cale> It is written as a foldl though, iirc.
21:41:27 <elliott> I think if you use it on Int it gets strictified.
21:41:31 <elliott> or maybe that was length.
21:41:34 <Cale> The real answer is that foldl' is not in the Prelude
21:41:38 <johnw> i mean, we rarely use foldl too, but it's more "obvious" than foldl'
21:41:51 <Cale> and the reason for that is that it was assumed that compilers would be doing strictness analysis
21:42:02 <alkabetz> Cale: USE_REPORT_PRELUDE gets you the foldl definition, but even the non-Report one is nonstrict
21:42:14 <johnw> let sum' = foldl' (+) 0
21:42:23 <Cale> and indeed, if you turn on optimisations, it should be strict
21:42:32 <johnw> orly?
21:42:43 <Cale> Or rather, the compiler will take advantage of its strictness
21:42:57 <Cale> (it is a strict function in any case)
21:43:10 <alkabetz> Cale: Uh, not on GHC 7.4.
21:43:17 <Cale> oh?
21:43:34 <alkabetz> Yeah, looks like that started in 7.6.
21:43:48 <alkabetz> Oh, wait.
21:43:51 <Cale> Maybe that's a 7.4 specific bug?
21:43:54 <alkabetz> Hang on, I'm getting some really weird behavior.
21:44:13 <Cale> Did you compile with -O2?
21:44:46 <alkabetz> Okay.  So, with -O or higher, it works on 7.4 and 7.6.  I guess I was getting some old object code leftover from compiling with -O0
21:44:50 <alkabetz> Sorry for the false alarm.
21:44:53 <Cale> Right.
21:45:03 <johnw> nice to know
21:45:06 <Cale> That's been that way as far back as I can remember
21:45:21 <Cale> I'm pretty sure even GHC 5.04 would get that right :)
21:45:21 <alkabetz> So, does GHCi have optimizations turned on by default?  Because I don't stack overflow in GHCi.
21:46:06 <Cale> Hm, that's curious.
21:46:14 <Cale> It doesn't optimise by default.
21:46:25 <Cale> But maybe it manages the stack a little differently.
21:46:53 <Cale> One difference is that it does use the threaded runtime. I'm not sure what effect that would have, if any, in this case.
21:47:39 * hackagebot cabal2ghci 0.0.1.1 - A tool to generate .ghci file from .cabal  http://hackage.haskell.org/package/cabal2ghci-0.0.1.1 (HiromiIshii)
21:49:13 <alkabetz> So, it definitely does not stack overflow.  It will, I have now discovered, happily swap the rest of the system into oblivion.
21:49:35 <Cale> Yeah, so probably it just removes the stack limit.
22:12:32 <tabemann> question
22:12:41 <scshunt> answer
22:12:43 <scshunt> daily double
22:12:53 <tabemann> what does "Empty record update of ..." mean when I'm using RecordWildCards?
22:13:48 <dmwit> Perhaps you wrote {}? Just a guess.
22:14:34 <dmwit> Or, like, { foo = bar, .. } but you covered all the fields in the "foo" part.
22:14:41 <dmwit> Or... dunno! What's the line it refers to?
22:14:56 <hpaste_> tabemann pasted “Empty record update” at http://lpaste.net/92059
22:16:32 <dmwit> ah
22:16:40 <tabemann> doesn't if you're using RecordWildCards and you use {..} in a pattern you're exporting all the fields in that record into the scope of the pattern?
22:16:42 <dmwit> It means the {..} is part of the Just, not the siblings, probably.
22:17:22 <tabemann> nah - putting siblings{..} in parens doesn't fix it
22:17:31 <dmwit> Maybe you meant Just (Siblings { .. }) -- note capitalization.
22:17:46 <dmwit> -s
22:18:04 <tabemann> ah that fixes it
22:18:50 <dmwit> err, yes, {} binds tighter than application, so it would indeed parse as Just (siblings {..}). So the real problem was the capitalization.
22:19:23 <dmwit> I have no idea what record syntax after a variable would mean in a pattern.
22:19:31 <dmwit> ...which is probably why it's an error. =P
22:26:25 <jfischoff> how does one deal with GADTs generically?
22:31:47 <Twey> dmwit: Sounds like http://en.wikipedia.org/wiki/Pattern_calculus
22:32:36 <tabemann> okay, time to go to bed
22:32:36 <BeardedCoder> I'm working through the Hutton book and had a question. The book has functions lke 'drop (n + 1)[] = []' where n + 1 means it' a positive integer. I'm getting 'parse error in pattern' on that though?
22:33:08 <Twey> BeardedCoder: It's a feature that no longer exists in Haskell
22:33:30 <BeardedCoder> doh, k. That would be why I can't find it in any other code
22:33:32 <Twey> (it never meant it was positive anyway, thanks to our lack of a natural type)
22:33:55 <Cale> GHC still supports it, but you need to turn it on explicitly
22:34:12 <Cale> If you add {-# LANGUAGE NPlusKPatterns #-} to the top of your file, it should work
22:34:30 <dmwit> Twey: It does mean it's positive.
22:34:54 <Twey> dmwit: (-3) doesn't match (n + 1) with n = (-4) ?
22:34:59 <dmwit> Twey: correct
22:35:10 <Twey> Urgh.  >.>
22:35:25 <dmwit> Yes, it's a very surprising feature.
22:35:39 <Twey> I'm suddenly glad it was dropped
22:35:48 <Cale> "Matching an n+k pattern (where n is a variable and k is a positive integer literal) against a value v succeeds if x >= k, resulting in the binding of n to x - k, and fails otherwise. Again, the functions >= and - are overloaded, depending on the type of the pattern. The match diverges if the comparison diverges."
22:36:20 <Twey> Surprising indeed.
22:36:58 <maxiepoo> poor Nats, they never get proper support in "real" languages
22:36:59 <haasn> it sort of makes sense in that you could swap patterns (n+1) and 0; not that it's really necessary
22:37:36 * haasn wonders if gmp has a native natural type
22:37:48 <johnw> i don't think so
22:37:50 <BeardedCoder> well, what was enlightening, ty for the input all.
22:37:51 <johnw> just integer
22:38:03 <johnw> int, float, rational and complex, if I recall
22:40:26 <raymank26> hi all. It the easy way to make random shuffle of list using Data.Random with StdGen from System.Random?
22:40:33 <raymank26> *Is
22:40:49 <haasn> @hackage random-shuffle raymank26
22:40:49 <lambdabot> http://hackage.haskell.org/package/random-shuffle raymank26
22:40:55 <johnw> heh
22:41:24 <raymank26> shuffle' :: RandomGen gen => [a] -> Int -> gen -> [a] dosn't return new stdgen
22:41:31 <raymank26> *doesn't
22:42:15 <haasn> there's shuffleM which can be used with Rand StdGen as the MonadRandom
22:42:22 <Twey> You can split it
22:42:43 <raymank26> okey :(
22:43:08 <raymank26> hassn: it there some example?
22:43:08 <dmwit> Eridius: ping
22:43:27 <haasn> runRand . shuffleM :: RandomGen g => [a] -> g -> ([a], g)
22:43:46 <dmwit> ?ask Eridius What did you finally end up doing about the CPP the other night? Got somebody complaining about the X11 library with similar-looking errors and I wonder what I can do to deal with it.
22:43:46 <lambdabot> Consider it noted.
22:45:11 <raymank26> haasn: thank you!
22:45:12 <haasn> λ (runRand . shuffleM) "hello world" (mkStdGen 1234)
22:45:14 <haasn> ("dololhwler ",522754180 1336516156)
22:49:41 <haasn> I wonder, are there any actual packages that provide RandomGen or MonadRandom instances other than StdGen?
22:51:32 <Ralith> haasn: several, I think.
22:56:09 <haasn> it would be cool if we could search for this kind of stuff
22:56:17 <haasn> eg. via hayoo
22:56:32 <haasn> packages that export instances of class X, or instances for type Y
23:02:07 <dmwit> haasn: For this particular thing, a revdeps search will probably narrow things down quite nicely.
23:02:10 <dmwit> ?where revdeps
23:02:10 <lambdabot> http://packdeps.haskellers.com/reverse
23:02:42 <dmwit> Turns out I'm wrong.
23:03:38 <haasn> looks like that mainly picks up users
23:05:27 <dmwit> Unfortunately, yes.
23:06:02 <haasn> still better than nothing, since it narrows it down from “all of hackage” to “a page of packages”
23:09:53 <Eridius> dmwit: I ended up just running the pre-built pandoc installer :/ but I emailed the author of CPP, and he put out a new version that supposedly implements the required behavior
23:10:04 <Eridius> dmwit: I haven't tried it yet, but hopefully cpphs can now be used to preprocess pandoc
23:10:23 <Eridius> err emailed the author of cpphs, naturally
23:11:11 <Eridius> dmwit: I also filed a radar about the fact that clang's preprocessor (in c mode) is more strict than GCC's, but I'm doubtful that anything will be done about that before release
23:14:59 <dmwit> Eridius: Thanks. I'll suggest this guy take a shot with a recent release of cpphs.
23:22:39 <Eridius> dmwit: I believe the version is 1.17.1
23:23:22 <Eridius> IIRC the flag for cabal install was --ghc-options="-pgmPcpphs -optP--cpp"
23:32:36 <mstksg> does anyone else always forget the rules for those prefix/infix rules when making inline functions like map ((/) 2) [1..]
23:33:04 <mstksg> i always have to throw open a ghci session
23:33:11 <mstksg> it doesn't happen often enough for me to develop a muscle memory for it
23:33:18 <mstksg> does anyone have a trick/mneumonic?
23:35:03 <Cale> mstksg: Which rules?
23:35:25 <Cale> mstksg: You're producing a list like [2/1, 2/2, 2/3, ...] there.
23:36:02 <Cale> It might be easier to read if you use an operator section like map (2/) [1..]
23:36:28 <Cale> (But I'm not sure which rules you're referring to exactly)
23:36:38 <mstksg> whether or not to type ((/) 2) or (/ 2)
23:36:56 <mstksg> and i guess i totally forgot about operator sections (2/)
23:37:29 <mstksg> does (/ 2) x = x / 2 and (2 /) x = 2 / x ?
23:37:37 <Cale> (/) is the prefix form of the infix operator /
23:38:02 <Cale> The arguments are applied to it in the same order as they'd normally occur, it's just that you get to write the (/) before the arguments that way
23:38:28 <mstksg> but i can't do something like
23:38:33 <mstksg> > / 2 6
23:38:34 <lambdabot>   <hint>:1:1: parse error on input `/'
23:38:41 <mstksg> i need the parentheses?
23:38:45 <Cale> Right.
23:39:16 <mstksg> is this a special rule for operators only, or does it apply to all "normally infixed" functions?
23:39:29 <Cale> I don't understand the distinction
23:39:33 <Twey> mstksg: You can just think of it as a section with both the arguments missing
23:40:16 <Twey> mstksg: Anything that can be written infix is an operator and can be used in an operator section (including prefix functions in backticks)
23:40:17 <mstksg> some functions are normally used as infixed, like `el`
23:40:37 <mstksg> can i do (`el`) to turn it into a prefix function too
23:40:43 <Twey> mstksg: Yes
23:40:59 <Twey> > (`elem`) 2 [1, 2, 3]
23:41:00 <lambdabot>   <hint>:1:8: parse error on input `)'
23:41:05 <Cale> no
23:41:06 * Twey blinks.
23:41:10 <Twey> No, apparently.
23:41:23 <Cale> elem is already prefix
23:41:27 <Twey> Well that's weird and inconsistent.
23:41:41 <Cale> You can put backticks around any ordinary function to make it infix
23:42:08 <mstksg> but there are no 'inherently infix' functions
23:42:11 <Twey> > (2 `elem`) [1, 2, 3] -- surely this should be valid iff (`elem`) is valid.
23:42:11 <Cale> Functions whose name consists of symbol characters are written infix
23:42:12 <lambdabot>   True
23:42:13 <mstksg> > 2 elem [1,2,3]
23:42:14 <lambdabot>   Could not deduce (GHC.Num.Num
23:42:14 <lambdabot>                      ((() -> [()] -> GHC.Type...
23:42:33 <mstksg> er, ordinary functions
23:42:34 <Cale> mstksg: Yes there are and (/) is one of them. Their names must consist entirely of symbols.
23:42:46 <mstksg> i guess i have been incorrectly referring to them as operators
23:43:04 <Cale> Well, you can call them operators, but they're also functions
23:43:05 <Twey> mstksg: If the function name is written with alphabetical characters, it's prefix, and can be made infix with backticks.  If it's made of symbol characters, it's infix, and can be made prefix with brackets.
23:43:05 <mstksg> as in operators = symbols only, normal functions = alphanumericsymbol
23:43:44 <mstksg> so "operators" (functions with only symbols) are inherently prefix, and non-operators are inherently infix
23:43:49 <mstksg> and conversion is done with () ``
23:43:53 <arkeet> > (??id) 2 elem [1,2,3]
23:43:53 <Twey> mstksg: Other way around.
23:43:54 <lambdabot>   Could not deduce (GHC.Num.Num
23:43:54 <lambdabot>                      ((() -> [()] -> GHC.Type...
23:43:56 <arkeet> er
23:43:58 <mstksg> er, yea, other way around
23:43:59 <mstksg> sorry.
23:43:59 <arkeet> > (id??) 2 elem [1,2,3]
23:44:01 <Twey> Yes
23:44:02 <lambdabot>   True
23:44:38 <mstksg> what is this magic
23:44:45 <haasn> (id??) is flip id
23:44:46 <Twey> It's a bit of a wart that conversion can only be done on single-identifier functions, so e.g. a `f x` b is a parse error
23:44:48 <haasn> or flip ($)
23:44:59 <Twey> :t (??)
23:44:59 <lambdabot> Functor f => f (a -> b) -> a -> f b
23:45:22 <mstksg> so i can't do infix functions with multiple arguments?
23:45:30 <haasn> it's a bit like (2$) elem [1,2,3]
23:45:42 <haasn> err
23:45:46 <haasn> ($2) elem [1,2,3]
23:46:17 <Twey> mstksg: You can't put whole expressions (e.g. function applications) in backticks, only identifiers.
23:46:37 <mstksg> Twey: by what you are writing you are intending to mean f x a b, right?
23:46:43 <Twey> mstksg: Yes
23:47:04 <mstksg> is there any way to get around this
23:47:11 <mstksg> besides naming the function?
23:47:16 <Twey> mstksg: You can let- or where-bind the function to an identifier
23:47:19 <Twey> No
23:47:36 <mstksg> a `(f x)` b
23:47:49 <haasn> a & f x $ b
23:47:49 <Cale> The trouble is that backtick is only one symbol, so if you start allowing arbitrary expressions in there, you also have expressions which contain backticks
23:47:58 <Cale> and you end up with ambiguous parses
23:48:00 <Twey> mstksg: You can also only convert once
23:48:15 <Twey> Which I suppose is consistent with (`f`) being illegal
23:48:21 <Twey> Cale: *nod*
23:48:28 <Twey> It was a poor choice of character, I think
23:48:29 <haasn> Twey: and `(+)`
23:48:39 <Twey> haasn: Yes, that's what I meant
23:49:35 <mstksg> the possibility of ambiguity is not immediately apparent
23:49:39 <mstksg> to me
23:49:41 <Twey> haasn: I usually view infix-to-prefix conversions as a special case of operator sections, but the lack of (`f`) breaks that rule (okay, it's useless, but so is (`f` x), and that's valid)
23:49:43 <mstksg> but i can take your word for it
23:49:59 <Twey> mstksg: `(`f`)` is difficult to parse
23:49:59 <haasn> mstksg: a`b`c`d`e
23:50:19 <haasn> is that a `b` c `d` e  or a `(b `c` d)` e
23:50:45 <mstksg> that same problem comes up with normal function binding/application
23:50:48 <maxiepoo> the first one
23:50:53 <mstksg> we solve it with parentheses and clever operators
23:51:13 <mstksg> define a default binding and allow people to alter it with parentheses etc.
23:51:27 <Twey> The world would have been saved much trouble if ‘chiral quotes’ had been encoded in ASCII in the first place.  ☹
23:51:28 <mstksg> but i guess it's a level of complexity with very little practical benefit
23:52:49 <Twey> mstksg: Yes, but that doesn't really diminish the overall hack-level :þ
23:55:39 <mstksg> i've been sitting here trying to think of a three argument function to watch a `f x` b fail with
23:56:40 <int-e> @type comparing
23:56:41 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
23:57:16 <mstksg> > " " `center 10` "center me"
23:57:17 <lambdabot>   <hint>:1:13: parse error on input `10'
23:57:32 <mstksg> > center 10 ' ' "center me"
23:57:33 <lambdabot>   Not in scope: `center'
23:57:33 <lambdabot>  Perhaps you meant one of these:
23:57:33 <lambdabot>    `censor' (import...
23:59:31 <mstksg> comparing is a good one
