00:13:24 <fylwind> is there a class that has a function with signature:: c a b -> a -> b where 'c' represents the class?  it's kind of like an arrow but in reverse
00:15:35 <johnw> well, if c were (->), your function would be ($)
00:20:25 <fylwind> right, but c is not a -> :(
00:23:12 <haasn> johnw: don't need IO for telling the time: http://hackage.haskell.org/packages/archive/acme-now/1.0.0.1/doc/html/Acme-Time-Now.html
00:25:02 <johnw> haha
00:25:18 <johnw> now = unsafePerformIO getCurrentTime :)
00:26:46 <erisco> @pl \xs -> [(xs, a)]
00:26:49 <lambdabot> return . flip (,) a
00:26:49 <lambdabot> optimization suspended, use @pl-resume to continue.
00:28:49 <erisco> @pl \xs -> f (g xs) (h xs)
00:28:49 <lambdabot> liftM2 f g h
00:29:12 <erisco> :t liftM2
00:29:14 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:29:29 <johnw> it's using the monad for (->) e there
00:29:44 <wunki> would it be possible to quickly add a module for testing to the system without a cabal file (it's one file only)?
00:29:58 <erisco> johnw, hm ... don't know monads yet so quite mysterious
00:31:13 <johnw> well, that one is a bit tricky
00:35:51 <erisco> I'll use it blissfully for now :)
00:36:25 <kqr1> it says ticket #7509 is fixed and it says "version 7.6.1" and "milestone 7.8.1" – which of these numbers refer to the version i can expect the fix to be in?
00:36:43 <kqr1> (ticket in question: http://ghc.haskell.org/trac/ghc/ticket/7509 )
00:36:55 <johnw> 7.8.1
00:36:59 <kqr1> oh okay :(
00:37:00 <johnw> version should be the version it was found against
00:37:10 <kqr1> ah right
00:39:05 <levi> wunki: You can probably do it with ghc-pkg, but I'm not sure how much easier it would be than making a .cabal file.
00:39:46 <wunki> levi: ok, thanks. Think I will just load the modules in GHCI.
00:39:59 <wunki> I'm doing exersism.io btw, which is pretty cool
00:41:45 <levi> I have been slowly working on something kind of like that.  More like 4clojure.com, with automated test feedback.
00:42:19 <wunki> yes, I also did 4clojure, loved it
00:42:28 <wunki> nice thing about this is that you get "human" feedback
00:45:34 <levi> I'd like to incorporate something like that eventually; right now I'm trying to figure out a reasonable way of running test cases.  My current approach is to hack doctest to output json instead of strings.
00:48:23 <wunki> that would be really nice. I have you have something to test, ping me :)
00:49:58 <erisco> johnw, where do I read on this (->)e thing? if it has an applicative interface, it might already define what I need
00:50:05 <levi> That will probably not be for a while at the rate I'm going. :P
00:50:41 <johnw> erisco: it does, liftA2 :)
00:51:00 <johnw> it basically the Reader monad
00:51:17 <johnw> :t liftM (+)
00:51:18 <lambdabot> (Monad m, Num a1) => m a1 -> m (a1 -> a1)
00:51:37 <johnw> in the case of (->) e, m = (->) e
00:51:41 <johnw> so that signature becomes:
00:52:22 <johnw> (e -> a) -> e -> (a -> a)
00:54:22 <hpaste_> nonconvergent pasted “wrong type on line 22” at http://lpaste.net/92131
00:54:30 <johnw> liftM (+1) (+1) $ 5
00:54:32 <johnw> > liftM (+1) (+1) $ 5
00:54:34 <lambdabot>   7
00:54:44 <nonconvergent> Sorry, wrong box.
00:54:49 <nonconvergent> :P
00:55:01 <johnw> but I don't think I'm explaining anything very well here
00:55:13 <johnw> erisco: http://stackoverflow.com/questions/14430397/about-the-function-monad
00:55:24 <erisco> johnw, its okay.
00:57:52 <erisco> f <$> _ <*> a     I want to transform this into something like   f op a   where it takes an argument and effectively puts it in the underscore spot
00:58:11 <erisco> and yes, I could use a lambda, but my goal is a cleaner, enforced interface
00:58:19 <johnw> can you show me the lambda version?
00:58:29 <erisco> \x -> f <$> x <*> a
00:58:55 <johnw> so the type is :: a -> f b?
00:59:03 <johnw> where Applicative f?
00:59:26 <sipa> @pl \x -> f <$> x <*> a
00:59:29 <lambdabot> (f <$>) . (<*> a)
00:59:30 <lambdabot> optimization suspended, use @pl-resume to continue.
00:59:35 <johnw> oh wait, is x a pure value?
00:59:39 <johnw> or is it in the applicative?
00:59:55 <erisco> it is the applicative
01:00:14 <johnw> then I think the lambda form may be the clearest
01:00:16 <erisco> sipa, I suppose using that tool would have made sense
01:00:25 <erisco> but not sure that is what I want
01:00:31 <erisco> johnw, no no, that isn't the point =\
01:00:36 <johnw> what is the point?
01:01:18 <erisco> the user *has* to write the lambda exactly as such. the point is to take that burden away
01:01:41 <johnw> what about sipa's @pl result?
01:01:52 <johnw> or
01:02:05 <johnw> flip (liftA2 f) a
01:02:26 <erisco> I dunno maybe I'm trying for the wrong thing
01:04:18 <erisco> I'm trying to hide it away
01:04:37 <johnw> i don't really understand anymore
01:04:42 <johnw> you want x to be in a reader environment?
01:04:51 <erisco> I don't know what "reader environment" means
01:05:39 <erisco> maybe I can define a different type class or something. *shrug*
01:06:05 <erisco> it works with the lambda, yes, but it exposes invalid ways to use the interface
01:07:03 <erisco> not that I know monads, but it'd be like unwrapping IO and giving you the underlying data for free to use however you want
01:07:39 <johnw> can you show me an example of what you want the "solution" to look like?
01:07:43 <liyang> What's a nice library for pretty-printing XML? I guess it doesn't have to be particularly pretty. Ease-of-use is perhaps more important.
01:07:45 <MedDev> johnw, it seems like in some of my functions I have to do put myNewState and then also return myNewState (type is StateT MyState IO (MyState) ) does this mean that i can just have the type be StateT MyState IO ()?
01:07:57 <johnw> yes
01:08:05 <johnw> you can "put myNewState"
01:08:52 <johnw> State "desugars" to s -> (a, s), which is equivalent to your original version; so you're doing the same thing, you're just using the Monad to do it now
01:09:28 <erisco> johnw, I'll play around more and see if I can come up with something more coherent. I was mainly hoping that trying to explain it would help me come up with an answer
01:09:39 <johnw> before, when a was () you returned just s, but with StateT you always return only a, so it has to be ()
01:10:14 <johnw> erisco: ok, I'm not sure I have any clue now what you are trying to achieve, so I'm afraid that any further attempts at help will just confuse the issue
01:19:13 <MedDev> johnw, ah because i'm in the IO monad? and put has the type of StateT s m (), so whenever I put it's always equivalent to StateT MyState IO () and the type is actually MyState -> (MyState, IO ())? The StateT just hides that
01:19:38 <johnw> the type is MyState -> IO (MyState, ())
01:19:45 <nh2> http://lpaste.net/92133 <- why does it stackoverflow with replicateM 1000000 randomIO?
01:19:50 <johnw> @unmtl StateT MyState IO ()
01:19:50 <lambdabot> MyState -> IO ((), MyState)
01:19:56 <johnw> sorry, flipped the pair
01:20:19 <nh2> I could imagine it doing that on tail, but why on head?
01:20:47 <johnw> nh2: the IO monad forces that list
01:21:23 <MedDev> johnw, damn, so close! i'll get it one of these days heh
01:21:48 <nh2> johnw: yes but does it not force left to right, which should be fine?
01:21:51 <johnw> nh2: I don't recommend ever using this
01:21:55 <johnw> l <- unsafeInterleaveIO $ (replicateM 100000 randomIO :: IO [Int])
01:21:59 <johnw> that will give the behavior you expected
01:22:06 <johnw> and now you know why lazy I/O was born
01:22:13 <johnw> but it has its own issues
01:22:34 <nh2> sins behold!!
01:22:48 <johnw> nh2: it forces the spine of the list before the assignment to l happens
01:23:02 <MedDev> @unmtl Float -> String -> StateT MyState IO
01:23:02 <lambdabot> Float -> String -> StateT MyState IO
01:23:19 <johnw> Float -> String -> MyState -> IO (??, MyState)
01:25:00 <mauke> @unmtl StateT MyState IO Zomg
01:25:00 <lambdabot> MyState -> IO (Zomg, MyState)
01:26:00 <uvelichitel> Im playng with code.google.com/p/biogo.graph. Code have interfaces with unexported methods. I can't touch a sense of that. Reference say norhing about unexporting methods in interfaces. Where should I better read about subj?
01:27:27 <mauke> preflex: ? .ua
01:27:27 <preflex>  Ukraine
01:27:59 <mauke> uvelichitel: I think you're in the wrong channel
01:28:36 <nh2> johnw: no I don't get why it happens. With replicateM n x = sequence (replicate n x) and sequence foldr (... x <- m; xs <- m'; return (x:xs) ), why should it overflow?
01:28:42 <uvelichitel> Ah. Its true excuse me
01:29:15 <kryft> I'm parsing a format with a bunch of fields that could appear in any order and of which some are optional; the parser returns a record with a bunch of fields. Is it a good solution to have a (parsec) parser with my record type as a custom state and have each individual field's parser update it?
01:29:25 <johnw> nh2: you're doing a million iterations, right?
01:29:51 <nh2> johnw: yes
01:30:06 <johnw> so, that only leaves 8 bytes per iteration, which isn't enough apparently
01:30:17 <levi> Yay, I have a hacked-up doctest that dumps test output in json format now.
01:30:31 <levi> Time to sleep.
01:31:40 <johnw> when you use the result of a call to sequence, it forces that result.  a function IO [a] must produce the entire list before it can return it
01:32:10 <johnw> unsafeInterleaveIO relieves that burden, but at the cost of causing IO to happen who-knows-where in your code
01:35:43 <johnw> is (>>=) for IO strict in both arguments?
01:36:47 <nh2> johnw: I understand that it has to load my whole list into memory, I'm fine with that. But why does it use stack space? I'd think it'd just allocate the list as usual like any other million-sized list
01:37:26 <johnw> replicateM is causing 2,000,000 invocations of >>=, based on your expansion using foldr above
01:37:50 <johnw> did you try compiling with -O2?
01:37:58 <johnw> i'm not sure whether that will eliminate the stack use or not
01:38:01 <johnw> but that's a lot of lambdas
01:38:35 <nh2> johnw: yes that is with -O2
01:38:59 <johnw> then it's generating the lambdas for >>=, and they are taking up stack space
01:39:10 <johnw> i've run into this exact same problem before, btw
01:39:23 <johnw> finally I just had to increase stack space, but I'd love to know if there's a better way
01:39:37 <nh2> I run into this every half a year :(
01:40:20 <nh2> also it works in ghci without problem
01:42:33 <johnw> that's interesting
01:42:41 <johnw> my analysis could very well be wrong
01:43:53 <nh2> I don't quite get it still, O2 breaks, O0 breaks, ghci works
01:46:17 <johnw> how about runghc?
01:48:32 <nh2> johnw: runghc works
01:48:51 <johnw> i have a feeling that evaluating replicateM in runghc/ghci does not use stack
01:49:48 <nh2> johnw: also this works in ghc: http://lpaste.net/92134 using a dlist
01:51:06 <johnw> interesting
01:52:20 <johnw> your version is tail-call optimized
01:53:06 <johnw> @src foldr
01:53:06 <lambdabot> foldr f z []     = z
01:53:06 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:54:16 <johnw> let me do some more analysis here
01:57:19 <supki> johnw: how is it tail-call optimized?
01:57:32 <supki> last call is to (>>=)
01:57:37 <johnw> oh, duh
01:57:47 <johnw> I was reading m >>= go
01:57:49 <johnw> and seeing just the go
01:58:55 <johnw> maybe it's simply due to half the number of >>= calls?
01:59:30 <nh2> johnw: half the number, where?
02:00:03 <johnw> the original is m >>= \x -> m' >>= \xs -> return (x:xs)
02:00:18 <johnw> your is m >>= \x -> go ms (dlist . (x:))
02:01:00 <johnw> actually, that x <- m in the default definition of sequence seems a bit wasteful, but I bet GHC optimizes that away
02:01:07 <johnw> i'm still working on my analysis though to confirm
02:01:31 <nh2> johnw: the number doesn't seem to matter, with my version I can easily multiply the N by factor 10
02:01:38 <johnw> ok
02:05:54 * hackagebot tidal 0.2.2.6 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.2.2.6 (AlexMcLean)
02:09:34 <johnw> for lists that fit in stack space, your version is 20% slower
02:09:42 <johnw> but yours has the advantage of working for lists of essentially any length
02:09:53 <johnw> which leads me to believe that you're trading stack for heap
02:10:38 <johnw> by putting the result value for each element inside a function, rather than having it live on the stack
02:10:57 <johnw> but I need to dig deeper, time to look at Core
02:13:58 <eis> Hi everyone. A question to sublime-haskell users. How do I see the text of a compilation warning that is highlighted in my code? I don't see any warnings in error output, but there are highlighted (gray outline) parts of my code.
02:15:01 <nh2> eis: are you using the ghc-mod or cabal backend for checking?
02:15:07 <johnw> i'm using ghc-core
02:15:11 <johnw> I think I've found the difference
02:15:42 <johnw> under -O2, your version isn't binding a let variable in the loop
02:15:55 <eis> nh2: I think it's ghc-mod (since sublime-haskell requires it), although I'm not sure. How do I check?
02:16:11 <nh2> johnw: I think you are right, but I do not properly understand when the stack is used and when not
02:16:20 <nh2> eis: does your project have a cabal file?
02:16:28 <eis> nh2: yes it does
02:16:47 <johnw> I think that anything constructed is constructed on the heap, and anything bound by a let is bound on the stack
02:17:08 <johnw> where function argument bindings I guess would like an implied let
02:17:43 <eis> nh2: I also tried to do 'cabal build', everything's ok and there are no warnings. Still, there are some highlighted parts in sublime.
02:18:15 <johnw> nh2: see https://gist.github.com/jwiegley/6327073
02:18:25 <johnw> the top is your function, the bottom is the default function
02:18:27 <nh2> eis: when you save in sublime, the status bar at the bottom should either show "ghc-mod: checking yourfile.hs" or something with cabal
02:18:34 <johnw> see the let on line 9 of the default version?
02:19:09 <eis> nh2: Yes. It says 'cabal-dev: building'
02:21:24 <nh2> johnw: yes I see it
02:21:49 <johnw> now I want to see if I can rewrite the original sequence without your dlist, or introducing that let
02:22:32 <nh2> eis: ok, two things: first: what is your SublimeHaskell "auto_build_mode" setting set to? Can you check in the user and the default config?
02:23:15 <eis> nh2: it's "normal-then-warnings" in both.
02:23:39 <eis> nh2: BTW, I deleted the 'dist' directory, and ran cabal build again. Now I see all the warnings in output.
02:24:12 <nh2> eis: yes, cabal will only display the warnings the first time you compile, after that it will avoid compilation wherever possible
02:24:42 <nh2> that's why normal-then-warnings will run a second pass with `-Wall -fforce-recomp` over your code
02:25:04 <eis> nh2: aha, that explains a lot. so is there any way I can see those warnings in sublime-text?
02:25:23 <nh2> yes it should show it, let me try some things
02:25:39 <nh2> is your project public? then I could try right on it
02:27:44 <eis> nh2: thanks! yes, I have it on github. here's the clone URL: git@github.com:blacktaxi/inversion.git
02:29:25 <johnw> nh2: I can't, and I think my analysis was correct.  The version in base stores the intermediate elements on the stack as it constructs the list, while your version stores the intermediate elements inside functions on the heap.  Your stack use is constant because you only ever use one value: the function you keep replacing with a composed new version.  So you're growing a "virtual stack", which has no bounds, at the cost of having to
02:29:26 <johnw> perform N function applications at the very end before you can return.
02:30:37 <johnw> and thanks to this, I now know how to fix my other program, where my N is not known at compile-time and so I was forced to up the stack to an arbitrarily large value
02:31:12 <MedDev> ... are you a wizard?
02:32:00 <johnw> among some of the wizards in the channel, I'm just a carpet sweeper, believe me
02:32:03 <Saizan> johnw: as long as performing the function applications at the very end won't consume O(N) stack, which is what happens if they are strict
02:32:13 <johnw> Saizan: great point!
02:32:34 <johnw> in his case it's (x:) . (x':) . (x'':) . id
02:32:43 <Saizan> right, that works
02:32:52 <nh2> johnw: I see. Yet I find the fact that sequence only works on short lists very disturbing
02:33:29 <johnw> i guess it's not a limitation people run into often enough to want to optimize the other way
02:33:37 <johnw> a 20% hit is not small
02:33:56 <johnw> but maybe there should be a sequence variant that is unbounded
02:34:16 <nh2> I mean stack space errors are some of the worst, since they give even less feedback about what happened than error. If that happens in my production system, I'm screwed
02:34:33 <johnw> at least this time it wasn't due to laziness
02:34:43 <Saizan> for large lists you probably want a streaming solution, like pipes/machines/..
02:35:06 <johnw> @src foldM
02:35:06 <lambdabot> foldM _ a []     = return a
02:35:06 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
02:35:23 <Saizan> so that you can return the list lazily even in a monadic context
02:35:28 <nh2> Saizan: why would I want to stream if I need them all in memory anyway? As johnw said, it's not even a lazy IO issue here
02:35:49 <Saizan> nh2: ah, ok, i assumed you wouldn't
02:36:29 <nh2> in my case, I actually want to reuse that list multiple times, that's why my disability to construct it bothers me so much :(
02:37:24 <johnw> so use your sequence'
02:37:26 <johnw> that's a perfect valid solution
02:37:27 <nh2> and I mean, no matter how long you've been doing this stuff already, replicateM N randomIO would probably be the first case you come up with
02:37:28 <Saizan> WriterT and sequences_ could've worked
02:38:24 <johnw> Saizan: wouldn't <> have the same problem as : here?
02:38:36 <nh2> so this way the my really intuitive code turns out to be very unsafe one; it's not even slow (as in most of the laziness problems), but it will crash
02:39:02 <Saizan> because it's a strictness problem :)
02:40:07 <nh2> yeah but this time it is strictness + *where* the strictness is, and that can vary a lot depending on the compiler as we see here
02:40:46 <Saizan> did we?
02:40:56 <Saizan> i guess i should read the backlog
02:41:08 <nh2> yes, both versions run fine on runhaskell and ghci
02:41:21 <johnw> that's not a strictness issue
02:41:32 <johnw> you're comparing very different evaluators, which use resources differently
02:41:36 <Saizan> johnw: yeah, i guess WriterT's (>>) kills the tail recursion
02:41:43 <johnw> i bet that ghci uses a heap-based stack machine
02:42:15 <johnw> or maybe not, actually
02:42:30 <nh2> if I want some confidence that my programs won't suddenly crash on me, I currently feel that base doesn't serve me well :(
02:42:47 <johnw> Emacs' byte-code evaluator uses the stack, but just keeps calling brk() to make the stack larger as needed
02:43:26 <Saizan> johnw: ghci's?
02:43:39 <johnw> in ghci, his example works fine with the default version of sequence
02:43:40 <nh2> johnw: ghci is written on top of emacs? I knew it
02:43:45 <johnw> no no!
02:43:48 <nh2> :P
02:44:10 <hvr> nh2: where'es the :elisp command then?
02:44:13 <johnw> i know next to nothing about ghci though, so these are just pure supposition
02:44:30 <johnw> anyway, back to work :)
02:45:33 <mel-> Hi
02:46:49 <mel-> can I do something like "type Foo = (SomeClass a) => a -> ConcreteType"? i.e., i want to give the type 'function of a -> ConcreteType where a is instance of SomeClass' a type?
02:47:09 <mel-> I guess not?
02:47:18 <johnw> sure you can
02:47:22 <johnw> if you enable several extensions
02:47:32 <johnw> type Foo = forall a. (SomeClass a) => a -> ConcreteType
02:47:52 <mel-> hm interesting, thanks
02:47:53 <johnw> ghc should complain enough for you to find out which ones you need
02:48:52 <Saizan> a forall in a type synonym rarely means what you want
02:49:03 <Saizan> mel-: can you give an example of where you'd use this?
02:49:22 <mel-> sure
02:51:17 <nh2> eis: I'm looking into it. I also lost my warnings :o
02:51:40 <mel-> I'm writing an Application in Gtk2hs. I've been thinking about writing a thin 'convenience' layer to reduce the amount of boilerplate. When I program in Gtk2hs, I can 'retrieve' GUI Widgets through an XML description of the GUI. In order to actually use these widgets you must cast them. So there are functions like castToWindow, castToButton, etc. For my convenience layer I wanted to introduce a type matching
02:51:41 <mel-> these 'casting functions'.
02:52:13 <mel-> and they are of type GObjectClass obj => obj -> Window
02:52:18 <Saizan> nh2: seems like ghci just grows or otherwise uses a larger stack by default, starting it with +K reproduces the overflow there too
02:52:25 <mel-> it's not crucial that I have a type name for these. but i was wondering.
02:52:33 <Saizan> nh2: +RTS -K8M, i meant
02:52:45 <nh2> Saizan: ah, good to know!
02:52:55 <johnw> yes, good to know
02:53:05 <johnw> can I put that in my .ghci?
02:53:11 <johnw> :set +RTS -K8M?
02:53:19 <Saizan> no idea
02:53:22 <johnw> no, that fails
02:54:07 <Saizan> mel-: well, the issue is actually if you are going to use this Foo on the left of (->) in types or not
02:54:55 <Saizan> mel-: because Foo -> X and GObjectClass obj => (obj -> Window) -> X are very different, and that often causes confusion
02:55:04 <Saizan> mel-: otherwise it should be fine
02:55:10 <johnw> then you're in rank-2 territory at least
02:55:36 <johnw> and easily without realizing it at first
02:55:47 <mel-> Saizan: I'm not sure I can follow here. :)
02:55:59 <johnw> mel-: the take-away: don't do that
02:56:09 <johnw> you'll end up with type-errors that will have you begging for mercy
02:56:46 <johnw> or, try it and enjoy the educational ride! :)
02:57:07 <nh2> johnw: so what was your opinion about also offering a sequence' for a general audience?
02:57:33 <Saizan> mel-: Foo -> X means (forall obj. GObjectClass obj => (obj -> Window)) -> X, which is a function that will only take _polymorphic_ functions as arguments
02:57:53 <johnw> nh2: I wouldn't bother
02:58:02 <johnw> very soon (7.10?) sequence will become sequenceA
02:58:21 <johnw> and then each Traversable instance will get to choose how to implement that function, leaving yours only beneficial as a specialization for lists
02:58:35 <lukexi> does anyone have any good ideas for justin spahr-summers? https://alpha.app.net/jspahrsummers/post/9673745
02:58:56 <mel-> Saizan: okay, thanks
02:59:43 <johnw> nh2: and if you're going to do that, then why use sequence at all?  just peel of the number of actions that you want and then sequence *that*
02:59:54 <johnw> i.e., sequence . head , rather than head <$> sequence
03:00:07 <johnw> i mean, why use replicateM
03:00:33 <johnw> and then use just replicate instead of replicateM
03:00:33 <nh2> johnw: oh no, head was just to minimize the test case. I use the full list (multiple times)
03:00:40 <johnw> ah, I see
03:00:58 <johnw> you really want to generate a list of 1,000,000 randoms to play with
03:01:03 <nh2> yes
03:01:31 <johnw> is the size of the list a compile or run-time value?
03:01:39 <nh2> a run-time value
03:01:48 <Saizan> you can still do that without going through IO each time, using randoms, but i guess you are making a larger point about sequence
03:02:15 <nh2> Saizan: right
03:02:18 <johnw> there's no harm at all in bringing this up on libraries@, but I have a feeling no one is going to get very excited about it
03:02:35 <johnw> because there are almost always other ways to express the solution
03:03:02 <johnw> @src [] sequenceA
03:03:03 <lambdabot> Source not found. Maybe you made a typo?
03:03:32 <nh2> from a theoretical viewpoint, the discussion is probably not too interesting; from a software engineering one it's a reliability killer
03:03:49 <johnw> nh2: this same problem crops up when using foldM, btw
03:03:56 <johnw> and probably many of the iterative monadic functions
03:04:20 <nh2> @src foldM
03:04:20 <lambdabot> foldM _ a []     = return a
03:04:20 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
03:04:32 <nh2> :t foldM
03:04:32 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
03:04:49 <johnw> now imagine the a you want to build up is a list
03:04:54 <nh2> johnw: how in foldM? I thought it only happens if you *produce* a list
03:04:58 <Saizan> foldM should be fine
03:05:00 <nh2> ah you do want to produce a list
03:05:10 <johnw> yeah, I ran into using foldM and <>
03:05:33 <johnw> at a certain point, a few million elements in [b], it would always blow stack; remained a mystery to me until tonight
03:06:10 <Saizan> it can't cause a stack overflow like sequences
03:06:14 <Saizan> *sequence
03:06:20 <Saizan> it might cause one like foldl
03:06:44 <johnw> well, i was do something like this:
03:06:46 <Saizan> i.e. by returning something that then overflows when reduced
03:08:52 <johnw> https://gist.github.com/6327253
03:09:03 <johnw> where listDirectory can sometimes return a really large list
03:10:07 <johnw> Saizon: that "fax" variable up above isn't kept on the stack?
03:10:52 <ehamberg> how is ~ pronounced (as in “could not deduce (foo ~ Bar)”)?
03:10:58 <lpsmith> hmm,  I'm messing around with the IO manager,  and when I change the libraries/base/configure.ac file to check for another header file,  and then call autoheader,  it's not regenerating libraries/base/include/EventConfig.h.in
03:11:10 <lpsmith> any ideas?
03:11:11 <johnw> type equality
03:11:28 <Saizan> johnw: a pointer, at most
03:11:45 <johnw> yeah, so, N pointers will blow stack at some point
03:11:57 <Saizan> there are no N pointers around here
03:12:05 <Saizan> just 1 at a time
03:12:07 <johnw> oh, cool
03:12:22 <johnw> glad we brought this up
03:12:23 <ehamberg> johnw: thanks
03:12:39 <Saizan> well, i guess it might depend on the monad, which one were you working in?
03:12:45 <johnw> IO
03:13:14 <Saizan> ok, so in that case foldM is properly tail recursive
03:13:55 <johnw> i guess my use of seq in that code snippet wasn't not deep enough then
03:15:09 <johnw> funny, I'm even using dlists there
03:15:38 <lpsmith> yet when I remove one of the header files defined in AC_CONFIG_HEADERS,  it dumps all the configuration stuff into one file
03:15:40 <johnw> anyway, another day I'll have to look at the core
03:15:50 <lpsmith> including my new header file I'm looking for
03:16:40 <pentace> Do Data.Map's index functions preserve order of all untouched elements in a map after inserting, deleting or updating an element?
03:19:39 <donri> pentace: a Map is always sorted on the keys
03:20:24 <pentace> Where the indices reflect this order?
03:20:42 <donri> pentace: yes
03:20:55 <pentace> okay
03:21:17 <johnw> Saizan: how can foldM be properly tail recursive if the last function it calls is >>=?
03:22:07 <Saizan> johnw: inline that (>>=)
03:22:13 <johnw> ok, one sec
03:22:29 <Saizan> or, consider that it's lazy on the rhs
03:22:35 <johnw> ohh
03:23:07 <Saizan> and the rhs will only get called once, in a tail position
03:24:52 <johnw> got it
03:25:23 <johnw> the core for this just calls Control.Monad.$wfoldM
03:25:32 <johnw> I wonder how I can see the core for library functions like that?
03:27:17 <Saizan> --show-ifaces can show what's saved in the .hi files, but if it's not there you'd have to recompile the module
03:28:30 <Saizan> but the polymorphich version won't be so instructive
03:31:00 <hape01> How can I add a type signature to circumvent the ambiguius type?
03:31:01 <hape01> > foldM (return.(+)) 0 [1,2,3]
03:31:02 <lambdabot>   <Integer -> Integer>
03:31:16 <johnw> (0 :: Int)
03:31:21 <hape01> yes
03:31:27 <johnw> i mean, type that
03:31:35 <johnw> > foldM (return.(+)) (0 :: Int) [1,2,3]
03:31:36 <lambdabot>   <Int -> Int>
03:31:50 <hape01> my ghci says: No instance for (Show (Int -> Int)) arising from a use of `print'
03:31:57 <johnw> > foldM (return.(+)) (0 :: Int) [1,2,3] $ 5
03:31:59 <lambdabot>   15
03:32:06 <donri> @hackage show
03:32:06 <lambdabot> http://hackage.haskell.org/package/show
03:32:19 <donri> is what lambdabot uses, but you don't need it in code
03:32:20 <johnw> > foldM (liftM2 (+)) (0 :: Int) [1,2,3]
03:32:20 <lambdabot>   Couldn't match expected type `m0 a20'
03:32:21 <lambdabot>              with actual type `GHC.Ty...
03:32:42 <johnw> > foldM (\x y -> (+) <$> x <*> pure y) (0 :: Int) [1,2,3]
03:32:42 <donri> :t return . (+)
03:32:43 <lambdabot> (Monad m, Num a) => a -> m (a -> a)
03:32:43 <lambdabot>   Couldn't match expected type `m0 GHC.Types.Int'
03:32:43 <lambdabot>              with actual ty...
03:33:09 <johnw> > foldM (\x y -> (+) <$> x <*> pure y) (return (0 :: Int)) [1,2,3]
03:33:10 <lambdabot>   Couldn't match type `GHC.Types.Int' with `m0 GHC.Types.Int'
03:33:10 <lambdabot>  Expected type:...
03:33:17 <johnw> hmm, must be getting tired
03:33:27 <bscarlet> :t foldM
03:33:28 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
03:33:37 <donri> :t return . (+)
03:33:38 <lambdabot> (Monad m, Num a) => a -> m (a -> a)
03:33:46 <hape01> johnw, donri: Now I understand :)
03:33:53 <donri> :t liftM2 (+)
03:33:53 <lambdabot> (Monad m, Num r) => m r -> m r -> m r
03:33:57 <johnw> > foldM ((return .) . (+)) (0 :: Int) [1,2,3]
03:33:58 <lambdabot>   No instance for (GHC.Show.Show (m0 GHC.Types.Int))
03:33:59 <lambdabot>    arising from a use of...
03:34:22 <johnw> > foldM (\x y -> return $ x + y) (0 :: Int) [1,2,3]
03:34:23 <lambdabot>   No instance for (GHC.Show.Show (m0 GHC.Types.Int))
03:34:23 <lambdabot>    arising from a use of...
03:34:26 <johnw> > foldM (\x y -> return $ x + y) (return (0 :: Int)) [1,2,3]
03:34:27 <lambdabot>   No instance for (GHC.Show.Show (m0 (m1 GHC.Types.Int)))
03:34:27 <lambdabot>    arising from a u...
03:35:23 <donri> johnw: the previous was right, but you want :t not >
03:35:32 <johnw> why not?
03:35:33 <donri> or you need a monad
03:35:36 <johnw> oh
03:35:41 <donri> :t foldM (\x y -> return $ x + y) (0 :: Int) [1,2,3]
03:35:41 <lambdabot> Monad m => m Int
03:35:49 <donri> > foldM (\x y -> return $ x + y) (0 :: Int) [1,2,3] :: Maybe Int
03:35:50 <lambdabot>   Just 6
03:36:25 <donri> @pl (\x y -> return $ x + y)
03:36:28 <lambdabot> ((return $) .) . (+)
03:36:28 <lambdabot> optimization suspended, use @pl-resume to continue.
03:36:41 <johnw> @pl (\x y -> return (x + y))
03:36:41 <lambdabot> (return .) . (+)
03:36:47 <johnw> so I had that right too up above
03:37:00 <donri> :t return .: (+)
03:37:01 <lambdabot>     Not in scope: `.:'
03:37:01 <lambdabot>     Perhaps you meant one of these:
03:37:01 <lambdabot>       `.' (imported from Data.Function),
03:37:05 <johnw> i guess I'm too used to ghci fixing m at IO
03:39:17 <hape01> originally my aim was to get the foldM analogon for  foldl (+) 0 [1,2,3] == 6   with use of foldM. But his foldM function above behaves different of... hmmm
03:40:01 <donri> > runIdentity $ foldM ((return .) . (+)) 0 [1,2,3]
03:40:02 <lambdabot>   6
03:40:09 <hape01> wow!
03:40:15 <hape01> that is it
03:40:57 <donri> Identity is the trivial monad that adds no structure
03:41:27 <hape01> where is the Identidy function in   runIdentity $ foldM ((return .) . (+)) 0 [1,2,3]   ?
03:41:34 <donri> @hoogle runIdentity
03:41:34 <lambdabot> Data.Functor.Identity runIdentity :: Identity a -> a
03:41:34 <lambdabot> Control.Monad.Trans.Identity runIdentityT :: IdentityT m a -> m a
03:41:40 <hape01> yep
03:41:41 <hape01> :-)
03:41:55 <donri> @hoogle transformers
03:41:55 <lambdabot> package transformers
03:41:55 <lambdabot> package transformers-abort
03:41:55 <lambdabot> package transformers-base
03:42:00 <donri> eh
03:42:03 <donri> @hackage transformers
03:42:03 <lambdabot> http://hackage.haskell.org/package/transformers
03:44:29 <donri> hape01: type inference says that if you apply runIdentity to a polymorphic monad computation, the monad is specialized to Identity
03:44:39 <donri> > fromJust $ foldM ((return .) . (+)) 0 [1,2,3]
03:44:40 <lambdabot>   6
03:45:45 <nh2> eis: ping
03:45:54 <eis> nh2: pong
03:46:10 <nh2> eis: I pushed a new version. Can you check if it works now?
03:46:32 <hape01> donri: sounds good, I work on this
03:46:44 <hape01> to get more understanding of this complex.
03:47:20 <eis> nh2: sure thing. where do I get it?
03:47:41 <nh2> just update SublimeHaskell
03:47:41 <eis> nh2: should I grab it from SublimeHaskell repo?
03:47:48 <eis> oh okay
03:48:03 <nh2> I'm not sure if package control immediately recognizes the push
03:48:30 <nh2> I think you can shift-ctrl-p "upgrade"
03:48:38 <nh2> hopefully it's in the list then
03:50:40 <eis> nh2: BTW, I'm getting this error (I had it with previous version): Sublime Text 2\Packages\SublimeHaskell\ModuleInspector.hs:145:12: Constructor `H.PTuple' should have 1 argument, but has been given 2 In the pattern: H.PTuple _ ns In an equation for `names': names (H.PTuple _ ns) = concatMap names ns
03:51:06 <eis> nh2: but a simple fix seems to be just remove the first argument
03:51:18 <nh2> eis: you have to upgrade to the latest haskell-src-exts
03:51:21 <eis> nh2: I think I have a different version of haskell-exts
03:51:48 <nh2> (and after the upgrade restart sublime)
03:52:17 <adnap> Is there something that can take hlint suggestions and ask you to apply them one-by-one?
03:53:36 <eis> adnap: there the HLint minor mode for emacs
03:54:45 <eis> nh2: great, it worked! thanks a lot.
03:55:53 <donri> readme for sublimehaskell says you're using ghc-mod for completing imports and LANGUAGE pragmas, but you know it can be used to complete arbitrary identifiers in scope right?
03:56:17 <hape01> adnap: if you instal ghc-mod in emacs, you can do C-c to toggle between GHC and hlint and the you can iterate through any hlint message, one by one, with next-error
03:56:23 <Cas_> @lambdabot
03:56:23 <lambdabot> Unknown command, try @list
03:56:31 <donri> (and hdevtools can do the same completions, faster)
03:56:41 <nh2> eis: welcome :)
03:57:29 <adnap> hape01: Does this method apply hlint suggestions? I don't use emacs though :/
03:57:42 <donri> nh2: ^ probably meant that for you
03:57:42 <fylwind> :t (,,)
03:57:43 <lambdabot> a -> b -> c -> (a, b, c)
03:58:13 <hape01> adnap: Oh I see, I don't know yet how to apply.   I am just reading the Hlint msgs.
03:58:55 <nh2> eis: by the way you can step through errors (and now warnings) with F4 / shift F4 (in case you have not seen)
03:59:22 <donri> adnap: http://community.haskell.org/~ndm/darcs/hlint/hlint.htm "Why aren't the suggestions automatically applied?"
04:00:33 <eis> nh2: no I have not, and I'm glad I've seen it now! :) this is awesome. I was using emacs for haskell before, but it was so much harder to get to work properly. thanks for sublimehaskell!
04:01:52 <hape01> eis: it has gotten much easier to emacs haskell since MELPA milkbox packaging and M-x package-list-packages and ghc-mod
04:02:28 <haasn> I guess the ‘re’ in ‘repa’ is from Regular? Or is ‘repa’ an acronym for something involving an ‘e’?
04:02:39 <nh2> eis: I didn't come up with it, I just joined the team :)
04:03:18 <donri> haasn: "Repa (REgular PArallel arrays)" from website
04:03:31 <haasn> ah, okay
04:03:38 <haasn> I figured REgular Parallel Arrays
04:03:46 <donri> me too, but i guess this is more consistent! :p
04:03:49 <nh2> by the way for the people who use ghc-mod / hdevtools, I've sent a PR for those so that they can check multiple files (or all of the project) at the same time. Maybe you can have a look at what the corresponding $EDITOR changes are in case you want to use that?
04:03:52 <haasn> donri: maybe that expansion should be added to the description on hackage so people don't get confused in the future :)
04:04:48 <nh2> for hdevtools this means you don't have to have one instance per file open (which eats memory) or share the socket (which discards the fast compilation)
04:05:04 <donri> nh2: i just use cabal build for that. maybe hdevtools is faster but still doing the right thing?
04:05:41 <donri> how does the socket discard fast compilation
04:07:29 <nh2> donri: yes, ghc-mod and hdevtools cannot check all projects (e.g. when file generation is involved), but for big projects where they can, hdevtools is still much faster than cabal build
04:08:11 <nh2> donri: if you share a socket and hdevtools file1.hs, then hdevtools file2.hs, and agian file1.hs, then afaik hdevtools will only always work at the speed of ghc-mod
04:08:21 <donri> nh2: i'll look at adding it as a vim compiler then
04:08:40 <nh2> because checking file2.hs unloads file1
04:09:06 <akegalj> what is proper way to load jquery to yesod page?
04:09:07 <akegalj> is adding "addScriptRemote" to defaultLayout function of "instance Yesod App" in Foundation.hs a good way?
04:09:33 <zomg> akegalj: seems reasonable to me
04:10:16 <akegalj> zomg: jquery is added on bottom of body tag, usually is in head. Is that ok? (not an html expert)
04:11:42 <zomg> akegalj: that just affects when the script will become available. Generally you can assume the loading order of scripts is the same order as they appear in the markup.
04:12:23 <donri> akegalj: in the head it means the browser first has to download the js before displaying the document IIRC
04:12:32 <zomg> Yep, that as well
04:12:33 <donri> except with <script async> and modern browsers
04:12:41 <akegalj> zomg, donry: thanks
04:40:45 <nh2> has anybody some experience with haste?
04:49:21 <nh2> donri: which ghc-mod command is used for the autocompletions as you suggested?
04:52:44 <donri> nh2: ah, looks like i'm wrong. a vim addon uses ghc-mod browse to implement this itself
04:53:24 <nh2> probably here right? https://github.com/ujihisa/neco-ghc/blob/master/autoload/necoghc.vim#L120
04:53:42 <nh2> yet how can it know what is in scope?
04:53:57 <nh2> afaik browse only gives top-level module declarations
04:54:45 <donri> nh2: that line is for qualified imports (e.g. complete `Map.[here]`) and i think the else under it is for "anything imported"
04:55:15 <donri> nh2: yeah it's not aware of lexical scope
04:56:29 <nh2> donri: I never managed to actually run ghc-mod browse. How does that work? I get things like Dummy:0:0:Error:<command line>: module is not loaded: `Hemokit' (./Hemokit.hs)
04:58:06 <donri> nh2: ghc-mod browse Control.Lens, "just works" for me
04:59:25 <nh2> donri: oh right, but that only works with installed packages, right?
04:59:40 <donri> i guess?
05:00:09 <nh2> doesn't that mean it can't autocomplete from your own imports?
05:01:43 <donri> i don't remember if it works for "other-modules" but i think you need to "cabal install" yes
05:03:31 <donri> nh2: don't these restrictions apply to import completions as well?
05:04:38 <nh2> yes but I guess it's not so important there / you import external stuff most of the time maybe
05:05:11 <nh2> SublimeHaskell has the "ModuleInspector" for completing functions from your own code: https://github.com/SublimeHaskell/SublimeHaskell/blob/master/ModuleInspector.hs We were thinking about putting it on hackage. It should be general enough for any editor
05:07:57 <donri> aha, i tend to rely on vim's keyword and tag completions etc for things like that
05:12:42 <shieX> Hello.
05:13:11 <shieX> What is Kleisly and how its usefull in haskell?
05:14:04 <byorgey> shieX: Kleisli arrows are functions of type  (a -> m b)  for some monad m
05:14:23 <shieX> :t return
05:14:23 <lambdabot> Monad m => a -> m a
05:14:40 <byorgey> shieX: the monad laws guarantee that these functions form a category, i.e. they can be composed, and there is an identity arrow   return :: a -> m a
05:14:44 <shieX> byorgey: And why its usefull while it duplicates return functionality?
05:15:23 <byorgey> shieX: the Kleisli newtype embeds monadic functions of type   a -> m b  into the Arrow class.
05:15:37 <byorgey> so it's useful for working with monadic functions in an Arrow context.
05:15:41 <shieX> Ah, so it just arrows for monads?
05:15:55 <byorgey> yes.  It's fairly specialized, you don't really see it that often.
05:16:17 <shieX> byorgey: Thank you for an exaplation.
05:16:23 <byorgey> you're welcome.
05:16:31 <satc> Suppose I have an array of Integers (C array) and On the haskell side I have a value of type `Ptr Int`. Now suppose I want to increment the first integer, the obvious way of doing this is to peek integer out, increment it and then poke it back. But doing so will create a temporary value on the haskell side as a result of peek. Is there a more direct way of working with pointers than peeking and poking?
05:17:25 <shieX> byorgey: Is cokleisli just an arrows for comonads?
05:18:31 <shieX> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Arrow-CoKleisli.html
05:18:35 <shieX> Yeah, i think so.
05:18:42 <shieX> That one was easy. :)
05:18:59 <arkeet> satc: I don't think so. not without writing any C.
05:19:33 <byorgey> shieX: yep
05:26:52 <Krakarn> can anyone help me with this excercise on arrows?
05:28:08 <Krakarn> I'm trying to implement the Arrow instance for data SP a b = Put b (SP a b) | Get (a -> SP a b)
05:28:38 <Krakarn> or rather the composition function (.)
05:29:06 <Krakarn> I've got this: s . (Put b f) = Put b $ s Cat.. f
05:29:14 <Krakarn> but it complains about the types not matching up
05:33:04 <Krakarn> nvm
05:33:27 <Krakarn> sry about my noobness
05:41:13 <nh2> satc: I could imagine you could use a ptr to Int# (or I# or so) and use ghc prim stuff?
05:41:25 * hackagebot amqp 0.5.0 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.5.0 (HolgerReinhardt)
05:42:54 <nh2> satc: also see stuff like http://ghc.haskell.org/trac/ghc/browser/ghc/compiler/utils/FastMutInt.lhs
05:43:09 <nh2> satc: 'writeFastMutInt'
05:46:37 <ibotty> hi, i'd like to convert a function to pointfree style. that works out, but i am sure there is another combinator that i am missing, that would simplify it
05:47:00 <ibotty> my function is:
05:47:01 <ibotty> f a b = g a == g b
05:47:12 <ibotty> (g :: a->b)
05:47:37 <ibotty> (f:: a -> a -> Bool)
05:48:04 <ibotty> i can pointfree that to f = (. g) . (==) . g
05:48:17 <ibotty> but isn't there a way to get rid of the second g?
05:50:05 <Kaini> ibotty (==) `on` g probably
05:50:51 <Kaini> ibotty, you find on in Data.Function
05:51:38 <ibotty> i even knew `on`. thank you.
05:53:34 <ibotty> i should work on my hoogle skills :D
05:54:32 <jmcarthur> we have comparing as a shorthand for (compare `on`), but nothing as a shorthand for ((==) `on`). i always want something for that, especially when using groupBy
05:54:44 <byorgey> 'equating'?
05:54:51 <jmcarthur> that may be a good name
05:55:51 <byorgey> > let equating = on (==) in  groupBy (equating fst) [(1,2), (1,3), (2,4), (4,7)]
05:55:55 <lambdabot>   [[(1,2),(1,3)],[(2,4)],[(4,7)]]
05:55:58 <byorgey> I like it
05:57:27 <jmcarthur> yes, i totally want that
05:57:34 <ibotty> yes. that sounds very nice
05:59:24 <simon> I just read about the ST monad. is this the preferred way to do dynamic programming in Haskell?
05:59:34 <ibotty> where should `equating` be? in what namespace?
06:00:25 <ibotty> Data.Eq, obviously
06:00:26 <ibotty> :D
06:00:58 <jmcarthur> simon: dynamic programming is often implemented just using laziness instead of explicit mutation
06:03:24 <simon> jmcarthur, you'd do that with regular immutable arrays that are initialized with some value dependent on its position?
06:03:29 <jmcarthur> simon: http://stackoverflow.com/questions/5223498/efficient-table-for-dynamic-programming-in-haskell
06:03:34 <simon> thanks.
06:03:35 <jmcarthur> simon: yeah that's about right
06:08:26 <ibotty> http://www.reddit.com/r/haskell/comments/1l01lf/proposal_add_equating_to_dataeq/
06:08:28 <ibotty> :D
06:26:30 <jmcarthur> :)
06:32:26 <akegalj_> in yesod, how to make browserId widget?  authBrowserId is ":: YesodAuth m => BrowserIdSettings -> AuthPlugin m" but i want to get widget type
06:34:25 <edwardk> part 5 is up: https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication-part-5  please ping me with any typos/egregious errors
06:39:15 <hpaste_> Kaini pasted “Strange phenomenon” at http://lpaste.net/92138
06:39:30 <Kaini> Can someone explain this behavior to me: http://lpaste.net/92138
06:39:40 <Kaini> I don't understand why op is not Ord a => a -> a -> Bool
06:43:13 <elliott> because of the monomorphism restriction + GHCi's extended defaulting
06:43:21 <elliott> if you add an explicit function parameter to op it will go away
06:43:26 <elliott> or :iset -XNoMonomorphismRestriction
06:43:30 <elliott> (or was it :seti...)
06:44:42 <jmcarthur> it's :seti
06:45:51 <Kaini> I guess I'll have to learn about this restriction. Thanks for the answer
06:46:54 <jmcarthur> Kaini: it only exists to make certain kinds of code easier to understand. there are no type safety issues with turning it off.
06:47:45 <jmcarthur> Kaini: and arguably it doesn't actually make anything easier to understand anyway, since it makes other things more confusing'
06:54:27 <pentace> Is it possible to prevent class functions from being exported?
07:03:23 <simon> when I recurse over a number from n to 0, in SML I'd use List.tabulate :: Int -> (Int -> a) -> [a]. what's the idiomatic thing to do in Haskell; map f [1..n]?
07:03:39 <simon> sorry, [n-1..0]
07:04:07 <simon> I realize [n-1..0] doesn't work for counting backwards.
07:04:14 <Nisstyre> pentace: "module Foo (YourTypeClass, method1)"
07:04:17 <simon> never mind. :)
07:04:29 <simukis_> [0, -1..n]
07:05:07 <pentace> Nisstyre: Does that mean you can even hide complete type classes?
07:05:31 <elliott> yes
07:05:41 <Nisstyre> pentace: if you do :i YourTypeClass you will see all of the methods, but if you try to use the ones that were not exported they will not be in scope
07:05:48 <jmcarthur> > let countDown n = [n,n-1..0] in countDown 10
07:05:49 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
07:05:57 <pentace> elliott: I thought that wasn't possible at all
07:06:10 <Nisstyre> pentace: you can create an instance without defining all of the class methods
07:06:17 <Nisstyre> you will get warnings though
07:06:32 <elliott> pentace: you can't hide instances, maybe that's what you're thinking of?
07:06:56 <pentace> Nisstyre: Yeah, exactly that was what GHC complained about, so I was asking :)
07:07:06 <pentace> elliott: Ah right
07:08:07 <Nisstyre> pentace: if you just put undefined as the definition then you won't get any warnings, that's a somewhat better pattern than just not implementing them
07:08:14 <jmcarthur> if you want to hide an instance you have to hide the type itself. you can do this by making a newtype, writing your instance for it instead of the underlying type, and not exposing the newtype outside your module
07:08:31 <jmcarthur> the documentation generated by haddock might still mention the newtype, but it will not be accessible
07:08:38 <Nisstyre> jmcarthur: I think he just wants to make an incomplete instance
07:08:45 <jmcarthur> (i mean it might still mention the newtype in the instance list)
07:09:32 <pentace> that was the error "`unsafeCastGObject' is not a (visible) method of class `GObjectClass'"
07:09:49 <sj4nz> Quick thought, what if you made a function "TODO = undefined" and used "TODO" instead? Since many text editors have support for searching/indexing TODOs, it'll stand out better.
07:09:59 <pentace> so the class was in scope but not the method, which was puzzling me
07:10:00 <elliott> you can't.
07:10:07 <elliott> it'd have to be tODO or _TODO or something.
07:10:11 <sj4nz> aha
07:10:38 <sj4nz> Forgot the type-naming conventions.
07:11:24 <pentace> todo foo = error $ foo ++ " is not yet implemented"
07:11:32 <jmcarthur> i normally say   error "TODO blah blah blah"
07:11:46 <jmcarthur> that is still somewhat searchable at least
07:11:47 <Nisstyre> I just write undefined >.>
07:12:02 <jmcarthur> oh i do undefined if it won't be there long
07:12:15 <jmcarthur> i do the error "TODO... thing if it will be a while
07:12:28 <Nisstyre> yeah, seems like a good idea
07:31:37 * hackagebot haste-compiler 0.2.4 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.2.4 (AntonEkblad)
07:36:37 <burp> anyone familiar with yesod? In my Handler there is a definition of a Text handlerName, which is used in homepage.hamlet as #{handlerName}, but when I define another Text test = "foobar" and want to use it as #{test} it says "Not in scope: `test'  In the result of the splice:  $(widgetFile "homepage")"
07:36:37 * hackagebot data-extra 2.4.0 - Extra utilities for working on Data.* types.  http://hackage.haskell.org/package/data-extra-2.4.0 (ChrisDone)
07:37:56 <burp> I thought I'm able to use everything in scope in the template
07:42:30 <geekosaur> burp: scope for tempate haskell is a little different from normal. make sure it's defined above all uses?
07:47:36 <b2coutts> I need a function :: String -> IO String, which takes a html URL, and returns the HTML code at that url; what's the easiest/best way of doing this?
07:47:39 <dfan> Relative Haskell newbie having trouble installing Euterpea (http://haskell.cs.yale.edu/euterpea/)
07:48:11 <dfan> I'm on Windows 7, just installed Haskell Platform 2013.2.0.0
07:48:55 <dfan> When I follow the instructions at http://haskell.cs.yale.edu/euterpea/download/ and cabal install in the source directory
07:49:24 <dfan> I get a compilation failure on ArrowWrap.hs (https://github.com/kianwilcox/haskell-music/blob/master/ArrowWrap.hs)
07:49:54 <dfan> http://lpaste.net/92140
07:50:06 <burp> geekosaur: uhm, never mind, the template was also used at some other Handler, which was missing the definition of test; I was not looking at the errors line number ;)
07:50:44 <dfan> (short version: "Couldn't match expected type `Extension' with actual type `KnownExtension'")
07:51:43 <dfan> I see that this must have something to do with Language.Haskell.Extension (looks like one needs to use EnableExtension to turn a KnownExtension into an Extension?) but other than that I'm out of my depth
08:00:33 <byorgey> dfan: that's because of recent updates to the haskell-src-exts package
08:00:57 <pentace> @pl \a b c -> a
08:00:57 <lambdabot> const . const
08:01:14 <byorgey> dfan: try   cabal install --constraint='haskell-src-exts < 1.14'
08:01:32 <dfan> I tried putting an EnableExtension on every element of that extensions list and got a little farther, but now mkPragma is barfing
08:01:48 <dfan> Trying...
08:02:02 <petapetapeta> Ralith: Can you explain to me the mixed-arity tree structure you showed yesterday? I was thinking that it would just be Data Tree x = Empty | Leaf x | Tree (x, [Tree x])
08:03:26 <byorgey> dfan: the Euterpea developers will have to update it to work with the newest haskell-src-exts, looks like it will require a bit of not-entirely-trivial reworking
08:04:21 <byorgey> and for anyone who is listening, this is exactly why developers ought to put explicit version upper bounds on their dependencies.  It creates more work for the developers and less confusion for newbies. which is exactly the way it ought to be.
08:05:03 <dfan> OK, so I shouldn't expect to bring this up to date on my end
08:05:03 <dfan> Compiling haskell-src-exts 1.13.5 in the background, will report back
08:05:05 <dfan> :)
08:05:50 <dfan> Aha, haskell-src-exts 1.14.0 is super-recent (4 days ago)
08:06:03 <byorgey> dfan: right, exactly
08:06:49 <byorgey> dfan: I knew what it was because I just updated some of my packages to work with haskell-src-exts, so that error message is very familiar =)
08:06:59 <byorgey> *to work with haskell-src-exts-1.14
08:08:59 <dfan> Hmm, same error. Do I need to explicitly tell it to use haskell-src-exts-1.13.5? Or uninstall 1.14?
08:09:43 <magicman> b2coutts: Network.HTTP.simpleHTTP from the HTTP package is fairly easy. http://hackage.haskell.org/package/HTTP . Not sure if that's the best way to do things, haven't really kept up to date with the developments (if any) in this area.
08:11:37 <magicman> b2coutts: String is a valid instance, compose with getRequest :: String -> Request String, and there's your function.
08:12:29 <dfan> Also tried "cabal install --constraint=haskell-src-exts==1.13.5", same result
08:15:31 <augur> anyone seen tekmo?
08:17:00 <zomg> augur: not in the last 24 hours no (my lastlog goes about that far at the moment)
08:17:14 <augur> :(
08:17:27 <monochrom> @seen tekmo
08:17:27 <lambdabot> 7ex/\/\O
08:17:31 <monochrom> oops
08:17:44 <monochrom> preflex: seen Tekmo
08:17:44 <preflex>  Tekmo was last seen on #haskell 1 day, 17 hours, 3 minutes and 21 seconds ago, saying: monochrom: No you don't.  The worst case scenario is you ignore parameter order and you still do no worse than tupling everything
08:18:21 <monochrom> that is approaching 2 days
08:21:37 <dfan> OK, I actually did update ArrowWrap to understand haskell-src-exts 1.14, and now I'm failing in a later place in the install. Time to give up for now, I think
08:29:13 <petapetapeta> I have a type constructor which looks like this: sum' :: (Double -> Double -> Color) -> (Double -> Double -> Color) -> Double -> Double -> Color
08:29:13 <petapetapeta> Is there anything I can do to make it more readable?
08:29:49 <mlamari> Running latest emacs/haskell, getting "Could not find module Foo, Use -v to see the list of files searched for" - for an import of my won module from an adjacent file in cabal procect.  Any idea how to backtrack this?  I don't even know which haskell support lib is generating this or if it's ghc or lint saying it (as if i don't get other errors but do if i remove the imports line)
08:31:42 <PJBoy> petapetapeta, a comment, I would suggest
08:32:53 <petapetapeta> PJBoy: I was just thinking that since (Double -> Double -> Color) occurs often in the code it might be possible to do something about it
08:33:04 <petapetapeta> But I think I will go with a comment as you suggested :)
08:35:13 <geekosaur> actually if the types are concrete you could use a type synonym
08:36:15 <geekosaur> type ToColor = Double -> Double -> Color; {- ... -} sum' :: ToColor -> ToColor -> ToColor
08:36:47 <petapetapeta> Oh that looks like something I might want :) THanks
08:36:55 <geekosaur> pretty sure that works out right given associativity
08:37:38 <PJBoy> I need to get 'round to seriously learning haskell
08:38:08 <petapetapeta> geekosaur: Yeah it does. It should increase readability a bit
08:38:11 <simon> meh, I give it a year.
08:38:20 <PJBoy> or do I, hmm
08:45:37 <dfan> Victory!
08:46:00 <mr-> dfan: congrats!
08:46:18 <dfan> I hadn't updated ArrowWrap as much as I needed to
08:48:02 <tikhon> mlamari: what exactly do you mean by adjacent file?
08:48:20 <mlamari> tikhon:  In the same Cabal project, in the same directory
08:48:29 <tikhon> oh
08:48:32 <tikhon> hmm
08:48:56 <tikhon> so you have two files like Foo.hs and Bar.hs in the same directory?
08:49:05 <tikhon> and it can't find one of those?
08:49:17 <mlamari> I guess
08:50:21 <mlamari> Switched to another machine/installation, same source (building cabal project) and module MyModule where errors out "cannot satisfy -package errors"
08:50:36 <mlamari> Inherent issue with emacs plugins - something just doesn't happen, hard to backtrack why
08:51:04 <tikhon> did you make sure to add all your modules to your .cabal file?
08:52:38 <mlamari> On one of the machines there's a problem with the dependencies; but the first one where I got the error no, the cabal will install/etc.  I don't want to conflate two issues
08:52:41 <mlamari> grr :)
08:55:30 <byorgey> dfan: \o/
08:57:14 <dfan> Updated with duct tape and string, but the nice thing about Haskell is that all you have to do is get it to pass the typechecker :) Thanks for your help
08:57:34 <monochrom> heh duct tape
09:18:18 <hvr> mlamari: did you get the "could not find module" with haskell-interactive?
09:19:50 <danilo2> Hi! I've got a question related to Unit Tests in Haskell. According to the calal docuemtation, we can use the cabal support for testing and choose an interface "it is preferred that new test suites be written for the detailed-1.0 interface". So how does this correspond to existing testing frameworks? Should I use the "detailed-1.0" interface with HUnit?
09:19:58 <elliott> no
09:20:04 <danilo2> http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/developing-packages.html#test-suites
09:20:06 <elliott> it's unfinished and the documentation is lies, AIUI.
09:20:20 <hvr> elliott: but at least there's no cake offered
09:21:07 <danilo2> elliot: this "no" was to me or hvr? :D
09:21:23 <elliott> to you
09:21:54 <danilo2> elliott: Ok, so I understand I should use HUnit with exitcode-stdio-1.0?
09:22:31 <elliott> that is my understanding, yes.
09:22:38 <elliott> I don't think anyone really uses detailed-1.0
09:23:32 <danilo2> thank you :) Its nice that here on irc are people, which could help you much more than documentation :)
09:24:21 <elliott> someone should write a patch to fix that documentation.
09:24:24 <elliott> not me, of course...
09:25:32 <danilo2> elliott: I've got one additional small question - I've written 2 small tests in HUnit and my main looks like: main = runTestTT tests. When I execute cabal like "cabal test" I got output: [...] 1 of 1 test suites (1 of 1 test cases) passed." butif I look into log I see some of the tests failed. Am I doing anything wrong?
09:26:24 <elliott> hm, not sure. perhaps the log is old? I haven't really used HUnit myself -- just have looked into the detailed-1.0 thing after seeing it myself and other people asking questions about it in the past.
09:26:51 <haasn> whoa, criterion has a lot of dependencies
09:26:58 <haasn> installing it pulls in 33 new haskell packages
09:27:04 <danilo2> elliott: No the log is ok, because one of the tests checks if 1 == 2 :)
09:27:30 <danilo2> elliott: but If you didnt used Hunit I'll try to solve it further myself :) thank you for your help! :)
09:27:36 <elliott> :)
09:36:29 <bergmark> danilo2: maybe check the exit code of the test?
09:38:02 <hiptobecubic> What is the algebraic term for "splittable" monoids, if there is one?
09:38:37 <danilo2> bergmark: I was thinking about doing this (yeah and it is even possible - I was thinking that runTestTT returns an INt but it returns a data type instance).
09:39:05 <hiptobecubic> For example   Foo c = Foo a <> Foo b   and then  (Foo d, Foo e) = split (Foo c)
09:39:35 <hiptobecubic> well actual, if all you do is <> and split and don't operate on the data inside a and b, then d and e should be identical to a and b again
09:39:35 <danilo2> Accidentaly I've found out something called HSpec: http://hspec.github.io/ What do you think about it as an replacement for HUnit tests? Does anybody tried it ?
09:39:46 <hiptobecubic> so the monoid is really just reversible i guess
09:39:46 <supki> danilo2: even if runTestTT returns Int it would not be used as exit code
09:40:08 <jmcarthur> hiptobecubic: i would be surprised if such a thing is really possible
09:40:17 <heatsink> If it's reversible, then it isn't associative
09:40:19 <jmcarthur> hiptobecubic: consider   split (a <> b <> c)
09:40:33 <danilo2> supki: I see! I have to use Systrm.Exit! :)
09:40:45 <flebron> Hi. Why is foldl' (+) 0 [1..10^6] faster than foldr (+) 0 [1..10^6]? Which thunks are not being stored?
09:40:48 <mlamari> hvr:  It's triggered from somewhere in flycheck
09:41:05 <heatsink> We should have a foldl' faq
09:41:10 <hiptobecubic> jmcarthur, well in that case i just wasn't clear when I tried to say "working on the data inside a and b". What i'm thinking of are quadtrees
09:41:36 <jmcarthur> hiptobecubic: i mean what heatsink said. it can't be a monoid is the mappend is reversible
09:41:43 <byorgey> hiptobecubic: you can't get that d and e are identical to a and b again, for the reasons others have said.  However, there is something like what you are talking about called factorization monoids, or unique factorization monoids
09:41:43 <jmcarthur> *if
09:41:51 <hiptobecubic> you can just stick four quadtrees together and get another quadtree
09:42:03 <byorgey> hiptobecubic: instead of  split :: m -> (m,m)  you have   split :: m -> [m]   which "factors" m
09:42:12 <hiptobecubic> and the way to split it up into four quadtrees again is really just the partitioning algorithm that the quadtrees are based on in the first place
09:42:14 <heatsink> flebron, the foldr call constructs the thunk (1 + (2 + (3 + ...)))
09:42:32 <elliott> hiptobecubic: but consider split (mempty <> a <> b) = (mempty, a <> b) = split (a <> b) = (a, b)
09:42:35 <jmcarthur> hiptobecubic: yeah, but there is no guarantee that you get the same result
09:42:36 <heatsink> To evaluate x + y, first x and y must be evaluated
09:42:36 <flebron> Yes, I see foldr as replacing : with f.
09:42:37 <byorgey> for example, the natural numbers under multiplication are such a monoid, where split is prime factorization
09:42:47 <hiptobecubic> byorgey, So in my case, split :: m -> (m, m, m ,m)
09:42:59 <heatsink> So it pushes all the applications onto the evaluation stack until it reaches the last two numbers
09:43:08 <heatsink> and then it starts unwinding the stack
09:43:16 <hiptobecubic> jmcarthur, well I just started thinking about this. :)  Getting the same result back is really totally immaterial in this case i think.
09:43:18 <flebron> What about foldl'?
09:43:29 <hiptobecubic> as long as you get back a set of four valid quadtrees
09:43:53 <elliott> hiptobecubic: so is the law that given split x = (a,b,c,d), then a <> b <> c <> d = x?
09:43:56 <heatsink> foldl' evaluates from the left, and it forces each application to be evaluated before going to the next list element.
09:44:03 <flebron> Oh, it does (1 + 2) + 3) + 4) ...
09:44:06 <elliott> hiptobecubic: and that none of a, b, c, d are mempty?
09:44:10 <hiptobecubic> elliott, well that implies that "a <> b" should make sense somehow
09:44:13 <hiptobecubic> i'm not claiming it should
09:44:19 <byorgey> I doubt you can get that  none of  a, b, c, d  are nonempty.
09:44:24 <byorgey> *empty
09:44:29 <jmcarthur> it could be an infinite structure
09:44:39 <flebron> Right, OK, so foldl normally would create the thunks for 1 + 2, the one for (1 + 2) + 3, etc, while foldl' evaluates it before going to the next one.
09:44:45 <elliott> perhaps m -> Maybe (m, m, m, m) and then x = mempty <-> split x = Nothing,.
09:44:45 <heatsink> yes
09:44:48 <elliott> or something.
09:44:51 <hiptobecubic> it should be more like   mappendQuad a b c d = x and split x = (e, f, g, h)
09:44:56 <elliott> anyway there is not much to say about an abstraction that you know no laws for :P
09:45:04 <byorgey> hiptobecubic: ok, well that is not a monoid anymore =)
09:45:16 <hiptobecubic> byorgey, no. I'm seeing that :)
09:45:16 <elliott> hiptobecubic: ok, but a, b, c and d and e, f, g and h are completely unrelated there, so you're not really stating anything.
09:45:28 <elliott> you might as well just say split x = (e, f, g, h)
09:45:32 <mekeor> can't i use "where" within an instance declaration like this?!: http://codepad.org/SH9DpuqP
09:45:34 <elliott> without saying anything about what x is.
09:45:45 <hiptobecubic> well they are all the same type, which is the same type as x
09:45:56 <heatsink> The frontier of computing is rife with lawless abstractions.
09:46:10 <hiptobecubic> and it should *always* be possible and should always produce valid quadtrees
09:46:24 <elliott> hiptobecubic: so your law is equivalent to the type signature split :: m -> (m, m, m, m) :P
09:46:31 <jmcarthur> so you have   quad :: (Quad, Quad, Quad, Quad) -> Quad   and   unquad :: Quad -> (Quad, Quad, Quad, Quad)... now what? :)
09:46:35 <elliott> maybe your operation can be given useful/interesting laws, but I'm not seeing them.
09:46:41 <elliott> I'd want something relating these two functions.
09:46:43 <flebron> heatsink: thanks :)
09:46:47 <hiptobecubic> and if the points in a,b,c,d haven't been modified, then e,f,g,h really should be the same as a,b,c,d right?
09:46:55 <elliott> why? take a = mempty
09:46:56 <k00mi> mekeor: the "where" probably has to be indented atleast as far as "show"
09:47:01 <supki> mekeor: no, 'where' is not shared between different clauses
09:47:05 <elliott> or do you not have associativity and identity laws for mappendQuad?
09:47:21 <Fuuzetsu> LAMMJohnson: How's your RSS reader going?
09:47:41 <hiptobecubic> well i suppose ordering of the arguments would matter, but you could say that it's preserved at least
09:47:53 <mekeor> supki: hmm, thanks you :/
09:47:53 <hiptobecubic> considing it's arbitrary which quadrant comes first
09:48:01 <Sonarpulse> I was just thinking, would it make sense to have a type family so Data.Map Int a --> Data.IntMap a
09:48:27 <elliott> Sonarpulse: IntMap is better at some things, worse at others
09:48:30 <hiptobecubic> elliott, i'm looking at this image https://en.wikipedia.org/wiki/File:Point_quadtree.svg
09:48:31 <mekeor> *thank ^^
09:48:32 <elliott> can't remember exactly what off the top of my head
09:48:36 <jmcarthur> hiptobecubic: i think it's easier to talk about plain monoids than this four-argument operation. let's say we're just using a normal monoid and this split operation.   what should  split (a <> b <> c)  return? is it  (a <> b, c)?  (a, b <> c)?  (a <> b <> c, mempty)?   (mempty, a <> b <> c)?
09:48:48 <Sonarpulse> ah ok
09:48:55 <hiptobecubic> elliott, and thinking that there should be something sensible that can be said about the way the partition/joining of groups of four behaves
09:49:07 <elliott> hiptobecubic: I agree you can join four quad trees together, and take non-leaf quad trees apart into four others.
09:49:24 <elliott> that is clear from the data type definition of one :)
09:49:46 <jmcarthur> even if you disallow mempty (you have a semigroup), you still run into the same issues with associativity
09:49:47 <hiptobecubic> elliott, well yes that conclusion is not difficult to come to :)  I'm just trying to figure out if it is a special case of something we already know
09:50:11 <jmcarthur> it would be easier to identify something we already know if it has some laws :)
09:51:39 <hiptobecubic> jmcarthur, split (a <> b <> c) doesn't make sense in this case because the input to split should be valid. you can't make a quadtree from three quadtrees, you need four.  If you were making tri-tree or something, then split (a <> b <> c) would give you (a, b, c) back
09:52:19 <jmcarthur> hiptobecubic: i was talking about monoids
09:52:26 <elliott> you could just think about binary trees.
09:52:47 <hiptobecubic> jmcarthur, then this is not associative if you want it to also be reversible. that I can follow
09:53:10 <jmcarthur> okay. we agree. i'm just looking for what you *do* expect to be true about this operations?
09:53:11 <hiptobecubic> ((a <> b) <> c) and (a <> (b <> c)) would produce a different split
09:53:34 <elliott> ok, I publicly guess that monoids of any kind are a complete red herring here
09:54:21 <jmcarthur> so far all i can see is that your type is some sort of product, and you just have injections and projections
09:54:25 <hiptobecubic> I expect it to be true that split (mappendN (a, b, ...)) = (a, b, ...) for which ever n-tuple you want to implement this for
09:54:51 <hiptobecubic> quadtree would use 4-tuple, bisection search on a line is 2-tuple, etc
09:54:52 <jmcarthur> now i'm certain that all you're describing is tuples and nothing more
09:55:16 <jmcarthur> *products
09:55:21 <hiptobecubic> ok
09:55:50 <hiptobecubic> Is there a tree structure which follows the monoid laws and is "factorizable" as i think byorgey mentioned?
09:56:04 <hiptobecubic> because "factorizable" sounds way more like what I'm imagining than "reversible"
09:56:06 <elliott> lists?
09:56:09 <hiptobecubic> reversible is too strong
09:56:16 <elliott> I would guess the prime factors of [1,2,3,4] are [[1],[2],[3],[4]]
09:56:21 <hiptobecubic> elliott, :D  yes i suppose so
09:56:39 <elliott> i.e. split = map pure
09:56:46 <hiptobecubic> right
09:57:00 <hiptobecubic> splitAt n would also work
09:57:06 <hiptobecubic> not as prime factors of course
09:57:15 <hiptobecubic> but i'm not searching for those.
09:57:27 <hiptobecubic> in fact, i'm searching for the largest possible factors i think
09:58:06 <hiptobecubic> at any rate
09:58:26 <hiptobecubic> It's clear that I haven't stumbled on anything particularly interesting
09:58:29 <hiptobecubic> thanks everyone
09:58:45 <jmcarthur> for what it's worth, i have occasionally run into join semilattices that also have operations i like to generically call "fork" such that    join . fork = id   (but not necessarily that  fork . join = id)
09:59:13 <jmcarthur> i don't know of any interesting theory about it though
09:59:17 <hvr> mlamari: oh, well, flycheck doesn't take into account the .cabal file at all
09:59:23 <hvr> (last time I checked at least)
10:00:42 <jmcarthur> hiptobecubic: perhaps you were constraining your problem such that mappend and split were inverses when in fact you only wanted to constrain it such that  uncurry mappend . split = id
10:00:52 <Sonarpulse> elliott: when is it worse? The documentation implies it's wholly better
10:01:10 <Sonarpulse> which might be a problem then
10:01:25 <elliott> <elliott> can't remember exactly what off the top of my head
10:01:31 <elliott> but anyway I think you should just use IntMap if IntMap is what you want :p
10:01:40 <shachaf> jmcarthur: fork picks some distinguished pair of elements?
10:01:45 <elliott> you can be polymorphic in the container if you want the potential for best performance
10:01:46 <hiptobecubic> jmcarthur, yes that identity should definitely be true
10:01:50 <elliott> in fact HashMap Int will usually beat IntMap I think.
10:02:29 <augur> so the fact that the monad and applicative for Reader are the same is kind of cool, i think
10:02:39 <haasn> Fuuzetsu: I imagine it would work to fallback to a ‘dumber’ highlighting algorithm for the portions / versions that can't be super-highlighted
10:03:11 <jmcarthur> shachaf: no, it in some unspecified way splits the information in the argument into two, but such that i could be recombined
10:03:13 <jmcarthur> *it could be
10:03:46 <shachaf> jmcarthur: fork x = (x,x)?
10:03:51 <hiptobecubic> so splitting is reversible, but not mappending, that makes sense i think.
10:04:08 <haasn> shachaf: comappend!
10:04:33 <Sonarpulse> Even though HashMap Int a == Intmap (Hashmap Int a) ?
10:04:45 <jmcarthur> shachaf: that would be a valid implementation
10:04:49 <Sonarpulse> * IntMap (Map Int a) ?
10:06:26 <elliott> HashMap does not use intMap
10:06:26 <shachaf> Oh, "operations", so you can have more than one. Not something associated with the semilattice directly.
10:06:55 <Sonarpulse> I guess I looked at the wrong HashMap
10:07:05 <jmcarthur> yeah there is often a class of such operations (but usually only one is used in a particular application)
10:07:42 <augur> also interesting is
10:07:57 <jmcarthur> usually it's most interesting when    uncurry (/=) . fork
10:08:11 <elliott> = const True
10:08:16 <elliott> finished your proposition for you
10:08:37 <jmcarthur> :)
10:08:42 <hiptobecubic> jmcarthur, is there a name for structures that have that property?
10:08:45 <augur> f :: m (a -> b)   gets you   \a -> f <*> pure a :: a -> m b    but not the other way around
10:08:48 <augur> and yet
10:08:51 <hiptobecubic> jmcarthur, I assume not. It seems kind of arbitrary
10:09:09 <jmcarthur> hiptobecubic: as i said earlier, i don't know of any theory about it. i have run into this pattern a few times, though.
10:09:14 <hiptobecubic> with integers, (+) as mappend and (/2) as split is an example of one
10:09:34 <hiptobecubic> well (\x -> (x/2, x/2)
10:09:36 <jmcarthur> that is not a very interesting one, i claim
10:09:46 <jmcarthur> because the two results are still the same
10:10:06 <hiptobecubic> sure, didn't say it was interesting :) It just looks like one
10:10:15 <hiptobecubic> the quadtree one is interesting i thought
10:10:24 <augur> (>>=) :: m a -> (a -> m b) -> m b    gets you    (<*>) :: m (a -> b) -> m a -> m b
10:10:36 <augur> so the special application goes in the other direction
10:10:43 <augur> i find this interesting as well :T
10:10:45 <jmcarthur> a more interesting one is a fork that takes a set and returns two disjoint sets
10:10:55 <jmcarthur> hiptobecubic: the quadtree thing is not an example of this
10:11:01 <augur> probably shouldnt, there's something subtypy going on
10:11:40 <jmcarthur> hiptobecubic: because i'm talking about semilattices
10:11:51 <jmcarthur> hiptobecubic: i think it's also less interesting if it's merely a monoid
10:12:32 <jmcarthur> augur: what's subtypy?
10:12:44 <augur> jmcarthur: subtype-y
10:12:54 <jmcarthur> but i mean what do you find subtypy about that?
10:12:57 <augur> oh
10:13:12 <augur> well, its like.. contravariance in argument positions or something like this
10:13:24 <augur> which is typical of subtype interactions with function types i think
10:13:34 <augur> like, if a <: a'
10:13:42 <augur> then a' -> b <: a -> b
10:13:44 <augur> or something like this
10:14:22 <jmcarthur> oh, it's true that variance is involved in the relationship between (>>=) and (<*>)
10:14:31 <jmcarthur> :t (=<<)
10:14:31 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:14:41 <augur> because morally, a <: a' is a -> a', so obviously, a -> a' and a' -> b gets you a -> b by composition
10:15:04 <augur> jmcarthur: yeah but more importantly, its on the a -> m b, vs m (a -> b) argument
10:15:10 <jmcarthur> right
10:15:22 <augur> m (a -> b)  <:  a -> m b
10:15:25 <jmcarthur> i think it boils down to the same thing as in fmap
10:15:28 <jmcarthur> :t fmap
10:15:29 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:15:39 <jmcarthur> it's just that all monads and applicatives are covariant functors
10:15:41 <augur> so    (a -> m b) -> m a -> m b   <:   m (a -> b) -> m a -> m b
10:16:23 <augur> no its really not about the variance of the functor m
10:16:36 <augur> its really just about ->, and how its covariant in its first arg
10:16:41 <jmcarthur> i don't see why not
10:17:06 <augur> because it doesnt depend on m, here. its just an accidental fact that i noticed this for applicatives and monads :)
10:17:37 <augur> a  <: a'   ==>   a' -> b  <:  a -> b
10:17:47 <jmcarthur> if i had join and comap i could implement  (m a -> b) -> m b -> m a
10:17:49 <augur> i merely accidentally noticed that this was specialized for applicatives and monads
10:18:04 <augur> where a = m (a -> b), a' = a -> m b, and b = m a -> m b
10:19:14 <bergmark> Is there's a function for converting a HDBC-postgresql Connection to a postgresql-simple connection somewhere?
10:20:22 <augur> hm
10:20:23 <mlamari> I've noticed that GHC.exe IS sensitive to the directory it runs from - it doesn't warn about "Could not find module" for my other file when I'm at or under the .cabal file. . . .
10:20:32 <jmcarthur> augur: but it is related to the fact that (>>=) is just join and fmap that it has that type
10:20:39 <mlamari> Is there a way to make it also detect stuff like template haskell?
10:20:40 <augur> conor makes an interesting observation that having is dual to expecting, in a certain sense
10:20:47 <jmcarthur> right
10:20:49 <augur> jmcarthur: no, you're confused about what i was saying
10:20:53 <jmcarthur> i guess :)
10:21:13 <augur> jmcarthur: all i was observing was, in a roundabout way, that -> is contravariant in its first argument
10:21:18 <jmcarthur> ah
10:21:32 <jmcarthur> i always just considered that a part of the definition
10:21:32 <augur> jmcarthur: but i noticed this via a special case -- (>>=) and (<*>)
10:22:34 <jmcarthur> the variance of the a parameter in   m (a -> b)  depends on the variance of the argument of m, though. this is what i thought you were really bringing up, since for monads that parameter is always covariant
10:22:46 <augur> but it makes me wonder now whether or not this is the core reason why these subclass-superclass relationships can exist -- because -> is contra, and the inputs are co
10:23:05 <jmcarthur> oh! you're relating variance to subtyping
10:23:10 <augur> i think it probably MUST be that, essentially
10:23:12 <jmcarthur> yes this is a thing
10:23:35 <jmcarthur> it's exactly the basis of subtyping
10:23:50 <kuribas> > tail $ scanl (flip (:)) [] [1..5]
10:23:51 <lambdabot>   [[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
10:24:02 <kuribas> Any better way to do this?
10:24:04 <augur> because to go from Sub to Super, you have to take in Super-y inputs, convert them to Sub-y inputs and use Sub-y actions to produce Super-y actions
10:24:32 <Sonarpulse> kuribas: scanl1
10:24:35 <Sonarpulse> maybe?
10:24:41 <kuribas> yes
10:25:18 <beaky> hello
10:25:36 <kuribas> > tail $ scanl1 (flip (:)) [1..5]
10:25:37 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
10:25:37 <lambdabot>  Expected type:...
10:25:38 <beaky> how do I get a list of subsequences of a sequence
10:25:40 <augur> jmcarthur: i wonder tho if there are any sub-super relationships that arent based on functions in haskell. if not, then it would seem like haskell subtype-supertype really does just reduce to contraviance of -> on the left
10:25:45 <valyagolev> > (reverse . init . tails . reverse) [1..5]
10:25:46 <lambdabot>   [[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
10:25:58 <valyagolev> not as clever though
10:26:13 <jmcarthur> augur: i don't think i'm following what you mean by subtyping in haskell
10:26:15 <bennofs> > [[x..1] | x <- [2 .. 5]]
10:26:16 <lambdabot>   [[],[],[],[]]
10:26:21 <augur> jmcarthur: with typeclasses
10:26:22 <bennofs> > [[x, pred x..1] | x <- [2 .. 5]]
10:26:23 <lambdabot>   [[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
10:26:24 <jmcarthur> ah
10:26:30 <jmcarthur> subclasses and superclasses
10:26:36 <valyagolev> > subsequences [1..5]
10:26:37 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
10:26:46 <augur> yeah but thats 14 extra characters :)
10:26:50 <beaky> wow thanks
10:26:50 <fredmorcos> hello, I just read the chapter from LYAH about functors and how (->) r is also a functor, I have a gut feeling that this is somewhat related to functions being curried in Haskell, is that true?
10:27:10 <beaky> > subsequences "foobar"
10:27:11 <lambdabot>   ["","f","o","fo","o","fo","oo","foo","b","fb","ob","fob","ob","fob","oob","...
10:27:21 <jmcarthur> fredmorcos: i don't think that is the case
10:27:31 <augur> > filterM (const [True,False]) [1..5]
10:27:32 <lambdabot>   [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1...
10:27:38 <jmcarthur> fredmorcos: fmap for ((->) r) is just composition (.)
10:27:51 <valyagolev> I don't think "functions being curried" really means anything in scientific* view of function | * - for some definitions of this word
10:28:29 <fredmorcos> mm... OK, thanks!
10:28:29 <mlamari> Flymake (haskell) runs ghc without -i, so it uses <whatever> as its directory and thus doesn't find the .cabal file.  Is there some trick to tell GHC to just look downward from the current source file until it finds one?
10:28:41 <mlamari> I recall this sort of thing working properly for other plugins
10:28:54 <Fuuzetsu> haasn: Yes, I considered that as well. I'll have to experiment with it all really. My main problem is that currently haskell-mode uses regex everywhere and it's rather incomplete. This means that any file larger than few hundred LOC becomes really, really slow to edit and most of the extension-induced syntax outright breaks the highlighting. Many cases are also not considered (a, b :: Integer, b doesn't get highlighted etc.). Instead of
10:28:55 <Fuuzetsu> slapping ever more regex on it, I think it's smarter to just roll a different system.
10:30:14 <Sonarpulse> augur: I think I was thinking about this the other day? Namely how does haskell get away with avoid the explicit variance of, let's say scala, when there can be subclasses
10:30:53 <Sonarpulse> Let's say with Cat a b, for instances other than ->
10:30:58 <augur> Sonarpulse: im not sure i follow
10:31:00 <jmcarthur> Sonarpulse: because there is no subtyping in haskell
10:31:02 <haasn> Fuuzetsu: I wonder what my vim environment uses to highlight, but it's probably pretty dumb
10:31:10 <Sonarpulse> yeah, no subtyping
10:31:19 <Sonarpulse> but what aboutu typeclass relationships?
10:31:20 <BMeph_> Types /= Classes. Done!
10:31:35 <haasn> Fuuzetsu: at the very least, it doesn't get anything “obviously wrong”, though - even if I slap on everything from unicodesyntax to kind signatures to datakinds
10:31:40 <Sonarpulse> ^ I know that
10:31:46 <Sonarpulse> * BMeph_
10:31:53 <jmcarthur> Sonarpulse: do you have a specific bit of code that you are surprised works out fine?
10:32:00 <jmcarthur> or some example you can invent?
10:32:00 <Sonarpulse> no, sorry
10:32:04 <BMeph_> Sonarpulse: You're aware of it, but do you "Know" it? ;)
10:32:11 <Sonarpulse> well I wsa thining Category
10:32:16 <Fuuzetsu> mlamari: ‘M-x cd’ and go to the directory you need. Also see https://github.com/flycheck/flycheck/issues/182 for further issues.
10:32:28 <jmcarthur> Sonarpulse: so what is a subclass of category that would surprise you?
10:32:32 <BMeph_> Are Thrists Categories? :)
10:33:02 <Sonarpulse> well what did one of you say about the varience of typeclasses?
10:33:03 <Saizan> BMeph_: they should be the free ones
10:33:32 <jmcarthur> Sonarpulse: here's an example that i think will be helpful for you.  consider:    class Functor f => Foo f where foo :: (a -> b) -> f b -> f a
10:33:42 <Sonarpulse> sure
10:33:48 <jmcarthur> Sonarpulse: you are allowed to write that class, but have fun implementing any instances for it
10:33:57 <elliott> jmcarthur: lens uses that.
10:34:12 <elliott> there is at least one useful instance
10:34:16 <mlamari> Fuuzetsu:  What did you end up doing with this?  Just M-x cd or is there something else going on?
10:34:16 <jmcarthur> Sonarpulse: apart perhaps from some Trivial type where the parameter is just a phantom
10:34:19 <Fuuzetsu> haasn: My housemate complained the other day that with some extension (DataKinds maybe?), it becomes useless because it makes a prime valid in signatures such as ‘a :: 'Foo’. haskell-mode thinks that everything in the file behind the prime is a character so it highlights it as such making it useless.
10:34:21 <jmcarthur> elliott: oh?
10:34:26 <elliott> jmcarthur: right, Proxy.
10:34:26 <jmcarthur> elliott: where the argument is not a phantom?
10:34:38 <elliott> no, it encapsulates exactly that the argument is a phantom!
10:34:39 <jmcarthur> well, okay
10:34:42 <haasn> Fuuzetsu: definitely works in vim for me
10:34:42 <jmcarthur> right
10:34:43 <elliott> because it lets you write coerce :: f a -> f b
10:34:51 <elliott> which is quite a wondrous property :)
10:35:07 <Fuuzetsu> haasn: I don't know what it's like in vim, I use emacs.
10:35:10 <elliott> we use it for setters and stuff so they fit the general mold of lens types
10:35:18 <jmcarthur> Sonarpulse: well, okay, so try to implement an instance for that where the type argument is not a phantom :)
10:35:29 <bennofs> Is there a GHC option to disable RULES ?
10:35:49 <Fuuzetsu> mlamari: Nothing, I didn't have time to look at it. Also I just realised I linked to a flycheck issue when you were asking about flymake…
10:36:12 <mlamari> Fuuzetsu:  Never mind, I had a typo, I *was* talking about flycheck (cluelessly swapped them)
10:36:48 <Sonarpulse> ok, that looks hard to implement
10:37:31 <Sonarpulse> as function may or may not be invertable
10:37:41 <hpc> quick question, how does one escape backticks in haddock?
10:37:47 <jmcarthur> invertability doesn't really play into this as far as i can tell
10:38:00 <jmcarthur> *invertibility
10:38:02 <Sonarpulse> ok
10:38:06 <Sonarpulse> yeah it's not required
10:38:09 <hpc> nvm, it's backslash
10:38:22 <Sonarpulse> but fmap . magic-invert would work, right?
10:38:44 <jmcarthur> Sonarpulse: i guess so, although it's kind of missing the point
10:39:01 <Sonarpulse> yes, I am not sure exactly what your point is, yet
10:39:04 <jmcarthur> Sonarpulse: the point is that you *could* come up with instances of that class if it didn't have the Functor constraint
10:39:13 <valyagolev> wow, Thrists are fun
10:39:42 <Sonarpulse> fmap $ const undefined ?
10:39:50 <jmcarthur> Sonarpulse: for example,  newtype Blah a b = Blah (b -> a)
10:40:11 <jmcarthur> Sonarpulse: but put that Functor constraint back and you're stuck, because now you can't write fmap for it!
10:40:13 <Fuuzetsu> hpc: You probably do not need to escape them.
10:41:49 <Sonarpulse> not sure how the functor constraint hurts
10:41:54 <jmcarthur> try it
10:42:03 <Sonarpulse> ok
10:42:15 <Sonarpulse> I'll define the whole class
10:42:21 <jmcarthur> with some thinking you can write the foo function, but you will not be able to write fmap
10:42:57 <jmcarthur> at least not such that the laws are obeyed (this rules out cheating with undefined)
10:43:25 * monochrom loves newtype Eat b = Eat (b -> Eat)
10:43:53 <valyagolev> newtype Hyper b c = H (Hyper c b -> c)
10:44:07 <jmcarthur> monochrom: that tickled my internal positivity checker even though it shouldn't have
10:44:37 <augur> i wonder if its possible to do applicative parser combinators for a chart parser
10:44:43 <beaky> > (take 5) <$> "foobar"
10:44:44 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[a0]'
10:44:44 <lambdabot>  Expected type: [[a0]]
10:44:44 <lambdabot>    ...
10:45:15 <monochrom> it's simply (take 5) "foobar"
10:45:16 <augur> probably not. applicative parsing is top down, isnt it?
10:45:24 <beaky> ah
10:45:32 <jmcarthur> augur: top-down in what sense?
10:45:44 <beaky> i want to take every possible 5 of foobar
10:45:50 <augur> jmcarthur: the decision process
10:46:23 <jmcarthur> ah, i suppose so
10:46:35 <monochrom> what is "chart" here?
10:46:37 <augur> jmcarthur: in that, it tries to parse an X, and to do that it recursively tries to parse a Y, and so on, for subunits
10:46:56 <augur> monochrom: chart parsing is this super awesome bottom up parsing technique
10:47:46 <augur> where you build on multiple parse trees simultaneously (called the chart, due to the illustrative presentation)
10:47:47 <Sonarpulse> write fmap?
10:48:04 <Sonarpulse> isn't your example a subclass of functor?
10:48:05 <jmcarthur> Sonarpulse: you have to implement Functor because i wrote Foo as a subclass of Functor
10:48:33 <beaky> @djinn [a] -> (a, [a])
10:48:33 <lambdabot> Error: Undefined type []
10:48:53 <augur> monochrom: the basic idea is like this: you have your string of tokens/subtrees ts, and you take all your rules  X -> Y Z W ...  and scan over the string looking the pattern Y Z W ...
10:48:56 <beaky> @djinn [a] -> (Maybe a, [a])
10:48:57 <bgamari> Is tekmo around?
10:48:57 <lambdabot> Error: Undefined type []
10:49:08 <Sonarpulse> wait what? Don't sub classes just rely on implementations of the superclass?
10:49:09 <jmcarthur> Sonarpulse: you should also try to come up with some existing Functor instance which is compatible with Foo and implement that
10:49:09 <bgamari> He's Tekmo on IRC as well, right?
10:49:25 <augur> monochrom: when you find it, you add to the chart a new branching node for X -> Y Z W ...
10:49:27 <jmcarthur> Sonarpulse: no. maybe this is where your question about variance comes from then
10:50:15 <jmcarthur> Sonarpulse: a subclass in Haskell simply requires/promises that all instances are also instances of its superclass
10:50:33 <augur> monochrom: except, you dont use a string of tokens/subtrees, you use the chart itself, with the bounds of each subtree demarcated on the subtree. that way you can reuse the same subtree for different parses, and you also reuse the surrounded "unaffected" subtrees
10:50:42 <jmcarthur> Sonarpulse: its methods are not required to use anything from its superclasses
10:51:10 <Sonarpulse> sure
10:52:02 <augur> monochrom: the usual visualization looks like this: https://www.cs.tcd.ie/Martin.Emms/Extraction/img4.gif
10:52:48 <jmcarthur> Sonarpulse: you asked about the interplay between variance and subclassing. this example demonstrates that even though we don't explicitly specify variance of type parameters, there is still some hidden notion of variance, and you are prevented from writing instances of subclasses that would violate it because they just don't make any sense
10:53:05 <hape01> again I have a problem with ambiguous type variables in the following, I unfort. don't find out what I could add to be monomorph. the problem is the function (a->a) which should have a instance of type  Num (a->a)
10:53:09 <hape01> ((.) (+) (+)) 10 (+20) 30
10:53:12 <hape01> > ((.) (+) (+)) 10 (+20) 30
10:53:13 <lambdabot>   No instance for (GHC.Show.Show a0)
10:53:13 <lambdabot>    arising from a use of `M651944140.sho...
10:54:04 <Sonarpulse> I guess I am missing why one might think you could write an implementation without _|_ for this
10:54:06 <jmcarthur> Sonarpulse: in particular, if f is a Functor then its argument is covariant. if f is a Foo (assume we have dropped the Functor constraint on it) then its argument is contravariant.
10:54:11 <jmcarthur> exactly
10:54:16 <edwardk> jmcarthur: what I do is use the fact that a type is both Contravariant f and a Functor f  to enable us to cast f a -> f b by round tripping through either () or Void
10:54:26 <byorgey> hape01: it doesn't seem to me the problem is ambiguity.
10:54:27 <edwardk> that is how getters work
10:54:33 <jmcarthur> edwardk: yeah. that is pretty neat
10:54:33 <edwardk> :t to
10:54:36 <byorgey> hape01: it seems to me the problem is simply that there is no Num instance for functions.
10:54:39 <edwardk> :t Control.Lens.to
10:54:45 <lambdabot> (Functor f, Conjoined p, Contravariant f) => (s -> a) -> p a (f a) -> p s (f s)
10:54:51 <monochrom> "variance and subclassing" sounds like not about Haskell type classes
10:54:59 <byorgey> hape01: what are you trying to do?  learn about point-free style?
10:55:01 <ksf> Text.XML.Cursor seems to leak impurity
10:55:22 <hape01> byorgey: that means, in this case, the could be no valid expression for that type?
10:55:30 <hape01> which I could accept :-)
10:55:44 <ksf> if I try to collect results via foo x = zip (content x) (content x) evenrything works, so it does for foo x = zip (attribute "refid" x) (attribute "refid" x), but foo x = zip (content x) (attribute "refid" x) returns no results.
10:55:47 <edwardk> replace p with (->), and squint at removing the phantom and that becomes (s -> a) -> (a -> r) -> s -> r   because      f a is just some type 'r' we don't know anything about, given that the arg is perforce phantom.
10:55:53 <hape01> I tried from scratch to experiment with function application
10:55:53 <edwardk> and thats just flip (.) with some newtype noise
10:56:00 <byorgey> hape01: no, it means that ((.) (+) (+)) 10 (+20) 30  is not well-typed, *unless* you add a Num instance for functions.  And that is probably not what you want to do.
10:56:15 <Sonarpulse> what would be a "meaningful" implementation without the Functor requirement?
10:56:17 <byorgey> hape01: in which case, it means simply that ((.) (+) (+)) 10 (+20) 30 is not well-typed.
10:56:38 <edwardk> "Conjoined" there is enough to allow us to let 'to' pass along any index on an indexed lens-like it is composed with.
10:57:18 <jmcarthur> Sonarpulse: for   newtype Blah a b = Blah (b -> a),   let foo f (Blah g) = Blah $ g . f
10:57:33 <edwardk> > myTable^@..group MyCategory . to count -- can then be used to get out the list of counts by category with tables without crazy combinators
10:57:34 <lambdabot>   Not in scope: `myTable'Not in scope: data constructor `MyCategory'Not in sc...
10:57:35 <byorgey> hape01: ((.) (+) (+)) 10 (+20) 30 =  ((+) . (+)) 10 (+20) 30 = (+) ((+) 10) (+20) 30 = ((10+) + (+20)) 30
10:57:46 <beaky> http://ideone.com/6RAjEx how do I impove my function
10:57:58 <beaky> I want to get all sequences of 3 characters
10:58:03 <byorgey> hape01: the last is nonsense, since we have no way to add two functions  (10+) and (+20)
10:58:04 <beaky> consecutive sequences*
10:58:19 <edwardk> beaky: clearly it needs more lens
10:58:29 <monochrom> haha
10:58:40 <beaky> lens? :D
10:58:47 <byorgey> edwardk: how would you do it with lens?
10:58:56 <edwardk> byorgey: i honestly have no idea ;)
10:59:00 <byorgey> hahaha
10:59:26 <edwardk> what is that doing, chunking in n element groups?
10:59:31 <beaky> yes
10:59:34 <edwardk> into integral numbers of
10:59:41 <edwardk> so any short lists are truncated?
10:59:45 <beaky> yes
11:00:07 <beaky> oops they shouldnt be truncated
11:00:08 <byorgey> edwardk: it's not splitting, it's a sliding window
11:00:27 <edwardk> ah
11:00:30 <edwardk> my bad
11:00:33 <edwardk> sliding window it is
11:00:52 <hape01> byorgey: thank you for explaining. Now I understand better :)
11:00:58 <edwardk> > map (take 3) tails "foobar"
11:00:59 <beaky> btw is hpaste.org down for everyone else? :D
11:00:59 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t0'
11:00:59 <lambdabot>              with act...
11:01:00 <byorgey> hape01: great =)
11:01:02 <edwardk> > map (take 3) (tails "foobar")
11:01:03 <lambdabot>   ["foo","oob","oba","bar","ar","r",""]
11:01:22 <byorgey> beaky: yes.  hpaste is dead, long live the new hpaste!
11:01:25 <ksf> isn't there a single xml library that just lets me take apart the data in a sane way?
11:01:26 <edwardk> hrmm that gets too much residue at the end
11:01:26 <byorgey> @paste
11:01:26 <lambdabot> Haskell pastebin: http://lpaste.net/
11:01:30 <byorgey> beaky: ^^^
11:01:33 <beaky> oh wow
11:02:13 <byorgey> edwardk: clearly this is not a valid traversal so I don't know if it even makes sense to do this with lens.
11:02:42 <edwardk> > filter (\n -> length n == 3) (take 3 <$> tails "foobar")
11:02:43 <lambdabot>   ["foo","oob","oba","bar"]
11:02:56 <edwardk> well, we have folds ;)
11:03:03 <byorgey> true =)
11:03:13 <edwardk> :t folding
11:03:19 <beaky> http://www.markhneedham.com/blog/2012/02/28/haskell-creating-a-sliding-window-over-a-collection/
11:03:20 <edwardk> :t folding tails
11:03:21 <lambdabot> (Applicative g, Contravariant g) => LensLike g [a] t [a] b
11:03:35 <edwardk> :t "foobar"^..folding tails
11:03:36 <lambdabot> [[Char]]
11:04:11 <edwardk> :t "foobar"^..folding tails.to (take 3).filtered (\n -> length n == 3)
11:04:11 <lambdabot> [[Char]]
11:04:14 <edwardk> > "foobar"^..folding tails.to (take 3).filtered (\n -> length n == 3)
11:04:16 <lambdabot>   ["foo","oob","oba","bar"]
11:04:50 <edwardk> thats kinda cheap though and doesn't get any benefit from the lensiness
11:05:01 <beaky> wow so it can be done with lens
11:05:09 <edwardk> everything can be done with lens
11:05:29 <edwardk> now, it can't be done very _well_ with lens ;)
11:05:31 <danharaj> edwardk: part V is my favorite part yet
11:05:35 <edwardk> danharaj: heh
11:05:36 <nooodl> @src splitAt
11:05:36 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
11:05:38 <edwardk> the bootstrapping?
11:05:41 <danharaj> yes
11:05:48 <nooodl> ^ is that really how it's implemented? that seems needlessly inefficient :/
11:05:53 <danharaj> The connection to Cofree was delightful :P
11:05:56 <edwardk> i figured it showcased a nice general purpose functional programming technique
11:06:03 <danharaj> I haven't read Okasaki's book since long before I groked comonads.
11:06:14 <edwardk> and yes, bootstrapping as cofree is something i've long held in reserve to throw in a post ;)
11:06:26 <ksf> nooodl, http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#splitAt
11:06:30 <Sonarpulse> ok, thanks jmcarthur
11:06:32 <beaky> so hpaste is gone for good :(
11:06:44 <danharaj> hpaste is dead. long live lpaste.
11:06:46 <mr-> beaky: yeah, it's called lpaste now
11:06:57 <Sonarpulse> I'll continue thinking about it
11:07:22 <jmcarthur> > let dropEnd n xs = drop n $ zipWith const (replicate n undefined ++ xs) (reverse xs) in dropEnd 3 . map (take 3) $ tails "foobar"
11:07:23 <lambdabot>   ["foo","oob","oba","bar"]
11:07:25 <bennofs> Hmm, using -fno-enable-rewrite-rules fixes my bug
11:07:43 <jmcarthur> why did i use reverse...
11:07:50 <jmcarthur> > let dropEnd n xs = drop n $ zipWith const (replicate n undefined ++ xs) xs in dropEnd 3 . map (take 3) $ tails "foobar"
11:07:51 <lambdabot>   ["foo","oob","oba","bar"]
11:08:00 <jmcarthur> it was an artifact of some other code i modified
11:08:18 <bennofs> > permutations "foobar"
11:08:19 <lambdabot>   ["foobar","ofobar","oofbar","oofbar","ofobar","foobar","boofar","obofar","o...
11:08:27 <bennofs> Oh, this is different :P
11:09:03 <bennofs> Is there a way to disable individual rewrite rules in GHC?
11:09:05 <Guest49713> I'm trying to implement a solver for algebraic equations, and I was wondering if I have an equation data type, I can specify a type signature of , for example, Quadratic -> Solution ?
11:09:43 <BMeph_> Does someone have an operator form for repeated composition (or application, for that matter)?
11:09:55 <jmcarthur> > let sequencesOf3 xs = zipWith3 (,,) xs (tail xs) (tail (tail xs))
11:09:56 <lambdabot>   not an expression: `let sequencesOf3 xs = zipWith3 (,,) xs (tail xs) (tail ...
11:10:06 <edwardk> hrmm
11:10:11 <jmcarthur> > let sequencesOf3 xs = zipWith3 (,,) xs (tail xs) (tail (tail xs)) in sequencesOf3 "foobar"
11:10:12 <edwardk> let me modify jmcarthur's version
11:10:12 <lambdabot>   [('f','o','o'),('o','o','b'),('o','b','a'),('b','a','r')]
11:10:18 <edwardk> > "foobar"^..backwards (dropping 3 (backwards (folding tails).to (take 3)))
11:10:19 <lambdabot>   ["foo","oob","oba","bar"]
11:10:33 <jmcarthur> does backwards reverse the list?
11:10:41 <edwardk> > "foobar"^..backwards (dropping 3 (backwards (folding tails))).to (take 3)
11:10:42 <lambdabot>   ["foo","oob","oba","bar"]
11:10:53 <edwardk> backwards does the traversal in the opposite order by changing out the applicative
11:10:58 <arnsholt> edwardk: That looks way too much like Lisp =)
11:11:17 <edwardk> arnsholt: i'm usually parenthesis-phobic too =)
11:11:25 <jmcarthur> edwardk: if you use it twice is it still lazy?
11:11:31 <jmcarthur> mine was lazy
11:11:31 <edwardk> yep
11:11:34 <jmcarthur> that's cool
11:11:58 <jmcarthur> > [1..]^..backwards (dropping 3 (backwards (folding tails).to (take 3)))
11:12:00 <lambdabot>   *Exception: stack overflow
11:12:03 <jmcarthur> :(
11:12:04 <edwardk> oh, hrmm
11:12:13 <edwardk> its not the super-lazy version you can get
11:12:55 <Ralith> petapetapeta: you around?
11:12:56 <edwardk> clearly we need a droppingRight  ;)
11:13:20 <edwardk> it'd annoyingly need to traverse twice though
11:13:57 <bennofs> Is there any way to disable individual rewrite rules in GHC?
11:17:27 <edwardk> #ifdef's around them, clearly ;)
11:17:56 * BMeph_ prefers "not . null. drop (pred 3)" to "\n -> length n == 3", since the prior "take 3" guarantees the subs will already be length 3 or less.
11:18:33 * BMeph_ would prefer if "not . null..." were shorter to write, but "full = not . null" helps with that.
11:21:09 <petapetapeta> Ralith: On my way out to an appointment in the city :/
11:21:21 <Ralith> petapetapeta: no worries
11:21:41 <edwardk> > "foobar"^..backwards (indexing (backwards (folding tails))).to (take 3).indices (>=3)
11:21:42 <lambdabot>   Couldn't match expected type `(a0
11:21:43 <lambdabot>                                 -> Contro...
11:22:07 <edwardk> > "foobar"^..backwards (indexing (backwards (folding tails))).to (take 3).Lens.indices (>=3)
11:22:09 <lambdabot>   ["foo","oob","oba","bar"]
11:22:31 <edwardk> that assigns the indices for the indivudal positions in the fold right to left
11:22:40 <edwardk> er individual
11:22:46 <edwardk> then we can filter by that
11:23:14 <edwardk> still not as good as jmcarthur's continuous extension to infinity
11:26:17 <edwardk> > zipWith const (tails "foobar") (drop 2 "foobar")^..folded.to (take 3)
11:26:19 <lambdabot>   ["foo","oob","oba","bar"]
11:26:35 <jmcarthur> it's interesting that a lot of super-lazy list algorithms are in the pointer-chasing class
11:26:38 <edwardk> > (\x -> zipWith const (tails x) (drop 2 x)^..folded.to (take 3)) [1..]
11:26:40 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
11:26:42 <edwardk> yeah
11:27:14 <edwardk> > [1..]^..folding (\x -> zipWith const (tails x) (drop 2 x)).to (take 3))
11:27:15 <lambdabot>   <hint>:1:71: parse error on input `)'
11:27:18 <edwardk> > [1..]^..folding (\x -> zipWith const (tails x) (drop 2 x)).to (take 3)
11:27:20 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
11:27:27 <edwardk> still cheap
11:27:39 <jmcarthur> that's pretty nice there
11:28:04 <edwardk> @pl \x -> zipWith const (tails x) (drop 2 x)
11:28:04 <lambdabot> ap (zipWith const . tails) (drop 2)
11:28:28 <edwardk> > [1..]^..folding (zipWith const . tails <*> drop 2).to (take 3)
11:28:29 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
11:29:11 <edwardk> that is the best continuous extension i have that uses lens i think
11:29:16 <Dobias> Hi, I am trying to install UHC but I have the following problem: http://codepad.org/aFBTFreQ If would be very nice if someone could have a look at it. :)
11:29:43 <jmcarthur> Dobias: looks like you need to add ~/.cabal/bin to your PATH
11:29:44 <BMeph_> @pl \n -> folding (zipWith const . tails <*> drop (pred n)).to (take n)
11:29:44 <lambdabot> (line 1, column 42):
11:29:44 <lambdabot> unexpected "d"
11:29:44 <lambdabot> expecting space
11:29:44 <lambdabot> ambiguous use of a left associative operator
11:30:30 * BMeph_ cries
11:30:53 <jmcarthur> :t \n -> folding (zipWith const . tails <*> drop (pred n)).to (take n)
11:30:54 <lambdabot> (Applicative f, Contravariant f) => Int -> ([b] -> f [b]) -> [b] -> f t
11:31:50 <Dobias> @jmcarthur: After PATH="$PATH:$~/.cabal/bin" the errors of ./configure are still the same.
11:31:50 <lambdabot> Unknown command, try @list
11:32:10 <jmcarthur> Dobias: isn't that second dollar sign unnecessary?
11:32:37 <geekosaur> also did you export?
11:32:55 <geekosaur> also don't use ~ in the middle of a shellword like that. use $HOME
11:33:04 <Dobias> @jmcarthur: PATH="$PATH:~/.cabal/bin" did also not help.
11:33:04 <lambdabot> Unknown command, try @list
11:33:17 * geekosaur repeats
11:33:18 <jmcarthur> Dobias: do what geekosaur said. also, don't use @ on irc ;)
11:33:37 <Dobias> jmcarthur: ok
11:33:57 <Dobias> geekosaur: thanks, after PATH="$PATH:$HOME/.cabal/bin" it works. :)
11:34:03 <Dobias> jmcarthur: thank you too. :)
11:34:42 <geekosaur> ~ is strange and inconsistent, although convenient. it's only understood by shells and it's only understood by them at the beginning of "words".
11:34:50 <geekosaur> and when not quote
11:34:52 <geekosaur> d
11:35:12 <Dobias> oh, I didn't know that.
11:35:53 <zomg> ~ is a part of the shell expansions
11:36:25 <zomg> though I guess you could say so are environment variables so it's a bit funny ones work but others don't =)
11:36:41 <geekosaur> I described it above
11:36:48 <geekosaur> start of a shell word only and not quoted
11:36:52 <zomg> Yeah
11:37:31 <geekosaur> shell words are things separated by characters designated in $IFS, normally space, tab, and newline
11:37:53 <geekosaur> notably, not colons. bash usually (but not always!) expands it after = as well
11:37:59 <geekosaur> but not after colons
11:38:06 <jmcarthur> ~ normally works in paths, at least it always has for me
11:38:28 <jmcarthur> although i not that my path doesn't have any right now
11:38:30 <jmcarthur> *note
11:38:34 <geekosaur> and just to make things more interesting, if bash is using $PATH then it will internally expand ~ in $PATH --- but other programs will not
11:38:38 <valyagolev> is there something like :print or :force, but force until one constructor or something like, not everything/
11:39:07 <geekosaur> the rules are complex and seemingly designed to bite people
11:39:28 <jmcarthur> valyagolev: that's the default unless there are strict fields in the constructor
11:39:41 <valyagolev> unfortunately ghc-vis just won't work for me:'(
11:39:57 <jmcarthur> valyagolev: oh, :force does it deeply
11:40:06 <jmcarthur> valyagolev: i guess you could use Control.Exception.evaluate
11:43:28 <hpaste_> valyagolev pasted “No title” at http://lpaste.net/2118864257977155584
11:44:16 <valyagolev> just hangs. but maybe lists are bad example, I'll try it on the thing I needed it for… btw any ideas on the lexical error in the beginning? it's there every time I run ghci
11:45:27 <valyagolev> yeah, that worked
11:46:19 <geekosaur> re the error, do you have a .ghci file?
11:47:34 <valyagolev> yeah… hm. I removed a hoogle string from there (it had something that shows like ^@ in vim) and it worked
11:47:57 <geekosaur> yeh, that's a locale issue
11:49:22 <valyagolev> thank you
11:56:36 <NemesisD> for some reason after installing cabal from github recently im getting an error on every package install "unrecognized option `--sysconfdir=/home/michael/.cabal/etc'"
11:56:53 * hackagebot network-multicast 0.0.8 - Simple multicast library  http://hackage.haskell.org/package/network-multicast-0.0.8 (AudreyTang)
11:56:55 * hackagebot acme-microwave 0.1.0.0 - The eighth wonder of the world, kitchen math!  http://hackage.haskell.org/package/acme-microwave-0.1.0.0 (JoeQuinn)
11:59:05 <monochrom> hrm, on a microwave, 60 is the same as 100?
11:59:14 <hpc> monochrom: 0:60 vs 1:00
11:59:15 <byorgey> yes
11:59:29 <monochrom> yikes
11:59:35 <zomg> I'm disappointed that acme-microwave appears to have no source at least on hackage
11:59:39 <zomg> at least acme-php had some!
11:59:43 <hpc> zomg: the docs are run as a batch
11:59:55 <hpc> it will  not only have source, but haddock too!
12:00:52 <hpc> i have finally learned that rare haskell skill, typing "-- |" in a source file
12:02:05 <valyagolev> I remember reading about a boy who was learning fractions, and he deduced some weird method of division which worked often enough to not be confusing
12:02:18 <byorgey> ah, Joe Quinn = headprogrammingczar@gmail = hpc ?
12:02:27 <monochrom> yikes
12:02:28 <NemesisD> i pretty much can't work on haskell stuff until i figure this out :(
12:02:40 <valyagolev> something like striking out similar digits from divisor and enumerator
12:02:54 <bennofs> Is it possible to compile GHC core?
12:02:59 <byorgey> NemesisD: why did you install cabal from github?
12:03:16 <NemesisD> byorgey: because i rely on the sandbox features
12:03:32 * monochrom coldly says: gain some, lose some
12:03:33 <NemesisD> i'm not sure which executable its giving --sysconfdir to
12:03:38 <jmcarthur> there's cabal-dev for that until cabal-install is released that supports it
12:04:13 <byorgey> NemesisD: well, have you filed a ticket on the cabal bug tracker?
12:04:20 <NemesisD> that was my next step
12:04:28 <NemesisD> i don't really have much interest in going back to cabal-dev
12:04:59 <NemesisD> also there are 492 issues on cabal D:
12:05:15 <NemesisD> oh wait nm, i think that's for all time
12:05:43 <bennofs> All-time and temporary issues :p
12:05:46 <flebron> Say I want to write an array in my code. Is the best way to use listArray and pass it a list?
12:06:03 <flebron> (That is, this is a fixed, hardcoded array, known at compile time. I want to embed it in my source code.)
12:06:27 <byorgey> flebron: yes
12:06:32 <flebron> Thanks :)
12:06:48 <bennofs> Why does my bug go away when I add trace statements?  :|
12:07:06 <NemesisD> i may have had a stale dist dir when building it
12:08:29 <haasn> mm_freak/ocharles: I've decided to attempt creating an engine for VNs (visual novels) using netwire; in case you'd be interested in contributing
12:11:01 <zomg> Isn't that just an euphemism for porn game?
12:11:01 <zomg> err
12:11:23 <haasn> zomg: no, that's ‘eroge’
12:11:57 <valyagolev> how do you edit a wiki page on haskell org?
12:11:59 <zomg> Maybe it's just that I've never seen a VN-like game that wasn't one of those :p
12:12:10 <valyagolev> I want to add cabal install alex and cabal install happy to Gtk2Hs/mac
12:12:45 <monochrom> that doesn't sound right
12:13:12 <valyagolev> monochrom, this is for me? hmm that does for me
12:13:50 <haasn> zomg: neither have I! But I've only seen one, so
12:14:06 <valyagolev> e.g. i do cabal install gtk2hs-buildtools and it says "The program happy is required but it could not be found."
12:14:11 <valyagolev> so I just install it :|
12:14:23 <zomg> haasn: thus going back to being euphemism for eroge ;)
12:14:26 <valyagolev> no idea why wouldn't cabal install it for me instead of complaining
12:15:58 <BMeph_> valyagolev: Because, it doesn't know which package it's in. It could guess it's in the 'happy' package, but everything may not have that as a convention. :)
12:16:16 <NemesisD> how do you nuke all your ghc packages and start clean again?
12:16:26 <monochrom> I just doubt that gtk2hs-buildtools uses happy or alex at all
12:16:49 <monochrom> NemesisD: see my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
12:17:28 <monochrom> in fact, see the whole thing
12:18:28 <valyagolev> BMeph_ well, can't it be specified in gtk2hs-buildtools as a dependency?
12:18:43 <valyagolev> monochrom, I'm not lying to you ;-)
12:18:58 <monochrom> hpc: hackage has a build failure log for acme-microwave
12:19:25 <monochrom> because of base=4.5.*
12:19:50 <valyagolev> yarrr! got gtk/ghc-vis working on my mac (after a biiig reinstall)
12:21:36 <valyagolev> no, I didn't. got a segfault
12:21:51 <hpc> monochrom: :( that's what cabal inferred
12:22:12 <monochrom> do not trust cabal
12:22:35 <bennofs> How can I enable a ghc option depending on the version of GHC itself with cabal=
12:22:37 <bennofs> ?
12:24:34 <Zenol> @pl concat.mapM
12:24:55 <lambdabot> join . mapM
12:25:17 <NemesisD> man. yep. even after clearing out my packages and cabal dir its still hosed. annoyingly, there's a commit in there from a day ago that's supposed to have fixed this
12:26:44 <byorgey> NemesisD: this is not annoying, this is awesome.  You are helpgin find bugs in cabal-install just before a release!
12:26:48 <byorgey> *helping
12:26:54 * hackagebot sparser 0.6 - Lightweight parsing library based on partial functions.  http://hackage.haskell.org/package/sparser-0.6 (HansHoglund)
12:26:56 * hackagebot acme-microwave 0.1.0.1 - The eighth wonder of the world, kitchen math!  http://hackage.haskell.org/package/acme-microwave-0.1.0.1 (JoeQuinn)
12:27:04 <NemesisD> i thought i could remove the option from the config but its already there
12:27:08 <NemesisD> erm already commented
12:27:08 <valyagolev> don't we all love to help find bugs in package managers
12:27:38 <zomg> hpc: I think you should integrate hs-language-php into acme-php
12:27:47 <byorgey> valyagolev: if you are building the bleeding-edge version from github instead of waiting for a release, then yes.
12:28:05 <NemesisD> byorgey: should i comment on the closed ticket or start a new one?
12:28:28 <byorgey> NemesisD: you should comment on/repoen the closed ticket.  That way all the context is already there for anyone looking at it.
12:35:48 <NemesisD> byorgey: well i don't have the authority, but I'm assuming theyll get a notification from that comment
12:36:54 * hackagebot sparser 0.6.1 - Lightweight parsing library based on partial functions.  http://hackage.haskell.org/package/sparser-0.6.1 (HansHoglund)
12:37:48 <valyagolev> I think I'll reinstall mac os to get ghc-vis running
12:37:58 <valyagolev> or write an HTML backend for it
12:39:47 <monochrom> installing linux in a virtual machine may be cheaper than installing mac os
12:41:25 <valyagolev> I thought about it but wanted to work natively, don't really want to run a VM every time
12:41:44 <valyagolev> another idea it to brew remove even more stuff and install it again
12:42:22 <emurillo510> i just scrapped my windows partition yesterday, linux works great if all your hardware supports it out of the box
12:42:33 <NemesisD> oh that reminds me of something else i needed some help on. i'm trying to set up a build environment in a VM to produce a binary for production. for some reason I was having trouble compiling the mysql package
12:43:07 <NemesisD> gonna try to find the error
12:45:47 <NemesisD> ah yes it was https://raw.github.com/bos/mysql/master/Setup.lhs it was choking on findProgramLocation's type being IO (Maybe FilePath) and not soemthingelse -> IO (Maybe FilePath)
12:50:14 <paulherman> how can I prove that pair (f, g) . h = pair (f .h, g . h) where pair :: (a -> b, a -> c) a -> (b, c); pair (f, g) x = (f x, g x)?
12:50:49 <scshunt> paulherman: try expanding it out
12:51:32 <paulherman> scshunt: I'd get (f, g) . h but I'm not sure about composing a tuple to a function
12:51:57 <monochrom> consider proving instead: for all x: (pair(f,g).h) x = pair(f.h, g.h) x
12:52:53 <elliott> pair (f, g) . h is not pair ((f, g) . h)
12:52:56 <elliott> it is (pair (f, g)) . h
12:53:06 <elliott> in general, function application binds tighter than anything but record syntax.
12:53:37 * haasn .oO( record syntax? what's that? )
12:53:51 <elliott> part of the Haskell Report.
12:54:33 <monochrom> it means "f v{x=2}" = f (v{x=2}) not (f v){x=2}
12:54:49 <monochrom> it also means:
12:54:57 <paulherman> msg elliott I'd get (f, g) . h which I do not know how to solve
12:55:21 <monochrom> "f Just{} = True" is valid
12:56:11 <elliott> paulherman: you'll never get (f, g) . h reducing ((pair (f, g)) . h)
12:56:34 <elliott> I agree with monochrom's restatement of the problem being easier to work with, though.
12:56:38 <elliott> you can dispense of (.) immediately there
12:57:25 <monochrom> in fact, at this level, there is no other way. it is not like pair is axiomatized category-theoretically
12:57:59 <paulherman> so there is no point-free proof for this?
12:58:33 <monochrom> pointfree definition begets pointfree proof. pointful definition begets pointful proof.
12:58:40 <elliott> paulherman: a proof of (f = g) where (f, g :: a -> b) is a proof that (forall x. f x = g x) by functional extensionality.
12:58:53 <monochrom> "pair (f,g) x = ..." is clearly pointful
12:58:54 <elliott> you can prove it without the restatement if you want, but since the restatement implies the original proposition, why bother?
12:58:58 <elliott> you'll just end up with more lambdas
12:59:22 <paulherman> all right, I'll do it that way, thanks both for the answers
13:02:14 <pentace> In gtk2hs' TreeModel functions, why do you need to pass both TreePath and TreeIter values?
13:03:45 <valyagolev> can you show me a module with debugging functions? right now I want to stick something that would return something similar to what ":print" shows in trace
13:05:16 <kuribas> Is there a shortcut for "iterate f a !! n"?
13:09:31 <bennofs> @ty iterate
13:09:32 <lambdabot> (a -> a) -> a -> [a]
13:10:23 <bennofs> > foldl' (.) id (replicate 3 (+4)) 2
13:10:24 <lambdabot>   14
13:13:55 <Taneb> Is ChrisDone ever on IRC?
13:14:18 <Clint> yes
13:14:27 <Taneb> What nick does he use?
13:14:55 <bennofs> preflex: seen chrisdone
13:14:55 <preflex>  chrisdone was last seen on #haskell 6 days, 22 hours, 1 minute and 52 seconds ago, saying: madjestic: if you use the interactivve  mode you can use M-. with emacs tags
13:15:10 <Taneb> Bah
13:16:24 <aristid> Taneb: you have never seen chrisdone?!
13:16:38 <Taneb> aristid, I have a very bad memory for people, I'm afraid
13:16:41 <Taneb> I'm sure I had
13:16:46 <Taneb> But not quite sure enough
13:17:06 <aristid> Taneb: you probably have :)
13:17:45 <aristid> Taneb: and now that i tell you what you should believe, surely you have a vague feeling of remembering, because such is the power of suggestion :P
13:23:01 <tfero> hi all!
13:23:24 <tfero> I'm just starting to learn about haskell.
13:23:30 <joelteon> good
13:23:40 <tfero> And would like to ask you about the IO monad and the monad laws.
13:23:51 <tfero> especially right identity
13:24:51 <tfero> if I have a random source, that's producing different values on each call,
13:25:14 <tfero> wouldn't right identity say, that it has to produce the same value?
13:25:53 <joelteon> no
13:25:57 <joelteon> why would you say that?
13:26:23 <tfero> right id as I understand it is:
13:26:39 <joelteon> m >>= return = m
13:27:20 <tfero> right, sorry was looking for the notation
13:27:26 <joelteon> eh, close enough
13:27:57 <tfero> so, say m is the random generator
13:28:12 <joelteon> ok
13:28:53 <tfero> doesn't this imply that the two evaluations of m (on the left and the right side of the equality) must produce the same value?
13:29:08 <kuribas> no
13:29:15 <joelteon> you're not evaluating m twice in that situation
13:29:28 <joelteon> err, executing
13:29:40 <kuribas> tfero: It doesn't say anything about evaluating it.
13:29:44 <joelteon> the nomenclature for IO actions is kind of a PITA
13:30:11 <kuribas> tfero: An IO action and it's execution are not the same thing.
13:31:06 <joelteon> if m is an action that, when executed, produces a 3 in the IO monad, binding return to it won't change the fact that it produces 3
13:31:08 <kuribas> tfero: Think of an IO action more as a description of an action.
13:31:32 <tfero> processing
13:32:15 <monochrom> it is more like this. at 2012 January 1st noon, you ran "m >>= return", you got 4. now you use a time machine, go back to 2012 January 1st noon same place, but you change history, you run "m" instead, you still get 4
13:32:47 <exFalso1> hi, what can be the cause of waitForProcess from System.Process hanging even after the spawned process exits?
13:33:44 <monochrom> solar flares
13:33:58 <exFalso1> thats what i was afraid of
13:34:08 <geekosaur> did it actually exit?
13:34:18 <exFalso1> yes
13:34:39 <monochrom> more honestly, until I reproduce the phenomenon, I have insufficient information for a meaningful answer
13:34:54 <exFalso1> i know what happened
13:35:00 <exFalso1> i redirected its stdout
13:35:17 <exFalso1> and waited for the process before reading the handle
13:35:21 <exFalso1> can that be the problem?
13:35:27 <joelteon> that could be a problem
13:36:02 <monochrom> then the process may be unable to exit
13:36:16 <exFalso1> hmm nope still hangs
13:36:27 <kuribas> tfero: You can see it like this: only main is able to see what effect an IO action has.
13:36:56 * hackagebot bitset 1.4.7 - A space-efficient set data structure.  http://hackage.haskell.org/package/bitset-1.4.7 (SergeiLebedev)
13:37:17 <kuribas> And it can transfer that information via monads.
13:37:34 <geekosaur> it shouldn't be a problem unless the process is blocking on a full pipe in which case you must read from the pipe first (preferably in a separate thread)
13:37:57 <geekosaur> note that the process will not exit in that case until it can finish writing
13:38:03 <exFalso1> hmm if i print the contents before waiting it works
13:38:16 <exFalso1> which means some lazy io is in action somewhere
13:38:16 <joelteon> probably because of lazy IO
13:38:18 <joelteon> yeah
13:38:25 <joelteon> :t evaluate
13:38:26 <lambdabot> a -> IO a
13:38:34 <exFalso1> i'll try thanks
13:38:58 <geekosaur> no.
13:39:09 <joelteon> did i give the wrong instructions
13:39:10 <geekosaur> lazy I/O would mean that you read after and there's nothing returned
13:39:28 <exFalso1> it worked
13:39:38 <joelteon> ok, there you go
13:39:44 <exFalso1> ty!
13:40:11 <geekosaur> if reading before waiting worked then the reason is it's returning mroe data than fits in a pipe buffer, and blocks (therefore can't exit, therefore waitpid() will block)
13:40:57 <tfero> ok, maybe I need a more concrete example:
13:41:13 <tfero> e.g. next in the stdlib
13:41:56 <tfero> it carries around a state with it,
13:42:22 <tfero> but if I want to use a hw rng, it has no state that the haskell runtime knows about
13:42:28 <exFalso1> geekosaur: no, it didnt matter which way i put reading/waiting it always blocked. If i first read, then printed it,then waited it worked which meant i had to force the lazy io'd stream
13:43:12 <tfero> so is it possible at all to represent such a device? As the time travel mentioned earlier becomes impossible
13:43:40 <kuribas> tfero: Yes, but it must be in the IO monad.
13:44:05 <tfero> ok, let's say the manufacturer releases a haskell lib for the device
13:44:10 <tfero> how would that work?
13:44:36 <tfero> with a single function, that would return IO Bool
13:44:45 <tfero> (if thats a meaningful interface at all)
13:44:57 <joelteon> like kuribas said, IO actions are more like descriptions
13:45:17 <joelteon> the function is like a "thing" that says "Ok, when this is executed, do these things to get a Bool"
13:45:24 <joelteon> if you >>= return onto that, you're adding
13:45:30 <joelteon> "Then take it out of the IO monad and immediately put it back in"
13:45:45 <kuribas> tfero: you could have for example "readRng :: IO Int"
13:46:47 <kuribas> tfero: That's not the same as "IO -> Int".
13:47:03 <kuribas> The result of the RNG stays in the IO monad.
13:47:04 <tfero> in this case, would it be the library's responsibility to store every bit returned
13:47:09 <tfero> ?
13:47:31 <tfero> and identify each call to "readRng" and return the same bits?
13:47:59 <kuribas> tfero: No, because you don't need to return the same value in the IO Monad.
13:48:59 <tfero> using you example:
13:49:10 <tfero> (readRng >>= return) = readRng
13:49:11 <tfero> ?
13:49:14 <joelteon> yeah
13:49:48 <tfero> this is what wrecks my head, I see two "calls" to readRng, which in my mind may return different values
13:50:32 <elliott> just talking about readRng doesn't do anything.
13:50:38 <hiptobecubic> readRng is not a call
13:50:39 <elliott> it represents the *idea* of reading something from the RNG.
13:51:06 <elliott> the statement says: getting a value from readRng, and then returning it, is the same as just using readRng directly.
13:51:17 <augur> infact, m >>= return == m
13:51:21 <elliott> in fact, that = isn't even on the level of Haskell.
13:51:23 <augur> not just readRng, tfero
13:51:29 <joelteon> augur: that's the whole point of this discussion
13:51:33 <augur> o
13:51:34 <joelteon> why that's a law
13:51:35 <augur> :D
13:51:37 <elliott> what it's saying is that if you ever see readRng, you can replace it with (readRng >>= return) in your code, and vice versa, and it won't change.
13:51:42 <hiptobecubic> tfero, you have to break the mental model you have that the left and right side of the = are first evaluated and then compared assigned
13:51:43 <elliott> because they mean the same thing.
13:51:46 <augur> joelteon: well, if you want the truth, that's not the law
13:51:52 <joelteon> oh
13:51:55 <hiptobecubic> it's just a statement about readRng
13:51:56 <augur> joelteon: its "a" law
13:52:02 <augur> that makes more sense to have in haskell
13:52:03 <joelteon> yeah, I said "a" law
13:52:08 <joelteon> oh
13:52:17 <augur> joelteon: but thats because haskell's orientation is more towards bind, and not join
13:52:23 <augur> when you see it for join, it makes more sense
13:53:19 <augur> when you translate into bind that's what you get out, but the obviousness is i think best presented for the join presentation
13:53:49 <tfero> maybe I have escape route: is it even syntactly possible to evaluate (readRng >>= return = readRng)?
13:54:12 <augur> tfero: what do you mean
13:54:15 <joelteon> no, there's no Eq instance for IO a
13:54:24 <augur> well thats == not =
13:54:34 <augur> but this = is at the level of logic, not the level of haskell code
13:54:38 <joelteon> well :P
13:55:23 <tfero> so every time readRng appears in code, it _must_ be a "new" call?
13:55:47 <monochrom> oh, it gets better than that
13:56:08 <monochrom> myloop n = getLine >> myloop (n-1)
13:56:25 <monochrom> the code has only 1 occurrence of "getLine". guess what happens.
13:56:27 <augur> joelteon: the naturalness comes from two things
13:56:57 <augur> joelteon: first, you have what looks like monoidal behavior of m. so let me define a nice little type def to make things clearer:
13:57:09 <tfero> monochrom: a new call but one appearance :D
13:57:13 <monochrom> you're likely going to completely destroy your current mental model to understand this
13:57:28 <augur> type f ~> g = forall a. f a -> g a
13:57:53 <augur> and also lets say
13:58:27 <augur> type (f :. g) a = f (g a)
13:58:36 <augur> joelteon: so,    return :: Id ~> m   join :: m :. m ~> m
13:59:08 <joelteon> ok
13:59:24 <augur> this is awfully like the monoid widgets:   mempty :: a   mappend :: (a,a) -> a
13:59:45 <augur> if we squint, we can see mempty as   mempty :: () -> a
13:59:58 <monochrom> I want to point out, though: if I modify the code to "myloop n = (getLine >>= return) >> myloop (n-1)", it behaviour doesn't change
14:00:05 <augur> so we have some generalizations: instead of a type a, we have a "thing" m
14:00:16 <joelteon> so mempty ~ return, and mappend ~ join
14:00:17 <augur> maybe its a type, maybe its a functor, who knows, who cares
14:00:59 <augur> joelteon: and we also then have to generalize, instead of a binary type widget (,), we need a binary "thing widget".
14:01:28 <augur> given two types it gives you a type, or if we want to do this with functors, given two functors it gives you a functor, etc.
14:01:33 <joelteon> ok
14:01:47 <augur> we also want a unit thingy
14:01:57 <augur> () is a unit type for the type-widget (,)
14:02:04 <augur> Id is the unit functor for the functor widget (:.)
14:02:13 <joelteon> ok
14:02:16 <augur> because, notice
14:02:23 <augur> ((),a) ~ a ~ (a,())
14:02:30 <joelteon> right
14:02:32 <augur> and Id :. f ~ f ~ f :. Id
14:02:47 <jmcarthur> tfero: there is no observable difference between readRng >>= return and readRng
14:02:59 <jmcarthur> that does not mean one reduces to the other
14:03:24 <tfero> monochrom: I guess understand this repackaging, my problem was/is how do you enforce that getLine/readRng returns the same value when it is called in the same context
14:03:42 <augur> joelteon: what we say then is that we want to work in a monoidal category -- a category that kinda has nullary and binary products, but not products like (,), rather, products in the categorical sense.
14:03:47 <jmcarthur> tfero: i think what we're trying to explain is that there is a difference between evaluation and execution. evaluation is just reduction. execution is when IO "happens"
14:04:02 <augur> joelteon: ok, once you're comfortable with that, we can then talk about what makes monads so obvious
14:04:07 <monochrom> I don't understand the question. by implementing getLine correctly, I suppose?
14:04:12 <jmcarthur> tfero: haskell requires that the meaning of an expression before and after evaluation is the same
14:04:16 <joelteon> getLine is the same as getLine
14:04:36 <jmcarthur> tfero: since evaluation has nothing to do with execution, this is true even of IO
14:04:40 <augur> joelteon: so, lets say generally, that our categorical unit thing is written as 1, and our product-y thing is written as *, just for the obvious convenience, yeah?
14:04:46 <joelteon> ok
14:04:57 <jmcarthur> tfero: and IO action is just a data representation which is interpreted "outside" of evaluation
14:04:58 <augur> so for types, 1 = (), * = (,)
14:05:05 <augur> and for functors, 1 = Id, * = (:.)
14:05:29 <joelteon> ok
14:06:08 <joelteon> tfero: a similar question to that would be "how do you enforce that '1' returns the same value when called in the same context?"
14:06:29 <augur> ok so, joelteon, a monoid in such a monoidal category is an object M together with an arrow unit :: 1 -> M, and an arrow join :: M*M -> M
14:06:33 <joelteon> ok
14:06:44 <augur> obviously if M is a type, it's just a monoid, right
14:06:45 <jmcarthur> joelteon: for some definition of "called"...
14:06:47 <joelteon> sure
14:06:48 <augur> boring old monoid
14:06:50 <tfero> jmcarthur: what my mind still stumbles upon is, that if the runtime encounters a request to e.g. readLine, how does it decide to return some value read earlier, or to actually read new value
14:06:52 <joelteon> jmcarthur: yeah, that's the thing
14:07:03 <joelteon> tfero: it always reads a new value
14:07:08 <joelteon> when executed
14:07:18 <augur> joelteon: and it has to satisfy some laws, obviously
14:07:22 <joelteon> ok
14:08:33 <augur> joelteon: the monoid laws of course being that unit is actually a unit for join, and join is actually associative
14:09:32 <joelteon> neat
14:09:47 <augur> so obviously for types, we want to know that going from    join ((),x) == m == join (x,())
14:10:07 <augur> and that   join (join (x,y), z) == join (x, join (y,z))
14:10:44 <augur> but what happens if M is a functor as before?
14:10:59 <tfero> thanks for the help, I'll try to internalize this
14:11:07 <jmcarthur> tfero: it's an interpreter
14:11:20 <augur> well, then   unit :: Id ~> M   and join :: M :. M ~> M
14:11:26 <jmcarthur> tfero: if the interpreter encounters some expression, it's just unaware of any past calls
14:11:35 <jmcarthur> tfero: i say expression. i meant action
14:11:46 <jmcarthur> tfero: it sees the action, it executes it
14:12:00 <augur> but we cant just write   join ((),x)   because that's not right at all is it
14:12:17 <jmcarthur> tfero: but this an interpreter of "the IO value that the haskell program represents" not the evaluator of the haskell expression
14:12:20 <augur> that's assuming the input is now a pair, but we said its something of type M :. M
14:12:27 <augur> well let's expand these types then
14:12:39 <augur> unit :: forall a. a -> M a    join :: forall a. M (M a) -> a
14:13:24 <augur> and what we want to do is somehow get the "equations" for a monoid, but with this suped up variant
14:13:52 <tfero> jmcarthur: let's say I pass the same IO String to two functions, both bind it and process the string somehow
14:13:55 <augur> well its somewhat tricky, but we can pointsfree it probably. but diagrams are much more fun:
14:14:04 <elliott> tfero: IO String isn't a string in disguise.
14:14:06 <elliott> @quote /bin/ls
14:14:06 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:14:13 <jmcarthur> tfero: and IO String does not contain a String
14:14:14 <elliott> that is the fundamental issue here.
14:14:21 <jmcarthur> *an
14:14:33 <elliott> you can think of (IO String) like an imperative program written in your favourite language -- Python, C, whatever -- that outputs a String.
14:14:36 <elliott> the program itself. not its result.
14:14:49 <elliott> the monad interface lets you *compose* these programs into bigger ones.
14:14:55 <augur> M :. M :. M ---fmap join---> M :. M ---join---> M   (that is, join . fmap join)
14:15:02 <elliott> the only time anything actually gets *run*/executed is by the runtime system, when it looks at what you define as "main".
14:15:02 <augur> has to be equal to
14:15:20 <elliott> (getRng >>= return = getRng) is basically the following statement:
14:15:49 <elliott> The Python programs "x = getRng(); return x" and "getRng()" are equivalent.
14:15:58 <augur> M :. M :. M ---join---> M :. M ---join---> M   (that is, join . join)
14:15:59 <elliott> (ok, some subtlety since that's not actually wrapped in a function etc. -- but you can see the relevant sentiment)
14:16:15 <augur> joelteon: yeah? because if we expand out the types:
14:16:48 <augur> M (M (M a)) ---fmap join---> M (M a) ---join---> M a   =   M (M (M a)) ---join---> M (M a) ---join---> M a
14:17:10 <tfero> elliott: ok, but doesn't haskell somehow ensure, that if I want to bind the same IO String twice, the String coming out of the monad is the same?
14:17:50 <elliott> tfero: do { x <- getLine; y <- getLine; ... } reads two lines, not one.
14:17:59 <elliott> that is precisely because getLine is a *description* of how to read a line
14:18:14 <elliott> you do the same thing twice and get different results, because it is a thing with effects
14:18:22 <tfero> that part I get
14:18:33 <elliott> now, the law is saying we can say
14:18:37 <tfero> what's probelmatic for me (it's probably not even valid haskell)
14:18:40 <elliott> do { x <- getLine >>= return; y <- getLine >>= return; ... }
14:18:44 <elliott> and it will be exactly the same.
14:18:46 <tfero> x = getLine
14:18:49 <tfero> f x
14:18:50 <tfero> g x
14:18:54 <augur> joelteon: thats for associativity. for unit, obviously:    M ---fmap unit---> M :. M ---join---> M   =   M ---id---> M
14:19:01 <tfero> f,g : IO String -> IO ()
14:19:06 <elliott> if you say x = getLine at top level, or let x = getLine in ..., then you can simply replace all uses of x with getLine
14:19:15 <elliott> it is a directly true equation: x is the same as getLine
14:19:16 <monochrom> that's going to be do{ x <- getLine; putStrLn x; putStrLn x again }
14:19:31 <augur> and conversely,   M ---unit---> M :. M ---join---> M   =   M ---id---> M
14:19:33 <elliott> monochrom: er, if it was x <- getLine, sure?
14:19:35 <haasn> tfero: in practise you won't find any functions of type :: IO String -> IO ()
14:19:40 <haasn> tfero: they'll all have String -> IO ()
14:19:40 <elliott> (but I guess = vs. <- is part of the confusion here.)
14:20:00 <joelteon> join . fmap return == id
14:20:03 <joelteon> right??
14:20:29 <augur> joelteon: yep, thats what it gets called in haskell :)
14:20:52 <haasn> tfero: but assuming for the sake of argument that f=g and f x = x >> return () -- then yes, do { let x = getLine; f x; g x } -- would read two lines
14:21:02 <tfero> elliott: so if I say let x = getLine in ... then each time I bind x, it will return a different value?
14:21:10 <tfero> ok
14:21:24 <elliott> tfero: yes. because you are saying: let x be an effectful description of how to produce a String. let it be the same as getLine. then, ...
14:21:32 <augur> joelteon: if you squint and ignore the fmaps, youll notice it's just the monoid laws, but for these beefed up monoids over things other than types
14:21:45 <joelteon> yeah I see it
14:22:04 <elliott> when you say "do { x <- getLine; ... }" that is simply syntax sugar for: the description we get by considering what happens when we follow the description 'getLine' (call the output x), and then do ...
14:22:09 <joelteon> join :: m (m _) -> m _, mappend :: (m -> m) -> m
14:22:24 <joelteon> well
14:22:26 <augur> joelteon: well not quite. the type of mappen is wrong.
14:22:27 <joelteon> that's the wrong grouping, though
14:22:28 <joelteon> m -> m -> m
14:22:50 <augur> but also, its important to realize that m -> m -> m is basically (m,m) -> m
14:23:18 <tfero> eliott: so basically it is impossible to assign a executed IO String to a name, then get the execution result twice
14:23:22 <augur> and   forall a. m (m a) -> m a   is the same as   m :. m ~> m
14:23:37 <augur> where (,) ~ (:.) and (->) ~ (~>)
14:23:40 <elliott> tfero: I don't see why not
14:23:41 <joelteon> yeah I know
14:23:43 <elliott> you can refer to "x" multiple times in ...
14:23:46 <elliott> in do { x <- getLine; ... }
14:24:01 <valyagolev> have anyone read and tried "Programming with Arrows"?
14:24:17 <augur> joelteon: but ok, so, that's fun, but programming like that is nasty. we like to think about function application, and join aint function application. but we can define something kind of like function application quite easily
14:24:21 <valyagolev> I just can't get it to work. found some code https://github.com/Athas/sigkill.dk/blob/master/programs/arrows/ – it doesn't work either :(
14:24:26 <jmcarthur> tfero: this is a fairly common analogy. an IO action is like a recipe. imagine i say "let x mean read a line and then write that line with some stuff on the end." now if i say "do x, then do x", i mean do x twice. it's the same x, but the fact that it's mentioned twice in the same recipe means it is to be executed twice.
14:24:26 <tfero> elliott: yes, but I mean a bit more freestyle, not just within one block
14:24:28 <elliott> (and it will be the same x always, because things are always equal to themselves)
14:24:38 <elliott> tfero: you can pass around "x" to functions
14:24:42 <haasn> tfero: you could ‘return’ it and the end and bind the result of that block to some other action
14:24:43 <augur> joelteon: given join :: m (m a) -> m a, we can define (=<<) :: m a -> (a -> m b) -> m b
14:24:52 <augur> whoops
14:25:00 <augur> (=<<) :: (a -> m b) -> m a -> m b
14:25:07 <augur> if you squint and ignore the m's, it's just ($)
14:25:21 <joelteon> yeah, I know
14:25:40 <jmcarthur> tfero: it's the same as if i say   let x = 1+1 in x*x*x   . it's the same x in all the uses, but its effect on the result is different each time (the second time changes it from 2 to 4, the third time changes it from 4 to 8)
14:25:48 <valyagolev> I think I was closing the pdf with anger like 6 time in the last couple of days
14:25:55 <augur> so just define (=<<) (or (>>=)) in terms of join, translate the effects of the laws through, and hey presto, you get the haskellian monad laws
14:26:34 <augur> the laws for bind arent intuitively obvious, but the laws for join are: they're just monoid laws!
14:26:38 <tfero> jmcarthur: this went over my head
14:27:11 <jmcarthur> tfero: let's break this down, and then i'll do the same thing in IO
14:27:32 <jmcarthur> tfero: i'll change the example slightly, and use parens to make it more clear
14:27:46 <jmcarthur> tfero: let x = 1+1 in (10 * x) * x
14:28:11 <jmcarthur> tfero: what is the effect of the first x on the 10?
14:28:20 <jmcarthur> in terms of the result
14:28:32 <augur> joelteon: i hope that made some more sense than not :P
14:29:13 <tfero> jmcarthur: not sure, it double it obv, but this effetct is not clear
14:29:31 <tfero> how's that an effect?
14:29:35 <jmcarthur> tfero: right. it changes the "accumulator" (we'll call it that, at least) from 10 to 20
14:29:49 <jmcarthur> tfero: it is in effect only in that we can interpret it that way. we are "affecting" the accumulator
14:30:36 <jmcarthur> tfero: now the next x does something different. it doesn't just make the accumulator 20. it makes it 40 this time. that is because the "execution context" (the current accumulator) is different
14:30:56 <tfero> jmcarthur: ok
14:31:16 <jmcarthur> tfero: likewise:     let x = getLine >>= putStrLn in x >> x
14:31:21 <mm_freak> haasn: sounds interesting, but all my future work will be based on netwire 5
14:31:38 <jmcarthur> tfero: now my execution context is the so-called Real World
14:31:41 <haasn> mm_freak: Okay. Are you close to a release? Maybe I could use it
14:31:49 <jmcarthur> tfero: and my effects are my interactions with it
14:31:56 <mm_freak> haasn: i have to be close to a release =)
14:32:09 <mm_freak> i'll need it for a project next week
14:32:10 <jmcarthur> tfero: and instead of using (*) to change the effects on some accumulator, i'm using (>>) to chain the effects on the real world
14:32:13 <valyagolev> I want a visual beta-reduction tool :/
14:32:51 <jmcarthur> tfero: and the state of the real world after the first x vs. after the second x can be different (since i have consumed two lines and output two lines by the end)
14:33:26 <jmcarthur> tfero: with the first example, i could have instead said this:   10*(1+1)*(1+1)
14:33:44 <jmcarthur> tfero: with the IO example, i could have instance said this    (getLine >>= putStrLn) >> (getLine >>= putStrLn)
14:33:49 <jmcarthur> *instead
14:34:02 <jmcarthur> tfero: the meaning is the same
14:34:48 <jmcarthur> tfero: in haskell you can always replace one subexpression with another than means the same thing. the resulting expression's meaning is not different from the original
14:35:05 <jmcarthur> *that means
14:35:55 <tfero> jmcarthur: thanks, I'm still trying to make the transition between the two examples
14:35:57 <jmcarthur> tfero: just as 2 always means 2, getLine always means getLine. (*2) always means (*2). (>>getLine) always means (>>getLine). and so on
14:38:00 <mlamari> That Brian Hurt speech was gold, the best case I've ever seen made for static typing.  I want to go through it and mark out specific points to send specific highlights to people.
14:38:40 <path[l]> is this online?
14:38:51 <mlamari> http://vimeo.com/72870631  <-- gold
14:38:57 <path[l]> I'm still usually strongly in favour of dynamic typing, so I'd like to change my mind
14:39:08 <path[l]> thanks
14:39:27 <tfero> I think I finally understood, the IO analogy from earlier: if you have an expression with type IO String, it _will_ return a different String each time you bind it.
14:39:28 <mlamari> You may have misunderstood me - I'm not claiming dynamic vs static is settled or anything. There are pros and cons that are undeniable.  He just lays out many of them very well.
14:40:13 <mlamari> Hell, a lot of the speech is stuff I already knew from other sources; but he lays it out more concisely in one place.
14:40:40 <tfero> as one of you put it, IO String does not "contain" the String, it produces it every time.
14:40:50 <jmcarthur> tfero: well, bind will pass a different string to its second argument each time. it's not *exactly* correct to say that an IO String "returns" and String at all (although, loosely, that is something we say)
14:41:02 <jmcarthur> *a String at all
14:41:03 <path[l]> yeah I understand, I just wanted to see the arguments. I've slowly started to come around to the opinion that statically typed languages can be close to the level of verbosity of dynamically typed languages AND that the tooling advantages are extremely beneficial
14:41:09 <elliott> I still think this quote is a very good description:
14:41:10 <elliott> @quote /bin/ls
14:41:10 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:41:13 <jmcarthur> tfero: but yeah, you are saying basically correct things
14:41:24 <elliott> every time you *run* /bin/ls, it (may) give different results
14:41:36 <mlamari> path[l] :  The measure is ultimately human work, and he even addresses *that* as the rationale behind his pitch.
14:41:40 <elliott> though we don't speak of the /bin/ls executable itself as somehow being different itself when this happens
14:41:50 <elliott> the actual executable is a static, (machine-readable) description
14:41:51 <mlamari> It's not "which is better"; but what are you measuring?
14:42:28 <tfero> yeah, I'm not speaking the lingo yet :)
14:42:37 <tfero> thanks a lot!
14:44:23 <tfero> so the right identity basically says, that this String producing mechanism m, and this other String producing mechanism (m >>= return) produces the same Strings
14:44:36 <elliott> right, precisely
14:44:39 <elliott> they behave the same way.
14:45:22 <tfero> well, that's clearer now :D
14:45:26 <tfero> thanks again!
14:45:35 <jmcarthur> "a = b" means "a is not observably different from b"
14:47:03 <path[l]> mlamari: agreed. Which is why Ive started to believe that tooling is one of the most important pieces. As I work on larger and larger codebases, I find that the effort needed to find usages and implementation is more than the actual work to write code
14:48:16 <mlamari> In dynamic typed though, I've retrenched to seeing only Common Lisp being a candiate for standing up to best-of-breed static-typed.  But also, full potential of static typed seems only available in haskell
14:48:51 <mlamari> The MLs wouldn't have the thread-safety proofs mentioned in the video
14:49:13 <jmcarthur> thread safety proofs? if you are talking about ST, that was kind of wrong
14:49:24 <jmcarthur> i cringed when i heard him say that
14:49:44 <mlamari> Fair enough I could be naive
14:50:11 <jmcarthur> ST is really for writing functions that uses mutation in a way that is safe to use in pure code
14:50:23 <mlamari> But you can guarantee IO separate from transaction right?
14:50:32 <jmcarthur> it's still a type safety thing, still interesting, but it's not really about single threadedness
14:50:40 <jmcarthur> oh do you mean STM?
14:50:49 <mlamari> I was thinking of the STM/IO part
14:50:52 <jmcarthur> ah
14:50:55 <mlamari> That's what spoke to me
14:51:24 <jmcarthur> yeah, STM guarantees that from the point of view of a transaction there is nobody else interacting with what is actually a shared state
14:51:33 <mlamari> Debated that one to death with a friend 2 years ago - couldn't get it past "don't do that" in anything else
14:51:42 <jmcarthur> while in reality there actually can be other threads using the same shared state you are using
14:51:53 <jmcarthur> but the illusion is maintained in a completely safe way
14:51:54 <mlamari> STM + type sig proving no IO
14:51:57 * hackagebot cloudfront-signer 0.0.0.1 - CloudFront URL signer  http://hackage.haskell.org/package/cloudfront-signer-0.0.0.1 (ChrisDornan)
14:52:20 <jmcarthur> right, there can be no IO (barring well-laballed escape hatches) in an STM transaction
14:55:49 <donri> and even then you can disable those escape hatches with SafeHaskell
15:01:12 <jmcarthur> you can cheat your way around SafeHaskell, too. just mark a module as trustworthy, then import it and use it in some other module. that module will be marked safe, and users of that module will be none the wiser.
15:01:40 <donri> jmcarthur: that's why the system includes the concept of package trust
15:04:40 <jmcarthur> donri: i'm just saying that it's still possible to violate somebody's trust. it's still a weaker guarantee than a real type system without escape hatches
15:04:40 <mlamari> Right - but I got the gist, any such security in almost anything else is just running on hope/conventions
15:05:43 <mlamari> And even though I kind of knew this before the video, he lays it out with other goodies (like how the type signature gives you a high amount of the documentatino in itself)
15:06:05 <jmcarthur> yeah, parametricity is awesome
15:07:40 <dagano> is there a ghci command to inspect an import .. ie the functions defined?
15:09:22 <jmcarthur> i don't know of one
15:09:28 <jmcarthur> mlamari: check this out:
15:09:30 <jmcarthur> @free zip
15:09:31 <lambdabot> $map ($map_Pair f g) . zip xs = zip ($map f xs) . $map g
15:09:40 <jmcarthur> a free theorem!
15:09:43 <jmcarthur> @free filter
15:09:44 <lambdabot> $map f . filter (g . f) = filter g . $map f
15:10:29 <jmcarthur> @free head
15:10:30 <lambdabot> f . head = head . $map f
15:15:42 <monoidal> dagano: to see things exported from a module, use  :browse M. i don't think there's one for seeing what is imported.
15:23:29 <identity> Is there any reason at all to not simply use the llvm backend for ghc always?
15:24:56 <Taneb> Yes, it's only better than default every now and then
15:25:00 <geekosaur> last I heard it still had performance issues in many cases
15:25:12 <geekosaur> the only clear win is lots of Double math, IIRC
15:25:36 <identity> oh. I had only really seen examples where it's often better by a gigantic margin, but none where it's worse
15:26:03 <identity> I guess I'll just stick to trying out my code with the llvm to see if it performs better etc
15:26:08 <geekosaur> basically ghc CPS-transforms before generating LLVM code, and this confuses LLVM a bit
15:26:36 <identity> aah.
15:26:57 <hiptobecubic> I've only had it be faster for numeric code, yeah
15:27:18 <hiptobecubic> although it was double digit % faster there i think, I'd have to bench it again
15:28:08 <hiptobecubic> there was also that interesting blog post that dons did (I think) where he used genetic algorithms to optimize the compilation flags
15:28:26 <geekosaur> yeh, that was dons
15:28:36 <hiptobecubic> and he was able to get some really crazy behavior, like having the llvm backend just evaluate a loop entirely at compiletime
15:28:55 <identity> Yeah I just tried it on some number crunching code and it was about 270% faster there.
15:29:14 <identity> hiptobecubic: lol, shit, that sounds awesome
15:29:35 <identity> Haha, that's really really ingenious
15:29:54 <hiptobecubic> sheesh. were you using optimizations for the native compiler?
15:30:04 <identity> hiptobecubic: Yep. -O2 on both
15:30:11 <identity> it's just some silly euler challenge mind you
15:30:26 <hiptobecubic> oh
15:30:28 <identity> 17.7 secs -> 4.7 secs
15:30:35 <hiptobecubic> intersting, care to paste?
15:31:33 <identity> oh, sure. This is practically completely unoptimized code, though. I was about to play around with optimizing it for fun. I like optimizing things
15:31:33 <geekosaur> llvm is capable of very good optimization when it can figure out what's going on. for heavy numeric code it often can; for other stuff, not so much because of the CPS transform. IIRC the ghc folks are waiting on some LLVM annotations that will let them tell it wtf ghc is up to, so it has some chance of optimizing the code properly instead of giving up and generating slower code
15:31:39 <jmcarthur> microbenchmarks tend to be more likely to favor the llvm backend because they are more often written to have fairly tight, non-allocating loops with mostly math code.
15:32:16 <erisco> cool idea of today (actually I hope its already done and someone can point me to it) http://pastebin.com/yTCGz6Sc
15:32:20 <mauke> The paste yTCGz6Sc has been copied to http://lpaste.net/92153
15:32:44 <erisco> a family of functions which (p)op then (p)ush a parameter of a function
15:33:18 <jmcarthur> these exist
15:33:40 <jmcarthur> but i have to rederive them
15:33:58 <hpaste_> identity pasted “No title” at http://lpaste.net/92154
15:34:14 <identity> hiptobecubic: ^
15:34:33 <tikhon> erisco: Heh, that vaguely reminds me of a paper about embedding a postfix language into Haskell—it's interesting because Haskell naturally favors prefix and infix notation.
15:34:39 <tikhon> http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/hw02postfix.pdf
15:34:53 <erisco> well sure they exist, I just wrote them :P I'm looking for a mechanism where you don't have to write out pp*
15:34:59 <erisco> I'm not up on Haskell's code generation libraries
15:35:12 <hiptobecubic> identity, thanks
15:36:06 <hiptobecubic> identity, look up maxBy
15:36:40 <identity> @src odd
15:36:52 <identity> It's not @src?
15:37:14 <hiptobecubic> odd is what you'd expect
15:37:17 <geekosaur> it is but the bot occasionally lags/gets stuck, we're not sure wht
15:37:20 <geekosaur> *why
15:37:21 <monochrom> w00t new lpaste theme? chrisdone++
15:37:29 <identity> @src odd
15:37:44 <lambdabot> odd = not . even
15:37:45 <lambdabot> odd = not . even
15:37:51 <identity> there we go
15:37:54 <identity> @src even
15:37:57 <lambdabot> even n = n `rem` 2 == 0
15:37:59 <identity> ah.
15:38:07 <tikhon> heh, I was hoping it said not . odd :P
15:38:13 <hiptobecubic> me too :)
15:39:08 <identity> Well, odd' = (== 1) . (.&. 1) takes the code to roughly llvm performance..
15:40:39 <identity> so I reckon that's a big part of the optimization the llvm backend is doing
15:40:46 <erisco> you might also want the uu* family... unshift and unpop, which would be the inverse
15:41:12 <erisco> actually I think unshift is putting it back on... su* then
15:44:11 <fylwind> is there a name for a category with a "special/unique element" ?
15:45:20 <fylwind> oh never mind, found it: pointed category
15:47:46 <erisco> jmcarthur, actually I might have a better idea
16:03:07 <erisco> okay here is an even more powerful version http://lpaste.net/92156
16:03:53 <arkeet> erisco: did you know that sf3p12 = sf2p12
16:04:04 <arkeet> and so is sf4p12
16:04:11 <erisco> jmcarthur, I conjecture that any permutation of the parameters can be made using the s* functions
16:04:19 <arkeet> it can
16:04:39 <arkeet> :t flip . (flip .) . flip
16:04:40 <lambdabot> (a1 -> a -> b -> c) -> b -> a -> a1 -> c
16:04:54 <erisco> arkeet, yes, indeed they are, but the verbosity was to make the pattern more clear
16:04:57 <arkeet> sfNp12 = flip, sfNp23 = (flip .), sfNp34 = ((flip .) .), etc
16:05:20 <erisco> that's a good way to define them too :)
16:05:22 <arkeet> but yes, the symmetric groups are generated by transpositions.
16:05:47 <arkeet> wait.
16:05:54 <arkeet> yeah.
16:05:57 <bennofs> :t fmap . fmap . fmap . fmap . fmap $ flip
16:05:58 <lambdabot> (Functor f, Functor f1, Functor f2, Functor f3, Functor f4) => f (f1 (f2 (f3 (f4 (a -> b -> c))))) -> f (f1 (f2 (f3 (f4 (b -> a -> c)))))
16:06:17 <arkeet> :t (.).(.).(.) $ flip
16:06:18 <lambdabot> (a -> a1 -> a2 -> a3 -> b -> c) -> a -> a1 -> a2 -> b -> a3 -> c
16:07:28 <erisco> arkeet, I don't know what symmetric groups are, but the generality of the simple operation is quite appealing
16:07:38 <erisco> and defining it with composition and flip is even better
16:07:43 <arkeet> they're groups of permutations.
16:07:56 <arkeet> and you're permuting arguments.
16:08:44 <erisco> mm, I would think bubble sort would depend on this as well
16:08:54 <arkeet> yes
16:09:28 <arkeet> in fact, bubble sort gives you an explicit algorithm for determining which transpositions compose to give a given permutation.
16:09:37 <arkeet> transpositions to compose.
16:10:08 <arkeet> nice observation. :)
16:11:32 <erisco> "a transposition" is what exactly? the swapping of any adjacent arguments?
16:11:50 <arkeet> yes
16:12:08 <arkeet> hm, no, not quite.
16:12:16 <arkeet> a transposition is the swapping of any two things.
16:12:55 <arkeet> so we should say adjacent transpositions.
16:13:25 <arkeet> anyway, bubble sort makes it clear that any permutation is a product of adjacent transpositions.
16:13:28 <arkeet> now the fun exercise:
16:13:41 <arkeet> show that any permutation (of N things) is a product of at most N-1 adjacent transpositions
16:13:43 <arkeet> :)
16:14:05 <arkeet> (the unique permutation that requires N-1 is the one that reverses everything.)
16:14:06 <erisco> :o
16:14:32 <erisco> seems I've stumbled into something well studied. what area are we in exactly?
16:14:47 <arkeet> group theory, I suppose.
16:14:48 <fylwind> is there a reason why the Pointed type class was rendered obsolete? http://www.haskell.org/haskellwiki/Why_not_Pointed%3F
16:14:52 <arkeet> specifically, about the symmetric group.
16:16:03 <arkeet> wait.
16:16:06 <arkeet> never mind, it's not N-1.
16:16:10 <arkeet> it's N(N-1)/2.
16:16:12 <erisco> arkeet, that conclusion is somewhat interesting, because bubble sort is more complex
16:16:14 <arkeet> and then bubble sort gives you that.
16:16:20 <arkeet> heh.
16:16:26 <bennofs> fylwind: it has no laws
16:16:27 * arkeet was confused a bit.
16:16:35 <arkeet> N-1 is the number of generators.
16:18:10 <arkeet> fylwind: supposedly it wasn't very interesting.
16:18:15 <arkeet> :(
16:18:38 <fylwind> I guess it's not the most interesting thing in the world, but sometimes one simply needs a type that has a "default" constructor so Pointed seems like the right kind of type class to use :(
16:18:50 <bennofs> And N(N-1)/2 is also the sum of the integers from 1 to N
16:18:51 <erisco> arkeet, it seems one would want to prove that bubble sort is correct. With that established you're almost done
16:19:00 <bennofs> oh, that was N(N+1)/2
16:19:02 <bennofs> nvm
16:19:16 <arkeet> bennofs: it is the sum of integers from 1 to N-1 though!
16:19:42 <arkeet> (which is precisely the number of comparisons bubble sort makes.)
16:20:17 <arkeet> fylwind: well, it would have been nice to have for lens =(
16:20:34 <arkeet> then we would have had a way to express "a traveresal with at most one target"
16:20:37 <erisco> these similarities between seemingly entirely different things is quite titillating
16:20:59 <arkeet> coxeter groups are fun.
16:21:18 <arkeet> hm, I meant "traversal"
16:21:46 <erisco> I suppose I should study on some group theory if it is this interesting
16:22:12 <erisco> maybe it is more tractable than categories
16:22:48 <arkeet> it's one level lower of abstraction, I guess.
16:22:50 <arkeet> and it's fun
16:23:51 <fylwind> so if I were to have a type class instance Alpha a => Beta a, as well as Gamma a => Beta a, what happens if Alpha and Gamma overlap?
16:24:32 <arkeet> fylwind: ghc will yell at you whenever you try to use such an instance.
16:24:44 <arkeet> unless you enable OverlappingInstances.
16:25:00 <geekosaur> those instances overlap anyway; context doesn't play a part in instance selection
16:25:07 <arkeet> when checking for overlapping instances--uh that^
16:25:20 <arkeet> when checking for overlap, it just sees two instances Beta a and Beta a
16:25:25 <edwardk> fylwind: if you have those instances, you're basically hosed.
16:25:36 <edwardk> fylwind: even if Alpha and Gamma don't overlap.
16:25:44 <edwardk> there is _zero_ backtracking in instance resolution
16:25:50 <fylwind> I see, that's unfortunate :( thanks
16:25:52 <edwardk> as it would change the semantics of your program under an open world
16:25:52 <arkeet> the justification being that they *might* overlap in the future.
16:25:57 <arkeet> because type classes are open.
16:26:12 <edwardk> if someone adds an instance it could cause you to backtrack and select difference instances elsewhere in your program
16:26:17 <edwardk> causing global changes in meaning
16:26:59 * hackagebot texmath 0.6.4 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.4 (JohnMacFarlane)
16:27:16 <edwardk> in many ways the current semantics are the best for lots of people interoperating on a large codebase. even if they do occasionally cause you to write a boilerplate instance or newtype wrapper
16:32:32 <tikhon> the semantics are good, but they also seem to be a very common cause for confusion
16:33:05 <tikhon> maybe we just need some clearer documentation for it—I'm never sure where to point people when talking about the open world assumption
16:33:38 <pxqr> why ghc do not allow to unpack enums?
16:33:51 <tikhon> pxqr: what do you mean by unpacking enums?
16:34:28 <pxqr> tikhon: just like ints or single constr ADT
16:34:34 <erisco> point them to working on a several month team project where everyone decides global state is convenient
16:34:45 <tikhon> pxqr: so you want to go from the enum to an int and back?
16:34:52 <erisco> (by global state I mean using global variables, statics, etc)
16:35:36 <erisco> you'll have bugs you never thought possible :)
16:35:59 <pxqr> tikhon: no, for example data A = A {-# UNPACK #-} !Int and data B = B !Bool will have different representation at runtime
16:36:23 <edwardk> pxqr: i've often wanted the ability to 'unpack' a Bool myself.
16:36:46 <pxqr> edwardk: yeah, I mean this
16:36:50 <edwardk> similarly for other enum like data types
16:37:27 <tikhon> oh
16:37:28 <tikhon> hmm
16:37:38 <edwardk> i often just stuff the {-# UNPACK #-} !Int or Int# in there myself and convert with toEnum/fromEnum
16:37:39 <pxqr> I just remembered haskell wiki note about enum vs Int performance
16:37:45 <tikhon> OCaml does something like that, I believe
16:37:46 <edwardk> but that annoyingly requires smart constructors
16:37:56 <arkeet> and smart patterns
16:38:01 <edwardk> yeah
16:38:16 <tikhon> is it more difficult in Haskell because of laziness?
16:38:33 <edwardk> no
16:38:33 <pxqr> tikhon: !Bool still unlifted
16:39:09 <edwardk> it has the same semantics as any other {-# UNPACK #-} pragma modulo some Enum noise.
16:39:24 <edwardk> we can unpack all sorts of crazy nested structures
16:39:28 <tikhon> right
16:39:53 <tikhon> but laziness is the reason things can't be unpacked by default, right?
16:41:01 <pxqr> tikhon: + recursive ADTs
16:41:07 <arkeet> it's the reason things can't be *strict* by default
16:41:33 <arkeet> if it's already strict, unpacking doesn't really mean anything in terms of laziness.
16:41:39 <tikhon> yes
16:42:08 <tikhon> but there is no way to have something be unpacked and non-strict, is there? It would have to sometimes be a thunk.
16:42:31 <arkeet> no, that's the whole reason things are boxed.
16:42:43 <tikhon> (Part of my understanding comes from the fact that we have the -funbox-strict-fields flag)
16:42:57 <arkeet> that's a good flag
16:44:48 <pxqr> arkeet: doesn't -funbox-small-strict-fields (not sure about pronouncing) better? :)
16:45:42 <arkeet> hmm?
16:46:02 <arkeet> what sort of things are considered not small?
16:46:07 <tikhon> does unboxing large strict fields lead to stack overflows or something?
16:47:17 <arkeet> pxqr: ?
16:47:29 <valyagolev> what is a large strict field?
16:47:44 <arkeet> that's what I'm wondering.
16:47:47 <pxqr> arkeet: I just trying to find that flag, forget it's name
16:47:53 <arkeet> or rather, what qualifies as large.
16:48:02 <pxqr> if I right it's word size, but not sure
16:48:08 <tikhon> couldn't you have an arbitrarily large unboxed record or something?
16:48:16 <arkeet> you could.
16:48:25 <tikhon> and could that mess up your stack?
16:48:30 <valyagolev> -funfolding-use-threshold=n
16:48:47 <valyagolev> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/options-optimise.html#options-f
16:48:58 <arkeet> that looks unrelated
16:49:18 <notasi> > fix fail
16:49:19 <lambdabot>   ""
16:49:25 <arkeet> > fix error
16:49:26 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
16:49:40 <valyagolev> for some reason I read unfolding as unboxing
16:50:10 <lightquake> @type fail
16:50:10 <lambdabot> Monad m => String -> m a
16:50:17 <pxqr> ok, it's cf8fba957d86a291eea971ef12d3ba76ffcfef13
16:50:25 <lightquake> oh, fail :: String -> String
16:51:04 <S_J> how do I return to a specific monad? like return . x :: [a] does not work
16:51:08 <pxqr> "A "small" data type is one whose size is equivalent to or smaller than the native word size of the machine."
16:51:41 <notasi> > return 3 :: [Int]
16:51:42 <lambdabot>   [3]
16:51:44 <tikhon> S_J: why do you have the .?
16:51:48 <notasi> > return 3 :: Maybe Int
16:51:49 <lambdabot>   Just 3
16:51:57 <Mikicacarica> FREE BRAZZERS ACCOUNTS EVERYDAY ---> http://brazzersnew.blogspot.com
16:52:01 --- mode: ChanServ set +o geekosaur
16:52:06 --- mode: geekosaur set -o geekosaur
16:52:18 <notasi> > return 3 :: Either (IO ()) Int
16:52:19 <lambdabot>   Right 3
16:52:54 <S_J> that doiesn not work in ghci
16:53:07 <geekosaur> S_J: typically the monad will be constrained by >>=, you don't get to choose one
16:53:20 <valyagolev> that sure does
16:53:45 <valyagolev> Prelude> return 3 :: [Int] --------> [3]
16:54:10 <notasi> return 3 :: Either (IO ()) Int doesn't work in GHCi, I just tried it there
16:54:36 <geekosaur> it will depend on whether you have a Monad instance for Either in scope
16:54:40 <valyagolev> @t return (return 3) :: Either (IO ()) Int
16:54:41 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
16:54:42 <geekosaur> there isn't one by default
16:54:48 <arkeet> notasi: try import Control.Monad.Instances
16:54:48 <valyagolev> @type return (return 3) :: Either (IO ()) Int
16:54:49 <lambdabot>     Couldn't match expected type `Int' with actual type `m0 a0'
16:54:49 <lambdabot>     In the return type of a call of `return'
16:54:49 <lambdabot>     In the first argument of `return', namely `(return 3)'
16:54:57 <arkeet> or, use ghc 7.6+
16:55:01 <valyagolev> @type return (return ()) :: Either (IO ()) Int
16:55:01 <lambdabot>     Couldn't match expected type `Int' with actual type `m0 ()'
16:55:02 <lambdabot>     In the return type of a call of `return'
16:55:02 <lambdabot>     In the first argument of `return', namely `(return ())'
16:55:02 <geekosaur> rather for Either a
16:55:26 <S_J> I don't get the list monad. return puts it back in the monad. so then what does >>= take out?  A list that isnt a list?
16:55:33 <geekosaur> also note that most such instances are Right-biased (Left is used for `fail`)
16:55:41 <notasi> It takes out an arbitrary element of the list
16:55:46 <valyagolev> >>= is concatMap
16:55:53 <ParahSail1n> @src [] (>>=)
16:55:54 <lambdabot> xs >>= f     = concatMap f xs
16:56:03 <ParahSail1n> @src [] return
16:56:04 <lambdabot> return x    = [x]
16:56:04 <notasi> > do {x <- [1..3]; y <- [1..3]; return (x,y);}
16:56:05 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
16:56:08 <arkeet> = concat (map f xs)
16:56:23 <arkeet> > liftA2 (,) [1..3] [1..3]
16:56:23 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
16:58:04 <notasi> > [1..10] >>= \n -> guard (even n) >> return n
16:58:06 <lambdabot>   [2,4,6,8,10]
16:58:29 <S_J> > join [[1,2,3],[4,5,6]]
16:58:30 <lambdabot>   [1,2,3,4,5,6]
16:58:34 <notasi> > [n | n <- [1..10], even n]
16:58:35 <lambdabot>   [2,4,6,8,10]
16:59:36 <valyagolev> are these list comprehensions common? I don't actually find them any fun
16:59:50 <valyagolev> love list monad though, but not like this
17:00:23 <notasi> > filter even [1..10] -- Less typing than comprehensions
17:00:24 <lambdabot>   [2,4,6,8,10]
17:01:33 <k00mi> valyagolev: you rarely see list comprehensions in real code in my experience
17:01:37 <pxqr> $ touch Prelude.hs && ghci
17:01:40 <pxqr> attempting to use module `Prelude' (./Prelude.hs) which is not loaded
17:01:40 <tikhon> list comprehensions sometimes make the code look nicer
17:01:47 <arkeet> > [1..10] >>= liftA2 (>>) (guard.even) return
17:01:48 <lambdabot>   [2,4,6,8,10]
17:02:04 <pxqr> doesn't that strange a bit?
17:02:04 <arkeet> pxqr: don't do that then ;)
17:02:10 <arkeet> heh
17:02:20 <tikhon> you can also enable monad comprehensions and use the same syntax for other monads
17:02:39 <pxqr> arkeet: well, why does ghci even see that file >.<
17:02:43 <arkeet> heh.
17:02:56 <tikhon> I find this very useful with Maybe for example: it makes the pattern of if condition then Just something else Nothing much neater.
17:03:27 <arkeet> > guard True *> Just 1
17:03:36 <arkeet> hmm.
17:03:43 <lambdabot>   Just 1
17:04:00 <notasi> @t (*>)
17:04:00 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
17:04:06 <notasi> @typ (*>)
17:04:07 <lambdabot> Applicative f => f a -> f b -> f b
17:04:18 <notasi> oh, so it's just like (>>) for applicatives?
17:04:24 <arkeet> yes
17:04:33 <arkeet> tikhon: I suppose that's [1 | True] with MonadComprehensions.
17:04:41 <tikhon> arkeet: yep
17:04:52 <valyagolev> >> is just like *> for monads
17:04:55 <tikhon> for some sorts of code, it's very nice
17:05:23 <tikhon> notasi: you also get <*, which is like *> but returns the result of the first argument
17:05:30 <valyagolev> > [18 | (>3) ] :: Just Int
17:05:32 <lambdabot>   Not in scope: type constructor or class `Just'
17:05:32 <lambdabot>  A data constructor of that ...
17:05:33 <arkeet> except it really ought to work for any Alternative
17:05:33 <arkeet> :(
17:05:37 <valyagolev> > [18 | (>3) ] :: Maybe Int
17:05:38 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
17:05:39 <lambdabot>              ...
17:05:55 <arkeet> valyagolev: the guard has to be a bool
17:05:58 <notasi> > [Just 1 <* Just 2, Just 1 <* Nothing]
17:05:59 <lambdabot>   [Just 1,Nothing]
17:06:08 <tikhon> > [18 | 18 > 3] :: Maybe Int
17:06:09 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
17:06:09 <lambdabot>              ...
17:06:21 <tikhon> maybe it doesn't have the extension loaded
17:06:23 <valyagolev> > listToMaybe [x <- Just 39 | x > 3 ]
17:06:24 <lambdabot>   <hint>:1:16: parse error on input `<-'
17:06:38 <arkeet> hm, how come we don't have guard for Alternative anyway
17:06:52 <arkeet> maybe because bools are evil.
17:07:30 <tikhon> evil, perhaps, is a little bit strong
17:07:41 <tikhon> but they do tend to view the world in very black and white terms
17:07:53 <arkeet> :p
17:08:40 <quchen> What do you guys think about ViewPatterns? Haven't seen them used much. They seem useful but maybe too easily abusable. Should I avoid them when I can, use them sparingly, spam them all over the place?
17:09:42 <quchen> My current use is just to save renames, like "foo (abs -> n) = replicateM n bar >> forM_ [1..n] $ \..."
17:09:48 <tikhon> I don't think they're that abusable—they desugar in a very straightforward way
17:10:01 <tikhon> and they make some awkward code much easier to follow
17:10:04 <quchen> tikhon: I meant that in the "becomes unreadable very fast"
17:10:11 <quchen> ... sense
17:10:25 <quchen> But maybe I'm just not very used to them.
17:10:32 <tikhon> I've found them to be the more readable alternative a lot of the time
17:10:43 <shanse> I concour
17:10:50 <quchen> The GHC wiki gives this example: `parsePacket (bits 3 -> Just (n, (bits n -> Just (val, bs)))) = ...`
17:11:12 <tikhon> then again, that could be because I've only used them in a few cases where they were particularly helpful
17:11:53 <quchen> I guess I'll do that as well. Try to avoid except when they're awesome. (Not like TH, which I try to avoid even when it's awesome) ;-)
17:41:25 <notasi_> @src liftIO
17:41:25 <lambdabot> Source not found. I am sorry.
17:41:46 <tikhon> notasi_: that's defined as part of a typeclass
17:41:58 <tikhon> MonadIO
17:42:14 <tikhon> it's going to be different for every type that implements it
17:42:26 <notasi_> @type lift
17:42:27 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
17:50:16 <erisco> how can I jam a print statement into my function for debugging purposes?
17:50:29 <orzo> Debug.trace
17:50:52 <tikhon> @ty trace
17:50:53 <lambdabot> Not in scope: `trace'
17:50:53 <erisco> oh right sorry
17:50:54 <erisco> read the signature wrong
17:51:06 <tikhon> @ty Debug.Trace.trace
17:51:07 <lambdabot> String -> a -> a
17:51:10 <erisco> I have an exponential explosion where I am not expecting one :)
17:51:19 <tikhon> a useful trick is to put the trace in a guard
17:51:33 <tikhon> | "foobar" `trace` False = undefined
17:53:07 <erisco> hmm this really isn't behaving like I'd expect
17:54:23 <erisco> even though my function would clearly be called many times, the trace is only printing once
17:55:58 <erisco> curious... it seems to depend where I put it in the function
17:56:03 <erisco> (it is recursive)
17:56:49 <NemesisD> why is a dependency on happy always a pain in the ass in any project
17:58:02 <erisco> this is highgly erratic
17:58:27 <erisco> I suppose there is no guarantee where the print statement is actually going to be inserted into the code
17:58:34 <edwardk> NemesisD: is happy making you sad?
17:59:02 <NemesisD> lol
18:00:14 <joelteon> the names for some and many seem backwards to me
18:00:40 <edwardk> some implies there is at least 1
18:00:43 <edwardk> many was more historical
18:05:27 <tikhon> erisco: the print will only happen if its expression gets evaluated
18:05:46 <erisco> tikhon, even so, I am having odd behaviour
18:05:58 <tikhon> hmm, like what?
18:07:30 <fylwind> is there a more sane way of writing "instance Num a => MyClass a"? (without UndecidableInstances)
18:08:00 <danharaj> That's probably not what you want.
18:08:10 <arkeet> what exactly is MyClass supposed to be?
18:08:53 <fylwind> a class that is supposedly generalizes Num, for example
18:09:12 <danharaj> if the class generalizes Num then it should be defined as class Num a => ...
18:09:25 <geekosaur> that would be more specific than Num, not more general
18:09:38 <danharaj> yes true
18:09:42 * danharaj is in the opposite category
18:10:20 <fylwind> so i take it there's no way out of this then?
18:10:32 <danharaj> fylwind: you can make a newtype
18:10:42 <danharaj> make the instance for the newtype
18:10:51 <danharaj> and then whenever you want to use that instance, wrap in the newtype.
18:11:15 <mlamari> Does Brian Hurt (of this video http://vimeo.com/72870631) loiter on here?
18:11:39 <danharaj> sclv_: do you know what Brian Hurt's irc handle is?
18:14:44 <erisco> maybe there are operations for moving memory around that are causing increased complexity
18:14:59 <erisco> how might I diagnose that one?
18:27:27 <erisco> mm found the problem by inspection. never mind
18:27:58 <tikhon> that's good to hear
18:28:10 <tikhon> what was it, roughly?
18:29:03 <erisco> a logical error... an incorrect assumption of the type of data being passed through the algorithm
18:29:10 <tikhon> ah
18:29:37 <erisco> wasn't exponential, but quadratic. it isn't such great news because now I have to figure out what to do about it :P
18:29:48 <tikhon> did using trace help?
18:29:52 <erisco> no
18:30:12 <tikhon> do you know about the GHCi debugging facilities?
18:30:19 <erisco> yes
18:30:51 <tikhon> it too me quite a while to learn about them when I first started :P
18:31:04 <erisco> well, I haven't found them very useful yet
18:31:19 <erisco> following the execution of the program is difficult
18:31:45 <tikhon> yeah, that's true
18:32:02 <tikhon> most of the time, it shows me that I forgot something obvious
18:32:35 <tikhon> but that saves me going through increasingly convoluted hypotheses because I missed the simplest one :D
18:34:49 <erisco> tikhon, well, I suppose that applies here, because between yesterday and today I made an erroneous simplification based on forgetting what I really wanted to do
18:34:56 <erisco> results are correct, perf isn't
18:37:59 <erisco> how keen is Haskell on acronyms in place of full names?
18:38:14 <erisco> if that is taboo, what shorter thing can I call a ParseResult?
18:38:25 <erisco> I don't really like the camel casing so much
18:38:39 * erisco is using PR right now
18:40:39 <erisco> tikhon, the most powerful debugging method for me is evaluating the program by substitution
18:40:59 <erisco> and I'd very much like a debugging tool which did so automatically :)
18:41:54 <tikhon> for types like that, I usually prefer to have the full name
18:41:55 <pentace> Why aren't instances of a type that is not exported from a module listed on :i TypeClass?
18:42:15 <erisco> tikhon, doesn't look slick like the single word names though
18:42:27 <tikhon> well, I'd be pretty tempted just to call it Result
18:42:50 <tikhon> and then, outside modules where the context is obvious, use it qualified—something like Parse.Result
18:42:53 <erisco> doesn't do well when someone imports your modules
18:42:55 <scshunt> pentace: the type isn't visible, so neither are its instances
18:43:23 <tikhon> but yeah, some standard library modules obvious use acronyms like that: IO and ST, for example
18:43:24 <pentace> Oh, I thought all instances are exported
18:43:36 <tikhon> but I don't think PR is quite as easy to follow as either of those
18:43:38 <erisco> tikhon, ah, you can hide Result on import and then import it explicitly under alias or fully qualified, right?
18:43:46 <tikhon> you could do that, yes
18:44:02 <tikhon> or you could design your entire module expecting it to be import qualified
18:45:30 <erisco> if I have *_T for an alias, would a Haskeller shoot me?
18:45:44 <erisco> this is what C++ does for typedefs
18:45:47 <tikhon> that just looks odd
18:45:54 <tikhon> it really wouldn't fit with normall Haskell code
18:46:02 <erisco> :(
18:46:09 <tikhon> people almost never use underscores
18:46:16 <erisco> well in one part of my code, "Result" is a type, not a newtype
18:46:28 <tikhon> and T usually implies "monad transformer", which could be confusing
18:46:38 <erisco> I could change the other part of the code to be newtype, I guess
18:48:36 <tikhon> yeah, I've never seen any naming conventions explicitly differentiating between uses of type and newtype
18:49:32 <erisco> well I'd have to come up with another name
18:49:39 <erisco> or I have to change the other code to use newtype
18:50:03 <erisco> kind of a bizarre situation I guess
18:50:12 <erisco> I don't think it'll hurt to have it all use a newtype
18:51:12 <pentace> scshunt: My code looks like "type Foo = Bar; newtype Bar = Bar" with instances for Bar. Foo is exported and Bar is hidden. :i doesn't list the instances but it seems I can use them from my code, which is confusing.
18:51:49 <scshunt> huh
18:52:01 <heatsink> instances are global and they can't be hidden.
18:53:19 <heatsink> If you don't export a type from a module, you can still end up using values and instances of that type
18:53:39 <pentace> Why are they not listed on :i then?
18:55:17 <heatsink> :i tries to show only types that you've imported, on the premise that those are the types you care about.
18:55:24 <heatsink> For classes and type families, the "in scope" rule isn't so useful
18:55:33 <heatsink> so it uses some other rule that I don't really know for deciding what to show
18:55:56 <erisco> what prevents you from pattern matching on IO to get the inside stuff out/
18:56:05 <danharaj> it is an abstract data type
18:56:17 <danharaj> besides, there isn't 'stuff' inside of it.
18:56:23 <heatsink> IO is made of functions
18:56:38 <heatsink> and some of those functions are built-in or defined in C code
18:56:46 <erisco> okay, IO may have not been the right example
18:56:48 <pentace> heatsink: Okay, thanks for clarifying
18:57:02 <dagano> ghci commands : how do I inspect an imported module?  ie how see what fcns are defined, possible look at source?
18:57:08 <heatsink> :browse
18:57:11 <scshunt> erisco: because its constructors aren't visible
18:57:13 <scshunt> you don't know what's in it
18:57:14 <heatsink> :browse Data.Map
18:57:27 <erisco> ah of course, hide the constructors
18:57:29 <heatsink> You can't look at source from ghci though
18:57:31 <erisco> that makes sense. thanks
18:57:53 <dagano> it is that easy!
18:58:01 <dagano> no source ?  just hoogle or somesuch for that?
18:58:22 <heatsink> If you know what package it's in, you can look up the source on hackage
18:58:33 <dagano> kthnks
18:58:38 <heatsink> On the documentation for each module, there's a link to the source
19:03:48 <erisco> tikhon, well, guess I don't care... the alias is just better and _T is how I'm going to distinguish it :P
19:05:06 <erisco> otherwise I just have to do a bunch of unboxing in the other code
19:15:25 <greg0987> I'm having trouble installing lambdabot (for goa) with cabal install
19:15:32 <greg0987> it gives me this error: http://pastebin.com/aPNVeXDP
19:15:35 <mauke> The paste aPNVeXDP has been copied to http://lpaste.net/92157
19:17:29 <Zenol> @hoogle Bool -> a -> Maybe a
19:17:29 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
19:17:29 <lambdabot> Control.Exception assert :: Bool -> a -> a
19:17:29 <lambdabot> Control.OldException assert :: Bool -> a -> a
19:17:41 <Zenol> :/
19:19:49 <fylwind> @pl tDraw t = drawTree (show <$> (f t))
19:19:49 <lambdabot> tDraw = drawTree . (show <$>) . f
19:19:52 <Ralith> @djinn Bool -> a -> Maybe a
19:19:52 <lambdabot> f a b =
19:19:52 <lambdabot>     case a of
19:19:52 <lambdabot>     False -> Nothing
19:19:52 <lambdabot>     True -> Just b
19:20:59 <khyperia> what does djinn do?
19:21:13 <applicative> strange error greg0987
19:21:16 <Zenol> khyperia: Try to "proove" Bool -> a -> Maybe a
19:21:44 <Zenol> khyperia: And writing a proof is implementing a function of this type.
19:22:09 <Zenol> Ralith: Seams there isn't many use of this function since it's not part of any package :(
19:22:30 <tikhon> Zenol: this came up earlier—you can use monad comprehensions
19:22:46 <Ralith> Zenol: it's an odd function to want, and certainly not a meaningful proof.
19:23:26 <khyperia> ah
19:24:22 <tfero> hi all!
19:24:56 <tfero> I asked for help a few hours ago about the IO monad
19:25:15 <tfero> and at the end I thought I understood it, but as it turns out I was wrong
19:25:20 <Zenol> tikhon> I want to put a value in an aplicative instance depending of an argument to the function.
19:25:35 <Zenol> tikhon> and the aplicative instance I'm talking about is Maybe.
19:26:38 <tfero> if you consider the following code:
19:26:48 <tfero> import Random
19:26:48 <tfero> i = do g <- getStdGen return (fst (next g))
19:26:48 <tfero> main = do x <- i putStrLn $ show x y <- i putStrLn $ show y z <- i putStrLn $ show z
19:27:34 <scshunt> tfero: please paste it at http://lpaste.net/new/haskell
19:27:35 <jmcarthur> tfero: try lpaste.net
19:27:37 <Zenol> @pl  map (map (zip3 x y))
19:27:38 <lambdabot> map (map (zip3 x y))
19:27:45 <Zenol> @pl \x y ->  map (map (zip3 x y))
19:27:45 <lambdabot> ((map . map) .) . zip3
19:28:50 <khyperia> so @pl just takes a lambda and wiggles it until it can be eta-reduced?
19:29:06 <jmcarthur> khyperia: yeah that's a fine way to think of it
19:29:07 * Zenol wonder if a lens evangelist will comme to tell him he should use some traversable magic 
19:29:31 <edwardk> Zenol: we don't have much for zipping
19:29:32 <jmcarthur> Zenol: i would probably keep the x and lose the y
19:29:42 <tfero> ok, sorry: http://lpaste.net/92159
19:29:45 <jmcarthur> \x -> map . map . zip3 x
19:30:21 <jmcarthur> tfero: so what is your question?
19:30:32 <tfero> so, if i is not a prng, but an actual hw rng,
19:31:09 <tfero> then in order for the code to be correct, it must memorize each returned value
19:31:30 <tfero> so as to support multiple "reads" of the same value
19:31:35 <Zenol> edwardk: I was thinking that lens could reduce any line of haskell to few symbols :(
19:31:41 <jmcarthur> tfero: i don't understand what you mean
19:31:54 <edwardk> it can, just not ones involving zip. those still have a few alphanumeric characters left ;)
19:32:17 <edwardk> :t \x -> map . map . zip3 x
19:32:18 <lambdabot> [a] -> [b] -> [[[c]]] -> [[[(a, b, c)]]]
19:32:27 <edwardk> yeah thats definitely not very lensy
19:32:33 <Zenol> jmcarthur: I have that : map (map (zip3 aligns rcWs)) rows
19:33:23 <tfero> jmcarthur: for me it looks like "i" captures some value, that i'm reading later three times
19:33:42 <jmcarthur> tfero: right. you aren't doing anything that changes it
19:33:57 <jmcarthur> tfero: every time you use getStdGen it's just returning the same thing because it hasn't been updated
19:34:32 <tfero> yes but it's an implementation detail of getStdGen
19:34:37 <jmcarthur> tfero: http://lpaste.net/92159
19:34:44 <jmcarthur> tfero: no, it's semantics
19:35:02 <jmcarthur> *it's the intended semantics of the global StdGen
19:35:21 <jmcarthur> i should have done a couple more things in that lpaste
19:35:25 <jmcarthur> let me do another sessions
19:35:27 <jmcarthur> *session
19:36:19 <jmcarthur> tfero: http://lpaste.net/92162
19:36:37 <jmcarthur> tfero: see? it only changes when you actually do some operation that changes it
19:37:36 <jmcarthur> tfero: note that if you want a fresh one every time you can use newStdGen. however, this is misusing System.Random. you should really be using the updated generate after each thing you generate
19:38:10 <tfero> my problem is a little more theoretical
19:38:14 <jmcarthur> tfero: that is, use getStdGen once and then use only non-IO from there. alternatively, you could just stick to all the *IO things, like that randomIO action i used
19:38:39 <jmcarthur> tfero: it's just that the behavior of getStdGen is not to update the global generator. that's all it is
19:38:48 <tfero> say, i want to create haskell i/f for a hw rng
19:39:02 <jmcarthur> tfero: as my paste shows, if you change the global generator, getStdGen will have different results the next time you use it
19:39:31 <tfero> the type of i/f function would be IO Int
19:39:37 <jmcarthur> sure
19:40:21 <tfero> but then, in order to conform to this behaviour, it must remember each value returned, and also identify which captured value is requested again
19:40:32 <jmcarthur> why does it have to remember anything?
19:43:25 <tfero> right ok, I just tried you example mixed with mine, so my error came from using getStdGen instead of newStdGen (like you said)
19:43:31 <tfero> *your
19:43:46 <tfero> thanks
19:43:49 <jmcarthur> np
19:44:01 <jmcarthur> but again, take note that i don't recomment using newStdGen repeatedly
19:44:05 <jmcarthur> *recommend
19:44:39 <tfero> yes, it's not production code :)
19:44:55 <tfero> duly noted though
19:51:21 <erisco> tikhon, heh, it originally was exponential after all... the problem I spotted was what made it at least quadratic
19:53:31 <meretrix> Is there a more compact syntax for "fromIntegral x / fromIntegral y" where x and y are both of type Int and the result is of type Double?
19:54:03 <shachaf> ((/) `on` fromIntegral) x y  is a thing that exists.
19:54:48 <meretrix> Interesting, but I guess I was just looking for a standard infix operator.
19:55:40 <geekosaur> (/.) = (/) `on` fromIntegral -- now you have e.g. 5 /. 3
20:09:18 <wavewave>  /join #haskell-gsoc
20:10:15 <wavewave> h
20:10:15 <wavewave> hi
20:23:06 <fylwind> is there a guideline for using the strictness annotation (!) in data type declarations? (that is, when is it a gain / loss in efficiency?)
20:24:35 <jmcarthur> for the most part, i don't recommend thinking of it as being for efficiency in the first place (although that is definitely a common use)
20:25:08 <jmcarthur> instead of should just be about whether you want construction to succeed regardless of whether evaluation of its arguments will succeed
20:25:21 <jmcarthur> *instead it should normally just be
20:25:47 <fylwind> i see, thanks
20:26:20 <jmcarthur> that said, it is *usually* a good idea to make fields strict if they contain types that don't have laziness of their own
20:26:28 <jmcarthur> that is, it is usually what you want anyway
20:26:42 <jmcarthur> so for example, and Int field is normally best when strict
20:26:46 <jmcarthur> *an Int
20:27:08 <jmcarthur> and i think there is less point in make a list field strict
20:27:23 <jmcarthur> doesn't mean you shouldn't make it strict, or that you should always make an Int field strict
20:27:41 <jmcarthur> just something to keep in mind, since that is the "common" thing
20:28:54 <dmj`> is there a way to visualize evaluation of haskell code? like mkVideo $ takeWhile (<1000) $ map (2^) [1..]
20:29:38 <dmj`> and it'll pop out an .mp4 of that function evaluating
20:29:43 <dmj`> :)
20:30:36 <flebron> How can I read from, say, file descriptor 6?
20:31:30 <geekosaur> @hoogle fdToHandle
20:31:31 <lambdabot> GHC.IO.Handle.FD fdToHandle :: FD -> IO Handle
20:31:31 <lambdabot> System.Posix.IO.ByteString fdToHandle :: Fd -> IO Handle
20:31:31 <lambdabot> System.Posix.IO fdToHandle :: Fd -> IO Handle
20:32:01 <flebron> Next question then, how does one get a Fd? Say, a Fd representing file descriptor 6? :p
20:32:38 <dmj`> @hoogle fdSocket
20:32:39 <lambdabot> Network.Socket fdSocket :: Socket -> CInt
20:32:40 <shachaf> ghci can answer that!
20:33:02 <shachaf> But note that Fd and FD are two different types in the results above.
20:34:25 * flebron is still not clear on how to create Int -> Fd :s
20:34:52 <dmj`> @hoogle recvFd
20:34:52 <lambdabot> Network.Socket recvFd :: Socket -> IO CInt
20:34:58 <geekosaur> FD is System.Posix.Internals.FD which is CInt
20:35:25 <flebron> This may be a stupid question but what do sockets have to do with this?
20:35:47 <geekosaur> if you prefer Fd, you can chase down what it is via the haddock for System.Posix.IO.ByteString or via :browse and :info in ghci
20:35:58 <flebron> It's also CInt
20:36:36 <geekosaur> so, at worst fromIntegral or toEnum
20:36:47 <flebron> But I don't understand how sockets help me here to build Int -> Fd. Is it literally just fromIntegral?
20:37:04 <geekosaur> I have no idea why Socket was brought up
20:37:05 <flebron> Ah, OK.
20:37:06 <shachaf> fromIntegral works
20:37:10 <shachaf> Fd also works
20:37:16 <geekosaur> if you want a numeric literal, it'll just work. other values may need fromIntegral
20:37:34 <geekosaur> oh, it'd a newtype so it needs the constructor I guess
20:37:42 <geekosaur> Fd
20:38:24 <fylwind> what's the idiomatic way to pop an element from the end of a Seq?
20:38:24 <flebron> Cool, thanks :)
20:42:25 <dmj`> fylwind: I dunno, but you could try last = \x -> index $ (length x) - 1
20:42:36 <dmj`> length is O(1)
20:42:48 <dmj`> index is O(log(min(i,n-i))).
20:42:58 <shachaf> No, Use viewr.
20:43:44 <dmj`> oh cool
20:43:47 <johnw> allButLast (viewr -> xs :> _) = xs
20:44:23 <johnw> i guess that's call init :)
20:44:42 <fylwind> I guess that one looks a lot cleaner than messing with the indices :)
20:44:49 <fylwind> thanks
20:45:41 * johnw is playing with RawFilePath today
20:46:02 <shachaf> I'm surprised you didn't use LambdaCase.
20:46:31 <johnw> lol
20:46:42 <scshunt> <3 lambdacase
20:46:45 <johnw> when I'm able to use a compiler that has it, I will!
20:46:46 <shachaf> Anyway, don't write partial functions. :-(
20:47:04 <johnw> oh, you're right, that was partial :(
20:48:10 <erisco> is template haskell the "go to" for adding a bit of syntatical sugar?
20:48:49 <geekosaur> the most available one, at least. there's SugarHaskell but it's more experimental
20:48:59 <johnw> I think TH is one of those "if you can't find a more natural way" solutions
20:49:32 <erisco> johnw, this is actually related to the lambda thing I was talking about yesterday
20:49:45 <erisco> I figured out that I was wrong-headed about what I was trying to do
20:50:15 <erisco> but, nonetheless, syntatical sugar would be nice.
20:50:23 <shachaf> Oh, LambdaCase doesn't actually work there at all.
20:51:10 <shachaf> Well, maybe with something like (>>>)... foo = viewr >>> \case ... -> ...; ... -> ...
20:51:19 <shachaf> But that's not so great.
20:52:03 <scshunt> sugarhaskell looks intersting
20:52:06 <johnw> foo s = case viewr s of xs :> _ -> xs; _ -> empty
20:52:10 <johnw> that's really not at all bad
20:52:23 <tikhon> erisco: it really depends, but Template Haskell is usually a pretty heavyweight solution.
20:52:43 <erisco> what I have is   \x ->  f <$> x <*> a0 <*> a1 ... <*> an   and with the right function 'g', I can eta reduce the 'x'    g f <$> a0 <*> a1 ... <*> an
20:53:02 <shachaf> It's not, but it involves naming a thing only to immediately use the name exactly once.
20:53:09 <shachaf> Which is presumably what the viewpattern was meant to avoid.
20:53:19 <erisco> so I was hoping to bake 'g' into <$> and call it <#> or something
20:53:32 <shachaf> The trouble with viewpatterns is that they require you to name the *function* many times. foo (f -> ...) = ...; foo (f -> ...) = ... and so on
20:53:34 <erisco> since the arity of 'f' can vary
20:54:12 <johnw> shachaf: yes, and they can't tell you if your pattern matches are exhaustive
20:54:20 <erisco> does that make sense?
20:54:23 <shachaf> They can't?
20:55:19 <johnw> no, https://gist.github.com/6331904 gives that warning
20:55:34 <johnw> Pattern match(es) are non-exhaustive
20:55:35 <johnw>     In an equation for `foo': Patterns not matched: _
20:55:46 <erisco> I'm hoping that template haskell can let you define an operator, ie <#>, whose type and definition varies depending on its arguments
20:56:04 <geekosaur> I doubt it
20:56:15 <tikhon> I'm not sure that's possible with template Haskell, and certainly not easy
20:56:17 <erisco> really? what else would you want metaprogramming for? :)
20:56:30 <tikhon> I dunno—templates?
20:56:33 <johnw> erisco: can you use type classes with type families to do that?
20:56:39 <tikhon> that's what Yesod uses it for :)
20:56:49 <shachaf> Hmm...
20:56:57 <erisco> does my meta-definition of <#> make sense as I explained?
20:57:06 <shachaf> If you add foo (id -> _) then it doesn't complain
20:57:36 <erisco> johnw, I don't know what type families do, so I don't know, but I might take a close look if you can be more confident it will help :)
20:57:41 <shachaf> So that sort of seems like a bug?
20:57:50 <johnw> erisco: sadly, I'm still not confident I understand what you're trying to do
20:58:02 <shachaf> If you remove Bar so the type has just one summand it also doesn't complain.
20:58:11 <erisco> johnw, okay, here is an example using valid Haskell code
20:58:15 <johnw> shachaf: interesting
20:58:21 <shachaf> But it ought to be able to recognize that you're using the same id there, oughtn't it?
20:58:22 <johnw> maybe that is a bug then
20:58:36 <shachaf> At least I know that it only computes the result once.
20:58:52 <shachaf> But I suppose the latter is just an optimization and the former is closer to semantic.
20:59:34 <shachaf> @remember rwbarton [on +RTS --help] <rwbarton> but knowing it exists is half the battle <rwbarton> the other half is knowing it is unique?
20:59:35 <lambdabot> I will remember.
20:59:40 <erisco> johnw,   \x -> f <$> x <*> a       and     flip f <$> a
21:00:14 <erisco> johnw, I can move the left argument of 'f' all the way to the right and eta reduce
21:00:23 <erisco> johnw, correct?
21:00:43 <johnw> if you use (f <$>) . (<*>) a, yes
21:00:51 <johnw> but why is it important to do so?
21:00:59 <erisco> it looks cleaner
21:00:59 <johnw> (sorry, (<*> a))
21:01:03 <erisco> in the way I use it
21:02:13 <erisco> but 'flip' only works for arity of 2
21:02:25 <erisco> and I'd rather not be writing flip at all
21:03:06 <erisco> hence, redfine <$> as <#> which takes the function on the left and transposes it for any arity
21:03:10 <erisco> but that requires code generation
21:03:18 <erisco> hence something like template haskell, maybe
21:03:25 <johnw> :t (<&>)
21:03:26 <lambdabot> Functor f => f a -> (a -> b) -> f b
21:03:33 <johnw> a <&> pure f
21:03:50 <johnw> no, that isn't it
21:04:03 <johnw> anyway, i'm unclear enough that I shouldn't be confusing you more
21:04:41 <khyperia> Is it better to call getLine inside functions that need it, or shove around the string from getContents?
21:05:11 <johnw> khyperia: i don't think there is a universal answer to that
21:05:22 <johnw> i'd say neither: use a pipe or conduit to feed the information to where you need it
21:05:40 <johnw> or, if the data is small, force-read it up-front and then process plain strings
21:05:42 * khyperia is a haskell beginner and has no idea what words mean
21:05:57 <johnw> ah, then maybe play with both and see what suites you
21:06:02 <khyperia> specifically, what's a pipe/conduit?
21:06:15 <johnw> are you familiar with Python?
21:06:32 <khyperia> nope
21:06:42 <erisco> johnw, sorry what I was saying was invalid
21:06:58 <johnw> a pipe/conduit is an abstraction for producing values in one place (like, from reading a file), and consuming them in another place
21:07:06 <erisco> I'm not being helpful in my explanations =\
21:07:22 <johnw> the idea being that resource consumption, and when IO is going to happen, or both deterministic
21:08:27 <tikhon> khyperia: a pipe is just an abstraction for streaming data
21:08:31 <khyperia> ah
21:08:34 <erisco> johnw, let me be more clear this time
21:08:42 <erisco> johnw, I think I've got it straight now
21:08:55 <khyperia> although wouldn't the lazy string by getContents be similar to a stream?
21:09:01 <tikhon> yes
21:09:13 <tikhon> in fact, that's exactly what Pipes et al were designed to replace
21:09:35 <tikhon> those lazy streams have some very unfortunate properties regarding resource usage or even correctness
21:09:56 <tikhon> also, pipes allow you to stream data in two directions
21:10:18 <tikhon> one way to think of them is as a particular kind of coroutine
21:10:25 <khyperia> ah
21:10:31 <tikhon> but this is only really useful if you're already familiar with coroutines in another setting—are you?
21:10:40 <johnw> I they are exactly a particular kind of coroutine :)
21:11:08 <erisco> @pl \a b c -> f b c a
21:11:08 <lambdabot> flip (flip . f)
21:11:18 <tikhon> johnw: even if they are, it is not necessarily a good way to think of them; that depends on your own experience :D
21:11:44 <erisco> johnw, I have     flip f2 <$> a      flip (flip . f3) <$> a <*> b     and so on
21:11:58 <johnw> tikhon: true, I was just confirming your explanation
21:12:52 <erisco> johnw, in English, my f* functions desire a certain argument order for clarity, but it turns out that I can't give the first argument until later
21:15:10 <erisco> so... what would be better than using 'flip' and flip (flip . f)  and so on, which will really ugly up the code, is to redefine <$> as <#> which will transpose the function (ie, make the first argument the last)
21:15:25 <erisco> am I explaining this clearly thus far?
21:15:52 <johnw> erisco: I think so
21:16:35 <erisco> okay. given that the natural way to transpose the function is ugly, especially since the arity of 'f' can vary, I am looking to use code generation
21:17:02 <erisco> with the hopes that I can define <#> as a meta function which, at compile time, can look at the arity of the function on the left
21:17:35 <erisco> and generate a function which does the transpose (and then the normal <$>, of course)
21:17:39 <scshunt> erisco: template haskell would be the usual way of doing this, but it's not syntactic sugar
21:17:56 <erisco> scshunt, what do you mean by "not syntactic sugar"?
21:18:06 <scshunt> erisco: you could not write a type-dependent function like that
21:18:13 <tikhon> this sounds like something that you could probably do with typeclasses
21:18:22 <tikhon> using an approach like printf
21:18:30 <tikhon> but maybe I am not fully understanding the problem
21:18:51 <scshunt> you could do $(flipper f), with 'flipper' performing the flip you want
21:18:58 <scshunt> but you couldn't escape the splice brackets
21:19:19 <erisco> the transposing part is equivalent to what I posted earlier
21:19:19 <erisco> http://pastebin.com/yTCGz6Sc
21:19:20 <mauke> The paste yTCGz6Sc has been copied to http://lpaste.net/92153
21:19:33 <scshunt> (you could do something like $(f <#> args) as well, in which case TH would be able to interpret the contents the way you want. But you still can't get rid of the splice
21:19:46 <erisco> I could write   pp4 f <$> ...   but it is simply ugly
21:20:41 <scshunt> you could also use a quasiquoter
21:20:45 <scshunt> but you still have the same fundamental issue
21:20:57 <erisco> (<#>) f = fmap (pp* f)
21:21:33 <scshunt> erisco: I get what you're trying to do
21:21:39 <erisco> yay :)
21:21:45 <johnw> he wants something like ??, for applicatives
21:21:47 <scshunt> erisco: I'm telling you you can't do it :)
21:21:58 <scshunt> erisco: the best you could get is something like http://hackage.haskell.org/packages/archive/applicative-quoters/0.1.0.8/doc/html/Control-Applicative-QQ-Idiom.html
21:21:59 <erisco> even with template haskell? that seems puzzling to me
21:22:01 <johnw> f <$> ?? <*> x, f <$> a <*> ?? <*> x
21:22:07 <johnw> i think
21:22:21 <scshunt> erisco: Template Haskell requires you to invoke it
21:22:35 <scshunt> erisco: It does not allow for arbitrary dependent types
21:23:09 <erisco> :t ??
21:23:10 <lambdabot> parse error on input `??'
21:23:14 <erisco> :t (??)
21:23:14 <lambdabot> Functor f => f (a -> b) -> a -> f b
21:23:45 <johnw> it's an operator form of flip, from the lens library
21:24:02 <scshunt> @src (??)
21:24:03 <lambdabot> Source not found. You untyped fool!
21:24:05 <scshunt> sigh
21:24:14 <erisco> lambdabot is merciless
21:24:14 <johnw> > ?? + 2 $ 3
21:24:15 <lambdabot>   <hint>:1:1: parse error on input `??'
21:24:19 <johnw> aw
21:26:08 <edwardk> ?? is still an operator
21:26:08 <lambdabot>  is still an operator
21:26:19 <johnw> oh, right
21:26:22 <edwardk> > flip ?? id
21:26:23 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable c0)
21:26:23 <lambdabot>    arising from a use ...
21:26:25 <johnw> > (+) ?? 3 $ 3
21:26:26 <edwardk> :t  flip ?? id
21:26:27 <lambdabot> (a -> (a1 -> a1) -> c) -> a -> c
21:26:27 <lambdabot>   6
21:26:47 <edwardk> :t  traverse ?? [1,2,3]
21:26:48 <lambdabot> (Num a, Applicative f) => (a -> f b) -> f [b]
21:27:13 <edwardk> :t foldl (+) ?? [1,2,3,4]
21:27:14 <lambdabot> Num b => b -> b
21:29:02 <erisco> well maybe there is another way I can massage the definitions
21:34:24 <erisco> johnw, are type families and assist here?
21:35:13 <johnw> I'm not sure, erisco
21:35:26 <erisco> okay I'll do some reading on them then.
21:35:38 <erisco> this is such a slight thing but it makes a big presentation difference
21:35:48 <scshunt> erisco: no, they aren't
21:35:58 <scshunt> hmm... actually
21:36:24 <erisco> I don't care how stupid or hacky or whatever
21:36:35 <johnw> well, in _that_ case
21:36:39 <erisco> preprocessor it is :P
21:36:43 <johnw> ghc allows you to create program formatters
21:36:56 <johnw> which let you do arbitrary compile-time massaging of file contents
21:37:06 <erisco> I'll try for something sane first. let me look at type families. hope I can grok them in a few hours
21:37:07 <johnw> the true last stop for the crazy train
21:39:36 <erisco> actually...
21:40:39 <erisco> eh, nah. I was thinking of just implementing Show explicitly so it would print the data transposed, but I really want the data type definitions to be clear too
21:40:59 <levi> The integration of preprocessors with ghc is actually pretty nice.
21:42:45 <levi> HSX/HSP and SHE are a couple of interesting examples.
21:44:11 <erisco> scshunt, just at a cursory glance, it seems that with instances for each function arity (say go up to 9, or whatever), it'd work
21:44:39 <erisco> but I'm sure I'll find problems as I go on :P
21:46:51 <scshunt> erisco: pretty sure this can't be solved away with type families
21:52:49 <erisco> I'm starting off on this correctly right? http://lpaste.net/92164  I get conflicting definitions
21:53:04 <pharaun> oh whoa
21:53:06 <pharaun> pretty
21:53:14 <pharaun> that got prettified up nicely
21:53:39 <erisco> pharaun, sorry was that at me?
21:53:49 <pharaun> erisco: sorry, lpaste :)
21:54:46 <tikhon> maybe it's just me, but now the syntax highlighting seems a bit too subtle
21:59:31 <erisco> I find this simple description to be quite lucid http://byorgey.wordpress.com/2010/07/06/typed-type-level-programming-in-haskell-part-ii-type-families/
21:59:47 <erisco> but I am slightly perplexed... so if we take all the type family stuff out, 'plus' still works...
22:00:09 <erisco> the type family allows us to use the function to... generate a type?
22:00:28 <johnw> type families are one way to expression functions on types
22:00:41 <johnw> the simplest kind of type function is a parameterized type
22:00:56 <johnw> like, data Foo a = Foo a, is a type function a -> Foo a
22:01:12 <johnw> but it only allows type functions of a particular kind, which can be rather limiting
22:01:27 <johnw> GADTs open this up, let you go from a -> Foo b, for any b you like
22:01:53 <johnw> and type families go even further, letting you go from a -> b, for any for which an instance exists relating a to b
22:02:06 <erisco> mm my head is spinning about the implications
22:02:18 <johnw> the main point is this
22:02:23 <johnw> you have a type you know about, a
22:02:34 <johnw> and you want your code to take some a, and yield a new type based on that type
22:02:52 <johnw> type families make creating such relationships in code easy to do
22:03:09 <johnw> type family Foo a ; type instance Foo a = b
22:03:13 <erisco> a -> b  and  a -> b -> c  are seen as the same type, though?
22:03:20 <johnw> well, not b
22:03:26 <johnw> type instance Foo Int = Char
22:03:30 <johnw> type instance Foo Float = Bool
22:03:32 <johnw> whatever you like
22:03:46 <johnw> a -> b and a -> (b -> c), are not the same type
22:04:08 <johnw> you "invoke" the type function in this case by applying Foo to a type
22:04:11 <erisco> okay, so when I say this: http://lpaste.net/92164  why does ghc tell me I have a conflicting instance?
22:04:33 <erisco> and feel free to laugh at how stupidly I am trying to use type families
22:04:50 <johnw> I think in that case the first type subsumes the second
22:05:09 <johnw> what if you flip the declaration order?
22:05:33 <erisco> still complains
22:05:37 <erisco> that'd be kind of gross if it didn't
22:06:18 <erisco> what else would you have besides '*' in  type family Foo f :: * ?
22:06:24 <johnw> * -> *
22:06:28 <johnw> (* -> *) -> *, etc.
22:06:36 <erisco> okay
22:06:36 <johnw> your family could be a family of Monads
22:07:08 <Zenol> What's the name of the extension fct Type{..} = ?
22:07:13 * hackagebot language-mixal 0.1 - Parser, pretty-printer, and AST types for the MIXAL  assembly language  http://hackage.haskell.org/package/language-mixal-0.1 (JonathanDaugherty)
22:07:25 <johnw> RecordWildcards
22:07:39 <Zenol> johnw: ok, thanks :)
22:08:13 <erisco> johnw, so it is because on line 2, c could be (c -> d) ?
22:08:17 <erisco> that is a shame
22:08:25 <johnw> i think so
22:08:32 <johnw> but I'm not completely sure
22:08:56 <erisco> so what it needs is a resolution system that looks for the most specific match
22:09:17 <erisco> however that is determined (slippery slope)
22:09:29 <erisco> but hey, c++ managed :)
22:10:52 <edwardk> woot. all the mask logic is gone from sparse
22:10:55 <edwardk> https://github.com/ekmett/sparse/blob/master/src/Sparse/Matrix.hs#L315
22:11:14 <edwardk> it is all xor-based 'most significant difference' testing now
22:11:16 <johnw> woohoo!
22:11:25 <edwardk> and it got 2x faster in exchange
22:11:43 <edwardk> that bodes well for my intmap changes being viable ;)
22:11:50 <MedDev> edwardk the man, the machine, THE LEGEND
22:12:31 <edwardk> it also performs remarkably close to the performance of a naive dense matrix multiplication at around 128x128
22:12:39 <edwardk> i was expecting it to get slaughtered
22:13:11 <edwardk> i'm sure as it scales up the extra log factor starts to eat it away
22:13:52 <edwardk> MedDev: =)
22:21:13 <erisco> okay, so lets say I fix this with a preprocessor
22:22:45 <fylwind> does it make sense for a zipper (of say a list or tree) to be an Applicative?
22:22:48 <erisco> do I only get to work on the source file as text?
22:24:44 <johnw> your preprocessor can parse the Haskell file
22:25:50 <erisco> well, yes, of course, but I need semantic information too
22:26:04 <erisco> wondering how much compiler help you get
22:27:05 <erisco> well, okay, I just thought of one suboptimal thing that will be enough to tide things over
22:27:46 <dmj`> is there a language extension for guards in do statements?
22:28:23 <edwardk> :t Control.Monad.guard
22:28:24 <lambdabot> MonadPlus m => Bool -> m ()
22:28:56 <edwardk> > do x <- [1..10]; guard (x<=5); return (x*x)
22:28:57 <lambdabot>   [1,4,9,16,25]
22:30:54 <hpaste> dmj pasted “something like this?” at http://lpaste.net/92165
22:32:30 <levi> Oh my, Carl Hewitt is claiming that mathematics proves its own consistency on LtU.
22:32:44 <johnw> dmj: MultiWayIf would allow something like that
22:33:04 <johnw> just replace "c |" with "if |", and "= print" with "-> print"
22:34:17 <erisco> @pl \x y z -> f y z x
22:34:17 <lambdabot> flip (flip . f)
22:35:28 <erisco> @pl \f x y z -> f y z x
22:35:28 <lambdabot> flip . (flip .)
22:36:18 <scshunt> erisco: my suggestion for you would be something like idiom brackets
22:36:23 <scshunt> which I linked you earlier
22:37:49 <erisco> @pl \f y z x -> f x y z
22:37:49 <lambdabot> (flip .) . flip
22:38:27 <johnw> erisco: is all this aggrevation just to save a little bit of typing down the line?
22:39:15 <erisco> I'm giving up and going with something close enough
22:39:27 <hpaste> dmj annotated “something like this?” with “something like this? (annotation)” at http://lpaste.net/92165#a92166
22:39:29 <erisco> I just wanted lambdabot to figure out the flips for me :P
22:39:43 <dmj`> johnw: very cool
22:39:46 <johnw> yeah, having fancy DWIM type syntax is sometimes not worth the time it seems to save
22:40:24 <johnw> i've learned to really enjoy Haskell's explicitness about everything.  It makes code readable the way that C can be, in that it's always pretty clear what's going on
22:40:52 <erisco> I've got what I consider a neat program for my undergrad research project, and I just want to beautify as much as I can
22:41:21 <erisco> it won't do good to make the presentation obscure by needless syntatical woes
22:42:41 <erisco> but what I did was take the function f and just defined f' elsewhere that transposes the arguments
22:43:16 <erisco> it is hidden away enough that I can still make the presentation make sense, I think
22:43:42 <erisco> and the code is concise in the right spots
22:50:00 <erisco> really feeling catharsis having finally solved the last big thing. just in time too... has been a lot of work
22:57:14 * hackagebot bits 0.3.3 - Various bit twiddling and bitwise serialization primitives  http://hackage.haskell.org/package/bits-0.3.3 (EdwardKmett)
23:02:19 <NemesisD> anyone heard if there's a rough date for cabal's next release
23:03:56 <johnw> before ICFP
23:05:25 <NemesisD> i've hit a case where a dependency yesod-platform specifies doesn't work with cabal HEAD. the fix is in the next patch level up
23:06:55 <NemesisD> i guess i may fetch yesod-platform and bump the version for development and wait it out
23:56:16 <Zenol> I'm done with my writer. If you have time to lost, feel free to criticise and give me advice to simplify the source code (its my first 'True' projet in haskell) https://github.com/Zenol/scripts/blob/master/Text/Pandoc/Writers/Dvp.hs
