00:01:11 <janiczek> Hi guys, do you know of some functional way to generate combinations in colex order? I know there's always FXT's bit fiddling - http://cl.ly/image/2q0e3R0P3H43 - but I guess it would be shame to do such unreadable bit fiddling when there's probably a functional way ...
00:57:56 <haasn> colex comparison of tuples seems like “comparing swap”, so “sortBy (comparing swap)” might come in handy in ordering a list of tuples colexicographically
01:03:12 <haasn> > sortBy (comparing reverse) [[x,y,z] | x <- [0..5], y <- [x+1..5], z <- [y+1..5]] -- janiczek
01:03:13 <lambdabot>   [[0,1,2],[0,1,3],[0,2,3],[1,2,3],[0,1,4],[0,2,4],[1,2,4],[0,3,4],[1,3,4],[2...
01:04:44 * hackagebot haskell-src-exts 1.14.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.14.0 (NiklasBroberg)
01:06:09 <janiczek> wow. I'm going to wrap my brain around how that does the right thing so declaratively... :) thanks!
01:06:35 <haasn> > sortBy (comparing reverse) [[x,y,z] | x:xs <- tails [0..5], y:ys <- ys, z <- ys] -- more elegant
01:06:36 <lambdabot>   Not in scope: `ys'
01:06:36 <lambdabot>  Perhaps you meant one of these:
01:06:36 <lambdabot>    `xs' (line 1), `y' (...
01:06:44 <haasn> > sortBy (comparing reverse) [[x,y,z] | x:xs <- tails [0..5], y:ys <- tails xs, z <- ys]
01:06:45 <lambdabot>   [[0,1,2],[0,1,3],[0,2,3],[1,2,3],[0,1,4],[0,2,4],[1,2,4],[0,3,4],[1,3,4],[2...
01:08:38 <janiczek> if there's reverse, will it work with infinite list? these reverses are of the inside of [0,1,2] for example? or does it generate the whole thing and then sorts it to colex?
01:08:48 <Maxdamantus> > reverse [1..]
01:08:59 <lambdabot>  Terminated
01:09:14 <haasn> janiczek: yes it will generate an infinite sequence
01:09:57 <haasn> ‘reverse’ only fails when the inner lists have an infinite length, but that much should be clear :P
01:10:24 <haasn> janiczek: keep in mind though that an infinite sequence here is not very useful, it will just be [0,1,n] for all n
01:10:30 <haasn> (as I understand it)
01:11:55 <janiczek> yeah I've been able to do that with replicateM ... :)
01:13:01 <janiczek> for now I'll try your version with some big-enough constants ... thanks ... :)
01:13:17 <haasn> replicateM 3 [0..n] would contain [0,0,0] and stuff though mind
01:14:18 <haasn> in general, Haskell can't reason very well about infinite lists, eg. all f . filter f  is ⊥ for any infinite input, despite it logically holding true
01:14:33 <haasn> > sum (repeat 0)
01:14:41 <lambdabot>   mueval-core: Time limit exceeded
01:14:51 <haasn> hence in practice any use case would involve finite constants
01:15:49 <quicksilver> (all f . filter f) isn't logically true, it's logically _|_. But I know what you mean.
01:16:51 <haasn> I didn't say True ;-) but yeah
01:20:16 <haasn> > let lexN 0 _ = [[]]; lexN n xs = do { y:ys <- tails xs; fmap (y:) (lexN (n-1) ys) } in sortBy (comparing reverse) $ lexN 3 [0..5]
01:20:18 <lambdabot>   [[0,1,2],[0,1,3],[0,2,3],[1,2,3],[0,1,4],[0,2,4],[1,2,4],[0,3,4],[1,3,4],[2...
01:20:19 <haasn> generalized
01:25:09 <haasn> A bit ugly though, maybe somebody can find a way to improve it? Time for me to sleep
01:29:30 <mel-> Hi, I'm writing a game in haskell (with Gtk2hs). For this I need to (1) play audio files (2) play audio sounds simultanously (3) cancel the playing of specific audio files currently in progress. Any ideas how to implement this? So far I had no luck finding a suitable sound library. I guess I could also just write a thin layer to control an mplayer instance. But for this, I would need to learn about threaded
01:29:31 <mel-> programing in Haskell, I guess.
01:29:48 <johnw> isn't there a set of SDL bindings?
01:32:37 <quicksilver> at least 2 sets of SDL bindings I think
01:32:59 <quicksilver> and openAL can probably do that although it's a weird interface
01:35:15 <mel-> the SDL-mixer package looks good.
01:35:17 <mel-> thanks
01:37:27 <dvyal> Hi all! A friend of mine recently showed me a strange profile. https://code.stypi.com/jevnphma . There SSC for dododo is responsible for a large percent of cpu time and allocations. Can anyone explain, why? It seems strange given the fact all the work is done inside other SCCs.
01:37:33 <exicer> I was just trying to install hlint from cabal, but there seems to be a bug in it ?
01:38:18 <exicer> http://lpaste.net/91988
01:39:45 <haasn> let lex f xs = do { y:ys <- tails xs; fmap (y:) (f ys) } in const [[]] & lex.lex.lex $ [0..5] -- janiczek: just one more!
01:39:51 <haasn> > let lex f xs = do { y:ys <- tails xs; fmap (y:) (f ys) } in const [[]] & lex.lex.lex $ [0..5]
01:39:54 <lambdabot>   [[0,1,2],[0,1,3],[0,1,4],[0,1,5],[0,2,3],[0,2,4],[0,2,5],[0,3,4],[0,3,5],[0...
01:40:07 <haasn> add the usual sortBy (comparing reverse) etc.
01:40:42 <janiczek> haasn: you're incredible :D
01:41:51 <mxf> I installed "foo" from hackage, now i want to install a development version of it from git. Should I execute something like "ghc-pkg unregister foo-0.23.5" prior to "cd $src && cabal install"?
01:42:05 <haasn> or: lexN n = foldr id (const [[]]) $ replicate n lex
01:49:55 <johnw> mxf: yes
01:50:02 <johnw> although you don't really need to
01:52:20 <mxf> johnw, thanks!
01:52:21 <mxf> johnw, are there any corner cases when calling "ghc-pkg unregister" is needed?
01:52:38 <johnw> there could well be, but I can't think of one off hand
01:55:26 <Taneb> It doesn't remove executables in .cabal/bin
01:55:43 <bergmark> also doesn't remove data-files
01:55:56 <johnw> i use cabal-delete for that
01:56:20 <bergmark> oh didn't know about that one
01:56:28 <johnw> it's only on github
01:56:32 <johnw> but it's quite handy
01:56:35 <johnw> does recursive removal too
01:56:53 <merijn> edwardk: I have a really pedantic nitpick about your bound tutorial on School of Haskell
01:57:28 <mxf> johnw, thanks for that cabal-delete tip :)
02:12:42 <johnw> i just used -boot files for the first time today
02:12:48 <johnw> pretty nifty that GHC allows that
02:16:13 <Kinnison_> If only it did it for itself :-(
02:16:25 <johnw> true, it does seem like that should be possible
02:16:37 <johnw> for every module, compile a -boot to represent it exports
02:17:04 <johnw> actually, I wonder why it doesn't just do that, to optimize for the most common case?
02:17:42 <mel-> hooray, my jeopardy game can play the jeopardy theme. :)
02:18:40 <johnw> good job!
02:20:10 <mel-> the other day we have been brazing quiz buzzers for this project.
02:21:44 <merijn> johnw: It's my pet peeve that GHC doesn't follow the standard there :(
02:22:10 <merijn> johnw: The reason it doesn't do that is that GHC HQ doesn't think it's worth the investment of manpower to implement
02:22:29 <merijn> If someone would volunteer I'm pretty sure it'd get accepted
02:25:15 <quicksilver> because secretly everyone thinks that cyclic depedencies are immoral and the world is a beter place if you're encouraged not to use them
02:26:29 <johnw> merijn: that sounds reasonable actually
02:26:39 <johnw> i could go with quicksilver too
02:27:08 <quicksilver> especially if he improved his speling.
02:27:39 <quchen> hs-boot files are what kept me away from implementing cyclic modules. How ironic.
02:27:45 <merijn> Cyclic dependencies are a lovely and shining beacon of code structuring!
02:28:48 <merijn> It sucks when I have to restructure my entire module layout for the 5th time to accommodate a change I made that makes an import cyclical and have to somehow factor it out...
02:28:59 <merijn> It's manually breaking #include cycles all over again...
02:29:04 <johnw> well, in my case I have event logging code, which needs to use the database; and the database initializing itself using a module that needs to do event logging
02:29:23 <merijn> johnw: Yeah, that sorta thing happens often for me
02:29:35 <Kinnison_> merijn: At least #includes commonly don't cycle since implementation and interface are separated
02:29:54 <merijn> Kinnison_: ...
02:30:07 <merijn> Kinnison_: You must not have worked with very many significant C code bases
02:30:20 <Kinnison_> merijn: Manylots
02:30:30 <Kinnison_> merijn: Up to and including the Linux kernel
02:30:42 <merijn> Kinnison_: Even fairly small codebases (a couple of K files) run into cylces all the time
02:31:02 <Kinnison_> merijn: maybe I've just been lucky
02:31:21 <quicksilver> my experience is that all C codebases have cycling includes
02:31:30 <quicksilver> hence the #define _H_FOO convention
02:31:45 <quicksilver> and various compilers incompatible solutions like #pragma once
02:32:05 * Kinnison_ tends to find that those are usually more for the fact that leaf includes are often repeated, rather than being there to break cycles
02:32:40 <merijn> quicksilver: Sure, but I mean that even with those you end up with headers depending on other headers so you need to include in the right order to avoid cycles where something isn't defined yet when it includes another header
02:32:47 <johnw> well, boot files are really like haskell header files in a way
02:33:14 <johnw> it should be easy to write a tool with haskell-src-exts to auto-generate a -boot file
02:33:19 <merijn> So the #define/#ifndef thing is really not sufficient to avoid C header cycle problems
02:35:47 <quicksilver> merijn: Kinnison : you're right, I was talking rubbish. That does help cyclic includes at all, it just stops multiple copies.
02:36:13 <quicksilver> well, it only helps against 'inessential' or 'accidental' cyclic includes
02:36:21 <quicksilver> it doesn't actually solve the case where you needed the definition.
02:36:42 <Kinnison> y'know, it's rare I'm told I'm right
02:36:44 * Kinnison basks in it
02:37:36 <quchen> merijn: Is there a way to avoid cyclic dependencies in general? What often works in practice is just adding the mutuality to a separate module, but sometimes that may not be enough
02:37:59 <quicksilver> separating core data type into a separate module
02:38:05 <quicksilver> breaks some kinds of cycle
02:38:05 <johnw> yeah, I could have done that
02:38:09 <johnw> and until today I did
02:38:19 <quicksilver> generally, stratifying the code into layers
02:38:21 <johnw> but this time I had just read about boot files and it was a much easier way to go
02:38:27 <quchen> quicksilver: Yes, that's common practice (however, it's a good idea to do this regardless of cyclic deps)
02:38:45 <johnw> the problem with doing that is that you sometimes disassociate common code
02:38:53 <bartavelle> exactly
02:39:00 <johnw> i'd rather have all code dealing with X and Y in two modules, than X, Y and some X+Y
02:39:06 <quchen> quicksilver: I'm thinking of "data A = A B; data B = B A" in separate modules
02:39:14 <bartavelle> you start with a "types" module, and end up with tons of helper functions in this
02:39:45 <bartavelle> next thing you know you have to build an internal prelude for your module
02:39:46 <merijn> quchen: Yes, dump everything in one module
02:39:51 <quicksilver> quchen: in extremise, push the mutual recursion into a parameter.
02:40:03 <quicksilver> data A t = A t; data B t = B t;
02:40:17 <merijn> quchen: I disagree that pushing types to a separate module is good practice
02:40:28 <quchen> merijn: Common types, not types in general.
02:40:30 <quicksilver> and then in another module which imports both, type ActualA = A B
02:40:31 <merijn> Types should go into the module with the code associated with that type
02:40:47 <quicksilver> however, that's certainly not always a good thing.
02:40:59 <quicksilver> (you can do the same transformation with mutually recursive functions too)
02:41:04 <merijn> I mostly don't even need code from my circular imports, just data/newtype/type definitions
02:41:25 <merijn> The problem is when A needs those from B and B needs those from A + code from A
02:41:38 <quchen> merijn: You have to find a good middle ground. If you create a shared module for every combination of modules you'll grow your source file tree with n^2.
02:41:39 <merijn> Now I need to split the types of, breaking my nice modularity
02:41:40 <HugoDaniel> w000t my copy of "parallel and concurrent programming in haskell" has just arrived :D
02:41:46 <HugoDaniel> coolness :D
02:41:58 <quchen> merijn: Eh, not n^2. Ignore that. Anyway, it becomes a mess.
02:42:01 <quicksilver> quchen: yes, it's case by case really.
02:42:02 <johnw> HugoDaniel: enjoy!
02:42:10 <johnw> i just wish the book were longer so I could still be reading it
02:42:10 <quicksilver> part of the problem is that modules don't really mean anything
02:42:12 <merijn> quchen: Yes, hence my annoyance when a small code change forces me to restructure my entire module layout for 30+ minutes
02:42:23 <quicksilver> they're just source files, they're not actually a unit of abstraction.
02:42:24 <HugoDaniel> amazing :D
02:42:31 <merijn> Just to break all the cycles and obtain a "sensible" layout
02:42:40 <quicksilver> the other part of the problem is that modules mean far too much
02:42:49 <merijn> .hs-boot is even worse, as then you just duplicate code
02:43:09 <merijn> iirc anyway
02:43:15 <quicksilver> they're deeply embedded in the GHC compilation technique and changing module arrangement can radically change the way your code compiles.
02:43:17 <johnw> merijn: doesn't an .hs-boot just duplicate type declarations?
02:43:40 <quchen> merijn: I think that's a pretty fundamental problem. Not sure whether automatic cyclic dependencies make it much better.
02:43:42 <johnw> appears this is an active ticket: http://ghc.haskell.org/trac/ghc/ticket/1409
02:46:17 <merijn> quchen: It would
02:46:46 <merijn> quchen: Because all cycles I have so far are trivial, mostly just needing datatypes so proper recursive imports would work fine
02:47:40 <merijn> So there is really no fundamental problem there
02:48:05 <quchen> Hm.
02:48:23 <quchen> I guess I wasn't bitten by it enough to be seriously annoyed by the current state.
02:48:59 <quchen> On the other hand you're right, it's possible with the hs-boot hack so the functionality is there, so why not make it convenient
02:49:10 <merijn> It's not a big problem if your initial design works out, but if you start writing standalone pieces and then realise "oh, actually this needs access to that" and change an import and suddenly have to restructure to break cycles it's quite annoying
02:49:48 <quchen> merijn: I've had that in the past, but when refactoring I didn't think "if only cyclic was possible".
02:49:54 <quchen> Maybe I should have.
02:50:10 <merijn> quchen: Then your cycle wasn't complex enough :p
02:50:52 <quchen> merijn: In retrospect I think cyclic stuff may have saved me an hour or so.
02:51:17 <quchen> merijn: Also, in retrospect I'm getting angry at myself for not realizing it at the time. Thanks for teaching me about cyclic deps I guess haha
03:09:15 <ocharles> dreixel: instant-generics worked a treat in my little prototype
03:09:24 <ocharles> dreixel: also, nice paper - very readable :)
03:12:05 <dreixel> ocharles: ah, great that it worked
03:12:13 <dreixel> but perhaps you'd prefer using GHC.Generics directly?
03:12:20 <ocharles> dreixel: that would be best
03:12:40 <ocharles> dreixel: is there any reason the approach for instant-generics can't apply for ghc.generics? Or is it simply "because it's not done"?
03:12:55 <dreixel> ocharles: the latter, I think
03:12:58 <ocharles> ok
03:13:02 <dreixel> but also because I don't think it's a very principled approach
03:13:49 <dreixel> it might be possible to do something nicer for GHC.Generics, though
03:14:08 <dreixel> at least in the simple case where there is only one index, and that is the last type variable of the datatype (and it is of kind *)
03:14:11 <dreixel> which is your case.
03:14:33 <ocharles> Yea
03:14:35 <dreixel> one good thing of your GADT is that it does not introduce existentially-quantified variables
03:14:48 <ocharles> right, that seems to be the bit that makes it all quite easy
03:14:48 <dreixel> which would for us to use the type family X trick, which is not very pretty
03:15:01 <ocharles> I don't think it even needs the X type family
03:15:05 <dreixel> but, without it, we'd just need to be able to represent type equalities in the representation
03:15:05 <ocharles> at least, it didn't in instant-generics
03:15:29 <dreixel> right.
03:15:30 <ocharles> oh you mean if I had used existentially-quantified type variables
03:16:02 <dreixel> I didn't manage to build your code (due to dependencies), but does it even need the indexing? can't you just replace the constructor return type by |Tree a|?
03:16:11 <dreixel> or are you making use of the equalities somewhere?
03:16:37 <ocharles> I believe I make use of the qualities somewhere. For example, if you have a Tree Artist, you can turn that into a Revision Artist. But you can't turn a Tree Label into a Revision Artist
03:16:44 <ocharles> it's that sort of equality I use
03:17:18 <dreixel> but that's just turning a |Tree a| into a |Revision a|
03:17:29 <ocharles> mmm, it is
03:17:33 <dreixel> if you replace the return types by |Tree a|, GHC will tell you where you are actually using those equalities
03:17:44 <ocharles> ok, lets try that
03:17:44 <dreixel> (unless it compiles without problem, in which case you aren't using them)
03:18:01 <ocharles> so I just change my GADT to be { } -> Tree a?
03:18:52 <dreixel> yep
03:19:21 <ocharles> ah, that immediately breaks underneith, when I provide a way to go from Tree a -> a
03:19:27 <ocharles> but that might not be needed
03:19:38 <dreixel> could be done with a type class instead
03:19:43 <ocharles> yea
03:20:29 <ocharles> wait, if you have a 'Tree Artist' withouth the GADT, how do you guarantee it was constructed with ArtistTree? Nothing stops me doing 'URLTree {..} :: Tree Artist', does it?
03:20:41 <ocharles> and you can't extract an Artist from a URLTree.
03:21:29 <dreixel> well, you lose that guarantee
03:22:01 <dreixel> if you need those sort of guarantees, then you need a GADT
03:22:18 <ocharles> yea, I think that's why I was using one. at least it's more convenient than having Tree a -> Maybe a everywhere
03:22:40 <dreixel> sure
03:22:41 <ocharles> but this is only one place, and maybe the cost of one Maybe isn't too bad
03:22:50 <dreixel> well, how do you build these trees?
03:23:23 <ocharles> you mean where do I construct values like Tree Artist?
03:23:28 <dreixel> you can make the datatype opaque, allowing it to be constructor only through some smart constructor
03:23:51 <dreixel> then you'd know that a Tree Artist is a ArtistTree constructor
03:23:58 <dreixel> and wouldn't need the Maybe
03:24:06 <ocharles> then treeData becomes partial, and I don't trust myself doing that
03:24:08 <dreixel> though, honestly, the GADT is the nicest way to do this, of course.
03:24:21 <ocharles> it puts the onus on me, not the compiler
03:24:27 <dreixel> sure, I can understand :)
03:24:29 <ocharles> i don't want to give that up just for generics :)
03:24:35 <dreixel> fair enough
03:24:46 <dreixel> you can still use generics, but you'll need to write your own Generic instance
03:24:58 <ocharles> oh, this can be encoded into GHC.Generics?
03:25:19 <dreixel> yes
03:25:26 <ocharles> Oh, I can introduce my own "C" that witnesses equality?
03:25:32 <dreixel> the easiest way is to pretend every constructor has an extra argument
03:25:40 <dreixel> which is a proof of type equality
03:25:56 <dreixel> (of type data Refl a b where Refl :: Refl a a)
03:26:11 <dreixel> I *think* that should work.
03:27:27 <ocharles> Ok. but that sounds like I have to write all my representations out by hand, which is ugly. I'll probably stick with instant-generics, unless there's a path to get this into GHC.Generics proper (at which point I might be interested in doing the grunt work to make that happen)
03:28:18 <dreixel> it probably isn't too hard to adapt the TH code in instant-generics to generate Generic instances instead.
03:28:32 <dreixel> but it could also be that you're happy just using instant-generics
03:29:01 <ocharles> not set on anything yet, just exploring my options
03:29:07 <ocharles> and then being lazy and going with whatever is easiest :)
03:29:33 <dreixel> it's just that there's more momentum on GHC.Generics than on instant-generics, so if in the future you want more generic functionality, you might find yourself reimplementing things in instant-generics even though they're already available in GHC.Generics.
03:30:27 * ocharles nods
03:30:44 <ocharles> that's why I might be interested in
03:30:45 <ocharles> oops
03:30:54 <ocharles> interested in helping get at least some GADT support into GHC.Generics
03:31:28 <ocharles> but that might be a lot of work, or work that's beyond me at the moment
03:32:05 <ocharles> I suppose if I wanted to do that, I should begin by working out how to do it by writing Rep by hand, and then working out how to automate that in the deriving clause?
03:33:15 <jmcarthur> i wish i could selectively disable MonoLocalBinds per let binding without having to write out the entire type signature for it
03:36:57 <dreixel> ocharles: the problem is that this solution is very specific
03:37:03 <dreixel> it only works for some special cases
03:37:08 <dreixel> I'd rather have something more general in place
03:37:19 <dreixel> even if that means completely rewriting GHC.Generics
03:38:22 <ocharles> yea, I appreciate that
03:39:07 <ocharles> I assume you don't want to go a step forward because the ultimate solution to GADTs might be radically different? (which risks wasting the time of GHC.Generics users)
03:39:16 <dreixel> yep
03:39:23 <ocharles> fair enough
03:49:54 <osa1> does anyone have any ideas why I'm getting "ambiguous occurences" errors in hdevtools? this project compiles and works fine with `cabal install` ..
03:51:48 <b__> Why does "data Void; a :: Void; a = a" type-check? How can the type of a be resolved by the compiler?
03:52:23 <merijn> b__: Why not? if "a = a" then that works for every type, no?
03:52:32 <merijn> b__: Granted "a = a" is just bottom in disguise
03:53:08 <dreixel> ocharles: http://dreixel.net/research/pdf/trkgp.pdf Section 6 has a discussion on how to improve GHC.Generics
03:53:32 <dreixel> you can see that one way to support GADTs changes things radically. And it also doesn't work (yet), unfortunately
03:53:38 <b__> merijn: you're right. The type is irrelevant
03:54:38 <b__> But why does a = a work? (I guess my questions aren't very good, but I want help asking better ones)
03:56:09 <merijn> b__: Well, define work
03:56:15 <jmcarthur> b__: what is the type of  let f n = f (n+1) in f 0  ?
03:56:25 <merijn> b__: "a = a" is bottom, so it doesn't work for most sane definitions of "work"
03:56:49 <b__> merijn, I guess I'd define it as "it compiles".
03:57:24 <merijn> b__: Basically what happens is "what is the value of 'a'?" "Oh, the value of 'a' is the value of 'a', let's look up what that is"
03:57:45 <merijn> Loop until forever, repeatedly checking what the value of 'a' is and never stopping*
03:57:58 <merijn> *For some value of never, the RTS will usually just return "<<loop>>"
03:58:24 <merijn> b__: Do you understand why "let ones = 1:ones in ones" works?
03:59:27 <b__> merijn, yes
03:59:46 <merijn> Well, "let a = a" just takes out the "middle man" that returns "1:" at first :)
03:59:54 <jmcarthur> :t forever
03:59:56 <lambdabot> Monad m => m a -> m b
04:00:31 <b__> merijn, jmcarthur, that makes sense, thanks :)
04:00:47 <ocharles> dreixel: thanks, I'll have a read
04:19:03 <hape02> > liftM (+1) $ Just 1
04:19:04 <lambdabot>   Just 2
04:28:43 <merijn> hape02: Incidentally, liftM is just fmap and fmap has an infix version <$>
04:28:49 <merijn> > (+1) <$> Just 1
04:28:50 <lambdabot>   Just 2
04:31:47 <augur> whoa whoa whoa
04:31:59 <augur> merijn: thats not entirely true
04:32:20 <augur> fmap for monads is the same thing as fmap for that monad, yes
04:32:30 <augur> is the same thing as liftM*
04:32:53 <augur> and fmap for applicatives is the same as the applicatives' <$>
04:33:19 <merijn> augur: <$> is literally fmap
04:33:19 <augur> but liftM isn't "just" fmap, and <$> isn't the infix version of fmap
04:33:32 <merijn> augur: Oh, wanna bet on the last one? :)
04:33:42 <augur> merijn: i know it ends up actually being that way, but <$> exists for applicative functors only
04:33:52 <merijn> augur: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Functor.html#%3C%24%3E
04:33:59 <merijn> augur: *bzzzt* wrong
04:34:04 <merijn> :t (<$>)
04:34:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:34:28 <augur> well thats stupid
04:34:29 <augur> who did that
04:34:39 <merijn> Why would that be stupid?
04:34:47 <merijn> fmap isn't part of the Applicative class
04:34:57 <augur> no its not
04:35:07 <augur> thats irrelevant
04:35:07 <merijn> augur: So why would <$> be?
04:35:25 <augur> that's like asking why would liftM be tied to monads
04:35:29 <merijn> Applicative requires Functor, so why would you implement <$> as Applicative only
04:35:43 <merijn> augur: Because Monad has no superclass, Applicative does
04:35:46 <augur> why would you implement liftM as Monadic alone
04:35:57 <augur> monad certainly does have a superclass
04:36:03 <merijn> No, it doesn't
04:36:08 <augur> Functor
04:36:11 <merijn> No
04:36:15 <dcoutts> it really doesn't
04:36:18 <dcoutts> not at the moment
04:36:30 <augur> wat
04:36:30 <merijn> augur: That's the entire reason liftM exists....
04:36:32 <dcoutts> though everyone agrees it should
04:36:43 <merijn> augur: If Functor was a superclass of Monad liftM would never have been made
04:36:47 <augur> everyone agrees applicative should be the superclass
04:36:49 <augur> but
04:37:02 <augur> man, what, are you seriously
04:37:03 <augur> thats absurd
04:37:11 <augur> who the heck did THAT
04:37:16 <merijn> augur: Everyone wants Applicative as superclass because that would automatically add Functor as a superclass
04:37:22 <augur> yeah
04:37:28 <augur> ok
04:37:38 <jmcarthur> and it's going to happen soon! :)
04:37:45 <merijn> jmcarthur: Soon (TM)
04:37:45 <jmcarthur> finally
04:38:05 <jmcarthur> well, it's at least been agreed that it's worth whatever breakage occurs, which is something
04:38:32 <jmcarthur> s/agreed/decided/
04:39:28 <augur> well anyway, (<$>) is spiritually   f <$> x = pure f <*> x
04:39:38 <merijn> well, yes
04:39:40 <augur> and tho that's extensionally the same as fmap f x
04:39:46 <augur> its spiritually different
04:39:55 <merijn> In the same sense that 'fmap' is spiritually "pure f <*> x"
04:40:00 * hackagebot haste-compiler 0.2.3 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.2.3 (AntonEkblad)
04:40:03 <augur> no thats definitely not true, merijn
04:40:15 <augur> not all functors are applicatives!
04:40:27 <merijn> So? <$> is not an applicative thing
04:40:31 <merijn> It's a functor thing
04:40:38 <merijn> It just happens to work nicely with <*>
04:40:40 <augur> im saying it spiritually is (or at least ought to be :P)
04:40:54 <augur> eh. i guess the functor perspective makes sense too tho.
04:40:56 <augur> hmm hmm
04:41:04 <augur> oh fine
04:50:30 <orzo> is there a way to pass an ExpQ object to a function and have it splice it with $() ?
04:50:36 <orzo> (template haskell, of course)
04:51:17 <augur> whats a good haskell web page library thing?
04:59:57 <luite> augur: what kind of functionality do you need?
05:00:46 <augur> luite: db interfacing, html generation (from templates, preferably)
05:01:09 <augur> im building a sort of reddit-like site. not quite, but that gives you an idea of what sort of backend activity will go on
05:01:37 <luite> uh well, yesod bundles that all, but the same is possible with snap and happstack
05:02:28 <augur> on a side note, how do _you_ pronounce "yesod"
05:03:08 <merijn> augur: Just like the hebrew, I imagine
05:03:16 <luite> yisod, stress on sod, and i don't know phonetic notation :p
05:03:29 <luite> long o
05:03:29 <augur> ok, so you pronounce it like they say on their site
05:03:35 <luite> ah yesodweb.com has a pronunciation
05:03:56 <Maior> http://www.forvo.com/word/yesod/
05:04:11 <augur> my instinct is to pronounce it yes-id
05:04:15 <augur> ihd
05:07:29 <luite> augur: but what you're asking for is rather generic, you might need to look into more details. for example if you want runtime customizability of templates (like users uploading custom templates) then the compile-to-haskell templates (for yesod hamlet is often used, hsx with happstack) might not be ideal
05:07:42 <augur> no i dont want that at all
05:08:27 <luite> with all of the frameworks you can do bare bones blaze-html and runtime templates though, but you might lose some functionality
05:08:45 <augur> i think i probably do want the ability to have templates out in HTML tho, not in code
05:08:47 <hape02> > Just (+1) <*> (sin <$> (cos <$> Just 1))
05:08:49 <lambdabot>   Just 1.5143952585235492
05:08:57 <hape02> I can walk    :-)
05:09:36 <augur> (| pure 1 + (| sin (| cos (pure 1) |) |) |)
05:10:02 * hackagebot mecab 0.4.0 - A Haskell binding to MeCab  http://hackage.haskell.org/package/mecab-0.4.0 (HideyukiTanaka)
05:10:22 <hape02> Looks nice with that pipes
05:10:31 <augur> i really think that it'd be interesting to have the schemequote notation
05:10:43 <augur> `( 1 + sin (cos ,1) )
05:10:45 <luite> augur: hsx embeds haskell in the template, preprocesses it. hamlet is html-inspired syntax, can be included from files or inline in code, but you omit closing tags and use indentation for nesting instead (and you get some haskell variable expansion). heist is xml with tags tat get replaced
05:11:04 <augur> luite: hm
05:11:59 <augur> luite: whats the relative purpose of snap vs. happstack?
05:12:28 <Guest80998> this may be a stupid question but i want to annotate multiple types: foo :: Integer becomes foo :: (Integer,Char)
05:12:31 <Guest80998> can i do such a thing?
05:13:08 <luite> hmm that's a bit hard to say. perhaps that snap focuses more on building around the snap extension system with snaplets and heist?
05:13:21 <simukis_> Guest80998: You mean `foo :: Integer | (Integer, Char)`?
05:13:29 <augur> luite: can you go one level higher?
05:13:31 <Guest80998> ah that sounds like it
05:14:00 <luite> they're taking a different direction with their server IO, with snap being enumerator based atm, switching to io-streams. happstack lazy io, switching to pipes
05:14:03 <simukis_> Guest80998: Then do `data SomeType = This Integer | That (Integer, Char)` and `foo :: SomeType`
05:14:11 <luite> warp might still be the fastest though
05:14:23 <ocharles> uh, OverlappingInstances/UndecidableInstances shouldn't cause the linker to fail, should it?
05:14:25 <Guest80998> simukis_: i guess data is just like a c struct then?
05:14:29 <ocharles> I wonder if Cabal has got confused
05:14:35 <ocharles> ah yes, cabal clean solved that. phew
05:14:36 <augur> luite: ok, but going one level up, what is the conceptual difference involved in terms of what they're "for"
05:14:42 <simukis_> Guest80998: more like enumeration, I guess.
05:14:51 <Guest80998> cool
05:14:53 <Guest80998> thanks!
05:14:59 <augur> luite: like, snap isn't "for" enumerator based yadda yadda. its "for" web apps of some sort.
05:15:19 <ocharles> l
05:15:22 <luite> augur: oh, i don't think there's that much difference, they're both web server libraries with some tools.
05:15:40 <augur> ok, so snap and happstack are alternative solutions for the same thing, then?
05:15:43 <Guest80998> it gives me a parse error on | thogh
05:15:45 <Guest80998> though*
05:15:51 <ocharles> augur: snaplets promote a type of reuse that other web frameworks don't seem to have. You have snaplets that provide specific parts of functionality, and compose it all together
05:16:03 <augur> ocharles: example?
05:16:04 <ocharles> such as login snaplets, database access snaplets, a wiki snaplet, a performance analysis snaplet, etc
05:16:27 <ocharles> the ultimate goal is that building web applications should be something that is mostly taking off-the-shelf things, and doing a little bit of gluing
05:16:47 <luite> augur: you really need to look at the limitations, websockets aren't supported in happstack for example, so you don't want to choose it for things that needs that
05:17:03 <simukis_> Guest80998: http://en.wikibooks.org/wiki/Haskell/Type_declarations#data_and_constructor_functions
05:17:08 <augur> ocharles: aha
05:18:19 <Guest80998> ah i might need -> then
05:19:27 <luite> yesod has a few mechanisms for those type of extensions, yesod instances, subsites and wai middlewares, but subsites are showing their limitations a bit, so are getting an overhaul. but i'm not familiar enough with snaplets yet to make a good direct comparison
05:19:43 <luite> mightybyte promised he'd teach me though :p
05:19:56 <ocharles> yea, snaplets are just a means to a diserable end
05:21:41 <ocharles> luite: there's a nice video about snaplets on the snapframework site
05:21:47 <ocharles> at least, I think it covers snaplets
05:23:39 <augur> ocharles: gosh, should i first learn lens for this? D:
05:24:22 <edwardk> you should first learn lens for everything ;)
05:24:22 <ocharles> augur: not really
05:24:51 <ocharles> augur: lenses are just the abstracted used for moving around the tree of snaplets. in practice you need to know very little about lens to use it
05:25:00 <ocharles> (you need to know as much as is mentioned in all the snap documentation)
05:25:28 <edwardk> snap largely limits itself to a small corner of lens I make sure works across a large number of versions of GHC.
05:25:59 <augur> edwardk: ofcourse YOUD say that
05:26:33 <augur> ok.
05:26:41 <ocharles> augur: snaplets are also comonads
05:26:44 <ocharles> am I scaring you yet?
05:26:45 <ocharles> ;)
05:26:48 <edwardk> so snap can work with the subset of lens that has been held constant since lens 3.7, mostly http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Control-Lens-Loupe.html
05:27:03 <edwardk> the snaplet comonad is also my fault
05:27:07 <augur> well, if you're interested in what im making with this, read http://magazine.amstat.org/blog/2012/10/01/stats-view-oct12/ and http://gowers.wordpress.com/2011/10/31/how-might-we-get-to-a-new-model-of-mathematical-publishing/ and my workflowy https://workflowy.com/shared/30434af9-05ad-a64f-228a-d6d6acca8fe0/
05:27:09 <augur> :P
05:27:16 <augur> ocharles: comonads D:
05:27:17 <augur> ahhhh
05:27:25 <augur> do we have comonadic do?
05:27:26 <augur> od
05:27:26 <merijn> edwardk: I have a pedantic nitpick about your "bound" article on School of Haskell!
05:27:36 <ocharles> augur: i think there is a codo TH library
05:27:37 <edwardk> merijn: pick away
05:27:42 <augur> ocharles: hah.
05:27:43 <augur> codo.
05:27:57 <augur> why not be explicit
05:27:59 <augur> its comodo
05:28:00 <edwardk> merijn: i wrote the thing at 2 am, just so people could have some idea about the library ;)
05:28:23 <merijn> edwardk: You're far from the only to make this mistake, but you happen to be the only one I can correct :p You repeteadly refer to "de Bruijn", the proper way to capitalise that is "De Bruijn"
05:28:58 <edwardk> merijn: http://en.wikipedia.org/wiki/Nicolaas_Govert_de_Bruijn names him with the lower case d
05:29:08 <merijn> edwardk: The first letter of Dutch names is *always* capitalised. The connector words in last names are "normally" not, so the full name would be "Nicolaas Govert de Bruijn"
05:29:16 <edwardk> aha
05:29:22 <merijn> edwardk: But when *only* using the last name, the proper style is to capitalise
05:29:34 <edwardk> i'll take that lump
05:29:38 <edwardk> i'll go fix it
05:29:58 <`Jake`> Is there a reason why msum for MonadPlus exists but not for Monoid?
05:30:05 <`Jake`> unless I'm just not finding it
05:30:12 <edwardk> :t mconcat
05:30:13 <lambdabot> Monoid a => [a] -> a
05:30:17 <edwardk> :t msum
05:30:18 <lambdabot> MonadPlus m => [m a] -> m a
05:30:21 <`Jake`> ah
05:30:24 <ion> :t fold
05:30:26 <lambdabot> (Foldable t, Monoid m) => t m -> m
05:30:28 <`Jake`> thanks
05:30:30 <edwardk> mconcat is in the Monoid class
05:30:50 <luite> merijn: van Dale begs to differ ;)
05:31:27 <luite> (Van Dale is the best known maker of Dutch dictionaries and in their logo the 'van' is not capitalized)
05:32:04 <merijn> luite: Really? I don't think I've seen that logo?
05:32:16 <luite> well, go to www.vandale.nl :p
05:32:37 <merijn> I blame stupid artistic types :p
05:32:44 <augur> you know what, merijn, we're not speaking dutch, quit your cultural imperialism! >|
05:32:52 <merijn> I'd like to point out the name is properly capitalised everywhere else on the site :)
05:33:00 <augur> next you'll be saying "da brown" isn't the right way to pronounce his name!
05:34:02 <luite> it's pronounced like the 'ui' in luite, easy!
05:34:36 <edwardk> merijn: searched and replaced.
05:34:48 <edwardk> luite: hahaha
05:35:01 <merijn> augur: Got to enforce the standards of the Kingdom of the Netherlands*
05:35:04 <edwardk> luite: whenever i pronounce your name right, nobody can tell who the hell I'm talking about.
05:35:21 <merijn> * - Not to be confused with "The Netherlands", the country
05:35:59 <nooodl> alternate answer: "it's pronounced like the 'ij' in merijn with your lips rounded, what's the problem?"
05:36:03 <ocharles> urgh, hs-boot files need the default implementation copied in?
05:36:04 <quicksilver> I pronounce luite like lutefisk.
05:36:10 <ocharles> oh, maybe it's just the default signature
05:37:12 <augur> edwardk: how do you pronounce luite
05:37:56 <luite> quicksilver: hm, at least the 'lui' is one syllable then, that's good i guess :)
05:38:15 <merijn> luite: I know *that* feeling >.>
05:38:20 <augur> afaik <uij> is /ʏɛi/
05:38:30 <merijn> I am apparently mu-ri-jin
05:38:39 <ocharles> correct
05:38:40 <edwardk> augur: too early to try to transcribe it in IPA ;)
05:38:48 <ocharles> merijn: actually, you're "merry gin" here
05:38:49 <augur> edwardk: im a linguist, man
05:39:03 <merijn> ocharles: Actually, that one also pops up, yes
05:39:11 <ocharles> luite: is "loot" or "lweet" depending on my mood
05:39:17 <merijn> Silly Brits and their limited sounds
05:39:23 <ocharles> we try :(
05:39:28 <nooodl> augur: <uij> isn't all too common outside of names but it's pronounced just like <ui>, which is /œy/
05:39:32 <merijn> ocharles: Not particularly hard...
05:39:52 <edwardk> LOUT-eh is about as close as i can get
05:39:55 <augur> luite to me is /luɪtə/ like "louie-tuh", but thats on certain assumptions
05:39:57 <luite> ocharles: the first is closer
05:40:12 <edwardk> and its probably mangled beyond recognition to a dutch ear =)
05:40:13 <merijn> ocharles: People ask me "how do you pronounce that so often that I don't even know anymore :<
05:40:18 <quicksilver> merijn: you're merlin. you just made a typo in your nick.
05:40:27 <merijn> "You keep saying it differently!" 'I don't think I am... :("
05:40:40 <augur> nooodl: aha /œy/, interesting
05:40:44 <merijn> quicksilver: Technically, the inspiration came from the Dutch version of Merlin, being Merlijn
05:41:01 <merijn> My parents decided not to inflict that on me
05:41:23 <augur> i think we need a wiki with pronounciations
05:42:34 <luite> edwardk: well that's as good as can be expected :)
05:42:56 <augur> so i can definitely see where "da brown" comes from
05:43:06 <luite> since i've never been able to get anyone from outside the netherlands pronounce it any better :)
05:43:29 <augur> each sound in /œy/ is one feature value away from some english vowels
05:43:46 <nooodl> luite: just convince german people your name is löte
05:43:55 <augur> if we drop rounding, we down something like "da brain" because it becomes /ɛi/
05:44:04 <merijn> Google translate gets "De Bruin" right http://translate.google.com/#auto/en/De%20Bruin but "De Bruijn" is silly in pronounciation, as it should just be the same :p
05:44:22 <augur> if we drop frontness we get "da brawn" or "da brown", because it becomes /ɔu/
05:44:41 <merijn> I should learn IPA at some point...
05:44:46 <augur> merijn: why not now!
05:44:56 <merijn> augur: Paper deadline tomorrow, procratinating >.>
05:45:10 <augur> i think the obvious, correct compromise is how i pronounce it
05:45:19 <augur> "da broyn" with /ɔi/
05:48:10 <augur> i should get breakfast
05:58:34 <ocharles> 19 files changed, 592 insertions(+), 738 deletions(-) <-- generics ftw
06:00:04 <Taneb> http://www.vandoorn.talktalk.net/Nathan's_Stuff/d.svg <-- diagrams ftw (50-ish line program)
06:00:25 <hape02> Nice :-)
06:00:32 <ocharles> pretty :)
06:00:53 <ocharles> is that a single line?
06:01:20 <Taneb> ocharles, it's 50-or-so not particularly well thought out lines
06:01:27 <ocharles> ah, ok
06:01:31 <ocharles> nono
06:01:34 <ocharles> I meant the resulting image
06:01:41 <ocharles> not lines of code
06:01:47 <ocharles> a single path
06:02:06 <Taneb> Yeah
06:02:10 <ocharles> kewl
06:02:19 <Taneb> It's actually non-intersecting-ish
06:02:32 <exicer> If I wanted to look into a haskell webserver for use with a front end framework (eg angularjs) what would people reccomend ?
06:02:52 <tikhon> probably Snap or Yesod
06:03:42 <Okasu> exicer: Yesod is just fine, did weekend project with yesod + angularjs (what a coincidence).
06:04:16 <Okasu> Never tries Snap actually.
06:04:19 <tikhon> Yesod has some nice features and is well supported, so it's certainly a good option. The FP Complete site (and School of Haskell) are built with it.
06:04:27 <Okasu> s/ies/ied/
06:04:42 <tikhon> honestly, it's more important to choose one than which one to choose
06:05:01 <tikhon> (that sentence did not really work gramatically :P)
06:05:27 <shelf> tikhon: totally agreed.
06:05:41 <tikhon> http://www.yesodweb.com/
06:05:49 <shelf> very impoortant than which
06:06:28 <tikhon> the website makes a pretty good case for it; if you like the things they talk about there, chances are you'd like Yesod
06:07:06 <tikhon> the main complaint people have about it is its heavy use of template Haskell—I personally don't mind, but some people really prefer avoiding it unless absolutely necessary
06:08:03 <Maior> "template Haskell"?
06:08:14 <tikhon> it's an extension for compile-time metaprogramming
06:08:15 <Maior> ah sorry just found the wiki page
06:08:39 <tikhon> they use it to embed little DSLs for things like outputting HTML and CSS
06:08:58 <tikhon> I actually quite liked those facilities myself
06:09:03 <Maior> mm
06:10:02 <tikhon> If you want to see an example in practice, look here: http://www.yesodweb.com/book/shakespearean-templates#_hamlet_html
06:10:20 <Maior> tikhon: thanks
06:10:39 <hape02> I learned the composability gets lower when using TH
06:10:50 <tikhon> it depends on how it's used
06:11:10 <tikhon> I actually used Yesod's templates for a non-Yesod project, and had no problems combining small templates into bigger ones
06:11:19 <tikhon> moreover, you can always just wrap your template up into a function
06:11:20 <hape02> ah
06:11:41 <tikhon> that said, it's certainly an important concern
06:29:24 <shergill> why *do* people object to use of template haskell? is it just because haskell's syntax isn't quite as straightforward as say lisps? i haven't done much template metaprogramming myself
06:29:40 <tikhon> it depends
06:29:47 <Work_jack> shergill: There are several posts about it on StackOverflow if you're interested
06:29:56 <tikhon> sometimes it is to enable new syntax, like what Yesod does
06:30:06 <Work_jack> but as always there are multiple reasons, many of whom are contextual
06:30:18 <tikhon> Template Haskell is a macro system, and this is also the sort of thing you'd use macros for in Lisp
06:30:44 <tikhon> but people also use it to do arbitrary compile-time computations
06:31:05 <tikhon> sometimes you need relatively complex logic at compile time or just a good way to write generic programs
06:31:18 <tikhon> like what lens does to generate lenses for a data type
06:31:40 <shergill> right, but my questions was why people object to it
06:31:44 <tikhon> I personally think that conflating both syntax improvements *and* comiple-time logic into a single tool is unfortunate
06:31:46 <shergill> *question
06:31:48 <tikhon> oh
06:32:17 <tikhon> well, it's a bit of a mess and harder to use than it has to be
06:32:19 <Work_jack> shergill: http://stackoverflow.com/questions/10857030/whats-so-bad-about-template-haskell
06:32:25 <tikhon> it also has less typing than we'd like
06:32:51 <applicative_tmp> shergill: there is also the important principle that, a pre-cut system of objections spares you the labor of actually learning it, as with e.g. arrows, and a hundred other things ;)
06:33:02 <tikhon> I personally think the [foo| ... |] syntax is annoying—it marks things you add to the language as clearly foreign
06:33:08 <Maior> applicative_tmp: lol
06:33:24 <tikhon> have you seen "Growing a Language"?
06:33:46 <tikhon> it's a talk by Guy Steele
06:34:16 <shergill> applicative_tmp: heh
06:34:54 <shergill> Work_jack: thanks for the link. wasn't aware of the launching missiles property
06:35:30 <Work_jack> The major part for me is when TH is used when it's absolutely not needed
06:35:41 <Work_jack> but there are definitely uses for it
06:36:23 <tikhon> I would love a more capable macro system that would let us relegate most of Haskell's syntax sugar (if-then-else, do notation, proc notation and so on) to libraries
06:36:32 <Work_jack> Yes I agree with that
06:36:51 <tikhon> but that sort of thing is very hard to design well
06:36:52 <Work_jack> Personally I'd like to see something similar to what Idris does, for writing nicer DSLs
06:37:37 <tikhon> What does Idris do?
06:37:39 <Work_jack> rebinding if_then_else_, do-notation, where-clauses, let, ... and then allowing overloadable syntax for other literals than strings
06:38:00 <tikhon> eh, but I would also like to add new syntax (like mdo or proc) without having to hack on the compiler
06:38:06 <Work_jack> Yes indeed
06:38:13 <tikhon> or applicative brackets
06:38:18 <Work_jack> tikhon: I'll try to find nice examples
06:38:31 <tikhon> but yes, overloaded syntax everywhere would be awesome too
06:38:39 <tikhon> or maybe even just reader macros
06:38:52 <tikhon> ie I could imagine special syntax for regular expressions being nice
06:39:05 <Work_jack> There are some papers on pattern matching on regular expressions
06:39:40 <tikhon> and nice syntax for things like units of measure or (mostly for GUI and web development) colors
06:40:04 <Work_jack> Yes, the problem is that it's hard to provide a general ‘feature’ which allows for that without just baking it into the language design
06:40:13 <tikhon> yep
06:40:37 <tikhon> although I the ones I just described would be covered by reader macros
06:41:02 <Work_jack> True, but I remember people going crazy with reader macros from Common Lisp
06:41:04 <tikhon> they would also work for literal syntax for arrays, maps and what have you
06:41:07 <tikhon> crazy is fine
06:41:32 <Work_jack> It's fine when /you're/ the one reading and writing the code
06:41:46 <tikhon> if we just need to rely on some good taste, I think it should be permissible
06:42:04 <tikhon> most language features can be abused in horrible ways
06:42:31 <tikhon> also, reader macros are basically a feature that only library writers will use
06:42:56 <Work_jack> I don't buy that argument though
06:43:01 <tikhon> which argument?
06:43:06 <Work_jack> <tikhon> most language features can be abused in horrible ways
06:43:09 <tikhon> oh
06:43:25 <Work_jack> Certainly many can be yes, but there are different degrees of awfulness that features lend themselves to
06:44:06 <tikhon> I still don't think that *potential* for abuse should prevent a feature from being included
06:44:17 <tikhon> if we do that, we'd just get Java
06:44:18 <Work_jack> It depends on the purpose of the language
06:44:40 <Saizan> haskell restricts its features in many ways just so you get more theorems about them
06:44:57 <Work_jack> Haskell is strange in that regard
06:45:06 * hackagebot throttle 1.0.0 - Throttle TCP/IPv4 connections to a given server.  http://hackage.haskell.org/package/throttle-1.0.0 (ChrisDone)
06:45:07 <Saizan> when you add power you should always ask "what guarantees do i lose?"
06:45:07 <tikhon> yes, and reader macros—being purely syntactic and compile-time—do not really affect theorems
06:45:23 <tikhon> so you lose no guarantees, because all it lets you do is add a bit of syntax sugar
06:45:33 <Saizan> tikhon: that depends entirely on the theorem/guarantee
06:45:39 <arnsholt> I dunno, restricting things so that you get more theorems makes sense. More theorems means more opportunities for optimisation
06:45:53 <tikhon> reader macros are ultimately just a notational convenience
06:45:57 <Saizan> e.g. alpha-equivalence is syntactic and compile-time
06:45:59 * Work_jack . o O (( sometimes it feels like Haskell's operators go too far ))
06:47:33 <tikhon> also, that seems to be the *main* reason Haskell restricts features: if something doesn't compromise guarantees (like infix operators), Haskell has no qualms about adding it
06:47:33 <Work_jack> tikhon: http://eb.host.cs.st-andrews.ac.uk/writings/idris-tutorial.pdf, section 10: Syntax Extensions
06:48:11 <Work_jack> Agda's mixfix operators are pretty nifty but solve a different problem
06:48:37 <tikhon> I think the mixfix operators are a very good example of the sort of feature I want
06:49:01 <tikhon> unlike traditional macro systems, it completely decouples logic and syntax, and makes it clear that mixfix identifiers *only* change syntax
06:49:13 <supki> tikhon: is there a conceptual difference between quasiquoters and reader macro?
06:49:14 <tikhon> whereas Lisp macros and Template Haskell do both at the same time
06:49:19 <supki> (I don't speak CL)
06:49:47 <tikhon> supki: I don't think it's *too* different
06:50:02 <tikhon> also, I think my vision of "reader macros" for Haskell might be a bit different from Lisp's
06:50:25 <tikhon> basically, I would like the resulting syntax to "fit" into the languae, in a way that TH really doesn't
06:50:29 <Work_jack> Yes, mixfix operators are a good idea but like I said it's all a matter of purpose: Agda will never be used by ‘traditional’ developers so having mixfix operators there is no big deal; Java is a different matter all together and Haskell is unsure where it wants to be
06:51:10 <tikhon> and also I would like to restrict the scope of the system to only doing fairly simple syntactic manipulation, not the rather wide range of logic template Haskell lends itself to
06:51:53 <tikhon> Work_jack: eh, I am suspicious of the argument for supporting "traditional" developers
06:52:27 <Work_jack> I'm not making that argument for something in Agda and kind of not in Haskell either
06:52:27 <tikhon> Most of these features will—like Java generics—end up used by library designers far more than anyone else
06:53:05 <Work_jack> But anyway, using Idris you can define for-loops as such:
06:53:05 <Work_jack>     syntax for {x} "in" [xs] ":" [body] = forLoop xs (\x => body)
06:53:05 <Work_jack> resulting in code like:
06:53:05 <Work_jack>     main = do for x in [1..10]:
06:53:08 <Work_jack>                   putStrLn ("Number " ++ show x)
06:53:11 <Work_jack>               putStrLn "Done!"
06:53:14 <tikhon> and the languages actually designed with that philosophy (Java, Python...) tend to have this weird compromise: you can do all sorts of stupid things in your code, as long as all the code looks uniform
06:53:30 <Work_jack> avoiding the ugly: forM_ [1..10] $ \x → ...
06:53:30 <carp> Hello, I have been learning Haskell for the last 3 weeks. Thought Id come and say hello on the IRC while I continue to work through the Learn you a Haskell for Great Good tutorial. Hi
06:53:39 <Work_jack> Hey carp
06:53:50 <tikhon> Haskell is the opposite: the syntax is fairly flexible, but you cannot easily write convoluted logic like in Java or Python
06:54:24 <tikhon> carp: that's a good idea; if you have any questions, always feel free to ask: there is almost always somebody around to answer
06:54:31 <tikhon> and have fun with LYAH :)
06:54:54 <carp> Thankyou.
06:55:19 <tikhon> the complete inflexibility of Java's syntax was one of the main reasons I stopped using it and went off in search of a better language
06:55:48 <tikhon> in fact, it caused me to swear off static typing for a while because I assumed all statically typed languages were equally awkward :P
06:56:22 <tikhon> ooh, looking through the Idris pdf, I really like the syntax facilities
06:57:45 <tikhon> the dsl facilities also seem very nice, and like something I'd use reasonably often
06:58:38 <Okasu> tikhon: Yeah, and jst read your code people should learn whole new language. Sounds good.
06:58:47 <Okasu> just to read*
06:59:30 <tikhon> they'd have to read the base function definitions either way
06:59:56 <tikhon> unless they're already familiar with the domain and the functions would have made sense
07:00:07 <tikhon> but then the dsl should also make sense
07:01:52 <tikhon> take GUI layouts for example: I don't think having nice syntax for laying out widgets would add that much overhead over using normal functions, since you'd still have to understand what the different layout rules *meant*
07:02:16 <tikhon> but it might make it sufficiently easier to read to be worth doing, especially for people already familiar with the idea
07:02:48 <tikhon> of course, I haven't actually thought of what that particular DSL would look like :P
07:03:22 <tikhon> but I think there would be lots of ways to improve over, say, the way wxHaskell does it
07:05:27 <Jentrep> zomg on? :)
07:08:49 <carp> is it possible to hide all the joined and quit messages?
07:09:04 <tikhon> carp: what client are you using? Erc?
07:09:16 <carp> webchat.freenode.irc
07:09:19 <tikhon> oh
07:09:22 <tikhon> no idea, then
07:09:36 <tikhon> are you using Emacs for your programming, perchance?
07:10:00 <carp> im not using emacs
07:10:02 <ocharles> dreixel: sorry to bug you again, but do you have any advice on how to choose whether to follow the left and right injection into a sum? the "obvious" approach needs GFoo a => a :+: b and GFoo b => a :+: b, but you can't define two instances for the same type
07:10:08 <tikhon> okay, never mind then
07:10:11 <ocharles> left or right*
07:10:27 <tikhon> I only know how to do it for ERC, which is Emacs's IRC client.
07:10:44 <carp> ah ok no worries.
07:10:49 <dreixel> ocharles: what are you defining?
07:10:51 <ocharles> I tried refining those instances to be GFoo a => ((CEq c1 p p a) :+: b) and GFoo b => (a :+: (CEq c2 p p b)) and that does work, but it doesn't work with nested sums
07:10:54 <tikhon> have you considered learning Emacs? :P
07:10:58 <ocharles> dreixel: let me paste some code
07:11:12 <exicer> I keep seeing strings like : {-# LANGUAGE OverloadedStrings #-} at the top of .hs files. What are they for ?
07:11:22 <carp> i dont know what it is ha
07:11:25 <tikhon> that enables a particular GHC extension
07:11:37 <tikhon> carp: It's a text editor. It's better than other text editors.
07:11:56 <exicer> Aside from vim, obviously!
07:11:59 <exicer> :p
07:12:13 <tikhon> exicer: it just lets you use new Haskell features which aren't part of the standard
07:12:35 <tikhon> exicer: this one, for example, enables "overloaded strings", which makes string literals polymorphic just like numeric literals
07:12:46 <exicer> Hm okay. So it seems like in yesod has this a lot  ?
07:12:50 <tikhon> yes
07:12:56 <ocharles> dreixel: http://lpaste.net/91993 -- that works if I gViewTree to get a Tree Artist because that's the first constructor in the sum. but if you try Tree Label, I just get told there is no instance for CEq c Artist Label (paraphrasing), which makes sense
07:13:02 <tikhon> template haskell, which we were talking about earlier, is also an extension like this
07:13:05 <ocharles> because for Tree Label I need to follow the right injection, not the left
07:13:08 <exicer> Ah okay
07:13:30 <tikhon> most code in practice uses extensions—there are some particular ones that are very nice and have basically no downside
07:13:30 <ocharles> or more, I need to go InL . InR
07:13:31 <dreixel> uhm.
07:14:12 <dreixel> ocharles: can you describe what you're trying to achieve with function gViewTree?
07:14:39 <ocharles> dreixel: i'll explain at one higher level to explain why I think I need gViewTree
07:15:09 <carp> I have been learning python for 8 months and by the end, I understood an Asteroids type clone. Then, I saw John Carmack talking about Haskell and decided to try it out. I am very very nooby. So i will try not to bother anyone ha.
07:15:10 <ocharles> Recall we have Tree defined as https://github.com/metabrainz/musicbrainz-data/blob/master/src/MusicBrainz/Types/Internal.hs#L561
07:15:21 <ocharles> I need to build values of Tree a (for specific a's) by loading from the database
07:15:30 <ocharles> one example of this is at https://github.com/metabrainz/musicbrainz-data/blob/master/src/MusicBrainz/Data/Artist.hs#L63
07:15:38 <tikhon> carp: don't worry about bothering anyone, we're always happy to help
07:15:45 <ocharles> all ViewTree's take the same shape, so I thought I could write that generically
07:16:18 <ocharles> so I build up Rep (Tree a), and then use Representable.to to go back from Rep to the concrete type
07:16:21 <exicer> tikhon: So why are these almost always used extensions not part of "normal" haskell ?
07:16:28 <carp> Thankyou tikhon
07:16:32 <applicative_tmp> carp: oh, please bother
07:16:35 <ocharles> so GViewTree is a set of instances for working under the Rep (Tree a) representation
07:16:42 <tikhon> exicer: sometimes it's just because the standardization process takes a long time
07:16:52 <dreixel> ocharles: so, a generic deserialiser?
07:16:54 <ocharles> I can then do: viewTree = fmap to . gViewTree
07:16:59 <ocharles> dreixel: essentially, yea
07:17:17 <ocharles> where "deserializing" is doing some IO
07:17:22 <tikhon> exicer: I believe there are a few extensions slated to become standard in the next iteration
07:17:47 <exicer> tikhon: Hm, okay. Where can I read about these extensions ?
07:17:53 <dreixel> ocharles: well, can't you do the IO first (read files/DB/whatever), and then deserialise generically and purely?
07:17:57 <tikhon> the GHC manual has a list of them
07:18:04 <tikhon> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/ghc-language-features.html
07:18:26 <ocharles> dreixel: because the queries to run depends on the fields of Tree a. the "Tree" of an artist is different from the "Tree" of a URL, for example
07:18:33 <tikhon> but there's a lot of them; instead of trying to read that section, just look up any you see in the wild
07:18:38 <ocharles> but the queries are the same for each type of data
07:19:01 <ocharles> so that felt like a good place to use generics, provided I have written the definitions for how to load a 'Set ISWC', for example
07:19:47 <exicer> tikhon: Cool. Will do.
07:19:55 <exicer> I think I'll play around with yesod a bit, and see how it goes.
07:20:01 <dreixel> ocharles: ok. anyway, I'm pretty sure you don't want GViewTree to be an MPTC
07:20:07 * hackagebot contravariant 0.4.4 - Contravariant functors  http://hackage.haskell.org/package/contravariant-0.4.4 (EdwardKmett)
07:20:29 <tikhon> exicer: try doing a simple project of some sort—maybe a text adventure game? Those are always fun :).
07:20:40 <ocharles> dreixel: hmm, maybe - but I don't think that's what's causing problems right now
07:21:00 <dreixel> ocharles: it should probably bear some resemblance to http://hackage.haskell.org/packages/archive/instant-generics/0.3.7/doc/html/src/Generics-Instant-Functions-Empty.html
07:21:02 <merijn> Quick writing question, how would people here pluralise α? αs?
07:21:08 <exicer> tikhon: Heh, sounds good.
07:21:19 <dreixel> that's also a *generic producer*
07:21:23 <Jentrep> anyone here work in JS and Haskell?
07:21:24 <merijn> (α being a variable I'm solving)
07:21:43 <merijn> Jentrep: Some people here are working on a Haskell-to-JS compiler, so I'm betting yes :)
07:21:44 <tikhon> merijn: yeah, I think that's fine; α's is another option, but I think αs is more correct
07:21:56 <Jentrep> merijn: well then ... that's good :P
07:22:02 <merijn> tikhon: α's would be the right way in Dutch, but I wasn't sure about English
07:22:05 <dreixel> ocharles: as for your sum question, you have to decide whether you want to go left or right.
07:22:18 <tikhon> merijn: but this is one of those bits of grammar that people love arguing about, so there is not 100% correct answer
07:22:35 <dreixel> in deserialisation, that typically means looking at your stream of bits and deciding based on that (you have encoded before whether this thing is a left or right thing)
07:22:41 <tikhon> I think α's looks better myself, so I'd probably go with that
07:22:41 <merijn> tikhon: Thus again proving the inferiority of English ;)
07:23:10 <tikhon> unless α was set in a different typeface, in which case αs might be better
07:23:13 <luite> Jentrep: yeah i'm working on a haskell to js compiler :p
07:23:26 <Jentrep> Has anyone here connected a heavy JS frontend to a Haskell middle recording events in a object-relational db like Mongo??
07:23:32 <Jentrep> oh sweet luite :P
07:23:42 <tikhon> normal rules of "grammar" rarely consider things like typefaces, but they really should :)
07:23:48 <ocharles> dreixel: Hm, well in this case the decision is in the types. There is only one 'Tree Artist', so there is only one (CEq c p p r) instance (the rest are CEq _ p q r with p /= q). So I was hoping to follow the types and stop at the first match
07:24:04 <merijn> tikhon: Well, α would be in the italic math fontface, s in normal Computer Modern
07:24:09 <ocharles> it's going to take some oleg type trickery, maybe like what HasRec is doing
07:24:24 <tikhon> in that case, αs is probably the way to go
07:24:33 <dreixel> ocharles: this goes back to me wondering about the MPTC
07:24:39 <tikhon> if they were both the same—like on IRC—then αs looks too much like as
07:24:40 <Jentrep> luite does that mean i can build a video player in Haskell soon :P
07:24:44 <dreixel> is this function *consuming* or *producing* data generically?
07:25:03 <dreixel> (or is it updating?)
07:25:19 <ocharles> dreixel: I think producing. The 'entity' type varible is essentially so I can do "Tagged entity Int"
07:25:20 <luite> Jentrep: oh that's already possible i think, video is mostly handling events for the controls, right?
07:25:38 <Jentrep> luite: basically sure
07:25:43 <Jentrep> luite: but it has to be ajax
07:25:51 <Jentrep> luite: can you stick Haskell in the browser yet?
07:26:11 <ocharles> dreixel: so 'entity' is giving me context while I load things to know what entity in the database I am loading data for, and the value under Ref (Revision entity) is the actual entity ID
07:26:16 <luite> Jentrep: oh that already works. ajax worth easier than from js itself, since you don't have to work with callbacks
07:26:31 <dreixel> ocharles: so maybe this entity can tell you what type to expect?
07:26:40 <luite> Jentrep: just something like x <- ajax "abc"
07:26:47 <ocharles> dreixel: oh, that's interesting. there might be something there, yea
07:27:11 <dreixel> but I'm highly suspicious of the Ref and IO in your generic function...
07:28:04 <Jentrep> luite: what?
07:28:07 <ocharles> I was trying to abstract https://github.com/metabrainz/musicbrainz-data/blob/master/src/MusicBrainz/Data/Artist.hs#L63 and https://github.com/metabrainz/musicbrainz-data/blob/master/src/MusicBrainz/Data/Artist.hs#L63
07:28:11 <ocharles> which are pretty much identical
07:28:21 <ocharles> erm
07:28:25 <ocharles> they are identical if I paste the same link :)
07:28:27 <dreixel> indeed, very identical :)
07:28:28 <applicative_tmp> more than pretty much
07:28:36 <ocharles> https://github.com/metabrainz/musicbrainz-data/blob/master/src/MusicBrainz/Data/Label.hs#L126 is the second link
07:29:03 <dreixel> can you tell me the type of viewTree?
07:30:14 <luite> Jentrep: ghcjs makes that call run on async javascript, suspending the haskell thread until it returns
07:30:22 <merijn> Jentrep: I think he means that (afaik) lightweight threading works too, so you can just use the usual haskell threading approach to write synchronous code, rather than work with async callbacks
07:30:42 <merijn> whoo!
07:30:43 <Jentrep> Ah .. .hrmmm
07:30:46 <merijn> I guessed right
07:30:47 <ocharles> dreixel: https://github.com/metabrainz/musicbrainz-data/blob/master/src/MusicBrainz/Data/Tree.hs
07:30:53 <oooooldSport> if I have 'fibs' that is defined as 'fibs = 1 : 1 : zipWith (+) fibs (tail fibs)', and I want to get fibonacci numbers in a list up to 4,000,000, i have thought to do something like: '[z | z <- fibs, z < 4000000]'. however, this doesn't work. it gets fibonacci numbers up to the one before 4,000,000 like it should, but doesn't seem to finish the list. it just leaves '3524578' as the last thing in the list and doesn't append a 
07:30:53 <oooooldSport> bracket, and doesn't go to the next step in the program. any suggestions?
07:30:58 <Jentrep> I wonder what is the performance of that though :/
07:31:02 <ocharles> it turns a reference to a revision into a fully loaded tree
07:31:31 <applicative_tmp> right, oooooldSport it has to make sure that 3333333333333333 < 400000
07:31:35 <merijn> oooooldSport: How is it supposed to know there won't be any numbers smaller than 4000000 afterwards?
07:31:42 <luite> Jentrep: so far it seems pretty good :)
07:31:57 <merijn> oooooldSport: You probably want "takeWhile (<4000000)"
07:32:00 <Jentrep> luite: at what scales tested so far?
07:32:08 <dreixel> ocharles: ok. I'm less suspicious now :)
07:32:26 <oooooldSport> merijn: rather than simply 'z < 4000000'?
07:32:26 <Jentrep> luite: so should I start using ghcjs you are saying? :)
07:32:27 <ocharles> dreixel: phew :)
07:32:29 <applicative_tmp> takeWhile (< 4000000) fibs
07:32:34 <ocharles> dreixel: it may still be mad though
07:32:39 <ocharles> but that's what learning is for :)
07:32:42 <Jentrep> luite: what is the future software support/updates on this project looking like? :P
07:32:47 <merijn> oooooldSport: "z < 4000000" filters out all elements bigger than 4000000
07:33:01 <merijn> oooooldSport: But how do you know when you're done filtering? When you finish the list
07:33:10 <merijn> oooooldSport: When do you finish an infinite list? :)
07:33:27 <oooooldSport> merijn Okay i'll see how this works
07:33:36 <luite> Jentrep: mostly small benchmarks. this strategy doesn't really affect code size so it's not likely to be less scalable than direct calls without asynchronous stuffs
07:33:55 <dreixel> you might consider giving gViewTree the type :: Ref (Revision a) -> IO (Tree a), though
07:34:13 <luite> Jentrep: it's still a bit early (based on ghc 7.8 that is not yet released) but it works :)
07:34:44 <ocharles> dreixel: yea, not set there. i might change to 'gViewPart' as that's more what it does (recursively walks the tree, loading all nodes)
07:34:50 <Jentrep> luite: yep I guess I will have to give it a try! :)
07:34:57 <dreixel> ocharles: anyway, did I answer your question?
07:35:07 <ocharles> dreixel: i think you've given me a hint where to go
07:35:08 <dreixel> basically, you have to decide whether to go left or right
07:35:16 <ocharles> I think I can use a type family to decide that
07:35:19 <dreixel> as you're generating data
07:35:21 <ocharles> and a type class
07:35:35 <Jentrep> luite: do you think that a whole Haskell-for-browser project (even with a small team) could be handled by ghcjs?
07:35:37 <dreixel> I'm really curious as to how this will end, though
07:35:41 <ocharles> the more general problem is that the choice is by the consumer of the function, not the generation itself
07:35:44 <ocharles> because it's a GADT
07:35:52 <xunie-laptop> I always feel young when reading documents that predate me.
07:36:06 <xunie-laptop> Wrong room.
07:36:23 <dreixel> ocharles: is that significantly different from |read|? the type you instantiate it to also dictates its behaviour.
07:36:36 <Taneb> I think this is the kind of thing that can do well from memoizing
07:36:41 <ocharles> if you consider the 'Term a' GADT with "TInt :: Term Int | TBool :: Term Bool", I kind of what 'someTerm :: Term Int' or 'someTerm :: Term Bool' to be what determines which side of the sum to follow
07:37:00 <ocharles> someTerm is a producer of 'Term a', but the choice is determined by the instantiation of a
07:37:11 <merijn> ocharles: oh, are you trying to deal with "read" for GADTs?
07:37:16 <ocharles> yea, I think it's that!
07:37:20 <merijn> ocharles: There's no real nice way to do that :(
07:37:25 <ocharles> read feels like a better analogy than deserializing
07:37:28 <merijn> ocharles: Due to type erasure
07:37:41 <dreixel> then I guess you'll need a proof as an extra argument
07:37:50 <ocharles> dreixel: shoot. but in this case I have the ultimate type in 'entity' so I might be able to mess about wit hthat
07:40:21 <bscarlet> There's no Enum a => Enum (Maybe a) ?
07:40:37 <dreixel> ocharles: let me know if you run into further problems
07:40:47 <Jentrep> thanks luite
07:40:49 <ocharles> dreixel: sure thing. thanks for all the help so far, you've been awesome
07:40:51 <Jentrep> :)
07:40:58 <dreixel> ocharles: glad to be of help
07:41:46 <FreeFull> bscarlet: I don't think that Enum instance would make sense
07:42:00 <FreeFull> bscarlet: You can always fmap
07:42:11 <Work_jack> That sounds wrong
07:46:46 <bscarlet> bleah. I guess the problems are with figuring out where to put Nothing when the underlying enumeration uses negative Ints, or with the unfortunate overflow for (Maybe Int). Pttth.
07:47:15 <mightybyte> Anyone else having trouble installing MonadCatchIO-transformers?
07:47:31 <mightybyte> It looks like I can't even download it from hackage.
07:48:40 <applicative_tmp> cabal unpack monadcatchio-transformers workds
07:48:44 <applicative_tmp> works rather
07:49:18 <edwardk> mightybyte: that is why i wrote exceptions
07:49:32 <edwardk> mightybyte: MonadCatchIO-transformers won't work with head.
07:49:43 <applicative_tmp> but it's out of date
07:50:03 <mightybyte> unpack doesn't work for me.
07:50:11 <mightybyte> edwardk: head of what?
07:50:16 <edwardk> ghc
07:50:27 <edwardk> block/unblock are dead, only mask remains
07:50:32 <applicative_tmp> oh wait could it be i unpacked from ~/.cabal/wherever
07:50:34 <mightybyte> Oh, that doesn't bother me.
07:54:41 <Polarina> What would be the best way to install cabal? I just installed ghc 7.6.3 from the binary distribution.
07:55:29 <applicative_tmp> Polarina: get the source; inside there is bootstrap.sh
07:56:29 <applicative_tmp> Polarina: maybe get the github version now that there's a little tutorial on 'cabal sandbox'
07:56:57 <applicative_tmp> but that will be less sensible than getting the tarball from hackage
07:57:06 <Polarina> applicative_tmp, thanks. :)
07:57:50 <applicative_tmp> Polarina: this is about doing the whole platform that way, but has useful points http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
07:58:02 <mightybyte> cabal unpack MonadCatchIO-transformers
07:58:04 <mightybyte> cabal: <socket: 9>: timeout
07:58:10 <mightybyte> wtf
07:58:34 <tomejaguar> cabal unpack monadcatchio-transformers works for me
07:58:55 <mightybyte> Bizarre, it works for me on a different computer.
07:59:41 <Polarina> applicative_tmp, do you know if bootstrap.sh will compile profiling versions of cabal's dependencies too?
08:00:32 <applicative_tmp> cabal install is just an executable, if you use the one from hackage it wont need anything that didn't come with your ghc
08:00:59 <Polarina> Ok, nice.
08:02:33 <Polarina> applicative_tmp, it errors with missing dependencies: base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.6
08:02:36 <applicative_tmp> wait let me check that
08:02:47 <dcoutts> mightybyte: it'll have been trying to download it
08:03:01 <applicative_tmp> thats pretty weird dependencies
08:03:42 <dcoutts> applicative_tmp: it'll be the result of picking flags that give impossible deps
08:03:43 <mightybyte> dcoutts: I'm using a version from git several months old.  I'm upgrading to see if that helps.
08:03:56 <Polarina> applicative_tmp, http://codepad.org/PetqhZgV
08:04:19 <dcoutts> mightybyte: doubt it'll help, unless there's some unknown problem with the http package. Does it happen reliably?
08:04:47 <applicative_tmp> what I said above was wrong Polarina let me study a second
08:05:27 <Polarina> applicative_tmp, just glad that you're helping.
08:06:06 <mightybyte> dcoutts: On this machine, yes.
08:06:18 <applicative_tmp> Polarina: you dont still have your old cabal-install around?
08:06:19 <akegalj> i am using hsenv. while editing in vim with neocomplete, autocomplete works fine but not suggesting new installed packages from .hsenv. Am i missing some path in vim? I have added let g:ghc=system("which ghc")
08:06:24 <mightybyte> I just blew away my .ghc and most of .cabal the other day.  I wonder if that messed something up.
08:06:25 <akegalj> in my vim conf
08:06:59 <applicative_tmp> Polarina: i'm not sure why i've never had trouble with the profiling, but the bootstrap.sh doesnt seem to take account of it
08:09:03 <applicative_tmp> Polarina: in any event there is the expedient of using bootstrap.sh and then unregistering and reinstalling random, stm etc -- whatever didn't come with ghc
08:09:30 <applicative_tmp> but there is still the question of this error.
08:10:37 <applicative_tmp> Polarina: it is generally a good idea to keep the old cabal executable around til you've established everything; it will work with various ghcs
08:11:03 <applicative_tmp> Polarina: what does 'ghc-pkg list Cabal' say about the Cabal library?
08:11:23 <applicative_tmp> you should get the matching version of the cabal-install package
08:11:45 <Polarina> applicative_tmp, it says Cabal-1.16.0
08:13:08 <applicative_tmp> and thats the version of cabal-install http://hackage.haskell.org/package/cabal-install-1.16.0
08:13:50 <Polarina> applicative_tmp, I got cabal-install 1.14.0 as it seems to be the most recent version.
08:14:04 <Polarina> Got it from here: http://www.haskell.org/cabal/download.html
08:15:11 <mightybyte> dcoutts: Wow, upgrading solved the problem.
08:15:14 <applicative_tmp> hm, no                          http://hackage.haskell.org/package/cabal-install-1.16.0
08:15:21 <dcoutts> mightybyte: weird
08:15:33 <applicative_tmp> Polarina: it has a compressed package at the bottom of the page
08:15:41 <mightybyte> Yeah.  I suppose it's *possible* that it was a network issue that resolved itself.
08:16:09 <mightybyte> But I think that's unlikely because I could install plenty of other packages.  It seemed like MonadCatchIO-transformers was the only problem.
08:16:17 <Polarina> applicative_tmp, I'll try that version.
08:16:52 <applicative_tmp> -fllvm should be renamed -fglacial
08:17:42 <applicative_tmp> or -fpay-now-save-later
08:17:48 <TimUK> hey peeps!
08:18:14 <TimUK> anyone up for correcting my simple recurrisve fuctions?? 8)
08:18:18 <TimUK> I got stuck
08:18:26 <TimUK> 8(
08:18:49 <tikhon> TimUK: put it up on lpaste
08:19:05 <tikhon> recursion is tricky until you figure out the right way to think about it
08:19:35 <TimUK> getNextPrime n     | isPrime (n+1) == True = n+1     | otherwise = getNextPrime (n + 1)           getPrimeFactors n y a     | div n y = 1 = a:a     | mod n y = 0 = getPrimeFactors (div n y) y     | mod n y /= 0 = getPrimeFactors n (getNextPrime y)  --getprimefators 24 2 --mod 24 2 = 0 -> getprimesfactors (12) 2 --mod 12 2 = 0 -> getprimesfctors (6) 2 --mod 6 2 = 0  -> getprimesfctors (3) 2 --mod 3 2 = 1  -> getPrimeFactors 3 (3) --div
08:19:38 <applicative_tmp> namely, by figuring out which library function abstracts the kind you're writing....
08:19:39 <tikhon> @where lpaste
08:19:41 <lambdabot> http://lpaste.net/new/haskell
08:19:51 <tikhon> TimUK: use that URL; reading code from IRC is annoying
08:19:56 <TimUK> think im nearly there, just don't know how to terminate it correctly
08:19:58 <tikhon> all the formatting gets lost
08:20:16 * hackagebot stringable 0.1.1.1 - A Stringable type class, in the spirit of Foldable and Traversable  http://hackage.haskell.org/package/stringable-0.1.1.1 (KetilMalde)
08:20:29 <TimUK> what is the command for lpaste /lpaste ?
08:20:30 <tikhon> lpaste is just a paste site like pastebin, but optimized for Haskell
08:20:57 <tikhon> I don't know of a command for it—there's an Emacs package you can install though
08:21:05 <hpaste_> TimUK pasted “problem” at http://lpaste.net/91995
08:21:06 <tikhon> but you can also just use the website directly
08:21:09 <tikhon> awesome
08:21:29 <donri> there's "hpasteit" but it's not updated to use lpaste last i checked
08:21:39 <Cale> a : a  is definitely a type error
08:21:45 <tikhon> a note immediately: you don't have to use == True
08:21:58 * applicative_tmp was trying to type a:a too
08:22:00 <tikhon> ie isPrime (n + 1) is a valid condition itself
08:22:11 <tikhon> after all, True == True evaluates to True :)
08:22:21 <TimUK> hey i used lpaste on the website but what happens afterwards
08:22:22 <Cale> and False == True evaluates to False
08:22:29 <Cale> TimUK: now we can look at it
08:22:34 <tikhon> a message was posted on the IRC channel with the URL
08:22:35 <donri> > True == True == True
08:22:36 <lambdabot>   Precedence parsing error
08:22:36 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
08:22:40 <donri> hah
08:22:53 <TimUK> oh yeah see it now
08:22:57 <tikhon> it's very convenient
08:23:29 <Cale> also, you appear to be attempting to use = for equality testing
08:23:37 <Cale> in getPrimeFactors
08:24:11 <tikhon> also, I think you forgot to include your definition of isPrime
08:25:22 <hpaste_> TimUK pasted “problem” at http://lpaste.net/91996
08:25:33 <TimUK> hey I missed a bit actually
08:26:06 <applicative_tmp> > let infixl 2 ==; (==) = (Prelude.==) in True == False == False == True
08:26:06 <lambdabot>   True
08:26:31 <applicative_tmp> > let infixl 2 ==; (==) = (Prelude.==) in Flase == False == False == False
08:26:32 <lambdabot>   Not in scope: data constructor `Flase'
08:26:32 <lambdabot>  Perhaps you meant `False' (imported...
08:26:37 <applicative_tmp> > let infixl 2 ==; (==) = (Prelude.==) in False == False == False == False
08:26:38 <lambdabot>   True
08:27:20 <tikhon> TimUK: the first step is to fix the syntax error Cale mentioned
08:27:41 <tikhon> you need to use == for equality; = is for defining things
08:27:56 <TimUK> cool .. how would i make the function stop once that evaluates to true
08:28:17 <TimUK> div n y = 1 = stop or something
08:28:34 <tikhon> a function "stops" when it returns a value without a recursive call
08:28:39 <Cale> div n y = 1 would be a declaration (and doesn't belong in a guard)
08:28:51 <TimUK> ops will fix with ==
08:28:52 <Cale> div n y == 1  is a Bool value
08:29:12 <tikhon> you can edit that paste right on lpaste.net
08:29:22 <Cale> a : a is also not a valid list, because it would have to be the same type as its type of elements
08:29:40 <Cale> i.e. its type would satisfy the equation  t = [t]
08:29:40 <ocharles> sigh. any idea what causes this linker error?
08:29:42 <ocharles> (.text+0xe880): undefined reference to `musicbrainzzzmdatazm0zi0zi1_MusicBrainzzziDataziISNI_zdfViewTreePartentitySetzuzdcviewTreePart_info'
08:29:45 <ocharles> everything compiles just fine...
08:29:57 <ocharles> All modules are mentioned in exported-modules and other-modules in the cabal file
08:30:14 <tikhon> ooh, I really hate linker errors
08:30:15 <Cale> ocharles: Is musicbrain in the dependencies?
08:30:19 <ocharles> I've ran cabal clean and tried again, but it gives the same result
08:30:20 <ocharles> yes
08:30:28 <Cale> ghc-pkg check
08:30:32 <shergill> an infinitely nested list
08:30:33 <ocharles> I've made a handful of code changes, and it was building before that
08:31:15 <ocharles> I've just stashed my changes, lets see if it builds without them
08:31:34 <ocharles> but this was building half an hour ago and I haven't installed anything since
08:31:34 <hpaste_> TimUK revised “problem”: “updated” at http://lpaste.net/91996
08:31:41 <Cale> make sure you don't have more than one version of that package installed
08:31:55 <ocharles> that package is the library I'm working on :0
08:31:57 <ocharles> :)
08:32:42 <applicative_tmp> TimUK: you still have the mind-bending a:a
08:32:49 <Cale> No he doesn't
08:33:02 <Cale> But the problem is similar
08:33:09 <TimUK> lol!
08:34:02 <Cale> TimUK: whenever you write h:t, you're constructing a list whose first element is h and where the rest of the list is t.
08:34:16 <TimUK> you know what im trying to do is capture what y is and put it in a list and then return that
08:34:30 <Cale> Maybe you just want the result to be [y] ?
08:34:37 <applicative_tmp> oh i see, i used curl http://lpaste.net/raw/91996 which is mysteriously different
08:34:40 <Cale> (which is y : [])
08:34:53 <Cale> You can just write [y] though.
08:35:43 <applicative_tmp> lpaste.net/raw/n+1 = lpaste.net/n
08:35:49 <Cale> also getPrimeFactors explicitly has three parameters, but you're only giving it two in the other two lines
08:35:52 <hpaste_> TimUK revised “problem”: “omg it didn't crash!” at http://lpaste.net/91996
08:36:02 <TimUK> i taste victory it soon!
08:36:15 <Cale> You... didn't fix it
08:36:28 <Cale> oh, well, you fixed the not enough parameters thing
08:36:38 <Cale> though it's unclear what 'a' is for
08:38:18 <TimUK> ah, well in this case a should have returned [2, 2, 2, 3]
08:40:46 <TimUK> im gonna work on this a bit more thanks for the helps all!
08:41:01 <Cale> TimUK: If mod n y == 0, it means that y is a factor of n, right? So perhaps y should be an element of the resulting list?
08:41:28 <Cale> Instead, the resulting list in that case is the list of prime factors of (div n y) starting from y.
08:42:11 <TimUK> that sounds like what im after
08:42:13 <Cale> (which in general won't include y)
08:42:20 <TimUK> oic
08:42:38 <ocharles> The minimal changes to cause the above linker error seems to be using the default implementation of a type class... (a type class I wrote in the same library)
08:43:05 <TimUK> okay ill work on that bit a bit more, thanks !
08:43:08 <tikhon> TimUK: out of curiosity, are you working on project Euler problems?
08:43:16 <TimUK> yeah you got me!
08:43:26 <tikhon> awesome
08:43:31 <TimUK> but as you see im just learning haskell
08:43:42 <tikhon> your approach is much better than my half-drunk Rust prime checker :P
08:43:54 <tikhon> I just included a literal array of the first ~10,000 primes
08:44:04 <TimUK> cool!
08:44:11 <TimUK> what number problem are you on?
08:44:18 <Cale> Here's my favourite implementation of the list of primes / isPrime, even if it's not all that fast:
08:44:20 <tikhon> oh, I don't do them sequentially
08:44:48 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
08:44:49 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
08:45:19 <TimUK> nice
08:45:23 <Cale> Mutual recursion between the list of primes and the primality tester :)
08:46:13 <TimUK> heres my friend key on Euler friend me if you want! 20722795512760_cf4b6a4335c2d3402ea4de14c1783687
08:46:28 <Cale> I don't have an account there
08:46:33 <TimUK> ah shame
08:46:41 <tikhon> and I, embarassingly, can't remember my username :P
08:46:47 <TimUK> lol
08:46:49 <tikhon> it's probably some variation on "tikhon" though
08:46:53 <tikhon> I'm creative like that
08:47:08 <TimUK> I'll keep an eye out when i post my answer next
08:47:27 <TimUK> cya peeps!
08:48:28 <Polarina> applicative_tmp, it seems to work now. Thank you for your help. :)
08:48:48 <applicative_tmp> oh awesome Polarina
08:54:39 <ocharles> urgh, this linking problem really does feel like a GHC bug
08:54:56 <exicer> I still find when I try to install hlint from cabal it fails :(
08:55:11 <ocharles> ghc-pkg check is happy, and changing one line makse the linker happy
08:55:30 <exicer> http://lpaste.net/91999
08:55:47 <exicer> Anyone got any ideas what is going on?
08:56:37 <supki> exicer: you can try with haskell-src-exts < 1.14
08:56:59 <exicer> supki: Is that an option for cabal ?
08:57:42 <supki> in cabal-speak that would be --constraint='haskell-src-exts < 1.14' I think
08:58:52 <exicer> What is that doing exactly ? It seems to be working
08:59:49 <supki> it tells cabal to peek haskell-src-exts version that's lower than 1.14 when solving hlint dependencies
09:00:13 <exicer> Ok - not quite sure what that means, but thanks :)
09:01:01 <exicer> Ah, so it is using extensions that are below a certain revision
09:01:18 <applicative_tmp> exicer: in the new version there is a distinction of types Extension KnownExtension in the others there is just Extension
09:01:53 <applicative_tmp> this is haskell-src-exts ; hlint doesnt know about this distinction yet
09:02:22 <applicative_tmp> supki's solution is, *to go back in time*
09:08:43 <exicer> Ok, thanks :)
09:10:13 <donri> and people whine about upper bounds
09:22:21 * heath is looking for an example of an http hello world server which takes advantages of all cores
09:22:32 <heath> s/advantages/advantage
09:23:35 <DaveS> if I have 2 lists how can I remove all elements from list A that are in list B
09:23:45 <DaveS> is there a library function for that?
09:24:29 <scshunt> DaveS: \\
09:25:16 <DaveS> thank you
09:27:46 <donri> heath: i think all the popular haskell web servers will do that if compiled with -threaded and run with +RTS -N
09:27:55 <donri> @where web
09:27:56 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
09:28:20 <Cale> DaveS: Note that \\ will only remove as many copies of an element from A as the number of times it occurs in B
09:28:31 <Cale> > [1,1,1,2,2,3,3,3] \\ [1,2,3,4]
09:28:33 <lambdabot>   [1,1,2,3,3]
09:28:55 <Cale> > [1,1,1,2,2,3,3,3] \\ [1,1,2,2,3,3]
09:28:56 <lambdabot>   [1,3]
09:29:15 <donri> heath: but note that a network server is IO bound and won't scale linearly on current ghc (next version will)
09:29:34 <kuribas> > [1, 1, 2] \\ [2, 1]
09:29:36 <lambdabot>   [1]
09:29:54 <joneshf-laptop> im trying to finish 8.7 from htcofp.  It's a proof about zip and unzip.  I'm at the last step, i think, but i can't make the leap.  Can someone take a look and see what i'm missing?  Or rather where my mistake is: http://lpaste.net/92000
09:31:34 <exicer> Damn, the Foundation.hs in yesod looks kinda hard to understand..
09:31:39 <Cale> joneshf-laptop: zs went missing
09:32:20 <joneshf-laptop> Cale: should I change my definition of unzip?
09:32:25 <byorgey> joneshf-laptop: you introduced xs and ys but you forgot to note where they came from
09:32:42 <byorgey> joneshf-laptop: in fact, they come from a recursive call to unzip
09:32:49 <byorgey> so you will be able to use the induction hypothesis
09:33:48 <Polarina> I'm trying to 'cabal install hlint' and it complains about not finding happy>=1.17 when compiling haskell-src-exts-1.14.0. I have happy-1.18.10 installed and in PATH. :(
09:34:29 <joneshf-laptop> byorgey: hmm, i'm not sure i understand what you mean by being able to use the hypot
09:34:35 <Cale> joneshf-laptop: Specifically, it appears you have xs = fst (unzip zs) and ys = snd (unzip zs) yes?
09:34:59 <dcoutts> Polarina: double check it really is in the path, if it is cabal should find it, and check it's not masked by another version earlier
09:35:04 <joneshf-laptop> Cale: yes
09:35:05 <dcoutts> Polarina: e.g. hash -r; happy --version
09:35:12 <joneshf-laptop> Cale: hidden at least
09:35:13 <Cale> joneshf-laptop: So zip xs ys = zip (fst (unzip zs)) (snd (unzip zs))
09:35:31 <Cale> and by the induction hypothesis, this is equal to zs
09:35:48 <Polarina> dcoutts, oh, it seems that cabal doesn't like me using PATH="~/.cabal/bin:$PATH". Had to change it to a fully qualified location.
09:37:44 <joneshf-laptop> hmm, let me play with it a bit, thanks byorgey , Cale
09:38:41 <Cale> joneshf-laptop: when you apply unzip, you should perhaps represent the binding that it creates using 'let ... in ...'
09:39:27 <dcoutts> Polarina: right, you can't generally use ~ in the PATH, that's something the shell understands but not other programs
09:39:42 <dcoutts> it only works because the shell can usually expand it before passing it to the program
09:39:53 <Polarina> dcoutts, that makes sense. Thanks.
09:40:00 <dcoutts> Polarina: e.g. echo ~/
09:41:06 <Polarina> dcoutts, you might not happen to know why I would be getting this error though?: http://codepad.org/Ix4TgtP7
09:42:23 <dcoutts> Polarina: hlint is clearly expecting a different Cabal lib version
09:43:26 <Polarina> I guess I'll have to live with sloppier code quality then.
09:43:50 <Polarina> dcoutts, thank you.
09:44:18 <dcoutts> Polarina: or build it against an older Cabal lib version
09:44:21 <dcoutts> like 1.6.x
09:45:01 <Polarina> I'll just break things messing with cabal. Look at it wrong and it looks at you the same way too.
09:45:30 <joneshf-laptop> Cale: got it, my unzip was too terse.
09:46:14 <joneshf-laptop> Cale: thanks
09:46:19 <applicative_tmp> oh this hlint nonsense is continuing
09:46:22 <byorgey> joneshf-laptop: you should be able to complete the proof just fine using your original definition of unzip.
09:47:46 <cvic> hm, can't get lambdabot on a freenode channel
09:47:51 <applicative_tmp> hm, the new hlint is 2 days old; the new haskell-src-exts is 0 days old
09:47:55 <cvic> good thing it's wotking offline
09:47:59 <cvic> *working
09:50:06 <applicative_tmp> Polarina: oh if that's the most recent error, it's that you're still building with today's haskell-src-exts
09:50:20 <Cale> byorgey: I think he was just saying that his expansion of unzip was too terse (it left out the binding of xs and ys)
09:50:29 <byorgey> oh, maybe so
09:50:41 <applicative_tmp> Polarina: but you need the at-least-three-days-ago haskell-src-exts; it isn't a Cabal issue
09:51:57 <applicative_tmp> Polarina: if you do 'ghc-pkg list haskell-src-exts' it will tell you if you have two versions
09:52:45 <applicative_tmp> Polarina: cabal install will default to taking the more recent one, I think; which you still have
09:55:02 <joneshf-laptop> byorgey: yeah, it wasn't spelled out enough in the definition for me to just use it as justification.  I'm probably just being pedantic about it.
09:55:21 <joneshf-laptop> byorgey: thanks though :)
09:55:31 <byorgey> joneshf-laptop: pedantic is good!
09:55:48 <byorgey> I'm just saying that there IS a (fully pedantic) way to complete the proof using your original definition
09:56:56 <byorgey> but if you understand the central idea, that's the most important part.
09:57:29 <joneshf-laptop> byorgey: hmm, more with english sentences than with haskell sentences?
09:57:50 <joneshf-laptop> byorgey: or can you just say it's the case by inspection?
10:00:21 <carp> Im falling in love. Haskell is something I want to be awesome at. I cant wait to gain skills!
10:00:31 <cvic> <socket: 9>: hGetLine: end of file   oh well
10:00:43 <Cale> carp: Feel free to hang around and ask any questions you might have.
10:00:50 * cvic bashes his head with a keyboard 
10:00:53 <carp> Thankyou
10:00:54 <blochchain> https://github.com/plsql/Haskell-Snippets/blob/master/readability.hs    any suggestions on optimizing and clarifying this code?
10:01:26 <byorgey> joneshf-laptop: no, no English sentences
10:01:30 <byorgey> joneshf-laptop: just a second
10:03:13 <Cale> blochchain: That's some interesting use of the Applicative instance for lists
10:03:13 <cvic> blochchain: Bitcoin stuff and Haskell? Very interesting
10:03:49 <Cale> Heh, when I first saw the name, I thought it had something to do with quantum bitcoins (qubitcoins?)
10:03:59 <hpaste_> byorgey annotated “htcofp 8.7” with “htcofp 8.7 (annotation)” at http://lpaste.net/92000#a92004
10:04:01 <Cale> (http://en.wikipedia.org/wiki/Bloch_sphere)
10:04:11 <byorgey> joneshf-laptop: like that ^^^
10:04:41 <blochchain> cvic, i ended up using python for that. efficiency (particularly memory efficiency) was too much of a concern to be using Haskell as a non-expert
10:04:46 <byorgey> joneshf-laptop: the key is using  (fst.1) and (snd.1) backwads to go from  xs   to  fst (xs,ys)  etc.
10:04:56 <byorgey> joneshf-laptop: then you can substitute for (xs,ys)
10:04:57 <blochchain> the bitcoin stuff was for summer research, i'm a rising sophomore undergrad
10:05:59 <blochchain> also, what's the best way for me to get the syllable-count of a word in Haskell?
10:06:26 <cvic> blochchain: for English
10:06:42 <Cale> blochchain: It might be worth noting that or $ isSuffixOf <$> ps <*> [xs] can be written  any (`isSuffixOf` xs) ps
10:06:57 <byorgey> joneshf-laptop: also, just a stylistic thing, instead of writing   thing-you-are-working-with = thing-you-want-to-get  on each line, omit  thing-you-want-to-get  and just write an equals in between each line
10:07:04 <blochchain> ah, thanks Cale
10:07:07 <Sculptor> oyo
10:07:12 <byorgey> because that's really the point, you are transforming one expression through a series of equalities into another expression
10:07:36 <donri> blochchain: you might look at http://hackage.haskell.org/packages/archive/pkg-list.html#cat:natural%20language%20processing for starters
10:07:39 <blochchain> wait, Cale, i think you might be misunderstanding the logic. there's only one xs and many ps
10:07:56 <Cale> blochchain: I don't think I misunderstood it.
10:08:33 <Cale> blochchain: note the backticks. That's an operator section :)
10:08:34 <blochchain> ah right Call, I didn't know any existed
10:11:13 <Cale> blochchain: (not . null . drop 1) will be somewhat more efficient than (\x -> length x > 1)
10:11:39 <shachaf> It's especially more efficient for infinite lists.
10:11:47 <Cale> It might be worth thinking about whether combine can be a foldr too...
10:11:47 <donri> "somewhat"
10:12:16 <Cale> acc ++ [sent] is suspicious, and horrible performance-wise
10:12:34 <Cale> xs ++ ys takes O(length xs) time to fully compute
10:13:11 <blochchain> Cale, i think it can be foldr
10:13:18 <blochchain> it's associative, I believe
10:13:26 <Cale> In that case, it should be.
10:14:54 <blochchain> i also noticed that hasException takes an arg that it doesn't use
10:15:02 <blochchain> odd that hlint didn't catch some of these things
10:15:13 <blochchain> hlint is still my favorite thing in the world, however
10:15:23 <blochchain> it really sums up a lot of why i love haskell
10:15:37 <Cale> @src foldr
10:15:38 <lambdabot> foldr f z []     = z
10:15:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:15:53 <blochchain> cleverness can usually reduce everything into a concise line or two
10:15:53 <Cale> @src foldl
10:15:54 <lambdabot> foldl f z []     = z
10:15:54 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:16:09 <Cale> foldl does nothing except to apply itself to new arguments until it reaches the end of the list
10:16:15 <Cale> foldr immediately passes control to f
10:16:49 <Cale> If you're producing a list, this means that the first cons cell of that list might become available before the foldr is finished.
10:16:57 <Cale> > foldr (:) [] [1..]
10:16:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:17:02 <Cale> ^^ this works
10:17:18 <arkeet> > foldl undefined undefined (repeat undefined)
10:17:28 <lambdabot>  Terminated
10:17:34 <blochchain> > foldl (:) [] [1..]
10:17:37 <Cale> > foldl (flip (:)) [] [1..] -- obviously can't produce anything
10:17:39 <lambdabot>   can't find file: L.hs
10:17:44 <Cale> oops
10:17:44 <lambdabot>  Terminated
10:17:47 <arkeet> blochchain: that's a type error.
10:18:14 <ParahSai1in> somehow a constructor field name is getting hidden
10:18:24 <arkeet> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
10:19:26 <blochchain> using foldr messed something up
10:19:30 <blochchain> not totally sure what
10:20:06 <Cale> blochchain: Well, did you change the parameter order?
10:20:42 <blochchain> in the lambda? yeah
10:20:48 <blochchain> you're supposed to, right?
10:20:51 <Cale> yeah
10:21:20 <blochchain> it's inserting periods willy-nilly or something
10:21:21 <Cale> But then, if you do that, you'll also have to swap the order in which the resulting list is produced
10:21:36 <Cale> which is good for you
10:21:56 <Cale> because it means you can use x:xs instead of xs ++ [x]
10:22:08 <blochchain> ahhh yes right
10:26:28 <blochchain> hmm, continually getting bizarre errors and trying to fix them.
10:26:53 <blochchain> this definitely is the way to go, though, because cons is a way better option that list-casting and concat
10:27:13 <blochchain> i need to step back for a minute and think about what's happening
10:28:09 <joneshf-laptop> byorgey: ah, I see what you mean.
10:28:59 <blochchain> @src foldr
10:29:00 <lambdabot> foldr f z []     = z
10:29:00 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:29:08 <joneshf-laptop> byorgey: and yeah, this is pretty gruesome.  I started this chapter late one night, and it looks like this now.
10:30:25 * hackagebot stylish-haskell 0.5.8.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.8.0 (JasperVanDerJeugt)
10:40:25 * hackagebot derive 2.5.12 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.12 (NeilMitchell)
10:41:18 <SS_JJ> if I have a type data MessageQueue a = MessageQueue (Mailbox a) [Consumer a] Int; is there some automatic way to access the "fields" except for patternmatching? like fmap for a type with 3 elements
10:42:31 <Rarrikins> SS_JJ: Either use record syntax or create accessor functions.
10:42:34 <scshunt> SS_JJ: not directly, no. You could use record syntax, however, or you could create accessors that do the pattern matching for you
10:48:29 <scshunt> SS_JJ: record syntax is commonly used just to create accessors even if record syntax is never used for matching or construction
10:48:50 <scshunt> SS_JJ: you may also be interested in Lens
10:50:25 * hackagebot monoid-extras 0.3.1.0 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.3.1.0 (BrentYorgey)
10:52:07 <simukis_> So `something . cosomething = id` as in `monad . comonad = id`?
10:52:45 <joelteon> :t join . extract
10:52:46 <lambdabot> Not in scope: `extract'
10:53:45 <tikhon> simukis_: I'm not sure that statement really makes sense.
10:54:37 <simukis_> tikhon: just trying to figure out wether co* are exact oposites of *.
10:55:25 * hackagebot units 1.0.1 - A domain-specific type system for dimensional analysis  http://hackage.haskell.org/package/units-1.0.1 (RichardEisenberg)
10:55:30 <tikhon> read about duality in category theory: https://en.wikipedia.org/wiki/Dual_%28category_theory%29
10:56:34 <tikhon> roughly speaking, given a something in some category C, a co-something is a corresponding construction in the category Cᵒᵖ, which is just C with all the morphisms reversed
10:57:08 <tikhon> so to make a co-something, just take a something and flip all the arrows
10:57:26 <tikhon> but I don't think this relationship implies anything besides that
10:57:45 <ksf_> which is, like everything in abstract nonsense theory, easily explained and impossible to grok.
10:57:52 <tikhon> something like that
10:57:59 <tikhon> my favorite example is product types and sum types
10:58:08 <tikhon> pictures help
10:58:26 <tikhon> (pictures always help—see LYAH—but here the pictures can even be *relevant*)
10:58:47 <simon> someone wrote here a definition for 'container' and asked if there were other, simpler monads(?) than Cont that were examples of non-container monads. I forgot the rigid definition for a monad. can anyone tell me this or point in a direction where such a distinction is made?
10:59:13 <tikhon> I don't know how you would define "container" :/
10:59:29 <simon> there was some mathematical definition using quantifiers, I think.
10:59:38 <simon> (I initially thought he referred to the metaphor)
11:05:50 <blochchain> Cale, thanks so much for the suggestions. foldr really simplified my code
11:06:17 <Cale> blochchain: cool! :)
11:07:57 <shergill> simon: i think i know what you're referring to
11:07:59 <shergill> let me look
11:09:03 <sclv> simon: here's a containers paper http://www.cs.nott.ac.uk/~txa/publ/cont-tcs.pdf
11:09:13 <sclv> one of the standard ones
11:09:22 <shergill> simon: the quote was by roconnor
11:09:30 <shergill>   (19:32:05 08/02/13) <roconnor> I believe the definiton of containaer is the same as "strictly positive functor".
11:09:31 <sclv> all strictly positive types can be represented as containers
11:09:34 <carter> tikhon: thanks for chiming in on HN :)
11:09:52 <sclv> right. so you need your 'a' in the negative position to not be a containers, basically
11:09:53 <simon> shergill, thanks!
11:09:59 <sclv> and cont is about the simplest thing that gets you there
11:10:00 <simon> and thanks sclv :)
11:15:26 * hackagebot hlint 1.8.51 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.51 (NeilMitchell)
11:24:52 <shergill> sclv: i was here asking about symplecticity (i'm looking at it within the context of hamiltonian dynamics), and edwardk said you might be able to point me in the right direction. i'd like to get an understanding for what symplecticty entails (the wikipedia page seemed quite opaque to me)
11:25:17 <shergill> would you happen to have any references which might be useful?
11:25:26 * hackagebot hoogle 4.2.17 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.17 (NeilMitchell)
11:25:27 <sclv> gah i can hum a few bars here and there but don't know what it means to point you in the right direction exactly
11:25:37 <sclv> are you interested from the standpoint of symplectic integrators?
11:26:38 <sclv> as is the question is awfully vague
11:27:07 <shergill> not sure what 'integrators' there refers to. but i'm trying to get a more thorough understanding of hamiltonian monte carlo. one of the attractive properties that neal's paper states is that hamiltonian dynamics are symplectic (he uses it to prove that the dynamics are thus volume preserving), but i was wondering if there are any implications over and above
11:28:36 <sclv> well an integrator is something like euler's method for calculating the numerical solution to a differential equation
11:28:51 <sclv> if you remember your basic calc, you'll recall that euler's method gets increasingly crummy with each step
11:29:26 <sclv> if your differential equation is additionally constrained by the laws of physics, like the preservation of a hamiltonion
11:29:42 <sclv> then you can immediately get better integrators by requiring that they also obey those other laws
11:29:52 <sclv> so a simple of that is semi-implicit or symplectic euler: http://en.wikipedia.org/wiki/Semi-implicit_Euler_method
11:30:44 <sclv> so if you are in a situation where you want to grind through approximating differential solving, and you know that you are working over a symplectic manifold
11:30:58 <sclv> then you can instead of using a crummy solver like euler, use a symplectic solver
11:31:09 <sclv> which is typically more precise and cheaper than a good non-symplectic solver
11:31:20 <sclv> so that's the advantage i imagine you get in hmc
11:31:50 <shergill> yeah, partly. same for leapfrog method
11:32:19 <shergill> in hmc, volume preservation by itself also frees you from having to do extra bookkeeping and renormalization
11:34:52 <shergill> sclv: why are symplectic solvers better? or rather, what gives them the ability to be better? is it that the 'volume preservation' property also provides increased stability over repeated applications (keeping the errors from getting compounded as it were)?
11:35:13 <sclv> well they're better because they can use more information
11:35:24 <sclv> or rather, you can use a symplectic solver on any equation
11:35:38 <sclv> but on equations that _additionally_ are constrained by physical laws
11:35:45 <sclv> then that solver _also_ respects those laws, unlike other solvers
11:35:54 <sclv> so in those _specific_ equations over symplectic manifolds
11:36:17 <sclv> then they tend to work better
11:36:23 <shergill> gotcha, and in the other cases they're no worse?
11:36:32 <sclv> that's a strong statement :-)
11:36:50 <sclv> you can always cook up a degenerate case to flummox any integrator
11:37:03 <sclv> in other cases, they're better than some and worse than others
11:37:14 <sclv> that's all you can say in general :-(
11:39:06 <SS_JJ> scshunt: yes i here about these lenses.
11:39:17 <sclv> shergill: the last paper in this collection (starting on p. 95) was recommended to me as a good piece on variational integrators in general http://ddg.cs.columbia.edu/SIGGRAPHASIA08/SiggraphAsia2008DDGCourse.pdf
11:39:20 <shergill> hmm k
11:39:47 <shergill> sclv: thanks!
11:40:20 <sclv> no prob
11:40:23 <SS_JJ> anyway if i do a lot of operations like f :: (a -> b) -> Mailbox a -> (Maybe b, Mailbox a), that seems very state-ish, use state monad?
11:41:40 <Polarina> SS_JJ, it is not exactly clear what that function does.
11:42:21 <carter> woah thats a big pdf :)
11:42:42 <c_wraith> Polarina: it *does* match State's use pattern, though
11:43:14 <c_wraith> it'd be f :: (a -> b) -> State (Mailbox a) (Maybe b)
11:45:25 <ReinH> Just got my dead tree copy of Parallel and Concurrent Programming in Haskell :D
11:46:14 <carter> woot
11:46:22 <carter> kill all the tree farms :)
11:46:33 <Polarina> Need more lumber!
11:46:35 <hiptobecubic> oh it's done?
11:46:44 <c_wraith> aaargh.  What the heck, GHC...  I have two modules with overlapping instances.  In one of them, it doesn't care if I specify the extension.  In the other, it's required.
11:46:50 <hiptobecubic> I remember reading the draft version for comments on the site a few months ago
11:48:08 <t4nk500> hey peeps! anyone know if there is a function similar to union, but where it drop duplicates from the second list?
11:48:15 <carter> nub?
11:48:18 <t4nk500> *doesn't
11:48:25 <carter> oh
11:48:28 <t4nk500> srry
11:48:31 <carter> depends on the data structure?
11:48:42 <c_wraith> For lists, isn't that (++) ?
11:48:48 <t4nk500> ah, I'm trying to run this union [2] [7, 3, 2, 2]
11:49:11 <t4nk500> but i want 7 3 2 2 back
11:49:29 <c_wraith> that's the most bizarre thing I can imagine wanting. :P
11:49:39 <t4nk500> lol
11:49:48 <c_wraith> > [2, 2] \\ [2]
11:50:00 <c_wraith> ...  is lambdabot gone again?
11:50:41 <c_wraith> drat, (\\) doesn't work the way I'd hoped
11:50:45 <tikhon> > 1  + 2
11:50:47 <tikhon> looks like it
11:51:36 <c_wraith> wow, (\\) doesn't have *any* properties I'd expect of it.
11:51:53 <tikhon> what did you expect?
11:52:37 <lambdabot>   [2]
11:52:37 <lambdabot>   3
11:52:37 <c_wraith> I expected [2, 2] \\ [2] to be [], and when that failed, I expected [2,2] \\ cycle [1,2,3] to not diverge
11:52:45 <c_wraith> ok..  not gone, just slow
11:52:54 <tikhon> > 1 + 2
11:52:57 <lambdabot>   3
11:53:03 <tikhon> maybe he just took a coffee break
11:53:05 <tomejaguar> > "I am here"
11:53:06 <lambdabot>   "I am here"
11:53:42 <arnsholt> An infinite list on the RHS diverging isn't that surprising though, is it?
11:54:02 <tikhon> arnsholt: I guess you'd expect a case like [] // _ = []
11:54:15 <arnsholt> That's true, I guess
11:54:18 <c_wraith> that case is exactly what I was expecting
11:54:21 <danharaj> @src //
11:54:21 <lambdabot> arr@(Array l u _) // ies = unsafeReplace arr [(index (l,u) i, e) | (i, e) <- ies]
11:54:25 <tikhon> where by "you" I meant "c_wraith" :P
11:54:58 <tikhon> I do not know what to make of that source
11:55:08 <c_wraith> It's for a different type. :)
11:55:11 <tikhon> yes
11:55:21 <Jentrep> zomg on? :)
11:55:39 <carter> tikhon sclv (and everyone): soon there'll be some simple SIMD vector libs for 7.6 :)
11:55:52 <tikhon> yay
11:55:59 <b2coutts> @src \\
11:56:00 <lambdabot> (\\) = foldl (flip delete)
11:56:09 <tikhon> or more like yay yay yay yay :D
11:56:11 <b2coutts> wrong character :P
11:56:15 <c_wraith> dunno.  That source looks pretty sane to me.
11:56:25 <b2coutts> @src delete
11:56:25 <lambdabot> delete = deleteBy (==)
11:56:40 <b2coutts> let's see how far the rabbit hole goes...
11:56:41 <tikhon> @src deleteBy
11:56:42 <lambdabot> deleteBy eq x []        = []
11:56:42 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
11:56:46 <arkeet> not that far
11:56:51 <tikhon> farish, I would say
11:56:53 <b2coutts> apparently not :P
11:57:00 <arkeet> :t split
11:57:01 <lambdabot> Splitter a -> [a] -> [[a]]
11:57:03 <arkeet> :t splitAt
11:57:03 <lambdabot> Int -> [a] -> ([a], [a])
11:57:05 <c_wraith> foldl?  weird.  I really expected \\ to be a foldr
11:57:06 <arkeet> :t splitOn
11:57:07 <lambdabot> Eq a => [a] -> [a] -> [[a]]
11:57:13 <arkeet> hm.
11:57:22 <arkeet> c_wraith: the foldl is over the second argument.
11:57:26 <arkeet> the list of things to remove.
11:57:31 <c_wraith> oh
11:57:35 <b2coutts> (foldr (flip delete)) [2,2] cycle [1,2,3]
11:57:37 <t4nk500> anyone know of a function that given this list [[2],[7],[3,2,2],[7,3],[7,3,2]] would end up with [2, 2, 3, 7] I thought i could use union and foldl but union drops duplicates in the 2nd list, and I couldn't get foldl to work with it anyway ... you think I would need to make a new function from scratch?
11:57:38 <b2coutts> > (foldr (flip delete)) [2,2] cycle [1,2,3]
11:57:39 <lambdabot>   Couldn't match type `[[t2] -> t0]' with `[t2] -> t0'
11:57:39 <lambdabot>  Expected type: ([t2] ...
11:57:47 <b2coutts> oh, right, foldr and foldl are different and stuff
11:57:59 <arkeet> > [] \\ undefined
11:58:01 <lambdabot>   *Exception: Prelude.undefined
11:58:03 <arkeet> =(
11:58:10 <arkeet> > [] \\ [undefined
11:58:11 <arkeet> > [] \\ [undefined]
11:58:11 <lambdabot>   <hint>:1:17:
11:58:11 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
11:58:12 <lambdabot>   []
11:58:46 <arkeet> b2coutts: how about foldr delete
11:58:50 <arkeet> :t foldr delete
11:58:51 <lambdabot> Eq a => [a] -> [a] -> [a]
11:59:07 <b2coutts> well, trying it is easier than reasoning about whether or not it'll work :P
11:59:18 <b2coutts> > (foldr delete) [2,2] cycle [1,2,3]
11:59:19 <lambdabot>   Couldn't match type `[a0]' with `[t2] -> t0'
11:59:19 <lambdabot>  Expected type: a0 -> ([t2] ->...
11:59:26 <arkeet> :t foldr delete [1,3,5] [1,2,3,4]
11:59:27 <lambdabot> (Eq a, Num a) => [a]
11:59:30 <arkeet> > foldr delete [1,3,5] [1,2,3,4]
11:59:31 <lambdabot>   [5]
11:59:37 <b2coutts> > (foldr delete) [2,2] (cycle [1,2,3])
11:59:38 <lambdabot>   *Exception: stack overflow
11:59:40 <carter> hehe, somethings wrong with me, i'm catching bugs in my C code by looking at the assembly :)
11:59:42 <arkeet> > foldr delete [1..] [1..3]
11:59:43 <lambdabot>   [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30...
11:59:52 <arkeet> > foldr delete [1..] [9,5]
11:59:53 <lambdabot>   [1,2,3,4,6,7,8,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
11:59:55 <arkeet> right.
12:00:13 <arkeet> > foldr delete [1..] [3..]
12:00:14 <lambdabot>   *Exception: stack overflow
12:00:16 <arkeet> =)
12:00:40 <c_wraith> t4nk500: I'm not sure what the rules are.  Do you mean "every number in a a sublist, appearing the maximum number of times it appears in any single sublist"?
12:02:20 <ion> > unwords . map join . sequence $ [["M","T"], ["i","a"], ["ss","ll"], ["i","a"], ["ss","h"], ["i","a"], ["pp","ss"], ["i","ee"]]
12:02:21 <lambdabot>   "Mississippi Mississippee Missississi Missississee Mississappi Mississappee...
12:02:35 <b2coutts> t4nk500: ah, are you doing that project euler question?
12:06:44 <merijn> carter: I was catching bugs in my C code by looking at my haskell :p
12:07:15 <carter> i'll be transitioning to that too soon
12:07:29 <carter> assembly on modern cpus has more type info than C
12:07:30 <carter> :(
12:07:44 <carter> at least in terms of whats going on in the micro architecture level
12:08:12 <joelteon> :t join . sequence
12:08:12 <lambdabot> [[a]] -> [a]
12:08:17 <joelteon> wat
12:08:48 <tikhon> :t sequence
12:08:49 <lambdabot> Monad m => [m a] -> m [a]
12:08:56 <tikhon> replace m with [] also
12:09:00 <tikhon> [[a]] -> [[a]]
12:09:05 <tikhon> :t join
12:09:06 <lambdabot> Monad m => m (m a) -> m a
12:09:10 <tikhon> [[a]] -> [a]
12:09:25 <ParahSai1in> @src [] join
12:09:25 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:09:30 <arkeet> > fix sequence
12:09:31 <ParahSai1in> @src join
12:09:31 <lambdabot> join x =  x >>= id
12:09:37 <lambdabot>   mueval-core: Time limit exceeded
12:09:46 <arkeet> > iterate sequence [[1]]
12:09:47 <lambdabot>   [[[1]],[[1]],[[1]],[[1]],[[1]],[[1]],[[1]],[[1]],[[1]],[[1]],[[1]],[[1]],[[...
12:09:50 <arkeet> > iterate sequence [[1,2]]
12:09:51 <lambdabot>   [[[1,2]],[[1],[2]],[[1,2]],[[1],[2]],[[1,2]],[[1],[2]],[[1,2]],[[1],[2]],[[...
12:09:57 <arkeet> heh.
12:10:02 <arkeet> > iterate sequence "abc"
12:10:03 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[a0]'
12:10:03 <lambdabot>  Expected type: [[a0]]
12:10:03 <lambdabot>    ...
12:10:10 <arkeet> > iterate sequence ["abc"]
12:10:11 <lambdabot>   [["abc"],["a","b","c"],["abc"],["a","b","c"],["abc"],["a","b","c"],["abc"],...
12:10:17 <arkeet> > iterate sequence ["ab","c"]
12:10:18 <lambdabot>   [["ab","c"],["ac","bc"],["ab","ac","cb","cc"],["aacc","aacc","aabc","aabc",...
12:10:40 <arkeet> > iterate sequence ["a","bc"]
12:10:40 <lambdabot>   [["a","bc"],["ab","ac"],["aa","ac","ba","bc"],["aabb","aabc","aaab","aaac",...
12:10:53 <arkeet> > iterate sequence ["ab","cd"]
12:10:54 <lambdabot>   [["ab","cd"],["ac","ad","bc","bd"],["aabb","aabd","aacb","aacd","adbb","adb...
12:11:08 <arkeet> > map length $ iterate sequence ["ab","cd"]
12:11:16 <lambdabot>  Terminated
12:11:22 <arkeet> > map length . take 4 $ iterate sequence ["ab","cd"]
12:11:30 <lambdabot>   mueval-core: Time limit exceeded
12:11:33 <arkeet> > map length . take 3 $ iterate sequence ["ab","cd"]
12:11:34 <lambdabot>   [2,4,16]
12:11:37 <danharaj> oh
12:11:40 <danharaj> good sequence
12:11:53 <arkeet> > iterate (2^) 2
12:11:54 <lambdabot>   [2,4,16,65536,2003529930406846464979072351560255750447825475569751419265016...
12:12:20 <c_wraith> seriously, wtf is up with GHC?  Why is letting me declare overlapping instances without the extension?
12:12:55 <tikhon> I think you only need the extension when you *use* an instance that needs special resolving
12:14:22 <arkeet> indeed
12:15:27 <c_wraith> In a different module, it forces me to use the extension just to declare both instances.
12:15:57 <c_wraith> Oh, and here's even weirder...  If I don't specify OverlappingInstances, they don't both get used.
12:16:49 <c_wraith> (I'm looking at the output of -ddump-simpl-stats, looking for RULES that fire when the correct instances are used...  Only one of the expected two show up without OverlappingInstances, both show up with)
12:43:49 <RThinker> > 1 + 1
12:43:50 <lambdabot>   2
12:56:25 <clahey> I think I'm making progress on how to do O(log n) lazy Naturals.
12:56:41 <clahey> I'm not entirely sure though.
12:57:03 <edwardk> clahey: carrys suck :)
12:57:17 <clahey> edwardk, Oh, I'm not anywhere close to addition.
12:57:50 <clahey> Currently I'm on a way to represent it and a way to test for comparisons to Integers.
12:57:56 <clahey> Or Ints or whatever.
12:58:02 <tikhon> ooh, that sounds vaguely like an interview question I had once
12:58:03 <edwardk> clahey: you can speed things up by using skew binary random access lists, then succ can be almost lazy enough, but you can still never know if you got all the digits =(
12:58:23 <tikhon> should be a fun problem
12:58:31 <clahey> What does the standard representation look like?
12:58:37 <edwardk> you can truncate said lazy nat, but if you take two of them that are untruncated then you have to solve equality of strams
12:58:42 <edwardk> er streams
13:01:23 <dagano> hi : i am used to this symbol (_|_) as being a contradiction from logic.  in semantics, it seems to mean a lot more .. i'm assuming they are connected
13:01:36 <dagano> saying that bottom is a type is blowing my mind
13:01:45 <joelteon> bottom is a value, kinda
13:01:50 <joelteon> it's not a type
13:02:00 <`Jake`> isn't bottom :: a?
13:02:02 <merijn> dagano: bottom is the value that inhabits every type
13:02:06 <tikhon> in Haskell, ⊥ is a value
13:02:13 <dagano> why does every type need a bottom?
13:02:18 <joelteon> it represents non-terminating computations
13:02:26 <merijn> dagano: comparable to bottom letting you proof any proposition in logic
13:02:28 <tikhon> because Haskell is Turing-complete
13:02:38 <latro`a_> dagano--roughly speaking, because any computation, regardless of its type, could fail
13:02:41 <tikhon> we can define a value of type ∀a. a
13:02:50 <tikhon> by writing a program that does not terminate
13:02:50 <merijn> dagano: It doesn't, see Agda et al
13:02:50 <merijn> dagano: But that means you have a total language and thus aren't Turing complete
13:03:04 <tikhon> :t fix id
13:03:05 <lambdabot> a
13:03:18 <tikhon> > fix id
13:03:25 <lambdabot>   mueval-core: Time limit exceeded
13:03:31 <dagano> forall a . a is a tautology no?
13:03:35 <tikhon> yeah
13:03:39 <dagano> HOW DO YOU DO THAT ON YOUR KEYBOARD?
13:03:40 <tikhon> wait
13:03:44 <elliott> no, it's false.
13:03:46 <tikhon> I don't think it's a tautology
13:03:49 <tikhon> it's more like a lie
13:03:51 <elliott> not every statement is true.
13:03:57 <tikhon> also, I use Emacs
13:04:01 <merijn> No, "a -> a" is a tautology
13:04:07 <hvr> tikhon: good for you!
13:04:08 <tikhon> and fix
13:04:09 <tikhon> :t fix
13:04:10 <lambdabot> (a -> a) -> a
13:04:14 <tikhon> (that's how I type ⊥)
13:04:16 <dagano> is . composition or defining the scope for 'forall'
13:04:17 <dagano> ?
13:04:22 <dagano> confusion
13:04:23 <tikhon> in this case, it's just syntax for the forall
13:04:23 <elliott> latter
13:04:26 <merijn> dagano: Defining scope
13:04:28 <elliott> (forall vars. type)
13:04:33 <dagano> gotit
13:04:35 <tikhon> fix tells us that a tautology implies anything
13:05:19 <tikhon> which is a slightly suspicious statement to prove :P
13:05:58 <arkeet> what sort of logic corresponds to having fix?
13:06:04 <merijn> arkeet: An inconsistent one
13:06:12 <arkeet> sure.
13:06:31 <arkeet> but that's a boring answer.
13:06:34 <arkeet> I want a more interesting one.
13:06:35 <arkeet> :c
13:06:40 <dagano> i don't know too much about fix .. but is that akin to the notion that a contractiction allows you to assert any statement?
13:06:46 <merijn> Or paraconsistent, if you want to do anything useful in the presence of contradiction
13:07:13 <merijn> dagano: bottom is akin to the notion that contradiction allows you to assert any statement
13:07:20 <tikhon> dagano: not quite
13:07:20 <tikhon> @src fix
13:07:20 <lambdabot> fix f = let x = f x in x
13:07:26 <tikhon> I think it corresponds to being able to construct an infinite proof
13:07:35 <elliott> no, it's not paraconsistent.
13:07:47 <elliott> assuming (a -> a) holds for all a then it lets you derive anything. that's inconsistent, not paraconsistent
13:07:54 <merijn> elliott: I just said it was inconsistent earlier :<
13:08:01 <elliott> of course you could have (a -> a) not hold for all a. the technical term for the logic is then "weird"
13:08:10 <elliott> merijn: ok, but inconsistent and paraconsistent are inconsistent :P
13:08:25 <dagano> ok thanks, geniuses.  back to reading
13:08:25 <merijn> elliott: I was just clarifying that you want a paraconsistent one if you wanted to useful things in the presence of contradictions like that
13:09:16 <merijn> Since, afaik paraconsistent logics are a strict subset of inconsistent logics?
13:10:09 <elliott> no, paraconsistent logics aren't inconsistent
13:10:20 <elliott> the whole point is to allow contradictions without being inconsistent
13:10:33 <elliott> uh, wait.
13:10:46 <elliott> you should ignore me. I just woke up and am talking nonsense.
13:10:51 <elliott> ask arkeet.
13:11:17 <arkeet> I don't know anything about logic.
13:11:25 <elliott> great, me too.
13:11:30 <merijn> :p
13:11:54 <arkeet> but I thought the point of paraconsistent logic was to allow contradictions without having explosion.
13:12:00 <merijn> Yes
13:12:07 <merijn> But that doesn't make your logic consistent, afaik
13:12:07 <arkeet> but clearly we have explosion.
13:12:08 <elliott> right.
13:13:09 <arkeet> would it be better if we generalized the notion of truth value
13:13:11 <arkeet> or something
13:14:23 <merijn> arkeet: That already exists
13:14:32 <arkeet> are you thinking what I'm thinking
13:14:36 <merijn> Temporal logics generalise truth to something that can value over time
13:14:41 <arkeet> ok, guess not
13:14:55 <merijn> Paraconsistent logics generalise truth over the presence of contradictions
13:15:02 <tikhon> Wait, do they? I thought they just let you quantify propositions over time, but didn't affect how truth worked.
13:15:19 <tikhon> to me, that seems different
13:15:21 <merijn> tikhon: Well, it means the truth value of a statement depends on time
13:15:29 * hackagebot hoogle 4.2.18 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.18 (NeilMitchell)
13:15:54 <merijn> tikhon: "A was true in the past, but is no longer true"
13:15:56 <tikhon> but ultimately, it's still either true or false
13:15:56 <tikhon> it's just that now you can state things about behavior over time
13:15:58 <merijn> i.e. "pluto is a planet"
13:16:09 <tikhon> right
13:16:12 <tikhon> that statement is either true or false
13:16:19 <zomg> I wonder why this Jentrep guy wanted to talk to me in particular about Haskell and JavaScript... I don't recall being any famous in that field :D
13:16:33 <tikhon> zomg: you certainly have a memorable username
13:16:38 <zomg> hehe
13:17:03 <merijn> tikhon: It's either true or false, but which of those varies over time
13:17:42 <merijn> i.e. before the demotion the statement was true, now it is false
13:17:44 <tikhon> my thinking is that ◇x is either true or false, even if it depends on time
13:18:00 <merijn> i.e. the truth value of "pluto is a planet" has varied over time
13:19:12 <tikhon> you could make the statement 'pluto is a planet' without temporal logic
13:19:19 <tikhon> and it's either true or false
13:19:40 <tikhon> with temporal logic, you could make a statement like 'pluto was a planet but is not a planet', or something
13:19:53 <tikhon> but that statement itself—despite being quantified over time—is still either true or false
13:20:14 <tikhon> so while you extend the domain you can reason about to time, you do not really change the notion of "true"
13:21:03 <tikhon> I guess it's really not a big difference
13:21:12 <merijn> I'm going to call this potato, potato (doesn't really work online, does it?)
13:22:45 <jesyspa> I find "potato, tomato" does the job equally well.
13:27:40 <clahey> Is there a built in zipper for List a?
13:27:54 <clahey> I know the type is Zipper a [a] [a]
13:28:48 <clahey> Ah, I'll just make it myself since I want to include an integer representing the position where we are in the list.
13:29:08 <donri> don't know of any "standard" zipper but there's a nice zipper interface in the lens package
13:29:46 <edwardk> clahey: i use Store Int a     as that notion if the list is going to be infinite
13:32:10 <clahey> edwardk, Where is Store?
13:32:12 <clahey> data-store?
13:32:25 <edwardk> control.comonad.store
13:32:37 <edwardk> clahey: https://www.fpcomplete.com/user/edwardk/cellular-automata talks about this approach
13:32:48 <edwardk> C.A. are traditionally done with list zippers
13:32:53 <edwardk> there i do it with a memoized store
13:33:45 <clahey> I think I'll just write a simple list zipper.
13:35:19 <edwardk> probably a good idea =)
13:38:20 <levi> I like to think that, long ago, even edwardk started out writing simple haskell that mere mortals could understand without an introductory course in category theory. ;)
13:38:43 <edwardk> levi: i started writing haskell back in 2006 and didn't know anything about category theory
13:38:58 <edwardk> i still know very little. i just know a few parts of it really well.
13:39:22 <notasi> I can understand category theory but I still have a hard time with haskell...
13:39:48 <tikhon> there's a lot of fun stuff in Haskell besides category theory :)
13:40:27 <notasi> I know, but I'm still trying to learn monads (in the Haskell sense) and I'm stuck. I got IO, List, Maybe, Writer monads down fine but State just makes my head hurt
13:40:40 <levi> I have an introductory text in category theory that I'm slowly reading through, and advanced haskell stuff is slowly starting to make more sense, but I take too long thinking about things and don't get enough coding experience to really make things click.
13:40:44 <edwardk> haskell works so well for me because pretty much all my various backgrounds are useful in it, whereas elsewhere I was always forced to think with only some of the tools at my disposal.
13:41:17 <notasi> I'm so used to doing numerical computations with C that even with a lot of mathematics background I can't wrap my head around some of the more advanced features of haskell
13:41:17 <edwardk> notasi: state is just the monad you get from the adjunction (,) s -| (->) s
13:41:58 <tikhon> I don't really have a background per se, which probably made Haskell easier to pick up :D
13:42:15 <edwardk> if you compose them you get (->) s . (,) s =    s -> (s, a)  -- they flip it around to put the pair on the right hand side.  that you can return and join are consequences of the adjunction.
13:42:51 <levi> The core of haskell is not too bad, but there are a lot of common libraries and idioms just outside the core that increase the complexity a lot.
13:42:52 <edwardk> notasi: i normally wouldn't explain it that way, but since you mentioned a C.T. background, i hoped it might give another avenue to understanding
13:44:02 <notasi> I don't have a huge category theory background, I just have dealt with abstract algebra before (mostly groups) so I am more receptive to it
13:45:54 <levi> It's weird to look at old, pre-monad and pre-constructor class Haskell and compare it to today's libraries.
13:48:59 <lorozic> hey guys, can anyone give some pointers to the proof that normal order reduction always leads to normal form (if there is one ofcourse)?
13:49:03 <heath> https://gist.github.com/heath/6285981
13:49:11 <heath> can anyone make this faster?
13:49:15 <heath> it's so slooowww
13:49:39 <heath> 1.833ms/request
13:50:29 * hackagebot hoogle 4.2.19 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.19 (NeilMitchell)
13:53:34 <donri> heath: doesn't sound that slow for a full-stack setup with routing and logging etc
13:54:09 <heath> donri: hrm, i don't want all that
13:54:25 <joelteon> then listen on a tcp socket and forkIO for each client
13:54:30 <donri> heath: maybe try direct warp with pure wai
13:59:28 <heath> ah
13:59:28 <heath> fixed
14:02:35 <donri> heath: and, i might've mentioned this before, it might improve with the new IO manager in the upcoming GHC release, too
14:02:48 <heath> https://gist.github.com/heath/6086184
14:03:00 <donri> heath: the current IO manager doesn't scale well beyond two or so cores
14:04:17 <carter> is it possible to use TH to splice in several top level declarations at once?
14:04:24 <joelteon> can a module name have accented characters in it?
14:04:39 <joelteon> The language spec says "consists of a letter followed by ..."
14:04:48 <joelteon> > isUpper 'Á'
14:04:49 <lambdabot>   True
14:04:56 <donri> heath: i think you pasted the wrong output there, identical to the yesod one?
14:05:06 <notasi> > isUpper '島'
14:05:07 <lambdabot>   False
14:05:24 <notasi> > isLower '島'
14:05:25 <lambdabot>   False
14:05:41 <`Jake`> If I give a handle to runProcess for stdout, should it be in WriteMode or AppendMode?
14:05:45 <joelteon> Ok, so it looks like it does
14:05:48 <heath> donri: ah!
14:05:50 <heath> thanks
14:05:52 <joelteon> "import Å" in ghci gives me a missing module error, rather than a parse error.
14:05:54 <joelteon> Neat.
14:06:13 <donri> heath: plus you're not benchmarking the same responses there, note that the coffee one is much smaller
14:06:23 <donri> 11 bytes vs 82 bytes
14:07:22 <heath> maybe it should return $ "hello world" ?
14:07:25 <notasi> > putStrLn "文字化け"
14:07:26 <lambdabot>   <IO ()>
14:09:49 <Lethalman> huh lambdabot now spits new messages?
14:09:54 <Lethalman> > getLine
14:09:54 <lambdabot>   <IO [Char]>
14:09:59 <Lethalman> oooooooooooooh
14:10:00 <geekosaur> that's not new
14:10:12 <Lethalman> geekosaur, mh is it some configuration switch perhaps?
14:10:16 <Lethalman> my own copy of lambdabot doesn't do that
14:10:25 <notasi> > "文字化け"
14:10:28 <lambdabot>   "\25991\23383\21270\12369"
14:10:34 <heath> how would do something like https://gist.github.com/heath/5589af08854fdf674ea1
14:10:35 <Lethalman> it says there's no Show instance for IO etc.
14:10:36 <donri> @hackage show is what provides this
14:10:38 <lambdabot> http://hackage.haskell.org/package/show is what provides this
14:10:54 <Lethalman> !!! nice
14:10:59 <geekosaur> dunno, but the lambdabot in the channel has always done that for IO values
14:11:01 <Lethalman> thanks! :)
14:11:15 <Lethalman> have to import ShowFun then, it's safe haskell
14:11:24 <geekosaur> I removed @run from my lambdabot so don't know this stuff too well...
14:11:40 <Lethalman> geekosaur, why did you?
14:11:46 <donri> > succ
14:11:47 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
14:11:47 <lambdabot>    arising from a use ...
14:11:52 <arkeet> but @run is like the only thing it's actually good for.
14:12:03 <arkeet> well, besides everything else.
14:12:15 <heath> > let application _ = show return "hello world"
14:12:15 <lambdabot>   not an expression: `let application _ = show return "hello world"'
14:12:16 <arkeet> ok, @quote is the only thing it's actually good for.
14:12:26 <donri> > id `asAppliedTo` ()
14:12:31 <lambdabot>   <() -> ()>
14:12:41 <geekosaur> because I was using it in channels that didn't particularly care about eval functionality in haskell or any other language
14:13:02 <arkeet> heh
14:13:11 <geekosaur> mostly did logging, @tell, and some custom plugins (notably @ipcalc)
14:14:05 <arkeet> > generalCategory '島'
14:14:06 <lambdabot>   OtherLetter
14:14:18 <arkeet> what's @ipcalc?
14:14:43 <arkeet> > generalCategory '９'
14:14:44 <lambdabot>   DecimalNumber
14:14:50 <arkeet> > ９
14:14:51 <lambdabot>   <hint>:1:1: lexical error at character '\65305'
14:14:52 <arkeet> aw.
14:15:01 <tikhon> if only
14:15:06 <`Jake`> Has lambdabot always displayd functions as <a -> b>?
14:15:24 <merijn> `Jake`: No, it's a recent addition
14:15:28 <`Jake`> thanks
14:15:36 <arkeet> it's not something special to lambdabot, though.
14:15:39 <arkeet> see the show package
14:15:50 <notasi> > map generalCategory "あア亜ａ”"
14:15:51 <elliott> it's not a recent addition
14:15:51 <lambdabot>   [OtherLetter,OtherLetter,OtherLetter,LowercaseLetter,FinalQuote]
14:15:56 <elliott> it used to do it, then it didn't, now it does
14:16:00 <`Jake`> ok
14:16:03 <geekosaur> feed it an ipv4 address and either netmask or /n and it calculated the network range, hex netmask and hostmask (for cisco routers), and some other stuff
14:16:10 <donri> > id `asAppliedTo` id `asAppliedTo` ()
14:16:11 <lambdabot>   Couldn't match expected type `a0 -> a0' with actual type `()'
14:16:25 <arkeet> > (0$0`asAppliedTo`)
14:16:26 <lambdabot>   The operator `L.asAppliedTo' [infixl 0] of a section
14:16:26 <lambdabot>      must have lower p...
14:16:33 <geekosaur> I may still have the plugin code somewhere but no idea if it'll work with recent lambdabot
14:16:46 <Cubic_> Is anyone here familiar with netwire? I've got this wire that's supposed to create movement on an axis "bouncing" off the edges/bounds of that axis, but instead it gets stuck upon hitting a bound http://lpaste.net/92013
14:17:06 <geekosaur> and people here are probably as interested in networky stuff as the people in the channels I was running it in were interested in @run :)
14:17:26 <donri> Cubic_: ocharles maybe, mm_freak doesn't seem to be on
14:18:14 <Cubic_> GameW there is just a wire with inhibition monoid and wire monad set, but I'm not using either of those anyway in that wire
14:20:03 <levi> heath: If you have a lot of cores, -N2 explicitly is probably faster than just -N
14:20:24 <merijn> levi: Why?
14:21:04 <levi> There are issues in the RTS as the number of cores go up unless you have the latest shiny one.
14:21:23 <merijn> You should be fine up to 10-12ish cores
14:21:23 <levi> (I just tested and -N3 was *slightly* slower than -N2 on my machine, YMMV)
14:23:26 <levi> Oh, sorry, I had it backwards; I was switching back and forth and lost track.  -N3 is *slightly* faster than -N2. But that may be due to running ab on the same machine.
14:23:55 <heath> levi: you wouldn't happen to know how to return just a plain "hello world", would ya?
14:24:35 <levi> heath: Not off the top of my head.
14:24:40 <heath> aye
14:28:57 <levi> You can pass the empty list for the response headers.
14:33:16 <_arjun> is this piece of code correct?
14:33:17 <_arjun> cylinder :: (RealFloat a) => a -> a -> a
14:33:22 <_arjun> cylinder r h =
14:33:28 <_arjun> let sideArea = 2 * pi * r * h
14:33:32 <_arjun> topArea = pi * r ^2
14:33:43 <tomejaguar> yeah
14:33:43 <_arjun> in sideArea + 2 * topArea
14:34:39 <_arjun> it is showing this error for ""parse error on input `='" in 2nd last line of code
14:35:19 <Dodek> hey, which library you recommend for working with SQL databases?
14:35:33 <hpc> Dodek: hdbc, by far
14:35:52 <danharaj> postgresql-simple
14:35:53 <hpc> it's the traditional api, though
14:35:56 <danharaj> hdbc is slow
14:36:12 <hpc> ChokoIt is spamming racism in PM
14:36:35 <hpc> @ops
14:36:35 <lambdabot> Maybe you meant: pl oeis docs
14:36:38 <hpc> @where ops
14:36:38 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
14:36:38 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:37:05 --- mode: ChanServ set +o geekosaur
14:37:23 <merijn> hpc: For PM spam you might be better of contacting freenode ircops
14:37:27 <geekosaur> although, chanops can't do anything about pm to speak of
14:37:48 <quchen> … ignore him?
14:38:04 --- mode: ChanServ set +o mauke
14:38:05 --- kick: ChokoIt was kicked by mauke (ChokoIt)
14:38:09 <Dodek> hpc: what do you mean by traditional api?
14:38:20 <tomejaguar> _arjun: do you need to indent topArea = ...?
14:38:37 <ChokoIt> eat shit mauke
14:38:40 --- mode: mauke set +b $a:ChokoIt
14:38:41 --- mode: ChanServ set +o elliott
14:38:43 --- kick: ChokoIt was kicked by mauke (ChokoIt)
14:38:46 <elliott> oh, too late.
14:38:52 --- mode: elliott set -o elliott
14:38:53 <_arjun> tomejaguar: I did that
14:39:25 <_arjun> but now it working after adding ; in 3rd last line
14:40:05 --- mode: geekosaur set -o geekosaur
14:40:13 <tomejaguar> OK
14:40:19 <geekosaur> takes too long to do op-y stuff in this client...
14:40:20 <hpc> Dodek: like what you would find in other languages
14:40:44 --- mode: mauke set -o mauke
14:40:46 <hpc> Dodek: create a connection, then run a query to get a statement, then pull rows out of the statement
14:41:04 <Dodek> hpc: so there's a library with more haskell api, i assume
14:41:12 <edwardk> sclv: hah. kmett.com seems to be back up and pointing to the old comonad.com site. amusing since i didn't do anything
14:41:16 <hpc> Dodek: as opposed to packages that i can't remember the names of, which do query combinators and static table description checks
14:41:20 <hpc> and neat things like that
14:44:38 <Dodek> hpc: ah, i see
14:45:19 <hpc> if you've never done any database programming before, i would go with a traditional api first
14:45:23 <hpc> then later move on to fun stuff
14:56:15 <quchen> Is there a reason there doesn't seem to be an "is full?" operation for TBQueue?
14:56:31 <flebron> Could I get a critique on style? http://ideone.com/mSLEUQ . In particular, for a format as simple as the one in my datafile (N, and N lines, then M, and M lines), should I use Parsec? Is there a better way to handle errors in IO? Where would be a good way to define ballRadius and ballThickness, right up there with the Ball datatype?
14:56:33 <merijn> quchen: Hence my proposal from last week
14:56:49 <quchen> merijn: Oh, I didn't see that. On the mailing list or just in IRC?
14:56:58 <merijn> quchen: Which, btw has finished it's discussion time without objection, so I should create a ticket + patch this week
14:57:41 <quchen> Oh, found it. Neat.
14:58:03 <quchen> In the meantime: any tips on how to debug a thread that you kind of suspect that it fills a queue but you're not sure?
14:58:09 <merijn> quchen: http://www.haskell.org/pipermail/libraries/2013-August/020284.html
14:59:21 <hpaste_> merijn pasted “isFullTBQueue” at http://lpaste.net/92016
14:59:28 <merijn> quchen: See that hacky implementation
14:59:35 <merijn> quchen: It's rather inefficient, but works
15:00:29 <quchen> Nice idea though. Hacky, but nice.
15:00:48 <quchen> I forgot about unGetQueue. Now it's obvious. :-)
15:01:00 <quchen> Thanks for the help
15:01:57 <merijn> quchen: Remind me again later this week to submit the patch
15:02:19 <quchen> Noted.
15:04:28 <johnw> edwardk: nice, updating my mirror :)
15:10:40 <edwardk> johnw: hah, good. then push it to github! =)
15:11:16 <edwardk> johnw: i may try rerouting the dns for comonad.com back to the proper host now that it is up
15:13:22 <johnw> I did it with /etc/hosts for now
15:13:32 <johnw> don't reroute for a couple hours, though
15:13:36 <johnw> so I can finish mirroring
15:26:43 <Hrumph> hi i'm looking for a function of type f :: [Maybe a] -> Maybe [a], such that if xs has one or more Nothing elements f xs is Nothing, otherwise f xs is Just [xs but no longer with Just...]
15:26:55 <joelteon> :t sequence
15:26:56 <lambdabot> Monad m => [m a] -> m [a]
15:27:24 <Hrumph> ok that sounds like the one
15:27:28 <Hrumph> i'll try that
15:27:47 <flebron> :src sequence
15:27:59 <flebron> @src sequence
15:27:59 <lambdabot> sequence []     = return []
15:27:59 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:27:59 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
15:29:16 <Hrumph> right sequence is the one. its working
15:37:39 <isomorphismes> I'm trying to experiment with >> which I think means like function composition. I was going to start out with sqrt and square and sum as examples. How would you use >> or >>= to write sqrt( sum( squares( 3, 4) ) )   ?
15:38:14 <jmcarthur_mobile> I think you are confused.
15:38:40 <isomorphismes> jmcarthur_mobile: likely.
15:38:53 <Peaker> isomorphismes: >> composes "monadic actions", not functions. If you're just starting out, first learn about functions and composing them and later about monadic actions
15:39:01 <isomorphismes> Peaker: ok
15:39:11 <jmcarthur_mobile> :t (.)
15:39:11 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:39:12 <notasi> (.) is the function composition operator
15:39:18 <Peaker> isomorphismes: what is the "squares" function?
15:39:36 <isomorphismes> Peaker: let square x = x*x
15:39:42 <notasi> if you have f :: a -> b and g :: b -> c then (g . f) x = f (g x)
15:39:48 <Peaker> isomorphismes: and squares (3,4) ?
15:40:04 <Peaker> isomorphismes: do you mean: map square [3,4] ?
15:40:21 <Peaker> isomorphismes: btw, (^2) is another name for "square"
15:40:34 <notasi> > (sqrt . sum . map (join (*))) [3,4]
15:40:35 <lambdabot>   5.0
15:41:22 <isomorphismes> notasi: ah, that's what I meant. When I run sqrt . sum . square $ 4 it throws an error. Why is map ( join (*)) necessary?
15:41:30 <Peaker> notasi: that's too much to teach at one go
15:41:37 <notasi> map (join (*)) is the same as map (^2)
15:41:43 <notasi> map applies a function to every element in a list
15:41:45 <isomorphismes> notasi: ok
15:41:47 <notasi> > map (^2) [3,4]
15:41:48 <lambdabot>   [9,16]
15:42:24 <isomorphismes> > let square x = x*x in ( sqrt . sum . square $ [3,4] )
15:42:25 <lambdabot>   No instance for (GHC.Show.Show a0)
15:42:26 <lambdabot>    arising from a use of `M1900174771.sh...
15:42:52 <notasi> > let square x = x*x in (sqrt . sum . map square) [3,4]
15:42:53 <lambdabot>   5.0
15:43:29 <isomorphismes> Peaker: yes, why is map square [3,4] necessary rather than square [3,4] ? Because without the "map" it doesn't know to "apply" so it's thinking "I can't square a list"?
15:43:38 <FardadJalili> I have a problem installing SourceGraph, it this the right place to ask for a solution?
15:43:41 <FardadJalili> the error is this:
15:43:43 <notasi> :t \x -> x*x
15:43:43 <lambdabot> Num a => a -> a
15:43:49 <FardadJalili> Data/GraphViz/Algorithms.hs:1:14:
15:43:50 <notasi> :t [3,4]
15:43:51 <FardadJalili>     Unsupported extension: MonadComprehensions
15:43:51 <lambdabot> Num t => [t]
15:43:52 <FardadJalili> cabal: Error: some packages failed to install:
15:43:54 <FardadJalili> Graphalyze-0.14.0.1 depends on graphviz-2999.16.0.0 which failed to install.
15:43:56 <FardadJalili> SourceGraph-0.7.0.5 depends on graphviz-2999.16.0.0 which failed to install.
15:43:57 <FardadJalili> graphviz-2999.16.0.0 failed during the building phase. The exception was:
15:43:59 <FardadJalili> ExitFailure 1
15:44:05 <isomorphismes> ohhhhh. sqrt accepts a scalar; sum returns a scalar. …ya
15:45:32 <isomorphismes> > ( sqrt . sum . map (\x -> x*x) ) [3,4]
15:45:33 <lambdabot>   5.0
15:45:43 <FardadJalili> @pl f g h x = (g h) (g g h) x
15:45:43 <lambdabot> f = ap ap (join id)
15:46:00 <isomorphismes> thanks Peaker notasi  jmcarthur_mobile
15:46:43 <FardadJalili> I have a problem installing SourceGraph, it this the right place to ask for a solution?
15:46:44 <SS_JJ> > let (=>>=) f m = m >>= return . f in Just 5 =>>= (+1)
15:47:00 <lambdabot>   Couldn't match expected type `a1 -> b0'
15:47:00 <lambdabot>              with actual type `Data...
15:47:27 <FardadJalili> at least give a yes or no :D
15:47:41 <SS_JJ> > let (=>>=) f m = m >>= return . f in (=>>=) Just 5  (+1)
15:47:42 <lambdabot>   Could not deduce (GHC.Num.Num
15:47:42 <lambdabot>                      ((GHC.Integer.Type.Integ...
15:47:47 <SS_JJ> > let (=>>=) f m = m >>= return . f in (=>>=) (Just 5)  (+1)
15:47:49 <lambdabot>   Couldn't match expected type `a1 -> b0'
15:47:49 <lambdabot>              with actual type `Data...
15:48:06 <FardadJalili> @pl f g h x = (g x h) (g x g) h
15:48:06 <lambdabot> f = join . (flip .) . ap (flip . (ap .) . flip) (join flip)
15:48:10 <Peaker> isomorphismes: a compiler could in theory automatically apply a given function to all members of a list ("auto-lifting" the function), but that would be problematic because then it's ambiguous: Apply the function on the list itself, or the elements which are also lists?
15:48:14 <SS_JJ> > Just 5 >>= return . (+1)
15:48:15 <lambdabot>   Just 6
15:48:37 <Peaker> isomorphismes: so Haskell doesn't do auto-lifting, but lifting a function to work on all of the list elements is easy, just use "map"
15:49:01 <notasi> languages such as APL and J can automatically apply a function to a list or matrix, but they introduce something known as rank to do it. And that is getting off topic
15:49:09 <joelteon> :t lift
15:49:10 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
15:49:21 <joelteon> :t lift (+1)
15:49:22 <lambdabot> (Num a, MonadTrans t) => t ((->) a) a
15:49:23 <Peaker> notasi: to resolve the ambiguity?
15:49:27 <notasi> yes
15:49:34 <joelteon> > lift (+1) [1..10]
15:49:35 <lambdabot>   Couldn't match kind `* -> *' with `*'
15:49:35 <lambdabot>  Expected type: [t0] -> a0
15:49:35 <lambdabot>    Actual ...
15:49:44 <`Jake`> > liftM (+1) [1..10]
15:49:45 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
15:49:54 <SS_JJ> why doesnt thismwork: let (=>>=) f m = m >>= return . f in (=>>=) (Just 5)  (+1)
15:50:02 <SS_JJ> :t lift
15:50:03 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
15:50:12 <FardadJalili> notasi: is this the right place to ask, considering I have problems installing SourceGraph with cabal? :)
15:50:16 <joelteon> SS_JJ: isn't that just fmap?
15:50:18 <FardadJalili> notasi: sorry to ask directly
15:50:32 <notasi> I have no idea, I've never asked about cabal problems here
15:50:46 <SS_JJ> @src fmap
15:50:46 <lambdabot> Source not found. I feel much better now.
15:51:07 <`Jake`> having a generic source for fmap sounds rather odd
15:51:12 <joelteon> fmap f m === m >>= return . f
15:51:18 <`Jake`> but that's with monads
15:51:39 <FardadJalili> notasi: Do you have any suggestions? graphviz failing to install should at least be somewhere on the issues..
15:51:52 <FardadJalili> Data/GraphViz/Algorithms.hs:1:14:
15:51:54 <FardadJalili>     Unsupported extension: MonadComprehensions
15:52:04 <notasi> I'm not a cabal developer or package maintainer, and I've never tried to install that package, so I have no idea
15:52:24 <S_J> but why cantg i define =>>= ?
15:52:53 <S_J> > let (=>>=) f m = m >>= return . f in (=>>=) (Just 5)  (+1)
15:52:53 <Peaker> FardadJalili: it sounds like it needs a newer GHC than you have, and it doesn't specify that in its .cabal spec
15:52:54 <lambdabot>   Couldn't match expected type `a1 -> b0'
15:52:54 <lambdabot>              with actual type `Data...
15:53:10 <S_J> > let (=>>=) m f = m >>= return . f in (=>>=) (Just 5)  (+1)
15:53:12 <lambdabot>   Just 6
15:53:13 <S_J> im an idio
15:53:14 <S_J> t
15:53:29 <Peaker> S_J: (=>>=) = flip liftM
15:53:42 <notasi> > (flip . fmap) (Just 5) (+1)
15:53:43 <lambdabot>   Couldn't match expected type `a0 -> b0'
15:53:43 <lambdabot>              with actual type `Data...
15:53:49 <notasi> > (flip fmap) (Just 5) (+1)
15:53:50 <lambdabot>   Just 6
15:53:54 <Peaker> and if you're willing to use a Functor constraint rather than Monad, then it is also the (<&>) operator from Control.Lens
15:54:00 <FardadJalili> Peaker: fedora rpms should be actually old then. Let me check
15:54:43 <FardadJalili> yep they're old it seems 7.0.4
15:55:29 <isomorphismes> Peaker: hmm, is this what J does? (if "the magic of J" is to interpret based on the header and a few indications which kind of "multiplication" or "addition" and so on to perform). eg avg=: +/ % #
15:55:40 <isomorphismes> notasi: oh you just said that
15:55:51 <joelteon> > (+1) [1..10]
15:55:52 <lambdabot>   No instance for (GHC.Show.Show t0)
15:55:52 <lambdabot>    arising from a use of `M922445094.sho...
15:55:55 <S_J> > let peaker2 (x:xs) y = if x > y then peaker2 xs x else peaker2 xs y; peaker xs = peaker2 xs x in peaker [1..10]
15:55:56 <lambdabot>   *Exception: <interactive>:3:5-67: Non-exhaustive patterns in function peaker2
15:55:56 <joelteon> hmm.
15:56:14 <`Jake`> :t (+1) [1..10]
15:56:15 <lambdabot> (Enum t, Num [t], Num t) => [t]
15:56:18 <S_J> > let peaker2 (x:xs) y = if x > y then peaker2 xs x else peaker2 xs y; peaker2 [] y = y; peaker xs = peaker2 xs x in peaker [1..10]
15:56:19 <lambdabot>   x
15:57:00 <S_J> > let peaker2 (x:xs) y = if x > y then peaker2 xs x else peaker2 xs y; peaker2 [] y = y; peaker (x:xs) = peaker2 xs x in peaker [1..10]
15:57:01 <lambdabot>   10
15:57:11 <S_J> > let peaker2 (x:xs) y = if x > y then peaker2 xs x else peaker2 xs y; peaker2 [] y = y; peaker (x:xs) = peaker2 xs x in peaker [20,2,22,1,0]
15:57:12 <lambdabot>   22
15:57:20 <`Jake`> > (+1) []
15:57:21 <lambdabot>   No instance for (GHC.Show.Show a0)
15:57:21 <lambdabot>    arising from a use of `M1839848842.sh...
15:57:48 <isomorphismes> SS_JJ: Was the Just 5 >>= example directed at me? Because that makes sense, thanks.
15:57:57 <Peaker> S_J: extract "peaker2 xs" from the "if" if both then and else are identical for that part
16:06:24 * Ghoul_ wipes sweat off forehead
16:06:42 <Ghoul_> its a chore to port all these programs that run shell commands to windows :C
16:08:17 <S_J> > let peaker2 (x:xs) y = peaker2 xs (if x > y then  x else y); peaker2 [] y = y; peaker (x:xs) = peaker2 xs x; peaker [] = error "" in (peaker [20,2,22,1,0], peaker [])
16:08:27 <S_J> goodnightie
16:08:28 <Hafydd> Are they Haskell programs?
16:08:37 <Peaker> S_J: if x > y then x else y  is named "max"
16:09:27 <lambdabot>   (22,*Exception:
16:18:28 <d-snp_> hi, I'm struggling with some imperative think
16:19:35 <d-snp_> I'm in a do block, and I read some data, depending on that data I can do either or all of three things
16:20:31 <d-snp_> and the things I want to do, they are passed to a next function that is going to execute them
16:20:32 * hackagebot compilation 0.0.0.3 - Haskell functionality for quickly assembling simple compilers.  http://hackage.haskell.org/package/compilation-0.0.0.3 (AndreiLapets)
16:20:34 * hackagebot staticanalysis 0.0.0.3 - Reusable static analysis interfaces and modules.  http://hackage.haskell.org/package/staticanalysis-0.0.0.3 (AndreiLapets)
16:21:09 <d-snp_> so in imperative world, I would have 3 if statements, and in each statement, I would add a thing to a variable
16:21:44 <d-snp_> and at the end, I would pass the variable to the next function
16:22:07 <d-snp_> but in haskell, you can't have a variable in a do notation block right?
16:22:48 <zRecursive> d-snp_: do {v1<-act1; v2<-act2;  ...}
16:23:40 <zRecursive> @undo do {v1<-act1; v2<-act2}
16:23:41 <lambdabot> <unknown>.hs: 1: 24:Parse error: Last statement in a do-block must be an expression
16:24:05 <zRecursive> @undo do {v1<-act1; v2<-act2; v1+v2}
16:24:05 <lambdabot> act1 >>= \ v1 -> act2 >>= \ v2 -> v1 + v2
16:24:49 <Peaker> zRecursive: v1+v2 is an instance of Num. Instances of Num tend not to be instances of Monad, so it's likely you didn't mean that
16:25:04 <`Jake`> @undo do {v1<-act1; v2<-act2; return $ v1+v2}
16:25:04 <lambdabot> act1 >>= \ v1 -> act2 >>= \ v2 -> return $ v1 + v2
16:25:27 <zRecursive> sure
16:25:33 * hackagebot imparse 0.0.0.3 - Multi-platform parser analyzer and generator.  http://hackage.haskell.org/package/imparse-0.0.0.3 (AndreiLapets)
16:25:39 <d-snp_> http://lpaste.net/92018 made a pseudo code example here
16:25:58 <edwardk> d-snp_: you can write a little combinator like modifyIf True f = f; modifyIf False = return;    then you can write foo x = do y <- modifyIf (condition1) (howToModifyIt) x; z <- modifyIf (condition2) (howToModifyIt); return z;     we can simplify the latter by using >=>   to foo = modifyIf condition1 howToModifyIt >=> modifyIf condition2 howToModifyIt  -- that presumes your modifications have monadic effects. if not it gets
16:25:58 <edwardk>  easier.
16:26:17 <d-snp_> lol :D
16:27:39 <hpaste_> Peaker annotated “Variables” with “Variables (annotation)” at http://lpaste.net/92018#a92019
16:27:56 <Peaker> d-snp_: ^^
16:28:09 <d-snp_> wow Peaker
16:28:11 <`Jake`> The if like you want to use it seems to be much like when to me
16:28:16 <d-snp_> that looks very elegant
16:28:41 <Peaker> d-snp_: using list comprehensions with only a guard is a neat trick, useful
16:28:41 <d-snp_> thanks!
16:28:45 <edwardk> d_snp: do xs <- readSomeData; doThings $ concat [aspectAProcessor <$ guard (hasAspectA xs), aspectBProcessor <$ guard (hasAspectB xs), xs]
16:29:04 <edwardk> or peaker's trick
16:29:16 <edwardk> and you shouldn't include the 'xs' on the tail of mine
16:29:26 <arkeet> > [1 | True]
16:29:44 <arkeet> it's lambdabotastic.
16:29:51 <lambdabot>   [1]
16:29:58 <arkeet> > [2 | False]
16:29:59 <lambdabot>   []
16:30:17 <`Jake`> [2 | _ <- [] ]
16:30:23 <`Jake`> > [2 | _ <- [] ]
16:30:24 <lambdabot>   []
16:33:49 <arkeet> > [ 2 | False <- True ]
16:33:50 <lambdabot>   Couldn't match expected type `[GHC.Types.Bool]'
16:33:50 <lambdabot>              with actual ty...
16:33:55 <arkeet> oh right.
16:33:59 <arkeet> > [ 2 | False <- pure True ]
16:34:00 <lambdabot>   []
16:34:37 <`Jake`> @undo do {False <- pure True; return 2} :: [Int]
16:34:37 <lambdabot> pure True >>= \ a -> case a of { False -> return 2; _ -> fail ""} :: [Int]
16:35:24 <arkeet> fail =(
16:37:46 <d-snp_> ah turns out I can't use your trick Peaker, I have to give back an MVar in the guard
16:37:52 <d-snp_> I think..
16:39:45 <Peaker> d-snp_: use sequence?
16:40:09 <Peaker> d-snp_: not sure what the problem is exactly, do you have more concrete code?
16:40:33 * hackagebot exceptions 0.3.2 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.3.2 (EdwardKmett)
16:41:41 <`Jake`> I didn't even know you could pattern match against values in do notation with <-. Have I just not read carefully or is that really not in the standard books?
16:41:57 <arkeet> you always could.
16:42:41 <arkeet> the thing to the left of <- is really an argument to a lambda.
16:42:45 <arkeet> and you can pattern match in lambdas too.
16:43:12 <arkeet> (well, slight difference in that pattern match fails in do notation produce fail, instead of exploding)
16:43:12 <`Jake`> but @undo does it with case, which is completely different from using it with a variable
16:43:15 <edwardk> `Jake`: the trick is if that match fails it'll call 'fail', so be careful.
16:43:43 <arkeet> `Jake`: case can be used with variables too.
16:43:46 <arkeet> > case 5 of x -> x
16:43:47 <lambdabot>   5
16:43:52 <arkeet> :p
16:44:00 <arkeet> (variables being trivial patterns)
16:44:04 <`Jake`> but that's now how you usually undo do notation
16:44:40 <arkeet> do { p <- x; foo } is the same as x >>= \p -> foo (aside from fail)
16:44:54 <arkeet> @undo do { p <- x; foo }
16:44:54 <lambdabot> x >>= \ p -> foo
16:44:58 <arkeet> @undo do { P <- x; foo }
16:44:58 <lambdabot> x >>= \ a -> case a of { P -> foo; _ -> fail ""}
16:45:05 <`Jake`> Yeah, I guess that makes sense
16:45:39 <arkeet> I don't like fail. =(
16:46:11 <`Jake`> I've never needed it in practice, I think
16:46:24 <arkeet> well, I don't think anyone should ever *write* fail
16:47:26 <d-snp_> http://lpaste.net/92020 I made it like this now
16:47:31 <arkeet> it would be nice if it did mzero if there was a MonadPlus instance, and pattern match error otherwise.
16:47:34 <d-snp_> not as elegant, haven't tried to compile it yet
16:47:35 <arkeet> but that sounds awkward.
16:47:47 <arkeet> because then behaviour depends on whether there's a MonadPlus instance in scope.
16:48:00 <`Jake`> Well, that
16:48:02 <`Jake`> oops
16:48:16 <`Jake`> 's similar to how it's now, where you redefine it if your types allow it
16:49:37 <arkeet> `Jake`: no, not really.
16:49:40 <arkeet> fail is part of the Monad instance.
16:49:43 <arkeet> it's always there.
16:50:00 <arkeet> and it doesn't really belong there. =(
16:51:20 <`Jake`> That's just what happens when you try to adapt theoretical mathematical concepts to practical computational tasks, I suppose
16:52:17 <arkeet> the worst thing is that fail takes an argument.
16:52:20 <Peaker> `Jake`: or rather, when you try to make things "beginner friendly" at the expense of too many other things
16:53:57 <ParahSail1n> fail is needed for do syntax as it is implemented
16:54:50 <Peaker> but there was a better implementation before Haskell 98
16:54:59 <ParahSail1n> @src catMaybes
16:54:59 <lambdabot> catMaybes ls = [x | Just x <- ls]
16:55:02 <Peaker> then, misguided beginner friendliness kicked in
16:55:46 <geekosaur> I am not clear on that; what's beginner friendly about handling pattern match in do differently from pattern match outside of it?
16:56:45 <ParahSail1n> without fail, that would be [case x of {Nothing -> []; Just j -> [j]} | x <- ls]
16:57:04 <ParahSail1n> people wanted it to be the short cut way above
16:57:42 <d-snp_> Peaker: do you have some magic for http://lpaste.net/92020 ? I guess it's readable but it's not very elegant, then again I guess the whole thing is intrinsically not very elegant
16:57:51 <`Jake`> but that only works if you're just working with lists
16:57:52 <Peaker> ParahSail1n: the better "do" allowed this, it just added an extra constraint
16:58:05 <`Jake`> @undo do {Just x <- ls; return x}
16:58:05 <lambdabot> ls >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
16:58:14 <Peaker> determineProcessors :: QueueState -> Int -> [] ?
16:58:50 <Peaker> d-snp_: redundant brackets there: (qsBufferSize qs)   <-- try hlint first?
16:59:22 <Peaker> d-snp_: also, the syntax errors make it hard to read :)
17:00:14 <d-snp_> haha ok I'll try to get it working first
17:00:40 <Peaker> d-snp_: also, extract stuff that's identical in both then/else out of the if
17:02:19 <`Jake`> Would it be better to allow pattern matching for <- only for Monads which are also instances of MonadPlus?
17:03:14 <arkeet> what do you mean by allow?
17:04:05 <arkeet> MonadPlus is kind of too much anyway.
17:04:06 <`Jake`> Let the compiler throw a type error if you use it with do notation and not an instance of MonadPlus
17:04:21 <arkeet> that sounds even worse.
17:04:47 <Peaker> `Jake`: only for instances of MonadZero (or at least, this is how it was before it was ruined, iiuc)
17:05:33 <arkeet> ruined when/how?
17:05:40 <acowley> Has anyone done any work on a library of commonly used machines (re the machines package)?
17:05:52 <`Jake`> I see there's a proposal for that type on the haskellwiki.
17:05:56 <Peaker> arkeet: ruined by Haskell98, which decided for "newbie friendliness" that it should remove MonadZero, and put its zero as "fail" inside Monad
17:06:01 <acowley> I feel like I'm blazing a trail parallel to one somebody else must have already blazed :/
17:06:19 <arkeet> =(
17:06:42 <`Jake`> s/type/class
17:11:48 <jfischoff> can one make Data.Data instance for GADTs?
17:11:59 <jfischoff> are they usable?
17:20:23 <flebron> Could I get a critique on style? http://ideone.com/mSLEUQ . In particular, for a format as simple as the one in my datafile (N, and N lines, then M, and M lines), should I use Parsec? Is there a better way to handle errors in IO? Where would be a good way to define ballRadius and ballThickness, right up there with the Ball datatype?
17:42:27 <nh2> where is http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-ForeignPtr.html ?
17:42:58 <nh2> hoogle points to it but it 404s
17:44:55 <`Jake`> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-Ptr.html
17:45:00 <`Jake`> nh2:
17:45:23 <`Jake`> or wait
17:45:29 <`Jake`> that's somethign else, isn't it
17:45:31 <nh2> `Jake`: I don't mean Foreign.Ptr
17:45:31 <nh2> yes
17:46:50 <Ralith> nh2: http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Foreign-ForeignPtr-Safe.html
17:47:00 <lemao> Sorry if a bit off topic, but does anyone know what stratification means in the context of datalog?
17:47:09 <Ralith> or more generally, http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Foreign.html
17:47:17 <nh2> Ralith: that looks right, but why does hoogle put me to a 404 link?
17:47:33 <Ralith> nh2: idk
17:47:44 <`Jake`> what about this? http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/Foreign-ForeignPtr.html
17:47:48 <`Jake`> oh
17:47:49 <`Jake`> wrong version
17:47:56 <`Jake`> that's probably why
17:48:22 <nh2> hmm
17:48:40 <`Jake`> hoogle points to latest
17:49:19 <tac> Is there a handy applicative or monad function that lets you discard the result?
17:49:38 <tac> that is, a function defined as f x = x >> return ()
17:49:50 <`Jake`> void?
17:49:50 <tac> @type void
17:49:51 <lambdabot> Functor f => f a -> f ()
17:49:57 <tac> ah neat
18:02:13 <FreeFull> :t fmap . const ()
18:02:13 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `()'
18:02:14 <lambdabot>     In the first argument of `const', namely `()'
18:02:14 <lambdabot>     In the second argument of `(.)', namely `const ()'
18:02:18 <FreeFull> :t fmap $ const ()
18:02:18 <lambdabot> Functor f => f a -> f ()
18:09:22 <`Jake`> @src void
18:09:22 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
18:11:16 <nh2> `Jake`: but if it points to latest, why does it 404 then? Because the hoogle index is too old?
18:12:09 <`Jake`> nh2: The hoogle link assumes that the module organization hasn't changed, but it has; the link on hoogle hasn't been updated, yeah
18:13:29 <`Jake`> And if it would point to an actual version number, it would still work, but there are obviously other disadvantages with that
18:21:37 <`Jake`> The same 404 is also linked on hackage: http://hackage.haskell.org/packages/archive/haskell98/latest/doc/html/ForeignPtr.html#ForeignPtr
18:21:54 <`Jake`> (almost the same)
18:25:42 <mm_freak> ocharles: hi there…  nice work =)
18:28:45 <mm_freak> ocharles: you may be interested in this project: http://hub.darcs.net/ertes/netwire
18:28:49 <mm_freak> netwire 5 =)
18:29:21 <mm_freak> i'm currently working very extensively on it…  planning to release it next week
18:33:34 <haasn> wooh, darcshub user :D
18:34:04 <edwardk> they still exist
18:34:16 <edwardk> they are fewer and further between these days though
18:34:50 <sclv> enough that we're spending a darcs soc slot on it
18:35:32 <edwardk> well, the darcs guys get their own slots now, so they are free to spend them as they will
18:35:45 <haasn> soc slot?
18:35:48 <haasn> oh, summer of code
18:36:27 <edwardk> yeah
18:36:56 <latermuse> mm_freak, you are the maintainer of netwire?
19:13:52 <mm_freak> latermuse: yes
19:17:54 <mm_freak> haasn: i could never get used to git
19:20:49 <mm_freak> in fact i'd probably contribute to more projects, if they weren't git-controlled…  every time i have to work with git i get mad, almost like haskell vs. PHP
19:22:53 <jmcarthur> i honestly feel that way almost every time i switch version control systems
19:23:09 <jmcarthur> the only time i don't is when i'm switching back to darcs after a long way away from it
19:23:14 <jmcarthur> *long time away
19:24:06 <jmcarthur> it helps that i normally use darcs for smaller toy projects though. it always ends in disaster when i play with converting a large repo to darcs :(
19:24:07 <BMeph> jmcarthur: "If only they knew the POWER...of the darcs-IDE!" ;)
19:24:47 <edwardk> BMeph: *groan*
19:25:16 <jmcarthur> wow that was awfulmazing
19:25:20 * BMeph takes a cyber-bow!
19:25:34 <jmcarthur> @remember BMeph If only they knew the POWER...of the darcs-IDE!
19:25:34 <lambdabot> It is stored.
19:25:43 <BMeph> Thank you very much, I'll be here all week - good night! :)
19:25:51 <monochrom> oh haha, now I get it
19:26:02 <jmcarthur> it took me a second too
19:26:09 <jmcarthur> or two or ten
19:26:30 <monochrom> probably more than a minute for me
19:27:08 <BMeph> Granted, if the rumored IDE were anywhere close to testing, nevertheless completion, it might connect faster, but you work with what you're given.... :)
19:27:18 <monochrom> "hmm 'power', is that He-Man's 'by the power of grayskull'? is that Power Rangers? ..."
19:27:45 <monochrom> "is that Kick-Ass?"
19:28:18 <BMeph> monochrom: Buckaroo Banzai! ;p
19:32:13 <khyperia> Hi, I'm having trouble building buildwrapper with cabal, is this the right place to ask for help? If not, where might a good place be?
19:33:31 <monochrom> it's a good place. but I can't answer.
19:34:02 <pentace> I'd say it depends on the problem
19:34:18 <khyperia> Alright, I'll paste the log, see where that gets me.
19:35:33 <hpaste_> khyperia pasted “buildwrapper” at http://lpaste.net/92023
19:35:43 <khyperia> Huh. That's a neat feature.
19:37:52 <pentace> Looks like a package dependencies problem
19:38:04 <edwardk> :t \f l r -> folding $ liftM2 (liftM2 f) (toListOf l) (toListOf r)  -- would work
19:38:04 <lambdabot> (Applicative g, Contravariant g) => (a -> a1 -> r) -> Getting (Endo [a]) s a -> Getting (Endo [a1]) s a1 -> LensLike g s t r b
19:38:07 <edwardk> er wrong chanel
19:38:08 <edwardk> er channel
19:38:31 <alastor__> damn I have no idea who made the Haskell book at wikipedia's wikibooks but I'm pretty sure there's at least some of you here and I'd like to thank you for the work you put into that.
19:41:38 <pentace> khyperia: your Cabal version seems to be either to old or too new for what version is needed by buildwrapper
19:42:51 <khyperia> does cabal come with the default haskell platform, or somewhere else? (I'm a complete beginner at haskell, apologies for dumb questions)
19:43:17 <pentace> I guess it's part of the platform
19:43:34 <pentace> What does "ghc-pkg list Cabal" tell you?
19:44:00 <khyperia> Cabal-1.16.0
19:44:48 <pentace> that's a recent version
19:44:58 <carter> tikhon: blahhh more of the silly lang folks
19:45:33 <khyperia> is it possible to downgrade and try installing buildwrapper, or is that not a good idea?
19:47:03 <pentace> Usually, installing several versions of the same package is not a good idea, though it may be safe in some cases
19:52:00 <khyperia> Any immediate advice? I didn't notice how late it is, so if there's nothing obvious, I'll just come back tomorrow.
20:00:53 <Twey> Is there an unbounded natural type in the standard library?  Or even better, a positive natural type?
20:02:39 <leroux> Twey: Integer is unbounded...atleast I believe it is.
20:02:53 <leroux> You could create a data type that does not allow negatives..
20:06:32 * haasn .oO( [()] )
20:07:02 <pentace> Twey: I think there's nothing in the standard libraries but we have several extra packages for natural numbers
20:10:07 <chexxor_netbook> I want to write a function like this -- skips "ABCD" == ["ABCD", "BD", "C", "D"]
20:10:35 <chexxor_netbook> If the input is n elements long, the output should have 5 lists
20:10:40 <chexxor_netbook> how would I do that?
20:11:12 <chexxor_netbook> maybe I'm thinking about this wrong...
20:11:36 <geekosaur> I think you described yourself wrong, if nothing else (did you mean n lists?)
20:12:11 <chexxor_netbook> yeah
20:12:51 <chexxor_netbook> on the second element, it should skip every two chars, the third element should skip every three chars... something like that
20:13:39 <chexxor_netbook> it feels like I should use recursion, but this lesson is about how to use library functions instead of recursion, like map, fold, etc
20:16:58 <mm_freak> sm_: apparently markdown code rendering on darcshub is broken
20:17:07 <mm_freak> ">" renders as "&gt;"
20:17:23 <mm_freak> see http://hub.darcs.net/ertes/netwire
20:23:43 <begriffs> Hey question about strings. I'm trying to use Aeson to decode some JSON, but the decode method can't handle [Char]. It wants Data.ByteString.Lazy.Internal.ByteString. Is there a way to get Haskell to quietly convert my strings?
20:24:37 <ReinH> begriffs: Haskell does not do implicit coersion.
20:25:11 <Twey> chexxor_netbook: I did it with zip, zipWith, replicate, and a list comprehension
20:25:32 <Twey> begriffs: No; use the ‘pack’ function from Data.ByteString.Lazy
20:25:35 <begriffs> ReinH  The docs of Aeson make it look like they can just use [Char] somehow: decode "[1,2,3]" :: Maybe [Int]
20:25:47 <ReinH> begriffs: oh, if you're talking about literals
20:25:53 * hackagebot swish 0.9.0.4 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.4 (DouglasBurke)
20:26:02 <ReinH> you can use the overloaded strings pragma
20:26:20 <ReinH> {-# LANGUAGE OverloadedStrings #-}
20:27:05 <begriffs> How does it know which string type to convert [Char] into? Seems like there are a lot of Haskell string types.
20:28:02 <ReinH> begriffs: because it infers the type
20:28:23 <latermuse> gives a type error when you mix types
20:28:55 <hpaste_> dmj pasted “FileLineAverager-er” at http://lpaste.net/92026
20:29:36 <dmj`> is there a "isDirectory" function? couldn't find it in System.Directory
20:29:57 <latermuse> doesDirectoryExist
20:31:02 <dmj`> latermuse: Ah! Thank you!
20:31:04 <latermuse> dmj`: True <- doesDirectoryExist
20:31:14 <latermuse> if it doesnt exist, you will get a runtime error
20:31:21 <latermuse> no problem
20:32:18 <begriffs> ReinH: interestingly if I import import Data.ByteString.Char8 and use OverloadedStrings it doesn't work but it does work if I import Data.ByteString.Lazy.Char8. Why can't it infer the type just by examining :t decode
20:35:11 <ReinH> begriffs: I don't know :)
20:40:11 <Twey> begriffs: It does
20:40:34 <Twey> I assume decode takes a lazy bytestring
20:40:46 <Twey> Er, a strict one, even
20:41:06 <Twey> Nope, lazy.  *blinks at text*
20:41:42 <Twey> There are IsString instances for both lazy and strict bytestrings, so OverloadedStrings can use either.
20:42:57 <begriffs> @Twey when I import only Data.Aeson Data.ByteString.Char8 then decode can't figure out how to convert the string, even with OverloadedStrings enabled. (in ghci at least)
20:42:57 <lambdabot> Unknown command, try @list
20:43:37 <Twey> begriffs: What is the type of decode?  (:t decode)
20:44:08 <begriffs> Data.ByteString.Lazy.Internal.ByteString -> Maybe a where a is an instance of FromJSON
20:44:12 <latermuse> Begriffs: Maybe you are using a strict function on your bytestring, which could make it assume strict strings
20:44:22 <Twey> There you go, then
20:44:47 <Twey> It requires a lazy bytestring; unless you import the .Lazy module, you won't have an instance in scope that will give you a lazy bytestring
20:45:06 <Twey> (an IsString instance, that is)
20:45:34 <begriffs> Oh so even if import Data.Aeson, and one of its functions uses that type, that type is not imported transitively.
20:45:55 <begriffs> Like dependencies of Data.Aeson don't come along for the ride when I import Data.Aeson
20:46:29 <Twey> begriffs: It depends what the author has chosen to export
20:47:46 <Twey> It's not possible to avoid exporting instances, but the module might import a ByteString module that exports the type but not the instance
20:49:56 <arkeet> only if it's an orphaned instance
20:54:51 <joelteon> is Void inhabited by bottom?
20:55:37 <arkeet> every type is inhabited by bottom.
20:55:51 <arkeet> (at least, every type of kind *)
20:56:16 <edwardk> joelteon: in reality yes. logically, none of the combinators for Void give you one, so you had to go make it yourself.
20:56:34 <arkeet> edwardk: but it already exists: undefined
20:56:48 <edwardk> arkeet: yes, but undefined isn't provided by Void ;)
20:56:58 <arkeet> Void has no need to provide it ;)
20:57:29 <edwardk> anyways, when programming with Void the places where it gets constructed are always loops or undefineds or errors in your own code
20:57:40 <edwardk> which i can't fix or feel guilty for
20:57:51 <arkeet> :t fix void
20:57:52 <lambdabot> Functor f => f ()
20:58:24 <edwardk> i don't want to fix void any more. for a package with a type with no inhabitants it has gone through a lot of changes =)
20:58:34 <arkeet> :)
20:58:53 * edwardk finds himself needing a catenable stack-ended queue of pairing heaps of streams and thinks he is going to have to implement it himself.
21:00:16 <edwardk> ugh
21:00:27 <edwardk> worse, its not streams, it has to bootstrap through that parameter.
21:00:39 <pentace> catenable = able to be concatenated
21:00:42 <pentace> ?
21:00:53 <edwardk> a bootstrapped catenable stack-ended queue of heaps
21:00:54 * hackagebot crypto-pubkey-openssh 0.2.2 - OpenSSH keys decoder/encoder  http://hackage.haskell.org/package/crypto-pubkey-openssh-0.2.2 (FedorGogolev)
21:00:56 <edwardk> pentace: yeah
21:02:16 <edwardk> i did some analysis and it turns out it is MUCH better for me to go through and use a heap of streams, inserting them into the heap by their first element, so i only ever have to compare against one thing than to maintain the merge tree i was maintaining
21:02:38 <hpaste_> chexxor_netbook pasted “Get index when iterating through list?” at http://lpaste.net/92027
21:04:00 <edwardk> but i need to be able to say 'interleave these' then 'interleave these', but this means i need to be able to concatenate things that are made up of multiple segments, that drives me to tarjan and kaplan or okasaki's version of catenable deques, but i don't need a full deque, merely a c-steque, that is to say, i only ever pull off one side, so it can be faster.
21:04:18 <edwardk> but i need to bootstrap my own structure because the things in the heap are this same structure again
21:04:20 <edwardk> yay
21:05:17 <edwardk> so now i get to spend the next few hours doing case analysis
21:08:56 <chexxor_netbook> any ideas for what to try? I pasted my problem above.
21:12:12 <pentace> > (\s -> map (\i -> concat $ zipWith (\p c -> if p then [] else [c]) (cycle $ replicate i True ++ [False]) s) [0..length s-1]) "123456789"
21:12:13 <lambdabot>   ["123456789","2468","369","48","5","6","7","8","9"]
21:12:18 <edwardk> > let skips xs = map (\i -> every i xs) [1..length xs] where every k xs = xs^..Lens.elements (\j -> mod j k == k - 1) in skips "ABCDEF"
21:12:20 <lambdabot>   ["ABCDEF","BDF","CF","D","E","F"]
21:12:45 <edwardk> > let skips xs = map every [1..length xs] where every k = xs^..Lens.elements (\j -> mod j k == k - 1) in skips "ABCDEF"
21:12:47 <lambdabot>   ["ABCDEF","BDF","CF","D","E","F"]
21:14:07 <chexxor_netbook> holy eff, that's some pro haskell
21:14:08 <edwardk> > let skips xs = [1..length xs] <&> \ k -> xs^..Lens.elements (\j -> mod j k == k - 1) in skips "ABCDEF"
21:14:10 <lambdabot>   ["ABCDEF","BDF","CF","D","E","F"]
21:16:38 <pentace> :t ([1..2] <$>)
21:16:39 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `[t0]'
21:16:39 <lambdabot>     In the first argument of `(<$>)', namely `[1 .. 2]'
21:16:39 <lambdabot>     In the expression: ([1 .. 2] <$>)
21:17:08 <edwardk> you could do something fancy with an indexed fold on (xs <$ xs) but that seems silly
21:17:26 <pentace> Meh, I misread, '&' /= '$'
21:17:30 <scshunt> :t (<$)
21:17:30 <lambdabot> Functor f => a -> f b -> f a
21:17:47 <edwardk> > "hello" <$ "hello"
21:17:48 <lambdabot>   ["hello","hello","hello","hello","hello"]
21:18:21 <scshunt> (<$) = fmap . const?
21:18:22 <edwardk> > ("hello" <$ "hello")^@..each<.>each
21:18:24 <lambdabot>   [((0,0),'h'),((0,1),'e'),((0,2),'l'),((0,3),'l'),((0,4),'o'),((1,0),'h'),((...
21:18:36 <edwardk> but then you have to get the lists back together
21:18:58 <edwardk> scshunt: yeah, but it inside the Functor class so it can be optimized for some functors
21:19:44 <lightquake> I have some test data that's too large to include inline in my program; should I just dump it in a file and load it up and plug it into the relevant tests at runtime, or is there something else I should do?
21:20:31 <chexxor_netbook> what is the <$ keyword? Quick google search doesn't bring it up
21:20:38 <arkeet> > sequence ["hello","hello"]
21:20:39 <lambdabot>   ["hh","he","hl","hl","ho","eh","ee","el","el","eo","lh","le","ll","ll","lo"...
21:20:46 <scshunt> edwardk: is there a technical reason that functions outside of the typeclass cannot be overriden with specialized versions?
21:20:56 <edwardk> scshunt: yes
21:21:00 <scshunt> edwardk: what is that?
21:21:10 <edwardk> scshunt: how would you supply them?
21:21:18 <edwardk> the dictionary is where they live
21:21:30 <scshunt> edwardk: Syntax-wise or implementation-wise?
21:21:38 <tabemann> > let skips xs = skips' 0 where skips' n = case drop n xs of [] -> [] (first : rest) -> (first : every n rest) : skips' (n + 1) ; every n xs = case drop n xs of [] -> [] (first : rest) -> first : every n rest in skips "ABCDEF"
21:21:39 <lambdabot>   <hint>:1:84: parse error on input `->'
21:21:44 <edwardk> we have RULES to do some rewriting, but without knowing the types you're dispatching on, how would they know to fire?
21:21:52 <scshunt> hmm
21:21:59 <edwardk> basically there is both a syntax and a semantics issue
21:22:00 <tabemann> > let skips xs = skips' 0 where skips' n = case drop n xs of [] -> [] ; (first : rest) -> (first : every n rest) : skips' (n + 1) ; every n xs = case drop n xs of [] -> [] (first : rest) -> first : every n rest in skips "ABCDEF"
21:22:01 <scshunt> it just seems so ugly
21:22:01 <lambdabot>   <hint>:1:131: Parse error in pattern: every
21:22:08 <pentace> chexxor_netbook: It's not a keyword but an operator
21:22:18 <tabemann> that didn't work compressed like that
21:22:21 <arkeet> > map head . chunksOf 3 $ "abcdefghijk"
21:22:22 <lambdabot>   "adgj"
21:22:24 <pentace> :t (<$) -- chexxor_netbook
21:22:25 <lambdabot> Functor f => a -> f b -> f a
21:22:38 <lightquake> I guess I could use TH to pull in the text of the file as a String (or Text)
21:22:42 <edwardk> i would actively rebel against changing it. think of it this way. the issue is the same one with why you can't just use Typeable on everything without the constraint
21:23:02 <edwardk> the class describes how things specialize to different functors.
21:23:10 <edwardk> or whatever Foo concept you're defining
21:23:29 <hpaste_> tabemann pasted “skips (a more long-winded version)” at http://lpaste.net/92028
21:23:43 <edwardk> we don't pattern match on arbitrary types in haskell. given id :: a -> a  you can be pretty sure it doesn't look at it, figure out if it is an Int and add 1 in passing ;)
21:26:20 <haasn> a name for toListOf . indices -- might be useful
21:27:07 <edwardk> well, you can get it with xs^..indices
21:27:15 <edwardk> > "hello"^..indices
21:27:16 <lambdabot>   Couldn't match type `GHC.Arr.Array i0 e0'
21:27:16 <lambdabot>                with `a0
21:27:16 <lambdabot>          ...
21:27:18 <edwardk> er
21:27:24 <edwardk> > "hello"^..traverse.indices
21:27:25 <lambdabot>   Couldn't match type `GHC.Arr.Array i0 e0'
21:27:25 <lambdabot>                with `a0
21:27:25 <lambdabot>          ...
21:27:27 <edwardk> i guess
21:27:37 * edwardk is being slow
21:27:39 <edwardk> :t indices
21:27:39 <lambdabot> Ix i => Array i e -> [i]
21:27:40 <edwardk> oh
21:27:42 <tabemann> edwardk: what about with Typeable... of course then you would have to provide Typeable a => ...
21:27:45 <edwardk> > "hello"^..Lens.indices
21:27:46 <lambdabot>   Couldn't match type `GHC.Types.Bool'
21:27:46 <lambdabot>                with `Control.Lens.Inte...
21:28:07 <haasn> :t toListOf . Lens.indices
21:28:12 <edwardk> tabemann: With Typeable you've marked it and there is no moral objection. you've "opted in"
21:28:14 <lambdabot>     Couldn't match type `Indexed i0 a0 (Accessor (Endo [a0]) a0)'
21:28:14 <lambdabot>                   with `s0 -> Accessor (Endo [a0]) s0'
21:28:15 <lambdabot>     Expected type: (i0 -> Bool) -> Getting (Endo [a0]) s0 a0
21:28:21 <edwardk> > "hello"^..traverse.Lens.indices
21:28:24 <haasn> well, should be Traversable t => (Int -> bool) -> t a -> [a]
21:28:25 <edwardk> > "hello"^..traversed.Lens.indices
21:28:27 <lambdabot>   Couldn't match type `GHC.Types.Bool'
21:28:27 <lambdabot>                with `Control.Lens.Inte...
21:28:27 <lambdabot>   Couldn't match type `GHC.Types.Bool'
21:28:27 <lambdabot>                with `Control.Lens.Inte...
21:28:34 <lightquake> indices looks like it takes some kind of predicate
21:28:41 <haasn> on second thought that seems less useful than -> t a
21:28:42 <edwardk> > "hello"^..traversed . Lens.asIndices
21:28:43 <lambdabot>   Not in scope: `Lens.asIndices'
21:28:43 <lambdabot>  Perhaps you meant one of these:
21:28:43 <lambdabot>    `Lens.in...
21:28:45 <edwardk> > "hello"^..traversed . Lens.asIndex
21:28:47 <lambdabot>   [0,1,2,3,4]
21:28:47 <haasn> but the latter isn't possible obviously
21:28:51 <edwardk> > "hello"^..traversed.asIndex
21:28:53 <lambdabot>   [0,1,2,3,4]
21:28:54 <edwardk> finally =)
21:29:12 <edwardk> i can never remember those combinators
21:29:15 <lightquake> what's traversed?
21:29:22 <haasn> traversed is traverse but indexed with Int
21:29:28 * tabemann honestly really doesn't like the idea of Typeable... reminds him too much of languages that are supposedly statically typed but are actually underlyingly dynamically typed, like Java...
21:29:33 <haasn> use it whenever you need indexing
21:29:34 <edwardk> traversed = traverse but is an indexed traversal with an Int index, starting counting from 0
21:29:39 <lightquake> ah
21:29:45 <lightquake> seems like a confusing name tbh
21:29:56 <edwardk> > "hello"^@..traversed
21:29:57 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
21:29:58 <haasn> it matches ‘folded’ and ‘mapped’
21:31:00 <edwardk> when I added indexed traversals i added ifolded, imapped, etc.  and itraversed,  and itraverse can then be the combinator that performs an indexed traversal of a valid FoldableWithIndex instance.
21:31:02 <edwardk> :t itraverse
21:31:19 <edwardk> :t Control.Lens.itraverse
21:31:20 <lambdabot> (Applicative f, TraversableWithIndex i t) => (i -> a -> f b) -> t a -> f (t b)
21:31:23 <edwardk> :t Control.Lens.itraversed
21:31:24 <lambdabot> (Applicative f, Indexable i p, TraversableWithIndex i t) => p a (f b) -> t a -> f (t b)
21:31:37 <edwardk> the latter is implemented using the former
21:31:58 <chexxor_netbook> so I can't just use one function or idea to solve this problem? Look sli (\s -> map (\i -> concat $ zipWith (\p c -> if p then [] else [c]) (cycle $ replicate i True ++ [False]) s) [0..length s-1]) "123456789"
21:31:59 <edwardk> > M.fromList [("hello",2)]^..itraversed
21:32:00 <lambdabot>   [2]
21:32:03 <edwardk> > M.fromList [("hello",2)]^@..itraversed
21:32:04 <lambdabot>   [("hello",2)]
21:32:07 <edwardk> > M.fromList [("hello",2)]^@..traversed
21:32:08 <lambdabot>   [(0,2)]
21:32:10 <chexxor_netbook> damn paste on this netbook
21:32:11 <edwardk> notice the difference
21:32:20 <haasn> :t Control.Lens.itraverse . Control.Lens.indexed
21:32:20 <lambdabot> (Applicative f, Indexable i p, TraversableWithIndex i t) => p a (f b) -> t a -> f (t b)
21:32:34 <lightquake> edwardk: M is Data.Map?
21:32:41 <edwardk> lightquake: yeah
21:32:56 <edwardk> Map has a FoldableWithIndex instance, so you can use itraversed on it
21:33:06 <edwardk> er TraversableWithIndex
21:33:21 <edwardk> but traversed works with any old Traversable instance
21:33:23 <edwardk> :t traversed
21:33:29 <edwardk> :t Control.Lens.traversed
21:33:30 <lambdabot> (Applicative f1, Traversable f, Indexable Int p) => p a (f1 b) -> f a -> f1 (f b)
21:33:44 <lightquake> so traversed iterates over whatever and uses the position of the item in the traversal, whereas itraversed uses the 'actual' index?
21:33:50 <edwardk> :t traversed putStrLn
21:33:51 <lambdabot> Traversable f => f String -> IO (f ())
21:33:52 <edwardk> yeah
21:34:13 <edwardk> but by profunctor magic i make it so 'traversed' can be used directly as a traversal, so if you don't use the index, you don't really pay for it
21:34:13 <haasn> :t M.fromList [("hello",2), ("world", 4)] & itraversed.indices (== "hello") .~ 10 -- who needs ix
21:34:14 <lambdabot>     Couldn't match expected type `(a1 -> Mutator b0)
21:34:14 <lambdabot>                                   -> p0 a0 (Mutator b1)'
21:34:14 <lambdabot>                 with actual type `[i0]'
21:34:16 <haasn> oh no
21:34:24 <lightquake> got it
21:34:29 <chexxor_netbook> ah, looks like arkeet had a good idea -- map head . chunksOf 3 $ "abcdefghijk"
21:34:37 <haasn> this works locally, err
21:34:43 <haasn> M.fromList [("hello",2), ("world", 4)] & itraversed.Lens.indices (== "hello") .~ 10
21:34:47 <haasn> > M.fromList [("hello",2), ("world", 4)] & itraversed.Lens.indices (== "hello") .~ 10
21:34:48 <lambdabot>   fromList [("hello",10),("world",4)]
21:34:52 <haasn> there we go :)
21:34:57 <edwardk> you can use 'index' there
21:35:08 <haasn> ah, okay
21:35:11 <edwardk> > M.fromList [("hello",2), ("world", 4)] & itraversed.Lens.index "hello" .~ 10
21:35:12 <lambdabot>   fromList [("hello",10),("world",4)]
21:35:16 <haasn> or ix :)
21:35:25 <edwardk> yeah. ix would be way faster
21:35:57 <haasn> is there any law on indexed versions of lenslikes? eg. that indices have to be unique
21:36:18 <edwardk> haasn: we used to say that, but we don't enforce it or even use it anywhere outside of zippers
21:36:28 <chexxor_netbook> I need to go find food before the taiphoon hits. Thanks for the ideas. :-)
21:36:33 <lightquake> so, suppose I have a list and I want to add the index to each element; what would a nice way to do that be?
21:36:44 <haasn> :t zip [0..]
21:36:45 <lambdabot> (Enum a, Num a) => [b] -> [(a, b)]
21:36:57 <edwardk> the zipper code has some stuff for assuming the indices will be monotonically increasing by Ord and thereby allowing you to jump via binary search through the zipper.
21:37:02 <edwardk> but you have to explicitly use it
21:37:03 <lightquake> well sure but suppose I want to use these fancy traversal mechanics :)
21:37:11 <haasn> :t itoListOf traversed -- generalized!
21:37:12 <lambdabot> Traversable f => f a -> [(Int, a)]
21:37:15 <edwardk> :t imap
21:37:16 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
21:37:20 <edwardk> :t imap (+)
21:37:21 <lambdabot> (Num b, FunctorWithIndex b f) => f b -> f b
21:37:23 <haasn> :t itoListOf folded -- even more generalized!
21:37:24 <lambdabot> Foldable f => f a -> [(Int, a)]
21:37:29 <edwardk> > imap (+) [4,2,2]
21:37:30 <lambdabot>   [4,3,4]
21:37:50 <haasn> :t imap (,)
21:37:51 <lambdabot> FunctorWithIndex i f => f a -> f (i, a)
21:37:53 <haasn> neat
21:38:04 <edwardk> or did you not mean literally add =)
21:38:10 <haasn> heh
21:38:48 <haasn> shorter than zip [0..] too, so it's an objective improvement
21:38:54 <haasn> I didn't think lens could produce anything better than that
21:39:10 <lightquake> edwardk: well, I figure that if I know how to add I can apply any other function to both of them by making the obvious substitution
21:39:12 <edwardk> haasn: it also works on other container types
21:39:29 <edwardk> lightquake: yeah. imap is your friend
21:40:08 <edwardk> i named those combinators ifoo because fooWithKey or fooWithIndex would be long enough people would get mad, and would also conflict with the exported versions from Map, etc. making more people want to import lens qualified
21:40:53 <edwardk> > "hello"^..magma traverse
21:40:55 <lambdabot>   [.. <$> Magma 0 'h' <*> (.. <$> Magma 1 'e' <*> (.. <$> Magma 2 'l' <*> (.....
21:40:57 <edwardk> > "hello"^.magma traverse
21:40:58 <lambdabot>   .. <$> Magma 0 'h' <*> (.. <$> Magma 1 'e' <*> (.. <$> Magma 2 'l' <*> (.. ...
21:41:25 <lightquake> edwardk: sure, iwhatever is a decent name
21:41:26 <haasn> I've never managed to wrap my head around this magma stuff or what it's useful for
21:41:43 <edwardk> > M.fromList [("hello","world")]^.magma itraversed
21:41:44 <lambdabot>   .. <$> pure .. <*> Magma 0 "world" <*> pure ..
21:41:58 <tabemann> this all definitely sounds nicer than what I've had to do when mapping over lists is to actually use mapAccumL and maintain my index as the folded value, manually incrementing it
21:42:14 <edwardk> it gives you the 'shape' of the traversal as a data type, you can then go in traverse and swap out its contents, and then run the magma
21:42:15 <edwardk> :t runMagma
21:42:16 <lambdabot> Not in scope: `runMagma'
21:42:20 <haasn> tabemann: zipWith f [0..] -- still works!
21:42:24 <edwardk> :t Control.Lens.Internal.Magma.runMagma
21:42:25 <lambdabot> Magma i t a a -> t
21:42:45 <edwardk> :t magma traversed
21:42:46 <lambdabot> (Functor f, Traversable f1, Profunctor p) => p (Magma Int (f1 b) b a) (f (Magma j u c c)) -> p (f1 a) (f u)
21:42:56 <haasn> Iso?
21:42:56 <edwardk> :t [1..10]^.magma traversed
21:42:56 <tabemann> haasn: I'm still in the habit of trying to avoid *any* unnecessary allocation, even though I'm trying to get out of it
21:42:57 <lambdabot> (Enum b, Num b) => Magma Int [b] b b
21:44:02 <haasn> > []^.magma traversed
21:44:04 <lambdabot>   pure ..
21:44:09 <edwardk> haasn: yeah, magma takes a traversal and builds an isomorphism from something to the magma of that traversal over that data type.     you can reassemble the data structure from the magma later. it is like a 'slowed down' traversal.
21:44:43 <haasn> but we want things to be fast in HEAD!
21:44:46 <edwardk> in the meantime the magma itself lets you show it, map over it in multiple passes as a functor/traversal, etc.
21:44:59 <edwardk> and then you can get the types to match up and extract it
21:45:54 <haasn> reminds me of codensity; if Magma is a functor/traversable/whatever for whatever types
21:46:08 <edwardk> Magma i t a b     is a value actively being traversed, where the values of all the traversal targets have index type i and are currently 'b's, in such a way that if you change all of them to 'a's we know how to reassemble it into a 't'.
21:46:10 <haasn> fmap = MagmaFmap -- ?
21:46:41 <edwardk> no, MagmaFmap is that the traversal did an fmap, not that we're doing one
21:46:48 <edwardk> (Magma i t a) is a real Functor
21:46:53 <haasn> ah
21:47:12 <edwardk> we fmap over it by walking down to the leaves and applying the function turning 'b's into some new type.
21:47:13 <mm_freak> Traversable is not powerful enough for 'filter'…  what is powerful enough and still covers [], Seq, Set and Map?
21:47:24 <haasn> yeah makes sense now
21:47:54 <edwardk> mm_freak: you can use fmap. also 'filtered' is an 'illegal prism' so in practice you _can_ use it, but you should feel bad about yourself immediately thereafter ;)
21:47:56 <edwardk> er
21:47:57 <edwardk> sorry
21:48:02 <edwardk> you can use a Fold i mean
21:48:21 <edwardk> basically the magma is me capturing the traversal in amber so i can inspect it
21:48:37 <edwardk> the fact that that could be done wasn't immediately obvious
21:48:50 <mm_freak> edwardk: where is it defined?  side note: my question is unrelated to your discussion with haasn
21:49:01 <edwardk> filtered?
21:49:03 <edwardk> or magma?
21:49:08 <edwardk> oh filtered
21:49:36 <mm_freak> oh, you mean a lens Fold?
21:49:42 <edwardk> filtered is in http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Control-Lens-Fold.html#v:filtered
21:49:54 <edwardk> the reason it is up in Fold is it isn't a "legal" traversal or prism
21:50:02 <edwardk> it just typechecks in places that expect them
21:50:44 <edwardk> filtered p = dimap (\x -> if p x then Right x else Left x) (either pure id) . right'  -- would basically using the prism combinator, but it shouldn't because it isn't making a prism
21:50:51 <mm_freak> how would i express 'catMaybes' or 'rights' using that?
21:51:07 <mm_freak> (Something f) => f (Either e a) -> f a
21:51:11 <mm_freak> removing all Lefts
21:51:53 <edwardk> we kind of suck at applying a prism or lens under a structure, hrmm
21:52:55 <edwardk> it doesn't really fit
21:52:57 <mm_freak> i guess an Unfoldable class would be sufficient
21:53:08 <mm_freak> (Foldable f, Unfoldable f) => f (Either e a) -> f a
21:53:09 <edwardk> there isn't a notion of a container 'f' that you can filter that we provide anywhere
21:54:00 <mm_freak> hmm, no…  Unfoldable wouldn't work
21:54:02 <mm_freak> it doesn't cover Map
21:54:52 <edwardk> clearly it should be   (>>= \case Right a -> return a; _ -> empty)
21:54:59 <edwardk> er mzero i guess
21:55:17 <mm_freak> yeah, except that Map doesn't have a 'return'
21:56:06 <edwardk> you really need to traverse the map twice to do this sanely or use a map specific combinator
21:56:29 <edwardk> since we have no way to 'filterMap' without it
21:56:36 <mm_freak> well, i could make up something
21:56:52 <edwardk> for some filterMap :: … (a -> Maybe b) -> f a -> f b
21:57:17 <edwardk> the lack of that kind of function routinely annoys me
21:57:34 <edwardk> because filtering and then mapping immediately after with a partial function always strikes me as a wart
21:57:44 <edwardk> i think Map has one somewhere though
21:57:59 <mm_freak> (Plus f) => (forall g w. (Singleton g, Comonad w) => w a -> g (w b)) -> f a -> f b
21:58:13 <mm_freak> that's so complicated it almost feels wrong
21:58:28 <mm_freak> s/Singleton/Applicative/
21:58:29 <edwardk> if that only _almost_ feels wrong, i worry about you =)
21:58:53 <mm_freak> well, it would work, but it would be very arbitrary =)
22:00:21 <mm_freak> edwardk: but say, do you have a Monad sans return somewhere? =)
22:00:25 <mm_freak> (>>=) would totally suffice
22:00:44 <mm_freak> no, it would not…  forget it =/
22:00:47 <edwardk> mm_freak: Data.Functor.Bind in semigroupoids
22:01:07 <edwardk> that is a 'Semimonad' class basically
22:01:29 <mm_freak> yeah, but i just realized it's not enough
22:04:31 <orzo> I'm using RankNTYpes and I want to specify: "any function that is polymorphic enough to be able to send both type a and type b to a type c"   But the best I could come with is (forall x. f x -> c) and then using f a and f b instead of a and b.  But that's not quite right
22:05:51 <orzo> it works for 'head' and 'null' for [a] and [b], and it works for 'fst' for (a,Int) (a,String) but it doesn't work for 'snd' with types (Int,a) and (String,a)
22:06:23 <orzo> Is there anyway to specify the type I want?
22:06:24 <haasn> ‘class Bizarre’ hehe
22:06:39 <mm_freak> orzo: (Either a b -> c) -> …?
22:09:16 <orzo> mm_freak: no, not really, i'm trying to promote a polymorphic function to one that will act on Either's.  So  for example,  promote f = either f f <-- but with polymorphism
22:09:57 <orzo> it seems wrong for me to be forced to specify the function twice
22:11:48 <orzo> mm_freak: see this: http://jerkface.net/~joe/Control-Bijection.html  <-- I'm trying to come up with the best type signature for my 'bothways' method
22:14:17 <orzo> mm_freak_: wb, did you see my post?
22:14:21 <mm_freak_> yeah
22:14:25 <mm_freak_> not sure how that would work
22:15:23 <orzo> well i think i prefer the version i have now to just tossing it because its not as general as it should be
22:15:38 <mm_freak_> i don't think you can get around the 'f'
22:15:52 <mm_freak_> but then the whole function is pointless, so you could just as well say, "use either"
22:16:30 <orzo> yeah i think i prefer keeping it, with the 'f' to that
22:17:05 <orzo> i mean it is not pointless iwth the f, it works in a lot of instances
22:17:41 <joelteon> GHC is complaining "Could not deduce (PersistEntityBackend val0 ~ SqlBackend)" from loadFixtures in here: https://gist.github.com/joelteon/6290559
22:17:58 <joelteon> it looks to me like the [Filter a] on line 28 is not using the same a as specified in the type sig for loadFixtures on line 26
22:18:04 <mm_freak_> orzo: i mean i don't see why people wouldn't just use 'either'
22:18:44 <joelteon> aren't those a's supposed to be the same if I specify forall a? or am I missing an extension or something
22:19:21 <mm_freak_> joelteon: see the ScopedTypeVariables extension
22:19:24 <orzo> mm_freak_: did yo usee my example at the top?  ifb (bothways null)  would become  ifb (const (either null null))
22:19:46 <orzo> don't you think (bothways null) is better than (const (either null null)) ?
22:20:23 <mm_freak_> joelteon: with the extension the 'a' in the type signature "[] :: [Filter a]" refers to the same 'a' as in the top-level type signature
22:20:30 <mm_freak_> but it requires the 'forall' for that
22:20:34 <joelteon> oh
22:20:59 <joelteon> yeah, that did it. adding ScopedTypeVariables and it compiles ;D
22:21:04 <mm_freak_> orzo: no, i don't
22:21:24 <mm_freak_> orzo: i understand 'const (either null null)' immediately
22:21:31 <mm_freak_> 'bothways null' i have to look up
22:22:13 <edwardk> :t backwards traverse
22:22:13 <lambdabot> (Applicative f, Traversable t) => Overloading (->) (->) f (t a) (t b) a b
22:22:20 <edwardk> > [1..10]^..backwards traverse
22:22:21 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
22:22:29 <mm_freak_> furthermore 'bothways null' is a type error, if 'a' and 'b' are supposed to be lists
22:22:42 <orzo> what?
22:22:51 <mm_freak_> err, if /not/ both are supposed to be lists
22:22:55 <mm_freak_> try (== 0) for Integer
22:23:01 <mm_freak_> instead of 'null'
22:23:14 <mm_freak_> the type signature works because f = []
22:23:32 <orzo> mm_freak_: that's wrong, both lists is exactly right
22:23:41 <orzo> its checking for the null list
22:23:50 <orzo> whether its looking at the integers or the chars
22:23:59 <orzo> thats intended
22:24:08 <mm_freak_> orzo: consider this:  const (either (== 0) (== 0))
22:24:11 <orzo> its a base case to the recursion
22:24:24 <mm_freak_> try to express it in terms of 'bothways'
22:24:49 <orzo> it wont work because the numbers aren't functored
22:25:07 <orzo> and thats due to haskell's unwillingness to let me specify the right type
22:25:53 <mm_freak_> whatever the right type would be
22:26:08 <orzo> the right type is a type polymorphic enough to include types a and b
22:26:14 <orzo> its a precise thing
22:26:17 <orzo> not some fuzzy idea
22:26:24 <orzo> its the language's failure, not mine
22:26:49 <Twey> Isn't that just (d → c)?
22:26:56 <mm_freak_> it's not a precise thing, because it's ill-defined, unless you want to introduce run-time type information
22:27:11 <Twey> Oh, right
22:27:20 <mm_freak_> bothways :: (a -> b) -> (b -> c) -> ctx -> Either a b -> c
22:27:33 <elliott> bothways :: (forall a. f a -> r) -> Either (f a) (f b) -> r or something?
22:27:34 <orzo> whats that
22:28:03 <mm_freak_> elliott: that's the current one, but orzo isn't happy with it
22:28:29 <elliott> essentially you want intersection types, I guess.
22:28:43 <mm_freak_> orzo: the problem is that at run-time the only thing telling 'a' from 'b' is Either's constructor
22:28:49 <elliott> bothways :: ((a -> c) & (b -> c)) -> Either a b -> c
22:28:56 <mm_freak_> a polymorphic function would have to match on something other than that
22:29:28 <mm_freak_> which means that either you need some other constructor or some form of RTTI
22:29:35 <mm_freak_> haskell does not give you the latter
22:29:45 <tac> @hoogle String -> [String] -> String
22:29:45 <lambdabot> System.Process showCommandForUser :: FilePath -> [String] -> String
22:29:45 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
22:29:45 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
22:29:59 <orzo> there's no theoreticall reason why RTTI is needed to implement the feature, and that's trivial to prove
22:30:11 <tac> is there a more common name for intercalate? Something in the prelude specialized to strings?
22:30:12 <orzo> i mean, its trvial to prove that it is NOT needed
22:30:21 <mm_freak_> orzo: how would you prove it?
22:31:13 <orzo> suppose I make a macro that rewrites every instancde of (bothways f) with (const (either f f)).  Then the program would work fine, have full type safefty and no RTTI info added.  Q.E.D.
22:31:40 <mm_freak_> orzo: that doesn't prove the program is well-typed, only that it works
22:31:55 <tac> @hoogle sort
22:32:09 <mm_freak_> every type system limits the set of correct programs
22:32:14 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
22:32:15 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
22:32:15 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
22:32:50 <mm_freak_> orzo: "ill-typed" doesn't mean incorrect…  it means ill-typed
22:33:50 <elliott> orzo: sure you can hack bothways into the language as a one-off hack.
22:33:58 <elliott> but to give it a principled type requires e.g. intersection types
22:34:09 <elliott> and then you can quickly throw out inference or even decidable typechecking out the window
22:34:18 <mm_freak_> orzo: here is one interesting example:  "f x" may be well-typed, but that doesn't mean that "f $ x" is
22:34:19 <elliott> (I don't quite understand mm_freak_'s argument, though)
22:34:48 <mm_freak_> and it would be incorrect for the compiler to accept "f $ x" in those cases
22:35:21 <Twey> tac: No, intercalate is the one to use
22:35:29 <elliott> you can use something like HMF to ensure (f $ x) always types if (f x) does, though.
22:35:48 <elliott> hardly out of the question to tweak the type system when you're changing the language so that something types :)
22:35:53 <orzo> elliott: okay, so the language doesnt do it because it interferes with some other goodies, and not because there's something worng with my notion that it could do it
22:36:17 <orzo> either way, its a limitation of the language
22:37:43 <orzo> is there a way i could make it include more cases
22:38:16 <elliott> orzo: um, well. I don't think something that gives you decidable typechecking can be called a "limitation"...
22:38:27 <mm_freak_> orzo: your mapped variant includes all cases…  you can always use Identity
22:38:29 <orzo> like (bothways fst) works but (bothways snd) does not, and that's a little unsatisfying
22:38:31 <elliott> if you're willing to throw it away then you can also demand that the compiler decide whether arbitrary logical propositions are true or false
22:38:39 <elliott> and claim it's a limitation of the language that it can't
22:38:46 <elliott> technically true maybe, but more than a little silly :)
22:39:30 <orzo> i'm not saying the compiler didnt amke the right choice in limiting me here, maybe they did, i'm just saying what i wanted to do was perfectly reasonable in spite of freaky deaky here
22:39:48 <mm_freak_> elliott: on the other hand you can prove false in haskell anyway =)
22:40:24 <mm_freak_> orzo: provide 'bothways' for mapped cases and tell your users to use 'either' otherwise
22:40:53 <orzo> ya thats what ill do
22:41:05 <Twey> What librar(y|ies) would be good these days for simple interactive vector graphics?
22:41:10 <mm_freak_> bothways ((== 0) . runIdentity)
22:41:25 <mm_freak_> Twey: gloss?
22:42:06 <dmj`> Twey: http://projects.haskell.org/diagrams/
22:42:07 <Twey> Does gloss do interaction?  I looked at it but it seems to only handle drawing
22:42:21 <mm_freak_> Twey: it does, but it doesn't help you much
22:42:29 <mm_freak_> you don't get selection for example
22:43:07 <Twey> I only really want to be able to pick out clicks on topmost shapes.  I think.
22:43:23 <mm_freak_> that's difficult with gloss
22:43:48 <Twey> What *does* gloss do?
22:44:09 <mm_freak_> it gives you pixel coordinates of clicks, key strokes and the like
22:44:47 <Twey> Hm, that would be enough, I guess — I just need to keep track of where stuff is
22:45:23 <mm_freak_> OpenGL is probably easier for that…  it actually allows you to identify the meshes clicked pixel-perfectly
22:45:45 <Twey> Yeah, but I'd have to write OpenGL.  :þ
22:45:54 <elliott> I think diagrams is good at this?
22:46:00 <mm_freak_> is diagrams interactive?
22:46:06 <elliott> I think you can make it be so.
22:46:06 <Ralith> mm_freak_: that's kind of misleading
22:46:06 * hackagebot storable-static-array 0.6.1.0 - Statically-sized array wrappers with Storable instances  for FFI marshaling  http://hackage.haskell.org/package/storable-static-array-0.6.1.0 (CarlHowells)
22:46:11 <mm_freak_> last time i checked it was only a rendering library
22:46:36 <mm_freak_> Ralith: ?
22:46:38 <Ralith> Twey: you should generally expect to have to do your own modeling
22:46:40 <Twey> « The GTK backend allows rendering diagrams directly to GTK windows instead of to a file. Note that it is possible to receive mouse clicks and then query the corresponding location in a diagram to find out which part the user clicked on »
22:46:44 <Twey> — brilliant
22:47:06 <Ralith> 22:46:50 < mm_freak_> OpenGL is probably easier for that…  it actually allows you to identify the meshes clicked pixel-perfectly
22:47:22 <mm_freak_> Ralith: why is that misleading?
22:47:28 <isomorphic> I have a long running C function that I'm running using forkIO.  I'd like to reduce its priority to stop it interrupting the (basically real-time) main thread of execution.  Is there a way to do that with Control.Concurrent?
22:47:41 <Ralith> because OpenGL has no notion of 'mesh' and certainly not identification thereof.
22:48:09 <Twey> Ralith: I'm not averse to doing modelling (especially since I'm only going to be drawing some rectangles and stuff), but I'd rather avoid writing OpenGL if I can.  Haskell's too nice to besmirch with it.  :þ
22:48:21 <Ralith> you can abuse certain features to make a really ugly, inefficient hack that allows you to do pixel-picking as you envision, but that's really very much the wrong way to do it.
22:48:31 <Ralith> Twey: I mean modeling your world.
22:48:39 <Ralith> as in, defining a computational model for it.
22:49:23 <edwardk> data Heaps a = Empty | Heaps !Key a [Heaps a] [Heaps a] [Heaps a]   -- could be slightly more informative. =/
22:49:31 <Twey> Oh… yes, I have that already.  I have some data; I'd like to make an interactive diagram (probably just a bar chart) with facilities for panning around, zooming, and editing data-points.
22:49:45 <Ralith> Twey: then you will need to model that interaction.
22:49:56 <ReinH> Twey: using GTK?
22:49:59 <ReinH> edwardk: hai
22:50:01 <Twey> Yes
22:50:04 <Twey> ReinH: Using whatever
22:50:07 <edwardk> heya ReinH
22:50:25 <tac> fucking haskell ;___;
22:50:30 <mm_freak_> Ralith: i understand your point, but it's easy enough to draw each object in a unique color and then check the pixel value
22:50:33 <ReinH> Twey: If you weren't tied to a particular representation then I would suggest d3.js
22:50:34 <mm_freak_> it's ugly, but it works
22:50:37 <tac> 10 minutes wasted looking for an infinite loop, blah blah blah where name = name
22:50:55 <ReinH> tac: yep, totally haskell's fault :)
22:51:02 <edwardk> tac: heh
22:51:31 <Ralith> mm_freak_: it's extremely ugly, violates at least one major tenet of GPU use, and is not in sum an OpenGL feature but rather a messy hack.
22:51:36 <Twey> ReinH: Hm.  I would rather keep it in Haskell if possible.  I gave Raphaël a little thought, too.
22:51:41 <tac> ReinH: general recursion is obviously a type error...
22:51:54 <ReinH> tac: needs more coinduction
22:52:05 <Ralith> mm_freak_: and worse still, it is in fact *substantially more complex* than the correct solution.
22:52:12 <tac> I kind of wish there was a distinction between let and letrec, where let would only let you write code that was 'obviously' terminating or productive
22:52:21 <ReinH> Twey: d3.js is great if you can target svg / the browser. Really powerful abstraction for data viz
22:52:27 <tac> and letrec is #yolo recursion
22:52:32 <mm_freak_> Ralith: it is actually an OpenGL feature
22:52:32 <mm_freak_> glRenderMode(GL_SELECT)
22:52:46 <ReinH> tac: so about that "obviously terminating"...
22:52:49 <Ralith> mm_freak_: oh, strange, I had no idea
22:53:00 <Ralith> mm_freak_: nonetheless it's horrific and should be killed with fire and never mentioned in polite company again :P
22:53:18 <mm_freak_> hehe
22:53:22 <tac> ReinH: same way agda and friends do it: a structural recursion check. Catches 95% of what you want to do.
22:53:51 <Twey> Deprecated, apparently
22:53:51 <ReinH> tac: http://en.wikipedia.org/wiki/Corecursion
22:54:01 <tac> ReinH: I know what corecursion is...
22:54:09 <ReinH> tac: ok :)
22:54:20 <Twey> tac: But you then need to check all functions called within a let for totality
22:54:26 <tac> ReinH: duuuuuh. Like... who doesn't know corecursion by now ;P
22:54:31 <ReinH> tac: I was just thinking about http://blog.sigfpe.com/2007/07/data-and-codata.html
22:54:33 <tac> Twey: yes.
22:54:46 <Ralith> Twey: it's almost like it's terrible and should never be used :P
22:54:53 <Twey> Ralith: Surely not!
22:55:06 <tac> ReinH: This is my unplublished, less elegant version of that same article: http://tac-tics.net/data-vs-codata
22:55:19 <mm_freak_> yeah, and people who know what corecursion is would never write "main = main" =)
22:55:26 <ReinH> tac: :)
22:55:30 <tac> :)
22:55:31 <ReinH> lmao
22:55:41 <tac> I still think the Partial monad is really cool
22:55:56 <ReinH> tac: added to my reading list
22:56:13 <mm_freak_> btw, guarded corecursion always makes me go mad in agda
22:56:17 <tac> ReinH: My article is probably an embarrassment. Which is why I never published it :)
22:56:18 <mm_freak_> codata was way nicer to work with
22:56:23 <ReinH> tac: I will be the judge of taht
22:56:25 <ReinH> also that
22:56:38 <tac> corecursion just kind of sucks in intentional type theory :<
22:56:55 <ReinH> intentional type theory: type theory like you really mean it.
22:57:07 <johnw> edwardk: ping
22:57:14 <edwardk> pong
22:57:15 <ReinH> johnw: oh hai
22:57:18 <johnw> hi ReinH!
22:58:10 <kqr1>    Bootstrapping using   : /usr/bin/ghc
22:58:12 <kqr1> whoops
22:58:14 <kqr1> wrong channel!
22:58:54 <mm_freak_> tac: is it corecursion in intensional type theory that sucks?  or is it intensional type theory itself?
22:59:32 <tac> mm_freak_: Mostly it's that coinductive types act as if they were well-dressed functions
22:59:49 <tac> And lack of functional extensionality means you can't prove a lot of very true things about them
23:00:49 <tac> I wish I knew more about coinduction, though.
23:01:13 <tac> Supposedly, a lot is known about it. But it's all folklore as far as I can tell. Not nearly as much is written down :(
23:01:15 <mm_freak_> well, i only know agda, but proving things is hard with it
23:01:38 <mm_freak_> it took me many attemps before i finally understood how to prove commutativity for _+_ on natural numbers =)
23:01:41 <dwcook> Is there a Haskell module for placing an icon in a FreeDesktop-compliant system tray?
23:01:45 <tac> Often harder than you think. Often impossible :(
23:02:15 <tac> well... and generally understanding dependently typed lambda caluclus is kind of a mindf***
23:03:27 <tac> You have to build a good mental model of what equalities hold judgmentally, while you shuffle them around propositionally
23:04:10 <tac> It's even harder when you can't use pattern-matching (like the first few chapters of the HoTT book :)
23:06:37 <mm_freak_> dwcook: there are at least two applications on hackage that use the system tray
23:06:48 <mm_freak_> http://hackage.haskell.org/packages/archive/pkg-list.html
23:06:56 <mm_freak_> search for "tray" and see their source code
23:07:27 <mm_freak_> tac: i'm far from understanding any of HoTT
23:08:08 <tac> It's some pretty neat stuff
23:08:29 <tac> Even if you don't care for all the homotopy stuff, univalence would be useful for programming in, say, Agda or whatever
23:08:51 <dwcook> mm_freak_, looks like I used poor search terms. Thanks!
23:09:00 <Ralith> tac: error in your article: "If this were codata ... But when it's codata"
23:09:13 <tac> You can prove facts are true about a naively-implemented "reference" implementation of the thing you care about... then you can transport those proofs to your finely-tuned program as long as you have an isomorphism
23:09:30 <tac> Ralith: I don't doubt that article is rittled with errors :P
23:09:32 <tac> but thank you
23:09:48 <Ralith> tac: to be fixed one at a time ^^
23:10:03 <ReinH> tac: tac *riddled with errors
23:10:05 <ReinH> errorception
23:10:34 <tac> Ralith: I have some latent plans on writting a nice deep tutorial on type theory aimed at programmers.... it will come along eventually
23:11:05 <ReinH> tac: you should have said that it is your intention to write a nice deep tutorial on type theory
23:11:58 <tac> yes well
23:12:13 <tac> I have an outline and I worked on the first part a bit
23:12:20 <tac> But it might be a while before I get to it.
23:12:37 <dwcook> Blech, not sure bringing in all of GTK+ just to get this is a good idea. I might need to write my own module.
23:30:29 <ben_> anyone using postgresql-simple here who can throw some light on the correct types to use for timestamps? at the moment I'm using UTCTimestamp but don't know the magic to pull it back out of the database
23:44:46 <ReinH> tac: get it... *intentional* type theory? I'll show myself out.
23:45:53 <blackdog> hey, any recommendations on html parsing/selection libs?
23:53:09 <joelteon> html-conduit looks good to me
