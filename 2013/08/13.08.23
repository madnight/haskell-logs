00:01:08 <dwcook> Does cabal have an option to add a specific package to the dependencies of a specific package description file?
00:01:33 <mm_freak_> dwcook: could you rephrase the question?
00:02:10 <dwcook> Well, I noticed cabal automatically added a dependency on base when I first generated my package config. But I've since started using a module in containers, which is not part of that automatically generated config. How do I get cabal to add it?
00:02:18 <Walther> Ahh :3 "In an imperative language, you have no guarantee that a simple function that should just crunch some numbers won't burn down your house, kidnap your dog and scratch your car with a potato while crunching those numbers."
00:02:54 <dwcook> Preferably without having to re-answer all the questions I answered initially, like synopsis
00:03:16 <mm_freak_> dwcook: build-depends: base >= 4.5 && < 5, containers >= … && < …
00:03:26 <mm_freak_> in your library/executable/test-suite/benchmark section
00:03:35 <dwcook> mm_freak_, well, I was curious if it could deal with that automatically.
00:03:44 <dwcook> Since I know it can *initially* generate it automatically.
00:04:15 <mm_freak_> dwcook: no, it doesn't do that for you after initialization
00:04:16 <dwcook> It probably knows better than I do what comparator to use with what version, for example.
00:04:20 <dwcook> Ah. I see.
00:04:26 <mm_freak_> no, it doesn't =)
00:04:35 <dwcook> Well, currently it does. :)
00:04:40 <Walther> Uhm, now I got confused. If in Haskell, you cannot change "variables" once set, how can I implement a while-loop, with being user-interruptable? (As in, 'Do you want to play again?')
00:04:50 <dwcook> That's more a statement about my own ignorance than anything, of course.
00:05:14 <mm_freak_> dwcook: usually you would want to depend on a specific minor version up to, but excluding, the next major or minor version
00:05:21 <mm_freak_> >= 2.5 && < 2.6
00:05:23 <mm_freak_> >= 2.5 && < 3
00:05:33 <dwcook> Makes sense.
00:05:36 <mm_freak_> i usually do the latter, many others do the former
00:06:05 <dwcook> Walther, one answer is recursion.
00:06:05 <leroux> Walther: Control.Monad has stuff to do that.
00:06:16 <dwcook> But there are much better tools in the libraries, as it turns out.
00:06:29 <mm_freak_> Walther: recursion
00:06:44 <mm_freak_> loop = … loop …
00:06:46 <dwcook> mm_freak_, so I should just lookup what version of the package I have installed and then do that thing you just described?
00:06:52 <Walther> ah, if getline = y, loop
00:07:07 <leroux> Walther: Yeah.
00:07:24 <Walther> holy crap, even if I had to rethink that, it's *again* more logical in haskell than other languages
00:07:49 <leroux> Also, Walther, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#g:6
00:07:52 <Walther> compared to "if getline == n, break"
00:08:14 <Walther> or "while x ... if answer == n, x = 0"
00:08:24 <mm_freak_> dwcook: yeah, and if you know the module name, just import it and let GHC's error message tell you what version you have installed =)
00:08:25 <mm_freak_> just import Data.Map and let GHC complain that you need containers 0.whatever.0.0
00:08:58 <dwcook> mm_freak_, ah, good point, it actually did that and it totally slipped my mind. :)
00:09:15 <dwcook> "It is a member of the hidden package `containers-0.4.2.1'."
00:09:19 <mm_freak_> Walther: well, it's regular imperative programming, except that you don't get mutable variables or 'while' =)
00:09:50 <mm_freak_> Walther: in some cases Control.Monad does help, but mostly when doing imperative programming in haskell, i found good old recursion to be the simplest way to express loops
00:09:50 <Walther> mm_freak_: Mmh, but I like the idea of Haskell essentially forcing to write "good code"
00:10:09 <Walther> well, not "good" but *damn* readable
00:10:21 <mm_freak_> yeah
00:10:36 <mm_freak_> if x > 3 then return x else again
00:10:36 <mm_freak_> =)
00:10:42 <arcatan> once you get skilled enough, you can write really unreadable code!
00:10:57 <dwcook> main = forever $ putStrLn "Hello!" -- versus: while True: print "Hello!"
00:11:01 <Walther> arcatan: like in javascript? http://patriciopalladino.com/blog/2012/08/09/non-alphanumeric-javascript.html
00:11:12 <dwcook> (or forever (putStrLn "Hello!") if you're not familiar with ($) already)
00:11:13 <mm_freak_> main = putStrLn "Hello!" >> main
00:11:31 <mm_freak_> speaking of unreadable…
00:11:33 <dmj`> my friend had a javascript interview and they asked him what {} + [] was
00:11:38 <mm_freak_> main = fix (putStrLn "Hello!" >>)
00:11:43 <dwcook> \o/
00:11:50 <dwcook> It is a beautious line of code
00:12:02 <dwcook> hampered only by our feeble human comprehension
00:12:28 <mm_freak_> > filterM (const [False, True]) "abc"
00:12:29 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
00:12:37 <dwcook> (which is of course just a really nice way of saying "unreadable")
00:13:44 <mauke> dmj`: equivalent to ; ?
00:14:34 <Walther> I wonder how badly you could obfuscate a "just another haskell hacker" in three lines :P
00:14:48 <mauke> all code can be written in one line
00:15:07 <dwcook> @pl \x y z -> x + y * z
00:15:10 <lambdabot> flip ((.) . (.) . (+)) (*)
00:15:10 <lambdabot> optimization suspended, use @pl-resume to continue.
00:15:30 <dmj`> mauke: {} + [] == 0, {} + {} == NaN
00:15:48 <mauke> unlikely
00:15:52 <dmj`> [] + [] == ""
00:15:56 <mauke> {} + [] isn't an expression
00:15:57 <dwcook> dmj`, that's preassuming it's an expression rather than a statement
00:15:59 <mauke> it's two statements
00:16:04 <dmj`> [] + {} == "[object Object]"
00:16:13 <dwcook> It depends on what syntax production you start with
00:16:30 <shiona> dmj`: I see you have also watched wat
00:16:38 <dmj`> shiona: yep :)
00:16:47 <dmj`> dwcook: yes
00:17:14 <dwcook> s/statement/program/
00:18:24 <dwcook> If a package has four version numbers, what does each mean? I take it the first two are still major and minor?
00:19:46 <laar> @dwcook See http://www.haskell.org/haskellwiki/Package_versioning_policy
00:19:46 <lambdabot> Unknown command, try @list
00:19:53 <shiona> dmj`: my favourite work-blocker for this summer with javascript was isNaN("") == false && isNaN(toFloat("")) == true
00:19:56 <dwcook> Thanks
00:20:17 <Walther> mauke: the "three line" requirement predates to 'signatures' in forums/threads
00:20:18 <bartavelle> is "fix" actually something you use in day to day programming, or just something intellectually interesting ?
00:20:22 <Walther> it also has a fixed width
00:20:49 <mauke> the standard usenet signature limit is 4 lines of less than 80 characters
00:21:17 <dmj`> shiona: isNaN("") == false... sigh
00:21:52 <mbrock> i think we might actually have that exact bug in our product somewhere
00:22:00 <hpaste_> dmj pasted “Walther -> Guess the num” at http://lpaste.net/92103
00:22:13 <shiona> dmj`: yep
00:22:36 <mbrock> not really surprising, except that in javascript you expect surprises
00:23:19 <dwcook> I tend to do a combinator of know the rules well and avoid type coercion
00:23:22 <dwcook> s/combinator/combination/
00:23:43 <laar> bartavelle, not daily but sometimes it is useful. It is sometimes used in combination with "tying the knot"
00:23:47 <mm_freak_> > let s+n=zipWith($).cycle$replicate n id++[(++s).filter(>'9')]in unwords$"Buzz"+4$"Fizz"+2$show<$>[1..]
00:23:48 <lambdabot>   "1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Bu...
00:23:52 <mbrock> I never really know what types things have in our JS code
00:24:31 <shiona> same
00:24:33 <mbrock> strings and ints are interchangable and the code tends to work a lot with database ids stored in DOM elements
00:24:36 <mbrock> it's all pretty horrible
00:24:41 <bartavelle> laar : thanks
00:25:29 <dmj`> Walther: that's one way you can do re-entry logic. Or simulate a while loop. Write yourself a scheme in 48 hours has a monadic version of a while loop
00:25:42 <mm_freak_> bartavelle: in imperative programming sometimes this is a useful idiom:  fix $ \again -> …
00:25:57 <mm_freak_> main = fix $ \again -> putStrLn "Hello!" >> again
00:26:13 <bartavelle> what makes it different from forever ?
00:26:24 <mm_freak_> that it may not act like forever =)
00:26:28 <bartavelle> heh :)
00:26:41 <mm_freak_> fix $ \again -> x <- getLine; if x == "quit" then return () else again
00:26:58 <mm_freak_> + do
00:27:02 <bartavelle> then why not just :
00:27:10 <bartavelle> x <- getLine ; if x == "quit" then return () else main
00:27:18 <dmj`> please critique my code im dieing for feedback
00:27:26 <mm_freak_> because you might be in the middle of a larger do-block =)
00:27:32 <bartavelle> oic
00:27:47 <bartavelle> I'd just use a "let"
00:27:51 <mbrock> dmj`: missed your link
00:27:54 <dmj`> dying :)
00:28:02 <laar> bartavelle: It seems it can also be used to simplify some recursion, see http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion. Though I don't think I've used it that way.
00:28:07 <dmj`> http://lpaste.net/92103
00:28:12 <dmj`> mbrock ^
00:28:17 <dmj`> well, this code isn't really much
00:28:26 <mm_freak_> bartavelle: the point of fix is to avoid an extra name
00:28:33 <mm_freak_> with let you have to name the loop
00:29:32 <bartavelle> I can see that ... but on one side you have 2 lines, and perhaps an informative name (it will be "go" or something like that anyway), and on the other side a slightly more concise way of putting it
00:29:43 <bartavelle> I'll obviously use "fix" all the time now
00:29:48 <mbrock> dmj`: hey, it changes the number every time you guess! unfair!
00:29:58 <mbrock> :P
00:30:30 <haasn> Assuming I pick a seed for my StdGen from a truly random source, is there a nonzero chance of it generating me the first n digits of pi, for any n? Or is there some upwards limit of how “pseudo-random” the PRNG used can really be?
00:30:50 <dmj`> mbrock: ha :) can't make it too easy can we
00:30:55 <haasn> Assume for the sake of the argument that n doesn't exceed the periodic length of StdGen
00:30:58 <mbrock> dmj`: might be fun to try using randomRs
00:31:14 <bartavelle> haasn, for large n this is probably not true
00:31:16 <mbrock> dmj`: as a way of reducing IO within the game logic
00:31:31 <mbrock> dmj`: it gives you an infinite random list
00:31:49 <mm_freak_> bartavelle: for example i do this to generate two distinct prime numbers:  rndPrimes = do p <- fix $ \againP -> do { p <- getCandidate; if isPrime p then return p else againP };  fix $ \againQ -> do { q <- getCandidate; if q /= p && isPrime x then return (p, q) else againQ }
00:31:51 <bartavelle> now that was a useful sentence:)
00:32:38 <mm_freak_> haasn: the chance will converge to 0 in finite time as n grows
00:33:44 <dmj`> mbrock: sure, we could add a higher or lower option too
00:33:51 <mm_freak_> haasn: you can actually calculate the probability =)
00:34:02 <mm_freak_> StdGen is just a linear congruential generator AFAIK
00:34:54 <haasn> mm_freak_: I guess a better way to formulate that question would be “for any choice of output O, does there exist *some* seed x that will generate it?”
00:35:37 <bartavelle> you can probably have an informal information theoritic argument about this, and think of the seed as a compressed form of O
00:35:42 <Walther> What is the difference between Haskell and Literal Haskell?
00:35:57 <Walther> (Just curious as I found two separate options in Sublime's highlighter)
00:35:58 <bartavelle> Walther, in Haskell all variable names are one letter
00:36:16 <haasn> bartavelle: yes, good idea; StdGen is seeded from an Int which has a finite size on most platforms
00:36:32 <haasn> (or all I guess, thanks to Bounded)
00:36:38 <bartavelle> Walther, literate Haskell makes it easier to intermingle long comments with the code and generate something readable
00:36:41 <bartavelle> for example for a blog post
00:36:57 <bartavelle> I suppose it directly comes from this : http://en.wikipedia.org/wiki/Literate_programming
00:37:10 <arcatan> in Haskell, everything is code unless you prefix it with --. in literate Haskell, everything is comment unless you prefix it with >
00:38:05 <haasn> bartavelle: hmm; Assume I seed a StdGen from an Int and I produce a single Int
00:38:11 <Walther> arcatan: ahh now that is a better/more precise definition, thanks
00:38:38 <haasn> bartavelle: the moment I generate a second Int, my codomain will be significantly larger than my domain making it impossible to reverse the function
00:38:49 <hpaste_> dmj revised “Walther -> Guess the num”: “high/low randomRs” at http://lpaste.net/92103
00:39:16 <bartavelle> haasn, I don't know what a codomain is
00:39:17 <mbrock> it'd be nice to have the reversible String -> Int32 function
00:39:28 <haasn> bartavelle: f :: Int -> (Int, Int)  -- Int is the domain, (Int, Int) is the codomain
00:39:48 <bartavelle> what makes you think you can't reverse the function then ?
00:40:14 <mbrock> haasn you meant codomain significantly *smaller*, right
00:40:43 <haasn> assume I had g :: (Int, Int) -> Int -- such that f.g = id
00:40:57 <haasn> incorrect terminology on my part I think
00:41:02 <haasn> not ‘reverse’ but generate an isomorphism
00:41:07 <haasn> (at least in that direction)
00:41:13 <haasn> not sure how to describe it
00:41:13 <bartavelle> you do have g for several well know  PRNGs
00:41:25 <bartavelle> there are rainbow tables based techniques for PHP's rand
00:42:01 <haasn> bartavelle: but that doesn't satisfy f . g = id :: (Int, Int) -> (Int, Int)
00:42:56 <bartavelle> why not ? I don't think I am understanding well what you are saying
00:43:37 <haasn> let's consider a simpler case, Bool instead of Int; assume I had a PRNG that's seeded from a Bool and produces Bools
00:43:50 <haasn> f :: Bool -> (Bool, Bool) -- generates two random Bools, seeded from a single Bool
00:44:49 <bartavelle> well, given (True, False) you can decide if there is a "seed" for that or not, and what the seed is
00:45:22 <mbrock> but there are at least two pairs that have no seed
00:45:35 <bartavelle> yeah but you are looking for f . g = id
00:45:36 <haasn> yeah, but my assumed function ‘g’ such that ‘f.g = id’ would require there being a seed for every possible (Bool, Bool)
00:45:37 <bartavelle> not g . f
00:45:46 <bartavelle> ahh I got it the other way around
00:46:02 <haasn> ah then we are clear? :)
00:46:05 <bartavelle> yup
00:46:30 <bartavelle> but who would care about this ? it's getting the seed from the output that you should care about ;)
00:46:41 <mbrock> so there are at most 2^n different randomRs
00:49:58 <Walther> dmj`: On your number-guessing game, is it possible to replace the "take 10" with something like just "take" or just use it without take at all and rely on lazy evaluation, to get rid of the 10 chances restriction
00:50:31 <dmj`> :t take
00:50:33 <lambdabot> Int -> [a] -> [a]
00:51:04 <Walther> mmh, take returns a list
00:51:37 <Walther> > take $ [1..]
00:51:38 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
00:51:39 <lambdabot>              with actual type ...
00:52:41 <Walther> > a = take $ [1..]; fmap (+) a 1
00:52:42 <lambdabot>   <hint>:1:3: parse error on input `='
00:52:50 <Walther> > let a = take $ [1..]; fmap (+) a 1
00:52:51 <lambdabot>   <hint>:1:35:
00:52:51 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
00:52:54 <Walther> gah
00:52:57 <dmj`> Walter: yes, we can remove the take 10 and rely on lazy evaluation. The game will play until you correctly guess the number
00:53:13 <dmj`> take 3 [1..10]
00:53:13 <latermus1> hm
00:53:27 <dmj`> > take 3 [1..10]
00:53:28 <lambdabot>   [1,2,3]
00:53:28 <Walther> Hm, which part makes it break/quit on correct answer?
00:53:42 <Walther> ah, no >> loop xas
00:53:49 <Walther> xs*
00:54:01 <latermus1> drop 0 []
00:54:53 <dmj`> Walther: If the list is infinite, the base case [] will never get called. The only other place where evaluation breaks is the (_) case.
00:55:16 <Walther> dmj`: nod
00:55:31 <dmj`> or if you insert anything besides a number... it will crash
00:58:28 <dmj`> "all a combinator is, is a function that takes functions and returns other functions"
00:58:38 <dmj`> :t (.)
00:58:38 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:01:16 <arkeet> that sounds wrong. lots of things aren't functions
01:03:59 <dmj`> arkeet: lots of things aren't functions... yet are still combinators?
01:04:02 <mm_freak_> Walther: to add a pure part to your exercise, write a custom type for streams
01:04:16 <mm_freak_> data Stream a = …
01:04:20 <arkeet> dmj`: I'm disagreeing about the other two instances of "function" in your statement.
01:04:46 <arkeet> "a combinator is a function"
01:05:32 <mm_freak_> there are multiple conflicting definitions of combinator
01:05:40 <dmj`> arkeet: would you prefer higher-order function?
01:05:46 <arkeet> no
01:05:49 <mm_freak_> my favorite definition is:  a function without free variables
01:06:21 <Walther> mm_freak_: *whoosh* completely went over my head
01:06:37 <mm_freak_> Walther: what?  the stream type?
01:06:39 <dmj`> arkeet: can you give me a counter-example
01:07:24 <arkeet> dmj`: say, >>
01:08:00 <dmj`> arkeet: that would be a higher order function no?
01:08:07 <arkeet> :t (>>)
01:08:07 <lambdabot> Monad m => m a -> m b -> m b
01:08:13 <arkeet> I don't see any function types as arguments.
01:08:25 <arkeet> so no
01:09:08 <arkeet> it doesn't really matter.
01:09:10 <arkeet> a combinator is a thing.
01:10:08 <dmj`> Monadic instances are still functions right?
01:11:13 <arkeet> :t (>>) `asAppliedTo` Nothing
01:11:13 <lambdabot> Maybe a -> Maybe b -> Maybe b
01:11:15 <arkeet> I don't see any functions.
01:11:17 <mbrock> http://www.haskell.org/haskellwiki/Combinator
01:11:28 <mm_freak_> as said, there are multiple conflicting definitions of "combinator"
01:11:38 <mm_freak_> so your debate is pretty much meaningless =)
01:11:59 <dmj`> @def gg z k = do { x <- z; y <- k; return $ x + y }
01:12:01 <lambdabot>  Defined.
01:12:08 <dmj`> gg (Just 2) (Nothing)
01:12:13 <arkeet> (+) is a free variable there. =(
01:12:20 <arkeet> maybe.
01:12:26 <arkeet> so is return.
01:12:29 <arkeet> so is >>=
01:12:32 <arkeet> I dunno.
01:12:34 <dmj`> :t gg
01:12:35 <arkeet> (+) is a combinator.
01:12:35 <lambdabot> (Monad m, Num b) => m b -> m b -> m b
01:12:36 <mm_freak_> arkeet: (+) is not free there
01:12:46 <arkeet> everything is a combinator.
01:13:25 <mm_freak_> in this function (+) is free:  f x y = x + y :: Integer
01:13:34 <mm_freak_> in this function it's not:  f x y = x + y
01:13:54 <arkeet> ugh, fine =(
01:14:13 <arkeet> everything is free.
01:14:18 <arkeet> free for all.
01:14:24 <arkeet> all for none.
01:14:31 <mbrock> mm_freak_: hmm?
01:14:41 <dmj`> all for one, one for all
01:14:43 <mm_freak_> mbrock: ?
01:14:55 <dmj`> :)
01:14:57 <arkeet> mbrock: the latter takes a Num instance as a (hidden) argument, I think that's what he's saying.
01:15:29 <mbrock> hm, okay
01:15:36 <dmj`> The second meaning of "combinator" is a more informal sense referring to the combinator pattern, a style of organizing libraries centered around the idea of combining things
01:15:50 <dmj`> that's what i was thnkin hm
01:16:12 <dmj`> wikipedia: A combinator is a higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
01:16:53 <arkeet> that's the first meaning.
01:17:00 <Gracenotes> that might be in the context of combinator calculi, not practical usage
01:17:50 <mm_freak_> in combinator calculi "combinator" actually uses my earlier definition
01:18:03 <mm_freak_> everything is expressed in terms of a predefined set of supercombinators
01:18:42 <dmj`> supercombinators ay
01:19:19 <Gracenotes> the term supercombinators also overloads with the multi-arg graph nodes in Hughes/Turner's PL compilation research
01:21:13 <dmj`> arkeet: where is isApplied
01:21:16 <dmj`> To from
01:21:41 <dmj`> `asAppliedTo`
01:22:54 <mm_freak_> i'm actually quite fond of SKI calculus, both for writing compilers and for writing haskell programs =)
01:23:52 <arkeet> dmj`: in lambdabot
01:23:57 <Gracenotes> yes, that was miranda
01:24:00 <arkeet> :t asAppliedTo
01:24:01 <lambdabot> (a -> b) -> a -> a -> b
01:24:03 <arkeet> it's defined as const
01:24:13 <Gracenotes> like sasl etc. before it
01:24:32 <arkeet> :t let f `asappliedto` x = let _ = f x in f
01:24:33 <lambdabot> <no location info>:
01:24:34 <lambdabot>     not an expression: `let f `asappliedto` x = let _ = f x in f'
01:24:46 <arkeet> :t let f `asappliedto` x = (let _ = f x in ()) in f
01:24:46 <lambdabot> FromExpr a => a
01:24:49 <arkeet> oops.
01:24:58 <arkeet> :t let f `asappliedto` x = (let _ = f x in ()) in asappliedto
01:24:59 <lambdabot> (t1 -> t) -> t1 -> ()
01:25:02 <arkeet> oops.
01:25:08 <arkeet> :t let f `asappliedto` x = (let _ = f x in f) in asappliedto
01:25:08 <lambdabot> (t1 -> t) -> t1 -> t1 -> t
01:25:24 <arkeet> I am a confused person.
01:26:14 <mm_freak_> :t let asAppliedTo :: forall a b. (a -> b) -> a -> a -> b; asAppliedTo f = const f in asAppliedTo
01:26:15 <lambdabot> (a -> b) -> a -> a -> b
01:26:32 <mm_freak_> :t let asAppliedTo :: (a -> b) -> a -> a -> b; asAppliedTo f = const f in asAppliedTo
01:26:33 <lambdabot> (a -> b) -> a -> a -> b
01:27:44 <mm_freak_> :t pure :: (a -> b) -> a -> a -> b
01:27:45 <lambdabot> (a -> b) -> a -> a -> b
01:28:26 <dmj`> :t return
01:28:26 <lambdabot> Monad m => a -> m a
01:28:40 <dmj`> :t return :: (a -> b) -> a -> a -> b
01:28:41 <lambdabot> (a -> b) -> a -> a -> b
01:29:36 <quchen> Does GHCi have FlexibleInstances enabled by default? My program worked fine there, but GHC complained about the missing extension
01:29:47 <quchen> (It's not in my ghci.conf either)
01:31:19 <wojtekM_> Hello list. This is my secnod day of attempts to parse Java object Serialization Stream Protocol, http://docs.oracle.com/javase/7/docs/platform/serialization/spec/protocol.html, with Attoparsec. Now I'm stuck for good. No idea how to parse values, for which "the size and types are described by the classDesc for the current object". So, I need access to what has already been parsed. Do I have to switch to Parsec or yet another library?
01:32:22 <zq> is there an efficient method of resolving from which import a given function is defined?
01:32:25 <mm_freak_> quchen: no, but it may be enabled in your ~/.ghci
01:32:49 <quchen> mm_freak_: That's why I said it's not in my ghci.conf :-)
01:33:06 <mm_freak_> zq: if you have 16 imports, comment the first 8, see if it's still there, repeat with the remaining candidates
01:33:09 <mm_freak_> O(log n)
01:33:10 <quchen> (Neither ~/ghc/ghci.conf nor ./ghci.conf)
01:33:57 <mm_freak_> zq: jokes aside, load the module in GHCi, type :i f
01:35:04 <zq> hah
01:36:02 <mbrock> wojtekM_: note that Parser is an instance of Monad
01:36:54 <mbrock> wojtekM_: look at the type of (>>=) when the first argument is, say, Parser x
01:37:41 <mbrock> wojtekM_: you get (>>=) :: Parser x a -> (a -> Parser x b) -> Parser x b
01:38:11 <pharaun> i'm just being dense, but is there any good way of putting "func = Foo <$> something <*> something" into a list ?
01:38:13 <squimmy> i have a (possibly stupid) question again:
01:38:33 <mm_freak_> pharaun: into a list?
01:38:34 <pharaun> i could always do it in do notion and then return it inside a list but i'm wondering if there's a way to do it in applicative style?
01:38:42 <pharaun> mm_freak_: yeah as in a -> [a]
01:38:53 <mm_freak_> pharaun: what about sequence/sequenceA?
01:39:03 <mm_freak_> > sequence [sin, cos, tan] 3
01:39:05 <lambdabot>   [0.1411200080598672,-0.9899924966004454,-0.1425465430742778]
01:39:05 <squimmy> why does ghci give a parse error on ":t ->"
01:39:16 <mm_freak_> squimmy: try:  :k (->)
01:39:43 <mbrock> wojtekM_: so if you have (parseClassDesc :: Parser String ClassDesc) and (parseValue :: ClassDesc -> Parser String Value), you can combine those with (>>=)
01:39:51 <pharaun> mm_freak_: hm ParsecT isn't having any of it
01:39:59 <mm_freak_> pharaun: sequenceA is defined in Data.Traversable
01:41:36 <pharaun> yeah, i think i'm tripping up on the ParsecT type
01:41:42 <pharaun> cos its just not having it
01:41:47 <squimmy> mm_freak_: thanks! but... the defninition is recursive?!?
01:41:54 <mm_freak_> pharaun: ParsecT is certainly an Applicative =)
01:41:58 <mm_freak_> and that's all you need
01:42:01 <mm_freak_> :t sequenceA
01:42:02 <lambdabot>     Not in scope: `sequenceA'
01:42:02 <lambdabot>     Perhaps you meant one of these:
01:42:02 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
01:42:06 <mm_freak_> :t T.sequenceA
01:42:07 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
01:42:11 <pharaun> yeah i know i'm working on sequenceA
01:42:16 <pharaun> just grr
01:42:22 <mm_freak_> t = [], f = ParsecT x y z a b c
01:42:52 <mm_freak_> sequenceA :: (Applicative f) => [f a] -> f [a]
01:43:21 <mr-> squimmy: (the point is that (->) is a type, not a function)
01:43:38 <pharaun> mm_freak_: yeah i'm being wedged >_<
01:43:45 <pharaun> the type isn't working
01:44:00 <mm_freak_> > T.sequenceA [sin, cos, tan] 3
01:44:01 <lambdabot>   [0.1411200080598672,-0.9899924966004454,-0.1425465430742778]
01:44:15 <mm_freak_> > T.sequenceA (Just sin) 3
01:44:16 <lambdabot>   Just 0.1411200080598672
01:45:10 <mm_freak_> squimmy: you won't get a definition for (->) at all, because it's primitive =)
01:45:23 <mm_freak_> it is a type, as such it has a kind
01:45:26 <mm_freak_> :k asks for it
01:45:27 <lambdabot> Not in scope: type variable `asks'
01:45:28 <wojtekM_> mbrock: There are also references (by identifier) to class definitions that occured earlier in the stream
01:45:28 <lambdabot> Not in scope: type variable `for'
01:45:28 <lambdabot> Not in scope: type variable `it'
01:46:05 <squimmy> mm_freak_: it's confusing :/
01:46:21 <wojtekM_> mbrock: and also to objects that previously occured in the stream
01:46:31 <mm_freak_> squimmy: you probably got the answer * -> * -> *
01:46:57 <simukis_> Can you define something else in terms of `→`? something like `(») = → Integer →`?
01:47:21 <wojtekM_> well, for objects I can traverse the tree and replace the identifiers with objects
01:47:29 <hpaste_> pharaun pasted “sequenceA” at http://lpaste.net/92105
01:47:48 <squimmy> mm_freak_: yes! but... that doesn't explain much to me :(
01:47:49 <pharaun> mm_freak_: ^ i've tried several different way
01:47:55 <mm_freak_> squimmy: read "*" as "type"
01:47:58 <pharaun> but its all giving me various form of type issues
01:48:06 <mm_freak_> squimmy: (->) takes two types as arguments and is itself a type
01:48:09 <mm_freak_> try :k Maybe
01:48:35 <mm_freak_> Maybe :: * -> *, Maybe is a type that takes a type as argument
01:48:39 <mm_freak_> Maybe Int, for example
01:49:28 <mm_freak_> pharaun: yes, that one whats ParsecT to be a Traversable, which it obviously isn't
01:49:32 <mm_freak_> compare:
01:49:42 <mm_freak_> > T.sequenceA [sin] 3
01:49:44 <lambdabot>   [0.1411200080598672]
01:49:46 <mm_freak_> > T.sequenceA sin 3
01:49:48 <lambdabot>   No instance for (Data.Traversable.Traversable ((->) (a1 -> a0)))
01:49:48 <lambdabot>    arising...
01:50:02 <pharaun> yeah but if i put the karmacandidate and the whole thing into a list
01:50:06 <pharaun> it falls apart
01:50:17 <squimmy> mm_freak_: ah. i.. i think i get it now
01:50:19 <squimmy> thank you!
01:50:48 <mm_freak_> pharaun: the way you wrote it you don't need sequenceA
01:50:55 <mbrock> wojtekM_: are you familiar with the do notation?
01:50:57 <mm_freak_> i thought you had a list of parsers that you want to sequence
01:51:01 <pharaun> nah
01:51:01 <simukis_> :k a -> a
01:51:02 <lambdabot> Not in scope: type variable `a'
01:51:02 <lambdabot> Not in scope: type variable `a'
01:51:09 <pharaun> i just want to take this thing and *put* it into a list :)
01:51:18 <mm_freak_> pharaun: fmap?
01:51:21 <pharaun> without having to do... do notation or other chunky stuff
01:51:31 <mm_freak_> pharaun: pure . KarmaCandidate
01:51:33 <simukis_> :k Integer -> Integer
01:51:33 <lambdabot> *
01:51:38 <mm_freak_> instead of just KarmaCandidate
01:51:40 <mbrock> wojtekM_: not that you need it, but it can make such things easier and more readable
01:51:44 <mm_freak_> pure :: a -> [a]
01:51:53 <mm_freak_> wait
01:52:00 <mm_freak_> (pure .) . KarmaCandidate
01:52:08 <mm_freak_> or:  fmap pure $ KarmaCandidate <$> …
01:52:24 <pharaun> its that second dot that kept on screwing with me
01:52:29 <pharaun> (sorry really tired) :)
01:52:42 <mm_freak_> pharaun: but why would you do that anyway?
01:52:48 <mm_freak_> putting it in a list seems arbitrary
01:52:58 <pharaun> cuz i have a list of several parser
01:53:01 <mbrock> wojtekM_: in principle there's no problem, but you might find Parsec more convenient
01:53:06 <pharaun> and couple do return a list of result, couple don't
01:53:15 <wojtekM_> mbrock: I'm familiar with do notation, yes
01:53:27 <pharaun> and i'm doing a big choice [try parse, try parse2] at the end
01:53:37 <mm_freak_> pharaun: then fmap at the call site instead
01:53:54 <wojtekM_> mbrock: still, I'm perplexed how to access what has already been parsed
01:54:13 <mm_freak_> pharaun: fmap concat . sequence $ [parser1, parser2, fmap pure parser3, parser4, …]
01:54:16 <pharaun> mm_freak_: http://lpaste.net/92106 <- here?
01:54:48 <mm_freak_> pharaun: yeah, fmap there
01:55:01 <mm_freak_> try (fmap pure …)
01:55:17 <pharaun> ok i like that solution lots better
01:55:19 <pharaun> thanks mm_freak_ :)
01:55:26 <mm_freak_> that's cleaner than arbitrarily wrapping a result in some data structure
01:55:32 <pharaun> yup
01:55:33 <pharaun> it is
01:55:51 <pharaun> i forgot the pure call, oops
01:56:07 <mm_freak_> application =)
01:56:09 <pharaun> anyway this is much better, thanks!
01:56:19 <pharaun> haha yeah i don't do applicative style very much
01:56:26 <pharaun> so i was playing with this some more to work on that
01:56:34 <mm_freak_> for some reason "call" feels wrong in haskell =)
01:57:23 <pharaun> call, ha yeah yeah, i'm just tired so i'm going all fuzzy sorry
01:57:29 <pharaun> application is better name for what happens
01:57:35 <mm_freak_> get some sleep ;)
01:57:43 <Twey> Hahah
01:57:46 <pharaun> soon, it just annoys me when something isn't working before bed
01:57:53 <pharaun> i need to stop working on code before bed >_>
01:58:06 <mm_freak_> i know the feeling
01:58:07 <Twey> I was going to say that about ‘call’, but I thought it would be just too pedantic
01:58:21 <pharaun> nah you're right its better to be more precise
01:58:24 <mbrock> wojtekM_: with Parsec you can do your parsing within a State monad, which probably makes sense if your parsing is quite stateful
01:58:48 <Twey> pharaun: I usually find I think better in bed than in front of the editor :þ
01:59:15 <pharaun> haha! that is also true
01:59:31 <pharaun> well i'm like this > < close to getting this whole thing to work nicely so gah
02:01:24 <wojtekM_> mbrock: I'm strongly suspecting that this is what I need. Any Parsec stateful parsing example/tutorial?
02:03:57 <mbrock> wojtekM_: oh, I guess all Parsec parsers already have a "user state"
02:04:10 <pharaun> mm_freak_: however i ended up needing sequenceA later anyway so... that was a win for pointing that one out anyway :)
02:04:42 <pharaun> and now wow this code is really tidy now
02:04:46 <mbrock> wojtekM_: see {getState, putState, modifyState} in the Parsec docs
02:04:54 <mm_freak_> pharaun: note that there is also sequence, if the Monad constraint doesn't bother you
02:05:03 <pharaun> yup i saw
02:05:35 <Twey> It's annoying that find and lookup return Maybe instead of a list or something.
02:05:58 <mbrock> wojtekM_: that means all your parsers (and "subparsers") can access and modify your user state -- which might contain a Map Int ClassDesc and so on
02:06:02 <pharaun> can't you do the Maybe a -> [a] function Twey ?
02:06:04 <Twey> Or a generic MonadPlus.
02:06:21 <pharaun> s/do/use/
02:06:25 <Twey> pharaun: That's not the point: it can only return one result, even if there are multiple matches
02:06:34 <pharaun> ah
02:06:45 <pharaun> yeaaah
02:06:53 <pharaun> iirc i've used ixset for that
02:06:54 <arkeet> > toList (Just 1)
02:06:55 <lambdabot>   Not in scope: `toList'
02:06:56 <lambdabot>  Perhaps you meant one of these:
02:06:56 <lambdabot>    `F.toList' (impo...
02:06:58 <arkeet> > F.toList (Just 1)
02:07:00 <lambdabot>   [1]
02:07:43 <Twey> This is the third time in a week I've defined lookupMany ∷ (Eq k, MonadPlus m) ⇒ k → [(k, v)] → m v   or something like it
02:08:24 <Twey> arkeet: What's F?
02:08:31 <arkeet> Data.Foldable
02:08:34 <Twey> Ah
02:08:52 <Twey> That's also useful to have
02:09:02 <arkeet> so is lens
02:09:53 <ocharles> Twey: hmm, you could weaken that to (Eq k, Alternative f) => k -> [(k, v)] -> f v, I think
02:10:47 <arkeet> (Eq k, Alternative f, Foldable t) => k -> t (k, v) -> f v
02:11:02 <ocharles> Or that
02:11:03 <donri> Map k (Set v) ? :p
02:11:23 <mbrock> wojtekM_: here's a page with some examples http://www.vex.net/~trebla/haskell/parsec-generally.xhtml
02:11:45 <Twey> donri: Sometimes you just want a list :þ
02:12:05 <Twey> But yes, some kind of multimap-like typeclass might be the answer
02:12:11 <arkeet> > [(1,a),(1,b),(2,c)] ^.. folded . filtered ((== 1) . fst) . _2
02:12:13 <lambdabot>   [a,b]
02:12:25 <pharaun> why not submit the lookupMany to the owner of Data.List or what so not
02:12:27 <pharaun> seems useful
02:12:36 <arkeet> I'm sure there's a better lens way to do this.
02:13:21 <Twey> arkeet: Nice
02:13:36 <Twey> I should get used to using lens
02:13:46 <arkeet> > [(1,'a'),(1,b),(2,c)] ^.. folded . filtered ((== 1) . fst) . _2
02:13:47 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
02:13:47 <lambdabot>              with actual type...
02:13:48 <arkeet> er
02:13:52 <pharaun> arkeet: oh whoa lens
02:13:52 <arkeet> I should finish typing before pressing enter.
02:13:59 <Twey> Heh
02:14:01 <pharaun> i should set aside some time to play with that
02:14:08 <arkeet> > [(1,'a'),(1,'b'),(2,'c')] & traverse . filtered ((== 1) . fst) . _2 %~ toUpper
02:14:10 <lambdabot>   [(1,'A'),(1,'B'),(2,'c')]
02:14:30 <donri> i want a filtered _1 (== 1) combinator
02:14:37 <arkeet> me too!
02:14:43 <donri> i keep running into that
02:14:57 <arkeet> all it makes sense to use is a getter though.
02:14:59 <arkeet> which is really a function.
02:15:02 <ocharles> I think that (== 1) thing can be done with 'only'
02:15:26 <arkeet> ocharles: not on _1 though.
02:15:28 <ocharles> _1.only 1
02:15:31 <ocharles> no?
02:15:46 <arkeet> _1 isn't supposed to be in the lens chain.
02:16:14 <ocharles> what do you mean by "isn't supposed to be"? It doesn't compose, or it's not safe to compose it?
02:16:15 <arkeet> hmm.
02:16:30 <arkeet> I mean it's passed as an argument to another lens thing.
02:16:36 <arkeet> it's not in the composition chain itself.
02:16:38 <haasn> what are we doing?
02:16:43 <arkeet> uh.
02:16:46 <arkeet> I dunno.
02:16:57 <ocharles> haasn: with lens?
02:16:58 <pharaun> i give up, ni ni yah all :)
02:16:58 <donri> arkeet: it might only need a getter but it could use a lens/fold/traversal as a getter no problem?
02:17:10 <arkeet> let me think.
02:17:14 <wojtekM_> mbrock: Thank you. Now I'm about to find out if Attoparsec API is much different from Parsec API :-)
02:17:29 <arkeet> donri: of course.
02:17:35 <ocharles> arkeet: sure, but 'has' can view that prism as a bool
02:17:37 <arkeet> yeah, good point.
02:17:37 <haasn> MultiSet.fromList [(1,a), (1,b), (2,c)]^..ix 1
02:17:41 <haasn> this?
02:17:45 <mbrock> wojtekM_: :) shouldn't be too bad
02:18:05 <donri> ocharles: i think has only tells you that it has a Field1, not its value?
02:18:58 <ocharles> filtered (has (_1 . only 1))
02:18:59 <ocharles> but ix is probably more where we want to be looking :)
02:19:07 <arkeet> fair enough.
02:19:38 <arkeet> well, we can't give [(k,v)] an Ixed isntance.
02:19:39 <donri> sure that works
02:19:46 <arkeet> since it would overlap with the instance for [a]
02:20:01 <arkeet> newtypes can fix that though, I guess.
02:20:15 <arkeet> hm, I should have gone to bed hours ago. bye =)
02:20:25 <haasn> arkeet: oh, wait a minute
02:20:31 <arkeet> make it quick
02:20:34 <donri> i doubt Twey wants to newtype his list
02:20:34 <ocharles> donri: 'has (_1 . only x)' works as you'd expect
02:20:48 <donri> ocharles: yeah. i thought you were trying to do it without 'filtered'
02:20:59 <haasn> arkeet: with an Iso wrapped for the newtype we could do something like xs ^.. foo.ix 1 -- ?
02:21:02 <ocharles> oh, no - filtered (has (_1 . only x))
02:21:03 <haasn> where foo is the wrapper
02:21:05 <arkeet> I guess.
02:21:15 <haasn> oh, “wait a minute” as in “I just got an idea”. Don't let me keep you up :)
02:21:18 <arkeet> ok
02:21:19 <arkeet> :)
02:21:25 <arkeet> that should work though.
02:21:42 <haasn> ‘keyed’?
02:22:28 <donri> if you do an iso just to make an indexed instance why not just make an indexed traversal separately
02:22:55 <donri> ...at which point we're back to "i defined lookupMany thrice this week" :p
02:23:11 <ocharles> :P
02:23:30 <Twey> Heh
02:23:50 <arkeet> donri: but then you can get it included in lens :p
02:23:57 <donri> :)
02:24:03 <arkeet> and then wait for the next hackage release.
02:24:05 <arkeet> and then go to bed.
02:24:07 <arkeet> o/
02:24:11 <Twey> \o
02:30:39 <donri> Twey: so how did you define it anyway? list comp?
02:31:35 <Twey> donri: findMany . (==) :þ
02:31:52 <donri> :t findMany
02:31:53 <lambdabot>     Not in scope: `findMany'
02:31:53 <lambdabot>     Perhaps you meant one of these:
02:31:53 <lambdabot>       `IM.findMax' (imported from Data.IntMap),
02:31:57 <donri> @hoogle findMany
02:31:57 <lambdabot> No results found
02:31:58 <donri> :(
02:33:17 <Twey> Oh, findMany is filter.  D'oh.
02:33:47 <Twey> Yeah, list comprehension seems clearest
02:34:34 <donri> :t filter . (==)
02:34:35 <lambdabot> Eq a => a -> [a] -> [a]
03:04:37 <Jeanne-Kamikaze> given two functions (a -> b -> c) and (a -> b), is it possible to compose them in a function (a -> c) using point-free style, i.e. without referring to the a?
03:05:50 <haasn> > [(1,"foo"), (2,"bar"), (1,"bat")] ^.. traverse.itraversed.index 1 -- arkeet, donri
03:05:51 <lambdabot>   Couldn't match type `GHC.Types.Int'
03:05:51 <lambdabot>                with `p0 [GHC.Types.Char...
03:05:55 <haasn> huh
03:06:10 <haasn> works in my GHCi instance
03:06:27 <ocharles> you can itraverse into a tuple?
03:06:30 <haasn> ocharles: yes
03:06:38 <Jeanne-Kamikaze> like, f :: a -> b -> c, g :: a -> b, h a = f a (g a), but I want to write that with no 'a'
03:06:40 <haasn> it has a TraversableWithIndex k ((,) k)
03:06:41 <ocharles> any tuple, or just pairs?
03:06:47 <haasn> pairs only it seems
03:06:53 <pentace> @pl \f g x -> \x -> f x (g x)
03:06:53 <lambdabot> (const .) . ap
03:06:53 <ocharles> good to know though
03:07:23 <haasn> λ  [(1,'a'),(1,'b'),(2,'c')] & traverse.itraversed.index 1 %~ toUpper
03:07:25 <haasn> [(1,'A'),(1,'B'),(2,'c')]
03:07:39 <haasn> looks like the Assoc newtype is unneeded :)
03:07:44 <haasn> a good trick to have, either way
03:08:12 <Hafydd> \ 1
03:08:33 <Jeanne-Kamikaze> pentace, I'm not sure I get it ?
03:08:58 <Jeanne-Kamikaze> what's @pl by the way ?
03:09:12 <pentace> it makes an expression pointless
03:11:08 <haasn> @ask edwardk do we want some kind of combinator like assoc = traverse.itraversed :: IndexedTraversal k [(k,a)] [(k,b)] -- eg. lookup k xs = xs ^? assoc.index k
03:11:08 <lambdabot> Consider it noted.
03:11:28 * haasn has really got to stop using the word ‘combinator’ to mean ‘function’
03:11:45 <haasn> or ‘lens’, or anything at all, really
03:11:50 <ocharles> stop using words, haasn !
03:12:25 <pentace> Jeanne-Kamikaze: Do you understand the pointfree version?
03:13:01 <ReinH> Jeanne-Kamikaze: it's possible to make it pointfree but it's not necessarily better
03:13:03 <Jeanne-Kamikaze> I would need to refresh myself on the monad instance of ((->) r)
03:13:11 <Jeanne-Kamikaze> yeah, I figured that :P
03:13:47 <pentace> :t ap `asAppliedTo` (undefined :: a -> b -> c)
03:13:48 <lambdabot> (a -> b -> c) -> (a -> b) -> a -> c
03:14:00 <ReinH> pentace: asAppliedTo?
03:14:29 <pentace> It's usefull for type specialization
03:14:49 <ReinH> pentace: where does it come from?
03:14:50 <Jeanne-Kamikaze> oh, but that's exactly what I wanted
03:15:15 <pentace> ReinH: I've wondered myself, I think it's lambdabot only
03:15:53 <pentace> @src asAppliedTo
03:15:53 <lambdabot> Source not found. The more you drive -- the dumber you get.
03:16:03 <ReinH> magic
03:16:10 <haasn> asAppliedTo = const
03:16:24 <ReinH> oh
03:16:30 <ReinH> not very magical
03:16:32 <ReinH> ;)
03:17:03 <pentace> but it's type is more special
03:17:04 <ReinH> type inference is still magical though
03:17:09 <pentace> :t asAppliedTo
03:17:10 <lambdabot> (a -> b) -> a -> a -> b
03:17:10 <haasn> (asAppliedTo, asTypeIn, asTypeOf) = (const, const, const) -- :)
03:17:18 <ReinH> haasn: huh.
03:17:38 <haasn> they're all const
03:18:28 <Hafydd> :t (asAppliedTo, asTypeIn, asTypeOf)
03:18:29 <lambdabot> ((a -> b) -> a -> a -> b, a1 -> (a1 -> b1) -> a1, a2 -> a2 -> a2)
03:18:50 <haasn> :t (const, const, const) `asTypeOf` (asAppliedTo, asTypeIn, asTypeOf)
03:18:50 <lambdabot> ((b -> b2) -> b -> b -> b2, a -> (a -> b3) -> a, b1 -> b1 -> b1)
03:21:57 <Zenol> Bonjour
03:22:45 <Hafydd> Salut.
03:30:12 <Zenol> how would you rewrite this case test : http://lpaste.net/92107 ? I think one can do something shorter with a Maybe monad or something like that.
03:33:40 <donri> Zenol: perhaps with the Maybe Alternative or First Monoid
03:33:50 <donri> don't think the Monad will help a lot there
03:36:09 <Zenol> donri: First sounds well. I'll try with it :)
03:36:20 <donri> lookup "showLines" xs <|> (lookup "startFrom" xs *> pure "1") <|> if "numberLines" `elem` classes then pure "1" else empty
03:37:33 * Zenol doesn't like to use if
03:38:58 <donri> ya i wish there was a bool :: a -> a -> Bool -> a in the prelude
03:40:33 <Zenol> donri: I don't think it would solve my issue with if :) When I wrote if stuff I often exchange the then and else cases.
03:41:02 <donri> Zenol: so slap a not on the condition? :)
03:41:03 <Zenol> Don't know why, but I don't do this mistake with 'case' (pobably because right before the lighe the value True or False is written).
03:41:20 <donri> oh as a mistake
03:42:36 <donri> but you can put a case in there anyway, the main point was <|>
03:42:44 <Zenol> I would like something like a -> [a] -> Maybe a
03:43:03 <donri> what would that do?
03:43:06 <Zenol> So that I can "cons "1"" =<< (somethng) :p
03:43:26 <Zenol> A kind of Maybe `elem`.
03:43:43 <donri> find?
03:43:44 <donri> :t find
03:43:44 <lambdabot> (a -> Bool) -> [a] -> Maybe a
03:43:55 <haasn> isn't there some combinator to combine two Folds into a single fold that folds both sides?
03:44:19 <Zenol> (cons "1" =<< ("numberLines"==) `find` classes ? :)
03:44:45 <donri> :t \x -> find (== x)
03:44:46 <lambdabot> Eq a => a -> [a] -> Maybe a
03:45:59 <Zenol> @hoogle (<|>)
03:45:59 <donri> "1" <$ find (== "numberLines") classes
03:45:59 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
03:45:59 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
03:45:59 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
03:46:24 <Zenol> oh, Control.Applicative, not Control.Alternative x)
03:46:25 <donri> :t "1" <$ find (== "numberLines") []
03:46:26 <lambdabot> Maybe [Char]
03:46:49 <donri> should do the same as that if
03:47:30 <Zenol> Ah, <$, :D
03:47:39 <donri> @src <$
03:47:39 <lambdabot> (<$) = (<$>) . const
03:48:43 <donri> it's the same as fmap (const "1")
03:50:01 <ocharles> donri: semantically, yes
03:50:08 <ocharles> but may be more efficient for some functors
04:04:12 <haasn> @edwardk do we have something like merge a b f = liftA2 (<>) (x f) (y f) :: Fold s a -> Fold s a -> Fold s a -- merge _head (_tail.folded) = folded
04:04:12 <lambdabot> Unknown command, try @list
04:04:15 <haasn> @ask edwardk do we have something like merge a b f = liftA2 (<>) (x f) (y f) :: Fold s a -> Fold s a -> Fold s a -- merge _head (_tail.folded) = folded
04:04:15 <lambdabot> Consider it noted.
04:04:36 <haasn> oh, but with a/b and x/y fixed
04:05:17 <mbrock> i wonder how many % of haskellers' mental effort goes to searching for pithy expressions of small utility functions
04:05:27 <mbrock> (:
04:07:13 <mbrock> it'd be fun to have a site where you can put up like "golfing" challenges
04:07:34 <mbrock> like a paste site that quickchecks extensional equality of revisions
04:08:24 <mbrock> with a bunch of neato gamification stuff
04:09:05 <mbrock> i even have a great name for it: pointless
04:10:06 <Zenol> mbrock: hey, you have the name! set up the site :D
04:10:20 <jmcarthur> you're like 90% of the way there already
04:10:42 <Sonderblade> can't the haskell compiler itself golf trivial code?
04:11:01 <mbrock> i need to think of a way to bootstrap it
04:11:05 <haasn> if the haskell compiler started golfing code we'd be all out of our jobs
04:11:30 <mbrock> so the site's code itself is maximally golfed and pointfree from the outset
04:11:50 <Zenol> hassn: Our job would be limited to write types, no? Isn't it the dream of some computer scientist?
04:12:13 <jmcarthur> i'm not actually sure my dream is to write specifications all day
04:14:30 <Zenol> @djinn [a] -> (a, [a])
04:14:30 <lambdabot> Error: Undefined type []
04:15:10 <Zenol> @djinn [a] -> [a]
04:15:10 <lambdabot> Error: Undefined type []
04:15:14 <Zenol> :(
04:15:22 <Zenol> @djinn a -> a
04:15:22 <lambdabot> f a = a
04:15:27 <Zenol> @djinn Int -> Int
04:15:27 <lambdabot> Error: Undefined type Int
04:16:02 <Zenol> @djinn (Monad m) => m (m a) -> m a
04:16:02 <lambdabot> -- f cannot be realized.
04:16:24 <mbrock> i think djinn basically only knows type variables, functions and tuples?
04:16:55 <Zenol> @djinn (Monoid a) => b -> a
04:16:55 <lambdabot> Error: Class not found: Monoid
04:17:50 <mbrock> @djinn Maybe (Maybe a) -> Maybe a
04:17:50 <lambdabot> f a =
04:17:50 <lambdabot>     case a of
04:17:50 <lambdabot>     Nothing -> Nothing
04:17:52 <lambdabot>     Just b -> b
04:17:54 <Zenol> @let import Data.Monoid
04:17:55 <lambdabot>  Defined.
04:17:58 <Zenol> @djinn (Monoid a) => b -> a
04:17:58 <lambdabot> Error: Class not found: Monoid
04:18:08 <Zenol> Damnit :(
04:18:23 <byorgey> djinn is a first-order-logic theorem prover, disguised as a Haskell code generator.
04:18:54 <Zenol> byorgey> He doesn't know about Monoid? :(
04:19:05 <mbrock> http://www.augustsson.net/Darcs/Djinn/verbose-help
04:19:35 <byorgey> but yeah, I suppose there's no reason it couldn't just treat type classes as a set of extra axioms to assume
04:19:57 <mbrock> @djinn :environment
04:19:57 <lambdabot> Invalid command
04:22:00 <Zenol> pretty sad, I was just asking for "cons mempty" :(
04:41:39 <Zenol> I really need something like "haskellman Arrow" :/
04:42:37 <zomg> Zenol: like, a google search? ;)
04:43:03 <Zenol> zomg: google search is bad, he find old hackage packages, not the last one.
04:43:43 <zomg> you can always click "content" from the corner and then choose the latest version from the list on the index page :)
04:43:47 <Zenol> zomg: More like hoogle, browsing the package installed in your machine, and displaying the haddock documentation as a nice man page.
04:44:04 <zomg> true, that could be convenient
04:44:20 <Zenol> zomg: Yes, but it takes time. That's why I prefer "man 3 printf" instead of google + "man printf" + click click click.
04:45:23 <ocharles> Zenol: I think you can incorporate hoogle into GHCI
04:45:23 <Zenol> I'm pretty sure most of the tool are already writen. Just need to pipe haddock, panddoc, and hoogle through scripts.
04:46:11 <ocharles> https://www.youtube.com/watch?v=QpDQhGYPqkU - Zenol
04:46:11 <ocharles> might help
04:47:13 <ocharles> see 5:15
04:48:38 <Zenol> ocharles: But hoogle don't give you the documentation of the function :)
04:48:59 <Zenol> ocharles: manpages does (but don't allow you search by type, right).
04:54:35 <Zenol> :o, looks like you can check the doc with :doc through hoogle.
04:55:05 <ocharles> yes
04:55:08 <ocharles> that's why I said 5:15 :)
04:56:34 <Zenol> 5:15? I saw it at 13:00
04:57:07 <Zenol> Oh, you'r right, also 5:15.
04:57:44 <Zenol> But it's missing colors and data constructor. (You have to import and then type :info)
05:00:31 <Zenol> ocharles: thanks :)
05:02:47 <teneen> what's the difference between DoRec and RecursiveDo?
05:04:45 <teneen> Are they both the same?
05:05:47 <donri> i think dorec is deprecated and moved into recursivedo
05:06:03 <donri> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#recursive-do-notation
05:07:53 <teneen> ok so DoRec was just the name of RecursiveDo in previous ghc versions
05:08:45 <donri> well mdo and "do rec" used to be separate extensions, RecursiveDo now provides both
05:09:10 <teneen> ok, I see
05:10:22 <donri> "The mdo keyword has been reintroduced. This keyword can be used to create do expressions with recursive bindings. The behavior of the rec keyword has been changed, so that it does not perform automatic segmentation in a do expression anymore."
05:10:31 <donri> http://www.haskell.org/ghc/docs/latest/html/users_guide/release-7-6-1.html
05:13:07 <donri> IIRC RecursiveDo used to provide mdo and got deprecated in favor of DoRec, then DoRec got deprecated and both merged into un-deprecated RecursiveDo
05:13:25 <donri> don't rely on extensions to be very stable and back-compat ;)
05:21:38 <bennofs> How do i debug a segmentation fault in haskell?
05:22:36 <bennofs> Or better, a internal error: PAP object entered! message?
05:22:56 <edwardk> bennofs: that is usually something going horribly wrong. i'd hunt for the unsafeCoerce ;)
05:23:24 <bennofs> edwardk: It works fine with GHC 7.6, but fails in 7.4 :/
05:23:36 <edwardk> ugh
05:23:42 <bennofs> (I'm using no unsafeCoerces in my code, only lens)
05:23:55 <edwardk> now you have me concerned. how big of a snippet is it?
05:24:11 <bennofs> It's pretty big. I might try to simplify it
05:24:31 <edwardk> if you can get it down to a smallish test case, _please_ throw an issue at github.com/ekmett/lens/issues
05:25:06 <edwardk> can you try to cabal install lens -fsafe and see if you still get the issue?
05:26:35 <bennofs> I'll try it in a cabal sandbox
05:30:02 <haasn> (does zippers exist yet?)
05:30:04 <haasn> @hackage zippers
05:30:31 <haasn> lambdabot?
05:31:17 <edwardk> haasn: not yet the release of the separate zippers package is happening with lens 3.10
05:31:26 <edwardk> that got held up by the introduction of Roles into GHC 7.7
05:31:32 <edwardk> so we need to fix all the template haskell we generate
05:31:34 <haasn> is it on github?
05:31:37 <haasn> oh ok
05:31:37 <edwardk> yes
05:31:41 <Zenol> haasn: Not zippers, but zipper (http://hackage.haskell.org/package/zipper)
05:31:42 <edwardk> github.com/ekmett/zippers
05:31:45 <lambdabot> http://hackage.haskell.org/package/zippers
05:31:55 <haasn> Zenol: yuck :)
05:32:12 <edwardk> well, there is that thing, but blech =)
05:32:54 <edwardk> with the zippers package i want to have 3 sets of zippers: a basic list zipper, lens 3.8 style zippers and lens 3.9 style indexed zippers.
05:33:23 <edwardk> the 3.8 zippers were easier to understand, but couldn't handle some infinite cases
05:33:34 <edwardk> the 3.9 lenses are more powerful but the types offputting, even to me
05:34:04 <donri> ooh -fdefer-type-errors with hdevtools in vim is amazing
05:34:52 <merijn> donri: How so?
05:34:57 <edwardk> donri: yeah that sounds like exactly what defer-type-errors is for
05:35:09 <edwardk> merijn: you don't have to get the program to a compiling state to get some type info out of it
05:35:12 <ocharles> donri: hmm, I haven't used hdevtools
05:35:18 <ocharles> is that like ghc-mod?
05:35:22 <edwardk> it just has a parse
05:35:25 <donri> merijn: i can inspect inferred types of [sub-]expressions in incomplete and illtyped programs
05:35:26 <merijn> edwardk: oh, right
05:35:39 <merijn> edwardk: But then it won't highlight compile errors anymore, will it?
05:35:40 <ocharles> but yea, defer-type-errors is awesome for prototyping
05:36:02 <edwardk> yeah i guess that depends on how you use the tool
05:36:15 <donri> and particularly nice that it lets me use deferred type errors without putting it in .cabal or manually passing the flag in
05:36:38 <edwardk> donri: how?
05:36:47 <donri> ocharles: it's basically ghc-mod as a bg proc
05:37:24 <donri> edwardk:   let g:hdevtools_options = '-g-O0 -g-fno-code -g-fdefer-type-errors'
05:37:33 <edwardk> donri: ah
05:37:43 <ocharles> donri: oh, it's that one!
05:37:45 <donri> (but you might not want -fno-code since it means no TH is type checked by it)
05:37:56 <ocharles> i should install that
05:38:05 <ocharles> donri: is your vim setup available anywhere?
05:38:07 <donri> https://github.com/bitc/vim-hdevtools
05:38:12 <donri> ocharles: not currently
05:38:27 <donri> i think i'm gonna rewrite my vimrc for the fifth-or-so time
05:38:39 <donri> also in the process of rewriting vim2hs from scratch
05:38:42 <donri> gah
05:39:29 <ocharles> donri: is vim2hs yours?
05:39:35 <donri> yes
05:39:40 <ocharles> it's great :)
05:39:47 <donri> not great enough
05:39:55 <ocharles> heh
05:40:14 <ocharles> i've only started using it recently. the folding is a bit buggy but it otherwise works nicely
05:40:27 <donri> merijn: syntastic still works with hdevtools and -fdefer-type-errors
05:40:42 <merijn> donri: oh, cool
05:41:10 <edwardk> one of these days i'll have to improve my development environmnt beyond raw vim ;)
05:41:23 <donri> since it will still show the errors as warnings, and syntastic also shows warnings
05:42:01 <ocharles> I need to get syntastic setup
05:42:12 <_emm_> I have to say that of all the languages I have tried from vim, Haskell has given me the best experience
05:42:12 <ocharles> but at the moment because I use nixos, ghc-mod and such fail to call ghc properly
05:42:15 <donri> i wish vim-hdevtools did :GhcModExpand though
05:42:23 <donri> ghc-mod is slower and requires compiling vimproc
05:42:24 <ocharles> donri: do you know if syntastic uses ghc-mod or calls the current $PATH ghc?
05:42:33 <_emm_> the only thing painful is export/import lists
05:42:41 <dalaing1> I'm liking my current vim setup for haskell, but I'm wondering whether I should start bracing for getting set up with emacs again for when I start playing with coq and agda
05:43:01 <donri> ocharles: syntastic uses ghc-mod, hdevtools and hlint, depending on your setup
05:43:09 <ocharles> ok
05:43:39 <ocharles> so that's not going to work without a little fiddling :) but I need to get ghc-mod working in nixos anyway
05:43:46 <donri> i don't know what the defaults are, i think it just includes them all in alphabetical order and only runs the ones whose exe is installed
05:43:51 <dalaing1> I think I'm using hdevtools and ghc-mod, partly to get GhcModExpand
05:44:03 <dalaing1> I should work out what I've actually got set up at some point
05:45:25 <donri> can't wait for addons using -XTypeHoles in interesting ways... although I worry a bit that the new named holes introduce ambiguity that could mask name errors, so it seems problematic to leave always-on for something like hdevtools...
05:45:55 <ocharles> I really want TypeHoles
05:46:01 <ocharles> so much that I even tried to get GHC HEAD to build
05:46:05 <donri> _foo is either the identifier _foo *or* a named hole
05:46:17 <donri> i'd rather have a clunkier syntax and no ambiguity :/
05:47:21 <donri> i guess the worst thing that happens is you get hole information instead of a "not in scope" error, but it still bugs me :p
05:47:23 <bennofs> donri: Does that mean that nearly all lens code clashes?
05:47:45 <bennofs> i.e. data SomeDataType = S { _field1 :: Blah } clashes?
05:48:08 <donri> bennofs: yeah, sort of. it means you can't do a named hole _field1 if that field is in scope
05:48:22 <donri> no biggie per se but i don't like the ambiguity :/
05:48:29 <edwardk> in practice i don't see that being too much of a problem
05:48:48 <donri> the worse side is if you typo _feild1 when you didn't want a hole
05:49:39 <ocharles> i dunno, I can imagine wanting a hole _1 quite a lot
05:49:45 <ocharles> because that's an easy go-to hole name
05:50:01 <donri> _ is a valid unnamed hole though
05:50:02 <ocharles> or can you use _ for un-named holes?
05:50:04 <ocharles> ah, good
05:50:08 <donri> with no ambiguity
05:50:14 <donri> and you can have multiple holes with the same/no name
05:50:20 <ocharles> i will probably only be working with one hole at a time
05:50:25 <donri> _ + _ will give you two hole errors
05:50:33 <ocharles> "working one hole at a time" really doesn't read well.
05:51:10 <donri> yeah i don't imagine named holes being used *that* often so i don't feel the syntax needs to be minimized
05:51:25 <donri> but haskell syntax is a lost cause
05:51:33 <donri> it's insane all over
05:52:17 <_emm_> donri: as opposed to Scala? :)
05:53:07 <donri> ...but maybe i'm not imaginative, maybe named holes are killer for prototyping. write a whole code base full of named holes, etc
05:53:21 <ocharles> a lost cause?
05:53:32 <donri> _emm_: i don't know scala
05:54:28 <donri> ocharles: speaking as someone who tries to write useful syntax highlighting / code folding etc. haskell's syntax is so liberal it's nigh impossible
05:55:48 <merijn> donri: Word.
05:55:53 <_emm_> donri: it has about the same regularity as Perl
05:55:56 <donri> data declarations look exactly like function definitions if you don't special case the data keyword
05:56:03 <merijn> donri: Especially if you have to do it using vim regexes
05:56:06 <donri> did i say function definitions, no haskell doesn't have function definitions
05:56:12 <donri> it has pattern matching in the top level
05:56:25 <merijn> donri: Share my pain! :)
05:56:29 <donri> :)
05:56:46 <merijn> donri: Those are actually the easy bits
05:56:55 <donri> hah yeah
05:57:06 <donri> haskell has multiple inter-mixed namespaces
05:57:21 <donri> try to highlight something as a type, no, you can't really tell what's a type or something else
05:57:35 <merijn> How do you indent if you encounter "blah <- if b; then foo; else bar" do you indent the then/else to line up with if or just a one block indent?
05:57:39 <_emm_> donri: but data types have to start with an uppercase letter too
05:57:42 <bennofs> Think of DataKinds
05:57:57 <donri> _emm_: those are values, not types
05:58:05 <simukis_> merijn: if it is short enough to fit in a line I leave it that way.
05:58:12 <donri> datakinds is fun too yes, more ambiguity
05:58:24 <donri> which is resolved with a prefix single quote
05:58:32 <bennofs> and KindSignatures
05:58:34 <donri> which in turn is ambiguous with template haskell quoting
05:58:35 <merijn> simukis_: That remark was in relation to donri's complaints about dealing with haskell syntax
05:58:35 <_emm_> (on the other hand, Perl managed pretty well to "namespace" different kind of notions with $, @ and %)
05:58:42 <simukis_> oh
05:59:01 <bennofs> KindSignatures + PolyKinds makes even haskell-src-exts fail afair
05:59:07 <donri> heh
05:59:37 <simukis_> can we declare haskell's syntax to be parseable by human brain easier than by the computer?
06:00:22 <donri> lol not sure about that even, we just rely on stuff to type check ;)
06:02:30 <donri> merijn: re indent i think maybe what we actually want is "stepped indents" where say Tab steps between valid indentation "points"
06:02:40 <donri> emacs apparently had this since forever
06:04:04 <merijn> donri: Yes, thought about that too
06:04:19 <merijn> but computing proper points is non-trivial too and I haven't invested the time into fixing it
06:04:26 <donri> true
06:04:34 <merijn> donri: If you solve it before me I'll just ditch my own attempts and steal your stuff :p
06:04:39 <donri> :)
06:06:13 <donri> would be nice to port chrisdone's structured haskell mode to vim
06:10:22 <_emm_> donri: what does it do?
06:10:34 <bgamari> When do writes to TChans block?
06:11:30 <donri> _emm_: it's like paredit for haskell. parses surroundings on the fly with haskell-src-exts and lets you edit the text source as a syntax tree
06:11:57 <donri> _emm_: https://www.youtube.com/user/ChristopherDone/videos
06:12:11 <merijn> bgamari: They shouldn't
06:12:27 <bgamari> merijn, That's what I thought
06:12:28 <bgamari> hmm
06:12:56 <merijn> They might retry if there's contention on the TChan, I guess
06:13:17 <bgamari> I seem to have some interaction between STM and the IO manager
06:14:04 <bgamari> reading from a file handle appears to block despite having data available until I try reading something from my TChan
06:14:21 <bgamari> unfortunately this involves the FFI so who knows what magic is involved
06:14:47 <merijn> bgamari: How are you reading from the file handle?
06:15:24 <bgamari> merijn, With the usb package
06:15:24 <bgamari> http://hackage.haskell.org/package/usb
06:15:47 <bgamari> so there's some libusb magic involved at very least
06:20:36 <danilo2> Hi! :) is it possible somehow in Parsec to get the erros to a variable and not pront them to the screen?
06:22:13 <fryguybob> bgamari: Which particular functions from usb are you using?
06:22:31 <bartavelle> danilo2, "parse" should get you an Iether ParserError a, you can then use this
06:22:36 <bartavelle> Either
06:23:02 <danilo2> bartavelle - ah so it must be done there someghow (I was using runParserT) - ok I'll look into it.
06:23:19 <danilo2> bartavelle: Btw I've managed to fix the problem we were tolking yesterday about :)
06:23:29 <bartavelle> ah, cool !
06:23:42 <danilo2> bartavelle: I'm not using ident parser - I've created my custom parsers to manage the indentations and it works great :)
06:24:37 <bartavelle> runParserT also gets you an Either BTW
06:26:06 <bgamari> merijn, fryguybob, found one issue: I disabled data output in my hardware
06:26:26 <bgamari> Unfortunately there is still strangeness, this time pertaining to OpenGL
06:26:43 <bgamari> but I need to poke around a bit more before I can ask any reasonable questions
06:27:03 <bgamari> the USB side seems to be working fine, however
06:27:11 <fryguybob> bgamari: Ok
06:27:47 <Zenol> Anyone knows if I can find a  Int -> ListNumberStyle -> String in pandoc ? (hoogle doesn't seams to have all the pandoc types/functions)
06:29:47 <bgamari> too much imperative code!
06:33:38 <Zenol> ok, how is named the function which does f 5  = "V" ? x)
06:34:28 <Zenol> seams there isn't any package, http://www.haskell.org/haskellwiki/Roman_numerals
06:36:36 <geekosaur> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:roman%20package%3Aroman-numerals
06:37:19 <donri> well http://hackage.haskell.org/packages/archive/roman-numerals/0.5.1.2/doc/html/Text-Numeral-Roman.html
06:38:49 <mbrock> it's a little funny when we use state-of-the-art functional programming techniques to implement the conventions of ancient Rome
06:41:29 <haasn> is there some parFold :: Monoid a => [a] -> a -- that builds up a tree and does log n parallel reduction steps?
06:42:37 <Zenol> gekkosaur, donri: Thanks :D
06:45:18 <bergmark> i wish Roman was the author of that package
06:45:37 <haasn> perhaps parFoldChunks :: Monoid a => Int -> [a] -> a -- that lets me choose the granularity
06:45:52 <donri> bergmark: no he's the author of roman's-numerals
06:46:24 <Zenol> hu, and know I wan't some kind of fromBasis "123456" 7 = 11 :s
06:49:56 <Zenol> wait, it's not supported by those perl scripts...
06:50:22 <Zenol> hum, I'm wrong, they are.
06:53:41 <haasn> Zenol: fromBasis?
06:57:30 <Zenol> @hoogle fromBasis
06:57:30 <lambdabot> No results found
06:57:49 <Zenol> @hoogle Int -> String -> String
06:57:50 <lambdabot> Test.QuickCheck.Text number :: Int -> String -> String
06:57:50 <lambdabot> Test.QuickCheck.Text short :: Int -> String -> String
06:57:50 <lambdabot> Prelude drop :: Int -> [a] -> [a]
06:58:58 <quchen> let fromBasis base = foldl' (\acc x -> base*acc + x) 0 in fromBasis 2 [1,0,1,0]
06:59:01 <quchen> > let fromBasis base = foldl' (\acc x -> base*acc + x) 0 in fromBasis 2 [1,0,1,0]
06:59:02 <lambdabot>   10
06:59:06 <danilo2> bartavelle: ah I was using 'forceEither' - thats the reason I get the results printed. heh :)
07:00:42 <Zenol> oh, it's not "fromBasis" but "toBasis"
07:01:57 <Zenol> and I means f "123456" 7 = "11", sorry.
07:02:57 <bennofs> @hoogle showIntAtBase
07:02:58 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
07:03:09 <Sculptor> hello
07:04:21 <bennofs> > "123456" ^? base 7
07:04:23 <lambdabot>   Just 22875
07:05:23 <donri> > "123456" ^? to (base 7)
07:05:24 <lambdabot>   Couldn't match type `f0 a0' with `GHC.Types.Char'
07:05:24 <lambdabot>  Expected type: Control.L...
07:05:43 <Zenol> bennofs: Is that some lens magic? :)
07:05:55 <Zenol> bennofs: anyway, thanks for showIntAtBase :)
07:07:14 <bennofs> Zenol: yes it's lens
07:07:27 <bennofs> > base 7 # 123456 -- Other direction
07:07:28 <lambdabot>   "1022634"
07:08:11 <Zenol> > base 26 # 18
07:08:13 <lambdabot>   "i"
07:08:22 <Zenol> > base 26 # 27
07:08:24 <lambdabot>   "11"
07:08:36 <Zenol> Hum, not exactly what I want :/
07:09:07 <Zenol> it's for generating alpha numbered lists.
07:10:09 <bennofs> Zenol: What do you mean by alpha numbered lists? A, B, C, D, ... ?
07:10:22 <Zenol> bennofs: yes.
07:10:24 <bennofs> > ['A' .. 'Z']
07:10:25 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
07:10:29 <bennofs> > ['A' .. 'Z'] !! 1
07:10:31 <lambdabot>   'B'
07:10:33 <bennofs> > ['A' .. 'Z'] !! 4
07:10:34 <lambdabot>   'E'
07:10:50 <bennofs> and what should 27 be then? AA?
07:11:37 <Zenol> bennofs: Exactly. But I don't have to build the list in memory. I just want the "alpha number" from a "decimal number".
07:12:11 <Zenol> I have to make some <ol> list begin from the right "number".
07:12:55 <Zenol> showIntAtBase 26 (\n -> [A..Z] !! n) n ? :)
07:13:51 <bennofs> > let f x = toEnum (fromEnum 'A' + succ x) in [f 1, f 10]
07:13:52 <lambdabot>   [*Exception: Prelude.Enum.().toEnum: bad argument
07:14:03 <bennofs> :O
07:14:11 <bennofs> > let f x = toEnum (fromEnum 'A' + succ x) in [f 1, f 10] :: [Char]
07:14:12 <lambdabot>   "CL"
07:14:20 <bennofs> > let f x = toEnum (fromEnum 'A' + pred x) in [f 1, f 10] :: [Char]
07:14:22 <lambdabot>   "AJ"
07:15:21 <Zenol> I wonder what happen if someone write some fonyly long numbers :p
07:15:32 <bennofs> > let f x = toEnum (fromEnum 'A' + pred x) in map (f . read . pure) $ show "12131312312312313123"
07:15:33 <lambdabot>   [*Exception: Prelude.read: no parse
07:15:52 <bennofs> what
07:16:29 <bennofs> > let f (x :: Int) = toEnum (fromEnum 'A' + pred x) in map (f . read . (:[])) $ show "12131312312312313123"
07:16:30 <lambdabot>   [*Exception: Prelude.read: no parse
07:16:48 <bennofs> > read "1" :: Int
07:16:49 <lambdabot>   1
07:17:25 <bennofs> > let f (x :: Int) = toEnum (fromEnum 'A' + pred x) in concatMap (f . read . (:[])) $ show 12131312312312313123
07:17:26 <lambdabot>   No instance for (GHC.Show.Show b0)
07:17:26 <lambdabot>    arising from a use of `M933419760.sho...
07:18:05 <bennofs> Hmm sorry for the spam
07:18:21 <bennofs> > let f (x :: Int) = toEnum (fromEnum 'A' + pred x) in map (f . read . (:[])) $ show 12131312312312313123 :: String
07:18:22 <lambdabot>   "ABACACABCABCABCACABC"
07:18:32 <bennofs> Zenol: ^^ I that what you want?
07:18:59 <bennofs> Ah, I guess not
07:19:25 <Zenol> > let showAlpha n = showIntAtBase 26 (\n -> ['A' .. 'Z'] !! n) (n - 1) ""
07:19:26 <lambdabot>   not an expression: `let showAlpha n = showIntAtBase 26 (\n -> ['A' .. 'Z'] ...
07:19:30 <Zenol> @let showAlpha n = showIntAtBase 26 (\n -> ['A' .. 'Z'] !! n) (n - 1) ""
07:19:32 <lambdabot>  Defined.
07:19:35 <Zenol> > showAlpha 1
07:19:41 <lambdabot>   "A"
07:19:43 <Zenol> > showAlpha 27
07:19:46 <lambdabot>   "BA"
07:19:52 <Zenol> Arg, fail.
07:20:15 <bennofs> @ty showIntAtBase
07:20:36 <bscarlet> :t showIntAtBase
07:22:56 <Zenol> I want : 1 = A, 26 = Z, 27 = AA, 28 = AB, etc.
07:24:44 <quchen> That's not a good idea because the grammar isn't prefix-free, in other words "AAA" could be "A A A" or "A AA" or "AA A".
07:27:10 <bscarlet> quchen: I'm missing some context. Why should Zenol want that property?
07:27:31 <Zenol> quchen: ah, your right. Don't now what's the behavior when you use <ol type="a"> on html. Anyway, it seams that what I'm doing is useless, since those perl scripts at the end can't handle changing the starting value of a list....
07:27:32 <quchen> bscarlet: Well if you encode a number it should be unambiguous
07:27:55 <quchen> bscarlet: That's a good idea regardless of context :-P
07:28:57 <nooodl> how is it ambiguous? AAA is AAA. it's what comes between ZZ and AAB
07:29:05 <bscarlet> quchen: I would have thought any list of strings without duplicates provided an unambiguous encoding.
07:29:40 <quchen> Oh, I thought "A" and "B" and "AA" would be the *digits*, not the numbers.
07:30:06 <kier> Does SYB provide a top-down variant of everywhereM?
07:30:10 <bscarlet> quchen: I don't know. That's the context I was asking about, I guess.
07:30:17 <nooodl> > concat $ [replicateM n ['A'..'Z'] | n <- [1..]]
07:30:19 <lambdabot>   ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S...
07:30:26 <nooodl> ^ this is the list you want Zenol
07:30:26 * Zenol did the same mistake as quchen
07:31:05 <bscarlet> > concat $ [ replicateM n ['A'..'C'] | n <- [1..]]
07:31:07 <lambdabot>   ["A","B","C","AA","AB","AC","BA","BB","BC","CA","CB","CC","AAA","AAB","AAC"...
07:32:09 <Zenol> > (concat $ [ replicateM n ['A'..'C'] | n <- [1..]]) !! 500
07:32:12 <lambdabot>   "ABCAAC"
07:32:21 <Zenol> works well :) thanks.
07:33:01 <bscarlet> Zenol: Is it okay that it's takes linear time in the number?
07:34:11 <Zenol> bscarlet: Actualy, it looks like I won't have to use any of this stuff (including toRoman) XD. But it would have been ok, since it's a script to convert Markdown into some ugly XML format :)
07:34:35 <nicoo> bscarlet: I don't think it's possible to have sub-linear access, using lists (even doing fancy tricks with lazyness)
07:34:36 <kier> > [1..] >>= flip replicateM ['A' .. 'C']
07:34:38 <lambdabot>   ["A","B","C","AA","AB","AC","BA","BB","BC","CA","CB","CC","AAA","AAB","AAC"...
07:35:14 <bscarlet> nicoo: I was thinking about an approach that didn't use the list.
07:36:22 <nooodl> if you index from the same list each time won't it get "memoized"?
07:36:27 <Zenol> I'm pretty sure one could find an O(log n) way, but it's like killing flys with a hammer :)
07:39:19 <nicoo> Zenol: And it might not even be efficient, if one accesses range [n..n+k] with k >> n
07:43:05 <augur> anyone really familiar with iteratees wanna read something for me?
07:44:52 <blast_hardcheese> Not sure who in here was helping me earlier, but he recommended I come here. Thanks friend!
07:45:54 <merijn> nooodl: Only if by memoised you mean "the list is only computed once"
07:46:09 <merijn> nooodl: You still have to walk the list O(n) when you access
07:46:14 <nooodl> oh yeah
07:48:01 <hpaste_> bigstones pasted “type inference” at http://lpaste.net/92110
07:48:07 <bigstones> Hi all, I have a question about type inference, a function in particular (I'm learning)
07:48:34 <merijn> bigstones: Oh, that's a silly ghci-ism
07:48:49 <merijn> bigstones: Together with the dread monomorphism restriction
07:48:51 <merijn> @where dmr
07:48:52 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
07:48:57 <merijn> bigstones: Read that :)
07:49:10 <bigstones> thank you, I will
07:51:27 <Zenol> Haskell is the only language where when you wrote 100 lines, you can say it was a hard day.
07:51:34 <WraithM> lol
07:51:41 <Zenol> s/only language/only language I know
07:52:40 <donri> Zenol: you should try agda
07:52:46 <ocharles> good luck getting to 10
07:53:15 <donri> good luck *inputting* a single line of code ;)
07:54:58 <bennofs> Writing 100 lines of code is not difficult. But getting them to compile is a different story :p
07:55:50 <deggis> if a piece of text doesn't compile, what does it require for it to be called code?
07:55:57 <haasn> Zenol: haskell is the only language where I routinely spend a few hours slowly expanding some file to about ~100 lines before hitting a breaking point and spending the second half of my time reducing it in size, eventually reducing it to 3 lines of lens code
07:56:20 <RevJohnnyHealey> deggis: a new compiler
07:56:41 <deggis> RevJohnnyHealey: aye
07:57:42 <kier> > [1..] >>= flip replicateM ['A' .. 'C']
07:57:47 <kier> argh not again
07:58:03 <lambdabot>   ["A","B","C","AA","AB","AC","BA","BB","BC","CA","CB","CC","AAA","AAB","AAC"...
08:12:35 <notdan> @pf \k f -> f k
08:12:35 <lambdabot> Maybe you meant: pl bf
08:12:42 <notdan> @pl \k f -> f k
08:12:43 <lambdabot> flip id
08:13:15 <notdan> @pl \k f -> k f
08:13:15 <lambdabot> id
08:15:43 <McManiaC> are there any statistics on how often hackage packages are being used/downloaded?
08:18:31 <nu11s37> Hello everyone
08:18:39 <bergmark> .o/
08:18:41 <RevJohnnyHealey> Hello you.
08:18:41 <nu11s37> I have decided to learn Haskell
08:19:02 <nu11s37> Is "Learn you a Haskell" a good resource
08:19:02 <kryft> A good decision
08:19:06 <kryft> Yes
08:19:12 <bergmark> nu11s37: i've heard it is
08:19:35 <nu11s37> I am reading it online
08:20:35 <nu11s37> I am using ubuntu. Do I need just the GHC package ?
08:21:06 <nu11s37> Downloading
08:21:08 <nu11s37> yay!
08:21:32 <bergmark> nu11s37: i think everyone will recommend haskell-platform
08:21:32 <nu11s37> I had decided to learn lisp
08:21:36 <kryft> nu11s37: I'm not sure, but I think you want the haskell-platform package (I don't use ubuntu)
08:22:43 <nu11s37> lol I was thinking asking about ghc was a stupid question
08:22:46 <nu11s37> turns out it was not
08:23:11 <nu11s37> Haskell platform installs ghc and other packages
08:24:01 <nu11s37> So I had decided to learn lisp and in the book there was a personality test. It showed a wolf, a sheep and a wolf in sheep clothing
08:24:24 <nu11s37> and it asked to choose. I chose wolf in sheep clothing.
08:24:57 <jonh> nu11s37: good story!
08:25:07 <nu11s37> The results were : If you chose wolf you should learn common lisp. If you choose sheep you should learn scheme
08:25:19 <nu11s37> and for wolf in sheep clothing learn haskell
08:26:04 <donri> and implement scheme in haskell?
08:26:56 <donri> @google write yourself a scheme
08:26:57 <lambdabot> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
08:26:57 <lambdabot> Title: Write Yourself a Scheme in 48 Hours - Wikibooks, open books for an open world
08:27:14 <nu11s37> bergmark, How do I get a vhost ?
08:27:28 <bergmark> donri: that tutorial is awful for beginners...
08:27:31 <bergmark> nu11s37: what?
08:27:43 <nu11s37> atmat.net
08:27:44 <donri> i don't know, haven't read it
08:27:51 <nu11s37> something like that
08:27:55 <nu11s37> virtual host
08:28:08 <nu11s37> There is no hostserv
08:28:20 <bergmark> ah, you need a CNAME record for your domain name
08:28:26 <bergmark> i'm using www.tilaa.com
08:28:32 <haasn> I think Haskell is like a sheep in wolf's clothing
08:29:22 <t7> haskell is a lazy person that doesnt clean up after itself
08:29:27 <bergmark> donri: i started out with it with a friend :) lotsa confusion
08:29:30 <t7> well it does clean up every once in a while
08:30:12 <donri> haskell will do what you ask, in "just a seq"
08:30:27 <t7> very good :)
08:31:47 * nu11s37 is away: dinner
09:00:00 * hackagebot swish 0.9.0.5 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.5 (DouglasBurke)
09:03:02 <Clint> is there a way to make a generic acid-state dumping function?
09:03:53 <flebron> Hi. Why am I getting a stack overflow in this short function? http://ideone.com/QThUqI . I would assume foldl' makes it so I'm only doing some multiplications.
09:05:35 <haasn> try making the fields of the tuple strict; foldl' won't do much if you're just forcing the (,) constructor
09:05:54 <flebron> How does one do that?
09:06:10 <flebron> #(Integer, Integer)?
09:06:14 <haasn> well eg. by adding bang patterns f (!x, !ans)
09:06:52 <flebron> ah, cool :) thanks!
09:06:55 <haasn> or just: x `seq` ans `seq` ...
09:11:26 <danharaj> is there a way to reload ghci without erasing all my stuff I defined in the repl?
09:16:16 <monochrom> no
09:17:52 <danharaj> sucks :\
09:19:20 <smith_> danharaj: I've been thinking of writing a sort of scratchpad, where you type in some statements and then when you reload it reruns them all
09:19:37 <danharaj> smith_++
09:19:47 <danharaj> I'm sure it's 'trivial' in emacs.
09:19:52 <danharaj> trivial meaning the nontrivial part is emacs.
09:21:58 <smith_> Well luckily I have the weekend to work on it, so I'll get to it later today.
09:22:34 <hvr> smith_: something like ':cmd readFile "/tmp/scratchpad.txt"' does something like that laready
09:26:53 <dagano> > (+) <$> [1,2,3] <*> [3,4,5]
09:26:54 <lambdabot>   [4,5,6,5,6,7,6,7,8]
09:27:06 <dagano> can anyone give me the intuition why <*> creates combinations
09:27:16 <dagano> <$> is fmap .. making a list of partial functions
09:27:24 <dagano> but i don't get applicative
09:27:28 <danharaj> :t (<*>)
09:27:28 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:28:09 <danharaj> :t (,) <$> [1..]
09:28:10 <lambdabot> (Enum a, Num a) => [b -> (a, b)]
09:28:20 <danharaj> :t (,) <$> [1..] <*> [1..]
09:28:21 <lambdabot> (Enum a1, Enum a, Num a1, Num a) => [(a1, a)]
09:28:30 <danharaj> > (,) <$> [1..] <*> [1..]
09:28:31 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
09:28:52 <danharaj> > (,) <$> [1..3] <*> [1..3]
09:28:53 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
09:29:24 <danharaj> > ($ "ponies") <$> (,) <$> [1..3]
09:29:26 <lambdabot>   [(1,"ponies"),(2,"ponies"),(3,"ponies")]
09:29:44 <danharaj> dagano: I would suggest just playing around with it.
09:34:53 <dagano> danharaj: ($ "thanks") print
09:36:21 <levi> danharaj: Lambdabot keeps a scratchpad like that.
09:39:34 <sellout-> Ok, package B depends on package A. I export an additional name in a module in package A, rebuild/install it with cabal, but when I then rebuild package B, it says “Not in scope” about my new name. I feel like I’ve run into and figured this out before, but I can’t remember.
09:40:01 * hackagebot richreports 0.0.0.2 - Integrated pretty-printing and error/static analysis reporting.  http://hackage.haskell.org/package/richreports-0.0.0.2 (AndreiLapets)
09:47:01 <jeffy_poo> is 'look at my johnson' here?
09:47:18 --- mode: ChanServ set +o geekosaur
09:47:48 <adnap> :t cos
09:48:01 <adnap> @hoogle cos
09:48:22 <lambdabot> Floating a => a -> a
09:48:22 <lambdabot> Prelude cos :: Floating a => a -> a
09:48:22 <lambdabot> Prelude cosh :: Floating a => a -> a
09:48:22 <lambdabot> Prelude acos :: Floating a => a -> a
09:49:13 <nu11s37> biack
09:50:32 <danilo2> Hi! What testing framework is currently the "bset" in haskell? Should I use HUnit, QuickCheck or something else?
09:51:10 <geekosaur> define "best". QuickCheck and HUnit fill different roles
09:52:18 <danilo2> Ok, so I'm writing a compiler - I want to have a parser test framework, which would be simple and powerfull. I want to be able to fast change the testing cases and rules. So the main goal is simplicity and easy of use and maintain.
09:52:34 <danilo2> But if you could tell more about both of them (the differences etc) I would be very thanful :)
09:54:55 <geekosaur> HUnit is, aa the same suggests, a unit testing framework; you write the unit tests. QuickCheck, given rules to generate random values for a specified type, generates tests based on the type of a function "on the fly" in order to try to probe corner cases (fuzz testing)
09:55:03 <geekosaur> both can be useful
09:55:54 <danilo2> geekosaur: ahh I see - I'm currentlu looking for unit-testing framework, so H-Unit is the only one I should check?
09:56:29 <geekosaur> there are a few others; I just described the two you mentioned. "tasty" is a new test framework that was just introduced and is still evolving a bit, for example
09:56:42 <zomg> I've been hanging on the internet far too long because H-unit made me think of something completely different than Haskell :P
09:56:53 --- mode: geekosaur set -o geekosaur
09:57:29 <bergmark> danilo2: hunit, quickcheck, hspec
09:57:47 <geekosaur> smallcheck
09:57:49 <bergmark> and tasty to combine them
09:57:50 <danilo2> @geekosaur, bergmark: Thank you, could you recommend one, which would you choose to test your programms in general?
09:57:51 <lambdabot> Unknown command, try @list
09:57:59 <bergmark> danilo2: it depends on what kind of testing you are doing
09:58:55 <bergmark> it can be nice to have quickcheck tests and when you get a failure you convert that instance to hunit since quickcheck doesn't guarantee that it will always test for exactly that
09:59:22 <geekosaur> and as bergmark said, tasty is more a way to unify the different kinds of tests represented by quickcheck, smallcheck, hunit, etc. into a single test framework
09:59:43 <bergmark> danilo2: i'm also interested in golden (it's for comparing output written to files)
09:59:58 <danilo2> brmark: I want to unit-test my parser - So there would be some inputs strings and it will check the outputs.
10:00:11 <bergmark> danilo2: that's what golden is for
10:00:57 <danilo2> berkmark: But I dont write anything to files - I simply parse input strings (written as multiline strings in haskell) with expected results (written also in haskell as nested structures)
10:01:14 <bergmark> for instance, in fay have tests that go from haskell source to javascript, then we run nodejs on that and compare the output from node to a file
10:01:24 <bergmark> danilo2: ok then you should not use golden :)
10:01:35 <bergmark> hunit is probably good for that case
10:01:46 <danilo2> berkmark: Ok thank you :D So I'll stick with HUnit :)
10:04:02 <bergmark> tasty is good for running tests also, even if you just use one of the backends, i assume it can test in parallell like test-framework
10:04:52 <sellout-> Has no one else encountered the issue I’m running into? (“not in scope” when exporting a new name from a dependency)
10:05:39 <danilo2> berkmark: Ok thank you again :) I\m looking into tasty also :)
10:05:46 <sellout-> Oh *facepalm* this Haskell file is being generated, but no header indicating that it shouldn’t be edited.
10:06:10 <enthropy> sellout-: maybe you have multiple versions of package A installed
10:06:40 <sellout-> enthropy: No, it’s that the file I edited got overwritten during the build, so it’s really _not_ exporting the name I wanted it to.
10:10:40 <sellout-> Ok, edited the file generator, so now it prefixes the file with a “DON'T EDIT THIS” warning. Hopefully will prevent me from making this mistake again.
10:10:42 <Zenol> did I said that pandoc is awesome?
10:11:55 <Zenol> because it's __eavily__ awesome! It parse all the ugly latex I wrote perfectly, including \lstinline and other packages.
10:15:33 <jfischoff> if I get a duplicate instance error, is there a way to tell where they were defined?
10:15:51 <bergmark> i thought the error message stated that
10:16:24 <jfischoff> heh
10:16:32 <jfischoff> maybe it did :p
10:33:24 <DMcGill> is it safe to call the CFloat constructor on any old Float? Alternative question: what's the best way to turn an arbitrary Float into a GLfloat or CFloat? The other way I've come up with is `fromRational . toRational'
10:39:55 <enthropy> > fromRational . toRational $ (1/0) :: CFloat
10:39:56 <lambdabot>   Not in scope: type constructor or class `CFloat'
10:39:56 <lambdabot>  Perhaps you meant `Float'...
10:40:42 <enthropy> DMcGill: going through Rational is slower, and won't preserve values like NaN that don't exist for Rational
10:42:35 <RichyB> DMcGill, the Haskell 2010 Language Report explicitly states that CFloat is a newtype on Float.
10:42:57 <enthropy> uncurry encodeFloat . decodeFloat -- another option
10:43:08 <Igloo> RichyB: Where does it say that?
10:43:11 <DMcGill> newtypes are usually used when you don't want to mix the two up, or when it's dangerous. Is that the case here?
10:43:35 <DMcGill> if there's no difference between a Float and CFloat, why the newtype?
10:43:37 <RichyB> In practice you can write a Haskell program that produces absolutely any Float value that's there in IEEE 754.
10:43:53 <pentace> What about realToFrac?
10:44:22 <RichyB> Igloo, http://www.haskell.org/onlinereport/haskell2010/haskellch28.html#x36-27400028.1.3
10:46:24 <Igloo> Hmm, that's from teh library docs. I'm not sure if it was intended to say that in the standard
10:47:09 <DMcGill> realToFrac seems easiest
10:48:25 <glguy> > realToFrac (0/0 :: Float) :: Float
10:48:27 <lambdabot>   -Infinity
10:48:49 <glguy> > 0/0
10:48:50 <lambdabot>   NaN
10:49:27 <RichyB> Igloo, it's chapter 28 of the 2010 Haskell language report. :P
10:50:12 <Igloo> Yeah, but the last load of chapters are just the haddock library docs
10:50:30 <DMcGill> well until corner cases like that bite me glguy I'm just going to continue to ignore them :)
10:51:35 <pentace> @src realToFrac
10:51:35 <lambdabot> realToFrac = fromRational . toRational
10:51:41 <pentace> hah
10:52:59 <Sonarpulse> does anybody know if/when http://ghc.haskell.org/trac/ghc/wiki/LightweightConcurrency is supposed to become standard?
10:55:03 * hackagebot fay 0.16.0.3 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.16.0.3 (AdamBergmark)
10:55:05 * hackagebot ghci-ng 7.6.3.4 - Extended GHCi fork  http://hackage.haskell.org/package/ghci-ng-7.6.3.4 (HerbertValerioRiedel)
10:56:29 <augur> hmm
10:56:51 <augur> iteratees would probably be more interesting if they didn't just emit an answer when they're done
10:57:18 <sclv> yeah maybe they could sing a little song
10:57:34 <augur> but like if instead they could emit data when they say they're ready to request some more data as well
10:57:41 <augur> like
10:57:49 <sclv> nah i like the song thing
10:57:50 <johnw> I like the song idea
10:58:10 <augur> data Iter a b = Done a | Next a (b -> Iter a b)
10:58:26 <augur> or maybe it would be Next (Maybe a) (b -> Iter a b)
10:58:39 <augur> something like that
11:01:12 <hvr> sclv: would the song represent an out-of-band channel?
11:01:31 <sclv> ouch
11:03:42 <sclv> ♬ Done with the iteratee / yeah you know me. ♬
11:04:45 <dacc> heh, REM?
11:09:25 <b2coutts> > (\(x:xs) -> 1; \x -> 0)
11:09:27 <lambdabot>   <hint>:1:14: parse error on input `;'
11:09:43 <b2coutts> ^ is there a way to do magic like that in a lambda?
11:10:14 <geekosaur> not as such; you can manually use a case, but you can't use multiple patterns at the top of the lambda
11:10:50 <geekosaur> \x -> case x of {(_:_) -> 1; _ -> 0} or similar
11:11:00 <geekosaur> (or even shorter with LambdaCase
11:11:01 <geekosaur> )
11:11:33 <geekosaur> {-# LANGUAGE LambdaCase #-} ... \case {(_:_) -> 1; _ -> 0}
11:19:10 <pentace> > fromEnum . not . null $ []
11:19:11 <lambdabot>   0
11:19:14 <pentace> > fromEnum . not . null $ [1,2,3]
11:19:15 <lambdabot>   1
11:19:34 <johnw> nice!
11:19:52 <johnw> i never thought of using fromEnum :: Bool -> Int
11:20:23 <int-e> > foldr (\_ _ -> 1) 0 $ []
11:20:25 <lambdabot>   0
11:21:09 <byorgey> > length . zip [()] $ []
11:21:10 <lambdabot>   0
11:21:14 <byorgey> > length . zip [()] $ [1,2,3]
11:21:16 <lambdabot>   1
11:23:32 <johnw> min 1 . length $ []
11:23:36 <johnw> > min 1 . length $ [1,2,3]
11:23:38 <lambdabot>   1
11:23:45 <johnw> > min 1 . length $ []
11:23:47 <lambdabot>   0
11:24:09 <Zenol> Does lambdabot know about lambdacase?
11:24:47 <byorgey> johnw: min 1 . length has the right result, but it forces the entire argument list
11:24:51 <glguy> > (\case () -> ()) ()
11:24:52 <lambdabot>   <hint>:1:3: parse error on input `case'
11:25:05 <byorgey> johnw: that's why I did  length . zip [()] instead
11:25:17 <johnw> byorgey: good point!
11:25:21 <byorgey> > min 1 . length $ [1..]
11:25:29 <lambdabot>   mueval-core: Time limit exceeded
11:25:31 <byorgey> > length . zip [()] $ [1..]
11:25:41 <johnw> > min 1 . length . take 1 $ [1..]
11:25:49 <lambdabot>   1
11:25:49 <lambdabot>   1
11:25:54 <geekosaur> @let {-# LANGUAGE LambdaCase #-}
11:25:54 <lambdabot>  Parse failed: Parse error: EOF
11:25:54 <johnw> > take 1 []
11:25:55 <lambdabot>   []
11:25:55 <byorgey> yes, that works
11:25:56 <geekosaur> bah
11:25:57 <mstksg> huh. who would have thought
11:26:15 <geekosaur> thought that was working at one point
11:26:30 <glguy> geekosaur: Glad they fixed it
11:30:27 <leroux> @src (->)
11:30:27 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:30:49 <leroux> Where is (->) defined?
11:32:11 <merijn> leroux: Nowhere, it's syntax not a function
11:32:12 <elliott> in the Haskell Report.
11:32:18 <WraithM> Isn't that just in the Haskell grammar?
11:32:24 <WraithM> Right
11:32:25 <elliott> well, (->) has kind * -> * -> *.
11:32:27 <merijn> Oh, yeah, I guess the report is the more accurate answer
11:32:31 <elliott> or uh, more than that in GHC
11:33:17 <merijn> elliott: No, "* -> * -> *" is right according to ghci
11:33:47 <WraithM> > :k (->)
11:33:48 <lambdabot>   <hint>:1:1: parse error on input `:'
11:33:55 <WraithM> :k (->)
11:33:56 <lambdabot> * -> * -> *
11:34:07 <WraithM> :t (->)
11:34:08 <lambdabot> parse error on input `->'
11:34:15 <leroux> So, that are any kinds?
11:34:32 <leroux> s/that/those
11:34:35 <merijn> leroux: No * is the kind of "normal" haskell types
11:34:40 <merijn> :k Int
11:34:40 <lambdabot> *
11:34:54 <merijn> The type for any kind is AnyK
11:35:18 <elliott> but (Int# -> ()) is a valid type.
11:35:22 <elliott> subkinding?
11:35:28 <elliott> weird.
11:35:36 <elliott> maybe it just lies to you.
11:35:41 <merijn> Probably
11:36:03 <tomejaguar> What's wrong with (Int# -> ()) being a valid type?
11:36:45 <augur> edwardk: your github is gone?
11:36:50 <edwardk> wut
11:37:02 <edwardk> https://github.com/ekmett
11:37:02 <mstksg> is there a library function that lazily compares lists by length?
11:37:03 <augur> comonad.com says no github
11:37:13 <glguy> https://github.com/ekmett works fine for me
11:37:20 <edwardk> augur: that is annoying
11:38:01 <merijn> mstksg: genericLength plus lazy Peano arithmetic would work :)
11:38:04 <johnw> status.github.com will tell you if something is up
11:38:08 <merijn> mstksg: It hangs if both are infinite, though
11:38:55 <augur> edwardk: which repo has the nyc talk slides?
11:39:01 <edwardk> augur: i have a cname entry for it on github it should work =(
11:39:19 <mstksg> merijn: how would that work?
11:39:26 <edwardk> annoyingly http://ekmett.github.io/comonad.com/reader/index.html works
11:39:32 <johnw> I want the lambdajam slides
11:39:37 <edwardk> so whatever they did it stopped serving from the redirect =(
11:40:03 <merijn> mstksg: genericLenth just uses "+1" internally, so if you need a Peano type that has a lazy Num and Ord instance
11:40:16 <merijn> s/if//
11:40:20 <edwardk> ah when johnw updated the mirror he put it in a subdir
11:40:24 <edwardk> johnw: you nuked comonad.com ;)
11:40:41 <johnw> oopsy
11:40:42 <mstksg> > comparing genericLength [1,2] [1..]
11:40:45 <lambdabot>   *Exception: stack overflow
11:40:46 <johnw> yeah, I mirrored with a better tool this time
11:40:55 <johnw> httrack instead of SiteSucker (which now always crashes)
11:41:18 <merijn> mstksg: You're missing the Peano piece of the puzzle
11:41:21 <augur> edwardk: well i can get it through the github direct link :
11:41:22 <augur> :D
11:41:33 <johnw> johnw: Breaker of Websites
11:41:35 <edwardk> johnw: yeah but the problem is with it not being in the top level dir the github site doesn't work
11:41:49 <merijn> mstksg: Alternatively you could implement it using direct recursion pretty easily
11:41:59 <glguy> edwardk: Any reason I shouldn't be able to use ersatz's "solveWith" inside an unsafePerformIO? It's pure, right?
11:42:02 <johnw> actually, I think we can just move it all up a level
11:42:08 <johnw> let me do that
11:42:13 <edwardk> glguy: it runs an outside program
11:42:15 <glguy> if you pretend like temp files are hidden/local to the solver
11:42:24 <edwardk> beyond that sure
11:42:27 <augur> edwardk: hm so yeah
11:42:29 <mstksg> merijn: yeah, i know how it would be very easily implemented; i just wanted to know if there was a library function already for it
11:42:33 <augur> i dont like this talk of the .'s being backwards
11:42:37 <johnw> edwardk: can you point your webserver into the comonad.com directory instead that checkout?
11:42:40 <johnw> then it should just work
11:42:43 <edwardk> augur: what (.)'s being backwards?
11:42:52 <edwardk> you mean lens (.)'s
11:42:52 <augur> in the lens nyc talk
11:42:53 <edwardk> ?
11:42:58 <edwardk> they aren't backwards, its just cps'd
11:42:59 <augur> with the fmap.fmap.fmap and so on
11:43:11 <edwardk> the cps inverts the meaning you'd naively assign
11:43:26 <edwardk> giving you imperative programming meaning by accident
11:43:28 <augur> eh. i think at least for fmap, maybe not for lens we'll see when i get there, but at least for fmap
11:43:51 <edwardk> suspend disbelieve and give it the benefit of the doubt. ;)
11:43:54 <edwardk> er disbelief
11:43:56 <augur> that the rhetoric really should be that we have to think about pushing "down" into structures
11:43:59 <edwardk> it grows on you after a while
11:44:14 <edwardk> i'm open to new ways to selling it ;)
11:44:35 <augur> at least for fmap, this is just essentially true.
11:44:43 <augur> fmap f really is just f, but "down inside"
11:45:02 <augur> so that fmap.fmap.fmap just says go down once, then again, then again, ok here
11:45:14 <augur> and its left-to-right like that
11:46:04 <sepia> anyone have experience getting gloss to work with ghcjs?
11:46:07 <johnw> there's a similar reversal with monad transformers.  lift.lift.lift go "out to in" from left to right
11:46:20 <augur> yeah, lift is a really poorly named thing
11:46:25 <augur> its "correct" but also not
11:46:26 <edwardk> augur: the site should be fixed. i pointed it to the new version of the old server
11:46:38 <sepia> i tried and it compiled correctly, but am getting a console error in index.html
11:46:47 <alpounet> sepia, ask luite i think
11:46:53 <augur> it ought to be lower, just from an intuitional perspective.
11:47:07 <johnw> I agree sometimes
11:47:12 <augur> sure, lift takes a thing and lifts it into the higher monad
11:47:47 <augur> but the point is that the action is in the lower monad
11:47:49 <johnw> it depends on whether you take the stalagmite or the stalactite view of monad transformers
11:47:56 <augur> the "true" action, anyway
11:48:00 <sepia> alpounet: thanks
11:48:13 <edwardk> augur: You've already got the right 'flip' in your head, but for the most part when i explain to someone that "traverse.both" will walk over a list of pairs the kneejerk reaction of a 8 out of 9 people who know how (.) works in Haskell has historically been to look at me like i'm a loon.
11:48:20 <clahey> I'm confused as to why     main = unless True do print "test"    gives a syntax error.
11:48:32 <johnw> unless True $ do print "test"
11:48:37 <johnw> unless only takes two arguments
11:48:47 <augur> edwardk: thats why i think the rhetoric is important
11:49:07 <edwardk> augur: sure. i'm open to agreeing that i could have said it better. =P
11:49:10 <clahey> Oh, I thought do was like then in that it would automatically create groupings like that.  Okay.
11:49:21 <johnw> edwardk: did you see my suggestion of pointing your webserver at the "comonad.com" directory now inside ekmett.github.com?
11:49:24 <augur> edwardk: the right choice of wrds can make people your best friend or your worst enemy
11:49:28 <edwardk> clahey: nah, do has to be on the right hand side of an operator to start working its magic
11:49:29 <johnw> or is that problematical?
11:49:40 <edwardk> johnw: not an option
11:49:40 <augur> but let me finish watching this
11:49:40 <akamaus> is it possible to define unary operators in Haskell? It there any ghc extension for that?
11:49:44 <johnw> edwardk: ok, fixing then
11:49:47 <augur> (this is like the third time ive watched this too. :p)
11:49:48 <edwardk> johnw: github doesn't let me do that
11:50:04 * hackagebot hexpat-pickle-generic 0.1.5 - Picklers for de/serialising Generic data types to and from XML  http://hackage.haskell.org/package/hexpat-pickle-generic-0.1.5 (BrendanHay)
11:50:33 <edwardk> > 2 * do 5 + 2    -- works because do is on the right hand side of an operator
11:50:35 <lambdabot>   14
11:50:41 <johnw> edwardk: pushed
11:50:46 <edwardk> johnw: thanks.
11:51:01 <edwardk> that'll work well if i need to move back to the github repo as a stable mirror on short notice
11:51:23 <johnw> comonad.newartisans.com has also been updated, btw
11:52:02 <clahey> :t do 5 + 2
11:52:03 <lambdabot> Num a => a
11:52:12 <clahey> It's just using the Identity Monad there?
11:52:19 <edwardk> clahey: no monad at all actually
11:52:21 <edwardk> do x = x
11:52:39 <edwardk> its only when ; gets involved that you start picking up monadic stuff in the signature
11:52:47 <edwardk> they changed it around 6.10 or 6.12 or so
11:52:47 <glguy> edwardk: If you use solveWith minisat (and probably others) and don't use the solution but only the result (Satisfied, Unsatisfied) you leak file descriptors
11:53:00 <edwardk> glguy: then you've answered your own question ;)
11:53:00 <glguy> because readFile is used in parseSolution
11:53:12 <edwardk> glguy: feel free to make it more strict
11:53:40 <edwardk> i need to spend some time upgrading ersatz to do smtlib stuff, so it can talk to smt solvers.
11:53:53 <edwardk> woot!
11:53:59 <glguy> Also, thanks for making ersatz. I'm enjoying having it :)
11:54:30 <edwardk> if we take IntMap and use my trick from the matrix multiplication II post, we can improve a number of operations on it
11:54:47 <edwardk> e.g. data IntMap a = Nil | Tip {-# UNPACK #-} !Int a | Bin {-# UNPACK #-} !Int {-# UNPACK #-} !Int !(IntMap a) !(IntMap a)  has the same amount of storage overhead as the existing one
11:55:07 <edwardk> _but_ what we want to store is the least and greatest key in the map in Bin rather than the prefix and mask
11:55:13 <edwardk> that makes better use of those two ints
11:55:35 <edwardk> then when we recurse for lookup:
11:55:39 <edwardk>   go (Bin lo hi l r) | xlh <- xor lo hi, xkh <- xor k hi, xkh < xlh, xkh < xor xkh xlh, k <= hi = go r | k >= lo   = go l | otherwise = Nothing
11:55:39 <edwardk>  
11:56:08 <edwardk> uses the 'compare on most significant difference' trick to decide which branch to take, but will also exit early if the key you are looking for isn't in the map
11:56:32 <edwardk> similarly when you go to intersect two IntMaps you can get more quickly rejected regions
11:57:08 <edwardk> the overhead is replacing some .&.'ing and comparing with xoring and comparing
11:57:58 <clahey> I'm confused by how where and do interact.
11:58:26 <simukis_> clahey: how?
11:59:14 <clahey> simukis_, I was probably just using where when I should have been using let.
12:02:14 <jophish> What is the most simple way of making a type alias which doesn't allow casting to it's alias
12:02:49 <jophish> for example type T = Int, type S = Int allows casting from S to T
12:03:02 <jophish> but data T = T Int, data S = S Int doesn't
12:03:13 <byorgey> jophish: you probably want a newtype.
12:03:31 <byorgey> you can't actually make a type alias with that property
12:04:05 <augur> also, edwardk, this type SEC is really tricky. i think the best way to "say" it is like this: "SEC s t a b" means "go from s to t using an a to b"
12:04:32 <jophish> byorgey: ah, great
12:07:02 <augur> edwardk: also i think the "applicative/monad = way to compute" might be especially useful for talking about traverse.
12:07:41 <augur> "if i can take an a and get a way to compute a b, then give a structure full of a's, i can get a way to compute a structure full of b's"
12:07:51 <augur> that's just "obviously" true
12:10:25 <augur> :t traverse
12:10:36 <edwardk> augur: sure
12:10:43 <augur> darn lambdabot :(
12:16:14 <augur> edwardk: mmm  Setter s t a b = SEC s (Id t) a (Id b) ?
12:16:27 <edwardk> augur: typewise yes, semantically no
12:16:42 <edwardk> we want s = t, a = b to be possible assignments for a Setter or SEC
12:17:21 <augur> but surely that'd just be Setter s s a a = SEC s (Id a) a (Id a)
12:17:51 <augur> also haskell's lack of type level functions is terribly irritating because Id shouldnt even exist :|
12:18:59 <zomg> augur: there would need to be another lang like that then because something has to act as the gateway drug
12:19:02 <zomg> erm
12:19:03 <augur> i mean, in principle, it ought to be that over == ($)
12:19:18 <augur> zomg: there is, it's called agda :)
12:19:27 <augur> and/or idris, depending on your stylistic preferences
12:19:55 <zomg> I always thought haskell was the gateway drug to agda and not the other way around
12:19:58 <zomg> =)
12:20:08 <augur> oh i see what you mean
12:20:28 <alpha123> Oh great, I'm not going to end up on Agda eventually, am I?
12:20:34 <augur> i thought you meant there would need to be anoter lang that haskell would be the gateway for
12:20:40 <augur> alpha123: ofcourse you are!
12:20:42 <augur> we all are!
12:20:42 * alpha123 is just getting into Haskell and it's amazingly cool
12:20:55 <alpha123> augur: Is Agda practical *at all*?!
12:21:04 <augur> hell no
12:21:20 <blume_> so beautiful
12:21:23 <augur> SPJ WOULD BE PROUD
12:21:29 <alpha123> I just want to write performant, concise web apps quickly....
12:21:41 <zomg> alpha123: ha, I'm using haskell p much for exactly that :)
12:22:01 <alpha123> zomg: What framework? Yesod is literally one of the coolest things I've ever used. :)
12:22:09 <ParahSailin> @src Either fail
12:22:10 <lambdabot> fail msg      = Left (strMsg msg)
12:22:26 <zomg> Yeah I've used Yesod but for my current project I'm just using plain warp/wai for now and seeing how it goes
12:22:27 <augur> alpha123: you can compile agda to JS tho lol
12:23:08 <alpha123> augur: Seriously? Woah.
12:23:35 <donri> eh that's not the definition of fail for Either?
12:23:56 <joelteon> > do { fail "nope" } :: Either String Int
12:23:57 <lambdabot>   *Exception: nope
12:24:06 <donri> that's ErrorT
12:30:02 <monochrom> haha "Have you ever wondered [...] but never could understand the paper or Edward Kmett's blog posts on the subject?" http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/
12:30:11 <edwardk> =P
12:31:05 <tomejaguar> What is SEC?
12:31:19 <byorgey> I do very much like the whole idea of problem-set-as-exposition
12:31:26 <merijn> zomg: relevant quote
12:31:29 <byorgey> tomejaguar: Semantic Editor Combinator
12:31:31 <merijn> @quote roconnor merijn
12:31:31 <lambdabot> roconnor says: <roconnor> merijn: I got into Haskell from Coq. <xplat> that's like getting into drinking through heroin.
12:31:32 * monochrom has to dance with codensity now because of oleg's extensible effect paper
12:31:42 <zomg> merijn: lol
12:31:43 <byorgey> tomejaguar: http://conal.net/blog/posts/semantic-editor-combinators
12:31:59 <tomejaguar> Ah right.
12:32:18 <monochrom> yeah, learning-is-not-spectator-sport and inverted-classrom FTW
12:33:33 <byorgey> alpha123: you can compile Haskell to JS too!  See ghcjs, haste, fay
12:34:41 <clahey> @pl newIORef Nothing >>= (\ref -> return Just ref)
12:34:44 <lambdabot> newIORef Nothing >>= return Just
12:34:45 <lambdabot> optimization suspended, use @pl-resume to continue.
12:34:53 <clahey> @pl newIORef Nothing >>= (\ref -> return (Just ref))
12:34:54 <lambdabot> Just `fmap` newIORef Nothing
12:35:25 <clahey> @pl newIORef Nothing >>= (\ref -> return (ref, 0))
12:35:28 <lambdabot> return . flip (,) 0 =<< newIORef Nothing
12:35:28 <lambdabot> optimization suspended, use @pl-resume to continue.
12:35:47 <mauke> @pl-resume
12:35:53 <lambdabot> return . flip (,) 0 =<< newIORef Nothing
12:35:54 <lambdabot> optimization suspended, use @pl-resume to continue.
12:36:00 <mauke> @pl-resume
12:36:12 <lambdabot> return . flip (,) 0 =<< newIORef Nothing
12:36:12 <lambdabot> optimization suspended, use @pl-resume to continue.
12:36:33 * byorgey suspects foul play
12:36:59 <clahey> byorgey?
12:37:19 <byorgey> clahey: just a silly joke.  @pl seems to be stuck in an infinite loop.
12:38:18 <elliott> someone broke @pl at some indefinite point in the past
12:38:31 <elliott> I think possibly in the same way @unmtl broke.
12:41:11 <johnw> maybe it happened with a GHC upgrade
12:43:50 <elliott> they don't use GHC, so I doubt it
12:53:25 <xenocons> whats the general haskell approach to efficiently (but functionally) reading types from a binary stream, for example 4 bytes and returning this as int32 (or uint32) etc)
12:53:30 <xenocons> horrible question i know
12:54:03 <elliott> take a look at the cereal and binary packages
12:54:07 <elliott> perhaps also attoparsec
12:54:17 <xenocons> ok, sounds like a good start
12:54:47 <ion> I wish cereal, binary and attoparsec were a single thing.
12:54:59 <johnw> cerinaryparsec?
12:55:13 <ion> attocenary?
12:55:36 <byorgey> attorparbinal
12:55:58 <johnw> my attocenary is what I celebrate a quintillion times a second
12:56:20 <byorgey> wow, that is a lot of celebrating
12:56:27 <johnw> here is a happy place
12:56:42 <johnw> not much time to do much at each event though
12:56:50 <johnw> the aggregate left-overs are killing me
12:57:46 <S11001001> also bytes package for cereal/binary-genericity
13:01:32 <clahey> Is it possible to get the current time in ms in haskell?
13:01:38 <clahey> With some accuracy?
13:01:50 <Sonarpulse> ion: especially cerial and binary
13:01:59 <Sonarpulse> *cereal
13:02:01 <clahey> Well, with some precision.  I don't terribly care about accuracy.
13:02:13 * khyperia decides to do project euler with haskell
13:02:29 <bscarlet> clahey: http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#v:getCurrentTime
13:04:03 <clahey> bscarlet, And that will update from millisecond to millisecond?
13:04:39 <bscarlet> clahey: That will probably call to the OS. The result will be as accurate as the OS lets it.
13:12:53 <byorgey> anyone remember off the top of their head what module I have to import to get the Constraint kind in scope?
13:13:18 <johnw> isn't it GHC.Constraint?
13:13:30 <elliott> GHC.Exts I think.
13:13:34 <byorgey> johnw: that module doesn't seem to exist
13:13:45 <byorgey> elliott: that's it, thanks!
13:14:04 <khyperia> what is the operator for "does not equal"
13:14:19 <geekosaur> /=
13:14:22 <khyperia> huh
13:14:25 <khyperia> alright, thanks
13:14:26 <tikhon> it's like ≠
13:14:30 <tikhon> but in ASCII
13:14:38 <elliott> byorgey: :)
13:14:41 <joelteon> and the latter is in base-unicode-symbols
13:14:43 <joelteon> I think
13:14:51 <johnw> i still miss <> from Pascal
13:14:59 <tikhon> that's what OCaml uses :)
13:15:09 <geekosaur> ~= !
13:15:14 <tikhon> but I like it more for Data.Monoid
13:15:20 <johnw> well, true
13:15:25 <johnw> and I was just joking too
13:15:27 <joelteon> I usually like to define (++) as mappend
13:15:38 <tikhon> (<>) = mappend comes with Data.Monoid
13:15:46 <tikhon> I think something like • would be ideal
13:16:03 <mauke> too close to ∘
13:16:15 <tikhon> at least in my font, I can tell them apart
13:16:32 <tikhon> I actually have ∘ configured in my editor, so I've played around with this
13:16:39 <tikhon> but yeah, I could see that being an issue
13:16:44 <tikhon> hmm
13:17:00 <joelteon> the most I'd ever do for unicode syntax is conceals, I can't stand writing source code with those characters actually in it
13:17:10 <tikhon> why not?
13:17:37 <joelteon> I'm not sure
13:17:41 <joelteon> mainly because I can't type them
13:17:54 <joelteon> and I haven't found a good solution that allows me to
13:18:15 <tikhon> Emacs has the TeX input mode, and somebody even released a special Haskell input mode recently
13:18:34 <joelteon> I wonder if vim has tex input
13:18:41 <tikhon> almost definitely
13:18:51 <tikhon> I believe you can even configure something like that throughout your whole system
13:19:21 <joelteon> that would be nice.
13:20:39 <johnw> I use the Agda-input-mode
13:23:55 * lispy is super excited for ghc 7.8
13:24:01 <lispy> So many good new features in one release
13:24:01 <johnw> yeah, me too
13:24:12 <johnw> especially since my work code still uses 7.4
13:24:20 <johnw> so this will be a "double jump" for me :)
13:24:42 <lispy> TypeHoles should be awesome. Now if we can get an Agda or ProofGeneral like mode for Haskell...
13:25:03 <haasn> can I see the (preliminary) release notes anywhere? and when does it come out?
13:25:09 <johnw> Sept
13:25:22 <johnw> is what I've heard
13:25:25 <k00mi> joelteon: in vim see ":help digraph"
13:25:26 <elliott> TypeHoles is still worse than ImplicitParams.
13:25:29 <elliott> unless they fixed it.
13:26:07 <joelteon> k00mi: nice
13:26:45 <joelteon> wow, there are a lot defined already.
13:26:58 <k00mi> joelteon: not nearly as good as agda input mode for emacs though
13:27:08 <joelteon> no, I guess not
13:30:11 * hackagebot sparse 0.5 - Lightweight parsing library based on partial functions.  http://hackage.haskell.org/package/sparse-0.5 (HansHoglund)
13:32:11 <Zenol> Question about gloss :
13:32:34 <Zenol> Does it handle union, intersection, substraction, etc of vectorial  stuff?
13:33:04 <Zenol> Like taking the intersection of two circles as you can do with inkscape (svg).
13:33:49 <zq> main = do { raw <- getContents; print . sum . map read . words $ raw }
13:33:50 <zq> main = do { raw <- getContents; print . sum . map read . words $ raw }
13:34:28 <zq> even with ghc -O3, summing takes > 800% longer than python
13:35:20 <byorgey> Zenol: nope.  neither does diagrams (yet).  You might be interested in https://github.com/colah/ImplicitCAD
13:35:22 <Zenol> zq: You are using read and String.
13:36:00 <Zenol> zq: If you want efficiency, take a look at Text for text mode processing, and ByteString for binary processing.
13:38:35 <Zenol> byorgey: Hey! Fun!
13:40:52 <zq> Zenol: ByteString doesn't do unicode, does it?
13:41:12 <tikhon> zq: no, it's just a string of bytes
13:41:19 <tikhon> if you want Unicode, use Text
13:41:36 <jlamothe> You could encode UTF-8 into a ByteString
13:41:37 <zq> tikhon: which package?
13:41:51 <zq> hm nvm
13:42:02 <Zenol> zq: Data.Text
13:42:12 <zq> str in python2 is a bytestring too
13:45:10 <Zenol> zq: http://hackage.haskell.org/packages/archive/text/0.11.1.3/doc/html/Data-Text-Read.html for reading number from UTF-8 strings.
13:47:24 <zq> god
13:47:29 <Zenol> zq: You want something like main = do { raw <- Text.IO.getContents; Text.IO.putStr . sum . map ((\Right (n, _) -> n) . decimal) . Text.words $ raw }
13:47:34 <zq> :browse output is hard to read
13:47:52 <zq> Zenol: hey, don't give me the answer outright
13:47:55 <zq> but thanks
13:50:13 <Zenol> zq: Also, if you input is something like 1GB file, you'd prefer Text.Lazy :) And maybe you can do something more efficient around the map aplied to Text.words (maybe with fold' 0 (+), but I'm not sure).
13:50:24 <zq> what if i want to split along multiple delimiters?
13:50:39 <zq> splitWith with the first argument being membership check into a string?
13:53:42 <edwardk> sclv: ping
13:53:53 <sclv> yo
13:54:16 <edwardk> so basically the trick comes down to replacing the prefix and mask with the least and greatest entry in the IntMap.
13:54:38 <d3lxa> any idea why this won't compile: let allEnum :: Bounded a => [a] -> [Int]; allEnum x = map fromEnum [x .. maxBound]  and error is Could not deduce (Enum [a]) arising from a use of `fromEnum'
13:54:41 <edwardk> you can then use the trick from part 2 of my matrix multiplication series to implicitly compare by the mask with 3 xors
13:55:01 <edwardk> and as a side-effect searches that fail can do faster rejections
13:55:13 <edwardk> because they can use the rest of the bits for free
13:55:38 <d3lxa> sorry, in my example above I mean 'a' and not '[a]'
13:56:34 <hpaste_> edwardk pasted “IntMap via 2-fat comparison” at http://lpaste.net/92117
13:56:46 <edwardk> sclv: ^- that
13:57:04 <edwardk> still cleaning up the insert, but the lookup is nice
13:57:26 <sclv> ooh
13:57:54 <edwardk> sclv: this is using the same jumble of xor's that powers my matrix multiplier
13:58:27 <sclv> so does this change the ordering things are stored in the map?
13:58:31 <edwardk> no
13:58:34 <sclv> cool
13:58:35 <edwardk> same IntMap shape
13:58:39 <zq> signature of Data.ByteString.split :: Word8 -> ByteString -> [ByteString] -- shouldn't that be Char8?
13:58:51 <johnw> what's the speed difference to unordered-containers?
13:58:55 <Zenol> zq: You have split, splitAt, and splitOn. If you want a splitWith, you'll have to use find/findIndex/breakOn, etc
13:58:55 <edwardk> just using the rest of the bits in Prefix/Mask more intelligently by storing different stuff in those two ints
13:59:06 <merijn> zq: There is no such thing as Char8
13:59:06 <edwardk> johnw: still working out benchmarks i wanted to have a larger cross-section first
13:59:15 <zq> > [1..23]
13:59:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]
13:59:22 <johnw> oh, that's in containers
13:59:22 <merijn> zq: Word8 == byte
13:59:30 <zq> :t Data.ByteString.split
13:59:31 <lambdabot> Word8 -> BSC.ByteString -> [BSC.ByteString]
13:59:38 <joelteon> :t Data.ByteString.Char8.split
13:59:39 <lambdabot> Char -> BSC.ByteString -> [BSC.ByteString]
13:59:41 <edwardk> johnw: but it can quickly reject things that are outside of the rang of the IntMap right at the top rather than after up to 64 steps
13:59:59 <edwardk> and as you recurse those ranges tighten, letting it short circuit later as well
14:00:07 <johnw> how much slower does it get with each new bit in the key?
14:00:09 <zq> > import Data.ByteString as BS; bs.split '\n' "a\nb\nc"
14:00:10 <lambdabot>   <hint>:1:1: parse error on input `import'
14:00:15 <edwardk> same as IntMap
14:00:18 <edwardk> nothing changes there
14:00:27 <merijn> d3lxa: Bounded Does not imply Enum, afaik?
14:00:28 <johnw> I wonder if StableName can yield a Ptr number, then you wouldn't even have to hash
14:00:38 <edwardk> the only difference is when you use some IntMap on a small set of dense integers, where IntMap sucks, it sucks less
14:00:48 <edwardk> StableNames are expensive
14:00:55 <johnw> ah, ok
14:00:57 <edwardk> i have an interned intmap in intern
14:00:58 <d3lxa> merijn: yes you are right; in fact I'm trying to have a small example of my problem but I didn't got it right ,sorry
14:01:02 <edwardk> its almost never a win
14:01:08 <merijn> zq: Maybe you want "fromIntegral (ord '\n')"?
14:01:13 <edwardk> (tried it!) =)
14:02:04 <merijn> zq: Also, you seem to be using ByteString for working with text, which is almost always wrong
14:02:11 <edwardk> if i can reduce the noise and factor the use of 'large' down a little bit further, it may become a viable proposal for improving IntMap
14:02:13 <zq> uh, how do i get lambdabot to import?
14:02:26 <edwardk> (and IntSet)
14:02:31 <Nisstyre> > "foo" :: Text
14:02:32 <lambdabot>   Not in scope: type constructor or class `Text'
14:02:35 <Nisstyre> lame
14:02:41 <zq> merijn: i'm running the examples on http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString.html#v%3Asplit verbatim
14:03:00 <merijn> zq: Lambdabot doesn't do imports
14:03:01 <edwardk> e.g. the two uses of 'large' in insert are almost entirely redundant calculations, after they inline, they compute many of the same xor's etc
14:03:24 <Nisstyre> zq: the Text type + OverloadedStrings make scrapping String easy
14:03:32 <zq> merijn: d.bs.split has several examples that all operate on strings
14:03:38 <Nisstyre> although some libraries still use String
14:03:46 <Nisstyre> (where they should be using Text)
14:03:54 <merijn> zq: That's because it uses OverloadedStrings
14:04:01 <Nisstyre> String is more for short strings or debugging
14:04:09 <zq> ugh
14:04:16 <johnw> String is still too integrated
14:04:31 <johnw> ex: show
14:04:35 <zq> so nice when posted code doesn't work as advertised
14:04:38 <merijn> Also
14:04:49 <merijn> Since when can you use '\n' as Word8?
14:05:09 <merijn> zq: The code is intended as illustration of behaviour, not as example, as far as I can tell
14:05:29 <d3lxa> merijn: I'm using Yesod, thus there are its monad in the code, maybe you have a clue? http://sprunge.us/jfGA thx anyway
14:05:46 <zq> very misleading
14:07:01 <merijn> d3lxa: Oh!
14:07:08 <merijn> d3lxa: That one is really easy
14:07:29 <merijn> d3lxa: This does not mean what you think it means: "myEnum = map fromEnum [(minBound::a)..]"
14:07:50 <mvj4> [newtypes and monad transformers] is there any way to constrain newtype variables, e.g. making a monad transformer over all monads implementing MonadIO? an alternative would be to specify the constraint in each function, but that scales O(n), not O(1).
14:07:58 <merijn> d3lxa: Type variables are local to a single type signature, so your current code is the exact same as writing "minBound::b"
14:08:57 <d3lxa> merijn: oh really? I didn't know that, I don't understand why this is so and how to fix that :S
14:08:59 <merijn> d3lxa: You *can* change this by using the ScopedTypeVariables extension, this lets you introduce type variables scoping over an entire function
14:09:38 <merijn> d3lxa: See http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
14:10:15 <d3lxa> merijn: thank you *very much, i'm quite new, so i'm quite disrupted by this behavior
14:11:36 <d3lxa> merijn: in my case I could write a function for myEnum with the same constraint (again) but it's repetitive then
14:12:47 <zq> everytime haskell makes me hold shift down, my molars lose a layer of enamel
14:14:58 <merijn> zq: Haskell doesn't make you do anything, I think you'll find that that's your keyboard
14:15:57 <tomejaguar> You type with your teeth?
14:16:04 <zq> merijn: coming from python, where the imports are instantly clear
14:16:15 <zq> both backwards and forwards
14:16:15 <Zenol> why would you have to press shift down? If you don't like symbols, you can define functions and use `fct`.
14:16:35 <zq> spec-enforced capitalization = wtf god
14:16:59 <zq> and why the hell would common things like ord need to importing beforehand?
14:17:21 <zq> might as well run back to cpp where i have to include this and that namespace
14:17:33 <quchen> Suppose I have "data List a = Nil | a : List a" and "data Stream a = a :| Stream a". Is there some way I can make a "head" function that works on both of them (without resorting to typeclasses)? Conceptually, I'd like to pattern match on the constructor, i.e. "head (c x xs) = x".
14:17:38 <zq> sorry, had to rant, all this extraneous typing really pushes me
14:17:52 <johnw> you just added to your typing for the day, really
14:17:55 <zomg> zq: go back to cpp and you'll have 10x the typing ;)
14:17:59 <merijn> quchen: Nope
14:18:11 <quchen> merijn: Not even with extensions?
14:18:26 <merijn> quchen: Well, you could maybe combine the two into a GADT and then encoded the Stream or List thing as phantom type
14:18:46 <quchen> merijn: Yeah, but then that would be like a sum of Stream and List
14:18:52 <simon> can anyone tell me how to suppress these Alex/Happy warnings? http://stackoverflow.com/questions/18060029/suppress-certain-haskell-alex-happy-compilation-messages
14:18:54 <quchen> Mostly a crazy way of encoding Either :-)
14:18:58 <elliott> not really
14:19:00 <elliott> since it'd show up in the type.
14:19:08 <quchen> Oh, right.
14:19:19 <quchen> Anyway, there's nothing crazy simple.
14:19:25 <quchen> Thanks for the confirmation.
14:19:29 <merijn> You could even "type X = " to rename to Stream/List
14:20:16 <quchen> zq: Spec-enforced capitalization is about as silly as spec-enforced use of spaces. Get used to it.
14:20:33 <quchen> zq: Also you don't have to import Ord, it's in the Prelude. On another note, importing is not a bad thing.
14:20:35 <elliott> spec-enforced capitalisation is nicer than most of the alternatives.
14:20:42 <elliott> Data.Char.ord isn't in Prelude
14:21:01 <merijn> Also, I <3 the ability to tell constructors and functions apart and type constructors and type variables
14:21:05 <quchen> Oh, ord, not Ord.
14:21:12 <tomejaguar> Spec enforced capitalization of types makes a lot of sense
14:21:21 <tomejaguar> I'm not so sure it does for constructors
14:21:31 <quchen> "Here are these two disjoint namespaces. Let's given them a disjoint set of names."
14:21:51 <elliott> f Nothing = ...
14:21:53 <elliott> f nothing = ...
14:22:00 <elliott> f :: Maybe a -> ...
14:22:03 <elliott> f :: maybe a -> ...
14:22:09 <elliott> any questions?
14:22:18 <tomejaguar> elliott: "f nothing = ..." OK I see your point :)
14:22:20 <merijn> tomejaguar: "data List a = cons a (List a) | nil" "infinity x = cons x (infinity x)" <- I'll pass
14:22:32 <zq> quchen: it's not in prelude, it's in data.char
14:22:44 <quchen> zq: Sorry, thought you meant Ord.
14:22:45 <zq> spec enforced caps of types, yes, but not modules
14:22:50 <quchen> Misread.
14:23:04 <zq> types, constructors, those make sense to me
14:23:38 <elliott> Control.Monad.return
14:23:44 <elliott> let control = ...; monad = ... in control.monad.return
14:24:43 <d3lxa> merijn: your solution helped me thx but I suspect there is a better solution than using ScopedTypes, isn't there?
14:25:07 <quchen> let control = MaybeT; monad = return in return = control.monad.return -- MaybeT return definition ;-)
14:25:22 <newsham> ?let default x d = maybe const d x
14:25:22 <lambdabot>  Parse failed: Parse error: x
14:25:31 <newsham> ?let defval x d = maybe const d x
14:25:33 <lambdabot>  Defined.
14:25:41 <newsham> > Nothing `defval` 3
14:25:42 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> a1 -> b -> a1))
14:25:42 <lambdabot>    arising from the am...
14:26:14 <merijn> d3lxa: No, because the language defines the scope of type variables to be limited to one type signature, but normally you don't need to refer to type variables in the parent scope anyway
14:26:28 <merijn> d3lxa: I almost never encounter a situation where that's needed
14:28:00 <ReinH> hai
14:28:02 <d3lxa> merijn: okay, thank you for your answer :)
14:29:19 <zq> what's the difference between char8 and word8 if they're both 8 bits wide?
14:29:37 <mauke> char8 doesn't exist
14:30:47 <newsham> > (Nothing `defval` 5, Just 2 `defval` 5)
14:30:51 <lambdabot>   (5,2)
14:31:03 <elliott> defval = flip fromMaybe
14:31:06 <f-a> ah, ddg'd for a bit without answer: where can I find an haskell-written omega combinator?
14:33:00 <Fuuzetsu> @package text
14:33:00 <lambdabot> http://hackage.haskell.org/package/text
14:43:08 <levi> zq: 'Char8' is Word8 that can be automatically cast to Char via unsafeChr.
14:44:12 <elliott> levi: what?
14:44:27 <levi> That's what Data.ByteString.Char8 does.
14:44:46 <elliott> levi: no it isn't
14:45:09 <levi> Maybe I'm not understanding the code correctly, but it certainly looks like that's what it's doing.
14:46:50 <levi> The Read and Show instances map through w2c/c2w.
14:47:06 <elliott> well, ok, but there's no actual Char8 type afaik?
14:47:26 <levi> Right, that's why I put it in quotes.
14:49:44 <levi> There's an idea of a Char8 implemented by the Data.ByteString.Char8 module, but it's just the name of the module, not a type alias.
15:06:27 <ParahSailin> whats a good xml dom parser?
15:07:25 <donri> ParahSailin: xml-conduit maybe
15:07:55 <ParahSailin> donri: yeah was playing with that one, it feels a little broken
15:08:06 <donri> hexpat might be the fastest
15:09:22 <donri> hxt has nice filtering combinators but it's kinda slow and complex and sort of abuse of arrow
15:13:41 <bennofs> donri: What's so bad about hxt's arrows?
15:14:56 <donri> bennofs: that it's an ArrowApply ;)
15:15:14 <donri> arrow doesn't buy you anything in hxt's case AFAIK
15:18:39 <augur> edwardk: so what's the point of all these Identity functors all over the place again?
15:18:42 <petapetapeta> Ralith: Heya! I'm working on the Random-Art generator you suggested yesterday. It's awesome! Thanks loads for recommending it.
15:19:30 <ParahSailin> im looking for something xml parsing similar to aeson
15:19:36 <edwardk> augur: to make the setters line up with traversals/lenses later
15:19:41 <edwardk> :t traverse
15:19:50 <edwardk> :t Data.Traversable.traverse
15:19:50 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
15:19:59 <edwardk> > [1..10] & traverse +~ 1
15:20:11 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
15:20:12 <augur> edwardk: right ok.
15:20:24 <edwardk> +~ is written using those identities. traverse already existed
15:20:45 <edwardk> > ([1..10],[11..20]) & both.traverse +~ 1
15:20:48 <lambdabot>   ([2,3,4,5,6,7,8,9,10,11],[12,13,14,15,16,17,18,19,20,21])
15:21:17 <tertl3> hello, i understand that the Haskell runtime is written in C.  Does that mean it uses GCC in linux and maybe M$ C in windows?  just wondering
15:22:13 <Ralith> petapetapeta: Great! I had a lot of fun with it; it's good to hear you are too.
15:22:14 <luite> tertl3: it's usually built on mingw with gcc, but perhaps other compilers are supported
15:22:25 <Ralith> petapetapeta: ping me in a few hours and I'd be happy to give you a code review, if you like
15:22:37 <tertl3> okay ty
15:24:00 <petapetapeta> Ralith: It would be awesome! I think I will be sleeping in a few hours though.
15:24:10 <tertl3> Ralith i guess that woudl make it easier to port over
15:24:18 <petapetapeta> Ralith: I will definitely let you know when I have something to review ;)
15:24:22 <Ralith> petapetapeta: ^^
15:24:31 <Ralith> tertl3: wat?
15:25:09 <petapetapeta> Ralith: I'm still in the starting phase of the project though so I'm still a bit on shaky ground as to how I'm gonna proceed. But I think I have an idea for how to make it work in a nice way :)
15:25:11 <tertl3> i always envisioned that Haskell was first written in Linux
15:25:28 <tertl3> and then ported over, but I guess it doesnt really have be that way
15:25:42 <Ralith> petapetapeta: great!
15:25:57 <Ralith> tertl3: you probably meant to talk address someone else.
15:26:16 <tertl3> ah yes luite
15:26:20 <tertl3> my mistake
15:26:37 <petapetapeta> Ralith: But maybe you could help me a bit - I am a bit confused as to how I'm gonna support the different arities of the classes that represent the expression trees
15:27:13 <petapetapeta> I was thinking about just putting them in some different tuples and handling it like that, but the more I think about it... The less I like that approach
15:27:39 <Ralith> petapetapeta: generally variable-arity trees are represented as follows: data Tree = Foo Bar Tree | Baz Quux Forble Tree
15:27:51 <Ralith> plus a leaf constructor
15:28:17 <Ralith> add/subtract constructors and arguments as needed
15:28:27 <Ralith> I know that's probably kind confusing but I have an appointment I gotta run to atm
15:28:40 <petapetapeta> Ralith: Fair enough :) I will look into it
15:28:43 <petapetapeta> Thanks loads again
15:35:07 <valyagolev> hey guys, I'm going through John Hughes' Arrows paper and can't understand what's the problem with one of my exercises (2.5.2)
15:35:22 <valyagolev> can't figure out how people debug arrows anyway
15:35:48 <tomejaguar> valyagolev: post some code?
15:35:51 <valyagolev> nothing actually goes through it for some reason, so even arr (\x -> trace x x) doesn't work
15:35:58 <valyagolev> yeah, one sec
15:37:56 <hpaste_> valyagolev pasted “Arrow problem” at http://lpaste.net/92118
15:38:48 <valyagolev> here's a part of the code. probably this is not the only relevant part, since I'm not using the Arrow instances from the library, but define them myself
15:39:06 <valyagolev> what happens is `runSP (mapA (arr (+1))) [[1]]` just returns the empty list
15:39:24 <valyagolev> actually, `runSP (mapA (arr (+1))) (any list of lists)` - an empty list
15:39:49 <valyagolev> http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf this is an exercise from here, 2.5.2, page 20
15:40:02 <Zenol> @pl \(a, b) -> (a, f b)
15:40:05 <lambdabot> ap (flip ((.) . (,)) f . fst) snd
15:40:05 <lambdabot> optimization suspended, use @pl-resume to continue.
15:40:17 <Zenol> X.X
15:40:48 <Zenol> @pl \f -> \(a, b) -> (a, f b)
15:40:48 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
15:40:59 <hpaste_> valyagolev pasted “Arrow problem: the whole file” at http://lpaste.net/92119
15:41:11 <S11001001> hehe Zenol
15:41:24 <valyagolev> this is the whole code (all classes, instances, default implementation, etc)
15:41:46 <Zenol> S11001001: I thin I'll keep the pointfull version :)
15:41:56 <valyagolev> everything works (mapA for (->), Kleisli and SF works), but not mapA for SP :(
15:43:15 <S11001001> Zenol: (hint if you don't know the api: second :)
15:43:35 <S11001001> (actually, for that matter, fmap :)
15:44:01 <S11001001> @ty [second, fmap]
15:44:02 <lambdabot> [(a -> b) -> (d, a) -> (d, b)]
15:45:16 <Zenol> S11001001: ?
15:45:28 <valyagolev> I think the problem is in my implementation of instance Arrow SP but I can't understand what's wrong :(
15:45:30 <S11001001> Zenol: point-free what you wrote
15:45:37 <S11001001> Zenol: second, or fmap
15:47:25 <fylwind> there's a lot of dead links on haskell.org for some reason ... e.g. http://www.haskell.org/pipermail/haskell-cafe/2011-June/092863.html
15:48:49 <Zenol> > fmap (+1) (1, 2)
15:48:50 <lambdabot>   (1,3)
15:48:53 <Zenol> Oh
15:49:03 <Zenol> I'm lucky I need to update the right part :D
15:49:13 <Zenol> > second (+1) (1, 2)
15:49:14 <lambdabot>   (1,3)
15:49:20 <Zenol> > first (+1) (1, 2)
15:49:21 <lambdabot>   (2,2)
15:49:26 <Zenol> Thanks :D
15:49:57 <Zenol> > secondM (return . (+1)) (1, 2)
15:49:58 <lambdabot>   Not in scope: `secondM'
15:49:59 <lambdabot>  Perhaps you meant `second' (imported from Control....
15:50:07 <Zenol> > fmapM (return . (+1)) (1, 2)
15:50:08 <lambdabot>   Not in scope: `fmapM'
15:50:08 <lambdabot>  Perhaps you meant one of these:
15:50:08 <lambdabot>    `mapM' (imported ...
15:50:11 <Zenol> :/
15:50:15 <ParahSailin> not sure if i've seen a useful arrow
15:50:28 <valyagolev> FRP <3
15:52:01 <companion_cube> is hugs usable for real haskell programs, or do all libraries require bizarre extensions specific to GHC?
15:53:07 <lispy> companion_cube: hugs would probably work okay for haskell98 stuff, but in practice most people use haskell98 and then some
15:53:14 <lispy> and ghc is on haskell2010
15:53:23 <lispy> I don't think hugs does haskell2010?
16:00:04 <quchen> I don't think there's much need for Hugs anymore
16:03:45 <tertl3> hugs farewell
16:03:51 <tertl3> i have never tried it
16:05:23 <Zenol> now there isn't any other haskell compiler maintened than GHC ?
16:05:28 <notasi> > sum $ take 200 $ map recip $ zipWith ($) (cycle [id,negate]) [1..]
16:05:30 <lambdabot>   0.6906534304818243
16:05:32 <notasi> > log 2
16:05:34 <lambdabot>   0.6931471805599453
16:05:36 <geekosaur> jhc/ajhc
16:07:24 <Zenol> started in april 2013?
16:07:29 <Zenol> (ajhc)?
16:07:50 <levi> Zenol: It's a friendly fork of jhc, which has been around a while longer.
16:08:17 <Zenol> levi: friendly fork?
16:10:20 <geekosaur> also it looks like there was some uhc activity last year
16:10:23 <lispy> the utrechs haskell compiler seemed pretty good
16:10:30 <lispy> I don't know how maintained it is
16:10:51 <lispy> and yhc may still be maintained
16:10:58 <elliott> yhc is dead
16:11:22 <geekosaur> ajhc was forked with the blessing of jhc's maintainer and is contributing patches back to jhc. I think jhc's author has been busy but intends to resume development
16:11:28 <geekosaur> yhc is indeed dead
16:12:53 <Zenol> Ohh, metasepi ? Does it means that they are trying to write an OS in haskell? :)
16:12:56 <RichyB> geekosaur, I heard a rumour from ndm that yhc was actually killed by its build system.
16:13:26 <Zenol> geekosaur: Ok, thanks for the explanation :)
16:14:10 <RichyB> geekosaur, seriously too; as in it got to be so much of a pain to build it from source that the people who were hacking on it for research switched to other compilers to implement their experiments on instead.
16:14:36 <joneshf-laptop> @pl reverse (dropWhile even (reverse [1..10]))
16:14:36 <lambdabot> reverse (dropWhile even (reverse [1..10]))
16:14:42 <joneshf-laptop> bleh
16:14:43 <arkeet> that's already pointless.
16:15:14 <RichyB> Did you mean to ask:
16:15:16 <flux> but it's readable, shouldn't @pl make it unreadable?-)
16:15:31 <RichyB> @pl \l -> reverse (dropWhile (even (reverse l)))
16:15:31 <lambdabot> reverse . dropWhile . even . reverse
16:16:40 <levi> UHC has a javascript backend, and it seems to have had recent commmits.  It's hosted on github now.
16:16:45 <joneshf-laptop> close
16:16:52 <joneshf-laptop> the predicate also
16:17:19 <joneshf-laptop> @pl \p xs -> reverse (dropWhile p (reverse xs))
16:17:22 <lambdabot> (reverse .) . flip ((.) . dropWhile) reverse
16:17:23 <lambdabot> optimization suspended, use @pl-resume to continue.
16:17:32 <joneshf-laptop> gross
16:17:37 <flux> ah, now we're getting there :)
16:17:53 <alkabetz> Yeah, for more than one parameter, pointfree is not so great
16:18:08 <alkabetz> I'd probably write \p -> reverse . dropWhile p . reverse
16:19:24 <levi> If you want to go full-Squiggol, you'd probably want some extra combinators.
16:20:35 <Zenol> the youtube video on the ajhc page is impressing.
16:21:34 <bennofs> @ty \p -> reverse . dropWhile p . reverse
16:21:34 <lambdabot> (a -> Bool) -> [a] -> [a]
16:21:41 <bennofs> @ty liftA2 (.) (fmap (reverse.) dropWhile) $ pure reverse
16:21:42 <lambdabot> (a -> Bool) -> [a] -> [a]
16:22:00 <levi> Yeah, writing bare-metal Haskell for my beagleboard would be cool.
16:22:33 <bennofs> @ty fmap (.reverse) $ fmap (reverse.) dropWhile
16:22:34 <lambdabot> (a -> Bool) -> [a] -> [a]
16:22:40 <bennofs> that looks quite neat :p
16:25:27 <copumpkin> @ty ((.reverse) . (reverse.)) . dropWhile
16:25:27 <lambdabot> (a -> Bool) -> [a] -> [a]
16:26:11 <copumpkin> @ty ((.) . (.)) reverse dropWhile
16:26:12 <lambdabot> (a -> Bool) -> [a] -> [a]
16:26:12 <mstksg> if i have a function with no arguments, if i call it twice, will it be recomputed the second time?
16:26:16 <Zenol> levi: I have some ATMega / ATTiny and a raspbery waiting :)
16:26:19 <mstksg> or is it just a collapsed thunk in memory
16:26:31 <arkeet> mstksg: top-level things, yeah. those are called CAFs
16:26:39 <arkeet> er
16:26:40 <copumpkin> whoops, I lost it
16:26:44 <arkeet> I think.
16:27:33 <arkeet> mstksg: a function with no arguments is called a value. ;)
16:27:42 <Zenol> just nead to find time to learn haskell, then a graphic river for the Raspbery, and then haskell multimedia station :) Sounds easy, no?
16:27:50 <arkeet> oh, the answer is "no, it won't."
16:28:07 <mstksg> arkeet: haha. yeah, but i'm still getting the hang of laziness and what it really all means
16:28:29 <mstksg> it's basically like implicit cacheing then?
16:29:41 <arkeet> mstksg: initially it'll be some unevaluated thunk.
16:29:53 <arkeet> the first time it's evaluated, the thunk gets replaced with the value.
16:30:21 <arkeet> and that result gets shared.
16:33:38 <arkeet> actually, I guess it's not just top-level things.
16:34:23 <arkeet> > last [1..1]
16:34:24 <lambdabot>   1
16:34:26 <arkeet> > last [1..1000000]
16:34:27 <lambdabot>   1000000
16:34:29 <arkeet> > last [1..10000000]
16:34:30 <lambdabot>   10000000
16:34:32 <arkeet> > last [1..100000000]
16:34:36 <lambdabot>   100000000
16:34:44 <arkeet> @let expensive = last [1..100000000]
16:34:45 <lambdabot>  Defined.
16:34:49 <arkeet> :t expensive
16:34:50 <lambdabot> Integer
16:34:52 <arkeet> hmm.
16:34:53 <arkeet> > expensive
16:34:59 <lambdabot>   100000000
16:35:00 <arkeet> > expensive
16:35:06 <lambdabot>   100000000
16:35:08 <arkeet> ok good.
16:35:12 <arkeet> > expensive + expensive
16:35:19 <lambdabot>   mueval-core: Time limit exceeded
16:35:20 <arkeet> > let x = expensive in x + x
16:35:27 <lambdabot>   mueval-core: Time limit exceeded
16:35:30 <arkeet> uh/.
16:35:32 <arkeet> > let x = expensive in x + x
16:35:39 <lambdabot>   mueval-core: Time limit exceeded
16:35:41 <arkeet> lambdabot isn't a good vehicle for timing experiments.
16:35:44 <arkeet> > let x = expensive :: Integer in x + x
16:35:51 <lambdabot>   200000000
16:36:04 <arkeet> that shouldn't have made a difference.
16:37:44 <dwcook> I like to use unsafePerformIO and seq to experiment with sharing
16:38:22 <dwcook> unsafePerformIO (putStrLn "evaluated") `seq` x
16:38:31 <levi> You can't really depend on something *not* being evaluated unless it makes a semantic difference, because GHC can do some strictness analysis as an optimization.
16:38:55 <arkeet> dwcook: why not use Debug.Trace for that?
16:39:12 <dwcook> Because I was unaware of it :)
16:39:18 <arkeet> :)
16:40:10 <levi> Haskell can evaluate things whenever it pleases as long as it obeys your strictness annotations and lazy semantics.
16:40:28 <Twey> dwcook: GHCi has some nice evaluation-debugging features built in
16:40:51 <levi> ghc-vis is a fun tool, too.
16:41:03 <Twey> You can e.g. force a value with :force, and inspect a value without evaluating it with :print
16:41:06 <Twey> Yeah
16:42:20 <levi> ghc-vis is like :print with graphical views of the data's current in-memory graph structure.
16:44:25 <monochrom> s/lazy semantics/non-strict semantics/
16:44:59 <monochrom> this is important. by the time you say "lazy", you have already removed the freedom you set out to allow.
16:46:17 <levi> Yes, you're right; I meant non-strict semantics.
16:46:21 <quchen> Remind me, non-strict is evaluating inside out, lazy is evaluating by need?
16:47:02 <levi> non-strict is a semantic thing, lazy is a strategy for implementing non-strict semantics.
16:47:05 <monochrom> non-strict is don't know how to evaluate, only know what answer
16:47:44 <quchen> Woops, I meant "outside in" there.
16:47:47 <monochrom> lazy is largely outside-in and by need, but there are exceptions. see my http://www.vex.net/~trebla/haskell/lazy.xhtml
16:49:24 <monochrom> semantics can be denotational (e.g., is it non-strict?) or operational (e.g., is it lazy?). therefore, "semantics" alone is ambiguous.
16:49:29 <levi> My stupid proxy server at work doesn't like your web host.
16:49:32 <quchen> Nice, I was looking for that article two days ago.
16:50:18 <monochrom> humanity has defined 3 levels of semantics: axiomatic, denotational, operation
16:50:32 <monochrom> s/operation/operational/
16:50:42 <edwardk> I just posted https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication-part-4   if anyone sees typos or faulty reasoning, shout!
16:52:22 <quchen> monochrom: axiomatic semantics?
16:52:24 <edwardk> "humanity" eh?
16:52:49 <tikhon`> just three?
16:52:50 <quchen> edwardk: \exists human so that human has defined …
16:52:58 <tikhon`> I always assumed there were more that I was just never taught about
16:53:31 * edwardk introduces monochrom to algebraic semantics
16:53:45 <edwardk> @google algebraic semantics
16:53:45 <lambdabot> http://en.wikipedia.org/wiki/Algebraic_semantics
16:53:46 <lambdabot> Title: Algebraic semantics - Wikipedia, the free encyclopedia
16:53:51 <tikhon`> well, to be fair, algebraic semantics is fairly similar to axiomatic semantics, isn't it?
16:53:58 <monochrom> Hoare logic is an example of axiomatic semantics. algebraic semantics is a special case of axiomatic semantics: the axioms are equations.
16:54:06 <edwardk> i guess its a form of axiomatic semantics
16:54:10 <tikhon`> hmm
16:54:18 <tikhon`> oh
16:54:24 <tikhon`> I forgot to log out at work :/
16:54:58 <tikhon`> isn't there some command to fix that?
16:55:15 <joneshf-laptop> ssh?
16:55:24 <tikhon`> no, can't do that, I'm afraid
16:55:35 <quchen> Call them?
16:55:38 <quchen> sudo shutdown? :s
16:55:42 <joneshf-laptop> dos the server
16:56:06 <byorgey> tikhon`: are you just referring to being logged into IRC from work?
16:56:19 <tikhon`> well, I'd like to kick myself off, if possible
16:56:30 <tikhon`> and I remember seeing some command involving the word 'ghost'
16:56:33 <byorgey> tikhon`: /msg nickserv ghost tikhon
16:56:42 <tikhon`> yeah, that looks like it, thanks
16:56:54 <joneshf-laptop> oh that king of log out ;)
16:57:02 <monochrom> the problem is, ironically tikhon has authenticated, but tikhon` hasn't
16:57:03 <tikhon`> there we are
16:57:26 <elliott> monochrom: where do categorical semantics end up? :)
16:57:35 <elliott> (I know nothing about it)
16:57:38 <monochrom> denotational
17:00:54 <tikhon> I've always been vaguely curious about how CS semantics relates to semantics in other fields
17:01:50 <heatsink> It overlaps with philosophy, if SEP reflects the state of affairs
17:02:11 <tikhon> also linguistics
17:02:50 <tikhon> SEP?
17:03:01 <heatsink> The Stanford Encyclopedia of Philosophy
17:03:04 <tikhon> oh yeah
17:03:13 <Clint> somebody else's problem
17:03:16 <arkeet> ^
17:03:36 <arkeet> this is the first and only expansion I could think of :(
17:04:16 <heatsink> I thought linguistics was about describing what people say, especially when it doesn't seem to follow sensible rules.
17:04:40 <tikhon> hmm, except for the sensible rules bit, that seems similar to the semantics of programming languages
17:04:59 <tikhon> and that's roughly what I expected from linguistics
17:05:06 <sclv> well it derives from broader semantics in philosophy
17:05:07 <tikhon> with philosophy, I don't even have an idea of what to expect
17:05:15 <sclv> but typically hasn't been connected back directly.
17:05:24 <tikhon> In philosophy, is it just the study of "meaning" in general?
17:05:34 <sclv> instead you get sort of fancy hybrid things that go back to linguistics
17:05:39 <sclv> but half-bypassing philosophy
17:05:47 <tikhon> fancy hybrid things?
17:05:58 <sclv> like ccshan's cool stuff on continuations and anaphora
17:06:20 <sclv> http://www.cs.rutgers.edu/~ccshan/dissertation/book.pdf
17:06:21 <tikhon> oh, I actually saw one of his papers on delimitted continuations, I think
17:06:46 <tikhon> so you mean a CS-linguistics hybrid
17:06:49 <sclv> there's other stuff that's like a categorical linguistics too
17:07:04 <tikhon> categorical in the "category theory" sense?
17:07:06 <sclv> yes
17:07:08 <tikhon> woah
17:07:40 <valyagolev> I was doing beta-reduction by hand to understand what's going on with an expression :( Is that what people are doing?
17:08:25 <valyagolev> this really looked like something ruby people would already be doing by point and click:)
17:08:36 <jfischoff> ?
17:08:36 <tikhon> beta reduction?
17:08:47 <heatsink> If you're learning Haskell, evaluating on paper is helpful
17:08:50 <valyagolev> well I had an expression and I applied functions one by one
17:08:58 <jfischoff> oh I see
17:09:04 <johnw> beta reduction = resolving function applications
17:09:15 <quchen> (\x.x)y = y   <-- Beta reduction
17:09:16 <valyagolev> http://cl.ly/image/0m3I1r3k2P44
17:09:28 <valyagolev> is beta reduction a wrong term for what I was doing?
17:09:31 <jfischoff> I've often thought having an program animate beta reduction would be a good teaching too
17:09:47 <sclv> tikhon: ah here's the stuff http://en.wikipedia.org/wiki/Categorial_grammar
17:09:49 <sclv> categorical grammar
17:10:02 <hape01> levi: Wow, ghc-vis has gotten very nice, thx
17:10:13 <sclv> you'll note that lambek (he of curry-howard-lambek) played a role.
17:10:15 <jfischoff> Also something that shows the parse tree for an express
17:10:18 <quchen> What do those bars on the left of the line numbers say, valyagolev?
17:10:35 <sclv> iirc, i think he was more interested in the linguistic/philosophy side of his categorical work from the start
17:10:40 <sclv> tho that's no what we remember him for :-)
17:10:46 <valyagolev> @quchen  is a plugin for showing last-changed line. I'm not sure it's useful, installed it a couple of days ago just to check out
17:10:47 <lambdabot> Unknown command, try @list
17:10:52 <valyagolev> ouch
17:11:01 <heatsink> @shapr
17:11:01 * lambdabot places her fist firmly on  jaw
17:11:14 <tikhon> sclv: that sounds very interesting
17:11:19 <valyagolev> hm, is ghc-vis something akin to my manual thing?
17:11:20 <quchen> @get-shapr
17:11:21 <lambdabot> shapr!!
17:11:51 <heatsink> I was just checking whether there was an @username command
17:11:58 <heatsink> and there was
17:13:20 <heatsink> valyagolev, Control abstractions like monads or arrows are not very readable after being expanded like that
17:13:23 <Zenol> edwardk: Oh, you wrote an article on cellular automata :o I'll have to read it I guess :p
17:13:39 <heatsink> It's better to develop higher-level equalities and apply those
17:14:12 <valyagolev> healsink yeah, that's certain. but I had a bug in something low-level. I actually found it
17:14:13 <heatsink> Like rewriting (return x >>= f) to (f x) instead of inlining return and >>=
17:14:30 <heatsink> Ok
17:15:55 <heatsink> Yah, debugging those things can be tricky
17:16:14 <heatsink> The trickiness is offset by the fact that they're usually a very small amount of code
17:16:30 <heatsink> so you can remove all the bugs
17:16:59 <valyagolev> I'm looking at the screenshots of ghc-vis while cabal is making it, that seems really useful for things like that. Have to check it out though
17:22:53 <MedDev> is there something like mapM for Data.Map?
17:23:05 <johnw> traverse
17:23:09 <johnw> in Data.Traversable
17:23:18 <MedDev> ok
17:23:19 <johnw> where you will find a variant of mapM that = traverse
17:23:34 <johnw> It just occurred to me that Ouroboros is tail-call optimized
17:24:20 <byorgey> well I should hope so.
17:24:40 <byorgey> hehe
17:24:54 <johnw> :)
17:27:38 <dmwit> heatsink: @shapr probably auto-corrected to @slap
17:29:11 <tikhon> that seems to be a very aggressive auto-correcting mechanism
17:30:12 <notasi> @swkap
17:30:12 <lambdabot> stop telling me what to do
17:30:21 * hackagebot gitlib 2.0.1.1 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-2.0.1.1 (JohnWiegley)
17:32:16 <MedDev> thanks johnw :D
17:32:34 <valyagolev> the joys of cabal install gtk
17:33:20 <monochrom> have you done "cabal install gtk2hs-buildtools" first? :)
17:34:00 <valyagolev> yeah, everything seems fine (from the nth try), I'm just saying' :)
17:35:06 <dmwit> Patches (including documentation patches) welcome. In fact, the official instructions are on a wiki page, so you don't even need to send a patch. Just make the instructions better.
17:36:21 <valyagolev> are you talking about gtk install? I found some tutorial and it was good enough, I just had to add PKG_CONFIG_PATH=/opt/X11/lib/pkgconfig once
17:37:32 <valyagolev> oh, I see it's there in official wiki
17:42:36 <hpaste_> Zenol pasted “Pretty horrible” at http://lpaste.net/92121
17:42:54 <Zenol> Any advice on this past? :/
17:43:36 <Zenol> types are becoming prety confusing (like [[XML]] where type XML = [Content] ... )
17:44:46 <NemesisD> hey guys. i'm running through my app with -Wall -Werror, but it looks like yesod's TH defines a few things like Widget and resourcesWebApp that I don't use. any ideas other than disabling defined but not used warnings for the file
17:45:35 <danharaj> {-# GHC_OPTIONS #-}
17:45:38 <danharaj> or something like that
17:45:45 <danharaj> it's a pragma
17:45:52 <arkeet> Zenol: <$> is a nice alternative to `liftM`.
17:45:54 <monochrom> have you gone through the GHC user guide
17:46:04 <tikhon> danharaj: can you use that on a better granularity than per file?
17:46:17 <danharaj> I don't think so.
17:46:49 <Zenol> arkeet: Ah, yes, good idea.
17:46:51 <monochrom> -fno-warn-unused-binds, there are others
17:47:00 <NemesisD> yeah it would be OPTIONS_GHC -fno-warn-unused-binds
17:47:09 <NemesisD> was just seeing if there was something less heavy handed than that
17:47:44 <valyagolev> you can do something weird like logging them to the console, just for no reason
17:47:58 <NemesisD> lol nm
17:48:08 <Zenol> arkeet: I'm afraid by itemify. Was hard to write.
17:48:46 <arkeet> Zenol: concat . map f = (>>= f)
17:48:57 <arkeet> itemify xmls = xmls >>= \(a,b) -> ...
17:49:50 <arkeet> any reason you use concat [blah, blah] instead of blah ++ blah ?
17:49:57 <arkeet> on line 14
17:50:47 <arkeet> itemify xmls = [... | (a,b) <- xmls]
17:51:10 <arkeet> I keep forgetting list comprehension exists.
17:51:17 <arkeet> it may or may not look nice there.
17:51:44 <DMcGill> if there's something big on the left of a list comprehension, just take it out
17:52:00 <arkeet> yeah, the >>= version would keep the big thing on the right.
17:52:01 <DMcGill> [f a b | (a,b) <- xmls] where f = ...
17:52:08 <arkeet> or that.
17:52:58 <Zenol> arkeet: http://i451.photobucket.com/albums/qq235/Kris_McGee/Tumblr/Disney/ToyStory1AliensOooooh.gif
17:53:16 <arkeet> argh, photobucket. =(
17:53:17 <Zenol> for the concat [ ... , .. , ..] it's because of the precedence of <!>
17:53:30 <arkeet> you could just write ("b" <!> a) ++ ...
17:53:55 <arkeet> I think that would be preferable to having concat.
17:54:11 <Zenol> a bit longuer for 3 chars: (\s -> makeListRoot $ ("b" <!> a) ++ (toXML ") ") ++ s)
17:54:19 <Zenol> I don't find it more readable :/
17:54:38 <arkeet> Zenol: up to you.
17:54:57 <arkeet> map (\s -> makeListRoot $ ("b" <!> a) ++ toXML ") " ++ s)
17:54:59 <arkeet> seems alright
17:55:22 * hackagebot git-monitor 2.0.2.0 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-2.0.2.0 (JohnWiegley)
17:56:16 <johnw> now, with more efficiency :)
17:57:17 <NemesisD> im not a big fan of the unused do binds warn
17:58:35 <arkeet> why not put _ instead of your variable, then?
17:58:49 <Zenol> I can do that also: map (makeListRoot . concat . \s -> ["b" <!> a, toXML ") ", s]) b
17:58:56 <arkeet> (is prefixing with _ enough? I forget)
17:58:57 <Zenol> (move the \s on the right)
17:58:58 <johnw> NemesisD: me either
17:59:10 <johnw> arkeet: well, that has its own problems
17:59:20 <arkeet> Zenol: I still don't really like concat being there, but it's up to you.
18:00:06 <johnw> :t (<!>)
18:00:07 <lambdabot>     Not in scope: `<!>'
18:00:07 <lambdabot>     Perhaps you meant one of these:
18:00:07 <lambdabot>       `<>' (imported from Data.Monoid),
18:00:26 <Zenol> arkeet: I really think about it as "lets take a peace of XML, an other peace, then an other.. ok, now, reduce all this stuff" instead of "start by the elements inside "b" <!> a, then add the elements inside toXML ") ", and then the elements in s.
18:00:27 <arkeet> @hoogle <!>
18:00:28 <lambdabot> No results found
18:01:26 <Zenol> arkeet> Yeh, <!> is defined in term of Text.XML.Light's unode and toXML.
18:01:56 <Zenol> (<!>) =  fmap (fmap toXML) unode ;  infixr 8 <!>
18:02:48 <Zenol> toXML :: (IsXML t) => t -> XML.
18:28:56 <Zenol> arkeet: You wone, I wrote  map (makeListRoot . \s -> "b" <!> a ++ toXML ") " ++ s) b.
18:29:03 <arkeet> heh
18:29:14 <bennofs> What is the syntax for comments in cabal=
18:29:22 <arkeet> bennofs: --
18:30:23 * hackagebot diagrams 0.7.1 - Embedded domain-specific language for declarative vector graphics  http://hackage.haskell.org/package/diagrams-0.7.1 (BrentYorgey)
18:31:42 <valyagolev> okay, ghc-vis doesn't work :(
18:31:45 <hpaste_> valyagolev pasted “No title” at http://lpaste.net/92122
18:33:59 <valyagolev> probably will have to reinstall everything
19:12:42 <Twiceler> I've got a question... I'd like to use the Arrow syntax. But I can't make my type an instance of Arrow, because I require my types to be in the Eq type class. Is there some way I can use the syntax without making my type an instance of Arrow?
19:13:25 <fylwind> how does being in Eq preclude you from doing that?
19:15:12 <Twiceler> Well, I need to make an arrow for pure functions.
19:15:30 <Twiceler> My correct definition of arr should be:
19:15:36 <Twiceler> arr f = Node (\x y -> if (f x) == y then 1 else 0)
19:16:02 <Twiceler> And so I've tried a few things but I can't beat the darn type system!
19:16:55 <Hafydd> @src Arrow
19:16:55 <lambdabot> class Arrow a where
19:16:55 <lambdabot>     arr, pure   :: (b -> c) -> a b c
19:16:55 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
19:16:55 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
19:16:56 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
19:16:57 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
19:16:59 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
19:17:33 <S11001001> Ah, arrow.
19:18:19 <S11001001> Twiceler: You can't make your type an instance of Arrow and preserve Eq membership.
19:18:25 <Twiceler> And so I'm trying to make Node an instance of Arrow. Where
19:18:28 <Twiceler> data Node a b = Node (a -> b -> Double)
19:18:31 <Hafydd> Twiceler: could you just partially define the instnace?
19:18:32 <S11001001> Twiceler: it's the unstoppable force and the immovable object
19:18:33 <elliott> you could have
19:18:37 <elliott> wait, never mind.
19:18:37 <Twiceler> Right.
19:18:50 <S11001001> Hafydd: I don't think Twiceler's a law-breaker
19:19:09 <pharaun> any particular recommendation for a configuration file library?
19:19:23 <Hafydd> They said they "just wants to use the syntax". It doesn't sound like they care about the laws.
19:19:26 <fylwind> Eq isn't possible for your definition of Node
19:19:35 <pharaun> Heard about configFile and configurator so was wondering if there was any preferred one
19:19:47 <Twiceler> Well, I almost satisfy the laws!
19:19:51 <Hafydd> Hmm... never mind, they didn't say "just".
19:20:02 <fylwind> well I guess the real question is why do you need it to be Eq that bad?
19:20:04 <S11001001> Hafydd: it's a matter of civilization
19:20:09 <Twiceler> Well, ideally, I could have (Eq a, Eq b) => Node a b ... something like that
19:20:30 <dmwit> pharaun: dyre ;-)
19:20:36 <Twiceler> I could just say arr f = error and define my own restricted arrow though, maybe
19:20:49 <elliott> the arrow notation desugaring uses arr a lot.
19:21:09 <yogert> why is it lpaste instead of hpaste now?
19:21:19 <pharaun> dmwit: oh that one! :) i've been eyeballing it for a project of mine, however i need to run the resulting binary and config it on machines without ghc
19:21:38 <Twiceler> Oh, right. And I tried using my own arr and >>>. But it won't let me write "proc"!
19:22:17 <Twiceler> fylwind: I need a pure function to be mapped to an arrow by
19:22:23 <Twiceler> arr f = Node (\x y -> if (f x) == y then 1 else 0)
19:22:37 <dmwit> yogert: Because hpaste wanted to switch hosting and the registrar wasn't cooperating.
19:22:45 <Twiceler> Inside Eq, I would satisfy the Arrow laws
19:23:00 <elliott> Twiceler: do you have RebindableSyntax on?
19:23:22 <Twiceler> elliott: No. That sounds like just what I want! Let me look that up.
19:28:27 <Zenol> arkeet: Finaly, changed to http://lpaste.net/92124. Althought I don't really know where to put line break and how to indent.
19:30:06 <Twiceler> S11001001 is right: It's "the unstoppable force and the immovable object"
19:30:37 <Twiceler> Even using Rebindable Syntax, I get an error that the compiler basically wants arr and first to have unrestricted types.
19:30:44 <elliott> hm. I mean RebindableSyntax + not using the Arrow class
19:30:47 <elliott> what kind of error?
19:31:09 <S11001001> some of the stuff in the Category hierarchy is on the wrong side of Arrow
19:31:31 <Twiceler> Here's the "arr" error: http://lpaste.net/92125
19:31:46 <S11001001> there are Choices that aren't Arrows, in other words
19:32:09 <S11001001> we'll just wait for the core libraries committee to fix all those, after the upcoming Applicative m => Monad m
19:32:41 <elliott> Twiceler: hm, that is unfortunate. I don't see any reason for that restriction to exist, perhaps ping one of the GHC mailing lists about it?
19:32:45 <elliott> or put an issue on the trac
19:32:58 <dmwit> Could you post the code that causes this error?
19:33:08 <Twiceler> Sure! Hold on, let me fix it up.
19:34:00 <dmwit> Under the assumption that you did it right, I agree with elliott.
19:35:29 <yogert> dmwit: aw, thanks.
19:36:48 <Twiceler> Here's the very bare bits of it: http://lpaste.net/92127
19:37:11 <yogert> anyone think they could clue me in to my error here…? I'm trying to write a generic Matrix type that can use various types for its "container" and indices. I'm getting a kind mismatch error from the instance declaration. Here is the code: http://lpaste.net/92126
19:37:24 <Twiceler> It doesn't explain much context as to to what I'm doing, but it's the gist of the Arrow stuff.
19:37:43 * elliott considers telling Twiceler about "if...then...else".
19:38:04 <Twiceler> Try RebindableSyntax and you'll see why it's like that!
19:38:20 <elliott> ah :)
19:38:20 <Twiceler> (at least I couldn't find out where to import ifThenElse from)
19:38:20 <dmwit> elliott: better yet, fromEnum ;-)
19:38:30 <elliott> yes, you have to give some more definitions I guess.
19:38:39 <elliott> is that (>>>) really well-typed, also?
19:39:52 <dmwit> yogert: Perhaps you meant "instance ContainerType ListContainer where"
19:40:14 <augur> @tell edwardk your talk is really hard to understand :(
19:40:14 <lambdabot> Consider it noted.
19:40:18 <dmwit> yogert: OR perhaps you meant "class ContainerType c i e where" and "instance ContainerType ListContainer Int e where".
19:41:04 <Twiceler> eliott: Let me check that out!
19:41:08 <dmwit> yogert: As it stands, your class ranges over type constructors, but you've claimed you can give an instance for a fully-applied type.
19:41:20 <yogert> dmwit: i think I've tried both of those, but ill see
19:41:38 <dmwit> yogert: Well, stick around and try to understand the error before you just try random things. =)
19:41:49 <yogert> : ) okay
19:41:59 <dmwit> yogert: Does my last sentence about why it's complaining make sense...?
19:42:24 <yogert> I think so, I should provide parameters to the class delaration?
19:42:44 <yogert> whereas just 'c' implies a fully applied type?
19:42:45 <dmwit> hm
19:43:14 <yogert> nope...
19:43:15 <yogert> okay
19:43:23 <dmwit> 'c' is a type variable, and without any further information you can't tell whether it ranges over fully applied types or partially applied ones
19:43:40 <dmwit> There's a type system for types, too. =)
19:44:23 <dmwit> So, terms are classified by types, and types are classified by kinds.
19:44:31 <dmwit> There's a kind named * which is the kind of fully-applied types.
19:45:14 <dmwit> And, you can construct arrow kinds, too: whenever k and k' are kinds, k -> k' is the kind of type constructors that take an argument of kind k and result in something of kind k'.
19:45:22 <dmwit> e.g. Maybe is a type constructor of kind * -> *
19:45:28 <shachaf> dmwit: Can I talk you into adding documentation etc. for http://ghc.haskell.org/trac/ghc/ticket/7266 ?
19:45:33 <dmwit> Int :: *, Bool :: *
19:45:48 <yogert> okay, well maybe i should first clear up some bits of confusion about classes
19:45:58 <dmwit> shachaf: erm
19:46:17 <dmwit> shachaf: What's involved?
19:46:23 <shachaf> I have no idea.
19:47:02 <shachaf> That's where you come in, see.
19:47:10 <dmwit> No, I will not accept this ill-defined task.
19:47:16 <shachaf> It's probably just a matter of adding it to the user manual or something.
19:47:23 <shachaf> You're the one who wanted the patch, right?]
19:47:54 <Twiceler> elliott: Woops. That was a big mistake... Thanks for catching it!
19:48:00 <augur> what should i read to learn about lenses :(
19:48:11 <Ralith> you should read shachaf.
19:48:18 * augur reads shachaf
19:48:24 <Ralith> and there you go!
19:49:11 <shachaf> Don't learn about lenses.
19:49:33 <yogert> dmwit: okay, so is the "kind" stuff, in part, to prevent one from making Int Int Int a member of a class?
19:49:35 <dmwit> Yes, I wanted it.
19:49:44 <dmwit> yogert: for example, yes
19:49:45 <augur> @tell edwardk "folded" is a passive not a past tense
19:49:45 <lambdabot> Consider it noted.
19:49:55 <augur> shachaf: why not?
19:51:01 <Zenol> goon night
19:51:01 <levi> augur: Because then you'll want to know how they work.
19:51:11 <augur> levi: i do wanna know how they work!
19:51:47 <dmwit> shachaf: I'll be happy to put it on my list of things to do someday. But there's an awful lot of higher-priority things on that list.
19:52:39 <yogert> dmwit: I'm still a b it confused when you say "your class ranges over type constructors". Is that to say it doesn't have a kind of "*"?
19:52:40 <levi> augur: Then you'll get sucked into the black hole of category theory.
19:53:03 <augur> levi: too late for that :)
19:53:11 <augur> far far too late
19:53:30 <augur> i even helped found the ##categorytheory channel :X
19:53:34 <dmwit> yogert: In the class declaration you pasted, 'c' has kind * -> * -> *
19:54:09 <yogert> yeah, because it "ranges over type constructors"
19:54:14 <levi> Ahh, well, then you're already lost.  Might as well learn lens too. :)
19:54:23 <yogert> which implies a type other than "*"?
19:54:23 <augur> levi: :)
19:54:23 <Twiceler> Okay, well I fixed my Arrow stuff. Turns out I also require my Arrow things to be Enum and Bounded as well as Eq. So finite, basically :)
19:54:30 <yogert> or am i mistaken?
19:54:34 <Twiceler> Here's the code: http://lpaste.net/92128
19:54:36 <dmwit> yogert: Well, a *kind* other than "*", but yes.
19:55:07 <dmwit> Twiceler: You might prefer Finite to Enum/Bounded. Maybe.
19:55:07 <Twiceler> And here's the errors in full: http://lpaste.net/92129
19:55:09 <dmwit> ?hackage universe
19:55:10 <lambdabot> http://hackage.haskell.org/package/universe
19:55:16 <elliott> Twiceler: that (>>>) looks a tad inefficient :)
19:55:46 <levi> I finally figured out something about why the Yoneda Lemma is a big deal today. I think it would be a bit premature to say I understand it, but at least it's starting to make sense.
19:55:56 <dmwit> Yes, I think you should definitely use Finite instead of Enum/Bounded.
19:56:24 <Twiceler> dmwit: Ah, cool!
19:57:09 <levi> But it seems every step I take, things are defined in some entirely new terminology from some other field of math.
19:57:40 <dmwit> Twiceler: Hm, does this mean you're about to ask for a Finite instance for Double? =P
19:58:05 <dmwit> (I'm not against putting one in, but I haven't really thought of a good way to yet.)
19:58:24 <elliott> enumerating through every Double whenever you compose sounds kind of bad.
19:58:28 <Twiceler> dmwit: Nope, it's input and output that need to be finite! Iterating over Double would take w hile
19:58:39 <dmwit> Indeed it would.
19:59:12 <Twiceler> dmwit: Basically I'm working with discrete conditional probability measures
19:59:38 <dmwit> uh huh
20:00:08 <dmwit> You might also like Writer (Product Double) or whatever that probability monad is.
20:00:16 <Twiceler> dmwit: So given an input and output, I assign a number between 0 and 1. But I need to sum over all the possible points which are assigned measure, so hence the finite thing.
20:04:10 <erisco> I keep losing where to find docs for the Alternative typeclass. oddly hard to Google
20:04:29 <geekosaur> use hoogle instead
20:04:34 <bennofs> @where hoogle
20:04:34 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
20:05:03 <erisco> thanks
20:05:11 <erisco> didn't know you coud look for typeclasses
20:13:23 <yogert> dmwit: sorry to bother you, but I'm not sure whether I've correctly understood your suggestion : ). What signifegance do parenthesis have in an instance declaration? For example, what exactly is the difference between "class Foo abc where… instance Foo (Bar Int e) where…." and "instance Foo Baz Int e where…."
20:14:21 <yogert> with the later working
20:14:42 <Excedrin> 8
20:14:58 <yogert> significance*
20:15:53 <Ralith> yogert: Foo (Bar Int e) is the application of Foo to the result of Bar Int e
20:16:09 <Ralith> Foo Baz Int e is the application of Foo to Bar, and Int, and e
20:16:22 <Ralith> s/Bar,/Baz,/
20:16:40 <yogert> ok, so the parenthesis denote the application?
20:17:03 <yogert> like pattern matching
20:17:48 <Ralith> huh.
20:18:05 <flebron> So I have an f :: a -> b -> a, and I'm doing a fold over [0..n] with it. Is there a way to collect the successive outputs of f and store them as the entries of an Array Int a?
20:18:35 <flebron> Sort of like a scanl but with iterate or something.
20:18:47 <cl_away> flebron, Why do you want them in an Array instead of a list?
20:19:11 <flebron> clahey: Because I'm going to access random entries of this thing at runtime, and the platform I'm using has no vector.
20:19:33 <Ralith> yogert: denote isn't the right word, that's just how the parser works
20:19:50 <Ralith> (e) = e
20:20:06 <papyrus> hello. i am sorry for my poor english. i am readding ghc document. theres exist "List" and "Data.List" . i think both is same. what is different ?
20:20:55 <Excedrin> "Data."
20:21:00 <levi> yogert: The parenthesis are there for the same reason you use them in arithmetic expressions.
20:21:25 <Twiceler> Well, I've been thwarted. It seems that Arrow syntax just isn't all that rebindable. See http://www.haskell.org/ghc/docs/6.8.1/html/users_guide/syntax-extns.html, section 8.3.5
20:21:53 <Twiceler> "Arrow notation (see Section 8.9, “Arrow notation ”) uses whatever arr, (>>>), first, app, (|||) and loop functions are in scope. But unlike the other constructs, the types of these functions must match the Prelude types very closely. Details are in flux; if you want to use this, ask!"
20:22:01 <clahey> flebron, So, I would find a function to make a list and then build the array from that.
20:22:04 <geekosaur> papyrus, "List" is the Haskell98-compatible one. because of differences between the Haskell98 Prelude and later language standards, you can;t reliably use List unless you force Haskell 98 mode
20:22:28 <geekosaur> Haskell2010 specifies Data.List
20:23:00 <papyrus> thanks a ton. geekosaur.
20:23:10 <clahey> flebron, I think you want scanl.
20:23:54 <flebron> Yeah, makes sense. Thanks :)
20:24:09 <clahey> flebron, So :     listArray (0, length) . scanl
20:24:19 <clahey> :t listArray (0, length) . scanl
20:24:20 <lambdabot>     Couldn't match type `a1 -> [b0] -> [a1]' with `[e0]'
20:24:20 <lambdabot>     Expected type: (a1 -> b0 -> a1) -> [e0]
20:24:20 <lambdabot>       Actual type: (a1 -> b0 -> a1) -> a1 -> [b0] -> [a1]
20:24:40 <levi> yogert: The juxtaposition of terms denotes application, the parentheses let you override the default order of application.
20:24:43 <flebron> yep
20:24:52 <clahey> :t listArray (0, 5) . scanl
20:24:53 <lambdabot>     Couldn't match type `a0 -> [b0] -> [a0]' with `[e0]'
20:24:53 <lambdabot>     Expected type: (a0 -> b0 -> a0) -> [e0]
20:24:53 <lambdabot>       Actual type: (a0 -> b0 -> a0) -> a0 -> [b0] -> [a0]
20:25:05 <clahey> :t listArray (0, 5) . (scanl .)
20:25:06 <lambdabot>     Couldn't match type `a0 -> a1 -> [b0] -> [a1]' with `[e0]'
20:25:06 <lambdabot>     Expected type: (a0 -> a1 -> b0 -> a1) -> [e0]
20:25:06 <lambdabot>       Actual type: (a0 -> a1 -> b0 -> a1) -> a0 -> a1 -> [b0] -> [a1]
20:25:41 <clahey> :t \f a bs-> listArray (0, 5) (scanl f a b)
20:25:42 <lambdabot>     Couldn't match expected type `[b0]' with actual type `Expr'
20:25:42 <lambdabot>     In the third argument of `scanl', namely `b'
20:25:42 <lambdabot>     In the second argument of `listArray', namely `(scanl f a b)'
20:25:47 <clahey> :t \f a bs-> listArray (0, 5) (scanl f a bs)
20:25:48 <lambdabot> (Num i, Ix i) => (e -> b -> e) -> e -> [b] -> Array i e
20:25:55 <clahey> @pl \f a bs-> listArray (0, 5) (scanl f a bs)
20:25:55 <lambdabot> ((listArray (0, 5) .) .) . scanl
20:26:09 <clahey> There you go.  :)
20:26:22 <clahey> \f a bs-> listArray (0, length) (scanl f a bs)
20:26:27 <clahey> :t \f a bs-> listArray (0, length) (scanl f a bs)
20:26:27 <lambdabot> (Num ([a] -> Int), Ix ([a] -> Int)) => (e -> b -> e) -> e -> [b] -> Array ([a] -> Int) e
20:26:35 <joelteon> :t (<$>) `asAppliedTo` succ
20:26:36 <lambdabot> (Enum b, Functor f) => (b -> b) -> f b -> f b
20:26:56 <clahey> Oh, it used the function length as the index type.  Ha!
21:11:02 <MedDev> How long does it usually take to get a hackage account?  I sent an e-mail about 3 days ago now.
21:12:27 <shachaf> Depends on Ross.
21:13:35 <MedDev> I'm just impatient :)
21:29:47 <NemesisD> anyone ever hit this error installing HsOpenSSL:  fatal error: ../dist/build/autogen/cabal_macros.h: No such file or directory
21:30:19 <NemesisD> i think its a relative path issue because that file does exist from the project root :(
21:47:02 <NemesisD> yep. finally got bit by installing cabal off of HEAD
21:48:46 <augur> edwardk: :\
21:48:58 <edwardk> augur: ?
21:49:30 <augur> i @telled you some stuff but apparently lambdabot doesnt want to tell you!
21:49:36 <edwardk> @messages
21:49:49 <augur> ... thats not good
21:50:06 <edwardk> i'm okay with folded being a passive
21:50:30 <augur> well, just the way it seems to be used, i think it's probably passive not past tense
21:50:30 <edwardk> and it is a fairly dense talk
21:50:51 <augur> yeah the talk is super dense. it starts out ok, but it quickly goes off into another dimension
21:51:04 <edwardk> i was going for a more declarative/passive tone with the combinator names
21:51:26 <edwardk> that and it had a huge benefit of being an under-occupied portion of the namespace ;)
21:51:54 <augur> imperative names!
21:51:59 <augur> TRAVERSE! FOLD!
21:52:00 <augur> oh wait
21:52:01 <augur> :(
21:52:43 <edwardk> traverse is given to me. i don't control that one, but i do have 'traversed', to go with 'folded' and 'mapped'
21:53:12 <johnw> I guess next we need 'bound'
22:25:38 <hpaste_> MedDev pasted “Can I generalize this pattern?” at http://lpaste.net/92130
22:26:58 <shachaf> StateT?
22:28:57 <johnw> if he's already in IO, how about IORef?
22:29:05 <johnw> or is there a reason to prefer StateT?
22:29:31 <shachaf> StateT is a pretty direct translation around what's written there, just with some abstraction.
22:29:41 <johnw> sure, I was just wondering more in general
22:29:42 <shachaf> IORef is a completely different mechanism, with a mutable reference and everything.
22:29:58 <johnw> i think in this case, I would reach for StateT too
22:30:39 <johnw> then I know which functions will be able to change the state, rather than any IO anywhere
22:30:59 <MedDev> hmmm ok i'll look into it
22:31:15 <johnw> MedDev: have you used StateT before?
22:31:22 <MedDev> nope, looks scary :)
22:31:35 <johnw> func1 :: a -> b -> c -> StateT SomeData IO ()
22:31:51 <johnw> now your func1 can use "liftIO" to run an IO action, or "get/put/modify" to get, alter, mutate the current state
22:32:16 <johnw> and then you starts things off with execStateT, or evalStateT (or runStateT if you want both the final result and the final state)
22:33:12 <johnw> > flip runStateT 10 $ do { put 15; liftIO $ print "Hello"; return 5 }
22:33:13 <lambdabot>   No instance for (Control.Monad.IO.Class.MonadIO m0)
22:33:13 <lambdabot>    arising from a use o...
22:33:19 <johnw> "Hello"
22:33:19 <johnw> (5,15)
22:33:20 <johnw>  
22:33:50 <MedDev> i'll see what I can do.  starting with the simple functions :)
22:39:29 <davidfstr> New Haskell dev here. Trying to figure out how to parse this line: request = (,) <$> requestLine <*> many messageHeader <* endOfLine
22:39:39 <davidfstr> How do I figure out where the parens go?
22:40:04 <johnw> it depends on operator precedence
22:40:08 <johnw> usually the error message will guide you
22:40:15 <johnw> and gradually you'll develop a feel for them
22:40:39 <johnw> in this case, I'm guessing the parens go here:
22:40:43 <johnw> request = (,) <$> requestLine <*> (many messageHeader <* endOfLine)
22:41:07 <johnw> but I bet this does the exact same thing:
22:41:13 <johnw> request = ((,) <$> requestLine <*> many messageHeader) <* endOfLine
22:41:30 <davidfstr> No error message (I assume here), since this is copied from an example in attoparsec which I assume works.
22:41:47 <johnw> yeah, since either expression is valid (and has the same meaning in this case), there would be no error
22:41:59 <davidfstr> Is there a way in GHCI to dynamically inspect the precedence or evaluation pattern of an expression?
22:42:31 <johnw> it would be cool if it could "parenthesize" an expression to show how GHC parsed it, but I don't know how to do that.  maybe someone else knows of a utility
22:42:38 <shachaf> davidfstr: No, but you can ask it about the precedence of a particular operator.
22:42:42 <shachaf> :i <* and so on
22:43:16 <shachaf> (Precedence means "stickiness" -- the higher the number, the stickier it is.)
22:43:46 <mlamari> Haha - was chasing down issues with hi2 emacs haskell-indent - turned out System.Process.proc and some Haskell construct "proc" were confusing it.
22:56:59 <lispy> mlamari: the haskell construct "proc" in part of the syntatic sugar for arrows
22:57:31 <mlamari> I don't know much about proc and arrows - but it's probably beyond me (and maybe too far from design of hi2) to make it able to take things called 'proc'
22:57:35 <mlamari> I mean, that aren't the actual proc
22:58:07 <lispy> if you understand monads and do-notation then you have the prerequsites to start learning arrows
22:58:24 <lispy> Like monads it's easy to pick up but hard to master
23:11:53 <edwardk> of course, once you learn arrows you'll mostly wonder why you bothered
23:12:44 <mlamari> I was whining about chasing down this detail of the plugin, not arrows :)
23:13:38 <mlamari> The Brian Hurt video has to be the best advocacy for static checking/haskellage I've ever seen.
23:14:39 <MedDev> johnw, thank you so much :D almost have the whole thing in a monad :) it was hard to desugar on sight, but it's getting easier
23:17:46 <johnw> MedDev: instead of actually using StateT s IO a, I prefer to use MonadState s m => m a, that way only functions which actually need IO (or need to pass down the IO constraint) can use MonadIO explicitly, further generalizing the functions
23:20:46 <MedDev> johnw, you lost me at MonadState :D all of my functions need IO (it's a high level wrapper for a ffi)so StateT is fine in this case right?
23:20:56 <johnw> ah, yeah
23:20:59 <johnw> in that case yes
23:21:41 <shachaf> (forall m. MonadIO m => m A) isn't really "generalized" compared to (IO A)
23:22:06 <johnw> I try to keep MonadIO to a minimum.  If everything ends up requiring it, then you are exactly right
23:22:55 <johnw> I also like being able to grep my code for "liftIO" and find all the places where external effects might come into play.  I did this the other day, and realize that the only things I was doing that needed IO were (a) telling the time, and (b) sending out e-mails
23:26:15 <erisco> doesn't say what the Alternative laws are: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Alternative
23:26:45 <erisco> does <|> have to be communative?
23:26:46 <roboguy_> erisco: it says it's a monoid though
23:27:52 <erisco> well, I don't think monoids have to be, so I might be okay
23:29:01 <erisco> oh but has to be associative... no dice then
23:31:24 <johnw> no, monoids don't have to be
23:32:20 <erisco> johnw, communitive? no, but associative, yes
23:32:28 <erisco> right?
23:32:35 <johnw> correct
23:32:44 <erisco> cool
23:32:57 <erisco> I think I have to split my problem into two separate things
