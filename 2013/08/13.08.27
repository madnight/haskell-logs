00:00:57 <luite> erisco: they're just a primitive value, not a computation that can do weird things like throwing an exception or getting stuck in a loop
00:01:37 <erisco> what, bottom? or unboxed?
00:01:50 <luite> unboxed values
00:01:59 <erisco> right, I get that
00:02:15 <erisco> I was saying I am profoundly confused when people start talking about "bottom" :)
00:02:29 <scshunt> erisco: bottom is the value which represents a computation that doesn't terminate
00:02:35 <luite> bottom means that the computation doesn't complete succesfully
00:02:56 <scshunt> it could be because it causes the program to halt, because it throws an exception, because it enters an infinite loop, or any other reason it doesn't actually get a result
00:03:40 <scshunt> it has a name because it does have some theoretical applications
00:04:21 <scshunt> for instance, treatment of bottom is the main difference, theory-wise, between a newtype and a data
00:13:09 <erisco> scshunt, I noticed
00:13:15 <erisco> that newtype doesn't let you have two fields
00:13:31 <erisco> which seems odd to me
00:14:10 <erisco> Haskell coding guidelines told me to not use tuples, so I decided to take my newtype tuple and give it fields instead
00:17:05 <scshunt> erisco: newtype is an optimization of data
00:17:25 <erisco> seems like I am incurring costs just to have a second field
00:17:28 <erisco> even though
00:17:31 <erisco> it could just use a tuple
00:17:41 <scshunt> nope, you aren't
00:18:10 <erisco> to be clear, I have to use 'data'
00:18:12 <scshunt> suppose I have data Foo = Foo String
00:18:25 <erisco> and you are saying 'data' doesn't incur extra costs?
00:18:46 <scshunt> it does for a single one-field constructor, and I'll explain why :)
00:19:05 <scshunt> if I have data Foo = Foo String, then Foo undefined is different from undefined :: Foo
00:19:06 <erisco> I'm confused to what your claim is right now
00:19:31 <scshunt> the former will only cause an exception when you actually try to get the value inside the Foo
00:20:30 <scshunt> I'll use Maybe for illustration purposes here:
00:20:59 <scshunt> > case Just undefined of { Just _ -> True; Nothing -> False }
00:21:00 <lambdabot>   True
00:21:07 <scshunt> > case undefined of { Just _ -> True; Nothing -> False }
00:21:08 <lambdabot>   *Exception: Prelude.undefined
00:21:22 <erisco> I said "it seems that data is incurring extra cost over newtype"
00:21:26 <erisco> and it sounded like you said no
00:21:28 <scshunt> erisco: hang on, I'm explaining :)
00:21:41 <erisco> well I'm confused from the premise of the entire conversation :P
00:21:49 <scshunt> erisco: When you have only one constructor, and that constructor has only one field, this disinction is not so important
00:21:58 <erisco> but I have two fields
00:22:05 <scshunt> Right
00:22:10 <erisco> because coding guidelines advised to not use tuples
00:22:15 <scshunt> in which case the distinction is very meaningful
00:22:20 <scshunt> because you could have only one field be undefined
00:22:26 <scshunt> and you could still access the other field no problem
00:22:51 <erisco> okay, but it could still use a tuple under the hood
00:22:58 <erisco> I don't see why an extra field is a problem
00:23:09 <scshunt> Because a tuple is just a type constructor with two fields
00:23:15 <scshunt> What newtype does is eliminate that distinction
00:23:19 <erisco> so is my 'data'
00:23:29 <scshunt> right, so you're not saving anything
00:23:41 <erisco> saving what?
00:23:45 <erisco> sorry this is confusing
00:23:59 <scshunt> any space
00:24:15 <scshunt> in the Just example, Just undefined and undefined are different
00:24:21 <scshunt> Haskell needs to be able to distinguish between the two
00:24:34 <erisco> I wasn't trying to save space...
00:25:24 <scshunt> ok, stop thinking so much about your code and just think about the distinction between Just undefined and undefined :)
00:25:43 <scshunt> Haskell needs to keep track of the difference, because it's a meaningful distinction
00:25:52 <scshunt> as demonstrated by my example above
00:26:02 <scshunt> what a newtype lets you do is ignore that distinction
00:26:48 <scshunt> if I have newtype Foo = String, then Foo undefined is the same as undefined
00:27:03 <erisco> I don't get how this applies to multiple fields
00:27:43 <scshunt> It doesn't
00:27:47 <erisco> okay
00:27:48 <scshunt> which is why you can't use newtype with multiple fields
00:28:09 <scshunt> it's an optimization that applies only when you have one constructor, and that constructor has only one field
00:28:15 <scshunt> so newtype is restricted to that case
00:29:03 <scshunt> it ends up being a worthwhile optimization because under the hood, the compiler doesn't need to keep extra data around on the object to say which constructor was used to make an object of that type
00:29:08 <scshunt> because there can only ever be one constructor
00:30:03 <scshunt> when you have multiple fields, you can't really do that optimization (you can in some restricted cases, but that's deep compiler-specific magic)
00:30:17 <scshunt> and underneath, a tuple is implemented exactly the same way as a type with two fields
00:30:36 <scshunt> if you did newtype Foo = (a, b), that would be the same as data Foo = Foo a b in terms of the representation and overheads
00:30:59 <scshunt> the latter is much nicer to work with, so it's preferred
00:38:27 <supki> TIL unsafeCoerce is not commutative
00:39:05 <supki> i.e. with  data Foo = Foo Int String  unsafeCoerce :: (Int, String) -> Foo  works and  unsafeCoerce :: Foo -> (Int, String)  segfaults
00:40:22 <supki> well, probably that's not "commutative" but whatever
00:40:59 <johnw> the former works when you case analyze on FoO?
00:42:24 <supki> the former works when I run it in ghci :)
00:43:30 <johnw> sure enough
00:43:48 <johnw> let (x, y) = unsafeCoerce (Foo 1 "hello") in putStrLn y
00:43:50 <johnw> that works in ghci for me too
00:47:57 <erisco> scary
00:48:26 <erisco> I will depend on this as the crux of my project
01:02:35 <fylwind> if I have a polymorphic function, say: Foldable f => f a -> Seq a, is there a way to write a special case when f = Seq to improve efficiency?
01:04:59 <kosmikus> fylwind: you could try using a GHC rewrite RULE for that
01:05:27 <mbrock> fylwind: see http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/rewrite-rules.html#rule-spec
01:05:30 <fylwind> interesting, i'll look into that; thanks
01:06:12 <johnw> kosmikus: a rewrite will only help for a direct call to such a function, right?  and not if another function Foldable f => f a passes its argument down to that function?
01:06:48 <kosmikus> johnw: it certainly is fragile, it depends on the inliner as well
01:07:10 <ski> fylwind : <http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#specialize-pragma> might perhaps also be useful in case you don't want a completely different algorithm
01:07:31 <kosmikus> but as long as the rewrite is correct, it's not going to make things worse, at least :)
01:08:46 <kosmikus> johnw: note that in this case, you do not need to rewrite a call to the function, you'd simply rewrite the function itself (at the specialized type) to be id
01:09:10 <kosmikus> johnw: so it might work in higher-order cases if the type information is sufficient to constrain the function to that case
01:10:02 <johnw> you could certainly do it with yet another type class
01:10:30 <johnw> class Foldable f => Algorithm f a where alg :: f a -> Seq a
01:10:49 <johnw> but that doesn't help optimize code you didn't write which uses the Foldable f constraint
01:11:23 <johnw> (and also, giving Algorithm a default implementation for alg pointing at the generic version)
01:26:14 <mm_freak> ManateeLazyCat: hi there =)
01:27:29 <squimmy> if i have a value x, and i want to apply that to each function in a list of [x -> IO ()], what's the best way to do that?
01:27:50 <erisco> fmap ($x) xs
01:28:02 <ski> preflex: xseen ManateeLazyCat
01:28:02 <preflex>  ManateeLazyCat was last seen on freenode/#go-nuts 160 days, 18 hours and 50 seconds ago, saying: After i read all package descriptions in https://code.google.com/p/go-wiki/wiki/Projects , i have to say "you guys are really nuts!".
01:28:03 <erisco> :type $x
01:28:06 <erisco> :t $x
01:28:07 <lambdabot> parse error on input `$'
01:28:14 <erisco> :t ($)x
01:28:15 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `Expr'
01:28:15 <lambdabot>     In the first argument of `($)', namely `x'
01:28:15 <lambdabot>     In the expression: ($) x
01:28:19 <ski> @type \x -> ($ x)
01:28:20 <lambdabot> a -> (a -> b) -> b
01:28:20 <erisco> :t ($)1
01:28:21 <lambdabot> Num (a -> b) => a -> b
01:28:27 <ManateeLazyCat> mm_freak: ski Hi, long time no see. :)
01:28:36 <ski> wb :)
01:28:42 <mm_freak> indeed
01:28:44 <squimmy> erisco: thanks! i'll give that a shot :)
01:29:04 <erisco> :t \x -> fmap ($x)
01:29:05 <lambdabot> Functor f => a -> f (a -> b) -> f b
01:29:17 <erisco> :t \x -> map ($x)
01:29:18 <lambdabot> a -> [a -> b] -> [b]
01:29:23 <ManateeLazyCat> mm_freak: How are you? ;)
01:29:24 <erisco> there that is more clear
01:29:30 <mm_freak> squimmy: mapM, mapM_
01:29:38 <mm_freak> :t mapM
01:29:39 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
01:29:50 <squimmy> oh that's much better
01:29:58 * erisco doesn't know monads :(
01:30:04 <ski> @type \x funs -> mapM_ ($ x) funs
01:30:05 <lambdabot> Monad m => a -> [a -> m b] -> m ()
01:30:31 * ManateeLazyCat Monads is monster, it's not terrible once you know what it is.
01:31:05 <squimmy> wait. neither of those work. i think it's because my function should be returning IO() but now it's returning [IO()]
01:31:13 <zomg> erisco: you will know monads or you will cry and know monads!
01:31:14 <zomg> =)
01:31:17 <mm_freak> the road to monads:  hate them, love them, learn applicative functors, hate them
01:31:18 <ski> squimmy : `mapM_', not `map'
01:32:14 <mm_freak> i'm pleased to see that there is an official proposal to make Monad a subclass of Applicative
01:32:19 <mm_freak> i hope it won't take years
01:32:43 <mm_freak> because this is really annoying:  (Applicative m, Monad m) => …
01:33:06 <erisco> does that mean return and pure will be merged into one thing?
01:33:10 <erisco> or will that linger?
01:33:32 <mm_freak> erisco: as a first approximation they will both be around
01:33:46 <mm_freak> IIRC
01:34:23 <mm_freak> but that's only for compatibility…  in user code you can use 'pure' given a Monad constraint
01:34:35 <erisco> they could move return out of the type class as return :: (Applicative f) -> a -> f a   return = pure   yeah?
01:34:43 <mm_freak> and (<*>) and liftA* and fmap and …
01:35:05 <mm_freak> erisco: yeah, but the first step is to introduce the change without breaking half of hackage =)
01:36:42 <ski> mm_freak : instead of `(Applicative m, Monad m) => ', you can use `ap',`liftM' ..
01:37:57 <mm_freak> ski: but this sucks:  instance (Monad m) => Functor (X m)
01:38:25 <mm_freak> if you use Functor instead of Monad, then you will have (Functor m, Monad m) all over your code
01:39:00 <mm_freak> ski: consequently you can't use DeriveFunctor
01:40:05 <mm_freak> and also liftM is usually slower than fmap
01:40:28 <ski> `Monad m => Functor (X m)' as opposed to ?
01:40:54 <mm_freak> instance (Functor f) => Functor (X f)
01:41:35 <mm_freak> example:  newtype StreamT m a = StreamT { step :: m (a, StreamT m a) }
01:41:47 <mm_freak> this is an applicative functor
01:42:04 <mm_freak> if you add another type argument it becomes a Category, which needs m to be a monad
01:42:25 <mm_freak> newtype AutoT m a b = AutoT { step :: a -> m (b, AutoT m a b) }
01:42:34 <mm_freak> instance (Monad m) => Category (AutoT m)
01:42:51 <ski> ok, synchronous (effectful) stream processor
01:43:27 <fylwind> is there a way to move the position of the stream in Parsec? (forward and/or backwards)
01:43:42 <mm_freak> now if you base its Functor instance on Functor m, then something like liftA2 f (x . y) z will have a constraint like this:  (Applicative m, Monad m) => AutoT m X Y
01:44:04 <mm_freak> and this sucks
01:44:19 <mm_freak> fylwind: only by parsing/failing
01:44:26 <fylwind> I see
01:46:05 <fylwind> so let's say I have 'try A <|> B'; how would I communicate some information from A to B when A fails?
01:46:44 <fylwind> hrm I guess I can use the state ...
01:46:46 <erisco> :t try
01:46:47 <lambdabot> Exception e => IO a -> IO (Either e a)
01:47:07 <petapetapeta> Hello. Can I use Cabal to install a different branch of a package?
01:47:43 <mm_freak> fylwind: i'm not sure that would work
01:48:06 <mm_freak> i'm worried about the associativity of (<|>)
01:48:26 <ski> fylwind : i'm wondering why you need to communicate information there
01:50:39 <fylwind> because the way B parses will depend on how A has failed
01:52:09 <petapetapeta> Ah. I figured it out. There was a Setup.hs file I should run
01:52:09 <ski> perhaps you can provide more elaboration ?
01:52:55 <mbrock> Parsec's user state is rewound on failure, no?
01:55:07 <mm_freak> mbrock: i didn't check, but i'm sure it has to
01:55:13 <mm_freak> otherwise (<|>) won't be associative
01:56:42 <fylwind> an attempt to parse an indentation-sensitive language: if indent is >= current level then (if indent is > current level, then call parser for sub-expression with new level, else parse rest of the line) else (fail without consuming indent)
01:57:15 <fylwind> the trick here is that if I call the sub-expression parser, i would prefer to rewind back to the beginning of the line
01:57:41 <mbrock> can you perhaps use lookAhead?
01:57:45 <fylwind> it can be done without being so, but it's less messy if it starts at the beginning
01:58:02 <fylwind> i was thinking of that, but then that means i have to parse a 2nd time if the look ahead turns out to be useful
01:58:11 <fylwind> s/useful/successful/
01:58:48 <fylwind> though the real thing is that I can't think of a better way of parsing an indentation-sensitive language
01:59:08 <mm_freak> fylwind: you can always add more cases
01:59:14 <mm_freak> a <|> b <|> c <|> …
01:59:20 <petapetapeta> I'm attempting to run a Setup.hs file with configure, but it fails with the following message: "Setup.hs: At least the following dependencies are missing: cmdargs -any, ghc-paths -any".
01:59:34 <petapetapeta> However I've just installed both of them with cabal
01:59:44 <fylwind> I'm trying to keep as much logic within Parsec as possible because once i'm out of Parsec I lose the debugging information (line / col #)
02:22:50 <mel-> Hi. I need to read/parse rather big data structures (the are few megabytes big, containing a lot of bytestrings). parsing it with maybeRead (i.e. 'read') is very slow. I have the remark online that using readP instead might improve performance. but it's not clear to me how to use it. could anyone give me a hint? thanks.
02:27:40 <mel-> I mean, what I basically need is some way to make large haskell data structures persistent in an efficient way. if that would include some mapping haskell data structures <-> suitable binary format, that would also be fine wit hme
02:33:50 <erisco> > listToMaybe [1..]
02:33:51 <lambdabot>   Just 1
02:36:47 <luite> mel-: use binary or cereal for serialization instead
02:45:37 <djang0nub> im starting out learning haskell and i have a question - why does the time cost of the ++ operator depend on the size of the first list? if lists are implemented internally as linked lists, why not just store a pointer to the end of the list too?
02:46:00 <liyang> I'm writing some stuff to output GMail-compatible filters as XML that can be imported. What module hierarchy should I put it under? Really struggling with this. :-/
02:47:21 <ski> djang0nub : because someone else might hold a reference to the first list (or some of its tails), and we don't want to clobber that view of the (original) first list by updating-in-place
02:47:23 <arnsholt> djang0nub: For one thing, the list could be circular. In which case there isn't actually an end
02:48:25 <ski> djang0nub : after `zs = xs ++ ys', we still want `xs' to be the same list as before
02:48:40 <djang0nub> ski: ah yes.. immutability
02:48:45 <djang0nub> thank you
02:48:46 <ski> yes
02:48:53 <elliott> liyang: I hear Data is a good place to put every module
02:49:33 <ski> djang0nub : but also note that immutability also means that we often don't need to copy inputs (because they can't change), where a mutable datastructure would often require more "safety" copying
02:49:43 <liyang> elliott: Data.XML.Google.Mail.Filters?
02:50:26 <elliott> Data.Control.Network.Text.LiyangsPackage
02:50:48 <elliott> it's data because the filters are data, control because they decide what emails get filtered, network because of email, and text because they look at the text of the messages. any questions?
02:50:51 <djang0nub> ski: well we dont, but the interpreter will i.e its less work for a programmer in that case, but still the same performance hit right?
02:51:03 <liyang> I don't want my package to be exposed, especially not to you guys.
02:53:12 <liyang> elliott: in all seriousness, this is the hardest part of writing the thing.
02:53:32 <ski> djang0nub : hm, i'm not quite sure what you mean
02:54:17 <ski> by "interpreter" are you talking about a Haskell implementation (perhaps an interactor), or are you talking about some specific interpreter for some language, written in Haskell ?
02:54:40 <djang0nub> ski: i meant a Haskell implementation, something that runs my haskell code basically
02:54:46 <elliott> liyang: how about Acme.*?
02:55:02 <ski> (also, "we dont" ? we don't what ?)
02:55:05 <liyang> s/Acme/Google/
02:55:23 <liyang> The two companies are indistinguishable.
02:55:38 * ski . o O ( <http://upload.wikimedia.org/wikipedia/commons/9/98/Acme.png> )
02:55:53 <erisco> > Just 1 *> ((,) <$> Just 2 <*> Just 3)
02:55:54 <lambdabot>   Just (2,3)
02:56:03 <erisco> is there a nicer way to do this without the parens?
02:56:11 <djang0nub> ski: and i was just pointing out that with mutable structures, the copying of inputs would be explicitly specified by the programmer, whereas with immutable structures, they would be copied implicitly by the haskell implementation
02:56:18 <ski> > Just 1 *> liftA2 (Just 2) (Just 3)
02:56:19 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b0'
02:56:19 <lambdabot>              with actual...
02:56:22 <ski> er
02:56:26 <ski> > Just 1 *> liftA2 (,) (Just 2) (Just 3)
02:56:27 <lambdabot>   Just (2,3)
02:57:01 <erisco> eh doesn't read that nice either frankly
02:57:10 <ski> djang0nub : no, no implicit copying is needed (apart from copying of pointers/references, but that's cheap)
02:58:31 <erisco> > Just 1 *> $ (,) <$> Just 2 <*> Just 3
02:58:32 <lambdabot>   <hint>:1:11: parse error on input `$'
02:58:36 <erisco> I'd really want something like that to work :)
02:58:42 <donri> djang0nub: you don't copy a list wholesale, you just make new links between shared elements
02:58:42 <erisco> :t Just 1 *>
02:58:43 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
02:58:50 <erisco> :t (*>) Just 1
02:58:51 <lambdabot> Num (a -> b) => a -> b
02:58:57 <ski> @type (Just 1 *>)
02:58:58 <lambdabot> Maybe b -> Maybe b
02:59:20 <erisco> > (Just 1 *>) $ (,) <$> Just 2 <*> Just 3
02:59:21 <lambdabot>   Just (2,3)
03:00:30 <donri> djang0nub: but anyway list is but one option available to you in haskell. you can even have safe, pure local mutation if you must.
03:00:35 <erisco> > (Just 1 *>) $ (id) <$> Just 2 *> Just 3
03:00:38 <lambdabot>   Just 3
03:01:28 <supki> > Just 1 *> both id (Just 2, Just 3)
03:01:30 <lambdabot>   Just (2,3)
03:01:59 <erisco> > (Just 1 *>) $ (id) <$> Just 2 <* Just 3
03:02:00 <lambdabot>   can't find file: L.hs
03:02:22 <erisco> stop getting rid of my <$> lol
03:02:31 <erisco> > (Just 1 *>) $ (id) <$> Just 2 <* Just 3
03:02:32 <lambdabot>   Just 2
03:08:26 <t4nk199> Hi, I would like to write extension in Yi editor, the config file for yi is ~/.config/yi/yi.hs, but  this file cannot export any functions, I found this file is the only one can be dynamiclly recompiled, what I miss? what is the suggested way to write extension?
03:16:51 <djang0nub> > [ x ++ y | x <- ['a'..'e'], y <- ['A'..'E']]
03:16:52 <lambdabot>   Couldn't match expected type `[a0]'
03:16:52 <lambdabot>              with actual type `GHC.Type...
03:17:32 <ski> > [[x,y] | x <- ['a' .. 'e'] , y <- ['A' .. 'E']]
03:17:33 <lambdabot>   ["aA","aB","aC","aD","aE","bA","bB","bC","bD","bE","cA","cB","cC","cD","cE"...
03:17:52 <ski> > liftM2 (,) ['a' .. 'e'] ['A' .. 'E']
03:17:53 <lambdabot>   [('a','A'),('a','B'),('a','C'),('a','D'),('a','E'),('b','A'),('b','B'),('b'...
03:18:08 <djang0nub> ski: lol, thank you again. just learning haskell.
03:19:09 <ski> `x' and `y' above are characters, not lists; hence you can't use `(++)' on them
03:19:39 * hackagebot aws-cloudfront-signer 1.0.0.1 - For signing AWS CloudFront HTTP URL requests  http://hackage.haskell.org/package/aws-cloudfront-signer-1.0.0.1 (ChrisDornan)
03:20:15 <djang0nub> ski: yup. why does this work: [ x : y : []  | x <- ['a'..'e'], y <- ['A'..'E']] whereas this doesnt: [ x :: y  | x <- ['a'..'e'], y <- ['A'..'E']]
03:20:22 <djang0nub> > [ x : y : []  | x <- ['a'..'e'], y <- ['A'..'E']]
03:20:23 <lambdabot>   ["aA","aB","aC","aD","aE","bA","bB","bC","bD","bE","cA","cB","cC","cD","cE"...
03:20:29 <djang0nub> > [ x :: y  | x <- ['a'..'e'], y <- ['A'..'E']]
03:20:32 <lambdabot>   Couldn't match expected type `y' with actual type `GHC.Types.Char'
03:20:32 <lambdabot>    `y' i...
03:20:58 <djang0nub> i meant  [ x : y  | x <- ['a'..'e'], y <- ['A'..'E']]
03:21:00 <ski> first, you probably intended `x : y' there, not `x :: y'
03:21:05 <ski> aye :)
03:21:06 <djang0nub> > [ x : y  | x <- ['a'..'e'], y <- ['A'..'E']]
03:21:26 <ski> well, `:' takes a list on the right, and an element which can be put into such a list on the left
03:21:35 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
03:21:35 <lambdabot>              with actual ty...
03:21:37 <ski> and `x : y : []' means `x : (y : [])'
03:22:03 <ski> iow : add the element `y' to the left of the empty list, then the element `x' to the left of the resulting list
03:22:18 <ski> but if you say `x : y', then `y' has to be a list, but in your case it wasn't
03:22:28 <djang0nub> ski: d'oh. cons operator.. yes.
03:22:52 <ski> > [x : ys  | x <- "012" , ys <- ["abc","de"]]  -- this works, however
03:22:53 <lambdabot>   ["0abc","0de","1abc","1de","2abc","2de"]
03:23:01 <ski> because here `ys' *is* a list
03:23:07 <ski> (a string is a list of characters)
03:23:39 <ski> (btw, `[x,y]' is just syntactic sugar for `x : y : []'; they mean the same)
03:24:22 <Benzi-Junior> Anyone here had problems with GHC chrashing when trying to set up Happstack ?
03:24:49 <djang0nub> ski: yes, that all makes sense now! :)
03:24:57 <donri> Benzi-Junior: nope. what's the error and what were you trying?
03:24:59 <donri> @lpaste
03:24:59 <lambdabot> Haskell pastebin: http://lpaste.net/
03:25:22 <ski> djang0nub : hth :)
03:28:06 <Benzi-Junior> donri: I have been using Cabal to try to set it up but I get: panic! (the impossible happened) when its compiling happstack/internal/socket
03:28:36 <donri> Benzi-Junior: what ghc version? is this on windows?
03:31:03 <Benzi-Junior> donri: The Glorious Glasgow Haskell Compilation System, version 7.4.1, and no not windows
03:32:48 <donri> Benzi-Junior: i vaguely recall something about some issue related to ipv6 or something, not sure. :p
03:33:01 <donri> but i think it was windows-only...
03:34:22 <Benzi-Junior> Can't happen: pprExp (CompExp [])
03:35:04 <Benzi-Junior> donri: after the panick message it says Can't happen: pprExp (CompExp [])
03:35:23 <erisco> is there a function to fix two mutually recursive functions?
03:35:37 <donri> Benzi-Junior: perhaps post to the mailing list or file a bug, or ping stepcut in #happs when he's awake
03:36:32 <ski> @type \f_ g_ -> let f = f_ f g; g = g_ f g in (f,g)
03:36:32 <lambdabot> (t -> t1 -> t) -> (t -> t1 -> t1) -> (t, t1)
03:38:02 <erisco> (a -> b) -> (b -> a) -> ??? guess the problem is, what is the return type?
03:38:14 <supki> Benzi-Junior: can you paste the output of  ghc-pkg list template-haskell  ?
03:39:45 <donri> supki: i don't think it's a TH issue, the constructor is CompE not CompExp in TH
03:40:30 <supki> well
03:40:38 <supki> pprExp _ (CompE []) = error "Can't happen: pprExp (CompExp [])"
03:40:49 <donri> oh. hah.
03:40:57 <erisco> f :: (a -> b) -> a   g :: (b -> a) -> b
03:41:20 <Benzi-Junior> supki: WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
03:41:23 <Benzi-Junior> /var/lib/ghc/package.conf.d template-haskell-2.7.0.0
03:41:26 <Benzi-Junior> /home/bjarki/.ghc/x86_64-linux-7.4.1/package.conf.d template-haskell-2.8.0.0
03:41:38 <donri> Benzi-Junior: your ghc install is broken
03:41:39 <elliott> it sounds like you have broken packages!
03:41:43 <alexander__b> can someone help me figure out what kind of magic my op class needs to do in http://bpaste.net/show/fYPggnMKeVpmm7TX2ZxS/ ?
03:41:47 <alexander__b> it's an rpn calculator
03:42:13 <alexander__b> I do op (*), op negate, op (pi :: Double) and other things, right? so I need... uhm... arity polymorphism or something?
03:46:18 <DMcGill> alexander_b: one nice method I've seen is to treat the stack as nested tuples. So `push :: a -> stack -> (a, stack)' and `add :: (Int, (Int, stack)) -> (Int, stack)'
03:47:13 <startling> is there a (prelude-extras) Eq1 instance for Eq1 f => Eq1 (Free f) somewhere?
03:47:34 <alexander__b> DMcGill: | don't immediately see what this accomplishes
03:47:43 <Benzi-Junior> donri: I looked through the problems and they all seem to result from haddock-html or haddock-interfaces any suggestions on how to fix that?
03:48:31 <zomg> Getting into slightly bigger and more complex Haskell programs, it's interesting to see how the language solves things you do in OO languages
03:48:39 <jmcarthur> i think something is happening that goes against my mental model of evaluation in ghc
03:49:04 <zomg> Like in OO you often have to pass around some dependencies and such, or initialize an object with a bunch of other objects as its params etc.
03:49:21 <zomg> While in Haskell you would partially apply a function and pass it, or perhaps use a Reader monad
03:49:27 <jmcarthur> oh, before i bother explaining, i'm going to try something i just thought of
03:51:11 <jmcarthur> meh, okay, i'm still at a loss
03:51:33 <erisco> ah, I cannot possibly define this. good to know.
03:51:44 <jmcarthur> in ghci, i defined a value x. in its definition, i use Debug.Trace such that when i evaluate x i see some output
03:52:13 <jmcarthur> i'm observing that if i run  x `seq` True  more than once, my trace executes every time instead of just the first time
03:52:46 <erisco> I could only do it for right associativity
03:52:50 <erisco> but I need left
03:53:17 <erisco> so the return type is unknowable... hence the only thing to do is make a variant of the two types
03:53:18 <bscarlet> jmcarthur: What do you get if you say "let y = x in (y `seq` True, y `seq` True)"
03:53:27 <jmcarthur> good idea
03:53:36 <Walther> Hm. Does haskell have any native libraries / whatcha call 'em for handling iso 8601 dates?
03:53:58 <jmcarthur> bscarlet: i still see it twice
03:54:23 <Walther> say, I want to store a file with dates and durations in iso8601, be able to import them, and manipulate the data
03:54:24 <bscarlet> care to lpaste so others can try?
03:54:45 <startling> Oh, I guess it might not be possible.
03:54:45 <Walther> e.g. calculate durations of events, times between events, etc
03:55:19 <jmcarthur> bscarlet: it's reproducible without anything fancy. just   let x = trace "foo" x; let y = x in (y `seq` True, y `seq` True)
03:56:08 <jmcarthur> ah sorry
03:56:12 <jmcarthur> let x = trace "foo" 5
03:56:15 <jmcarthur> or somsuch
03:56:20 <jmcarthur> not recursive, of course
03:56:42 <jmcarthur> maybe it's a ghci quirk
03:57:41 <HugoDaniel> http://functionaltalks.org/2013/08/26/john-carmack-thoughts-on-haskell/
03:57:41 <bscarlet> jmcarthur: I can't get two foos in ghci.
03:57:50 <jmcarthur> weird!
03:57:56 <bscarlet> what ghci are you using?
03:58:08 <jmcarthur> The Glorious Glasgow Haskell Compilation System, version 7.6.3
03:58:19 <bscarlet> double weird. me too.
03:59:05 <bscarlet> what OS?
03:59:19 <valyagolev> > trace "foo" 4
03:59:20 <lambdabot>   Not in scope: `trace'
03:59:29 <jmcarthur> and now i have managed to make one expression that does it and one that doesn't
03:59:29 <valyagolev> > Debug.Trace.trace "foo" 4
03:59:30 <lambdabot>   Not in scope: `Debug.Trace.trace'
03:59:39 <jmcarthur> linux
03:59:49 <valyagolev> what are they?
04:00:14 <jmcarthur> hold on, let me try a fresh ghci session with none of my other code... shouldn't make a difference because i'm only using pure stuff apart from trace itself
04:00:45 <jmcarthur> woah what
04:01:04 <jmcarthur> it's fine now
04:01:17 <jmcarthur> okay, i guess i need to work on cutting down my context
04:02:08 <Walther> So I repeat my question - any sane ways (well, as sane as it is itself...) to deal with dates, times, and durations in haskell?
04:02:32 <elliott> there is the time package
04:02:40 <Walther> say I want to essentially have calendar events be parsed to iso8601 and calculate durations of events and times between events
04:03:09 <jmcarthur> bscarlet: ah, no, this expression does it reliably for me, even in a fresh session:    let y = trace "foo" 5 in (y `seq` True, y `seq` True)
04:04:04 <bscarlet> jmcarthur: I only get it once.
04:04:10 <jmcarthur> :(
04:04:18 <bscarlet> jmcarthur: 7.6.3, linux
04:04:56 <bscarlet> jmcarthur: a fresh fresh session, or fresh in the sense of not your original but possibly with preceeding context?
04:05:26 <startling> I think I get it twice.
04:05:55 <donri> Benzi-Junior: your best bet is to wipe ~/.ghc and reinstall anything local
04:06:12 <jmcarthur> bscarlet: fresh as in a freshly launched ghci, not loading any of the modules i was working on
04:06:19 <startling> jmcarthur, I get "(foo\nTrue,foo\nTrue)"
04:06:26 <jmcarthur> startling: ah, you too!
04:06:42 <valyagolev> fine for me, still
04:06:42 <jmcarthur> so, i found that if i move my .ghci aside then it works as expected
04:06:43 <startling> jmcarthur: isn't that expected behavior?
04:07:00 <jmcarthur> startling: why? (especially given this inconsistency with .ghci?)
04:07:10 <bscarlet> jmcarthur: I have no .ghci. What's in yours?
04:07:30 <startling> jmcarthur: oh, you're surprised by the lack of sharing.
04:07:31 <jmcarthur> normally a lot, but it does it even with just a :set prompt
04:07:35 <jmcarthur> startling: right
04:08:00 <startling> jmcarthur, I bet you have :set -XNoMonomorphismRestriction
04:08:28 <jmcarthur> startling: not in this case (i do normally)
04:09:09 <startling> weird. I do, and more extensive sharing is touted as one of the motivations for the monomorphism restriction.
04:09:40 <jmcarthur> startling: actually, maybe that is it. maybe i screwed up my test somewhere along the lines here
04:09:54 <Benzi-Junior> donri: what should be in ~/.ghc because I have no such dir
04:10:11 <startling> jmcarthur, btw, there's --ignore-dot-ghci
04:10:13 <donri> Benzi-Junior: have you been doing sudo cabal install?
04:10:28 <elliott> jmcarthur: I wonder if trace uses the dupable kind of unsafePerformIO.
04:10:28 <bscarlet> jmcarthur: I put your line in a file so I could run it with runhaskell. I get one "foo" if I just run it, two if I run it w/ -XNoMonomorphismRestriction
04:10:30 <jmcarthur> startling: good call, that is it
04:10:35 <elliott> aw.
04:11:00 <startling> jmcarthur: cool. :)
04:11:11 <jmcarthur> and indeed, this did come up when the thing i was forcing was polymorphic
04:11:25 <Benzi-Junior> donri: in some cases yes ... I do have a ~/.cabal though
04:11:29 <ski> alexander__b : what's the tree for ?
04:11:30 <bscarlet> jmcarthur: one again if I change y from (trace "foo" 5) to (trace "foo" (5 :: Int))
04:11:35 <alexander__b> anyone care to guess what the type signature even would be for class Op in here: http://bpaste.net/show/fYPggnMKeVpmm7TX2ZxS/ ? lol
04:11:36 <adnap> Is it possible to add class constraints to type parameters in a data declaration, such as data Applicative f => T (f a) = T (f a) ? Is this a sensible thing to want to do?
04:11:37 <alexander__b> ski: history
04:11:50 <alexander__b> ski: so that I can prettyprint a tree with the stack and where an error occured
04:11:56 <jmcarthur> but it's still weird. shouldn't MonoLocalBinds mean that it does apply to  let y = trace "foo" 5 in (y `seq` True, y `seq` True)  ?
04:11:59 <jmcarthur> *doesn't
04:12:10 <startling> adnap: it's possible with an extension for backwards-compatibility but it's not a good idea.
04:12:14 <alexander__b> ski: so if 2 2 + + fails, prettyprint the stack
04:12:27 <ski> alexander__b : so, what function of type `Stack -> Either Error Stack' should `op pi' be ?
04:12:35 <adnap> Wouldn't GADTS allow this, since they allow constructor functions?
04:12:44 <alexander__b> ski: that's the problem :-P
04:12:56 <startling> adnap: it doesn't do what you want; you'd still need constraints for most functions iirc and it disallows some useful instances.
04:13:03 <Benzi-Junior> [
04:13:11 <startling> ]
04:13:16 <ski> alexander__b : if `Solution' was just `Double', then i think i could do it, but i'm not sure what to put in the `Tree String' in the `Solution'
04:13:34 <ski> @karma+ startling
04:13:34 <lambdabot> startling's karma raised to 5.
04:13:55 <adnap> I was thinking about making a zipper for Applicative f => f [a] ...
04:14:04 <yitz> hmm no one answering in #diagrams. can anyone here answer a newbie diagrams question?
04:14:21 <donri> Benzi-Junior: in that case i think it'll be easier to just wipe your whole ghc installation completely, globally.
04:14:31 <donri> Benzi-Junior: and avoid sudo cabal in the future
04:14:45 <startling> adnap: more information: http://www.haskell.org/haskellwiki/Data_declaration_with_constraint
04:15:04 <adnap> startling: Thanks. I was looking at that already
04:15:05 <yitz> nm ClaudiusMaximus is there now :)
04:15:06 <donri> Benzi-Junior: but it might be that you just need to wipe something like /usr/local/lib/ghc-*
04:15:07 <ski> adnap : you can add constraints on parameters in GADTs, yes (if you do it on a plain `data', the result probably won't be what you expect)
04:15:45 <donri> Benzi-Junior: http://www.vex.net/~trebla/haskell/sicp.xhtml
04:16:15 <jmcarthur> amazing. there is no telling how many times i fooled myself into thinking something i wrote was insufficiently lazy because of this
04:16:29 <startling> jmcarthur: heh.
04:16:30 <jmcarthur> it doesn't even need NoMonomorphismRestriction, just polymorphism
04:16:32 <donri> Benzi-Junior: according to that it might be in /root/.ghc though
04:16:44 <jmcarthur> (of course)
04:16:52 <Benzi-Junior> donri: let me guess when I sudo cabal install it views my file system from the viewpoint of / instead of ~ and puts all the packages in different places and that may cause problems
04:17:11 <adnap> Can I import the Id monad from somewhere?
04:17:25 <ski> @index Identity
04:17:26 <lambdabot> Control.Monad.Identity, Control.Monad.Identity
04:17:29 <donri> Benzi-Junior: apparently not, actually. according to that link it does the same thing, only with $HOME = /root
04:17:32 <adnap> ski: Thanks
04:18:11 <donri> Benzi-Junior: unless you also used --global
04:19:30 <Benzi-Junior> donri: well I have no /home/root but I'll look through the other places you suggested
04:19:45 <zeroXten> i'm playing with tryhaskell.org and find the syntax of step21 really weird
04:19:47 <donri> Benzi-Junior: just /root, no /home
04:19:49 <zeroXten> specifically, let (a:b:c:[]) = "xyz" in a
04:20:06 <alexander__b> ski: OK let's try that then, and I'll try to work in history some other way later
04:20:09 <startling> zeroXten: what's weird about it?
04:20:10 <ski> alexander__b : anyway, perhaps something like `class Op t where {op :: t -> Stack -> Either Error Stack}; instance Op Double where {op x s = Right ((x,Node "?" []): s)}; instance Op t => Op (Double -> t) where {op f [] = Left "stack empty"; op f ((x,_):s) = op (f x) s}' ?
04:20:18 <zeroXten> thats what I'm trying to work out :)
04:20:26 <zeroXten> startling: ^
04:20:45 <ski> > let a:b:c:[] = "xyz" in a
04:20:46 <lambdabot>   'x'
04:20:55 <startling> zeroXten, have you been introduced to pattern-matching?
04:21:12 <ski> > splitAt 3 "foobar"
04:21:13 <startling> ski: for some reason I doubt zeroXten is referring to the parens. ;)
04:21:13 <lambdabot>   ("foo","bar")
04:21:24 <zeroXten> thats the section i'm on.. i get it
04:21:28 <ski> > let (front,back) = splitAt 3 "foobar" in back ++ front
04:21:29 <lambdabot>   "barfoo"
04:21:45 <zeroXten> a:b:c:[] is "xyz" so a = x, b = y and c = z
04:21:55 <zeroXten> but I can't mentally translate the syntax
04:21:58 <ski>   a = 'x'  -- hrm
04:21:59 <startling> zeroXten: right. do you know what : is?
04:22:08 <zeroXten> yeah
04:22:18 <zeroXten> shift operator basically
04:22:28 <startling> not quite.
04:22:36 <ski> more like "add element to front of list" operator
04:22:42 <zeroXten> isn't that a shift?
04:22:45 * zeroXten googles
04:22:57 <zeroXten> ahh, unshift
04:22:59 <zeroXten> duh
04:23:03 <adnap> So... if I wanted to make a type that could hold any applicative, how would I do it?
04:23:07 <ski> i think "shift" is often (in shells) interpreted as "drop front element from list/stack" ?
04:23:08 <startling> zeroXten, also, : is a construct.
04:23:13 <startling> or
04:23:19 <startling> *a constructor
04:23:23 <adnap> I guess just data Foo a = Foo a
04:23:23 <Cale> zeroXten: x:xs is the list whose first element is x and whose tail is xs
04:23:30 <Cale> > 1 : [2,3,4,5]
04:23:32 <lambdabot>   [1,2,3,4,5]
04:23:32 <zeroXten> Cale: yeah
04:23:34 <adnap> And then asume a is an applicative.
04:23:35 <valyagolev> adnap you can try defining a class, and instance (Applicative a) => MyClass a
04:23:38 <zeroXten> thats all nice and simple
04:23:43 <ski> adnap : depends on what you want to do
04:23:51 <zeroXten> let XXX = YYY in ZZZ
04:23:51 <Cale> Every list is either [] or it is (x:xs) for some element x and list xs
04:23:58 <zeroXten> what are XXX, YYY and ZZZ?
04:23:59 <startling> zeroXten: that is, the list type is defined as "the empty list or a : someOtherList"
04:24:18 <zeroXten> is ZZZ a "block"?
04:24:29 <donri> zeroXten: new List<T>(T head, List<T> tail)
04:24:36 <ski> zeroXten : `YYY' is an expression, `XXX' is a "pattern", which is "matched" with the result of evaluating the expression, thus "binding" variables, which can then be used in the expression `ZZZ'
04:24:39 <startling> zeroXten: XXX is a pattern, YYY is an expression, ZZZ is an expression
04:24:47 <Cale> zeroXten: XXX would be a pattern (usually just a variable, but could match against constructors), YYY is an expression, and ZZZ is another expression.
04:24:54 <erisco> Cale, heya
04:24:55 <ski> > let x = 3+3 in x*X
04:24:56 <valyagolev> YYY is a set of (pattern = expression)
04:24:56 <lambdabot>   Not in scope: data constructor `X'
04:24:57 <ski> > let x = 3+3 in x*x
04:24:59 <lambdabot>   36
04:25:00 <Cale> erisco: hi
04:25:10 <valyagolev> ah, no
04:25:11 <valyagolev> sorry
04:25:12 <ski> here the `x' to the left of `=' is a very simple pattern, just a variable name
04:25:18 <zeroXten> so, comparing that to let add1 x = x + 1 in map add1 [1,5,7]
04:25:37 <zeroXten> we'd have let XXX = YYY in ZZZ
04:25:38 <Cale> zeroXten: In that case, you have a function binding, rather than a pattern binding
04:25:38 <ski> matching a variable with a value (here the result of evaluting `3+3') just "binds" that variable to that value
04:26:08 <Cale> zeroXten: You can tell the difference because add1 starts with a lowercase letter, so it can't be a data constructor.
04:26:16 <Cale> So it must be a function being defined.
04:26:17 <zeroXten> Cale: so the only thing different is the XXX?
04:26:29 <Cale> yeah
04:26:51 <Cale> In that case, you're defining add1 bringing it into scope in ZZZ
04:27:06 <zeroXten> exactly
04:27:11 <ski> (and `x' is only defined in the function body expression `x + 1')
04:27:27 <zeroXten> but in the case of the pattern it isn't really doing that? The pattern has nothing to do with functions?
04:27:50 <Cale> With a pattern binding, you're again binding a variable or some variables to some values
04:27:54 <ski> function bindings and pattern bindings are somewhat different, yes
04:27:57 <Cale> But there are no function parameters
04:28:01 <zeroXten> ahh ok
04:28:13 <zeroXten> I couldn't see how the 'a' was available in teh scope of ZZZ
04:28:39 <Cale> > let (x,y) = fst (("hello", 5), 'c') in y
04:28:40 <lambdabot>   5
04:28:45 <ski> `let a:b:c:[] = "xyz" in a' has a pattern binding
04:28:53 <Cale> > let ((x,y),z) = (("hello", 5), 'c') in y
04:28:54 <lambdabot>   5
04:28:57 <ski> > let (front,back) = splitAt 3 "foobar" in back ++ front  -- also does
04:28:58 <lambdabot>   "barfoo"
04:29:28 <ski> > let pair = splitAt 3 "foobar" in snd pair ++ fst pair  -- another way of saying the same thing
04:29:29 <lambdabot>   "barfoo"
04:29:45 <erisco> ski, hmm
04:29:51 <Cale> > let (less, greater) = partition (<5) [5,9,1,6,2,8,0,4] in less ++ greater
04:29:52 <lambdabot>   [1,2,0,4,5,9,6,8]
04:29:54 <erisco> ski, I'm perplexed by what you have created
04:30:15 <ski> erisco : what did i create ?
04:30:17 <Cale> > let (less, greater) = partition (<5) [5,9,1,6,2,8,0,4] in (less, greater)
04:30:18 <lambdabot>   ([1,2,0,4],[5,9,6,8])
04:30:31 <erisco> ski \f_ g_ -> let f = f_ f g; g = g_ f g in (f,g)
04:30:31 <ski> > partition (<5) [5,9,1,6,2,8,0,4]
04:30:34 <lambdabot>   ([1,2,0,4],[5,9,6,8])
04:30:45 <ski> erisco : what about it ?
04:30:59 <erisco> ski, I don't quite understand what is happening :D
04:31:31 <Cale> > let (x:y:z:[]) = [1,2] in x -- this will fail
04:31:32 <lambdabot>   *Exception: <interactive>:3:5-22: Irrefutable pattern failed for pattern (x...
04:31:53 <ski> adnap : hm .. "I was thinking about making a zipper for Applicative f => f [a]" -- well, applicatives compose
04:32:10 <ski> erisco : how about `\f_ -> let f = f_ f in f', then ?
04:32:17 <ski> @type \f_ -> let f = f_ f in f
04:32:18 <lambdabot> (t -> t) -> t
04:32:23 <Cale> > let (x:y:z:[]) = [1,2] in 5 -- this, interestingly enough, won't, because we don't make use of any of the bound variables, so it never has a chance to find out that the pattern doesn't match
04:32:24 <lambdabot>   5
04:33:09 <ski> zeroXten : anything unclear in the explanations yet ?
04:33:11 <adnap> ski: A problem I ran into is that I can't write coreturn (w a -> a)
04:33:40 <Cale> I'm just giving lots of examples, hopefully some or all of them make sense -- feel free to ask questions :)
04:34:39 <ski> adnap : hm, so now you're thinking comonads ?
04:34:47 * hackagebot aws-cloudfront-signer 1.1.0.0 - For signing AWS CloudFront HTTP URL requests  http://hackage.haskell.org/package/aws-cloudfront-signer-1.1.0.0 (ChrisDornan)
04:35:08 <adnap> ski: Well, a zipper is supposed to be a comonad, right? That's how I was introduced to them.
04:36:02 <ski> hm, i was thinking you were thinking about `[]' as `ZipList' as an applicative functor
04:36:17 <erisco> ski, I'm just trying to figure out if it can actually be productive
04:38:02 <ski> > (take 5 *** take 5) ((\f_ g_ -> let f = f_ f g; g = g_ f g in (f,g)) (\f g -> 0 : g) (\f g -> 1 : f))  -- productive
04:38:05 <lambdabot>   ([0,1,0,1,0],[1,0,1,0,1])
04:39:17 <ski> > (($ 4) *** ($ 6)) ((\f_ g_ -> let f = f_ f g; g = g_ f g in (f,g)) (\f g x -> case x of 0 -> True; _ -> g (x-1)) (\f g x -> case x of 0 -> False; _ -> f (x-1)))  -- and this
04:39:18 <lambdabot>   (True,False)
04:40:19 <ski> erisco : anything unclear ?
04:40:34 <erisco> ski, the implications are bewildering me, but you've been plenty clear
04:41:46 <ski> the first is basically just `let zerosAndOnes = 0 : onesAndZeros; onesAndZeros = 1 : zerosAndOnes in (zerosAndOnes,onesAndZeros)'
04:42:17 <erisco> I'm trying to apply this to another problem, is the main thing
04:42:20 <ski> the second being `let even 0 = True; even x = odd (x-1); odd 0 = False; odd x = even (x-1) in (even,odd)'
04:42:35 <ski> ok (?)
04:49:47 <erisco> ski, thanks for the help
04:50:17 <ski> np
04:59:32 <startling> where do people normally import data Fix f = Fix (f (Fix f)) from?
04:59:49 <edwardk> startling: recursion-schemes provides it
05:00:21 <startling> ah. I was intimidated by the lack of haddocks and the funny names.
05:05:17 <Chat1037> Hi
05:07:55 <satc> I have a class with a dat family. How do I export the constructor when I am defining the instance of that class?
05:08:00 <satc> *data
05:21:53 <donri> satc: it's probably X(Cons) where X is either the data family type or the type class
05:23:27 <mal___> silly beginners question. is there a way at a point in a program to print out the type of an entity that has been computed?
05:24:46 <donri> mal___: type holes in future ghc, but for now you can fake them by intentionally adding a type error
05:25:31 <donri> > length ("hi" :: Int) -- will tell you "hi" is actually a String
05:25:36 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:25:36 <lambdabot>              with actual type ...
05:25:48 <nh2> how can I find where a stack space overflow is happening when I don't know where it is?
05:26:13 <mal___> lol good idea. I hadn't thought of that. simply tacking + 1 after it will also do I guess.
05:26:49 <Saizan> nh2: you should be able to get a stack trace with the profiling libs
05:28:14 <nh2> Saizan: I'm running with +RTS -hc, but the output is not very useful
05:28:49 <nh2> for example: I get three stack traces instead of one, each claiming to have its own exception
05:29:24 <Saizan> afaik the option is -xc, but -hc might work too
05:30:17 <nh2> Saizan: sorry I meant -xc
05:30:51 <Saizan> 3 stack traces sounds like different threads
05:31:04 <lpaste> nh2 pasted “stack traces in HSE” at http://lpaste.net/92215
05:31:22 <nh2> Saizan: I put the output in the lpaste
05:31:35 <apfelbox> how can I work around import cycles?
05:31:50 <nh2> I do not think that multiple threads are involved, I think haskell-source-exts cannot do that
05:32:36 <applicative> apfelbox: dont make import cycles? there are the mysterious boot files, though
05:33:02 <nh2> apfelbox: circular imports are possible in a certain situation, but usually not recommended. If you can make an example on what you want to achieve we might be able to make a suggestion on how to remove the cycle
05:33:15 <apfelbox> So, indirect recursion of functions in different files cannot work?
05:33:57 <applicative> well, you get wild mutual recursion inside files
05:34:00 <nh2> Saizan: do you see though the THUNK_1_0 and the THUNK_STATIC differences in my output?
05:34:20 <nh2> I don't know what the difference between them is
05:35:09 <applicative> apfelbox: is it just two files?
05:35:14 <arian_> https://www.youtube.com/watch?v=MpxvJ1J-Z2s Comonads explained in terms of inside-out burritos. worth the watch
05:35:35 <apfelbox> applicative: yes, pairs of two files actually.
05:36:12 <edwardk>  american ordinary swedish meantime?
05:36:15 <edwardk> er mealtime?
05:36:25 <Guest87714> haha
05:36:36 <Guest87714> actually ordinary swedish mealtime is a parody on this thing
05:36:37 <Saizan> nh2: THUNK_1_0 is a generic partial application iirc, they are names for the kind of closures built on the heap
05:37:25 <Guest87714> edward. Enjoyed the  haskell podcast a lot btw.
05:38:05 <manek> Hello! Is it possible to set cutom formatter to the root logger (with default handler) in hslogger? I can create custom handler and set formatter (as shown here: http://hackage.haskell.org/packages/archive/hslogger/latest/doc/html/System-Log-Logger.html)
05:38:09 <haasn> edwardk: so did I!
05:38:19 <manek> but I want to change the default formatter.
05:38:25 <edwardk> Guest87714: thanks =)
05:38:44 <Guest87714> But like I said on reddit, I should experiment with lenses a bit more. Because it was mind-boggling, haha.
05:38:58 <haasn> edwardk: it was interesting hearing about how you stumbled upon Haskell :)
05:39:24 <Guest87714> I'm not even sure how I stumbled upon haskell.
05:39:27 <edwardk> i was hoping to try to convey a bit of a sense of wonder about some nice abstractions, but i kind of forgot i was in an audio medium that people play when distracted in the middle, so i got a bit too technical
05:39:43 <edwardk> haasn: heh. i blame Cale.
05:40:05 <Guest87714> Wait I remember. I was building a  green-threads library in C, so I could do concurrency for my atmega chip. and then I stumbled upon haskell I think
05:40:26 <Guest87714> Then I realized haskell wasnt something low-level and I forgot about it again.
05:40:39 <edwardk> i popped on the channel to ask a question about something and he was there being so damned nice explaining stuff to someone who wants clearly out of his depth, but i had no idea what he was talking about
05:40:45 <Guest87714> then a year or so later, the name suddenly got stuck in my head and I picked up some books :P
05:40:57 <edwardk> heh
05:41:04 <Guest87714> Next year, we're getting haskell introductory class at uni.  It's gonna be fun.
05:41:18 <quchen> Can someone tell me what's wrong here? I get a parse error for record matching: http://lpaste.net/4975761441102495744
05:41:27 <edwardk> Guest87714: i think you'll find that an intro class in haskell won't go nearly as far as you get on your own
05:41:38 <Guest87714> Yes I realized that myself as well
05:41:50 <nh2> Saizan: any idea about how I can find which one is relevant for me?
05:41:59 <edwardk> isLocalDef { gre_prov = LocalDef } = True doesn't parse to me
05:42:10 <edwardk> isLocalDef Foo{ gre_prov = LocalDef } = True
05:42:13 <apfelbox> Ok, I fixed my import cycle (with a hack :D)
05:42:24 <nh2> apfelbox: oh no, hacks!
05:42:26 <edwardk> that would work if the constructor that provides gre_prov was named Foo
05:42:31 <ski> quchen : missing data constructor
05:42:38 <Guest87714> I wish there was some community of 'young people learning haskell'..  as of this moment, I only know one person of my age who is studying haskell as well.
05:42:42 <apfelbox> I just pass the function from the first module into the second function...
05:42:53 <mal___> hmmmm say I have a list of filenames. I map a function on them that gives IO Something giving me [IO Something]. Is there a way to convert that into IO [Something]?
05:43:00 <edwardk> Guest87714: there is a haskell-beginners mailing list on haskell.org
05:43:05 <Guest87714> ah neat.
05:43:08 <edwardk> Guest87714: it is probably the closest
05:43:14 <ski> mal___ : `sequence (map foo names)' or better `mapM foo names'
05:43:22 <nh2> Guest62936: young people are all around
05:43:23 <ski> @src mapM
05:43:23 <lambdabot> mapM f as = sequence (map f as)
05:43:28 <Guest87714> I'm actually thinking of doing an introductory course on game-design with elm  at my previous high-school.
05:43:29 <ipuustin> question about QuickCheck: can I do IO in Arbitrary instances?
05:43:39 <ski>   sequence :: [IO a] -> IO [a]  -- in this case
05:43:39 <Guest87714> Wondering if kids would like it.
05:43:42 <edwardk> that way you don't have to feel guilty spamming the haskell-cafe with newbie questions, but there are a lot of people in here who are happy to continue the tradition of bringing new people up to speed
05:43:42 <ski> ipuustin : no
05:43:44 <quchen> edwardk, ski: You have to specify the data constructor explicitly because what you're matching on could be a sum of records types?
05:43:45 <ipuustin> I would need to read possible test values from the ssytem.
05:43:52 <mal___> ski: thanks. I'm kind of struggling with haskell. my weapon of choice is Common Lisp :)
05:44:13 <edwardk> quchen: mostly because they just never opened up the possibility to anything else
05:44:14 <nh2> ipuustin: there is some dubious function for that
05:44:24 <Guest87714> edwardk: that's great. I've just wrapped my head around monadic programming. Now looking into  Foldable etc (Hey I gotta understand that lens library someday)
05:44:26 <edwardk> quchen: you can also use view patterns
05:44:40 <ipuustin> nh2: you mean unsafePerformIO?
05:44:44 <edwardk> isLocalDef (gre_prov -> LocalDef) = ...
05:44:48 <nh2> ipuustin: no, morallyDubiousIOProperty
05:44:48 * mbrock was 15 when he started to learn Haskell :)
05:45:10 <edwardk> Guest87714: a laudable goal. one of these days i'll understand it too
05:45:10 <quchen> edwardk: Oh, right. That's probably even more what I want.
05:45:23 <ipuustin> nh2: ok, I'll take a look at that
05:45:36 * edwardk was 32 or so
05:45:49 * Guest87714 was 17
05:45:50 <nh2> ipuustin: not sure if it is what you mean because it's not in the arbitrary instance, but maybe it helps your purpose
05:46:11 <ski> mal___ : often `mapM_' is used instead of `mapM'; namely when the results are not desired -- cf. `dolist'
05:46:23 <Guest87714> I actually think declaritive programming would be easier for high-school students than imperative programming
05:46:30 <Guest87714> people just dont experiment with it enough at schools
05:46:37 * applicative was thinking in haskell in the womb; it took a while to learn how to read and write it though
05:46:55 * mbrock is still an unevaluated thunk
05:47:03 <ski> ipuustin : you do you need to do it from within `Arbitrary' ?
05:47:07 <mal___> ski: thanks. in this case I really want the results.
05:47:14 * ski forces mbrock
05:47:19 <t7> mbrock: is bottom
05:47:25 <ski> @src mapM_
05:47:25 <lambdabot> mapM_ f as = sequence_ (map f as)
05:47:34 <applicative> > error "mbrock"
05:47:35 <lambdabot>   *Exception: mbrock
05:47:41 <haasn> edwardk: “explaining stuff to someone who wants clearly out of his depth, but i had no idea what he was talking about” <- and now you seek to replicate the same experience for newcomers?
05:47:54 <Saizan> nh2: i'd go for fix
05:47:59 <ipuustin> ski: yes. I want to ask from system a list of possible values a generator can provide.
05:48:01 <mbrock> no fair, at most you can seq me!
05:48:08 * elliott was 11; do I win?
05:48:14 * ski escapes into a different thread, `killThread'ing the original
05:48:44 * Guest87714 deepseq mbrock (error "hey")
05:49:28 <Guest87714> Ohwell. I'm off to work. I should make a freenode account sometime, and hang around on IRC channels a bit more.
05:49:31 <Guest87714> Toodles!
05:49:47 <edwardk> haasn: pretty much
05:50:02 <mbrock> yeah it's a bit hard to tell you apart from my good friend Guest83341
05:50:08 <mbrock> see you later!
05:50:25 <Guest87714> mbrock: cheers!
05:50:28 <edwardk> elliott: yes, but now i see you as a little nerdy kid with glasses
05:50:29 <ski> ipuustin : and you can't use `... -> IO (Arbitrary Foo)' ?
05:50:30 <nh2> ipuustin: for that, you can write your own gen locally
05:50:37 <elliott> edwardk: hah
05:51:02 <elliott> I'm just shachaf's sidekick. or is he mine?
05:51:03 <nh2> ipuustin: Arbitrary is just the "standard way" for a type to provide a gen, you can make your own gen and then use it with `forAll`
05:51:28 <ski> (er, s/Arbitrary/Gen/ i of course meant)
05:52:32 <ipuustin> nh2, ski: thanks for advice! I'll need to examine generators further.
05:53:06 <nh2> ipuustin: so you can do: do{ data <- getSystemData ; let gen = ..construct gen.. ; forAll gen (\x -> ...) }
05:53:09 <nh2> ipuustin: something like that
05:55:45 <nh2> Saizan: how did you conclude that?
05:58:27 <Saizan> nh2: the other stuff is on the path to that, it seems
06:01:03 <nh2> Saizan: this kind of problem is a pain in haskell
06:01:23 <nh2> I just changed my stack traces significantly by putting a simple Debug.Trace.trace somewhere :/
06:02:49 <nh2> Saizan: I think I found it. It's not good :(
06:05:58 <apfelbox> If I browse throught the docs, like here: http://www.haskell.org/ghc/docs/7.0.1/html/libraries/ghc-7.0.1/Var.html#t:Var
06:06:06 <apfelbox> and see, that Var is a instance of Show Var
06:06:22 <apfelbox> why does `show var` not work? (var is an instance of Var)
06:07:06 <supki> these are docs for ghc-7.0.1
06:07:18 <supki> you're probably not using it :)
06:08:42 <apfelbox> supki: it's so obvious, thanks!
06:11:14 <Saizan> nh2: can't be good, it's overflowing :)
06:12:32 <nh2> Saizan: I'll continue in #ghc now that I believe to know where it is
06:20:57 <Cale> apfelbox: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-7.6.3/Var.html
06:21:40 <apfelbox> Cale: thanks, I already saw that I used old docs :(
06:22:22 <Cale> I just thought I'd link the new ones
06:22:43 <Cale> There is this class Outputable which might be useful
06:24:01 <nh2> Saizan: liftM2cont f m1 m2 = runContT (liftM2 f (lift m1) (lift m2)) return ?
06:24:35 <nh2> Outputable sucks unfortunately because you need silly dynflags for everything
06:24:43 <Cale> apfelbox: If you have a DynFlags, then you can showPpr :: Outputable a => DynFlags -> a -> String
06:24:45 <Cale> right
06:24:58 <nh2> and usually the only thing it's good for is silly line wrapping :/
06:25:12 <apfelbox> nh2: I just thought the same... Do I really have to drag the dynflags through all my calls?
06:25:27 <nh2> I wish more things had show instances for debugging (I actually managed to sneak one in with my last commit, yeah!)
06:25:45 <Saizan> nh2: no, i don't think that's going to help
06:25:57 <Saizan> nh2: you want the recursion going through ContT
06:26:06 <nh2> apfelbox: that depends on whether you are debugging or writing real code - for debugging, you can hack yourself a show instance, and if it's proper one hopefully push it
06:26:31 <nh2> if you are not debugging, you probably want to do the line wrapping so you need the grumpy dflags
06:27:01 <nh2> if you are in the session/ghc monad or whichever it is, you can also get the dflags from the session
06:27:02 <Saizan> nh2: i'd just rename leafFix to leafFixCont, then define leafFix fixs e = runContT (leafFixCont fixs e) return
06:27:13 <apfelbox> For example I try to get a representation of a Name from a Var.
06:27:15 <Cale> Maybe you could use getOccString here?
06:27:24 <Cale> oh, getName
06:27:31 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-7.6.3/Name.html#t:NamedThing
06:27:33 <apfelbox> (I am trying to write a small compiler and need the name of a function call)
06:28:28 <nh2> apfelbox: in a case like that you probably want to obtain the name in a non-show way (not even Outputable), like Cale said
06:29:02 <ski> @type \f m0 m1 -> runContT (liftM2 f (lift m0) (lift m1)) return
06:29:03 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:29:17 <apfelbox> I am in the code generation phase, so I actually need a string
06:29:29 <apfelbox> getOccString gives me a (non fqn) name
06:29:33 <ski> looks like `liftM2'
06:31:01 <apfelbox> http://www.haskell.org/ghc/docs/7.6.3/html/libraries/ghc-7.6.3/CoreSyn.html if I do code generation, I have to append the unique to the var name myself?
06:31:27 <Saizan> ski: yeah, i'm pretty sure it's operationally equivalent too
06:31:57 <ski> ought to be
06:32:27 <tomboy64> i work a lot with data that is ordered in 1 or 2 planes, e.g. has indices like 1,2,3 or (1,1), (1,2), (1,3),...(2,1),(2,2),(2,3) - what would be the best way to organize it in terms of retrievability?
06:32:34 <ski> `lift . f =<< lift m  =  lift (f =<< m)', i'd assume
06:32:42 <tomboy64> e.g. that i need a little time as possible to retrieve it?
06:33:20 <Saizan> ski: "\n m -> runCont (replicateM n m) return" isn't though because it "trampolines" the recursion
06:33:20 <tomboy64> so far i usually use Data.List.lookup or find in a Set
06:33:28 <ski> tomboy64 : perhaps an array ?
06:33:45 <ski> @type \n m -> runCont (replicateM n m) return
06:33:48 <lambdabot> Monad m => Int -> ContT (m [a]) Identity a -> m [a]
06:33:56 <Saizan> ehm, add a lift
06:33:58 <ski> @type \n m -> runCont (replicateM n (lift m)) return
06:33:59 <lambdabot> Monad m => Int -> Identity a -> m [a]
06:34:08 <tomboy64> hmm
06:34:17 <Saizan> @type \n m -> runContT (replicateM n (lift m)) return
06:34:19 <lambdabot> Monad m => Int -> m a -> m [a]
06:35:07 * hackagebot skein 1.0.4 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-1.0.4 (FelipeLessa)
06:35:09 * hackagebot esqueleto 1.3.3 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.3 (FelipeLessa)
06:35:32 <ski> Saizan : hm, apart from strictness issues, what's the difference ?
06:36:43 <tomboy64> ski: that looks good
06:36:52 * tomboy64 goes afk reading
06:36:55 <applicat1ve> tomboy64: what are the indices and what the data? the indices are (2,3) etc.
06:36:56 <tomboy64> thanks :)
06:37:02 <applicat1ve> oh
06:37:20 <tomboy64> applicat1ve: pardon?
06:37:21 <Saizan> ski: well, it should turn the recursive call of replicateM effectively tail-recursive, no? because it will just go down in the recursion with a bigger continuation
06:37:57 <applicat1ve> tomboy64: i was just making sure arrays were the type you wanted, but it seems they are. What are you 'storing'
06:39:47 <tomboy64> applicat1ve: different things, ranging from Strings over Ints, Integers, sometimes just Bools
06:40:03 <ski> Saizan : yep, though of course not in constant space
06:40:07 * hackagebot fb 0.14.10 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.14.10 (FelipeLessa)
06:40:58 <tomboy64> applicat1ve: it seems they are not 100% what i want since often it's without bounds. e.g. analogous to an infinite list or a Set
06:41:46 <applicat1ve> tomboy64: yes, the standard lazy array type is like that; things like UArray are essential finite though. on the other hand they cant hold strings
06:42:30 <ski> the lazy array still has fixed bounds
06:42:47 <applicat1ve> ski: right, I was thinking of something different, lazy construction
06:42:56 <ski> > array (0,undefined) [(0,2),(1,3)]
06:43:00 <lambdabot>   array *Exception: Prelude.undefined
06:43:10 <ski> > array (0,1) [(0,2),(1,3)]
06:43:11 <applicat1ve> which is admittedly different from potential infinity
06:43:14 <lambdabot>   array (0,1) [(0,2),(1,3)]
06:43:36 <tomboy64> hmm. i do actually need potential infinity
06:43:41 <tomboy64> (sometimes)
06:44:23 <ski> perhaps a `Map' would suffice ?
06:44:48 <tomboy64> Data.Map?
06:45:33 <tomboy64> ahh, kind of like an indexed Set
06:45:38 <tomboy64> yes, that looks good
06:45:42 <tomboy64> thanks again :)
06:46:43 <apfelbox> why does `foldl (++) xx []` expect xx to return Char?
06:46:47 <apfelbox> why no String?
06:47:14 <startling> :t foldl
06:47:17 <lambdabot> (a -> b -> a) -> a -> [b] -> a
06:47:25 <startling> :t foldl (++)
06:47:29 <lambdabot> [a] -> [[a]] -> [a]
06:47:46 <tomboy64> ahhh, yes, that is very good! now i'm happy :)
06:48:01 <applicat1ve> tomboy64: sometimes the 'unordered-containers' version of data map is better http://hackage.haskell.org/packages/archive/unordered-containers/0.2.3.1/doc/html/Data-HashMap-Strict.html just dont use lookupDefault
06:48:31 <Cale> > foldl (++) "z" ["a","b","c"]
06:48:34 <lambdabot>   "zabc"
06:48:44 <ski> > M.fromList [(i,i^2+1) | i <- [0 ..]]  -- no actual infinite `Map', though
06:48:52 <lambdabot>   mueval-core: Time limit exceeded
06:48:56 <applicat1ve> ah indeed
06:49:10 <ski> tomboy64 : but there's still no fixed bounds on a `Map'
06:49:59 <tomboy64> applicat1ve: why do you say it's better?
06:50:00 <ski> @type ?xx `asTypeIn` \xx -> foldl (++) xx []
06:50:03 <lambdabot> (?xx::[a]) => [a]
06:50:20 <applicat1ve> tomboy64: oh, it's generally distinctly faster
06:50:31 <tomboy64> ski: where? in hashmap? or map?
06:50:33 <applicat1ve> tomboy64: its in the haskell platform so you probably have it
06:50:37 <ski> @type undefined `asTypeIn` \xx -> foldl (++) xx []  -- i suppose
06:50:41 <lambdabot> [a]
06:50:58 <tomboy64> applicat1ve: can you make a speed-statement about array vs hashmap?
06:51:12 <apfelbox> ah, I actually wanted concat
06:51:39 <b2coutts> @src concat
06:51:40 <lambdabot> concat = foldr (++) []
06:52:35 <applicat1ve> tomboy64: oh, wouldn't know what to say about that; it's just Data.Hashmap is often faster than Data.Map ; it has a further constraint of course
06:53:05 <nh2> Saizan: uhm Occurs check: cannot construct the infinite type m0 = ContT (Exp SrcSpanInfo) m0
06:53:32 <apfelbox> foldr vs foldl *doh*
06:54:21 <Saizan> nh2: code and more of the error?
06:54:30 <ski> > foldr f z [a,b,c]
06:54:31 <ski> > foldl f z [a,b,c]
06:54:39 <lambdabot>   f a (f b (f c z))
06:54:39 <lambdabot>   can't find file: L.hs
06:54:51 <ski> > foldl f z [a,b,c]  -- bah
06:55:15 <lambdabot>   f (f (f z a) b) c
06:55:26 <ski> nh2 : ooc, what are you trying to do ?
06:56:31 <nh2> ski: http://www.haskell.org/pipermail/haskell-cafe/2013-August/108570.html and https://github.com/haskell-suite/haskell-src-exts/issues/27
06:56:34 <Saizan> nh2: ah, maybe you just need to turn that recursive call to leafFix into leafFixCont
06:57:07 <Saizan> nh2: btw you should try with -O2
06:57:14 <nh2> Saizan: it works if I put a type signature (leafFix had none so far)
06:57:14 <Saizan> nh2: or at least -O
06:57:35 <nh2> Saizan: using cabal, so -O is on
06:57:49 <Saizan> nh2: when compiling your test program too
06:58:43 <nh2> Saizan: I put an O2 but still the same problem
06:58:51 <nh2> (independent from that, I think code should always work, with O0 or not)
06:58:55 <Saizan> nh2: it's still better to make the recursive call to leafFixCont
06:59:11 <nh2> Saizan: i'll try
06:59:33 <nh2> Saizan: where though?
06:59:54 <Saizan> nh2: line 284
07:00:24 <nh2> Saizan: that's not used, I put a trace in front of each case and only the App case is used
07:00:57 <nh2> Saizan: I'm running that on https://raw.github.com/ghc/testsuite/master/tests/perf/compiler/parsing001.hs so I guess you can see why :D
07:01:35 <Sculptor> hi
07:01:37 <Saizan> nh2: it's still better in the general case
07:02:02 <Saizan> nh2: and yeah, maybe pathological code like that is just going to be considered out of scope for the library
07:03:42 <nh2> Saizan: I don't think so. One of my purposes with this is to show that the stack-optimized sequence / mapM that we have in base are probably the wrong thing
07:04:26 <Saizan> nh2: it really depends on the monad
07:04:27 <nh2> Saizan: *any* code will break if it uses mapM and some strict monad, and *everything* uses mapM
07:04:33 <Saizan> nh2: for some they are exactly the good thing
07:04:47 <nh2> Saizan: yes but they break very common cases like IO
07:05:04 <startling> is there something like newtype Fix1 f a = Fix1 (f (Fix1 f a) a) somewhere?
07:05:13 <Saizan> nh2: also, if your lists are so big and do need to stay in memory then you probably want another datastructure
07:05:56 <nh2> Saizan: why? 800k is a perfectly small list, that's just a few MB ram
07:06:35 <nh2> and a linked list like [a] is the right data structure for many operations, and there is no replacement
07:06:38 <ski> nh2 : ok .. and `leafFix' ?
07:06:43 <ski> lo Sculptor
07:06:54 <Sculptor> o/
07:07:12 <Saizan> nh2: there's better stuff like chunked vectors and similar
07:07:24 <ski> startling : .. itym `newtype Fix1 f a = Fix1 (f (Fix1 f) a)'
07:07:43 <Saizan> nh2: each cons cell is quite big
07:07:44 <nh2> Saizan: still chunked vectors are not linked lists, and they don't unbreak mapM
07:08:03 <startling> ski, nope.
07:08:20 <startling> ski: (wouldn't that just be your standard Fix?)
07:08:22 <nh2> Saizan: what does it have to do with memory size?
07:08:22 <ski> startling : oh, so just knot in the other argument
07:08:33 <ski> (startling : yep, though with different kind)
07:08:48 <nh2> ski: what did you mean by " ok .. and `leafFix' "?
07:09:03 <startling> ski, "just knot in the other argument"?
07:09:50 <nh2> Saizan: mapM someIOAction mylist is a common thing, and if you encounter a mapM somewhere, chances are quite high it is the IO monad
07:10:07 <ski> (`Fix :: (* -> *) -> *', and for my `Fix1 :: ((* -> *) -> (* -> *)) -> (* -> *)', while for your `Fix1 :: (* -> (* -> *)) -> (* -> *)')
07:10:32 <ski> nh2 : just wondering where it's coming from
07:11:10 <nh2> ski: where the stack overflow is coming from? I don't actually know that yet :( My suspicion was that it was one of the mapMs (that's how it's related to my issue)
07:12:09 <Saizan> nh2: and if mylist is small enough then it's fine, an 800k list is already around 150mb with the cons cells alone
07:12:24 <ski> nh2 : where `leafFix' is coming from
07:13:56 <nh2> Saizan: are programs that use 150 mb uncommon haskell programs?
07:13:58 <Saizan> nh2: it would be better if mapM/sequence worked just fine in all use cases, but i don't think optimizing for big lists in strict monads is the most useful one
07:14:14 <nh2> Saizan: but this is not about optimizing, this is about breaking
07:14:37 <Saizan> you'll break the other side if you change mapM
07:15:09 <Saizan> you either have it broken like currently, or broken for lazy monads that want the streaming behaviour
07:15:20 <nh2> take any IO doing library on hackage. It will use mapM and it will break given a list large enough
07:15:43 <nh2> Saizan: not necessarily, e.g. if ghc makes the stack size unlimited by default
07:15:48 <Saizan> i don't think mapM is used often enough where it's expecting large lists
07:16:17 <Saizan> nh2: oh, ok, if the stack size is unlimited then we can keep this definition
07:16:29 <nh2> Saizan: anything that does something with the file system will exceed the limits easily
07:17:29 <Saizan> nh2: i'm not convinced of that
07:18:01 <nh2> Saizan: https://github.com/ndmitchell/shake/blob/e0e0a43/Development/Shake/Database.hs#L394
07:18:03 <Saizan> anyhow this is mostly a matter of statistics, we should measure rather than argue
07:18:26 <nh2> Saizan: I measured. It breaks for 1M Ints
07:19:05 <roconnor> I rarely use mapM in IO.
07:19:33 <Saizan> yeah, we also need to measure how often mapM gets used in places which are going to get 1M long lists
07:19:34 <roconnor> If I'm in a strict monad, I'm probably using mapM_
07:20:08 <applicative> oh nh2 is talking about mapM not mapM_ , I was wondering ...
07:21:13 <roconnor> granted, I not using mapM is probably a learned behavour
07:22:19 <Saizan> but we also need to measure how often the lazy nature of the current mapM makes a difference
07:22:33 <tomboy64> applicative: were you talking about this as further constraint? " A map cannot contain duplicate keys; each key can map to at most one value. "
07:22:56 <applicative> tomboy64: just that the keys have to be 'hashable'
07:23:10 <tomboy64> uh?
07:24:00 <tomboy64> hm
07:24:01 <nh2> roconnor: 1) I doubt it is rarely used, I have already with a bunch of projects regarding this issue only today, ghc, cabal, haddock, haskell-src-exts included. 2) :: Int -> m a -> m [a] must work for any [a], not "some small [a]"
07:24:28 <elliott> mapM in a strict monad is kind of bad news.
07:24:35 <elliott> compared to mapM_.
07:24:39 <applicative> the operations in Data.Map require an Ord instances, which is how they keep things straight; Data.Hashmap.{Strict,Lazy} uses a Hashable instance
07:24:51 <nh2> mapM_ is not what I want to use in my cases
07:24:59 <nh2> e.g. in my first example:  list <- replicateM 1000000 randomIO :: IO [Int]
07:25:09 <nh2> I want that list, and I need it completely
07:25:20 <nh2> generating two lists with different elements using mapM_ is not an option
07:25:28 <tomboy64> applicative: then i would have to use Data.Hashmap anyway, since (1,2) can be hashed, but not ordered.
07:25:43 <applicative> it has an Ord instance too, actually
07:25:56 <applicative> > (0,2) < (0,3)
07:26:01 <lambdabot>   True
07:26:03 <Saizan> nh2: better find an example which can't be done without monads :)
07:26:20 <nh2> Saizan: "but we also need to measure how often the lazy nature of the current mapM makes a difference" <- what do you mean exactly?
07:26:25 <tomboy64> oh
07:26:26 <nh2> Saizan: without monads?
07:26:31 <tomboy64> hehe
07:26:32 <tomboy64> right
07:26:50 <tomboy64> > (1,3) < (0,4)
07:26:57 <roconnor> nh2: fmap randoms getStdGen works fo rme.
07:26:58 <Saizan> nh2: as we said in the past, there's no real reason to use randomIO there
07:27:23 <tomboy64> > (0,2) < (0,3)
07:27:36 <tomboy64> lambdabot =
07:27:38 <tomboy64> =
07:27:40 <tomboy64> ?
07:27:52 <lambdabot>   False
07:27:53 <lambdabot>   True
07:27:56 <roconnor> nh2: otherwise if you want lazily generated IO, you need to use something like pipes/interatees
07:27:58 <tomboy64> ah
07:27:59 <tomboy64> finally
07:28:05 <nh2> roconnor: no I don't want lazy IO
07:28:07 <Saizan> nh2: i mean that if we never quite make use of the fact that the current definition is better behaved with lazy monads then that'd be an argument in favour of switching it to an accumulator-based definition
07:28:30 <roconnor> nh2: no one wants to use a 1Meg list strictly
07:28:38 <nh2> Saizan, roconnor: randomIO is just an example, you can't replace e.g. file system operations, socket receives or anything like this like you can replace with a stdgen
07:28:56 <roconnor> nh2: I know, that is why I suggest using Pipes.
07:29:00 <Saizan> nh2: btw, changing mapM is not going to fix haskell-src-exts alone
07:29:30 <Saizan> s/alone/by itself/
07:29:35 <roconnor> nh2: no one wants 1M list pulled into memory.
07:29:45 <nh2> roconnor: what has pipes to do with the issue? No streaming is needed, no lazy IO replacement is being sought for
07:30:03 <nh2> roconnor: of course one wants to
07:30:11 <roconnor> nh2: then I don't see the problem.
07:30:35 <roconnor> nh2: you have 1M IO actions you want to perfrom, I get that.
07:31:02 <roconnor> nh2: but you either want to lazily produce a "list" meaning lazy IO/pipe, or you want to put them into a strict data structure, which means not lists.
07:31:16 <roconnor> nh2: or you have a small list
07:31:19 <roconnor> that's it.
07:31:32 <nh2> roconnor: why would I want to pull them into a data type that is not a list?
07:31:53 <nh2> if you receive from a socket until it says stop, a list is the data structure you want to receive into
07:32:17 <roconnor> nh2: I'd use something like pipes for that.
07:32:22 <nh2> and how is a mapM / replicateM etc. not appropriate for that?
07:32:43 <roconnor> Because you don't want to bring megabytes of data into RAM.
07:33:06 <nh2> roconnor: why? You want them all into memory. Pipes are a sane alternative to give the benefits of lazy IO. Here no lazy IO is to be replaced
07:33:26 <haasn> It's a real shame Accelerate is nVidia-only :(
07:33:35 <elliott> things can have purposes beyond their original intention as replacements
07:33:48 <nh2> roconnor: you want to bring the megabytes of data into ram. Imagine you receive a million messages via a socket and want to sort them
07:33:52 <Saizan> or at least i'd want the data in a more memory-compact representation
07:33:55 <nh2> that is a perfectly valid use case
07:34:04 <haasn> I want to do some GPU programming but I have an AMD GPU
07:34:08 <haasn> and OpenCL looks dreadful
07:34:12 <nh2> Saizan: that would require you to use memory where you cannot cons in constant time
07:34:15 <t7> opencl is a standard
07:34:26 <t7> cuda is rubbish
07:34:37 <roconnor> nh2: if I want to sort them then I'd use pipes to stream the data into a balanced binary tree.
07:34:52 <applicative> nh2: if you want to sort a zillion bytestrings, this is a problem in any case, no?
07:35:00 <nh2> roconnor: how is that better than a list? It uses even more memory.
07:35:06 <haasn> t7: yeah, but if I understand it correctly, to work with OpenCL I'm going to have to write my kernels in its language; as opposed to something that looks more like high-level Haskell
07:35:11 <haasn> eg. as with Accelerate
07:35:20 <Saizan> nh2: there are ways to make it almost constant time with the right "builder"
07:35:52 <nh2> applicative: a million Ints is a very feasible data set to work on
07:35:55 <roconnor> nh2: I'm sorry, but you are just wrong about using mapM here.  I'm sorry you cannot see that.
07:36:39 <nh2> roconnor: why? I don't get how the binary tree is better than the list
07:36:42 <applicative> nh2 yes but is there a problem with a list of a million ints?
07:37:17 * applicative isn't objecting to nh2's inquiry of course
07:37:45 <nh2> applicative: I think there should not, but I cannot construct it using mapM, replicateM etc because it will crash
07:38:12 <applicative> what is main, the one with randoms?
07:38:39 <nh2> Saizan: but that builder is exactly a replacement for single linked lists then, is it not?
07:39:04 <nh2> applicative: what do you mean by "what is main"?
07:39:21 <applicative> i just mean what did you compiler
07:39:23 <applicative> compile
07:39:51 <applicative> why aren't you using e.g. mwc-random if you are using random Ints
07:40:24 <nh2> applicative: I just used randomIO as an example for any arbitrary IO action you want to repeatedly run
07:40:35 <nh2> socket receive would be just as good
07:40:49 <Saizan> nh2: it's going to be used in place of [a] but it's not the same, evey N elements received they'll go into a better representation
07:41:11 <nh2> (probably I should have used this as an example because you can actually replace randomIO by a single IO action and continue pure with that, so it does not quite pose the problem)
07:41:13 <applicative> oh i see replicateM 1000000 randomIO
07:41:58 <nh2> Saizan: until the a batch of N elements is received to be stored in a continuous chunk, they will be stored in a linked list, right?
07:42:24 <nh2> (or a data structure isomorphic to a linked list)
07:42:33 <Saizan> nh2: does it matter? the details can differ
07:43:14 <nh2> Saizan: what I mean is: how does the discussion change if you replace [a] by an equivalent with a different name? Only so that replicateM doesn't work any more on it?
07:43:42 <Saizan> maybe i'm allocating a block of memory and unsafePerforming my way into writing into it instead of using a linked list for temorary storage
07:44:10 <Saizan> nh2: it's not equivalent
07:44:44 <nh2> Saizan: but how is unsafePerformIO an alternative for replicateM N myaction?
07:44:51 <Saizan> nh2: and yeah, the point is that if you are doing stuff like this then you shouldn't be using replicateM so such use cases have less weight on how replicateM should behave
07:45:15 <Saizan> nh2: the writing into some datastructure part is the same
07:45:31 <nh2> Saizan: why should I not use replicateM? The only reason I cannot use it is because it crashes
07:45:55 <geekosaur> "makr it work for my case, I dont care who else's cases break"
07:45:57 <Saizan> nh2: because you should be using other data structures
07:46:35 <nh2> would ghc come with an infinite stack, hiding the fact that it *arbitrarily* (from the language view) allocates some things on the stack than on the heap, the problem would not exist
07:46:44 <nh2> geekosaur: that is my point
07:47:10 <Saizan> i'd be fine with an unlimited stack, but i don't see that happening
07:47:14 <nh2> Saizan: which data structures should I use if I need a linked list to buffer incoming IO data into?
07:47:56 <Saizan> nh2: lazy bytestrings or lazy Text, built with some of the Builder types, and you might want to look into pipes
07:48:32 <Saizan> geekosaur, nh2: i don't see the unlimited stack happening, but i'm not against that. If it doesn't happen then we have to decide _which_ use cases we want to break
07:49:08 <Saizan> we can't have it work for all of them with finite stack
07:49:13 <nh2> Saizan: what if I receive integers? Also, if I receive my text in 20 byte chunks, lazy BS and Text won't help me (they will actually use much more memory because of the minimum callocated chunk size)
07:49:14 <elliott> nh2: can't you just make the stack bigger?
07:49:18 <elliott> if you really want to.
07:50:06 <Saizan> nh2: are you getting 1M of chunks or not?
07:50:09 <nh2> Saizan: yes I would prefer breaking none of these cases, treating lists equally infinite no matter which way they are created
07:50:45 <Saizan> of elements, or whatever
07:50:57 <Saizan> vectors can hold Ints
07:51:16 <nh2> elliott: me making my stack size bigger does not fix replicateM being "partial" on others computers
07:51:19 <Saizan> there's probably some Builder type for them too
07:51:53 <elliott> nh2: yes, you have to run programs with runtime settings that can support what they do on your computer
07:52:03 <elliott> you can tell GHC to assume certain RTS options by default IIRC
07:52:07 <elliott> in e.g. the cabal file
07:52:39 <Saizan> yeah, you can give the runtime options with -rtsops=.. (or similar) at compile time
07:52:54 <elliott> I think it's --with-rtsopts
07:53:08 <Saizan> *nod*
07:54:01 <nh2> elliott: that's right, but no one does that, and you cannot pass an option to make the stack infinite, which is the only option that will work given that you cannot know how big the user input is (e.g. the files on their hard drive or the number of things they receive from a socket)
07:54:29 <elliott> nh2: ok, so what do you want?
07:54:34 <startling> nh2, well, you don't have infinite memory anyhow.
07:54:40 <elliott> if it's for GHC to use an infinite stack, then you could ask on the Trac or whatever.
07:54:45 <elliott> "no one does that" seems silly though.
07:54:55 <elliott> people do it when their programs need it, or else they change their programs; we've given advice on both
07:55:05 <elliott> and who cares about what everyone else does? it's your program
07:55:34 * hackagebot skein 1.0.5 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-1.0.5 (FelipeLessa)
07:55:35 <nh2> startling: right, but I also don't have to set how much memory I want to use in the heap
07:56:04 <Saizan> well, we should have the saner defaults in the stdlib, but to decide sanity we have to decide use cases
07:56:08 <nh2> it would be weird to work like "OK, do I use mapM somewhere? Does it use stack in my case? How much stack will I need for all my mapMs? I better set that in the cabal file"
07:56:24 <elliott> it's more like you up the stack limit when your program crashes. :p
07:56:32 <elliott> or don't use huge lists.
07:56:36 <elliott> (that you don't consume incrementally)
07:56:46 <Saizan> (and produce so!)
07:56:50 <elliott> right.
07:57:34 <nh2> elliott: what I want (what I currently think would be better than changing code) is to treat heap and stack space equally unlimited
07:58:33 <elliott> ok. I suspect that will have drawbacks (e.g. performance and such, masking things like insufficiently strict folds that stack overflow quickly as-is), it'd probably have to be opt-in and such
07:58:36 <startling> nh2, on account of the first option only requires patching GHC? ;)
07:58:37 <elliott> but you could ask for it
08:00:43 <nh2> elliott: I am not sure about the drawbacks
08:01:17 <nh2> startling: I imagine making the stack unlimited not to be a difficult change given that it already grows dynamically, but that is just an assumtion
08:01:23 <Saizan> (btw a server that can be made to use arbitrary amounts of memory according to the requests is not a good server)
08:01:39 <elliott> nh2: of course. because you support the change :)
08:01:47 <elliott> anyway, I recommend asking mailing lists or on the trac
08:02:06 <elliott> since at this point it requires expertise/more long-form discussion for meaningful technical input, I think
08:02:33 <nh2> Saizan: a server that cannot receive 1M requests into a list while having > 150mb ram is not a good server either
08:03:37 <startling> nh2, that's not necessary in any case.
08:05:48 <nh2> I need to go and catch my train. Thanks for the discussion so far!
08:06:30 <ski> yw
08:09:55 <identity> I want to create and pass a mutable array to use as a cache to a pure function, that does some work with it, calls itself recursively passing the array to itself again. Is it possible to create an STRef containing this STArray and pass it around, or should the function as a whole just be in the ST monad?
08:10:05 <roconnor> reverseSequence = Data.Foldable.foldlM (\a -> Control.Monad.liftM (:a)) []
08:10:24 <roconnor> reverseSequenceIO = Data.Foldable.foldlM (\a -> evaluate a >> Control.Monad.liftM (:a)) []
08:18:26 <ParahSailin> identity: how do you create an STRef that is not in the ST monad?
08:20:48 <roconnor> identity: As I recall it is impossible to hold an STArray without being inside a single instance of an ST monad; which would imply that your function must as a whole be in the ST monad.
08:21:23 <roconnor> identity: it would be common to write a helper function that uses the ST monad and then wrap that inside a pure funciton.
08:21:35 <roconnor> very common
08:22:05 <ski> identity : do you want distinct (non-recursive) calls to the function to access the same cache ?
08:24:19 <ski> @type Data.Foldable.foldlM (\a -> Control.Monad.liftM (:a)) []
08:24:20 <lambdabot> (Monad m, Foldable t) => t (m a1) -> m [a1]
08:24:24 <ski> @type Data.Foldable.foldlM (\a -> Control.Monad.liftM (:a)) []
08:24:25 <lambdabot> (Monad m, Foldable t) => t (m a1) -> m [a1]
08:24:34 <ski> @type Data.Foldable.foldlM (\a m -> evaluate a >> Control.Monad.liftM (:a) m) []
08:24:34 <lambdabot> Foldable t => t (IO a1) -> IO [a1]
08:37:13 <identity> Sorry for the late replies.
08:37:19 <identity> roconnor: Yeah I was thinking something along those lines.
08:37:54 <cads> hey guys
08:37:55 <identity> ski: Yes, I want a function that calls a function that generates the cache recursively, to pass the cache from one such call to the function again.
08:38:48 <ski> identity : which doesn't answer my question though (afaiui)
08:38:49 <identity> foo = let (cache, result) = runST $ bar emptyCache 0 in bar cache result
08:38:51 <identity> basically
08:39:15 <cads> Is there an already built method for creating a dependency fulfillment graph of the installed Cabal packages on a given machine?
08:39:32 <dcoutts> cads: ghc-pkg dot
08:39:47 <cads> sounds right!
08:39:52 <cads> thanks
08:40:35 <valyagolev> I remember how I learned that memoizing (what these on the outside call "dynamic programming", really!) in haskell can be done purely by building a recursive data-structure. I felt enlightened a little bit
08:40:42 <identity> ski: My "main worker" function calls the helper function to do some number crunching and generate a cache of results. The helper then returns the result and the cache, and the subsequent calls to the helper function want should use this cache as well
08:41:20 <ski> identity : i don't think you can do that with `ST', while wrapping the helper call with `runST'
08:41:34 <identity> ski: So the function as a whole would have to be in ST?
08:41:35 <ocharles> cads: or switch to nixos, which gives you that at the package manager level ;)
08:41:36 <ski> no `ST'-state can escape from a `runST'
08:41:45 <identity> ski: Aah, of course
08:42:11 <identity> I'll need to build another pure function on top, then, I guess.
08:42:26 <ski> identity : all the `bar' calls which wants to access the same stateful cache needs to be in `ST' -- `foo' needn't have `ST' in its type, in case it wraps all those `bar' calls inside a single `runST'
08:43:07 <identity> ski: I see what you mean, yes. Thank you, I think I can figure something out now.
08:43:09 <Jesin-phone> Hm, is there a standard package for reading random numbers from, for example, /dev/urandom ?
08:43:12 <valyagolev> identity do you really need an ST monad? maybe you can use lazy evaluation for this stuff?
08:43:16 <ski> @hoogle (forall s. ST s (STArray s i a)) -> Array i a
08:43:16 <lambdabot> Data.Array.ST runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
08:43:16 <lambdabot> Data.Array.ST.Safe runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
08:43:27 <ski> identity : depending on what you're doing, those might be useful
08:43:34 <cads> ocharles: I actually want to do it at package manager level in Debian / APT
08:43:44 <ski> @hoogle (forall s. ST s (STUArray s i a)) -> UArray i a
08:43:45 <lambdabot> Data.Array.ST runSTUArray :: Ix i => (forall s. ST s (STUArray s i e)) -> UArray i e
08:43:45 <lambdabot> Data.Array.ST.Safe runSTUArray :: Ix i => (forall s. ST s (STUArray s i e)) -> UArray i e
08:43:49 <cads> ocharles: but there isn't such a thing yet
08:44:06 <ocharles> cads: ah, debian really doesn't have something to do that?
08:44:39 <identity> ski: Yes, I had already looked at those. I reckon I'm going to be using STUArray since I'm only working with Int
08:44:54 <cads> ocharles: you can pull the installed dependency graph of a package selection using apt-rdepends
08:45:41 <ski> identity : in case the cache is just for performance, and not for behaviour, it would probably be acceptable to use `unsafePerformIO' or similar
08:46:14 <cads> ocharles: but there's nothing that pulls the complete graph
08:47:53 <cads> lemme check how hard apt-rdepends crashes if we ask for the dependencies of all currently installed packages
08:50:40 * hackagebot Konf 0.1.0.0 - A configuration language and a parser.  http://hackage.haskell.org/package/Konf-0.1.0.0 (GoktugKayaalp)
08:51:04 <identity> ski: Hmm. I truly hadn't thought of that. I might use that
08:53:21 <aegis__> hey guys; I am messing around with the "repl" package (https://github.com/mikeplus64/repl); is there a way to load a file in the repl? the equivalent of ":l file.hs" or the load method on http://chrisdone.com/posts/haskell-json-service-tryhaskell
08:53:56 <ski> identity : though you should then strive to place `unsafePerformIO' at the correct place, around the whole `IO'-action which is behaviourally pure, rather that several `unsafePerformIO's around smaller actions which aren't behaviourally pure
09:00:26 <cads> ocharles: hey, it turns out that apt-rdepends in fact _didn't_ choke on my list of ~2900 packages
09:01:08 <ocharles> :)
09:03:38 <napping> type instance Fix f = f (Fix f) is accepted but isn't very usable
09:03:59 <elliott> is that really accepted? terrifying
09:04:09 <napping> with UndecidableInstances
09:04:41 <levi> aegis__: Tryhaskell uses a modified mueval, and mueval has a parameter to pass a 'session file' that will be loaded before it executes the expression you gave it. It looks like 'repl' takes a different approach at sanitizing things, and being able to load arbitrary files would probably defeat the purpose of it.
09:05:31 <aegis__> levi: oh ok :/ thanks
09:06:42 <elliott> I think you could do file loading OK with repl.
09:11:10 <aegis__> elliott: how come?
09:11:22 <elliott> I mean if you modified the code.
09:11:29 <elliott> I don't think it's incompatible with the approach
09:12:07 <aegis__> I'll take a look
09:13:27 <lpaste> identity pasted “ST woes” at http://lpaste.net/92217
09:13:37 <identity> anyone care to enlighten me on the above?
09:15:22 <startling> identity: there is no argument to generateSequenceCachedST, hence it can not have a function type.
09:16:21 <startling> identity: the reason this is confusing is because (a ->) is a Monad, too, so it tries to check "newArray (1, 1000000) 0 :: ST s (STUArray s Int Int)" as a function type.
09:16:30 <startling> it isn't, so there's an error.
09:17:58 <lpaste> hardliner pasted “xmonad.hs” at http://lpaste.net/92218
09:20:28 <tomejaguar> Can type synonyms only be fully applied?
09:20:41 <ski> yes
09:20:48 <tomejaguar> OK, thanks ski
09:22:12 <ski> if you want, you could probably think of a type synonym as a (possibly parameterized) macro expanding to a type
09:22:41 <ski> (type families are more interesting, perhaps)
09:22:50 <merijn> tomejaguar: Although the result of totally applying a type synonym isn't required to be a fully applied type!
09:23:21 <merijn> i.e. "type Counter = State Int" is valid and lets you write "Counter ()" or "Counter Char" or whatever
09:23:41 <tomejaguar> Yes that can be quite useful.  Doesn't allow you to rearrange the argument order unfortunately.
09:24:22 <merijn> tomejaguar: True, but type families might let you do what you want?
09:25:19 <startling> tomejaguar: they need to be applied at least as far as their definitions are applied
09:26:05 <tomejaguar> merijn: Actually your original observation is sufficient for me now.  I was then just continuing to think on ...
09:26:10 <startling> e.g., you can have type List = []
09:26:37 <startling> and still have e.g. MaybeT List
09:28:01 <startling> but if you have type List a = [a], you can't have MaybeT List.
09:29:05 <DMcGill> that's odd, what's the reasoning behind that?
09:29:30 <tomejaguar> I imagine it's specifically to disallow you permuting type arguments
09:30:04 <napping> If you allow that sort of thing, it's just general type lambdas
09:30:23 <tomejaguar> And they are too hard to type check?
09:32:29 <elliott> it's bad for instances.
09:33:29 <tomejaguar> Would they be OK without typeclasses?
09:34:03 <elliott> maybe
09:34:09 <elliott> inference might be bad
09:52:44 <startling> I think you could do more than haskell does wrt type-level lambdas, but not much.
10:00:25 <joelteon> @pl \a b -> a </> unpack b
10:00:28 <lambdabot> flip ((.) . (</>)) unpack
10:00:28 <lambdabot> optimization suspended, use @pl-resume to continue.
10:00:34 <joelteon> what's up with @pl?
10:01:00 <mm_freak> -XTADTs -XTypePatternMatching
10:02:39 <Eduard_Munteanu> Blargh... why do authors of monad transformers pick the wrong order of parameters for run* functions?
10:02:57 <mauke> they don't pick
10:03:01 <mm_freak> Eduard_Munteanu: firstly because they don't pick the order
10:03:11 <mauke> the run* things are usually just accessors
10:03:18 <mm_freak> newtype ReaderT e m a = ReaderT { runReaderT :: e -> m a }
10:03:31 <Eduard_Munteanu> Hm, I see.
10:04:09 <Eduard_Munteanu> I'd do  newtype ReaderT e m a = ReaderT { unReaderT :: e -> m a }; runReaderT = flip unReaderT;
10:04:31 <Eduard_Munteanu> That's what I meant by "wrong" / "right" order.
10:04:47 <mm_freak> Eduard_Munteanu: secondly i found the argument order very useful, and the flipped order is only useful when you have to unwind a large transformer stack, which is a probably a bad coding style to begin with
10:05:04 <mm_freak> example:  f = runState g where g x = …
10:05:32 <Eduard_Munteanu> mm_freak: I find myself doing run* . run* . run* rather often
10:05:45 <Eduard_Munteanu> Well, just when defining a wrapper monad.
10:05:48 <mauke> did you copy the un/run convention from me or vice versa?
10:05:52 <ski> Eduard_Munteanu :  (`runBlah` bleh)
10:06:09 <mm_freak> Eduard_Munteanu: that means you should revisit your application design ;)
10:06:48 <Eduard_Munteanu> mauke: hm, not sure... I've seen 'un' around for accessors of newtypes and it seemed rather natural here
10:06:57 <Eduard_Munteanu> mm_freak: what do you mean?
10:07:16 <ski> @type let f = runState g where g x = undefined in f
10:07:16 <lambdabot>     Couldn't match type `t0 -> a1' with `StateT s0 Identity a0'
10:07:17 <lambdabot>     Expected type: State s0 a0
10:07:17 <lambdabot>       Actual type: t0 -> a1
10:07:35 <Eduard_Munteanu> Yeah, I've used what ski said above.
10:07:51 <mm_freak> f = runState g where g = do …
10:07:59 * ski often does `unBlah'
10:08:29 <mm_freak> Eduard_Munteanu: in recent years i've never stacked more than two monad transformers, and there is only a single place in my code where i unwind the stack
10:09:02 <mm_freak> however, there are multiple places in my code where i actually want the argument order we currently have
10:09:04 <Eduard_Munteanu> mm_freak: there's only one place here too, I just define a newtype wrapper, derive stuff for it and write a runMyMonad function.
10:09:43 <tomejaguar> Does anyone remember a floating point library that carries around the size of the numerical error?
10:09:50 <tomejaguar> (Probably by edwardk)
10:10:00 <mm_freak> Eduard_Munteanu: i stopped using newtypes for that purpose, instead my type signatures look like this:  f :: (MonadReader Config m, MonadWriter Result m) => A -> B -> m C
10:10:25 <Eduard_Munteanu> Hm.
10:10:26 <mm_freak> the application is polymorphic in the monad and only the runner instantiates, and it does it internally
10:10:35 <mm_freak> no specific monad stack/order necessary
10:10:42 <Eduard_Munteanu> Oh, I see.
10:11:45 <Eduard_Munteanu> mm_freak: it's a bit annoying to carry the Monad* around though, maybe I should define a superclass.
10:11:59 <mm_freak> no, you absolutely shouldn't
10:12:16 <Eduard_Munteanu> Why not?
10:12:29 <bigstones> hi all, I'm having problems with QuickCheck
10:12:30 <haasn> type MyMonad m = (MonadReader Config m, MonadWriter Result m)
10:12:32 <mm_freak> it takes a while to get used to it, but i appreciate this style a lot
10:12:35 <haasn> {-# LANGUAGE ConstraintKinds #-}
10:12:49 <lpaste> bigstones pasted “quickcheck” at http://lpaste.net/92219
10:12:52 <Eduard_Munteanu> haasn: hah, I thought it was a joke :)
10:13:01 <Eduard_Munteanu> But yeah, it makes sense with ConstraintKinds.
10:13:08 <haasn> it absolutely works :)
10:13:32 <Eduard_Munteanu> mm_freak: what's wrong with an "application" class?
10:13:48 <startling> mm_freak: yeah, I've arrived at the same style.
10:13:59 <mm_freak> Eduard_Munteanu: because it's not a sensible type class
10:14:08 <startling> it makes recursion a lot nicer, for example.
10:14:19 <mm_freak> type classes shouldn't be abused to save keystrokes
10:14:25 <mm_freak> startling: yeah
10:15:12 <startling> Can't you do a nice type synonym with Rank2Types?
10:15:17 <Eduard_Munteanu> mm_freak: I guess you have a point, in a saner language (Agda :P) you'd be forced to make the dependencies explicit.
10:15:37 <mm_freak> startling: yeah
10:15:57 <mm_freak> type App a = forall m. (MonadReader X m, MonadWriter Y m) => m a
10:15:58 <Eduard_Munteanu> Isn't it the same thing?
10:16:08 <mm_freak> however, as said, most of my functions don't require both
10:16:16 <mm_freak> and it's great documentation to see which function accesses what
10:16:18 <Eduard_Munteanu> Unless you write App a both in a type sig.
10:16:39 <mm_freak> Eduard_Munteanu: <startling> Can't you do a nice type synonym with Rank2Types?
10:16:43 <Eduard_Munteanu> Hm, so a type synonym should work.
10:16:49 <mm_freak> you can, but it's a bad idea IMO
10:17:00 <mm_freak> it destroys useful documentation
10:17:01 <Eduard_Munteanu> Yeah, I thought he suggested it for some other purpose.
10:17:33 <mm_freak> f :: (MonadWriter Result m) => A -> m ()
10:17:45 <mm_freak> it's useful to know that this function produces a result only from its argument
10:17:51 <mm_freak> it does not access the application configuration
10:18:03 <Eduard_Munteanu> Oh, hm... fair point.
10:18:13 <mm_freak> that's why this style is so useful:  f :: A -> MyMonad ()
10:18:18 <mm_freak> now tell me ANYTHING about f
10:18:18 <Eduard_Munteanu> Actually this is great.
10:18:22 <mm_freak> you can't
10:18:39 <Eduard_Munteanu> Thanks, I'll use that everywhere now. :D
10:18:50 <mm_freak> =)
10:19:55 <Eduard_Munteanu> mm_freak: you can still use a type synonym (or the constraints synonym) *and* the individual typeclasses, depending on the case. Anything against that?
10:20:42 * hackagebot haskell-packages 0.2.1 - Haskell suite library for package management and integration with Cabal  http://hackage.haskell.org/package/haskell-packages-0.2.1 (RomanCheplyaka)
10:20:43 <Eduard_Munteanu> E.g. you could define RWS as a synonym.
10:20:44 * hackagebot haskell-names 0.1.1 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.1.1 (RomanCheplyaka)
10:21:08 <Eduard_Munteanu> And use R, W, S alone when the rest isn't needed.
10:21:43 <startling> I think that makes sense.
10:22:04 <mm_freak> Eduard_Munteanu: you can write constraint synonyms for things like MonadReader Config
10:22:17 <mm_freak> but i wouldn't write synonyms for ready-made constraints
10:22:34 <bigstones> I hate to disturb you again, but could anyone take a look at this? should I leave QuickCheck alone while still learning? http://lpaste.net/92219
10:22:35 <mm_freak> type UsesConfig = MonadReader Config
10:22:50 <mm_freak> type MakesResult = MonadWriter Result
10:24:23 <Eduard_Munteanu> I need to take a closer look at ConstraintKinds... does it let you "newtype" constraints in any sensible way?
10:24:48 <merijn> Eduard_Munteanu: Yes
10:24:59 <Eduard_Munteanu> Cool.
10:25:11 <johnw> how can I find out the exception type of an exception being thrown from, say, System.Directory.removeFile?
10:25:12 <Eduard_Munteanu> (Not a great idea here, but wondering)
10:25:22 <merijn> johnw: The docs >.>
10:25:29 <johnw> ah, the docs say all
10:25:32 <johnw> wasn't expecting that :)
10:25:37 <merijn> johnw: Libraries should really document the exceptions they throw...
10:25:44 <merijn> johnw: Oh, they did? I was being snide
10:25:50 <Eduard_Munteanu> They should make a Throws typeclass. :D
10:26:02 <elliott> merijn: how does it let you newtype constraints?
10:26:02 <Eduard_Munteanu> Self-documenting. :)
10:26:13 <johnw> Eduard_Munteanu: there are hackage libraries that provide that
10:26:31 <merijn> elliott: Wait, I guess that depends on what you mean by "newtype constraints"
10:26:37 <merijn> Eduard_Munteanu: What did you mean by that? :p
10:26:52 <Eduard_Munteanu> johnw: ErrorT sort of does that, I presume, but it still lumps IO exceptions in one big thing
10:27:11 <johnw> Eduard_Munteanu: http://hackage.haskell.org/package/control-monad-exception
10:28:23 <Eduard_Munteanu> merijn: something like a constraints synonym but opaque and should let you shuffle parameters like newtype lets you vs plain type.
10:28:32 <startling> can I write the Monad instance here more generically? https://gist.github.com/startling/ba6244d00ed5137c6939
10:28:33 <mm_freak> Eduard_Munteanu: you can take constraints as arguments
10:28:39 <mm_freak> and synonyms can produce constraints
10:28:49 <mm_freak> there is no such think as newconstraint
10:28:49 <Eduard_Munteanu> mm_freak: yeah, but can they be e.g. partially applied?
10:29:16 <mm_freak> Eduard_Munteanu: depends on where you use them
10:29:24 <Eduard_Munteanu> Actually I guess it's not a big deal because you don't write instances for constraints. :)
10:29:35 <elliott> I don't understand what opacity would do here.
10:29:37 <mm_freak> you can write point-free type synonyms/families
10:30:27 <Eduard_Munteanu> Well there's a bunch of stuff you can't write with plain type synonyms.
10:30:49 <Eduard_Munteanu> Actually you can but then you get stuck defining instances because of partial application.
10:31:08 <apfelbox_> What is the preferred way to use regex in haskell?
10:31:14 <Eduard_Munteanu> E.g. defining composition for functors.
10:32:02 <Eduard_Munteanu> elliott: I was sort of concerned a big constraint synonym would be expanded by the compiler in error messages. Sometimes 'type' is avoided for that reason too.
10:32:26 <johnw> hmm.. the exception it's documented to throw does not exist :(
10:32:46 <Eduard_Munteanu> Possibly for Haskell it might be possible to fold synonyms back.
10:32:49 <startling> > error "exception does not exist"
10:32:50 <lambdabot>   *Exception: exception does not exist
10:33:04 <johnw> :t NoSuchThing
10:33:05 <lambdabot> Not in scope: data constructor `NoSuchThing'
10:33:06 <mm_freak> Eduard_Munteanu: you can't write constraint types
10:33:27 <Eduard_Munteanu> mm_freak: err... constraint types?
10:33:27 <mm_freak> data X :: (* -> a) -> a where
10:33:37 <mm_freak> would allow instantiating a = Constraint
10:33:41 <mm_freak> but GHC rejects that
10:33:51 <Eduard_Munteanu> Oh.
10:34:20 <bigstones> http://lpaste.net/92219 ok, in case anyone wondered, I was using ver. 2.4 of QuickCheck and that was a bug. fixed upgrading to 2.6
10:34:29 <Eduard_Munteanu> mm_freak: but stuff like   somefunc :: BigConstraintSynonym f => ...   would get expanded.
10:34:37 <mm_freak> yeah
10:34:44 <mm_freak> you can really only take them as arguments or write synonyms for them
10:34:58 <mm_freak> the only way to create new constraints is by writing a type class
10:35:06 <Eduard_Munteanu> I conjecture the compiler could fold them back into synonyms in a sensible manner.
10:35:14 <haasn> type families can produce constraints as well
10:35:20 <elliott> constraint types seem OK.
10:35:23 <elliott> at least one-constructor ones.
10:35:51 <mm_freak> haasn: literally only "type" families
10:35:54 <Eduard_Munteanu> (because constraint expressions are way simpler)
10:36:04 <mm_freak> you can't have constraint data/newtype families
10:36:24 <haasn> ok
10:36:47 <mm_freak> usually when there is some compiler-enforced restriction there is very likely a very good reason =)
10:37:07 <Eduard_Munteanu> When Haskell is the language, yes. :)
10:37:16 <mm_freak> mostly to protect decidable type inference
10:39:55 <haasn> does lens have anything like ‘chunksOf’?
10:40:02 <startling> haasn: what would it do?
10:40:22 <haasn> I'm not sure, but I was thinking along the lines of splitting a traversal' s a into a traversal s [a] ?
10:40:26 <haasn> partsOf-ish
10:40:49 <startling> :t traverse . toListOf
10:40:50 <lambdabot> Traversable t => Getting (Endo [b]) a b -> t a -> [t b]
10:41:05 <startling> :t (traverse .) . toListOf
10:41:06 <lambdabot>     Couldn't match type `[a1]' with `a0 -> f0 b0'
10:41:06 <lambdabot>     Expected type: Getting (Endo [a1]) a0 a1 -> a0 -> a0 -> f0 b0
10:41:06 <lambdabot>       Actual type: Getting (Endo [a1]) a0 a1 -> a0 -> [a1]
10:41:11 <haasn> chunksOf :: Int -> [a] -> [a]
10:41:12 <FreeFull> :t toListOf
10:41:12 <lambdabot> Getting (Endo [a]) s a -> s -> [a]
10:41:16 <haasn> err
10:41:19 <haasn> :: Int -> [a] -> [[a]]
10:41:21 <supki> haasn: there is Data.List.Split.Lens
10:41:34 <haasn> perfect!
10:43:12 <haasn> λ "68656c6c6f20776f726c64"^..chunking 2 folded.base 16.to chr
10:43:14 <haasn> "hello world"
10:43:43 <startling> oh
10:43:51 <johnw> wow
10:44:30 <johnw> lens -- for when you think you know what Haskell can do
10:45:06 <startling> :t (flip traverse .) . toListOf -- this was what I was trying to do (but it's probably not what you want)
10:45:07 <lambdabot> Applicative f => Getting (Endo [a1]) a a1 -> a -> (a1 -> f b) -> f [b]
10:45:29 <johnw> startling: that would be similar to "chunking 1"
10:45:30 <haasn> I can tell from the functions involved that it isn't
10:45:37 <haasn> johnw: more like chunking infinite?
10:45:42 <johnw> or that
10:45:46 <johnw> but certainly not chunking N
10:46:07 <startling> :t partsOf
10:46:30 <roconnor> @type Data.List.Split.Lens.chunking
10:46:31 <lambdabot> (Applicative f, Contravariant f) => Int -> Getting (Endo [a]) s a -> ([a] -> f [a]) -> s -> f s
10:47:17 <DMcGill> the worst part of lens is the derived type sigs
10:47:50 <roconnor> come on, there must be a single function that does \i -> chunking i folded
10:47:54 <roconnor> :P
10:48:48 <johnw> funking i?
10:48:56 <donri> :t \i -> chunking i folded
10:48:57 <lambdabot> (Applicative f, Foldable f1, Contravariant f) => Int -> ([a] -> f [a]) -> f1 a -> f (f1 a)
10:49:29 <donri> hoogle says no
10:50:08 <roconnor> oh, it seems I misunderstood the type of chucking.
10:50:18 <roconnor> how could I have done that :P
10:50:31 * roconnor approves of chunking.
10:51:00 * startling approves of chucking
10:51:14 <elliott> roconnor: really? it sounds law violating
10:51:18 <elliott> oh, it's read only
10:51:22 <elliott> but it doesn't *have* to be!
10:51:27 <elliott> I bet edwardk will let it be a traversal if I tell him.
10:51:27 <oleo> chuck the chuckers!
10:51:41 <oleo> lol
10:51:44 <elliott> :t
10:51:48 <elliott> :t \i -> chunking i traverse
10:51:49 <lambdabot> (Applicative f, Traversable t, Contravariant f) => Int -> ([a] -> f [a]) -> t a -> f (t a)
10:52:01 <elliott> you could totally let it write back.
10:52:14 <roconnor> elliott: (Applicative f, Contravarient f) sounds like a Fold to me, not a traversal.
10:52:17 <edwardk> ReinH: you do know that lens has an iterative deepening traversal right?
10:52:32 <edwardk> roconnor: it is
10:52:34 <elliott> roconnor: yes
10:52:41 <elliott> edwardk: so, chunking could allow you to write back!
10:52:41 <roconnor> elliott: I think the documentation is a little broken.
10:52:45 <elliott> it'd follow the laws if you preserved length.
10:52:49 <haasn> *if*
10:52:58 <elliott> haasn: conditional law obedience is edwardk's favourite kind
10:53:08 <elliott> and roconnor's least favourite kind
10:53:18 <haasn> just throw a runtime error if the lengths don't (==)
10:53:21 <haasn> ;)
10:53:25 <elliott> that sounds slow. we don't like slow
10:53:30 <elliott> we like fast and broken
10:53:31 <roconnor> nvr mind, I was misreading the documetnation
10:53:33 <haasn> do it in the type system then
10:53:41 <roconnor> it is fine, if not a little confusing.
10:53:48 <monochrom> that sounds slow. at the type level. :)
10:54:08 <apfelbox_> Could somebody please point out the error: matchRegex (mkRegex "\n*$") "test\n\n"
10:54:09 <apfelbox_> ?
10:54:15 <S_J> So Control.Concurrent.Chan.readChan blocks waiting until someting can be read?
10:54:25 <edwardk> I view th lens laws more like guidelines that tell me 'hey if someone is watching, maybe you shouldn't do that', but if I don't see anyone around I'm not above a little jay walking.
10:54:54 <apfelbox_> Ah, Haskell does not automatically capture the complete match
10:55:09 <elliott> I guess the problem here is that I am trying to get edwardk to do the evil work, instead of doing it myself.
10:55:10 <haasn> edwardk: also, is there a function for chunking ?? folded
10:55:43 * hackagebot skein 1.0.6 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-1.0.6 (FelipeLessa)
10:56:07 <edwardk> :t chunking ?? folded
10:56:08 <lambdabot> (Applicative f, Foldable f1, Contravariant f) => Int -> ([a] -> f [a]) -> f1 a -> f (f1 a)
10:56:14 <edwardk> looks like a good name for it
10:56:14 <pentace> apfelbox_: Shouldn't it be ".*\n*$"?
10:56:17 <edwardk> done ;)
10:56:22 <kognitiva> vem heter lambabot?
10:56:34 <edwardk> :t Data.Split.chunk
10:56:35 <lambdabot> Couldn't find qualified module.
10:56:39 <edwardk> :t Data.List.Split.chunk
10:56:40 <lambdabot> Int -> [e] -> [[e]]
10:56:41 <kognitiva_> lol hej
10:57:14 <haasn> edwardk: I want to get this toy hexDecode :: String -> String -- even shorter
10:57:16 <johnw> would it normally be "chunked"?
10:57:16 <apfelbox_> pentace: well, I only want to match the last characters - the regex does not have to match the whole string (it works in ghci)
10:57:34 <haasn> "68656c6c6f20776f726c64"^..chunking 2 folded.base 16.to chr  =>  "hello world"
10:57:44 <edwardk> johnw: likely
11:01:59 <roconnor> haasn: that is such a nice combination of folds, prisms and getters.
11:02:06 <edwardk> > "68656c6c6f20776f726c64"^..chunking 2 folded.base 16.to chr
11:02:08 <lambdabot>   "hello world"
11:02:32 <haasn> oh, good to know we have this stuff imported
11:03:04 <edwardk> haasn: feel free to add that as an example to chunking or base
11:03:04 <elliott> that's wonderful
11:03:07 <edwardk> thats pretty nice
11:03:21 <elliott> haasn: you can say hex
11:03:24 <elliott> rather than base 16
11:03:29 <haasn> oh, good catch!
11:03:32 <edwardk> > "68656c6c6f20776f726c64"^..chunking 2 folded.hex.to chr
11:03:33 <lambdabot>   "hello world"
11:03:43 <elliott> and enum instead of to chr, except you'd need a signature
11:03:53 <elliott> we should have an iso for ord/chr. or two.
11:05:35 <startling> can I see the derived Ord instance for Either somewhere?
11:06:30 <haasn> > "Jelly world"^.folded.to ord.re hex
11:06:31 <lambdabot>   "4a656c6c7920776f726c64"
11:06:34 <haasn> we do need an iso for ord/chr
11:06:48 <edwardk> :t enum
11:06:58 <edwardk> > "68656c6c6f20776f726c64"^..chunking 2 folded.hex.enum
11:07:00 <lambdabot>   [*Exception: Prelude.Enum.().toEnum: bad argument
11:07:06 <haasn> :(
11:07:09 <edwardk> > "68656c6c6f20776f726c64"^..chunking 2 folded.hex.from enum
11:07:10 <lambdabot>   [104,101,108,108,111,32,119,111,114,108,100]
11:07:17 <edwardk> > "68656c6c6f20776f726c64"^..chunking 2 folded.hex.enum
11:07:18 <lambdabot>   [*Exception: Prelude.Enum.().toEnum: bad argument
11:07:19 <haasn> > "Jelly world"^.folded.from enum.re hex
11:07:20 <elliott> edwardk: but you need a type signature for the decoding direction
11:07:21 <lambdabot>   "4a656c6c7920776f726c64"
11:07:22 <edwardk> ?
11:07:24 <edwardk> damn
11:07:26 <haasn> edwardk: defaults to ()
11:07:27 <elliott> > "68656c6c6f20776f726c64"^..chunking 2 folded.hex.to chr
11:07:28 <lambdabot>   "hello world"
11:07:30 <elliott> > "68656c6c6f20776f726c64"^..chunking 2 folded.hex.enum
11:07:31 <lambdabot>   [*Exception: Prelude.Enum.().toEnum: bad argument
11:07:32 <elliott> > "68656c6c6f20776f726c64"^..chunking 2 folded.hex.re enum
11:07:34 <lambdabot>   [104,101,108,108,111,32,119,111,114,108,100]
11:07:39 <elliott> not what you want
11:07:44 <elliott> which is why a specialised version would be nice
11:07:57 <elliott> also, isn't that exception a bug?
11:08:04 <haasn> no
11:08:09 <edwardk> elliott: yeah but all the good names would suck to take
11:08:10 <haasn> > toEnum 1 :: ()
11:08:11 <lambdabot>   *Exception: Prelude.Enum.().toEnum: bad argument
11:08:19 <elliott> edwardk: "codepoint"?
11:08:29 <edwardk> elliott: to chr is shorter ;)
11:08:32 <elliott> :(
11:08:35 <elliott> tochr
11:08:47 <elliott> uplus
11:08:59 <haasn> elliott: “ fromEnum and toEnum should give a runtime error if the result value is not representable in the result type. For example, toEnum 7 :: Bool is an error.”
11:09:12 <haasn> edwardk: ‘char’ is what I would have guessed
11:09:13 <elliott> haasn: I mean a bug in enum
11:09:19 <elliott> char would be an awful name to take
11:09:23 <elliott> don't tempt edwardk
11:09:28 <elliott> he wanted to take "is"
11:09:33 <haasn> well as long as it's in Data.Char.Lens
11:10:01 <edwardk> i still want to take is
11:10:07 <edwardk> and to rename (??) to (?)
11:10:07 <haasn> what would is be?
11:10:10 <edwardk> and do all the bad things
11:10:12 <edwardk> :t isn't
11:10:12 <lambdabot> APrism s t a b -> s -> Bool
11:10:17 <haasn> aha
11:10:17 <edwardk> > isn't _Left (Right 12)
11:10:19 <lambdabot>   True
11:10:24 <edwardk> @let is = has
11:10:25 <lambdabot>  Defined.
11:10:31 <edwardk> > is _Left (Left 12)
11:10:37 <edwardk> > is _Just (Just 12)
11:10:44 <edwardk> > is _Nothing (Just 12)
11:10:54 <haasn> lambdabot?
11:10:56 <monochrom> you kill lambdabot
11:10:59 <elliott> see.
11:11:01 <lambdabot>   True
11:11:02 <elliott> this is why you can't take is.
11:11:02 <edwardk> kills a whole family of functions everyone likes to make up
11:11:02 <lambdabot>   can't find file: L.hs
11:11:03 <haasn> lambdabot protests
11:11:04 <lambdabot>   True
11:11:05 <monochrom> err, s/kill/killed/
11:11:13 <haasn> :t hasn't
11:11:14 <lambdabot> Getting All s a -> s -> Bool
11:11:18 <danharaj> > i can has cheezburer
11:11:19 <lambdabot>   Not in scope: `can'
11:11:19 <lambdabot>  Perhaps you meant one of these:
11:11:19 <lambdabot>    `tan' (imported fro...
11:11:21 <haasn> how is this different from isn't other than the type signature?
11:11:36 <elliott> well, one is is and the other is isn't.
11:11:40 <elliott> which isn't is.
11:11:45 <haasn> I meant isn't/hasn't
11:11:58 <elliott> isn't is superfluously type-restricted
11:11:59 <monochrom> hahaha this is surreal
11:12:14 <haasn> but I thought type restriction only happened in comments
11:12:25 <elliott> so did I
11:12:41 <haasn> edwardk: explain yourself
11:13:05 <edwardk> semantically, hasn't takes a traversal. hasn't (element 20) parses.   isn't _Left parses. it doesn't have a Left, it is the left.
11:13:19 <haasn> =/
11:13:33 <haasn> ooh
11:13:35 <edwardk> when you have _Foo :: APrism .. , then isn't _Foo  works
11:13:45 <haasn> > is hex "7a3f"
11:13:47 <edwardk> er sorry hasn't takes a fold
11:13:49 <lambdabot>   True
11:13:50 <haasn> > is hex "7a3fg"
11:13:53 <lambdabot>   False
11:13:53 <haasn> I approve
11:13:55 <haasn> let's move this into base
11:13:55 <edwardk> haasn: exactly
11:14:02 <edwardk> haasn: its dead sexy
11:14:29 <edwardk> haasn: i'm likely to just make a module with the lens combinators i'm not brave enough to take ;)
11:14:37 <haasn> lens-extras
11:14:37 <edwardk> and just let you import Control.Lens.Extras
11:14:38 <edwardk> and get is
11:14:42 <haasn> oh, module
11:14:50 <edwardk> yeah i'm happy to put them in lens proper
11:14:59 <haasn> yeah it's not like they need language extensions
11:15:02 <edwardk> and have it export Data.Data.Lens, Control.Lens, is, etc.
11:15:05 <haasn> go ahead, I'll add it to my .ghci and tell you if I ever notice it collide
11:15:18 <haasn> I do notice collisions with Control.Lens from time to time when working with other libraries
11:15:34 <edwardk> yeah, indices clips array, and there are a few collisions
11:15:35 <haasn> though I can't remember any off the top of my head
11:15:39 <edwardk> i tried to keep them to a minimum
11:15:48 <edwardk> we spent a _long_ time hunting for non-colliding names
11:16:07 <edwardk> indices was the last big compromise, and (#) was a blatant grab for something for applying prisms
11:16:12 <edwardk> not sure i like the fixity it got
11:16:12 <haasn> I'm sure you also spent a long time pressuring other authors into changing their names
11:16:15 <edwardk> but its useful
11:16:36 <edwardk> in retrospect # probably should have been super-low fixity
11:16:38 <haasn> (#) has high fixity right?
11:16:47 <elliott> edwardk: the indices thing really annoys me, btw.
11:16:50 <edwardk> then it'd behave more like ($)
11:16:54 <edwardk> elliott: yeah
11:16:59 <edwardk> no other good names though
11:17:05 <haasn> I'd like to see a higher fixity for ?? too
11:17:05 <elliott> I don't like array but it comes in handy
11:17:12 <haasn> I think I've mentioned this before
11:17:41 <edwardk> yeah. i think in many ways (#) and (??) have eachother's ideal fixities
11:17:50 <haasn> maybe that could be debated along with the change to (?), or if they're just going into .Extras the (??) fixity could just stay low
11:18:10 <haasn> imagine the confusion that would arise from mixing (?) with (??) if you keep both :)
11:18:19 <edwardk> heh
11:18:24 <elliott> do I have veto powers?
11:18:31 <elliott> 'cuz I'd have to use them on (?) in Control.Lens, I think.
11:18:42 <edwardk> elliott: sure, but i can override it with a supermajority of my opinion
11:18:52 <haasn> elliott: even if they're not exported by default?
11:19:03 <monochrom> yikes
11:19:12 <elliott> maybe I can blackmail edwardk with the times we've exported unsafeCoerce
11:19:25 <haasn> I don't really mind ?? vs ? personally, the character doesn't make a huge difference
11:19:33 <elliott> unfortunately some of those times were my fault.
11:19:40 <elliott> haasn: hence "in Control.Lens" not in lens
11:19:47 <haasn> elliott: oh, yes
11:19:53 <shachaf> Wait, what's going on?
11:19:58 <edwardk> haasn: if you wanted to add Control.Lens.Extras i'd take the patch
11:20:07 <elliott> Control.Lens.SmoothOperators
11:20:14 <haasn> Control.Lens.SuperCombinators
11:20:21 <edwardk> Control.Lens.Operators.Smooth
11:20:24 <shachaf> edwardk: Is elliott messing up lens again?
11:20:30 <shachaf> elliott: Is edwardk messing up lens again?
11:20:33 <edwardk> shachaf: he stopped? =)
11:20:54 <elliott> I retired from ruining lens.
11:21:02 <elliott> but edwardk has been doing an excellent job in my absence
11:21:14 <haasn> shachaf: we were discussing (?) and ‘char = iso ord chr’ (or vice versa) in Control.Lens.Extras, among other names edwardk isn't brave enough to re-export in Control.Lens
11:21:29 <elliott> let's not put char in Control.Lens.Extras
11:21:30 <shachaf> What's (?)?
11:21:37 <elliott> it shouldn't be a grab bag for things that should go in more specific modules
11:21:41 <edwardk> shachaf: the name i wish i took for (??)
11:21:45 <haasn> oh, sorry
11:21:51 <edwardk> actually i don't want (?) in there i don't think
11:21:52 <haasn> it was ‘is’ not ‘char’ in .Extras
11:21:53 <shachaf> Oh.
11:22:03 <edwardk> i'm okay with the (??) compromise
11:22:04 <haasn> edwardk: so it's just ‘is’ then?
11:22:06 <edwardk> i just grumble about it
11:22:07 <edwardk> yeah
11:22:12 <elliott> c'mon.
11:22:13 <haasn> Control.Lens.Is
11:22:14 <elliott> "has" isn't so bad.
11:22:14 <edwardk> is and maybe a re-export of Data.Data.Lens
11:22:17 <haasn> class Is where is :: ...
11:22:23 <edwardk> > is hex "1234"
11:22:26 <haasn> we have to stay consistent
11:22:26 <lambdabot>   True
11:22:28 <edwardk> haasn: hahaha
11:22:29 <shachaf> elliott: :t c'mon
11:22:32 <elliott> > has hex "1234"
11:22:33 <lambdabot>   True
11:22:35 <elliott> it still reads properly.
11:22:38 <elliott> the string has hex in it.
11:22:46 <haasn> > has hex "so does this 1234"
11:22:48 <lambdabot>   False
11:22:52 <elliott> maybe is should be flip has
11:22:56 <elliott> "1234" `is` hex
11:23:00 <edwardk> blech
11:23:14 <edwardk> i'm going to stick to my guns and not name combinators for infix application
11:23:25 <shachaf> @let ain't = hasn't
11:23:26 <lambdabot>  Defined.
11:23:27 <shachaf> @let ai = has
11:23:28 <lambdabot>  Defined.
11:23:47 <shachaf> There you go.
11:23:50 <edwardk> @let can = id
11:23:51 <lambdabot>  Defined.
11:23:54 <edwardk> :t can has
11:23:55 <lambdabot> Getting Any s a -> s -> Bool
11:23:55 <haasn> :t ain't no
11:23:56 <lambdabot>     Not in scope: `no'
11:23:56 <lambdabot>     Perhaps you meant one of these:
11:23:56 <lambdabot>       `not' (imported from Data.Bool),
11:24:01 <tomboy64> someone tell me whether array has speed-advantages compared to hashmaps?
11:24:12 <tomboy64> *can ... please
11:24:20 <tomboy64> :(
11:24:26 <edwardk> tomboy64: if you are looking for speed advantags i wouldn't recommend looking at array
11:24:30 * tomboy64 goes looking for his manners
11:24:34 <haasn> > let ain't = id; no = hasn't in ain't no hex "foo"
11:24:36 <lambdabot>   True
11:24:56 <roconnor> edwardk: it depends on where you are coming from. :D
11:25:03 <edwardk> roconnor: heh
11:25:08 <roconnor> edwardk: like if you are coming from lists.
11:25:14 <tomboy64> edwardk: i am asking because on occasion i need potentially infinite keys - which array doesn't provide
11:25:22 <haasn> edwardk: what happens when lens starts running out of two-letter names? Do we move onto unicode?
11:25:41 <Eduard_Munteanu> I wish.
11:25:46 <edwardk> no, then we have to start using 3 letter names. =(
11:25:55 <edwardk> and maybe the occasional 1 letter name. sorry.
11:25:58 <roconnor> infinite keys?
11:26:06 <tomboy64> just use cyrillic :-}
11:26:08 <tomboy64> moar fun
11:26:09 <edwardk> i'll make sure to leave you i,j,x and y.
11:26:19 <roconnor> arbitrarly large keys?
11:26:19 <Yaniel> I'd suggest pinyin
11:26:24 <haasn> > let a = is in a _Right (Right 4)
11:26:27 <lambdabot>   True
11:26:31 <Yaniel> fun as heck to type too
11:26:54 <tomboy64> roconnor: not necessarily large ... but without upper bound.
11:26:56 <haasn> -fwarn-name-shadowing
11:27:19 <roconnor> > map f [x,y,z]
11:27:20 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
11:27:21 <lambdabot>    arising from a us...
11:27:28 <edwardk> 'was' was another option
11:27:30 <edwardk> @let was = has
11:27:31 <lambdabot>  Defined.
11:27:33 <edwardk> > was hex "hello"
11:27:37 <lambdabot>   False
11:27:44 <edwardk> > was hex "1234"
11:27:47 <lambdabot>   True
11:27:48 <haasn> that sounds stuck in the past
11:27:52 <haasn> @let willBe = was
11:27:53 <lambdabot>  Defined.
11:28:00 <haasn> we need to keep moving forwards
11:28:25 <Eduard_Munteanu> You can define 'haz' and such for variants of the above, no need for apostrophes. :)
11:29:00 <edwardk> :t (was &&& willBe)
11:29:01 <lambdabot> Getting Any s a -> (s -> Bool, s -> Bool)
11:29:15 <haasn> (does github have a web interface for fast forwarding fork of lens to ekmett's version?)
11:29:18 <haasn> like hub.darcs.net does
11:29:26 * Eduard_Munteanu that will warrant a name change to "lollens" though :P
11:29:32 <edwardk> =P
11:30:05 <bergmark> haasn: i don't think so
11:31:24 <haasn> let can = id; haz = has; _Cheezburger = ...
11:35:42 <ReinH> edwardk: I DID NOT KNOW THAT LENS HAS AN ITERATIVE DEEPENING TRAVERSAL. WTF.
11:35:51 <edwardk> :t levels
11:35:52 <lambdabot>     Ambiguous occurrence `levels'
11:35:52 <lambdabot>     It could refer to either `Lens.levels',
11:35:52 <lambdabot>                              imported from `Control.Lens' at /home/lambdabot/.lambdabot/State/L.hs:39:1-43
11:35:55 <edwardk> :t Lens.levls
11:35:56 <lambdabot> Couldn't find qualified module.
11:35:57 <edwardk> :t Lens.levels
11:35:58 <ReinH> lens is truly the kitched sink library, jesus
11:35:58 <lambdabot> (Applicative f, Indexable Int p) => ATraversal s t a b -> p (Level () a) (f (Level () b)) -> s -> f t
11:36:02 <ReinH> *kitchen
11:36:09 <absence> is there a data structure that allows the equivalent of [0..] !! 40 but with faster than O(n) lookup? IntMap goes into an infinite loop
11:36:57 <merijn> absence: Array?
11:37:09 <merijn> absence: Array supports constant time lookup
11:37:22 <merijn> absence: Also things like Vecotr
11:37:24 <edwardk> > ("hello","world")^..taking 5 (Lens.levels (both.traverse)).traverse
11:37:25 <lambdabot>   "hweolr"
11:37:29 <merijn> s/Vecotr/Vector
11:37:35 <edwardk> ReinH: ^-
11:37:43 <edwardk> > ("hello","world")^..Lens.levels (both.traverse).traverse
11:37:45 <lambdabot>   "hweolrllod"
11:37:55 <edwardk> > ("hello","world")^..Lens.levels (both.traverse)
11:37:56 <lambdabot>   [Zero,Zero,Two 0 (One () 'h') (One () 'w'),Two 0 (One () 'e') (One () 'o'),...
11:37:57 <elliott> hmm
11:38:01 <elliott> what is levels conflicting with?
11:38:08 <edwardk> :t levels
11:38:09 <lambdabot>     Ambiguous occurrence `levels'
11:38:09 <lambdabot>     It could refer to either `Lens.levels',
11:38:09 <lambdabot>                              imported from `Control.Lens' at /home/lambdabot/.lambdabot/State/L.hs:39:1-43
11:38:10 <absence> merijn: i don't think they can be infinite?
11:38:14 <edwardk> no idea
11:38:27 <elliott> Data.Tree.levels
11:38:34 <elliott> perhaps we should s/levels/levelled/?
11:38:34 <merijn> absence: How could you have an infinite data structure with constant lookups?
11:38:36 <elliott> or levelling or something
11:38:36 <edwardk> > ("hello","world")^.magma (Lens.levels (both.traverse).traverse)
11:38:38 <lambdabot>   .. <$> (.. <$> pure .. <*> (.. <$> pure .. <*> (.. <$> (.. <$> (.. <$> Magm...
11:38:47 <merijn> absence: Are all of the values the same after a certain value or something?
11:39:19 <absence> merijn: doesn't have to be constant, just better than O(n)
11:39:24 <edwardk> ReinH: anyways, you can thn cut off after a number of results in depth first order or after a number of levels by using taking on the levels or on the traversal of the levels
11:39:33 <edwardk> > ("hello","world")^..taking 4 (Lens.levels (both.traverse).traverse)
11:39:34 <lambdabot>   "hweo"
11:39:41 <edwardk> that takes the first 4 results in depth first order
11:39:45 <edwardk> > ("hello","world")^..taking 4 (Lens.levels (both.traverse)).traverse
11:39:46 <merijn> absence: "Map Integer" or Set?
11:39:47 <lambdabot>   "hweo"
11:39:58 <edwardk> that takes the first 4 levels, no matter how many entries are in each
11:40:03 <edwardk> > ("hello","world")^..taking 5 (Lens.levels (both.traverse)).traverse
11:40:05 <lambdabot>   "hweolr"
11:40:35 <edwardk> every time i use levels roconnor cries.
11:40:59 <ReinH> edwardk: you are blowing my mind.
11:41:13 <merijn> I feel like I should get a phd in lens
11:41:27 <ReinH> edwardk: now, how can I cut it off via an asynchronous exception while storing the result somewhere?
11:41:34 <ReinH> merijn: heh
11:41:34 <edwardk> the school of lensology is now accepting grad school applications
11:41:50 <edwardk> ReinH: its a traversal. traverse it with io actions
11:41:56 <ReinH> oh god, obviously
11:41:57 <merijn> edwardk: Do you have funding or do I first need to get my own grant? Because the latter seems to be a problem :p
11:42:08 <ReinH> edwardk: or STM actions, or whatever
11:42:10 <ReinH> god
11:42:10 <bergmark> i'm a little disappointed that the Prismatic Prismoid instance was removed from lens... >:)
11:42:12 <ReinH> brilliant
11:42:22 <ReinH> edwardk: <3
11:42:36 <elliott> we still have prismatic prismoids, they just got renamed.
11:42:55 <edwardk> merijn: well, you have to start paying tuition. we'll use that tuition to build nice buildings
11:43:03 <edwardk> and force you to work in labs
11:43:18 <haasn> it's easy to forget about ‘traverseOf’ :)
11:43:25 <edwardk> haasn: aka 'id'
11:43:42 <edwardk> :t traverseOf
11:43:42 <lambdabot> Over p f s t a b -> p a (f b) -> s -> f t
11:43:49 <edwardk> best signature for id ever
11:44:01 <merijn> edwardk: tuition...how very american :p
11:44:23 <edwardk> merijn: well, the school of lensology is located in the greater boston area
11:44:27 <bergmark> elliott: but it was the naming i liked :/
11:44:38 <elliott> I dislike the "Choice" class name
11:44:40 <elliott> but what can you do.
11:44:54 <edwardk> elliott: not a huge fan either, but its generalized ArrowChoice
11:45:05 <absence> merijn: hmm, Map Integer behaves like IntMap. Set doesn't allow lookups (i.e. a -> b)
11:45:31 <absence> merijn: so i guess the answer is "no" :)
11:45:43 <elliott> I also don't really like Strong, since there's nothing profunctory about it.
11:45:44 <edwardk> hrmm, this tensor/table edsl i'm fiddling with actually seems like it might work
11:45:48 <elliott> even if a plain strong functor class would be useless.
11:45:49 * hackagebot fay-base 0.17.0.0 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.17.0.0 (AdamBergmark)
11:45:51 * hackagebot fay 0.17.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.17.0.0 (AdamBergmark)
11:46:03 <edwardk> its getting positively pipes-like w.r.t the number of parameters though =(
11:46:38 <FreeFull> :t id :: Over p f s t a b -> p a (f b) -> s -> f t
11:46:39 <lambdabot> Over p f s t a b -> p a (f b) -> s -> f t
11:46:42 <elliott> edwardk's pipe dream
11:46:56 <merijn> edwardk: It already was >.>
11:47:11 <edwardk> merijn: no, the tensor thing
11:47:21 <absence> merijn: was hoping for a quick speedup to decode_LZW at http://www.haskell.org/haskellwiki/Toy_compression_implementations but there's no free lunch i guess
11:47:37 <edwardk> Project   :: Eq j => (a -> a -> a) -> (Out v j -> T is js v m a) -> T is js v m a
11:47:38 <edwardk> etc.
11:48:12 <FreeFull> Can someone tell me which of the arrows in that type signature is id's arrow?
11:48:40 <edwardk> T is js v m a represents a 'tensor' or 'table' with inputs is, outputs js, variables in 'v' -- (ebasically its like the ST region parameter), effects for generating the tables in m, and associated values in 'a'
11:48:46 <Taneb> FreeFull, the one after the Over and before the pafb
11:49:35 <edwardk> 'is' works like codata and can be infinite, 'js' works like data and is finite, and then we have cup-like operations for joining and tracing out down paramters on our tensors
11:49:59 <FreeFull> Taneb: Thanks
11:50:09 <edwardk> and matrices themselves work like tensors with two down parameters, join takes two up parameters, and we can view is and js as input modalities
11:50:13 <tomejaguar> FreeFull: This one: ->
11:50:40 <FreeFull> Prelude Control.Lens> :i Over      type Over p f s t a b = p a (f b) -> s -> f t
11:50:41 <edwardk> that way we can talk about how to mix tensors/tables with real functions applied to the results, and still generate the answers in morton order using the fancy matrix multiply-like tricks
11:50:49 * hackagebot fay-text 0.1.0.0 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.1.0.0 (AdamBergmark)
11:51:13 <edwardk> FreeFull: it is necessarily the first one =)
11:51:20 <edwardk> :info traverseOf
11:51:33 <edwardk> :t traverseOf
11:51:34 <lambdabot> Over p f s t a b -> p a (f b) -> s -> f t
11:51:42 * bos tries to install edwardk's "free" package, is blown away by its enormous number of dependencies
11:51:46 <edwardk> Over p f s t a b -> (p a (f b) -> s -> f t)
11:51:49 <c_wraith> installing it isn't free
11:51:59 <elliott> bos: he was just thinking about adding another too!
11:52:21 <edwardk> bos: i can either write crippled code or i can incur dependencies
11:52:35 <edwardk> i've given up on crippling the code as good engineering practice
11:53:04 <tomejaguar> edwardk: why have you given up?
11:53:35 <jfischoff> edwardk: I don't know what is says about me that I'm excited that your getting worried about one of your types ;)
11:53:39 <FreeFull> edwardk: Well, I asked before checking how Over was defined =P
11:53:41 <tomejaguar> I'm curious about the rationale
11:53:41 <edwardk> tomejaguar: because in general i find that limiting what i can think just to satisfy the kind of user who won't be satisfied if i have any dependencies at all isn't very useful to me as a developer
11:54:17 <edwardk> tomejaguar: it is an inherently self-limiting process. there are tons of developers who will write that kind of code
11:54:33 <edwardk> tomejaguar: i'm more interested in the frontier of what you can say when you don't cripple yourself in that way
11:54:44 <jfischoff> bos: why did you name the default parameter operator (:!=) in Aeson?
11:55:00 <jfischoff> more curious than anything
11:55:05 <bos> jfischoff: i have no recollection
11:55:11 <tomejaguar> Are dependencies still very bad things these days?  I've never really had cabal problems, perhaps because I came late to the game.
11:55:12 <edwardk> bos: but if free makes you boggle you should try to install lens ;)
11:55:19 <bos> jfischoff: for the record, i basically regret all of those crappy little operators.
11:55:27 <jfischoff> heh
11:55:36 <jfischoff> that would make tech directory happy to hear
11:55:36 <dcoutts> tomejaguar: no, code reuse is a good thing! :-)
11:55:47 <edwardk> bos: i confess i tend to just use lens-aeson these days
11:56:08 <tomejaguar> dcoutts: I meant from the mythical "cabal hell" POV.
11:56:16 <bos> edwardk: i haven't used lens-aeson, but it seems like the rightish approach
11:56:29 <tomejaguar> I've basically only been in cabal purgatory, but it seems like my relatives paid indulgences to get me out.
11:56:48 <dcoutts> tomejaguar: it's easier if you use standard versions of things
11:56:58 <dcoutts> e.g. the versions that come with the platform
11:57:23 <edwardk> bos: i've got a little library for doing json manipulation via 'semi-indexing' that i've been putting together. If you wind up with some downtime and want to keep your brain wrinkly: http://www.di.unipi.it/~ottavian/files/semi_index_cikm.pdf
11:57:26 <haasn> until you start mixing it with libraries from git :)
11:57:27 * Eduard_Munteanu wonders if you can use typeclasses / constraints infix.
11:57:39 <haasn> Eduard_Munteanu: you can, afaik
11:57:42 <bos> tomejaguar: there's nothing wrong with dependencies per se. having a long chain of them makes for slow builds and a greatly increased chance of cross-version incompatibilities - but this isn't unique to haskell
11:57:45 <edwardk> bos: it is a very simple application of the kinds of succinct data structure techniques i rambled to you on the phone a few months ago
11:57:48 <Eduard_Munteanu> Hm, pretty cool.
11:58:12 <haasn> Eduard_Munteanu: but you have to enclose them in parentheses
11:58:22 <haasn> like so:  :: (a * b) => foo
11:58:22 <edwardk> bos: in my case most of my dependencies are on other packages i wrote and i go out of my way to ensure cross version compatibilities
11:58:27 <bos> edwardk: thanks for the pointer. it's an entertaining paper title, at the very least.
11:59:02 <Eduard_Munteanu> haasn: ah, I always do that... But I wanted to write stuff like (m `Reads` a) => ...
11:59:14 <jfischoff> bos: why the change of heart with the Aeson operators?
11:59:46 <haasn> :t ask :: (r `MonadReader` m) => m r
11:59:47 <lambdabot> MonadReader r m => m r
11:59:57 <elliott> @tell chrisdone hpaste.org now points at the lpaste server, but the webserver shows ircbrowse
11:59:57 <lambdabot> Consider it noted.
11:59:58 <haasn> it's fairly consistent
12:00:01 <edwardk> bos: but the general objection is one i can understand
12:00:02 <Eduard_Munteanu> Oh, cool. So it even works out of the box.
12:00:03 <bos> jfischoff: because the "more right" approach is to have generalised composable combinators, such as lenses, rather than a grab bag of fiddly things with fugly names
12:00:44 <bos> jfischoff: for instance, there's no concise way with the default aeson accessors to be able to reach deep inside a structure
12:01:05 <elliott> hooray for lens
12:01:12 <jfischoff> yeah that is very annoying … without lens :)
12:01:20 <elliott> I remember when prisms were projections and also bad.
12:01:24 <bos> jfischoff: but with json data, you're often only interested in a few bits and pieces out of a giant barfbag of someone else's data
12:01:35 <merijn> bos: Now that you're here, that people already badger you about the hpaste domain? :)
12:01:36 <elliott> those were the dark ages of data access.
12:01:48 <elliott> merijn: already did
12:01:54 <merijn> ok, good :p
12:02:07 <bos> merijn: i repointed it at the IP address that chrisdoner requested a few months ago, but now it seems to point to a useless IRC log web site
12:02:17 * jfischoff nods
12:02:21 <roconnor> elliott: you mean January?
12:02:28 <bos> so i'm wondering where to point it now
12:02:53 <elliott> roconnor: yes. the dark ages
12:03:01 <elliott> bos: the web server is just defaulting to that
12:03:05 <elliott> because it doesn't know hpaste.org
12:03:06 <elliott> (I assume)
12:03:09 <elliott> I sent a @tell
12:03:10 <merijn> bos: Maybe he needs to change his virtual host
12:04:30 <haasn> edwardk: http://bpaste.net/show/126811/ http://bpaste.net/show/126812/
12:04:48 <haasn> oh, that email needs to be updated
12:05:02 <edwardk> ghci> "[{ \"foo\" : [12]},34]"^?nth 0.key "foo".nth 0    ==> Just (Number 12)
12:05:28 <edwardk> haasn: sounds good
12:07:09 <ReinH> edwardk: popular podcast is popular :) high five
12:07:16 <edwardk> ReinH: nice =)
12:07:27 <ReinH> edwardk: it's doing surprisingly well in /r/programming
12:07:45 <edwardk> ReinH: yeah i think the general populist tone of the first part works well for that audience
12:07:50 <ReinH> I'm interested to see any stats from the site itself or itunes but Chris is afk as if he has some sort of real life...
12:07:57 <haasn> ReinH: you should probably add the names (and IRC handles) of the participants to the video
12:08:04 <haasn> I had to pause and look it up online
12:08:11 <ReinH> haasn: good idea :)
12:08:21 <ReinH> I'll ask Chris to put them in the description
12:09:58 <edwardk> ReinH: you can do the little annotation thing on the youtube video itself to superimpose the names over each of us in the first few seconds
12:10:08 <ReinH> edwardk: true! Well, Chris can. :)
12:10:49 * hackagebot fay-jquery 0.4.0.0 - jQuery bindings for Fay.  http://hackage.haskell.org/package/fay-jquery-0.4.0.0 (AdamBergmark)
12:12:27 <haasn> ew, both features my youtube client does not implement :(
12:18:38 <Eduard_Munteanu> Hmm... I sort of want to separate MonadError e m into Throws e m and Catches e m. Not sure if it makes sense.
12:22:46 <Eduard_Munteanu> Also  data FailOr e = PatternMatchFail String | NotFail e  such that  instance (Error e) => Error (FailOr e) where strMsg = PatternMatchError  seems like a random useful thing to have.
12:22:50 <Placinta> Hi. foldMap has the type (F.Foldable t, Monoid m) => (a -> m) -> t a -> m. It extract the "a" from t, and feeds it to a function. Is there some kind of foldmap that send the whole t a to a function?
12:23:16 <elliott> Placinta: um... you mean (t a -> m) -> t a -> m?
12:23:24 <elliott> that does exist; it's called id
12:23:25 <Placinta> Yes
12:23:30 <cschneid> can somebody help me parse this line of code, from a snap application - setting up the heist config. I'm confused at what mempty and then the curly braces are doing.
12:23:30 <cschneid>     let config = mempty { hcInterpretedSplices = [("allPosts", Post.allPosts),
12:23:42 <elliott> Placinta: which is to say... why not just pass the (t a) to the function directly?
12:24:23 <Placinta> elliott: If I want to make a data type be an instace of foldable, I kinda can't do that.
12:24:42 <elliott> I don't understand. are you using or implementing Foldable?
12:24:43 <Eduard_Munteanu> cschneid: it happens that mempty refers to a record
12:24:58 <Placinta> elliott: Implementing a foldable. Specifically a Tree.
12:25:10 <elliott> ok. I'm not sure what you are asking for then
12:25:11 <monoidal> Placinta: maybe you want >>=?
12:25:29 <elliott> since foldMap is a method of Foldable, any way you implement it must necessarily give rise to a foldMap
12:25:44 <elliott> (a Foldable that did not provide foldMap would not be a Foldable at all)
12:25:52 <elliott> so if you think you cannot do foldMap then you cannot instantiate Foldable.
12:26:04 <monoidal> cschneid: a { x = y, ... } is record update syntax
12:26:06 <elliott> however, I wouldn't be so sure you can't.
12:26:14 <haasn> trees tend to be foldable :)
12:26:16 <elliott> what is your tree type?
12:26:26 <Eduard_Munteanu> I think I also want to be able to catch an exception type and throw a different one.
12:26:30 <Placinta> elliott: It's kinda like the Data.Tree
12:26:40 <elliott> ok, but how is it not like Data.Tree? :p
12:26:45 <Placinta> But the foldMap in Data.Tree sends only the a into the function
12:26:58 <Placinta> I need to send the whole tree into the function, and fold it like that
12:27:15 <Placinta> Or rather the subtree
12:27:29 <monoidal> Placinta: do you want something like scanl/r but for trees?
12:27:39 <Placinta> One moment to check
12:27:47 <elliott> I don't understand.
12:27:52 <elliott> it sounds like this is a question about using Foldable again
12:27:55 <elliott> (rather than implementing it)
12:28:08 <cschneid> Eduard_Munteanu / monoidal - thanks. I was just trying to figure out what was going on with the mempty - getting help in #snapframework on the details. Basically lets them use a sane default config, then override just want you want to
12:28:28 <Placinta> elliott:  The implementation that is not good for my need
12:29:13 <Placinta> monoidal: I don't think I need scanl
12:29:41 <monoidal> Placinta: can you give an example with input and expected output? it's hard to tell what you want to do.
12:29:53 <Placinta> elliott: I want to implement a filter function for the tree. But I need the resulting elements to contain not only a, but also the children of the subtree
12:30:18 <Placinta> elliott: I can use foldMap to implement a filter, but I will get only a to work with.
12:30:29 <elliott> ok, so it's not a question about giving a Foldable instance
12:30:44 <elliott> I suggest just writing this function you need?
12:30:47 <Placinta> I was wondering if I can specialize the Foldable somehow
12:30:50 * hackagebot bencoding 0.2.0.0 - A library for encoding and decoding of BEncode data.  http://hackage.haskell.org/package/bencoding-0.2.0.0 (SamTruzjan)
12:31:38 <Placinta> The function that I need is almost entirely like a foldMap, just with the difference it contains the whole subtree. I thought there could be some trickery to make it work.
12:32:13 <elliott> I don't think Foldable supports what you want. but I don't think it matters, because you would have to write foldMap for your tree type to give a Foldable instance
12:32:23 <elliott> so it's not like you really save work over just writing this function yourself :)
12:32:33 <tomejaguar> Placinta: sounds like you just want a catamorphism, no?
12:32:44 <Placinta> tomejaguar: I'm not sure what that is
12:32:47 <monoidal> Placinta: you could write a function Tree a -> Tree (a, Tree a) that annotates each node with its subtree, and use foldable on that
12:33:01 <arianvp> hmm What irc client would you guys recommend?
12:33:23 <arianvp> Is there one I can script in haskell? .-.
12:33:24 <Placinta> monoidal: hmm, I could try that
12:33:25 <pxqr> erc if you use emacs
12:33:30 <arianvp> nah. vim user ):
12:33:30 <tomejaguar> Placinta: can you give us an explicit example of a datatype and the algorithm you want to perform on it?
12:34:03 <Velpoman> I like irssi personally for cli/tmux and colloquy for mac if gui.
12:34:22 <hape01> arianvp: irssi is nice in combination with linux screen
12:34:31 <Placinta> tomejaguar: myfilter p = F.foldMap (\a -> if p a then return a else mempty) This is what I want. The only caveat \a has to be the a inside Tree, whereas I want it to be Tree a
12:34:36 <arianvp> hape01: yeh my last setup was tmux+irssi
12:35:04 <hape01> arianvp: you're at the top why changing? ;-)
12:35:08 <pxqr> arianvp: there are irc client in haskell: http://hackage.haskell.org/package/manatee-ircclient
12:35:15 <tomejaguar> Placinta: but which Tree do you want it to be?
12:35:18 <arianvp> hape01: New computer, new possibilities
12:35:37 <tomejaguar> Placinta: do you want to fold over all subtrees?  Or all subtrees at the first level?
12:35:44 <Placinta> tomejaguar: Every subtree
12:35:50 * hackagebot krpc 0.2.0.0 - KRPC remote procedure call protocol implementation.  http://hackage.haskell.org/package/krpc-0.2.0.0 (SamTruzjan)
12:35:55 <arianvp> + my current unversity has all their courses based on microsoft stuff. So I can't use linux too much anymore ):
12:36:05 <arianvp> I find it saddening that they won't use an open-source solution
12:36:07 <Placinta> This is my foldmap foldMap f (Node node children) = f (Node node children) `mappend` F.foldMap (F.foldMap f) children
12:36:15 <arianvp> EVEN if that means writing Java. -ugh-
12:36:19 <tomejaguar> Placinta: do you basically want to produce a list of the subtrees?
12:36:22 <Placinta> Yes
12:36:33 <tomejaguar> OK well I doubt there is any standard way of doign it
12:36:34 <haasn> ‘folding over every subtree’ sounds like syb/plate
12:36:46 <Placinta> Note f (Node node children) wont work up there, it has to be f node so the instance is valid
12:37:37 <elliott> you can write decorate (Node node children) = Node (Node node children) children
12:37:42 <elliott> er.
12:37:48 <elliott> you can write decorate (Node node children) = Node (Node node children) (map decorate children)
12:37:51 <elliott> or whatever.
12:37:53 <elliott> and then use foldMap on the result.
12:38:51 <haasn> > Node "hello" [Node "world" [], Node "foo" [Node "bar" [], Node "bat" []]] & plate .~ Node "x" []
12:38:53 <lambdabot>   Node {rootLabel = "hello", subForest = [Node {rootLabel = "x", subForest = ...
12:38:59 <haasn> not sure if this is relevant
12:39:10 <monoidal> elliott: btw that Tree + decorate looks like a comonad, no?
12:39:26 <elliott> only if you have extract.
12:39:31 <elliott> but yes
12:39:38 <arianvp> hmm what would extract be
12:39:44 <elliott> depends what the full tree type is.
12:39:44 <haasn> extract (Node n xs) = n
12:39:48 <haasn> for the standard one
12:39:50 <elliott> Node might not be the only constructor.
12:39:50 <monoidal> extract (Node node children) = node
12:39:50 <haasn> I guess
12:39:58 <elliott> since I heard it wasn't the same as Data.Tree?
12:40:17 <HugoDani1l> hi
12:40:19 <arianvp> of course. `comonad` package is maintained by edwardk. Damn you edwardk and your magical mathmatics!
12:40:25 <Placinta> Which comonad is that?
12:40:25 <HugoDani1l> how can i generate javascript with haskell ?
12:40:39 <arianvp> Hugodani1l . Check out projects Fay
12:41:38 <arianvp> or ghcjs, or haste, or uhc-js
12:41:40 <HugoDani1l> cool, can i do it like import Fay ?
12:41:42 <monoidal> Control.Comonad has instance Tree Comonad which does exactly that.
12:42:01 <arianvp> Oh you mean generating javascript inside haskell?
12:42:06 <arianvp> I think there's a quasi-quoter for that
12:42:35 <arianvp> but don't take my word for it.
12:42:48 <Placinta> monoidal:  I'll check it
12:42:54 <HugoDani1l> arianvp: yes
12:42:58 <Placinta> monoidal:elliott: Thanks for all the suggestions
12:42:59 <HugoDani1l> jmacro
12:43:18 <arianvp> HugoDani1l: But that wasn't what you were looking for, I guess?
12:44:10 <arianvp> Are you looking for something like blaze-html, but for javascript?
12:44:57 <HugoDani1l> arianvp: yes exacly :D
12:45:04 <elliott> jmacro?
12:45:38 <luite> jmacro is more like hamlet for javascript
12:46:01 <arianvp> http://hackage.haskell.org/package/language-javascript
12:46:09 <arianvp> that's just a Parser + AST though
12:46:22 <arianvp> but going from AST  to javascript shouldn't be that hard
12:46:49 <arianvp> Oh nvm
12:46:53 <arianvp> it actually comes with a pretty printer
12:46:54 <ocharles> there is sunroof for a Haskell DSL to generate JS
12:47:05 <arianvp> http://hackage.haskell.org/packages/archive/language-javascript/0.5.7/doc/html/Language-JavaScript-Pretty-Printer.html
12:47:32 <ocharles> HugoDani1l: Sunroof will let you do it directly in Haskell itself - no other languages
12:47:46 <ocharles> @hackage sunroof-compiler
12:47:46 <lambdabot> http://hackage.haskell.org/package/sunroof-compiler
12:48:10 <arianvp> neat
12:48:34 <HugoDani1l> allright! :D
12:48:44 <HugoDani1l> i have defined a few datatypes in haskell
12:48:54 <HugoDani1l> and done the aeson instances for them
12:49:19 <HugoDani1l> now i want to automatically generate the JS that parses the aeson from those datatypes
12:49:31 <HugoDani1l> so that when i change the datatypes in the future, the JS can be correct
12:49:33 <ski> hape01 : linux screen ?
12:49:46 <arianvp> tmux > screen #yolo
12:49:54 <arianvp> To quote the young folks
12:50:15 * ski was only aware of GNU Screen ..
12:50:30 * arianvp recommends ski to try tmux
12:50:37 <ski> perhaps one day
12:50:53 <HugoDani1l> tmux is great !
12:50:55 <Unoni> Hello!
12:51:09 <ski> hello there, Unoni
12:51:30 <arianvp> I had tmux pretty well integrated with vim.  I could do stuff like    :openGHCI and open ghci in a new tmux session automagically
12:51:39 <arianvp> which was pretty sexy
12:51:45 <ski> hyvää iltaa
12:51:51 <Unoni> iltaa
12:52:05 <arianvp> jag talar inte _finnish_
12:52:08 <HugoDani1l> arianvp: !! write a blog post about that!
12:52:11 <arianvp> oh wait. that was swedish ):
12:52:29 <arianvp> HugoDani1l: Will do after I get my old computer unbricked, (which had that setup)
12:52:42 <arianvp> It's on my TODO list
12:53:01 * arianvp todo list:  []make a blog , []write a blogpost about tmux/vim
12:53:07 <ski> arianvp : i assume a "tmux session" corresponds to a "screen window" ?
12:53:17 <arianvp> ski: I think so yes
12:53:52 <ski> (i do hope you can have multiple, independent, tmux "sessions" (in the screen and emacs sense, at least) at the same time)
12:53:53 <Yaniel> a session contains windows and a window can contain multiple panes
12:54:26 <arianvp> What Yaniel said.
12:54:40 <Yaniel> sessions are independent of each other but can share windows
12:54:49 <HugoDani1l> :D
12:54:50 <arianvp> AND they are suspendable!
12:54:54 <arianvp> to later pop in again
12:54:59 <arianvp> which is like uber sexy
12:55:07 <arianvp> (I bet screen does that as well)
12:55:15 <arianvp> I just got one little problem
12:55:19 <ski> a Screen session contains windows, each typically containing one process. any number of terminals can be attached to a Screen session, each possibly with its own layout of regions, each displaying a window
12:56:08 <arianvp> I'm   in my xmonad session  in an xmonad window in one of my xmonad panes which runs a terminal which runs a tmux session and on one of the tmux windows I got a tmux pane running vim which has multiple files open in one of the tabs where the file I want is in one of the vim panes
12:56:13 <arianvp> pane-ception
12:56:49 <arianvp> There _must_ be an easier way D:
12:57:08 <startling> panem et circenses
12:57:39 * arianvp needs to learn latin. and category theory
12:57:59 * arianvp the latter was unrelated to what startling said though
12:58:08 <roconnor> arianvp: you can take edwardk's zygohistomorphic prepromorphism course.
12:58:32 <arianvp> roconnor: Does it include inverted burritos? I'm kind of hungry
12:59:06 <haasn> doubly inverted burritos where the filling gets piped back into the whole thing, placed inside a space suite
12:59:12 <startling> I wonder if latin verbs form a category.
13:00:23 <arianvp> Most Category terms are lend from greek though, right?
13:00:23 <startling> you know, someone needs to write a pure haskell x86 emulator (with a linux compatibility layer) so that we can have IO a -> Maybe a.
13:00:53 <arianvp> I'm pretty sure computers are pure
13:01:12 <startling> well, that's what Nothing is for.
13:02:05 <roconnor> startling: IO a is more like a tree since it responds to input.
13:02:51 <startling> roconnor, obviously you'd have a variant that looks like "interact" (for stdio in the linux compatibility layer)
13:02:53 <arkeet> @quote /bin/ls
13:02:53 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
13:05:11 <arianvp> Hmm I need to implement lexical scoping for my toy-lisp language
13:05:27 <arianvp> What kind of data-structure should I use to keep track of lexical scoping?
13:05:28 <arianvp> .-.
13:05:40 <roconnor> arianvp: lexical scoping is static scoping?
13:06:07 <arianvp> roconnor: Yes
13:06:36 <roconnor> arianvp: you can use edwardk's bindings package.  I forget the name, possibly "bindings".
13:06:48 <litb> hello all
13:06:52 <litb> let fib (x:xs) = fib ((x + (head xs)):x:xs)
13:06:53 <arianvp> @package bindings
13:06:54 <lambdabot> http://hackage.haskell.org/package/bindings
13:07:01 <Guest35913> I'm wondering, is there any typeclass or proper name for something with just extract/copure/coreturn :: f a -> a
13:07:04 <litb> what's wrong with that "fib" function?
13:07:10 <arianvp> nop that didnt work
13:07:23 <litb> fib [1, 0]   doesn't seem to work..
13:07:23 <tomejaguar> I think you mean bound
13:07:29 <startling> arianvp: look at edwardk's "bound"
13:07:30 <startling> yeah
13:07:31 <arianvp> @package bound
13:07:32 <lambdabot> http://hackage.haskell.org/package/bound
13:07:41 <litb> nothing happens
13:07:43 <roconnor> that's the one
13:08:07 <arianvp> alright. will check it out
13:08:11 <arianvp> hope it isnt too complicated ):
13:08:23 <arianvp> (Haskell novice here, toy-lisp is my first serious project)
13:08:24 <monoidal> Guest35913: Copointed
13:08:29 <joelteon> litb: that function should never terminated
13:08:34 <startling> arianvp: it's deadly complicated, but it has nice examples.
13:08:39 <litb> ohh wait... that is silly
13:08:44 <arianvp> So it
13:08:47 <arianvp> is like lens?
13:08:50 <S_J> > let f g (x:xs) = g x : f g xs; f _ [] = []; in (f (+1) [], f (+1) [1,2,3])
13:08:51 <litb> i see now. i should append the numbers instead of prepending it
13:08:51 <lambdabot>   ([],[2,3,4])
13:08:56 <Guest35913> @monoidal thank you
13:08:56 <lambdabot> Unknown command, try @list
13:08:57 <arianvp> as in
13:08:57 <litb> but how to do the proper patter matchinng then?
13:09:05 <arianvp> deadly complicated, but examples make sense?
13:09:11 <litb> i mean   fib (_:x:y) =    will not do what I want
13:09:13 <S_J> @src map
13:09:13 <lambdabot> map _ []     = []
13:09:13 <lambdabot> map f (x:xs) = f x : map f xs
13:09:22 <arianvp> Darn you, edwardk!
13:09:23 <startling> arianvp: yeah. you don't need to understand the magic to use it.
13:09:28 <litb> i wanna have "_" be greedy in the above
13:09:37 <S_J> has anyone here done a haskell bacheloer thesis?
13:09:46 <joelteon> litb: you need to redesign your algorithm
13:09:52 <litb> joelteon: hmm i see
13:10:01 <joelteon> you cannot pattern match on the last few elements of a list
13:10:10 <joelteon> of arbitrary size*
13:10:19 <notdan> S_J: A bachelor thesis on/about Haskell or bachelor thesis which made some use of Haskell?
13:10:59 <litb> joelteon: hmm i see
13:11:06 <Placinta> Is there a cleaner way to pattern match a deeply nested structure than just A (B(C(D(E _ x)))))
13:11:19 <arianvp> I'm starting my bachelor next tuesday.. so nope
13:11:27 <pxqr> Placinta: views?
13:11:33 <FreeFull> > let fib xs = let fibs = xs ++ zipWith (+) fibs (tail fibs) in fibs in fib [0,1]
13:11:34 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:11:53 <litb> nooo i will not look at your code xD
13:11:58 <pxqr> also proposed pattern synonims looks just great
13:12:08 <roconnor> Placinta: you can use prisms.
13:12:23 <Placinta> pqxr: this http://ghc.haskell.org/trac/ghc/wiki/ViewPatterns ?
13:12:28 <FreeFull> I once wrote a more general version that was unfortunately very slow
13:12:31 <pxqr> Placinta: yes
13:12:57 <tomejaguar> pxqr: surely not
13:13:24 <roconnor> Placinta: or just (affine) traversals.
13:13:27 <tomejaguar> this: http://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms
13:13:37 <litb> joelteon: i guess the simplest might be to pass the last two results along
13:14:15 <ski> arianvp : a more simplistic choice is to keep an environment (a set of identifiers, or a map from identifiers) around which will change according to dynamic scope
13:14:34 <pxqr> tomejaguar: well, i mentioned view patters as well :)
13:14:35 <roconnor> ski: that's like a recipie for disaster.
13:14:50 <arianvp> But I don't want dynamic scoping
13:14:50 <ski> how so ?
13:15:04 <roconnor> ski: sure, in principle it can be done correctly, but if you do it incorrectly you end up with LISP.
13:15:07 <ski> arianvp : it'll implement static scoping in the object language
13:15:22 <ski> roconnor : by "LISP", do you mean dynamically scoped lisp ?
13:15:26 <roconnor> yes
13:15:32 <oleo> ah
13:15:32 <Placinta> roconnor: affine traversals and prisms in lens?
13:15:37 <oleo> the old ones
13:15:38 <tomejaguar> pxqr: Ah so you did :)
13:15:38 <pxqr> i guess pattern synonims should be usefull for not so deeply nested patterns
13:15:50 <roconnor> Placinta: yes.
13:16:10 <ski> roconnor : btw, it isn't clear to me yet whether arianvp is talking about static analysis, or interpreting/compiling
13:16:22 <arianvp> ski: interpreting
13:17:48 <tomejaguar> arianvp: Is this helpful? https://www.fpcomplete.com/user/edwardk/bound
13:18:30 <ski> roconnor,arianvp : in any case `checkExpr :: Env -> Expr -> StaticResult' / `checkExpr :: Expr -> Reader Env StaticResult' / `checkExpr :: (?env :: Env) => Expr -> StaticResult' will use dynamic scope for the environment while the object language uses static scope
13:18:41 <roconnor> ski: The point is to make a data type supporting statically bound variables.  Then you can do all those things.
13:19:31 <ski> roconnor : that's the typeful approach. since arianvp is a beginner, i was suggestion an approach that is easier to grasp (but which leaves more room for bugs)
13:19:57 <roconnor> ski: understood
13:20:43 <ski> arianvp : for interpreting, you can use more or less the same as `checkExpr' above, except you need to be careful when interpreting lambda expressions, otherwise you'll implement the (pervasive) dynamic scoping of the original LISP
13:20:45 <jesyspa> Yay, another toy-lisp project.  (Hm, maybe I should contribute to an existing one, not write my own...)
13:20:59 <arianvp> Toy-lisp \o/
13:21:39 <arianvp> Im keeping it simple though.    things can only be bound with (let  )  and (defun ) i s just    (let .. (lambda
13:21:42 <arianvp> etc
13:21:49 <ski> arianvp : btw, i hope you're planning to add macros sooner or later (that being one of the traditionally strong points of Lisps)
13:22:01 <startling> arianvp, jesyspa: you may want to take a look at https://github.com/ekmett/bound/blob/master/examples/Simple.hs
13:22:13 <jesyspa> I've not gotten to let yet, just have lambdas and arithmetic working and am working on the runtime.
13:22:18 <ski> arianvp : lisp-1 or lisp-2 ?
13:22:31 <jesyspa> And I've managed to convert to bound already, though it was painful.
13:23:19 <startling> jesyspa: yeah, removing 2/3 of your hard-written code to switch to an edwardk library is always painful. :(
13:23:56 <jesyspa> Eh, funny thing was that I didn't really lose much code doing it.  I guess it's because the only transformation I did was lambdas -> SKI.
13:24:04 * ski ought to investigate `bound' closer some time
13:24:13 <arianvp> ski: No idea.  the parser is based on this : http://people.csail.mit.edu/jaffer/r5rs_9.html
13:24:18 <jesyspa> Did make the thing more generic, though.
13:24:21 <ski> jesyspa : one fun exercise is to write that transformation as a fold
13:24:56 <pxqr> did someone read about new Intel x86 extension (called TSX) appeared in Haswell? It implements somewhat similar to STM in bare metal. The extension have 2 different forms: HLE and RTM. While former are backward compatible and used for mutex-like things, the latter (Resticted Transactional Memory) used for STM-like things. I wonder if it is possible to implement STM using RTM to speed up STM.
13:25:10 <jesyspa> ski: Eh, I initially wrote it using UUAG. :P
13:25:15 <arianvp> ski: I might need to wrap my head around Foldables and Traversals before I look at any libraries written by edwardk
13:25:18 <ski> arianvp : i hope you don't parse `let' any different from any other symbol
13:25:23 <pxqr> benchmarks shows some neat speed up, but i don't know is it suitable for STM
13:25:29 <ski> jesyspa : that sounds like fun :)
13:25:32 <arianvp> Nah..   'let' is just an atom afaik
13:25:45 <ski> good
13:25:54 <ski> (though the Lisp term is "symbol")
13:25:56 * hackagebot git-annex 4.20130827 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130827 (JoeyHess)
13:26:02 <arianvp> https://github.com/arianvp/Haskeme/blob/develop/src/Language/Haskeme/Parse.hs
13:26:09 <pxqr> also I can't find if someone did related research
13:26:11 <startling> "atom" means something different from "symbol"
13:26:12 <jesyspa> ski: Moved away from UUAG now seeing as I couldn't get it to work with polymorphic types well enough...  But it's still /almost/ a fold.
13:26:13 <arianvp> the parser has some trouble sometimes though
13:26:16 <arianvp> (5a) is parsed as (5 a)
13:26:21 <arianvp> instead of error. etc
13:26:39 <fryguybob> pxqr: I've been working on that very idea this summer.
13:26:40 <arianvp> Not sure why yet. but I will figure it out
13:26:41 <litb> why is this so utterly slow? http://codepad.org/
13:26:41 <Placinta> roconnor: I haven't found anything substantial regarding affine traversal. Whereas prism, it has functions, and I don't believe you can pattern match on a function's result?
13:26:50 <litb> oops.. http://codepad.org/eXBWBxUp
13:26:56 <pxqr> fryguybob: do you have some results?
13:27:08 <ski> arianvp : anyway, R5RS, being a standard for Scheme, means a Lisp-1 (only one namespace, including both functions and other values, as opposed to Lisp-2 as in Emacs Lisp, Common Lisp, in which functions inhabit a different namespace)
13:27:10 <litb> shouldn't "fib" results be momoized?
13:27:15 <mauke> litb: no, why?
13:27:27 <litb> i thought that functional languages does that by default
13:27:31 <mauke> you thought wrong
13:27:38 <litb> hmm, that's bad :(
13:27:41 <ski> arianvp : however, looking at R5RS for syntax doesn't mean that you have to adopt Lisp-1 if you don't want to ..
13:27:42 <startling> litb, they should, but you haven't written the part where you memoize them yet.
13:27:46 <mauke> litb: no, it's good
13:27:49 <pxqr> in particular transactional log in hardware sound like nonsence for me
13:28:12 * arianvp is sad that he discovered that someone else was already smart enough to call his toy-lisp project 'Haskeme'
13:28:13 <litb> startling: oh
13:28:17 <ski> startling : "\"atom\" means something different from \"symbol\"" -- i know
13:28:50 <S_J> notdan: either...
13:29:08 <ski> (more properly, in modern systems (at least on the Schemey side), "atom" tends to mean less, or possibly nothing at all (or at least nothing very useful))
13:29:27 <arianvp> a `prefixWith` b = List . ([Atom b] ++) . (:[]) <$> (a *> expr)
13:29:29 <pxqr> fryguybob: oh, do you mean GHC will support TSX?
13:29:30 <arianvp> I love this line of code.
13:29:33 <fryguybob> pxqr: I don't have useful results yet, but it may be the case that it opens GHC's STM up to workloads that it could not handle well.
13:29:38 <tromp__> there is also a "Hascheme"
13:29:56 <levi> litb: You may be thinking of how in haskell, an expression that is passed to two different sites is still only evaluated once.
13:30:04 <jesyspa> arianvp: Why <$> (a *> expr) intead of <$ a <*> expr?
13:30:06 <arianvp> I might rename it to  `lithp` for obvious reasons :P
13:30:24 <fryguybob> pxqr: I've extended GHC's STM to use Intel TSX for speed up and have less overhead for how the RTS implements STM.  The API for the programmer is the same.
13:30:26 <arianvp> jesyspa: Because when I wrote this I was not aware of <$
13:30:30 <tromp__> but that is ha as in half-assed, not as in Haskell
13:30:55 <fryguybob> pxqr: I'm not sure whay you mean by "transactional log in hardware sounds like nonsense".
13:31:02 <ski> arianvp : `([Atom b] ++)' is `(Atom b :)'
13:31:19 <levi> litb: Which is standard for languages with a strict evaluation order, since it has to be evaluated before it's passed the first time in those, but it doesn't always happen in languages that allow passing of un-evaluated expressions.
13:31:48 <arianvp> ski: thanks. ha this is embarressing
13:31:49 <pxqr> fryguybob: doesn't hardware keep some kind of log (read set, write set) per cache line?
13:32:13 <ski> arianvp : not really. nothing wrong with the former if you think it's prettier
13:32:17 <notdan> S_J: I am writing my bachelor diploma and I implement the software I need in Haskell
13:32:23 <pxqr> fryguybob: for example then we need to commit transaction we need to write from L1 to L2, right?
13:32:28 <arianvp> Isnt ++ slower though?
13:32:57 <pxqr> actually I started to dig into this recently
13:33:06 <ski> well, `[Atom b]' has length `1', so `++' will only have to traverse that cons cell (unless the compiler manages to optimize that away)
13:33:49 <ski> arianvp : you should watch out for `xs ++ ys' with `xs' a long list, *especially* if you keep adding stuff to the end using `++'
13:33:53 <litb> levi: oh
13:33:54 <fryguybob> pxqr: There are not very many details about Haswell's implementation that are public.
13:33:54 <pxqr> so my understanding i far from truth
13:34:30 <arianvp> Still find <$> (a *> expr) easier than using <$ though
13:34:30 <ski> arianvp : e.g. `foo ... = ..base case..; foo ... = foo (...) ++ ...' is usually a bad sign
13:34:39 <arianvp> makes it less obscure what is happening
13:35:07 <ski> then keep it that way, at least for the while
13:35:19 <fryguybob> pxqr: But there are several papers detail various HTM implementations if you are looking for how it *could* be done efficiently.
13:35:31 <roconnor> Placinta: you can use preview, to get a Maybe a to match on.
13:35:48 <jesyspa> How strictly does Haskell code in the wild stick to things like camelCase and other stylistic questions?
13:35:54 <arianvp> noow I just need to fix the case where     (5a) gets parsed like (5 a)
13:36:01 <pxqr> fryguybob: do you mean hierarchical temporal memory?
13:36:21 <roconnor> Placinta: works well in conjuction with view patterns or pattern guards
13:36:25 <arianvp> jesyspa: What I've heard, people get stoned forNotStickingToCamelCase.. but those are just rumors
13:36:49 <Guest35913> what do I do to get two potentially overlapping instances to compile?
13:36:57 <ski> camelCase seems to be more common, but under_scores isn't unseen
13:37:06 <arianvp> -XOverlappingInstances  or use a newtype wrapper
13:37:10 <fryguybob> pxqr: Hardware Transactional Memory
13:37:29 <Guest35913> I have OverlappingInstances and UndecidableInstances
13:37:48 <jesyspa> Hmm, guess I'll change it just to make hlint happy...
13:38:01 <ski> `OverlappingInstances' is generally considered to be evil
13:38:18 <pxqr> fryguybob: thanks; i'll read about this
13:38:22 <arianvp> I usually use _ for small inline comments when I got a lot of version of some function when experimenting in ghci etc
13:38:23 <Guest35913> It's just cause there's two possible implementations for something
13:38:23 <arianvp> instead of
13:38:25 <arianvp> f''''''''
13:38:28 <ski> (`UndecidableInstances' is fine, as long as your compilation terminates)
13:38:30 <arianvp> f_theonethatdoesitthatway
13:38:48 <Guest35913> The problem is that they have the same form but different constraints
13:39:07 <ski>   separating'with'primes
13:39:12 <Guest35913> like two that are both q f g but one requires one thing of f and the other of g
13:39:19 <Guest35913> without going into specifics
13:39:43 <arianvp> Ugh I wish there was a text-editor that renders haskell-code like it does in my LaTeX stuff
13:39:54 <arianvp> I dont need monospace editor when working on haskell, grrrr
13:40:37 * ski generally prefers monospace, so as to be able to align patterns in different equations/branches, &c.
13:40:45 <Guest35913> why would you not want monospace?
13:40:50 * arianvp thinks the editor should do that automagically
13:40:57 <arianvp> because monospace fonts are hard to read
13:41:10 <Guest35913> and the editor doing that automatically wouldn't?
13:41:11 <b2coutts> arianvp: maybe you haven't tried out good ones :)
13:41:22 <koala_man> how will your boss know you're coding if your screen isn't covered in monospace?
13:41:54 <arianvp> Oh that's why i'm unemployed....
13:41:57 <arianvp> >.>
13:42:02 <RevJohnnyHealey> I can't imagine not coding in monospace.
13:42:06 <ski> Guest35913 : such instance resolution meant to depend on constraints can be hard. perhaps if you show concrete code, someone in here can give some suggestion
13:42:09 <RevJohnnyHealey> It sounds...scary...
13:42:14 <arianvp> Well I thought it woul be an interesting idea for once
13:42:14 <levi> Layout parsing might be a bit trickier in a non-monospace font.
13:42:24 <Guest35913> what's that haskell pastebin version?
13:42:26 <arianvp> math isnt monospaced in papers, yet it's still aligned and all pretty
13:42:30 <ski> @paste
13:42:30 <lambdabot> Haskell pastebin: http://lpaste.net/
13:42:34 <Eduard_Munteanu> Nonsense, a structural editor would support proportional fonts. ;)
13:42:44 <Eduard_Munteanu> Or just a smart editor really.
13:42:58 <Guest35913> http://lpaste.net/2485827011071705088
13:43:18 <ski> Eduard_Munteanu : but would it align "corresponding" parts in the bodies of separate defining equations with each other ? :)
13:43:24 <Eduard_Munteanu> But these days most editors still live in the Regex Age.
13:43:36 <levi> Well, it would have to know about the parser it had to keep happy so it could insert the appropriate amount of space to simulate monospace-written code.
13:43:42 <Eduard_Munteanu> Hm, fair.
13:43:57 <arianvp> Meh. I
13:44:08 <arianvp> if LaTeX can do it to papers. we can do it to code
13:44:10 <supki> Guest35913: you will need a newtype for one of those instances
13:44:14 <arianvp> that's my argument
13:44:24 <levi> arianvp: Computers don't have to read LaTeX *output*
13:44:26 <Guest35913> Ugh, that makes things much more annoying
13:44:34 <supki> Guest35913: constraints are ignored in instance lookup
13:44:39 <ski> (`(=<<) (getComp . f) (getComp m)' is `getComp . f =<< getComp m', btw)
13:44:42 <arianvp> levi: that's true..
13:44:51 <arianvp> it's just some wet dream I have I guess
13:44:58 <Eduard_Munteanu> arianvp: that's a bit different... in LaTeX you write code to typeset. In normal editors you write code. Imagine if you had to write code *and* write code to typeset that code. :)
13:45:07 <quchen> arianvp: Latex is not a very good example here. Alignment in Latex is not trivial.
13:45:07 <arianvp> Nonnonon
13:45:30 <arianvp> the whole point of LaTeX is not to think of typesetting (Not true in all cases, I must admit)  and to let the compiler do the work
13:45:30 <mauke> what if you had to write a haskell compiler in tex
13:45:35 <quchen> arianvp: And remember we don't only want the code to look acceptable, it also has to parse unambiguously. You never have to parse a Latex-generated file.
13:45:37 <Guest35913> I felt in the chain of composition that just putting the =<< there rather that infixing it was nicer
13:45:38 <Eduard_Munteanu> Eww, mauke.
13:45:50 <arianvp> quchen: true
13:45:52 <haasn> mauke: what if you had to write a haskell compiler to tex?
13:45:57 * hackagebot BlogLiterately 0.6.1 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.6.1 (BrentYorgey)
13:46:07 <haasn> .. in sed
13:46:24 <b2coutts> writing that much code in sed? ugh
13:46:26 * Eduard_Munteanu feels this room is getting more and more obscene lately :P
13:46:29 <ReinH> haasn: You can write a chess engine in sed. What now?
13:46:33 <b2coutts> I'd rather write a compiler from haskell to sed in haskell
13:46:33 <quchen> arianvp: All in all I think it's easier to get used to monospace than writing that dream editor ;-)
13:46:41 <arianvp> operating systems were written in ed. respect the ed!
13:46:45 <haasn> ReinH: yeah, I saw that :)
13:46:51 <b2coutts> so I can write my haskell->tex compiler in sed using haskell
13:47:09 <ReinH> haasn: makes me feel pretty inadequate for not finishing my haskell one...
13:47:19 <ReinH> haasn: but I'm working on game trees again so I might make some progress
13:47:21 <levi> Fortress was interesting in that it was designed to support both monospace-ascii and more graphically-enhanced editing modes.
13:47:47 <arianvp> Well another reason why I don't like monospace....
13:48:00 <haasn> ReinH: implementation progress should be sped up now that we have lens
13:48:01 <arianvp> Haskell supports unicode. and most monospace fonts dont cover all of the unicode
13:48:08 <arianvp> So code just gets ugly
13:48:16 <arianvp> if you use that kind of stuff :P
13:48:39 <haasn> so instead you propose using variable width fonts, so code gets ugly all the time? :)
13:48:56 <quchen> arianvp: Don't use Unicode. (Don't use things in code you cannot type easily.)
13:49:22 <quchen> arianvp: Display certain Haskell commands in Unicode? Well if your editor wants to, but don't save that stuff in the actual files.
13:49:27 <napping> proportional fonts should work okay, with some editor support
13:49:41 <napping> lhs2TeX has a decent way to record alignment
13:49:55 <arianvp> as long as columnn alignment is maintained through correct kerning etc,  non-monospace fonts shouldnt be a problem
13:50:12 <arianvp> but the editor should know about columns though...By saving it as if it was monospace
13:50:23 <[swift]> i tried using a plugin that replaced common haskell syntax and functions with unicode symbols, but what made me stop was that it involved collapsing sequences of multiple characters to a single character, so things were either aligned with the plugin enabled or aligned with it disabled but never both
13:50:37 <ReinH> haasn: yeah, I'm looking forward to implementing the traversal using lenses
13:50:40 <[swift]> i found that more disturbing than just sticking with ascii operators
13:50:52 <ReinH> haasn: like TIL about `levels` and my mind sort of blew up.
13:51:23 <haasn> I haven't actually looked at/understood levels yet, but make sure not to tell that to edwardk or he'll blow my sleep deprived mind up
13:51:28 <c_wraith> I'm currently baffled by the purposed of Indexable in lens.
13:51:30 <ReinH> haasn: hah :)
13:51:46 <c_wraith> Other than that, for my first foray into it, it makes a lot of sense.
13:52:03 <haasn> c_wraith: Indexable is just so you can ‘forget’ about the index for indexed traversals
13:52:07 <haasn> and use them as normal traversals instead
13:52:13 <litb> what's up with this?
13:52:15 <litb> http://codepad.org/Jlp3TtJn
13:52:21 <arianvp> Noob question: Why isn't Set a functor?
13:52:25 <c_wraith> haasn: oh.  That'd explain why the instances ignore i
13:52:32 <arianvp> My notion of Functor has always been  "Stuff that contains stuff"
13:52:42 <litb> it nearly crashed my box by doing infinitely many mallocs
13:52:48 <c_wraith> arianvp: logically, it should be.  technically, there's a problem
13:53:05 <c_wraith> arianvp: the problem is that the implementation of Set requires an Ord instance for the elements
13:53:17 <ReinH> litb: you appear to be attempting to reverse an infinite list?
13:53:18 <c_wraith> arianvp: and there's nowhere in the type signature of fmap to put that Ord instance
13:53:21 <haasn> c_wraith: eg. ‘over traversed’ unifies the Indexable Int p => p ~ (->)
13:53:32 <haasn> but ‘iover traversed’ unifies it with Indexed Int
13:53:48 <arianvp> c_wraith:  can't we move the Ord requirement out of the instance definition?
13:53:52 <litb> ReinH: as far as I see te largest list I reverse is 9 elements long?
13:54:01 <litb> where does the infinite list occur?
13:54:12 * jfischoff wishes it was 'lover traversed'
13:54:19 <arianvp> interface definition*
13:54:30 <c_wraith> arianvp: You could try..  But the result of something like fmap negate on a Set Int would be totally broken
13:54:47 <ReinH> litb: true
13:54:59 <c_wraith> arianvp: no further set operations would work properly, because the binary search tree property would be thoroughly violated.
13:55:02 <haasn> c_wraith: not that we need it anymore :)
13:55:06 <ReinH> litb: it does look like it uses exponential space though?
13:55:12 <haasn> instance Functor Set, that is
13:55:28 <litb> ReinH: hmm
13:56:07 <litb> i thought that "take 2 (reverse x)" because of lazy evaluation only touches 2 elements of "x" ?
13:56:22 <c_wraith> litb: it only touches 2 elements of reverse x
13:56:29 <c_wraith> litb: reverse x requires touching all the elements of x
13:56:56 <litb> c_wraith: hmm
13:57:04 <c_wraith> litb: remember what data structre [] is.  singly-linked list
13:57:09 <ReinH> litb: you can't reverse a linked list without traversing it
13:57:12 <Lethalman> > take 2 (reverse [1..])
13:57:14 <S11001001> litb: well, it touches *zero* elements, but must touch the entire list structure.
13:57:21 <Lethalman> litb, how would you do that ^^ :-)
13:57:21 <lambdabot>   mueval-core: Time limit exceeded
13:57:41 <tromp__> null (reverse [0..])
13:57:48 <tromp__> cant even tell if its empty...
13:57:59 <litb> c_wraith: ohh! i see
13:58:03 <ReinH> S11001001: it gives each thunk in the list a loving embrace
13:58:04 <ReinH> :p
13:58:19 <litb> c_wraith: so I have absolutely no choice but to pass the last two elements along even if i already have them in the list
13:58:27 <litb> c_wraith: i wanted to avoid that because it looks unelegant
13:58:29 <S11001001> ReinH: petition to rename whnf
13:58:37 <ReinH> S11001001: in my mind I see it like a game of duck duck goose
13:58:40 <tromp__> null (reverse [0..]::[Word8])
13:58:42 <arianvp> how does [1..] get desugareD?
13:58:44 <ReinH> traversing the list and going "duck, duck, duck..."
13:58:49 <c_wraith> arianvp: enumFrom 1
13:58:58 <litb> c_wraith: but, seriously, 9 elements should not cause a out-of-memory error
13:59:23 <litb> Lethalman: but my list is not infinite
13:59:24 <c_wraith> litb: ah.  That sounds like an entirely different issue, where you're holding on to lots of intermediate data structures due to laziness
13:59:29 <S11001001> tromp__: >
13:59:43 <litb> i'm reversing "x", which is  [0, 1], then [0, 1, 1] then [0, 1, 1, 2...] up to 9
13:59:54 <litb> the main function doesn't take more elements from it, as far as i can see?
14:00:32 <litb> or does the invocation of "fibsc" somehow "disconnect" the main function's take from it so that it doesn't know how much elements to consume?
14:00:34 <Lethalman> litb, doesn't seem you have a base case
14:00:38 <arkeet> litb: fibsc never produces anything.
14:00:52 <Lethalman> when does it stop?
14:01:49 <litb> oh i see what I have wrong now. i guess i wanted to put the "x ++" outside
14:02:11 <Lethalman> litb, yes that might be a good setp :)
14:02:13 <Lethalman> *step
14:03:48 <arkeet> so would figuring out how to actually generate the fibonacci sequence.
14:04:07 <arkeet> btw, head (reverse xs) = last xs
14:04:19 <arkeet> although both head and last are evil.
14:06:32 <litb> arkeet: ah thanks
14:07:18 <litb> arkeet: why is it evil?
14:07:28 <arkeet> because they're partial functions.
14:07:32 <arkeet> they blow up when you apply them to []
14:08:31 <litb> arkeet: oh that's no good
14:09:04 <haasn> :t view _head
14:09:07 <lambdabot> (MonadReader s m, Cons (->) (Accessor a) s s a a) => m a
14:09:22 <haasn> or uh
14:09:25 <haasn> :t preview _head
14:09:29 <lambdabot> (MonadReader s m, Cons (->) (Accessor (First a)) s s a a) => m (Maybe a)
14:09:47 <arkeet> :t preview folded
14:09:50 <lambdabot> (Foldable f, MonadReader (f a) m) => m (Maybe a)
14:10:04 <arkeet> :t take 1
14:10:06 <lambdabot> [a] -> [a]
14:10:11 <haasn> :t preview _tail -- :)
14:10:14 <lambdabot> (MonadReader s m, Cons (->) (Accessor (First s)) s s a a) => m (Maybe s)
14:10:15 <arkeet> :)
14:10:22 <ReinH> arkeet: Fibonacci sequences are more interesting when applied to other vector spaces
14:10:25 <haasn> :t preview (dropping 1 folded) -- ;)
14:10:28 <lambdabot> (Foldable f, MonadReader (f a) m) => m (Maybe a)
14:10:34 <arkeet> :t preview (backwards folded)
14:10:40 <lambdabot> (Foldable f, MonadReader (f b) m) => m (Maybe b)
14:10:42 <arkeet> =)
14:10:57 <arkeet> > [1..5] ^? backwards folded
14:10:57 <litb> nice, now i got it to work :) http://codepad.org/Yo5ZXzDa
14:11:03 <lambdabot>   Just 5
14:11:09 <haasn> I don't think I need to give the _last and _init examples to complete this
14:11:16 <arkeet> litb: good work :)
14:11:22 <arkeet> btw, [a] ++ b = a : b
14:11:44 <haasn> litb: mind your strictness
14:11:46 <litb> ah right
14:12:22 <arkeet> haasn: should be fine in this case.
14:12:35 <haasn> arkeet: he's going to build up huge chains of (+)
14:12:48 <litb> haasn: what do you mean?
14:12:51 <haasn> oh, because of print, you mean?
14:12:54 <haasn> yeah should be fine
14:12:54 <arkeet> not if you force the elements of fibs in order
14:13:07 <litb> i need to do this up to 4 million fib numbers
14:13:07 <arkeet> but fibs !! 1000 will explode.
14:13:13 <haasn> still wouldn't hurt to optimize it :)
14:13:22 <litb> arkeet: oops
14:13:31 <arkeet> litb: turn on BangPatterns, and then fibsc !x1 !x2 = ...
14:13:38 <arkeet> will magically fix everything.l
14:13:40 <haasn> or just !x2, really
14:13:43 <arkeet> true.
14:15:29 <litb> i wanna fold over the first 4 million elements. will it not have O(1) space requirement then?
14:15:39 <litb> i mean, the old elements are not needed anymore when folded over
14:15:44 <haasn> as long as your folding function is strict
14:15:56 <litb> ah
14:15:58 <haasn> but if you add the bang pattern it shouldn't matter
14:16:10 <haasn> well, as far as thunks are concerned
14:16:14 <arkeet> consider using x and y instead of x1 and x2 ;)
14:16:19 <haasn> I don't know if folding 4 million elements of that is a good idea in general :)
14:16:26 <litb> i'm not sure what magical option that is. i wanna try with the vanilla environment
14:16:44 <arkeet> -XBangPatterns or {-# LANGUAGE BangPatterns #-} to turn on an extension.
14:16:45 <haasn> for vanilla you can just replace the body by x2 `seq` ... where ... is whatever it was
14:16:49 <arkeet> but sure.
14:16:53 <arkeet> seq does it.
14:16:56 <haasn> (importing seq, obviously)
14:16:58 <haasn> in fact
14:17:01 <haasn> that's exactly what the bang pattern means
14:17:08 <litb> haasn: ahh thanks
14:17:14 <haasn> it's desugars to that or something like that
14:17:29 <haasn> and ‘seq a b’ evaluates ‘a’ to WHNF before returning ‘b’
14:17:38 <arkeet> does f !x !y = ... mean f x y = x `seq` y `seq` ..., or is it f = \x -> x `seq` \y -> y `seq` ...
14:17:42 <arkeet> I guess I should read the docs.
14:18:22 <haasn> there must be some way to find this out via experiment
14:18:31 <arkeet> i.e. is f undefined bottom or not.
14:18:46 <tomejaguar> arkeet: Well, you could give it a go :)
14:18:48 <arkeet> yes
14:19:01 <ReinH> litb: when you're done with the basic fibonacci sequence, try writing a function that detects Keith numbers. (http://en.wikipedia.org/wiki/Keith_number)
14:19:13 <haasn> > let f !x !y = () in f undefined `seq` ()
14:19:16 <lambdabot>   ()
14:19:19 <arkeet> yes
14:19:28 <quchen> haasn: "f = \x -> ..." is never bottom, is it? On the other hand, "f !x !y = ..." can be bottom, e.g. when f _ _ = undefined
14:19:37 <haasn> > let f x = x `seq` \y -> y `seq` () in f undefined `seq` ()
14:19:41 <lambdabot>   *Exception: Prelude.undefined
14:20:07 <ski> > let f !x !y = () in seq f ()
14:20:10 <lambdabot>   ()
14:20:11 <litb> i will need to read my Bird book about Bottoms and strictness to understand it I guess
14:20:12 <arkeet> I expected it to be the non-lambda version.
14:20:18 <haasn> arkeet: yeah so did I
14:20:28 <arkeet> since that one's lazier.
14:20:50 <monoidal> quchen: \(!x) -> ... is not bottom, either
14:21:04 <arkeet> I guess that means \(!x) (!y) -> ... and \(!x) -> \(!y) -> ... are different?
14:21:11 <ski> yep
14:21:14 <arkeet> > (\(!x) (!y) -> ()) undefined `seq` ()
14:21:15 <lambdabot>   ()
14:21:16 <quchen> monoidal: But "f pat" is generally not "f = \pat ->", that's what I meant
14:21:17 <arkeet> > (\(!x) -> \(!y) -> ()) undefined `seq` ()
14:21:18 <lambdabot>   *Exception: Prelude.undefined
14:21:20 <arkeet> :)
14:21:34 <monoidal> ah I see.
14:22:50 <litb> ReinH: actually, all this is just to solve the second euler problem :D
14:22:54 <warp> hello, I'm trying to figure out what the ">>" operator does, what is a good reference manual to look up things like that?
14:23:14 <arkeet> hoogle is good for looking up things.
14:23:17 <arkeet> @where hoogle
14:23:17 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
14:23:22 <arkeet> @hoogle (>>)
14:23:22 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
14:23:22 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
14:23:22 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
14:23:26 <ParahSailin> @ty (>>)
14:23:27 <lambdabot> Monad m => m a -> m b -> m b
14:23:28 <arkeet> in this case, it's a typeclass method.
14:23:58 <haasn> as for what it does, I recommend LYAH
14:24:00 <warp> arkeet: thanks!
14:24:03 <haasn> or perhaps the typeclassopedia
14:24:07 <ParahSailin> @src [] (>>)
14:24:07 <lambdabot> xs >> ys      = concatMap (const ys) xs
14:24:51 <arkeet> but yeah, as for what it's good for, I guess you'd need to learn about monads.
14:24:53 <monoidal> warp: (>>) is an operator derived from (>>=) via x >> y = x >>= (\_ -> y)
14:24:55 <arkeet> since it's a monad thing.
14:25:25 <arkeet> also, do {x; y} = x >> y.
14:25:27 <arkeet> (well, almost.)
14:26:21 <ReinH> litb: The Euler problems are fun but I think mine is fun too! :D
14:26:43 <ReinH> litb: The fibonacci sequence has some interesting properties that can make solutions to some of the Euler problems more efficient :)
14:27:10 <ReinH> litb: this particular problem in particular :)
14:27:17 <litb> ReinH: ah nice
14:27:33 <litb> i will look up what it's about when I'm finished with this one
14:27:37 <ReinH> litb: as a little hint, how often do even numbers appear in the sequence?
14:28:37 <tromp__> 1/3?
14:30:07 <arkeet> ~modular arithmetic~
14:30:21 <ReinH> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 20 $ map even fibs
14:30:23 <lambdabot>   [True,False,False,True,False,False,True,False,False,True,False,False,True,F...
14:30:30 <ReinH> ignoring 0, which is a special case
14:30:46 <litb> ReinH: i guess because of the rule  odd + even = odd, even + even = even, odd + odd = even, it can be shown that 1/3 of them is odd
14:30:52 <arkeet> > let fibs = 0 : 1 + zipWith (((`mod` 2) .) . (+) fibs (tail fibs)
14:30:55 <lambdabot>   <hint>:1:65:
14:30:55 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
14:30:56 <arkeet> > let fibs = 0 : 1 + zipWith (((`mod` 2) .) . (+)) fibs (tail fibs)
14:30:56 <ReinH> litb: 1/3 of them is even, that is
14:30:58 <lambdabot>   not an expression: `let fibs = 0 : 1 + zipWith (((`mod` 2) .) . (+)) fibs (...
14:31:00 <tromp__> how often to multiples of 3 appear?
14:31:03 <arkeet> > let fibs = 0 : 1 + zipWith (((`mod` 2) .) . (+)) fibs (tail fibs) in fibs
14:31:04 <lambdabot>   No instance for (GHC.Show.Show a0)
14:31:04 <lambdabot>    arising from a use of `M1075170017.sh...
14:31:07 <arkeet> urgh.
14:31:09 <ReinH> arkeet: yes, you can use a modular ring :)
14:31:11 <arkeet> > let fibs = 0 : 1 : zipWith (((`mod` 2) .) . (+)) fibs (tail fibs) in fibs
14:31:12 <lambdabot>   [0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,...
14:31:14 <ReinH> yay algebra
14:31:16 <arkeet> sorry for the spam.
14:31:26 <ReinH> arkeet: np, that's a nicer example
14:31:36 <arkeet> > let fibs = 0 : 1 : zipWith (((`mod` 5) .) . (+)) fibs (tail fibs) in fibs
14:31:39 <ReinH> litb: the point is that every third fibonacci number is even
14:31:40 <lambdabot>   [0,1,1,2,3,0,3,3,1,4,0,4,4,3,2,0,2,2,4,1,0,1,1,2,3,0,3,3,1,4,0,4,4,3,2,0,2,...
14:31:41 <litb> ReinH: oh
14:32:04 <arkeet> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in map (`mod` 5) fibs
14:32:06 <lambdabot>   [0,1,1,2,3,0,3,3,1,4,0,4,4,3,2,0,2,2,4,1,0,1,1,2,3,0,3,3,1,4,0,4,4,3,2,0,2,...
14:32:42 <ReinH> litb: which means you don't need to calculate all fibs and then filter the even ones
14:32:47 <ReinH> you can generate the even fibs directly
14:32:51 <kittymorphism> let f x = 3
14:32:55 <kittymorphism> > let f x = 3
14:32:57 <lambdabot>   not an expression: `let f x = 3'
14:33:23 <kittymorphism> no let binds?
14:33:29 <ReinH> > let f x = 3 in f undefined
14:33:30 <lambdabot>   3
14:33:55 <lpaste> enthropy pasted “fundep and typefamily hzip implementations” at http://lpaste.net/92221
14:33:59 <litb> ReinH: ohh
14:35:03 <arkeet> observation: let A = [0, 1; 1, 1] be the matrix of the linear recurrence producing fibonacci.
14:35:08 <arkeet> then A^3 = 1 (mod 2)
14:35:08 <enthropy> somebody familiar with typefamilies can suggest improvements for what I pasted above?
14:35:45 <Placinta> What is the order evaluation for           extend = fmap f . duplicate?          is it the same as    extend = fmap (f.duplicate) ?
14:36:00 <ReinH> Placinta: look at the types
14:36:03 <arkeet> Placinta: function application binds more tightly than any operator.
14:36:24 <arkeet> (the only thing it binds less tightly than is record updates.)
14:36:49 <elliott> arkeet: and module qualification
14:36:53 <kittymorphism> $!
14:36:56 <kittymorphism> ?
14:37:04 <arkeet> elliott: oh, sure.
14:37:30 <arkeet> depends on whether you count that as a lexical thing.
14:37:38 <ReinH> kittymorphism: is that a question?
14:37:41 <ski> Placinta : terminology, this isn't "order of evaluation" but "how it is parsed", where precedence and fixity are relevant
14:37:55 <kittymorphism> i thought that bound more tightly ..
14:38:10 <arkeet> $! is an ordinary operator.
14:38:19 <arkeet> > (0$0$!)
14:38:21 <lambdabot>   The operator `Prelude.$!' [infixr 0] of a section
14:38:22 <lambdabot>      must have lower prec...
14:38:22 <ski> arkeet : and lazy pattern, and record construction, and bang pattern
14:38:33 <Placinta> ski:  ok
14:38:35 <kittymorphism> ah ok
14:38:45 <arkeet> ski: I mentioned records. patterns don't count since they don't appear in the same context as function application.
14:38:49 <sipa> Placinta: it's the same as (fmap f) . (duplicate)
14:38:58 <Placinta> sipa: Aye, figured it out now
14:39:05 <sipa> ok
14:39:11 <monoidal> Placinta: if you have an expression like "f x + g y z t * map f x", you should read it as (f x) + (g y z t) * (map f x)
14:39:17 <ski> Placinta : i'm just saying this so as to avoid confusion in the future. of course you're not expected to know this beforehand
14:39:50 <Placinta> monoidal: An expression like that is easy to parse. I get confused when I see composition :)
14:39:55 <ski> and because `*' binds more tightly (has higher precedence) than `+', that really means `(f x) + ((g y z t) * (map f x))'
14:40:36 <ski> (and that really means `(f x) + ((((g y) z) t) * ((map f) x))' since function application "associates to the left", as "left fixity")
14:41:13 <sipa> and: (a b . c d $ g e)    is the same as ((a b) . (c d)) $ (g e)
14:42:24 <lpaste> greg` pasted “No title” at http://lpaste.net/92222
14:42:28 <ReinH> Placinta:  me too... me too.
14:42:57 <enthropy> dmwit: do you know if the HZ class in  http://lpaste.net/92221 can be written in less code? (say with less parameters etc.)
14:43:01 <haasn> enthropy: http://lpaste.net/92221
14:43:34 <haasn> see my annotation
14:44:09 <haasn> oh, doesn't work for unzip though, I think
14:44:11 <haasn> hmm
14:44:12 <lpaste> greg` revised “No title”: “No title” at http://lpaste.net/92222
14:46:07 --- mode: ChanServ set +o monochrom
14:46:34 --- mode: monochrom set -bb *!*@122-59-82-97.jetstream.xtra.co.nz *!*@121.99.86.70
14:46:42 --- mode: monochrom set -o monochrom
14:47:50 <haasn> either way, you can get hunzip without a type class via a similar technique
14:48:34 <tel> Is there a convenient way to get the result of applying a type family?
14:48:49 <monoidal> tel: :kind!
14:48:49 <haasn> you mean name it?
14:48:51 <tel> in GHCi
14:48:52 <arkeet> hm, is it of any significance to fibonacci mod 11 that (x^2 - x - 1) has a root mod 11
14:48:52 <haasn> oh
14:49:11 <tel> monoidal ooh!
14:49:27 <arkeet> specifically it factors as (x - 4)(x - 8)
14:49:35 <tel> monoidal What does the ! do generally?
14:49:41 <arkeet> this isn't haskell.
14:49:54 <tomejaguar> root mod 11?
14:50:04 <monoidal> tel: it varies from command to command, there's no set meaning
14:50:05 <arkeet> 4 and 8 are zeros of x^2 - x - 1, mod 11.
14:50:13 <tomejaguar> oh right
14:50:25 <arkeet> because sqrt(5) exists in integers mod 11.
14:50:45 <tel> monoidal it's also not documented at :help
14:50:49 <tel> monoidal but very cool, thanks!
14:51:08 <monoidal> tel: yes, it's an oversight
14:51:15 <datalligator> \quit Sleep o'clock
14:51:26 <monoidal> tel: for an almost complete list, http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/ghci-commands.html
14:51:48 * datalligator quit
14:51:54 <tel> monoidal Tremendous, thanks again
14:52:11 <Placinta> Why duplicate . duplicate a doesn't work, whereas duplicate . duplicate $ a works?
14:52:13 <geekosaur> you'll get it right eventually...
14:52:24 <arkeet> Placinta: because the former is duplicate . (duplicate a)
14:52:27 <arkeet> and the latter is (duplicate . duplicate) a
14:52:36 <arkeet> and only one of those makes sense.
14:52:52 <Placinta> sigh, the space has higher precedence again
14:53:21 <tomejaguar> Placinta: once you get that function application has higher precedence than everything it becomes much easier.
14:53:34 <arkeet> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
14:53:37 <lambdabot>  Defined.
14:53:43 <arkeet> > map (`mod` 11) fibs
14:53:50 <lambdabot>   mueval-core: Time limit exceeded
14:53:55 <ReinH> you might want to take a few of those...
14:53:58 <arkeet> ...
14:53:59 <arkeet> > map (`mod` 11) fibs
14:54:02 <arkeet> oh right.
14:54:07 <lambdabot>   mueval-core: Time limit exceeded
14:54:07 <arkeet> > take 50 $ map (`mod` 11) fibs
14:54:15 <lambdabot>   mueval-core: Time limit exceeded
14:54:20 <arkeet> augh.
14:54:22 <Placinta> >take 5 $ map (`mod` 11) fiibs
14:54:24 <ReinH> arkeet: a couple questions for you
14:54:37 <Placinta> > take 5 $ map (`mod` 11) fibs
14:54:45 <lambdabot>   mueval-core: Time limit exceeded
14:54:48 <ReinH> arkeet: fist, is F(mod m) periodic?
14:54:50 <arkeet> @let fibs' r = 0 : 1 : zipWith (\x y -> r (x+y)) fibs (tail fibs)
14:54:51 <tomejaguar> > take 5 fibs
14:54:53 <lambdabot>  Defined.
14:54:55 <arkeet> ReinH: yes.
14:54:59 <lambdabot>   mueval-core: Time limit exceeded
14:55:02 <arkeet> oh shit.
14:55:03 <ReinH> arkeet: how do you calculate the period?
14:55:07 <arkeet> @let fibs'' r = 0 : 1 : zipWith (\x y -> r (x+y)) fibs'' (tail fibs'')
14:55:08 <lambdabot>  .L.hs:151:42:
14:55:08 <lambdabot>      Couldn't match expected type `[a1]'
14:55:08 <lambdabot>                  with...
14:55:26 <enthropy> haasn: thanks that's much better
14:55:28 <ReinH> arkeet: in terms of m, that is
14:55:30 <arkeet> @let fibs'' r = 0 : 1 : zipWith (\x y -> r (x+y)) `ap` tail $ fibs'' r
14:55:32 <arkeet> ReinH: sounds hard.
14:55:33 <lambdabot>  .L.hs:151:5:
14:55:33 <lambdabot>      Couldn't match expected type `t0 -> t0' with actual type `...
14:55:46 <arkeet> @let fibs'' r = 0 : 1 : zipWith (\x y -> r (x+y)) `ap` tail (fibs'' r)
14:55:50 <lambdabot>  .L.hs:151:13:
14:55:50 <lambdabot>      Couldn't match expected type `[a0 -> a0]'
14:55:50 <lambdabot>                ...
14:55:57 <arkeet> oh urgh.
14:56:00 <arkeet> @let fibs'' r = 0 : 1 : (zipWith (\x y -> r (x+y)) `ap` tail (fibs'' r))
14:56:03 <lambdabot>  .L.hs:151:14:
14:56:03 <lambdabot>      Couldn't match expected type `[a0 -> a0]'
14:56:03 <lambdabot>                ...
14:56:09 <monoidal> arkeet: FYI 11 should not be that special in this regard. modulo any prime p>5, if 5 is a quadratic residue, the polynomial x^2-x-1 should factor.
14:56:15 <arkeet> monoidal: I know.l
14:56:26 <arkeet> I just looked at a table of quadratic residues to find 11.
14:56:45 <elliott> > ()
14:56:59 <lambdabot>   ()
14:56:59 <elliott> @undefine
14:57:00 <lambdabot> Undefined.
14:57:01 <arkeet> @let fibs'' r = 0 : 1 : (zipWith (\x y -> r (x+y)) `ap` tail $ fibs'' r)
14:57:01 <elliott> > ()
14:57:03 <lambdabot>  Defined.
14:57:04 <lambdabot>   ()
14:57:14 <arkeet> > fibs'' (`mod` 11)
14:57:18 <lambdabot>   [0,1,1,2,3,5,8,2,10,1,0,1,1,2,3,5,8,2,10,1,0,1,1,2,3,5,8,2,10,1,0,1,1,2,3,5...
14:57:38 <arkeet> > fibs'' (`mod` 13)
14:57:45 <lambdabot>   mueval-core: Time limit exceeded
14:57:49 <arkeet> > fibs'' (`mod` 13)
14:57:56 <lambdabot>   mueval-core: Time limit exceeded
14:58:00 <arkeet> > take 40 $ fibs'' (`mod` 13)
14:58:04 <lambdabot>   [0,1,1,2,3,5,8,0,8,8,3,11,1,12,0,12,12,11,10,8,5,0,5,5,10,2,12,1,0,1,1,2,3,...
14:58:15 <arkeet> monoidal: but I wonder if that "explains" the short period for mod 11.
14:58:18 <Placinta> > take 5 $ fibs''
14:58:19 <lambdabot>   Couldn't match expected type `[a0]'
14:58:19 <lambdabot>              with actual type `(c0 -> c...
14:58:19 <arkeet> or something along those lines.
14:58:34 <arkeet> > take 40 $ fibs'' id
14:58:38 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:59:03 <Placinta> > take 5 $ fibs'' (\x->x+2)
14:59:05 <ReinH> arkeet: consider factoring m in to primes
14:59:06 <lambdabot>   [0,1,3,6,11]
14:59:09 <ReinH> into
14:59:15 <arkeet> ReinH: I'm only thinking about primes.
14:59:28 <Placinta> > take 5 $ fibs'' (\x->x/0)
14:59:31 <ReinH> ok
14:59:31 <arkeet> also look. the period mod 11 is 10, which is 11-1
14:59:32 <lambdabot>   [0.0,1.0,Infinity,Infinity,Infinity]
14:59:35 <arkeet> what's the next one
14:59:42 <mm_freak> > let fibsFrom x y = x : fibsFrom y (x + y) in fibsFrom 0 1
14:59:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:59:47 <arkeet> > take 40 $ fibs'' (`mod` 19)
14:59:48 <mm_freak> still my favorite definition
14:59:50 <lambdabot>   [0,1,1,2,3,5,8,13,2,15,17,13,11,5,16,2,18,1,0,1,1,2,3,5,8,13,2,15,17,13,11,...
15:00:10 <arkeet> yeah, period 18.
15:00:20 <arkeet> so I suspect the period is p-1 when 5 is a quadratic residue mod p.
15:00:28 <arkeet> which would make sense intuitively sor tof.
15:00:45 <ReinH> arkeet: ok, new question: how many zeros can there be in the period?
15:01:08 <arkeet> I don't know!
15:01:16 <ReinH> arkeet: but can you find out? :)
15:01:50 <monoidal> arkeet: there's also http://en.wikipedia.org/wiki/Pisano_period
15:02:32 <arkeet> it's more fun to discover things for yourself.
15:02:39 <arkeet> I'm not looking. spoilers.
15:03:06 <ReinH> arkeet: I already know it. That's why I'm not spoiling it :)
15:03:18 <ReinH> I will say that the result is pretty surprising
15:03:31 <arkeet> I'll think about it later.
15:03:45 <ReinH> :)
15:06:02 <ReinH> arkeet: let's just say that I *really*, *really* hope someone asks me to write a fib function in a job interview some day ;)
15:06:11 <arkeet> lol
15:06:21 <ReinH> "Ok, you can stop now."
15:06:56 <MrRacoon> lol
15:07:26 <MrRacoon> don't we all...
15:08:49 <arkeet> oh right. if x^2 - x - 1 factors in Z/p, then A = [0,1;1,1] is diagonalizable and invertible, so A^(p-1) = 1.
15:08:52 <arkeet> done
15:09:24 <ReinH> arkeet: :D
15:09:47 <arkeet> s/in/over/
15:10:20 <arkeet> hm, could the period be smaller
15:10:42 <sm> ReinH, jekor: great job on starting the haskellcast btw
15:10:55 <ReinH> sm: <3
15:11:00 <ReinH> we are excited
15:12:00 <sm> even if you did dive in at the deep end :)
15:12:10 <ReinH> hahaha well Edward is the perfect guest imo
15:12:16 <ReinH> wicked smaht and very well spoken
15:12:18 <ReinH> and *engaging*
15:12:20 <sm> I'm listening to it a second time and getting a lot more out of it
15:12:28 <cschneid> what does $(....) do? In this example: getEchoR theText = defaultLayout $(widgetFile "echo")
15:12:34 <ReinH> sm: man I was *there* and I still learn things by relistening to it
15:12:35 <arkeet> cschneid: that's a Template Haskell splice
15:12:54 <cschneid> arkeet: ok, I figured it was somethingl ike that
15:13:08 <ReinH> sm: I'm going to add some links to some relevant papers and blog posts for people
15:13:22 <ReinH> like roconnor's multiplate paper, which is fantastic
15:13:25 <sm> ReinH: do you hosts have a back channel for coordinating questions etc ?
15:13:41 <cschneid> ReinH: I have literally 1 minute left on your haskellcast. It's awesome.
15:13:43 <ReinH> sm: well, we prepare a few things in advance but mostly we just wing it
15:13:48 <ReinH> cschneid: awesome! :D
15:14:02 <arkeet> what's a haskellcast? :o
15:14:05 <monoidal> cschneid: basically what is inside $(...) is evaluated compile-time, it is expected it will be an AST of haskell code, and that is substituted where the $(...) was
15:14:06 <ReinH> arkeet: haskellcast.com
15:14:15 <arkeet> cool, I'll check it out later.
15:14:18 <ReinH> cool
15:14:33 <cschneid> monoidal: sweet. I knew of templatehaskell, but that's fairly far down my list to understand it. :)
15:15:03 <deech> If I want to set a flag when compiling in GHC is the `ghc-options:` the place to pass it along in the Cabal file?
15:15:34 <arkeet> deech: yes
15:15:39 <deech> arkeet: thanks!
15:15:43 <dcoutts> deech: as the package author yes, if you just want to do it as a user/builder, then there are command line flags --ghc-options=
15:15:51 <arkeet> unless you can find another more specific place to put it.
15:16:23 <arkeet> like -X... flags.
15:16:36 <deech> dcoutts: Great. I'm the package author (my first) . Can basically any Cabal command line flag be used inside the file in this way?
15:23:06 <fylwind> is there a way to use the guard syntax in an expression?
15:23:21 <arkeet> fylwind: with what result?
15:23:40 <arkeet> oh, you can use MultiWayIf
15:23:43 <fylwind> I tried to use the guard in a function defined by where but ghc is rejecting it
15:23:57 <geekosaur> @where lpaste
15:23:57 <lambdabot> http://lpaste.net/new/haskell
15:24:00 <geekosaur> ^^ code
15:24:02 <arkeet> or the poor man's MultiWayIf: case _ of () | guard1 -> x | guard2 -> y | ...
15:24:13 <joelteon> the hlint-using man's MultiWayIf*
15:24:25 <joelteon> or, I forget. does hlint support that now?
15:24:29 <joelteon> I know it still hates lambda-case
15:25:10 <monoidal> joelteon:   Parse error: |
15:25:37 <joelteon> rats
15:27:42 <fylwind> thanks, i guess this works: case () of _ { | guard1 -> x; _ | guard2 -> x ... }
15:28:06 <fylwind> s/_ {/{ _/
15:29:07 <arkeet> hm
15:29:44 <haasn> every time I look at the superclass for Conjoined I die a little inside
15:30:19 <monochrom> add a Disjoined to compensate :)
15:30:59 * hackagebot http-conduit-downloader 1.0.10 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.10 (VladimirShabanov)
15:31:05 <arkeet> oh right, if 5 isn't a quadratic residue then A is still diagonalizable over a degree-2 extension of Z/p. so fibs has period p^2 - 1 in that case
15:31:21 <haasn> wait why do we have Choice and ArrowChoice on it?
15:31:25 <arkeet> well, dividing that.
15:31:35 <arkeet> > take 40 $ fibs'' (`mod` 5)
15:31:38 <lambdabot>   [0,1,1,2,3,0,3,3,1,4,0,4,4,3,2,0,2,2,4,1,0,1,1,2,3,0,3,3,1,4,0,4,4,3,2,0,2,...
15:31:52 <arkeet> er, guess not.
15:31:56 <monochrom> oops, wrong window! why am I looking for haskell in a channel that talks about quadratic residues?! :)
15:32:01 <arkeet> oh oops
15:32:04 <arkeet> ;)
15:32:31 <monochrom> horror horror memory recalls of the days I took a number theory course!
15:32:56 <monochrom> (but quadratic reciprocity is really cool!)
15:33:51 <Anon1> puu.sh/4cw1f.rar enjoy ;)
15:34:09 --- mode: ChanServ set +o monochrom
15:34:14 --- mode: monochrom set +b *!*@197.1.181.141
15:34:15 --- kick: Anon1 was kicked by monochrom (Anon1)
15:34:20 <monochrom> (enjoy!)
15:34:26 --- mode: monochrom set -o monochrom
15:41:06 <ReinH> risky click
15:41:30 <jfischoff> what are the limitations GHC has with inlining? How much cross module inlining can it do?
15:49:50 <c_wraith> Hmm.  Does lens have a low-precedence version of . ?
15:50:41 <lpaste> enthropy annotated “fundep and typefamily hzip implementations” with “fundep and typefamily hzip implementations (annotation) (annotation)” at http://lpaste.net/92221#a92225
15:51:07 <enthropy> haasn: ^^
15:51:48 <ski> arkeet : ok
15:51:51 <c_wraith> I guess if I use over instead of infix operators, the precedence of . doesn't matter so much
15:51:52 <arianvp> edwardk: are you there?
15:51:55 <arkeet> ok what?
15:52:05 <elliott> c_wraith: we generally use (&).
15:52:08 <danharaj> edwardk is not in the channel
15:52:12 <arianvp> darnit
15:52:21 <ski> "I mentioned records. patterns don't count since .."
15:52:24 <arkeet> right.
15:52:26 <Eduard_Munteanu> Do any monad transformers generalize run functions through typeclasses? I think I want something like  class MonadTransFooT f t | t -> f
15:52:46 <c_wraith> elliott: that only works if you're also providing an argument, not just composing lenses
15:53:28 <elliott> c_wraith: right. so you eta-expand. it's the edwardk way.
15:53:32 <Eduard_Munteanu> Well, in this particular case I have a nasty thing in mind. Namely have separate ThrowT and CatchT for exceptions, b-b-but... runThrowT requires a catch somewhere.
15:54:16 <enthropy> Eduard_Munteanu: you're aware of monad-control (and other packages that provide exception stuff using those classes in there)?
15:54:19 <Eduard_Munteanu> And I can't really define this in terms of ThrowT and CatchT alone.
15:54:22 <Eduard_Munteanu> Not nicely.
15:54:32 <Eduard_Munteanu> Hm.
15:54:42 <Eduard_Munteanu> enthropy: I'll have a look, thanks.
15:55:14 <Eduard_Munteanu> I'll try doing it myself first, for fun.
15:55:39 <pxqr> is there any efficient data structure like queue but with deduplication?
15:59:45 <jfischoff> Enigmagic: ping
16:00:10 <k00mi> trying to install aeson, cabal tells me aeson and unordered-containers depend on different versions of hashable. There is no contradiction between version constraints and it worked after I told cabal to build aeson with the same hashable as unordered-containers is built with. Is there a reason cabal can't do that automatically?
16:01:41 <enthropy> in your ~/.cabal/config you could have added 'constraint: hashable installed'
16:02:03 <mescalinum> I rolled my own version of fold:  let fold' neutral op list = if list == [] then neutral else (op) (head list) (fold' neutral op (tail list))    why I have to pass the operand (e.g. +) in parentheses like (+), if I already wrap it in (..) in the body of fold'?
16:02:48 <geekosaur> mescalinum, the one in your definition is useless, and the other is syntactic and required for operators
16:03:02 <geekosaur> (when used as functions, as opposed to as operators)
16:03:03 <monochrom> "list == []" is very bad
16:03:23 <monochrom> also, read my http://www.vex.net/~trebla/haskell/crossroad.xhtml
16:03:34 <ReinH> geekosaur: when used as values, you might say?
16:03:50 <geekosaur> you might, but that's questionably accurate
16:04:12 <mescalinum> sorry, I am a total beginner of haskell
16:04:21 <k00mi> enthropy: I did basically that on command line, but I wonder why cabal fails instead of using the installed version, since it seems a simple enough thing to figure out
16:04:49 <ReinH> geekosaur: ah, I see what you mean
16:06:02 <geekosaur> > (+) 2 3
16:06:03 <lambdabot>   5
16:06:11 <geekosaur> > 2 + 3
16:06:13 <lambdabot>   5
16:06:23 <geekosaur> mescalinum: notice the difference here? ^^
16:08:41 <ion> and/or the lack of one
16:10:20 <enthropy> k00mi: there are lots of ways to pick packages that will satisfy the dependencies listed in the cabal file. If it was an easy problem probably cabal would do better
16:10:38 <dcoutts> it's an NP-complete problem :-)
16:10:49 <ski> mescalinum : `a + 2 * b' is an expression, but `+' is not an expression. you can only place a complete expression as an argument to be passed to a function
16:10:59 <edwardk> carter: you may start hating me soon
16:11:07 <enthropy> either that, or the Cabal devs are reluctant to add more and more packages to that hardcoded list of packages that can't have newer versions installed
16:11:18 <mescalinum> ski: yup =) I was figuring out that right now
16:11:36 <ski> mescalinum : that you happened to write `(op)' in the body of your function is irrelevant, this is just (superfluous, in this case) wrapping an expression in brackets, yielding a new expression (that expresses the same thing)
16:11:43 <dcoutts> k00mi: if you think it's not finding a valid solution then you can use --max-backjumps=-1
16:12:06 <dcoutts> enthropy: it only has base hardcoded, since that one really cannot be upgraded
16:12:17 <ski> mescalinum : when you write `(+)', this is how you turn an infix operator into an ordinary expression, so that you can place it anywhere an expression is expected
16:12:22 <refold> how can /quit
16:12:25 <edwardk> dcoutts: in general it is np complete and all that, but I wonder if there could be some low hanging fruit. For example, anything other than 'template-haskell installed' is basically a huge red-flag
16:12:38 <dcoutts> there's the more general issue of packages that you probably don't want to upgrade
16:12:51 <dcoutts> but that needs a better solution than a hard-coded list
16:12:51 <edwardk> is it possible to say that constraint constraints supplied by hackage?
16:12:57 <edwardk> similarly base installed, etc.
16:13:15 <dcoutts> is it really true that template-haskell is not upgradable?
16:13:16 <edwardk> er in the version constraints
16:13:24 <edwardk> dcoutts: yes, i've literally never seen it work
16:13:41 <edwardk> it installs and then just silently fails for about half the operations
16:13:43 <danharaj> dph isn't upgradable either is it?
16:14:03 <dcoutts> edwardk: then hard-coding that one is plausible
16:14:15 <edwardk> dcoutts: ghc-prim is similar
16:14:17 <haasn> enthropy: hmm, I'm stumped (with my approach and yours)
16:14:20 <dcoutts> I think we didn't do it originally as it was theoretically upgradable
16:14:40 <dcoutts> and it means you could never install it with cabal if it were not installed already
16:14:46 <edwardk> they break it pretty consistently
16:15:22 <dcoutts> ghc-prim isn't on hackage anyway
16:15:26 <edwardk> sure
16:15:40 <edwardk> base might be a similar situation
16:15:50 <edwardk> ghc-prim was just me thinking out loud
16:17:14 <edwardk> template haskell getting silently upgraded and breaking user installs is the majority of the bug reports we get for both lens and our not-on-hackage ermine compiler actually ;)
16:17:36 <ReinH> scumbag template haskell
16:17:52 <enthropy> maybe the problem is the person who uploaded template-haskell to hackage
16:18:02 <dcoutts> edwardk: well, should be straightforward to fix
16:18:03 <enthropy> or rather the choice to put it up there
16:18:22 <dcoutts> edwardk: perhaps we can fix it at ZuriHac
16:18:28 <dcoutts> before the 1.18 release
16:18:34 <edwardk> dcoutts: just figured i'd mention it while others were talking about similar issues.
16:18:40 <edwardk> dcoutts: much obliged
16:18:42 <dcoutts> sure, thanks
16:18:55 <dmwit> enthropy: That looks like pretty much what I would do.
16:18:56 <dcoutts> edwardk: should make sure there's a ticket for it so we don't forget
16:20:05 <enthropy> dmwit, the one with 3 parameters and 3 associated types?
16:20:29 <enthropy> maybe there's some algebra to say that's the minimum translation of      class C a b c | a b -> c, c -> a b
16:20:32 <dmwit> Well. Actually, couldn't you get away with just one parameter?
16:20:49 <dmwit> Just the list of pairs, to be specific.
16:20:59 <enthropy> maybe
16:21:05 * hackagebot HaskellNet-SSL 0.1.1.0 - Helpers to connect to SSL/TLS mail servers with HaskellNet  http://hackage.haskell.org/package/HaskellNet-SSL-0.1.1.0 (DanielWright)
16:21:31 <dmwit> Anyway, both versions look fine to me as-is.
16:21:42 <dmwit> ...and essentially equivalent in terms of user interface.
16:22:09 <edwardk> dcoutts: https://github.com/haskell/cabal/issues/1444 done
16:22:13 <dcoutts> ta!
16:26:23 <enthropy> dmwit the class for unzip works with 1 parameter. It's much cleaner than before that way.
16:26:42 <dmwit> That's good.
16:40:40 <tabemann> random question
16:41:07 <geekosaur> incomprehensible answer
16:41:18 <tabemann> why would a program, compiled with -prof and run with +RTS -h, after the Foo.hp is fed into hp2ps, in the resulting Foo.ps file say that 0 bytes were allocated?
16:42:12 <c_wraith> if all the allocation was done by native code, the rts wouldn't see it...
16:42:57 <c_wraith> or...  uh..  is -h really the flag you want?  I'm used to specifying more information
16:43:36 <tabemann> oh I see, the program didn't run long enough
16:44:04 <tabemann> because I'd originally set it only do 2 tests (one for equals, one for not-equals), and now I set it to do 200 tests (100 for equals, 100 for not-equals)
16:44:37 <begriffs> Can anyone give me an example of using ZipList with <$>? I see examples that put them together with <*> but not sure if there's any way you can do something interesting to a ziplist with <$>.
16:44:53 <elliott> it's just map.
16:45:00 <c_wraith> Oh, is heap profiling done by sampling?
16:45:04 <c_wraith> That'd totally explain it
16:45:12 <c_wraith> If it terminates before it can be sampled...
16:45:32 <tabemann> now the question...
16:45:42 <tabemann> how do I make hp2ps make colorful output?
16:45:48 <haasn> begriffs: (<$>) is by definition equal to ‘fmap’ and there can only be one valid Functor implementation of any type, and since ZipList [a] is isomorphic to [a] it must be equal to [a]'s fmap
16:45:54 <begriffs> elliott: I'm surprised that this fails: (5+) <$> ZipList [1,2]
16:45:57 <tabemann> oh I see
16:46:00 <tabemann> forget that question
16:46:09 <haasn> > getZipList $ (5+) <$> ZipList [1,2]
16:46:10 <lambdabot>   [6,7]
16:46:11 <haasn> works
16:46:24 <haasn> note: ZipList a has no Show instance
16:46:28 <begriffs> Oh, it just didn't know how to show it to me…got it
16:46:42 <c_wraith> tabemann: I really have no idea why color isn't the default.
16:47:07 <tabemann> yeah... trying to tell each thing apart with grayscale is... hard
16:47:07 <begriffs> haasn: interestingly the ghci error didn't mention anything about Show, it was complaining about type ambiguity.
16:47:39 <haasn> begriffs: odd, when I run that expression I get the No instance for (Show (ZipList b0))
16:48:09 <begriffs> haasn: for me, No instance for (Num b0) arising from a use of `+'
16:49:05 <haasn> ah, seems to be related to some of the things I have in my .ghci
16:49:13 <haasn> if I run it in a blank GHCi I get that *and* the Show error
16:49:31 <begriffs> haasn: oh, I get the show error when I start ghci with -XNoMonomorphismRestriction
16:49:34 <haasn> begriffs: oh, yes
16:49:39 <haasn> I have that in .ghci :)
16:50:06 <begriffs> What the hell is that option? Is it a good idea to remove the restriction? Do I get into dangerous territory somehow?
16:50:17 <haasn> begriffs: http://www.haskell.org/haskellwiki/Monomorphism_restriction
16:50:25 <tabemann> there are performance implications to getting rid of the monomorphism restriction
16:50:41 <tabemann> particularly that there are use cases in which expressions can be evaluated multiple times, unintuitively
16:51:09 <c_wraith> if you put signatures on all your top-level bindings, the monomorphism restriction doesn't do anything at all.
16:51:10 <haasn> (but only if you don't actually add the polymorphic signature yourself)
16:51:22 <haasn> c_wraith: yeah, but who does that in GHCi?
16:51:44 <tabemann> c_wraith: that makes me wonder why they even have it
16:53:20 <tabemann> my thing against the monomorphism restriction is that, as a former MLer, I'm used to basically programming without type signatures, aside from interface files
16:54:24 <tabemann> but then type signatures do tend to contain typing issues when they are present, whereas I remember dealing with at-a-distance typing problems in OCaml specifically due to not using type signatures within modules
16:54:24 <begriffs> So the simplified consensus for my beginner self is that I should add the flag to remove the restriction in my .ghci file and if weird things ever happen, remember to try removing it.
16:55:29 <tabemann> random question - does Array actually use STArray internally?
16:55:38 <c_wraith> tabemann: why would it?
16:55:50 <tabemann> because my profiling output is absolutely *full* of STArray
16:55:56 <c_wraith> Oh, I guess it does
16:55:58 <tabemann> even though I'm not using it directly in the code I'm profiling
16:56:14 <tabemann> (I'm using *IOArray* a lot)
16:56:17 <tabemann> wait
16:56:17 <c_wraith> Whenever you do an array update, it probably creates an STArray to do the copying and modification in, then freezes it.
16:56:20 <tabemann> that's it
16:56:32 <tabemann> internally IOArray and STArray are the same thing
16:56:40 <c_wraith> Oh, right.
16:56:43 <tabemann> and the profiler doesn't know enough to tell the difference
16:57:56 <tabemann> I just got an idea for a question
16:58:23 <tolt> So, stupid question time. If I wanted to make an application that had a list of global clients that I wanted to modify, how could I do this? Is there a mutable list type or something similar?
16:58:51 <tabemann> are newArray_, and writeArray with IOArrays lazy w.r.t. the IOArray itself, i.e. do they actually apply until you call readArray?
16:59:23 <Rembane> tolt: Send the list as an argument when you do recursion and modify the list right before the function call
16:59:32 <tabemann> because there's a damned lot of "STArray" in my profiler output, and its allocation pattern does not seem to match the pattern in which I *think*  they are being used
16:59:41 <arianvp> SSorry it's late and not so sober:  What's the difference between these two patterns?   e@Lam{}    and e@Lam _
17:00:01 <c_wraith> tabemann: they create the array structure as part of the IO action.  However, values in the array aren't forced.
17:00:20 <tabemann> c_wraith: what I mean is the IOArray itself strict or lazy in its creation and setting
17:00:38 <c_wraith> arianvp: the only difference is the former doesn't need to be updated if the Lam constructor ever has a different number of arguments.
17:00:55 <arianvp> ahh I see
17:01:05 <arianvp> That Bound library you guys pointed out is really neat
17:01:12 <geekosaur> well, that's assuming correct aprentheses
17:01:16 <arianvp> been experimenting with it and has been fun. No idea how I'm gonna use it though
17:01:22 <c_wraith> geekosaur: true.
17:01:54 <tabemann> i.e. when you call newArray_, does it actually literally allocate an array then, or does it only return IO <thunk> where <thunk> will only be evaluated (i.e. allocated) when forced later
17:02:03 <ippo> can somebody help me one second with a noob question? I don't understand the last line of the parse function in the command line tutorial: http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell/Argument_handling
17:02:18 <c_wraith> tabemann: more or less, all IO happens immediately, unless unsafeInterleaveIO was used.
17:02:34 <c_wraith> tabemann: and no array stuff uses unsafeInterleaveIO
17:02:44 <c_wraith> tabemann: in fact, only a few things do
17:03:19 <arianvp> ippo: are you referring to  parse ["-v"]
17:03:20 <arianvp> ??
17:03:23 <c_wraith> tabemann: unfortunately, they tend to be things like interact and getContents, that are the first IO things demonstrated to new haskell programmers.
17:03:36 <elliott> c_wraith: you can still do return (expensive computation) though
17:03:42 <geekosaur> last line. the one with the fmap
17:03:52 <tabemann> part of me wonders why they even have unsafeInterleaveIO, as the likes of the list produced by hGetContents has been shown to be very not RT IRL
17:03:57 <ippo> arianvp: no, to "parse fs = ..."
17:04:05 <elliott> it depends on your definition of RT.
17:04:11 <c_wraith> elliott: yes, that's why I was careful to say "all IO", rather than "all computation".  I didn't get around to spelling out *why* I said that, though..
17:04:14 <ippo> parse fs     = concat `fmap` mapM readFile fs
17:04:50 <elliott> c_wraith: well, fair enough :) I just mean you can get a <thunk> in IO even without any interleaving
17:04:53 <arianvp> mapM just chains together IO actions and keeps the result
17:05:00 <tabemann> elliott: i.e. that the list in question can differ arbitrarily based upon other operations, without being within the IO monad
17:05:05 <arianvp> it's basically    "readFile for every f in fs"
17:05:28 <c_wraith> tabemann: unsafeInterleaveST is *far* worse.
17:05:29 <c_wraith> :)
17:05:30 <tabemann> e.g. what if someone hCloses the handle one called hGetContents on
17:06:07 <tabemann> c_wraith: umm can the resulting thunk escape runST?
17:06:19 <ippo> arianvp: mmm ok, so basically mapM maps readFile on every filepath, and I get a list of contents. Now I use (fmap concat) on this list, thus just concatenating the contents returned before, is that right?
17:06:58 <tabemann> unsafeInterleaveST really sounds like unsafePerformIO . unsafeInterleaveIO
17:06:58 <arianvp> not really
17:07:01 <lpaste> c_wraith pasted “unsafeInterleaveST fun” at http://lpaste.net/92226
17:07:04 <ippo> dang
17:07:05 <c_wraith> tabemann: ^
17:07:09 <arianvp> ippo:  mapM returns  m [b] , not [b]
17:07:25 <arianvp> so we got an IO [b]    but we want to concat all our b's
17:07:34 <arianvp> as IO is a functor
17:08:02 <quchen> ippo: Does this help? http://lpaste.net/5256776431110717440
17:08:08 <arianvp> we use mapM  to apply   our concat on the list
17:08:11 <arianvp> if that makes sense
17:08:17 <arianvp> (sorry, bit not-sober)
17:08:40 <tabemann> c_wraith: I'm ... trying to wrap my brain around that code
17:09:04 <k00mi> dcoutts, enthropy: sorry, I was distracted. I realize finding dependencies is NP-complete in general, but in the case I explained, cabal knows what it's trying to do likely won't work and the solution (the only viable one) is basically lying at its feet. Maybe this is another low-hanging fruit?
17:09:32 <haasn> isn't there some whenM :: Monad m => m Bool -> m () -> m ()
17:09:39 <haasn> in an accessible place? (not some obscure package like shelly)
17:09:53 <ippo> arianvp: yes, thank you, it does help. I'm still trying to grasp this monad concept, and failing spectacularly
17:10:00 <quchen> haasn: I think there was some mailing list discussion about this recently, maybe that's where you've heard about it?
17:10:03 <arianvp> Well. just forget monads for now
17:10:12 <arianvp> Just think of them as IO actions
17:10:14 <haasn> quchen: I found myself defining this function twice within the past few days
17:10:40 <ippo> what I'm trying to do basically is: I have a function that processes a file (String -> String), I have a list of files, I want to process all the files and concatenate the results, but I don't really know what I'm missing
17:10:41 <c_wraith> tabemann: it's about as far from referentially transparent as possible without sneaking in actual IO
17:10:47 <dcoutts> k00mi: it's hard to say without the full specifics of the situation, it's possible it would find it if it tried harder, you can check with --max-backjumps=-1
17:11:04 <k00mi> dcoutts: tried that, same error
17:11:04 <quchen> haasn: Is it "whenM p foo = p >>= \p' -> if p' then foo else return ()"?
17:11:17 <ippo> arianvp: I'm trying "fmap fun (mapM readFile fs)"
17:11:20 <dcoutts> k00mi: you mean it says it finds no solution?
17:11:26 <enthropy> @where om
17:11:27 <lambdabot> I know nothing about om.
17:11:34 <dcoutts> k00mi: yet when you pass it the extra constraint it finds the solution?
17:11:38 <geekosaur> ippo: fun is receiving a list of String-s, not a String
17:11:39 <quchen> OH NO not this "om" function again
17:12:02 <haasn> quchen: yes; or whenM x y = x >>= (when ?? y)
17:12:08 <dcoutts> k00mi: could I get a log of both? with -v
17:12:09 <edwardk> nom
17:12:17 <haasn> edwardk: fix that fixity!
17:12:22 <quchen> haasn: Not sure whether whenM should introduce a Lens dependency :-P
17:12:25 <haasn> :)
17:12:30 <tabemann> c_wraith: oh I see now
17:12:38 <k00mi> dcoutts: both as with and without extra constraint?
17:12:45 <tabemann> the value of i changes depending on how many values one has evaluated in the list ls
17:12:47 <ippo> geekosaur: oh, you are right. So I have to map fun to every list... which is ""fmap (map fun) (mapM readFile fs)" =
17:12:49 <ippo> ?
17:12:52 <applicative> fmap fun (readFile fs) applies the String->String to the filecontents ippo
17:12:58 <c_wraith> tabemann: yep
17:13:07 <dcoutts> k00mi: please
17:13:10 <edwardk> haasn: make an issue to propose changing the fixity with usecases, it'll give folks a place to debate it
17:13:18 <arianvp> ippo:  you're looking for this :  fmap concat (mapM (readFile >>= (\data -> return (fun data)))
17:13:24 <edwardk> haasn: i'd rather not thrash on the topic, so if i change it i want it to be a well talked about decision
17:13:26 <arianvp> I think..
17:13:28 <c_wraith> tabemann: and there's no *hint* that anything that scary is going on in the types - at least unsafeInterleaveIO leaves IO in the type.
17:13:37 <geekosaur> arianvp, that's a bad way to do it
17:13:50 <tabemann> c_wraith: and no unsafePerformIO either!
17:14:01 <jfischoff> what's the package called that makes a dotviz graph of a packages module dependencies?
17:14:02 <tabemann> but yeah
17:14:04 <arianvp> fmap concat (mapM (readFile >>= return . fun)) ?
17:14:07 <c_wraith> tabemann: you could argue runST *is* unsafePerformIO.  >_>
17:14:09 <elliott> unsafeInterleaveST lets you write unsafeCoerce I think?
17:14:12 <elliott> maybe not
17:14:12 <applicative> ippo: you realize this could be trouble with lots of files or long files and so on, depending what fun is
17:14:23 <k00mi> @where hpaste
17:14:23 <lambdabot> http://lpaste.net/new/haskell
17:14:28 <geekosaur> (x >>= return . f)  is a bad way to write (fmap f x)
17:14:33 <tabemann> c_wraith: just with type magic to make it all safe and well-contained, at least without the likes of unsafeInterleaveST
17:14:48 <ippo> applicative: nothing really big or long, also it's just for personal research and not for real use
17:14:49 <arianvp> edwardk: There's a little mistake on your bound tutorial https://www.fpcomplete.com/user/edwardk/bound
17:14:51 <c_wraith> elliott: I don't think it's that bad. Just bad enough to break referential transparency, not bad enough to break the type system.
17:14:56 <tabemann> elliott: unsafeCoerce lets you like unsafePerformIO
17:14:56 <applicative> let funFile file = fmap fun (readFile file) seems a good start at elimination confusion ippp
17:15:00 <edwardk> arianvp: which one?
17:15:08 <applicative> ippo rather
17:15:09 <arianvp> edwardk:   You define data constructors  Bound and Free, but refer to them as B and F in the rest of the code
17:15:13 <ippo> (I'm counting the frequency of the letters in some text files, basically)
17:15:29 <elliott> c_wraith: fair
17:15:33 <ski> tabemann : i think of `unsafeInterleaveIO' as similar to concurrency. `unsafeInterleaveST' is very different
17:15:39 <tabemann> (unsafeCoerce (putStr "evil") :: () -> ()) ()
17:15:42 <edwardk> arianvp: likely. thats what i get for mashing things around from different slides
17:15:56 <ippo> applicative: I'm going to try your suggestion and see what I come up with. Thanks everyone for the help, I really suck at this
17:16:01 <dcoutts> ski: they're kind of similar, but in IO non-determinism is ok, where as in ST it's really not ok
17:16:11 <elliott> does anyone even use unsafeInterleaveST?
17:16:13 <applicative> ippo: no, this is seeming perfectly normal
17:16:14 <elliott> it should just be removed.
17:16:24 <dcoutts> elliott: sure
17:16:27 <edwardk> arianvp: i may just add a comment above the abstract/instantiate code saying I'm switching to preserve the puns
17:16:35 <edwardk> letmeB this (F you) | you == me = B this
17:16:35 <edwardk>                       | otherwise = F you
17:16:37 <c_wraith> there's a valid case for unsafeInterleaveST, which is producing infinite streams incrementally
17:16:39 <elliott> dcoutts: sure they use it or sure it should be removed?
17:16:40 <edwardk> that doesn't work with Bound and Free ;)
17:16:42 <ski> dcoutts : yes. i was a bit unclear. the difference i was aluding to was that the indeterminacy of the latter can't be explained away
17:16:49 <dcoutts> elliott: though most uses can be changed to using mixed strict & lazy ST monads
17:16:56 <arianvp> edwardk: I was like. he is flipping me off again! First in the podcast, now this F you too!
17:17:13 <edwardk> arianvp: that's conor's code, it has his peculiar sense of humor
17:17:29 <tabemann> hah
17:17:31 <elliott> Conor has a wonderful way of structuring code so that the puns fall out naturally.
17:17:33 <arianvp> edwardk: Trying to wrap my head around that library to get my lisp interpreter off the ground. great fun really
17:17:46 <tabemann> (unsafeCoerce (putStr "evil") :: () -> ()) () makes GHCi print "evil" and then segfault
17:18:01 <applicative> haha
17:18:07 <dcoutts> :-)
17:18:11 <ski> elliott : iiuc it's ok to use `unsafeInterleaveST' when the action you pass doesn't refer to any piece of state accessed by the rest of the state thread, and vice versa
17:18:42 <tabemann> the big problem with unsafeInterleaveST is that you can have more than one independent thunk generated with it escape from runST
17:18:54 <tabemann> if you used it to just generate, say, a lazy list you'd be fine
17:18:58 <c_wraith> err, do you mean interdependent, there?
17:19:07 <lpaste> k00mi pasted “No title” at http://lpaste.net/92227
17:19:11 <k00mi> dcoutts: ^
17:19:17 <tabemann> c_wraith: I meant as in there is no given order in which they must be evaluated
17:19:18 <dcoutts> I use the moral equivalent of  unsafeInterleaveST in the zlib package
17:19:23 <c_wraith> tabemann: ah, I see
17:19:40 <ski> elliott : e.g. you might want to generate a tree such that the generatation of one part is independent of the generation of another part, and you don't want to oversequentialize
17:19:42 <edwardk> arianvp: there. i've updated it to make it clear i switched from Bound to B and Free to F deliberately
17:19:46 <haasn> edwardk: right, I'll do so later
17:19:51 <tabemann> whereas if you make a lazy list with successive nested unsafeInterleaveSTs, there is an order in which the cons cells must be forced
17:20:10 <dcoutts> k00mi: ohh, sorry, so it actually does find a solution fine, it's just that it then fails to compile
17:20:37 <c_wraith> tabemann: Still, the problem also requires that the unprocessed thunks refer to the same mutable cells, and that at least one of them mutate it.
17:20:44 <dcoutts> kooga: so the problem isn't not finding a solution, it's that the constraints in the .cabal files are wrong
17:21:00 <dcoutts> erm sorry, kooga, k00mi
17:21:02 <c_wraith> tabemann: so they do need to be interdependent in that sense.
17:21:12 <ski> tabemann : as long as the state accessed by the thunks generated by `unsfaeInterleaveIO' are independent of each other and the "main state thread", you should be ok
17:21:17 <arianvp> edwardk: neat
17:21:30 <arianvp> I'm off for some well deserved sleep, guys. later!
17:21:40 <edwardk> arianvp: thanks for the feedback =)
17:21:42 <dcoutts> k00mi: there's not a whole lot cabal can do when the data it has to work with is wrong
17:21:53 <tabemann> c_wraiski: well yes
17:21:55 <tabemann> whoops
17:21:57 <tabemann> *ski:
17:22:03 <k00mi> dcoutts: you mean it should usually solve this fine but i messed something up in .cabal somewhere?
17:22:14 <dcoutts> k00mi: we already have some heuristics, but it's not clear we can do a lot better in general
17:22:16 <arianvp> `otherwise = F you` ... gets me every time
17:22:54 <dcoutts> k00mi: I'm using "solve" here in a particular technical sense. I mean that the dependency solver finds an install plan. It's what you see with --dry-run
17:23:45 <dcoutts> k00mi: if that install plan then fails when it's tried, that's almost always a problem with the constraints in some .cabal file being too lax. A package is claiming to work with some version of something when in reality it does not.
17:23:55 <ski> tabemann : so `unsafeInterleaveST' is in roughly the same ballpark as `unsafePerformIO', while `unsafeInterleaveIO' is more benign (though not necessarily that predictable, just like concurrency sheduling isn't predictable)
17:24:04 <dcoutts> k00mi: by adding the constraint, you're changing the plan that it finds to one that does work
17:24:55 <ski> (iow, `forkIO',`newMVar',`takeMVar',`putMVar',&c.)
17:24:56 <tabemann> ski: the difference between the two is that unsafeInterleaveIO requires unsafePerformIO to do what you can do with unsafeInterleaveST
17:25:32 <tabemann> but one can still do horribly non-RT things with the former as well, as only the unsafeInterleaveIO itself must be in the IO monad
17:25:32 <dcoutts> k00mi: ohhh, wait a mo...
17:25:34 <ski> tabemann : i think of all of them as primitives
17:25:47 <k00mi> dcoutts: it seems to me that it tries to build aeson against hashable-1.2.0.10, while unordered-containers is built against a different version
17:26:11 <ski> tabemann : i don't think you can break equational reasoning with `unsafeInterleaveIO'
17:26:28 <ski> (while you definitely can do so with `unsafePerformIO' and `unsafeInterleaveST')
17:26:29 <k00mi> atleast it warns about that
17:26:30 <applicative> sexy new design on lpaste, apart from the excessively noisy hlint lintings
17:26:56 <monochrom> hehe
17:27:06 <dcoutts> k00mi: no, actually the problem is that the install plan it is executing is different to the one it created, because when cabal executes it, it only identifies packages by their source id not installed id, and you've got duplicate installed instances of something
17:27:31 <dcoutts> k00mi: check your "ghc-pkg list", you've got a duplicate of something
17:27:48 <tabemann> ski: you can still with unsafeInterleaveIO do things like, say, create a list of functions, where each function takes a value and returns a value, and where evaluating the function before the next function in the list is forced will set the value which the next function will return
17:28:26 <k00mi> hm, how can i grep for that
17:28:49 <dcoutts> k00mi: here's the bug...  cabal looks at package ids, that's the full id with the big hash in it, but when it calls Setup.hs to tell it to build, it just uses the short id, without the hash (historical limitation). This means the Setup.hs can sometimes pick wrong instances of packages. That's bad obviously because it means we're not executing the right install plan.
17:29:04 <dcoutts> k00mi: it's a duplicate between your user and global dbs
17:29:28 <dcoutts> k00mi: I'd guess it's unordered-containers that might be a dup
17:29:40 <ski> tabemann : hm. perhaps there is an objective difference here. interesting
17:30:00 <k00mi> dcoutts: yep, you're right
17:30:05 <dcoutts> k00mi: see the warning on line 30.
17:30:21 <tabemann> i.e. you can make code that is sensitive to evaluation order, and which includes functions with side effects, with unsafeInterleaveIO
17:30:52 <c_wraith> well, you can do anything with unsafeInterleaveIO that you can do with unsafeInterleaveST
17:31:12 <tabemann> the only difference is that you can't run unsafeInterleaveIO itself in pure code
17:31:16 <c_wraith> yep
17:31:46 <tabemann> okay, gonna go eat, so will be back later
17:31:48 <ski> tabemann : i don't think merely "sensitive to evaluation order" cuts it, since you could (presumably ?) explain away this in terms of general indeterminacy of `IO'
17:32:12 <dcoutts> k00mi: so unregister one and then it should work. Sorry gotta disappear now
17:32:17 <ski> of course, one major problem here is not having a model of what `IO' may do
17:32:27 <k00mi> dcoutts: alright, thanks!
17:32:29 <tabemann> ski: well yes; it's just that you can make things with unsafeInterleaveIO that are not nearly as well-behaved as hGetContents
17:32:49 <ski> (though there's possibly some things we can say for sure it can't do)
17:32:58 <tabemann> but now, dinner
17:33:21 <haasn> edwardk: do we have lens operators for working with STArray and stuff?
17:33:29 <haasn> I want to write some very imperative-looking code :)
17:34:33 <ski> tabemann|eating : anyway, the possibly line of comparision would be whether one could simulate the behaviour (or a super-behaviour, say) of `unsafeInterleaveIO' by a concurrency (with state) model -- perhaps this wouldn't say all, but it would still be interesting
17:34:55 <ski> tabemann|eating : i'm also wondering if the picture would change if we add futures into it
17:35:36 <Apocalisp> What's an example of an expensive monoid?
17:36:15 <kittymorphism> somebody please tell me about the state monad in 4 words or less
17:36:23 <haasn> type Money = Sum Integer
17:36:27 <zomg> kittymorphism: state monad is cool
17:36:39 <edwardk> haasn: nope
17:36:44 <haasn> kittymorphism: State s a ~ s -> (a, s) -- how many words?
17:36:45 <ski> (as in `newFuture :: IO (Future a)',`readFuture :: Future a -> a',`setFuture :: Future a -> a -> IO Bool', where `readFuture' blocks until the future has been set (and `setFuture' will yield `False' if it's already set, say))
17:36:50 <Apocalisp> kittymorphism: get, set, bind, return
17:37:31 <ski> kittymorphism : threading state through computations
17:37:32 <edwardk> Apocalisp: i have one for computing composites of charts in a chart parser that has to glue two square matrices together on a common row/column, then compute a transitive closure using a modified form of valiant's algorithm
17:37:46 <edwardk> Apocalisp: thats pretty darn expensive =)
17:37:48 <Apocalisp> hahaha
17:37:50 <Apocalisp> Yeah.
17:38:17 <kittymorphism> thanks, ski wins
17:38:44 <Apocalisp> I'll begin the example: "Suppose we want to glue two square matrices together on a common row/column, then compute a transitive closure using a modified form of valiant's algorithm..."
17:39:08 <TimUK> hey all!
17:39:24 <TimUK> quick question about trying to get this syntax right, i can't figure it out
17:39:32 <TimUK> this works fine map read ["2.2", "2.2"]::[Float]
17:39:41 <TimUK> but if I have a list in a list
17:39:49 <TimUK> what should the synax be i tried everything
17:39:56 <edwardk> You start with matrices A and B  such that A and B are strictly upper triangular, then you overlap the last column of A with the first column of B, and the last row of A., then the point they overlap winds up being a 0, and you can then compute the product, that product takes worst case time (n - 1) * (m - 1) to start  for n*n A, m*m B, then we have to do the transitive closure which is another logarithmic pass
17:40:06 <TimUK> map read [["2.2", "2.2"]]::[Float]
17:40:25 <edwardk> so the matrix is something like n^2 log n in theory, but log^2 n or log^3 n in practice due to sparsity
17:40:41 <edwardk> er so the monoid mappend
17:41:30 <edwardk> Apocalisp: another one is tabulating all transitions of a regular expression
17:41:47 <Apocalisp> I suppose ++ is expensive enough for my purposes
17:41:54 <edwardk> e.g. if you have a DFA, you can say 'given this character it takes me from these states to these other states'
17:41:59 <Apocalisp> for very long lists, it's quite slow
17:42:00 <edwardk> and thn you can compose those mappings
17:42:23 <edwardk> bah
17:42:26 <Apocalisp> :)
17:43:20 <applicative> >  map read [["2.2,2.2"]]::[Float]
17:43:21 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:43:21 <lambdabot>              with actual type...
17:43:55 <kittymorphism> > fmap read $ head [["2.2","2.2"]]::[Float]
17:43:56 <lambdabot>   [2.2,2.2]
17:44:00 <applicative> >  map read ["[2.2,2.2]"]::[[Float]]
17:44:01 <lambdabot>   [[2.2,2.2]]
17:47:27 <applicative> > concatMap (map read) [["2.2","2.2"], ["2.3"]] :: [Float] -- maybe sort of like this, TimUK
17:47:28 <lambdabot>   [2.2,2.2,2.3]
17:48:35 <ippo> VICTORY!!! "(fmap (concatMap fun) (mapM readFile fs))", tested and verified it's correct :)
17:48:59 <ippo> thank you arianvk, applicative, and everyone
17:49:33 <applicative> concatMap fun <$> mapM readFile fs
17:49:58 <TimUK> thanks for the tips
17:50:11 <ippo> applicative: yeah definitely neater like that
17:51:17 <ippo> and now I can go to bed happy (3 am here). Thank you again for the help, goodbye!
18:15:46 * tabemann wonders if there is any "stable" way to derive unsafePerformIO with unsafeCoerce, as opposed to the unstable (unsafeCoerce foo :: () -> ()) () method
18:16:54 <ski> i'd expect not
18:17:36 <c_wraith> I bet you can do better using other IO internals.
18:18:02 <c_wraith> But if you're using all the IO internals *except* unsafePerformIO, I'm not sure what you've proven.
18:19:42 <c_wraith> I mean, inlinePerformIO proves you don't even need unsafeCoerce if you have access to the IO internals - though it doesn't handle all IO actions.
18:20:41 <tabemann> well inlinePerformIO *is* unsafePerformIO, except with different inlining
18:21:08 <tabemann> hmm
18:21:14 <marai> noob question: I have a text file like so: "January\n1 Thursday\n2 Friday\n ... August\n1 Saturday\n2 Sunday ...". I've read the IO chapter on LYAH but the examples in there do something with each line of the input like map toUpper etc.
18:21:15 <c_wraith> That wasn't true, at least the last time I read the docs on it.
18:21:24 <tabemann> is there anything that is isomorphic to State# RealWorld?
18:21:26 <c_wraith> inlinePerformIO had warnings not to allocate from within it
18:21:35 <tabemann> yeah
18:21:52 <marai> Im having trouble writing a function that will print the line corresponding to for example todays date.
18:22:28 <marai> So my question isn't about dates per say, but how do I print the line "28 Monday" only after I match the line "August" for todays month.
18:23:04 <c_wraith> marai: Divide it up into different pieces.  Read the whole file into a list.  Figure out how to do all of your logic without involving IO, and put that in a function.  print the result of that function applied to the list you read
18:25:13 <marai> c_wraith: that makes sense. now if I were to do that, I would do something like: allMyLines. dropWhile (/= "August") -- ignore all lines upto the current month
18:25:26 <marai> and then dropWhile (/= todaysDate).
18:25:41 <marai> is that a good way to do this when I have a huge file?
18:26:08 <c_wraith> marai: depends on the definition of "huge".  If it's terabytes? No. If it's 50 megabytes?  whatever.
18:28:33 <marai> c_wraith: cool thanks! I was having a hard time trying to unthink my iterative ways. if line == currentMonth, continue reading each line, if line == currentDate then do something with it.
18:29:05 <c_wraith> marai: As a first pass, do the simplest thing, even if it seem inefficient.  If it turns out to be too slow, come back and ask us how to speed it up. :)
18:29:07 <ski> nothing wrong with iteration, it's just a special case of recursion
18:29:14 <c_wraith> *seems
18:30:40 <applicative> it looks like it should be dropWhile (not . isPrefixOf (show todaysDate))
18:32:34 <marai> applicative: nice.
18:32:55 <applicative> marai: if the Months are a showable type, getDays'Line month date file = head $ dropWhile (not . isPrefixOf (show date)) $  dropWhile (/= show month) file
18:33:09 <applicative> to which there are a number of objections of course
18:34:41 <applicative> marai: have you seen the split package, which comes with the platform http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html it has a pile of nice functions for this kind of parsing-by-list-manipulation
18:47:36 <marai> applicative: I have briefly seen split before when I was trying to split a string. But my question today was more about wrapping my head around how to handle line by line IO in Haskell, i.e. how to transform this ruby code into haskell: if line == currentYear; then line = file.getLine; if line == currentDate; puts "Got it"; return; end; end
18:48:05 <marai> well actually that's bad psuedo ruby code.
18:49:03 <applicative> yes, I see.
18:49:43 <applicative> you could write something like this in Haskell with a mind-numbing use of hGetLine
18:50:54 <applicative> monthLoop h = do line <- hGetLine; if (line == "August") dateLoop else monthLoop; ...
18:51:18 <marai> :-) yep that's how I did in my first attempt. it worked but looked unHaskellish.
18:51:37 <BMeph> marai: Why doesn't that translate directly? With maybe half of the ";"'s you're using, but still. :)
18:52:31 <BMeph> Does "return" in Ruby make it a loop, then? I've never done Ruby before.
18:53:25 <marai> BMeph: I was able to translate it directly (no sorry there should've been a while loop in that ruby code).
18:54:18 <marai> but I was confused about getContents/hGetContents. I was only using getLine, which I understood was handing me back a line by line. but didn't understand
18:54:34 <BMeph> marai: "Got it" ;)
18:55:01 <marai> :-) alright thanks for your help folks. Gotta grab dinner.
19:18:33 <tabemann> dammit this project is making me rue the whole let's thread a stack through everything while maintaining extra other copies of the stack at times as well design of this algorithm...
19:20:01 <tabemann> when I am done with it it will be just one big pile of `seq`
19:23:23 <tabemann> hah
19:23:26 <tabemann> got the space leak
19:24:02 <applicative> solved a space leak? *write a blog post*
19:24:16 <tabemann> now I want to remove all these extra `seq`s I added... but I will have to carefully remove them one at a time, to make sure that I don't re-break things...
19:24:42 <tabemann> applicative: already put up a question on stackoverflow
19:24:45 * elliott highly disrecommends just sprinkling seqs in places to solve space leaks
19:25:03 <tabemann> what actually solved it, I think, wasn't a `seq` after all
19:25:15 <applicative> there used to be a program that would insert strictness annotations in all possible places, then bench each serially.
19:25:44 <tabemann> but I think that I might have covered cases that could *also* be space leaks with all those `seq`s, hence why I want to be careful about removing them
19:26:21 <applicative> ah here it is, http://hackage.haskell.org/package/strictify
19:26:28 <applicative> i would think it won't build
19:27:42 <applicative> hm it does build
19:29:46 <applicative> " usage: strictify _file_ [Arguments]  Example: strictify foo.hs 400 < infile > fooStrict.hs  The above command determines a locally optimal combination of strictness annotations (hinted to strictify by {- ! -} comments) such that the executable generated by GHC --make -O2 foo.hs runs in minimal time when presented with 400 as an argument and input as derived from infile. The command as presented above then pipes the result to f
19:33:36 <lpaste> tabemann pasted “Do any of these `seq`s look unnecessary?” at http://lpaste.net/92228
19:36:30 <lpaste> tabemann revised “Do any of these `seq`s look unnecessary?”: “Do any of these `seq`s look unnecessary?” at http://lpaste.net/92228
19:39:23 <tabemann> applicative: one thing I note about the Haskell environment is that it is not uncommon to make breaking changes in things, especially language extensions, where, say, I can trust 20-year old C code to work (even though there are C99 changes that break code thanks to the "new" strict-aliasing rules)
19:42:33 <applicative> 10 yr old haskell frequently works, as it happens; since it was all Haskell 98. 2 years' ago's Haskell is more of a problem
19:43:06 <tabemann> of course
19:44:36 <applicative> man this is complicated; is there a simple 'main = ...' you could write. I have an admittedly twisted desire to run 'strictify'...
19:44:39 <applicative> ha
19:44:51 <tabemann> part of that makes me wish that Haskell 2010 hadn't been quite so conservative, so they could have created a language that one could use for what people need out of GHC today without relying on some kind of language extension
19:45:08 <applicative> dis you consider making data Tree a = Value a | Node (Node a)
19:45:16 <applicative> strict in a and Node a?
19:45:26 <tabemann> the problem wasn't that
19:46:03 <applicative> also something like  frameNodes :: !(Node a, Node a) doesn't make the nodes go anywhere
19:46:16 <tabemann> the problem was that I was threading a chain of thunks through the entire path that my code was following through the data structure, including *all* the deepest cycles (before they were caught)
19:46:49 <tabemann> applicative: but the nodes aren't the problem, the problem is the thunk that results in (Node a, Node a)
19:46:54 <tabemann> holding live variables
19:47:51 <tabemann> but actually I don't think the stuff in those data types is actually the problem; I could de-bang many of them, actually
19:48:06 <tabemann> well
19:48:15 <tabemann> no, I'll keep many of those bangs
19:49:17 <tabemann> actually
19:49:47 <applicative> so the function you were testin with was equal? I'm trying to figure out how to build a Tree
19:49:59 <tabemann> what I'll do is change my backtracking, so I just use a record with bangpatterns for my backtracking state, so I can put bangpatterns there, and eliminate a lot of those `seq`s
19:50:25 <tabemann> applicative: I have another source file containing code for that, but that's not where the problem was, so I only pasted this file
19:50:48 <tabemann> applicative: specifically equal with proper cycle detection and resolution
19:51:02 <applicative> i see.
19:51:11 <applicative> i just wanted to witness the space leak!
19:52:49 <tabemann> I could paste the other piece of code, so you can take out the `seq`s and bangs, and change unrolled' on line 143 to unrolled, so then you can have it eat all your RAM
19:54:08 <tabemann> (at a maximum of 1024 nodes for an equals test it would literally eat all 8 GB of RAM on this system in a few seconds)
19:54:15 * applicative is only ever really happy when ghc is eating all his RAM; then he knows none of those other languages have any room to do their black magic
19:54:56 <applicative> ah well
19:55:40 <tabemann> just how fast space leaks can eat all your RAM makes it clear just how efficient GHC's GC is when there *isn't* a space leak
19:56:30 <tabemann> if it can GC 8+ GB of garbage in seconds such as to keep the memory usage under 1 M at any time, as in my working code...
19:56:37 <tabemann> s/M/MB
19:58:10 <bscarlet> tabemann: one of the beautiful things about gc is that it can be done so as to take time proportional to what's left, not what's discarded.
19:58:38 <tabemann> yep
19:58:45 <tabemann> well
19:58:56 <tabemann> that's actually true for the first generation of generational GC
19:59:08 <tabemann> and for copying GC in general
19:59:18 <tabemann> it's not true for mark-and-trace GC
20:01:21 <bscarlet> tabemann: So does your example actually indicate anything extraordinary about GHC's GC, or just GC in general?
20:01:42 <leroux> How can I convert an Int to PortNumber?
20:01:57 <leroux> I found intToPortNumber but that's defined in a hidden module in network.
20:02:10 <leroux> Network.Socket.Types.
20:02:54 <tabemann> bscarlet: it's probably more a matter of how much time it takes to fill the first generation vis-a-vis how long do those objects, for the most part, stay live
20:03:18 <tabemann> if those objects stay live long enough to get promoted to the second generation, GC becomes significantly more expensive for them then
20:03:32 <tabemann> especially if the second generation is mark-and-trace, as is GHC's by default
20:03:43 <bscarlet> leroux: fromIntegral?
20:03:58 <leroux> PortNumber requires a Word16.
20:04:13 <leroux> I use `read port :: Word16` to do that.
20:04:37 <tabemann> you can convert to Word16 with fromIntegral
20:04:43 <leroux> Ahh, okay.
20:04:54 <tabemann> whereas... somehow using read for numeric conversions is probably a suboptimal practice...
20:05:05 <leroux> I have a string for that.
20:05:12 <leroux> So I'm taking a port number from the cmd args.
20:05:20 <tabemann> then use reads, not read
20:05:29 <tabemann> so you can validate the input, and properly handle bad input
20:06:05 <tabemann> reads is String -> [a], where it returns [value] for valid input and [] for invalid input (don't ask me why they didn't just use Maybe)
20:07:13 <geekosaur> tabemann, because it can return *multiple* parses
20:07:16 <geekosaur> not just 0/1
20:07:24 <bscarlet> :t reads
20:07:25 <lambdabot> Read a => ReadS a
20:07:37 <leroux>  sock <- listenOn $ fromIntegral port :: Word16
20:07:41 <leroux> That doesn't seem quite right.
20:07:52 <tabemann> geekosaur: no one told me about that!
20:08:16 <bscarlet> > reads "3foo" :: [(Int, String)]
20:08:17 <lambdabot>   [(3,"foo")]
20:08:21 <geekosaur> leroux, it's right, because the way the network library handles ports is bizarre
20:08:36 <geekosaur> (the fromIntegral is byteswapping it)
20:08:39 <tabemann> > read "3foo3foo" [(Int, String)]
20:08:40 <lambdabot>   Not in scope: data constructor `Int'
20:08:41 <lambdabot>  Perhaps you meant one of these:
20:08:41 <lambdabot>    `I...
20:08:44 <tabemann> > reads "3foo3foo" [(Int, String)]
20:08:45 <lambdabot>   Not in scope: data constructor `Int'
20:08:46 <lambdabot>  Perhaps you meant one of these:
20:08:46 <lambdabot>    `I...
20:08:51 <tabemann> > reads "3foo3foo" :: [(Int, String)]
20:08:52 <lambdabot>   [(3,"foo3foo")]
20:08:53 <geekosaur> not that kind of multiple parse
20:09:09 <geekosaur> if you give it something which could be parsed in multiple ways, it will return a list of possible parses
20:09:28 <tabemann> I see
20:09:39 <bscarlet> > reads "33" :: [(Int, String)]
20:09:40 <lambdabot>   [(33,"")]
20:10:05 <bscarlet> Not [(3,"3"),(33,"")] though.
20:10:10 <geekosaur> there aren't many viable cases of that, because ambiguous parses like that are kinda bad, but if you do arrange for something to be ambiguous reads can cope with it
20:19:21 <tabemann> good; introduced an Unrolled a type with strict members, got rid of those damn tuples and most of those `seq`s
20:20:43 <dpwright> I have written some FFI stuff using hsc2hs to help with marshalling the relevant structs
20:21:14 <dpwright> all of the functions that return a struct (as opposed to a pointer to a struct) throw an "Unacceptable result type in foreign declaration" error
20:21:51 <dpwright> is it not allowed to import functions which return structs?  (I have implemented Storable for the relevant types)
20:23:11 <tabemann> that's a question I've always wondered about myself, despite my contact with the FFI being limited to working with HOpenGLRaw
20:24:12 <dmj`> was the function "generate" removed from Test.QuickCheck?
20:24:31 <johnw> dpwright: returning structs by value varies from architecture to architecture, so I wouldn't be surprised if Haskell's FFI simply doesn't address the posibility, the same as with vararg functions
20:25:06 <dpwright> johnw: OK, thanks -- I didn't realise that (but thinking about it, it makes sense)
20:25:24 <dpwright> this library is a wrapper around a C++ lib anyway, so I can just rewrite it to return pointers, I suppose
20:25:33 <johnw> the structure passing rules on x86_64 take up multiple pages in the ABI spec, for example
20:25:45 <cschneid> if I have a bytestring (returned from snap's getPostParam), I need a Text type. What's the quickest way between the two?
20:25:51 <johnw> some fields in registers, some on the stack, depending on float vs. non-float, etc.
20:26:05 <johnw> cschneid: decodeUtf8/encodeUtf8
20:26:20 <johnw> assuming, of course, that it's UTF-8 encoded
20:26:26 <johnw> see Data.Text.Encoding
20:26:48 <dpwright> johnw: Wow, that's something I've never given any thought to
20:27:01 <tabemann> there's other functions for UTF-16, both little and big endian, as well
20:27:27 <johnw> dpwright: count yourself lucky
20:27:52 <johnw> that's why libraries like libffi exist, to try and free you from having to keep up with the complexity of ABI standards
20:28:43 <cschneid> johnw: amazing, that's perfect
20:28:52 <cschneid> I sure hope it's utf8. :-/
20:29:13 <johnw> cschneid: you can use decodeUtf8' if you don't want an exception should it fail to decode
20:29:21 <johnw> or, use decodeUtf8With lenientDecode
20:29:29 <johnw> to just replace wrong encoding with the UTF-8 standby character
20:29:38 <cschneid> johnw: cool
20:29:47 <tabemann> why is there only decodeUtf8', and not, say, decodeUtf16BE'?
20:29:52 <johnw> dunno
20:31:24 <ayhid> I'm having very hard time understanding the bind function for Reader monad, i checked http://www.maztravel.com/haskell/readerMonad.html and  http://adit.io/posts/2013-06-10-three-useful-monads.html#the-reader-monad
20:44:39 <tabemann> ayhid, basically, the bind function produces a new function that takes an environment, which it passes to the function m in m >>= k, which then gives a value that it passes to the function returned by k
20:44:47 <tabemann> giving its return value
20:46:20 <tabemann> where m is a function that represents a mapping from an environment to a result, so hence >>= builds a new function that also is such, except that it passes the environment to both m and the function returned by k, and it passes the return value of m to k
20:47:59 <bos> tabemann: because nobody much uses utf16
20:48:47 <tabemann> bos: except that Text itself uses UTF-16 internally, as do many libraries and the JVM
20:49:12 * tabemann remembers having to work with a library that used UTF-16 internally in an otherwise UTF-8 environment; that was fun...
20:49:14 <bos> tabemann: but it's not used much as an external representation.
20:49:20 <tabemann> yeah
20:49:34 <bos> tabemann: if someone came along with a pull request because they needed it, i'd add it.
20:49:48 <bos> as things stand, the lack of demand is telling.
20:50:22 <ayhid> tabemann, r is the environment or a reader it's pretty vague for me
20:50:55 <geekosaur> the point of a reader is to carry something around. that something is referred to as the environment
20:50:59 <tabemann> ayhid: in that first page (I didn't read the second), the environment is r
20:51:09 <geekosaur> you might want to look at the primitive version of the reader monad: ((->) r)
20:51:21 <tabemann> geekosaur: that's the monad we're looking at
20:51:27 <geekosaur> which is to say, functions from r to (something)
20:51:40 <alastor__> i've seen some codes in examples which feature Elem. Is it a  type class or a type or something else? I can't seem to find anything useful on google since there's a function named elem and that takes up all search results
20:52:02 <ayhid> geekosaur, yes i grasped the concept of the reader, but having some problem with the syntax and vague names :)
20:52:23 <ayhid> tabemann, geekosaur  thanks i'll give it some deep thinking now
20:55:31 <dpwright> Another FFI question... I have written my wrapper which just binds a load of extern "C" functions that then call the C++ equivalents, and compiled it as a static library.  Attempting to link against that with GHC gives me undefined references on things like "operator new".. I am passing -lstdc++ to GHC
20:55:50 <dpwright> what I'm trying to do should be possible, right?
20:56:22 <dpwright> (By the way, I'm on Windows, using MinGW to build the static library... not sure if that makes a difference)
20:57:36 <geekosaur> dpwright, did you also include the C++ objects it's referencing?
20:58:21 <geekosaur> (er, objects is not the word you probably read it as. "C++ object code and/or libraries"
20:58:44 <ayhid> http://pastebin.com/VUsUgMaH here's a snippet how can i chain the greeter, byer readers to some input ?
20:58:49 <mauke> The paste VUsUgMaH has been copied to http://lpaste.net/92229
20:59:38 <dpwright> geekosaur: Well, the objects that library uses are created in a dll file which the library loads.  I include the header distributed with that dll, but the object code itself is obviously not included
21:00:08 <dpwright> so the only object that is linked in my static library is a single .o file created from my .cpp file
21:01:02 <dpwright> looking at the errors, it seems they are all undefined references to either "new" or "delete", except the last one, which is an undefined reference to "__gxx_personality_v0"
21:01:17 <geekosaur> mmmh, I want to say that won't work unles syou explicitly link against the DLL, but I can;t say that for certain given it's Windows
21:01:28 <geekosaur> oh
21:02:09 <geekosaur> hm. that's the c++ internals then. you need more than -lstdc++ then, but I don't know how *on windows* you get them other than using g++ to do the final link
21:02:32 <tabemann> ayhid: that looks like you really want is ReaderT String (Writer String a)
21:03:14 <tabemann> but if you really just want to concatenate those two strings
21:03:20 <ayhid> tabemann, haven't advanced to monad transformers yet :( , i want to run both functions and pass them a string as shared state :(
21:05:08 <dpwright> geekosaur: Hmm, thanks.  When I did this before, exposing the same library to Racket's FFI, I ended up making a dll with libgcc and libstdc++ compiled statically into it
21:05:22 <tabemann> ayhid: I added an annotation to your code
21:05:45 <dpwright> maybe I'll need to do something similar here, though I'd rather compile my wrapper in statically than have to distribute two dlls
21:06:23 <geekosaur> um. you were hoping the dll would magically get sucked into your static object?
21:06:25 <geekosaur> doesn;t work thjat way
21:07:03 <geekosaur> usually is impossible, except in some very limited circumstances (linux i386 for example)
21:07:06 <dpwright> no, but I would expect it to get linked at runtime rather than at compile time... that's the point, isn't it?
21:07:23 <ayhid> tabemann, haven't advanced to monad transformers yet, so i want to run both functions and pass them a string as shared state ?
21:07:44 <ayhid> s/i/if*
21:07:46 <geekosaur> static objects can only load dynamic objects explicitly, not automatically
21:07:58 <tabemann> ayhid: I just annotated your code with how you want to do it if you want to avoid monad transformers
21:08:04 <geekosaur> that is, you would have to use the win32 calls to load a DLL and to look up symbols in it
21:08:09 <tabemann> which is honestly much simpler than doing it the monad transformer way
21:08:24 <ayhid> tabemann, yes, i checked it thanks alot :)
21:08:42 <dpwright> geekosaur: Ah, sorry, yes, I am doing that.  Or rather, the DLL provides a function which does that (and is defined inline in the dll), and I'm calling it
21:09:26 <ayhid> tabemann, i know scheme, ocaml, but never crossed such terms before and with the syntax i'm feeling => :(
21:09:26 <geekosaur> if it's *in* the dll, you still need to get a dll handle and look up that function yourself, not just refer to it and hope the right thing happens...
21:09:38 <geekosaur> but, I think you need someone who knows the windows toolchain better'
21:12:00 <alastor__> what is an Elem ?
21:14:46 <tabemann> alastor__, I just looked up on Hayoo, and it found nothing named "Elem", as opposed to "elem", which is a function a -> [a] -> Bool
21:15:23 <geekosaur> you didn't look right, then
21:15:29 <geekosaur> Elem is in the "word cloud"
21:15:34 <geekosaur> along with Elem'
21:15:54 <tabemann> I clicked on "Elem" in the word cloud, and it got me back to the same point
21:16:02 <geekosaur> the problem is finding only those :) since clicking on the word in the word cloud doesn't acutally constrain it
21:16:23 <dpwright> geekosaur -- ok, thanks, I'll look into it a little more...
21:16:34 <alastor__> this is an excerpt from H99, so I thought it would be basic stuff http://pastie.org/8276087
21:17:13 <tabemann> I did "Elem" with quotes and it's just getting me lots of functions named "elem" or "notElem"
21:17:14 <geekosaur> you apparently didn't read what you pasted
21:17:15 <alastor__> is it analogous to cons in lisp?
21:17:27 <geekosaur> "We have to define a new data type, because lists in Haskell are homogeneous."
21:17:36 <geekosaur> and then it *defines* something it calls Elem
21:17:49 <alastor__> doesn't it define something based on Elem?
21:17:50 <geekosaur> it does not use an *existing* Elem, it creates a new thing which it calls Elem
21:18:15 <tel> tabemann scroll a few pages and you find `Data.Vinyl.Witnesses.Elem` and `Feldspar.Core.Collection.Elem`, `Database.Ferry.Syntax.Elem` and one in SBV
21:18:17 <geekosaur> actually it creates a thing it calls NestedList. this has two constructors, which are also defined as part of it
21:18:34 <geekosaur> one of those new constriuctors is Elem, the other is List
21:18:35 <tel> not that any of those are likely H99
21:19:00 <tel> oohhhh…
21:19:07 <alastor__> oh so Elem is also defined within the definition for NestedList, is that correct?
21:19:11 <geekosaur> (note that standard Haskell does not have anything called "List"! it has [a]
21:19:15 <geekosaur> yes
21:19:33 <geekosaur> data Foo = A | B | C -- same thing, defines a type Foo and new "values" A, B, C
21:20:14 <gnuvince-> Can anyone confirm if there is an error in slide #9: http://comonad.com/haskell/Lenses-Folds-and-Traversals-NYC.pdf .  Shouldn't it be: data Store s a = Store (a -> s) a ?
21:20:19 <alastor__> hmm ok thank you geekosaur tel tabemann
21:20:25 <tabemann> geekosaur: that reminds of a question that I've had for a long time - what do you do if you want something that has kind * -> * which is a type constructor for a list, not a list itself
21:20:43 <geekosaur> :k []
21:20:58 <geekosaur> hello bot...
21:21:14 <lambdabot> * -> *
21:21:33 <tabemann> okay, so [] is the type constructor for lists (did not know that)
21:21:37 <geekosaur> the type [a] is syntactic sugar for ([] a)
21:24:05 <erisco> Applicative interface seems close to composition (.) ... is there some relationship?
21:25:00 <erisco> I say that because my definition for <*> looks very close to a definition I made up for composition
21:25:38 <johnw> gnuvince-: the slides are correct
21:25:49 <johnw> a store comonad holds some state, and a function to yield a value from that state
21:26:23 <shachaf> Calling a value "a comonad" is as bad as calling it "a monad". :-(
21:26:47 <johnw> what terminology would be better?
21:27:21 <shachaf> I'm not sure there's a standard dual of, say, "action".
21:27:45 <tel> "a value in a comonadic context"?
21:27:46 <tabemann> erisco: umm doesn't <*>, just from the type signature, look rather like *function application*, except in the context of an applicative?
21:27:47 <elliott> coaction.
21:27:53 <edwardk> tel: nice tutorial
21:27:59 <shachaf> But saying something slightly longer isn't so bad.
21:28:00 <erisco> tabemann, yes, and?
21:28:17 <shachaf> E.g. a value of type "Store s a" holds a value of type "s" and a function of type "s -> a"
21:28:25 <tel> edwardk thanks—I think I may have kicked the bug now
21:28:36 <shachaf> Of course, the syntax "Store s a = (s, s -> a)" is a shorter way of saying the same thing. :-)
21:28:39 <edwardk> tel: heh.
21:28:46 <erisco> I use the same underlying function for <*> and composition (I called .>) except I collect results with ($) and (.) and reverse the arguments
21:28:56 <geekosaur> erisco, have you studied the Typeclassopedia?
21:29:14 <erisco> sorry I'm not up for riddles
21:29:19 <johnw> maybe I just needed to say "the store comonad" instead of "a store comonad", since people commonly refer to "the state monad" in the same sense
21:29:21 <edwardk> tel: i'm more than happy for you to continue. ;) now you just need to explore isomorphisms, equalities, indexed lenses, zippers, the plated combinators, magma, levels...
21:29:36 <johnw> or maybe that isn't clear either
21:29:40 <tel> edwardk I'll… get right on that
21:29:46 <edwardk> tel: my one objection is that there is no caveat that 'costate' is the wrong name for store, as it isn't dual to state
21:30:03 <johnw> since (s, a -> (a, s)) isn't the monad per se, but just a data type for which an instance of Monad exists
21:30:04 <shachaf> edwardk: Do you also object to "counit"?
21:30:32 <johnw> edwardk: store is the comonad of the flipped adjunction, right?
21:30:35 <shachaf> Well, the instance is for the type constructor.
21:30:38 <tel> edwardk: mmm, what do you call it then?
21:30:42 <johnw> shachaf: ooh, good point
21:30:53 <edwardk> shachaf: no. counit is fine
21:31:02 <tel> edwardk I only know the flipped adjunction relationship… and I really wanted to somehow explain that whole "costate comonad coalgebra" line
21:31:04 <edwardk> it is a unit in the opposite category
21:31:11 <shachaf> Is it?
21:31:12 * johnw has learned to appreciate shachaf's dedication to clarifying terminology
21:31:15 <shachaf> Oh, as in G^op -| F^p[
21:31:22 <edwardk> shachaf: yes
21:32:05 <shachaf> So, (s,) -| (s ->), and (s ->)^op -| (s,)^op
21:32:11 <edwardk> but store isn't dual to state, its given rise to by the adjunction composed in the other order.
21:32:21 <johnw> right
21:32:22 <shachaf> And the monad that you get is (s ->)^op . (s,)^op
21:32:30 <shachaf> Er, comonad.
21:32:35 <shachaf> Well, depends on the category.
21:32:50 <edwardk> which you then flip around to get a monad in hask, putting you where you started
21:32:59 <edwardk> iirc
21:33:25 <tel> Hmm. I'll probably just rewrite that whole section then.
21:33:53 <tel> Or removing it. It's almost totally superfluous except to explain the gag line
21:34:43 <shachaf> awHmm, does it give you a monad or a comonad?
21:34:45 <edwardk> the gag line is fun. i just decided at some point at roconnor's urging to stop using costate as the name for it, because it was actively getting in the way of people understanding store
21:35:01 <johnw> shachaf: do you have a good example for explaining limits in the context of Haskell, like you did when you explained Coyoneda?
21:35:16 <edwardk> shachaf: i think you need to do a pen and paper proof =)
21:35:36 <shachaf> edwardk: I think I do.
21:35:38 <erisco> geekosaur, where on typeclassopedia should I be looking?
21:35:54 <edwardk> johnw: name inhabitants of forall a. [a]
21:36:01 <tel> I'm footnoting it to explain the line in a better setting
21:36:14 <johnw> [], [_|_], [_|_, _|_], etc.
21:36:23 <edwardk> johnw: modulo _|_'s
21:37:04 <edwardk> so without bottoms you get?
21:37:08 <johnw> [], [x], [x,x], etc., for some x that names the a
21:37:20 <shachaf> But there's a forall out there.
21:37:31 <tabemann> threadscope question
21:37:51 <edwardk> johnw: i want the quantified a. so you can't use a
21:37:53 <tabemann> whenever I've tried to use threadscope, it eats *all* the RAM on my system, no matter how short I try to make my eventlog
21:38:06 <johnw> edwardk: then isn't [] the only thing I can give?
21:38:09 <shachaf> I'd say that Hask doesn't have many interesting limits, I think, so it probably isn't very interesting in general.
21:38:09 <edwardk> yep
21:38:11 <edwardk> johnw: congratulations on finding your first limit
21:38:20 <shachaf> But it sounds like edwardk might have a better answer.
21:38:22 <johnw> actually, I've read this presentation before, let me find it...
21:38:43 <shachaf> edwardk: What's that the limit of?
21:39:00 <edwardk> damnit now i have to go remember =)
21:40:06 <johnw> edwardk: I was thinking of http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
21:40:15 <johnw> but he doesn't make the connection to a limit there
21:41:13 <carter> what article are you guys talking about?
21:43:00 <bos> could anything be more fun than constructing an interpreter over a free monad.
21:43:09 <johnw> edwardk: so, is the limit of any inductive type similar to the property which allows Agda to be able to decide if inductive recursion will terminate?
21:43:24 <johnw> bos: constructing one over Codensity (F
21:43:28 <johnw> ree f), of course
21:43:38 <shachaf> Free (CoYoneda f), surely.
21:44:05 <bos> bah, all you category wonks spoil the atmosphere.
21:44:17 <bos> we were simple peasants, and proud, once.
21:44:38 <johnw> Codensity (Free f) is basically the same as taking monad coproducts, right?
21:44:55 <shachaf> johnw: How?
21:45:13 <shachaf> bos: That just makes the "Program" monad: data Program f a where { Return :: a -> f a; Then :: f a -> (a -> Program f b) -> Program f b }
21:45:28 <shachaf> Which is isomorphic to Free when f is a functor.
21:45:56 <johnw> I was reading edwardk's comments from 28 days ago to Oleg's recent paper on effects, and he linked it back to Daat Types a la Carte, which is based on monad coproducts, and in that context he brought up Codensity (Free f).  So I don't know enough yet to answer 'how', more I'm trying to see if I'm heading in the right direction toward understanding this
21:46:17 <bos> shachaf: ok
21:46:28 <johnw> shachaf: but now you've made me wonder how Free (Codensity f) relates to Codensity (Free f)
21:47:02 <johnw> sorry, Free (CoYoneda f)
21:47:48 <shachaf> Well, Codensity (Free f) is bigger.
21:47:57 <johnw> what does "bigger" mean in that context?
21:48:03 <johnw> i saw edwardk say that too
21:48:07 <shachaf> Has more inhabitants.
21:48:09 <carter> "has more things"?
21:48:10 <johnw> ahh
21:48:11 <mauke> encompasses more values
21:48:23 <mauke> is more famous in japan
21:48:37 <tel> is slightly smaller than your mom
21:48:53 <shachaf> tel: Is that necessary?
21:49:05 <tel> no, but it's late
21:49:19 <mauke> false. it's 6:49
21:49:30 <carter> i know its late by how many typoes i make as I type
21:49:38 <carter> or by how late it is
21:49:42 <carter> go sleep!
21:50:20 <shachaf> gnuvince: By the way, there's #haskell-lens for lens-related questions.
21:50:57 <carter> or any other kmett lib
21:51:01 <carter> for that matter
21:51:06 <edwardk> =P
21:51:09 <carter> or just darn cool haskell things
21:51:16 <johnw>  edwardk: what's another limit example?
21:51:34 <edwardk> johnw:	 Codensity (Free f) isn't monad coproducts
21:51:39 <shachaf> Hey, edwardk still owes me an explanation for the last one!
21:51:52 <johnw> k, I can wait :)
21:51:55 <edwardk> shachaf: stopped searching. barely awake
21:52:25 <johnw> edwardk: Codensity (Free f) is a CPS'd transformation of a coproducts representation?
21:52:31 <edwardk> johnw: Free f   for an ala carte f would be a lawvere theory coproduct of the pats you used to build f
21:52:44 <edwardk> Codensity CPS's it, which makes it much bigger than the lawvere theories
21:52:49 <johnw> bos: did we scare you off?
21:53:08 <johnw> edwardk: that helps
21:53:28 <edwardk> oleg's construction works in Codensity (Free f)) for a coproduct of monads f,    but if we look at that, its simultaneously too big and too small
21:53:30 <bos> johnw: i know when to shut my eyes
21:53:32 <edwardk> it is too big for Reader.
21:53:47 <edwardk> Codensity (Reader e) is State e!
21:53:57 <edwardk> it is too small to contain lazy writer. you can't write it!
21:53:58 <johnw> whoa
21:55:12 <edwardk> @remember bos bah, all you category wonks spoil the atmosphere. we were simple peasants, and proud, once.
21:55:13 <lambdabot> It is stored.
21:55:15 <shachaf> bos: Did you ever see my explanation of CoYoneda in Haskell? It's a reasonably straightforward solution to a practical problem.
21:55:40 <johnw> shachaf: that explanation was really stellar, I'm hoping you blog it
21:55:45 <bos> shachaf: i quite possibly did, but the number of blog posts i have read without absorbing is ... large
21:55:56 <ayhid> Now i have a question, m >>= k  = Reader $ \r -> runReader (k (runReader m r)) r , here we start from runReader m r , then get a value , why do we want to apply k to it ?
21:56:29 <shachaf> Hmm, I think I only ever said it in IRC, so probably not.
21:56:45 <shachaf> Maybe I should get in the habit of writing things outside of IRC.
21:57:10 <edwardk> ayhid: get m >>= k there to typecheck without doing so
21:57:21 <edwardk> ayhid: you need to get a b in the end, and k is the only source of b's!
21:57:25 * hackagebot aws-elastic-transcoder 0.1.0.1 - Haskell suite for the Elastic Transcoder service  http://hackage.haskell.org/package/aws-elastic-transcoder-0.1.0.1 (ChrisDornan)
21:57:48 <edwardk> (e -> a) -> (a -> e -> b) -> e -> b
21:57:57 <edwardk> just going through the arguments to bind there
21:58:07 <ayhid> edwardk, sorry not following  :(
21:58:11 <shachaf> Make sure e is a comonoid.
21:58:29 <edwardk> we have (>>=) ea aeb e = aeb (ea e) e
21:58:34 <edwardk> modulo the newtype noise
21:58:42 <johnw> shachaf: would you mind if I took your explanation and turned it into a blog article, pending your review of course?
21:58:46 <edwardk> where ea is the function from e -> a,    aeb is a -> e -> b
22:00:04 <ayhid> edwardk, don't i want aeb to be (a e  argument) ?
22:00:10 <edwardk> ea e  gives you an a, which since we need to get b, and the only path to b is through aeb is good. so we take and apply it and get aeb (ea e) :: e -> b     now we need to apply it another argument.
22:00:50 <edwardk> @djinn (e -> a) -> (a -> e -> b) -> e -> b
22:00:50 <lambdabot> f a b c = b (a c) c
22:01:09 <ayhid> totally lost :(
22:01:20 <edwardk> Reader e a = e -> a   right?
22:01:34 <ayhid> k supposed to take e (implicitly) and another argument *i* should pass  right ?
22:01:38 <edwardk> (>>=) :: Reader e a -> (a -> Reader e b) -> Reader e b
22:01:51 <edwardk> if we rip off the newtype for Reader from that, we get
22:02:02 <edwardk> (e -> a) -> (a -> e -> b) -> (e -> b)
22:02:12 <ayhid> edwardk, uhaa! got it!
22:02:42 <edwardk> now its just put the arguments where they go, because there is only one definition that typchecks without _|_'s
22:03:01 <edwardk> that was what djinn gave back to us
22:03:09 <edwardk> and then you have to clutter it with newtypes
22:03:13 <edwardk> and you get where you started
22:03:28 <ayhid> edwardk, thanks alot :)
22:03:31 <edwardk> np
22:04:01 <edwardk> ayhid: you may want to work through (<*>) for Reader to make sure you have this down pat
22:04:06 <edwardk> that is very similar
22:06:51 <shachaf> johnw: I think I may as well do it myself, with all this encouragement. I should set up a place to post things anyway.
22:07:03 <johnw> shachaf++
22:07:33 <johnw> and write about your limits presentation from SEAHUG too, if you have an inkling.  mgsloan told me enough to make me feel like I really missed something
22:08:04 <shachaf> Watch the catsters videos.
22:08:24 <shachaf> I'm not qualified to write about limits. I don't even know what edwardk meant!
22:08:47 <johnw> edwardk: explain!
22:09:06 <shachaf> He's tired, let him be.
22:09:24 <johnw> i'm still struggling to get a right intuition for universal properties, which I think is blocking me from fathoming limits
22:09:57 <shachaf> Maybe I'll get it out of him when he visits in Oct.
22:10:14 <johnw> I'll see him too in Sep
22:10:25 <johnw> we'll compare notes :)
22:11:37 <shachaf> Anyway, a limit is just a universal cone. And cones are pretty straightforward. So yes.
22:15:17 <fylwind> is there a way to nest a do expression inside another do expression? kind like "do { ...; return do { ... } }
22:15:28 <johnw> sure
22:15:36 <shachaf> Yes. The issue here isn't with the nesting, it's with the "return do"
22:15:43 <johnw> do { x <- foo; do { y <- bar } }
22:15:45 <johnw> oops
22:15:46 <shachaf> "do" is special syntax, "return" is a regular function.
22:15:49 <johnw> do { x <- foo; do { y <- bar; return y } }
22:15:59 <shachaf> So maybe try do { ...; return $ do { ... } }
22:16:00 <arkeet> the last statement doesn't even have to be return.
22:16:09 <johnw> return $ do is still likely to be wrong
22:16:10 <shachaf> (But, of course, what arkeet said.)
22:16:11 <arkeet> shachaf: then you'd be mixing two different monads.
22:16:39 <shachaf> arkeet: Right. But syntactically what fylwind asked for is allowed.
22:16:43 <arkeet> sure.
22:17:00 <fylwind> well i am mixing two different monads! :p
22:17:02 <shachaf> what would mauke do?
22:17:03 <enthropy> > do do do () -- is also allowed
22:17:04 <lambdabot>   ()
22:17:07 <arkeet> > do { a <- [1,2,3]; return $ do { Just a }}
22:17:08 <lambdabot>   [Just 1,Just 2,Just 3]
22:17:14 <fylwind> outer 'do' is for an arbitrary monad, inner 'do' is for a maybe
22:17:48 <fylwind> but yeah it's the "$" that I was missing, thanks!
22:17:52 <johnw> then return $ do would do it
22:18:14 <shachaf> Another thing that would do it is "return (do { ... })"
22:29:59 <ayhid> edwardk, runReader ( byer (runReader greeter "haskell")) "haskell" that code isn't valid ?
22:32:30 <dpwright> with reference to my earlier problem, I am still not sure what the issue was, but I have found a solution.  Compiling my C++ file as a static library resulted in linking errors even when using -lstdc++, however if I simply compile it to a .o file and pass that into ghc manually, it links fine with -lstdc++
22:32:53 <dpwright> so I think perhaps I was building the library wrong or something -- but whatever the case, it works, so I'm happy with that
22:35:20 <bos_> dpwright: be warned that ghci's linker doesn't run static initializers in C++ code
22:36:20 <dpwright> bos_ thanks for the warning -- this code has no statics, so I think I should be safe?
22:36:39 <bos_> dpwright: hopefully
22:37:31 * hackagebot openid 0.2.0.2 - An implementation of the OpenID-2.0 spec.  http://hackage.haskell.org/package/openid-0.2.0.2 (TrevorElliott)
23:00:17 <EvanR> i think im up too late again
23:00:39 <EvanR> i stumbled on "reactive demand programming"
23:01:42 <EvanR> is the material on reactive demand programming generated randomly?
23:24:05 <mr-> is haskell.org broken again?
23:25:02 <mauke> http://downforeveryoneorjustme.com/haskell.org
23:30:56 <mr-> pity
23:31:10 <johnw> any cloud haskell devs on?
23:31:56 <thoughtpolice> edsko will probably be around sometime soon
23:36:37 <johnw> thanks, thoughtpolice
