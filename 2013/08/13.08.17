00:00:00 <edwardk> this gives me the tools i need so that when i want to render an image in the text, I can do it by writing a program that draws the image for me, which since the source is visible really lets me elevate the notion of a tutorial to the next level
00:00:27 <johnw> and since that's really our objective, anything which supports that is pretty much a no-brainer
00:00:29 <edwardk> i had to learn yesod and diagrams to do it, but it worked out
00:00:44 <johnw> does stackage have reflection-1.3.2?
00:00:49 <edwardk> not sure
00:00:59 <johnw> i noticed that our own build environment uses 1.1.7
00:01:01 <edwardk> i released it, and i support it
00:01:06 <edwardk> so it should
00:02:06 <edwardk> now the real trick would be going back to my first matrix tutorial and replacing the z-order image from wikipedia with a custom diagram
00:02:09 <edwardk> =)
00:02:16 <Taneb> I probably ought to learn about memoization in Haskell it some point
00:02:24 <Taneb> Hold on
00:02:32 <johnw> Taneb: once you learn it, the knowledge is always there
00:02:36 <Taneb> I just realised it's memo-ization
00:02:45 <Taneb> I thought it was memoize-ation
00:02:51 * Taneb facepalm
00:03:03 <startling> uh.
00:03:16 <johnw> i'm still unclear on words like "inpredicable"
00:03:23 <johnw> mi?
00:04:56 <startling> so anyway, what's the best way to statically compile information into an executable or library with cabay?
00:06:17 * hackagebot crypto-cipher-types 0.0.3 - Generic cryptography cipher types  http://hackage.haskell.org/package/crypto-cipher-types-0.0.3 (VincentHanquez)
00:11:17 * hackagebot crypto-cipher-tests 0.0.3 - Generic cryptography cipher tests  http://hackage.haskell.org/package/crypto-cipher-tests-0.0.3 (VincentHanquez)
00:11:19 * hackagebot crypto-cipher-benchmarks 0.0.2 - Generic cryptography cipher benchmarks  http://hackage.haskell.org/package/crypto-cipher-benchmarks-0.0.2 (VincentHanquez)
00:11:21 * hackagebot cipher-des 0.0.1 - DES and 3DES primitives  http://hackage.haskell.org/package/cipher-des-0.0.1 (VincentHanquez)
00:11:23 * hackagebot cipher-blowfish 0.0.1 - Blowfish cipher  http://hackage.haskell.org/package/cipher-blowfish-0.0.1 (VincentHanquez)
00:13:09 <elliott> @flush
00:13:12 <elliott> @quit
00:14:13 <elliott> :t ?x
00:14:25 <lambdabot> (?x::t) => t
00:14:28 <elliott> I also doubled the evaluation timeout.
00:14:36 <dmwit> thanks
00:14:44 <elliott> also, you can probably @let an undecidable instance in /msg and get every @run to timeout without a useful error message.
00:15:00 <elliott> I suggest not doing that and instead becoming paranoid and @undefining whenever it times out
00:15:06 <dmwit> :t let x :: forall a. a; x = undefined in x
00:15:11 <lambdabot> a
00:15:14 <dmwit> hooray
00:16:17 * hackagebot cipher-aes 0.2.3 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.2.3 (VincentHanquez)
00:16:51 * wagle calculates how many time he needs to apply the elliott function to get effectively infinite evaluation timeouts
00:17:21 <elliott> someone should rewrite lambdabot to not be a pain to maintain, and also rewrite me to care less about pain.
00:17:35 <wagle> eww
00:17:50 <wagle> i felt your pain
00:18:10 <wagle> thanks
00:18:23 <elliott> always happy to contribute pain
00:18:49 <wagle> no, i mean thanks for subjecting yourself to the pain
00:19:17 <elliott> but you felt it.
00:19:20 <elliott> I actually just transferred it to you.
00:19:29 <wagle> oops
00:19:55 <wagle> where is the source of lambdabot these days?
00:20:33 <elliott> @version
00:20:33 <lambdabot> lambdabot 5.0
00:20:33 <lambdabot> git clone git://github.com/mokus0/lambdabot.git
00:20:46 <elliott> I also have a hacky local diff that I should merge upstream or whatever one of these days.
00:20:54 <wagle> ah
00:21:00 <elliott> though it's only minor things
00:21:07 <startling> @pl \f -> a f $ b f
00:21:07 <lambdabot> ap a b
00:21:13 <elliott> oh, and a lens patch too!
00:21:16 <startling> wooh, no more weird @pl-resume stuff
00:21:17 <elliott> so many patches.
00:21:24 <elliott> startling: uh, I didn't change @pl.
00:21:26 <elliott> you just got lucky.
00:21:32 <wagle> it always occurs to me to google after i lazy google
00:21:35 <wagle> http://www.haskell.org/haskellwiki/Lambdabot
00:21:41 <elliott> that wiki page is totally wrong though :)
00:21:48 <wagle> hahah
00:21:55 <startling> elliott: mightn't the evaluation timeout fix that?
00:22:12 <elliott> um. I doubt it, I just patched mueval itself.
00:22:19 <elliott> feel free to try another example and thank me if it works
00:22:28 <startling> oh well. thanks!
00:22:53 <wagle> cool..  i click on a git url, and it fires up xcode for me
00:22:59 <elliott> maybe I can do some git bisecting to find out when and how @pl broke when the idea of the lambdabot code doesn't fill me with dread
00:22:59 <startling> @pl \a b c d -> c d (b a)
00:23:02 <lambdabot> (flip flip .) . flip id
00:23:02 <lambdabot> optimization suspended, use @pl-resume to continue.
00:23:07 <elliott> ah, how reassuring.
00:23:49 <wagle> that shouldnt have been that hard
00:26:17 * hackagebot language-java 0.2.5 - Manipulating Java source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/language-java-0.2.5 (VincentHanquez)
00:27:34 <wagle> i'm sure i will find out first hand, but whst makes maintaining lambdabot a pain?
00:28:12 <wagle> besides a noted lack of documentation (apparently)
00:29:53 <elliott> well, it's not actually a pain.
00:29:59 <elliott> only kind of.
00:30:04 <elliott> it's just annoying to recompile things and stuff.
00:30:20 <elliott> and various things are just broken for no apparent reason.
00:31:27 <wagle> ah..  ok..  figuring out lambdabot has been on my joblist (the far end) for a couple years now
00:36:58 <johnw> aristid: ping
00:59:19 <aristid> johnw: you are lucky to ping me when i'm actually here :)
00:59:36 <johnw> :)
00:59:42 <johnw> we overlap a lot apparently
00:59:42 <aristid> johnw: aren't you in the US though? i mean this is not a US-people-are-awake time
00:59:46 <johnw> i'm odd
00:59:59 <johnw> i answered my own question at any rate (it was an aws question)
01:00:13 <aristid> johnw: may i know anyways what the question would have been?:)
01:00:37 <johnw> how to distinguish NoSuchKey from other errors when querying
01:00:49 <johnw> apparently you have checkStatus set to swallow any and all status codes coming from Amazon
01:01:36 <aristid> johnw: swallow?
01:01:46 <johnw> so HEAD Object on a non-existent object doesn't actually fail gracefully
01:01:48 <aristid> johnw: iirc i had to change the status thing to never throw an exception
01:01:56 <johnw> rather, it dies because there is no ETag in the 404 response
01:02:12 <aristid> ah can you fix it?
01:02:16 <johnw> it just so happens that this work,s but it prevents me from seeing the actual status code
01:02:19 <johnw> i may have to
01:04:30 <aristid> johnw: aws has its own error detection thing, so i didn't want http-conduit to do its thing for that
01:04:53 <aristid> johnw: does it not detect the 404 as an error for the HEAD?
01:07:32 <hpaste> jtbandes pasted “No title” at http://lpaste.net/91911
01:07:39 <johnw> sure
01:07:39 <jtbandes> what am I doing wrong?
01:07:54 <johnw> i was thinking we could put the status code into the Response as a new field
01:30:18 <Polarina> jtbandes, change line 3 to {print x} and remove line 4.
01:30:50 <jtbandes> Polarina: of course, this example is a simplification of what I want to do... the real code is not so trivial, but this illustrates the problem
01:31:16 <Polarina> jtbandes, try adding {let foo = x} in between lines 2 and 3.
01:33:18 <LordBrain> or passing x as a parameter to whatever function he is defining in his where clause
01:33:59 <LordBrain> he's trying to get x out of the monad
01:36:07 <Polarina> I'm not sure it works that way, or I have little idea on what he's trying to do.
01:36:47 <LordBrain> yeah it depends on what his real code is, i think he just showed us this simplified thing.
01:37:39 <LordBrain> but i mean the where clause declarations are outside of the do block so of course x is not available there.
01:38:39 <LordBrain> that would be unsafeIO
01:39:19 <LordBrain> even if the scoping rules actually permitted it
01:39:25 <LordBrain> which they dont..
01:44:52 <LordBrain> i guess it is mostly just a scoping thing actually
01:45:53 <LordBrain> well no... i am right... because even if you change the scoping rules, you wouldn't change them to place them inside the scope of the do block
01:46:08 <LordBrain> that makes little sense
01:51:19 * hackagebot liblastfm 0.3.0.0 - Lastfm API interface  http://hackage.haskell.org/package/liblastfm-0.3.0.0 (MatveyAksenov)
01:57:41 <wagle> need to reinstall macosx to restore fonts, apparently..  8(
01:59:46 <azm> istn last fm dead hackagebot
02:04:26 <merijn> azm: hackagebot just announces packages uploaded to hackage by people
02:05:19 <azm> he could send the messages to the creators as well :p
02:06:54 <solirc> Hackage is down :(
02:07:07 <azm> yea
02:09:14 <solirc> https://travis-ci.org/hspec/hspec/builds/10304819
02:09:16 <solirc> :(
02:14:29 <merijn> solirc: No it's not?
02:14:29 <merijn> solirc: It works just fine here
02:14:29 <johnw> it was down when he said that
02:14:30 <johnw> now it's back
02:16:39 * hackagebot hspec-smallcheck 0.1.0 - SmallCheck support for the Hspec testing framework  http://hackage.haskell.org/package/hspec-smallcheck-0.1.0 (SimonHengel)
02:25:08 <erisco> > 5
02:25:08 <lambdabot>   mueval-core: GhcException "cannot satisfy -package lambdabot-haskell-plugin...
02:25:11 <erisco> :(
02:27:08 <hpaste> Kaini pasted “wxc fails to build” at http://lpaste.net/91912
02:27:17 <Kaini> Building wxc-0.90.0.4 against wxWidgets 2.9.5 fails with http://lpaste.net/91912 (ghc 7.6.3; Haskell Platform 2013.2.0.0). Has anyone an idea how to fix this? Should I use another version of wxWidgets?
02:31:58 <elliott> oh.
02:32:00 <elliott> > ()
02:32:01 <lambdabot>   mueval-core: GhcException "cannot satisfy -package lambdabot-haskell-plugin...
02:32:03 <elliott> cool, I broke it
02:32:52 <elliott> @flush
02:32:54 <elliott> @quit
02:33:12 <elliott> > ()
02:33:27 <lambdabot>   ()
02:33:35 <elliott> cool and great.
02:33:47 <elliott> > let ?x = 3 in ?x
02:33:53 <lambdabot>   3
02:34:22 <Yaniel> ? is allowed in variable and function names?
02:34:33 <elliott> it's an implicit parameter.
02:34:35 <elliott> they're weird.
02:34:47 <elliott> I suggest not using them for their intended purpose. (they're a language extension)
02:34:50 <elliott> they're quite useful as holes though.
02:36:01 <Yaniel> > let x = 3 in x
02:36:09 <lambdabot>   3
02:37:38 <kryft> ? reminds me: is ! a language extension too? It was suggested here https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md  that one should use strict constructor fields by default, but I had never seen ! before
02:38:44 <elliott> as function parameters, eys
02:38:45 <elliott> *yes
02:38:49 <elliott> as constructor fields, standard
02:38:55 <kryft> Ah, ok
02:39:14 <elliott> data C = C Int !Char Double -- then (C x y z) is like (y `seq` C x y z) compared to the bang-less version
02:39:34 <startling> I don't think I would say to use strict constructor fields by default.
02:39:46 <wagle> poor iavor..  never believed in punch cards
02:39:55 <gienah> Kaini: no I have not seen it, however I use linux with wxwidgets 2.9.4 - maybe it might help to try wx from git - seems to be some changes that might help like: https://github.com/wxHaskell/wxHaskell/commit/872312754f00f95b32dec9cc17ceab7812f79ad8
02:40:34 <kryft> elliott: All right, thanks
02:40:45 <elliott> I agree with startling.
02:40:48 <elliott> the advice is misguided.
02:40:51 <elliott> especially for something like String.
02:41:14 <elliott> or at least, the advice is a controversial point. tibbe likes strictness a lot more than most people, as ndm discovered recently :)
02:41:28 <Kaini> gienah, I guess I'll try 2.9.4 first - thanks for the hint
02:42:05 <kryft> Yes, that's another reason why I asked; I had never encountered the concept before, so I was a bit suspicious about someone suddenly telling me that one should always do this by default :P
02:42:14 <wagle> doesnt strictifying your constructors pretty much make haskell a strict language?
02:42:23 <startling> wagle, nope.
02:42:43 * wagle hopes for an explanation
02:43:01 <elliott> kryft: it's an important technique to apply judiciously.
02:43:30 <startling> wagle, if I say data A = A !Int, then f (A x) = ... is strict on the integer parameter. but f a = ... is not.
02:43:48 <startling> (as I understand it; I'm sure someone will correct me if I'm wrong)
02:44:30 <elliott> that is incorrect
02:44:37 <startling> see, I was right!
02:44:40 <riffm> Hello, how does one track source position when using `Text.ParserCombinators.ReadP`?
02:44:40 <kryft> :)
02:44:55 <arkeet> startling: strict fields has no effect on pattern matching
02:44:57 <arkeet> only on construction
02:44:58 <elliott> your two fs are effectively equivalent.
02:45:08 <elliott> (operationally not so because of the extra boxing; denotationally identical AFAIK)
02:45:13 <elliott> oh, no
02:45:20 <elliott> actually.
02:45:26 <elliott> f (A undefined) will be _|_ for the first one
02:45:31 <elliott> because it's f undefined and the match is not irrefutable.
02:45:38 <elliott> so in a sense you do get additional strictness there.
02:45:47 <arkeet> the strictness is in the constructor.
02:45:50 <elliott> right.
02:46:05 <elliott> but a can be _|_ in the second and x cannot be _|_ in the first, so there's that important distinction.
02:46:10 <elliott> with a newtype the two are identical, of course.
02:46:30 <arkeet> http://www.haskell.org/haskellwiki/Newtype
02:46:45 <startling> arkeet, oh, interesting.
02:46:49 <startling> thanks!
02:47:37 <startling> anyway, my impression is that people try to use bangs in constructors as a magic all-purpose optimization, which it isn't. You should benchmark, instead.
02:48:39 <elliott> well, for something like String it's just ridiculous.
02:48:46 <elliott> since you're being strict in, hooray, a single cons cell at most.
02:48:56 <elliott> (ok, unless you're producing the list in a really weird way)
02:49:22 <arkeet> it makes more sense to always be strict for flat things like Double
02:49:23 <wagle> i'm looking at data Tree a = Branch !a !(Tree a) !(Tree a)
02:49:27 <arkeet> haha.
02:49:32 <arkeet> wagle: that's as good as Void.
02:49:36 <doomlord> wouldn't strict everywhere remove a lot of haskells' virtues
02:50:03 <wagle> well, it has a | Leaf, which isnt strict
02:50:10 <arkeet> you didn't write one
02:50:17 <arkeet> =(
02:50:29 <wagle> i didnt want to use pastebin...
02:50:37 <arkeet> I don't understand.
02:50:42 <arkeet> why do you need pastebin to write | Leaf
02:50:57 <wagle> it was the second line of the paste
02:51:04 <arkeet> you can put it on one line.
02:51:31 <wagle> and i was pointing out the part I didnt understand of the style braindamage
02:51:59 <arkeet> lol
02:52:13 <wagle> (which is accusing me on braindamage, so that was tit for tat)
02:52:50 <startling> doomlord, yeah.
02:53:04 <arkeet> haskell has plenty of nice things besides laziness!
02:53:07 <ana_> my input is string of words. how to extract first letters of words and concat them into one word in alfabetical order
02:53:27 <wagle> how do i build an infinite tree?  (that gets garbage collected as i traverse it?)
02:53:50 <arkeet> ana_: get the words, get the first letter of each word, and sort them?
02:53:54 <wagle> why do i have to build the entire tree to make progress?
02:54:04 <doomlord> i'm tempted to look at haskell again, not sure though.
02:54:17 <arkeet> ana_: the functions  words, head, and sort may be useful.
02:54:26 <arkeet> > words " "
02:54:26 <lambdabot>   []
02:54:28 <arkeet> hm, ok
02:54:38 <arkeet> doomlord: do it =)
02:54:58 <arkeet> usually I don't advise using head, but if you can guarantee it's applied to nonempty things...
02:55:09 <arkeet> well there is a safer way to do it.
02:55:12 <arkeet> but it needs more thinking. =(
02:55:13 <ana_> arkeet: oh, thans... il try now
02:55:49 <elliott> arkeet: speaking of thinking, how's @pl?
02:55:50 <doomlord> ii'm a c++ head. Where i usually fizzle out is the record system , although little prefixes to disambiguate shouldn't be much differnet to seeing c++ code with "m_"
02:56:22 <doomlord> been using Rust recently, which i like a lot, but thats much closer to C++.
02:57:26 <ana_> > sort . concatMap head . words  $ "bla anan bllaa"
02:57:27 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[a0]'
02:57:27 <lambdabot>  Expected type: GHC.Base.S...
02:57:28 <doomlord> the other thing is i always miss c++ overloading, but have tried using traits so perhaps typeclasses wont seem so un-natural now
02:57:59 <arkeet> ana_: just map ;)
02:58:05 <ana_> > sort . concat head . words  $ "bla anan bllaa"
02:58:06 <lambdabot>   Couldn't match expected type `[GHC.Base.String] -> [a0]'
02:58:06 <lambdabot>              with ...
02:58:17 <ana_> > sort . map head . words  $ "bla anan bllaa"
02:58:18 <lambdabot>   "abb"
02:58:33 <ana_> arkeet: thank you :)
02:58:40 <arkeet> > sort . concatMap (take 1) . words $ "bla anan bllaa"   -- avoids using head
02:58:40 <lambdabot>   "abb"
02:59:01 <arkeet> but I think head is ok in this case.
02:59:30 <ana_> arkeet: ok :)
02:59:57 <arkeet> > sort . (>>= take 1) . words $ "bla anan bllaa"
02:59:57 <lambdabot>   "abb"
03:00:31 <ana_> arkeet: oh, cool :)
03:00:41 <arkeet> concatMap = (=<<)
03:00:48 <wagle> mein got!  where DID you find that style sheet?
03:01:13 <arkeet> @where style
03:01:13 <lambdabot> http://urchin.earth.li/~ian/style/haskell.html http://snapframework.com/docs/style-guide
03:02:34 <wagle> at least that one had a brain behind it
03:03:28 <wagle> sigh..
03:04:20 * wagle is bored waiting for an answer, if any, to his questions about mandatory strictness
03:04:53 * wagle scared augur off..  oops
03:06:03 <elliott> haha, lambdabot has three MemoServ memos.
03:06:07 <elliott> I wonder who sent them.
03:06:14 <wagle> complaining about tabs and the use of 80 column punch cards is on thing, but making everything strict?
03:06:23 <wagle> complaining about tabs and the use of 80 column punch cards is one thing, but making everything strict?
03:07:09 <wagle> you can fix that by adding lazy send fields that dont look until you ask
03:07:26 <wagle> s/send/sender/
03:07:35 <elliott> wagle: I'm pretty sure tibbe has a brain. :)
03:07:46 <arkeet> data Lazy a = Lazy a
03:07:59 <wagle> me too, but i'm at a loss
03:08:31 <arkeet> I can understand making fields for types that are already strict strict.
03:08:47 <arkeet> I don't think you lose anything by doing that always.
03:10:01 <wagle> what types are already strict?
03:10:13 <hape01> ()
03:10:40 <wagle> you cant bottom out ()?
03:11:01 <wagle> lemme rephrase that
03:11:03 <hape01> how would this go?
03:11:34 <arkeet> by strict I mean flat.
03:11:42 <arkeet> every type has bottom.
03:11:53 <arkeet> but some types are such that every non-bottom value is totally defined.
03:11:58 <arkeet> () and Integer are examples of such.
03:12:25 <wagle> let x = x+1 in x
03:12:46 <arkeet> that's bottom.
03:12:59 <arkeet> (when addition is strict, anyway.)
03:13:18 * wagle thinks a bit
03:13:21 <elliott> arkeet: sometimes you have an expensive computation of a flat value that you want to keep cached in your data.
03:13:25 <elliott> but don't necessarily want to compute immediately.
03:13:30 <elliott> I do that a lot.
03:13:34 <arkeet> is that so.
03:13:38 <elliott> yes
03:13:41 <arkeet> is that so.
03:13:43 <elliott> yes.
03:13:46 <arkeet> ok.
03:13:47 <elliott> it's like pure memoisation and stuff.
03:13:52 <elliott> you should try it, it's great.
03:14:00 <arkeet> is that so.
03:14:03 <elliott> yes
03:15:04 * wagle isnt sure what a type with a non-totally defined value is
03:15:28 <arkeet> e.g. [undefined]
03:15:38 <arkeet> is such a value of type [a]
03:15:44 <wagle> undefined :: ()
03:15:52 <wagle> undefined :: Int
03:15:58 <wagle> cant do those?
03:16:04 <elliott> > undefined :: ()
03:16:05 <lambdabot>   *Exception: Prelude.undefined
03:16:07 <elliott> > undefined :: Int
03:16:07 <lambdabot>   *Exception: Prelude.undefined
03:16:20 <wagle> bizarre
03:16:36 * wagle didnt know that
03:16:37 <arkeet> what is?
03:16:56 <wagle> > undefined :: [Int}
03:16:57 <lambdabot>   <hint>:1:18: parse error on input `}'
03:17:03 <wagle> > undefined :: [Int]
03:17:04 <lambdabot>   *Exception: Prelude.undefined
03:17:08 <danr> > length [undefined]
03:17:09 <lambdabot>   1
03:17:18 <wagle> thanks]
03:17:26 <arkeet> > [undefined]
03:17:27 <lambdabot>   No instance for (GHC.Show.Show t0)
03:17:27 <lambdabot>    arising from a use of `M1192452405.sh...
03:17:31 <arkeet> > [undefined :: Int]
03:17:32 <lambdabot>   [*Exception: Prelude.undefined
03:17:40 <arkeet> > fix error
03:17:41 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
03:17:52 <danr> ^^
03:18:08 <arkeet> huh? why does it have that initial " ?
03:18:10 <arkeet> > error "hi"
03:18:11 <lambdabot>   No instance for (GHC.Show.Show a0)
03:18:11 <lambdabot>    arising from a use of `M1256909668.sh...
03:18:17 <arkeet> > error "hi" :: ()
03:18:17 <lambdabot>   *Exception: hi
03:18:19 <arkeet> > fix error :: ()
03:18:20 <lambdabot>   Couldn't match type `[GHC.Types.Char]' with `()'
03:18:20 <lambdabot>  Expected type: () -> ()
03:18:20 <lambdabot>  ...
03:18:21 <wagle> me was expecting ground types to behave like the others
03:18:24 <arkeet> oh right.
03:18:27 <arkeet> because it's a String.
03:18:37 <arkeet> wagle: they do!
03:18:46 <arkeet> every type has bottom.
03:20:07 <wagle> i guess i dont understand "undefined"
03:20:37 <kryft> I see there are quite a few suggestions for improving record syntax; are any of them actually slated for inclusion in the near future?
03:21:08 <wagle> geologically?  yes!  8)
03:21:29 <wagle> otherwise, /mee cant shut up
03:22:04 <elliott> kryft: edwardk is working on it, I think.
03:22:11 <elliott> records aren't really so bad though. especially if you use lens.
03:22:23 <wagle> hahaha
03:22:43 <arkeet> it's true.
03:22:43 <wagle> which version of lens?
03:22:55 <wagle> (joke)
03:23:18 <kryft> elliott: I've heard of lens(es), but I haven't looked into it yet
03:23:24 * wagle heard edwardk had a million versions of lens or somesuch
03:23:47 <arkeet> how come there hasn't been a new version of lens on hackage forever =(
03:23:52 <startling> wagle, there's only one lens! but there's also data-lens, lens-family...
03:24:07 <elliott> my "lens" was a package name.
03:24:09 <arkeet> I want declareLenses
03:24:10 <arkeet> =(
03:24:26 <startling> wagle, anyway, re: undefined: it's "undefined = undefined"
03:24:35 <startling> ish
03:24:58 <arkeet> undefined is something that will blow up when evaluated.
03:25:11 <Kaini> @src undefined
03:25:11 <lambdabot> undefined =  error "Prelude.undefined"
03:25:12 <startling> wagle, it's in every type because that type-checks as every type
03:25:18 <startling> Kaini: shhhh
03:25:19 <wagle> startling: yeah, i knew that, sorta, but its not making sense for undefined to not populate Int
03:25:23 <arkeet> :t undefined
03:25:24 <lambdabot> a
03:25:27 <elliott> undefined does populate Int.
03:25:30 <elliott> > undefined :: Int
03:25:31 <lambdabot>   *Exception: Prelude.undefined
03:25:32 <startling> wagle, undefined /does/ populate Int
03:25:34 <elliott> that's a runtime error, not compile-time.
03:25:37 <elliott> :t undefined :: Int
03:25:37 <lambdabot> Int
03:25:42 <startling> wagle, it's just that you can't have an Int that's partially undefined
03:25:43 <elliott> > let _ = undefined :: Int in ()
03:25:44 <lambdabot>   ()
03:25:54 <startling> which is what these nerds were talking about.
03:26:06 <arkeet> who's a nerd here!
03:26:07 <arkeet> :c
03:26:13 <CADD> hey, we are al nerds
03:26:18 <arkeet> =)
03:26:18 <CADD> all*
03:26:19 <wagle> warning, dont lie to me pedagogically, you will only harm me my doing so
03:26:33 <elliott> nobody lied.
03:26:34 <mauke> challenge accepted
03:26:35 <startling> > fst (1, undefined) -- wagle, consider this
03:26:36 <CADD> wagle: who would?
03:26:36 <lambdabot>   1
03:26:39 <elliott> hah
03:26:40 <arkeet> nobody lied.
03:26:45 <elliott> at last mauke finds his perfect match
03:26:53 <wagle> [03:24:56] <startling> Kaini: shhhh
03:26:56 <CADD> lol
03:27:01 <kryft> CADD: I read "we are ai nerds"
03:27:13 <CADD> kryft: i am!
03:27:18 <CADD> kryft: i <3 ai
03:27:26 <wagle> i am slow however
03:27:29 <kryft> CADD: Oh I thought you were an ai :(
03:27:38 <CADD> got a problem? newural network!
03:27:43 <CADD> lol, i wish
03:27:52 <startling> wagle, it's a lie but not a very bad one. "error" is a special thing that GHC does that's semantically equivalent to "undefined = undefined" (in Haskell) but actually just quits the program with an error.
03:28:03 <CADD> jkjk, NN are only good in certain cases
03:28:24 <elliott> wait, what lie?
03:28:34 <startling> elliott: I said "undefined = undefined"
03:28:35 <elliott> I haven't seen any lies. if I did I would have whined annoyingly.
03:28:43 <CADD> kryft: http://turing.iimas.unam.mx/~comdig/print_article.php?id_article=23981
03:28:45 <elliott> oh. well that's denotationally true, so okay.
03:28:48 <CADD> kryft: might be interesting
03:28:59 <startling> elliott: right, that's what I said!
03:29:01 <CADD> a v12 engine that is powered by a NN. very cool
03:29:39 <wagle> > fst (undefined)
03:29:40 <kryft> CADD: Were neural nets ever really successful for something?
03:29:40 <lambdabot>   No instance for (GHC.Show.Show a0)
03:29:40 <lambdabot>    arising from a use of `M197113611.sho...
03:30:07 <CADD> kryft: i just showed you an example
03:30:11 <arkeet> wagle: you have to fix a type.
03:30:15 <arkeet> > fst (undefined :: (Int,Int))
03:30:16 <lambdabot>   *Exception: Prelude.undefined
03:30:30 <wagle> > fst (undefined) :: (Int)
03:30:30 <lambdabot>   *Exception: Prelude.undefined
03:30:30 <CADD> kryft: they were quite successful, but like most models they suffer from the curse of dimensionality
03:30:31 <mauke> > fst undefined :: ()
03:30:33 <lambdabot>   *Exception: Prelude.undefined
03:30:40 <arkeet> > fst ((undefined,undefined) :: (Int,Int))
03:30:40 <lambdabot>   *Exception: Prelude.undefined
03:30:43 <arkeet> > fst ((5,undefined) :: (Int,Int))
03:30:44 <lambdabot>   5
03:30:44 <startling> wagle: the parens don't do anything
03:30:49 <arkeet> > (5,undefined)
03:30:50 <lambdabot>   No instance for (GHC.Show.Show t0)
03:30:51 <lambdabot>    arising from a use of `M1934776257.sh...
03:30:52 <wagle> yeah
03:30:54 <arkeet> > (5,undefined) :: (Int,Int)
03:30:56 <lambdabot>   (5,*Exception: Prelude.undefined
03:31:00 <CADD> kryft: https://en.wikipedia.org/wiki/Curse_of_dimensionality
03:31:01 <mauke> oh, is extended defaulting off?
03:31:11 <wagle> how DO you do a 1-tuple?
03:31:17 <mauke> wagle: no such thing
03:31:19 <wagle> or can you?
03:31:24 <arkeet> data OneTuple x = OneTuple x
03:31:34 <kryft> CADD: Yes, I'm familiar with the concept
03:31:34 <startling> mauke, I think it's the crazy Show instance of (->) a b
03:31:47 <wagle> > data OneTuple x = OneTuple x
03:31:48 <lambdabot>   <hint>:1:1: parse error on input `data'
03:31:53 <wagle> awww
03:31:53 <CADD> kryft: yeah, it bites..
03:32:04 <startling> wagle, we call it "Identity". :)
03:32:04 <mauke> @let data OneTuple x = OneTuple x
03:32:04 <elliott> it's not that crazy.
03:32:04 <lambdabot>  Defined.
03:32:05 <elliott> > pow
03:32:05 <lambdabot>   Not in scope: `pow'
03:32:08 <elliott> um.
03:32:08 <mauke> :t OneTuple
03:32:08 <elliott> > exp
03:32:09 <lambdabot> x -> OneTuple x
03:32:11 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
03:32:11 <lambdabot>    arising from a use ...
03:32:11 <startling> > Identity 12
03:32:11 <arkeet> mauke: you forgot to derive instances =(
03:32:13 <elliott> never mind.
03:32:17 <lambdabot>   Identity {runIdentity = 12}
03:32:23 <CADD> kryft: either way, NN are only so useful.. lots of other models that are much better
03:32:25 <arkeet> startling: that's wrong, Identity is a newtype.
03:32:45 <startling> arkeet, so is the one-tuple (for performance reasons)
03:32:53 <arkeet> startling: no, I just defined one that's not!
03:32:54 <startling> it's also strict in its argument.
03:33:07 <arkeet> :/
03:33:07 <startling> :)
03:33:14 <elliott> hmm, there's a disgusting Num [a] instance in L.hs. this is arkeet's fault, isn't it.
03:33:26 <CADD> kryft: my (currently) personal favortie: https://en.wikipedia.org/wiki/Hierarchical_temporal_memory
03:33:26 <arkeet> no, that last one wasn't me!
03:33:28 <startling> > 12 :: [Char]
03:33:31 <lambdabot>   ""
03:33:41 <CADD> kryft: aaand: https://en.wikipedia.org/wiki/In_Situ_Adaptive_Tabulation
03:33:42 <arkeet> oh.
03:33:42 <elliott> @undefine
03:33:42 <lambdabot> Undefined.
03:33:42 <elliott> RIP.
03:33:45 <arkeet> I would never make [Char] a Num instance.
03:34:10 <arkeet> I would only do it for like [()] or Num a => Num [a]
03:34:10 <startling> > 1 + 2 :: [Char]
03:34:10 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
03:34:10 <lambdabot>    arising from a use of `GH...
03:34:10 <elliott> it was Num [a].
03:34:10 <elliott> with no constraint.
03:34:11 <arkeet> I would never do that.
03:34:12 <startling> wagle: anyway.
03:34:32 <wagle> > (1 + 2) :: Char
03:34:32 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
03:34:33 <lambdabot>    arising from a use of `GHC....
03:34:36 <arkeet> @let data OneTuple x = OneTuple x deriving (Eq, Show, Ord, Typeable, Data {- what else? -})
03:34:37 <lambdabot>  Defined.
03:34:38 <wagle> ahhhh
03:34:41 <wagle> good
03:34:55 <CADD> kryft: the first one is based on our biological brains. it has very interesting properties. the second one was developed as an estimator in rocket fuel studies and was applied later to ai
03:34:59 <elliott> 2013-08-16.log:04:41:47 <shachaf> @let instance Num [a] where fromInteger _ = []; (+) = undefined; (*) = undefined; abs = undefined; signum = undefined
03:35:06 <wagle> startling: i'm thinking slowly
03:35:06 <elliott> culprit identified.
03:35:08 <arkeet> =)
03:35:14 <arkeet> I think I was even there for that one.
03:35:24 <elliott> you did [()] the day before, apparently.
03:35:24 <arkeet> sounds about right.
03:35:31 <elliott> it should be Default a => Num [a], clearly.
03:35:36 <elliott> or even just use undefined.
03:36:03 <arkeet> why?
03:36:06 <wagle> > let x = undefined::Int in x
03:36:07 <lambdabot>   *Exception: Prelude.undefined
03:36:16 <arkeet> > OneTuple undefined
03:36:17 <lambdabot>   No instance for (GHC.Show.Show x0)
03:36:17 <lambdabot>    arising from a use of `M1646238322.sh...
03:36:19 <CADD> kryft: as you can see, i like ai a bit too much.. :)
03:36:21 <startling> yeah, I assumed it would be undefined.
03:36:21 <arkeet> > OneTuple (undefined :: ())
03:36:25 <lambdabot>   OneTuple *Exception: Prelude.undefined
03:36:57 <arkeet> > let f (OneTuple x) = x in f undefined
03:37:01 <lambdabot>   No instance for (GHC.Show.Show a0)
03:37:03 <arkeet> no wait.
03:37:03 <lambdabot>    arising from a use of `M153673278.sho...
03:37:18 <arkeet> > let f :: OneTuple () -> Int; f (OneTuple x) = 5 in f undefined
03:37:19 <lambdabot>   *Exception: Prelude.undefined
03:37:20 <mauke> > deriv (2 * sin) x
03:37:20 <arkeet> > let f :: OneTuple () -> Int; f (OneTuple x) = 5 in f (OneTuple undefined)
03:37:21 <lambdabot>   Not in scope: `deriv'
03:37:22 <lambdabot>   can't find file: L.hs
03:37:22 * wagle is trying to wrap brain around what the heck an partially undefined value is..  /me HAS written lazy interpreters
03:37:23 <arkeet> > let f :: OneTuple () -> Int; f (OneTuple x) = 5 in f (OneTuple undefined)
03:37:24 <lambdabot>   5
03:37:25 <mauke> > deriv (2 * sin) x
03:37:26 <lambdabot>   Not in scope: `deriv'
03:37:38 <arkeet> mauke: no ad =(
03:37:40 <mauke> > id (2 * sin) x
03:37:43 <lambdabot>   2 * sin x
03:38:06 <startling> wagle, well fst (1, undefined) never evaluates 'undefined'.
03:38:26 <startling> so it's all good as far as haskell is concerned.
03:38:26 <wagle> sure
03:38:39 <elliott> wagle: a partially undefined value is one that can be evaluated to WHNF without running into _|_, but not NF.
03:38:42 <arkeet> > let loop = loop in loop
03:38:43 <lambdabot>   No instance for (GHC.Show.Show a0)
03:38:44 <lambdabot>    arising from a use of `M529525396.sho...
03:39:07 <arkeet> @let loop = loop
03:39:07 <lambdabot>  .L.hs:156:8:
03:39:07 <lambdabot>      Ambiguous occurrence `loop'
03:39:07 <lambdabot>      It could refer to either ...
03:39:07 <arkeet> @let looop = looop
03:39:07 <lambdabot>  Defined.
03:39:07 <wagle> unless you follow the style sheet and *SOMEHOW* strickufy 2-tuples
03:39:07 <arkeet> > fst (1, looop)
03:39:07 <mauke> :t loop
03:39:07 <lambdabot>     Not in scope: `loop'
03:39:07 <lambdabot>     Perhaps you meant `looop' (imported from L)
03:39:07 <lambdabot>   1
03:39:07 <startling> wagle, this is actually one of the reasons 'undefined'-like things are so theoretically ugly -- if it weren't for 'undefined', haskell would have the same semantics evaluated lazily or strictly.
03:39:40 <arkeet> but there's a lot of nice theory!
03:39:48 <wagle> yeah, I rremember Brian Huffman thinking about that
03:39:56 <CADD> startling wagle: undefined also make haskell generally unsuitable for theorm proving as well.
03:40:28 <arkeet> there's even a thing that says you can pretend undefined doesn't exist when reasoning about your program.
03:40:28 <CADD> arkeet: right, just dont use it.. :)
03:40:29 <wagle> he produced isabelle/holcf, I imagine he has some solution
03:40:46 <CADD> arkeet: although it is nice if you are just trying to write out some types and match them up before you flesh out the func
03:40:53 <arkeet> this one http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.59.8232
03:41:01 <startling> CADD: sure.
03:41:42 <CADD> startling: but if you dont use undefined, you should be fine since haskell is such a nice lang anyway
03:41:58 <arkeet> or http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html
03:42:03 <CADD> startling: but you probably alreasy know that :)
03:42:03 <startling> wagle, you could do termination-checking, but then you lose turing-completeness.
03:42:57 <CADD> wagle: which is acceptable if you are doing theorm proving, but not general computing
03:43:10 <wagle> I cant speak for him since 10 years ago, but i imagine he's worried about os's these days that dont terminate, but thats just speculation
03:43:13 <startling> CADD, nah.
03:43:16 <CADD> wagle: well, not just acceptable. but neccesarry
03:43:34 <CADD> startling: hmm?
03:44:27 <wagle> cant isabelle hol reputedly handle non-termination?  I vaguely recall something about that
03:44:29 <CADD> wagle: iirc, yes
03:45:06 <startling> CADD, languages like idris say that termination-checking is OK for general computing.
03:45:06 <startling> wagle, well, you need it for any sort of proof language
03:45:06 <CADD> startling: oh yeah, you are completely right
03:45:36 <startling> wagle, otherwise you can just say "let f = f; f : proof_of_anything_I_want;"
03:46:52 <CADD> wagle startling: http://biblioteca.universia.net/html_bura/ficha/params/title/certification-of-nontermination-proofs/id/56894190.html
03:46:55 <CADD> may be useful?
03:47:07 <wagle> i dont think thats necessarily true, but I can't proof/support/etc that claim..  i did notice that one math author treated limits as infinite definitions, so i wonder
03:48:16 <wagle> i hope i remember to transfer my bookmarks to my man computer when its back up
03:48:25 <wagle> i hope i remember to transfer my bookmarks to my main computer when its back up
03:48:42 <CADD> wagle: if you use firefox, there is a sync functionality
03:49:12 <wagle> it doesnt work, tried a couple times, had to restore from backup after it destroyed things
03:49:19 <startling> wagle, you can do infinitish things to some extent, but you can't really check them -- it's the halting problem.
03:49:22 <lasticot> In Haskell, is it common to define recursive datatypes similar to linked lists?
03:49:45 <wagle> tried both the firefox thing and xmarks
03:49:45 <startling> check them *in general , that is
03:49:45 <CADD> wagle: huh that suck, ive never heard of any problems. havent done it myself though
03:49:46 <CADD> lasticot: yup, all the time
03:49:58 <startling> lasticot: It depends what you're doing, but it's not uncommon.
03:50:24 <wagle> he might mean with destructive updates
03:50:31 <lasticot> CADD, startling: ok ok
03:51:42 <CADD> startling: speaking of the halting problem: http://esolangs.org/wiki/TwoDucks
03:51:43 <lasticot> CADD, startling: just wanted to make sure that I hadn't missed a feature of Haskell that made it unnecessary for some reason
03:51:49 <shanse> @where paste
03:51:50 <lambdabot> http://lpaste.net/new/haskell
03:51:59 <CADD> lasticot: nope, sounds like you are on the right track
03:52:35 <CADD> @def List = Nil | Cons List
03:52:35 <lambdabot>  Parse failed: Parse error: |
03:52:44 <CADD> eh?
03:53:28 <startling> lasticot: it turns out that [] is good enough for a lot of uses
03:54:21 <startling> CADD: heh
03:54:22 <CADD> @def List = Nil | Cons List
03:54:22 <lambdabot>  Parse failed: Parse error: |
03:54:24 <CADD> @def data List = Nil | Cons List
03:54:25 <lambdabot>  Defined.
03:54:26 <nicoo> wg #Clampgirls-fansub
03:54:29 <CADD> thar we go
03:54:43 <lasticot> CADD, startling: yes, that's what I'm starting to consider, well I'll finish the way I started and see if there is a better way.
03:55:09 <CADD> startling: isnt that esolang pretty cool?
03:55:14 <CADD> lol
03:55:33 <CADD> @@ lasticot @def data List = Nil | Cons List
03:55:33 <lambdabot> Plugin `compose' failed with: Unknown command: "def"
03:55:39 <CADD> *sigh*
03:55:49 <mauke> CADD: why do you keep trying to use @def?
03:55:51 <wagle> shouldnt that me @def data List = Nil | Cons List List?
03:55:58 <CADD> mauke: what should i use?
03:56:02 <mauke> a command that exists
03:56:10 <CADD> mauke: ohlol
03:56:28 <CADD> wagle: and yes, im just messing around
03:56:35 <CADD> mauke: but it said it was defined
03:56:46 * hackagebot HueAPI 0.1.1 - API for controlling Philips Hue lights  http://hackage.haskell.org/package/HueAPI-0.1.1 (SjoerdVisscher)
03:56:56 <mauke> yes, because spelling correction kicked in and turned it into @let
03:57:10 <CADD> mauke: oh, thank you for the explaination
03:57:47 <mauke> @quite
03:57:48 <lambdabot> Maybe you meant: quote quit
03:57:57 <CADD> that is a very specific package there..
03:58:37 <mauke> hue hue hue
03:58:37 <CADD> XD
03:59:10 <mauke> I know why it's called TwoDucks
03:59:27 <CADD> mauke: enlighten me
03:59:58 <mauke> http://mauke.hopto.org/stuff/img/lol,internet/paradox.jpg
04:01:23 <mauke> (if that wasn't clear: pair-o'-ducks)
04:02:48 <wagle> meh, twoducks doesnt output anything for a program that doesnt halt
04:02:49 <CADD> mauke: sorry had to take my dog outside, she was whining
04:03:02 <CADD> mauke: huh, im still lost. lol
04:03:15 <CADD> mauke: ooooh!
04:03:17 <CADD> mauke: lo
04:03:18 <CADD> l
04:03:33 <CADD> thats punny
04:04:18 <CADD> had to say it a could of times to myself before it got it
04:04:55 <CADD> what are those words called? i think its like a distructive word?
04:04:57 <wagle> peridox is when i get two phds
04:05:03 <CADD> lol
04:05:29 <CADD> or what 4chan does to people, but twice
04:06:17 <CADD> *sigh* 4chan..
04:09:23 <wagle> >let x = undefined :: Int in 1
04:09:35 <wagle> > let x = undefined :: Int in 1
04:09:36 <lambdabot>   1
04:11:11 * wagle wonders at the point made about Ints and () and other "ground" (>) values vs undefined/bottom
04:11:14 <wagle> too late?
04:13:46 <wagle> hmm..  maybe this is it:
04:14:11 <wagle> > let x = 1 + undefined::Int in 2
04:14:12 <lambdabot>   2
04:14:19 <arkeet> > let !x = undefined :: Int in 1
04:14:20 <lambdabot>   <hint>:1:5:
04:14:20 <lambdabot>      Illegal bang-pattern (use -XBangPatterns):
04:14:20 <lambdabot>      ! x
04:14:57 <arkeet> wagle: it doesn't matter what you let x be if you don't use it on the right side, because x will never get evaluate.
04:14:58 <arkeet> d
04:15:12 <CADD> arkeet: thank you, was just about to say that
04:15:29 <wagle> right..  someone claimed int and () were strict
04:15:48 <CADD> wagle: i dont think so
04:15:54 * wagle scans again
04:16:21 <elliott> ugh, probably BangPatterns should be on.
04:16:26 <elliott> but adding it requires restarting lambdabot.
04:16:37 <arkeet> you should make it not require restrating!
04:16:40 <arkeet> restarting.
04:16:44 <CADD> wagle: https://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Non-Strict_and_Strict_Languages
04:16:59 <elliott> arkeet: you can code that after @pl works
04:17:11 <arkeet> what's wrong with @pl, anyway?
04:17:54 <arkeet> (let aside *using* @pl)
04:18:03 <mauke> > read "()"
04:18:05 <lambdabot>   No instance for (GHC.Show.Show a0)
04:18:05 <lambdabot>    arising from a use of `M208730977.sho...
04:18:12 <mauke> why is extended defaulting off?
04:18:14 <elliott> well, it doesn't work.
04:18:15 <arkeet> also yeah, is extended defaulting off?
04:18:15 <wagle> i think this confused me, but i didnt pay enough attention afterwards:
04:18:19 <wagle> <arkeet> I can understand making fields for types that are already strict strict.
04:18:19 <wagle> <arkeet> I don't think you lose anything by doing that always.
04:18:20 <elliott> huh.
04:18:21 <elliott> ugh
04:18:23 <elliott> maybe it is
04:18:28 <arkeet> @pl o f g x = f (g x)
04:18:28 <lambdabot> o = (.)
04:18:44 <arkeet> looks working to me.
04:19:21 <elliott> @flush
04:19:21 <elliott> @quit
04:19:52 <elliott> oops, I forgot to add BandPatterns.
04:19:53 <elliott> @quit
04:20:15 <wagle> ok, my sense of haskell is back to the beginning, where I understand everything except the admonition in a style sheet to "always be strict"
04:20:15 <arkeet> add ad too
04:20:19 <arkeet> and uh
04:20:21 <arkeet> TupleSections
04:20:25 <arkeet> and uh
04:20:28 <FreeFull> @pl x = x
04:20:34 <lambdabot> x = fix id
04:20:40 <arkeet> wagle: ignore it
04:21:20 <wagle> but i gotta know why..  8)
04:21:21 <FreeFull> @pl x = x x
04:21:21 <lambdabot> x = fix (join id)
04:21:21 <arkeet> that's a type error.
04:21:21 <FreeFull> It is
04:21:21 <arkeet> and pl takes it anyway.
04:21:21 <mauke> > deriv sin x
04:21:21 <arkeet> cool
04:21:21 <FreeFull> @pl doesn't care about types
04:21:22 <lambdabot>   Not in scope: `deriv'
04:21:25 <arkeet> =)
04:21:27 <lambdabot> doesn't care about types
04:21:31 <arkeet> haha
04:21:53 <wagle> @pl i lied
04:21:53 <FreeFull> @pl ACTION licks everyone
04:21:53 <lambdabot> i lied
04:21:59 <lambdabot> (line 1, column 1):
04:22:05 <lambdabot> unexpected "\SOH"
04:22:11 <lambdabot> Plugin `pl' failed with: <<timeout>>
04:22:33 <wagle> wow
04:23:59 <wagle> elliott: you increased the timeout to 20 seconds?
04:23:59 <FreeFull> @pl a = a = a
04:24:04 <lambdabot> (line 1, column 8):
04:24:10 <lambdabot> unexpected " "
04:24:16 <lambdabot> Plugin `pl' failed with: <<timeout>>
04:24:23 <FreeFull> @pl a = let a = a in let a = a in let a = a in let a = a in a
04:24:30 <lambdabot> a = fix id
04:24:32 <wagle> ok ok, we get it
04:24:36 <elliott> uh, I don't know.
04:24:40 <elliott> I just changed it from 5 to 10 or something.
04:24:43 <elliott> where 5 meant three seconds.
04:24:49 <FreeFull> @pl a = let b = a in b
04:24:50 <wagle> hahahaha
04:24:50 <arkeet> why's it so slow =(
04:24:55 <elliott> I forget the unit and I can't do arithmetic.
04:24:56 <lambdabot> a = fix id
04:25:11 <arkeet> weren't you going to make a new @run?
04:26:04 <wagle> oh..  its in a million different channels, maybe it multiplexes itself to death
04:26:51 <CADD> wb mauke
04:27:09 <elliott> arkeet: yes
04:27:10 <mauke> |assuming
04:27:12 <CADD> all better?
04:27:34 <wagle> yeah, its entering and leaving the other channels (I imagine) frequently
04:27:39 <CADD> ouch
04:27:40 <arkeet> elliott: when are you going to do it?
04:27:55 <elliott> arkeet: well, I did most of it.
04:28:01 <FreeFull> @pl a = b
04:28:01 <lambdabot> a = b
04:28:02 <elliott> now all that's left are the annoying fiddly parts that are awful to do.
04:28:06 * wagle starts the chant
04:28:11 <elliott> also I don't have the code on this machine. in fact this machine is running Windows
04:28:43 <wagle> omg!  lambdabot is tainted!  shriek!  etc etc
04:29:12 <FreeFull> @pl a = a * a
04:29:12 <lambdabot> a = fix (join (*))
04:29:20 <FreeFull> Ok, I'll stop now
04:31:24 <arkeet> @@ @let @where listnat
04:31:25 <lambdabot>  Defined.
04:31:28 <arkeet> > 5 :: [()]
04:31:32 <lambdabot>   [(),(),(),(),()]
04:31:45 <wagle> eh what?
04:31:50 <arkeet> > let a = 1 + a in a :: [()]
04:31:53 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
04:32:27 <wagle> oh
04:32:47 <arkeet> @where listnat
04:32:47 <lambdabot> instance Num [()] where fromInteger x = replicate (fromInteger x) (); (+) = (++); (-) = (\\); (*) = liftA2 (\x y->()); abs = id; signum = take 1
04:32:58 <arkeet> hm,
04:33:15 <wagle> the bc grog shouts: "types are values!"
04:33:55 <arkeet> oh wow I should be in bed. bye
04:34:14 <wagle> me too, but who's counting
04:34:56 <elliott> that (*) is ugly. :(
04:35:12 <wagle> infinite types?
04:35:44 <wagle> how the heck did that work?
04:36:21 <wagle> > tail :: [()]
04:36:22 <lambdabot>   Couldn't match expected type `[()]' with actual type `[a0] -> [a0]'
04:37:04 <merijn> wagle: That's a type error, tail is a function, not a list
04:37:42 <wagle> > 20 :: [()]
04:37:45 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()]
04:38:11 <wagle> and the > let a = 1 + a in a :: [()]
04:38:17 <merijn> Wow, that is an awful num instance
04:38:35 <wagle> oh, you didnt see that one
04:38:39 <wagle> > let a = 1 + a in a :: [()]
04:38:42 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
04:38:59 <merijn> Yes, but those things are well-typed
04:39:18 <merijn> Though almost as vile as some of the old Caleskell we had in lambdabot
04:39:28 <wagle> sure, but on a finite machine?
04:39:58 <merijn> wagle: What's the problem with running that one a finite machine?
04:40:04 <wagle> i should have gotten the same with tail
04:40:09 <merijn> No
04:40:12 <merijn> :t tail
04:40:13 <lambdabot> [a] -> [a]
04:40:24 <merijn> :t tail :: [()] -- type error
04:40:25 <lambdabot>     Couldn't match expected type `[()]' with actual type `[a0] -> [a0]'
04:40:25 <lambdabot>     In the expression: tail :: [()]
04:40:26 <wagle> :t 5
04:40:27 <lambdabot> Num a => a
04:40:41 <merijn> > tail 5 :: [()]
04:40:45 <lambdabot>   [(),(),(),()]
04:40:58 <merijn> > let a = 1 + a in tail a :: [()]
04:41:01 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
04:41:07 <merijn> No problem :)
04:41:44 <merijn> > 5 :: [Bool]
04:41:45 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Bool])
04:41:45 <lambdabot>    arising from the literal ...
04:42:39 <wagle> > 5 :: [True]
04:42:39 <lambdabot>   Not in scope: type constructor or class `True'
04:42:39 <lambdabot>  A data constructor of that ...
04:42:39 <merijn> wagle: basically, someone implemented "instance Num ([()]) where fromInteger i = replicate i (); ..."
04:43:02 <merijn> wagle: "5 :: [True]" is a syntax error, because True is not a type* but it is in a type signature
04:43:03 <wagle> 5 is the 5th element, was thinking tail would be the first tail
04:43:17 <wagle> > 5 :: [true]
04:43:17 <lambdabot>   No instance for (GHC.Num.Num [true1]) arising from the literal `5'
04:43:17 <lambdabot>  Possibl...
04:43:17 <merijn> * - yes, I'm aware of DataKinds, thank you very much
04:43:27 <merijn> wagle: You are typing nonsense
04:43:43 <wagle> you werent here
04:43:44 <merijn> wagle: The syntax is "<expr> :: <type>"
04:43:51 <merijn> [True] and [true] are not types
04:44:09 <wagle> ok
04:44:58 <wagle> the question is why/how/etc <expr> ::= <expr> :: <type>
04:44:58 <merijn> wagle: The thing that is happening is that "5" is a polymorphic literal, the type annotation is just telling GHC which *exact* instance of Num to pick
04:45:04 <merijn> :t 5
04:45:06 <lambdabot> Num a => a
04:45:24 <wagle> i alreasdy did that one
04:45:26 <merijn> wagle: So 5 can be any 'a' that is an instance of Num
04:46:16 <merijn> wagle: "5 :: [()]" annotates the type of '5' as being '[()]' which is a type error if the "[()]" is not an instance of Num, but works if "[()]" *is* an instance of Num
04:46:42 <merijn> wagle: In "normal" haskell, there is no Num instance for "[()]" but someone added one in lambdabot for shits and giggles, it seems
04:47:06 <wagle> what was surprising was that let x = x + 1 was an "infinite number"
04:47:40 <merijn> wagle: The reason that works is because the definition for (+) of [()] is apparently lazy in it's second argument
04:47:40 <wagle> so i you came in to see me feebly try tail
04:48:27 <wagle> which didnt work, just because
04:48:44 <merijn> i.e. the definition of (+) is probably "[] + x = x; (():rest) + x = () : (rest + x)"
04:49:20 <merijn> Since that definition never tries to pattern match on 'x', it doesn't matter whether x is undefined or infinite
04:49:27 <merijn> I would actually expect this to work too:
04:49:39 <merijn> > (5 :: [()]) + undefined
04:49:42 <lambdabot>   [(),(),(),(),()*Exception: Prelude.undefined
04:49:48 <merijn> Whoo!
04:49:50 <merijn> I guessed right
04:50:08 <wagle> strict
04:50:47 <wagle> if its strict, though, how did let x = x + 1 work?
04:50:50 <elliott> > let x = x + 1 in x :: [()]
04:50:56 <elliott> it didn't
04:50:57 <lambdabot>   mueval-core: Time limit exceeded
04:51:02 <elliott> you did 1 + x
04:51:04 <elliott> very different
04:51:28 <wagle> buh
04:51:29 <merijn> wagle: Do you see how "(1+)" in case of [()] becomes "(():)"?
04:51:49 <merijn> "let a = 1 + a" this is the same as
04:51:57 <wagle> yeah, I know computers and people
04:52:01 <merijn> > let units = () : units in units
04:52:02 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
04:54:20 <wagle> i'm just amazed that they/him/her/it decided to go looking for +
04:54:37 <wagle> but its a good joke
04:55:27 <elliott> @undefine
04:55:28 <lambdabot> Undefined.
04:55:31 <elliott> let's not leave that intasnce lying around.
04:56:19 <merijn> Clearly it should have been "instance Monoid a => Num ([a]) where"
04:56:24 <wagle> maybe lambdabot should spring clean things after 15 minutes or so?
04:57:10 <wagle> in your copious spare time, of course..
04:57:40 <wagle> (actually more a theoretical question than a job/pain list)
04:57:42 <mauke> > 1 2 3
04:57:43 <lambdabot>   Could not deduce (GHC.Num.Num t)
04:57:43 <lambdabot>    arising from the ambiguity check for `e...
04:59:32 <merijn> num-instances has been gone from lambdabot for a while, so no more shennanigans with that
04:59:51 <wagle> elliott: did you notice that lambdabot is crashing a lot in (say) haskell-in-depth?
05:00:22 <elliott> crashing howso?
05:00:27 <elliott> I'm not in #haskell-in-depth.
05:00:33 <wagle> leaving and coming back
05:01:18 <mauke> > 1 2 (3::Int)
05:01:21 <lambdabot>   1
05:01:27 <mauke> you were saying?
05:02:54 <merijn> heh?
05:03:10 <merijn> Did someone decide to readd it?
05:03:20 <mauke> yes. I.
05:16:14 <fylwind> > x where x = x
05:16:15 <lambdabot>   <hint>:1:3: parse error on input `where'
05:16:34 <fylwind> > let x = x in x
05:16:42 <lambdabot>   mueval-core: Time limit exceeded
05:19:13 <FreeFull> > let x = y in x where x = y
05:19:14 <lambdabot>   <hint>:1:16: parse error on input `where'
05:21:48 * hackagebot SimpleH 0.9 - A light, clean and powerful Haskell utility library  http://hackage.haskell.org/package/SimpleH-0.9 (MarcCoiffier)
05:23:35 <drayevarg> Char.toUpper "test"
05:23:58 <drayevarg> map Char.toUpper "test"
05:24:40 <wagle> need the >
05:24:51 <wagle> > Char.toUpper "test"
05:24:52 <lambdabot>   Not in scope: `Char.toUpper'
05:25:09 <wagle> well, there's that too
05:25:17 <drayevarg> i tried it in ghci and it told me (basically) to install haskell98
05:25:48 <wagle> use import Char?
05:26:07 <wagle> (i'm not sure)
05:26:15 <drayevarg> "It is a member of the hidden package 'haskell98-2.0.0.2'.
05:26:27 <wagle> my normal machine is off line, i'm helpless
05:26:52 <mr-> > map Data.Char.toUpper "help"
05:26:53 <lambdabot>   "HELP"
05:27:03 <wagle> thanks
05:27:04 <drayevarg> thanks :)
05:27:09 <mr-> sure ;-)
05:29:57 <mr-> drayevarg: looks like you are reading something very old, though
05:29:57 <drayevarg> yeah, it seems like
05:29:57 <drayevarg> some of the examples don't work
05:29:57 <wagle> when was it written?
05:29:57 <drayevarg> 2002-2006
07:24:12 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
07:24:12 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
07:24:12 --- names: list (clog roboguy_ JobV tufflax dgpratt kcj watermind Croms bowas109 revtintin mdhopkins Banistergalaxy laar Kiryx ozgura xymox ptshih kurisumasu arpunk boblu dialelo jackp danharaj latermuse manung Alpha64 tharper flebron copumpkin jkoshy fridim__ gehmehgeh _justjust Jeanne-Kamikaze uu1101 rnons happy4crazy Mowah yyyyy walter nilsi OlegYch maksbotan maxter oleo S_J Argue_ Taneb guest82 chidy bogdanp fylwind k00mi voxpopuli jmbto ulfdoz tpsinnem guampa kwos nooodl)
07:24:12 --- names: list (cognominal aegis__ ksf_ jophish_ Eduard_Munteanu ntus1017 AgentM jbracker Reite hashcat Luser kier visof derelm tomprince MindlessDrone perspectival MrFahrenheit xinming q66 weie_ merijn PatrickRobotham phyrex1an mauke kstuart lambdabot nova_ eldariof shintah yacks Digit edwardk kav allsystemsarego jml lemao Thra11 xunie-laptop sbahra_ hrehf sinclair|net jj515 ghorn__ augur hajimeho_ t7 hape01 Sculptor kuribas soulrain shrekster whaletechno amatsu kludge`)
07:24:12 --- names: list (wole DolphR lq heath torwegia wolfnn bitonic seschwar gg7 matheus23 kloplop321 gautamc drayevarg pantech SoupEvil pygospa Paprikachu _d3f Alice3 mellum azm Mon_Ouie goldkatze desc|zenbook nneko001__ DanielDiaz BMeph Kaini io2 kerrick zammy m3ga solrize jesyspa shashank cdidd zxq9 simion314 Krakarn rfw nwf ParahSailin Jesin-phone otto_s_ sellout- preflex tabemann dolio flippo shanse scshunt jrslepak gnuvince synonymous araujo Kabaka a_ jbauman hiratara Ralith)
07:24:13 --- names: list (RichyB parcs_ bscarlet apaku nuttycom [swift] Rarrikins milessabin kevinqcs xplat predator217 jaimef sxn cdk tuxit threesome TheFuzzball Sgeo favonia Sonderblade tg DrCode zacts Twey chrisdotcode_ jdegoes jdoliner bytbox LAMMJohnson tertl3 Internet13 perlite solancile RevJohnnyHealey TallerGhostWalt joaopizani b2coutts Mortomes_ isomorphic morolin structuralist transfinite Pengoo Tinned_Tuna drdo conal mescalinum chrisdone brandonw nominolo mshroyer ysuzuki)
07:24:13 --- names: list (yogurt_truck gbarboza [[zzz]] Philippa miloshadzic wtw knsd fridim_ jssanders Shou `^_^v nik_89 linux_noob_666 bennofs ghorn NimeshNeema gdoteof dgvncsz0f davorak jeff_s1 joneshf-laptop neektza1 seanparsons ido Arnoldz geoffh raft ssbr kubrat meretrix byorgey DexterLB amathew __main__ mkiefel Excedrin qrlr caligula MoALTz Egbert9e9 waterlaz shachaf maoe f8ld Boreeas latro`a_ AntiSpamMeta hvr gienah adnap n00dle rndm c_wraith IanKelling mrowe_away Shin-LaC)
07:24:13 --- names: list (fgomez Natch ormaaj alang shutdown_-h_now arun torkjak burp_ doshitan vili ecube kooga zorzar MK_FG edk cl_away Morgawr sj4nz mceier WhereIsMySpoon ft brixen JaRoel|4d xenophon solirc dju CareBearemcho cods zentrification thorsten` tudalex lattenwald leifw NeatBasis vpm swistak35 nodeless_ fran tehroflmaoer saep od- ismlages stvc mgsloan dmwit smarter FreeFull apples gthorslund nhanho knyppeldynan Riussi mikecaruso albel727 relrod Hafydd dino- tntc lusory)
07:24:13 --- names: list (levi [mth] idoru Guest83359 ggreg Noldorin pikhq ezrios zoktar srcerer epta Veltas Bwild Ycros brisbin thebnq mikee niko Excureo ciaranm go|dfish seantallen jaspervdj dkasak Amadiro yriw joachifm eacameron s4muel milli PHO_ maurer mmaruseacph2 geekosaur idnar s4msung kakos ekyo wormphlegm noam fijimunk1i n-dolio eyck fxrh zomg mlh Belgarion0 DT`` wchun hive-mind supersym alexsdutton Work_jack mannyv fikusz fryguybob hiptobecubic SHODAN dsantiago tero-)
07:24:13 --- names: list (Polarina k4nar Khisanth Fuuzetsu otulp frontendloader lunarjar jml_ sclv Deewiant wilfredh bentrevor chexxor Vertue idnaria Xorlev nullcone alszar asjo ninzine Iceland_jack epsylon plucas zrot dwierenga markov_twain ParahSail1n xye machisuji _flow_ Jaxan mimi_vx ktosiek crs_ plhk McManiaC dsirenko_ popx ninegrid Darkflux troydm dymatic sbahra Vorpal bergey shajra maximumsteve thetallguy Athas mlamari mee IbnFirnas Soft ggherdov destiny zebr killy9999 jroesch)
07:24:13 --- names: list (ski_ jmcarthur Phlogistique sleepybug aleator sajith Lemmih osfameron udoprog joogi barrucadu fry mjrosenb mel- identity rgrinberg gseitz wting tych0 lpvb carter cheezey hfaafb nonconve1gent flori_ aford mantovan1 Bynbo7 Kuba _br_ purefn xenocons ahihi ofan \q sanjoyd hamishmack jzl bergmark vmeson chirpsalot s00pcan Kuraitou MrRacoon bbee Cerise dreixel shepheb tavelram Nshag dabradley jzelinskie iteratee mjo iemejia SLi stelleg absence katis redjohn Fubar^)
07:24:13 --- names: list (tahu Vq Tene wollw doomlord_ mephx akiress thomassgn bbloom gereedy reactormonk bduc sirspazzolot Guest63538 Dtgr schlumpi charlesofarrell_ tunixman satshaba1 satshabad udevd tarmo osnr jcp mgaare counterstrike44 vnz mbrock Draconx mak` stevejb Boney canissimia MouseTheLuckyDog Tarential rhodesd mstksg sordina andrewsw cmears derekv shergill jonsterling fabjan profmakx melter pjstadig zenoli djahandarie mcbonz sunfun dlundy sababa hellome Kyzza kekimmo)
07:24:13 --- names: list (DarkFox KyleCloud og canta zq haasn dan64 krakrjak_ ousado Pad^ ssttudder shelf janinge dropdrive pcapriotti ircbrowse jackhill junsuijin solution Fuco davean theorbtwo noddy MetaCosm td123 blakesmith monochrom tvaalen c_14 de-Vri-es rmyers k0ral MOMI daira b0c1 tauntaun ByronJohnson aloiscochard edkk ErkiDerLoony jang1 bartavelle aoh arnsholt Nik05 M-ou-se tomh- peddie_ cynick taruti sdx23 arkx so mokus fergusnoble Spaceghost peddie Igloo drbean gpampara)
07:24:13 --- names: list (tsou callen rasmusto jlaire joefiorini davidt_ ceii tensorpudding simon anon123 ccxCZ Tehnix felipe_ Adios neena bicgena uranther bsmt nkpart Liskni_si tomaw rpenguin_ hpc aristid guerrilla iulian dpwright KitB tulcod sgso ivan` jlamothe adimit alpounet marienz yam cajla palmje mrshoe Ke FireFly tridactyla SegFaultAX BigEndian yiannis_t Maxdamantus wunki `0660 vsayer Nimatek Enigmagic twn dogmaT dexter1 tomejaguar adlan annulus- orospakr gambogi Squid_Tamer)
07:24:13 --- names: list (munro Khady robinbb-freenode oldmanstan Adeon DustyDin1o leroux bobry demolithion dyreshark mmathis gilbertw1 lenstr Will| Jello_Raptor vehk ab9rf stass Gracenotes threedaymonk Sunhay_ DigitalKiwi acfoltzer cschneid qz mietek lightquake mortberg Raynos tylergillies_ stepcut inr Cale valdyn dqd colah jyyou xnyhps anhall machisuji_ mike2 Tekerson KaneTW arkeet kloeri Odd_Bloke FUZxxl mxf divarvel froztbyte _janne akraut etherfreak vvv drewr Erstarrung jrib)
07:24:13 --- names: list (zero7 sevvie hdevalence flazz_gone Raynes quicksilver bd__ Bigcheese d3lxa si14 alej upgrayeddd lopex dcoutts pettter qwandor hiyakashi tdammers Baughn_ michaf etrepum spligak hpd seneca eL_Bart0 puzza007 chickenflu warpy ortmage akahn xorox90_ lokydor chrisbuchholz talzeus_ shennyg vivekrai Ghoul_ jodaro_ gdeest ehd DrSyzygy joeyh kini Licenser jhh banjiewen dthibodeau mykhal blz37 palaga Eridius sepeth farn yano brett bcoppens Martty knz cmsd2 neurocyte)
07:24:13 --- names: list (ivan\ s_quark arbn petantik bogner electrogeek BrianHV newsham earthy vobi bezik edwtjo mero vvein levitation[A] koala_man JustAPerson nanothief_ Th0mas wto linduxed noplamodo thorkilnaur__ averell nxorg8 thirsteh mlinksva kxra dan_johnsin SaBer zerokarmaleft myme1 otterdam ocharles aess saiam elgot mechairoi Valodim hackagebot Svedrin `bps liori kshannon h_chiro_ stiell alexander__b int-e sm Tribal flux kaw ReinH joar bogner_ jamwt dmp1ce yeltzooo necroyeti)
07:24:13 --- names: list (willb1 Dashkal Chousuke nlogax Starfire_ mrd_ Ulrar davd tessier b52 asante deavid elliott poucet XMunkki_ bqp ericmj pharaun cruxeternus sp3ctum Clint mendez Dybber magicman anders^^_ isomorphismes wagle sipa pnielsen Kinnison tamiko OrangeDuck wavewave @ChanServ dumbhat LeaChim chrra mattp__ lulf Proteumus Rembane pfoetchen prophile sunnavy_ finnrobi pi8029 TML ve genisage wereHamster gridaphobe klugez ion dario^CIP Rutger`_ cross danr jliikka solarus nicoo)
07:24:13 --- names: list (jkpl liszt petanqk opqdonut stomp SuperNoeMan bxc rs0 Kneiva TheSpectre Sagi kryft cjay tromp_ Spockz arcatan def-lkb zaiste aszlig CindyLinz Jaak ibid bitraten Reisen jayne Walther ipuustin taylorgb geal inarru Ptival gds betawaffle majoh robbert mikeplus64 lpsmith Draggor horlicks zeiris_ notdan pyykkis mononofu lahwran jix copton almondjelly kosmikus johnw b_jonas Ezku SirChurchill anachron Eliel mkrull Zesler confound_ luminous macron xaimus Yaniel ejls)
07:24:13 --- names: list (Watcher7 dsp_ bgamari aforemny Blkt yan_ Nickeeh fall_ greymalkin zw01 nikola hpaste ClaudiusMaximus sohum Edoxile raid pr aninhumer ziman Razz mr- ryanakca thoughtpolice dilinger_ malorie_ pqmodn_ ttm kaol CosmicRay mornfall schoppenhauer Ornedan hiredman joelteon briden liyang guymann supki Zariel skypers Sourceless bind companion_cube ChongLi Yawgmoth_ bholst_ tswett mami ehamberg statusfa1led mollerstrand ernst shiona fayden jlouis Maior mviljamaa lispy)
07:24:13 --- names: list (Saizan luite saurik dixie_ zenzike_ ent Plex- agundry drmegahertz suiside othiym23 brainproxy rce brendan Cryovat Brando753 integral JPohlmann duairc jlewis BlastHardcheese ahf a11235 mux bstrie slobo_ deggis cow-orke1 kranius Gothmog_ kqr1 zaphar_p1 theDon Elision thetallguy2 mixi Laney gbluma_ MasseR peltchu Hardolaf gemelen phryk saiam^ dustinswan Mayzie tippenein)
07:24:16 <merijn> skypers: Writer is not really suitable for interleaving actions and logging in a traditional logging to file sense
07:24:42 <merijn> skypers: However, if you want to do "run some IO actions and have a log of the things you did", then it is
07:24:44 <skypers> merijn: I don’t want logging to file
07:24:58 <skypers> I want tracing actually
07:25:18 <skypers> Writter is perfect for that isn’t it?
07:25:20 <merijn> skypers: For debugging purposes?
07:25:30 <skypers> hhm
07:25:44 <skypers> yeah, and for anyone who’d like to be sure some stuff is ok
07:25:54 <merijn> skypers: It will help if you can be more specific about your usecase, as the answer changes depending on this
07:26:07 <skypers> merijn: hm
07:26:13 <merijn> For example, for tracing code for debugging, we have the lovely Debug.Trace
07:26:36 <skypers> I want to run IO action that might fail, then in that case I’d get a monoid, representing the trace of the error
07:26:47 <skypers> maybe I need to combine WritterT and EitherT?
07:27:12 <skypers> or just MaybeT?
07:27:24 <skypers> something like
07:27:33 <skypers> Writter LogMonoid (Maybe a)
07:27:34 <skypers> ?
07:27:55 <skypers> and all that thing should be able to run in IO
07:28:22 <merijn> @unmtl EitherT e (WriterT w IO) a
07:28:22 <lambdabot> EitherT e (WriterT w IO) a
07:28:36 <kier> EitherT LogMonoid IO a, then write your own Monad instance for that which mappends the monoid when binding?
07:28:48 <merijn> Oh, I guess EitherT is not in mtl?
07:28:56 <supki> no
07:28:57 <skypers> nope
07:29:01 <skypers> it’s in either
07:29:03 <geekosaur> they're still bikeshedding it
07:29:39 <merijn> skypers: It might end up simpler to newtype EitherT and write your own monad as kier suggests
07:29:41 <skypers> ok it sounds hard to understand all that monad transformers stack :D
07:29:49 <skypers> yeah
07:30:18 <skypers> WritterT is not really for errors tracing
07:30:35 <merijn> skypers: Because EitherT short circuits and WriterT doesn't really let you handle failure
07:31:24 <skypers> yeah
07:31:24 <skypers> that’s the spirit :)
07:31:25 <b2coutts> if I want to use the Writer described in lyah, which module should I import?
07:31:25 <b2coutts> Control.Monad.Writer seems to be at least somewhat different
07:31:25 <skypers> Control.Monad.Writer is fair enough
07:31:25 <merijn> b2coutts: Control.Monad.Writer and/or Control.Monad.Trans.Writer
07:31:25 <geekosaur> you'd need to use mtl1, but I think you can't get there from here
07:31:32 <merijn> b2coutts: With the caveat that the Writer constructor no longer exists and has been replaced with the function "writer"
07:31:32 <skypers> Control.Monad.Tans.Writer is for mtl
07:31:44 <merijn> :t writer
07:31:45 <lambdabot> Not in scope: `writer'
07:31:46 <geekosaur> (that is, you can't safely install and use mtl1 since mtl2 is part of the standard install)
07:31:53 <merijn> :t Control.Monad.Trans.Writer.writer
07:31:54 <lambdabot>     Not in scope: `Control.Monad.Trans.Writer.writer'
07:32:12 <merijn> awww
07:32:49 <Taneb> :t Control.Monad.Trans.Writer.Lazy.writer
07:32:49 <lambdabot>     Not in scope: `Control.Monad.Trans.Writer.Lazy.writer'
07:32:49 <Guest00000> just got this ad in gmail
07:32:49 <Guest00000> Do you think in closures? We do too. - janestreet.com - Haskell programmers welcome!
07:32:52 <b2coutts> really, the lack of the Writer constructor is the only issue I'm having
07:32:57 <Guest00000> "it has begun"
07:33:41 <merijn> b2coutts: The simple rule of thumb for State, Writer, Reader and RWS is the following, the non-transformer constructors no longer exist
07:33:41 <merijn> b2coutts: The modules now export functions with the same name (but lowercase first letter)
07:33:41 <b2coutts> I don't know what a transformer is =/
07:33:41 <Guest00000> soon haskell will be the next enterprise ready web hipster PL
07:34:04 <elliott> b2coutts: you don't need to. just lowercase the first letter.
07:34:04 <skypers> comonad, semigroupoids
07:34:04 <merijn> b2coutts: Ignore that word then, to simplify further "Writer" became "writer", "Reader" became "reader", "State" became "state"
07:34:04 <b2coutts> Guest00000: yeah, I've seen that ad as well
07:34:05 <skypers> all that weird concepts make me sick :D
07:34:07 <merijn> b2coutts: See the pattern? :)
07:35:25 <b2coutts> ah, cool
07:35:35 <b2coutts> at some point I'll go back and make sense of :t writer
07:35:54 <merijn> b2coutts: Basically, monad transformers add extra "abilities" to an existing monad, i.e. add State to Maybe, or something like that. People realised the that original versions of State/Reader/Writer could be implemented using a nice general way, which replaced the definitions from LYAH
07:36:14 <merijn> b2coutts: If you "import Control.Monad.Trans.Writer" and then do ":t writer" you should get a much simpler type
07:36:37 <b2coutts> merijn: ah, indeed
07:36:40 <merijn> b2coutts: The one from Control.Monad.Writer is really generic "automatically work with a bunch of other things" type of version
07:37:01 <merijn> b2coutts: Don't worry about it for now, they do the same thing, the other is just much more generic
07:38:36 <skypers> :t liftIO
07:38:36 <lambdabot> Not in scope: `liftIO'
07:38:43 <skypers> .
07:38:55 <merijn> skypers: "liftIO :: MonadIO m => IO a -> m a"
07:39:09 <skypers> yeah, Hoogle said the same thing :)
07:39:10 <skypers> thank you
07:39:31 <Guest00000> MonadGeneralizedAbstractNonsense
07:40:35 <b2coutts> Guest00000: my impression is that janestreet uses ocaml for the sake of attracting programmers who like that sort of language
07:40:56 <b2coutts> especially given that many such programmers would give strong preference to a job that lets them use a language like ocaml, it seems like a good strategy to me
07:42:11 <merijn> b2coutts: The impression I got (knowing people that know people, you know the drill) is that they consider functional programming an essential tool in reducing the bug count and complexity of their code
07:42:25 <merijn> b2coutts: Which, given the sums of money they handle, is rather critical
07:43:52 <b2coutts> oh, I can see that
07:46:17 <geekosaur> there's a number of papers (mostly by SPJ, I think) about Haskell for financial contracts. those folks can get a lot of mileage out of a language that can define types such that illegal or importer transactions are compile errors
07:46:17 <geekosaur> *improper
07:46:41 <merijn> Standard Chartered seems to think roughly the same things, given their investment in Scala (and Haskell?)
07:46:42 <S_J> where does haskell store source code for packages on windows?
07:47:16 <merijn> S_J: Nowhere, if you wanna take a look you can run "cabal get <package>" to unpack a package in the current directory
07:47:36 <merijn> I always forget where edwardk is working, was that Standard Chartered too?
07:48:58 <merijn> oh, "S&P Capital" according to linked-in, anyway that sounds rather financy too :)
07:50:05 <merijn> Whenever I talk to haskell programmers that are in industry I always get the impression that there's humongous proprietary codebases being written in Haskell and all the companies are all just being very hush-hush and secretive about their secret weapon :p
07:50:22 <geekosaur> yepyep
07:50:31 <b2coutts> it turns out Windows 8 is actually written entirely in haskell
07:51:26 <geekosaur> nothing new, either. Smalltalk lives in a very similar space; not very well known or popular in the world we see but huge proprietary codebases in industry
07:52:00 <merijn> One of the banks should pony up and invest in someone to walk on cabal properly
07:52:01 * hackagebot tuples-homogenous-h98 0.1.0.0 - Wrappers for n-ary tuples with Traversable and Applicative instances.  http://hackage.haskell.org/package/tuples-homogenous-h98-0.1.0.0 (PetrPudlak)
07:52:01 <merijn> :p
07:54:07 <geekosaur> also I imagine the banks couldn't care less about cabal, they have internal libraries and build systems :)
07:54:12 <merijn> Or I should kickstart myself working on haskell infrastructure fulltime. I'm curious how many people would donate
07:58:48 <_justjust> <-
08:02:44 <merijn> What do you guys think, is least squares notable enough not to require a citation?
08:06:01 <kier> EitherT LogMonoid IO a, then write your own Monad instance for that which mappends the monoid when binding?
08:06:07 <kier> argh crap
08:08:59 <djahandarie> merijn, I would not be surprised if people would actually be interested in kickstarting something like that, as long as the person has a good track record with work on Haskell infrastructure stuff (not sure if you do or not)
08:10:56 <merijn> djahandarie: I have patches in cabal, base and ffi!*
08:11:10 <merijn> * Small print: All of these are 2 character patches... >.>
08:11:43 <merijn> djahandarie: Yeah, I think people would be willing to kickstart something, but probably not enough to be viable as full-time employment
08:12:15 <mkiefel> merijn: I guess you should cite it somehow, but I guess it depends on your field what to cite since it got reinvented a lot of times.
08:13:55 <merijn> mkiefel: It's for IFL, I'm tempted to just go with "meh, everyone there should be familiar with least squares"
08:14:22 <mkiefel> merijn: mhm, I am not sure if citation is about familiarity... but I might be wrong
08:15:00 <S_J> merijn: then why does leksah ask for path to source of haskell packages?
08:15:09 <merijn> It's not just about familiarity, but I think least squares is from "times beyond rememberance" :p
08:15:16 <merijn> S_J: No clue, I don't use leksah
08:15:24 <mkiefel> merijn: this survey article about the Moore-Penrose pseudo-inverse seems to be nice: Generalized inverse of a matrix and its applications, by Rao and Mitra.
08:16:01 <mkiefel> merijn: Always good to have an old citation :)
08:18:54 <merijn> True
08:21:55 <edwardk> arkeet: mostly because lens HEAD was incompatible with GHC 7.7.. which I had fixed and now the Roles stuff breaks us again
08:25:27 <hamishmack> S_J: Leksah indexes the source code you might already have installed.  If you do not have any source folders to add don't worry.
08:26:15 <hamishmack> it also asks you for a folder to put cabal source in.  It looks at the pacakages you have installed on your machine
08:26:22 <S_J> it takes forever...
08:26:27 <hamishmack> and attempts to unpack the source for them
08:26:39 <hamishmack> yes it is not fast
08:26:54 <hamishmack> but it only has to do it once
09:49:32 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
09:49:32 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
09:49:32 --- names: list (clog phst` revtintin trism Puffton DMcGill boblu Nahra seanparsons amyers [[zzzz]] honkfest_ pastorius mwc conehead Cho0fool vk_ l0p3n t7 ethercrow ozgura normanrichards Demos Nisstyre-laptop Sixmsj JobV ihm1 S11001001 rnz_ eribeiro twanvl applicative pentace flebron hamid k00mi thunderrd nexx aforemny_ Claudius1aximus aninhume1 supki_ ziman_ manung Pip aegis__ codesoup farn tuxit maxter dmwit_ tharper pantsman Apocalisp h4199 Morgawr csp doomlord TIHan)
09:49:32 --- names: list (Tesseraction araujo bananagram scottschecter evan_ m1001 zzing kitallis tommd Y_Less qjin Mortomes phienone io2 Guest00000 Argue hiroaki iol timemage tufflax watermind bowas109 mdhopkins Banistergalaxy laar Kiryx xymox ptshih kurisumasu arpunk jackp danharaj Alpha64 copumpkin fridim__ _justjust Jeanne-Kamikaze uu1101 Mowah yyyyy OlegYch maksbotan oleo S_J Taneb guest82 bogdanp fylwind voxpopuli ulfdoz tpsinnem guampa nooodl cognominal ksf_ jophish_)
09:49:32 --- names: list (Eduard_Munteanu jbracker Reite hashcat Luser tomprince MindlessDrone perspectival MrFahrenheit xinming q66 weie_ merijn phyrex1an mauke kstuart lambdabot nova_ shintah yacks Digit edwardk kav jml lemao Thra11 xunie-laptop sbahra_ hrehf sinclair|net ghorn__ augur hape01 Sculptor kuribas soulrain shrekster whaletechno amatsu kludge` wole DolphR lq heath torwegia wolfnn seschwar gg7 matheus23 kloplop321 gautamc pantech SoupEvil pygospa Paprikachu _d3f Alice3)
09:49:32 --- names: list (mellum Mon_Ouie goldkatze desc|zenbook nneko001__ DanielDiaz BMeph Kaini kerrick zammy m3ga solrize jesyspa shashank cdidd zxq9 simion314 Krakarn rfw nwf ParahSailin otto_s_ sellout- preflex tabemann dolio flippo shanse scshunt jrslepak gnuvince Kabaka jbauman hiratara Ralith RichyB parcs_ bscarlet apaku nuttycom [swift] Rarrikins milessabin kevinqcs xplat predator217 jaimef cdk threesome TheFuzzball Sgeo favonia tg DrCode zacts Twey chrisdotcode_ jdegoes)
09:49:32 --- names: list (jdoliner bytbox LAMMJohnson tertl3 Internet13 perlite solancile RevJohnnyHealey TallerGhostWalt joaopizani b2coutts isomorphic morolin structuralist transfinite Pengoo Tinned_Tuna drdo mescalinum chrisdone brandonw nominolo mshroyer ysuzuki gbarboza Philippa miloshadzic wtw knsd fridim_ jssanders Shou `^_^v nik_89 linux_noob_666 bennofs ghorn NimeshNeema gdoteof dgvncsz0f davorak jeff_s1 joneshf-laptop neektza1 ido Arnoldz geoffh raft ssbr kubrat meretrix)
09:49:32 --- names: list (byorgey DexterLB amathew __main__ mkiefel Excedrin qrlr caligula MoALTz Egbert9e9 waterlaz shachaf maoe f8ld Boreeas latro`a_ AntiSpamMeta hvr gienah adnap n00dle rndm c_wraith IanKelling mrowe_away Shin-LaC fgomez Natch ormaaj alang shutdown_-h_now arun torkjak burp_ doshitan vili ecube kooga zorzar MK_FG edk cl_away sj4nz mceier WhereIsMySpoon ft brixen JaRoel|4d xenophon solirc dju CareBearemcho cods zentrification thorsten` tudalex lattenwald leifw)
09:49:32 --- names: list (NeatBasis vpm swistak35 nodeless_ fran tehroflmaoer saep od- ismlages stvc mgsloan smarter FreeFull apples gthorslund nhanho knyppeldynan Riussi mikecaruso albel727 relrod Hafydd dino- tntc lusory levi [mth] idoru Guest83359 ggreg Noldorin pikhq ezrios zoktar srcerer epta Veltas Bwild Ycros brisbin thebnq mikee niko Excureo ciaranm go|dfish seantallen jaspervdj dkasak Amadiro yriw joachifm eacameron s4muel milli PHO_ maurer mmaruseacph2 geekosaur idnar)
09:49:32 --- names: list (s4msung kakos ekyo wormphlegm noam fijimunk1i n-dolio eyck fxrh zomg mlh Belgarion0 DT`` wchun hive-mind supersym alexsdutton Work_jack mannyv fikusz fryguybob hiptobecubic SHODAN dsantiago tero- k4nar Khisanth Fuuzetsu otulp frontendloader lunarjar jml_ sclv Deewiant wilfredh bentrevor chexxor Vertue idnaria Xorlev nullcone alszar asjo ninzine Iceland_jack epsylon plucas zrot dwierenga markov_twain ParahSail1n xye machisuji _flow_ Jaxan mimi_vx ktosiek)
09:49:32 --- names: list (crs_ plhk McManiaC dsirenko_ popx ninegrid Darkflux troydm dymatic sbahra Vorpal bergey shajra maximumsteve thetallguy Athas mlamari mee IbnFirnas Soft ggherdov destiny zebr killy9999 jroesch ski_ jmcarthur Phlogistique sleepybug aleator sajith Lemmih osfameron udoprog joogi barrucadu fry mjrosenb mel- identity rgrinberg gseitz wting tych0 lpvb carter cheezey hfaafb nonconve1gent flori_ aford mantovan1 Bynbo7 Kuba _br_ purefn xenocons ahihi ofan \q sanjoyd)
09:49:32 --- names: list (hamishmack jzl bergmark vmeson chirpsalot s00pcan Kuraitou MrRacoon bbee Cerise dreixel shepheb tavelram Nshag dabradley jzelinskie iteratee mjo iemejia SLi stelleg absence katis redjohn Fubar^ tahu Vq Tene wollw doomlord_ mephx akiress thomassgn bbloom gereedy reactormonk bduc sirspazzolot Guest63538 Dtgr schlumpi charlesofarrell_ tunixman satshaba1 satshabad udevd tarmo osnr jcp mgaare counterstrike44 vnz mbrock Draconx mak` stevejb Boney canissimia)
09:49:32 --- names: list (MouseTheLuckyDog Tarential rhodesd mstksg sordina andrewsw cmears derekv shergill jonsterling fabjan profmakx melter pjstadig zenoli djahandarie mcbonz sunfun dlundy sababa hellome Kyzza kekimmo DarkFox KyleCloud og canta zq haasn dan64 krakrjak_ ousado Pad^ ssttudder shelf janinge dropdrive pcapriotti ircbrowse jackhill junsuijin solution davean theorbtwo noddy MetaCosm td123 blakesmith monochrom tvaalen c_14 de-Vri-es rmyers k0ral MOMI daira b0c1)
09:49:32 --- names: list (tauntaun ByronJohnson aloiscochard edkk ErkiDerLoony jang1 bartavelle aoh arnsholt Nik05 M-ou-se tomh- peddie_ cynick taruti sdx23 arkx so mokus fergusnoble Spaceghost peddie Igloo drbean gpampara tsou callen rasmusto jlaire joefiorini davidt_ ceii tensorpudding simon anon123 ccxCZ Tehnix felipe_ Adios neena bicgena uranther bsmt nkpart Liskni_si tomaw rpenguin_ hpc aristid guerrilla iulian dpwright KitB tulcod sgso ivan` jlamothe adimit alpounet marienz)
09:49:32 --- names: list (yam cajla palmje mrshoe Ke FireFly tridactyla SegFaultAX BigEndian yiannis_t Maxdamantus wunki `0660 vsayer Nimatek Enigmagic twn dogmaT dexter1 tomejaguar adlan annulus- orospakr gambogi Squid_Tamer munro Khady robinbb-freenode oldmanstan Adeon DustyDin1o leroux bobry demolithion dyreshark mmathis gilbertw1 lenstr Will| Jello_Raptor vehk ab9rf stass Gracenotes threedaymonk Sunhay_ DigitalKiwi acfoltzer cschneid qz mietek lightquake mortberg Raynos)
09:49:32 --- names: list (tylergillies_ stepcut inr Cale valdyn dqd colah jyyou xnyhps anhall machisuji_ mike2 Tekerson KaneTW arkeet kloeri Odd_Bloke FUZxxl mxf divarvel froztbyte _janne akraut etherfreak vvv drewr Erstarrung jrib zero7 sevvie hdevalence flazz Raynes quicksilver bd__ Bigcheese d3lxa si14 alej upgrayeddd lopex dcoutts pettter qwandor hiyakashi tdammers Baughn_ michaf etrepum spligak hpd seneca eL_Bart0 puzza007 chickenflu warpy ortmage akahn xorox90_ lokydor)
09:49:32 --- names: list (chrisbuchholz talzeus_ shennyg vivekrai Ghoul_ jodaro_ gdeest ehd DrSyzygy joeyh kini Licenser jhh banjiewen dthibodeau mykhal blz37 palaga Eridius sepeth yano brett bcoppens Martty knz cmsd2 neurocyte ivan\ s_quark arbn petantik bogner electrogeek BrianHV newsham earthy vobi bezik edwtjo mero vvein levitation[A] koala_man JustAPerson nanothief_ Th0mas wto linduxed noplamodo thorkilnaur__ averell nxorg8 thirsteh mlinksva kxra dan_johnsin SaBer)
09:49:32 --- names: list (zerokarmaleft myme1 otterdam ocharles aess saiam elgot mechairoi Valodim hackagebot Svedrin `bps liori kshannon h_chiro_ stiell alexander__b int-e sm Tribal flux kaw ReinH joar bogner_ tippenein Mayzie dustinswan saiam^ phryk gemelen Hardolaf peltchu MasseR gbluma_ Laney mixi thetallguy2 Elision theDon zaphar_p1 kqr1 Gothmog_ kranius cow-orke1 deggis slobo_ bstrie mux a11235 ahf BlastHardcheese jlewis duairc JPohlmann integral Brando753 Cryovat brendan rce)
09:49:32 --- names: list (brainproxy othiym23 suiside drmegahertz agundry Plex- ent zenzike_ dixie_ saurik luite Saizan lispy mviljamaa Maior jlouis fayden shiona ernst mollerstrand statusfa1led ehamberg mami tswett bholst_ Yawgmoth_ ChongLi companion_cube bind Sourceless skypers Zariel guymann liyang briden joelteon hiredman Ornedan schoppenhauer mornfall CosmicRay kaol ttm pqmodn_ malorie_ dilinger_ thoughtpolice ryanakca mr- Razz pr raid Edoxile sohum hpaste nikola zw01)
09:49:32 --- names: list (greymalkin fall_ Nickeeh yan_ Blkt bgamari dsp_ Watcher7 ejls Yaniel xaimus macron luminous confound_ Zesler mkrull Eliel anachron SirChurchill Ezku b_jonas johnw kosmikus almondjelly copton jix lahwran mononofu pyykkis notdan zeiris_ horlicks Draggor lpsmith mikeplus64 robbert majoh betawaffle gds Ptival inarru geal taylorgb ipuustin Walther jayne Reisen bitraten ibid Jaak CindyLinz aszlig zaiste def-lkb arcatan Spockz tromp_ cjay jamwt dmp1ce yeltzooo)
09:49:32 --- names: list (necroyeti willb1 Dashkal Chousuke nlogax Starfire_ mrd_ Ulrar davd tessier b52 asante deavid elliott poucet XMunkki_ bqp ericmj pharaun cruxeternus sp3ctum Clint mendez Dybber magicman anders^^_ isomorphismes wagle sipa pnielsen Kinnison tamiko OrangeDuck wavewave @ChanServ dumbhat LeaChim chrra mattp__ lulf Proteumus Rembane pfoetchen prophile sunnavy_ finnrobi pi8029 TML ve genisage wereHamster gridaphobe klugez ion dario^CIP Rutger`_ cross danr jliikka)
09:49:32 --- names: list (solarus nicoo jkpl liszt petanqk opqdonut stomp SuperNoeMan bxc rs0 Kneiva TheSpectre Sagi kryft)
09:49:52 <edwardk> well, either really.
09:49:53 <Cho0fool> merijn: Thanks, it solved my problems.
09:49:58 <edwardk> you'd have to encode the world differently
09:50:02 <jmcarthur> b2coutts: one potential confusion with either function is that evaluating the second result would force the entire thing. maybe some non-list result type would be nicer in practice (assuming you don't need the final seed before you have consumed the list):  data Blah a b = Cons a (Blah a b) | Nil b
09:50:09 <ReinH> edwardk: yeah I thought so
09:50:11 <ReinH> edwardk: "Café au Life takes just under two seconds to boot up, and another second to calculate the state of the pattern after 143.4 quadrillion generations."
09:50:13 <jmcarthur> b2coutts: the unfold would be quite straightforward then
09:50:16 <ReinH> that's pretty damn fast for javascript
09:50:23 <ReinH> I bet Haskell could do significantly better
09:50:33 <edwardk> yeah. i have a hashlife implementation around somewhere on some machine
09:50:39 <edwardk> but i have no idea where
09:50:40 <ReinH> of course you do :p
09:50:40 <jbracker> jmcarthur: With the SCC options I still only get information that most time is spent in that expression no further info about what it happening inside. S at this point I need ghc-core or can I let the profiler show the internals of that call somehow? There from an external package
09:50:49 <ReinH> edwardk: any hint as to how you would encode the world?
09:51:00 <b2coutts> jmcarthur: my actual use case is that I'm parsing a string, and would like to use unfoldr to pull the first "thing" off of the string, but also return the rest of the string to be parsed
09:51:03 <ReinH> aside from "as a tree, dummy" ;)
09:51:07 <edwardk> nowadays i'd strongly consider something like a matrix grammar.
09:51:13 <b2coutts> I think trying to use unfoldr to do this is just the wrong approach
09:51:17 <ReinH> "a matrix grammar"
09:51:17 <ReinH> huh
09:51:22 <ReinH> I don't even know what that means :)
09:51:27 <edwardk> and then use observable sharing to renormalize it each step
09:51:38 <ReinH> yeah, yeah I know some of these words
09:51:43 <b2coutts> which makes me sad because unfoldr is so tantalizingly close to doing exactly the right thing
09:51:48 <jmcarthur> jbracker: did you put the annotation on a subexpression or just the whole function?
09:51:56 <jmcarthur> jbracker: you have to do the former if you want more finegrained profiling
09:52:10 <ReinH> edwardk: so the problem with hashlife is that it doesn't generalize to small world topos
09:52:20 <jmcarthur> b2coutts: maybe you could just use a parser combinator library?
09:52:21 <edwardk> lets take a step back from this problem and talk about a simpler one
09:52:21 <edwardk> sure
09:52:21 <ReinH> it requires bounded information propagation
09:52:28 <ReinH> ok let's do
09:52:36 <edwardk> this would assume a lot about the topology
09:52:41 <edwardk> but its a fun exercise
09:52:44 <ReinH> ok!
09:52:48 <ReinH> should we #haskell-overflow?
09:52:55 <ReinH> I have a feeling we're about to spam the channel with automata
09:53:01 <edwardk> how about we overflow when someone tells us to shut up ;)
09:53:02 <jbracker> jmcarthur: {-# SCC "runBackend" #-} runBackend env cr < Thats what I did so just the function. So to get that more detailed I would habe to go and set annotation inside the library providing it?
09:53:06 <ReinH> ok :D
09:53:32 <jmcarthur> jbracker: yeah. in fact, if you didn't build that library with -auto-all (and perhaps -caf-all) then maybe that would be a good first try
09:53:48 <edwardk> Have you ever heard of the term 'SLP'? or 'straight line program?
09:54:27 <edwardk> the idea is to describe a string in terms of some context free grammar that has it as its only parse.
09:54:46 <ReinH> nope
09:54:55 <jbracker> jmcarthur: ok
09:55:01 <b2coutts> jmcarthur: nah, this project is more of a learning experience than me trying to make something practical
09:55:12 <b2coutts> so I figure I should do the parsing on my own
09:55:15 <ReinH> edwardk: reading
09:55:23 <jmcarthur> b2coutts: if you have never used a parser combinator library then that can be a learning experience!
09:55:34 <b2coutts> that's true
09:55:40 <edwardk> so if we put things in chomsky normal form you have productions that look like A := BC for nonterminals A,B,C  and rules that look like A := x  for a terminal x. since we want only one parse, we only ever have one rule for each non-terminal
09:55:47 <b2coutts> I'm also curious about how concisely I can write an s-expression parser
09:55:48 <edwardk> then you have a distinguished start state.
09:56:54 <edwardk> So if we start to encode that you can make something like: data Production nt t = NonTerminal nt nt | Terminal t
09:57:09 * hackagebot yesod-auth-account 1.2.2 - An account authentication plugin for Yesod  http://hackage.haskell.org/package/yesod-auth-account-1.2.2 (JohnLenz)
09:57:19 <augur> edwardk:   A ::= BC | DE   B, D ::= x   C, E ::= y
09:57:20 <edwardk> and then define the SLP: data SLP a = SLP Int (Map Int (Production Int a))
09:57:45 <edwardk> augur: SLP, so i'm disallowing |
09:57:58 <augur> edwardk: ah, ok.
09:58:10 <augur> edwardk: so only ever one rule for each non-terminal
09:58:17 <edwardk> yep
09:58:20 <edwardk> hence on unambiguous parse
09:58:21 <augur> that sounds finite state
09:58:30 <edwardk> its a compression technique
09:58:36 <augur> when combined with CNF, i mean
09:58:39 <Cho0fool> Still i wonder why i need match all contructors of data type?
09:58:46 <bixuanzju> Hello, I am a newbie. Hope to learn more Haskell from here!
09:58:47 <ReinH> edwardk: can you unpack the SLP data type for me please?
09:58:54 <edwardk> LZ77 can be seen as a particular form of SLP, and you can go back and forth between LZ77 and SLP with some polynomial expansion each direction
09:58:57 <edwardk> ReinH: absolutely.
09:59:31 <edwardk> A straight line program consists of a starting state (Int)      and a map from state to the production for that state.
10:00:11 <ReinH> edwardk: that looks an awful lot like Store...
10:00:22 <Cho0fool> Is it like: if function returns m [ObjectOid m] and ObjectOid has 4 constructors that array can contain any of that four types?
10:00:36 <jmcarthur> Cho0fool: clearly because if you don't then you can get a runtime error ;)
10:01:05 <edwardk> ReinH: think of this like a tree with explicit sharing
10:01:11 <ReinH> ok
10:01:33 <jmcarthur> Cho0fool: right. if i have a data type   data Blah = A | B | C | D   and i claim i have a function that takes that as input, it better work for any of those inputs if you can reasonly expect that any of them could be used as an argument in practice
10:01:45 <edwardk> you can expand from SLP a   into Mu Production a  -- for a version of Mu that fixes over the first argument of a bifunctor.
10:01:54 <jmcarthur> Cho0fool: a function that is not defined for all inputs is called "partial," and one that is defined for all inputs is called "total"
10:02:02 <edwardk> in fact you can do that expansion with perfect sharing using loeb.
10:02:04 <ReinH> what does "explicit sharing" mean here?
10:02:41 <mbrock> in a language with pointers, an SLP could just be a generic binary tree?
10:03:00 <jmcarthur> Cho0fool: so for example if i don't define my function for constructor B but i pass B as an argument to it, there is clearly no choice but to error out
10:03:34 <ReinH> edwardk: Mu f = f (Mu f), and some wrapper/unwrapper functions?
10:03:34 <applicative> hi bixuanzju
10:03:58 <Cho0fool> jmcarthur: Hm, can i have array of [A, B, C] :: Blah?
10:04:06 <edwardk> Mu f a = f (Mu f a) a -- its the bifunctor version
10:04:09 <jmcarthur> Cho0fool: yes (although that's a list, not an array)
10:04:11 <ReinH> ah
10:04:18 <jmcarthur> Cho0fool: and its type would be [Blah], not Blah
10:04:35 <applicative> bixuanzju: have you managed to install the ghc, and found a decent text to read?
10:04:36 <Cho0fool> jmcarthur: Okay got it, thank you for explanation.
10:04:49 <mbrock> hm, except with this SLP you can get all the keys & values of the map...
10:04:57 <edwardk> so you get Result a = NonTerminal (Result a) (Result a) | Terminal a
10:05:08 <geekosaur> also you have a slight confusion above, the constructors are not independent types, they are possible values for a single type
10:05:24 <edwardk> mbrock: its just a way to get some kind of notion of a 'pointer', yeah
10:05:35 <geekosaur> this means if you have data Foo = A | B } C, you can't declare a function that only takes B
10:05:44 <geekosaur> s/}/|/
10:06:39 <ReinH> edwardk: ok
10:07:06 <edwardk> mbrock: with an SLP you usually want the parse to be finite as well. this can be encoded many ways. the LZW approach is to start with a dictionary of all the terminals, and then just add new non-terminals concatenating anything you need as you go to write it
10:07:33 <edwardk> that way all non-terminals reference productions with lower numbers
10:08:41 <edwardk> ReinH seems to be suckering me into writing a 'hashline' implementation for the next version ;)
10:09:27 * ReinH looks pleased
10:10:03 <aristid> what does SLP stand for?
10:10:03 <ReinH> edwardk: ok so I grok LZW compression at least, and I can see how it is a form of SLP
10:10:04 <edwardk> anyways, the SLP itself was just a starting state, and a map from states to productions
10:10:10 <edwardk> aristid: 'straight line program'
10:10:21 <aristid> and what does it mean?:D
10:10:32 <edwardk> its a form of compression, you define a grammar for which the document is the only parse
10:10:38 <edwardk> then you use the grammar generatively
10:10:41 <aristid> ah.
10:11:00 <aristid> and the popular LZW compression is such a method?
10:11:05 <edwardk> yeah
10:11:31 <edwardk> my LZ78 haskell code can be seen as another such method as well
10:11:49 <edwardk> http://hackage.haskell.org/packages/archive/compressed/3.0.3/doc/html/Data-Compressed-LZ78.html
10:12:14 <edwardk> note the size of the compressors/decompressors: http://hackage.haskell.org/packages/archive/compressed/3.0.3/doc/html/src/Data-Compressed-Internal-LZ78.html#encode
10:12:18 <aristid> edwardk: why LZ78 over LZW?
10:12:38 <edwardk> LZW requires you to build an initial dictionary containing each terminal
10:12:50 <aristid> and LZ78 can be used adaptively?
10:13:02 <edwardk> LZ78 does not it starts with a dictionary with a single empty production
10:13:28 <edwardk> and when you need to extend a dictionary entry because you haven't seen something you emit a slot # and a terminal
10:13:42 <edwardk> this has the benefit that LZ78 works over infinite alphabets
10:13:54 <bixuanzju> whois
10:13:56 <aristid> LZ78 does not start with terminals for all 8-bits?
10:13:57 <edwardk> LZW, on the other hand does not
10:14:05 <edwardk> correct
10:14:17 <edwardk> it merely starts with a dictionary that has one, empty production in it
10:14:19 <c_wraith> aristid: many files limit their bytes to <128
10:14:25 <aristid> c_wraith: right
10:14:48 <edwardk> then you emit a sequence of (Token, Terminal) pairs, where tokens reference existing productions, and each implicitly creates a new dictionary entry
10:15:23 <ReinH> encode is gorgeous :)
10:15:29 <edwardk> ReinH: thanks =)
10:15:44 <aristid> edwardk: so a LZ78 decoder is pretty simple?:)
10:16:02 <edwardk> aristid: see the code i linked above. if fits in 3-4 lines of haskell
10:16:19 <c_wraith> is every output (except the end of the file) required to create a new production?
10:16:46 <c_wraith> Seems like a "sufficiently smart" compressor might be able to do better by sometimes not creating new productions
10:17:18 <edwardk> aristid: one thing i use in there though, is that i can 'lose' som information about my domain and still produce a valid LZ78 document. This enables me to make LZ78 form both an Applicative and a Monad
10:17:34 <edwardk> the way i do so is to assume that the individual terminals you got are all unique!
10:17:48 <edwardk> then build a new LZ78 document out of the result
10:18:16 <edwardk> you can recode it to get better compression usually, but thats fine
10:18:49 <edwardk> and they can form a Functor because nothing prevents you from just fmapping a pure function changing out terminals to new terminals
10:19:22 <aristid> edwardk: i don't find the meat of the decode function :P
10:19:38 <edwardk> aristid: it is hidden as mapTo
10:20:08 <aristid> edwardk: how does mapTo magically become reduce? *confused*
10:20:10 <ReinH> edwardk: right, you just recursively fmap the tokens
10:20:14 <edwardk> you can 'foldMap' any LZ78 document into any monoid, and the trick is what i do is i build up the output dictionary _in_ your monoid.
10:20:41 <ReinH> edwardk: I notice that you could have done fmap f (Cons (Token i a) as) = Cons (fmap (Token i a)) (fmap f as) but didn't use the functor instance of Token there
10:20:46 <ReinH> edwardk: on purpose?
10:21:32 <gelisam> greetings! I would like to improve my understanding of the interaction between polymorphism and laziness-based memoization.
10:21:54 <gelisam> in particular, the following behaviour is quite puzzling to me: https://gist.github.com/gelisam/6257856
10:22:30 <ReinH> edwardk: I guess I'm just so used to seeing fmap Cons (fa) as = Cons (fmap fa) (fmap as)
10:22:33 <edwardk> aristid: think of it this way, i run down a list of token, terminal pairs, carrying a Seq m of monoidal results so far. All I have to do then is for each slot#/terminal pair, is look up the slot# in the sequence, mappend (f a)   onto it, add it to the right of my sequence, and emit it to the user
10:22:48 <ReinH> edwardk: also would that be defivable with DeriveFunctors?
10:22:48 <edwardk> ReinH: it could probably be cleaned up
10:23:03 <edwardk> ReinH: DeriveFunctor exhibited asymptotic slowdown until recently
10:23:06 <ReinH> ah
10:23:08 <edwardk> and this package is entirely haskell 98 as i recall
10:23:13 <edwardk> oh guess not
10:23:14 <ReinH> just curious
10:23:15 <edwardk> type families
10:23:17 <ReinH> ah
10:23:18 <ReinH> ok then
10:23:42 <aristid> edwardk: your LZ78 uses an "infinite-size" dictionary?
10:24:15 <edwardk> aristid: this package was based on the observation that many decompression schemes don't require you to look at the values produced, so i can produce them in a target monoid rather than as a list.
10:24:31 <edwardk> aristid: the cute little 4 line encoder/decoder pairs, yeah.
10:24:47 <edwardk> you could write a version that had a bounded dictionary
10:25:00 <edwardk> but the monoids i was interested in were _scary_ so they were worth memoizing at all costs
10:25:26 <edwardk> in fact i may still want to use this in my new valiant parser
10:25:33 <aristid> what's valiant?
10:25:43 <danharaj> CYK parser thing
10:25:50 <edwardk> 'fast parallel parser'
10:25:51 <edwardk> =)
10:26:06 <edwardk> its a variant of cyk that can abuse fast sparse matrix multiplication
10:26:06 <danharaj> edwardk: do you know of any papers on SMT solvers
10:26:18 <edwardk> danharaj: yes, but thats a pretty big field. what more specifically?
10:26:24 <Cho0fool> Guys, can you explain why this: lookupCommit coid >>= \commit -> return $ M.insert (getEmail commit) 1 acc   doesn't equals to this: return $ M.insert (lookupCommit coid >>= getEmail) 1 acc ?
10:26:27 <ReinH> edwardk: if only you had a fast sparse matrix library...
10:26:46 <Cho0fool> I bet i'm asking something like "why 1 doesn't equal to 2"...
10:27:03 <danharaj> edwardk: something that outlines how to implement an efficient one `ala` SPJ's STG paper on implementing an efficient lazy functional programming language.
10:27:22 <ReinH> Cho0fool: what is the type of getEmail
10:27:24 <danharaj> edwardk: I can't find a "the story so far" paper, just incremental improvements over DPLL(T) from a thousand years ago.
10:27:27 <edwardk> ReinH: and now you see how i wound up shaving my current yak
10:27:36 <ReinH> edwardk: :D
10:27:42 <edwardk> danharaj: everything i've read has been scattered all over
10:27:44 <Cho0fool> ReinH: getEmail :: Commit m -> String
10:27:54 <ReinH> edwardk: now back to our yak, SLP -> hashlife ;)
10:27:57 <edwardk> danharaj: i don't have a great rosetta stone like summary paper to recommend
10:28:09 <ReinH> :t (>>=) -- Cho0fool
10:28:09 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:28:11 <danharaj> oh well
10:28:19 <danharaj> maybe I can get away with reading all the Z3 papers
10:28:41 <edwardk> danharaj: you can also read the z3 code. once you get past the awful c'isms its understandable
10:28:41 <ReinH> Cho0fool: the rhs of >>= has to be (a -> m b) for some monad m
10:28:52 <ReinH> Cho0fool: but getEmail is of the form a -> b
10:29:03 <danharaj> edwardk: that sounds legally troublesome since I might need to implement an SMT solver for work :P
10:29:05 <Cho0fool> ReinH: Oh, i see, thanks.
10:29:10 <ReinH> Cho0fool: np
10:29:17 <edwardk> danharaj: i've been tempted to write a nice haskell solver that would at least be elegant if not competitive. z3 is a sewer, but most of the sewage is c-style AST manipulation
10:29:49 <danharaj> edwardk: exactly. We are really skeptical of using foreign library for that sort of stuff because of the massive impedance mismatch between our logic and theirs.
10:29:55 <edwardk> danharaj: but i can also see writing such a haskell solver as becoming all consuming
10:30:11 <edwardk> danharaj: you've seen my tiny little ersatz lib, right?
10:30:23 <mbrock> Cho0fool: if you're familiar with callback-based programming, notice that the first variant there is like providing a callback for the commit lookup action
10:30:24 <danharaj> is that the weighted datalog one
10:30:25 <edwardk> ReinH: i haven't forgotten you, one sec =)
10:30:29 <ReinH> edwardk: no worries :)
10:30:35 <edwardk> danharaj: nah ersatz is just a binding to external sat solvers
10:30:42 <danharaj> oh cool
10:30:55 <edwardk> danharaj: can do things like: http://heh.fi/tmp/regexp-grid
10:31:14 <edwardk> if you remember the mit regex crossword
10:31:19 <mbrock> Cho0fool: in the second, you're trying to use a callback-based action as an immediate value, which doesn't make sense
10:31:20 <danharaj> I do not
10:31:33 <edwardk> https://github.com/ekmett/ersatz
10:31:47 <danharaj> looking at it atm
10:31:54 <mbrock> Cho0fool: this way of thinking works with the IO monad anyway, and might be intuitive if you've done a bunch of javascript programming for example
10:31:55 <danharaj> clearly you are hinting at me that I should extend ersatz with theories
10:32:38 <edwardk> https://github.com/ekmett/ersatz/blob/master/notes/grid.pdf?raw=true
10:32:40 <Cho0fool> mbrock: He-he, nice analogy.
10:32:43 <edwardk> danharaj: yes
10:33:45 <danharaj> edwardk: well it's good to know there's a sane starting point if we ever get around to that
10:34:08 <edwardk> danharaj: i would happily collaborate with you if you wanted to add smtlib file format stuff and open theory code to ersatz
10:34:28 <edwardk> for that matter if you wanted to tackle adding a simple in-process sat or qsat or smt solver
10:34:36 <edwardk> ion has also done a lot of work on ersatz
10:34:58 <danharaj> do you know if they want a job ;)
10:35:12 <edwardk> ion: do you want a job?
10:36:04 <danharaj> not that I'm authorized to make that offer :P
10:36:18 <edwardk> personally i've greatly enjoyed working with him, so i'd say if he is, you should hire him ;)
10:36:35 <danharaj> edwardk: do you really want ryan to steal yet another haskeller from you?
10:36:49 <edwardk> all the good stuff in the lens build system is by him, all the bad stuff is by me
10:36:53 <edwardk> meh
10:37:02 <edwardk> he seems to loan them back to me here on irc
10:37:13 <edwardk> and he's in finland i think
10:37:49 <edwardk> i'm not about to go rushing off into the snow to try to stop your abduction squad
10:38:35 <kuribas> I have a nested if on the bottom of this page: http://paste.lisp.org/display/138499  So if it's not good style, how should I refactor it?
10:38:38 <danharaj> edwardk: you should get back to ReinH now ;)
10:38:44 <edwardk> i was just going to say that
10:38:52 <ReinH> Cho0fool: since you're always inserting the email in the map with a value of 1, maybe you just want a Set for membership?
10:38:54 <edwardk> ReinH: ok, so now you grok SLP
10:38:56 <ReinH> danharaj: :)
10:39:02 <ReinH> edwardk: yeah, I think so
10:39:07 <merijn> kuribas: Why not add a guard to clipSplit?
10:39:19 <edwardk> ReinH: http://programmers.stackexchange.com/questions/207665/haskell-memory-efficiency-which-is-the-better-approach/207781#207781 unpack that =)
10:39:27 <ReinH> Cho0fool: just S.insert (getEmail commit) acc ?
10:39:46 <merijn> edwardk: How do you even have time for a day job?!?
10:39:47 <Cho0fool> ReinH: No, i'm planing to insert all commits as value and email as key. But haven't figured out how yet.
10:39:54 <ReinH> edwardk: hah ok
10:39:55 <edwardk> between loeb and adding a dimnsion that should make it more interesting
10:40:00 <edwardk> merijn: give up sleep
10:40:11 <merijn> edwardk: Awww...but I don't want to :(
10:40:15 <ReinH> Cho0fool: replace 1 with commit?
10:40:16 <kuribas> merijn: Because clipSplit is just a branch.
10:40:18 <edwardk> merijn: neither did i
10:40:38 <bennofs> kuribas: If you change the let to where, you can use a guard on bezierClipAux
10:40:39 <edwardk> sadly something had to give and it was sleep or my sanity. both cracked a little.
10:40:53 <merijn> kuribas: so?
10:41:12 <aristid> edwardk: i don't think i could think too clearly when sleep-deprived :P
10:41:28 <kuribas> merijn: Ok, so I can get rid of one if, but what about the nested if on the bottom?
10:41:41 <edwardk> aristid: i long ago found i write my best code when i'm a bit tired, because i finally stop second guessing myself and just write the obvious thing.
10:41:52 <edwardk> aristid: under long term sleep deprivation i get that effect all the time
10:41:52 <aristid> edwardk: hah
10:41:54 <kuribas> bennofs: Are the local variable available in a guard?
10:42:08 <aristid> edwardk: where "obvious" still involves a bunch of comonads and reducers.
10:42:09 <edwardk> Think of it like the Ballmer Peak
10:42:15 <merijn> edwardk: This is why my best code comes together when I've been drinking :p
10:42:33 <merijn> Unfortunately, drinking and quality of my paper don't seem positively corelated :\
10:42:40 <edwardk> merijn: hah
10:43:01 <aristid> merijn: i suspect that edwardk just claims to be sleep-deprived to cover up that he's actually a pair of twins who discreetly swap roles every few hours.
10:43:06 <Cho0fool> ReinH: Yeah, i think something like    M.insert email ([commit] ++ (M.lookup email acc)) acc   should work.
10:43:09 <merijn> It doesn't help that I don't really care that much about these results >.>
10:43:24 <edwardk> aristid: Actually I've outsourced most of my higher brain functions to India.
10:43:38 <aristid> makes sense.
10:43:40 <Cho0fool> ReinH: Just in process of thinking.
10:43:52 <scshunt> edwardk: that explains a lot
10:44:19 <bennofs> kuribas: Yes, if you use where: http://lpaste.net/91920
10:44:24 <ReinH> Cho0fool: ok, so you want a map from Email to [Commit], sure.
10:44:48 <kuribas> bennofs: Oh, I didn't know that worked.
10:45:08 <Cho0fool> ReinH: Correct.
10:45:11 <ReinH> Cho0fool: you want insertWith <>
10:45:28 <ReinH> or (++)
10:45:29 <edwardk> ReinH: let me know when that post starts to make sense or if it doesn't. ;)
10:45:34 <ReinH> edwardk: ok
10:45:58 <ReinH> Cho0fool: http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map-Lazy.html#v:insertWith
10:47:09 <Cho0fool> ReinH: Thats great!
10:47:17 <Cho0fool> ReinH: But what <> is?
10:47:22 <Cho0fool> :t (<>)
10:47:22 <lambdabot>     Not in scope: `<>'
10:47:23 <lambdabot>     Perhaps you meant one of these:
10:47:23 <lambdabot>       `>>' (imported from Prelude), `<' (imported from Prelude),
10:47:32 <Cho0fool> Just a placeholder?
10:48:00 <ReinH> Cho0fool: <> is ++ for any monoid
10:48:30 <ReinH> > Sum 1 <> Sum 2
10:48:31 <lambdabot>   Sum {getSum = 3}
10:48:34 <ReinH> > "aaa" <> "bbb"
10:48:35 <lambdabot>   "aaabbb"
10:49:14 <ReinH> Cho0fool: for [Commit] you can just use (++), but if you wanted a more general monoid you could use (<>)
10:49:16 <bennofs> @let import Data.Monoid
10:49:17 <lambdabot>  Defined.
10:49:20 <bennofs> :t (<>)
10:49:20 <lambdabot>     Not in scope: `<>'
10:49:21 <lambdabot>     Perhaps you meant one of these:
10:49:21 <lambdabot>       `>>' (imported from Prelude), `<' (imported from Prelude),
10:49:24 <edwardk> ReinH: once you grok the grammar expansion we can look at repeating this construction to make a 'hash-life' for our number line
10:49:32 <ReinH> edwardk: ok, one sec
10:49:37 <ReinH> do I need to read the loeb paper?
10:49:43 <ReinH> s/paper/article
10:49:51 <edwardk> why don't you do that and i'll go grab caffiene
10:49:56 <ReinH> hahaha ok
10:50:03 <ReinH> maybe make yourself a sandwich...
10:50:44 <merijn> Is anyone aware of research into the automatic construction of performance/runtime models for algorithms/code?
10:50:45 <edwardk> ReinH: are you in the US? I forget
10:50:57 <ReinH> edwardk: I am, Portland OR
10:52:22 <aristid> edwardk: loeb reminds me of that function in vector... constructN. is that comparison valid?
10:52:54 <ReinH> Cho0fool: for example, if you wanted to store commits in a map indexed by timestamp, Ord k => Monoid (Map k v) would let you do that using <>
10:53:03 <edwardk> aristid: i think constructN can only see the prefix
10:53:08 <aristid> edwardk: yes.
10:53:18 <edwardk> loeb can "see the future"
10:53:20 <edwardk> ReinH: pm ;)
10:53:36 <aristid> edwardk: loeb will just not terminate if there are cyclic dependencies, right?
10:53:48 <edwardk> aristid: depends on what you do with the functor
10:53:58 <edwardk> you can have some things that are cyclic that are perfectly well defined
10:55:13 <Cho0fool> ReinH: Oh, sorry, i'm still quite newbie so i don't understand that monoid thing yet. Why key makes difference? If key is string or timestamp or whaever i still can use ++ as long as value is list.
10:55:51 <merijn> :t (Data.Monoid.<>)
10:55:51 <lambdabot> Not in scope: `Data.Monoid.<>'
10:56:21 <ReinH> Cho0fool: actually, that was slightly misleading, sorry
10:56:21 <aristid> i believe lambdabot is hopelessly outdated
10:56:35 <ReinH> Cho0fool: key doesn't make a difference for insertWith (++)
10:58:07 <Cho0fool_> ReinH: Hm, okay.
10:58:45 * Cho0fool_ was disconnected but have read ReinH answer via http://tunes.org/~nef/logs/haskell/13.08.17 .
11:00:49 <ReinH> Cho0fool_: ping
11:00:55 <Cho0fool_> ReinH: Pong.
11:01:36 <ReinH> Cho0fool_: a monoid is a structure for sets of things that can be "appended" to each other.
11:01:38 <b2coutts> I want to make my datatype an instance of Read, but I don't quite understand how I'm supposed to do this
11:01:50 <b2coutts> why doesn't Read simply require me to implement read?
11:02:19 <c_wraith> b2coutts: read is a sufficient implementation of Read, for simple cases
11:02:29 <ReinH> Cho0fool_: with the additional rule that there is some "identity" or "empty" thing that such that empty <> a = a and a <> empty = a
11:02:42 <geekosaur> because values can contain other values (consider Maybe a) and then you get to deal with precedence, so there are additional things you may need to implement in that case
11:02:50 <b2coutts> c_wraith: GHC yells at me when I try to implement read, though
11:03:01 <jmcarthur> what does is say?
11:03:04 <jmcarthur> *it
11:03:07 <geekosaur> @where hpaste
11:03:08 <lambdabot> http://lpaste.net/new/haskell
11:03:12 <geekosaur> ^^ code and error plz
11:03:15 <Cho0fool_> ReinH: I see, id (++) monoid too?
11:03:36 <ReinH> Cho0fool_: so, if you use the tuple (set, append, identity) to describe the structure:
11:03:50 <ReinH> integers under addition are a monoid: (Z, +, 0)
11:03:56 <ReinH> integers under multiplication: (Z, *, 1)
11:04:03 <ReinH> strings: (String, ++, "")
11:04:05 <ReinH> and so on
11:04:06 <b2coutts> http://lpaste.net/91921
11:04:30 <Cho0fool_> ReinH: Whoa, quite general.
11:04:34 <ReinH> <> is the general form of the append operator, so anything that is a Monoid instance can be appended using <>
11:04:44 <ReinH> so "foo" <> "bar" = "foo" ++ "bar"
11:04:59 <ReinH> Cho0fool_: some things are ambiguous, like integers: do you want the sum or product?
11:05:14 <ReinH> so for those cases we often use a newtype wrapper to define the desired monoidal structure:
11:05:18 <ReinH> Sum 1 <> Sum 2
11:05:25 <ReinH> Product 2 <> Product 6
11:05:30 <scshunt> ReinH: I think "append" is misleading
11:05:30 <jmcarthur> maybe c_wraith was thinking Show. it looks like Read isn't so simple
11:05:47 <ReinH> scshunt: well, it's "combine" but it's not necessarily commutative, so yeah
11:05:52 <b2coutts> having looked at the Read class on hoogle, it looks like it wants me to implement readsPrec, which from my perspective is needlessly complex
11:06:17 <haasn> functions from a type to itself (eg. :: Int -> Int) are monoids too, with ‘id’ being the identity and (.) the concatenation
11:06:29 <merijn> b2coutts: Implementing read by hand is a bit of a pain
11:06:29 <scshunt> b2coutts: is your datatype not simple enough to simply derive Show and Read?
11:06:43 <b2coutts> scshunt: it's simple enough, but rather unreadable
11:06:54 <ReinH> Cho0fool_: so the idea is that lists of things are monoids using [] and ++
11:06:55 <c_wraith> I guess I've never implemented Read manually.
11:06:59 <b2coutts> and I'll have to look at the values a lot
11:07:05 <Cho0fool_> ReinH: Thanks for great explanation. I think i'm a bit more into monoids now.
11:07:17 <ReinH> Cho0fool_: which gives rise to the idea that [a] is the "free monoid" for a
11:07:31 <merijn> b2coutts: If it helps, a bare bones implementation of readPrec: https://github.com/merijn/SNet2.0/blob/master/SNet/Types.hs#L58
11:07:38 <b2coutts> the thing I'm trying to create an instance for is an s-expression
11:07:39 <ReinH> Cho0fool_: which basically means that if you want to make a monoid for a set of a's, you get one for free if you use [a]
11:08:06 <merijn> b2coutts: Also, maybe you just want to write a proper parser using Parsec?
11:08:15 <ReinH> Cho0fool_: there might be other ways to turn a set of a's into a monoid, but [a] is guaranteed to work and it's the simplest thing that is guaranteed to work
11:08:41 <b2coutts> I was hoping to avoid using outside libraries since I just need a very basic s-expression parser
11:09:02 <b2coutts> indeed, it's already written, and I figured it would probably be cleaner to just export the AST type with Show and Read instances
11:09:09 <b2coutts> but I suppose I could just export parse :: String -> AST
11:09:19 <jmcarthur> i claim that this is a misuse of Read and Show anyway
11:09:25 <Cho0fool_> ReinH: Got it.
11:09:26 <b2coutts> how so?
11:09:48 <aristid> edwardk: i somehow expect that LZ77 should be better than LZ78 with bounded dictionary size (if the dictionary just stops accepting), because it can adapt better to local patterns
11:09:52 <b2coutts> oh, I just realized my answer to scshunt made no sense because I was thinking of Show rather than Read
11:09:55 <scshunt> Read and Show are expected to give valid Haskell
11:10:02 <jmcarthur> Read and Show are best as REPL pretty printers, and are especially best when they output something that can be parsed as a normal Haskell expression (which is how the derived implementations work)
11:10:20 <b2coutts> nevertheless, I'd like the program to read proper s-expressions rather than weird-looking Haskell-like synta
11:10:35 <scshunt> b2coutts: you should probably not use Show and Read for that
11:10:37 <merijn> b2coutts: Yes, which is what parsers were invented for ;)
11:10:38 <jmcarthur> err, well, Show is best for REPL-like stuff, and Read is best as an inverse for Show
11:10:51 <Taslem> You could do both by yielding a string like:  parseAST "(+ 4 (* 3 6))"
11:10:57 <Taslem> Then it's both pretty /and/ valid Haskell
11:11:18 <b2coutts> so even an instance for Show is bad, and I should instead export display :: AST -> String or something?
11:11:42 <jmcarthur> an instance for Show is not bad, just make it output valid haskell code (derive is the easiest way to go)
11:12:03 <jmcarthur> you just don't want show to be the thing that outputs the s-expression form of the ast
11:12:07 <jmcarthur> but just the ast itself
11:12:15 <b2coutts> yeah, but I'd rather it actually produce something like "(* 3 4)"
11:12:26 <b2coutts> ok, I see
11:12:33 <jmcarthur> call it pretty or something :)
11:12:35 <b2coutts> so these should just be separate functions then
11:12:38 <edwardk> back
11:12:42 <jmcarthur> so i claim
11:12:48 <edwardk> aristid: except now you need to be able to scan the window, etc.
11:13:11 <b2coutts> makes sense, I guess; I just figured that since what I'm writing basically seemed like implementations of Show and Read that I may as well make them explicitly so
11:13:12 <edwardk> aristid: what i use the LZ78 thing for isn't compression, its that ability to decompress within a monoid. its for improved sharing in folds
11:13:18 <aristid> edwardk: i just meant in terms of compression efficiency
11:13:23 <b2coutts> but their canonical use makes sense
11:13:27 <danharaj> #ghc isn't alive enough to help me: when I build GHC HEAD it doesn't build profiling libraries for base et al. halp :3
11:13:44 <edwardk> aristid: if i take [a] and compress it to LZ78 a  and then decompress it in a monoid the fold can reuse many of the intermediate monoidal results
11:13:47 <b2coutts> (I'll probably keep the Show instance for now because I'm too lazy to prepend my testing code with "pretty" ;))
11:13:51 <ReinH> Cho0fool_: this is a good opportunity to talk about something else monoids can do, if you'd like
11:14:22 <edwardk> there are lots of tuning parameters with an LZ77 style and it forces me into a finite alphabet, meaning i can't have nice things. ;)
11:14:22 <aristid> edwardk: so you basically get a faster mconcat for complex monoids?
11:14:27 <edwardk> aristid: yeah
11:14:52 <aristid> edwardk: but for compression of files, my point isn't entirely wrong, right?
11:15:33 <edwardk> aristid: one example of such a monoid i use is 'tabulations of a regular expression', another is the sequence-algebra 'compose these matrices, add a production in the upper right quadrant and take a transitive closure' used by valiant.
11:15:48 <edwardk> aristid: for compression of files your point is one hundred percent correct.
11:16:12 <edwardk> i use compression technologies for many things that have nothing to do with compression
11:16:24 <aristid> edwardk: given that you don't do any bounding it doesn't apply to your LZ78 anyways
11:16:31 <edwardk> the 'speeding up a fold' trick is one example, another example is in the way i do indexing in analytics
11:16:54 <danharaj> edwardk: sounds like you need to write more school posts
11:16:56 <edwardk> aristid: yeah, but my lz78 could use a smaller forgetful window size/lru technique easily
11:17:31 <edwardk> danharaj: probably
11:17:34 <aristid> edwardk: ...and then you have an LZ77-equivalent implemented using LZ78 theory
11:18:02 <edwardk> aristid: yeah LZ78 says nothing about the management of the dictionary, just that you have some strategy
11:18:12 <edwardk> i took the easiest such strategy because my monoids are _expensive_
11:18:27 <aristid> what kind of monoids are you talking about?:D
11:19:22 <edwardk> the easiest example would be to, say, take some DFA for a regular expression
11:19:41 <edwardk> now, consider the symbols of your alphabet over which your regular expression operates.
11:19:53 <kuribas> bennofs: Alright, it already looks better! http://paste.lisp.org/display/138499#1
11:20:17 <edwardk> you can make the 'values' in your monoid be an array from states to states that maps the 'transitions' of where you start to where you end up
11:20:23 <edwardk> the identity of your monoid maps each state to itself
11:20:35 <edwardk> the composition does the lookup to get the composition
11:21:12 <edwardk> you inject the symbols of your alphabet into the monoid by mapping them to their effects, if your DFA recognizes symbol 'c' in state 3 and goes to state 2, the entry for 3 in your array is 2, etc.
11:21:29 <edwardk> now you can show like function composition composition of these tabulations is associative
11:22:02 <edwardk> so take your document, feed it into this monoid (in parallel if you like
11:22:09 <edwardk> then look at the value in the result for the start state
11:22:10 * hackagebot mueval 0.9.1 - Safely evaluate pure Haskell expressions  http://hackage.haskell.org/package/mueval-0.9.1 (GwernBranwen)
11:22:14 <edwardk> and that tells you your ending state
11:22:28 <aristid> so that's for parallel parsing?
11:22:54 <edwardk> i can define a monoid homomorphism from that simpler regular expression-style system into a larger system for parsing context free grammars that uses a similar but more expensive monoid that instead builds up matrices using valiant's algorithm
11:23:17 <edwardk> now i have the regular expression component (my lexer) and my grammar as a context free component in a larger but more expensive system.
11:23:18 <aristid> and the whole "map state to state thing" is to be able to parse parts of the document individually i suppose
11:23:23 <edwardk> eah
11:23:30 <edwardk> so now you can parse in parallel
11:24:08 <edwardk> the fact that the latter monoid is tractable is the subject of Bernardy and Claessen's paper for this year's ICFP: http://www.cse.chalmers.se/~bernardy/PP.pdf and it is why i started thinking about sparse matrix multiplication again
11:24:34 <aristid> it's barely tractable and LZ78 makes it reasonable?
11:24:54 <edwardk> the sequence algebra homomorphism from my regular expression recognizer into the larger system lets me speed up the lexing part, analogous to splitting the lexer from the parser
11:25:12 <edwardk> well, the LZ78 thing was something i just mentioned here as a 'and i could use it with this' in passing.
11:25:27 <edwardk> i used to use it with old parsers that worked similarly but less-efficiently.
11:25:37 <aristid> but it is actually feasible even without finding sharing before running the monoid?
11:25:42 <edwardk> bernardy and claessen's sequence algebra stuff is a better idea than the way i used to do this with my reducers
11:25:47 <edwardk> yeah
11:25:54 <edwardk> they abuse sparsity
11:26:07 <aristid> i guess the nice thing is you can without any problem run the LZ78 on _parts_ on the document and reduce the parts individually
11:26:08 <edwardk> with the LZ78 stuff though you can abuse regularity
11:26:12 <edwardk> yep
11:26:22 <aristid> in parallel
11:26:36 <edwardk> an so you can parse in paralll initially and then keep the results in a finger-tree like construction and parse incrementally in polylog time from there
11:27:06 <edwardk> that is what i want it for. combined with the revision control monad stuff you could in theory have a pretty nice compiler that let you make use of incrementality from start to finish
11:27:34 <edwardk> i keep this in the back of my brain as a 'holy grail' i try to build a bunch of my parsing tech, etc. towards
11:28:24 <aristid> does the parser just become faster?
11:28:29 <aristid> or are there other goals?
11:28:32 <edwardk> it would be very nice in that you can recycle most of your parsing and typechecking online as you go, so you can avoid the type, build, parse cycle
11:28:44 <jmcarthur> it allows you to do incremental parsing with incremental changes, for example
11:28:47 <edwardk> parallel + incremental parsing for free is a big part of the goal
11:29:19 <aristid> edwardk: ah, incremental is big i guess. my clang_complete gives me the slows sometimes. (i don't use anything like that for haskell)
11:29:57 <edwardk> my variants on valiant so far have been tricky to get right though, this is why i started the post on matrix multiplication because i want to showcase a general technique so i can talk to other people about 2-fat matrix decomposition and then have the common vocabulary to talk about the valiant variants i care about
11:30:04 <aristid> and it's slow because even just for compiling an invidual file it reads in the entire many-meg include chain
11:30:49 <edwardk> yeah the nice thing about this is done right in theory you can just recycle most of the previous answer.
11:33:10 <mbrock> Cho0fool_, ReinH: here's a little simple way to do "multimaps" based on monoids in case you're interested: http://goula.sh/~mbrock/SetMap.hs
11:33:15 <aristid> edwardk: so really progressing towards much much smarter parsing is the end goal of most of the things you do?
11:33:29 <edwardk> no, but it is a consistent toy problem i like to play with
11:33:51 <danharaj> parsing is hard, let's go shopping
11:33:58 <edwardk> i find it interesting because it is fundamental to much of what people do in programming. parse in input, do stuff with it, write it back out
11:34:06 <edwardk> so uniform improvements in parsing have a big impact
11:34:12 <jfischoff> @remember danharaj parsing is hard, let's go shopping
11:34:13 <lambdabot> It is forever etched in my memory.
11:34:16 <aristid> edwardk: and it has enough complexity to keep you unbored :P
11:34:29 <Cho0fool_> mbrock: Thank, i'll take a look at this. Haskell comunity is really brilliant, nuff said.
11:34:42 <danharaj> if he ever masters context free grammars, there's always context sensitive grammars of various complexities
11:36:18 <mbrock> Cho0fool_: it's really fun to write Haskell so it's no burden to be helpful :)
11:38:39 <ReinH> mbrock yeah, multimap is a very nice way to leverage monoids :)
11:40:30 <mbrock> I was wondering if there's a typeclass to use instead of Set for the singleton function
11:41:11 <mbrock> um, Monoid is an obvious one
11:42:14 <lispy> edwardk: revision control monad, what?
11:45:05 <mbrock> Cho0fool_: oh duh someone already wrote pretty much my exact code, as an explanatory blog post http://blog.ezyang.com/2010/05/use-the-monoid/
11:45:17 <edwardk> lispy: this is the monad i wound up improving the bounds on online LCA for
11:46:05 <edwardk> lispy: STM is all about rolling back in the presence of an error/disagreement between threads. Rev chooses instead to resolve differences by 3-way-merge.
11:46:21 <lispy> ah
11:46:53 <edwardk> lispy: you make a monad with explicit fork/join/'created versioned variable with specified 3-way-merge-strategy'/read/write variable operations
11:46:53 <BMeph> edwardk: I like it, if only so that we as programmers can use the same tools that the Haskell compiler uses, in the same way (and eventually, in a better way). :)
11:48:30 <ReinH> edwardk: still reading things :)
11:48:45 <edwardk> lispy: basically when you fork you logically get your own copy of all the variables, then when we join to threads together, if they both have made edits we have to use the merge strategy to merge together the two new versions.. with the lowest common ancestor in the fork/join graph
11:49:07 <edwardk> lispy: github.com/ekmett/revisions has the monad and these basic operations
11:49:39 <edwardk> it is based on some work by Daan Leijen who implemented it in c#. he also has a haskell version but its very much 1998 style haskell, explicit IO, forking, etc.
11:49:51 <edwardk> my version uses sparks to run the forked tasks so it scales better
11:50:04 <edwardk> and it doesn't require explicitly discarding a forked task you don't join with
11:51:24 <edwardk> lispy: anyways, this approach works 'okay' what i described above is enough to get 3-4x speedup on 8 cores. nothing earth shaking, but better than a sharp stick in the eye. but we can do better!
11:51:46 <edwardk> most systems that give you a decomposition for parallelism also give you a notion of incrementality if you look at them cross-eyed
11:51:52 <edwardk> this is no exception
11:52:48 <edwardk> so we can make up a notion of 'recording' an action, that takes Rev s a -> Rev s (a, Rev s a)  -- it takes your monadic action, and runs it and gives you back another monadic action that has the same semantics as the original, but is optimized
11:53:21 <lispy> neat
11:53:32 <edwardk> in particular if the portions of the environment that it uses haven't changed you can just reuse its changes to the environment and answer directly!  if not, then look at the last join in the fork graph and repeat the analysis recursively
11:53:49 <edwardk> this means you can now share results if your environment is substantially similar to before.
11:54:28 <edwardk> so you can go back and take your monadic computation for, say, game physics or scene rendering, and run it after your first frame, then modify your world, and re-run it, sharing the bulk of the unchanged bits
11:54:36 <edwardk> then keep re-running it as you modify the world
11:55:18 <edwardk> so the while {1} { mutate(); compute(); }  loop can let you do less work in the compute phase.
11:55:22 <edwardk> er while(1)
11:55:37 <ReinH> edwardk: btw I actually understand Iso now :D Shouldn't have been that hard but my brain works in strange and mysterious ways.
11:56:12 <edwardk> now, we get some interesting super-linear speedup on multiple cores. on 8 cores an algorithm decomposed for doing CSS layout goes from 2-3x speedup after decomposing it for parallelism to 22x speedup!
11:56:27 <edwardk> (for small edits, like people typing in a text box, etc)
11:56:41 <ReinH> edwardk: that's super efficient!
11:56:54 <ReinH> given max speedup is 24x
11:57:15 <edwardk> ReinH: its super-linear. 8 cores, so best should be 8x ;)
11:57:35 <edwardk> the extra comes from newfound incrementality
11:57:47 <ReinH> edwardk: I was assuming an 8x multiplier on the 3x?
11:57:59 <edwardk> th 3x was already the parallelism speedup
11:58:00 <ReinH> oh I see
11:58:03 <ReinH> reading.
11:58:11 <ReinH> also wtf hax
11:58:17 <c_wraith> incrementality mattering because it means less GC pausing?
11:58:38 <edwardk> c_wraith: incrementality mattering because it reuses previous computations, not incremental GC
11:58:42 <c_wraith> ah
11:58:51 <c_wraith> that's even more useful
11:59:09 <edwardk> lispy: an example of this can be seen by writing a type checker this way.
11:59:21 <c_wraith> I was just thinking of the way you often lose performance on multiple cores with tasks that don't yield to the GC enough.
11:59:26 * monochrom has a cunning plan! if you have just 2 cores, use virtual machine to pretend 8 cores so you can enjoy the 8-core algorithm :)
11:59:39 <edwardk> now we can do unification for the original problem, and reject it, saying the program is bad.  but we might 'censor' part of the input, like a quickcheck shrink and try it again
11:59:46 <edwardk> most of the unification steps will be the same
11:59:47 <c_wraith> monochrom: my handy VM won't let me tell the client there are more cores than there actually are. :(
11:59:52 <edwardk> if we get the same error, repeat
11:59:58 <edwardk> otherwise censor different parts
12:00:23 <edwardk> in the end you get the set of all locations in the initial program you have to look at to resolve a given type error, not just the two points that failed to unify
12:00:44 <edwardk> this is a version of type error slicing built by swapping out the monad in which you do unification rather than by constraint handling rules
12:01:10 <ReinH> edwardk: holy shit loeb is magic
12:01:11 <edwardk> in particular it is useful because most of those extra runs of the type checker are fast. we have to remove O(n) locations and run the type checker each time
12:01:17 <edwardk> ReinH: hahahahah
12:01:30 <ReinH> what in the actual...
12:01:58 <ReinH> Dan Piponi is seriously a wizard
12:02:45 <ReinH> edwardk: I love how he basically did a hoogle search of all his books to find something that had a similar type
12:02:49 <ReinH> this is basically how math works isn't it?
12:03:11 <monochrom> how applied math works
12:03:19 <edwardk> ReinH: you can do the same thing by tying the knot, its just a nice pattern.
12:03:19 <ReinH> find a similar structure with some known properties and then see how many of those properties carry over
12:03:27 <monochrom> for pure math, you have to write the books in the first place
12:03:52 <ReinH> monochrom: in order to construct the Yoneda lemma, you must first invent the universe? Or something?
12:03:59 <edwardk> the fact that we can move between logic, category theory and code is damn useful
12:04:18 <edwardk> each focuses on different parts of the elephant
12:04:29 <ReinH> yep, and Haskell somehow magically gives us that bridge
12:04:31 <paolino> hello, how Prism compose with Lens  ?  IE. I have Either a (b,c), I need to modify c
12:04:32 * structuralist pays tribute to the Holy Trinity
12:04:49 <edwardk> > Left (1,2) & _Left._2 .~ "hello"
12:04:51 <lambdabot>   Left (1,"hello")
12:05:39 <monochrom> the elephant in the chinese room
12:05:41 <ReinH> damn, beat me
12:05:46 <edwardk> ReinH: well, the Curry-Howard-Lambek-de Bruijn-"everyone and their brother that we want to thank today"  correspondence gives us the bridge
12:05:47 <paolino> >  _Left._2 .~ "hello" $ Right 1
12:05:48 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field2
12:05:49 <lambdabot>                      s0 t a0 [G...
12:06:02 <edwardk> paolino: doesn't know the type
12:06:19 <paolino> >  _Left._2 .~ "hello" $ Left (1,2)
12:06:20 <lambdabot>   Left (1,"hello")
12:06:28 <edwardk> > Right "wut" & _Left._2 .~ "hello" :: Either (Int,String) String
12:06:29 <lambdabot>   Right "wut"
12:06:50 <edwardk> > Left (1,2) & _Left.traverse .~ "hello"
12:06:51 <lambdabot>   Left (1,"hello")
12:06:56 <edwardk> > Right () & _Left.traverse .~ "hello"
12:06:57 <lambdabot>   No instance for (Data.Traversable.Traversable t0)
12:06:57 <lambdabot>    arising from a use of ...
12:07:22 <edwardk> problem there is picking the instance. it doesn't know what Traversable to use for the left hand side. so you need a type annotation
12:07:43 <S_J> ^^ What do I need to do here: http://lpaste.net/91922 <- cabal problem with reactive banana threepenny
12:08:03 <paolino> ok, they just compose if the type is known, ghci has been a bad playground, thanks
12:08:07 <ReinH> edwardk: I mostly blame Church.
12:08:10 <edwardk> paolino: yeah
12:08:31 <ReinH> or, equivalently, Turing
12:08:43 <ReinH> depending on which day of the week it is mod 2
12:08:58 <ReinH> axiom of choice jokes, everyone...
12:11:04 <applicative> S_J: well, you can do ghc-pkg unregister wai  and likewise warp hoogle
12:11:54 <applicative> hashable case-insensitive vault reactive-banana
12:12:03 <amyers> ReinH: What are you reading?
12:12:39 <ReinH> amyers: ?
12:13:39 <amyers> ReinH: Sorry reading back through what you and edwardk were saying
12:14:16 <amyers> you kept referencing something you were reading, it was an interesting conversation and was wondering if you had pointers to reading material :p
12:14:23 <nimish_> is cloud-haskell dead?
12:14:26 <applicative> S_J then reinstall them
12:14:30 <nimish_> there hasn't been an update in months
12:14:31 <applicative> nimish_: no, it's finished
12:14:38 <ReinH> amyers: http://programmers.stackexchange.com/questions/207665/haskell-memory-efficiency-which-is-the-better-approach/207781#207781
12:15:02 <edwardk> amyers: i sent him to http://programmers.stackexchange.com/questions/207665/haskell-memory-efficiency-which-is-the-better-approach/207781#207781 after explaining the connection between SLP and LZ78/LZ77/LZW, this is in the context of 'hash-life' and the recent post i did on cellular automata based on talking to Rein here on channel.
12:15:09 <aristid> nimish_: no update in _months_ does not say that anything is dead :D if it was years, you might need to worry more
12:15:15 <c_wraith> It's really sad that foldl doesn't fuse.  Because it really would make sense.
12:15:27 <amyers> edwardk: Is your blog back up or do you have a new one?
12:15:42 <aristid> edwardk: it seems to me like LZ78 is really the general case, and LZ77 and LZW are specific versions of it
12:15:48 <edwardk> amyers: i've decided to start posting to https://www.fpcomplete.com/user/edwardk
12:15:49 <applicative> nimish it's called distributed haskell
12:15:56 <edwardk> aristid: yeah
12:16:12 <edwardk> aristid: most of the variant LZ things are just different ways to write SLPs though
12:16:23 <amyers> edwardk: Sweet :)  thanks for the link :)  Do you have any pointers on where to start with the sharing stuff you were talking about?  I'm a dumb programmer, just started reading about CT
12:16:34 <edwardk> aristid: once you take the SLP formalism as the fundamental thing then the fact that the LZ variants work is obvious
12:16:46 <aristid> edwardk: well, maybe you should rename your LZ78 type SLP then?:D
12:16:48 <edwardk> amyers: sharing being observable sharing?
12:17:06 <edwardk> aristid: well, my LZ78 type is just the LZ78 case, not the general SLP solution
12:17:11 <applicative> nimish_: https://github.com/haskell-distributed
12:17:17 <amyers> edwardk: The thing you were saying you got 22X speedup on an 8 core machine by sharing results with old versions
12:17:18 <edwardk> the general SLP version would permit the introduction of new terminals _and_ merging
12:17:22 <nimish_> applicative: yeah that's what I meant; last update seems to be from Jan
12:17:24 <aristid> edwardk: ah
12:17:33 <edwardk> amyers: oh that thing. i can point you to papers by daan leijen
12:17:39 <nimish_> applicative: and distributed-process-platform doesn't seem to build for me either
12:17:41 <aristid> edwardk: but LZW and LZ77 are subsets of LZ78 itself, not just SLPs?
12:17:42 <amyers> edwardk: Would be much appreciated :)
12:17:43 <edwardk> amyers: sorry, 2-3 discussions involving different notions of sharing going on
12:18:00 <danharaj> you guys are thrashing edwardk's cache
12:18:06 <amyers> edwardk: haha, I'm trying to learn as much as I can so pointers to all  of them might be helpful
12:18:13 <edwardk> aristid: no. LZ78 only appends a literal to an existing entry, the others just emit dictionary slot #s rather than dictionary #, terminal pairs.
12:18:18 <amyers> danharaj: haha
12:19:18 <aristid> let me defer to the other discussions and not thrash the cache anymore.
12:19:36 <amyers> likewise, I will be off reading now that I have two references
12:19:41 <edwardk> amyers: http://research.microsoft.com/en-us/projects/revisions/ in particular the original http://research.microsoft.com/apps/pubs/default.aspx?id=150431 paper and http://research.microsoft.com/apps/pubs/default.aspx?id=150180 the latter is about the record primitive
12:19:45 <amyers> any more are appreciated and will be added to the list though :)
12:19:56 <S_J> "hashable case-insensitive vault reactive-banana" huh?  and if i unregister wai and warp and hoogle what happens, maybe i have other libs. why do i need to unregister stuff?
12:20:18 <amyers> edwardk: Thanks, will stop thrashing your cache now :)
12:20:26 <danharaj> Daan Leijen is a cool guy.
12:20:39 <edwardk> amyers: the notion of sharing intermediate results by observable sharing or other means is kind of a central theme to many of my favorite toys though
12:20:52 <amyers> edwardk: It sounds very useful
12:20:59 <amyers> edwardk: From what you were saying
12:21:04 <edwardk> hence the discussion about the LZ78 monad in http://hackage.haskell.org/packages/archive/compressed/3.0.3/doc/html/Data-Compressed-Internal-LZ78.html
12:21:22 <ReinH> edwardk: I'm writing out loeb [length] so I can figure out wtf this magic does
12:21:24 <edwardk> and the general notion of SLP and hashlife in the context of the automata discussion, etc
12:21:34 <edwardk> :t loeb
12:21:35 <lambdabot> Not in scope: `loeb'
12:21:38 <amyers> edwardk: SLP?
12:21:40 <edwardk> shucks someone reset it
12:21:50 <S_J> cabal says: "Continuing even though the plan contains dangerous reinstalls." why dangerous?
12:21:53 <applicative> nimish_: i'm not having any trouble building distributed-process or distributed-process-platform what version of ghc are you using
12:21:56 <edwardk> @let loeb x = fmap (\a -> a (loeb x)) x
12:21:57 <lambdabot>  Defined.
12:22:00 <edwardk> > loeb [length]
12:22:04 <lambdabot>   [1]
12:22:06 <ReinH> I mean, I know it's [1]
12:22:10 <ReinH> but I need to know how
12:22:13 <edwardk> > loeb [length,(!!0)]
12:22:16 <lambdabot>   [2,2]
12:22:21 <applicative> S_J: just unregister the things it's about to overwrite first
12:22:21 <jmcarthur> ah that's a cool function
12:22:31 <edwardk> > loeb [length,(!!0),\x -> (x!!1) + 1]
12:22:34 <lambdabot>   [3,3,4]
12:22:42 <jmcarthur> couldn't that be defined to share more?
12:22:45 <edwardk> it does
12:22:54 <S_J> applicative: too late :(
12:23:03 <jmcarthur> that definition reapplies leob to x
12:23:08 <nimish_> applicative: 7.6.3/ OSX 10.8.4 distributed-process-platform's not on Hackage; when I install from a cloned github repo I get Module `Control.Distributed.Process' does not export `Message'
12:23:09 <edwardk> you mean loeb x = xs where xs = fmap (\a -> a xs) x
12:23:11 <edwardk> ah yes
12:23:14 <edwardk> i took a naive one
12:23:18 <edwardk> @undefine
12:23:19 <lambdabot> Undefined.
12:23:24 <edwardk> @let loeb x = xs where xs = fmap (\a -> a xs) x
12:23:25 <lambdabot>  Defined.
12:23:36 <edwardk> @undefine
12:23:37 <lambdabot> Undefined.
12:23:42 <edwardk> @let loeb x = xs where xs = fmap ($xs) x
12:23:43 <lambdabot>  Defined.
12:23:49 <merijn> nimish_: And how do you know the github repo is in a buildable state?
12:24:14 <structuralist> where's a good place to learn about performance issues in haskell? like sharing
12:24:19 <nimish_> merijn: I don't but it's the only place to get distributed-process-platform :p
12:24:24 * structuralist has zero background in algorithms or data structures
12:24:47 <edwardk> jmcarthur++ # better loeb
12:25:09 <edwardk> thats better than the one i was using everywhere
12:25:13 <edwardk> hadn't noticed the issue
12:25:47 <jmcarthur> how have you been using this?
12:25:58 <jmcarthur> and what does loeb stand for?
12:26:29 <structuralist> Löb
12:26:29 <c_wraith> It's a name
12:26:48 <applicative> merijn: I just built it twice without trouble
12:26:48 <jmcarthur> ah
12:28:05 <nimish_> applicative: If I switch to the development branch of distributed-process, there's a build issue with Hashable
12:28:13 <edwardk> jmcarthur: http://en.wikipedia.org/wiki/L%C3%B6b%27s_theorem
12:28:22 <nimish_> well, a missing instance involving hashable
12:29:03 <edwardk> The Gödel-Löb axiom looks a lot like that combinator replacing the functor with a modality
12:29:42 * danharaj goes off to look at the curry-howard of modal operators
12:30:07 <edwardk> danharaj: most of the time they become monads or comonads
12:30:14 <danharaj> interesting
12:30:26 <edwardk> (!) forms a comonad in linear logic for instance
12:30:28 <ReinH> edwardk: so I get that for an appropriately defined Nim (x -> a), we can do [(!!1), 5]
12:30:44 <ReinH> *Num
12:30:53 <danharaj> edwardk: speaking of which, FinSet -> *, Lawvere Theories, Operads, and Monads all are related in a way that I am currently disentangling.
12:31:13 <edwardk> ReinH: what i do in that post is take my Map full of integers and replace it with the map full of functions from the map to the expanded matrix grammar, then loeb to get the full grammar
12:31:30 <ReinH> edwardk: what I don't get is how loeb ties the knot
12:31:47 <edwardk> you pass the result into the functor using strength and laziness
12:31:50 <ReinH> oh duh
12:31:54 <ReinH> it's doing length [length]
12:31:57 <edwardk> loeb x = xs where xs = fmap ($xs) x
12:31:57 <jmcarthur> so loeb preserves structure and replaces leaves with observations about the structure
12:32:01 <edwardk> yeah
12:32:06 <ReinH> duh
12:32:07 <ReinH> awesome
12:32:17 <edwardk> jmcarthur: yep
12:32:37 <ReinH> ok that was a big missing piece for me
12:32:39 <ReinH> reading on
12:33:23 <edwardk> ReinH: you can implement the routine i describe in that post naively using recursion, but this gets sharing in memory between all the distinct productions in the grammar
12:34:06 <edwardk> its something you have to be remarkably pedantic or memory hungry to care about… or if you plan to use observable sharing later to recover a new matrix grammar it can be useful
12:34:31 <edwardk> a fun exercise is to write a form of fmap that tries to use observable sharing to avoid redundantly expanding heavily shared structures.
12:34:52 <ReinH> edwardk: is this generally possible for all functors?
12:35:01 <edwardk> it is _just_ doable with GHC.Generics and Rep1
12:35:05 <edwardk> no
12:35:14 <ReinH> so you can't write Functor f => Sharable f
12:35:16 <ReinH> shame
12:35:33 <Banistergalaxy> Reinh are you working your way through the Marlow concurrency book?
12:35:36 <edwardk> no, but given a Generic1 instance for f you can derive Sharable f
12:36:01 <edwardk> a similar sharing issue arises in traversals. many nodes are just pure liftings of the other nodes from the original, with their types changed
12:36:02 <ReinH> Banistergalaxy: in parallel to edwardk's detonating of supernovae in my brain, yes
12:36:04 <applicative> nimish_: https://github.com/haskell-distributed/distributed-process/tree/development https://github.com/haskell-distributed/distributed-process-platform/tree/development
12:36:06 <edwardk> so traverse also murders sharing
12:36:10 <ReinH> I'm not sure my brain can contain all the awesome
12:36:19 <applicative> nimish_: i.e. clone blah --branch development
12:36:55 <nimish_> applicative: done that, might try deleting cabal's caches entirely and trying again
12:37:01 <jmcarthur> hmm. it has the same expressivity as    Functor f => (forall a. f (f a -> f b)) -> f b    but is able to share more
12:37:06 <edwardk> now you can see why i care, because if i can come up with a nice formulation of the sharing problem i can make a form of traversal that recovers sharing
12:37:15 <ReinH> edwardk: so loeb grammar folds the grammar until it produces all the terminals
12:37:32 <edwardk> ReinH: yeah, in one pass by setting up thunks in all the right places for the final answers
12:37:40 <ReinH> it's a fixed point functor combinator that shares
12:37:41 <ReinH> wow
12:37:42 <edwardk> then pulls it tight by tying the knot
12:37:43 <ReinH> magic
12:37:52 <ReinH> ok then
12:38:07 <edwardk> so you wind up removing all the lookups in the map and replacing them with direct pointers to the right thunk
12:38:14 <jmcarthur> i see, so what i said is almost precisely the difference you are interested in
12:38:17 <edwardk> after the GC runs and tightens everything its like you hand wrote the sharing
12:39:18 <edwardk> jmcarthur: not sure i follow the expressivity argumnt
12:39:40 <edwardk> the f (f b -> b) -> f b     is needed because otherwise i get an f (f b) in the end
12:39:44 <jmcarthur> anything you can write with loeb you can write with a function of the type i just gave instead
12:39:50 <ReinH> edwardk: so fix with sharing: fix f = xs where xs = f xs
12:39:55 <ReinH> this is that for functors
12:40:04 <jmcarthur> oh woops
12:40:07 <edwardk> jmcarthur: i can look at other cells
12:40:10 <jmcarthur> i think i had an extra f in there
12:40:12 <edwardk> i can't in yours
12:40:28 <edwardk> jmcarthur: how can i add one to the content of the third cell with yours?
12:40:39 <ReinH> edwardk: except your first version is the naive version and jmcarthur's version is the one with more sharing
12:40:42 <ReinH> this actually makes sense
12:40:44 <ReinH> I am so excite
12:40:57 <edwardk> > loeb [length, (+1).(!!0)]
12:41:00 <lambdabot>   [2,3]
12:41:01 <jmcarthur> ReinH: we are talking about a (wrong) type i added to the conversation a bit after that part
12:41:13 <ReinH> jmcarthur: yeah but I'm still playing catch up :)
12:41:19 <ReinH> so I'm still on that part
12:41:35 <edwardk> jmcarthur: how do you write that with your (forall a. f (f a -> f b)) -> f b
12:42:03 <edwardk> or (forall a. f (f a -> b) -> f b  even
12:42:08 <edwardk> here i care that f is wrapped around b's
12:42:13 <jmcarthur> edwardk: right, with mine you would have to do   foo [length, (+1) . length].   i'm assuming you can vary the input to loeb to achieve the same results.
12:42:13 <edwardk> not just that its forall a.
12:42:30 <edwardk> jmcarthur: the problem is the point of loeb is to get that spreadsheetification
12:42:35 <jmcarthur> right
12:42:41 <jmcarthur> that's why i said that was the significant difference
12:42:46 <edwardk> yeah
12:43:07 <edwardk> so basically the argument seems to be you can do loeb your way so long as you only want to work with the boring parts =)
12:43:26 <edwardk> perhaps a better way to do it would be to shove your forall down deeper
12:43:33 <edwardk> so its clearly a limit
12:43:59 <edwardk> f (f () -> b) -> f b
12:44:06 <jmcarthur> ah that would be better yeah
12:44:30 <edwardk> then you can do it cleanly using mere strength.
12:44:37 <jmcarthur> when i was first typing it up i had a Void there, realized that was wrong, then just went with forall a
12:44:37 <edwardk> that can always be implemented, even in agda
12:44:37 <aristid> would loeb work in a strict-evaluation language?
12:45:00 <edwardk> but it loses the power that makes loeb magic
12:45:03 <jmcarthur> right
12:45:14 <edwardk> aristid: no, loeb is a non-strict thing
12:45:30 <edwardk> its about tying the knot
12:45:56 <applicative> nimish_: see https://github.com/haskell-distributed/network-transport/tree/development not the last patch
12:46:01 <ReinH> edwardk: ok, so where were we? SLPs and loeb?
12:46:29 <edwardk> ReinH: so, lets go look at the lz78 code for a second again. because i want to indoctrinate you in a trick i like
12:46:35 <ReinH> yay!
12:46:38 <edwardk> figure out the LZ78 Applicative instance
12:46:54 <ReinH> ok I'm there...
12:47:21 <edwardk> and given that we can describe a way to make "multiplication" of matrix grammars/SLPs
12:48:04 <ReinH> edwardk: ok, so a pure a is a an initial rule 0 that produces an a
12:48:09 <edwardk> the applicative works by saying 'i don't know anything about 'a', but i know its not in the dictionary, so pure must just emit the token [(0,a)]
12:48:47 <edwardk> then we can apply them by saying i don't know anything about the functions in this left LZ78 stream  and i know nothing about the values in this other LZ78 stream… but i can assume they are all different!
12:49:31 <edwardk> and worst case scenario when i encode the new LZ78 stream using the equality of the pairs of 'what production did this come from' as the notion of equality, i lose some sharing over the ideal coding, but i get a legal LZ78 sequence
12:49:51 <jmcarthur> edwardk: i just read over some history. you've been bringing up observable sharing a lot. do you mean this in the sense of a data-riefy thing, a memo combinator thing, or something else?
12:50:00 <edwardk> jmcarthur: data-reify sense
12:50:26 <edwardk> we're talking about the cellular automata example i posted last night and how to 'hash-life' it
12:50:48 <edwardk> i figured it might be worth doing a second post that can show w can teleport a few quadrillion steps into the future on many of them.
12:50:49 <jmcarthur> edwardk: it's pretty easy to use StableName-based memoization to do things like write a map that preserves sharing
12:51:16 <edwardk> jmcarthur: exactly, and then using that stablename based thing i can spit out a 'grammar'… thats exactly the graph from data-reify
12:51:27 <edwardk> you're spitting out my punchline ;)
12:51:30 <jmcarthur> edwardk: you can even write generic recursion schemes with it without much effort
12:51:35 <jmcarthur> ah
12:52:10 <edwardk> but what i wanted to show is that you can do things like 'add' matrix grammars by tabulating intermediate results even if you don't know what they are
12:52:26 <jmcarthur> i see
12:53:26 <edwardk> in particular i care about matrix grammars here so all my terminals are at the same height.
12:53:39 <edwardk> so i can 'zip' two matrix grammars together to add them
12:53:48 <edwardk> and go and add the corresponding terminals together
12:54:01 <ReinH> edwardk: so what you're heading towards is a 'loebified' automatic shares the production of new generations from previous generations, assuming we use a data structure that allows such sharing
12:54:04 <edwardk> and when i go to add to two non-terminals i can look up the addition in a map of what non-terminals i've added together, etc.
12:54:10 <edwardk> ReinH: yep
12:54:11 <ReinH> *loebified automata
12:54:13 <edwardk> well
12:54:23 <edwardk> we work in the grammar, and expand it to the loebified form to show
12:54:31 <ReinH> edwardk: so Store doesn't work because you can't share an infinite universe
12:54:42 <jmcarthur> it's a loebotomy
12:54:47 <edwardk> but we can say how far information can have traveled
12:54:59 <ReinH> right, the speed of light lets us use a tree structure
12:55:00 <edwardk> so we just have to deal with a tree covering some band around the origin
12:55:05 <ReinH> where the tree expands at the speed of light
12:55:08 <edwardk> yep
12:55:16 <ReinH> which is exactly what hashlife does
12:55:38 <edwardk> then the trick becomes taking multiple steps in the universe by trying to make states that made out smaller states… hashing them basically
12:55:50 <edwardk> so we can run larger grain steps through time/space
12:55:55 <edwardk> and you get hashlife
12:56:02 <edwardk> thats all
12:56:07 <ReinH> and rather than explicitly memoizing the "previous local universe to new local universe", we loebify the comonadic effect to get the sharing for free?
12:56:29 <ReinH> assuming that we can join up the local universes into a larger universe
12:56:31 <edwardk> well, the loebification is just used to show it to the user. to expand it out of the matrix grammar
12:56:48 <S_J> I thought reactive banana was only a GUI lib but it is a geenral function reactive programming lib which' also you can write GUI:s in?
12:57:02 <edwardk> in the end you want to look at the 142 quadrillionth step of your automata
12:57:10 <edwardk> so loebify it and look at the entries
12:57:12 <ReinH> edwardk: right, so the grammar in this case is the rules for evolving the local universe
12:57:17 <edwardk> yeah
12:57:18 <jmcarthur> S_J: it doesn't even have anything for GUIs, as far as i know
12:57:24 <edwardk> and we build more complicated steps out of simpler steps
12:57:30 <ReinH> yep
12:57:44 <ReinH> and loeb does that for us automatically with sharing
12:57:47 <edwardk> so before we were a store looking at our neighbors and calculating a new cell.
12:57:49 <edwardk> no
12:57:50 <ReinH> no
12:57:56 <edwardk> again loeb is only for the last step to show it
12:58:01 <ReinH> ah
12:58:06 <ReinH> loeb lets us *evaluate* with sharing
12:58:17 <ReinH> i.e. produce the string
12:58:21 <edwardk> now we're a store looking at our neighbors, but we and our neighbors are big composite cells
12:58:28 <edwardk> yep
12:58:39 <edwardk> so the trick is to build a new store out of smaller stores
12:58:56 <edwardk> and to do so intelligently (hash-cons/hash-life)
12:58:58 <ReinH> edwardk: so just like LZ encoding starts with a single production, we start with an initial state
12:59:07 <edwardk> yep
12:59:12 <ReinH> brilliant
12:59:38 <edwardk> then we track what do to at the small scale for the 000,001,010,011,100,101,110,111 cases. those get tabulated at level 0
12:59:43 <ReinH> yep
12:59:43 <edwardk> now, we have to move up to bigger squares
12:59:51 <ReinH> and combinations of those get tabulated at level 1
12:59:52 <ReinH> and so on
12:59:53 <edwardk> there are some warts in scaling up
12:59:57 <edwardk> just like there are with hash-life
13:00:06 <edwardk> but the same strange alignment tricks they use work
13:00:21 <ReinH> well that is just fabulous
13:00:50 <edwardk> anyways that was all i was saying when i said we can hash-life this rep ;)
13:00:56 <ReinH> "all"
13:00:57 <ReinH> right
13:01:00 <ReinH> obv
13:01:16 <edwardk> then the 'loop' function ceases to just be tabulate and extend, but rather tabulate and expand
13:01:27 <ReinH> so this should be called the loeb combinator?
13:01:40 <edwardk> well, loeb is the loeb combinator =)
13:01:53 <ReinH> "this" = loeb, yes
13:01:53 <edwardk> so it depends on which this was the antecedent you meant
13:01:57 <ReinH> sorry
13:02:11 <edwardk> and yeah the loeb combinator is a nice toy
13:02:15 <ReinH> right, so rather than taking in the entire previous universe, you take in your local universe, which is composed of other compositions of local universes, up to some base production
13:02:21 <ReinH> and loeb walks this structure with sharing
13:02:23 <edwardk> i use it as a 'design pattern' to think about knot tying a lot
13:02:42 <edwardk> well, loeb doesn't give us the memoization, etc.
13:02:54 <edwardk> it gives us sharing in the result off some grammar
13:02:59 <aristid> it's the LZ that generates the sharing, right?
13:03:01 <edwardk> we still have to compute the grammar
13:03:04 <edwardk> yeah
13:03:14 <ReinH> right, it doesn't explicitly memoize, we have to pick a grammar that allows for sharing
13:03:22 <edwardk> its running the store on SLP-d fragments
13:03:46 <ReinH> which recursively find thunks for the rules they are composed by
13:03:50 <ReinH> and those thunks are shared
13:03:56 <ReinH> *composed of*
13:04:18 <edwardk> the thing we've won is that for each universe size we have a set of all the productions we've seen of that size, so many of the triples of them we compose will be redundant
13:04:22 <edwardk> and the answer already known
13:04:33 <ReinH> right, and those triples are shared at the thunk level
13:04:41 <edwardk> well, explicitly in the grammar level
13:04:46 <ReinH> ah
13:04:52 <edwardk> but finally when we show it to the user implicitly in the loeb expansion of the grammar
13:05:09 <ReinH> right, it's tying the knot onto "previous" grammar rules
13:05:12 <edwardk> yeah
13:05:30 <edwardk> each step we're a quad-tree level 'larger' in time and space.
13:05:41 <ReinH> right, bounded by c
13:05:51 <edwardk> so long as our automaton is regular enough we can quickly jump through time
13:05:55 <ReinH> (the upper bound for growth)
13:06:03 <edwardk> if it is rule 110, then we probably can't reduce it too far ;)
13:06:29 <ReinH> right, the more chaotic automata will have less sharing among "production rules"
13:06:43 <edwardk> but e.g. rule 222 will tabulate trivially as there are only really 2-3 types of cells for each level
13:07:11 <edwardk> so do to a billion steps you need ~60-70 states
13:07:28 <ReinH> and interestingly, the runtime is a function of the automata's entropy
13:07:33 <edwardk> yep
13:08:02 <ReinH> "how random-seeming is this automata" = "how long does it take to compute"
13:08:08 <ReinH> that's neat in and of itself
13:08:19 <edwardk> well, not quite
13:08:27 <edwardk> we only exploit a certain form of sharing
13:08:37 <aristid> did you switch from discussing sparse matrices do automata now? :D
13:08:48 <ReinH> aristid: we were always discussing automata :)
13:09:09 <edwardk> aristid: ReinH likes automata so i talk about automata with him. danharaj likes category theory, so i talk about category theory with him. ;)
13:09:22 <aristid> edwardk: and who likes sparse matrices?
13:09:27 <edwardk> aristid: me
13:09:27 <ReinH> well, automata are what make comonads intuitive for me
13:09:29 <danharaj> pfft automata are just coalgebras
13:09:34 <edwardk> so i talk about them with everybody
13:09:40 <aristid> edwardk: ah
13:09:43 <ReinH> so I'm latching onto them like a life boat in a storm :)
13:09:46 <edwardk> danharaj: i use the store-comonad coalgebra in that post =)
13:10:06 <danharaj> edwardk: yeah I saw. I like the bit on bazaar. I'd like to see more on that.
13:10:07 <edwardk> danharaj: er i use them as
13:10:32 <edwardk> danharaj: i threw the technical aside in to hold the interest of the lenserati ;)
13:11:30 <ReinH> edwardk: and it actually makes perfect sense that if compression is monadic then decompression would be comonadic. One is creating a monadic context from a value and the other is creating a value from a comonadic context.
13:12:28 <edwardk> ReinH: not sure i follow
13:12:37 <ReinH> edwardk: extract . join = id
13:12:44 <ReinH> decompress . compress = id
13:13:05 <edwardk> extract . join = id is something you aren't guaranteed though
13:13:21 <edwardk> that requires some kind of relationship between your monad and your comonad.
13:13:47 <edwardk> :t extract . join
13:13:47 <lambdabot> Not in scope: `extract'
13:13:48 <lambdabot> Not in scope: `join'
13:13:50 <ReinH> right, they are dual
13:13:56 <ReinH> (for lossless compression)
13:14:08 <ReinH> or isomorphic, or whatever is the correct term
13:14:10 <edwardk> elliott: lambdabot is being dumb
13:14:25 <ReinH> or, they must be isomorphic
13:14:38 <edwardk> i have no idea what you are talking about right now
13:14:41 <ReinH> edwardk: sorry
13:15:41 <ReinH> edwardk: so if you have iso compress decompress
13:16:48 <ReinH> you can implement LZ compression as a monad, right?
13:17:05 <edwardk> well, the monad for LZ78 is sneaky
13:17:11 <ReinH> edwardk: just in general terms
13:17:17 <edwardk> well it doesn't work like that
13:17:21 <ReinH> ok
13:17:31 <edwardk> the problem is i can't see the values in your LZ78 stream
13:17:37 <edwardk> they can be functions, all sorts of things
13:17:45 <edwardk> but i can use the same quotienting trick
13:17:50 <edwardk> i can assume that every one is distinct
13:18:14 <edwardk> LZ78 (LZ78 a) -> LZ78 a    then needs to basically take the positions in the token stream of token streams
13:18:26 <edwardk> and get out a composite key
13:18:38 <edwardk> then use the composite key to build a new LZ78 using equality on the key
13:18:44 <ReinH> edwardk: so let's just talk about LZ compression of [Char]
13:19:15 <ReinH> LZ78 (LZ78 String) adds new production rules to the dictionary, right?
13:19:19 <edwardk> LZ78 a -> LZ78 (Int, a)     can be done as an evil operation that    just tracks how far down the list of tokens you are and just augments each 'a' with an Int
13:19:32 <aristid> edwardk: that's "entries", right?
13:19:36 <edwardk> aristid: yeah
13:19:41 <ReinH> er
13:19:45 <edwardk> its inherently evil
13:19:51 <edwardk> bcause it exposes details the user shouldn't see
13:20:58 <edwardk> the trick is the 'Int' there determines the a associated with it
13:21:01 <ReinH> edwardk: is it incorrect to think of LZ compression as a function from [a] to a dictionary of production rules with a known initial rule?
13:21:26 <edwardk> that is correct
13:21:49 <ReinH> where rules must be recursively walked from the initial to produce the original list
13:23:05 <edwardk> a token at position k in the stream (Token j t)       represents two new productions in my grammar logically.    T_k ::= t       and NT_k ::= NT_j T_k
13:24:04 <edwardk> we can pretend that each of the T_k are distinctly identified by k
13:24:08 <edwardk> even if they aren't
13:24:54 <edwardk> fmap for LZ78 does just that
13:25:09 <edwardk> you get a new perfectly valid LZ78 stream
13:25:24 <edwardk> it may not be the optimal thing you could have encoded
13:25:26 <edwardk> but its valid
13:27:16 <ReinH> edwardk: so another way to say that is you don't need an Eq constraint since you can just consider all terminals distinct at a loss of some efficiency?
13:27:24 <edwardk> yep
13:27:32 <edwardk> decoding doesn't care about the 'a's at all
13:27:50 <ReinH> right, it cares that it can produce an a
13:27:57 <edwardk> that was the observation that led to 'compressed'
13:28:14 <edwardk> the usual meaning is to decompress in the list monoid basically
13:28:26 <edwardk> but i can decompress in any target monoid just as easily
13:28:43 <edwardk> so if you have an LZ78 Int  and you want its sum, ala Sum foldMap will compute it very quickly
13:29:03 <edwardk> because the dictionary entries it builds during decompression will just be numbers
13:29:08 <ReinH> right
13:29:45 <edwardk> if we use the Applicative, it'll build a new stream assuming each entry in each of the input streams was distinct, using just the tuple of their indices into their streams as uniqueness information
13:30:02 <edwardk> but because there is a lot of sharing in that you can actually recover decent sharing in the result.
13:31:07 <edwardk> [(0,x),(1,y),(2,x)] = xxyxyx  but by slot it is 001012
13:31:24 <edwardk> so the x = z info was a very small part of out sharing
13:31:31 <edwardk> so recovering by slot # costs us little
13:31:53 <edwardk> er slot # would be 112123 actually
13:31:55 <edwardk> but still
13:32:16 <edwardk> (well, with 0 offset i had it right the first time)
13:32:47 <edwardk> in any event, now, if we have a LZ78 (LZ78 a)  i can get out the pair of slot #'s and i lose a bit of sharing but not much
13:33:18 <edwardk> and with that LZ78 forms a monad
13:33:46 <edwardk> you can do things like use it as an Alternative or MonadPlus as well, but the encoding isn't something you want to use that way very often ;)
13:35:49 <FreeFull> I wonder if there is an alternative way to go from Functor other than -> Applicative -> Monad, or -> Comonad
13:35:56 <FreeFull> As in, one that is useful
13:36:32 <FreeFull> What sits between Functor and Comonad anyway?
13:36:35 <edwardk> FreeFull: sure there are lots of structures for your functor
13:36:51 <edwardk> there isn't a Co-Applicative for deep technical reasons involving co-exponentials
13:37:51 <FreeFull> Comonads are guaranteed to be functors, is there anything else that's useful and they are guaranteed to are?
13:38:31 <edwardk> In general you can't have both exponentials (functions) and co-exponentials (perhaps the closest analogue would be 'subtraction') and not have the entire category collapse into a poset, hence no co-applicative which relies on th exponentials in the category for its encoding.
13:39:09 <edwardk> well, we have the Apply/Bind hierarchy and the notion of 'Extend' or semicomonad in semigroupoids
13:39:34 <FreeFull> I heard that Comonads aren't Arrows as Arrows are defined in Haskell
13:39:45 <edwardk> ?
13:40:01 <edwardk> Cokleisli w forms a perfectly cromulent Arrow
13:40:18 <jmcarthur> FreeFull: there's Functor -> Foldable -> Traversable, for one
13:40:35 <FreeFull> Then I don't know what that was about
13:40:40 <FreeFull> :t arr
13:40:41 <lambdabot> Not in scope: `arr'
13:40:47 <FreeFull> :t Control.Arrow.arr
13:40:48 <lambdabot> Not in scope: `Control.Arrow.arr'
13:40:57 <FreeFull> jmcarthur: That is useful
13:41:06 <copumpkin> @arr
13:41:07 <lambdabot> Drink up, me 'earties
13:41:08 <edwardk> a 'monad' doesn't form an arrow its kleisli category is an arrow though
13:41:22 <edwardk> :t Kleisli
13:41:23 <lambdabot> Not in scope: data constructor `Kleisli'
13:41:30 <FreeFull> You can just wrap in Kleisli though
13:41:31 <aristid> :k Kleisli
13:41:31 <lambdabot>     Not in scope: type constructor or class `Kleisli'
13:41:35 <aristid> hum
13:41:42 <edwardk> elliott: lambdabot can't see any types
13:41:45 <FreeFull> @import Control.Arrow
13:41:45 <lambdabot> Unknown command, try @list
13:41:48 <FreeFull> @let import Control.Arrow
13:41:49 <lambdabot>  Defined.
13:41:52 <aristid> :k Control.Monad.Kleisli
13:41:52 <FreeFull> :t arr
13:41:52 <lambdabot>     Not in scope: type constructor or class `Control.Monad.Kleisli'
13:41:53 <lambdabot> Not in scope: `arr'
13:41:55 <edwardk> its broken
13:42:00 <edwardk> its nothing about arrow
13:42:01 <edwardk> :t over
13:42:01 <lambdabot> Not in scope: `over'
13:42:06 <aristid> oops
13:42:07 <FreeFull> arr :: Arrow a => (b -> c) -> a b c
13:42:13 <aristid> :t id
13:42:14 <lambdabot> a -> a
13:42:22 <mauke> > 3 (length "two")
13:42:23 <aristid> :k Control.Arrow.Kleisli
13:42:23 <lambdabot>     Not in scope: type constructor or class `Control.Arrow.Kleisli'
13:42:25 <lambdabot>   3
13:42:27 <FreeFull> lambdabot: Stop being broken
13:42:27 <aristid> oh well
13:42:38 <FreeFull> > 1 2 3 4 5 6
13:42:39 <lambdabot>   Could not deduce (GHC.Num.Num t)
13:42:39 <lambdabot>    arising from the ambiguity check for `e...
13:42:39 <edwardk> its been broken for an hour or so
13:42:45 <FreeFull> Who broke it?
13:43:00 <mauke> > 1 2 3 4 5 (6 :: Int)
13:43:04 <lambdabot>   1
13:43:22 <aristid> did somebody try to upgrade it or so?
13:43:23 <edwardk> spontaneous combustion
13:43:28 <edwardk> or it choked to death on loeb
13:43:39 <edwardk> undefine didn't help though
13:44:09 <edwardk> carter: alive?
13:44:12 <carter> yes
13:44:15 <ReinH> edwardk: so what would our Store look like?
13:44:27 <carter> edwardk sup
13:44:31 <edwardk> ReinH: figure it out and write a post =)
13:44:34 <carter> i'm doing triage
13:44:35 <ReinH> argh. :)
13:44:37 <edwardk> carter: phone?
13:44:39 <ReinH> edwardk: Ok see you next month
13:44:40 <carter> sure
13:45:03 <edwardk> ReinH: i have to spin off threads somehow. i figured this was a good point. now you have enough ammunition to slog through
13:45:05 <edwardk> =)
13:45:12 <ReinH> edwardk: seems good, I'll give it a go
13:45:18 <edwardk> ReinH: let me know how it goes or if you get _too_ stuck
13:45:25 <ReinH> ok :)
13:45:45 <edwardk> but i figure this is a good way for you to really internalize hashlife
13:45:58 <ReinH> yeah, seems good
13:46:26 <ReinH> edwardk: one question though
13:46:47 <ReinH> edwardk: when you said that you have to assume every a is distinct, does that have anything to do with SLGs being acyclic?
13:47:53 <carter> edwardk ring away
13:48:19 <edwardk> no, merely that its fully polymorphic
13:48:22 <edwardk> and i know nothing about it
13:50:05 <ReinH> ah right
14:02:35 <kryft> What's the preferred way to cause a parser to fail in parsec? I would like to fail if some things that have been successfully parsed don't meet certain criteria. As a toy example, I might parse a non-negative integer with many1 digit, and then fail if it was 0.
14:04:22 <S_J> how do I run cabal configure in FP eclipse? leksah actually seems nicer than eclipse...
14:04:27 <hpc> :t fail
14:04:28 <lambdabot> Monad m => String -> m a
14:05:31 <byorgey> kryft: use 'guard'
14:06:23 <hpc> guard won't give you a nice message when your parser fails
14:06:24 <byorgey> kryft: there is some primitive failing parser you could use as well, but 'guard' is exactly the idiomatic solution for this use case (failing if a certain condition is met)
14:06:28 <hpc> it'll just say "mzero"
14:06:32 <byorgey> oh... good point.
14:07:16 <kryft> hpc: Ah, I was actually just reading the source for Parsec, and it said that there are three parsers used to generate error messages, fail, unexpected and <?>, and the two latter ones clearly don't meet my needs
14:07:52 <byorgey> kryft: hmm, maybe you are supposed to use  parserFail :: String -> ParsecT s u m a
14:08:13 <haasn> it would be cool if you could use some operator to change the error message on ‘mzero’, or parse failures like that in general
14:08:22 <kryft> byorgey: Yeah, fail is basically implemented as that
14:08:32 <haasn> like guard (foo bar bat) <?> "cleaner error message" -- if that works (or doesn't)
14:08:50 <kryft> I just had a vague fear of calling fail because I remember reading in RWH or LYAH (or maybe both!) that you generally shouldn't
14:09:02 <byorgey> kryft: you shouldn't call fail.
14:09:18 <byorgey> kryft: you should call parserFail.
14:09:48 <hpc> what's wrong with fail?
14:09:51 <byorgey> fail actually makes sense for Parsec in particular, but it doesn't make sense in general for all monads.
14:09:53 <kryft> byorgey: Right, it just happens that fail is implemented as parserFail here, and the reason you shouldn't call it is that it could do something less nice in another monad?
14:10:01 <hpc> it's a huge wart to have it as a generic piece of Monad, but this is exactly what it's made for
14:10:38 <kryft> Uh it=fail obviously
14:11:22 <byorgey> kryft: well, it doesn't really matter that much.  I would just personally prefer parserFail over fail because I don't like fail.
14:11:29 <hpc> fail is the right thing here, because then you "know" that it's the same failure behavior as a pattern match in do-notation
14:11:59 <hpc> and pattern matching is an encouraged way to denote "if this doesn't hold, parse fail"
14:12:16 <byorgey> it is??
14:12:21 <byorgey> I wouldn't encourage it.
14:12:37 <hpc> i've seen it used in a few places
14:12:48 <byorgey> I believe you, though I've never seen (or used) it myself
14:13:05 <kryft> hpc: Hmm, do you have good examples of pattern matching used like that ("if this doesn't hold, parse fail")? Not questioning you; I'm just too tired to imagine how you do it :)
14:13:41 <hpc> matchLet = do {"let" <- token; defn's; "in" <- token; expr}
14:14:35 <hpc> expr = matchLet <|> matchThis <|> matchThat <|> ...
14:14:53 <hpc> probably with some try peppered in there, i haven't used parsec in a while
14:15:45 <kryft> "let" <- token? What does that mean?
14:16:11 <byorgey> kryft: it pattern-matches on the result of token, and calls 'fail' (with some generic error message about a pattern match failure) if it doesn't match
14:16:21 <kryft> Ah, I see
14:16:58 <kryft> I didn't realize you could use pattern matching like that
14:16:59 <hpc> and then token will be an action that has specific rules about the separation between words and operators and syntax and such
14:17:06 <hpc> it won't just be (string "let")
14:17:16 <kryft> Right, I see
14:18:10 <byorgey> I wouldn't write the parser that way though.  I would make a wrapper around token, a function which takes a String and fails (with a nice error message) if the next token doesn't match the given String
14:20:48 <kryft> All right, thanks
14:22:14 * hackagebot dns 0.3.8 - DNS library in Haskell  http://hackage.haskell.org/package/dns-0.3.8 (KazuYamamoto)
14:25:58 <jfischoff> edwardk: well it looks like I am jumping on the loeb bandwagon.
14:26:33 <jfischoff> I was struggling to make a dictionary of functions that used the same dictionary
14:26:40 <ReinH> edwardk: good news, I'm already stuck!
14:43:38 <hpaste> beefcube pasted “bytestring version conflict and ghc-mod” at http://lpaste.net/91923
14:49:46 <MrRacoon> if i wanted to parallelize a seuence of IO actions, what package/module would y'all suggest?
14:50:13 <MrRacoon> say ping every host on a subnet at once
14:50:31 <hpaste> beefcube annotated “bytestring version conflict and ghc-mod” with “bytestring version conflict and ghc-mod (annotation)” at http://lpaste.net/91923#a91924
14:50:34 <mauke> I'd probably check async first
14:50:55 <donri> @hackage parallel-io
14:50:55 <lambdabot> http://hackage.haskell.org/package/parallel-io
14:51:07 <donri> but maybe async yes
14:51:20 <MrRacoon> mauke++ donri++ thanks guys
14:54:32 <Cho0fool> Is there a library that can do Map String Int -> JSON?
14:54:51 <donri> Cho0fool: aeson is usually preferred
14:55:44 <zomg> Oh fucking cabal install broke deps again...
14:56:44 <beefcube> *passes zomg beer*
14:57:31 <donri> Cho0fool: should be able to just call aeson's "encode" function on that and get a bytestring of json
14:58:18 <Cho0fool> donri: OKay, thanks. I'll try that.
14:59:00 <zomg> Gee thanks cabal :P "Warning: Note that reinstalls are always dangerous. Continuing anyway..."
14:59:13 <zomg> Bleh, at least I know which package broke it this time
15:00:05 <donri> zomg: avoid-reinstalls: True in ~/.cabal/config should disable that
15:00:29 <donri> but probably makes hacking on packages a pain
15:01:09 <zomg> thanks, until now it had actually stopped when it figured a package might break from a reinstall but now it apparently just figured "meh, whatever" =)
15:02:15 <donri> zomg: i think it defaults to avoid reinstalls for *dependencies* but not for explicitly asked-for installations
15:03:50 <donri> zomg: actually, it refuses even that when i tried it now if the package+version is depended upon by something else...
15:04:27 <donri> zomg: i think it only "reinstalls anyway" when nothing uses the package, which supposedly is in fact safe
15:04:41 <jtbandes> I'm trying to "cabal install basic-prelude", but getting a "Duplicate instance declarations" error for "instance Applicative (L.ST s)" from Control.Monad.Base and Control.Applicative... any advice?
15:05:20 <jtbandes> the error is from the installation of the dependency transformers-base
15:05:30 <donri> jtbandes: supposedly it defines orphans because an older base didn't include them, but does now
15:05:31 <zomg> donri: yeah the error was something about the ghci runtime compiler something, not the usual dependency issue
15:05:42 <applicat1ve> jtbandes: sounds like basic prelude needs updated
15:05:54 <jtbandes> hm, I see
15:06:13 <jtbandes> applicat1ve: actually it's transformers-base
15:06:31 <applicat1ve> oh before you get to basicprelude
15:07:03 <jtbandes> yeah
15:07:08 <donri> jtbandes: try: cabal install -f-OrphanInstances transformers-base
15:08:01 <applicat1ve> oh my god donri !
15:08:03 <donri> jtbandes: or simply: cabal install -f-OrphanInstances transformers-base basic-prelude
15:08:20 <jtbandes> donri: that's not changing anything
15:08:31 <applicat1ve> i don't know transformers base; it seems this is done by 'hoist' elsewhere
15:08:56 <donri> jtbandes: are you sure you typed that exactly
15:09:12 <jtbandes> yep, I also see it recommended somewhere else online
15:09:22 <jtbandes> no space between -f and -O, if that's what you're wondering
15:10:09 <donri> well i'm just looking at the source. that should avoid the orphan
15:10:50 <donri> jtbandes: what version are you getting?
15:11:01 <jtbandes> transformers-base-0.4.1
15:11:10 <madjestic> hey guys.  I've got a haskell-emacs question: is there a set up that allows jumping to a definition of a basic function (e.g. putStrLn)?
15:12:12 <donri> jtbandes: actually nevermind the source is stupid
15:12:23 <jtbandes> lol
15:13:03 <chrisdone> madjestic: if you use the interactivve  mode you can use M-. with emacs tags
15:13:07 <donri> jtbandes: you'll have to contact the author. and/or cabal unpack transformers-base and fix it
15:13:10 <applicat1ve> he probably wants --fNoOrphanInstances
15:13:14 <applicat1ve> or however you write it
15:13:30 <donri> applicat1ve: what?
15:13:47 <jtbandes> presumably you mean -f-OrphanInstances, which is what I tried already
15:14:09 <donri> yeah, it's just doing #if MIN_VERSION_base(4,4,0) || HS_TRANSFORMERS_BASE__ORPHANS
15:14:11 <applicat1ve> donri: i'm just working toward repeating what you said already ...
15:14:12 <donri> || not &&
15:15:21 <S_J> how can i change emacs to color comments green instead of red? re dlooks like errors
15:15:27 <applicat1ve> this package is in dire need of an update
15:16:12 <donri> S_J: maybe try a different color scheme or whatever emacs calls them?
15:17:17 <JanBessai> S_J: see http://batsov.com/articles/2012/02/19/color-theming-in-emacs-reloaded/
15:20:00 <applicat1ve> i'm puzzle how come I could install transformers-base as something seems to have depended on it
15:20:13 <donri> older version?
15:20:25 <donri> or you're not on latest base? :)
15:21:05 <applicat1ve>    base-4.6.0.1
15:21:21 <applicat1ve>    transformers-base-0.4.1
15:22:29 <donri> orphans, international instances of mystery
15:22:38 <applicat1ve> what ghc does jtbandes have?
15:22:48 <jtbandes> 7.6.3
15:22:58 <applicat1ve> how could that matter this package is unaltered for 2 yrs
15:23:16 <donri> how could what matter?
15:23:34 <jtbandes> are you all seeing the same error as well? if not, my OS version may be problematic
15:23:56 <applicat1ve> builds with ghc 7.7.20130802 too
15:24:11 <donri> i seem to have it installed already too
15:24:18 <donri> and also on ghc 7.6
15:25:26 <applicat1ve> could it be a cpp thing? are you on osx jtbandes ?
15:25:36 <jtbandes> OS X 10.9
15:25:38 <applicat1ve> that seems unlikely too
15:25:38 <jtbandes> beta
15:25:49 <applicat1ve> oh. maybe it's this cpp nonsense
15:26:02 <applicat1ve> have you installed some other stuff with out trouble?
15:26:51 <donri> what Cabal? ISTR there was a bug with MIN_VERSION and &&/||
15:26:53 <jtbandes> I haven't tried to install much
15:26:57 <jtbandes> 1.8.0.2
15:27:04 <donri> ...what?
15:27:05 <applicat1ve> oh, that seems more likely
15:27:14 <donri> that sounds ancient
15:27:17 <jtbandes> "cabal-install version 0.8.0 using version 1.8.0.2 of the Cabal library"
15:27:20 <jtbandes> ..huh
15:27:26 <jtbandes> is this not installed by the haskell platform installer?
15:27:33 <donri> it should be
15:27:35 <applicat1ve> cabal-install version 1.17.0
15:27:36 <applicat1ve> using version 1.17.0 of the Cabal library
15:27:38 <donri> but not that version plus ghc 7.6
15:27:44 <jtbandes> ah...I have an old version of cabal lying around
15:27:53 <jtbandes> I'm not sure where it came from...
15:28:05 <applicat1ve> oh cool problem resolved
15:28:08 <jtbandes> oh no, it points to /Library/Frameworks/HaskellPlatform.framework
15:28:09 <donri> cabal-install is independent of ghc
15:28:34 <donri> since in fact it can be used with multiple compilers and versions at the same time
15:29:04 <applicat1ve> jtbandes: presumably the other cabal install is around somewhere
15:30:33 <applicat1ve> mzero made a script for removing old haskell stuff from os x before installing the platform its probably buried in there too
15:31:28 <applicat1ve> i think                   /Library/Frameworks/HaskellPlatform.framework
15:31:37 <applicat1ve> is where the installer puts stuff,
15:32:14 <jtbandes> cabal-install-1.16.0.2 failed during the building phase
15:32:17 <jtbandes> welp
15:32:20 <jtbandes> I'm screwed
15:32:34 <applicat1ve> no, there's a script inside.
15:34:02 <applicat1ve> cabal unpack cabal-install then cd cabal-install then do 'bootstrap.sh --user'
15:35:42 <jtbandes> any reason not to use global?
15:36:03 <applicat1ve> jtbandes: on reflection, probably not
15:36:12 <applicat1ve> i keep everything local even ghc.
15:36:25 <applicat1ve> so global yes, i guess
15:39:46 <S_J> anyone familiar with GLUT? my program does not terminate when I close it. how do i do that?
15:41:27 <startling> S_J, what is "close it"? what is "terminate"?
15:41:45 <startling> S_J: in any case, GLUT is old and gross. Things like GLFW are better.
15:42:04 <Adeon> I wonder, did someone write SDL2 bindings yet
15:43:04 <S_J> I want to create a 2D sidescroller, is GLFW the way to go then?
15:43:27 <Adeon> sure
15:43:28 <startling> S_J: yeah.
15:44:57 <startling> S_J: okay, so OpenGL is for literally drawing stuff to a surface. OpenGL is cross-platform API that many things implement. There is no such cross-platform way to do things like create windows and get keypresses. Things like GLUT and GLFW exist to fill that space.
15:46:19 <tabemann> back
15:46:59 <tabemann> goddammit threadscope *still* hadn't finished loading, and I had to kill it because it was about to exhaust *all* memory on the system, swap included
15:47:02 <Demos> openGL is not an API, it is an API /specification/
15:47:11 * Demos heads to the nitpickers corner
15:47:12 <jtbandes> how does this make sense? is 0.5 being interpreted as Int for some reason? "No instance for (Fractional Int) arising from the literal `0.5'"
15:47:37 <johnw> jtbandes: we can't guess without seeing code
15:47:52 <startling> S_J: anyway, re: GLUT: if you mean "pressing the x button on top of the window (or local equivalent) does not close the window", you'll need to handle whatever event GLUT gives you for when the user tries to close the window.
15:48:16 <startling> jtbandes, you're using 0.5 in a place that expects an Int
15:48:22 <jmcarthur> jtbandes: if the type in context has to be an Int then it will try to treat 0.5 as an Int (and fail)
15:48:54 <startling> > [1, 2, 3] !! 0.5
15:48:54 <lambdabot>   Could not deduce (GHC.Real.Fractional GHC.Types.Int)
15:48:55 <lambdabot>    arising from the li...
15:50:18 <jtbandes> ah I see, I guess I was thinking about it backwards... since the literal is 0.5 it must be Fractional, so it tries to satisfy that based on the expression
15:51:24 <jtbandes> it's just that the error doesn't give any pointers as to why it's expecting an Int
15:51:42 <startling> jtbandes, I bet it does.
15:51:47 <Tekmo> Can you paste the code?
15:52:16 * hackagebot processing 1.2.0.0 - Web graphic applications with processing.js.  http://hackage.haskell.org/package/processing-1.2.0.0 (DanielDiaz)
15:53:12 <jtbandes> I'd like to try and figure out myself, but I'll try to come up with a minimal example to reproduce it
15:53:25 <applicat1ve> > let f xs = length xs == 0.5 in f [x]
15:53:26 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
15:53:26 <lambdabot>    arising from the lit...
15:54:20 <madjestic> chrisdone: thanks, I am reading into interactive mode set up.  What is the status of inf-haskell mode vs. shime?
15:54:43 <applicat1ve> > length "jtbandes" * 0.3
15:54:44 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
15:54:45 <lambdabot>    arising from the lit...
15:55:28 <hape01> I have no tab-completion in inf-haskell; as I have it in ghci :-)
15:55:48 <startling> jtbandes: but yeah, the error messages like "Possible fix: add an instance declaration for (Fractional Int)" are pretty bad and you should ignore them.
15:56:24 <applicat1ve> if the typechecker suggests it, surely it cant be wrong ;)
15:56:26 <Tekmo> Or "parser error (possibly incorrect indentation"
15:56:38 <ReinH> Tekmo: hai
15:56:41 <Tekmo> Hey!
15:56:46 <applicat1ve> hi Tekmo !
15:56:50 <Tekmo> Hi!
15:56:55 <startling> hi Tekmo
15:57:10 <Tekmo> Hi!
15:57:29 <Tekmo> But yeah, parser error is almost always wrong
15:57:41 <Tekmo> I find that 9 times out of 10 it's a mismatched parentheses
15:58:03 <startling> usually on the line before it says.
15:58:20 <S_J> would it be reasonable to run haskell programs on a raspberry? I mean compile on a normal desktop and then install it somehow? so you dont need ghc on the rpi.
15:58:24 <madjestic> hape01: is code.haskell.org the right place to get inf-haskell.el?
15:58:56 <startling> S_J, yeah. there's some work in that regard; keyword is "cross-compiling".
15:59:15 <applicat1ve> Tekmo: btw, i think this new pipes-parse could do with a more extensive example; i was having trouble figuring out
15:59:38 * applicat1ve concedes he may be more dimwitted than many
15:59:43 <Tekmo> applicat1ve: The more extensive example is going to be in pipes-bytestring
15:59:49 <applicat1ve> oh cool
16:00:07 <Tekmo> For example:
16:00:48 <Tekmo> Let me rephrase that: it will make more sense when you get to `pipes-text`
16:01:00 <Tekmo> Here's a really simple example to motivate the problem that `pipes-parse` solves
16:01:29 <Tekmo> Let's say that you want to forward only the first line of a file
16:01:56 <Tekmo> The naive way using something like `lines` from `conduit` would be like: input =$= lines =$= take 1 =$= output
16:02:24 <Tekmo> The problem with this approach is that `lines` concatenates all bytestrings within a line into a single chunk
16:02:42 <Tekmo> So now imagine that you have an 8 GB file that is just one line long
16:02:42 <applicat1ve> oh so it has to build a new one
16:02:50 <applicat1ve> oh
16:03:08 <Tekmo> If you use that approach, you'd load the entire line into memory, when really the correct behavior is to just stream that entire file in chunks
16:03:26 <jtbandes> so here is some code that produces the Fractional error http://lpaste.net/2695140206427766784
16:03:36 <applicat1ve> yes, but you want to forward them as they first came, but clipping wherever the first newline falls
16:03:43 <Tekmo> So what would a "correct" lines function look like, then?
16:03:59 <Tekmo> The simplest approach that gives the correct behavior is this:
16:04:23 <Tekmo> lines :: (Monad m) => Producer Text m r -> Free (Producer Text m) r
16:04:35 <Tekmo> The input `Producer` is your unmodified stream of `Text` chunks
16:04:46 <applicat1ve> jtbandes: if you zip [..] vals it might work
16:04:50 <Tekmo> Each element of the resulting `Free` is one line's worth of chunks
16:05:11 <Tekmo> Each line returns the next line through its return value (since it's a free monad)
16:05:14 <johnw> Tekmo: the Foldr answer here: http://stackoverflow.com/questions/18287848/unzip-in-one-pass
16:05:15 <applicat1ve> the unmodified stream of text chunks detemined by some default buffer
16:05:16 <jtbandes> applicat1ve: nope
16:05:20 <johnw> sounded exactly like your foldl library
16:05:29 <johnw> thought you might want to chime in :)
16:05:33 <Tekmo> johnw: Yeah, I saw that today.  I'm seeing how I can incorporate it
16:05:49 <Tekmo> applicat1ve: Right, you might having something like: `stdinText :: Producer Text IO ()`
16:06:01 <Tekmo> applicat1ve: Oh sorry, let me clarify
16:06:23 <Tekmo> applicat1ve: I have even more to say about how to split the text chunks, but just assume for now that they are all roughly a few kilobytes each"
16:06:41 <applicat1ve> so we want to forward chunks as they come, then we return a new producer that also has the leftover bit of the line that was broken with the newline.
16:06:45 <Tekmo> Right
16:06:56 <applicat1ve> oh that was responding to two lines earlier, let me read
16:07:09 <Tekmo> The key part is that you can't access the next line until you finish the previous line
16:07:09 <applicat1ve> ok i am assuming they are a few kilobytes
16:07:17 <hape01> madjestic: inf-haskell.el came to me automatically via Emacs ELPA milkbox.net  (M-x package-list-packages, then install haskell-mode)
16:07:27 <Tekmo> This prevents you from partially draining the first line and beginning the second line from a corrupt state
16:08:06 <applicat1ve> Tekmo: right i think i see this.
16:08:20 <applicat1ve> we dont want to collect the lines and produce *them*
16:08:27 <Tekmo> Right
16:08:30 <applicat1ve> with an ordinary producer
16:08:43 <Tekmo> We just want to use `Free` to mark line boundaries but preserve the original chunks
16:08:50 <applicat1ve> we just forward til we break a line, then stop, returning somethign new
16:09:04 <Tekmo> Right
16:09:07 <applicat1ve> i hope this will be easy to learn ...
16:09:21 <Tekmo> So `pipes-parse` doesn't go all the way and do the `Free` thing
16:09:31 <Tekmo> Right now it's doing something more conservative while I test drive the `Free`-based solution
16:09:51 <Tekmo> So the more conservative solution is to define a function that just splits at the first line boundary:
16:10:09 <Tekmo> line :: (Monad m) => Producer Text m r -> Producer Text m (Producer Text m r)
16:10:31 <Tekmo> ... and let the user take care of recursing over multiple lines, using `isEndOfInput` to know when to stop
16:11:18 <Tekmo> Now, what makes this cool is that you can define an isomorphism both to and from the split representation
16:11:30 <Tekmo> In other words, you would actually use this type:
16:11:47 <Tekmo> lineIso :: (Monad m) => Iso' (Producer Text m r) (Producer Text m (Producer Text m r))
16:11:55 <Tekmo> lineIso = iso line join
16:12:28 <Tekmo> You can then use this isomorphism and pass it to `zoom` and it just works and does the right thing in the context of `pipes-parse`
16:12:34 <Tekmo> You would then write:
16:12:40 <Tekmo> zoom lineIso myParser
16:12:57 <Tekmo> ... and it would restrict `myParser` to exactly one line of input *and* return unused input back to the leftovers buffer when done
16:13:07 <Tekmo> ... all while preserving streaming and not collecting chunks together
16:13:29 <applicat1ve> myParser has the type StateT (Producer...) ..
16:13:32 <Tekmo> Right
16:13:33 <ReinH> holy crap the store comonad makes my brain hurt
16:13:44 <johnw> ReinH: but it only ever hurts in one place at a time
16:13:55 <Tekmo> myParser :: StateT (Producer Text m r) SomeResult
16:14:23 <applicat1ve> but zoom lineIso myParser
16:14:24 <ReinH> johnw: Store (const True)
16:15:11 <applicat1ve> StateT (Producer Text m (Producer Text m r)) SomeResult
16:15:20 <applicat1ve> wait
16:15:22 <Tekmo> Ah, so that's the trick
16:15:29 <ReinH> johnw: I think I'm finally starting to grok it though
16:15:38 <Tekmo> Your myParser will typically be universally quanitified to ignoer the return value of the outer `Producer`
16:15:49 <Tekmo> So it will still type-check when you `zoom` in
16:15:51 <madjestic> hape01: I've just figured that one out.  Thanks
16:16:00 <Tekmo> The type you just wrote out is what the return value will specialize to after `zoom`ing
16:16:22 <Tekmo> A neat way to think of it is that this is behaving exactly like "isomorphism lenses"
16:16:32 <Tekmo> http://twanvl.nl/blog/haskell/isomorphism-lenses
16:16:33 <johnw> ReinH: compare State (s -> (s, a)) with Store (s, s -> a), it could lead to some insights
16:16:43 <ReinH> johnw: figuring out that duplicate store create a store where the context is sort of "all possible previous stores"
16:17:03 <ReinH> well, all possible previous evaluations of f on s
16:17:17 <aristid> Tekmo: one thing i'm mildly worried about... do you verify that the whole set of lens/iso/prism laws is upheld when postulating these pipes lenses?
16:17:20 <Tekmo> So in a sense this is exactly like "lensing" into a stream
16:17:37 <Tekmo> The isomorphisms in `pipes-parse` are true isomorphisms if that's what you are asking
16:18:12 <aristid> Tekmo: i haven't actually looked at those yet, for my purposes i'm just using pipes itself right now.
16:18:25 <Tekmo> aristid: What laws are you specifically curious about?
16:18:34 <applicat1ve> like the iso String (String, String) with take 3/drop 3 or something
16:18:47 <applicat1ve> or is that illegal
16:19:07 <aristid> Tekmo: i just remember you proposing on the ML an Iso that wasn't one :P, and the fact that there are whole packages on hackage with isos and prisms that are none, and the fact that i had in the past written prisms that were none myself. i just think it can be tricky
16:19:34 <Tekmo> applicative: That's a legal isomorphism, I think
16:19:55 <applicat1ve> and uncurry concat for the other way
16:20:08 <Tekmo> aristid: Oh, that was the `pipes-attoparsec` isomorphism that Renzo proposed, not me
16:20:14 <applicat1ve> that is vaguely analogous, i guess?
16:20:25 <Tekmo> applicat1ve: Yes, that is analogous
16:20:55 <aristid> Tekmo: how does the isomorphism behave for "error" cases, like with not enough elements in the list or something like that? does it still roundtrip in both directions?
16:21:17 <Tekmo> Which isomorphism?
16:21:43 <aristid> that was more a general thought, but applicat1ve mentioned a take/drop one
16:21:56 <applicat1ve> > uncurry concat (take 3 "h", drop 3 "h")
16:21:57 <lambdabot>   Couldn't match type `[a0]' with `[GHC.Types.Char] -> c0'
16:21:57 <lambdabot>  Expected type: [[...
16:22:01 <applicat1ve> :(
16:22:17 <FreeFull> :t concat
16:22:18 <lambdabot> [[a]] -> [a]
16:22:21 <FreeFull> :t uncurry
16:22:21 <lambdabot> (a -> b -> c) -> (a, b) -> c
16:22:23 <Tekmo> THe same as the `take`/`drop` example.  If there are not enough elements, then it puts all elements in the first list and leaves the second one empty.  The backwards direction concatenates the lists and gives you back the original result
16:22:24 <applicat1ve> bahh, thanks
16:22:33 <applicat1ve> > uncurry (++) (take 3 "h", drop 3 "h")
16:22:34 <lambdabot>   "h"
16:22:41 <aristid> Tekmo: ok so ([], [1]) does not roundtrip.
16:22:49 <aristid> Tekmo: that right there is a law violation i do think.
16:22:59 <Tekmo> Ah, you are right
16:23:05 <Tekmo> I never thought of that
16:23:19 <aristid> that's why i'm mentioning it, i think it's easy to miss:)
16:23:21 <applicat1ve> so it matters where we start which isn't quite like Iso
16:23:22 <FreeFull> [] isn't ((->) r) so it doesn't unify =P
16:25:27 <aristid> Tekmo: and unfortunately I think "lens" does not really offer variants with less stringent laws
16:25:32 <Tekmo> Then maybe there is a way to weaken it to a lens instead of an isomorphism
16:25:41 <aristid> that might be
16:26:34 <Tekmo> Give me a second to hash together an example for splitting and see if I can get it work
16:26:35 <applicat1ve> the main is surely to think out what behavior is desirable. the leap to lens might be precipitate?
16:26:43 <Tekmo> Well, I do care about laws
16:27:05 <applicat1ve> aristid: you spoil everything!
16:27:11 <Tekmo> "It works" is not good enough for me :)
16:27:41 <aristid> laws are good for you... like milk!
16:27:55 <applicat1ve> oh I wasnt meaning that; it was stabilizing the earlier idea whichis independent of the witty use of zoom
16:27:59 <applicat1ve> but maybe not
16:28:00 <johnw> unless you are lawctose intolerant
16:28:39 <Tekmo> I've never met a problem where getting the laws correct didn't lead to a better solution
16:29:10 <applicat1ve> crime doesnt pay!
16:29:24 <Tekmo> :)
16:29:44 <applicat1ve> darn I have to go. i'll see if anything came of this later.
16:29:52 <Tekmo> Alright, see you later
16:30:12 * aristid still feels sick every time he thinks of that html monad that is just a Monoid and doesn't even implement itself as a Writer, but just errors away the argument for the >>= second parameter
16:30:20 <Tekmo> Yeah, that bothered me, too
16:30:35 <Tekmo> Especially since `mconcat` + a list produces just as nice syntax
16:30:55 <aristid> yep, and if you really really want do there, there's always Writer.
16:30:59 <Tekmo> Right
16:31:04 <Tekmo> I don't get why they didn't like `Writer`
16:31:38 <aristid> oh well, that's just an irrelevant tangent, lol
16:33:54 <aristid> Tekmo: btw i think in lens there's somewhere a module with all kinds of law tests
16:34:09 <Tekmo> What do you mean?  Like quickcheck?
16:34:27 <aristid> https://github.com/ekmett/lens/blob/master/tests/properties.hs#L97
16:34:31 <aristid> yep
16:34:39 <Tekmo> Yeah, I'm writing up equivalent tests for `pipes`, too
16:34:52 <Tekmo> There is an issue on Github to remind myself to complete this
16:35:04 <aristid> it's a pretty strong incentive to write pure code IMHO
16:35:10 <Tekmo> Yes, I agree
16:35:17 <Tekmo> This is also the reason I added 'toList'
16:35:27 <Tekmo> It makes it very easy to do pure tests on `pipes`
16:36:24 <aristid> yes, toList and quickcheck has already helped me find a bunch of bugs in my current toy code
16:36:51 <Tekmo> Yeah, that's one of the motivations behind `pipes` in general, too
16:37:03 <Tekmo> You can separate out the pure bits from the impure bits so you can quickcheck the pure parts
16:37:41 <Tekmo> Whereas if you do something like `io-streams` then all your application logic is in `IO` and untestable
16:37:48 <Tekmo> Well, it's testable, but not purely
16:38:18 <aristid> i'm not sure if quickCheck itself has any support for IO
16:38:33 <Tekmo> Alright, I got the lens to work, I think:
16:38:34 <Tekmo> http://lpaste.net/91925
16:38:41 <Tekmo> I have no idea if that's law abiding, but it type-checks
16:39:12 <aristid> i linked you to properties... there's an isLens in there:)
16:39:23 <Tekmo> That's actually a bit convenient because then I can drop the `profunctors` dependency
16:39:48 <aristid> it's slightly ugly though because it's a lens that ignores the old value
16:39:53 <roconnor> Tekmo: yikes.
16:40:14 <Tekmo> Maybe I should just define an `Arbitrary` and `==` instance for `Producer a Identity` to make testing really easy
16:40:21 <aristid> ah, roconnor can probably tell you if it's law-abiding without quickchecking it :D
16:41:23 <roconnor> Tekmo: do join and (split' n) form an isomorphism?
16:41:28 <Tekmo> No
16:41:34 <Tekmo> aristid found a counterexample for that
16:41:40 <aristid> roconnor: no, because ([], [1]) does not roundtrip.
16:41:56 <roconnor> okay so I have to think then
16:42:17 <Tekmo> I'm working on it, too
16:42:35 <Tekmo> If it makes it easier for you to read the code, `next` is basically `uncons` for a `Producer`
16:43:15 <aristid> Tekmo: the idiom seems to be x <- lift (next p); case x of ... :D
16:44:09 <Tekmo> So that's another reason for `pipes-parse`'s existence
16:44:16 <Tekmo> It makes it easier to write this without using `next`
16:44:19 <aristid> Tekmo: why don't you use Free there?
16:44:36 <Tekmo> What do you mean?
16:44:50 <aristid> the type of split' is weird
16:45:05 <roconnor> seems unlikely to satify the set-get law.
16:45:08 <Nisstyre> :t split'
16:45:09 <lambdabot>     Not in scope: split'
16:45:09 <lambdabot>     Perhaps you meant `splitAt' (imported from Prelude)
16:45:18 <aristid> why not split :: Monad m => Int -> Producer a m r -> Free (Producer a m r) or so
16:45:45 <Tekmo> That's only if you want to split the stream repeatedly
16:45:49 <Tekmo> This one is designed to just split once
16:46:10 <aristid> Tekmo: oh the Producer-Producer is a kind of pair, right?
16:46:14 <Tekmo> Right
16:46:25 <danharaj> hmmm, my template haskell program throws up a stack overflow if I try to make a base-256 type level natural.
16:46:26 <roconnor> you could set the (Producer a m (Producer a m r)) to any old garbage and you won't get it back with get.
16:46:38 <aristid> well still slightly confusing, but to think how it would've looked in pipes 3.x *shudder* :P
16:47:00 <Tekmo> roconnor: Why not?
16:47:49 <aristid> Tekmo: you could maybe make a splitting prism!
16:48:04 <roconnor> Tekmo: (x & split 5 .~ return p) ^. (split 5)
16:48:06 <aristid> Tekmo: if there are not enough elements in the first list, fail it.
16:48:20 <roconnor> that will probably not be the same as (return p)
16:48:30 <aristid> prisms don't get the attention they deserve *sniff* ;)
16:48:59 <Tekmo> Maybe I need to existentially quantify the return value of the outer producer
16:49:03 <aristid> and i think it would actually be a valid prism
16:49:06 <roconnor> aristid: I don't even think a prism is approprate here
16:49:17 <aristid> because it does not drop any information if there are enough elements
16:49:20 <aristid> roconnor: why not?
16:49:33 <aristid> oh
16:49:36 <aristid> right
16:49:39 <roconnor> aristid: same set-get problem.
16:49:41 <aristid> yeah it's wrong
16:49:57 <aristid> roconnor: you'd need to quotient out these values :D
16:50:04 <roconnor> Yeah, the problem is that join and split just don't have a "functional references" relationship.
16:50:33 <roconnor> They are nice and all, and maybe there is some structure out there just waiting to love them.
16:50:37 <roconnor> but lens isn't it.
16:50:46 <S_J> where does haskell look for DLLs?
16:50:46 <jfischoff> is it a bug if the ghc loops with out giving up?
16:51:03 <roconnor> jfischoff: the compiler?
16:51:08 <jfischoff> yeah
16:51:16 <roconnor> jfischoff: yes, but there are some known won't fix bugs like that.
16:51:48 <jfischoff> roconnor: do you know how I can find them on trac? any keywords to search for?
16:51:49 <aristid> roconnor: a prism to (Vec n a, [a]) would that work in theory (i mean you don't want that in practice, it'd be too much dependent typing pain in haskell, but...)?
16:52:19 <roconnor> aristid: yes that is a valid prism.
16:52:23 <aristid> yay!
16:52:42 <aristid> not sure how to make it a valid Iso though.
16:52:43 <roconnor> aristid: if you had the same Vec constraint on Producer, that would work too.
16:53:00 <Tekmo> You mean requiring that the outer `Producer` yields exactly `n` elements?
16:53:14 <roconnor> Tekmo: Yes, that is what I'm imagining.
16:53:31 <roconnor> I'm not entirely familiar with Pipes though.
16:53:37 <aristid> Tekmo: i mean that's not practical at all, but in dependent typing lala land that'd be the right thing, right? ;)
16:54:38 <roconnor> Lenses and Prisms are actually fairly easy to spot.  If A can be decomposed into R*B for some residual R, then you have a lens.
16:54:46 <aristid> Tekmo: and sorry for spoling the fun :/
16:54:50 <roconnor> if A can be decomposed into R + B for some residual R, then you have a prism.
16:54:52 <Tekmo> aristid: Not at all! :)
16:55:26 <roconnor> [a] can be decomposed in to R + (Vec n a, [a])
16:55:46 <roconnor> where R = () + a + a^2 + ... + a^(n-1)
16:55:47 <aristid> right
16:55:54 <aristid> and isos are even easier to spot
16:56:09 <fylwind> why did they name them Lens and Prism?
16:56:37 <haasn> a lens ‘focuses’ on a smaller part of a data structure
16:56:41 <edwardk> lenses were named by benjamin pierce. prism was because we needed a name for colenses that had the right connotations
16:56:49 <haasn> a prism ‘splits’ a data structure into multiple possibilities, I guess
16:56:53 <roconnor> fylwind: Lens comes from B. Pierce's work on bidirctional programming.  I guess you will have to ask him.
16:57:11 <roconnor> edwardk I persume made up the name prism.
16:57:15 <aristid> haasn: indeed
16:57:34 <edwardk> yeah i basically polled everyone in #haskell-lens until we found a name i didn't hate
16:57:34 <aristid> there has been an analogy of prisms with pattern matching that can fail
16:57:59 <roconnor> prisms do have a nice splitting conotation.
16:58:06 <Tekmo> I think prisms are the right way to do extensible exceptions
16:58:14 <roconnor> Tekmo: so do I.
16:58:23 <roconnor> though I got some scoffing from that remark at my talk.
16:58:24 <haasn> Tekmo: is there a practical implementation of that anywhere?
16:58:24 <aristid> Tekmo: it turns out that there are exception prisms in lens :D
16:58:36 <aristid> they use SomeException though
16:58:52 <edwardk> aristid: we have them in terms of the Error monad as well
16:58:54 <roconnor> aristid: there is a whole Exception monad library for prisms.
16:58:59 <edwardk> :t Control.Monad.Error.Lens.catching
16:58:59 <lambdabot>     Not in scope: `Control.Monad.Error.Lens.catching'
16:59:05 <edwardk> :t id
16:59:06 <lambdabot> a -> a
16:59:11 <edwardk> :t Control.Monad.Trans.Error.Lens.catching
16:59:12 <lambdabot>     Not in scope: `Control.Monad.Trans.Error.Lens.catching'
16:59:25 <roconnor> just keep permuting those words
16:59:25 <aristid> bad lambdabot!
16:59:34 <aristid> roconnor: nah lambdabot is broken
16:59:38 <edwardk> @let import Control.Monad.Error.Lens
16:59:39 <lambdabot>  Defined.
16:59:42 <edwardk> :t Control.Monad.Trans.Error.Lens.catching
16:59:43 <lambdabot>     Not in scope: `Control.Monad.Trans.Error.Lens.catching'
16:59:52 <edwardk> :t Control.Monad.Error.Lens.catching
16:59:53 <lambdabot>     Not in scope: `Control.Monad.Error.Lens.catching'
16:59:56 <edwardk> bah
16:59:57 <edwardk> its there
17:00:09 <edwardk> t is defined analogously to the ones in Control.Exception.Lens
17:00:12 <jtbandes> I'm getting "error: invalid preprocessing directive" on line 5 here: http://hackage.haskell.org/packages/archive/memoize/0.6/doc/html/src/Data-Function-Memoize-TH.html
17:00:13 <roconnor> I'm give a class on Monads next week.
17:00:32 <roconnor> for some reason I find coming up with compelling examples difficult.
17:00:36 <edwardk> http://hackage.haskell.org/packages/archive/lens/latest/doc/html/Control-Monad-Error-Lens.html
17:00:39 <edwardk> done =)
17:00:47 <Tekmo> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
17:00:51 <Tekmo> Just copy and paste what Dan did
17:01:14 <roconnor> That is vaguely my plan
17:01:26 <aristid> i love how often we link up old blog posts from dan piponi
17:01:41 <aristid> from between 2006 and 2009 usually
17:01:44 <Tekmo> He's the guy that inspired me to start blogging
17:02:01 <roconnor> though I largely find Wadler's paper better.
17:02:17 <roconnor> I should just fly Dan in and have him give the lecture.
17:02:22 <Tekmo> I wish there was a way to un-PDF academic papers
17:02:31 <Tekmo> Linking to a blog post is so much nicer than linking to a paper
17:02:36 <aristid> it's nice that HTML adapts to your screen size
17:03:00 <aristid> i can read Tekmo blog posts on my phone. not so much Wadler papers in PDF form (or i can but it's a pita).
17:03:23 <Tekmo> Same here.  I do a lot of reading on my smart phone
17:03:26 <Tekmo> PDFs are a pain
17:04:35 <Sculptor> tablet ftw
17:04:53 <Tekmo> aristid: Also, don't worry if the lens thing doesn't work out.  The worst case scenario is that I just define one-way morphisms
17:04:56 <roconnor> I should get back to work.
17:04:57 <aristid> Sculptor: do you take your tablet to the tram? :P
17:05:08 <edwardk> Tekmo: what lens thing?
17:05:17 <Sculptor> i never leave home without it
17:05:21 <Sculptor> 7"
17:05:24 <aristid> edwardk: well, some of his isos are no isos.
17:05:29 <aristid> nor lenses. nor prisms.
17:05:34 <edwardk> oh
17:05:41 <Tekmo> edwardk: Oh, it was an idea I had for `pipes-parse`
17:05:52 <Tekmo> It almost worked, except they violate laws in certain cases
17:06:09 <edwardk> this is where i need to get around to defining those 'improper prisms/traversals/lenses of the first and second kind' thing more formally?
17:06:18 <Tekmo> It's not a super-huge deal
17:06:25 <Tekmo> I can do without the lens stuff if necessary
17:06:31 <Tekmo> However, when it does work it is really cool
17:06:36 <aristid> edwardk: the nicest thing in his case would be an improper Iso methinks.
17:06:45 <Tekmo> You have parsers for pipes that do the right thing with `zoom`
17:06:46 <edwardk> same structure
17:06:54 <Tekmo> You can `zoom` in on stream subsets and limit your parser to that subset
17:07:00 <edwardk> Tekmo: ah nice
17:07:06 <Tekmo> The it correctly restores unused input when you're done zooming
17:07:27 <Tekmo> See `pipes-parse` on Github for the law-unabiding version that I thought worked
17:08:11 <Tekmo> What was really cool is that it is not just for splitting streams
17:08:17 <Tekmo> You can define codecs really elegantly this way, too
17:08:29 <Tekmo> For example, if this were law-abiding you could write:
17:08:47 <Tekmo> utf8 :: Iso' (Producer ByteString m r) (Producer Text m (Producer ByteString m r))
17:09:05 <Tekmo> That decomposes a ByteString stream into a Text string and ByteString residue at the end
17:09:26 <aristid> residue?
17:09:45 <Tekmo> Basically anything that is not valid utf8
17:10:01 <aristid> so basically the error case
17:10:07 <Tekmo> It just parses as much vaild utf8 text as possible and then stops and returns ByteStrings when it hits an invalid sequence
17:10:10 <Tekmo> Right
17:10:22 <aristid> Tekmo: did you hear of the hybrid latin1/utf-8 encoding? :>
17:10:38 <aristid> but i'm being facetious
17:11:00 <Tekmo> aristid: I don't know a whole lot about text encoding so I think I missed some sort of joke
17:11:21 <aristid> Tekmo: irc clients actually tend to do that, but slightly differently
17:11:32 <Tekmo> You mean treat any failed ByteStrings as latin1?
17:11:40 <aristid> yep basically
17:11:49 <Tekmo> That could be another option
17:11:55 <Tekmo> I can always provide both
17:11:59 <aristid> Tekmo: irc clients usually first try to parse a line as utf8 and if that fails fall back to latin1
17:12:44 * aristid remembers when irc channels had this push to move to utf-8... and suddenly feels slightly less young
17:13:01 <Tekmo> Haha
17:14:12 <FreeFull> latin-1 sucks because it lacks ♥
17:14:26 <aristid> Tekmo: anyways, i guess i'm gonna see what you'll come up with later because now i want to head to the bed :P good night.
17:14:37 <Tekmo> aristid: Alright, good night!
17:17:23 * hackagebot pretty-show 1.6 - Tools for working with derived `Show` instances and generic  inspection of values.  http://hackage.haskell.org/package/pretty-show-1.6 (IavorDiatchki)
17:22:44 <jtbandes> does a double apostrophe mean anything in particular? e.g. deriveMemoizable ''T
17:22:56 <jtbandes> it's giving "warning: empty character constant" when trying to install memoize
17:24:55 <k00mi> jtbandes: not sure what it means exactly, but it looks like TemplateHaskell
17:25:11 <k00mi> you'd probably have to put $(...) around it
17:25:36 <zRecursive> ugly TH
17:26:16 <jtbandes> ok, well, it's not really causing a problem I guess, just warnings... the problem is that {-# LANGUAGE #-} directive is not working for some reason > http://hackage.haskell.org/packages/archive/memoize/0.6/doc/html/src/Data-Function-Memoize-TH.html
17:27:44 <c_wraith> What do you mean by "not working"?
17:28:00 <c_wraith> oh, nevermind, I caught up
17:29:00 <c_wraith> jtbandes: that warning is coming from CPP,
17:29:19 <c_wraith> jtbandes: CPP is very, very unhappy with people using ' to mean anything other than characters.
17:30:00 <c_wraith> jtbandes: there are cases where it will completely fail to allow perfectly valid code, in fact.  CPP is a terrible hack, and only used because it's a useful terrible hack
17:30:46 <jtbandes> actually, "not working" referred to "error: invalid preprocessing directive        #-}"
17:30:59 <jtbandes> it seems the '' messages are just warnings
17:31:18 <c_wraith> oh, hah.
17:31:25 <Tekmo> Do you ahve something after the LANGUAGE?
17:31:26 <c_wraith> I told you, CPP is a terrible hack
17:31:39 <jtbandes> Tekmo: the link above is the offending source file
17:31:48 <c_wraith> it'd compile fine if line 4 was move up to line 3
17:31:52 <jtbandes> there's another comment after it, not another directive
17:32:00 <c_wraith> but because the # is the first non-whitespace character on the line, CPP vomits
17:32:18 <jtbandes> ...ah, I see
17:32:21 <jtbandes> now the other question
17:32:27 <jtbandes> ..how has anyone ever installed this package, ever?
17:32:48 <danharaj> edwardk: do you know what the proper way to fake a kind instance is in HEAD? I recall hearing trouble about using Any.
17:32:52 <c_wraith> it's possible that people who have did so with the system CPP replaced by something like cpphs
17:33:49 <c_wraith> Or it could be a clang/gcc issue
17:33:56 <c_wraith> or any other number of things
17:34:22 <jtbandes> yeah, I suppose that's possible, i am probably using a weird version of clang
17:35:55 <jtbandes> so I found this example for memoizing a fibonacci function: http://www.haskell.org/haskellwiki/Memoization#Memoization_with_recursion   but if I add another parameter to the function, it becomes slow again. is there any way to modify this approach to have another parameter?
17:36:18 <jtbandes> (note: the new parameter is just a constant, not meant to change in recursive calls... perhaps that will help)
17:36:39 <c_wraith> If it's just a constant, you can just define a helper function in a where clause
17:36:54 <c_wraith> and the helper function will do the memoization, but not have the constant passed in
17:36:58 <Tekmo> jtbandes: I think the `stable-memo` package does this
17:36:59 <c_wraith> (It'll close over it, instead)
17:37:07 <Tekmo> jtbandes: See `memo2` here: http://hackage.haskell.org/packages/archive/stable-memo/0.2.2/doc/html/Data-StableMemo.html
17:40:03 <jtbandes> c_wraith: ah I see, I was trying to close over it but still ended up passing it back into the recursive call
17:40:47 <c_wraith> heh.  If you pass it in, you've failed to close over it. :)
17:41:23 <jtbandes> I was hoping pattern matching would take care of that for me :p
17:43:12 <jtbandes> i.e. the case of calling "f k x", if already inside a "f k _"
17:53:37 <Jentrep> Anyone feel like making a new web?
17:53:41 <Jentrep> Getting tired of this one
17:54:35 <zomg> Jentrep: https://images.encyclopediadramatica.se/thumb/4/4f/How_do_I_shot_web_gigantor_size.jpg/600px-How_do_I_shot_web_gigantor_size.jpg
17:54:53 <Jentrep> porn?
17:55:02 <zomg> nah it's SFW
17:55:14 <Jentrep> No that was me answering spiderman
17:55:23 <zomg> lol
17:56:10 <Jentrep> I almost feel like posting a Ask HN on hacker news
17:56:18 <Jentrep> *an Ask HN
17:56:40 <Jentrep> Ask HN: Would anyone like to build a new web?
17:57:06 <zomg> Do it
17:57:11 <zomg> I'm sure you would get.. interesting answers
17:57:13 <geekosaur> lots of folks would like to. the only ones who can agree as to its content are the spammers...
17:57:30 <Jentrep> Spammers?
17:58:10 <geekosaur> well, the ecosystem they inhabit, consisting of spam, largely infected-via-web botnets, and shitloads of cybercrime of all descriptions
17:58:23 <Jentrep> Ah right the web
17:59:14 <geekosaur> also a more direct relationof those would be that more personal internet users use webmail than any dedicated mail program
17:59:18 <Jentrep> zomg you say do it ... but I really doubt it would get anywhere
17:59:34 <zomg> Yeah I doubt it would really elicit any kind of real answers :D
17:59:35 <Jentrep> I use webmail
17:59:35 <zRecursive> :t (\f -> (=<<) (f who))
17:59:36 <lambdabot> Not in scope: `who'
17:59:44 <zRecursive> :t (\f -> (=<<) (f "me"))
17:59:45 <lambdabot> Monad m => ([Char] -> a -> m b) -> m a -> m b
17:59:54 <geekosaur> so do I. (heck, I used to host my own mail infrastructure, but that got old long since)
18:00:09 <Jentrep> lol
18:01:35 <zomg> If I had a million dollars (as in, wouldn't need to work to afford the usual living expenses), I'd start building a new web
18:01:52 <zomg> or maybe I would just drive around in my lamborghini and party all night...
18:01:56 <zomg> not sure.
18:01:57 <zomg> =)
18:02:32 <Jentrep> Both
18:02:42 <Jentrep> Youd get bored of both at different times
18:03:07 <Jentrep> zomg are you a finnish hacker?
18:03:13 <zomg> Yes
18:03:17 <Jentrep> O_O
18:03:28 <Jentrep> I must be a magnet for talking to Finnish hackers
18:03:32 <zomg> Oh? :P
18:03:39 <Jentrep> I talk to them all the time
18:03:42 <Jentrep> :P
18:03:49 <Jentrep> Guess it's time for me to move to Finland
18:03:53 <S_J> getAddrInfo: does not exist (error 10093) <- im trying to use cloud haskell on win8 but get that errorwhen doing t <- createTransport "127.0.0.1" "5000" defaultTCPParameters'
18:04:04 <zomg> heh
18:04:17 <latermuse> S_J: is your port 5000 open?
18:04:28 <Jentrep> hrmmm
18:04:38 <Jentrep> zomg what areas do you like hacking in?
18:05:01 <zomg> I'm primarily a web developer, frontend and backend stuff
18:05:13 <Jentrep> Ah cool
18:05:20 <zomg> I also do some game programming for fun, nothing fancy though
18:05:33 <Jentrep> Favorite langs?
18:05:42 <zomg> javascript and haskell? =)
18:05:49 <latermuse> hah
18:05:56 <Jentrep> Funny combo :P
18:06:03 <latermuse> javascript for the front, haskell for the back. its not unusual at all
18:06:21 <S_J> latermuse: yes. i read something about having to wrap a function on windows in Network.Socket but didnt really get it
18:06:23 <latermuse> thats why there is so much development on haskell to javascript compilers
18:06:24 <zomg> well pretty much gotta like javascript if you work with web stuff or you'll just hate it every day... :D
18:06:27 <Jentrep> Yeah, it's perfectly fine. But I still find it funny :P
18:06:39 <Jentrep> very true
18:07:13 <geekosaur> S_J: all socket operations must be done under (a single) withSocketsDo
18:07:37 <latermuse> S_J: for winsock stuff, you might want to check the wikipedia to get started with learning: http://en.wikipedia.org/wiki/Winsock
18:07:49 <geekosaur> not one per operation, more like put your actual program in a realMain function and your main is withSocketsDo realMain
18:16:56 <nooodl> i was going to read through https://www.fpcomplete.com/user/edwardk/cellular-automata but then i got distracted by the "instance Comonad (Pretext s)" exercise
18:17:44 <nooodl> and it's pretty tough! i have no idea how to tackle writing "duplicate" but i don't want to look it up either
18:19:04 <nooodl> has anyone else here tried it? i could use a hint
18:19:15 <danharaj> Saizan: I noticed a similarity between unification and pattern matching.
18:20:23 <S_J> How do I terminate a GLUT window properly
18:22:13 <CADD> nooodl: you should just look it up. why waste time worrying on a problem that has already been solved?
18:23:28 <jmcarthur> CADD: for education
18:24:12 <CADD> jmcarthur: i think educating yourself is reading and writing code, not reinventing the wheel.
18:24:30 <CADD> (imho) :)
18:25:44 <CADD> s/code/novel code/
18:26:38 <zomg> CADD: I think reinventing wheels can be useful at times
18:27:12 <byorgey> if education was only restricted to making up stuff that no one had ever done before, it would be impossible to learn anything.
18:27:17 <zomg> ^
18:28:23 <byorgey> CADD: why waste time telling other people not to waste their time?  Go write some code! ;)
18:28:31 <CADD> im not restricting education, i just find it more useful to read the implementation rather than to drudge through reinventing it.
18:28:39 <CADD> byorgey: hehe, right back at you! :)
18:28:51 <byorgey> OK.  perhaps nooodl finds it more useful to "drudge" through reinventing it.
18:29:10 <CADD> again thats why i added (imho)
18:30:34 <jmcarthur> CADD: have you never written a hello world before?
18:31:17 <jmcarthur> ah, nevermind, i don't want to just hound on it
18:32:38 <Hafydd> Hello World has been solved.
18:32:48 <S_J> How do I terminate a GLUT window properly, leaveMainLoop, but where do i call it?
18:36:02 <CADD> jmcarthur: sorry i was afk. ill make my point a bit better i think.
18:36:31 <CADD> jmcarthur: yeah i did, but i did it by looking at someone elses code. i didnt just try to blindly figure it out.
18:36:49 <CADD> either way, this is pretty off topic and going nowhere.. :)
18:37:03 <nooodl> hmm... i can't even find a solution -- the Pretext definition in lens is different, and the (Indexed)Comonad instance relies on a bunch of other confusing lens stuff
18:41:56 <CADD> nooodl: you mean duplicate?
18:42:49 <nooodl> i'm looking for a definition for duplicate, yeah
18:44:28 <CADD> nooodl: http://hackage.haskell.org/packages/archive/comonad/3.0.3/doc/html/src/Control-Comonad.html#duplicate
18:44:42 <CADD> nooodl: you probably already saw that
18:44:58 <nooodl> yeah
18:45:18 <CADD> nooodl: gotta love recursive definitions :)
18:45:30 <CADD> mutually recursive*
18:46:54 <nooodl> sadly you have to define one of duplicate/extend for it to work
18:47:07 <nooodl> hmm maybe i'll look for a way to write extend though
18:47:55 <CADD> nooodl: well technically you have to define both for it to work.. :)
18:47:58 <jmcarthur> extend and duplicate basically will have the same structure for most types
18:48:21 <jmcarthur> CADD: you are thinking extract+duplicate+fmap or extract+extend
18:48:39 <jmcarthur> CADD: you don't need both extend and duplicatye
18:48:41 <jmcarthur> *duplicate
18:48:46 <CADD> jmcarthur: well fmap comes ala functors, so the latter
18:48:59 <CADD> actually i mean extend and duplicate
18:49:09 <jmcarthur> you don't need both
18:49:31 <CADD> from what i see its a mutually recursive definition
18:49:36 <nooodl> oh yeah i'm running into the same problem :/
18:49:41 <jmcarthur> no, those are defaults
18:49:49 <CADD> oh ok
18:50:14 <CADD> right, that is just for the trivial comonad
18:50:33 <jmcarthur> no, it's for when you define one but not the other
18:50:53 <CADD> hmm, im not sure what you mena
18:50:54 <CADD> mean*
18:51:09 <jmcarthur> extract can be implemented in terms of extract and extend. extend can be implemented in terms of extract, duplicate, and fmap.
18:51:13 <jmcarthur> oops
18:51:18 <jmcarthur> extend can be implemented in terms of extract and extend. extend can be implemented in terms of extract, duplicate, and fmap.
18:51:20 <jmcarthur> gah
18:51:26 <jmcarthur> duplicate can be implemented in terms of extract and extend. extend can be implemented in terms of extract, duplicate, and fmap.
18:51:27 <jmcarthur> sorry
18:51:31 <CADD> thanks
18:51:33 <c_wraith> I hope extend can be implemented in terms of extend!
18:51:34 <c_wraith> :)
18:51:39 <CADD> now let me parse that :)
18:51:47 <jmcarthur> please only the last one :)
18:51:52 <CADD> yes sir
18:52:02 <nooodl> if you define "duplicate" haskell will know what "extend" is from its default implementation in terms of "duplicate"
18:52:07 <jmcarthur> hmm... apparently duplicate only needs extend
18:52:08 <nooodl> and vice versa
18:52:18 <jmcarthur> and extend needs fmap and duplicate
18:52:20 <jmcarthur> extract is separate
18:52:29 <CADD> thats what i meant by mutually recursive
18:52:33 <CADD> i think.. :)
18:52:39 <jmcarthur> but they aren't mutually recursive, or not intended to be
18:52:44 <CADD> anyway, the source is there
18:52:46 <CADD> oh ok
18:52:55 <jmcarthur> you are intended to override at least one of those
18:53:00 <jmcarthur> otherwise you just get an infinite loop
18:53:09 <CADD> that makes sense
18:53:14 <applicative> how do you define duplicate for this 'Pretext'?? Maybe the Constant functor...
18:53:15 <nooodl> (isn't this also how (>>=) and join work? maybe that would be a better example)
18:53:20 <jmcarthur> read the documentation
18:53:50 <nooodl> applicative: i'm real glad i'm not alone
18:54:31 <applicative> you've trapped me nooodl, grr
18:55:49 <jmcarthur> okay, i'll say it all in one place:  join can be implemented in terms of bind, and bind can be implemented in terms of join and fmap.   similarly, duplicate can be implemented in terms of extend, and extend can be implemented in terms of duplicate and fmap.
18:56:06 <flebron> is the state of the art for dense matrix computations repa?
18:56:07 <nart> hi
18:56:33 <johnw> flebron: certainly it's one of the active areas of development
18:56:39 <nart> why :t [(*), (+), (-)] :: Num a => [a -> a -> a] ?
18:56:52 <hpaste> nooodl pasted “duplicate for Pretext?” at http://lpaste.net/91926
18:56:54 <jmcarthur> flebron: i would say repa is a fine way to implement such things, but is certainly not intended to be the main thing to reach for for matrix stuff if you just want an existing matrix library
18:57:10 <jmcarthur> nart: what part of that do you find confusing?
18:57:17 <nooodl> applicative: this is what i've tried and i thought it would typecheck but it doesn't
18:57:26 <flebron> jmcarthur: as an exercise, i was going to compute the permanent of a matrix, and was wondering if repa was a reasonable way to do it, so that others may reuse it
18:57:47 <nart> jmcarthur: this [a->a->a]
18:57:48 <flebron> my experience with matrices + haskell has been in an environment without either vector or repa, so i'd had to deal with array :p
18:58:10 <nooodl> nart: [t] is a list of values of type t
18:58:11 <jmcarthur> nart: you have a list of functions. that's all that means
18:58:27 <flebron> nart: it's an array of functions, each function takes two "a"s and returns an "a" (or, equivalently due to currying, they take an "a" and return a function that takes an "a" and returns an "a")
18:58:31 <flebron> s/array/list/;
18:58:34 <jmcarthur> flebron: repa is in some ways nicer than array and in some ways more awkward
18:58:36 <nart> stupid me
18:58:47 <jmcarthur> flebron: vector is a little awkward for higher dimensional stuff
18:59:16 <johnw> there's also accelerate, if you have Nvidia hardware and your problem maps to that domain
18:59:19 <flebron> jmcarthur: were you to implement a matrix function that you wanted others to reuse, what would you use?
18:59:35 <nart> thanks, nooodl, jmcarthur, flebron
18:59:47 <jmcarthur> nart:  out of curiosity, what about that was unclear? how did you interpret it? i sometimes have trouble understanding people new to the language because it's been a while, and i'd like to know what your inclination was.
19:01:19 <jmcarthur> flebron: i don't know. i don't think many people really want to use repa directly.
19:01:35 <jmcarthur> flebron: linear algebra is something i feel like we still haven't "gotten right"
19:01:40 <flebron> ah
19:02:07 <nart> jmcarthur: actually i don't know, it may be that it's 4 am, i don't understand why i got confused by that extremly simple code
19:02:13 <nooodl> (applicative: oh, i see why -- the "f" in h's type is bound to the "forall f." in g's type and if i try "f h" that f would escape its scope)
19:02:36 <jmcarthur> nart: ah don't beat yourself up :)
19:03:52 <applicative> oh nooodl i just saw your paste
19:05:07 <applicative> oh, duplicate p@(Pretext f) = Pretext (fmap (const p) . f )
19:05:54 <applicative> that seems likely to be right, no?
19:07:00 <nooodl> wow. looks like it is
19:07:06 <nooodl> i was so close, too...
19:08:04 <applicative> oh, i just depointed yours.
19:08:11 <nooodl> yeah
19:08:41 <nooodl> they're different though, because of the of scope that "forall f."
19:09:11 <applicative> that tends to get one out of trouble when you want it to see you have a forall z . ... -> ...
19:09:19 <applicative> depointing does, i mean
19:09:20 <nooodl>     duplicate p@(Pretext f) = Pretext g where g = (fmap (const p) . f) -- doesn't work
19:09:34 <applicative> oh, just a sec
19:09:56 <nart> jmcarthur: actually i don't know, it may be that it's 4 am, i don't understand why i got confused by that extremly simple code
19:10:10 <nooodl> yours typechecks, at least, maybe i'll check the comonad laws to be sure
19:10:11 <applicative> right, thats let g = fmap (const p) . f in Pretext g
19:10:37 <heatsink> @seen dcoutts
19:10:37 <lambdabot> DcOuT+5
19:10:48 <heatsink> Huh?
19:10:50 * nooodl is never sure whether to use "let" or "where"
19:10:51 <geekosaur> ask preflex
19:11:02 <geekosaur> lambdabot doesn't have @seen, it's edit-corrected to @leet
19:11:18 <nooodl> (the best lambdabot bug imo)
19:11:24 <geekosaur> preflex: seen dcoutts
19:11:25 <preflex>  dcoutts was last seen on #ghc 2 days, 7 hours, 20 minutes and 34 seconds ago, saying: * dcoutts disappears
19:11:30 <heatsink> oh
19:11:38 <heatsink> Was seen removed?
19:11:41 <nooodl> nice disappearance
19:11:43 <geekosaur> long ago, yes
19:11:45 <geekosaur> it was buggy
19:11:52 <heatsink> I see
19:11:58 <geekosaur> and not really fixable due to lambdabot's architecture
19:12:09 <geekosaur> (I recall studying the code back when I ran one)
19:12:42 <geekosaur> basically if someone left the channel, rejoined, and said nothing, lambdabot would respond to @seen with "has not seen"
19:12:43 <heatsink> Wouldn't all the necessary info for @seen queries be in the @quote database?
19:13:08 <heatsink> I hacked a 'seen' command into some other bot that way.
19:13:26 <geekosaur> no, @quote does not track joins/parts/random speech
19:13:43 <geekosaur> you can't slurp someone else's remarks into lambdabot
19:14:04 <geekosaur> you have to explicitly make a @remember user whatever
19:14:14 <nooodl> applicative: yup, fits the laws
19:14:20 <heatsink> Oh, that's right.  Lambdabot quotes have to be inserted by a command.
19:14:31 <deech> Hi all, is there a tool that automatically binds Haskell to a C header file?
19:14:47 <johnw> deech: c2hsc aims to do that
19:14:50 <geekosaur> deech: c2hs?
19:14:59 <heatsink> If you want to call Haskell functions from C, you can use the foreign function interface
19:14:59 <johnw> c2hs requires you to actually write the bindings
19:15:01 <johnw> c2hsc generates them
19:15:19 <deech> Awesome, I'll check out c2hsc!
19:15:25 <johnw> deech: hi btw!
19:15:30 <johnw> deech: now I've seen you here :)
19:15:42 <johnw> (we meet at LambdaJam)
19:15:46 <johnw> s/meet/met
19:17:05 <deech> johnw: Hey, great to hear from you!
19:17:16 <johnw> are you coming to ICFP by chance?
19:17:35 <deech> johnw: No, September's a busy month for me.
19:17:49 <deech> johnw: And no-one's paying me to go :)
19:18:02 <deech> I take it you're going?
19:18:05 <johnw> yes
19:18:15 <johnw> this month is crazy busy for me, but next month is open enough
19:18:20 <deech> Cool.
19:18:33 <applicative> nooodl: did you do the other one, what is called, extract?
19:18:52 <nooodl> yeah: extract (Pretext f) = runIdentity $ f Identity
19:19:12 <applicative> oh yes, i was about to say
19:19:37 <deech> johnw: So in case you're interested in why I'm using your tool, I'm writing a binding to the C++ FLTK library. (github.com/deech/fltkc). The aim is to have a light-weight, cross-platform GUI for Haskell.
19:19:49 <applicative> runIdentity . ($ Identity) . runPretext
19:19:52 <johnw> yep, that's exactly why I created c2hsc
19:20:03 <johnw> i use it to generate bindings from libgit2, for which there are like 100 functions
19:20:23 <johnw> and they change too often for me to want to maintain hand-coded FFI bindings
19:29:39 <flebron> Given an n x n matrix in Repa, and a list of rows (or a function that tells you if a row is wanted or not), how could one obtain a matrix that has only the rows that are wanted from the input matrix?
19:29:51 <deech> johnw: I just cabal install'ed c2hsc and I'm running it with: c2hsc --prefix=Test /path/to/C/header.h and I get "gcc: error: : No such file or directory". Is this is an issue with not being able to find gcc?
19:30:00 <flebron> I'm thinking it's slice, but I just can't understand how slicing works :s
19:30:31 <johnw> hmm... that error makes it seem like it's trying to find a file named ""
19:31:04 <johnw> are you on Mac?
19:31:12 <deech> No, Ubuntu.
19:31:22 <johnw> then your invocation looks right
19:31:26 <johnw> do you need a -I option?
19:32:10 <deech> What's -I, I don't see it in the help message?
19:32:26 * hackagebot ghc-parmake 0.1.4 - A parallel wrapper for 'ghc --make'.  http://hackage.haskell.org/package/ghc-parmake-0.1.4 (MikhailGlushenkov)
19:32:28 * hackagebot ghc-parmake 0.1.5 - A parallel wrapper for 'ghc --make'.  http://hackage.haskell.org/package/ghc-parmake-0.1.5 (MikhailGlushenkov)
19:35:05 <johnw> -I, sets an include path
19:35:12 <Polarina> Can someone explain to me what the forall in types are?
19:35:15 <carter> flebron: repa's bad fro those sort of things
19:35:31 <johnw> Polarina: that's been a popular question lately!
19:35:34 <carter> you want to be able to do a filter over rows, right?
19:35:35 <johnw> Polarina: I can take a shot
19:35:44 <Polarina> Yay!
19:35:46 <carter> a bullseye even
19:35:52 <applicative> good luck, johnw!
19:36:25 <flebron> carter: My end goal is, for a given subset of the rows of size r, obtain those rows and form a r x n matrix. Then take the product of each column, forming a vector of length n. The compute the product of the entries of this vector.
19:36:27 <johnw> when you see a polymorphic function type like "foo :: a -> String", it means that 'a' gets fixed by how the caller uses the function.  If I call "foo (10 :: Int)", then 'a' is an Int.  That should be clear?
19:36:30 <flebron> *Then
19:36:42 <Polarina> johnw, mhm. :)
19:36:43 <carter> flebron: k
19:36:44 <carter> well
19:36:54 <carter> good news is once i finally get my shit out, that'll be easy
19:37:07 <flebron> (The reason is to compute the permanent of a matrix)
19:37:09 <carter> flebron: the way to do that in repa is to use delay
19:37:22 <carter> you do a delayed array of the right rank
19:37:31 <carter> and then again
19:37:47 <carter> the problem then
19:37:53 <carter> is
19:38:11 <carter> if you don't hae a uniform way of selecting the rows
19:38:15 <carter> you're hosed in repa
19:38:16 <johnw> ok, now let's get a little more complex: foo :: (a -> String) -> String.  This is a function that takes a function that yields a string and then returns a string.  And I could call it like: foo (show :: Int -> String)
19:38:16 <flebron> right
19:38:25 <johnw> again, fixing the type of 'a' based on how I use "foo"
19:38:32 <johnw> but now consider a wrinkle, after enabling RankNTypes:
19:38:39 <johnw> foo :: (forall a. a -> String) -> String
19:39:08 <johnw> now foo doesn't want just a function for its first argument, it wants a *polymorphic* function, because foo itself is going to decide what 'a' is, not the caller of foo
19:40:16 <johnw> thus, I could call just "foo show", and foo could use that show function (which happens to be polymorphic in its first argument) multiple times for different a's within the body of foo
19:40:19 <johnw> does that make sense?
19:40:30 <deech> johnw: FYI, the Git version doesn't have this problem.
19:40:30 <Polarina> It does.
19:41:19 <johnw> Polarina: that's all there is to it.  without forall you can polymorphic functions, and with forall you can also make polymorphic higher-ordered functions
19:41:27 <carter> flebron: also you want to transpose while you're picking out those rows
19:41:29 <johnw> ^you can make
19:41:39 <carter> so that the products can be fast
19:41:44 <carter> repa can't do that at all
19:41:44 <flebron> yeah :)
19:41:46 <johnw> function that take polymorphic functions as arguments
19:41:49 <carter> or at least not nicely
19:41:51 <flebron> repa does have transpose thouhg
19:41:54 <carter> yeah
19:42:02 <carter> you can express this in repa
19:42:05 <Polarina> johnw, it makes a lot more sense now. Thank you.
19:42:09 <carter> but you can't think about locality while doing it
19:42:29 <carter> even though you should
19:42:36 <joelteon> johnw: but then it'd have to be foo :: (forall a. Show a => a -> String) -> String
19:42:56 <johnw> yes, very good point
19:43:12 <johnw> forall a. a is only useful if you are passing the 'a' along or ignoring it
19:43:32 <joelteon> yeah forall a. a is really not very useful
19:43:33 <flebron> ignoring is used in the ST monad, for example
19:44:17 <johnw> joelteon: unless you want to eliminate the possibility of the function peeking at the value
19:44:25 <joelteon> except that
19:44:30 * arkeet doesn't like the Binary instances for Float/Double =(
19:44:30 <johnw> forall a. a is by nature a purely opaque value
19:44:48 <Polarina> arkeet, I agree.
19:45:00 <carter> whats the instances it has?
19:45:09 <arkeet> they use decodeFloat/encodeFloat
19:45:33 <flebron> carter: what should i use for now? Array?
19:45:44 <carter> flebron: you can probably get by with repa
19:45:58 <arkeet> so I can't read 4 bytes into a Float in the obvious way
19:46:15 <arkeet> oh.
19:46:17 <carter> arkeet: do a newtype to fix it? :)
19:46:21 <arkeet> no!
19:46:22 <arkeet> =(
19:46:27 <arkeet> I just wrote my own getFloat.
19:46:31 <Polarina> arkeet, how about a little touch of TemplateHaskell?
19:46:42 <Polarina> arkeet, there's Data.Binary.IEEE754
19:46:45 <arkeet> anything else is more effort than it's worth.
19:46:47 <arkeet> is there?
19:46:55 <Polarina> arkeet, separate package. Let me find it.
19:46:57 <arkeet> thank you!
19:47:00 <arkeet> found it.
19:47:00 <joelteon> binary-ieee754 is good
19:47:03 <flebron> i may go to hell for it but... isn't "getting 4 bytes to be a float" a reasonable use of unsafeCoerce?
19:47:12 <danharaj> no
19:47:19 <carter> flebron: on x86_64, i think so
19:47:20 <joelteon> unsafeCoerce is NEVER ok
19:47:29 <Polarina> arkeet, http://hackage.haskell.org/package/data-binary-ieee754
19:47:36 <arkeet> Polarina: I've already installed it.
19:47:38 <arkeet> =)
19:47:50 <carter> unsafeCoerce just requires understand the RTS intimately:)
19:47:59 <arkeet> unsafeCoerce :: Word32 -> Float seems reasonable.
19:48:00 <carter> btw: who here uses brew?
19:48:04 <deech> johnw: I think I have it working. It's pretty cool!
19:48:07 <arkeet> that's what I was using before.
19:48:08 <Polarina> arkeet, there's also a similar package for cereal if you ever want to use that.
19:48:16 <carter> arkeet: only for the unlifted versions
19:48:37 <arkeet> Polarina: I don't know what the difference between binary and cereal is, so I tossed a coin.
19:48:55 <Polarina> arkeet, cereal works on strict bytestrings, binary on lazy.
19:49:24 <arkeet> I see.
19:49:40 <Polarina> arkeet, cereal also supports failure without vomiting exceptions all over the carpet.
19:50:02 <arkeet> I'm not planning to fail. =)
19:50:08 <arkeet> but I'll keep that in mind.
19:50:25 <Polarina> arkeet, I mean, if you're handling arbitrary inputs, like from over a network. :)
19:50:45 <arkeet> I'm handling known inputs.
19:50:53 <arkeet> just trying to parse some binary files I have locally.
19:51:16 <Polarina> How often I wished I could trust my inputs.
19:53:02 <jmcarthur> joelteon: i wouldn't say never
19:53:23 <jmcarthur> but i would say that if you have to ask it's probably not okay
19:54:03 <carter> yeah
19:54:10 <carter> you just really really really understand exactly whats going one
19:54:12 <joelteon> just don't ask!
19:54:25 <johnw> deech: nice!  not that it doesn't handle CPP-related stuff, and you will almost certainly need to refine the output by hand
19:54:40 <carter> whats deech  doing?
19:54:53 <johnw> wrapping a C++ library for using from Haskell
19:55:32 <jmcarthur> confession: i've used unsafeCoerce just because it would have been very difficult to avoid it, and then uploaded it to hackage
19:55:37 <deech> johnw: Good to know. This is a great star.
19:55:44 <deech> s/star/start
19:55:46 <jmcarthur> i could have avoided it though
19:56:07 <carter> oh?
19:56:34 <jmcarthur> hmm, maybe i couldn't have after all
19:56:45 <deech> carter: You're helping with a C++ interface, right?
19:57:08 <carter> in some fuzzy way, i'm helping yes
19:57:08 <jmcarthur> did hackage just die again? :(
19:57:09 <carter> :)
19:57:22 <carter> LUITTTTTEEEE
19:57:24 <carter> :)
19:57:49 <begriffs> Hey, I've got a type system question. Is there a way to write the following statement so I get a type error rather than an exception?
19:57:50 <deech> carter: So I'm already pretty far into making extern'd versions of all the functions I need. Can I still use the library to generate the Haskell bindings?
19:57:53 <begriffs> ghci> case [] of x:xs -> x
19:57:53 <begriffs> *** Exception: <interactive>:9:1-20: Non-exhaustive patterns in case
19:58:21 <carter> deech: honestly, at that point you'll have better just doing it your way
19:58:22 <begriffs> Like a way that the compiler can notice I missed a pattern for constructing a list in my cases
19:58:33 <joelteon> begriffs: the compiler warns you about those cases
19:58:35 <jmcarthur> nope, i could have avoided it
19:59:04 <deech> carter: Cool. Thanks!
19:59:08 <begriffs> joelteon: so I only got the exception because I ran it in the repl rather than in a real source file.
19:59:20 <carter> deech: most of the fficxx stuff is about helping people get to that point + some haskell shims for the low level stuff
19:59:26 <carter> deech:what are you ffiing?
19:59:46 <jmcarthur> but, at the time at least, i would have had to implement a Map (f :: k -> *) (g :: k -> *). there are a couple choices now. also, this would be slower than the hashtable i was using
19:59:51 <deech> carter: fltk http://www.fltk.org/index.php github.com/deech/fltkc
20:00:29 <begriffs> joelteon: can I make ghci more strict so that it complains too? Like even when I run a working statement like case [] of [] -> "empty"
20:00:58 <jmcarthur> begriffs: :set -Wall
20:01:02 <joelteon> hmm
20:01:04 <johnw> hmm
20:01:06 <jmcarthur> hmm
20:01:10 <joelteon> oh, I forgot I had -Wall
20:01:11 <johnw> joeyh: git-annex won't build with the current HP anymore
20:01:13 <joelteon> yeah, you'll want that
20:01:42 <carter> deech: also most of the work was already done by wave wave
20:02:03 <carter> deech: cool!
20:02:13 <carter> What oses does it support?
20:02:31 <deech> Cool. I'll try and find (him?)
20:02:50 <carter> wavewave?
20:02:54 <deech> carter: It supports more than GHC, I think :)
20:02:58 <carter> ok
20:03:04 <carter> does it look native on all of them?
20:03:12 <deech> NOPE :)
20:03:27 <carter> whats it look like?
20:03:35 <carter> windows?
20:03:43 <begriffs> @joelteon thanks for the tip. Do you know why a missing pattern is considered only a warning and not a straight error?
20:03:43 <lambdabot> Unknown command, try @list
20:03:49 <deech> carter: carter: It not a great looking library, but it
20:03:54 <carter> works
20:03:54 <deech> carter: http://www.fltk.org/shots.php
20:03:55 <carter> gotit
20:04:14 <joelteon> begriffs: not sure
20:04:18 <deech> carter: Cut-and-paste error, sorry.
20:04:29 <carter> its fine
20:04:55 <deech> carter: It supports deploying the application as a zero-install static binary.
20:05:00 <carter> ooo
20:05:02 <carter> thats nice
20:05:10 <carter> well, per architecture
20:05:27 <deech> carter: So no installing X11 on Mac. But yeah, you need to provide platform-specific binaries.
20:05:46 <pentace> begriffs: Think of it as a partially defined function
20:05:55 <carter> gotit
20:06:06 <carter> you're doing important stuff then :)
20:06:07 <deech> carter: And it has pretty workable GUI builder. Not like Glade and certainly not like QT Creator, but good enough.
20:06:21 <joelteon> There are situations in which it's ok to miss a pattern, but I usually just do _ = error "some info about the function"
20:06:40 <carter> deech: but simpler to write a binding for, right?
20:06:43 <geekosaur> begriffs: if you know for some reason that you will never receive that parameter, why should you write code for it? but static analysis to recognize that it's not needed isn't always possib;e
20:07:34 <deech> carter: Yup. Small enough that I've been able to most of it myself. Still a lot of work, but manageable by one person given time.
20:07:34 <joelteon> right, but in that case, just fall back to an error call explaining the situation
20:08:21 <geekosaur> it's something of a pity that ghc can't produce a better default error in that case (at least including the constructor)
20:09:36 <begriffs> geekosaur: can you give me an example that baffles static analysis? (I'm sure there are plenty of them, but I'm ignorant)
20:09:46 <johnw> hi begriffs
20:09:57 <johnw> you're the one writing the "haskell each day" blog?
20:10:06 <begriffs> johnw: hi, yeah. :)
20:10:09 <geekosaur> begriffs, by that I meant that ghc cannot determine reliably that a function can never be invoked with a particular parameter
20:10:10 <joelteon> case splitOn " " ("foo" ++ somelist) of ...
20:10:15 <johnw> begriffs: having fun yet? :)
20:11:24 <begriffs> johnw: quite fun. Still have plenty of basic language questions like this case statement stuff.
20:12:29 <geekosaur> to give a trivial case, if there is any way that a function parameter could come from outside the current module, and a constructor pattern you omitted is exported, ghc can never be certain that it won't find its way in as a possible parameter
20:12:44 <geekosaur> since ghc doesn't do whole-program analysis/compilation
20:50:41 <heatsink> I have a function that uses 'min' and 'max' to compute loop bounds in some imperative code.
20:51:09 <heatsink> GHC's optimizer makes 24 copies of the loop body.  If I make the function NOINLINE, GHC's optimizer makes only 4 copies of the loop body.
20:51:50 <heatsink> Can I cut down on code replication in a better way?
20:52:40 <levi> Yay, I have a little Snap app hooked up to HLint now. Time to hook it up to doctest now...
20:52:50 <startling> heatsink, why do you think you want to cut down on code replication?
20:53:08 <startling> (in other words: have you benchmarked?)
20:53:43 <heatsink> startling, I'm trying to get as close as possible to the performance of an equivalent C code
20:54:02 <heatsink> Having 24 copies of the loop body makes it hard for me to read the output of -ddump-simpl
20:54:23 <heatsink> It's about 3 times slower than the C code now
20:59:46 <elliott> edwardk: lambdabot still broken?
20:59:54 <edwardk> :t over
20:59:54 <lambdabot> Not in scope: `over'
21:00:02 <edwardk> yep
21:03:51 <elliott> wtf
21:03:53 <elliott> @undefine
21:03:53 <lambdabot> Undefined.
21:03:54 <elliott> :t over
21:03:55 <lambdabot> Not in scope: `over'
21:03:57 <elliott> > over
21:03:58 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable1
21:03:58 <lambdabot>                     Contr...
21:04:02 <elliott> ugh
21:04:11 <elliott> I have no idea why that would happen.
21:04:18 <elliott> I assume the import is failing or something
21:05:14 <startling> > over _1 (+ 1) (0, 0)
21:05:15 <lambdabot>   (1,0)
21:05:16 <arkeet> > over id (+1) 1
21:05:18 <lambdabot>   2
21:05:35 <arkeet> :t over
21:05:36 <lambdabot> Not in scope: `over'
21:05:38 <arkeet> :V
21:06:57 <elliott> ok, well, let me wake up and then I'll take a look
21:07:02 <elliott> edwardk: it was probably adding extensions that broke it
21:07:27 <startling> I /knew/ there must be a reason everyone avoids ImplicitParams.
21:07:36 <arkeet> I love ImplicitParams.
21:07:42 <arkeet> haha
21:08:15 <startling> yeah, it's really nice, especially for DSLy things
21:08:16 <elliott> I wonder if I woke up at 4 am because I could sense lambdabot was broken.
21:08:20 <elliott> I should get paid for this.
21:08:35 <elliott> @flush
21:08:36 <elliott> @quit
21:08:45 <startling> well could have lambdabounties.
21:08:52 <elliott> :t over
21:08:55 <danharaj> actually lambdabot has been broken for a while
21:08:59 <danharaj> soooo
21:09:00 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
21:09:05 <elliott> ok, well.
21:09:12 <elliott> I *may* have just broken Safe Haskell.
21:09:17 <elliott> @let import System.IO.Unsafe
21:09:22 <lambdabot>  .L.hs:114:1:
21:09:28 <lambdabot>      System.IO.Unsafe: Can't be safely imported!
21:09:33 <elliott> works for me
21:09:38 <lambdabot> Plugin `eval' failed with: <<timeout>>
21:09:42 <startling> haha
21:09:44 <danharaj> does that work for you
21:09:44 <elliott> wtf.
21:09:51 <arkeet> haha
21:12:34 <tabemann> does anyone know why threadscope, for an event log lasting 10 seconds, would try to exhaust all the memory on one's sysetm?
21:12:38 <tabemann> *system
21:12:45 <dwcook> Is it possible to find a type at *least* as specific as a given type via Hoogle? e.g., say I want a -> [[b]], but it gives me things like a -> [a].
21:13:04 <elliott> edwardk: anyway, that will be $10,000, ty.
21:13:07 <tabemann> and mind this that this is 24 GB of memory here, minus about 2 GB for Firefox
21:15:24 <startling> dookdwcook: I think that means "we can't find it, here's this other thing"
21:15:56 <dwcook> startling, well, it also gives me functions of the form I want, like [a] -> [[a]]
21:16:28 <dwcook> What I want it to do is give me just things that unify with a given type
21:16:37 <dwcook> I'm guessing at this point that's simply not how it works
21:24:25 <heatsink> My intuition tells me that folding over an (enumFromTo m n) should be slower than a recursive function with an Int# loop counter
21:25:00 <heatsink> but my cpu disagrees
21:25:14 <arkeet> why should it be slower?
21:25:27 <heatsink> Because it builds a list of boxed integers
21:25:35 <geekosaur> ghc might well fuse it into something at least as efficient as your alternative
21:25:42 <arkeet> first of all, it doesn't build the entire list at once
21:25:43 <startling> heatsink, it doesn't "build" a list
21:25:53 <startling> dwcook, yeah, hoogle is kind of limited ime
21:26:17 <arkeet> second, ghc does optimization
21:26:32 <heatsink> I'm reading the output of -ddump-simpl.  The loop is not fused.
21:27:35 <heatsink> So it's at least allocating space, writing integers and list cell pointers to memory, and reading them back into registers
21:29:59 <shachaf> HemesisD
21:30:06 <heatsink> NemesisD
21:31:57 <NemesisD> shachaf: heatsink
21:32:18 * dmwit is confused
21:33:24 <NemesisD> shachaf: how's it going?
21:34:48 <NemesisD> heatsink: were you at the meetup as well?
21:35:24 <heatsink> Nope.  What meetup?
21:35:40 <arkeet> in seattle
21:36:55 <NemesisD> yep yep
21:37:04 <NemesisD> wait arkeet were you there?
21:37:08 <arkeet> nope
21:37:21 <heatsink> I'm not in seattle.  So there's lots of haskellers there?
21:37:42 <NemesisD> i don't actually know most of the attendees irc names
21:38:11 <NemesisD> this time was pretty light. < 10
21:38:15 <shachaf> It's easier when you use the same name in and out of IRC.
21:38:35 <arkeet> hm, why is my realname set to freenode?
21:39:07 <shachaf> Freenode Keet
21:39:39 <heatsink> Have you considered a job as an IRC server?
21:39:50 <arkeet> oh well, fixed for next time this thing connects.
21:40:09 <arkeet> I wonder when that will be.
21:43:34 <NemesisD> any time when i walk away from the SEAHUG meetup without a parking ticket is a good meetup
21:43:48 <arkeet> haha
21:45:08 <shachaf> I should've found a more general-interest topic.
21:46:18 <NemesisD> you guys seemed to have a pretty good contingency in the category theory room
21:46:19 <tabemann> damn you threadscope... I generate an event log for a *couple seconds*, and it still tries to eat all the RAM on my machine (minus that firefox has already eaten)
21:48:44 <mgsloan> shachaf: No worries, pretty sure Bartosz'd be categorying it up either way.  And now I understand hom functor variance / adjunctions / limits / cones better!  How much of that sticks around the next time I'm categoricalizing remains to be seen
21:49:17 <NemesisD> yeah bartosz is all about the CT
21:50:36 <mgsloan> should probably do some practical haskelling sometime
21:51:09 <mgsloan> maybe a tutorial session where everyone brings their laptops messes with the library being discussed
21:51:14 <carter> shachaf you gave a topic?
21:51:36 <carter> *talk
21:51:47 <Saizan> danharaj: as in pattern matching is unification where one side has no meta-vars, or something else?
21:51:52 <shachaf> carter: Not really.
21:52:02 <danharaj> Saizan: just that.
21:52:17 <danharaj> Saizan: It makes me wonder what higher order unification would do for expressivity .
21:52:19 <carter> oh
21:52:38 <shachaf> Bartosz came and we talked about adjunctions for a while, and then he left and I kept on blathering about things. Or something like that.
21:53:08 <mgsloan> Naah, your "blathering" was pretty well organized
21:53:38 <carter> cool! :)
21:54:00 <Saizan> danharaj: twelf uses it to implement HOAS natively, a newer language doing the same should be beluga but i've never managed to look it into it
21:54:22 <mgsloan> Covered limits in order to show how the diagonal functor is adjoint to limit / colimit
21:54:31 <danharaj> Saizan: hmm. what does a higher order pattern even look like?
21:54:40 <NemesisD> i like the idea of helping people work on/refactor their projects
21:54:50 <shachaf> mgsloan was threatening to make me do a lens talk but I narrowly escaped.
21:55:19 <mgsloan> At the very end we covered Mu / Nu / Fix, which I hadn't seen laid out like that before
21:55:26 <mgsloan> Hahah
21:56:10 <mgsloan> NemesisD: Yeah, have an informal seattle hackathon maybe?
21:56:30 <johnw> mgsloan: any recordings?
21:56:30 <shachaf> Maybe informally do it in SF.
21:57:08 <NemesisD> mgsloan: that would be cool
21:57:11 <mgsloan> johnw: Nope, it was pretty informal
21:57:41 <johnw> no slide decks or anything?
21:57:51 <Saizan> danharaj: you put lambdas in them
21:58:00 <mgsloan> You know what'd be a neat concept?  Parallel hackathons.  So, you'd have a seattle hackathon during HacPhi
21:58:10 <shachaf> No computers involved at all. Just a whiteboard.
21:58:36 * tabemann wishes we had haskeller meetups here in Milwaukee, but the closest thing I know of is an FP meetup in september... where they are covering *web frameworks* of all things (why web frameworks?)
21:58:37 <mgsloan> Yup, barely any Haskell made it up there till the end, either!
21:58:51 <danharaj> Saizan: I still can't construct such a pattern off the top of my head. I am too first order :(
21:59:07 <johnw> I would have liked to hear shachaf talk about adjunctions and limits very much
21:59:14 <mgsloan> Whiteboard turned out to be a good medium, though - the different colors for the parts of limits was really helpful
21:59:21 <NemesisD> one day one of us is going to do slides, i'm sure of it
21:59:44 <shachaf> That must be a joke about how long-winded I am. :-)
22:00:18 <Saizan> danharaj: i'm trying to find examples on the twelf introduction but they can all be eta-contracted to ones not using lambdas
22:00:27 <startling> maybe I should see if there are any meetups around here (chicago)
22:00:40 <danharaj> Saizan: oh you don't have to do that. I'll get around to it eventually :)
22:00:44 <johnw> startling: Sep 14
22:00:48 <Saizan> danharaj: though for example (\x -> E) would match those lambdas whose body doesn't use the variable
22:01:08 <startling> johnw, where? does it have a googleable name?
22:01:13 <johnw> startling: https://plus.google.com/communities/116633609119253853717
22:01:24 <NemesisD> ah yeah actually one of the guys at our meetup is going to school in chicago, i'm sure he'll be excited to find that out
22:01:26 <johnw> i believe that's where chicagohaskell.com redirects to
22:01:28 <johnw> i'm near chicago too
22:01:38 <startling> cool!
22:01:44 <johnw> i'll be there, come join!
22:01:55 <tabemann> too bad going all the way to chicago for a meetup would be a pain here if it were on a weekday...
22:02:45 <tabemann> oh it's a saturday
22:03:32 <tabemann> and it's one that doesn't conflict with anything
22:03:33 <danharaj> Saizan: I have to go to bed now but we should talk more about unification another time.
22:06:01 <johnw> shachaf: that wasn't it; I've enjoyed many of your category theoretical musings in the past
22:07:22 <johnw> and always learned something valuable from them, too
22:07:52 <NemesisD> hey guys if i'm trying to update cabal to HEAD. when installing Cabal with.. cabal it warns that the module-management package is likely to be broken. what should i do
22:08:13 <johnw> reinstall module-management afterwards
22:08:16 <johnw> it relies on the Cabal library
22:08:21 <NemesisD> ah ok
22:09:59 <mgsloan> Yup, I certainly went away from today with a refreshed understanding of category theory - I found it unusually clear!  Also, I really feel like studying it more right now
22:10:11 <mgsloan> Going to put that off for a bit yet :P
22:10:25 <johnw> um, glad to hear that :)
22:10:32 <johnw> not because C
22:10:34 <mgsloan> :D
22:10:35 <johnw> T isn't worth it!
22:10:47 <johnw> but because I know what else mgsloan is supposed to be doing right now ;)
22:11:08 <johnw> having me here must be like getting facebook stalked, huh mgsloan?
22:11:25 <Saizan> @tell danharaj sure, btw I think you can find some good examples here, even if it's logic programming http://www.lix.polytechnique.fr/Labo/Dale.Miller/papers/abstracts.html#nadathur95handbook
22:11:26 <lambdabot> Consider it noted.
22:12:16 <mgsloan> johnw: Hahaha, naah.  I'll be pushing some stuff shortly ;)
22:13:39 <NemesisD> out of curiousity, how practical would it be to get a job as a haskell dev without strong understanding of CT?
22:14:08 <johnw> NemesisD: in which field, academic research or commercial/industry programming?
22:14:15 <NemesisD> commercial
22:14:23 <johnw> I don't really think anyone would care
22:14:30 <mgsloan> Yeah, pretty much unrelated
22:14:31 * tabemann isn't sure where he would get a haskell dev job anywhere commercial in the first place
22:14:42 <NemesisD> so it isn't really used that heavily at FP complete, for example?
22:14:47 <tabemann> and yes, I doubt commercial people would care a bit about whether one knows CT
22:14:48 <johnw> no, not at all
22:14:59 <johnw> CT is something we study for personal enrichment and better coding design
22:14:59 <NemesisD> i mean beyond the common faire of monads, applicative, functors, etc
22:15:04 <johnw> but as a prereq?  no
22:15:28 <NemesisD> good information to know
22:15:52 <NemesisD> if i ever end up burning out at my job i may consider it
22:16:10 <johnw> I've found that what I need to know well at FP Complete is exception safety, how to write sound concurrent code, the use of many different libraries, and knowing the ins and outs of monad transformers
22:16:11 <NemesisD> its hard to pass up being a ruby dev around here though.
22:18:20 <zomg> Yeah good luck finding haskell work, especially if you're not interested in relocating =)
22:18:33 <johnw> zomg: just fyi, we all work remotely
22:18:53 <johnw> plus, I interviewed at a company on the east coast that wanted a remote Haskell dev
22:18:57 <johnw> so, those jobs are out there
22:19:04 <zomg> oh good to know that at least some companies in the field are sensible =)
22:19:29 <jmcarthur> not all jobs *can* be done remotely, of course
22:19:36 <NemesisD> i'm extremely disinterested in relocating ;) there's a good chance that if my current job wasn't the only decent rails gig in the Lynnwood, WA area, i may have rage quit by now
22:19:40 <zomg> but I'm guessing you heard of said work through someone and not just by searching
22:19:42 <thinkpad20> anyone know companies in Chicago that are hiring Haskell devs?
22:19:50 <johnw> zomg: both jobs I saw posted on cafe, I think
22:19:59 <zomg> maybe I should start reading it
22:20:00 <zomg> :P
22:20:12 <NemesisD> i prefer in-person work usually. i go a bit crazy working at home
22:20:12 <thinkpad20> almost all of the stuff I've seen advertised has been java, python or ruby
22:20:28 <zomg> Not sure if I have good enough haskell chops yet though but won't hurt to try if someone wants to hire remote people =)
22:20:44 <johnw> NemesisD: i started working at home in '99, it took some adjustment at first for certain
22:22:10 <zomg> I like working remotely because I can choose when I work rather than having to work when someone else chooses
22:23:19 <NemesisD> i just like the personal interaction/comraderie with my coworkers. my team at the place i work is pretty awesome. the only person that ever grinds my gears is unfortunately the CEO :/
22:23:32 <johnw> IRC is where I interact with my co-workers :)
22:24:02 <johnw> but you're right
22:24:05 <zomg> Current client super happy because I sometimes work during the weekends, they just don't know I work whenever I feel like and sometimes that's during the weekend (especially if I didn't put in that many hours during the weekdays) =)
22:24:07 <johnw> I do miss face-to-face meetings sometimes
22:24:11 <johnw> just not the frequency of them
22:25:17 <thinkpad20> yeah if your workplace is good it's definitely nice to be able to go to work
22:25:34 <thinkpad20> programmers need social interaction too :)
22:26:13 <zomg> Problem with those at least here tend to be they always expect you to show up if it's possible for you to show up
22:26:27 <zomg> and when you don't they think you're not working
22:27:01 <zomg> which might be entirely true in my case, but I probably would just do the same work in the evening or at night when they're sleeping =)
22:27:10 <NemesisD> depending on how competitive the job market is for the language, i think employers tend to relax on stuff like that
22:28:58 <NemesisD> holy crap. cabal repl
22:29:05 <johnw> heh
22:29:12 <NemesisD> switching to cabal HEAD was the best decision i've made in a long  time
22:31:10 <pharaun> i only interact with coworkers on irc :)
22:31:15 <pharaun> i'm a remote local worker
22:33:37 <pharaun> is there a good way to make parsec parser "success at parsing x" then reverting so that a latter parser can then actually parse it?
22:33:43 <pharaun> i guess what i want is a lookAhead parser
22:33:58 <johnw> use try
22:34:06 <johnw> try (someParser) <|> someOtherParser
22:34:21 <johnw> the try will reset the token stream before attempting someOtherParser
22:34:50 <startling> you need something like try (someParser *> empty)
22:34:59 <johnw> why the empty?
22:34:59 <pharaun> yeah i tried, but i'm not sure its the right way, because - "Foo++", i only want to parse up to the ++, but i want to reset at ++ so a latter parser can parse the ++ but i don't want to make the latter parse responsible for parsing the Foo part
22:35:11 <johnw> ah
22:35:17 <startling> johnw, because if the "try" succeeds it won't revert
22:35:27 <mauke> @hoogle notFollowedBy
22:35:27 <lambdabot> Text.Parsec.Combinator notFollowedBy :: (Stream s m t, Show a) => ParsecT s u m a -> ParsecT s u m ()
22:35:27 <lambdabot> Text.ParserCombinators.Parsec.Combinator notFollowedBy :: (Stream s m t, Show a) => ParsecT s u m a -> ParsecT s u m ()
22:35:31 <johnw> oh, I didn't realize he always wanted it to fail
22:35:35 <startling> pharaun: I think you can do it in terms of notFollowedBy
22:35:37 <startling> oh
22:35:50 <pharaun> hm let me see if i can't express it clearer?
22:35:54 <johnw> :(
22:35:56 <johnw> :)
22:36:16 <mauke> pharaun: what is this for?
22:36:21 <startling> pharaun: you want to parse some string only if some other parser succeeds at parsing it?
22:36:22 <pharaun> "a++" I want Parser 1 to parse the A part up to ++ part, but all of the parser i've found so far will work and then *eat* the ++ part
22:36:28 <pharaun> i want to force them to uneat the ++ part
22:36:43 <pharaun> so that a later parser can then eat the ++ part and do stuff with it
22:36:43 <NemesisD> is parsec still generally preferred to attoparsec?
22:36:46 <carter> NemesisD: i have cabal repl now, but i've not really used it
22:36:52 <carter> depends on what your'e parsing
22:37:18 <NemesisD> how so
22:37:26 <startling> @hoogle followedBy
22:37:26 <lambdabot> Text.Parsec.Combinator notFollowedBy :: (Stream s m t, Show a) => ParsecT s u m a -> ParsecT s u m ()
22:37:26 <lambdabot> Text.ParserCombinators.Parsec.Combinator notFollowedBy :: (Stream s m t, Show a) => ParsecT s u m a -> ParsecT s u m ()
22:37:29 <pharaun> mauke: parsing a very silly karma thing, trying to improve my parsing skills with "unclear" grammar
22:37:30 <startling> heh
22:37:46 <startling> pharaun: fwiw parsers/trifecta makes postfix operators super easy
22:37:59 <pharaun> i've never used ^ i could be interested
22:38:09 <johnw> i much prefer trifecta
22:38:16 <johnw> the error messages alone make it worthwhile
22:38:24 <pharaun> i'm used to parsec since its what i learned first
22:38:32 <johnw> then you pretty much already know trifecta
22:38:38 <johnw> it uses almost the same API
22:38:41 <pharaun> oh?
22:38:48 <startling> pharaun: it's in Text.Parser.Expression or something (in the 'parsers' package)
22:38:53 <johnw> yeah, just change the import and fix a few compile errors
22:39:07 <startling> also all the type signatures
22:39:13 <carter> trifecta is neat,  i need an excuse to use it
22:39:24 <johnw> the only time NOT to use trifecta is if you're dealing with loads af binary data, in which case even edwardk recommends attoparsec
22:39:56 <johnw> can someone give me a TH one-liner that will pause during compilation for 10 seconds?
22:40:02 <NemesisD> ive never heard trifecta
22:40:08 <startling> johnw, oh god
22:40:23 <johnw> startling: i'm trying to test a production bug and our compilation is just too fast
22:40:28 <pharaun> i'm looking at trifecta and it doesn't seem to have stuff like "many1" etc ?
22:40:37 <johnw> pharaun: those are in the parsers module
22:40:42 <johnw> trifecta is a consumer of parsers
22:40:47 <startling> pharaun, all the combinators are in "parsers"
22:40:56 <startling> those are defined in terms of a few base classes.
22:41:08 <startling> "trifecta" has a parser type that's an instance of those classes.
22:41:19 <startling> there's another package that makes ParsecT an instance too, I think
22:41:36 <pharaun> ohh it was in parsers
22:41:46 <pharaun> yeah ok
22:42:23 <pharaun> alright time to roll up my sleeves and get dirty with this, thanks guys :)
22:42:31 <JoshTriplett> Does this function have a name: \f x -> last $ unfoldr f x
22:42:32 <JoshTriplett> ?
22:42:48 <JoshTriplett> I don't want the intermediate list, I just want to iterate a function until it stops working and return the last value.
22:43:00 <johnw> pharaun: an example trifecta parser for you: https://github.com/ledger/ledger4/blob/master/ledger-parse/Ledger/Parser/Text.hs
22:43:20 <startling> :t \f x -> last $ unfoldr f x
22:43:20 <lambdabot> (b -> Maybe (a, b)) -> b -> a
22:43:43 <pharaun> johnw: looks very familiar to me ;p sweet
22:43:51 <shachaf> johnw: runIO (threadDelay 10000000) ?
22:44:04 <startling> johnw, /ledger/ (not hledger) uses trifecta?
22:44:05 <JoshTriplett> Or, even better, I'd like a function (a -> Maybe a) -> a -> a
22:44:10 <johnw> shachaf: thanks!
22:44:11 <JoshTriplett> "run this until it stops"
22:44:31 <JoshTriplett> @hoogle (a -> Maybe a) -> a -> a
22:44:31 <lambdabot> Data.IntMap.Strict updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
22:44:31 <lambdabot> Data.IntMap.Lazy updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
22:44:31 <lambdabot> Data.IntMap.Strict updateMin :: (a -> Maybe a) -> IntMap a -> IntMap a
22:44:48 <startling> JoshTriplett: I don't see what's wrong with \f -> last . unfoldr f
22:44:59 <startling> :t (last .) . unfoldr
22:45:00 <lambdabot> (a -> Maybe (c, a)) -> a -> c
22:45:17 <johnw> startling: ledger4 is my own rewrite of Ledger into Haskell, with the intention that hledger and ledger4 will merge at some point
22:45:18 <JoshTriplett> startling: Just seems like something that ought to have a name.  (And also, I don't need the state, and I'd like it to return the initial value if the function returns Nothing first.)
22:45:31 <johnw> since sm prefers the higher-level stuff, and I prefer the lower-level stuff
22:45:47 <carter> johnw ooo
22:45:53 <startling> johnw, neat!
22:46:46 <JoshTriplett> lastJust f x = case f x of Just x' -> lastJust f x' ; Nothing -> x
22:47:20 <carter> johnw: i need to start doing accounting somet time...
22:48:49 <carter> *learning
22:48:59 <johnw> JoshTriplett: that's really close to iterateM_, except for the behavior of your termination condition
22:49:03 <johnw> (from monad-loops)
22:49:09 <JoshTriplett> johnw: Yeah.
22:49:14 <JoshTriplett> Exactly.
22:49:21 <JoshTriplett> Hence me thinking it ought to have a name.
22:49:50 <johnw> well, it's odd that iterateWhile doesn't have the "feedback" behavior that iterateM_ does
22:49:54 <johnw> which strikes me as a poor name choice
22:50:21 <johnw> your function should be iterateWhile perhaps, and iterateWhile changed to repeatWhile
22:50:42 <JoshTriplett> @type iterateWhile'
22:50:43 <lambdabot> Not in scope: iterateWhile'
22:50:44 <JoshTriplett> @type iterateWhile
22:50:45 <lambdabot> Not in scope: `iterateWhile'
22:50:53 <JoshTriplett> @hoogle iterateWhile
22:50:54 <lambdabot> No results found
22:50:54 <johnw> @type Control.Monad.Loops.iterateWhile
22:50:55 <lambdabot> Monad m => (a -> Bool) -> m a -> m a
22:51:20 <JoshTriplett> johnw: I agree; that smells like "repeatWhile", or just "whileM".
22:51:59 <JoshTriplett> Also, better implementation: iterateMaybe f x = maybe x (iterateMaybe f) $ f x
22:52:18 <shachaf> Building that out of something that uses Bool seems like a step backwards from just writing it out.
22:52:44 <JoshTriplett> Oh, I just realized that that's "a -> Bool", not "m Bool".
22:52:47 <JoshTriplett> Yeah, I agree. :)
22:56:56 <johnw> also agree
22:57:40 <shachaf> I also agree.
22:57:43 <bicgena> Given a bitonic sequence as an array, find the minimum(or maximum, doesn't matter...) number in the array. definition on wikipedia "A bitonic sequence is a sequence with x_0 ≤ ... ≤ x_k ≥ ... ≥ x_{n-1} for some k, 0 ≤ k < n, or a circular shift of such a sequence."
22:59:47 <elliott> please don't crosspost identical lines in both #haskell and -blah under two different nicks...
23:00:14 <Hafydd> Especially if they're stupid lines.
23:13:41 <dmj`> I remember that question from my algorithms class
23:35:55 <lightquake> i'm trying to model tumblr posts as a datatype/group of related datatypes. some kinds of tumblr posts can have titles; some can have an associated URL, etc., but all of them have bodies and tags
23:37:05 <haasn> Has* classes?
23:38:37 <lightquake> maybe
23:41:52 <startling> data Post = Post { extra :: [Extra], body :: Text, Tags :: [String] }
23:42:11 <startling> data Extra = Url ...
23:43:25 <dmj`> > 4 < 5 < 6
23:43:27 <lambdabot>   Precedence parsing error
23:43:27 <lambdabot>      cannot mix `GHC.Classes.<' [infix 4] and `GHC...
23:44:04 <lightquake> dmj`: afaik python is the only language that lets you do that
23:44:13 <arkeet> > all . (zipWith (<) `ap` tail) $ [4,5,6]
23:44:14 <lambdabot>   Couldn't match type `a0 -> GHC.Types.Bool' with `[GHC.Types.Bool]'
23:44:15 <lambdabot>  Expecte...
23:44:23 <arkeet> > and . (zipWith (<) `ap` tail) $ [4,5,6]
23:44:24 <lambdabot>   True
23:44:44 <dmj`> lightquake: ah good to know
23:44:50 <dmj`> arkeet: very cool
23:46:14 <arkeet> I don't know why I wrote `ap` instead of <*>
