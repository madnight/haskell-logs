00:00:25 <shachaf> E.g. mapEither and mapPair and mapFst are abstracted by Bifunctor perfectly well.
00:01:34 <shachaf> And that's actually a useful abstraction. And Profunctor is also useful, though maybe less general-purpose. But Arrow is just not suitable for almost everything people want, and its types happen to specialize to useful things when you pick the most boring instance you can.
00:02:15 <sopvop> Profunctor is the one like bifunctor but with one part  contravariant, right?
00:02:23 <danr> yes
00:03:08 <Ghoul_> zvrba: llvm doesn't work
00:03:13 <Ghoul_> everything else seems to work
00:03:29 <Ghoul_> its much much faster than 32-bit also. 32-bit ghc has the worst contention issues ever.
00:03:30 <zvrba> shachaf: hmm.. what about Arrows? why are they a bad abstraction? it seems that you've continued some previous discussion
00:03:53 <zvrba> Ghoul_: i can live without llvm. (does it generate faster code?)
00:04:02 <Ghoul_> the ncg generates much faster code
00:04:06 <zvrba> ncg?
00:04:11 <Ghoul_> native codegen
00:04:20 <zvrba> oh. so why port it to LLVM?
00:04:22 <Ghoul_> I doubt you'll get faster code with the 64-bit ncg than with 32-bit llvm though
00:04:36 <zvrba> ok
00:05:14 <Ghoul_> err, that turned into a mess, and I think you may have missed the thing I was trying to convey
00:05:29 <zvrba> yes :)
00:05:35 <Ghoul_> LLVM generates the fastest code, but llvm doesn't work on 64-bit ghc -- it only works on 32-bit
00:05:43 <zvrba> ok
00:05:49 <Ghoul_> therefore, 32-bit ghc using LLVM is probably faster than 64-bit GHC without it
00:06:06 <Ghoul_> (but benchmark, ofcourse, if you must)
00:06:20 <zvrba> no, speed is not that important.
00:06:40 <zvrba> can I install 64-bit ghc from cabal, or how do I proceed?
00:06:42 <Ghoul_> in terms of the native codegen then 64-bit is much faster because the 32-bit native codegen has really really bad code generation problems IRT the lack of registers on x86
00:06:58 <zvrba> haskell platform installs itself somewhere under program files..
00:07:03 <Ghoul_> http://www.haskell.org/ghc/download_ghc_7_6_3
00:07:07 <Ghoul_> windows x86_64 from there
00:07:19 <zvrba> oh, cool. thanks.
00:07:28 <Ghoul_> you'll have to find your own way to get it on your path and such
00:07:41 <Ghoul_> you can still use all the regular 32-bit stuff supplied by haskell-platform
00:07:50 <Ghoul_> so you dont need to replace cabal and such
00:07:58 <sopvop> About arrows - the only usage of them I know is that xml library. And I think it's horrible.
00:08:09 <zvrba> Ghoul_: but what about existing packages installed by platform?
00:08:11 <Ghoul_> You will need to rebuild all your cabal stuff though
00:08:20 <Ghoul_> uhh, im unsure.
00:08:21 <zvrba> hehe, as i suspected :)
00:08:31 <Ghoul_> I actually run dual target
00:08:36 <zvrba> what's that?
00:08:37 <Ghoul_> but I have the mingw hostnae change when I swap enviuronments
00:08:42 <Ghoul_> so cabal automatically deals with that for me
00:08:51 <Ghoul_> Oh, I run 32-bit and 64-bit ghc in the same environment
00:08:58 <Ghoul_> I can run a command to swap between
00:09:09 <zvrba> how do you do that?
00:10:00 <Letchik> Does anybody here know where I can get the BigFloat library by Martin Guy mentioned here http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics? The link mentioned on wiki page is dead.
00:10:40 <Ghoul_> zvrba: I only run ghc through mingw
00:10:53 <Ghoul_> I followed instructions here to make my base dual target environment (supporting C/C++): http://ingar.satgnu.net/devenv/mingw32/base.html
00:11:09 <Ghoul_> and then I modified respectively to also include swapping PATH's for ghc
00:11:32 <Ghoul_> cabal automatically separates the two, which is really neat. When I swap environments the packages all change and I just have to install them and they separate fine
00:11:55 <Ghoul_> (because cabal detects the name of the environment changes and puts them in different folders respectively)
00:12:04 <zvrba> oh, nice
00:12:26 <Ghoul_> beware though you cant currently build GHC from HEAD with that environment because ghc has a glitch where it doesn't build with gcc 4.8 on windows
00:12:41 <zvrba> sigh
00:12:47 <Ghoul_> so if you plan on compiling a HEAD for yourself, setting up dual targets per those instructions will give you headaches
00:13:04 <Ghoul_> I've reported it, I think thoughtpolice is on it.. when he gets time
00:13:20 <ezrios> how does one accomplish accumulative recursion without using recursion explicitly?
00:13:27 <ezrios> that is to say, using higher order functions/pointfree or somesuch
00:13:37 <Ghoul_> What do you mean exactly?
00:13:46 <zvrba> Ghoul_: nah, i'll just download the binary.
00:13:47 <Ghoul_> :t foldr
00:13:48 <lambdabot> (a -> b -> b) -> b -> [a] -> b
00:14:15 <Ghoul_> > take 4 $ foldr (\i n -> n + i) 1 [1..]
00:14:16 <lambdabot>   No instance for (GHC.Show.Show a0)
00:14:16 <lambdabot>    arising from a use of `M1497938256.sh...
00:14:40 <Ghoul_> > take 4 $ foldr (+) 1 [1..]
00:14:41 <lambdabot>   No instance for (GHC.Show.Show a0)
00:14:41 <lambdabot>    arising from a use of `M1430857052.sh...
00:14:56 <Ghoul_> ??
00:15:21 <supki> take 4 what?
00:15:32 <Ghoul_> OH derp
00:15:39 <Ghoul_> > foldr (+) 1 [1..]
00:15:41 <lambdabot>   *Exception: stack overflow
00:16:00 <arkeet> not that that even returns a list
00:16:01 <arkeet> :v
00:16:03 <Ghoul_> Ugh, embarasssing. put a cap on the list and it'll not flow over
00:16:07 <arkeet> unless you have Num instances on lists
00:16:13 <arkeet> > scanr (+) 1 [1..]
00:16:15 <lambdabot>   [*Exception: stack overflow
00:16:18 <arkeet> > scanl (+) 1 [1..]
00:16:19 <lambdabot>   [1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254,...
00:16:26 <arkeet> > scanl (+) 0 [0..]
00:16:27 <lambdabot>   [0,0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,25...
00:16:44 <Ghoul_> Oh yeah, left works with lambdabot because it doesn't S-O
00:17:10 <Ghoul_> zvrba: yeah thats the easiest way
00:19:45 <Ghoul_> ive been off haskell for a while. suffering like withdrawal or something
00:20:24 <zvrba> oh?
00:22:47 <Ghoul_> I wiped my laptop because I was going for an arch/xmonad setup, but then I lost motivation to do all the customization and now it's sitting as a shell haha
00:23:41 <Ghoul_> Also had pretty bad compatibility issues with the latest kernel and toshiba being bad at supporting linux and stuff like that. I'll end up having to just reinstall windows :(
00:35:09 <levi> Ghoul_: arch is pretty brutal that way. My laptop is set up with arch/xmonad, but I regret it sometimes.
00:36:42 <Ghoul_> I dont mind it. toshiba bios engineers have no idea what they are doing though
00:36:51 <Ghoul_> they make linux a PITA to work with.
00:37:10 <Ghoul_> my next laptop would undoubtedly be a mac or an ASUS or something. Even system76 is tempting
00:38:29 <levi> I have a thinkpad.
00:39:06 <Ghoul_> Ive heard good things about lenovo, but they are hard to find cost effective. lets move to #haskell-blah
00:42:16 <zvrba> Ghoul_: what about running linux in a vm?
00:42:56 <Ghoul_> I don't like it.
00:43:18 <mcbonz> zvrba: what about running windows in a vm? :P
00:43:35 <Ghoul_> I have quad 0.8-1.5ghz cores, so im kind of at a lack of power for that kind of thing
00:48:51 <twoolie> can anyone familiar with parsec help me figure out why im getting these type errors? http://lpaste.net/7859560997994889216
00:58:14 <twoolie> is anyone still watching the channel?
00:59:55 <YoungFrog> I am, just now, but won't be able to help. I'm just lurking here for no good reason
01:01:10 <shiona> same here
01:01:45 <arkeet> I apparently am, but I ought to be in bed.
01:03:58 <twoolie> can someone take a look at this code and tell me why it throws type errors?
01:03:59 <twoolie> http://lpaste.net/7859560997994889216
01:04:16 <twoolie> I'm sure i'm just not understanding type aliasing correctly or somehting
01:08:34 <cmears> Instead of the type annotation at the end
01:08:35 <cmears> try this:
01:08:37 <cmears> optionEither :: Parse a -> Parse b -> Parse (Either a b)
01:10:53 <Ghoul_> does haskell use reference counting in its GC?
01:10:55 <twoolie> ok, so that worked.
01:11:18 <twoolie> thanks cmears. but why did it work?
01:12:30 <Cale> Ghoul_: no
01:12:49 <arnsholt> Ghoul_: IIRC GHC has a copying GC
01:12:51 <Ghoul_> Oh, generational GC
01:12:55 <Ghoul_> thats so clever
01:13:01 <Cale> It's a combination of copy collection and mark/sweep
01:13:11 <Cale> http://ghc.haskell.org/trac/ghc/wiki/GarbageCollectorNotes
01:13:39 <Cale> (that's actually a bit old)
01:13:45 <Ghoul_> maybe this is older? http://www.haskell.org/haskellwiki/GHC/Memory_Management
01:13:52 <Cale> The GC now runs in parallel
01:14:29 <Cale> I dunno, but GHC has had a generational garbage collector for a long time
01:14:59 <Ghoul_> .. is it still generational?
01:15:14 <Cale> yes
01:16:17 <Cale> It's also still stop-the-world, but collections run in parallel across available cores
01:16:35 <Ghoul_> wouldn't have thought stop-the-world would be a good thing
01:18:38 <Cale> Well, they tried a mode where one capability could be doing a GC while another one was running code, but apparently it worked out to be slower in many cases.
01:26:07 <arnsholt> From what I gather, stop the world is good for throughput, but bad for interactivity
01:26:18 <arnsholt> (Relatively simple to see why)
01:31:02 <cmears> twoolie, I think introducing "ta" and "tb" does not work
01:31:17 <cmears> it's trying to match them against the implicitly introduced type variables, which it can't do
01:35:01 * carter @tell tikhon yes i'm on a team, shoot me an email :) 
01:35:03 <carter> @tell tikhon yes i'm on a team, shoot me an email :)
01:35:03 <lambdabot> Consider it noted.
01:52:22 <arnsholt> What's the best way to inspect time profile data? (From a Haskell program, obviously)
01:52:49 <arnsholt> Do people just read the report, or are there visualisation tools?
01:56:03 <Work_jack> arnsholt: ThreadScope and Criterion come to mind
01:58:29 <arnsholt> I'll look into those. Cheers!
02:03:47 <quchen> arnsholt: Criterion is for profiling functions, ThreadScope is more for having a look at how your concurrency/parallelism is doing.
02:12:19 <arnsholt> Ah, ok
02:13:09 <arnsholt> Criterion is probably more what I need then. I suspect I'm leaking memory
02:15:08 <killy9999> Criterion is for benchmarking
02:15:12 <killy9999> not profiling
02:15:32 <killy9999> it will measure how fats your function runs, but will not tell you anything about memory leaks
02:16:06 <killy9999> arnsholt: your best bet is using profiling tools built into GHC
02:16:13 <arnsholt> Right
02:16:16 <killy9999> they can measure memory allocation and usage
02:47:19 <danielle> ciao
02:47:22 <danielle> !list
02:47:23 <monochrom> danielle: http://okmij.org/ftp
02:48:32 * hackagebot cabal-ghci 0.3 - Set up ghci with options taken from a .cabal file  http://hackage.haskell.org/package/cabal-ghci-0.3 (EtienneLaurin)
03:36:51 <yesthisisuser> i'm trying to run this example: http://src.seereason.com/happstack-authenticate/demo.hs but I get an error ghc: could not execute: trhsx
03:42:21 <yesthisisuser> never mind, I found the solution here http://stackoverflow.com/questions/13540096/cant-install-happstack-hsp
03:45:41 <merijn> Is the prelude sort stable?
03:46:08 <merijn> oh, RTFM, I guess >.>
03:50:17 <mr-> What does stable mean? ;-)
03:50:43 <bscarlet> ties are broken by the input order
03:51:45 <bscarlet> i.e. if the comparator for the sort doesn't require the elements to be shuffled, they won't be
03:52:15 <quchen> mr-: A stable sort doesn't change the order of equivalent elements when sorting. For example, if you sort [('a', 1), ('b', 2), ('c', 1)] by the second tuple element, a stable sort guarantees that the order of the 'a' and 'c' entries is preserved.
03:52:16 <mr-> ah, thanks
03:52:34 <quchen> An unstable sort on the other hand can scramble equivalent elements around at will.
03:53:47 <hpc> you can also turn an unstable sort into a stable sort fairly trivially
03:54:07 <mr-> hpc: by adding a data that distinguishes?
03:54:34 <hpc> yeah
03:54:53 <hpc> zip with [1..] and mappend the comparisons on fst and snd
03:54:57 <mr-> like, zip it with [1..] and have the second component as secondary..
03:55:06 <bscarlet> mr-: for context, one way to sort a multi-column table is to successively stably sort it by columns of increasing significance
03:55:12 <hpc> (Ordering is the coolest monoid)
03:55:37 <merijn> The advantage being that "map last . groupBy f . sortBy f" lets you find the last values for every entry that has a unique entry determined by f
03:55:47 <quchen> hpc: Seconded :-)
03:56:09 <mr-> hpc: what's the monoid structure? :-)
03:56:19 <merijn> If sort isn't stable you can't assume the last item in your input list will be the last item in the grouped list
03:56:37 <quchen> mr-: GT <> _ = GT; LT <> _ = LT; EQ <> x = x
03:57:12 <quchen> mr-: That is how you compare strings lexicographically for example: check the first letter. If it's different, you know the order of the words. If the first letter is equal, you have to go on checking.
03:57:22 <mr-> Ah, the type Ordering :-) I was mishreading the capital...
03:57:46 <quchen> So what `comparing snd <> comparing fst` does is comparing the snd; if it finds it's LT or GT then it's done.
03:57:54 <quchen> If the snd comparison is inconclusive, it goes on checking fst.
03:58:42 <bscarlet> anyone have any recommendations for a combinator library for both parsing & printing?
03:59:01 <hpc> @let isPrefixOf' = (== EQ) . foldr EQ (<>) .: zipWith compare
03:59:01 <lambdabot> Plugin `eval' failed with: Ambiguous infix expression
03:59:04 <hpc> :t (.:)
03:59:05 <lambdabot>     Not in scope: `.:'
03:59:05 <lambdabot>     Perhaps you meant one of these:
03:59:05 <lambdabot>       `.' (imported from Data.Function),
03:59:10 <hpc> pah
03:59:16 <danr> @let (.:) = (.) . (.)
03:59:16 <lambdabot>  Defined.
03:59:21 <danr> :t (.:)
03:59:22 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
03:59:24 <hpc> @let isPrefixOf' = (== EQ) . foldr EQ (<>) .: zipWith compare
03:59:24 <lambdabot> Plugin `eval' failed with: Ambiguous infix expression
03:59:28 <danr> :(
03:59:31 <hpc> oh well
04:00:04 <hpc> > let isPrefixOf' = ((== EQ) . foldr EQ (<>)) .: zipWith compare in isPrefixOf' "yes" "yes it is"
04:00:05 <lambdabot>   Couldn't match expected type `GHC.Types.Ordering
04:00:05 <lambdabot>                           ...
04:00:11 <quchen>  /q lambdabot?
04:00:13 <hpc> yeah
04:00:42 <quchen> It's where I secretly brew my commands so nobody notices I'm just gambling every-single-time ;-)
04:01:17 <Kinnison> :-)
04:01:29 <mr-> :-)
04:02:22 <merijn> It's where I check my witty quotes will work :p
04:02:56 <quchen> That's especially important if there are multiple quotes with a certain keyword
04:03:05 <quchen> Some day something nasty will come up :-)
04:05:17 <merijn> Bah, googlegroups seems to silently drop my mail to the pipes mailing list >.>
04:05:47 <quchen> Heh, Lambdabot forgot my Reader quote! :-C
04:06:00 <quchen> Mauke promised me I would be in HWN.
04:07:55 <quchen> @remember quchen I wonder whether there is any non-id function in the Reader API.
04:07:56 <lambdabot> I will remember.
04:08:39 * hackagebot xsd 0.4.0 - XML Schema data structures  http://hackage.haskell.org/package/xsd-0.4.0 (StefanWehr)
04:09:36 <ocharles> merijn: orly?
04:17:02 <Rarrikins> Are there any array types that use the new type-level naturals for static sizing? I see Foreign.Marshall.StaticArray, but it seems a bit foreign. I want to use Haskell objects within Haskell only.
04:20:53 <zRecursive> Data.Array ?
04:22:12 <zRecursive> > print (sumU (enumFromToU 1 (200000000 :: Int)))
04:22:13 <lambdabot>   Not in scope: `sumU'
04:22:13 <lambdabot>  Perhaps you meant one of these:
04:22:13 <lambdabot>    `sum' (imported fr...
04:23:14 <zRecursive> > print (Data.Array.Vector.sumU (Data.Array.Vector.enumFromToU 1 (200000:: Int)))
04:23:15 <lambdabot>   Not in scope: `Data.Array.Vector.sumU'Not in scope: `Data.Array.Vector.enum...
04:23:59 <Rarrikins> Hmm. That's not a bad idea. I just need to figure out how to get the type-level natural as a value-level Enum a => a or something.
04:28:20 <zRecursive> @hoogle array
04:28:20 <lambdabot> Control.OldException ArrayException :: ArrayException -> Exception
04:28:20 <lambdabot> Control.Exception.Base data ArrayException
04:28:20 <lambdabot> Control.Exception data ArrayException
04:29:34 <zRecursive> today lambdabot always give me Nothing
04:30:16 <jmcarthur> "I see Foreign.Marshall.StaticArray, but it seems a bit foreign."  <- ha
04:38:35 <theredlol> Hello again.
04:38:46 <theredlol> https://pastee.org/54cu8
04:38:50 <theredlol> I was wondering about this.
04:39:26 <theredlol> I can't get it to output Something and then without going to the nextline allowing the user to enter some input
04:39:46 <theredlol> If I run this, the input of getLine is always ran first.
04:40:22 <theredlol> It works perfectly well if I use putStrLn or add a "\n" to the end of the string in putStr
04:43:57 <theredlol> My question is : How would I be able to print out "Name: " and then on the same line have the user input text?
04:45:22 <elliott> do { putStr "Name: "; hFlush stdout; getLine }
04:45:25 <ocharles> theredlol: use 'putStr' not 'putStrLn'
04:45:59 <theredlol> elliott: Thanks.
04:46:23 <theredlol> ocharles: I did that, but it seems that the reason it doesn't work is that haskell flushes std out on newline
04:48:11 <theredlol> elliott: That worked! Thanks a lot!
05:09:43 <mauke> quchen: I *think* the HWN quotes come from logs, not lambdabot
05:10:34 <ocharles> really? that'd take quite a bit of effort
05:10:40 <quchen> mauke: Yes, but IRCBrowse also didn't remember it. I think HWN guy (Cruz?) said he just greps the logs
05:13:40 * hackagebot tasty 0.2 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.2 (RomanCheplyaka)
05:13:42 * hackagebot tasty-smallcheck 0.2 - SmallCheck support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-smallcheck-0.2 (RomanCheplyaka)
05:13:44 * hackagebot tasty-quickcheck 0.2 - QuickCheck support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-quickcheck-0.2 (RomanCheplyaka)
05:13:46 * hackagebot tasty-golden 2.0.1 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.0.1 (RomanCheplyaka)
05:13:48 * hackagebot tasty-hunit 0.2 - HUnit support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hunit-0.2 (RomanCheplyaka)
05:14:00 <mauke> quchen: http://tunes.org/~nef/logs/haskell/13.08.05
05:14:36 <ocharles> i think tasty just got updated
05:15:35 <quchen> mauke: I stand corrected.
05:16:14 <quchen> By the way, remember me joking that somehow local could also be id? Well guess what.
05:16:20 <quchen> :t [id, ask, asks, local]
05:16:21 <lambdabot> MonadReader (m a) m => [(m a -> m a) -> m a -> m a]
05:19:38 <elflord> is there anyway to find out which cabal packages on hackage uses a particular lib such as tagsoup ?
05:21:08 <quchen> elflord: Yes, there's a reverse dependendy search: http://packdeps.haskellers.com/reverse
05:21:19 <elflord> great thanks
05:21:27 <elflord> any cli command for that ?
05:21:28 <quchen> And by search I mean "Ctrl+F in your browser"
05:21:34 <quchen> Not that I know of
05:21:41 <quchen> None*
05:29:30 <JuanDaugherty> anybody know if 7.6.3 will build on debian wheezy 64 if I build current gmp for it and tell it to use it? It's asking for gmp3.
05:30:34 <JuanDaugherty> s/build/install/
05:44:08 <tomejaguar> -fno-code is extremely useful!  (Just thought I'd throw that out there)
05:45:00 <manek> Hi! I'm trying to write my own Setup.hs and .cabal cionfig files. In the Setup.hs I've written a custom "preconf" userhook. When I'm executing "./Setup.hs configure" it works - I can see the printed message, but when executing "cabal configure" i cannot see the message - why "cabal configure" does not uses Setup.hs?
05:45:30 <dcoutts> manek: your .cabal file has to say build-type: Custom  rather than build-type: Simple
05:46:25 <manek> ahhhh! of course!
05:46:28 <manek> thank you!
05:51:10 <exicer> Do the functor laws get automatically checked when you implement fmap, or do you have to do it yourself ?
05:51:39 <k00mi_> the latter
05:51:46 <Kinnison> Laws are more "guidelines" in the sense that it is assumed the implementor will be checking they are met
05:52:08 <exicer> Okay, cheers
05:56:41 <manek> Does anybody know how can I obtain the path of the project (path of the file "Setup.hs") from my custom "userhook" ?
06:00:42 <manek> Hi! I'm writing my custom Setup.hs file (to build with cabal). How can I obtain the full path of current project from the hook?
06:00:58 <dcoutts> manek: it's always the current dir
06:02:03 <quchen> exicer: I think calling the laws "guidelines" is not strong enough. In the best case everyone will be angry at you for violating them, in the worst case your program does rubbish and it's really hard to debug because nobody suspects you violated the laws.
06:02:13 <donri> manek: even with runhaskell path/to/Setup.hs ?
06:02:17 <donri> uh dcoutts *
06:02:41 <dcoutts> donri: that's breaking the contract
06:02:45 <donri> heh ok
06:02:57 <manek> donri: yes
06:02:59 <dcoutts> Cabal spec says: runhaskell Setup.hs
06:03:18 <donri> dcoutts: but cabal install path/to/dir does the right thing?
06:03:26 <manek> ah ok, so its not possible, ok so its seems fine to get current directory
06:03:27 <dcoutts> donri: indeed
06:03:30 <manek> ok thank you very much! :)
06:04:00 <dcoutts> donri: what'd happen with runhaskell path/to/Setup.hs is that it'd build the package in .
06:05:04 <donri> dcoutts: and --enable-tests, do they always run in the dir the tarball was extracted to? ISTR having problems with that and needing to use the data-files api, but maybe you just need extra-src-files or something...
06:06:16 <dcoutts> donri: tarballs isn't relevant really, a package is built, tests run etc etc all with the current dir being at the package root
06:06:34 <quchen> Speaking of Functor laws: is there any requirement to have RULES in the same module as the corresponding functions? For example, could I write a separate module that only contains RULES pragmas that uses the Functor/Applicative/Monad laws for rewrites?
06:06:37 <dcoutts> whether the package was unpacked from a tarball is orthogonal
06:06:48 <manek> I've got one additional question to you :) If I want to concatenate some parts of system path and I want the concatenated path to be working on windows and on linux (something like sys.path.join in Python) - how can I do this in Haskell?
06:07:04 <dcoutts> donri: though obviously it's possible to miss files out of the tarball and so get an incomplete package file set
06:07:07 <donri> dcoutts: yeah well the problem is you usually develop/CI against a repo checkout but then cabal install --enable-tests from hackage doesn't work because you forgot to include test files :)
06:07:39 <dcoutts> donri: yes, so to be clear they're totally orthogonal
06:07:51 <donri> got it, thanks
06:08:45 <donri> manek: use the filepath or system-filepath package
06:09:29 <jtanguy> manek: what are you trying to do in the end? maybe you are going to great lenghts to copy something from another language when there is a tool available in haskell
06:09:57 <donri> going to unnecessary lengths is great for learning ;)
06:20:44 <JoergFritsch> How can I get assemble a string using a list comprehension
06:20:46 <JoergFritsch> eg
06:20:48 <JoergFritsch> [x * 10 + y | x <- [1..3], y <- [4..6]]
06:20:55 <JoergFritsch> I would liek to get something like
06:21:21 <donri> :t concat
06:21:22 <lambdabot> [[a]] -> [a]
06:21:28 <donri> :t intersperse
06:21:29 <lambdabot> a -> [a] -> [a]
06:21:31 <JoergFritsch> [mystring.x.y | x <- [1...300], y <- [5 - 20]]
06:21:37 <donri> :t intercalate
06:21:37 <lambdabot> [a] -> [[a]] -> [a]
06:22:48 <donri> > concat ["hi" ++ show x ++ show y | x <- [1...300], y <- [5 - 20]]
06:22:50 <lambdabot>   Not in scope: `...'
06:22:50 <lambdabot>  Perhaps you meant one of these:
06:22:50 <lambdabot>    `.&.' (imported fro...
06:23:04 <JoergFritsch> donri: good idea
06:23:07 <donri> > concat ["hi" ++ show x ++ show y | x <- [1..300], y <- [5..20]]
06:23:09 <lambdabot>   "hi15hi16hi17hi18hi19hi110hi111hi112hi113hi114hi115hi116hi117hi118hi119hi12...
06:23:47 <JoergFritsch> donri: how would I get the results emitted one by one?
06:23:59 <donri> > ["hi" ++ show x ++ show y | x <- [1..300], y <- [5..20]]
06:24:01 <lambdabot>   ["hi15","hi16","hi17","hi18","hi19","hi110","hi111","hi112","hi113","hi114"...
06:24:16 <ion> > do x <- [1..300]; y <- [5..20]; "hi" ++ show x ++ show y
06:24:17 <lambdabot>   "hi15hi16hi17hi18hi19hi110hi111hi112hi113hi114hi115hi116hi117hi118hi119hi12...
06:24:34 <CaptainHaddock> I assume this is my emacs being weird, but in that list comp' I see "x <- [1i300]"
06:25:04 <int-e> CaptainHaddock: weird
06:25:14 <JoergFritsch> CaptainHaddock: yes, the y was screwed up
06:25:15 <ion> > [ s | x <- [1..300]; y <- [5..20]; foo <- "hi" ++ show x ++ show y; s <- foo ]
06:25:16 <lambdabot>   <hint>:1:20: parse error on input `;'
06:25:25 <ion> > [ s | x <- [1..300], y <- [5..20], foo <- "hi" ++ show x ++ show y, s <- foo ]
06:25:26 <lambdabot>   Couldn't match expected type `[t0]'
06:25:26 <lambdabot>              with actual type `GHC.Type...
06:25:42 <ion> Err. Don’t mind me, i haven’t finished my coffee yet.
06:25:47 <int-e> ion: it stops at foo.
06:26:26 <ion> yeah
06:26:35 <ion> > [ foo | x <- [1..300], y <- [5..20], foo <- "hi" ++ show x ++ show y ]
06:26:36 <lambdabot>   "hi15hi16hi17hi18hi19hi110hi111hi112hi113hi114hi115hi116hi117hi118hi119hi12...
06:26:51 <ion> I got confused when trying to do a “join” at the end.
06:26:55 <JoergFritsch> ion: I still do not understand how I could get them one by one.
06:27:22 <JoergFritsch> In my case the result string wiull be the argument for an other function (it is a database key) and I need these keys further
06:28:02 <JoergFritsch> ion: I need somehow an outer loop that receives the next key and prints it
06:28:22 <ion> joergfritsch: Sorry, i just played with a line donri wrote. I didn’t realize there was a question. So, you have [x * 10 + y | x <- [1..3], y <- [4..6]], please give an example of the actual output you’d like to get.
06:29:31 <bscarlet> > let moreWorkHere x y = "stuff " ++ x ++ y in [ moreWorkHere x y | x <- [1..2], y <- [5,7..11] ]
06:29:32 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
06:29:32 <lambdabot>    arising from the literal ...
06:29:50 <bscarlet> > let moreWorkHere x y = "stuff " ++ show x ++ show y in [ moreWorkHere x y | x <- [1..2], y <- [5,7..11] ]
06:29:51 <lambdabot>   ["stuff 15","stuff 17","stuff 19","stuff 111","stuff 25","stuff 27","stuff ...
06:30:30 <JoergFritsch> Thanks.
06:31:35 <bscarlet> > map (\(x,y) -> "stuff " ++ show x ++ show y) [ (x,y) | x <- [1..100], y <- [2..7] ]
06:31:37 <lambdabot>   ["stuff 12","stuff 13","stuff 14","stuff 15","stuff 16","stuff 17","stuff 2...
06:32:53 <bscarlet> > let pairs = [(x,y) | x <- [1..10], y <- [2..5]]; moreWorkHere x y = "stuff " ++ show x ++ show y in map (uncurry moreWorkHere) pairs
06:32:54 <lambdabot>   ["stuff 12","stuff 13","stuff 14","stuff 15","stuff 22","stuff 23","stuff 2...
06:33:58 <bscarlet> JoergFritsch: of course giving a name to "moreWorkHere" is just style. There's no reason you can't just do more work inside the list comprehension.
06:40:54 <Yip> Good afternoon
06:41:23 <Yip> How can I make tha a GADT deriving show?
06:42:52 <chturne> Please may someone help to translate the following gibberish to an English description of what went wrong: http://codepad.org/xhfbMr9J  -- many thanks in advance, this is a cabal problem BTW.
06:43:12 <Work_jack> Yip: Have you tried (instance Show ... where ...) ?
06:43:53 <dcoutts> chturne: scion needs base>=4.2 && <4.6, but you have base-4.6.0.1
06:44:00 <Work_jack> You can derive it for GADTs that are also normal Haskel98 ADT, but you need to define it yourself otherwise
06:44:28 <Yip> Work_jack: of course, that works
06:44:35 <dcoutts> chturne: cabal cannot install a different base lib for you (that's what the "global constraint requires installed instance" is about)
06:45:03 <Yip> Isn't possible to use *deriving* ?
06:45:06 <chturne> dcoutts: thanks.
06:45:21 <Work_jack> Yip: Not for GADTs in general
06:45:28 <supki> Yip: you can derive Show for some non-Haskell98 GADTs with -XStandaloneDeriving
06:47:17 <quchen> chturne: You could try editing the .cabal file to allow your Base version to be used. There is no guarantee this works though. Scion puts upper boundaries on module versions, which is sometimes (!) somewhat arbitrary.
06:48:01 <CaptainHaddock> is there any easy way to diff different versions of base?
06:48:35 <quchen> CaptainHaddock: Base is its own submodule in GHC, so you can just do a git diff
06:49:15 <quchen> CaptainHaddock: It has tags for different GHC releases
06:50:21 <quchen>  >  git diff ghc-7.6.3-release ghc-7.6.1-release
06:50:34 <quchen> (in libraries/base)
06:50:51 <CaptainHaddock> cheers
06:53:58 <Yip> supki: thanks, I will try it
06:58:42 * hackagebot postgresql-simple 0.3.5.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.5.0 (LeonSmith)
06:59:30 <danharaj> lpsmith: this is relevant to my interests :P
07:01:43 <prophile> @hoogle (ArrowZero a) => (b -> Bool) -> a b b
07:01:43 <lambdabot> Data.Graph.Inductive.Basic elfilter :: DynGraph gr => (b -> Bool) -> gr a b -> gr a b
07:01:43 <lambdabot> Control.Arrow arr :: Arrow a => (b -> c) -> a b c
07:01:43 <lambdabot> Data.Map.Lazy filter :: (a -> Bool) -> Map k a -> Map k a
07:03:20 <merijn> Is anyone subscribed to the pipes mailing list? I've tried sending a message yesterday and it appears to be blocked? I wonder if anyone saw it or not
07:09:00 <ocharles> merijn: I am
07:09:12 <ocharles> merijn: i've seen posts from you, what was the body I should be looking for?
07:09:13 <t7> is there an infix op for map?
07:09:20 <ocharles> t7: <$>
07:09:22 <mauke> `map`
07:09:25 <Work_jack> lol
07:09:35 <t7> > (+ 1) <$> [1..10]
07:09:37 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
07:09:58 <t7> why is fmap not called map?
07:10:02 <ocharles> yay Functor [a], etc
07:10:09 <ocharles> t7: mostly historical reasons
07:10:09 <Work_jack> t7: good question
07:10:13 <t7> map is redundant
07:10:21 <mauke> t7: better error messages
07:10:37 <ocharles> there is another school of thought that teaching functor's is too hard, and we should start with monomorphic functions first
07:11:03 <tac> Well, you don't start off learning math by talking about categories, topoi, and sheaves
07:11:11 <chturne> quchen: thanks for the tip, turns out loads more stuff is "too new" on my system for this package, including GHC itself, which sounds bad given the nature of scion :) -- thanks.
07:11:12 <tac> You start with integers and addition :)
07:11:30 <ocharles> tac: maybe we should!
07:11:32 <ocharles> ;)
07:12:13 <hvr> quchen: alas, base is not a proper git submodule
07:12:20 <quchen> Functors are chapter 7 (+-2) in LYAH, and that's precisely the point where I was wondering why there's a "map" function.
07:12:28 <quchen> hvr: It's not? What else is it then?
07:12:48 <hvr> quchen: just a repository checked out manually into the ghc source-tree by sync-all
07:13:07 <hvr> quchen: the git-submodules are listed in the .gitmodules file
07:13:08 <quchen> hvr: Ah, and a submodule is such a thing that the GHC git repo knows of?
07:13:12 <tac> ocharles: maaaaybe :)
07:13:23 <quchen> hvr: So Base is a stapled-on submodule so to speak
07:14:00 <hvr> quchen: yeah, but it's a unsatisfying solution right now; half of the sub-repos are git submodules, and the other half are script-based submodules
07:14:22 <hvr> quchen: and you can find recent discussions on ghc-devs@ about that
07:14:39 <quchen> hvr: Yeah I've seen those, and I was constantly wondering what the fuzz was about
07:15:00 <CaptainHaddock> how hard would it be to modify GHCi so that the tab-completions for ":k" are only type variables ?
07:15:19 <hvr> CaptainHaddock: *variables*?
07:15:22 <quchen> hvr: So basically you can do proper checkouts using git/submodules, but the "improper submodules" are troublesome, so there's an effort being made to migrate everything to GHC+proper submodules?
07:15:52 <CaptainHaddock> /s/variables//
07:16:07 <CaptainHaddock> in fact
07:16:18 <hvr> quchen: there's a consensus that something has to be done; but it's not fully been agreed on what to do exactly
07:16:49 <CaptainHaddock> things that it would be sensible to auto-complete in the context of :k
07:17:01 <CaptainHaddock> but not the extra stuff that pops up now (like functions)
07:17:55 <hvr> CaptainHaddock: I'm just trying to remember, the GHCi code differentiated between the class of symbols (currently it separates module names from types & values)
07:18:15 <hvr> CaptainHaddock: other than that, it'd be quite easy to implement
07:18:35 <hvr> CaptainHaddock: if you do that, I'd backport it to ghci-ng :)
07:19:30 <CaptainHaddock> I shall look in to it xD
07:19:49 <CaptainHaddock> what does '-ng' signify?
07:19:54 <hvr> next-gen
07:20:09 <mauke> nanogram
07:20:30 <CaptainHaddock> cheers
07:20:40 <hvr> (I was watching the blueray releases of TNG when I was searching for a name...)
07:20:50 <quchen> mauke: I don't think anyone ever used that unit. You discovered something new!
07:21:19 <merijn> ocharles: Question about turning an Effect into a Producer
07:21:31 <merijn> ocharles: There were a couple about MTL and masking that did go through
07:22:02 <yesthisisuser> I am trying to install  data-lens-template bug get an error Data/Functor/Contravariant.hs:53:1: tagged-0.6:Data.Proxy can't be safely imported! The module itself isn't safe.
07:23:06 <yesthisisuser> (but get an error)
07:24:32 <ocharles> merijn: let me see which is the last email I have from you
07:25:01 <ocharles> merijn: I got one at 2pm today (an hour ago)
07:25:15 <ocharles> '[haskell-pipes] Turning Effect into a Producer' is the subject
07:28:23 <merijn> ocharles: ok, I just recently resent it, so apparently that attempt worked
07:28:43 * hackagebot hi 0.0.2 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-0.0.2 (DaisukeFujimura)
07:29:46 <merijn> ocharles: wrt the actual question, I meant "efficient" in terms of code, not performance
07:30:24 <merijn> ocharles: of course it needs to rerun the effect, but I figured that should already exist. The docs seem to imply that "foo >~ cat" should work, but it doesn't >.>
07:31:08 <merijn> According to the haddocks >~ is (among other things) "(>~) :: Monad m => Effect       m b -> Pipe     b y m c -> Producer   y m c"
07:31:17 <merijn> Except, it turns out that that is a type error
07:33:20 <isomorphismes> Can infix operators only be used with exactly two arguments? eg a `add` (b c) fails
07:34:17 <bscarlet> isomorphic: (b c) is a single value, the result of applying the function b to the value c.
07:34:21 <merijn> > let infixFoo a b c = a + b + c in 1 `infixFoo` 3 $ 4
07:34:22 <lambdabot>   8
07:34:28 <merijn> > let infixFoo a b c = a + b + c in (`infixFoo` 3) 4
07:34:29 <lambdabot>   <Integer -> Integer>
07:34:30 <merijn> eh
07:34:35 <merijn> > let infixFoo a b c = a + b + c in (1 `infixFoo` 3) 4
07:34:36 <lambdabot>   8
07:35:27 <ocharles> merijn: ohh...
07:35:35 <ocharles> merijn: best to let Tekmo step in :)
07:35:54 <ocharles> merijn: oh wait, I wonder if you can use request composition
07:36:11 <ocharles> you want to fill in "await" holes with a "run myEffect"
07:36:28 * ocharles has a play
07:39:17 <isomorphismes> merijn: bscarlet Thank you!
07:41:13 <ocharles> merijn: you can: lift (return True) >~ cat
07:41:25 <ocharles> but change lift (return True) to be lift (run myEffect)
07:41:48 <ocharles> and that will give you a producer (in my case of Bools)
07:42:24 <isomorphismes> > let add a b c = a + b + c; 1 `add` 3 $ 4
07:42:25 <lambdabot>   <hint>:1:41:
07:42:25 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
07:44:23 <haasn> isomorphismes: s/;/ i n/
07:45:54 <JoergFritsch> how would I best ranslate such a nested structure into Haskell:
07:45:56 <JoergFritsch> for 0 <= i < row dimension of A
07:45:57 <JoergFritsch>          for 0 <= j < column dimension of B
07:45:57 <JoergFritsch>             sum = 0
07:45:57 <JoergFritsch>             for 0 <= k < column dimension of A = row dimension of B
07:45:57 <JoergFritsch>                sum += A(i,k)*B(k,j)
07:45:57 <JoergFritsch>             if sum != 0 emit (ibase+i, jbase+j), sum
07:46:03 <haasn> @hpaste
07:46:03 <lambdabot> Haskell pastebin: http://hpaste.org/
07:46:08 <haasn> oh no
07:46:10 <haasn> @lpaste
07:46:11 <lambdabot> Haskell pastebin: http://hpaste.org/
07:46:13 <haasn> :(
07:46:18 <quchen> @where paste
07:46:19 <lambdabot> http://lpaste.net/new/haskell
07:46:19 <quchen> :-)
07:46:48 <WraithM> What happened to hpaste anyway?
07:47:15 <JoergFritsch> I heard hpaste was on holiday.
07:47:24 <quchen> WraithM: The domain owner didn't respond and there were some issues, so a new domain was chosen to get control over the paste site back.
07:47:40 <WraithM> Fair enough
07:48:48 <isomorphismes> haasn: thanks. I'm trying to look up documentation about "in", but :i in :t in :k in :bro in :h in don't show anything. Not sure I will find anything googling "in" either
07:49:15 <merijn> isomorphismes: in is just a keyword
07:49:17 <haasn> isomorphismes: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-440003.12
07:49:26 <merijn> isomorphismes: The proper syntax is "let <declaration> in <expression"
07:49:40 <merijn> isomorphismes: let without in is the special case that only works in do blocks
07:49:50 <isomorphismes> merijn: Is it like ∈? Seems like no.
07:50:11 <merijn> isomorphismes: It's literally read like the english meaning
07:50:14 <lpsmith> danharaj, =)
07:50:26 <merijn> isomorphismes: "let x = 1 in x" says "let x have the value 1 in x"
07:50:27 <lpsmith> Though I doubt there is too much that you'll find directly interesting in the latest release.
07:50:35 <isomorphismes> haasn: thank you
07:50:41 <danharaj> lpsmith: Well I am just glad an important library is being actively maintained :P
07:50:52 <quchen> isomorphismes: There's a section on let...in in LYAH: http://learnyouahaskell.com/syntax-in-functions#let-it-be
07:51:01 <isomorphismes> merijn: that explanation doesn't make sense to me. thanks though
07:51:13 <isomorphismes> quchen: oh great, thanks. not there yet in LYAH =)
07:52:11 <merijn> I don't know how I could possibly simplify that explanation :\
07:54:40 <isomorphismes> merijn: e.g. "He's in his underwear", "Get in my belly", "Our team is in first place", "What's in store for next time?", "Come in, come in"
07:55:12 <chrisdone> and i would've gotten away with it too if it wasn't for those rotten static types
07:55:50 <isomorphismes> merijn: it sounds like 1 is "inside" x somehow which doesn't make sense to me. Is x a list and 1 becomes an element of the list?
07:55:58 <isomorphismes> Anyway thanks all I will go read those docs. =)
07:57:17 <merijn> isomorphismes: It is not in x, it's in the expression (consisting of only x)
07:57:23 <benzrf> hey
07:57:29 <byorgey> isomorphismes: it is the sense of "in"  you find in "he plays Horatio in the play"
07:57:31 <merijn> > let x = 1 in x + x
07:57:33 <lambdabot>   2
07:57:39 <benzrf> is there a pragma or something that I can use to indicate that a function should be memoized?
07:57:56 <quchen> @hackage data-memocombinators -- benzrf
07:57:56 <byorgey> "let x = 1 in y"  means  "x has the value (plays the role) 1 in the expression y"
07:57:56 <lambdabot> http://hackage.haskell.org/package/data-memocombinators -- benzrf
07:58:04 <benzrf> don't think I can do that
07:58:16 <benzrf> it's for an online challenge thing
07:58:23 <benzrf> let me show you what I have and what it wants, hold on
07:58:32 <haasn> then you might have to hand-implement it
07:58:35 <haasn> there's no pragma
07:58:42 <benzrf> :|
07:58:50 <haasn> online challenges are weird :)
07:59:12 <byorgey> hand-implementing simple memoization is not that hard.
07:59:14 <benzrf> this is the problem: http://www.spoj.com/problems/PRIME1/
08:00:05 <benzrf> my current attempt at a solution: http://bpaste.net/show/121406
08:00:52 <benzrf> it times out
08:01:05 <benzrf> it's correct but not very performant, and so it isn't accepted
08:03:01 <quchen> benzrf: Well, you can do some pretty small optimizations that should help a bit there. For example, line 9 checks divisibility by all even numbers.
08:03:11 <benzrf> -.-
08:03:12 <benzrf> of course
08:03:15 <quchen> Make the [2..top] a 2:[3,5..top]
08:03:32 <benzrf> done
08:03:51 <quchen> You could also generate the list of primes to memoize them, and then use that list instead of the [x..y] version
08:04:00 <benzrf> hmm
08:04:04 <benzrf> oh right, I forgot!
08:04:06 <benzrf> it's bounded
08:04:10 <benzrf> ok hold on
08:04:29 <quchen> You could try to implement your own "nubBy" function that uses Data.Set (not sure how that compares performance-wise though)
08:04:32 <manek> Hi! Is it possible to write a Setup.hs file, which will modify the .cabal config file? for example it will add some   Exposed-modules etc?
08:04:40 <benzrf> oh wow I just realized that I have waaaaaay too many tabs open
08:04:41 <benzrf> o_o
08:05:59 <bergmark> manek: i would do that externally from cabal
08:06:17 <bergmark> but it should be possible either way
08:09:20 <dcoutts> manek: you can write hooks that modify the PackageDescription before calling the normal hook
08:09:32 <dcoutts> so never having to actually modify the .cabal file
08:11:51 <manek> ok thank you :)
08:12:21 <Clint> oh look, it was bos
08:12:54 <quchen> benzrf: So I just hacked together a small sieve algorithm, let me see whether that one's faster.
08:14:15 <dmp1ce> If I'm using cabal-dev, how can I know what versions of packages I'm using?
08:15:09 <tikhon> cabal-dev info, I think
08:15:29 <benzrf> quchen: nooooooooo
08:15:51 <quchen> benzrf: ?
08:16:09 <benzrf> nothing
08:16:23 <exicer> What are <*> and <$> called ?
08:16:38 <benzrf> <*> and <$>
08:16:39 <benzrf> :D
08:16:42 <Work_jack> confused meatball and fmap
08:16:50 <dmp1ce> tikhon: Yep, that is it.  Thanks.
08:17:07 <ocharles> exicer: <*> is often called 'ap'
08:17:12 <exicer> Pff :p
08:17:23 <ocharles> <$> is infix map
08:17:28 <exicer> Okay, cheers
08:17:44 <Work_jack> exicer: http://stackoverflow.com/questions/7746894/are-there-pronounceable-names-for-common-haskell-operators might be interested in this
08:18:04 <Work_jack> <$>: map, fmap
08:18:04 <Work_jack> <*>: ap, apply
08:18:56 <lpsmith> bah,  map should be fmap,  like it was pre-H98
08:19:05 <lpsmith> mappend should be ++
08:19:21 <Work_jack> and [a] should be an instance of Num!
08:19:30 <lpsmith> I dunno about that one =)
08:19:55 <supki> you mean [()]
08:20:44 <lpsmith> Honestly if you want something more matlab/octave like,  you probably don't want to be using lists
08:21:23 <quchen> benzrf: isPrime' 9 == True  <-- I think I made a mistake somewhere
08:21:51 <levi> Heh.
08:23:37 <benzrf> Fuuzetsu: hey, are you that guy on /g/
08:23:56 <Fuuzetsu> yes
08:24:17 <benzrf> I just want to congratulate you on being the prototypical Smug Haskell Weenie
08:24:28 <chrisdone> Erik Meijernads
08:25:13 <chrisdone> Peyton `Simon` Jones
08:25:23 <Fuuzetsu> benzrf: thanks?
08:25:27 <chrisdone> SimonT m a r Loeb
08:25:29 <benzrf> no prob
08:25:43 <quchen> Keep your 4chan flaming to 4chan please
08:26:03 <danharaj> ^
08:26:13 <chrisdone> Lens Arrow Augu (forall s. ST s on)
08:26:21 * chrisdone giggles to himself
08:26:31 <quchen> chrisdone: Not just you :-)
08:28:44 * hackagebot diagrams-core 0.7 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-0.7 (BrentYorgey)
08:28:46 * hackagebot diagrams-lib 0.7 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-0.7 (BrentYorgey)
08:28:48 * hackagebot diagrams-contrib 0.7 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-0.7 (BrentYorgey)
08:28:50 * hackagebot diagrams-svg 0.7 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-0.7 (BrentYorgey)
08:28:52 * hackagebot diagrams-cairo 0.7 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-0.7 (BrentYorgey)
08:29:29 <danharaj> byorgey: is this an exciting update?
08:30:02 <byorgey> danharaj: yes!  though I am not putting out an official announcement quite yet since there's still documentation that needs to be cleaned up etc.
08:30:08 <benzrf> still too slow :\
08:30:10 <danharaj> cool cool
08:30:16 <benzrf> here is the new version: http://bpaste.net/show/121412
08:30:31 <chrisdone> bergmark: Adam Byorgeymark
08:33:54 * hackagebot diagrams-postscript 0.7 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-0.7 (BrentYorgey)
08:33:56 * hackagebot diagrams 0.7 - Embedded domain-specific language for declarative vector graphics  http://hackage.haskell.org/package/diagrams-0.7 (BrentYorgey)
08:33:58 * hackagebot diagrams-builder 0.4 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.4 (BrentYorgey)
08:34:00 * hackagebot SVGFonts 1.3 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-1.3 (BrentYorgey)
08:40:00 <benzrf> help?
08:40:19 <benzrf> quchen: still there?
08:40:41 <quchen> benzrf: Yeah, half time at leaset
08:41:10 <benzrf> here is the new version: http://bpaste.net/show/121412
08:41:17 <benzrf> still too slow :\
08:41:44 <quchen> primesBetween should use a tuple instead of a 2-element list
08:41:56 <quchen> Otherwise it's a very non-total function. It always expects 2 parameters.
08:42:01 <quchen> In fact, make it a 2-parameter function :-)
08:42:14 <quchen> primesBetween s e = …
08:42:14 <benzrf> ah, right
08:42:17 <benzrf> I know
08:42:21 <benzrf> I just don't want to unpack it
08:42:21 <benzrf> :P
08:42:24 <benzrf> one sec
08:42:48 <exicer> Which functors don't have applicative implementations  ?
08:42:57 <exicer> Are there any?
08:43:07 <benzrf> ok, fixerd
08:43:09 <benzrf> *fixe
08:43:10 <benzrf> d
08:44:00 <supki> exicer: Const m (without additional constraints on m)
08:44:14 <quchen> benzrf: Your algorithm still computes every prime by testing divisibility by all odd numbers smaller than it
08:44:26 <quchen> Maybe you can rewrite it so that it uses the previously generated primes?
08:44:55 <benzrf> mm
08:44:55 <benzrf> let
08:44:58 <benzrf> 's see
08:45:13 <quchen> benzrf: That would cut the candidates from 500 to 150 when searching all primes below 1000 :-)
08:45:17 <benzrf> mm!
08:45:17 <haasn> exicer: Const Void -- for a particular example
08:46:50 <exicer> I don't know what Const Void is - but is there a reason it can't have an applicative implementation ?
08:47:05 <int-e> benzrf: even worse, you calculate all primes up to the upper bound; if you want primes between n and m, you should sieve the range [n..m] using primes up to sqrt(m).
08:47:21 <haasn> exicer: newtype Const a b = Const { runConst :: a }
08:47:27 <benzrf> :|
08:47:37 <benzrf> I'm sorry, I suck at algorithms ok]
08:47:44 <haasn> exicer: pure :: a -> Const Void a; so runConst . pure :: a -> Void
08:47:49 <benzrf> awesome
08:47:50 <benzrf> ok
08:48:27 <benzrf> is there some tool I can run on a file to infer the types of the things in it and add them to the file?
08:48:34 <exicer> Ahh ok
08:48:45 <benzrf> nvm
08:48:58 <benzrf> ok
08:49:05 <benzrf> quchen: new version http://bpaste.net/show/121423
08:49:10 <benzrf> int-e: wait, let me fix that
08:49:16 <benzrf> hmm
08:49:24 <benzrf> no nvm
08:50:00 <bergmark> chrisdone: it's me! ?
08:50:20 <benzrf> aaand it's still exceeding the time limit
08:50:22 <bergmark> i'm easily confused with all the good haskell prorgrammers
08:50:22 <benzrf> fD:<
08:50:22 <quchen> benzrf: The problem here is that every invocation of `smallerPrimes` executes the whole `takeWhile` business. You can do it with a single list of primes. Hint:  primes = 2 : filter isPrime [...]
08:50:28 <benzrf> ohhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
08:50:29 <benzrf> :\
08:50:52 <benzrf> quchen: well, when I just use 'primes'
08:50:57 <benzrf> it tries to calculate the whole list
08:50:58 <int-e> benzrf: I'm sure you'll find  filter isPrime [s..e]  is faster than your current primesBetween (but probably still too slow.)
08:50:58 <benzrf> I think?
08:51:01 <benzrf> the point is that it hung
08:51:06 <benzrf> ko
08:51:07 <benzrf> *ok
08:51:15 <benzrf> int-e: that's what I initially did...
08:51:24 <quchen> You also use `smallerPrimes = takeWhile (<top) primes`. This traverses the `primes` list every time you call `isPrime`.
08:51:32 <benzrf> :|
08:51:37 <benzrf> I don't know how else to retrieve them
08:51:40 <benzrf> help
08:51:53 <int-e> quchen: that's okay-ish.
08:52:04 <quchen> Is it? Oh.
08:52:17 <int-e> quchen: since we want to test divisibility by each of them anyway
08:52:47 <quchen> Hm right, may be negligible
08:52:54 <benzrf> hmmm...
08:53:06 <benzrf> how do I retrieve the segment of primes between the limits, then?
08:53:12 <benzrf> SHOULD I just filter?
08:53:20 <haasn> takeWhile / dropWhile
08:53:25 <benzrf> huh
08:53:40 <benzrf> well, this is still too slow
08:53:42 <benzrf> q.q
08:54:08 <Fuuzetsu> Why not look at the primes wiki page to get some ideas?
08:54:10 <haasn> > let evens = [0,2..] in takeWhile (<15) . dropWhile (<3) $ evens
08:54:11 <lambdabot>   [4,6,8,10,12,14]
08:54:21 <Fuuzetsu> (Haskell wiki that is)
08:54:28 <benzrf> :\
08:54:29 <haasn> > filter even [3..15]
08:54:30 <lambdabot>   [4,6,8,10,12,14]
08:54:41 <int-e> (but the algorithm sucks in comparison to the sieve of Erathostenes; but you really need to use arrays for that. I'm not sure how good the wheel sieves are, e.g.  http://hackage.haskell.org/packages/archive/Numbers/0.2.1/doc/html/Data-Numbers-Primes.html )
08:54:44 <benzrf> oh wow it's slow
08:55:12 <benzrf> :|
08:55:25 <benzrf> screw it I'm skipping this problem
08:55:25 <benzrf> q.q
08:55:55 <haasn> algorithms are boring anyway :)
08:55:58 <quchen> int-e: Primes is pretty fast I think.
08:56:04 <int-e> (There's array based code on hackage, too, but it kind of defeats the exercise :-) )
08:56:07 <quchen> Pretty = "comparatively"
08:56:21 <monochrom> > sqrt 3
08:56:22 <lambdabot>   1.7320508075688772
08:56:44 <monochrom> > takeWhile (< 2) (1 : 2 : undefined)
08:56:45 <lambdabot>   [1]
08:57:39 <monochrom> err, heh
08:57:43 <monochrom> > takeWhile (< 2) (2 : undefined)
08:57:44 <lambdabot>   []
08:59:28 <quchen> int-e: Got an idea how to skip every 3rd element in a list? Only 6*n +- 1 are primes after all, so a third of the checks can be omitted - assuming that 6*n+1 is faster than doing the check of course
08:59:52 <quchen> (Why am I doing this again? haha)
09:00:46 <dmwit> quchen: chunk 3 >=> tail
09:01:04 <maxiepoo> :t chunk
09:01:05 <lambdabot> Int -> [e] -> [[e]]
09:01:09 <dmwit> chunk 3 >=> drop 1 is probably better.
09:02:17 <dmwit> > (chunk 3 >=> drop 1) [1..10]
09:02:19 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
09:02:28 <dmwit> ...
09:02:54 <dmwit> Of, FFS, you get a deprecation warning.
09:03:00 <ReinH> lmao
09:03:02 <edwardk> > "hello world"^..elements (\i -> mod i 3 /= 0)
09:03:03 <lambdabot>   Ambiguous occurrence `elements'
09:03:03 <lambdabot>  It could refer to either `Control.Lens.Tra...
09:03:07 <edwardk> > "hello world"^..Lens.elements (\i -> mod i 3 /= 0)
09:03:08 <quchen> dmwit: chunksOf
09:03:08 <dmwit> elliott: Can lambdabot please give answers instead of warnings?
09:03:08 <lambdabot>   "elo ord"
09:03:18 <edwardk> > "hello world"^..Lens.elements (\i -> mod i 3 /= 0)
09:03:19 <lambdabot>   "elo ord"
09:03:34 <dmwit> quchen: No. I like chunks better.
09:04:14 * byorgey liked chunks better too.
09:04:30 <elliott> dmwit: ideally. I think it'll require ugly mueval patches or the half-written less-hacky faster @run I have to be finished. (maybe I should put the latter up somewhere public in case anyone wants to help hack on it...)
09:05:29 <int-e> quchen: Data.Numbers.Primes ran out of memory for the 10^6th prime; Math.NumberTheory.Primes.Sieve used properly didn't break a sweat finding the 10^7th prime (2.15 seconds)
09:05:36 <haasn> :t Lens.elements
09:05:37 <lambdabot> (Applicative f, Traversable t, Indexable Int p) => (Int -> Bool) -> p a (f a) -> t a -> f (t a)
09:05:59 <edwardk> takes a function on the position in the traversable container
09:06:03 <maxiepoo> map snd . filter ((/= 3) . fst) . zip (cycle [1,2,3])
09:06:04 <haasn> Lens.elements f = traverse.indices f -- ?
09:06:06 <haasn> traversed*
09:06:14 <edwardk> elements = traverse.indices
09:06:28 <dmwit> elliott: http://www.youtube.com/watch?v=_hHDxlm66dE
09:06:37 <edwardk> er elements p = traverse . indices p
09:06:54 <edwardk> and yeah i mean traversed
09:07:21 <haasn> I used that when going through H99, lens style :P good to know it has an even shorter form
09:08:07 <elliott> dmwit: I'm, uh, currently on... *wince* Windows.
09:08:21 <elliott> I doubt lambdabot compiles on Windows. (but I'm sure I don't want to find out.)
09:08:42 <dmwit> ouch
09:09:01 <ReinH> elliott: quick, get a VM running!
09:09:06 <quchen> int-e: In GHCi I get either the wrong answer or 27512614111 is really the 10^7-th prime (0-indexed) in 0.01 seconds.
09:09:17 <quchen> Mathematicaaaa help me
09:09:48 <quchen>  PrimeQ@27512614111  ==> False       :-(     It's time to stop.
09:09:55 <tertl3> http://www.infoq.com/interviews/meijer-monads
09:10:29 <test123>  @pl \xs n -> take n xs
09:10:35 <int-e> quchen: 31^7, nice :)
09:10:44 <quchen> test123: flip take
09:10:58 <test123> How do I ask lambdabot?
09:11:12 <dmwit> test123: Use one less space at the beginning.
09:11:13 <int-e> quchen: (I did the same thing, then realized that the operator precedence is not what I expected)
09:11:32 <test123> dmwit: Now, I feel like a dmwit
09:11:36 <dmwit> =)
09:11:48 <hiptobecubic> For some sequence A, I can think of a linear time algorithm to find the maximum subsequence sum, but only an quadratic one to find a subsequence with sum closest to some other number 't'. Any thoughts
09:11:49 <dmwit> I feel honored!
09:11:59 <hiptobecubic> a quadratic*
09:12:01 <dmwit> Apparently feeling like me means being enlightened. =D
09:12:31 <quchen> int-e: What was it, specifically? The only place I've got something like that is x `rem` n /= 0, which parses as (x `rem` n) /= 0
09:12:32 <geekosaur> impostor syndrome? :)
09:12:39 <int-e> quchen: oh, and regarding your earlier question, I have some only slightly crazy C code that works on bytes representing the 8 coprime residue classes modulo 30.
09:13:08 <int-e> > [1..10] !! 2^8 -- quchen
09:13:09 <lambdabot>   6561
09:13:22 <Fuuzetsu> :t \xs n -> take n xs
09:13:22 <lambdabot> [a] -> Int -> [a]
09:13:23 <Fuuzetsu> @type \xs n -> take n xs
09:13:23 <Fuuzetsu> oh
09:13:23 <Fuuzetsu> :t let foo = \xs n -> take n xs in foo
09:13:24 <lambdabot> [a] -> Int -> [a]
09:13:24 <lambdabot> [a] -> Int -> [a]
09:13:26 <quchen> int-e: AAAA devious :-D
09:14:06 <quchen> Although you just made my program's performance much worse. Not sure whether correctness was worth it.
09:14:29 <int-e> hah
09:14:37 <dmwit> main = putStrLn "42" -- faster is better than correct
09:14:53 <quchen> putStrLn has bad performance
09:14:54 <quchen> main = main
09:15:10 <hiptobecubic> quchen, nontermination is pretty bad performance i'd say
09:15:11 <Fuuzetsu> :t ((.) . (.)) (flip take)
09:15:12 <lambdabot> (a -> a1 -> [a2]) -> a -> a1 -> Int -> [a2]
09:15:21 <dmwit> hiptobecubic: Surprise! That program terminates.
09:15:24 <quchen> hiptobecubic: main=return()
09:15:26 <dmwit> hiptobecubic: (try it!)
09:15:36 <quchen> <<loop>>?
09:15:38 <Fuuzetsu> :t flip take
09:15:38 <lambdabot> [a] -> Int -> [a]
09:15:44 <quchen> Breaking news: GHC SOLVES HALTING PROBLEM
09:15:46 <dmwit> quchen: As we all know, fewer spaces is compiler speak for GO FASTER
09:16:10 <hiptobecubic> doesn't terminate here?
09:16:11 <quchen> dmwit: main=pure()  --  if Applicative goes into the Prelude :-)
09:16:16 <dmwit> hiptobecubic: compile it
09:16:36 <quchen> hiptobecubic: It will terminate in GHCi too if it loops, it just takes some time.
09:16:44 <hiptobecubic> oh. I suppose. Isn't that cheating? I thought we were talking about Haskell.
09:16:45 <dmwit> quchen: what?
09:16:49 <quchen> My prime algo is still searching for 10^7 by the way. Damn you int-e.
09:17:23 <quchen> dmwit: GHCi also complains about <<loop>>, but not immediately. Run "let x = x in x".
09:17:36 <arnsholt> Too much laziness can result in larger memory use than expected, right?
09:17:40 <dmwit> quchen: huh
09:17:48 <dmwit> TIL
09:17:58 <Philippa> arnsholt: yeah, you gotta remember what to think about later
09:18:05 <hiptobecubic> I've never had the patience to test this before
09:18:14 <Philippa> if that's bigger than the result, it'll take up more memory
09:18:20 <quchen> ~ 5 seconds here
09:18:23 <hiptobecubic> .... granted it's still going. Not convinced yet :)
09:18:33 <dmwit> quchen: putting main = main in a file doesn't seem to get the same treatment
09:18:50 <Swamy> Hello
09:18:56 * dmwit runs off
09:18:59 <arnsholt> Philippa: Table-driven algorithm to compute an int, so quite a bit bigger =)
09:19:09 <hiptobecubic> been running for a minute now. what version of ghc is supposed to determine it's  looping?
09:19:30 <quchen> 7.6.3 here
09:19:32 <Philippa> arnsholt: that's pretty much the classic kind of example, yeah :-)
09:20:30 <arnsholt> In fact, it's even more memory hungry than Levenstein distance (being a generalisation to trees rather than strings)
09:21:16 <quchen> hiptobecubic: Loop yet?
09:21:40 <hiptobecubic> no
09:21:54 <hiptobecubic> still on 7.4.2 though :)
09:22:11 <haasn> maybe if you will let it run for a few more minutes it will upgrade the compiler to 7.6.3
09:24:53 * geekosaur wonders if -feager-blackholing is relevant here
09:26:45 <test123> @pl \x -> sqrt $ x + x
09:26:45 <lambdabot> sqrt . join (+)
09:27:04 <quchen> sqrt . (*2)   :-)
09:27:47 <monochrom> laziness uses much memory: foldl (+) 0 [1..1000000000] in haskell. eagerness uses much memory: takeWhile (< 0) [1..1000000000] in SML.
09:28:23 <quchen> (How serious was Dan Doel's message on libraries about using Lens and Bifunctors? I can't tell.)
09:28:50 <stevejb> hello, question on developing haskell stuff in Emacs. I am working on two projects simultaneously. Is it possible to have two different inferior-haskell ghci buffers open at once, one for each project
09:28:50 <n-dolio> Very serious.
09:29:05 <edwardk> quchen: it was mostly showcasing how silly it is to write all of these one-off combinators that are instances of more general patterns we already know
09:29:21 <FreeFull> > round (1/0)
09:29:22 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
09:29:23 <haasn> yeah, shame on Data.Map
09:29:28 <tikhon> stevejb: it's possible, but I don't know of an easy way to do it—I wrote some custom elisp to get it working
09:29:28 <edwardk> :t preview _Left
09:29:28 <lambdabot> MonadReader (Either b c) m => m (Maybe b)
09:29:36 <edwardk> preview _Left (Left 12)
09:29:37 <edwardk> > preview _Left (Left 12)
09:29:37 <shachaf> I think the complaints about Arrow are legitimate. But it's not that abstraction is bad, just that Arrow is a bad abstraction.
09:29:38 <lambdabot>   Just 12
09:29:40 <edwardk> > preview _Left (Right 12)
09:29:41 <lambdabot>   Nothing
09:29:48 <stevejb> tikhon: do you mind sharing?
09:29:51 <edwardk> :t isn't _Left
09:29:51 <lambdabot> Either a c -> Bool
09:29:58 <quchen> edwardk: Well, Lens isn't part of Base. But yeah.
09:29:59 * monochrom ♥ Arrow
09:30:02 <tikhon> stevejb: sure, although you'll probably have to adapt it a bit
09:30:09 <stevejb> tikhon: thanks!
09:30:15 <edwardk> quchen: well, mapEither being just +++ for example
09:30:18 <tikhon> stevejb: for example, it's currently designed to work with cabal-dev
09:30:19 * FreeFull puts a profunctor on monochrom
09:30:37 <edwardk> i'm pretty heavily against adding a mapEither. i'm neutralish on adding leftToMaybe, etc.
09:30:40 <quchen> I think I got it the wrong way round in my mail anyway I think. (+++) should be defined as mapEither (for (->)), and not the other way round.
09:31:41 <edwardk> i don't believe in making users chase down 3-4 modules worth of definitions in terms of "simpler" functions to read off the code and worsening inlining along the way bcause it may not get exported in the interface file. it strikes me as awkward pedagogy
09:31:56 <test123> What package has the join that lambdabot gave me (sqrt . join (+))
09:32:06 <edwardk> it means you can't understand things without keeping a stack of multiple modules open
09:32:10 <arnsholt> How annoyed should I be that the system GHC on my work machines is 7.0.4?
09:32:11 <shachaf> (+++) and (***) are both bimap in an obvious way.
09:32:26 <shachaf> :t (+++)
09:32:27 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
09:32:28 <shachaf> :t (***)
09:32:28 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
09:32:36 <edwardk> when that thing is as trivial as mapEither, it is somewhat celebrating the trappings of reuse over actually helping anyone
09:32:47 <shachaf> I mean, come on. Is (->) *really* the thing you want to abstract there for most uses of that?
09:32:54 <edwardk> shachaf: heh
09:33:01 <quchen> Oh, shachaf is back.
09:33:12 <quchen> Hello.
09:33:56 <quchen> Data.Tuple and Data.Either are some of those packages where improvementin either direction is awkward it seems.
09:34:10 <n-dolio> Yeah, arrow is not the correct abstraction for those.
09:34:27 <n-dolio> But Bifunctor is.
09:34:28 <tikhon> stevejb: here's the little mode I wrote: https://github.com/TikhonJelvis/haskell-project-mode
09:34:42 <quchen> n-dolio: Problem is those aren't in Base, and basic Either functions probably should be.
09:34:52 <tikhon> it works with cabal-dev and cabal-dev ghci
09:35:11 <tikhon> if you're not using cabal-dev, you might have to modify it
09:35:18 <tikhon> or, better yet, start using cabal-dev
09:38:16 <b2coutts> MetaCosm: you don't _need_ anything other than the basics, but this sort of goes against the philosophy of vim
09:38:41 <MetaCosm> ... I suspect wrong channel friend.
09:38:51 <test123> :t join
09:38:52 <lambdabot> Monad m => m (m a) -> m a
09:39:02 <MetaCosm> right guy, wrong channel :)
09:39:35 <stevejb> tikhon: thank you
09:40:01 <tikhon> stevejb: I just added a bit more info to the README which might help with setup
09:40:28 <stevejb> tikhon: I haven't used cabal-dev but it seems like something I should look into
09:40:34 <tikhon> yeah
09:40:39 <tikhon> and this is a good excuse to do so
09:40:53 <tikhon> in practice, the main difference is that you use commands like cabal-dev install and cabal-dev ghci
09:40:54 <quchen> test123: For functions, `join f x = f x x`
09:40:57 <tikhon> instead of cabal install and ghci
09:41:10 <quchen> test123: That's why `join (+) x = x + x`
09:41:17 <tikhon> but it lets you install packages on a per-project basis instead of installing them globally
09:41:30 <tikhon> which will likely save you some headaches in the future
09:41:49 <stevejb> yeah, I can see that I am getting to that point
09:41:55 <test123> quchen: What module has that? Do I define it myself?
09:42:01 <stevejb> version issues and such
09:42:08 <quchen> test123: It should be in Control.Monad
09:42:18 <quchen> Or even in the Prelude
09:42:33 <quchen> join is from Control.Monad, but the (->) r Monad instance is in the Prelude, that is. I think.
09:43:13 <mauke> or Control.Monad.Instances
09:44:11 <monochrom> ghci ":info Monad" shows "instance Monad ((->) r) -- Defined in `GHC.Base'"
09:45:42 <benzrf> qwradsfaqafsz
09:45:44 <benzrf> oops crap
09:46:36 <benzrf> right so I'm working on a programming challenge where you convert infix to RPN
09:46:52 <benzrf> I'm trying to figure out how to parse a string into a tree
09:47:07 <isomorphismes> merijn byorgey ah ok that you
09:47:18 <benzrf> I figured out how to do it imperatively a while back, but I can't figure out a functional way of doing it
09:47:21 <benzrf> any tips?
09:48:01 <edwardk> benzrf: take a look at the parsec examples
09:48:06 <benzrf> errr
09:49:18 <isomorphismes> byorgey: merijn So either of these works: let a=3;b=4; in a+b ------ or let a=3; b=4 in a+b
09:50:55 <isomorphismes> and let a=3; b=4 in (a+b) ---- works, but not ---- let a=3;b=4 in $ a+b
09:51:02 <test123> If join :: (a -> a -> b) -> a -> b (f x = f x x) why does Control.Monad have join :: Monad m => m (m a) -> m a
09:51:49 <Taneb> test123, the latter is a generalization of the former
09:51:50 <Taneb> :t join
09:51:51 <lambdabot> Monad m => m (m a) -> m a
09:52:07 <Taneb> Replace m with ((->) a)
09:52:22 <Taneb> ...and a with b
09:52:25 <test123> Taneb: I got it!
09:52:29 <edwardk> Taneb: pick m = (a ->)    and you get that
09:52:31 <Taneb> :D
09:52:33 <edwardk> er test123
09:52:55 <Taneb> > join (Just (Just 8))
09:52:56 <lambdabot>   Just 8
09:52:59 <benzrf> edwardk: I am having trouble finding anything specific
09:53:01 <Taneb> > join (Right (Left 3))
09:53:03 <lambdabot>   Left 3
09:53:03 <benzrf> I can only use the stdlib
09:53:07 <benzrf> [it's a challenge thing]
09:53:15 <Taneb> > join [[523,32], [21]]
09:53:16 <lambdabot>   [523,32,21]
09:53:27 <Taneb> > join (+) 9
09:53:28 <lambdabot>   18
09:53:33 <Taneb> > join (+) x
09:53:34 <lambdabot>   x + x
09:55:01 <edwardk> benzrf: http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Expr.html gives an example of precisely what you want
09:55:06 <benzrf> thakns!
09:55:09 <benzrf> *thanks
09:55:21 <test123> When I try to `join (+) 9` in ghci I "No instance for (Monad ((->) a0)) arising from a use of `join'"
09:55:33 <Taneb> test123, import Control.Monad.Instances
09:55:35 <benzrf> oh...
09:55:43 <benzrf> edwardk: no, I'm trying to figure out how to actually write the parser
09:55:46 <benzrf> not use a library
09:55:48 <benzrf> am I missing something?
09:55:55 <Taneb> test123, the instance is done correctly in newer versions of GHC
09:55:57 <edwardk> benzrf: http://comonad.com/reader/2011/a-parsec-full-of-rats/ builds up a parsing combinator library from scratch using a packrat approach
09:56:07 <benzrf> packrat approach?
09:56:16 <edwardk> the packrat parts aren't all that necessary but the basic approach is easy to follow i think
09:56:19 <test123> Taneb: Thanks.
09:56:19 <test123>  I guess I should update ghc then.
09:56:31 <Taneb> You don't need to!
09:56:36 <zomg> It's when you play an RPG and you have to collect every rock and piece of junk that you are never going to need
09:56:37 <Taneb> Stick with the platform is the best bet
09:56:47 <edwardk> benzrf: you can always write a custom Parser type by using a 'list of successes' approach. it is pretty easy if you don't care about the error messages
09:56:54 <benzrf> basically I'm just trying to figure out a functional approach to parsing
09:57:00 <benzrf> I'm too used to thinking imperatively\
09:57:02 <test123> Sorry, I guess I should upgrade to the new platform. I am on 2012.4
09:57:04 <mithsv> I get this linking error when trying to compile with executable profiling: http://pastebin.com/gE6T9fUd
09:57:04 <edwardk> newtype Parser a = Parser { runParser :: String -> [(a, String)] }
09:57:05 <mauke> The paste gE6T9fUd has been copied to http://lpaste.net/91693
09:57:10 <benzrf> I can't remove the 'iterate over a string' from my brain
09:57:15 <benzrf> I'm not writing a library
09:57:17 <monochrom> benzrf: I do not understand whether you want "infix to RPN" or "parse string to tree". if you want "infix to RPN", it needs not go through a tree.
09:57:21 <benzrf> I just want to make a simple function
09:57:26 <benzrf> monochrom: but that's how I choose to do it :
09:57:28 <benzrf> p
09:57:35 <edwardk> a parser that will yield results of type 'a' takes an input, and gives back a list of successful parsers consisting of the 'a' you were looking for and the rest of the input
09:57:47 <benzrf> blugh
09:58:09 <benzrf> basically I just need to figure out a way to locate the lowest priority infix operator in the expr
09:58:15 <edwardk> benzrf: that can be built out of the mtl automatically for you. StateT String []
09:58:17 <benzrf> in imperative languages I iterated...
09:58:20 <benzrf> mtl?
09:58:30 <edwardk> monad transformer library
09:58:34 <edwardk> @hackage mtl
09:58:34 <lambdabot> http://hackage.haskell.org/package/mtl
09:58:35 <monochrom> this is full of XY problems
09:58:36 <benzrf> =_=
09:58:42 <benzrf> monochrom: yes you are probably right
09:59:06 <edwardk> you can do this many different ways. you can build a shunting yard parser, a parsing combinator library and solve it by recursive descent, etc.
09:59:12 <benzrf> blugh
09:59:26 <ParahSailin> so mtl uses transformers, so that one is the better one to import?
09:59:36 <edwardk> i tend to write the parsing combinators because 30 lines later i have everything
09:59:47 <edwardk> ParahSailin: transformers is just the 'haskell 98 heart' of the mtl
10:02:47 <edwardk> ParahSailin: if you don't need the classes and just want the data types then you can get by with transformers
10:03:25 <Dennis> hi
10:04:40 <Dennis> i posted a Question about memory consumption and approaches of defining a grammar in haskell here: http://programmers.stackexchange.com/questions/207665/haskell-memory-efficiency-which-is-the-better-approach
10:05:21 <Dennis> This is part of a thesis i have to write and could need some information about the issue with how many copies haskell saves internally
10:05:41 <Dennis> so i would be very thankful if someone could help me with this :=
10:06:06 <Dennis> or provide me with information on where i could find an answer ;)
10:06:44 <edwardk> Dennis: for a grammar of about a thousand entries no representation will take up too much space ;)
10:07:10 <c_wraith> edwardk: I'm sure I could a representation that used a gigabyte per rule.  somehow.
10:07:16 <c_wraith> could *find* a...
10:07:40 <edwardk> also, 'aString' there is just a single 'string', its not like c where you copy it all over into fixed size buffers
10:08:09 <Dennis> edwardk i think you are the suggested ekmett :)?
10:08:19 <edwardk> thats me
10:08:46 <c_wraith> he's also sometimes edwardkmett
10:08:55 <edwardk> gotta keep them guessing
10:09:59 <Dennis> well about 1000 productions was justa random number this approach of compressing seems to only make sense in very big matrices so it could be more
10:11:09 <Dennis> But good to meet you here - Do you think it makes sense to use your interning library for this ?
10:11:49 <Dennis> i also read somethin abuóut StableNames with weak pointers to test object identity and im now kinda confused
10:12:27 <edwardk> interning would recover non-obvious sharing between values, but it will leak it for the rest of the life of the process
10:13:06 <c_wraith> well..  that's where weak pointers come in, I guess..  Only intern weakly.
10:13:27 <c_wraith> It doesn't get you all the sharing guarantees, but it does let you recover memory
10:13:46 <edwardk> you can just use the InternedByteString representation in intern directly and not have to write anything custom
10:14:17 <elliott> isn't intern broken?
10:14:25 <edwardk> elliott: its leaky, not broken
10:14:29 <elliott> fair enough :)
10:14:38 <edwardk> it originally tried to recover sharing _AND_ permit GC
10:14:47 <edwardk> but that turned out to be broken in a lazy setting
10:15:37 <c_wraith> oh, yeah.  What I was thinking only has the slightest chance of working if everything is strict.
10:19:31 <CaptainHaddock> What does Rdr stand for in Rdrnames?
10:22:14 <Dennis> Mh im still a little confused and i kinda don't know which approach i should take... The one with Constructors as parameters for my Productions seems to be better in terms of top down calcualtion of entries (mainly because i dont need to lookup the next production in a map) and the other seems to have better memory consumption to me.. is it possible to look up how much memory a sepcific object in haskell is consuming?
10:23:03 <Dennis> this would be great cause most questions on how many copies are internally insantiated by haskell i could answer my self with that
10:28:47 * hackagebot Hclip 1.0.0.1 - A small cross-platform library for reading and modifying the system clipboard.  http://hackage.haskell.org/package/Hclip-1.0.0.1 (JensThomas)
10:30:35 <kwf> @pl (\w x y z -> (w x) + (y z) - (w . y $ (x * z)))
10:30:38 <lambdabot> ap (ap . (ap .) . ((ap .) .) . ((((-) .) .) .) . ((.) .) . ((+) .)) (flip ((.) . flip . ((.) .) . (($) .) . (.)) (*))
10:30:38 <lambdabot> optimization suspended, use @pl-resume to continue.
10:31:02 <kwf> @pl-resume
10:31:08 <lambdabot> ap (ap . (ap .) . ((ap .) .) . ((((-) .) .) .) . ((.) .) . ((+) .)) (flip ((.) . flip . ((.) .) . (($) .) . (.)) (*))
10:31:08 <lambdabot> optimization suspended, use @pl-resume to continue.
10:32:32 <kot_2010> Does anybody have a strange delay of about 5 seconds in EclipseFP after press Run button? It seems that nothing is happening but hgc.exe is in the Progress. No CPU/disc activity.
10:43:47 * hackagebot esqueleto 1.3.2 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.2 (FelipeLessa)
10:46:08 <edwardk> Dennis: given the fact that everything is immutable 'a data structure' in haskell is often sharing large parts of itself with other data structures in haskell, so quantifying how much 'belongs' to some data structure is an awkward task
10:47:55 <edwardk> Dennis: you might look at something like https://github.com/BNFC/bnfc/blob/master/source/runtime/Data/Matrix/Quad.hs which provides sparseness in a quad-tree-like fashion. are you really expecting massive numbers of repeated values not just 0s?
10:48:50 <Hugh_> hello - could anyone point me to an opensource (github?) project of about 1000 ish lines of Haskell please? I would like to have a medium sized body of code to look at and take in, try to comprehend...
10:49:13 <elliott> Hugh_: perhaps xmonad.
10:49:15 <tikhon> Hugh_: XMonad—a reasonably popular tiling window manager—is a good option
10:49:18 <Hugh_> anything which is useful so the code 'makes sense'
10:49:30 <Hugh_> great, thanks
10:49:38 <Hugh_> is that github?
10:49:47 <tikhon> https://github.com/xmonad/xmonad
10:49:49 <byorgey> no, xmonad uses darcs
10:50:08 <byorgey> oh, but there's a fork on github, right
10:50:11 <tikhon> it's not the official repo, but since you just want to read the code...
10:50:31 <edwardk> hugh: almost anything in github.com/ekmett in haskell, but its not the best place to get started exploring the language's whys and wherefores
10:50:40 <tikhon> Pandoc might also be a good project to look at
10:50:44 <tikhon> https://github.com/jgm/pandoc
10:50:48 <Hugh_> exellent - thanks
10:50:48 <Dennis> edwardk: yes i do this compression method is made for non sparse matrices though its more a study so far then something usefull and we try to implement something like a proof of concept ;)
10:50:50 <tikhon> I think it's a bit bigger, but also very modular
10:51:31 <tikhon> Pandoc is a very nice tool for converting between different input formats (markdown, LaTeX, HTML) to all sorts of output formats
10:51:49 <Hugh_> pandoc sounds useful
10:51:55 <tikhon> it really is
10:52:14 <tikhon> http://johnmacfarlane.net/pandoc/
10:53:06 <tikhon> the website has a really impressive diagram of which input and output formats it supports
10:54:07 <edwardk> Dennis: so basically you are describing the matrix in quad-tree fashion already. you can generate 'tabulate' the grammar as a recursive data structure with perfect sharing that should take the same amount of space as the grammar itself, using that quad-tree rep i mentioned
10:54:27 <edwardk> er generate/tabulate
10:56:42 <edwardk> Dennis: one sec. let me write it up
10:59:33 <dmwit> ?wn wherefore
10:59:35 <lambdabot> *** "wherefore" wn "WordNet (r) 3.0 (2006)"
10:59:35 <lambdabot> wherefore
10:59:35 <lambdabot>     n 1: the cause or intention underlying an action or situation,
10:59:35 <lambdabot>          especially in the phrase `the whys and wherefores' [syn:
10:59:35 <lambdabot>          {why}, {wherefore}]
10:59:45 <dmwit> That phrase seems redundant.
11:01:44 <tikhon> woah, I never knew lambdabot had a dictionary
11:02:29 <simukis_> It's a multipurpose bot which will be an integral part of every person's life.
11:02:34 <simukis_> Soon.
11:02:54 <tikhon> combine it with some voice recognition and Google Glass :)
11:03:05 <tikhon> then you get λ-siri
11:03:33 <Dennis> edwardK: That Quadtrees look interssting and i will definitly have a look at that. Its correct that the structures of quad trees and our grammars are related but they are not äquivalent (We have a super special in productions and i think they are a bit more restricted - can't go into more detail so far ;))
11:03:35 <chrisdone> dmwit: i think it's more liek "what for" than "why"
11:03:43 <merijn> tikhon: Where do I sign up?
11:03:57 <edwardk> Dennis: one sec. i've almost finish expanding the code to convert from your rep to a quadtree
11:04:15 <edwardk> (with perfect sharing)
11:04:58 <dmwit> chrisdone: I would consider "why and what for" redundant, too. What's the difference?
11:06:38 <tikhon> the repetition is just a way to add some emphasis to the phrase—much like "varied and sundry"
11:06:39 <chrisdone> dmwit: i think "what for" implies there is a specific purpose being worked on, whereas "why" is general reason
11:06:56 <chrisdone> like "what is this book for?"
11:06:58 <Dennis> sidequestion: what does ! mean in datatype declarations?
11:07:00 <chrisdone> as opposed to "why this book?"
11:07:09 <tikhon> it means that field is strict
11:09:07 <chrisdone> dmwit: "i love you" "what for?" you'd never say that, but you might say "why?" =p
11:09:18 <edwardk> Dennis: http://programmers.stackexchange.com/a/207781/21088
11:09:38 <dmwit> hm =)
11:09:43 <edwardk> (!) is a strictness annotation.
11:10:26 <edwardk> chrisdone: you might say 'what for' in response to that statement if you think they only love you for something you did ;)
11:12:00 <edwardk> Dennis: that code above will even work for infinitely recursive expansions, etc.
11:12:02 <monochrom> I may say "what for?" too, if I know (e.g., track record) the correspondent says "I love you" for a hidden agenda
11:12:04 <chrisdone> edwardk: exactly, what's what i meant above
11:12:29 <chrisdone> "you have some motive/purpose for this"
11:12:39 <monochrom> in fact, why don't I try it now :)
11:12:46 <chrisdone> monochrom: i love you!
11:12:50 <monochrom> I love chrisdone!
11:12:55 <Hugh_> whoa! Has this turned into the 'philosophy of love' chat room!
11:12:57 <chrisdone> haha
11:12:58 <edwardk> Dennis: i was just using something almost exactly like your 'matrix grammar' to try to speed up a funny form of valiant parser the other day
11:13:30 <thetallguy2> I picked the oddest time to drop in on #haskell
11:13:39 <edwardk> by tabulating which identical sub-products had already been computed
11:13:47 <Hugh_> thetallguy2 - indeed!
11:14:23 <Igloo> thetallguy2: Could be worse. They could be talking about category theory again.
11:14:23 <applicative> we love you, thetallguy2
11:14:42 <Hugh_> I love category theory.....
11:15:00 <thetallguy2> Igloo: or I could have stumbled into some lambda on lambda action.
11:15:11 <Dennis> edwardk: wow thats awesome oO just trying to understand that now xD
11:15:27 <applicative> oh hi
11:15:34 <applicative> Igloo
11:15:38 <applicative> bah
11:15:55 <tikhon> Igloo: that's a problem at work too :P (at least among the interns)
11:16:03 <thetallguy2> applicative love.  It's a thing.
11:16:27 <tikhon> category theory is surprisingly polarizing: some people really like it and others are militantly indifferent
11:17:18 <alpha123> Can I use Haskell for real-world stuff without knowing category theory?
11:17:24 <tikhon> oh yeah
11:17:31 <applicative> hm, Erik Meijer has a company 'Applied Duality Inc.' wowz
11:17:45 <shachaf> "militantly indifferent"
11:17:55 <tikhon> But can you use category theory for real-world stuff without knowing Haskell? Much harder :).
11:18:07 <Dennis> edwardK: ah seems like this tabulate function is just computing the full matrix?ill take a read at loeb...
11:18:07 <shachaf> I like that phrase.
11:18:08 <applicative> alpha123: forget you ever heard the words 'category theory'
11:18:13 <ParahSailin> you'll eventually osmosis category theory
11:18:16 <monochrom> I am militantly indifferent to curry-howard. I use haskell without it.
11:18:30 <edwardk> Dennis: yes, but we can go both ways, i just added notes about how data-reify can do that.
11:18:53 <edwardk> its computing th full matrix, but its doing so in such a way that the references to the same non-terminal point to the same thunk in memory
11:19:34 <edwardk> so it is tying the references in memory in knots using laziness
11:19:51 <edwardk> alpha123: yes
11:19:59 <edwardk> alpha123: i didn't know any category theory when i found haskell
11:20:15 <Fuco> Can I match multiple patterns to the same "right side" in case-of? I'm recieving keyboard events and I want the same action on "Pressed" and "Repeating".
11:20:24 <alpha123> applicative: Great. :D It's hard to though, almost every explaination of monads involves category theory somehow. :/
11:20:25 <applicative> and, he didn't anything practical until he learned it ...
11:20:31 <tikhon> most of the people talking about category theory do it because it's interesting and elegant, not because it's absolutely essential
11:20:37 <monochrom> Fuco: can't
11:20:39 <edwardk> Fuco: nope but you _can_ use a guard to check more complex conditions
11:20:59 <Fuco> right! totally forgot about that
11:21:01 <chrisdone> Fuco: aren't you the who helped me with emacs yesterday?
11:21:03 <edwardk> Fuco x | x `elem` [Pressed,Repeating] ->  … would work but it'd be hideous
11:21:09 <Fuco> chrisdone: possibly ;)
11:21:16 <chrisdone> Fuco++
11:21:18 <applicative> alpha123: forget monad-in-general too. the abstracts come from experience with the material
11:21:21 <Fuco> edwardk: so what'd you do?
11:21:29 <applicative> abstractions, not abstracts
11:21:32 <Fuco> make a function and call it on both matches?
11:21:33 <tikhon> Fuco: this is one of the rare places where OCaml syntax is better
11:21:39 <dmwit> alpha123: Have you tried sigfpe's You Could Have Invented Monads?
11:21:47 <edwardk> Fuco: if i have a combinator that returns true if something matches some complex condition i tend to use x | p x -> ...
11:21:52 <edwardk> for some predicate p
11:22:25 <alpha123> applicative: Awesome. :) I just want to do things with the power and IMO beautiful syntax of Haskell, not really mess around with abstract math stuff.
11:22:38 <alpha123> dmwit: I don't think I have, I will look at that. Thanks. :)
11:23:28 <Fuco> also, is there a way to "unqualify" an import in a block?. Right now I have to put the GLFW. prefix to every key/event in this case and it is getting quite redundant
11:23:58 <monochrom> no
11:24:01 <dmwit> No, but you can import both qualified and unqualified in the whole module.
11:24:05 <merijn> Fuco: Just import unqalified?
11:24:06 <tikhon> Fuco: wow, you're good at spotting these—another place where OCaml syntax is better :P
11:24:20 <dmwit> So why not import qualified blah as GLFW; import blah (just, the, unqualified, names, you, want) -- ?
11:24:23 <applicative> Fuco: there is the more delicate procedure of making a record of it all and using record wild cards, but that will be even more work
11:24:28 <Fuco> tikhon: haha :P I've seen it somewhere, but it wasn't OCaml
11:24:34 <applicative> and maybe not a great idea anyway
11:24:52 <tikhon> let open List in ...
11:25:14 <monochrom> because of instances, local importing is problematic
11:25:20 <chrisdone> the best chance of getting local unqualification is RecordWildCards
11:25:21 <applicative> let GLFWRecord{..} = glfw in ..
11:25:38 <tikhon> yeah, instances are tricky
11:25:47 <dmwit> But why is locality so important?
11:26:03 <Fuco> so in the end it seems to add more problems than it solves :D
11:26:09 <Fuco> I'll leave it as it is for now
11:26:14 <dmwit> i.e. what's wrong with my proposed solution?
11:26:34 <applicative> Fuco: I don't know, RecordWildCards is kind of fun, and dmwit is recommending standard operating procedure
11:26:36 <monochrom> local importing is very convenient
11:26:37 <Fuco> dmwit: nothing I guess
11:26:44 <tikhon> dmwit: it's possible he's using several modules with overlapping names like Array/Map/whatever
11:27:11 <chrisdone> i suppose one way of doing multiple pattern matches is viewpatterns
11:27:12 <monochrom> local importing is also philosophically satisfying because it is in line with local defining
11:27:14 <dmwit> monochrom, tikhon: Yes, I agree that in general it's very nice.
11:27:16 <Fuco> tikhon: right now that won't be a problem, no. I want to basically import data constructors
11:27:21 <dmwit> I'm asking about this specific instance.
11:27:24 <Fuco> like Key'Escape, Key'Left etc
11:27:38 <Fuco> and have them unqualified
11:27:44 <trism> Is it possible to write a function g f = f . f; where f is not a -> a? For instance, (replicate n) . (replicate n) makes sense but wouldn't work in g
11:27:45 <Fuco> so dmwit's solution should work well
11:27:55 <tikhon> yeah, I think it's the best option here
11:28:01 <applicative> hm, oh; RecordWildCards wont work for that
11:28:06 <chrisdone> case something of
11:28:06 <chrisdone>   Cons ((\case X a b -> (a,b); Y a Z b -> (a,b)) -> (a,b)) Bob -> …
11:28:21 <edwardk> trism: the answer is technically yes, but not usefully yes.
11:28:49 <edwardk> and requires rank-2 types or a type system with subtyping
11:28:56 <applicative> @type let g f = f. f in g
11:28:56 <lambdabot> (a -> a) -> a -> a
11:29:07 <chrisdone> it would be nice to have "fall-through" patterns though, sometimes
11:29:25 <tikhon> In OCaml it would look like
11:29:48 <tikhon> match foo with | 1 | 2 -> ...
11:29:54 <chrisdone> right
11:30:00 <chrisdone> how does it handle bindings?
11:30:01 <tikhon> but that syntax only works because they use | for all patterns
11:30:04 <dmwit> :t let g :: (forall a. a -> f a) -> a -> f (f a); g f = f . f in g (replicate 3) 5
11:30:05 <lambdabot>     Illegal symbol '.' in type
11:30:05 <lambdabot>     Perhaps you intended -XRankNTypes or similar flag
11:30:05 <lambdabot>     to enable explicit-forall syntax: forall <tvs>. <type>
11:30:15 <tikhon> chrisdone: actually, I'm not sure; let me try it
11:30:21 <applicative> match foo with r@| 1 | 2 -> goo r ?
11:30:27 <dmwit> I wonder whether that would work with type families properly.
11:30:35 <elliott> no
11:30:42 <dmwit> That was sort of my guess.
11:30:44 <elliott> type families are never the f there
11:30:49 <elliott> since that kind of f has to be injective
11:30:51 <enthropy> is there a way to implement http://hackage.haskell.org/packages/archive/haskeline/0.7.0.3/doc/html/System-Console-Haskeline-MonadException.html in terms of http://hackage.haskell.org/packages/archive/monad-control/0.3.2.1/doc/html/Control-Monad-Trans-Control.html ?
11:31:19 <dmwit> elliott: er; is that a fundamental limitation or merely a current one?
11:31:20 <chrisdone> e.g. case Just (1,2) of Just (1,a); Just (_,a) -> a
11:31:54 <chrisdone> if all binding names match up and are the correct type, that could work
11:32:03 <tikhon> I think that's what it does
11:32:11 <tikhon> and the name has to occur in all of the options
11:32:43 <tikhon> if it doesn't, I get:
11:32:47 <tikhon> "Error: Variable a must occur on both sides of this | pattern"
11:32:54 <chrisdone> sure
11:33:03 <tikhon> but your particular example works
11:33:08 <elliott> dmwit: lifting it sounds annoying. especially since it means (Int -> String) could unify with (a -> f b)
11:33:14 <elliott> for *multiple* f, b
11:33:21 <elliott> and it'd break code
11:33:27 <tikhon> (modulo the incomplete pattern match)
11:33:40 <chrisdone> one-sideed unification would also be nice too but let's not lament haskell's ppattern matching =p
11:33:45 <dmwit> Ah, right, we still want unification.
11:33:55 <tikhon> one-sided unification?
11:33:56 <dmwit> s/unification/an easy unification algorithm/
11:34:26 <Dennis> edwardk: From the information u added there if i want to know just one entry of the matrix its just computing the path to this one entry and not used productions are never evaluated? Thats nice and i will try how performant it will be compared to the fixed algorithm i have to implement for that xD
11:34:53 <edwardk> Dennis: you only pay for the portions of the matrix you look at
11:35:05 <edwardk> well, plus a small fixed cost
11:35:26 <edwardk> because fmap has to strictly reconstruct a new Map due to Data.Map being spine-strict
11:35:45 <enthropy> here is what I've got so far http://lpaste.net/91694
11:35:52 <edwardk> if Data.Map was a bit lazier then you'd pay for no more than you used at all
11:35:54 <chrisdone> dmwit: i'd be very happy if f x x = … was simply translated to f x' x | x'==x = …
11:36:25 <chrisdone> i resent having to write that condition bit sometimes
11:36:27 <dmwit> chrisdone: My comment on unification was unrelated to yours. (I was responding to elliott.)
11:36:37 <chrisdone> elliott: ah, ok
11:36:41 <edwardk> dennis: the naive version would get you down to the portion of the whole a bit faster, but wouldn't get sharing across the entire matrix
11:36:45 <elliott> edwardk: no problem.
11:36:59 <Dennis> that would make equality checking of 2 terminals surprisingly easy though i dont understand that code fully so far.
11:37:15 <hvr> chrisdone: has thoughtpolice reached out to yet w.r.t http://git.haskell.org ?
11:37:21 <hvr> +you
11:37:26 <tikhon> chrisdone: that has the slightly unexpected behavior of adding an Eq constraint to an otherwise normal-looking functions
11:37:27 <chrisdone> first i've heard of it
11:37:28 <edwardk> Dennis: i recommend looking up 'tying the knot'
11:37:44 <chrisdone> tikhon: i thought someone would mention that, i would counter with: f 1 = …
11:37:49 <edwardk> @google tying the knot haskell
11:37:50 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_Knot
11:37:50 <lambdabot> Title: Tying the Knot - HaskellWiki
11:38:02 <tikhon> chrisdone: and f "foo", I suppose
11:38:05 <chrisdone> hvr: what about that domain?
11:38:10 <hvr> chrisdone: it's about the brand-styling that's going on; and there's the new http://git.haskell.org/ has a gitweb front-page
11:38:16 <chrisdone> tikhon: with overloaded strings?  right
11:38:26 <tikhon> but f x y looks much closer to f x x than to f x 1 or f x "foo"
11:38:39 <chrisdone> hvr: right, the dns seems not updated for me yet
11:38:47 <tikhon> also, what about f x = \ x -> ...?
11:38:51 <hpaste> enthropy annotated “monad-control & haskeline compatibility?” with “monad-control & haskeline compatibility? (annotation)” at http://lpaste.net/91694#a91695
11:38:58 <hvr> chrisdone: you have to hack your /etc/hosts to simulate a CNAME to ghc.haskell.org
11:39:13 <chrisdone> i'll try that
11:39:17 <hvr> chrisdone: our DNS admin is not reachable yet
11:40:10 <chrisdone> tikhon: i would say the slightly unexpected behaviour is slightly unexpected, and that it's a reasonable behaviour, and the compiler will tell you what it wants
11:40:48 <tikhon> yeah, I could see that
11:40:53 <chrisdone> tikhon: in fact, newbies /assume/ this is the behaviour of the pattern matcher quite a lot
11:40:59 <edwardk> anyways using something like intern can be done to ensure that you always get perfect structure sharing for leaves that have identical values, which then ensures that the construction of the matrix grammar from the matrix will always recover ideal sharing
11:41:05 <tikhon> but what about my lambda example?
11:41:11 <tikhon> f x = \ x -> ...
11:41:13 <edwardk> and yet still allow you to edit the contents of the matrix easily
11:41:23 <edwardk> but then it'll leak memory over the life of the program
11:41:33 <edwardk> destroying much of that utility
11:41:40 <edwardk> an explicit hash consing combinator can be written though
11:41:50 <edwardk> that can build the matrix grammar as you go with sharing
11:41:54 <chrisdone> tikhon: the lambda seems fine? they are separate pattern matches
11:41:58 <tikhon> yeah
11:42:16 <tikhon> but right now f x y = ... is just syntax sugar for two lambdas; this would break that expectation
11:42:19 <clahey> So, if you were going to write a mandelbrot explorer in haskell, what sort of data structures might you want?
11:42:54 <chrisdone> tikhon: hmm, we've already broken that, consider:
11:43:06 <chrisdone> f x 1 = …
11:43:06 <chrisdone> f x = \n -> …
11:43:11 <chrisdone> ghc will tell you that this is not valid
11:43:21 <tikhon> right
11:43:27 <chrisdone> "wrong number of arguments"
11:43:29 <clahey> In particular, if you wanted to keep your state for each pixel and iteratively do more detail?
11:43:46 <clahey> So you can display the whole thing quickly and then get more accurate over time?
11:44:03 <chrisdone> tikhon: i thinnk  actually they are different, really. pattern matching happens in one go
11:44:13 <tikhon> yeah, I guess I could see it being useful, but I'm still a little skeptical—I'd have to play around with it before making a decision
11:44:46 <chrisdone> tikhon: f 1 = \1 ->  is two separate pattern match procedures, the first one can suceed while the second one may never even be evaluated. whereas f 1 1 = has to match in one go
11:44:53 <tikhon> ooh, I don't think of pattern matching as "happening" per se, but I do a lot of purely symbolic manipulations of my code
11:44:59 <Dennis> edwardk: seems like i have some more things to read. one more question: that functions seems to be very neat though as i said we got some "theroretically proofen algorithms" which we have to implement (including lookups xD) so dont think we can use that fancy tabulate ;)
11:45:00 <tikhon> which assume a bunch of these little rules to hold
11:45:23 <clahey> I'm currently looking at IOArray (Int, [Double]) where the Int is the number of iterations that have been done for that pixel and the [Double] is the iterated value (x_i = x_(i-1)^2 + c)
11:45:43 <tikhon> for example, I often change a function with two arguments into a function with one that resolves to another function in a where clause (if that makes sense)
11:45:47 <Dennis> edwardk: but anyhow as i understand right now the sharing is because of the loeb function and because the datatype is a fucntor ?
11:46:05 <chrisdone> tikhon: if you do that, you are changing the semantics, of course
11:46:09 <edwardk> Dennis: you should be able to modify the scheme slightly to accomodate more interesting compressions
11:46:14 <clahey> Which would be great except that I'd like to keep the data when the window size changes, but IOArray doesn't have an easy way to create a new array with a subset of that array equal to the old array.
11:46:25 <tikhon> chrisdone: changing the semantics? How?
11:46:36 <clahey> And I was curious if there was a data structure that might do me here.
11:46:48 <tikhon> I view it as a purely syntactic refactoring that's perfectly meaning-preserving
11:46:53 <edwardk> i do this sort of thing routinely to say, perform monoidal summaries of data compressed in LZ78 without expanding first.
11:47:05 <tikhon> to the point where I do it without even thinking about what the particular code does, just about how it reads
11:47:08 <edwardk> http://hackage.haskell.org/packages/archive/compressed/3.0.3/doc/html/Data-Compressed-LZ78.html
11:47:44 <edwardk> there i can foldMap over the LZ78 compressed data without decompressing fully by performing my LZ78 expansion 'in the monoid'
11:47:50 <edwardk> and get sharing of monoidal intermediate results
11:48:39 <edwardk> that can be viewed as a version of this same pattern, where we simply state how new non-terminals are built out of existing non-terminals seen so far
11:49:07 <hvr> chrisdone: can ircbrowse compute a cat-theory scoring per nickname? i.e. the more cat-theory terms the nick says, the higher the score
11:49:08 <edwardk> that version also has the benefit of properly being lazy and not having to deal with the Map.
11:49:18 <dmwit> clahey: I would think of some kind of infinite kd-tree or something
11:49:32 <chrisdone> tikhon: i suppose if you ignore strictness, there's no difference
11:49:35 <dmwit> Well, quadtree, since we know k=2.
11:49:44 <tikhon> chrisdone: does strictness change it somehow?
11:49:50 <chrisdone> hvr: what's a cat-theory?
11:49:54 <tikhon> category theory
11:50:00 <hvr> chrisdone: category theory =)
11:50:13 <chrisdone> oh, i thought you were referring to some score =p
11:50:15 <edwardk> Dennis: i have a similar construction for run length encoding as well that can 'decompress in a target monoid'
11:50:25 <edwardk> its a bit different in 2d, but not much
11:51:04 <Dennis> well i have something for SLPs in 2d which we wanted to take as our blueprint
11:51:05 <tikhon> I'm roughly talking about refactoring f a 1 = ...; f a 2 = ...; f a 3 = ... into f a = go where go 1 = ...; go 2 = ...; go 3 = ...
11:51:41 <tikhon> of course the actual patterns in question are often quite a bit more complicated
11:51:52 <tikhon> I think this is entirely sound, but I could be wrong
11:51:55 <edwardk> expand SLP?
11:52:25 <edwardk> straight line programs?
11:52:27 <chrisdone> hvr: give me a list of category theory terms and i can compute a score =p
11:52:36 <Dennis> yes
11:52:58 <dmwit> chrisdone: ncatlab.org ;-)
11:53:03 <Dennis> but thats far easier and i dont think there is much thought about memory consumption :)
11:53:05 <tikhon> maybe we should throw together something like a naive Bayes classifier to figure out whether somebody is talking about category theory :)
11:53:12 <chrisdone> tikhon: hang on, i thinnk i have an example of the difference
11:53:14 <edwardk> sure
11:54:13 <Dennis> though this is not our main task it could be interessting to write about this in our thesis (we have a lot of pages to fill)
11:54:24 <edwardk> anyways that was pretty much what i was getting at with the LZ78 analogy, SLP and LZ77 are very similar
11:54:44 <chrisdone> @let f 1 2 = "A"; f 1 3 = "B"
11:54:44 <chrisdone> @let g 1 = \2 -> "A"; g 1 = \3 -> "B"
11:54:45 <lambdabot>  Defined.
11:54:45 <lambdabot>  .L.hs:145:1: Warning:
11:54:45 <lambdabot>      Pattern match(es) are overlapped
11:54:45 <lambdabot>      In an equat...
11:54:57 <chrisdone> > f 1 3
11:54:58 <lambdabot>   Ambiguous occurrence `f'
11:54:58 <lambdabot>  It could refer to either `L.f', defined at L.hs:1...
11:55:04 <chrisdone> well, you get the idea
11:55:21 <chrisdone> f and g are not semantically the same, despite the transformation seeming "sound"
11:55:31 <dmwit> um?
11:55:36 <dmwit> That is not the transformation tikhon proposed.
11:55:50 <Dennis> yeha we implemented LZ77 some time ago in some universty practicum
11:55:52 <dmwit> g 1 = go where go 2 = "A"; go 3 = "B" would be what he proposed
11:56:06 <dmwit> ...which looks the same to me.
11:56:09 <tikhon> yeah, with multiple lambdas, it does have a different meaning
11:56:11 <chrisdone> i was talking about what *i* said
11:56:21 <dmwit> Oh, I missed that. Sorry.
11:56:24 <chrisdone> but ok if that's all you meant, nevermind
11:56:33 <Dennis> but also there noone asked for real compressions though..
11:56:33 <edwardk> Dennis: i'm mostly interesting in this stuff because i have a toy little valiant parser combinator library i started the other day, and i'm looking at the matrices i get in the meantime, which are all defined in that recursive quadtree form, and looking for more sharing
11:56:50 <tikhon> I think I was a bit unclear about my expectations for how f a b can turn into f = \ a -> \ b -> ...
11:57:45 <chrisdone> sure, you mean literally variables, not "any pattern here"
11:57:51 <edwardk> the code i linked for LZ78 takes a list and can give you a data type that is the LZ78 compression of that list, then you can map over that new list with a monoid to extract a monoidal summary, we do that by building the decompression table, but instead of decompressing a list of values, I decompress in your new monoid
11:57:58 <tikhon> chrisdone: how often do the little user pages (with the various graphs) update on ircbrowse.net?
11:58:08 <chrisdone> tikhon: once a day
11:58:13 <edwardk> so if you have a list of numbers and then LZ78 compress it, i can, say, tally the sum of the list without fully expanding it
11:58:14 <tikhon> really?
11:58:16 <tikhon> hmm
11:58:29 <chrisdone> in fact i need to do some manual intervention on ircbrowse as tunes returned a crappy unparseable log again…
11:58:38 <tikhon> aha
11:58:42 <tikhon> tunes?
11:58:52 <edwardk> the benefit of SLP-matrix compression though is when you go to do things like matrix multiplication, your compression boundaries all line up in quad-tree form for subdivision based multiplication
11:58:54 <dmwit> There are #haskell logs on tunes.org.
11:58:59 <tikhon> I see
11:59:02 <tikhon> I haven't seen those before
11:59:09 <dmwit> They're in the /topic...
11:59:20 <tikhon> yeah, I never paid attention to that :P
11:59:26 <chrisdone> reading the topic is so 90s
11:59:26 <edwardk> and you should be able to do things like track which products have already been taken by name and their result
11:59:40 <tikhon> also, what does any of this have to do with tunes.org itself?
11:59:47 <edwardk> but those matrices would likely have to be huge and highly repetitive for that to pay off
11:59:50 <tikhon> which seems to be a defunct OS project
11:59:56 <danharaj> edwardk: I've only been able to drop in once in a while for the past hour, can you compress what you're talking about into a blog post for later consumption :P
12:00:01 <dmwit> At a guess: ircbrowse.net doesn't have a bot on IRC, it just scrapes tunes.
12:00:02 <chrisdone> dunno. tunes.org hosts a bunch of irc logs
12:00:13 <edwardk> danharaj: there are channel logs ;)
12:00:15 <b2coutts> woah, I'm higher up in that than I expected
12:00:18 <dmwit> Oh, you meant what does IRC logging have to do with tunes. =P
12:00:29 <danharaj> edwardk: compression! :P
12:00:43 <chrisdone> ironic that tunes is more remembered for its irc logging than OS innovation
12:00:51 <edwardk> danharaj: you should know that you can't compress the results of good compression!
12:01:26 <danharaj> edwardk: good point
12:02:18 <edwardk> Dennis: anyways i'm curious what you're up to, because it seems your project and my obsession of the moment happen to coincide =P
12:02:35 <Dennis> edwardk: well i thought about the compression which we can achive this way before and i don't think it will be that great on non sparse matrices simply because the definition is a limitation here... but well its a study :=
12:02:38 <danharaj> you should tweet your obsession changes
12:02:51 <sm> chrisdone: how would you feel about adding #haskell-game to ircbrowse
12:03:00 <edwardk> danharaj: by the time i realize its shifted its too late
12:03:13 <clahey> dmwit, What is this infinite kd-tree you speak of and where can I buy one?
12:03:15 <sm> or would that dilute the mission :)
12:03:18 <chrisdone> sm: if it's on tunes.org, happy. if not, reluctant
12:03:30 <edwardk> also, this way i seem omniscient. if i tweeted every time i switched topic i'd seem like a flake ;)
12:03:36 <danharaj> hehe
12:03:38 <edwardk> well, like more of a flake
12:03:43 <danharaj> edwardk: maybe I can convince you to obsess over adjoint folds?
12:03:43 <sm> hmm, so get ourselves on tunes first ?
12:04:02 <danharaj> edwardk: And then profunctor algebras. And then adjoint folds over profunctor algebras. Then you'd do what I would do in my nonexistent space time!
12:04:04 <clahey> dmwit, More to the point, do you know of a good reference for what a kd-tree is that I could read?
12:04:12 <dmwit> clahey: Wikipedia?
12:04:17 <clahey> Parfait.
12:04:39 <chrisdone> sm: could do?
12:04:49 <tikhon> Wikipedia CS is a little inconsistent in quality (although the k-d tree article seems relatively good)
12:04:49 <edwardk> clahey: take your axes, split your set on one axis, somewhere then the next, then the next, ten loop back around until you run out of points recursively
12:04:57 <chrisdone> sm: i'm not sure how responsive the tunes guys are, but that would be super convenient if so
12:05:23 <dmwit> clahey: oh
12:05:24 <merijn> clahey: It's a binary tree, but you split in more than two dimensions :)
12:05:35 <edwardk> a kd-tree is a binary tree where each fork at level l has a choice of where on axis (l `mod` number of dimensions) it is splitting.
12:05:38 <dmwit> clahey: And the Dr Dobbs article on "An Algorithm For Compressing Space And Time" or something like that.
12:05:39 <sm> I doubt super responsive, and it seems we'd then have two sites logging the channel which creates confusion
12:05:42 <dmwit> clahey: It will blow your mind.
12:05:51 <chrisdone> sm: where is the other site?
12:06:05 <sm> I mean there would be the tunes log, and the ircbrowse log
12:06:32 <chrisdone> that's what we have anyway with #haskell?
12:06:33 <tikhon> sm: just point everyone at ircbrowse and leave tunes.org as essentially part of the backend
12:06:33 <edwardk> it is pretty much an old stand-by in computational geometry for point-set data (and for some polygonal stuff)
12:06:58 <dmwit> edwardk: I was thinking of using it for LOD type stuff here.
12:07:00 <clahey> Ah, yeah, I'm familiar with those.
12:07:06 <dmwit> Which it seems it should be suited for, too.
12:07:08 <chrisdone> hmm, i could implement logging in ircbrowse directly
12:07:09 <dmwit> With slight adaptation.
12:07:19 <Dennis> edwardk: oh i would tell you if i could but because i don't fully understand what im doing myself thats not possible :) - Anyhow you helped me alot here thanks for that i will forward this to my mate and come back here in the next days xD
12:07:21 <sm> does ircbrowse piggyback off tunes logs or something ?
12:07:32 <chrisdone> sm: yeah, it downloads them once a day and imports
12:07:40 <sm> ah
12:07:48 <sm> fair enough
12:07:50 <edwardk> Dennis: np. i'll shoot me my email address in pm. feel free to fire me follow up questions and i'm happy to help
12:08:01 <clahey> So instead of an array, I keep a 2d tree of the area that I care about.
12:08:04 <edwardk> er shoot you
12:08:05 <clahey> And the leafs are points.
12:08:20 <dmwit> clahey: I would want all internal nodes to be points.
12:08:27 <clahey> And if I go to find the info about a point and it's not there, I can divide the tree until it is.
12:08:31 <dmwit> clahey: And then you compute the tree just deep enough to get enough points. =)
12:08:32 <clahey> dmwit, Oh yeah, good point.
12:08:43 <edwardk> the leaves are technically 2d (potentially unbounded) axis aligned boxes
12:08:51 <dmwit> right
12:09:01 <edwardk> each time you pick an axis-aligned plane to divide on you are splitting your current space in half
12:09:04 <clahey> And I can keep the data around when I zoom.
12:09:05 * sm wonders who is http://tunes.org/~nef
12:09:08 <merijn> Is there a variant of "when" with type "Bool -> a -> m a -> m a" or something similar?
12:09:08 <Dennis> edwardk thanks for that :)
12:09:15 <clahey> And just use the old data as guesses.
12:09:42 <scshunt> merijn: what semantics?
12:10:02 <clahey> > :t when
12:10:02 <dmwit> clahey: But again, I would make the structure be an infinite, read-only one.
12:10:03 <lambdabot>   <hint>:1:1: parse error on input `:'
12:10:06 <edwardk> Dennis: you my also want to read: http://www.cse.chalmers.se/~bernardy/PP.pdf which describe a bit of why i care about this rep =)
12:10:15 <clahey> dmwit, Why read only?
12:10:15 <tikhon> @type when
12:10:16 <lambdabot> Monad m => Bool -> m () -> m ()
12:10:47 <dmwit> clahey: Read only isn't important, but it's a feature of the implementation strategy I'm suggesting and I'm hoping it's a feature of few enough implementation strategies that only the one I'm thinking of meets it. =)
12:10:54 <tikhon> I think the semantics are clear from the type
12:10:55 <merijn> scshunt: "\b x act -> if b then return x else act"
12:11:07 <dmwit> In other words, "read-only" is meant to be a disambiguation phrase rather than a prescriptive one. =)
12:11:14 <clahey> dmwit, Oh, the tree itself is read only, it just keeps IOVars or TVars or something as the data at the points.
12:11:18 <dmwit> no
12:11:23 <dmwit> No, really, really read-only.
12:11:39 <dmwit> You make it once at the beginning. Every point you're interested in is in it.
12:11:42 <scshunt> merijn: I know of no function for that
12:11:45 <clahey> Huh, cause one of the important points of what I want to do is to have the data at each point be updateable.
12:11:46 <dmwit> And then laziness means it only computes the points you observe.
12:11:52 <scshunt> your if statement seems fine though
12:11:57 <dmwit> clahey: Why updateable?
12:12:02 <dmwit> The Mandlebrot set never changes...
12:12:18 <edwardk> given that i'm using the matrices there as a chart of another grammar, compressing them using a grammar myself seems poetic
12:12:20 <clahey> dmwit, Right, but a computer view of the mandelbrot set includes the maxIterations value.
12:12:26 <clahey> dmwit, Which I want to change over time.
12:12:40 <clahey> So that I can compute a low detail set quickly and then improve it over time.
12:12:41 <dmwit> clahey: No problem, let "number of iterations" be one of the dimensions in the tree. =)
12:13:19 <clahey> dmwit, That could work.
12:13:33 <dmwit> Alternately, let the number of iterations be a lazy natural.
12:13:36 <clahey> dmwit, Is there some specific reason that my idea of putting IOVars on the points wouldn't work?
12:13:43 <dmwit> You can do greater-than comparisons without computing the actual natural.
12:13:52 <edwardk> dmwit: cute
12:13:54 <dmwit> No. It would work. But it isn't beautiful. =)
12:14:06 <clahey> I think it might take up a considerable amount less memory.
12:14:10 <clahey> But I could be wrong.
12:15:01 <merijn> hmm, alternatively, is the something like <|> for Monoid?
12:15:20 <tikhon> merijn: what would that do?
12:15:21 <merijn> Returning the first non-mempty value
12:15:25 <tikhon> an
12:15:26 <tikhon> ah
12:15:28 <tikhon> hmm
12:15:31 <dmwit> :t \x y -> if x == mempty then y else x
12:15:32 <lambdabot> (Eq a, Monoid a) => a -> a -> a
12:15:51 <clahey> merijn, You want whenElse test default mon = if test then mon else return default ?
12:16:00 <clahey> merijn, Is that the semantics you're looking for?
12:16:00 <dmwit> merijn: Perhaps you want the First monoid.
12:16:12 <merijn> dmwit: Sure, but I wanted to get rid over some code like that by having a function I can lift over my monad
12:16:13 <dmwit> > First Nothing <+> First (Just 3)
12:16:14 <lambdabot>   Ambiguous occurrence `<+>'
12:16:14 <lambdabot>  It could refer to either `Control.Arrow.<+>',
12:16:14 <lambdabot>  ...
12:16:23 <dmwit> > First Nothing `mappend` First (Just 3)
12:16:24 <lambdabot>   First {getFirst = Just 3}
12:16:28 <merijn> clahey: Pretty much
12:16:29 <kimblorangler> How does haskell compare as a language for hardware programming against other languages? e.g. c/c++/lisp/python
12:16:32 <merijn> dmwit: oh, maybe!
12:16:35 <dmwit> > First (Just 4) `mappend` First (Just 3)
12:16:37 <lambdabot>   First {getFirst = Just 4}
12:16:45 <merijn> kimblorangler: What does "hardware programming" mean?
12:16:51 <merijn> oh
12:16:53 <kimblorangler> Robotics
12:16:59 <Clint> soldering iron
12:17:00 <sleepynate> kimblorangler: for a single-line answer, "high barrier of entry"
12:17:05 <merijn> Actually, I don't think First monoid will help me
12:17:14 <tikhon> I think some people (Galois inc) use it very successfully in that space, but I could be wrong.
12:17:15 <kimblorangler> Due to ut's difficulty?
12:17:20 <clahey> kimblorangler, merijn: Isn't there a company using haskell in designing ICs?
12:17:21 <tikhon> I only have a vague idea of what exactly Galois does
12:17:23 <sleepynate> kimblorangler: toolchain, mostly
12:17:24 <merijn> The effect needs to be conditional, so lifting something won't work
12:17:28 <dmwit> kimblorangler: ping acowley, he does robot programming in Haskell
12:17:32 <edwardk> clahey: bluespec
12:17:39 <kimblorangler> cheers
12:17:46 <merijn> clahey: University of Twente in NL is modelling hardware in haskell
12:17:51 <clahey> edwardk, I know, I was just intentionally misunderstanding hardware programming.
12:17:51 <tikhon> I don't think he meant hardware *design*
12:17:53 <edwardk> clahey: they have a whole language based on a haskell-compiler that generates netlists for chips
12:18:01 <sleepynate> kimblorangler: the language itself is great for logic stuff, but there's no "easy button" for robotics like in python
12:18:11 <clahey> So, the main problem I see with your first suggestion (number of iterations is a dimension) is that (I assume) the infinite kd-tree requires some reasonable guestimate of a good place to do the dividing?
12:18:18 <tikhon> otherwise Python wouldn't have been an alternative (unless there's a Python HDL floating around that I simply haven't heard of)
12:18:20 <edwardk> and yeah there are various forms of Lava out there, kansas lava, etc.
12:18:42 <dmwit> merijn: Yes, there's not really a good story for lifting short-circuiting operations into monads as far as I know.
12:18:49 <edwardk> kimblorangler: acowley does some pretty damn impressive stuff with robotics in haskell.
12:19:09 <kimblorangler> Is python any good anyway? pypy speeds are quick I hear, C python even better. But I seems to high a level language to compare to haskell
12:19:14 <edwardk> kimblorangler: http://www.youtube.com/watch?v=Zlt6EJVdUN8
12:19:17 <clahey> dmwit, Doesn't STM lift short-circuiting fairly well?
12:19:18 <kimblorangler> edwardk: do you know when he is on?
12:19:31 <tikhon> kimblorangler: how do you define "high-level"?
12:19:39 <dmwit> clahey: You can *do* short circuiting in many monads. You can't *lift* short circuiting very well.
12:19:41 <edwardk> kimblorangler: we try not to get into debates about the relative merits of different programming languages in here, as it doesn't lead to good things
12:19:42 <sleepynate> kimblorangler: honestly, their abstraction levels are about the same
12:19:47 <dmwit> i.e. generically over all short-circuiting operations.
12:19:48 <merijn> dmwit: Yeah, it looks like I really want like MonadPlus/Alternative for something whose inner value is a Monoid, but that doesn't help :p
12:19:53 <sleepynate> kimblorangler: haskell is quite a high-level language :P
12:20:27 <dmwit> clahey: And yes, adding it as a dimension may not be the best choice. Though it wouldn't be terrible; you could do something like geometric search.
12:20:39 <b2coutts> the highest of levels
12:20:56 <kimblorangler> I'm not sure whether to start getting into haskell. It seems like a cool language though
12:21:02 <tikhon> Haskell has some cool tools for various flavors of reactive programming which may be well-suited to your particular application
12:21:13 <clahey> dmwit, Wouldn't it be easy to do   or :: Monad m => m Bool -> m Bool -> m Bool   or a b = a >>= (\result -> if result then return result else b)
12:21:14 <dmwit> clahey: i.e. first you have a chain of iteration counts like [1,2,4,8,16,32,64,...] and then once you go over the desired iteration count it's binary search or some such thing.
12:21:23 <tikhon> ultimately, it really depends on what exactly you want to do
12:21:28 <dmwit> clahey: Yes. Now implement that in terms of (||) and you'll see what I mean.
12:21:36 <clahey> dmwit, Gotcha.
12:21:39 <dmwit> clahey: liftM2 (||) ain't it
12:21:56 <edwardk> kimblorangler: other stuff from the same lab: http://www.youtube.com/watch?v=YQIMGV5vtd4
12:21:56 <edwardk> kimblorangler: he is in here fairly often. also #haskell-lens
12:21:57 <tikhon> Maybe take a look at http://blog.sigfpe.com/2011/02/build-yourself-bluetooth-controlled-six.html? It looks like a really promising article from a *very* high quality blog.
12:22:14 <b2coutts> kimblorangler: also, I would say haskell is much higher-level than python; python still largely adheres to the imperative paradigm, which has loosely evolved from machine code
12:22:23 <tikhon> edwardk: is that the UPenn thing?
12:22:24 <clahey> dmwit, So, this would mean making the tree one and a half times as deep.
12:22:32 <dmwit> clahey: And there's not really a good function (or even family of functions) for which f (||) *is* it.
12:22:49 <dmwit> clahey: one and a half times as deep as what?
12:22:50 <clahey> (back to mandelbrot)
12:23:00 <edwardk> that stuff uses lots of general purposes haskell libraries though, 'linear', my 'ad' automatic differentiation library, etc. who knew all this crap i wrote for fun could be useful to robotics guys! =)
12:23:16 <clahey> dmwit, Adding a third dimension compared to 2 dimensions.
12:23:27 <tikhon> it is funny how your abstract libraries get practical use in academia
12:23:30 <clahey> dmwit, As importantly, it would mean not deleting the information about lower iteration counts as you increased the iteration counts.
12:23:33 <b2coutts> kimblorangler: and also, you should start getting into haskell because john carmack said so :)
12:23:49 * hackagebot crypto-totp 0.1.0.0 - Provides generation and verification services for time-based one-time keys.  http://hackage.haskell.org/package/crypto-totp-0.1.0.0 (JeffShaw)
12:24:00 <dmwit> clahey: I suppose.
12:24:06 <clahey> dmwit, And thus even as you sat there watching it, it would continue to use more memory.
12:24:11 <clahey> dmwit, But it would be a pretty design.
12:24:21 <dmwit> clahey: I think overall I like the idea of using a lazy nat better.
12:24:21 <kimblorangler> b2coutts: haha well he does have credibility. what reason did he give?
12:24:23 <clahey> dmwit, I didn't understand your Natural number suggestion.
12:24:36 <clahey> What's a lazy nat?
12:24:39 <dmwit> clahey: Especially since you could easily choose to use a lazy binary nat and demolish your space-saving complaint. =P
12:24:53 <dmwit> clahey: The easiest (badly performing) lazy nat is data Nat = Z | S Nat
12:24:57 <b2coutts> kimblorangler: actually I've yet to see the talk that he gave; he said words to the effect of "if you start learning haskell now, you'll be kicking ass in 5 years"
12:24:59 <dmwit> i.e. type Nat = [()]
12:25:00 <edwardk> kimblorangler: he rambled for an hour or so about it, hard to summarize, but 'state bad', functional code is awkward but easy to reason about over the lifespan of the project, etc.
12:25:11 <b2coutts> perhaps someone else in this channel can be more specific :P
12:25:30 <b2coutts> also I disagree on the idea that functional code is awkward
12:25:35 <clahey> dmwit, Right.  The Natural numbers by the definition.  That was what I figured you meant.  But I don't know how that would help.
12:25:58 <dmwit> clahey: What's neat about lazy nats is that (5 > 6+undefined) returns False -- so comparisons return *as soon as* the computation notices it's done enough work.
12:26:34 <wargotad> Hello everyone! I have programmed a small utility program to help reduce password reuse and I'd like to know what you think about it (the code or the general idea). The code is on GitHub at https://github.com/redelmann/scat . For comments, you can go to http://www.reddit.com/r/haskell/comments/1k1k6r/scat_my_solution_to_the_password_reuse_problem_in/ ! Cheers!
12:26:38 <boothead> hi guys, is anyone using Haskell in an event processing setting?
12:26:39 <dmwit> i.e. even 5 > 6 + (prove the Poincare conjecture) or 5 > 6 + (do 10^6 more iterations of mandlebrot's formula before we realize we're done) returns quickly
12:27:02 <clahey> I get it.
12:27:10 <edwardk> b2coutts: likewise, but to someone without experience with it, it can take a while to find your sea legs
12:27:19 <clahey> You have the result type be a lazy natural number.
12:27:24 <clahey> You have a tree of those.
12:27:34 <dmwit> The result of computing how many iterations it takes is a lazy nat, yes.
12:27:35 <clahey> And you iterate over it saying, "are you less than 100"?
12:27:37 <b2coutts> edwardk: I don't think that's any truer of functional programming than any other paradigm
12:27:40 <dmwit> clahey: right =)
12:27:51 <kimblorangler> b2coutts: apparently haskell is relatively difficult to learn, emphasis of relatively
12:27:59 <b2coutts> I guess it relies on the assumption that everyone is used to iterative programming and nobody is used to functional programming :P
12:28:00 <dmwit> clahey: Or, if you prefer, "what are you, but at most 100?".
12:28:07 <clahey> Right.
12:28:09 <edwardk> b2coutts: sure. but he's coming to it as a 25+ year veteran of the other school of thought ;)
12:28:24 <clahey> So, there's a little bit more information I want which might make things tough.
12:28:43 <edwardk> he's likely say the same thing if the 'language of the future' was prolog ;)
12:28:46 <edwardk> er he'd
12:29:08 <clahey> I would like to know, when you do iterate past the end of the world, what was the value of your last iteration.
12:29:17 <b2coutts> kimblorangler: people keep saying this, in this channel and elsewhere, and I still disagree
12:29:55 <b2coutts> edwardk: oh, I guess if he was making more of a personal statement, rather than a universal statement, that's fine
12:29:57 <clahey> Though I suppose the value at each node could be (iteratationcountasnatural, finaliterationasmaybeundefined)
12:30:02 <kimblorangler> b2coutts: personally or generally speaking?
12:30:02 <edwardk> clahey: use a 'Partial' number monad
12:30:05 * b2coutts should just watch his talk
12:30:17 <edwardk> newtype Partial a = Partial (Partial a) | Total a
12:30:33 <b2coutts> kimblorangler: well I can only _really_ talk about personal experience, but when I try to think about it objectively I don't feel that haskell is harder to learn than, say, perl
12:30:33 <dmwit> wargotad: I guess the complaint about this and other tools is that an attacker that knows your password on one site has a lot of information about your password on every other site ever.
12:31:04 <b2coutts> in fact, I would guess that it would be easier for someone who has never programmed before to learn how to write basic programs in haskell than in perl
12:31:21 <dmwit> clahey: I don't understand yet.
12:31:25 <edwardk> you can make a monad for partial very easily, then every 'step' you put on another Partial. you can translate Total = 0, and Partial n = (1 + n)  as the level
12:31:26 <alpha123> b2coutts: Depends if they had a strong math background I think.
12:31:36 <dmwit> clahey: Ah, no, I do understand.
12:31:47 <dmwit> clahey: Okay, no problem; instead of [()] use [Complex Double] or whatever. =)
12:31:48 <b2coutts> the illusion of difficulty probably largely comes from the fact that haskell is a functional programming language, and someone who has used perl is going to have a much easier time learning python than haskell
12:31:53 <clahey> dmwit, Yeah, you only ever read the second value if the first value finally comes to an end.
12:31:58 <edwardk> if you force it down to level n and its still partial you don't have a value, if you force it down to level n and find a Total you have the answer
12:32:12 <edwardk> clahey: put the second value _in_ the first
12:32:13 <b2coutts> alpha123: strong math background definitely helps, though I'm not sure it's necessary to become a decent haskell programmer
12:32:16 <dmwit> clahey: Oh, okay, if you know that, then yeah, a pair is great, as you said.
12:32:27 <b2coutts> depending on your definition of decent
12:32:30 <clahey> dmwit, Actually...
12:32:36 <kimblorangler> b2coutts: For someone who is relatively new to functional programming, would haskell be a good starting point? Or would it be better to start with a more fundamental language like c or c++?
12:32:39 <tikhon> even coming from a very imperative background, I found certain languages (ie C++) much more difficult to learn than Haskell
12:32:39 <alpha123> b2coutts: Even if you've never been exposed to imperative programming Haskell is still boing to be hard due to how general its concepts are, which would be more familiar to math types.
12:32:43 <clahey> dmwit, IOVar [Complex Double] is my current data structure.
12:32:45 <merijn> alpha123: I have a very math background (just some CS courses) and I have no trouble with Haskell
12:32:52 <dmwit> clahey: =)
12:32:55 <clahey> dmwit, Or IOArray currently.
12:33:02 <clahey> dmwit, Yeah, I came up with [Complex Double] on my own.
12:33:03 <merijn> alpha123: I *don't* have
12:33:14 <alpha123> b2coutts: I hope you're right, I don't have a strong math background (yet) and I'd like to be a decent Haskell programmer :)
12:33:20 <b2coutts> kimblorangler: well, c/c++ aren't really going to help you with functional programming. I think haskell is a perfectly good language for learning functional programming, but a lot of people like to start with scheme first. I suppose scheme is somewhat more similar to typical languages than haskelll
12:33:24 <dmwit> clahey: Right, but the observation is that laziness is all the mutability you need.
12:33:31 <dmwit> clahey: That's (in my opinion) the cool part.
12:33:34 <edwardk> runPartial :: Int -> Partial a -> Maybe a; runPartial !_ (Total a) = Just a; runPartial 0 _ = Nothing; runPartial n (Partial m) = runPartial (n - 1) m
12:33:44 <edwardk> then you don't need any weird tuple
12:34:05 <clahey> dmwit, The advantage of having it as an IOVar (Int, [Complex Double]) is that to check the value being < 100 you just check the int instead of doing 100 steps down the list.
12:34:10 <b2coutts> alpha123: I think the paradigm behind haskell makes it that much easier for beginners; there's a lot of intuition required for imperative programming that I think programmers take for granted
12:34:18 <edwardk> and i've said the same thing for 4 minutes without a response so i'm going to shut up and work on something else now
12:34:18 <merijn> In proper haskell style, the more I realise what I'm doing, the shorter my code becomes
12:34:23 <b2coutts> the fact that haskell is more elegant, and without exception, makes it easier to conceive of, I thin
12:34:26 <nonconvergent> Let's be fair...most imperative programmers don't recognize the important distinctions that would set it apart from functional programming anyway, like the reliance on side-effects.
12:34:27 <b2coutts> k
12:34:28 <clahey> edwardk, Sorry about the no response.
12:34:31 <clahey> I've been reading it.
12:35:01 <clahey> edwardk, Does it not have the same issue that I just described where you have to do 100 lookups to see whether the value is done?
12:35:08 <nonconvergent> I didn't...not until I actually learned what side effects were.  Four years into a CS degree.
12:35:15 <alpha123> b2coutts: That's definitely true, Haskell is much more consistent than most imperative langauges (Ruby and Lua might be exceptions)
12:35:18 <dmwit> clahey: Right. [()] is a lousy type for lazy naturals. But [Bool] is significantly better. =)
12:35:33 <clahey> dmwit, But it loses the ability to tag each step.
12:35:40 <alpha123> b2coutts: But I think Haskell requires thinking on a more abstract level than most people are used to
12:35:46 <edwardk> you just tick it down towards the answer. once you've got the answer you can cram it in an IVar or something which gets you something like your original result
12:36:00 <dmwit> clahey: I thought you said you only wanted the final value anyway.
12:36:13 <dmwit> (I feel like we're going in circles here.)
12:36:26 <merijn> alpha123: *programming* requires thinking on a more abstract level than most people are used to
12:36:29 <edwardk> but knowing if you _should_ look at the ivar is a function of checking if the lazy natural number you have is bigger than some other number anyways… which is the ame work as forcing the partial monad!
12:36:32 <b2coutts> alpha123: maybe so, but I think that programming is necessarily abstract
12:36:48 <merijn> alpha123: Haskell just forces you to realise this fact more than other languages
12:37:00 <clahey> edwardk, So, I'm still reeling a little from the partial monad, but working on it.
12:37:33 <edwardk> alpha123: i wrote haskell because it _enables_ me to abstract more than other languages. in haskell the general solution is often the fastest and easiest to prove correct.
12:37:47 <edwardk> so the more abstract the better!
12:37:49 <dmwit> clahey: partial monad is [()], except you replace the final [] signifier with a value
12:37:58 <alpha123> merijn: That is definitely true, I ended up realizing it with Lisp and that's helped a lot with Haskell so far. Dropping it on people immediately may make learning harder though
12:38:03 <clahey> dmwit, Right, I figured it was something like that.
12:38:06 <edwardk> you can also view it as 'Free Identity'
12:38:46 <clahey> My browser crashed, so it's going to take me a sec to look up what an IVar is.
12:38:48 <b2coutts> scheme is how I initially learned functional programming as well
12:39:03 <stevejb> hello, I have a quick question. I have some code which calls a C function which occasionally fails. I have a "backup" Haskell function which is slower but will never fail. Is there a notion of trying the C version first, catching a possible exception, and calling the haskell function if the C one fails?
12:39:15 <b2coutts> thus, I suppose I can't really give a first-hand account of how good haskell is for teaching FP in the first place, but LYAH seemed like a perfectly reasonable introduction to FP when I read through it
12:39:32 <dmwit> ivar = data-flow friendly thunk
12:39:43 <clahey> I see it now.
12:40:02 <b2coutts> but scheme may be a better introduction due to the fact that it's probably easier for imperative programmers to learn
12:40:13 <dmwit> stevejb: Sure, see the amb package.
12:40:19 <stevejb> dmwit: thanks!
12:40:31 <merijn> stevejb: Wrap the C function so that it returns a Maybe, then use "fromMaybe (expensiveHaskellFunction) cResult"?
12:40:34 <dmwit> stevejb: ...I actually meant "unamb".
12:40:39 <b2coutts> also I like scheme anyway, and would recommend it to anyone
12:40:46 <dmwit> stevejb: http://hackage.haskell.org/packages/archive/unamb/latest/doc/html/Data-Unamb.html#v:race
12:41:03 <dmwit> But I guess what merijn is saying is actually closer to what you asked.
12:41:12 <JoergFritsch> why does this give an error instead of a sum?
12:41:13 <JoergFritsch> map (+) (map (\(x,y) -> ((x+y)*6)) [ (x,y) | x <- [1..100], y <- [2..7] ])
12:41:15 <clahey> edwardk, So, IVar.  I would do tryRead on an ivar and if it fails, calculate the next deeper level and write it if it matches?
12:41:31 <stevejb> dmwit: merijn: thank you!
12:41:33 <dmwit> JoergFritsch: Let's answer a simpler question. What type does "map (+) [0]" have?
12:41:35 <merijn> b2coutts: Having TA'ed ocaml is a first functional language, people will do ridiculous things regardless of language, and ocaml actually ran into a lot of beginner issues we wouldn't ave had in Haskell
12:41:36 <edwardk> basically
12:41:47 <edwardk> it'd be an imperative mess, but it'd work
12:42:08 <b2coutts> merijn: I haven't actually learned ocaml; one of the many things I've been meaning to do
12:42:22 <merijn> b2coutts: Neither have I! :p
12:42:27 <b2coutts> haha
12:42:31 <JoergFritsch> dmwit: I do not understand where the zero would come from.
12:42:38 <clahey> edwardk, That's one reason I'm thinking of just going with an imperative data structure since I'm gonna have to make it an imperative mess anyway.
12:42:39 <dmwit> JoergFritsch: It came from my mind.
12:43:41 <arkeet> JoergFritsch: the inner map is fine, it gives a list of numbers.
12:44:06 <arkeet> dmwit is therefore asking you about map (+) (a list of numbers)
12:44:06 <JoergFritsch> arkeet: yes, but I need the sum of all those numbers.
12:44:13 <arkeet> [0] is a list of numbers.
12:44:39 <boothead> does anyone have a canonical example of folding a series of events into a base state object. Is this what Endo is for?
12:44:55 <merijn> uh-oh, suspicion time
12:45:03 <JoergFritsch> arkeet: so I would need to write map (+) [inner map] ?
12:45:07 <arkeet> no
12:45:14 <merijn> My code compiles with Rank2Types, but not without and I don't know why >.>
12:45:18 <haskellnoobee> hello, I have newbie question: I'm trying to perform IO, and return something like this: IO [FilePath] -> [FilePath], how could I do that?
12:45:20 <arkeet> JoergFritsch: hint: map (+) doesn't sum anything
12:45:29 <arkeet> think about the types.
12:45:31 <merijn> haskellnoobee: You can't and probably don't want that
12:45:57 <dmwit> ?where faq
12:45:57 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
12:46:14 <arkeet> haskellnoobee: http://www.haskell.org/haskellwiki/Introduction_to_IO
12:46:15 <haskellnoobee> merijin: I'm getting a list of files, in a way I need to perform IO to obtain those
12:46:28 <arkeet> or see the IO chapter in LYAH
12:46:35 <geekosaur> JoergFritsch, look carefully at the type of map. it tells you what you can do with the mapping function. and, more to the point, what you can't do with it.
12:46:43 <merijn> haskellnoobee: You probably want to use either do-notation and/or fmap, see the links mentioned above
12:46:46 <dmwit> haskellnoobee: http://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
12:47:01 <Adeon> you get the [FilePath] out of IO by binding in the IO monad, read the details from the above links that you are bombarded with
12:47:03 <quchen> IO is like the Borg. Everything that touches the Borg becomes a Borg. Resistance is futile.
12:47:16 <merijn> @quote shachaf ls
12:47:16 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
12:47:45 <JoergFritsch> geekosaur: could I not just add a ::INT somewhere :D ?
12:47:57 <arkeet> JoergFritsch: no
12:48:10 <arkeet> map doesn't do what you want to do
12:48:11 <geekosaur> (a) you seem to have missed the point (b) not unless you rewrote map yourself.
12:48:17 <dmwit> haskellnoobee: My personal favorite answer to this is: instead of turning your IO [FilePath] into a [FilePath], teach your consumer that expects a [FilePath] how to work with an IO [FilePath].
12:48:26 <geekosaur> and, as a hint, what you would end up with is not map. it'd be something else in the standard library
12:48:50 <geekosaur> :t map
12:48:51 <lambdabot> (a -> b) -> [a] -> [b]
12:48:55 <arkeet> map applies a function to each element of the list separately.
12:49:00 <haskellnoobee> dmwit: ok I'll check where it needs to be called
12:49:15 <haskellnoobee> thanks all
12:49:34 <arkeet> the function never can "see" more than one element at once.
12:49:56 <geekosaur> JoergFritsch, the only thing a function with that type can do is apply the a->b to each a in [a], producing a b which is put into [b]. nothing else. it can't see other elements of [a] or of [b], nor can it use an accumulator
12:50:07 <haskellnoobee> it's somehow more friendly than the compiler messages
12:50:13 <JoergFritsch> arkeet: understand. but what would be the rightway to create the sum?
12:50:29 <arkeet> JoergFritsch: well, there's a Prelude function called 'sum'
12:50:44 <arkeet> but more generally, if you want to combine elements of a list together, you'd use a fold
12:50:58 <arkeet> like foldl' or foldr
12:51:00 * quchen thinks explicit recusion might be easier for a newcomer
12:51:02 <JoergFritsch> arkeet: unbelieveable!
12:51:07 <arkeet> or, you can use explicit recursion.
12:51:13 <arkeet> and you should definitely understand how to.
12:51:32 <merijn> It feels like there should be a nicer way to do: "    do { rest <- get; start <- if BS.null rest then return rest else act}"
12:52:19 <arkeet> (base case: what's the sum of the empty list? recursive step: given the sum of some list (which we'll call xs), what's the sum of x:xs ?)
12:52:41 <dmwit> merijn: add a clause to act saying act "" = return ""; then get >>= act
12:53:12 <arkeet> dmwit: that's just moving the nonniceness into act ;)
12:53:47 <quchen> merijn's function looks like whenM. (I don't know whether that exists, but that's probably how it would be called.)
12:53:47 <dmwit> Yes, but it's a prettier non-niceness.
12:53:51 <edwardk> arkeet: yes, but the combinator style reads much nicer
12:53:52 <quchen> Or ifM.
12:53:54 <arkeet> :)
12:54:04 <merijn> quchen: Yes, hence my earlier question about when :p
12:54:19 <merijn> Actually, that's plain wrong
12:54:20 <arkeet> depends on whether act is something you wrote.
12:54:33 <merijn> "act "" = return """ <- huh?
12:54:55 <arkeet> act x = if BS.null x then return x else ...
12:55:02 <dmwit> arkeet: noooo
12:55:06 <arkeet> ??
12:55:07 <dmwit> then it's the same ugly non-niceness
12:55:14 <arkeet> dmwit: act doesn't take an argument.
12:55:24 <dmwit> oh bugger
12:55:24 <arkeet> unless it does.
12:55:50 <arkeet> I just noticed that too.
12:55:58 <merijn> It doesn't
12:55:59 <arkeet> merijn: right?
12:55:59 <JoergFritsch> arkeet: in fact I am looking for a translation of this http://pastebin.com/bXiZNCn2 into haskell. I am struggling w the result part.
12:56:01 <mauke> The paste bXiZNCn2 has been copied to http://lpaste.net/91696
12:56:10 <quchen> merijn: The package that defines them (whenM, ifM etc)contains Unicode and since I'm on a rebellion I will not endorse it.
12:56:12 <johnw> is Oleg's extensible exceptions library on Hackage yet?
12:56:30 <johnw> sorry, extensible effects
12:56:31 <merijn> arkeet: Basically, I have a StateT ByteString and want to use any leftovers if they exist, else use hGet to get a new bytestring
12:56:51 <edwardk> johnw: he doesn't tend to hackage things
12:56:54 <danharaj> johnw: Please don't use that in production code :P
12:56:57 <edwardk> other people tend to talk to him and hackage his code
12:57:03 <johnw> danharaj: why not?
12:57:11 <johnw> it looked good from the paper
12:57:16 <johnw> i want to give it a spin
12:57:22 <danharaj> because if I wanted to use your library and any libraries that use mtl I would be fucked.
12:57:26 <danharaj> And I would curse your name.
12:57:37 <quchen> @quote kmc generically -- :-)
12:57:37 <lambdabot> Plugin `quote' failed with: user error (parseRegex for Text.Regex.TDFA.String failed:"generically -- :-)" (line 1, column 18):
12:57:37 <lambdabot> unexpected ')'
12:57:37 <lambdabot> expecting empty () or anchor ^ or $, an atom, "|" or end of input)
12:57:44 <quchen> @quote kmc generically
12:57:44 <lambdabot> kmc says: Haskell is a language where the community observes that there are 50 incompatible error handling monads, and the response is 50 incompatible packages for generically handling all error
12:57:44 <lambdabot> handling monads
12:57:44 <edwardk> johnw: Codensity (Free f)   -- then bury your effects in f using prisms or ala carte. same diff
12:57:50 <edwardk> johnw: no fancy package needed
12:58:02 <edwardk> but then you have to write all the interpreters that the mtl gives you for free
12:58:25 <edwardk> the mtl is both a system for composing effects and for composing the interpreters for those effects
12:58:50 <edwardk> the lawvere theory approach just gets you the description of the effects in a semantic domain that is 'too big' and then relies on you to supply an interpreter
12:58:57 <danharaj> edwardk: I wonder if you can compose interpreters using finally tagless style + constraint kinds + indexed monads?
12:59:21 <edwardk> danharaj: its all the same thing, the latter 2 add nothing here
12:59:31 <danharaj> hrm
12:59:32 <johnw> edwardk: do you have an example of combining effects using Codensity (Free f) somewhere?
12:59:33 <edwardk> the former just makes you grab for a dictionary
12:59:41 <arkeet> merijn: I can't think of anything nicer. :(
12:59:59 <edwardk> johnw: just use prisms for the different 'base' monads for the systems of effects you want
13:00:14 <johnw> I don't know enough about prisms yet to know what that statement means
13:00:18 <danharaj> edwardk: mayhaps one can write a dictionary for composing interpreters.
13:00:30 <edwardk> but Codensity (Free f) is exactly what oleg's trick is
13:00:40 <edwardk> a prism is just a first class constructor
13:00:50 <carter> what are some good examples of type classes that use mutual recursive default values for both functions and types?
13:01:07 <carter> and where a valid instance will need to override some of those to break the loop?
13:01:18 <johnw> edwardk: do you have a code example of such prism use?
13:01:26 <merijn> arkeet: Sad times :(
13:01:36 <edwardk> danharaj: we have one, its called the mtl. the problem with the lawvere theory approach is it breaks down when you want to work with a monad that needs polymorphic recursion to be efficient (e.g. scope from bound) and generally only does half the job
13:01:44 <danharaj> ah
13:01:44 <dmwit> carter: mutually recursive default values for types?
13:01:46 <edwardk> johnw: lets write one now
13:01:48 <carter> yes
13:01:49 <carter> like
13:01:55 <johnw> edwardk: K!
13:02:02 <danharaj> edwardk: is that the same thing that makes constrainted monads naively fail?
13:02:06 <danharaj> constrained*
13:02:07 <carter> isn't there some example stuff for the AMP proposal
13:02:10 <monochrom> carter: I only know mutual recursive default values for functions, and it's Eq
13:02:12 <carter> and then you need to define at least one of them
13:02:28 <dmwit> carter: What is a default value for a type?
13:02:38 <quchen> carter: That's not "type-recursive". m >>= f = join (fmap f m); join = (>>= id)
13:02:44 <edwardk> danharaj: well, constrained monads just expose lots of gory details about what values you smash in in the meantim so there cease to be canonical definitions for most useful combinators for them
13:02:58 <edwardk> here we just wind up with a case where codensity doesn't quite fit the domain
13:02:59 <carter> dmwit monochrom : lemme gist an example of what i want to do
13:05:15 <clahey> edwardk, dmwit: Thanks for the help.
13:06:12 <carter> rhmmmm
13:06:25 <clahey> dmwit, What was the paper about infinite kd trees you mentioned?
13:06:30 <dmwit> monochrom: Ord, too, right? And there's that fun one with things going funky if you use instance Functor ... where fmap = fmapDefault but implement the wrong Foldable method or something like that.
13:06:33 <clahey> dmwit, wikipedia only seems to mention finite ones.
13:06:38 <dmwit> clahey: Didn't mention a paper.
13:06:38 <carter> ok, nevermind
13:06:40 <monochrom> Ord too, there are others
13:06:44 <hpaste> pxqr pasted “forkIO & killThread with -O2” at http://lpaste.net/91697
13:06:48 <clahey> dmwit, There was some source you mentioned, right?
13:06:54 <pxqr> that's kinda strange
13:07:20 <dmwit> clahey: nope, but you might like to look at conal's stuff on infinite 3d tessellations for doing FRP-style OpenGL stuff
13:07:40 <dmwit> I don't think he was using kd-trees for that, though
13:07:55 <monochrom> to obtain mutual recursion in default types, first you need to get support for default types, then you need to use it in type families
13:07:57 <c_wraith> pxqr: I'm pretty sure exactly 0 of those threads are actually getting killed
13:08:14 <clahey> Is there a web log of this channel?
13:08:33 <pxqr> c_wraith: yeah, but how does this explain the difference?
13:08:42 <dmwit> clahey: see /topic
13:09:17 <pxqr> btw, does thread pool makes some sense in context of ghc threads?
13:09:27 <tikhon> clahey: see ircbrowse.net for a nice interface to the logs
13:09:57 <dmwit> pxqr: GHC capabilities already keep thread pools.
13:10:22 <dmwit> (For OS threads, not Haskell threads.)
13:10:48 <clahey> "12:05:38 <dmwit> clahey: And the Dr Dobbs article on "An Algorithm For Compressing Space And Time" or something like that."
13:10:52 <c_wraith> pxqr: I'm not sure that difference is really indicative of anything.  I suspect it's got more to do with scheduling variance than the -O2 flag
13:10:52 <clahey> dmwit, That was the one I meant.
13:10:54 <clahey> No big deal.
13:10:55 <pxqr> dmwit: I did mean haskell threads. seems like one fork cost is about 500 clocks.
13:11:00 <clahey> Anyway, I have to go for a while.
13:11:04 <clahey> Back later.
13:11:05 <dmwit> clahey: aaah, yeah, no infinite trees in there, either
13:11:34 <dmwit> Infinite structures are more painful in strict languages. =)
13:11:57 <clahey> dmwit, So how do you make it infinite?
13:12:18 <dmwit> In Haskell? Plain old base-case-less recursion.
13:12:19 <clahey> Have a parent node for your tree that you leave uncomputed?
13:12:51 <clahey> I get how it's infinite in getting smaller.  Just not sure how it would get bigger.
13:13:06 <edwardk> johnw: anyways lets get started:
13:13:07 <dmwit> Oh, yeah, you need to decide on an upper bound.
13:13:09 <edwardk> class AsState s f | f -> s where _State :: Prism' (f a) (s -> (a, s))
13:13:22 <clahey> dmwit, Ah, I thought you meant infinite going up.
13:13:22 <edwardk> that gets you a prism that can view the state portion of your effects
13:13:34 <dmwit> All the interesting bits of Mandelbrot are in the (-2,2) and (-2i,2i) range, for example.
13:13:39 <clahey> dmwit, it's true.
13:13:43 <edwardk> instance AsState s (State s) where _State = iso runState state
13:13:45 <clahey> dmwit, I just didn't understand what you meant by infinite.
13:13:46 <johnw> edwardk: and where "f" is the effects container?
13:13:50 <edwardk> yeah
13:13:50 <dmwit> clahey: Ah, sorry.
13:14:04 <edwardk> now we could go and define an instance of MonadState
13:14:06 <clahey> dmwit, I think I'm so used to haskell that infinite downward is simply obvious.  :)
13:14:12 <dmwit> \o/
13:14:13 <clahey> Anyway, I have to run for a while.  ttyas.
13:14:14 <edwardk> instance AsState s f => MonadState s (Free f) where state f = lift (_State # f)
13:14:30 <edwardk> (assuming that Free f didn't have the other MonadState instance it already does
13:14:38 <edwardk> we can repeat for other monads
13:15:30 <johnw> to use it then, I just have a constraint like : foo :: (Monad m, AsState Int m, AsState Float m) => m (Int, Float); foo = do { x <- get; y <- get; return (x, y) }?
13:15:33 <edwardk> now you can make up your composite ball of effects, call that 'f', manually make your instances defining the injection of state actions, etc. into it and then manually write your interpreter at the end...
13:15:43 <edwardk> but that it a help of a lot of work compared to the mtl
13:16:11 <edwardk> now, using the ala carte approach you get a 'stack' of effects by putting them in order so that runState can 'simplify the effect list'.. but this is just what the mtl does
13:16:47 <edwardk> no power has been gained moving to that formalism
13:17:59 <edwardk> lawvere theories/ala carte approaches make you lean on an ugly tool (OverlappingInstances) for no theoretical or practical gain
13:18:35 <edwardk> the thing you get is that you wind up storing details the interpreters would otherwise quotient out … until the interpreter comes along and would quotient it out later
13:19:49 <edwardk> in the end you wind up taking the monad and running it.. and if you expand out all the runFoo signatures in the end, and look at what you get… its the monad transformer
13:21:09 <edwardk> runState :: Typeable s => Eff (State s :> r) w -> s -> Eff r (w, s)
13:21:35 <johnw> :>?
13:21:54 <edwardk> State . runState :: Eff (State s :> r) a -> StateT (Eff r) a
13:22:19 <edwardk> the only thing you gained was uncertainty about what evaluator you were going to get
13:23:01 <edwardk> if i have StateT s (Either e) a  i can tell you that the state doesn't 'survive' an error, but that in EitherT e (State s a)  it does.
13:23:18 <edwardk> if I ave Eff (State s :> Either e :> Nil) a i have no idea.
13:23:32 <apples`> hey, i'm running into an issue with mueval, is this the right place to ask or should i email the author? :)
13:23:39 <edwardk> the ordering there is free, but i can commute it before i go to evaluate it
13:24:14 <edwardk> so it might or might not survive backtracking,.. the type tells me less about my effects than what i knew before with the monad transformer version
13:24:14 <johnw> interesting
13:24:32 <merijn> apples`: You can always ask, no guarantees about answers though :
13:25:09 <edwardk> and i've lost the flexibility of CPSing or not. i'm doomed to always CPS, so if you use the result multiple times you're screwed and have to recompute it over and over.
13:25:13 <edwardk> from scratch
13:25:35 <edwardk> there is a lot of 'bad' in this codensity (free f) approach
13:25:50 <johnw> so in the end, the best answer is just to stick with mtl?
13:25:53 * arkeet should try to understand Codensity at some point
13:25:55 <edwardk> and literally nothing gained other than uncertainty about which interpreter will screw with me later
13:26:10 <edwardk> that is my answer
13:26:13 <merijn> arkeet: High five!
13:26:18 <merijn> arkeet: Me too :p
13:26:19 <zomg> Whenever you talk about CPS it makes me want to fire up MAME and play CPS-1 and CPS-2 games =)
13:26:22 <merijn> An yoneda/coyoneda
13:26:28 <johnw> arkeet: it's a lot like Yoneda, but for Kleisli arrows a -> m b instead of arrows a -> b
13:26:28 <arkeet> zomg: =)
13:26:39 <johnw> edwardk: ok, fair enough
13:27:09 * arkeet compares definitions
13:27:13 <edwardk> i figure someone has to stand up and say 'this is a bad idea' or it being oleg will cause a ton of people to charge in that direction heedlessly =P
13:27:25 <edwardk> and we'll be in iteratee land all over again =)
13:27:31 <johnw> haha
13:27:39 <johnw> yes, I did get momentarily excited about it last night
13:27:46 <dolio> arkeet: There was a decent writeup of codensity on n-category cafe not long ago, from the categorical perspective.
13:27:57 <johnw> but it being oleg usually means to me: wait until someone else comes up with a better implementation
13:28:16 <edwardk> ultimately it comes down to the fact that there may not actually be an interpreter for that coproduct of effects that is sound
13:28:24 <arkeet> dolio: "Where do monads come from?"?
13:28:34 <dolio> Maybe.
13:28:45 <edwardk> consider Eff (ST s :> IO :> STM :> Nil) a  -- now run it
13:28:47 <Gracenotes> Are there monads hiding under my bed?
13:28:52 <arkeet> it claims to explain codensity, so I'm guessing so.
13:29:03 <dolio> It talked about how it's equivalent to G F when you have F -| G, but it also creates monads when such an adjunction doesn't exist.
13:29:44 <edwardk> dolio: sounds like a much more theoretical version of the crap i always talk about =)
13:29:59 <Gracenotes> it seems like yoneda is more operationally useful, in the cases that it is
13:30:03 <arkeet> http://golem.ph.utexas.edu/category/2012/09/where_do_monads_come_from.html
13:30:12 <flux0r> edwardk: does your machines package solve some of the same problems that iteratees aim at?
13:30:21 <apples`> i'm trying to execute mueval --expression '1*100+1', but i just get "Could not find module `ShowQ'", and i'm not sure if there's a package i'm missing or what
13:30:24 <c_wraith> yeah, machines is in that space
13:30:36 <dmwit> Oh, wait, all this effect stuff recently isn't people just rediscovering http://math.andrej.com/eff/?
13:30:41 <Guest76594> If someone has a free moment, can you help me with http://ypaste.com/9292/
13:30:42 <c_wraith> But it's a couple conceptual generations away from iteratee
13:30:46 <edwardk> Gracenotes: yoneda gives you 'fmap fusion' codensity gives you 'bind fusion'. the former requires you to round trip through the monad a lot, but in codensity you don't do any 'administrative' traversals of the monad, and all your binds are reassociated to the right
13:31:05 <edwardk> this means that if you have a non-associative but otherwise correct monad, you can use Codensity m   to turn it into a real monad!
13:31:25 <stevejb> dmwit: I am looking at the unamb package a bit. I am having trouble seeing how it fits in with what I am trying to do
13:31:40 <dmwit> stevejb: Yes, merijn's suggestion was much better.
13:31:44 <edwardk> dmwit: its more people discovering the same ideas though
13:31:57 <flux0r> c_wraith: cool...is the best way to learn how they work just writing some simple programs that can read from file handles?
13:32:05 <edwardk> dmwit: every time i turn around someone is talking about lawvere theories and then trying to hold them up as a replacement for the mtl
13:32:13 <dmwit> stevejb: You can sort of cram things into "race" but it's probably not worth it.
13:32:27 <dmwit> stevejb: (By making your C function non-terminate when it fails.)
13:32:36 <dolio> edwardk: Yeah, I liked it because it was kind of the theoretical justification for Codensity having a monad instance regardless of what you put in for f.
13:32:38 <edwardk> that is me admittedly stealing a line from dolio the other day
13:32:49 <stevejb> dmwit: thanks. I am trying to figure out merijn's comment now
13:32:49 <edwardk> dolio: link?
13:32:58 <stevejb> the thing is, it isn't *my* C function
13:33:02 <dolio> It's the one arkeet linked to 3 minutes ago.
13:33:04 <stevejb> so, I can't control how it fails
13:33:08 <merijn> stevejb: I assume it returns an error code?
13:33:15 <dmwit> stevejb: Well, you can non-terminate in Haskell land when it fails. =)
13:33:18 <edwardk> oh i remember it now
13:33:28 <dmwit> forever (threadDelay 1e6)
13:33:35 <dmwit> or even maxBound =)
13:33:37 <hiptobecubic> quchen, ran for a few hours. still no <loop> ;)
13:33:41 <merijn> stevejb: Take a look at: https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L188
13:33:51 <merijn> stevejb: Except return Maybe instead of throwing an exception
13:34:02 <merijn> dmwit: Pro-tip, avoid "threadDelay maxBound" for now :)
13:34:16 <dolio> edwardk, dmwit: That's not quite what I said.
13:34:21 <merijn> dmwit: It will crash your program on many architecture/OS combo's and only works on linux by accident
13:34:22 <stevejb> I get something like: gsl: qags.c:548: ERROR: cannot reach tolerance because of roundoff error. Default GSL error handler invoked. Process haskell aborted
13:34:22 <stevejb>  
13:34:37 <stevejb> merijn: thanks
13:34:43 <quchen> hiptobecubic: ♥
13:34:48 <dolio> My point was, people always have 'alternatives to monad transformers.' But what they propose is equivalent to using the classes in the mtl.
13:35:01 <quchen> hiptobecubic: I should have my Raspi try, it's idle most of the time, and it's running 7.4.2
13:35:19 <dolio> They always forget about those and focus on monad transformers, which give you something that you don't get in their stuff.
13:35:50 <dmwit> stevejb: Well, you're going to have to find a way to catch that error, either in C or in Haskell, for *any* approach to work. Is your question about how to catch errors?
13:36:11 <hpc> i have found an alternative to transformers! http://hackage.haskell.org/package/decepticons
13:36:15 <edwardk> basically the design trade-off is that they get to write the 'how they commute over other transformers' part once and for all.. for most of the boring commutative monad transformers, but in exchange you have to work in a world that is too big
13:36:40 <edwardk> the lure is the appearance that it lets you avoid having to write O(n^2) instances.
13:36:48 <edwardk> fortunately n is something like 9 so thats not so bad in practice ;)
13:37:11 <c_wraith> I was surprised recently to learn that Ix doesn't have instances for 5-tuples and up.
13:37:14 <hpc> edwardk: mtl is webscale?
13:37:17 <c_wraith> Someone got lazy writing instances!
13:37:26 <stevejb> dmwit: yeah that is my question is how to catch that error and then wrap it in a maybe
13:37:37 <dmwit> Oh, then I have no idea.
13:37:45 <hpc> c_wraith: someone got /nonstrict/
13:37:47 <merijn> stevejb: Looks like a different problem, looks like your library is just killing your entire process
13:37:57 <dmwit> At a guess you'll have to hack on some C a bit.
13:38:24 <dmwit> But I don't know and at the moment don't really want to find out. =P
13:38:27 <stevejb> merijn: so, this is called from the hmatrix haskell package, which is calling c
13:38:28 <merijn> stevejb, dmwit: Looks like he has to install a C error handler somehow, which is really more of a library question
13:38:56 * dmwit covers his ears
13:39:01 <dmwit> merijn: I can't hear you LALALALALA
13:39:18 <edwardk> carter: around?
13:39:29 <stevejb> so, I guess it is a Haskell function that is calling a C function, so I assume just need to wrap the haskell function
13:39:48 <carter> edwardk yes
13:41:07 <carter> edwardk whats up
13:41:48 <edwardk> carter: up for phone chat?
13:41:52 <carter> sure
13:42:05 <carter> coding productively for the first time in a week
13:42:07 <carter> but bring it :)
13:42:12 <carter> breaks are good sometimes
13:44:42 <Peaker> I avoid the O(N^2) instances by writing a couple of lifters declarations for each of my monad stacks
13:45:50 <Peaker> (always using transformers, and not mtl)
13:47:20 <Peaker> It is sometimes annoying to have to do something like:  (mapSomeTrans . mapWriterT . mapMaybeT . Reader.local) ...    instead of just "Reader.local"
13:55:08 <merijn> dmwit: Nothing is more fun than trying to find the origin in that bug when "main = threadDelay maxBound" crashes your program :p
14:02:36 <joelteon> if I want to parse a file that represents a game replay and get an arbitrary long list of actions out of it, should I use a plain list or a free monad?
14:02:46 <joelteon> for the representation of the resultant data
14:02:59 <arkeet> if you want a list of actions, it sounds like you want a list of actions.
14:03:18 <dmwit> This helpful advice brought to you by the one and only ARKEET!
14:03:26 <joelteon> good idea
14:03:27 <arkeet> =)
14:03:31 <joelteon> why didn't I think of that?
14:03:32 <dmwit> ...but I agree with him. arkeet++
14:05:16 <monochrom> begin with a list. later, change it to something optimized for your actual use. but it is still a list in your mental model, just not in code.
14:06:06 <monochrom> programmers erase their mental models too soon.
14:06:23 <tromp_> see http://homepages.cwi.nl/~tromp/go/SimpleGo.hs for an example of processing Go moves in a state monad
14:11:21 <dmwit> > foldr f z [a,b,c]
14:11:22 <lambdabot>   Ambiguous occurrence `f'
14:11:22 <lambdabot>  It could refer to either `L.f', defined at L.hs:1...
14:11:31 <dmwit> > foldr g z [a,b,c]
14:11:32 <lambdabot>   g a (g b (g c z))
14:12:00 <monochrom> @type L.f
14:12:01 <lambdabot> (Eq a, Eq a1, Num a, Num a1) => a -> a1 -> [Char]
14:12:18 <arkeet> > L.f 2 3
14:12:22 <lambdabot>   "*Exception: L.hs:(143,1)-(144,11): Non-exhaustive patterns in function f
14:12:25 <arkeet> > L.f x y
14:12:29 <lambdabot>   mueval-core: Time limit exceeded
14:12:34 <arkeet> we'll never know!
14:12:46 <joelteon> @src L.f
14:12:46 <lambdabot> Source not found.
14:12:50 <pentace> > L.f 0 0
14:12:53 <lambdabot>   "*Exception: L.hs:(143,1)-(144,11): Non-exhaustive patterns in function f
14:12:58 <joelteon> what does L.f do?
14:13:01 <arkeet> we'll never know!
14:13:08 <monochrom> God and elliott know
14:13:14 <joelteon> which is which
14:13:24 <monochrom> (because elliott can read that file)
14:13:41 <b2coutts> :t L.f
14:13:42 <lambdabot> (Eq a, Eq a1, Num a, Num a1) => a -> a1 -> [Char]
14:13:57 <b2coutts> haha
14:14:34 <geekosaur> [09 14:54] <chrisdone> @let f 1 2 = "A"; f 1 3 = "B"
14:14:38 <dmwit> Oh, interesting. data X = A X | B X is not the same as data Tag = A | B; data Y = Cons Tag Y.
14:14:45 <arkeet> @let instance Num () where _ + _ = (); negate _ = (); _ * _ = (); abs _ = (); fromInteger _ = (); signum _ = ()
14:14:46 <lambdabot>  Defined.
14:14:48 <arkeet> > L.f () ()
14:14:51 <lambdabot>   "A"
14:14:53 <arkeet> HMM
14:14:57 <b2coutts> oh
14:14:59 <arkeet> oh I see.
14:15:01 <joelteon> what the hell
14:15:14 <b2coutts> well that's disappointing
14:15:17 <arkeet> dmwit: does that surprise you?
14:15:36 <dmwit> Well, a bit. I would think they were pretty interchangeable. But they're very not.
14:16:06 <dmwit> So, related question: is there a good lazy binary natural number package on Hackage?
14:16:07 <arkeet> well, X and Y should be the same besides bottom.
14:16:33 <monochrom> perhaps "data Z = ConsZ !Tag Z" is closer to X
14:16:37 <dmwit> arkeet: Right, but in this case, bottom-ness is exactly where the interesting difference lies.
14:16:42 <dmwit> monochrom: indeed
14:16:53 <elliott> oh, I thought dmwit meant operationally.
14:18:01 <dmwit> (In particular: for the "nat" package this difference means you can't tell whether a number is bigger or smaller than 2 until you've learned whether it's odd or even. This sucks.)
14:18:42 <dmwit> (...because, practically speaking, that makes it a strict nat package.)
14:27:53 <evan__> @type map
14:27:54 <lambdabot> (a -> b) -> [a] -> [b]
14:28:25 <quchen_> We've recently talked about fairness and STM here. I've got a somewhat related problem now, and it boils down to this: When I have multiple threads waiting to read a TChan and one attempts to do so because data becomes available, will it somehow be placed at the end of the queue to try again?
14:28:49 <quchen_> Am I mistaking this for "not fairness" when it actually is?  (Not sure how to express my gut feeling here)
14:29:17 <quchen_> Maybe I should call it common-sense-STM fairness, seeing that STM has no theoretical fairness guarantees
14:31:23 <dmwit> quchen_: I think all readers get woken up when the data becomes available.
14:31:37 <dmwit> So it's a race.
14:31:48 <dmwit> nota bene: *I think*
14:32:02 <quchen_> dmwit: Hm, so I should assume it's completely indeterminate?
14:33:28 <dmwit> I think that's pretty much right, yeah.
14:33:55 <Saizan> i'm pretty sure there's a queue actually
14:34:16 <dmwit> MVars have a queue.
14:34:17 <johnw> is there such a thing as stochastic fairness? :)
14:34:22 <dmwit> TVars it's not so clear to me.
14:34:32 <dmwit> I mean, what is (<|>) supposed to mean...?
14:35:22 <Saizan> i guess it makes sense to wake every reader for TVars because of "optimism"
14:45:36 <S11001001> > (3::Word8) - 1
14:45:37 <lambdabot>   2
14:45:49 <S11001001> > [0 .. (3::Word8) - 1]
14:45:50 <lambdabot>   [0,1,2]
14:49:32 <bscarlet> > [(0::Word8), 100 .. 300 ]
14:49:33 <lambdabot>   [0]
14:49:51 <bscarlet> > [ 0, 100 .. 300 ]
14:49:54 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
14:50:20 <bscarlet> > [ 0, 2 .. 10 ]
14:50:22 <arkeet> oops
14:50:23 <Fuuzetsu> huh
14:50:24 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
14:50:27 <arkeet> @undefine
14:50:27 <lambdabot> Undefined.
14:50:36 <arkeet> try again
14:50:44 <arkeet> my fault for defining a Num () instance
14:50:47 <bscarlet> > [0, 2 .. 10 ]
14:50:48 <lambdabot>   [0,2,4,6,8,10]
14:50:55 <bscarlet> > [0, 100 .. 300 ]
14:50:56 <lambdabot>   [0,100,200,300]
14:51:15 <bscarlet> > [ (0::Word8), 100 .. 300 ]
14:51:16 <lambdabot>   [0]
14:51:24 <arkeet> because 300 < 100.
14:51:27 <bscarlet> yep
14:51:54 <elliott> haha, that defaulting.
14:51:54 <arkeet> yeah =)
14:51:54 <elliott> I don't understand though, shouldn't it pick Integer first?
14:52:18 <bscarlet> Did you define just the instance, or more that made it default?
14:52:30 <arkeet> I defined the instance. defaulting made it pick () first
14:53:06 <heath> where is the permutation function from Data.List located?
14:53:13 * heath is grepping within ghc and can't find it
14:53:23 <hpc> @hoogle permutation
14:53:23 <lambdabot> Data.List permutations :: [a] -> [[a]]
14:53:23 <lambdabot> package permutation
14:53:23 <lambdabot> package action-permutations
14:53:33 <heath> thanks hpc
14:54:18 <Clint> heath: i assume the answer you wanted is "base"
14:54:29 <bscarlet> Is it possible to cabal install in a way which won't break future cabal test?
14:54:42 <heath> Clint: not seeing a directory named base within the ghc source
14:54:53 * heath fetches action-permutations and greps from there
14:55:41 <Clint> heath: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#permutations
14:55:54 <heath> that works too
14:56:47 <Clint> that is, as you can see, from the "base" package
14:56:49 <S11001001> > iover itraversed (,) "abc"
14:56:50 <lambdabot>   [(0,'a'),(1,'b'),(2,'c')]
14:56:52 <heath> hrm, cabal-dev install action-permutations seems to install binaries
14:56:56 <heath> nothing i can grep around in
14:57:46 <heath> ah, this permutations implmentations is better than mine
14:57:58 <heath> s/implmentations/implementation
14:58:11 * heath gives up
14:58:54 * hackagebot htiled 0.1.1.1 - Import from the Tiled map editor.  http://hackage.haskell.org/package/htiled-0.1.1.1 (ChristianRoedliAmble)
14:59:49 <heath> it's odd it uses interleave which is from a graphics lib
14:59:51 <S11001001> @ty iover
14:59:52 <lambdabot> AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
14:59:54 <heath> @hoogle interleave
14:59:54 <lambdabot> package interleave
14:59:54 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays data InterleavedArrays
14:59:54 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays interleavedArrays :: InterleavedArrays -> Stride -> Ptr a -> IO ()
15:01:15 <S11001001> @ty iover itraversed
15:01:16 <lambdabot> TraversableWithIndex i t => (i -> a -> b) -> t a -> t b
15:01:39 <S11001001> @ty itraverseOf
15:03:48 <troydm> i've asked on #yesod but it seems no one can answer, probably channel is slow
15:04:05 <troydm> so i have this problem with yesod devel, when i run it i get ExitFailure 127
15:04:12 <troydm> anyone encountered this problem?
15:06:18 <johnw> troydm: that really gives me almost nothing to go on
15:07:14 <troydm> johnw: running it with yesod -v devel didn't give anything helpful tho
15:07:38 <troydm> johnw: it's like it's failing without saying why it failed
15:07:59 <johnw> it works when not using "devel"
15:08:09 <luite> troydm: what operating system / compiler?
15:09:06 <luite> troydm: does runghc exist in your path?
15:09:24 <troydm> luite: OpenIndiana ghc 7.4.2
15:09:38 <troydm> luite: yes, it does
15:09:49 <haskellnoobee> can anyone shed some light on  Filesystem.Path.CurrentOS  and System.FilePath, I'd like to use "combine" function and currently using FilePath from Filesystem.Path.CurrentOS
15:10:13 <troydm> luite: PATH is added in .profile
15:10:27 <Demos_> can you use </>?
15:10:31 <luite> troydm: does runghc somehaskellfile.hs actually work?
15:11:30 <troydm> luite: hmm, strange just trid runghc ./devel.hs and it started app
15:11:36 <luite> you might be the first person to try this on some opensolaris system :)
15:11:46 <haskellnoobee> Demos_: seems I could if I remove conflict with Shelly
15:12:19 <troydm> luite: yeah, well... OpenIndiana gives me headaches usually
15:12:35 <luite> troydm: does yesod -d devel work?
15:13:41 <troydm> luite: no...
15:14:35 <luite> troydm: same error?
15:14:47 <troydm> luite: it's obv has something to with PATH, yeah same error
15:15:07 <luite> troydm: ah it's really the runghc call that fails?
15:15:12 <Zenol> Hum, yesod html DSL doesn't prevent you from typing wrong html?
15:15:38 <merijn> troydm: What's the first line in devel.hs? (i.e. the shebang)
15:16:33 <troydm> merijn: devel.hs doesn't has shebang
15:16:42 <troydm> merijn: it's just yesod generated template
15:17:10 <merijn> hmmm
15:19:12 <luite> troydm: are you using hsenv or similar?
15:19:55 <troydm> luite: no
15:22:31 <edwardk> > iover itraversed (,) "abc"
15:22:32 <edwardk> > imap (,) "abc"
15:22:33 <luite> troydm: hmm, weird, 127 seems indeed a path error, is the new PATH exported?
15:22:33 <lambdabot>   [(0,'a'),(1,'b'),(2,'c')]
15:22:33 <lambdabot>   [(0,'a'),(1,'b'),(2,'c')]
15:23:04 <c_wraith> that was nearly a minute.  bit of lag there
15:24:07 <troydm> luite: yeah, otherwise running it with runghc wouldn't start it
15:24:45 <troydm> luite: but it seems like when i run yesod devel, it tries to runghc ./devel.hs itself but somehow path fails for it
15:26:22 <mjrosenb> hey, I had a coworker assert that the list fusion operations aren't actually that effective in practice.  Can anyone support/deny this assertion?
15:26:57 <luite> troydm: yeah, perhaps somethings wrong with the ghc libraries themselves
15:27:17 <c_wraith> mjrosenb: they're very effective - when they happen.  What they aren't is reliable.
15:27:27 <acowley> mjrosenb: I suppose you'd have to define "in practice". If someone here gives you an example where fusion matters, is that proof of use in practice?
15:27:44 <acowley> mjrosenb: I certainly rely on vector's fusion pieces in practice
15:27:45 <troydm> luite: not sure about libraries, maybe somthing related to forking and PATH propagation
15:28:19 <acowley> mjrosenb: Maybe try compiling some Haskell code you feel isn't a silly toy and seeing if those rules fire?
15:28:20 <luite> troydm: i meant the process library :)
15:28:38 <mjrosenb> c_wraith: acowley: so you have to write decently specialized code in order to take advantage of it?
15:28:43 <acowley> No
15:29:09 <troydm> luite: ohh
15:29:19 <troydm> luite: yeah, but not sure too
15:29:56 <luite> troydm: but that might not be right, can you run a few tests to check if other progs are in the path?
15:30:03 <luite> troydm: with runProcess
15:31:05 <troydm> luite: yeah, i'll try it
15:32:01 <luite> troydm: perhaps you can work around it by hardcoding the full path in the yesod executable
15:34:15 <troydm> luite: just tried this with env command http://www.haskell.org/haskellwiki/Running_processes_concurrently
15:34:26 <troydm> and it reports correct PATH and LD_LIBRARY_PATH
15:35:07 <troydm> luite: so basicly everything should work :(
15:35:13 <adnap> Linearly interpolating between -1 and infinity:
15:35:16 <adnap> > let t :: Float; t = 0; inf :: Float; inf = read "Infinity" in (1 - t) * (-1) + t * inf
15:35:17 <lambdabot>   NaN
15:35:55 <luite> troydm: hm, weird
15:36:49 <adnap> Should this have any meaning?
15:37:24 <hpaste> stevejb pasted “trying to figure out how to catch an exceptiopn” at http://lpaste.net/91699
15:38:14 <merijn> stevejb: If that's the example from earlier, are you sure it's throwing an exception?
15:38:24 <stevejb> merijn: perhaps I am saying it wrong
15:38:37 <stevejb> if you uncomment 42 and comment 43, it crashes
15:39:11 <stevejb> so, I guess not an exception in the formal sense
15:39:31 <adnap> >                 http://lpaste.net/91699
15:39:31 <lambdabot>   Not in scope: `http'Not in scope: `lpaste'
15:39:32 <lambdabot>  Perhaps you meant one of these:...
15:39:39 <adnap> Sorry
15:39:49 <adnap> > let inf :: Float; inf = read "Infinity"; interpolate :: Float -> Float -> Float -> Float; interpolate 0 r0 _ = r0; interpolate 1 _ r1 = r1; interpolate t r0 r1 = (1 - t) * r0 + t * r1 in interpolate 0 (-1) inf
15:39:50 <lambdabot>   -1.0
15:39:52 <stevejb> in any case, is there a way I can wrap quad so that I can catch the crash?
15:39:58 <adnap> Does this make sense?
15:40:07 <merijn> stevejb: If the GSL code is exiting your program, you can't
15:41:21 <stevejb> merijn: darn! Alright, I need to figure out something then
15:41:53 <troydm> luite: i think it's not related to yesod, when i run it with runghc with all package pathes provided just like yesod -v devel is doing it it fails without printing error message
15:42:00 <monochrom> but does GSL exit your program?
15:42:01 <stevejb> this quad function is part of hmatrix, whic calls the GSL stuff. So perhaps I need to go in there and modify the code
15:42:05 <troydm> luite: it seems one of the packages makes it fail
15:42:34 <stevejb> monochrom: I get something like: gsl: qags.c:548: ERROR: cannot reach tolerance because of roundoff error. Default GSL error handler invoked. Process haskell aborted
15:43:37 <geekosaur> that's C throwing an exception (but it's not a Haskell exception, and since C doesn't actually have exceptions, it's just calling exit()). You can't trap that from Haskell
15:43:51 <geekosaur> figure out how, if at all, GSL exceptions work
15:44:28 <stevejb> geekosaur: that makes sense. That way I can trap it in C and then detect the failure in haskell
15:44:40 <cschneid> when an exception gets raised in a thread, does that bubble out to the parent? or does it just silently kill the thread?
15:45:02 <merijn> Any good naming conventions for miscellaneous internal library bits that don't have a good home?
15:45:11 <merijn> .Internal? .Utils?
15:45:13 <geekosaur> except you can't "trap" it in C; every library has to provide its own exceptions and exception handling, and you'll have to figure out what GSL uses
15:45:20 <geekosaur> it's a pain.
15:45:59 <monochrom> Numeric.GSL has setErrorHandlerOff
15:46:22 <luite> troydm: does ghc-pkg check report any errors?
15:46:26 <monochrom> now you will get a haskell-side exception, but I don't know what it looks like
15:46:40 <stevejb> monochrom: checking that out now
15:46:50 <monochrom> also, more importantly, at what time
15:47:32 <stevejb> monochrom: where are you seeing this?
15:47:35 <troydm> luite: yeah, also i just recently reinstalled them
15:47:35 <isomorphismes> In implementing head', sum', length' in LYAH are there performance differences to the native sum, head, length? Or do Haskellers generally leave performance to the compiler? ("premature optimisation is the root of all evil")
15:48:00 <monochrom> bottom of http://hackage.haskell.org/packages/archive/hmatrix/0.15.0.0/doc/html/Numeric-GSL.html
15:48:30 <monochrom> unless you are using something other than hmatrix
15:48:45 <stevejb> no, this seems perfect
15:49:10 <stevejb> so, I just need to figure out Control.Exception ?
15:49:14 <c_wraith> isomorphismes: generally optimizations are left to libraries..  Until we see that they're not getting the job done.
15:49:27 <monochrom> now we have two problems
15:49:39 <isomorphismes> c_wraith: thanks
15:50:03 <monochrom> "I know, I will call setErrorHandlerOff". now we have two problems.
15:51:56 <roboguy_> is there an emacs extension that lets you see a list of all defined names in the current module (and maybe other modules) along with their types in a buffer?
15:52:34 <Iceland_jack> You can try C-h m
15:52:37 <monochrom> are you satisfied with plain ghci's ":browse ThatModule"?
15:52:58 <Iceland_jack> oh, sorry! misunderstood
15:53:16 * geekosaur kinda wishes haskell-mode supported speedbar...
15:53:20 <troydm> luite: funny, reinstalling all packages didn't solved the problem :(
15:53:32 <troydm> luite: now ghc-pkg check doesn't reports any problems
15:53:41 <troydm> luite: but i still get 127 error :(
15:53:57 <roboguy_> monochrom: well, it's so that I don't have to keep scrolling through the file I'm in to look at all the names. I guess that would sort of work, but I might as well scroll if I'm going to do that
15:54:23 <luite> troydm: hmm, perhaps you can narrow it down by removing some of the packages? does -v or -v9 help?
15:54:37 <luite> troydm: might be some external command that it runs
15:55:07 <monochrom> emacs haskell-mode also has an "Index" on the menu bar, it lists names, just not types
15:55:46 <monochrom> it seems to also let you jump to those names
15:57:05 <troydm> luite: runghc just successfully loads packages and without problem reports that it started the development server on 3000 port however than the executable itself quits and whole process exits because of that
15:57:14 <troydm> luite: also echo $? reports exit code is 0
15:57:24 <troydm> luite: but yesod devel reports it to be 127
15:57:27 <roboguy_> monochrom: hmm, I'm not sure I see that
15:57:28 <troydm> which is strange
15:58:18 <ReinH> oh hai
15:58:42 <c_wraith> troydm: yesod devel forks to run the process.  It's reporting the exit code from the subprocess
15:58:55 <c_wraith> troydm: echo $? is giving you the exit code from the parent
15:59:11 <troydm> c_wraith: it's suprocess is runghc *lots of packages* devel.hs right?
15:59:31 <c_wraith> I don't remember the details of the subprocess, actually. sorry.
15:59:35 <cl_away> dmwit, For what it's worth, I had read that article before and it absolutely did blow my mind.  I'm gonna reread it later.
16:01:34 <monochrom> roboguy_: http://www.vex.net/~trebla/tmp/ei.png
16:02:15 <roboguy_> monochrom: huh. I don't see anything between "Tools" and "Haskell"
16:02:17 <roboguy_> I'm on OS X
16:02:57 <monochrom> then it's too bad
16:03:30 <roboguy_> haha, yeah I guess so
16:03:35 <monochrom> oh, (add-hook 'haskell-mode-hook 'imenu-add-menubar-index) ?
16:06:06 <roboguy_> hmm, still nothing. oh well
16:15:14 <hpaste> edwardk pasted “morton ordered keys” at http://lpaste.net/91701
16:21:10 <Tritlo> I'm looking for a module browser for Haskell
16:21:16 <Tritlo> does anyone know of such a thing?
16:22:08 <Tritlo> I'm thinking along the lines of:
16:22:28 <FreeFull> Tritlo: You could open up ghci, write   import beginningofname  and press tab
16:22:28 <Tritlo> given a haskell source file, show a browser so that you can view all the imports
16:22:41 <FreeFull> Ah, you want something else
16:22:47 <FreeFull> Hmm
16:22:57 <FreeFull> I don't know anything like that
16:23:11 <chrisdone> man, this beer is delicious
16:23:12 <Tritlo> right
16:23:30 <chrisdone> any haskellers drinking a bit of beer this evening?
16:23:35 <Tritlo> FreeFull: do you know then where haskell looks for modules?
16:23:47 <Tritlo> FreeFull: I.e. the haskell equivalent of "classpath"
16:24:07 <Ralith> what's #haskell's favorite name supply monad for practical use?
16:24:38 <FreeFull> Tritlo: Locally installed modules will be somewhere in .ghc, I don't know about system-wide
16:24:43 <enthropy> Ralith: Q
16:24:50 <johnw> Ralith: bound?
16:25:01 <Ralith> johnw: I am kinda scared of bound.
16:25:20 <Ralith> enthropy: isn't Q TH specific?
16:26:26 <Ralith> johnw: my use-case here is doing equality constraint solving across multiple Idris function definitions, if that provides any insight
16:27:08 <enthropy> Ralith: you could run it outside of that case but that would be very unusual
16:27:46 <Ralith> enthropy: well, my use case certainly isn't TH.
16:30:14 <Ralith> johnw: can bound be used to generate globally unique names? Is it at all appropriate?
16:30:26 <johnw> edwardk: would know
16:30:40 <edwardk> Ralith: i use concurrent-supply for that
16:30:57 <edwardk> bound deals simply with capture and substitution
16:31:14 <Ralith> edwardk: cool, thanks
16:31:16 <edwardk> getting a supply that is globally consistent is more like the barendregt convention, which is a competing style of dealing with naming
16:31:23 <edwardk> sometimesit is beneficial to be able to do both
16:31:58 <Ralith> I don't plan to need concurrency immediately, but it wouldn't hurt to be prepared--if anything benefits from optimization, it's a DT language compiler.
16:31:59 <startling> bound looks very useful.
16:32:08 <edwardk> concurrent-supply gives you a way to generate globally unique names from splittable supplies of them that are efficient, e.g. don't bottleneck on a single supply of variables in an IORef, so they can amortize the cost of pulling from a global free list
16:32:42 <edwardk> in general just generate a supply and you can ignore the concurrency aspects afterwards
16:32:57 * Ralith nod
16:33:19 <c_wraith> I feel like GHC's story for non-pure access to a limited resource concurrently still isn't very good.
16:36:43 <c_wraith> I want some sort of per-capability MVar. Exclusive access, but each capability has its own copy.
16:38:02 <Ralith> edwardk: do you usually role your own actual supply monad? This just seems to define the primitives.
16:38:11 <Ralith> er, roll
16:41:51 <joelteon> ok, say I need to use ZLib to decompress the remaining input in a Parsec parser
16:41:53 <joelteon> how should I do that
16:41:59 <joelteon> i.e., before I actually parse it
16:43:02 <monochrom> there is "getInput"
16:43:24 <joelteon> oh, neat
16:49:39 <SrPx> Again because this interests me a lot. Why don't we have a language just like Haskell, except not turing complete, so your program can be completely analyzed (and cached) in advance, in order to be ridiculously optimizable? I don't mean COQ because it is not meant to be used as a general purpose language.
16:50:22 <b2coutts> turing-completeness is kind of nice :P
16:50:45 <mstksg> i don't think you have to get too far in a programming language for it to acquire turing completeness
16:50:46 <monochrom> consider agda
16:51:19 <c_wraith> I kinda dislike turing-completeness.  You only need it to write bugs.
16:51:30 <Ralith> SrPx: turing incompleteness does not entail ease of static analysis.
16:51:57 <c_wraith> less powerful systems suffice to model anything that works the way you intend it to.
16:53:07 <monochrom> 10 years ago, this channel already argued over how much power they needed. today, they still argue. 10 years from now, they will still be arguing.
16:53:26 <monochrom> the loop invariant throughout is: no deliverables
16:54:18 <SLi> It cannot be truly general-purpose if it's not Turing complete. :p Of course it's a question of definitions, but I think Coq is probably roughly as close to general purpose non-Turing-complete as you can reasonably hope to get with the current state of the art.
16:56:21 <Saizan> the problem is not really power, you can encode all you need, the problem is the language expects you to show termination/productivity
16:57:35 <c_wraith> Yeah, that's sometimes not a friendly thing.
16:58:18 <Saizan> it's an active research topic, e.g. there are some papers at icfp
16:58:53 <Saizan> on how to make that more pleasant
16:59:45 <SrPx> SLi: why not? The only thing a non-turing complete can't do, as far as I know, is getting stuck in an infinite loop. Which I personally don't care that much, don't know about you.
16:59:55 <SrPx> (and implementing turing-complete languages, obviously)
17:00:18 <SrPx> Saizan: which!? (:
17:00:42 <c_wraith> Basically, if you can prove an algorithm terminates, you can prove it will run in a system that isn't turing complete.
17:01:33 <SrPx> c_wraith: really? Is there a name for that proof?
17:02:00 <Saizan> Wellfounded Recursion with Copatterns: A Unified Approach to Termination and Productivity
17:02:03 <Saizan> Andreas Abel and Brigitte Pientka
17:02:06 <Saizan> Productive Coprogramming with Guarded Recursion
17:02:08 <Saizan> Robert Atkey and Conor McBride
17:02:18 <Saizan> (sorry if it was too spammy)
17:02:26 <SrPx> Saizan: you probably just filled my weekend, thanks
17:02:56 <lukexi> anyone have any idea what might cause GHC to suddenly reject tons of layout-rule based code? I'm building GHC itself and everywhere that uses the hanging "do this\n\s\s\sthenThis" style is failing
17:03:06 <SLi> SrPx: Assume there is a language which allows expression of a large set of programs that all terminate. It follows that for each program, successfully expressing it in this language is a formal proof that it terminates. Therefore, writing a program in such a language cannot be easier than formally and rigorously proving that it terminates.
17:03:48 <SLi> SrPx: And if you are already able to rigorously prove that it terminates, why do you need a non-Turing-complete language when you can use a Turing-complete one and due to your proof rest assured that it does terminate?
17:04:16 <c_wraith> because proving something correct isn't the same as debugging it.
17:04:25 <SrPx> SLi: wait, I don~w get the last sentence. "Therefore, writing a program in such a language cannot be easier than formally and rigorously proving that it terminates."
17:04:25 <c_wraith> helps if the language enforces the proofs
17:04:27 <Saizan> SrPx: haven't read them yet, but the authors are usually worth it
17:06:17 <Ralith> hm
17:06:27 <SLi> SrPx: If the language can only express programs that terminate, the fact that you have implemented an algorithm in that language immediately proves that it terminates (or, indeed, the implementation is *a proof* that it terminates).
17:06:33 <Ralith> a week or two ago people in here were discussing ways to annotate ASTs with phase-varying information
17:06:46 <SrPx> SLi: yes, but so..?
17:06:48 <Ralith> I remember a good method being presented but I forget what it was
17:07:22 <c_wraith> Ralith: attribute grammars?
17:07:44 <Ralith> one of them was 'data Expr a = ...' with the 'a' slapped on every constructor and then just using various applications of Expr throughout
17:07:53 <Ralith> c_wraith: doesn't ring a bell
17:08:12 <Ralith> c_wraith: I'm referring to the case of ADTs encoding ASTs specifically
17:08:24 <SrPx> SLi: for example, lets start simple. "map (*2) [1 2 3 4 5 6]" that program/syntax obviously terminates and is pretty useful. Why couldn't that syntax be kept in a turing-incomplete language?
17:09:19 <Saizan> it can, if you add some commas :)
17:09:31 <Ralith> I remember someone had a blog post or similar that discussed a few alternatives, the above being one of them
17:10:13 <SLi> SrPx: So, if you can write a formal enough proof that the program terminates (say, in a non-Turing-complete subset of Haskell), you can just as well use a normal Haskell compiler to compile it and you are no worse off because you have already proven (by writing it in the subset) that it terminates.
17:11:04 <c_wraith> SLi: unless you have a bug, typo or semantic, that causes you to leave that subset without realizing it
17:11:15 <SrPx> SLi: I'm not sure why you are saying that... but my point in having such a language is not to prove it terminates, is to allow ridiculous optimizations. for example, therically it could optimize reverse(reverse(list)) to just list.
17:11:20 <c_wraith> SLi: that's where your argument breaks down - when it meets software engineering, rather than theory
17:11:30 <SrPx> SLi: now this is something pretty obvious, but think how much code is not as obvious it has a faster equivalent...
17:11:40 <Saizan> SLi: that argument could be applied to type-safety and some untyped language
17:12:01 <SrPx> SLi: a non-turing complete language could be optimized the most that is mathematically possible. that is my point. it could even cache the whole program in advance if it fit in memory
17:12:55 <SLi> Well, naturally you can have a program to verify it. But the point is that any language that can only express terminating programs either needs to be very unexpressive or hard to use (because writing a program is at least as hard as formally proving it terminates).
17:13:14 <SLi> And I don't think you appreciate the hardness of proving termination for real-world programs :)
17:13:18 <Saizan> SrPx: tbf totality helps with some optimizations but it's not an holy grail, a lot of things just go from impossible to infeasible
17:13:36 <Ralith> SrPx: if optimization is your objective here, you might be better off just focusing on supercompilation of existing languages.
17:13:45 <SrPx> Ralith: what is that?
17:13:49 <Saizan> SLi: got a very hard example?
17:13:54 <SrPx> Saizan: are you sure of that?
17:14:00 <c_wraith> SLi: proving termination of a real-world program is exactly equivalent in difficulty to writing it in a provably-terminating language subset. You're not gaining anything.
17:14:19 <Saizan> c_wraith: that's his point, i think
17:14:28 <SLi> c_wraith: That's what I'm trying to say. I kind of assumed it was common grounds that proving termination is hard. Maybe not then :P
17:14:29 <SrPx> c_wraith: it is his point indeed
17:14:53 <c_wraith> My point is, given that, work in a terminating language. Better guarantees, same difficulty.
17:14:58 <SLi> Saizan: Well, consider for example code to compute a square root.
17:15:11 <SrPx> but all I get is that you are saying that writting programs in such a non-turing complete language is hard, while I just showed an example of a program that is pretty easy to write and obviously terminates
17:15:13 <c_wraith> Unless your plan is to cheat when things get hard
17:15:22 <c_wraith> But that's the same as saying "if it's hard, just allow bugs"
17:15:42 <SLi> Most formal systems try (for a good reason) to minimize the number of axioms, i.e. they usually are founded on set theory.
17:15:47 <arkeet> it's better to have to prove things to the compiler than to prove things to yourself.
17:15:51 <Ralith> SrPx: http://community.haskell.org/~ndm/temp/supero.pdf may be of interest
17:15:59 <SLi> On top of this, you define integers, usually using something resembling Peano arithmetic.
17:16:08 <arkeet> because you can lie to yourself.
17:16:13 <c_wraith> Has Supero seen any work in the last couple years?
17:16:26 <SrPx> I mean you don't have to "prove" it by yourself. You can just write in a syntax that is cautiously made to be useful, yet only can make stuff that the compiler can be sure it terminates. Like, mapping a function to an array.
17:16:28 <SLi> Or you start from natural numbers, then define negative integers, then rational numbers.
17:16:38 <Ralith> c_wraith: haven't seen anything since 2010, which makes me sad
17:16:38 <SrPx> Ralith: kay
17:16:55 <SLi> The theory of real numbers, and even the theory of floats, is really hard and is quite seldom seen in formal systems.
17:17:25 <SLi> Yet you need that to be able to reason about the convergence of a routine computing a square root.
17:17:47 <Saizan> Coq has computable reals as a lib
17:18:15 <SLi> Yeah. I think (but haven't really taken a look) that the foundations beyond that must be quite enormous.
17:18:24 <Saizan> behind?
17:18:32 <SLi> behind.
17:18:36 <Ralith> c_wraith: ah, found the discussion I was thinking of: http://lambda-the-ultimate.org/node/4170#comment-63834
17:18:52 <Saizan> once it's done you can use it anyway :)
17:19:12 <Saizan> though of course, reals aren't exactly what most code these days is about
17:19:48 <SLi> SrPx: But that's the problem. Writing a program in such a language *is* a proof that it terminates, therefore by writing such a program is exactly proving it by yourself.
17:20:17 <SLi> Agh, I'm getting too tired to write syntactically valid sentences. Time to sleep :P ->
17:21:14 <Saizan> anyhow, there are plenty of cases where termination is quite easy to show by structural recursion or more generally well-founded one
17:21:59 <Saizan> i.e. if there's anything that's getting smaller at each step it can either figured out by the typechecker or you make it somewhat explicit
17:22:07 <Ralith> I find that almost all the code I write in Idris is trivially total
17:22:22 <Ralith> on that basis I can say with confidence that it's definitely useful to have even a primitive totality checker
17:22:32 <SrPx> SLi: :/ ok see you
17:28:16 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
17:28:16 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
17:28:16 --- names: list (clog lcfrs_ talzeus__ shesek Demos tertl3 wbooze__ mjs2600 kaktus dgpratt Hermit mekeor Watabou balthamos89 cmccann flebron Betal carlo5m Sgeo SrPx SBauer voxpopuli sacundim pkrnj conehead fgomez agjacome rishabhjain MedDev chidy augur dropdrive Tritlo wole xpika ehaliewicz Twey chatsiri_ Y_Less xcv_ Ralith predator117 apples` Krakarn Nisstyre D9 ido Jesin k0001 Kabaka subbyyy startling Mortomes Ian__ EvilPenguin Jesin-phone dented42 lukexi pcapriotti)
17:28:16 --- names: list (litherum edwardk sxn conal scottschecter andyjgill acowley diabel232 virvel Beetny sellout aartamonau evan__ kloplop321 joelb tiffany krzysz00 cognominal solrize_ pentace Sonderblade archblob troydm dolio ircbrowse pxqr jackhill brainwash gautamc sclv Croms bb010g hiratara boothead Kuraitou junsuijin datura bananagram marr kylcarte OlegYch roboguy_ albel727 ozgura k00mi harovali tpsinnem skeet70 solution Fuco nan` Thra11 Myk267 glosoli h4199 insejn)
17:28:16 --- names: list (AntiSpamMeta nova_ nominolo solidus_ raichoo alpha123 DrCode canta seschwar Urchin[emacs] kot_2010 wting nexx mrsolo Wuzzy NiceOneBrah Dennis flux0r fionnan nilsi mannyv Fuuzetsu ahihi cdidd codesoup spektroskop aunn kennyd c_wraith jamestastic sunfun copumpkin kobain davean benj_ trism wbruce ddinh joe9 totos__ pygospa Reite jascase901 Sculptor resttime _d3f jzl bscarlet nimish WaffleCat kevinqcs iol Noldorin Natch eyck asjo rodrigovidal kubrat theorbtwo)
17:28:16 --- names: list (Internet13 Pranz thunderfishes74 n-dolio hiptobecubic shintah doomlord [[zz]] mirari Rarrikins thunderrd mcbonz dmwit Ov3rload dschoepe Eduard_Munteanu kludge` MoALTz weie q66 noddy sjoerd_visscher chrisdone lemao Endeg SoupEvil xexonixxexillion iteratee flowsnake nilg MetaCosm dav mshroyer stvc dysinger vili phienone gienah tero- td123 xinming FreeFull rfw cdk blakesmith monochrom shachaf hamishmack goldkatze joogi araujo daniel-s tobyo preflex mauke ezrios)
17:28:16 --- names: list (parcs shanse tvaalen wtw_ fikusz torkjak Shou mstksg fijimunkii LordBrain c_14 gnuvince- julmac krakrjak RichyB apaku jaimef jonlorusso purefn ormaaj de-Vri-es kstuart rmyers ecube k0ral Philippa Dtgr cods amosr MOMI bytbox cl_away daira Khisanth setmeaway morolin isomorphic burp b0c1 haasn tauntaun ByronJohnson jssanders aloiscochard|off edkk scshunt milessabin vk_ ErkiDerLoony YoungFrog chirpsalot zvrba lpvb coeus lunarjar ghorn Nshag jang1 Moataz-E tadeo)
17:28:16 --- names: list (dabradley tehroflmaoer b2coutts udoprog joneshf-laptop bartavelle whaletechno aoh arnsholt Nik05 JuanDaugherty caleb_9 mceier M-ou-se tomh- Entroacceptor peddie_ ssbr mantovani cynick taruti sdx23 bduc arkx so dwierenga mokus perlite Bwild fergusnoble tg aford brandonw tudalex adnap stepkut Spaceghost doshitan Jonno_FTW otto_s Philonous NihilistDandy peddie brisbin hiroakip Igloo dreixel Boney drbean biscarch gpampara_off plucas miloshadzic tsou andrewsw)
17:28:16 --- names: list (smlgs joneshf-work Counter-Strike callen rasmusto epta enthropy jlaire ktosiek zrot dkasak_ joefiorini Tinned_Tuna davidt_ ceii niko Amadiro tensorpudding gbeshers swistak35 simon eacameron anon123 seq99`` xymox bbloom uu1101 Luke hive-mind xilo MrFahrenheit otulp Cerise idoru cheezey ccxCZ Tehnix machisuji gthorslund felipe_ Adios neena bicgena charlesofarrell_ uranther ski bsmt nkpart EpicOut Athas Liskni_si tomaw rpenguin_ pjstadig hpc aristid guerrilla)
17:28:16 --- names: list (iulian dpwright KitB tulcod ousado osfameron sgso ivan` mlamari jlamothe adimit mgsloan sirspazzolot alpounet dju marienz yam leifw McManiaC shergill tavelram epsylon Excureo DarkFox Tarential dino- mee hape01 cajla Work_jack palmje mrshoe Ke FireFly Bio kakos tridactyla SegFaultAX pdxleif BigEndian Ycros jrslepak frontendloader _br_ yiannis_t Hafydd dsantiago Maxdamantus obcode wunki ninegrid `0660 Jaxan vsayer LevelOneDev Nimatek Enigmagic twn gereedy)
17:28:16 --- names: list (ethercrow jdoliner dogmaT dexter1 tomejaguar centrinia adlan annulus- orospakr gambogi Squid_Tamer munro Khady robinbb-freenode oldmanstan Adeon DustyDin1o jbauman IanKelling SLi leroux carter bobry demolithion satshaba1 satshabad brixen dyreshark mmathis gilbertw1 lambdabot Iceland_jack lenstr Will| tahu mimi_vx PHO_ mikee Jello_Raptor vehk ab9rf canissimia idnar stass Gracenotes threedaymonk Sunhay_ DigitalKiwi wollw acfoltzer cschneid jml ParahSail1n)
17:28:16 --- names: list (Lemmih qz mietek lightquake solancile floatingman mjo mortberg Raynos tylergillies_ stepcut nik_89 thorsten` raft tshirtman reactormonk helgikrs fxrh inr Cale valdyn dqd colah jyyou xnyhps wormphlegm anhall djahandarie osnr machisuji_ mike2 Tekerson sajith KaneTW heath kloeri Odd_Bloke FUZxxl mxf knyppeld1nan divarvel froztbyte Draconx _janne BMeph akraut arkeet tunixman etherfreak vvv_ drewr Erstarrung jrib zero7 sevvie zebr hdevalence flazz_gone Raynes)
17:28:16 --- names: list (quicksilver bd__ dsirenko_ Bigcheese go|dfish pikhq d3lxa si14 alej stelleg nullcone_ Sabey upgrayeddd chexxor lopex bentrevor sordina1 dcoutts vnz pettter lattenwald drdo qwandor hiyakashi tdammers Baughn_ ciaranm srcerer Morgawr michaf gnuvince zoktar etrepum spligak descender hpd seneca nitrodex _flow_ eL_Bart0 shutdown_-h_now wilfredh puzza007 chickenflu warpy Xorlev ortmage ps-auxw bbee akahn xorox90_ lokydor chrisbuchholz talzeus_ shennyg kav vivekrai)
17:28:16 --- names: list (Ghoul_ Vertue IbnFirnas jodaro_ xrl gdeest ehd DrSyzygy stevejb` joeyh kini stevejb waterlaz Licenser hfaafb nwf jhh banjiewen dthibodeau mykhal blz37 palaga doomlord_ NeatBasis_ ggherdov mak` mikecaruso Eridius|vacation gseitz sepeth farn yano aleator milli brett bcoppens Martty knz cmsd2 destiny vpm neurocyte ivan\ nonconvergent mmaruseacph2 rgrinberg thebnq s_quark zomg arbn petantik bogner electrogeek BrianHV newsham earthy vobi sclv_ Belgarion0 bezik)
17:28:16 --- names: list (edwtjo mero vvein levitation[A] koala_man JustAPerson apples nanothief_ maoe f8l Th0mas tomprince wto linduxed noplamodo thorkilnaur__ averell nxorg8 thirsteh mlinksva kxra dan_johnsin SaBer neektza1 zerokarmaleft myme1 janinge ggreg otterdam ocharles ysuzuki aess saiam elgot resure mechairoi Valodim awruef hackagebot WhereIsMySpoon Svedrin byorgey `bps liori mlh kshannon h_chiro_ goodmanio stiell alexander__b mel- warpaint int-e sm dakrone Tribal Bynbo7)
17:28:16 --- names: list (sleepybug flux kaw ReinH joar bogner_ tych0 Deewiant tippenein Mayzie noam_ dustinswan zxq9 plhk saiam^ Phlogistique jmcarthur joshc ninzine phryk gemelen Hardolaf peltchu akiress_ MasseR gbluma_ Jimi` Laney mixi thetallguy2 Elision mapreduce schlumpi theDon zaphar_p1 kqr1 Gothmog_ kranius cow-orke1 deggis javawizard slobo_ SHODAN s4msung bstrie mux a11235 xplat ahf BlastHardcheese geoffh jlewis duairc JPohlmann integral Brando753 Cryovat brendan rce)
17:28:16 --- names: list (brainproxy othiym23 davorak_ suiside drmegahertz agundry Plex- ent zenzike_ dixie_ saurik luite Saizan lispy hvr ofan mviljamaa Maior thorsten1 jlouis fayden shiona wchun ernst mollerstrand statusfa1led Boreeas ehamberg mami_ tswett bholst_ Yawgmoth_ ChongLi companion_cube bind Sourceless shepheb flori skypers smarter Zariel supki guymann liyang joachifm vmeson briden joelteon ski_ hiredman jroesch Ornedan schoppenhauer mornfall CosmicRay Soft kaol ttm)
17:28:16 --- names: list (pqmodn_ malorie_ dilinger_ Gilly thoughtpolice ryanakca mr- Razz ziman thetallguy aninhumer pr xenophon zorzar `^_^v raid Edoxile sohum ClaudiusMaximus hpaste nikola zw01 greymalkin fall_ Nickeeh yan_ Blkt aformeny bgamari dsp_ swook` Watcher7 ejls Yaniel killy9999 xaimus macron luminous jaspervdj confound_ Zesler mkrull Eliel ft anachron SirChurchill Ezku b_jonas johnw kosmikus almondjelly copton jix Riussi_ lahwran Fubar^ mononofu pyykkis natte notdan)
17:28:16 --- names: list (zeiris_ ParahSailin horlicks Draggor lpsmith mikeplus64 fry kooga barrucadu robbert majoh betawaffle gds Ptival inarru geal taylorgb ipuustin Walther ccasin jayne Reisen bitraten davorb-cellphone ibid Jaak CindyLinz aszlig zaiste def-lkb_ arcatan Spockz tromp_ cjay kryft \q Sagi TheSpectre Kneiva_ rs0 bxc SuperNoeMan stomp opqdonut petanqk profmakx liszt jkpl nicoo solarus jliikka pyrtsa danr cross Rutger`_ solirc ljhms_ dario^CIP ion klugez gridaphobe)
17:28:16 --- names: list (wereHamster genisage ve TML away_sondr3 pi8029 finnrobi sunnavy_ prophile pfoetchen Rembane relrod Proteumus lulf mattp__ chrra fabjan LeaChim dumbhat @ChanServ wavewave OrangeDuck dextrey tamiko n00dle Kinnison pnielsen sipa wagle geekosaur isomorphismes anders^^_ magicman mgaare Dybber mendez Clint sp3ctum cruxeternus birkenfeld seantallen Vq pharaun ericmj bqp XMunkki_ poucet bergmark elliott deavid dlundy gbarboza MK_FG asante __main__ b52 caligula__)
17:28:16 --- names: list (fryguybob tessier davd petekaz`` Ulrar mrd_ Starfire_ mjrosenb nlogax Chousuke Dashkal jamwt dmp1ce yeltzooo necroyeti willb1)
17:28:45 <SLi> And if support for integers is the "batteries included" model in dependent typing, there's still way to go ;)
17:31:18 <SrPx> SLi: just want to say you teached me more than you would think with all that
17:31:47 <SrPx> I wish I could stop working and just study that kind of stuff :/
17:34:36 <ReinH> Ralith: seems pretty standard. I'm interested in biplates for things like this.
17:35:02 <Ralith> ReinH: doesn't this somewhat obviate the need?
17:35:29 <Ralith> ReinH: at present Idris is using manually constructed similarly-shaped ADTs for each distinct pass, and I'm looking to start using something better.
17:35:48 <SrPx> (by the way, ReinH, supercompilation seems to be exactly what I am saying, except with tricks to find some 'non turing complete forms' inside turing complete languages in order to supercompile them!!!)
17:35:57 <ReinH> SrPx: oh we're still talking about that? :D
17:36:05 <SrPx> No sorry, I was just reading that paper
17:36:13 <ReinH> SrPx: no no, I'm just joking :D
17:36:55 <ReinH> Ralith: well, I like the composability of biplates (see the lens impl)
17:37:03 <ReinH> and how much more I understand them than what's going on there ;)
17:37:44 <ReinH> Ralith: "I am not s smart man."
17:37:56 <ReinH> *a
17:38:13 <maurer> Prelude> :m Data.Aeson Data.Text
17:38:13 <maurer> Prelude Data.Aeson Data.Text> encode $ object [(pack "size", Number 3)]
17:38:15 <maurer> this hangs
17:38:17 <maurer> any ideas why?
17:38:28 <Ralith> ReinH: That can't be right if you're comfortable with lens ^^
17:39:10 <ReinH> Ralith: well, I understand biplates in terms of lenses...
17:39:36 <ReinH> as in "oh I can do X with biplates", not in a deeply theoretical way
17:39:52 <Ralith> ReinH: anyway, what's biplate's deal? I haven't learned it yet. Is it a good solution for the problem of type-safe AST annotation?
17:39:53 <ReinH> thus the "I am not a smart man" comment :)
17:40:14 <Ralith> @hoogle Fix
17:40:14 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
17:40:14 <lambdabot> Data.Fixed module Data.Fixed
17:40:14 <lambdabot> Data.Function fix :: (a -> a) -> a
17:40:14 <ReinH> Ralith: it seems like a good general solution to the problem of subtree transformations, annotations, etc
17:40:38 <Ralith> ReinH: can you point me at some examples?
17:40:41 <ReinH> Ralith: hmm
17:41:50 <Ralith> ReinH: my immediate need is to take a fairly simple AST and annotate every instance of a specific sort of leaf (corresponding to a single data constructor) with a name.
17:42:09 <ReinH> Ralith: it actually generalizes over generic traversals (http://community.haskell.org/~ndm/uniplate/)
17:42:10 <Ralith> while Writering out constraints
17:42:15 <ReinH> > anyOf biplate (=="world") ("hello",(),[(2::Int,"world")])
17:42:16 <lambdabot>   True
17:43:11 <ReinH> Ralith: most of my intuition comes from http://arxiv.org/pdf/1103.2841.pdf
17:43:13 <Ralith> ReinH: that's neat, but it isn't obvious to me how it relates to my problem.
17:43:35 <ReinH> Ralith: that paper is more interesting for you I think
17:44:36 <ReinH> "we often want to apply a transformation to
17:44:37 <ReinH> all subtrees of a certain type and often these abstract syntax trees are built from mutually
17:44:39 <ReinH> recursive data types."
17:44:41 <ReinH> sorry for multiple lines
17:49:14 <Ralith> ReinH: so, no practical examples of annotations handy?
17:49:50 <ReinH> Ralith: afraid not :(
17:50:41 <edwardk> :t rewrite
17:50:41 <lambdabot> Plated a => (a -> Maybe a) -> a -> a
17:50:42 <Ralith> I'm not sure how to easily check if it's even relevant :/
17:51:24 <ReinH> Ralith: never fear, edwardk is here...
17:51:25 <Ralith> edwardk: my usecase is to add information to a node that previously wasn't there, without having to bloat or duplicate the base AST type.
17:51:29 <edwardk> rewrite (\case Neg (Lit a) -> Just (Lit (-a)); _ -> Nothing)  -- would go through a syntax tree replacing all negated literals with negative literals bottom up rewriting over and over until it doesn't fire
17:51:37 <edwardk> :t rewriteM
17:51:38 <lambdabot> (Monad m, Plated a) => (a -> m (Maybe a)) -> a -> m a
17:51:45 <edwardk> there you can have monadic side-effects
17:52:11 <edwardk> but in ASTs one common pattern is to move to a cofree comonad or some other system to sneak in annotations
17:52:17 <Ralith> oh dear.
17:52:28 <edwardk> but that takes er.. a bit of a long explanation
17:52:34 <ReinH> heh
17:52:37 <ReinH> Ralith: see what I mean...
17:52:45 <edwardk> i wrote a post on 'reflecting on incremental folds' about it
17:52:53 <Ralith> I knew I was going to have to learn what all this costuff was about one of these days
17:53:01 <edwardk> =)
17:53:15 * Ralith digs it up, reads
18:09:29 <mstksg> is there a popular indent ocnvention?  two spaces or four?
18:09:39 <mstksg> no intention of starting a flame war
18:09:58 <monochrom> 2.718 spaces
18:10:30 <pxqr> monochrom: that's pretty close to the average
18:10:46 <pxqr> if we sum the all haskell sources
18:22:07 <sm> mstksg: whatever my haskell-mode insists on today
18:22:44 <lykos> does anyone here know how I would set up https on snap?
18:23:09 <Ralith> @hoogle Mu
18:23:09 <lambdabot> Text.ParserCombinators.ReadP munch :: (Char -> Bool) -> ReadP String
18:23:09 <lambdabot> Text.ParserCombinators.ReadP munch1 :: (Char -> Bool) -> ReadP String
18:23:09 <lambdabot> package mucipher
18:24:05 <Clint> lykos: use a reverse proxy?
18:25:52 <lykos> Clint: uh, I don't see what that has to do with https?
18:26:22 <lykos> Clint: I'm still pretty new to managing a server
18:26:44 <Ralith> ReinH: http://hackage.haskell.org/packages/archive/fixplate/0.1.5/doc/html/Data-Generics-Fixplate.html looks like about what I was thinking of originally
18:27:28 <Ralith> it seems to reimplement a lot of wheels, though
18:27:36 <Clint> lykos: if you put nginx or apache or something else in front of your application server, it can listen on https
18:28:14 <Clint> you lose out on client-cert auth but nobody seems to care about that very much anyway
18:28:39 <lykos> Clint: So snap can't listen on https?
19:09:30 <gertc> how do you go from (IO a , IO b) to IO (a,b)?
19:09:47 <elliott> liftM2 (,)
19:10:11 <gertc> ok testing
19:10:28 <dalaing1> :t liftM2 (,)
19:10:29 <lambdabot> Monad m => m a1 -> m a2 -> m (a1, a2)
19:11:43 <pentace> @pl \(a, b) -> liftM2 (,) a b
19:11:43 <lambdabot> uncurry (liftM2 (,))
19:14:27 <startling> :t both id
19:14:28 <lambdabot> Applicative f => (f b, f b) -> f (b, b)
19:14:46 <startling> :t _1 id &&& _2 id
19:14:47 <lambdabot> (Functor f, Functor f1, Field2 s t1 (f1 b1) b1, Field1 s t (f b) b) => s -> (f t, f1 t1)
19:16:33 <startling> oh, that last one is wrong.
19:17:27 <gertc> lol it worked haha :) openState = liftM2 (,) (openLocalState (UserMap empty)) (openLocalState (GroupMap I.empty))
19:19:40 <pentace> or for more readability: openState = (,) <$> openLocalState (UserMap empty) <*> openLocalState (GroupMap I.empty)
19:20:30 <gertc> ok thx
19:28:05 <enthropy> would it be possible to encode this concept http://cvxr.com/cvx/doc/dcp.html at the type level?
19:31:32 <Nisstyre> enthropy: lots of things are possible
19:31:48 <Nisstyre> enthropy: check out type families and data kinds
19:39:37 <hpaste> enthropy pasted “types for convex programs” at http://lpaste.net/91703
19:41:05 <enthropy> there's no overlap for type families, so maybe that's not a good approach
19:41:36 <enthropy> it's about the same amount of code to have   class PlussT a b r | a b -> r
19:53:01 <shelf> yo, stupid question. is there any operator with signature a -> (a -> b) -> b
19:53:56 <shelf> just backwards $
19:54:45 <elliott> lens has (&)
19:55:22 <startling> shelf, flip id
19:55:25 <startling> :t flip id
19:55:25 <lambdabot> b -> (b -> c) -> c
19:55:37 <startling> oh, "operator"
19:56:07 <shelf> yeah someone is asking about the equivalent to F#'s (|>)
19:56:09 <ReinH> I think I understand free monads now. Cofree Comonads, not so much.
19:56:20 <ReinH> Something something right adjoint.
19:56:20 <shelf> i know nothing about F# but i figured it'd be monadic code in any haskell situation and thus just >>=
19:56:42 <shachaf> ReinH: Right adjoint?
19:56:50 <startling> shelf, that's not necessarily true
19:56:55 <startling> but yeah, lens has &
19:57:54 <ReinH> shachaf: apparently. http://stackoverflow.com/questions/13352205/what-are-free-monads
19:58:20 <shachaf> Oh, I thought you were talking about (|>).
19:58:20 <shachaf> I missed the first line.
19:58:33 <ReinH> heh
19:58:38 <shachaf> Anyway, Free f a is just Either a (f (Either a (f (...
19:58:47 <shachaf> Cofree f a is just (a, f (a, f (a, f (...
19:59:21 <ReinH> hmm
19:59:25 <shachaf> So they're both trees of sorts with f-shaped branches.
19:59:43 <startling> oh, that's interesting.
20:00:02 <ReinH> shachaf: so it's like a stream?
20:00:10 <startling> ReinH, no.
20:00:14 <shachaf> Free Identity is a stream, yes.
20:00:20 <startling> oh
20:00:28 <shachaf> Er.
20:00:31 <shachaf> Cofree Identity
20:00:33 <shachaf> Is a stream.
20:00:42 <jmcarthur> a + f (a + f (a + f (a + ...   vs.   a * f (a * f (a * f (a * ...      -- i think it's clearer with infix type constructors
20:00:43 <ReinH> ha! And Cofree [] is a rose tree http://hackage.haskell.org/packages/archive/category-extras/0.2/doc/html/Control-Comonad-Cofree.html
20:00:51 <shachaf> Yes.
20:00:56 <shachaf> Cofree [] is Data.Tree
20:01:04 <ReinH> well then
20:01:06 <ReinH> thanks
20:01:17 <shachaf> Free [] is also an n-ary tree -- a lot like an s-expression.
20:01:37 <shachaf> data Foo a = Atom a | List [Foo a]
20:01:39 <Swamy> Hello
20:01:53 <ReinH> neat
20:02:35 <shachaf> And of course Cofree is right-adjoint to a forgetful functor from F-Alg, like you said.
20:02:44 <shachaf> I'm not sure how much that really helps you, though. :-)
20:02:46 <ReinH> shachaf: yeah that's the part I need more math for :)
20:02:56 <ReinH> also, "of course" ;)
20:03:22 <cschneid> I built a new project using the `hi` tool, and the build fails immediately with "cabal: ender.cabal:16: Parse of field 'exposed-modules' failed."
20:03:26 <cschneid> any idea on what I need to go look at
20:03:45 <shachaf> Well, "right-adjoint to a forgetful functor" is in general the meaning of "cofree".
20:04:47 * shachaf vanishes.
20:05:27 <piesquared> What's the right way to avoid needing to give excessive type declarations when using numeric literals?
20:07:18 <piesquared> I'm playing with these examples for the functional dependencies and whatnot by making my own toy library, and I'd like to be able to just write 3 `myTimes` Vector [1.0, 2.0, 3.0], or something, and have it work. The real issue is that 3 :: Num a => a, so anything I do with type classes confuses ghc due to ambiguity - "there are multiple potential instances" is a common thing.
20:08:35 <shelf> so is there any reason why this kind of flow isn't popular in haskell? http://pastebin.com/JZrgukBw
20:08:35 <enthropy> piesquared: that's probably workable without any annotations
20:08:37 <mauke> The paste JZrgukBw has been copied to http://lpaste.net/91704
20:14:29 <jmcarthur> piesquared: you can get rid of the most common ones by either turning off the monomorphism restriction or always adding top level type signatures
20:14:54 <Swamy> What all the things i need to know before i start haskell ?
20:15:17 <jmcarthur> shelf: you mean reverse application?
20:16:54 <jmcarthur> Swamy: prerequisites just depend on what tutorials you are following
20:17:19 <shelf> yeah
20:17:21 <jmcarthur> Swamy: overall, you don't need much particular background, but some tutorials or teachers might assume different things
20:17:42 <jmcarthur> shelf: i don't personally see much point in reverse application
20:17:45 <shelf> F# friend is making a good case for that being pretty readable, and ofc that style works fine in haskell. but i've never seen it
20:18:12 <Swamy> Basic Math is Fine ?
20:18:14 <shelf> i assuemd that math-happy haskell folk would be more at home with a where block vs something resembling a nix pipe
20:18:34 <Swamy> jmcarthur Basic Math is fine ?
20:18:45 <jmcarthur> shelf: sum . filter blah   -- would be my preference (it's less common to have the actual argument to the whole thing inlined anyway, since it's normally a program input from IO)
20:19:11 <jmcarthur> Swamy: as i said, it depends
20:19:54 <shelf> yeah i agree
20:21:03 <shelf> ty
20:22:00 <Swamy> Can i take it as YES
20:23:57 <jmcarthur> Swamy: i gave you the most direct answer i know. it's entirely up to you whether you intentionally ignore it and assume i meant something that fits into your more binary worldview.
20:24:44 <jmcarthur> Swamy: if you want something closer to a boolean answer, i will need more information, such as what materials you are learning from
20:25:21 <cschneid> ok, finally got a test suite running. What's the workflow people use to build the code, then run the tests?
20:25:31 <cschneid> do you have a makefile, or just an alias to cabal build && cabal test?
20:25:53 <jmcarthur> cschneid: i just use cabal directly. it's not like it's hard to type "cabal build"
20:26:20 <cschneid> jmcarthur: well, from a test-driven perspective, it's nice to have instant feedback. You're right of course, just wondered if there's a nice feedback loop people use
20:26:25 <jmcarthur> cschneid: plus i usually just have to hit the up arrow once or twice and hit enter, since it's in recent history
20:26:28 <Swamy> jmcarthur I'm searching for a tutorial
20:26:43 <cschneid> jmcarthur: sure. And/or aliased to a vim mapping :)
20:26:54 <cschneid> I am right I have to `cabal build` before each cabal test though, right?
20:27:07 <jmcarthur> cschneid: ah, well, i also use ghc-mod with emacs, so i normally don't have to explicitly build anything except when i'm going to test
20:27:14 <jmcarthur> as far as i know, yes
20:27:23 <jmcarthur> @where lyah
20:27:24 <lambdabot> http://www.learnyouahaskell.com/
20:27:25 <jmcarthur> Swamy: ^^
20:27:34 <cschneid> ya, gotta figure out ghc-mod in vim. I have hdevtools doing typechecking.
20:27:42 <jmcarthur> Swamy: or if you already know some programming, maybe rwh would be good for you...
20:27:44 <jmcarthur> @where rwh
20:27:45 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:28:30 <cschneid> I found both books excellent, and filled in nicely for each other in some places
20:29:15 <Swamy> Thank You for near to boolean answer
20:30:12 <cschneid> Swamy: yeah, just go for it. It's a programming language first, math second. Just learn to ignore some of the overly clever people here for a while while you get the basics down
20:30:18 <hpaste> enthropy pasted “piesquared -- example” at http://lpaste.net/91705
20:30:26 <enthropy> piesquared: you might also just make scalars and vectors have the same type like ^^
20:30:32 <cschneid> I'm new too - it's mostly just figuring out how different it is from other languages :)
20:31:09 <Swamy> k.... cschneid  Thanks
20:31:29 <Swamy> Math is First though
20:32:16 <piesquared> enthropy: huh, interesting idea...
20:33:43 <Swamy> Bye All
20:34:15 <cschneid> Swamy: nah, screw math. There's not much to it in haskell
20:34:27 <cschneid> lots of underlying, nearly no math for doing basic learning programmings
20:35:40 <piesquared> enthropy: My current approach is to have `Scalar raw` and `Vector raw` where `raw` is the type they have inside them; then, define a MultOp type class using functional dependencies as in the example, i.e. MultOp Scalar Vector Vector === "scalar * vector = vector". This works pretty cleanly, but breaks down when I try 3 `myOp` (someVectorExpression), because it just uses 3 :: Num a => a, and there is no general instance f
20:35:40 <piesquared> Num (ContainerType raw), so it doesn't know how to use the MultOp. Num instances exist for Scalar's, but it doesn't know that it should use those specifically.
20:36:16 <Swamy> Before i came here people said it's for math wizards..So i thought of trying out :) cschneid .... I guess i got misinformed
20:36:35 <cschneid> Swamy: there is most certainly math to learn. At some point
20:36:54 <cschneid> just like if you learn java, you're gonna want to know details of Garbage collection at some point
20:36:57 <cschneid> but that's WAY down the line
20:37:06 <Swamy> java is set of API
20:37:13 <Swamy> i left the language
20:37:54 <cschneid> you get the idea though. haskell uses mathy terms moreso than other languages. but the actual concepts at the beginning aren't hard
20:38:14 <cschneid> and down the line, it's pushing boundaries so yeah, you'll hit math and academic papers. No biggie. You'll have your footing by then
20:38:16 <cschneid> go play with it
20:38:31 <Swamy> nice ...Thank You
20:41:40 <startling> yeah, you'll probably find yourself diving deeper and deeper down the rabbit hole
20:41:51 <startling> but it's emphatically not something you need to do
21:17:25 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox
21:51:17 <pdxleif> It'd be nice if there was some travis-like build services that could produce .exe's of your programs across a variety of platforms.
21:52:17 <pdxleif> Seems it'd be easier to tell people to just "download my program and put it in your $HOME/bin or /usr/local/bin", rather then tell them to first install haskell platform, then cabal-install it and wait for everything to compile.
21:55:53 <edwardk> pdxleif: they've been talking about adding build artifacts to travis for a year or two now
21:59:13 <pdxleif> If everyone chipped in some server resources for whatever they happened to be running...
22:07:14 <josiah14> I'm going through the learn you a haskell book so bear with me
22:08:34 <blackdog> I'm having a problem with a network server - I've turned a socket into a handle, then am attempting to read from it with hGetLine
22:08:56 <blackdog> this works, but when i send control-d through telnet, i get an explicit EOT character on the haskell side
22:09:11 <blackdog> is there a way to get the cooked terminal mode, rather than raw?
22:09:13 <johnw> josiah14: do you have a question?
22:09:42 <josiah14> I know I can define an infinite array using [1..] or some such
22:10:04 <josiah14> but is there a way I might be able to define something generic so I can do something more like [n..0]
22:10:19 <johnw> that feature is not yet in GHC
22:10:23 <blackdog> josiah14: counting down or up?
22:10:30 <josiah14> I seem to have figured out how to define an incrementing list but not decrementing
22:10:44 <johnw> > [-5,-4..0]
22:10:45 <lambdabot>   [-5,-4,-3,-2,-1,0]
22:10:54 <josiah14> assume n positive
22:11:05 <johnw> > [5,4..0]
22:11:06 <lambdabot>   [5,4,3,2,1,0]
22:11:11 <johnw> you need to specify three numbers
22:11:20 <josiah14> so to make that generic...
22:11:32 <johnw> > [n,n-1..0]
22:11:33 <lambdabot>   *Exception: not a number
22:11:38 <johnw> > let n = 5 in [n,n-1..0]
22:11:40 <lambdabot>   [5,4,3,2,1,0]
22:16:04 <josiah14> what about defining it as a function, something that allows me to pass n as a param and get back a list from n down to 0.  Something reusable
22:16:33 <josiah14> the list comprehension thing is hard to grasp coming from C++
22:16:58 <startling> :t \n -> enumFromThenTo n (n - 1) 0
22:16:58 <lambdabot> (Enum a, Num a) => a -> [a]
22:17:25 <startling> > let f n = enumFromThenTo n (pred n) 0 in f 12
22:17:26 <lambdabot>   [12,11,10,9,8,7,6,5,4,3,2,1,0]
22:17:51 <josiah14> ah, interesting
22:17:57 <josiah14> let my try that out
22:18:25 <startling> it's kind of an ugly function; that's what [n, m ... o] desugars to
22:18:46 <startling> sorry, [n,m..o]
22:19:09 <solrize> question about `par`, i think: i have a function expensive :: Integer -> Bool.  i'd like to print all numbers with this property, i.e.  main = mapM_ print (filter expensive [1..1000]).  but i'd like to use multiple cores, is there a simple way?
22:19:32 <josiah14> ugly is okay, every bit is going to help me understand Haskell a bit better
22:22:20 <johnw> solrize: I think this would work: print $ catMaybes $ map (\x -> if expensive x then Just x else Nothing) [1.1000] `using` parList
22:22:28 <johnw> i'm not sure what happens if you use parList with filter
22:22:37 <josiah14> no matter how hard I try, I always come back to working on Haskell - it's a fucking beautiful language
22:22:40 <josiah14> thanks for your help all
22:24:27 <joelteon> we should make a shorthand for data X = X ..., just data X ...
22:24:39 <solrize> hmm i didn't know about parList, i'll look for info
22:24:46 <solrize> thanks
22:25:08 <enthropy> joelteon: well you could run the c preprocessor over your code
22:25:28 <joelteon> yeah
22:25:35 <joelteon> or i could just complain in IRC
22:25:48 <johnw> I guess by "we" he meant us? :)
22:26:03 <joelteon> by "we" I meant the whole beautiful haskell community
22:26:10 <joelteon> i just happen to not know GHC very well
22:26:14 <johnw> flattery will get you nowhere :)
22:27:37 <kwos> Hello!
22:27:46 <zzing> I need to represent beta distributions in two different ways: Beta(p | r,s,a) and Beta(p | α, β) - I could use a Data type to represent them, and currently do for the one, but it would almost be better to have a function using one of them and do a partial application so that a parameter can be left for graphing. Can anyone give suggestions on the best way to look at this?
22:39:30 <kwos> is it somehow possible to write a function that takes a record and returns a list of all its field names?
22:40:20 <zzing> kwos, I am sure you could make something in template haskell that does that
22:40:25 <kwos> e.g. for data X = X { a :: Int, b :: Y } and data Y = Y { c :: Double, d :: String }, I'd like to get [ "a", "b", "c", "d" ]
22:40:46 <zzing> kwos, that is very much a metaprogramming kind of thing
22:41:01 <startling> kwos, I'm sure you could do it with template haskell
22:41:09 <startling> oh
22:41:13 <startling> jinx
22:41:13 <kwos> zzing: yeah I reckon that I may need TH
22:41:19 <kwos> I can do this sort of using sub: concatMap constrFields . dataTypeConstrs . dataTypeOf
22:41:27 <kwos> but that's only "first level"
22:41:28 <zzing> I wouldn't want to have to look into that :P
22:41:41 <startling> kwos, why do you want it?
22:41:50 <johnw> can you do this with Typeable?
22:42:00 <kwos> startling: in a bit more general problem, I have a few data types that I want to print as tables
22:42:25 <kwos> so I want something that generates "flattened" representation
22:46:20 <kwos> ideally I'd have something like "deriving Tabular" and then I get methods tblHeaders :: [String] and tblRow :: a -> [String] so I can print it
22:46:20 <kwos> or something along these lines.. any ideas how to bite this?
22:50:50 <zzing> kwos, one of the web frameworks did something with records, I forget which one
22:50:54 <zzing> or what it did
23:06:23 <zzing> Do we have an implementation of the gamma function somewhere?
23:07:28 <enthropy> hmatrix-special
23:08:35 <zzing> awesome
23:12:50 <zzing> What is the simplest type theory that could be experimented with? I wanted to understand type systems with implementation, and wanted something simple yet formal to start with.
23:16:04 <levi> Simply typed lambda calculus?
23:16:41 <levi> Check out the book 'Types and Programming Languages' by Benjamin Pierce
23:16:43 <zzing> Its fairly basic isn't it? Now I am not too far into lambda calculus itself, should I do stuff of that first?
23:19:09 * hackagebot Elm 0.9 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.9 (EvanCzaplicki)
23:19:41 <levi> Ooh, a new version of elm.
23:20:08 <zzing> hmm, too much magic?
23:20:54 <levi> Yay, unary negation!
23:21:00 <levi> Too much magic?
23:21:59 <zzing> levi, elm does look interesting, but it is magic in the sense that i usually would do that sort of thing by hand in a closer to javascript method - either with javascript or typescript
23:22:59 <levi> Oh, well, I think it's interesting as a language in itself, not necessarily as a 'write web apps' tool.
23:23:18 <zzing> oh this sucks
23:23:32 <dalaing1> zzing: TAPL is pretty awesome
23:23:33 <zzing> I wanted to have a Γ function
23:23:43 <zzing> But it is capital so it is a constructor
23:23:46 <levi> You might look at JMacro for doing Javascript stuff from Haskell.
23:25:46 <blackdog> levi: i've been playing around with elm today - it's fun, but a bunch of the code from the docs doesn't seem to compile with 0.8
23:27:49 <heath> within haskell, how would you say... "perform function, perform function, don't perform function, perform function perform function, don't perform function, etc..."?
23:28:00 <levi> 0.9 looks like a pretty solid improvement.
23:28:01 <mauke> heath: you can't perform functions, only apply them
23:28:23 <heath> apply fn, apply fn, don't apply fn, apply fn, apply fn, don't apply fn --then :)
23:28:32 <heath> and continue on until a certain limit
23:28:33 <mauke> you apply functions by writing 'f x'
23:28:39 <levi> To apply a function, you have to have something to apply it to.
23:28:41 <mauke> you don't apply functions by writing nothing
23:29:09 * hackagebot Elm 0.9.0.1 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.9.0.1 (EvanCzaplicki)
23:31:03 <zzing> :t fromRational
23:31:05 <lambdabot> Fractional a => Rational -> a
23:35:34 <levi> If you had a list of functions a -> b and a matching list of things a to apply them to, you could use Maybe a for the list instead of plain a, use Nothing for the functions you don't want to apply, and Just a for the ones you do. Then zip the lists together and map over them with a function that fmaps the fst of the pair onto the second one.
23:37:19 <ziman> 8~8
23:38:10 <levi> Hm?
23:40:34 <wunki> why does this work `L.readFile (file cmd) >>= mkThumbnail' ((100, 100), (400, 400))` and this doesn't:
23:40:39 <wunki> L.readFile $ file cmd >>= mkThumbnail' ((100, 100), (400, 400))
23:41:51 <enthropy> >>= binds tighter than $
23:42:08 <enthropy> so you're getting   L.readFile (file cmd >>= mkThumbnail' ((100, 100), (400, 400)))
23:42:23 <levi> Precedence rules suck.
23:42:51 <enthropy> well you can re-write it as   mkThumbnail' ((100, 100), (400, 400)) <=< L.readFile $ file cmd
23:42:56 <wunki> ah, ok
23:43:07 <wunki> ough, never came across `<=<` before
23:43:16 <wunki> I'm just writing my first Haskell program
23:43:23 <enthropy> or just use  (file cmd)
23:43:28 <levi> I am sympathetic to the designers of languages like Smalltalk and J that say 'screw operator precedence, we're not doing it!' and just let you deal with the idiom of the language instead of trying to make it 'mathy'.
23:43:31 <enthropy> that probably makes the most sense
23:43:55 <silasm> levi: I was about to mention J in response to that. But it certainly comes with its own set of problems. Fun language though.
23:44:31 <wunki> does this piece of code make you weep as a Haskeller: https://github.com/wunki/pinki/blob/master/src/Main.hs ?
23:44:32 <wunki> or am I on the right path? :)
23:50:07 <fragamus> howdy
23:52:01 <levi> wunki: Doesn't offend my sensibilities at all, but I haven't developed very refined taste in haskell yet.
23:52:27 <wunki> levi: good to hear, I'm struggling a bit, but it seems to be working
23:53:07 <notdan> looks alright to me
23:53:24 <levi> It's pretty imperative, but it's the sort of task that imperative monadic code was invented for.
23:54:00 <wunki> yeah, that was also my concern at the beginning, it's almost 100% imperative, but it's also a pretty imperative progam
23:54:22 <Saizan> wunki: a big main with many bindings makes it harder to follow the flow of information, better to split it up if it gets any longer
23:54:42 <wunki> Saizan: split it up by creating smaller functions you mean?
23:54:49 <orzo> Hello, I'm trying to debug some code that uses Data.Binary's Get monad.  Although it's written in do notation, it's pure and when i try to put traces on it, they are not forced reliably.  It's proving rather difficult to debug.  Anybody have any tips?
23:54:49 <Saizan> wunki: yeah
23:55:13 <wunki> Saizan: is it "idiomatic" to have the main at the top or the bottom of the file?
23:55:53 <levi> wunki: Also, haskellers typically don't bind a value to a name and immediately do an 'if' expression with a large body.
23:56:05 <Saizan> wunki: i've most often seen it at the bottom
23:57:11 <wunki> Saizan: ok, thanks
23:57:11 <Cale> orzo: The traces *will* appear if the expression in question is evaluated. If they're not appearing, you know that expression somehow isn't being used.
23:57:20 <wunki> levi: how would I rewrite that?
23:57:32 <orzo> Cale: well i realize the value must not be used
23:58:02 <Cale> Maybe put the trace on a nearby part of the action which you know is being executed?
23:59:26 <orzo> Cale: the code i'm trying to debug is originally form here: http://hackage.haskell.org/packages/archive/openpgp/0.6/doc/html/src/Data-OpenPGP.html
23:59:34 <orzo> Cale: parse_packet
23:59:53 <orzo> hm, is there a way for hackage to show line numbers?
23:59:55 <levi> Well, one way would be to wrap IO in a Maybe or Either Monad transformer to add exception-like semantics to the do block. But that would be a bit heavy for a little program like this.  So you might just put the original expression in a 'case' match instead of binding it and then doing an if.
