00:07:35 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
00:07:35 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
00:07:35 --- names: list (clog_ pi8030 kav_ kamatsu maoe1 diadara MOMI_ isomorphic doomlord_ kitallis joelb MrRacoon_ tensorpuddin Philonous__ kwos knyppeld1nan akraut_ jyyou_ strmpnk kshannon_ kryft_ Rarrikin1 mshroyer_ adlan_ CindyLin1 axiom tessier_ BMeph_ supersymmetry eff__ kubrat_ gbluma vili_ tomh-_ doomlord__ iulian_ Obfuscate` phar roconnor_ Ptival_ Guest53212 Bwild_ oldmanst1n maximums1eve noddy2OOO cynick_ pxqr Kuraitou sdx32 basdirks1 chairs_ Sculptor_ teodor98 Sixmsj)
00:07:35 --- names: list (slack1256 mno2_ fl00r phischu recycle senthilkumarv tov yopikh corkexaminer arpunk zhulikas fylwind ericmathison elton_ maxter bitonic` k0001 cleek_ ananthakumaran simukis_ Wizek kerrick jascase901 arlinius kcj applicative Spaceghost edwardk ersran9_ goldkatze [[zz]] tearful jbomo albel727 voxpopuli mrsolo Argue levi conal path[l] Desheng3 oleo preflex mauke dennylin93 otto_s fmapE shanse ssbr` hiratara Philonous_ ISF tobyo2 codesoup augur Betal tolt)
00:07:35 --- names: list (shrekster m3ga TDJACR ve xl normanrichards apaku Quadrescence mcw09 solrize xinming joneshf-laptop Ralith ormaaj jdegoes RichyB mjs2600 shepheb Cale enthropy mm_freak tpsinnem cdidd xpika ndonaldson fosky xymox sclv ryant5000 ski_ predator217 Beetny ecube litherum waterlaz sm desc|zenbook copumpkin rckrd pootler Patchou mbrock torkjak eff_ MercurialAlchemi danilo2 SegFaultAX poppingtonic totte nabilhassein mrcheeks Heffalump eis_ araujo markov_twain)
00:07:35 --- names: list (jack_rabbit weie_ supersym mendez jonsmock Sgeo martinalex Sculptor dabradley paddymahoney flux nominolo epsylon TallerGhostWalt doomlord jaimef thunderrd DrCode roconnor Lefeni Veltas kloplop321 dmwit callen Guest22019 dreixel wole dsp_ joe9 brandonw hiptobecubic ketil JesuZ Jaak Shou jeff_s1 latro`a_ adnap wto jang skchrko spaceships Tesseraction cods pygospa yacks YoungFrog Excureo Rarrikins bbloom Guest98659 ccasin destiny cdk benj_ mroman hamilyon)
00:07:35 --- names: list (liori strmpnk_ lieven_ d3lxa u_ noam JaRoel|4d bunzen mrowe_away zcourts smarter niko tomboy64 Swizec bscarlet hashcat shergill kludge` eevar skulls gienah SoupEvil Kabaka_ wtw m0g DolphR milessabin jdoles MrWoohoo PiepScuim sababa lunarjar mcbonz phienone andares warpy joefiorini joneshf-work sellout- aupiff otulp mnbernstein orospakr Twey jzelinskie stepcut parcs neptunepink s_quark ChongLi hiredman Krakarn pcapriotti mjo_ kxra dolio SLi k0ral OlegYch)
00:07:35 --- names: list (tsou mrpantoufle Nshag averell mmaruseacph2 Draconx knigitz ninegrid mannyv Khisanth companion_cube Erstarrung dacc perlite SirChurchill schroedinbug Mortomes gbarboza Neqoxec mavam morolin bethebunny DarkFox MouseTheLuckyDog DT` CODEtaku sudlowbot Dtgr identity yogurt_truck Morgawr finnrobi ggreg sclv_ n-dolio Baughn Jonno_FTW janinge dju Axman6 DarkNFoxy bergey aleator saep sinclair|net schoppenhauer ismlages Will| jobstijl rfw hive-mind Guest92121)
00:07:35 --- names: list (uu1101 hamishmack stass ezrios BMeph Shin-LaC AntiSpamMeta anders^^ ByronJohnson Tene kstuart tauntaun mimi_vx chirpsalot idoru CosmicRay fran hpd michaf jaepark s00pcan cyphase cronject kav Maxdamantus tunixman _flow_ mceier fxrh dcoutts jmct thetallguy _br_ Yawgmoth caleb_9 scottschecter gdeest chrra nwf robbert` nilg` Boreeas dixie dwcook Edoxile xenophon guymann zaphar_ps farn newsham brisbin timemage mononofu johnw fogus|gone sirspazzolot Nik05)
00:07:35 --- names: list (biscarch nopcode_ kakos Martty chrisdone stelleg ndngvr squimmy raid zoktar jml vmeson Kruppe dropdrive ibotty maksbotan hc thetallguy1 dsfox bcoppens Guest19190 lattenwald ljhms IanKelling EvanR hvr marienz tavelram cl_away ps-auxw talzeus_ cschneid ryanakca apples tertl3 centrinia Boney Draggor Adios miasma profmakx gereedy monochrom coeus_ mgsloan dthibodeau epta Counter-Strike nuttycom1 dfan knz byorgey swook` shachaf jrd0 doshitan burp dogmaT wimpunk)
00:07:35 --- names: list (kk1fff ParaSa1lin Ornedan twn MasseR wormphlegm fijimunkii td123 thorkilnaur Obfuscate shelf leroux lusory Nimatek iron_houzi ecc drmegahertz mxf wollw reactormonk jbauman akiress junsuijin fikusz mokus arkx jzl [swift] yam mami dwierenga aforemny schlumpi_ dumael zebr mlamari_ theDon dlundy DexterLB eyck saiam mimico__ Brando753 amatsu maoe jonke bd_ PHO_ ofan tragalo FreeFull drbean whaletechno edwtjo WhereIsMySpoon macron etrepum tahu adlan bind tych0)
00:07:35 --- names: list (solirc davidt Internet13 agundry dsirenko_ mkiefel suiside zenzike jroesch mviljamaa Mowah statusfailed Saizan gambogi ent aninhumer FireFly Plex- luite knyppeldynan lispy shiona jlouis othiym23 jix purefn eataix Vorpal tensorpudding M-ou-se mietek Cerise pi8029 copton_ janiczek prototrout Dybber mikeplus32 jackhill Svedrin FreakyPe1guin vpm dexter2 ircbrowse vili b2coutts fergusnoble hdevalence|away yan_ sunnavy Pengoo kqr1 fryguybob ousado slobo Nickeeh)
00:07:35 --- names: list (CindyLinz meretrix caligula djahandarie f8l aford vobi ernst palmje b_jonas gpampara_off \q ssttudder solancile mvj4 hape01 solution plhk krakrjak Belgarion0 chrisbuchholz drdo Eliel greymalkin philipde` blast_hardcheese tdammers pjstadig DrSyzygy b52 theorbtwo aoh `^_^v Ycros bens vsayer GaelanAintAround sunfun SHODAN otterdam geekosaur Mayzie c_14 FZ jaspervdj AlexWebr Chousuke Tarential Dodek Lemmih Th0mas Licenser Fubar^ jayne zorzar xorox90 ivan\)
00:07:35 --- names: list (gthorslund dino- stvc tarmo crs_ satshaba1 gbeshers rhodesd jcp Razz vehk ninzine kfreds ParahSailin jrslepak NeatBasis MOMI wilfredh tylergillies_ Kobata akahn lopex samrat Polarina quaestor mapreduce bartavelle ocharles __main__ bobthenameless canta dpwright bstrie s4msung Dashkal ido cow-orker ggherdov brainproxy Zariel jb55 Ghoul_ sgso si14 ivan` tomh- myme zero7 Pad^ froztbyte tew88 udevd mike2 SaBer integral supki ejls poucet ab9rf melter mephx)
00:07:35 --- names: list (troydm jonsterling gnoel lokydor lulf qz_ pr lahwran relrod dyspeptics15 joelteon mstksg Natch tero- eacameron Gunni Guest80998 mrd milli tippenein vvv d-snp_ yano elgot k00mi bsmt ghorn isomorphismes pyrtsa gds jliikka divarvel petantik mixi majoh kekimmo bitraten saiam^ joeyh lpaste KaneTW flazz vnz Walther Ptival Kinnison arcatan pyykkis_ OrangeDu1k sipa notdan taylorgb_ kosmikus tromp__ Blkt upgrayeddd kubrat KyleCloud vivekrai Xorlev akraut)
00:07:36 --- names: list (chickenflu shennyg IbnFirnas ehd jodaro aloiscochard Raynos charlesofarrell_ puzza007 bobry idnar tomprince liyang chexxor nkpart mechairoi Nahra lambdabot mirsal zrot juuhaa Enigmagic ysuzuki phryk McManiaC ibab go|dfish popx joar clog ClaudiusMaximus ziman heath scshunt xplat tg RevJohnnyHealey Tinned_Tuna mshroyer davorak neektza1 geoffh raft Excedrin n00dle MK_FG edk ft brixen thorsten` tudalex swistak35 tehroflmaoer Riussi Hafydd pikhq srcerer)
00:07:36 --- names: list (ciaranm seantallen Amadiro yriw s4muel zomg mlh alexsdutton dsantiago k4nar Fuuzetsu frontendloader Deewiant bentrevor Vertue asjo Iceland_jack xye machisuji Jaxan shajra Athas mee killy9999 jmcarthur Phlogistique sleepybug sajith osfameron udoprog joogi barrucadu fry mjrosenb mel- rgrinberg gseitz carter cheezey hfaafb flori_ mantovani xenocons ahihi bergmark MrRacoon bbee absence katis redjohn Vq thomassgn bduc satshabad osnr mgaare mak` canissimia)
00:07:36 --- names: list (sordina andrewsw fabjan zenoli og haasn dan64 davean MetaCosm b0c1 arnsholt peddie taruti so Igloo rasmusto simon ccxCZ Tehnix felipe_ Liskni_si tomaw rpenguin_ hpc aristid guerrilla KitB tulcod adimit alpounet cajla mrshoe Ke tridactyla BigEndian wunki `0660 tomejaguar munro Khady robinbb Adeon DustyDin1o demolithion dyreshark mmathis gilbertw1 lenstr Jello_Raptor Gracenotes threedaymonk Sunhay_ DigitalKiwi acfoltzer lightquake mortberg inr valdyn dqd)
00:07:36 --- names: list (colah jyyou xnyhps anhall machisuji_ Tekerson arkeet kloeri Odd_Bloke FUZxxl _janne drewr jrib Raynes quicksilver Bigcheese alej qwandor eL_Bart0 kini jhh banjiewen palaga Eridius brett cmsd2 neurocyte arbn bogner electrogeek BrianHV earthy bezik mero koala_man linduxed noplamodo nxorg8 thirsteh mlinksva zerokarmaleft Valodim hackagebot `bps kshannon h_chiro_ stiell alexander__b int-e Tribal kaw ReinH bogner_ dustinswan gemelen Hardolaf peltchu gbluma_)
00:07:36 --- names: list (Laney Elision Gothmog_ kranius deggis mux a11235 ahf BlastHardcheese jlewis duairc JPohlmann Cryovat brendan saurik Maior mollerstrand ehamberg skypers briden mornfall kaol ttm pqmodn malorie_ dilinger_ thoughtpolice mr- sohum nikola zw01 fall_ bgamari Watcher7 kryft Sagi TheSpectre Kneiva rs0 bxc SuperNoeMan stomp opqdonut petanqk liszt jkpl nicoo solarus danr cross Rutger`_ dario^CIP ion klugez gridaphobe wereHamster TML prophile pfoetchen Rembane)
00:07:36 --- names: list (Proteumus mattp_ @ChanServ tamiko pnielsen wagle magicman Clint sp3ctum cruxeternus pharaun ericmj bqp XMunkki_ elliott deavid asante tessier Ulrar Starfire_ nlogax willb1 necroyeti yeltzooo dmp1ce jamwt cjay Spockz def-lkb zaiste aszlig ibid Reisen ipuustin geal inarru betawaffle lpsmith horlicks zeiris_ almondjelly Ezku anachron mkrull confound xaimus Yaniel)
00:08:21 <kwos> oh, QuickCheck has something (~==?) :: (AEq a, Show a) => a -> a -> Result
00:10:29 <kwos> yopikh: yo!
00:10:53 <kwos> too damn hot to go out, time to write some Haskell :)
00:20:41 <turiya> for printing the list [0..512*512-1], the total alloc = 52,669,024 bytes. The total memory needed for storing the list is 512*512*8 = 2,097,152 bytes. Why is the total alloc much more than this? Is it due to the printing?
00:22:49 <pxqr> any http lib to encode/decode requests and responses?
00:23:33 <pxqr> http-types do not provide request and response types
00:23:50 <newbie> hello
00:23:58 <pxqr> while the HTTP package do not allow "*" in start-line
00:24:21 <Guest43682> with x:xs i say head plus list
00:25:24 <augur> turiya: how are you calculating that
00:25:29 <pxqr> turiya: did you specify -O2?
00:26:10 <Guest43682> but how can i say list plus tail? It should work like addToList e (xs:s)
00:26:13 <turiya> i used the -prof and -fprof-auto and ran with +RTS -p
00:26:15 <augur> turiya: that is to say, elaborate on why you think 512*512*8 makes sense
00:26:18 <turiya> i did specify O2
00:26:27 <pxqr> list additionaly takes around 3 words per elem
00:26:55 <pxqr> + unboxed Int take one 2 words
00:27:01 <turiya> oh.. the list length is 512*512 and eight bytes for storing each element
00:27:21 <ski_> Guest43682 : "tail" is always a list. perhaps you meant "list (i.e. init) plus last" ?
00:27:33 <pxqr> turiya: 3 + 2 = 5 words per element
00:27:36 <ski_> > (init &&& last) "list"
00:27:39 <lambdabot>   ("lis",'t')
00:27:47 <Guest43682> ski_: yes, for recursion
00:27:51 <turiya> pxqr: why 3+2?
00:28:05 <Guest43682> addToList e [] = [e]
00:28:22 <Guest43682> addToList e (xs:x) = some_logic
00:28:27 <ski_> Guest43682 : in general, that's a bad idea (it's inefficient -- if you want this, either initially reverse the list, or use another data structure=
00:29:09 <ski_> given a non-empty list, you can directly access its head (first element) and tail (list of all the rest of the elements, possibly zero of them)
00:29:33 <ski_> you can't directly access the last element, nor the list of the initial elements (all but the last element)
00:29:44 <augur> Guest43682: you might also want to consider whether you need access to both ends of the list
00:29:52 <ski_> the only way to reach those is by going *via* the "head plus tail" representation
00:29:56 <augur> if the answer is no, then you should just treat the whole list as "backwards"
00:30:00 <turiya> what is the amount of memory required to store a list of size n (Ints)
00:30:28 <pxqr> [1,2] = {:#, head_ptr = {Int#, 1#}, tail_ptr = {:#, head_ptr = { Int#, 2# }, tail_ptr = { []# } }}
00:30:30 <augur> turiya: going by what pxqr said, 5n words
00:30:51 <augur> whatever a word is here
00:31:05 <Kinnison> s/word/pointer/
00:31:13 <Guest43682> ski_: well, i'll try queue then
00:31:29 <Guest43682> ski_: thought list is two-sided
00:31:31 <Kinnison> In essence, it's hardware and implementation dependent
00:31:41 <ski_> Guest43682: btw, wb from earlier
00:32:02 <Guest43682> ski_: wb?
00:32:03 <turiya> i see, so the remaining is the overhead for printing
00:32:05 <ski_> the standard "list" type in Haskell is singly-linked lists
00:32:14 <ski_> Guest43682 : meaning "welcome back"
00:32:20 <Guest43682> ski_: ah =)
00:32:22 <augur> Kinnison: indeed, but that maps to some hardware specific thing in this case :)
00:32:43 <augur> using pxqr's numbers, turiya's system has words of length 40.1832763671875
00:32:55 <ski_> Guest43682 : but also see what augur said, in case you missed it
00:33:14 <pxqr> augur: well, we can floor that to 40 :)
00:33:15 <augur> which suggests he's on a 32 bit-word system, and the extra overhead is from the printing
00:33:17 <turiya> is there a way to check word size in haskell
00:33:40 <augur> pxqr: do systems ever use non-2^n memory content sizes?
00:33:48 <Guest43682> ski_: i need only access from end of list. But reversing is bad idea, due to performance
00:33:50 <Quadrescence> 36 bits!
00:34:49 <pxqr> augur: I don't know; do you mean something like data Foo = Foo {-# UNPACK #-} !Word8 {-# UNPACK #-} !Word8   ?
00:34:49 <ski_> Guest43682: why is reversing bad, if you only do it once (or maybe twice) ?
00:35:47 <augur> pxqr: i mean it seems unlikely that any memory manufacturer is mapping each address to a non-2^n-sized location in memory
00:36:14 <ski_> Guest43682: are you attempting to write an incremental algorithm ? iow one which can process through a list without the whole list needing to fit in memory at any one time ?
00:36:33 <Guest43682> ski_: in algorithm, i add many elements, and every time i will reverse this list, so the number of reversions is much more then 2
00:36:38 <ski_> Guest43682: where is the list coming from ?
00:37:00 <ski_> Guest43682 : why reverse every time you add elements ?
00:37:08 <ski_> do you need to add both to front and back ?
00:37:12 <ski_> or only to back end ?
00:37:27 <Guest43682> ski_: in fact, i have next task. A list (let it be list) is like [(1, 2), (3, 4), (10, 20)]
00:37:47 * ski_ awaits an answer :)
00:37:54 <pxqr> augur: i don't know;
00:37:55 <turiya> i have 20% alloc for the list in the main and the rest should be for printing then? this means that more memory has been allocated for printing than to generate the list
00:38:11 <Guest43682> ski_ when i add new element (Double, Double), it must stay between two nearest points
00:38:22 <mauke> Guest43682: why?
00:38:37 <ski_> Guest43682 : do you only need to add elements at the end ?
00:38:48 <Guest43682> ski_: e.g. add (6, 8) -> [(1, 2), (3, 4), (6, 8), (10, 20)]
00:38:57 <ski_> hm, ok
00:39:09 <ski_> that looks like insert-in-sorted-list
00:39:16 <Guest43682> ski_: yes
00:39:37 <ski_> so then another data structure would be better than a list
00:39:47 <Guest43682> ski_: and inner pairs never intersects
00:39:55 <ski_> a `Set', e.g.
00:40:15 <Guest43682> ski_:, yes, i'm googling about queues, found a good post on SO
00:40:34 <ski_> (if you want to implement it yourself, try some variant of search trees)
00:41:36 <ski_> queues are probably not good (unless perhaps if you mean priority queues)
00:41:56 <Guest43682> ski_: its basics, so should be already implemented
00:42:06 <ski_> queues typically have efficient adding to one end and removing from the other end (and perhaps also vice versa)
00:42:18 <ski_> while you seem to be wanting to insert in order
00:42:30 <turiya> augur:  (52,669,704 * 0.2) / (512*512*5) = 0.8 < 1 (the 0.2 is for the 20% alloc for the list), so may be the whole list is not stored in memory then?
00:42:52 <augur> turiya: who knows!
00:43:27 <Guest43682> ski_: an ideal variant would be (xs:x), but it is impossible
00:44:14 <turiya> so, it is hard to understand where memory is being used..
00:45:32 * hackagebot crypto-random 0.0.2 - Simple cryptographic random related types  http://hackage.haskell.org/package/crypto-random-0.0.2 (VincentHanquez)
00:48:31 * ski_ idly wonders why `ViewPatterns' aren't enabled in lambdabot
00:49:10 <ski_> Guest43682 : `((init &&& last) -> (xs,x))' would work, but you don't want it
00:49:28 <ski_> (because it's inefficient)
00:53:02 <pxqr> > 512*512 * 5 * 8 + 512 * 512 * 7 * 2 * 8
00:53:03 <lambdabot>   39845888
00:53:45 <augur> > 512*512*5*32
00:53:46 <lambdabot>   41943040
00:54:17 <Guest43682> ski_: well, i do another thing. I reverse list from beginning. So not [(1, 2), (3, 4), (10, 20)] but [(20, 10) ,(4, 3), (2, 1)]
00:54:42 <Guest43682> ski_: then seems like i can work with simple list
00:54:45 <pxqr> maybe show takes 7 chars per number
00:54:51 <ski_> well, it won't help if you want to add stuff into the middle of it
00:55:12 <Guest43682> ski_: i ll show a code a bit later
00:55:12 <adnap> Why does isEOF block?
00:55:18 <adnap> after calling getLine
00:57:08 <mauke> so it can tell you whether it's reached the end of the file
00:59:44 <lpaste> adnap pasted “eof block” at http://lpaste.net/92356
01:00:33 <adnap> mauke: If I type something which does not contain EOF and press enter, why should isEOF block?
01:01:16 <pxqr> when blah (return ()) makes no sense
01:02:25 <mauke> adnap: "contain EOF" makes no sense
01:02:26 <adnap> pxqr: It could also be when (not eof) loop
01:02:38 <ski_> adnap: the `when' won't do what you probably intended it to do
01:02:43 <adnap> mauke: When I press enter and not CTRL+D
01:02:57 <adnap> ski_: It seems to
01:02:57 <mauke> where/when?
01:03:11 <mauke> and yeah, you're not actually using eof anywhere
01:03:18 <adnap> wtf
01:03:23 <adnap> isEOF
01:03:31 <adnap> ...is in there
01:03:32 <mauke> whole sentences, please
01:03:47 <adnap> What do you mean I'm "not actually using eof"?
01:03:56 <ski_> adnap `when (...) $ return ()' is equal to `return ()' (assuming `...' isn't bottom)
01:03:58 <mauke> what I said
01:04:13 <mauke> the value of eof has no effect on the behavior of the program
01:04:35 <adnap> I thought when does the IO when the first argument is True
01:04:39 <knz> hi all
01:04:39 <mauke> correct
01:05:03 <ski_> adnap : you are probably misunderstanding the effect of `return ()'
01:05:08 <knz> maybe dumb question: I have a function "rgb2gray f ix = f1 (rgb f ix)" which types properly; but "rgb2gray = f1 . rgb" doesn't
01:05:17 <adnap> ski_: Yes
01:05:20 <Guest43682> ski_: well, indeed, that didn't help. I really need insert into sorted list
01:05:22 <ski_> `return ()' is simply an `IO'-action that does nothing interesting
01:05:23 <adnap> ski_: I forgot that return doesn't exit the program
01:05:23 <knz> what am I missing?
01:05:37 <mauke> knz: rgb2gray f = f1 . rgb f
01:05:40 <adnap> I will change it to "when (not eof) loop"
01:05:44 <pxqr> misunderstanding could be shrinked to just return using QC terms
01:05:51 <ski_> in particular, `return ()' does not "cause the containing function to return" (whatever that would mean here)
01:05:59 <mauke> knz: rgb2gray = (f1 .) . rgb
01:06:19 <ski_> adnap : that's better. `unless eof loop' would also work, in case you prefer that
01:06:44 <knz> mauke: aha
01:06:56 <ski_>   rgb2gray f ix = f1 (rgb f ix)
01:07:03 <ski_>   rgb2gray f ix = f1 ((rgb f) ix)
01:07:12 <ski_>   rgb2gray f ix = (f1 . rgb f) ix
01:07:18 <ski_>   rgb2gray f = f1 . rgb f
01:07:26 <ski_>   rgb2gray f = (f1 .) (rgb f)
01:07:27 <pxqr> > :i :.
01:07:28 <lambdabot>   <hint>:1:1: parse error on input `:'
01:07:33 <ski_>   rgb2gray f = ((f1 .) . rgb) f
01:07:37 <pxqr> @ty :.
01:07:38 <ski_>   rgb2gray = (f1 .) . rgb
01:07:39 <lambdabot> parse error on input `:.'
01:07:51 <ski_> @type (.:)
01:07:52 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
01:08:04 <pxqr> yep
01:08:33 <knz> wut
01:08:52 <ski_> knz : if you use `infixr 9; (.:) = (.) . (.)' (or defined as `(f . g) x y = f (g x y)', if you prefer), you get `rgb2gray = f1 .: rgb'
01:08:55 <lpaste> adnap annotated “eof block” with “eof block (annotation)” at http://lpaste.net/92356#a92358
01:09:16 <adnap> I still don't understand why the first line is not printed right away
01:09:35 <ski_> knz : did you follow the above step-by-step refactoring of the `rgb2gray' definition ?
01:09:56 <mauke> adnap: because null (f x) has to evaluate f x before it can return a result
01:09:57 <arkeet> adnap: huh? it's waiting for getLine
01:09:58 <knz> ski_: yeah, ut I had missed the definition of .:
01:10:17 <adnap> mauke: null?
01:10:21 <ski_> knz : if you want to, i can continue from above
01:10:22 <what-is-this> Hi all, I'm trying to model continuations that call the provided function exactly once (well, perhaps these objects are not continuations).. does anything like this exist?
01:10:24 <ski_>   rgb2gray = (f1 .) . rgb
01:10:27 <adnap> arkeet: I mean after I type something and press enter
01:10:32 <knz> ski_: it's fine, I got that
01:10:34 <knz> (and it works)
01:10:37 <ski_>   rgb2gray = (.) f1 . rgb
01:10:38 <mauke> adnap: what programming languages do you know?
01:10:45 <ski_>   rgb2gray = (.) ((.) f1) rgb
01:10:48 <adnap> mauke: C, C++, Java, and Haskell
01:10:54 <ski_>   rgb2gray = ((.) . (.)) f1 rgb
01:10:58 <ski_>   rgb2gray = (.:) f1 rgb
01:11:01 <mauke> adnap: not Haskell if you don't know null
01:11:02 <ski_>   rgb2gray = f1 .: rgb
01:11:13 <adnap> mauke: null checks if a list is empty, right?
01:11:16 <mauke> yes
01:11:20 <knz> more general question: is there an operator (or is it possible to define one) which captures this pattern generally?
01:11:24 <adnap> mauke: I don't know why you mentioned it. It's not in my code
01:11:28 <mauke> and isEOF checks whether you've reached the end of an IO stream
01:11:35 <mauke> it's analogous
01:11:42 <adnap> mauke: Please don't pick on me
01:11:47 <ski_> knz : so, the basic answer to why your original attempt didn't work is that `.' only "transmits one argument into the right function"
01:11:48 <pxqr> knz: dot rule?
01:11:59 <mauke> adnap: please don't play dumb
01:12:04 <adnap> mauke: I'm not
01:12:06 <knz> like if I have f :: a->b and g :: x->y->...->a, have some syntax f OP g that has type x->y->..->b ?
01:12:07 <ski_> knz : see the definition of the `.:' operator above
01:12:09 <mauke> adnap: me neither
01:12:20 <mauke> a list is either empty or a cons of an element and the rest of the list
01:12:29 <mauke> an IO stream is either at EOF or contains a Char and the rest of the stream
01:12:51 <ski_> knz : oh, you mean for any number of curried arguments -- i don't think so, at least not without scary (well) type class stuff
01:13:00 <knz> o
01:13:01 <knz> k
01:13:10 <mauke> now, how can isEOF tell which it is?
01:14:38 <what-is-this> anyone? basically, Cont' :: (a -> m r) -> m r; but the argument can be called exactly once - anything like this or similar?
01:14:42 <adnap> mauke: isEOF could look at the last character that was buffered and base the result on that
01:14:56 <mauke> adnap: how would that help?
01:15:05 <mauke> also, what do you mean by buffered?
01:15:24 <adnap> mauke: Because then when I type "hello" and press enter, isEOF would know based on those actions that EOF has not been reached yet
01:15:31 <mauke> how would it know?
01:15:32 <Kinnison> If the stream is stdin fr.ex. then the process won't get any more bytes after the enter
01:15:37 <Kinnison> the read() would block
01:15:40 <Kinnison> thus isEOF() would block
01:15:54 <Kinnison> because it cannot find another character or the EOF indicator until read() returns
01:16:00 <mauke> adnap: getLine would consume "hello\n", and then isEOF has an unknown stream
01:16:17 <adnap> mauke: isEOF could look at \n : unknown stream
01:16:22 <mauke> there is no \n
01:16:27 <mauke> getLine has already consumed it
01:16:38 <Kinnison> indeedy
01:17:16 <adnap> What does Ctrl + d do?
01:17:28 <mauke> sends a virtual EOF, effectively
01:17:34 <adnap> Is that a characteR?
01:17:36 <mauke> no
01:17:52 <adnap> How does isEOF know that a stream is empty?
01:18:00 <Kinnison> because read() returns zero
01:18:06 <mauke> how does null know a list is empty?
01:18:10 <mauke> [] isn't an element
01:18:58 <adnap> I guess I don't know how to make my program do what I want. I guess I will make it exit when one types "quit" or something
01:19:11 <mauke> what do you want it to do?
01:19:17 <ski_> what-is-this : perhaps try "Linear Continuation-Passing" and "Linearly Used Continuations" at <http://www.cs.bham.ac.uk/~hxt/research/hayo-thielecke-publications.shtml> by Hayo Thielecke et al. ?
01:19:30 <adnap> I just want it to print lines that were read immediately after enter is pressed, and stop immediately after Ctrl + D is pressed
01:19:38 <adnap> (d
01:19:39 <adnap> *d
01:20:06 <mauke> loop = eof <- isEOF; when (not eof) $ do s <- getLine; putStrLn s; loop
01:20:33 * hackagebot crypto-numbers 0.2.0 - Cryptographic numbers: functions and algorithms  http://hackage.haskell.org/package/crypto-numbers-0.2.0 (VincentHanquez)
01:20:38 <adnap> mauke: Thanks. I didn't think of that
01:20:41 <pharaun> pxqr: if you find a http library for encoding/decode requests/responses i would be interested in it :)
01:20:53 <Kinnison> getContents >>= putStr
01:20:54 <mauke> you can tell your original structure can't be right because it doesn't handle empty input
01:21:07 <mauke> also, I normally wouldn't use isEOF
01:21:09 <adnap> I don't understand
01:21:22 <mauke> adnap: what if there are 0 lines?
01:21:27 <pxqr> http-types seems like near that I need, but there are no request/response types
01:21:28 <mauke> your original code always calls getLine
01:21:36 <pxqr> just headers, methods etc
01:21:36 <adnap> mauke: Then wouldn't EOF be reached immediately?
01:21:41 <mauke> adnap: yes
01:21:45 <what-is-this> ski_: that looks promising - Do you think it can be enforced at the type level though? A cursory glance seems to indicate that they prove equivalence between general continuations and linear continuations.
01:21:47 <mauke> that's the problem
01:21:53 <adnap> Oh, getLine blocks?
01:21:57 <adnap> If there is no input?
01:22:00 <mauke> no
01:22:05 <mauke> how would that make sense?
01:22:11 <pxqr> pharaun: however I think I'll just use http-types
01:22:16 <ski_> what-is-this : i suspect not, if you mean by the type level in Haskell
01:22:24 <adnap> What is wrong with calling getLine first if there are 0 lines?
01:22:29 <mauke> "read a line. if you've reached the end of the file, block forever"
01:22:41 <Kinnison> adnap: If you're just experimenting and want something which reads lines, runs a function over them, writes the result out, etc.  then look at interact
01:22:45 <Kinnison> @hoogle interact
01:22:45 <lambdabot> Prelude interact :: (String -> String) -> IO ()
01:22:45 <lambdabot> System.IO interact :: (String -> String) -> IO ()
01:22:45 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
01:22:50 <adnap> Kinnison: I don't
01:22:55 <Kinnison> aah okay
01:22:58 <what-is-this> ski_: I see. Do you think this requires dependent types? (I've a similar question, which I'm pretty sure would require dependent types.)
01:22:58 <mauke> adnap: what could it possibly do?
01:23:02 <pharaun> pxqr: fair enough :)
01:23:05 <adnap> mauke: What is "it"?
01:23:11 <pharaun> i'll dig into http-types then
01:23:12 <mauke> I mean, I know what it actually does, but what choice does it have? (it = getLine)
01:23:19 <ski_> what-is-this : no. i think it requires linear types
01:23:31 <adnap> mauke: I don't know how to answer these questions. They're rhetorical
01:23:46 <mauke> they're not
01:23:46 <Kinnison> adnap: Your code has a bug -- if the input is empty, then getLine will throw an exception
01:23:55 <adnap> Kinnison: Thank you
01:24:01 <Kinnison> adnap: Always check the exit case first
01:24:17 <adnap> Kinnison: I didn't know getLine did that, and I'm reading from standard in, so I wouldn't know how to specify no input
01:24:28 <Kinnison> < /dev/null
01:24:31 <Kinnison> is an obvious way
01:24:34 <what-is-this> ski_: "linear types", TIL
01:24:37 <mauke> or press ctrl-d
01:24:41 <Kinnison> indeed
01:24:49 <knz> mauke, ski_: http://pastebin.com/fVjDw7CY -- thanks!
01:24:54 <mauke> The paste fVjDw7CY has been copied to http://lpaste.net/92360
01:25:04 <mauke> some possible choices: it could throw an IO exception (this is what it actually does), call 'error', or return an empty string
01:25:07 <adnap> Pressing Ctrl-d exits the program. Perhaps I didn't realize that...
01:25:11 <mauke> or your suggestion: it could simply not return, blocking forever
01:25:19 <adnap> Is "eof.hs: <stdin>: hGetLine: end of file" an error?
01:25:25 <mauke> it's an exception
01:25:33 * hackagebot crypto-pubkey 0.2.0 - Public Key cryptography  http://hackage.haskell.org/package/crypto-pubkey-0.2.0 (VincentHanquez)
01:25:35 * hackagebot cprng-aes 0.5.0 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.5.0 (VincentHanquez)
01:25:36 <ski_> what-is-this : alternatively, you could try to settle for a dynamic check on the use-once (though that is probably bound to degrade to just use-at-most-once, see e.g. `call/1c', e.g. mentioned at <http://lists.gnu.org/archive/html/guile-devel/2001-03/msg00030.html>)
01:25:39 <mauke> or rather, the result of not catching the exception
01:25:41 <adnap> Okay
01:25:47 <mauke> you get an error message on stderr and the program exits
01:27:09 <ski_> what-is-this : linear types comes from linear logic, via the Curry-Howard correspondence
01:28:19 <ski_> what-is-this : also note that linear types are distinct from uniqueness types as in Clean and Mercury (which ensures that you can sometimes safely use update-in-place to construct a new value from an old one, since there are no other references to the old one)
01:29:17 <ski_> what-is-this : iirc, Wadler has some paper re linear types
01:29:51 <what-is-this> ski_: yep, "linear types can change the world" by him seems quite accessible.
01:29:51 <ski_> (though possibly also mentions (confuses with ?) uniqueness types)
01:30:09 <newbie2_> well, insert from Data.List helped me. I'm not sure about good O( ), but i can later change adding
01:30:33 * hackagebot tls 1.1.3 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.1.3 (VincentHanquez)
01:30:57 <ski_> what-is-this : for uniqueness types, check out Clean (the other lazy functional language), and Mercury (the logic/functional language with a static mode and determinism system (in addition to type system))
01:33:24 <pxqr> hm, tls package seems pretty mature, does there are native https lib based on the tls?
01:36:17 <what-is-this> ski_: thanks for the pointers! linear types seems exactly the thing I want - though I'll probably need more time to completely grok it.
01:41:28 <ski_> what-is-this : see <http://www.mercurylang.org/> and <http://wiki.clean.cs.ru.nl/Clean> for those two languages
01:43:09 <ski_> what-is-this : also lolli <http://www.lix.polytechnique.fr/~dale/lolli/>, a(n intuitionistic) linear-logic based logic programming language might be interesting (also see <http://www.cs.rmit.edu.au/lygon/> for a take on classical linear logic)
01:43:47 <ski_> what-is-this : .. are you familiar with any logic programming language or technique ?
01:44:31 <newbie2_> one more newbie question. In http://pastebin.com/QThQMd1s, how do i use strike with damage parameter?
01:44:32 <mauke> The paste QThQMd1s has been copied to http://lpaste.net/92361
01:44:37 <what-is-this> ski_: no, unfortunately.
01:45:33 <ski_> what-is-this : then it would possibly be simplest to start with Prolog
01:45:33 * hackagebot tls 1.1.4 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.1.4 (VincentHanquez)
01:45:35 * hackagebot tls-extra 0.6.5 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.6.5 (VincentHanquez)
01:45:48 <ski_> there's a ##prolog channel here. there's also a #mercury channel
01:46:42 <what-is-this> ski_: prolog is certainly very high up on my should-learn-someday list. I was hoping though that I might be able to model this linear type construction somehow in haskell (since that's the thing I'm currently trying to learn).
01:46:49 <newbie2_> execStateT strike 100 initialState fails
01:47:27 <ski_> what-is-this : yes, the logic programming aspects of it are distinct (but related to) the typing aspects of it
01:48:07 <what-is-this> ski_: unfortunately, not being even slightly acquainted with type systems, I can't even tell at a glance whether what I want is even possible in haskell! perhaps I should invest more time in learning basics of type systems - any pointers to how does one go about learning type systems and type inference?
01:48:20 <ski_> newbie2_ : just guessing here, perhaps you meant `execStateT (strike 100) initialState' ?
01:49:06 * ski_ looks at the paste
01:49:37 <newbie2_> ski_: yes, thanks
01:49:45 <ski_> newbie2_ : `d do ...' ?
01:50:33 * hackagebot tls-debug 0.2.5 - Set of programs for TLS testing and debugging  http://hackage.haskell.org/package/tls-debug-0.2.5 (VincentHanquez)
01:51:10 <newbie2_> ski_: and one more question : is it possible to remove IO this code?
01:51:28 <newbie2_> ski_: and one more question : is it possible to remove IO _from_ this code?
01:52:10 <ski_> what-is-this : you could try "Polymorphic Type Inference" by Michael Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.pdf>, istr it being relatively easy-going
01:52:35 <ski_> what-is-this : as to linear types, i suspect you can't have them in Haskell without extending the type system
01:52:48 <newbie2_> ski_: StateT requires a monad, so can i put some empty one?
01:53:11 <ski_> newbie2_ : it uses `putStrLn', so no, you can't remove `IO' from it
01:53:26 <arkeet> you might be able to move it elsewhere, though!
01:53:31 <newbie2_> ski_: forgot, ofc without that line
01:53:48 <newbie2_> ski_: just health -=
01:54:02 <ski_> then you could have `StateT Game Identity ()' or `State Game ()' e.g.
01:54:11 <what-is-this> ski_: wow, that tutorial seems awesome,  thanks!
01:54:11 <arkeet> or Monad m => StateT Game m ()
01:54:15 <ski_> yes
01:54:38 <ski_> or `MonadState Game m => Damage -> m ()'
01:55:06 <arkeet> or that yeah
01:55:07 <ski_> (obviously `Damage ->' would be present in some place in the earlier alternatives, as well=
01:55:10 <ski_> )
01:55:10 <mm_freak> type IShouldReallyUseFunctionalReactiveProgrammingBecauseGlobalStateBasedGamesSuckT = StateT Game
01:55:18 <arkeet> :p
01:55:57 <ski_> i thought the point of the state monad was to not have global state ;P
01:56:39 <newbie2_> well when i have smth like a game, there is no way except State Monad to code it, isn't it?
01:56:46 <arkeet> false!
01:57:03 <arkeet> let mm_freak tell you about frp.
01:57:22 <knz> another question: how can I explicitly import the constructor ":." from Data.Array.Repa.Index? (http://hackage.haskell.org/packages/archive/repa/3.2.2.3/doc/html/Data-Array-Repa-Index.html)
01:57:22 <arkeet> I probably should have a look at netwire at some point.
01:57:38 <knz> I try to write import Data.Array.Repa.Index (:.) but that does not work
01:57:41 <arkeet> knz: import blah ((:.))
01:57:44 <knz> nope
01:57:46 <arkeet> yes
01:57:48 <arkeet> double parentheses
01:58:00 <arkeet> because "(:.)" is the name of the thing you're importing.
01:58:12 <mm_freak> ski_: StateT is global state
01:58:21 <mm_freak> when used in a game
01:58:23 <knz> arkeet: it's a constructor, not a function
01:58:26 <knz> t.hs:18:8: Not in scope: data constructor `:.'
01:58:27 <arkeet> I know!
01:58:38 <arkeet> ah. that imports the type, I guess.
01:58:42 <arkeet> ((:.)(..))
01:58:42 <arkeet> ;)
01:58:52 <ski_> newbie2_ : e.g. instead of a state-monad, you *could* use plain explicit state-passing/threading-style, as per "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> (before the monadic stuff is introduced)
01:59:02 <mm_freak> knz: ((:.)(:.))
01:59:08 <mm_freak> knz: ((:.)((:.)))
01:59:11 <knz> this syntax is awful :)
01:59:15 <mm_freak> a bit awkward, yeah
01:59:22 <ski_> mm_freak : depends on how far the state "reaches", no ?
01:59:27 <knz> :t (..)
01:59:27 <lambdabot> parse error on input `..'
01:59:35 <ski_> (though i agree with you in some sense)
01:59:37 <arkeet> import Module (Foo(..)) imports Foo and all its constructors.
01:59:42 <knz> aha
01:59:43 <knz> k
01:59:43 <knz> thx
01:59:54 <mm_freak> ski_: in a game it probably reaches very far =)
02:00:08 <mm_freak> likely over the entire application, but in the best case over a game session
02:00:16 <mm_freak> the latter isn't much of an improvement
02:00:21 <adnap> Well this is fun:
02:00:28 <adnap> >   [Act: 1,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34]  [1|(status)   2|(msgs)     3|#haskell   4|##japanese 5|#japa~utf8 6|#gentoo    7|#gentoo-ja   ]   [8|#anime     9|#hask~blah 0|##club~ntu q|#wanikani  w|##physics  e|#BDS~unity r|#darcs       ]   [t|#fsf       y|##law      u|##cars     i|##ele~nics o|#grub      p|##crypto   a|#ratpoison   ]
02:00:30 <lambdabot>   Not in scope: data constructor `Act'Not in scope: `status'
02:00:30 <lambdabot>  Perhaps you mea...
02:00:39 <adnap> Err, woops
02:00:40 <adnap> lol
02:00:41 <arkeet> what
02:00:46 <adnap> pted.
02:00:53 <adnap> > let f, g :: Int -> Int; f x = g x; g x = f x in f 2
02:00:56 <ski_> mm_freak : i just attempting to argue that you probably *could* localize the state in it quite some more
02:00:59 <Ghoul_> I find that every time I go to write a real world thing I start with a state transformer
02:01:00 <lambdabot>   mueval-core: Time limit exceeded
02:01:22 <adnap> I always get screwed over by the middle-click
02:01:26 <Ghoul_> and then realize I need a pipe transformer or something, so I wrap that in. Then I need IO, so I refractor that. Then I need EitherT or Error or something like that
02:01:37 <Ghoul_> and a few days of development later I have a 5-trans stack :(
02:01:43 <arkeet> adnap: so what's fun?
02:01:48 <arkeet> oh.
02:01:51 <adnap> arkeet: I was being sarcastic
02:01:54 <arkeet> that's not very surprising.
02:01:55 <arkeet> :p
02:02:41 <arkeet> mm_freak: is there a good introduction to netwire somewhere?
02:02:42 <adnap> arkeet: Well, this is "malicious". Even a safe module could write this
02:02:53 <arkeet> > fix id
02:02:57 <arkeet> adnap: and?
02:02:58 <ski_> Ghoul_ : with or without any `ContT' in it ?
02:03:00 <lambdabot>   mueval-core: Time limit exceeded
02:03:02 <mm_freak> ski_: assuming that all the game objects depend on each other, there is really only one way to localize:  automata and proper data dependencies
02:03:08 <mm_freak> ski_: from there it's a small step to FRP =)
02:03:33 <mm_freak> arkeet: the netwire 5 tutorial is quite decent, but not finished yet
02:03:44 <mm_freak> arkeet: http://hub.darcs.net/ertes/netwire
02:03:58 <arkeet> thanks
02:04:03 <arkeet> netwire 5, you say.
02:04:05 <Ghoul_> ski_: I don't use ContT, I've never learnt about it
02:04:12 <mm_freak> yeah =)
02:04:15 <mm_freak> it's not on hackage yet
02:04:25 <mm_freak> the API is still not stabilized
02:04:46 <ski_> mm_freak : i think that's probably the case -- but you could possibly have lots of transforms of `State s' stuff into automata ?
02:05:32 <ski_> Ghoul_ : then you haven't had real fun with monad transformer stacks yet :)
02:05:39 * hackagebot crypto-random 0.0.3 - Simple cryptographic random related types  http://hackage.haskell.org/package/crypto-random-0.0.3 (VincentHanquez)
02:05:51 <mm_freak> ski_: local state transforms are pretty much what automata are, but with one important difference:  the state is invisible from outside
02:05:55 <adnap> arkeet: Could I write a program that tries to get a result from a function and gives up if the result is not returned in a certain amount of time?
02:06:04 <mm_freak> data Auto a b = forall s. Auto s ((a, s) -> (b, s))
02:06:10 <arkeet> adnap: lambdabot does it!
02:06:33 <ski_> mm_freak : ok, which is basically a synchonous stream processor
02:06:41 <mm_freak> ski_: exactly
02:06:53 <adnap> arkeet: Well, if my program interprets functions, I need some way to protect against functions which never return a result
02:07:00 <ski_>   data SSP a b = GetPut (a -> (b,SSP a b))
02:07:01 <arkeet> adnap: lambdabot does it!
02:07:06 <mm_freak> this is the usual definition, which is easier to work with:  newtype Auto a b = Auto (a -> (b, Auto a b))
02:07:16 <mm_freak> you can find it in 'arrows', 'machines' and some other libraries
02:07:26 <mm_freak> also yampa's SF is pretty close to it
02:07:40 <adnap> arkeet: Do you think what I suggested is a good way, or is there a way to tell that a function is not doing anything productive for simple cases like the one I posted?
02:08:07 <arkeet> adnap: I missed your suggestion
02:08:14 <ski_> mm_freak : Fudgets are also related (though asynchronous, and with hidden I/O channels)
02:08:41 <adnap> arkeet: Try to call the function and throw some kind of error/exception if the function does not return a result within some interval of time
02:08:53 <augur> ski_: what an interesting type
02:08:56 <arkeet> adnap: well, lambdabot does that.
02:09:08 <mm_freak> ski_: for games you want to make this abstraction as lightweight as possible…  Auto is a thin layer around regular haskell functions
02:09:09 <ski_> augur : `SSP' ?
02:09:12 <augur> ski_: yeah
02:09:14 <augur> hmm
02:09:23 <adnap> arkeet: Well, I don't know if lambdabot is as good as it gets
02:09:29 <arkeet> I don't know either.
02:09:33 <adnap> Okay
02:09:37 <augur> data SSP a b = SSP { get :: a -> b, put :: a -> SSP a b }
02:09:37 <arkeet> I can't think of any way to do better, though.
02:09:49 <adnap> > let f, g :: Int -> Int; f x = g x; g x = f x in f 2
02:09:56 <lambdabot>   mueval-core: Time limit exceeded
02:10:00 <mm_freak> augur: s/put/next/
02:10:04 <adnap> It seems like this should be detectable by analysis
02:10:08 <augur> mm_freak: even better!
02:10:18 <ski_>   data ASP a b = Get (a -> ASP a b) | Put b (ASP a b)
02:10:23 <augur> coalgebras! :D
02:11:02 <augur> at least i THINK this is a coalgebra. hmm
02:11:04 <mm_freak> add a time argument and you've got yampa's SF
02:11:06 <augur> is it?
02:11:18 <mm_freak> newtype SF a b = SF (DTime -> a -> (b, SF a b))
02:11:28 <mm_freak> timeDelta :: DTime
02:11:49 <augur> it feels kinda coalgebraic
02:11:58 <ski_> augur,mm_freak : <ftp://ftp.cpsc.ucalgary.ca/pub/projects/charity/examples/misc/proc.ch> at <http://pll.cpsc.ucalgary.ca/charity1/www/home.html> is also basically the same thing
02:13:09 <ski_> adnap : detecting that in general is equivalent to solving the halting problem
02:13:32 <adnap> ski_: I know
02:13:53 <ski_> adnap : however, in some cases GHC can detect it using "blackholing", and then it prints something like "<loop>"
02:14:10 <adnap> ski_: The example I posted seems simple to detect
02:14:18 <ski_> (detecting when forcing a thunk wants to force the same thunk)
02:15:07 <ski_> augur : your variant is (more or less) coalgebraic, at least
02:15:39 * hackagebot crypto-random 0.0.4 - Simple cryptographic random related types  http://hackage.haskell.org/package/crypto-random-0.0.4 (VincentHanquez)
02:15:53 <ski_>   SSP a b = b ^ a * SSP a b ^ a
02:16:26 <ski_> augur : hm, i suppose we want some concept corresponding to "polynomial functor", maybe ?
02:16:57 <augur> ski_: well, its the fix of   SSPF a b x = a -> (b,x) ofcourse
02:17:25 <ski_> yes, the question is whether `a ->' there would be allowed
02:17:43 <ski_> (in the Charity `proc', they do that via exponentials=
02:17:44 <ski_> )
02:17:52 <augur> i think that makes it non-coalgebraic
02:18:31 <ski_> is `T = A + T^B' algebraic ?
02:18:32 <augur> because a coalgebra is an f :: a -> f a
02:18:44 <augur> ski_: well its not an algebra!
02:18:45 <ski_> (where `A' and `B' are constants)
02:19:00 <ski_> it's a polynomial functor
02:19:20 <augur> ski_: maybe, but that doesnt make it a coalgebra :)
02:19:48 <ski_> well, the issue there was algebraic, not coalgebraic
02:20:40 <ski_> `<X,f>' is an `F'-algebra when `f : F X --> X'
02:20:59 <ski_> (anarchic `F'-algebra, i.e.=
02:22:12 <ski_> augur : do you want any restrictions placed on the functor `F' ?
02:23:10 <augur> ski_: i dont want anything
02:24:21 <ski_> augur : it's not clear to me if you want to be talking about `F'-algebras or something else
02:24:36 <ski_> perhaps universal algebra stuff ?
02:25:14 <augur> ski_: i dont want anything :)
02:26:30 <ski_> hm, iiuc, universal algebras only have polynomial functors (with natural numbers as exponents)
02:26:59 <ski_> augur : what is wrong with you !?
02:27:42 <augur> :(
02:29:30 <ski_> anyway, you seemed to want to determine whether `SSP' was coalgebraic
02:29:32 <arkeet> !?
02:30:09 <augur> ^!?
02:30:11 <ski_> so i was wondering in which sense you intended that term
02:30:14 <newbie2_> if i have smth like tetris with already done list of blocks, should i use state or it is better to use pure functionality?
02:30:33 * ski_ hands augur some linear logic exponentials to play with
02:30:36 <augur> ski_: oh, i just meant it looked like a coalgebra sort of
02:31:56 <newbie2_> in fact, there is no global states. But my field have same layers, which number increases with new blocks. So, what can you advise me to do?
02:32:09 <haasn> edwardk: iterated needs to be made an indexed traversal
02:32:12 <haasn> then it would work
02:32:29 <haasn> indexed fold, even
02:34:18 * ski_ . o O ( "Clean Game Library" <http://cleangl.sourceforge.net/> )
02:36:17 <augur> hmm
02:36:31 <augur> data ZeroF :: * where
02:36:38 <augur> er, sorry
02:36:43 <augur> data ZeroF :: * -> * where
02:36:50 <augur> how do you write a functor instance for this?
02:37:15 <augur> it's obviously a functor, with fmap being ALMOST the identity
02:37:21 <augur> but the types wont line up for the identity
02:37:25 <augur> so you couldnt do fmap x = x
02:39:28 <augur> i /guess/ you could do fmap x = undefined, because the only way itll get called is with a non-terminative value anyway
02:39:31 <augur> terminating*
02:39:44 <augur> but that seems hacky
02:39:51 <augur> oh if only we had absurd patterns!
02:41:15 <augur> ofcourse, type ZeroF = Const Zero works just as well, so im just being silly, but
02:46:49 <augur> ok question
02:48:09 <augur> first some context: when showing that   Store a b  ~  forall f. Functor f => (a -> f a) -> f b  , we can reason as follows
02:49:19 <augur> we cant just store a b, because not every functor lets us inject into it, we cant store an f b because we dont know the functor, so all we can do is somehow use fmap as  fmap h :: f c -> f b  for some c
02:49:55 <augur> but f c yields a similar problem, so our only recourse is to try c = a and h :: a -> b
02:50:31 <augur> then we just need to supply an a, and we can get from a to f a to f b
02:50:50 <augur> this seems kind of forced by the fact that we're polymorphic on f.
02:51:00 <augur> does this emerge from the usual free theorems?
02:51:47 <augur> i cant imagine how it would, but i dont know. free theorems usually are about polymorphism over types not functors
02:52:32 <augur> sorry, i think thats actually that b -> Store a b is iso to that. whatever. you get the question :P
02:52:40 <ski_> augur `fmap f z = case z of {}' ?
02:52:58 <augur> ski_: hmm! maybe that would work yeah
02:53:04 <augur> lovely!
02:53:15 <ski_> you'll need a recent extension, i think
02:53:34 <ski_> (obviously `EmptyDataDecls' ought to have supported this from the start)
02:55:40 * hackagebot hspec-meta 1.7.1 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.7.1 (SimonHengel)
02:56:08 <joelteon> how do you test hspec-meta?
02:57:05 <ski_> @free foo :: Functor f => (a -> f a) -> f b
02:57:05 <lambdabot> Extra stuff at end of line
02:57:09 <ski_> @free foo :: (a -> f a) -> f b
02:57:09 <lambdabot> Plugin `free' failed with: src/Lambdabot/Plugin/Haskell/Free/Type.hs:(152,17)-(160,45): Non-exhaustive patterns in case
02:57:15 <ski_> @free foo :: (forall a b. (a -> b) -> (f a -> f b)) -> (a -> f a) -> f b
02:57:15 <lambdabot> Plugin `free' failed with: src/Lambdabot/Plugin/Haskell/Free/Type.hs:(152,17)-(160,45): Non-exhaustive patterns in case
02:59:15 <ski_> @free f :: [a] -> Maybe (a,a)
02:59:15 <lambdabot> $map_Maybe ($map_Pair g g) . f = f . $map g
02:59:58 <ski_> @free x :: Bool
02:59:58 <lambdabot> x = x
03:00:03 <ski_> @free x :: Maybe a
03:00:03 <lambdabot> $map_Maybe f x = x
03:00:40 * hackagebot io-streams 1.1.1.0 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.1.0 (GregoryCollins)
03:00:42 * hackagebot hspec 1.7.1 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.7.1 (SimonHengel)
03:00:44 * hackagebot HTF 0.11.0.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.11.0.0 (StefanWehr)
03:01:51 * ski_ tries to recall how to derive the free stuff
03:22:35 <Ghoul_> ski_: is ContT useful or un-useful in making transformer stacks easier to manage?
03:23:04 <arkeet> neither. but it makes your transformer stack more awesome :>D
03:23:20 <arkeet> (I don't understand ContT.)
03:23:57 <jophish> Yo yo yo
03:24:12 <mm_freak> Ghoul_: if you imagine your sequence of computations as a directed graph, ContT basically allows you to pick any subtree of it and stick it to anywhere (where the types match)
03:24:31 <jophish> I'm writing a compiler for a small functional language with a similar syntax to haskell (Using Language.Haskell.Exts to parse it in fact).
03:25:15 <mm_freak> Ghoul_: two of the simplest things you can implement with it is 'goto', 'continue' and 'break' from imperative languages
03:25:25 <mm_freak> s/two/three/
03:25:26 <Ghoul_> Oh, so it's basically lego
03:25:40 <jophish> I'm planning to use Hindley–Milner for the internal representation. Where can people recommend looking for something similar to a Haskell->HM compiler
03:25:40 <newbie2_> in_line :: Integer -> [(Integer, Integer)] -> Integer -- returns 1 if integer is in one of tuples, otherwise 0. Note that tuples are sorted and not intersected
03:25:40 * hackagebot xmlgen 0.6.1.0 - Fast XML generation library  http://hackage.haskell.org/package/xmlgen-0.6.1.0 (StefanWehr)
03:25:44 <mm_freak> lego for programs, yeah =)
03:25:49 <jophish> I don't think GHC uses HM any more
03:25:49 <newbie2_> what is the fasted way to do that?
03:25:57 <Ghoul_> That's cool I guess
03:26:02 <Ghoul_> is there a performance impact?
03:26:20 <mm_freak> newbie2_: a recursive function
03:26:44 <newbie2_> mm_freak: tuples are sorted, can i use it somehow?
03:26:48 <mm_freak> Ghoul_: ContT performs CPS transformation, which usually gives you even higher performance =)
03:27:07 <mm_freak> Ghoul_: that's the main purpose of Codensity, which is ContT with the continuation effects hidden
03:27:22 <newbie2_> mm_freak: intuition says that exists O(1) algo
03:27:26 <mm_freak> newbie2_: you can use it to break early
03:27:33 <mm_freak> no, definitely not O(1)
03:27:36 <Ghoul_> Sounds cool
03:27:37 <mm_freak> it's still O(n)
03:27:52 <mm_freak> newbie2_: you may want to use Data.Set instead
03:28:30 <mm_freak> Ghoul_: once the enthusiasm is over you will realize that you don't really need ContT for anything =)
03:28:48 <mm_freak> Ghoul_: but it's cool to try out =)
03:28:58 <mm_freak> Ghoul_: in fact the best way to understand ContT is to implement it yourself
03:28:58 <Ghoul_> I'm trying to imagine how this "higher performance" thing will work
03:29:25 <Ghoul_> I'm familiar with CPS but I can't imagine how it's going to make tightly knit code faster by lego-izing it
03:29:46 <mm_freak> Ghoul_: it gets rid of some memory operations
03:29:51 <mm_freak> consider a CPSed Either
03:30:23 <mm_freak> type Either e a = forall c. (e -> c) -> (a -> c) -> c
03:30:48 <mm_freak> when you apply this function it just calls the proper function right away…  it does not compare a tag in memory
03:31:35 <Ghoul_> okay.
03:31:35 <mm_freak> in general you won't notice much of a difference, but there are some algorithms where CPS can boost performance quite a bit
03:33:15 <mm_freak> one huge drawback of ContT and related monad transformers is that it kills MonadFix
03:39:40 <Ghoul_> oh god
03:39:46 <Ghoul_> its horrifically confusing to read code that uses it
03:40:43 <aristid> ContT? just gotta link this: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
03:43:28 <Ghoul_> thanks'
03:43:46 <Ghoul_> hmm, typo, or I could really mean thanks-prime
03:43:51 <Ghoul_> an alternate extra strict variant of thanks
03:44:14 <aristid> surely you meant dthanks/dt
03:44:38 <arkeet> aristid: lol
03:45:00 <Ghoul_> lol
03:47:35 <ski_> Ghoul_ : as i said, `ContT' is fun
03:47:59 <newbie2_> can you give examples of usage RBTree?
03:48:10 <newbie2_> i mean syntax
03:48:18 <ski_> aristid : that must be equal to `hanks', right ?
03:51:44 <Ghoul_> ContT StateT sounds like fun fun fun
03:52:57 <Ghoul_> now, the way to cheat thinking of real applications, now that I know how it works, is to hop on gist.github.com and search for ContT and let the knowledge flow in :P
03:53:39 <newbie2_> and can i mao in RBTree?
03:53:41 <newbie2_> *map
03:54:28 <ski_> who broke `unmtl' ?
03:54:36 <ski_> @unmtl ReaderT r (WriterT w m) a
03:54:36 <lambdabot> r -> (WriterT w m) a
03:55:29 <ski_> newbie2_ : not sure how `RBTree' is defined ..
03:55:41 * hackagebot network-multicast 0.0.9 - Simple multicast library  http://hackage.haskell.org/package/network-multicast-0.0.9 (AudreyTang)
03:56:07 <newbie2_> data RBTree a = Node Color a !(RBTree a) !(RBTree a) | Leaf    	-- Defined in `Data.Tree.RBTree'
03:56:43 <ski_> replace each value `x' of type `a' with `f x', where `f' is the function to map over it
04:00:41 * hackagebot genprog 0.1.0.2 - Genetic programming library  http://hackage.haskell.org/package/genprog-0.1.0.2 (JanSnajder)
04:18:11 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
04:18:11 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
04:18:11 --- names: list (clog MindlessDrone ykm soulofpeace spion bennofs RThinker longqm newbie2 jmbto zbcm hkj ps-auxw Kiryx mrkotfw apfelbox kallisti shintah Neqoxec ski_ Lethalman q66 jarlg Beetny Okasu twanvl SingingBoyo ulfdoz Desheng2 kayloos jophish epta agjacome peter_zfs kuribas jaimef valyagolev copumpkin Bluuu ollehar matheus23 Soft- ts33kr torkjak ndrei wollw jzl arlinius nooodl MK_FG Eduard_Munteanu pootler kludge` skulls nneko001__ Reite Vendethiel asQuirreL _justjust)
04:18:11 --- names: list (Palmik mjo Caztiel dschoepe wolfnn bduc Toxaris maxter quchen donri simukis_ Wizek hexagoxel_ Alice3 nominolo Kaini dcoutts_ SoupE vobi ioanel wole eeezkil lemao zammy wavewave c_wraith kamatsu sjoerd_visscher Taneb lq allsystemsarego pantsman Internet13 alanz turiya tomprince plhk td123 mrcheeks enthropy ananthakumaran tavelram__ ceii dreixel heruur sxn cyphase_ neektza1 shennyg oleo jrib sj4nz Vorpal k00mi_ edon pi8030 kav_ maoe1 MOMI isomorphic doomlord_)
04:18:11 --- names: list (kitallis MrRacoon_ tensorpudding Philonous__ knyppeldynan akraut jyyou_ strmpnk kshannon_ kryft Rarrikin1 mshroyer_ adlan_ CindyLin1 axiom tessier_ BMeph_ supersymmetry eff__ Guest66158 gbluma vili_ tomh- doomlord__ iulian Obfuscate` phar Ptival_ Guest53212 Bwild_ oldmanst1n maximums1eve noddy2OOO cynick_ pxqr Kuraitou sdx32 basdirks1 mno2_ phischu recycle tov yopikh arpunk fylwind bitonic` kerrick kcj Spaceghost edwardk goldkatze [[zz]] albel727 Argue levi)
04:18:11 --- names: list (conal path[l] preflex mauke dennylin93 otto_s fmapE shanse ssbr` hiratara ISF tobyo2 augur tolt shrekster m3ga TDJACR ve xl apaku Quadrescence xinming joneshf-laptop Ralith ormaaj jdegoes RichyB mjs2600 shepheb Cale mm_freak cdidd xpika xymox sclv ryant5000 predator217 ecube litherum waterlaz sm rckrd Patchou mbrock MercurialAlchemi SegFaultAX poppingtonic totte nabilhassein Heffalump eis_ araujo markov_twain jack_rabbit weie_ mendez jonsmock Sgeo martinalex)
04:18:11 --- names: list (dabradley paddymahoney flux epsylon TallerGhostWalt thunderrd DrCode Lefeni Veltas kloplop321 dmwit callen Guest22019 dsp_ joe9 brandonw hiptobecubic ketil JesuZ Jaak Shou jeff_s1 latro`a_ adnap wto jang skchrko Tesseraction cods pygospa yacks YoungFrog Excureo bbloom Guest98659 ccasin destiny cdk benj_ mroman hamilyon liori lieven_ d3lxa noam JaRoel|4d bunzen mrowe_away zcourts smarter niko tomboy64 Swizec bscarlet hashcat shergill eevar gienah Kabaka_ wtw)
04:18:11 --- names: list (m0g DolphR milessabin jdoles MrWoohoo PiepScuim sababa lunarjar mcbonz andares warpy joefiorini joneshf-work sellout- aupiff otulp mnbernstein orospakr Twey jzelinskie stepcut parcs neptunepink s_quark ChongLi hiredman Krakarn pcapriotti mjo_ kxra dolio SLi k0ral OlegYch tsou mrpantoufle Nshag averell mmaruseacph2 Draconx knigitz ninegrid mannyv Khisanth companion_cube Erstarrung dacc perlite SirChurchill schroedinbug Mortomes gbarboza mavam morolin bethebunny)
04:18:11 --- names: list (DarkFox MouseTheLuckyDog DT` CODEtaku sudlowbot Dtgr identity yogurt_truck Morgawr finnrobi ggreg sclv_ n-dolio Baughn janinge dju Axman6 DarkNFoxy bergey aleator saep sinclair|net schoppenhauer ismlages Will| jobstijl rfw hive-mind Guest92121 uu1101 hamishmack stass ezrios Shin-LaC AntiSpamMeta anders^^ ByronJohnson Tene kstuart tauntaun mimi_vx chirpsalot idoru CosmicRay fran hpd jaepark s00pcan cronject Maxdamantus tunixman _flow_ mceier fxrh dcoutts jmct)
04:18:11 --- names: list (thetallguy _br_ Yawgmoth caleb_9 scottschecter gdeest chrra nwf robbert` nilg` Boreeas dixie dwcook Edoxile guymann zaphar_ps farn newsham brisbin timemage mononofu johnw fogus|gone sirspazzolot Nik05 biscarch nopcode_ kakos Martty chrisdone stelleg ndngvr squimmy raid zoktar jml vmeson Kruppe dropdrive ibotty maksbotan hc thetallguy1 dsfox bcoppens Guest19190 lattenwald ljhms IanKelling EvanR hvr marienz cl_away talzeus_ cschneid ryanakca apples tertl3)
04:18:11 --- names: list (centrinia Boney Draggor Adios miasma profmakx gereedy monochrom mgsloan dthibodeau Counter-Strike nuttycom1 dfan knz byorgey swook` shachaf jrd0 doshitan burp dogmaT wimpunk kk1fff ParaSa1lin Ornedan twn MasseR wormphlegm fijimunkii thorkilnaur shelf leroux lusory Nimatek iron_houzi ecc drmegahertz mxf reactormonk jbauman akiress junsuijin fikusz mokus arkx [swift] yam mami dwierenga aforemny schlumpi_ dumael zebr mlamari_ theDon dlundy DexterLB eyck saiam)
04:18:11 --- names: list (mimico__ Brando753 amatsu jonke bd_ PHO_ ofan tragalo FreeFull drbean whaletechno edwtjo WhereIsMySpoon macron etrepum tahu bind tych0 solirc davidt agundry dsirenko_ mkiefel suiside zenzike jroesch mviljamaa Mowah statusfailed Saizan gambogi ent aninhumer FireFly Plex- luite lispy shiona jlouis othiym23 jix purefn eataix M-ou-se mietek Cerise copton_ janiczek prototrout Dybber mikeplus32 jackhill Svedrin FreakyPe1guin vpm dexter2 ircbrowse b2coutts)
04:18:11 --- names: list (fergusnoble hdevalence|away yan_ sunnavy Pengoo kqr1 fryguybob ousado slobo Nickeeh meretrix caligula djahandarie f8l aford ernst palmje b_jonas gpampara_off \q ssttudder solancile mvj4 hape01 solution krakrjak Belgarion0 chrisbuchholz drdo Eliel greymalkin philipde` blast_hardcheese tdammers pjstadig DrSyzygy b52 theorbtwo aoh `^_^v Ycros bens vsayer GaelanAintAround sunfun SHODAN otterdam geekosaur Mayzie c_14 FZ jaspervdj AlexWebr Chousuke Tarential Dodek)
04:18:11 --- names: list (Lemmih Th0mas Licenser Fubar^ jayne zorzar xorox90 ivan\ gthorslund dino- stvc tarmo crs_ satshaba1 gbeshers rhodesd jcp Razz vehk ninzine kfreds ParahSailin jrslepak NeatBasis wilfredh tylergillies_ Kobata akahn lopex samrat Polarina quaestor mapreduce bartavelle ocharles __main__ bobthenameless canta dpwright bstrie s4msung Dashkal ido cow-orker ggherdov brainproxy Zariel jb55 Ghoul_ sgso si14 ivan` myme zero7 Pad^ froztbyte tew88 udevd SaBer mike2 integral)
04:18:11 --- names: list (supki ejls poucet ab9rf melter mephx troydm jonsterling gnoel lokydor lulf qz_ pr lahwran relrod dyspeptics15 joelteon mstksg Natch tero- eacameron Gunni Guest80998 mrd milli tippenein vvv d-snp_ yano elgot bsmt ghorn isomorphismes pyrtsa gds jliikka divarvel petantik mixi kekimmo bitraten saiam^ joeyh lpaste KaneTW flazz vnz Walther Kinnison arcatan pyykkis_ OrangeDu1k sipa notdan taylorgb_ kosmikus tromp__ Blkt upgrayeddd KyleCloud vivekrai Xorlev chickenflu)
04:18:11 --- names: list (IbnFirnas ehd jodaro aloiscochard Raynos charlesofarrell_ puzza007 bobry idnar liyang chexxor nkpart mechairoi Nahra lambdabot mirsal zrot juuhaa Enigmagic ysuzuki phryk McManiaC ibab go|dfish popx joar ClaudiusMaximus ziman heath scshunt xplat tg RevJohnnyHealey Tinned_Tuna davorak geoffh raft Excedrin n00dle edk ft brixen thorsten` tudalex swistak35 tehroflmaoer Riussi Hafydd pikhq srcerer ciaranm seantallen Amadiro yriw s4muel zomg mlh alexsdutton dsantiago)
04:18:11 --- names: list (k4nar Fuuzetsu frontendloader Deewiant bentrevor Vertue asjo Iceland_jack xye machisuji Jaxan shajra Athas mee killy9999 jmcarthur Phlogistique sleepybug sajith osfameron udoprog joogi barrucadu fry mjrosenb mel- rgrinberg gseitz carter cheezey hfaafb flori_ mantovani xenocons ahihi bergmark bbee absence katis redjohn Vq thomassgn satshabad osnr mgaare mak` canissimia sordina andrewsw fabjan zenoli og haasn dan64 davean MetaCosm b0c1 arnsholt peddie taruti so)
04:18:11 --- names: list (Igloo rasmusto simon ccxCZ Tehnix felipe_ Liskni_si tomaw rpenguin_ hpc aristid guerrilla KitB tulcod adimit alpounet cajla mrshoe Ke tridactyla BigEndian wunki `0660 tomejaguar munro Khady robinbb Adeon DustyDin1o demolithion dyreshark mmathis gilbertw1 lenstr Jello_Raptor Gracenotes threedaymonk Sunhay_ DigitalKiwi acfoltzer lightquake mortberg inr valdyn dqd colah xnyhps anhall machisuji_ Tekerson arkeet kloeri Odd_Bloke FUZxxl _janne drewr Raynes)
04:18:11 --- names: list (quicksilver Bigcheese alej qwandor eL_Bart0 kini jhh banjiewen palaga Eridius brett cmsd2 neurocyte arbn bogner electrogeek BrianHV earthy bezik mero koala_man linduxed noplamodo nxorg8 thirsteh mlinksva zerokarmaleft Valodim hackagebot `bps h_chiro_ stiell alexander__b int-e Tribal kaw ReinH bogner_ dustinswan gemelen Hardolaf peltchu Laney Elision Gothmog_ kranius deggis mux a11235 ahf BlastHardcheese jlewis duairc JPohlmann Cryovat brendan saurik Maior)
04:18:11 --- names: list (mollerstrand ehamberg skypers briden mornfall kaol ttm pqmodn malorie_ dilinger_ thoughtpolice mr- sohum nikola zw01 fall_ bgamari Watcher7 TheSpectre Kneiva rs0 bxc SuperNoeMan stomp opqdonut petanqk liszt jkpl nicoo solarus danr cross Rutger`_ dario^CIP ion klugez gridaphobe wereHamster TML prophile pfoetchen Rembane Proteumus mattp_ @ChanServ tamiko pnielsen wagle magicman Clint sp3ctum cruxeternus pharaun ericmj bqp XMunkki_ elliott deavid asante Ulrar)
04:18:11 --- names: list (Starfire_ nlogax willb1 necroyeti yeltzooo dmp1ce jamwt cjay Spockz def-lkb zaiste aszlig ibid Reisen ipuustin geal inarru betawaffle lpsmith horlicks zeiris_ almondjelly Ezku anachron mkrull confound xaimus Yaniel)
04:19:53 <bmm> Hi. I'm trying to use the Lazy bytestring to murmur-hash a file per chunk. But I keep getting a Data.ByteString.Internal.ByteString where murmur-hash expects a Data.ByteString. How can I deal with that?
04:20:16 <donri> bmm: they're the same thing
04:20:29 <lpaste> bmm pasted “Not working murmurhash of a file” at http://lpaste.net/92362
04:21:13 <donri> bmm: paste error please :)
04:21:30 <bmm> donri: ok, will paste...
04:21:35 <ski_> hm, is there any composition type present in lambdabot ?
04:21:54 <lpaste> bmm annotated “Not working murmurhash of a file” with “Not working murmurhash of a file (annotation)” at http://lpaste.net/92362#a92363
04:21:57 <Ghoul_> what does this do
04:22:00 <Ghoul_> fullTree (pred -> n) = do ...
04:22:25 <Ghoul_> particularly, the (pred -> n) thing. Never seen anything like that before
04:22:26 <mm_freak> Ghoul_: it's a view pattern
04:22:43 <mm_freak> same as:  fullTree n' | n <- pred n' = …
04:22:57 <mm_freak> or:  fullTree n' = let n = pred n' in …
04:23:42 <bmm> donri: added the error to the paste earlier. If they are the same, I'm probably missing some kind of import, because I would expect the Bytestring instance of Hashable from the murmur library to be picked up.
04:24:07 <Ghoul_> oh wow
04:24:09 <Ghoul_> thats pretty cool
04:24:28 <mm_freak> Ghoul_: it requires an extension though…  i use lets and pattern guards
04:24:37 <donri> bmm: yes it has those instances, which suggests you might have multiple versions of some packages installed. try: ghc-pkg list bytestring
04:24:47 <Ghoul_> extensions aren't scary
04:25:03 <Ghoul_> imho haskell 2010 is seriously lacking some type level stuff
04:25:20 <Ghoul_> Like, we have to pull out extensions even to implement a lot of prelude in a *nice* way
04:25:40 <bmm> donri: Ah, so I do! I thought cabal-dev would fix that, but I'll try a complete clean of cabal-dev and try again. Thanks for the tip!
04:26:00 <Ghoul_> Although it gets worrying when there's a longer list of extensions than module exports in your code :P
04:26:11 <donri> bmm: with cabal-dev i think you need to use "cabal-dev ghc-pkg"
04:26:37 <donri> also cabal-dev is still subject to the global package db
04:27:59 <bmm> donri: did a complete clean and that fixed it! I used cabal-dev to install a newer version of bytestring earlier and that probably caused the problem. Thanks! I would have never caught that.
04:28:06 <mm_freak> Ghoul_: even my acme package from yesterday, single module, uses two extensions =)
04:28:36 <donri> bmm: i don't recommend upgrading core packages
04:29:07 <donri> bmm: actually i'd suggest putting "constraint: bytestring installed" (etc for all core packages, maybe even platform) in ~/.cabal/config
04:30:04 <donri> bmm: http://www.vex.net/~trebla/haskell/haskell-platform.xhtml#correction
04:30:19 <bmm> donri: I had to because I wanted a "chunks" function of the 0.10 which was not in 0.9. "rm -rf cabal-dev; cabal-dev install etc..." seems to fix it all. I'll look up the link you sent now.
04:30:49 <donri> bmm: well it's real messy to upgrade ghc's core libraries without upgrading ghc
04:31:16 <donri> bmm: if you want bytestring .10 upgrade ghc/platform
04:32:22 <bmm> donri: I decided that I want a full laptop os upgrade to go with it, and the full laptop upgrade is still putting me of ;) Maybe next weekend :D
04:35:13 <newbie2> what type should i use to cover Integer, Double and Rational?
04:35:42 <lpaste> valyagolev pasted “parse error” at http://lpaste.net/92364
04:35:44 <valyagolev> hey guys, I'm trying Arrows and getting parse error, can you tell me what I'm doing wrong?
04:35:47 * hackagebot miniutter 0.4.2 - Simple English clause creation from arbitrary words.  http://hackage.haskell.org/package/miniutter-0.4.2 (MikolajKonarski)
04:36:33 <valyagolev> nm! forgot -XArrows
04:36:37 <hari_> One of the things, I've noticed as a beginner is that tutorials in haskell tend to get complicated very quickly after the first couple of chapters.
04:37:14 <Eduard_Munteanu> Can you invert a parser in Parsec?
04:37:32 <hari_> I mean, I hit a road block in this chapter: http://en.wikibooks.org/wiki/Haskell/YAHT/Type_advanced
04:38:14 <Eduard_Munteanu> i.e. given a parser, apply it and if it succeeds back out, and if it fails consume the input and return what has been consumed.
04:38:52 <Eduard_Munteanu> hari_: what exactly?
04:39:08 <hari_> I could not understand the difference between type class and new type.
04:40:03 <Eduard_Munteanu> hari_: they're in a whole different category. Newtypes are types, while typeclasses are like sets of types with a common interface.
04:40:38 <hari_> How does newtype differ from data?
04:40:47 * hackagebot algebraic-classes 0.5 - Conversions between algebraic classes and F-algebras.  http://hackage.haskell.org/package/algebraic-classes-0.5 (SjoerdVisscher)
04:41:01 <Eduard_Munteanu> hari_: it only contains one value
04:41:01 <hpc> hari_: a newtype is restricted to one constructor of one field
04:41:09 <hpc> hari_: and it is the "same size" as the field
04:41:33 <hpc> hari_: so for instance, with "data Foo = Foo ()", Foo has the following distinct values
04:41:36 <Eduard_Munteanu> hari_: it is also represented more efficiently, since unlike data it does no packing/unpacking at runtime
04:41:36 <hpc> undefined
04:41:37 <hpc> Foo undefined
04:41:40 <hpc> Foo ()
04:41:52 <hpc> hari_: if it's a newtype, (Foo undefined) is semantically the same as undefined
04:42:03 <hari_> you mean newtype holds only one value?
04:42:11 <hpc> yes
04:42:23 <Eduard_Munteanu> hari_: that value can be a tuple or something else though
04:43:09 <hari_> I have trouble grasping the concept of isomorphic mentioned in the tutorial
04:43:36 <hpc> isomorphic is fancy greek for "same shape"
04:43:39 <Eduard_Munteanu> hari_: isomorphic ~ "same shape". It means two types are equivalent.
04:43:54 <hpc> in very non-mathematical language, it means you can go back and forth between A and B
04:44:02 <hiptobecubic> hari_, in boring, possibly imprecise terms it means you can convert between them without losing anything
04:44:04 <hpc> without any "changes"
04:44:13 <hari_> OK
04:44:25 <hiptobecubic> bool <-> int, are not, for example
04:44:37 <Eduard_Munteanu> E.g. data Foo a = Baz | Bar a  is isomorphic to  data Maybe a = Nothing | Just a
04:44:45 <hari_> So according to the tutorial, MyInt and Int are identical, except for that I define the ordering in MyInt
04:45:22 <kaw> Hey, I'm getting a bunch of errors about not being able to match "bytestring-0.9.2.1:Data.ByteString.Lazy.Internal.ByteString" with "Data.ByteString.Lazy.Internal.ByteString" -- what might cause this? Is there something wrong with my code or with my package installations?
04:45:23 <jdoles> hiptobecubic: bool and int could be isomorphic by mapping all even values to true and all odd values to false.
04:45:35 <hari_> Hmm,,,
04:45:47 * hackagebot free-functors 0.6 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.6 (SjoerdVisscher)
04:46:05 <hiptobecubic> jdoles, isn't that just a mapping? Not an isomorphism? How do you recover your int?
04:46:06 <Eduard_Munteanu> jdoles: that would only work for an infinitely countable Bool
04:46:08 <hpc> kaw: that's happening when you try to cabal-install?
04:46:09 <hari_> Maybe a is used to define functions that can return either Just a or nothing, right?
04:46:19 <hpc> likely going to be just a versions issue
04:46:23 <hiptobecubic> jdoles, Eduard_Munteanu, yes you'd need int -> [bool] or something
04:46:24 <kaw> hpc: No, it's happening when I try to ghc --make my program
04:46:29 <hpc> hmm
04:46:59 <Eduard_Munteanu> hari_: yeah... you could also say functions which can fail.
04:47:05 <hpc> if it happened to me i would just re-install; that's beyond my ability to actually fix
04:47:08 <hari_> OK
04:47:11 <hiptobecubic> kaw, anytime ghc gives me version numbers of packages, i have always borked my packages
04:47:20 <hari_> Understood.
04:47:45 <kaw> Ironically it's happening after I tried to clear out everything and reinstall because of another package problem
04:47:54 <kaw> So how do I do that properly, what should I clear exactly?
04:48:07 <hiptobecubic> you have two bytestrings installed i would guess? One older and one more recent and it's getting confused? I'm not particularly well versed in this, i just screw it up a lot
04:48:32 <Eduard_Munteanu> kaw: what did you clear?
04:48:43 <kaw> ~/.ghc and ~/.cabal
04:48:50 <Eduard_Munteanu> That's fine. :/
04:48:54 <hpc> did you install any packages --global?
04:48:56 <Eduard_Munteanu> Well, unless you did --global installs.
04:49:10 <hiptobecubic> kaw, make a cabal file for your program and use cabal-dev :)
04:49:11 <hari_> How does one automatically reply to a person in XChat without typing the name fully?
04:49:21 <hpc> hari_: start typing and press tab
04:49:23 <hiptobecubic> hari_, most IRC clients have tab completion
04:49:26 <hpc> h<tab> -> hari_
04:49:27 <kaw> Would that happen only if I explicitly passed --global, or would it happen automatically if I ran cabal as root?
04:49:43 <hari_> hpc,  thanks
04:49:44 <kaw> I'm pretty sure I haven't done the former but I have done the latter
04:49:52 <hpc> kaw: if you ran cabal as root, it would go into root's ~/.ghc and ~/.cabal
04:50:00 <hpc> which is usually /root
04:50:14 <kaw> Ooh, true. I'll try to delete those
04:50:39 <hpc> however, if you are installing conflicting things as root locally, then running things as a normal user
04:50:42 <hpc> those shouldn't interact
04:50:53 <hari_> is it permitted to ask how you folks first got into Haskell and how you became proficient with it?
04:50:55 <hiptobecubic> kaw, also i can't recommend running cabal (or anything else)  as root if you have no idea what it does :)
04:51:15 <hari_> And what motivated you to learn?
04:51:21 <kaw> Heh, I know, I know. I've been flailing a bit with this packageing stuff, honestly
04:51:25 <kaw> packaging*
04:51:43 <hpc> hari_: i saw someone write an entire webserver in 60 lines with no depends but TCP
04:51:49 <hpc> hari_: and then thought "i must learn this"
04:52:06 <hari_> hpc, wow, webserver in 60 lines of code... amazing
04:52:32 <hpc> i have since written mostly just ridiculous code
04:52:41 <hpc> acme-packages and stuff
04:52:50 <hiptobecubic> hari_, chasing wikipedia links starting at set theory. "Proficient" is too strong a word.
04:53:09 <donri> or you can write a web server in a few hundred lines of code with some dependencies and serve some 450 000 requests per second with ghc HEAD ;)
04:53:19 <hari_> hiptobecubic, I find it so interesting to know how people discover things to learn
04:53:22 <kaw> Hm, no, it looks like nothing has been installed to /root
04:54:02 <kaw> Using -v it seems clear that when I sudo cabal it installs to my own home directory, possibly with the wrong permissions, I don't know
04:54:27 <newbie2> Couldn't match type `Integer' with `GHC.Real.Ratio Integer'. How can i fix that?
04:54:33 <Eduard_Munteanu> hari_: funnily I've seen someone blogging about it, the first thought was "oh, another PHP/Ruby...". But a quick visit to Wikipedia proved that *very* wrong. :)
04:54:39 <hpc> newbie2: can you paste your code?
04:54:41 <hpc> @hpaste
04:54:41 <lambdabot> Haskell pastebin: http://lpaste.net/
04:55:14 <hpc> newbie2: without knowing anything at all about your code, it kind of looks like you are trying to use modulo?
04:55:17 <hari_> Eduard_Munteanu, I also read about functional programming and then was interested in Haskell.
04:55:24 <Eduard_Munteanu> Anyway I found purity and other things quite motivational just by being weird. :)
04:55:38 <hari_> Not sure why I chose Haskell, though. Maybe because it was deemed "tough" to learn and also because it has a nice name. :)
04:55:45 <newbie2> hpc: just changed all my Integer type to Rational
04:55:58 <zomg> Best article on type families: "Type Families and Pokemon"
04:56:06 <zomg> That was some brilliant execution in that one.
04:56:07 <zomg> :D
04:57:45 <newbie2> http://lpaste.net/92365
04:58:04 <newbie2> and when i type 4, for example, it blames me
04:58:42 <donri> :t 4 :: Rational
04:58:43 <lambdabot> Rational
04:59:20 <hpc> what's the body of the function?
04:59:46 <hari_> In classifying programming languages, where exactly does "functional" fall into? Is it at a level higher than Object Oriented and procedural? I assume "imperative" is used as a generic term for OOP and procedural
05:00:43 <hpc> hari_: they're different styles, not really levels
05:00:59 <donri> hari_: http://www.info.ucl.ac.be/~pvr/paradigms.html :p
05:01:09 <zomg> the level of abstraction would probably depend on the libraries being used
05:01:20 <hpc> so to take an extreme example, assembly language
05:01:25 <hpc> is very low-level and procedural
05:01:30 <zomg> though maybe FP languages inherently have a higher level abstraction
05:01:32 <hpc> but not all procedural languages are low-level
05:01:47 <hpc> and the reduceron is a theoretical cpu with a functional assembly language
05:02:04 <hari_> I forgot about "Declarative" paradigm :)
05:02:13 <hari_> Yes, I find that chart very interesitng.
05:03:02 <hari_> donri, Must take the time to digest that!
05:03:49 <donri> hm there should be a version for type systems too somewhere...
05:04:45 <newbie2> :t 4
05:04:46 <lambdabot> Num a => a
05:05:48 <hari_> :t 4.0
05:05:49 <lambdabot> Fractional a => a
05:06:14 <hari_> :t (4/3)
05:06:15 <lambdabot> Fractional a => a
05:06:31 <ski_> "Declarative" is often construed to include both "Functional" and "Logic"
05:07:00 <Eduard_Munteanu> I wonder if SQL fits in any of those two.
05:07:22 <hari_> I wonder why C++ isn't on that chart.
05:07:33 <donri> hari_: http://james-iry.blogspot.com/2010/05/types-la-chart.html
05:07:33 <hpc> C++ /is/ the chart
05:07:44 <companion_cube> SQL is some bastard logic programming
05:08:09 <aristid> companion_cube: no, it's bastard relational algebra:)
05:08:18 <companion_cube> which is a subset of logic ;)
05:08:24 <Eduard_Munteanu> C++ is a weird language.
05:08:26 <companion_cube> it's basically non recursive datalog
05:08:45 <Ghoul_> oooh pred/succ simulates n+k patterns
05:08:47 <Ghoul_> tats cool
05:08:48 <aristid> companion_cube: i believe relational algebra can do some things that datalog can't, but i might be mistaken
05:09:05 <Ghoul_> w/ ViewPatterns, sorry, should have mentioned that
05:09:06 <ski_> Eduard_Munteanu : SQL is sortof a logic/relational programming language
05:09:07 <companion_cube> right, maybe you need to add aggregates
05:10:19 <aristid> companion_cube: aggregates are not a primitive operation in relational algebra:)
05:10:37 <GaXo> Hello, i'm trying to use Data.Graph and i wonder is there some visualisation tool for Graph ADT?
05:10:43 <companion_cube> but you cannot encode them, right?
05:10:57 <companion_cube> you need to add them as a primitive to get some features of SQL
05:11:02 <hari_> I had a nephew drop in and ask for help with C++ and I was stumped. The worst part is that, in our schools, they still use Borland Turbo C++ on DOS.
05:11:08 <companion_cube> apart from that, pure relational algebra should be less powerful than datalog
05:11:17 <hpc> wow, borland
05:11:17 <ski_> SQL,Datalog and other deductive database languages are based on a bottom-up sets-at-a-time interpretation of relational/logic programming, rather than the top-down tuple-at-a-time interpretation employed in languages like Prolog,Mercury,Oz,Goedel,Curry,Escher
05:11:17 <aristid> companion_cube: yeah but i was comparing relational algebra and datalog, not SQL and datalog
05:11:22 <tomejaguar> Here is a cool category theory approach to relational algebra: http://arxiv.org/pdf/1305.0297v1
05:11:37 <GaXo> By visualisation i mean (Graph -> IO ()) and within that IO i want either save pictuare of nodes in graph or display it.
05:11:52 <companion_cube> ski_: Datalog doesn't presuppose a top down or bottom up approach
05:11:54 <companion_cube> both are valid
05:11:55 <hpc> tomejaguar: can't tell if snarxiv... :P
05:12:14 <companion_cube> aristid: so I think datalog encompasses relational algebra
05:13:07 <tomejaguar> hpc: why, does it sound weird?
05:13:08 <ski_> companion_cube : ok, but i was under the impression that bottom-up was the main intended approach
05:13:24 <Eduard_Munteanu> hari_: same thing here usually... at least when I was in highschool
05:13:39 <aristid> companion_cube: hmm maybe
05:13:44 <ski_> (i know that it is possible to mix the two in the same system)
05:13:44 <hpc> tomejaguar: mostly "operad"
05:13:59 <aristid> companion_cube: and if you then extend datalog with aggregates, you can do everything that SQL can? MWAHAHAHA
05:14:06 <tomejaguar> An operad is a perfectly cromulent category theory gadget
05:14:13 <companion_cube> ski_: not always, for instance, datalog with negation is usually done with top-down
05:14:19 <companion_cube> (I think)
05:14:34 <companion_cube> top-down with tabbling, that is
05:14:35 * Eduard_Munteanu hands out passes to ##categorytheory for everybody :D
05:14:43 <aristid> companion_cube: i guess a problem is that there isn't ONE datalog, eh?
05:14:45 <companion_cube> aristid: I don't know, there are also subqueries ^^
05:14:47 <aristid> datalog without negation
05:14:51 <hari_> Eduard_Munteanu, haha, they refuse to even use python in our schools for teaching
05:15:04 <companion_cube> aristid: well, datalog is a logic language, so you can have several approaches
05:15:10 <fredmorcos> I have a couple of statements I made up after going through Monads in LYAH. I'd like to make sure they're somewhat correct. Is it okay to just toss them here?
05:15:11 <aristid> companion_cube: how are subqueries not possible in relational algebra? (which you said is a subset of what datalog can do)
05:15:12 <Eduard_Munteanu> Not that you need one, but it earns you a free Yoneda shake. :P
05:15:29 <aristid> companion_cube: datalog without negation isn't just a different approach, it's strictly less powerful
05:15:36 <GaXo> Trying Data.GraphViz with Data.Graph but i'm getting: No instance for (Data.Graph.Inductive.Graph.Graph GHC.Arr.Array) for (graphToDot nonClusteredParams g) where g is Graph. Can you help me?
05:15:45 <companion_cube> aristid: I'm just not sure it can be reduced cleanly to something without subqueries
05:15:50 <ski_> companion_cube : hm, i thought one required stratification, and then interpreted `p,not q' by set difference ?
05:15:51 <companion_cube> aristid: but how? What is less powerful?
05:16:01 <aristid> companion_cube: datalog without negation.
05:16:06 <Ghoul_> I found this benchmark on gist. It benchmarks CPS, ConstT and regular construction of a tree. CPS/ConstT are about 3 magnitudes faster than the regular construction and I can't figure out why http://lpaste.net/92366
05:16:09 <hiptobecubic> ineda shake too
05:16:15 <companion_cube> aristid: oh, like differences? right
05:16:17 <mjboa> hey can anyone enlighten me? What does fix from Data.Function do? Specifically, I'm trying to understand the defition of Iteratee in Data.Enumerator
05:16:25 <Eduard_Munteanu> hari_: yes, I think it's definitely not the best language to teach first. Especially since they never intend to teach any low-level or hw-specific stuff.
05:16:30 <companion_cube> but datalog with negation doesn't necessarily require stratification
05:16:36 <companion_cube> just the existence of stable models
05:16:41 <mjboa> also confusing me is the use of ($ m0) in the definition for bind for Iteratee
05:16:51 <Eduard_Munteanu> mjboa: link?
05:16:58 <mjboa> http://hackage.haskell.org/packages/archive/enumerator/0.4.19/doc/html/src/Data-Enumerator-Internal.html
05:17:07 <aristid> companion_cube: yes... so that's where there are even different datalogs even if you have negation
05:17:07 <companion_cube> http://www.sciencedirect.com/science/article/pii/0743106694000285  for instance
05:17:12 <hari_> Eduard_Munteanu, I agree. C++ put me off OOP for a long time
05:17:22 <hari_> Even now I am prejudiced against OOP
05:17:46 <mjboa> all in the definition of bind for Iteratee a m
05:19:02 <Eduard_Munteanu> mjboa: it's (fix $ do ...) then you apply m0 to that.
05:19:10 <Eduard_Munteanu> s/do//
05:19:34 <Eduard_Munteanu> mjboa: you do understand the ($ m0) section, right?
05:19:40 <mjboa> not really
05:19:44 <ski_> mjboa : `fix $ \bind m -> ..bind..m..' is the same as `let bind m = ..bind..m.. in bind'
05:19:46 <mjboa> i mean it's reversed somehow
05:19:54 <hpc> mjboa: you know what ($) is?
05:19:58 <hpc> @src ($)
05:19:58 <lambdabot> f $ x = f x
05:19:58 <mjboa> yea
05:20:04 <hpc> so take (flip ($))
05:20:09 <Eduard_Munteanu> :t ($ ?x)
05:20:10 <lambdabot> (?x::a) => (a -> b) -> b
05:20:12 <hpc> which is (x # f = f x)
05:20:16 <hpc> and then partially apply it to x
05:20:25 <mjboa> ok got that
05:20:36 <Eduard_Munteanu> :t (+ 3)
05:20:36 <hpc> now you have something of type (a -> b) -> b
05:20:36 <lambdabot> Num a => a -> a
05:20:46 <Taneb> Huh
05:20:51 <ski_> mjboa : and `($ m0) fix $ \bind m -> ..bind..m..' is the same as `let bind m = ..bind..m.. in bind m0'
05:20:51 <hpc> which is a function that takes a function from (a -> b), then applies an a to it
05:20:59 <Taneb> Github + Literate haskell + CPP doesn't mix well
05:21:00 <hpc> specifically the one you partially applied
05:21:11 <hpc> @let foo = ($ 10)
05:21:12 <lambdabot>  Defined.
05:21:21 <hpc> > foo (+ 13)
05:21:26 <Eduard_Munteanu> They chose to do that because the right side of fix is taken up by the definition itself.
05:21:27 <lambdabot>   23
05:21:32 <ski_> (er s/fix/$ fix/ in what i last said)
05:21:32 <hpc> > foo (* 6)
05:21:33 <aegis__> hey! could someone explain me how this code actually works: http://lpaste.net/7073542533552275456 ? I have an intuition on how it works but I don't understand why it doesn't get stuck as fib needs fib to build one more element of the list why itself needs fib which..
05:21:35 <Taneb> It seems like it's interpreting #ifdef as a header
05:21:36 <lambdabot>   60
05:22:00 <hpc> aegis__: okay, so
05:22:04 <companion_cube> ski_: even with stratified negation, I think datalog is more powerful than relational algebra
05:22:12 <hpc> aegis__: we begin with fib = 1 : 1 : <thunk>
05:22:14 <companion_cube> (you can do set difference with negation)
05:22:24 <hpc> aegis__: we force the first two elements, and nothing really happens
05:22:35 <mjboa> so what does fix do?
05:22:36 <ski_> companion_cube : hm, did i imply otherwise ?
05:22:39 <companion_cube> no
05:22:41 <hpc> aegis__: now we force the next element, which is the head of (zip fib (tail fib))
05:22:53 <aegis__> hpc: so far so good, which is (1, 1)
05:22:57 <hpc> aegis__: so fib = 1 : 1 : <thunk> and tail fib = 1 : <thunk>
05:23:04 <Ghoul_> aegis__: theres a major win here with laziness
05:23:14 <hpc> aegis__: so we follow the definition of zip, which is to get (1, 1) yes
05:23:16 <mjboa> is it like a recursive let or something?
05:23:17 <Ghoul_> the first 2 elements are certain, and after that, they are only generated on-demand
05:23:18 <hpc> and add them to get two
05:23:19 <GaXo> Mayb i should not use Data.Graph.
05:23:25 <hpc> now fib = 1 : 1 : 2 : <thunk>
05:23:31 <GaXo> What do recomend me for graphs in haskell?
05:23:32 <companion_cube> ski_: but thanks, that made things clearer in my head about why negation is necessary
05:23:43 <hpc> we force the next element of that thunk, which is 1 + 2
05:23:52 <hpc> because tail fib = 1 : 2 : <thunk>
05:24:14 <hpc> there should really be an animation for this
05:24:23 <Eduard_Munteanu> mjboa: it lets one write recursive definitions without explicit recursion. E.g. fix $ \f -> ... f something  gives you something like   foo = ... foo something
05:24:30 <Eduard_Munteanu> :t fix
05:24:31 <lambdabot> (a -> a) -> a
05:25:13 <aegis__> hpc: that's the part I am confused about; how did 2 get pushed to the result of fib? I mean, we are building a sequence in the first call to fib but the call to fib in the list comprehension is "another call", building another sequence, no? (I migh tbe unclear here --')
05:25:13 <Eduard_Munteanu> > fix (1:)
05:25:15 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:25:53 <ski_> companion_cube : is necessary for what ?
05:25:59 <Eduard_Munteanu> fix (1:) = fix (\recurse -> 1:recurse)
05:26:03 <Eduard_Munteanu> @src fix
05:26:04 <lambdabot> fix f = let x = f x in x
05:26:38 <int-e> Ghoul_: This is analogous to constructing lists: The 'Tree' version is akin to constructing a list of length n by appending n singleton lists; the CPS version is analogous to using a difference list.
05:26:38 <Eduard_Munteanu> That's a little complicated though.
05:26:42 <ski_> hpc : please, fibonacci begins with `0' :)
05:26:46 <companion_cube> ski_: I mean, datalog without negation isn't powerful enough, if it cannot simulate relational algebra
05:26:49 <Eduard_Munteanu> fix f = f (fix f)   is easier to comprehend.
05:26:58 <ski_> ok
05:27:29 <ski_>   fix f = x where x = f x  -- is the version i prefer to read
05:27:35 <mjboa> alright i think im slowly comprehending it, thanks
05:27:45 <ski_> > fix (0 :)
05:27:46 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
05:28:08 <int-e> Ghoul_: in particular, fullTree n will create n root nodes (and later traverse them), while the CPS version constructs only one.
05:28:11 <hpc> aegis__: getting into implementation details would be that fib is modified in place
05:28:29 <ski_> > (`fix` 12) $ \fib n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2)
05:28:30 <lambdabot>   144
05:28:49 <hpc> aegis__: every instance of "fib" in the definition is shared, so evaluating part of one leaves it evaluated for all of them
05:29:01 <Kaini> Why is there no zipWithM_ with the function as last parameter?
05:29:01 <hpc> but even without the sharing you would just have a really slow fib
05:29:06 <int-e> Ghoul_: I guess the comment in the beginning says that fullTree n is O(n^2) and the other two versions are O(n). That's precisely what happens.
05:29:16 <Eduard_Munteanu> > ($ 12) $ fix $ \fib n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2)
05:29:17 <lambdabot>   144
05:29:21 <aegis__> hpc: ok, so there is really only one instance of the result of fib
05:29:26 <hpc> yeah
05:30:15 <aegis__> hpc: is there a name for this "property" ? I mean, if I want to check how another language treats this kind of sitution
05:30:16 <Eduard_Munteanu> Kaini: that'd be nice, yeah... like forM is for mapM.
05:30:52 <hpc> aegis__: "sharing" is what you probably want
05:31:26 <Eduard_Munteanu> aegis__: also "memoization"
05:31:53 <aegis__> hpc: ok, thanks a lot for your explanations, it's much clearer now :-)
05:32:25 <hpc> aegis__: sharing isn't really important to the definition, btw
05:32:25 <Eduard_Munteanu> aegis__: though it's specific to non-strict languages, otherwise the order of evaluation is already fixed.
05:32:42 <mjboa> let f x = x + 1
05:32:44 <hpc> all it does is make it faster
05:32:52 <mjboa> how can I understand the type ($ f)
05:33:19 <Eduard_Munteanu> mjboa: ($ f) means "apply f to something (as an argument)"
05:33:46 <hpc> mjboa: to expand it out completely, ($ f) g = g (\x -> x + 1)
05:34:04 <aegis__> Eduard_Munteanu: makes sense
05:34:31 <bmm_> I'm getting a space overflow I don't understand. http://lpaste.net/92367 Should I create an issue for the murmur-hash library?
05:34:31 <mjboa> so it's (flip $) f?
05:34:38 <hpc> yes
05:34:47 <Eduard_Munteanu> (flip ($)) f
05:35:04 <hpc> all sections work that way
05:35:10 <hpc> (+ 5) = flip (+) 5
05:35:25 <mjboa> Eduard_Munteanu: that's where i was stuck, didn't put the parenthesis around the $
05:35:28 <mjboa> thanks
05:35:31 <hpc> (- 5) = negative 5 -- minus is kind of a silly one
05:35:45 <Eduard_Munteanu> :t (flip $) ?f
05:35:46 <lambdabot> (?f::a -> b -> c) => b -> a -> c
05:35:50 <Eduard_Munteanu> :t (flip ($)) ?f
05:35:51 <lambdabot> (?f::b) => (b -> c) -> c
05:35:56 <aegis__> hpc: erm it might not be that part I was confused about then; what I mean is that when you have fib = 1 : 1 : 2 : [a+b, (a, b) <- zip fib (tail fib)], how does the list comprehension draws (1,2) out of it? how does it get access to this 2 we just pushed? if there is only one instance of the result of fib it makes sense but then it's not only a matter of speed; the function wouldn't work without it
05:36:06 <ski_> aegis__ : also, "memoization/tabling of functions" is a different thing
05:36:23 <Eduard_Munteanu> (flip $) f = flip $ f = flip f
05:36:53 <mjboa> Eduard_Munteanu: is the ? there something for lambdabot? never seen that syntax before
05:36:56 <tommi> !list
05:36:57 <monochrom> tommi: http://lpaste.net
05:37:18 <Eduard_Munteanu> mjboa: it's for implicit parameters, I'm misusing it to introduce and ask for f's type.
05:37:57 <Eduard_Munteanu> mjboa: so it's not a lambdabot thing, it's a GHC Haskell thing
05:38:28 <ski_> aegis__ `fib = 1 : 1 : 2 : [a+b, (a, b) <- zip fib (tail fib)]' is equivalent to `fib = 1 : fib2; fib2 = 1 : fib3; fib3 = 2 : fib4; fib4 = [a+b, (a, b) <- zip fib (tail fib)]'
05:38:33 <aegis__> mjboa: 7.8.3 http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/other-type-extensions.html
05:39:39 <aegis__> ski_: light bulb, thanks !
05:39:44 <ski_> aegis__ : then `fib4 = [a+b | (a, b) <- zip fib (tail fib)]', in the presence of the other definitions are equivalent to `fib4 = [a+b | (a, b) <- zip (1:1:2:fib4) (tail (1:1:2:fib4))]'
05:39:54 <ski_> which is equivalent to `fib4 = [a+b | (a, b) <-'
05:39:56 <ski_> er
05:40:04 <ski_> `fib4 = [a+b | (a, b) <-'
05:40:08 * ski_ sighs
05:40:51 <ski_> which is equivalent to `fib4 = [a+b | (a,b) <- zip (1:1:2:fib4) (1:2:fib4)]'
05:41:21 <ski_> which is equivalent to `fib4 = (1 + 1) : (1 + 2) : [a+b | (a,b) <- zip (2:fib4) fib4]'
05:41:31 <ski_> which is equivalent to `fib4 = 2 : 3 : [a+b | (a,b) <- zip (2:fib4) fib4]'
05:41:41 <aegis__> ski_: you can stop there, the expansion made it clear :p thanks
05:41:51 <ski_> which is equivalent to `fib4 = 2 : fib5; fib5 = 3 : fib6; fib6 = [a+b | (a,b) <- zip (2:fib4) fib4]'
05:41:54 <ski_> &c.
05:42:12 <donri> fibs = 0 : 1 : (zipWith (+) <*> tail) fibs
05:43:20 <ski_> aegis__ : it would be enough here to provide the first two values initially (outside the list comprehension) -- noting that one usually starts with `0',`1' rather than `1',`1', that'd be `fibs = 0 : 1 : zipWith (+) fibs (tail fibs)'
05:44:16 <arkeet> if you provide more than two, it's wrong.
05:44:22 <mjboa> I want to practice more with haskell but I find myself starved of ideas or worthwhile projects. What can I write that will lead me to a deeper understanding of haskell and possibly also creating something useful along the way?
05:44:27 <donri> @quote aztec
05:44:28 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
05:44:28 <arkeet> > fix $ \fibs -> 1:1:2:zipWith (+) fibs (tail fibs)
05:44:29 <lambdabot>   [1,1,2,2,3,4,5,7,9,12,16,21,28,37,49,65,86,114,151,200,265,351,465,616,816,...
05:44:31 <ski_> aegis__ : so, due to "memoization of values", we so to speak get "internal names" generated for each list node, and so the whole generation "chases its own tail"
05:44:33 <arkeet> not very fibby.
05:44:59 <deech> Does c2hs allow me to write custom functions to process enumerations?
05:45:07 <Ghoul_> int-e: thanks I /think/ I have some understanding now
05:45:25 <mjboa> How do i get to that point to where I can contribute to GHC for example? It seems like there's an enormous gap between reading Learn you a haskell/real world haskell and contributing to GHC or writing a useful library
05:45:31 <arkeet> > fix $ \fibs -> 1:1:1:1:1:zipWith (+) fibs (tail fibs)
05:45:33 <lambdabot>   [1,1,1,1,1,2,2,2,2,3,4,4,4,5,7,8,8,9,12,15,16,17,21,27,31,33,38,48,58,64,71...
05:45:57 <ski_> aegis__ : and what arkeet says
05:46:23 <arkeet> but yes, starting with 0,1 is good.
05:46:48 <arkeet> F_0 = 0, etc.
05:47:10 <zomg> mjboa: what do you code in other languages than haskell?
05:47:26 <ion> I thought everyone knows the Fibonacci sequence begins with -144, 89.
05:47:27 <arkeet> @localtime
05:47:27 <lambdabot> Local time for arkeet is 土 8月 31 05:46:03 2013
05:47:29 <arkeet> oops.
05:47:53 <mjboa> python
05:48:00 <arkeet> what do you do in python?
05:48:09 <mjboa> not much honestly
05:48:13 <mjboa> mostly mess around
05:48:25 <zomg> what was the reason you learned haskell (or the reason you learned python for that matter)
05:48:43 <mjboa> python initially because of django
05:48:46 <donri> > fix ((0:1:).(zipWith(+)`ap`tail))
05:48:47 <lambdabot>   The operator `:' [infixr 5] of a section
05:48:47 <lambdabot>      must have lower precedence th...
05:48:58 <donri> > fix ((0:).(1:).(zipWith(+)`ap`tail))
05:49:00 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:49:04 <GaXo> Hello?
05:49:14 <zomg> mjboa: well, you could do web apps with haskell then. A variety of nice libs are available for that
05:49:34 <mjboa> im a second year comp sci student now, had haskell in a programming course. found it fascinating
05:49:38 <arkeet> donri: why not <*> instead of `ap`
05:49:51 <donri> arkeet: because aztec :(
05:49:59 <Eduard_Munteanu> How do you invert Parsec parsers? I'm having difficulty seeing how you take care not to overlap parsers.
05:49:59 <arkeet> but one character
05:50:00 <donri> but With destroys it
05:50:01 <GaXo> I want to represent my datastructure as graph and then visualize it. What library do you guys recommend?
05:50:06 <mjboa> been tying to understand category theory, type inference etc ever since
05:50:09 <arkeet> @quote zip`ap`tail
05:50:09 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
05:50:26 <mjboa> i find it much more compelling than python
05:50:31 <zomg> mjboa: yeah that's the reason I'm using haskell as well, it's more interesting than the other languages I know
05:50:42 <Eduard_Munteanu> GaXo: diagrams?
05:50:45 <donri> > fix((0:).(1:).(zipWith(+)<*>tail))
05:50:46 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:50:50 <Eduard_Munteanu> GaXo: I mean the 'diagrams' package.
05:50:53 <Eduard_Munteanu> @hackage diagrams
05:50:53 <lambdabot> http://hackage.haskell.org/package/diagrams
05:50:57 <donri> > fix((0:).(1:).zipWith(+)<*>tail)
05:50:58 <lambdabot>   Couldn't match type `[c0] -> [c0]' with `[a0]'
05:50:58 <lambdabot>  Expected type: [c0] -> [a0]...
05:51:04 <zomg> mjboa: when I was starting haskell I really just took whatever ideas I wanted to code and instead of using whatever else I knew I just tried doing it in haskell =)
05:51:23 <nooodl> > fix$(0:).(1:).(zipWith(+)<*>tail)
05:51:24 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:52:10 <mjboa> like what? all the random stuff i think of seems to have been done already and 100 times better at that and then i get the feeling im wasting my time
05:52:43 <GaXo> Eduard_Munteanu: Uh, sorry, visualising isn't purpose but a nice to have thing. Main aspects of desired graph library should be performance and it should be possible to store something in vertices.
05:52:53 <ski_> > fix ((0 :) . scanl (+) 1)
05:52:54 <Eduard_Munteanu> Oh.
05:52:57 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:53:15 <zomg> mjboa: well it's hard to say what would be compelling for you, but I'd imagine there's some reason why you're studying compsci and languages
05:53:25 <GaXo> Data.Graph from containers is fine but lacking ease of visalisation and graph ops.
05:53:40 <zomg> mjboa: I'd honestly just do whatever seems to be fun and interesting and not worry about if it has been done before or not. You'll learn something along the way for sure
05:54:03 <mjboa> true
05:55:02 <GaXo> It's truly great to make graph easy as graphFromEdges' [(tile :: myCustomADT, 1 :: Int, [1])]. And FGL seems to be dead long ago...
05:55:25 <GaXo> Any FGL gurus around?
05:55:44 <GaXo> What these labels(LNode, LVertex) are about?
05:55:58 <GaXo> Does main purose of labels is to store custom info?
05:56:16 <Ghoul_> int-e: so, could I say simply, that the tree is "double lazy" ?
05:57:33 <ski_> preflex: xseen ddarius
05:57:35 <preflex>  ddarius was last seen on freenode/#haskell 364 days, 3 hours, 54 minutes and 10 seconds ago, saying: > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
05:57:59 <arkeet> > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 "hello, world"
05:58:01 <lambdabot>   "hell, wold"
05:58:11 <arkeet> > let f n = g (n-1) where g k [] = []; g 0 (_:xs) = g (n-1) xs; g k (x:xs) = x:g (k-1) xs in f 5 [0..]
05:58:13 <lambdabot>   [0,1,2,3,5,6,7,8,10,11,12,13,15,16,17,18,20,21,22,23,25,26,27,28,30,31,32,3...
05:58:20 <arkeet> ah.
05:59:11 <GaXo> Well, FGL seems to be very odd library.
05:59:23 <GaXo> Why on earth i'm forced to label edges?
05:59:58 <int-e> Ghoul_: maybe, you'd have to explain what you mean by that.
06:01:56 <Ghoul_> sorry I think I understood it wrong
06:02:15 <Ghoul_> im having a hard time understanding how they behave differently because they look like they should produce the same structure
06:16:24 <Eduard_Munteanu> Hm, I think I figured it out: isNot = manyTill anyToken . try . (eof <|>)
06:19:05 <Eduard_Munteanu> Then sepBy could be something nicer like  sepBy' sep = sepBy (isNot sep) sep
06:20:05 <Eduard_Munteanu> Needs a better name than isNot though.
06:25:54 * hackagebot final 0.1 - utility to add extra safety to monadic returns  http://hackage.haskell.org/package/final-0.1 (GergelyRisko)
06:34:15 <turiya> hi
06:35:15 <hari_> I actually find the wikipedia page on monad to be a pretty sound explanation of the concept. Seems like I am beginning to get a feel for the idea
06:35:29 <turiya> i am trying to use Data.Graph.Inductive.Graph but dont understand how to create a graph. The Graph is a type class so the type of my Graph should be Graph Gr, however this gives me an error
06:36:04 <turiya> Predicate `Graph Gr' used as a type
06:40:37 <aegis__> turiya: you can't use a typeclass as a type constructor
06:40:49 <aegis__> :k Eq
06:40:50 <lambdabot> * -> Constraint
06:41:12 <aegis__> :k Maybe
06:41:12 <lambdabot> * -> *
06:41:50 <turiya> aegis__ : aha, thanks
06:42:02 <turiya> it worked now
06:42:41 <Vendethiel> Is there a way to get a function as value ? ala Function1
06:46:15 <haasn> is there a good way to write :: Foldable f => f a -> Tree a -- such that the resulting tree is as balanced as possible, and preserves the fold order?
06:47:11 <haasn> or [a] -> Tree a, really
06:47:21 <donri> Vendethiel: a function is a value
06:47:43 <Vendethiel> donri: yeah but it automatically gets called, doesn't it ?
06:47:49 <donri> type Function a b = a -> b
06:47:51 <donri> Vendethiel: no
06:48:08 <Vendethiel> mmh ok
06:48:10 <Jaxan> Vendethiel: it can only be called if there are arguments to call it with
06:48:25 <donri> Vendethiel: only if you apply it to an argument and its evaluation is forced
06:49:32 <Jaxan> > length [\n -> n+1, \n -> n*2]
06:49:33 <lambdabot>   2
06:50:07 <Jaxan> Vendethiel: in this example a list of functions is used, but the functions arent called
06:55:37 <meretrix> Say I have "data X = A | B", "data Data = { x :: X, y :: Int }", and "data Pair = Pair Data Data".  Is there any way to constrain the Pair constructor to require the first argument has "x == A" and the second has "x == B"?
06:55:58 <meretrix> Is this a case where I need GADT?
06:57:43 <aegis__> meretrix: that wouldn't make much sense I believe; A and B are data constructors, not types
06:59:52 <donri> data A; data B; data Data x = Data { x :: x, y :: Int }; data Pair = Pair (Data A) (Data B)
07:00:16 <donri> actually
07:00:29 <donri> data Data x = Data { y :: Int }
07:01:48 <meretrix> Ok, I guess that makes sense. So A and B become types.
07:01:49 <donri> data Data x where DataA :: Int -> Data A; DataB :: Int -> Data B
07:03:22 <donri> but not sure this justifies a gadt though, data A = A; data Data x = Data { x :: x, y :: Int} -- now DataA == Data A
07:04:33 <hpc> that's just an ordinary ADT with record syntax
07:05:23 <donri> exactly
07:13:42 <ski_>   data A = MkA; data B = MkB
07:13:50 <ski_>   data Data :: * -> *
07:13:52 <ski_>     where
07:14:01 <ski_>     DataA {y :: Int} :: Data A
07:14:08 <ski_>     DataB {y :: Int} :: Data B}
07:14:12 <ski_>   data Pair = MkPair (forall a. a -> Data a)
07:15:01 <ski_> hm, actually, the last one doesn't work
07:15:21 <donri> also i think they're changing record gadt syntax
07:15:29 <ski_> donri : to what ?
07:15:35 <donri> but again, i don't think you need a gadt in this simple case
07:15:45 * haasn wonders how many people actually genuinely use the operators like <.&.~ in lens
07:15:55 * hackagebot aws 0.8.0 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.8.0 (AristidBreitkreuz)
07:15:57 * hackagebot algebraic-classes 0.5.1 - Conversions between algebraic classes and F-algebras.  http://hackage.haskell.org/package/algebraic-classes-0.5.1 (SjoerdVisscher)
07:17:17 <aristid> (almost exactly one year after 0.7.0, aws 0.8.0 is out :D)
07:17:52 <aristid> how long does hackage need these days to get to build packages?:)
07:18:11 <deech> What is the recommended way of binding a C enum to Haskell? In the binding I'm working on the enum isn't exhaustive and numbers are being cast to it in different parts of the code.
07:18:11 <donri> ski_: https://github.com/ghc/ghc/commit/9fc2778cf20990524b13705a519b0c337ad197fe  -- not sure if it was already deprecated though
07:18:28 <Makoryu> I heard somewhere that GHC doesn't know how to represent enumerable datatypes as plain ints. Is this still true?
07:18:53 <aristid> is it possible that hackage doesn't do any builds anymore? :(
07:19:06 <donri> aristid: it has to to build docs
07:19:22 <Makoryu> deech: Ouch. In that situation I think I'd use a layer of indirection that "translates" the C values to a Haskell type that only represents legal states
07:19:36 <aristid> donri: hm
07:19:54 <aristid> donri: it's just that all the What's new packages have no docs/no built tag
07:20:35 <donri> aristid: the bottom ones do for me...
07:21:05 <deech> Makoryu: How do you mean?
07:21:35 <aristid> donri: hmm either i was blind or they are being built as we speak:)
07:21:51 <Eduard_Munteanu> Hm... why aren't empty declarations allowed for newtypes?
07:22:06 <donri> aristid: actually only the top three ones haven't built yet
07:22:18 <donri> aristid: i think it builds stuff every few hours
07:22:20 <Makoryu> deech: Well, I'd write a datatype describing what the enum is supposed to represent, and then only allow access to the C version via functions that can translate back and forth between those formats
07:22:38 <Makoryu> Eduard_Munteanu: Because of the way newtypes allocate storage
07:22:38 <aristid> donri: this one is a bit older and also not built, hm: http://hackage.haskell.org/package/tls-debug-0.2.5
07:22:53 <Eduard_Munteanu> Makoryu: how do you mean?
07:22:53 <donri> aristid: not a lib
07:22:59 <deech> Makoryu: Ah. Thanks!
07:23:05 <Makoryu> Eduard_Munteanu: Don't think of them like datatypes. Think of them as opaque type synonyms
07:23:52 <Eduard_Munteanu> Makoryu: well, yes... and IMO newtype VoidN ~ newtype VoidN' = VoidN' Void    where data Void
07:24:03 <donri> what would an empty newtype even *mean*
07:24:05 <Eduard_Munteanu> Actually they're the same thing, not just ~
07:24:13 <Makoryu> deech: I dunno if that's the right thing to do *in this case* but as a rule of thumb you should have "gatekeepers" like that between non-Haskell (dirty) types and typesafe stuff
07:24:15 <donri> newtype wraps an existing type
07:24:43 <Makoryu> Eduard_Munteanu: Newtypes are lifted
07:24:45 <Eduard_Munteanu> It means only bottom inhabits it.
07:24:51 <Makoryu> IIRC
07:25:04 <Makoryu> So it does generate extra thunks
07:25:16 <Eduard_Munteanu> I thought it wasn't supposed to.
07:25:17 <donri> Eduard_Munteanu: but what type does it wrap? i suppose we could have a syntax for wrapping a type without a value constructor...
07:25:23 <Makoryu> Maybe I'm remembering wrong
07:25:36 <Eduard_Munteanu> donri: it doesn't need to wrap a type.
07:25:38 <donri> newtype Empty :: Void, or something
07:25:39 <Makoryu> At any rate you can only use newtype to wrap existing types, even if they're Void
07:25:56 <donri> which might let you derive instances or something
07:26:14 <Eduard_Munteanu> My point was it should be allowed because a newtype wrapping a void data Void is exactly the same as that Void.
07:26:15 <donri> Eduard_Munteanu: it does, because that's what newtype *does*
07:26:37 <Eduard_Munteanu> donri: that's what newtype currently does, yes
07:26:44 <donri> Eduard_Munteanu: but two Void types are not equal...
07:26:57 <Eduard_Munteanu> donri: they should be isomorphic
07:27:20 <Makoryu> Eduard_Munteanu: It's not just what newtype *happens* to do. It is the raison d'être of newtype.
07:27:48 <Eduard_Munteanu> And the newtype wrapper and the original Void would be isomorphic, since the newtype must not introduce another bottom.
07:27:55 <donri> Eduard_Munteanu: that just means you can convert between them, not that they have the same meaning or the same instances even
07:28:23 <donri> newtype Empty -- what Void type should this be based on?
07:28:37 <Eduard_Munteanu> donri: well, none... what is Void based on? :)
07:29:09 <donri> Eduard_Munteanu: but Void is `data Void` which doesn't need to be based on anything
07:29:24 <Makoryu> Eduard_Munteanu: If data and newtype could be conflated in the way you seem to imply they ought to be, they wouldn't need to be different features
07:29:52 <Eduard_Munteanu> Makoryu: of course they need to, it's only that they coincide in the void declaration case
07:30:19 <Eduard_Munteanu> They're not the same even when the data has a single constructor with a single field.
07:30:38 <Makoryu> Eduard_Munteanu: Then why would there be a special case for this?
07:31:12 <Eduard_Munteanu> Makoryu: it would not be a special case, actually. I'm arguing any sane definition yields the exactly same semantics for the void case.
07:31:29 <Eduard_Munteanu> Unless one specifically forbids it, that is. :)
07:32:00 <Makoryu> I mean a special case in the implementation
07:32:18 <Eduard_Munteanu> Oh, I don't know how they're actually handled.
07:32:20 <Makoryu> A special case in the compiler's *representation* of this feature
07:33:42 <Makoryu> Eduard_Munteanu: When it comes down to it, any data-vs.-newtype contrasts probably work the way they do because implementing it another way would be really hard
07:33:59 <Makoryu> And not necessarily because the semantics make sense on their own
07:34:51 <Eduard_Munteanu> I guess so.
07:36:02 <Makoryu> 'Cause if the latter was the only motivating factor at work, maybe data and newtype should be the same thing, and the compiler should be smart enough to allocate storage appropriately depending on the content of the type declaration as opposed to the keyword in use
07:36:47 <Makoryu> But I dunno if that makes sense either
07:36:49 <Eduard_Munteanu> Makoryu: right, though the allocation thing isn't all there is to it. 'data' is supposed to thunk, some code depends on that
07:37:24 <user1843> is it right to say that in haskell any value has been create by a data constructor? (which can be built-in, like 'a', 'b' or 1, 2, 3 but still, a data constructor)
07:38:02 <Eduard_Munteanu> user1843: integers aren't inductively defined
07:38:28 <Eduard_Munteanu> user1843: however they do wrap actual integers in a constructor
07:38:30 <Eduard_Munteanu> @src Int
07:38:30 <lambdabot> data Int = I# Int#
07:38:40 <user1843> Eduard_Munteanu: but number literals behave like data constructors, don't they? you can pattern match over them etc
07:38:59 <Makoryu> user1843: Well.... sorta...
07:39:00 <Eduard_Munteanu> user1843: no, that's not pattern-matching
07:39:12 <donri> it's just desugared to Eq i think?
07:39:13 <Eduard_Munteanu> user1843: well, the compiler pretends it is but in fact it uses the Eq instance
07:39:24 <Eduard_Munteanu> Yeah.
07:39:44 <Makoryu> user1843: Pattern matching on numeric literals is actually syntactic sugar for using appropriate guards
07:39:53 <donri> also try pattern matching on a function
07:39:56 <donri> functions are values
07:39:59 <Makoryu> (Well, maybe that's not quite true, but that's how you should think of it)
07:40:03 <user1843> Eduard_Munteanu: ok ok, interesting; any article so I can look deeper on that?
07:40:17 <Eduard_Munteanu> Not sure. :/
07:41:02 <shachaf> The Report specifies the behavior exactly.
07:41:27 <shachaf> (Well, OK, not exactly. GHC changed things a bit. But close enough.)
07:41:35 <Eduard_Munteanu> :k Int#
07:41:36 <lambdabot>     Not in scope: type constructor or class `Int#'
07:41:36 <lambdabot>     Perhaps you meant one of these:
07:41:36 <lambdabot>       `Int' (imported from Data.Int), `Int8' (imported from Data.Int)
07:42:09 <Eduard_Munteanu> Grr.
07:42:18 <Eduard_Munteanu> Should be #.
07:42:23 <shachaf> Int# is an implementation detail, anyway, and not an important one (take Integer instead).
07:42:27 <StahlGrau> quchen: good to see ya
07:42:31 <shachaf> It's not part of the language standard.
07:42:34 <Eduard_Munteanu> @src Integer
07:42:34 <lambdabot> data Integer = S# Int#
07:42:34 <lambdabot>              | J# Int# ByteArray#
07:42:36 <Eduard_Munteanu> :P
07:42:48 <Eduard_Munteanu> But anyway, you're right. :)
07:43:33 <shachaf> I know how Integer is defined in integer-gmp.
07:44:18 <newbie2> how can i make length list to return Integer?
07:44:25 <newbie2> it does Int
07:44:40 <donri> :t genericLength
07:44:41 <lambdabot> Num i => [b] -> i
07:44:48 <shachaf> fromInteger . length
07:44:52 <shachaf> Er.
07:45:00 <shachaf> fromIntegral . length
07:45:03 <shachaf> Don't use genericLength.
07:45:09 <donri> yeah
07:45:14 <newbie2> what is that?
07:45:23 <shachaf> What is what?
07:45:28 <newbie2> genericLength
07:45:34 <shachaf> @src genericLength
07:45:34 <lambdabot> genericLength []    = 0
07:45:35 <lambdabot> genericLength (_:l) = 1 + genericLength l
07:45:56 <donri> genericLength works when the length of the list is larger than the maxBound of Int, in which case why are you using lists :p
07:45:56 <Makoryu> newbie2: It's length, but defined with a different type
07:45:58 <shachaf> A function that shouldn't be used unless you're using lazy naturals.
07:46:25 <shachaf> donri: OK, it works in that case. If you're using 32-bit Int and you need a bigger length, write your own.
07:46:40 <shachaf> genericLength will *certainly* not work in that case. You'll just get a stack overflow.
07:47:11 <newbie2> so i hae no way to get length of list with more then 2^32-1 items?
07:47:31 <Makoryu> newbie2: Well...
07:47:44 <shachaf> If you're using 32-bit GHC and you want to do that, you should just write your own length function.
07:47:47 <hpc> newbie2: you've lost the way long before 2^32
07:47:50 <shachaf> genericLength will not help you.
07:47:53 <donri> length is O(n) for lists
07:48:23 <newbie2> hpc: why?
07:48:28 <donri> and "n" may not even be finite for lists
07:48:37 <donri> > length [0..]
07:48:43 <donri> ...wait for it...
07:48:44 <lambdabot>   mueval-core: Time limit exceeded
07:49:54 <shachaf> That's not an answer to their question, though.
07:50:12 <Makoryu> > length [0..maxBound]
07:50:13 <lambdabot>   No instance for (GHC.Num.Num a0) arising from the literal `0'
07:50:13 <lambdabot>  The type var...
07:50:21 <Makoryu> > length [0..maxBound :: Int]
07:50:28 <lambdabot>   mueval-core: Time limit exceeded
07:51:49 <donri> > length [0..maxBound :: Int32]
07:51:56 <lambdabot>   mueval-core: Time limit exceeded
07:53:44 <Makoryu> It would be neat if there was some kind of hook into the type system where ambiguous types (as in "length [0..maxBound]") could be guessed somehow instead of throwing an error
07:53:55 <Makoryu> And if lambdabot could be sassy about it
07:54:07 <Makoryu> "You didn't specify a type here so I'm guessing 'Bool'"
07:54:26 <Makoryu> This would be completely useless but fun
07:54:35 <donri> that's extended default rules
07:54:36 <shachaf> It exists, but not for Enum/Bounded.
07:54:48 <hpc> no no no, see, ghc would be guessing totally at random
07:55:13 <hpc> it would get a list of all the types in scope that meet the constraints then pick one
07:55:25 <hpc> "oh, you want to test for equality? i'm gonna say......... Handle"
07:55:35 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:Handle
07:55:42 <Makoryu> Exactly
07:56:00 <hpc> i for one, approve of the idea of acme ghc extensions
07:57:17 <quchen> Random defaulting? That doesn't sound like a very good idea. Not even for acme.
07:57:18 <donri> > maxBound :: ()
07:57:19 <lambdabot>   ()
07:57:47 <donri> > [minBound..] :: [()]
07:57:49 <lambdabot>   [()]
07:57:52 <Makoryu> quchen: Not *completely* random, of course. First it would have to verify that any candidates meet all the requirements
07:58:08 <Makoryu> But after that, since the user didn't specify...
07:58:19 <donri> Makoryu: because you fear type errors? :)
07:58:29 <donri> i'd rather get a helpful error than arbitrary defaulting
07:58:30 <Makoryu> Nah. Because I think it would be funny
07:58:33 <donri> hah
07:58:49 <quchen> {-# LANGUAGE Funny #-}
07:59:50 <ski> Makoryu : hm, reminds me of how SML/NJ invents skolem types for you, when it can't generalize a tyvar (due to value restriction) ..
08:00:30 <Makoryu> I'm unfamiliar with SML/NJ except for vague memories of some of the syntax differences from OCaml
08:00:58 * hackagebot cabal-debian 3.4.3 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-3.4.3 (DavidFox)
08:01:13 <int-e> @quote malbolge
08:01:14 <lambdabot> gwern says: Haskellers! Tonight we write in Malbolge!
08:01:21 <int-e> @quote malbolge
08:01:21 <lambdabot> gwern says: Haskellers! Tonight we write in Malbolge!
08:02:26 <ski> well, in some cases (in Haskell syntax), when it has inferred `foo :: (_a -> Bool) -> Foo _a -> Option _a', it can't generalize the meta-tyvar `_a' to `foo :: forall a. (a -> Bool) -> Foo a -> Option a'
08:03:07 <ski> Makoryu : instead it invents a fresh type `X0' which is only equal to itself and about which nothing further is known, and sets `foo :: (X -> Bool) -> Foo X -> Option X'
08:03:26 <ski> (well s/X/X0/)
08:06:56 <haasn> about a quarter of my .hs files contain “import Control.Lens”
08:07:22 <haasn> what does this say about my personality?
08:08:01 <zomg> haasn: that it refracts light? ;>
08:10:26 <Eduard_Munteanu> Any suggestion for naming type variables containing numbers? Stuff like 'f1' looks ugly for some reason.
08:10:43 <haasn> f₁
08:11:11 <Eduard_Munteanu> Hm... actually I can afford unicode, thanks.
08:12:37 <donri> f, f', f'' ;)
08:12:44 * haasn did not expect that to get taken seriously
08:13:28 <Eduard_Munteanu> donri: that would require at least 7 ticks :)
08:13:44 <haasn> f₁₀ -- ugly though
08:14:14 <zomg> how do you even type subfix numbers? :P
08:14:15 <Eduard_Munteanu> Maybe I should give them names. They're type variables describing fields I'm to parse in a big record.
08:14:31 <haasn> zomg: AltGr + numrow for me
08:14:43 <haasn> AltGr + Shift + numrow, even; without shift is superfix
08:14:54 <zomg> What kind of weird layout are you using =)
08:14:57 <haasn> Eduard_Munteanu: _12 etc. hehe
08:15:16 <Eduard_Munteanu> haasn: oh, '_' is lowercase, hm
08:15:25 <zomg> alt+numrow just gets me special chars and stuff
08:15:34 <Eduard_Munteanu> I think I'll do that then.
08:15:36 <zomg> well not with the US layout
08:15:37 <Zenol> edwardk: Question : Qhen using makeClassy, I have to write myself the instances of HasSomething for each class that has a something field?
08:15:57 <Eduard_Munteanu> Zenol: no
08:16:15 <Eduard_Munteanu> At least for the original record.
08:17:18 <Zenol> Eduard_Munteanu: Because the only instance of HasType is instace HasType Type where type = id :/
08:18:03 <Zenol> Eduard_Munteanu: Here http://sprunge.us/ChDX?hs  :/
08:19:20 <Zenol> maybe there is some function to call to generate automatically those intances, or I'm using a version of lens to old?
08:19:22 <Eduard_Munteanu> Mind I'm a differed 'edward' though. :)
08:19:25 <Eduard_Munteanu> *different
08:19:43 <Zenol> Eduard_Munteanu: Yes, I know :)
08:21:20 <haasn> Eduard_Munteanu: you can't be edward, your name isn't green
08:22:02 <Makoryu> Ah crap
08:22:12 <Makoryu> Can't build diagrams-cairo without cairo-pdf
08:22:29 <haasn> Makoryu: you can use diagrams-svg as an alternative backend
08:22:54 * Zenol has it's whole shell green
08:24:08 <Makoryu> Guess I'll deal with it
08:34:17 <Makoryu> Aaaand the tutorial examples don't work
08:35:59 * hackagebot diagrams-pdf 0.3.1 - PDF backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-pdf-0.3.1 (alpheccar)
08:37:05 <applicat1ve> hah , you can build diagrams-pdf without cairo-pdf
08:38:50 <applicative> Makoryu: whats wrong with cairo-pdf?
08:39:08 <Makoryu> applicative: I'm not sure. OS X stuff, I think.
08:39:19 <pxqr> last time I tried to understand hspec and its use cases I end up thought "it's just HUnit done right". Is it true or I missing something?
08:39:51 <applicative> oh i think i have it on os x, but maybe it was a little complicated
08:40:15 <Makoryu> Specifically, I'm on a Lion box, and installed cairo via homebrew, but since there's already a (semi-hidden) version of cairo included with the system, it builds as keg-only (ie. also semi-hidden)
08:40:20 <applicative> no, indeed i *dont* have diagrams cairo
08:40:38 <Makoryu> So now pkg-config can't find cairo-pdf even though I'm pretty sure it's there
08:40:59 <Makoryu> And even if I went and figured out how to make it aware of where it would be
08:41:05 <Makoryu> I think doing that would break some stuff
08:41:08 <applicative> yes, when homebrew hides it, it becomes complicated
08:41:43 <applicative> i was hoping i would have wisdom since i've been having surprisingly good luck with homebrew+cabal the last year or so
08:41:53 <applicative> but no ;)
08:42:40 <Makoryu> If I upgraded to 10.8, in which cairo is no longer provided by the system, it wouldn't build as keg-only
08:42:42 * applicative tries cabal install diagrams-cairo
08:42:53 <Makoryu> Can't do that right now though
08:43:56 <user1783> if I have "data X a = X a", how can I force the evaluation of X a without forcing the evaluation of a?
08:43:58 <applicative> hm, it did install, with homebrew cairo -- i think -- and 10.8 maybe it doesnt work?
08:44:16 <applicative> by leaving it as it is user1783
08:44:18 <Makoryu> applicative: Huh? Are you on 10.8 now?
08:44:36 <applicative> newtype X a = X a will be different; as in another way is data X a = X !a
08:44:44 <user1783> applicative: it doesn't force the evaluation of X a; i.e. "data X a = X !a; X bot"
08:45:12 <Makoryu> user1783: Wherever you use "X a" (eg. in a function type signature) write "!X a" instead
08:45:19 <Makoryu> Or use seq
08:45:38 <Makoryu> But if you write "data X a = X !a" then it will always evaluate a
08:45:39 <applicative> or i see what you mean, I was too impressed by the particular type you named
08:46:00 * hackagebot diagrams-builder 0.4.0.2 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.4.0.2 (BrentYorgey)
08:46:36 <applicative> Makoryu: yes it is as you said, i have the same as you, but let me see if it works
08:47:46 <Makoryu> applicative: No, I'm saying I'm on 10.7, when I *should* be on 10.8
08:47:59 <Makoryu> If I was, that would (supposedly) solve my cairo problems
08:48:15 <Makoryu> But that's not my actual problem so this is yak shaving
08:48:32 <user1783> applicative: here is what I mean: https://gist.github.com/a3gis/6875606133e5793671da
08:48:56 <user1783> applicative: basically I would like to reproduce this behaviour with one argument ot the data constructors instead of two
08:50:06 <Makoryu> user1783: As far as I know you can't force a data type to always be strict at the "outermost" level (ie. a thunk that wraps around the entire value)
08:50:25 <Makoryu> user1783: But you can use it strictly in function arguments or function type signatures
08:50:56 <Makoryu> However
08:51:11 <Makoryu> That's not necessary if you're pattern matching on such a type anyway
08:51:18 <Makoryu> Because pattern matching forces it to evaluate
08:52:04 <Makoryu> user1783: Do you understand what I'm saying here
08:52:16 <Makoryu> And how it relates to your situation
08:52:21 <user1783> Makoryu: oh ok got it, thanks! so "data U a = U !a; g (U _) = 42; g (U bot)" won't terminate, whereas it would without the strictness declaration
08:52:35 <Makoryu> Yep
08:52:55 <user1783> thanks!
08:53:08 * Makoryu salutes
08:53:48 <user1783> is there another way to force a thunk to evaluate though? something like "(U bot)()" or so
08:54:04 <user1783> other than pattern-match on it
08:56:16 <user1783> nevermind, I think I can get that answer from the sources of Prelude.$!
08:56:58 <Makoryu> user1783: There's seq and deepSeq
08:57:42 <Makoryu> The former evaluates only the shallowest thunk
08:57:55 <Makoryu> The latter is for evaluating whole data structures
08:58:06 <Makoryu> I mention it in case you ever find yourself needing it
08:59:11 <applicative> Makoryu: diagrams-cairo is working; I see my snowflake.png
08:59:26 <applicative> God knows how I did it
09:00:28 <byorgey> applicative: =)
09:00:47 <user1783> Makoryu: ty
09:01:01 <Makoryu> user1783: Have you read Real World Haskell?
09:01:11 <zomg> So the other day I mentioned that SQL injection exists because of unsafe string concatenation based interfaces
09:01:13 <applicative> byorgey: there is an os x specific sublety out libcairo unsurprisingly
09:01:13 <user1783> Makoryu: nope, it's on my reading list
09:01:23 <applicative> about, not out
09:01:32 <zomg> so for fun I wrote a simple proof of concept for doing queries with a string concatenation like syntax but in a safe fashion =)
09:01:40 <zomg> You could run queries something like this, query $ "SELECT * FROM test WHERE name = " ?> y <? " AND x = " ?> (show x)
09:01:45 <zomg> and it would still escape the values automatically =)
09:01:57 <byorgey> applicative: indeed.  OSX + cairo = sadness
09:02:05 <zomg> could probably do it in a more clever way but I'm not intimate enough with all the typing craziness in haskell
09:02:13 <applicative> somehow its working, but i'm not sure what i did, unfortunately
09:02:18 <byorgey> applicative: that's been one of the primary motivators to develop other backends like diagrams-svg, diagrams-postscript and diagrams-pdf
09:02:44 <user1783> zomg: in scala you could even use implicit crazyness for that kind of stuffs ^^'
09:02:52 <zomg> hehe
09:03:19 <applicative> any mix of os x , cairo and haskell has been a bit of a horror since i started using this dubious os
09:03:47 <monochrom> consider using linux in a virtual machine :)
09:04:55 <Makoryu> I tried that for a while
09:04:55 <applicative> yes i should install one again. i had a nice stripped down debian thingy that was specially made for last years icfp contest
09:05:06 <Makoryu> Don't remember what was terrible about it
09:06:05 <applicative> but actually os x + haskell generally works pretty well these days, though some things people were saying suggest a new crisis coming
09:06:07 <Makoryu> At this point I'm not sure if it'd be a worse move to build/buy a second piece of hardware just for Haskell hacking, or to write a "just do what I mean" image display library that actually works on OS X and go around throwing it in people's faces until they cooperate
09:06:42 <Makoryu> applicative: "some things people were saying" ...Care to elaborate?
09:06:48 <Makoryu> Apple things, or GHC things?
09:07:49 <applicative> Makoryu: i would have but i didn't understand it all; the current phenomenon is that 'cpp' on certain arrangments are pointing to clang's cpp
09:08:10 <applicative> the 'real' gcc will be harder and harder to build -- something like that
09:08:28 <Makoryu> I can sort of see where this is going
09:08:46 <applicative> several people had knowledge, geekosaur among them
09:09:08 <Makoryu> So futureproofing GHC will require it to be portable across both pure GCC and pure LLVM stacks
09:09:30 <Makoryu> Some of that has been done with the LLVM backend, hasn't it?
09:09:45 <applicative> to that particular phenomenon the solution according to geekosaur is just for us all to start using the haskell cpp which is mostly ignored
09:10:02 <Makoryu> I had no idea it existed
09:10:13 <applicative> cpphs
09:10:40 <Makoryu> Aren't there still Perl scripts here and there in GHC's pipeline
09:10:42 <applicative> one thing is, it has a scary GPL or LGPL on it, though surely that's irrelevant to anything since its an independent program
09:10:58 <Makoryu> Ugggh
09:11:27 <applicative> the famous Perl chunk was for -f-viaC so it's not used, except I think for specialist purposes
09:11:54 <Makoryu> So if a GHC build links to it, then that build is (L)GPLed, and then if anything uses hs-plugins or something, ditto
09:12:02 <Makoryu> Gross
09:13:04 <applicative> the license might be changeable, but duncan c. though that given what it is, a comparatively simple independent binary, its all irrelevant really, but I dont understand this nonsense
09:13:07 <Makoryu> applicative: With the Perl question I was sort of implying GHC has a lot of parts that *could* be replaced if someone was around to do the legwork
09:13:10 <applicative> thought/not though
09:13:23 <applicative> well of course Makoryu
09:14:38 <applicative> but i think the perl business is pretty much irrelevant
09:14:46 <applicative> oh yes the Evil Mangler, it was called
09:15:11 <donri> cpphs is also a library, and cabal will link to it if you depend on it for the exe
09:15:19 <Makoryu> "Notice that we still need to use GCC as the preprocessor. Clang does not support the traditional mode of the GCC preprocessor used by GHC. This mode is needed by GHC because some of the Haskell syntax clashes with ansi standard c preprocessor syntax. The preprocessor usage inside GHC turned out to be a fairly big impediment to compiling with clang for a variety of reasons."
09:15:19 <applicative> donri: oh ick
09:15:20 <Makoryu> Hmm
09:15:35 <donri> but it's lgpl not gpl, so linking should be fine
09:16:06 <applicative> donri: duncan c seemed to think there wasnt a deep problem in any case just general fear
09:16:43 <applicative> Makoryu: is that from the trac ?
09:16:51 <Makoryu> It's from some guy's blog
09:16:55 <Makoryu> http://www.dmpots.com/2010/05/building-ghc-with-clang.html
09:17:23 <Makoryu> I was just googling junk
09:17:32 <Makoryu> http://gcc.gnu.org/onlinedocs/cpp/Traditional-Mode.html
09:17:45 <Makoryu> I bet someone could reimplement this if they were excruciatingly bored
09:17:57 <applicative> oh i see
09:19:07 <Makoryu> It seems there are other traditional mode preprocessors out there
09:19:18 <Makoryu> Dunno if it matters
09:19:32 <applicative> right '--traditional' was the crucial flag absurd as it seems
09:20:05 <applicative> we were trying to figure out what was going wrong in someone's particular case
09:22:37 <Makoryu> Say, how might you generate clang-style error message highlighting from Parsec error messages?
09:23:13 <applicative> by using Trifecta instead?
09:23:36 <Makoryu> Holy shit
09:23:42 <Makoryu> I'd never heard of this
09:23:43 <applicative> "A modern parser combinator library with slicing and Clang-style colored diagnostics
09:27:11 <Makoryu> How the heck do I use this
09:27:57 <FardadJalili> Is there a better way to implement the following function: f xs = map (*(last xs)) xs ?
09:28:13 <Saizan> Makoryu: look at "parsers" too, iy goes with that
09:29:05 <FardadJalili> @pl f xs = map (*(last xs)) xs
09:29:08 <lambdabot> f = id (fix (const (ap (map . flip (*) . last) id)))
09:29:08 <lambdabot> optimization suspended, use @pl-resume to continue.
09:29:11 <applicative> FardadJalili: it does look like you want to find out what 'last xs' is before you map it
09:29:36 <FardadJalili> applicative: I didn't get your point
09:29:37 <applicative> f xs = let y = last xs in map (*y) xs
09:29:50 <applicative> but maybe Im thinking of a different aspect of the definition
09:30:11 <FardadJalili> applicative: That's the same thing of course. I mean better semantically
09:30:35 <applicative> i guess that wont matter in this case; I take it back.
09:31:12 <applicative> i was worrying it might keep looking for last xs but it can see it's always the same
09:31:41 <applicative> yes, nonsense
09:31:57 <Makoryu> FardadJalili: Is this part of a fold by any chance
09:32:18 <applicative> but whats wrong with it as it is -- apart from egregious non-totality
09:32:40 <FardadJalili> Makoryu: No. I just want a function that multiplies each item in a list with the last element
09:32:45 <Makoryu> OK
09:33:10 <FardadJalili> applicative: There are a lot of ways to do things in haskell
09:33:18 <Saizan> FardadJalili: there's no improvement over that, i'd say
09:33:26 <FardadJalili> applicative: I get a feeling that this could be done better
09:33:30 <FardadJalili> So I just asked
09:33:39 <Saizan> but if you are working with the end of lists often you probably want some other data structure
09:33:41 <FardadJalili> but it seems there is no better way
09:33:44 <Saizan> like Seq maybe
09:34:09 <Makoryu> @unpl uncurry (*) $ last &&& id
09:34:10 <lambdabot> (uncurry (*) (last &&& \ a -> a))
09:34:25 <Makoryu> ¯\O_o/¯
09:34:32 <applicative> > (uncurry (*) (last &&& \ a -> a)) [1,2,3,4]
09:34:33 <lambdabot>   Couldn't match type `(c0, c'0)' with `[t2] -> t0'
09:34:33 <lambdabot>  Expected type: ([t2] -> ...
09:34:51 <nooodl> maybe you can use Vectors, FardadJalili?
09:34:54 <chrisdone> ahoy
09:34:54 <Makoryu> Oh wait
09:35:00 <Makoryu> @unpl uncurry (*) . last &&& id
09:35:00 <lambdabot> Plugin `pointful' failed with: Ambiguous infix expression
09:35:08 <Makoryu> @unpl uncurry (*) . (last &&& id)
09:35:08 <lambdabot> (\ d -> uncurry (*) ((last &&& \ a -> a) d))
09:35:11 <applicative> > ((last &&& id)) [1,2,3,4]
09:35:12 <lambdabot>   (4,[1,2,3,4])
09:35:15 <FardadJalili> nooodl: Oh I'm aware that using other DS is better
09:35:34 <Makoryu> I knew I was forgetting something
09:35:34 <nooodl> ah ok
09:35:45 <nooodl> yeah for regular lists what you have is as good as it gets, really
09:36:02 <Makoryu> @pl \a, b -> map (a *) b
09:36:02 <lambdabot> uncurry (map . (*))
09:36:15 <applicative> well nooodl and Saizan have spoken FardadJalili , I'm convinced
09:36:18 <Makoryu> @unpl uncurry (map . (*)) . (last &&& id)
09:36:18 <lambdabot> (\ d -> uncurry (\ g -> map ((*) g)) ((last &&& \ a -> a) d))
09:36:43 <Makoryu> > uncurry (map . (*)) . (last &&& id) $ [2, 3, 5, 7]
09:36:44 <lambdabot>   [14,21,35,49]
09:36:50 <applicative> there it is yes
09:37:00 <FardadJalili> Makoryu: haha, tnx for the effort
09:37:11 <mr-> very pretty :-
09:37:12 <mr-> P
09:37:15 <Eduard_Munteanu> What's an existential in terms of GADT notation? Variables which are universally quantified over the entire constructor type?
09:37:19 <nooodl> maybe you can somehow find a way to build your lists the other way around? if it were 'head xs' it'd be faster
09:37:33 <haasn> edwardk: we really really need some super elegant way to do zips :(
09:37:38 <shachaf> Eduard_Munteanu: Variables which aren't mentioned in the return type.
09:37:49 <Eduard_Munteanu> Erm, right.
09:37:53 <shachaf> (And universally quantified like you said, yes.)
09:37:57 <Makoryu> FardadJalili: You could also write (map . (*)) as ((*) <$>) I think
09:38:00 <applicative> yes, they dont occur in -> -> Foo
09:38:01 <Makoryu> No wait
09:38:03 <FardadJalili> nooodl: Yes, I know. This was more of asking about elegant ways to do things question, rather than how to solve this problem most efficiently
09:38:29 <shachaf> Sometimes the most efficient way to solve your problem is to solve a different problem instead.
09:38:35 <applicative> Nu :: forall s f . s -> (s -> f s) -> Nu f
09:38:36 <Makoryu> @unpl ((<$>) . (*.))
09:38:36 <lambdabot> (\ c -> (<$>) ((*.) c))
09:38:37 <haasn> > let (x,y) = (0xF3, 0xF8) :: (Int, Int) in lengthOf (folded.filtered id) $ zipWith (==) (x^..bits) (y^..bits)
09:38:38 <Makoryu> D'OH
09:38:38 <lambdabot>   29
09:38:40 <Makoryu> @unpl ((<$>) . (*))
09:38:40 <lambdabot> (\ c -> (<$>) ((*) c))
09:38:53 <shachaf> For example, maybe you can keep the list backwards, so you can get the first element instead of the last one.
09:38:55 <Eduard_Munteanu> shachaf: actually, can I phrase the requirement as being universally quantified over the result type of the constructor?
09:39:12 <FardadJalili> shachaf: Yep.
09:39:15 <shachaf> Eduard_Munteanu: I don't understand what you mean, so I don't know.
09:39:42 <Makoryu> > reverse . (\(x:xs) -> map (x *) xs) . reverse $ [2, 3, 5, 7]
09:39:44 <lambdabot>   can't find file: L.hs
09:40:05 <Eduard_Munteanu> shachaf: data Foo a where Foo :: ... -> (forall x. Foo a)  -- x is trivially existential here
09:40:45 <nooodl> FardadJalili: oh, if it's purely a matter of elegance, what you already had is perfectly fine! (you can write (* last xs) instead of (*(last xs)) though)
09:40:57 <Eduard_Munteanu> Now sure, you can move that to the left as long as there are no occurences of x.
09:41:13 <shachaf> If it's a matter of elegance, don't use last. :-)
09:41:35 <FardadJalili> shachaf: Totality matters
09:41:40 <shachaf> Eduard_Munteanu: x isn't even used there.
09:41:52 <applicative> FardadJalili: but you're the one using last!
09:42:10 <Eduard_Munteanu> shachaf: I know, I was trying to establish the minimal criteria for 'x' to be called existential
09:42:19 <FardadJalili> shachaf: but I believe it is not a problem if your function is used inside another function and you are sure about the input
09:42:44 <applicative> FardadJalili: that's what they always say; same about head and !! 17
09:42:51 <nooodl> wait does it even matter at all here
09:42:57 <nooodl> > map (* last []) []
09:42:58 <lambdabot>   []
09:43:01 <nooodl> it does not.
09:43:09 <applicative> my construction precludes a 16 member list!
09:43:09 <Makoryu> FardadJalili: How do you generate that list anyway
09:43:10 <FardadJalili> nooodl: huh, tnx
09:43:22 <shachaf> Someone mentioned "elegance", though.
09:43:23 <shachaf> Whatever.
09:43:25 <nooodl> (because map _ [] = [])
09:43:40 <applicative> okay, nooodl wins
09:43:51 * haasn uses _last instead of last, for elegance
09:44:05 <mr-> nooodl: (and laziness?)
09:44:05 <applicative> but with the same definition?
09:44:15 <shachaf> It's like zip xs (tail xs). It works, but almost by accident.
09:44:19 <FardadJalili> Makoryu: I said, it is a matter of elegance. It's not like I'm using this code anywhere
09:44:31 <Makoryu> FardadJalili: And I'm mostly just curious :p
09:44:57 <joelteon> > map (* undefined) []
09:44:58 <lambdabot>   []
09:45:03 <applicative> it is best to avoid an accumulation of elegant accidents
09:45:26 <FardadJalili> Makoryu: The thing I said about being inside another function, what my thoughts about the definition of elegance. I can't really guess where such function could be used really, haha :D
09:46:05 <shachaf> Anyway, coming into #haskell and saying things like "here's some code, make it elegant" with sufficient vagueness is a great way to stir people up.
09:46:21 <FardadJalili> applicative: well it's just fixed by adding f [] = [], right?
09:46:59 <FardadJalili> shachaf: I ask when I'm not sure is there a better way to do things, even when they're of any use. Is it against the philosophy of this channel?
09:47:12 <FardadJalili> shachaf: of no use*
09:47:20 <applicative> FardadJalili: right, that's how we avoid last and head in general
09:47:24 <applicative> well, not last
09:47:26 <applicative> ok
09:47:39 <shachaf> No.
09:48:03 <FardadJalili> applicative: to be exact the reason I was wondering if there would a better way was because of that shiny last in middle of the function :)
09:48:30 <applicative> things frequently emerge from such questions; and frequently there is just a tide of de-pointillisme
09:48:58 <Makoryu> FardadJalili: Mainly, the way to avoid using "last" is to avoid having that value be at the end of the list to begin with
09:49:17 <Makoryu> Which is why people were asking about that
09:49:29 <applicative> it's what is called a 'list smell', though not by anyone actual
09:49:31 <FardadJalili> Makoryu: Didn't think about it that way. Thanks
09:49:52 <FardadJalili> Makoryu: so in the end, you wouldn't be using last
09:50:00 <Makoryu> Yep
09:50:10 <FardadJalili> Makoryu: even if for this particular task there seems to be no other ways
09:50:20 <FardadJalili> I think I learned something
09:50:21 <Makoryu> FardadJalili: Well it depends how that value got into the list
09:50:22 <FardadJalili> haha
09:50:58 <Makoryu> If it was put there by another function, you could rewrite that function so it passes it on as a separate parameter instead of just including it in the list
09:52:29 <Makoryu> I would prefer to do it this way even if the list includes the separate value anyway
09:59:18 <applicative> > (map . flip map) <*> (map (*)) [1,2,3]
09:59:19 <lambdabot>   Couldn't match expected type `[(a1 -> a1) -> b0]'
09:59:19 <lambdabot>              with actual ...
09:59:30 <applicative> > (map . flip map) <*> (map (*)) $ [1,2,3]
09:59:31 <lambdabot>   [[1,2,3],[2,4,6],[3,6,9]]
09:59:35 <chrisdone> applicative fail
09:59:38 <chrisdone> geddit?
09:59:43 <applicative> geddit
09:59:46 <chrisdone> :)
10:00:24 <applicative> my horror of the almight $ got in the my usually razor sharp golfing
10:00:29 <applicative> got in the way
10:00:39 <chrisdone> sure it did
10:00:49 * chrisdone motions a beer glass at the others and winks
10:00:51 <applicative> ha
10:00:55 <cdk> are there typeclass laws for Foldable that guarantee a fold over any Foldable f behaves like a fold over (toList f)? or is that not true?
10:01:20 <chrisdone> good question
10:02:02 <chrisdone> i see that in the docs there is this (and i've made it explicit because Haddock sucks):
10:02:11 <chrisdone> Data.Foldable.foldr f z = Data.List.foldr f z . Data.Foldable.toList
10:02:37 <opqdonut> yeah, the default implementation for foldr uses toList
10:02:43 <chrisdone> it's not stated as a law, but the claim is there
10:02:44 <opqdonut> even the docs tell that nowadays: http://www.haskell.org/ghc/docs/7.6.2/html/libraries/base/Data-Foldable.html
10:03:06 <chrisdone> yeah, that's what i was copying from
10:03:37 <opqdonut> oh, but toList is not a method in the Foldable class, but implemented using foldr...
10:03:45 <opqdonut> @src Data.Foldable.toList
10:03:45 <lambdabot> Source not found. Sorry.
10:03:51 <opqdonut> @src toList
10:03:51 <lambdabot> Source not found. stty: unknown mode: doofus
10:03:59 <opqdonut> http://www.haskell.org/ghc/docs/7.6.2/html/libraries/base/src/Data-Foldable.html#toList
10:04:02 <opqdonut> anyway
10:05:19 <cdk> guess i didnt look hard enough at the docs, thats what I was looking for. Thanks opqdonut, chrisdone
10:10:46 <ReinH> edwardk: So documentation formats...
10:10:53 <ReinH> edwardk: have you ever used asciidoc?
10:12:25 <edwardk> oh that thing
10:12:38 <edwardk> its not that i want another documentation format
10:12:44 <edwardk> i just want _some_ way to get the functionality in haddock
10:12:59 <ReinH> edwardk: well, I'm thinking of doc formats that support haddock's use cases
10:13:01 <edwardk> i don't really give a flying leap if its done via markdown or whatever
10:13:02 <ReinH> and asciidoc comes close
10:13:07 <ReinH> and is a relatively easy format to write
10:13:43 <edwardk> well, i think the issue comes down to the fact that the resulting format needs to b relatively close to haddock as it exists. you can probably extend the haddock syntax, make a few breaking changes, but switching to a new markup is nontrivial as it interacts all the way into GHC
10:13:53 <edwardk> so it just strikes me as something that isn't going to happen in this life
10:13:56 <ReinH> hell, you can even write manpages in asciidoc ;)
10:14:10 <ReinH> right
10:14:17 <edwardk> so yes, there are better documentation formats, but if you want to talk about something that can _happen_, it is going to look a lot like haddock
10:14:24 <ReinH> maybe we should be talking about haddock 2.0 instead
10:14:41 <edwardk> that was nominally what this gsoc proposal was converted to being
10:14:46 <ReinH> we should call it pollock.
10:15:11 <edwardk> which is 'improve haddock to do the stuff it should be able to do'
10:15:15 <ReinH> right
10:15:29 <ReinH> I wouldn't object to using markdown as a template for those extensions though
10:15:32 <fryguybob> edwardk, ReinH: What's the desired feature?
10:15:32 <ReinH> it's been quite successful
10:15:58 <tikhon> the thing that annoys me most about Haddock is how it uses `, and that would still be annoying with Markdown.
10:16:06 <edwardk> fryguybob: there are just a ton of things you can't say in haddock right now. can't make a hyperlink with text other than the link, can't format images, ec.
10:16:12 <ReinH> Maybe we can't do haddock flavored markdown but we might be able to markdown flavored haddock
10:16:13 <edwardk> tikhon: heh
10:16:15 <tikhon> Haskell code uses backticks fairly liberally
10:16:20 <ReinH> tikhon: why does that annoy you? It's better than @
10:16:25 <fryguybob> edwardk: Ah, so just, sanity.
10:16:36 <ReinH> It has a reasonable mnemonic in `` from shell
10:16:37 <edwardk> ReinH: that was the plan as i understood it going into the summer of code
10:16:49 <ReinH> edwardk: cool, can I help?
10:16:52 <tikhon> ReinH: because I use backticks in my Haskell code quite a bit
10:17:05 <tikhon> and foo `mod` bar gets rendered incorrectly
10:17:07 <edwardk> ReinH: sure, join #haskell-gsoc and talk to Fuuzetsu i guess
10:17:13 <fryguybob> I'm happy that diagrams-haddock is working well enough for us to use.
10:17:17 <ReinH> tikhon: Ah, do you have to \`?
10:17:25 <tikhon> yes
10:17:28 <edwardk> he's the man behind the 8-ball
10:17:32 <ReinH> that's somewhat annoying
10:17:41 <ReinH> edwardk: trying to please everyone, yeah
10:17:42 <ReinH> good times
10:17:43 <tikhon> also, witness how many people have trouble with backticks on StackOverflow (which uses Markdown)
10:17:53 <newbie2> can you advise some data structure that says is element inside or not with minimal O?
10:18:03 <edwardk> i'm going to think about other things now =)
10:18:08 <ReinH> edwardk: I realize it's a little late but I'd love to help with hsakell gsoc in any way I can, this year or upcoming years
10:18:20 <edwardk> newbie2: what is the domain?
10:18:26 <ReinH> tikhon: I get it :)
10:18:51 <edwardk> newbie2: e.g. are you requiring fast updates? as the 'element' type finite? countably infinite? only able to be compared with others of its ilk?
10:19:25 <newbie2> edwardk: thousands of points (Double, Double). I dont insert into them
10:19:29 <tikhon> newbie2: does it have to be correct, or can you live with a probabilistic data type?
10:19:39 <ReinH> edwardk: I never thought I'd be saying this, but cofree comonads are really simple and useful!
10:19:49 <edwardk> newbie2: e.g. if the element type has a small range, an array of bits one per element is O(1) which meets your minimal O, if its bigger and finite, then fusion trees beat naive comparisons, if its bigger than that then you need some kind of search
10:20:04 <edwardk> newbie2: just store them as an array of double/double pairs, then binary search
10:20:14 <edwardk> newbie2: binary search gives you log n time
10:20:21 <newbie2> tikhon: didnt thought about that. May by, with good probability...
10:20:32 <edwardk> ReinH: hah. glad they won you over =)
10:20:32 <ReinH> You're only going to do better than log n in some special cases anyway
10:20:42 <iene> hi, can you suggest Faker-like library for haskell? For those who mught not know what Faker is, it's a library for generating random fake data like names of addreses and stuff like that.
10:20:44 <ReinH> like if you can use a bit for every member of the domain
10:20:45 <edwardk> ReinH: i remember your 'oh my god'  reaction when i suggested them
10:20:56 <edwardk> iene: we often just use quickcheck
10:20:57 <ReinH> edwardk: :)
10:21:09 <ReinH> iene: do you want them for testing or?
10:21:26 <ReinH> quickcheck is great for generating arbitrary data of a given type
10:21:28 <newbie2> edwardk: it was the first i thought about. But i dont want to insert into, that may give some speed
10:21:33 <ReinH> but makes no attempt to generate interesting or human readable data
10:21:49 <edwardk> newbie2: yeah if you don't need insert then the array will be the best asymptotics you can get sanely
10:22:00 <ReinH> newbie2: pretty good chance that some for of Map will be sufficient
10:22:11 <ReinH> optimizing beyond that is probably premature
10:22:13 <tikhon> generating plausible addresses/names has some specific concerns that QuickCheck does not really address
10:22:22 <iene> ReinH: i want it for game, so i need to generate human readable data and real names.
10:22:24 <edwardk> newbie2: but as rein noted just throwing them in a Data.Set would also work, and givs you the same asymptotics
10:22:26 <ReinH> tikhon: it does if you can get the types right :p
10:22:29 <edwardk> but supports more features
10:22:37 <Fuuzetsu> <ReinH> I wouldn't object to using markdown as a template for those extensions though
10:22:38 <edwardk> the constants may be worse though
10:22:43 <ReinH> Fuuzetsu: hi :)
10:22:47 <iene> edwardk: not exactly, just need some random names and stuff looking like real.
10:22:47 <Fuuzetsu> I think you'll find that a lot of the stuff we have looks like Markdown already.
10:22:55 <ReinH> Fuuzetsu: seems good
10:23:09 <edwardk> iene: sounds like an opportunity to write a library. i nominate you =)
10:23:14 <ReinH> edwardk: ++
10:23:24 <iene> edwardk: ha-ha
10:23:36 <Fuuzetsu> It's hard not to look like Markdown to be fair. In any case, there isn't much we can borrow from it. We're covering pretty much everything that Markdown is, that isn't HTML-specific (like inline HTML tags)
10:23:46 <enthropy> iene: it might also be sensible to call the original library from haskell
10:23:49 <newbie2> edwarkd: well, thanks
10:23:52 <ReinH> Fuuzetsu: cool :)
10:24:09 <ReinH> Fuuzetsu: where is your project located so I can follow along?
10:24:09 <iene> enthropy: it'll be hard since original one is in perl i think.
10:24:13 <Fuuzetsu> I'll be back in a second if you want to chat. Might want to ping me in haskell-gsoc as there's less traffic there
10:24:19 <edwardk> Fuuzetsu: the things i want are links that don't suck and some way to do a little bit better with images. i just need some way to express these things.
10:24:20 <ReinH> iene: there's a decent Ruby version that isn't too hard to read
10:24:47 <edwardk> Fuuzetsu: so i strongly challenge that 'haddock has these things already' as their lack was the very reason we did the gsoc project in the first place =
10:24:49 <edwardk> =P
10:24:56 <iene> ReinH: ah, okay, i'll take a look, thank you.
10:25:07 <ReinH> iene: it's called faker as well iirc
10:25:07 <Fuuzetsu> edwardk: Well, it has those things in relation to Markdown
10:25:25 <Fuuzetsu> if you could be more specific than ‘not suck’ then I might be able to work on it better
10:25:29 <Fuuzetsu> AFK few minutes.
10:25:38 <edwardk> by not sucking i mean, i can put text on the hyperlin
10:26:03 <edwardk> [This](http://foo) is something i can't say in haddock right now
10:26:03 <Fuuzetsu> oh, ReinH, here's where I push stuff: https://github.com/Fuuzetsu/haddock the ‘pullbase’ branch is the branch that will be merged in the end. Note that a lot of rebasing and squashing is going on.
10:26:24 <ReinH> Fuuzetsu: cool :)
10:27:07 <Fuuzetsu> edwardk: <http://foo This>
10:27:16 <Fuuzetsu> Really now, back in a few.
10:27:18 <edwardk> that works?
10:28:22 <edwardk> hrmm
10:28:34 * edwardk comes down off his high horse and goes and fixes a bunch of haddocks
10:28:52 <ReinH> haha
10:28:59 * edwardk grumbles about the <http://www.haskell.org/haddock/doc/html/ch03s08.html docs> not including that little tidbit
10:32:14 <newbie2> and what about heaps?
10:32:41 <newbie2> smth like Fibonacci heap; is it already implemented in Haskell?
10:33:39 <int-e> we've seen binomial heaps.
10:33:50 <tikhon> I've used the heaps package, which seems good
10:33:59 <tikhon> http://hackage.haskell.org/package/heaps
10:34:05 <int-e> As far as I recall, fibonacci heaps are not persistent, so a bad match for haskell.
10:34:15 <Rarrikin1> http://new-hackage.haskell.org/package/pqueue-mtl-1.0.7/docs/Data-Queue-FibQueue.html
10:35:53 <ReinH> Is there a library for Brodal Queues? (https://karczmarczuk.users.greyc.fr/TEACH/Doc/brodal_okasaki.pdf)
10:36:32 <newbie2> hmm, thanks, need to investigate that
10:36:42 <chrisdone> ReinH: what's my haskell podcast this week? ლ(ಠ益ಠლ)
10:36:48 <ReinH> chrisdone: :p
10:36:49 * chrisdone screams MOARR in a zoidbergian way
10:36:54 <ReinH> did we say it would be weekly? :p
10:37:21 <chrisdone> definitely. he definitely said that, right, guys? you heard him
10:37:32 <tikhon> oh, is there a Haskell podcast around?
10:37:34 <fryguybob> chrisdone: I heard daily, he is so behind.
10:37:38 <chrisdone> haha
10:37:42 <chrisdone> tikhon: http://www.haskellcast.com/
10:37:59 <ReinH> interesting https://code.google.com/p/priority-queues/
10:38:13 <int-e> Rarrikin1: Oh, right. We just don't support decreasing keys (which fibonacci heaps support in constant time) :)
10:38:28 <ReinH> a Coq-verified impl of Brodal-Oskasaki heaps. Nice.
10:39:08 <ReinH> newbie2: not sure you want a hash though, they are not designed for optimized elem checks
10:39:35 <ReinH> *heap
10:40:04 <edwardk> ReinH: i have brodal/oksaki heaps
10:40:09 <edwardk> @hackage heaps
10:40:09 <lambdabot> http://hackage.haskell.org/package/heaps
10:40:31 <edwardk> ReinH: mine aren't coq verified but they also implement the full paper
10:40:40 <edwardk> ReinH: and go further to provide a haskelly API
10:41:18 <eevar> doing FFI, is it possible to declare a function argument as Ptr /something/ and stuff pointers to chars, ints and whatnot in there? -- or should I declare the function once for every data type that I'm supposed to use for the void* argument?
10:41:39 <edwardk> newbie2: i tend to use the heaps package or turn to a handrolled 10 line 'pairing heap' whenever i need a heap
10:41:47 <Jeanne-Kamikaze> Ptr a ?
10:42:01 <ReinH> edwardk: nice
10:42:02 <edwardk> newbie2: it depends on my usage if its persistent vs. ephemeral
10:42:36 <edwardk> and the brodal/okasaki heap is rarely a win in practice over the simpler 'fewer moving parts' pairing heap
10:42:51 <ReinH> edwardk: well, first he wanted a data structure with optimized elem checks, now he wants a heap...
10:42:52 <edwardk> (which is just a cofree comonad!) to poke fun at ReinH
10:42:59 <ReinH> edwardk: indeed it is :D
10:43:02 <eevar> Jeanne-Kamikaze: great. thanks
10:43:10 <ReinH> edwardk: it's cofree what, Pair a a?
10:43:20 <edwardk> Cofree []
10:43:22 <edwardk> its Tree
10:43:29 <edwardk> a pairing heap is based on a rose tree
10:43:32 <ReinH> oh so a Tree
10:43:33 <ReinH> ah
10:43:35 <edwardk> not a binary tree
10:43:38 <ReinH> kk
10:43:49 <apfelbox> I have a list and want to build a tree structure out of it. But I need to traverse the last from back to front (just reversing the whole list does not work, since the content of the nodes should keep the initial order).
10:44:00 <epta> ReinH: you are one of that guys from haskell podacst?
10:44:03 <ReinH> epta: yes
10:44:04 <apfelbox> How do I traverse a list from back to front?
10:44:18 <ski> eevar : is there a finite number of types you could have there ?
10:44:27 <edwardk> reinh: merge (Heap a as) (Heap b bs) | a < b = Heap a (b:as) | otherwise = Heap b (a:bs)  -- singleton a = Heap a []
10:44:37 <edwardk> ReinH: that is for a non-empty version
10:44:44 <edwardk> to add empty you add a wrapper at the top and make it ugly
10:44:49 <ReinH> edwardk: yeah, so you get your heap properties pretty cheaply
10:45:10 <ReinH> edwardk: didn't you do that in your SoH series?
10:45:14 <ReinH> I seem to remember something similar
10:45:35 <ReinH> apfelbox: if you're traversing from back to front, how is that different from reversing and traversing normally?
10:45:43 <eevar> ski: yep. just int and string that I can think of right now
10:45:44 <edwardk> popping involves just merging down the list. pop (Heap _ []) = Nothing; pop (Heap _ (x:xs)) = Just (foldl' merge x xs)
10:45:55 <ReinH> you said "contents of the nodes should keep the initial order" but I'm not sure how traversing from back to front would maintain that order
10:45:57 <edwardk> ReinH: yeah i do. i use the pairing heap as an example of a simple boostrappable structure
10:46:00 <apfelbox> If I build a tree structure out of the reversed list, the order in the nodes is reversed too. I want to keep the order
10:46:03 <ReinH> edwardk: cool
10:46:09 <ski> eevar : what does the function do ?
10:47:41 <eevar> ski: it updates settings for a message queue connection
10:47:57 <ReinH> apfelbox: so you want the order of the tree toList to be the same as the original tree?
10:48:10 <apfelbox> Exactly.
10:48:18 <Fuuzetsu> edwardk: Those docs are really old, hopefully we can replace them with the new release… A slightly less outdated version comes with Haddock sources, under ‘doc’.
10:48:18 <eevar> there's a void*, and some other arguments tell you what it shold point to
10:48:46 <ReinH> apfelbox: seems like you could traverse from the end and also build the tree backwards
10:49:22 <apfelbox> how do I traverse from the end? Is there syntactic sugar / functions / etc.. or do I need to use the index?
10:49:40 <ReinH> apfelbox: traverse.reverse
10:49:48 <ReinH> There's no simple way because reversing a list is expensive
10:49:58 <ReinH> apfelbox: is there a way to build your list in the correct order to begin with?
10:50:55 <monochrom> or, if you will be walking the "list" in many different orders, use a more suitable data structure than list
10:50:56 <apfelbox> I get the list from an API, so probably not :(
10:51:22 <ReinH> apfelbox: well, reversing is O(n) and unfold is O(n) so you're just changing the constant, not the complexity
10:51:47 <enthropy> apfelbox: if you have something like    foldr (\value tree -> insert value tree) emptyTree, that "starts" at the end of the list
10:51:52 <ReinH> er folding
10:52:04 <monochrom> you can always marshal that list to a form suitable for your use as the first thing
10:52:11 <ReinH> enthropy: good point, for some reason I was thinking unfold
10:53:10 <apfelbox> ok
10:53:12 <enthropy> apfelbox: or if that's the wrong order / what you're already doing, you can use foldl (which is going to be the same idea as having a reverse in there)
10:53:45 <ski> eevar : so it's effectively a variant/sum type value being passed ?
10:54:15 <Fuuzetsu> edwardk: by the way, if you have libraries that you know build with GHC HEAD (including all their dependencies), I'd love to hear it. AFAIK you document quite heavily and I'd love to see how any changes made in Haddock affect your documentation. I've been mostly using HXT for this so far.
10:55:09 <eevar> ski: yea
10:57:13 <ski> eevar : i suppose you could make a wrapper function which gets passed an `Either', or possibly a custom type with two alternatives, if you think it's plausible for the (number ior type of) alternatives change in the future ..
10:58:46 <eevar> ski: I'll try that, thanks
10:59:25 <ski> eevar : .. and of course only export the wrapper :)
11:00:02 <ski> that way, you'd guard against accidentally passing the wrong `Ptr Blah' to it
11:00:16 <ski> (i.e. for the wrong type `Blah', i mean)
11:00:54 <edwardk> Fuuzetsu: lots of stuff down near the bottom of my foodchain is HEAD compatible. lens currently isn't but will be soon
11:01:08 * haasn wants to be compatible with edwardk's HEAD
11:01:23 <edwardk> i document somewhat.. bimodally. the new stuff i write is documented to death
11:01:39 <edwardk> haasn: my wife may object
11:02:51 * ski . o O ( "fixed in teh HEAD" <http://spl.smugmug.com/Humor/Lambdacats/i-6djpLdS/0/S/simon-S.jpg> )
11:03:13 <edwardk> heh
11:04:19 <haasn> I meant like, to be able to understand your lines of thought :P
11:05:17 <edwardk> what you should do then is get in on the ground floor of new projects.. like help me figure out how to make this COLA implementation fast. ;)
11:05:25 <edwardk> it is currenty small enough to fit entirely inside your head
11:05:33 <haasn> module Cola where
11:05:57 <edwardk> https://github.com/ekmett/structures
11:06:27 <edwardk> its currently about 3x slower than map on inserts, and its dropping some entries on lookup
11:06:35 <edwardk> so i've got corner cases wrong there
11:06:42 <haasn> oh, so that's the meaning of cola you were referencing
11:06:45 <haasn> I was looking at https://en.wikipedia.org/wiki/COLA_(software_architecture)
11:07:05 <edwardk> http://supertech.csail.mit.edu/papers/sbtree.pdf gives the academic reference
11:08:33 <edwardk> haasn: heh the thing you found sounds like almost a marketing fluff piece
11:08:51 <edwardk> "A COLA is designed to be the simplest possible language which can be described in itself, so that the implementation exactly describes itself." *cough*bullshit*cough*
11:09:02 <haasn> that's trivial
11:09:34 <edwardk> basically the stuff i have is simple. its a linked list of arrays of ever increasing size, where the arrays are stored in sorted order
11:10:01 <edwardk> you can search it by searching each of the arrays naively, but that leads to searching log n files each in log n time, giving a log n blowup
11:10:23 <edwardk> so what we do is modify this format using "fractional cascading"
11:10:27 <edwardk> @google fractional cascading
11:10:28 <lambdabot> http://en.wikipedia.org/wiki/Fractional_cascading
11:10:28 <lambdabot> Title: Fractional cascading - Wikipedia, the free encyclopedia
11:10:47 <edwardk> which is to say i copy every kth entry out of the next larger file down into the smaller ones
11:10:56 <LazinCajun> Beginner question: I'm sure there's a godo reason for this, but why are the parameters reversed in this?  newtype Writer w a = Writer { runWriter :: (a, w) }
11:11:03 * hackagebot heaps 0.3.0.1 - Asymptotically optimal Brodal/Okasaki heaps.  http://hackage.haskell.org/package/heaps-0.3.0.1 (EdwardKmett)
11:11:17 <edwardk> so if i have a file with 8000 entries, the next smaller file will have, say, an extra 1000 entries of "forwarding pointers".
11:11:40 <edwardk> so that when i fail to find it in my small update, i can fast forward directly to the right 8 element window in the next file
11:11:54 <edwardk> he only tricky part is i store the forwarding pointers implicitly
11:12:02 <mkramer> newb Q. I am trying to process commandline args. I am using System.Console.GetOpt to handle —parameters, but I want to allow positional parameters too
11:12:21 <ski> LazinCajun : another question might be, why isn't it `(w,a)' instead of `(a,w)' ?
11:12:30 <edwardk> to insert we just make a new file, and merge it with other files until we restore the size invariants
11:12:48 <mkramer> so, after calling getOpt, I have a [String] that might contain 0, 1, or 2 file paths, and an [OptFlag] that might contain and Input String, an OutputString, both, or neither
11:12:49 <geekosaur> LazinCajun, because fmap on a tuple applies to the first thing in the tuple. which makes it more convenient to put the result in the first thing
11:12:58 <mkramer> http://lpaste.net/92371
11:13:00 <ski> LazinCajun : as for your question, we want `Writer w a' to be a "monad in `a'" (as well as a functor, e.g.)
11:13:01 <edwardk> i may switch to redundant binary counters and restore invariants in parallel and stuff later, but the idea itself is very simple
11:13:07 <geekosaur> whereas, for the type, it's most useful to have the resutl type last
11:13:19 <ski> LazinCajun : so we need `a' to be the last argument of `Writer'
11:13:25 <LazinCajun> geekosaur: ski Ok, I see.  Thanks :)
11:13:34 <mkramer> I need a function of type ([OptFlag], [String]) -> (OptFlag, OptFlag) that pulls those strings out
11:13:37 <edwardk> haasn: and its currently broken, so i'm seeking to recruit your brain =)
11:13:44 <mkramer> it's so…hard…to..do…anything
11:14:22 <edwardk> haasn: no pressure ;)
11:14:47 <ski> LazinCajun : of course, in this case it doesn't really matter, since `a' and `w' are used symmtrically in the body of the definition (so you could swap the `w' and `a' parameters, and then rename `w' to `a' and vice versa, and it'd express basically the same thing)
11:15:04 <mcstar> i lost my chromium session, and there was a tab open, with an interactive haskell class(online education), do you know the address? i remember the page had a turquois menubar, and a gold-yellow background
11:15:35 <haasn> edwardk: my brain is only good at taking working code and finding ways to compress it into a one-liner using lens. Why isn't it working? ;)
11:15:40 <ski> LazinCajun : however, if you consider `newtype Reader r a = MkReader {runReader :: r -> a}', then we really want `a' to be the last argument, so that we can say that `Reader r' is a monad (and a functor)
11:16:10 <mkramer> How can I search an [OptFlag] to see if any of them pattern match one of my constructors?
11:16:21 <edwardk> haasn: well, inserts are slower than i think they should be on one front, and on the other the search is choosing the wrong window
11:16:28 <edwardk> so my logic about the thinning is likely flawed
11:16:55 <edwardk> i'd live with 3x slower inserts than map in exchange for scalability and other things speeding up
11:19:43 <haasn> edwardk: I'll download it and have a look the next time my internet dies
11:19:59 <edwardk>  k
11:20:11 <edwardk> figured it seemed like the kind of puzzle you seem to like
11:20:50 <haasn> (is this how edwardk lures so many people into writing his projects for him?)
11:20:57 <edwardk> yes
11:21:28 <edwardk> by pushing this hard i've gotten to where about 1/5th to 1/4th of the code comes from other people =)
11:21:43 <edwardk> that is a bigger help than it sounds, because those lines are often the biggest bugfixes
11:21:48 <mcstar> in the meantime i just found this http://shuklan.com/haskell/
11:22:00 * haasn reminds edwardk that he has contributed more removals than additions to lens
11:22:12 <edwardk> which is very much appreciated
11:22:35 <edwardk> arguably it comprises the better contribution =P
11:22:38 <ReinH> edwardk: hey can we talk cellular automata again for a sec
11:22:43 <edwardk> sure
11:22:51 <haasn> I could just make sure to always delete your lines, that improves the ratio too
11:23:34 <edwardk> true
11:23:39 <edwardk> and likely improves correctness
11:24:14 <ReinH> edwardk: My friend wrote her thesis on small-world properties of cellular automata in Z modulo n (cyclical) universes
11:24:26 <edwardk> *nods*
11:24:30 <ReinH> edwardk: Where the small world properties were encoded into the universe topology as invariants
11:24:39 <ReinH> so they don't change from generation to generation
11:24:50 <ReinH> There should be a way to build an s -> a that encodes this, right?
11:24:54 <ReinH> for your Store s a
11:24:57 <haasn> oh, re: cellular automata does the comonad algebra interpretation of it them give you any laws/theorems for free that can be used to optimize their speed?
11:25:06 <haasn> or it just effectively a more elegant formulation of a trivial algorithm
11:25:07 <edwardk> well, z mod n forces you into cycles pretty early
11:25:36 <ReinH> edwardk: right, basically she builds small cyclical universes with a few local connections replaced with non-local jumps
11:25:43 <ReinH> and then runs experiments in them
11:25:48 <edwardk> in essence z mod n you can just tabulate all automata as a bigger store
11:26:02 <edwardk> or rather all world states
11:26:22 <ReinH> as a bigger store?
11:26:25 <edwardk> so then the rule + world state is enough to figure out te new world state, and since your world states are enumerable you can abuse that
11:26:38 <ReinH> ah right
11:26:52 <ReinH> there are a finite number of possible world states
11:26:58 <ReinH> I'm more interested in generating the small world properties
11:27:14 <edwardk> define "small world property" here
11:27:52 <ReinH> edwardk: I'm not sure exactly how she defined it, but consider a double linked cyclical list. Replacing the links between any two nodes creates a small world.
11:28:08 <ReinH> So z mod 20, replace 5 and 13
11:28:21 <ReinH> so 4 now has neighbors 3 and 13
11:28:41 <ReinH> and 14 now has neighbors 5 and 15
11:28:44 <enthropy> is there a general way to get a data out of a type that's been promoted (with -XDataKinds)?
11:28:53 <edwardk> sure but from that implicit rep you can't see the fact that you can fast forward the world through the cycle
11:29:54 <ReinH> edwardk: right, I was just using a model to make sure I communicated the property
11:29:58 <ReinH> since I don't know a formal way to exress it
11:30:05 <edwardk> once you bound the world you bound the information it contains, and we can exploit that to run it faster ;)
11:30:12 <ReinH> right
11:30:18 <ReinH> that's the idea
11:30:25 <edwardk> well, you can talk about a set of directions for a point
11:31:15 <edwardk> basically you need the normalizing function point + vector -> point      that describes the space of moves available to you, a local map for your space the contains your point
11:31:23 <ReinH> edwardk: so in our cellular automata right now we do: [s-1, s, s+1]
11:31:27 <edwardk> where vector may be quite small: up/down/left/right
11:31:27 <ReinH> we'd need to generalize that
11:31:42 <ReinH> over that map
11:32:03 <ReinH> encode the small world properties into the way we perform the experiment?
11:32:05 <edwardk> newtype World s move a = World (s -> move -> s) (s -> a) s
11:32:13 <edwardk> er data World
11:32:34 <ReinH> so a store with an additional s -> move -> s that encodes the topo?
11:32:38 <edwardk> yeah
11:32:39 <Fuuzetsu> edwardk: Can you name some specific packages of yours that build with HEAD and are heavily documented? If possible, I'd rather not download and try to compile the large number of packages you have up.
11:32:49 <ReinH> where move is?
11:33:00 <edwardk> you can pull the topology out into a class as well to avoid bundling it
11:33:16 <edwardk> the space of moves you're willing to allow your automata up to your 'speed of light'
11:33:37 <edwardk> even better you can use an indexed comonad to make that more explicit
11:33:56 <ReinH> edwardk: how would you represent that? For the non-small world it might be [(-1), id, (+1)] ?
11:34:02 <edwardk> newtype World s m t a = World (s -> m -> t) (t -> a) s
11:34:03 --- mode: ChanServ set +o monochrom
11:34:05 --- mode: monochrom set -bb *!*@gateway/web/freenode/ip.98.85.4.55 *!*@197.1.181.141
11:34:07 <edwardk> so you have to move
11:34:10 --- mode: monochrom set -o monochrom
11:34:17 <ReinH> monochrom: what happened?
11:34:29 <edwardk> then you can have data Move = L | Stay | R
11:34:32 <monochrom> manual expiring of bans
11:34:34 <edwardk> for the number line case
11:34:40 <ReinH> monochrom: ah -bb not +bb
11:34:44 <ReinH> I was like... did I miss something?
11:35:07 <ReinH> edwardk: here's a thought
11:35:10 <ReinH> for z mod n
11:35:17 <edwardk> z mod n is easy
11:35:19 <ReinH> you can represent the topo as a list of points of length n
11:35:25 <edwardk> you can just let them add to it and normalize
11:35:29 <edwardk> not every topology works that way
11:35:46 <ReinH> "let them add to it and normalize"?
11:35:58 <edwardk> (s+1) `mod` n
11:36:03 <edwardk> (s-1) `mod` n
11:36:08 <ReinH> oh normalize = (`mod` n`, right
11:36:10 <edwardk> those are fine left/right moves
11:36:25 <edwardk> but if you want to be able to sew your world together in interesting ways that fails
11:36:29 <mkramer> Alright. I have a working "filePaths" function that interprets positional command-line parameters based on what the user has supplied using —named args, but it's very ugly, and wouldn't scale to more parameters. http://lpaste.net/92372. Can anyone suggest a better way?
11:36:32 <ReinH> edwardk: right
11:36:44 <edwardk> e.g. consider moving right out the side of the map brings you into the bottom of it, etc.
11:36:45 <ReinH> what kind of interesting ways are we talking about?
11:36:52 <ReinH> edwardk: klein 2d worlds?
11:36:59 <edwardk> that sort of thing, yes
11:36:59 <ReinH> right
11:37:06 <FreeFull> I don't think this game was worth the effort it took to compile it
11:37:16 <mantovani> I need an example of genRange
11:37:19 <mantovani> :(
11:37:22 <tomboy64> what's the command in ghci to display the maximum value for Int?
11:37:23 <ReinH> edwardk: so what is this generalization that works over all these topos?
11:37:29 <ReinH> sounds like she would be interested in that :)
11:37:31 <mantovani> I need generate random numbers between an interval
11:37:36 <mantovani> how can I do it ?
11:37:40 <edwardk> Fuuzetsu: not sure what i have that would fit that criterion. i think lens head will compile on HEAD
11:38:04 <edwardk> ReinH: i'm making it up as we talk =P
11:38:19 <ReinH> edwardk: :D fun!
11:38:21 <edwardk> Fuuzetsu: compile yes, work no =)
11:38:44 <Fuuzetsu> Well, as long as I can generate Haddocks out of it.
11:38:54 <edwardk> Fuuzetsu: yeah then that would be what i'd recommend
11:39:02 <edwardk> Fuuzetsu: if it doesn't build. patch and tell me! =0
11:39:06 <ReinH> edwardk: I think Moves is really Neighbors?
11:39:07 <Fuuzetsu> Alright, I'll have a look, thanks.
11:39:17 <Fuuzetsu> Patching lens… I'd rather avoid it if at all possible.
11:39:26 <edwardk> ReinH: they are 'places you can get information from' including yourself
11:39:43 <tomboy64> ah, found it
11:39:44 <ReinH> edwardk: so if you have a total function Neighbor -> Point, that encodes the manifold for your atomata
11:39:49 <tomboy64> > maxBound :: Int
11:39:50 <edwardk> i you consider a real speed of light, its the edge of the light cone
11:39:50 <lambdabot>   2147483647
11:40:01 <tomboy64> haha!
11:40:04 <tomboy64> mine is bigger!
11:40:07 <edwardk> ReinH: yeah
11:40:13 <ReinH> edwardk: I think I'm using manifold correctly here. The local shape of the topo.
11:40:26 <edwardk> its correct enough
11:40:30 <ReinH> heh :)
11:40:46 <ReinH> edwardk: and you can represent trivial ones trivially
11:41:25 <ReinH> move Left = (-1); move Same = id; ...
11:41:30 <edwardk> yeah
11:41:49 <Zenol> edwardk: If you have a minute, I have a question about makeClassy. I would like to know if there is something in lens to generate the instances of HasType for type that has only one field of type Type. (Because it seams that data Cpu = ..., data Vm { _vmCpu :: CPU}, makeClassy ''Vm isn't enougth to have HasCpu Vm where cpu = vmCpu generated :/)
11:41:52 <edwardk> trying to find a nice way to prevent you from using your 'current coordinate' in the rule for the automaton
11:42:13 <ReinH> and more complex ones as well... move NW = ((-1) `mod` n), (-1) `mod` n)) for a torus
11:42:22 <ReinH> switch them around for others
11:42:41 <edwardk> Zenol: we have 'makeFields' which should do that for you, but i never use it personally
11:43:09 <ReinH> (with some arrowy goodness in there to make it type check ofc)
11:43:36 <ReinH> edwardk: how would you not need to use your current coord? o_O
11:43:39 <edwardk> so lets look at a rule. a rule is currently defined as a Store s a -> a   transition, but what we really want is that the rule can't jnow about s and t in the world, and can only know the moves
11:43:50 <edwardk> going back to
11:43:58 <ReinH> what is t?
11:44:08 <edwardk> data World s m t a = World (s -> m -> t) (t -> a) s
11:44:20 <ReinH> right
11:44:25 <ReinH> so what magic is t?
11:44:50 <edwardk> a rule should look like (forall s. t. World w m t a -> a)   -- so it can't use s or t
11:45:03 <edwardk> t is to prevent s from being passed directly back
11:45:08 <ReinH> right
11:45:23 <edwardk> now lets see what we can eliminate from that
11:45:44 <ReinH> wait, how does (forall s. t. World w m t a -> a) mean we can't use s or t?
11:45:56 <Zenol> edwardk: Oh, thanks :)
11:46:07 <fdvsu> quick quiz
11:46:29 <fdvsu> are multi-param typeclasses gonna be in haskell 2014 std?
11:46:50 <edwardk> ReinH; because you don't know anything about them other than they exist, and that you can pass the s into the function
11:46:51 <fdvsu> I kn no one takes haskell std seriously
11:46:58 <geekosaur> not likely
11:47:14 <edwardk> so lets go back to our rule notion and simplify
11:47:18 <edwardk> this is still too complicated
11:47:37 <edwardk> what we really want is that a rule is something that takes (m -> a) -> a
11:47:45 <edwardk> given the ability to answer what you can see, give an answer.
11:47:53 <geekosaur> they're too painful without either fundeps or type families, fundeps get under too many people's skins, type families are still evolving
11:47:57 <edwardk> then we can lift a rule into a world where we can apply the moves
11:48:21 <edwardk> (s -> m -> s) -> ((m -> a) -> a) -> World s a -> a
11:48:31 <fdvsu> what happened to remove implicit prelude import in ghc 7.x (i.e after 7.8), are they going with it or it will be status quo?
11:48:40 <edwardk> that gives you the topology, the rule and then you can apply it to a store giving an answer
11:48:51 <edwardk> now our rules can't cheat and use their coordinate
11:49:01 <edwardk> as they can only see the torsor-like move structure
11:50:03 <mcstar> i.e. they are concerned about the 'small world' only?
11:50:11 <edwardk> rein sms maa (Store sa s) = maa (sa . sms s)
11:50:40 <edwardk> ReinH: that gives you a function that takes a topology, and a rule specified in coordinateless form, and gives you the cokleisli store action that evaluates a step
11:50:49 <edwardk> now the rules can't cheat with regards to the topology
11:51:07 <edwardk> they can't see where they are and only have access to the intrinsic properties of their location rather than the extrinsic notion of a coordinate
11:51:10 <ReinH> edwardk: reading
11:55:06 <edwardk> ReinH: consider writing the wolfram rules that way by using a set of three possible moves as m.
11:55:29 <ReinH> mcstar: "small world" actually means something different here, but yes :)
11:56:15 <ReinH> edwardk: we probably want world to be World m s a so we know what moves are available in the world?
11:56:26 <edwardk> you have the topology captured in (s -> m -> s)  it could just add/subtract the offset, do so modulo something, it could even say that the answer for some other point
11:56:36 <edwardk> well, here World = Store
11:56:39 <ReinH> right
11:56:49 <ReinH> and m is determined by sms and maa
11:56:50 <edwardk> the topology is in the thing that applies the rule
11:57:02 <edwardk> m is determined by the topology and speed of light you want
11:57:08 <ReinH> right
11:57:25 <edwardk> and if you want to allow yourself to see your old value or just your neighbors, etc.
11:57:26 <ReinH> I meant: the type of m is determined by sms and maa
11:57:33 <edwardk> yeah
11:57:37 <mcstar> how can you determine the speed of light without running the simulation?
11:57:40 <edwardk> but the world doesn't care
11:57:54 <ReinH> mcstar: it's determined by the moves you allow
11:58:03 <edwardk> mcstar: the speed of light in life is how fast information can travel using the rules
11:58:03 <edwardk> the rules only see 'one neighbor away'
11:58:09 <edwardk> so the speed of light is one move per step
11:58:27 <edwardk> in an automata that can look 2-3 nighbors out you get a faster speed of light
11:58:40 <mcstar> but you cant be sure if that works for all the rules, i mean, imagine that one move generates a situation, when the alive cells actually reduce
11:58:43 <ReinH> mcstar: Moves = Left | Right gives c = 1
11:58:55 <mcstar> now, over 2 steps, the information doesnt spread as fast as over 1 step
11:58:57 <ReinH> Moves = LL | L | R | RR gives c = 2
11:59:07 <ReinH> mcstar: speed of light is constant
11:59:08 <edwardk> mcstar: you can say that that does work for all the ruls when the rules are restricted to only looking n neighbors.
11:59:33 <flebron> which direction of f id = id <=> f (g . h) = f g . f h is true (and provable)?
11:59:51 <edwardk> whether the rule sends information at the speed of light is subjective, it could move slower
11:59:54 <mcstar> basically, you define C as the maximum possible speed, not the max speed a coherent entity could travel
12:00:00 <edwardk> the speed of light is just the cap on information travl
12:00:01 <edwardk> correct
12:00:13 <ski> flebron : quantifiers ?
12:00:16 <mcstar> that is somewhat wrong i think, but who cares
12:00:17 <edwardk> much like in this universe
12:00:23 <ReinH> mcstar: how is it wrong?
12:00:46 <mcstar> there is no guarantee that there is an alive cell or a cluster of them traveling at that speed
12:00:47 <flebron> ski: forall g, h. f is fixed (conceptually a fmap implementation, i'm trying to remember which functor law was implied by the other as a free theorem)
12:00:50 <edwardk> if i drive 100mph down the street, the speed of light for me doesn't become 100 mph =)
12:00:58 <mcstar> only that it could possibly can for a certain rule
12:01:36 <edwardk> mcstar: sure, the speed of light is used as a bound for information propagation, if you can handle information traveling at that speed then you can handle any possible state transitions in your automaton
12:01:39 <ReinH> mcstar: cells don't travel
12:01:41 <ReinH> information travels
12:01:47 <ReinH> cells stay in the same place
12:02:15 <mcstar> edwardk: ofc, thats true
12:02:32 <mr-> flebron: I don't think either direction is true
12:02:33 <edwardk> now if you can show that given your system of rules there exist no transitions possible, then you can tighten the analysis
12:02:36 <ski> flebron : `forall g,h. (f id = id <=> f (g . h) = f g . f h)' or `f id = id <=> (forall g,h. f (g . h) = f g . f h)' ?
12:02:45 <ReinH> edwardk: transitions?
12:03:23 <flebron> ski: i am trying to see which of the following is true: (f id = id => (forall g, h. f (g.h) = f g . f h), or ((forall g, h. f (g.h) = f g . f h) => f id = id).
12:03:30 <edwardk> ReinH: if your rules permit viewing information 2 cells away and you only use information 1 cell away while the speed of light is in theory 2, it is 1 for your simpler automaton embedded in a more permissive universe
12:03:43 <ReinH> ah
12:03:44 <flebron> s/),/)),/ :)
12:03:47 <edwardk> thats all
12:03:51 <ReinH> sure
12:04:10 <ReinH> so s -> m -> s encodes your topo
12:04:13 <edwardk> yeah
12:04:16 <ReinH> (m -> a) -> a encodes your rules
12:04:25 <ReinH> Store s a encodes your universe
12:04:31 <edwardk> and ((m -> a) -> a)  gives you the independence from your coordinate frame
12:04:34 <edwardk> yp
12:04:37 <ibotty> aristid: are you online?
12:05:16 <ReinH> edwardk: I need to go over how maa works again
12:05:20 <ReinH> reading up
12:05:34 <mr-> flebron: f id = id certainly does not imply anything for f (g . h) (when you know nothing else about f..)
12:05:36 <edwardk> (m -> a) -> a  is saying if you can tell me the answers for all the things i can see, i'll give you my answer.
12:05:45 <edwardk> now the rule is coordinate-free
12:05:50 <edwardk> its just using relative movements
12:06:05 <flebron> mr-: f :: (a -> b) -> t a -> t b for some type ctor t
12:06:09 <aristid> ibotty: yup.
12:06:12 <edwardk> @djinn (s -> m -> s) -> ((m -> a) -> a) -> (s -> a) -> s -> a
12:06:12 <lambdabot> f _ a b c = a (\ _ -> b c)
12:06:18 <edwardk> @djinn (s -> m -> t) -> ((m -> a) -> a) -> (t -> a) -> s -> a
12:06:19 <lambdabot> f a b c d = b (\ e -> c (a d e))
12:06:32 <edwardk> that forces djinn to use the topology
12:06:37 <edwardk> hence the t
12:06:52 <ReinH> ahh
12:07:01 <ReinH> there's no way djinn can use the s
12:07:06 <edwardk> yep
12:07:10 <ReinH> so rules can no longer have arbitrary access to the space
12:07:21 <edwardk> yeah
12:07:39 <ReinH> the topo provides the experiment
12:07:43 <edwardk> by splitting Store's state into s and t you can only cross the chasm by using some way to turn s into t, to apply the function
12:07:45 <ibotty> great. another q regarding extending aws. every request for mws has a required header `SellerId`. that's why i thought about including it in MwsConfiguration (the analogous config to S3Configuration, etc). but i have trouble defining a defaultServiceConfiguration then.
12:07:45 <ReinH> that is applied over the store
12:08:01 <edwardk> and the topology gives you the way across
12:08:18 <ibotty> without opting out of type-safety (as in hack around it with maybes)
12:08:24 <edwardk> you're going to drive me to write another cellular automata post at this rate ;)
12:08:26 <ReinH> edwardk: don't you want s -> m -> [s]? Or [t]? A list of the neighbors? Am I confused?
12:08:27 <edwardk> sneaky
12:08:36 <ReinH> oh you need to apply sms for each m
12:08:38 <edwardk> why do w need a finite number of neighbors?
12:08:42 <edwardk> thats the job of the rul
12:08:47 <edwardk> it can ask as many of them as it wants
12:08:51 <ReinH> oh right
12:09:11 <edwardk> this permits us to have access to an infinite number of neighbors and only choose to interact with some of them… like we do here in Boston
12:09:15 <aristid> ibotty: hum maybe you should just not have a defaultServiceConfiguration
12:09:19 <ReinH> hah
12:09:33 <ReinH> edwardk: I have a plan.
12:09:50 <ibotty> heh. that sounds reasonable :)
12:09:51 <ReinH> edwardk: I am going to work this up in two parts: this part and a second part introducing small-world properties to the topology
12:10:13 <ReinH> edwardk: and I want you to TR it for me so I can post it to SoH :D
12:10:17 <ReinH> in your copious free time :D
12:10:28 <edwardk> heh
12:10:35 <ReinH> it's less work than writing it yourself. Maybe.
12:10:51 <ReinH> depending on how obtuse I am, there's probably a threshold
12:11:13 <ReinH> I think I can make a lot of progress with what you've said so far though
12:11:23 <edwardk> happy to help
12:11:26 <ReinH> edwardk: how can I get access to SoH? Sign up for beta?
12:11:34 <edwardk> ReinH: sounds right
12:11:45 <ReinH> doing it
12:12:19 <haasn> edwardk: (do we want noneOf l f = not . anyOf l f ?)
12:12:22 <edwardk> i like this separation of topology from moves from world
12:12:42 <tel> anyone have a reference about merging possibly infinite lists of infinite lists such that we preserve ordering—whether it's possible, when it's possible
12:12:50 <ReinH> edwardk: ah, signing up for the beta doesn't give you access to anything, it just puts me in a sales queue
12:12:52 <edwardk> haasn: anyOf was chosen by analogy to any. i'm not sure i want to run off and take all the trivial negations of them
12:12:53 <ReinH> edwardk: yes, me too
12:13:10 <tel> it feels like generalizing diagonal enumeration of the rationals
12:13:20 <edwardk> ReinH: there should be something else then
12:13:20 <edwardk> ReinH: https://www.fpcomplete.com/auth/login
12:13:21 <edwardk> that work?
12:13:42 <haasn> edwardk: I can't think of a useful name for the negation of allOf, at any rate, but ‘noneOf’ just seems like a perfectly reasonable combinator.  noneOf (folded.folded) (>10) -- or whatever
12:13:47 <ski> tel : a sorted list of sorted lists ?
12:13:56 <haasn> s/combinator/function/
12:14:10 <ReinH> edwardk: win!
12:14:17 <flebron> So kind of newbie question. I'm looking at Applicative, and the "main" use I'm seeing is to be able to work with functions that take more than 1 parameter. However, knowing Howard-Curry, one sees a -> b -> c <=> (a, b) -> c (simply using curry and uncurry is the implementation of this idea), so functions with more than 1 parameter shouldn't be special, since they are always equivalent to a function of 1. So why is Applicative special? When else do we
12:14:17 <flebron>  get functions that are in a functor?
12:14:19 <tel> ski I know they're sorted and I want to merge them such that it's productive
12:14:25 <ReinH> edwardk: do you write things directly in the SoH IDE or start with a literate haskell version or?
12:14:26 <edwardk> haasn: it strikes me as a bit gratuitous i'll admit ;)
12:14:34 <ski> tel : but is the list of lists also sorted ?
12:14:44 <edwardk> ReinH: i start in the SoH IDE after i get a basic version compiling
12:14:48 <ReinH> cool :)
12:14:57 <ReinH> edwardk: I've got all day so I'm going to work on it
12:15:03 <tel> ski in my particular application, yes, but I'd like to get away with something weaker
12:15:12 <edwardk> you can view source on any of my other tutorials for ideas for how to work with the active haskell bits, etc.
12:15:24 <haasn> edwardk: would you accept a patch?
12:15:24 <edwardk> and you can steal the diagrams code back from the first automata post to show it all
12:15:27 <ReinH> flebron: what can you do with an Applicative that you can't do with a Monad?
12:15:35 <ReinH> edwardk: yep! :D
12:15:38 <edwardk> haasn: sure. its easier to click 'okay' than reject and explain ;)
12:15:40 <ReinH> edwardk: thanks
12:15:44 <tel> ski I'm generating schedules that I can interleave and I'd like to use laziness to separate out choosing "stop dates"
12:15:49 <ski> flebron : instead of `(<*>) :: i (a -> b) -> (i a -> i b)' as a primitive, one could have `i a -> i b -> i (a,b)'
12:15:51 <flebron> ReinH: since monads are applicatives, nothing
12:16:08 <mcstar> i still cant find the site...
12:16:23 <ski> tel : not sure what you mean by "stop dates"
12:16:30 <tel> ski say you have a schedule for a day, you can repeat that each day forever by shifting it by 24 hours and appending
12:16:57 <mcstar> again, a haskell online course, possible hosted on a uni., turquoise menubar on the top, the page has gold-yellow like background
12:17:02 <tel> ski in this case, we know that each copy is strictly later that the prior, so it's easy to merge them and keep the sort productively
12:17:25 <mcstar> does anyone remember this site?
12:18:02 <ski> flebron : so, to get from `i ((a,b) -> c)' to `(i a,i b) -> i c', you still need this other primitive, if not `(<*>)'
12:18:26 <tel> ski it seems like that operation depends upon being able to envelope your schedule—guarantee there are min and max bounds
12:18:44 <BMeph_> i a -> i b -> i (f a b)! :)
12:19:11 <tel> which is also needed to some degree in order to know how the schedules align—much like the envelopes used for `beside` in diagrams
12:19:26 <tel> but it just all feels pretty coarse
12:19:53 <ski> tel : i suspect it's a matter of taking the head of the head, then inserting the tail of the head in the tail, and continuing
12:20:47 <ski> if the list of lists is sorted, and the whole list is sorted, then the head of the head is a least element
12:21:04 * hackagebot aws-elastic-transcoder 0.2.0.0 - Haskell suite for the Elastic Transcoder service  http://hackage.haskell.org/package/aws-elastic-transcoder-0.2.0.0 (ChrisDornan)
12:21:17 <ski> removing it may cause the read of the head list (the tail of it) to not preserve the ordering of the list of lists, so we need to insert
12:21:17 <newbie2> what is the smartest way to double loop throw some list?
12:21:49 <tel> ski yeah—I think that's how Data.List.Ordered.mergeAll works
12:22:05 <haasn> edwardk: would “noneOf each (is _Nothing) (Just 3, Just 4, Just 5)” be pushing it as an example? :)
12:22:06 <BMeph_> newbie2: double-loop through? ;)
12:22:20 <ski> @let diag :: Ord a => [[a]] -> a; diag [] = []; diag ([]:ass) = diag ass; diag ((a:as):ass) = a : diag (insert as ass)
12:22:20 <lambdabot>  .L.hs:194:11:
12:22:20 <lambdabot>      Could not deduce (a ~ [a0])
12:22:20 <lambdabot>      from the context (Ord a)...
12:22:27 <ski> er
12:22:32 <ski> @let diag :: Ord a => [[a]] -> [a[; diag [] = []; diag ([]:ass) = diag ass; diag ((a:as):ass) = a : diag (insert as ass)
12:22:32 <lambdabot>  Parse failed: Parse error: ;
12:22:35 <edwardk> haasn: knock yourself out ;)
12:22:38 <BMeph_> The smartest way is not to do it. ;)
12:22:39 <newbie2> BMeph_: for (i : list) for (j : list)
12:22:40 <ski> @let diag :: Ord a => [[a]] -> [a]; diag [] = []; diag ([]:ass) = diag ass; diag ((a:as):ass) = a : diag (insert as ass)
12:22:42 <lambdabot>  Defined.
12:22:43 <mcstar> lol at the end ^
12:22:55 <mkrull> hi. i would like to lookup values in [(key :: String, value :: String)]. at the moment i am using a combination of lookup and fromList from Data.Map like 'lookupList k xs = lookup k $ fromList xs'. does this look ok or would you suggest another approach?
12:23:00 <newbie2> BMeph_: have to do this action in Haskell
12:24:30 <mcstar> i dont even know what double loop means
12:24:46 <ski> > diag [[x^y | y <- [1 ..]] | x <- [2 ..]]
12:24:49 <lambdabot>   [2,3,4,4,5,6,7,8,8,9,9,10,11,12,13,14,15,16,16,16,17,18,19,20,21,22,23,24,2...
12:25:15 <BMeph_> I don't even know what a "double loop throw" is... ;)
12:25:34 <mcstar> newbie2: try to explain your problem a little better
12:25:37 <tel> ski hm, that's sort of what I thought would work as well… now I need to dive back in and figure out why that isn't working
12:25:39 <tel> ski thanks
12:25:51 <ski> tel : i'm not sure whether you needed anything more than this
12:26:15 <mcstar> i think he wants zipWith though
12:26:20 <mcstar> :t zipWith
12:26:20 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
12:26:58 <tel> ski I'm not sure either unfortunately, haha. What I have isn't lazy enough and I need to figure out if it's really the interleaving where that's happening
12:27:02 <newbie2> mcstar: i have a list of elements. What do i want to do in simple language : foreach a in list { foreach b in list {do_smth(a, b)} }
12:27:33 <mcstar> well, thats not really simple language
12:27:42 <mcstar> i dont know the semantics of your pseudocode
12:27:52 <valyagolev> just learned about http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters
12:27:57 <aizo> hi, is there extension for ghc to autocerse Int into Integer and wiseversa? One smart pants puts Int into his lib and another puts Integer into his lib and i can't make these two libs play nice together without setting my hair on fire.
12:27:58 <valyagolev> this is cool
12:27:59 <mcstar> is do_smth a pure function?
12:28:05 <aizo> autocoerce*
12:28:30 <newbie2> mcstart: does not matter
12:28:47 <mcstar> i think it does
12:28:49 <newbie2> mcstart: let it be so
12:29:27 <mcstar> > let lst = [1..5] in [a + b | a <- lst, b <- lst]
12:29:29 <lambdabot>   [2,3,4,5,6,3,4,5,6,7,4,5,6,7,8,5,6,7,8,9,6,7,8,9,10]
12:29:32 <BMeph_> newbie2: Here's a hint: If it were just one list, do you know what you'd do? :)
12:30:07 <mcstar> newbie2: it matters, if you want to execute IO on the elements, or you can construct a new list in many ways(nested or flat list)
12:30:13 <valyagolev> it's like Reader monad but much cooler, isn't it?
12:30:17 <BMeph_> Okay, NM, mcstar is just gonna toss Spoilers out.... ;)
12:30:18 <ski> @let diagBy :: (a -> a -> Ordering) -> [[a]] -> [a]; diagBy compare [] = []; diagBy compare ([]:ass) = diagBy compare ass; diagBy compare ((a:as):ass) = a : diagBy compare (insertBy (mconcat .: zipWith compare) as ass)
12:30:20 <lambdabot>  Defined.
12:30:30 <haasn> edwardk: sent
12:30:40 <mcstar> BMeph_: next time coordinate with me in private :)
12:30:46 <enthropy> aizo: let fi = fromIntegral -- now the conversions will be quieter
12:30:49 <ski> > diagBy (comparing (uncurry (^))) [[(x,y) | y <- [1 ..]] | x <- [2 ..]]
12:30:52 <lambdabot>   [(2,1),(3,1),(2,2),(4,1),(5,1),(6,1),(7,1),(2,3),(8,1),(3,2),(9,1),(10,1),(...
12:30:56 <newbie2> BMeph_: recursion
12:31:30 <newbie2> mcstar: no, i dont want do this. All actions can be pure functions
12:31:46 <mcstar> dont use action pls, action usually means IO action here
12:31:50 <enthropy> aizo: I don't believe there's a way to get those conversions put in for you. They could be inside one (or both) of the libraries
12:31:54 <blume> /j haskell.de
12:31:57 <ski> tel : there could perhaps be some smarter variant of this that was stable ..
12:32:02 <blume> woops.
12:32:17 <ski> (mayhaps instability is your problem. i don't know)
12:32:41 <tel> ski let me clean stuff up and try replicating the core functionality. I'd lpaste but this problem is in the middle of a mess of code
12:32:42 <mcstar> also, if it is a pure function, you somehow would want to collect its results, otherwise, theres no point in executing it(which haskell wont, cause of lazy semantics)
12:32:55 <aizo> enthropy: nope, one expects Ints and another Integers, i wonder why do we have OverLoadedString but not DontCareIntOrInteger extensions. :/
12:33:27 <mcstar> fyi, (+) is a pure function
12:33:41 <newbie2> mcstar: i'm going to add one more param to function that collects result
12:33:49 <ski> (all Haskell functions are pure)
12:34:00 <haasn> all*
12:34:32 <newbie2> mcstar: smth like http://lpaste.net/92373
12:34:51 <enthropy> aizo: -XOverloadedStrings doesn't add coercions wherever necessary
12:35:11 <enthropy> it just puts them on the literals, which you already have for things like 1 and 2
12:35:51 <tel> ski: I was thinking of Conal's improving the whole time, too, but I'm not sure that's an appropriate model except that it also dealt with time
12:36:19 <ski> hm, what's that `improving' ?
12:36:25 <haasn> what's the semantics on when Integer's internal representation switches from Int to gmp, anyhow?
12:36:46 <ReinH> flebron: what I meant to say is, what do applicative monads do that older, non-applicative monads don't?
12:36:46 <haasn> will staying in the range 2^31 or whatever always guarantee Integer uses Int internally?
12:36:49 <mcstar> newbie2: so what is the question exactly? you could write such a function... what isnt clear?
12:37:08 <enthropy> > fromIntegral (10^10) :: Int
12:37:09 <lambdabot>   1410065408
12:37:11 <flebron> ReinH: i didn't know non-applicative monads existed :o
12:37:38 <newbie2> mcstar: it goes throw all elements of list once, i need twice .-. Well, seems like i know the solution
12:37:50 <ReinH> flebron: Applicative is (unfortonately) newer than Monad, so monads are not automatically applicative
12:37:56 <ReinH> even though they can be made applicative
12:38:03 <flebron> right
12:38:30 <enthropy> @src Integer
12:38:30 <lambdabot> data Integer = S# Int#
12:38:30 <lambdabot>              | J# Int# ByteArray#
12:38:30 <tel> ski: it's in Conal's Push-Pull Semantics paper. Which I haven't read in a long time, but essentially was attacking the productivity problem for signals in FRP.
12:38:38 <ReinH> flebron: Marlow's recent talk about Haxl gives a nice example of what applicative can do that non-applicative monads can't
12:38:48 * flebron goes to check it out :)
12:38:52 <ReinH> flebron: for instance, mapM in Control.Monad is non-applicative
12:39:01 <enthropy> haasn: probably (fromIntegral :: Int -> Integer) ends up calling  S#
12:39:03 <tel> ski it's connected to unamb
12:39:11 <ReinH> flebron: he made the slides available recently
12:39:14 <enthropy> provided ghc's Integer is still set up that way
12:39:18 <ReinH> not sure if there's audio or video :(
12:39:21 <ReinH> but I'd love to find some
12:39:26 <tel> ski but thus has a lot more to do with impurity and side effects than just sorting
12:39:38 <ReinH> flebron: also we're hoping to get SM on the Haskell Cast in November or so. But shhhh, secret. :)
12:39:45 <ReinH> he's kind of busy right now ;)
12:39:45 <flebron> :))
12:39:58 <haasn> enthropy: yeah but what about S# x + S# y ?  S# x * S# y ?
12:40:14 <ski> tel : mhm
12:40:30 <ReinH> you know, rebuilding a fundamental part of Facebook, like you do.
12:41:06 <mcstar> newbie2: http://sprunge.us/FRKB?haskell look at this if you are stuck
12:42:55 <ReinH> edwardk: I have another question
12:42:55 <newbie2> mcstar: thanks, i ll check it
12:43:02 <Taslem> Is it sufficient that liftM follows the functor laws for the definitions of (>>=) and (return) used in liftM to form a valid monad?
12:43:11 <spaceships> is there a more idiomatic way to check conditions in whileM loops than things like this: "whileM_ (get >>= \p -> return (p > n)) $ do ..."? I've just been putting the predicate in a "when"statement...
12:43:15 <Tekmo> Taslem: No
12:43:19 <ReinH> Tekmo: hi!
12:43:21 <Tekmo> Taslem: It needs to also obey the monad laws
12:43:26 <Tekmo> ReinH: Hi! :)
12:43:45 <Taslem> Tekmo: I meant, can it be proved that it must satisfy the monad laws. Can you think of a counterexample?
12:43:46 <geekosaur> fmap (> n) get -- ?
12:44:04 <spaceships> geekosaur: oh, cool, thanks
12:44:20 <aizo> is there some way to make it type check and return 1.33333?
12:44:23 <aizo> > (4 :: Integer) / (3 :: Int)
12:44:24 <Tekmo> "ListT done wrong" from `transformers` is a counter-example
12:44:24 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
12:44:24 <lambdabot>              with a...
12:44:44 <enthropy> Taslem: gets (> n) -- another option
12:44:52 <Tekmo> It has a correct `fmap` in terms of `liftM` but does not have a valid monad instance
12:45:12 <enthropy> oops that was for spaceships
12:45:16 <aizo> div only returns integers(or whatever without floating point) so its not an option
12:45:29 <edwardk>   ReinH : back
12:45:39 <ReinH> edwardk: heh :) actually two questions
12:45:44 <spaceships> enthropy: very cool, thanks
12:45:48 <geekosaur> aizo: use fromIntegral on both sides
12:46:21 <ReinH> edwardk: there is some relationship between your topology and your moves, right?
12:46:24 <ReinH> they are not entirely orthogonal
12:46:32 <edwardk> sure
12:46:38 <ReinH> edwardk: how would you represent that? typeclasses?
12:47:03 <ReinH> any moves on Z2 should work with any topo on Z2? what's the relationship?
12:47:04 <edwardk> well, since there is an MPTC involved at best i prefer not to, and to just pass around the world explicitly
12:47:04 <aizo> geekosaur: yay, thanks, that is such a pain.
12:47:06 <edwardk> i like defaulting
12:47:12 <ReinH> MPTC?
12:47:19 <Tekmo> Multiparameter type class
12:47:21 <edwardk> multi-parameter type class
12:47:28 <ReinH> ah
12:47:42 <ReinH> edwardk: so you wouldn't worry about making that relationship explicit in the type system?
12:48:03 <edwardk> your space of 'moves' may determine 's', but then you need to put a parameter on m, or you have to make an MPTC involving both s and m
12:48:16 <ReinH> right
12:48:43 <Twey> spaceships: You can write whileM_ ((> n) <$> get) $ do …
12:48:56 <edwardk> so basically any way you encode it with a typeclass is more restrictive than just letting them float free
12:49:13 <Twey> spaceships: Sounds like a bad idea to write your program that way, though
12:49:31 <edwardk> (s -> m -> t) -> ((m -> a) -> a) -> Context s t a -> a  pretty neatly captures the relationships you want
12:50:14 <edwardk> type Topology s t m = s -> m -> t ; type Rule m a = (m -> a) -> a             then you have step :: Topology s t m -> Rule m a -> Context s t a
12:50:28 <edwardk> er
12:50:30 <edwardk> type Topology s t m = s -> m -> t ; type Rule m a = (m -> a) -> a             then you have step :: Topology s t m -> Rule m a -> Context s t a -> a
12:50:42 <edwardk> using Context from lens
12:50:45 <edwardk> :t Control.Lens.Context
12:50:46 <lambdabot> (b -> t) -> a -> Context a b t
12:50:59 <edwardk> which is the 'indexed' store comonad
12:51:21 <ReinH> edwardk: ooh :D
12:51:26 <ReinH> edwardk: ok that's a big help :D
12:52:25 <spaceships> Twey: definitely aware that imperative is bad style in haskell ;) but i'm enjoying learning how to do it
12:52:26 <edwardk> nicely all the memoization machinery can also be applied there, as well.
12:53:57 <Lethalman> how can I read the docs in .lhs files? running lhs2TeX says it can't find lhs2TeX.fmt... I've installed the debian version
12:54:13 <Twey> spaceships: Sometimes it's worthwhile, but there are nicer ways to do it than State; look into the ST monad
12:54:20 <Lethalman> I'm trying for example to read ghc source code, but there are so many comments that it's hard to follow the code
12:54:46 <Twey> (not that that will change this code much)
12:54:56 <ReinH> edwardk: ok I'm going to go over everything you said and make notes :)
12:55:16 <edwardk> ReinH: you want me to write this one up and you tackle the next part with the small world properties?
12:55:24 <edwardk> its not a lot of work for me
12:55:29 <tpsinnem> hey -- is this thing still true: http://www.haskell.org/haskellwiki/Let_vs._Where#Problems_with_where ?
12:55:31 <ReinH> edwardk: I'm sure it's not, but I want to learn
12:55:35 <edwardk> k
12:55:39 <ReinH> :p
12:55:54 <spaceships> Twey: some kind of mixture of IO and State?
12:56:55 <Twey> spaceships: More like a restriction of IO
12:57:03 <ReinH> edwardk: how about this.
12:57:09 <spaceships> Twey: Okay, cool. Looking into it
12:57:16 <ReinH> edwardk: can you show me how to represent the automata we already built using this formulation?
12:57:23 <ReinH> and I can go from there?
12:58:00 <Twey> spaceships: It lets you do imperative memory manipulation, but guarantees that the state can't be shared between runs of the monad — so you can write an algorithm that's internally impure but is referentially transparent to the outside world
12:58:19 <Twey> (and therefore doesn't have to live in IO)
12:58:25 <edwardk> lets start with data Move = L | S | R deriving (Eq,Ord,Show,Read,Enum,Bounded)
12:58:43 <Eduard_Munteanu> Are there specific reasons for disallowing deriving clauses on GADTs? Simple things like Enum would be quite worthwhile.
12:58:55 <edwardk> now we can define rule :: Word8 -> (Move -> Bool) -> Bool
12:59:15 <edwardk> we do that by taking the existing 2-color automata function we have
12:59:17 <edwardk> notice
12:59:30 <geekosaur> didn't someone demonstrate a way to have ghc derive unsafeCoerce?
12:59:58 <edwardk> that is a lot like a store. if we had a monoid for Move we can make that the "cowriter"  'traced' comonad.
13:00:06 <ReinH> oh can we
13:00:17 <mcstar> i hope that let/where thing is not true, seems quite stupid imho
13:01:00 <ReinH> edwardk: cowriter traced comonad...
13:01:20 <mcstar> it would mean, basically every top level function definition that uses `where` to define auxiliary functions would incure a performance hit
13:01:31 <Twey> mcstar: That's not what it's saying
13:01:33 <ReinH> edwardk: and yes, it does look like a store
13:01:56 <edwardk> consider instance Monoid m => Comonad ((->) m)
13:02:34 <edwardk> ReinH: if we had a monoid for Move, we could make a comonad for functions from it. then (m -> a) -> a  would be a cokleisli action for that comonad!
13:02:39 <mcstar> Twey: it puts in parallel the second `let` with the second `where`, so yes, it does say that
13:02:44 <ReinH> edwardk: yes it would!
13:02:49 <edwardk> ReinH: we don't want one though, because it would violate our expectation of a known speed of light
13:02:51 <ReinH> edwardk: I understood those words!
13:02:58 <edwardk> but i wanted to point out that in general you would be able to do that
13:03:20 <edwardk> and that it is a path to understanding another comonad
13:03:21 <ReinH> right
13:03:24 <ReinH> nice!
13:03:43 <Twey> mcstar: But not for every function definition using ‘where’.  The problem only occurs when you're (potentially) referencing an argument passed in to the function from your where clauses, which is just how closures work.
13:04:28 <Twey> Maybe there's some nice optimization that can avoid that, but it seems fairly obvious that it's going to happen
13:04:41 <edwardk> ReinH: anyways
13:04:49 <edwardk> lets carry on with our rule
13:05:07 <edwardk> rule w (Store f s) = testBit w $   0 & partsOf (taking 3 bits) .~ [f (s+1), f s, f (s-1)]
13:05:10 <edwardk> was our old one
13:05:23 <ReinH> right
13:05:27 <edwardk> rule w f = testBit w $  0 & partsOf (taking 3 bits) .~ [f L, f S, f R]
13:05:28 <ReinH> but now we can't access s
13:05:28 <edwardk> is our new one
13:05:47 <edwardk> the absolute address is now gone
13:05:52 <edwardk> its just relative motions
13:05:56 <ReinH> right, where f is out peek into the move comonad?
13:05:58 <mcstar> Twey: sry, i dont understand, the body of `fib'` does not contain any `x`, so what is the problem?
13:06:05 <ReinH> *our
13:06:07 <edwardk> or [f R, f S, f L] i guess
13:06:46 <edwardk> well move doesn't form a comonad per se,  we're just asking it to give us the answers for the things it permits us to look at, but the general idea you have is right
13:06:53 <mcstar> Twey: this optimization seems like a triviality to me, why is it a 'nice' optimization?
13:07:05 <edwardk> if we set that up right
13:07:09 <edwardk> we can do
13:07:43 <edwardk> rule w f = testBit w $  0 & partsOf bits .~ (f <$> [minBound .. maxBound])
13:07:59 <edwardk> then rule works for any enumerable set of moves
13:08:03 <ReinH> right!
13:08:20 <edwardk> newtype Move = R | S | L deriving (Enum,Bounded) gives you wolfram's 2-color rules
13:08:33 <edwardk> but if you allow larger moves you can get a similar 'free' enumeration
13:08:39 <ReinH> edwardk: although the rule "shape" is coupled to the move enumeration
13:08:40 <edwardk> er
13:08:55 <edwardk> data Move = RR | R | S | L | LL deriving (Enum,Bounded)
13:08:56 <edwardk> sure
13:08:59 <ReinH> yep
13:09:02 <ReinH> but
13:09:07 <ReinH> you can just try random numbers
13:09:08 <edwardk> then you just need your topology to let you make those moves
13:09:09 <ReinH> and it'll Just Work
13:09:11 <edwardk> yep
13:09:16 <ReinH> which is fantastic
13:09:30 <ReinH> this is a pretty powerful abstraction already
13:09:40 <edwardk> if you want to allow more colors in your automaton you need to replace bits with some kind of 'digits' traversal
13:09:52 <edwardk> but then 'random numbers' still work
13:10:02 <mcstar> Twey: i would be grateful if you could explain this to me
13:10:40 <edwardk> and with that you've covered all n-color automata with n-neighbors of sensing
13:11:01 <edwardk> in all n-dimensional topologies with arbitrary interconnections
13:11:29 <ReinH> edwardk: ok, now I want countably infinite colors :D
13:11:35 <ReinH> just kididng
13:11:46 <edwardk> ReinH: sure, we can do that too
13:11:53 <edwardk> but you have to write the rules on a one-off basis
13:12:01 <ReinH> let's not get sidetracked
13:12:08 <mcstar> Twey: oh, i just noticed that fib' calls fib, not fib', probably i will need to reconsider my position
13:12:18 <ReinH> I'd like to do multicolor (greyscale) at some point though
13:12:24 <edwardk> this whole thing is a side-track =)
13:12:30 <ReinH> edwardk: well let's not get side side tracked then
13:12:49 <edwardk> but RPGs put all the best rewards on the side-tracks!
13:13:06 <ReinH> hah
13:13:15 <Twey> mcstar: See the ‘let’ translation
13:13:18 <ReinH> edwardk: I know but I'm really invested in the main quest right now
13:13:27 <edwardk> i live my life searching for the mana potion that i obviously left in my closet in the first city I grew up in..
13:13:36 <ReinH> haha
13:13:57 <mcstar> Twey: im looking at it, just not seeing it :)
13:14:13 <edwardk> lame. rushing through means you miss all the extra character development opportunities. its not like the big bad will happen while you're running side-quests. this isn't star control 2!
13:14:28 <ReinH> edwardk: hah
13:14:40 <ReinH> edwardk: I know. I just want to get through this new representation for cellular automata
13:14:44 <ReinH> before I try to fit anything else in my brain
13:15:17 <edwardk> ok, so you have varying dimensions, varying topologies, and easy generalizations of wolfram's 2-color rules
13:15:28 <edwardk> what more do you need?
13:15:32 <ReinH> yep
13:15:33 <ReinH> uh
13:15:48 <ReinH> I need an implementation of f
13:15:54 <edwardk> which 'f'?
13:16:04 <ReinH> f <$> [L, S, R]
13:16:19 <ReinH> f L = (-1) ... ?
13:16:24 <ReinH> is our current one?
13:16:25 <edwardk> f gets passed to your rule
13:16:27 <spaceships> Twey: Cool. Rewrote my horrible evil State implementation of fib with STRefs. Thanks for the tip!
13:16:30 <edwardk> thats (m -> a) -> a    thats the m -> a
13:16:40 <edwardk> we get that from the earlier "rein" function i gave you
13:16:48 <ReinH> looking
13:16:55 <edwardk> lets just ask djinn!
13:17:04 <ReinH> the  maa (sa . sms s)
13:17:21 <edwardk> @djinn (s -> m -> t) -> ((m -> a) -> a) -> (t -> a) -> s -> a
13:17:21 <lambdabot> f a b c d = b (\ e -> c (a d e))
13:17:28 <Twey> mcstar: The body of a function isn't evaluated until all the arguments are passed in — in this case, the ‘let’ forms the body of the function.  So the ‘let’ is what's evaluated *after* the argument is passed in, including the definitions contained therein.
13:17:45 <edwardk> rein topology (rule 110) (Store (==0) 0)
13:17:51 <edwardk> that would run on timestep
13:18:00 <edwardk> rein = f
13:18:14 <ReinH> er
13:18:30 <Twey> mcstar: In the point-free version, on the other hand, the ‘let’ is around the function itself, not including the argument, so the ‘let’ is evaluated as soon as the *function* is evaluated, before the argument is passed in (and then memoized, because it doesn't require any arguments to get to that point)
13:18:50 <Twey> spaceships: No problem ☺
13:19:06 <Twey> spaceships: Now it's a horrible evil ST implementation ;)
13:19:20 <spaceships> Twey: heck ya! haskell is awesome!
13:19:42 <ReinH> edwardk: wait, what did djinn just give me?
13:19:48 * hiptobecubic likes ST
13:19:51 <edwardk> step top rule (Store f s) = rule (f . top s)
13:19:59 <edwardk> it gave you the function we've been talking about
13:20:26 <edwardk> it gave you the thing that applies a rule in a given topology to a store that represents your world
13:20:44 <edwardk> @djinn-add type Topology s m t = s -> m -> t
13:20:45 <ReinH> ah
13:20:50 <keseldude> can someone please help me understand a small point in this paper
13:20:50 <keseldude> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf (page 29)
13:20:56 <edwardk> @djinn-add type Rule m a = (m -> a) -> a
13:21:13 <edwardk> @djinn-add data Context s t a = Context (t -> a) s
13:21:19 <keseldude> maybe it's just the notation, but I don't get what guarantee changes about the function reiterate
13:21:29 <edwardk> @djinn Topology s m t -> Rule m a -> Context s t a -> a
13:21:30 <lambdabot> f a b c =
13:21:30 <lambdabot>     case c of
13:21:30 <lambdabot>     Context d e -> b (\ f -> d (a e f))
13:22:29 <mcstar> Twey: does this mean, that in the second case, fib' as a closure, will have to close over `x` even if it doesnt use it?
13:23:54 <ReinH> edwardk: ok, I'm trying to do some variable substitution there with meaningful names
13:24:00 <Driscoll> what's the best way to get a list of elements from an array, given a list of indices?
13:24:22 <Driscoll> i'm currently doing: map (arr !) ( range (0,10) )
13:24:28 <edwardk> ReinH: that was what i did above
13:24:38 <edwardk> step top r (Store f s) = r (f . top s)
13:24:45 <ReinH> b (\ f -> d (a e f)) is confusing me
13:25:55 <edwardk> step takes a topology top, a rule r and a world where you can see the state of the world at position with the experiment f    and a current position s  and gives you the new result for that position after applying the rule
13:26:15 <ReinH> edwardk: ok let me go write some code with this new knowledge
13:26:30 <Twey> mcstar: It will close over x, yes, but that's not necessarily *why* it's redefined
13:26:39 <ReinH> edwardk: how come you used Store in one but Context in the other?
13:26:41 <edwardk> it applies your rule to compute the answer by first partially applying the topology to your position
13:26:47 <edwardk> ReinH: no deep reason
13:26:56 <edwardk> Store is probably easier to explain
13:27:02 <edwardk> and it is always a comonad
13:27:17 <edwardk> but context is only an 'indexed comonad'
13:27:57 <ReinH> so Context s t a is like State s a but you can't assume that the t and the s are the same?
13:28:12 <Twey> mcstar: The difference is between the functions (λx → let y = 3 in y) and (let y = 3 in λx → y) — the former only evaluates the let after the x has been passed in, whereas the latter evaluates the let in order to define the function in the first place, before the x is passed in
13:28:23 <ReinH> and you want that so your Topology can be s -> m -> t instead of s -> m -> s?
13:28:41 <ReinH> and you want that so you can enforce a "neighborhood constraint"?
13:28:56 <Twey> mcstar: It's possible to transform the former into the latter if x isn't referenced, but I don't know whether the compiler does so; it's reasonable (if naïve) for it to work like that
13:29:16 <bennofs> Wow, ceh seems to be a really neat way to get GHC 7.6 to travis-ci
13:29:33 <edwardk> ReinH: yeah
13:29:50 <edwardk> iextract :: w i i a -> a       would be the indexed extraction
13:29:59 <Twey> (and there may be scary compiler consequences of performing that optimization that aren't immediately obvious to me)
13:30:00 <edwardk> but you can also 'extend' an indexed comonad while the indices disagree
13:30:26 <edwardk> :t Control.Lens.Internal.Context.iextend
13:30:27 <lambdabot> Control.Lens.Internal.Context.IndexedComonad w => (w b c t -> r) -> w a c t -> w a b r
13:30:29 <ReinH> edwardk: I'm going to stick with the Store version for now and enforce the constraint manually
13:30:36 <ReinH> so I can reduce the number of new concepts I need to acquire
13:30:40 <edwardk> yep
13:31:02 <edwardk> just letting you know there are names for the other ideas involved =)
13:31:14 <edwardk> this also lets you run automata on 'changing topologies'
13:31:16 <ReinH> yep!
13:31:22 <mcstar> Twey: ok, i understand what you are saying, i just find it really odd, i was under the impression, that a binding is 'static' in a sense, that it happends after definition....somehow, and i wasnt thinking about 'evaluation'(haskell is mostly compiled[ghc]...) but probably lazy semantics makes this kind of 'binding-evaluation' necessary?
13:31:31 <edwardk> e.g. that evolve by letting the universe expand or what not between steps
13:31:54 <edwardk> that is the extra power of context
13:31:55 <Twey> mcstar: Compilation doesn't (or shouldn't) change the semantics
13:31:59 <ReinH> edwardk: ah
13:32:34 <ReinH> edwardk: so if topologies form a category, I can move from topology to topology while the world evolves by following the arrows?
13:32:49 <mcstar> Twey: no ofc not, but in other (strict[and compiled]) languages, a binding is not evaluated, afaik
13:33:28 <Twey> mcstar: I'm not sure what it would mean to say that a binding ‘isn't evaluated’, especially in a strict language; care to elaborate?
13:34:10 <mcstar> let me turn that question inside out, why is a binding in haskell 'evaluated'?
13:34:42 <edwardk> ReinH: something close to that the arrows would be your indexed cokleisli arrows, lets look at iduplicate
13:34:44 <mcstar> it is not a function application...
13:34:47 <edwardk> :t Control.Lens.Internal.Context.iduplicate
13:34:48 <lambdabot> Control.Lens.Internal.Context.IndexedComonad w => w a c t -> w a b (w b c t)
13:34:51 <ReinH> edwardk: ooh, this is more intersting maybe: can I change the neighborhood while it runs?
13:34:56 <edwardk> that is the 'splitting'
13:35:08 <ReinH> edwardk: that could model nondeterministic small world properties
13:35:12 <edwardk> ReinH: yes, sure.
13:35:19 <ReinH> run the universe in ListT or something?
13:35:20 <edwardk> just change the topology between steps
13:35:23 <ReinH> neat
13:35:26 <edwardk> we've seperated the topology from the world
13:35:29 <Twey> mcstar: In C, for example, if you have a function int foo() { int x = 3; return x; } the binding x = 3 is always evaluated (modulo optimizations) even if x isn't used in the body of the function, because it may involve side-effects that must occur before the body of the function can be executed
13:35:35 <ReinH> edwardk: this is super cool :)
13:36:42 <Twey> mcstar: I'm using the term ‘evaluated’ to mean the expression is reduced to a value, not implying any kind of interpretation.  It must be evaluated at some point or you wouldn't get a value from calling the function ☺ (of course, because of non-strictness, it needn't be evaluated if the function isn't called)
13:37:13 <Twey> In the outer-let case, you wouldn't get a function at all
13:38:26 <mcstar> hm
13:38:37 <mcstar> i have to digest this, many thanks Twey
13:39:26 <mcstar> i guess the easiest way to learn the most of haskell in the least time, is by implementing a compiler for it
13:39:41 <edwardk> mcstar: worked for john meacham
13:40:23 <edwardk> @where jhc haskell compiler
13:40:23 <lambdabot> http://repetae.net/john/computer/jhc/
13:40:29 <Twey> Heh, perhaps
13:40:36 <mcstar> :)
13:41:24 <tikhon> I find this naming convention for Haskell compilers a bit inconvenient :P
13:42:08 <Twey> One of the first things you learn about compiler implementation is that what you'd expect to happen from a human standpoint and what's most elegant to implement from a compiler standpoint often do not coincide :þ
13:42:08 <Zenol> write a haskell compiler?! X.X
13:42:29 <mauke> in haskell
13:42:35 <mauke> for maximum learnings
13:42:48 <Twey> Hehe
13:42:48 <edwardk> tikhon: especially since my work in progress compiler steals your name. ;)
13:42:49 <tikhon> It's probably easier in Haskell than any other language
13:42:53 <Twey> Zenol: It's not that terrifying
13:42:58 <Zenol> mauke: Not sure you'll learn on comonad stuff and theoric things doing so :/
13:43:12 <hiptobecubic> even better
13:43:14 <Twey> You'll probably learn some type theory
13:43:17 <hiptobecubic> you'll learn how to write an actual program
13:43:20 <mauke> heh, "theoric"
13:43:26 <edwardk> Zenol: i use a lot of lens in the ermine compiler
13:43:29 <mauke> you'll have to visit a math for that
13:43:31 <Eduard_Munteanu> I was going to pick on that.
13:43:37 <Twey> hiptobecubic: Who needs to do that?  Impractical skillset.  :þ
13:43:37 <Eduard_Munteanu> Hah.
13:43:38 <tikhon> zenol: nothing stops you from using that stuff in your implementation
13:43:40 <edwardk> we also have comonads, etc. floating around
13:44:12 <mauke> .oO( saunt edwardk )
13:44:17 <Eduard_Munteanu> Or multiple maths if you're a poly. :P
13:44:28 <Twey> Hehe
13:45:19 <Zenol> edwardk: Yes but using lens doesn't means you'll be able to write part of it or even understand how it's working :(
13:45:40 <Zenol> Twey: I feel like ghc is doing terrribe things like twisting the ast, and lazyness scare me.
13:46:18 <mcstar> i will make a fool of myself, but i still have to ask
13:46:52 <Twey> Zenol: Yeah, but GHC is a real compiler.  You wouldn't have to do most of that stuff just to play around with a toy compiler.
13:47:17 <edwardk> what is surprising is how far you can get with a basic compiler without all the crazy ghc/mu style optimizations
13:47:41 <mcstar> Twey: the evaluation of the let binding in the second case (and the worse performance thereof) does only come from, by binding the function (that implements fib') to the name fib', for each value of `x` ?
13:48:37 <Twey> mcstar: The performance difference comes from that, yes.  The binding of the name is the *effect* of evaluating the let.
13:49:00 <mcstar> at least im steering my understanding in the right direction
13:49:08 <mcstar> or is it you? :)
13:49:39 <Twey> mcstar: fib is a pretty simple function, so adding in that binding (which is fairly cheap) will have a relatively large impact on its performance.
13:49:41 <mauke> that's so cratic
14:03:00 <Zenol> > (1, 2) .~ _1 5
14:03:01 <lambdabot>   Couldn't match type `(t1, t2)'
14:03:01 <lambdabot>                with `(a0 -> Control.Lens.Int...
14:03:03 <zomg> Wrote a few thoughts on writing exploit-proof interfaces to SQL and such if anyone is interested http://codeutopia.net/blog/2013/08/31/library-author-dont-provide-an-exploitable-interface/
14:03:33 <Zenol> > set _1 5 $ (1, 2)
14:03:34 <lambdabot>   (5,2)
14:04:01 <statusfailed> What's that function (something like x = x + 1 if x is odd, otherwise x = x/2), which isn't known to terminate?
14:04:09 <statusfailed> I realise that's pretty vague... hoping someone's heard of it
14:04:17 <shachaf> 3x+1, x/2
14:04:30 <shachaf> (For the odd and even cases.)
14:04:30 <statusfailed> woop, thanks
14:04:34 <statusfailed> does it have a name?
14:04:35 <LadyAurora> Collatz.
14:04:38 <statusfailed> Thanks :D
14:04:41 <mcstar> Twey: with -O2 they are equally quick, wo/ optimization, the difference is big though
14:04:56 <shachaf> Well, the question isn't whether it terminates, it's whether it reaches 1. :-)
14:04:58 <Zenol> So _1 :: Setter s t a b, 5 :: b, and s :: (Int, Int) ?
14:05:05 <mcstar> (as in, ^c big)
14:05:17 <shachaf> Zenol: = (or ~ or something), not ::
14:05:28 <mcstar> hailstone
14:05:28 <shachaf> s is a type, and so is (Int, Int)
14:05:38 <statusfailed> shachaf: oh true :)
14:05:49 <mcstar> yeah, it stays cyclic
14:06:05 <Zenol> shachaf: er, yes, = for s.
14:06:14 <mcstar> 4 2 1 4 2 1 4 ...
14:07:06 <statusfailed> ok so follow up question
14:07:13 <statusfailed> Does this function have a name? rec f x = let r = f x in if x == r then [x] else (x : rec f r)
14:07:15 <Zenol> > _1 .~ 5 $ (1, 2)
14:07:17 <lambdabot>   (5,2)
14:07:32 <mcstar> it is called rec
14:07:34 <statusfailed> if you say collatz 1 == 1, then rec collatz n gives you the collatz sequence for n
14:07:37 <statusfailed> ho ho ho
14:07:52 <shachaf> statusfailed: But collatz 1 = 4
14:07:57 <shachaf> [4,2,1,4,2,1,...
14:08:15 <Zenol> So it's Setter InputType OutputType OldType NewType ?
14:08:42 <shachaf> Zenol: outer-in outer-out inner-in inner-out
14:08:48 <shachaf> Er, maybe that naming is confusing.
14:08:56 <shachaf> But hopefully that makes sense.
14:09:18 <haasn> Zenol: looks right to me
14:09:23 <Zenol> shachaf: i don't think, inner means "field" and outer means "whole structure", right?
14:09:28 <shachaf> Yes.
14:09:37 <statusfailed> shachaf: well, just meant it as an example really. it sorta hunts fixed points by recursively applying f to its own output
14:09:55 <haasn> (of course, the ‘Input/Output’ and ‘OldType/NewType’ could be swapped and it would still make sense, albeit differently :)
14:09:57 <shachaf> "structure"-in "structure"-out "field"-in "field"-out
14:10:13 <mcstar> there is absolutely no point in studying the collatz sequence numerically though
14:10:15 <shachaf> You can swap everything around and it still makes sense! Unsetters!
14:10:29 <statusfailed> mcstar: numerically?
14:10:45 <mcstar> as in, computing it, and looking for patterns or whatnot
14:11:28 <statusfailed> oh i'm not. I just got bored and wondered what would happened if I wrote "rec", and then mis-remembered collatz as it's sorta similar
14:12:10 <Zenol> So in a setter the type s depend on a and the type t depend on b?
14:13:05 <shachaf> Well, they're related.
14:13:18 <shachaf> You must always allow the case where s=t, a=b
14:14:06 <watermind> why is fix defined as    fix f = let x = f x in x    rather than   fix f = f (fix f)
14:14:22 <shachaf> watermind: More sharing in some cases (I think).
14:14:26 <watermind> I'm guessing to avoid some sort of memory leak, but don't see why that should be the case
14:14:30 <shachaf> Zenol: If you wanted, you could have two type functions, i and o.
14:14:32 <Zenol> > _2 %~ show $ (1, 2)
14:14:33 <lambdabot>   (1,"2")
14:14:40 <watermind> shachaf: right... but where
14:15:17 <haasn> Rettes b a t s
14:15:39 <mcstar> > let fix f = f (fix f) in fix (const 1)
14:15:41 <lambdabot>   1
14:15:48 <shachaf> type Setter s t a b = forall a b. (o a -> o b) -> i a -> i b
14:15:49 <byorgey> edwardk: ping
14:17:03 <shachaf> haasn: Yep.
14:17:57 <edwardk> pong
14:17:58 <FardadJalili> I need to write a function modify that takes a function, an input, an output and modifies the given function according to given input output.
14:18:07 <shachaf> haasn: from :: (Un p a b a b -> Un p a b s t) -> p t s -> p b a
14:18:08 <FardadJalili> modify :: Func -> Input -> Output -> Func
14:18:28 <raisdead> @pl f n = filter (<n)
14:18:29 <FardadJalili> modify f i o ii = if ii == i then o else f ii
14:18:31 <lambdabot> f = id (fix (const (filter . flip (<))))
14:18:31 <lambdabot> optimization suspended, use @pl-resume to continue.
14:18:56 <shachaf> haasn: I.e. from :: (Overloaded (Un p a b) s t a b) -> Overloaded p b a t s
14:19:03 <FardadJalili> is there a way to write this without introducing the ii pattern?
14:19:04 <shachaf> (Or the other way around if you prefer.)
14:19:14 <haasn> Un?
14:19:27 <shachaf> newtype Un p a b s t = Un { unUn :: p t s -> p b a }
14:19:45 <LadyAurora> unUn, lol
14:19:53 <FardadJalili> haha
14:19:54 <haasn> pabst
14:21:11 * Zenol was lost since shachaf's Setter declaraction
14:21:12 <d3lxa> is it possible to import a module in a scope (eg: a function) to avoid name collision in other part of the same module?
14:21:13 <raisdead> :t fix
14:21:14 <lambdabot> (a -> a) -> a
14:21:42 <mcstar> imports go on the top of the file
14:21:48 <FardadJalili> @pl update s var val v = if v == var then val else s v
14:21:51 <lambdabot> update = id (fix (const (flip (flip . (ap .) . flip . (if' .) . flip (==)))))
14:21:51 <lambdabot> optimization suspended, use @pl-resume to continue.
14:21:53 <LadyAurora> d3lxa: nope IIRC
14:21:56 <shachaf> Zenol: You can ignore that, really.
14:22:10 <shachaf> Zenol: Setter is pretty straightforward.
14:22:29 <shachaf> Zenol: It's equivalent to this: type Setter s t a b = (a -> b) -> s -> t
14:22:42 <shachaf> Think of it as a more general version of fmap.
14:22:54 <d3lxa> reformulated: if it's already import with qualified then I would like to remove avoid the noise due to the "prefix", possible?
14:23:16 <d3lxa> (s/to remove/not write the qualified name in some part/)
14:23:20 <shachaf> For example, with this simple version, fmap :: Functor f => Setter (f a) (f b) a b
14:23:22 <FardadJalili> is there a way to tell lambdabot's @pl to take out only certain inputs?
14:23:28 <mcstar> @hoogle prefix
14:23:28 <lambdabot> Data.Data Prefix :: Fixity
14:23:28 <lambdabot> Text.ParserCombinators.Parsec.Expr Prefix :: (GenParser tok st (a -> a)) -> Operator tok st a
14:23:28 <lambdabot> Text.Parsec.Expr Prefix :: (ParsecT s u m (a -> a)) -> Operator s u m a
14:23:53 <mcstar> d3lxa: you can import the module, that provides prefix, with `hiding (prefix)`
14:24:22 <kaw> I'm getting this error when doing "cabal-dev install wx", is it an indication of a problem with my setup or one with the package? http://lpaste.net/91428
14:24:35 <kaw> Not my paste, so clearly I'm not the first person to have encountered this
14:24:54 <d3lxa> mcstar: that's not what I meant: I have two modules (persistent and esqueleto) that provides both SQL operators but I have to use them both in the same module, but it's very noisy
14:25:14 <d3lxa> if I could say "in this function you use that and in the other, you use this" it would really help
14:25:15 <Kinnison> kaw: Looks like a mismatch between the version of the wx library you have installed and the wx haskell module's expectations
14:25:21 <FardadJalili> Someone help me plz :D is there a way to tell lambdabot's @pl to take out only certain inputs?
14:25:54 <FardadJalili> Also, what does pl stand for? :/
14:25:58 <joelteon> pointless
14:26:05 <zomg> poland?
14:26:05 <joelteon> is a tool for transforming functions into point-free style
14:26:06 <FardadJalili> really? :)
14:26:12 <LadyAurora> Yes.
14:26:13 <FardadJalili> Yes I know
14:26:13 <mcstar> d3lxa: i said imports go on the top of the file, cause, you cant do what you want, the must be on the top level, right after `module ... where ...` before code
14:26:16 <joelteon> @pl f x y = f y x
14:26:16 <lambdabot> f = fix flip
14:26:21 <joelteon> whoops
14:26:28 <LadyAurora> It's pointless to use it. :P
14:26:38 <FardadJalili> That's why I thought it would be pf!
14:26:40 <FardadJalili> haha
14:26:40 <fommil> hi all, what's the current state of cross-compilation for the raspberry pi? http://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling
14:26:41 <FardadJalili> :))
14:26:55 <FardadJalili> but pointless is good enough
14:26:59 <ReinH> edwardk: got it!
14:27:03 <d3lxa> mcstar: can't you threat a module like a variable and rename it somehow? or maybe I can use CPP to help me here =) or not…
14:27:11 <edwardk> ReinH: is it contagious?
14:27:24 <ReinH> edwardk: hah! I've got Topology and Rule working! :D
14:27:32 <edwardk> ReinH: nice =)
14:27:35 <ReinH> I need to bring back memoization now.
14:27:38 <ReinH> But it was super easy :D
14:27:44 <fommil> I've found it surprisingly difficult to get a C/Fortran cross compilation setup from OS X or Linux, which involved using crosstools-ng from Linux (doesn't work properly from OS X) to ensure that the binaries support HF and the EGLIBC
14:28:03 <mcstar> d3lxa: you could break up your source into 2 files...
14:28:06 <edwardk> glad that the thing i made up on the spot paid off ;)
14:28:16 <kaw> Kinnison: cabal-dev info says wxc-0.90.0.4 is supposed to work with wx 2.9, I have both 2.9 and 2.8 installed and from that error message it's finding 2.9?
14:28:21 <FardadJalili> @pl update (s,var,val,v) = if v == var then val else s v
14:28:21 <lambdabot> (line 1, column 23):
14:28:21 <lambdabot> unexpected " "
14:28:21 <lambdabot> expecting operator
14:28:42 <FardadJalili> ehem
14:28:54 <Zenol> shachaf: There shouldn't be something about CPS somehere in Setter type?
14:29:05 <FardadJalili> @pl update ((s,var),(val,v)) = if v == var then val else s v
14:29:08 <lambdabot> update = id (fix (const (ap (ap (flip (flip . (ap .) . flip (flip . ((.) .) . flip (flip . (ap .) . flip . (if' .) . flip (==))) fst) snd . fst) snd . fst) snd)))
14:29:08 <lambdabot> optimization suspended, use @pl-resume to continue.
14:29:14 <shachaf> Zenol: Not really, I don't think.
14:29:30 <d3lxa> mcstar: okay, thx
14:29:50 <int-e> :t flip ?flap ?flop
14:29:51 <lambdabot> (?flap::a -> b -> c, ?flop::b) => a -> c
14:30:07 <Kinnison> kaw: I'm afraid you're outside my expertise :-(
14:30:16 <shachaf> Zenol: No more than fmap does, at any rate.
14:30:31 <FardadJalili> @pl f x y = x y
14:30:31 <lambdabot> f = id
14:30:37 <ReinH> edwardk: it totally did :D
14:30:41 <FardadJalili> @ pl f x = \y -> x y
14:31:03 <FardadJalili> @pl f x = \y -> x y
14:31:04 <lambdabot> f = id
14:31:05 <LadyAurora> FardadJalili: space
14:31:15 <FardadJalili> LadyAurora: yep :D
14:31:35 <LadyAurora> Alternatively, f = ($).
14:31:44 <FardadJalili> LadyAurora: Yes I know
14:31:53 <ReinH> edwardk: omg, the memoization just drops right back in <3
14:32:03 <ReinH> I guess that should make sense since the f still provides the same thing
14:32:07 <FardadJalili> LadyAurora: I'm trying to find a way to ask lambdabot to translate f x y = x y to f x = x for me
14:32:15 <kaw> I'm sort of still at the stage of searching for something nice to make GUIs with, are there other options I should be exploring?
14:32:28 <FardadJalili> LadyAurora: in other words, I only want the last argument translated into point-free style
14:32:48 <LadyAurora> FardadJalili: she won't, f x = x is not pointless.
14:33:23 <FardadJalili> LadyAurora: Isn't there any workaround? somehow changing the definition for example. Nothing comes to my mind
14:33:41 <kaw> I've gotten Gtk2Hs to work but it seems a little more low-level/non-functional than I'd prefer for Haskell
14:33:42 <LadyAurora> I don't know.
14:33:52 <FardadJalili> LadyAurora: Ok, thanks a lot anyways
14:34:01 <Tekmo> kaw: Have you tried threepenny-gui?
14:34:09 <Zenol> I feel like i have already asked it and didn't understood the answer, but let's try again. What means "we monomorphize the type".
14:34:11 <FardadJalili> LadyAurora: Also, how come lambdabot is a she? :D
14:34:30 <Tekmo> Zenol: It means that the type is not polymorphic
14:34:48 <Tekmo> Zenol: For example, a type like `id :: a -> a` is polyorphic
14:35:06 <Tekmo> Zenol: If you specialize `a` to a specific value then it becomes monomorphic: `id :: Int -> Int`
14:35:32 <mantovani> I'm reanding this tutorial
14:35:35 <mantovani> http://learnyouahaskell.com/syntax-in-functions#pattern-matching
14:35:37 <kaw> Tekmo: I actually tried running the examples just before I tried compiling wx
14:35:41 <mantovani> very cool
14:35:47 <mantovani> how do I declare the types ?
14:35:48 <kaw> I would prefer a native-type GUI I think, but reactive-banana looks nice
14:35:51 <mantovani> charName :: Char -> String
14:35:52 <Twey> mcstar: *nod* That's how I'd expect it to be
14:36:07 <mantovani> if I write it "charName :: Char -> String" I get an error
14:36:18 <mantovani> "Not in scope"
14:36:33 <FardadJalili> mantovani: Are you trying that in GHCi?
14:36:40 <Zenol> Tekmo: Hum, strange because it's "(a -> b) -> f a -> f b we monomorphize the type to obtain (a -> b) -> s -> t " and s is a type variable :/
14:37:32 <mantovani> yes
14:37:40 <mantovani> FardadJalili: cyes
14:37:41 <FardadJalili> mantovani: write it in test.hs, then in GHCi enter :load test.hs
14:37:52 <mantovani> just put the code there like it without main ?
14:38:02 <FardadJalili> Yep
14:38:12 <mantovani> ok
14:38:14 <mantovani> thank you
14:38:52 <FardadJalili> yw
14:39:09 <mantovani> can I create this lists FardadJalili, in runtime ?
14:39:21 <FardadJalili> mantovani: what lists?
14:39:27 <mantovani> a = 1
14:39:28 <mantovani> b = 2
14:39:30 <mantovani> b = 3
14:39:32 <mantovani> ops
14:39:34 <mantovani> a = 2
14:39:37 <mantovani> a = 3
14:39:41 <mantovani> ?
14:40:03 <Tekmo> Zenol: I was just answering the question out of context.  I just got back
14:40:03 <mantovani> can I create pattern matching in runtime ?
14:40:16 <Tekmo> mantovani: Use the `case` statement for that
14:40:23 <FardadJalili> yep
14:40:34 <mantovani> fantastic
14:40:35 <Tekmo> mantovani: f x = case x of Left a -> ...; Right b -> ...
14:40:56 <Tekmo> You don't need semicolons if you split it over multiple lines
14:41:01 <mantovani> ok
14:41:03 <ReinH> edwardk: would you use a more general type for rule :: Word8 -> (Move -> Bool) -> Bool
14:41:03 <mantovani> thanks
14:41:05 <FardadJalili> mantovani: pattern matching is actually a case expression
14:41:07 * hackagebot Nomyx 0.3.0 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.3.0 (CorentinDupont)
14:41:09 <Tekmo> No problem
14:41:09 * hackagebot Nomyx-Language 0.3.0 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.3.0 (CorentinDupont)
14:41:20 <FardadJalili> mantovani: It just has easier syntax when writing functions :)
14:41:30 <Tekmo> A lot of things in Haskell are just syntactic sugar for more primitive constructs
14:41:41 <FardadJalili> yeah
14:41:43 <FardadJalili> f x y = ..
14:41:46 <Tekmo> For example, when you define `f x = y`, you are really defining `f = \x -> y`
14:41:47 <FardadJalili> is syntax sugar itself
14:41:48 <FardadJalili> haha
14:41:50 <ReinH> oh duh, rule :: Word8 -> Rule move a
14:42:34 <Tekmo> Almost everything in Haskell can be done just using lambdas and case statements (and type classes)
14:42:50 <FardadJalili> Tekmo: I happened to be familiar with lambda expressions and combinatory logic, before I was familiar with Haskell. So those things weren't actually too strange for me
14:43:24 <haasn> Tekmo: (modulo DMR)
14:43:32 <Tekmo> What is DMR?
14:43:38 <haasn> Dreaded Monomorphism Restriction
14:43:42 <Tekmo> Oh yeah
14:43:45 <FardadJalili> Tekmo: I was just amazed that those ideas have been *implemented* and working
14:44:04 <FardadJalili> and are working*
14:44:57 <Tekmo> Yeah, it's really crazy when you think about it
14:45:36 <Tekmo> I really like the fact that Haskell such a small and orthogonal core
14:46:23 <LadyAurora> It's Core all the way down.
14:46:23 <mantovani> FardadJalili: for begin haskell is hard, because it is complete different than perl,c java etc.
14:46:52 <Tekmo> Yeah, it was hard for me, coming from a C background
14:47:29 <FardadJalili> mantovani: Theoretically there are two different views on computation. Haskell inherits from lambda expressions, while C java (and other imperative languages) inherit from Turing machines
14:47:51 <FardadJalili> That's why when you get used to one of them, it is hard to change your gears
14:47:54 <Zenol> but once you get used to it, going back to C/C++ is realy hard.
14:48:06 <Tekmo> The biggest shift is less reliance on state to do everything
14:48:21 <mantovani> FardadJalili: for me all was turing machines
14:48:21 <FardadJalili> Zenol: well you can actually write functional code in C
14:48:55 <Zenol> FardadJalili: Functional yes, but most of the nice thing well integrated in haskell (like monads) start to being really hard to reproduce in C.
14:48:55 <LadyAurora> Zenol: is it? I can switch between Haskell and imperative langs without problems.
14:49:08 <Zenol> And, also, having a GC helps you a bit :)
14:49:37 <FardadJalili> LadyAurora: if you leave imperative languages for let's say two years, it will be really hard to go back
14:49:46 <kaw> Hm, so would it be accurate to say that there are still a few gaps in Haskell support for high-level programming of native GUIs, it's not something that's extremely common and easy?
14:49:58 <Tekmo> That's more because of a lack of effort
14:49:58 <mantovani> FardadJalili: haskell is not turing machine ?
14:49:59 <FardadJalili> LadyAurora: I'm not in such situation, but I have seen such people
14:50:05 <Tekmo> GUI bindings take a lot of time to maintain
14:50:14 <mantovani> turing machine complete*
14:50:16 <Tekmo> It's a completely thankless job
14:50:17 <kaw> The haskell.org wiki does say that it's "experimental", but that's from 2006 and I wasn't sure it was still current
14:50:19 <FardadJalili> mantovani: Of course it is
14:50:33 <mantovani> FardadJalili: so, what you said confuse me.
14:50:44 <FardadJalili> mantovani: I'll try to clarify
14:50:45 <LadyAurora> FardadJalili: maybe, I don't know about others.
14:50:47 <mantovani> just because haskell use lambda to write math funcitons ?
14:50:53 <Tekmo> mantovani: Haskell is turing complete
14:51:02 <Tekmo> mantovani: He just means that it descends from a different school of thought
14:51:09 <Zenol> LadyAurora: It's not like I'm not able to write the same imperative code as before, it's that I feel sad doing so, and sad to have to debug.
14:51:10 <FardadJalili> in a turing machine you are always doing some set of things (statements) according to some state
14:51:15 <mantovani> oh ok
14:51:27 <FardadJalili> that's what coding in C is like
14:51:35 <LadyAurora> Zenol: oh, I see you point.
14:51:35 <FardadJalili> doing some statements according to some state
14:51:44 <LadyAurora> And agree.
14:52:17 <FardadJalili> mantovani: but there is something that is equal in power with turing machines, called lambda expressions
14:52:59 <FardadJalili> which is building up more complex computations on less complex computations using functions
14:53:06 <FardadJalili> mantovani: and that's what haskell is like
14:53:17 <FardadJalili> mantovani: I hope I didn't mislead you again
14:53:19 <FardadJalili> :)
14:53:36 <haasn> > rewrite (fmap ("bar"++) . stripPrefix "foo") "hello foo bat baz"
14:53:37 <lambdabot>   "hello bar bat baz"
14:53:39 <mantovani> now make sense :)
14:53:39 <haasn> lens is beautiful
14:53:40 <mantovani> haha
14:53:59 <fommil> so nobody has anything further to say about cross compiling to raspberry pi? :-(
14:54:16 <Kinnison> Is the trick not to native compile?
14:54:19 <FardadJalili> mantovani: lambda expressions are a really cool topic. but I guess you need some mathematical background before studying them
14:54:42 <Zenol> > rewrite (fmap ("bar"++) . stripPrefix "foo") "hello foouu bat baz
14:54:43 <Zenol> :p
14:54:43 <lambdabot>   <hint>:1:66:
14:54:43 <lambdabot>      lexical error in string/character literal at end of input
14:54:44 <lightquake> if I'm using cabal 0.18, is there any way to launch a repl that has all the sandboxed libraries without using cabal repl?
14:54:48 <edwardk> ReinH: you can use Int or even Integer
14:54:53 <edwardk> instead of Word8
14:55:08 <mantovani> lambda is a great example of turing complete
14:55:55 <Deix> hello, how that function similar to `mod' called? it should return everything mod returns but zero, for zero case it should return second arg like: 3 `f` 3 = 3
14:56:01 <fommil> Kinnison: I've heard of that approach using qemu. but it's not a great workflow
14:56:12 <Deix> if there isn't such function what the best way to define it?
14:56:17 <fommil> Kinnison: and compiling *on* the device? forget about it!
14:56:33 <Deix> or like 6 `f` 3 = 3
14:56:35 <haasn> > lastOf (splittingOn "." folded) "foo.bar.bat.txt"
14:56:37 <lambdabot>   Just "txt"
14:57:01 <Tekmo> Deix: You can build that function from `mod`
14:57:32 <Deix> Tekmo: Yeah, but can you suggest clever way to do so without using if?
14:57:40 <haasn> case :)
14:57:47 <Deix> with math possibly
14:57:51 <haasn> f x y = case mod x y of 0 -> y; z -> z
14:58:12 <Tekmo> > let mod' x n = ((x - n) `mod` n) + n
14:58:13 <lambdabot>   not an expression: `let mod' x n = ((x - n) `mod` n) + n'
14:58:16 <FardadJalili> > rem 6 3
14:58:17 <lambdabot>   0
14:58:48 <shachaf> > (last . splitOn ".") "foo.bar.bat.txt"
14:58:49 <lambdabot>   "txt"
14:58:54 <shachaf> Sadly last is partial.
14:59:23 <Tekmo> Then use lastMay
14:59:35 <Rarrikin1> > let f a b = mod (a - 1) b + 1 in map (`f` 3) [0..10]
14:59:36 <lambdabot>   [3,1,2,3,1,2,3,1,2,3,1]
14:59:40 <Kinnison> fommil: Once again, my opinion of raspi drops
14:59:42 <Kinnison> :-(
15:00:11 <Deix> Rarrikin1: thats great, thank you!
15:00:16 <Rarrikin1> No problem
15:00:43 <fommil> Kinnison: why? it's a fantastic little device for the price! and at least it *registers* on performance benchmarks, e.g. https://github.com/fommil/netlib-java/ now given the fact that its 10 times slower than devices that are 100 times more expensive, I say win.
15:01:20 <FardadJalili> > let f a b  = mod a b + b - (mod a b) * b in map (`f` 3) [0..10]
15:01:21 <lambdabot>   [3,1,-1,3,1,-1,3,1,-1,3,1]
15:01:28 <FardadJalili> huh
15:01:40 <FardadJalili> oops
15:01:41 <ReinH> edwardk: https://gist.github.com/reinh/e1b2f0388bc53698cd0b
15:01:47 <fommil> Kinnison: I think it's an incredible target for Haskell. Haskell could win a lot of ground in the Embedded space, where JVMs are quite high overhead
15:03:27 <LadyAurora> GHC runtime is not exactly lightweight either.
15:03:56 <Kinnison> indeed
15:04:06 <edwardk> ReinH: nice
15:04:57 <hilo> hi all, is this a good place to ask cabal questions? specifically, I am having some issues installing certain packages on Mac OSX. getting an error that says "cannot satisfy -package-id publicsuffixlist-0.1-..."
15:05:08 <ReinH> edwardk: mtopo gives a z mod m topology ofc
15:05:18 <LadyAurora> hilo: yes
15:05:25 <Tekmo> hilo: Can you paste the full error using lpaste.net?
15:05:36 <edwardk> ReinH: yep
15:05:36 <hilo> Tekmo: sure
15:05:55 <fommil> LadyAurora: will it fit into 512MB?
15:05:55 <ReinH> edwardk: and I did a little manual loop fusion to clean up the printer
15:06:08 * hackagebot NXTDSL 0.3 - Generate NXC Code from DSL  http://hackage.haskell.org/package/NXTDSL-0.3 (AlexanderThiemann)
15:06:47 <LadyAurora> fommil: no way, it needs 5120 PB.
15:06:56 <fommil> LadyAurora: :-P
15:07:06 <Tekmo> fommil: Yes, of course
15:07:22 <fommil> Tekmo: i was being sarcastic ;-)
15:07:31 <Tekmo> :)
15:08:07 <fommil> Tekmo: LadyAurora the haskell RT is surely not all that much
15:08:17 <fommil> I'd like to see it compared to the JVM
15:08:20 <Tekmo> Yes, it will fit just fine
15:08:29 <Tekmo> Most of the programs I write fit in 1-2 MB of memory
15:08:38 <fommil> some nice benchmarks, C vs Haskell vs Scala
15:09:13 <ReinH> rule 30 becomes extremely chaotic on a ring topology
15:09:13 <LadyAurora> fommil: it depends on what kind of "embedded" we're talking about.
15:09:20 <fommil> LadyAurora: raspberrypi
15:09:20 <ReinH> after it starts to cycle around all semblance of a pattern is lost
15:09:29 <ReinH> edwardk: ^
15:09:41 <ReinH> (of an apparent pattern)
15:10:27 <fommil> LadyAurora: Tekmo I'm planning on writing a CCTV monitor for the rpi in haskell (I'll eventually OSS). I'm currently calling it HALkell (as in 2001)
15:10:46 <Tekmo> Nice :)
15:10:58 <fommil> if anyone is interested in helping, I'll add them to the github. I just don't like OSSing until I actually have something
15:11:10 <fommil> (well, technically it's still OSS, just not "public")
15:11:53 <Zenol> If you are interested in embeded, look the video here : http://ajhc.metasepi.org/ (Yes, it's not GHC, but it's still haskell) :)
15:12:05 <Zenol> s/embeded/haskell embeded
15:12:21 <fommil> Zenol: yuck
15:12:28 <fommil> it converts it into C???
15:12:37 <edwardk> ReinH: oh?
15:12:49 <fommil> that sounds awful. LLVM is a much better layer to do this sort of thing
15:13:07 <Tekmo> fommil: GHC does have an LLVM backend
15:13:32 <LadyAurora> fommil: to me Raspberry Pi is just an underpowered PC. When I hear "embedded" I usually think more along the lines of "8-bit CPU (AVR?) and several KB of memory".
15:13:37 <fommil> Tekmo: yes, I know… so I don't understand why this person put all their eftort into a C convertor instead of just helping out with the LLVM layer
15:13:55 <hilo> Tekmo: here's the lpaste link, http://lpaste.net/92377
15:14:02 <fommil> LadyAurora: yeah, that's probably technically correct
15:14:08 <ReinH> edwardk: well, this is not rigorous, but the pattern running down the left edge is lost once it the right edge reaches it
15:14:09 <Zenol> one good thing with C is, for some devices, you have only a C compiler, and no llvm backend.
15:14:18 <edwardk> makes sense
15:14:37 <Tekmo> hilo: What is the output of `ghc-pkg list | grep text`?
15:14:39 <fommil> but LLVM can produce assembly
15:14:43 <ReinH> I'm adding Yesod back now for SoC
15:14:45 <edwardk> now you need to play with weird topologies where you have a side that acts like a mirror ;)
15:14:48 <ReinH> SoH
15:14:55 <fommil> for pretty much every chip known to man
15:15:24 <hilo> WARNING: there are broken packages.  Run 'ghc-pkg check' for more details. text-0.11.3.1 css-text-0.1.1 shakespeare-text-1.0.0.5 text-0.11.3.1
15:15:38 <edwardk> hat starts to require your 's' have a state and a heading though
15:16:12 <Tekmo> hilo: I think the problem is that you have `text-0.11.3.1` installed twice
15:16:16 <fommil> LadyAurora: for *that* kind of 8bit embedded… even C is too heavy ;-P
15:16:36 <Zenol> fommil: It seams that adding a llvm backend to ghc isn't "so easy".
15:16:49 <ReinH> edwardk: weird, I'm getting a type error with diagrams. Did renderSvg change to renderSVG at some point... AND change its type signature?
15:16:51 <fommil> Zenol: that does appear to be the bottleneck
15:16:55 <hilo> Tekmo: should I ghc-pkg unregister and then delete one version from my .cabal dir?
15:17:04 <Zenol> fommil: And I though that many backend was missing (for small chips like avr)
15:17:05 <fommil> Zenol: I thought that *was* the backend? Are there others?
15:17:06 <edwardk> two different functions
15:17:13 <Tekmo> hilo: Try it
15:17:18 <edwardk> the one i'm using is in blaze-svg
15:17:24 <Zenol> fommil: One backend by assembly / chip family.
15:17:28 <Tekmo> hilo: One question: did you install the Haskell platform first?
15:17:29 <ReinH> oh I dropped my Text.Blaze.Svg.Renderer.Utf8 import
15:17:35 <edwardk> check the top of the file for my imports
15:17:39 <edwardk> yeah
15:17:40 <ReinH> yep got it now :)
15:17:41 <fommil> but in any case, I was really asking about cross-compiling, because I think it works on device (or emulator)
15:17:42 <edwardk> thats the bug
15:18:04 <lightquake> I just pulled down the latest haskell-mode, and it's syntax highlighting everything in the repl buffer, even the error messages
15:18:09 <lightquake> is there any way to make it not do that?
15:18:10 <hilo> Tekmo: I might have just install ghc without the Haskell platform...it's been a while since I did all that
15:18:31 <fommil> I use crosstool-ng for C/fortran etc, which sets up the gcc and eglibc universe needed to cross-compile properly
15:18:47 <lightquake> oh, huh, restarting it fixed it
15:18:54 <Zenol> fommil: Cross compiling with ghc is a bit harder than using gcc :(
15:18:54 <Tekmo> hilo: I highly recomend installing the Haskell platform to minimize dependency problems
15:19:00 <Tekmo> hilo: However, there's an easy fix
15:19:23 <Tekmo> hilo: In this case you can either keep unregistering packages until you get a clean install or reset your local package database
15:19:24 <fommil> Zenol: I expect so. but ultimately it is a compiler and linker, right?
15:19:36 <Zenol> fommil: First, you need one cross compiler for each arch you are targetting.
15:19:39 <ReinH> edwardk: oh my god, Edward, it is glorious
15:19:49 <fommil> Zenol: one target… just the raspberrypi
15:19:58 <edwardk> ReinH: heh pretty pictures?
15:20:06 <hilo> Tekmo: I just checked my installed ports, I do have the haskell platform (haskell-platform @2013.2.0.0_0 (active))
15:20:08 <Zenol> fommil: Futhermore, it's a stage 1 compiler, so you can't compiler haskell template (if I understoud the doc)
15:20:25 <Zenol> fommil: And you'll have to compile it yourself from the sources.
15:20:26 <Tekmo> hilo: Then try unregistering the locally installed `text` package
15:20:46 <Tekmo> hilo: You probably have two versions installed: one in your global package database (from the Haskell platform) and one in your local package database
15:21:03 <Zenol> fommil: Thats probably why many peaples prefer using qemu and a stage 2 compiler instead of a cross compiler.
15:21:33 <Zenol> *peoples
15:21:41 <Kinnison> With all the new changes to the build system to support cross compilation, the bootstrap-from-C stuff has broke
15:21:46 <Kinnison> which is really annoying for me
15:21:52 <fommil> Zenol: compiling myself is fine (I'm sure ubuntu etc will take care of that one day)… I don't know haskell well enough to know what you mean by templates
15:22:31 <Zenol> fommil: Generating functions, data type, etc, writing haskell code.
15:22:31 <ReinH> edwardk: btw would switching endianness on the rule bitmappy thing fix the currently flipped productions? R is currently L.
15:22:36 <hilo> Tekmo: ok, using ghc-pkg unregister I've removed one text package. when I ghc-pkg list | grep text, I now see only one text package installed
15:22:41 <Zenol> fommil: I you don't need it, don't use it :)
15:22:48 <edwardk> it would but then it can't fold Integer
15:22:51 <Tekmo> hilo: See what happens if you do `cabal install` now
15:22:54 <ReinH> edwardk: ah
15:23:10 <edwardk> we took the definition that has the right continuous extension to the infinite case
15:23:18 <ReinH> edwardk: I can compensate but it's non obvious... of course it's also not obvious that there must be a particular ordering
15:25:31 <ReinH> edwardk: also when I said rule 110 I meant rule 30
15:25:34 <ReinH> rule 30 is the chaotic one
15:25:39 <hilo> Tekmo: that solved my original problem, now I've got to work through a few others but knowing to check ghc-pkg list is a big help, thanks!
15:26:00 <fylwind> is there a way to make a function 'show' its argument if it's Show, but just return a default string if it's not Show?
15:26:06 <sipa> ReinH: you were using base 5?
15:26:08 * hackagebot NXTDSL 0.4 - Generate NXC Code from DSL  http://hackage.haskell.org/package/NXTDSL-0.4 (AlexanderThiemann)
15:26:09 <Tekmo> hilo: You're welcome!
15:26:57 <ReinH> edwardk: and actually I'm totally wrong, it's still patterned
15:26:59 <Tekmo> fylwind: Not really
15:27:06 <ReinH> sipa: for which?
15:27:22 <sipa> ReinH: 110 in base5 == 30 in base10
15:27:47 <ReinH> sipa: oh right... no, just a mistake :)
15:28:21 <fylwind> Tekmo: okay, thanks
15:28:31 <hilo> Tekmo: in case you're feeling generous, check out this new error, http://lpaste.net/92380 seems to have to do with an assertion in a library--what's your usual approach to solving this sort of issue?
15:29:16 <hilo> Tekmo: oh, nvm, looks like I'm missing a lib!
15:30:50 <Zenol> good night
15:31:02 <augur> copumpkin: http://www.reddit.com/r/programming/comments/1lgjjn/idempotence_in_math_and_computing/cbz9cfs
15:31:34 <ReinH> edwardk: what is the simplest image format I could generate for the web?
15:31:48 <edwardk> the svg thing so far
15:31:58 <ReinH> svg is not super efficient for large numbers of small things :(
15:32:04 <ReinH> did the canvas backend ever become a thing?
15:32:10 <edwardk> i asked for diagrams-cairo support
15:32:14 <edwardk> it should be coming soon
15:32:19 <ReinH> oh on SoH
15:32:22 <edwardk> also i put in an issue asking for repa-devil
15:32:31 <edwardk> that would give us png
15:34:08 <ReinH> edwardk: pbm would be trivial to generate but browsers don't read it :/
15:35:18 <haasn> edwardk: oh, that reminds me; is there a way to have something like repa-devil but in realtime? ie. for displaying in a gtk window
15:35:34 <haasn> I want to make some animations and possibly control them with user input
15:35:38 <haasn> but I want to do the rendering with repa
15:35:56 <haasn> oh
15:36:02 <haasn> there's gloss-raster which uses repa, neat
15:36:12 <hilo> Tekmo: If I'm logged in as a certain user and avoid using sudo, don't all my cabal packages get installed locally? I am just trying to figure out how to avoid installing the same package multiple times in the future.
15:40:39 <applicative> oh is Tekmo here? Howdy!
15:42:51 <LadyAurora> G'night.
15:43:12 <applicative> goodnight LadyAurora !
15:46:05 <ReinH> edwardk: ok, do you want me to write this up?
15:46:50 <edwardk> either you can or i will
15:46:55 <edwardk> but i think it should go on the site
15:47:30 <edwardk> for now the svg is the best rendering format supported
15:49:01 <ReinH> edwardk: ok, cool, I'm going to take a break and then I'll write it up.
15:49:06 <ReinH> my brain needs to decompress
15:49:10 <edwardk> kk
15:49:11 <ReinH> edwardk: but look! https://dl.dropboxusercontent.com/u/632742/rule-110.png
15:49:15 <edwardk> happy to squeeze
15:49:45 <ReinH> pbm file is 1.8MB, png is 10KB :D
15:49:55 <ReinH> but PBM is MUCH easier to generate :p
15:50:14 <edwardk> ReinH: clearly we should just write the gif writer
15:50:19 <ReinH> we really should
15:50:28 <ReinH> only reason it doesn't exist is the patent we would be violating :)
15:50:55 <edwardk> bah the user'd be violating it by running the code ;)
15:50:59 <edwardk> not us =P
15:51:01 <ReinH> haha
15:51:04 <ReinH> maybe.
15:51:16 <ReinH> that is a risk I am willing to take on their behalf ;)
15:51:36 <Tekmo> hilo: Oh, sorry for the late reply.  Yes, if you don't use `sudo` then they go to your local package database
15:51:55 <edwardk> ReinH: let me think about nice output formats for a bit
15:52:03 <ReinH> {{{kk
15:52:05 <ReinH> er. kk
15:52:37 <ReinH> of only browsers could display pbm
15:52:40 <ReinH> *if
15:52:52 <Tekmo> applicative: Hi!
15:53:30 <ReinH> applicative: hi :)
15:54:17 <applicative> ohai comrades
15:54:19 <shachaf> ReinH: GIF patents are expired.
15:54:28 <S_J> is there a name for something like: k * f(k-1) == f(k) ?
15:54:45 <Tekmo> S_J: A factorial?
15:54:59 <byorgey> a recurrence?
15:55:01 <ReinH> shachaf: orly
15:55:06 <ReinH> alrighty then
15:55:09 <edwardk> ReinH: could always just render a web page with divs for each cell
15:55:15 <edwardk> styled for color
15:55:23 <ReinH> edwardk: uh... how is that even slightly better than svg? :p
15:55:30 <edwardk> way way faster
15:55:40 <edwardk> the svg gets a whole matrix per element
15:55:43 <ReinH> or we could just render ' ' and 'x' in a really small font
15:55:43 <edwardk> that is what slows us down
15:55:44 <ReinH> :p
15:55:47 <edwardk> okay
15:55:48 <edwardk> =)
15:56:19 <ReinH> pre.super-small { font-size: 1px }
15:56:21 <ReinH> DONE :p
15:56:45 <edwardk> ReinH: http://mainisusuallyafunction.blogspot.com/2012/04/minimal-encoder-for-uncompressed-pngs.html
15:56:49 <ReinH> there is unicode for an entirely full glyph right? or something close?
15:56:52 <eyebloom> Anyone interested in fielding a question about the difference between a let statement and a lambda abstraction
15:56:54 <applicative> hilo, sudo is independent of where cabal puts things; if you want to install globally there is cabal install --global
15:56:58 <ReinH> edwardk: seriously, try really small text
15:57:00 <ReinH> I bet it will be fine
15:57:12 <applicative> hilo: which will likely require sudo and so on
15:57:26 <edwardk> ReinH: i'd be willing to write the png writer based on that and put the whole thing into a post
15:57:42 <ReinH> edwardk: ok! Your exposition would probably be much better than mine
15:57:54 <edwardk> ship me the code you have
15:58:26 <applicative> Tekmo: I was just trying to rewrite this DirStream module with the straightforward 'ListT done right' sort of type
15:58:37 <ReinH> edwardk: https://gist.github.com/reinh/611d4f32458c9bd99013
15:58:38 <ReinH> done
15:59:07 <Tekmo> applicative: You mean using the non-`pipes` version of `ListT`?
15:59:27 <S_J> > let f g x = g f x in f (\a b -> b + 1) 10
15:59:28 <lambdabot>   Occurs check: cannot construct the infinite type:
15:59:28 <lambdabot>    t1 = (t1 -> t2 -> t0) ...
15:59:35 <applicative> yeah, i just wrote one myself, for another reason, so I was using this as a demo program
15:59:57 <S_J> > let f g x = g f x in f (\_ b -> b + 1) 10
15:59:58 <lambdabot>   Occurs check: cannot construct the infinite type:
15:59:58 <lambdabot>    t1 = (t1 -> t2 -> t0) ...
16:00:03 <Tekmo> Are you consulting the `dirstream` I have on Github?
16:00:06 <S_J> why is thta infitnite?
16:00:56 <S_J> > let f g x = g (f,x) in f (\(a,b) -> b + 1) 10
16:00:57 <lambdabot>   Occurs check: cannot construct the infinite type:
16:00:57 <lambdabot>    t1 = ((t1, t2) -> t0) ...
16:01:05 <applicative> there is some subtlety by the way, at least on os x, if I do your "descendentsOf "/"" i get breakage at /dev/fd though this may be a bug in the Posixy libraries
16:01:21 <S_J> > let f g x = g x in f (\b -> b + 1) 10
16:01:22 <lambdabot>   11
16:01:35 <applicative> Tekmo: yes I was consulting the dirstream on github which is a very pleasing program
16:02:04 <ReinH> edwardk: I particularly like how we got step for free
16:02:06 <applicative> is there a dev and a /dev/fd on linux systems?
16:02:13 <edwardk> yeah
16:02:15 <ReinH> edwardk: is there some deep reason why we were able to get it for free?
16:02:24 <Tekmo> applicative: Most of the code there is `pipes`-agnostic so it's definitely do-able
16:02:27 <edwardk> that djinn was able to deriv it for us?
16:02:31 <ReinH> right
16:02:38 <Tekmo> applicative: You just need to integrate the new code with `pipes-safe`
16:02:40 <edwardk> because with the types split the free theorem was enough to make its definition unique
16:02:50 <ReinH> edwardk: winning
16:02:57 <edwardk> i'll likely include the djinn derivation of it because it shows off the sexiness of haskell tools
16:03:11 <applicative> Tekmo yes, I have done it by now. right, i tore out the pipes safe aspect; i have to think how to link the vanilla listt with it
16:03:17 <ReinH> edwardk: I need to read Wadler again, don't I?
16:03:23 <edwardk> yes =)
16:03:26 <ReinH> :D
16:03:31 <ReinH> edwardk: ok, ttfn
16:03:34 <mel-> hi
16:03:42 <ReinH> brain is becoming critically overheated :)
16:04:12 <leroux> What does `go` mean in functions? I've seen it used alot, but never understood why it's called `go`.
16:04:26 <applicative> ReinH: we all always need to read Wadler again, don't we?
16:04:28 <ReinH> leroux: it's just a generic name
16:04:34 <ReinH> leroux: like do_the_thing
16:04:35 <Iceland_jack> leroux: Just a name for local functions
16:04:38 <ReinH> but shorter
16:04:41 <leroux> Ahh, okay.
16:04:53 <mel-> in my gui application, i quiet often write code like this: if someCondition then doSomeIO else return (). is there a shorter version of writing this? i.e., doSomeIO only if someCondition is True -- without the need to add this 'return ()' all the time?
16:04:55 <leroux> I tend to use func and func' (as the helper).
16:05:01 <ReinH> applicative: I'm pretty sure that's a free theorem, yes
16:05:19 <leroux> mel-: when?
16:05:22 <Tekmo> mel-: Use the `when` function
16:05:23 <leroux> :t when
16:05:24 <lambdabot> Monad m => Bool -> m () -> m ()
16:05:28 <Tekmo> when someCondition doSomeIO
16:05:36 <mel-> thanks!
16:05:39 <Tekmo> It's from `Control.Monad`
16:05:44 <ReinH> edwardk: is that paper properly called the free theorem theory?
16:05:46 <Tekmo> There is also the opposite function: `unless`
16:05:47 <ReinH> because it should be
16:06:22 <edwardk> ReinH: http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
16:06:42 <ReinH> edwardk: I have it open right now? :)
16:06:45 <ReinH> It was just a poor joke
16:06:49 <ReinH> I ean
16:06:54 <ReinH> I mean... I have it open right now!
16:07:00 <ReinH> that was not a question
16:07:59 <ReinH> Tekmo: I sort of which `when` and `unless` were flipped so I could write: fireTheMissiles `unless` amNapping
16:08:06 <ReinH> *wish
16:08:09 <ReinH> what is wrong with my brain today
16:08:27 <Iceland_jack> ReinH: Gah, that wouldn't be nice for long ‘fireTheMissles’
16:08:43 <ReinH> Iceland_jack: that is true
16:09:11 <ReinH> `unless cond $ do` is quite nice.
16:09:31 <Iceland_jack> I dunno, I'd prefer: ‘unless cond:’
16:09:34 <Tekmo> ReinH: Live the dream and define it your way! :)
16:09:38 <ReinH> Iceland_jack: that's why I only sort of want that :)
16:09:43 <Iceland_jack> ;)
16:10:03 <ReinH> Iceland_jack: wait, 'unless cond:' ?
16:10:16 <ReinH> oh you're suggesting a suger
16:10:23 <ReinH> for the sugar
16:10:26 <Iceland_jack> Yeah, similar to what you can define in Idris
16:10:34 <ReinH> yep
16:11:06 <ReinH> that way it's almost indistinguishable from imperative syntax :D
16:11:14 <Iceland_jack> I mean (foo $ \s → …) and (foo $ do …) is nice and all, but once your actions get more complicated it's becomes less legible than imperative code in my humble opinion
16:11:37 <Iceland_jack> *it becomes
16:11:40 <ReinH> Iceland_jack: which is also a good reason to start factoring :)
16:11:44 <Iceland_jack> Possibly
16:11:54 <ReinH> sometimes
16:12:17 <Iceland_jack> I'm rather talking about the general syntax of it, rather than the structure of the action itself
16:12:22 <Iceland_jack> -rather
16:12:37 <leroux> Iceland_jack: Are you typing these unicode characters or do you something setup to do it for you?
16:12:47 <ReinH> edwardk: so a fun thing you can do with automata diagrams printed to a terminal is interactively resize the terminal and watch them wrap in interesting ways
16:13:11 <ReinH> edwardk: sometimes it looks like they are rotating. There has to be a way to expess that.
16:13:34 <Iceland_jack> leroux: I define them in my .XCompose file
16:14:38 <Iceland_jack> Which allows me to write horrible Haskell code like: (z₀ = y₀ ⊕ ((z₃ ⊞ z₂) <<< 18)) ;)
16:14:39 <scshunt> edwardk: the more I think about your objections to MLens, the more I disagree
16:15:30 <shachaf> scshunt: Make sure to stop thinking about it once your agreement level reaches 0.
16:15:33 <scshunt> edwardk: Yes, the underlying monad can cause violation of the laws. But most monads won't, and the cases where they will, it is still useful even if you don't have quite the same guarantees
16:15:33 <shachaf> Otherwise it could be dangerous.
16:16:15 <ReinH> Iceland_jack: I guess you really want your Haskell to look like APL? :)
16:16:24 <Iceland_jack> That doesn't look very similar to APL at all!
16:16:40 <ReinH> Iceland_jack: it uses unicode to express operators. Close enough :p
16:17:04 <Iceland_jack> So anything that uses unicode-specific operators is similar to APL?
16:17:07 <Iceland_jack> ts
16:17:16 <ReinH> Iceland_jack: for the purposes of my completely flippant remark? yes :)
16:17:22 <applicative> the apl would be eg. ₀ ⊕ ⊞ <<< 18
16:17:39 <tikhon> it would have an ω in there too
16:17:56 <tikhon> but yeah, we must be liberated from the tyranny of ASCII
16:18:06 <applicative> people always make fun of it, but it seems kind of cool, apl
16:18:12 <ReinH> tikhon: that is (not) what J is for!
16:18:18 <ReinH> applicative: APL is fascinating
16:18:18 <tikhon> which is a phrase I blatantly stole from some blog post
16:18:23 <applicative> once i tried the J machinery, never apl
16:18:33 <tikhon> I actually used J a bit but did not really like it
16:18:36 <ReinH> I love the video on GoL with APL on the youtubes
16:18:50 <leroux> Iceland_jack: What XCompose key do you use?
16:19:51 <ReinH> leroux: not sure but there's https://github.com/kragen/xcompose
16:20:43 <Iceland_jack> leroux: The menu key
16:21:52 <applicative> Tekmo: it occured to me that Data.Vector.Fusion.Stream.Monadic is actually the stream-fusiony variant of 'ListT done right' so I was fiddling a little from that point of view
16:22:01 <tikhon> Iceland_jack: hey, that's pretty brilliant—I never actually use that key. But it seems like it might be difficult to type.
16:22:35 <ReinH> Ooh I finally found instructions for porting XCompose to OS X :D :D http://superuser.com/questions/202695/real-compose-key-on-mac-os
16:22:45 <Iceland_jack> It's actually quite OK to type, it's pain that reminds me of the luxury I have of being able to use proper unicode characters
16:23:07 <tikhon> it probably also depends on your keyboard
16:23:22 <tikhon> on my laptop, I think it would be too annoying for widespread use
16:23:30 <croyd> join
16:23:34 <leroux> ReinH: Thanks! I'm on OS X.
16:23:48 <i_am_neuron> Hi folks, now building ghc-ios as described at http://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling/iOS and got this (error and source code at the offending line): http://lpaste.net/92381. Any idea what's wrong?
16:23:51 <Ghoul_> I wonder what people think of using unicode in haskell
16:23:59 <tikhon> Ghoul_: I'm all for it
16:24:04 <Ghoul_> is it a 'scary thing' that breaks everyones editors
16:24:08 <tikhon> if it makes the code look better
16:24:11 <tikhon> no
16:24:15 <tikhon> it only breaks bad editors
16:24:15 <Iceland_jack> Ghoul_: It's more about people not being able to input them
16:24:16 <Ghoul_> or are people refreshed to see methametical symbols in calculations
16:24:17 <applicative> oh my God, i_am_neuron I wonder if knowledgeable people hang out in #ghc?
16:24:24 <tikhon> but I refuse to acknowledge people using anything less capable than Emacs
16:24:25 <applicative> or can be found there
16:24:26 <Ghoul_> *math
16:24:40 <Ghoul_> what the hell, I swapped the e and the a. It's too early for me...
16:24:44 <Iceland_jack> I go unicode mad in Agda and personal Haskell modules, for anything public I use normal ASCII values
16:24:46 <tikhon> ie people using ¬Emacs
16:24:48 <ReinH> Ghoul_: I use vim's new conceal feature to replace some normal Haskell syntax with unicode
16:25:05 <shachaf> applicative: There's no need to be so rude about it.
16:25:13 <leroux> ReinH: I find that a problem cause it messes up my indents.
16:25:29 <tikhon> It's the 21st century, and we're still worried about tools not supporting Unicode! It's absurd.
16:25:35 <mstksg> yeah conceals were nice but something about me likes seeing those text arrows
16:25:43 <applicative> oh, was i being rude, I meant it differently than it seemed then
16:25:45 <mstksg> i feel more leet hacks.
16:25:45 <Iceland_jack> tikhon: It's not about supporting unicode…
16:25:46 <tikhon> besides, I think x₁ is *much* better than x1 or x_1 :D
16:25:51 <Iceland_jack> The only exception I've made for this is when collaborating with friends on Haskell code where I used subscripts: bar (Foo m₁ m₂) = …
16:26:01 <applicative> oh wait though i_am_neuron , this is the CPP problem!
16:26:04 <Ghoul_> Ooh subscripts
16:26:07 <Ghoul_> those look amazing
16:26:09 <tikhon> and I can't not use Greek letters once in a while
16:26:16 <mstksg> oh my goodness that might change my life.
16:26:25 <shachaf> tikhon: x₁ doesn't scale. I care about non-numeric subscripts.
16:26:27 <mikeplus32> leroux: depends on what things you conceal, e.g. ::, -> and => all are 2 chars long, so it doesn't mess up indentation
16:26:30 <tikhon> If I would say "alpha" aloud, I want to write α
16:26:30 <i_am_neuron> applicative: Really?
16:26:47 <roboguy_> it seems really ridiculous to me if someone does something like use alphas instead of as in type variables. I don't know, seems pointless and overcomplicated
16:26:49 <Iceland_jack> ∶, ∷, →, ⇒ are great on personal projects :)
16:26:50 <shachaf> mikeplus32: Uh oh, what happened to your bits?
16:26:52 <Ghoul_> do subscripts work in types?
16:26:54 <ReinH> mikeplus32: I also conceal things like: or = λx y → x ∨ y
16:26:56 <i_am_neuron> applicative: Looks like Haskell code to me :)
16:26:58 <applicative> i_am_neuron yes, I'm totally not expert about it, but I think its that the cpp you are getting when ghc calls for it, is the clang one
16:27:00 <Tekmo> roboguy_: I agree.
16:27:00 <roboguy_> *as type variables
16:27:04 <tikhon> Ghoul_: they should, yes
16:27:10 <ReinH> I can also turn it on or off as I need to
16:27:17 <leroux> mikeplus32: the arrows and stuff are one-char long for me.
16:27:18 <tikhon> How is it overcomplicated?
16:27:22 <leroux> Not sure why...
16:27:31 <applicative> i_am_neuron: the error is from clang as you can see from the de-luxe error i_am_neuron
16:27:34 <roboguy_> tikhon: it's not ascii for one thing. also it's harder to type
16:27:48 <mstksg> one problem i have with unicode is that the terminal font i use doesn't have all of them necessarily
16:27:49 <tikhon> It shouldn't be any harder to type than "alpha"
16:27:55 <Tekmo> tikhon: 'a' is easier
16:27:55 <mikeplus32> ReinH: yeah me too (haskell-mode is pretty neat :))
16:27:57 <mstksg> but i think that's something i could fix given the effort
16:27:57 <Ghoul_> is there a 'conceal' for sublime-text?
16:27:59 <roboguy_> tikhon: no, I mean an actual alpha
16:28:09 <roboguy_> not the word alpha
16:28:15 <tikhon> roboguy_: that's my point: α and alpha should take a similar amount of effort to type
16:28:26 <Iceland_jack> tikhon: Because there is no benefit to it and it only makes it harder for others to contribute and use?
16:28:27 <roboguy_> tikhon: I'm saying: why not "a" like everyone else?
16:28:29 <shachaf> Ctrl-Shift-U 3 B 1 <space>
16:28:33 <tikhon> Tekmo: a and α are different, and a is likely to be mistaken for a type variable
16:28:37 <shachaf> Seems like about the same amount of effort to me.
16:28:45 <mikeplus32> shachaf: just rolls off the tongue
16:28:53 <tikhon> whereas α is very well defined in context
16:29:01 <Tekmo> tikhon: alpha is meaningless to me
16:29:01 <tikhon> (like in AI algorithms, for example)
16:29:10 <shachaf> Clearly you should just write 'a.
16:29:12 <i_am_neuron> applicative: Yeah, you might be right. I checked the output and there are some warnings indicated as suppressable by -Winvalid-pp-token, which looks like cpp to me. Thanks anyway, I'll shoot this question to #ghc
16:29:17 <Tekmo> tikhon: I agree with using unicode for that purpose
16:29:22 <Tekmo> tikhon: I've done this for trig in Haskell
16:29:25 <roboguy_> what I mean is if someone does something like "pure :: α -> f α" instead of "pure :: a -> f a"
16:29:43 <tikhon> oh yeah, for type variables, a makes more sense
16:30:07 <Tekmo> Bas van Dikj is the worst offender in this regard
16:30:10 <Tekmo> *Dijk
16:30:20 <roboguy_> shachaf: that's five times more keys than "a"
16:30:21 <tikhon> I only use α for type variables in pseudocode
16:30:32 <mikeplus32> opacity :: Fractional α => α -> IO ()
16:30:41 <shachaf> type Setter s σ a α = (a -> f α) -> s -> σ
16:30:48 <roboguy_> shachaf: or 7, actually
16:30:48 <shachaf> Easy!
16:30:55 <Tekmo> shachaf: That's worse
16:31:09 <Tekmo> shachaf: The a and alpha are good
16:31:14 <Tekmo> shachaf: But not s and sigma
16:31:42 <Tekmo> shachaf: Maybe t and tau?
16:31:48 <shachaf> Now let's try (ν -> v) -> (ο -> o)
16:31:56 <shachaf> (One of those is an omicron.)
16:32:06 <Tekmo> You know, ASCII is under-rated
16:32:24 <shachaf> ASCII is over-rated. No one should use ASCII these days.
16:32:34 <shachaf> But restricting yourself to the first 128 codepoints of Unicode isn't so bad.
16:32:44 <Iceland_jack> shachaf: I'm pretty sure that's what Tekmo meant
16:32:46 <roboguy_> shachaf: wow that's confusing
16:33:17 <Iceland_jack> Then I look at type signatures like:
16:33:17 <Iceland_jack>     :: ((forall β. IO β -> IO β) -> IO α) -> IO (ThreadId, IO (Result α))
16:33:17 <Iceland_jack> and wonder why Haskell isn't mainstream yet ;)
16:33:28 <scshunt> edwardk: the more I think about your objections to MLens, the more I disagree
16:33:36 <applicative> unicode itself is a menace; i use babel in latex
16:33:36 <scshunt> edwardk: Yes, the underlying monad can cause violation of the laws. But most monads won't, and the cases where they will, it is still useful even if you don't have quite the same guarantees
16:33:41 <shachaf> Yay, rank-3 types.
16:34:16 <applicative> ancient greek can be typeset just fine; bit I think it is a theorem that it cant be unicoded
16:34:32 <tikhon> ooh, another place I think ASCII really shines: compare forall and ∀
16:34:45 <Tekmo> The way I see it, getting Haskell to compile to Javascript is much more pressing than getting full Unicode support
16:34:47 <tikhon> right now, I just have my editor render "forall" as ∀
16:34:47 <shachaf> tikhon: You mean doesn't shine?
16:34:48 <applicative> so we get beer muchs but wrong greek diacritics; the curse of plan 9
16:34:51 <scshunt> applicative: what, why can't it be put in unicode?
16:35:03 <tikhon> shachaf: I don't know, I find the ∀ much easier to read
16:35:13 <shachaf> tikhon: Right. Hence the ASCII not shining.
16:35:23 <shachaf> Unless shining is a bad thing, I guess?
16:35:26 <tikhon> beer muchs?
16:35:34 <FardadJalili> tikhon: what about 'bottom' :@
16:35:38 <tikhon> oh, I meant Unicode, not ASCII :P
16:35:42 <applicative> scshunt: i guess you could make a letter for each syllable sort of like an east asian language
16:35:50 <tikhon> FardadJalili: I also render undefined as ⊥
16:35:57 <tikhon> it's actually a standard option in Haskell mode to do that
16:36:08 <applicative> but unicode is basically ascii imperialism thinking everything is like itself
16:36:09 <tikhon> (although I have a few additional symbols of my own)
16:36:10 <Iceland_jack> (maybe #haskell-blah?)
16:36:38 <shachaf> Anyway, I like ∀. I handwrite it. But I don't think it's worth the cost in an existing language like Haskell, and it has a high barrier to entry in existing editors etc.
16:36:40 <Tekmo> Another pet peeve of mine: Haskell papers that don't use fixed width fonts for code
16:36:51 <shachaf> And also I doubt this conversation will get anywhere it hasn't gotten to before. :-)
16:37:23 <tikhon> well, it might finally push me to use {-# LANGUAGE UnicodeSyntax #-}
16:37:25 <applicative> Tekmo: yes, that is truly demonic
16:37:41 <Fuuzetsu> I have a ‘fmap foo <$> bar’. I'd like to get rid of the leading fmap. Is there a combinator for this in base already?
16:37:44 <FardadJalili> shachaf: so let's all go develop computer vision applications to change our handwritten code into unicode data
16:38:31 <tikhon> Fuuzetsu: this sounds like a question for Hoogle
16:38:44 <Tekmo> Fuuzetsu: That's a very narrowly useful function
16:39:00 <shachaf> That's fmap (fmap foo) bar
16:39:01 <tikhon> and the answer, coincidentally, seems to be "no"
16:39:04 <shachaf> I.e. (fmap.fmap) foo bar
16:39:10 <Tekmo> (fmap fmap fmap) foo bar
16:39:19 <shachaf> You can write "over (mapped.mapped) foo bar" if you prefer!
16:39:26 <Tekmo> fmap fmap fmap foo bar
16:39:35 <Fuuzetsu> strange, I tried fmap fmap fmap… Let's try again.
16:39:43 <shachaf> Don't use fmap fmap fmap.
16:39:55 <Fuuzetsu> It works… Yeah, I don't want to use it.
16:40:01 <Tekmo> I know, it's horrible
16:40:06 <scshunt> applicative: ancient greek doesn't have that many symbols, does it?
16:40:08 <Tekmo> I'd personally recommand fmap (fmap foo) bar
16:40:55 <tikhon> I think the fmap foo <$> bar formulation is probably best
16:41:01 <Tekmo> I'm not a big fan of (<$>)
16:41:12 <Tekmo> It only works on the simple cases and breaks down on the more complicated cases
16:41:17 <Makoryu> scshunt: Objection! Greek writing is alphabetic, not hieroglyphic
16:41:28 <tikhon> Tekmo: but the simple cases are far more common
16:41:31 <shachaf> <$> is the future (also the present)
16:41:35 <tikhon> besides, it's great by analogy to $
16:41:46 <Tekmo> I like it for applicative style, but that's it
16:41:47 <haasn> <&>
16:41:48 <FardadJalili> which is a great analogy to S combinator
16:41:55 <FardadJalili> haha :)
16:42:05 <leroux> tikhon: Which haskell concealer do you use?
16:42:14 <leroux> I think I used haskell-conceal before.
16:42:19 <leroux> But now I found unicode-haskell.
16:42:28 <applicative> scshunt: its the forms of combination, and the breathings and other diacritical marks, they can join as many as three vowels at a time, and what happens depends on the vowels and so on
16:42:45 <scshunt> ah
16:42:46 <Fuuzetsu> I think I'll stick with fmap foo <$> bar
16:43:01 <FardadJalili> I have a somehow off-topic question. What's your view on Perl6?
16:43:10 <shachaf> This channel is off-topic enough.
16:43:17 <shachaf> Let's get it more on-topic rather than less.
16:43:18 <applicative> unicode attempts to dispense with the idea of a language
16:44:54 <scshunt> question: I am writing a typeclass. I need to include functions which are partial. Should I make them return Maybes? If I do, the typeclass should throw errors if it ever gets Nothing back unexpectedly. Which is worse?
16:45:07 <Tekmo> shachaf: I think it's okay if it's off topic if nobody has a question that needs answering
16:45:30 <tikhon> leroux: concealer? Assuming you're talking about the symbols, I just use Haskell-mode for Emacs which supports that out of the box.
16:45:46 <leroux> Ahh, right, I'm using vim.
16:45:54 <tikhon> classic mistake :)
16:46:10 <Tekmo> Oh no you didn't
16:46:15 <pharaun> haha
16:46:17 <FardadJalili> Oh shi..
16:46:17 <shachaf> Well, "what do you think of language X" questions are explicitly discouraged for the mos part because they tend to lead to unproductive flame wars.
16:46:22 <shachaf> Similarly editor wars.
16:46:34 <Tekmo> So?
16:46:36 <tikhon> but Unicode is always relevant
16:46:41 <Tekmo> It's not like this channel is very productive anyway
16:46:48 <leroux> Hold on...someone had a question.
16:47:01 <Tekmo> If you really cared about productive use of your time you'd be maintaining bindings for GUI toolkits
16:47:02 <shachaf> OK, s/unproductive/harmful/
16:47:11 <mikeplus32> it would be neat if unicode syntax modules were automatically imported, otherwise to use unicode (for e.g. set operators), you need to pollute your import list
16:47:17 <pharaun> fwiw i find this channel productive cuz i'm always learning something new ;p
16:47:33 <applicative> another crucial point is that it is difficult to distinguish between 'off topic' and 'i don't like the topic'
16:47:36 * FardadJalili agrees with pharaun
16:47:40 <roboguy_> scshunt: what is the context of this question?
16:47:44 <tikhon> leroux: the last question was the fmap fmap fmap one and seems to have been answered
16:47:49 <applicative> i don't like obscure lens type-synonymns for example, myself
16:48:05 <leroux> Nah, someone asked about typeclasses and partial functions or something.
16:48:09 <Tekmo> Oh, speaking of lens type synonyms
16:48:14 <Tekmo> Here's an idea I've been kicking around
16:48:29 <Tekmo> Why not have a way to tell GHC to automatically apply type synonyms to improve type inference
16:48:42 <Tekmo> Both to improve error messages and improve inferred type signatures
16:48:44 <pharaun> yup - basically which is worse, partials or returning maybe and in the typeclass tossing errors out
16:48:47 <tikhon> scshunt: as with most style questions, the answer is basically "it depends"
16:48:57 <haasn> Tekmo: this feature request has been around for aeons
16:49:12 <Tekmo> haasn: What's the non-trivial part about implementing it?
16:49:18 <tikhon> in this case, it mostly depends on what an error means and where errors come from
16:49:34 <roboguy_> every time I try to figure lenses out it always seems like figuring the type synonyms out is a major hurdle
16:49:39 <haasn> wait, I think I misunderstand
16:49:44 <haasn> how do type synonyms affect type inference?
16:49:53 <Tekmo> The problem with lenses is that the library tries to do too much
16:50:04 <tikhon> haasn: I suppose he wants GHC to infer types using synonyms
16:50:08 <Tekmo> It's basically become an umbrella for every continuation-passing-style scheme in existence
16:50:28 <scshunt> roboguy_: I am creating a typeclass to represent a database relation with transitive structure
16:50:44 <tikhon> I've thought about some mechanic for completely custom type errors that the really crazy libraries could use
16:50:50 <scshunt> each database entry is of the form "a < b" for some a and b
16:51:04 <tikhon> like unittyped
16:51:12 <shachaf> lens doesn't have all that much to do with CPS.
16:51:14 <roboguy_> scshunt: should errors be immediately handled by the calling function?
16:51:36 <roboguy_> I've almost given up on trying to figure out lens. it's pretty overwhelming
16:51:54 <mlamari> Don't give up
16:51:59 <scshunt> roboguy_: a and b may not agree, but must be related. It must be possible to turn one into the other, EXCEPT  at either end of a transitive family
16:52:02 <scshunt> here the functions are partial
16:52:39 <scshunt> that is, if we insert "a < b" and "b < c", then we get "a < c", and "b" can be freely transformed from a head type to a tail type
16:52:43 <shachaf> lens is not as complicated as most presentations of lens, I think.
16:52:53 <shachaf> It's pretty straightforward from the right angle.
16:52:54 <mlamari> Lenses are a very practical solution to something I get bogged down with in F#
16:53:02 <scshunt> but c may not be a valid tail type, and a may not be a valid head type
16:53:10 <roboguy_> shachaf: I wish I could find that angle. it's hard for me to find a good entry point
16:53:20 <scshunt> I suppose the other alternative is to not make this part of the class, and use a single type
16:53:28 <scshunt> and have the instance detect the invalid code
16:53:32 <Tekmo> roboguy_: Have you read my post on lenses?
16:53:40 <Tekmo> http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
16:53:43 <roboguy_> I do see that lenses are pretty cool, which makes it more frustrating
16:53:45 <shachaf> I've been meaning to write a thing about it. But I can explain things a bit in #-lens if people are interested.
16:53:55 <mlamari> roboguy_: go to the simple cases in the ReadMe.  Then make your own set of records that contain records that contain records, and write a lens that "replaces" a field deep down.
16:54:03 <mlamari> You'll have an example that shows a high bang/$ case
16:54:32 <mlamari> I think you can get a lot out of them with just 5% of the library (it has a lot of exotic tools in it)
16:55:04 <roboguy_> Tekmo: yeah, that did help some. I seem to remember thinking that there was something that I wished it explained that it doesn't, but I can't remember what it was right now...
16:55:49 <Tekmo> mlamari: You can use the `lens-family` library which covers that simpler 5%
16:56:12 <Tekmo> mlamari: Edward pointed it out to me when I made the same complaint
16:56:16 <roboguy_> mlamari: I don't think I read the ReadMe, actually. Worth a shot
16:56:31 <mlamari> The readme has a few high-impact cases in it
16:58:12 <mlamari> What strikes me about lenses is that, in production type large codebases, if you embrace it it'd be on every other line (i.e. change the way you code)
16:58:30 <shachaf> I can explain my perspective on the important ideas of lens in #haskell-overflow (or #haskell-lens, but maybe -overflow is better) if people are interested.
16:59:13 <Tekmo> It's not that hard
16:59:14 <roboguy_> well, here's an example of something that I'm doing now that I feel like lenses might be able to help with (maybe I'm wrong though): applying operations across various pieces of a 2D array (rows, columns, diagonals in particular)
16:59:22 <Tekmo> Lens are just first class setters and getters
16:59:34 <shachaf> I mean the whole (a -> f b) -> s -> f t thing.
16:59:35 <Tekmo> And they're composable
17:00:25 <mstksg> do the haskell people ever intend on adding a heredoc syntax?
17:00:51 <thoughtpolice> shachaf: what's #haskell-overflow, again?
17:00:58 <tikhon> mstksg: probably not any time soon, but you can always use Template Haskell quasiquoting
17:01:03 <mstksg> i don't really want to involve template haskell every time i want to put more than one lines of string
17:01:08 <Tekmo> thoughtpolice: It's another IRC channel for extended discussion
17:01:11 <shachaf> thoughtpolice: Conversations that are too long for #haskell.
17:01:13 <mstksg> tikhon: yeah, i've seen those. i guess it's good enough for now
17:01:20 <tikhon> yeah, it's not ideal
17:02:09 <edwardk> mstksg: it can be written with a library as a quasiquoter
17:02:21 <roboguy_> shachaf: I'd be interested
17:02:58 <edwardk> http://hackage.haskell.org/packages/archive/heredoc/0.2.0.0/doc/html/Text-Heredoc.html
17:03:05 <edwardk> mstksg: there as another one as wel
17:03:30 <edwardk> roboguy_: its pretty easy to peel off a vector, from a matrix like that and then put it back in.
17:04:15 <edwardk> roboguy_: a related example is something like representing a maze as a bunch of cells with shared walls, then getting a lens to view a cell https://gist.github.com/ekmett/5970140
17:04:19 <roboguy_> edwardk: right now I'm just generating a list of indices for each case. is that the best way?
17:05:56 <roboguy_> (also I'm doing it in a particularly ugly way at the moment)
17:06:33 <edwardk> roboguy_: well, lets do this with linear. we can get a row directly using the Vector (Vector a)    representation by just using the index into the outer vector (ix n) and we can get the traversal by doing something like partsOf (traverse.ix n). by that token the other would be perhaps best as partsOf (ix n.traverse) for symmetry but it'd do unnecessary work
17:07:09 <Tekmo> Side note: Why is `repa` all we have for multi-dimensional unboxed vectors?
17:07:12 <edwardk> er i mean and then we can get a column
17:07:24 <edwardk> Tekmo: i'm working on a tensors project that may fix that
17:07:27 <Tekmo> edwardk: Thanks
17:07:42 <edwardk> it is an offshoot of the reasoning from the matrix multiplication series
17:08:12 <roboguy_> hmm
17:08:12 <edwardk> with tensors unlike linear, etc. you'd get a nice representation that is cache coherent, etc.
17:08:17 <thoughtpolice> edwardk: i think i'm going to use tasty for tests, fwiw (for structures)
17:08:19 <Tekmo> Really, all I need is unboxed vectors + multidimensional
17:08:28 <edwardk> thoughtpolice: go for it
17:08:42 <roboguy_> edwardk: I started to read that, but I don't know much about the specifics of caches and I'm not used to thinking a lot about bitwise stuff
17:08:49 <edwardk> thoughtpolice: the way i wind up using these things is someone sends me patches for them for one project, i like it, then i adopt it across all of them ;)
17:08:57 <Eduard_Munteanu> How do you declare GADTs in TH?
17:09:10 <edwardk> roboguy_: skip to part 6, then go back to parts 4 and 5. no real bit twiddling
17:09:21 <edwardk> Eduard_Munteanu: use the ForallC syntax.
17:09:38 <Eduard_Munteanu> Oh. I hadn't looked at that, thanks.
17:10:23 <edwardk> data a == b where Refl :: a == a   becomes   data (==) a b = (a ~ b) => Refl a b
17:11:00 <monochrom> hrm, is that syntax allowed? do you need a colon?
17:11:57 <roboguy_> edwardk: thanks, I'll try that
17:12:27 <Eduard_Munteanu> Oh, I see.
17:12:58 <edwardk> monochrom: 7.6 changed the : requirement
17:13:05 <monochrom> yikes
17:13:15 <edwardk> monochrom: conal panicked a bit =)
17:13:15 <arkeet> there are no type operator variables anymore.
17:13:49 <Eduard_Munteanu> I should write myself some helpers for this.
17:15:55 <monochrom> my left brain says: that's evil. my right brain says: good riddance. :)
17:17:08 <monochrom> so, "class a ~> b" is legal, but "instance a ~> b" is (where ~> is declared elsewhere) :)
17:17:12 <monochrom> err
17:17:17 <monochrom> so, "class a ~> b" is illegal, but "instance a ~> b" is (where ~> is declared elsewhere) :)
17:17:22 <shelf> anybody know HTTP.Conduit well? has the Response type changed? I can't match on it anymore
17:17:48 <shachaf> @remember edwardk <shachaf> But if it's a Prism, the thing you turn around is an Unlens. <edwardk> f it is a prism you get an 'unprism' <shachaf> Er, Unprism. <edwardk> er unlens
17:17:48 <lambdabot> I will never forget.
17:17:59 <edwardk> hahahaha
17:18:04 <shachaf> (edwardk had it right, for what it's worth.)
17:18:26 <Tekmo> shelf: Judging by the most recent version `Response` is now an opaque data type
17:18:41 <Tekmo> shelf: It looks like you are supposed to use accessors like `responseHeaders` and friends
17:20:33 <shelf> thanks, will investigate
17:20:54 <shelf> in other news, the HTTP Conduit book is now out of date :>
17:21:18 <Tekmo> I recommend not being afraid to dive straight into a library's API
17:21:31 <Tekmo> In Haskell, the API is more informative than in other languages
17:22:28 <arkeet> monochrom: no, you had it right the first time.
17:22:36 <arkeet> ~> would be the class name.
17:23:03 <arkeet> class a ~> b would be legal, and instance a ~> b would be legal too I guess.
17:23:18 <arkeet> class C (~>) would be illegal.
17:23:23 <arkeet> by would be, I mean is.
17:23:48 <edwardk> monochrom: the nice thing is it means i can upgrade the constraints package to use |- for judgments and the like
17:25:07 <arkeet> :- looks cuter.
17:26:38 <shachaf> And -| for adjunctions!
17:27:01 <monochrom> oh oops, I forgot that alphabetical class names are capitalized too
17:27:18 <monochrom> this whole business is very confusing!
17:28:14 <shachaf> This is all getting rather undisciplined... The boat, the night, the sense of isolation and uncertainty... all these induce a loosening of the concentration. We must not lose control. Tighten up.
17:28:59 <monochrom> use ContT or codensity to gain control
17:29:16 <Driscoll> i am totally spacing out, what is the function to fold a list, while building another list
17:29:37 <Driscoll> for like, summing an infinite list, while something else is lazily evaluating it
17:30:20 <shachaf> monochrom: You can use Codensity to gain control?
17:30:45 <monochrom> it can control free monads, at least
17:31:19 <Tekmo> Driscoll: scanl
17:31:28 <Driscoll> ty Tekmo
17:31:32 <Tekmo> You're welcome!
17:31:53 <monochrom> "foldr (\x ys -> sin x : ys) [] xs" folds xs and also builds another list
17:32:28 <monochrom> > foldr (\x ys -> sin x : ys) [] [0, pi/4, pi/2, 3*pi/4]
17:32:29 <lambdabot>   [0.0,0.7071067811865475,1.0,0.7071067811865476]
17:32:39 <Driscoll> cool
17:33:06 <Driscoll> actually i may want to do that instead
17:33:17 <Driscoll> i'm writing a function to check if every element of a list is the same value
17:33:25 <Driscoll> so i need the output array to be a Bool
17:33:46 <Driscoll> that i can just use and on
17:33:59 <Tekmo> Driscoll: There's an easy way to write that function
17:34:03 <Driscoll> ooh
17:34:28 <dwcook> @type any
17:34:28 <Tekmo> Driscoll: same [] = True; same (x:xs) = all (== x) xs
17:34:29 <lambdabot> (a -> Bool) -> [a] -> Bool
17:34:43 <ion> (== 1) . length . group
17:34:44 <shachaf> I,I GHC.Exts.the
17:34:48 <Driscoll> ah yes, that's what i have now in my prototype
17:34:53 <Driscoll> but i don't know the value in advance
17:34:57 <Driscoll> oh wait
17:35:02 <Driscoll> yep that's what i want
17:35:05 <Driscoll> haha ty again
17:35:11 <Tekmo> You're welcome! :)
17:35:23 <ion> or (< 2)
17:35:43 <Driscoll> thats pretty clever
17:35:52 <Driscoll> but obvious in retrospect
17:35:57 <monochrom> I . (<3) . Haskell
17:36:04 <Tekmo> Yeah, Haskell rocks
17:37:48 <mstksg> i love haskell.  i just changed a field in my database to be nullable and ghc promply tells me every single case where that would become a problem
17:38:27 <mstksg> whereas in say ruby i would only ever find out at runtime
17:38:33 <Tekmo> Yeah, it's great
17:38:38 <Nisstyre> mstksg: what database is this?
17:38:41 <Tekmo> It makes refactoring a dream
17:38:43 <mstksg> persistent
17:38:44 <Maior> mstksg: isn't it excellent
17:39:05 <Nisstyre> mstksg: well, I assume that alters the type, so you get a type error
17:39:22 <mstksg> yeah, that's exactly what happened
17:39:23 <Maior> I find the whole "lets write a test to validate something a type system would just give me" thing tedious
17:39:28 <Nisstyre> static type errors are a big help
17:39:47 <Tekmo> Yeah, I had to do some work in Python a couple of months ago
17:39:51 <Nisstyre> it lets you write code in Haskell in a fraction of the time it takes in more dynamic languages if you want the same level of confidence in it
17:40:14 <yitz> mstksg: where "runtime" in the best case means during testing, and in a worse case means hearing about it from irate customers
17:40:21 <Tekmo> There's nothing worse than finding out I didn't capitalize something correctly at runtime
17:40:21 <Nisstyre> Tekmo: I've had to write two fairly large systems this summer, one in Haskell the other in Python
17:40:33 <Nisstyre> the Haskell one is around 900 sloc, the Python one is around 500
17:40:48 <Driscoll> what sort of stuff are you writing in haskell for production
17:40:50 <Nisstyre> the Python one has taken two weeks and still isn't done, the Haskell one took about 1.5 weeks
17:41:09 <Tekmo> Yeah, Haskell is insanely productive
17:41:10 <Nisstyre> Driscoll: a content aggregator (http API stuff)
17:41:14 <Driscoll> cool
17:41:17 <Nisstyre> I used http-conduit
17:41:30 <Driscoll> personal project or work?
17:41:37 <Nisstyre> Driscoll: work
17:41:40 <Driscoll> cool
17:41:58 <Driscoll> my office does everything in java and python
17:42:06 <Driscoll> they do it well but it's pretty old school
17:42:06 <Nisstyre> I was going to use the Async module to speed it up but I didn't want to hammer the servers
17:44:36 <carter> Tekmo I'm really happy you're using a Void thingy for caps :)
17:44:53 <Tekmo> carter: Yeah, that's probably the 4th time I've gotten that request, so I relented
17:44:58 <carter> that was really bothering me in an (admittedly) OCD way :)
17:45:01 <Tekmo> :)
17:45:03 <Tekmo> I understand
17:45:21 <Driscoll> is 'all' lazy
17:45:26 <Tekmo> Yes
17:45:28 <Driscoll> like it will stop after the first false
17:45:29 <Driscoll> cool
17:45:35 <Tekmo> > all even [1..]
17:45:37 <lambdabot>   False
17:45:52 <Driscoll> ah yeah
17:45:54 <carter> also shifts the calculus of "should I try using pipes 4 for applicable bits of my own code" to YES
17:46:08 <carter> i still want to at some poiint help push Machines along
17:46:51 <carter> but makes the net ROI for using pipes a yes
17:46:58 <Tekmo> Haha
17:47:20 <carter> being annoyed with subtle design things is a huge penalty
17:47:27 <carter> its known to trigger yak shaving for me :)
17:47:30 <NemesisD> woahhhh
17:47:37 <Tekmo> Yeah, you're not the only one
17:47:44 <carter> yay
17:47:45 <carter> :)
17:47:47 <Tekmo> The 4.0 release got bikeshedded to death on the mailing list
17:47:50 <carter> hehe
17:47:50 <NemesisD> today i learned failed pattern matches are a supported case in list comprehensions
17:48:09 <NemesisD> [ x | Just x <- [Just 1, Nothing, Just 2]]
17:48:15 <Tekmo> NemesisD: Yes.  For example, `catMaybes` works like that
17:48:23 <NemesisD> man thats so nice
17:48:25 <liyang> NemesisD: look at Monad (fail).
17:48:28 <Tekmo> NemesisD: catMaybes xs = [ y | Just y <- xs ]
17:48:47 <Tekmo> I really wish `fail` would be defined to be `mzero`
17:48:51 <liyang> You can use it to do all sorts of nasty things.
17:48:55 <shachaf> Like Haskell 1.4?
17:49:00 <shachaf> :-(
17:49:04 <Tekmo> shachaf: Was that how it was in Haskell 1.4?
17:49:55 <shachaf> Tekmo: It was slightly better.
17:50:02 <Tekmo> How so?
17:50:11 <shachaf> MonadZero was separate from MonadPlus
17:50:20 <shachaf> So you didn't need to define mplus to have failure.
17:50:37 <Tekmo> I don't mind the `MonadPlus` constraint, but I can understand that
17:50:46 <shachaf> See section 3.14 in http://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/exps.html
17:50:46 <lightquake> I wish there was a monadic case
17:50:58 <lightquake> I don't like having to do x <- f y; case x of
17:51:16 <shachaf> Also, map was fmap.
17:51:18 <Tekmo> lightquake: There is lambda case
17:51:20 <shachaf> And a bunch of other things.
17:51:27 <Tekmo> lightquake: f y >>= \case of ...
17:51:35 <lightquake> true
17:51:44 <Tekmo> shachaf: Are you SERIOUS?
17:51:48 <shachaf> Yep.
17:51:52 <shachaf> http://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/standard-prelude.html
17:51:58 <Tekmo> shachaf: Wow, that's pretty bad that they actually switched map to lists
17:52:07 <NemesisD> hmm. why can't you do this? [ (x, y) | y <- getY x, x <- xs]
17:52:18 <shachaf> I don't know of anything that Haskell 98 actually improved.
17:52:21 <carter> yeah… it was "for pedagogy"
17:52:33 <Tekmo> shachaf: I always thought they started out with a specialized `map` and added `fmap` later
17:52:39 <carter> or "make things simple because we're lazy teachers"
17:52:45 <NemesisD> erm getYs, but you get the idea
17:52:46 <carter> "and thus make things more complicated"
17:53:12 <shachaf> Tekmo: That would be a reasonable justification for having two functions with one being a special case of the other, wouldn't it?
17:53:15 <shachaf> But no.
17:54:11 <carter> any chance we can fix that story in 7.10 along with AMP?
17:54:19 <shachaf> NemesisD: What would it mean?
17:54:40 <shachaf> carter: Well, it'd be part of the Foldable/Traversable generalization.
17:54:59 <Tekmo> All we need is to find somebody with commit access to ghc and just get them drunk
17:55:00 <shachaf> If we're generalizing mapM etc. to work on Traversable, it makes sense to generalize map etc. to work on Functor.
17:55:11 <shachaf> But there are some tricky issues with compatibility so it might not happen.
17:55:12 <carter> oh?  Oh yeah, that got ok'd subject to the fusion story being sorted out, right?
17:55:33 <shachaf> We'll see.
17:55:45 <Tekmo> Oh, and I have a simpler test case for fusion onw
17:55:52 <Tekmo> The `foldl` library is a really good example
17:56:08 <Tekmo> If you generalize the `fold` function to use the `Foldable` `foldl'` then you lose fusion
17:56:10 <roboguy_> why isn't join in the Monad type class to start with?
17:56:36 <Makoryu> Huh? Isn't it?
17:56:39 <shachaf> roboguy_: Because.
17:56:40 <Tekmo> Nope
17:56:46 <NemesisD> shachaf: xs = [Just "ab", Nothing]; [(y, x) | y <- x, Just x <- xs] i'd expect to == [('a', "ab"), ('b', "ab")]
17:56:48 <monochrom> because I haven't built a time machine to go back and fix that
17:56:53 <Makoryu> roboguy_: You mean as a method?
17:56:54 <Tekmo> But the eponymous `fail` is
17:56:55 <shachaf> NemesisD: Clauses are ordered.
17:57:03 <tel> it's not even in prelude
17:57:04 <NemesisD> i guess i could probably nest comprehensions
17:57:11 <NemesisD> shachaf: am i doing it in the wrong order?
17:57:24 <shachaf> NemesisD: You're binding x after y.
17:57:24 <NemesisD> yep!
17:57:26 <shachaf> But y uses x.
17:57:26 <NemesisD> niiiice
17:57:27 <Makoryu> I could have sworn it was in Prelude.
17:57:40 <Makoryu> Someone must have *already* changed the timeline
17:57:44 <shachaf> It's in Control.Monad, but not part of the Monad class.
17:58:21 <monochrom> darn, someone built a time machine ahead of me.
17:58:22 <shachaf> But I think it's pretty much been approved, if #7633 gets into GHC.
17:58:30 <shachaf> ( http://ghc.haskell.org/trac/ghc/ticket/7633 )
17:58:42 <monochrom> now I have to speed up my time machine project so I can go back and fix *that*
17:58:53 <roboguy_> Makoryu: yeah (is "method" the right word?)
17:58:57 <Tekmo> Yes
17:58:59 <monochrom> then again, I have plenty of time
17:59:20 <tel> shachaf I like that ticket!
17:59:32 <Makoryu> roboguy_: It is absolutely the right word, as far as terminology used in a way specific to Haskell
17:59:36 <mstksg> is there a way to tell cabal install to only build a specific executable defined in the cabal file if there are multiple executables defined?
17:59:55 <shachaf> tel: So do I!
17:59:57 <roboguy_> Makoryu: huh, I didn't know that
18:00:13 <monochrom> shachaf++
18:00:33 <monochrom> pragma is a very easy solution for this!
18:01:37 <shachaf> twanvl even wrote a patch.
18:01:40 <monochrom> when my time machine is completed, will you want a ride so you can go back and impose that right at Haskell 1.4? :)
18:01:50 <shachaf> But now people aren't happy with conjunctive normal form.
18:02:11 <shachaf> monochrom: When it's completed, you can travel back in time to right now and ask me again.
18:02:19 <monochrom> haha
18:02:29 <monochrom> but CNF is exactly right for this
18:03:00 <Tekmo> Everybody kills Rasmus Lerdorf on their first trip
18:03:02 <shachaf> Or, wait, disjunctive normal form?
18:03:02 <monochrom> err wait, no, DNF is exactly right for this
18:03:07 <shachaf> Right.
18:03:40 <shachaf> Henning wants to be able to write things like ((sin AND cos) OR tan) AND ((sinh AND cosh) OR exp)
18:04:36 <monochrom> I can understand that for some type classes, DNF is a bit redundant. but why over-optimize this?
18:04:59 <shachaf> I think a syntax like {-# MINIMAL ((sin, cos) | tan), ((sinh, cosh) | exp) #-} would be nicer, since those already mean "and" and "or".
18:05:12 <shachaf> But I care much more than the extension exists than about the specifics.
18:06:23 <carter> agreed
18:06:28 <paz> What do you think: Can I do something like streamripper as first project if I am new to Haskell? Are there libraries for streaming, m3u and MP3 IDv3 tags?
18:06:38 <carter> whats streamripper?
18:07:02 <paz> it dumps audio streams in mp3 files. e.g. to dump web-radio
18:07:05 <monochrom> I am a typical programmer. I have just purportedly finished writing a piece of instance code. but have I really finished? Let's see. I have implemented methods #2, #4, and #5. how do I know that they suffice? Give me DNF, I see that #2, #4, #5 meets or exceeds one of the options. as simple as that. why should I do more logic than that?
18:07:33 <shachaf> You'll note that that was my original proposal. :-)
18:08:02 <shachaf> paz: Looks like there are libraries for ID3 tags. I doubt the other ones exist. You could write them!
18:09:07 <paz> shachaf: Well, sure I could write something, but it wont qualify as a library others liked to use, as I am a newbie.
18:09:27 <paz> And if I have to write that stuff, it seems too complex for the first project
18:09:50 <shachaf> You could maybe write bindings to existing libraries.
18:09:58 <NemesisD> man i really need hlint for lenses
18:09:59 <shachaf> But maybe that's not a great first project.
18:10:20 <shachaf> (Not necessarily because it's too hard but because you might not have a sense for what nice Haskell APIs are like.)
18:10:40 <NemesisD> there are times where I don't know the lens equivalent and fall back to stuff from prelude
18:11:05 <edwardk> NemesisD: the best recommendation i have is ask here or in #haskell-lens for how to do something
18:11:23 <paz> Well, I have some Scala experience, but not in the pure functional manner. Monads are kind of a new concept to me. But I love them already ;)
18:11:31 <Nisstyre> one thing Haskell needs are some good gstreamer bindings
18:11:54 <Nisstyre> last I remember there were some but they're rather old and apparently don't build correctly
18:12:04 <NemesisD> edwardk: yeah i figure i'm going to go in there and bug you guys for code review once this project is less of a moving target
18:12:31 <edwardk> ReinH: started the png converted. decided to implement crc32 and adler32 as left-folds in the style of tekmo's recent tutorial
18:12:34 <NemesisD> i find myself doing: map (view attr) listOfThings and i know that doesn't make sense
18:12:35 <edwardk> er convert
18:12:39 <edwardk> er converter even =)
18:18:49 <edwardk> @pl \(s,r) -> s2f s (r2x r)
18:18:52 <lambdabot> ap (flip ((.) . s2f) r2x . fst) snd
18:18:53 <lambdabot> optimization suspended, use @pl-resume to continue.
18:18:58 <edwardk> er nope
18:19:23 <shachaf> uncurry ((. r2x) . s2f)
18:19:37 <ReinH> edwardk: llmao awesome
18:20:02 <edwardk> shachaf: still kinda ugly
18:20:14 <shachaf> edwardk: Just giving you the non-broken @pl output.
18:20:22 <edwardk> ReinH: just getting started, we'll see how it goes
18:20:28 <ReinH> edwardk: cool :)
18:20:28 <heatsink> I've known some programmers who routinely use the C++ container library, yet don't have a clue how constrained parametric polymorphism works
18:20:41 <edwardk> i want to try to make a pretty combinator that lets me prime a fold, etc.
18:20:45 <heatsink> It makes me wonder whether learning Scala can teach you something you don't already know
18:20:55 <heatsink> prime?
18:20:59 <shachaf> edwardk: "prime a fold" is how you go from foldl to foldl', right?
18:20:59 <heatsink> \x -> x'
18:21:02 <edwardk>  i mean kickstart it with some values
18:21:05 <edwardk> shachaf: =)
18:21:14 <edwardk> data Fold a b where Fold :: (r -> b) -> r -> (r -> a -> r) -> Fold a b
18:21:18 <shachaf> (You actually need foldr.)
18:21:25 <edwardk> shachaf: yes, i know
18:21:33 <shachaf> I know you know.
18:21:35 <edwardk> =)
18:22:27 <edwardk> but yes, clearly profunctors belong in my short png generator
18:22:43 <edwardk> since folds are a profunctor
18:23:05 <edwardk> and then w can have things like
18:23:07 <edwardk> crc32 = Fold complement 0xffffffff $ \ (CRC32 chksum) b -> CRC32 $ unsafeShiftL chksum 8 `xor` crcs ! fromIntegral (unsafeShiftR chksum 24 `xor` b)
18:23:23 <edwardk> er i guess i don't need the CRC32 noise in there any more
18:24:02 <Tekmo> edwardk: I also wanted to thank you for your `exceptions` library
18:24:16 <Tekmo> edwardk: It was a perfect fit for `pipes-safe`
18:24:42 <edwardk> Tekmo: i'm going to sit down with snoyman/johnw in a week or two and try to hammer out the right mix of that and monad-control's guts at some point
18:24:58 <edwardk> to try to handle the rest of the stuff we don't currently try to do with it
18:25:04 <Tekmo> edwardk: Alright
18:25:14 <edwardk> mzero deserves most of the credit for what is in exceptions, it was based on his code
18:25:28 <Tekmo> edwardk: I can at least say that the two masks were not problematic at all, so I'd recommend you keep them
18:25:45 <edwardk> oh the mask and mask_ stuff?
18:25:50 <edwardk> or uninterruptible
18:25:54 <Tekmo> Yea
18:26:20 <edwardk> it mostly comes down to deciding if we want to gracefully handle side-exiting monads like EitherT, etc.
18:26:24 <Tekmo> Oh
18:26:27 <Tekmo> I have a lot to say about that
18:26:42 <edwardk> Does Fold a form a comonad?
18:26:55 <edwardk> clearly we should drag you into the discussion
18:26:56 <Tekmo> I found the most elegant solution is to redefine the meaning of `onException` (or alternatively provide a separate `onAbort` primitive)
18:27:10 <Tekmo> For simplicity, I'll assume it's a separate `onAbort` command
18:27:23 <Tekmo> The meaning of `onAbort` is that it runs the code if you take any control path other than the successful one
18:27:40 <Tekmo> And the laws are that (`onAbort` m) must be a monad morphism
18:27:52 <edwardk> i have very little to say about exception handling in general in haskell at this point, i figured i'd just ask folks to explain like I'm 5 until i grokked their issues ;)
18:28:28 <Tekmo> So using the example of `EitherT`, the `onAbort` command would run the finalizer if you received either an exception or took the `Left` control path of the `EitherT`
18:28:29 <edwardk> exceptions was the basically bare minimum replacement for MonadCatchIO-transformers we could ship lens 3.10 with
18:28:37 <edwardk> that makes sense
18:28:46 <Tekmo> That will also work for `conduit`, too
18:28:58 <Tekmo> Since `conduit`'s finalization scheme is very similar
18:29:13 <edwardk> how about when it sounds like we're actually going to have the discussion i try to get you looped in as well?
18:29:19 <Tekmo> Alright
18:29:25 <Tekmo> Just send me an e-mail whenever you guys are ready
18:29:30 <edwardk> will do
18:29:40 <edwardk> i think its mostly hung up on snoyman's availability for now
18:29:49 <Tekmo> I found that the most problematic transformers to deal with are the ones that can have more than one control path (i.e. `ListT`)
18:30:04 <edwardk> anything 're-entrant' is pretty hard
18:30:09 <edwardk> ContT, etc.
18:30:23 <edwardk> because the exception handling vocabulary has no concept of dynamic-wind
18:30:35 <Tekmo> You need some sort of `once` command that ensures that the wrapped command only runs exactly once, but even then it's not obvious how you implement that
18:30:44 <Tekmo> Since you may not know when a given iteration is the last one
18:31:06 <Tekmo> Right now I just settle for not implementing `MonadCatch` for things like `ListT`
18:31:12 <Tekmo> That was the only sane solution I could come up with
18:31:28 <ski> hm, there's some such `on-commit' stuff in Mercury
18:31:40 <edwardk> wait, when did data-default go full retard and split into 5 packages?
18:31:58 <ReinH> edwardk: anything I can look at?
18:32:01 <shachaf> 0.5.2?
18:32:03 <ReinH> edwardk: wait what?
18:32:06 <edwardk> shachaf: *sigh*
18:32:11 <ReinH> what happened to data-default?
18:32:13 * edwardk scraps any dependency on that
18:32:13 <shachaf> What happened?
18:32:18 <shachaf> mauke: ☝?
18:32:40 <edwardk> shachaf: dunno. i just installed it and got 5 packages. for a one line class that i barely wanted
18:33:00 <shachaf> https://github.com/mauke/data-default/commit/312844532f3c3c79fc5b0e911bffa74baf24b2f7
18:33:38 <shachaf> I guess it's an orphan thing.
18:33:49 <scshunt> Is there an efficient version of intersect which assumes the lists are sorted?
18:34:14 <edwardk> scshunt: turn them both into Data.Maps with fromAscList and intersect? =)
18:34:25 <Tekmo> Yes
18:34:37 <ReinH> edwardk: I'm confused in a different way. Can you not define Default for all Monoids as mempty?
18:34:45 <edwardk> ReinH: for non-monoids
18:34:53 <edwardk> ReinH: consider a configuration for a system or something
18:35:04 <edwardk> ReinH: anyways, let me get the code i have to compile sans default =)
18:35:10 <edwardk> then i'll lpaste
18:35:18 <Tekmo> Why do you even need the class?
18:35:39 <ReinH> edwardk: I mean, why is the library doing this? https://github.com/mauke/data-default/blob/312844532f3c3c79fc5b0e911bffa74baf24b2f7/data-default-instances-containers/Data/Default/Instances/Containers.hs#L46-L50
18:35:44 <Tekmo> How often do you program generically over configurations?
18:36:01 <shachaf> ReinH: Because instance resolution doesn't work the way you think.
18:36:04 <ski> edwardk : doesn't work incrementally
18:36:05 <ReinH> shachaf: ok
18:36:29 <shachaf> If you define instance Monoid m => Default m where def = mempty, you can't define any other instances without overlapping.
18:36:36 <lpaste> edwardk pasted “crc folds for rein” at http://lpaste.net/92383
18:36:47 <ReinH> shachaf: any other instances of what?
18:36:52 <shachaf> Default
18:37:10 <edwardk> ReinH: it has to
18:37:12 <ReinH> so you might want something that is a monoid to have a default that is not mempty but you couldn't?
18:37:27 <edwardk> ReinH: you can't make instance Monoid m => Default m without making all other instances ever conflict with it
18:37:29 <shachaf> Well, even for things that aren't monoids.
18:37:38 <ReinH> ah
18:37:39 <edwardk> ReinH: no you might want to make things that aren't monoids into instances of default
18:37:46 <scshunt> edwardk: Data.Set, but seems good
18:37:46 <tel> ReinH it's that GHC will try matching that instance for things that aren't monoids… and then complain it can't find their monoid instance
18:37:47 <ReinH> OH
18:37:58 <ReinH> that's not saying "for things that are monoids, their default instance is this"
18:38:04 <ReinH> it's saying "default is a monoid"
18:38:12 <shachaf> Not exactly.
18:38:18 <Tekmo> GHC only uses the type to match against a type class
18:38:24 <Tekmo> It ignores constraints for the purposes of matching
18:38:25 <edwardk> reinh: thats saying if you need Default for any 'm' then go look for a Monoid m   and build the dictionary this way
18:38:34 <ReinH> ah
18:38:41 <Tekmo> So when you say `instance (Monoid m) => Default m`, that matches every single type
18:38:43 <ReinH> it's not saying "the default for any m where m is a monoid"
18:38:43 <mstksg> is there a way to monadically iterate along a list of Maybe's and stop at the first Just value?  kind of like a Foldable.forM_ but stopping at the first Just
18:38:49 <edwardk> ReinH: ghc isn't going to backtrack when it can't find a Monoid for m, and go 'oops my bad, lets try another path' its just going to die horribly ;)
18:38:52 <ReinH> it's saying "the default for any m assumes m is a monoid"
18:38:57 <ReinH> ok
18:38:59 <ReinH> thanks
18:38:59 <edwardk> correct
18:39:01 <shachaf> ReinH: Let's say you define instance Default Foo, and then some other module somewhere else defines instance Monoid Foo.
18:39:05 <shachaf> What should happen when I import both?
18:39:17 <tel> mstksg First :)
18:39:21 <edwardk> > [Nothing, Just 1, Just 2]^?traverse.traverse
18:39:22 <lambdabot>   Just 1
18:39:24 <tel> mstksg wait, whoops
18:39:30 <Driscoll> is having nested Maybe's a bad idea?
18:39:46 <ski> Driscoll : depends on what you want to express
18:39:50 <Driscoll> like, maybe i have a square on a chessboard, maybe there's a poiece in it
18:39:52 <ReinH> shachaf: got it
18:39:54 <Driscoll> *piece
18:39:58 <mstksg> i have a function that executes a monadic action, but i want to run it on the first Just item
18:40:08 <mstksg> er wait
18:40:10 <Driscoll> which would end up being Just ( Just Knight ) or something
18:40:10 <edwardk> mstksg: ^-
18:40:25 <mstksg> hold on, i didn't even completely understand what i was doing.
18:40:30 <ski> Driscoll : is a piece also a `Maybe'-thing ?
18:40:37 <ReinH> Driscoll: that seems ok, but I'm not sure why you would maybe have a square on a chessboard
18:40:46 <edwardk> ReinH: does that code make any sense?
18:40:52 <Tekmo> Note that the equivalent code for `pipes` would be
18:41:02 <ReinH> edwardk: which code?
18:41:03 <Tekmo> P.head $ (each ~> each) [Nothing, Just 1, Just 2]
18:41:07 <edwardk> http://lpaste.net/92383
18:41:15 <mstksg> i have monadic actions that return Maybes, and a list of parameters for the action to be run on, and I want to stop after the first action that returns m Just
18:41:26 <shachaf> > firstOf (each . each) [Nothing, Just 1, Just 2]
18:41:28 <lambdabot>   Just 1
18:41:31 <ReinH> ooh, I want to play
18:41:33 <ReinH> > ala First foldMap [Nothing, Just 1, Just 2]
18:41:34 <lambdabot>   Just 1
18:41:38 <edwardk> ReinH: =)
18:41:51 <ski> > msum [Nothing, Just 1, Just 2]
18:41:52 <lambdabot>   Just 1
18:41:55 <Tekmo> mstksg: What's the type signature of the function you want?
18:42:07 <Driscoll> ReinH: the chessboard is a hypothetical here
18:42:13 <shachaf> > lastOf (each . each) [Nothing, Just 1, Just 2, Nothing] -- ski: how about that?
18:42:14 <lambdabot>   Just 2
18:42:23 <mstksg> so it would be (a -> m (Maybe b)) -> [a] -> ()
18:42:27 <ReinH> Driscoll: well, in general it's fine.
18:42:27 <Driscoll> ReinH: but in that example, a square is Maybe Piece
18:42:28 <Tekmo> P.last $ (each ~> each ) [Nothing, Just 1, Just 2]
18:42:37 <ReinH> Maybe (Maybe a) is as reasonable type
18:42:43 <Driscoll> ok cool
18:42:48 <ski> > (msum . reverse) [Nothing, Just 1, Just 2, Nothing]  -- shachaf : simple :P
18:42:50 <lambdabot>   Just 2
18:42:50 <shachaf> ReinH: Maybe it is, maybe it isn't.
18:42:57 <ReinH> shachaf: yes thanks
18:42:59 <Driscoll> lol
18:43:27 <ski> Driscoll : why is a square a maybe piece ?
18:43:33 <Tekmo> mstksg: So in principle the return value could be a `Bool`, too?
18:43:34 <shachaf> We should fix lastOf.
18:43:38 <ReinH> > ala Last foldMap [Nothing, Just 1, Just 2, Nothing] -- :p
18:43:39 <Tekmo> mstksg: Or are you using the `b`?
18:43:39 <lambdabot>   Just 2
18:43:40 <Driscoll> ski: beacuse a square can be empty
18:43:52 <ski> Driscoll : ok, so why `Maybe' a square then ?
18:43:58 <shachaf> Right now it takes a ~1000x penalty in the average case to get better asymptotic behavior.
18:44:11 <shachaf> (In the worst case.)
18:44:11 <edwardk> Tekmo: hrmm, left folds form a comonad.
18:44:20 <FreeFull> > foldl (<|>) Nothing [Nothing, Just 1, Just 2]
18:44:21 <lambdabot>   Just 1
18:44:27 <mstksg> Tekmo: er.  yeah, actually i misunderstood myself again
18:44:27 <Driscoll> ski: Maybe Square could be for something like: hilighted a square in the ui
18:44:27 <Tekmo> edwardk: I also discovered that left *scans* form a category
18:44:32 <ReinH> Driscoll: for instance, reading a piece from a character (like from an ASCII representation of a board)
18:44:35 <mstksg> i want it to return the first Just value
18:44:42 <ReinH> Driscoll: readPiece :: Char -> Piece would be a partial function, and that's bad
18:44:44 <edwardk> that sounds very likely
18:44:46 <mstksg> (a -> m (Maybe b)) -> [a] -> b
18:44:55 <mstksg> where b is the first Just value
18:44:57 <ReinH> Driscoll: you would want readPiece :: Char -> Maybe Piece
18:44:58 <ski> Driscoll : with `Just square' being highlighted square ? and `Nothing' being ?
18:45:09 <FreeFull> > foldr (<|>) Nothing [Nothing, Just 1, Just 2]
18:45:11 <lambdabot>   Just 1
18:45:17 <FreeFull> Ah, of course
18:45:20 <Driscoll> ski: Nothing would be, don't hilight anything
18:45:24 <FreeFull> Would have to flip it
18:45:45 <ski> Driscoll : where where would such `Maybe Square's occur ?
18:45:47 <mstksg> i might have picked an inopportune time to ask my question
18:45:55 <ski> Driscoll : in some datastructure ? as a result from some function ?
18:45:57 <Driscoll> anyways that's not actually what i'm actually doing, it was a hypothetical
18:46:20 * hackagebot typeable-th 0.1.2 - Automatic deriving of TypeableN instances with Template Haskell  http://hackage.haskell.org/package/typeable-th-0.1.2 (BennoFuenfstueck)
18:46:21 <Tekmo> Got it
18:46:24 <Tekmo> Using `pipes`:
18:46:41 <Tekmo> let yourFunction k as = P.last $ for (each as >-> P.mapM k) each
18:46:42 <ski> Driscoll : in any case, `Maybe (Maybe Blah)' can be reasonable, if you have a sensible rationale for the meaning of both `Maybe', and why `Nothing' should be distinct from `Just Nothing'
18:46:47 <Tekmo> let yourFunction k as = P.head $ for (each as >-> P.mapM k) each
18:46:50 <Tekmo> Oops, should have been head
18:46:54 <ReinH> Driscoll: so reading a square that might contain a piece would be: readSquare :: Char -> Maybe Square
18:46:55 <mstksg> if i just used mapM over the list, and found teh first Just, would that also execute all of the remaining actions after that first Just?
18:46:58 <ReinH> Driscoll: where Square is Maybe Piece
18:47:07 <Driscoll> yes
18:47:10 <edwardk> Tekmo: just noticed because i was looking for a nice way to feed a fold some initial values, but if i just extend the use of the fold then i get a longer fold that wants more inputs
18:47:11 <ReinH> or, if you want to report an error, readSquare :: Char -> Either ErrorMsg Square
18:47:20 <ReinH> Driscoll: so yes, it's a perfectly reasonable type
18:47:20 <mm_freak_> mstksg: if m = Maybe, then it will evaluate up to the first Nothing
18:47:36 <mstksg> m is not maybe, m contains a maybe
18:47:39 <Tekmo> edwardk: Hold on a second, I need to eat dinner.  I'll be right back
18:47:43 <edwardk> feed :: [a] -> Fold a b -> b   -- then you can extend (feed xs) to get a fold that picks up where the old one left off
18:47:51 <Driscoll> oh hey you're ReinH
18:47:53 <mm_freak_> mstksg: in what way?  MaybeT?
18:47:53 <joelteon> @pl \x -> print x >> print x
18:47:56 <lambdabot> liftM2 (>>) print print
18:47:57 <lambdabot> optimization suspended, use @pl-resume to continue.
18:47:59 <ReinH> Driscoll: I am :)
18:48:02 <Driscoll> ive watched your vids, you should make more!
18:48:07 <edwardk> Tekmo: or so my current half thought out scribblings seem to say
18:48:08 <ReinH> Driscoll: I'm planning on it
18:48:10 <Driscoll> sweet
18:48:16 <ReinH> Driscoll: I think I've unstuck myself on how to represent the game tree
18:48:29 <Driscoll> nice
18:48:33 <edwardk> that actually may be wrong
18:48:35 <mstksg> mm_freak_: i want to find (a -> m (Maybe b)) -> [a] -> b, where b is the first value in the list that returns m (Just b)
18:48:36 <edwardk> damn
18:48:36 <Driscoll> wow diving right in huh?
18:48:40 <mstksg> excuse my notational abuse
18:48:43 <mm_freak_> Tekmo: glad you're here…  have you experimented with representing monad morphisms more precisely?
18:48:43 <edwardk> it was nice while the thought lasted
18:48:44 <shachaf> What is this type, data Fold a b = forall x. Fold (x -> a -> x) x (x -> b)?
18:49:00 <ReinH> Driscoll: well, once we can play a 2-player game, which is pretty easy
18:49:12 <mm_freak_> mstksg: you want a findM?
18:49:16 <ReinH> Driscoll: the next step is to evaluate a game tree using material counts and start getting an engine going
18:49:25 <Driscoll> yeah
18:49:36 <ReinH> Driscoll: minimax in Haskell is a couple lines though, so that's good
18:49:37 <mstksg> mm_freak_: it looks like i do; is that a real thing?
18:49:44 <mm_freak_> mstksg: not yet =)
18:49:45 <Driscoll> i started trying to do chess in haskell as a driver for learning it
18:49:48 <shachaf> That looks like Nu of data Foo b a x = (b, a -> x)
18:49:50 <Driscoll> but then backed off to tictactoe
18:49:51 <shachaf> I.e. of Context.
18:49:51 <ReinH> Driscoll: heh me too :D :D
18:49:51 <Driscoll> haha
18:50:03 <Driscoll> i've done chess in other stuff before but i hit a wall pretty early on
18:50:04 <ReinH> Driscoll: yeah, I tested my gamea tree representatio on tic tac toe actually
18:50:05 <shachaf> s/data //
18:50:05 <ReinH> just the other day
18:50:14 <Driscoll> nice
18:50:14 <mm_freak_> mstksg: first get the type right:  findM :: (Monad m) => (a -> m (Maybe b)) -> [a] -> m (Maybe b)
18:50:17 <ski> shachaf : `forall b. Fold a b -> b' is another way of saying `[a]'
18:50:21 <edwardk> nevermind it works
18:50:26 <edwardk> >>> feed [1,2] crc32
18:50:26 <edwardk> 617832752
18:50:29 <edwardk> >>> feed [1] (extend (feed [2]) crc32)
18:50:30 <edwardk> 617832752
18:50:40 <edwardk> so the comonad provides us with the ability to run a longer fold
18:50:41 <mstksg> mm_freak_: well i techically want the value, so an unwrapped Maybe, but that would work too
18:50:48 <mstksg> oh
18:50:50 <edwardk> thats really nice
18:50:50 <mstksg> but it is Maybe
18:50:52 <mstksg> because it might not be found
18:50:53 <mm_freak_> mstksg: what if the list is empty?
18:51:14 <mstksg> ah, thanks for reminding me.
18:51:17 <shachaf> Fold a b = Nu (Context b a)?
18:51:21 <edwardk> ReinH: i think i have another pedagogical tool to explore in this second post now =)
18:51:21 <mm_freak_> mstksg: you might try the predefined filterM, but that one always traverses the entire list
18:51:29 <shachaf> How did the Nu-like Cofree look, again?
18:51:32 <ReinH> edwardk: :D :D
18:51:32 <edwardk> ReinH: so we'll get 2-3 new topics to play with
18:51:36 <ReinH> edwardk: fun!
18:52:01 <shachaf> Oh, exists x. (x, x -> (a, f x))
18:52:05 <mstksg> mm_freak_: if I did mapM and then find, would it evaluate the entire list?
18:52:20 <mm_freak_> mstksg: it would cause effects for the entire list
18:52:34 <shachaf> Hmm, I got something wrong somewhere there...
18:52:49 <mstksg> what's the best way to do this then, short of maybe explicit recursion?
18:52:50 <Tekmo> edwardk: Usually if I want to do more complicated things like feed some initial values I just immediately go straight to `pipes` where doing that kind of thing is easier
18:53:09 <edwardk> Tekmo: sure. i'm not looking for anything that complicated. it just emerged as a natural consequence of what i was writing
18:53:10 <ski> shachaf> :k Cofree
18:53:16 <edwardk> feed is the 'apply the fold' function
18:53:31 <edwardk> that it can be extended to allow me to run longer folds was just a really happy but fundamental accident
18:53:32 <Tekmo> mm_freak_: What did you have in mind for more precision?
18:53:43 <mm_freak_> mstksg: explicit recursion =)
18:53:43 <mm_freak_> monadic combinators usually don't provide a shortcut, unless the underlying monad provides one
18:53:44 <edwardk> Tekmo: feed :: [a] -> Fold a b -> b
18:54:01 <shachaf> ski: (* -> *) -> * -> *
18:54:02 <edwardk> Tekmo: thats the 'obvious' function, it just happens to also take a list and turn it into a cokleisli action for the Fold comonad
18:54:10 <Tekmo> edwardk: The `foldl` library has this function and it's called `fold`
18:54:15 <mm_freak_> mstksg: alternative example (pun intended):  findA :: (Alternative f) => (a -> f b) -> [a] -> f b
18:54:26 <ski> edwardk : heh, i've been calling that `Fold' a `ListConsumer'
18:54:36 <mm_freak_> mstksg: that's foldr (<|>) empty . map f
18:54:38 <edwardk> yes. i know, i was just pointing out that when you make Fold a comonad you can extend it and keep feeding entries
18:55:04 <mm_freak_> mstksg: something based on Monoid is already predefined in Data.Foldable
18:55:07 <mm_freak_> fold and foldMap
18:55:13 <ski> shachaf : so what was wrong ?
18:55:14 <edwardk> the fact that extend works on it was just really neat to me
18:55:28 <shachaf> ski: Not in what I said, just in my chain of reasoning in general.
18:55:38 <Tekmo> edwardk: So extract would be `feed []`?
18:55:39 <edwardk> and it works because you can view Fold as just a EnvT'd Store
18:55:39 <ReinH> edwardk: oh so that's what you did :)
18:55:45 <edwardk> Tekmo: exactly
18:55:47 <mstksg> mm_freak_: thanks, i'll look into Alternative. also have never had the occasion to use <|> before so i guess i have some readong ti do
18:55:49 <mm_freak_> Tekmo: not sure to be honest, but i'm working a lot with monad morphisms, but can't really make use of mmorph
18:55:49 <ski> Tekmo : sounds likely
18:55:53 <edwardk> data Fold a b where
18:55:53 <edwardk>   Fold :: (r -> b) -> r -> (r -> a -> r) -> Fold a b
18:55:56 <edwardk>   extract (Fold rb r rar) = rb r
18:55:57 <Driscoll> would there be an elegant way to 'flatten' a bunch of nested Just's?
18:56:01 <edwardk>   duplicate (Fold rb r0 rar) = Fold (\r -> Fold rb r rar) r0 rar
18:56:04 <shachaf> Fold a b = Cofree (a ->) b?
18:56:08 <mm_freak_> mstksg: Just x <|> _ = Just x
18:56:12 <edwardk> feed as (Fold rb r rar) = rb (F.foldl' rar r as)
18:56:17 <Tekmo> Driscoll: join
18:56:22 <ski> edwardk : ooc, where did you arrive at `Fold' from ?
18:56:23 <edwardk> so when as = [] then that is rb r  which
18:56:26 <mm_freak_> mstksg: for Maybe it's basically left-biased selection with fallback to Nothing
18:56:30 <edwardk> ski: the name was to copy tekmo
18:56:42 <Driscoll> Tekmo: would that turn Just ( Just 5 ) into 5
18:56:43 <edwardk> i'll likely switch to FoldL for the post because I'll be mixing in some lens code
18:56:50 <ski> edwardk : no, i mean the type, not the name of it
18:57:00 <Tekmo> Driscoll: No
18:57:06 <Tekmo> Driscoll: It would turn it into `Just 5`
18:57:11 <Driscoll> ok
18:57:15 <Driscoll> and Nothing would remain Nothing ?
18:57:18 <Tekmo> Driscoll: Right
18:57:21 <Driscoll> perfect ty
18:57:27 <edwardk> ski: its the non-list arguments to foldl'  and a final 'tweak' function that commonly gets used
18:57:28 <Tekmo> You're welcome!
18:57:29 <mstksg> mm_freak_: ah, so if i hold over it, and the accumular starts off as Nothing, it will stay nothing until the first Just, where it would then ignore al other Justs in the list
18:57:34 <mstksg> mm_freak_: but would it still have side effects?
18:57:36 <ski> edwardk : i've been pondering it, in the context of "pushy" lists and list loops
18:57:38 <edwardk> ski: that makes it a profunctor
18:57:53 <mm_freak_> mstksg: pick f = Maybe and review the type
18:58:00 <mm_freak_> the only possible effect is Maybe
18:58:04 <mm_freak_> i.e. Nothing
18:58:05 * ski still can't recall a simple definition of "profunctor" :/
18:58:06 <mstksg> mm_freak_: would it have to execute the effects to know <|> ?
18:58:16 <roboguy_> is there something like traverse that takes a function that returns a Maybe and only traverses until it gets a Nothing?
18:58:42 <mm_freak_> mstksg: don't think too much in effects…  just check the definition of Applicative and Alternative for Maybe
18:58:42 <mstksg> lots of questions on traversing with maybe's right now
18:58:46 <ski> roboguy_ : maybe `forever'
18:58:48 <edwardk> ski: contravariant in first arg, covariant in second
18:58:50 <mm_freak_> mstksg: it's pretty straightforward
18:59:08 <ski> edwardk : yeah, but istr people saying it was different from difunctor, somehow
18:59:29 <mm_freak_> mstksg: in fact define a custom Maybe and give it Functor, Applicative and Alternative instances…  that should help =)
18:59:30 <mstksg> is it that Just a <|> _ = Just a?
18:59:34 <mm_freak_> yeah
18:59:40 <mm_freak_> Nothing <|> x = x
18:59:48 <mm_freak_> Just x <|> _ = Just x
18:59:53 <mm_freak_> that's the full definition
19:00:22 <edwardk> ski: nope
19:00:50 <ski> edwardk : something with `Hom', or codomain being `Set' or something
19:00:51 <Tekmo> So then couldn't you just use `asum` in conjunction with `MaybeT`?
19:00:55 <roboguy_> ski: that doesn't really do a sort of mapping over a structure though
19:00:55 <mm_freak_> mstksg: in any case i like the Alternative solution…  it doesn't suffer from boolean blindness =)
19:00:59 <ski> edwardk : so, it's just difunctor ?
19:01:13 <edwardk> ski: difunctor, distributor, bimodule, etc. yes
19:01:26 <ski> roboguy_ : hm, i thought the `Maybe' was the structure
19:01:27 <edwardk> ski: they are all names for the same thing
19:01:33 <roboguy_> ski: I was thinking something kind of like (a -> Maybe (f a)) -> t a -> f (t a)
19:01:36 <ski> edwardk : ok
19:01:51 <shachaf> edwardk: So is Fold a just Cofree (a ->)?
19:02:09 <shachaf> (With a Nu representation?)
19:02:29 <mstksg> mm_freak_: it is not immediately obvious to me how to to extend findA from (a -> f b) to (a -> m (f b))
19:02:45 <mm_freak_> sentences with the uncapitalized word "just" in them tend to be the scariest ones in #haskell
19:02:51 <shachaf> @quote just
19:02:51 <lambdabot> frustrated says: <byorgey> that frustrated feeling that you are just not getting it is the feeling of your brain expanding =)
19:02:57 <shachaf> @quote just
19:02:57 <lambdabot> wootles says: quicksilver: i dont understand the haskell error messages, i just move brackets around until they go away... they make c++ template errors look like monosyllabic grunts :(
19:03:06 <mm_freak_> or perhaps "just a"
19:03:12 <shachaf> @quote just.a
19:03:12 <lambdabot> HipsterHacker says: Private Cloud is a just another way of saying "our shitty intranet".
19:03:19 <shachaf> @quote just.a\b
19:03:19 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
19:03:24 <mm_freak_> there we go =)
19:04:07 <shachaf> or is it an oplax functor?? the world may never be able to figure out which is which
19:04:22 <mm_freak_> mstksg: findM :: (Alternative f, Monad m) => (a -> m (f b)) -> [a] -> m (f b)
19:04:30 <mm_freak_> mstksg: but that one almost doesn't deserve an own function
19:04:47 <mm_freak_> also it's sufficient for m to be Applicative
19:05:24 <ski> roboguy_ : i'm not aware of anything similar
19:06:10 <ReinH> lmao
19:07:04 <mm_freak_> btw, i don't really buy the "a monad is just a monoid in the category of endofunctors"
19:07:11 <mm_freak_> not that it's wrong, but it's also not very useful =)
19:07:31 <spaceships> mm_freak_: what is better
19:07:38 <Tekmo> Kleisli category!
19:07:41 <mm_freak_> spaceships: a monad is a spaceship
19:07:41 <mstksg> mm_freak_: yeah, i see the type signature, but implementing it is what i'm worried about. but i'll give it a shot
19:07:50 <spaceships> mm_freak_: now we're talking!
19:08:02 <mm_freak_> mstksg: just try it out…  constraining yourself to the Applicative interface might actually make it easier
19:08:18 <mm_freak_> mstksg: hint:  you will need 'pure' and 'liftA2'
19:08:29 <roboguy_> ski: hmm. it seems like this keeps coming up for me: I want a way to do a sort of map over part of a structure and leave the rest alone (in this case a Vector)
19:08:55 <Tekmo> Can't you just use the `taking` lens or whatever it is called?
19:09:03 <roboguy_> and it would probably look nicest if the function being mapped decided when to stop
19:09:32 <Tekmo> I'll be it is something like `over (taking 10) f`
19:09:38 <ski> i suspect you can use some `StateT' trick to "update the function with `id'" when you reach `Nothing', so that the rest of the structure is only copied
19:10:21 <ski> hm, this reminds me of `parsimoniousFilter'
19:10:41 <roboguy_> maybe I should paste the (nonworking) code I have on the paste site
19:12:51 <lpaste> roboguy_ pasted “partial traversals” at http://lpaste.net/92385
19:13:23 <roboguy_> keep in mind, I don't know much about Lens yet so maybe that code isn't great at the moment
19:14:27 <Tekmo> roboguy_: You don't need lens to solve this
19:14:57 <roboguy_> Tekmo: yeah, but I thought I would use this opportunity to try to learn about them. Maybe this isn't a good place to do so?
19:15:20 <Tekmo> roboguy_: You'll learn more about `lens` by doing it the simple way, because that will teach you how to define your own lenses
19:16:16 <roboguy_> Tekmo: hmm, alright. Actually, I was thinking about trying to reimplement the basics of lens at some point to see if that would help
19:20:24 <bennofs> Hmm. Hackage is giving 500 Internal errors on package upload, but the upload still succeeds
19:21:03 <Tekmo> bennofs: It's been doing that for a long time
19:21:13 <tomboy64> i have to deal with bitfields in the size-range of 2^24x2^24 - working with arrays there kinda strikes me as wasteful
19:21:21 * hackagebot typeable-th 0.1.3 - Automatic deriving of TypeableN instances with Template Haskell  http://hackage.haskell.org/package/typeable-th-0.1.3 (BennoFuenfstueck)
19:21:22 <tomboy64> other container-suggestions?
19:22:20 <Tekmo> tomboy64: Are you familiar with bit vectors in Haskell?
19:22:31 <tomboy64> Tekmo: nope.
19:22:45 <Tekmo> tomboy64: If I remember correctly, if you use `Vector Bool` it gets translated to a bit vector under the hood
19:22:46 <tomboy64> that's exactly the kind of suggestion i was hoping for
19:23:06 <mm_freak_> tomboy64: 2^24 * 2^24?  as in 2^48 individual bits?
19:23:27 <tomboy64> mm_freak_: indeed
19:23:37 <Driscoll> so i've written a function that takes a list of Maybe's, and returns the first that isn't Nothing
19:23:40 <Driscoll> or returns Nothing
19:23:45 <mm_freak_> > 2^5
19:23:46 <lambdabot>   32
19:23:50 <Driscoll> its a few lines, but is there something built in that i could use instead?
19:23:52 <Sonarpulse> Is there any one one could make some sort of haskell type binary isomorphism and from there both Put Get instance could be derived?
19:23:53 <Tekmo> Driscoll: There's already a function for that
19:23:54 <mm_freak_> you need 32 terabytes of RAM to store all of them
19:24:06 <Driscoll> i figured as such
19:24:07 <tomboy64> mm_freak_: hm
19:24:15 <mm_freak_> tomboy64: so you should use some additional information to compress the bit vector
19:24:22 <heatsink> I think msum does that
19:24:28 <tomboy64> well, it's sparse stuffs
19:24:32 <mm_freak_> for example if it's a sparse bit vector then an IntSet may be a better option
19:24:34 <Tekmo> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Foldable.html#v:asum
19:24:52 <Tekmo> Or `msum`, like heatsink said
19:24:58 <Driscoll> cool i'll look into it
19:25:00 <mm_freak_> tomboy64: mind explaining the application?
19:25:13 <tomboy64> mm_freak_: http://projecteuler.net/problem=287
19:25:15 <tomboy64> ^^
19:25:37 <tomboy64> i kind of figured it out, i just lack the tools yet
19:26:44 <mm_freak_> tomboy64: as far as i see you don't really need to construct the bit vector itself
19:26:53 <Platz> watchin' Meijer's channel 9 videos
19:27:12 <tomboy64> mm_freak_: yup. it didn't really occur to me that it would really be 32 terabytes
19:27:37 <tomboy64> but yes, chunking it down to kinda small elements should do the trick
19:28:09 <mm_freak_> tomboy64: that's not the point…  use the encoding at the top to define D_24
19:28:36 <heatsink> Given that it's a Project Euler question, there's going to be a way to get the answer without enumerating the whole data structure.
19:28:38 <mm_freak_> if your algorithm gets into memory problems, there is likely a smarter solution =)
19:29:07 <tomboy64> yup.
19:29:42 <tomboy64> basically it's "are there both black and white bits in this chunk? yes? split it up!"
19:29:59 <mm_freak_> there, you figured out most of it ;)
19:30:46 <tomboy64> brute-force just is appealing cause the last 2 problems in the 200-area i solved within 30 minutes via bruteforce
19:30:51 * tomboy64 shrugs
19:30:56 <tomboy64> let's get to work
19:31:05 <mm_freak_> doesn't sound appealing to me
19:31:29 <mm_freak_> PE solutions shouldn't really compute for more than a few seconds, perhaps a minute
19:31:30 <heatsink> Is that image just a black triangle in one corner of the box?
19:32:03 <tomboy64> heatsink: no, it's a circle in the vertical middle in the left half
19:32:14 <mm_freak_> tomboy64: in fact they chose the image to be large enough specifically to prevent anyone from bruteforcing ;)
19:32:38 <tomboy64> ^^ they usually do
19:33:17 <mm_freak_> but if you like algorithms that actually need to perform some computation to get a result i can give you a challenge later =)
19:34:18 <tomboy64> hahaha
19:34:27 <tomboy64> it's 4.30 am
19:34:42 <tomboy64> i'll brood a little more over that, then i'm off to bed
19:34:56 <mm_freak_> it would be a small crypto challenge…  not of the "decrypt this" kind though, but something that requires some actual thinking as well as some CPU time
19:35:32 <heatsink> I see, didn't notice the _^2
19:36:04 <tomboy64> hehehe had to work on the "xor" decryption
19:36:45 <tomboy64> i didn't reckon them using ( and ) - ( as the very first character even. actually had to read through quite some garbage to solve it.
19:38:51 <joelteon> @pl foo >>= \h -> bar h >> baz
19:38:55 <lambdabot> flip ((>>) . bar) baz =<< foo
19:38:55 <lambdabot> optimization suspended, use @pl-resume to continue.
19:39:20 <shachaf> roboguy_: I can still give my explanation of lens in -overflow later if you're interested.
19:40:06 <roboguy_> shachaf: sure! i'm always interested in learning about new programming concepts (well, new to me anyway)
19:40:45 <shachaf> OK. After I get home, so in a little bit.
19:41:01 <mm_freak_> https://www.mysterytwisterc3.org/en/challenges/level-ii/smartcard-rsa ⇐ my favorite challenge
19:41:08 <mm_freak_> solved it in haskell a few months ago
19:41:21 * hackagebot typeable-th 0.1.4 - Automatic deriving of TypeableN instances with Template Haskell  http://hackage.haskell.org/package/typeable-th-0.1.4 (BennoFuenfstueck)
19:42:18 <Sonarpulse> What is the most cannonical way to put/get floats with Data.Binary (or Data.Cereal if it is easier)
19:44:28 <edwardk> Sonarpulse: heh to give up and use bytes, which offers serialization of floats/doubles in a way that doesn't completely suck ;)
19:44:48 <edwardk> and which will then serialize it with either =)
19:45:10 <edwardk> the serialization of floats/doubles in haskell drives me nuts
19:45:44 <edwardk> we took a pretty standard ieee thing and turned it into something godawful in the name of portability to platforms that don't exist and that we don't support
19:45:49 <ab9rf> from what i've seen a cannon may actually be a better solution :)
19:46:43 <shachaf> @quote edwardk ieee
19:46:43 <lambdabot> edwardk says: type level ieee floats are a crime against nature. i had to implement them in c++ for template meta programming once. never ever again
19:47:02 <edwardk> they can be a crime against nature. what we have is worse ;)
19:47:18 <Sonarpulse> haha
19:47:24 <Sonarpulse> unforrunately
19:48:01 <Sonarpulse> As I am implementing an existing protocol, I think I am stuck with IEEE
19:48:26 <mikeplus32> http://i.imgur.com/Qp7Dy3Q.png vacuum-cairo sure is neat
19:48:48 <Sonarpulse> ah oh I see the normal haskell way is bad
19:48:48 <edwardk> Sonarpulse: seriously though, bytes gives you big-endian ieee754 floats/doubles as the serialization format for them
19:49:11 <Sonarpulse> ah, so bytes /is/ what I need, as it does it sanely and in accordence with the standard
19:49:13 <edwardk> Sonarpulse: if you need the other endianness then you're in for more pain
19:49:14 <Sonarpulse> bytes it is then!
19:49:22 <Sonarpulse> oh
19:49:25 <Sonarpulse> yeah I need LE
19:49:32 <Sonarpulse> this isn't a proper protocol
19:49:41 <Sonarpulse> just somebody sending off some C structs
19:49:49 <ReinH> edwardk: how goes it?
19:50:13 <edwardk> Sonarpulse: i'd take a patch that added a LittleEndian newtype wrapper and instances for it applied to things like Float
19:50:18 <edwardk> so you can serialize LittleEndian Float
19:50:26 <edwardk> ReinH: quite well!
19:50:39 <Ghoul_> Hey, that's a very cool idea
19:50:45 <edwardk> the folds for crc's turned comonadic
19:50:56 <Sonarpulse> hmmm
19:51:06 <tomboy64> is hackage down?
19:51:12 <tomboy64> !hayoo?
19:51:13 <lpaste> edwardk revised “crc folds for bennofs”: “comonadic folds” at http://lpaste.net/92386
19:51:15 <mikeplus32> yup seems so
19:51:16 <tomboy64> hayoo, too?
19:51:18 <Ghoul_> instance Serializable a => {Little,Big} a where :)
19:51:22 <edwardk> ReinH: that
19:51:26 <Sonarpulse> It's stuff like this were the boundary between Storable and Binary/Cereal/Bytes gets blurry
19:51:53 <edwardk> ReinH: notice that L is a version of an EnvT'd Store like the original world proposal ;)
19:52:06 <edwardk> ReinH: i figured this would let me tie the knot pedagogically
19:52:16 <bennofs> tomboy64: hackage is not down for me
19:52:17 <ReinH> edwardk: what's L?
19:52:28 <edwardk> ReinH: its a type for a 'left fold'
19:52:29 <shachaf> Cofree . (->)!
19:52:51 <ReinH> ah!
19:53:00 <edwardk> L :: (r -> b) -> r -> (r -> a -> r) -> L a b       -- its the function to apply when we're done, the 'zero' value to start with and then the foldl' step
19:53:08 <ReinH> oh, per
19:53:11 <edwardk> that forms a profunctor, applicative, comonad, etc.
19:53:20 <edwardk> per [1,2,3] (total / count)   ==> 2.0
19:53:24 <ReinH> clever girl
19:53:46 <edwardk> the use of foldl' for it was tekmo's idea
19:53:52 <edwardk> the comonad was my insight just now
19:53:54 <ReinH> wait what
19:54:00 <elliott> hey!
19:54:00 <ReinH> how does that work?
19:54:09 <elliott> I've been telling people about Cofree ((->) a) for like a year.
19:54:12 <elliott> just nobody has listened.
19:54:22 <edwardk> elliott: well the cofree ((->) a) moore machine is well understood
19:54:34 <ReinH> well understood... by you and elliot ;)
19:54:34 <elliott> sure.
19:54:36 <edwardk> elliott: i've been using that for a lot longer =)
19:54:49 <elliott> but it's, like, the same thing, and stuff.
19:55:28 <edwardk> its very similar.
19:55:28 <edwardk> i could switch to the cofree version here
19:55:35 <edwardk> and just make this a moore machine
19:55:38 <edwardk> i kinda like that
19:55:39 <shachaf> It's just a Nu encoding of it.
19:55:55 <shachaf> It's the same type.
19:56:37 <elliott> edwardk: I even have a file which calls it Fold and has the average example!
19:56:38 <elliott> somewhere.
19:56:38 <edwardk> elliott: ok. i'll go cofree, maybe after connecting L to tekmo's fold post
19:56:48 <elliott> it even has a .cabal file.
19:56:52 <elliott> that's basically a patent.
19:56:53 <edwardk> then showing that the moore machine is nicer
19:57:19 <elliott> the nice thing is that it reduces really simply to the cofree version
19:57:22 <edwardk> yeah
19:57:51 <elliott> you just strip out the "existential antipattern" part and substitute in a recursion
19:58:00 <shachaf> Moore already has these instances and everything. Is there a benefit to this type over it?
19:58:15 <ReinH> shachaf: maybe pedagogically?
19:58:55 <edwardk> elliott: agreed
19:59:00 <elliott> no, reusing Moore is fine
19:59:06 <elliott> I just didn't realise it was a moore machine when I called it Fold.
19:59:21 <edwardk> yeah i'll use it as moore rather than the cofree.
19:59:24 <elliott> edwardk: another nice thing is that you can decide strictness at the actual use site
19:59:27 <elliott> rather than in the fold definitions
19:59:38 <elliott> although that breaks down if your folds need to be internally strict
19:59:40 <edwardk> and the fact that moore forms a comonad was long since known, so i feel better about that comonad too
19:59:53 <elliott> is it a ComonadApply?
20:00:00 <edwardk> it should be if it isn't
20:00:17 <edwardk> it is
20:00:25 <Sonarpulse> edwardk: so right now, there is no putFloatBE or anything like that
20:00:32 <Sonarpulse> just an instance for float
20:00:33 <edwardk> Sonarpulse: patch!
20:00:38 <Sonarpulse> so the BE is implicit
20:00:39 <ski> edwardk : which form was the `Moore' one ?
20:00:42 <edwardk> Sonarpulse: i'm not wedded to the status quo
20:00:56 <edwardk> data Moore a b = Moore b (a -> Moore a b)
20:00:57 <shachaf> ski: http://hackage.haskell.org/packages/archive/machines/0.2.3.1/doc/html/Data-Machine-Moore.html
20:01:00 <Sonarpulse> Just double checking I now waht the status quo is before I make a patch
20:01:03 <Sonarpulse> :)
20:01:19 <ski> edwardk : ok, aka synchronous stream processor
20:02:06 <edwardk> Sonarpulse: sure. we wrote it BigEndian because S11001001 likes network order =P
20:02:14 <edwardk> ski: yeah
20:02:33 <ski> .. though i rather think of the `r -> b' as "zero" :)
20:02:42 <Sonarpulse> Ok
20:02:49 <Sonarpulse> Well, this is definitely a change
20:03:01 <Sonarpulse> but I forked/rewrote an endianness library
20:03:03 <shachaf> Moore a b = (b, Mealy a b)
20:03:05 <Sonarpulse> pretty simple
20:03:19 <Sonarpulse> where you just tag values with a phantom type to show the endianess
20:03:31 <Sonarpulse> If bytes used that
20:03:53 <ski> elliott : i think the existential is helpful here
20:03:54 <Sonarpulse> stuff like putWordLE would be as simple as
20:04:09 <Sonarpulse> put . toLE
20:04:13 <Sonarpulse> with a type constraint
20:04:44 <Sonarpulse> write now it does the conversions with some Data.bits stuff
20:04:47 <ski> hm, perhaps one could recall it as `Moore' being odd and `Mealy' being even ?
20:05:23 <Sonarpulse> but I can ifdef that now that GHC is has byteSwap as a new primop
20:05:31 <elliott> ski: I don't agree
20:05:35 <elliott> it's easy to turn the existential form into the moore version
20:05:53 <ski> elliott : yes, but i suspect the existential form can be more efficient
20:06:34 <elliott> when I wrote it the isomorphism seemed operationally trivial
20:06:40 <elliott> the existential r just disappears into the closure
20:07:09 <ski> exactly
20:07:13 <ski> i want to undo the closure
20:07:35 <ski> (cut open that loop/recursion)
20:09:50 <Sonarpulse> library is http://hackage.haskell.org/package/typesafe-endian
20:10:01 <shachaf> I wonder whether there are other similar uses for Nu representations of things.
20:10:43 <ski> i tried for a binary tree thing
20:11:02 <ski> couldn't interpret the result, though
20:12:46 <Ghoul_> hah
20:12:52 <Ghoul_> the package uses unicode symbols everywhere
20:13:20 <mlamari> Dunno if this would be helpful to any haskell/emacs/flycheck users https://github.com/flycheck/flycheck/pull/205   <-- augments it when viewing a file to backtrack to any .cabal file in a higher up directory, and populate -i based on that directory.  The core feature for this hook was added to flyCheck; but the pull request contains the scrap to use it.
20:21:32 <smith_> Is there a generalized way of doing something like "case x of Nothing -> ..." where x :: Maybe, but for all Monad?
20:21:45 <smith_> As in, matching for "failing" and "succeding" cases.
20:22:02 <shachaf> There are no "failing" and "succeeding" cases for monads in general.
20:22:12 <shachaf> But maybe you want Alternative/MonadPlus.
20:23:04 <smith_> If I do "do x <- someMonad" and someMonad doesn't match, then do will fall through. Is there a way I can detect / respond to that case?
20:23:39 <Sonarpulse> edwardk: I saw the CBits file? How do you know what endianness that is?
20:23:46 <shachaf> What does "match" mean?
20:24:57 <mm_freak_> smith_: (c >>= matchingCase) <|> nonMatchingCase
20:25:05 <mm_freak_> provided that your monad is an Alternative
20:25:24 <shachaf> Maybe, but I think that's too much guesswork.
20:25:25 <mm_freak_> where "matching" should better be read as "non-empty"
20:25:47 <shachaf> I don't know what smith_ meant and I'm not sure they did either. :-)
20:25:49 <carter> tel: I"m done with the low level bits of vector-vectorize!
20:25:56 <mm_freak_> true
20:26:29 <applicative> smith_: keep going, there's a couple more pieces of information needed to figure out what you want
20:27:50 <smith_> Maybe I've got this wrong in my head, but if I have `monadFunc >>= otherFunc` and the output of monadFunc doesn't "match" otherFunc, then the result from monadFunc doesn't get passed to otherFunc. Right?
20:28:18 <jmcarthur> smith_: what do you mean by "match"?
20:28:25 <mm_freak_> smith_: that doesn't really make sense
20:28:30 <applicative> well, 'monadFunc' 'returns' a definite value, which can match various patterns according to the type returned
20:29:04 <barrucadu> Woo, my really stupid djinn-like thing works!
20:29:39 <barrucadu> The code is a mess, and it's very limited at the moment, but it can successfuly derive things like id, const, fst, snd, uncurry, and flip :D
20:30:21 <applicative> > [show x | Just x <- [Just 0, Just 1, Nothing, Just 2]]
20:30:22 <lambdabot>   ["0","1","2"]
20:31:12 <edwardk> Sonarpulse: i assume the endianness of the floats on your platform matches the endianness of an long on your platform
20:31:28 <edwardk> er a long
20:31:41 <joefiorini> I'm having trouble importing Control.Monad.IO.Class in a snap app; saying I need to add 'transformers'
20:31:44 <edwardk> Sonarpulse: the putWordbe stuff is what cares about endianness
20:32:11 <jmcarthur> joefiorini: you need to add transformers to the build-depends field of your .cabal file
20:32:29 <joefiorini> jmcarthur: I've used it before without doing that
20:32:41 <applicative> smith_: by contrast, something like this just goes wrong
20:32:43 <applicative> > [Just 0, Just 1, Nothing, Just 2] >>= \(Just x) -> show x
20:32:44 <lambdabot>   "01*Exception: <interactive>:3:39-57: Non-exhaustive patterns in lambda
20:32:45 <jmcarthur> maybe you weren't using a cabal project then
20:32:51 <jmcarthur> but it seems you are now
20:33:00 <joefiorini> I haven't used haskell without cabal :)
20:33:18 <jmcarthur> in any case, i see no way to use a module without its package ;)
20:33:36 <applicative> hm, is transformers it listed under 'build-depends'
20:33:46 <applicative> or however you type it
20:33:58 * jmcarthur can't parse applicative's sentence
20:34:12 <joefiorini> haha, definitely understood, but when Iadd it it rejects command-3.0.3
20:34:15 <applicative> yeh, is transformers in his build-depends
20:34:21 <applicative> was my question
20:34:53 <applicative> joefiorini: is that something about the version of command or transformers?
20:34:59 <joefiorini> applicative: it is now, but it conflicts with profunctors I think?
20:35:14 <joefiorini> sorry, not command, comonad
20:35:19 <applicative> oh comonad.
20:35:57 <joefiorini> I've only added a couple dependencies since snap init
20:36:30 <applicative> comonad is one of them?
20:36:36 <joefiorini> nope
20:36:43 <joefiorini> snaplet-postgres-simple
20:36:51 <joefiorini> postgres-simple & now transformers
20:36:54 <Sonarpulse> edwardkL ah, didn't realized it "cancelled itself out" like that
20:37:02 <Sonarpulse> *edwardk
20:37:46 <joefiorini> here's my cabal file https://gist.github.com/6402174
20:38:01 <smith_> This is a contrived example, but hopefully it demonstrates what I mean: http://lpaste.net/92390
20:38:04 <edwardk> comonad causes problems where?
20:38:09 <edwardk> or am i misreading?
20:38:19 <edwardk> Sonarpulse: yeah
20:38:33 <hari_> Why does data Token = TokenNum Num not work?
20:38:44 <geekosaur> what is "not work"?
20:38:45 <monochrom> who is Num?
20:38:49 <geekosaur> and that
20:38:51 <geekosaur> ohhh
20:38:56 <hari_> data Token=TokenNum Num
20:38:56 <geekosaur> Num is a typeclass
20:38:58 <joefiorini> edwardk: trying to figure it out
20:39:00 <hari_> OK
20:39:01 <geekosaur> Num is not a type
20:39:12 <applicative> do we need this if flag old-base nonsense anymore?
20:39:37 <hari_> Data Token = TokenNum Double | TokenNum Int
20:39:43 <hari_> data Token = TokenNum Double | TokenNum Int
20:39:49 <monochrom> then you have two "TokenNum"s
20:40:03 <joefiorini> applicative: I might delete it
20:40:41 <hari_> Suppose I want to define Token as either a Token with a numeric type of integer or double.
20:40:43 <geekosaur> hari_, what are you trying to accomplish with this?
20:40:59 <geekosaur> then you need a separate constructor for each case
20:41:02 <edwardk> joefiorini: k lemme know if it is
20:41:14 <hari_> I am trying to define a token as either a token with a type of number
20:41:20 <monochrom> then it is "data Token = Its_an_Int Int | Its_a_Double Double
20:41:47 <hari_> Can I not generalize for any type of class Num?
20:42:04 <monochrom> that depends on what you're willing to lose
20:42:27 <smith_> I suppose Alternative works, but it still confuses me how "do" and ">>=" work without it.
20:43:17 <monochrom> there is a potion. it lets you generalize. but you will lose the original type. you only know "its type is a Num", but you will not know which type. are you willing to drink this potion?
20:43:20 <hari_> So I could use data Token = TokenInt Int | TokenDouble Double
20:43:32 <leroux> Anyone know a way to do `(a -> b) -> [a] -> [(a, b)]` other than with map.
20:43:32 <monochrom> oh, you will also lose your mermaid tail
20:43:59 <geekosaur> leroux, what's wrong with map?
20:44:01 <leroux> :t \f -> map \x -> (x, f x)
20:44:01 <lambdabot> parse error on input `\'
20:44:03 <leroux> Nothing.
20:44:08 <leroux> :t (\f -> map \x -> (x, f x))
20:44:09 <lambdabot> parse error on input `\'
20:44:15 <Iceland_jack> leroux: \f as -> [ (a, f a) | a <- as ] ?
20:44:31 <leroux> Still a map.
20:44:36 <leroux> Whatever, I was just wondering if there was a better way
20:44:44 <leroux> I was expecting to find a lib function that does it.
20:44:59 <applicative> joefiorini: it's fine if i delete the constraint on transformers
20:45:12 <geekosaur> does every trivial operation have to have a library function defining it?
20:45:16 <joefiorini> applicative: how do you delete the constraint? (sorry, still new)
20:45:41 <leroux> geekosaur: Fair enough.
20:45:50 <joefiorini> applicative: think I got it
20:45:58 <applicative> oh wait could it be theres a curlicue where transformers == 3.0 doesn't cover   transformers-0.3.0.0 which is what i have
20:46:19 <applicative> you write  transformers == 0.3.*
20:46:25 <applicative> or am I confused
20:46:43 <jmcarthur> :t map . (id &&&)
20:46:44 <lambdabot> (a -> c') -> [a] -> [(a, c')]
20:46:45 <applicative> its as if 3.0.0.0 was slightly larger than 3.0
20:46:54 <Iceland_jack> jmcarthur: Still map! /s
20:46:58 <jmcarthur> :t fmap . (id &&&)
20:46:58 <lambdabot> Functor f => (a -> c') -> f a -> f (a, c')
20:47:00 <jmcarthur> :P
20:47:01 <Iceland_jack> heh
20:47:02 <joefiorini> I got it just by deleting the version
20:47:26 <geekosaur> if you're using it so ofte that you feel the need for a function, write one. While you're at it, use something mroe descriptive than a tuple.
20:47:28 <applicative> oh cool; i think transformers == 0.3.* should work
20:47:39 <joefiorini> yeah, that looks good, thanks for the help :)
20:47:46 <Iceland_jack> I think the question was actually ‘is there a library function that …’ rather than ‘is there a way to write … without map’
20:48:06 <pentace> smith_: What's confusing you exactly?
20:48:46 <Iceland_jack> But it's not a very useful function an like geekosaur rightfully pointed out, trivial to define
20:49:01 * Iceland_jack feels like the use of tuples is often suspect anyway
20:49:40 <thoughtpolice> AKA the 'Fairbairn threshold', the point at which the name for a combinator isn't worth simply re-deriving it
20:49:53 <thoughtpolice> (thanks to edwardk for pointing me to that term :P)
20:50:07 <Iceland_jack> Interesting term
20:50:21 <smith_> pentace: If I have, say, `x :: String ->  Maybe String`, and a do clause with `y <- x "test"`, then if x returns Nothing, the rest of the code is skipped and the whole thing returns Nothing.
20:50:24 <thoughtpolice> it's named after Jon Fairbairn
20:50:28 <smith_> That's my understanding of it, anyway.
20:50:49 <pentace> smith_: Yes, but only for the Maybe monad
20:50:50 <Iceland_jack> thoughtpolice: Now I wonder if the word itself pass the ‘Fairbairn threshold’? :)
20:51:33 <Iceland_jack> *passes
20:51:42 <pentace> smith_: That's how x >>= y is defined for Maybe, if x returns Nothing, there's no need to evaluate y
20:51:53 <shachaf> If x *is* Nothing.
20:52:07 <pentace> yes
20:52:16 <Iceland_jack> > do a <- Just 10; return (show 10)
20:52:17 <lambdabot>   Just "10"
20:52:21 <Iceland_jack> > do a <- Nothing; return (show 10)
20:52:22 <lambdabot>   Nothing
20:53:03 <applicative> the 'fairbairn convention' is, not to exceed the fairbairn threshhold
20:53:14 <applicative> oh smith_ is back good
20:53:42 <smith_> pentace: Okay. So if I'm using the Failure monad, for example, that can be transformed to Maybe and used, but at that point you lose the original information from the failure case.
20:54:16 <pentace> Failure = Either String?
20:54:37 <applicative> joefiorini: I should have said that the problem was simply that transformers-3.0 doesn't exist.
20:54:52 <joefiorini> applicative: I got that, haha, a little confusing
20:54:59 <joefiorini> but makes sense
20:55:06 <smith_> Failure is http://www.haskell.org/haskellwiki/Failure -- you have `Failure <error data type> <success result>`, which can transform into Maybe, Either, etc.
20:55:53 <smith_> pentace: I'm trying to write a function with :: (Monad m) => [(a -> m b)] -> a -> m b, which tries all of the functions in the list until it gets one that "succeeds", and returns with that; or returns the negative response if they all fail.
20:56:14 <applicative> so transformers > 3.0 should work too I think, joefiorini
20:56:16 <smith_> If I use Maybe here, and I use that with, say, Failure, I get back Nothing and lose that error datao n failure.
20:56:19 <smith_> data on*
20:56:35 <Iceland_jack> smith_: Oh I've been wondering about such a monad
20:56:42 <pentace> smith_: What would be "failure" if m = IO?
20:56:53 <joefiorini> applicative: so 3.0 < 3.0.0.0? interesting
20:57:46 <smith_> pentace: See, I don't know. I'm a bit mixed up.
20:58:00 <applicative> joefiorini: i think thats right, and was getting in the way of my giving a clearer explanation above
20:58:37 <smith_> I suppose if there is no "failure" case then everything would pass through.
20:58:59 <pentace> smith_: You have to restrict m to another type class that provides something like failure checking
20:59:36 <smith_> pentace: That's what I was afraid of. I didn't want to tie the code to that one Failure package, though.
20:59:37 <applicative> joefiorini: no it doesn't work, there's some mistake in the picture i was deriving from the phenomena; anyway the main facts are clear enough...
20:59:50 <joefiorini> yep, 3.0.* worked well enough
21:00:01 <pentace> smith_: Why don't you stick with Maybe for m?
21:01:19 <smith_> pentace: Because then, if I use it with Failure, I lose the error data and instead just get Nothing back.
21:02:02 <smith_> I suppose Either would work, but then (I believe) that would make the function incompatible with Maybe.
21:03:31 <pentace> I guess you simply want something like
21:03:43 <pentace> @ty \fs x -> mapM ($ x) fs
21:03:44 <lambdabot> Monad m => [a -> m b] -> a -> m [b]
21:05:06 <pentace> or maybe not :P
21:05:50 <smith_> Doesn't seem to work, no.
21:08:19 <hari_> If I want to write a simple parser (for learning purpose) should I use the Haskell Parsec or can I do a simple parser in functional style without external lib?
21:08:43 <Fuuzetsu> Are the ‘front page’, property pages for packages generated by Hackage? E.g. this one http://hackage.haskell.org/package/QuickCheck . I thought Haddock was generating these as well but I can't find anything in the source that would indicate that.
21:09:21 <Fuuzetsu> Oh, ‘Produced by hackageDB and Cabal 1.14.0’, guess that answers it.
21:09:27 <pentace> smith_: Without writing your own type class, the only alternative I can think of is Alternative
21:09:52 <applicative> hari the old standard parser type is pretty easy to implement in 10 lines
21:10:42 <carter> Fuuzetsu have you looked at the hackage2 stuff yet? Its really cool!
21:11:11 <applicative> hari newtype Parser a = Parser {runParser :: String -> [(a,String)]}; defined Functor, Monad, Applicative and Alternative
21:11:20 <applicative> define them, rather
21:11:35 <mlamari> Is there a way to find redundant packages in a cabal file?
21:12:13 <hari_> applicative, so what are teh disadvantages of implementing a simple parser in pure style without monad
21:12:18 <Fuuzetsu> carter: I had a very brief look at how it looks. I'm sure it will be deployed by 2020!
21:12:18 <enthropy> Fuuzetsu: the description field in the .cabal file haddock markup that hackagedb somehow generates
21:12:41 <Fuuzetsu> mlamari: move your cabal file out of the way, do ‘cabal init’ and see what packages it thinks it needs. Then remove any that don't seem to appear.
21:13:33 <applicative> hari_: oh without a monad, or an explicit one? that's possible too, type Parser a = String -> [(a,String)] but you would immediately want similacra of the monad applicative and alternative methods
21:13:58 <carter> hopefully 2013 fall or early winter 2014 :)
21:14:19 <hari_> Bearing in mind I'm still learning though. is it possible to write a parsing program simly using functions and pattern matching?
21:15:58 <hari_> What benefits do monad approach to parsing give? Or am I missing something ?
21:16:14 <scshunt> hari_: it expresses very well, because the monadic value is the result of the parse
21:16:29 <applicative> hari_: it's great; do notation for example is pretty lucid; so is the so-called applicative style
21:17:00 <tac> hari_: What's amazing isn't that parsing in Haskell is monadic. What's amazing is that it's an in-language library
21:17:17 <tac> rather than a 3rd party application you have to run before the rest of your program.
21:17:28 <hari_> applicative, scshunt, tac thanks
21:17:40 <applicative> hari_: it really isnt any different from 'simply using functions and pattern matching', you just put isolate the kind of function in question and put a name on it so you can associate it with familiar 'methods'
21:18:12 <applicative> hari_: the textbook by hutton basically does what you are talking about if I remember
21:18:39 <hari_> applicative, I own a copy of Real World Haskell.
21:19:16 <hari_> One of the things I find confusing about the documentation is that it doesn't really explain the steps involved very well.
21:20:04 <tac> hari_: which documentation are you referring to?
21:20:16 <applicative> it's irritating parsec isnt in scope with lambdabot; its really idiot simple -- if you leave out the universal complexities involved in parsing and parsing theory
21:20:17 <hari_> I am talking about the tutorials on haskell website.
21:20:29 <tac> The tutorials on haskell.org?
21:20:37 <hari_> tac, yes
21:20:52 <Sonarpulse> edwardk: I'll try to submit a patch tomorrow
21:20:53 <tac> Those very so incredibly in quality, it wouldn't even make sense to treat them as a cohesive single thing
21:21:23 <tac> especially stuff on the Haskell wiki. Most of it is outdated and lots of it was half-baked to begin with.
21:21:34 <hari_> It assumes some knowledge of functional programming which makes it tough for beginners to follow some of the explanations. I agree though, that I am probably too much of a beginner to digest
21:21:52 <edwardk> @tell sonarpulse thanks
21:21:52 <lambdabot> Consider it noted.
21:21:53 <applicative> > char x "" = []; char x (y:ys) = if x == y then [(y,ys)] in char 'c' "colorado"
21:21:54 <lambdabot>   <hint>:1:11: parse error on input `='
21:21:55 <hari_> I found LYAH good to a point and then it also becomes very tough very quickly.
21:21:57 <applicative> bahh
21:22:09 <applicative> > char x "" = []; char x (y:ys) = if x == y then [(y,ys)] else [] in char 'c' "colorado"
21:22:10 <lambdabot>   <hint>:1:11: parse error on input `='
21:22:21 <applicative> pardon moronism
21:25:12 <applicative> hari_: here is the 'classic' hutton-meijer parser module http://lpaste.net/92392
21:27:04 <applicative> you can see that it was formerly written with 'monad comprehensions'
21:28:21 <hari_> applicative, thanks. Probably a bit over my head at the moment though.
21:29:07 <applicative> sat p            = [c | c <- item, p c]
21:29:17 <tertl3> is that something similar to Parsec?
21:29:37 <tertl3> seems to be
21:31:44 <applicative> tertl3: yes, Parsec attributes itself to the inspiration of Hutton and Meijer see http://hackage.haskell.org/packages/archive/parsec/2.0/doc/html/Text-ParserCombinators-Parsec.html
21:31:50 <mauke> shachaf: that was because people were annoyed they got a dependency on containers, dlist and old-locale just for a one line class
21:32:09 <tertl3> oh nice
21:32:57 <tertl3> hari if you want to see it in action Ive been going over this some lately http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
21:33:11 <tertl3> it makes more sense to see it applied to something
21:33:30 <mlamari> Has anyone ever done a monadic do-hickey for inter-language communication with ownership issues resolved?  Basically, that the haskell could take a reference to something in language X, maybe ostensibly use it; but release it in an orderly manner on last touch. . . I don't mean depending upon the GC; but upon some monadic thing explicitly releasing.
21:38:18 <hari_> tertl3, thanks.
21:44:43 <applicative> hari_: here's a really dumb date parser in the 'monadic style' http://lpaste.net/92393
21:45:25 <applicative> it would be the same if I imported Text.ParserCombinators.Parsec and maybe a couple other parsec modules?
21:45:41 <applicative> but it imports ParseLib from hutton and meijer
21:46:50 <applicative> as you can see, in a simple case like this, you can read it aloud and it immediately makes sense
21:48:59 <applicative> oh my example parse dates "11/23/1 12.12.12 23/32/2" didn't use the spacing i was pointlessly allowing
21:49:19 <applicative>  parse dates "11/23/1 12 . 12 . 12 23 / 32 / 2" --> [([(11,23,1),(12,12,12),(23,32,2)],"")]
21:55:22 <hari_> applicative, thanks. That example is much simpler for my level of understanding
21:56:05 <applicative> anyway, if you try with parsec -- there's plenty of genuinely talented parsers who frequent this channel and can explain curiosities
21:56:42 <hari_> I've actually done some parser generator in Flex/Bison.
21:56:47 <applicative> there are a few build problems with the demos in Real World Haskell; people can quickly instruct  you what needs changed
21:57:13 <hari_> I might try those examples with Haskell.
21:57:42 <shachaf> mauke: Looks like people get annoyed either way.
21:57:56 <shachaf> edwardk: You could just import one of the dependency packages, presumably.
22:00:11 <mauke> if you're just using the class, you can depend on data-default-class
22:00:18 <mauke> and it's smaller than the old version
22:01:26 <applicative> hari_: there is also the famous parsec manual which is out of date, and presupposes a fair grasp of parsing theory in general; most of its examples will work with a little coaxing. the pragma {-LANGUAGE NoMonomorphismRestriction-} will come in handy in either case since the Parsec-3 types are very abstract and dont like it when there are no signatures
22:02:10 <hari_> applicative, I am a bit rusty with the theory of context free grammar
22:02:23 <hari_> Must go back and brush up the concepts again I guess.
22:03:28 <applicative> well you'll see if you try. there are also some very fast parser libraries like attoparsec for the string and bytestring types, which follow the same general format, but sticking to Parsec's old string parsing modules is good for starting with
22:03:52 <applicative> i meant attoparsec is for the Text and ByteString types, not for String
22:04:22 <edwardk> shachaf: well, i don't need default any more, so meh
22:04:31 <hari_> applicative, thanks. I am now revisiting bison to see how I actually build the context free grammar.
22:04:58 <edwardk> my usecases for the class were always minimalist
22:06:25 <tomboy64> mm_freak_: i managed to hack up a nice algo, it still spits out garbage. something ~76000. i found an example in their forum for D5 - which should give 499, but for me it gives 128 - even with a revised scanning algorithm (all borders, instead of just the corners). so i guess i'm gonna sleep over it and tomorrow it will have solved itself.
22:08:25 <applicative> hari_: it occurs, a search like 'site:lpaste.net "import Text.ParserCombinators.Parsec"' reveals some simple examples, along with complicated ones, similarly for github.com
22:09:18 <hari_> applicative, right.
22:10:04 <hari_> parsing was actually trickier than I remembered. Flex/Bison make it look so simple though.
22:14:13 <enthropy> are there alternatives classes/libraries to Binary that also allow an ascii-format output?
22:16:59 <satc> @pl \a -> f a + g a
22:16:59 <lambdabot> liftM2 (+) f g
22:19:33 <Iceland_jack> enthropy: Encode output of binary in base64?
22:24:36 <enthropy> Iceland_jack: that's not really what I'm looking for
22:25:48 <enthropy> say   put 12345  could either be  "12345\n", or the 4 bytes that it takes to store an int
22:26:25 <Iceland_jack> > show 12345 -- ;)?
22:26:26 <lambdabot>   "12345"
22:26:35 <Iceland_jack> In all seriousness, I'm not familiar with such a library
22:30:54 <ReinH> mauke: damned if you do...
22:31:36 <ReinH> Iceland_jack: well, if you could expect read . show = id to hold...
22:31:48 <ReinH> I know edwardk would prefer if it did
22:33:02 <Iceland_jack> That's why you would only use it for things where (read ∘ show) does hold and then wait for Haskell to add a PrettyPrint type class to the standard!
22:35:00 <ReinH> Iceland_jack: definitely. I'd like something like "inspect" or pretty print so show isn't overloaded to also be "display in ghci"
22:35:58 <Iceland_jack> Absolutely, too bad many of the changes to the standard would break things
22:36:06 <Iceland_jack> (that I'd like to see happen)
22:36:06 <enthropy> there are lots of options for pretty printing
22:36:10 <enthropy> @hackage IPPrint
22:36:10 <lambdabot> http://hackage.haskell.org/package/IPPrint
22:36:22 <enthropy> @hackage ipprint
22:36:23 <lambdabot> http://hackage.haskell.org/package/ipprint
22:36:35 * hackagebot crypto-pubkey 0.2.1 - Public Key cryptography  http://hackage.haskell.org/package/crypto-pubkey-0.2.1 (VincentHanquez)
22:36:39 <enthropy> http://hackage.haskell.org/package/data-pprint
22:36:53 <ReinH> enthropy: haven't seen that one before
22:37:36 <Iceland_jack> Sure, making a simple library for pretty printing is trivial: but (read ∘ show = id) is something that should be part of the Haskell standard and it would be nicer to have a standard pretty printing class rather than a bajillion unmaintained ones
22:38:03 <enthropy> there's not much maintenance to do for those libraries
22:38:46 <Iceland_jack> Well, for every new data-type you or the author needs to add new instances
22:38:55 <enthropy> that's not how they work
22:39:17 <enthropy> the ipprint uses Show, and then messes around with the String
22:39:35 <enthropy> the data-pprint uses Data instances apparently
22:39:49 <enthropy> both of which ghc will derive for you
22:39:50 <Iceland_jack> Apparently I spoke too soon (:
22:40:30 <enthropy> probably there are classes out there intended for pretty printing that people have to write instances for
22:43:14 <Iceland_jack> But be that as it may, it would be nice to have a standard class that GHCi used for displaying values
22:51:16 <ReinH> specifically one that isn't Show
22:52:18 <Iceland_jack> Right
22:53:57 <enthropy> > gshow "abcd"
22:53:58 <lambdabot>   Not in scope: `gshow'
22:53:58 <lambdabot>  Perhaps you meant `show' (imported from Prelude)
22:54:22 <enthropy> > Data.Generics.gshow "abcd"
22:54:23 <lambdabot>   Not in scope: `Data.Generics.gshow'
22:57:00 <joelteon> there isn't a pipes-specific channel, is there?
23:07:31 <mlamari> Are things like Conduit used for TCP type/continuous connections?  Or is that sort of thing outside their nature?
23:08:38 <Iceland_jack> % cabal list conduit | grep '\*.*network'
23:08:38 <Iceland_jack> * conduit-network-stream
23:08:38 <Iceland_jack> * network-conduit
23:08:38 <Iceland_jack> * network-conduit-tls
23:08:43 <Iceland_jack> Any of these helpful?
23:09:18 <mlamari> What I was after really was if you'd use a single source-sink over some long-running to-fro TCP type conversation
23:09:47 <mlamari> Conduits can carry the data - I'm wondering if you use them for such a purpose, a single source/sink, or somehow break the conversation up into multiple source/sinks.
23:11:23 <ellipsis> hi
23:11:41 * hackagebot cprng-aes 0.5.1 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.5.1 (VincentHanquez)
23:14:44 <ellipsis> I'm trying to figure out how to use monad transformers
23:14:58 <ellipsis> specifically to make a version of State with error handling
23:15:06 <ellipsis> and I'm getting a weird error
23:15:12 <ellipsis> and GHC crashes :/
23:15:14 <ellipsis> here's my code:
23:15:25 <ellipsis> http://lpaste.net/92397
23:15:54 <ellipsis> and the error:
23:15:59 <ellipsis> http://lpaste.net/92398
23:17:58 <joelteon> uhh, anybody want to help with some pipes-related code?
23:18:23 <joelteon> https://gist.github.com/joelteon/d4b2899742f2f554c7e8
23:18:30 <Iceland_jack> ellipsis: Well, you're applying lift to two arguments
23:18:35 <joelteon> the line in question is #12, which has the type hole
23:18:41 <joelteon> hang on, I'll paste the type sig of the type hole
23:19:16 <spaceships> will you define "type hole"?
23:19:39 <Iceland_jack> ellipsis: write ‘lift (put (e:s))’ instead of ‘(lift put) $ e:s’
23:19:55 <joelteon> spaceships: type holes are a thing in GHC HEAD
23:20:13 <joelteon> where you put _ in place of a term and the compiler tells you what the term's type needs to be
23:20:17 <Iceland_jack> same with the other lift: ‘lift (put (tail s))’ rather than ‘lift put (tail s)’
23:20:19 <spaceships> okay
23:20:51 <joelteon> but I don't really understand that error
23:21:01 <joelteon> because it's pretty complex
23:21:05 <ellipsis> Iceland_jack: Do I need to lift the return on line 24?
23:21:07 <ellipsis> 25*
23:21:10 <Iceland_jack> no
23:21:51 <joelteon> that is, I need a function of type StateP a _ _ _ _ _ _ _ -> EitherP SomeException _ _ _ _ String SafeIO _
23:21:56 <ellipsis> okay
23:21:59 <ellipsis> it doesn't crash anymore
23:22:00 <joelteon> where _ are irrelevant type variables
23:22:06 <joelteon> oh, whoops
23:22:12 <joelteon> s/StateP a/StateP String/
23:22:18 <ellipsis> but now it's giving me a new set of errors
23:22:44 <ellipsis> http://lpaste.net/92399
23:23:24 <ellipsis> I'm not sure what '* -> *' and '*' mean
23:23:25 <Riccardo> i need some help with lenses! it's my first time trying to use them for something non-trivial. here i have list traversal, Either as bifunctor and monadic sequencing: http://lpaste.net/7168472254370545664
23:23:29 <Riccardo> how do i write lensF?
23:23:30 <ellipsis> are those types or what?
23:23:56 <Iceland_jack> ellipsis: * and * -> * are kinds
23:24:02 <Iceland_jack> kinds are the “types of types”
23:24:16 <edwardk> Riccardo: i presume you have Monad m => or Applicative m => ?
23:24:28 <Iceland_jack> You can see what kind something has by using :k
23:24:29 <ellipsis> so where as + is Int -> Int, FPUState is * -> *?
23:24:30 <Iceland_jack> :k Maybe
23:24:31 <Riccardo> edwardk: yes
23:24:32 <lambdabot> * -> *
23:24:34 <edwardk> :t choosing
23:24:42 <edwardk> :t Control.Lens.choosing
23:24:43 <lambdabot> Functor f => LensLike f s t a b -> LensLike f s' t' a b -> LensLike f (Either s s') (Either t t') a b
23:24:47 <Riccardo> i tried choosing
23:24:53 <edwardk> well lets get there
23:24:55 <Iceland_jack> ellipsis: write return (head s)
23:24:57 <edwardk> there are a lot of moving parts here =)
23:24:59 <Iceland_jack> instead of return $ head s
23:25:01 <Riccardo> it seems that "id" is the only function that typechecks :-|
23:25:13 <edwardk> first makePrisms ''Fug, makePrisms ''Foo makePrisms ''Bar
23:25:21 <edwardk> that gives you _Fug, _Foo and _Bar to play with
23:25:44 <edwardk> we can likely get by with the _a things instead, but just for completeness
23:25:49 <Riccardo> (Left 1)^.(choosing id id) typechecks, but (Left 1)^.(choosing (+1) id) doesn't
23:25:56 <edwardk> and lets write lensF in the other order
23:26:04 <edwardk> (Int -> m Int) -> [Fug] -> m [Fug]
23:26:09 <edwardk> that way it itself is a traversal
23:26:12 <Iceland_jack> ellipsis: You might also want to write:
23:26:12 <Iceland_jack>     when (null s) $ throwError StackUnderflow; lift (put (tail s)); return (head s)
23:26:12 <Iceland_jack> rather than using the if-then-else expression
23:26:43 <Iceland_jack> also ellipsis, you can use ‘modify’ in the push function
23:27:09 <edwardk> a.choosing (traverse.b.traverse.c) c
23:27:24 <edwardk> lensF = a.choosing (traverse.b.traverse.c) c
23:27:45 <edwardk> choosing takes a pair of traversals, not functions like (+1)
23:27:47 <ellipsis> Iceland_jack: Thanks!
23:28:12 <Iceland_jack> ellipsis: So you can replace (do s ← lift get; lift (put (e:s))) with (lift (modify (e:)))
23:28:13 <Riccardo> but how come "id" is a traversal, and not (+1)? the Num constraint?
23:28:15 <edwardk> then fugs^..lensF   will return all the Int's in fugs
23:28:30 <edwardk> id isn't being used like you'd think there
23:28:42 <edwardk> a traversal looks like (a -> f b) -> (s -> f t)
23:28:49 <Iceland_jack> Using ‘when’ is just a matter of style though, your previous code was perfectly fine
23:28:53 <edwardk> id :: (a -> f b) -> a -> f b    type checks
23:28:59 <ellipsis> Iceland_jack: so throwError doesn't need to be the final return value?
23:29:05 <edwardk> (+1) :: (a -> f b) -> a -> f b  flips out ;)
23:29:09 <Iceland_jack> No
23:29:17 <Riccardo> oh i see
23:29:24 <edwardk> unless you have a Num for that.
23:29:29 <Riccardo> so a -> a is not "value in - value out", it's expanded here
23:29:30 <edwardk> in which case you have worse problems ;)
23:29:52 <edwardk> yeah
23:29:54 <ellipsis> Iceland_jack: Is that part of the MonadError?
23:29:56 <ellipsis> -the
23:30:04 <Iceland_jack> yes
23:30:10 <edwardk> lens bends over backwards to let you use Prelude id and (.) to compose lenses
23:30:19 <edwardk> but don't forget that they are lenses =)
23:30:28 <Iceland_jack> > runIdentity (runErrorT (do throwError "HI"; return "IGNORED!"))
23:30:30 <lambdabot>   Left "HI"
23:31:50 <ellipsis> awesome
23:31:52 <ellipsis> it works now
23:31:56 <ellipsis> thanks for the help :D
23:31:57 <Iceland_jack> Great :)
23:32:09 <Iceland_jack> No problem, throwError is just like ‘Nothing’ in the Maybe monad
23:32:19 <Iceland_jack> > sequence [Just 1, Just 2, Nothing, Just 4]
23:32:20 <lambdabot>   Nothing
23:33:17 <Iceland_jack> > runIdentity $ runErrorT $ sequence [return 1, return 2, throwError "error", return 4]
23:33:18 <lambdabot>   Left "error"
23:33:33 <Iceland_jack> And so on and so forth
23:33:33 <mascotte> ciao
23:33:37 <mascotte> !list
23:33:38 <monochrom> mascotte: http://hackage.haskell.org/packages/archive/pkg-list.html
23:33:52 <ellipsis> neat
23:33:57 <ellipsis> I've never used Error before
23:34:21 <ellipsis> always used stuff like IO (Either String <whatever>)
23:34:41 <ellipsis> this is way cleaner
23:36:27 <johnw> sclv: Ping
23:36:35 <johnw> sclv: ping
23:36:41 * hackagebot camh 0.0.1 - Image converter to 256-colored text.  http://hackage.haskell.org/package/camh-0.0.1 (HironaoKomatsu)
23:36:53 <Riccardo> edwardk: what's the difference between traverse and traversed? I've mostly seen the latter used in the introductory material
23:42:12 <arkeet> Riccardo: as the docs say, it's an IndexedTraversal.
23:42:52 <arkeet> so it's slightly more general that's the only difference.
23:43:49 <arkeet> as a plain old Traversal, it
23:43:52 <arkeet> it's identical to traverse.
23:44:17 <Riccardo> arkeet: so if i have a non-indexable collection, traverse would work, but not traversed?
23:44:23 <Riccardo> say, a set
23:44:24 <arkeet> no, both work.
23:44:29 <arkeet> you can always replace traverse with traversed.
23:45:04 <cirdec> @pl \f -> c . (($) f)
23:45:04 <lambdabot> (c .)
23:45:13 <arkeet> traversed just also gives you an integer index by position.
23:45:20 <arkeet> > "abcd" ^@.. traversed
23:45:23 <lambdabot>   [(0,'a'),(1,'b'),(2,'c'),(3,'d')]
23:46:59 <arkeet> all it needs is a Traversable instance.
23:47:04 <arkeet> which is the same as what traverse needs.
23:47:06 <Riccardo> so the difference is only observable if down in the chain I use an operator that uses this index value?
23:47:22 <arkeet> more or less.
23:47:25 <Riccardo> which i didn't in my lensF
23:47:29 <arkeet> > "abcd" ^@.. traverse
23:47:30 <lambdabot>   Couldn't match type `GHC.Types.Char
23:47:30 <lambdabot>                       -> Control.Lens.I...
23:47:38 <arkeet> that doesn't typecheck, because traverse isn't an indexed traversal.
23:48:12 <edwardk> traversed takes any traversal and adds the index that starts counting at 0 and increases from there.
23:48:18 <edwardk> its not always the index you want
23:48:37 <edwardk> but its always an index that is possible
23:48:38 <edwardk> when traversing a map you probably want itraversed, which will give you the keys as the indices
23:48:38 <Riccardo> i know it hurts to explain it in these terms, but these informal intuitions help to start out  :-)
23:48:40 <edwardk> rather than traversed
23:50:03 <arkeet> > S.fromList
23:50:04 <lambdabot>   <[()] -> Set ()>
23:50:15 <lpaste> edwardk pasted “illegal pngs” at http://lpaste.net/92400
23:50:15 <arkeet> > S.fromList "hello world" ^@.. traversed
23:50:16 <lambdabot>   No instance for (Data.Traversable.Traversable Data.Set.Base.Set)
23:50:16 <lambdabot>    arising...
23:50:21 <lpaste> edwardk pasted “illegal pngs” at http://lpaste.net/92401
23:50:25 <arkeet> oh right.
23:50:30 <arkeet> Set isn't Traversable to begin with.
23:50:41 <arkeet> > S.fromList "hello world" ^@.. folded
23:50:42 <lambdabot>   [(0,' '),(1,'d'),(2,'e'),(3,'h'),(4,'l'),(5,'o'),(6,'r'),(7,'w')]
23:50:46 <edwardk> > er that was for #haskell-lens, but oh well =)
23:50:48 <lambdabot>   <hint>:1:30: parse error on input `,'
23:51:04 <edwardk> > S.fromList "hello world" ^.. each
23:51:05 <lambdabot>   No instance for (Control.Lens.Each.Each
23:51:05 <lambdabot>                     (Control.Lens.I...
23:51:09 <edwardk> > S.fromList "hello world" ^.. folded
23:51:10 <lambdabot>   " dehlorw"
23:51:15 <edwardk> > S.fromList "hello world" ^@.. folded
23:51:16 <lambdabot>   [(0,' '),(1,'d'),(2,'e'),(3,'h'),(4,'l'),(5,'o'),(6,'r'),(7,'w')]
23:51:36 <arkeet> > zip [0..] $ S.fromList "hello world" ^.. folded
23:51:38 <lambdabot>   [(0,' '),(1,'d'),(2,'e'),(3,'h'),(4,'l'),(5,'o'),(6,'r'),(7,'w')]
23:52:33 <arkeet> yeah, traversed just makes up an index.
23:52:46 <arkeet> so the first things it sees when traversing gets the index 0, the second gets 1, and so on.
23:53:16 <ReinH> arkeet: :)
23:54:53 <Riccardo> thanks
