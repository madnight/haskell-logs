00:00:58 <Gracenotes> :t traverse
00:01:18 <Gracenotes> ..into the void..
00:01:34 <Kneiva_> what's this called: ((->) t)
00:01:42 <arkeet> it's called ((->) t)
00:01:55 <mauke> I call it the naked reader
00:02:13 <Kneiva_> but it's hard to search for more information on it without a name
00:02:32 <shachaf> I colloquially call it (t ->), though that's a syntax error.
00:02:39 <shachaf> Kneiva_: It's just (->) applied to one argument.
00:02:41 <Gracenotes> kloplop321: anyway, sequenceA from Traversable does that
00:02:49 <shachaf> (->) as in "a -> b"
00:03:11 <kloplop321> Gracenotes: I moved the inline expression into it's own function, and it acts the way I expected now...
00:04:38 <Gracenotes> er, hm, hm, that's not quite true... right... (a,) isn't Applicative
00:05:22 <kloplop321> Gracenotes: it isn't (a,), it is (,) <$> pure a <*> someFunc a
00:05:52 <shachaf> (a,) <$> someFunc a
00:06:12 <kloplop321> It is equivalent?
00:06:20 <Gracenotes> I'm referring to the functor instance of (,) a, speaking of section notation.
00:06:52 <kloplop321> I was aware that any constructor, namely (,) in this example, could have applicatives applied.
00:07:04 <shachaf> fmap f (pure x) = pure (f x)
00:08:08 <kloplop321> shachaf: that's a law, isn't it?
00:08:08 <Gracenotes> what is a nice idiomatic way to go from (a, Maybe b) to Maybe (a, b)?
00:08:19 <shachaf> By "law" do you mean that it's true?
00:08:24 <kloplop321> yes.
00:08:38 <kloplop321> for any functor implementations
00:08:45 <shachaf> Gracenotes: sequence
00:08:51 <shachaf> (From Data.Traversable.)
00:09:17 <shachaf> Or sequenceOf _2, if you like being explicit (and using lens).
00:09:34 <kloplop321> Gracenotes: That's what this problem was. Which seems to be solved now that I moved the inlined stuff out of the second portion, after the <*>
00:09:38 <Gracenotes> shachaf: that's the thing, though, where's (a,) defined to be Traversable?
00:10:07 <shachaf> Oh, right.
00:10:08 <shachaf> lens
00:10:13 <shachaf> And HEAD base, but that doesn't help you.
00:10:21 <Gracenotes> ;_;
00:10:55 <kloplop321> Gracenotes: in case you are interested, also I have ScopedTypeVariables enabled, so a is part of the typeclass, rather than a free type variable http://puu.sh/43mVo.png
00:11:53 <kloplop321> Note, the p function is the same as the example function someMaybeFunc.
00:12:10 <Gracenotes> not a super name, arguably
00:12:26 <Gracenotes> to say it mildly
00:12:52 <Gracenotes> is a defined in the type signature for parseEntities?
00:13:22 <Gracenotes> or quantified over there, rather
00:13:31 <kloplop321> parseEntities :: [KVEntity] -> [(KVEntity, a)]
00:13:47 <shachaf> A screenshot of your code? What happened to text?
00:14:25 <kloplop321> shachaf: I apologize for the inconvenience.
00:14:43 <mauke> next time I'll post ASCII art of a picture of text
00:15:31 <mauke> :t mapMaybe
00:15:31 <lambdabot> (a -> Maybe b) -> [a] -> [b]
00:16:14 <kloplop321> That is definitely cool.
00:16:36 <kloplop321> It is right under catMaybes. I should have seen it.
00:16:48 <Gracenotes> cowsay -f /usr/share/cowsay/cows/mauke.cow $1
00:17:08 <mauke> don't make me figlet
00:17:39 <Gracenotes> you can pipe it into cowsay
00:17:48 <kloplop321> mauke: it works. You simplified my code.
00:18:01 <mauke> yay?
00:47:23 <hape02> I understand that in ghci  if I type   :t Maybe    this is wrong,  since :t  evaluates the type of some value, and since Maybe a is a data type this goes wrong. But the type of a type is a sort of "kind". And if  I ask ghci to give me the type of a type, why does it not return the kind of it, as I get it when I ask ghci in the way:   :kind Maybe
00:48:20 <shachaf> Because types and values exist in different namespaces.
00:48:21 <notdan> Because kinds and types are different things and live in different universes, so it makes sense to separate :t and :k
00:48:36 <shachaf> Sometimes you have both a type and a value called Foo.
00:49:40 <hape02> both, makes sense :-)
00:50:24 <raichoo> Idris> :t Maybe
00:50:24 <raichoo> Prelude.Maybe.Maybe : Type -> Type
00:50:30 <raichoo> yay \o/
00:50:46 <johnw> it would be helpful if ":i name" presented everything that's known about name, the kind, type, info, instances, all in one display
00:51:02 <hape02> raichoo: ? that works ?
00:51:39 <raichoo> hape02: It works in idris, it's dependently typed. Anyway I was just trolling a litte :)
00:51:43 <raichoo> little
00:51:50 <hape02> nice :-)
00:51:52 <shachaf> johnw: How is what you want different from what it does?
00:52:36 <johnw> shachaf: :i Maybe Int, for example, shows the info for Maybe, and then Int, rather than the info for "Maybe Int"
00:52:48 <raichoo> hape02: The line between types, kinds and values blurs in a dependently typed setting.
00:52:50 <shachaf> Oh, sure, it shows information on names, not expressions.
00:53:12 <shachaf> But if you have a data constructor and a type constructor with the same name, it'll show both.
00:53:22 <johnw> oh, nice, didn't know that
00:53:25 <hape02> raichoo: I see, thx
00:55:15 <merijn> raichoo: Or Haskell with DataKinds :p
00:56:14 <merijn> λ :k (Just Int)
00:56:15 <merijn> (Just Int) :: Maybe *
00:56:41 <raichoo> merijn: That's pretty much a hack, but better than nothing ^^
00:57:15 <merijn> raichoo: I <3 my DataKinds
00:57:17 <raichoo> merijn: I like datakinds but it feels clunky compared to DTs.
00:57:49 <merijn> raichoo: The sacrifices we make for practicality... :)
00:58:00 <arkeet> haskell has dependent types btw ;-)
00:58:10 <shelf> tell me more
00:58:12 <raichoo> arkeet: Depends on what you call DT ^^
00:58:18 <arkeet> http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf
00:58:19 <arkeet> ;)
00:59:03 <joneshf-work> @hoogle String -> String -> Int
00:59:03 <lambdabot> Foreign.C.Error throwErrnoPath :: String -> FilePath -> IO a
00:59:03 <lambdabot> System.Posix.Error throwErrnoPath :: String -> FilePath -> IO a
00:59:03 <lambdabot> Data.Time.Format readTime :: ParseTime t => TimeLocale -> String -> String -> t
00:59:25 <joneshf-work> @hoogle a -> [a] -> Int
00:59:25 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
00:59:25 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
00:59:25 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
01:08:16 <structuralist> is hpaste down?
01:09:22 <structuralist> so I try this example directly from the GHC manual and it doesn't work… what am I doing wrong?
01:09:23 <structuralist> {-# LANGUAGE TypeOperators #-}
01:09:24 <structuralist> type T (+) = Int + Int
01:09:24 <structuralist> f :: T Either
01:09:26 <structuralist> f = Left 3
01:09:46 <merijn> structuralist: The VM got moved but the person owning vm doesn't own the domain, so the domain is stuck pointing to the wrong machine
01:09:53 <merijn> structuralist: Use lpaste.net
01:10:28 <merijn> structuralist: I believe there was a change to how TypeOperators work, but I forget the details
01:10:29 <hpaste> structuralist pasted “type operators as arguments” at http://lpaste.net/91895
01:10:52 <merijn> structuralist: In short, I believe this "infix variable" thing is no longer possible and the GHC manual is probably out of date
01:11:12 <structuralist> aw
01:12:15 <merijn> structuralist: Note, I'm not 100% sure of this
01:13:01 <merijn> structuralist: I believe the rationale was the infix type variables were nice, but the ability to write infix TypeFamilies was nicer, so the ability to do this got canned in favour of the ability to have infix type families
01:13:08 <merijn> Anyhoo, time to run
01:14:15 <structuralist> hmm
01:14:34 <structuralist> I guess "type Category to = forall a b c. (a `to` a, (a `to` b) -> (b `to` c) -> (a `to` c))" is okay enough
01:14:41 <structuralist> thanks
01:16:43 <raichoo> arkeet: Scala also has DTs. Nevertheless I prefer using Agda or Idris when I really want that power :) Haskell can approximate some of those features but it can become cumbersome.
01:17:09 <arkeet> sure.
01:17:18 <edwardk> structuralist you can construct type aliases -: and :>  such that you can use
01:17:19 * arkeet has never used an actual DT language.
01:17:26 <edwardk> a -:c:> b
01:18:03 <edwardk> there is some hinky issue with -   or you could use a -c> b
01:18:33 <arkeet> >- ->
01:18:34 <structuralist> haha, I like that
01:18:43 <arkeet> wait, no ->
01:19:04 <edwardk> yeah it was how i mollified conal about the change on the haskell mailing list as i recall
01:19:36 <shachaf> I don't think conal is mollified.
01:19:47 <edwardk> ok, somewhat mollified  ;)
01:19:50 * structuralist goes hunting for obscure unicode characters to do the job
01:22:46 <structuralist> is it possible to have operators as type constructors that don't start with :?
01:23:45 <edwardk> yes
01:23:47 <edwardk> that is why the change
01:23:54 <edwardk> 7.6 enabled it
01:24:16 <edwardk> they wanted + - * etc for TypeNats
01:24:18 <structuralist> er sorry I mean value constructors? I think? like Left
01:24:25 <edwardk> value constructors no
01:24:32 <structuralist> ah k
01:25:04 <structuralist> why do they conflict?
01:25:08 <arkeet> we can't have + and * for Either and (,) ?
01:25:09 <arkeet> :(
01:25:11 <edwardk> a * b = c     could be a destructuring assignment reading both halves of the * value constructor or a definition
01:25:33 <structuralist> I see
01:25:39 <edwardk> if you got rid of destructuring assignment you could play games, but thats horrid
01:26:34 <arkeet> could you do something ugly, with type families perhaps, to make something like a :>c:> b
01:26:36 <arkeet> work
01:26:40 <arkeet> maybe not.
01:27:09 <arkeet> maybe.
01:27:12 <arkeet> type families are pretty gross.
01:27:48 * hackagebot cryptocipher 0.5.2 - Symmetrical block and stream ciphers.  http://hackage.haskell.org/package/cryptocipher-0.5.2 (VincentHanquez)
01:33:50 <Egbert9e9> hi, could you recommend some reasonably terse guide which introduces monad transformers such as StateT, etc?
01:34:19 <Work_jack> Egbert9e9: Real-World Haskell has a fairly intuitive introduction to monad transformers
01:35:08 <Egbert9e9> Work_jack: it's pretty huge, though. Can I hop mid-book and just read it or should I read it start to finish?
01:35:29 <shachaf> I think you can "hop" into the middle of that book pretty easily.
01:35:38 <Work_jack> If you know what monads are and have a good grasp of Haskell it should be easy
01:35:43 <Work_jack> They are just a way of combining monads
01:36:01 <Work_jack> http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf I always found this to be pretty intuitive
01:37:04 <Egbert9e9> cool. I have some kind of grasp but sometimes they seem to be slippery as a fish.
01:39:21 <arkeet> technically you're not combining monads.
01:39:35 <arkeet> you can't take two random monads and glue them together to get another monad.
01:39:49 <Work_jack> That's right
01:42:11 <Kinnison> I've always described them with: "They (monad transformers) are a way to layer one monadic behaviour on top of another monad to form a new monad with the combined behaviour"
01:42:30 <arkeet> I can't argue with that.
01:42:54 <Kinnison> I did something right(ish)?
01:42:54 <Kinnison> wow
01:42:57 * Kinnison does a happy dance
01:43:09 <arkeet> aren't monad transformers just monad morphisms?
01:43:29 <arkeet> or rather
01:44:02 <arkeet> functors from the category of monads to itself.
01:44:03 <arkeet> no...
01:45:24 <arkeet> functors equipped with a natural transformation from id
01:45:28 <arkeet> ?
01:45:39 <arkeet> but are they really functors
01:45:53 <notdan> Well, 'lift' is a monad morphism
01:45:57 <arkeet> of course.
01:46:12 <arkeet> but nothing in MonadTrans seems to connect transformers applied to related monads.
01:47:01 <arkeet> probably the monad transformers we care about are actually such, though.
01:47:15 <arkeet> the natiral transformation I was speaking of is lift.
01:48:21 <arkeet> natural
01:48:25 <arkeet> clearly I need to go to bed.
01:59:50 <structuralist> is there a way to turn off kind checking before expanding type synonyms?
02:04:25 <merijn> What do you mean by that?
02:05:24 <joelteon> I'm getting a solid 35KBps down from haskell.org
02:24:31 <dpwright> hmm, I'm having some trouble getting to grips with the pipes and pipes-network modules.  I'm pretty sure I'm missing the point somewhere along the line which is leading me down a lot of dead ends
02:25:28 <dpwright> basically, my use-case is, I have a server, the client connects to it with a simple request, and the server responds to that request.  For most requests, the response is quick and simple -- grab some data, give it back
02:25:42 <dpwright> that all works fine
02:26:45 <dpwright> but I also want the client to be able to request to stream a log from this server.  In that case, the server should just keep delivering information to that client and can basically ignore any more requests until the client closes the connection
02:27:23 <dpwright> but if I do that, the "requests" don't line up with the "responds" any more
02:27:53 <dpwright> am I doing it wrong?
02:41:45 <boothead> Hi guys, anyone using esquleto here?
02:44:46 <merijn> dpwright: What do you mean by "requests don't line up"?
02:46:17 <kloplop321> boothead: I tried it for a bit, but I never really ended up using it since I moved to riak.
02:47:51 <boothead> kloplop321, interesting. How do you find riak?
02:48:39 <kloplop321> I find it to fulfill my needs, of course, I needed to come up with my own schema to store with. The package is easy to use on hackage.
02:54:19 <notdan> Has anyone else experienced this problem during the linking of some libraries: https://gist.github.com/co-dan/e81f17c31193c839a7ed ?
02:57:20 <rekado> I have just started a new project with only base==4.5.* and basic-prelude as dependencies. With cabal-dev I cannot install basic-prelude, though.
02:58:35 <rekado> Says the version of the Cabal library is too low (must be >=1.8), yet cabal-dev was built with Cabal 1.14
03:00:29 <rekado> cabal-dev ghc-pkg list doesn't show any cabal library; does this mean that I first have to install the cabal library with `cabal-dev install cabal`?
03:14:16 <merijn> rekado: rerun the command with -v3
03:14:24 <merijn> rekado: The current output doesn't tell us anything
03:14:43 <merijn> rekado: oh, wait
03:14:51 <merijn> rekado: I'm getting you mixed up with someone else >.>
03:14:58 <merijn> rekado: Can you pastebin your cabal file?
03:15:08 <merijn> notdan: See my remark about rerunning with -v3
03:18:31 <notdan> merijn: oops, sorry, I've already fixed the issue (by deleteing ghc-7.4 libraries from ~/.cabal)
03:19:24 <rekado> merijn: here's the cabal file: https://gist.github.com/rekado/1a336fbb65f80f11907c
03:19:52 <rekado> I'm on Fedora 19 and have installed cabal-dev from the official repos.
03:22:12 <merijn> rekado: What does "ghc-pkg list | grep Cabal" say?
03:24:24 <rekado> it's empty. Tried installing it with cabal-dev install cabal, but this fails with an unhelpful error (even at verbose=3)
03:25:02 <rekado> This is true for cabal-dev ghc-pkg list | grep Cabal and the invocation without cabal-dev
03:27:50 * hackagebot hxt-charproperties 9.1.1.1 - Character properties and classes for XML and Unicode  http://hackage.haskell.org/package/hxt-charproperties-9.1.1.1 (UweSchmidt)
03:28:53 <dpwright> merijn: Sorry about the slow reply -- was afk
03:29:37 <dpwright> what I mean is -- and maybe this is a misunderstanding on my part, I'm just getting started with this pipes stuff -- I was under the impression that for every "respond" there has to be a "request"
03:30:40 <dpwright> but in this case, after the first request from socketReadS, I just want to keep responding with line after line of this log
03:32:50 * hackagebot hxt-unicode 9.0.2.1 - Unicode en-/decoding functions for utf8, iso-latin-* and other encodings  http://hackage.haskell.org/package/hxt-unicode-9.0.2.1 (UweSchmidt)
03:34:09 <dpwright> up until now, where there's been a simple response to every request, I could do a simple lookup of whatever was requested, and pass that through to socketWriteD, which would forward the response back to the client
03:37:06 <dpwright> ...actually, looks like I should have just *tried* it before asking!  I just tried putting to "responds" in a row and they both came through just fine, so I don't know what I was worrying about
03:37:39 <dpwright> it seems I was mistaken in my initial belief that they had to be balanced
03:43:42 <merijn> dpwright: Yeah, they don't have to be balanced at all
03:44:02 <merijn> dpwright: In fact, if you use Producer/Consumer rather than client/server there are never any request/responds
03:44:47 <merijn> dpwright: The request/respond thing is specifically for if your "downstream" code needs to make decisions and relay those back upstream
03:50:22 <dpwright> merijn: Oh, really? the lines'/printer functions at the beginning of the pipes tutorial are producers/consumers though aren't they?
03:52:08 <merijn> dpwright: Yes, but the printer doesn't have to communicate anything upstream...
03:53:30 <merijn> oh, wait, I think I see the issue
03:53:59 <merijn> I've been working with the new pipes-4 library, which has simplified a bunch of this stuff
03:54:59 <dpwright> Ah, I see.. I'm on 3.2, which seems to be what the latest release of pipes-network is compatible with
03:55:01 <merijn> Which doesn't use request/respond anymore for the basic functionality of a pipe
03:55:39 <merijn> dpwright: Yes, 4.0 is getting the ecosystem ready, most libraries have been ported, but it won't be released until all other things using it have been made compatible
03:56:39 <merijn> dpwright: Anyway, the basic thing holds that request/respond doesn't have to go in lockstep, either side can just request repeatedly or respond repeatedly, without doing the other in between
03:56:46 <dpwright> merijn: Ah, ok... is that imminent enough that it would be worth my while taking a look at now or a little while off still?
03:57:12 <merijn> dpwright: Well, it depends, are you just playing around to learn or trying to get actual work done?
03:57:57 <dpwright> ..sort of both.  next week, I will be trying to do some actual work using this... right now I'm playing around with it to get a feel for it so I can hit the ground running next week
03:57:58 <merijn> I would say pipes-4 is certainly finished/imminent enough that for just learning pipes it'd be worthwhile, since the API is much simpler and cleaner than pipes-3
04:00:13 <merijn> The only thing that seems to still be evolving into its final API is pipes-safe, which (unfortunately) means that pipes-network hasn't been upgraded yet and won't be until the final API of pipes-safe is decided upon
04:01:21 <dpwright> ok, thanks
04:01:46 <dpwright> I think I'll keep going with 3.2 for now and take a look at 4 when it's released
04:01:50 <merijn> rekado: Something is *very* broken if "ghc-pkg list" doesn't show a version of Cabal, afaik Cabal is a dependency of GHC, it should not be possible to have a GHC without it...
04:03:45 <supki> don't underestimate the power of linux distributions to split GHC !
04:04:29 <merijn> supki: ghc can't even work if you don't have Cabal, afaik
04:05:10 <merijn> Maybe one of those distros that edit the package db by hand and they accidentally wrecked it?
04:06:36 <merijn> rekado: Can you even compile anything atm? i.e. "module Main where main = putStrLn "Hello world!""?
04:07:06 <aloiscochard> hey folks, do you have some good ref about what's a "literate" haskell code file (.lhs)?
04:07:31 <merijn> aloiscochard: Literate programming means your program is really prose with compilable code in between
04:07:54 <quicksilver> I would guess that rekado is running ghc-pkg in a context where it can't see his global package list
04:07:55 <merijn> aloiscochard: See: http://www.haskell.org/haskellwiki/Literate_programming
04:08:09 <quicksilver> either paths have changed, or cabal-dev has messed something up
04:08:20 <merijn> quicksilver: Well, he ran it outside of cabal-dev too, he said
04:08:33 <quicksilver> nonetheless that's what I think :)
04:08:55 <aloiscochard> merijn: I see ty, so why here -> http://www.haskell.org/haskellwiki/Structure_of_a_Haskell_project#Directory_Structure they say to name the main module "Main.lhs", is it to write the package documentation with literate in some way?
04:08:58 <merijn> quicksilver: Sure, but that'd be operator error :)
04:09:41 <merijn> aloiscochard: That's just personal preference of the author of that example
04:09:56 <merijn> aloiscochard: any literate haskell file can be replaced with a normal one and vice versa
04:10:13 <aloiscochard> merijn: ok that make sense now :-) thanks a lot!
04:10:44 <merijn> aloiscochard: literate haskell only affects which bits of the file are considered haskell code
04:11:21 <aloiscochard> merijn: can be quite usefull to write papers I suppose
04:12:54 <merijn> aloiscochard: Or blog posts, yes
04:46:03 <rekado> merijn: I can compile; for example my website that depends on hakyll. But there I use ghc --make and the distro packages, no cabal install
04:48:49 <rekado> I'm installing the distro package ghc-Cabal-devel now; hope this'll fix it. I thought when using cabal-dev that would just work and all dependencies would be installed as needed.
04:57:52 <rekado> Hmm, I still get "lifted-base-0.2.1.0 failed during the configure step."
04:58:26 <bennofs> @hoogle (Group a, Ord a) => a -> a -> Int
04:58:26 <lambdabot> Warning: Unknown class Group
04:58:26 <lambdabot> Data.Set findIndex :: Ord a => a -> Set a -> Int
04:58:26 <lambdabot> Prelude max :: Ord a => a -> a -> a
04:59:58 <rekado> verbose=3 brings this error message to light: "wired-in package dph-seq not found."
05:00:08 <rekado> same for "dph-par"
05:03:34 <rekado> Here's the complete output of cabal-dev --verbose=3 install lifted-base: https://gist.github.com/rekado/6249269
05:04:02 <rekado> I'd be very happy if someone could take a look at the output and point me to the cause.
05:05:05 <adas> whats the difference between Text.Parsec and Text.ParserCombinators.Parsec?
05:07:17 <adas> anyone?
05:08:13 <rekado> "World file is already up to date." <-- this doesn't really sound like an error.
05:08:42 <otulp> adas: Text.ParserCombinators.Parsec is the old module name. In Parsec 3 everything moved to Text.Parsec. If I recall correctly and so on.
05:08:46 <supki> rekado: honestly I think you would be better off just by picking binary ghc distribution instead of fighting this nonsense
05:09:56 <supki> rekado: by "binary distribution" I mean this: http://www.haskell.org/ghc/download
05:10:10 <adas> otulp: ah okay.. thanks. old module name must be removed in that newest haskell platform
05:10:42 <rekado> supki: hmm, is that what people normally do? Is GHC really that mangled by distro maintainers?
05:11:13 <Cale> That's what I do
05:11:32 <Cale> I stopped trusting distributions to get anything related to Haskell right years ago
05:11:57 <Cale> ExitFailure 127 is interesting. That's "command not found" usually, right?
05:12:30 <mauke> depends :-)
05:12:34 <otulp> adas: Are you sure you are not using the "parsec3" package insetead of the "parsec" package? The latter should contain both setups.
05:12:42 <mauke> in shells, yes
05:12:59 <adas> my setup has both
05:13:15 <rekado> (I took a vacation from Haskell a year ago and only just got back to hacking Haskell. )
05:15:21 <rekado> I'm reluctant to install a second GHC just for this little project.
05:15:28 <Cale> https://github.com/haskell/cabal/issues/1058
05:16:00 <Franciman> is haskell's syntax ambiguous?
05:16:10 <rekado> Cale: aha!
05:16:37 <Cale> https://github.com/haskell/cabal/commit/48082b90726093298df8559b365ed08805ca6d8f -- this is the patch to cabal which supposedly fixed it
05:16:39 <mauke> Franciman: what does that mean?
05:17:22 <Franciman> mauke that you can parse a like in different ways
05:17:30 <Franciman> using different productions I mean
05:17:48 <mauke> I don't think any programming language works like that
05:18:14 <Franciman> *line
05:18:26 <Franciman> unfortunately it's not like that
05:18:41 <mauke> do you have an example?
05:18:50 <Franciman> in haskell or in other languages?
05:19:24 <mauke> either
05:19:33 <Franciman> for example golang
05:19:50 <Franciman> has some parenthesized expression that can't be disambiguated
05:19:57 <Franciman> for being either Expression or Types
05:20:05 <mauke> so what does the compiler do with them?
05:20:07 <Franciman> until semantic analysis
05:20:22 <Franciman> I don't know
05:20:25 <mauke> I don't know what that is
05:20:52 <Franciman> that what?
05:21:00 <mauke> semantic analysis
05:21:15 <mauke> if this is the usual C issue of 'f(c)' depending on whether f names a type or not, color me unimpressed
05:21:27 <rekado> Cale: apparently version 1.16.0.2 with the fix is available on Fedora rawhide.  Thanks for the hint.
05:21:45 <Franciman> mauke yes
05:22:00 <Cale> rekado: if you have cabal-install already, you can just cabal install cabal-install to update
05:22:30 <mauke> that's only ambiguous if you use a certain formalism to describe the language
05:22:31 <Cale> rekado: You'll have to make sure that ~/.cabal/bin is earlier in your $PATH than wherever else you have a cabal binary
05:22:46 <Franciman> but if you can define types after their usage....
05:22:51 <rekado> Cale: I see. I was afraid it would install to /usr/bin
05:23:13 <quicksilver> haskell isn't ambiguous in that sense
05:23:23 <quicksilver> except for binary operator precedence
05:23:33 <quicksilver> which you can consider part of the grammar or not according to taste.
05:23:58 <mauke> I thought you'd come up with something like perl's /$foo[10-3]/
05:24:45 <kuribas> Some function in hmatrix crash with an error message when given wrong parameters.  What would be a more idiomatic way to handle these errors?
05:25:27 <kuribas> Returning Maybe, or throwing exceptions?
05:26:03 <rekado> Cale: erm, cabal install cabal-install fails with the same silly message, heh.  I'll just fetch the rpm and try to upgrade that way.
05:27:13 <Cale> rekado: Here's what I would do: grab the generic linux binary of ghc 7.6.3, install that, then grab the tarball of cabal-install from Hackage, and run bootstrap.sh from there
05:27:56 <kuribas> For example in rootfinding, when there isn't a root in the specified interval, the function with give an error message and crash the program.
05:28:18 <Cale> kuribas: Yeah, that's definitely a use-case for Maybe
05:29:16 <Cale> kuribas: Throwing an exception from a pure function is as good as crashing the program. You generally shouldn't throw exceptions from a pure function which you want anyone to catch.
05:29:27 <Cale> But they're rather nice in IO sometimes.
05:29:49 <kuribas> Cale: Only slightly better because I don't have to restart ghci.
05:29:58 <kuribas> But yeah, I agree.
05:29:59 <Cale> oh, well, yeah
05:30:07 <joelteon> you know what you DON'T want to do is export a library function that returns IO (Either String a) but ALSO throws exceptions
05:30:24 <Cale> If it's crashing ghci, that's a whole other thing :)
05:30:51 <Cale> joelteon: Well, maybe it could throw exceptions unrelated to the ones it's handling with that Either String
05:31:01 <joelteon> yeah, I guess
05:31:09 <kuribas> I think the default gsl error handler terminates the program.
05:31:18 <joelteon> it was in hoauth2; the Strings were for auth failures and the exceptions were unexpected HTTP status codes
05:31:22 <joelteon> which signify an auth failure anyway :/
05:32:24 <Cale> Yeah, that's dumb
05:32:58 <joelteon> It is dumb, I ended up making String an instance of Exception
05:33:04 <Cale> If you're in IO anyway, making new instances of Exception can be quite effective, and it's easy to do.
05:33:11 <joelteon> Right
05:33:16 <joelteon> I absolutely agree.
05:33:22 <Cale> I wouldn't make String an instance...
05:33:33 <joelteon> Well, that's the thing.
05:33:33 <Cale> But some newtype of it perhaps :)
05:33:51 <joelteon> Yeah, I might go back and look at that
05:34:17 <joelteon> there should be a better way than making String an Exception. I don't remember why I didn't, but there was a good reason.
05:36:06 <joelteon> I think it was because I was using EitherT . liftIO . try to wrap the monadic action I wanted, and that ends up returning both thrown exceptions and the Left result as a Left
05:36:13 <Cale> Yesterday I was showing some people my code for making different kinds of IOErrors into their own exception types...
05:36:25 <joelteon> There should definitely be a better way to do that
05:36:26 <Cale> http://lpaste.net/91892
05:36:43 <Cale> You can do some pretty cool stuff with custom instances of Exception
05:36:53 <joelteon> yeah I do rather like it
05:37:07 <joelteon> I also figured out how to fake a polymorphic pattern match
05:37:26 <Cale> Yeah, you can cast multiple times :)
05:37:48 <Cale> With pattern guards, you can even get nice fallthrough :)
05:37:54 <joelteon> Cale: am I wrong that EitherT . liftIO . try makes Left results and errors indistinguishable?
05:38:09 <joelteon> or you could ignore the liftIO bit
05:38:14 <joelteon> doesn't matter either way
05:38:26 <bennofs> > 10 ^ 309 * 0.1
05:38:27 <lambdabot>   Infinity
05:38:48 <Cale> Well, that's what it does, yes.
05:38:56 <joelteon> Right
05:39:04 <joelteon> That's what EitherT is for, I guess
05:39:09 <Cale> Or what try is for
05:39:15 <joelteon> right
05:39:16 <Cale> depending on how you look at it
05:39:17 <joelteon> Oh, really?
05:39:24 <Cale> :t try
05:39:26 <lambdabot> Exception e => IO a -> IO (Either e a)
05:39:33 <joelteon> ok, good point
05:39:33 <Cale> It turns the exception into an Either
05:39:51 <joelteon> So I need to be able to distinguish Lefts and exceptions then
05:40:04 <joelteon> since hoauth2 returns errors both ways
05:40:39 <Cale> Right, well, you can catch the exception, and apply your own newtype to it which tags it as whatever sort of condition the Either represents
05:41:02 <merijn> joelteon: You can also just catch + rethrow
05:41:07 <Cale> Or: take the Lefts and throw them as a new exception type
05:41:15 <joelteon> It should expand to IO (Either a b) -> IO (Either e (Either a b))
05:41:22 <joelteon> or I could do that
05:42:00 <Cale> (which by the sounds of it would probably be more convenient anyway)
05:42:11 <Cale> I remember looking at hoauth2 and thinking that it could use some work
05:43:19 <Cale> It'd probably be best to just get the code for it and make it do something sane to begin with :)
05:43:24 <joelteon> Yeah maybe
05:46:03 <joelteon> :r
05:46:06 <joelteon> whoops
05:46:29 <Cale> Ok, modules loaded: none.
06:02:39 <joelteon> Damn, EitherT isn't a MonadCatchIO instance
06:04:49 <Kinnison> I imagine that's because there'd be no guaranteed way to convert an IO exception to your error type
06:07:10 <joelteon> Ok, that makes sense
06:07:25 <Kinnison> You can probably build an instance
06:07:49 <joelteon> Yeah, I did, it's pretty simple apparently
06:07:59 <Kinnison> :_)
06:08:05 * hackagebot hi 0.0.3 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-0.0.3 (DaisukeFujimura)
06:08:20 <joelteon> ok, sweet
06:08:32 <joelteon> so if an exception is raised, I get Left ex
06:08:40 <joelteon> if the OAuth function fails, I get a Right (Left s)
06:08:44 <joelteon> otherwise I get a Right (Right s)
06:08:52 <joelteon> beauty
06:10:30 <joelteon> ErrorT has a similar problem to this one
06:14:08 <allsystemsarego> Hi all, when using the Arrow interface, how do I match HXT XML tags which are anything but a predefined set of tags (exclusion list) ?
06:18:59 <donri> allsystemsarego: hasNameWith looks relevant
06:20:08 <donri> allsystemsarego: isElem >>> hasNameWith (\x -> not (x `elem` exclusions))  -- maybe
06:20:46 <allsystemsarego> donri, thanks, I'll look into it
06:36:58 <hape02> @type zipWith
06:36:59 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
06:37:07 <hape02> @type id
06:37:08 <lambdabot> a -> a
06:37:13 <hape02> @type zipWith id
06:37:13 <lambdabot> [b -> c] -> [b] -> [c]
06:37:48 <hape02> can anybody give me a hint why type of   zipWith id   is what it is?
06:38:05 * hackagebot Rlang-QQ 0.0.0.2 - quasiquoter for inline-R code  http://hackage.haskell.org/package/Rlang-QQ-0.0.0.2 (AdamVogt)
06:38:28 <mauke> look at the type of 'id' and set a = (x -> y)
06:42:07 <hape02> but how can   (a->b->c)    in   (a -> b -> c) -> [a] -> [b] -> [c]        "unificate" with   a->a  ? I am lost
06:42:21 <hape02> hmmm
06:42:39 <danr> unify
06:42:44 <hape02> yes
06:42:46 <mauke> a->b->c means a->(b->c)
06:42:48 <danr> and it cannot
06:42:50 <danr> :)
06:42:56 <mauke> totally can
06:44:26 <danr> oh
06:44:40 <danr> I thought we were unifying (a -> b -> c) with [a] -> [b] -> [c]
06:45:31 <FreeFull> Seems when you do  mapM_ (forkIO . putStr . repeat) ['a'..'z']  the output will be roughly but not exactly alphabetic (assuming -threaded )
06:46:47 <merijn> Math vocabulary check, should it be: "we can model f as a function *over* some predictor x" or "we can model f as a function *of* some predictor x"
06:47:21 <merijn> FreeFull: Yes, that is result of the way the GHC RTS does the locking around stdout
06:49:53 <hape02> mauke: Now I think for a second I got the point :-) thx!             very helpful:  a->b->c means a->(b->c)
06:50:07 <merijn> hape02: Yes, that's correct
06:50:49 <merijn> Aww...all the math people are asleep :(
06:51:16 <tomejaguar> What's a predictor?
06:52:26 <merijn> Something that predicts?
06:54:38 <quicksilver> merijn: function of
06:54:41 <exicer> Argh, I semi understand monads, then people start talking about arrows! How many more things are there!
06:54:49 <tomejaguar> exicer: 5
06:54:52 <merijn> exicer: Arrows are much less important
06:54:52 <exicer> :p
06:54:53 <quicksilver> ALL THE THINGS
06:55:07 <tomejaguar> Arrows are cool
06:55:44 <exicer> I was trying to understand this thing: http://codingtales.com/2012/04/25/scraping-html-with-handsomesoup-in-haskell
06:55:46 <merijn> exicer: Also, once you get Functors/Applicative/Monads, things start to become easier to get, since you get the knack of thinking a certain way
06:55:48 <exicer> it looks so simple!
06:55:52 <exicer> Maybe because they use arrows..
06:56:06 <merijn> quicksilver: Thanks! :)
06:56:29 <exicer> merijn: The problem at the moment is, I kinda understand them - but I don't understand how to use them in practice
06:56:43 <exicer> The thing I'm currently flailing away at is awash with maybes
06:56:45 <merijn> exicer: That problem should be tackled by writing more code ;)
06:56:49 <exicer> and I'm sure it can't be right
06:57:15 <exicer> merijn: Hehe, yeah - well I'm working on that ;)
06:57:29 <merijn> exicer: r/haskell and here usually has a couple of people willing to critique your code and provide feedback on better ways to do things
06:58:14 <exicer> I'll at least get it working before asking for a critique..
06:58:25 <exicer> Unless I get stuck :p
06:58:30 <merijn> exicer: hmm, that page doesn't load for me, but if you want to do webscraping I had a decent amount of success using http-conduit and html-conduit
06:58:44 <merijn> I thought the API was pretty simple and self-explanatory
06:58:57 <exicer> I am using http-conduit at the moment, in a really simplistic fashion
06:59:25 <merijn> exicer: Oh, then definitely use html-conduit for the scraping
06:59:46 <exicer> merijn: Fortunatley, the thing I'm doing at the moment just provides the data in a tab delimited format from a url
06:59:51 <exicer> So it isn't yet necessary
07:00:02 <merijn> ah :)
07:01:09 <merijn> Anyhoo, math formulation answered I should go off IRC again in the interest of actually writing :)
07:28:12 * hackagebot llvm-general-pure 3.2.7.3 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.2.7.3 (BenjaminScarlet)
07:28:14 * hackagebot llvm-general-pure 3.3.7.3 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.7.3 (BenjaminScarlet)
07:28:16 * hackagebot llvm-general 3.2.7.3 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.7.3 (BenjaminScarlet)
07:28:18 * hackagebot llvm-general 3.3.7.3 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.7.3 (BenjaminScarlet)
07:33:56 <gdoteof> if anyone has a haskellwiki account The Dead Simple, No Chit Chat, Zero-Analogy Haskell Monad Tutorial is a dead link on http://www.haskell.org/haskellwiki/Monad_tutorials_timeline#year_2011
07:38:34 <rmyers> i'm having a problem with Text.Regex's subRegex: http://lpaste.net/91899. anyone have any ideas?
07:39:11 <mauke> why do you think it supports \s?
07:40:52 <ghorn__> is ghc 7.8 going to magically fix the linker problems with ghci and C++ bindings?
07:41:00 <rmyers> mmmm i suppose i am ignorant, why wouldn't it? i'm by no means a regex expert and i am sorry if that is a stupid question
07:41:41 <byorgey> gdoteof: is it still a dead link if no one has a haskellwiki account? ;)
07:41:44 <byorgey> (fixed)
07:43:00 <rmyers> mauke: "Makes a regular expression with the default options (multi-line, case-sensitive). The syntax of regular expressions is otherwise that of egrep (i.e. POSIX "extended" regular expressions).". led me to believe there wouldn't be anything special except the egrep syntax, which afaik, supports \s?
07:43:13 <mauke> rmyers: no, egrep doesn't support \s
07:43:31 <mauke> \s is a perl innovation AFAIK
07:43:47 <mauke> POSIX extended regex is very, very limited
07:44:32 <rmyers> hmm, ok, thanks. sorry for the non-haskell question - i'll dig into posix extended regex.
07:47:08 <geekosaur> this is one of the reasons regexes are kinda a bad way to go; there's a zillion different implementations, all subtle different. and the only ones that have any kind f standard associated with them are very limited
07:48:41 <rmyers> geekosaur: is there a better way? i'm trying to write a function to convert any number of spaces in a row more than 2 into a single tab.
07:52:26 <mauke> florp (c1 : c2 : cs) | isSpace c1 && isSpace c2 = '\t' : florp (dropWhile isSpace cs); florp (c1 : cs) = c1 : florp cs; florp [] = []
07:53:09 <tikhon> good name, florp
07:54:13 <mauke> hmm
07:54:48 <mauke> this does some redundant isSpace checks
07:55:10 <tikhon> maybe do something with groupBy?
07:55:22 <allsystemsarego> Hi all, http://lpaste.net/91900 I don't understand why QN is not in scope. Also, please review and critique my first attempt at parsing XML with HXT
07:55:50 <rmyers> mauke: hmm, a couple things i'm not familiar with in there. i'm going to play a bit with this.
08:04:17 <byorgey> allsystemsarego: Text.XML.HXT.DOM.QualifiedName  does not export the QN constructor.
08:04:24 <byorgey> it only exports the QName type.
08:04:55 <allsystemsarego> oh
08:05:00 <byorgey> allsystemsarego: to construct a QName you have to use functions like mkQName, mkName, mkNsName, etc.
08:05:18 <allsystemsarego> ok, thanks, I'll look into those
08:05:49 <byorgey> allsystemsarego: shadowing the name 'x' on line 27 is a bit confusing, I wouldn't recommend it
08:05:57 <byorgey> otherwise it looks good to me
08:14:13 <exicer> Is there any way to do pattern matching on tuples?
08:14:20 <exicer> I mean in the same way that you can match (x:xs)
08:14:33 <exicer> If not - how the hell do you deal with large tuples?
08:14:37 <Work_jack> let (a, b, c) = ("yes", "there", "is") in a ++ " " ++ b ++ " " ++ c
08:14:44 <Work_jack> > let (a, b, c) = ("yes", "there", "is") in a ++ " " ++ b ++ " " ++ c
08:14:45 <lambdabot>   "yes there is"
08:14:51 <exicer> Sweet
08:14:54 <Work_jack> Normally you don't want large tuples though
08:15:02 <exicer> I guess you would want a datatype  ?
08:15:03 <Work_jack> You'd rather opt for using data or records
08:15:12 <exicer> yeah.. data is what I meant
08:15:25 <exicer> This is for a preliminary step towards making a record
08:17:01 <Work_jack> So instead of
08:17:01 <Work_jack>     type Name = String; type Age = Int
08:17:01 <Work_jack>     type Year = Int
08:17:01 <Work_jack>     type Person = (Name, Age, YearOfBirth)
08:17:04 <Work_jack> you might do:
08:17:08 <Work_jack>     data Person = Person { personName :: Name; personAge :: Age, yearOfBirth :: Year }
08:27:49 <bryanvick> Is there a way I can 'iterate' over fields of a record if they all have type T a?
08:28:01 <bryanvick> Something like traversable?
08:29:51 <tomejaguar> You can wite a traversal for it.  Lensy people will tell you how.
08:30:23 <hape02> is traversable more iterator or more runtime-type-informations?
08:31:14 <bryanvick> tomejaguar: I just set out to do that, but it requires a kind * -> *, but my record type doesn't take a parameter
08:31:31 <byorgey> hape02: iterator.
08:31:48 <bryanvick> it's just a bunch of data, and I don't want to manually put all fields into a list to iterate them
08:31:58 <byorgey> bryanvick: I don't know if traversal is quite what you want.  Perhaps you want some sort of generic programming library such as uniplate.
08:32:04 <tomejaguar> What do you want to do with them then?
08:32:18 <tomejaguar> Modify them?
08:32:23 <Work_jack> byorgey: It sounds like you may be going down the wrong path
08:32:24 <byorgey> which will let you do something to all the subcomponents of some value.
08:32:29 <bryanvick> tomejaguar: they're all Either a b, and I want to see if any are Left
08:32:38 <byorgey> Work_jack: I might.  Why do you say that?
08:33:24 <Work_jack> If it has kind * and you're trying to force it into a kind * → * that's indicative of that, of course it's not always the case
08:33:27 <tomejaguar> bryanvick: If you don't want to write to them I'd just write the equivalent of a Foldable instance
08:33:38 <byorgey> Work_jack: oh, did you intend that comment for bryanvick?
08:33:47 <Work_jack> Oh yes I did, sorry byorgey
08:33:52 <tomejaguar> bryanvick: i.e. just implement toList
08:34:16 <bryanvick> tomejaguar: the data type holds the results of parsing a web form. If any fail, I want to return 400, otherwise continue
08:34:21 <supki> > ("hello", 'c', [1..3], ("something", 7, 'z')) & biplate %~ (reverse :: String -> String)
08:34:23 <lambdabot>   ("olleh",'c',[1,2,3],("gnihtemos",7,'z'))
08:34:43 <bryanvick> tomejaguar: toList sounds like what I need, I'll check it out
08:35:08 <Work_jack> bryanvick: Maybe you want something like Maybe, Either or ErrorT?
08:35:45 <DMcGill> nobody will ever convince me that biplate isn't black magic of the highest degree
08:37:47 <Work_jack> DMcGill: Has anyone tried to ;)
08:38:00 <DMcGill> probably not, any good blog posts?
08:38:12 <quicksilver> biplate is code smell though
08:38:22 <quicksilver> it's metaprogramming and suggests you might have your data types wrong
08:38:29 <quicksilver> or that there might be a simpler way.
08:38:38 <quicksilver> FSVO 'simpler'.
08:41:20 <luite> quicksilver: hmm, for transformations on AST-like things i don't know a way that's quite as convenient
08:41:49 <quicksilver> luite: sure, it has a place.
08:42:07 <quicksilver> luite: when it's just saving you writing a bunch of hand-rolled traversal functions
08:42:23 <quicksilver> luite: but when you're using it to compensate for the fact you chose an unnatural data structure....
08:42:42 <luite> it's really easy to go overboard though, and make your program way too slow :)
08:43:03 <luite> with the convenience of biplate (or now lens, which includes the same stuffs)
08:44:16 <edwardk> i mostly use uniplate as a default definition for 'plate'
08:45:47 <edwardk> > ("these","examples",["are","silly"],111 ::Int) & biplate %~ reverse . fmap toUpper
08:45:48 <lambdabot>   ("ESEHT","SELPMAXE",["ERA","YLLIS"],111)
08:46:31 <bryanvick> tomejaguar: Foldable requires kind *->* too, maybe I'm approaching this entirely wrong
08:46:43 <cschneid> is there a 2 line explaination of what a plate is? (biplate/uniplate/whatever?)  I've seen it several times now
08:48:00 <tomejaguar> bryanvick: I didn't mean use foldable, I meant just write a toList function
08:48:17 <tomejaguar> but yeah making your datatype more generic will probably help things
08:49:04 <bryanvick> tomejaguar: ahh, yes.  That's what I think I'll have to do.  I was just hoping there was some way to automatically convert all fields of a record into a list w/ magic. Thanks for the help
08:51:13 <edwardk> @remember Taneb You know you've made it when SPJ asks you for help with Haskell.
08:51:13 <lambdabot> I will never forget.
08:53:25 <allsystemsarego> [hxt]: http://lpaste.net/91901 My code compiles now thanks to byorgey, but I get some unexpected output, any ideas?
09:03:13 * hackagebot module-management 0.16 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.16 (DavidFox)
09:05:32 <c_wraith> allsystemsarego: well, I can guess why you're getting "\n     " instead of what you expect. I have no idea why you're getting duplicated results. I think the "hasNameWith" is matching on the guest element itself, not the element you're hoping for.
09:06:35 <allsystemsarego> oh
09:07:30 <c_wraith> But I don't know enough about hxt to even guess why the duplicated results are happening
09:09:54 <levi> cschneid: The Xplate things are abstractions that make it easier to do Scrap Your Boilerplate-style data-generic programming. When you have a recursive data type that can hold more than one type of data, they let you easily perform traversals (maps, folds, etc.) that work on all instances of one type of data in your recursive structure.
09:10:30 <cschneid> levi: thanks.  Not sure what "Scrap Your Boilerplate" is.
09:10:32 <cschneid> time to google
09:11:35 <cschneid> levi: it's hard learning haskell when all explainations are at the 100 foot level of what, and not the 10k foot level of "what, and why would you care"
09:11:53 <levi> cschneid: I know what you mean. :)
09:12:19 <cschneid> luckily irc is a good resource for that :)
09:12:28 <cschneid> really I should go make docs better as I learn.
09:12:33 <cschneid> grumble. grumble. :)
09:13:35 <Work_jack> There is a lot of interesting stuff in Haskell but you can do surprisingly much with a ‘simple’ subset of Haskell
09:14:01 <Work_jack> Problem(?) is that libraries tend to use complicated features
09:18:29 <levi> cschneid: The basic idea of datatype-generic programming is parameterizing things over the structure or shape of a type rather than the specific type. AST traversal or XML structure traversal is a common use case.
09:19:24 <cschneid> levi: how often does this come up? Is this the kind of thing that is needed for real programs, or a way to simplify an otherwise working program?
09:19:28 <cschneid> ie, can I put off learning this :)
09:19:36 <Work_jack> cschneid: Yes
09:19:52 <LordBrain> Are cabal questions ok here? or is there a separate channel?
09:19:56 <levi> You can put off learning it, but it is pretty useful. You can use it without deeply understanding how it works, though.
09:20:14 <cschneid> levi: any tutorials you know of, that show examples without diving right into the implementation?
09:20:18 <levi> cschneid: Think about how you would type an XML file.
09:20:27 <Work_jack> (I mean stricly speaking you can put off learning how to define functions in C)
09:20:40 <tikhon> LordBrain: I think this is a reasonable place for cabal questions
09:21:04 <cschneid> Work_jack: hah, sure. More of a feasibility thing, there are "required" parts to languages to make use of them feasibly, and then there are "extras" that let you do things quicker/safer
09:21:05 <levi> What kind of operations might you want to do with a data structure representing an XML file?
09:21:08 <edwardk> i just posted https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication-part-2 if anyone wants to give feedback before the world sees it and help me fix typos that would be great
09:21:46 <cschneid> levi: not sure. Search on nodes, spin it back to text.
09:21:50 <Work_jack> cschneid: I would not call Uniplate or anything similar a required part of Haskell
09:21:57 <LordBrain> Ok, I am trying to detect the absence of a library without using pkg-config, so i used an Includes field and an Extra-libraries field in the .cabal file, but it seems not to be triggering that check because configure runs without complaint even when i don't have the library installed.
09:24:48 <LordBrain> http://lpaste.net/91902
09:25:24 <LordBrain> see the part with the NoPkgConfig flag, and the little if statement at the bottom of the idris.cabal. That's what i added.
09:26:07 <levi> cschneid: Well, often you want to look for nodes with specific tag names and only do your updates on *those* nodes. It's fairly easy to design a type that stores every kind of node as a type with a tag string, a list of attributes (which are just string pairs) and a list of nodes. Then you can write a simple function for traversal and transformation.
09:26:37 <cschneid> levi: right. Which is how I'd assume you'd go at it
09:27:03 <cschneid> I did something similar with some yaml file reading. Building the "traversals" I need (although probably could have been much cleaner by using built-in typeclasses
09:27:21 <LordBrain> The problem is, cabal configure seems to succeed even tho i don't have the specified library or include file installed in the system.
09:29:43 <LordBrain> if i use the default in which NoPkgConfig is set to false, it uses pkg-config, detects that bdw-gc is not installed  works as expected.
09:29:58 <levi> cschneid: But then you aren't taking advantage of an opportunity to have the type checker help out with making well-formed XML that obeys some schema.  For example, some tags only accept a subset of possible tags as children.  If tags were typed rather than just strings, you could express these kinds of relationships in your type definitions.  But then your traversal would get littered with all sorts of type case analysis that's really
09:29:58 <levi> just boilerplate.
09:30:46 <cschneid> levi: ok, and plates is a way to turn that into a library, as opposed to writing it out?
09:31:01 <LordBrain> However, I have read on stack-overflow that pkg-config isn't distributed with the haskell platform, and so i am trying to provide this NoPkgConfig flag as a courtesy to windows users.
09:31:03 <cschneid> levi: sounds like something that I need to run into in a real app before really groking it.
09:31:07 <levi> That's the basic idea, anyway.
09:32:10 <LordBrain> i was inspired by this stack overflow question and answer: http://stackoverflow.com/questions/4959802/how-to-specify-dependency-on-external-c-library-in-cabal
09:33:14 * hackagebot cpphs 1.17 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.17 (MalcolmWallace)
09:33:57 <cschneid> levi: thank you a bunch for explaining it. I have the 10k look at it now, even if I haven't gotten down to code level :)
09:34:05 <cschneid> I now know when I want to go learn it
09:34:15 <cschneid> (stored off a thunk to eval later).
09:34:41 <levi> cschneid: Well, it's a common problem. Every time you have a tree-like type that has multiple types of "branches" that you want to preserve the detailed type information on, you hit a bunch of tedious boilerplate in working with the type.
09:35:19 <cschneid> levi: ok, cool - I'll keep that in mind, and it sounds like it'll come in handy pretty quick as I write "real" programs
09:35:29 <levi> You usually make the type that way so that you can only construct "meaningful" instances of each branch type, which helps you catch a lot of programming errors with the type system.
09:35:30 <cschneid> (as opposed to small exploration toy programs)
09:35:48 <LordBrain> In order to test the NoPkgConfig flag, without using windows, i just ran cabal configure -fNoPkgConfig without the library installed.  Even though I do  have pkg-config here on my build machine (Debian Wheezy), I figured cabal should still read the Includes and Extra-libraries fields and report the missing dependency.
09:36:20 <LordBrain> Is anyone reading my posts?
09:37:36 <levi> cschneid: edwardk's Lens library makes heavy use of this general idea and wraps it up in a package that's fairly easy to use with a lot of documentation and such, so it's a convenient way to use it without needing to understand entirely how it works.
09:37:57 <cschneid> levi: ok, so lens is an implementation of this same idea as well? Because I've looked into that too
09:38:18 <levi> cschneid: It's built on top of Uniplate/Biplate, I believe.
09:40:20 <cschneid> levi: ahh, cool.  I attempted to watch the NY Haskell meetup talk on lenses, but that went over my head/attention.
09:41:00 <jfischoff> what is the way to tell the compiler to check some external file for changes when running TH?
09:41:25 <jfischoff> qAddDependentFile nv
09:43:46 <enthropy> levi: can uniplate/lens do generic zips?
09:44:12 <jfischoff> I don't think so but syb can
09:46:37 <enthropy> > gzipWithT (mkQ (mkT (\x -> x::String)) $ \y -> mkT $ \x -> (y::String)++x ) ("ab","cd") ("xy", "zw")
09:46:38 <lambdabot>   Not in scope: `gzipWithT'
09:46:38 <lambdabot>  Perhaps you meant one of these:
09:46:38 <lambdabot>    `zipWith' (im...
09:47:25 <enthropy> it would be nice if the mkFoos were unnecessary
09:47:31 <edkk> hmmm, I think you are looking for zip | gunzip
09:48:05 <mauke> gzip --with-t
09:48:14 * Clint twitches.
09:48:40 <enthropy> ("abxy","cdzw") -- is what it prints anyways
09:53:22 <Narvius> Hello, would someone be willing to take a look at my IRC bot in Haskell and explain two things to me?
09:54:01 <enthropy> you'd have to show the bot and say what the things are :)
09:54:05 <Narvius> :3
09:54:07 <Narvius> http://pastebin.com/ZxtktLmx
09:54:10 <mauke> The paste ZxtktLmx has been copied to http://lpaste.net/91903
09:54:28 <Narvius> The first thing is documented in a comment on line 67 or so
09:54:44 <Clint> are you writing this from scratch for fun?
09:55:10 <Narvius> Yes. Though I did take a peek at that tutorial called Roll you own IRC bot in Haskell before writing it.
09:55:16 <Narvius> Though I'm not copying any code.
09:55:22 <Clint> 'cuz there are a couple of ircbot libraries
09:56:02 <Narvius> :)
09:56:39 <Narvius> Either way, one other thing I don't understand is, when the bot quits, it always quits via "Error: Connection reset by peer", not the quit message I sent.
09:56:58 <ParahSailin> would a Monad instance of ZipList be hard?
09:59:50 <haasn> does http://ghc.haskell.org/trac/ghc/wiki/Roles mean GNT is safe?
09:59:58 <haasn> or are there issues left?
10:00:43 <haasn> ParahSailin: as I understand it, it's impossible
10:01:36 <enthropy> Narvius: when you exitSuccess I don't think the very last line (103) gets run
10:01:39 <enthropy> that might be the issue?
10:02:23 <Narvius> Well, I flush with every send, so I wouldn't know why, but I'll try doing something about that.
10:02:36 <Narvius> why that would matter*
10:03:31 <geekosaur> hm, could this be related to the thing we found last night with exceptions (exitSuccess works via an exception, IIRC)?
10:04:08 <geekosaur> (if I recall incorrectly about it using an exception in order to force stuff to wind up properly, then no, it's not related)
10:04:43 <enthropy> at least don's example has `bracket' to close the connection when the exception gets thrown http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
10:04:49 <geekosaur> ("we" being the channel, I was minimally involved)
10:07:25 <Narvius> Yeah, I was rewriting it to use bracket right now, but I have to walk my dogs for now. _^_
10:07:58 <haasn> Narvius: maybeCall x = x >>= ($ args)
10:08:09 <haasn> sorry for not being more helpful :)
10:10:31 <enthropy> ParahSailin: instance Monad ZipList where return _ = ZipList []; _ >>= _ = ZipList []
10:11:57 <biscarch> is anyone querying solr from Haskell?
10:12:07 <enthropy> following laws doesn't make something useful
10:12:31 <haasn> enthropy: that violates the laws
10:13:04 <geekosaur> no, but not following them means the compiler may do unexpected things with your code
10:13:10 <enthropy> why? I thought   data Const a = Const was a legal Monad
10:13:18 <haasn> it is, but ZipList isn't Const
10:14:13 <haasn> enthropy: x >>= return = x -- a monad law
10:14:29 <haasn> enthropy: ZipList [1,2,3] >>= return  = ZipList [] -- in your instance
10:15:31 <enthropy> hmm, so those examples only work if you can make ZipListS that aren't  ZipList []
10:15:40 <enthropy> *counterexamples
10:15:52 <haasn> yes, hence ZipList /= Const
10:16:23 <haasn> if the only valid value is ZipList [] then it wouldn't be very useful in general
10:16:47 <josephle> hah, it seems to be a trend to be working on haskell IRC bots (whether that be maintaining lambdabot or writing your own)
10:17:10 <enthropy> lambdabot is probably a decade old
10:17:11 <haasn> I've found that working on IRC bots is a popular thing to do when learning a language in general
10:18:00 <josephle> haasn: does it hit up most of the important concepts a programmer would need to know about a language?
10:18:50 <haasn> I don't know, but it's a popular example of a nontrivial program.  Note: my sample includes programmers on IRC, so it may be slightly biased
10:18:59 <josephle> heh, true
10:19:01 <haasn> s/includes/consists of/
10:22:24 <levi> Narvius: It could be that when you flush your quit command, the connection is closed on the remote end, which raises that error due to a SIGPIPE?
10:23:24 <levi> The Network documentation talks about how to add a SIGPIPE handler; you might see if that changes things. Alternatively, (assuming you are running on Linux) you could run strace on your process and see if it gets a SIGPIPE signal.
10:27:03 <haasn> levi: if I understood it, he's complaining about the message that appears server-side, not locally
10:27:25 <Narvius> haasn: Yes, would be - but I return "return ()" in the my maybeCall, not Nothing (Maybe monad).
10:27:55 <haasn> if he sent the quit command, and the server received and handled that, then the right quit message would display
10:28:04 <haasn> (then again, are you sure the IRCd is not ignoring QUIT messages for unregistered users or something?)
10:28:25 <Narvius> ...funnily enough, when I look back at the logs
10:28:54 <haasn> oh, you're right; your ‘m’ in maybeCall /= Maybe
10:29:00 <Narvius> <Narvius>#quit ten
10:29:00 <Narvius> - NarvbotHS quit (Client exited)
10:29:00 <Narvius> - NarvbotHS joined
10:29:00 <Narvius> <Narvius>#echo Narvius
10:29:00 <Narvius> <NarvbotHS> Narvius
10:29:00 <Narvius> <Narvius>#quit
10:29:00 <Narvius> <Narvius>#quit 2
10:29:01 <Narvius> - NarvbotHS quit (Quit: Aw noes, I dies. :O)
10:29:01 <Narvius> <Narvius>...weird.
10:29:02 <Narvius> - NarvbotHS joined
10:29:02 <Narvius> <Narvius>#foo
10:29:03 <Narvius> <Narvius>#quit
10:29:13 <Narvius> It worked once
10:29:16 <Narvius> And then never again.
10:29:17 <haasn> please don't paste in here
10:29:18 <Narvius> Okay.
10:29:24 <Narvius> Sorry.
10:30:17 <levi> So, 'connection reset by peer' appears on the server?
10:31:19 <chrisdone> evening
10:34:08 <Narvius> Yes.
10:34:29 <Narvius> (Tangent: Considering I'm doing Haskell for two months, how is my code stylistically?)
10:34:58 <haasn> not 80col :(
10:35:18 <haasn> lacking some top-level type signatures as well
10:36:11 <Narvius> ...:/
10:36:15 <Narvius> That's not what I meant. xD
10:36:39 <Peaker> Narvius, where is your code again?
10:36:39 <haasn> you might also want to break up some of the longer / weirder (>>) (>>=) chains into more verbose but also more understandable do blocks; thus also eliminating the need for eg. localPrint :: String -> IrcIO String -- as opposed to :: String -> IrcIO ()
10:36:52 <Narvius> http://pastebin.com/ZxtktLmx
10:36:53 <mauke> The paste ZxtktLmx has been copied to http://lpaste.net/91903
10:37:34 <Peaker> Narvius, reading your code... I really dislike open imports (But there's no consensus about it)
10:38:16 <Peaker> Narvius, so far seems Ok, I'd consider more type synonyms or even newtypes for all the various strings
10:39:12 <haasn> Narvius: I'm also not convinced why break (== ' ') would be any different than your head.words / drop (1 + length words) approach
10:39:20 <Narvius> Because it didn't work.
10:39:24 <Narvius> I can't explain why, really.
10:39:25 <haasn> works here
10:39:28 <Narvius> Weird.
10:39:37 <Peaker> Narvius, why did you write "send cmd msg = asks socket >>= (\h -> ..)" this is exactly what do notation is for
10:39:37 <Narvius> I use ghc from the Platform.
10:39:52 <Peaker> > break (== ' ') "hello  world"
10:39:53 <lambdabot>   ("hello","  world")
10:40:14 <haasn> > let ('#':msg) = "#quit"; (cmd, args) = break (== ' ') msg in (cmd, args)
10:40:15 <lambdabot>   ("quit","")
10:40:20 <levi> 'Connection reset by peer' is from the TCP stack, saying it got a RST from the peer in response to something it sent. It's usually due to the remote end not gracefully closing the connection. I'm guessing that something is 'in-flight' to the bot as you're quitting, and there's a race between the FIN due to the process exit and the quit command.
10:40:32 <haasn> > let ('#':msg) = "#quit"; cmd = head . words $ msg; args = drop (1 + length cmd) msg in (cmd, args)
10:40:33 <lambdabot>   ("quit","")
10:40:43 <Narvius> Yes, you don't need to prove it to me, haasn.
10:41:14 <haasn> but if you run those commands inside GHCi on your local machine, do the results differ?
10:41:14 <Narvius> Thanks, levi.
10:41:43 <kryft> Peaker: What's an open import? Importing everything without qualification?
10:42:04 <Narvius> haasn: Nope, they don't.
10:42:16 <Narvius> That's why I came here to ask about that among other things, because I just can't explain it.
10:42:48 <Peaker> kryft, yeah:  import Network (dump its namespace into my namespace, even future names I have no way of knowing won't conflict with my names :-(  )
10:43:08 <Peaker> kryft, it makes the module less robust to future changes in dependencies for a very very tiny gain
10:44:07 <kryft> Peaker: Right
10:45:05 <levi> Narvius: Probably the ircd's IO handler processes error events from the socket before read/write events, and your quit command is queued in the receive buffer but never gets read due to getting a FIN in response to an ACK or something around the same time.
10:45:12 <chrisdone> Peaker: personally i don't remember having a conflict like that in the years i've been haskelling. is it a big deal?
10:45:27 <levi> Er, RST, not FIN.
10:45:48 <Narvius> levi: I tried a threadDelay inbetween, but didn't seem to change anything.
10:47:23 <Narvius> Peaker: Either way, I'm trying to avoid open imports, but when first working with package, I open import it until I know what it does, more or less.
10:47:42 <levi> Narvius: My approach would be to have the quit command set a flag that will make the main processing loop stop after it reads the next response from the ircd.
10:48:16 <chrisdone> at least if you're the type to do explicit imports, you can use ghc's dump-minimal-imports flag to get an import list of your module that is closed just over the things you're using
10:48:23 <jfischoff> chrisdone: that's probably because you don't choose names that conflict. If you are working on code base with inexperienced haskellers it happens.
10:48:49 <Narvius> levi: I'd have to tack on a StateT, then. No?
10:49:06 <levi> Or have the commands return a value instead of ()
10:49:17 <Narvius> Hm.
10:49:18 <Narvius> Okay.
10:50:12 <Narvius> Peaker: As to the type aliases for the strings; I feel it would be overkill to do so when most different uses for strings are in one function.
10:50:29 <Narvius> Peaker: And those will end up as command line arguments, either way.
10:50:34 <chrisdone> jfischoff: yeah, i think i do tend to pick names with a presumption of an open import
10:50:51 <jfischoff> likewise
10:51:57 <jfischoff> less haskellers will choose names like many, empty, left, etc
10:52:08 <jfischoff> err less experienced
10:52:11 <chrisdone> lol
10:52:20 <chrisdone> lesser haskellers, beneath our stature
10:52:24 * chrisdone pouts
10:52:31 <jfischoff> oh man
11:11:31 <Narvius> levi: I changed it according to your advice, and now it it says "NarvbotHS quit (Client exited)", and once it worked and used my quit message - so that's progress, thank you!
11:13:21 * hackagebot monadcryptorandom 0.5.3 - A monad for using CryptoRandomGen  http://hackage.haskell.org/package/monadcryptorandom-0.5.3 (ThomasDuBuisson)
11:16:58 <levi> Narvius: Nice!
11:21:35 <Narvius> levi: I've read up on the RCF for IRC, and it says that the server should acknowledge QUIT with an ERROR. So, I've reverted back to not returning anything, and now quit on receiving ERROR. Still, thanks. :>
11:22:49 <phulin> do you guys think it would be faster to use MaybeT (State) or to build a custom monad which integrates the two?
11:23:00 <phulin> like, does MTL have optimizations built in?
11:23:04 <phulin> or something
11:23:22 * hackagebot module-management 0.16.1 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.16.1 (DavidFox)
11:26:24 <Narvius> levi: And the other thing, about it using my quit message or not: That seems to be a server-specific thing, where it disregards the message if the quit happens BEFORE the first ping (just for future reference).
11:33:00 <ReinH> edwardk: hai
11:33:11 <edwardk> yo. one sec. switching networks
11:34:05 <ReinH> kk
11:34:57 <byorgey> phulin: Who knows?  Just use MaybeT State.
11:35:02 <byorgey> It is probably fast enough.
11:35:19 <phulin> byorgey: my tool is currently taking O(days) to run
11:35:34 <byorgey> ah.  well that is a different question. =)
11:35:46 <byorgey> phulin: have you done any profiling?
11:36:04 <phulin> byorgey, yeah
11:36:18 <byorgey> I have heard of people pulling fancy tricks with CPS-encoded monad stuff to make things faster, but I don't know a lot about it
11:36:19 <phulin> though i'm collceting a much longer profiling run now
11:36:21 <edwardk_> back =)
11:36:32 <phulin> yeah i saw something about that on the wiki but i didn't understand
11:36:40 <edwardk_> byorgey: what was the question?
11:36:49 * edwardk_ does lots of fancy cps encoding tricks
11:36:58 <byorgey> edwardk_: (14:22) <    phulin> do you guys think it would be faster to use MaybeT (State) or to build a custom monad which integrates the two?
11:37:21 <byorgey> edwardk_: phulin's tool currently takes a Very Long Time to run, and is looking for optimization opportunities
11:37:28 <phulin> edwardk_: i'm writing a tool which is supposed to symbolically execute O(10^10) instructions
11:37:30 <newsham> edk: "I've posted the result from the first 2 No-Prizes inline in the original post, with the spoilers being hidden."  where?
11:37:34 <enthropy> @quote transformers.*speed
11:37:34 <lambdabot> dcoutts says: monad transformers are not known for their blistering speed
11:38:01 <phulin> yeah, that's what the wiki seemed to say
11:38:15 <jfischoff> codensity to the rescue! … maybe?
11:38:17 <edwardk> my experience is you can make a slightly faster cps'd state monad or cps'd state + exception monad
11:38:22 <byorgey> . o O ( "For my next trick, I will CPS-encode this rabbit!" -- edwardk )
11:38:45 <jfischoff> @remember byorgey . o O ( "For my next trick, I will CPS-encode this rabbit!" -- edwardk )
11:38:45 <lambdabot> I will remember.
11:38:50 <tomejaguar> The Haskeller's Golden Rule: If in doubt, CPS transform.
11:39:07 <edwardk> forall r. (a -> s -> r) -> s -> r -> r
11:39:19 <edwardk> alternately (a -> s -> r) -> r -> s -> r  can be a little faster
11:39:33 <edwardk> because you don't have to flop args so much
11:39:34 <shachaf> tomejaguar: I prefer the cogolden rule: When CPS-transforming, doubt.
11:39:48 <newsham> edwardk: I dont see the spoilers in the first post
11:40:12 <jfischoff> @remember shachaf I prefer the cogolden rule: When CPS-transforming, doubt.
11:40:12 <lambdabot> It is stored.
11:40:19 <tomejaguar> shachaf: lol
11:40:42 <edwardk> newsham: didn't it put (Show) tags?
11:40:44 <phulin> heh, total alloc = 527,710,270,952 bytes
11:41:15 <newsham> edk: i dont see them when i load page.
11:41:23 <edwardk> newsham: hrmm
11:41:36 <phulin> oh jeez 97% of my time is spent doing string operations
11:41:37 <newsham> https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication-part-1 right?
11:41:41 <phulin> that's no good
11:41:58 <newsham> oh, now I see it.
11:42:19 <edwardk> newsham: There exists an unshuffle that works much more like shuffle! What is the definition? The first reader to email me a working version of it wins a No-Prize. **[Edit: No-Prize #1 has been awarded to Sanjoy Das. However, riotnerd was the first to provide both a working unshuffle alongside the proof that they compose to identity and so he has earned an honorable mention. His presentation showed good style and demonstrated
11:42:25 <edwardk>  the equality via clean equational rewriting.]
11:42:40 <DMcGill> phulin: When you say "string", do you mean String? Eww
11:43:01 <phulin> DMcGill, yeah - mostly required by the LLVM bindings I'm using
11:43:33 <sipa> or referring to the geberic concept of a character sequence, rather than the haskell implementation?
11:43:38 <sipa> generic
11:43:54 <phulin> no, referring to [Char]
11:46:23 <DMcGill> in that case, do you get any speed up from them compared to using Text, ByteString or Array and -fllvm?
11:47:02 <DMcGill> surely the bindings have support for more array-like strings than singly linked lists
11:47:19 <phulin> yeah never mind i'm being stupid
11:47:41 <DMcGill> it depends on what your use case is - Tries can be cool too
11:48:10 <dmwit> atomicModifyIORef lets you both modify the IORef and query it at the same time. Is there something similar in a library somewhere for MonadState?
11:48:33 <dmwit> :t \f -> do { (a, b) <- gets f; put a; return b }
11:48:34 <lambdabot> MonadState s m => (s -> (s, b)) -> m b
11:48:57 <exicer> Say I have [Maybe Int]. Is there some way using lift/bind/some monad magic that I can sum them? Other than defining my own function.
11:49:17 <dmwit> :t sum . catMaybes
11:49:18 <lambdabot> Num c => [Maybe c] -> c
11:49:29 <clahey> @pl [Maybe Int] -> Maybe Int
11:49:29 <lambdabot> (line 1, column 15):
11:49:29 <lambdabot> unexpected '>'
11:49:29 <lambdabot> expecting operator
11:49:38 <Rarrikins> @hoogle [Maybe a] -> [a]
11:49:39 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
11:49:39 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
11:49:39 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
11:49:40 <clahey> @djinn [Maybe Int] -> Maybe Int
11:49:40 <lambdabot> Error: Undefined type []
11:49:43 <dmwit> :t \ms -> sum <$> sequence ms
11:49:43 <clahey> Oh well.
11:49:44 <lambdabot> (Monad f, Functor f, Num b) => [f b] -> f b
11:49:59 <Rarrikins> > sum . catMaybes $ [Just 1, Nothing, Just 2, Just 3]
11:50:00 <lambdabot>   6
11:50:09 <dmwit> :t \ms -> sum <$> mconcat ms
11:50:10 <lambdabot> (Functor f, Num b, Monoid (f [b])) => [f [b]] -> f b
11:50:10 <clahey> exicer, What do you want the result to be?  a or Maybe a?
11:50:18 <dmwit> oops
11:50:20 <exicer> clahey: Maybe a - if there is a nothing, it should be nothing
11:50:23 <dmwit> That last one is a bit different. =P
11:50:30 <clahey> @hoogle [Maybe a] -> Maybe a
11:50:31 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
11:50:31 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
11:50:31 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
11:50:34 <dmwit> exicer: See my sequence one, then.
11:50:43 <exicer> Hmm, okay
11:50:55 <dmwit> :t mconcat . fmap (fmap Sum)
11:50:56 <lambdabot> (Functor f, Monoid (f (Sum a))) => [f a] -> f (Sum a)
11:50:58 <exicer> clahey: I did not realise you could use hoogle like that. that is awesome
11:51:00 <phulin> oh then you want foldl1 (fmap (+))
11:51:23 <clahey> :t sequence
11:51:24 <lambdabot> Monad m => [m a] -> m [a]
11:51:45 <clahey> I like liftM sum . sequence
11:51:55 <clahey> Which is the same as what dmwit said with sequence.
11:52:00 <clahey> :t liftM sum . sequence
11:52:00 <lambdabot> (Monad m, Num r) => [m r] -> m r
11:52:21 <exicer> Having so many ways to do things is a bit confusing, I have to say
11:52:29 <dmwit> These days, I have been convinced to prefer fmap (or (<$>)) to liftM.
11:52:38 <dmwit> exicer: Each of my suggestions has a different behavior!
11:52:41 <clahey> dmwit, Why?
11:52:57 <dmwit> fmap can be more efficient than liftM, because it doesn't have to go through (>>=).
11:53:12 * elliott mumbles something about inlining.
11:53:23 <clahey> dmwit, In this case, it should be pretty similar, but yeah.
11:53:25 <elliott> liftM has the advantage that you can make your code more edwardk with less effort!
11:53:39 <dmwit> clahey: Habits matter.
11:53:44 <clahey> Is there any time that it does something different?
11:53:46 <clahey> dmwit, True.
11:53:48 <chrisdone> hats also matter
11:54:19 <clahey> dmwit, So, would liftM just be fmap if all Monads were Functors?
11:54:23 <dmwit> :t state
11:54:24 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
11:54:31 <dmwit> :t state (head &&& tail)
11:54:32 <lambdabot> MonadState [a] m => m a
11:54:35 <dmwit> Perfect.
11:54:45 <dmwit> clahey: backwards
11:54:51 <dmwit> err
11:54:53 <shachaf> That depends on what you mean by "be".
11:54:57 <dmwit> clahey: By which I mean, "yes".
11:55:23 <dmwit> ?src liftM
11:55:23 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
11:55:27 <shachaf> They would be "the same function" in that there's only one possible definition of fmap/liftM that satisfies the laws.
11:55:36 <dmwit> I think liftM = fmap is a monad law.
11:55:46 <shachaf> But liftM would possibly still be written in terms of (>>=)/return, for convenience in defining Functor.
11:55:49 <shachaf> Or not. Who knows.
11:56:03 <ParahSailin> @ty fmap
11:56:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:56:15 <clahey> @ty liftM
11:56:16 <elliott> unfortunately making liftM efficient is impractical I think
11:56:16 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
11:56:18 <elliott> maybe as a rewrite rule
11:56:23 <elliott> because instance Functor MyMonad where fmap = liftM
11:56:37 <elliott> this is a sneaky kind of hidden dependency that you have to be aware of when restructuring class hierarchies :(
11:56:42 <shachaf> Yep.
11:56:46 <elliott> but maybe you can have a RULE to rewrite liftM to fmap
11:56:47 <shachaf> See also: liftA, fmapDefault
11:56:54 <elliott> and it'll stop firing if fmap = liftM
11:57:54 <edwardk> elliott: i use liftM a lot?
11:58:46 <elliott> edwardk: you make code polymorphic over m a lot :P
11:58:58 <elliott> (ok, probably over f more often)
11:59:03 <DMcGill> better to make it polymorphic over f if you can
11:59:10 <edwardk> fair nuff
11:59:36 <clahey> So, in haskell, by definition, every monad is a functor, right?
11:59:41 <clahey> But not every monad is an applicative?
11:59:44 <clahey> Is that right?
11:59:46 <shachaf> No.
11:59:54 <shachaf> Monad has no superclasses.
12:00:11 <clahey> The reason not to change that is that it would break a lot of existing code?
12:01:31 <merijn> clahey: The proposal to change it has already been accepted, the main questions are 1) will there be any problems that get in the way of the execution and 2) how much time will this cost
12:02:22 <clahey> merijn, I assume the change is to make the super class be Applicative?
12:02:27 <merijn> clahey: Yes
12:02:52 <b2coutts> oh, that's actually being changed?
12:02:53 <b2coutts> cool
12:04:13 <DMcGill> wait, so can you still make your Functor and Applicative be defined in terms of (>>=) if your type needs to already have instances of Functor and Applicative in order to be a Monad?
12:06:46 <shachaf> There's no "already".
12:07:12 <shachaf> instance Functor Foo where fmap = liftM; instance Applicative Foo where pure = return; (<*>) = ap; instance Monad Foo where ...
12:07:29 <monochrom> clahey: http://ro-che.info/ccc/21.html :)
12:07:32 <clahey> So, after such a change, would you just be able to define your monad in terms of join and >>= and everything else will work?  That's pretty awesome.
12:07:32 <shachaf> Or you could reverse the order of the definitions if you wanted to.
12:07:49 <clahey> Sorry, return, not join.
12:07:50 <shachaf> clahey: Either fmap,join,return or (>>=),return.
12:07:59 <clahey> shachaf, That's awesome.
12:08:06 <shachaf> Assuming join gets into the class, which it hopefully will.
12:08:09 <clahey> I would hope that liftM would go away.
12:08:13 <merijn> clahey: shachaf huh, join isn't part of the Monad typeclass, is it?
12:08:28 <shachaf> I think that's proposed along with the rest of it.
12:08:43 <ReinH> fmap, join and return are the most intuitive definition for me
12:08:44 <merijn> shachaf: Also, I guess you mean pure rather than return :p
12:09:04 <ReinH> where join is what defines the behavior and "sequencing" of the monadic effects
12:09:33 <shachaf> merijn: I do?
12:09:44 <yepyep> Hi, I'm interested in playing around with Haskell for system administration.  Other than one of the chapters in Real World Haskell, and perhaps some of the text parsing tutorials on School of Haskell can someone point me to some recommended resources?
12:09:58 <DMcGill> Learn You A Haskell is pretty awesome
12:10:04 <DMcGill> @where lyah
12:10:04 <lambdabot> http://www.learnyouahaskell.com/
12:10:17 <bergmark> @hackage shelly
12:10:17 <lambdabot> http://hackage.haskell.org/package/shelly
12:10:17 <yepyep> Read it already, thanks though.
12:10:18 <clahey> It's not immediately obvious to me how the definition of join affects the ordering of monadic affects in >>=.  But I want to think about it until I figure it out.
12:10:19 <monochrom> fmap-join-return is intuitive to me on odd days, bind-return is on even days
12:10:54 <ReinH> monochrom: a clever way to avoid the axiom of choice ;)
12:11:19 <oleo> the axe of choice!
12:11:19 <yepyep> from a more pragmatic point of view, what advantages does haskell as a system administration tool offer over say shell scripting or python aside from the typing system?
12:11:21 <oleo> lol
12:11:24 <ReinH> clahey: this is what made sense to me:
12:11:25 <monochrom> @quote monochrom debate
12:11:25 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
12:11:35 <ReinH> :t putStr <$> getLine
12:11:36 <lambdabot> IO (IO ())
12:11:43 <ReinH> clahey: nothing is printed until that is joined
12:12:18 <clahey> @src (<$>)
12:12:18 <lambdabot> f <$> a = fmap f a
12:12:21 <yepyep> shell scripting in general seems filled with edge cases, and I've gotten burned a number of times
12:12:30 <ReinH> clahey: sorry, <$> is infix fmap
12:12:39 <monochrom> haha, just thought up a new one: All pointless debates can be settled by going pointfree :)
12:12:45 <clahey> ReinH, It's fine.  I knew, but just wasn't remembering.
12:12:57 <merijn> monochrom: My, my, aren't you witty today? :p
12:13:28 <DMcGill> I don't think I've used actual "fmap" in ages, even up to the point of doing (f <$>) which is probably a bad idea
12:13:40 <monochrom> anyway, write join for C.M.State.Strict and C.M.State.Lazy, you may see how join is related to "order"
12:14:00 <bergmark> yepyep: haskell is nice for hacking some ugly shellscript together, it usually just works in my experience
12:14:03 <ReinH> it's related to order in monads where the structure involves ordering of effects or similar
12:14:20 <elliott> yepyep: you can look at shelly and the thing the Linspire people wrote about using Haskell for system administration type stuff.
12:14:33 <yepyep> bergmark: any practical examples on the net?
12:14:44 <elliott> don't know where to find the latter though.
12:15:04 <yepyep> I'd be curious to see some annotated examples.
12:15:05 <merijn> I guess the monad/functor laws guarantee that "fmap f x == x >>= return . f"?
12:15:14 <monochrom> yes
12:15:17 <ReinH> even Writer with a non-commutative monoid involves ordering :)
12:15:17 <yepyep> elliott: ok, thanks.
12:15:41 <ReinH> that might be the simplest example
12:16:35 <ReinH> two monadic contexts (monoidal values) are joined by mappend into a single monadic context
12:16:46 <bergmark> yepyep: i don't have anything public
12:17:51 <ReinH> Do people ever use (<>) = mappend ?
12:17:56 <tikhon> yes
12:17:58 <tikhon> all the time
12:18:01 <tikhon> I hate mappend
12:18:02 <ReinH> Seems like an obvious choice.
12:18:05 <monochrom> oh! and "mappend x y" vs "mappend y x" determines order? that's neat
12:18:11 <ReinH> It's concat in quite a few languages
12:18:20 <ReinH> monochrom: for non-commutative monoids, yes :)
12:18:23 <clahey> monochrom, Assuming it's a non commutative monoid.
12:18:55 <elliott> it's in Data.Monoid
12:19:00 <elliott> so yes you can use it :)
12:19:34 <shachaf> @let x >< y = y <> x
12:19:35 <lambdabot>  Defined.
12:19:43 <monochrom> >_<
12:19:54 <ReinH> elliott: oh ofc, so why doesn't hoogle show it?
12:20:07 <tikhon> > "abc" >< "def"
12:20:08 <lambdabot>   Ambiguous occurrence `><'
12:20:08 <lambdabot>  It could refer to either `L.><', defined at L.hs...
12:20:13 <tikhon> hah
12:20:20 <shachaf> Oh.
12:20:35 <shachaf> QuickCheck!
12:20:40 <shachaf> Does it even work?
12:20:44 <tikhon> @let a • b = a <> b
12:20:44 <lambdabot>  Parse failed: Illegal character ''\128''
12:20:45 <shachaf> @check join (==)
12:20:46 <tikhon> aww
12:20:48 <lambdabot>   mueval-core: Time limit exceeded
12:20:53 <shachaf> @check join (==)
12:20:57 <lambdabot>   mueval-core: Time limit exceeded
12:21:20 <bennofs> @let a <-> b = a <> invert b
12:21:21 <lambdabot>  .L.hs:161:16:
12:21:21 <lambdabot>      Not in scope: `invert'
12:21:21 <lambdabot>      Perhaps you meant one of thes...
12:21:28 <bennofs> no groups :(
12:21:40 <tikhon> lambdabot and Unicode do not mix :(
12:22:01 <tikhon> I think that "abc" • "def" looks the best of all the options I've seen
12:22:02 <ReinH> monochrom: also consider:
12:22:20 <ReinH> > getDual $ Dual "foo" <> Dual "bar"
12:22:21 <lambdabot>   "barfoo"
12:23:00 <tomejaguar> What's going on here.  Why are people obsessed with opposite monoids all of a sudden?
12:23:11 <ReinH> tomejaguar: just talking about "ordering" or monadic effects
12:23:19 <ReinH> *of
12:23:24 <shachaf> Opposite categories are the future.
12:23:54 <structuralist> are there any tricks for making programming with impredicative types less painful?
12:24:06 <danharaj> Newtype wrap your impredicative types
12:24:12 <danharaj> don't use impredicative types
12:24:13 <tomejaguar> Opposite categories are also the past.
12:24:19 <clahey> I think of  as being the operator for Field f => [f] -> [f] -> f     inner product.
12:24:49 <structuralist> are there any tricks for making programming with newtypes less painful?
12:25:02 <merijn> structuralist: What is it you find painful about them?
12:25:04 <tikhon> there's the newtype package
12:25:14 <tikhon> http://hackage.haskell.org/package/newtype
12:25:23 <DMcGill> constantly patternmatching on the constructor is a little annoying
12:25:23 <shachaf> Please do not confuse • with ∙.
12:25:26 <structuralist> merijn: what would otherwise be very concise code is littered with Wrap/unWrap
12:25:30 <shachaf> > map generalCategory "•∙"
12:25:32 <lambdabot>   [OtherPunctuation,MathSymbol]
12:25:42 <clahey> Oi geese.
12:25:44 <clahey> jeese
12:25:46 <clahey> jeeze
12:25:56 <bennofs> > generalCategory '·'
12:25:57 <lambdabot>   OtherPunctuation
12:26:11 <DMcGill> ok, newtype looks really cool
12:26:31 <shachaf> I propose this operator for mappend: 2062   INVISIBLE TIMES     [<U+2062>]
12:26:41 <tikhon> if only that actually worked :P
12:26:47 <tikhon> I've already tried it though
12:26:58 <ReinH> I'm also starting to enjoy & and <&>
12:27:04 <Peaker> chrisdone, still here? only now saw your question (was afk)
12:27:06 <monochrom> use the package "newtype" or the package "lens"
12:27:17 <ReinH> > [True, False, True] <&> All & getAll.mconcat
12:27:18 <lambdabot>   False
12:27:19 <tikhon> I would also like x² to work—one of these days...
12:27:35 <merijn> danharaj: w.r.t the "don't use impredicative types" what if I want things like "Chan (forall a . Foo a)"? That seems perfectly fine to me, but there's no way to do things like that without cumbersome wrapping atm
12:27:36 <Peaker> chrisdone, I had encountered broken hackage packages a couple of times, due to open import collisions,  one of those times was extremely painful
12:27:47 <shachaf> > ala All foldMap [True, False, True]
12:27:49 <lambdabot>   False
12:27:53 <Peaker> (not to mention the difficulty of reading code and having no idea where names come from)
12:27:55 <danharaj> merijn: wrap it in a newtype.
12:27:57 <ReinH> :t ala
12:28:04 <shachaf> @let àla = ala
12:28:05 <lambdabot>  .L.hs:158:1: Not in scope: data constructor `�'
12:28:11 <ReinH> ...
12:28:11 <shachaf> Hmph.
12:28:18 <tikhon> lambdabot and Unicode....
12:28:20 <danharaj> merijn: because the wrapping is nowhere near as bad as the type inference for impredicative types.
12:28:26 <ReinH> @info ala
12:28:26 <lambdabot> ala
12:28:30 <tikhon> the blight of my existence
12:28:31 <ReinH> thanks lambdabot
12:28:34 <tikhon> @ty ala
12:28:44 <ReinH> shachaf: where is it from?
12:28:51 <tikhon> lens type signatures must have fried lambdabot's mind
12:28:56 <shachaf> ReinH: 12:26 <monochrom> use the package "newtype" or the package "lens"
12:28:59 <ReinH> sorry
12:29:19 <shachaf> tikhon: Yep. It's a strange bug with line lengths/foralls/indentation/something else.
12:29:38 <ReinH> ala is nice! thanks
12:29:38 <tikhon> the type signatures are just too glorious for mortal eyes
12:29:38 <structuralist> is lens strictly more powerful than newtype? embarrassingly haven't gotten around to learning it
12:29:40 <shachaf> I think we figured it out once before, but then lambdabot changed hands.
12:29:58 <shachaf> structuralist: More or less.
12:30:03 <danharaj> :t ala
12:30:14 <danharaj> :t Control.Lens.ala
12:30:15 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
12:30:22 <danharaj> what am I looking at here
12:30:25 <tikhon> ssaa
12:30:29 <ReinH> :t ala Sum
12:30:30 <lambdabot> ((s -> Sum s) -> e -> Sum s) -> e -> s
12:30:59 <DMcGill> danharaj: newtype's page has a bunch of motivating examples
12:31:08 <DMcGill> mostly > ala Sum foldMap [1,2,3]
12:31:14 <DMcGill> > ala Sum foldMap [1,2,3]
12:31:15 <lambdabot>   6
12:31:19 <DMcGill> > ala Product foldMap [1,2,3]
12:31:21 <lambdabot>   6
12:31:21 <ReinH> DMcGill: where is newtype's page?
12:31:33 <DMcGill> http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html
12:31:35 <Peaker> selecting an instance via selection of a newtype wrapper
12:31:36 <ReinH> ty
12:31:58 <DMcGill> the implementation isn't complicated but is nice and revealing
12:32:06 <DMcGill> so I'd recommend looking at the source like I just did
12:32:07 <danharaj> ok I get it now
12:32:08 <danharaj> cute
12:32:12 <monochrom> [1,2,3] is an unlucky example :)
12:32:16 <DMcGill> aha
12:32:35 <shachaf> :t au
12:32:35 <lambdabot> AnIso s t a b -> ((s -> a) -> e -> b) -> e -> t
12:32:57 <DMcGill> hidden messages from edwardk there
12:32:58 <monochrom> also, ala Sum foldMap [2,2] = ala Product foldMap [2,2] = ala Exponentiation foldMap [2,2] :)
12:33:08 <shachaf> > au (iso Sum getSum) foldMap [1,2,3]
12:33:09 <lambdabot>   6
12:33:18 <shachaf> That takes the isomorphism as an argument.
12:33:28 <DMcGill> is Sum not an iso by default?
12:33:37 <danharaj> are all french prepositions going to be combinators
12:33:38 <shachaf> What do you mean by "is"?
12:33:40 <ReinH> clever
12:33:44 <DMcGill> an instance of Iso
12:33:45 <shachaf> danharaj: Hey, "au" is German!
12:33:50 <shachaf> Iso isn't a class.
12:33:50 <danharaj> yeah whatever
12:34:06 <DMcGill> this is so cool though, I'm definitely going to be using this stuff
12:34:07 <tikhon> it's also French though
12:34:14 <ReinH> danharaj: well, it matters that there is no class for it to be an instance of...
12:34:14 * danharaj wants agda mixfix ne_pas ne_que etc.
12:34:27 <monochrom> "learn you a european language from lens"
12:34:32 <ReinH> lmao
12:34:41 <shachaf> > au (iso (\n -> replicate n ()) length) foldMap [1,2,3]
12:34:42 <lambdabot>   6
12:34:52 <structuralist> I guess it restores some justice for Europeans programming
12:35:17 <shachaf> monochrom: What package can I learn Chinese from?
12:35:34 <monochrom> that package hasn't been written yet
12:35:37 <DMcGill> is there a good blog post about all the million things lens can do though? I don't understand how I was supposed to find out about this other than 1) being here while it happened to be discussed and 2) visiting every single of lens' page on hackage
12:35:49 <monochrom> but I did dream about Prelude.Chinese :)
12:35:51 <danharaj> there is a video
12:35:51 <phulin> I have a data structure that's effectively a Map Text Something
12:35:57 <phulin> What's the best way to make that more efficient
12:36:07 <danharaj> also there's like 3 people who know *everything* lens can do
12:36:08 <tikhon> also some nice blog posts, like one by Tekmo
12:36:13 <monochrom> that depends on why you don't find it efficient enough now
12:36:21 <monochrom> "the solution depends on the problem"
12:36:41 <yepyep> :t au
12:36:43 <lambdabot> AnIso s t a b -> ((s -> a) -> e -> b) -> e -> t
12:36:45 <DMcGill> phulin: have a look at Tries! They're really good for looking up things on prefixes
12:36:50 <Peaker> looking at the "Iso" type synonym, I don't quite understand why it represents an Iso and not a lens, when the only difference is the Profunctor constraint there?
12:36:55 <monochrom> but other people disagree. they will jump in with all kinds of speculative solutions
12:37:06 <DMcGill> ouch
12:37:13 <DMcGill> (point taken)
12:37:19 <Peaker> type Iso s t a b = (Profunctor p, Functor f) => p a (f b) -> p s (f t)
12:37:21 <shachaf> > au (wrapping Sum) foldMap [1,2,3]
12:37:23 <lambdabot>   6
12:37:28 <Peaker> type Lens s t a b = Functor f => (a -> f b) -> s -> f t
12:37:32 <yepyep> I see you guys (and gals?) speaking about lenses.  I haven't been able to wrap my head around them.  Again, any recommended reading on the subject?
12:37:42 <shachaf> Peaker: Well, it's easier to see when you forget about the f.
12:37:44 <bennofs> monochrom: Exponentiation is not a monoid, as 2 ^ (3 ^ 4) /= (2 ^ 3) ^ 4, or do you mean something else?
12:37:53 <shachaf> Peaker: type Iso s t a b = forall p. Profunctor p => p a b -> p s t
12:37:58 <tikhon> there's a nice talk about lenses from the NYC Haskell meetup that you can watch online
12:38:03 <monochrom> yikes. I just want to say 2+2 = 2*2 = 2^2
12:38:29 <shachaf> Remember the definition: class Profunctor p where dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
12:38:45 <shachaf> (A functor in both arguments, contravariant in the first.)
12:38:46 <monochrom> I now exploit the fact that the computer doesn't check the associative law :)
12:38:58 <bennofs> :)
12:38:58 <Peaker> shachaf, what instances of Profunctor are used to "reverse" the relationship?
12:39:09 <shachaf> "reverse"?
12:39:23 <shachaf> So if I give you "p a b" and you have to give me a "p s t", how can you do it?
12:39:39 <shachaf> Essentially you have to have a function :: s -> a and a function :: b -> t. There's no other way you can do it.
12:39:45 <phulin> monochrom, I'm trying to diagnose it now
12:39:54 <shachaf> (You can map multiple times but the functor laws tell us that's the same as mapping just once.)
12:40:04 <phulin> I'm jsut seeing that my profiling is spending 10% of time in Text comparison
12:40:16 <Peaker> shachaf, ah, thanks
12:40:21 <shachaf> Peaker: If you have foo :: forall p. Profunctor p => p a b -> p s t, you can pick profunctors to extract (s -> a) or (b -> t)
12:40:49 <shachaf> Namely: Use "Foo x y = y" to extract b -> t, and "Foo x y = x -> r" to extract s -> a
12:42:30 <Peaker> shachaf, I initially thought the Profunctor stuff was just an Indexing thing
12:42:52 <dmwit> By induction, all superoperators s have s 2 2 = 4
12:42:55 <shachaf> Nah, it's much more general.
12:43:05 <monochrom> nice, dmwit
12:43:18 <Peaker> shachaf, It's now classified in my brain as "an Indexing and Isomorphism thing" :-)
12:43:39 <shachaf> Peaker: Also prisms, reviews, equalitys, ...
12:43:54 <monochrom> perhaps this is why the idiom says "put 2 and 2 together" instead of some other numbers. it doesn't matter what is "put together", same answer :)
12:44:03 <dmwit> hehehe
12:44:10 <DMcGill> let's add const, id to that example!
12:44:19 <shachaf> Peaker: Another approach is that instead of (a -> f b) -> (s -> f t), you make (g a -> f b) -> (g s -> f t)
12:44:53 <elliott> telling people about symmetric lenses in 2013. :(
12:45:19 <Peaker> shachaf, Profunctor seems like a weird point in "generalization space".  It's not quite a generalized Category (can apply (->) functions on left/right), and it's not quite specific. I don't have a nice grasp on its utility..
12:45:56 <dmwit> You know how Arrow is supposed to generalize (->)?
12:45:58 <dmwit> So is Profunctor.
12:46:03 <merijn> Peaker: Good! I was starting to worry I was dumb
12:46:17 <shachaf> Then you can pick f,g appropriately, rather than just picking g.
12:46:26 <elliott> Arrow should be based on Profunctor.
12:46:27 <dmwit> elliott: Why is that sad? Also, what do you mean by symmetric lenses?
12:46:30 <Peaker> dmwit, Well, Arrow sucks because "arr" makes it a much less useful generalization (and it becomes useful only where Applicative would work as well)
12:46:39 <elliott> dmwit: symmetric lense are (g a -> f b) -> (g s -> f t).
12:46:43 <elliott> they're kind of awful.
12:46:47 <elliott> it's a long story.
12:47:04 <monochrom> elliott: what would Arrow look like when based on Profunctor?
12:47:05 <Peaker> shachaf, one day I should toy around with that to get a deeper understanding
12:47:09 <tomejaguar> Peaker: there are cases where Arrow works where Applicative is not enough
12:47:21 <Peaker> tomejaguar, s/Applicative/Applicative+Category
12:47:24 <elliott> monochrom: class (Profunctor a, Category a) => Arrow a where first :: ...
12:47:41 <monochrom> hrm!
12:47:43 <dmwit> What warrants the name "symmetric"?
12:47:48 <elliott> though you can do richer things like that.
12:47:52 <elliott> *than that
12:47:55 <shachaf> dmwit: You have a functor on both sides.
12:48:00 <elliott> dmwit: we started with (a -> f b) -> (s -> f t).
12:48:06 <tomejaguar> Peaker: That could well be.  I guess you'd need an applicative instance for 'myArrow a' for each a
12:48:09 <elliott> then we discovered making it more symmetric by adding the gs let you do more things.
12:48:14 <elliott> unfortunately we didn't realise it was horrific for a while.
12:48:19 <Peaker> tomejaguar, (Category,Applicative) <=> Arrow  (can define one in terms of the other, with a bit of funny constraints)
12:48:28 <Peaker> tomejaguar, yeah, those are the funny constraints
12:48:33 <shachaf> Hey, symmetric lenses were great!
12:48:42 <edwardk> *cringe*
12:48:44 <elliott> shachaf: tell me all about your cloneIso
12:48:44 <Peaker> elliott, horrific in what way?
12:48:57 <elliott> Peaker: e.g. no way to write cloneIso/clonePrism without partiality
12:49:01 <elliott> (safe partiality)
12:49:18 <Peaker> lens has plenty of (safe) partiality even now, doesn't it?
12:49:19 <elliott> usually only one of f or g "matters" and you get a lot of Identity cluttering things up etc.
12:49:27 <elliott> from a practicality POV you lose traverse compatibility
12:49:31 <shachaf> elliott: Rank-2. hth
12:49:39 <elliott> rank 2 cloneIso, so useful
12:50:06 <shachaf> Peaker: Does it?
12:50:17 <shachaf> Not in the core types/functions, I don't think.
12:50:23 <WraithM> @quote
12:50:23 <lambdabot> arkeet says: <arkeet> do {time <- getCurrentTime; do stuff with (show time :: String)} <arkeet> it's show time.
12:50:41 <Peaker> shachaf, 119 unsafeCoerces? :)
12:50:53 <edwardk> we have a rank-2 version using flip
12:50:58 <edwardk> it goes through Pretext
12:51:06 <shachaf> Peaker: None of them are partial.
12:51:12 <arkeet> that's a pretty terrible quote.
12:51:17 <ReinH> edwardk: today I learned about ala. Today was a good day.
12:51:22 <arkeet> @quote
12:51:22 <lambdabot> koeien says: Let's register it [monomorphismrestriction.com] to prevent it from being used ;)
12:52:28 <edwardk> =)
12:52:32 <edwardk> there is also 'au'
12:52:37 <shachaf> elliott: Rememebr when you tried to convince everyone to switch lens to symmetric lenses?
12:52:39 <edwardk> :t au
12:52:39 <Peaker> shachaf, ah, ok, glad to hear there's not much partiality in there
12:52:40 <lambdabot> AnIso s t a b -> ((s -> a) -> e -> b) -> e -> t
12:52:55 <shachaf> Peaker: I got rid of some of the bigger offenders recently.
12:52:56 <edwardk> :t ala
12:53:27 <edwardk> au is a version of ala that just takes an Iso as the argument rather than the function that it'll look up some iso using Wrapped with
12:53:38 * dmwit looks at class Reversing with suspicion
12:53:44 <shachaf> Peaker: I think almost all of them are a small optimization of (Foo . f) where Foo is a newtype constructor.
12:53:52 <edwardk> dmwit: its a convenience class, not a principled one
12:53:53 <NemesisD> wow https://twitter.com/BrettBukowski/status/368223344509743104
12:53:59 <ReinH> edwardk: right, au works with isos
12:54:10 <edwardk> i try to divide lens into 'the core theoretically necessary stuff' and 'crap that works like classy prelude to make it suck less'
12:54:23 <edwardk> reversing is in the second set
12:54:25 <shachaf> Oh, runPrism also has unsafeCoerce.
12:54:28 <dmwit> I was about to point at all the complaints about classy-prelude. =P
12:54:35 <shachaf> elliott: What was that you were saying about cloneIso again?
12:54:35 <edwardk> yes
12:54:42 <dmwit> Including some by you, I think. =P
12:54:45 <danharaj> will lens use any unsafeCoerces with the new GHC newtype machinery that's coming up?
12:55:02 <bryanvick> \quit
12:55:03 <shachaf> danharaj: That depends on whether I get around to answering SPJ's question about it.
12:55:04 <elliott> shachaf: the unsafeCoerces in runPrism are optional
12:55:07 <elliott> unless edwardk removed the optionality
12:55:08 <shachaf> It's only been seven months!
12:55:10 <elliott> they're just newtype optimisation
12:55:11 <edwardk> danharaj: the newtype machinery doesn't _yet_ give us everything we need to get rid of our coerces
12:55:18 <shachaf> elliott: Yes, I know.
12:55:24 <elliott> shachaf: did you read the blog post about rules?
12:55:28 <elliott> those look kind of relevant and stuff.
12:55:30 <elliott> *roles
12:55:39 <edwardk> i've been working with richard eisenberg on how to add some stuff to Functor using the new machinery that may let us avoid it though
12:55:40 <shachaf> edwardk: Look at his patch in http://ghc.haskell.org/trac/ghc/ticket/7542
12:55:49 <danharaj> edwardk: that's cool. Richard is an awesome dude.
12:55:56 <shachaf> edwardk: I think that might end up being enough with inlining?
12:56:31 <edwardk> newtype wrappers doesn't solve the issue directly as we don't know the Functor involved. so we need a method in Functor
12:56:36 <shachaf> Because it makes it so that strict composition actually optimizes.
12:56:43 <kosmikus> edwardk: I'm currently planning to talk about your lens library at the Haskell eXchange in London (in October). (Unless you want to discourage me, then I can still pick another topic.)
12:56:48 <Peaker> shachaf, why can't GHC optimize newtype constructor wrapping/unwrapping away?
12:56:51 <shachaf> edwardk: No, not newtype wrappers. The strict composition thing.
12:56:55 <edwardk> once we have something like fmapNewtype :: NT a b => (a -> b) -> f a -> f b
12:57:02 <edwardk> kosmikus: SPJ is also planning one for the same venue
12:57:11 <kosmikus> edwardk: hrm
12:57:15 <danharaj> oooh
12:57:16 <shachaf> Peaker: Well, it can't with (Foo . x) because what if x is undefined?
12:57:17 <elliott> edwardk: why do you need the (a -> b) there?
12:57:19 <danharaj> spj is going to talk about lenses?????
12:57:22 <danharaj> I am so jealous.
12:57:29 <kosmikus> I've already told him I'm going to do this ...
12:57:30 <shachaf> Peaker: ( (\x -> f x) is distinct from f when f is ⊥.)
12:57:42 <edwardk> kosmikus: well, at least he mentioned he was planning on talking about the way lenses work with the new record machinery.
12:57:53 <Peaker> shachaf, because we can `seq` functions :-(
12:57:57 <kosmikus> edwardk: I'm going to check with him
12:58:03 <edwardk> "So I’m thinking of giving a talk about some beautiful library instead, and lenses are the most obvious candidate."
12:58:16 <edwardk> so i'd talk to him to make sure you don't tromple one another
12:58:33 <shachaf> Peaker: Right. *However*, with strict composition -- \ !f !g -> \x -> f (g x) -- I think it ought to be possible.
12:58:38 <danharaj> spj called lens beautiful?
12:58:42 <danharaj> can't get much higher praise than that :P
12:58:52 <edwardk> i'm more than happy to have folks talk about lens. i'm also more than happy to contribute code, examples, slides, anything i can to help.
12:58:55 <shachaf> Peaker: And indeed that's the thing SPJ's optimization did.
12:59:00 <Peaker> shachaf, or maybe languages with more totality
12:59:06 <shachaf> Well, yes.
12:59:31 <ReinH> edwardk: did you get a chance to make any more process with SoH and the automata?
12:59:40 <ReinH> (which is also a good band name if anyone is looking)
12:59:48 <ReinH> *progress
12:59:49 <edwardk> kosmikus: i already sent him a copy of my slides from LambdaJam. i can forward you a copy as well.
13:00:07 <edwardk> ReinH: i got to where it compiles, but then never shows anything
13:00:11 <ReinH> hah awesome
13:00:13 <edwardk> i need to spend some time on the yesod side of things
13:00:15 <tikhon> oh hey, how was lambdajam?
13:00:23 <edwardk> as i'm probably just doing something dumb
13:00:49 <edwardk> i'll probably hop on ##yesod or whatever and beg for help until it works. ;)
13:00:53 <kosmikus> edwardk: there seem to be too few topics :) SPJ was sending a mail my way a while ago planning to give a talk on generic programming, but Neil Mitchell is already talking about Uniplate.
13:01:19 <kosmikus> edwardk: back in that discussion, I said "at least I won't talk about GP (directly), because I'm planning to do lenses"
13:01:25 <kosmikus> edwardk: but perhaps he overheard that
13:01:31 <shachaf> You should talk about how lens replaces Uniplate!
13:01:40 <shachaf> Is "overheard" like "overlooked" except for hearing?
13:01:43 <kosmikus> edwardk: anyway, if SPJ is planning to do lenses, I'll stand back
13:01:49 <kosmikus> sorry
13:01:53 <kosmikus> overlooked is better
13:02:05 <shachaf> No, I like that meaning. :-)
13:02:28 <edwardk> tikhon: It was actually a wonderful conference. It had a very different tone than I expected. A few years ago when I went to this sort of thing, it was all about how we could compete with imperative programming and reach parity. Now, the tone has shifted to "since we've already won, what can we do to make ourselves better" It is somewhat hard to articulate how reassuring that is. ;)
13:02:29 <kosmikus> shachaf: I think that in a single talk on lenses, you can hardly explain how it assimilates everything. a talk about something like uniplate is still very helpful. lots of people don't know these things.
13:03:04 <edwardk> kosmikus: to be honest i think there is more than enough room for SPJ to talk a bit about lenses and how they fit with the record accessor work Gundry is doing and a more detailed 'lens the library' talk
13:03:05 <tikhon> hmm, I'll really have to consider going next time
13:03:24 <kosmikus> edwardk: if SPJ is mainly planning to talk about records, then yes
13:03:29 <shachaf> kosmikus: Sure.
13:03:44 <edwardk> kosmikus: i don't think he's grokked the full depth of where lenses can go from there yet.
13:03:57 <kosmikus> edwardk: I'm not sure I have ;)
13:03:59 <edwardk> kosmikus: he's just gotten to where they seem to be able to solve this big record problem he's had for a long time.
13:04:08 <edwardk> and so he's happy to hang on and come along for the ride
13:04:12 <shachaf> How about I go to Haskell eXchange to talk about lens?
13:04:14 <Adeon> to infinity and beyond
13:04:19 <shachaf> That'll resolve the problem.
13:04:25 <edwardk> Heh, or me =)
13:04:28 <kosmikus> shachaf: hah :)
13:04:37 <edwardk> Though my October is looking pretty booked and the lineup seems named.
13:04:47 <kosmikus> Skills Matter would like to do a NYC Haskell eXchange in 2014
13:04:59 <edwardk> I'd be willing to do a lens talk for the NYC version
13:05:06 <kosmikus> I'm happy to recommend you to give a talk there
13:05:07 <edwardk> its only a few hours out of my way
13:05:18 <kosmikus> let's discuss it at ICFP
13:05:20 <edwardk> sure
13:05:44 <edwardk> heck, by then i should have a few new toys, too.
13:05:56 <companion_cube> telescopes?
13:05:59 * shachaf will most likely not be at ICFP. :-(
13:06:15 <shachaf> mgsloan was trying to talk me into a sort of lens talk tomorrow at SEAHUG.
13:06:21 <edwardk> e.g this matrix multiplication trick, the database/analytics stuff that derives from it, semi-indexing, succinct structures, etc.
13:06:44 <edwardk> so i find it funny that there seems to be a dearth of topics ;)
13:06:50 <companion_cube> edwardk: are you planning to do datalog using big matrix multiplications?
13:07:04 <tomejaguar> Who discovered you could replace the Functor constraint by an Applicative constraint and get traversals?
13:07:08 <edwardk> companion_cube: not quite
13:07:43 <kosmikus> edwardk: I wasn't serious. but there seem to be a few topics that are particularly fashionable.
13:07:43 <edwardk> tomejaguar: roconnor made the connection first. He called them 'multilenses'
13:07:44 <shachaf> tomejaguar: To me it seems like it'd be the other way around.
13:08:16 <shiona> a wild highlight suddenly appears
13:08:16 <shachaf> Traversals already existed in the form of traverse. That you can replace Applicative with Functor to get a 1-traversal isn't quite obvious.
13:08:23 <edwardk> shiona: Now we just have to talk about what is fashionable in here all the time.
13:08:39 <shiona> I guess so
13:10:09 <edwardk> in any event twanvl found the form first, roconnor found the connection to 'traverse', then he generalized it, shachaf, elliott and i came up with all the profunctor stuff that lets it all do indexing and isomorphisms. i came up with a hack, then rwbarton came up with the first principled set of laws for prisms, which combined with the profunctor stuff to give the first principled version of them
13:10:34 <edwardk> then i just kept writing it down and generalizing all the things
13:11:05 <Peaker> edwardk, I think a nice POV is as a generalization of conal's SECs
13:11:28 <Peaker> (Allow SECs to work in some arbitrary functor/applicative, and you get all these interesting new capabilities)
13:11:33 <shachaf> Peaker: Note that the p a b -> p s t thing is a direct generalization of that.
13:11:48 <edwardk> Peaker: yeah i had the SEC = Setter insight right before the talk in San Francisco, so i reworked my whole talk that day because I knew Conal would be in the audience.
13:11:49 <shachaf> When p = (->) it's just an SEC.
13:12:09 <shachaf> But when you give p more or less power you get different things.
13:12:11 <edwardk> that helped firm up the pure profunctor encoding of lenses as well
13:12:41 <edwardk> in a new language, starting from scratch without Traversable and the attendant baggage of the culture, I would have gone with a pure profunctor encoding of lenses.
13:12:57 <edwardk> but for Haskell I'm very happy with the current encoding, compromises and all.
13:13:08 <shachaf> Yep.
13:13:34 <tomejaguar> Why does pure profunctor make it better?
13:13:49 <edwardk> If we can get fundeps into ermine, maybe i'll do pure profunctor lenses all the way
13:13:52 <structuralist> is there somewhere I can read about lenses from the pure profunctor pov?
13:14:06 <shachaf> Not really.
13:14:13 <edwardk> tomejaguar: prisms can be then turned around with the same combinator as turns around an isomorphism giving an 'unprism' that can be turned around again to get a prism.
13:14:26 <shachaf> Well, there are a bunch of files that work it out floating around on my website.
13:14:36 <edwardk> right now we can only turn them around 'part way' with 're' a different combinator than 'from', and they can't finish turning all the way back into a prism.
13:14:39 <shachaf> But eh. Those are mostly outdated.
13:14:47 <edwardk> structuralist: #haskell-lens mostly
13:15:07 <structuralist> shachaf: http://shachaf.wix.com/shachaf2 ? :P
13:15:14 <structuralist> what's the website?
13:15:25 <shachaf> Not exactly.
13:15:47 <shachaf> I'm not even sure if they're up there anymore.
13:15:50 <edwardk> http://slbkbs.org/k.hs and a few similar links
13:15:53 <edwardk> at least that one is
13:16:03 <shachaf> Ah, right.
13:16:14 <shachaf> A lot of that file is nonsense, though.
13:16:21 <edwardk> the pure profunctor examples are what drove the _Foo convention we use now
13:16:21 <salimabu> check out my youtube channel and videos http://www.youtube.com/channel/UCLbLv8Aozc1OX-va_BmkebQ
13:16:42 <shachaf> It still uses prismy :: p a b -> p (Either b a) b -- we found a much nicer formulation later.
13:16:47 <edwardk> and they helped us realize we can get by with Functor + Contravariant constraints to make Getter, etc.
13:16:55 --- mode: ChanServ set +o shachaf
13:16:59 --- mode: shachaf set +b *!*kjhkj@*.dsl.bell.ca
13:17:00 --- kick: salimabu was kicked by shachaf (salimabu)
13:17:02 <edwardk> speaking of which, I want to remove Mutator and Accessor in lens 3.10
13:17:04 --- mode: shachaf set -o shachaf
13:17:11 <shachaf> Really?
13:17:17 <shachaf> Backt to Const and Identity?
13:17:17 <edwardk> We used to use them because they gave non-crappy error messages during unification
13:17:28 <edwardk> but we got rid of 'Gettable'
13:17:32 <edwardk> so meh
13:17:35 <shachaf> Hmm...
13:17:53 <edwardk> right now they just ensure you have a harder time consuming lens-style lenses
13:18:12 <edwardk> or rather with duplicating the types of our combinators
13:18:25 <shachaf> I guess that's true.
13:18:34 <Narvius> Question: If I have a pattern in a where-binding, one that would fail under bad conditions... due to Haskell's laziness, it will only fail once I attempt to use one of the values from binding, right?
13:18:56 <shachaf> Narvius: Yes.
13:18:57 <Narvius> Which means that if I only use them within a place in the code where I know those bad conditions don't occur, no error happens, right?
13:19:00 <edwardk> Narvius: yes
13:19:11 <shachaf> Well, due to "Haskell's laziness" and also the way let/where work. It'd be different with case.
13:19:33 <Narvius> Got a link where I can read up on the difference?
13:19:45 <tomejaguar> You'd also better be sure you don't pass them as arguments that are evaluated strictly
13:20:19 <Narvius> Sure. Thanks, all. :)
13:21:50 <shachaf> The pure profunctor Un type is this, by the way: newtype Un p a b s t = Un { unUn :: p t s -> p b a }
13:22:06 <shachaf> Try giving some instances to that type. It's very strange.
13:24:56 <tomejaguar> It's a b -> t and an s -> a, right?
13:25:08 <shachaf> ?
13:25:13 <shachaf> Depends on p.
13:25:42 <tomejaguar> If you have (forall p. Profunctor p => ...)
13:25:57 <shachaf> Wait, what's "it" here?
13:26:13 <shachaf> (forall p. Profunctor p => p a b -> p s t) ~~ (s -> a, b -> t), yes.
13:26:20 <tomejaguar> Yes
13:26:39 <shachaf> (forall p. Profunctor p => p t s -> p b a) also ~~ (s -> a, b -> t), of course.
13:26:55 <pr> what's the difference between using "import Data.List" and ":m + Data.List" when using ghci? is it basically that with import i get features like qualified imports aswell that may(?) not be possible by using :m?
13:27:08 <shachaf> pr: No difference between those two.
13:27:20 <pr> ok
13:27:21 <shachaf> But the latter lets you qualify and so on, yes.
13:27:25 <pr> cool
13:27:34 <shachaf> Er, the former.
13:28:38 <exicer> I'm having a little trouble understanding how to deal with Data.Map
13:28:53 <exicer> When I lookup a value, I get Maybe something
13:29:06 <exicer> I need to use that something.. how do I deal with this ?
13:29:58 <exicer> I guess I'm always trying to convert back to something that isn't maybe - should I instead convert all my functions to use maybe ?
13:30:14 <DMcGill> the simplest way is to use 'case' in a manner like: case (lookup k v) of \n Just x -> *use x* \n Nothing -> *failed*
13:30:14 <shachaf> That depends on what you're doing.
13:30:22 <shachaf> This isn't unique to Map. Maybe happens everywhere.
13:30:38 <johnw> exicer: usually I case analyze: case lookup "foo" someMap of Nothing -> ...; Just x -> ...
13:30:47 <shachaf> You have to handle the case where the thing you were looking for isn't in the Map. How you handle it is up to you.
13:31:22 <exicer> I think I'm probably just unsure of my options when dealing with failure
13:31:48 <shachaf> Sometimes you want to handle Nothing by returning Nothing yourself. :-)
13:32:08 <shachaf> There are utilities for doing that in various ways.
13:32:09 <tomejaguar> exicer: Can you give a concrete example?
13:32:10 <shachaf> Sometimes you want to do other things.
13:32:18 <johnw> is there a variant of map where lookup must succeed?  where the keyspace must be saturated during creation of the map?
13:33:00 <DMcGill> Not to my knowledge, you can use the partial lookup function which calls error on failure however
13:33:03 <DMcGill> and just promise that it'll never fail
13:33:16 <shachaf> But you shouldn't.
13:33:23 <DMcGill> no, you shouldn't
13:33:25 <shachaf> johnw: There's total-map
13:33:30 <johnw> ah, cool
13:33:31 <shachaf> http://hackage.haskell.org/packages/archive/total-map/0.0.4/doc/html/Data-TotalMap.html
13:34:16 <exicer> The example is that I have an id that corresponds to a list of [Maybe Int], which is found in a Map. I want to sum that list.
13:34:32 <johnw> exicer: sum . catMaybes
13:34:44 <exicer> Yeah, I already had help with that bit :)
13:34:49 <shachaf> johnw: Well, maybe.
13:34:57 <exicer> its more, how do I deal with the maybe from the lookup
13:34:59 <shachaf> Maybe it's fmap sum . sequence
13:35:00 <johnw> true, unless a Nothing is that list represents an error
13:35:27 <exicer> My understanding is that after the lookup, I will have Just [Just 1, ...]
13:36:16 <shachaf> You aren't communicatnig the full situation here.
13:36:19 <DMcGill> how are you getting the list?
13:37:18 <tomejaguar> exicer: what do you want it to do if the key is not in the map?
13:37:36 <exicer> tomejaguar: Nothing :p
13:37:40 <exicer> DMcGill: The list of [Maybe Int] ?
13:37:46 <exicer> It is from parsing a tab delimited file
13:37:47 <tomejaguar> What do you mean nothing?  It's got to do something.
13:38:02 <exicer> tomejaguar: If it were in Python I would pass and log the fact
13:38:03 <tomejaguar> It's got to return an Int
13:38:25 <exicer> It is unexpected that the lookup would ever fail..
13:38:27 <b2coutts> exicer: what do you do with the result of the function?
13:38:30 <DMcGill> I think then you'd want to return Maybe Int to represend the fact that it might fail
13:38:48 <b2coutts> (clearly it must return something in order for whatever you do with it to make sense)
13:38:50 <tomejaguar> exicer: /Can/ it ever fail?
13:39:16 <tomejaguar> For example, are you only looking up keys that you've previously determined to be in the map?
13:39:18 <exicer> tomejaguar: Not really.. it wouldn't ever look for a key that isn't there
13:39:25 <b2coutts> exicer: the typical way to do map lookups is to check if it's Nothing, and if so, throw an error
13:39:41 <cschneid> exicer / b2coutts: fromJust does basically that, right?
13:39:43 <b2coutts> or do whatever failure-ish thing the function should do
13:39:48 <DMcGill> or use the ! function rather than lookup
13:39:54 <DMcGill> which essentially does that for you
13:40:04 <exicer> Huh, didn't know about !
13:40:07 <b2coutts> you can do it with isNothing and fromJust, often a pattern match makes more sense
13:40:48 <b2coutts> oh, interesting, I didn't know about ! either
13:40:54 <tomejaguar> exicer: Then if I were you I'd use "Data.Map.map (sum . catMaybes)".  That will give you a Map of keys to sums.
13:41:08 <tomejaguar> And is typesafe
13:41:13 <exicer> tomejaguar: Cool cool. Cheers
13:41:19 <cschneid> ohh, nice. ! is awesome.
13:41:40 <DMcGill> I must reiterate my warning about ! though
13:41:51 <cschneid> DMcGill: that it throws an error? :)
13:42:00 <cschneid> and you really should handle your Nothing values politely
13:42:00 <DMcGill> it will likely lead to strange crashing in reasonable sized programs
13:42:12 <tomejaguar> This is Haskell, why be all like recommending unsafe functions?
13:42:40 <DMcGill> I mean at least `fromMaybe (error "a more helpful message here")' is a little better
13:42:53 <tikhon> although that can also behave in mysterious ways
13:43:09 <tikhon> thanks to imprecise exceptions and stuff
13:43:33 <tomejaguar> Why even think about it?  Just do the typesafe thing.
13:43:36 <cschneid> is there an easier way to say this: `maybe defaultVal $ lookup key map`
13:43:48 <cschneid> ahh, nevermind
13:43:50 <cschneid> I suck at doc reading
13:43:59 <cschneid> :t Data.Map.findWithDefault
13:43:59 <lambdabot> Ord k => a -> k -> M.Map k a -> a
13:44:53 <johnw> it would have been fromMaybe defaultVal, just fyi
13:44:57 <DMcGill> I'd be careful with that too though, a Maybe might be what you need though
13:45:40 <DMcGill> rather than, say, using findWithDefault 0 and then summing which (I believe) is worse than the catMaybes solution
13:46:02 <cschneid> :t catMaybes
13:46:02 <lambdabot> [Maybe a] -> [a]
13:46:13 <tomejaguar> The catMaybes and the findWithDefault deal with different missing things
13:46:17 <tomejaguar> at least in the OP's case
13:46:17 <cschneid> > catMaybes [Nothing]
13:46:18 <lambdabot>   []
13:46:22 <cschneid> > catMaybes [Nothing, Just 5]
13:46:23 <lambdabot>   [5]
13:46:57 <TallerGhostWalt> does anyone know of a good performance review on arrows?
13:47:07 <DMcGill> tomejaguar: true, `findWithDefault []' could be of use here
13:47:17 <TallerGhostWalt> I love the hxt library and the arrow system there seems good but it seems like they have fallen out of favor
13:48:01 <cschneid> > catMaybes []
13:48:02 <lambdabot>   []
13:48:35 <monochrom> "performance of arrows" is a pseudo-question. hxt performance is parsec performance rather than anything else
13:51:54 <TallerGhostWalt> hmmm, I am trying to decide what it means to have a pseudo-question
13:52:03 <TallerGhostWalt> is it not really a question?
13:52:50 <TallerGhostWalt> There aren't any underlying datastructures that are required to implement arrows that might have performance costs?
13:54:10 <tikhon> TallerGhostWalt: since normal functions form arrows, no
13:54:46 <tikhon> of course you have some datastructures necessary to implement a parser, but those are indpendent of having an arrow interface
13:55:07 <TallerGhostWalt> So it is all compiled away then?  That is very cool
13:55:34 <tikhon> my point is that Arrow is just a (relatively simple) interface which does not give you much information about implementation
13:55:48 <tikhon> how exactly it works in any given case depends on that case and not on being an arrow
13:55:53 <TallerGhostWalt> I really like Netwire and HXT's use of them
13:56:13 <tikhon> fair enough
13:56:22 <tikhon> I personally don't like arrows very much
13:56:44 <tomejaguar> Arrows are pretty cool when you actually need an Arrow
13:56:47 <DMcGill> I found that with Netwire's combinators I rarely needed to go into arrow notation
13:57:08 <TallerGhostWalt> tikhon: why not?
13:57:16 <tikhon> a few reasons
13:57:34 <tikhon> for one, they don't fit nicely into the functor -> applicative -> monad hierarchy
13:57:36 <TallerGhostWalt> DMcGill: yeah I agree with that
13:57:39 <tikhon> also, I don't like arr
13:57:40 <tomejaguar> DMcGill: Interesting.  Can you give an example?
13:57:53 <tikhon> many of the things I want to do with arrows are incompatible with having arr
13:57:59 <tomejaguar> tikhon: Why not arr?  arr is just fmap
13:58:10 <tomejaguar> or rather the equivalent
13:58:21 <tikhon> for things like Netwire, sure
13:58:37 <tikhon> but given arrows generalize functions in a pretty natural way, I wanted to use them for things like reversible computations
13:58:56 <djahandarie> arr = undefined
13:59:08 <TallerGhostWalt> hmm, that is interesting
13:59:30 <tikhon> also, for FRP in particular, I like working directly with time-varying values
13:59:37 <tikhon> instead of indirectly with computations over time-varying values
13:59:41 <DMcGill> -- | Given an initial worldView, make a wire that changes it for keyboard input
13:59:41 <DMcGill> viewToWire :: (Monoid e, Monad m) => WorldView -> Wire e m Input WorldView
13:59:41 <DMcGill> viewToWire view = accumT1 (\t x f -> f t x) view . (arr moveView . keyEvent <|> pure (const id))
13:59:41 <tikhon> it just makes more sense to me
14:00:06 <DMcGill> accumT1 essentially replaced a bunch of arrow notation
14:00:15 <DMcGill> possibly recursive, I wrote this a while ago
14:00:47 <tomejaguar> tikhon: so I guess you were looking for a Category with products?
14:00:49 <DMcGill> where moveView did a case on the event and returned a function that transformed the view
14:00:54 <tikhon> basically, yes
14:01:12 <tikhon> I guess that would be a monoidal category or something
14:01:48 <tomejaguar> tikhon: why not just a category with products?
14:02:13 <tomejaguar> DMcGill: So the idea is to use the Applicative and Alternative instances to make life easier?
14:02:24 <DMcGill> yep, as much as possible
14:02:25 <tomejaguar> I wonder if I can do that with my code.  I haven't tried much.
14:02:31 <tikhon> tomejaguar: isn't that basically what a monoidal category is? (except with an identity, I guess)
14:02:55 <tomejaguar> I just googled "haskell alternative".  I better erase that from my history.  Don't want anyone getting the wrong idea.
14:03:03 <tikhon> heh
14:03:05 <TallerGhostWalt> hehe
14:03:22 <DMcGill> tomejaguar - Functor too:
14:03:23 <DMcGill> -- | Given an initial object, turn it into a Wire that holds its state
14:03:23 <DMcGill> objectToWire :: Monad m => Object -> Wire e m Input Object
14:03:23 <DMcGill> objectToWire (Object basic forces rigid) =
14:03:23 <DMcGill>   Object basic forces <$> rigidObject rigid . arr forces
14:03:40 <tomejaguar> tikhon: A category with products is a special case of a monoidal category.
14:03:46 <Narvius> haasn: I know why I thought the break thing didn't work if there was only one word - I wasn't stripping \r off the end.
14:03:48 <DMcGill> where `rigid' is an object that holds the actual physical state
14:03:49 <TallerGhostWalt> Those sound like sensible reasons, the hxt library is really just good and probably would be w/o arrows
14:04:07 <TallerGhostWalt> the deep filters and such though are very intuitive to use
14:04:23 <TallerGhostWalt> makes me wish that it were written more generically for parsec
14:05:25 <tikhon> tomejaguar: oh yeah, I guess so. The terminology is a bit confusing: the monoidal category's operation (⊗) also seems to be called a product.
14:06:40 <shachaf> That's often called a "tensor product".
14:06:56 <tomejaguar> tikhon: I guess you would call it a tensor product or monoidal product.  Which is confusing because it's not a product.  It's a red herring: http://ncatlab.org/nlab/show/red+herring+principle
14:08:17 <exicer> If I have a list of [Maybe a], is there a function to filter Nothings and then give [a], or do I have to write one myself ?
14:08:18 <jfischoff> sometimes its a product, sometimes its a coproduct
14:08:26 <arkeet> @hoogle [Maybe a] -> [a]
14:08:27 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
14:08:27 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
14:08:27 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:09:19 <arkeet> exicer: hoogle is your friend.
14:09:20 <exicer> arkeet: I think they all give Nothing if there are any Nothings
14:09:24 <exicer> or, no
14:09:27 <arkeet> catMaybes is the thing you want. =)
14:09:30 <exicer> some give an emty list
14:09:45 <tikhon> heh, I really love the introduction to that article
14:09:45 <exicer> arkeet: Doh, yeah you are right :p
14:09:46 <haasn> Narvius: I see
14:09:47 <jfischoff> > catMaybes [Nothing, Just 'c']
14:09:48 <lambdabot>   "c"
14:09:57 <haasn> > words "a\rb"
14:09:58 <lambdabot>   ["a","b"]
14:10:08 <dymatic> exicer: I believe (filter (\c -> case c of (Just c) -> True; (Nothing) -> False) list) would work. Haven't used maybe much, though.
14:10:12 <arkeet> :t (>>= maybeToList)
14:10:12 <lambdabot> [Maybe b] -> [b]
14:10:15 <Narvius> > words "a\r"
14:10:16 <lambdabot>   ["a"]
14:10:26 <shachaf> tomejaguar: How is it not a product?
14:10:32 <arkeet> dymatic: that wouldn't. you'd end up with a list of Justs
14:10:53 <startling> is there not a way to tell cabal "this executable depends on this library and all its dependencies"?
14:11:03 <dymatic> Oh. I thought that's what he wanted.
14:11:06 <shachaf> It's not a *categorical* product, but the word "product" in general is pretty vague.
14:11:27 <tomejaguar> Fair enough.
14:11:37 <shachaf> Is there a category where products and coproducts are the same thing?
14:11:50 <tomejaguar> The unit category?
14:11:54 <arkeet> shachaf: those are called biproducts.
14:11:58 <shachaf> A nontrivial one.
14:11:59 <arkeet> at least, in the finite case.
14:12:03 <arkeet> example: any abelian category
14:12:16 <shachaf> arkeet: Oh, OK then.
14:12:16 <startling> does everyone duplicate the library/build-depends in the executable whatever/build-depends? that seems crazy.
14:12:22 <shachaf> arkeet: That's another counterexample to yesterday's thing.
14:12:26 <arkeet> it is?
14:12:33 <shachaf> Since the biproduct functor is left and right adjoint to the diagonal functor.
14:12:47 <arkeet> right.
14:13:09 <shachaf> Though, really, a zero object is just an empty biproduct.
14:13:18 <arkeet> sure
14:13:22 <shachaf> So that's still asimpler.
14:13:27 <shachaf> s/ a/ /
14:13:29 <jfischoff> startling: have the executable depend on the library you are building
14:13:39 <startling> jfischoff: it does.
14:13:48 <jfischoff> oh well
14:14:25 <arkeet> what I mean is
14:14:33 <arkeet> abelian categories (by definition) have finite biproducts.
14:24:33 <S_J> @type concat
14:24:34 <lambdabot> [[a]] -> [a]
14:24:53 <S_J> > concat ["h","a"]
14:24:54 <lambdabot>   "ha"
14:31:40 <cschneid> concat has to walk the first list to then cons on the second list, right?
14:32:03 <S_J> @src concat
14:32:04 <lambdabot> concat = foldr (++) []
14:32:05 <DMcGill> cschneid: that's (++)
14:32:13 <Cale> @src (++)
14:32:13 <lambdabot> []     ++ ys = ys
14:32:13 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:32:13 <lambdabot> -- OR
14:32:13 <lambdabot> xs ++ ys = foldr (:) ys xs
14:32:18 <S_J> @src foldr
14:32:19 <lambdabot> foldr f z []     = z
14:32:19 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:32:28 <DMcGill> but looking at the implementation, then concat will walk all the lists but the last one
14:32:33 <monochrom> I am not sure what you want from that question and how I should answer
14:33:02 <DMcGill> in fact no, it'll walk all of them
14:33:02 <monochrom> it also sounds like assuming a wrong operational model
14:33:18 <DMcGill> since concat [x,y,z] ==> x ++ y ++ z ++ []
14:33:31 <monochrom> how about this: take 1 (concat joy)  is O(1)
14:34:15 <cschneid> monochrom: yeah, reasoning about laziness is certainly something to get used to.
14:35:49 <Cale> concat [[x,y],[z]] -> foldr (++) [] [[x,y],[z]] -> [x,y] ++ foldr (++) [] [[z]] -> x : ([y] ++ foldr (++) [] [[z]]) -> x : (y : ([] ++ foldr (++) [] [[z]])) -> x : (y : foldr (++) [] [[z]]) -> x : (y : ([z] ++ foldr (++) [] [])) -> x : (y : (z : ([] ++ foldr (++) [] []))) -> x : (y : (z : (foldr (++) [] []))) -> x : (y : (z : []))
14:36:08 <WraithM> Say I want a state monad with a condition (fit into a typeclass) on the kind of states that this thing can have. Is there a good way to do this? Something like this: newtype TestState a = TestState { runState :: Testable s => s -> (a,s) }. Am I just thinking about this all wrong?
14:36:29 <S_J> > let cc xs = let sx = reverse xs in ct sx where ct [] = []; ct (x:xs) = x: ct xs
14:36:30 <lambdabot>   not an expression: `let cc xs = let sx = reverse xs in ct sx where ct [] = ...
14:36:36 <S_J> > let cc xs = let sx = reverse xs in ct sx where ct [] = []; ct (x:xs) = x: ct xs;
14:36:37 <lambdabot>   not an expression: `let cc xs = let sx = reverse xs in ct sx where ct [] = ...
14:37:20 <Cale> WraithM: Is there any reason not to just use the unrestricted State monad, and add the constraints to the signatures of the computations you write?
14:37:31 <WraithM> Basically, I want to be able to test (a function which is in Testable) this state at each step of the computation.
14:38:03 <WraithM> I want to be able to write a monad instance for this thing
14:38:36 <S_J> how do I concat "a" and "b" without (++) ?
14:38:48 <danharaj> uh
14:38:50 <S_J> @type (++)
14:38:51 <lambdabot> [a] -> [a] -> [a]
14:38:56 <S_J> @src (++)
14:38:56 <lambdabot> []     ++ ys = ys
14:38:56 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:38:56 <lambdabot> -- OR
14:38:56 <lambdabot> xs ++ ys = foldr (:) ys xs
14:38:56 <Cale> S_J: Well, you can see the definition of (++) there
14:39:02 <dwcook> S_J, replace the tail of the one in front with the one in back
14:39:18 <dwcook> Errr
14:39:21 <dwcook> [], not tail
14:40:03 <Cale> WraithM: Maybe what you want is to newtype a State monad, and only export a 'put' which does whatever test it is that you need to do?
14:40:35 <WraithM> Hmm
14:40:41 <Cale> WraithM: I'm a little bit confused about what it is that you're trying to accomplish.
14:40:54 <Cale> Are you trying to ensure that the state remains consistent in some way?
14:41:21 <WraithM> Sort of
14:41:48 <WraithM> I want to collect errors at each step of the computation.
14:41:52 <monochrom> how about a low tech KISS solution, which is what Cale said
14:42:26 <monochrom> newtype TestState s a = TestState (s -> (a,s))  nothing special here
14:42:37 <WraithM> Right
14:42:43 <WraithM> I guess that makes sense
14:42:52 <WraithM> and just rewrite the monand instance for this thing
14:42:54 <monochrom> but: myput :: Testable s => s -> TestState s ().
14:43:25 <monochrom> the body of myput can do all kinds of checks
14:44:23 <monochrom> runTestState :: Testable s => TestState s a -> s -> (a,s)  -- runTestState inits s, therefore also does all kinds of checks
14:44:42 <elliott> monochrom: you can even give a MonadState instance
14:44:52 <elliott> instance Testable s => MonadState s (TestState s) where ...
14:45:02 <monochrom> that's nice
14:45:21 <S_J> about proofs. a haskell function almost feels like a proof. or not a proof. but twheole equational way of writing functions makes it so easy to write it correct inthe first place. it is very beautiful.
14:45:46 <shachaf> A Haskell function is a proof, but usually not of something very interesting.
14:46:24 <S_J> how is it a proof?
14:46:53 <dwcook> Type signatures look like predicate logic
14:47:13 <dwcook> If I propose (a → b) and a, then I can deduce b: (a -> b) -> a -> b
14:47:30 <jfischoff> and the proof is the implementation
14:47:54 <WraithM> Cale, monochrom, elliott: Thank you for your input! Super helpful. I've got some good direction now.
14:48:02 <jfischoff> a program is proof the type signature is true
14:48:20 <elliott> WraithM: :)
14:48:49 <dwcook> You would be hard-pressed to write (a -> b) -> b -> a without forbidden magic, for example
14:49:43 <ParahSailin> is there an easy way to do all the boilerplate instances in making your own monad transformer?
14:53:28 <Peaker> ParahSailin, "GeneralizedNewtypeDeriving"?
14:53:44 <Cale> ParahSailin: I assume you're talking about instances which lift the methods of MonadReader/MonadState/etc. through your transformer?
14:54:43 <Cale> You kind of have to write those or just neglect them, unless your transformer is a simple composite of other monad transformers, in which case GND will do it.
14:56:57 <dmwit> S_J: Congratulations, you (re)invented the Curry-Howard isomorphism.
14:57:08 <dmwit> S_J: That's a pretty good spot to be in. =)
14:57:28 <monochrom> I like this section title in oleg's paper "finally tagless". "our final proposal" :)
14:57:51 <ParahSailin> Cale: ah, so if i just define the monad transformer in transformers style vs mtl style, the only thing im losing is the automatic lifting?
14:58:56 <startling> S_J: the trivial thing is to say "a function a -> b is a proof that there exists a way to get a 'b' from any 'a'"
15:01:43 <Cale> A proof of A -> B is a proof that there's a way to turn proofs of A into proofs of B
15:02:08 <Cale> ParahSailin: I'm not sure what you mean by that
15:02:13 <startling> oh, that's a betterway to say it.
15:03:08 <ParahSailin> Cale: the difference in mtl is that you dont have to do the lift $ lift ... stuff, but the typeclasses do that for you?
15:03:20 <Cale> Or maybe, remove needless words: A proof of A -> B is a way to turn proofs of A into proofs of B
15:03:52 <Cale> Oh, does transformers leave out those instances?
15:03:55 <shachaf> A proof of A -> B is a function from proofs of A to proofs of B
15:04:12 <ParahSailin> Cale: i think so?
15:04:43 <Cale> Huh, interesting, it looks like it does.
15:05:23 <Cale> ParahSailin: So yeah, if you want those instances, there's no way I know of to avoid writing them.
15:06:05 <Cale> It's sort of a hassle, because there ends up being O(n^2) instances when you have n transformer/class pairs.
15:06:29 <Cale> (of course, maybe not every class will be able to be lifted)
15:07:09 <ParahSailin> Cale: right
15:08:13 <Cale> If you're using monad transformers correctly, having to write multiple lifts shouldn't be a big deal, because you'll only have to do it in a few primitives in a module where you're defining your monad, and then from outside that module, you shouldn't necessarily be able to tell that monad transformers are even involved.
15:08:37 <Cale> (Where I'm using the word "correctly" in an especially opinionated way here)
15:14:09 <ReinH> Cale: right, encapsulation is what makes transformer stacks so easy to use
15:14:53 <ReinH> you don't need to remember how many times you have to lift to get to StateT, you just use the convenience lifter method you defined in your module that defines your monad
15:17:28 <Cale> ReinH: Or, don't expose get and put directly at all.
15:17:58 <Cale> Presumably there's some purpose to having StateT there, and you will likely have some more specific way of interacting with that.
15:18:30 <S_J> What is the best paper on quickcheck and property based testing?
15:19:33 <Cale> http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf
15:20:12 <Cale> That would be the first one you'd want to look at
15:20:28 <Cale> There have been some changes since that was written.
15:20:47 <Cale> Especially with regard to shrinking
15:21:11 <ReinH> Cale: right, hide the implementations and expose your interface, seems good
15:21:19 <ReinH> almost like some sort of general principle
15:21:24 <ReinH> ;)
15:21:32 <danharaj> except if you're putting a library on Hackage
15:21:40 <ReinH> EXPORT ALL THE THINGS
15:21:52 <danharaj> then you better expose your internal modules or I will cut you… out of my development cycle.
15:23:26 <Cale> It doesn't bother me that much with the stuff on Hackage. I'll just get the source and make changes if I need to. :)
15:24:10 <danharaj> that's like
15:24:13 <danharaj> 3 extra actions I have to take
15:30:21 <S_J> what should: sub Zero (Succ Zero) result in for the Natural numbers? Integer (Pred Zero) ? undefined? Zero?
15:30:57 <shachaf> That's up to you.
15:30:58 <dmwit> Nothing
15:30:59 <Cale> S_J: Usually Zero turns out to be the right thing.
15:31:15 <dmwit> Usually you find out you don't use sub when dealing with naturals.
15:31:25 <shachaf> I would say sub :: Nat -> Nat -> Nat isn't even a thing that makes sense.
15:31:41 <Cale> For example, in the property satisfied with respect to length and drop
15:31:43 <dmwit> I would say that, and did. Twice.
15:31:47 <Cale> You'll want Zero.
15:31:50 <monochrom> sub :: Nat -> Nat -> Either Nat Nat  so you can get negative numbers
15:32:00 <tac-tics> S_J: Consider it a situation analogous to division by zero.
15:32:22 <S_J> bud add :: Nat -> Nat -> Nat is? since Nats are closed under add and mul
15:32:31 <dmwit> correct
15:32:37 <dmwit> and for the correct reason, too =)
15:32:47 <shachaf> monochrom: Nat -> Nat -> Integer is nicer, since you don't have to handle the extra zero.
15:32:51 <Cale> There was a paper explaining this perspective at length and giving lots of examples where truncated subtraction that gives Zero is the right thing.
15:33:09 <monochrom> also, divide :: Nat -> Nat -> (Rational, Rational) so you can get the projective real line :)
15:33:53 <tac-tics> My personal favorite is sub : (n : Nat) -> (m : Nat) -> LTE m n -> Nat
15:34:03 <monochrom> sqrt :: Nat -> ??? is left as an exercise :)
15:34:40 <shachaf> tac-tics: sub : (n : Nat) -> Fin n -> ...
15:34:49 <shachaf> Well, I guess that's missing one.
15:35:17 <tac-tics> The signature I gave should prevent negative results without a problem
15:35:22 <monochrom> if you wanted to impose that constraint, I would use dependent predicate subtype. (n : Nat) -> { m : Nat | m<=n } -> Nat
15:35:23 <shachaf> Sure.
15:35:29 <tac-tics> (Although you r problem might be "I'm using Haskell")
15:37:22 <DMcGill> Agda is a compily-only language right?
15:37:29 <DMcGill> ;)
15:37:43 <monochrom> use ghci or hugs to interpret it
15:39:04 <DMcGill> I meant more that I've seen multiple agda programs compiled and type checked, but I've never seen them actually run.
15:39:33 <monochrom> perhaps not even compiled, just checked.
15:39:39 <josephle> why would you ever run them?! Proofs are for checking, not for running! :P
15:39:41 <tac-tics> DMcGill: It's sort of like that TV trope, where an alien race has become so advanced they have "transcended their need for physical bodies"
15:40:00 <tac-tics> Agda: Types so advanced, they have transcended the need for ever being executed.
15:40:01 <monochrom> because when you say "compile" I get to ask "where is the generated code?"
15:40:25 <tac-tics> monochrom: An important distinction lost to the unwashed masses ;P
15:40:55 <DMcGill> I was speaking to a PhD student whose compile (or possibly type-check) time was more than the running time of basically all of my code
15:40:59 <monochrom> actually, I believe the unwashed mass expect generated code, too
15:41:06 <DMcGill> we're talking several days
15:43:00 <monochrom> do not underestimate the unwashed mass. because they are still in contact with the ground, they are sometimes more sensible than some curry-howard fanatics
15:46:32 <S_J> doesnt haskell quickcheck do shrink automatically?
15:47:55 <JoeyA> > if True then error "A" else error "B"
15:47:56 <lambdabot>   *Exception: A
15:48:11 <JoeyA> Does imprecise exceptions allow the error "B" exception to arise instead?
15:48:23 <monochrom> this one no
15:48:30 <shachaf> monochrom: No?
15:48:44 <monochrom> assuming that the rest of the program do not have error"B"
15:48:51 <shachaf> I'd say that they're both ⊥, so GHC wouldn't be doing anything illegal if it gave you error "B"
15:49:43 <startling> > error "rm -rf /"
15:49:44 <lambdabot>   *Exception: rm -rf /
15:49:49 <monochrom> I reject that reason
15:50:55 <monochrom> if you harp on ⊥, the logical conclusion is: error"A" --> error"GHC decides to completely make up a message not even present in your program"
15:51:17 <monochrom> clearly, even imprecise exceptions have to be more precise than that
15:51:33 <DMcGill> that's nothing compared to some "undefined behaviour" I've heard about in C
15:56:13 <ReinH> so google.com is down
15:56:15 <ReinH> that is interesting
15:56:52 <jfischoff> woah
15:57:07 <jfischoff> down in mountain view
15:57:18 <monochrom> google.ca works here
15:57:32 <monochrom> well, not thoroughly tested, let me test more
15:57:37 <ReinH> it's back now
15:57:52 <ReinH> I suspect they were on top of that one pretty quickly
15:58:20 <monochrom> or just a stop-the-mountain-view GC for 2 seconds
15:58:52 <Ralith> heh
16:00:49 <ReinH> lmao
16:02:07 <xenocons> :t abs
16:02:08 <lambdabot> Num a => a -> a
16:02:51 <nicoo> monochrom: I don't really expect google to get GC pauses on something as trivial as the homepage :D
16:08:20 <S_J> So back to previous topic about haskell and proofs. is construction proof? i define a way to transform a to b and thus I have proofed it is possible. Maybe I am just restating what you say before, just trying to melt things.
16:09:04 <xenocons> nicoo: could be written in Go
16:09:29 <dwcook> S_J, "it's possible" is like saying "there exists", which requires only one example to prove
16:09:41 <Cale> S_J: Well, Haskell doesn't make a very good proof theory if you care about what things are true and what things aren't, because everything has at least one proof.
16:10:05 <dwcook> Cale, counting bottom?
16:10:08 <Cale> S_J: Specifically, because it has general recursion, you can write fix :: forall a. (a -> a) -> a, and then fix id :: forall a. a
16:10:09 <Cale> yes
16:10:31 <tac-tics> Haskell (and most languages) are inconsistent when used as logics.
16:10:36 <Cale> (If you're unfamiliar,  fix f = x where x = f x)
16:12:39 <nicoo> tac-tics, Cale : Yes, basically because one only cares about the states his program might reach.
16:12:44 <Cale> S_J: In logic, when you want to prove A -> B, you assume A, and you construct a proof of B.
16:13:19 <Cale> In lambda calculus, when you want to construct a function f : A -> B, you assume x : A, and you construct a term y : B, and then (\x -> y) : A -> B
16:13:41 <Cale> In logic, if you know A -> B, and you know A, then you can infer B.
16:14:00 <Cale> In lambda calculus, if you have f : A -> B, and you have x : A, then you obtain f x : B.
16:15:05 <Cale> In logic, if you know A, and you know B, then you can infer A and B.
16:15:39 <Cale> In lambda calculus, if you have x : A, and you have x : B, then you have (x,y) : (A,B) (using Haskelly notation for pair types)
16:15:53 <Cale> In logic, if you know A and B, then you can infer A
16:16:08 <Cale> In lambda calculus, if you have p : (A,B), then you have fst p : A
16:16:24 <Cale> (and similarly with B/snd)
16:17:02 <Cale> In logic, if you know A, you can infer A or B. In lambda calculus, if you have x : A, then you have Left x : Either A B
16:17:15 <Cale> (and similarly with B/Right)
16:17:20 <startling> S_J, I liked this paper: http://homepages.inf.ed.ac.uk/wadler/papers/frege/frege.pdf
16:19:00 <Cale> In logic if you know A or B, and you know A -> C, and B -> C, then you can infer C. In lambda calculus, if you have x : Either A B, and you have f : A -> C, and g : B -> C, then you have either f g x : C
16:19:30 <Cale> (In retrospect, I could have made stated the rule for products more symmetrically ;)
16:19:46 <Cale> -made
16:20:47 <ion> Btw, i really dislike the sigma/pi notation for dependent functions and pairs in the HoTT book (and i’m sure elsewhere, this is the first book i’m reading about the subject). Something like, say, infix → and × with a circle around them would have made more sense.
16:22:06 <jhy6h54ju> please friends visit new webchat www.ChatSocial.org please 2 cliks --> http://www.ChatSocial.org tnkssssss  http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org
16:22:06 <jhy6h54ju> http://www.ChatSocial.org
16:23:38 --- mode: ChanServ set +o johnw
16:23:41 --- mode: johnw set -o johnw
16:25:15 <josephle> ion: the Sigma and Pi are used, iirc, because those are in fact dependent sums and products
16:27:42 <Cale> ion: Why do you dislike it?
16:28:00 <Cale> ion: They really are sums and products of spaces
16:28:43 <Cale> It's pretty standard notation, even outside HoTT.
16:29:31 <Fylwind1> i think it's pretty clever, by the same analogy as A + B and A x B for regular sum and products, and Y^X for functions; though I agree it doesn't do much good for programmers
16:30:42 <lispy> Actually, I found Sigma and Pi types confusing until something I read used + for or and x for and...
16:30:47 <lispy> Suddenly it clicked
16:31:08 <Cale> Yeah, it's kind of assumed that you know that :)
16:31:11 <ion> I’m sure i’ll grow to like them after rewiring my brain, i’m looking at this all through a lens tinted by what i know in the past. They just looked like functions and pairs “but special” and i was expecting the notation to have some resemblance with the one for functions and pairs.
16:32:21 <Fylwind1> honestly i think the odd one out is the X -> Y notation; Y^X just seems more 'natural' if you think of them like numbers
16:32:52 <S_J> ty Cale
16:34:01 <lispy> Cale: I knew that people sometimes do that but I just didn't occur to me that the type theorists were using that :)
16:34:36 <ion> Agda’s syntax for dependent functions and seems more familiar to me (i’m not saying “more natural” because i realize this is completely subjective).
16:34:42 <ion> s/and //
16:36:07 <applicative> forall (a:A) -> B a ?
16:36:39 <Cale> ion: You mean forall in place of product?
16:39:43 <ion> Perhaps i misinterpreted what i was reading. I thought (x : A) → B x was equivalent to Π_{(x : A)} B(x)
16:40:10 <orzo_> hi, i'm playing with Data.Bijection http://hackage.haskell.org/packages/archive/TypeCompose/0.6.4/doc/html/Data-Bijection.html
16:40:37 <orzo_> It seems to me, using the arrow operators i can start with a reasonable Bijection and then use >>^ const ()
16:40:46 <orzo_> and then it is of type Bijection, but can't be
16:41:00 <orzo_> Is that right?
16:41:22 <orzo_> Shouldn't that be prevented?
16:45:04 <danharaj> did haskell.org just go down
16:45:29 <danharaj> rather, hackage.haskell.org
16:45:59 <Fylwind1> seems so
16:46:03 <ion> http://isup.me/hackage.haskell.org
16:46:06 <monochrom> yikes
16:46:16 <danharaj> worst time to go down
16:46:20 <danharaj> I was downloading the universe
16:46:45 <monochrom> perhaps you caused it :)
16:46:52 <monochrom> "need to GC again"
16:46:57 <danharaj> hehe
16:47:06 <danharaj> it is conceivable that installing lens from scratch could cause that
16:47:21 <danharaj> oh hey it's back up again
16:47:36 <monochrom> today must be GC day
16:47:42 <danharaj> oh no it's not
16:48:11 <monochrom> this time the OS underneath does GC :)
16:54:14 <poppingtonic> hmmm...is hackage.haskell.org down? I was updating cabal :(
16:54:46 <monochrom> yes
16:55:08 <monochrom> see the topic for options
17:00:14 <DanielDiaz> I miss you, Hackage :(
17:00:43 <S_J> why isnt mod and div typeclasses?
17:00:56 <arkeet> huh?
17:01:02 <arkeet> mod and div are in the Integral class.
17:01:05 <arkeet> :T mod
17:01:07 <arkeet> :t mod
17:01:07 <lambdabot> Integral a => a -> a -> a
17:16:24 <S_J> is 0^0 really 1?
17:16:56 <alpha123> yup.
17:18:31 <quchen> 0^0 is indeterminate and you can define it to be whatever you want it to be.
17:18:43 <quchen> Most of the time that 'whatever' is 1.
17:18:44 <merijn> quchen: No it's not
17:19:01 <merijn> quchen: I'm pretty sure almost everyone defines n^0 = 1
17:19:04 <merijn> For any n
17:19:11 <quchen> I've seen it set to 0 as well.
17:19:18 <quchen> (Can't remember where though.)
17:20:38 <merijn> quchen: That doesn't make any sense given the inductive definition of ^
17:21:00 <quchen> That's right.
17:21:01 <merijn> quchen: i.e "x^n = x * x^(n-1)" with "x^0 = 1"
17:21:10 <elliott> I would like to end this discussion by linking http://en.wikipedia.org/wiki/Exponentiation#Zero_to_the_power_of_zero
17:21:15 <jmcarthur> 1 makes a lot of sense because it means for n >= 0,   m^n * m = m^(n+1)
17:21:40 <jmcarthur> it m^0 wasn't 1, that would have to be for n > 0
17:22:20 <arkeet> @src (^)
17:22:20 <lambdabot> x ^ 0            =  1
17:22:20 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
17:22:20 <lambdabot>   where f _ 0 y = y
17:22:20 <lambdabot>         f x n y = g x n
17:22:20 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
17:22:22 <lambdabot>                       | otherwise = f x (n-1) (x*y)
17:22:24 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
17:22:39 <arkeet> heh, squaring.
17:22:40 <DanielDiaz> yes, n^0 = 1 for every n
17:22:59 <DanielDiaz> you can't let an operator be "undefined" for some values
17:23:08 <jmcarthur> err... division? :)
17:23:26 <quchen> n^0 = pi is also a valid definition. Not a very sensible one though. Also what Elliott said.
17:23:29 <DanielDiaz> jmcarthur: that is not an inner operator as I have studied it
17:23:43 <quchen> ^ for n = 0 ;-)
17:23:49 <jmcarthur> DanielDiaz: "inner operator"?
17:24:13 <DanielDiaz> jmcarthur: something like AxA -> A, for a set A
17:25:01 <dmwit> I find the argument "all operators are total, therefore (^) should be total" to be lacking.
17:25:03 <jmcarthur> well, sure, if you put it that way then a (^) that is undefined for 0 exponents would just not be an inner operator, the same way division isn't
17:25:04 <danharaj> I think your reasoning is tautological
17:25:06 <dmwit> Who says (^) must be an operator?
17:25:12 <DanielDiaz> jmcarthur: usually called just "operator"
17:25:13 <dmwit> Other arguments are better, but that particular one sucks.
17:25:24 <jmcarthur> DanielDiaz: a magma?
17:26:00 <DanielDiaz> jmcarthur: the magma is the pair of the set and the operator.
17:26:00 <arkeet> (^) isn't total.
17:26:04 <arkeet> > 5 ^ (-1)
17:26:06 <lambdabot>   *Exception: Negative exponent
17:26:14 <dmwit> > 5 ^^ (-1)
17:26:15 <lambdabot>   0.2
17:26:19 <quchen> arkeet: Depends on the codomain. :-P
17:26:38 <arkeet> depends on whether you have things less than 0.
17:27:03 <DanielDiaz> arkeet: depends on whether you have multiplicative inverse or not, I think.
17:27:19 <jmcarthur> > 5.0 ^ (-1)
17:27:20 <dmwit> I think this conversation has wandered far out of the "helpful" region.
17:27:20 <lambdabot>   *Exception: Negative exponent
17:27:34 <DanielDiaz> :t (^)
17:27:35 <lambdabot> (Integral b, Num a) => a -> b -> a
17:27:35 <arkeet> DanielDiaz: no, it doesn't. look at the definition of (^)
17:27:49 <jmcarthur> it really just wants the exponent to be a natural number
17:27:52 <DanielDiaz> arkeet: the exponent is Integral, different from the base.
17:28:00 <arkeet> yes.
17:28:12 <arkeet> and the base is Num, where you can't divide.
17:28:26 <DanielDiaz> the idea is to have ^(-1)  as recip, isnt?
17:28:35 <arkeet> no, the point is that (^) doesn't do that.
17:28:37 <arkeet> (^^) does.
17:28:41 * dmwit smashes arkeet and DanielDiaz together
17:28:47 <DanielDiaz> arkeet: sorry, that is what I meant. ^^
17:28:47 <arkeet> but that requires a Fractional instance on the base so that you can divide.
17:28:47 <dmwit> arkeet is talking Haskell, DanielDiaz is talking math.
17:28:56 <dmwit> Congratulations, all the miscommunication can end now.
17:29:00 <arkeet> =)
17:29:04 <DanielDiaz> dmwit: haha, thank you.
17:29:27 <DanielDiaz> anyway, I think the idea of the (^^) Haskell operator is exactly that.
17:29:44 <arkeet> @src (^^)
17:29:44 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
17:29:59 <DanielDiaz> exactly
17:30:16 <DanielDiaz> so x^^(-1) = recip x, if x^1 = x, which should be
17:30:52 <arkeet> > x^1
17:30:54 <lambdabot>   x
17:31:13 <levi> The wikipedia answers were pretty interesting.
17:32:52 <levi> My first thought was that the answer was related to 1 being the unit of the product monoid for integrals, which was among the answers, but the set-theoretic ones views were interesting too.
17:33:21 <jmcarthur> DanielDiaz: it's just that i've never heard of such constraints on the word "operator" without actually being related to some algebraic structure
17:33:56 <jmcarthur> DanielDiaz: for that matter, your very definition put requirements on the domain and codomain, so it really is a magma you're talking about
17:34:35 <dmwit> Saying something is a magma doesn't prevent other terms from applying to it.
17:35:11 <DanielDiaz> jmcarthus: not necessarily. I mean, in the same set, you may have infinite operators. The operator itself does not define the magma. It does it when you pair the set with the operator.
17:36:33 <jmcarthur> DanielDiaz: but you said it has to be AxA->A. are you trying to say it's an "operator" when A is free and a magma when it's not?
17:36:37 * elliott wistfully remembers linking a Wikipedia article to end this quarter ofa n hour ago.
17:37:59 <DanielDiaz> jmcarthur: I mean, it is not really an important matter. An operator refers to the function. A magma to a set with a function.
17:38:20 * arkeet hi
17:38:32 <jmcarthur> really i just don't know where this definition of operator came from. i'm used to division being treated as an operator
17:39:05 <jmcarthur> or at least the syntax of division
17:39:09 <danharaj> I know of a few places in math where the word operator is used to refer to an object that isn't defined everywhere.
17:39:18 <dmwit> I, too, find this definition of operator non-standard. But so what? I like non-standard, and as long people are up-front about their definitions I'm fine with whatever.
17:39:18 <arkeet> it's a partially defined operator.
17:39:48 <jmcarthur> dmwit: yeah that's fine. i'm not trying to be argumentative. just exploring whether it's a valuable distinction
17:40:25 <shachaf> The question is: Is http://www.youtube.com/watch?v=ahBU4Py5cPg a magma?
17:43:15 <jmcarthur> hmm... just realized an interesting property of stable-memo... you can say  `memo memo`
17:43:17 <DanielDiaz> jmcarthur: relevant wikipedia article: http://en.wikipedia.org/wiki/Binary_operation
17:43:50 <jmcarthur> DanielDiaz: i note that the article explicitly lists division
17:44:10 <arkeet> and calls it a partial binary operation
17:44:33 <jmcarthur> arkeet: but DanielDiaz rejected it from his definition of operation at all
17:44:34 * shachaf tries to figure out what the argument is about. Words?
17:44:43 <arkeet> jmcarthur: partial binary operations aren't binary operations. ;)
17:44:50 <jmcarthur> shachaf: yeah it's another silly terminology debate that we should put to death
17:45:02 <arkeet> (wasn't this linked somewhere just earlier? http://ncatlab.org/nlab/show/red+herring+principle
17:45:08 <DanielDiaz> jmcarthur: well, maybe I am too used to call "operation" to the closed ones.
17:45:14 <jmcarthur> fair enough
17:45:22 <jmcarthur> we have flooded the channel enough with this silliness :)
17:45:28 <DanielDiaz> I am just having fun haha
17:45:29 <arkeet> (maybe "partial function" should be added to that article.)
17:45:30 <jmcarthur> (silly on both sides, to be fair)
17:45:33 <DanielDiaz> sorry about that
17:45:44 <jmcarthur> i was carring on too
17:46:31 <jmcarthur> anyway...  `memo memo` is a memo combinator that memoizes on the function you apply it to, so if you apply it to the same function twice the results will share the same memo table
17:49:22 <ParahSail1n> @hoogle transformers
17:49:22 <lambdabot> package transformers
17:49:22 <lambdabot> package transformers-abort
17:49:22 <lambdabot> package transformers-base
17:50:18 <applicative> hm, hackage has gone incommunicado
17:50:40 <ParahSail1n> yeah
17:54:19 <DanielDiaz> leaving the room, bye-bye!
18:11:13 <meretrix> If I have a low latency critical haskell thread and cpu/garbage intensive haskell thread, would it make sense to split them into separate processes with IPC to protect the low latency thread from GC pauses?
18:13:18 <monochrom> hmm, that may be useful. measure it.
18:15:32 <hpaste> nuttycom pasted “Encountered while trying to build ghc-7.6.3 - any ideas?” at http://lpaste.net/91907
18:15:48 <monochrom> please don't try to build ghc
18:16:15 <monochrom> but this one is strange
18:16:18 <nuttycom> Hi all... any help with the above would be much appreciated. I'm trying to get around the abominable situation with the unavailability of a haskell platform for recent ubuntu.
18:16:38 <monochrom> there is very little to get around
18:16:45 <shachaf> Just download a GHC binary and use that.
18:17:12 <monochrom> to get GHC itself for ubuntu 13.04, consider my http://www.vex.net/~trebla/haskell/I-built-GHC.xhtml
18:17:14 <lingxiao> data ListTM m a = NilT | a `ConsT` m (ListTM m a)
18:17:23 <lingxiao> hey all.. if I have a data type of form above
18:17:40 <monochrom> for the rest of Haskell Platform, consider my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
18:17:43 <lingxiao> is it possible to make a Monoid instance of it without comonad m restriction on m?
18:18:11 <nuttycom> monochrom: thanks, I'll give that a shot. I was attempting to follow the directions here: http://askubuntu.com/questions/286764/how-to-install-haskell-platform-for-ubuntu-13-04
18:18:22 <edwardk> lingxiao why a comonad not a monad?
18:19:03 <lingxiao> edwardk : m is def a monad, but I do not know how to implement monoid instance without making m a comonad as well
18:19:21 <lingxiao> lt `mappend` ls = case lt of
18:19:21 <lingxiao>     NilT      -> ls
18:19:21 <lingxiao>     ConsT a m -> case extract m of
18:19:22 <lingxiao>       NilT -> ConsT a $ return ls
18:19:24 <lingxiao>       lt'  -> ConsT a $ return $ lt' `mappend` ls
18:19:39 <lingxiao> um... not sure if that is showing up ok on your end, but that's what I have for mappend
18:19:43 <edwardk> lingxiao: put an extra m on the outside
18:19:44 <monochrom> I symlinked libgmp 10 to 3. works for me. none of "confusing failures"
18:19:56 <edwardk> see "ListT Done Right"
18:20:08 <lingxiao> ah like this: `newtype ListT m a = ListT { unl :: m (ListTM m a) } `
18:20:13 <edwardk> yeah
18:20:18 <monochrom> now, of course, I can't say that it is good for other libs. but I don't care about other libs.
18:20:45 <lingxiao> ok cools, I am following that article actually, just trying to see what else I could do with it. But I guess I'm foolish to question Gabriel
18:20:58 <danharaj> who is Gabriel and why are they unquestionable.
18:21:23 <lingxiao> Gabriel Gonzales... I think he wrote the article. I don't know if he's unquestionable but def better at Haskell than me
18:21:39 <lingxiao> tekmo is what he goes by I thnk..
18:23:40 <nuttycom> monochrom: in an ideal world, I wouldn't mind to build ghc and the rest of haskell-platform myself routinely anyway, so that I'm able to not be a slave to a distro's schedule. Any idea whatsoever on the error, or who I could talk to to resolve it?
18:24:07 <shachaf> nuttycom: Why do you want to build GHC yourself?
18:24:17 <edwardk> yeah thats tekmo
18:24:21 <shachaf> There are binaries available.
18:24:30 <monochrom> I don't even think I can reproduce the error. at this point, I'll just conjecture "disk corruption"
18:24:54 <monochrom> I mean, I built GHC on a similar platform as yours afterall, no? :)
18:26:38 <nuttycom> Meh. Maybe it's the history of this particular machine, and the cryptic interaction of distro upgrades and homespun builds. Still, what a hassle. All I wanted was to cabal install snap (a couple of days ago) and dependency hell has eaten up hours since. :{
18:27:50 <dmwit> Did I miss the part where we get to deride you for trying to build GHC?
18:27:58 <monochrom> yes :)
18:28:14 <dmwit> dang
18:28:49 <danharaj> I am building GHC Head as we speak.
18:28:54 <monochrom> but to be fair there is nothing to deride, I even did it twice (because 32 and 64), it's just a lot of time and a lot of heat, what error?
18:28:54 <danharaj> So that I can play with fancy stuff.
18:28:57 <shachaf> No derision necessary.
18:29:04 <danharaj> My legs are on fire :3
18:29:08 <danharaj> silly laptop
18:29:18 <monochrom> please don't build ghc on your legs
18:29:34 <edwardk> death by ghc
18:29:34 <danharaj> I am afraid it'll set fire to the coffee table though.
18:29:39 <monochrom> doctors says it's also your genitals, not just legs
18:29:43 <edwardk> better the coffee table than you
18:29:50 * tabemann is waiting for GHC 7.6.3 to become available for Debian testing (it's already available for unstable) rather than trying to actually build it himself
18:29:54 <danharaj> edwardk: but then I'll have no place for my coffee!
18:30:06 <monochrom> um, don't build ghc on coffee table either, of course. use a laptop cooling fan pad
18:30:07 <edwardk> "You see these scars? I got them back in 7.7."
18:30:32 <shachaf> I just went to haskell.org and downloaded GHC.
18:30:33 <monochrom> @remember edwardk "You see these scars? I got them back in 7.7."
18:30:33 <lambdabot> It is stored.
18:31:14 * tabemann is using a tower, so he doesn't have to worry about burning himself with GHC
18:31:18 <dmwit> Building HEAD is different. There's no binaries for HEAD.
18:31:29 <danharaj> edwardk: what sort of angle do you think I should work in order to convince everyone involved to try to get pi types into GHC 7.8
18:31:50 <monochrom> the tower may output enough infrared to start you on fire
18:31:52 <edwardk> danharaj: isn't that gundry's whole thing?
18:32:04 <monochrom> and keep you warm for the rest of your life
18:32:08 <danharaj> edwardk: yes but it is quite an ambitious plan and I think spj needs to be bribed/coaxed/convinced.
18:32:18 <monochrom> "teach a man how to build ghc..."
18:32:34 <tabemann> monochrom: so how do we have anyone who lives to actually manage to build GHC in the first place?
18:32:40 <edwardk> @tell ReinH diagrams work and are pretty. going to hold off until byorgey can release an updated diagrams-canvas so they can be fast too
18:32:40 <lambdabot> Consider it noted.
18:33:05 <dmwit> tabemann: the cloud, man, the cloud
18:33:05 <edwardk> tabemann: no, its one of those folklore things.
18:33:34 <tabemann> dmwit: the cloud runs haskell?
18:33:55 <danharaj> it's a molecular cloud in space. ghc binaries are downloaded via cosmic ray
18:34:15 <dmwit> build it in the cloud, let the Google employees burn while you collect your precious GHCs
18:35:02 <tabemann> with these kinds of hazards I'm surprised that building GHC doesn't make the cores it is compiled on melt
18:37:08 <joelteon> is hackage down again :<
18:37:19 <tabemann> it probably is only worthwhile to compile GHC on a machine which can only compile it once by making sure it is someone else's computer
18:37:19 <danharaj> yes use a mirror
18:37:20 <dmwit> Is this not the scheduled downtime?
18:37:44 <dmwit> Ah, no, I see that's tomorrow.
18:37:58 <dmwit> Well. Tonight early morning.
18:38:00 <luite> good to see that they're well ahead of schedule then
18:38:35 <dmwit> =D
18:39:18 <danharaj> core lint warnings seem ominous
18:39:28 <danharaj> like dryer lint coming out of a nuclear reactor
18:41:04 <meretrix> In writing a ToRow instance for postgresql-simple, is there really not a more compact syntax:
18:41:05 <meretrix> toRow (Quote a b c d e f) = [toField a, toField b, toField c, toField d, toField e, toField f]
18:41:20 <tabemann> danharaj: how'd you manage that
18:41:33 <danharaj> GHC HEAD doesn't care
18:41:38 <danharaj> GHC HEAD will eat your children
18:42:14 <tabemann> what's the lambdabot command to find something that matches a type?
18:42:25 <shachaf> Hoogle does it.
18:43:40 <tabemann> meretrix: hmm there doesn't seem to be a better way to do it...
18:44:53 <meretrix> Ok, I'm used to haskell being so elegant, so I thought I'd ask.
18:49:06 * danharaj that sad moment when you realize no amount of sriracha will be hot enough
18:51:29 <ion> That’s not sad at all. When getting used to hot chilis you’ll find new, awesome flavors you never tasted before and you’ll get the capsaicin kicks as a bonus. :-P You can always make food hotter (e.g. sriracha for the taste, naga powder for the kicks) but it’s more difficult to make too hot food less spicy.
18:54:31 <ion> When you get more used to capsaicin, you’ll also use the naga powder for the taste. :-P
18:54:39 * tabemann wonders how badly he is abusing Data.PQueue.Prio.Min by using partition as a means of *deleting* items from the middle of priority queues (as opposed to the normal, more efficient taking things off the end of the priority queue)
18:55:27 <dmwit> If you want to delete items a lot, you may want to look for a PSQueue instead of a plain old PQueue.
18:55:48 <zomg> ion: I wonder if there's been any studies on the effects of getting used to hot foods, whether it actually numbs your taste in some other way... =)
18:56:26 <zomg> I mean pain is pretty much a reaction to make you stop doing whatever it is that's causing said pain... :D
18:57:05 <ion> It only numbs your TRPV1 receptors, not your tastebuds.
18:57:16 <zomg> Whatever those are
18:57:17 <zomg> :P
18:57:24 <maurer> meretrix: If you're doing it a bunch you could use T-H
18:57:31 <tabemann> dmwit: I'd look into that, but Hackage is down, and I can't figure out how to efficiently navigate hdiff.luite.com
18:57:51 <ezrios> @hoogle a -> b
18:57:51 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:57:51 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
18:57:51 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
18:58:05 <ezrios> tabemann: you mean that?
18:58:32 <tabemann> ezrios: I can't find any docs on hdiff.luite.com
18:58:49 <ezrios> tabemann: I was responding to your earlier question about lambdabot
18:58:53 <ezrios> I guess I was late to the party
18:59:03 <tabemann> ezrios: yeah
18:59:25 <dmwit> tabemann: JFGI?
18:59:33 <dmwit> https://www.google.com/search?q=priority+search+queue+haskell
19:00:09 <dmwit> ion: What do TRPV1 receptors do?
19:00:27 <tabemann> dmwit: umm google doesn't cache the hackage page for that
19:00:41 <ion> dmwit: http://en.wikipedia.org/wiki/TRPV1
19:01:51 <dmwit> tabemann: ...oh
19:03:20 <tabemann> i'd look into it as soon as hackage is back up, as i would like something a bit more efficient at deleting items from priority queues than partition
19:03:47 <tabemann> (well, it's not essential, as the size of this priority queue will be no bigger than the number of capabilities)
19:06:09 <applicative> here is the whole PSQueue implementation fwiw tabemann  http://sprunge.us/EYMX
19:07:46 <tabemann> interesting that it uses explicit user-provided priorities rather than Ord
19:09:27 <applicative> this is really the paradigm of ye olde hackage modules; a difficult data type and ... not one example
19:09:30 <tabemann> hmm actually it uses Ord on both the key and the priority
19:10:22 <ffog> hmm
19:10:43 <tabemann> good - delete is O(log n)
19:10:48 <tabemann> better than the O(n) of partition
19:12:28 <tabemann> from looking at this code it actually will work well for I want (even though it will require a good bit of refactoring of my code)
19:16:32 <tabemann> minor stylistic question: why in code examples do people like to put their commas *before* entries in multiline module, record, and tuple definitions?
19:17:38 <byorgey> tabemann: it makes it visually easy to see the list elements (the commas look like bullet points), and much harder to forget a comma at the end of a line
19:18:01 <byorgey> and I like how you can line the commas up with the [ and ]
19:18:18 <byorgey> otherwise you have your commas all raggedy at the ends of the lines, ugh
19:18:59 <danharaj> I always forget my commas if I don't align them that way
19:19:04 <startling> me too.
19:19:23 <levi> When I put the commas at the end and I add a new element to my list, half of the time I forget to add a comma and have to peer at a compile error for a moment before I realize why.
19:20:00 <tabemann> I'm so used to putting my commas at the ends of lines from programming in other languages where such was standard
19:20:21 <byorgey> tabemann: I bet you're used to mutating variables too.
19:21:17 <tabemann> byorgey: no, I prefer not to; at my work I had people refactoring my code to "use a single return code", where I was avoiding mutating variables (as would be required by that)
19:21:23 <tabemann> s/code/statement
19:21:30 <tabemann> and this was in Java
19:21:31 <byorgey> tabemann: fair enough =)
19:21:32 <ion> tabemann: Erlang?
19:21:57 * tabemann thinks not mutating variables is so much better than a stupid "single return point"
19:23:39 <tabemann> ion: I wish I could program in Erlang at work...
19:35:04 <zRecursive> tabemann: why not haskell ?
19:36:32 <tabemann> zRecursive: well Haskell would be better of course
19:36:57 <tabemann> but I'd be glad if I could program in, say, OCaml at work, even though I do not use it for my own programming anymore
19:37:32 <dmj`> tabemann: what language do you use at work
19:37:53 <zRecursive> in fact, i would like to use C because it is easy to debug
19:38:09 <tabemann> dmj`: Java and C++
19:39:02 --- mode: ChanServ set +o elliott
19:39:15 * tabemann finds C to be a pain for anything other than merely pushing bits around, as it is not very conducive to working with data structures
19:39:17 --- mode: elliott set +b lambdakind*!*@*$##fixyourconnection
19:39:20 --- mode: elliott set -o elliott
19:40:13 <tabemann> the only real good things about C is that just about everything out there will talk to it, as just about everyone has FFI bindings that will work with it
19:40:49 <tabemann> and that for heavily inner-loop type code you can optimize it to be faster than probably anything else, except maybe some FORTRAN and hand-optimized assembly
19:41:39 <zRecursive> Anyway the world is supported by C , i.e. linux, windows, *bsd ...
19:41:46 <dmj`> tabemann: which do you like more for data structures c++ or java
19:41:50 <dmwit> Yes, the solution to requiring the n^2 edges of a clique is to require the n edges of a star graph. You just need a popular enough center for the star.
19:42:16 <alpha123> C's just a great systems programming language. It fills a good niche, which is sort of as readable, structured, portable assembly.
19:43:16 <levi> alpha123: I disagree about C's greatness as 'portable assembly', but it's certainly ubiquitous.
19:43:54 <tabemann> dmj`: Java because garbage collection means you do not have to keep a chain-of-custody for each object created, and hence can use objects as values provided they are immutable
19:44:14 <spaceships> i heard a compelling argument that its compiler was free at the right time
19:44:16 <gnuvince> Why is it that every time I try to install a new package with Cabal, I am warned that the installation of a new package might break all other packages?
19:45:02 <alpha123> levi: Well-written C is portable assembly. Plenty of things are undefined, but those are architecture-specific and it's much easier to deal with those then in asm (obviously).
19:45:22 <zRecursive> i always suggest all students should learn assembly and c first
19:45:33 <levi> alpha123: There's no such thing as 'portable assembly', and even if there were, C wouldn't be it.
19:45:38 <tabemann> to use objects as values in C++ means doing a lot of copying (can we say copy constructors?) or very careful use of const references
19:46:03 <tabemann> (careful in that you can't really use a const reference as a value, even though in many places you can get away with it)
19:46:52 <alpha123> levi: C is just a level above assembly that can compile to whatever specific assembly language is used on a given architecture.
19:47:31 <tabemann> there is C--, which is more assembly-like than C, but not *nearly* as used
19:47:49 <dmj`> isn't java getting lambdas?
19:47:56 <GreaseMonkey> i've heard LLVM's intermediate representation (IR) is fairly decent for portability
19:47:56 * tabemann isn't aware of it being used anywhere other than in GHC actually
19:47:57 <levi> alpha123: That can be said of all languages that compile to machine code.
19:48:10 <tabemann> dmj`, in Java 8, yes
19:48:26 <tabemann> it's also getting lazy streams too
19:48:57 <ion> Yes, Haskell is “just a level” above assembly as well.
19:49:01 <alpha123> levi: Not really. C is also quite close to the hardware.
19:49:03 <levi> alpha123: C provides its own semantics that are neither close to modern machine models nor close to modern high-level languages.
19:49:19 <alpha123> ion: ...No, it's not. It's garbage collected for one thing, and doesn't have direct access to memory.
19:49:29 <levi> C's machine model was pretty close to the hardware back in the PDP days in which it was developed.
19:49:37 <alpha123> And that's how it got popular. :)
19:49:46 <ion> alpha123: I was answering to levi.
19:50:06 <levi> Yes, but both hardware architecture and languages have moved on since then.
19:50:10 <alpha123> ion: Oh, sorry.
19:50:28 <zRecursive> C is still moved on too
19:50:39 <tabemann> the biggest problem with C as a portable assembly is that you can make pointers to arbitrary local variables, when normally they would actually be much of the time in registers rather than in addressable memory
19:50:41 <levi> Barely.
19:50:43 <tabemann> and the compiler has to work around that
19:51:03 <tabemann> they in C99 added restrictions as to what pointers could do to help optimize such cases
19:51:22 <ion> What kind of restrictions did they add?
19:51:31 <fylwind> the aliasing rule?
19:51:33 <alpha123> levi: Stuff hasn't moved on enough that C is useless as a systems language, it's much closer to the hardware than most everything else out there.
19:51:38 <zRecursive> C99 < C11 ?
19:51:44 <tabemann> ion: you couldn't do arbitrary conversions between all pointer types
19:52:00 <ion> ok
19:52:01 <levi> alpha123: I never said it was useless.  I use it every day to write device drivers, network protocol stacks, small applications for embedded systems, etc.
19:52:06 <tabemann> e.g. you could turn a char* or void* into anything, but you couldn't change a double* into an int* necessarily
19:52:14 <tiffany> ion: __restrict__, for one thing, which is why FORTRAN isn't as much of a king of number crunching
19:52:34 <alpha123> levi: Which proves that it's still close enough to modern hardware to be useful.
19:52:43 <levi> Useful, yes.  Nice, no.
19:52:57 <zRecursive> nice indeed
19:53:02 <fylwind> writing C is a lot of painstaking work
19:53:05 <alpha123> Perhaps. I'm not saying C is ideal - it's not - but it's pretty darn good.
19:53:06 <tabemann> the thing is that working in straight assembly or LLVM IR isn't viable, so what are the alternatives?
19:53:13 <levi> Pretty darn good? No.
19:53:14 <alpha123> tabemann: Forth maybe?
19:53:38 <levi> I don't think it's got a viable competitor, though, so I make the best of it.
19:53:44 <zRecursive> there is #c :)
19:53:44 <tabemann> there is Forth, but it has a machine model which itself differs in many ways from the typical calling conventions out there (e.g. it uses *two* stacks)
19:53:53 <fylwind> it also helps that C has some of the best optimizing compilers out there
19:53:56 <tiffany> I don't think there's much left to C that makes it "faster"
19:54:12 <tiffany> llvm-based system's languages all have very similar performance
19:54:50 <tabemann> C is faster because it doesn't have garbage collection and also doesn't have all the extra stuff that comes with C++
19:55:50 <levi> Microsoft has also never updated their compiler to C99, so taking advantage of the newer developments there hampers portability to Windows. :/
19:55:56 <tabemann> note that C *can* have garbage collection, with things like the Boehm conservative collector, but due to the nature of the language garbage collection in C tends to be poorer than in languages designed for garbage collection
19:56:07 * hackagebot HandsomeSoup 0.3.2 - Work with HTML more easily in HXT  http://hackage.haskell.org/package/HandsomeSoup-0.3.2 (AdityaBhargava)
19:56:12 <tiffany> my game engine is written in C99 and has to be compiled using mingw on windows
19:56:49 <fylwind> never quite understood why MS just abadoned C for all intents and purposes
19:57:00 <fylwind> s/abadoned/abandoned/
19:57:04 <levi> Yeah. I used mingw to set up the Windows side of my C unit testing setup.
19:57:32 <Adeon> quite recently they added lots of C99 library support to the latest MSVC
19:57:36 <Adeon> last month, I think
19:57:40 <tabemann> fylwind: probably because they expected everyone to code in C++ and then .NET
19:57:54 <dmj`> and then silverlight
19:57:58 <cschneid> what's the name of the haskell doc format? -- ^ and -- | and such
19:58:03 <cschneid> I need to go google up how it works
19:58:03 <levi> silverlight is just a different .NET runtime.
19:58:10 <tabemann> haddock
19:58:41 <cschneid> tabemann: thanks :)
19:58:44 <levi> Hey, hackagebot.  That must mean hackage is back up.... Yay!
19:59:48 * zRecursive in fact there is no language which can beyond C now and future ...
19:59:48 <tabemann> good
20:00:06 <levi> zRecursive: Huh?
20:00:55 <zRecursive> i like C which made much money for me -:D
20:01:34 <tiffany> I have high hopes for rust
20:01:50 * tabemann likes even C++ better than C, honestly
20:02:34 <levi> I have made much money from C, too, but I don't see why I ought to like it.
20:03:12 <tabemann> I tend to not particularly like the languages that I get money from
20:03:38 <tabemann> (and conversely has never earned anything from the languages he has liked)
20:03:47 <tabemann> s/has/I have
20:03:50 <tabemann> s/he/I
20:04:52 <dmj`> starting to think everyone is in finance
20:05:46 <tabemann> no, I've mostly worked in aerospace and currently am working in biomedical...
20:06:32 <dmj`> that's awesome, is haskell a hard sell on the job?
20:07:25 <cschneid> who defines the (,) operator. It's hard to find since hoogle blows up on ,
20:07:30 <zRecursive> i like haskell which doensot make any money though
20:07:37 <arkeet> cschneid: it's part of ghc
20:07:39 <tabemann> I haven't managed to sell haskell to anyone at work myself
20:07:41 <arkeet> built-in
20:07:48 <cschneid> arkeet: what package? I didn't see it in prelude.
20:07:52 <dmj`> @src (,)
20:07:52 <lambdabot> Source not found. Where did you learn to type?
20:07:55 <arkeet> no, not even the prelude.
20:07:59 <arkeet> it's part of the compiler.
20:08:10 <arkeet> maybe.
20:08:13 <dmj`> zRecursive: yet...
20:08:34 <arkeet> cschneid: but you can think of it as data (,) x y = (,) x y
20:08:47 <cschneid> what
20:08:52 <arkeet> it's built-in like -> is built-in.
20:08:56 <cschneid> arkeet: sorry - what does that mean?
20:09:07 <arkeet> I don't know what else to say.
20:09:11 <arkeet> what doesn't make sense?
20:09:21 <cschneid> I'm trying to figure out these lines:
20:09:25 <cschneid> optionalArgs :: [(a, Maybe b)] -> [(a, b)]
20:09:25 <cschneid> optionalArgs = mapMaybe . uncurry $ liftM . (,)
20:09:30 <arkeet> (,) x y = (x,y)
20:09:32 <startling> arkeet: nope
20:09:40 <sleepybug> (,) is defined somewhere as a regular function I think
20:09:48 <arkeet> I'm pretty sure it isn't.
20:09:51 * tabemann 's coworkers haven't managed to wrap their brains around Haskell, aside from his coworker who is a former Haskeller who for some reason prefers to work in stuff like logic programming these days
20:10:01 <startling> arkeet, http://www.haskell.org/ghc/docs/7.0.4/html/libraries/ghc-prim-0.2.0.0/src/GHC-Tuple.html
20:10:02 <arkeet> if it was, then so would (,,), (,,,), and so on up to however many ghc supports
20:10:07 <dmj`> zRecursive: I bet if you used a haskell web framework, with stripe and some aws packages you could bring in some money...
20:10:08 <startling> arkeet: yep!
20:10:08 <arkeet> well there you go.
20:10:23 <dmj`> tabemann: like prolog?
20:10:25 <startling> arkeet: has the beautiful comment: "Manuel says: Including one more declaration gives a segmentation fault."
20:10:32 <sleepybug> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/GHC-Tuple.html
20:10:38 <tabemann> dmj`: he's using a language named eclipse (no relation to the IDE)
20:10:49 <zRecursive> dmj`: maybe in the future
20:11:01 <cschneid> ahh, it's the constructor for a 2 tuple? That's all it is?
20:11:04 <arkeet> yes.
20:11:08 <cschneid> sleepybug: thank you for finding that
20:11:13 <sleepybug> you're welcome :3
20:11:15 <dmj`> zRecursive: why not now?
20:11:16 <arkeet> [20:07:40] <arkeet> cschneid: but you can think of it as data (,) x y = (,) x y  -- this should have been enough, I suppose.
20:11:31 <cschneid> arkeet: sorry, I'm noobish enough that was hard to parse :)
20:11:42 <zRecursive> dmj`: no such a project
20:11:48 <cschneid> I do see what you said now though
20:12:17 <joelteon> ok, so this is weird. FOO=bar; ghci; the environment variable "FOO" doesn't exist
20:12:21 <joelteon> but FOO=bar ghci; it does
20:12:21 <dmj`> tabemann: that's quite a website, http://eclipseclp.org/index.html
20:12:35 <joelteon> is this a POSIX question or a haskell question?
20:12:38 <joelteon> I can't tell
20:12:54 <ion> joelteon: FOO=bar command by definition exports FOO to the command, “FOO=bar” doesn’t export FOO to commands you run later. “export FOO=bar”.
20:13:01 <arkeet> joefiorini: that's a shell question.
20:13:03 <arkeet> and yes, export.
20:13:12 <arkeet> (assuming bash or similar)
20:13:20 <arkeet> sorry, I meant joelteon
20:13:24 <joelteon> oh, export.
20:13:32 <joelteon> of course, why did I forget that X(
20:15:32 <nerrz> I have a question with the system function in System.Process. For project euler, I made a function that will open up a given problem's source in emacs, however, when I have the emacs window open, and then run a problem, if I need to use ^c to stop the evaluation, it closes the emacs window, this happened when I tried to use forkIO too.
20:16:11 <arkeet> nerrz: does that happen with other programs? this sounds like an emacs question.
20:16:33 <arkeet> I mean, other programs running in emacs.
20:17:12 <nerrz> the program isn't running in emacs
20:17:27 <arkeet> oh.
20:17:31 <arkeet> I get it.
20:17:37 <nerrz> like, I run ghci in a terminal to open a new window
20:18:11 <arkeet> ghci opens a new window?
20:19:25 <nerrz> well, for example, if I call open_problem 1 it will open the source for problem 1 in a new emacs window, so that I can still use ghci to then open new problems or evaluate them
20:19:51 <nerrz> and open_problem calls system, like system "emacs problem_1"
20:20:01 <arkeet> I see.
20:20:53 <nerrz> is there a way to split the system evaluation, since what I think is happening is it is never returning and is waiting for the exit code from the system call
20:21:04 <nerrz> since forkIO didn't seem to do that
20:21:24 <arkeet> forkIO doesn't actually make another OS thread.
20:21:32 <nerrz> does forkProcess?
20:21:33 <luser0> Is there a best practice for combining Haskell and Ruby?
20:21:38 <ReinH> edwardk: oh cool
20:21:47 <edwardk> ReinH: almost done
20:21:50 <arkeet> forkOS might.
20:21:55 <edwardk> tying up some connections to the bazaar comonad and lens
20:22:00 <arkeet> hmm.
20:22:08 * arkeet is confused.
20:22:21 <nerrz> arkeet: what module is that from?
20:22:23 <ReinH> the... bazaar comonad?
20:22:30 <arkeet> @hoogle forkOS
20:22:30 <lambdabot> Control.Concurrent forkOS :: IO () -> IO ThreadId
20:22:54 <arkeet> ReinH: store : lens :: bazaar : traversal
20:22:59 <levi> luser0: Probably the closest thing to a 'best practice' for that is "don't do it", but you could always have them communicate via file, socket, FIFO, etc.
20:23:08 <ReinH> arkeet: huh
20:23:36 <luser0> levi, there are no packages built with such message paradigm?
20:23:40 <arkeet> ReinH: do you know the store comonad?
20:23:54 <arkeet> aka context
20:24:03 <ReinH> arkeet: Store (s -> a) a
20:24:05 <ReinH> er
20:24:06 <arkeet> yes
20:24:07 <ReinH> (s -> a) s
20:24:10 <arkeet> yes
20:24:13 <ReinH> yes
20:24:25 <arkeet> Bazaar is like that, except instead of one a, it's zero or more a's. or something.
20:24:36 <ReinH> huh
20:24:40 <ReinH> I get it
20:24:46 <ReinH> a Bazaar holds many stores
20:24:47 <ReinH> clever
20:24:49 <luser0> I was thinking Ruby for DB manager with Haskell as a type sensitive analysis toolkit manager
20:24:49 <arkeet> =)
20:24:51 <levi> luser0: Well, there are *lots* of ways you could have two languages communicate, and both languages support many of them.  It probably depends on what other infrastructure you've got in place.
20:24:58 <arkeet> I might have just said something completely wrong, anyway.
20:25:24 <luser0> Haskell seems a better choice than Python, the default, if you will
20:25:56 <levi> luser0: Why not Haskell for both?
20:26:05 <nerrz> arkeet: I just tried the forkOS, same behavior
20:26:10 <arkeet> I thought so.
20:26:11 <arkeet> wait.
20:26:19 <arkeet> what behavior exactly do you mean?
20:26:27 <luser0> because Ruby is already well integrated for DB management against many architectures
20:26:31 <arkeet> something like  forkIO (system ...)  ?
20:26:36 <arkeet> what happens?
20:26:36 <nerrz> yes
20:26:57 <ReinH> luser0: there is no standardized communication protocol, you have to choose the best one for your application
20:26:59 <nerrz> well, it opens the window, but then if I call another function that hangs, then if I use ^C it will close the window too
20:27:12 <levi> luser0: What kind of 'DB management' are we talking about?  Haskell can interface to many databases as well.
20:27:45 <nerrz> and with PE I am often going back and forth from the code to ghci a lot until I get the problem sorted out
20:27:47 <luser0> corporate financial management
20:28:14 <luser0> not, like weather station data
20:28:52 <arkeet> nerrz: ahh right.
20:28:56 <arkeet> system is supposed to behave that way.
20:29:01 <nerrz> really?
20:29:02 <dmj`> luser0: with lots of concurrent users?
20:29:04 <arkeet> SIGINT is passed down to the child process.
20:29:16 <arkeet> according to the source.
20:29:29 <levi> luser0: Ruby just seems like a terrible choice for back-end stuff.
20:29:29 <luser0> dmj, that is humor? I did say "Ruby," right?
20:29:51 <nerrz> but I thought forkProccess would fix that... maybe there is another way to open the window?
20:29:59 <ReinH> edwardk: and ofc the example is s sierpinksi triangle https://github.com/byorgey/diagrams-canvas/blob/master/example/Sierpinski.hs
20:30:04 <arkeet> nerrz: try something like runProcess maybe?
20:30:16 <arkeet> or createProcess
20:30:29 <nerrz> from System.Process right?
20:30:29 <levi> luser0: Or do you mean that you have some sort of CRUD app written in Ruby that interfaces with the big database?
20:30:31 <arkeet> yes
20:30:34 <luser0> back end stuff with or without a pine implementation?
20:30:40 <ReinH> pretty clever impl though
20:30:50 <luser0> there you go, levi, on the money
20:31:47 <nerrz> still sends the stop to the window
20:32:02 <ReinH> luser0: are you being obtuse on purpose?
20:32:22 <ReinH> why not just say you have a rails app (or sinatra, or w/e)
20:32:31 <arkeet> nerrz: well, I don't know.
20:32:36 <luser0> obtuse, by referring to pine? perhaps I should mention some politicians, instead?
20:32:53 <levi> luser0: Well, you could easily set up a haskell-based web service that your Ruby app could interface with.
20:33:15 <ReinH> luser0: referring to how difficult it is to get you to tell us what you're doing and what you want
20:33:32 <dmj`> luser0: If you don't have concurrent users you could just encode and compress data structures to disk, better than trying to save a binary tree in a RDBMS. I don't know your needs though.
20:33:48 <nerrz> arkeet: thank you for the help
20:33:56 <luser0> what would be the recommended ISO format for the web based interface to Haskell?
20:34:01 <levi> luser0: There are great haskell JSON and XML libraries, and I imagine Ruby has good support for both of those as well.
20:34:13 <ReinH> luser0: recommended ISO format for the web based interface to Haskell? What does that even mean?
20:34:28 <luser0> yes, JSON and XML are both well supported in Rails
20:34:30 * lispy isn't sure how to format isomorphisms
20:34:33 <ReinH> pick a common mime type that's suitable for your purposes
20:34:41 <luser0> 1874?
20:34:50 <ReinH> wow
20:34:52 <luser0> or, is that obtuse in your world?
20:35:03 <ReinH> ...
20:35:14 <ReinH> any particular reason you want to come here and troll people?
20:35:17 <edwardk> ReinH: ok. its ready to go.. and the moment it is their server stopped working. giving it a minute to see if its some process rebuilding stackage or something =)
20:35:24 <ReinH> heh
20:35:26 <ReinH> edwardk: awesome
20:35:40 <edwardk> johnw:
20:35:40 <edwardk> <command line>: cannot satisfy -package ide-backend-rts
20:35:42 <edwardk>     (use -v for more information)
20:35:52 <luser0> I didn't make the obtuse reference to MS trolling with back end, you did
20:35:53 <edwardk> johnw: doesn't sound like its something i'm doing =)
20:36:02 <lispy> edwardk: is stackage still around?
20:36:08 <ReinH> luser0: what obtuse reference to MS? What are you even talking about?
20:36:37 <luser0> reinh, no one knows how to use office back end except for you
20:36:41 <luser0> it alright
20:36:47 <ReinH> luser0: what the hell are you talking about?
20:36:48 <luser0> don't get all worked up now
20:37:04 <elliott> I don't know what this is about but -- okay.
20:37:08 <dmj`> wow
20:37:42 <ReinH> I don't even
20:37:52 <lispy> edwardk: hackage down probably down earlier. The galois internet had some issue and I think we're still hosting hackage
20:38:26 <edwardk> lispy: i still get requests from snoyman to fix things, so i'd say yes
20:39:53 <ReinH> dmj`: Most trolls are a little easier to spot so... good job, I guess?
20:40:18 <ReinH> edwardk: can I see teh codeze?
20:40:27 <dmj`> ReinH: you handled it well, he lost me at ISO and 1874 tho
20:40:36 <levi> ISO 1874 is "a system of designation for polyamide (PA) thermoplastic materials"
20:40:37 <edwardk> sure
20:40:56 <levi> Probably not what he meant. :)
20:41:00 <ReinH> levi: what's the mime type for that?
20:41:02 <elliott> I assumed it was RFC 1874. but, I shouldn't contribute; if you think they were a troll why feed them from beyond the grave?
20:41:21 <ReinH> .. SGML?
20:41:31 <ReinH> I mean... I guess?
20:41:38 <edwardk> ReinH: https://gist.github.com/ekmett/d91edee0828d2c37aa8e
20:41:43 <ReinH> woo
20:41:54 <nerrz> arkeet: even forkProcess and then using createSession didn't work, idk
20:42:03 <edwardk> ReinH: you probably want to view raw on that
20:42:20 <ReinH> yeah SoH's markdown and github's don't play nice together
20:42:52 <edwardk> when you click run on the automaton at the end it'll generate the svg and show it to you on the site (when the site is working)
20:42:52 <arkeet> nerrz: it's not killing ghci though, right?
20:43:00 <edwardk> as soon as it is back operational i'll post
20:43:00 <nerrz> no
20:43:13 <nerrz> just interupting
20:43:15 <ReinH> edwardk: svg now but canvas later?
20:43:15 <edwardk> woot looks like its back
20:43:29 <edwardk> possibly canvas. byorgey is working on speeding up both
20:43:42 <ReinH> nice!
20:43:42 <nerrz> I assumed if it was it's own process that it would not get cancelled since it was split from ghc at that point
20:45:41 <drayevarg> does ++ not work with tuples? i'm very early in a tutorial, and noticed i can do ++ with a regular list
20:45:57 <levi> drayevarg: A tuple is very different from a list
20:46:00 <lispy> drayevarg: right
20:46:09 <lispy> > (1,2) ++ 3
20:46:10 <lambdabot>   Couldn't match expected type `[a0]' with actual type `(t0, t1)'
20:46:11 <flazz> for "flip (.)" (scala cals it andThen), is this idiomatic in haskell?
20:46:12 <edwardk> https://www.fpcomplete.com/user/edwardk/cellular-automata
20:46:12 <ReinH> edwardk: you know what we should do next?
20:46:44 <ReinH> "His version was much prettier." lmao
20:46:57 <drayevarg> k, thanks guys, just making sure it wasn't inputting something wrong
20:47:41 <lispy> > let a .++. b = (a,b) in 1 .++. (2 .++. (3,()))
20:47:41 <lambdabot>   (1,(2,(3,())))
20:47:48 <lispy> drayevarg: you could do that ^^
20:48:00 <levi> lispy: I think that is just going to be more confusing.
20:48:30 <lispy> drayevarg: and that's essentially how lisp represents a list. little boxes with a car and cdr
20:49:09 <lispy> levi: perhaps. Being confused once in a while is good though :)
20:49:31 <levi> lispy: Newcomers to haskell tend to be plenty confused already!
20:49:54 <drayevarg> yeah, i'm confused, but haskell in some ways seems more readable than c
20:49:55 <bscarlet> lispy: it doesn't help that (++) is append and your (.++.) is cons.
20:50:01 <lispy> "How did I get here? What is this language? Lazy? Pure? How do I back to C/Java/Python/Ruby/..."
20:50:14 <ReinH> edwardk: can you explain the memoization a bit more please?
20:50:49 <lispy> bscarlet: true
20:51:06 <edwardk> ReinH: a value of type Memo a = forall r. (a -> r) -> a -> r  turns a function into a function that memoizes its results
20:51:20 <edwardk> rather it describes a memoization strategy
20:51:34 <edwardk> i'll add another paragraph in there on it
20:51:45 <levi> drayevarg: A tuple (1, 2) and a tuple (1, (2, 3)) are completely separate types in Haskell, while the lists [1, 2] and [1, 2, 3] are the same type.
20:52:06 <ReinH> levi: er...
20:52:38 <arkeet> lispy: that's also essentially how haskell represents a list!
20:52:40 <ReinH> edwardk: so you're memoizing the application of the rule?
20:52:48 <arkeet> (1:(2:(3:[])))
20:53:13 <lispy> :t let a .++. b = (a,b) in (.++.)
20:53:13 <lambdabot> t -> t1 -> (t, t1)
20:53:20 <lispy> :t (:)
20:53:20 <lambdabot> a -> [a] -> [a]
20:53:36 <lispy> arkeet: the types are fairly different though. And in more ways than just tuple vs. list
20:53:55 <arkeet> lisp has no types
20:53:56 <arkeet> !!
20:54:21 <levi> arkeet: We're in #haskell
20:54:28 <edwardk> ReinH: tab transforms a Store into a Store that memoizes the results for each position
20:54:33 <lispy> in particular, even if wanted to say t1 ~ [a], you'd still have the part where (t, t1) !~ [a]
20:54:36 <arkeet> levi: I'm a burrito.
20:54:43 <edwardk> ReinH: that way i can stick to the simple store
20:54:45 <johnw> edwardk: hmm?
20:54:55 <arkeet> lispy: well that's fine, we can just use Fix (t,)
20:55:05 <arkeet> except throw in a ()
20:55:10 <arkeet> but wait, that's []
20:55:12 <arkeet> !
20:55:21 <lispy> using tuples for lists (even in haskell) would allow for dotted pairs
20:55:29 <lispy> but [a] has no dotted pairs
20:55:45 <levi> WTF, guys?  Not helpful.
20:56:14 <edwardk> johnw: its back now
20:56:18 <edwardk> https://www.fpcomplete.com/user/edwardk/cellular-automata
20:56:28 <edwardk> johnw: but it was complaining for ~10 minutes
20:56:36 <johnw> what was the complaint?
20:56:38 <lispy> levi: sorry, did you have a question?
20:56:42 <ReinH> edwardk: right and integral gives you a Memo a for integral types
20:56:56 <levi> lispy: No, but drayevarg did.
20:56:59 <edwardk> johnw it should be the couple of lines after i pinged you
20:57:04 <edwardk> ReinH: yep
20:57:24 <johnw> ah, I just fixed that bug two days ago actually
20:57:29 <johnw> it should get deployed shortly
20:58:24 <ReinH> edwardk: now we need to make a small world automata
20:59:43 <edwardk> ReinH: i figured doing small worlds, 2 or 3-dimensions, etc. could be a topic for later
21:00:03 <ReinH> ok
21:00:10 <ReinH> later we need to make a small world automata
21:00:17 <edwardk> i mostly wanted to sell people the store comonad, show that you can use diagrams on the site easily to make pretty pictures and showcase that in 60 lines of haskell give or take i can do all of that
21:00:41 <ReinH> yep!
21:00:41 <ReinH> pretty awesome
21:00:58 <ReinH> and only 60 because you defined your own Store
21:02:39 <ReinH> edwardk: I'd also be interested in other performance optimizations. Does it still leak space, for isntance?
21:02:52 <edwardk> no space leaks
21:02:56 <ReinH> nice
21:03:00 <ReinH> I need to mess with it
21:03:04 <ReinH> this is great :)
21:03:19 <edwardk> yeah it'd be < 40 or so if i dropped th store
21:03:45 <edwardk> and it could shrink if i dropped the 'go through the double list of bools' logic too
21:06:23 <lispy> my that's a lovely sierpinski triangle you have there; it would be a shame if something happened to it
21:06:23 <levi> edwardk: This bit looks like it's missing a word: "produce a value of type a, where have some ambient current configuration"
21:06:45 <ReinH> lispy: lmao
21:07:42 <edwardk> updated
21:07:48 <ReinH> edwardk: maybe fmap f here:  0 & partsOf (taking 3 bits) .~ [f (s+1), f s, f (s-1)]
21:09:24 <edwardk> ?
21:09:34 <edwardk> oh
21:09:42 <ReinH> [(s+1), s, (s-1)] <&> f
21:09:47 <edwardk> hrmm
21:09:54 <ReinH> you could extract the s out too somehow
21:10:49 <edwardk> its technically shorter but it gets in the way of comprehension
21:10:52 <ReinH> not sure if there's much point to that
21:10:53 <ReinH> sure
21:11:12 <ReinH> I just know how much you love your operators...
21:11:48 <edwardk> heh
21:11:54 <edwardk> i like them when they aid comprehension =)
21:11:58 <ReinH> :D
21:12:12 <edwardk> here doing complicated stuff on the rhs of .~ would be more scary than useful
21:12:15 <jmcarthur> what is <&>?
21:12:20 <edwardk> flip fmap
21:12:24 <jmcarthur> ah
21:12:30 <edwardk> its used a lot in lens
21:12:34 <edwardk> also it has the wrong fixity there
21:12:38 <edwardk> so it wouldn't work
21:12:38 <ReinH> & is flip $, <&> is flip <$> :)
21:12:42 <ReinH> edwardk: ok :D
21:12:58 <ReinH> there is SOME method to his madness
21:13:12 <edwardk> we us <&> a lot bcause it means the function that is usually taking the lambda is the second arg. so its much nicer for writing lenses with since the function you are mapping is often way bigger than what you are mapping over
21:13:33 <edwardk> _1 f (a,b) = f a <&> \a' -> (a', b)
21:13:40 <edwardk> avoids the parens you need with (<$>)
21:13:52 <arkeet> :t (<&>)
21:13:52 <lambdabot> Functor f => f a -> (a -> b) -> f b
21:13:59 <jmcarthur> i tend to use forM_ a lot, but i can't think of many cases where i wanted flip fmap
21:14:09 <edwardk> think (<$>)
21:14:14 <edwardk> if you need to use a lambda
21:14:22 <edwardk> this will almost always be less verbose
21:14:28 <jmcarthur> ah, a lambda
21:14:59 <jmcarthur> yeah, i use forM_ with do notation a lot, so i guess (<&>) with a lambda is comparable
21:15:14 <ReinH> jmcarthur: or if you need to make some use of every conceivable operator ;)
21:15:32 <ReinH> I mean, what kind of self respecting Haskeller would define <&&> but not <&>?
21:16:12 <ReinH> I think <<$>> should be fmap <$> fmap
21:16:33 <edwardk> thats just fmap . fmap
21:16:35 <ReinH> (+1) <<$>> [[1,2,3]], replace .:, etc
21:16:37 <edwardk> or fmap fmap fmap
21:16:38 <ReinH> edwardk: I know
21:16:57 <ReinH> I just wanted to use <$>
21:17:12 <ReinH> I was tempted to (<$>)<$>(<$>)
21:17:28 <edwardk> every time i say fmap fmap fmap during a lens talk i get a giggle from someone in the audience
21:17:35 <ReinH> edwardk: or fmap `fmap` fmap!
21:17:42 <ReinH> so many options
21:18:21 <ReinH> now, is flip fmap fmap fmap a useful thing?
21:20:44 <ReinH> no, but it might make for some fun obfuscated haskell
21:22:43 <haasn> :t fmap & fmap ?? fmap
21:22:44 <lambdabot> (Functor f, Functor f1) => (((a1 -> b1) -> f1 a1 -> f1 b1) -> a -> b) -> f a -> f b
21:22:47 <tabemann> an obfuscated haskell contest would be too easy
21:22:51 <haasn> oh, bad precedence
21:22:53 <haasn> :t fmap ?? fmap $ fmap
21:22:54 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
21:23:14 <ReinH> oh god
21:23:36 <thetallguy> "where have some ambient current configuration that is known we could run the experiment with."
21:24:03 <thetallguy> I don't think I understand what that means
21:24:25 <levi> thetallguy: Refresh, he's fixed it.
21:24:33 <thetallguy> It means the Store has an s to apply f to.
21:24:39 <ReinH> haasn:  pure $ join (<$>)<$>(flip <&>)
21:25:08 <thetallguy> noone else could read it either
21:25:33 <thetallguy> as usual, as soon as I paste it, I understand it two seconds later
21:25:37 <tabemann> question
21:25:48 <thetallguy> levi: thx
21:25:53 <tabemann> I'm running my code with +RTS -N4, but it looks like it's actually running on all 6 cores
21:26:18 <fylwind> maybe it's the GC?
21:26:52 <tabemann> my code shouldn't be too allocation or IO-heavy...
21:26:53 <johnw> tabemann: what makes you think that?
21:27:06 <tabemann> johnw: I've got gkrellm open
21:27:25 <tabemann> the only thing I can think of is that the OS is switching the OS threads around between cores very fast
21:28:01 <tabemann> as if it wasn't four cores should be solid 99-100% CPU usage
21:28:13 <tabemann> where they're more like 70% for each of all six cores
21:28:32 <johnw> 420%?
21:29:29 <tabemann> about
21:29:49 <johnw> well, i think threadscope would be the real way to tell
21:30:19 <tabemann> installing it now
21:31:04 <cschneid> what should I use for database access? I see postgres.simple, and hdbc, and perhaps other options?
21:31:29 <tabemann> interesting - the gtk2hs packages weren't smart enough to make cabal install gtk2hs-buildtools on their own
21:31:30 <johnw> i prefer persistent and equeleto
21:31:33 <tabemann> rather I have to manually install it
21:32:28 <cschneid> johnw: thanks
21:35:50 <tabemann> crap
21:36:13 <tabemann> can't install threadscope, because the cairo package needs cairo-pdf, which it seems my cairo on my system here is not installed with
21:36:49 <johnw> :(
21:37:55 <tabemann> this also means that I can't install GTK+ apps written in Haskell, as those depend on gtk2hs, which depends on cairo...
21:38:56 <lispy> the plight of the haskeller
21:39:07 <lispy> gtk/cairo/blah too hard to install
21:39:09 <tabemann> I can't just manually reinstall cairo without using Debian packages, as that would break so many things
21:39:17 * lispy nods
21:39:22 <lispy> it's frustrating
21:39:48 <haasn> sounds like an upstream issue. Have you contacted the debian devs?
21:40:20 <tabemann> what the writers of the cairo package should have done is detected *ahead* of time what was present, and use CPP and #ifdefs to replace unimplemented functionality with error calls
21:40:37 <tabemann> haasn: Debian is known for being glacially slow about these kinds of things
21:42:40 <ClaudiusMaximus> tabemann: haskell cairo bindings indeed has a flag for pdf support (default enabled), so you could maybe try  cabal install cairo -f-cairo_pdf
21:45:58 <tabemann> okay this is interesting
21:46:16 <tabemann> it's wanting cairo >= 1.2.0 installed, but I've got cairo *2* installed
21:46:35 <tabemann> and from looking in Debian packages, there doesn't seem to be any package for cairo 1
21:48:25 <ClaudiusMaximus> tabemann: the 2 is the debian cairo libaray abi version, not the version of cairo itself
21:49:08 <tabemann> the debian package itself is saying version 1.12.14-4
21:49:42 <ClaudiusMaximus> right, same as here
21:49:43 <shachaf> dmj`: ?
21:51:12 <dmj`> shachaf: still giving haskell lessons?
21:51:19 <shachaf> On what?
21:52:03 <zq> !haskell ascii table
21:53:11 <dmj`> shachaf: maybe stuff on monoids or equational reasoning
21:53:21 <shachaf> Any context for asking me?
21:53:45 <danharaj> you understand lens therefore you have something to teach
21:54:48 <dmj`> shachaf: you quizzed me a while ago and I want to see how I'm progressing, plus you're quite knowledgeable on the subject it seems
21:55:08 <shachaf> i mean, i do love monoids -- they are so easy, after all -- but how did my name come up?
21:55:10 <haasn> I'm sure shachaf has a lot to share about monoids
21:55:15 <dmj`> shachaf: plus a lot of the questions asked before I found on ekmett's lens derivation page: https://github.com/ekmett/lens/wiki/Derivation
21:55:15 <shachaf> Oh.
21:55:32 <shachaf> Well, I recommend asking the channel, for the most part.
21:56:41 <tabemann> hah
21:56:43 <tabemann> that was it
21:56:46 <tabemann> libcairo2-dev
21:57:22 <tabemann> (why must debian split out development stuff for everything)
21:57:53 <startling> I hate that too.
21:57:59 <danharaj> because debian hates the only reason to use linux
21:58:09 * danharaj half-tongue-in-cheek
21:58:19 <kwos> tabemann: why are you still using debian?
21:58:19 <kwos> :D
21:59:15 <tabemann> kwos: because I don't like red hat (or centos) or ubuntu either
21:59:34 <tabemann> ubuntu was at one time sort of a "better debian", before they started pulling shit like unity and wayland
21:59:50 <monochrom> I use unity happily
22:00:10 <ion> I like unity a lot.
22:00:16 <tabemann> I really don't like desktop environments myself; I'm quite happy with fluxbox
22:00:18 <johnw> -blah
22:01:00 <levi> xmonad ftw, though I don't mind unity and gnome3.
22:06:08 <danharaj> edwardk: you're never going to get a patch from me if you solve my complaints my the end of the work week :3
22:06:15 <danharaj> s/my/by
22:06:21 <edwardk> danharaj: oh?
22:06:25 <edwardk> which one did i solve?
22:06:33 <danharaj> someone fixed Tagged on GHC HEAD
22:08:03 <danharaj> edwardk: would you happen to know why my GHC HEAD didn't build profiling libraries for base :(
22:08:08 <edwardk> ah
22:08:14 <edwardk> no idea
22:09:10 <danharaj> all I want to do is play with closed type families
22:09:19 <danharaj> and this is what I have to put up with :p
22:09:29 <tabemann> how do you use threadscope?
22:09:41 <danharaj> tabemann: you have to compile with event logging and then run with -n
22:09:44 <danharaj> -s**
22:09:48 <danharaj> that is, -s
22:09:54 * danharaj it is too late
22:09:58 <tabemann> how do you compile with event logging?
22:10:04 <tabemann> -rtsopts?
22:10:28 <danharaj> have you read this
22:10:28 <danharaj> http://www.haskell.org/haskellwiki/ThreadScope
22:10:43 <tabemann> no
22:10:48 <danharaj> well then :P
22:11:43 <lightquake> what's a good library for 'I just want to draw a pretty picture on the screen'?
22:11:58 <danharaj> gloss
22:12:00 <danharaj> diagrams
22:13:25 <elliott> vacuum-cairo
22:13:57 <sclv> curses
22:14:57 <danharaj> they said pretty picture
22:15:24 * sclv thinks ascii art is pretty
22:15:45 <danharaj> maybe libtcod ascii art
22:18:41 <dmwit> tikz :3
22:19:57 <chirpsalot> dmwit: tikz is so awesome. Is there stuff to work with it in Haskell, though? :P
22:20:11 <tabemann> holy crap that made a huge event log
22:21:06 <Ralith> chirpsalot: it's quite useful for writing papers about haskell, certainly ^^
22:21:07 <dmwit> I think there's plans to have a pgf backend to diagrams?
22:21:08 <dmwit> not sure
22:21:17 <Ralith> interesting
22:22:15 <chirpsalot> Cool :). I wish I was better at tikz, but I don't use it enough. :|
22:28:47 <tabemann> I really feel like I should have invested in 16 GB or even 32 GB of RAM right now...
22:29:18 <fylwind> how do you use that much RAM?
22:29:31 <Rarrikins> Browser tabs.
22:29:34 <chirpsalot> fylwind: operating system caches.
22:30:10 <johnw>  VMs eat it up fast
22:30:16 <pikhq> As does GCC.
22:30:18 <chirpsalot> Disk accesses aren't nearly as cheap as RAM.
22:31:00 <haasn> chirpsalot: there's a working tikz/latex backend to diagrams
22:31:42 <haasn> you can just embed normal diagrams code in your latex files and have them render out automagically, it's pretty awesome
22:31:47 <tabemann> fylwind: threadscope on my machine has been eating up an astronomical amount of RAM (and swap), very fast
22:31:49 <chirpsalot> haasn: oh cool! So you can use diagrams to spit out something you can easily embed in LaTeX with TiKz? That's awesome!
22:31:56 <haasn> chirpsalot: even better :)
22:32:12 <tabemann> browser tabs also eat up lots of RAM, but they are only eating about 2.5 GB right now, as I recently restarted Firefox
22:32:22 <chirpsalot> haasn: actually, this makes me sad because I think I have never managed to get diagrams installed.
22:32:25 <tabemann> 40 seconds of event logging was obviously way too much...
22:32:43 <haasn> chirpsalot: well worth it. you don't need all of diagrams, the core should install with pretty much hardly any dependencies
22:32:49 <chirpsalot> haasn: because of cairo stuff and cabal yelling at me... I.e., what tabemann is going through right now I think :|.
22:32:56 <haasn> and you can pull in backends depending on your environment and needs; diagrams-svg should be fairly independent iirc
22:33:02 <haasn> it's daigrams-cairo most people have problems with
22:33:19 <chirpsalot> haasn: wait...
22:33:41 <chirpsalot> I have diagrams installed.
22:33:44 <chirpsalot> Brilliance!
22:34:39 <chirpsalot> haasn: thanks, though :). That's very awesome -- definitely worth looking into. I'm a newbie to Haskell and the like still, but yeah.
22:35:47 <chirpsalot> haasn: oh, is it this: http://www.haskell.org/haskellwiki/Diagrams/Projects#LaTeX.2FTikZ ?
22:35:58 <haasn> most likely
22:36:41 <tabemann> okay, I do event logging for *ten* seconds, and threadscope still eats *all* of the RAM on my system
22:36:50 <chirpsalot> Ah. Boo, dormant :(.
22:37:04 <chirpsalot> tabemann: swap?
22:37:13 <haasn> hmm the examples on that repo don't showcase what I was remembering
22:37:57 <tabemann> chirpsalot: it's eaten 6 GB of that too
22:38:00 <chirpsalot> haasn: well if you remember that it was something else let me know, please :). I should always be on IRC.
22:38:22 <chirpsalot> tabemann: how much swap do you have :P?
22:38:40 <chirpsalot> Also how much RAM? 4GB?
22:39:27 <tabemann> chirpsalot: 16 GB swap, 8 GB RAM
22:39:59 <hpaste> haasn pasted “#diagrams log re: latex” at http://lpaste.net/91910
22:40:00 <haasn> chirpsalot: ^
22:40:03 <chirpsalot> tabemann: well hopefully you don't run out :).
22:40:46 <chirpsalot> haasn: thanks! Also it was charts (https://github.com/timbod7/haskell-chart/wiki) that I was having problems installing, not diagrams. Whoops. Long time ago.
22:59:31 <kwos> I wish haskell had strictness annotations at type level
22:59:41 <kwos> e.g. f :: !Int -> Int
23:00:03 <kwos> so you don't have to know that (say) f !x = x + 1
23:00:44 * kwos wonders how much work would this be and what other people think about this idea
23:04:51 <dmwit> I'm not sure if that makes sense.
23:05:08 <dmwit> Maybe you could have two kinds of (->), though.
23:05:25 <Ralith> but would they unify with eachother?
23:05:40 <dmwit> Let's say "no" and see where that gets us.
23:08:17 <kwos> dmwit: but you can already do data X = X !Int
23:08:43 <shachaf> That means something different, though.
23:09:04 <shachaf> Even the GADT syntax is justified for a different reason.
23:09:34 <kwos> shachaf: why is it different?
23:10:05 <shachaf> Are you suggesting that it would be a different type, or the same type and just a different way to present BangPatterns to the compiler?
23:10:16 <kwos> the latter
23:10:22 <elliott> you can write
23:10:27 <elliott> f :: Int -> Int
23:10:30 <elliott> f !x | False = undefined
23:10:34 <elliott> f ...
23:10:49 <kwos> elliott: yeah but it's not obvious from looking at f's type whether it has some additional strictness
23:10:57 <shachaf> Oh, then I'd say that the information doesn't belong in the type.
23:11:51 <kwos> shachaf: agree, but I think it would be useful if it was there :)
23:12:16 <shachaf> If it's actually part of the type, yes. But you're proposing that it not be.
23:12:38 <kwos> I like the idea that :t plus a sensible function name tells me almost everything I need to know
23:12:42 <shachaf> In ScopedTypeVariables's case it's somewhat justified, but not here.
23:12:59 <shachaf> But you just said it's the same type!
23:14:05 <kwos> shachaf: treating it as a different type would be very inconvenient
23:14:33 <shachaf> Right. It would also be impossible, if you wanted to be precise about strictness.
23:14:33 <mgsloan> Could add documentation to the type like this (as far as I know, noone actually does this, but it's an interesting idea): https://groups.google.com/d/msg/haskell-cafe/nl2Zrrg-Xfs/g4aG85JS01cJ
23:18:23 <kwos> but say you have new type StrictInt = SI { unSI :: !Int } and then f !Int -> Int be equivalent to unSI . f . SI
23:18:57 <elliott> StrictInt doesn't make any sense.
23:19:05 <elliott> even if you fix it to be e.g. data.
23:19:11 <elliott> it'll just be isomorphic to Int, including _|_
23:21:07 <dmwit> shachaf: Yes, we'll have to drop precision. !-> means definitely strict; -> means the same thing it does now
23:22:37 <startling> How would I compile the hash of the HEAD commit into a executable (for e.g. --version)? It doesn't look like using setEnv in Setup.hs and CPP in the executable's source works.
23:23:19 <dmwit> startling: Step one: conspire to create a hash collision with today's date...
23:24:10 <startling> :/
23:28:27 <Polarina> Hello.
23:37:03 <bicgena> how would you solve this? http://community.topcoder.com/stat?c=problem_statement&pm=12419&rd=15697
23:37:08 <bicgena> in haskell
23:42:23 <dmwit> I feel like the hard part of this puzzle is language-agnostic.
23:50:16 <Taneb> edwardk, your CA FP post, how fast is the last example when using the Cairo backend?
23:50:22 <bicgena> dmwit: yea
23:50:34 <edwardk> Taneb: dunno. can't run it there without writing it to a file
23:50:47 <edwardk> you may be able to read/write files on the server there, i just haven't tried
23:51:12 <edwardk> nicely, its interactive and you have all the code there, so if you want to tweak it to try out cairo you can try it
23:51:31 <edwardk> in theory you might be able to replace the sendResponse with generating to a file and then using sendFile
23:51:40 <mgsloan> Yup, you can write a file!
23:51:59 <mgsloan> (just no cairo currently)
23:52:03 <edwardk> then once it works shoot me an email and i can incorporate it as an alternate url ;)
23:52:31 <mgsloan> :D
23:53:01 <johnw> edwardk: yes, you can write files there
23:53:37 <edwardk> johnw: you guys need to support diagrams-cairo/cairo ten =)
23:53:38 <edwardk> er then
23:53:57 <edwardk> that example would be much sexier as a png!
23:54:10 <johnw> i have no objection to that, create an issue against  stackage?
23:57:10 <edwardk> johnw: done
23:57:48 <edwardk> johnw: i have to admit i was very happy when i finally got that example to work and managed to cut the line count way down
23:58:09 <johnw> nice job
23:58:36 <edwardk> i figured it was a bit less terrifying than the matrix multiplication stuff
23:59:00 <edwardk> and i wanted to have an example of how to render diagrams with SoH on your site somewhere
23:59:37 <johnw> that's very cool actually :)
23:59:48 <johnw> I'll mention this to snoyberg at our next meeting
