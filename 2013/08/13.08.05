00:11:58 <lesur> I'm looking at the code for LambdaHack right now, hoping to get a better understanding of how a Haskell program is constructed. What I've noticed is a large amount of do blocks. How much of code do, do blocks occupy normally?
00:12:43 <Cale> lesur: depends on the code
00:12:44 <slack1256> depends of the code, but remember that do block are just syntax sugar
00:12:55 <c_wraith> lesur: it's impossible to say.  More usefully, though, if file size is a problem, it's probably the GHC runtime
00:13:34 <Cale> wat
00:14:02 <c_wraith> oh, I totally misread the question
00:14:16 <c_wraith> I thought it was asking how much code they generate
00:14:42 <ezrios> Is it bad form to use both do notation and (>>=)?
00:14:52 <johnw> no
00:15:02 <slack1256> @quote code base
00:15:02 <lambdabot> No quotes for this person. :(
00:15:07 <slack1256> @quote carmack
00:15:07 <lambdabot> carmack says: Everything that is syntactically legal that the compiler will accept will eventually wind up in your codebase.
00:15:12 <Cale> Though if you combine the two, you might want to consider using =<<
00:15:16 <ezrios> I have something like x <- getLine >>= return . read
00:15:26 <johnw> read <$> getLine
00:15:27 <Cale> x <- fmap read getLine
00:15:28 <ezrios> and that sort of looked funny to me
00:15:33 <NihilistDandy> Oh, yeah, did you guys see Carmack's talk at Quakecon where he talked about Haskell?
00:15:41 <johnw> NihilistDandy: yes
00:15:46 <c_wraith> NihilistDandy: well, that's where that quote came from. :P
00:15:50 <piron> :t readLn
00:15:51 <lambdabot> Read a => IO a
00:15:56 <ezrios> NihilistDandy: yeah, he also mentioned teaching his son Haskell in 2012
00:16:04 <Cale> Or a smaller change would be  x <- return . read =<< getLine
00:16:07 <piron> Bonus: it throws an IO exception instead of a pure one.
00:16:09 <NihilistDandy> It was a neat talk
00:16:22 <NihilistDandy> I like hearing about it outside tweets
00:16:38 <NihilistDandy> ("it" being Carmack's experience with Haskell)
00:16:40 <ezrios> hm, I think I need to re-read applicative functors
00:16:53 <johnw> ezrios: <$> isn't Applicative, it's just Functor
00:16:55 <slack1256> everybody is wanting to play (new) wolfstein as if it were 1990 again.
00:16:59 <slack1256> just because haskell
00:17:31 <ezrios> johnw: oh, it's infix fmap ._.
00:18:30 <lesur> I cannot quite understand this. How can I write pure code, that does not have side effects if my code has to handle IO. I'm probably missing something very obvious, but how can I operate on my impure results using a a pure area in my code?
00:19:46 <piron> cannot
00:19:55 <piron> But! You can teach your pure functions how to be impure.
00:20:19 <piron> (=<<) :: (a -> IO b) -> (IO a -> IO b)
00:20:25 <piron> fmap :: (a -> b) -> (IO a -> IO b)
00:21:01 <piron> This teaches a function that takes an a (not necessarily an IO action) how to be a function that takes an IO a instead.
00:21:42 <lesur> So if an area of my code is ever going to touch IO, it has to return an IO type?
00:21:51 <piron> yes
00:22:01 <Cale> lesur: The parts of your code which do input and output will have IO types.
00:22:22 <lesur> Okay, thanks guys, that has cleared up the last bit of my haskell confusion
00:22:26 <Cale> IO actions are how you (at least at a basic level) describe input and output effects
00:23:16 <c_wraith> lesur: this approach is powerful in two ways - one, code that doesn't involve IO won't have IO anywhere in its type.  Two, you can pass IO actions around without executing them.
00:23:28 <Cale> IO actions can themselves make use of pure functions and values, and then those pure bits of the code needn't know or care about the I/O which is taking place around them.
00:23:34 <MouseTheLuckyDog> What goes in the monad sgtays in the monad.
00:24:32 <Cale> As a tiny example:  do x <- getLine; putStrLn (reverse x)  is an IO action which gets a line of text from the user, and then prints out its reverse. The reverse function is just being used at type String -> String here, and doesn't need to know that the string it's getting came from doing I/O.
00:25:37 <lesur> I thought reverse takes in [a], not IO[a]
00:25:43 <Cale> It does.
00:26:03 <Cale> x :: String in that code.
00:26:22 <lesur> So <- allows me to assign a input to a variable that I can treat as pure?
00:26:31 <Cale> x <- getLine  means "execute the action getLine, and call its result x"
00:26:45 <MouseTheLuckyDog> lesur: Take  a look at what map does. It takes a function and "lifts" it to a function in the IO space.
00:26:56 <piron> lesur: More or less, yes.
00:27:11 <Cale> It's not quite the same operation as assignment, in that x isn't a memory cell which can be updated multiple times. It's simply the name of the result of getLine here.
00:27:13 <NihilistDandy> <- basically strips the IO context from the IO String, allowing you to manipulate it as a normal String
00:27:27 <NihilistDandy> Then putStrLn wraps that String up in the IO context again
00:27:36 <Cale> please don't think of it like that
00:27:42 <NihilistDandy> Oh, okay then
00:27:46 <ezrios> lesur: you should also know how to translate between do notation and the use of (>>=) and (>>)
00:28:11 <Cale> An IO String is nothing like a String, any more than /bin/ls is like a list of files.
00:28:28 <Cale> getLine is a program which if executed, produces a String result
00:28:40 * slack1256 thinks saw that quote on weekly news
00:28:44 <lesur> Oh, so I can operate on the IO input using >>= in the do block, but nowhere else.
00:28:54 <Cale> Yeah, I'm paraphrasing shachaf
00:29:02 <MouseTheLuckyDog> So fmap of reverse takes reverse which has sig [a]->[a] and liftrs it to IO [a] -> IO[a].
00:29:10 <piron> NihilistDandy didn't claim IO String was like a String.
00:29:14 <slack1256> That should be a quote
00:29:33 <piron> ?quote shachaf ls
00:29:33 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
00:29:37 <piron> It is.
00:29:55 <slack1256> no, "I'm paraphrasing shachaf"
00:29:56 <Cale> lesur: The do-block as a whole will denote an IO action, which when executed, will execute the other IO actions that it's made up from.
00:29:56 <obility> PLEASE I NEED SOME ONW WHO CAN TEACH ME HOW TO CREAT A ZEUS
00:30:09 <ezrios> what
00:30:24 <MouseTheLuckyDog> obility: First yo take a titan ...
00:30:27 <NihilistDandy> I suppose "stripping" is a bad way to think of it. It just lets you do things inside that box
00:30:28 <piron> lesur: You can do IO without do blocks, and (>>=) need not appear in a do block.
00:30:35 <slack1256> download the Zeusmonad package
00:30:40 <Ghoul_> zeus <- getBigBoss olympus
00:30:47 <mstksg> a do block is just syntactical sugar for repeated >>='s
00:30:49 <Cale> NihilistDandy: "executing"
00:30:51 <simukis_> lol.
00:30:52 <NihilistDandy> Right
00:31:00 <lesur> A just had a revelation! Finally >>= == do clicked!
00:31:05 <mstksg> just like [1,2,3] is syntatic sugar for 1:2:3:[]
00:31:11 <Cale> Well, let's spell out that connection in detail
00:31:24 <Cale> do notation is defined recursively as follows:
00:31:31 <Cale> do { x } = x  -- base case
00:31:44 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
00:32:03 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> } -- whenever v is a variable (or unfailable pattern)
00:32:24 <mstksg> (>>) is just (>>=) but ignores the result
00:32:25 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
00:32:49 <Cale> and just for completeness,
00:32:56 <slack1256> also https://en.wikibooks.org/wiki/Haskell/do_Notation has a good desugaration.
00:33:34 <Cale> do { pat <- x ; <stmts> } = let { ok pat = do { <stmts> }; ok _ = fail "some error message" } in x >>= ok -- whenever pat is a pattern match that could fail
00:33:52 <lesur> >>= is just Monad m => m a -> (a -> m b) -> m b. This means that I can (in effect) pass an IOa into a function that takes an a, as long as I tell other code that the result is impure - IOb. In a do block, I'm doing exactly that, passing impure results into pure functions and returning an impure result.
00:34:35 <c_wraith> lesur: true, as long as you get rid of the word "impure"
00:34:51 <Cale> x >>= f constructs an IO action which will first execute the action x, capturing its result (say v), and then executes the action f v, producing the result of that action as its own.
00:34:59 <c_wraith> Almost all types that support >>= are pure regardless of viewpoint
00:35:22 <lesur> Ah, yes, of course.
00:35:45 <Cale> x >> y constructs an IO action which first executes x (ignoring its result), and then executes y, producing the result of y as the result of the whole action.
00:35:57 <mstksg> if you know about the state monad, you can think of an application of >>= as a function of the state of the world and returning a new world state
00:36:12 <Cale> So, you can view >>= as a generalisation of >> which allows you to decide which action is performed based on the result of the first action.
00:36:15 <mstksg> it's "pure" in the sense that operating on the same world state will give you the same new world state evey time
00:37:00 <Cale> I rather dislike the IO ~= State RealWorld analogy though :P
00:37:21 <mstksg> there's a bit of controversry around it but i'm not sure how else to make the case that IO is pure
00:37:39 <Cale> Executing IO actions is not pure
00:38:06 <Cale> Evaluating them (which doesn't do much that's visible) is pure, however.
00:38:22 <lesur> No, I get it, the same input with the same computer state will give the same values, but that state changes.
00:38:29 <Cale> You can picture IO actions as being like abstract syntax trees of programs describing some effects
00:38:38 <mstksg> it is pure :) if i perform the same action on the same RealWorld state, i should always get the same new state and same new answer
00:38:48 <johnw> the same computer state is almost impossible
00:38:54 <Cale> Evaluating an IO action doesn't do anything much, similarly to how loading the source code of a program in a text editor doesn't cause the program to run.
00:38:57 <johnw> you could have a program that reacts to the temperature of the CPU, for example
00:38:58 <slack1256> time is part of the state.
00:39:05 <mstksg> it's literally impossible -- you have to be at the same time and location
00:39:06 <Cale> (or compiling a program doesn't cause it to run)
00:39:09 <mstksg> it's a theoretical idealness
00:39:14 <lesur> johnw: I know my next project now.
00:39:38 <lesur> :)
00:39:40 <slack1256> but it is true the view as a syntax tree.
00:39:52 <slack1256> the concatenation of >>= and >> is the same regarless of the state
00:39:57 <Cale> mstksg: That's a really impractical approach to understanding what IO actions mean, to the point of being almost useless...
00:40:09 <MouseTheLuckyDog> What I do not understand of what Cale said is this. You write the functional parts. Then basically you use monads to  piece together the functional code with the necessary nonfunctional code. But is the functional part worth all this effort of seperation.
00:40:32 <Cale> MouseTheLuckyDog: This has nothing to do with monads.
00:40:56 <Cale> IO happens to be a monad, but the fact that it's a monad here is fairly irrelevant.
00:41:14 <johnw> yes, monads are nothing special, they are not built into the language or anything like that
00:41:16 <mstksg> Cale: it's not a very practical way to understanding how they work or mean, but it allows you to pretend that everything, down to individual actions, are pure
00:41:25 <Cale> The important point is that we have values which describe effects that could be performed.
00:41:45 <mstksg> *is
00:41:56 <MouseTheLuckyDog> Cale, but you are probably going to do both IO and State.
00:42:03 <Cale> A value x of type IO t is a description of some stuff that your computer could do, and which would produce a result of type t
00:42:29 <Cale> Constructing that description is pure. Carrying out the effects that it describes is not.
00:43:29 <mstksg> carrying out the effects is actually pure, if you take the world as the state
00:43:31 <Cale> In a complete Haskell program, you will define main, and it will be one of these IO actions. When your program runs, the Haskell runtime will evaluate and execute the effects that main describes.
00:44:35 <Cale> mstksg: It's not a useful way to look at it, because at the very least, it doesn't help you to model programs with concurrency, and there are too many things which you'd have to formalise for it to be useful for anything.
00:45:39 <mstksg> i concede that it's not useful at all. but it's rather cute don't you think?
00:46:00 <mstksg> it's a little thrilling to realize that in a way, getLine is pure
00:46:12 <taylorgb> It seems more dangerous than cute. Pretending things to be pure that are not would seem to cause more problems than it solves
00:46:17 <mstksg> of course you can't actually go about constructing anything useful with it.
00:46:25 <Cale> If we're getting into toy models of IO, I would much prefer the GADT way of looking at it
00:46:29 <johnw> I would say that /bin/ls is pure in the sense that the executable doesn't change each time you use it
00:46:38 <Cale> because it's complete and the thing actually *could* be implemented that way
00:46:43 <Cale> i.e.
00:46:48 <Cale> data IO t where
00:46:54 <Cale>   ReturnIO :: t -> IO t
00:46:54 <Lethalman> johnw, well it depends on the contents, so it does change... not a good example :)
00:47:03 <johnw> i didn't say the output
00:47:06 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
00:47:07 <johnw> I meant the /bin/ls executable itself
00:47:10 <Lethalman> ah
00:47:12 <Cale>   GetLine :: IO String
00:47:15 <Lethalman> indeed
00:47:24 <taylorgb> What if ls is updated while your application is running ;)
00:47:28 <Cale>   ... etc, etc. other I/O primitives ...
00:48:12 <Cale> If this was sufficiently well-thought-through, you could have an encoding of FFI as some constructor(s) of that type, and then build most of the primitives in terms of that.
00:48:46 <c_wraith> didn't edwardk *do* that thinking-through at some point?
00:48:58 <c_wraith> in his series of blog posts about IO?
00:49:10 <MouseTheLuckyDog> So what happens  if you have to write a program which has to intermingle IO with functional parts?
00:49:26 <Cale> MouseTheLuckyDog: Did you see my program above with reverse?
00:49:26 <johnw> MouseTheLuckyDog: I don't quite follow that question
00:49:26 <Lethalman> mstksg, the point is that you can't have a snapshot of IO at some point.... i.e. you can't have a function that takes an IO state and returns the same result for every same state
00:49:30 <Lethalman> like you can do with, say State
00:49:51 <MouseTheLuckyDog> Cale: But that's a trivial example.
00:49:52 <Cale> MouseTheLuckyDog: A very simple example program to stare at:  do x <- getLine; putStrLn (reverse x)
00:50:10 <Cale> MouseTheLuckyDog: Now imagine replacing reverse with something arbitrarily complicated.
00:50:36 <Cale> and perhaps elaborating the I/O side of things as well, so that there's more input and more output
00:51:43 <Cale> Eventually, you have something which looks something like model/view/controller, with the pure part of the program being the model, and the view and controller being encoded as IO actions.
00:51:52 <Cale> (If you're familiar with that terminology)
00:52:50 <mstksg> Lethalman: it's not practical to reconstruct the entire world at a point in time to maintain the same output but i'm just looking at it from a theoretical point of view.  so this thinking can't ever actually be useful.  i think it's just cute that you can reason IO execution to be theoretically pure.  there are other equally cute yet more useful ways of thinking about IO however. and as Cale said you don't even have to try to reason that IO ex
00:53:20 <Cale> There are a lot of other theoretical approaches to IO which are also practical, in that they could really be implemented.
00:53:26 <Cale> Which is why I dislike that one.
00:53:40 <Cale> It's a) more complicated than necessary to think about
00:53:46 <Cale> and b) unimplementable
00:54:25 * hackagebot sandi 0.2.2 - Data encoding library  http://hackage.haskell.org/package/sandi-0.2.2 (MagnusTherning)
00:55:09 <MouseTheLuckyDog> johnw: For example you need to write a program which takes a file name. It runs a main loop as follows: it prompts you for a word. The program then prints the word with a list of number which are the positions of each appearance of the word. It then restarts the loop unless the word is ":q" at which point the program terminates.
00:55:50 <Cale> For example, that GADT way also explains how evaluation of IO actions is pure (you're just determining which of some data constructors your IO action is, just like with evaluation at any other algebraic datatype)
00:56:11 <Cale> But you can actually imagine implementing an interpreter for IO actions like that
00:56:34 <Cale> which pattern matches on that GADT, and carries out the appropriate effects
00:58:04 <lesur> Can lambdabot access hoogle?
00:58:17 <Cale> MouseTheLuckyDog: The pure part of that program will probably be a function which takes a String for the file contents and a String to search for, and produces a list of the the positions.
00:58:25 <NihilistDandy> @hoogle mapM
00:58:25 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
00:58:26 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
00:58:26 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
00:58:30 <NihilistDandy> lesur: Yes
00:58:44 <Cale> MouseTheLuckyDog: and then the IO part will make use of that, and take care of the loop with the user interaction
00:59:00 <lesur> @hoogle fmap
00:59:00 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
00:59:00 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
00:59:00 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
00:59:42 <Cale> MouseTheLuckyDog: You might also prefer to construct from the input some kind of map from words to lists of positions at which they occur right away, and that part would be pure too.
01:00:25 <Cale> MouseTheLuckyDog: If you really wanted to, you could model more of the user interaction in terms of pure functions, but it's not really necessary in a simple case like this.
01:01:00 <Cale> i.e. you could produce a function that takes a list of user commands and produces the list of responses
01:02:05 <Cale> MouseTheLuckyDog: Does that help?
01:03:18 <lesur> @hoogle getLine
01:03:18 <lambdabot> Prelude getLine :: IO String
01:03:18 <lambdabot> System.IO getLine :: IO String
01:03:18 <lambdabot> Data.ByteString getLine :: IO ByteString
01:03:52 <MouseTheLuckyDog> Cale: Yes i've thought of that but it then seems to be sort of computing version of tghe many-words interpretation of quantum mechanics and very wasteful as well as probably being NP hard.
01:05:39 <lesur> Is there a better way to say: func x = do return()?
01:05:53 <arkeet> do is unnecessary
01:05:59 <arkeet> do blah  =  blah
01:06:06 <lesur> Just func x = return()?
01:06:13 <arkeet> no, no Just
01:06:20 <lesur> Sorry?
01:06:26 <lesur> Just?
01:06:26 <arkeet> ... yes
01:06:29 <arkeet> you said Just.
01:06:33 <arkeet> :p
01:06:41 <MouseTheLuckyDog> lesur: I think that was meant to be a pun,
01:06:47 <tshirtman> Maybe
01:06:49 <MouseTheLuckyDog> On the Maybe monad.
01:06:55 <lesur> Oh. :)
01:07:12 <arkeet> I don't know what use one would have for such a function though.
01:07:25 <lesur> It's different in my code. :)
01:11:08 <lesur> Is code review here normal, or do beginners normally ask on CR stackexchange?
01:11:31 <c_wraith> code review (via lpaste) is pretty common here.
01:11:42 <c_wraith> Obviously, the longer your code is, the fewer people look at it in depth
01:11:42 <arkeet> for quick help, irc is fine.
01:11:51 <lesur> Would you guys mind reviewing a tiny piece of code?
01:12:21 <lesur> I just got the just joke.
01:12:35 <arkeet> I didn't =(
01:12:43 <Yaniel> Just paste it already :P
01:12:50 <lesur> Oh okay :)
01:12:53 <Ghoul_> I need to map a list, but prioritize the ones that meet a condition
01:12:55 <arkeet> just paste your code and maybe someone will look
01:12:56 <lesur> main = do
01:12:57 <lesur>   putStrLn "Haskell Rock Paper Scissors Try Three"
01:12:57 <lesur>   putStrLn "Choose either Rock, Paper, or Scissors"
01:12:58 <lesur>   playerInput <- getLine
01:13:00 <lesur>   computerInput <- computerChoice
01:13:01 <Yaniel> on lpaste please
01:13:02 <lesur>   putStrLn (winner playerInput)
01:13:02 <arkeet> etrghfhgh no, put it on lpaste
01:13:04 <lesur> computerChoice = return "Rock"
01:13:06 <lesur> winner :: String -> String
01:13:08 <lesur> winner player
01:13:10 <lesur>   |(player == "Rock") = "Tie"
01:13:11 <Ghoul_> lol
01:13:12 <lesur>   |(player == "Paper") = "You Win"
01:13:14 <lesur>   |(player == "Scissors") = "You Lose"
01:13:16 <lesur>   |otherwise = "+" ++ player ++ "+" ++ " is not a valid choice, you loose cheater"
01:13:18 <lesur> main = do
01:13:20 <lesur>   putStrLn "Haskell Rock Paper Scissors Try Three"
01:13:22 <lesur>   putStrLn "Choose either Rock, Paper, or Scissors"
01:13:23 <arkeet> =(
01:13:24 <lesur>   playerInput <- getLine
01:13:26 <lesur>   computerInput <- computerChoice
01:13:26 <Ghoul_> someone /kick him
01:13:28 <lesur>   putStrLn (winner playerInput)
01:13:30 <lesur> computerChoice = return "Rock"
01:13:32 <lesur> winner :: String -> String
01:13:34 <lesur> winner player
01:13:36 <lesur>   |(player == "Rock") = "Tie"
01:13:38 <lesur>   |(player == "Paper") = "You Win"
01:13:38 <arkeet> oh god he did it twice
01:13:40 <lesur>   |(player == "Scissors") = "You Lose"
01:13:42 <lesur>   |otherwise = "+" ++ player ++ "+" ++ " is not a valid choice, you loose cheater"
01:13:44 <lesur> uh, how do I use lpaste?
01:13:46 <Yaniel> dem floods
01:13:46 <lesur> lpast
01:13:50 <arkeet> go to lpaste
01:13:50 <Yaniel> @where paste
01:13:50 <johnw> see the topic
01:13:51 <lambdabot> http://lpaste.net/new/haskell
01:13:52 <arkeet> put your code there
01:13:52 <lesur> I thought I could type lpaste ..., but apparently not
01:14:32 <lesur> Oh, you mean pastbin?
01:14:36 <arkeet> yes.
01:14:46 <arkeet> (that's what we meant by paste.)
01:15:00 <lesur> Opps, sorry guys. http://pastebin.com/vAfcWyEU
01:15:03 <mauke> The paste vAfcWyEU has been copied to http://lpaste.net/91543
01:15:50 <lesur> @where paste
01:15:50 <lambdabot> http://lpaste.net/new/haskell
01:15:51 <arkeet> computerInput doesn't seem to be used for anything.
01:16:04 <lesur> Yeah, just a dummy.
01:16:05 <arkeet> also, consider making a data type to represent the 3 choices, and pass that around instead of a string
01:16:27 <quicksil1er> lose only has one O
01:16:36 <arkeet> maybe it's an adjective.
01:16:41 <lesur> Opps. :)
01:17:10 <lesur> Thanks guys, sorry about the paste rather than lpast thing.
01:18:50 <hvr> does the haskell-prime@ list require subscription for posting?
01:30:08 <Ghoul_> is there a way I can do an easy boolean pattern match
01:30:42 <johnw> ?
01:30:48 <Ghoul_> like, the equivalent of "case x of { Type s -> Just s; _ -> Nothing }"
01:30:50 <johnw> you mean, true if it matches false if not?
01:31:16 <Ghoul_> Im formatting these on multiple lines and its getting old
01:31:23 <johnw> ah, no, not that I know of
01:31:57 <johnw> usually I make a helper function for that kind of thing called maybeType or some such
01:39:49 <MouseTheLuckyDog> Oh wow. I just discovered there is an APL in the debian repositories.
01:42:44 <Ghoul_> is there a function to do this
01:43:22 <Ghoul_> f a b c d e = a (b c) (b d) (b e)
01:44:09 <Ghoul_> @pl (\a b c d e = a (b c) (b d) (b e))
01:44:09 <lambdabot> (line 1, column 13):
01:44:09 <lambdabot> unexpected "="
01:44:09 <lambdabot> expecting pattern or "->"
01:44:16 <Ghoul_> @pl (\a b c d e -> a (b c) (b d) (b e))
01:44:19 <lambdabot> join . (flip .) . ((flip .) .) . ((((.) .) .) .) . flip ap id . (flip .) . (((.) .) .) . (.)
01:44:19 <lambdabot> optimization suspended, use @pl-resume to continue.
01:45:07 <quchen> Ghoul_: Not really. It would be `on3` or something.
01:45:14 <quchen> `on` does that for 2-argument functions.
01:45:36 <Ghoul_> :t on
01:45:37 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
01:45:37 <quchen> (f `on` g) x y :: Expr
01:45:43 <quchen> > (f `on` g) x y :: Expr
01:45:44 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
01:45:44 <lambdabot>    arising from a us...
01:45:49 <quchen> Grr.
01:46:28 <Ghoul_> Thats not quite what I need, but its almost there
01:46:32 <quchen> Oh I think I misread your lambda anyway
01:46:43 <Ghoul_> b -> b -> c would need to be b -> e -> c
01:46:43 <quchen> Write it yourself and give it a sensible name :-)
01:46:57 <Ghoul_> but it'll take away from the theme of my module :(
01:47:10 <quchen> The theme of your module is having no helper functions?
01:47:34 <quchen> You don't have to export the function
01:47:38 <Ghoul_> bleh, Ill just not use it.
01:47:39 <Ghoul_> I'
01:48:18 <adnap> > let xs = [1..10] in zipWith3 (\x y z -> x + y * z) xs xs xs
01:48:20 <lambdabot>   [2,6,12,20,30,42,56,72,90,110]
01:48:38 <adnap> > let xs = [1..10] in (\x y z -> x + y * z) <$> xs <*> xs <*> xs
01:48:39 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,5,7,9,11,13,15,17,19,21,4,7,10,13,16,19,22,25,28,3...
01:52:33 <quchen> Ghoul_: You can also heavily abuse Reader to do what you want.
01:52:34 <quchen> :t \a b c d e -> (a <$> ($ c) <*> ($ d) <*> ($ e)) b
01:52:35 <lambdabot> (b1 -> b1 -> b1 -> b) -> (a -> b1) -> a -> a -> a -> b
01:52:53 <Ghoul_> I'm up for such abuse!
01:53:13 <quchen> It's impossible to read and longer
01:53:23 <quchen> I don't think it has any advantage over the direct definition.
01:53:39 <quchen> It's probably as built-in as you can get :>
02:06:47 <haasn> Ghoul_: http://hackage.haskell.org/packages/archive/pointless-fun/1.1.0.1/doc/html/Data-Function-Pointless.html
02:07:33 <haasn> a $:: b ~> b ~> b ~> id
02:07:58 <haasn> not awfully shorter than the lambda, but less points!
02:08:20 <Ghoul_> ahaha look at the source code for the module
02:09:21 <quchen> Whyyy is this on Hackage
02:10:15 <quchen> "Hey let's give all possible parenthesized permutations of fgxy an infix operator"
02:12:33 <merijn> Is it possible to tell cabal to generate Haddocks without installing the package?
02:12:47 <haasn> oh $:: is actually made redundant by (&)
02:12:59 <haasn> now we only need an equivalent of ~> in lens
02:13:37 <johnw> how do you figure?
02:13:52 <johnw> consider f $::, where f takes 4 arguments; how does & obviate $:: in that case?
02:14:02 <exicer> I have an Int and a list of Ints. I would like to find the value from this list which gives the smallest difference with the first.. I can't quite get my head around how to do this in a functional way :(
02:14:08 <johnw> i don't know of lenses that provide function arguments
02:14:15 <haasn> johnw: because from the source code ($::) = flip ($)
02:14:26 <johnw> ah, interesting!
02:15:45 <tshirtman> exicer: find the min value from the list of differences from head and tail?
02:16:02 <tshirtman> not sure i'm clear
02:17:11 <exicer> The list isn't necessarily in order
02:17:33 <haasn> :t let difference = abs .: subtract in minimumBy (comparing $ difference 5) [0,2..10]
02:17:33 <lambdabot>     Not in scope: `.:'
02:17:34 <lambdabot>     Perhaps you meant one of these:
02:17:34 <lambdabot>       `.' (imported from Data.Function),
02:17:36 <exicer> I can find the actually minimum value (by using minimum..) but how do I keep track of the value that resulted in the minimum ?
02:17:36 <haasn> err
02:17:44 <haasn> > let difference x = abs . subtract x in minimumBy (comparing $ difference 5) [0,2..10]
02:17:45 <lambdabot>   4
02:18:10 <haasn> :t minimumBy -- exicer
02:18:11 <lambdabot> (a -> a -> Ordering) -> [a] -> a
02:18:30 <exicer> haasn: Ah - that is what I was looking for
02:18:32 <haasn> coding exercise: implement minimumBy yourself (and no, please don't type @src minimumBy in this channel now)
02:18:38 <exicer> :p
02:19:07 <exicer> The only way I could think of doing it was to somehow pass the index and current minimum recursivley.. if that makes any sense
02:19:14 <haasn> keep in mind this is unsafe, errors for []
02:20:29 <haasn> :t minimumByOf traverse
02:20:30 <lambdabot> Traversable t => (a -> a -> Ordering) -> t a -> Maybe a
02:20:44 <haasn> or folded, rather
02:21:11 <haasn> exicer: don't bother with the index
02:21:16 <haasn> indexing lists is generally a bad idea
02:21:36 <exicer> That is kinda what I thought
02:21:44 <exicer> I'm still stuck in the loops mindset, I'm afraid
02:22:13 <haasn> loops are perfectly compatible with functional languages, via recursion
02:22:24 <exicer> I guess I mean loops + mutable variables
02:22:52 <exicer> I'll try and work it out
02:24:39 <c_wraith> instead of passing the index and current minimum, pass the current minimum and the part of the list you haven't looked at yet.
02:25:26 <c_wraith> It's exactly what you'd do in an imperative language when working with linked lists - walk a pointer down the list.
02:25:35 <c_wraith> and [] is a linked list
02:26:18 <haasn> A good strategy to work out how to write things declaratively is to think about each of the cases eg. (x : xs)  -> what is the minimum value of ‘x’ prepended to ‘xs’?
02:27:05 <haasn> then you don't need to think about recursion or loops or anything else, but instead have it come naturally as you express the correct answer
02:35:33 <quchen> What's the algorithm behind Data.List.sort? It says "merge" and feels like it, but it seems heavily modified.
02:36:01 <quchen> "Rumored to have been based on" is what the comment says
02:38:02 <haasn> looks like it first breaks the list up into continuously in/decrementing sequences, for whatever reason
02:38:24 <haasn> this is probably more efficient than recursing down to the single element
02:39:32 <quchen> I wonder whether some mutable ST-based solution would be better sometimes
02:39:38 <haasn> try it
02:40:35 <c_wraith> using a single STRef is usually slower than just passing a value around
02:40:53 <c_wraith> You need to be making real advantage of mutability within the algorithm for ST to win
02:41:15 <quchen> c_wraith: Yeah I was thinking of introsort
02:41:30 <quchen> Can't be too wrong if GCC uses it
02:41:46 <quchen> But the as you mentioned STRefs might have some overhead
02:42:11 <c_wraith> well, if you're sorting, I'm assuming vector or STArray
02:42:28 <c_wraith> and for those, mutability lets you avoid a lot of copying
02:44:42 <adnap> > [(+ 2), (* 3)] <*> repeat 5
02:44:43 <lambdabot>   [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,...
02:45:13 <adnap> > zipWith ap [(+ 2), (* 3)] (repeat 5)
02:45:14 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable b0)
02:45:14 <lambdabot>    arising from a use ...
02:45:24 <adnap> :t ap
02:45:25 <lambdabot> Monad m => m (a -> b) -> m a -> m b
02:45:25 <quchen> adnap: You can also /q lambdabot
02:45:47 <haasn> > zipWith ($) (cycle [(+2), (*3)]) (repeat 5)
02:45:48 <lambdabot>   [7,15,7,15,7,15,7,15,7,15,7,15,7,15,7,15,7,15,7,15,7,15,7,15,7,15,7,15,7,15...
02:46:03 <adnap> Why does everyone tell me this. I spam the channel because I want help. If people have a problem with the spam, tell me
02:46:22 <haasn> well then ask a question so people know you're asking for help and not just spamming the channel :)
02:47:13 <adnap> How can I produce [7, 15] from [(+ 2), (* 3)] and (repeat 5) ?
02:47:30 <haasn> > zipWith ($) [(+2), (*3)] (repeat 5)
02:47:31 <lambdabot>   [7,15]
02:47:43 <adnap> :t ($)
02:47:43 <lambdabot> (a -> b) -> a -> b
02:49:54 <supki> > getZipList $ (<*>) (ZipList [(+ 2), (* 3)]) (ZipList (repeat 5))
02:49:55 <lambdabot>   [7,15]
02:51:06 <quchen> ZipList . repeat = pure :-)
02:51:53 <adnap> ugly!
02:52:10 <mr-> no, not ugly
02:52:21 <mr-> good to know ;-)
02:52:29 <adnap> I know about ZipLisit
02:52:35 <adnap> Maybe if there was sugar
02:52:37 <adnap> Like...
02:52:41 <adnap> {} for a ZipList
02:52:51 <chrisdone> Frans ZipLiszt
02:52:55 <Iceland_jack> adnap: Why would you need that?
02:53:09 <Iceland_jack> ZipList is not used very much
02:53:20 <adnap> 'Cause ZipList is ugly! You have use the data constructor and call getZipList!
02:53:29 <quchen> Also it's not part of the standard, and introducing special syntax would make that necessary.
02:53:46 <mstksg> anyone here use yesod?  how do i use selectList on a list of keys?  or just get a list of rows corresponding to a list of keys, with additional filters and SelectOpts/orderings?
02:53:49 <adnap> Well, there are at least two ways list can be an applicative
02:54:23 <adnap> Maybe it would be better if there was a way to specify which one to use
02:54:24 <yitz> mstksg: sounds like you're talking about persistent
02:54:46 <mstksg> yitz: er...yeah, not sure why i said yesod.  i'm not even using yseod
02:54:51 <mstksg> haha.
02:55:02 <Iceland_jack> adnap: But there is a way, as per the example above
02:55:13 <adnap> Iceland_jack: It's so ugly!
02:55:33 <adnap> Because it's long
02:55:57 <Iceland_jack> I'm not sure you're taking into account what a big step syntactic sugar is
02:56:11 <quchen> > getZipList $ ZipList [(+ 2), (* 3)] <*> pure 5  -- supki's code refactored
02:56:12 <lambdabot>   [7,15]
02:56:26 <adnap> That's not baf
02:56:28 <adnap> *bad
02:56:30 <adnap> But I think
02:56:35 <chrisdone> mstksg: how about: http://hackage.haskell.org/packages/archive/persistent/1.2.2.0/doc/html/Database-Persist.html#v:-60--45-.
02:56:36 <quchen> ZipList becomes useful if you want to zip many lists together
02:56:43 <quchen> Using zip12 isn't much fun :-)
02:56:50 <adnap> > zipWith ($) [(+ 2), (* 3)] $ repeat 5
02:56:51 <lambdabot>   [7,15]
02:56:53 <yitz> adnap: how about this syntax: [| zipList | repeat 5 | (+2), (*3) |]
02:56:53 <Iceland_jack> If you need zip12 you may be doing something wrong
02:56:54 <adnap> is prettier
02:56:58 <chrisdone> mstksg: which is equiv. to writing x IN (1,2,3,)
02:57:36 <quchen> Well if what you want is zip, then use zip
02:58:08 <adnap> I just to apply several functions to the same value
02:58:11 <adnap> *want to
02:58:21 <mstksg> chrisdone: yeah, i saw that ... but am i allowed to use Keys as Filters?
02:58:42 <quchen> Iceland_jack: transpose is zipInfinity. Also, suppose you're generating long datasets in parallel and want to merge them somewhere, that's zipping many streams as well.
02:58:58 <chrisdone> mstksg: like what?
02:59:04 <adnap> Hrm...
02:59:22 <quchen> Iceland_jack: zip12 is still far-fetched, but not completely absurd. :-)
03:00:07 <quchen> > map ($ 5) [(+2), (*3)] --   adnap: Oh, by the way, you don't need to zip for that.
03:00:09 <lambdabot>   [7,15]
03:00:16 <mstksg> chrisdone: my list is a list of keys/identifiers.  let's say my table name is Entry.  I have a list [Key Entry]
03:00:37 <adnap> > let xs = [1..5] in getZipList $ ZipList [(+)] <*> ZipList xs <*> ZipList xs
03:00:40 <lambdabot>   mueval-core: Time limit exceeded
03:00:52 <mstksg> it doesn't seem to like selectList [ (Key Entry) <-. keyList ] []
03:00:56 <adnap> > let xs = [1..5] in getZipList $ (+) <$> ZipList xs <*> ZipList xs
03:00:58 <lambdabot>   [2,4,6,8,10]
03:01:52 <mstksg> chrisdone: admittedly though, usually when i run into problems like this it's because i approached the whole thin wrong
03:01:55 <mstksg> *thing
03:02:24 <adnap> I think...
03:02:56 <adnap> > let xs = [1..5] in zipWith4 (\x y z w -> (x + y) * (z + w)) xs xs xs xs
03:02:57 <lambdabot>   [4,16,36,64,100]
03:03:06 <adnap> ...is prettier than...
03:03:42 <adnap> > let xs = [1..5] in getZipList $ (\x y z w -> (x + y) * (z + w)) <$> ZipList xs <*> ZipList xs <*> ZipList xs <*> ZipList xs
03:03:43 <lambdabot>   [4,16,36,64,100]
03:04:07 <arkeet> > [(+2),(*3)] <*> pure 5
03:04:08 <lambdabot>   [7,15]
03:04:22 <adnap> O_O
03:04:33 <arkeet> what do I win
03:04:38 <adnap> All the...
03:04:47 <adnap> A hug!
03:04:50 * adnap hugs arkeet 
03:04:53 <arkeet> =)
03:04:56 <chrisdone> mstksg: surely it should be: [FooId <-. [Key …,Key …]]
03:04:56 <haasn> adnap: yeah for cases like these the ZipList newtype is really just there for instances (ie. using it with other combinators you might have lying around that require eg. an Applicative)
03:05:08 <quchen> adnap: That's identical to the `map` based solution I wrote above.
03:05:08 <adnap> > [(+2),(*3)] <*> [5]
03:05:09 <lambdabot>   [7,15]
03:05:21 <arkeet> quchen: well sure, but there's no ugly $ involved =)
03:05:27 <quchen> pure f <*> g = fmap f g
03:05:33 <adnap> Why didn't I think of that?
03:05:58 <arkeet> quchen: well, actually, not quite.
03:06:00 <adnap> quchen: I know that
03:06:00 <quchen> arkeet: Yeah, it's replaced by a beautiful unecessary Applicative.
03:06:10 <arkeet> of course it's unnecessary.
03:06:20 <arkeet> :t (??)
03:06:21 <lambdabot> Functor f => f (a -> b) -> a -> f b
03:06:24 <yitz> where's a good place for mathematician who isn't a programmer to start learning haskell?
03:06:29 <arkeet> > [(+2),(*3)] ?? 5
03:06:31 <lambdabot>   [7,15]
03:06:34 <arkeet> =)
03:06:41 <quchen> yitz: At the beginning, with LYAH and RWH and all that?
03:06:54 <haasn> > [(+2),(*3)] <&> ($5)
03:06:56 <lambdabot>   [7,15]
03:06:57 <yitz> quchen: aren't those for programmers?
03:07:01 <yitz> maybe hutton
03:07:03 <yitz> ?
03:07:06 <mstksg> chrisdone: oh i didn't even know about EntryId.
03:07:17 <mstksg> i wish i could somehow create haddock documentation for my TH-generated models
03:07:25 <mstksg> just to see what concerete types i have
03:07:27 <quchen> yitz: Maybe. I think LYAH is a nice read just for the pictures, the programming part is a side-effect (oh the irony).
03:07:33 <adnap> arkeet: O_o
03:07:42 <adnap> :t (??)
03:07:43 <arkeet> adnap: ?? is from lens, it's a generalized flip
03:07:43 <lambdabot> Functor f => f (a -> b) -> a -> f b
03:07:51 <arkeet> f ?? x = fmap ($x) f
03:08:06 <adnap> Generalized flip? Really?
03:08:13 <arkeet> yes
03:08:22 <arkeet> > (f ?? x) y :: Expr
03:08:23 <lambdabot>   f y x
03:08:57 <arkeet> (fmap ($x) f) y = (($x) . f) y = ($x) (f y) = f y $ x
03:09:53 <quchen> Oh, the ?? is like a placeholder, Mathematica-style.
03:09:57 <arkeet> yes
03:10:03 <quchen> Funny.
03:10:05 <arkeet> yes
03:10:11 <arkeet> that analogy doesn't go very far though
03:10:29 <quchen> Only for Reader.
03:10:36 <arkeet> only before the last argument.
03:10:44 <quchen> That too.
03:10:52 <adnap> f is the functor, right?
03:10:55 <quchen> I'm sure there's also ??? and ??. in there to address that :-P
03:11:20 <adnap> I am slow
03:11:32 <arkeet> f is a function.
03:11:37 <arkeet> remember the Functor instance for functions.
03:11:44 <adnap> Yes
03:11:44 <arkeet> Functor f => f (a -> b) -> a -> f b
03:11:47 <arkeet> put f = (r ->)
03:12:02 <arkeet> (r -> a -> b) -> a -> r -> b
03:13:08 <adnap> (fmap ($x) f) y = (($x) . f) y = ($x) (f y) = f y $ x
03:13:41 <arkeet> fmap = (.)
03:14:07 <johnw> based on the utility of f $:: a ~> b above, I thought it would be neat to wrap FFI functions with something like: c'foo $:: withCString ~~> withCString ~~> peekCString
03:14:17 <johnw> to turn a CString -> CString -> IO CString into a String -> String -> IO String
03:14:27 <adnap> arkeet: So this statement is only about function functors?
03:14:45 <arkeet> like I said, it's a generalization of flip.
03:14:55 <arkeet> when you choose your Functor to be a function thing, it becomes flip.
03:15:15 <adnap> Oh
03:15:57 <adnap> f ?? x = fmap ($x) f
03:16:04 <arkeet> yes
03:16:25 <adnap> So, if the functor has anything that takes an x-value inside, it applies the value of x to it
03:16:30 <tshirtman> what does "$" do here?
03:16:37 <arkeet> $ is function application.
03:16:38 <arkeet> f $ x = f x
03:17:02 <adnap> [(+2),(*3)] ?? 5
03:17:11 <adnap> I see!
03:17:21 <tshirtman> in this, i understand, but in ($x) i don't
03:17:31 <arkeet> tshirtman: have you seen stuff like (*5)?
03:17:40 <arkeet> (* 5) x = x * 5
03:17:43 <arkeet> ($ x) f = f $ x
03:17:43 <tshirtman> arkeet: aah, ok
03:17:49 <haasn> tshirtman: ($x) = \y -> y $ x
03:18:06 <tshirtman> yes i had seen functions defined like -3 or *5
03:18:14 <arkeet> hopefully not (-3).
03:18:19 <haasn> (-3) is ‘negate 3’
03:18:33 <adnap> Man...
03:18:38 <adnap> lens is so smart
03:18:38 <tshirtman> i guess i need to think hard about how things work :)
03:18:48 <arkeet> - is the exception there. =(
03:18:57 <haasn> it's an ugly wart
03:18:59 <haasn> =(
03:19:01 <arkeet> > [(+2),(*3)] <*> [5,6]
03:19:02 <lambdabot>   [7,8,15,18]
03:19:05 <tshirtman> is there a "learn haskell the hard way"? lol :)
03:19:11 <quchen> Minus signs are nasty in Haskell. Especially when you want to replace infix "-" with "subtract" so you can section it. 3 `subtract` 1 -- wat
03:19:18 <arkeet> tshirtman: read the haskell report? =)
03:19:36 <arkeet> quchen: subtract isn't meant to be used infix, I'm pretty sure.
03:19:36 <quchen> tshirtman: The gentle introduction to Haskell is pretty hardcore.
03:19:38 <haasn> quchen: best written (subtract 3 1) ie. “subtract 3 from 1” for clarity
03:19:44 <haasn> then again
03:19:48 <haasn> “3 subtracted from 1”
03:19:52 <haasn> works too
03:19:55 <quchen> haasn: Yes. Still it's something you can do by mistake.
03:19:56 <arkeet> subtract is basically meant to only be partially applied.
03:19:58 <adnap> The Gentle Intro to Haskell was all there was before LYAH
03:20:00 <arkeet> elsewhere you'd just use -
03:20:02 <adnap> That I knew of
03:20:13 <adnap> It starts out easy
03:21:17 <MouseTheLuckyDog> There was Hudak and THomson.
03:21:29 <tshirtman> i didn't read a whole tutorial yet, have been scrapping things there and there to solve my exercises :)
03:21:43 <tshirtman> i guess i'll have to, to get a better picture
03:22:02 <arkeet> I think my first exposure to haskell was with YAHT.
03:22:53 <adnap> lens seems so good that a lot of it should be in Prelude
03:23:02 <haasn> tshirtman: the importance of a good introduction is mainly so you can get your head around nonstrictness, purity and ADTs, imo
03:23:05 <ocharles> I need to make a habit of using lenses more
03:23:11 <ocharles> I think it's proved itself useful enough
03:23:15 <haasn> if you already understand those, you're probably fine
03:23:23 <ocharles> other than the slightly wonky reverse ordering of composition
03:23:29 <FreeFull> tshirtman: There is a "Learn Haskell Fast and Hard" but I don't know if it's good or not
03:23:59 <tshirtman> ok :)
03:24:04 <adnap> I think lens hasn't stuck for me because I don't use it in my code. I have followed a bunch of examples, but I don't know when to use it
03:24:06 <haasn> ocharles: it makes total sense if you just turn your intuition off and think of it like indexing fields in certain other languges ;-)
03:24:50 <tshirtman> there are so much concepts to grasp, and they are explained in so mathematical (terse) ways, it's hard to learn fast, i guess
03:24:51 <haasn> adnap: I think the main problem with that is that there are so many different parts of lens that you need to know in order to realize they can be used
03:24:54 <zvrba> hm. has anybody any experience with calling C code from haskell, where C code are stubs towards COM objects generated by MIDL?
03:25:01 <haasn> adnap: but in general, I use it whenever I need to modify some or all of a data structure
03:25:12 <tshirtman> a lot of tutorials have nice pictures, and it helps a little, still, you need to grasp them
03:25:14 <adnap> haasn: Even a very shallow data constructor?
03:25:14 <zvrba> hdirect is, according to web archives, rather broken now. i.e., it generates buggy code,
03:25:15 <Iceland_jack> zvrba: Have you looked at Haskell's FFI?
03:25:15 <haasn> specifically when traversing, folding or doing that kind of stuff
03:25:32 <adnap> haasn: 'Cause I still use x { foo = bar }
03:25:35 <zvrba> Iceland_jack: yeah, looking at it. but i'm specifically want to use COM objects.
03:25:36 <ocharles> haasn: sure, I know that
03:25:40 <ocharles> haasn: but context switches are a bad thing
03:25:45 <alexander__b> instance Functor [] where
03:25:47 <alexander__b>   fmap _ [] = []
03:25:49 <alexander__b>   fmap g (x:xs) = g x : g x : fmap g xs
03:25:51 <zvrba> so FFI towards midl-generated code would be the last resort.
03:25:59 <haasn> adnap: I don't use records a lot; for example if I need to ‘fmap’ over the left field of an Either; I'll throw an ‘over _Left’ in there
03:26:05 <alexander__b> is the reason this is "evil" because doing g x twice?
03:26:10 <haasn> for over _Right I might use ‘fmap’, unless I'm composing it with anything else
03:26:19 <ocharles> haasn: that arguably more readable, nice tip :)
03:26:20 <adnap> I haven't ever done anything like that
03:26:21 <alexander__b> because doing g x : gx : fmap g xs results in a different list.
03:26:40 <tero-> I'm validating an AST. I'm thinking of doing this by combining Reader and Writer monads, the stacked monad being ReaderT Bindings (Writer [String] ()). does this seem sensible?
03:27:05 <alexander__b> so fmap id on [1..3] would result in [1,1,2,2,3,3] (I think)
03:27:09 <Iceland_jack> I sent an email to Ross Paterson regarding a username on Hackage some 11 days ago but I haven't gotten a response: should I keep waiting?
03:27:11 <haasn> alexander__b: it violates the laws, yeah
03:27:15 <arkeet> alexander__b: no, fmap id = id
03:27:17 <arkeet> oh, yeah.
03:27:18 <haasn> alexander__b: it's exactly as you say, fmap id  needs to be = id
03:27:20 <alexander__b> arkeet: it has that
03:27:28 <altmattr> does anyone have advice for fixing "commitBuffer: resource vanished (Broken pipe)" errors?
03:27:38 <alexander__b> arkeet: oh wait sorry misread
03:27:42 <altmattr> not in code I wrote, using Hakyll
03:27:48 <alexander__b> arkeet: haasn: then I got that right, heh. thanks.
03:28:09 <alexander__b> (looking at haskell for the first time in weeks -- got a surprise day off work)
03:28:17 <haasn> alexander__b: fun fact: (lawful) Functor instances are unique, so if a data type already has a Functor instance and you try to define a different one, you know yours has to be wrong =)
03:28:36 <arkeet> @free fmap :: (a -> b) -> F a -> F b
03:28:36 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
03:28:58 <alexander__b> haasn: ya I know *that*. this was just listed as an illustration of a "legal" but "evil" functor, hehe.
03:29:07 <arkeet> where $map_F is a real lawful fmap.
03:29:08 <bellbreaker> Hello there! Would you fine folks recommend http://learnyouahaskell.com/ as a learning resource?
03:29:16 <alexander__b> but I g2g finish watching jcarmack's quakecon 2013 talk -- where, yes, he talks about haskell. :-)
03:29:17 <merijn> bellbreaker: Yes
03:29:20 <haasn> alexander__b: if you take ‘legal’ to mean ‘type-checks’, which isn't the same thing (obviously)
03:29:22 <arkeet> now put h = f = id, and fmap id = $map_F id = id, to obtain
03:29:27 <arkeet> $map_F g = fmap g
03:29:28 * hackagebot hakyll 4.3.2.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.3.2.0 (JasperVanDerJeugt)
03:29:30 <arkeet> (since g = k)
03:29:36 <Iceland_jack> I'm starting to wonder if there is a conspiracy in the Haskell community to prevent me from uploading packages on Hackage ;)
03:29:40 <alexander__b> haasn: the text says "legal" -- with the "s. ;-)
03:29:52 <merijn> bellbreaker: Learn You a Haskell is an excellent beginner intro, there is also Real World Haskell, but I tend to recommend that as a follow up to LYAH
03:30:46 <bellbreaker> Thanks merijn
03:30:50 <haasn> alexander__b: the general consequence of the Functor laws is that ‘fmap’ needs to exactly preserve the structure of what you're mapping over
03:30:59 <haasn> eg. if your input has X contexts, your output does too
03:31:10 <haasn> for lists, this means the length of the list has to remain unchanged
03:31:36 <merijn> Iceland_jack: A lot of community infrastructure is understaffed and there was a migration of machines too. New admins have been added, but there's no settled routine for tracking requests/account creatio/etc. yet
03:31:50 <merijn> Iceland_jack: This should hopefully improve, Real Soon Now (TM)
03:32:23 <Iceland_jack> I see! I'll wait patiently :)
03:33:02 <merijn> Iceland_jack: More specifically, afaik the guy responsible for Hackage accounts is on vacation and there has been no time to look into getting other people access to do it
03:33:46 <haasn> why can't we defer the job of confirming new registrations to the type system
03:33:57 <haasn> let GHC take care of it
03:34:09 <Iceland_jack> I would be willing to voluneer for what it's worth
03:34:14 <arkeet> alexander__b: oh yeah, I need to watch that myself.
03:34:33 <haasn> arkeet: I would love to read a summary or transcript or something
03:34:50 <arkeet> for a 3-hour talk? =)
03:37:05 <simukis_> arkeet: well, reading is still faster than listening.
03:37:17 <arkeet> it's hard to do other tasks while reading though.
03:37:30 <haasn> emphasis on summary =)
03:37:34 <arkeet> =)
03:37:45 <arkeet> I just love listening to him talk.
03:37:47 <haasn> in particular I'm curious about what negative points he mentions
03:39:28 * hackagebot sandi 0.2.2.1 - Data encoding library  http://hackage.haskell.org/package/sandi-0.2.2.1 (MagnusTherning)
03:47:17 <tero-> I'd like to change the Reader environment after each Reader computation. Is there a nice way to do this?
03:47:45 <hpc> tero-: State ;)
03:48:01 <Iceland_jack> tero-: What do you mean by after each computation? Are you sure you don't want State instead of Reader for a mutable environment?
03:48:03 <tero-> "everyone" says using State is evil/lazy/whatever
03:48:13 <arkeet> that's not true at all
03:48:20 <Iceland_jack> State isn't evil
03:48:24 <bergmark> if you want to read and write... use state :)
03:48:46 <Iceland_jack> You could use something like Control.Monad.Reader.local but why bother
03:49:16 <tero-> okay. now I have clear conscience for using State :)
03:49:25 <Iceland_jack> What are you using it for?
03:49:35 <tero-> I have a DSL I need to validate
03:49:58 <bergmark> at times it might be nice to have a state and then just supply a reader for a computation and then modify the state externally
03:50:00 <tero-> https://github.com/tlaitinen/yesod-dsl
03:50:29 <mstksg> tero-: that's probably exactly the use case for state
03:51:11 <mm_freak> is there a length-parameterized interface to Vector?
03:51:16 <tero-> I'll give it a shot then
03:51:20 <hpc> tero-: the main issue with State is that people sometimes use it when inappropriate
03:51:24 * hpc was guilty of that once
03:51:28 <mm_freak> like Vec, but for actual Vectors
03:52:03 <arnsholt> hpc: So, when is State appropriate, and when is it not?
03:52:07 <haasn> Vector doesn't expose a length to the type system, does it?
03:52:25 <arnsholt> (Having recently written code using State)
03:52:48 <haasn> state is appropriate when it makes your code more elegant, readable and composable :)
03:52:50 <typoclass> haasn: i suppose it *could*, with the new-fangle type-level nats and whatnot
03:52:58 <haasn> typoclass: it could, but then you have Vec ;-)
03:52:58 <hpc> haasn: heh, basically
03:53:02 <haasn> and besides, it doesn't work all that well
03:53:09 <hpc> there's not really a rule
03:53:58 <merijn> arnsholt: You learn as you get more experience and read other peoples code. Some things are just inherently Stateful, so forcing a non-stateful way to solve them is just wasting effort
03:54:07 <mm_freak> haasn: Vector itself isn't algebraic, so it can't by itself, but you can provide a lengthy wrapper
03:54:10 <hpc> i always fall back on "make the code look like what it does"
03:54:17 <hpc> for very fuzzy definition of "looks like"
03:54:47 <mm_freak> arnsholt: when you find that you combine a lot of functions of the form S -> (S, a), then State is appropriate
03:54:52 <mm_freak> arnsholt: most of the time it isn't
03:54:59 <arnsholt> Right, right. My initial implementation explicitly passed around tuples of state and intermediate results, so I'm pretty sure State was right in this case
03:55:13 <merijn> arnsholt: Probably :)
03:55:16 <typoclass> arnsholt: i think it's hard to say in the abstract. put your code in lpaste, ask in here. if there's heated debate and exclamation marks, you should improve it. if there's only moderate grumbling, then you've done ok :-)
03:55:28 <mm_freak> arnsholt: my main use case for State is random number generation
03:56:03 <arnsholt> This code is post-order numbering the nodes of a Tree
03:56:13 <arnsholt> @where hpaste
03:56:13 <lambdabot> http://lpaste.net/new/haskell
03:56:22 <mm_freak> arnsholt: as you gain more and more experience you will find that Reader and Writer are usually your best friends =)
03:56:41 <mm_freak> Writer for collecting new information, Reader for referring to existing information
03:56:42 <merijn> arnsholt: I tend to use StateT a lot when I want to have library specific state that is invisible to users of the library
03:56:43 <haasn> I find I don't really use Reader much at all
03:56:52 <haasn> because plain functions supersede most of its functionality
03:56:53 <hpaste> arnsholt pasted “State?” at http://lpaste.net/91544
03:56:59 <merijn> mm_freak: I think StateT is useful for hiding state from library users
03:57:08 <mm_freak> haasn: i don't use Reader either, i use (MonadReader X m) => m Y
03:57:13 <arnsholt> That's the actual code
03:57:24 <mm_freak> merijn: i think that's usually an anti-pattern
03:57:28 <typoclass> elliott: hai. i've noticed that "@where paste" is good, but @paste still gives the old defunct domain name. any chance you could work your magic?
03:57:30 <merijn> mm_freak: Why?
03:57:55 <mm_freak> merijn: because only very few applications really need state /threading/
03:58:29 <mm_freak> if anything, state should always be local and hidden
03:58:38 <mstksg> haasn: i try to avoid reader when i can, but sometimes it's very tempting to just eliminate the chore of writing/carrying around arguments for dozens of functions
03:58:45 <merijn> mm_freak: Sure, but I happen to write quite a bit of code with state threading :) I.e. most recent case is connection state for a socket
03:59:13 <mm_freak> merijn: you change connection state in the middle of a computation?
03:59:15 <merijn> mm_freak: I'm using lazy bytestrings to parse data, which means that after running a parser there might be left over data to feed to the next parser
03:59:17 <typoclass> mm_freak: so you think that the "Random" approach is better? having an opaque generator, giving it out to users, requesting them to pass it into the library's functions?
03:59:25 <typoclass> (just for clarification)
03:59:52 <haasn> knowing mm_freak he probably prefers an automaton for anything state-y ;)
04:00:01 <mm_freak> typoclass: no, for random numbers my types usually look like this:  f :: (Monad m) => (forall a. (Random a) => m a) -> m X
04:00:04 <merijn> mm_freak: It is very messy to expose the "left-over" threading to the rest of the code
04:00:23 <mm_freak> haasn: not at all
04:00:34 <mm_freak> haasn: my most common pattern for handling state is Reader and Writer
04:00:39 <merijn> Although I'd be open to better suggestions :p
04:00:42 <haasn> fair enough
04:00:49 <mm_freak> the reason is very simple:  for the duration of a computation i want assumptions to be consistent
04:01:00 <mm_freak> and this proves to be a good bug catcher
04:01:31 <mm_freak> MonadReader and MonadWriter are very good for that
04:01:54 <mm_freak> that's also the reason why i seem to use lenses a lot more seldomly than others =)
04:02:12 <haasn> I don't really use lens + State that much in serious code
04:02:17 <mm_freak> my Getter is regular functions, my Setter is Monoid =)
04:02:33 <merijn> mm_freak: Sure, but they're not very good for "let users compose library components that need to pass state between each other, without exposing this to the user"
04:03:16 <typoclass> mm_freak: hm. is "Random a" the class from System.Random?
04:03:16 <mm_freak> merijn: if the library is really that stateful, there is still the Wire-y approach =)
04:03:27 <mm_freak> typoclass: usually yeah
04:03:29 <haasn> merijn: it depends on the specifics of the problem, but instead of even bothering with some opaque encapsulation of state, you can often get away with hiding it inside functions
04:03:46 <merijn> mm_freak: Not until you implement concurrent wires and multiple input sources for me :)
04:03:51 <haasn> eg. data Foo = { bar :: a -> (b, Foo) } -- instead of bar :: a -> State Foo b
04:04:08 <mm_freak> merijn: then there is still the Proxy-y approach =)
04:04:17 <mm_freak> see pipes-concurrency
04:04:38 <haasn> then functions which don't “update” the state can drop the (, Foo); and functions which don't “require” a state can drop the Foo thing altogether
04:04:48 <merijn> Do pipes support bidirectionality?
04:04:48 <mm_freak> in fact Tekmo told me that he wrote a functor from Wire to (Proxy p) => p
04:04:53 <mm_freak> so you can even combine them
04:05:27 <mm_freak> merijn: yes, they do…  quite naturally actually
04:06:00 <mm_freak> merijn: anyway, the main reason why i try to avoid State is that it breaks many consistency assumptions
04:06:30 <merijn> mm_freak: Oh, wait pipes is coroutines, which is explicitly what I wanted to avoid :)
04:07:07 <typoclass> arnsholt: anyway, your paste looks quite alright to me
04:08:11 <arnsholt> Spiffy! I did try to get it done without the state-passing first, so I think it should be ok
04:08:15 <merijn> mm_freak: Atm I'm just using lazy IO, because as far as I can tell none of the downsides of lazy IO apply to me
04:08:46 <arnsholt> But I still don't feel I'm too much beyond pidgin Haskell, so second opinions are always good =)
04:09:58 <haasn> do { n <- get; put (n+1); ... } = do { n <- id <+= 1; ...} -- =)
04:10:12 <typoclass> arnsholt: i'm wondering why Control.Monad.State for a combination of get and put has a function modify :: (s -> s) -> m (), but not modify' :: (s -> s) -> m s. if it had, i guess it'd help you
04:10:17 <merijn> The main issues with lazy IO seem to be non-deterministic freeing of file descriptors and erratic memory behaviour for large data, but since I'm only dealing with sockets the fd consumption isn't relevant to me, as I will need the fd to remain open as long as the connection lasts anyway and memory consumption shouldn't be a problem since I have eager consumers of my data
04:10:25 <typoclass> haasn: using lens?
04:10:30 <haasn> yeah
04:11:51 <haasn> so that entire expression is  = Node <$> id <+= 1 <*> numberforest ts
04:11:57 <adnap> I just like to write code that is as short as possible. I think abstractions are good if they make the code shorter
04:12:27 <haasn> .. if the fixivity of <+= would allow it
04:12:41 <tero-> code compressors are also good at making the code shorter ;)
04:12:53 <hpc> i wonder what kind of place there would be for something like State, with only modify :: (s -> s) -> m ()
04:12:55 <arnsholt> typoclass: Yeah, I almost factored that into a separate little function, but in the end I didn't bother
04:13:07 <hpc> no get, no put
04:13:13 <hpc> (although you can implement put with modify)
04:13:15 <adnap> Yeah, I don't mean stupid things like putting everything on the same line or something
04:13:24 <haasn> hpc: seems equivalent to Writer
04:13:36 <DrTeggy> haasn, fixity
04:13:51 <haasn> hpc: specifically, Writer (Endo s)
04:13:53 <hpc> haasn: Writer is the special case of write w = modify (`mappend` w)
04:14:00 <hpc> oh, yes
04:14:09 <hpc> i see now
04:14:10 <typoclass> hpc: you could implement get and put in terms of something that offers only modify :: (s -> s) -> m s
04:14:28 <hpc> typoclass: that's less fun :P
04:14:40 <typoclass> ;)
04:15:19 <hpc> fun practical joke: in between releases of a hypothetical mtl with modify :: (s -> s) -> m s, change which state is returned
04:15:24 <hpc> the one before or after modify
04:16:11 <haasn> of course, all code using ‘get/put’ would still work
04:16:21 <adnap> Do you think it is a reasonable strategy to write something that works first, and apply abstractions that make the code clearer later, anaglogous to optimization for speed?
04:16:29 <typoclass> hpc: ... if anyone complains, give them the usual speech how we can't allow haskell to stagnate :)
04:16:52 <arnsholt> adnap: That's how I've written most of what little I've written
04:16:54 <haasn> adnap: it's certainly reasonable, especially if you're not experienced with the abstractions you're using or are unsure which abstractions would be the right tool for the job
04:17:14 <arnsholt> First make it work, then figure out which do things are stupid and can be eliminated and so on
04:17:14 <haasn> adnap: but you can also waste a lot of time that way when you end up writing an exponential amount of code for something that would be linear with the right abstractions
04:17:19 <mstksg> sometimes you aren't even aware of what abstractions are possible or even useful
04:17:38 <adnap> Yeah, but abstractions require a learning investment if you don't know them already
04:17:45 <hpc> adnap: what i find helps is to stop a bit and think, to get maybe halfway to a good final set of abstractions
04:17:54 <adnap> And I imagine you can just mine them from your longer code
04:18:04 <haasn> instead of implementing the whole thing at once I like to reduce the algorithm to a simpler or similar general case then find an abstraction for that
04:18:05 <hpc> which makes improving the code later significantly easier
04:18:52 <adnap> So, sort of iteratively writing code and compactifying it with abstractions
04:19:09 <hpc> not even necessarily compacting it, but yes
04:19:21 <adnap> Well, I think abstractions should make code shorter
04:19:46 <adnap> I guess sometimes they make it more general-purpose and not necessarily shorter
04:19:50 <hpc> abstractions make code more composable
04:19:52 <typoclass> hpc: ... compacting code by 3 lines, expanding the imports by 5 lines
04:19:54 <typoclass> ;)
04:20:01 <adnap> lol
04:20:02 <hpc> which usually correlates with small, but not always
04:20:19 <haasn> abstractions should make code more elegant, where elegance is a function of shortness, clarity, composability and sometimes ingenuity
04:20:23 <hpc> @quote Control.Arrow
04:20:23 <lambdabot> EvilTerran says: if three of those lines aren't import Control.Monad; import Control.Arrow; import Control.Applicative;, you can make it shorter ;]
04:20:25 <adnap> I don't like to make things too general-purpose right away either
04:20:32 <adnap> It can end up being a waste of time
04:20:46 <haasn> hpc: needs hotfixing for Control.Lens
04:20:51 <hpc> haha
04:21:31 <hpc> needs hotfixing for Prelude.PHP, more like :D
04:21:44 <haasn> best module on hackage
04:21:56 <typoclass> adnap: yes, that's a good insight. people have sometimes called it yagni (you ain't gonna need it), to defend against needlessly adding a myriad options, configuration settings, etc.
04:22:57 <haasn> of course there's always a difference between production code and something you write for fun
04:23:17 <haasn> if you're writing for fun and feel like abstracting something as far as you can manage, I say go for it, you might come up with the next Monad
04:23:34 <zvrba> is it worth to buy a paper copy of RWH?
04:23:39 <yitz> adnap: yes generalization can be good even if yagni if it makes the code simpler, but not otherwise
04:23:55 <haasn> does the paper copy of RWH come with small paper fold-outs to include the comments section after every paragraph? =)
04:24:35 <zvrba> haasn: no :)
04:24:51 <typoclass> zvrba: depends on what you like. however, it is available for free online, and it is a few years old at this point (aren't they working on a new edition ...?)
04:24:55 <hpc> haasn: and do the fold-outs update in realtime?!?!
04:24:57 <yitz> haasn: and postage-free envelopes for each, so that you can add comments and send them in
04:25:09 <haasn> hpc: only for the ebook variant
04:25:22 <DrTeggy> zvrba: buy the paper copy and encourage the authors to write a 2nd ed (which was indeed planned at some point, IINM)
04:25:30 <haasn> (the kindle supports fold-outs, right?)
04:25:52 <hpc> the kindle supports html, so you might be able to ajax something horrifying
04:25:57 <yitz> haasn: yes but you usually send it in for warranty service when that happens
04:26:31 <yitz> haasn: that happened to my nexus 7
04:36:01 <gertc> i would like to create a /etc/group like thing in haskell to verify permissions but i end up with a Map that has a groupId and allot of [users] in it. Is a big list with intgers to see if a user is in that group ok or should i do it differently?
04:38:24 <Entroacc1ptor> don't you usually have to see which groups a certain user has?
04:38:47 <gertc> yes
04:38:55 <Entroacc1ptor> so it's probably easier to just have [groups] associated to the user
04:39:31 <gertc> yes but i was thinking there must be a goed reason for linux to do it the other way around :)
04:39:49 <barrucadu> Linux doesn't do it the other way around, if you look at /etc/group it has no users in it
04:40:12 <barrucadu> Oh, /etc/group- does. Ignore me.
04:40:37 <typoclass> barrucadu: i just checked and was surprised that it seems to have the format "group name : something : group id : list of users"
04:41:51 <gertc> one reason i can think of its easier to assign groups to users?
04:42:49 <typoclass> gertc: if your lookups usually are "i have a user and want to know their groups", then i'd go with a map as Entroacc1ptor suggested. if your lookups usually are "i have a group and i need to know if it contains user X", then the other way round might be more natural
04:43:02 <barrucadu> I guess it could be because groups are used for permissions, and so asking "is this user in this group" is a more common operation than "what groups does this user belong to"
04:44:12 <typoclass> gertc: i think the difference really just is if using the data structure will be a little more work or a little less work
04:46:50 <gertc> which is the fastest? finding a index in a map or finding a intger in a array?
04:48:02 <danr> gertc: I don't know what you mean with index in a map, but if your array is sorted you can binary search it in logarithmic time
04:48:40 <gertc> wait i make example
04:49:06 <alexander__b> haasn: quick summary of jcarmack's haskell points: haskell is the best functional language he can think of. static typing rulz. pure functions is brilliant because it prevents programmers from thinking "what harm can this state change do... it's just once...".
04:49:38 <alexander__b> haasn: he thinks laziness is kind of overrated, but definitely not a bad thing. he didn't really have any "complaints" about haskell.
04:49:47 <haasn> hmm interesting
04:49:56 <haasn> I was expecting more criticism from somebody so deeply entrenched in the actual industry
04:50:35 <haasn> laziness is overrated, it's nonstrictness that counts =)
04:50:38 <alexander__b> haasn: with C and multi-paradigm languages, he said all code that is syntactically viable -- i.e. all code that the compiler will accept -- is going to at some point make it through to their codebase. haskell being so pure prevents this.
04:51:08 <haasn> alexander__b: the joke being that haskell does nothing to prevent this, of course; we have unsafeCoerce and unsafePerformIO ;-)
04:51:27 <Iceland_jack> haasn: Judicious use of SafeHaskell?
04:51:29 <alexander__b> static typing makes it usable for code that will exist over many generations of iterations, which is where he feels lisp will fail -- huge legacy systems.
04:51:47 <alexander__b> haasn: haskell very much encourages pure functions.
04:52:42 <haasn> if anything, Haskell does the right thing by prefixing ‘unsafe’ in front of everything that seriously violates any and all assumptions
04:53:04 <haasn> I only wish the paradigm extends to unsafeHead, unsafeError etc.
04:53:08 <Iceland_jack> hah
04:53:19 <Iceland_jack> I've heard people seriously complaining that "unsafePerformIO" should have a shorter name, apparently it takes too long to write
04:53:31 <haasn> I like reallyUnsafePtrEquality
04:53:43 <mauke> Iceland_jack: oh wow. where?
04:53:44 <alexander__b> when doing wolf3d in haskell he has only one file with monads and io stuff, and everything else is pure functions
04:53:56 <haasn> alexander__b: sounds like good Haskell
04:54:18 <alexander__b> he did say he doesn't think haskell has any good debugging tools
04:54:39 <haasn> I think the value of GHCi as a debugging tool is highly underrated and underused, even by myself
04:54:44 <alexander__b> for c(++) there are a bajillion tools, of course.
04:54:46 <haasn> I'd like to learn more about debugging in GHCi
04:54:48 <Iceland_jack> mauke: I won't name any names, but the person in question wanted to use it in the IO monad....
04:55:21 <alexander__b> I don't know of any static code analysis tools of the same wild complexity as some of the c(++) tools, but then again I'm not very knowledgable with haskell tool stuff.
04:55:59 <haasn> Iceland_jack: we have a short version of unsafePerformIO that lives in the IO monad, it's called id
04:56:02 <Iceland_jack> hah
04:56:11 <arkeet> safePerformIO :: IO a -> IO a
04:56:41 <mauke> safePerformIO :: IO (IO a) -> IO a
04:56:55 <arkeet> no
04:56:56 <arkeet> ;)
04:57:01 <gertc> what was the new hpaste url again
04:57:07 <arkeet> it's in the topic
04:57:09 <typoclass> @where paste
04:57:10 <lambdabot> http://lpaste.net/new/haskell
04:57:25 <gertc> thx
04:57:29 <FreeFull> mauke: join is shorter to write than safePerformIO
04:58:40 <haasn> it's even shorter to avoid the use of ‘join’ completely by using >>= to abstract it away
04:58:41 <Iceland_jack> The lack of "safePerformIO" is the reason Haskell will never become mainstream!
04:59:38 <arkeet> it exists, and its name is very short!
04:59:42 <Iceland_jack> (hush!)
04:59:44 <arkeet> :(
04:59:47 <Iceland_jack> :)
05:00:10 <danr> :t (fmap id unsafePerformIO) `asTypeOf` join
05:00:11 <lambdabot> Not in scope: `unsafePerformIO'
05:00:12 <haasn> alexander__b: does the type system count as a static analysis tool?
05:00:38 <arkeet> yes!!
05:01:06 <Iceland_jack> Haskell is certainly lacking in debugging/analysis tools, especially compared to languages like C/C++/Java
05:01:07 <alexander__b> haasn: no that's a tool to prevent having to do static analysis
05:01:10 <haasn> I wonder if it would be possible to thread a static representation of all your haskell code into the type system alongside the regular types
05:01:30 <Iceland_jack> but they're not as important in Haskell
05:01:45 <haasn> and then include static proofs and stuff as extra functions :: ... => () in your code
05:03:03 <typoclass> Iceland_jack: for debugging tools, yes. but afaik static analysis refers to "extended compilers", e.g. a tool that understands so much of c that it can tell if this or that pointer may be null or not. arguably we have that available in ghc anyway (Maybe and such)
05:04:20 <Iceland_jack> That's right
05:04:28 <hpaste> gertc pasted “/etc/groups” at http://lpaste.net/91548
05:04:42 <danr> luite: nominolo: do you know what the status of source plugins are? http://www.haskell.org/pipermail/ghc-devs/2013-June/001556.html
05:06:42 <haasn> hmm
05:07:05 <haasn> seems like there's no easy way to represent the lifted constructors of kind Name, via TH/DataKinds
05:07:29 <haasn> I was thinking about passing a phantom type :: Exp along on the type level
05:07:32 <Iceland_jack> I wonder, are there any particular debugging facilities that people miss in Haskell?
05:13:54 <bartavelle> Iceland_jack, a debugging experience that doesn't feel like "reading the mind of someone with ADHD"
05:14:35 <Iceland_jack> fair enough ;-)
05:15:44 <quchen> Iceland_jack: Function doesn't do what you want, but typechecks and everything. You now want to look inside.
05:16:37 <quchen> Debug.Trace is often useful, but a little hacky. Like cout debugging in C++.
05:17:20 <tero-> in functional code, there few things that quickcheck cannot catch
05:17:22 <quchen> Luckily there's not a lot of global state, so once you pinpoint down the problem you're left with debugging the last 10 lines in question.
05:17:42 <haasn> quchen: and less useful
05:18:14 <gertc> Does the following have equal performance if x and y are known and just want a True or False result? http://lpaste.net/91548
05:18:26 <Iceland_jack> I think for a language like Haskell something like type holes would be far more valuable, not that the suggestions here wouldn't be useful
05:18:53 <quchen> Iceland_jack: There are type holes already, and 7.8 beefs them up a bit.
05:19:12 <quchen> data Hole = Hole  -->  Type mismatch: found Hole, expected <type>
05:19:21 <Iceland_jack> gah! that's too hacky
05:19:42 <haasn> what I want is the ability to express partial type signatures easily
05:19:48 <Iceland_jack> I'm aware that they added it to GHD, they haven't added support for it to haskell-mode like they do with Agda though?
05:19:55 <haasn> someList :: [_] -- where the thing in the middle is some complicated type that I don't really care about here
05:20:06 <Placinta> Is it possible / a good idea to store a Sql Connection Pool inside a ReaderT, instead of passing the pool as an argument?
05:20:39 <typoclass> Placinta: that sounds like a pretty standard thing to do
05:20:49 <mauke> @unmtl ReaderT e m a
05:20:49 <lambdabot> e -> m a
05:20:52 <quchen> Placinta: Sure, Reader is often used to have things like connections or TChans handy.
05:20:58 <danr> haasn: do you know if there is a ticket for that?
05:21:20 <Placinta> typoclass: quchen: Thanks, I'm just learning, so it occured as an idea.
05:21:25 <danr> haasn: there's Oleg's h98 solution of course: http://okmij.org/ftp/Haskell/types.html#partial-sigs
05:21:29 <Iceland_jack> *GHC
05:21:30 <mauke> > (\x -> x * 2) 21
05:21:31 <lambdabot>   42
05:21:32 <haasn> danr: no idea, though it can easily be worked around eg. let _ = someList `asTypeOf` (undefined :: [a]) in ...
05:21:39 <mauke> > (do x <- ask; return (x * 2)) 21
05:21:40 <lambdabot>   42
05:21:42 <haasn> danr: yes that's basically the same thing
05:21:46 <haasn> as what I just mentioned
05:22:26 <danr> yeah, it's not particularily elegant
05:22:32 <Placinta> haasn: Yesterday I stumbled upon the need of partial type signatures as well :( . I've seen an issue in trac, that it is apparently disscussed and worked upon?
05:22:58 <quchen> Placinta: Reader's purpose is getting rid of passing an immutable environment along all the time, I think that's just what you need.
05:23:44 <Placinta> quchen: The thing that bugged me, is that the pool is actually kinda mutable? That's why I thought it wouldn't work with Reader
05:23:56 <quchen> Placinta: In a concurrent scenario for example, I have a global variable that stores the different communication channels, and that variable is passed along to all functions. If I need to send a message to some other thread, `asks toMain` will get me the channel.
05:24:19 <bartavelle> Placinta, you most likely have a reference to the pool, this reference will not change
05:24:38 <bartavelle> it is probably some native structure underneath
05:24:48 <quchen> Placinta: There's an important difference between the immutable connection object, and the mutable connection it points to. Reader stores the connection, and that's fine. To actually use that connection, you'll have to go IO.
05:24:59 <mauke> Placinta: Reader is 100% equivalent to function parameters
05:25:18 <bartavelle> mauke: not exactly, as reader doesn't let you change the parameter in a sub-call
05:25:43 <quchen> Placinta: Similarly, a TChan is immutable, it's a constant pointer to the channel. Writing to a TChan means modifying the thing it points to, but not the pointer itself.
05:25:47 <haasn> :t local
05:26:04 <mauke> bartavelle: yes, it does
05:26:16 <bartavelle> ah !
05:26:17 <Placinta> quchen: I see. But If i want to store a sql connection, or a tchan in a reader, that essentially means I'm dirtying the function with IO?
05:26:34 <mauke> @botsnack
05:26:39 <bartavelle> well at least it better documents the intent
05:27:07 <quchen> Placinta: Only when you want to use it from within the Reader. If your function does only store the connection (instead of using it to communicate etc) you're fine without IO.
05:27:11 <typoclass> Placinta: you can pass around the connection pool purely. but to use any of the connections, you're going to need IO anyway (or something built on top of IO)
05:27:15 <haasn> :t withReader
05:27:24 <haasn> :: (r' -> r) -> Reader r a -> Reader r' a
05:27:29 <bartavelle> mauke: my bad, I never knew there was a "local" thingie
05:27:31 <nh2_> somebody with a mac around who knows what GNU ar is?
05:27:52 <quchen> Placinta: A connection pool has type [Connection], which is a pure value like everything else in Haskell. You can call `head` on it, you can calculate its length, …
05:28:00 <bartavelle> nh2_, old unix compression utility, usually used when creation .so files
05:28:15 <bartavelle> well, archive utility
05:28:22 <nh2_> barrucadu: can you check if your OSX ar has an -S option?
05:28:23 <typoclass> nh2_: googling for "man ar" suggests http://unixhelp.ed.ac.uk/CGI/man-cgi?ar
05:28:27 <Placinta> quchen: Got it. Going to try and use it now.
05:28:44 <quchen> Placinta: On the other hand, a function like `askDatabase` will have a type like `ReaderT Connection IO a`, because it's going to do IO stuff with Connection.
05:29:08 <nh2_> I need to know if it has it and if yes, since when, because I try to put it into cabal
05:29:37 <quchen> Placinta: It's similar to how [IO a] is an immutable list of IO actions. Sure, the objects contained in the list are one way or another tied to side-effects, but unless you trigger them it's a pure thing.
05:29:40 <barrucadu> nh2_: I'm afraid I don't have a Mac
05:30:22 <nh2_> barrucadu: hmm then we need to find somebody
05:31:02 <typoclass> nh2_: google around. the mac's man pages are on the web in various places
05:32:19 <typoclass> oleg's partial signatures from years ago ... quite clever and remarkably simple http://okmij.org/ftp/Haskell/partial-signatures.lhs
05:32:40 <nh2_> typoclass: I know, but I would prefer to get somebody with actual mac knowledge before I break things for older macs
05:36:45 <merijn> nh2_: My man page says " -S      Do not generate an archive symbol table."
05:36:51 <merijn> nh2_: granted, that's on 10.7
05:38:18 <quchen> Can someone explain Writer's API functions to me? I haven't used anything but `tell`, and the rest confuses me to this day.
05:38:23 <nh2_> merijn: oh sorry, I meant the 'D' (deterministic) option. Is it there?
05:38:34 <quchen> `listen(s)` seems reasonably simple, although I wouldn't know a use case.
05:38:39 <merijn> nh2_: No
05:38:44 <quchen> `pass` and `censor` are awkward.
05:38:45 <nh2_> merijn: and which ar --version do you have?
05:40:43 <merijn> nh2_: OSX ships with BSD ar, which doesn't support --version
05:41:06 <merijn> nh2_: According to the man page "The ar utility is expected to offer a superset of the IEEE Std 1003.2 (``POSIX.2'') functionality."
05:41:23 <nh2_> merijn: is there some different approach to find out the actual binutils version shipped?
05:43:11 <merijn> nh2_: binutils is a GNU project
05:43:37 <merijn> nh2_: BSD derivatives don't use binutils, they have their own implementation of ar, etc.
05:43:56 <nh2_> merijn: oh, silly of me :D
05:44:49 <merijn> nh2_: Actually, I'm not sure what OSX ships with, but I thought it wasn't binutils
05:45:01 <merijn> nh2_: You can check the source to see what it supports, though
05:45:04 <merijn> nh2_: http://opensource.apple.com/source/cctools/cctools-800/
05:45:11 <nh2_> thanks
05:45:25 <merijn> Or go to opensource.apple.com to look up the source for whatever OSX version you care about
05:45:27 <gertc> if you have allot of integers and just want to check if a integer is in a list, do you use a normal list and elem or somthing else?
05:46:13 <merijn> gertc: For membership tests you might want to use Set (or in the case of Int maybe IntMap?)
05:46:26 <merijn> Oh, there's IntSet
05:46:26 <nh2_> yes http://opensource.apple.com/source/cctools/cctools-800/ar/ar.c doesn't have it unfortunately
05:46:31 <nh2_> so it looks like for now I should not use ar -D for BSDs. A bit of a shame though, because it makes noop cabal builds a lot faster
05:47:14 <typoclass> quchen: beats me. no idea what that stuff is. the original paper linked from http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Writer-Class.html doesn't seem to describe it either, only the basic 'tell' (they call it 'write')
05:47:46 <quchen> Tell is pretty useful.
05:47:54 <quchen> And also a very obvious API choice.
05:47:59 <Placinta> Wait. So Reader isn't actually immutable? You can change it with local?
05:48:01 <quchen> Kind of like ask(s).
05:48:06 <mauke> Placinta: Reader is 100% equivalent to function parameters
05:48:22 <quchen> Placinta: No, you can't. What you *can* do with local is execute a single Reader statement in a modified environment.
05:48:35 <quchen> After that, it's back to the old environment.
05:48:39 <gertc> merijn: ok thx
05:48:43 <mauke> what you can do with function parameters is call a single function with different arguments
05:49:06 <Placinta> Ah, so you define the body of the reader that takes a parameter, but you cant change the body
05:49:11 <manek> Hi! Can I test in Haskell a type of variable in a if expression? I mean - I can do: x = case y of A{} -> "...", but can I write somehow if y "isof" A{} then "..." ?
05:49:19 <mauke> manek: no
05:49:29 <nh2_> merijn: thank you, your help was very useful! (https://github.com/haskell/cabal/issues/1177#issuecomment-22102620 is the change in case you are interested)
05:49:42 <manek> mauke - can you please tell me a little more why?
05:49:47 <kwazar> Hey, im still newbie in haskell and *unix, trying to configure vim. right now i wanna just text highlighting, any good plugin
05:49:49 <kwazar> ?
05:50:01 <mauke> manek: what
05:50:02 <kwazar> i found some but i cant install it, dont know why
05:50:11 <mauke> manek: because there is no such functionality in haskell
05:50:34 <mauke> kwazar: syntax highlighting is built in
05:50:37 <manek> mauke: ok, thank you :)
05:52:08 <typoclass> manek: hello. in general, case-of does pattern matching, if-then-else takes a Bool and does one of two things. in "case ... of ... ->", you can write any expression after the ->. you can use anything you could use in the "then" part of if-then-else
05:52:58 <manek> typoclass: Thanks :)
05:52:59 <mauke> typoclass: the question was about typecase, though
05:53:11 <FreeFull> You could also use let or where for pattern matching
05:53:17 <jtanguy> manek: do you mean typeclasses?
05:53:32 <jtanguy> what is what you want to achieve?
05:53:50 <jtanguy> s/is what/do/
05:54:26 <hpaste> quchen pasted “Placinta: Using `local`” at http://lpaste.net/91550
05:54:27 <manek> jtanguy: No, I just wanted to pattern match in if expression :)
05:54:41 <quchen> Placinta: Maybe this snippet helps
05:55:10 <mauke> oh, so the question wasn't about typecase
05:55:16 <mauke> manek: sorry, I misunderstood
05:55:25 <Hugh_> hi - what language is the GHC written in?
05:55:33 <mauke> Hugh_: Haskell
05:55:55 <Hugh_> ok, that begs a question about chickens and eggs !
05:56:04 <Hafydd> No it doesn't.
05:56:05 <mauke> no, it doesn't
05:56:14 <mauke> :-)
05:56:28 <mauke> Hugh_: what language is gcc written in?
05:56:31 <merijn> Hugh_: Why? C compilers are written in C...
05:56:59 <Hugh_> ok, help me out. How can a compiler compile itself on iteration n=0
05:57:03 <Hafydd> Firstly, because of http://begthequestion.info/
05:57:06 <merijn> Hugh_: It can't
05:57:14 <Ezku> Hugh_: you don't. It's called compiler bootstrapping.
05:57:16 <Maior> Hugh_: http://stackoverflow.com/a/5657573/928098 etc.
05:57:18 <merijn> Hugh_: But that applies to C compilers too
05:57:21 <FreeFull> I don't think all C compilers are written inC
05:58:27 <mauke> yeah, e.g. gcc is written in C++ :-)
05:58:28 <typoclass> Hugh_: in some sense there is a chicken-and-egg problem. usually a compiler is first written in another language, and as the compiler matures, there may come a moment when folks rewrite it in its own language. to compile the very first binary of ghc 9.1, you'd use ghc 9.0 or 9.05 or something
05:59:12 <Hugh_> ok, got it. Makes sense. And I guess that Haskell being 20+ years old makes it well passed iteration n=0
05:59:17 <quchen> Once you have a chicken, laying an edd which hatches new chicken isn't a problem.
06:00:10 <merijn> Hugh_: yup
06:00:14 <mauke> Hugh_: hugs is a Haskell interpreter written in C
06:00:25 <mauke> Hugh_: hbc was a Haskell compiler written in Lazy ML
06:00:44 <Hugh_> ok, got it thanks.
06:01:36 <Hugh_> A different question, what is the 'bus factor' for the continued maintenance/development/support of Haskell?
06:01:45 <mauke> depends on your definition of "Haskell"
06:01:56 <Hugh_> the compiler
06:02:08 <Hugh_> not the prelude
06:02:40 <mauke> Haskell is math, not software
06:03:07 <Hugh_> ok, that is definitely not something I will be telling the bean-counters!
06:03:12 <Hugh_> but I get what you mean
06:03:16 <tdammers_> mauke: bus factor for a math theorem is still 1 when it only exists in the inventor's head
06:03:24 <ocharles> blast, missed mm_freak
06:03:36 <mauke> Hugh_: what is the bus factor of the C compiler?
06:03:54 <Hugh_> 0..n
06:03:59 <Hugh_> ;)
06:04:10 <typoclass> Hugh_: i think "getting hit by a bus" would result in ghc slowing down for a while with respect to new features being added. so, others could replace the most active developers; i don't think there's a fundamental barrier
06:04:26 <merijn> I'm pretty sure there are too many big code bases written in Haskell for any of these companies to be willing to let GHC die
06:04:31 <Hugh_> yeah, good point
06:04:37 <tdammers_> also, some compilers have been bootstrapped through manual compilation
06:04:53 <mauke> always fun
06:05:09 <Hugh_> merijn: that is kinda the sort of information I need. I need to convince managers to take a serious look at Haskell
06:05:13 <mauke> that's basically equivalent to running an interpreter in your head
06:05:33 <Hugh_> at the moment the Oracle factor is still massively skewing their corporate mindsets to Java
06:05:47 <simukis_> Hugh_: that'll be pretty hard unless haskell has some serious advantage using haskell in your problem space.
06:05:50 <merijn> Hugh_: If you ask around here, the are many people working with haskell code bases in big companies that they will then not be able to tell you anything about due to NDA's ;)
06:06:00 <typoclass> Hugh_: well at the minimal level, you can download a version of ghc today and archive that. no amount of buses can take that away from you :-)
06:06:04 <Hugh_> yes there is an advantage
06:06:11 <mauke> there are some professional consultants: http://www.well-typed.com/services
06:06:35 <tdammers> I tried to convince management of using Haskell once
06:06:54 * ocharles is gradually getting paid to write Haskell
06:06:55 <typoclass> simukis_: it depends a lot on the managers
06:06:58 <Hugh_> fellas, I get all this, I guess what I need is a Big Shiny List of Big Companies using Haskell to make my point
06:07:18 <simukis_> typoclass: sure it does.
06:07:39 <tdammers> basically, the answer I got was "You are right, something like Haskell would be a much better tool for the job, but 1. we don't have anyone who can audit Haskell, and 2. I have a hard time finding decent programmers as it stands; what do you think would happen when we switch from PHP and Python to Haskell?"
06:07:57 <tdammers> and both are valid concerns, really
06:08:00 <merijn> Hugh_: Then you should've asked for that ;) http://www.haskell.org/haskellwiki/Haskell_in_industry
06:08:01 <quchen> tdammers: "Gets rid of PHP. Booya!"
06:08:16 <tdammers> quchen: Well, we were already moving from PHP to Python
06:08:19 <Hugh_> merijn: thanks..
06:08:21 <mauke> tdammers: a possible answer to #2: the rate of decent programmers among Haskellers is higher
06:08:25 <quchen> tdammers: But yes, the programmer availability is probably a problem.
06:08:31 <tdammers> mauke: even then
06:08:47 <mauke> any monkey can read a tutorial or two and call himself a PHP developer
06:08:47 <exicer> How can I map !! to a list of lists ?
06:08:51 <tdammers> it's a much more dire chicken-and-egg problem than the compiler bootstrapping
06:08:53 <typoclass> Hugh_: it's a bit like saying the russian mafia is enthusiastic about haskell, but fwiw quite a number of finance places use some amount of haskell
06:08:53 <quchen> mauke: That's a pretty bold statement. (Which I think is true, but still you can't back it up.)
06:09:30 <tdammers> also, teaching a Haskeller some PHP or Python is trivial, but the other way around, you'll have a hard time
06:09:43 <typoclass> exicer: so you want the 5th element from a bunch of lists?
06:09:49 <quchen> tdammers: I don't think you can easily make a Haskeller write some PHP. :-P
06:10:02 <Hugh_> tdammers: indeed, until Big Corps embrace Haskell (or other lingos) fully then schools will not teach it and developers will not learn it...
06:10:03 <exicer> typoclass: For example. yes
06:10:09 <Maior> Hugh_: rofl
06:10:24 <tdammers> Hugh_: do you honestly think it takes *schools* to learn a programming language?
06:10:33 <quchen> > map (!! 2) [[1],[2,3],[4,5,6]] -- exicer
06:10:34 <Hugh_> no. not really
06:10:43 <taylorgb> Not to mention that some schools already teach it
06:10:46 <zomg> There are a lot of people in the PHP and JavaScript lands who express interest in Haskell when I tell them how great it is
06:10:47 <Hugh_> I was being /sarc
06:10:55 <Hugh_> but that is what the managers look for
06:10:56 <jtanguy> quchen: there are some functional libraries for php written by haskellers, se PHPz
06:10:57 <quchen> exicer: Note that (!!) crashes when you read an element past the end of the list, so you should probably not use it.
06:10:58 <zomg> So I think it's partially an exposure problem.
06:11:00 <exicer> quchen: Oh.. huh.
06:11:06 <tdammers> it's a chicken-and-egg problem
06:11:07 <Maior> Hugh_: your managers? mmm, fun
06:11:12 <merijn> > [1..10] !! 11
06:11:13 <shanse> I learned haskell in high school
06:11:18 <exicer> quchen: What should I use then?
06:11:21 <quchen> merijn: Lambdabot is gone :-(
06:11:23 <merijn> :(
06:11:36 <t7> why :(
06:11:37 <Hugh_> Maior: really dull big corp still wont install anything other than IE6
06:11:39 <tdammers> if more companies were to use Haskell, more people would learn it and use it in a corporate environment, which would create a larger hiring pool, which would make more companies use it
06:11:45 <Maior> Hugh_: woe :(
06:11:49 <typoclass> exicer: «map (!! 3) ["abcdef", "ghijkl"]» will give ['d','j']. note the usual caveat applies; !! can cause crashes
06:12:08 <t7> partial functions are the devil
06:12:09 <exicer> Is there a better alternative?
06:12:10 <quchen> exicer: Write your own (!!) that returns a Maybe, for example
06:12:14 <exicer> Ah okay
06:12:27 <tdammers> the fact that people are moving from PHP to Python and ({deity} forbid) node.js is quite something already, and then look at the mess that is PHP
06:12:38 <mauke> :t (listToMaybe .) . drop
06:12:53 <zomg> one of the reasons people are moving to node is because it gets good exposure in the developer circles
06:12:54 <quchen> What mauke said, without the (.) section. :-P
06:12:56 <Hugh_> I haven't used PHP since 95
06:13:20 <mauke> Hugh_: was it still written in perl back then? :-)
06:13:20 <zomg> a lot of people I know are perfectly aware of node and what it does well but if you talk to them about haskell they know nothing about it
06:13:24 <Hugh_> sorry, 2005
06:13:32 <Hugh_> losing a decade
06:13:43 <zomg> people aren't using node because it's being taught in school or because big corps are using it
06:13:56 <int-e> > flip drop "rain" 2
06:14:07 <mauke>  "in"
06:14:16 <int-e> @botsnack
06:14:22 <mauke> ಠ_ಠ
06:14:43 <typoclass> elliott: ping? lambdabot is out drinking again
06:14:45 <quchen>  /nick maukebot
06:15:03 <zomg> so I think the argument that haskell would be more popular if it was being taught or used in corps is only one way to look at it
06:15:15 <merijn> maukebot is lambdabot with every reply having look of disapproval behind it's results :)
06:15:42 <zomg> because node certainly isn't being taught, nor was it being used in big corps until it got popular to begin with =)
06:16:09 <Hugh_> maybe Haskell needs One Big Hairy Corporation to take it under its wing (/snarc)
06:16:23 <t7> snarc snarc
06:16:32 <jtanguy> the nodejs community seems to want to reinvent all the wheels
06:16:32 <zomg> I still think the issue is that haskell doesn't get the sort of exposure developers are interested in
06:16:34 <Hugh_> (looking at you, Oracle!)
06:16:34 <quchen> Haskell is probably one of those languages that people don't like because everyone says it's cool to learn but totally different. And some day, they would like to pick it up but they never do because too few curly braces. Haskell is the new Lisp.
06:16:53 <Hugh_> what bout the old Lisp?
06:17:01 <merijn> Hugh_: Intel is already working with Haskell..
06:17:07 <Hugh_> really?
06:17:12 <zomg> If you want developers to learn haskell, they need to be shown that the language solves some practical problems they are having with their existing tools
06:17:42 <zomg> it doesn't even have to be that the language solves the problems, it could just be that a library in the language solves it well
06:18:15 <klrr> ?src print
06:18:21 <merijn> Hugh_: They recently published a paper on their optimising haskell compiler
06:18:29 <merijn> klrr: "putStrLn . show"
06:18:34 <Hugh_> cool, got a link?
06:18:39 <klrr> merijn: that was what i guessed :)
06:18:43 <quchen> The main problem is the entry barrier. A previous programmer can learn a new imperative OO language in a couple of weeks reasonably well, which costs the company like $ 5000. Reaching the same level with Haskell is a one-year salary.
06:18:56 <Maior> quchen: ...really?
06:19:08 <klrr> merijn: btw, is intel going  to release their compiler? if so, how does this affect ghc, will ghc learn from it or intel compiler will take over?
06:19:11 <quchen> Going from Perl to Ruby is like learning a southern accent when you're from New York.
06:19:13 <jtanguy> it requires a different mindset, which can be long to get
06:19:13 <zomg> quchen: yeah that is a problem if you look at it from the perspective of learning it on the job
06:19:30 <merijn> Hugh_: http://www.leafpetersen.com/leaf/publications/hs2013/hrc-paper.pdf
06:19:34 <zomg> However if you actually get the devs interested in the language, they would just learn it on their own
06:19:37 <quchen> Going from Perl to Haskell is like moving to China without knowing any Chinese (modulo some false friends)
06:19:53 <zomg> but for that is what I mentioned... practical solutions to problems with existing tools
06:19:55 <merijn> klrr: Intel's compiler takes GHC generated Core, optimises that, then compiles it to C, compiling the C with ICC or GCC
06:19:57 <Hugh_> thanks
06:19:58 <typoclass> i think haskell is often viewed as incomprehensible and fatally weird, which in fairness is somewhat encouraged by much of our haddocks
06:20:28 <frankbro> Anyone familiar with using gtk and haskell? I'm trying to figure out how to pass something to various events that will be updated along the way. I see people using Data.IORef on github, is this the preferred way?
06:20:34 <t7> quchen: imagine you only knew C and someone locks you in a room with ghc(i)
06:20:39 <zomg> typoclass: I feel the existing docs and much of the material is geared towards people who are interested in languages for the sake of being interested in languages, or other academic reasons
06:20:43 <Hugh_> is Haskell also not considered cool because it is not on the JVM?
06:20:44 <zykure> merijn: aa okey
06:20:46 <t7> how long before you know how to monad?
06:20:57 <zykure> merijn: so it's kinda like a ghc optimizer=
06:21:16 <t7> Hugh_: lol what decade is it?
06:21:29 <quchen> t7: That's like learning Chinese by living with a mute Chinese person.
06:21:52 <mauke> quchen: http://upload.wikimedia.org/wikipedia/commons/0/05/EnglishChinaWriting.jpg
06:22:00 <mauke> (spoilers: "wiki")
06:22:00 <Hugh_> seriously, all the hype surrounding the JVM languages is still going on, and on
06:22:27 <zomg> There is a slowly increasing amount of people talking about haskell in a more practical fashion though
06:22:34 <Hugh_> t7: are you saying that the JVM is now obsolete?
06:22:48 <mauke> "now"
06:22:51 <zomg> which is reaching the non-academic guys better
06:23:03 <t7> the JVM is certainly not 'cool'
06:23:04 <quchen> zomg: Problem is those still have "visionary", "experimental", "curious" statusses.
06:23:23 <Hugh_> well, erm, I beg to differ. It is still attracting a lot of attention
06:23:26 <jtanguy> would you say that "Avoid success at all costs" is still a haskell motto?
06:23:31 <Hugh_> maybe unduly, but it is
06:23:32 <t7> john carmack had alot to say about haskell during the keynote, again :)
06:23:48 <exicer> One thing that, as a beginner, I have found to be a problem with docs is that nothing has examples. Just the type def and a breif description. I'm sure that is fine if you know what you are talking about, but it can be confusing to a newb!
06:23:50 <Adeon> did he say good or bad things
06:23:50 <int-e> Hugh_: don't follow the buzz of flies :P
06:23:56 <zomg> quchen: that sort of stuff gets people to try the lang if they find the concept interesting though
06:23:56 <typoclass> jtanguy: it has never quite made sense to me anyway ...
06:24:13 <Hugh_> I don't. But others do. That is why the JVM is still mega-popular
06:24:17 <quchen> zomg: True.
06:24:19 <merijn> typoclass: Marlow was saying the people misread the bracketing :)
06:24:24 <Hugh_> To say it isn't is to call the sky green
06:24:48 <mauke> Hugh_: would you call IE6 mega-popular too?
06:24:49 <merijn> typoclass: "Avoid (success at all costs)" instead of "(Avoid success) at all costs"
06:24:56 <quchen> merijn: Hehe, I've never seen it this way
06:24:57 <typoclass> exicer: absolutely true. i feel the lack of examples is the #1 problem with the docs
06:25:15 <quchen> It's time to mention "doomed to succeed"
06:25:16 <Hugh_> no. you are mixing metaphors
06:25:22 <int-e> Hugh_: and it's kind of amazing how good java virtual machines deal with the pile of dung that is the java bytecode.
06:25:33 <typoclass> jtanguy: i think they meant basically, don't add stupid stuff just to be popular. though i don't know why they phrased it so weirdly
06:25:49 <Hugh_> the facts remain that Java, Scala, Clojure, Groovy etc are still popular
06:25:58 <mauke> typoclass: it also means: Haskell was designed for research
06:26:15 <mauke> typoclass: if you become too popular, you accumulate the baggage of applications you have to support
06:26:29 <zomg> 2020: Haskell is the new PHP
06:26:32 <zomg> BU HA HA HA
06:26:33 <merijn> Ok
06:26:40 <quchen> @where ops -- zomg
06:26:44 <merijn> This conversation is now officially dull
06:26:46 <zomg> lol
06:26:58 <Hugh_> btw, don't confuse my saying it is popular with 'good'. Php is still mega-popular, but is crud in a bucket
06:27:30 <mauke> quchen: ?
06:27:37 <merijn> People seem just to be arguing "popularity matters" vs "quality matters" and no one seems to be adding any non-noise
06:27:46 <Hugh_> who is this John Carmack reference above, and what is the keynote he gave?
06:27:54 <quchen> mauke: Was just a joke because zomg called Haskell the new PHP
06:28:03 <t7> Hugh_: hand in your geek card
06:28:03 <mauke> Hugh_: http://en.wikipedia.org/wiki/John_D._Carmack
06:28:14 <typoclass> Hugh_: well-known programmer from the game industry
06:28:24 <quchen> He's like RMS, only cooler
06:28:30 <merijn> typoclass: Tat's an understatement
06:28:32 <Hugh_> ah, well not being a game enthusiast...
06:28:33 <Placinta> How can the . be legal in local f m = Reader $ runReader m . f ?           . is function composition, f is a function, whereas m is a monadic value
06:28:47 <t7> >He's like RMS
06:28:52 <Hugh_> I'm not even on Facebook, don't do gossip and hero-worship :)
06:28:56 <typoclass> Hugh_: regardless if you're playing them, programming games is technically challenging
06:29:02 <int-e> Placinta: Reader has type (r -> a) -> Reader r a; the argument is a function.
06:29:14 <mauke> Placinta: runReader m, not m
06:29:22 <Hugh_> yeah, but it doesn't keep the shareholders happy!
06:29:50 <Placinta> hmm
06:29:53 <mauke> Hugh_: I'm not on facebook either. I still know who he is
06:30:24 <Hugh_> Do you have to know who he is to get a job working with computers?
06:30:30 <int-e> Placinta: runReader is the opposite, Reader r a -> (r -> a).  so runReader m :: r -> a; f :: r -> r; runReader m . f :: r -> a,  Reader $ runReader m . f :: Reader r a. Everything is fine.
06:30:39 <Hugh_> seriously, hero worship is not my thing
06:30:46 <quchen> I really wish there were more jobs around Haskell around here, I'll be finishing my degree by the end of the year, but I've hardly seen any openings. The only company I can remember is Erudify.
06:30:50 <bscarlet> Placinta: the function application of runReader to m has higher precedence than the .
06:31:01 <quchen> It seems like you need SimonM or Dons level to get a job.
06:31:02 <Placinta> bscarlet: That's what I missed
06:31:18 <typoclass> quchen: 1. take any job 2. introduce haskell there
06:31:29 <merijn> quchen: No, haskell jobs usually get filled through professional networks, rather than posting job ads, though
06:31:34 <zomg> quchen: I've seen one opening in the entire country, and even that company rumoredly does Scala instead
06:32:07 <typoclass> Placinta: for your line of code, note that function application binds more tightly than (nearly) anything. it groups as Reader $ (runReader m) . f
06:32:14 <zomg> well, that "opening" was really an email sent to me by said company, so it really wasn't an open ad or anything
06:32:14 <taylorgb> I think it's easier to get Haskell work via contracting as there are clients who don't care how you solve their problem as long as you solve it.
06:32:23 <quchen> merijn: Hm, that may be true. I'm not in any professional networks, so this doesn't solve my problem. (Also not being able to do the AMP warnings is probably not a good recruiting reason.)
06:32:24 <Placinta> typoclass: Yes, I figured it out now
06:32:38 <merijn> quchen: Well, start networking ;)
06:33:11 <quchen> merijn: I have no idea how to do that. /nick quchen-for-hire? :-D
06:33:42 <Placinta> quchen: Thanks for the snippet explaining local
06:33:44 <typoclass> quchen: that's not really a bad idea, you know
06:33:55 <zomg> That can work but finding stuff on irc that actually is any good is a bit rare
06:34:12 <quchen> Placinta: Did it help?
06:34:15 <zomg> I've talked with a bunch of people about consulting gigs when they asked for people to hire on irc and very few of them ever materialized
06:34:34 <Placinta> quchen: After examining the implementation of the monad, it solidified it :)
06:34:39 <merijn> quchen: Go on haskellers.com, talk with people here, ask about whether they have jobs, release some libraries, etc.
06:35:09 <quchen> Placinta: Reader is pretty awkward to learn (implementation-wise), yeah
06:35:28 <quchen> Placinta: It helps writing it out in great detail, and then seeing that refactoring leads to \r -> m (f r) r or something :-)
06:35:49 <Placinta> quchen: That's just what I did. Learned to do that from Cont, cause it was impossible to understand otherwise
06:36:26 <quchen> Placinta: Reader in terms of fmap/join is super easy, but it didn't help me understand how it worked, only that it does
06:36:35 <quchen> fmap = (.);  join f x = f x x
06:37:21 <mauke> ask = asks
06:37:23 <johnw> quchen: you're looking for Haskell work?
06:37:34 <quchen> mauke: ask = id :-D
06:37:57 <mauke> if lambdabot was here, I'd :t [ask, asks, id]
06:38:19 <Placinta> Can lambdabot desugar do notation into binds?
06:38:24 <mauke> yes, with @undo
06:38:33 <Placinta> lambdabot where are you ='(
06:38:54 <zomg> johnw: I thought everyone here was
06:39:19 <zomg> except the couple guys who know literally everything about the language of course
06:39:23 <zomg> =)
06:39:53 <barrucadu> They have ascended to a higher plane, and do not need petty work
06:40:23 <mauke> I'm pretty happy with my current Perl job, actually
06:40:30 <zomg> To the q-continuum?
06:40:39 <zomg> mauke: whoa.
06:40:40 <zomg> :D
06:41:21 <typoclass> zomg: you mean they periodically show up on the enterprise to irritate the captain and generally cause chaos?
06:41:49 <zomg> they periodically show up on this channel and cause confusion
06:41:55 <zomg> so close enough I'd say
06:41:56 <zomg> :D
06:44:08 <quchen> mauke: Wait, back to ask=asks - I don't get it.
06:44:29 <mauke> me neither. I'd need lambdabot
06:45:04 <mauke> [ask, asks, id] :: [(r -> a) -> r -> a]
06:45:04 <quchen> ask :: ReaderT r m r       asks :: (r -> s) -> ReaderT r m s
06:45:13 <mauke> @src asks
06:45:24 <quchen> asks f = ReaderT (return . f)
06:45:29 <quchen> ask = ReaderT return
06:45:39 <mauke> @unmtl ReaderT r m r
06:45:48 <merijn> r -> m r
06:46:12 <mauke> :t ask ~ :t asks
06:46:32 <mauke> r -> m r  ~  (r' -> s) -> (r' -> m s)
06:46:45 <mauke> r ~ (r' -> s)
06:46:55 <mauke> wait, is that m'?
06:47:22 <quchen> I can see that  ask = asks id
06:47:25 <jtanguy> asks is basically p . ask, where p is a projection function
06:47:34 <quchen> But without the parameter it's awkward.
06:47:59 <quchen> Ah, and ask = id
06:48:09 <quchen> jtanguy: Now it's obvious.
06:48:17 <quchen> Thanks :-)
06:48:27 <mauke> asks = ($), actually
06:48:47 <quchen> Which is also (specialized) id.
06:49:00 <quchen> I tried using the Reader API for doing it, and the types didn't check out. Should've written my own small Reader.
06:50:03 <quchen> Thanks for the lambdabot substitution mauke :-)
06:50:19 <elflord> Hi all do people need to update the hoogle data ?
06:50:44 <elflord> i mean from time to time run the "hoogle data" command
06:54:15 <quchen> I wonder whether there's a non-id function in the Reader API.
06:54:34 <quchen> It doesn't look like it, but at this point `local = id` wouldn't surprise me ;-)
06:54:42 <mauke> @remember quchen I wonder whether there's a non-id function in the Reader API.
06:55:09 <mauke> preflex: remember quchen I wonder whether there's a non-id function in the Reader API.
06:55:24 <quchen> A vicious bot virus has taken them all
06:55:28 <mauke> preflex: quote-count quchen
06:55:29 <preflex>  quchen has 1 quote
06:55:34 <mauke> congratulations :-)
06:55:39 <quchen> :-)
06:55:40 <johnw> elflord: for a locally run Hoogle, yes, I have to update from time to time
06:55:51 <quchen> mauke: I feel like I've been knighted.
06:56:07 <Placinta> No instance for (MonadReader (Pool Connection) IO)  arising from a use of `ask', does that mean I'm at the wrong transformer level, and have to use lift?
06:56:16 <elflord> thanks johnw
06:56:42 <sir_quchen> Placinta: Post the code?
06:56:52 <mauke> sir_quchen: (you may find yourself in the next Haskell Weekly News)
06:56:54 <johnw> Placinta: it means you have no ReaderT in your stack
06:57:06 <johnw> or even a StateT
06:57:14 <mauke> Placinta: looks like you're in IO
06:57:16 <hpaste> Placinta pasted “ReaderT” at http://lpaste.net/91551
06:58:08 <mauke> Placinta: put a type signature on appRouter
06:58:11 <Placinta> also Couldn't match expected type `ReaderT ConnectionPool (ServerPartT IO) a0' with actual type `ServerPartT IO Response'
06:58:22 <Placinta> I wouldn't know the full type signature =(
06:59:13 <sir_quchen> Placinta: It's a "do … ask" block, therefore the function is a `ReaderT r m a`.
06:59:26 <sir_quchen> That's a good start. :-)
07:00:01 <sir_quchen> Then you set your environment to "pool" in line 7. Therefore, r = <type of pool>.
07:01:22 <quchen> What's the desired result value of the msum? That'll be of the form "m a", with the "a" being the same as the "a" in the `ReaderT` type sig.
07:02:06 <Placinta> ServerPart Response
07:02:43 <applicativ> which is ServerPartT IO Response, I guess?
07:03:23 <Placinta> I guess. I'm still not sure why sometimes its written as ServerPart Response, and other times ServerPartT IO Response
07:03:34 <quchen> Placinta: It's probably just a type synonym.
07:03:54 <applicativ> its just a synonym, i see it, this is happstack, nice
07:04:17 <applicativ> you just forgot lift, no?
07:04:41 <mauke> possibly even liftIO
07:04:50 <applicativ> ah yes
07:05:00 <Placinta> do I apply it to ask?
07:05:19 <mauke> no, to everything else
07:05:20 <applicativ> what is the outermost transformer on the desired type
07:05:47 <Placinta> I'm still confusing which is considered outermost? ReaderT? IO?
07:05:53 <applicativ> oh ask will work wherever anyway
07:06:16 <applicativ> Placinta: actually, the answer is in main
07:06:29 <applicativ> you are going to apply runReaderT to appRouter
07:06:34 <Placinta> Yes
07:06:36 <hpaste> quchen annotated “ReaderT” with “Holes for finding out types” at http://lpaste.net/91551#a91552
07:06:43 <quchen> Placinta: Try running that one.
07:06:46 <applicativ> so it is ReaderT something blah
07:06:53 <quchen> The compiler will complain "Hole found, expected <...>"
07:07:10 <quchen> That'll hopefully give you a hint what's missing.
07:07:22 <applicativ> but Placinta the type of msum
07:07:27 <applicativ> @type msum
07:07:31 <quchen> It's like going the other way round: instead of constructing the type from the code, you're using the missing type from what the compiler would like to have.
07:07:40 <quchen> MonadPlus m => [m a] -> m a
07:07:41 <Placinta> ReaderT ConnectionPool (ServerPartT IO) a0
07:07:42 <applicativ> well, its like that of dir and homepage
07:08:04 <applicativ> dir and homepage are evidently ServerPartT IO something
07:08:05 <quchen> Placinta: Then try that line as the type signature for your original code :-)
07:08:15 <applicativ> aka ServerPart something
07:08:58 <hpaste> quchen annotated “ReaderT” with “Try me” at http://lpaste.net/91551#a91553
07:09:19 <Placinta> well I forgot a return for msum
07:09:31 <mauke> System F#
07:09:43 <Placinta> But now I get a rigid error for a0
07:09:56 <applicativ> i think you dont want to return it but to lift it
07:10:23 <applicativ> who wants a ServerPartT IO blah as a return value; they want blah
07:10:33 <Placinta> oh dear, lift works
07:10:35 <quchen> Good point
07:11:02 <quchen> Placinta: Welcome to Haskell gardening, where you grow correct code from a seed.
07:11:32 <Placinta> Well, if only the error messages would have been a little more helpful
07:11:45 <applicativ> yeah, I can imagine
07:11:47 <quchen> For entertainment purposes, imagine the same problem if Haskell was dynamically typed :-P
07:12:04 <applicativ> I think once you are accustomed to these transformer stacks the errors will be clearer
07:12:13 <applicativ> at least the lift / liftIO errors
07:12:27 <Placinta> is there an inverse function for lift? Like downlift?
07:12:50 <quchen> No.
07:12:51 <mauke> runWhateverT
07:13:04 <typoclass> Placinta: usually the compiler is right and you did do something wrong, but yes, the messages can be puzzling and take a while to get used to
07:13:24 <applicativ> Placinta: it just takes off the constructor, but for Reader and State you need an initial value and so on
07:13:26 <Placinta> Sure, it's obvious I'm wrong, not the compiler.
07:13:41 <sopvop> The more type system extensions you add, the worse message you get
07:13:49 <Placinta> I can't wait for the holes extentsions in the next GHC, I hope that will ease development
07:14:01 <Placinta> extension*
07:14:35 <applicativ> it's amazing to me how good the error messages are, considering
07:14:46 <applicativ> though of course they're usually unintelligible
07:15:43 <applicativ> check out the errors in Idris for example ;)
07:15:49 <applicativ> the messages I mean
07:15:54 <elflord> when i run   conn <- connectSqlite3 "test1.db" , where is the database stored on the file system ?
07:16:11 <elflord> current directory ?
07:16:12 <Placinta> elflord: usually the directory where .hs is
07:16:13 <applicativ> evidently in "." in this case
07:16:16 <mauke> elflord: yes
07:16:21 <mauke> Placinta: what .hs?
07:16:29 <Placinta> or executable...
07:16:40 <elflord> if i want it somewhere else i will need to write the full path right ?
07:16:58 <applicativ> well, there is also "../test1.db"
07:16:58 <mauke> elflord: no
07:17:10 <mauke> relative paths work fine, as demonstrated by "test1.db"
07:17:17 <elflord> ok
07:17:31 <elflord> relative to the current dir of *.hs
07:18:07 <Zenol> Hi. They isn't any wikipedia snap page?
07:18:25 <elflord> if i use sqlite and generate the excutable file, does the end user who use my software need to have this database engine installed ?
07:18:26 <applicativ> Zenol, write one and see what happens
07:20:07 <Placinta> elflord: I think sqlite gets statically linked into the executable
07:21:09 <quchen> Placinta: 7.8 holes won't be much different from the "data Hole = Hole" approach. TypeHoles will suggest suitable functions though.
07:22:16 <typoclass> Zenol: it is a web framework written in haskell. the main alternatives are yesod and happstack
07:22:32 <Placinta> quchen: Well it's going to be useful nontheless
07:23:00 <typoclass> Zenol: not really sure what else to say :-) one of them relies more on template haskell, giving (possibly) more convenience but a little longer compile times. if that is relevant to you
07:23:06 <whald> does anyone here have experience using an WAI application with fastcgi? I have an app which runs fine using CGI, standalone (with Warp), but produces errors every once in a while when run using wai-handler-fastcgi
07:23:42 <whald> unfortunately, I don't see error messages anywhere, just that lighttpd complains the process seems to have died
07:26:45 <whald> (this also happens with an APP as simple as "return $ responseLBS status404 [] "Move along.", so I'm pretty sure it's not really my app causing the error)
07:26:47 <geekosaur> elflord, sqlite doesn't have an egine, that's the "lite" part
07:27:41 <xplat> sqlite is just a library, that uses os-level file locking primitives for preventing database corruption from multiple access
07:28:26 <elflord> i see
07:28:42 <xplat> unfortunately portable os-level file locking primitives suck, so you end up with purely serialized access to the db and it's hard to make apps robust against malfunctioning randomly from timeouts waiting for a lock
07:29:04 <typoclass> whald: how about "strace lighttpd" or something similar? then look what it is doing before it complains about the process dying. see what command line it tries to run, with what switches. what happens if you on the shell try to run the same command line?
07:29:21 <elflord> i just want to do a quick prototyping
07:29:24 <elflord> with sqlite
07:29:36 <elflord> and then will choose another one such as postsql
07:29:36 <xplat> but if it's really just a single-user single-threaded app then you won't have problems
07:30:48 <Placinta> If I a want a function to use a Reader monad to get an sql connection, but I don't want the return type to contain ReaderT, I'm out of luck?
07:31:32 <whald> typoclass, seems I'll have to do something like this. just thought someone yells "yeah, just turn magic knob X and it works." here. :-)
07:32:38 <quchen> Placinta: You can always include the `runReader` part in your function.
07:33:10 <Placinta> quchen: But it's upper in the call hierarchy, I can't do it twice.
07:33:32 <killy9999> I'm using Debug.Trace for tracing execution of my program
07:33:46 <killy9999> is there any way of making these traces strict?
07:33:47 <S11001001> Placinta: If you are saying you don't want the fact that your function requires the sql connection to be apparent in its type, then yes, you're "out of luck" in that you can't have that.
07:33:52 <quchen> What's wrong with having having a ReaderT result in a ReaderT do block?
07:34:11 <killy9999> i.e. evaluated and printed as soon as thunk containing them is created
07:34:13 <killy9999> ?
07:34:14 <Cale> killy9999: Um, they're as strict as they can be
07:35:21 <Cale> trace s x can only do anything at all when it's evaluated, and it prints s at that point.
07:35:33 <killy9999> I see
07:35:41 <Placinta> quchen: Because I'd have to do it at a higher level. Say if I had 20 functions, I don't want to send the connection value as an argument to all of them, but rather extract it from inside the function. But then my return type gets messed up.
07:35:42 <killy9999> too bad :/
07:36:19 <Cale> It's hard to say at what point the thunk is created. I suppose if it's occurring inside of a let, you could put a trace around the let.
07:37:05 <killy9999> Cale: I think that won't be possible because the thunk is created within an external library
07:37:09 <killy9999> I think
07:37:13 <quchen> Placinta: You don't send the connection value around, just a pointer to it.
07:37:14 <killy9999> and that library is Hoopl
07:37:22 <killy9999> so I'd rather not mess with its sources :)
07:37:29 <quchen> Placinta: And much of this pointer-sending can probably even be optimized away.
07:38:45 <Placinta> quchen: I meant the pointer. But still, I don't see any way around it. Either i extract the connection at a higher level, and send it as argument to the function. Or I use the ReaderT inside the function, extract it there, but then my return type isn't good.
07:39:23 <Placinta> At least that's the way I see it.
07:39:53 <S11001001> Placinta: Why isn't your return type good?
07:40:32 <quchen> Placinta: I don't understand what problem the "ReaderT all the way" approach has. Is it just about performance? What do you mean by "extracting the connection at a higher level"?
07:40:48 <Placinta> S11001001: I have a library function that expects another type.
07:40:50 <quchen> The usual way would be packing everything in a Reader and then running it once
07:41:05 <S11001001> Placinta: so lift *that* function into ReaderT w/ev.
07:42:00 <hpaste> Placinta pasted “ReaderT 2” at http://lpaste.net/91555
07:42:37 <Placinta> The path function expects a ServerPart Response
07:42:51 <Placinta> but it gets a ReaderTServerPart Response
07:44:02 <jtanguy> that's where the lift function comes in
07:44:04 <jtanguy> :t lift
07:44:16 <Cale> Placinta: ReaderT e m a is the same thing internally as e -> m a. So if you want to avoid ReaderT, you can just pass parameters explicitly.
07:44:21 <jtanguy> lift :: (Monad m, MonadTrans t) => m a -> t m a
07:45:01 <Placinta> Cale: My goal was trying to get rid of sending parameters explicitly.
07:46:08 <Cale> Well, ReaderT often won't actually make your life easier in that regard, unless you do a lot of leg-work to wrap up all the computations you're likely to need, because otherwise, you end up lifting everything all the time just to avoid passing a parameter.
07:46:24 <applicativ> Placinta: how do you want to complicate the original example
07:46:51 <zl64c> anyone uses vim to coding?
07:46:59 <Cale> zl64c: I use vim
07:47:16 <zl64c> i have problems with configuration
07:47:34 <Placinta> applicativ: I don't want to complicate it, I want it to compile. :)
07:47:46 <Cale> zl64c: The important bits are  set expandtab  and  syntax on
07:47:52 <quchen> Compilecation is a common technique in Haskell.
07:48:01 <applicativ> Placinta: what does it look like now, though; didn't it compile a while back
07:48:05 <zl64c> Cale: i downloaded it: http://lbolla.info/blog/2011/10/15/haskell-and-vim
07:48:15 <zl64c> and put to the /vim
07:48:25 <Cale> ah, I've never played with any of that fancy stuff
07:48:41 <zl64c> so, are you using any plugins?
07:48:48 <cschneid> zl64c: hdevtools is pretty slick
07:48:49 <Cale> no, just plain vim
07:48:55 <Placinta> applicativ: The previous example extracted the pool pointer inside appRouter, and sent it as parameter to all the functions inside the msum. Now I want to extract it inside the functions instead
07:49:18 <Cale> I honestly don't care at all about what text editor I'm using though. I just use vim because it loads fast.
07:49:19 <cschneid> zl64c: Bundle 'bitc/vim-hdevtools'  -- and then map au FileType haskell nnoremap <buffer> <leader>ht :HdevtoolsType<CR>  and :HdevtoolsClear
07:49:26 <Cale> I don't use any of its features :P
07:49:30 <zl64c> i need only code highlighting
07:49:46 <Cale> zl64c: vim comes with syntax highlighting for Haskell
07:49:48 <applicativ> Placinta: by 'the functions' you mean the ones in the lift $ msum [...]
07:49:59 <zl64c> Cale: set syntax=haskell?
07:50:04 <Placinta> applicativ: yes
07:50:05 <Cale> yeah
07:50:29 <Cale> zl64c: If your .vimrc has syntax on in it
07:50:33 <Placinta> applicativ: specifically insertNewNode
07:50:46 <mauke> don't :set syntax, :set filetype
07:50:49 <Cale> then it should automatically pick up the fact that you've loaded Haskell source when you load a .hs file
07:51:04 <Cale> So you shouldn't have to explicitly say
07:52:41 <zl64c> so what should i add to vimrc for auto colors?
07:52:53 <Cale> syntax on
07:52:56 <mauke> syntax enable
07:53:01 <Cale> That should just work on its own.
07:53:30 <Cale> You should also set expandtab just to make sure there are no tabs ending up in your source code.
07:53:37 <Nimatek> number one, syntax on, make it so.
07:54:04 <jtanguy> Placinta: hum. Maybe you should invert the transformer stack
07:55:16 <applicativ> Placinta where are insertNewNode and deleteSelectedNode coming from?
07:55:57 <Placinta> applicativ: What do you mean?
07:56:05 <Cale> Placinta: Why are you lifting the msum?
07:56:12 <applicativ> Placinta: did you define them or are they imported
07:56:19 <Placinta> applicativ: I defined them
07:56:27 <jtanguy> making appRouter a ServerPartT ( ReaderT ConnectionPool IO) Response ?
07:56:31 <applicativ> Cale: well, I guess Placinta could put lift inside
07:56:46 <applicativ> or map lift over the listed things
07:56:47 <Cale> Placinta: Using lift there implies that the msum itself has type ServerPartT IO Response
07:56:57 <Placinta> Cale: It was from a previous version, to make the return type contain ReaderT
07:57:03 <saml> hfaafb, hi
07:57:28 <applicativ> Placinta: oh i hadnt seen the new paste
07:57:38 <Placinta> http://lpaste.net/91555
07:58:00 <Placinta> jtanguy: I'm not sure I can do that.
07:58:14 <Cale> Placinta: Well, you should actually think a little about what it means, rather than just trying to line the types up :)  What lift does here is to turn your action of type ServerPartT IO Response into a ReaderT action which ignores the ConnectionPool that's implicitly being passed in.
07:58:34 <applicativ> Placinta: here you are constrained by the type of dir
07:58:42 <Cale> Placinta: So, if the code in there needs to use that ConnectionPool, lift is the wrong thing to be doing.
07:59:15 <Cale> Unless you want to ask for the ConnectionPool, and pass it explicitly.
07:59:20 <Cale> (beforehand)
07:59:33 <lpsmith> hmm,  does ByteString guarantee that there is at least one addressable byte after it's  char*  buffer?
07:59:38 <applicativ> Cale , lift arose in the discussion of this http://lpaste.net/91551
07:59:39 <Placinta> Cale: That means each function in the sum has to take the pool argument, which I'm trying to avoid
08:00:03 <Cale> Placinta: right
08:00:07 <lpsmith> Might be useful to check if there is a null to see if you don't need to copy a bytestring on it's way to a c function that expects a null-terminated string
08:00:16 <Cale> Placinta: So, you'd rather not lift that msum or its contents.
08:00:26 <lpsmith> but if that byte can change because it's not allocated in the buffer...
08:00:30 <Cale> Placinta: However, what's the type of dir?
08:00:48 <Placinta> dir :: (ServerMonad m, MonadPlus m) => String -> m a -> m a
08:01:12 <applicativ> and the type of 'path'?
08:01:15 <Cale> Okay. Is there an instance ServerMonad m => ServerMonad (ReaderT e m) ?
08:01:36 <Placinta> > path :: (FromReqURI a, MonadPlus m, ServerMonad m) => (a -> m b) -> m b
08:01:50 <applicativ> ah
08:02:26 <Cale> Ah, this is Happstack, right?
08:02:33 <Placinta> Yes
08:02:36 <Cale> It looks like they didn't provide an instance of that sort...
08:02:45 <Cale> But I think you can probably write one.
08:02:56 <jtanguy> Cale: the instance is defined
08:03:25 <Cale> jtanguy: Oh, is it? Then everything should be okay if you just remove the lift, I think?
08:03:31 <lingxiao> Hey does anyone know of any good bi-directional coroutine packages?
08:03:36 <lingxiao> or just attempts, haha?
08:03:37 <Cale> (or Placinta does, rather)
08:04:07 <hpaste> Placinta annotated “ReaderT 2” with “ReaderT 2 (annotation)” at http://lpaste.net/91555#a91557
08:04:28 <Cale> lingxiao: I don't know what that is, but maybe: http://hackage.haskell.org/package/monad-coroutine-0.8
08:05:24 <Placinta> Yes, the instance is defined.
08:05:27 <lingxiao> thanks! By bi-directional I mean a coroutine that can yield both upstream and downstream
08:05:54 <lingxiao> as oppposed to only yield downstream and await from upstream, like Monad.Coroutine, or pipes or machines
08:05:56 <applicativ> lingxiao: pipes yield and await in both directiions
08:06:11 <lingxiao> oh it does? man gotta read more carefully
08:06:20 <applicativ> lingxiao: are you thinking of conduit's pipes?
08:06:30 <applicativ> the type is called Proxy
08:07:00 <applicativ> lingxiao: there's a new version coming out any minute you  might as well look at it
08:07:03 <applicativ> https://github.com/Gabriel439/Haskell-Pipes-Library
08:07:41 <ocharles> i think we're just tieing up loose ends now
08:07:47 <ocharles> so yea, 4.0.0 is imminent
08:07:57 <applicativ> though the bidirectionalness is being somewhat downplayed, so maybe the old tutorial may be better for your purposes
08:08:10 <Placinta> For some reason The ServerPartT dissapears in the type. Maybe I need a nested do.
08:08:17 <applicativ> oh hi ocharles
08:08:20 <ocharles> hallo!
08:08:23 <lingxiao> applicativ : ah thanks a lot, I played with pipes a while ago, must have forgotten. Thanks for the reminder!
08:08:24 <gertc_> ...>>= \x -> f x >>=... how can i squese a print in there without using do?
08:08:47 <gertc_> i mean a print x
08:08:57 <bergmark> gertc_: you might want Debug.Trace
08:08:58 <applicativ> ...>>= \x -> (print x >> f x) >>=...
08:09:02 <Cale> \x -> print x >> f x >>= ...
08:09:17 <gertc_> thx :)
08:09:24 <jtanguy> Placinta: what happends if you specify the type of insertNewNode explicitely ?
08:09:27 <applicativ> it does sound like you are asking for Debug.Trace somehow, gertc_
08:09:39 <Cale> (You probably should just use do)
08:09:47 <applicativ> @quote oasis
08:09:54 <applicativ> oh no lambdabot, grr
08:10:12 <mauke> preflex: quote * oasis
08:10:40 <applicativ>  <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency
08:11:10 <preflex>  <patterner> this channel is an oasis of intelligence in a sea of dumbness
08:11:24 <mauke> preflex: quote-count * oasis
08:11:25 <preflex>  * has 1 quote containing "oasis"
08:11:28 <Cale> elliott: hey!
08:11:28 <mauke> :-/
08:11:42 <Placinta> jtanguy: Will try
08:11:47 <zl64c> i found this rc: https://github.com/skwp/dotfiles/blob/master/vimrc
08:11:56 <zl64c> copied it and still nothing ;/
08:12:05 <mauke> zl64c: nothing what?
08:12:16 <jtanguy> Placinta: Which DB library do you use?
08:12:18 <zl64c> no syntax highlighting
08:12:54 <Placinta> jtanguy: Persistent
08:13:19 <gdeest> Ouais ok
08:13:53 <cschneid> zl64c: might want to go ask in #vim - they can get you setup. Setting syntax on should do it
08:14:44 <Placinta> Okay I fixed it
08:14:53 <Placinta> I needed a couple more lifts
08:14:58 <zl64c> ok, i will try
08:15:09 <Placinta> But this was more guesswork, and more pain than gain
08:15:16 <augur> if haskell had a nice interactive editor you'd never need such guesswork :(
08:15:47 <Placinta> Well, If I had more experience there would probably be less guesswork
08:15:49 <Cale> Placinta: Can I see the code which works?
08:15:55 <jtanguy> Placinta: out of curiosity, could you show us the final paste?
08:16:12 <hpaste> Placinta annotated “ReaderT 2” with “ReaderT 2 (annotation)” at http://lpaste.net/91555#a91559
08:16:48 <Cale> btw, instead of lift . lift here, you can use liftIO
08:16:57 <bergmark> was just going to say that!;o
08:16:58 <jtanguy> the two `lift $ runDB pool $ do` on two consecutive lines seems weird
08:17:13 <Cale> and yeah, you can lift . lift $ do ...
08:17:18 <applicativ> nothing quite like a long sequence of runResourceT $ runNoLoggingT $ flip runSqlPool pool
08:18:18 <ocharles> applicativ: don't forget hoist lift hoist hoist lift . runRunnerT
08:18:19 <applicativ> or define superlift = lift . lift
08:18:41 <Placinta> Is runResourceT $ runNoLoggingT $ flip runSqlPool pool bad practice?
08:18:46 <applicativ> well, hoist actually is pretty amazing I take it all back
08:18:55 <applicativ> Placinta: no not at all
08:18:58 <Cale> Placinta: I'd get rid of the flip :P
08:19:10 <Cale> and not chain the $'s, but that's just me :)
08:19:12 <applicativ> Cale: bah
08:19:30 <Placinta> How do I get rid of the $ ?
08:19:32 <applicativ> Placinta: no .. import Control.Lens and use ?? in place of flip
08:19:45 <applicativ> parentheses?
08:19:47 <mauke> Placinta: replace all but the last $ by .
08:20:00 <Placinta> But that's almost the same
08:20:05 <danr> (`runSqlPool` pool)
08:20:08 <mauke> yes, but it doesn't chain $
08:20:13 <Cale> actually, if you leave the flip in, you can turn both the $'s into .'s
08:20:22 <Cale> and kill off the explicit action parameter
08:20:35 <applicativ> or do like me, and import Prelude hiding ((/)) then define (/)=($) and get $$$ out of your life
08:20:48 <Cale> applicativ: ohgodwhy
08:21:00 <applicativ> because i dont ever use /
08:21:05 <applicativ> i can't even remember the type
08:21:23 <applicativ> I don't this much, but I have a keybinding at the ready!
08:21:58 <applicativ> all the good keys were stolen by arithmetic
08:22:00 <mauke> (/) :: Double -> Double -> Double
08:22:06 <applicativ> for examlpe
08:22:15 <applicativ> I never use Double
08:22:18 <applicativ> okay sometimes
08:22:23 <Cale> (/) :: Fractional t => t -> t -> t
08:22:27 <applicativ> Int too for prelude things
08:22:47 <applicativ> arithmetic is an unusually tedious dsl that has taken over my programming language
08:22:54 <applicativ> well from the beginning
08:23:33 <applicativ> I want Prelude.NonNumeric
08:23:56 <mauke> stupid computers, always trying to make me compute
08:24:09 <applicativ> what does computation have to do with double and int
08:24:33 * applicativ ceases absurd rant
08:24:42 <Placinta> Can lambdabot infer the type of each row in a do statement?
08:24:44 <c_wraith> applicativ: gotta think more like a computer.  (Soon we'll give you only bool as a type)
08:25:00 <applicativ> c_wraith: I avoid bool too
08:25:39 <applicativ> I thought our effort was to think less like a computer
08:25:46 <applicativ> oh wait ranting again
08:26:05 * applicativ grasps one arm with the other like Dr Strangelove
08:32:56 <Placinta> Oh I completely forgot. Thanks guys for the help. You are awesome.
08:35:18 <quchen> c_wraith: Or even worse, a data type with only two values!
08:36:44 <h4199> 0_o and _|_
08:38:09 <quchen> data Unit = O_o
08:38:30 <nicoo> > data Unit = O_o
08:38:48 <augur> undefined is undetectable, right?
08:38:49 <nicoo> No lambdabot ?
08:38:54 <nicoo> ;_;
08:38:59 <tikhon> augur: in general
08:39:00 <augur> > 1 + 1
08:39:09 <augur> no \bot D:
08:39:15 <augur> tikhon: in haskell i mean
08:39:22 <quchen> augur: Warning on "undefined" would be a useful compiler flag actually.
08:39:34 <tikhon> if you mean `undefined' as the actual value, then it just throws an exception
08:39:38 <augur> quchen: im pretty the compiler does that, yes
08:39:46 <tikhon> if you mean ⊥ in general, then you can't always detect it
08:39:51 <augur> i mean "undefined"
08:40:10 <tikhon> I believe you can catch it in IO
08:40:41 <merijn> undefined is just error, I'm not sure whether that's an instance of Exception, I think not?
08:40:42 <augur> i was just wondering if types behaved technically like they have +1 element like the denotations putatively have or if it was genuine, implicit failure semantics
08:40:46 <tikhon> but I never really use exceptions, so I wouldn't know how to do it
08:41:11 <tikhon> augur: I'm not sure exactly what you mean by that
08:41:14 <augur> given haskell's love of monads, it'd be nice if we could force all errors through monadic computation
08:41:35 <tikhon> one way an expression can be ⊥ is by not terminating
08:41:39 <tikhon> and you can't detect that in general
08:41:41 <augur> tikhon: well, the denotational semantics of silent failure is usually to interpret a type A as something basically like Maybe A
08:41:55 <augur> which you can obviously do in haskell explicitly
08:42:02 <danr> you catch undefined by catching ErrorCall: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception-Base.html#v:ErrorCall
08:42:16 <merijn> augur: Undefined throws ErrorCall, which is an instance of Exception and can thus be caught
08:42:28 <augur> but haskell's undefined is essentially the same thing as this -- all types are implicitly Maybe A's using haskell's internal errors instead of the user defined ones
08:42:38 <augur> (or using Either String, instead of maybe, but you get the point)
08:42:42 <tikhon> Haskell's undefined is one particular way of failing
08:42:50 <tikhon> semantically it's equivalent to not terminating
08:42:54 <augur> well
08:42:55 <tikhon> e.g. you could write undefined as
08:42:58 <tikhon> undefined = undefined
08:43:03 <tikhon> and then you couldn't really catch it
08:43:03 <augur> semantically it can be made equivalent
08:43:05 <merijn> augur: You need a total language (see Agda) for that
08:43:16 <augur> but thats a choice made for simplicity :)
08:43:19 <augur> merijn: yes i know :D
08:43:29 <augur> and im a big fan of agda!
08:43:38 <tikhon> yeah
08:43:52 <tikhon> and to preserve that simplicity, I never expect exceptions to be caught in my code
08:43:53 <applicativ> catch x (\(ErrorCall s) -> case s of "Prelude.undefined" -> return (); _ -> ...)
08:44:00 <augur> i was just thinking it's sort of humorous that haskell had implicit IO but changed to monadic IO
08:44:05 <augur> because semantics!
08:44:12 <augur> but it still has implicit errors/partiality
08:44:26 <tikhon> I guess people like Turing-completeness
08:44:42 <augur> you dont need implicit errors/partiality for turing completeness
08:45:03 <tikhon> functions could still be implicitly partial
08:45:16 <augur> they always _could_ be
08:45:36 <tikhon> unless you throw away Turing completeness and force all of them to be total
08:46:04 <tikhon> if you're just worried about exceptions in pure code, that's entirely understandable
08:46:26 <augur> you can avoid becoming incomplete (at least for the useful stuff) while still being total
08:46:33 <augur> for some definition of total
08:46:52 <augur> AH!
08:46:54 <augur> i just realized!
08:47:14 <augur> i mentioned lazy IO the other day, and how it'd be nice to have something about evaluation order in the type system
08:47:47 <augur> but i just realized, stupidly should've done so sooner, than laziness is very much like coalgebraicity (especially since the semantics of lazy languages is often done with coalgebras)
08:48:02 <augur> and those are definitely representable in the type system
08:48:14 <augur> i wonder how explicit coalgebraic effects look
08:48:41 <ocharles> augur: isn't laziness caputered in the type system in Agda, with coinduction?
08:48:43 <applicativ> kind of like exceptions
08:48:51 <ocharles> or is that something different?
08:48:56 <augur> ocharles: thats what i just said x3
08:49:09 <augur> well, not the agda part
08:49:10 <ocharles> augur: ok, this stuff is very alien to me so I don't know when I'm saying the same thing as someone else :)
08:49:10 <augur> but
08:49:19 <augur> agda has coinductive types
08:49:31 <augur> i dont actually know if agda's IO system is coalgebraic tho
08:49:36 <applicativ> yes, like data Empty and ->
08:49:40 * hackagebot yesod-dsl 0.1.1.4 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.4 (TeroLaitinen)
08:49:57 <applicativ> no one one knows anything about agda's 'IO system'
08:50:03 <augur> applicativ: :D
08:50:08 <augur> not even NAD?!
08:50:09 <augur> D:
08:50:17 * applicativ is a prosyletizing idrisite
08:50:25 <augur> pah, idris
08:50:29 <augur> EPIGRAM2 FOREVER
08:50:38 <applicativ> no, Idris is better
08:50:41 <augur> (because thats how long itll take to get it!)
08:50:47 <augur> (>_>)
08:51:05 <augur> i write all my code in dependently typed binary
08:51:08 <applicativ> these questions have all been answered
08:51:37 <augur> i really shouldnt say that because its both false but possibly true
08:51:51 <augur> what with irene-knapp's dependently typed binary format >_>
08:52:12 <augur> a friend of my was interested in writing a DT assembly language
08:53:10 <levi> Whatever happened to Epigram2?
08:53:28 <applicativ> it's Epigram24 now, I think
08:53:34 <augur> levi: everyone stopped caring and/or having time to work on it, i think
08:54:06 <augur> levi: conor told me he was gonna put the source code up on github, but i dont think he did it
08:54:10 <augur> i should bug him about it again
08:54:55 <applicativ> https://github.com/brixen/Epigram
08:55:10 <augur> i still wonder if it'd be possible to have a nice idiom-bracket-like syntax for monadic computation instead of lift's and such
08:55:30 <augur> applicativ: epig1 /= epig2 !
08:55:40 <applicativ> that's epig2
08:55:41 <augur> so do we know this is epig2?
08:55:43 <augur> \o/
08:55:49 <augur> cant be the whole of it tho
08:55:52 <augur> its from 3 years ago
08:58:31 <phulin> Should TH be able to cause GHC to panic - i.e., if I'm seeing a GHC panic, is it definitely a GHC bug or is it a bug in the library?
08:58:40 <applicativ> its out of date of course; you can send a patch to Brixton augur
08:59:40 <byorgey> phulin: if you see a GHC panic it is always a GHC bug.
08:59:53 <applicativ> that's certainly what the message says
09:00:07 <phulin> okay, sounds good
09:00:22 <applicativ> It might be difficult in the context of TH to figure out what the real bug is though, or am I wrong
09:01:09 <levi> augur: His blog just seemed full of all sorts of energy and development, and then suddenly stopped without any mention of why.
09:01:48 <phulin> Testing again against 7.6.3 then will file a bug
09:01:59 <phulin> (this was with 7.4.1)
09:01:59 <augur> levi: you'd have to ask him why
09:02:07 <augur> he seems to have dumped all that energy into twitter x3
09:02:16 <phulin> applicativ, byorgey, thanks
09:05:34 <hpaste> sutabi pasted “Either Recursive Function?” at http://lpaste.net/91564
09:06:03 <sutabi> How can I use Either for a recursive function? http://lpaste.net/91564
09:06:29 <johnw> you don't need to do Left $ gameloop
09:06:31 <johnw> just call gameloop
09:07:03 <johnw> although, I don't see why you'd be using Either at all
09:07:49 <sutabi> johnw: its when I just want to return "world" instead of "gameloop"
09:08:01 <johnw> but that's the only time you return at all
09:08:05 <quicksilver> gameloop isn't a type
09:08:13 <quicksilver> it looks like you always return a World in the end
09:08:19 <johnw> so you don't need to distinguish Left from Right; just return or don't
09:08:23 <quicksilver> it's just a question of returning immediately or recursing
09:08:27 <johnw> exactly
09:10:29 <sutabi> If I return nothing, then I need to change the type to Maybe, and handle the recusion somewhere else?
09:10:48 <johnw> but you don't return nothing
09:10:55 <johnw> you either return a World or you keep recursing
09:11:38 <bscarlet> when you keep recursing you're still (eventually) returning a world
09:12:05 <sutabi> johnw: ok, haha I was a little slow on that
09:16:47 <sutabi> so If I am just returning world the signiture gameloop :: World -> World is wrong for recusion?
09:17:03 <Cale> sutabi: That's right.
09:17:10 <johnw> why do you think that recursion is expressed by the type?
09:17:57 <sutabi> johnw: no idea but my main function is freaking out becuase it doesn't know what it is returning so I figured I need a signature.
09:19:20 <edwardk> > take 10 $ let gold = "1":"10":zipWith (++) (tail gold) gold in gold
09:19:29 <edwardk> no lambdabot?
09:20:41 <bscarlet> sutabi: have you played with recursion much?
09:21:14 <t7> lambdabot decided node.js was the future
09:21:29 <Zenol> applicativ: I did it (you told me to create the page, not to fill it with content :) ). Let's see what happens!
09:22:25 <applicativ> hah https://en.wikipedia.org/wiki/Snap_(web_framework)
09:22:42 <applicativ> the avenging editors will get rid of it in no time
09:24:17 <gertc_> i want to use IntMap but the id numbers i get from google are for example 999999999999999999999 how can i fit that into a key?
09:26:40 <quchen> If your keys are larger than maxBound, then Int isn't a good type to use.
09:26:48 <c_wraith> > 999999999999999999999 :: Int64
09:26:53 <c_wraith> crap, no bot
09:27:03 <c_wraith> But I'm pretty sure that's in the bounds of Int on 64-bit ghc
09:27:07 <quchen> gertc_: Are you sure you need the performance benefit of IntMap over Map?
09:27:10 <h4199> are your total keys less than the Int bound??
09:27:39 <h4199> s/??/?
09:28:21 <gertc_> yes its for a login
09:28:25 <quchen> λ. maxBound :: Int64
09:28:25 <quchen> 9223372036854775807
09:28:39 <quchen> Still too small.
09:28:44 <c_wraith> hmm.  guess you can't use IntMap.
09:28:47 <quchen> For a login? Why not use Integer?
09:28:57 <quchen> To be more precise, `Map Integer`
09:29:09 <quchen> It's not like you're going to handle millions of logins per second
09:30:34 <gertc_> why do google uses such big id numbers anyway?
09:31:11 <mee> if you don't need to do numbery things on them, you could store them as strings
09:31:17 <h4199> I think quchen's solution is the most reasonable. Unless there is a really pressing reason to choose IntMap
09:31:33 <sutabi> bscarlet: in other languages, sure. in Haskell, well I am trying but obviously failing.
09:31:34 <applicativ> gertc_: don't you have 223372036854775807 google accounts?
09:31:35 <quchen> mee: You don't store numbers as strings, no.
09:32:30 <bscarlet> sutabi: it might help to write some little recursive functions in ghci and look at their types.
09:32:57 <quchen> IntMap is something you choose for the performance benefit, and that means you've tried using `Map X` and profiling showed you that the Map is the bottleneck.
09:33:37 <gertc_> hmm i gues my network cable going to be the bottle neck :)
09:35:36 <gertc_> > read "999999999999999999999"
09:35:39 <applicativ> the descending order of 'Difficulty' for ghc bugs is Difficult, Easy, Moderate, Unknown, None
09:36:08 <quchen> applicativ: Look at the "time to implement" field :-)
09:36:22 <applicativ> lambdabot: 3875820019684212735
09:36:27 <gertc_> λ. read "999999999999999999999"
09:36:36 <applicativ> oh good idea quchen
09:36:38 <h4199> what is the difficulty of the difficulty ordering bug?
09:36:43 <danr> what are some and many for in alternative? only for parsers?
09:36:59 <applicativ> h4199: hah. well its a trac thing so maybe it's hopeless
09:37:09 <applicativ> Milestone: _|_
09:37:31 <quchen> Oh no, "rocket science" is in difficulty.
09:37:33 <quchen> Nevermind.
09:37:37 <applicativ> danr: that's what they always say when someone tries to use them for e.g. (Int -> _)
09:38:11 <danr> applicativ: but the true story is?
09:38:50 <simukis_> applicativ: ⊥?
09:38:59 <applicativ> it seems like it must make sense for similar types. some suggest they should be separated into a different class
09:39:23 <applicativ> it comes up on e.g. haskell-cafe from time to time.
09:39:37 <danr> applicativ: ah okidoki, thanks
09:39:38 <applicativ> I BURNT MY HAND USING "SOME" WITH MAYBE
09:40:12 <danr> yeah it is a bit silly to have those functions which almost everywhere are _|_ for some instances
09:41:08 <applicativ> oh not so bad some with Maybe
09:42:01 <applicativ> what am I thinking, it's horrible
09:42:40 <quchen> λ. some (Just 1) :: Maybe [Int]
09:42:40 <quchen> *** Exception: <<loop>>
09:42:42 <quchen> Brilliant
09:43:17 <applicativ> it could be worse, it could diverge for Nothing too
09:43:35 <quchen> If that's your argument in favour all hope is lost.
09:43:54 <applicativ> hah
09:45:26 <bscarlet> do they have to diverge?
09:46:28 <quchen> The good thing about many and some is that they're so opaque that they're probably not used very much.
09:46:41 <bscarlet> why is many v = some v <|> pure [] instead of pure [] <|> some v ?
09:47:51 <applicativ> danr: here's a bit of temptest in a teapot http://www.haskell.org/pipermail/haskell-cafe/2011-December/096125.html
09:47:58 <applicativ> or tsunami in a demi-tasse
09:48:06 <augur> quchen: many and some?
09:48:15 <augur> oh in applicative parsing
09:48:47 <augur> bscarlet: probably to avoid left recursive naughtiness
09:49:06 <bscarlet> augur: sorry - could you elaborate?
09:49:38 <augur> left recursive grammars are notoriously problematic for top-down left-to-right parsing
09:49:52 <bscarlet> ah
09:49:57 <augur> becaus they can lead to all sorts of nasty infinite loops
09:50:14 <augur> for instance, consider a grammar that handles english's saxon genitive:
09:50:57 <augur> <NP> ::= <Noun> | <NP> 's <Noun>
09:51:40 <augur> which describes phrases like John's mother's friend's sister's pet's name's spelling
09:52:08 <augur> or if you want a more CS-y instance, <Term> ::= <Term> <Term> | ...
09:52:12 <augur> as in the LC, for application
09:52:38 <augur> if you try to do a top-down parse with such a grammar, you just spin on the left edge forever, unless you do something fancy
09:52:39 <bscarlet> augur: so if someone wrote an LR parser combinator library it would need to be the other way?
09:52:55 <augur> dunno, but i imagine that that might be a thing
09:57:56 <bscarlet> > let mymany v = pure [] <|> mysome v; mysome v = (:) <$> v <*> mymany v in take 10 $ mymany ['a']
09:57:57 <lambdabot>   ["","a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa"]
09:58:13 <bscarlet> let mymany v = pure [] <|> mysome v; mysome v = (:) <$> v <*> mymany v in take 10 $ mymany ['a','b']
09:58:29 <bscarlet> > let mymany v = pure [] <|> mysome v; mysome v = (:) <$> v <*> mymany v in take 10 $ mymany ['a','b']
09:58:30 <lambdabot>   ["","a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa"]
09:59:41 <quchen> @botsnack -- welcome back
09:59:41 <lambdabot> :)
09:59:43 <bscarlet> > let mymany v = pure [] <|> mysome v; mysome v = flip (:) <$> mymany v <*> v in take 10 $ mymany ['a','b']
09:59:44 <lambdabot>   ["","a","b","aa","ba","ab","bb","aaa","baa","aba"]
10:00:10 <Placinta> @botsnack
10:00:10 <lambdabot> :)
10:00:34 <adelbertc> so ive been slowly getting back into haskell after my brief month-or-so stint a few months ago and im revisiting this "dependency hell" or "cabal hell" ive been reading about - looking for recommendations on tools/best practices to avoid such things? seems there is stuff like cabal-dev or hsenv, and also the HEAD of cabal has some kind of support for sandboxed builds as well?
10:04:29 <Cale> adelbertc: Yeah, cabal-dev works fairly well in my experience, but cabal hell isn't usually *that* bad, outside of certain sets of libraries. (The web frameworks in particular have quite complicated dependency chains where a lot can go wrong.)
10:06:33 <Cale> monochrom has some articles about what to do about problems and how to avoid them
10:06:39 <bergmark> i ran just regular cabal for a good while, but finally got annoyed that you need to force install so much and then rebuild other things
10:07:40 <Cale> adelbertc: http://www.vex.net/~trebla/haskell/sicp.xhtml
10:08:19 <adelbertc> Cale: nice! will bookmark, thanks
10:08:52 <Cale> The situation is, I believe, a bit better than it was when that article was written, in that you'll usually get better warnings before anything happens to screw things up, but the general structure of things has remained the same as far as I know.
10:10:30 <geekosaur> and isn't going to improve as long as ghc handles compiled modules the way it does
10:10:50 <Cale> see also http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
10:11:02 <geekosaur> yes, aggressive inlining is nice for performance. but it makes module management almost impossible
10:11:14 <Cale> (which is just bonus tips about cabal configuration and such)
10:14:42 <Chat9593> Noæoionmoæuyt.                                               Noæ.                                 Boæmn.                   Oæmn.                         Otom
10:17:06 <h4199> 何?
10:19:06 <joelteon> yep
10:20:26 <Placinta> This is the instance of foldable for a tree. foldMap f (Node x ts) = f x `mappend` foldMap (foldMap f) children    Shouldn't there be one more argument after children?
10:21:12 <Placinta> children = ts
10:21:24 <byorgey> @type foldMap
10:21:25 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
10:21:38 <byorgey> Placinta: foldMap only takes two arguments.
10:21:57 <Placinta> The outer foldMap receives only one though
10:22:36 <byorgey> I am not sure what you mean.
10:22:38 <byorgey> in the expression  foldMap (foldMap f) children,  the first foldMap has two arguments:  (foldMap f)  and  children
10:23:43 <Placinta> I see, foldMap f returns a suitable function for another foldMap
10:23:58 <byorgey> right
10:27:44 <heatsink> My program's space usage goes down if I rnf the return value of the closure-retaining function I found by profiling.  Now my program is much slower due to  redundantly evaluating data structures.  Is there a way to find out precisely what needs evaluating?
10:28:45 <Cale> heatsink: apart from "thinking about it hard", I'm not sure :)
10:29:27 <heatsink> okay then :)
10:29:55 <Cale> You could start by just trying a less aggressive use of seq rather than rnf
10:30:28 <heatsink> I tried that before writing rnf instances; it didn't make a measurable difference
10:30:50 <heatsink> NFData instances
10:31:53 <Cale> My usual heuristic for where strictness is needed is where you're turning a large number of pieces of data into a single piece of data by accumulating them (rather than by searching for one of them)
10:32:49 <Cale> and where by a "single piece of data", I mean something which can't be partly evaluated without most or all of the input
10:34:43 <Cale> Maybe your rnf is just a little too far out? You're rnfing a data structure whose elements each need to be evaluated strictly, but which as a whole could be evaluated lazily?
10:34:54 <Cale> I dunno :)
10:36:06 <heatsink> I think the problem has to do with the part of the code that is doing substitution on an AST.  I've tried to force evaluation of all the lookups.  Maybe the substitution map itself is retaining closures.
10:45:24 <schell> sorry to join&ask but what is the standard SHA lib on hackage? specifically for SHA'ing files?
10:46:56 <Cale> schell: There's nothing wrong with asking! Stick around and ask all you like :)
10:47:34 <schell> Cale: thanks :) still learning irc etiquette
10:48:50 <Cale> As for computing SHA hashes, I know there's a binding to OpenSSL, as well as an implementation of SHA directly in Haskell
10:48:59 <Cale> http://hackage.haskell.org/package/HsOpenSSL
10:49:13 <mmathis> If I want to learn haskell am I gonna have to like math?
10:49:18 <zomg> mmathis: no
10:49:20 <zomg> =)
10:49:25 <S11001001> yeah
10:49:41 <Cale> http://hackage.haskell.org/package/SHA
10:49:44 <tertl3> at least a little i would say for any programming language
10:49:49 <roconnor> mmathis: yes
10:49:55 <zomg> I don't like math, I'm pretty bad at math
10:50:06 <zomg> I'm still decent in Haskell and I've been programming for over 13 years
10:50:10 <mmathis> well, am I going to have to know substantially more math than I would for any other language
10:50:12 <zomg> (not that long in haskell obv)
10:50:16 <tertl3> programming is just an implementation of mathematics imo
10:50:20 <zomg> mmathis: not really
10:50:20 <schell> Cale: thanks - the last link is the one i found, good to know i'm googling well ;)
10:50:34 <tertl3> a formalization if you will
10:50:55 <levi> Depends on what you mean by 'math'.
10:50:58 <zomg> mmathis: I'd imagine knowing some of the concepts from math might make it easier to understand all of it but you certainly can learn it without knowing any of it
10:51:00 <Cale> mmathis: You don't have to know math, but it helps. It would be a distraction to go off and study math if your goal is just learning to program in Haskell though.
10:51:47 <Cale> If you think mathematically, Haskell is a particularly good choice of programming language.
10:51:56 <mmathis> hm.. alright, it's just taht I've been idling here for a while, and almost every time I switch to this channel people are talking about math things that I don't already know
10:52:17 <Iceland_jack> mmathis: You can safely ignore them for the time being
10:52:27 <mmathis> alright, sweet
10:52:59 <c_wraith> Cale just thinks that because he's a mathematician. :)
10:53:23 <levi> Mostly the 'math' things in Haskell are sort of like 'pattern' things in other programming circles, but the math things are nicer in that they apply more often and have properties that can be guaranteed.
10:53:39 <Cale> c_wraith: Well, because Curry-Howard is probably clearer in Haskell than in any other language you can do practical day-to-day programming in.
10:53:56 <Cale> (Well, maybe some of the MLs are about the same in that regard)
10:54:42 * hackagebot fay-base 0.16.0.0 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.16.0.0 (AdamBergmark)
10:54:44 <Cale> and that makes the thought process of writing programs especially similar to the thought process of writing proofs.
10:55:00 <Cale> (at least, I think so!)
10:55:37 <levi> mmathis: Every once in a while someone comes up with a clever application of mathematical reasoning to Haskell programs that makes a significant difference, but that usually ends up producing a nice library by which people who don't want to go through the reasoning themselves can still take advantage of it.
10:55:44 <Cale> It's really the same business. Eventually if you look at it carefully enough, you'll realise that it's silly to enjoy one and not the other :)
10:56:03 <mr-> Cale, I don't. Proofs are always much less detailed than programs
10:56:24 <Cale> mr-: I suppose that the proofs that humans write down are, yes.
10:56:27 <zomg> Cale: math doesn't let me build cool shit though!
10:56:28 <zomg> =)
10:56:34 <Cale> zomg: But it does!
10:56:39 <zomg> well if you like building numbers
10:56:41 <zomg> or something
10:56:46 <Cale> Mathematics isn't just about numbers
10:56:51 <Iceland_jack> Building numbers?
10:56:52 <mr-> Cale: and humans don't think in those little steps.. still, you are right. It's practically the same :-)
10:57:03 <zomg> Iceland_jack: makes perfect sense right?
10:57:04 <zomg> :p
10:58:01 <monochrom> I recommend http://www.engr.mun.ca/~theo/Publications/index.html#ProofByProgramming
10:58:19 <levi> mr-: You should try out the 'Software Foundations' book, which will make very clear the correspondence between programs and proofs.
10:59:26 <mr-> levi: If it is refering to Curry-Howard, I think I am familiar enough
10:59:28 <levi> It's a very nice book to do self-study from, as most of the proof problems are self-checking!
10:59:41 <osa1> I'm my halfway through SF book, but as far as I can see it doesn't explain why does that correspondence work, it only says there's a correspondence and let's write some proofs by writing programs ...
10:59:42 * hackagebot fay 0.16.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.16.0.0 (AdamBergmark)
11:00:30 <mr-> levi: but thanks :-)
11:00:51 <schell> zomg: it's hard to see the way programming is applied mathematics without going through some cool math classes, but trust, it is, and it's awesome
11:00:55 <levi> mr-: As osa1 noted, it's not really *about* the correspondence, but it makes practical use of it.
11:01:43 <zomg> schell: yeah my level of math understanding is pretty low
11:01:55 <zomg> attempting to learn anything more generally has led to much frustration
11:01:58 <monochrom> people also have different definitions of "mathematics"
11:02:34 <schell> zomg: if you know any programming at all then you're math knowledge is probably more advanced than you think it is, plus i think it's cool to be a novice
11:02:57 <Cale> osa1: Here's the basic gist of it: In logic, if you want to prove a statement of the form A -> B (i.e. "A implies B", "if A then B"), you start by assuming A, and try to construct a proof of B from that.
11:03:49 <Cale> osa1: In programming, if you want to construct a value of type A -> B, you assume that you have some value x of type A, and try to construct from that an expression y of type B, and then (\x -> y) is your function.
11:03:56 <osa1> btw, if anyone's interested, my math background is very bad but I can still understand and apply stuff in Software Foundations book, use dependently typed languages etc. so you're also good to go (my main goal is to formalize programming lanugage constructs in Coq and give proofs for some useful theorems)
11:04:09 <Cale> osa1: In logic, if you know that A -> B, and you know that A, then you can conclude B.
11:04:31 <Cale> In programming, if you have a value f of type A -> B, and a value x of type A, then you can get a value f x of type B.
11:04:36 <tshirtman> i'm pretty sure most programmer get by with high-school math or less
11:04:44 <tshirtman> programmers*
11:05:05 <Cale> and similarly, there's a correspondence between pairs and logical "and", and the Either type and logical "or"
11:05:08 <osa1> tshirtman: yeah, but that formalization stuff is different than most programmers do as a day job.
11:05:19 <tshirtman> yes
11:05:31 <levi> mr-: Mostly it's about the mathematical foundations of software, presented in a proof-oriented way as a literate Coq program in which you do a lot of the proofs as exercises. The early part is training you both to do informal proofs and to get those translated into Coq so it can do the formal proof. And so it helps with intuition about the different levels of detail involved in formal vs. informal proofs.
11:05:32 <Cale> osa1: Ah, if you're programming in Coq, then you should already know this!
11:05:33 <Cale> :)
11:05:45 <johnw> osa1: now that I've studied some maths because of Haskell, I am seeing monoids, categories and algebras simply everywhere
11:05:48 <osa1> Cale: it will probably help others, thanks :-)
11:05:59 <tshirtman> i'm unsatisfied with my math skills, but that doesn't prevent me to program for a living :)
11:06:04 <kryft> johnw: What did you read btw?
11:06:11 <kryft> johnw: (maths because of Haskell)
11:06:17 <johnw> kryft: I started with the book on Naive Set Theory by Halmos
11:06:18 <osa1> heh, I was about to ask same thing
11:06:19 <tshirtman> i guss haskell will make me learn some new math ^^
11:06:21 <tshirtman> s
11:06:40 <johnw> then read a Linear Algebra book, then Abstract Algebra by Fraleigh, and am now on to Awodey's Category Theroy
11:07:00 <zomg> schell: if you consider stuff like abstract thinking etc. then sure, I've managed several large projects.. but pretty much anything concrete about math is completely beyond me, unless it's trigonometry or something practical =)
11:07:19 <johnw> and mind you, I knew almost *NO* math before starting in Haskell; like, less than high school
11:07:25 <mr-> levi: Hmm, that would give me a nice path to Coq
11:07:35 <johnw> because what high school classes I had, I barely passed and certainly didn't pay attention to
11:07:47 <Cale> If you like programming, you'd probably like real mathematics (i.e. the stuff that actual mathematicians do, rather than the stuff they teach you in highschool).
11:08:11 <johnw> right, if anyone had introduced me to abstract math in high school, I would have gone into math in university
11:08:22 <johnw> instead, they taught me numerical manipulation recipes, for which I never had any use
11:08:27 <Cale> yeah
11:08:31 <Cale> It's really quite sad
11:08:40 <troutwine> A terrible pity.
11:08:45 <johnw> abstract math is truly fascinating
11:08:45 <kryft> Cale: I think you can also say 'rather than the stuff they teach you in university' to some extent, or rather maybe how it's often taught
11:08:47 <zomg> I can sorta follow mathy stuff too if it's explained without going too much into the lingo
11:09:01 <johnw> zomg: and indeed, most of math is learning the terminology
11:09:07 <levi> Well, they kind of *tried* to introduce abstract math early on, in the form of 'New Math', but from what I understand it was pretty much a disaster.
11:09:10 <zomg> there was that online artificial intelligence course going some time ago, could follow that pretty good even though it had way more advanced math than I ever studied
11:09:19 <Cale> kryft: Well, yeah, things aren't much better in some university programs for nonmathematicians :)
11:09:25 <scshunt> levi: I think Lehrer had somethiing to say about that
11:09:38 <schell> zomg: i remember that - it had bayesian statistics
11:11:08 <kryft> Cale: I'm afraid it's not always that much better with university programs for mathematicians either. :P At least I've seen plenty of courses that are pedagogically pretty horrible unless your mathematical maturity is at the point where you wouldn't really need any courses in the first place
11:11:49 <Cale> kryft: I'll admit I might have a skewed perspective because my undergrad was at Waterloo, and we were pretty formal about things all the way through.
11:11:57 <Cale> (or at least, pretty formalisable ;)
11:12:23 <scshunt> Cale: whoa, I didn't realize you were an alum :)
11:14:18 <Cale> scshunt: Yeah, they still call me and ask for money.
11:14:58 <monochrom> haha
11:15:00 <Cale> Which imo is a bit like a car dealership calling you up after you've paid for your car and asking if you'd make a donation to help improve their showroom, but whatever :)
11:15:48 <kryft> Cale: Well part of the 'pedagogically horrible' is being very formal without teaching people how to gain intuition into formalism. I kind of wish I had learned haskell many years ago, because the wrong way to try to understand monads (monad tutorial fallacy etc) and the right way to understand them would have been very useful for studying maths too. :)
11:15:53 <c_wraith> I made the wise choice of not telling my school's alumni association anything about how to find me. :)
11:16:20 <ReinH> oh hai
11:16:32 <kryft> Cale: Uh, 'gaining intuition into formalism' - I'm too sleep-deprived - I mean gaining intuition into the things that are being formalized
11:17:00 <Cale> kryft: Well, that's an even more subtle thing than the really horrible thing that I'm complaining about, which is where they teach you stuff in a way which is actually impossible to make good sense of, and throw out all the explanations.
11:17:21 <kryft> Cale: Oh, that's what I had in mind too actually :D
11:17:44 <Cale> If you're proving all the theorems, there's only so much cheating you can get away with.
11:19:22 * c_wraith finally understands the benefit of Data.Tagged over Data.Proxy
11:19:29 <Cale> I'm talking about things where things are being taught where they not only remove the proofs from the assignments, but also from the lectures, and moreover, they've messed with the order of things such that there's no sensible way you could even fill the proofs in.
11:19:29 <c_wraith> Sometimes I feel like these things take me forever.
11:19:46 <Cale> ugh, that was a mess of a sentence :)
11:19:46 <tippenein> > foldl (+) 0 [1..1000000000]
11:19:50 <lambdabot>   mueval-core: Time limit exceeded
11:20:02 <tippenein> getMBlock internal error
11:20:04 <kryft> Cale: Ah, but you can still get by with quite a lot of cheating. Proofs are like source code; both can be written in forms that are pretty much incomprehensible to the neophyte.
11:20:21 <tippenein> shouldn't I be able to sum to 1 billion with that?
11:20:38 <piron> tippenein: Compile with -O2, or use foldl', or both.
11:20:42 <kryft> Cale: Sure, I've also seen one or two courses like that (I avoided them when I could), and that's even worse of course
11:20:56 <piron> c_wraith: Can you summarize it? What's better about Tagged?
11:21:17 <c_wraith> piron: Tagged s a ≈ Proxy s -> a
11:21:31 <piron> Cale, kryft: Have you seen twitter.com/tinyproof?
11:21:44 <Cale> kryft: Well, a good portion of highschool was like that for me. I could only really articulate after I'd learned things properly what had gone wrong of course, but a lot of the things people stumble on are of that sort.
11:21:50 <Cale> I have :)
11:21:52 <tippenein> piron: I'm doing it with ghci. Is that a problem?
11:22:23 <piron> tippenein: Nope, no problem. Can't use -O2 there, so you must use the other of my suggestions.
11:22:39 <c_wraith> piron: it helps when writing things that have types like Proxy s -> a.  You can just say Tagged s a instead, and you no longer need to bother with extracting the type argument from the proxy somehow.
11:22:55 <c_wraith> piron: Which turns out to make some code simpler
11:23:07 <piron> c_wraith: Huh, neat.
11:24:13 <Cale> e.g. they try to introduce trig functions and logarithms before Calculus, when it's pretty impossible to really define either of them properly without at least some form of limits
11:24:24 <kryft> piron: Haha, I hadn't seen that
11:24:31 <kryft> Cale: Right
11:25:42 <tippenein> foldl' takes 2x longer than python's sum(xrange(1000000000+1))
11:25:46 <tippenein> seems wrong
11:25:53 <Codex_> what do we know about exists -| * -|forall adjunction?
11:26:03 <piron> tippenein: Python is not using bignums.
11:26:14 <Cale> piron: It's not?
11:26:17 <piron> tippenein: Tell Haskell not to use bignums and I bet you'll get your performance back.
11:26:21 <c_wraith> tippenein: cPython's interpreter is better optimized than ghc's.  Compile if you want to see ghc's actually performance.
11:26:24 <tikhon> tippenein: did you run in in GHCi?
11:26:32 <c_wraith> *actual
11:26:37 <tikhon> piron: Python uses bignums by default too
11:26:43 <tippenein> tikhon: yah, I'm trying it out with compiled now
11:26:44 <piron> Okay, I'm wrong.
11:27:11 <c_wraith> ghc provides an interpreter as a development aid.  It's not intended to replace compiled code in production.
11:27:29 <Cale> Yeah, if you compile without -O or -O2, the performance you'll get is basically random :)
11:27:37 <Cale> (randomly bad)
11:27:47 <levi> I've recently collected a bunch of freely-available university-level math textbooks for self-study, and it's kind of amusing that no matter what the topic, the intro usually says something to the effect that, "We're going to assume that you haven't done real math before, so we're going to cover the basics of proving things as well as X so that you will be able to transition into real math."
11:28:00 <geekosaur> (and the interpreter doesn't support optimization at all)
11:28:32 <Cale> levi: Yeah, it's both amusing and really sad.
11:28:49 <c_wraith> levi: that's not a bad preamble for something made freely available.  People with no formal background *will* find it.
11:29:04 <tikhon> eh, it makes it possible to learn the material in any order
11:29:23 <tikhon> also, repetition is very good for learning things, so it's probably healthy to go through the basics several times
11:29:43 * hackagebot tasty 0.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.1 (RomanCheplyaka)
11:29:44 <levi> Well, these are typically made by professors who compile them from their course notes, so I think it's safe to say that they present it that way in the classroom as well.
11:29:45 * hackagebot tasty-smallcheck 0.1 - SmallCheck support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-smallcheck-0.1 (RomanCheplyaka)
11:29:47 * hackagebot tasty-quickcheck 0.1 - QuickCheck support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-quickcheck-0.1 (RomanCheplyaka)
11:30:03 <Zenol> http://hackage.haskell.org/package/markdown Inline and Block links are broken ?
11:30:10 <Cale> If there's one thing about mathematics that people who are not mathematicians could benefit from, it's the application of logic, which is exactly the part we've been complaining is left out from highschool.
11:30:27 <Cale> Codex_: what do you want to know about it?
11:31:37 <Codex_> cale: like is it possible to implement exists :: ((X,Y)->2)->(X->2)
11:32:05 <johnw> i would think not
11:32:08 <c_wraith> Codex_: is 2 a type?  What are some values of type 2?
11:32:17 <johnw> 2 is typically Bool
11:32:19 <Codex_> c_wraith: it's Bool
11:32:20 <tikhon> I imagine 2 ~ BOol
11:32:26 <c_wraith> Oh, that makes sense
11:32:29 <c_wraith> ok!
11:32:40 <tikhon> since () is 1
11:32:42 <tikhon> and Either is +
11:32:48 <tikhon> you can think of it as Either () ()
11:32:58 <tippenein> even when I compile it with O2 I get a mmap operation not permitted
11:33:05 <johnw> and also Maybe ()
11:33:09 <c_wraith> I've been a bit confused by working with lots of code recently where 2 *is* a type.  But it has no values. :)
11:33:09 <piron> ghc -O2 doesn't seem to do any better than ghci for foldl' (+) 0 on my machine.
11:33:14 <tippenein> this is while using foldl, not foldl'
11:33:28 <tippenein> piron: exactly what I just found out too
11:33:48 <Codex_> cale: I'm thinking it needs to be: exists :: [Y]->((X,Y)->2)->(X->2), so that you can enumerate the Y type
11:33:52 <Cale> Codex_: hmm, I'm not sure I see what you mean there though.
11:34:43 * hackagebot tasty-hunit 0.1 - HUnit support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hunit-0.1 (RomanCheplyaka)
11:35:19 <Codex_> cale: I mean, the function would return true from X->2, only if there exists one y where (X,Y)->2 returns true
11:36:05 <Cale> Codex_: Well, that's possible in set theory, but not computable of course.
11:36:18 <Cale> (for an arbitrary Y at least)
11:36:45 <spooky_d> Hello
11:36:55 <spooky_d> I just installed Haskell Platform for Windows
11:37:03 <Cale> spooky_d: Welcome!
11:37:03 <exicer> I'm trying to update cabal, but cabal install cabal-install fails
11:37:14 <exicer> Where should I start looking to resolve this ?
11:37:17 <spooky_d> and I'm trying to install (using cabal) leksah
11:37:22 <Cale> exicer: maybe use lpaste.net to paste the error you're getting?
11:37:32 <spooky_d> fails to install glib, because of missing pkg-config
11:37:49 <spooky_d> there's no pkg-config*.* on my computer
11:38:04 <spooky_d> Hi Cale :)
11:38:17 <exicer> http://lpaste.net/new
11:38:26 <exicer> Uh, woops
11:38:40 <exicer> http://lpaste.net/91565
11:38:48 <Cale> spooky_d: It seems like there's a specific binary installer for leksah on Windows you might try: http://www.leksah.org/download.html
11:39:01 <exicer> Is there some way I can remove HTTP-4000  ?
11:39:03 <syntaxfree> is there something simple like f:: (Eq a)=>a->[a]->Int such that f x = length. filter (==x)
11:39:33 <syntaxfree> Criticall, I don't want to produce the filtered list, just iterate, count and discard.
11:39:43 * hackagebot tasty-golden 2.0 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.0 (RomanCheplyaka)
11:40:19 <Cale> spooky_d: As for the specific problem, pkg-config I believe is originally from GTK (though it's now used for more stuff)
11:40:33 <b2coutts> syntaxfree: I feel like length . filter (==x) is short enough (and this need uncommon enough) that there wouldn't be such a function
11:40:56 <Cale> spooky_d: I would imagine that it might be on your system somewhere if you've installed the GTK libraries, but maybe not in your PATH. I don't really know how it works on Windows.
11:41:10 <syntaxfree> can I ask a more generic question re: what I'm actually trying to do?
11:41:17 <spooky_d> Nope, nowhere :(
11:41:40 <bscarlet> syntaxfree: yes
11:41:46 <Cale> exicer: Does ghc-pkg check report any issues?
11:41:57 <syntaxfree> I have some text (a lot of text), and a function to break it into bigrams (br re ea ak ki...)
11:42:12 <syntaxfree> I want to produce a map (as in Data.Map) with the bigram counts.
11:42:49 <spooky_d> Hmmm, so actually "Windows is not mature enough" :D I see.
11:42:55 <Placinta> What kind of extension does this use? data SqlExpr a where EList :: SqlExpr (Value a) -> SqlExpr (ValueList a)
11:43:05 <spooky_d> This sort of stuff are really upsetting :(
11:43:09 <spooky_d> gah, brb
11:43:17 <syntaxfree> my current strategy is to create a map with zero counts and use Data.Map.update
11:43:37 <mr-> syntaxfree: create a function that adds one element to the Map, and use it to fold over the list?
11:43:52 <monochrom> syntaxfree: why do you not accept "length . filter (==x)" as an implementation? your reason had better not be "because filter(==x) builds a long list in its entirety first", because that is false.
11:43:56 <syntaxfree> incr k = Map.update (\x->Just x+1)
11:44:04 <ReinH> syntaxfree: I'd think you could use a list of bigrams and Data.Map.fromListWith to accumulate
11:44:05 <syntaxfree> and then map incr over the bigram list again.
11:44:07 <exicer> Cale: The cache was out of date; I've run the command to fix that and am attempting to install again.
11:44:23 <syntaxfree> I'll check fromListWith.
11:44:26 <mr-> syntaxfree: fromListWith might be better
11:44:44 <syntaxfree> thanks, folks.
11:45:28 <exicer> Cale: That seems to have fixed it - thanks!
11:45:59 <Cale> exicer: great!
11:46:09 <Cale> Placinta: GADTs
11:46:10 <syntaxfree> uh,
11:46:14 <syntaxfree> @type fromListWith
11:46:18 <lambdabot>     Not in scope: `fromListWith'
11:46:18 <lambdabot>     Perhaps you meant one of these:
11:46:18 <lambdabot>       `IM.fromListWith' (imported from Data.IntMap),
11:46:33 <syntaxfree> @type Data.Map.fromListWith
11:46:44 <Cale> @type M.fromListWith
11:46:46 <Cale> hmm
11:46:55 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
11:46:55 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
11:47:17 <syntaxfree> ah, yes. It's fromListWithKey that was bothering me.
11:47:34 <syntaxfree> sorry.
11:53:49 <Zenol> hum, conduit was named after the unix pipes?
11:54:43 * hackagebot processing 1.1.0.0 - Web graphic applications with Processing.  http://hackage.haskell.org/package/processing-1.1.0.0 (DanielDiaz)
11:54:43 <xico> hi
11:57:06 <Zenol> I say that because $$ looks like a unix |
11:57:32 <Zenol> and it reads left->right instead of right->left with .
11:57:52 <ReinH> syntaxfree: fromListWith (+) $ bigrams `zip` (repeat 1)
11:59:21 <ReinH> Zenol: pipes was named after unix pipes iirc :)
11:59:43 * hackagebot vty-menu 0.0.3 - A lib for displaying a menu and getting a selection using VTY  http://hackage.haskell.org/package/vty-menu-0.0.3 (TimothyHobbs)
12:00:05 <ReinH> vty-menu eh, that could be useful...
12:00:48 <ReinH> syntaxfree: Things like that are why I love Haskell. Inferring the correct empty value for the map, etc.
12:01:31 <boothead> Hi folks, could I ask for a little help in setting up a haskell install so that runhaskll will find libraries installed in ~/.cabal (or any other non-global location)?
12:01:39 <ReinH> parens around repeat 1 are optional. I still don't grok precedence.
12:01:56 <ReinH> boothead: what OS?
12:02:38 <boothead> ubuntu
12:03:09 <ReinH> boothead: are you using the haskell-platform package?
12:03:20 <ReinH> boothead: but you want a non-root install?
12:03:25 <boothead> I couldn't figure out the correct  -package-conf to give it to include ~/.cabal
12:03:30 <ReinH> ah
12:04:04 <boothead> ReinH, I have platform installed but I want to a script the has a #! line and I want it to be able to find stuff i've installed locally
12:04:06 <geekosaur> ~/.cabal isn't actually the righjt place unless you moved ~/.ghc/version/package.conf.d there for some reason
12:04:30 <boothead> geekosaur, ~/.cabal is where libs that you cabal install get put right?
12:05:40 <geekosaur> yesBUT
12:05:50 <geekosaur> they are useless without the instructions for how to use them
12:05:54 <geekosaur> which are in package.conf.d
12:05:59 <geekosaur> which is what ghc is looking for
12:06:17 <lingxiao> hey guys, as a general question, do you guys remember how good you were at Haskell after half a year of learning i?
12:06:19 <lingxiao> it*
12:06:46 <lingxiao> Like your comfort level with the language, the number of concepts you learned and intimately know by heart, ect
12:06:56 <geekosaur> (for example, if they use the FFI to bind to C libraries, the package.conf.d entry says where those libraries can be found and how to use them)
12:06:59 <elliott> better than I was but less good than I am now :)
12:07:12 <elliott> I think it's unproductive to count your knowledge in terms of concepts checked off a list, personally
12:07:38 <elliott> I don't really like the focus on a weird path of "understand Monads(tm) -> understand Applicatives(tm) -> understand Arrows(tm) -> understand Lenses(tm) -> ..."
12:07:55 <lingxiao> hmm.. what did you focus on?
12:08:02 <lingxiao> or looking back, what do you think should be the main focus?
12:08:36 <elliott> well, I think the important thing is what the language is for: being able to write and read code. and striving to make the code you write better
12:08:40 <c_wraith> Also, I think understanding Arrow is kind of wasted effort.
12:09:02 <elliott> and of course, being able to read code implies understanding of many of the abstract concepts, or better: it implies understanding of how they can be used concretely, in practice
12:09:13 <boothead> geekosaur, i did actually try pointing runhaskell at .ghc/version/package.conf.d but it gave a parse error. Is there a way to do it?
12:09:20 <elliott> (and as a nice side-effect, the things you will need to understand will, by definition, be weighted according to how commonly they're used!)
12:09:55 <geekosaur> I think -package-conf requires a file, not a directory (package.conf.d contains individual package.conf files)
12:10:03 <elliott> I tend to learn languages quite strangely, though. I read a few tutorials, write some toy programs to try and get myself started, and then lose interest. a year later, I'll return to the language and find out I already know it quite well
12:10:20 <ReinH> elliott: you forgot the profit??? step
12:10:30 <elliott> and from there on it's just plain old accumulation of knowledge; reading code and articles and papers that interest me and vacuuming up all the info
12:10:49 <geekosaur> that said, ghc should already be using the right one, unless you removed ghc and installed a new one and expect the already installed libraries to work (they won't. stop trying. reinstall from source. yes, I really do mean this.(
12:11:09 <ReinH> lingxiao: My biggest breakthrough was when I stopped thinking I needed to learn category theory and every typeclass to use Haskell and started actually building stuff instead
12:11:10 <elliott> ReinH: haven't yet profited from Haskell. we'll see :p
12:11:16 <ReinH> elliott: soon...
12:11:17 <lingxiao> word true, I'm writing a lot of code everyday, but it seems like I can't express some of the things I want elegantly w/o learning new concepts
12:11:37 <ReinH> lingxiao: that's probably true, but don't let it stop you
12:11:38 <lingxiao> or maybe I could use the old concepts, but like you said, I just can't quite see how to use them concretly yet
12:12:06 <ReinH> lingxiao: focus on one thing at a time and use that in the next thing you build, or to refactor something you've already built
12:12:11 <lingxiao> ReinH : it's actually really exciting haha, I feel like I'm becoming a better person
12:12:14 <Zenol> ReinH: But 'Pipes' isn't conduit, right?
12:12:17 <ReinH> lingxiao: that's how you eat an elephant: one bite at a time.
12:12:30 <edwardk> ReinH: how fares the editing?
12:12:33 <ReinH> lingxiao: don't feel like you need to understand everything right now
12:12:42 <lingxiao> see that's the thing, I feel like when I cant solve a problem, I roll unwittingly towards using some sort of StateT stack
12:12:52 <lingxiao> which is bascially..writing imperitive code in Haskell
12:13:08 <ReinH> edwardk: well!
12:13:23 <boothead> geekosaur, i've got a vanilla ghc and platform which is why I kind of expected runhaskell to pick up on anything that's been cabal installed.
12:13:25 <lingxiao> And haha man Haskell is like a gateway drug to so much math
12:13:41 <ReinH> edwardk: sound quality is good, working on cleaning up the audio and getting the levels right
12:13:44 <lingxiao> so i can't quite tell when the elephant ends and when the stegosaurus begins
12:13:53 <geekosaur> and? if you replace dthe compiler, ghc is deliberately not using the old libraries
12:13:58 <geekosaur> because they will not work
12:14:04 <geekosaur> no matter how badly you want them to
12:14:06 <ReinH> edwardk: then Chris and I will work on editing the master down into whatever its final form
12:14:28 <elliott> lingxiao: but writing imperative code in Haskell isn't so bad.
12:14:35 <ReinH> edwardk: there's a lot of good stuff and we'll be able to use most of it, but there are a few pauses and interruptions (sorry!) and such that we can edit to improve the flow.
12:14:44 <elliott> lingxiao: because you're still writing it in Haskell, there's still that room for understanding how else it could be written.
12:14:51 <ReinH> edwardk: also we've got about an hour and a half in total so we might try to get it closer to an hour
12:14:59 <ReinH> edwardk: tl;dr it's going very well
12:15:01 <elliott> lingxiao: I think pastebinning short but real-world code for feedback is helpful.
12:15:07 <edwardk> np: let me know if you need to rerecord any short snippets
12:15:07 <elliott> lingxiao: you can learn how to apply a lot of concepts that way
12:15:13 <lingxiao> elliot: that's very true, that that "how else it could be written" is the most elusive thing for me
12:15:17 <geekosaur> http://www.vex.net/~trebla/haskell/sicp.xhtml if you want to know why. just accept it; there are ways you can try to force ghc to use them but you WILL get incomprehensible errors because they were compiled against different base libraries.
12:15:17 <lingxiao> it's a general "way" of thinking
12:15:43 <elliott> lingxiao: yes. I think experience is necessary, it's not something you can just read about and pick up.
12:16:01 <ReinH> elliott: I'm tempted to say that the MonadState is my favorite imperative langauge...
12:16:05 <boothead> geekosaur, but I haven't replaced the compiler.
12:16:14 <Placinta> Yay! I finally finished my first haskell mini-project. It took me an hour to do it in PHP. And about 4-5 days in Haskell.
12:16:25 <ReinH> edwardk: cool, thanks!
12:16:30 <geekosaur> well then what did you do?
12:16:40 <lingxiao> elliot: ah I will be doing that pastebining suggestion you just talked about
12:16:53 <lingxiao> in general, can I just post a link here and people will look at it?
12:16:59 <Placinta> A webpage where you display a hierarchical tree of values in li's, and you can add and remove them
12:17:08 <geekosaur> if you have valid package information in ~/.ghc then "ghc-pkg list" should show your libraries. if it does not then either you have lost critical linking information or you have switched compiler installations
12:17:09 <jfischoff> Placinta: and how did your million line php refactor go ;)
12:17:12 <ReinH> lingxiao: you can try :D depends on how busy people are, if they're in a good mood, etc ;)
12:17:29 <ReinH> but there's a good chance
12:17:36 <elliott> lingxiao: no guarantee, but there's no harm in doing so. ideally it should be loadable in ghci (without too many other dependencies) and fairly short (i.e., not thousands of lines)
12:17:46 <lingxiao> ReinH : haha thanks :D. Yeah I'm kind of new here so if there are unspoken rules ... I'm not quite clued in on them
12:17:48 <geekosaur> and there's no guarantee that the libs would work even if you did find the linking information
12:17:51 <elliott> you can also try the code review stack exchange and stuff
12:17:55 <ReinH> lingxiao: no worries :)
12:17:56 <Placinta> jfischoff:  I didn't refactor php, I wrote it from scratch
12:18:14 <jfischoff> Placinta: I know I was being silly
12:18:21 <ReinH> elliott: I want a Try Haskell like site that combines a paste with a GHCi session in browser...
12:18:23 <lingxiao> elliot: ah thanks for the tip, it's a really good suggestion, specific feedback is what I sorely miss h
12:18:28 <ReinH> elliott: so you can just link people to it and they can play around
12:18:30 <Placinta> jfischoff: And I was tongue in cheek :)
12:18:38 <jfischoff> touche
12:18:46 <elliott> ReinH: yeah. but I'd still want my editor, really :P
12:18:48 <geekosaur> the way ghc handles this stuff is rather unfortunate (better performance at the price of stuff only working with *exactly* *the* *same* stuff it was compiled against. not just the same version or etc.)
12:18:52 <elliott> but it's quite a nice idea, yes
12:19:10 <lingxiao> by them way how do you feel when you read some of Gabriel Gonazales' code, and articles?
12:19:22 <ReinH> elliott: some people will, but at least they'll have confidence that it'll actually work without too much fussing
12:19:25 <lingxiao> like do they seem advanced? reasonably understandable?
12:19:39 <Zenol> Placinta: Can I ask which framework did you used? :)
12:19:52 <Placinta> Zenol: Happstack + Persistent for database
12:19:58 <ReinH> elliott: Hmm, can you pipe stdin into ghci?
12:20:04 <aristid> lingxiao: gabriel aka Tekmo is definitely an advanced haskeller but his code isn't as crazy as some others' :)
12:20:32 <ReinH> lingxiao: I find his code easy to understand. The *concepts*, on the other hand...
12:20:35 <lingxiao> haha yeah reading edward kmett's code is def a revelation, it's the way of thought I was talking about
12:20:59 <ReinH> edwardk: ^
12:21:00 <boothead> geekosaur, I'm a muppet - I assumed the install had worked as ansible (where I'm trying to capture  a comprehensive account of my setup) didn't tell me it didn't work!
12:21:00 <lingxiao> ReinH : yeah man reading his code makes me feel like I'm not yet half way up the mountain of concepts
12:21:27 <elliott> I don't like pipes much as it stands, frankly. though the upcoming 4.0 looks a bit better.
12:21:29 <ReinH> lingxiao: well, there's a *lot* of edwardk code to read...
12:21:49 <ReinH> elliott: Funny, I was just talking to edwardk about pipes and he said something similar...
12:21:54 <elliott> the nice thing about edwardk code is that he wants you to hack on it.
12:22:43 <lingxiao> ReinH: yeah I like how "humanistic" his code is as well acutally, if you get my drift. Do you have any go-to projects of ekmett's that you like to reference? And any other people that stands out to you who have good code to study?
12:22:56 <ReinH> lingxiao: well I'm working my way through lens right now.
12:23:07 <ReinH> lingxiao: also XMonad is a very exemplary codebase imo
12:23:22 <lingxiao> ReinH : edwardk said the same thing to me about pipes actually haha.
12:23:25 <ReinH> lingxiao: he has over 100 original github repos, so... pick something that looks interesting :)
12:23:37 <elliott> the bad thing about edwardk code is that he wants you to hack on it.
12:23:41 <ReinH> elliott: lmao
12:23:45 <lingxiao> LOLz, yeah I worked through most of machines ( just because I am interested in Coroutines )
12:24:03 <elliott> I wish machines was ready for the prime-time.
12:24:11 <ReinH> elliott: it might be the pipes killer...
12:24:15 <lingxiao> yeah I really like it, it's soo easy to use.
12:24:26 <lingxiao> if only it had bidrectional flow
12:24:30 <lingxiao> bi-directional*
12:24:56 <lingxiao> he said he's not interested in adding to it unless something changes. it was a mockup for something he's meant to do in Scala
12:25:14 <elliott> ReinH: but it isn't, yet.
12:25:42 <uniquenick> does anyone know of a small example tcp server using pipes/pipes-network?  like an echo server or something?
12:25:48 <ReinH> elliott: no, but I prefer the design
12:25:50 <edwardk> lingxiao: pchiusano has some stuff for letting information flow upstream and for sinks and cycles and whatnot
12:25:59 <edwardk> we just haven't integrated it all into the haskell version
12:26:10 <ReinH> edwardk: btw I ran across an interesting question in here yesterday
12:26:35 <lingxiao> edwardk : DOH! didn't know you're online haha sorry to talk about you err.. in front of you lol
12:26:37 <ReinH> edwardk: how would you make ring data structure Traversable and/or Comonad?
12:26:42 <edwardk> elliott: re machines i'll happily take patches that get it up to prime time ;)
12:27:11 <ReinH> Or, for that matter, a Zipper
12:27:18 <edwardk> lingxiao: hah, np. i'm at work without my laptop so its actually quite difficult for me to see traffic here (webchat is pretty awful)
12:27:21 <elliott> like I said. the nice thing about edwardk code is that he wants you to hack on it. the bad thing about edwardk code is that he wants you to hack on it
12:27:26 <lingxiao> edwardk : and thanks for the pchiusano pointer
12:27:49 <edwardk> reinh: not sure i follow what you mean by ring data structure, you mean a cycle?
12:28:25 <lingxiao> edwardk: ok awesome we talked about how machines was drowning in a sea of parameters and was really hard to use ;)
12:28:27 <edwardk> ReinH: i wrote a post how to make a PointedCycle comonad
12:28:38 <ReinH> edwardk: Probably. A circular linked list, say.
12:28:40 <edwardk> ReinH: or at least a reply to a post by chung-chieh shan about it
12:28:47 <ReinH> huh
12:28:52 <ReinH> go on.
12:29:04 <ReinH> go go gadget google...
12:29:17 <ReinH> edwardk: http://comonad.newartisans.com/reader/2008/the-pointed-set-comonad/index.html ?
12:29:24 <edwardk> http://comonad.newartisans.com/reader/2008/the-pointed-set-comonad/index.html
12:29:26 <edwardk> yeah
12:29:34 <ReinH> edwardk: I think Pointed is what I meant when I said Zipper
12:29:37 <ReinH> I get those confused.
12:30:45 <edwardk> yeah that is based on the derivatives of a non-empty cycle, which are non-empty lists.
12:30:50 <edwardk> which is a zipper by another name
12:31:41 <ReinH> if you say so...
12:32:04 <lingxiao> edwardk : if you to add bi-directional flow to machines where would you start?  if this is a sensible question at all
12:32:18 <edwardk> ReinH: if you look up Joyal's theory of combinatorial species you'll find lots of those kinds of relationships
12:32:23 <ReinH> Probably with comachines...
12:32:27 <ReinH> I am only half joking.
12:32:40 <ReinH> edwardk: bookmarked, thanks
12:32:46 <ReinH> some nice bedtime reading
12:32:49 <ReinH> I am sure
12:32:49 <lingxiao> hahah, actually...could you expand on that?
12:32:58 <edwardk> lingxiao: you can't have it in general. i can feed a machine to two machines, applicatively. each wants to send something back upstream how do those messages combine?
12:33:18 <ReinH> edwardk: something something arrows?
12:33:27 <edwardk> full bidirectional communication comes at a cost
12:33:29 <joelteon> ARROWS
12:33:41 <ReinH> I'm just going to throw out random typeclasses until one sticks
12:33:44 <ReinH> Coarrows?
12:33:56 <joelteon> Comonadic codata
12:34:12 <edwardk> reinh: http://www.amazon.com/Combinatorial-Structures-Encyclopedia-Mathematics-Applications/dp/0521573238 is sort of the definitive textbook on the subject
12:34:29 <ReinH> $157.89
12:34:31 <ReinH> nice
12:34:33 <carter> coconut comonad :)
12:34:33 <lingxiao> edwardk : hmm that's very true. In the case of linear flow, would there be a good solution?
12:34:43 <ReinH> which sucks because that looks fascinating
12:34:57 <ReinH> carter: doesn't that reduce to the nut comonad?
12:35:05 <lingxiao> carter : LOLz
12:35:14 <carter> ReinH depends
12:35:15 <edwardk> lingxiao: well, then its easy. machines is based on a gross simplification of an earlier design that was fully symmetric
12:35:19 <ReinH> carter: DOES IT?
12:35:21 <carter> no clue
12:35:24 <carter> depends
12:35:25 <ReinH> lmao
12:35:32 <carter> you can CPS something thats CPSed
12:35:44 <carter> not all duals simplify away
12:35:51 <lingxiao> haha nut comonad, it sounds.. not PG
12:36:07 <lingxiao> edwardk : do you happen to have the earlier version somewhere?
12:36:11 <lingxiao> for reference
12:36:14 <edwardk> lingxiao: i can't do it here off the top of my head without a compiler though
12:36:24 <carter> yeah, paul graham doesn't understand haskell :)
12:36:28 <edwardk> talk to me some time when i have access to a compiler
12:36:56 <ReinH> edwardk: when are you having one installed in your head?
12:37:01 <edwardk> i probably have a gist of it or something lying around though
12:37:07 <lingxiao> edwardk : oh awesome, thanks! Thanks for your attention, because I was about to writing my own two-way flow abomination that will NOT work
12:37:13 <carter> huh: so testframework isn't maintained?
12:37:28 <lingxiao> carter: I wonder what PG would say about haskell
12:37:40 <carter> lingxiao: doesn't matter
12:37:45 <edwardk> reinh: i spend long periods of time just 'running my code in my head'. my mental compiler is great, it has all sorts of non-existent extensions that let it do what i mean all over the place.
12:37:46 <carter> he's no longer a technologist
12:38:01 <lingxiao> carter : I don't know man, I worship PG. I have a picture ofhim over my bed like chairman Mao.
12:38:26 <lingxiao> his collection of essays is like my little red book ( hope you get the analogy)
12:38:27 <ReinH> edwardk: I think I've been playing too much Shadowrun Returns...
12:38:41 <carter> that sounds dangerous
12:38:49 <lingxiao> edwardk : if you can sell what's in your head I'd buy it with gold
12:38:54 <ReinH> lingxiao: so you're saying PG is a fascist? Hmm...
12:39:24 <lingxiao> ReinH : didn't know Mao was a fascist... I always accept it as true that he was the sole savior of Chian
12:39:24 <ReinH> carter: I've been enjoying HSpec...
12:39:27 <lingxiao> China*
12:39:34 <ReinH> lingxiao: of course he was. :)
12:39:46 * Zenol is still reading the listing from http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Pointed_set/
12:39:57 <lingxiao> lolz, he did kill lots of people with his nimwit policies
12:40:02 * heatsink finally solved the space leak in my program
12:40:09 * heatsink still needs to fix the space leak in my home
12:40:15 <ReinH> lingxiao: apologies, I shouldn't talk about politics.
12:40:52 <lingxiao> ReinH : no it's all good! I shouldn't have brought it into the channel, I rode the joke for too long
12:40:58 <ReinH> lingxiao: no worries :)
12:41:16 <blochchain> is there any way to see a class definition from GHCi?
12:41:23 <carter> ReinH noted
12:41:31 <ReinH> blochchain: :info
12:42:28 <Zenol> what means the "(xs >>= toList.k)" in the pointed definition?
12:42:31 <ReinH> carter: it wraps hunit and qc in a nice "BDD style"
12:42:45 <carter> yeahhhh, i don't understand that
12:42:53 <Placinta> heatsink: How did you find the problem?
12:42:54 <ReinH> carter: it's easy to read :)
12:43:13 <carter> i can read asm and certain C code easily too
12:43:19 <ReinH> I prefer "it does the thing" to testDoesTheThing
12:43:26 <ReinH> but personal preference
12:43:28 <carter> ReinH whats a godo example?
12:43:46 <carter> http://hspec.github.io/ ?
12:43:55 <ReinH> carter: http://hspec.github.io and the repo has examples as well
12:44:19 <ReinH> huh actually just the one...
12:44:35 <startling> I like hspec a lot.
12:44:54 <ReinH> carter: and if you prefer hunit they are pretty interoperable http://hspec.github.io/hunit.html
12:45:03 <startling> seeing lots of green and not very much red is good for the soul.
12:45:10 <carter> fair
12:45:21 <Placinta> Is there a filter function somewhere for Data.Tree?
12:45:22 <carter> i'm going to be pretty quickcheck heavy too
12:45:43 <ReinH> carter: it has a nice shim for qc properties http://hspec.github.io/quickcheck.html
12:45:52 <carter> this isn't hleping me decided
12:46:01 <ReinH> ok :)
12:46:02 <carter> what are the tradeoffs aside from feelings
12:46:04 <carter> :)
12:46:10 <ReinH> carter: my feelings are important! ;)
12:46:13 <carter> true
12:46:18 <carter> i acknowledge that
12:46:20 <startling> carter, have you written test suites for haskell projects before?
12:46:26 <carter> i did
12:46:29 <ReinH> carter: nice output, easy (for me) to write and read, solid tooling
12:46:37 <carter> i thought test framework did that too
12:46:43 <carter> is it actually not maintaained?
12:46:47 <Zenol> they wasn't an ideone like for haskell? That sayd lot's of thing like "why did you used an _ in the name?!"
12:46:56 <carter> got an update in december?
12:47:22 <startling> Placinta: what do you want the return type to be?
12:47:34 <ReinH> carter: last update Thu Dec 6 16:59:52 UTC 2012
12:47:37 <carter> yes
12:47:40 * ReinH shrugs
12:47:52 <carter> testing libraries should stabilize after a while
12:47:52 <heatsink> Placinta, I got some approximate location with profiling, then used careful guessing to decide where to insert strictness annotations
12:47:53 <tippenein> Zenol: leksah I believe
12:48:08 <ReinH> carter: two things I dislike about test framework
12:48:08 <startling> I admit I never used test-framework
12:48:13 <carter> ok
12:48:17 <carter> lets here it
12:48:30 <exicer> Is there some advantage to point-free style other than having to type slightly less ?
12:48:40 <carter> exicer not really :)
12:48:46 <ReinH> First, there's a lot of builerplate. Second, the tests list is defined in one place and the test themselves are defined in another place
12:48:47 <Placinta> startling: A node of the tree
12:48:52 <ReinH> *boilerplate
12:48:56 <carter> ReinH good reasons
12:48:59 <carter> i don't like boiler plate
12:49:01 <carter> you win
12:49:10 <ReinH> hspec is very immediate
12:49:16 <ReinH> carter: compare https://raw.github.com/batterseapower/test-framework/master/example/Test/Framework/Example.lhs
12:49:21 <startling> exicer, it allows you to add stuff without adding parentheses on both sides of the original
12:49:25 <carter> vs what?
12:49:40 <startling> Placinta: how is that a filter?
12:49:53 <ReinH> carter: maybe https://github.com/hspec/hspec/blob/master/test/Test/HspecSpec.hs
12:50:01 <Placinta> startling: I want to extract one node out of the tree, based on the value it contains
12:50:08 <carter> looks the same to me..
12:50:15 <Placinta> startling: something like id == number
12:50:22 <josephle> exicer in some cases it might be easier to read. Obviously there are just as many (if not more) cases where point-free reduces readability
12:50:39 <Zenol> tippenein: leksah is an ide. It was really something like ideone.
12:50:53 <ReinH> carter: 7 test-framework includes vs 3
12:51:04 <carter> hehe
12:51:05 <ReinH> carter: and it's only 3 because it's testing hspec itself so some things require qualificaiton
12:51:20 <carter> thats light boilerplate in the land of boiler plates
12:51:46 <ReinH> carter: a big meaningless block of tests = [prop_foo, prop_bar, ...] vs tests defined in the structure where they are used
12:51:47 <startling> Placinta, the easy way is Data.Foldable.toList then filter
12:52:01 <startling> some things from lens might make it look nicer.
12:52:11 <ReinH> carter: the non-locality of test-framework frustrated me
12:52:19 <carter> which parts are the non locality?
12:52:21 <Placinta> startling:  filterM from Control.Monad wouldn't work?
12:52:28 <ReinH> "Oh what failed? Well here's where it's included in tests now let's search the rest of the file for its definition"
12:52:42 <ReinH> where do I test prop_foo_bar? Oh, it's in this part of the structure of tests
12:52:59 <carter> oh
12:52:59 <carter> ok
12:53:04 <Zenol> ok, I get it, toList.k :: a -> [a] so you can use the list >>= on it. I wonder how it could be used in real stuff O.o
12:53:09 <startling> > preview (only 1) [0, 3, 4, 6, 1]
12:53:10 <lambdabot>   No instance for (GHC.Num.Num t0) arising from the literal `0'
12:53:10 <lambdabot>  The type var...
12:53:19 <carter> looks lkind athe same to me
12:53:21 <ReinH> Zenol: what was the argument?
12:53:23 <carter> but whtever, not important :)
12:53:28 <ReinH> carter: ok, I don't really have much invested in convincing you :D
12:53:30 <startling> :t filterM -- Placinta
12:53:31 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
12:53:39 <carter> if i hit a problem with one
12:53:39 <S_J> http://lpaste.net/91569 <- can someone look at my Parsec code? I dont know why it does nto work as intended test2 fails, why?
12:53:44 <carter> i'll complain and migrate to the othters
12:53:45 <ReinH> carter: but if you want a testing framework with a bit more activity I'd suggest hspec :)
12:53:53 <startling> Placinta: unless the function you want to filter by is a monadic action I don't see how that helps.
12:54:26 <ReinH> Zenol: what was the original?
12:54:36 <Zenol> ReinH: http://lpaste.net/6493737552208461824
12:54:36 <carter> isn't there an irc channel too?
12:54:41 <carter> #hspec
12:54:42 <carter> k
12:56:19 <Zenol> ReinH: If I understand its like the list monad, but you always have the first element of the list ... 'pointed' ?
12:56:37 <danilo2> Hi! I want to write an interactive system (based on GHC), which will load /unload modules in runtime, execute functions etc - I'm thinking about using GHC API and embeding GHCI into my project - is it possible?
12:56:37 <ReinH> Zenol: it might help to replace >>= with its List instance definition: concat (map f xs)
12:58:02 <ReinH> Zenol: and also what is the type of k there?
12:58:40 <Zenol> ReinH: a -> Pointed a
12:58:52 <ReinH> Zenol: and the type of toList.k ?
12:59:25 <Zenol> ReinH: :p <Zenol> ok, I get it, toList.k :: a -> [a] so you can use the list >>= on it.
12:59:51 <ReinH> Zenol: ah.
12:59:56 <Zenol> ReinH: but do you have any case of use of Pointed?
13:00:28 <Peaker> S_J, why do you have "parse" and "parseStore" instead of a single polymorphic: fromEither = either (error "foo") id ?
13:01:05 <ReinH> Zenol: the Comonad instance of PointedSet is interesting.
13:01:40 <Peaker> S_J, why    P.char '$' >> P.string "storestart" >> P.char '$'    and not: P.string "$storestart$" ?
13:02:07 <Zenol> ReinH: I don't know what's a comonade, and how it's used :(
13:03:05 <ReinH> Zenol: the Comonad instance of pointed set allows you to define comonadic actions that use the entire pointed set to return a value (or a new PointedSet)
13:03:08 <Peaker> S_J, also, if any parsec parser fails after consuming input, it will fail all the way till any "try" combinator that wraps it.  you don't have any, so any failure-after-consumption will always fail your entire parser
13:03:09 <monochrom> lemonade means lemon drink. comonade means coco drink. :)
13:03:43 <Peaker> S_J, attoparsec doesn't need the "try" applications.  maybe parsec is out of fashion when there's trifecta/attoparsec, too
13:04:15 <ReinH> Zenol: if you use the interesting property that for PointedSet x xs, the first and last element of xs are the right- and left-neighbors of x, you can use a PointedSet to model cellular automata as comonadic actions
13:04:36 <Zenol> monochrom: I think I prefer lemonade :p
13:05:06 <ReinH> Zenol: so you can use PointedSet to model a cyclical one-dimensional universe
13:05:53 <ReinH> Zenol: which is a variation of http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
13:07:27 <Zenol> ReinH: cellular automata and cyclical one-dimensional universe what was you had to sake to to make me really curious :p
13:08:27 <ReinH> A friend of mine did her thesis on small-world properties of cellular automata. She was limited to relatively small, one-dimensional universes because of the tools she had available.
13:08:32 <ReinH> She did not have comonads :)
13:08:35 <ReinH> I wonder what you could do with them.
13:09:32 <ReinH> Maybe larger cardinality or dimensionality universes? The abstractions are stronger so it should be easier to generalize...
13:10:01 <ReinH> Just replace PointedSet with a comonad instance with the universe properties you want.
13:11:00 <Zenol> it sounds crasy :p
13:11:32 <Zenol> So it makes two more things to read...
13:12:33 <Zenol> I should stop asking question or I'll have enougth article to spend my whole life reading :/
13:12:55 <edwardk> zenol: that is a happy problem
13:14:42 <ReinH> edwardk: question for you if I may...
13:15:57 <edwardk> ReinH: shoot
13:16:08 <ReinH> edwardk: small-world properties are generally obtained by randomly replacing swapping neighbor relationships with a non-local point in the universe, so that my left-neightor is now what was your right-neighbor and vice versa. I'm trying to figure out how to construct this model and make it comonadic.
13:16:16 <ReinH> s/replacing //
13:16:38 <ReinH> basically the small-world properties is that some neighbor relationships "jump" to elsewhere in the universe
13:16:46 <ReinH> connecting those two parts of the universe
13:17:14 <edwardk> ReinH: randomly or deterministically?
13:17:47 <osa1> where are documentations saved in .cabal folder?
13:17:50 <edwardk> the main issue is figuring out how to describe the 'stitches' in your topology
13:17:51 <ReinH> edwardk: generally the number and position of these 'jumps' is randomized but we could do it deterministically if that's easier
13:18:33 <ReinH> edwardk: the universe topology is defined on creation and does not change
13:18:34 <edwardk> well, what i mean is that the jump placement would have to be deterministic to work in a usable Hask-comonad. each placement would be a different comonad
13:18:53 <Zenol> ReinH: Oooooh. ma -> ( ma -> b) -> m b dosen means that you stupidely apply ma to ma->b :o
13:19:11 <c_wraith> ma is very different from m a
13:19:12 <edwardk> it may only differ in that you have some map of unified locations or something that is captured by reflection in the type
13:19:48 <c_wraith> edwardk: I figured out earlier, how handy Data.Tagged is for certain uses, and it made me wonder how I missed it. :)
13:19:53 <edwardk> zenol: yeah the comonad's extend may be fairly complicated
13:19:56 <ReinH> edwardk: so let's say that the topology is defined by a map of source -> sink locations
13:20:01 <ReinH> edwardk: and we don't then need to care how that map is built
13:21:44 <ReinH> edwardk: well maybe a map of Int -> (Int, Int) for left and right neighbors
13:22:05 <edwardk> reinh: then use something like Reifies s (l -> l) => Comonad (Small l s) -- for some data type like data Small l s a = Small (l -> a) l
13:22:20 <ReinH> parsing...
13:22:32 <edwardk> where the l -> l function represents the canonicalized version of the location
13:22:53 <edwardk> so e.g. if you work in (`mod` 5) you can have one small world
13:23:07 <ReinH> right
13:23:12 <ReinH> what is Reifies?
13:23:24 <edwardk> ReinH: from reflection
13:23:33 <ReinH> kk
13:23:50 <edwardk> reify :: a -> (forall s. Reifies s a => Proxy s -> r) -> r
13:24:06 <edwardk> reflect :: Reifies s a => p s -> a
13:24:09 <ReinH> edwardk: well now I can spend the next week unpacking the 4 things you just said
13:24:13 <ReinH> :D
13:24:17 <edwardk> reify a reflect = a
13:24:18 <ReinH> thanks
13:24:24 <osa1> I can't generate documentation for llvm-general package: http://lpaste.net/91570 any ideas on that?
13:24:32 <ocharles> ReinH: for learning reflection, the linked paper on Implicit Configurations is worth a read
13:24:44 <ReinH> ocharles: yeah, I just bookmarked it thanks :D
13:24:50 <ocharles> i grok reflection after reading that, but I still haven't got much of an intuition for it
13:24:53 <ocharles> but it's a step forward at least
13:25:06 <ReinH> can you grok something without an intuition for it?
13:25:26 <twomashi2> Anyone know if any special ceremony is required to be able to `import GHC`? Or should it work at ghci?
13:25:27 <monochrom> that depends on what is "grok".
13:25:28 <ocharles> sure, I always figuring grokking is a akin to being able to give a handwavey explanation
13:25:32 <monochrom> what is "grok"?
13:26:03 * geekosaur hands monochrom a glass of water
13:26:11 <troutwine> Term from Stranger in a Strange Land. Means to understand a concept so thoroughly you aren't consciously aware of it anymore.
13:26:27 <troutwine> Or something like that. It's been a while since I read the book.
13:26:45 <ocharles> oh, then I'm misusing the term
13:26:55 <monochrom> then perhaps it's synonym with "intuition"
13:26:57 <hpaste> S_J pasted “Parsec manyTill, how does it work?” at http://lpaste.net/91572
13:27:09 <troutwine> http://www.wordnik.comwww.wordnik.com/words/grok
13:27:15 <S_J> could someone have a look? i cant understand why it doesnt work http://lpaste.net/91572
13:27:42 <Peaker> S_J, datakv2 = datakv ++ datakv ?
13:27:49 <Peaker> S_J, if so, why not write it that way instead of hurting my eyes? :)
13:27:58 <ReinH> troutwine: sort of like that but essentially different in ways only a Martian can understand. ;)
13:28:08 <troutwine> :D
13:28:49 <ReinH> troutwine: in sort of the same way, I suppose, that "zeitgeist" almost means "spirit of the times" but totally doesn't. ;)
13:28:58 <S_J> Peaker: when I do that it works...why?
13:29:08 <twomashi2> would anyone mind checking to see if they can `import GHC` at ghci?
13:29:38 <S_J> and: (datakv++datakv) == datakv2 -> True.
13:29:48 <S_J> but it is not the same when i aprser them...
13:30:09 <ReinH> > join (++) [1] -- Peaker
13:30:10 <lambdabot>   [1,1]
13:30:26 <geekosaur> it's not just the same thing repeated
13:30:28 <geekosaur> &valuestart&32
13:30:32 <ReinH> Peaker: from the useless obfuscation department
13:31:09 <geekosaur> but the code I see wants &valuestart& to be followed by P.man P.letter
13:31:13 <S_J> no wait it is not the same obv. sorry the strings are different but that is still weird
13:31:14 <geekosaur> *P.many
13:31:29 <S_J> no it is different
13:31:50 <geekosaur> S_J: line 24
13:32:16 <heatsink> S_J, the Parsec error could be helpful
13:32:36 <S_J> ah, P.letter!
13:33:35 <piron> troutwine: That domain name is freaking me out.
13:34:03 <troutwine> piron: I know, right?
13:34:26 <troutwine> http://www.wordnik.com/words/grok also works. No idea.
13:34:34 <piron> The non-doubled version works, too, so I hypothesize that anything.wordnik.com/words/grok works.
13:35:24 <heatsink> Is this URL less freaky? http://5z8.info/getPersonalData-start_l6e3dd_torrentEverything
13:35:28 <heatsink> It goes to the same place.
13:35:32 <troutwine> Quite so. Fun google result, anyway.
13:36:09 <S_J> how does parsec parse any letter or digit?
13:36:18 <S_J> how do I write or?
13:36:23 <piron> <|>
13:36:23 <heatsink> (<|>)
13:37:00 <ReinH> Random question: Can you make a legal Monoid instance for URI parameters such that mempty = "" and ("foo", "bar") <> ("bizz, "bazz") = "?foo=bar&bizz=bazz"
13:37:26 <ReinH> No.
13:37:31 <Peaker> ReinH, (<>) :: Monoid m => m -> m -> m
13:37:52 <ReinH> Peaker: as soon as I asked the question I realized it was stupid.
13:38:07 <Peaker> the free monoid (list) seems to be the monoid you're after
13:38:19 <joelteon> You could make a monoid instance that does that but I don't think it would be legal
13:38:20 <joelteon> let me try
13:38:22 <piron> ReinH: http://hackage.haskell.org/packages/archive/http-types/0.8.0/doc/html/Network-HTTP-Types.html#g:9
13:38:57 <joelteon> no, you couldn't
13:39:00 <joelteon> never mind, haha
13:39:22 <gdoteof> i need to write a simple server that takes json 'commands' and executes bash scripts based off them and send back json 'answers'
13:39:32 <c_wraith> ...  that's terrifying
13:39:49 <c_wraith> executing bash scripts? So many ways things could go terribly wrong...
13:39:52 <gdoteof> any recommendations on libraries to look at?
13:40:03 <piron> ?hackage aeson
13:40:03 <lambdabot> http://hackage.haskell.org/package/aeson
13:40:03 <gdoteof> i've done some haskell but mostly within yesod
13:40:04 <c_wraith> all of the web frameworks do that easily
13:40:09 <Demos_> gdeest, I would go for Acme.PHP
13:40:17 <tippenein> jsonrpc seems to be what you've described
13:43:32 <S_J> so seriously, is there no way to have hieracrhial modules? like Application/ and in APplication/ I have somemodules/ someothermodules/ ?
13:44:01 <schell> S_J: as far as i know yes, you can do that
13:44:02 <piron> Hierarchical modules are in Haskell 2010.
13:44:05 <tikhon> you can certainly organize your files like that
13:44:07 <S_J> Parsec is unbelievably cool though
13:44:10 <tikhon> and have modules like Foo.Bar.Baz
13:44:21 <tikhon> but you can't do anything like import Foo.Bar.*
13:44:23 <S_J> do I need cabal then ?
13:44:24 <piron> GHC will look for Foo.Bar.Baz in Foo/Bar/Baz.hs.
13:44:37 <tikhon> so it's basically just a naming convention
13:44:37 <hpc> S_J: without cabal you will likely go crazy :P
13:44:44 <piron> You never *need* cabal.
13:44:45 <schell> if you do import Foo.Bar everything exported in Foo.Bar is imported implicitly
13:44:51 <piron> Everything cabal does can be done by hand.
13:45:02 <tikhon> but Foo.Bar.Baz is a completely separate module
13:45:11 <tikhon> even though the name is heirarchical
13:45:14 <gdoteof> tippenein: this: http://hackage.haskell.org/package/hs-json-rpc-0.0.0.1 ?
13:45:30 <tikhon> wow, did I misspell that word
13:45:36 <piron> Yes, Haskell 2010 module names are hierarchical, but not in an interesting way, as tikhon is saying.
13:45:39 <tikhon> hierarchical
13:46:04 <schell> though, it Foo/Bar.hs you could re-export Baz(..)
13:46:33 <tikhon> it's different from e.g. Java where foo.bar.* can import a whole bunch of classes
13:46:38 <schell> i've found that haskell's modules are way more expressive than other systems
13:47:06 * piron ponders echo module Foo..Bar. where >Foo/""/Bar/"".hs
13:54:12 <pavel> Hello, is anyone familiar with the language-python package?
13:54:28 <pavel> I am trying to go from a (Module SrcSpan) to a (Module a) in the parser
13:54:55 <dcoutts> pavel: does it have a Functor instance?
13:55:05 <Hugh_> what does the => in a function signature mean?
13:55:22 <piron> Hugh_: => separates constraints from the body of the type
13:55:43 <piron> Hugh_: It means the value has the given type, but only if you can show that the constraints to the left of the => hold.
13:55:45 <roboguy_> schell: I hear interesting things about the standard ML module system but I've never looked at it
13:55:50 <pavel> dcoutts: Not as far as I can tell
13:55:59 <pavel> dcoutts: Is the advice to manually add one, then?
13:56:04 <Hugh_> thanks piron. what happens if the constraints don't hold?
13:56:19 <piron> Hugh_: Your compiler whines.
13:56:21 <dcoutts> Hugh_: if I have something like: Num a => a -> a, then the way to read it is as "function from 'a' to 'a', so long as 'a' is in Num"
13:56:47 <monochrom> when the constraints don't hold, you get "No instance for ..." messages
13:56:49 <Hugh_> oh, ok. Got it. Makes sense. so it defines the typeclass?
13:57:05 <monochrom> it requires typeclasses. requires, not defines.
13:57:14 <Hugh_> yep, requires thanks
13:57:26 <Hugh_> Got it, thanks.out
13:57:36 <cdk> the pqueue package doesnt seem to support a general lookup function, is it possible to write such a function for a binomial heap? ie. lookup :: Ord a => a -> PQueue a -> Maybe a
13:57:37 <dcoutts> pavel: not necessarily, depends what the lib provides in terms of manipulation (especially if it uses some generics package)
13:58:06 <schell> roboguy_: i'd like to check out ML
13:58:16 <dcoutts> cdk: it'd have to do a linear search I think, heaps are only partially ordered
13:58:18 <schell> and agda
13:58:24 <edwardk> 'class' defines a typeclass. 'instance' instantiates the typeclass for some type(s), the class constraint on the left of => indicates that such an instance is required.
13:58:33 <slack1256> So, atomically# is a primOp (def ./compiler/prelude/primop.txt.pp) but where is the rest of it defined?
13:58:35 <slack1256> in the rts?
13:58:45 <dcoutts> slack1256: yes
13:58:52 <pavel> dcoutts: It provides Data
13:58:53 <roboguy_> schell: me too, but I haven't gotten around to it yet either
13:58:59 <pavel> dcoutts: But I don't know much about it
13:59:08 <dcoutts> pavel: ah, syb
13:59:17 <schell> roboguy_: maybe when we strike it rich!
13:59:25 <edwardk> cdk: you can at best get burkhard-keller style guarantees about searching it, not log time
13:59:30 <pavel> dcoutts: syb?
13:59:31 <schell> i'll go back to school, travel and learn ML
13:59:31 <roboguy_> schell: haha, yeah
13:59:40 <dcoutts> pavel: that should make it possible, but I also have to admit I've not really used SYB
13:59:44 <slack1256> dcoutss: OK
13:59:46 * hackagebot tdd-util 0.2.0.1 - Test framework wrapper  http://hackage.haskell.org/package/tdd-util-0.2.0.1 (ByronJohnson)
13:59:49 <cdk> dcoutts: okay, i read the wiki page on binomial heaps but was still unsure.
14:00:00 <cdk> edwardk: I've never heard of burkhard-keller, I'll take a look
14:00:02 <pavel> dcoutts: What is SYB?
14:00:26 <dcoutts> pavel: "scrap your boilerplate", it's one of the generics libs
14:00:44 <dreixel> pavel: http://www.cs.uu.nl/wiki/GenericProgramming/SYB
14:00:45 <piron> ?wiki syb
14:00:45 <lambdabot> http://www.haskell.org/haskellwiki/syb
14:00:45 <pavel> dcoutts: Ah, I see
14:00:46 <hpc> it's one of the first
14:01:26 <dcoutts> cdk: https://en.wikipedia.org/wiki/Heap_%28data_structure%29, see the heap property and the comment about no sibling order
14:01:49 <dcoutts> cdk: unlike search trees, which are totally ordered and so allow log lookup of any key
14:03:12 <dcoutts> slack1256: primops are either implemented directly in the compiler (by generating code inline) or by calling out-of-line to some cmm code, either in the rts or another lib
14:03:46 <dcoutts> slack1256: there's some docs in the ghc wiki, e.g. how to find the implementation in the compiler / lib / rts
14:04:27 <S_J> can I have 1 cabal file for different builds? like buildTest buildProgram ?
14:04:33 <dcoutts> slack1256: in the case of atomically# it's probably cmm code that goes on to call C function(s) from the RTS
14:04:43 <edwardk> dcoutts: sure, by BK, i was referring to the fact that you can trim some of the branches once you go deep enough that the node is (>) than the key you are searching for, but the worst case asymptotics are going to be the same as the linear scan
14:05:07 <edwardk> even if in practice it'll be much better for small keys that get to trim most branches
14:05:44 <dcoutts> edwardk: right, I was thinking worst case, but you're obviously right about short-circuiting sometimes
14:05:53 <edwardk> cdk: if you want to do key-lookup, look into treaps and priority search queues.
14:07:05 <edwardk> cdk: http://hackage.haskell.org/package/PSQueue and there is one based on fingertrees (that performs rather abysmally but has some desirable properties)
14:09:40 <slack1256> dcoutts: I was grepping everything until I found stm.c
14:10:16 <slack1256> I don't know where else I thought it could be.
14:10:58 <cdk> edwardk: I'm using the PSQ from pqueue right now. I'd like O(1) access to the lowest priority element, and O(log n) lookup. PSQueue provides O(log n) for both minView and lookup and in my case an O(1) minView operation is more important.
14:11:59 <edwardk> cdk: the fingertree-psqueue should give O(1) minview and log(n) lookup
14:12:32 <heatsink> pavel, what type do you want to use in place of SrcSpan?
14:12:35 <edwardk> because the monoid is just tracking the minView for you and the elements are in key order.
14:13:16 <edwardk> er i guess its O(1) findMin, not minView
14:13:42 <edwardk> someone has to pay the log cost either during insertion or removal.
14:14:43 <FreeFull> What are your guys opinions on this? https://github.com/gelisam/hsl
14:15:45 <Peaker> oh man, ghc-core just bailing out with an error if its output isn't pager-compatible is so silly
14:15:57 <Peaker> If I wanted to |less its output I could do it myself!
14:15:58 <cdk> edwardk: i guess pqueue is the best implementation for me then. Its good to know why I cant do better though, thanks!
14:16:19 <carter> Peaker then provide a patch, i think alpounet  is the current maintainer
14:16:28 <hpc> Peaker: |more for hardmode :D
14:19:28 <Peaker> the repo is shachaf's apparently
14:19:46 <FreeFull> hpc: Hardmode is reading it as it's coming out without a pager
14:19:58 <carter> oh
14:20:01 <carter> same idea
14:24:39 <gambogi> is this an ok place to ask for language help?
14:28:50 <elliott> gambogi: assuming the language is Haskell :)
14:29:03 <gambogi> haha alright
14:29:17 <gambogi> so I have a newtype
14:29:42 <gambogi> which wraps float, but I want to be able to convert it back to a float
14:29:59 <Iceland_jack> newtype WrapsFloat = WrapsFloat { unWrap :: Float } ?
14:30:14 <Gracenotes> this channel is both about the programming language and the town in Oklahoma
14:30:28 <Iceland_jack> Where (unwrap :: WrapsFloat -> Float)
14:30:50 <Peaker> gambogi, record syntax in newtypes does that
14:31:16 <Iceland_jack> There's also run-of-the-mill pattern matching
14:32:50 <gambogi> currently my type def is this:  62 newtype Foot = Foot Float
14:32:51 <gambogi>  63     deriving (Eq, Ord, Num, Fractional, Typeable)
14:33:29 <gambogi> Iceland_jack: I guess my question is how to write unWrap
14:33:38 <Iceland_jack> gambogi: I just showed you how :)
14:34:12 <Iceland_jack>     > newtype WrapsFloat = WrapsFloat { unWrap :: Float }
14:34:12 <Iceland_jack>     > let foo = WrapsFloat pi
14:34:12 <Iceland_jack>     > unWrap foo
14:34:12 <Iceland_jack> 3.1415927
14:34:27 <elliott> you can also just do
14:34:30 <elliott> newtype W = W Float
14:34:33 <elliott> unW (W n) = n
14:34:41 <elliott> with regular pattern matching.
14:34:45 <elliott> or match on W directly at usage sites
14:34:56 <gambogi> ah gotcha
14:35:26 <watermind> when explaining (lazy) data structures, it's usual to draw diagrams with cells with pointers that may be undefined or point to a particular value/cell
14:35:35 <watermind> is there a common name for these cells?
14:35:35 <pentace> gambogi: May I ask why you derive a Typeable instance?
14:35:43 <watermind> particularly the ones taking primitive values?
14:38:06 <gambogi> pentace: I was looking off the source of Data.Time.Units
14:38:19 <gambogi> but now that I'm looking at it I don't think I need it
14:42:47 <Zenol> ReinH: I tried to write a 2D comonad instance
14:44:45 <Zenol> ReinH: if you have a little free time and can tell me if it's correct, it would be very kind.
14:54:34 <DanielDiaz> hello, I have this big datatype that depends in other big datatypes and so on... and I want to be able to run quickcheck tests. Is it possible to derive automatically an instance of the Arbritrary class?
14:54:54 <DanielDiaz> using DeriveGenerics, for example
14:58:28 <ocharles> DanielDiaz: SmallCheck can do that
14:59:15 <Peaker> DanielDiaz, http://hackage.haskell.org/packages/archive/derive/2.5.11/doc/html/Data-Derive-Arbitrary.html
14:59:26 <Peaker> (requires TH, isn't based on Generic class)
14:59:47 <DanielDiaz> Peaker: I have to investigate how to use that.
15:00:47 <Peaker> DanielDiaz, import Data.Derive.Arbitrary (makeArbitrary) ; import Data.DeriveTH (derive) ; derive makeArbitrary ''YourSmallType ; derive makeArbitrary ''YourBiggerType
15:01:12 <Peaker> DanielDiaz, unfortunately the TH in the derive package is annoying and requires you to also import the class and methods manually
15:01:37 <DanielDiaz> I see
15:02:01 <DanielDiaz> the API documentation of the library is also pretty empty
15:04:54 <merijn> That's SOP >.>
15:05:12 <DanielDiaz> SOP?
15:05:23 <merijn> Standard Operating Procedure
15:05:48 <DanielDiaz> ok
15:06:57 <realzies> kloplop321: mmm
15:16:35 <ReinH> Zenol: I'll give it a shot :)
15:17:06 <DanielDiaz> Tekmo, it looks that I have the derivation working. How do I see the output code of Template Haskell?
15:17:27 <geekosaur> -ddump-splices ?
15:18:09 <DanielDiaz> geekosaur, thank you
15:18:51 <Zenol> oh, actualy, it's lpast that says "hey, redundant bracket! Why not [expr] ?".
15:19:05 <Zenol> ReinH: http://lpaste.net/91575
15:20:00 <Riccardo> is anybody using Yi? I'm spending some time with XMonad to improve my haskell knowledge and I'd like to try a text editor as well, but I can't figure out if it's as mature and used...
15:20:56 <WraithM> Riccardo: I think (correct me if I'm wrong) most people just use vi/emacs.
15:21:06 <cdk> I'm looking at a heap profile produced by RTS -hy, what does data type does * represent?
15:21:46 <ReinH> Zenol: think of a 2D pointed space as a 1d pointed space of 1d pointed spaces
15:23:00 <ReinH> Zenol: so if data D1 a = D1 [a] a [a] then data D2 a = D2 (D1 (D1 a))
15:23:54 <quchen> cdk: * is unknown
15:24:20 <Riccardo> WraithM: thanks. I've used emacs as well, though now I'm giving Sublime Text a try (it's quite popular with the JS crowd). The Haskell plugin has a few bugs. I wanted to get into scripting/customizing my editor and learning lisp+emacs is not on my laundry list...
15:24:41 <ReinH> I guess those are zippers, not pointed, but w/e
15:24:47 <cdk> quchen: how can there be unknown data?
15:24:57 <xico> is there a problem with list comprehension with floats? do error accumulates and such? (i just want a simple [a,b..c] with floats)
15:25:10 <quchen> cdk: No idea :-D
15:25:10 <carter> Riccardo: file bugs with the author, he's pretty responsive
15:25:11 <ReinH> Zenol: then up and down are left and right on the outer zipper: up (D2 a) = D2 (left a)
15:25:18 <carter> i'm using ST3 for my work
15:25:23 <ReinH> Zenol: but left and right have to be applied to the inner zipper:
15:25:23 <carter> though for now , no plugins
15:25:49 <geekosaur> xico: would have to see code to be certain, but errors almost certainly will accumulate. Float and Double are somewhat badly behaved
15:25:50 <Riccardo> you mean the SublimeHaskell author?
15:26:37 <ReinH> Zenol: left (D2 x) = D2 (left <$> x)
15:27:22 <ReinH> (I'm assuming you have a typeclass for these spaces that provides left/right and D2 and D1 are instances, otherwise you would need to disambiguate their names)
15:27:32 <xico> geekosaur: thanks
15:30:50 <DanielDiaz> Tekmo, geekosaur, the TH generated code does not stop throwing me "not in scope" errors of entities that are clearly in scope, even defined in the same module.
15:31:39 <geekosaur> remember that TH code is evaluated at the point it is found; something defined in the same module but *after* the TH code won't be visible
15:31:54 <geekosaur> and some stuff defined before may not be visible, depending. it's somewhat complex
15:32:11 <DanielDiaz> I see, this is like black magic
15:32:18 <geekosaur> yep
15:32:28 <DanielDiaz> geekosaur, I will end up doing it by hand
15:33:52 <Zenol> ReinH: Actualy, D1 and D2 are the instances for left/right and down/up.
15:34:05 <Zenol> s/instances/type class/
15:34:13 <ReinH> Zenol: ok :)
15:34:24 <Zenol> And, why it's not pointed?
15:34:36 <mstksg> is there any way I can see what types/functions TH generates?  some way to intercept the output of the preprocessor?
15:34:55 <c_wraith> -ddump-splices as an argument to ghc.  (iirc)
15:35:12 <DanielDiaz> mstksg, add the next ghc option: -ddump-splices
15:35:18 <Zenol> ReinH: why are they 'zipper' ?
15:35:29 <mstksg> i feel like ghc-mod seems to "know" what types it generates because it marks them as in-scope when i use them inother files
15:35:37 <mstksg> c_wraith, DanielDiaz thanks :)
15:35:56 <geekosaur> mstksg, also note it's not a preprocessor (see preceding with DanielDiaz)
15:35:58 <DanielDiaz> mstksg, actually, I learned it like 5 minutes ago
15:36:20 <xico> > (10**) . logBase 10 <$> [4..8]
15:36:21 <lambdabot>   [4.0,5.000000000000001,6.0,7.0,7.999999999999999]
15:36:26 <geekosaur> it's done *while* parsing, so it has odd idiosyncracies and a proper preprocessor isn't really possible
15:36:28 <mstksg> oh how interesting the timing
15:36:41 <ReinH> Zenol: I honestly don't understand the distinction :)
15:36:47 <geekosaur> (although zeroth tries)
15:37:02 <ReinH> Zenol: but you see the basic idea that a 2D space is a 1D space of 1D spaces?
15:37:24 <ClaudiusMaximus> > nub [2**24 .. 2**24 + 10] :: [Float]
15:37:27 <lambdabot>   mueval-core: Time limit exceeded
15:37:49 <ReinH> Zenol: for instance Grid = [[a]], where fmap operates on rows (or columns) and fmap.fmap operates on cells?
15:38:37 <augur> > 2**24
15:38:38 <lambdabot>   1.6777216e7
15:38:39 <Zenol> ReinH: Yes I see, it's actualy what I'v done manualy
15:38:43 <augur> > 2^24
15:38:44 <lambdabot>   16777216
15:39:01 <augur> nub [2^24 .. 2^24 + 10]
15:39:02 <Zenol> ReinH: I should be able to simplify a lot by using only V's instance of 1D(up/down)
15:39:10 <augur> > nub [2^24 .. 2^24 + 10]
15:39:12 <lambdabot>   [16777216,16777217,16777218,16777219,16777220,16777221,16777222,16777223,16...
15:39:23 <Yaniel> :t nub
15:39:24 <lambdabot> Eq a => [a] -> [a]
15:39:27 <geekosaur> mstksg, it doesn't actually produce haskell code, either. it transforms the internal parse tree (AST) as it's being created. so you (potentially) can do things in TH that you can't write at all in Haskell code
15:39:32 <Zenol> ReihH: Yes :) Thanks :)
15:39:37 <augur> ClaudiusMaximus: dont use floats when you want nats :D
15:39:43 <ClaudiusMaximus> > nub $ take 11 [2**24 .. 2**24 + 10] :: [Float]
15:39:44 <lambdabot>   [1.6777216e7]
15:39:45 <augur> Yaniel: nub is unique
15:39:53 <ReinH> Zenol: you can simplify U as data U a = U (V (V a))
15:40:01 <ReinH> Zenol: and other simplifications will fall from that
15:40:03 <geekosaur> and I seem to recall people have used it to e.g. evade language restrictions in order to get access to things that aren't supposed to be accessible
15:40:05 <ClaudiusMaximus> augur: xico was asking about enumFromTo with Float/Double
15:40:18 <augur> ClaudiusMaximus: how weird
15:40:41 <augur> i represent my floats as functions Nat -> Bool!
15:41:49 <ReinH> Zenol: e.g.: instance D1 U where up (U x) = U (up x)
15:41:53 <augur> actually i guess it should be (Nat, Nat -> Bool)
15:42:18 <augur> or something like that
15:42:18 <ReinH> instance D2 U where left (U x) = U (up <$> x)
15:42:20 <ReinH> and so on
15:42:22 <haasn> augur: why not [Bool]
15:42:47 <Zenol> ReinH: Yap, Ua = U (V (V a)) :)
15:42:50 <augur> haasn: because im morally opposed to implicit coinduction!
15:43:10 <haasn> I'm a Haskell programmer. I have no idea what coinduction is
15:43:10 <augur> haasn: that would work tho. :T
15:43:16 <augur> haasn: lol
15:43:26 <augur> lots of haskell programmers know what coinduction is
15:43:34 <haasn> and I'm not one of them :)
15:43:44 <ReinH> augur: The categorical dual of induction. Obviously.
15:43:48 <ReinH> ;)
15:43:51 <haasn> ReinH: I figured as much :P
15:43:54 <augur> ReinH: as it happens, yes
15:43:56 <merijn> I'm guessing that coinduction is just non-terminating induction?
15:44:04 <augur> no
15:44:07 <merijn> awww
15:44:08 <michaelfeathers> Silly question: I want to compose zip with a function I'm calling untuple which is untuple(x,y) = [x,y]  This leads to errors because a and b need to be she same type in zip :: [a] -> [b] -> [(a, b)]  What is the easy way out?
15:44:17 <augur> coinductive data = greatest fixed points
15:44:33 <augur> so coalgebraic types rather than algebraic ones
15:44:35 <mstksg> how should i use -ddump-splices with cabal build/cabal install?
15:44:53 <ReinH> haasn: I'm a big fan of non-answers :)
15:44:56 <merijn> michaelfeathers: Are you asking "How do I get elements of differing types into a list?"?
15:45:07 <haasn> ReinH: coanswers
15:45:08 <ReinH> michaelfeathers: hi :)
15:45:12 <ReinH> haasn: touche
15:45:50 <geekosaur> mstksg, edit the cabal file's "ghc-options:" to specify -ddump-splices
15:46:14 <ReinH> michaelfeathers: untuple would need to be (a,a) -> [a]
15:46:16 <merijn> michaelfeathers: Also, the type of untuple makes no sense as argument to zip...
15:46:23 <geekosaur> (if it doesn't have one, add it. although in that case you could also cabal install --ghc-options=-ddump-splices)
15:46:24 <augur> merijn: given a functor f, an f coalgebra is a map a -> f a (for some choice of a)
15:46:32 <haasn> I just got a slightly amusing (to me) idea; instead of prefixing ‘co’, dualizing could be done by reversing the letters, monad <-> danom
15:46:51 <mstksg> geekosaur: i did that, but i don't know where it outputs too heh.  nothing shows up on stdin
15:47:01 <michaelfeathers> let mix  = untuple . zip
15:47:04 <augur> haasn: algebra <-> arbegla
15:47:29 <ezrios> michaelfeathers: what is the type of untuple
15:47:36 <augur> haasn: induction <-> noitcudni
15:47:45 <haasn> nruter :: a <-- w a <= Danom w -- to capitalize on a previous idea
15:47:53 <michaelfeathers> mix :: [String] -> [String] -> [[String]]
15:48:20 <michaelfeathers> untuple :: (t, t) -> [t]
15:48:42 <geekosaur> probably need to pass -v3 to cabal install as well
15:49:00 * haasn .oO( untuple = toListOf each -- look ma, generalized to n-tuples )
15:49:02 <mstksg> geekosaur: ah, that did it
15:49:19 <augur> hmm
15:49:24 <DanielDiaz> omg, I am going to be writing Arbitrary instances for hours haha
15:49:30 <c_wraith> Is it totally unreasonable to tell people to manually index via Ix if they want to use Vector for multidimensional data?
15:49:39 <augur> michaelfeathers's idea suggests another kind of natural transformation like thing
15:50:22 <owen> \me anyone want to look at this and tell me what they think? http://codereview.stackexchange.com/q/29378/28083
15:50:23 <michaelfeathers> it's actually an artificial problem.  I'm trying to motivate the use of transpose.
15:50:42 <michaelfeathers> ..in a learning situation
15:51:17 <augur> t :: f a -> g a   is a flibble if there is a t' such that for all f :: f a -> b, f . t' . t = f
15:51:36 <augur> im not sure if that then entails the one directional equation t' . t = id, tho
15:52:10 <augur> obviously, t' :: g a -> f a
15:52:40 <michaelfeathers> I'll likely take another tack.. but isn't there some casting thing that can be done?  Something short of making a custom zip which operates on two args of the same type?
15:52:46 <haasn> augur: pick f = id ?
15:52:51 <augur> haasn: ??
15:53:34 <haasn> ‘id’ is an example of “for all f :: f a -> b”, with b ~ f a, no?
15:53:38 <augur> oh also hah
15:53:49 <augur> that shouldve used something other than f :D
15:54:07 <augur> haasn: i dont know what you mean
15:54:12 <ReinH> michaelfeathers: the (a,a) vs (a,b) isn't your actual problem
15:54:24 <michaelfeathers> ReinH: say more?
15:54:25 <ReinH> michaelfeathers: I think you want mix xs ys = zip xs ys >>= untuple
15:54:35 <augur> haasn: oh i see
15:54:43 <ReinH> zip gives you [(a,b)] but untuple takes (a,a)
15:54:47 <merijn> ReinH: I don't think the monad instance of list is very desirable here
15:54:49 <augur> set f :: f a -> b to be id :: f a -> f a
15:55:09 <augur> then we have id . t' . t = id => t' . t = id
15:55:31 <merijn> owen: In the interest of performance, nub is n^2 complexity
15:55:47 <ReinH> merijn: ok, then mix xs ys = concat (map untuple (zip xs ys))
15:55:56 <haasn> yes, and the reverse is also obviously true (if given t' . t = id; then f . t' . t = f . id = f)
15:56:05 <augur> haasn: yes very good, thank you
15:56:13 <augur> so that just means t' retracts t, i think
15:56:15 <merijn> ReinH: How do you know he didn't simply meant "map untuple"?
15:56:20 <merijn> s/meant/mean
15:56:22 <augur> so not as interesting as i thought but still useful!
15:56:36 <ReinH> michaelfeathers: oh, wait, he did... I'm sorry.
15:56:59 <michaelfeathers> Yes, I meant map untuple
15:57:23 <merijn> michaelfeathers: btw, different type variables don't *have* to be different
15:57:26 <ReinH> michaelfeathers: so my reading comprehension failure aside, map untuple (zip xs ys) is valid
15:57:50 <merijn> michaelfeathers: All a's in a type must be the same and all b's must be the same, but there's no rule that says that a and b can't be the same
15:57:56 <haasn> what's the actual problem michaelfeathers is trying to solve?
15:58:04 <michaelfeathers> ReinH: I see.  I was trying let mix = map untuple . zip
15:58:19 <merijn> michaelfeathers: i.e. "[a] -> [b] -> [(a, b)]" *can* be "[Int] -> [Int] -> [(Int, Int)]"
15:58:34 <merijn> michaelfeathers: You're allowed to pick any value for a and b
15:58:35 <haasn> interleave two lists?
15:58:38 <ReinH> michaelfeathers: ah, but mix takes two arguments
15:58:50 <merijn> michaelfeathers: That composition doesn't work
15:58:55 <michaelfeathers> ReinH: yes, that's the thing.  Got it.
15:59:09 <michaelfeathers> Pointfree is beautiful when you can use it ;-)
15:59:21 <merijn> michaelfeathers: because "(f . g) x y" == "(f (g x)) y"
15:59:31 <michaelfeathers> Much thanks!
15:59:37 <ReinH> michaelfeathers: it doesn't serve the same pedagogical purpose
15:59:42 <ReinH> michaelfeathers: but you can define it as: zipWith (curry untuple)
15:59:51 <h4199> haasn: I think he is trying to make an example of something that is unwieldly to motivate transposition
16:00:23 <michaelfeathers> ReinH:  Thanks.  That's too much, though.  I'm trying to make a little tut for non-Haskellers to show them how generalization of computation can lead to concision.
16:00:24 <merijn> michaelfeathers: Or in your case "(map untuple . zip) x y" = "(map untuple (zip x)) y", note that zip needs another argument
16:00:43 <ReinH> michaelfeathers: right, and there's no simple transformation from the former to the latter
16:01:12 <ReinH> merijn: could some magic be applied with (.).(.)?
16:01:29 <ReinH> or :. or whatever the kids are calling it these days?
16:01:31 <sirspazzolot> is there a way to have a guard function as an 'until' instead of a filter? ie I want to escape the list comprehension as soon as I encounter a certain value > 10
16:01:40 <merijn> ReinH: Yes, but that's begging for a smack against the back of the head and a "don't be so clever!"
16:02:19 <dmj`> does happstack use iteratees?
16:02:25 <ReinH> merijn: yep, sometimes being too pointless is pointless.
16:03:13 <haasn> michaelfeathers: then link them to lens
16:03:15 <haasn> ;-)
16:03:44 <ReinH> michaelfeathers: you might want to use a different problem. This one has some extrinsics (the types of zip and untuple, etc) that might cloud the issue.
16:04:11 <michaelfeathers> ReinH: Either than or use a dynamically typed language like Clojure ;-)
16:05:34 <michaelfeathers> Gotta go.  Thanks.
16:05:41 <ReinH> michaelfeathers: ttfn
16:06:24 <Zenol> ok, I did it :)
16:06:30 <Zenol> But there is still something bad.
16:08:53 <Zenol> ReinH: http://lpaste.net/diff/91575/91576
16:09:19 <Zenol> ReinH: I'm not satisfied with the comonad instance of U
16:09:23 <ReinH> Anyone have any other good resources on learning equational reasoning? I'm going through Bird's Pearls book atm.
16:11:13 <c_wraith> ReinH: the newish one?
16:11:48 <c_wraith> Because if it is, it's about the only book I've seen with that focus.
16:12:01 <ReinH> c_wraith: well then I will read it even harder :)
16:12:35 <c_wraith> I feel like there's a lot of depth in the book
16:12:49 <c_wraith> If you read through it just once, you'll see solutions to some problems.
16:13:15 <c_wraith> But if you read through it again, you'll see that it's more about methods of improving solutions than the specific problems.
16:13:23 <ReinH> c_wraith: yep
16:13:36 <c_wraith> But a lot of them won't mean much without understanding the problem being solved.
16:13:43 <c_wraith> So you really do need to read everything a few times.
16:14:58 <ReinH> Zenol: it would help you to extract tail . iterate f
16:16:05 <Zenol> ReinH: To extract? You mean apply f =  V (tail $ iterate f a) a (tail $ iterate f a) ?
16:16:35 <Zenol> ReinH: I would like do don't have to explicitely have to call the constructor of V like that.
16:16:36 <raduu> hi, just a quick noob question related to an example from the book learnyouahaskell:
16:16:38 <raduu> https://gist.github.com/samsonradu/4ac121ed70cbcba66bf7
16:16:42 <ReinH> Zenol: for instance, call that iterate' and you get cojoin a = V (iterate' down a) a (iterate' up a)
16:16:55 <raduu> does this function stop when it finds the item by key?
16:17:03 <raduu> or just goes through the whole list
16:17:29 <ReinH> Zenol: then notice that you do a lot of things of the pattern (iterate' f a) a (iterate' f' a)
16:18:08 <dmj`> @src foldr
16:18:09 <lambdabot> foldr f z []     = z
16:18:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:18:55 <ReinH> Zenol: you can extract that to give you something like: let move f f' x = (iterate' f x) x (iterate' f' x) in V (move down up d1)
16:19:16 <Zenol> @pl iterate' f v = tail $ iterate f v
16:19:19 <lambdabot> iterate' = ((tail $) .) . iterate
16:19:19 <lambdabot> optimization suspended, use @pl-resume to continue.
16:19:36 <raduu> lambdabot: that s a yes? :)
16:20:07 <raduu> actually it looks like it goes through
16:20:09 <ReinH> Zenol: then instance Comonad V where cojoin = move up down
16:20:12 <cdk> Zenol: (tail .) . interate, theres also (.:) in Data.Function i think
16:21:52 <ReinH> Someone needs to coin the phrase: pointless use of pointless
16:22:10 <Zenol> cdk> I think i'll stick to the old good poitfull notation until I'm able to write that "by hands" :) But thanks for Data.Function.
16:22:25 <ReinH> Zenol: anyway move will help you simplify cojoin for U a lot
16:22:35 <Zenol> ReinH: Ok, I can repeat the fuzz.fuzz. ... .fuzz as n incread : http://lpaste.net/diff/91576/91577
16:23:23 <Zenol> ReinH: I was looking for something that can generalise the pattern to dimension n. In this case, it's the fuzz . fuzz pattern.
16:24:06 <cdk> nevermind, (.:) isn't in Data.Function, i'm not sure where (if) it's defined and neither does hoogle.
16:24:14 <ReinH> Zenol: it's something like cojoin a = U $ fmap (move up down) $ move left right a
16:24:22 <ReinH> Zenol: I might have the ups and downs and lefts and rights switched up
16:24:49 <ReinH> cdk: I don't think anything defines it because it's so easy to define
16:25:03 <ReinH> cdk: and depending on how you define it it could be (.).(.) or fmap.fmap, etc
16:25:24 <Zenol> ReinH: What is move?
16:25:26 <cdk> ReinH: yes, I've never actually used it. I dont go that far out of my way to be pointfree
16:25:36 <ReinH> Also a word of warning: if anyone calls it the "boobs operator" I will be cross with you.
16:26:22 <schell> is there an easy way to iterate over a list with heist?
16:26:23 <cdk> good old "fmap fmap fmap"
16:26:28 <ReinH> Zenol: move f f' x = V (iterate' f x) x (iterate' f' x)
16:27:13 <ReinH> Zenol: it extracts the pattern you use in lines 44, 50, 51
16:27:19 <Zenol> ReinH: In this case it's shorter to directly fix left/right. As fuzz v = V (iterate' down v) v (iterate' up v)
16:27:45 <ReinH> Zenol: but you can parameterize the functions
16:27:53 <ReinH> fuzz v = move down up v
16:28:02 <Zenol> But it's always called with the same functions.
16:28:07 <ReinH> Zenol: are you sure?
16:28:22 <ReinH> Zenol: ah, because you make U an instance of D1
16:28:26 <ReinH> ok
16:28:27 <ReinH> :)
16:28:55 <ReinH> Zenol: so you want fuzz.fuzz then
16:29:34 <Zenol> ReinH: Actualy, I have :p See the diff.
16:29:44 <ReinH> Zenol: which diff?
16:30:14 <Zenol> 01:22 < Zenol> ReinH: Ok, I can repeat the fuzz.fuzz. ... .fuzz as n incread : http://lpaste.net/diff/91576/91577
16:30:17 <Zenol> :)
16:30:25 <ReinH> sorry
16:30:42 <lingxiao> edwardk : hey Edward I was wondering if you have a moment now?
16:30:43 <ReinH> Zenol: wewt :)
16:30:57 <lingxiao> actually not sure if you're on haha
16:32:30 <ReinH> Zenol: then evolve = cobind rule, right?
16:33:37 <Zenol> ReinH: Oh, I didn't read the next part of the article :s
16:33:48 <Zenol> ReinH: Wanted to play a bit before :p
16:34:01 <ReinH> ok :)
16:34:54 <sirspazzolot> what am I doing wrong: let fib 0 = 0; let fib 1 = 1; let fib n = fib (n-1) + fib (n-2); //semicolons of course to delimit statements and are not valid syntax
16:35:27 <sirspazzolot> before the final statement, fib 1 does properly evaluate to 1. after, fib 1 hangs and then ghci closes itself
16:36:42 <byorgey> sirspazzolot: that defines three separate functions which all happen to be called fib
16:36:46 <Zenol> oh! he's shift function is realy fancy. I mean, creating an infinite list of all possibility and just pick the right one.
16:36:48 <byorgey> sirspazzolot: each one shadows the previous.
16:36:49 <geekosaur> they have to all be part of the same let
16:37:19 <sirspazzolot> oh, gotcha. guards are a thing
16:37:24 <byorgey> sirspazzolot: semicolons are valid syntax, like this:  let fib 0 = 0; fib 1 = 1; fib n = ...
16:37:35 <sirspazzolot> oh, it complained at me
16:37:59 <sirspazzolot> oh because other lets
16:38:20 <byorgey> right, let ...; let ...; ...  is not valid syntax, but  let ...; ...; ...  is
16:38:50 <Cale> You can add braces to disambiguate where the blocks of let declarations start and stop
16:39:23 <Cale> (if you want to next them)
16:39:25 <Cale> nest*
16:39:44 <Cale> But you really just want one let there, of course
16:42:23 <Zenol> ReinH: Yap. I'll need some display IO. If you won't be sleeping in few hour I may show you a lazy game of life, or something like that :D
16:43:51 <sirspazzolot> wonderful, I'm learning
16:43:52 <sirspazzolot> thanks guys!
16:48:26 <sirspazzolot> computing the 60th fibonacci number takes a long time
16:48:30 <ReinH> Zenol: you can define a toList on V and U. Since your universe is infinite, you'll have to provide a size to get the "list around the point" rather than the whole list.
16:49:03 <Zenol> ReinH: Oh, good iea, with groom I can have a display as a table.
16:50:41 <pentace> sirspazzolot: You can rewrite your function to make it much faster
16:50:44 <ReinH> Zenol: like toList n (V ls x rs) = (take n ls) ++ [x] ++ (take n rs)
16:51:59 <ReinH> Zenol: then you can define a toGrid :: Int -> U a -> [[a]] to get a square grid around a point
16:52:21 <ReinH> Zenol: and fmap from a to Char at some point to get your display characters for terminal output, etc
16:53:54 <ReinH> Zenol: and once you have [[Char]], that's synonymous with [String] you can just use unlines to print it :)
16:54:49 * hackagebot yesod-fay 0.4.0.2 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.4.0.2 (MichaelSnoyman)
16:54:59 <DanielDiaz> geekosaur: I ended up creating my own generic deriving algorithm for the Arbitrary class. Well, a copy with a different name. I hope it works.
16:55:39 <ReinH> Zenol: or mapM_ putStrLn if that's what you're into.
16:56:04 <byorgey> sirspazzolot: note that Haskell does not do any kind of memoization of function calls.  So every time (say) fib 29  is called, it must be recomputed
17:01:31 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 60
17:01:32 <lambdabot>   1548008755920
17:01:42 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 1000
17:01:43 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
17:02:48 <ReinH> (this works because fibs is monomorphic)
17:04:29 <Cale> Yeah, typeclass polymorphism would get in the way of efficiency here.
17:04:39 <sirspazzolot> byorgey: haha a friend just explained memoization to me actually
17:05:48 * applicative is finding it hard to believe that this scheme actually works http://hackage.haskell.org/packages/archive/memo-sqlite/0.1/doc/html/Data-Memo-Sqlite.html 
17:05:56 <applicative> it does though
17:06:34 <Clint> i'd rather have a caching layer for persistent
17:06:42 <Cale> What's surprising about that one?
17:07:23 <Cale> data-memocombinators is more surprising, I think :)
17:07:36 <Cale> At least, until you get how it works :)
17:07:41 <ReinH> There's a big difference between fib n = fibs !! n and fib = (fibs !!)
17:08:02 <ReinH> which can be quite surprising
17:08:10 <Cale> ReinH: With the monomorphism restriction on, yes.
17:08:28 <ReinH> Cale: right
17:08:38 <ReinH> Cale: which is also a good example of why turning it off might not always be what you want
17:08:50 <applicative> Cale, by 'that it works' I just meant, that it makes for a pretty fast almost-naive fib
17:09:11 <Cale> Well, you'd usually also give a type signature for top level declarations like that, which would solve the efficiency issue. A warning would be sufficient.
17:09:17 <ReinH> Cale: true
17:10:50 <ReinH> Cale: actually I don't think it's because monomorphism
17:10:57 <pentace> ReinH: What's the difference?
17:11:11 <ReinH> with fib n = fibs !! n, fib 1 is not the same as fib 2 so there is no sharing
17:11:29 <Cale> > let fibs :: (Num n) => [n]; fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 60
17:11:33 <lambdabot>   mueval-core: Time limit exceeded
17:11:35 <ReinH> with fib = (fibs !!), fibs can be shared because fib 1 === fib 2
17:11:47 <ReinH> at least that's how I think I understand it
17:11:53 <ReinH> this is also impl dependent
17:12:03 <ReinH> nothing requires that fibs be shared
17:12:17 <Cale> ReinH: It's defined separately, presumably, which means that it's still in scope
17:12:42 <ReinH> Cale: ok, let's use a version where fibs is defined in a where clause or otherwise scoped to fib
17:12:51 <ReinH> I don't know how to write that in one line :/
17:12:52 <Cale> Yes, in that case, they're different
17:13:20 <Cale> fib n = let fibs = ... in fibs !! n is quite different from  fib = let fibs = ... in \n -> fibs !! n
17:13:35 <ReinH> there you go thanks
17:13:39 <Cale> Moving lambdas through lets can change space and time complexity
17:13:47 <pentace> ReinH: What do you mean by "not the same", the result?
17:14:01 <Cale> pentace: The result is of course the same, the performance is very much not.
17:15:06 <Neqoxec> that zipWith fibonacci function blew my mind
17:15:29 <Cale> Neqoxec: it's cool, isn't it?
17:15:31 <ReinH> Neqoxec: yeah, it's pretty great
17:15:50 <zRecursive> :t zipWith
17:15:51 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
17:16:16 <ReinH> [0, 1, (0+1), (1+1), ...]
17:16:17 <ReinH> magic
17:16:33 <ReinH> lazy magic
17:16:57 <ReinH> :t zipWith (+)
17:16:58 <lambdabot> Num c => [c] -> [c] -> [c]
17:18:33 <ReinH> btw this also allows an interesting generalization
17:20:31 <ReinH> fibLikes n m = let seq = fibLikes n m in n : m : zipWith (+) seq (tail seq)
17:20:48 <ReinH> fibs = fibLikes 0 1
17:21:33 <johnw> s/seq/xs
17:21:37 <ReinH> ok
17:21:54 <ReinH> My brain was thinking "Fibonacci SEQuence" but yes.
17:22:17 <ReinH> Also this can be further generalized over any abelian group, but I digress.
17:22:52 <johnw> what does it need to be a group?  this should work for any semigroup, no?
17:23:29 <johnw> fibLikes n m = let xs = fibLikes n m in n : m : zipWith sappend xs (tail xs)
17:24:13 <ReinH> johnw: I thought you needed commutativity but now I have doubts
17:24:17 <johnw> and then the traditional fib = map getSum $ fibLikes (Sum 0) (Sum 1)
17:24:39 <ReinH> johnw: another fun generalization :)
17:25:33 <ReinH> Also I think something something module but I don't have enough math
17:25:35 <ReinH> :(
17:26:24 <FreeFull> I bet you could replace zipWith with some Applicative's ap
17:26:59 <FreeFull> Probably ZipList
17:27:42 <FreeFull> Actually, probably not
17:27:50 <Peaker> Cale, I think GHC will float a definition like "fibs = " outside lambdas when it doesn't depend on the argument
17:28:08 <ReinH> FreeFull: that's interesting actually
17:28:16 <johnw> fibLikes n m = let xs = fibLikes n m in n : m : sappend <$> ZipList xs <$> ZipList (tail xs)
17:28:17 <ReinH> If "Tribonacci numbers" are:
17:28:20 <ReinH> > let tribs = 0 : 0 : 1 : zipWith3 (\a b c -> a + b + c) tribs (tail tribs) ((tail.tail) tribs) in take 10 tribs
17:28:21 <lambdabot>   [0,0,1,1,2,4,7,13,24,44]
17:28:25 <johnw> maybe need parens there
17:28:29 <ReinH> how do you generalize that to higher orders?
17:29:03 <Peaker> @type \f x y -> getZipList $ f <$> ZipList x <*> ZipList y
17:29:04 <lambdabot> (a2 -> a1 -> a) -> [a2] -> [a1] -> [a]
17:29:18 <FreeFull> ReinH: I don't think you can without using typeclasses
17:29:40 <Peaker> ReinH, You use applicative style
17:30:41 <FreeFull> Peaker: That would actually work
17:30:55 <FreeFull> I don't know why I thought it wouldn't
17:30:59 <ReinH> Peaker: ok, please show me fibsOrder n = (replicate n-1 0) ++ [1] ++ ?
17:31:16 <ReinH> (not being snarky, I really want to see it)
17:32:09 <johnw> however, since ZipList takes a list, we've not added any generalization
17:32:25 <johnw> the use of a list is a purely internal matter
17:32:36 <johnw> so using zipWith over [] is equally as general
17:32:50 <zRecursive> :t ZipList
17:32:51 <lambdabot> [a] -> ZipList a
17:33:27 <FreeFull> ReinH: You could do something like fibsOrder :: Int -> ([a] -> a) -> [a] -> [a]
17:34:31 <FreeFull> Where   fibsOrder 2 sum [0,1]    would correspond to the fibbonacci numbers
17:48:14 <FreeFull> ReinH: fibsOrder n f xs = let xs' = xs ++ concatMap (return . f . take n) (tails xs') in xs'
17:48:19 <FreeFull> Very ugly first approximation
17:48:31 <FreeFull> Wait
17:48:54 <FreeFull> ReinH: fibsOrder n f xs = let xs' = xs ++ map (f . take n) (tails xs') in xs'
17:48:59 <FreeFull> That's simpler
17:50:09 <FreeFull> ReinH: That's a very generic solution though
17:50:39 <FreeFull> You'd call it like    fibsOrder n sum (replicate (n-1) 0 : [1])
17:51:04 <FreeFull> :t \n -> fibsOrder n sum (replicate (n-1) 0 : [1])
17:51:04 <lambdabot> Not in scope: `fibsOrder'
17:51:25 <FreeFull> :t let fibsOrder n f xs = let xs' = xs ++ map (f . take n) (tails xs') in xs' in \n -> fibsOrder n sum (replicate (n-1) 0 : [1])
17:51:26 <lambdabot> (Num [a], Num a) => Int -> [[a]]
17:51:37 <FreeFull> That's not right
17:52:54 <FreeFull> Ah
17:52:58 <FreeFull> :t let fibsOrder n f xs = let xs' = xs ++ map (f . take n) (tails xs') in xs' in \n -> fibsOrder n sum (replicate (n-1) 0 ++ [1])
17:52:59 <lambdabot> Num a => Int -> [a]
17:53:46 <ReinH> also fun: take 10 $ fibLikes (Dual "a") (Dual "b")
17:54:53 * hackagebot FunGEn 0.4 - FUNctional Game ENgine  http://hackage.haskell.org/package/FunGEn-0.4 (SimonMichael)
17:55:16 <FreeFull> > let recSec n f xs = let xs' = xs ++ map (f . take n) (tails xs') in xs' in recSec 2 product [1,2]
17:55:17 <lambdabot>   [1,2,2,4,8,32,256,8192,2097152,17179869184,36028797018963968,61897001964269...
17:55:35 <FreeFull> > let recSec n f xs = let xs' = xs ++ map (f . take n) (tails xs') in xs' in recSec 2 sum [0,1]
17:55:36 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:55:44 <FreeFull> > let recSec n f xs = let xs' = xs ++ map (f . take n) (tails xs') in xs' in recSec 3 sum [0,0,1]
17:55:45 <lambdabot>   [0,0,1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890...
17:56:07 <FreeFull> Note that the initial starting list can be longer than the number, but can't be smaller
17:56:19 <FreeFull> > let recSec n f xs = let xs' = xs ++ map (f . take n) (tails xs') in xs' in recSec 3 sum [0,0,0,1]
17:56:20 <lambdabot>   [0,0,0,1,0,1,1,2,2,4,5,8,11,17,24,36,52,77,112,165,241,354,518,760,1113,163...
17:56:23 <zRecursive> Can you show me the trunk of "fibs n = 0 : 1 : zipWith (+) fibs (tail fibs)" ? i.e. fibs 5
17:56:38 <Zenol> mapM_ killed my laptop :/
17:56:58 <Clint> seems unlikely
17:57:01 <FreeFull> zRecursive: You know that n doesn't do anything there, right?
17:57:11 <zRecursive> yeah
17:57:13 <FreeFull> Other than making the whole thing not typecheck
17:57:52 <zRecursive> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
17:58:44 <FreeFull> What do you mean by trunk?
17:59:05 <zRecursive> lazy
17:59:24 <ReinH> ?
17:59:45 <ReinH> Unsure if "it is lazy" or "I am lazy"...
18:00:04 <zRecursive> lazy causes thunk ?
18:00:17 <ReinH> zRecursive: can you use more than three words to ask your question?
18:00:46 <zRecursive> ReinH: what is the thunk of (fibs !! 5) ?
18:01:03 <zRecursive> the thunk before evaluated
18:03:01 <geekosaur> zRecursive, a thunk is an unevaluated thing. (thing of it as an anonymous function that, when evaluated, will produce the value; that's more or less how laziness is implemented)
18:03:10 <geekosaur> *think of it
18:03:38 <ReinH> zRecursive: it is a thunk that points to other thunks and so on. I'm not sure what answer you're looking for.
18:05:09 <zRecursive> then how to expand "fibs = 0 : 1 : zipWith (+) fibs (tail fibs)" ? i.e. [0,1,(0+1) ...]
18:05:37 <ReinH> zRecursive: with simple-reflect you can see:
18:05:43 <zRecursive> geekosaur: i will
18:06:14 <zRecursive> ReinH: simple-reflect ?
18:06:29 <ReinH> take 6 $ fibLikes x y --> [x,y,x + y,y + (x + y),x + y + (y + (x + y)),y + (x + y) + (x + y + (y + (x + y)))]
18:06:42 <ReinH> which doesn't show everything but at least shows how the lazy, recursive structure is built
18:06:47 <ReinH> http://hackage.haskell.org/packages/archive/simple-reflect/0.3.1/doc/html/Debug-SimpleReflect-Expr.html
18:07:09 <zRecursive> ReinH: thx
18:07:22 <FreeFull> [0,1,(0+1),(1+(0+1)),((0+1)+(1+(0+1)))...
18:07:49 <FreeFull> Each time you just sum the previous two values
18:08:02 <geekosaur> generally when we talk about thunks, we mean anonymous functions that are managed internally by the compiler/interpreter; if I have to create and dereference manually it's not a thunk, but if the compiler does that for me it is
18:08:35 <ReinH> oh duh you can just: take 6 $ fibLikes (0 :: Expr) (1 :: Expr)
18:08:41 <ReinH> boom [0,1,0 + 1,1 + (0 + 1),0 + 1 + (1 + (0 + 1)),1 + (0 + 1) + (0 + 1 + (1 + (0 + 1)))]
18:08:58 <ReinH> I don't always use simple-reflect, but when I do it blows my mind.
18:09:17 <FreeFull> @let recSec n f xs = let xs' = xs ++ map (f . take n) (tails xs')
18:09:18 <lambdabot>  Parse failed: Parse error: EOF
18:09:33 <FreeFull> @let recSec n f xs = (let xs' = xs ++ map (f . take n) (tails xs'))
18:09:33 <lambdabot>  Parse failed: Parse error: )
18:09:46 <FreeFull> @let recSec n f xs = let xs' = xs ++ map (f . take n) (tails xs') in xs'
18:09:48 <lambdabot>  Defined.
18:10:14 <FreeFull> > take 6 $ recSec 2 sum (0 :: Expr) (1 :: Expr)
18:10:15 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr
18:10:15 <lambdabot>                ...
18:10:29 <FreeFull> Ah, I guess sum doesn't work for Expr
18:10:32 <ReinH> FreeFull: unfortunately there's no way to ensure a correspondence between n and length xs
18:11:17 <FreeFull> ReinH: You could using Nat and a List+length type
18:11:30 <ReinH> rephrase: there's no practical way ;)
18:11:45 <FreeFull> It would be simpler in a dependently-typed language
18:12:00 <FreeFull> > take 6 $ recSec 2 sum (0 :: Expr) (1 :: Expr) :: Expr
18:12:01 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr
18:12:01 <lambdabot>                ...
18:12:05 <FreeFull> > take 6 $ recSec 2 sum (0 :: Expr) (1 :: Expr) :: [Expr]
18:12:06 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr
18:12:06 <lambdabot>                ...
18:12:17 <FreeFull> > take 6 $ recSec 2 ([a,b] -> a+b) (0 :: Expr) (1 :: Expr) :: [Expr]
18:12:18 <lambdabot>   Pattern syntax in expression context: [a, b] -> a + b
18:12:26 <ReinH> heh
18:12:27 <FreeFull> > take 6 $ recSec 2 (\[a,b] -> a+b) (0 :: Expr) (1 :: Expr) :: [Expr]
18:12:28 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr
18:12:28 <lambdabot>                ...
18:12:33 <ReinH> lambdabot is not amused
18:12:41 <FreeFull> Ok, I really should look at the full error message
18:12:48 <ReinH> might be useful
18:13:03 <ReinH> Couldn't match expected type ... guess!
18:13:27 <FreeFull> Oh, duh
18:13:40 <hpaste> DanBurton pasted “foldl' optimization” at http://lpaste.net/91580
18:13:48 <FreeFull> > take 6 $ recSec 2 (\[a,b] -> a+b) [0,1] :: [Expr]
18:13:52 <lambdabot>   mueval-core: Time limit exceeded
18:14:00 <FreeFull> > take 6 $ recSec 2 sum [0,1] :: [Expr]
18:14:04 <lambdabot>   mueval-core: Time limit exceeded
18:14:08 <FreeFull> > take 6 $ recSec 2 sum [0,1]
18:14:11 <lambdabot>   [0,1,1,2,3,5]
18:14:23 <DanBurton> Is there any reason why this foldl' optimization is not used generally? ^
18:14:38 <FreeFull> > sum [1,2,3,4] :: [Expr]
18:14:39 <lambdabot>   No instance for (GHC.Num.Num [Debug.SimpleReflect.Expr.Expr])
18:14:39 <lambdabot>    arising fr...
18:14:42 <FreeFull> > sum [1,2,3,4] :: Expr
18:14:43 <lambdabot>   0 + 1 + 2 + 3 + 4
18:14:49 <ReinH> huh
18:15:22 <FreeFull> > take 4 $ recSec 2 sum [0,1] :: [Expr]
18:15:26 <lambdabot>   [0,1,0 + 0 + 1,0 + 1 + (0 + 0 + 1)]
18:15:55 <ReinH> ah ha.
18:16:52 <FreeFull> > recSec 1 head [0..]
18:16:55 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:17:21 <ReinH> huh
18:18:32 <FreeFull> > recSec 2 ((+1) . max) [0,1]
18:18:33 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0] -> [a0]
18:18:33 <lambdabot>  Expect...
18:19:39 <FreeFull> @pl \[a,b] -> max a b
18:19:39 <lambdabot> (line 1, column 2):
18:19:39 <lambdabot> unexpected "["
18:19:39 <lambdabot> expecting pattern
18:20:19 <ReinH> silly FreeFull, a is not [a] ;)
18:20:38 <FreeFull> ReinH: It's more that  a -> a -> a  isn't [a] -> a
18:20:45 <FreeFull> > recSec 2 ((+1) . maximum) [0,1]
18:20:48 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:20:56 <ReinH> FreeFull: right, but it's trying to unify a and [a] :p
18:21:45 <FreeFull> > recSec 2 ((+1) . head) [0]
18:21:48 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:21:56 <FreeFull> Huh
18:22:04 <FreeFull> Seems like the number can be bigger than the length of the list after all
18:22:29 <FreeFull> Depends on what the function provided des
18:22:31 <FreeFull> does*
18:22:40 <FreeFull> > recSec 1 ((+1) . head) [0]
18:22:43 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:22:49 <FreeFull> Yeah, of course it's the same
18:25:56 <FreeFull> > recSec 1 ((^2) . (+1) . head) [0]
18:25:59 <lambdabot>   [0,1,4,25,676,458329,210066388900,44127887745906175987801,19472704769152964...
18:26:14 <FreeFull> I wonder how fast that grows
18:36:19 <ReinH> FreeFull: I can give you an upper bound ;)
18:38:51 <Dextr> hi
18:39:04 <ReinH> Dextr: hi
18:39:22 <Dextr> is "real world haskell" (the book) still a good place to start? or should i be looking at something else instead?
18:39:53 * hackagebot texmath 0.6.3 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.3 (JohnMacFarlane)
18:41:21 <dpwright_> Dextr: I like it
18:41:37 <Dextr> so the changes in 2010 weren't too big?
18:41:50 <dpwright_> it's probably a matter of taste.  Personally I found it easier to get into than "learn you a haskell"
18:42:04 <elliott> Dextr: RWH is outdated in several parts. but the outdatedness is not related to the language standard
18:42:37 <dpwright_> I'm still pretty new to haskell, so I couldn't comment, but I haven't come across anything I can't do because of changes -- whether those things are "best practice" or not I have no idea
18:42:42 <Dextr> elliott how else is it outdated then?
18:43:03 <elliott> Dextr: e.g., recommending ByteString for text (this advice is obsolete because one of the authors wrote the text library afterwards :) )
18:43:12 <elliott> and some minor things like using old names for mtl constructors.
18:43:25 <Dextr> oh, ok, so nothing essential?
18:43:48 <geekosaur> it talks about old style exceptions
18:44:19 <geekosaur> anyway essentials are correct, some details need to be updated
18:44:41 <geekosaur> the online version has a wiki associated with it which should have many of the updates
18:45:01 <Dextr> We had a brief intro to haskell in the last semester, and I ran into some sort of incompatibility with typeclasses between hugs (that we should have been using for the course) and ghc which was what people here were telling me to use..
18:45:14 <tabemann> okay, I'm doing Haskell for my STM lecture at work dammit (I'm also providing examples from the Java STM impl. Multiverse along with some of my Haskell, just to placate my Java-programming coworkers)
18:45:32 <Dextr> now the semester is over and I wanted to take a proper look at .. and wanted to avoid again learning old things
18:46:26 <tabemann> (I had to present a *very* small subset of Multiverse because it is huge and complex, whereas I could cover basically all the core functionality in Haskell STM aside from things like exception handling)
18:46:39 <geekosaur> courses based on hugs :(
18:46:48 <tabemann> why are they still using hugs?
18:47:05 <monochrom> I like hugs :)
18:47:22 <Dextr> my guess is that it had something to do with the interactive environment
18:47:36 <tabemann> but GHC *does* have an interactive environment...
18:48:05 <Dextr> not according to what we were told.. but yeah, i can see that it does
18:48:07 <tabemann> maybe they've been teaching these courses for years and not realized that Hugs is generally considered obsolescent
18:48:26 <geekosaur> winghci was a bit slow in showing up and early versions were buggy
18:48:35 <geekosaur> (compare winhugs)
18:49:10 <tabemann> when I was in school they made us do (most of) our work on Solaris...
18:49:33 <Zenol> ReinH: http://ideone.com/OrvgzT
18:50:04 <Zenol> ReinH: I havent write the rule but you have the display, and an easy way to write what you want in the grid :)
18:50:38 <Zenol> ReinH: Although you should read bottom->up the test2d function because I use .
18:50:43 <Dextr> tabemann solaris still runs some departments' webservers at our uni
18:51:31 <tabemann> well this was a decade (or a little less) ago
18:54:00 <tabemann> last time I checked in the CS department at Madison they were using Linux
18:55:45 <tabemann> dammit... I should probably actually code up some code examples in Java using Multiverse, but I really don't want to...
19:02:26 <tabemann> hmm... I kinda want to use the Santa Claus Problem, but it doesn't like like SPJ's code'll fit on a single slide
19:02:45 <tabemann> (and it looks too elaborate to easily explain to my Java-coding coworkers)
19:05:08 <Zenol> they are something really weird that isn't working in my code :(
19:05:24 <Zenol> first time something compile but really don't works :/
19:12:10 <Zenol> ok, my comonad instance should be wrong...
19:18:59 <CaptainK> kindof like grammer, your and you're, both will pass spell check, but can mean different results?
19:21:41 <ReinH> Zenol: for neighbor counts you probably want to get a list of neighbors and then length $ filter (==True) neighbors
19:22:43 <ReinH> should be simpler that way
19:23:05 <ReinH> you don't need toNum
19:25:34 <Zenol> hey hey, it's working \ o / : http://ideone.com/OrvgzT
19:26:14 <Zenol> yap, I could do length $ filter.
19:26:23 <Zenol> Lets do that, and then goto sleep :)
19:26:46 <Zenol> but making the right comond instance is really hard. The typecheck won't help you :(
19:27:04 <Zenol> and now, I don't know how to make it for n dimensional spaces.
19:27:33 <ReinH> Zenol: woo!
19:28:22 <ReinH> Zenol: r pentomino ftw
19:28:40 <augur> Zenol: whats this!
19:29:06 <ReinH> augur: comonadic Conway's Game of Life :D
19:29:13 <augur> ahh
19:29:41 <ReinH> pretty nice
19:29:46 <tac> if a monad is a monoid in the category of endofunctors... what's a comonad?
19:30:05 <Zenol> r pentomino ?
19:30:19 <Zenol> oh, it's just pure hasard.
19:30:20 <augur> portofino
19:30:37 <BMeph> ReinH: Shame on you! filter id, not filter (==True).... Sheesh, kids these days! ;)
19:30:43 <Zenol> just put randomely some left/right/up ...
19:31:00 <ReinH> BMeph: :p
19:31:14 <ReinH> I think filter (==True) is more intention revealing
19:31:20 <ReinH> even though it's not strictly necessary
19:31:21 <augur> filter id on bools is pointless for infinite lists
19:31:24 <sirspazzolot> I have a list of fibonacci numbers that I know is in ascending order. how might I iterate through the list only up until the first element that exceeds a certain value?
19:31:42 <sirspazzolot> (it's an infinite list so a guard in a list comprehension will not work)
19:31:52 <ReinH> sirspazzolot: takeWhile?
19:32:12 <augur> better idea: sirspazzolot, you define a function!
19:32:15 <Zenol> oh, yes, filter id xD
19:32:25 <augur> Zenol: dont filter id tho
19:32:28 <sirspazzolot> oh haha that sounds like exactly what I want
19:32:31 <ReinH> sirspazzolot: also, euler?
19:32:33 <augur> (==True) is reasonable
19:32:37 <sirspazzolot> ReinH: exactly heh
19:32:41 <ReinH> augur: it's not an infinite list in this case
19:32:45 <augur> sirspazzolot: best that you define the function yourself so you understand what its doing
19:32:49 <ReinH> augur: it's the neighbor list
19:32:53 <augur> ReinH: o ok
19:32:55 <elliott> tac: a comonad is a comonoid in the category of endofunctors.
19:33:07 <elliott> tac: or equivalently, a monoid in the opposite category of endofunctors.
19:33:14 <Zenol> augur: Why not filter id?
19:33:19 <augur> elliott: a comonad is a comonoid in the cocategory of coendo cofunctors!
19:33:25 <Zenol> augur: It's funny to read like that \ o /
19:33:29 <augur> Zenol: ReinH's comment on intention is better
19:33:30 <elliott> no it isn't.
19:33:35 <sirspazzolot> since augur suggested it, may as well figure this now. how might one declare a function with guards in ghci
19:33:38 <ReinH> well yes obviously, but what is the opposite category of endofunctors?
19:33:50 <augur> elliott: it is for comedy's sake!
19:34:01 <Zenol> augur: ok :(
19:34:06 <augur> sirspazzolot: you dont need a function with guards
19:34:07 <Zenol> so, sleep.
19:34:22 <Zenol> Wasn't expecting that comonad leads me to the r pentomino \ o /
19:34:39 <sirspazzolot> augur: how else might one check for a parameter >x?
19:34:44 <Zenol> good night
19:34:48 <sirspazzolot> good night Zenol
19:35:03 <augur> sirspazzolot: that's a very good question, how might you do that!
19:35:04 * BMeph smirks: Nobody expects the Comonadic Inquisition!
19:35:12 <augur> coinquisition
19:35:31 <sirspazzolot> I'm only in the type section of lyah heh
19:35:33 <geekosaur> as distinct from the Coquisition?
19:35:34 <ReinH> BMeph: our chief weapons are extend and duplicate
19:35:36 <sirspazzolot> just got a little ahead of myself
19:35:44 <augur> sirspazzolot: then you should keep reading :)
19:36:01 <ReinH> Among out weaponry are such diverse functions as extend, duplicate, extract, fmap, liftW, wfix...
19:36:08 <ReinH> *our
19:36:12 <sirspazzolot> augur: a brilliant friend of mine threatened to learn haskell before I have time to so I panicked :P
19:36:16 <edwardk_> Our two combinators are extend and extract and fmap, our three combinators are extend and extract and fmap and duplicate, our four combinators are extend and extract and fmap and duplicate and (<$)...
19:36:19 <augur> amongst*
19:36:27 <augur> (among is fine, but they say amongst, so)
19:36:29 <ReinH> edwardk_: :D :D
19:36:42 <ReinH> augur: argh
19:36:46 <ReinH> ofc they do
19:36:48 <augur> sirspazzolot: so? congratulate him on learning haskell!
19:36:50 <ReinH> because british
19:36:54 <BMeph> ReinH: And loeb! ;)
19:37:08 <augur> ReinH: i think its more because irritating character
19:37:16 <BMeph> edwardk: See above. ;)
19:37:30 <ReinH> edwardk_: we need an o_O combinator
19:37:37 <ReinH> foo `o_O` bar
19:37:45 <augur> also edwardk_, they progress using normal conjunctions
19:37:48 <augur> X, Y, and Z
19:37:56 <augur> and then tack someone on with another and
19:38:13 <edwardk_> ReinH: you should see about adding it to http://hackage.haskell.org/packages/archive/acme-lookofdisapproval/0.1/doc/html/Acme-LookOfDisapproval.html
19:38:32 <ReinH> oh my god
19:38:38 <ReinH> this is the best thing ever
19:38:41 <sirspazzolot> hoorah, problem 2 solved. I guess I'll keep on with lyah instead of bugging irc to tell me about functions included in prelude
19:38:44 <sirspazzolot> B)
19:38:52 <sirspazzolot> thanks for the help, all
19:38:58 * BMeph wonders: Is the comonad's utility incidental? Or COincidental? ;p
19:39:13 <augur> Our main weapon is surprise, surprise and fear, our TWO weapons are surprise and fear and ruthless efficiency! Three, our three weapons are suprise, fear, and ruthless efficiency and fanatical devotion to the pope! .. I'll start again.
19:39:25 <edwardk_> We do not talk about the cocoa incident.
19:39:33 <augur> Amongst our weaponry are surprise, fear, ruthless efficiency, and fanatical devotion to the pope. And snazzy red dresses~
19:40:14 <ReinH> BMeph: you mean its coutility?
19:40:24 <augur> sirspazzolot: its often best to define things yourself rather than use prelude
19:40:28 <augur> when learning, i mean
19:40:30 <BMeph> ReinH: But, of urse! ;p
19:41:16 <edwardk_> I definitely agree with augur that implementing things yourself is a great way to learn them. I may have never figured out when to stop doing that though.
19:41:20 <ReinH> BMeph: if you think mathematical models are incidental then their utility is also incidental, I guess.
19:41:36 <augur> edwardk_: have you finished implementing the universe yet?
19:41:54 <edwardk_> @hackage universe
19:41:54 <lambdabot> http://hackage.haskell.org/package/universe
19:41:59 <edwardk_> dmwit beat me to it
19:42:04 <augur> :p
19:42:08 <augur> Data.Universe, yeah
19:42:10 <ReinH> edwardk_: and what is your ETA on the apple pie combinator?
19:42:15 <augur> not entirely sure why the name choice tho
19:42:22 <edwardk_> me neither
19:42:34 <edwardk_> otoh, someone took patterns for something that had nothing to do with patterns
19:42:37 <edwardk_> @hackage patterns
19:42:37 <lambdabot> http://hackage.haskell.org/package/patterns
19:42:44 <edwardk_> so naming is somewhat fluid
19:43:05 <edwardk_> when i hear 'patterns' i don't immediately think 0mq ;)
19:43:31 <ReinH> how rude
19:43:48 <ReinH> I would have preferred "mom"
19:43:50 <ReinH> https://github.com/toschoo/mom
19:44:00 <edwardk_> my current obsessions are with kan lifts and semiindexing
19:44:07 <ReinH> go on...
19:44:29 <edwardk_> i haven't put these obsessions together yet ;)
19:44:37 <ReinH> heh
19:44:48 <ReinH> whenever you do I'm sure you'll put out a package
19:44:50 <edwardk_> i'll be back in a few minutes
19:44:56 <ReinH> that will take the rest of us about 2 years to understand
19:45:18 <edwardk_> thats how i slow the rest of you down enough to keep you off my tail ;)
19:46:00 <BMeph> edwardk_: No, threatening you with making documentation for us is how We slow You down! ;p
19:47:44 <ReinH> edwardk_: per our discussion of Sunday, I give you: acme-dont http://hackage.haskell.org/package/acme-dont
19:47:46 <edwardk_> BMeph: i actually bothered to start writing docs for kan-extensions while i was hacking on this ;)
19:48:07 <edwardk_> ReinH: yeah i was going to mention it during the session but i figured it was too obscure
19:48:12 <ReinH> heh
19:48:21 <edwardk_> also another 'don't' is to use don't = return ()
19:48:23 <edwardk_> so you can say
19:48:28 <edwardk_> if x then do … else don't
19:48:42 <cschneid> so generally, pure code doesn't use exceptions, and instead uses Maybe or Either, or similar approaches to error handling?
19:48:57 <cschneid> is that right, or am I misinterpreting my reading of the docs
19:49:00 <edwardk_> cschneid: yeah use exceptions for _truly_ exceptional control flow
19:49:06 <cschneid> then exceptions are for IO stuff that really can fail
19:49:09 <edwardk_> yeah
19:49:12 <cschneid> ie, file disappears out from under us or whatever
19:49:14 <joelteon> don't $ do ...
19:49:15 <cschneid> cool.
19:49:18 <edwardk_> or for where your invariants are totally screwed up
19:49:29 <dolio> Why would you use that instead of 'when x $ do ...'?
19:49:33 <lingxiao> edwardk : can I ping you now about the older version of machines you mentioned earlier?
19:49:36 <edwardk_> dolio: you wouldn't
19:49:41 <dolio> Oh.
19:49:43 <edwardk_> when/unless are universally superior
19:49:45 <elliott> dolio: that's why it's a don't, presumably.
19:49:48 <lingxiao> that is if you have a moment
19:50:04 <cschneid> edwardk_: like pattern matching against a negative number when that's totally illegal to call with that value (for whatever function)? that's sorta a "legit" place to throw an exception?
19:50:13 <edwardk_> i still wish elliott and shachaf had let me take is to go with isn't ;)
19:50:22 <edwardk_> cschneid: yeah
19:50:35 <edwardk_> cschneid: thats a large part of why we have error and undefined
19:50:41 <edwardk_> > fix error
19:50:42 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
19:50:48 <cschneid> error is throwing your hands up and quitting right?
19:50:53 <cschneid> or is it an exception
19:51:06 <ReinH> edwardk_: 'tis
19:53:02 <danharaj> edwardk: what does the free monad look like in the category of profunctors?
19:55:36 <ReinH> "w is a strong lax symmetric semi-monoidal functor on Hask"
19:55:43 <ReinH> oh ok then
19:56:09 <ahill-89> That's a lot of words that I know individually.
19:56:24 <ahill-89> I suppose this means I have some reading to do.
20:04:57 <ReinH> edwardk: I'm trying to figure out what I need to learn to understand https://github.com/ekmett/kan-extensions/blob/master/src/Data/Functor/KanExtension.hs
20:06:41 <augur> http://www.reddit.com/r/haskell/comments/1jrj7o/sum_11billion_in_haskell/cbht08v obviously my answer is the best answer >_>
20:09:30 <LevelOneDev> Hello all
20:09:40 <LevelOneDev> I have a dumb question that is hard to google
20:09:57 <augur> lets have it!
20:10:17 <joelteon> is it composed entirely of symbols?
20:10:18 <LevelOneDev> What is the best way to get a list that's 1.. x/2 to half of x
20:10:19 <joelteon> those are hard to google
20:10:27 <LevelOneDev> Mostly yeah
20:10:37 <LevelOneDev> I understand it produces a fraction
20:10:43 <augur> LevelOneDev: so you want a list, 1, 2, 3, ..., x/2 ?
20:10:54 <LevelOneDev> augur: Yes.
20:10:58 <joelteon> [1..x/2] ?
20:11:05 <applicat1ve> > let x = 10 in [1.. x `div` 2]
20:11:07 <lambdabot>   [1,2,3,4,5]
20:11:07 <LevelOneDev> Complains about it not being an Int
20:11:21 <LevelOneDev> let me try `div`
20:11:29 <applicat1ve> yes use div or whatever, not / which if for 'Floating' things
20:11:39 <applicat1ve> is for them, rather
20:11:51 <applicat1ve> > let x = 11 in [1.. x `div` 2]
20:11:52 <lambdabot>   [1,2,3,4,5]
20:12:16 <ReinH> applicat1ve: hai
20:12:21 <LevelOneDev> Thanks a bunch
20:12:23 <applicat1ve> hey ReinH
20:13:34 <LevelOneDev> I am using project euler problems to help learn Haskell. It has been working OK
20:13:35 <LevelOneDev> haha
20:21:13 <augur> LevelOneDev: you'd do better to lyah
20:21:15 <augur> @where lyah
20:21:15 <lambdabot> http://www.learnyouahaskell.com/
20:22:12 <edwardk_> > take 10 $ let gold = "1":"10":zipWith (++) (tail gold) gold in gold
20:22:13 <lambdabot>   ["1","10","101","10110","10110101","1011010110110","101101011011010110101",...
20:22:49 <augur> edwardk_: wossat
20:23:30 <edwardk_> http://www.johndcook.com/blog/2013/07/23/golden-strings/
20:23:34 <LevelOneDev> Now I just need a better prime function.
20:23:36 <augur> 1,2,5,22
20:23:44 <LevelOneDev> augur: Do better to lyah?
20:23:55 <augur> LevelOneDev: yes, read lyah, dont do project euler
20:24:33 <LevelOneDev> Oh Learn you a Haskell. Yes I've already read a lot of it. It has helped a lot
20:25:29 <ReinH> edwardk: we've been generalizing fibonacci sequences all day :)
20:25:46 <LevelOneDev> augur: I meant it's going just OK because I haven't been writing the most efficient algorithms up front. My first thoughts are terrible :-P
20:25:53 <augur> edwardk_: huh. predictably (?) it's fibonacci of some sort
20:25:54 <edwardk_> ReinH: how timely ;)
20:25:59 <edwardk_> augur: yeah
20:26:06 <augur> http://oeis.org/A005203
20:26:12 <Ghoul_> sirspazzolot: f x = case x of { 1 -> ....; _ -> ... } works
20:26:14 <hpaste> tabemann pasted “Santa Claus” at http://lpaste.net/91581
20:26:20 <ReinH> arbitrary fibonacci sequence for semigroups: fibLike n m = let xs = fibLike n m in n : m : zipWith sappend xs (tail xs)
20:26:25 <Ghoul_> On the other hand, you can also just define functions with the pattern matches in the parameters
20:26:28 <Ghoul_> f 0 = ...
20:26:33 <Ghoul_> f 1 = error "You done wrong!"
20:26:34 <ReinH> in this case fibLike "1" "10" :)
20:26:42 <ReinH> oh wait
20:26:45 <hpaste> tabemann revised “Santa Claus”: “Santa Claus” at http://lpaste.net/91581
20:26:53 <ReinH> fibLike (Dual "1") (Dual "10")
20:27:07 <edwardk_> http://oeis.org/A005614
20:27:19 <edwardk_> > concat $ let gold = "1":"10":zipWith (++) (tail gold) gold in gold
20:27:20 <lambdabot>   "11010110110101101011011010110110101101011011010110101101101011011010110101...
20:27:23 <tabemann> any thoughts on my reimplementation of the Santa Claus problem?
20:27:35 <edwardk_> oh, different sequence
20:27:38 <ReinH> heh
20:27:52 <augur> edwardk_: how weird that its a free binary monoid fibonacci sequence
20:28:08 <augur> that happens to be interpretable as numbers that are themselves fibonacci-esque
20:28:09 <edwardk_> > concat $ let gold = "1":"10":zipWith (++) gold (tail gold) in gold
20:28:10 <lambdabot>   "11011010110110101101011011010110110101101011011010110101101101011011010110...
20:28:17 <augur> and definable in terms of fibonacci numbers
20:29:11 <centrinia> > concat $ let gold = "1":"10":zipWith (++) gold (tail gold) in map (length . filter (=='1')) $ tails gold
20:29:12 <lambdabot>   Couldn't match type `[GHC.Types.Char]' with `GHC.Types.Char'
20:29:12 <lambdabot>  Expected type...
20:29:27 <centrinia> > let gold = "1":"10":zipWith (++) gold (tail gold) in map (length . filter (=='1')) $ tails $ concat gold
20:29:30 <lambdabot>   mueval-core: Time limit exceeded
20:29:43 <centrinia> > let gold = "1":"10":zipWith (++) gold (tail gold) in map (length . filter (=='1')) $ tails $ take 20 $ concat gold
20:29:44 <lambdabot>   [13,12,11,11,10,9,9,8,8,7,6,6,5,4,4,3,3,2,1,1,0]
20:30:15 <ReinH> edwardk_: here's a fun one: if a "tribonacci sequence" is let tribs = 0 : 0 : 1 : zipWith3 \a b c -> (a+b+c) tribs (tail tribs) (tail (tail tribs))
20:30:24 <chenwl> I define a Writer type `type W a = (a, String)` and make it an instance of Monad `instance Monad W where` ... without any language extensions nor imports
20:30:29 <ReinH> edwardk_: how would you generalize that to higher orders?
20:31:05 <chenwl> ghc --make file.hs complain an error     Illegal instance declaration for `Monad W'
20:31:08 <chenwl>       (All instance types must be of the form (T t1 ... tn)
20:31:11 <chenwl>        where T is not a synonym.
20:31:13 <chenwl>        Use -XTypeSynonymInstances if you want to disable this.)
20:31:16 <chenwl>     In the instance declaration for `Monad W'
20:31:23 <geekosaur> don't paste into the channel
20:31:41 <edwardk_> @oeis 2, 7, 13, 149, 19341322569415713958901
20:31:41 <chenwl> sorry
20:31:42 <lambdabot>  Prime tribonacci numbers.[2,7,13,149,19341322569415713958901,157626795420711...
20:31:45 <geekosaur> and the error tells you exactly what is wrong
20:31:51 <geekosaur> "where T is not a synonym:
20:31:57 <geekosaur> `type` creates synonyms
20:32:04 <ReinH> edwardk_: lmao, there's an oeis sequence for everything
20:32:17 <arkeet> > let foo a f = a ++ f (tails (foo a f)) in foo [0,1] (sum . take 2)
20:32:18 <lambdabot>   No instance for (GHC.Show.Show a0)
20:32:18 <lambdabot>    arising from a use of `M448173527.sho...
20:32:20 <arkeet> hmm
20:32:22 <ReinH> edwardk_: but seriously, how?
20:32:27 <ReinH> something something applicative
20:32:31 <arkeet> nope.
20:32:33 <arkeet> I messed it up.
20:32:34 <arkeet> sorry.
20:33:02 <edwardk_> ReinH: something something take n . tails
20:33:19 <augur> ReinH: not everything, just 227581 things minimum. :)
20:33:19 <danharaj> umm does anyone know why I'm getting a stack overflow when I call myThreadId?
20:33:27 <ReinH> edwardk_: something something ZipList?
20:33:35 <arkeet> yeah I forgot a ZipList.
20:33:39 <ReinH> handwave handwave ZipList
20:33:45 <ReinH> QED
20:34:02 <hpaste> chenwl pasted “instance of monad” at http://lpaste.net/91583
20:34:12 <geekosaur> chenwl, so if you really want to do that with the type synonym you need to enable TypeSynonymInstances. alternately rewrite your `type` into a `data` (this will require a data constructor, you can't just use a raw tuple)
20:34:33 <arkeet> > let foo a f = a ++ f (tails (foo a f)) in foo [0,1] (map sum . transpose . take 2)
20:34:34 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:35:19 <arkeet> transpose is like ZipList, right.
20:36:08 <chenwl> geekosaur: I tried again with TypeSynonymInstances enabled, ghc says W should have 1 argument
20:36:08 <arkeet> > let foo a f = a ++ f (tails (foo a f)) in foo [0,0,1] (map sum . transpose . take 3)
20:36:08 <lambdabot>   [0,0,1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890...
20:39:04 <ReinH> chenwl: maybe it should have 1 argument then
20:46:45 * tabemann wonders whether there are any good concurrency problems out there other than the dining philosophers and the santa claus problem...
20:50:35 * tabemann wonders how many slides his impl. of the Santa Claus problem will fit onto, as it doesn't look like it'll fit onto just one...
20:50:57 <dpwright_> I am working with a C library exposing a number of functions from a dll
20:51:42 <dpwright_> the library itself is for connecting to a particular piece of hardware, and only supports connecting to one of these things at a time
20:51:56 <dpwright_> so it has a "connect" function and a "getCurrentConnected" function
20:52:54 <dpwright_> the reference code (which is in C++) appears to get around this by loading the dll multiple times, and creating a "handle" class which stores function pointers to the equivalent functions for each instance of the dll
20:53:20 <dpwright_> so you can call handle->getCurrentConnected and it will return the currently connected unit for that particular instance
20:53:55 <dpwright_> is it possible to do something similar using haskell's FFI?
20:54:52 <bscarlet> dpwright_: what does the C++ code do to load the dll multiple times? That seems to be the essential bit.
20:56:08 <tabemann> I for one would be tempted to place the code for manhandling the library outside of Haskell, in C, and call *that* library with the FFI
20:56:26 <tabemann> as I don't think the Haskell FFI is designed to juggle multiple copies of a given DLL in memory
20:56:45 <dpwright_> bscarlet: The C++ code calls LoadLibrary in the constructor for this handle class, and then runs a series of "GetProcAddress" calls to get the function pointers (I think these are Win32 specific functions)
20:57:37 <bscarlet> dpwright_: you'd have to do that somewhere. You could either call LoadLibrary & GetProcAddress with FFI, or with C-code which you write and call through FFI.
20:57:45 <tabemann> I don't think you can do that from within Haskell itself; you'll have to write your own code to wrap the library that does that
20:57:52 <tabemann> and call that from Haskell
20:58:01 <dpwright_> tabemann: I had wondered if this might be the case.  In actual fact, I am currently accessing the dll through a static library (supplied by the vendor) which handles loading a single instance of the dll, so I guess it's just an extension of that
20:58:34 <bscarlet> tabemann: why couldn't he do that from Haskell?
20:59:06 <geekosaur> that'd be the "with FFI" part of tabemann's suggestion
20:59:48 <bscarlet> geekosaur: ?
21:00:16 <geekosaur> nemmind I misread
21:00:20 <dpwright_> from what I've seen of the Win32 headers, writing imports for those functions sounds like a daunting task
21:00:36 <geekosaur> that was your suggestion, and tabemann is a little confused about the ffi I guess
21:01:06 <geekosaur> not that I would want to do this, but the whole multiple copies of a DLL with DLL-local data is just icky
21:01:27 <tabemann> geekosaur: can the FFI dynamically look up bindings in DLLs by name and reload those DLLs multiple times, getting different bindings for the same name each time?
21:01:43 <tabemann> somehow I suspect that's a no
21:01:44 <geekosaur> not directly
21:01:56 <geekosaur> that's why you are making FFI bindings to LoadLibrary and GetProcAddress
21:02:01 <geekosaur> so *you* can do it
21:02:17 <dpwright_> http://darcs.haskell.org/packages/Win32/System/Win32/DLL.hsc
21:02:17 <geekosaur> instead of asking the FFI to do it for you
21:02:19 <dpwright_> looks promising
21:02:59 <bscarlet> dpwright_: yep
21:04:27 <dpwright_> ok -- thanks guys!  I'll give that a go
21:04:44 <tabemann> the only question with that is how to turn the Addr gotten with getProcAddress into something that can be called from within Haskell
21:05:58 <bgamari> Hmm, I guess there really isn't any way to use async within a transformer stack, eh?
21:07:13 <bscarlet> Addr is a type synonym for Ptr ()
21:08:30 <tabemann> okay, yeah, then there's castPtrToFunPtr
21:09:56 <bscarlet> That'll get you a FunPtr, then you need an ffi wrapper.
21:11:45 <evancz> has anyone ever observed cross-OS problems with Data.Binary?
21:12:00 <evancz> I am getting errors with "get" on windows but not OSX and Linux
21:12:19 <evancz> I guess this is a typical thing, but is there anything I should watch out for in particular?
21:12:23 <evancz> when debugging
21:15:41 <clj_newb_2345> so I'm doing a study on parsec (which I implemented myself for fun) and packrat (which I only read the paper about)
21:15:55 <clj_newb_2345> from what I have read, packrat is basically dynamic-programming reading the string back to front
21:16:09 <clj_newb_2345> which explains the linear time, linear space, ... but also means it has shitty error messages, no?
21:16:51 <clj_newb_2345> and as for parsec -- is there any tutorial on how to encode operator _precedence_ into parsec?
21:19:44 <johnw> clj_newb_2345: usually precedence is managed by the sequence of evaluation
21:20:05 <clj_newb_2345> so how is parsec supposed to correclty parse 1 + 2 * 3?
21:20:12 <johnw> you have two parser
21:20:14 <johnw> addExpr and mulExpr
21:20:22 <johnw> addExpr calls mulExpr
21:20:26 <edwardk_> clj_newb_2345: packrat doesn't have to give crap error messages
21:21:16 <edwardk_> clj_newb_2345: http://comonad.com/reader/2011/a-parsec-full-of-rats/  http://comonad.com/reader/2011/a-parsec-full-of-rats-part-2/index.html  describes implementing packrat on parsec-like foundations
21:21:18 <clj_newb_2345> johnw: can you recommend a more detailed link to read?
21:22:01 <edwardk_> re precedence parsing see the text.parsec.expression or text.parser.expression machinery
21:22:18 <edwardk_> they build a pretty basic expression parser with nested precedence levels
21:22:32 <edwardk_> alternately google for 'shunting yard parser'
21:23:21 <edwardk_> hat can be done much more efficiently than the parsec-like expression parser
21:24:49 <clj_newb_2345> edwardk_: I like the shunting yard parser
21:25:15 <clj_newb_2345> what is "hat" in the context of parsing?
21:25:49 <clj_newb_2345> edwardk_: when you say packrat doesn't have to give bad error messages, is this linear-time packrat, or the monadic extension you're suggesting?
21:26:14 <edwardk_> linear time packrat
21:26:40 <clj_newb_2345> edwardk_: how do you get good error messages when you're reading the file backwards?
21:27:06 <edwardk_> your parse result for each packrat parser can be the error context or the result
21:27:12 <edwardk_> then you roll the error context back up
21:27:25 <edwardk_> LALR parsers 'parse backwards' too in many ways
21:27:32 <edwardk_> and they give pretty awesome error messages
21:28:16 <edwardk_> packrat is just a bit of memoization on top of otherwise pretty standard recursive descent techniques.
21:28:48 <edwardk_> just because the implementations so far have mostly sucked doesn't mean that they have to suck
21:36:55 <clj_newb_2345> edwardk_: signing off, but thanks for the link to Dijkstra's shunting yard algorithm -- it's one of those cool things that once you understand it, makes an annoying problem trivial
21:38:01 <edwardk_> note: you can write a simple recursive descent parser without needing the shunting yard, but the yard makes it easy to have arbitrary numbers of levels of precedence
21:38:26 <edwardk_> whereas with a more direct approach you usually have to pick some number of levels
22:01:08 <davesque> hey, i'm trying to figure out how to implement this function in a little parser library i'm writing: http://lpaste.net/91585
22:01:30 <davesque> basically, it should just take a parser and yield another one that will parse until it fails and return the results
22:02:35 <davesque> any help would be appreciated
22:15:40 <Saizan> davesque: if you just use the implementation details of Parser it shouldn't be hard
22:16:03 <Saizan> davesque: call the given parser on the input string and check for the empty list
22:18:56 <mstksg> i am not sure why google isn't giving me a good answer for this but how does haskell handle equality in tuples? is it even defined?
22:19:02 <mstksg> > (1,2) == (1,3)
22:19:03 <lambdabot>   False
22:19:14 <danharaj> :i (,)
22:19:26 <mstksg> huh i could have sworn that returned true in my ghci
22:20:43 <mstksg> carry on, this is kind of embarassing
22:21:39 <davesque> Saizan: but how do i continue to call that parser on the string if i get a non-empty list? (without hand-typing a function out to infinity)
22:22:04 <scottj> mstksg: LYAH says "All standard Haskell types except for IO (the type for dealing with input and output) and functions are a part of the Eq typeclass." There's probably a way to check at repl if a type is a member of a typeclass, but I'm a newb
22:23:41 <apples> :i <type>
22:23:51 <davesque> Saizan: actually, maybe i could define it recursively.  nevermind.  let me give that a try.
22:25:27 <Saizan> yeah, you have to recurse
22:33:56 <frx> hello
22:33:59 <frx> why doesn't this work?
22:34:04 <frx> > getZonedTime >>= (formatTime defaultTimeLocale "%H:%M:%S")
22:34:06 <lambdabot>   Not in scope: `getZonedTime'Not in scope: `formatTime'Not in scope: `defaul...
22:35:21 <frx> if I do t <- getZonedTime. and then formatTime defaultTimeLocale "%H:%M:%S" t it works
22:39:02 <mstksg> i'm in ghci and i have a foo <- bar where the foo is of an ambiguous type.  how do i specify its intended type on the repl?
22:39:33 <mstksg> erm the bar returns IO a, where a is an ambiguous type
22:39:43 <mstksg> normally in a program i'd use it somewhere else and it'd be inferred.
22:41:19 <frx> mstksg foo <- bar :: IO Int
22:42:36 <mstksg> frx: thanks, that did it :) i was trying foo :: Int <- bar and trying everyhting on foo...didn't think about doing things with bar
22:42:50 <frx> welcome :)
22:43:54 <supki> mstksg: you can also do  foo :: Int <- bar  with ScopedTypeVariables enabled
22:44:01 <supki> I guess ghci says that
22:44:58 * hackagebot tasty 0.1.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.1.1 (RomanCheplyaka)
23:04:49 <pcavs1> what's the recommended RPC system for Haskell? C++ has Thrift/Protobufs/CapnProto same for Java. The Haskell implementations I've seen of those don't seem particularly well maintained, but I could be wrong. Any ideas?
23:06:53 <levi> I don't know if any 'efficient' ones, but Aeson is a good library for JSON work.
23:07:38 <pcavs> levi: hmm, that's unfortunate, but that's probably good enough for what I'm trying to do for now
23:08:03 <pcavs> actually, JSON is probably great for this for now, since its human readable
23:08:18 <levi> There are probably other things, I'm just not aware of them.
23:12:16 <amosr> in this expression/binder, what does the tilde mean? "fixV (\ ~(_, exprs') -> …)"
23:12:19 <amosr> as seen here https://github.com/ghc/ghc/blob/master/compiler/vectorise/Vectorise.hs#L226
23:12:55 <levi> A lazy pattern match, I think?
23:13:35 <Saizan> it's called an irrefutable pattern
23:14:03 <Saizan> it gets actually matched only when you force exprs' in this case
23:14:09 <amosr> hmm, thank you
23:14:30 <Zenol> pcavs1: I don't know if it can help you : http://www.haskell.org/haskellwiki/Web/Libraries/RPC_and_Services
23:14:33 <amosr> I'll read the wiki now :-)
23:14:50 <levi> Well, it matches immediately (because it's irrefutable) but it doesn't force evaluation until you use one of the pattern-bound variables later.
23:15:26 <amosr> so it's only really useful for types with one constructor, I take it?
23:16:03 <levi> Yeah.
23:17:23 <amosr> interesting. I hadn't seen that syntax before
23:17:52 <levi> IIRC, at the core of haskell, pattern matching is what actually forces evaluation to occur.
23:17:52 <ezrios> gah
23:18:00 <amosr> is it standard, or a ghc extension?
23:21:42 <levi> It appears to be in the Haskell 98 report, along with as-bindings.
23:23:04 <Zenol> i never though such a thing could exists :o
23:23:24 <amosr> I suppose I'd better read the report!
23:23:38 <ezrios> I gave up by chapter 3
23:24:14 <levi> Standards are not usually meant to be light reading.
23:27:59 <johnw> when you sit down to implement your own compiler, you are then very grateful for the density of standards :)
23:28:18 <johnw> if anything, you always find yourself wishing for more info
23:32:21 <evancz> hey again, anyone around who knows about Data.Binary and serialization?
23:32:27 <johnw> i do
23:32:47 <evancz> awesome! I am having issues on Windows, but not OSX or Linux
23:32:56 <evancz> but I don't even know where to start looking
23:33:11 <evancz> are cross-OS issues known?
23:33:20 <johnw> I don't know anything about Windows or cross-OS issues
23:33:38 <evancz> I do one slightly crazy thing, but it does not seem to be the root cause
23:33:56 <evancz> I serialize a bunch of things to separate files
23:34:15 <evancz> and then I join them all into one file without deserializing and reserializing
23:34:30 <evancz> I just emulate a list and put the "list length" at the front of the file
23:35:04 <evancz> In any case, have you ever had issues with serialization?
23:35:10 <johnw> not as of yet
23:35:15 <evancz> hmm, okay
23:35:19 <Saizan> maybe you're writing the length in an arch-specific way
23:35:49 <evancz> I don't think so
23:35:56 <evancz> one sec, I'll paste some relevant code
23:36:31 <evancz> assuming the list length is wrong, it should either end early (and be fine) or crash at the end of the file
23:36:37 <evancz> I am getting a runtime error
23:36:41 <evancz> which I'll post in a sec
23:37:31 <evancz> https://github.com/evancz/Elm/issues/200
23:38:11 <evancz> so I define a way to serialize Elm types
23:38:26 <evancz> and when I am reading them later, I read a 13
23:38:44 <evancz> So somehow something is getting offset incorrectly
23:39:11 <evancz> But I don't see how to get any clues about where it's going wrong
23:39:21 <evancz> I guess just 'print' everything I can?
23:40:38 <Saizan> are you reading files written on some arch on some other one there?
23:40:53 <evancz> no, files are generated locally
23:41:03 <evancz> i was just thinking through that though
23:41:32 <evancz> yeah, it is all generated during compilation
23:41:44 <Saizan> could be defaulting maybe, can you paste the code for your manual concatenation?
23:42:06 <evancz> yeah, one second
23:42:44 <Fernandos> hi
23:42:46 <evancz> https://github.com/evancz/Elm/blob/master/Setup.hs#L133
23:43:18 <evancz> write length to file, then append contents of a bunch of binary files
23:43:29 <Fernandos> when I have haskell system libraries and run cabal update; cabal install --reinstall --force hs-bibutils pandoc as normal user could that be wrong or cause bugs?
23:43:30 <evancz> http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/src/Data-Binary.html#Binary
23:43:38 <Fernandos> never used haskell, sorry if that's a dumb question.
23:44:02 <Fernandos> just am afraid of running: cabal update && cabal install --reinstall --force hs-bibutils pandoc as root.
23:44:15 <evancz> in the Data.Binary link, ctrl-f for "[a]" to see how lists are serialized
23:44:48 <evancz> Fernandos: I think that could cause issues if you have installed things that depend on the things you are reinstalling
23:44:53 <Saizan> evancz: and how do you decode?
23:44:59 <evancz> Fernandos: not sure if cabal will warn
23:45:48 <evancz> Saizan: https://github.com/evancz/Elm/blob/master/compiler/Metadata/Prelude.hs#L50
23:46:26 <evancz> Fernandos: if you have nothing depending on the libraries, it *should* be okay
23:46:28 <Fernandos> evancz: I wanted to run that command because it was suggested here: http://osdir.com/ml/general/2013-08/msg02502.html
23:46:33 <Fernandos> as a fix for that problem..
23:46:52 <Fernandos> but I didn't use cabal to install those packages, but emerge (gentoo)
23:47:08 <Saizan> evancz: i see, but don't all these files you're concat'ing also each have a length at their start? that would mess with deseralization later
23:47:10 <Ghoul_> ugh, ubuntu 13.04 has the wrong cabal
23:47:17 <NihilistDandy> Oh. Well, that could complicate things, Fernandos
23:47:19 <Saizan> evancz: since you're considering it a single list
23:47:30 <NihilistDandy> Mixing package managers and cabal usually doesn't end up well
23:47:47 <evancz> Saizan: I don't think so
23:47:57 <evancz> the other thing is that it definitely works on OSX
23:48:36 <Saizan> evancz: oh, maybe readFile/appendFile are in text mode
23:48:46 <Fernandos> NihilistDandy: yea, I'm afraid that's true. There is no more recent version of pandoc out there in cabal anyway, but I don't know about hs-bibutils
23:48:46 <evancz> what does that mean?
23:48:50 <evancz> that sounds like it!
23:49:30 <Fernandos> NihilistDandy: cabal list hs-bibutils outputs: Default available version: 5.0 Installed versions: 4.15, 4.17
23:49:33 <evancz> Like, on Windows, it does some non-unicode stuff or something?
23:49:47 <Saizan> evancz: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/System-IO.html#v:openBinaryFile
23:50:00 <Saizan> see the docs there
23:50:11 <evancz> okay, thank you! looking now
23:50:34 <NihilistDandy> Fernandos: I suppose it couldn't hurt to try. If it breaks, you should be able to just install the Haskell Platform and then cabal install pandoc yourself
23:50:47 <Fernandos> NihilistDandy: my system package manager tells me: dev-haskell/hs-bibutils  Installed versions:  4.17 and there is no newer version
23:50:58 <NihilistDandy> Yeah, that'll be the issue, then, probably
23:51:09 <evancz> awesome! That should be it! Thank you Saizan!
23:51:20 <Fernandos> NihilistDandy: hmm I hope cabal isn't as fragile as pip.. I'll try it out
23:51:21 <Saizan> evancz: np :)
23:52:35 <Fernandos> NihilistDandy: should I install hs-bibutils as root or user with cabal?
23:53:23 <NihilistDandy> Fernandos: I don't actually know how emerge sets things up wrt Haskell. What does ghc-pkg list say?
23:53:52 <NihilistDandy> If pandoc is in the global space, maybe just the --global flag will be enough
23:54:00 <NihilistDandy> Though you may need root.
23:54:19 <NihilistDandy> And if it's in the local space, it may be sufficient just to use a bare cabal command
23:54:25 <NihilistDandy> Since it would go to ~/.cabal
23:54:30 <Fernandos> NihilistDandy: output http://hastebin.com/fuyewotoxo.hs
23:54:49 <NihilistDandy> Yeah, so that's global
23:54:49 <Fernandos> pandoc was installed with emerge too
23:55:01 * hackagebot MHask 0.2.0.0 - The category of monads  http://hackage.haskell.org/package/MHask-0.2.0.0 (DanBurton)
23:55:07 <NihilistDandy> Try just using the --global flag on cabal
23:55:24 <Fernandos> so: cabal install --reinstall --global --force hs-bibutils pandoc ?
23:55:25 <NihilistDandy> If it complains about giving root, I guess you should give it
23:55:30 <NihilistDandy> Right, that should do it
23:55:34 <danharaj> don't use —global
23:55:40 <Fernandos> hmm
23:55:59 <NihilistDandy> danharaj: Why not?
23:56:08 <NihilistDandy> Fernandos: Oh, also, what does ghc-pkg check give you? It says you have broken packages
23:56:10 <danharaj> because you don't want cabal mucking up that namespace
