00:06:06 <edwardk> johnw++ # comonad.com mirroring goodness
00:07:22 <lasticot> Hi, does someone have a piece of code that would help me understand how to use MonadRandom?
00:17:29 <Flaeme> Hmm. I wanted to do a tower of hanoi solver thing for fun, but I want to know what disk is moved where, and I can't think how to do it without being able to do something like tower1 = init tower1. Am I missing something obvious maybe? I'm still fairly new to haskell if you couldn't tell
00:18:10 <startling> lasticot: evalRandIO (getRandom :: Rand StdGen Int)
00:20:08 <lasticot> startling: thanks
00:20:26 <startling> lasticot, usually you have some stack of monad transformers in your program. If that's the case, you'd be able to use getRandom anywhere and evaluate the whole thing as a RandT
00:20:54 <lasticot> ok
00:21:29 <lasticot> I gonna try to figure it out
00:52:02 <johnw> edwardk: thanks :)
01:21:49 <haasn> > let step [a,b] = [b,a] in iterate step [1,2] -- I think I need to work on my solver algorithm
01:21:52 <lambdabot>   [[1,2],[2,1],[1,2],[2,1],[1,2],[2,1],[1,2],[2,1],[1,2],[2,1],[1,2],[2,1],[1...
01:42:47 * hackagebot stylish-haskell 0.5.7.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.7.0 (JasperVanDerJeugt)
01:44:17 <startling> people have some funny ideas about what makes haskell code look nice.
01:45:58 <johnw> some are even right :)
01:47:22 <startling> surprisingly few!
01:47:30 <startling> in fact, I know of only one.
01:47:36 <johnw> lol
01:48:23 <Flaeme> startling: I think that actually looks like a useful utility IMO, except for that spacing "fixing" on the imports. That's just me though. >.>
01:48:50 <startling> Flaeme: yeah, I really dislike that style of imports.
01:48:55 <startling> I didn't really read past that.
01:49:04 <johnw> i don't like it either
01:51:27 <startling> One thing I like doing is organizing imports by package (in roughly topological order) with comments with the name of the package above them.
01:51:55 <johnw> i like a big fat sorted list where the first letter of each module name lines up
01:52:08 <johnw> so, close to stylish-haskell, but I don't put whitespace before the explicit function names
01:53:17 <bennofs> I hate that stylish-haskell isn't usable with a few GHC extensions, because parsing fails (ConstraintKinds in particular)
02:07:48 * hackagebot greencard 3.0.4.1 - GreenCard, a foreign function pre-processor for Haskell.  http://hackage.haskell.org/package/greencard-3.0.4.1 (SigbjornFinne)
02:08:46 <ro> hi, how can I type a multiline statement into ghci?
02:09:48 <startling> ro: type :{ and then a newline, then the mutliline thing, then a newline, then }: and another newline.
02:11:04 <ro> ok, let me try, startling
02:11:43 <Flaeme> I think it's actually :} not }: to end
02:12:02 <Flaeme> As in say :t or other GHCi commands.
02:12:17 <Flaeme> ro: Last 2 lines I said there.
02:12:30 <ro> Flaeme, got it
02:13:22 <startling> Flaeme: oh, my mistake.
02:15:12 <ro> I'm trying a multiline statement with guards and it is not working
02:17:14 <startling> ro, paste the session to http://lpaste.net/new/haskell
02:18:09 <hpaste> ro pasted “haskell” at http://lpaste.net/91474
02:22:13 <startling> ro, first of all, you need a "let" for that kind of thing in ghci
02:22:31 <startling> ro, but, yeah, I can't seem to get a multiline-guard to be accepted either. it's odd.
02:23:06 <paolino> hello, I'm trying to put a signature on a Lens (again) , if I write  Functor f => [(Int -> f Int) -> Sequenza -> f Sequenza] no problem, if I write seq_lenses [Lens Sequenza Sequenza Int Int] I get an illegal polymorphic type
02:23:42 <ro> startling, hae you ever got it to work before?
02:23:44 <edwardk> paolino: you generally can't store lenses in a list or a monad. there is a data type 'ReifiedLens' offered by lens that can be stored though
02:23:55 <edwardk> :t Control.Lens.ReifiedLens
02:23:56 <lambdabot>     Not in scope: data constructor `Control.Lens.ReifiedLens'
02:23:56 <lambdabot>     Perhaps you meant one of these:
02:23:56 <lambdabot>       `Control.Lens.ReifyLens' (imported from Control.Lens),
02:24:01 <edwardk> :t Control.Lens.ReifyLens
02:24:02 <lambdabot> Lens s t a b -> ReifiedLens s t a b
02:24:10 <edwardk> :t Control.Lens.reflectLens
02:24:11 <lambdabot> Functor f => ReifiedLens s t a b -> (a -> f b) -> s -> f t
02:24:23 <edwardk> then you can project it back out when you want to use it
02:24:52 <startling> ro, nope. I don't usually define things in ghci; I just test things defined in a module with it.
02:25:03 <edwardk> this is because [(forall f. Functor f => (a -> f b) -> s -> f t)]   would be an impredicative type and ghc will generally not do what you want for them
02:25:39 <paolino> edwardk, ah the signatures are different
02:26:06 <ro> startling, ok, i will try typing this code into a text editor and see if it works that way
02:26:33 <edwardk> paolino: in general [ReifiedLens' Sequenza Int]   -- will be what you want
02:28:08 <edwardk> (there are some other variants on this trick, including the ALens s t a b  type that can be used by some combinators directly and freshened to a full lens with 'cloneLens')
02:28:58 <edwardk> Using [ALens s t a b]  has the benefit that you can just pass it lenses, and they'll 'dumb down' to ALens'es for you without you having to put the newtype on.
02:29:06 <edwardk> and then you can cloneLens to promote them back to lenses
02:29:22 <ro> ok, it works if I import in from a text file, but why do I have to put brackets around the argument when I'm passing a negative value?
02:29:25 <edwardk> :t [_1,_2]
02:29:26 <lambdabot> (Functor f, Field2 s t a b, Field1 s t a b, Indexable Int p) => [p a (f b) -> s -> f t]
02:29:44 <edwardk> :t [_1,_2] :: [ALens' (a,a) a]
02:29:44 <lambdabot> [ALens' (a, a) a]
02:29:55 <edwardk> :t head ([_1,_2] :: [ALens' (a,a) a])
02:29:56 <lambdabot> ALens' (a, a) a
02:30:01 <edwardk> :t cloneLens (head ([_1,_2] :: [ALens' (a,a) a]))
02:30:01 <lambdabot> Functor f => (b -> f b) -> (b, b) -> f (b, b)
02:30:10 <edwardk> :t (1,2)^.cloneLens (head ([_1,_2] :: [ALens' (a,a) a]))
02:30:11 <lambdabot> Num t => t
02:30:15 <edwardk> > (1,2)^.cloneLens (head ([_1,_2] :: [ALens' (a,a) a]))
02:30:18 <lambdabot>   1
02:30:27 <startling> ro, it's a haskell syntax quirk. abs -2 could just as easily be abs - (2).
02:31:54 <paolino> edwardk, thanks, I cannot take this all, I'm still very confued about lenses
02:32:19 <paolino> (_1 %~) is first ?
02:32:38 <edwardk> > ("hello","world") & _1 %~ length
02:32:40 <lambdabot>   (5,"world")
02:32:44 <edwardk> yes
02:32:52 <ro> okay, I just would have thought that the lack of space between the - and the number gives a clue...
02:32:54 <johnw> you call the nu-reification cloning?
02:32:58 <johnw> un
02:33:30 <edwardk> johnw: there is ReifyLens/reflectLens and cloneLens. the former makes up a full data type with four arguments, etc. the latter just uses
02:33:32 <edwardk> :t cloneLens
02:33:33 <lambdabot> Functor f => ALens s t a b -> (a -> f b) -> s -> f t
02:33:40 <johnw> ah, ok
02:33:52 <edwardk> ALens s t a b uses Context
02:34:01 <paolino> > [1,2] & (_1 %~ negate)
02:34:02 <lambdabot>   No instance for (Control.Lens.Tuple.Field1 [t0] a0 a1 a1)
02:34:03 <lambdabot>    arising from a...
02:34:35 <edwardk> _1 works on tuples, not lists, you can use 'ix' or one of the other indexing combinators to adjust an element
02:34:45 <hpaste> lasticot pasted “main.hs” at http://lpaste.net/91475
02:34:46 <edwardk> > [1,2} & ix 0 %~ negate
02:34:47 <lambdabot>   <hint>:1:5: parse error on input `}'
02:34:48 <lasticot> looking at this code do you see any major way of improving it? The github directory to see the rest of the files https://github.com/Daiwen/HaskellTraining/tree/master/dailyprogrammer/easy/130.
02:34:53 <edwardk> > [1,2] & ix 0 %~ negate
02:34:55 <lambdabot>   [-1,2]
02:35:08 <edwardk> > [1,2] & ix 1 %~ negate
02:35:10 <lambdabot>   [1,-2]
02:35:13 <edwardk> > [1,2] & ix 2 %~ negate
02:35:14 <lambdabot>   [1,2]
02:35:22 <johnw> i like that behavior
02:35:34 <startling> > view (ix 2) [1, 2]
02:35:35 <lambdabot>   No instance for (Data.Monoid.Monoid a0)
02:35:36 <lambdabot>    arising from a use of `e_1212'
02:35:36 <lambdabot>  ...
02:35:46 <paolino> ix is for IntMap also ?
02:35:51 <startling> :t ix
02:36:03 <edwardk> startling: 'ix' is a traversal, so if you go to use view it demands a monoid. you can use ^? to get out Maybe the result
02:36:10 <johnw> > IntMap.fromList [(1,2),(3,4)]
02:36:11 <lambdabot>   Not in scope: `IntMap.fromList'
02:36:11 <lambdabot>  Perhaps you meant `IM.fromList' (imported ...
02:36:14 <edwardk> > [1,2]^?ix 2
02:36:15 <lambdabot>   Nothing
02:36:15 <johnw> > IM.fromList [(1,2),(3,4)]
02:36:17 <lambdabot>   fromList [(1,2),(3,4)]
02:36:17 <edwardk> > [1,2]^?ix 0
02:36:18 <lambdabot>   Just 1
02:36:21 <johnw> > IM.fromList [(1,2),(3,4)] & ix 1
02:36:22 <lambdabot>   Couldn't match type `p0 (Control.Lens.At.IxValue m0)'
02:36:23 <lambdabot>                with `...
02:36:24 <johnw> > IM.fromList [(1,2),(3,4)] ^. ix 1
02:36:25 <startling> edwardk: yeah. I was just wondering if it made any unfortunate assumptions.
02:36:25 <lambdabot>   No instance for (Data.Monoid.Monoid a0)
02:36:25 <lambdabot>    arising from a use of `e_112341'...
02:36:27 <johnw> > IM.fromList [(1,2),(3,4)] ^. at 1
02:36:27 <edwardk> paolino: yes
02:36:29 <lambdabot>   Just 2
02:36:43 <edwardk> paolino: you may need to use 'at' if you want to put something in that wasn't there to begin with
02:36:54 <edwardk> 'ix' will let you 'edit something if its present'
02:37:05 <edwardk> 'at' will let you 'change if something is present or not'
02:37:50 <edwardk> that way ix can try to index into arrays, lists, etc. and also into maps, etc.    but at can be used for maps, where you can add/remove single elements without affecting other elements
02:38:18 <paolino> > [] $ at 1 .~ 1
02:38:19 <lambdabot>   Couldn't match expected type `(t1 -> t1) -> t0'
02:38:19 <lambdabot>              with actual ty...
02:38:27 <johnw> &, not $
02:38:34 <paolino> > [] & at 1 .~ 1
02:38:36 <lambdabot>   No instance for (Control.Lens.At.At [a0])
02:38:36 <lambdabot>    arising from a use of `e_111'
02:38:36 <lambdabot> ...
02:38:36 <edwardk> at doesn't make sense for lists because i can't add the 30th element to a 1 element list
02:38:42 <johnw> and you just to set Just 1
02:38:47 <johnw> > [] & at 1 .~ Just 1
02:38:48 <lambdabot>   No instance for (Control.Lens.At.At [a0])
02:38:48 <lambdabot>    arising from a use of `e_111'
02:38:48 <lambdabot> ...
02:38:55 <johnw> hmm
02:38:56 <edwardk> johnw: no instance
02:38:59 <edwardk> it can't be
02:39:09 <edwardk> how do you set the 30th entry in an empty list?
02:39:14 <johnw> haha, true!
02:39:21 <johnw> > [1..4] & at 1 .~ Just 1
02:39:22 <lambdabot>   No instance for (Control.Lens.At.At [t0])
02:39:22 <lambdabot>    arising from a use of `e_11411...
02:39:31 <edwardk> that is why [] is an instance of Ix, but not At
02:39:37 <johnw> makes sense
02:39:40 <supki> > [] & wrapping M.fromList . at 1 ?~ 1
02:39:42 <lambdabot>   [(1,1)]
02:40:05 <edwardk> supki: heh
02:40:47 <johnw> ah, hadn't seen wrapping before
02:42:51 <lasticot> why does lambda-paste tells me there is an error line 14 when the file is compiling and working? http://lpaste.net/91475
02:43:07 <mauke> because you should use mapM
02:44:28 <lasticot> mauke: ok but I don't see how :-(
02:44:39 <mauke> uh. it tells you?
02:44:52 <mauke> like, it literally has the code it thinks you should use
02:44:58 <lasticot> oh! I didn't know that!
02:46:08 <lasticot> thank you
02:51:45 <hpaste> lasticot revised “main.hs”: “main.hs” at http://lpaste.net/91475
02:53:05 <Ghoul_> hlint suggestions are much smarter than I thought  they were
02:53:12 <Ghoul_> Thats a full expression reduction right there..
02:55:58 <lasticot> Do you know if the program generating the suggestions can be interfaced with emacs
02:57:27 <hpaste> lasticot revised “main.hs”: “main.hs” at http://lpaste.net/91475
02:59:54 <mauke> you could just do 'case readNDM a of ...'
03:03:47 <hpaste> lasticot revised “main.hs”: “case readNDM a of ..” at http://lpaste.net/91475
03:05:31 <donri> lasticot: hlint doesn't do the rewrite for you (in part to let you learn) but there's probably a way to have the suggestions shown on the relevant lines in emacs
03:06:26 <lasticot> donri: ok I may look into that at some point
03:06:57 <donri> lasticot: such as ghc-mod + flymake http://www.mew.org/~kazu/proj/ghc-mod/en/
03:08:17 <lasticot> donri: thank you
03:18:04 <mstksg> what can I do if a function requires an argument after the a do block? parentheses the entire do block?
03:18:08 <mstksg> for example, runState (do { ... }) s
03:18:34 <mstksg> and the do block is multi-line, of course
03:19:29 <Reite> use let or where
03:19:58 <Reite> runState x s where x = do...
03:21:53 <mstksg> Reite: ah that makes sense. i do remember seeing that idiom often too.
03:22:43 <mstksg> what if i'm using it inside another do block/monad?  r <- runState x s, for example.  should i put the state block before-hand in a let?
03:24:38 <Reite> It depends :)
03:24:56 <Reite> you should do what is most easy to understand
03:26:00 <mstksg> i guess i just need to "get used" to things.  runState (do { ... }) is easiest for me to connect the dots but it might just be my imperative background
03:26:49 <Reite> I think its a bad idea to have arguments over multiple lines
03:27:15 <Reite> If you can keep it to one line, then sure
03:27:18 <FreeFull> Reite: I see it pretty often with do blocks
03:27:41 <FreeFull> mstksg: Often what is done is    flip runstate s $ do ...
03:28:04 <Reite> yeah
03:28:06 <FreeFull> Where the ... can start on a new line as long as it's indented
03:28:07 <Reite> thats fine imo
03:28:18 <Reite> but you dont wanna have additional arguments further down
03:29:08 <mstksg> FreeFull: flip just feels weird to me for some reason i can't place. am i alone in this?
03:29:09 <FreeFull> Reite: Yeah, but it'd be fine for runState
03:30:29 <levi> mstksg: You just haven't written enough Forth
03:31:31 <FreeFull> levi: Then it'd be swap though =P
03:33:02 <MouseTheLuckyDog> is there a built in function isOdd? if not is it a part of a module--which module?
03:34:18 <mstksg> maybe it feels like it's breaking how you are used to seeing the function work...it throws away your intuition, kind of, and you have to pause and take time to manually process things instead of just easily reading through?
03:34:37 <adnap> > odd 3
03:34:38 <lambdabot>   True
03:34:50 <adnap> MouseTheLuckyDog: "odd" in Prelude
03:34:55 <donri> @src odd
03:34:55 <lambdabot> odd = not . even
03:35:00 <donri> @src even
03:35:00 <lambdabot> even n = n `rem` 2 == 0
03:35:52 <simukis_> i wonder if `not . even` is any more optimal than `n `rem` 2 == 1`…
03:36:37 <nicoo> simukis_: Can rem return negative values, sometimes ?
03:36:51 <adnap> > -5 `rem` 2
03:36:52 <lambdabot>   -1
03:37:17 <simukis_> oh
03:37:27 <simukis_> @src (\=)
03:37:27 <lambdabot> Source not found. You type like i drive.
03:37:41 <nicoo> And I expect GHC to inline the definition of even in odd, and optimize to "n `rem` 2 \= 0" anyways
03:38:10 <taylorgb> @src (/=)
03:38:10 <lambdabot> x /= y = not (x == y)
03:41:25 <lemao> why this works: newtype UserId = UserId String deriving (Show); instance EntityId UserId, but this doesnt newtype UserId = UserId String deriving (Show, EntityId)
03:42:34 <bennofs> lemao: Because instance EntityId declares an instance where all functions use their default definition
03:43:15 <bennofs> lemao: deriving EntityId tries to derive an instance, which is not supported for user-defined classes without extensions
03:43:58 <lemao> bennofs: I have GeneralizedNewtypeDeriving and StandaloneDeriving set
03:44:18 <lemao> bennofs: and the class has no functions/methods
03:44:35 <bennofs> lemao: is String an instance of the class?
03:47:01 <lemao> bennofs: it's not. In this case, having to create an instance for my newtype and another for the underlying type seems like a unneeded boiler plate.
03:47:38 <lemao> bennofs: since the deriving is trivial and could be automatic. I think this was my wrong assumption
03:48:01 <bennofs> lemao: You need to create an instance for the underlying type. Then you can derive an instance for your GeneralizedNewtypeDeriving
03:49:09 <lemao> bennofs: humm, I am only interested in tagging my newtype with EntityId so I could even be class EntityId where (without a type parameter)
03:49:21 <lemao> bennofs: that doesnt seem allowed
03:50:46 <adnap> Is there a fuction like "if :: Bool -> a -> a -> a"?
03:51:13 <lemao> bennofs: let me step back and state what I am after here: maybe there is a better alternative.
03:51:18 <adnap> if b x y = if b then x else y
03:51:32 <bennofs> @hoogle Bool -> a -> a -> a
03:51:32 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
03:51:33 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex3 :: a -> a -> a -> Vertex3 a
03:51:33 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector3 :: a -> a -> a -> Vector3 a
03:51:49 <bennofs> adnap: Not in base afaik.
03:52:00 <adnap> @let if b x y = if b then x else y
03:52:00 <lambdabot>  Parse failed: Parse error: =
03:52:52 <adnap> @let if = \b x y -> if b then x else y
03:52:52 <lambdabot>  Parse failed: Parse error: =
03:53:34 <FreeFull> adnap: You have to call it something else
03:53:41 <adnap> lol
03:53:44 <adnap> Oh, of course
03:53:50 <bennofs> @let if' b = ((when . return) .) . fromMaybe
03:53:50 <lambdabot>  .L.hs:142:18:
03:53:51 <lambdabot>      Couldn't match type `m1 b0' with `Bool'
03:53:51 <lambdabot>      Expected typ...
03:53:52 <FreeFull> Most commonly it's called if'
03:54:02 <adnap> @let if' b x y = if b then x else y
03:54:03 <lambdabot>  Defined.
03:54:06 <bennofs> @let if'crazy b = ((when b . return) .) . fromMaybe
03:54:07 <lambdabot>  Defined.
03:54:16 <adnap> > if (odd 3) 42 4
03:54:16 <bennofs> > if'crazy True 1 2
03:54:17 <lambdabot>   <hint>:1:16:
03:54:17 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
03:54:17 <lambdabot>   can't find file: L.hs
03:54:25 <adnap> > if' (odd 3) 42 4
03:54:29 <lambdabot>   mueval-core: Time limit exceeded
03:54:33 <bennofs> > if'crazy True 1 2
03:54:33 <lambdabot>   Could not deduce (GHC.Num.Num (Data.Maybe.Maybe ()))
03:54:34 <lambdabot>    arising from the li...
03:54:37 <bennofs> lol
03:54:41 <adnap> @let if' b x y = if b then x else y
03:54:41 <lambdabot>  .L.hs:142:1: Warning:
03:54:41 <lambdabot>      Pattern match(es) are overlapped
03:54:41 <lambdabot>      In an equat...
03:54:57 <bennofs> > if' True 3 4
03:54:57 <adnap> What the hell
03:55:00 <lambdabot>   3
03:55:06 <bennofs> > if' False 3 4
03:55:09 <lambdabot>   4
03:55:22 <adnap> Can one do...
03:55:23 <bennofs> > foldl f [a,b,c]
03:55:25 <lambdabot>   Could not deduce (Debug.SimpleReflect.Expr.FromExpr
03:55:25 <lambdabot>                      [D...
03:55:29 <adnap> > 3 `if True` 4
03:55:31 <lambdabot>   <hint>:1:4: parse error on input `if'
03:55:35 <bennofs> > foldl1 f [a,b,c]
03:55:36 <lambdabot>   f (f a b) c
03:55:36 <adnap> > 3 `if' True` 4
03:55:37 <lambdabot>   <hint>:1:8: parse error on input `True'
03:55:48 <bennofs> adnap: No, that's not possible unfortunaly
04:25:45 <emfa> anyone care to share a rise-up invite?
04:39:01 <Ghoul_> anyone know AES encryption for buffers from a Ptr ?
04:39:18 <Ghoul_> *if such a package exists
04:44:22 <aristid> AES in itself does not constitute encryption :P but there are crypto packages on hackage
04:54:28 <katla> can you help me with monoid in the category of endofunctors
04:54:56 <nicoo> > monads, you mean ?
04:54:57 <lambdabot>   <hint>:1:7: parse error on input `,'
04:55:03 <nicoo> Oops
04:55:12 <nicoo> @quote endofunctors
04:55:12 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
04:55:16 <nicoo> @quote endofunctors
04:55:16 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
04:55:18 <katla> to me monoid is:  object M, with maps id : M -> M and * : MxM -> M
04:55:31 <katla> but if M is an endofunctor, this isn't a monad
04:55:41 <katla> so what do yo mean Wadler
04:56:04 <nicoo> katla: A monoid need to contain a neutral element (wrt *) also
04:56:50 <katla> yes the monoid laws: id*x = x, x*id = x, (x*y)*z = x*(y*z)
04:57:22 <katla> how do you get the usual monad from this description?
05:01:07 <katla> please
05:02:51 * hackagebot processing 1.0.0.0 - Web graphic applications with Processing.  http://hackage.haskell.org/package/processing-1.0.0.0 (DanielDiaz)
05:06:55 <qwerty1793> hi, my haskell program compiles fine but when I try and profile it, and so compile it with the -prof option, I get "Could not find module `Data.ByteString.Char8'". What is causing this?
05:08:31 <mux> qwerty1793: you didn't install the bytestring package with profiling enabled
05:10:48 <qwerty1793> mux: got it, thanks
05:16:15 <Entroacc1ptor> katla: http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem
05:23:13 <Ghoul_> aristid: well, you get what I mean :\
05:23:18 <Ghoul_> I was actually disappointed
05:23:39 <Ghoul_> I looked on hackage and the packages that claimed to have pure haskell implementations of crypto  tended to use C libraries for the AES stuff
05:24:05 <Ghoul_> we can do better than that guys! we have llvm and vector primops now :\
05:27:36 <luite> Ghoul_: but no primops for the aes-ni instructions
05:28:13 <Ghoul_> While having those instructions are cool, I'm naive about that because it won't build on windows through mingw
05:30:49 <aristid> Ghoul_: https://github.com/vincenthz/hs-cipher-aes
05:31:00 <aristid> oh wait nevermind
05:31:02 <aristid> i misread.
05:31:32 <Ghoul_> Yeah, the cryptocipher claims a pure haskell implementation
05:31:43 <Ghoul_> and then links to that, which turns out to be a /pure haskell interface/ implementation
05:32:14 <aristid> it's going to be terrifically slow and vulnerable to timing attacks i guess, but then your homebrew crypto will likely have worse problems :P
05:41:35 <sipa> Ghoul_: where do you read that it's a pure haskell implementation?
05:42:13 <Ghoul_> "A growing collection of pure haskell implementation of ciphers (AES, Camellia, RC4)" on the haskell wiki
05:42:25 <Ghoul_> below the link to CryptoCipher
05:43:31 <sipa> ah
05:52:15 <bennofs> Shoud 3 `mod` 0 be efined?
05:52:19 <bennofs> defined*
05:53:02 <bennofs> Hmm, probably not
06:01:36 <nicoo> bennofs: Dividing by 0 isn't defined, but taking mod 0 definitely is : Z/0Z = Z/{0} ~ Z
06:01:44 <nicoo> So n mod 0 should be n
06:02:01 <nicoo> > 3 `mod` 0
06:02:02 <lambdabot>   *Exception: divide by zero
06:02:05 <nicoo> :(
06:07:53 <bennofs> Do you /url 1
06:09:08 <nicoo> bennofs: ?
06:09:22 <bennofs> Ups, I typed something blindly
06:09:28 <bennofs> Ignore that
06:09:36 <nicoo> 'k
06:20:59 <exicer> Could anyone recommend a guide on reading/writing files, for a relative beginner?
06:21:10 <exicer> Or perhaps just point me at some functions
06:23:55 <bennofs> http://learnyouahaskell.com/input-and-output#files-and-streams  This talks about IO in general, but also convers basic File IO
06:24:28 <exicer> bennofs: Awesome, thanks very much
06:26:56 <CapitanK> Goodmorning haskellers and hecklers
06:28:28 <CapitanK> Has anyone ordered LYAH book from Germany?  From any alternative other than our evil monopolizer Amazon?
06:28:49 <mumble-p2p> hi
06:35:21 <shanse> CapitanK: maybe contact one of the non amazon sellers and see if they're willing to sell it without amazon as a middleman
06:41:44 <CapitanK> shane: that is so depressing, Amazon has infected every avenue of cyber existance :<
06:42:27 <CapitanK> I doubt you can get a new book without them...gotta try ebay.
06:44:06 <k00mi> CapitanK: do you want the dead tree version?
06:44:14 <startling> CapitanK, no starch won't ship to germany?
06:48:41 <CapitanK> k00mi: yes the dead tree version :)
06:49:58 <k00mi> CapitanK: you can just go to a local bookstore, tell them the ISBN and they'll have it in a few days
06:50:56 <CapitanK> Ya, my girl was just suggesting that...good idea.
06:52:06 <k00mi> it'll most likely be cheaper than paying shipping fees and customs
06:55:26 <manky> hey all :)
06:55:44 <typoclass> manky: hi
06:56:36 * CapitanK is not gay, but thinks living with a man would be much easier.
07:40:03 <hvr> edwardk: what's the reason for the current ordering of (<%~)'s result pair? (I'm just wondering, as it requires swapping to be usable for atomicModifyIORef)
07:41:57 <FreeFull> :t (<%~)
07:41:57 <lambdabot> Profunctor p => Overloading p q ((,) b) s t a b -> p a b -> q s (b, t)
07:43:44 <hvr> FreeFull: here's a more readable specialization:
07:43:46 <hvr> FreeFull:   (<%~) ::             Lens s t a b      -> (a -> b) -> s -> (b, t)
07:44:23 <hvr> :t  atomicModifyIORef
07:44:24 <lambdabot> Not in scope: `atomicModifyIORef'
07:44:48 <hvr>  atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
07:48:17 <FreeFull> > _1 <%~ id $ (3,4)
07:48:19 <lambdabot>   (3,(3,4))
07:48:52 <FreeFull> hvr: That specialisation is a LOT more readable
07:49:58 <exicer> Is there an easy way to partition (may be the wrong word..) a list by element index? Eg, I want to split a list into two lists based on their index being even or odd ?
07:50:48 <exicer> My guess was to zip [1..] with the list, and then check if the value was odd or something
07:50:56 <exicer> but that seems like a bad way to do it
07:51:07 <FreeFull> > _1 <%~ (subtract 3) $ (3,4)
07:51:08 <lambdabot>   (0,(0,4))
07:53:33 <geekosaur> exicer: that is in fact how you do it. lists are not arrays; they don't really have the concept of offsets
07:53:45 <FreeFull> exicer: You could also do it recursively
07:54:48 <exicer> geekosaur: FreeFull Okay, thanks. I just wanted to make sure there wasn't a simpler way :)
07:58:31 <Modius> Any profound thoughts on conduits vs iteratees?
07:59:14 <aristid> Modius: i think pretty much nobody likes iteratees anymore
07:59:42 <typoclass> Modius: i think the larger discussion these days is conduits vs. pipes
08:02:10 <typoclass> > partitionEithers $ zipWith ($) (cycle [Left, Right]) [1..10] -- exicer: how about this? though i'm not sure if this counts as 'simple'
08:02:11 <lambdabot>   ([1,3,5,7,9],[2,4,6,8,10])
08:03:17 <mm_freak> i like iteratees
08:03:31 <exicer> typoclass: Hm, that looks good. Let me just work out how it actually works :p
08:04:16 <typoclass> exicer: sure :) feel free to ask questions. there's an intermediate list in there that looks like [Left 1, Right 2, Left 3, Right 4...]
08:04:19 <aristid> mm_freak: why?:)
08:05:39 <mm_freak> aristid: simple, sound concept
08:05:40 <exicer> Ah I have not come accross partitionEithers before (which is not surprising given the ammount of haskell I have done :p)
08:05:49 <aristid> mm_freak: and a PITA to use :P
08:06:09 <typoclass> exicer: it's from Data.Either. it's all pretty straightforward
08:06:11 <mm_freak> aristid: not at all…  they are very easy to use once you understood them
08:06:19 <aristid> mm_freak: maybe i'm just too stupid to deal with enumerators
08:06:38 <exicer> Yeah, no I see how it works. Looks good, thanks!
08:06:40 <jj515> For those of you familiar with FGL, how is the 'match' function implemented?
08:06:55 <mm_freak> aristid: they are really just fancy unfoldr+foldl
08:06:56 <jj515> I believe it is runs in constant time, though I don't see how
08:08:23 <jj515> It seems like it would have to take at least linear time to transform the graph into the proper form, so that the node to be matched is the last one added
08:08:30 <mm_freak> in fact iteratees and Wire are almost equivalent with the difference that wires never stop
08:08:59 <aristid> mm_freak: compare https://github.com/Gabriel439/Haskell-Pipes-Library/blob/master/src/Pipes.hs#L351 (each function)
08:09:03 <aristid> and the iteratee equivalent
08:09:08 <aristid> http://hackage.haskell.org/packages/archive/iteratee/0.8.9.4/doc/html/src/Data-Iteratee-Iteratee.html#enumList
08:09:19 <typoclass> mm_freak: you mean the netwire package?
08:10:35 <aristid> mm_freak: if you really want to write a producer iteratee style i find you have to bend over yourself backwards.
08:11:01 <aristid> mm_freak: or is the code i linked worse than it should be?
08:12:11 <exicer> typoclass: Could you explain what the type signature of that function would be? I would have thought it was something like [a] -> ([a], [a])
08:12:15 <exicer> but it isn't
08:12:40 <b2coutts> :t partitionEithers
08:12:41 <lambdabot> [Either a b] -> ([a], [b])
08:13:01 <b2coutts> exicer: well, it necessarily needs to take a list of Eithers of course
08:13:07 <b2coutts> oh wait, I see
08:13:17 <b2coutts> partitionEithers by itself isn't the solution to your problem
08:13:17 <FreeFull> I think that way is an abuse of Either anyway
08:13:25 <typoclass> exicer: the entire function has this signature, if that's what you're asking
08:13:26 <typoclass> @type (partitionEithers . zipWith ($) (cycle [Left, Right]))
08:13:27 <lambdabot> [b] -> ([b], [b])
08:13:50 <exicer> wait, that is what I thought it was..
08:13:57 <exicer> okay I am probably doing something stupid then
08:14:04 <FreeFull> I'd make a new function  (a -> Bool) -> [a] -> ([a],[a])
08:14:13 <b2coutts> the rest of the code he typed converts a list into a list of Eithers, where odd things are Left and even things are Right
08:14:27 <b2coutts> such that it can be fed into partitionEithers
08:14:31 <FreeFull> Actually
08:14:33 <Modius> Do both Pipes and Conduits have source and sink exceptions covered now?
08:14:36 <typoclass> FreeFull: he wants the indices, so it'd have to be (Int -> Bool) -> [a] -> ...
08:14:48 <FreeFull> typoclass: Yeah, you're right
08:14:53 <aristid> Modius: well there's the pipes-safe module
08:15:13 <FreeFull> typoclass: Although I'd go with integer over int
08:15:33 <FreeFull> Although you're unlikely to process lists larger than maxBound :: Int
08:15:35 <Zenol> @pl  \f x -> concat $ (fmap . fmap) f x
08:15:38 <lambdabot> ((concat $) .) . fmap . fmap
08:15:38 <lambdabot> optimization suspended, use @pl-resume to continue.
08:16:03 <exicer> I think you may have lost me with (Int -> Bool). Where does that come in ?
08:16:21 <FreeFull> exicer: Int would be the index
08:16:30 <exicer> Ohh, right right
08:16:53 <FreeFull> Depending on if you get true or false, it'd go in one of the two lists
08:17:43 <b2coutts> @hoogle (a -> Bool) -> [a] -> ([a],[a])
08:17:43 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
08:17:43 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
08:17:43 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
08:17:53 <b2coutts> break even [1..10]
08:17:58 <b2coutts> > break even [1..10]
08:17:59 <lambdabot>   ([1],[2,3,4,5,6,7,8,9,10])
08:18:11 <b2coutts> > span even [1..10]
08:18:12 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10])
08:18:14 <b2coutts> :(
08:18:24 <typoclass> exicer: it's part of another approach to solving your problem. i don't think there's a function (Int -> Bool) -> [a] -> ([a], [a]) in the standard library, but if there was, you could use it to solve your thing. (but that function is not hard to write i suppose)
08:18:56 <exicer> typoclass: Okay. Well I will continue to play around. Thanks very much!
08:19:39 <typoclass> b2coutts: how about 'filter'? you'd still have to 'zip [0..]' before you filter of course
08:20:15 <typoclass> b2coutts: oh, or partition
08:21:53 <b2coutts> typoclass: good idea
08:22:01 <typoclass> > let (a,b) = partition (even . fst) $ zip [1..10] "lolcats" in (map snd a, map snd b) -- a second solution, as b2coutts suggested
08:22:02 <lambdabot>   ("oct","llas")
08:24:35 <typoclass> ... well, obviously [0..] instead of [1..10] :-)
08:24:47 <exicer> Hehe
08:24:58 <exicer> That is more along the lines of what I was thinking of doing initially
08:25:04 <exicer> although much shorter :p
08:36:29 <arnsholt> What's the best way to track down where exactly an undefined array access takes place?
08:37:05 <typoclass> @where stacktrace
08:37:05 <lambdabot> compile with -prof -fprof-auto -rtsopts and run with +RTS -xc
08:37:12 <typoclass> arnsholt: start with this maybe? ^^
08:39:19 <arnsholt> Stacktrace sounds useful, yeah. Cheers!
09:10:59 <exicer> What stupid thing am I doing here: http://lpaste.net/91487 ?
09:13:10 <Nisstyre> exicer: did you get an error about an infinite type or something? It looks like you want a tree not a list...
09:13:44 <Saizan> or you want to change it to pairsList (x:xs, y:ys) = [[x,y], pairsList (xs, ys)]
09:14:08 <Saizan> pairsList (x:xs, y:ys) = x : y : pairsList (xs, ys)] -- sorry
09:14:15 <Saizan> s/]//
09:14:24 <Nisstyre> Saizan: I think that might be what they want
09:14:39 <forwardbackslash> Hello.
09:15:40 <guest6543> Hi, uh, new to this and I'm just trying to figure out if this is where I type. :)
09:16:00 <typoclass> forwardbackslash: hello
09:16:08 <typoclass> guest6543: yes it is :-P
09:16:21 <exicer> Saizan: Ah, yes I was getting the infinite type
09:16:42 <guest6543> Yay!
09:16:45 <exicer> Saizan: I actually don't even see why it would be an infinite type - doesn't it have a terminating condition ?
09:16:49 <typoclass> exicer: how about [x,y] : pairsList xs ys ? you could then do transpose at the end
09:17:06 <typoclass> > transpose [[1,2], [3,4], [5,6]]
09:17:08 <lambdabot>   [[1,3,5],[2,4,6]]
09:17:24 <exicer> I was trying to go from ([1,2], [3,4]) to [[1,3], [2,4]]
09:17:46 <typoclass> exicer: it's because pairsList gives a list, which you're putting inside a list
09:17:49 <Saizan> oh, then my solution doesn't work
09:18:26 <exicer> typoclass: Okay - but as that list is getting shorter, why does it count as infinite?
09:18:28 <Saizan> exicer: infinite type doesn't mean your function wouldn't terminate, it means you'd need type-level direct recursion to make it typecheck
09:18:35 <exicer> Ohhh
09:18:46 <exicer> OKay
09:18:57 <exicer> It was wrong anyway, but I wasn't sure what that error meant :p
09:19:55 <hpaste> Saizan annotated “infinite type” with “infinite type (annotation)” at http://lpaste.net/91487#a91489
09:20:08 <Saizan> exicer: that annotation does what you want
09:20:21 <selene23> come join me on live cam here: http://chinadating.tk/us/profiles/girl/selene23
09:21:23 <typoclass> exicer: the type checker doesn't know about list lengths. [Int] could be length 0, could be infinity. so pairsList may put a list inside a list inside etc which may go on for 10x or 50x or 3x, but *potentially* it infinite and that's what counts
09:21:29 <Saizan> > let pairsList ([],[]) = []; pairsList (x:xs, y:ys) = [x,y] : pairsList (xs,ys) in pairsList ([1,2], [3,4])
09:21:31 <lambdabot>   [[1,3],[2,4]]
09:22:28 <Saizan> exicer: though, usually, we wouldn't use a list to represent something we know has two elements, unless we want to feed it to a general list combinator
09:22:42 <exicer> Saizan: Ah, yes that is waht I was trying to do.
09:23:22 <Saizan> > uncurry zip ([1,2], [3,4])
09:23:23 <lambdabot>   [(1,3),(2,4)]
09:23:23 <exicer> typoclass: Okay that makes sense
09:23:53 <typoclass> > let pairsList ([],[]) = []; pairsList (x:xs, y:ys) = [x,y] : pairsList (xs,ys) in pairsList ([1,2], [3]) -- there's a little bit of a problem however
09:23:54 <lambdabot>   [[1,3]*Exception: <interactive>:3:5-78: Non-exhaustive patterns in function...
09:25:24 <exicer> Hm, well I suppose you could just trim the longer list to be the length of the shorter
09:25:29 <exicer> and throw away any of the other bits
09:26:19 <Saizan> typoclass: the list length wouldn't matter anyway for typing this, if anything the depth
09:27:17 <nooodl> as Saizan demonstrated [(Int, Int)] probably makes more sense than [[Int]]
09:30:26 <tomboy64> > 22/7
09:30:27 <lambdabot>   3.142857142857143
09:39:16 <b2coutts> is it just me or is cabal bad at resolving dependencies on its own?
09:40:22 <crdueck> Is this Monad already implemented somewhere? newtype Foo a r = Foo (a -> (r, Foo a r)). Its a continuation monad that can return a result at each step of the continuation.
09:42:15 <dcoutts_> crdueck: that can? isn't it that is must?
09:42:30 <dcoutts_> is/it
09:42:38 <crdueck> dcoutts_: you're right, it must return a result at each step.
09:42:43 <dcoutts_> which is too much
09:42:49 <dcoutts_> return ?
09:43:05 <crdueck> s/return/produce/
09:43:33 <dcoutts_> crdueck: that's why people often use lists, you can return results whenever
09:43:56 <anon125> whats the best way to transform an [IO Int] to IO [Int] ?
09:44:02 <crdueck> anon125: sequence
09:44:12 <dcoutts_> :t sequence
09:44:13 <lambdabot> Monad m => [m a] -> m [a]
09:44:19 <anon125> wow aweseome
09:44:20 <anon125> thanks
09:44:43 <Nisstyre> anon125: I recommend setting up ghci to handle hoogle
09:45:07 <anon125> I didnt know it could
09:45:24 <anon125> I'll definitely look into it
09:46:01 <Nisstyre> anon125: if I do ":hoogle [IO Int] -> IO [Int]" the first result is Control.Monad.sequence
09:46:23 <typoclass> anon125: you can use hoogle through the website, through lambdabot, and from the command line. from inside ghci you can run command-line stuff
09:46:28 <typoclass> Nisstyre: you mean :!hoogle?
09:46:32 <crdueck> dcoutts_: why do you say a result at each step is too much? The continuation might not be able to produce a result at every step in general? I could have (a -> (Maybe r, Foo a r)) instead
09:46:39 <Nisstyre> typoclass: it's set to :hoogle here
09:46:54 <dcoutts_> crdueck: yes, for example return.
09:47:05 <typoclass> Nisstyre: oh so it's a feature in newer ghci versions?
09:47:17 <Nisstyre> typoclass: maybe, I actually forget exactly how I set that up...
09:47:23 <Nisstyre> typoclass: I am on 7.6 though
09:47:29 <crdueck> return r = Proc (const (r, return r))
09:49:04 <crdueck> dcoutts_: s/Proc/Foo, doesnt that work?
09:49:05 <Nisstyre> typoclass: in my ghci.conf file I have ":def hoogle \str -> return $ ":! hoogle --count=15 \"" ++ str ++ "\""
09:49:18 <typoclass> Nisstyre: ooh, nice
09:49:53 <dcoutts_> crdueck: but that has type Foo a a
09:50:11 <b2coutts> I want to build a roguelike in haskell; what kind of library should I use in haskell that's similar to ncurses?
09:50:25 <dcoutts_> crdueck: not general enough for return
09:55:05 <crdueck> dcoutts_: I dont think thats right, it has type Foo a r. The const ignores the a argument, so its completely general.
09:55:18 <typoclass> b2coutts: not sure, but there's got to be 1-2 haskell bindings to ncurses. and there's the vty package, and another thing which i currently forgot the name of :-/
09:55:20 <crdueck> @define newtype Foo a r = Foo (a -> (r, Foo a r))
09:55:21 <lambdabot>  Defined.
09:55:39 <crdueck> :t returnFoo r = Foo $ const (r, return r)
09:55:39 <lambdabot> parse error on input `='
09:55:58 <crdueck> :t \r -> Foo $ const (r, return r)
09:55:58 <lambdabot> Monad (Foo a) => r -> Foo a r
09:56:39 <b2coutts> typoclass: vty looks like exactly what I need, thanks
09:57:56 <dcoutts_> crdueck: yes, you're quite right
09:58:37 <lesur> Hi, I'm rather new to Haskell. So far I love it, and I'm pretty sure I understand it. However there is one question that keeps coming back to me: how should I deal with changing the state of my program? Should I just have a ProgramState data type that I pass through the program and modify it along the way? Thanks.
10:00:08 <monochrom> that is one option. there are many, many options
10:00:16 <typoclass> lesur: hello, yes, that's one of the standard solutions. if you get tired of passing around that parameter, there's one or two plausible alternatives
10:00:46 <lesur> What else? This problem has stumped me. :(
10:01:15 <dcoutts_> lesur: and quite often we just write the program so there isn't any ProgramState or equivalent in the first place
10:01:24 <monochrom> there are IORef, MVar, STRef, StateT, just off the top of my head
10:01:53 <taylorgb> Do you have an example program? It would probably be easier to identify the most natural technique that way
10:02:02 <lesur> Looks like I don't know my haskell. :) Thanks guys, I'll keep learning.
10:02:17 <lesur> uh, not really, I've been thinking it through in my head.
10:02:30 <monochrom> they further expand to infinitely many options when you begin to consider e.g. "one IORef pointing to a record of many fields" vs "one record containing many IORef fields" etc
10:03:42 <monochrom> and who knows? perhaps it's "one recording containing many IORef fields, one of which is a record containing more IORef fields..."
10:04:37 <dcoutts_> lesur: generally having a ProgramState (or equiv) indicates that you're thinking of the program in an imperative way (which is not unusual for people new to FP, so don't feel bad about it!)
10:04:39 <pentace> I still haven't found a satisfying answer to that problem  ...
10:04:41 <monochrom> if you have 100 numbers to mutate, there are many, many different ways to organize them.
10:05:20 <dcoutts_> lesur: certainly we do sometimes write things in an imperative style (and that's the stuff monochrom is talking about), but it isn't the default
10:05:29 <monochrom> and yes, what dcoutts_ says, there are also many, many ways to eliminate the notion of mutating altogether
10:05:39 <lesur> Hmm, would reading other peoples code help me get that FP style?
10:05:41 <typoclass> lesur: i think of the ones monochrom mentioned, maybe State (or StateT) is the first one to look at. it basically provides you with a set function and a get function. you change the signature of all the functions where you need the program state, and from within those you can then call the setter and getter, as needed
10:05:51 <dcoutts_> lesur: yes, and books/tutorials
10:06:19 <c_wraith> ...  can you specify the fixity of type operators?
10:07:07 <typoclass> lesur: if you put your program on lpaste, you may get concrete answers. (doesn't matter if the program is partial or doesn't compile)
10:07:09 <typoclass> @where paste
10:07:09 <lambdabot> http://lpaste.net/new/haskell
10:08:21 <lesur> typoclass: sorry, I haven't written anything past the Euler solutions. :/ My question came from a mental experiment.
10:08:41 <typoclass> lesur: fair enough
10:09:25 <bryanvick> holy shit I just had the monad epiphany (finally)!
10:09:29 <lesur> typeclass: for future reference, was this message I typed, directly to you?
10:10:05 <h4199> bryanvick: time to write a tutorial blog post then.
10:10:11 <typoclass> lesur: almost yes :-) in most irc clients, you only need to type the first 2-3 letters followed by <tab>
10:10:34 <typoclass> lesur: (for convenience and for avoiding spelling errors)
10:10:37 <lesur> typoclass: cool! I've been typing it all out!
10:11:13 <lesur> typoclass: I'm to young, I had never even heard of a IRC before Haskell. :)
10:11:13 <c_wraith> Huh.  Looks like type operators are infixr.  That's the fixity I wanted, guess I don't need to worry about whether it can be set.
10:12:31 <c_wraith> err, no, they're infixl and my first test was..  somehow broken.
10:12:47 <h4199> bryanvick: congratulations though, didn't mean to sound trite
10:13:29 <bryanvick> h4199: no I didn't take it that way, I just keep typing stuff out and then deleting it because I have 1000 ideas in my head now that they are clear
10:14:00 <monochrom> deletion is important
10:14:12 <bryanvick> I just saw Matrix in Concert, and I feel like Neo when he sees the matrix for what it is at the end
10:14:29 <c_wraith> But you can specify fixity of type operators in ghc 7.6 and up.  ok then!
10:14:41 <bryanvick> Of *course* IO isn't unpure!
10:15:05 <monochrom> "IO is the OI"
10:15:13 <bryanvick> the IO monad doesn't execute instructions, it composes them sequentially, and only main/ghc actually executes things ... right?
10:15:53 <monochrom> ghc provides a runtime system that actually executes things
10:16:00 <scshunt> bryanvick: yesish
10:16:07 <scshunt> bryanvick: see unsafePerformIO
10:16:56 <monochrom> actually, that is still inaccurate. so how about: ghci or hugs provides a runtime system that actually executes things
10:18:12 <monochrom> as for compiling, it's going to be: generate machine code that would behave as though a runtime system actually executes things
10:19:28 <bryanvick> I also see why people write monad tutorials now. There is an urge to share the understanding
10:20:33 <typoclass> bryanvick: i take it you know what's up with burritos? if not, it's important to know
10:20:40 <typoclass> @google monad tutorial fallacy
10:20:43 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
10:20:43 <lambdabot> Title: Abstraction, intuition, and the “monad tutorial fallacy” | blog :: Brent ...
10:22:22 <bryanvick> I've read about the fallacy, thankfully I don't have a blog so the worst I'll do is pollute this channel a bit with my enthusiasm
10:22:33 <typoclass> bryanvick: fair enough ;-)
10:22:44 <bryanvick> :)
10:24:09 <monochrom> your model is correct. IO is only responsible for composing, not executing. something else is responsible for executing.
10:24:34 <monochrom> most other people's enthusiastic blogs don't even get that far
10:24:37 <taylorgb> IO isn't exactly the easiest thing to reason about just after having the monad lightbulb
10:25:00 <monochrom> but he's having an IO lightbulb
10:25:07 <taylorgb> Oh right
10:25:34 <bryanvick> I first had the understanding last night with the Either/Maybe monads, then reader, then IO just put me on my ass when I got it this morning
10:25:34 <lesur> Out of curiosity, how long did it take you to get your Monad lightbulb?
10:26:44 <bryanvick> lesur: I tried Haskell a couple times before now, but last time I decided I needed to understand FP from the ground up before I jumped in, so I did the lambda calc -> SICP -> write a scheme thing, and now Haskell is working for me
10:27:25 <bryanvick> lesur: I've spent the last 9 months in Scheme land, and have been back in Haskell for 1 or 2 months
10:27:46 <typoclass> lesur: in my opinion the lightbulb largely consists of "really? it's just that? then why all the fuss and the 6000 tutorials?"
10:28:14 <lesur> typoclass: Thats what OOP felt like when I first figured it out.
10:28:39 <bryanvick> lesur: yes I'm having a bit of that too.  Either/Reader/State seem to just be nice plumbing, but I really like what the IO monad does conceptually
10:29:04 <bryanvick> typoclass: Had that feeling about OOP when SICP talked about it
10:29:28 <lesur> bryanvick: You make me jealous I still don't see the importance of IO monads. :)
10:30:17 <monochrom> the importance of IO is I/O, of course
10:30:25 <bryanvick> lesur: I'm mostly just over excited
10:31:05 <bryanvick> ...but man, it's a nice abstraction I think for sequential computations that may have observable effects
10:31:50 <bryanvick> I guess transformers are next, since I can already see that many interesting things will require more than one monad at the same time
10:31:59 <h4199> bryanvick: So you have the IO, parsec, Either, Reader, and State monad down individually, have you hit transformers yet? I enjoyed that understanding almost as much as the generic monad lightbulb.
10:32:12 <chrisdone_> i am a mole and i live in a type hole
10:32:32 <monochrom> I'm monochrom and I live in an eprom
10:32:38 <chrisdone_> :D
10:32:45 <typoclass> chrisdone_: hopefully the hole is of the correct type for you
10:33:04 <chrisdone_> typoclass: if i only i had some kind of typoclass to constraint the hole's type
10:33:26 <bryanvick> h4199: was just thinking about transformers. I have "Monad Transformers Step by Step" by Martin Grabmuller here waiting to be read
10:34:58 <sm> hi chrisdone_, I wanted to let you know _ seems to break ircbrowse search
10:35:37 <h4199> bryanvick: I made a Int stack that printed when it popped as my first transformer. State and IO.  I don't know if that helps but it is what gave me the intuition for how a transformers worked.
10:35:42 <monochrom> is that why chrisdone_ has a _ , to evade ircbrowse search? :)
10:35:46 <chrisdone_> sm: in what manner?
10:35:57 <chrisdone_> oh, must've nick collided
10:36:08 <sm> eg: searching for SDL_INIT_CDROM finds nothing, but CDROM works
10:36:21 <monochrom> yikes
10:36:50 <evancz> I am using Text.PrettyPrint, but the Doc type does not derive Typeable or Data. Is it possible to derive these things after the fact?
10:36:52 <chrisdone> sm: is there an actual result for SDL_INIT_CDROM?
10:37:12 <chrisdone> seems to work fine: http://ircbrowse.net/browse/haskell?q=chrisdone_
10:37:38 <bryanvick> h4199: nice.  I'm interested in how IO and Either mix. Seems like many errors in IO could be handled nicely w/ Left err instead of exceptions
10:37:48 * chrisdone wonders if there's a clever catamorphism pun on lambda cats
10:37:59 <applicative> evancz: it should be possible with StandaloneDeriving, but maybe one should just send a patch ...
10:38:20 <luite> evancz: yeah use StandaloneDeriving
10:38:20 <sm> chrisdone: yes there is (somewhere)
10:38:27 <luite> evancz: then just deriving instance Typeable X
10:38:36 <chrisdone> sm: i'll search the db directly to see
10:38:37 <typoclass> chrisdone: not really. there's a cat who has a banana peel fallen on her head
10:38:45 <luite> evancz: you need to have the constructors available for that though
10:38:48 <sm> here: http://ircbrowse.net/browse/haskell/?events_page=342678
10:39:26 <evancz> luite: as in all the constructors that can possibly make a Doc?
10:40:10 <chrisdone> sm: i think it's counted as one word: http://ircbrowse.net/browse/haskell?q=%E2%80%98SDL_INIT_CDROM%E2%80%99
10:40:22 <luite> evancz: yeah, at least i'm pretty sure that's required
10:41:33 <sm> chrisdone: I did try that, but entering 'SDL_INIT_CDROM' or "SDL_INIT_CDROM" in the search box doesn't work
10:42:07 <luite> evancz: perhaps not for Typeable? (note that you can define your own Typeable instance, but that's not allowed in 7.8 anymore)
10:42:16 <chrisdone> sm: they are curly quotes
10:42:35 <evancz> hmm, the constructors are not exported by Text.PrettyPrint (which makes sense)
10:42:39 <applicative> evancz: I wonder if there's another pretty printing library
10:42:54 <sm> oh for heavens sake :)
10:43:06 <c_wraith> when 7.8 comes out, I'll be able to provide Show instances for this type I'm working with that actually tell the whole story!
10:43:09 <luite> evancz: do you want to serialize a Doc without printing it or something?
10:43:23 <chrisdone> sm: what can i say, it's a precise search =p
10:43:33 <sm> well ircbrowse is awesome and I wish it supported all irc channels. Thanks chrisdone
10:43:49 <chrisdone> i think i can make sphinx more fuzzy, though
10:43:53 <chrisdone> sure
10:43:55 <evancz> I run Uniplate on my AST to find things sometimes, and there may be some docs in there
10:44:03 <evancz> maybe this is just not a good idea
10:44:06 <evancz> and I should rethink
10:44:15 <chrisdone> maybe
10:44:16 <chrisdone> you should
10:44:22 <applicative> I think its clear there should be typeable instance for Doc no?
10:44:25 <h4199> bryanvick: you are right, once you write something take a look at Error in the mtl package.
10:44:34 <typoclass> chrisdone: doesn't it have a function to find the beginnings/ends of words?
10:44:42 <monochrom> yes, Typeable is fair
10:44:52 <luite> a pull req for Typeable should be ok indeed
10:44:56 <chrisdone> typoclass: i'd expect so, somewhere in the configuration
10:45:07 <bryanvick> h4199: will do, thanks
10:45:42 <evancz> okay, i'll find an alternate method
10:45:52 <evancz> thanks everyone :)
10:46:21 <luite> evancz: also check out lens for your AST traversals :)
10:46:59 <chrisdone> luite: what's up dude?
10:47:06 <luite> hej!
10:47:23 <luite> chrisdone: you must come to zurihac and bring a mountainbike etc
10:48:06 <chrisdone> haha
10:50:48 <applicative> should I also be deriving Data for Doc while I'm at it?
10:50:54 <luite> evancz: only problem is that lens makes it so easy to traverse and rewrite complex structures that you end up with much too slow code, and you have spend weeks rewriting it then! (lens contains some uniplate/biplate derived things, with somewhat generalized types, and clever caching so it doesn't traverse parts of the data that can't contain hits, which is a bit broken so you'll sometimes scratch your head because it didn't traverse the things you were looking for
10:51:18 <chrisdone> applicative: isn't Doc an opaque type?
10:51:37 <evancz> applicative: Doc is not exported
10:51:44 <evancz> oops, that was for chrisdone
10:52:06 <evancz> is it bad to have these instances on such a type?
10:52:09 <applicative> Doc is exported not the constructors
10:52:22 <luite> applicative: hmm, perhaps better not
10:52:23 <applicative> are the uses of Data opposed to this, hm
10:52:25 * roconnor is trying to gain an understaing of the J monad and its uses
10:52:28 <evancz> oops, yes, that's what I meant
10:52:49 <chrisdone> not sure. just seems a little like subverting the author's intentions to derive Data and look at the constructors
10:52:59 <chrisdone> can GHC derive Data instances for a type whose constructors aren't exported?
10:53:14 <applicative> chrisdone this is a patch to Text.Pretty
10:53:41 <applicative> http://lpaste.net/91494 prettyprint rather
10:53:45 <luite> chrisdone: i think it can't
10:53:49 <luite> but not sure
10:54:00 <luite> on the other hand, evancz could make an orphan Data instance that doesn't traverse it
10:54:10 <luite> that would make uniplate work for the rest of the stuffs
10:54:11 <applicative> I don't really understand Data.Data
10:54:13 <simon> I'm trying to use a happy "posn" parser with a parseError :: [Token] -> Either String a, but I get the following type error when I compile my generated parser: http://ix.io/72h (Couldn't match type `a' with `Either String a0'    `a' is a rigid type variable bound by    the type signature for happyError' :: [Token] -> HappyIdentity a    at RFUN/Parser.hs:147:16
10:54:22 <evancz> applicative: me neither
10:54:35 <luite> applicative: if you make an instance, i'd probably not make one that can access the constructors
10:55:08 <applicative> maybe the reason this hasnt been done is no one knows what to do
10:55:25 <applicative> or they know all to well
10:55:49 <luite> http://hdiff.luite.com/cgit/text/tree/Data/Text.hs#n349 <- this is what you can do
10:56:00 <luite> for an abstract type
10:56:08 <luite> a "dummy" Data instance
10:56:18 <luite> adding that to the package should be fine
10:56:40 <simon> should I somewhere in my Parser.y specify the expected error type? I've only got '%error { parseError }'
10:57:17 <luite> applicative: that's the only reasonable instance you can make outside the package, so might as well add it inside
10:57:42 <lesur> Uh, sorry, quick question:  I can use getLine in input <-getLine , to get input from the terminal right?
10:57:43 <luite> evancz: ^ so for just uniplating the AST you should be fine
10:57:52 <chrisdone> lesur: yeah
10:58:00 <lesur> chrisdone: thanks
10:59:28 <applicative> I was interested in Typeable in the first instance, which seems no problem, vide http://hdiff.luite.com/cgit/text/tree/Data/Text/Internal.hs
11:00:03 <applicative> it does seem Data is more trouble than it's worth
11:00:22 <luite> applicative: yeah that's ok, and also the only way (other than standalone deriving which does the same as of GHC 7.8)
11:00:51 <luite> applicative: well, you can provide an instance so it's easy to traverse data structures that contain Doc with uniplate/syb/lens
11:01:11 <luite> that's the reason Text does it i guess
11:01:19 <applicative> yeah
11:01:49 <luite> but with that instance it's a 'leaf', you can't travers into it anymore. if you serialize it you proably have to render it, which means fixing the layout
11:02:10 <chrisdone> took me a longwhile to get comfortable with Data
11:02:10 <luite> dunno if that makes it a bad case for Data :)
11:02:23 <luite> chrisdone: you comfortable with Generic yet?
11:02:54 * roconnor is currently irrationally repulsed by Data
11:03:46 <applicative> hm, bytestring 'derives Data'
11:04:45 <luite> applicative: uh no?
11:04:59 <luite> at least not 0.10.3.0 i'm looking at here
11:05:05 <chrisdone> luite: i've not looked at Generic yet
11:06:04 <monochrom> bytestring's Data instance is error"Data.ByteString.ByteString.toConstr"
11:06:27 <luite> yeah it does traverse into the bytes with gfoldl
11:06:34 <luite> i'm not sure that's a great idea
11:07:36 <c_wraith> I have this sneaking suspicion that all the work I'm doing to ensure that I create correct types of MArray to unsafeFree to the necessary IArray type is pointless because the optimizer can't even see the types in question in the context they're being used.
11:07:42 <luite> Text does the same, perhaps it's not so bad?
11:08:02 <c_wraith> I guess I should write up a sample program, compile with optimizations, and dump rule firings.
11:08:22 <c_wraith> .. I just need to figure out what the RULES names for unsafeFreeze are
11:09:17 <Saizan> luite: it's much better to use some smart constructor instead, when the type is abstract
11:09:18 <applicative> hah
11:10:45 <applicative> monochrom: Text does the same thing, making most Data methods an error
11:10:54 <applicative> oh luite said that
11:11:46 <applicative> somehow I feel that Doc shouldn't be so complicated
11:12:40 <evancz> applicative, luite, also, I think I have a workable alternative for now
11:14:11 <luite> Saizan: that's what Doc uses already
11:14:19 <monochrom> to a large extent, Text.PrettyPrinter.PJ demonstrates how a simple algebraic type (Doc) supports a nice prettyprinting API, and so instance Data Doc is reasonable. but you also have the concern of how much of Doc should be exposed rather than hidden
11:16:07 <monochrom> Doc is meant to be both algebraic (Data-friendly) and off limits (Data-hostile)
11:16:41 <applicative> CoNTraDiCtiOn
11:19:16 <applicative> I wonder if there's some good recent discussion of this. The thread bos point to is old and undecided http://groups.google.com/group/haskell-cafe/browse_thread/thread/b5bbb1b28a7e525d/0639d46852575b93
11:29:14 <chrisdone> monochrom: indeed… i'd prefer an Internal module exporting the data constructors
11:29:53 <chrisdone> seems a more recent convention than when SPJ's printer was written, tho
11:43:10 <chrisdone> http://tryhaskell.org/ocean/
11:47:18 <applicative> "Need reasons to love Haskell? Look no further."
11:47:44 <c_wraith> chrisdone: colors are good, but I hate that font.  It was way better before I allowed custom fonts.
11:48:05 <applicative> yes, the font is a little rough somehow.
11:49:54 <chrisdone> applicative: c_wraith: actually that's the same font as used on haskell.org
11:50:05 <chrisdone> i'm not too into it either, but i thought i'd faithfully apply the theme as-is
11:51:03 <applicative> oh youre right, but somehow on the main haskell.org page it doesnt have much work to do
11:51:33 <applicative> so its no different
11:51:33 <chrisdone> i'd prefer a simple sans-serif
11:51:54 <diabel232> how can i write this in haskell
11:52:00 <diabel232> this code is in python
11:52:01 <diabel232> "*"*300
11:52:05 <elliott> chrisdone: while you're messing with haskell.org, can you change the "Download Haskell" button's text to not be totally misleading? :p
11:52:19 <applicative> Download Haskell Platform ?
11:52:23 <elliott> yes, that would be nicer
11:52:41 <piron> > replicate 300 '*'
11:52:42 <lambdabot>   "**************************************************************************...
11:52:47 <applicative> I dimly remember a fight about this when the button was devised by dons
11:52:49 <diabel232> thank you
11:53:12 <piron> > concat (replicate 300 "abc")
11:53:13 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
11:53:20 <piron> and, for fun
11:53:25 <applicative> uh oh
11:53:27 <piron> > "abc" >>= replicate 300
11:53:28 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
11:53:42 <applicative> > "abc" >>= replicate 30
11:53:43 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcccccccccccccc...
11:54:01 <mauke> > "abc" <* [1 .. 300]
11:54:02 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
11:54:13 <mauke> > [1 .. 300] >> "abc"
11:54:14 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
11:54:19 <elliott> > "abc" <* [1..10]
11:54:20 <lambdabot>   "aaaaaaaaaabbbbbbbbbbcccccccccc"
11:54:21 <piron> Oh, I like that one.
11:54:23 <elliott> whoa.
11:54:32 <elliott> oh.
11:54:37 <elliott> that's obvious.
11:54:47 <mauke> all haskell code is trivial
11:54:49 <chrisdone> elliott: i'm not messing with haskell.org, just documenting the current theme/palette using bootstrap (with its extensive example set). but yeah, hopefully i can get access to haskell.org to tweak some things, make it a bit more modern
11:55:16 <piron> (that one = ([1..300]>>))
11:55:32 <chrisdone> the current thing is ok for me, i just want to make it feel more up market. like pretty woman
11:56:19 <applicative> ha
11:58:07 <applicative> somehow I feel anything called 'haskellwiki' will need a lot of help to feel upmarket
11:59:04 <chrisdone> yeah i'd like to down play the wiki aspect on the home page
12:00:04 <chrisdone> alas, getting access has always been beyond my reach
12:01:13 <applicative> I see it needs actually to be a wiki page of course
12:01:48 <chrisdone> the process usually goes: excitement, motivation, hope, patience, impatience, despair, resentment, forgetting
12:02:36 <chrisdone> every couple years i get motivation to sort it out and get stonewalled
12:03:00 <applicative> nice that you kept murder and php off that list
12:04:24 <Saizan> is "by nerds, for nerds" part of the up-marketing? that's a bit cringey
12:04:36 <chrisdone> Saizan: nah, the text on that page is from bootstrap
12:04:44 <applicative> it goes with lorem ipsum
12:04:44 <chrisdone> i just replaced some stuff so it didn't look like bootstrap
12:05:05 <Saizan> ah, fair enough
12:05:33 <chrisdone> (http://getbootstrap.com/2.3.2/)
12:09:24 <Redz> hello,
12:09:25 <Redz> is there a lens function which appends on a tuple?
12:09:26 <Redz> c -> (a,b) -> (a,b,c) and d -> (a,b,c) -> (a,b,c,d) , ...
12:09:34 <edwardk> nope
12:11:49 <levi> Redz: Thinking about why there isn't is a good exercise in understanding the type system.
12:12:20 <sm> chrisdone: nice. Your http://chrisdone.com/posts/haskell-homepage-thoughts is excellent too
12:12:43 <elliott> well, you could write such a function in the same way lens's _1 etc. are done
12:12:46 <elliott> but it would have nothing to do with lens.
12:13:01 <exicer> When things say "see haddock documentation" where should I be looking ?
12:13:55 <BMeph> levi: To be fair, it would be much easier to do in TH, which annoys me to a great extent.
12:13:58 <Redz> i could use a list of Dynamic, but this is more ugly.
12:14:35 <geekosaur> exicer: if you look the package in question up on hackage, you'll usually find documentation for the modules
12:14:38 <elliott> exicer: probably http://hackage.haskell.org/package/thepackagename
12:14:41 <levi> exicer: haddock is an 'extract documentation from source and comments' tool.  You could run it locally or use the pre-generated copies on Hackage.
12:14:46 <geekosaur> ("haddock" is the documentation processor)
12:14:48 <elliott> you may also have the docs locally
12:17:19 <levi> The 'automatically add elements to a tuple' is more or less and instance of the expression problem, isn't it?
12:19:04 <BMeph> levi: Here's a fun exercise - Why doesn't your "add elements to a tuple" function put the new one at the Front of the tuple? You mention it first, after all. ;)
12:19:42 <exicer> Cool, thanks guys.
12:25:32 <levi> Now that I think about it some more, all the n-tuples are already defined, so writing a function that takes a value and an n-tuple of values and returns them all together in an (n+1)-tuple is not hard and you can completely re-arrange the order if you like, because the n-tuple and (n+1)-tuple are completely unrelated types.
12:28:30 <Redz> i do so. i wonder why there are no typelists like in c++ . tuples are annoying. ;)
12:33:06 * hackagebot io-manager 0.1.0.0 - Skeleton library around the IO monad.  http://hackage.haskell.org/package/io-manager-0.1.0.0 (MihaiMaruseac)
12:33:08 * hackagebot io-manager 0.1.0.1 - Skeleton library around the IO monad.  http://hackage.haskell.org/package/io-manager-0.1.0.1 (MihaiMaruseac)
12:33:27 <levi> I'm not sure what a C++ typelist is.
12:34:34 <BMeph> A tuple is just a list, at the type level.... ;)
12:34:53 <levi> Er, not really.
12:35:26 <levi> A list is an inductively-defined type, while a tuple is a product type.
12:36:15 <Taneb> If it was a list, (a, b, c) would be syntax sugar for (a, (b, c)) which it definitely is not
12:37:12 <BMeph> Taneb: Then what would [a, [b,c]] be? ;)
12:37:20 <bscarlet> or (a, (b, (c, ())))
12:37:20 <Taneb> Type error
12:37:38 <BMeph> Taneb: Why?
12:37:57 <BMeph> Taneb: Are they not types of the same kind?
12:37:59 <levi> They're not type errors, they're just nested tuples/lists.
12:38:01 <applicative> newtype List a = List (Maybe (a, List a))
12:38:53 <Taneb> Because, (assuming a, b, and c all have the type "Type"), a would have type Type and [b, c] would have type [Type], so does the whole thing have type [Type] or [[Type]]?
12:39:11 <bscarlet> applicative: I'd think using newtype and Maybe would confuse the issue. Did you have a particular point to make with that choice?
12:39:43 <levi> Taneb: You never said a, b, and c all had the same type.
12:39:44 <applicative> that lists and tuples dont have nothing in common
12:40:53 <bscarlet> applicative: hrm. kinda forced, but I see your point.
12:40:54 <applicative> in any case there are as-you-please tuple types, like HList
12:41:11 <elliott> bscarlet: well, not really that forced. that's the fundamental definition of the functor that gives you lists, really
12:41:20 <elliott> L(a) = 1 + a * L(a)
12:41:31 <BMeph> bscarlet: I'd say that using newtype and Maybe, not only does not "confuse the issue," but makes the isomorphism more explicitly match the original form.
12:41:35 <elliott> which is List a = () `Either` (a, List a)
12:41:46 <elliott> which is List a = Maybe (a, List a)
12:41:47 <applicative> ah even better :0
12:42:02 <bscarlet> elliott: as opposed to data List a = List a (List a) | EmptyList?
12:42:10 <elliott> sure.
12:42:27 <elliott> we understand the meaning of that data type in terms of the L functor.
12:42:36 <elliott> modulo _|_s and stuff.
12:42:47 <applicative> in any case it makes some things blindingly clear ...
12:44:11 <applicative> I wonder though, what Redz was looking for
12:44:58 <applicative> surely c++ has nothing our dear language!
12:45:21 <monochrom> heh, our dear language
12:45:54 <monochrom> our dear language has type political correctness and kind political correctness
12:46:36 <Redz> i will write a little parser lib. parsec is fine, but i try some other approach.
12:47:04 <applicative> Redz: have you seen attoparsec one of the ultra-moderne alternatives?
12:47:39 <Redz> no.
12:47:59 <applicative> i think its sort of the most popular these days
12:48:15 <flebron> Is there any notion of a 0 in Num? If so, what would I need to obtain it? (Strong preference towards not installing non-base packages)
12:48:15 <Redz> whats the difference?
12:48:17 <applicative> maybe parsing genuine programming languages are a clear exception where parsec wins
12:48:47 <applicative> Redz it's insanely optimized by the leading master
12:48:54 <applicative> for one thing
12:49:07 <flebron> (I'm building a Polynomial a type, [a] as a list of coefficients, and for something like [1, 2, 0], I'd like to trim the trailing 0s, since they are meaningless.)
12:50:06 <cdk> flebron: the Monoid instance for Sum maybe?
12:50:29 <monochrom> fromInteger is the notion of 0 in Num, and 1, and 2...
12:50:48 <cdk> then you could use mconcat to simplify
12:50:51 <Redz> oh i think, optimization is a problem in haskell. creating extra types just for optimization makes haskell less elegant.
12:51:31 <applicative> I don't know, there's nothing strange about the types in attoparsec
12:51:50 <levi> You don't make extra types for optimization purposes, you make extra types to express precisely what you mean.
12:51:56 <applicative> everything is basically the same, but e.g. not the same line number error messages and deluxe features like that
12:53:13 <applicative> I guess its true the attoparsec is dedicated to Text and ByteString input, whereas Parsec has a more general input conception
12:53:21 <levi> Creating multiple copies of all your generic code at compile-time just for optimization makes C++ less elegant. :P
12:53:40 <Redz> attoparsec looks fine. i think for those new webframework things. conduits and other things in wai.
12:54:14 <applicative> conduits are a little complicated
12:54:28 <applicative> it could be worse, check out the pipes library ...
12:56:53 <roconnor> applicative: is lens complicated?
12:59:10 <applicative> I was regretting introducing this concept as soon as I had done it, roconnor
12:59:23 * BMeph finds lens to be gloriously complicated, like a nuclear power plant!
12:59:38 <Zenol> nuclear power plant! \ o /
12:59:44 <applicative> but the abc combinators are pretty simple, no?
12:59:55 <applicative> > (1,2) ^. _1
12:59:56 <lambdabot>   1
12:59:59 * BMeph gives Zeno a cyber-high-five
13:00:01 <applicative> > (1,2) ^. _2
13:00:03 <lambdabot>   2
13:00:24 <applicative> > (1,2) &  _2 .~ 3
13:00:26 <lambdabot>   (1,3)
13:00:37 <applicative> see, i can always remember those ;)
13:00:45 <roconnor> abc?
13:00:52 <applicative> elementary
13:00:56 <roconnor> ah
13:01:01 <applicative> which comes from 'lmn'
13:01:05 <roconnor> that's all that is important.
13:01:07 <Zenol> > ["a","b", "c"] & _2 .~ "z"
13:01:09 <lambdabot>   No instance for (Control.Lens.Tuple.Field2
13:01:09 <lambdabot>                     [[GHC.Types....
13:01:13 <Zenol> :(
13:01:29 <edwardk> > ["a","b","c"] & ix 1 .~ "z"
13:01:30 <lambdabot>   ["a","z","c"]
13:01:37 <Zenol> oh
13:01:41 <applicative> haha
13:01:43 <Zenol> _n is only for tuples?
13:01:46 <edwardk> yeah
13:01:48 <applicative> the master appears
13:02:09 <edwardk> _n is a lens, but nothing tells you the length of a list. so how can it replace the 30th element of say a 3 element list?
13:02:23 <edwardk> ix n is a traversal, so it can 'have 0 targets' if the list isn't long enough
13:02:44 <edwardk> but to query it then you should use (^?) to deal with the possibility of the target not being there
13:02:56 <applicative> Zenol: now youre supposed to say, Of course! it all makes so much sense!
13:03:04 <chrisdone> i'm pretty sure i've seen lenses that are a no-op if a record field is of the wrong type or so
13:03:06 <edwardk> > ["hello","world"]^?ix 0
13:03:08 <lambdabot>   Just "hello"
13:03:11 <edwardk> > ["hello","world"]^?ix 2
13:03:12 <lambdabot>   Nothing
13:03:26 <edwardk> chrisdone: those are traversals not lenses
13:03:37 <edwardk> > ["hello","world"] & ix 3 .~ "whatever"
13:03:39 <lambdabot>   ["hello","world"]
13:03:42 <Zenol> applicative> Thanks, you read my mind :)
13:03:49 <edwardk> that changes all the valid targets of the traversal to 'whatever' and there are no targets
13:03:54 <chrisdone> edwardk: in your naming convention
13:04:43 <edwardk> well, with non-type changing lenses you can make all sorts of lenses that piss over the lens laws. the nice thing about the type-changing formulation is it really does force you to do the right thing in more scenarios
13:05:00 <edwardk> your mileage may vary if you go off and use other conventions or give up the laws
13:05:06 <Zenol> so you shouldn't use ^. but ^? when you don't know the "size" of the object?
13:05:35 <edwardk> (^?) lets you ask for the (first) target of a traversal if it exists or get back Nothing if it doesn't.
13:05:40 <bennofs> Zenol: You should use ^? for anything that may fail (i.e. may not deliver a result)
13:05:46 <edwardk> in general (^?) is useful when it can fail
13:06:02 <edwardk> > M.fromList [(1,2)]^?ix 1
13:06:04 <lambdabot>   Just 2
13:06:08 <edwardk> > M.fromList [(1,2)]^?ix 3
13:06:09 <lambdabot>   Nothing
13:06:24 <edwardk> > M.fromList [(1,2)]^.at 1
13:06:26 <lambdabot>   Just 2
13:06:32 <edwardk> > M.fromList [(1,2)] & at 1 .~ Nothing
13:06:33 <lambdabot>   fromList []
13:06:39 <edwardk> > M.fromList [(1,2)] & at 3 .~ Just 4
13:06:40 <lambdabot>   fromList [(1,2),(3,4)]
13:06:58 <edwardk> ix is a 'traversal' that can only access a member of a container that is there, and edit it if its present, but can't add it to the container.
13:07:53 <edwardk> at n is a lens that can view the target in a container as a (Maybe a) giving you back its presence of absence as a manipulable thing hence why you can remove elements from a container with at, and you can add new elements with at as well
13:08:30 <Zenol> oh
13:08:46 <edwardk> ix n = at n . traverse
13:09:05 <Zenol> still don't know what's a traversal and a lens, but I think I understand how to use it :)
13:09:19 <edwardk> do you know what Traversable is?
13:09:23 <edwardk> :t traverse
13:09:52 <latro`a> @type traverse
13:10:02 * latro`a is confused by lambdabot's silence
13:10:05 <levi> So complicated it broke lambdabot!
13:10:21 <latro`a> > 1+1
13:10:22 <lambdabot>   2
13:10:25 <latro`a> wtf
13:10:31 <mauke> > traverse
13:10:32 <lambdabot>   No instance for (Data.Traversable.Traversable t0)
13:10:32 <lambdabot>    arising from a use of ...
13:10:39 <chrisdone> it's under T, iirc
13:10:42 <chrisdone> :t T.traverse
13:10:43 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:10:45 <edwardk> traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:10:50 * roconnor didn't know what Traversable really was until I knew what Traversals/Multilenses were.
13:10:53 <mauke> :t fiddlesticks
13:10:53 <lambdabot> Not in scope: `fiddlesticks'
13:11:27 <edwardk> a traversal is a generalization of that pattern
13:11:39 <edwardk> :t let both f (a,b) = (,) <$> f a <*> f b in both
13:11:40 <lambdabot> Applicative f => (t -> f a) -> (t, t) -> f (a, a)
13:11:51 <edwardk> > (1,2)^..both
13:11:52 <lambdabot>   [1,2]
13:12:01 <edwardk> > (1,2) & both .~ 3
13:12:02 <lambdabot>   (3,3)
13:12:05 <edwardk> > (1,2) & both +~ 1
13:12:06 <lambdabot>   (2,3)
13:12:24 <edwardk> its like a lens but it can affect 0 or more targets instead of just 1
13:12:32 <diabel232> guys for what you need so many calculations?:P
13:12:54 <BMeph> For Knowledge!!
13:13:07 * hackagebot processing 1.0.0.1 - Web graphic applications with Processing.  http://hackage.haskell.org/package/processing-1.0.0.1 (DanielDiaz)
13:13:09 * hackagebot heukarya 0.1.0.0 - A genetic programming based on tree structure.  http://hackage.haskell.org/package/heukarya-0.1.0.0 (HeChienTsai)
13:13:30 <edwardk> diabel232: i lenses because they help shrink my code further and let me focus on the intrinsic complexities of my problem rather than the incidental complexities of my encoding.
13:13:37 <Zenol> diabel232> to not get bored :)
13:13:39 <edwardk> er i use lenses
13:13:52 <diabel232> thanks for answer:)
13:14:56 <edwardk> the nice thing about them is that you get a large set of combinators that can be used in 'the only way that makes sense' for querying or modifying parts of all sorts of different kinds of structures in a consistent way
13:15:57 <levi> "type-safe jquery for ADTs" :P
13:16:27 <edwardk> levi: more importantly type-safe *principled* jquery for ADTs ;)
13:16:50 <edwardk> that is a really good way to view it though
13:17:24 <levi> Man, now we've got to have both types *and* principles?
13:17:44 <edwardk> yeah i can come up with a system of ad hoc classes that let me typecheck anything
13:17:53 <edwardk> but a good set of laws is hard to find
13:20:50 <levi> If it was easy, there wouldn't be anything for mathematicians to do, eh?
13:21:29 * BMeph pities edwardk, and his ambitions of Haskell type law enforcement.... ;)
13:21:54 <BMeph> edwardk: Were you interested in a career in law enforcement? ;)
13:22:09 <levi> It's really a practical matter. If you're going to subvert your types, why bother with them at all?
13:22:22 <levi> Might as well write javascript!
13:22:30 <exicer> Okay, so why is this producing a parse error ? http://lpaste.net/91498
13:23:09 <Zenol> exicer: parenthesis?
13:23:15 <mauke> exicer: because spaces don't affect precedence
13:23:24 <mauke> a b : c means (a b) : c
13:23:36 <BMeph> exicer: The short and unhelpful answer? 'Cause you're doin' it rong! ;)
13:23:46 <exicer> BMeph: Well I know that! :p
13:23:57 <exicer> Okay, this is one of those face-meet-palm moments
13:23:58 <exicer> Cheers
13:25:40 <b2coutts> a b:c is one of those unfortunate things about haskell syntax
13:25:49 <b2coutts> intuitively that reads like a (b:c)
13:26:02 <mauke> no, it's one of those unfortunate FUCKING PUT SPACES AROUND YOUR OPERATORS, PEOPLE things
13:26:21 <chrisdone> yeah, spaces should be mandatory
13:26:29 <chrisdone> then we could have more stuff in our identifiers
13:26:48 <dncr> What is the simplest/most-lightweight was to determine the maximum memory usage of (myF :: IO ())? Just time -v on main = myF? There's no cool way to do it in haskell or in ghci?
13:27:00 <dncr> s/was to/way to/
13:27:12 <mauke> chrisdone: be careful what you wish for
13:27:23 <chrisdone> dncr: ghci's :help:  +s            print timing/memory stats after each evaluation
13:27:26 <mauke> ploki allows random non-whitespace characters in label names
13:27:31 <dncr> chrisdone: nice
13:28:07 <chrisdone> mauke: lisp is pretty liberal, names used in lisp code are generally sane
13:28:26 <Zenol> hum, I was wonder wich library I should use to generate xml output?
13:28:28 <mauke> lisp is still restrictive about identifiers
13:28:31 <chrisdone> foo? *bar* zot. call/cc are about as bad as it gets
13:28:36 <levi> Mmm, destructruing-bind
13:28:42 <chrisdone> it's restrictive, but *nowhere near* haskell
13:28:43 <levi> Er, destructuring-bind
13:29:00 <Zenol> hxt?
13:29:03 <dncr> chrisdone: so you do [1 .. a ^ n + b ^ n]?
13:29:20 <dncr> chrisdone: or.. [ 1 .. a ^ n + b ^ n ]  ?
13:29:30 <chrisdone> dncr: i don't, because i don't have to
13:30:00 <dncr> oh
13:30:07 <chrisdone> (and because it's not normal haskell style)
13:30:23 <mauke> apparently I've used all of the following labels: *&ref-assign*& main: s///g ;
13:30:24 <chrisdone> [1..2] is normal, [ 1 .. 5 ] is just weird
13:31:23 <codesoup> what about [1 .. 5] i.e. spaces are nonmandatory (or even mandating no spaces) before/after "fence" characters (, [, <
13:31:25 <chrisdone> mauke: the space concept taken to its logical conclusion: http://chrisdone.com/z/
13:31:39 <chrisdone> codesoup: it's not normal as far as i'm aware
13:31:47 <chrisdone> (regardless of what's more logical)
13:35:24 <k00mi> chrisdone: in agda, you use _ in a function definition to indicate where the argument should be placed
13:35:32 <chrisdone> i'm pretty sure z is the only lisp where parentheses are banned entirely
13:35:41 <k00mi> so you can write  _secs  and would call it as  10 secs
13:36:40 <chrisdone> k00mi: yeah i've seen that
13:43:11 <Placinta> Hi. When you have no instance for a certain type variable, it shows a couple of possible instances, and at the end it write plus "14 others". Is it possible somehow to display them? Maybe a flag?
13:44:12 <FreeFull> Placinta: You could do :info classname
13:45:37 <Placinta> FreeFull: That works only ghci as I understand. Is there something similar for the compiler?
13:48:08 <FreeFull> I have no clue
13:48:22 <FreeFull> Have you tried the standard verbose flags?
13:50:02 <Placinta> FreeFull: Same thing
13:51:20 <roboguy_> Placinta: that sounds like it would make the compiler output a lot harder to read
13:51:51 <roboguy_> I think I'd always just want to look at ghci or hoogle or something
13:52:52 <Placinta> roboguy_: I see. It's just the error is inside a specific context of the code, and I thought it would be easier to find the missing type information by looking at those other instances
13:53:53 <roboguy_> Placinta: but couldn't you just see all those instances by going into ghci, importing the relevant module, and typing :i typeclass?
13:56:28 <roboguy_> I guess the exception to that would be instances that are defined in the code that has the error
13:56:41 <Placinta> roboguy_: That might be what I need
13:58:03 <Placinta> roboguy_: Strangely enough it shows me some kind of type family, instead of instances...
13:58:12 <Zenol> wow, hatex is a really huge package :/
13:58:31 <roboguy_> Placinta: what are you looking at with :i?
13:58:45 <Placinta> :info PersistStore
14:03:08 * hackagebot heukarya 0.1.0.1 - A genetic programming based on tree structure.  http://hackage.haskell.org/package/heukarya-0.1.0.1 (HeChienTsai)
14:10:02 <roboguy_> Placinta: huh, I guess :info doesn't work well with type families. well, at least you can find it on hackage: http://hackage.haskell.org/packages/archive/persistent/1.2.2.0/doc/html/Database-Persist-Class.html#g:1
14:10:12 <roboguy_> (they list the instances there)
14:12:10 <tulcod> i am writing an ffi, and a lot of C functions i'm working with return 0 for "error". in many cases, this best corresponds to a (Storable a => Maybe a) type in haskell, but since i have numerous types like these, is there a generic way to write an ffi that handles this?
14:12:39 <Placinta> roboguy_: Aye. I figured out to check there now. Thx!
14:17:58 <Redz> wow. 5 lines of code an 70 lines of error description ...
14:18:02 <Redz> *and
14:20:38 <jmcarthur> yeah, sometimes they get a little out of hand...
14:22:33 <hpaste> Redz pasted “i don't get it.” at http://lpaste.net/91499
14:22:38 <Zenol> hum I pased a .tex file with HaTex, and tried to output the whole structure with show, but it ran out of memory. Any idea on how I can make it? :/
14:23:06 <bennofs> Is there some typeclass in haskell for Monoid from which I can also "remove" something? With laws like a >< (b <> c) = (a >< b) >< c  and a >< empty = a?       (Where >< is an operation of that class)
14:23:32 <Zenol> oh... actualy, that might be a bug when the file is invalid latex...
14:26:15 <elliott> bennofs: http://hackage.haskell.org/package/monoid-extras may contain what you seek
14:27:27 <datura> bennofs: like a group?
14:28:19 <elliott> uh, that too I guess. :p
14:28:36 <bennofs> datura: Yes, I think that's it :P
14:29:35 <Zenol> hum, really stupie question. Do you know a way to indent output from show aplied to a showable object ?  It's a bit hard to read a 9500 wide line :s
14:29:38 <bennofs> :o hayoo: A web handler threw an exception. Snap <3
14:32:47 <Modius> Can Pipes and Parsec be used together?
14:33:03 <Fuuzetsu-emacs> Can anyone tell me where do all the miraculous functions at http://www.haskell.org/haskellwiki/Emacs/Keybindings_and_simple_usage are coming from? haskell-mode doesn't seem to provide them and I always wondered.
14:33:49 <bennofs> Modius: There is http://hackage.haskell.org/package/pipes-parse
14:33:59 <bennofs> Modius: Not exactly parsec though
14:35:22 <Zenol> ok, it's Text.Groom
14:36:37 <applicative> groom is good
14:37:12 <bennofs> @hoogle times
14:37:12 <lambdabot> Graphics.UI.GLUT.Fonts TimesRoman10 :: BitmapFont
14:37:12 <lambdabot> Graphics.UI.GLUT.Fonts TimesRoman24 :: BitmapFont
14:37:12 <lambdabot> package timestamp-subprocess-lines
14:39:59 <exicer> Is there a place I can post some code and get a code review?
14:40:17 <bennofs> @where lpaste
14:40:18 <lambdabot> http://lpaste.net/new/haskell
14:40:42 <exicer> Ah okay - just wondered if there was anything other than lpaste :)
14:40:53 <applicative> you can use other things
14:40:55 <bennofs> exicer: How long is trhe code?
14:41:27 <applicative> http://sprunge.us/
14:41:48 <applicative> alas, no hlint at sprunge
14:41:57 <exicer> Only around 50 lines or so
14:42:03 <exicer> But just as a general thing to know
14:42:31 <chrisdone> exicer: what's wrong with lpaste?
14:42:33 <applicative> what's wrong with lpaste, too public or something?
14:42:37 <chrisdone> lol
14:42:50 <exicer> Hah, no - but I will go to sleep soon
14:42:54 <chrisdone> #haskell, where your critiques of haskell products are met with challenges in stereo
14:42:59 <exicer> so if there were something where I could leave it overnight etc
14:43:06 <exicer> it would have been better!
14:43:08 * hackagebot patterns 0.1.0 - Common patterns in message-oriented applications  http://hackage.haskell.org/package/patterns-0.1.0 (TobiasSchoofs)
14:43:12 <bennofs> exicer: Bookmark it?
14:43:12 <elliott> exicer: codereview.stackexchange.com
14:43:14 <elliott> + drop a link in here
14:43:24 <chrisdone> pastes remain on lpaste forever
14:43:29 <geekosaur> if people annotate, bookmark the original and the critiques will be shown after when you reload
14:43:32 <chrisdone> and you can find your paste using your username
14:43:44 <elliott> I am fairly confident exicer wants a way to see commentary on the code left overnight.
14:43:53 <exicer> elliott: Yes :p
14:43:53 <elliott> which a pastebin is not really well suited-to (IMO)
14:44:00 <chrisdone> hm, i thought of that recently. adding comments
14:44:03 <chrisdone> gist supports comments
14:44:05 <geekosaur> true enough although I did suggest one way to do it\
14:44:07 <Hafydd> Oh, nice.
14:44:14 <bennofs> chrisdone: inline comments would be awesome#
14:44:24 <bennofs> like on github diffs
14:44:36 <Hafydd> #inline comments would be awesome
14:44:37 <chrisdone> hm, indeed
14:47:11 <bennofs> How would you call the opposite of "timesN" ?
14:47:23 <mauke> dividedbyN
14:47:30 <lispy> http://www.reddit.com/r/haskell/comments/1jnaz5/getting_started_with_ghc_hacking/
14:48:00 <chrisdone> lispy: cool =)
14:48:20 * chrisdone was thinking of hacking on ghci
14:49:19 <hpaste> applicative annotated “i don't get it.” with “i don't get it. (annotation)” at http://lpaste.net/91499#a91500
14:49:39 <applicative> Redz: http://lpaste.net/91499
14:50:18 <lispy> chrisdone: Cool!
14:51:04 <lispy> chrisdone: Improving GHCi is one of those relatively simple things (you usually don't have to have all that deep of haskell knowledge) but it's visible to many people.
14:51:29 <chrisdone> yeah, half of it is c =p
14:52:59 <Zenol> 'Find an expert who is willing to help you (try IRC or the mailing lists)'
14:53:22 <Zenol> i'm not convinced it's as easy :p
14:53:44 <lispy> Zenol: only one way to find out :)
14:54:07 <Zenol> lispy> I would like to have the time to try...
14:54:18 <Zenol> so many things to learn and so few time.
14:54:38 <chrisdone> lispy: you know much about ghci's byte code interpreter?
14:56:20 <lispy> chrisdone: no I don't.
14:56:36 <lispy> chrisdone: I know a bit about gmachines thanks to SPJ's publications, but not the byte code interpreter exactly
14:57:22 <chrisdone> i'm interested in supporting in-place update of functions, not sure whether the interpreter is designed for such things
14:57:43 <SrPx> Isn't there any language similar to Haskell except rooted in untyped lambda calculus instead?
14:57:46 <chrisdone> it might all be simplified/inlined away :/
14:57:57 <osa1> SrPx: scheme?
14:58:11 <SrPx> osa1: :l but
14:58:14 <lispy> chrisdone: hmm...I'm not sure that can be done safely
14:58:51 <lispy> chrisdone: if there is a thunk floating around that was constructed with the old definition, what would happen to it?
14:59:41 <chrisdone> lispy: i'd consider it the same as a zero-arg closure in lisp
15:00:03 <chrisdone> (defvar x (lambda () (foo 1)))   *update foo* (x) should use the new foo
15:00:18 <Redz> applicative: thank you. i think, i understand functional dependencies now. :)
15:00:28 <Zenol> as I think about, why it's bad to use template haskel ? (Except that it seams not being completely fully implemented)
15:01:00 <chrisdone> lispy: i think in general it means dynamic binding. in fay i can do this -- because javascript itself is dynamically looking up names, but fay is not real haskell
15:02:48 <Placinta> Is it possible to somehow copy paste code into ghci, such that the indentation is taken into account?
15:03:14 <lispy> chrisdone: have you read this? http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/GHCi
15:03:25 <bennofs> Placinta: try :set +m
15:03:27 <lispy> Placinta: there is a multiline mode
15:03:38 <lispy> :help
15:04:34 <Placinta> Thanks
15:06:01 <Zenol> wasn't applicative who says "but please don't use template haskell for that" ?
15:06:49 <chrisdone> lispy: thanks. the interpreter nomenclature is new to me, but this will be helpful once i've done some reading about the type of interpreter implemented in ghci
15:08:26 <levi> chrisdone: If you're implementing a new toplevel interpreter, you should look at utop for OCaml for ideas.
15:10:48 <levi> And since ghci allows dynamically loading libraries, it seems as if it should be possible to un-load and re-load them. The dynamic link phase would take care of fixing up references to point to the correct locations.
15:11:31 <levi> Linking/loading is a bit of an arcane topic, though.
15:15:23 <Modius> For doing a quasi-serious project, what forces pull you toward using pipes or conduits, or just avoiding either?
15:20:39 <levi> I wish I had a good answer there.
15:21:41 <levi> There is probably a lot more real-world production code based on conduits, as they've been around for a while baked into the Warp/Yesod infrastructure.
15:22:13 <levi> So there's somewhat more helper/glue code available in the conduit world, too.
15:23:44 <levi> Pipes seem to have some more conceptual elegance, but without having an implementation that seems significantly simpler for it. Huge type signatures, etc. Conduit's development was driven primarily by practical concerns.
15:28:54 <NemesisD> i think i've asked this before but i'm looking for something like foo <$> bar <*> baz but instead of foo :: a -> b -> c it is a -> b -> f c
15:28:58 <NemesisD> or m c
15:30:07 <elliott> you can prepend join $
15:30:10 <elliott> (you need a monad)
15:30:25 <ion> @type join (?foo <$> ?bar <*> ?baz)
15:30:26 <lambdabot> parse error on input `?'
15:30:38 <ion> elliott: halp
15:31:23 <ion> I wish Control.Monad had bind2 :: (a -> b -> m c) -> m a -> m b -> m c
15:31:45 <NemesisD> hmm i was doing that, must be something else with my types thats off then. i'll try to get it to work the long way
15:32:43 <NemesisD> also: is NoMonomorphismRestriction a Bad Idea?
15:33:59 <manek> Hi! What would be the purest way in Haskell to write a sequence of files? I've got a list of filenames "names" and a list of file contents "cntnts". I've tried something like "liftM3 writeFile files cntnts" but this does not work (because files and cntst are not IO Strings - they are simple Strings)
15:36:29 <ion> sequence $ zipWith writeFile names contents
15:36:48 <ion> sequence_ actually
15:37:06 <evincar> NemesisD: NoMonomorphismRestriction is fine. I like it because it avoids breaking eta-reduction.
15:37:12 <rvelez> Greetings everyone, n00b here curious to know if anyone else here has embraced Haskell as their first programming languaged learned?
15:37:29 <datura> i wish i had...
15:37:30 <evincar> ion: Control.Monad.zipWithM
15:37:41 <manek> ion: Thank you! I forgot about the sequence!
15:37:46 <ion> evincar: ah
15:37:54 <ion> I use NoMR in ghci, but i just specify top-level signatures in files.
15:38:03 <manek> evincar - Thank you also :)
15:38:10 <evincar> manek: np
15:38:29 <evincar> ion: Yes, top-level signatures are good practice, but that's really a separate issue.
15:38:39 <evincar> It *always* comes up in discussions of the MR though. :P
15:39:29 <scshunt> you're not doing it right unless you have enough extensions enabled to make your program not only undecideable, but such that it causes GHC to infinite loop trying to type-check
15:41:08 <Cale> manek: An IO String isn't really anything like a String, it's something which if you were to execute it, would do some stuff, and then produce a String as its result. If you're writing an IO action as a do-block and you have x :: IO t, you can write v <- x to execute x, obtaining its result v :: t.
15:42:15 <manek> Cale: Thank you, I know that - I was simply looking for zipWithM function :)
15:42:19 <Cale> ah, okay
15:42:35 <manek> Cale: But than you for your clarification :)
15:42:41 <manek> *thank
15:43:14 <applicative> rvelez: yes, but i'm a crank
15:44:06 <Cale> zipWithM is probably exactly what you need, but you could also get by with forM or mapM and zip, like  forM (zip files contents) $ \(f,c) -> writeFile f c
15:44:17 <Cale> (which is equivalent)
15:44:20 <applicative> who says the pipes package has bigger signatures than conduit?? ahem
15:45:58 <Cale> rvelez: For me, it was like the tenth language I learned, but I've taught it to a few people for whom it was the first, or practically the first language they were learning, and it went well.
15:46:45 <applicative> data Pipe l i o u m r is the core type of conduit; data Proxy a' a b' b m r is the core type of `pipes`
15:47:05 <Cale> rvelez: A nice thing about learning Haskell first is that you're naturally steered into some good habits that normally take some years to learn.
15:47:55 <Cale> applicative: Yeah, they're both pretty messy in that way :P
15:48:33 <applicative> admittedly conduit newtypes stuff away for various purposes
15:48:38 <Cale> (/>/) :: (Monad m, Proxy p) => (a -> p x' x b' b m a') -> (b -> p x' x c' c m b') -> a -> p x' x c' c m a'
15:49:02 <applicative> pretty deadly huh
15:49:30 <datura> wtf is a lioumr? some kind of extinct animal?
15:49:32 <applicative> I think its that  p x' x c' c m a' is all variables that really disturbs
15:49:35 <ion> applicative: I think both should use “m r s t a b” instead.
15:49:41 <applicative> hah
15:50:02 <applicative> i think it'd have to be s t a b m r
15:50:36 <Cale> s t a b m e
15:50:51 <ion> ++
15:52:02 <leroux> byorgey: Are you around?
15:52:59 <rvelez> Cale: Thanks for the input
15:53:32 <applicative> Cale in the latest version its  (Monad m)     => (a -> Proxy x' x b' b m a')   -> (b -> Proxy x' x c' c m b')  -> (a -> Proxy x' x c' c m a')
15:54:00 <applicative> but we are allowed to use the pointier 'for'
15:54:18 <applicative> e.g. for (each [1..10]) (lift . print)
15:54:58 <applicative> or equivalently (each ~> lift.print) [1..10]
15:55:41 <applicative> (each ~> yieldIf even ~> lift.print) [1..10]
15:55:53 <applicative> would print the even numbers if you apply 'run'
15:56:02 <applicative> so it's a picnic
15:56:03 <applicative> honest
15:57:14 <leroux> How can I make a instance of some typeclass with a type synonym?
15:57:34 <applicative> TypeSynonymInstances
15:58:55 <ClaudiusMaximus> so there's a Read instance for Array, but not UArray - is this a simple oversight or is there a good reason?
16:00:13 <hpc> ClaudiusMaximus: write an instance and send it to libraries@haskell.org
16:04:26 <Modius> What's the trick to make runProcess use a handle that isn't the stdout used by the app itself.  I basically want to start a process and interact with it distinctly from the stdio to my EXE
16:07:25 <Redz> is there a typeclass which says: type a is not a tuple?
16:08:00 <geekosaur> Modius: you probably want a pipe and should use createProcess instead of runProcess
16:08:20 <geekosaur> (you could do it with runProcess but you'd have to create and manage the pipe yourself)
16:10:13 <watermind> Redz: is there even one that says that it is?
16:11:04 <Redz> watermind: sure. (a,b) . ;)
16:11:13 <watermind> Redz: that's not a typeclass
16:11:28 <Redz> but it says, its a tuple. :p
16:11:35 <watermind> Redz: but it's not a typeclass
16:11:43 <Redz> ah no.
16:12:15 <Redz> but this is not the problem.
16:12:26 <geekosaur> haskell isn't good at negative type constraints
16:12:38 <watermind> Redz: you could do something like   Either (a,b) c
16:12:38 <geekosaur> there are ways to do it but they're painful
16:13:09 <watermind> Redz: where the values can either be pairs, or something else... but the something else is not guaranteed by the typesystem not to be a pair
16:13:59 <jmcarthur> Redz: i question your motives here :)
16:14:17 <jmcarthur> Redz: surely if you can't handle tuples then there are other things (probably most things) you can't handle either
16:14:44 <jmcarthur> Redz: so i think it is likely to make more sense to name the things you *can* handle than the things you can't
16:15:04 <pentace> Is there even a way to exclude certain types but include all other types without explicitly listing them?
16:15:18 <jmcarthur> pentace: what would you do with it if it was easy?
16:15:39 <pentace> I have no idea, just asking
16:16:17 <hpaste> ClaudiusMaximus pasted “Read instance for UArray” at http://lpaste.net/91503
16:16:27 <ClaudiusMaximus> hpc: ^^^
16:16:43 <ClaudiusMaximus> so i guess the reason is -XFlexibleContexts
16:17:03 <jmcarthur> type family NotUnit a where NotUnit () = Void; NotUnit a = ();     functionThatCan'tHandleUnit :: a -> NotUnit a -> Int
16:17:18 <jmcarthur> ^^ unless you use undefined, you can't call that function with first argument ()
16:17:49 <jmcarthur> that is using the new closed type families feature, which i haven't actually used yet and may have used incorrectly
16:17:58 <pentace> What is Void?
16:18:07 <jmcarthur> type Void = forall a. a
16:18:31 <jmcarthur> Void has no values (other than _|_)
16:19:16 <c_wraith> haddock tells me I should document the fact that I'm re-exporting a module. But I can't figure out where to actually *put* that documentation
16:19:17 <jmcarthur> i guess you could package this up with   data AnythingButUnit a = AnythingButUnit (NotUnit a) a
16:19:31 <jmcarthur> ooh, even better:
16:19:38 <jmcarthur> data AnythingButUnit a = AnythingButUnit !(NotUnit a) a
16:19:46 <Redz> my problem is, that i add elements to a tuple. but haskell misses a tuple with only one element. so if i write http://lpaste.net/91504 , definitions collide. i already solved it with onetuple lib, but i hope to find a direct way, with a typeclass.
16:19:58 <jmcarthur> since the NotUnit is strict, you really can't define that unless a is not ()
16:20:47 <roboguy_> Redz: I don't think you can have a tuple with one element
16:20:48 <elliott> (has this been disclaimed as a terrible idea yet?)
16:20:53 <roboguy_> Redz: I think (a) = a
16:21:09 <Redz> roboguy_: thats the problem.
16:21:26 <c_wraith> oh, found it.  section 3.4.1 of the haddock manual
16:21:27 <watermind> jmcarthur: pretty cool
16:21:27 <Redz> but if i can say, a is not a tuple, it might work.
16:22:10 <jmcarthur> ah, i could make this much simpler
16:22:19 <levi> Redz: You might want to take a step back and consider whether your overall approach is a good one.
16:22:47 <Modius> Seeking guidance, at a bit higher level - I'd like to interact with interactive executables (that may ask questions) - maybe via Conduits/whatever ultimately; but first I need to get the data in and out - what call should I research in order to interact with it?   Should it be done at the handle level, or should I be using something higher level?
16:22:59 <jmcarthur> type family NotUnit a where NotUnit () = Void; NotUnit a = a
16:23:10 <jmcarthur> much nicer to use
16:23:29 <hpc> Modius: so what you want is...
16:23:31 <jmcarthur> i still hold that this is useless though
16:23:37 <hpc> your process, A, spawns process B
16:23:48 <hpc> A can write to B's stdin, and can read from B's stdout
16:23:59 <Modius> hpc:  Yeah
16:24:09 <geekosaur> note that this is inherently problematic
16:24:09 <hpc> Modius: take a look at lambdabot's source; they do that for @type
16:24:23 <Modius> hpc:  But I want the program to do its own stdio too to the end-user
16:24:25 <hpc> spawn ghci, run ":t $expr", and read the output
16:24:56 <levi> Modius: Have you looked at System.Process?
16:24:59 <geekosaur> um. how do you propose to distinguish between I/O for the program and I/O for the user?
16:25:02 <elliott> don't look at the source to @type.
16:25:04 <elliott> it's awful.
16:25:20 <hpc> elliott: it's safe to look at, just not use outright
16:25:20 <Modius> levi: Yeah; but'm not sure if I should be using that or something higher, or how
16:25:29 <Modius> And I'm basically a bit of a noob
16:25:31 <hpc> elliott: i borrowed from its implementation for my bot, and it's worked out nicely
16:25:46 <hpc> (translated to perl, which did help a little)
16:26:07 <hpc> Modius: there's a package somewhere on hackage that lets you start a process and get back three Handles
16:26:17 <hpc> and then you can hPutStrLn and hGetLine from them
16:26:26 <geekosaur> I already pointed at System.Process.createProcess
16:26:46 <roboguy_> Redz: you mean something like a Tuple type class? I'm not sure I see how that'd help
16:27:09 <roboguy_> or actually work, for that matter
16:27:39 <Modius> Aah - createProcess *returns* handles
16:27:40 <hpc> that module's gotten fancier than last i checked
16:27:56 <bennofs> @let let remainderDiv m n = until ((< n) . snd) (\(c,x) -> (succ c, invert n <> x)) (0,m)
16:27:56 <lambdabot>  Parse failed: Parse error: EOF
16:28:12 <levi> Modius: Well, yes, you should be using System.Process. There are some examples in the docs: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/process-1.0.1.2/System-Process.html
16:29:45 <levi> After you get the hang of that, you can think about wrapping the lower-level IO with something fancy like Pipes or Conduit, but there's probably no need to at the moment.
16:29:47 <pentace> Does "type family NotUnit a where ..." require a special extension? The "where" is not accepted in my GHC
16:30:05 <geekosaur> LANGUAGE TypeFamilies?
16:30:11 <pentace> No
16:30:23 <bennofs> That sounds like GHC 7.8 closed type families
16:30:27 <bennofs> looks*
16:30:43 <levi> I think that's what was said about it earlier.
16:30:48 <Modius> (Thanks all for the noobness help)
16:31:16 <hpc> pentace: what version of ghc?
16:31:32 <pentace> bennofs: Ah, that seems to be the problem, two single type instances are reported as "conflicting"
16:31:39 <pentace> hpc: 6.12 :S
16:33:43 <geekosaur> ow
16:40:13 <watermind> given some type family F, is it not possible to define class instance A a (F a) where ... ?
16:42:05 <twomashi2> whats the lensey way to do: [(a, b)] -> ([b] -> [c]) -> [(a, c)] ?
16:42:15 <manek> Hi! Do you know if there is any list what can a datatype derive from? I mean: we can derive from Eq, Show etc, but is there a list of all possible derivations?
16:42:40 <edwardk> :t partsOf (traverse._2)
16:42:41 <lambdabot> (Functor f, Traversable t, Field2 a b b1 b1) => LensLike f (t a) (t b) [b1] [b1]
16:42:48 <Rembane> manek: The Prelude is a good start.
16:43:10 <edwardk> > [(1,2),(3,4)] & partsOf (traverse._2) %~ reverse
16:43:12 <lambdabot>   [(1,4),(3,2)]
16:43:22 <roboguy_> manek: it's not really possible to have a complete list of all of those, because you can make your own
16:43:26 <bscarlet> watermind: I'm ignorant but willing to hypothesize anyway: Perhaps instance (b ~ F a) => instance A a b where …?
16:43:46 <roboguy_> manek: they're called "type classes"
16:44:03 <watermind> bscarlet: hmm good point
16:44:07 <elliott> edwardk: yikes
16:44:53 <watermind> bscarlet: illegal
16:44:55 <watermind> :-/
16:45:02 <roboguy_> manek: oh wait, you mean in a "deriving" declaration?
16:45:03 <edwardk> elliott: just answering the question ;)
16:45:04 <manek> roboguy_ : I was thinking that using the "derive" keyword is allowed only for special type classes. If I make my custom typeclass with default implementation, can I use it in "derive" clausure?
16:45:05 <watermind> with  FlexibleContexts
16:45:38 <manek> roboguy_: yes, I mean the ones you can write after datatype declaration like: data X= X deriving(...)
16:47:52 <roboguy_> manek: in Haskell 98, just Eq, Ord, Enum, Ix, Bounded, Read, and Show. GHC has extensions for others: Typeable, Data, Generic, Functor, Foldable and Traversable
16:48:31 <roboguy_> manek: GHC also has an extension called GeneralizedNewtypeDeriving which allows a newtype to use the (essentially) the same definition as the type it is wrapping, as I understand it
16:49:08 <bscarlet> watermind: works for me with FlexibleContext, FlexibleInstances
16:49:14 <manek> roboguy_: Thank you for the GeneralizedNewtypeDeriving! It is very interesting!
16:49:23 <roboguy_> manek: there's more info on deriving here http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/deriving.html
16:49:25 <bscarlet> (FlexibleContexts)
16:49:50 <manek> roboguy_: Do you know if I can make my own (stuff like this - how to call it?) I mean - my ow typeclasses, which I can use in the "deriving" expression?
16:51:05 <dmj``> having issues parsing the Accept line of an http req w/ attoparsec.
16:51:10 <hpaste> dmj pasted “http req parsing and partial” at http://lpaste.net/91505
16:51:36 <roboguy_> manek: I don't *think* so, but I'm not positive. I've never seen a way to do that
16:52:07 <manek> roboguy_: Ok, thank you :)
16:53:04 <mstksg> is there a simple way to uninstall haskell platform/cabal if i built it myself?  i built it to get the latest ghc but now some of my packages won't work with the latest base.
16:53:10 <mstksg> on linux
16:53:55 <roboguy_> mstksg: you mean a cabal package or cabal itself?
16:54:37 <mstksg> cabal itself
16:55:21 <mstksg> or can i just install the lower-level base somehow
16:57:10 <watermind> bscarlet: really? which GHC version?
16:57:11 <geekosaur> base is tied to the compiler
16:57:17 <Modius> result <- hGetContents someHandle       followed by               waitForProcess ..       is this a faux-pas?
16:57:58 <geekosaur> Modius: hGetContents is lazy
16:58:03 <pentace> dmj``: My guess is that "char '\n'" consumes the newline expected by "endOfLine" if there are no parameters
16:58:10 <roboguy_> mstksg: it seems like it might be better to update/uninstall the conflicting packages
16:58:34 <mstksg> roboguy_: the package's latest version requires base <4.6
16:58:53 <bscarlet> watermind: 7.6.3
16:59:01 <mstksg> can i just remove ghc and re-install it to a lower version and leave cabal alone?
16:59:07 <bscarlet> @where lpaste
16:59:07 <lambdabot> http://lpaste.net/new/haskell
16:59:31 <geekosaur> waitForProcess doesn't close the Handle, so in theory that will work
16:59:59 <geekosaur> but there are other things you can do (like closing the Handle before you do anything with result) that will mess you up
17:00:25 <dmj``> pentace: I removed the <* endOfLine, still same
17:00:36 <Modius> Haha - I know it's lazy; but I'm still in the learning phase where the impact on that + surrounding code needs to sink in :)
17:01:11 <dmj`> pentace: when char ',' is evaluated, does it consume input? How do I check for newline without consuming? try?
17:01:36 <geekosaur> as for the waitForProcess itself, whether it's a problem depends on what else you might be doing
17:01:42 <roboguy_> mstksg: what package is it?
17:02:19 <pentace> No, try will consume input if it succeeds
17:02:25 <pentace> dmj`^^
17:03:24 <watermind> bscarlet: nevermind just figured it out
17:03:28 <ClaudiusMaximus> i've got a depth first backtracking search algorithm using MonadPlus [] - now i want to visualize the process by logging each step (including when branches are culled) - best way to do that?
17:03:30 <watermind> bscarlet: it does work
17:04:19 <jmcarthur> ClaudiusMaximus: maybe instead of [] you want to try LogicT IO
17:04:56 <pentace> dmj`: Not sure what's the best way to handle that, but Parsec has a lookAhead function or something like that
17:05:03 <dmj``> ClaudiusMaximus: import Debug.Trace (traceShow) would print during evaluation
17:05:19 <jmcarthur> yeah if all you want is some temporary debug messages then Debug.Trace is fine
17:05:54 <mstksg> roboguy_: virthualenv
17:06:20 <dmj``> pentace: my only other thought is that sepBy requires a comma, which it doesn't..
17:06:21 <mstksg> but i figured that there might be many packages in the future that might have this problem
17:07:09 <mstksg> it's just the first one i ran into
17:08:25 <geekosaur> "virthualenv"? try hsenv
17:08:40 <geekosaur> virthualenv is the ancient first version of hsenv
17:09:19 <applicativ> oh no wonder it needs a better base package
17:09:19 <pentace> dmj``: I can't see the problem here, sorry
17:09:36 <mstksg> geekosaur: oh thanks :)
17:09:40 <applicativ> funny github seems to be down
17:10:11 <dmj``> applicativ: can't ping it
17:10:14 <applicativ> mstksg: if you build the development version of cabal, it has de-luxe sandboxing
17:11:26 <applicativ> git pull is failing too
17:11:29 <geekosaur> some hosting thing seems to be flapping, actually. github and reddit at least are reportedly being affected
17:11:39 <mstksg> applicativ: thanks, i'll look into that
17:12:02 <applicativ> mstksg: I don't know if its best or what, but I'm really into it now that I started using it
17:12:33 <twomashi2> edwardk: that function is ([a] -> [a]) -> t a1 -> t b, not ([a] -> [c]) -> t a1 -> t b
17:12:53 <twomashi2> need: [(a, b)] -> ([b] -> [c]) -> [(a, c)]
17:12:57 <geekosaur> although a report elsechannel claims github's being DDoSed :/
17:13:22 <applicativ> by the darcs underground?
17:13:57 <elliott> https://status.github.com/
17:14:54 <carter> ick
17:15:04 <carter> glad I cloned stuff recently :)
17:15:34 <Sculptor> elliott, ddos attack
17:15:42 <mstksg> i wonder why people would target github
17:15:46 <dmj`> Sculptor: how do u know
17:15:53 <Sculptor> 15:05 UTCWe're currently experiencing a large DDoS attack. The site is experiencing major packet loss and is mostly unavailable. We're working to further mitigate the attack.
17:16:03 <Sculptor> that was earlier
17:16:22 <mstksg> that was last week
17:16:31 <Sculptor> yes
17:17:12 * applicativ conceals his 'darcs revolutionary underground' tatoo
17:17:40 <geekosaur> screw github. it's *git* that's nauseating
17:20:15 <carter> i mostly use source tree as my gui for my dvcs
17:20:22 <carter> so in theory i could easily migrate to mercruial
17:24:24 <Zenol> github down for you?
17:24:43 <Zenol> oh, yes.
17:27:33 <applicativ> does ghci have a 'banner' anymore?
17:28:11 <dmj``> applicativ: not mine
17:28:14 <applicativ> lispy begins his lessons in ghc hacking by recommending we change the banner
17:28:20 <geekosaur> GHCi, version 7.6.3: http://www.haskell.org/ghc/  :? for help
17:28:26 <geekosaur> not the big fancy one any more
17:28:27 <dmj``> 7.6.3
17:28:47 <applicativ> hm, okay, my first hack-ghc act is: to bring back the banner
17:29:06 <applicativ> the banner, for the loss of which, mankind has so long been sighing
17:30:03 * geekosaur is imagining Sam the American Eagle's response to that
17:30:54 <dmj``> pentace: is traceShow the best tool for debugging attoparsec
17:31:07 <dmj`> gg = (,) <$> (string "Accept: " *> (takeWhile1 (/= '/')) <* char '/') <*> (takeWhile1 (/= '\n') <* endOfLine)
17:31:21 <dmj``> pentace: ^ is a quick hack
17:31:33 <pentace> No idea, I've never used it for debugging
17:31:40 <applicativ> ghciWelcomeMsg :: String; ghciWelcomeMsg = "GHCi, version " ++ cProjectVersion ++ ": http://www.haskell.org/ghc/  :? for help"
17:31:41 <Fuuzetsu> dmj`` GHCi is the best tool for debugging attoparsec
17:31:53 <applicativ> definitely not very imaginative
17:32:38 <Fuuzetsu> applicativ: Are you going to put some ASCII art in?
17:33:02 <applicativ> Fuuzetsu: yeah I was thinking of following lispy's advice
17:33:23 <applicativ> note the old ticket http://ghc.haskell.org/trac/ghc/ticket/1378 asking 'how can i turn this nonsense off?'
17:33:27 <Fuuzetsu> What was it? Seems to be out of my buffer.
17:33:47 <applicativ> Fuuzetsu: I was just reading http://dagit.github.io/posts/2013-08-03-getting-started-with-ghc-hacking.html
17:34:13 <pentace> dmj``: What happens if you run mediaRange with "*/*"?
17:34:15 <applicativ> what I cant find now is the old ascii art.
17:34:24 <applicativ> maybe i'll just put hugs' in ;0
17:34:41 <Fuuzetsu> > Easy (less than 1 hour)
17:34:42 <lambdabot>   Not in scope: `less'
17:34:42 <lambdabot>  Perhaps you meant `lens' (imported from Control.Lens)...
17:34:49 <Fuuzetsu> >Opened 6 years ago
17:34:50 <Fuuzetsu> hah
17:35:10 <dmj``> pentace: parse mediaRange (pack "*/*\n")
17:35:13 <FreeFull> :t lens
17:35:18 <dmj``> pentace: Done "" MediaRange {typ = "*", subTyp = "*", param = [Param {name = "", value = 0.0}]}
17:35:29 <FreeFull> :t Control.Lens.lens
17:35:29 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
17:35:41 <hpc> > lagcheck
17:35:43 <lambdabot>   Not in scope: `lagcheck'
17:36:10 <JoeyA> http://www.haskell.org/haskellwiki/Web/Frameworks says Snap is "early-stage software with still-evolving interfaces".  Is this still accurate?
17:36:20 <pentace> dmj``: Is that the expected result?
17:36:22 <Zenol> applicativ: I would like to see your awesome banner once it will be released :D
17:36:31 <dmj`> pentace: yes
17:36:58 <pentace> So the problem has to be in parseAccept
17:37:04 <Fuuzetsu> I'm sure it will make it in for 8.6
17:37:08 <JoeyA> It's said that since October 2010.  I'm wondering if it has stabilized much since then.
17:37:09 <carter> JoeyA nope, its used by a few folks
17:37:17 <Zenol> applicativ: You can't resurect it from git log / git diff?
17:38:27 <carter> yeah… should be in the old commits...
17:38:35 <applicativ> Zenol: I was wondering, but there is a curious mix of history, svn darcs git
17:38:55 <Zenol> not easy :/
17:39:01 <JoeyA> I'm proficient in Haskell, but haven't dug into any web frameworks.  I might try to implement something simple in a few of them.  Snap, Happstack, and Yesod seem to be the most popular.
17:39:20 <carter> JoeyA snap or happstack are good to play with
17:39:28 <JoeyA> What are some key differences between Snap and Happstack?
17:39:35 <carter> different designs
17:39:36 <luite> yesod is teh evil!
17:39:44 <carter> luite: more like teh build hel
17:39:47 <carter> but sam idea
17:40:05 <carter> whenever anyone these days has "cabal hell", its usually attributable to Yesod
17:40:22 <Zenol> wow, it was before 2009?
17:40:25 <applicativ> yesod is very easy to build
17:40:43 <applicativ> cabal sandbox init ; cabal install yesod
17:40:51 <carter> i've had yesod conflict withi itself IN a sandbox, applicativ
17:41:21 * applicativ tries for the 5000th time, to reproduce this hell
17:41:22 <carter> the moment a library can create its own cabal hell in a fresh sandbox is the day i don't recommend it ever
17:41:44 <carter> applicativ: do a sandboxed build of git annex
17:41:45 <JoeyA> Between Snap and Happstack, which one seems simpler?
17:41:53 <carter> happstack probably still has more docs
17:41:58 <carter> the thing is
17:42:02 <danharaj> We use snap and it works.
17:42:03 <carter> they're all librareies
17:42:12 <carter> i did some snap dev last fall
17:42:19 <carter> took me a few days to figure out how web dev works
17:42:22 <carter> but then it was prettynice
17:42:31 * carter doesn't do web dev very often
17:42:36 <trism> applicativ: this the commit? http://ghc.haskell.org/trac/ghc/changeset/41cd72b3545c96c72816afb7b7627f3e744d9ab4/ghc
17:42:47 <applicativ> hm git-annex from hackage or from wherever JoeyA is keeping it
17:42:52 <carter> hackage
17:43:15 <JoeyA> I'm not the Joey that did git-annex
17:43:31 <applicativ> haha
17:43:38 <applicativ> JoeyQ
17:43:51 <JoeyA> Joey Hess, I think
17:43:54 <carter> joey hess right?
17:44:03 <JoeyA> Yup
17:44:08 <applicativ> trism: awesome thanks
17:44:09 <JoeyA> I'm Joey Adams.
17:44:11 <elliott> joeyh: hi
17:44:14 <Zenol> trism> Awesome \ o /
17:44:15 <carter> hello!
17:44:40 <carter> JoeyA snap is really designed to be easy to add "plugins" to
17:44:43 <carter> in a compile time way
17:44:49 <carter> if you look at the core libs
17:44:52 <carter> and the examples
17:45:05 <carter> you define a record type for your application
17:45:21 <carter> which every plugin will interact with
17:46:22 <dmj``> JoeyA: this might interest you, http://memoi.se
17:46:47 <JoeyA> Interesting, thanks
17:47:23 <carter> oh yeah!
17:47:30 <carter> that was a nyc haskelll meetup demo
17:50:18 <JoeyA> "optional high-concurrency backend using the libev event loop library" yeah, the wiki's not up to date.
17:50:54 <carter> yeah, they ahve their new io streams stuff + custom http server stuff pretty nic enow
17:51:27 <JoeyA> Is io-streams by the Snap folks?
17:52:47 <JoeyA> Looks like it (Gregory Collins is named in both snap-server and io-streams).
17:53:05 <JoeyA> Thanks for the input.
17:53:07 <dmj``> JoeyA: unsure, I know enumerator is used by snap though. https://john-millikin.com/software/enumerator/. snap on ubuntu uses epoll, osx doesn't have nice toys like that.
17:53:16 <luite> carter: last time i used the iostreams server it used 6GB memory after 100k reqs and then spewed a huge exception :p
17:53:47 <carter> luite well, was that while it wasn't ready yet?
17:53:48 <JoeyA> dmj``: I'd think it would use GHC 7.0+'s new threaded I/O manager.
17:54:01 <luite> carter: yep, last week or so
17:54:12 <carter> DAMN
17:54:54 <luite> the current version on github still uses enumerator
17:55:08 <carter> ahhh
17:55:28 <carter> luite: hehe, ryannewton seems to have gone and done the atomic primops work i was going to do
17:55:35 <carter> though github is down, so i can't tell
17:55:52 <luite> oh github sems to work from heren
17:55:54 <luite> here
17:55:56 <carter> whcih is great, means less work for me
17:55:57 <luite> unlike cpan
17:56:13 <luite> i'm having some ghc build problems :(
17:56:37 <bennofs> cpan and github work from here :D
17:56:41 <danharaj> luite: what are you building ghc on?
17:58:11 <luite> danharaj: ubuntu, but the trouble is that DynFlags suddenly depends on lots more modules after i make some changes, and i have no idea why
17:58:20 <danharaj> luite: :
17:58:27 <danharaj> oh you are *hacking* on GHC that's different :P
18:00:13 <luite> danharaj: it wouldn't be a problem if windows didn't have this annoying dll symbols limit. i could just add all the DynFlags dependencies to this dll but then it would get too many symbols
18:00:15 <danharaj> edwardk: I have some breathing room. tell me everything you know about kan lifts in haskell :P
18:00:24 <edwardk>  =)
18:00:26 <danharaj> luite: Windows is the albatross around GHC's neck.
18:00:52 <edwardk> i wrote a lot of it up in the kan-extensions haddocks in HEAD
18:00:56 <edwardk> including the derivation of right kan extensions from their (co)universal property
18:00:59 <danharaj> edwardk: also on a side note, is there a name for a fold that is just a catamorphism that also takes a distributive law F T -> T F for passing down F-arguments?
18:01:07 <danharaj> edwardk: ok cool!
18:01:25 <edwardk> where does T come in?
18:01:50 <edwardk> g_cata is a catamorphism built with an arbitrary distributive law
18:01:59 <danharaj> edwardk: T is the thing being folded.
18:02:12 <danharaj> well, Mu T would be the thing being folded.
18:02:41 <edwardk> all the other cata variants are just tricks of using various distributive laws for some base comonad of effects
18:02:55 <danharaj> edwardk: ah, what does the comonadicity get you?
18:03:56 <edwardk> the ability to implement it. =P
18:03:58 <edwardk> g_cata k g = extract . c where c = liftW g . k . fmap (duplicate . c) . outF
18:04:03 <edwardk> note the extract and duplicate
18:04:04 <danharaj> ah
18:05:12 <edwardk> basically the trick is using the distributive law to move the base functor f over the comonad w
18:05:33 <edwardk> then you can see that g_cata is just a cata followed by extracting from the final comonadic result
18:05:57 <c_wraith> so, every time I upload to hackage recently, I don't get a response back from the server.  But it still accepts the upload.  What's up with this?
18:06:35 <edwardk> similarly with an anamorphism you use a distributive law to 'push the monad away' so you never have to discharge its obligation
18:06:43 <danharaj> hm
18:07:25 <edwardk> likewise with he comonad you pull it from 'infinitely far down the source adt' so you don't have to create it in the first place
18:10:36 <danharaj> edwardk: actually I think I am confused about what I wanted to ask. I was thinking of, like say you have an argument at the top-level you want to pass in as a parameter down the structure when you fold it. Then you'd want something like (forall b. (a, t b) -> t (a, b))
18:18:52 <mstksg> i have a cabal file that specifies multiple executables ... is there any way to run cabal install so that it only builds one of them?
18:20:43 <c_wraith> mstksg: only if you use flags that control whether a buildable: false line shows up in their segment of the file
18:22:28 * applicativ has installed yesod for the 5001st time, still never having used it...
18:22:49 * applicativ 's secret formula:  
18:22:52 <applicativ> cabal update; mkdir yesody; cd yesody; cabal sandbox init; cabal install yesod -j3
18:23:29 * hackagebot storable-static-array 0.4.1.0 - Statically-sized array wrappers with Storable instances  for FFI marshaling  http://hackage.haskell.org/package/storable-static-array-0.4.1.0 (CarlHowells)
18:28:29 * hackagebot llvm-general 3.3.6.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.6.0 (BenjaminScarlet)
18:33:18 <JoeyA> Does "cabal install" look for sandbox directories (those with a .cabal-sandbox directory), and if none are found, resort to whatever database it normally uses?
18:33:30 * hackagebot llvm-general 3.2.6.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.6.0 (BenjaminScarlet)
18:33:33 <danharaj> cabal has sandboxes now??
18:33:37 <geekosaur> in HEAD
18:34:37 <danharaj> hmm
18:35:22 <JoeyA> I guess so.  cabal install network inside the sandbox directory starts with text, but outside it doesn't (since I already have the text package installed).
18:43:51 <c_wraith> what's the flag to dump RULES firings?
18:46:07 <c_wraith> hmm.  it's -ddump-simpl-stats  .  Was the space savings by leaving out that one letter worth it?
18:46:39 <Saizan> which letter?
18:46:51 <danharaj> e
18:47:28 <Saizan> simpl is short for simplifier i think
18:47:34 <cdk> c_wraith: i always took it to be short for simplified, not simple. I have nothing to back up that claim
18:48:27 <danharaj> that makes sense
18:49:55 <c_wraith> oh, I think it is simplifier
18:52:30 <c_wraith> aaargh.  Ok.  This doesn't optimize if I leave it polymorphic.  the necessary RULES pragma doesn't trigger because the optimizer doesn't know the types will always work out.
18:52:46 <c_wraith> That's fine, I'm ok with that.  That's why the SPECIALIZE and INLINEABLE pragmas exist
18:53:18 <c_wraith> Except for the fact that I can't apply them, because the class I'm implementing parts of doesn't allow it.
18:54:20 <c_wraith> So I can either create a bunch of one-off instances that are barely different except they are concrete enough to allow the RULES to fire
18:54:33 <c_wraith> Or live without that optimization
18:59:20 <stolaruk> What does it mean when a function signature ends with "-> m ()", where "m" is a monad? What sort of values can qualify as type "m ()"?
18:59:38 <c_wraith> lots and lots of them.
19:00:08 <stolaruk> Is the () like a wildcard?
19:00:08 <geekosaur> `return ()`, many IO actions.
19:00:20 <geekosaur> no, it's a sort of null value
19:00:28 <geekosaur> :t putStrLn
19:00:29 <lambdabot> String -> IO ()
19:00:48 <Saizan> stolaruk: () is also called unit, it's the type with a single defined value also called ()
19:00:53 <geekosaur> ^^ it doesn't return anything useful, but it must return *something*, so it uses ()
19:01:30 <stolaruk> Specifically I'm looking at the "guard" function. "guard False = mzero", where "mzero" is just an empty list when we are talking about the list monad. So how is an empty list of type "m ()">
19:02:21 <geekosaur> list is irrelevant to guard precisely for that reason
19:03:20 <BMeph> stolaruk: List is a Monad.
19:03:27 <stolaruk> yep
19:03:28 <Saizan> ?type []
19:03:29 <lambdabot> [a]
19:03:53 <Saizan> ?type ([] :: [Int])
19:03:53 <lambdabot> [Int]
19:03:57 <Saizan> ?type ([] :: [()])
19:03:58 <lambdabot> [()]
19:03:59 <geekosaur> oh, right, so [] is a perfectly valid m (). duh
19:04:00 <BMeph> :type []
19:04:20 <stolaruk> geekosaur: I don't see it.
19:04:25 <BMeph> ?type []
19:04:26 <lambdabot> [a]
19:04:43 <Saizan> stolaruk: [] is fine for every element type, since it doesn't contain any
19:04:49 <geekosaur> stolaruk, as Saizan demonstrated
19:05:01 <Modius> What's the difference/relationship between doing the cleanup in a Conduit via addCleanup, vs something with runResourceT?
19:05:03 <geekosaur> [] is a perfectly valid value in m () for m = List
19:05:12 <geekosaur> the type is [()], the value is []
19:06:19 <stolaruk> oh ok so in this case it would be a list containing a unit, but in this case there just aren't any units for the list to contain.
19:06:33 <geekosaur> it would be a list *of* units, but an empty list thereof, yes
19:07:02 <stolaruk> so the empty list is polymorphic?
19:07:07 <geekosaur> yes
19:07:10 <geekosaur> :t []
19:07:11 <lambdabot> [a]
19:07:13 <Zenol> Non fancy arrow to browse HaTex parsing tree? :(
19:07:19 <stolaruk> yeah I get it now, thanks!!
19:07:20 <geekosaur> `a` there can be any type
19:07:22 <stolaruk> awesome
19:33:53 <cschneid> given this bit of code, I'd like to collapse lines 4 & 5 into one call. How do I arrange it to not need the <- binding? (https://gist.github.com/cschneid/03d7ba1d74cddc14fbd1)
19:35:11 <Zenol> @pl \l -> renderAppend [l]
19:35:14 <lambdabot> renderAppend . (: [])
19:35:14 <lambdabot> optimization suspended, use @pl-resume to continue.
19:35:14 <ParaSa1lin> i dont see socket being used anywhere
19:35:31 <Zenol> : [], of course...
19:35:37 <geekosaur> that makes no sense to me, yeh, socket's not being used
19:35:49 <ParaSa1lin> connectSocket req >> mainLoop req
19:35:53 <geekosaur> unless mainLoop is supposed to take the socket as a parameter instead of req?
19:35:54 <pnielsen> cschneid: if you actually want to do mainLoop socket, then connectSocket req >>= mainLoop
19:35:56 <geekosaur> or maybe with?
19:36:29 <geekosaur> if that was supposed to be ```mainLoop socket``` then it's connectSocket req >>= mainLoop
19:36:30 <pnielsen> or mainLoop =<< connectSocket req
19:36:43 <ParaSa1lin> connectSocket does not need the return req at the end
19:36:46 * geekosaur is slow
19:36:51 <ParaSa1lin> just make it M ()
19:37:31 <cschneid> heh, yes - it was supposed to be socket on 5
19:37:51 <TIHan> I have never written any Haskell, and I'm about to try it.
19:38:30 <pnielsen> :t (>>=)
19:38:30 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:38:33 <pnielsen> :t (>>)
19:38:34 <lambdabot> Monad m => m a -> m b -> m b
19:38:57 <pnielsen> >> is like >>=, but discards the return value
19:39:00 <applicativ> TIHan: good luck!
19:39:25 <TIHan> Thanks! :)
19:39:42 <cschneid> ParaSa1lin: trying to get rid of the `return req`, and keep getting compile errors: Couldn't match expected type `()' with actual type `Socket Req'
19:39:47 <ChongLi> TIHan: you're in the right place
19:40:02 <pnielsen> cschneid: add return () at the end
19:40:06 <cschneid> ParaSa1lin: gist updated: this doesn't compile with that error: https://gist.github.com/cschneid/03d7ba1d74cddc14fbd1
19:40:09 <cschneid> ahh, I see
19:40:24 <cschneid> gotta call return on something out of the end of the function?
19:40:25 <pnielsen> cschneid: connect returns a request, so that's the value returned by your function
19:40:41 <pnielsen> cschneid: if you don't return unit (()), then the return value is the return value of the last action
19:41:00 <pnielsen> (return unit, or anything else)
19:41:01 <TIHan> I noticed, as far as what I have been noticing, Haskell is definitely picking up some speed.
19:41:28 <ParaSa1lin> cschneid, s/>>=/>>/
19:41:34 <ParaSa1lin> and it will type check
19:41:40 <ParaSa1lin> @ty (>>)
19:41:41 <lambdabot> Monad m => m a -> m b -> m b
19:41:44 <ParaSa1lin> @ty (>>=)
19:41:45 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:42:20 <flebron> Hi. Why is Rational not an instance of Fractional?
19:42:23 <cschneid> ParaSa1lin: correct, that typechecks. Is that better/worse than two lines though? :)  https://gist.github.com/cschneid/03d7ba1d74cddc14fbd1
19:42:48 <pnielsen> better as long as you know haskell, but I'm confused about what you want to do
19:42:52 <pnielsen> a more complete example would be helpful
19:43:08 <TIHan> Ah, reading haskell for great good mentions this channel. :)
19:43:14 <flebron> (In general, is there a typeclass for "Field"?)
19:43:16 <cschneid> pnielsen: let me paste whole thing, one sec
19:43:19 <applicativ> flebron: it is but the instance is in Data.Ratio or am I in a muddle
19:43:36 <ParaSa1lin> cschneid, that should work?
19:43:39 <cschneid> pnielsen: https://gist.github.com/cschneid/03d7ba1d74cddc14fbd1 -- idea is that main does setup, then mainloop runs forever saying hi
19:43:59 <cschneid> ParaSa1lin: it does work, yes. but now stylistically - is it better/worse than a two line version
19:44:19 <applicativ> flebron: you shouldn't have to import it since it's carrying its instance with it
19:44:26 <ParaSa1lin> getting rid of redundant code is good style
19:44:47 <flebron> applicativ: That's weird... how could I check that indeed Rational is an instance of Fractional?
19:44:52 <flebron> (From GHCi)
19:45:02 <geekosaur> :info Rational
19:45:11 <carter> flebron you can divide one rational by another
19:45:12 <ofan> TIHan: haskell is fast, I think the llvm backend of ghc could achieve even better performance
19:45:13 <pnielsen> cschneid: I guess what I'm confused about is the type of connect. Don't you want to use the return value of connect? In that case, you want >>= mainLoop, not >> mainLoop req, which discards the new value (socket) and reuses the old req
19:45:37 <flebron> geekosaur: That just tells me "type Rational = Ratio Integer 	-- Defined in `GHC.Real'"
19:45:44 <TIHan> ofan, that is what I remember reading. Currently, I'm very passionate about F#, but Haskell is attracting my attention.
19:45:45 <applicativ> flebron: yeah i think it wont show up with :i Rational or :i Fractional but its there
19:45:50 <cschneid> pnielsen: well, it's a C binding, I did try it and it worked. So I assume it's not strictly pure in this area
19:45:51 <carter> flebron yes
19:46:05 <geekosaur> hm, thought that showed instances
19:46:15 <TIHan> Mainly, I've been very passionate about C and F#.
19:46:20 <applicativ> as carter says, I can let z::Rational; z=1 in z/z  for example
19:46:37 <geekosaur> :info Fractional shows it
19:46:44 <carter> whats this about llvm?
19:46:45 <applicativ> geekosaur: really?
19:47:00 <geekosaur> (but it doesn't show the type alias Rational, it shows Integral a => Ratio a
19:47:06 <carter> yeah
19:47:08 <geekosaur> (Rational is Ratio Integer)
19:47:11 <carter> yeah
19:47:43 <TIHan> ofan: I'm in the process of re-writing Quake3 in F#. Do you think Haskell would be a better choice?
19:47:48 <carter> TIHan yes
19:47:52 <cschneid> pnielsen: but yeah, I think it's clearer that the connectSocket call returns a new version of the passed in socket, which is then used by mainLoop
19:47:59 <carter> because  F# can't do simd :)
19:48:05 <ofan> TIHan: wow are you doing that?
19:48:08 <carter> or cheap FFI
19:48:14 <carter> did carmack inspire you?
19:48:16 <carter> :)
19:48:16 <pnielsen> cschneid: if that works/is how it works, then yeah, definitely
19:48:16 <ofan> carter: because it's managed?
19:48:23 <TIHan> Yes. I'm about halfway finished with tr_main.c at the moment.
19:48:30 <flebron> hrmph. that's odd. I have fake :: (Eq a, Fractional a) => [a] -> [a]; fake = const undefined; fake' = reverse . map negate . init . fake; and :t fake' is [Double] -> [Double]... when am I losing generality?
19:48:30 <TIHan> It works on top of mono now.
19:48:33 <cschneid> pnielsen: well, works either way, might as well pretend that it's a pure function :)
19:48:36 <carter> cool
19:48:48 <carter> TIHan both are great
19:48:50 <TIHan> Everything is purely functional, but I keep thinking about Haskell.
19:49:14 <TIHan> I guess the purity of it is what makes it sound more appealing.
19:49:23 <carter> TIHan you should hang out on #haskell-game
19:49:32 <carter> you can do imperative bits if needed though
19:49:57 <cschneid> pnielsen, ParaSa1lin, thank you both for your help - it's hard to make the jump from barely knowing a language to doing it idiomatically :)
19:50:07 <geekosaur> flebron: monomorphism restriction applied to fake'
19:50:24 <flebron> geekosaur: 1) Aaaarghhhhhh. 2) Where does [Double] come from? O.o
19:50:35 <geekosaur> defaulting
19:50:43 <flebron> D: D: D:
19:50:50 <geekosaur> applied to Fractional a, I think
19:51:04 <applicativ> are you inside ghci flebron ?
19:51:04 <ofan> TIHan: is there a website of the quake3 in F# project?
19:51:09 <flebron> I guess I don't understand why the monomorphism restriction is biting me, then.
19:51:21 <flebron> applicativ: The code is typed in a .hs, I'm :t'ing in GHCi.
19:51:25 <geekosaur> because fake' has no signature and no parameters
19:51:46 <geekosaur> (none specified, that is)
19:52:21 <pnielsen> cschneid: well, it wasn't the most clear-cut example! You got it, and welcome!
19:52:38 <applicativ> it has a few downsides, but with :set -XNoMonomoblahah
19:52:44 <applicativ> in your .ghci you get aa :: Fractional a => a
19:52:56 <applicativ> for aa = 1.1 in an .hs file
19:52:56 <cschneid> pnielsen: well, unclear code is all I can make :)  I am really loving the change of pace from ruby this is presenting :)
19:53:23 <geekosaur> so the monomorphism restriction kicks in, and it uses defaulting (default (Integer, Double)) to get Double as the type given the Fractional constraint
19:54:22 <flebron> what is an upside of the restriction?
19:54:37 <applicativ> flebron: sharing is preserved
19:54:42 <applicativ> or that's one thing
19:54:43 <geekosaur> increases sharing in the common case
19:55:07 <geekosaur> but many people see it as not enough of an upside, and choose to disable it
19:55:15 <flebron> well, in this case I'm gaining nothing by partially sharing fake', right?
19:55:46 <applicativ> flebron: you might try going through the simple debugger examples in http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-eval-whnf
19:56:02 <applicativ> with and without NoMonomorphismRestriction on
19:56:39 <applicativ> everything goes to pieces with NoMonomorphismRestriction, which I have in my .ghci file, so I freaked out
19:56:49 <applicativ> but it's really a perfect illustration of lost sharing
19:57:31 <applicativ> once you figure out that's whats behind it
19:58:37 <geekosaur> moral: it's complicated and there really isn't a clear consensus that the MMR has outlived its usefulness
19:58:44 <scshunt> what do you mean by sharing, here?
19:59:05 <geekosaur> sometimes it's the MMR that is nonintuitive, sometimes it's its lack.
19:59:11 <applicativ> scshunt: well if you go through those four or five lines of Simon M. you see immediately
19:59:23 <applicativ> scshunt: you define something like x = [1..10]
19:59:29 <applicativ> this could be any Num
19:59:50 <applicativ> then you ask ghci whats take 2 x
20:00:12 <applicativ> then you ask the debugger what it knows of x, and it's the first two elements now
20:00:13 <elliott> another upside is that it keeps inferred types simpler
20:00:27 <applicativ> I really like the MMR strangely
20:00:48 <applicativ> NoMMR is good for figuring out what the typechecker thinks, then you go in and say what you mean
20:01:47 <applicativ> with NoMMR scshunt ghci keeps forgetting what it figured out about x
20:02:31 <applicativ> it's like alzheimers
20:04:18 <Zenol> @pl \l -> case l of _ -> True
20:04:18 <lambdabot> (line 1, column 17):
20:04:18 <lambdabot> unexpected '_'
20:04:18 <lambdabot> expecting variable, "(", operator or end of input
20:04:27 <cschneid> what should I look at if I want to run a bit of code every minute on the minute?  (modulo any OS thread scheduling that may screw me up.)
20:04:37 <Zenol> @pl \l -> case l of ; _ -> True
20:04:37 <lambdabot> (line 1, column 17):
20:04:37 <lambdabot> unexpected ';'
20:04:37 <lambdabot> expecting variable, "(", operator or end of input
20:05:26 <Zenol> :t \l -> case l of ; _ -> True
20:05:27 <lambdabot> t -> Bool
20:05:49 <Zenol> no @pl for such expressions? :(
20:06:38 <CADD> @pl (\l -> case l of ( \_ -> True))
20:06:41 <lambdabot> flip (flip case of) (const True)
20:06:42 <lambdabot> optimization suspended, use @pl-resume to continue.
20:06:45 <enthropy> cschneid: something like     forkIO $ forever $ do threadDelay 1000; x
20:06:59 <enthropy> but maybe that number is microseconds
20:07:00 <CADD> @@ Zenol @pl (\l -> case l of ( \_ -> True))
20:07:04 <lambdabot>  Zenol
20:07:04 <lambdabot>  flip (flip case of) (const True)
20:07:04 <lambdabot>  optimization suspended, use @pl-resume to continue.
20:07:24 <CADD> Zenol: not sure if its the same thing, worth a try
20:07:43 <CADD> :t flip
20:07:43 <lambdabot> (a -> b -> c) -> b -> a -> c
20:09:59 <Zenol> CADD: Parse error on input of
20:10:24 <CADD> Zenol: hmm?
20:10:28 <geekosaur> that @pl is garbage
20:10:34 <geekosaur> it doesnt understand case syntax
20:11:18 <CADD> geekosaur: i guessed as much. it didnt seem right
20:11:39 <geekosaur> as it turns out, there is a lambdacase extension, but @pl doesn't know it
20:12:07 <enthropy> it doesn't know about -XTupleSections either, or -XViewPatterns
20:12:40 <CADD> oh darn, and both of those extensions are very nice..
20:12:45 <Zenol> Actualy, what I would like to write is \l -> case l of ASpecificConstructor _ -> False ; _ -> True. No way to write it something like wasBuildWith ASpecificConstructor ?
20:13:15 <enthropy> Zenol: what's wasBuildWith?
20:13:34 <Zenol> enthropy: the function I'm looking for
20:13:40 <jmcarthur> what is its type?
20:13:43 <CADD> to be honest, i think that the lambda notation would probably be clearer than the pl version in this case
20:13:44 <Zenol> enthropy: if such a thing exists.
20:13:51 <enthropy> maybe you're looking for   \l -> case l of ASpecificConstructor {} -> False ; _ -> True -- doesn't care how many arguments ASpecificConstructor takes
20:14:20 <Zenol> oh, nice, I didn't now that.
20:14:26 <enthropy> Zenol: there is   Data.Data.toConstr
20:14:34 <jmcarthur> i kind of wish we could use partially applied constructors in patterns, a kind of eta-reduced form of pattern matching if you will
20:14:56 <enthropy> which only works if you have  deriving (Data)... which in turn needs some extensions
20:14:57 <jmcarthur> foldr f z = \case [] -> z; (:) -> f
20:15:49 <enthropy> > toConstr (Just 2) == toConstr (Just 5)
20:15:50 <lambdabot>   True
20:15:58 <jmcarthur> :t toConstr
20:15:59 <lambdabot> Data a => a -> Constr
20:16:06 <jmcarthur> :i Constr
20:16:10 <jmcarthur> :(
20:16:13 <geekosaur> no :i
20:16:36 <jmcarthur> i always forget
20:17:13 <Zenol> Ohhh
20:17:21 <jmcarthur> > toConstr (Just 2)
20:17:22 <lambdabot>   Just
20:17:50 <Zenol> toConstr d == toConstr ASpecificConstructor something for example so?
20:18:00 <enthropy> you're probably better of pattern matching on Just{} or Just _, since it's tricky to create values of type Constr
20:18:01 <jmcarthur> would be nice if that Show instance would actually show everything...
20:18:13 <Zenol> (== toConstr ASpecificConstructor undefined) . toConstr ?
20:18:16 <geekosaur> note however that it's a representation, not actually `Just` as a value
20:18:18 <enthropy> without using toConstr of course
20:19:10 <Zenol> enthropy: Ok, but it's good to know that such a thing exists :)
20:19:20 <jmcarthur> Zenol: not that i've never had to do this, but in my experiences, having to pattern match just to get to the constructor and ignore all the fields is often an antipattern
20:20:18 <jmcarthur> Zenol: it often, but not always, indicates an opportunity to generalize a bit by dropping some information earlier
20:20:44 <jmcarthur> Zenol: e.g. if i'm passing around a Maybe Int but find that i only every care whether it's Just or Nothing, maybe it should just be a Bool instead
20:20:50 <jmcarthur> *ever care
20:21:12 <meretrix> Is there an efficient way to create a decreasing sequence, something like [100..1]?
20:21:18 <meretrix> > [100..1]
20:21:19 <lambdabot>   []
20:21:23 <jmcarthur> > [100,99..1]
20:21:24 <lambdabot>   [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,7...
20:21:28 <meretrix> ah!
20:21:29 <meretrix> thanks
20:21:34 <jmcarthur> meretrix: i assume by efficient you mean terse
20:21:52 <meretrix> Well I just mean not having to use "reverse".
20:22:05 <jmcarthur> yeah that wouldn't be as efficient
20:22:42 <jmcarthur> even without enumFromThenTo (the function that desugars to), you could always just roll your own similar function. you don't have to do the inefficient thing
20:23:00 <jmcarthur> > [100,99..1] == enumFromThenTo 100 99 1
20:23:01 <lambdabot>   True
20:23:55 <CADD> :src enumFromTheTo
20:24:17 <jmcarthur> @src enumFromThenTo
20:24:17 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
20:24:23 <jmcarthur> ^^ it's a method of a type class
20:24:25 <CADD> :src enumFromThenTo
20:24:36 <CADD> ah, thanks
20:24:36 <jmcarthur> :src doesn't do anything
20:24:50 <CADD> right, yeah i forgot its @ instead of :
20:32:03 <monochrom> you have to say which instance. and hope that lambdabot has it. and I forgot the syntax
20:33:19 <geekosaur> @src Enum
20:33:19 <lambdabot> class  Enum a   where
20:33:19 <lambdabot>     succ                     :: a -> a
20:33:19 <lambdabot>     pred                     :: a -> a
20:33:19 <lambdabot>     toEnum                   :: Int -> a
20:33:19 <lambdabot>     fromEnum                 :: a -> Int
20:33:21 <lambdabot> [3 @more lines]
20:33:25 <geekosaur> @more
20:33:25 <lambdabot>     enumFrom                 :: a -> [a]
20:33:25 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
20:33:27 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
20:33:41 <geekosaur> @src Int enumFromThenTo
20:33:41 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:34:12 <elliott> monochrom: hah, syntax
20:34:19 <elliott> there is no syntax, just string keys. there is no consistency.
20:34:34 <monochrom> yeah, that too
20:42:02 <c_wraith> I dislike that I can't specialize functions that are part of a type class unless the class declares the function to be INLINEABLE. :(
20:44:01 <dmj`> pentace: you here?
20:44:07 <dmj`> @seen pentace
20:44:07 <lambdabot> pEn7ace
20:44:16 <c_wraith> seen is elite now
20:44:16 <c_wraith> nice
20:44:27 <c_wraith> preflex: seen pentace
20:44:35 <c_wraith> and preflex is absent
20:45:12 <c_wraith> heh.  thanks mauke
20:45:25 <c_wraith> preflex_: seen pentace
20:45:47 <applicativ> @seen c_wraith
20:45:47 <lambdabot> C_\/\/raItH
20:46:04 <c_wraith> yeah, lambdabot decided @seen means @elite
20:46:12 <CADD> lol, wat?
20:46:17 <dmj`> @elite pentace
20:46:17 <lambdabot> p3NtACe
20:46:21 <dmj`> @seen pentace
20:46:21 <lambdabot> PeN7aCE
20:46:23 <preflex>  pentace was last seen on #haskell 3 hours, 8 minutes and 27 seconds ago, saying: So the problem has to be in parseAccept
20:46:27 <geekosaur> I suspect there's an alias to @elite called @leet
20:46:48 <geekosaur> and @seen would therefore be within its edit distance
20:46:50 <applicativ> @leet geekosaur
20:46:51 <lambdabot> 933kO5aur
20:47:01 <applicativ> very leet indeed
20:47:43 <CADD> @leet CADD
20:47:43 <lambdabot> c4DD
20:47:44 <CADD> lol
20:47:46 <CADD> @leet CADD
20:47:46 <lambdabot> C4dD
20:47:51 <CADD> no suprise there
20:48:38 * hackagebot storable-static-array 0.5.0.0 - Statically-sized array wrappers with Storable instances  for FFI marshaling  http://hackage.haskell.org/package/storable-static-array-0.5.0.0 (CarlHowells)
20:50:20 <cschneid> for number literals, is there a way to include "commas" to show large numbers? ie, I have a literal 1 million, in Ruby I can do 1_000_000 to make that clear. Does haskell work like that?
20:50:42 <geekosaur> nope
20:51:02 <Modius> Can anyone tell me how to change normal Conduit code constructs to run under runResourceT?
20:51:15 <CADD> cschneid: http://stackoverflow.com/questions/3752898/haskell-format-number-with-commas
20:52:04 <cschneid> CADD: not quite. I want the actual value in my code. Just a function `constant = 1000000` is hard to read, and I just had a bug where I was off by one zero.
20:52:25 <cschneid> in some other languages, there are ways to write the same integer constant with underscores or similar.
20:52:32 <dmj`> preflex: ha, how'd ya know, parseAccept was the issue, the convoluted spec being the other
20:54:37 <enthropy> cschneid: there's -XOverloadedStrings, which could let you write  "1_000_000" and have it do the same thing as 1000000
20:54:41 <Cale> You could write constant = 10^6
20:54:45 <carter> that too
20:54:51 <cschneid> Cale: hmm, I do like that.
20:55:39 <cschneid> enthropy: cool - I need to look into overloaded strings, just for bytestring vs. normal [Char] type strings.
20:55:44 <cschneid> ie, what the default is
20:56:28 <enthropy> there isn't an instance IsString Integer where fromString = read . filter (/='_')
21:10:00 * applicativ has taken lispy's advice and repaired ghci's banner http://sprunge.us/AYif
21:10:30 <roboguy_> huh, I guess John Carmack recently rewrote Wolfenstein 3D in haskell for fun
21:10:46 <roboguy_> that's pretty cool
21:10:59 <geekosaur> except arguably it should cite h2010
21:11:07 <applicativ> geekosaur: ah yes
21:11:08 <geekosaur> except by default it's neither h98 nor h2010 :p
21:11:32 <applicativ> already my patch needs patched
21:12:32 <applicativ> "If you get this far, you’ll have made it further than most haskellers!"
21:12:48 * applicativ beams with the dubious pride
21:13:12 <applicativ> "At this point, you’ll have the skills and knowledge necessary to fix bugs"
21:13:15 * applicativ wonders
21:20:42 <edwardk> danharaj: just make it an arg to the function you are using to fold with
21:21:24 <edwardk> cata (foo someArgument)
21:27:24 <h4199> "At this point, you’ll have the skills and knowledge necessary to fix* bugs"
21:27:32 <h4199> *create
21:30:48 <applicativ> h4199: yes, I'm sensing that already
21:32:39 <h4199> What is the patch approval and integration process for ghc?
21:35:28 <johnw> h4199: #ghc may be better for that question
21:36:21 * applicativ should join #ghc now that he's followed lispy's tutorial ;)
21:39:30 <h4199> ghc is more populated than I expected it to be at this time, a healthy sign :)
21:42:25 * applicativ may have the wrong attitude for ghc bug repair
21:42:34 <applicativ> "#7687ghc panic on TH and deriveJSON" -- well, what did you expect?
21:43:01 <dmj`> what is lispy's tutorial? is it on ghc?
21:43:03 <c_wraith> I expect GHC to not panic. :P
21:43:25 <h4199> dmj: check out /r/haskell
21:43:30 <applicativ> dmj`: http://dagit.github.io/posts/2013-08-03-getting-started-with-ghc-hacking.html
21:44:10 <applicativ> dmj`: I managed to do the exercize, so I'm already studying the trac
21:44:16 <applicativ> watch out everyone
21:45:19 <dmj`> ah, intellesting
21:49:43 <dmj`> applicativ: all 296 pages of it?
21:50:43 <applicativ> oh I just read lispy's post and reverted the ghci banner, as he suggested we do http://sprunge.us/AYif
21:52:37 <dmj`> applicativ: ah, is https://github.com/ghc/ghc the latest? here goes nothin
21:53:24 <applicativ> yes, that's my understanding. there's a readme.md if you havent built it before
21:53:39 * hackagebot mighttpd2 2.8.7 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.8.7 (KazuYamamoto)
22:17:52 <cschneid> Can somebody help me transform this use of Maybe into monadic form (from case statement form).
22:18:07 <cschneid> https://gist.github.com/cschneid/a2cdc6d22b257e4bd595
22:18:30 <cschneid> I've tried lots of different forms, but it never passes compile right.
22:18:57 <johnw> are you saying that code does not work?
22:19:01 <cschneid> Just assume that the value the case function has is a Maybe YamlLight, and whatever comes out of that needs unStr and unpack run on it before finally being returned as a maybe String
22:19:11 <johnw> you don't need the case statement
22:19:19 <cschneid> johnw: what's pasted works. I'd like to transform it into a case-statement-free form
22:19:19 <johnw> x <- unStr <$> lookupYL (YStr $ pack val) config
22:19:36 <johnw> you may need "join . unStr"
22:19:40 <johnw> in fact, you will
22:19:46 <johnw> and then:
22:20:03 <johnw> unpack . join . unStr <$> lookupYL (YStr $ pack val) config
22:20:08 <johnw> should boil it all down to one line
22:20:23 <johnw> oh, no, unpack <$> join
22:20:27 <johnw> since join might return Nothing
22:20:58 <johnw> another alternative:
22:21:18 <johnw> unpack <$> unStr =<< lookupYL (YStr $ pack val) config
22:21:46 <johnw> though you may need parens around the whole =<< side of the expression
22:22:23 <cschneid>   x <- unpack <$> unStr =<< (lookupYL (YStr $ pack val) config)
22:22:27 <cschneid> has an error
22:22:32 <johnw> drop the "x <-"
22:22:34 <johnw> you don't need it anymore
22:22:40 <cschneid> ahh, sorry
22:22:41 <johnw> the "unpack ..." is the entire body of the function now
22:23:00 <cschneid> Couldn't match expected type `Maybe String' with actual type `[Char]'
22:23:01 <johnw> in fact, you can get this smaller too
22:23:07 <cschneid> is still the error though .
22:23:17 <johnw> fmap unpack . unStr <=< lookupYL (YStr $ pack val)
22:23:39 <johnw> oh, the parens weren't what I meant up above
22:23:41 <johnw> I had meant this:
22:23:48 <johnw> unpack <$> (unStr =<< lookupYL (YStr $ pack val) config)
22:24:08 <cschneid> ok, that type checks.
22:24:10 <johnw> if you use the fmap .. <=< version, you 'll need to omit the "config" parameter
22:24:19 <johnw> not the type, just the name
22:24:28 <cschneid> so the <$> fmap hoists the unpack function into Maybe. (right?)
22:24:33 <johnw> yes
22:24:39 <cschneid> then runs it against the whole Maybe return of the unstr..... stuff
22:24:52 <johnw> to use the Maybe monad, the return value of every expression in the Monad must be a Maybe value
22:25:01 <johnw> so we either need to chain Maybe functions, or lift non-Maybe functions
22:26:01 <cschneid> ok, that makes sense. so the vals on the right there (unStr and lookupYL) do return Maybe whatever, but unpack didn't
22:26:17 <cschneid> so fmap was used to pull it up into Maybe, and hence the whole return value is what we expected.
22:26:35 <johnw> exactly
22:26:37 <johnw> you've got it!
22:26:52 <johnw> and once you're there, you can use juts composition
22:27:11 <cschneid> johnw: what's <=< do? (rather, let me go read docs, I'll ping you if I need help interpreting)
22:27:24 <johnw> either monadic composition between Maybe-returning functions (<=<), or regular composition + fmap for non-Monadic functions (fmap unpack .)
22:27:41 <johnw> f = g <=< h === f x = g =<< h x
22:28:35 <cschneid> ahh, so it ties them together without the need for the explicit 'x' argument?
22:28:39 <johnw> right
22:29:10 <scshunt> <=< is to =<< as (.) is to ($)
22:30:06 <johnw> right, f = g . h === f x = g $ h x
22:33:55 <sirspazzolot> is there such thing as 'until' in a list comprehension? eg [fib x | x <- [1..], fib x <= 4000000000] where upon contradicting the guard the generator terminates?
22:34:22 <johnw> doesn't that just work?
22:34:32 <Fuuzetsu> :t takeWhile
22:34:32 <lambdabot> (a -> Bool) -> [a] -> [a]
22:34:49 <johnw> > [ x+1 | x <-[1..], x^2 < 20]
22:34:53 <lambdabot>   mueval-core: Time limit exceeded
22:35:12 <johnw> ah, I see
22:35:20 <johnw> it can't know that the remainder of the list might not fulfill the predicate
22:35:34 <sirspazzolot> exactly
22:36:29 <Fuuzetsu> > map (+1) $ takeWhile (\x -> x^2 < 20) [1 ..]
22:36:30 <lambdabot>   [2,3,4,5]
22:38:57 <lesur> Uh, if I'm thinking, "whats so hard about Monads," does that mean I'm not understanding them?
22:39:16 <johnw> eventually it will mean exactly the opposite :)
22:39:24 <johnw> but at the beginning, it can mean that
22:39:32 <sirspazzolot> lesur: haha I had the same concern about pointers
22:39:42 <lesur> c pointers?
22:40:14 <sirspazzolot> lesur: yeah
22:40:29 <johnw> if a beginner asks, "What's the big deal with functors?"  It means they haven't really grasped the depth of Functor.  If an expert asks, "What's the big deal with functors?", it means he has seen the ultimately simplicity at the bottom of that deep pool. :)
22:40:48 <dmj`> lesur: if you can switch between do syntax and (>>=) with ease you're probably doing well.
22:41:21 <lesur> Oh, good, huh, I guess I do understand monads
22:41:30 <sirspazzolot> gah I'm too sleepy to program right now. good night
22:42:25 <Fuuzetsu> Anyone know why haskell-src-exts doesn't have happy listed in dependencies even though it requires it?
22:44:43 <ClaudiusMaximus> > [ x + 1 | x <- [1..], then takeWhile by (x^2 < 20) ]
22:44:44 <lambdabot>   Unexpected transform statement in a list comprehension
22:44:44 <lambdabot>  Use -XTransformList...
22:44:47 <johnw> Fuuzetsu: because happy is a build tool; I've noticed this with several other packages, for example ones that use c2hs
22:47:18 <Fuuzetsu> johnw: I don't see how that changes anything.
22:47:38 <Fuuzetsu> It just makes cabal cry and users unhappy.
22:48:03 <johnw> well, i'm just saying cabal doesn't install prerequisite build tools
22:49:08 <Fuuzetsu> Why? the build-depends field should be perfectly fine with that
22:49:36 <johnw> happy is in the build-depends?
22:49:39 <elliott> that is not what build-depends means.
22:49:42 <Fuuzetsu> It's not.
22:49:46 <johnw> right
22:49:52 <elliott> it is an error to list happy there. like it would be an error to list gcc
22:50:06 <elliott> that happy is written in Haskell is only irrelevant coincidence here
22:50:26 <elliott> Cabal is in the business of tracking Haskell-level dependencies, i.e. stuff your modules actually import from
22:50:45 <elliott> I think there are some plans to have it track build tool dependencies that link to OS-level packages and stuff? but I know nothing about those plans
22:50:46 <lesur> Wait, so a monad simply allows me to do (f a( c a) where f taken in the same inner type as (c)?
22:50:49 <Fuuzetsu> elliott: It's on hackage and cabal-install will install it for you… I see no harm in putting it there.
22:51:11 <johnw> lesur: not sure I understand you
22:51:23 <elliott> lesur: I'm afraid your question doesn't make sense... so I'll err towards "no" :p
22:51:26 <scshunt> lesur: erm, not really
22:51:30 <lesur> :(
22:51:39 <lesur> I'd better keep reading. :)
22:51:42 <elliott> though it is also possible that you are right and it got lost in translation.
22:51:54 <lesur> I'll try rephrasing that.
22:52:05 <johnw> it feels like the Reader monad
22:52:07 <Fuuzetsu> isn't that bind for the (-> a) monad?
22:52:30 <scshunt> let's let him rephrase that before we talk about Reader, I suspect that's not what he's getting at :)
22:53:34 <dmj`> scshunt: yea, looks like the S combinator
22:53:38 <boothead> hi guys, I'm trying to build a reproducable set up with ansible and part of that is managing haskell versions and paths. what are people preferred schemes for installing permanent code (eg hdevtools, hoogle) without borking their OS installed haskell?
22:53:54 <scshunt> (incidentally, are there any common monads other than List where a single bind can result in multiple applications of the bound function? I don't know of any offhand, but I'm not that knowledgeable generally)
22:54:31 <johnw> scshunt: Orc
22:54:40 <johnw> scshunt: and the Probability monad maybe?
22:54:56 <johnw> also, some interpretation of a Tree monad
22:55:01 <boothead> relatedly - is there a way to get runhaskell to find things in these locations?
22:55:13 <dmj`> boothead: https://github.com/Paczesiowa/hsenv is a good isolated environment builder. If you are at all familiar with virtualenv from python its similar
22:56:05 <boothead> dmj`, I've used hsenv - it's great! would you suggest having an hsenv somewhere in ~ and referring to that as my global haskell env?
22:56:10 <scshunt> (actually, disregard any container which happens to be a monoid as well since those can all be made into monads similarly)
22:56:33 <Fuuzetsu> dmj`: boothead: What is the benefit of hsenv over cabal-dev?
22:57:01 <elliott> scshunt: Cont.
22:57:12 <johnw> oh yeah, Cont!
22:57:22 <elliott> trees.
22:57:25 <johnw> not only many invocations, but an indeterminate number
22:57:29 <elliott> (incl. e.g. lambda calculus expression trees)
22:58:07 <lesur> So, a monad is just a type that allows me to apply a function that takes a (m a) to a function that takes (a)?
22:58:31 <johnw> lesur: it's a little more
22:58:46 <elliott> lesur: I'm not sure what you mean.
22:58:47 <johnw> it takes an m a, and a function a -> m b, and gives an m b.  Also, it takes an a and gives an m a
22:58:54 <elliott> lesur: but I think you have it opposite at least.
22:59:23 <boothead> Fuuzetsu, hsenv is a complete haskell environment, it has a file that you source into your shell at which point all haskell related commands (ghc ghci, runhaskell, cabal etc) run in your sandbox
22:59:24 <lesur> elliott: sorry, I don't quite understand what you mean by opposite.
22:59:46 <scshunt> lesur: yes, plus it takes any value and "wraps" it in the monad
22:59:48 <scshunt> (with return)
23:00:07 <lesur> johnw: Your phasing was much better than mine.
23:00:15 <Fuuzetsu> boothead: that's cool, I'll probably give it a look when I need it
23:00:43 <dmj`> Fuuzetsu: honestly couldn't tell you, never used cabal-dev. Really like hsenv though.
23:00:45 <lesur> So I've understood monads all along. Looks like I've wasted two days. :/
23:00:58 <elliott> lesur: there are also laws.
23:01:09 <CADD> lesur: yup, monads are not as scary as people say they are.
23:01:33 <Fuuzetsu> I guess it's just that people do scary cool things with them
23:01:37 <CADD> lesur: http://www.haskell.org/haskellwiki/Typeclassopedia
23:01:41 <CADD> Fuuzetsu: exactly
23:01:50 <CADD> reverse state monad anyone?
23:02:04 <lesur> elliott: Yeah, I'll have to learn them; I can read monads but I cannot yet create my own instances of monads.
23:02:09 <boothead> Fuuzetsu, the only issue i have with hsenv is that it's not quite as well integrated with emacs' haskell-mode as cabal-dev is
23:02:51 <dmj`> boothead: How so?
23:03:03 <johnw> boothead: I use hsenv with haskell-mode every single day
23:03:07 <lesur> CADD: Perfect! this describes everything.
23:03:14 <johnw> but i also use hsenv.el
23:03:15 <Fuuzetsu> boothead: Do you have a ‘insert type’ function anywhere in your setup? The wiki mentions that such miraculous key should exist under C-C C-= (with a bunch of other keys) and yet I fail to find it. I had to write my own today.
23:03:47 <dmj`> johnw: boothead: me too
23:04:20 <lesur> I know monads, I know functors, and I know applicative functors, now I need to learn how to code in a functional style.
23:04:39 <boothead> Fuuzetsu, I believe C-u C-c C-t should do it.
23:05:27 <boothead> dmj`, johnw how do you do it? is it just a case of hsenv activate?
23:05:37 <johnw> M-x hsenv-activate
23:06:38 <johnw> lesur: what language are you most familiar with right now?
23:06:48 <lesur> johnw: Java
23:06:54 <boothead> dmj`, johnw also does it work with multiple sessions? this is what I meant when I said it wasn't quite as well integrated. If you change session (assuming you are working on many things at once) what happens?
23:07:43 <johnw> ah, true, I don't switch sessions generally
23:07:51 <johnw> it's not per-buffer yet
23:08:20 <johnw> no reason it couldn't be, though, I just haven't had the need to scratch that itch
23:08:33 <boothead> lesur, I'm not sure that you really "learn" functional style (as in go and suck in this body of knowledge) it just kind of seeps into you over time.
23:09:36 <boothead> johnw, I did modify haskell-mode a while back to do it - but it wasn't a great patch and the library had moved on a lot by the time it got some attention. might have to re-visit it at some point!
23:10:07 <lesur> Any hints though? My rock paper scissors program ended up imperative. (Most code in a do block and one or two half hearted functions)
23:10:27 <CADD> lesur: you are welcome! that is probably the only "monad tutorial" anyone should ever read.
23:11:43 <lesur> CADD: It certainly should be, reading more just confused me.
23:11:44 <dmj`> lesur: I'd code everyday. Read the sacred texts. http://www.catb.org/esr/faqs/hacker-howto.html
23:12:12 <CADD> lesur: right.. monads are not burritos.. :)
23:12:29 <Fuuzetsu> lesur: Contributing to projects is a pretty good way to learn
23:12:29 <johnw> lesur: think of how you'd write a Java functions if I took away the characters "=" and ";" from your keyboard
23:12:30 <CADD> dmj`: best page on the internet
23:12:36 <dmj`> eric raymond actually wrote on haskell too if anyone is interested: http://esr.ibiblio.org/?p=1796
23:12:55 <johnw> (well, I'll give you one ";" to put at the end of your return statement)
23:12:56 <CADD> dmj`: man i remember reading that years ago, still rings true today
23:13:04 <dmj`> CADD: I so agree... life-changing stuff
23:13:11 <lesur> johnw: what about ==
23:13:13 <lesur> +
23:13:15 <lesur> ?
23:13:27 <johnw> oh, haha
23:13:29 <johnw> == is fine :)
23:13:35 <lesur> :)
23:13:39 <johnw> i'll just take away ";" and the operator "="
23:14:02 <lesur> All right, this is going to take some thinking...
23:14:02 <boothead> is there a way to make runhaskell look in ~/.cabal?
23:14:42 <johnw> lesur: plus, you can define as many functions as you like
23:15:03 <johnw> that's how you create variables: by binding the results of expressions as the arguments to functions
23:15:29 <lesur> How do I change data though? Something like a state monad?
23:15:38 <boothead> runhaskell -f ~/.cabal/bin/ghc-pkg-6_8-compat ?
23:15:42 <johnw> you don't change data
23:15:50 <johnw> you make new data from old data
23:16:04 <johnw> 1 + 2 doesn't make 3 by changing 1 or 2
23:16:50 <lesur> So I have a main function that recurses on it's self an in each recurse it calls certain functions, passing the modified program state from the previous function?
23:17:06 <dmj`> CADD: this as well... http://www.paulgraham.com/avg.html
23:17:07 <johnw> try a simpler problem
23:17:22 <johnw> define the fibonacci function using the style just proposed
23:17:30 <johnw> that's purely numerical, so there's no need to keep any "state"
23:17:31 <CADD> dmj`: yeah, i love that article as well!
23:17:41 <lesur> I'll give it a try.
23:18:41 <lesur> One thing, does haskell memoize?
23:18:51 <johnw> no, not automatically
23:19:04 <lesur> So I have to memoize for it?
23:19:12 <johnw> for this exercise, no memoization is needed
23:19:23 <CADD> johnw: lol, oh man. that may not allways be true. my first haskell program was an implementation of a genetic algo. sometimes it does help to have a nice big project.
23:19:42 <CADD> it was a horrible implementation, but i learned a lot
23:20:35 <johnw> yeah, horrible implementations can be great experiences :)
23:20:36 <CADD> @@ lesur @wiki memoization
23:20:36 <lambdabot>  lesur http://www.haskell.org/haskellwiki/memoization
23:20:45 <CADD> indeed
23:20:58 <lesur> Cool, lamdbadot is useful.
23:21:03 <CADD> it is
23:21:06 <CADD> @listmodules
23:21:06 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap
23:21:06 <lambdabot> source spell system tell ticker todo topic type undo unlambda unmtl version where
23:21:10 <CADD> all that and more
23:21:31 <CADD> @hoogle (a -> b) -> [a] -> [b]
23:21:31 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
23:21:32 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
23:21:32 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
23:22:53 <CADD> um and now for some fun
23:23:02 <CADD> @@ lesur @unlambda `r```````````.H.e.l.l.o. .w.o.r.l.di
23:23:02 <lambdabot>  lesur   Hello world
23:23:04 <CADD> lol
23:23:22 <lesur> :P
23:23:35 <johnw> lesur: the concept of "functional style" descends from the lambda calculus, where functionsare the *only* construction.  There, you can only name values as function arguments, and the only operation is function application.
23:26:49 <lesur> Uh, I feel really stupid, but what command do I use to load a file into the GHCI
23:26:51 <lesur> ?
23:26:56 <johnw> :l
23:26:57 <dmj`> :l
23:27:21 <lesur> lol, I spend a while trying to figure that out. :)
23:27:42 <lesur> fib :: Integer -> Integer
23:27:42 <lesur> fib 0 = 0
23:27:42 <lesur> fib 1 = 1
23:27:43 <lesur> fib n = fib (n-1) + fib (n-2)
23:27:45 <lesur> johnw: How is this?
23:27:49 <CADD> :r to reload all the previously loaded files
23:27:56 <CADD> thats fib for you
23:27:58 <johnw> sure, I meant do it in Java, but that works
23:28:17 <CADD> t/wi27
23:28:19 <CADD> oops
23:31:41 <dmj`> lesur: do you know what the running time of that fib is? its asymptotic complexity
23:31:57 <lesur> dmj`: for that example?
23:32:15 <dmj`> lesur: yes
23:33:00 <lesur> O(n^2)?
23:33:22 <lesur> wait, O(2^n)
23:33:46 <dmj`> lesur: yes, nice
23:34:25 <lesur> I'm not sure I quite understand the implications of this fibonacci example. So is my job to simply define the problem - find the pattern in the program - and tell haskell the pattern, rather than define how to solve the pattern?
23:36:51 <johnw> in general, Haskell programs are about expressing the problem you want solved, rather than telling the computer how to solve the problem, if that's what you mean
23:37:36 <lesur> Yeah
23:38:01 <johnw> that fibonacci function you wrote defines the meaning of an element of the fibonacci sequence at a certain position, and the compiler turns that into code to represent that meaning in machine language
23:39:40 <johnw> but you see how no state, or assignments, or mutations, were needed at all?
23:39:48 <lesur> Yeah
23:39:48 <johnw> you can do the same thing in Java
23:39:52 <johnw> it would just be slightly awkward
23:39:57 <johnw> (for Java)
23:40:08 <lesur> My programming buddies would hate me for that. :)
23:40:40 <johnw> plus, Haskell is able to take advantage of the immutability of data to implement lots of optimization that you can't rely on if data structures are allowed to change
23:41:20 <johnw> so just writing code in a functional style in Java is likely to lead to horrible performance; but that's not the functional style at fault, but the mix of functional code in an imperative-by-default environment
23:43:58 <dmj`> @define fib@(1:tfib) = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ]
23:44:01 <lambdabot>  Defined.
23:44:05 <dmj`> taek 10 $ fib
23:44:09 <dmj`> take 10 $ fib
23:44:14 <dmj`> > take 10 $ fib
23:44:18 <lambdabot>   mueval-core: Time limit exceeded
23:44:24 <dmj`> aw
23:44:48 <dmj`> > take 2 $ fib
23:44:53 <lambdabot>   mueval-core: Time limit exceeded
23:46:35 <johnw> @define fib2 = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
23:46:36 <lambdabot>  Defined.
23:46:38 <johnw> > take 10 $ fib2
23:46:42 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
23:46:50 <johnw> the pattern match was too strict
23:47:27 <johnw> it caused a recursive evaluation before even one result could be returned
23:49:59 <lesur> Sorry to butt in, but going back to what is a functional style: an imperative implementation of Rock Paper scissors would go like: to play rock paper scissors, you and your opponent should, without the other knowing, choose a either rock, paper, or scissors, and compare them. Scissors beats paper beats rock. Meanwhile, a functional rock paper scissors would be something like this: Rock paper scissors is a game where out of two peop
23:49:59 <lesur> le, a winner is selected based upon their throws of either rock, paper, or scissors, where rock beats paper beats scissors.
23:50:14 <dmj`> johnw: that's interesting, worked in ghci
23:50:56 <johnw> true!
23:56:17 <lesur> Is there such thing as a built in data type like Ord that is circular: scissors beats paper beats rock beats scissors?
23:56:59 <johnw> Ord is not a builtin data type
23:57:04 <johnw> it's just a type class from the base libraries
23:57:20 <johnw> you could define your own ordering class
23:57:46 <Sculptor> rock paper scissors lizard spock
23:57:50 <lesur> Nah, it's a tiny program, I'll just throw a comparer together quickly
23:57:52 <johnw> i believe that's a preorder, right?
23:58:32 <johnw> oh, no, it's not
23:58:41 <johnw> S < P && P < R != S < R
