00:00:05 <zRecursive> i am NOT sure if it supports FAST-CGI
00:03:59 <startling> man, I wish runWhateverTs' arguments were flipped
00:05:37 <timthelion> startling: flip them then ?)
00:06:12 <enthropy> the benefit is you can have    do { blah; blahblah; } `runState` initialState
00:06:27 <johnw> startling++
00:06:46 <startling> it's just a common mistake I make, especially when writing things compositionally.
00:06:51 <enthropy> which might be nicer than    flip runState initialState $ do blah; blahBlah
00:06:59 <johnw> but they are really field accessors in a newtype, so from that point of view it would be rather hard to have their args flipped
00:07:25 <startling> johnw: sure, but they don't have to actually be accessors
00:07:32 <johnw> true
00:07:50 <arkeet> I think it's fine the way it is.
00:08:21 <arkeet> I wouldn't be opposed to an extra thing that's flipped
00:08:40 <enthropy> that's why we have flip
00:08:47 <johnw> like, stateT = flip runStateT, would be fine with me
00:09:21 <arkeet> that would be too easily confused with StateT
00:09:32 <johnw> not anymore than Maybe is with maybe
00:09:49 <arkeet> no.
00:09:51 <arkeet> StateT, the constructor
00:10:07 <arkeet> and inverse of runStateT
00:10:11 <johnw> and stateT "destructs" a StateT computation
00:10:17 <johnw> the way that maybe "destructs" a Maybe
00:10:26 <arkeet> I disagree.
00:10:29 <johnw> fine
00:10:39 <arkeet> :t StateT
00:10:40 <lambdabot> (s -> m (a, s)) -> StateT s m a
00:11:02 <arkeet> it would be really awkward to have something that differs by case in one letter doing something that's twice backwards of that constructor.
00:11:18 <sipa> :t Maybe
00:11:19 <lambdabot> Not in scope: data constructor `Maybe'
00:11:24 <sipa> right
00:11:34 <arkeet> Maybe isn't a value. StateT is.
00:12:00 <johnw> well, I'd use stateT about 100x more often that I'd use StateT as a constructor
00:12:08 <johnw> i only ever use StateT as a type
00:12:35 <sipa> :t runStateT
00:12:36 <lambdabot> StateT s m a -> s -> m (a, s)
00:12:39 <arkeet> I just think it's a rather poor choice of name.
00:20:36 <zRecursive> @ummtl StateT s m a
00:20:36 <lambdabot> s -> m (a, s)
00:22:46 <sipa> @unmtl StateT
00:22:47 <lambdabot> Plugin `unmtl' failed with: `StateT' is not applied to enough arguments, giving `/\A B C. A -> B (C, A)'
00:23:14 <sipa> @unmtl RWST r w s m a
00:23:14 <lambdabot> r -> s -> m (a, s, w)
00:24:19 <hpaste> chexxor revised “doubleEveryOther”: “doubleEveryOther ” at http://lpaste.net/91448
00:24:31 <chexxor> enthropy: I think I got it working! There's my code if you're curious.
00:27:55 <sinclair|net> hi all
00:29:13 <dmj> chexxor: doubler = zipWith (\x y -> if even y then x else 2*x) [1..]
00:29:47 <chexxor> somewhere around 1:30-1:40 John Carmack talks about his experience with Haskell, says he likes it. http://www.twitch.tv/bethesda/b/439369577
00:31:34 <chexxor> dmj: I'm keeping it simple, this is my first Haskell thing
00:31:55 <timthelion> chexxor: whoever John Carmack is, John Carmack should be begging for Haskell's praise and not the other way around.
00:31:57 <dmj> chexxor: no prob
00:32:10 <supki> chexxor: the pattern on line 5 looks redundant: [x, y] is covered by (x:y:xs)
00:32:18 <johnw> timthelion: he's been successfully coding for as long as Haskell has been in existence :)
00:32:21 <chexxor> timthelion: he's a serious programming genius, does video game stuff
00:32:28 <dmj> http://en.wikipedia.org/wiki/John_D._Carmack
00:32:51 <sinclair|net> chexxor: yeah, i watched that too
00:33:50 <timthelion> "when Carmack was 14, he broke into a school to help a group of kids steal Apple II computers, but during the attempted break-in one of the kids set off the silent alarm. John was arrested, and sent for psychiatric evaluation (the report mentions 'no empathy for other human beings'). Carmack was then sentenced to a year in a juvenile home." -- That guy?
00:34:19 <chexxor> supki: yeah, you're right, it looks like I can remove that... I still don't completely understand how to choose these matchers, heh
00:34:24 <timthelion> Ok, done joking around
00:36:42 * hackagebot fixed-storable-array 0.3.1.1 - Fixed-size wrapper for StorableArray, providing a  Storable instance. Deprecated - use storable-static-array  instead.  http://hackage.haskell.org/package/fixed-storable-array-0.3.1.1 (CarlHowells)
00:36:44 * hackagebot storable-static-array 0.4.0.0 - Statically-sized array wrappers with Storable instances  for FFI marshaling  http://hackage.haskell.org/package/storable-static-array-0.4.0.0 (CarlHowells)
00:43:28 <supki> chexxor: with -W ghc will warn about overlapping/incomplete patterns
00:44:17 <simukis_> Is there any MVar-like thingy which one could peek into atomically? My case is that a single thread will put data into it and then all other threads would read it.
00:44:51 <supki> hmm, probably won't work for [x,y] / (x:y:xs)
00:45:26 <supki> simukis_: TChan ?
00:45:44 <johnw> simukis_: use TVar from stm
00:45:53 <johnw> also, you can tryTakeMVar
00:46:24 <johnw> but what stm really does well is handle atomicity
00:46:46 <simukis_> supki: I don't want queue. Just a variable. If a consumer misses one value, so be it.
00:47:34 <simukis_> johnw: yeah, TVar it is then.
00:47:43 <supki> simukis_: sure, then TVar/TMVar, depending on the semantics
00:48:03 <simukis_> especially when readTVarIO doesn't even perform a transaction (exactly what I wanted)
00:48:22 <simukis_> Thanks.
00:49:03 <dmj> timethelion: you there
00:49:07 <ion> timthelion: You could use a web-of-trust kind of thing and display e.g. the high scores among friends and friends of friends to users.
00:49:58 <chexxor> supki: I'm using -Wall, it didn't report it
00:50:48 <johnw> I like Carmack's comments on static typing
00:52:54 <ion> johnw: What are those?
00:54:25 <johnw> see the link above
00:54:29 <arnsholt> He's generally quite positive, it seems
00:54:29 <johnw> he says a lot of stuff
00:54:45 <johnw> like, Haskell's relentless purity was to him a big overall win
00:55:32 <johnw> the only thing he wasn't sure about was laziness by default
00:56:42 * hackagebot reactive-banana 0.7.1.3 - Practical library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.7.1.3 (HeinrichApfelmus)
00:58:20 <timthelion> Does cabal-dev borrow packages from the global ghc database or does it recompile everything?
00:58:26 <johnw> the latter
00:58:37 <johnw> it borrows from the GHC global package database
00:58:43 <johnw> so maybe that's what you meant
00:58:47 <johnw> i was thinking of ~/.cabal/lib
00:59:19 <timthelion> johnw: so does it recompile everything or not?
00:59:49 <johnw> it doesn't recompile things that are truly global
00:59:55 <timthelion> ok
01:07:43 <johnw> hmm.. he just called Haskell "not industry grade"
01:07:53 <johnw> i wonder why everyone keeps repeating that mantra
01:08:44 <sp3ctum> insert problems of rarer languages here
01:10:16 <dmj> timthelion: still here?
01:11:55 <timthelion> dmj: yes
01:12:44 <hpaste> dmj pasted “site - timthelion” at http://lpaste.net/91451
01:13:13 <dmj> timthelion: heres a simple prototype of saving scores to/from acid state over ajax
01:13:29 <dmj> timethelion: having an issue decoding the json. I leave it as an exercise :)
01:13:46 <ion> Why is /submit a separate resource from /scores?
01:14:19 <hpaste> dmj pasted “site - timlion - html/js” at http://lpaste.net/91453
01:15:25 <dmj> ion: scores will retrieve all for scoreboard on page load, submit is a post. I guess you could combine them... but what about page load?
01:16:23 <ion> When you have a verb in the URL in addition to the HTTP method something’s wrong. :-P
01:16:49 <ion> What about page load?
01:17:11 <dmj> ion: oh i see, yea I could have had better naming conventions
01:17:52 <ion> In this case, /scores represents a resource and HTTP provides CRUD-like operations as standard methods. In this example, GET and POST are appropriate indeed.
01:18:27 <ion> But splitting the addition of a score and the listing of scores into separate resources just adds code smell.
01:19:46 <timthelion> dmj: it amuses me, that a full third of that haskell code is language extentions and imports.
01:21:26 <ion> > (21-2) / (65-22-9)
01:21:27 <lambdabot>   0.5588235294117647
01:21:37 <ion> err.
01:21:43 <ion> > (21-2) / (21-2 + 65-22-9)
01:21:44 <lambdabot>   0.3584905660377358
01:21:52 <dmj> ion: I too dislike code smell. How would you fix it?
01:22:15 <dmj> timthelion: Yea there's a lot of extensions
01:23:33 <ion> dmj: Since “scores” is a thing you have (but “submit” is not), make the resource path /scores and use the HTTP methods you’re already using. It’s just a matter of changing /submit to /scores.
01:26:24 <dmj> ion: Oh I see, yes good call. scores should have a GET and a POST.
01:26:43 * hackagebot x509 1.4.4 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.4.4 (VincentHanquez)
01:27:32 <dmj> ion: do you do a lot of web dev in haskell?
01:28:05 <hpaste> dmj revised “site - timthelion”: “update site - timthelion” at http://lpaste.net/91451
01:28:31 <ion> dmj: Not really. But whenever i do, i advocate RESTful design.
01:28:41 <hpaste> dmj revised “site - timlion - html/js”: “update timlion html/js” at http://lpaste.net/91453
01:29:00 <ion> <!DOCTYPE html> ;-)
01:30:41 <timthelion> dmj: I see that you've decided to write this for me :P
01:30:42 <dmj> ion: I normally use http://html5boilerplate.com
01:31:16 <dmj> ion: and coffeescript
01:32:08 <dmj> ion: but I hate marshalling types from js to app layer to db. This is why I really like acid-state and want to learn more haskell client side things
01:32:29 <dmj> timthelion: yes :) free of charge
01:32:50 <dmj> ion: Do you know if people use acid-state in production?
01:34:25 <ion> dmj: Dunno. I have tried it but not used it in any kind of production. Ask Lemmih. :-)
01:35:40 <hape01> why ist "Redundant Lambda" an error. I've foreign coding here which does raise errors:  let pop ∷ ByteString →  Double → IO ∅ = λx y →  ...       GHC wants instead   pop x y                                                                     execute_ conn "SET timezone TO 'America/St_Johns'"                        |    =
01:35:48 <dmj> ion: good point.
01:36:28 <hape01> Shouldn't it be only a warning?
01:41:00 <hamid> :t <|>
01:41:00 <lambdabot> parse error on input `<|>'
01:41:05 <hamid> :t `<|>`
01:41:06 <lambdabot> parse error on input ``'
01:41:15 <hamid> :t (<|>)
01:41:16 <lambdabot> Alternative f => f a -> f a -> f a
01:42:28 <hamid> where is this function?
01:43:11 <hamid> which module i mean
01:43:54 <hamid> :i (<|>)
01:43:55 <haasn> Control.Applicative
01:44:03 <hamid> haasn, thanks.
01:44:19 <haasn> @hoogle (<|>)
01:44:19 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
01:44:19 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
01:44:19 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
01:44:25 <merijn> hamid: fyi, hoogle can tell you these type of things :)
01:45:03 <johnw> i'm still not sure why I'd use acid-state over, say, persistent
01:45:25 <johnw> is it simpler?  lighter-weight?  easier to use?
01:45:34 <kryft> yes hoogle tells you types of things
01:45:39 <hamid> merijn, oh! didn't know that. thanks got it.
01:45:48 <merijn> johnw: Persistent seems to require a backend "database" to talk to
01:45:55 <johnw> yes, indeed it does
01:46:14 <merijn> johnw: acid-state persists haskell datatypes directly to files
01:46:18 <haasn> johnw: I don't have much experience with persistent but acid-state allows you to use arbitrary Haskell types (assuming they have the correct instances) as your state, rather than being forced into some relational model
01:46:37 <johnw> so, if I have a recursive structure it DTRT?
01:46:48 <merijn> johnw: Also, I think acid-state supports any serialisable haskell structure
01:47:03 <merijn> johnw: I would guess persist is limited by what backends support? Not sure, though
01:47:15 <merijn> johnw: DTRT?
01:48:18 <johnw> Does The Right Thing
01:48:24 <merijn> johnw: Define "the right thing"
01:48:54 <merijn> I don't think serialisation generally supports infinitely recursive data structures either
01:49:06 <haasn> it does whatever the serialization instance would do; in practise you can't serialize functions or infinite structures
01:49:07 <johnw> mean, it persists it and restores it
01:49:36 <johnw> like the way that Boost.Serialize handles pointer references magically with C++ serialization
01:50:12 <haasn> it might be possible to write a magic serialize interface that does this using GHC tricks and hacks, but as far as I'm aware acid-state itself has no logic for this
01:51:06 <merijn> johnw: If you implement that in your serialisation, then acid-state could do it, but in general, no
01:51:21 <johnw> ok
01:51:28 <merijn> johnw: I think the main difference you have to keep in mind is that acid-state *keeps the state in memory*
01:51:43 * hackagebot citation-resolve 0.3 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.3 (TakayukiMuranushi)
01:51:50 <merijn> It is not an offline data store, it is in memory data, that is safely persisted in case of crashes
01:52:31 <haasn> acid-state doesn't really have a lot of backends either; there's a remote API but the other side will still have a single running instance that keeps state in memory and saves it to its disk
01:53:14 <merijn> johnw: Which means you shouldn't treat it as a queryable database, it is meant for active data that needs the C and D of acid
01:54:41 <johnw> i see
01:54:47 <johnw> that makes sense
01:54:52 <johnw> it's like a backing store for the Haskell heap
01:55:07 <johnw> ok, that places it in a different category
01:55:14 <johnw> I can see where I might use that
01:55:31 <merijn> johnw: yes
02:07:28 <haasn> I wonder if it would be possible to provide a sort of persistent storage system that ties into lens, in particular, indexed monadic traversals
02:08:17 <haasn> and in general using its Ixed class to query stuff so you don't have to keep the entire structure in memory
02:08:42 <johnw> haasn: you mean, like "tables"?
02:08:53 <johnw> but with the behavior of a B-tree or some such?
02:09:04 <johnw> edwardk is actually working on something very near to that
02:09:05 <haasn> I have no idea what tables is, though I've seen it before
02:09:07 <merijn> johnw: You can do even simpler
02:09:22 <haasn> does ‘tables’ offer persistent storage?
02:09:24 <ocharles> haasn: in memory database with lensy accessing
02:09:25 <haasn> or is it just the API
02:09:28 <ocharles> haasn: I don't believe so
02:09:30 <haasn> ah
02:09:34 <johnw> haasn: I guess if you used acid-state with it maybe? :)
02:09:36 <merijn> haasn: I've actually thought about allowing acid-state to work without keeping everything in memory
02:09:43 <haasn> johnw: but then you still have the whole structure in memory
02:09:46 <johnw> true
02:09:49 <ocharles> haasn: though Table's themselves can be serialized
02:09:55 <ocharles> but that makes it up to you to do that
02:10:05 <haasn> ok
02:10:11 <merijn> By (ab)using my incredible knowledge of operating systems :p
02:10:49 <merijn> I'm pretty sure you can make acid-state more flexible in terms of memory use by using mmap
02:10:56 <haasn> merijn: I could see it working with lazy IO as long as you guarantee nothing rewrites its storage stuff
02:11:35 <ion> Too bad mmapped file access blocks other forked IO in the same process.
02:11:59 <merijn> ion: What do you mean by forked IO?
02:12:10 <ion> I have tried acid-state with tables, it worked (as expected).
02:12:16 <ion> merijn: Lightweight GHC threads
02:12:20 <ion> forkIO
02:12:40 <merijn> ion: You mean on page fault?
02:12:53 <ion> yeah
02:12:56 <merijn> True
02:13:21 <haasn> ion: what do the QueryEvents/UpdateEvents look like for tables? Are they handled in a general way, or will I still have to write my own instances for whatever updates I plan on performing?
02:16:09 <ion> The events look just like ones for non-tables data. Nothing special there. You will have to write your own query/update event code, again just like with other types.
02:16:49 * hackagebot threepenny-gui 0.2.0.0 - Small GUI framework that uses the web browser as a display.  http://hackage.haskell.org/package/threepenny-gui-0.2.0.0 (HeinrichApfelmus)
02:17:06 <haasn> makes sense
02:17:39 <ion> tables comes with a cereal instance, so you can just have a newtype wrapper for Table Foo and deriveSafeCopy for it.
02:17:43 <haasn> I wonder what the status is on serializing functions. Doesn't cloud-haskell have to solve this problem?
02:18:17 <ion> Cloud Haskell does pretty much the same thing as acid-state does.
02:18:21 <merijn> haasn: Cloud Haskell cheats, it serialises functions to an id and reifies at the other side
02:18:33 <ion> conceptually
02:18:44 <haasn> merijn: oh, okay; so it wouldn't be much use across code changes
02:21:49 * hackagebot threepenny-gui 0.2.0.1 - Small GUI framework that uses the web browser as a display.  http://hackage.haskell.org/package/threepenny-gui-0.2.0.1 (HeinrichApfelmus)
02:21:51 * hackagebot reactive-banana-threepenny 0.7.1.3 - Examples for the reactive-banana library, using threepenny-gui.  http://hackage.haskell.org/package/reactive-banana-threepenny-0.7.1.3 (HeinrichApfelmus)
02:26:51 <haasn> so does ‘tables’ replace ‘ixset’?
03:01:32 <structuralist> is there a simple way to convert a distributive law λ :: Σ (B x) -> B (Σ x) of endofunctors to one λ' :: Free Σ (Cofree B x) -> Cofree B (Free Σ x) of the corresponding (co)free (co)monads?
03:01:50 * hackagebot tidal 0.2 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.2 (AlexMcLean)
03:29:40 <BitPuffin> Can haskell compile to JS?
03:29:51 <haasn> BitPuffin: yes
03:29:56 <startling> yeah. check out "fay" and "ghcjs"
03:29:57 <BitPuffin> how?
03:29:59 <DigitalKiwi> haskell can do anything dontchaknow
03:30:06 <haasn> using a haskell to JS compiler
03:30:25 <mauke> Haskell can compile brainfuck to JS
03:30:41 <BitPuffin> fay is just a subset :o
03:30:50 <haasn> then checkout ghcjs ;)
03:30:55 <haasn> check out, even
03:31:24 <tdammers> I have a library that compiles from something resembling jinja2 to JS and PHP
03:31:24 <startling> BitPuffin, still a useful subset.
03:31:33 <tdammers> toy project, but works fine
03:31:34 <luite> some relatively big updates for ghcjs coming up for ghcjs this weekend
03:31:45 <luite> err, minus one for ghcjs :)
03:32:26 <BitPuffin> weird, no aur package for ghcjs
03:32:26 <luite> the compiler is 3x faster and uses far less memory, and files are smaller
03:32:41 <structuralist> :D
03:32:42 <luite> BitPuffin: well it's not officially released yet since it's built against GHC 7.8
03:32:53 <BitPuffin> aha!
03:32:54 <BitPuffin> cool
03:33:07 <BitPuffin> can haskell compile to C?
03:33:16 <haasn> BitPuffin: yes
03:33:22 <BitPuffin> how? :)
03:33:23 <luite> yes, ghc could generate C, and (a)jhc still does
03:33:28 <haasn> using a haskell to C compiler
03:33:28 <Walther> !faq can haskell compile to java?
03:33:42 <BitPuffin> luite: ghc can't generate C naymore?
03:33:54 <luite> BitPuffin: i think it was removed, and it wasn't terribly standard C either
03:33:58 <luite> gcc specific extensions
03:34:01 <haasn> no. Recent versions have dumped the C backend in favor of a native code generator
03:34:26 <BitPuffin> hmm, that's too bad
03:34:31 <BitPuffin> I think it's better to have both
03:34:41 <tdammers> isn't there an LLVM backend?
03:34:56 <luite> BitPuffin: if you want to see how it gets compiled, you can use -ddump-cmm. it's lower level than C, but similar in syntax
03:35:22 <luite> BitPuffin: that's teh last intermediate language before native code or llvm in ghc
03:35:30 <byorgey> BitPuffin: of course it's better to have both.  But finite time and resources, etc. etc.
03:35:33 <BitPuffin> luite: well I'm asking because more hardware can run C, so if you can compile to C you can make haskell software that works on more platforms
03:35:55 <klrr> i thought john carmack had gone into investigating FRP stuff :)
03:36:06 <luite> BitPuffin: they use LLVM for that now (for example for the ARM port)
03:36:36 <luite> BitPuffin: making it run on some new operating system is still fairly involved due to the RTS and its dependencies
03:36:38 <BitPuffin> luite: is there a tool that can compile llvm bytecode to C? lol
03:37:03 <luite> BitPuffin: uh well, probably, but that doesn't magically make it run on a new system
03:37:36 <BitPuffin> luite: no I know, but if you call the libries that are used on that system it should probably work
03:37:39 <luite> BitPuffin: for haskell on really small embedded systems, look into ajhc/jhc
03:38:16 <luite> (ajhc is an experimental fork, features get merged back from time to time in jhc)
03:39:59 <BitPuffin> luite: not bad
03:40:57 <haasn> “more hardware can run C” <- you mean more platforms exist with C compilers available?
03:41:17 <BitPuffin> haasn: yeah
03:41:23 <BitPuffin> haasn: like game consoles
03:41:35 <haasn> is llvm unable to target those?
03:41:56 <startling> BitPuffin: you'd need to do a significant amount of work porting the runtime in any case
03:42:12 <startling> (but I bet llvm does support at least some things like that)
03:42:34 <luite> meh unless you count small embedded systems (for which you have jhc) there are only two relevant cpu architectures left anyway :p
03:44:06 <BitPuffin> I'm disappoint, there is no aur package for jhc and ajhc
03:44:21 <startling> BitPuffin: ajhc has a cabal package.
03:44:27 <BitPuffin> oh
03:44:30 <FreeFull> You'd usually write a Gameboy Advance game mostly in C
03:44:50 <startling> feel free to install things without using your package manager, though. :)
03:44:51 <Philippa> yeah, but mostly you wouldn't write one these days
03:44:57 <startling> FreeFull, that's no fun.
03:45:00 <Philippa> what's the chip on the 3DS?
03:45:30 <CZ> hi
03:45:40 <Philippa> (IIRC the PS Vita's some flavour of ARM, the next-gen consoles're all x86 too)
03:45:44 <luite> Philippa: some arm11
03:45:55 <FreeFull> Philippa: Apparently a dual-core arm11
03:45:58 <Guest39871> I want to learn Haskell. the installer says my machine doesn't have the GLUT library installed. to I need this library?
03:46:08 <startling> FreeFull: one for each screen. :)
03:46:12 <FreeFull> Guest39871: That's for opengl stuff
03:46:13 <luite> yeah i think the wii u is the only ppc left
03:46:22 <Guest39871> FreeFull: i. e.?
03:46:31 <Guest39871> I am totally new to Haskell
03:46:51 <Guest39871> so that's graphics stuff?
03:46:59 <FreeFull> Guest39871: OpenGL is a 3D library, so yeah
03:47:02 <startling> Guest39871: yeah.
03:47:09 <startling> you wouldn't want GLUT in any case.
03:47:14 <Guest39871> ok
03:47:18 <startling> why does a ghc installer require GLUT?
03:47:36 <startling> Guest39871: what installer are you installing?
03:47:43 <hpc> the platform includes glut
03:47:48 <Guest39871> windows platform
03:47:53 <BitPuffin> alright, well that gives me hope about maybe using haskell one day, for now I'll experiment with nimrod :)
03:47:56 <startling> hpc, oh weird.
03:47:58 <Guest39871> it asks me if I want to install this library
03:48:17 <DigitalKiwi> BitPuffin: write a PKGBUILD and put it on AUR
03:48:17 <DigitalKiwi> that's what it's there for
03:48:53 <DigitalKiwi> freaking lag
03:48:58 <BitPuffin> DigitalKiwi: yeah maybe some day
03:49:08 <DigitalKiwi> oh it did go through
03:49:14 <FreeFull> BitPuffin: Glut is in standard repositories
03:49:16 <FreeFull> as libglut
03:49:30 <FreeFull> Actually, no
03:49:30 <BitPuffin> FreeFull: I haven't say anything about glut 0.o
03:49:31 <FreeFull> freeglut
03:49:34 <FreeFull> Oh
03:49:37 <FreeFull> Nevermind
04:29:00 <Guest39871> did anyone here read the book "programming in haskell"?
04:34:20 <mm_freak> is there a way to override the code highlighting language for individual pages in gitit?
04:57:08 <merijn> Guest39871: I haven't, but I heard people here say that it's good
05:19:41 <haasn> structuralist: I managed to write f :: (Functor f, Costrong g) => (forall a. g (f a) -> f (g a)) -> Free g (Cofree f b) -> Cofree f (Free g b) -- by just playing around with the types. I have no idea if this even does anything useful, but it might be related
05:20:17 <structuralist> haasn: I think I might have it actually
05:20:30 <haasn> if so I'd be interested in seeing
05:20:55 <structuralist> sure, refactoring it right now
05:23:21 <danilo2> Hi! I want to learn GHC API and I want to generate some Haskell structures using this API (like create new modules, functions, etc). I want also (if it is possible) to generate haskell code out of these structures - Could you give me any hints where to find informations about it?
05:25:01 <luite> danilo2: are you sure you need the GHC API? you might find Template Haskell useful, or if you need to process haskell source maybe haskell-src-exts
05:25:42 <danilo2> luite: I know, but I want to generate complex Haskell programs with it - and I would love to use the GHC API :)
05:25:53 <luite> danilo2: template haskell code runs at compile time and produces Haskell, you can read files and do other things to generate complex code
05:26:51 <luite> danilo2: if you're just looking for an excuse to use/learn the GHC API then that's fine of course :)
05:26:59 <danilo2> luite: I know template haskell and I'm using it a lot, but it cannot generate for example modulehierarchy etc- I want to generate Haskell structures as a result of custom compiler - here the GHC API is more suitable than TH.
05:27:10 <bennofs> Could Template Haskell also be used to generate haskell code at runtime, using runQ, or is there functionality that doesn't work in IO (other than reify)?
05:27:32 <luite> bennofs: does't work, the code is fed back into the compiler and compiled with the other haskell code
05:28:07 <luite> bennofs: you can of course bundle the whole interpreter with your program, using the ghc api (or some higher level lib that uses it)
05:28:39 <bennofs> luite: Yes, it was just a question about generating the code, not about actually running the generated source
05:28:49 <luite> oh right
05:28:58 <luite> i think that's probably possible :)
05:29:09 <luite> you just get the AST
05:30:03 <luite> not sure why you'd want that though :p
05:30:14 <thoughtpolice> you can do it, i think. Geoffrey had an example of using the new Template Haskell to write a staged power function, no
05:30:19 <thoughtpolice> ?
05:30:43 <thoughtpolice> oh, runtime. nvm.
05:31:05 <bennofs> luite: Maybe to get the quoting syntax for Something to Haskell compilers?
05:32:26 <CapitanK> what is the channel choice for hardcopy of Haskell Books?  lyah for sure is popular, any others?
05:35:00 <merijn> CapitanK: Programming in Haskell by...Hughes? (Not sure about the name) and Real World Haskell
05:35:41 <merijn> oh, Graham Hutton
05:36:31 <shanse> I just picked up »Parallel and Concurrent Programming in Haskell«
05:37:15 <merijn> shanse: That's really aimed at people who already know Haskell, though
05:37:20 <merijn> So it's no good as intro
05:37:28 <shanse> that's true
05:39:55 <roconnor> @pasete
05:39:55 <lambdabot> Haskell pastebin: http://hpaste.org/
05:40:28 <Yaniel> @where paste
05:40:28 <lambdabot> http://lpaste.net/new/haskell
05:40:50 <donri> @pastgarbl
05:40:50 <lambdabot> Unknown command, try @list
05:41:04 <luite> can @where things be updated by users?
05:41:10 <CapitanK> @where books
05:41:10 <lambdabot> See `LYAH',`RWH',`YAHT',`HR',`wikibook',`non-haskell-books'
05:41:34 <donri> @where HR
05:41:34 <lambdabot> "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/>
05:42:13 <danilo2> luite: I don't looking for excuse :) I simply want to learn GHC API and learn how to create moduels functions classes etc form the API :) I would be thanful for help in this topic :)
05:42:14 <donri> someone was asking what we should call Concurrent and Parallel Programming in Haskell for short
05:42:17 <donri> how about "simon says"
05:42:35 <CapitanK> great suggestions, although I can say I program in Haskell, it only means it know enough to be dangerous :P So need more of those beginning type books.
05:43:23 <luite> danilo2: ah i'm not sure if the API is really suitable for generating module hierarchies though. it's really built around a pipeline that compiles a haskell file, you can modify core from e asingle module with it of course
05:43:48 <merijn> CapitanK: What have you read so far?
05:43:53 <CapitanK> Been study Parallelisms at the hardware layer...SIMD
05:44:46 <danilo2> luite: Ok I've caused some misuderstanding :) I do not want to generate module hierarchies - I want to generate empty module and create functions data types etc inside of it - AND THEN compile it :)
05:44:48 <CapitanK> The lyah has been good to start, thinking of ordering the hardcopy, but can only order 1 or 2
05:45:48 <CapitanK> 1 or 2 books, so want to get something that will really be a good reference...technical books for me are better for referencing.
05:45:53 <merijn> CapitanK: Real World Haskell is a decent follow up to LYAH, just skip the first few syntax explanation chapters
05:45:57 <luite> danilo2: ok, it still sounds TH might be the easier route here
05:46:16 <danilo2> luite: I know, but I want to learn GHC API :)
05:46:35 <luite> danilo2: but check out GHC core plugins, you get the Parsed/typechecked module, you can generate your own code in that
05:46:39 <CapitanK> merihn: yes, was thinking real world
05:46:59 <luite> danilo2: there are no plugins for other phases yet, so you'd have to use GHC as a lib then
05:47:41 <merijn> CapitanK: RWH is online too, so you can try before you buy
05:48:08 <danilo2> luite: I was thinkign all the time about using GHC as a lib - I didnt know there is other way of using GHC in custom Hasskell program
05:48:22 <luite> danilo2: hopefully before 7.8 the plugins will be extended a bit
05:48:47 <danilo2> luite: what is the difference between making the plugins and using GHC as library?
05:48:49 <luite> danilo2: -fplugin=Some.Plugin.Module, and it runs the plugin on the generated core
05:49:27 <luite> danilo2: should also work with {-# OPTIONS_GHC #-} in the source file
05:49:28 <danilo2> luite: I understand that plugins are still using GHC as library then? (but in simplified form?)
05:49:57 <luite> danilo2: yep the plugin is called by GHC, you do some transformations, give the code back, and GHC does the rest
05:50:08 <luite> no need to have a custom compiler wrapper etc
05:50:22 <donri> plugins can't do syntax extension can they?
05:50:22 <luite> unfortunetly only for core at the moment
05:50:59 <luite> donri: no, but you can run a preprocessor if that can do what you want
05:51:14 <luite> for modifying the parser you'd have to recompile GHC, can't be done from the API
05:51:15 <CapitanK> Any read  "The Little Schemer"?
05:51:38 <luite> unless you just supply your own parser and hand preparsed HsSyn data to the API
05:51:43 <donri> luite: well that's what is currently done, which has loads of problems. would be nice if the ghc parser was directly extensible somehow.
05:51:49 <danilo2> luite: Thats interesting :) I don't know if plugins can do everything I want - I'm wriitng custom language copiler and I want to compile directly to Haskell structures and then typecheck them (make some operations on these typechecked structures) and then compile them.
05:52:06 <luite> donri: not easy with a generated happy parser :)
05:52:09 <danilo2> luite: I don't know if in this situatuion the GHC as library would be better choise
05:52:13 <donri> luite: aye
05:53:09 <luite> danilo2: do you need the GHC typecheker?
05:53:17 <luite> if you don't, you could compile to core
05:53:25 <danilo2> luite: yes I need
05:53:40 <danilo2> luite: I want heavly use the GHC typechecker in my compiler
05:53:54 <luite> (core can be checked, but it's all desugarde, typeclasses converted to arguments etc, no type inference)
05:54:23 <danilo2> luite: I'm creating my language parser in Haskell and I want to bind to the GHC to generate Haskell native structures and compiel them :)
05:54:51 <danilo2> luite: I would love to use type inference etc :)
05:55:04 <luite> danilo2: so you don't have your own typecheker (or a limited one?), but you want to generate haskell and let GHC do the checking?
05:55:08 <danilo2> luite: so I want to generate structures before desugaring
05:55:17 <danilo2> luite: exactly
05:56:54 <luite> danilo2: ok, well i think that you can use the GHC API then, you make your own HsSyn AST and feed that to GHC. you can label the AST with source locations of your own source langauge to get somewhat useful error location info, but the error messages might not be so useful
05:57:38 <luite> but perhaps you can later replace this with your own typechecker, switch to core instead, and still get GHC's optimizations and code generation
05:58:16 <danilo2> luite: I was thinking about something like that!
05:58:49 <danilo2> luite: Could you please tell me where can I find more informations about HsSyn AST? I'm new to GHC API and I want to learn it as fast as possible :)
05:59:32 <luite> danilo2: http://lambda.haskell.org/platform/doc/current/ghc-api/HsSyn.html
05:59:51 <luite> danilo2: but definitely try to install some local hoogle server with the GHC version you're working on
06:00:28 <luite> it's a relatively big program, pretty much the whole compiler is exported as a lib
06:00:45 <danilo2> luite: thank you :) I'll be trying to figure that out :)
06:01:24 <hpaste> lasticot pasted “compilation Error” at http://lpaste.net/91457
06:01:25 <hpaste> lasticot pasted “Dies.hs” at http://lpaste.net/91458
06:01:46 <lasticot> I've got this error and I don't get what is wrong. Can someone help me?
06:02:38 <luite> danilo2: the main API is here, you'll probably build your own ParsedModule and then run typecheckModule and loadModule on it, loading the module generates the code: http://lambda.haskell.org/platform/doc/current/ghc-api/GHC.html
06:02:45 <mauke> :t randomR
06:02:46 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
06:03:33 <mauke> lasticot: what happened to rollDie's Int argument?
06:03:39 <danilo2> luite: I didnt find the site before! thanks!
06:03:50 <luite> danilo2: it's probably also installed on your local system
06:04:07 <luite> danilo2: the API is rather unstable, breaks between major GHC releases, so make sure you have the correct one
06:04:11 <lasticot> mauke: thank you I was lost in the code and failed to notice it
06:04:18 <danilo2> luite: I will :)
06:04:36 <danilo2> luite: thank you once again :)
06:12:09 * hackagebot fixed-vector 0.5.0.0 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.5.0.0 (AlexeyKhudyakov)
06:41:11 <hpaste> oscarvarto pasted “where syntax?” at http://lpaste.net/91459
06:45:42 <oscarvarto> Hi! I am starting with Haskell and coded this: http://lpaste.net/91459 (I am interested in Data Clustering Algorithms). Lines 7-8 define a function `addItem` and I wonder if there is a way to make that definition part of the `data Cluster` definition. Would you mind give me some guidance?
06:46:48 <geekosaur> no, you can't make it part of the data. Haskell isn't an OO style language
06:47:02 <bergmark> oscarvarto: no they are separate, but you can define smart constructors and only export those if you don't want people to access the constructor directly
06:49:38 <oscarvarto> geekosaur: bergmark: Thanks for helping newbies. As long as I can find time (make some time) I will keep going with Haskell.
06:52:13 <b2coutts> oscarvarto: essentially, instead of creating "member functions" as you would in C++, Java, etc, you instead make static functions that take your object as their first argument
06:53:06 <b2coutts> in C++ speak, instead of making a function like int Point::sum();, you make a function like int sum(Point p);
06:53:55 <czro> Hello. Soory, but i'm having trouble with my irc client. Can anyone read this?
06:54:04 <mauke> czro: no
06:54:17 <czro> mantovani: ok :)
06:54:21 <oscarvarto> b2coutts: I have been coding in Scala, but now I want to use a `real` functional language (I had to work on top of the JVM).
06:55:33 <JuanDaugherty> oscarvarto, :)
07:02:10 * hackagebot tidal 0.2.1 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.2.1 (AlexMcLean)
07:04:01 <hpaste> lasticot pasted “random initialisation” at http://lpaste.net/91460
07:04:03 <lasticot> Concerning the code I've just pasted I've got 2 questions: why r is not in scope when used in "interpretDice"? and how can I make sure to have an independent dice throw for each line I'm entering?
07:07:50 <lasticot> to be clearer here is the declaration of lndmDices:
07:08:14 <lasticot> lndmDices :: [Either String (Int, Int)] -> [Either String (GeneratorState [Int])]
07:08:59 <supki> lasticot: if you desugar do-notation then the answer to your first question will be clear
07:11:35 <danilo2_> Hi! When I'm trying to use  $(makeLenses ''Vector) (where Vector is my custom Data Type) I'm getting error : Couldn't match type `[Language.Haskell.TH.Syntax.Dec]'  with `Language.Haskell.TH.Syntax.Exp' --- Is it possible to use TH in ghci?
07:12:53 <edwardk> danilo2_: sadly you're out of luck
07:13:24 <danilo2_> edwardk: so it is not possible to use Lenses in ghci?
07:13:33 <int-e> lasticot: you can use 'let' inside a do block to define functions depending on values computed inside the monad. and yoy might take a look at  newStdGen
07:13:39 <edwardk> you can use them, you just can't run makeLenses from in there.
07:14:10 <geekosaur> TH works because it can use the bytecode backend whle the standard backend is "busy". unforutnately, ghci also uses the bytecode backend...
07:15:41 <kuribas> Hi, I am making a library for bezier curve math.  Is there a good vector library, for example for calulating a unit vector, multiplying and adding vectors, matrix transformations, inverse matrices, matrix from transform (rotation, translation), etc... ?
07:17:05 <hpaste> lasticot revised “random initialisation”: “random initialisation” at http://lpaste.net/91460
07:17:36 <danilo2_> So it is not possible to use Lenses in GHCI ?
07:17:53 <edwardk> danilo2_: it is not possible to use makeLenses in ghci.
07:18:00 <edwardk> > (1,2)^._2
07:18:02 <lambdabot>   2
07:18:08 <edwardk> lenses work just fine there in general though
07:18:14 <ClaudiusMaximus> kuribas: looking on hayoo for "bezier", seems most of the existing implementations use 'vector-space' package
07:18:24 <edwardk> if you want to make a custom data type, just make it in a file, put makeLenses in there and load it
07:18:38 <lasticot> Is it ok to use randomRIO to get a new seed for each line I'm interpreting?
07:19:14 <danilo2_> edwardk: thank you :)
07:19:19 <ClaudiusMaximus> kuribas: though that's more of an API than concrete implementation
07:19:23 <ClaudiusMaximus> (afaict)
07:19:41 <mizu_no_oto> What's the proper term for type class instances of the form "Foo a => Bar (Quux a)"?  Conditional instances?
07:21:13 <ClaudiusMaximus> kuribas: you might find some more specific implementations at http://packdeps.haskellers.com/reverse/vector-space
07:21:26 <kuribas> ClaudiusMaximus: It doesn't need any bezier operations, because they will be defined by my code, but general geometry and linear algebra.
07:21:44 <danilo2_> edwardk: Could you please tell me why I cannot use Lenses in GHCI? I was thinking that GHCI supports TH?
07:22:11 <mauke> you can use lenses in ghci
07:22:56 <geekosaur> danilo2_, ghci does not support TH. but you don't need TH for lenses, just for some convenience features
07:23:01 <int-e> the ghci prompt does not support arbitrary declarations. put them into a .hs source file and load that.
07:23:18 <geekosaur> ghci and TH use the same compiler mechanism
07:23:39 <edwardk> danilo2_: makeLenses is just a template haskell function. at last check there wasn't a way in GHCI to turn a Q [Dec] into actual code.
07:23:46 <edwardk> nless i am mistaken
07:23:53 <edwardk> nothing lens specific about that
07:24:40 <int-e> (ghci can load files using TH just fine.)
07:24:44 <danilo2_> edwardk: I can use runQ in GHCI, so it seems it supports TH in some ways
07:25:04 <int-e> danilo2_: no, that's just the IO instance of the Q monad
07:25:47 <edwardk> the IO instance for Q lets you ask some things about the environment
07:26:00 <danilo2_> oh, ok, I see :)
07:27:03 <donri> (well, Quasi)
07:27:03 <int-e> Well, of the Quasi type class. (That's one indirection too many for my linguistic abilities)
07:30:20 <Carp> Hello, Im here after watching John Carmacks Quake Con speech
07:30:48 <Carp> I wonder how many people have said that in the last 12 hours hehe
07:30:56 <Clint> at least 2
07:31:49 <bscarlet> anyway, welcome.
07:32:47 <merijn> Oh, I still need to watch that
07:33:41 <ocharles> merijn: it's quite good
07:35:55 <Carp> He said learn Haskell now and in 5 years, you will be kicking everyone's ass.
07:36:11 <Carp> So I got interested quite quickly ha
07:36:12 <mauke> that advice comes too late for me
07:36:18 <mauke> I already learned Haskell :-(
07:36:28 <Zenol> what would need ghc/ghci to run chrooted (more than all the stuf in /usr/lib/ghc-version/) ?
07:36:30 <Carp> How is the ass kicking going?
07:37:09 <int-e> @quote ivory
07:37:09 <lambdabot> dons says: we had 15 years building ivory towers - time to throw rocks from the top!
07:37:31 <luite> Carp: the problem with this channel is that if you talk to people you realize that they kick much more ass than you :p
07:37:48 <ocharles> luite: stop kicking my ass!
07:37:50 <luite> Carp: (fortunately the greatest ass-kickers are also generally quite helpful)
07:37:54 <int-e> luite: I've found that to be a great incentive to learn more
07:38:34 <luite> int-e: hehe that's true, but at some points it made me want to go back to bubble gum
07:38:52 <datura> luite: try it. it tastes like shit :p
07:40:30 <luite> Carp: but it's quite cool that some high profile programmer like him can bring haskell to the attention of a wider audience :)
07:41:23 <mauke> > 2 + 2
07:41:24 <lambdabot>   4
07:41:28 <mauke> ^ amazing haskell technology
07:41:29 <Carp> He said he wonders what the world would be like today if he had written Quake in Haskell instead of C
07:41:38 <luite> there were a few technical inaccuracies but those don't really matter that much
07:41:46 <djahandarie> Maybe we'd have a good FRP library
07:42:09 <luite> Carp: well back then GHC really wasn't so good, so it would've been delayed a bit ;)
07:42:09 <elliott> not sure Quake in 1996 Haskell would have worked terribly well
07:42:27 <RichyB> We'd have several great FRP libs, but "R" would probably stand for "rocket".
07:42:28 <elliott> though how old is Frag?
07:43:05 <mauke> > filter even [0 ..]
07:43:06 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
07:43:42 <b2coutts> does carmack know haskell?
07:43:43 <ocharles> djahandarie: you don't like what we have now?
07:43:49 <b2coutts> I thought he sort of disliked functional languages
07:44:06 <b2coutts> I vaguely recall him trying to learn scheme and being frustrated with it
07:44:12 <luite> b2coutts: he says he really likes it, but he considers himself a beginner
07:44:23 <luite> in the talk that was posted on reddit yesterday
07:44:23 <b2coutts> cool
07:44:30 <b2coutts> I think that represents 90% of haskell users :P
07:44:39 <luite> oh he mentioned scheme as well in the talk
07:45:06 <luite> but static types are better
07:45:10 <donri> https://twitter.com/ID_AA_Carmack/status/344089043937665024
07:45:28 <luite> :)
07:45:30 <b2coutts> untyped data is a thing?
07:45:56 <datura> didn't he write some article about how the future of games development could be functional code at least 2 years ago?
07:46:35 <Carp> I know this is a biased place to ask ofcourse but..
07:46:37 <b2coutts> I think the future of all development could be functional code if we could manage to get off the OO bandwagon
07:46:39 <luite> datura: hmm, wasn't that tim sweeney
07:46:41 <luite> :
07:46:42 <luite> ?
07:46:58 <Carp> Ive been learning programming in my spare time for the last 8 months. Ive been learning python
07:47:38 <Carp> So now you know the level I am, do you think I should dip into Haskell now a bit?
07:47:42 <datura> luite: could be, not sure.
07:47:51 <elliott> Carp: only if it interests you.
07:47:58 <elliott> you don't need to be an elite programmer or mathematician or whatever to learn Haskell.
07:48:04 <elliott> just open to new ideas and willing to work at something unfamiliar
07:48:05 <Zenol> luite> when exactly in his talk? :p
07:48:12 <donri> Carp: it's fine to start with haskell as your first language, so sure
07:48:21 <mauke> it works better if you don't know another programming language :-)
07:48:22 <donri> @where lyah
07:48:22 <lambdabot> http://www.learnyouahaskell.com/
07:48:27 <luite> Zenol: uh dunno, somewhere between 1:38 and 2:00 i think
07:48:30 <datura> Carp: i know people who teach their kids haskell as the first language. just do it. it's mind-expanding, even if you can only read some like me.
07:48:32 <elliott> yes, arguably eight months of Python makes Haskell a little less smooth given how different it is :)
07:48:46 <b2coutts> Carp: there seems to be a conception that haskell is only for elite programmers
07:48:51 <b2coutts> this is not so
07:49:50 <donri> i rather feel i'm too stupid to use anything not haskell :p
07:49:50 <b2coutts> though I will say that becoming a novice in haskell is more difficult than in most other languages
07:50:06 <b2coutts> as it's easier to code in other languages without understanding them than it is to code in haskell without understanding it
07:50:11 <luite> but haskell programmers have so much fun programming that they become elite programmers eventually
07:50:17 <mauke> good because my goal wasn't to become a novice :-)
07:50:45 <b2coutts> I would guess that becoming an "elite" programmer in haskell is easier than in C++
07:50:56 <b2coutts> but as I'm not an elite haskell or C++ programmer I wouldn't really know
07:51:08 <luite> b2coutts: hmm, i'm not sure, but it's quite different
07:51:13 <haasn> donri: I know that feeling
07:52:03 <ousado> I don't think you can reasonably call someone "elite programmer in language X"
07:52:17 <b2coutts> I sort of feel like sketching a learning curve for various languages
07:52:22 <b2coutts> mostly python, C, and haskell
07:52:27 <luite> b2coutts: but it's a bit hard to say, bos is a totally different elite programmer than oleg for example
07:52:39 <Maior> it also depends what you're trying to do
07:52:40 <Zenol> b2coutts> I wounder if I would be able to understand monads when I was younger..
07:52:41 <jfischoff> good point
07:52:42 <int-e> I wonder how many people prototype in Haskell and then rewrite their code in a different language (e.g. to make it faster, or because there is a particular language requirement)
07:52:53 <Zenol> b2coutts> probably not..
07:52:56 <Maior> int-e: I do that a fair bit
07:53:06 <b2coutts> Zenol: keep at it!
07:53:14 <donri> b2coutts: http://mrozekma.com/editor-learning-curve.png
07:53:21 <b2coutts> best not to make excuses for not being able to understand things
07:53:31 <b2coutts> donri: haha yeah I've seen that
07:53:39 <luite> int-e: hmm, is rewriting to make it faster really necessary that often?
07:53:41 <Zenol> donry> I love the emacs's one :D
07:53:44 <b2coutts> though basically none of it makes sense to me
07:53:59 <b2coutts> I guess notepad does
07:55:24 <Maior> luite: often, but then it's that or using some kind of Haskell/C++ bridge to interface with existing code
07:56:01 <Carp> Well, thankyou very much for the mini taster. Its a very exciting landscape for me and I will be doing the Haskell tutorials on the main website next week! bye
07:56:15 <luite> Maior: right i mean cases where redoing bits of the code in C (or generated llvm or similar) and keep the bulk in haskell does not suffice
07:56:56 <Zenol> anyway, no-one tried to setup ghc in a chrooted environment? When I lauch him chrooted I just have a ghc: out of memory (requested 2097152 bytes) (although it works outside of the chroot). Probably related to missing libraries (I don't copied llvm stuff and I can't imagine it can work without jit, but that's not a helpfull error message...)
07:57:19 <ClaudiusMaximus> int-e: i write in haskell then either use C + FFI for speed critical sections or rewrite in C or C++ for library reasons (needing mpfr...)
07:57:53 <int-e> oh, right, there's the gmp allocator issue.
07:58:19 <luite> ClaudiusMaximus: i get a bit nauseous from your mpfr C code ;)
07:58:46 <ClaudiusMaximus> int-e: and for some things (audio-visual things with low latency requirements) any gc'd language is a bit risky...
07:59:10 <haasn> b2coutts: http://www.haskell.org/haskellwiki/Humor/LearningCurve
07:59:56 <ClaudiusMaximus> luite: me too...
07:59:59 <b2coutts> haasn: hahaha
08:01:20 <Zenol> maybe i'm asking too stupid things? :(
08:01:50 <luite> ClaudiusMaximus: awesome results though
08:03:53 <jfischoff> I think it is actually hard for many people to understand how poor and uneven parts of the Haskell ecosystem are.
08:04:15 <jfischoff> on the one hand you have people like bos throughing up aeson on hackage
08:04:35 <jfischoff> than you have me with what ever crap I put initially
08:05:04 <jfischoff> the levels of quality vary greatly
08:08:37 <Entroacceptor> I have a function f::(a -> m b), and a a::(Maybe a), now I want to have either mzero or (f a).
08:09:05 <roconnor> maybe mzero f a
08:09:26 <roconnor> :type maybe
08:09:27 <Entroacceptor> d'oh
08:09:33 <roconnor> :t maybe
08:09:34 <lambdabot> b -> (a -> b) -> Maybe a -> b
08:09:48 <Entroacceptor> thanks
08:09:51 <applicative> @type maybe mzero
08:09:52 <lambdabot> MonadPlus m => (a -> m a1) -> Maybe a -> m a1
08:09:53 <Entroacceptor> time to quit for today
08:10:15 <roconnor> foldMap f a  might also work?
08:10:24 <roconnor> what the status of MonadPlus and Monoid?
08:10:29 <roconnor> *what's
08:10:34 <donri> @. djinn type maybe mzero
08:10:36 <lambdabot> Error: Class not found: MonadPlus
08:11:04 <applicative> roconnor: wait you mean MonadPlus and Alternative -- they were to be affected by the Functor/Applicative/Monad reform
08:11:09 <applicative> ?
08:11:41 <roconnor> I mean how do I get a Monoid instance for a MonadPlus?
08:11:51 <roconnor> is there a wrapper
08:11:58 <roconnor> does it just work?
08:12:03 <applicative> ah
08:12:33 <geekosaur> MonadPlus is separate from Monoid, and has different instances in some cases (for example Maybe a)
08:12:33 <applicative> something like WrapMonadPlus
08:12:55 <roconnor> I guess there would have to be a wrapper
08:13:30 <roconnor> :t F.foldMap
08:13:31 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
08:13:37 <roconnor> :t F.foldr
08:13:37 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
08:14:21 <applicative> > F.foldMap Sum [1,2,3]
08:14:22 <lambdabot>   Sum {getSum = 6}
08:14:50 <roconnor> > F.foldMap Sum (Just 3)
08:14:52 <lambdabot>   Sum {getSum = 3}
08:15:16 <applicative> > F.foldMap Sum Nothing
08:15:17 <lambdabot>   Sum {getSum = 0}
08:16:17 <roconnor> ah ha
08:16:56 <roconnor> :type -> F.msum . fmap f
08:17:01 <roconnor> :t F.msum . fmap f
08:17:02 <lambdabot> (Functor t, Show a1, MonadPlus m, Foldable t, FromExpr (m a)) => t a1 -> m a
08:17:14 <roconnor> :t F.msum . fmap ?f
08:17:15 <lambdabot> Not in scope: `?'
08:17:21 <roconnor> :t \f -> F.msum . fmap f
08:17:22 <lambdabot> (Functor t, MonadPlus m, Foldable t) => (a1 -> m a) -> t a1 -> m a
08:17:47 <applicative> :t F.toList
08:17:48 <lambdabot> Foldable t => t a -> [a]
08:17:49 <roconnor> apparently msumMap is missing from Foldable
08:18:00 <applicative> :t msum .  F.toList
08:18:01 <lambdabot> (MonadPlus m, Foldable t) => t (m a) -> m a
08:18:05 <applicative> no
08:18:20 <roconnor> Entroacceptor: msumMap f = Data.Foldable.msum . fmap f
08:18:29 <applicative> well, Control.Monad is what needs msumMap so to say
08:18:48 <roconnor> applicative: Data.Foldable has foldMap
08:19:02 <applicative> yes, its F.msum that is confusing me now
08:19:08 <Entroacceptor> roconnor: thanks, just using maybe works fine for now
08:19:20 <applicative> haha
08:19:24 <roconnor> Entroacceptor: ya for now, until you change Maybe to some other container!!
08:19:28 <roconnor> Entroacceptor: ;)
08:20:15 <Entroacceptor> roconnor: but there's a chance I want to change the mzero part, too. A pretty big one, actually
08:20:22 <roconnor> :/
08:21:01 <Entroacceptor> premature abstraction is the root of all evil! ;)
08:21:54 <roconnor> ouch,  msum is defined as foldr mplus mzero ... how inefficent.
08:22:12 <applicative> in Data.Foldable
08:22:46 <applicative> and its not a method of Foldable
08:23:04 <applicative> I think these modules Monoid, Foldable etc arent too well thought out in point of efficiency
08:23:30 <roconnor> applicative: I'll make a proposal to and wrappers for Alternative and MonadPlus to Data.Monoid.
08:23:47 <roconnor> then we can patch Foldable to use these wrappers
08:24:26 <applicative> that makes sense. As I said, I think MonadPlus = Monad + Alternative was on the agenda
08:24:31 <roconnor> what's the new new new library proposal mechanism?
08:24:54 <applicative> I think you just write to the library list with a proposal
08:25:02 * applicative refuses to subscribe
08:25:59 <slack1256> I found this comment on the ghc source code
08:26:09 <slack1256> "Historical note: \"hsc\" used to be the name of the compiler binary, when there was a separate driver and compiler.  To compile a single"
08:26:31 <slack1256> what is a driver in compiler context?
08:26:47 <slack1256> *in the compiler context(sorry)
08:27:06 <applicative> is it the equivalent of the rts?
08:27:48 <bscarlet> for C, I'd call gcc the driver to distinguish it from cc1
08:28:38 <bscarlet> i.e. the thing that looks at filenames and suffixes and such and coordinates getting from a bunch of source files to a library or executable
08:29:07 <kqr1> what is something of kind * -> * called?
08:29:11 <kqr1> is it a type constructor?
08:29:25 <applicative> kqr1: yes, but of course thats not as precise
08:29:25 <b2coutts> kqr1: yes
08:29:43 <kqr1> and then what do you call the constructors you use to create values of those types?
08:29:50 <applicative> 'type constructor' also seems like it means the word
08:29:58 <applicative> data constructors
08:30:01 <kqr1> ah
08:30:11 <mizu_no_oto> Since this hadn't been answered before, trying again - is there a accepted term for typeclass instances of the form "Foo a => Bar (Quux a)"?
08:30:11 <dm> hello world
08:30:30 <applicative> kqr1: I'm not sure if this is general type jargon or haskell specific
08:31:00 <slack1256> oh OK
08:31:02 <ClaudiusMaximus> is there a library that has something like   parMapIO_' :: Int -> (a -> IO b) -> [a] -> IO ()  that runs each action in one of a pool of worker threads?  using 'spawn' package's parMapIO_ and pool creates a zillion threads that wait to run (while consuming lots of memory)
08:31:29 <kqr1> applicative, in this case i'm using it in a haskell context, so that's ok
08:31:36 <mizu_no_oto> Or is there not an accepted term?
08:31:45 <slack1256> @hoogle Int -> (a -> IO b) -> [a] -> IO ()
08:31:45 <lambdabot> No results found
08:32:03 <slack1256> @hoogle (Monad m) => Int -> (a -> m b) -> [a] -> m ()
08:32:03 <lambdabot> No results found
08:32:25 <elliott> mizu_no_oto: er, instances?
08:33:27 <mizu_no_oto> Not just instances in general.  But ones like "Ord a => Ord (Maybe a)" or "Monad m => Monad (Yoneda m)"
08:34:07 <dm> I have to do a foldl on a list with 10^12 elements. The folded type is a Data _ _ _ _ and it is being heap allocated, and then gc'ed (I think) immediately after, but this is thrashing terrabytes of heap. What now?
08:34:20 <mizu_no_oto> elliot: I've been calling them "conditional instances", but I'm not sure if that's standard.
08:34:30 <mizu_no_oto> elliott, rather
08:35:06 <elliott> mizu_no_oto: ok, well in that case Foo = Bar so it's more clear
08:35:14 <elliott> I would say they're transformers, perhaps
08:35:19 <elliott> Yoneda is a monad transformer, Maybe is an Ord transformer
08:35:28 <elliott> of course this implies some reasonable assumed laws about how the instances relate to me
08:35:46 <mizu_no_oto> elliott: Foo can equal Bar, but doesn't have to
08:36:30 <slack1256> dm: the elements of the list are also Data _ _ _ _?
08:36:33 <kqr1> mizu_no_oto, i would say something along the lines of "instances with type constraints"
08:36:44 <lasticot> I'm sorry to insist but is it good practice to call randomRIO to get a new seed for mkStdGen as done in  http://lpaste.net/91460
08:37:02 <dm> slack1256: True!
08:37:10 <ClaudiusMaximus> dm: if it's actually slow (I measure productivity with +RTS -s) then try +RTS -A16m to increase the size of the allocation area, then only long-lived objects need to be copied in GC - but in general it's not so much of a problem to allocate a lot of shortlived data; also: foldl' instead of foldl
08:37:16 <mizu_no_oto> For example, you could say something like "Semigroup a => Monoid (Maybe a)"
08:37:36 <elliott> mizu_no_oto: perhaps mumble mumble "lifting"
08:37:50 <slack1256> dm: As ClaudiusMaximus says, but also the strictness of foldl' is only on the outmust constructur
08:37:51 <elliott> maybe it's a functor!
08:37:56 <elliott> from the category of semigroups to the category of monoids.
08:37:59 <elliott> actually, I think it is.
08:38:00 <elliott> maybe.
08:38:11 <dm> ClaudiusMaximus: foldl' check, I've seq'ed each _ in Data _ _ _ _
08:38:12 <slack1256> if you are iterating with ?Data _ _ _ _' you need to enforce evaluation on the constructors
08:38:37 <mizu_no_oto> elliott: Also, there's "Integral a => Ord (Ratio a)" in Prelude
08:38:53 <elliott> well, that is just a regular instance really.
08:38:57 <elliott> no better term for it IMO
08:39:10 <slack1256> can you profile to see what is being retained on the heap? (the list of 10^12 elements or the accumulator in the foldl?)
08:39:14 <geekosaur> lasticot, really you should only seed the PRNG once
08:39:33 <ClaudiusMaximus> dm: maybe make the fields in the data declaration strict so you don't need to seq everywhere
08:39:40 <slack1256> you have given us too little information to see what is your problem :-)
08:39:54 <mizu_no_oto> It's essentially the same as the other cases - Ratio a isn't an instance Ord; a needs to be constrained.
08:40:09 <geekosaur> lasticot, also consider MonadRandom for management of the seed, rather than threading it yourself
08:40:23 <mizu_no_oto> I suppose kqr1's "type-constrained instance" is a good term
08:40:37 <lasticot> geekosaur: that's what I thought, ok I'm gonna look into that
08:40:48 <elliott> mizu_no_oto: sure, but "instance" does not imply unconstrained
08:40:53 <elliott> unconstrained is just a special case, really.
08:40:54 <dm> <-- reading up on +RTS -s
08:40:54 <ClaudiusMaximus> dm: and once you have that, maybe -funbox-strict-fields would speed it up a fraction (you're using -O2 already of course?, I had a 10% speedup with -fllvm -optlo-O3 too
08:40:55 <geekosaur> or trying to avoid threading by reseeding at each call
08:41:42 <slack1256> dm: compile with -prof and friend to see what is being retained
08:41:54 <mizu_no_oto> elliott: fair enough.  Mostly, it's useful to have a term for it when talking to e.g. OO programmers
08:41:59 <slack1256> +RTS -s gives general information, not per cost center
08:42:07 <slack1256> *friends
08:43:08 <mizu_no_oto> elliott: You can easily emulate "instance Ord Int" in OO languages.  But "instance Ord a => Ord [a]" is, so far as I know, not particularly easy to emulate
08:43:35 <kqr1> mizu_no_oto, you might want to avoid it altogether in those cases. saying e.g. "which can only be used with enumerable things" goes a long way further than the general "type-constrained" if they are unaware of the idiom
08:44:26 <elliott> mizu_no_oto: sure
08:44:57 <mizu_no_oto> Well, you could say "type-constrained instances, like having a List that's ordered iff it's a list of orderable things, or has sane equality iff its items have sane equality"
08:46:53 <kqr1> mizu_no_oto, i guess that depends a little on who you talk to as well. my peers are not at all used to formal language and would hide in a corner if i so much as breathed "iff"
08:47:33 <kqr1> mizu_no_oto, so i'm used to turning everything into different concrete examples until they can form their own intuition for it
08:47:40 <mizu_no_oto> I'd probably actually use a slightly more verbose way of saying the same thing, in practice
08:48:31 <mizu_no_oto> That's a good approach, but it's useful to have a name for the concept you're making concrete examples of
08:48:42 <kqr1> i guess
08:51:53 <slack1256> any of you in a single threaded enviorement use MVars instead of IORef just because of the more robust semantics?
09:07:55 <sclv> @remember carmack Everything that is syntactically legal that the compiler will accept will eventually wind up in your codebase.
09:07:55 <lambdabot> Good to know.
09:08:57 <ptc> such a good quote
09:10:11 <ocharles> that is a great quote
09:12:50 <sm> ha
09:15:50 <dmj> wonder if he'll opensource his wolfenstein port
09:18:30 <FreeFull> dmj: I'm pretty sure he will
09:20:44 <dmj> FreeFull: cool
09:23:40 <ousado> sclv: what's the context?
09:24:53 <mizu_no_oto> ousado: Carmack talking at quakecon about the cost of having large programs in dynamic languages, or of just having impure code
09:26:11 <mizu_no_oto> i.e. if you're a manager for a midsized development team, then whatever the tools let someone do, someone will do.
09:26:26 <DrTeggy> Unless he runs his Armadillo rockets on Haskell, he doesn't mean it. ;-)
09:36:22 <Nachy> How many people are in the ghc core team?
09:36:29 <Nachy> looking at the wiki looks small
09:38:35 <byorgey> Nachy: it is small.  depending how you count, I suppose somewhere between 2-4
09:39:22 <ousado> mizu_no_oto: I see. good.
09:43:40 <merijn> Haha, that haskell goto implementation is lovely :)
09:44:05 <ion> Which Haskell goto implementation?
09:44:10 <slack1256> reddit one?
09:44:11 <merijn> http://www.reddit.com/r/haskell/comments/1jk06q/goto_in_haskell/
09:44:18 <ion> thanks
09:46:15 <merijn> I eargerly await the upload of acme-goto, to be followed by acme-comefrom :)
09:49:07 * geekosaur thought there already was one, possibly in oleg's mother of all monads thing
09:49:54 <merijn> geekosaur: "Oleg did it" is the haskell version of "Gauss did it"
09:51:14 <k00mi> not quite as lovely as http://augustss.blogspot.de/2009/02/regression-they-say-that-as-you-get.html
09:51:37 <tromp_> i remember a southpark episode full of "diddy did it"
09:58:02 <Gracenotes> hm, this is disappointing. Amazon tells me I won't be receiving Parallel/Concurrent Haskell today
10:00:14 <Gracenotes> "Still want it? We'll keep on trying. To keep your order for this item open, please click the link below. Otherwise, we'll cancel your order on September 01, 2013, if we haven't located it by then."
10:06:03 <tortrot> does anyone know what it is called to take a data structure, and do sort of a permutation on it except where all possible combinations are involved(including repeating ones)? So if my data type had types A, B, and C I could get AAA, AAB, AAC ABA, ABB, ABC etc?
10:06:52 <tortrot> if I was doing it for length of 3
10:07:42 <b2coutts> tortrot: are you asking what this is called, or how to do it?
10:08:10 <tortrot> b2coutts: well, I suppose a bit of both. (:
10:08:44 <b2coutts> also, would you consider AAB and ABA to be distinct?
10:08:52 <tortrot> yes
10:09:03 <b2coutts> (note that such a function in haskell would only make sense if all the datatypes were the same)
10:09:20 <b2coutts> since the function would need to be something like [a] -> [(a,a,a)]
10:09:35 <b2coutts> er, f a -> [(a,a,a)]
10:09:56 <b2coutts> otherwise the type of the resulting tuple would change depending on the order
10:10:11 <tortrot> Yeah, what I'm doing is trying to run a general function over a large list of differing inputs to see how it changes
10:10:32 <tortrot> I know at 20,000 copy and pastes I'll be done (: haha
10:10:41 <Gracenotes> [a] -> [[a]] would be more general
10:10:52 <Gracenotes> but the length of the output lists won't be encoded in the type
10:11:11 <Gracenotes> @hoogle [a] -> [[a]]
10:11:11 <lambdabot> Data.List inits :: [a] -> [[a]]
10:11:11 <lambdabot> Data.List permutations :: [a] -> [[a]]
10:11:11 <lambdabot> Data.List subsequences :: [a] -> [[a]]
10:12:15 <Gracenotes> > sequence $ replicate 3 "XYZ"
10:12:16 <lambdabot>   ["XXX","XXY","XXZ","XYX","XYY","XYZ","XZX","XZY","XZZ","YXX","YXY","YXZ","Y...
10:13:48 <tortrot> Gracenotes: that last ones looks like ze one. Thanks! Any chance you know what doing that is called, would it still be referred to as a permutation or does it completely not fit that category
10:15:25 <Gracenotes> this is equivalent to (and, below, a 3-tuple can be used)
10:15:27 <Gracenotes> > [ (a,b,c) | a <- "XYZ", b <- "XYZ", c <- "XYZ" ]
10:15:28 <lambdabot>   [('X','X','X'),('X','X','Y'),('X','X','Z'),('X','Y','X'),('X','Y','Y'),('X'...
10:16:58 <joelteon> :t mapM
10:16:59 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
10:17:44 <joelteon> > "XYZ" >>= \a -> "XYZ" >>= \b -> "XYZ" >>= \c -> [(a,b,c)]
10:17:45 <lambdabot>   [('X','X','X'),('X','X','Y'),('X','X','Z'),('X','Y','X'),('X','Y','Y'),('X'...
10:17:46 <bjorkintosh> oh. hello nerdites.
10:18:14 <joelteon> @pl "XYZ" >>= \a -> "XYZ" >>= \b
10:18:14 <lambdabot> (line 1, column 29):
10:18:14 <lambdabot> unexpected end of input
10:18:14 <lambdabot> expecting letter or digit, operator, pattern or "->"
10:18:19 <joelteon> @pl "XYZ" >>= \a -> "XYZ" >>= \b -> [(a,b)]
10:18:19 <lambdabot> ("XYZ" >>=) . flip flip [] . ((:) .) . (,) =<< "XYZ"
10:18:30 <joelteon> i do love bind operators coming from both directions
10:19:04 <flux0r> :t flip flip []
10:19:05 <lambdabot> (a -> [a1] -> c) -> a -> c
10:20:18 <tortrot> Hopefully this week I can tackle learning about binds. They look souper.
10:20:34 <flux0r> :t ((,) =<<)
10:20:35 <lambdabot> (b -> a) -> b -> (a, b)
10:21:04 <MrRacoon> :t (=<<)
10:21:05 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:21:21 <MrRacoon> :t (>>=)
10:21:22 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:21:48 <flux0r> > ((,) =<<) (1 +) 3
10:21:49 <lambdabot>   (4,3)
10:22:24 <h4199> > ((,) =<<) show 1
10:22:25 <lambdabot>   ("1",1)
10:22:55 <ion> > (,) =<< show $ 1
10:22:56 <lambdabot>   ("1",1)
10:22:58 <ion> > (,) <*> show $ 1
10:23:00 <lambdabot>   (1,"1")
10:23:15 <h4199> > (show &&& id) 1
10:23:17 <lambdabot>   ("1",1)
10:23:20 <h4199> oops
10:23:32 <h4199> > (id &&& show) 1
10:23:34 <lambdabot>   (1,"1")
10:23:56 <h4199> oh wait no that was right
10:24:25 <tortrot> :t (.)
10:24:26 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:26:03 <tortrot> :t ($)
10:26:04 <lambdabot> (a -> b) -> a -> b
10:27:45 <tortrot> bind seem just like that just in m-mode to me
10:28:03 <elliott> ($) is closer to ap/(<*>).
10:28:10 <elliott> :t ap
10:28:10 <lambdabot> Monad m => m (a -> b) -> m a -> m b
10:28:44 <banister> :t <*>
10:28:45 <lambdabot> parse error on input `<*>'
10:28:52 <banister> :t (<*>)
10:28:53 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:28:55 <tortrot> ahh yes it does
10:29:32 <banister> elliott: did you hear john carmack is rewriting wolfenstein in haskell?
10:29:39 <flux0r> :t pure (,,)
10:29:40 <lambdabot> Applicative f => f (a -> b -> c -> (a, b, c))
10:30:06 <leroix> looking for someone with experience using postgresql-simple. I have a quick question about connecting to the db
10:30:10 <flux0r> :t pure (,,) show <*> show <*> show
10:30:11 <lambdabot> Show a => a -> (a, String, String)
10:30:16 <banister> flux0r: interesting, what does the ,, mean there?
10:30:26 <flux0r> :t (,,)
10:30:27 <lambdabot> a -> b -> c -> (a, b, c)
10:30:35 <h4199> > (,,) 1 2 3
10:30:35 <flux0r> (,,) 1 3 4
10:30:36 <lambdabot>   (1,2,3)
10:30:44 <banister> flux0r: oh a 2-tuple ?
10:30:46 <banister> 3 tuple
10:30:52 <h4199> yeah
10:31:11 <flux0r> yep
10:31:22 <banister> interesting i had no idea i could do that
10:31:26 <flux0r> i saw something like that somewhere and this (<*>) discussion reminded me of it
10:32:08 <b2coutts> :t (,,,,,,,,)
10:32:09 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> (a, b, c, d, e, f, g, h, i)
10:32:16 <b2coutts> haha
10:33:23 <h4199> you can do more than just that, "TupleSections: Enables the use of tuple sections, e.g. (, True) desugars into x -> (x, True). "
10:33:45 <h4199> It is a language extension
10:34:40 <flux0r> are you sure it's an extension? it seems like just function application
10:34:45 <flux0r> :t (,) True
10:34:46 <lambdabot> b -> (Bool, b)
10:34:59 <c_wraith> flux0r:  the extension is allowing partial sections
10:35:04 <h4199> yeah
10:35:04 <flux0r> oh right
10:35:06 <c_wraith> :t (, True)
10:35:07 <lambdabot> Illegal tuple section: use -XTupleSections
10:35:23 <flux0r> i see
10:36:16 <c_wraith> It works pretty nice.  (,0,) :: Num t => a -> b -> (a, t, b)  for instance
10:36:29 <c_wraith> You can include any number of arguments in any position
10:36:36 <flux0r> this is the second time i've been on this channel and i've learned so much awesome stuff just watching
10:37:09 <c_wraith> and it'll make the empty positions arguments of the function that results, in left-to-right order
10:37:35 <flux0r> that's cool
10:37:52 <c_wraith> (5,,,"foo",) :: Num t => a -> b -> c -> (t, a, b, String, c)
10:38:20 <c_wraith> basically, everything about it works exactly like you'd hope - except that it's an extension, not just built into the language. :)
10:40:49 <tortrot> flux0r: I feel the same way! This is great channel.
10:46:11 <quchen> Using the unsafe* functions, I can make impure functions (seemingly) pure. Is there some way of doing the reverse, i.e. changing the value of an immutable variable? (Don't worry, I'm not trying to actually do this, just curious)
10:46:53 <quchen> I remember some blog post using FFI calls to modify its own code, but that sounds even hackier than what I have in mind
10:47:25 * hackagebot git-annex 4.20130802 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130802 (JoeyHess)
10:47:39 <joelteon> :t (,,,,3,,,,)
10:47:40 <lambdabot> Illegal tuple section: use -XTupleSections
10:47:45 <joelteon> rats
10:56:02 <nerrz> why does this have a runtime error of "type variable source ambiguous": cs <- filter (\c -> and (map (\i -> c =~ i :: Bool) ignored)) <$> getDirectoryContents dir
10:56:18 <nerrz> where ignored is a list of Strings
10:56:25 <haasn> =~ ?
10:56:39 <nerrz> regex matching
10:56:55 <haasn> then I'd look into that package to figure out what that runtime error means, I doubt it's coming from any of the other names
10:58:06 <nerrz> it is just that "regex" =~ "test" :: Bool works in ghci, so I am confused.
10:58:18 <enthropy> @src all
10:58:18 <lambdabot> all p =  and . map p
11:00:04 <nerrz> enthropy: thanks for the tip
11:00:35 <leifw> :t and . map
11:00:41 <lambdabot>     Couldn't match type `[a0] -> [b0]' with `[Bool]'
11:00:44 <lambdabot>     Expected type: (a0 -> b0) -> [Bool]
11:00:45 <lambdabot>       Actual type: (a0 -> b0) -> [a0] -> [b0]
11:09:12 <koala_man> what's a typical, real world range for %GC time?
11:09:23 <tromp_> @let pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
11:09:25 <lambdabot>  Defined.
11:09:29 <tromp_> > pascal!!32!!9
11:09:34 <lambdabot>   mueval-core: Time limit exceeded
11:09:50 <tromp_> > pascal!!5!!2
11:09:53 <lambdabot>   10
11:09:57 <tromp_> > pascal!!32!!9
11:10:00 <lambdabot>   28048800
11:10:21 <Gracenotes> > pascal !! 10
11:10:24 <lambdabot>   [1,10,45,120,210,252,210,120,45,10,1]
11:15:01 <byorgey> @let choose n k = foldl' (\z i -> z * (n-i+1) `div` i) 1 [1..k]
11:15:02 <lambdabot>  Defined.
11:15:11 <byorgey> > 32 `choose` 9
11:15:12 <lambdabot>   Ambiguous occurrence `choose'
11:15:12 <lambdabot>  It could refer to either `L.choose', defined...
11:15:20 <byorgey> oops
11:16:06 <byorgey> anyway, it's 28048800
11:16:35 <luite> > 32 `L.choose` 9
11:16:39 <lambdabot>   28048800
11:16:56 <byorgey> oh, heh, I didn't notice that tromp_ ended up computing it after all
11:17:18 <tromp_> hi, Brent:)
11:17:24 <byorgey> hi =)
11:17:34 <roconnor> I got another book request for Haskell form Packt Publishing today.
11:17:37 <tromp_> i was looking at IBM's Ponder This for august
11:18:47 <byorgey> roconnor: a book request?  like, they want you to write one?
11:20:24 <ClaudiusMaximus> how to put something this in a .cabal file without cabal splitting it at the space and making ghc error?    ghc-options: -with-rts-opts="-A16m -N"
11:20:38 <dcoutts> ClaudiusMaximus: use Haskell string syntax
11:20:53 <dcoutts> ghc-options: "-with-rts-opts=-A16m -N"
11:21:24 <byorgey> or "-with-rts-opts='-A16m -N'" ?
11:21:30 <dcoutts> no
11:21:39 <dcoutts> that'd pass '-A16m -N' to ghc
11:21:47 <byorgey> oh, I see
11:21:58 <byorgey> man, Quoting is Hard
11:22:12 <dcoutts> there's only one level of quoting here
11:22:17 <dcoutts> Haskell string syntax
11:22:18 <ClaudiusMaximus> "-with-rtsopts=\"-A16m -N\""
11:22:23 <ClaudiusMaximus> is what worked for me
11:22:46 <dcoutts> ClaudiusMaximus: if that doesn't fail at compile time then that should fail at runtime I expect
11:23:01 <dcoutts> ClaudiusMaximus: because it will pass that string to ghc
11:24:10 <byorgey> won't it pass   -with-rtsopts="-A16m -N"  to GHC ?
11:24:22 <dcoutts> yes
11:24:25 <byorgey> (and isn't that what you want?)
11:24:27 <dcoutts> which is wrong
11:24:32 <dcoutts> there's no shell here
11:24:42 <dcoutts> $ ./foo
11:24:42 <dcoutts> foo: unexpected RTS argument: "-A16m
11:24:53 <byorgey> ahh
11:24:53 <ClaudiusMaximus> dcoutts: ah yes
11:25:01 <byorgey> Quoting is Seriously Hard
11:25:05 <dcoutts> no, it's easy
11:25:11 <dcoutts> there is only one quoting in .cabal files
11:25:28 <dcoutts> stop adding extra layers! :-)
11:25:31 <byorgey> it's easy if You Know What Is Going On.  otherwise, it's hard.
11:25:50 <byorgey> my experience with quoting is that there are always lots of layers.  So when there is only one layer, it is extra confusing.
11:25:58 <byorgey> =)
11:25:58 <dcoutts> this is uniform in all fields in .cabal files, they're either tokens with no spaces, or tokens using Haskell string syntax
11:26:13 <dcoutts> documented in the user guide
11:26:23 <dcoutts> byorgey: :-)
11:26:40 <byorgey> dcoutts: good to know.
11:26:52 <ClaudiusMaximus> dcoutts: thanks, working now
11:27:50 * monochrom has a cunning plan!
11:30:01 <b2coutts> I always get confused when I see dcoutts' name here
11:30:07 <b2coutts> especially since my userid at work is just bcoutts
11:30:15 <dcoutts> heh
11:30:17 <dcoutts> hia
11:32:53 <roconnor> byorgey: they want me to write a book: Haskell Data Analysis cookbook
11:33:01 <roconnor> apparenlty they think I know Bayesian data models.
11:33:15 <luite> cool
11:33:29 <roconnor> luite: it's somewhere between cool and spam
11:33:38 <kryft> roconnor: I've been looking for such a book :P
11:33:56 <h4199> Can you fake it for say 2-300 pages?
11:34:12 <roconnor> AFAIU Packt's business model is to, on a massive scale, invent ranodm book titles and search the internet for folish author wannabies
11:34:19 <roconnor> h4199: possibly
11:34:20 <Tene> I expect most of us could fake it for 2 pages. ;)
11:35:23 <roconnor> I wonder if anyone has made money of Packt
11:35:26 <roconnor> *off
11:35:44 <h4199> Hmm it would be a good thing to investigate,
11:35:52 <zomg> roconnor: They asked me to write an article about some PHP stuff some years ago
11:36:05 <zomg> I made some money off them with that but not a whole lot =)
11:36:08 <luite> roconnor: oh yeah it's a spammy request. just reminded me that pearl's algorithm was one of the first things i implemented in haskell to learn the language :)
11:36:55 <roconnor> zomg: really, you wrote them a book?
11:37:00 <roconnor> zomg: please tell me more
11:37:01 <zomg> Nono just an article
11:37:32 <zomg> http://www.packtpub.com/article/php-magic-features
11:37:35 <zomg> that's it
11:39:24 <h4199> Ah, they seem to use the articles to push people towards related media for sale.
11:39:36 <zomg> Yeah
11:40:02 <zomg> I recall I might have done a book review or two for them as well but that was essentially pro bono
11:40:14 <zomg> I did them mostly due to the books in question being interesting
11:40:24 <roconnor> zomg: that seems like not a bad deal, even if you only got a few bucks.
11:42:06 <h4199> I think that if a Haskell Data Analysis book were to be written I would prefer the author take the route that LYAH or RWH took.
11:44:18 <kqr1> is there a concept of "a non-empty list" anywhere in the libraries? or is that simply a useless notion?
11:44:19 <luite> i wonder what data analysis things would be specific to haskell
11:44:29 <haasn> kqr1: there's a package that provides NonEmpty
11:44:35 <kqr1> ah okay
11:44:44 <h4199> Were Bryan and Miran successful with that approach monetarily?
11:44:50 <kqr1> i don't need it for anything in particular, i was just a little curious
11:45:07 <haasn> kqr1: http://hackage.haskell.org/packages/archive/semigroups/latest/doc/html/Data-List-NonEmpty.html#NonEmpty looks like this is the one to use
11:45:48 <kqr1> haasn, is it weird to use that one /if/ you expect a non-empty list?
11:46:17 <haasn> for internal code, it may be overkill, but for public-facing APIs I'd definitely want it
11:46:24 <haasn> in particular if you want the Comonad interface or whatever it provides!
11:46:45 <kqr1> cool!
11:46:50 <h4199> I would be happy if labs just moved away from matlab for data analysis, haskell seems a tad too much to hope considering how those places work.
11:48:33 <luite> h4199: hmm, that's a good point, such a book might help sell haskell to those places
11:52:37 <h4199> They'd need something accessible to even consider it. I think Python has made strides in a few departments, but it really depends on the culture of the subdiscipline. Matlab is king in all the psychophys labs a friend of mine has worked in.
12:09:56 <shergill> i remember getting a request off packt last year
12:10:01 <shergill> about some open standards thing
12:10:40 <shergill> they never really elaborated when i asked them what basis they thought i was qualified for the task
12:11:29 <roconnor> shergill: :)
12:13:18 <Zenol> Are they network event library in haskell, or are they a awesomly better thing (as parsec is for regexp) ?
12:15:45 <roconnor> The big 6 monads: Reader, Writer, State (Transformer), Non-determinism, Continuation, Selection ... does this list sound right?
12:16:11 <byorgey> what's the Selection monad?
12:16:15 <joelteon> what's the selection mon--
12:16:31 <roconnor> byorgey: Selection r a = (a -> r) -> a
12:16:45 <joelteon> uhh, what does it do?
12:17:03 <roconnor> Selection Bool = Escardo's Search monad
12:17:18 <byorgey> ahh, cool
12:17:44 <WraithM> Does anybody know of a library for OData?
12:18:31 <elliott> roconnor: fix :: Selection a a
12:19:02 <sipa> roconnor: by State (Transformer), you mean State and ST?
12:19:25 <roconnor> Selection does some sort of witness finding thingy for functions
12:19:27 <sclv> roconnor: exception
12:19:35 <sclv> arguably you can get there from ContT
12:19:36 <roconnor> sipa: I mean State
12:19:46 <sclv> but Either is a v common monad
12:19:46 <roconnor> sclv: yes thank you
12:19:52 <roconnor> exception
12:19:59 <roconnor> the big 7
12:20:09 <sipa> Maybe?
12:20:17 <WraithM> Maybe.
12:20:25 <roconnor> Maybe counts as Exception
12:20:28 <c_wraith> Is there a MaybeNot monad?
12:20:42 <sipa> MayNotTobe
12:20:47 <roconnor> being isomorphic to Either ()
12:20:52 <sipa> agree
12:21:20 <roconnor> there is also the Identity monad and free monads, but I don't consider them part of the big 7
12:21:27 <sclv> non-det I assume covers [] as well as Logic and all the derivatives
12:21:36 <roconnor> sclv: that is my intention
12:21:36 <sclv> and variants
12:21:53 <sclv> dunno if probability distributions should count as a distinct monad
12:21:54 <roconnor> I'm presuming that LogicT Identity is equivalent to []
12:22:06 <WraithM> Parser monad?
12:22:09 <roconnor> sclv: possibly, but I don't feel that is it one of the big 7
12:22:24 <sclv> true, it just doesn't quite seem something that you can build as a compound toy
12:22:31 <sclv> as opposed to parser, which you totally can
12:22:49 <pseudolio> LogicT Identity is [], yes.
12:24:48 <roconnor> another question
12:25:04 <roconnor> What's the simplest illuminating example of a functor that isn't a container?
12:25:14 <roconnor> The best I have is Cont.
12:25:22 <roconnor> which isn't particularly simple.
12:25:41 <S11001001> roconnor: Const m
12:25:50 <roconnor> S11001001: it is a container
12:26:02 <S11001001> roconnor: not of a
12:26:26 <S11001001> do you define (->) r as "container"?
12:26:38 <roconnor> S11001001: yes
12:26:39 <simon> roconnor, lists! (when they represent non-deterministic computations).
12:26:47 <roconnor> lists are containers
12:26:51 <pseudolio> How about your completion-of-metric-space functor?
12:27:01 <simon> roconnor, because they reside in memory?
12:27:39 <WraithM> Parser? Sort of a container...
12:27:45 <roconnor> A container is a functor (isomorphic to) F a = Sigma (s:S). P s -> a
12:27:46 <S11001001> roconnor: if your definition of "container of xs" is "covariant over xs", you will not find one, even Cont z
12:28:08 <pseudolio> State, then.
12:28:24 <roconnor> pseudolio: I'm pretty sure State is a container. ...
12:28:39 <roconnor> s -> (a,s)  is isomorpic to (s -> a, s -> s)
12:28:45 <pseudolio> It doesn't match your definition of container.
12:28:50 <simon> roconnor, 'container' is a metaphor here, right? so we're asking what functor is better described using the 'computational context' metaphor, right?
12:29:25 <roconnor> take S = (s ->s) and take P = const s
12:29:26 <haasn> oh no, the containers analogy again
12:29:33 <roconnor> simon: no container is a techinical term.
12:30:14 <haasn> oh, nevermind
12:30:15 <elliott> you can't say "analogy" lines after someone gives a precise definition. :p
12:30:22 <haasn> just saw that!
12:30:25 <simon> I'm sorry, I didn't spot it :)
12:30:26 <roconnor> :)
12:30:29 <roconnor> np
12:30:30 <elliott> hehe
12:31:14 <roconnor> the nice thing about at technical term is that it ends the "analogy" debate :D
12:31:41 <sclv> afaik Cont is usually where you have to go to break the "monads as containers" analogy, and even with the precise dfn I don't see something simpler offhand.
12:31:52 <sclv> LogicT over something nontrivial might work?
12:32:07 <roconnor> sclv: yea, I might have to go with Cont.
12:32:27 <roconnor> I believe the definiton of container is the same as "strictly positive functor".
12:32:49 <pseudolio> Well, then, you need something like Cont.
12:32:50 <roconnor> so it seems like you will need something not to different from Cont to break strict positivity.
12:32:51 <pseudolio> Obviously.
12:32:56 <Saizan> roconnor: yep, it is
12:33:10 <shergill> roconnor: what do you mean by "strictly positive"?
12:33:30 <sclv> for a functor f a, a occurs only in a strictly positive position
12:33:39 <sclv> a -> b has b in a positive position, a in a negative
12:34:03 <roconnor> shergill: I'm not sure.  Whatever Coq means in it's definition of inductive types.
12:34:04 <sclv> (a -> b) -> b has b in a positive _and_ negative position, a in a positive one, but not a _strictly_ positive one
12:34:39 <sclv> positive position = you can be covariant in it (or rather you cannot be contravariant in it)
12:34:55 <sclv> negative position = you can be contravariant in it (or at least you can't be covariant)
12:35:13 <haasn> roconnor: I don't even understand your definition “Sigma (s:S). P s -> a”
12:35:27 <shergill> ok that makes sense now
12:35:30 <shergill> sclv: thanks
12:35:41 <sclv> containers in this sense come from the "containers gang" papers from ghani et al
12:35:51 <roconnor> haasn: are you familiar with Sigma types (aka dependent pair types)?
12:36:22 <haasn> ‘dependent pair types’ rings a bell, something about a pair where the type of one element depends on the type of the other
12:37:08 <roconnor> haasn: yep.  So a containers consists of two compents.  The first component is a type of "shapes"  S in this case.
12:38:00 <haasn> err, “the type of one element depends on the value of the other” is what I meant to say
12:38:07 <roconnor> Then for each shape value, it has a corresponing type of Positions.
12:38:29 <pseudolio> Except you then do things that completely violate that intuition.
12:38:29 <roconnor> so P :: S -> Type gives the type of Positions for every possible shape.
12:38:47 <roconnor> often P s is some Finite type, but not always.
12:39:25 <Saizan> pseudolio: such as?
12:39:31 <pseudolio> State. Just now.
12:40:24 <Saizan> heh, right
12:40:38 <roconnor> well State as a data type looks containerish
12:41:02 <roconnor> the fact that State is a monad has no bearing on it's status a functor
12:42:09 <Saizan> calling (s -> s) a shape is kind of a stretch
12:42:37 <sclv> if s is "small" enough it feels very natural
12:42:47 <sclv> (Bool -> Bool) is a shape!
12:42:58 <pseudolio> It is a shape that has no influence on the paths.
12:43:16 <pseudolio> It's just carrying around extra stuff for you to fit State into the definition of containers.
12:43:34 <roconnor> Saizan: ya.  If anything shape is a bad name since it also holds ancilery data
12:44:38 <pseudolio> Most parser types are also containers by this definition, as well, which was something someone else suggested.
12:44:52 <roconnor> pseudolio: interesting
12:45:28 <pseudolio> Really? It's a pretty obvious consequence of 'all strictly positive functors are containers'.
12:45:40 <roconnor> pseudolio: I suppose.
12:46:12 <roconnor> sclv: (Bool -> Bool) is Four
12:46:18 <sclv> yes
12:46:20 <roconnor> :)
12:46:57 <sclv> well lots of parsers pack some cont stuff in there for efficiency
12:47:06 <pseudolio> That's irrelevant.
12:47:16 <sclv> right. they have state like semantics
12:47:24 <pseudolio> They typically remain isomorphic to strictly positive functors.
12:47:33 <sclv> we violently agree
12:47:58 <pseudolio> That actually makes it difficult to figure out what's really strictly positive, though. :)
12:48:21 <pseudolio>  /\a -> forall r. (a -> r) -> r is strictly positive. :)
12:48:39 <sclv> parametricity!
12:48:59 <roconnor> sclv: ah good point
12:49:14 <roconnor> strictly postive functors is a syntatical definition
12:49:21 <Saizan> i'd propose: strictily positive only when syntactically so, and reserve the "up to isomorphism" for container
12:49:22 <roconnor> while containers is sematics.
12:49:40 <Saizan> right, as roconnor
12:50:31 <roconnor> We need more dual terms separating syntax and semantics. :D
12:54:42 <S_J> is memoization actually used a lot or not?
12:54:54 <pseudolio> What do you mean by memoization?
12:55:01 <chrisdotcode_> guys, which regex library should I use, if I want perl regex support?
12:56:12 <mauke> chrisdotcode_: none
12:56:14 <mauke> you should embed perl
12:56:22 <S_J> if param exists in table then get value else call function and store param and value in table.
12:56:26 <S_J> =memoization
12:57:21 <chrisdotcode_> mauke: what about the regex-pcre package?
12:57:38 <mauke> that's a binding to PCRE, which is a C++ library IIRC
12:58:41 <chrisdotcode_> mauke: is Text.Regex (and Text.Regex.Posix, whose hackage doc is down for right now) good enough?
12:58:50 <pseudolio> I can't say I see memoization used a lot. But it may depend on what you're writing.
12:58:54 <mauke> those are not even close to perl
12:59:57 <chrisdotcode_> mauke: yeah, I knew that; but hopefully they'll be good enough :)
13:00:07 <chrisdotcode_> is there a reason the Posix regex doc is down?
13:00:13 <mauke> well, that depends entirely on what you're trying to do
13:01:46 <chrisdotcode_> I don't know what I'm going to have to do yet, sadly. I just know that I"m *going* to need regexes. I'm not sure that POSIX regexes might be enough, but more importantly, I can't even find doc for it.
13:04:54 <S_J> so sick, how does someone get out of jail after 2years 8months after raping 2 14-year old girls? sometimes i despise my hippie country. and ofc he hasnt leanred his lesson, he starts chatting with udnerage girls and make them strip for him. bullet in the neck, only thing that works...
13:05:19 --- mode: ChanServ set +o mauke
13:05:20 --- kick: S_J was kicked by mauke (S_J)
13:07:09 <tortrot> chrisdotcode_: I was using pcre the other day: getStringMatches val pattern = getAllTextMatches $ val =~ pattern :: [String]
13:07:19 --- mode: mauke set -o mauke
13:07:31 <chrisdotcode_> tortrot: where's the doc for it?
13:08:22 <tortrot> chrisdotcode_: http://hackage.haskell.org/packages/archive/regex-pcre/0.94.4/doc/html/Text-Regex-PCRE.html
13:09:04 <tortrot> it uses perl instead of posix though
13:09:11 <chrisdotcode_> tortrot: yeah, thanks :)
13:09:14 <chrisdotcode_> sadly, it's not good enough.
13:09:15 <mauke> PCRE doesn't use perl
13:09:21 <mauke> :-[
13:09:29 <chrisdotcode_> *the doc isn't good enough, I mean
13:09:49 <tortrot> wait what, it doesn't... ?what am i thinking of then?
13:10:15 <mauke> perl
13:10:59 <Fuuzetsu> What's that application called that will analyse your imports and draw you a dependency diagram?
13:11:16 <tortrot> mauke: haha, well, the name is perl compatible regular expressions
13:11:41 <mauke> that's just marketing
13:11:49 <thoughtpolice> Fuuzetsu: graphmod
13:11:52 <tortrot> chrisdotcode_: yeah I was having trouble finding docs as well, sadly very little
13:12:10 <chrisdotcode_> tortrot: and it's sad, because the interfaces and polymorphism seem fantastic
13:12:48 <c_wraith> holy crap, I just looked at the source of Data.Array.IArray.  Why.....  Why does it work that way?
13:13:46 <Fuuzetsu> thoughtpolice: thanks
13:13:48 <tortrot> mauke: hmm, I'm looking at the wikipedia page and you are right! They are close though eh. Suprising
13:13:49 <c_wraith> Things I've learned from this experience include "don't create instances of IArray that aren't just newtypes.  They won't work."
13:15:57 <tortrot> chrisdotcode_: yeah, it was fun trying to figure out how to match (for a newb like me)
13:16:16 <chrisdotcode_> tortrot: hey, well I'm also relatively new, and so I suggest I"m about to have your problems...
13:17:30 <allsystemsarego> Hi all, why does import System.Timeout followed by timeout 5000 (putStrLn "blabla") not wait 5 seconds before outputting "blabla" in ghci?
13:17:56 <tortrot> chrisdotcode_: good luck! I put what I came up with on github if you wanna take a look,
13:18:02 <supki> allsystemsarego: it's in microseconds
13:18:04 <elliott> c_wraith: hm, what is the problem?
13:18:05 <chrisdotcode_> tortrot: sure :)
13:18:16 <tortrot> chrisdotcode_:http://goo.gl/PLf6Hj
13:18:22 <allsystemsarego> oh
13:18:34 <allsystemsarego> ok, let me try again with 5 million
13:18:59 <c_wraith> elliott: everything is implemented in terms of unsafe operations from GHC.Arr and GHC.IOArray
13:19:08 <allsystemsarego> supki, still no luck with 5 million
13:19:18 <c_wraith> elliott: if you have a type that isn't compatible with their representation, it's not going to go well
13:19:26 <elliott> hm
13:19:28 <elliott> that sounds like a bug
13:19:30 <elliott> arguably
13:19:30 <supki> allsystemsarego: ok, timeout also doesn't work as you think it does :)
13:19:45 <supki> allsystemsarego: you want Control.Concurrent.threadDelay or something
13:20:01 <allsystemsarego> ok, let me try that
13:20:06 <allsystemsarego> brb
13:20:09 <c_wraith> does cabal default to -O for ghc?
13:20:12 <chrisdotcode_> tortrot: thanks :)
13:20:17 <mauke> c_wraith: AFAIK yes
13:20:30 <dcoutts> c_wraith: yes, you can override with cabal configure -O0
13:20:36 <bryanvick> I'm using utf8-string, should I be converting to String to cons 2 together, then back to ByteString?
13:20:43 <c_wraith> mauke, dcoutts: thanks
13:20:57 <tortrot> chrisdotcode_: np! It probably isn't the best code, but might help a bit (:
13:21:11 <levi> You regex guys might want to use Text.Regex.PCRE.Light
13:21:37 <allsystemsarego> yay  Control.Concurrent works, thanks supki
13:21:41 <tortrot> levi: why is that?
13:22:20 <levi> It appears to be the intended user-level interface for Text.Regex.PCRE
13:22:44 <levi> Plus it's actually documented.
13:22:54 <tortrot> levi: I'm reading docs, I think I can see why you recommend it (:
13:23:29 * edwardk waves hello.
13:25:27 <haasn> what happens when you wave through a double slit
13:29:36 <levi> regex-applicative looks interesting, too.
13:35:46 <ion> haasn: You go through both and interfere with yourself before splatting to the back wall.
13:37:02 <structuralist> So I have some function λ :: Σ (B x) -> B (Σ x). When I write "(fmap λ . λ) . fmap (fmap λ . λ)" everything is fine. But "(\f -> (fmap f . f) . fmap (fmap f . f)) λ" doesn't typecheck. Why not?
13:38:09 <haasn> add a type signature
13:38:16 <hpc> structuralist: sounds like λ is being given different types for different instances in (fmap λ . λ) . fmap (fmap λ . λ)
13:38:17 <haasn> GHC can't infer rank-n types for n>2
13:38:33 <hpc> ...or that
13:38:57 <structuralist> haasn: you mean within the body of it?
13:39:31 <structuralist> test :: Σ (Σ (B (B x))) -> B (B (Σ (Σ x)))
13:39:31 <structuralist> test = (\f -> (fmap f . f) . fmap (fmap f . f)) λ
13:39:33 <structuralist> doesn't work
13:39:43 <haasn> :t (\f -> (f 3, f "foo")) :: (forall a. a -> a) -> (Integer, String)
13:39:44 <lambdabot>     Illegal symbol '.' in type
13:39:44 <lambdabot>     Perhaps you intended -XRankNTypes or similar flag
13:39:44 <lambdabot>     to enable explicit-forall syntax: forall <tvs>. <type>
13:39:46 <haasn> ugh
13:39:55 <hpc> :t (\f -> (fmap f . f) . fmap (fmap f . f))
13:39:56 <lambdabot>     Occurs check: cannot construct the infinite type:
13:39:56 <lambdabot>       b0 = f1 (f0 (f1 b0))
13:39:56 <lambdabot>     Expected type: f0 (f1 b0) -> b0
13:40:05 <hpc> yeah, there you go
13:40:07 <ion> @type let λ :: [Maybe x] -> Maybe [x]; λ = undefined in (\(f :: forall x. [Maybe x] -> Maybe [x]) -> (fmap f . f) . fmap (fmap f . f)) λ
13:40:07 <lambdabot> lexical error at character '\187'
13:40:11 <haasn> well, it type checks with RankNTypes enabled
13:40:19 <haasn> but removing the signature causes a type error
13:40:38 <tortrot> So I'm trying to write a function that prints the elements of a list without commas, I'm trying mapM_ with print and list but each result is on newline :o
13:41:04 <mauke> @src print
13:41:04 <lambdabot> print x = putStrLn (show x)
13:41:06 <ion> tortrot: Please give an example of the input and the output you expect.
13:41:08 <mauke> @src putStrLn
13:41:08 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
13:41:47 <structuralist> haha I didn't know "print" existed before now
13:41:56 <haasn> mapM_ putStr -- as referenced by mauke
13:42:14 <mauke> better idea: construct one string beforehand
13:42:24 <hpc> structuralist: it's mostly useless except for debugging
13:42:25 <ion> what mauuke said
13:42:27 <tortrot> ion: println [A, A, A, A, B, C, A, A] output AAAABCA
13:42:36 <hpc> where you can pepper "print (this, that, the other thing)" everywhere
13:42:39 <haasn> :t putStrLn . unwords
13:42:40 <lambdabot> [String] -> IO ()
13:42:43 <ion> tortrot: concat
13:42:45 <ion> @type concat
13:42:46 <lambdabot> [[a]] -> [a]
13:43:31 <structuralist> haasn: I still get an error with RankNTypes
13:43:48 <structuralist>     Couldn't match expected type `Σ x' with actual type `B (B x)'
13:43:48 <structuralist>     Expected type: Σ (Σ (B (B x))) -> B (B (Σ (Σ x)))
13:43:50 <structuralist>       Actual type: Σ (Σ (B (B x))) -> B (B (Σ (B (B x))))
13:44:04 <tortrot> mauke: my input isn't a string, I suppose I could loop through it and manually convert the tpyes to strings but eh, seems wrong
13:44:11 <ion> structuralist: You need the forall in the type signature.
13:44:26 <mauke> tortrot: map show
13:44:31 <mauke> now they're strings
13:44:41 <ion> @type let l :: [Maybe x] -> Maybe [x]; l = undefined in (\(f :: forall x. [Maybe x] -> Maybe [x]) -> (fmap f . f) . fmap (fmap f . f)) l
13:44:42 <lambdabot>     Illegal symbol '.' in type
13:44:42 <lambdabot>     Perhaps you intended -XRankNTypes or similar flag
13:44:42 <lambdabot>     to enable explicit-forall syntax: forall <tvs>. <type>
13:44:45 <mauke> tortrot: concatMap show
13:44:49 <mauke> now it's one big string
13:45:07 <structuralist> ion: you mean "test :: forall x. Σ (Σ (B (B x))) -> B (B (Σ (Σ x)))"?
13:45:16 <structuralist> no luck
13:45:30 <structuralist> oh I see
13:46:24 <tortrot> mauke, ion, haasn: thank you!
13:46:47 <structuralist> that works
13:47:31 <cschneid> I was talking with somebody yesterday who rarely used monad transformers. What's another approach than ReaderT to threading a configuration through an app?
13:47:54 <cschneid> (also, thanks for the Parallel and Concurrent Programming book recommendation, was great. About halfway through it).
13:47:59 <mauke> @hackage reflection
13:47:59 <lambdabot> http://hackage.haskell.org/package/reflection
13:48:12 <mauke> hhhehehe
13:48:37 <ion> cschneid: A configuration parameter everywhere? :-P
13:48:48 <cschneid> sure, the manual approach works, passing a Config type around.
13:48:57 <cschneid> is there another way, or is a ReaderT the best unobtrusive method?
13:49:03 <mauke> cschneid: see ^
13:50:58 <structuralist> thanks guys
13:51:16 <Zenol> they definitely something wrong with besites. Most of them use 1/3 of my screen width.
13:51:47 <cschneid> why is it so hard to find: "here's a simple program demoing usage of my library"
13:51:58 <mauke> it's all in the paper!
13:52:47 <supki> cschneid: there are examples in the repo
13:55:19 <elliott> there's also an hpaste I made once.
13:55:27 <elliott> @google hpaste reflection ReaderT
13:55:28 <lambdabot> http://ircbrowse.net/browse/haskell/?q=hpaste+66715
13:55:28 <lambdabot> Title: Browse #haskell
13:55:33 <elliott> :/
13:55:43 <elliott> well
13:55:45 <elliott> that does link to the paste!
13:55:51 <elliott> http://lpaste.org/66715
13:55:53 <elliott> er
13:55:55 <elliott> http://lpaste.net/66715
13:56:09 <ion> er
13:56:12 <ion> http://lpaste.xxx/66715
13:56:25 <hpc> heh
13:59:10 <enthropy> @src (\\)
13:59:10 <lambdabot> (\\) = foldl (flip delete)
13:59:45 <enthropy> is there a version of that somewhere that's good for both input lists being sorted?
13:59:59 <haasn> you probably want a Set
14:00:19 <ion> Set, if you don’t mind deduplication.
14:00:29 <haasn> (MultiSet if you do)
14:00:55 <enthropy> but Set is strict right?
14:01:31 <haasn> presumably
14:01:34 <enthropy> http://lpaste.net/91464
14:03:12 * haasn just noticed edwardk's user name: c62d1214
14:03:15 <haasn> is that the commit of edwardk we're on?
14:03:46 <ion> haasn: Is “nand” in base-36?
14:04:05 <haasn> > "nand" ^? base 36
14:04:06 <lambdabot>   Just 1086889
14:04:23 <haasn> doesn't seem like a particularly interesting number
14:04:26 <haasn> so no, I guess
14:04:49 <ion> Well, it’s interesting in its original base.
14:36:38 <exicer> Is there a socketio implementation in haskell ?
14:36:43 <exicer> or something similar ?
14:41:04 <ion> What do you mean by that?
14:42:11 <alpha123> exicer: http://hackage.haskell.org/package/websockets looks interesting
14:42:23 <alpha123> as far as socket.io I don't really know :/
14:42:35 <ion> Ah, that thing
14:43:49 <alpha123> building a socket.io-like API on top of websockets probably isn't terribly hard
14:47:29 <levi> It's harder than you might think.
14:48:25 * alpha123 has never tried so that wouldn't surprise him
14:49:31 <levi> socket.io itself was horribly broken last time I attempted to use it. I found sockjs to be much more reasonable.
14:53:04 <chrisdone> allo allo
14:53:22 <johnw> hey rm. done!
14:53:41 <chrisdone> hey mkdir wiegley
14:53:51 <johnw> :)
14:59:10 <epta> Is there any way to use ghci with syntax highlighting?
15:00:17 <ClaudiusMaximus> @where goa
15:00:17 <lambdabot> http://haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
15:01:39 <ClaudiusMaximus> oh, no syntax highlighting there, misremembered..
15:07:35 <levi> epta: Run it via emacs?
15:07:36 <liyang> Maybe a few drops of actual LSD might help with the colours.
15:17:50 <leroux> Does any function exist that does this? applyWith f g x y = g x `f` g y
15:18:37 <elliott> @src on
15:18:37 <lambdabot> (*) `on` f = \x y -> f x * f y
15:18:38 <leroux> Is this the on?
15:18:40 <leroux> Hmm.
15:18:51 <leroux> Okay. Thanks. I guess I wasn't using it correctly.
15:20:53 <leroux> elliott: Thanks. I corrected my function. I was just writing the wrong.
15:21:24 <leroux> s/the/it
15:23:10 <elliott> leroux: :)
15:26:27 <structuralist> is it true that distribFree . distribCofree = distribCofree . distribFree ?
15:27:04 <bor0> Can any other group-like structure be represented through category? E.g. can semi category be represented as a category?
15:27:36 * hackagebot storable-static-array 0.4.0.1 - Statically-sized array wrappers with Storable instances  for FFI marshaling  http://hackage.haskell.org/package/storable-static-array-0.4.0.1 (CarlHowells)
16:02:32 <sinclair|net> can anyone here recommend some good reading on the haskell programming language?
16:02:56 <liyang> Good reading or good beginners' learning resource?
16:03:25 <liyang> @where lyah
16:03:25 <lambdabot> http://www.learnyouahaskell.com/
16:04:25 <yesthisisuser> plenty of stuff on http://www.haskell.org also
16:05:10 <jfischoff> http://www.seas.upenn.edu/~cis194/lectures.html
16:05:32 <yesthisisuser> https://www.fpcomplete.com/school
16:06:47 <liyang> For a good read however, https://github.com/gasche/icfp2013-papers
16:06:53 <yesthisisuser> and http://book.realworldhaskell.org/read/ of course
16:10:22 <yesthisisuser> there is always the language report... for a "good reading" that is. not learning resource
16:11:28 <h4199> I like the functional pearl papers
16:11:32 <h4199> http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
16:12:11 <gavri> I was learning haskell a few months ago and came across two books for algorithms in haskell: chris okaski's and richard bird's
16:12:35 <gavri> now I'm learning clojure and I was searching for equivalent books for lisp and I can't find any
16:13:39 <gavri> why is it that the two most popular functional programming books on algorithms are of the ML-family?
16:13:46 <gavri> what am I missing here? :-/
16:14:54 <gavri> maybe this is question more suited for the lisp/scheme channels?
16:17:58 <levi> gavri: The functional programming community has largely migrated to statically-typed languages, which rules out most Lisps.
16:18:34 <h4199> Clojure is perhaps too young to have had that algorithm book written specifically for the language. As for lisp in general, I don't know why you can't find anything.
16:19:31 <alpha123> levi: To add to that, Common Lisp is typically written in a hybrid style anyway, sort of like JavaScript.
16:20:17 <levi> Most functional Lisp programming in the academic community was done in Scheme, and there's still a bit of it going on.
16:21:52 <sinclair|net> thanks for the reference
16:21:56 <levi> There's some interesting things going on with Racket regarding gradual typing, module systems, and enforcing contracts between typed and untyped modules.
16:22:06 <gavri> probably too vague a question, but how much of these books would translate over to lisp?
16:22:16 <levi> Scheme is a lisp.
16:22:32 <h4199> you mean the implementations in Okasaki?
16:23:04 <levi> Oh, you mean implementations of functional algorithms?
16:23:04 <gavri> yeah
16:23:45 <gavri> levi, yeah
16:24:07 <levi> Well, Okasaki did his work in ML, which like Scheme has strict evaluation.
16:24:54 <Zenol> How should i write \x -> fmap $ fmap $ x ? :)
16:25:02 <levi> I haven't looked at his book in detail, but I don't see why you wouldn't be able to implement his data structures in Scheme, especially a Scheme extended with pattern-matching syntax.
16:25:13 <FreeFull> Zenol: I think that's the same as   fmap . fmap
16:25:32 <gavri> it was actually the laziness that was worrying me
16:25:40 <FreeFull> :t \x -> fmap $ fmap $ x
16:25:41 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:25:42 <Zenol> oh yes, fmap.fmap.
16:25:44 <gavri> I thought the algorithms would be based on laziness
16:25:46 <h4199> You can write laziness into scheme
16:25:47 <FreeFull> :t fmap . fmap
16:25:47 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:26:07 <levi> Neither ML nor Scheme are lazy, and both of which allow you to build your own thunks.
16:26:18 <h4199> ^
16:26:22 <FreeFull> :t fmap fmap fmap
16:26:22 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:26:37 <gavri> what about richard bird's book? that's haskell, right?
16:26:37 <Zenol> xD
16:26:51 <Zenol> using fmap to fmap fmap insinde fmap.
16:26:57 <ReinH> aka (.).(.)
16:27:19 <Zenol> I should probably read stuff about lens, (.).(.), and all those things.
16:27:43 <Zenol> but now I just want to play at cleaning my code :)
16:28:13 <FreeFull> ReinH: Only if (.) = fmap
16:28:19 <ReinH> FreeFull: which it does.
16:28:28 <FreeFull> ReinH: Not in default Haskell
16:28:32 <ReinH> true
16:28:33 <levi> Again, it doesn't really matter. Monadic Haskell programs, or anything that relies heavily on how Haskell infers type classes, would become less convenient in other languages, but not impossible.
16:29:28 <ReinH> FreeFull: which is a rather glaring omission :)
16:31:32 <h4199> Bird's book it lovely, though as I remember he uses strict arrays for several of the early chapters, those should be fairly straightforward for naive translation if you just want to get your feet wet
16:33:35 <gavri> thanks, levi and h4199
16:35:55 <FreeFull> ReinH: You can go more general than (.) = fmap
16:36:07 <FreeFull> By using Control.Category's (.)
16:36:52 <d3lxa> can anyone explain the difference in behavior I have between GHC and GHCi when I do: myfunc :: type; myfunc = blabla VS let myfunc = blabla :: type?
16:37:01 <Cale> gavri: At least in my head, Lisps are functional programming languages in the same way that penguins are birds. It's possible to write things in a functional style in them, but it's not always the idiomatic way of doing things. Some make it easier to be functional than others.
16:37:21 <FreeFull> d3lxa: GHCi behaves as if you're in the IO monad
16:37:49 <FreeFull> Although it does special treatment for non-IO values
16:38:12 <FreeFull> Oh wait
16:38:25 <FreeFull> Misread that
16:38:31 <FreeFull> d3lxa: What difference in behaviour do you see?
16:38:32 <h4199> heh, I am putting that penguin analogy in my rotation
16:38:34 <Cale> That's correct. If the type of the expression you write is non-IO, it'll apply print to it.
16:39:02 <d3lxa> FreeFull: in GHCi I have defaulting that enforces a smaller type definition whereas with GHC I have a more general one
16:39:27 <Cale> d3lxa: Ah, yes, that too.
16:39:30 <FreeFull> That might be the monomorphism restriction
16:39:49 <Cale> Nah, GHCi turns on extended default rules by default.
16:39:59 <FreeFull> Ah
16:40:04 <FreeFull> Yeah, it does that too
16:40:06 <Cale> Well, the MR might also be helping
16:40:38 <Zenol> FreeFull> Monomorphisme restriction? It's why sometime you need forall a. ?
16:40:50 <Cale> http://www.haskell.org/ghc/docs/6.6/html/users_guide/ch03s04.html#extended-default-rules
16:40:54 <Cale> oops, that's old
16:40:57 <Cale> damnit google
16:41:06 <luite> Zenol: no, but sometiem you need a type sig to make something polymorphic
16:41:14 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
16:41:22 <luite> Zenol: if you need the forall. it's probably ScopedTypeVariables that you mean
16:42:40 <d3lxa> great, thank you =)
16:44:07 <d3lxa> for exemple I tried in GHCi and GHC: showNum :: (Show a, Num a) => a -> String; showNum = show
16:45:04 <FreeFull> d3lxa: As long as you provide the type signature, the behaviour should be the same in both
16:45:27 <d3lxa> FreeFull: how do you provide a type signature in GHCi?
16:45:45 <monochrom> unless you mean, you need to say "let" in GHCi. but that is expected.
16:45:56 <monochrom> GHCi is meant to be different from GHC in various ways.
16:46:00 <d3lxa> If I use the let x = … :: type << I have the intuitation that GHCi is free to "optimize" the type
16:46:19 <monochrom> where did you intuition come from?
16:46:44 <d3lxa> because there is a difference in behavior which gave rise to my question above
16:46:59 <FreeFull> d3lxa: You can just provide the type in the let binding like this:     let something :: sometype; something = blub
16:47:10 <monochrom> if anything, GHCi doesn't optimize anything at all
16:47:50 <monochrom> you should, instead, state the difference and ask what causes it
16:48:37 <d3lxa> FreeFull: didn't know that, it's working as expected (as in GHC) thx
16:51:50 <d3lxa> monochrom: you are right the difference is not between GHC and GHCi but in my case I thought that way because I assumed I wasn't able to specify a type signature as usual, so there is a difference between these two: let showNum :: (Show a, Num a) => a -> String; showNum = show  VS  let showNum = show :: (Show a, Num a) => a -> String
16:53:06 <d3lxa> in the first case the warning arises only when the function is used, in the 2nd case the warning is only shown when it's defined; the 2nd implementation doesn't not work on Double whereas the 1st does
16:54:50 <monochrom> you should try GHC with "showNum = show :: (Show a, Num a) => a -> String" some day.
16:55:02 <monochrom> that would be a really fair test.
16:56:34 <d3lxa> monochrom: I don't see the difference whether I use let or not in this case
16:57:04 <monochrom> GHCi makes you add "let". GHC makes you omit "let".
17:00:44 <Zenol> luite> actualy I was thinking about existantial type, but it's not for function. Sorry, I'm still a beginer :/
17:03:03 <d3lxa> FreeFull: I can confirm that using ghci -XNoMonomorphismRestriction makes the 2nd case works as the 1st one (more general type)
17:33:34 <chrisdotcode> hey guys, where are the docs for the packages I've downloaded?
17:33:55 <hpc> over there -->
17:33:58 <hpc> doh, you just missed them
17:34:17 <hpc> http://hackage.haskell.org/packages/hackage.html -- this is a good place to start
17:34:25 <chrisdotcode> hpc: heh, well of course there :p
17:34:30 <Cale> ~/.cabal/share/doc/index.html -- perhaps here
17:34:38 <chrisdotcode> but I meant, I turned on installing local docs, so where would they be?
17:34:43 <chrisdotcode> okay, thanks Cale, I'll try that out
17:34:46 <hpc> oh
17:34:48 <hpc> yeah, there
17:34:51 <hpc> lol
17:35:39 <chrisdotcode> Cale: sweet! that's awesome :)
17:35:41 <chrisdotcode> thanks :D
17:35:53 <chrisdotcode> (is there anyway to integrate those with a locally installed hoogle?)
17:37:17 <Cale> I don't know anything about that.
17:37:38 <chrisdotcode> alright, well thanks anyway :)
17:37:41 <Cale> I should probably try hoogle at some point, but for the most part, I usually end up just looking things up on hackage.
17:37:53 <Cale> (even though I have the local documentation too)
17:38:41 <edwardk_> dolio: the fact that you can use Rift g g a as a monad is obvious in retrospect. its just a particular Codensity monad.
17:39:18 <Cale> What's Rift?
17:39:26 <edwardk_> cale: right kan lift
17:39:27 <tortrot> so I'm trying to convert some values in a nested list into colors, but my implementation is super slow.. anyone wanna take a look?
17:39:45 <Cale> okay
17:39:47 <dolio> edwardk: It is?
17:40:02 <edwardk_> newtype Rift g h a = Rift { runRift :: forall r. g (a -> r) -> h r }  -- i called it CoT, my 'comonad-to-monad-transformer-transformer' when i first tripped over it
17:40:06 <hpaste> tortrot pasted “conv list” at http://lpaste.net/91467
17:40:52 <Cale> tortrot: That's quadratic time, yeah.
17:40:56 <dolio> edwardk: Oh, because g is representable?
17:41:02 <Cale> tortrot: Is there a good reason you're reversing the order?
17:41:13 <edwardk_> dolio: if you have a right adjoint it is representable (every functor C -> Set with a left adjoint is representable), so Rift g g a ~ forall r. (x -> a -> r) -> x -> r  -- flip the first arg, and you get forall r. (a -> x -> r) -> x -> r
17:41:14 <arkeet> it's cool
17:41:15 <arkeet> er
17:41:16 <arkeet> hi
17:41:26 <arkeet> wrong channel. continue.
17:41:30 <edwardk_> which is just Codensity ((->) x) ~ Codensity g
17:41:43 <tortrot> Cale: Yeah, my output where I get the Ternary's are flipped.. having it the other way cut the time in half
17:41:54 <tortrot> Case: But, even at half the time, it takes a long while
17:42:52 <Cale> tortrot: xs ++ ys takes O(length xs) time (necessarily)
17:42:58 <edwardk_> that also makes me wonder if that is a path to making a monad for any f to get the Rift f f construction  by pulling the (a -> ) out of the f, to turn f (a -> r)   into a -> f r    and then you can use it like it was Codensity f
17:43:34 <Cale> tortrot: So, you always want to make the first argument to (++) the short one. There is a trick you could also try, which in general is to do the following:
17:44:10 <Cale> Replace your (result) list type [a] with functions [a] -> [a] that add elements to the beginning of a given list.
17:44:22 <jfischoff> what is a good way to represent a category, where the types of objects are fixed and known at compile time, but the arrows between the objects are discovered at runtime?
17:44:24 <Cale> and replace [] with id, and [x] with (x:) and (++) with (.)
17:44:45 <Cale> Since (.) is O(1), this reduces the amount of work which needs to be done while concatenating.
17:45:01 <Cale> and you can apply the function to the empty list at the end to get back an ordinary list
17:45:23 <Saizan> edwardk_: then it'd be Ran from monad-ran
17:45:48 <edwardk_> Saizan: well, what i mean is that you can do so inside of the (>>=) for the monad
17:46:01 <edwardk_> Ran and Rift are related but not the same
17:46:11 <tortrot> Cale: Ok thanks. I'll try and see if I can do it (:
17:46:31 <Cale> tortrot: If you have any trouble, let me know and I can help you write it :)
17:46:32 <edwardk_> dolio: yeah
17:47:02 <tortrot> Cale: Thank!
17:48:36 <edwardk_> dolio: not sure if that f (a -> r) -> a -> f r   trick goes the right way, trying it
17:51:18 <Cale> tortrot: You might not get *super* fast performance in any case -- lists are not the most compact data structure ever and they have poor cache locality, so for image-manipulation sorts of operations, they really can't compete against a program which is using unboxed vectors for performance. Generally, you should think of lists as being like a concrete representation of loops -- anything which is going to require access
17:51:18 <Cale> ing them in an order other than the one they're already in is somewhat unnatural.
17:51:37 <Cale> (but in this case, it might be fine)
17:51:52 <edwardk_> looks like that was hopelessly optimistic
17:55:18 <tortrot> Cale: To give more background, I am creating a new list of Ternary's each step of a 1d cellular automata. So each [] is accessed once, and pretty much my prog just appends each timestep as a new []. I am just trying to render it as a bmp rather than burning my eyes on stdout.
17:56:21 <tortrot> Cale: I dunno enough about the other data structures to say one way or another (:
18:01:59 <Cale> Yeah, lists should make pretty okay 1D cellular automata
18:04:25 <edwardk_> dolio: hrmm. i was able to derive the Applicative for Rift f f   for all functors f.
18:04:40 <edwardk_> Rip ffarfar <*> Rip farfr = Rip $ \fbr -> farfr (ffarfar (fmap (\br ab a -> br (ab a)) fbr))
18:05:23 <dolio> Of course.
18:05:56 <edwardk_> which becomes:   Rip mf <*> Rip ma = Rip (ma . mf . fmap (.))
18:06:04 <edwardk_> now that i know what it looks like
18:06:24 <edwardk_> or perhaps nicer   Rip mf <*> Rip ma = Rip (ma . mf . fmap fmap)
18:10:14 <edwardk_> interestingly that makes full fledged Rift an "indexed applicative" with an index of kind (* -> *)
18:17:01 <elliott> edwardk_: farfar and farfr. good grief.
18:17:04 <elliott> *ffarfar
18:17:14 <edwardk_> it let me write the function =P
18:17:29 <edwardk_> get me usable holes in GHC and decent vim support and i'll stop thinking in hungarian
18:18:25 <elliott> hey, I'm down with seta. but some things are too far.
18:18:35 <elliott> we need an excuse to have a dual to seta called geta.
18:18:40 <edwardk_> hah
18:19:14 <piron> net?
18:20:21 <piron> (= geta in Japanese... I think.)
18:20:30 <edwardk_> i tried writing Rift as a one-parameter indexed applicative, and ouch my brain hurts. back to easy stuff
18:22:19 <tortrot> Cale: haha, I'm totally stuck on what you said. Still around?
18:31:30 <lpsmith> Is there a way to run ghc-core on .hsc files?
18:32:17 <lpsmith> Hmm, guessing I probably need to run hsc2hs first, maybe
18:34:59 <lpsmith> hmm, ghc-core doesn't seem to be working at all :-(
18:36:22 <lpsmith> I really miss the old ghc-core that would generate html
18:47:30 <Cale> tortrot: hi
18:49:34 <tortrot> Cale: hello
18:50:58 <Cale> tortrot: manage to figure it out?
18:52:08 <Cale> tortrot: So, we could write:
18:52:32 <Cale> colour A = [0,0,0,0]; colour B = [255,0,0,0]; colour C = [0,255,0,0]
18:52:51 <Cale> and then  flatten [] = id; flatten (x:xs) = flatten xs . flatten' x
18:53:19 <Cale> and similarly for flatten', we have:  flatten' [] = id; flatten' (x:xs) = flatten' xs . (colour x ++)
18:54:25 <tortrot> Cale: nope! and ok I'm following ya
18:56:16 <Cale> tortrot: and then we just have to apply the resulting function to []
18:56:55 <Cale> I just tried this with a 1920x1080 example, and it took about a second to write the long string to a file.
18:57:26 <Cale> (the result was 19MB or so)
18:58:00 <tortrot> Cale: not too shabby! what do you mean by applying the function to []?
18:58:18 <Cale> Well, what I've done is to replace the lists with functions that add elements to lists
18:58:27 <Cale> (to the beginning of a given list)
18:58:40 <Cale> To concatenate two such functions, we just have to compose them then
18:58:54 <Cale> But then at the end, we'd like to convert that back to an ordinary list
18:59:10 <Cale> So we apply it to an empty list, and it adds all the elements to the beginning of that.
19:00:05 <Cale> main = writeFile "output.big" (show (flatten (replicate 1920 (take 1080 (cycle [A,B,C]))) []))
19:01:06 <Cale> I could have used fewer parens there :P
19:02:03 <tortrot> aha ok, I didn't realize that you were passing [] to it. that makes more sense.
19:03:05 <tortrot> wow yes way way faster
19:04:48 <tortrot> Cale: ze results are beautiful. thank you!
19:05:10 <ddfisher> Hi all! I've got a (dumb) template haskell question:
19:05:14 <tortrot> Cale: Slowly but surely the concept of uhh inference / composition is sinking all
19:05:22 <ddfisher> How can I quote the value of a variable?
19:05:24 <Cale> I once blindly used this trick to improve the performance of a program which was manipulating large messes of XML and binary data (outputting terrain data for a game), so that instead of taking about half an hour and several gigabytes of memory, it took about a minute and used about 20 megs. :) That was with ByteString -> ByteString functions, but the same principle.
19:05:54 <Cale> ddfisher: I'm not sure what that means.
19:06:03 <ddfisher> Cale: I have a variable which is a list of a simple sum type, and I need an Exp to put in the body of a function.
19:06:37 <ddfisher> Cale: if I know the list before compile time, I could write e.g. [| [1, 2, 3] |]
19:06:44 <hpaste> oscarvarto pasted “Type class for distance measure” at http://lpaste.net/91469
19:07:28 <ddfisher> Cale: but if I do a calculation at compile time and want to quote the result, I don't know how!
19:08:09 <piron> Variables don't have values at compile time.
19:08:32 <ddfisher> piron: err... the template haskell variables?
19:09:09 <ddfisher> piron: that is, the variables used in template haskell code?
19:09:23 <Cale> I think I know what you want... just trying to recall what it's called.
19:09:27 <piron> Maybe you could invent a syntax for what you want to do and post a code sample, along with a short explanation of what you're trying to accomplish.
19:09:43 <Cale> Right, you want lift
19:09:54 <ddfisher> oh!
19:09:59 <Cale> class Lift t where lift :: t -> Q Exp
19:10:04 <ddfisher> yes!
19:10:06 <ddfisher> that's it!
19:10:13 <ddfisher> Cale: thanks so much!
19:10:16 <Cale> No problem
19:10:49 <Cale> piron: He wants to turn a Haskell datastructure into an expression for itself.
19:11:08 <Cale> (which is what lift does)
19:11:09 <piron> oscarvarto: You might want to look into associated type families. Or MPTCs and functional dependencies, if you're feeling a bit old-school.
19:11:29 <piron> Cale: I see.
19:11:56 <tortrot> Cale: Yes, this has drastically reduced size. I'm going to read on par / conc to try to see if I can pull that off
19:11:59 <oscarvarto> Would you mind helping a newbie? http://lpaste.net/91469 I am trying to create a type class for Distance Measures.
19:12:02 <tortrot> I mean time
19:12:33 <oscarvarto> piron: Sorry, my first day with Haskell, what is MPTC?
19:12:41 <piron> multi-parameter type class
19:12:44 <scottj> scrat
19:13:23 <Sa[i]nT> <-- starting haskell today lol.
19:14:42 <piron> oscarvarto: In a few more words: your problem is that the type you have declared for "distance" promises that it can return a value of type a, *for any a*. But what you meant was that each m determines a *single* type a which can be returned.
19:15:20 <ParahSail1n> which html/xml generation library is good
19:15:22 <piron> oscarvarto: You can tell the compiler that this is what you meant in two ways: one is to define a type-level function which takes instantiations of m and returns instantiations of a, then use that function in the type of "distance".
19:15:56 <piron> oscarvarto: (That's the "type families" way.)
19:16:23 <startling> ParahSailin: blaze-html is nice
19:16:51 <piron> oscarvarto: The second way is to think of your typeclass as a set of types, and realize that what you really want is a relation on pairs of types. MPTCs do this. Then you want the compiler to know that each "m" is really only related to one "a", and you can use functional dependencies to tell the compiler this part.
19:18:32 <enthropy> oscarvarto: you could also have something like    distance :: m -> Double
19:18:54 <edwardk_> dolio: puzzle for you
19:19:15 <edwardk_> decomposeRift :: (Functor f, Functor g) => Rift (Compose g f) h a -> Rift f (Rift g h) a
19:19:51 <edwardk_> i was able to write composeRift the other way around using grift
19:20:19 <edwardk_> going through and reasoning out the Ran-like combinators by analogy with the appropriate extensions swapped for liftings
19:20:33 <dolio> So that's: forall r. g (f (a -> r)) -> h r
19:21:10 <edwardk_> yeah
19:21:24 <edwardk_> composeRift (Rift f) = Rift (grift . fmap f . decompose)
19:21:27 <levi> Sa[i]nT: Don't be scared off by people talking about stuff you don't follow. People are generally happy to help with the problems of both experienced and inexperienced Haskellers.
19:21:30 <edwardk_> but i don't know decomposeRift
19:21:32 <hpaste> MedDev pasted “<<loop>>?” at http://lpaste.net/91470
19:21:34 <oscarvarto> piron: Thanks for your explanations. In 1) You talk about a "type-level" function. In lines 12-13 of http://lpaste.net/91469 I want to say that m takes the same "a" type variable to define a Distance Measure. Don't know how to say that
19:21:52 <piron> oscarvarto: Oh, you have a third option.
19:22:11 <piron> oscarvarto: You could define class Distance f where distance :: f a -> a
19:22:33 <piron> oscarvarto: Or some suitably constrained version of that; perhaps distance :: Fractional a => f a -> a
19:22:37 <oscarvarto> f is a type constructor
19:22:42 <piron> yes
19:23:07 <oscarvarto> that is what I was trying to encode
19:23:12 <hpaste> MedDev revised “<<loop>>?”: “<<loop>>?” at http://lpaste.net/91470
19:23:12 <piron> (Classes can range over type variables of any kind, not just types but also type constructors.)
19:23:22 <piron> (...and this is MAJORLY useful.)
19:24:05 <MedDev> Could  someone please look at my paste?  I'm a bit confused.  If i code in a constant it works fine, but if I try to grab a value from a data type once and use that as a value it segfaults or <<loop>>'s
19:26:46 <hpaste> oscarvarto pasted “Type class for distance measure (Second try)” at http://lpaste.net/91472
19:27:00 <piron> MedDev: I don't know what the problem is, and I suspect this is because you have not yet provided enough information.
19:27:15 <piron> (specifically, not enough code)
19:27:48 <piron> I bet it would be worth trying to produce a minimal reproducing example.
19:28:25 <enthropy> it might be that you're doing something like     let (i, filtered) = lowpass (i, original)
19:28:48 <enthropy> when you mean   let (i', filtered) = lowpass (i, original)
19:29:19 <MedDev> hmmm
19:31:58 <MedDev> shouldn't the code "where samps = fftWindow i" only be called once, then that static value be passed into the map? it seems to be trying to call fftWindow i for every element in the sequence?
19:32:28 <edwardk_> dolio: decomposeRift (Rift f) = Rift $ \far -> Rift (f . compose . fmap (\rs -> fmap (rs.) far))
19:33:07 <piron> Why do you believe it is calling fftWindow once for each element?
19:34:02 <piron> :t compose
19:34:02 <lambdabot>     Not in scope: `compose'
19:34:03 <lambdabot>     Perhaps you meant one of these:
19:34:03 <lambdabot>       `icompose' (imported from Control.Lens),
19:34:06 <piron> Too bad.
19:34:17 <piron> edwardk_: What's Rift?
19:34:25 <edwardk_> piron: compose is in Data.Functor.Composition
19:34:30 <MedDev> piron, just an assumption (probably wrong do to the error i'm getting) on my part
19:34:47 <edwardk_> piron: its the 'right kan lift' of a functor along another functor. i've been chasing after their meaning for a few days
19:35:06 <piron> cute pun
19:35:20 <edwardk_> right now i'm going through and beating my head against getting all the little operations that we can do in kan extensions to work here
19:35:28 <edwardk_> that pun is from the 50s ;)
19:35:50 <edwardk_> left and right Kan extensions are denoted Lan and Ran. left and right kan lifts are denoted Lift and Rift
19:35:59 <edwardk_> (because Lan and Ran were taken)
19:36:00 <edwardk_> =)
19:36:07 <piron> :)
19:36:24 <piron> Lext and Rext for uniformity, pls
19:36:41 <edwardk_> i'll go get 50 years of mathematicians to change their notation. brb ;)
19:37:01 <pentace> MedDev: The problem could also be in the way you define fftWindow, so please paste a complete, running minimal example.
19:37:42 <MedDev> pentace, yeah i'm trying to narrow it down.  kind of coded myself into a corner and running very small # of samples results in a different (rounding) error that I didn't know I had hehe
19:38:00 <oscarvarto> Can you say what should I do? My ~/.cabal/configure has the option to install packages "globally", setting user-install: False. I am using this. Should I use user-install: True? Why
19:38:22 <piron> ?where sicp
19:38:22 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized
19:38:22 <lambdabot> Packages"
19:38:29 <piron> The last one there.
19:38:51 <piron> After reading that, you will know enough to make a solid, informed decision for yourself.
19:40:27 <fragamus> Hey I was in an interview yesterday extolling the glories of Haskell and this guy said "but Haskell is a really big system".  He wanted small footprint. I replied that when compiled a Haskell program is tiny, but I really didn't know. What's the scoop on this?
19:42:26 <enthropy> fragamus: maybe that's true with compilers other than ghc
19:42:26 <startling> fragamus: GHC-compiled binaries tend to be pretty big.
19:42:38 <luite> fragamus: ghc produces pretty big statically linked executables, try jhc/ajhc
19:43:54 <piron> Well. The compiled program is tiny in the "doesn't contain GHC" sense, for most binaries.
19:44:14 <piron> compare e.g. some Python "compilers" that bundle together a Python interpreter and your code
19:46:10 <piron> On the other hand, perhaps you can convince someone that "big system" is a tradeoff rather than a simple black mark.
19:46:41 <startling> "small footprint" is usually a red herring I think.
19:46:50 <piron> When done well, "big system" can mean "lots of code I don't have to write because somebody else has done it well already".
19:54:18 <piron> I wonder what the average throughput on Freenode is.
19:54:45 <oscarvarto> piron: Thanks for your guidance. Bye ;)
19:54:50 <piron> g'luck
20:04:15 <carter> MedDev oooo, fft?
20:04:24 <MedDev> carter, yup
20:04:33 <carter> naive quadratic one?
20:04:41 <MedDev> *shrug* fftw
20:04:56 <carter> oh
20:04:56 <MedDev> just playin around with some beat onset detection :)
20:05:00 <carter> you're not writing your own
20:05:05 <MedDev> hell no :|
20:05:18 <carter> but number theory is fun!
20:05:23 <carter> + memory locality
20:05:24 <carter> + simd
20:05:33 <carter> … tis why i do it
20:05:44 <MedDev> fftw is really fast compared to a pure haskell implementation i tried off of hackage
20:06:12 <carter> yeah
20:06:13 <MedDev> and i don't have the math chops (or low level knowledge) to make something competitive
20:06:23 <carter> i'm going to work on doing that this fall
20:06:31 <carter> will probably do one version that does some C bits
20:06:36 <carter> and another that does runtime compilation
20:07:08 <MedDev> isn't that what fftw does?
20:07:13 <MedDev> compiles itself for your specific system
20:07:30 <carter> not quite
20:07:34 <carter> well
20:07:35 <carter> sortof
20:07:40 <carter> the general case
20:07:41 <carter> for FFTW
20:07:48 <carter> is "i want to do this size FFT"
20:07:56 <carter> and then it tries all the different factorization tree schedules
20:08:01 <carter> and picks the best one
20:08:05 <MedDev> neat
20:08:18 <carter> in some sense, FFTW is meant for when you're doing that single FFT size A LOT
20:09:32 <MedDev> carter, guess it was a good choice for my scenario then
20:13:41 <carter> could be
20:24:23 <edwardk_> dolio: i managed to get all the Ran stuff converted to work with Lan, but i'm having a bit of a brainfart when it comes to: adjointToLift :: Adjunction f u => u a -> Lift f Identity a
20:25:33 <edwardk_> er not to work with Lan, i mean to work with Rift
20:30:16 <solrize> djb rants a bit against fftw
20:30:16 <solrize> http://cr.yp.to/djbfft.html
20:33:15 <dolio> edwardk: The first step is yoneda.
20:33:33 <dolio> Oh, wait, lift.
20:43:11 <carter> solrize how so?
20:43:49 <solrize> carter, http://cr.yp.to/djbfft/bench-notes.html
20:44:19 <carter> oh
20:44:25 <carter> the rant is so out of date....
20:44:33 <carter> or at least some parts of it
20:44:43 <carter> some of the other points
20:44:54 <carter> are interesting and i look forward to trying to bench such things properly
20:45:11 <solrize> yeah
20:48:48 <solrize> The FFTW FAQ was written in bfnn (Bizarre Format With No Name) and formatted using the tools developed by Ian Jackson for the Linux FAQ.
20:53:03 <carter> heh
20:57:48 <xplat> adnap: not really moot, since it explains why certain instances are considered to overlap and thus excluded
20:58:19 <xplat> adnap: oop, was at the beginning of scrollback without noticing
20:58:27 <adnap> Ha
21:00:13 <adnap> Ignoring instance constraints before => "explains why certain instances are considered to overlap and thus excluded"?
21:04:01 <dolio> edwardk: I'm not sure how. I have steps for the alternate lift, but one of them looks like excluded middle.
21:04:59 <dolio> Or maybe it's just backwards.
21:06:29 <NemesisD> gah. more often than not i find reasonable things to do in in Snap are impossible
21:07:50 <dolio> Actually, one jsut doesn't make sense.
21:10:45 <NemesisD> snaplet-acid-state is so inflexible, and acid-state does not allow multiple connections per process, i've got to tunnel out the acid connection from the snaplet init via an mvar :(
21:13:29 <carter> is acid-state actively deved?
21:13:43 <carter> NemesisD is the issue snap or the other libs you're using with snap?
21:16:21 <NemesisD> carter: acid-state has recent dev on github. and i think the issue is mightybyte's snaplet-acid-state now that i think of it
21:16:34 <carter> he'll happily take patches
21:16:42 <carter> if he doesn't, i see him every month or so
21:16:46 <carter> so i can pester him :)
21:17:01 <NemesisD> hasn't responded to my pull request from about a week or so, though that fix wouldn't really solve this problem
21:17:33 <carter> what was the PR about?
21:17:41 <carter> try emailing him or ozgun
21:17:51 <Modius> Is there one iteratee library that everyone has converged on?
21:17:56 <carter> nope
21:17:58 <NemesisD> i think the way to solve this problem less awkwardly is probably to export a little more of the internals so you could say pass in an existing acid state conneciton
21:18:06 <carter> ok
21:18:07 <carter> well
21:18:11 <carter> i'm sure he's open to that
21:18:17 <carter> as long as you explain why
21:18:43 <NemesisD> the PR was about allowing an option to configure the snaplet to use the in-memory acid state
21:19:00 <carter> vs ?
21:19:19 <NemesisD> carter: yeah i figured. he's a good guy, i just tend to get frustrated when i have to do gross stuff like i have to do here ;)
21:19:39 <NemesisD> vs a local disk version
21:19:56 <carter> for perf?
21:20:16 <NemesisD> vs a remote version of acid but i bet that PR would be more involved
21:20:21 <NemesisD> for testing mainly
21:21:16 <carter> whats the use cases for these?
21:21:40 <NemesisD> for in memory or the tunneling the connection out thing?
21:22:19 <carter> what are you doing with all this? :)
21:22:53 <hdevalence> Hello, has anyone here tried to build cabal on ARM? I tried to build it using the bootstrap script, but it immediately fails the first time it tries to compile anything
21:23:10 <hdevalence> However, I can compile some other simple haskell programs
21:23:13 <NemesisD> ahh. so i'm writing an app called vigilence that acts as as a dead-man's switch with an HTTP API
21:24:05 <NemesisD> you defined named tasks and how often you expect them to be done via an API, then you ping the API when those get done and it sends alerts when it doesn't hear back in time
21:24:58 <NemesisD> example: run a backup cron task and have vigilance send you an email if it doesn't run
21:26:11 <carter> oh
21:26:12 <carter> that sound sneat
21:26:21 <carter> hdevalence which ghc version?
21:26:25 <carter> and what error messages
21:26:28 <carter> you need to share these things
21:26:30 <carter> so we can help
21:27:26 <NemesisD> what's the best way to block forever in main
21:27:36 <NemesisD> forever being i guess until the program gets a SIGINT
21:28:12 <carter> whats the reason for wanting to block
21:28:12 <NemesisD> i figure i could create an mvar but i feel like i've done that before and got a blocked indefinitely error
21:28:27 <carter> whats the higher level goal
21:28:49 <NemesisD> carter: i've spawned threads for all the things that i need to do that all by design run forever: a web server and some worker threads
21:28:57 <carter> ok
21:29:20 <carter> have main wait for them to return :)
21:29:30 <carter> and then throw an error message if they do :)
21:29:42 <NemesisD> how do i wait for them to return when they don't
21:29:49 <carter> i'm saying
21:29:53 <carter> that thats one way
21:29:59 <carter> eg
21:30:01 <carter> monad-par
21:30:08 <carter> lets you spawn paralle work
21:30:21 <carter> and then "don't do anything till those guys return"
21:30:36 <carter> i'm saying the error message would be dead code
21:30:39 <carter> an "impossible happened"
21:30:48 <carter> but worth having a helpful error message
21:31:29 <Flaeme> Rather than it just weirdly exiting, you can know what thread died that way.
21:31:36 <carter> yeah
21:31:45 <carter> whenever i have an impossible code path
21:31:49 <NemesisD> hmm, i wonder if async can do it. i already have a dep on that
21:31:49 <carter> i put an error message there
21:32:08 <carter> so that if something "impossible" happens, i know somethingsb roken
21:32:14 <carter> but i also know where to start
21:34:40 <hdevalence> The errors are here: http://paste.kde.org/p77fd3d9f/ ; I'm using ghc 7.6.3 with some kind of llvm backend that I got from the arch arm repos
21:35:04 <carter> hdevalence you can't use llvm 3.3
21:35:06 <carter> you're using llvm 3.3
21:35:11 <carter> aren't you?
21:36:06 <hdevalence> Yeah, I am
21:36:14 <NemesisD> hmm async seems like it is really focused on racing concurrent stuff, i don't see a way to wait for all async actions to complete
21:36:49 <hdevalence> Should I try to get another version of LLVM?
21:36:50 <carter> NemesisD monad par has something
21:36:53 <carter> hdevalence yes
21:36:58 <carter> 3.1 def will work
21:36:58 <NemesisD> yeah i guess ill just use that
21:37:03 <carter> i think 3.2 will too
21:37:12 <carter> but 3.1 *should*
21:38:56 <hdevalence> hmm, I see
21:39:25 <carter> eg: you can't use llvm 3.2 to build GHC
21:39:32 <carter> but works fine for normal stuff
21:39:54 <carter> ghc HEAD works fine with llvm 3.3
21:40:18 <hdevalence> Yeah, I just need to find a way to get an older version of LLVM, which I'm not really sure how to do
21:41:12 <jfischoff> has the database as categories coorespondence led to any fruitful implementations?
21:41:20 <NemesisD> carter: hmm, could you point me in the right direction on monad-par? it seems pretty oriented towards applying pure functions over lists
21:41:31 <hdevalence> carter: thanks for the help!
21:41:38 <carter> i've done IO  things with monad par
21:41:41 <carter> jfischoff what db?
21:41:48 <NemesisD> carter: and also do you have any opinions on parallel-io?
21:41:50 <carter> http://hackage.haskell.org/packages/archive/monad-par/0.3.4.3/doc/html/Control-Monad-Par-IO.html
21:41:54 <carter> NemesisD for what
21:42:02 <jfischoff> carter: http://www.categoricaldata.net/doc/introSlides.pdf
21:42:03 <carter> NemesisD you need to tell me the goal
21:42:25 <carter> jfischoff i should tell bscarlet  about that
21:42:51 <carter> NemesisD: without knowing the goal, paths to a goal are uselss
21:43:34 <carter> NemesisD: you'd do   runpario $ liftIO (myIOaction)
21:43:57 <carter> or something
21:43:59 <carter> idk
21:44:00 <carter> :)
21:44:11 <jfischoff> carter: spivak has been pushing the coorespondence for a bit, I'm wondering if anyone else finds it interesting, and if there is a Haskell implementation of some sort
21:44:20 <carter> probalby not yet
21:44:27 <NemesisD> carter: so if i have several blocking io actions i'd run: runpario $ liftIO $ sequence actions ?
21:44:32 <carter> noo
21:44:34 <carter> hangon
21:45:15 <carter> http://hackage.haskell.org/packages/archive/monad-par/0.3.4.3/doc/html/Control-Monad-Par.html
21:47:10 <carter> need to dig up the example code i had
21:47:31 <NemesisD> hmm, i think async might work as well actually. i think what i actually may want is to run these 3 things that are supposed to run forever and to abort if one of them crashes
21:47:43 * hackagebot MissingH 1.2.0.1 - Large utility library  http://hackage.haskell.org/package/MissingH-1.2.0.1 (JohnGoerzen)
21:47:48 <NemesisD> waitAnyCatchCancel :: [Async a] -> IO (Async a, Either SomeException a)
21:48:01 <NemesisD> cancels other async processes if 1 cancels
21:48:20 <NemesisD> if the first to finish throws, it captures the error and returns it
21:49:14 <carter> yes
21:49:36 <carter> ohh, i was using asynch maybe
21:50:07 <leroux> Is there a way to simplify this expression? mul x y = lit . (`mod` 7) $ (x `mod` 7) * (y `mod` 7)
21:50:42 <carter>  (x * y ) `mod` 7 ?
21:50:54 <leroux> I need to use lit.
21:51:00 <leroux> lit = Mod7
21:51:06 <leroux> newtype Mod7 = Mod7 Integer
21:51:57 <leroux> I could get rid of the two extra (`mod` 7)'s but it'd simplify the computation for big integers.
21:54:05 <leroux> Ehh, I guess (lit $ (x * y) `mod` 7) will suffice for now.
21:54:55 <byorgey> leroux: lit = Mod7 doesn't sound right,  what does  lit 23  give you?
21:55:15 <leroux> λ: lit 23
21:55:15 <leroux> 23
21:55:15 <leroux> it :: Expr a => a
21:55:23 <carter> whats the goal here?
21:55:31 <leroux> carter: It part of the course byorgey taught.
21:55:34 <leroux> Homework 5.
21:55:37 <byorgey> right, but 23 is not allowed.  lit should do a (`mod` 7) operation.
21:55:40 <leroux> http://www.cis.upenn.edu/~cis194/hw/05-type-classes.pdf
21:55:52 <leroux> Ahh.
21:55:57 <leroux> Right.
21:55:59 <byorgey> leroux: in that case you can simplify mul further
21:56:02 <leroux> Sorry, I wasn't thinking.
21:56:10 <byorgey> no worries =)
21:56:23 <leroux> I have this now ( mul x y = lit . (`mod` 7) $ (x `mod` 7) * (y `mod` 7))
21:57:28 <byorgey> leroux: what is the type of x and y?
21:57:36 <leroux> x and y are Integers.
21:57:42 <leroux>  mul :: Integer -> Integer -> a
22:00:02 <byorgey> that's not the right type for mul
22:00:35 <byorgey> you should be able to write things like   mul (mul (lit 3) (lit 4)) (add (lit 2) (lit 7))
22:04:55 <mgccl> How to enforce a the type class for data? for example data Stuff a, and I want to make sure a must be of Ord or something.
22:07:13 <leroux> λ: mul (mul (lit 3) (lit 4)) (add (lit 2) (lit 7)) :: Mod7
22:07:13 <leroux> Mod7 3
22:07:13 <leroux> Ahh, I see my mistake.
22:07:13 <leroux> I defined my lit wrong.
22:07:13 <leroux> I did lit = Mod7 instead of lit = Mod7 . (`mod` 7).
22:07:13 <leroux> byorgey: λ: mul (mul (lit 3) (lit 4)) (add (lit 2) (lit 7)) :: Mod7
22:07:13 <leroux> Mod7 3
22:07:13 <leroux> Is that okay?
22:07:13 <leroux> I guess I should use your test functions now.
22:07:13 <leroux> Thanks for your help.
22:09:38 <startling> mgccl: myfunction :: Ord a => Stuff a -> whatever
22:10:35 <mgccl> startling: oh, so I can't define a data that always enforce this... all the type variables are free in data declaration...
22:10:53 <startling> mgccl: I think you can with an extension, but it's a bad idea.
22:11:19 <startling> iirc it was removed from haskell into an extension because it was such a bad idea..
22:11:25 <byorgey> it's a bad idea because it doesn't work like one might expect, and you have to end up putting constraints on your functions anyway.
22:12:00 <pentace> Is there a way in ghc-pkg to check which packages unregistering a certain package would break?
22:14:28 <leroux> byorgey: Yeah, it's not working as expected.
22:15:38 <byorgey> pentace: yes, run 'ghc-pkg unregister certain-package' and see which packages it complains about.
22:16:26 <byorgey> leroux: how so?
22:16:43 <leroux> Well, the testExp function won't compile.
22:16:55 <leroux> It's having problems deducing (a ~ Integer) or sometthing.
22:17:11 <byorgey> leroux: do you still have  mul :: Integer -> Integer -> a?
22:17:21 <pentace> byorgey: But I don't want to unregister it in any case, just see what would happen
22:17:35 <byorgey> pentace: yeah, I didn't say it was a very good way =P
22:17:47 <pentace> :)
22:17:51 <byorgey> pentace: you can always do 'ghc-pkg dump' and grep the output
22:17:59 <byorgey> that's not a very good way either
22:18:04 <ofan> mgccl: class (Ord a) => Stuff a where ... ?
22:18:09 <leroux> Yes.
22:18:27 <byorgey> leroux: I don't understand how  mul (mul (lit 3) (lit 4)) (add (lit 2) (lit 7))  even type checks.
22:18:33 <byorgey> what is the type of lit?
22:18:41 <leroux> lit :: Integer -> a
22:18:45 <leroux> One second. I'll gist this.
22:19:04 <byorgey> so how does  mul (lit 3) (lit 4)  typecheck, if  lit 3  outputs a  Mod7, and mul expects an Integer?
22:19:05 <startling> is "a" free ?
22:19:15 <leroux> https://gist.github.com/leroux/6145284
22:19:41 <byorgey> ohh, it is using the Integer instance of Expr
22:19:46 <leroux> Mhm.
22:19:56 <byorgey> leroux: ok, anyway, those are the wrong types for add and mul.
22:20:02 <leroux> Ahh, okay.
22:20:06 <pentace> byorgey: Okay, thanks
22:21:28 <leroux> Ahh, should it be Expr a -> Expr a -> a ?
22:21:43 <leroux> Best if I try.
22:22:42 <leroux> Ok, I'm going to change the functions to adhere to (a -> a -> a)
22:23:59 <byorgey> leroux: right, a -> a -> a  is what you want
22:24:21 <byorgey> Expr a -> Expr a -> a  does not make sense, since Expr is a type class, not a type
22:24:26 <leroux> Yeah.
22:24:29 <leroux> My mistake.
22:24:45 <leroux> So rather... (Expr a) => a -> a -> a.
22:24:49 <leroux> Which is what the class does.
22:24:52 <byorgey> right.
22:44:06 <bryanvick> cls
22:50:25 <leroux> byorgey: Thanks for the help. I got it working. https://gist.github.com/6145349
22:51:01 <byorgey> leroux: cool, looks good =)
23:22:45 * hackagebot kan-extensions 3.4 - Kan extensions, Kan lifts, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-3.4 (EdwardKmett)
23:23:24 <NemesisD> jesus
23:23:36 <NemesisD> any snap-using folks around?
23:27:35 <edwardk> johnw: around?
23:27:45 * hackagebot hashable-extras 0.1.2 - Higher-rank Hashable  http://hackage.haskell.org/package/hashable-extras-0.1.2 (EdwardKmett)
23:32:34 <startling> NemesisD: I think there's #snapframework
23:36:31 <dmj> NemesisD: ocharles does a lot with snap.
23:37:45 * hackagebot tidal 0.2.2 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.2.2 (AlexMcLean)
23:45:39 <NemesisD> ocharles: ping
23:46:20 <johnw> edwardk: hi
