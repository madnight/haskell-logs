00:02:47 <chexxor> fragamus: congrats dude, any job offer is great
00:03:12 <fragamus> Thanks I guess I better learn Scala
00:03:16 <chexxor> I imagine there are only a handful of haskell jobs out there
00:03:52 <fragamus> I have to say Haskell and FP in general *must* one day become the mainstream
00:04:05 <johnw> I strongly agree
00:04:12 <johnw> it just has too many benefits for its costs
00:04:30 <fragamus> so when will it happen i wonder
00:04:34 <johnw> I'm sure there was a day when people were saying that virtual memory *must* one day become the mainstream
00:04:52 <Ralith> fragamus: give it 20 years
00:04:58 <Ralith> that seems to be the usual timeline for these things
00:05:03 <fragamus> not sure i have 20 years
00:05:28 <johnw> Java certainly didn't have to wait 20 years
00:05:48 <johnw> it's not even that old
00:06:33 <chexxor> idk, I was pretty excited about learning new languages and stuff last year, but then I became jaded when I decided that most companies just don't care what software they use. If it works, the software tools have lots of developers, and the employee candidate pool is really big, then that's best.
00:07:11 <johnw> all depends on the company
00:07:17 <johnw> certainly you shouldn't assume the whole world is like that
00:07:24 <johnw> my company only uses Haskell, and there are others
00:07:26 <fragamus> yes but at some point, a consise definition is more maintainable than bloated crap in ruby or java
00:07:39 <fragamus> what company is that
00:07:43 <johnw> fpcomplete.com
00:07:49 <fragamus> oh cool
00:08:00 <johnw> consider also Well-Typed and Galois
00:08:23 <johnw> Galois posts wanted ads from time to time
00:08:26 <chexxor> is fpcomplete pretty big?
00:08:35 <johnw> we are not big
00:09:02 <chexxor> your website and mission is kickass
00:09:14 <Ralith> johnw: well, get someone to invest Java levels of money in Haskell
00:09:15 <johnw> thanks!
00:09:26 <chexxor> johnw: you guys have an active sales team?
00:09:27 <Ralith> johnw: and make it look superficially like C++.
00:09:31 <johnw> chexxor: we do
00:09:37 <johnw> Ralith: lol
00:09:52 <johnw> I'm so tired of people touting "C-like" as if that was a reason to get excited
00:10:14 <chexxor> johnw: yeah, if you don't have sales, you're screwed. For your business, you have the hard sell, you have to really bring hard proof.
00:10:18 <fragamus> yeah
00:10:28 <Ralith> I didn't realize people commonly did that
00:10:34 <Ralith> though that's certainly an artifact of my circles
00:11:20 * hackagebot bed-and-breakfast 0.4.1 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.4.1 (JulianFleischer)
00:11:21 <johnw> you'd be surprised; it's not as hard a sell as you might think.  Companies are tired of having to scrap and rewrite huge projects every few years because the technical debt gets out of control with complex-yet-common languages like C++ or Java
00:11:22 * hackagebot data-extra 1.0.0 - Extra utilities for working on Data.* types.  http://hackage.haskell.org/package/data-extra-1.0.0 (ChrisDone)
00:12:07 <johnw> it's more a matter of selling them on long-term benefits vs. short-term gains
00:12:31 <johnw> and then, when you become capable with Haskell, even the short-term gains are not as different
00:12:49 <enthropy> is there something like http://hackage.haskell.org/packages/archive/html/1.0.1.2/doc/html/Text-Html-BlockTable.html for blaze-html?
00:13:32 <chexxor> johnw: If the sale isn't so difficult, your company must be growing, then?
00:13:42 <johnw> we have to have something to sell first
00:13:46 <johnw> and we're working on it, believe me :)
00:16:12 <fragamus> can someone tell me what to hate about scala as compared to haskell
00:16:20 <elliott> no
00:16:28 <elliott> well, yes.
00:16:34 <elliott> but it'll probably get old quickly.
00:16:51 <Ralith> #scala might be a better place to ask
00:17:01 <fragamus> right
00:17:03 <johnw> we prefer to talk about what we love about Haskell
00:17:04 <dmj`> johnw: any thoughts on high-end video tutorials with haskell? Like peepcode.com style?
00:17:12 <elliott> I don't recommend joining #scala to ask how it's worse than Haskell.
00:17:14 <SaBer> fragamus: My personal opinion is that scala has too much syntax, where as in haskell most of the stuff is just implemented as functions
00:17:15 <johnw> dmj`: my thoughts: is good!
00:17:23 <elliott> anyway you can ask edwardk and dolio. they know the pains of Scala well. :p
00:17:31 <dmj`> johnw: like "hey here's how to connect to mysql", was wondering if fpcomplete was tossing that around at all
00:17:39 <dmj`> in a video that is
00:17:48 <johnw> edwardk will say that he likes purity and laziness by default
00:18:04 <johnw> dmj`: I wonder if a video like that could win our monthly contest...
00:18:10 <johnw> if you show the code as well, I believe it might
00:18:23 <fragamus> but purity can be achieved as a discipline right?
00:18:45 <johnw> disciplines never work
00:18:54 <johnw> never ever ever ever
00:19:19 <fragamus> never ever^3 ?
00:19:50 <johnw> it's like carmack says: anything that is syntactically allowed by the compiler will end up your codebase over time
00:20:12 <c_wraith> I've yet to use implicit params.
00:20:16 <chexxor> I agree with that one john
00:20:23 <c_wraith> as long as I pretend they're not syntactically allowed, I'm good.
00:20:37 <dmj`> and also: in a knock on scala: "multi-paradigm just means you can cheat and do the wrong thing when its convenient"
00:20:53 <fragamus> so pretending works but never ever^3 discipline
00:21:18 <chexxor> johnw: do you have case studies that Haskell code base is better long-term benefits?
00:21:23 <c_wraith> fragamus: it helps when you have to go out of your way to enable them.
00:21:32 <johnw> chexxor: there's just a lot more you can't get away with in Haskell
00:21:44 <johnw> chexxor: http://www.haskellforall.com/2013/08/sometimes-less-is-more-in-language.html
00:22:15 <johnw> and only if you just can't do it will that stop being from doing it
00:22:21 <johnw> s/being/people
00:24:23 <dmj`> "complexity is opt-in when you program in Haskell" cool
00:32:02 <chexxor> HO! Just hand-checked that my 4-peg hanoi algo works with 4 discs.
00:34:11 <chexxor> but not for 5 discs :(
00:37:53 <dmj`> www.chicagohaskell.com will prob meet this summer fyi.
00:38:44 <johnw> oh really!
00:38:55 <johnw> i'll come for that
00:39:22 <dmj`> johnw: really!! yes!
00:39:32 <johnw> the date of the cloud haskell presentation couldn't be worse though
00:40:04 <dmj`> johnw: why? we can change it I bet, still up in the air
00:40:36 <johnw> in terms of our release schedule, and the fact that I'm taking a vacation in Chicago the very next week
00:40:45 <johnw> so, I really can't take off that weekend too
00:43:02 <dmj`> Are you based out of illinois? We can change the date most likely, would be great to have you
00:43:05 <johnw> yes, I'm in Peoria
00:43:10 <johnw> and I love Cloud Haskell :)
00:43:24 <johnw> I was just on the phone with dcoutts today talking about it in fact!
00:44:06 <dmj`> johnw: ahhh so cool :) finding uses for it in production?
00:44:14 <johnw> i have my eyes eagerly open to
00:44:18 <johnw> hopefully this year, if all goes well
00:44:27 <johnw> so now is a good time for me to hear others talk about their experiences
00:44:43 <johnw> anyway, for me anything in Sept would be much, much better
00:44:47 <johnw> from the 7th on
00:46:11 <dmj`> johnw: ok we definitely need you at the meeting then. Someone from basho is speaking on it. I'll discuss with Luke and others to change it. Get you on the mailing list too
00:46:30 <johnw> thanks, that would be awesome
00:46:31 <johnw> you're only 3 hours drive away
00:48:23 <dmj`> johnw: Yea not bad at all.
00:48:40 <dmj`> here's our group https://groups.google.com/forum/#!forum/haskell-chicago
00:50:02 <johnw> joined
00:50:28 <dmj`> awesome
00:50:46 <dmj`> I'm trying to get through all of Simon's examples leading up to the holy grail of "fault-tolerant distributed key/value store" so I won't be too in the dark, time-allowing
00:55:18 <dmj`> johnw: didn't know you were so close. Assumed fp complete would be in the valley :)
00:55:35 <johnw> the company isn't here, just me
00:56:21 * hackagebot data-extra 2.0.0 - Extra utilities for working on Data.* types.  http://hackage.haskell.org/package/data-extra-2.0.0 (ChrisDone)
01:00:20 <dmj`> johnw: how about Sept 14th
01:00:33 <johnw> perfect!
01:00:40 <johnw> two weeks before ICFP
01:01:18 <zvrba> any suggestions for a portable compact binary data structure encoding that has a library for C++ and Haskell?
01:02:14 <arkeet> what about something along the lines of protobuf
01:02:18 <dmj`> johnw: I really want to go to that, never been to boston either
01:02:23 <zvrba> like JSON, except that the set of keys is limited and I don't want to waste space to encode them with strings.
01:02:36 <zvrba> arkeet: ok.
01:07:45 <quicksilver> zvrba: I don't think there is one. Have you considered just using JSON + gzip ?
01:09:11 <zvrba> quicksilver: i've considered using xml + gzip
01:10:35 <Enigmagic> quicksilver: protocol buffers has two libraries for haskell and at least one for c++... and a lot of other languages.
01:10:56 <quicksilver> Enigmagic: well, I live and learn :)
01:13:05 <zvrba> i've also stumbled upon msgpack
01:36:55 <Franciman> is there a way to use ghc just as lexical analyzer?
01:38:50 <johnw> -fno-code?
01:44:20 <quicksilver> Franciman: there is a GHC-style lexical analyser in parsec, too
01:44:30 <quicksilver> and it's easy to build one in alex
01:45:06 <merijn> @remember AndrazBajt co-worker = producer of work tasks
01:45:06 <lambdabot> It is forever etched in my memory.
01:52:25 <simukis_> A thing Haskell beat into me is fear of IO.
01:54:08 <Work_jack> Good ;)
01:54:21 <Lethalman> I fear state mutation in general, not only IO
01:59:22 <merijn> Why? I <3 IO
01:59:36 <merijn> "How I Learned to Stop Worrying and Love IO"
02:06:38 <quchen> ReaderT r IO a > State s a
02:26:23 <quchen> I'm trying to build GHC, `./configure` tells me "ranlib not needed", and as a bonus I do have `ranlib`. However, when running `make`, it complains "ghc-cabal: Cannot find the program 'ranlib' at '@REAL_RANLIB_CMD@' or on the path" - anyone familiar with the problem?
02:41:07 <chexxor> quchen: did you ./sync-all pull ?
02:43:26 <Hugh_> hello again... I am looking at the Data.Maybe source...
02:44:05 <quchen> chexxor: Yeah I think that was it.
02:44:27 <Hugh_> in the definition for Monad Maybe where....
02:44:36 <quchen> On the other hand, connecting to darcs.haskell.org times out :-(
02:44:40 <chexxor> quchen: that's all I have to contribute ^_^ You should go to #ghc or google
02:45:16 <merijn> quchen: oh? What's the exact command you're using?
02:45:17 <Hugh_> (Just x) >>= k  = k x    ...     I am trying to do: Just 3 >>= (*4) and it doesn't like it
02:45:34 <merijn> Hugh_: Take a look at the type of >>=
02:45:35 <Hugh_> I was expecting to get 12
02:45:37 <merijn> :t (>>=)
02:45:38 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:45:47 <quchen> merijn: ./sync-all get
02:46:01 <johnw> :t (*4)
02:46:02 <lambdabot> Num a => a -> a
02:46:03 <merijn> Hugh_: >>= requires that the function returns a value of type "m b"
02:46:20 <quchen> Pulling works though.
02:46:20 <Hugh_> ahhh, ok
02:46:30 <merijn> Hugh_: In other words, for Maybe it requires a function that returns "Maybe b", (*4) does not do that
02:46:41 <merijn> Hugh_: The function you want for your example is fmap
02:46:41 <merijn> :t fmap
02:46:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:46:52 <Hugh_> so I need to define a function which will return a Monad and then use that with the bind operatot
02:46:54 <merijn> Hugh_: Where "fmap f (Just x) = Just (f x)"
02:47:20 <johnw> Hugh_: return . (*4) would have worked, but would not have been ideal
02:47:34 <Hugh_> I see, it is starting to make sense now
02:53:53 <merijn> Hugh_: Good :)
02:55:31 <merijn> Hugh_: Actually, this illustrates one of the main differences between functors and monads. If you look at "(a -> b) -> f a -> f b" you see that the function "a -> b" can't have any influence on the effects that "f" has. But in "m a -> (a -> m b) -> m b" you see that "a -> m b" could look at 'a' and potentially return different effects for different 'a's!
02:56:16 <merijn> Simple example: "\x -> if even x then putStrLn "Even!" else putStrLn "Odd!"
02:56:23 <Hugh_> got it! so I defined a function      moo :: Integer -> Just Integer  .... moo a = Just (4 * a)
02:56:41 <merijn> Here the result effect depends on the value of x, it's impossible to do that with functors
02:56:41 <Hugh_> and then do Just 3 >>= moo ..... gives result Just 20
02:56:48 <merijn> Hugh_: Yes
02:56:57 <zvrba> how does xmonad achieve dynamic configurability w/o recompilation?
02:57:02 <Hugh_> so it looks like the moo function is partially applied ?
02:57:23 <merijn> Hugh_: How so?
02:57:35 <Hugh_> so monads kinda capture side effects in a neat way ?
02:57:43 <merijn> Hugh_: Yes
02:58:33 <Hugh_> well, in ghci type just moo with out an Integer argument fails
02:58:48 <merijn> Hugh_: Side effects like: Doing IO, short-circuiting (Maybe monad), passing an environment to several computations (reader), updating state (state monad)
02:58:52 <Hugh_> but binding it to a monad takes the monad value and applies it as the argument to moo
02:59:11 <merijn> Hugh_: ghci can't print functions, "moo" is just a function, just like "head" or "map"
02:59:25 <merijn> Hugh_: Typing "map" into ghci fails too
02:59:28 <Hugh_> ahh, ok so moo would have to extend show
02:59:40 <Hugh_> sorry, not extend. derive
02:59:46 <merijn> Hugh_: Well, *functions* would have to be an instance of show, yes
03:00:07 <merijn> Hugh_: "moo" is no different from any other Haskell function
03:00:25 <merijn> Hugh_: It's just that the Maybe monad lets you compose functions that return Maybe values very easily
03:00:57 <Hugh_> ok, just returning to the capturing of side effects thing, if someone asks "what are Monads good for?" I could correctly answer "dealing with side effects elegantly"
03:01:17 <johnw> well, that's one answer
03:01:21 <johnw> but certainly not the only one
03:01:40 <merijn> Hugh_: "monads provide an interface that capture many useful tasks, including side effects, in an elegant way"
03:01:50 <Hugh_> ok...
03:01:51 <merijn> Hugh_: Have you read "you could have invented monads"?
03:02:10 <merijn> @google You could have invented monads
03:02:11 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
03:02:11 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
03:02:15 <johnw> the list monad, for example, isn't really about "side effects", yet it's very useful in its own way of representing indeterminate values
03:02:34 <Hugh_> yes, i did read it but probably too soon in my Haskell journey and it went way over my head. Maybe I re-read now the light is starting to appear at the end of the tunnel
03:02:55 <merijn> Hugh_: Yeah, that might be worthwhile
03:03:26 <Hugh_> great, will put the coffee on and settle down with it. thanks all for invaluable help...really appreciate it
03:13:47 <synonymous> Hi!
03:13:47 <synonymous> I need to have mutable state in a tight loop in ST monad.
03:13:47 <synonymous> I could pass it as a strict argument to the recursive loop function and rely on worker/wrapper transform to unbox it.
03:13:48 <synonymous> Is there another way of doing it and still have it unboxed? STRef or something similar?
03:19:09 <ocharles> haasn: explosion = decay 2 . gate . (rateReduce &&& 0.4) . (quantize &&& 500) . (noise &&& 0.2)
03:19:10 <ocharles> haasn: a lofi sound generator :)
03:19:10 <ocharles> sounds like a NES explosion. it's beautiful
03:20:21 <Krakarn--> I have read learnyouahaskell, does anyone have any good reading for a haskell noob?
03:20:41 <ocharles> Krakarn--: if you've read LYAH, best next step is to just jump in and build something
03:22:31 <Walther> yeah, don't be like me and just stick to reading
03:49:44 <mstksg> i too second jumping into doing actual useful things ... but it doesn't hurt to have a copy of books like RWH to flip through every once in a while.
03:49:59 <exicer> Can someone give me an example of how you can use ByteString for actual text processing?
03:50:13 <exicer> Eg, how would you find the number of lines in a bytestring ?
03:50:25 <Ralith> exicer: a ByteString is not text.
03:50:29 <Ralith> you want a Text object.
03:50:44 <exicer> Okay, so why is ByteString useful ?
03:50:52 <exicer> For binary stuff or somethign ?
03:50:58 <Ralith> because sometimes you want to write a program which processes things that are not text.
03:51:05 <exicer> Right right, fair enough :)
03:51:32 <ion> ByteString isn’t a representation of text, but if you make the assumption a specific ByteString contains encoded text, you can count the number of occurrences for whatever "\n" encodes to.
03:51:33 <int-e> (There is a Data.ByteString.Char8.lines for historical reasons but you really should use Data.Text instead.)
03:52:13 <exicer> Okay, so presumably I can check the ByteString somehow to check what kind of encoding the underlying text has ?
03:52:15 <Ralith> people would use it less if you didn't mention it when someone asks how to count lines >_>
03:52:35 <Ralith> exicer: encodings overlap, so not in any general manner, no
03:52:39 <exicer> Hmm
03:52:49 <exicer> So how do you usually do the conversion then ?
03:52:52 <Ralith> usually people just assume UTF8.
03:52:56 <exicer> Just know beforehand whatk ind of text it is ?
03:53:02 <exicer> Okay
03:53:15 <Ralith> if you have other information available about encoding you should of course use that.
03:53:18 <ion> Yes, you have to know the encoding to decode a ByteString into text.
03:53:34 <exicer> So if you were for example just scraping websites
03:53:36 <ion> A ByteString is just a collection of bytes.
03:53:41 <exicer> I suppose the html should say the encoding
03:54:07 <ion> No, the HTTP headers should. You only fall back to the meta element (if any) if the HTTP headers fail to specify the encoding.
03:55:09 <ion> And even parsing the meta element in that case requires some athletics because the encoding may be, say, UTF-16.
03:55:10 <merijn> Krakarn--: Real World Haskell is a good place to help get you started with real coding, just ignore the first few intro chapters and go right to the chapters where they show how to do things
03:55:32 <exicer> Hmm, okay then.
03:55:40 <exicer> I guess I will just flail around until I get properly stuck :p
03:56:13 <merijn> exicer: Make sure you read this: http://www.joelonsoftware.com/articles/Unicode.html
03:56:19 <mstksg> i think there might be some libraries that can abstract this stuff away for you
03:56:27 <ion> (That is, you cannot even make the assumption you can find <meta …> in any superset of ASCII.)
03:56:29 <merijn> exicer: It will explain all you need to know
03:56:57 <exicer> merijn: Okay. Will do.
03:58:49 <aleator> does Monad m => m (Either e b) -> EitherT e m b have a common name?
04:00:05 <hpc> aleator: EitherT
04:00:08 <hpc> :t EitherT
04:00:09 <lambdabot> Not in scope: data constructor `EitherT'
04:00:12 <hpc> hmm
04:00:14 <hpc> @src EitherT
04:00:14 <lambdabot> Source not found. You untyped fool!
04:00:28 <hpc> http://www.haskell.org/hoogle/?hoogle=ErrorT
04:00:34 <hpc> ErrorT, rather
04:00:35 <ion> EitherT :: m (Either e a) -> EitherT e m a
04:00:40 <ion> http://hackage.haskell.org/packages/archive/either/3.4.1/doc/html/Control-Monad-Trans-Either.html
04:01:08 <aleator> Of course... Silly me.
04:03:49 <ion> Data.ByteString.count 10 will count the number of newlines in anything that is encoded using a superset of ASCII.
04:15:02 <aleator> Anyone here used hedis? Every command is basically IO (Either Reply result). Do you just wrap these with EitherT? What is the idiomatic way for working with this thing?
04:21:31 <merijn> aleator: EitherT seems a sensible way to deal with things
04:37:29 <aleator> merijn: Yes. It just feels silly to begin every line with it. Wrapping every command seems also odd.
04:37:53 <aleator> Relatedly, is there a name for return (return ())?
04:38:12 <zomg> the xzibit return
04:38:21 <zomg> I heard you like returns so I put a return in your return
04:38:24 <zomg> ;>
04:39:01 <aleator> zomg: You run into that often with STM and such
04:40:19 <quchen> aleator: For most (all?) transformers, return = Transformer . return . return.
04:40:47 <aleator> quchen: this isn't a transformer, unfortunately.
04:41:26 <quchen> Then you'll have to write it explicitly I think.
04:41:39 <aleator> Fortunately it isn't long
04:49:14 <arcatan>  /win 12
04:53:26 <exicer> Uh, so I've imported Data.Text.Lazy as T, and on http://hackage.haskell.org/packages/archive/text/0.7.2.1/doc/html/Data-Text-Lazy.html it says there is a function splitBy in that module. However I can't access it ?
04:53:49 <exicer> Have I somehow got the wrong version of that module?
04:53:56 <Odd_Bloke> exicer: How are you trying to access it?  Paste somewhere?
04:54:38 <zomg> You might have the newer version of the lib without that function
04:54:55 <exicer> Just in GHCI
04:55:04 <exicer> import qualified Data.Text.Lazy as T
04:55:06 <zomg> the latest one is 0.11.3.1 and it doesn't have splitBy
04:55:08 <exicer> then T. tab
04:55:10 <exicer> ohh
04:55:12 <latermuse> T.splitBy
04:55:20 <exicer> Where did it go ?
04:55:26 <zomg> no idea :P
04:55:32 <exicer> Hehe
04:55:41 <zomg> was just looking on hackage, 0.7.2.1 has it but 0.11.3.1 doesn't
04:55:59 <exicer> How can I check which version of a thing I have ?
04:56:04 <quchen> exicer: http://hackage.haskell.org/packages/archive/text/0.11.3.1/doc/html/Data-Text.html#v:split
04:56:05 <exicer> (would this be called a package or a moduel?)
04:56:35 <zomg> I believe `text` is the package and `Data.Text.Lazy` is a module in said package.
04:56:45 <quchen> You can list installed packages with `ghc-pkg list`, therefore `ghc-pkg list | grep text` gives you your text version.
04:57:54 <exicer> Cool, good to know
04:58:07 <otulp> Or just "ghc-pkg list text"
04:59:02 <quchen> exicer: The version you posted is from 2010. :-P
05:04:20 <jtanguy> exicer: splitBy from text-0.7.2.1 seems to correspond to split from text-0.11.3.1
05:16:38 * hackagebot stm-conduit 2.1.2 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.1.2 (ClarkGaebel)
05:16:58 <donri> chrisdone: hey i think your bool function has its arguments the wrong way around, compared to maybe and either and foldr?
05:19:38 <donri> chrisdone: also i think it should be :: a -> a -> Bool -> a ?
05:19:58 <donri> chrisdone: unless you're not aiming for similarity to those other functions, in which case i think the naming is unfortunate ;)
05:21:38 * hackagebot parsek 1.0.0 - Parallel Parsing Processes  http://hackage.haskell.org/package/parsek-1.0.0 (JeanPhilippeBernardy)
05:53:05 <gjcross> /quit
05:55:39 <exicer> Would it be appropriate to create a new type for a value that can only take -1, 0, 1 or would I be better off just using Int ?
05:55:53 <exicer> (please forgive my probable butchery of haskell terms)
05:58:24 <mr-> exicer: can you give meaning to -1, 0, 1?
05:58:43 <MasseR> exicer: Your decision. By creating a new type you can be sure that no other values can go through
05:58:45 <mr-> exicer: are you going to have to multiply them?
05:59:09 <mr-> exicer: a new type would also serve as documentation, if there is a meaning to them, other than a number
05:59:36 <exicer> mr-: They represent a vote for, abstane or against
05:59:56 <haasn> ocharles: heh, interesting (re: lofi sound generator)
05:59:57 <mr-> exicer: Then a new type is called for
06:00:06 <haasn> unfortunately I don't understand a thing about sound generation. Looks cool though
06:00:36 <exicer> mr-: Okay - is there a way I can keep them as -1 0 1, but let people know what those things stand for ?
06:01:04 <mr-> exicer: Why would you want to?
06:01:41 <exicer> mr-: I would like to do comparisons at some point, something like the dot product of the vector of votes to see which two people are the most similar vote-wise
06:02:06 <shanse> somebody's doing the matrix course on coursera
06:02:10 <exicer> but for documentation it would be nice to explicitly say which is which
06:02:12 <exicer> hehe, yeah :p
06:02:26 <MasseR> I'd say, keep them as separate types, but when you need to do some calculations, convert them
06:03:42 <elflord> how do people update cabal packages ?
06:04:04 <MasseR> elflord: By having separate repos (cabal-dev, virthualenv)
06:04:34 <MasseR> If you need to update, nuke the .ghc and .cabal dirs and reinstall
06:04:35 <elflord> i use hsenv; so i need to create one environment for each project you mean ?
06:04:43 <MasseR> Yes
06:04:51 <exicer> Is there some way of having virtualenvs in haskell ?
06:04:59 <MasseR> virthualenv
06:05:07 <MasseR> Or hsenv. I don't remember which is the current name
06:05:10 <exicer> Huh, cool
06:05:36 <elflord> people don't prefer to use a package managemetn system ?
06:05:46 <elflord> like arch linux ?
06:05:53 <mr-> elflord: most don't
06:06:21 <mr-> elflord: we want the latest and greatest! ;-)
06:06:57 <elflord> say you are in the middle of develope and one of the lib you are using has been updated
06:07:01 <elflord> what do you do then ?
06:07:05 <elflord> keep using the old one ?
06:07:09 <haasn> mr-: that isn't mutually exclusive
06:07:37 <mr-> elflord: you can compile it using the new lib
06:07:49 <elflord> so you create a new virtualenv ?
06:08:06 <haasn> elflord: I guess the problem most people have is that different things have dependencies on different versions of upstream libraries (depending on how recently they were updated), which is why cabal-dev is commonly used
06:08:25 <haasn> elflord: but again, that also in no way contradicts using packages - eg. see Nix
06:08:55 <mr-> elflord: not necessarily, you can do that in your current environment. It might lead to a recompilation of more than you expected, though
06:09:18 <haasn> elflord: personally I just update my code to compensate and live with the change :)
06:09:28 * haasn wants the latest and greatest
06:11:07 <elflord> i'm using tagsoup for a project
06:11:16 <elflord> and today tagsoup got a update
06:11:26 <elflord> i need to remove the lib
06:11:29 <elflord> and reinstall ?
06:11:34 <elflord> in my virtual env ?
06:11:50 <merijn> elflord: Either I keep using the old version until the next platform update or (if I desperately need a bugfix/new feature) I will manually unregister the library and install the new one
06:11:51 <mr-> cabal install tagsoup-1.0
06:12:09 <elflord> OK
06:12:16 <haasn> I let my package manager take care of all the work
06:12:19 <haasn> I just tell it what to update/install
06:12:22 <elflord> so i need to manually unregister it and reinstall
06:16:24 <mr-> elflord: you could just change the dependency in your project's cabal file and see what happens
06:29:09 <lemao> could someone point out an up-to-date netwire tutorial/docs?
06:29:34 <MasseR> ocharles just wrote a tutorial of some sorts
06:31:08 <ocharles> lemao: see http://ocharles.org.uk/blog and let me know what's missing :)
06:32:05 <ocharles> lemao: also, https://github.com/ocharles/netwire-classics/tree/master/asteroids contains a fully working game of asteroids complete with sound synthesis using netwire for all of it
06:32:35 <lemao> ocharles: many thanks!
06:38:39 <quchen> `[git pull] && ./sync-all get && perl boot && ./configure && make` should do a complete GHC build from nothing, right? Somewhere in stage 1 it tells me "Failed to load interface for ‛GHC.Base’" and fails.
06:39:13 <hpaste> quchen pasted “GHC make error” at http://lpaste.net/91627
06:42:28 <donri> why aren't there inline pragmas all over base?
06:44:29 <latermuse> its been about a year, and ive finally grasped about 95% of the typeclassopedia. any recommendations for further reading that builds off the typeclassopedia?
06:46:28 <ocharles> latermuse: it doesn't build off typeclassopedia, but maybe read all the arrows papers
06:47:13 <ocharles> latermuse: byorgey's (Brent Yorgey) writing on monoids is a must
06:47:51 <ocharles> latermuse: the applicatives paper, and then maybe formlets and the essence of the iterator pattern will give you a good appreciation for applicative functors
07:02:41 <mr-> ocharles: which applicatives paper?
07:02:57 <ocharles> mr-: mcbride's
07:03:07 <ocharles> "applicative programming with effects" i thinkx
07:03:10 <ocharles> i think*
07:03:16 <mr-> thanks
07:04:24 <klrr> https://gist.github.com/klrr/6174002 any idea what make this parse error come?
07:05:51 <geekosaur> the let on line 112
07:06:00 <merijn> klrr: Your let doesn't have an in
07:06:00 <byorgey> klrr: "let s' = stepGame t (l, r) s"  is not valid by itself
07:06:02 <geekosaur> let without in is only valid in do
07:06:40 <byorgey> maybe you want to just remove  "let s' =" ?
07:07:08 <ocharles> klrr: also, rather than reinventing 2d vectors, you might want to use the 'linear' package
07:07:36 <klrr> ocharles: can i use them with lenses?
07:07:46 <klrr> merijn: byorgey didnt realize thtat was there :p
07:07:52 <ocharles> klrr: yes
07:07:53 <edwardk> klrr: linear is 'lens-based linear algebra'
07:07:58 <byorgey> klrr: 'linear' is edwardk's package, does that answer your question? =)
07:08:04 <latermuse> ocharles: thanks for the recommendations
07:08:04 <klrr> okey
07:08:12 <klrr> maybe later but now i got new errors
07:08:17 <ocharles> latermuse: yw, happy reading!
07:08:18 <klrr> also i think my logic is wrong
07:09:13 <klrr> my game doesnt even work even when it compiles -.-
07:10:05 <latermuse> klrr: the type system cant really prevent bad logic
07:10:43 <klrr> latermuse: i know, that why i gonna invent, SUPER-DUPER-SAFE-LANG 2.0 when i grow up :D
07:10:50 <merijn> klrr: It's called Agda
07:10:50 <latermuse> klrr: Although I suppose it could to a certain extent if you had the time and put the effort into it. But that might be overkill.
07:11:13 <klrr> merijn: agda seems cool but im learning lenses and frp and game dev atm
07:11:34 <klrr> https://gist.github.com/klrr/6174398 any suggestions how to make this work ? XD
07:11:57 <klrr> (using lens, elerea and helm
07:12:50 <latermuse> klrr: what doesnt work about it?
07:13:05 <klrr> latermuse: everything, it starts up and so, but when i press space it doesnt work
07:14:03 <ocharles> klrr: it sounds like you're trying to run before you can walk
07:14:25 <ocharles> slow down a bit, and maybe make it print to stdout when you press space (or some other form of diagnostics)
07:14:28 <ocharles> and then iterate
07:16:09 <latermuse> ocharles: by the way, I really enjoyed your 24 days of hackage last year
07:16:37 <klrr> ocharles: but ive written the whole game
07:16:38 <klrr> already
07:16:43 <klrr> no need to do hello world :P
07:16:47 <klrr> it just doesnt work
07:17:04 <klrr> it moves a little bit and the ball moves a bit to the left but then suddenly no more
07:17:27 <latermuse> klrr: when in your dev cycle did it stop working? or did you write the code without testing it along the way?
07:17:29 <ocharles> latermuse: thanks! I'm hoping to do something this year, but I'm not sure what. I've considered 4 hour long videos building a haskell application
07:18:02 <ocharles> latermuse: I could do another hackage run down, but I haven't really picked up many new libraries this year :)
07:18:07 <latermuse> ocharles: 4 hours would be a long video, but I would watch at least one if you made one.
07:18:12 <ocharles> latermuse: nono, one a week
07:18:28 <ocharles> giving people to suggest where the application will go, or something
07:18:29 <klrr> latermuse: i did testing now and then so it compiled, the thing is, first i implemented the model, all types etc., then i implemented the renderer, which renders the game based on the state whihch uses those types i defined, THEN i made the stepper or state updater code, now it compiles and all but doesnt work
07:18:30 <latermuse> 4 hour videos each week?
07:18:39 <latermuse> ohh!
07:18:42 <ocharles> latermuse: no, 4 one hour videos, one each week leading to xmas
07:18:45 <latermuse> four videos of one hour in length each
07:18:47 <ocharles> si
07:18:57 <latermuse> that would be awesome! would definitely watch that
07:19:17 <ocharles> anything in particular you'd be interested in learning about? Game programming? web programming? bulk data processing?
07:19:32 <ocharles> @faq can Haskell do that?
07:19:33 <lambdabot> The answer is: Yes! Haskell can do that.
07:20:20 <klrr> HASKELL DOESNT WOWRK ASS
07:20:20 <latermuse> ocharles: I would like to see web programming and bulk data processing. its the stuff I do for my daily work, and would love to see how other people tackle similar problems
07:21:11 <latermuse> I learned quite a few tricks from http://nlpwp.org/
07:21:16 <latermuse> Too bad they never finished the book
07:21:22 <startling> @faq Can haskell work ass?
07:21:22 <lambdabot> The answer is: Yes! Haskell can do that.
07:21:41 <startling> klrr, overruled.
07:21:50 <ocharles> latermuse: nice, never seen this
07:22:13 <latermuse> I guess they didnt finish due to lack of interest
07:22:41 <ocharles> it can be hard to keep going with these things
07:23:07 <latermuse> Yes. It is written very well. Its really too bad.
07:23:45 <merijn> Will any alternatives for block/unblock be added? They're marked deprecated in Control.Exception, but I don't see a suitable replacement?
07:23:56 <klrr> sry sry! i wont write such stupid stuff :/ dont ban me again i promised to stay away from #haskell if i was angry i gonna stay out of here
07:25:25 <ocharles> o.o
07:26:56 --- mode: ChanServ set +o mauke
07:26:56 --- mode: mauke set +b klrr!*@*
07:27:45 --- mode: mauke set -b+b klrr!*@* *!~klrr@*
07:27:58 <ocharles> that seems a bit harsh, he did excuse himself and leave
07:28:02 <ocharles> he/they
07:28:33 <merijn> ocharles: On the other hand he's thrown like 5 tantrums in the past few weeks
07:28:40 <ocharles> oh, fair enough
07:28:43 <WraithM> Oops
07:28:52 * ocharles lets the mods do their thing
07:29:03 <mauke> ocharles: and then he joined #perl, posted the "truth about haskell", and left
07:29:27 <latermuse> Im not sure how he got so far in his pong game with such a short-temper and lack of patience
07:29:45 --- mode: mauke set -o mauke
07:31:00 <b2coutts> latermuse: I got the impression that he had just written code that works "in theory" but hadn't tested any of it
07:31:22 <merijn> Any answers about the deprecation of block/unblock? Are they just deprecated "because you should avoid them as much as possible"?
07:32:05 <geekosaur> there was a mailing list discussion some time back about why they didn't and couldn't work right
07:32:20 <merijn> oh, bah
07:32:41 <merijn> Is there a way to fork a thread that *doesn't* inherit the parents mask state?
07:32:52 <geekosaur> short version is that there is no way to avoid some resource leaks (filehandles and such)
07:33:15 <int-e> merijn: no, but there's forkIOWithUnmask which should be close enough
07:33:29 <merijn> int-e: No
07:33:49 <int-e> and why not?
07:33:56 <latermuse> b2coutts: I understand. However, some of his code is pretty advanced. If he is at such a level where he can write such code, he should certaintly be able to debug some simple logic errors without throwing a fit.
07:33:56 <merijn> int-e: That first adds a mask and then removes it. If the code calling it is already masked, the unmask will just restore the previous mask state
07:34:39 <merijn> int-e: Because it doesn't remove calling codes mask which is inherited too
07:34:59 <int-e> merijn: that's wrong.
07:35:09 <int-e> forkIOWithUnmask io = forkIO (io unsafeUnmask)
07:35:22 <merijn> oh?
07:35:23 <merijn> hmm
07:36:06 <ocharles> any tips on debugging this:
07:36:07 <ocharles> Stack space overflow: current size 8388608 bytes.
07:36:09 <merijn> Oh, I misunderstood the docs of that
07:36:15 <ocharles> it seems to happen after playing my asteroids game for a minute or so
07:36:24 <ocharles> so i guess I have a space leak or something?
07:36:24 <merijn> int-e: Great, problem solved \o/
07:36:34 <luite> ocharles: do you get info from stack traces?
07:36:43 <ocharles> luite: that's all the information I got
07:36:52 <ocharles> ran from an executable compiled with -O2 -Wall, nothing else
07:36:56 <luite> ocharles: yeah you need to compilew ith profiling and +RTS -xc
07:37:02 <ocharles> ok, I'll give that a shot
07:37:43 <luite> ocharles: you should probably look for some place where you reduce some big thing strictly in a non-tailrecursive way
07:38:02 <luite> but perhaps the stack trace will immediately pinpoint the problem
07:38:10 <m_hyperbolic> Hello. I'm trying to create a tree type by using Maybe, and a treeHeight. I have a working function, but had to use a where clause, and I feel like there should be a more elegant solution. Would somebody take a look, and see if I missing some fundamental idea? http://lpaste.net/91629
07:38:11 <ocharles> I don't have a single big thing, but I'm wondering if the entire game is being evaluated non-tail recursively
07:39:25 <merijn> m_hyperbolic: You can use fmap and the Ord instance of Maybe
07:39:35 <merijn> > Nothing < Just 4
07:39:36 <lambdabot>   True
07:40:09 <luite> ocharles: often forgetting to evaluate something will lead to thead, like a state computation where the state is never forced until the end, and you get a really deep thunk
07:40:09 <Hafydd> m_hyperbolic: an alternative is to have: data Tree a = Branch a (Tree a) (Tree a) | Empty; or data Tree a = Branch a (Tree a) (Tree a) | Leaf a.
07:40:33 <ocharles> luite: yea, that's what I'm expecting to find
07:40:50 <ocharles> luite: and those unevaluated thunks take up space on the stack if they are being passed around a non-tail recursive call, I guess
07:40:59 <m_hyperbolic> merijn I'll try and take a look at that!
07:41:22 <m_hyperbolic> Hafydd: I already made the 'conventional' tree data type, I was just trying to play around with maybe :)
07:41:29 <Hafydd> Fair enough.
07:42:25 <luite> ocharles: passing around thunks is just heap, but when you force that big thunk it might have to use lots of stack space at once
07:42:42 <hpaste> merijn annotated “maybe Tree” with “maybe Tree (annotation)” at http://lpaste.net/91629#a91630
07:42:56 <merijn> m_hyperbolic: Take a look at that example
07:42:59 <ocharles> luite: ah, i see
07:45:11 <merijn> m_hyperbolic: If you have questions about how that version works, just ask :)
07:46:19 <m_hyperbolic> merijn: Thanks for that! I'll try at stare at it for a couple of minutes, and see if I understand :)
07:59:26 <gaze> hey, how do you find the size of a storage type of a pointer? Some function of type Ptr a -> Int
08:00:08 <m_hyperbolic> merijn: I think I have an idea of how it works, but I don't really have a clear understanding of fmap and `on`. But I haven't played with functors at all in haskell yet, so that is maybe to be expected hehe.
08:00:37 <luite> gaze: usually you'd make a Storable instance for a
08:02:48 <mauke> :t sizeOf
08:02:49 <lambdabot>     Not in scope: `sizeOf'
08:02:49 <lambdabot>     Perhaps you meant one of these:
08:02:49 <lambdabot>       `IM.size' (imported from Data.IntMap),
08:02:55 <mauke> @hoogle sizeOf
08:02:55 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
08:02:56 <lambdabot> GHC.Constants sIZEOF_CostCentreStack :: Int
08:02:56 <lambdabot> GHC.Constants sIZEOF_generation :: Int
08:03:06 <gaze> well, I have some type X a = BufLen (Ptr a) (GPUBufferPtr), and from that I feel like I should be able to get the length of the buffer and the number of items in the buffer
08:03:30 <mauke> "feel"
08:03:34 <gaze> I mean sizeOf is definitely what I'd want if I had an a
08:03:39 <gaze> but i have a Ptr a
08:03:45 <mauke> Ptr a contains a
08:03:45 <gaze> and I don't want to store the Ptr
08:04:05 <ion> gaze: sizeOfPtr :: Storable a => Ptr a -> Int; sizeOfPtr px = sizeOfPtr' px undefined; sizeOfPtr' :: Storable a => Ptr a -> a -> Int; sizeOfPtr' _px x = sizeOf x
08:04:21 <gaze> ion: thanks :D
08:04:29 <mauke> sizeOfPtr = sizeOf . deref where deref :: Ptr a -> a; deref = undefined
08:05:22 <gaze> thanks mauke as well. That makes sense, I'm still getting the hang of the type system
08:05:34 <ion> mauke’s is better.
08:06:19 <gaze> mauke's gives me a monomorphism restriction error
08:06:26 <mauke> oh, fun
08:06:27 <ion> Add a type signature.
08:06:30 <mauke> or a parameter
08:06:35 <mauke> or disable the restriction
08:07:09 <gaze> ah yeah a type signature got it.
08:07:12 <gaze> thanks :D
08:07:38 <merijn> m_hyperbolic: Basically, in the case of Maybe, fmap tries to apply a function "inside" the Maybe, if it happens to be Nothing it just returns Nothing
08:08:08 <merijn> m_hyperbolic: So "fmap treeHeight Nothing = Nothing" and "fmap treeHeight (Just t) = Just (treeHeight t)"
08:08:19 <merijn> :t on
08:08:20 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
08:08:47 <merijn> m_hyperbolic: As you can see on takes a function that wants two b's and a function that turns a's into b's and returns a function that wants two a's
08:09:49 <merijn> m_hyperbolic: (I'm simplifying by changing Num b into Int here) "fmap treeHeight :: Maybe (Tree a) -> Maybe Int"
08:11:04 <xexonixxexillion> What's the Cofree comonad of State?
08:11:07 <merijn> m_hyperbolic: So "max `on` fmap treeHeight" ends up being "Maybe (Tree a) -> Maybe (Tree a) -> Maybe Int" (it uses the fmap to turns the Maybe (Tree a) into Maybe Int and then returns the max of two "Maybe Int"
08:11:39 <gaze> oh yeah, how would I write N a b c x = a (b x) (c x) in pointfree style?
08:11:47 <edwardk> a * (s -> (s, a * (s -> (s, a * ...
08:11:53 <merijn> m_hyperbolic: Because max works on any Ord and there is an instance "instance Ord a => Ord (Maybe a) where", where Nothing is smaller than everything and "Just x < Just y == x < y"
08:12:01 <edwardk> that is Moore s a
08:12:05 <edwardk> its a moore machine
08:12:12 <edwardk> or is it
08:12:19 <edwardk> its like a moore machine
08:12:31 <ion> @type liftA2 (f :: Expr -> Expr -> Expr) (g :: Expr -> Expr) (h :: Expr -> Expr) x
08:12:31 <lambdabot> Expr
08:12:35 <edwardk> because that would be Moore s a = Cofree ((->) s) a
08:12:35 <ion> > liftA2 (f :: Expr -> Expr -> Expr) (g :: Expr -> Expr) (h :: Expr -> Expr) x
08:12:37 <lambdabot>   f (g x) (h x)
08:13:15 <m_hyperbolic> merijn: Ah yes I understand. That made sense. Thanks!
08:13:23 <edwardk> Cofree (Store s) a = a * s * (s -> (a * s * (s -> ..  )) = Moore s (a,s)
08:13:26 <ion> Note that using liftA2 or <$> <*> for that doesn’t necessarily make the code better.
08:13:26 <merijn> m_hyperbolic: Now we have "Maybe Int" describing the length of the max branch, now we need to turn that maybe into an Int, which we can do using "fromMaybe :: a -> Maybe a -> a" which returns the first argument if the Maybe is nothing (i.e. 0) and the contents of the Maybe if it is not Nothing
08:13:36 <edwardk> Cofree (State s) doesn't quite match up, its a little bit off from that
08:14:47 <m_hyperbolic> merijn: Yes I had been trying to work with fromMaybe, but I was missing really missing the fmap bit of it. I even think I had a thought like "I really need to apply a function inside the maybe in some way" hehe
08:15:20 <edwardk> (s, Cofree (State s) a) = Moore s (a,s) = (s, a * s -> s * a * s -> s * a * s -> …    )
08:15:33 <merijn> m_hyperbolic: You probably wanted "maybe" which is more intuitive in this example
08:15:36 <merijn> :t maybe
08:15:37 <lambdabot> b -> (a -> b) -> Maybe a -> b
08:16:08 <merijn> m_hyperbolic: That would let you do "max (maybe 0 treeHeight b) (maybe 0 treeHeight c)"
08:16:21 <ocharles> luite: thanks for the -xc tip - memory leak gone!
08:16:24 <edwardk> :t Data.Foldable.foldr . fmap const
08:16:25 <lambdabot> Foldable t => (a -> a1) -> a1 -> t a -> a1
08:16:30 <edwardk> ^- generalized maybe
08:16:52 <merijn> edwardk: Yes, but that's a significantly more intimidating type for newcomers :)
08:16:54 <edwardk> =)
08:17:07 <edwardk> mostly just offering it up for you ;)
08:17:14 <merijn> I already know about for_
08:17:16 <merijn> :t for_
08:17:17 <lambdabot>     Not in scope: `for_'
08:17:17 <lambdabot>     Perhaps you meant one of these:
08:17:17 <lambdabot>       `F.for_' (imported from Data.Foldable),
08:17:20 <merijn> :t F.for_
08:17:21 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
08:17:29 <merijn> oh, eh
08:17:36 <merijn> :t T.for
08:17:37 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
08:17:39 <xexonixxexillion> edwardk: thanks
08:17:41 <merijn> hmm
08:17:45 <luite> ocharles: good :) what was the problem?
08:17:46 <merijn> I forget which one I want
08:18:07 <m_hyperbolic> merijn: Yes I see how maybe would make it eaisere.
08:18:46 <ocharles> luite: I had an arrow which was 'keep . randomSpikes' which was meant to generate n random vertices for my asteroid polygon, but only once per asteroid (hence the keep)
08:18:48 <merijn> m_hyperbolic: Basically, if you want to get stuff out of a Maybe, you usually want fromMaybe/maybe if a pattern match would be ugly
08:19:03 <ocharles> luite: but it was still evaluating 'randomSpikes' every frame, only to throw the result away in keep
08:19:44 <luite> ocharles: ah :)
08:19:47 <ocharles> the fix is to make randomSpikes generate a spike, then act as a constant wire
08:19:51 <ocharles> e.g., don't be an idiot
08:20:52 <ocharles> compiling with -prof is cool, because I can see what's getting evaluated each frame, too
08:21:07 <m_hyperbolic> merijn: Sure. And I think I have a better understand of fmap too now. Thanks for the help!
08:23:08 <xexonixxexillion> edwardk: I'm still trying to get my head around Cofree. Am I right in saying that the Cofree Comonad of a List is a tree?
08:23:24 <edwardk> cofree [] is a rose tree, yes
08:23:57 <edwardk> data Bin a = Bin a a | Tip -- Cofree Bin a is a non-empty binary tree
08:24:10 <edwardk> Cofree Maybe a is a non-empty list
08:24:18 <edwardk> Cofree Identity is an infinite stream that can't stop
08:24:40 <edwardk> Cofree (Const b) a = is a pair of a and b
08:26:35 <edwardk> and Cofree ((->) s) a  -- is a moore machine
08:28:12 <tnks> edwardk: is Cont a free monad?
08:28:39 <edwardk> no
08:29:44 <tnks> okay, I think we were confusing ourselve to believe that the free monad you get from a function-0 is Cont.
08:29:50 <tnks> but I guess that's just something else.
08:30:46 <xexonixxexillion> if data NonDet s a = NonDet (s -> [a]), does that make (Cofree (NonDet s)) a non-deterministic finite state machine?
08:31:45 <tnks> edwardk: ahh. . . I see it now. . . we were interpretting the definition of Cont wrong.
08:33:15 <edwardk> xexonixxexillion: yes
08:33:50 <edwardk> not a terribly efficient one though
08:33:58 <edwardk> as you can't 'merge' identical states
08:34:16 <enthropy> dmwit: on the gtk2hs website there are links to bits on the rest of the page that don't seem to work. For example: http://projects.haskell.org/gtk2hs/download/#Windows
08:36:40 <edwardk> normally as you run an NFA with n states you have at most n states you have to consider, but with that representation if you expect k transitions from each input, and step m times you have O(k^m) states alive, with no way to collapse them down to the at most n distinct ones
08:37:09 <edwardk> of course nothing enforces that Cofree (NonDet s)     is a _finite_ state machine
08:37:22 <edwardk> t can be an infinite state machine just as easily
08:40:31 <xexonixxexillion> edwardk: does anything force Cofree ((->) s) to be a finite state machine?
08:46:44 <edwardk> no
08:46:57 <edwardk> its a potentially infinite moore machine
08:47:21 <edwardk> the states are the various Cofree ((->)s) a values
08:48:24 <banister> which is the best gamedev library for haskell? i see 'helm' has serious problems working on osx, are there any alternative?
08:50:37 <levi> helm is pretty new. I'm afraid I don't have any good suggestions.  I think there's a #haskell-game channel, though.
08:50:39 <edwardk> they all have issues on some platform or other
08:51:42 <edwardk> mostly in that each of them, sdl, etc. can be hard to install on some platforms or is lacking in functionality you'd need to ship something (e.g. gloss)
08:52:49 <banister> i guess i could just play with helm in my linux vm
08:54:22 <sm> banister: I just updated http://joyful.com/fungen
08:55:01 <FreeFull> What's the recommended Haskell library/DSL for raster graphics?
08:55:03 <Cale> banister: What kind of game? There's no all-encompassing game development framework yet, so you're likely to have to do at least a little bit of foundational legwork here and there as you go.
08:55:13 <sm> no idea why it didn't show up on haskell-cafe...
08:55:14 <banister> smarter: now that looks cool
08:55:18 <banister> sm: *
08:55:29 <banister> sm: glad it's using opengl rather than SDL, too ;)
08:55:53 <sm> it's imperative, cross-platform, easy to install
08:56:00 <banister> Cale: ah, nothing really, i actually just wanted to look at example code to see what gamedev in haskell is like, i'd probably just write a simple pong clone or something though
08:56:50 <Cale> banister: If you're doing something like that, maybe try gloss. It's rather simple and fun to use and you can get something on the screen quickly.
08:57:00 <banister> sm: are there any example games bundles with that?
08:57:03 <sm> yes
08:57:06 <Cale> http://hackage.haskell.org/package/gloss-1.7.8.4
08:57:13 <banister> sm: how do i run them?
08:57:14 <banister> Cale: thanks
08:57:35 <ocharles> I need to port asteroids to gloss rather than using SDL, I think
08:57:42 <banister> sm: this error: http://cl.ly/image/29111M1N0s1Q
08:58:14 <ocharles> banister: I'm writing asteroids using netwire and "raw" SDL - https://github.com/ocharles/netwire-classics/blob/master/asteroids/Asteroids.hs
08:58:17 <ocharles> that may be of interest to you
08:58:52 <banister> ocharles: thanks i'll check it
08:59:05 <sm> banister: that's the old version, do a cabal update
08:59:14 <banister> sm: ah
08:59:26 <Cale> http://hackage.haskell.org/packages/archive/gloss/1.7.8.4/doc/html/Graphics-Gloss.html -- if you look here, you'll see 4 basic main loops that gloss gives you: display (which is for putting a picture on the screen), animate (which lets the picture be a function of time), simulate (which is like animate, but with a state value being passed around that you can decide how to update and how to turn into a picture at each s
08:59:26 <Cale> tep), and play (which is like simulate but also incorporates mouse and keyboard input)
08:59:35 <exicer> I think I'm a bit confused by Maybe. It seems that as soon as you do something that is Maybe, all the following functions need to explicitly deal with Just / Nothing, which seems a bit inelegant.
09:00:05 <Cale> exicer: They don't *explicitly* have to, but they have to deal with the possibilities somehow.
09:00:06 <startling> exicer, you can deal with it right away instead
09:00:17 <startling> or you can hide it with monadic style.
09:00:24 <banister> Cale: scary, gloss uses tensors? :) I just saw Tensor.hs being compiled
09:00:27 <sm> to see the examples, you'll need the source: darcs get http://hub.darcs.net/simon/fungen, cd fungen/examples/pong, ghc pong, ./pong (and worms)
09:00:27 <donri> exicer: that's sort of the whole point though
09:00:27 <Cale> exicer: There are lots of functions for working with Maybe values.
09:00:30 <exicer> startling: Ah, not read the chapter on monads yet :
09:00:41 <exicer> Okay, so for example
09:00:47 <Cale> banister: I'm not sure what that's about.
09:00:52 <exicer> I am reading a load of text strings, and converting them to Ints
09:01:09 <exicer> What should I do ?
09:01:22 <Cale> banister: Oh, that's just OpenGL
09:01:23 <exicer> Have the list of converted ints all as Just / Nothing ?
09:01:39 <startling> > sequence [Just 1, Just 2, Just 3]
09:01:40 <lambdabot>   Just [1,2,3]
09:01:43 <dmwit> enthropy: Hm, that's annoying. Let's see what can be done about that.
09:01:43 <levi> exicer: Depends on what you want to do when invalid input happens.
09:01:47 <startling> > sequence [Nothing, Just 12]
09:01:48 <lambdabot>   Nothing
09:02:09 <monochrom> exicer: also depends on how you will use those Ints
09:02:23 <monochrom> it depends on a lot. "the solution depends on the problem"
09:02:23 <exicer> I guess the point is, in this case I don't expect there to be faulty input. If this were another language, I would raise an exception on a value that couldn't be converted and log it.
09:03:01 <startling> exicer, this sort of thing is annoying until you get to understanding monad transformers, I think.
09:03:16 <startling> well, monads in general.
09:03:19 <exicer> Hm, okay. Well the plan is to read monad stuff tomorrow
09:03:24 <Cale> exicer: So, you can write  case parseInput blah of Nothing -> error ("invalid input: " ++ blah); Just x -> x
09:03:38 <levi> You can form a Monad with Maybe that essentially does that; at the first Nothing, the whole conversion would immediately return Nothing.
09:03:50 <donri> exicer: haskell has exceptions and lots of things uses them instead of maybe/either. but it tends to bite you later because exceptions are messier to deal with.
09:04:02 <exicer> donri: Yeah, this is what I have read today :P
09:04:07 <exicer> try and limit exceptions to IO stuff
09:04:29 <ocharles> even IO seldom needs exceptions when you have EitherT and MaybeT
09:04:45 <Cale> IO's exception system is pretty cool though.
09:04:46 <monochrom> I am also not convinced that in another language you would throw an exception. perhaps you would ignore instead of throw. it depends on the actual specification.
09:04:54 <monochrom> "the solution depends on the problem"
09:05:03 <levi> But if you are unfamiliar with Monads, Maybe is also a Functor, which means it has 'fmap', which allows you to apply a function evenly across Maybe values.  In the case of Just x, fmap will apply the function to x.  In the case of Nothing, it doesn't try the function.
09:05:05 <exicer> monochrom: I suppose I mean, I would just handle the exception and log it
09:05:12 <merijn> hmm
09:05:17 <merijn> Is there a "(a -> Bool) -> m a -> m [a]"
09:05:22 <merijn> takeWhileM or something
09:05:24 <sm> fun trivia, I just found the initial FunGEn announcement at http://article.gmane.org/gmane.comp.lang.haskell.general/5108/match=fungen - this framework is 11 years old :)
09:05:27 <startling> merijn: monad-loops or something
09:05:30 <Cale> exicer: fmap :: (a -> b) -> Maybe a -> Maybe b (in the special case of Maybe)
09:05:30 <haasn> I'm personally find using exceptions for obviously invalid input that should never be actual inputs to the function; but if the function is expected to be passed any input and can possibly fail, I'd use Maybe or similar
09:05:39 <geekosaur> @hoogle (a -> Bool) -> m a -> m [a]
09:05:40 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
09:05:40 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
09:05:40 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
09:05:41 <sm> time we did something with it
09:05:43 <merijn> startling: That was the first place I looked
09:05:46 <geekosaur> beh
09:05:46 <Cale> exicer: So, that gives you a way to apply functions to Maybe values conveniently.
09:05:48 <ocharles> merijn: repeatedly running an action until it fails?
09:05:53 <merijn> monad-loops doesn't really seem to have anything
09:05:54 <ocharles> fails a predicate*
09:05:57 <merijn> ocharles: Pretty much
09:05:59 <startling> merijn: iterateWhile?
09:06:12 <haasn> eg. I'd use ‘error’ for internal loops or states that should never occur, or for situations that can only happen when things violate their respective laws
09:06:14 <exicer> Cale: Okay, that seems sensible
09:06:20 <merijn> startling: No, that throws away previous results
09:06:24 <startling> oh, dang
09:06:25 <haasn> but I'd use ‘Maybe’ for anything facing the user, like ‘head’ or ‘tail’
09:06:54 <startling> merijn: unfoldWhileM :: Monad m => (a -> Bool) -> m a -> m [a]
09:07:05 <haasn> (though I wouldn't do that myself, I'd just provide a traversal and let the lens functions take care of failure for me ;)
09:07:07 <merijn> startling: \o/
09:07:20 <exicer> haasn: I'll take your word for it ;)
09:07:31 <startling> n.b. "Discards the final one (which failed the predicate)"
09:07:44 <Cale> exicer: You also have (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
09:08:03 <Cale> exicer: Nothing >>= f = Nothing; Just x >>= f = f x
09:08:09 <haasn> and (>=>) :: (a -> Maybe b) -> (b -> Maybe c) -> a -> Maybe c -- and a whole lot of other useful stuff
09:08:21 <Peaker> Trying to use shake, if I build with -threaded, I'm getting non-deterministic "openFile: resource busy (file is locked)" failures. Any shake users know about that?
09:08:28 <Cale> exicer: and along with that, you have return :: a -> Maybe a; return v = Just v
09:08:31 <exicer> I've not yet come across >>= or >=>
09:08:47 <Cale> exicer: That (>>=) and return are what makes Maybe into an instance of Monad
09:08:56 <exicer> Hmm, okay
09:09:03 <exicer> I guess I really should just read about monads
09:09:03 <donri> don't-say-the-M-word
09:09:10 <haasn> donri: :)
09:09:16 <Cale> exicer: Well, think about this monad first. :)
09:09:36 <Cale> exicer: Understanding monads in general is harder until you have a bunch of examples under your belt anyway
09:09:47 <FreeFull> exicer: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
09:09:49 <exicer> Cale: Yeah, sure. I was just going to read the lyah chapter on them
09:09:59 <FreeFull> exicer: It helps if you undestand typeclasses first
09:10:03 <FreeFull> Also functors
09:10:18 <levi> > let vals = [Just 1, Just 2, Nothing, Just 4] in fmap (fmap (+1)) vals
09:10:19 <exicer> I think I mostly understand functors
09:10:19 <lambdabot>   [Just 2,Just 3,Nothing,Just 5]
09:10:20 <startling> wow, monad-loops has short-circuiting combinators for monadic predicates, too
09:10:21 <startling> cool!
09:10:22 <exicer> and typeclasses
09:10:25 <donri> exicer: Maybe is nice if you care *that* something failed. Either is better if you care about *what* failed.
09:10:28 <startling> I've written those mysefl so many times.
09:10:38 <Cale> exicer: (>>=) is useful because it lets you take some computation which might fail, and a function which takes the result of that computation and which might itself fail, and combines them together in the natural way, failing if either one of them does.
09:10:41 <exicer> levi: holy shit
09:11:00 <levi> exicer: Both List and Maybe are Functors, so you can use fmap on both of them.
09:11:06 <Cale> exicer: For example...
09:11:09 <Cale> :t lookup
09:11:09 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
09:11:24 <haasn> > fmap (fmap (+1)) [Just 1, Just 2, Nothing, Just 4]  :: [Maybe Expr]
09:11:25 <lambdabot>   [Just (1 + 1),Just (2 + 1),Nothing,Just (4 + 1)]
09:11:34 <ocharles> > [ Just 1, Just 2 ] & traverse . traverse .~ 42
09:11:36 <lambdabot>   [Just 42,Just 42]
09:11:42 <exicer> Hm, this seems to make a lot of sense
09:11:50 * hackagebot staticanalysis 0.0.0.1 - Reusable static analysis interfaces and modules.  http://hackage.haskell.org/package/staticanalysis-0.0.0.1 (AndreiLapets)
09:11:50 <exicer> but I will need to think about it for a bit
09:11:52 * hackagebot ascetic 0.0.0.2 - Generic markup builder.  http://hackage.haskell.org/package/ascetic-0.0.0.2 (AndreiLapets)
09:11:53 <haasn> > [Just 1, Just 2] & biplate .~ 42
09:11:55 <exicer> my tiny mind can't keep up :p
09:11:55 <lambdabot>   [Just 42,Just 42]
09:11:57 <Cale> > let dict = [(1,2),(2,3),(3,4)] in do x <- lookup 1 dict; y <- lookup x dict; z <- lookup y dict; return (x,y,z)
09:11:58 <lambdabot>   Just (2,3,4)
09:12:13 <Cale> > let dict = [(1,2),(2,3),(3,4)] in do x <- lookup 1 dict; y <- lookup x dict; z <- lookup y dict; w <- lookup z dict; return (x,y,z)
09:12:14 <lambdabot>   Nothing
09:12:24 <Cale> ^^ this do-notation translates away into uses of >>=
09:12:35 <exicer> Hm, okay
09:12:38 <Cale> This is the same as:
09:12:41 <exicer> So IO actions are linked to monads somehow?
09:12:48 <haasn> exicer: IO is an instance of Monad, yes
09:12:52 <Cale> Well, IO also happens to be a monad
09:12:53 <levi> exicer: For now, I would just concentrate on taking advantage of Functor instances.  They get you a lot of convenience and they're pretty easy to understand.
09:13:05 <Cale> Because there's a suitable definition of return and (>>=) there too
09:13:15 <exicer> OKay
09:13:24 * haasn personally prefers gaining intuition via fmap/join rather than (>>=), and also liftA2 (,)
09:13:24 <Cale> Monad is just a pattern which shows up in a lot of libraries of a certain type
09:13:25 <donri> exicer: anyway the way Maybe "infects" everything just reflects how an exception propagates and needs to be handled at some point to not crash the program. Maybe just gives you a way to track it statically.
09:13:38 <levi> If you get comfortable with how Functor works, it will make Monad easier to understand.
09:13:55 <Cale> > let dict = [(1,2),(2,3),(3,4)] in lookup 1 dict >>= \x -> lookup x dict >>= \y -> lookup y dict >>= \z -> return (x,y,z)
09:13:57 <lambdabot>   Just (2,3,4)
09:14:02 <exicer> My plan was to re-read about typeclasses / etc this evening,, now that I've actually tried to use them
09:14:36 <haasn> exicer: are you comfortable with typeclasses like Show or Num?
09:14:38 <Cale> If you can handle the nested lambdas here, you can perhaps get the idea better of how >>= lets you combine lots of things which might fail into one thing which might fail (if any of them do)
09:14:55 <Cale> If you want, I can put parens in :)
09:14:57 <exicer> haasn: I think so, but I am sure I could be proven wrong :p
09:15:11 <Cale> > let dict = [(1,2),(2,3),(3,4)] in lookup 1 dict >>= (\x -> lookup x dict >>= (\y -> lookup y dict >>= (\z -> return (x,y,z))))
09:15:12 <lambdabot>   Just (2,3,4)
09:15:44 <Cale> lookup 1 dict will succeed, giving Just 2, and then x will be 2
09:15:46 <haasn> exicer: well, in general, a typeclass is just a way to associate values with types; eg. the ‘Show’ typeclass associates a value of type :: a -> String;  for some ‘a’ that is an instance
09:15:50 <levi> exicer: Don't worry if you don't grasp all of this at once. Working with type classes can take some getting used to.
09:16:00 <Cale> and then lookup x dict will give Just 3, and y will get bound to 3
09:16:03 <Cale> and so on
09:16:11 <exicer> Cale: Yeah.. not sure I quite follow :p
09:16:23 <startling> a good use-case for the Maybe monad is nested dicts.
09:16:24 <exicer> haasn: Okay, that is what I thought
09:16:28 <Cale> Maybe I should start with a simpler example
09:16:47 <Cale> > let dict = [(1,2),(2,3),(3,4)] in lookup 1 dict
09:16:48 <lambdabot>   Just 2
09:16:50 * hackagebot uxadt 0.0.0.1 - Cross-language extensible representation for algebraic data types.  http://hackage.haskell.org/package/uxadt-0.0.0.1 (AndreiLapets)
09:16:52 * hackagebot compilation 0.0.0.1 - Haskell functionality for quickly assembling simple compilers.  http://hackage.haskell.org/package/compilation-0.0.0.1 (AndreiLapets)
09:16:54 * hackagebot richreports 0.0.0.1 - Integrated pretty-printing and error/static analysis reporting.  http://hackage.haskell.org/package/richreports-0.0.0.1 (AndreiLapets)
09:16:55 <startling> > let nested = [(1, [(2, 3)])] in lookup 1 nested >>= lookup 2
09:16:55 <haasn> exicer: the “associating values with types” thing gets a bit clearer for the typeclass Monoid; which has a value ‘mempty :: a’ (where a is an instance of Monoid)
09:16:56 <lambdabot>   Just 3
09:17:37 <exicer> startling: Well I think I understand that
09:17:41 <nooodl> haasn: i think that'll make things more confusing right now
09:17:45 <levi> Monoid is another good type class to learn early on.
09:17:46 <haasn> nooodl: perhaps
09:17:59 <startling> exicer: good! might want to stare at it a bit to make sure, though
09:17:59 <exicer> Hehe, yeah monoid is another word I've heard but don't have much idea what it is
09:18:12 <haasn> well if it doesn't confuse him then I guess he understands enough about type classes to understand how the Monad typeclass abstracts over its instances
09:18:15 <startling> exicer, the key insight is that it "flattens" what would otherwise be a Maybe (Maybe Int)
09:18:35 <exicer> Okay
09:18:42 <startling> one might say it "joins" them. :)
09:19:02 <exicer> hmmhmm
09:19:21 <exicer> I'll do some reading ;)
09:19:24 <startling> exicer: do you see what would happen in "let nested = [(1, [(2, 3)])] in lookup 0 nested >>= lookup 2"?
09:19:31 <haasn> another easy Monad instance (imo) is [], where (>>=) is just concatMap
09:19:32 <exicer> startling: Nothign ?
09:19:32 <dmwit> > ".22Spinner.22_errors_while_trying_to_compile_the_.22notebook.22_demo" == ".22Spinner.22_erros_while_trying_to_compile_the_.22notebook.22_demo"
09:19:32 <haasn> :t concatMap
09:19:33 <lambdabot> (a -> [b]) -> [a] -> [b]
09:19:33 <lambdabot>   False
09:19:39 <startling> exicer, yep.
09:19:46 <dmwit> ah, "erros"
09:19:49 <haasn> > concatMap (\x -> [x, x*1000]) [1..3]
09:19:50 <lambdabot>   [1,1000,2,2000,3,3000]
09:19:50 <Cale> exicer: It might be better if we were doing this in a channel with less scrolling :)
09:19:52 <dmwit> > ".22Spinner.22_errors_while_trying_to_compile_the_.22notebook.22_demo" == ".22Spinner.22_errors_while_trying_to_compile_the_.22notebook.22_demo"
09:19:53 <lambdabot>   True
09:19:56 <haasn> > map (\x -> [x, x*1000]) [1..3] -- note the difference
09:19:57 <lambdabot>   [[1,1000],[2,2000],[3,3000]]
09:19:59 <exicer> Haha, yeah true
09:20:03 <ocharles> Cale: isn't this a case for #haskellindepth?
09:20:04 <ocharles> :)
09:20:08 <Cale> exicer: It's kind of important to keep the definition of >>= in front of you
09:20:10 <startling> #haskell-overflow?
09:20:11 <ocharles> or whatever the thing is called
09:20:20 <banister> Cale: installed gloss, where can i find the example games?
09:20:21 <Cale> yeah, let's go to #haskell-overflow
09:20:24 <exicer> Okay
09:20:42 <Cale> banister: There are a bunch of examples in the gloss-examples package
09:20:55 <banister> Cale: thanks
09:21:04 <dmwit> enthropy: Should be fixed. Thanks for reporting.
09:22:00 <banister> Cale: sorry im a bit noob, after i've installed the cabal package containing the examples, where is the example folder to be found?
09:22:40 <Cale> banister: I think the examples end up in ~/.cabal/bin
09:22:51 <Cale> banister: But you're going to want to cabal unpack gloss-examples anyway
09:23:02 <Cale> so you can look at the code and fiddle with them :)
09:26:17 <dmwit> I always read -funfolding-* as fun folding.
09:27:40 <c_wraith> folding is fun
09:27:51 <donri> -funbox is a box of fun!
09:28:24 <banister> Cale: cool, got it working. However the mandelbrot example takes ages (about 2-3 seconds) to render, is this normal? or something messed up with my setup?
09:29:13 <haasn> dmwit: reminds me of -funroll-loops
09:30:00 <haasn> and relatedly, the somewhat more unfortunately named -fomit-frame-pointer; although fortunately the letters only sound similar
09:30:51 <geekosaur> although I conjecture the similarity may be deliberate due to its resemblance to what happens in case the program dumps core :)
09:31:55 <Cale> banister: I haven't tried it... you might try compiling it with -O2 if you just compiled normally, but I don't think those things are especially optimised for efficiency.
09:33:04 <dmwit> The cabal file specifies all kinds of optimization flags.
09:33:35 <dmwit> I'm betting you won't do much better than the ones in the cabal file unless you're prepared to do some actual profiling. =)
09:36:22 <banister> Cale: haha -O2 *really* changed it
09:36:29 <banister> Cale: instead of beachballing it runs extremely fast now
09:36:52 * hackagebot imparse 0.0.0.1 - Multi-platform parser analyzer and generator.  http://hackage.haskell.org/package/imparse-0.0.0.1 (AndreiLapets)
09:38:31 <Cale> banister: Yeah, you can't rely on performance at all with optimisations turned off
09:40:24 <mr-> banister: glossy programs should also be compiled -threaded
09:40:51 <banister> mr-: whycome?
09:41:29 <mr-> banister: the documentation says so ;-)
09:41:40 <banister> ah, thanks
09:41:40 <mr-> (The FAQ rather)
09:42:11 <banister> what's a .hi file?
09:42:27 <Jeanne-Kamikaze> the .o of ghc
09:42:44 <Jeanne-Kamikaze> haskell intermediate file I suppose
09:42:52 <banister> but i see .o files generated too
09:42:57 <haasn> Haskell Interface
09:43:07 <Jeanne-Kamikaze> ah, .hi is what ghci generates isn't it
09:43:08 <haasn> it's like a .h file more than an .o file, afaik
09:43:16 <haasn> Jeanne-Kamikaze: GHC generates them
09:43:19 <Jeanne-Kamikaze> I see
09:43:30 <haasn> they store info about functions exported by your module, etc.
09:43:31 <cschneid> if I want to represent a piece of data that can be shown in several different ways (MacAddress can be shown with 'aa:bb:cc' syntax, or no punctuation, or upper/lower case). How would I model that
09:43:36 <haasn> code that needs to be inlined
09:43:37 <haasn> that sort of stuff
09:43:54 <Jeanne-Kamikaze> banister, are you manually compiling stuff ?
09:44:23 <banister> Jeanne-Kamikaze: Yeah, how would i otherwise automate it?
09:44:26 <banister> i just see Main.hs in the folders
09:44:27 <Jeanne-Kamikaze> use cabal
09:45:35 <haasn> GHC still outputs .hi/.o files when you invoke it via cabal :)
09:45:48 <Jeanne-Kamikaze> but it doesn't plague the source directory
09:45:53 <haasn> fair enough
09:46:06 <haasn> anyway, nothing wrong with compiling manually; I do it all the time for single-file programs
09:46:16 <banister> Jeanne-Kamikaze: how do i compile with cabal?
09:46:37 <haasn> probably best to start with the cabal user's guide
09:46:40 <haasn> it's a build system
09:46:55 <Jeanne-Kamikaze> yeah, just check it out on the wiki
09:46:58 <haasn> and requires you to write a configuration file for it (.cabal); if this is your own project
09:46:59 <banister> haasn: assumign i jus thav ea single Main.hs file in the directory, how do i use cabal to build it? :)
09:47:04 <banister> ah ok
09:47:06 <haasn> if it's somebody else's, there's probably already a .cabal file there
09:47:10 <Jeanne-Kamikaze> it's simple but it's easier if you just read what's already written
09:47:12 <banister> ther'es not in this case
09:47:43 <geekosaur> if you really want to use cabal, then `cabal init` will create a cabal file including making a first pass at figuring dependencies and such
09:47:47 <haasn> if you just have a single Main.hs I would honestly just run “ghc Main.hs” ;)
09:47:50 <sm> if banister's successfully compiling a single file with ghc, why push towards cabal ? sounds like overkill
09:48:13 <geekosaur> but for a single source file I agree with haasn, only reason to use cabal there is complex deps
09:48:18 <geekosaur> or flags
09:48:29 <Jeanne-Kamikaze> yeah it's overkill for a single file, but just so he knows that it's there
09:48:39 <dmwit> The package in question is gloss-examples, and it specifies a lot of flags.
09:48:56 <dmwit> So I don't agree with this advice that it's overkill.
09:49:12 <dmwit> Especially since he has already observed that at least one of the programs performs badly when not compiled with cabal.
09:49:35 <dmwit> It is very easy to cabal build: just cd up to the top package directory (where the *.cabal file should be) and type "cabal build".
09:49:51 <dmwit> Then you will get a bunch of directories in .dist/build, one for each executable.
09:52:31 <banister> what format is cabal? a custom format or yaml or valid haskell code?
09:52:37 <banister> i mean the .cabal files
09:52:40 <tikhon> it's a custom format
09:52:41 <dmwit> It is a custom format.
09:52:44 <tikhon> for better or worse
09:52:47 <tikhon> (worse)
09:53:25 <simon> hello. I'm confused; do I pick 'parsec', 'parsec1', 'parsec2' or 'parsec3' from cabal?
09:53:48 <haasn> I know absolutely nothing about this but higher must be better, right?
09:53:58 <simon> the only thing I know is that parsec3 is a generalized improvement over parsec2. I don't know if people generally prefer it, or if it's less efficient or what.
09:54:01 <tikhon> I think the normal parsec package is the one to go for
09:54:19 <simon> tikhon, I like that thought. its version is also 3.something.
09:54:32 <Clint> or you could avoid the whole question with attoparsec
09:54:34 <quchen> simon: Why don't you use the Haskell platform? It's pretty much the standard library.
09:54:39 <quchen> (Also it's Parsec 3.)
09:54:40 <Guest12648> hey! quick question: is it possible to define a type synonym like: type Vector = (Num a) => (a, a) ?
09:54:41 <dmwit> haasn: Which is higher, parsec or parsec3? =)
09:54:42 <tikhon> Clint: no, they are for different things
09:54:57 <dmwit> Guest12648: nope
09:54:59 <Clint> every time i use parsec i regret it
09:55:17 <simon> quchen, I'm unsure what using the haskell platform means. I thought I did. :) does it bundle parsec 3 with it?
09:55:20 <quchen> Guest12648: You can do something almost like that, but it's not a good idea.
09:55:27 <tikhon> Clint: if you're doing PL stuff, you should almost definitely choose parsec over attoparsec
09:55:32 <Guest12648> @dmwit how would you approach that then? create a new data-type for a vector? represent it as a tuple?
09:55:33 <lambdabot> Unknown command, try @list
09:55:43 <dmwit> Guest12648: That's not a bad idea.
09:55:56 <dmwit> e.g. data Vector a = Vector a a
09:56:04 <quchen> simon: GHC comes with a couple of basic libraries. Then there's the Haskell Platform, which is a collection of libraries that are very stable and useful. "The Haskell standard library" is de facto GHC's libs + Platform.
09:56:05 * simon reads what it means.
09:56:13 <Guest12648> "You can do something almost like that" => ?
09:56:17 <Clint> tikhon: since i don't know what that is, i'll take your word for it
09:56:42 <tikhon> PL = programming language
09:56:45 <Clint> ah
09:56:46 <dmwit> Guest12648: Not really. Just put Num a constraints on the types of functions that use Vector.
09:56:52 <tikhon> so if you're implementing an interpreter or some tooling or something
09:56:52 <dmwit> Guest12648: It's more honest that way anyway. =)
09:56:58 <quchen> Guest12648: In general, you should never create types that are constrained by a typeclass. Functions carry constraints, types should be generic.
09:56:59 <Clint> tikhon: yes, i never want to do that
09:57:01 <tikhon> or a compiler
09:57:14 <dmwit> Guest12648: (You can do it with GADTs, but I recommend you play with the standard H2010 way for a while before you decide it's unworkable. =)
09:57:20 <tikhon> ooh, you should: it's a lot of fun
09:57:29 <Clint> i don't have time for fun
09:57:32 <Guest12648> ok, thanks!
09:57:52 <quchen> Guest12648: For example, if you defined something like the Vector above, the function "xComponent" would require Num, although it's perfectly valid for any type in the vector.
09:59:55 <tikhon> simon: so, if you want a definitive answer: just use the parsec package
10:00:17 <Guest12648> so even if I declare a new data-type, i.e. data Vector = Vector a a, I cannot constraint a to Num
10:00:44 <Guest12648> data Vector a *
10:00:53 <NiceOneBrah> is there a way in Haskell to iterate through a list in a sliding-window fashion without writing your own explicitely recursive function? I looked around on Hoogle for a function like Int -> [a] -> [[a]] where you can specify the window size and a list and get back a list of overlapping segments, but I didn't find anything
10:01:05 <Guest12648> that goes in the functions that manipulate Vectors
10:01:06 <startling> Guest12648: correct.
10:01:19 <simon> tikhon, thanks.
10:01:38 <Guest12648> thanks
10:01:38 <simon> tikhon, I just had to realize that both parsec and attoparsec are in the subset of packages called Platform.
10:02:03 <quchen> Guest12648: Well, you *can* constrain, but you should not.
10:02:15 <quchen> Guest12648: A constraint should always be necessary for something to work.
10:02:21 <Guest12648> quchen: ok
10:02:23 <tikhon> NiceOneBrah: I don't know of any function for *overlapping* windows like that
10:02:26 <mr-> Why is something like " foo (x:xs) = [foo xs | not (null xs)] " not allowed?
10:02:28 <quchen> For example, it makes sense for "sort" to have an "Ord" constraint, because it wouldn't work without it.
10:02:49 <quchen> Guest12648: However, your Vector is a wrapped 2-tuple. Does that tuple work without Num? Sure it does.
10:02:58 <dmwit> Guest12648: In particular, you should not *because* that means there are many operations you can't implement that are nevertheless often quite sensible; for example, you can't turn Vector into a Functor or Monad if you constrain it (but can if you don't).
10:03:03 <Neqoxec> NiceOneBrah: `take' and `drop' can be used to select or drop first parts of lists
10:03:03 <quchen> Guest12648: Functions adding two vectors need Num, so those should carry the constraint.
10:03:42 <simon> mr-, because it's a list of lists of lists of lists of ... (the type depends on the number of elements in the input list which is not known at compile time)
10:04:00 <quchen> Guest12648: A similar thing to constraining a type would be giving `sort` the type `(Ord a, Show a) => [a] -> [a]`. It's valid, but is the Show necessary for the function to work or make any sense? No, it just locks out a number of perfectly valid types.
10:04:13 <simon> mr-, try and concatenate those foo xs.
10:04:51 <NiceOneBrah> thanks tikhon, Neqoxec
10:05:47 <simon> mr-, i.e. concat [ foo xs | ... ] -- although the result doesn't seem overly useful.
10:05:50 <tikhon> NiceOneBrah: last time I needed something like that, I just wrote my own; it was only a couple of lines
10:06:23 <simon> mr-, maybe you should not throw away every element of the list, x. ;-)
10:07:55 <tikhon> @let window _ [] = []; window n (x:xs) = take n (x:xs) : window n xs
10:07:56 <lambdabot>  Defined.
10:08:03 <tikhon> > window 4 [1..10]
10:08:06 <lambdabot>   mueval-core: Time limit exceeded
10:08:15 <tikhon> > window 3 [1..5]
10:08:19 <lambdabot>   mueval-core: Time limit exceeded
10:08:22 <tikhon> hmm
10:08:55 <mr-> simon: ah, of course. The type has to be known at compile time..
10:09:05 <geekosaur> works here, maybe @let overgrew again?
10:09:15 <tikhon> probably
10:09:25 <quchen> > map (take 3) $ tails [1..10] -- tikhon
10:09:27 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10],[1...
10:09:40 <mr-> simon: I knew the type would have been [..[a]..] where the number of brackets is the number of elements in the list. Just did not see the problem with having that ;-)
10:10:22 <dmwit> > window 3 [1..5]
10:10:26 <lambdabot>   mueval-core: Time limit exceeded
10:11:43 <tikhon> lambdabot is acting in deeply disturbing and suspicious ways
10:27:58 <S_J> > Nothing >>= \r -> return $ case r of Nothing -> 5; Just x -> x;
10:27:59 <lambdabot>   Nothing
10:28:13 <S_J> > Just 5 >>= \r -> return $ case r of Nothing -> 5; Just x -> x;
10:28:14 <lambdabot>   No instance for (GHC.Show.Show b0)
10:28:14 <lambdabot>    arising from a use of `M1468681062.sh...
10:28:35 <haasn> S_J: you're matching ‘5’ against ‘Just x’, so GHCi wants a Num (Maybe x) instance
10:28:38 <haasn> GHC
10:28:40 <haasn> w/e
10:28:42 <S_J> so if i do (Maybe x >>= some code) I cant do anything with nothing? if i use do i can use (<-) and then use case. how would I use >>= and have one case for both Nothing and Just?
10:28:57 <S_J> @type (<-)
10:28:58 <lambdabot> parse error on input `<-'
10:29:27 <haasn> I have no idea what you're asking, and ‘<-’ is part of do-syntax sugar, it's not a function
10:29:38 <simon> @pl do { x <- f; g; return x }
10:29:38 <lambdabot> (line 1, column 4):
10:29:38 <lambdabot> unexpected '{'
10:29:38 <lambdabot> expecting variable, "(", operator or end of input
10:29:46 <haasn> @undo do { x <- f; g; return x }
10:29:46 <lambdabot> f >>= \ x -> g >> return x
10:30:29 <S_J> yes but with (>>=) instead of do, how would I deal with Nothing ? I dont want to do nothing on Nothing, I want to print something
10:30:30 <simon> I was actually looking for a combinator that might do this.
10:30:59 <haasn> S_J: maybe you want something like ‘maybe’ or ‘fromMaybe’?
10:31:01 <haasn> :t maybe
10:31:02 <lambdabot> b -> (a -> b) -> Maybe a -> b
10:31:04 <haasn> :t fromMaybe
10:31:04 <lambdabot> a -> Maybe a -> a
10:31:24 <haasn> > fromMaybe 5 Nothing
10:31:25 <lambdabot>   5
10:31:27 <haasn> > fromMaybe 5 (Just 100)
10:31:28 <lambdabot>   100
10:31:29 <simon> S_J, m >>= \x -> case x of ...
10:32:31 <S_J> simon: but the >>= throws away Nothing
10:32:57 <simon> S_J, then so would do-syntax.
10:33:06 <hpaste> js pasted “do vs >>=” at http://lpaste.net/91633
10:33:15 <S_J> ^^ code and question
10:33:35 <geekosaur> you can rewrite that but it doesn't do what you think
10:33:47 <geekosaur> <- is actually >>=
10:34:03 <geekosaur> if it's a Maybe (Maybe thing) then you get the Maybe thing
10:34:19 <geekosaur> if it's just Maybe thing then it won't get run on Nothing
10:35:15 <geekosaur> oh, I get it
10:35:39 <geekosaur> S_J: you're looking at the wrong Monad instance
10:35:45 <haasn> S_J: (>>=) here is in the IO Monad, whereas in your earlier instance, you were using the Maybe Monad
10:35:49 <geekosaur> that's in IO, the (>>=) will be the one in IO
10:35:50 <haasn> that's not at all what's happening
10:36:24 <haasn> S_J: did you mean to include a ‘return’ before your ‘Just 5’ example? eg.
10:36:31 <simon> haasn, I seem to recall that there's a parsec combinator that lets me do something like f `comb` g to achieve this.
10:36:49 <haasn> :t return (Just 3) >>= \mm -> case mm of Nothing -> return 5; Just x -> return x :: IO Integer
10:36:50 <lambdabot> IO Integer
10:36:55 * hackagebot imparse 0.0.0.2 - Multi-platform parser analyzer and generator.  http://hackage.haskell.org/package/imparse-0.0.0.2 (AndreiLapets)
10:37:04 <haasn> simon: achieve what, exactly?
10:37:17 <simon> haasn, do { x <- f; g; return x }
10:37:29 <haasn> oh
10:37:43 <eduardo_> Hello, guys. Has anybody tried to install wxhaskell on Snow Leopard? I tried to follow these instructions: http://www.haskell.org/haskellwiki/WxHaskell/Mac , but got an error: http://lpaste.net/91634
10:37:48 <haasn> simon: f <* g -- might do it
10:38:22 <haasn> will do it, in fact
10:38:25 <simon> thanks. ;-)
10:38:55 <geekosaur> eduardo_, that's not an OS X issue, that's a ghc version issue
10:39:21 <eduardo_> geekosaur: Is there anything I can do to fix it?
10:39:23 <geekosaur> 7.6.3 is much more pedantic (strictly following the standard) about FFI declarations
10:40:09 <simon> doesn't (*>) do the same as (>>), but is restricted typewise?
10:40:37 <geekosaur> less restricted, I think (*> needs only Functor IIRC?)
10:41:53 <n-dolio> Applicative.
10:42:23 <eduardo_> geekosaur: So wxhaskell only works on ghc < 7.4 ?
10:43:25 <simon> maybe I'm thinking upside down, but I've thought of Applicative as more restrictive than Monad.
10:43:56 <Philippa> in this particular regard, no: all Monads have (possible) Applicative instances
10:44:07 <geekosaur> eduardo_, looks like it. (note that the build failure on the hackage server is unrelated; it's failing there because WxWindows dev libs aren't installed)
10:44:14 <Philippa> there's a reason <*> is pronounced 'ap'
10:44:14 <startling> :t ap
10:44:16 <lambdabot> Monad m => m (a -> b) -> m a -> m b
10:44:32 <eduardo_> geekosaur: thanks
10:44:55 <simon> :t (>>=)
10:44:57 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:44:59 <geekosaur> probably want to try to contact the maintainr
10:45:02 <haasn> simon: the only ‘restriction’ is that you might be unable to use it with some really old Monad instance that was implemented before Applicative was around ;)
10:45:17 <simon> haasn, it wasn't that kind of restriction I was thinking of, but ok. ;)
10:46:48 <dmwit> :t (*>)
10:46:49 <lambdabot> Applicative f => f a -> f b -> f b
10:47:16 * geekosaur meant Applicative there. not doing well today for some reason...
10:50:45 <Guest12648> any tips on fun exercises to practice haskell other than 99 problems & euler?
10:51:09 <haasn> Guest12648: implement pong. Trust me, it's lots of fun :)
10:51:36 <haasn> Guest12648: http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/ maybe?
10:51:49 <haasn> though note that said exercise is a bit lawless
10:52:16 <eduardo_> Speaking of pong, does anybody know of good resources on writing games in haskell?
10:52:23 <Guest12648> haasn: implementing a UI in haskell isn't too much of a pain?
10:52:36 <Guest12648> haasn: thanks!
10:52:58 <haasn> Guest12648: not with the right libraries :)
10:53:10 <haasn> I like ‘gloss’ for this task
10:53:24 <haasn> it's my tried and trusted “implementing pong” library
10:53:39 <simon> eduardo_, have you read http://www.haskell.org/haskellwiki/Game_Development ?
10:53:53 <haasn> eduardo_: you might want to ask ocharles
10:54:12 <eduardo_> simon: I haven't read that. Thanks!
10:54:51 <eduardo_> haasn: thanks. Has ocharles made games in haskell?
10:55:13 <S_J> what channel would be suitable to discuss how to program a database(not use one)?
10:55:36 <haasn> eduardo_: he's been working on some cool projects involving netwire and SDL, I'm guessing he could link to a resource or two to learn more about this stuff
10:56:28 <simon> S_J, I don't think there is a community for that.
10:56:50 <eduardo_> Writing games in haskell might be challenging not only because of the graphics stuff, but also because of the datastructures
10:58:28 <sm> woah game dev is a hot topic this week
10:59:20 <Philippa> having John Carmack give a talk on FP will do that
10:59:26 <path[l]> haha
10:59:43 <simon> Philippa, is that available on the net?
10:59:45 <sm> ahh makes sense :)
10:59:47 <sm> eduardo_: that wiki page is the best starting point, there's also #haskell-game
10:59:56 <Philippa> I actually heard about it via my girlfriend during our nightly call that day
11:00:00 <Philippa> simon: yep
11:00:11 <Philippa> you'd have to dig it up yourself or hope someone else has the address though
11:00:28 <sm> simon: search, it was well linked
11:00:36 <simon> thanks.
11:00:38 <simon> interesting.
11:00:39 <startling> I don't know if I would call it a talk on fp.
11:01:01 <eduardo_> http://www.altdevblogaday.com/2012/04/26/functional-programming-in-c/
11:01:15 <startling> more like "John Carmack once half-heartedly ported some of wolfenstein to haskell, also he thinks writing pure functions in C/whatever is a good idea"
11:01:37 <sm> http://www.reddit.com/r/haskell/comments/1jj40p/john_carmack_talking_at_length_about_haskell_in/cbff7cp
11:01:56 * hackagebot kan-extensions 3.6.2 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-3.6.2 (EdwardKmett)
11:02:06 <aristid> startling: well he also does heap some more praise on haskell, saying that it is awesomer than scheme! ;d
11:02:09 <aristid> :D
11:02:57 <startling> my favorite part is when someone in the audience asks if he's looked into abstract algebra and he ignores that part of the question.
11:04:00 <aristid> startling: i think the guy who asked that question showed some serious misunderstanding what kind of person carmack is ;)
11:04:11 <path[l]> haha
11:05:14 <startling> heh
11:06:05 <danharaj> edwardk: If a kan extension is a generalized continuation passing style transform, what is a kan lift?
11:07:13 <startling> aristid: anyway, I just thought it was funny that he didn't just say "no"
11:08:44 <ReinH> edwardk: how many "KAHNNNN!!!!!" jokes have you gotten so far
11:08:49 <aristid> startling: i think he probably just zeroed in on what seemed to him the interesting part of the question, and ignored the stuff he didn't understand
11:08:58 <startling> that's fair.
11:09:02 <aristid> startling: maybe he's also too vain to say "i didn't understand"
11:09:09 <startling> it wasn't the interesting part of the question, though. :(
11:10:14 <Hafydd> What question are you talking about?
11:10:21 <Demos> yeah what was the other part
11:10:47 <startling> it was like "have you looked into abstract algebra for GPU operations" and he just talked about GPUs
11:11:28 <Demos> well otherwise it would not have made any sense, how does abstract algebra have anything to do with GPU operations, that is the whole point
11:11:52 <elliott> how does category theory have anything to do with programming?
11:12:01 <ReinH> something something monads
11:12:12 <Demos> now in haskell: the Nvidia monad
11:12:12 <ReinH> obv we need a GPU monad
11:12:15 <ReinH> damn it
11:12:22 <Demos> HA!
11:12:28 <aristid> startling: iirc he also talked about monads in a way that conflated them with IO
11:12:44 <ReinH> aristid: imperative programmer doesn't quite understand monads, story at 11
11:12:44 <edwardk> danharaj: a different generalization of continuation passing style ;)
11:12:46 <aristid> startling: but i mean, if you expect the guy to be an expert in haskell you're misguided
11:12:51 <edwardk> ReinH: a lot
11:12:56 <ReinH> edwardk: awesome :)
11:13:07 <danharaj> edwardk: Fair enough :P
11:13:21 <danharaj> edwardk: Can you explain the assymetry in your Rift definition and Lift definition?
11:13:24 <sm> I am really looking forward to seeing his Wolfenstein port, even incomplete
11:13:27 <startling> aristid: sure. I just thought it was funny.
11:13:30 <edwardk> ReinH: i made a char in the star trek MMO named 'Daniel Kan'. everyone in there kept telling me his name was mis-spelled.
11:13:36 <danharaj> Is there a limitation of Haskell's type system that doesn't let you simplify Lift as you did Rift?
11:13:44 <ReinH> aristid: There was someone in /r/Ruby this morning who thinks that classes are algebraic data types
11:13:47 <path[l]> people in general conflate monads with IO because a quick explanation of purity results in people saying "and so if you want to do IO, you have to use monads"
11:14:04 <aristid> ReinH: maybe he has dualisation glasses?:D
11:14:09 <edwardk> danharaj: well. notice the haddocks at the top of Ran about how you could alternately define Ran in terms of its universal property
11:14:12 <tikhon> coglasses
11:14:16 <danharaj> indeed
11:14:25 <edwardk> danharaj: there does exist a version that eliminates the references to Z, but it isn't very pretty
11:14:25 <ReinH> aristid: not quite http://www.reddit.com/r/ruby/comments/1jvskt/simple_algebraic_data_types_for_ruby/
11:14:34 <Hafydd> Expecting him to display some humility according to his ignorance is a different matter, however.
11:14:49 <edwardk> Lift is the only example where directly using the universal property sucks less than using the weird double-negation-like encoding of it
11:15:04 <ReinH> aristid: he thinks a switch statement on a object's class is the same thing as pattern matching on a sum type
11:15:11 <ReinH> it was... strange
11:15:27 <c_wraith> People should use the word "monad" much less often.  It's just "IO", not "the IO monad".  "You have to use IO for that." is good.  If more clarification is needed, "You have to use the IO type for that." Just never say "the IO monad" as if the word "monad" adds any meaning.
11:15:40 <edwardk> you can use something like: newtype Lift g f a = Lift { runLift :: forall r. (forall e. f e -> g ((e -> a) -> r)) -> r }  instead
11:15:45 <eduardo_> geekosaur: I want to remove everything I installed with cabal and restart from scratch. Will removing ~/.cabal  do it?
11:15:50 <edwardk> but that is rank-3 anyways
11:16:04 <ReinH> c_wraith: but... but... how else can I demonstrate my knowledge of monads?
11:16:16 <tikhon> "IO type" is fine, but "IO" as a noun already has a well-defined meaning (ie input/output in general)
11:16:23 <geekosaur> eduardo_, only half of it. and if you're using the "official" haskell platform, actually none of it
11:16:42 * aristid makes not to self to find an occasion to annoy c_wraith with "String monad"
11:16:50 <eduardo_> geekosaur: I installed haskell using homebrew for mac
11:16:52 <yitz> c_wraith: you have to use the IO mmmmfl...ahem for that
11:16:57 <Hafydd> Hahah!
11:16:58 <geekosaur> ghc's package database is in ~/.ghc and all removing ~/.cabal will do is leave ghc thinking it has libraries that it doesn't
11:17:09 <eduardo_> geekosaur: I want to remove everything and install an older version of ghc
11:17:22 <edwardk> c_wraith: Clearly you should use the reverse state monad on RealWorld# and check what the newspaper will be tomorrow before buying your stocks today.
11:17:25 <geekosaur> then you need to remove ~/.cabal and ~/.ghc
11:17:28 <aristid> eduardo_: older? do you currently use HEAD?
11:17:40 <c_wraith> tikhon: words have contextual meanings. if it's unclear that you mean the type from context, yes, say "the IO type". But in many contexts, the meaning is quite clear.
11:17:48 <aristid> .ghc should be version-specific so i don't think it's really necessary to remove
11:17:53 <eduardo_> I know that `brew remove haskell-platform` will remove ghc
11:18:07 <geekosaur> aristid, they're trying to install wxhaskell but that has FFI stuff that's not compatible with newer ghc's strict interpretation of the spec
11:18:08 <c_wraith> edwardk: stocks are too slow.  winning lottery numbers.
11:18:12 <eduardo_> aristid: I have ghc 7.6.3
11:18:24 <tikhon> c_wraith: that's what I do. For example, I would say "in IO" but "you would have to use the IO type"
11:18:25 <aristid> eduardo_: downgrading to 7.4? :(
11:18:36 <elliott> c_wraith: I don't see what's wrong with saying "the IO monad". monads are a structure. similarly "the free monoid" etc.
11:18:37 <eduardo_> aristid: I want to try out wxhaskell, and I've just found out that it does not work with ghc 7.6.3
11:18:43 <eduardo_> aristid: 7.4 or older
11:18:43 <geekosaur> I think all it needs is some extra imports, actually...
11:18:48 <eduardo_> aristid: LOL
11:18:55 <tikhon> Why not the "IO applicative functor"? You never hear that...
11:18:57 <c_wraith> elliott: it makes people associate IO and monads, which is the opposite of useful for learning.
11:18:59 <aristid> eduardo_: :(
11:19:04 <haasn> c_wraith: you're still thinking too small. Forget about money, import technology 100 years into the future
11:19:13 <sm> eduardo_: note that installing multiple ghc versions at the same time just works
11:19:17 <c_wraith> haasn: can't do that with tomorrow's newspaper
11:19:22 <ion> tikhon: People who know enough to know about it tend to say just “IO”. :-P
11:19:29 <aristid> eduardo_: why not try out some other GUI thingie :)
11:19:33 <ion> tikhon: Unless specifically referring to the Monad instance
11:19:34 <eduardo_> aristid: unless there is some way to get wxhaskell working on ghc 7.6.3
11:19:44 <dmwit> elliott: I don't have a lot of context on this conversation, but I would argue that "the IO monad" implies that its monad-ness is relevant to the current discussion. In many (most?) uses of "IO" in conversation, its monad-ness is not relevant.
11:19:48 <aristid> well you could probably fix it with a bit of effort ;)
11:19:55 <eduardo_> sm: really??? how can I do that ?
11:20:07 <haasn> c_wraith: just use one of the classified ads to carry information backwards one day at a time, do it for the rest of your life
11:20:14 <eduardo_> aristid: can you recommend me one?
11:20:15 <haasn> laziness will make it work out
11:20:18 <aristid> eduardo_: look in ~/.ghc
11:20:24 <c_wraith> haasn: sounds like way more work than just buying a lotto ticket. :)
11:20:25 <Demos> is there an FLTK binding to haskell?
11:20:29 <aristid> eduardo_: do you see the directories with the ghc version in the name?
11:20:39 <aristid> eduardo_: that's how having multiple versions "just works" :)
11:20:54 <sm> eduardo_: instead of uninstalling 7.6 (which you'll want for other stuff), install 7.4 and select it when needed by doing cabal install -w ghc-7.4.x
11:21:01 <elliott> dmwit: I think it's often very relevant.
11:21:07 <dmwit> elliott: For comparison: "You can use foldr to summarize lists." is more clear than "You can use foldr to summarize a list monad.".
11:21:15 <eduardo_> aristid: I have "ghci_history" and "x86_64-darwin-7.6.3"
11:21:22 <elliott> dmwit: "how can I read a line and print it out?" -- you're going to use getLine, putStrLn and, importantly, (>>=) (or equivalently, do notation).
11:21:32 <eduardo_> sm: thanks !!!
11:21:33 <tikhon> dmwit: part of the problem there is that the list type and its values get conflated
11:21:36 <elliott> the "monad" part is the essential interface to the composability that lets you do this here.
11:21:39 <dmwit> elliott: Yes, sometimes, I agree. And in those situations, you *should* say "IO monad".
11:21:50 <sm> eduardo_: ghc-pkg-7.4 list will show you your 7.4-specific installed packages
11:21:51 <tikhon> a list is a list is a list, but it's the type that's the monad
11:21:57 <aristid> eduardo_: as you can guess, ghci_history isn't really version-specific or even important.
11:22:20 <eduardo_> sm: now I have to figure out how to install ghc 7.4 using homebrew
11:22:22 <ReinH> elliott: I won't be part of your system! *uses =<<*
11:22:40 <sm> eduardo_: ah, that I don't know. I'd use the binary from haskell.org/ghc
11:23:08 <edwardk> danharaj: did that make any sense?
11:23:22 <ReinH> dmwit: also something something Foldable :p
11:23:40 <edwardk> danharaj: you can view that as a particular choice of 'z' in the original definition, which encodes "just enough information"
11:23:41 <eduardo_> sm: thanks
11:25:00 <edwardk> danharaj: http://comonad.com/kan-extensions/ has haddocks for the latest release
11:25:11 <danharaj> edwardk: yeah it does make sense. Cool.
11:25:43 <aristid> ReinH: i always use fmap and join!
11:26:47 <aristid> :t join (fmap putStrLn getLine)
11:26:48 <lambdabot> IO ()
11:26:53 <ReinH> I know :)
11:27:09 <edwardk> i still want a nice interpretation of "Co" as a right kan lift along a comonad. i get why it has the operational behavior it has from the 'sandwiching a monad in the middle of an adjunction' trick that ddarius noted way back in the day, but i'd really like a nicer explanation in terms of lifting
11:27:41 <edwardk> and i'd be even happier if i could nicely encode CoT as a kan lift
11:27:50 <edwardk> rather than the weird not-quite kan-lift it is now
11:27:58 <donri> man i almost want type inequality so i can say (IsString s, s !~ ByteString) so i don't have to explain in the docs how the bytestring instance probably isn't safe
11:28:02 <ReinH> edwardk: You need a library called Kant now.
11:28:09 <ReinH> Because that sounds better than Cokan.
11:28:22 <tikhon> KanT
11:28:29 <ReinH> there it is
11:28:35 <edwardk> ReinH: that would be a bit too depressing though
11:29:02 <ReinH> edwardk: what, you don't think people can handle the *categorical* imperative?
11:29:03 <tikhon> yeah, we don't like imperative stuff here
11:29:06 <ReinH> I'll show my self out.
11:29:22 <danharaj> edwardk: maybe if you right down a right kan lift as an end formula and Co as an end formula you'll be able to see how one fits into the other.
11:29:32 <dmwit> donri: You should be able to get something like that with the upcoming closed type families stuff in GHC.
11:29:40 <donri> hehe
11:29:59 <edwardk> danharaj: sure. i can derive one from the other, but i don't get any intuition from the 'it is a right kan lift along a comonad' statement
11:30:01 <dmwit> Dunno for sure, but I would think something like type family IsNotBytString where instance IsNotByteString ByteString = False; IsNotByteString a = True
11:30:18 <dmwit> and then use (IsString s, IsNotByteString s ~ True)
11:30:29 <edwardk> i want the latter to steer me towards the same operational behavior i see, and it doesn't do that for me
11:30:38 <startling> oh, is that what ~ means? neat.
11:30:54 <donri> interesting :)
11:31:00 <dmwit> startling: ~ is type-level equality
11:31:03 <tikhon> for types, ~ is an equality constraint
11:31:04 <startling> I saw it in a lens type and couldn't decipher it.
11:31:16 <edwardk> another somewhat unsatisfying thing is i _want_ a monad for Rift f f -- but so far I only have an Applicative and a bunch of special cases where Rift f f forms a monad.
12:04:58 <lbodor> @help
12:04:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:05:21 <lbodor> @list
12:05:21 <lambdabot> What module?  Try @listmodules for some ideas.
12:05:26 <lbodor> @help list
12:05:27 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
12:06:47 <ReinH> lbodor: you can also use lambdabot in a private message btw :)
12:16:52 <applicative> eduardo_: you will have better luck with https://github.com/wxHaskell/wxHaskell if it hasn't been mentioned
12:17:13 <eduardo_> applicative: thanks! I'll have a look!
12:17:36 <eduardo_> applicative: maybe that works with ghc 7.6.3 ?
12:17:54 <applicative> eduardo_: it should
12:18:05 <applicative> several of the patches are for that.
12:18:11 <eduardo_> I'll try that, thanks
12:18:18 <applicative> i built some version like this not too long ago
12:18:59 <eduardo_> applicative: I want to try wxHakell because I am already familiar with wxpython
12:19:04 <banister> in this they talk about foldl' being a lazy version of foldl, but they dont appear to define it anywhere, anyone knoe wtf is up? https://www.fpcomplete.com/school/haskell-fast-hard/haskell-fast-hard-part-3
12:19:31 <applicative> wait foldl is a lazy version of foldl'
12:19:37 <applicative> or am I not understanding
12:19:39 <banister> oh
12:19:42 <banister> it's from Data.List
12:19:49 <applicative> they both are. foldl is garbage.
12:20:02 <applicative> foldl' is strict, requires a strict operation, and is okay
12:20:14 <applicative> to repeat some familiar memes
12:20:17 <banister> applicative: yeah i got them wrong
12:21:00 <applicative> foldl' is sort of the abstract form of a 'tail recursive' definition
12:21:55 <napping> Are any parser generators set up for generating and immediately using grammars at runtime?
12:23:25 <Philippa> napping: er, not sure quite what you mean
12:23:49 <Philippa> You could certainly eg write a  program that builds and uses a parsec parser based on input in an appropriate metalanguage
12:23:52 <napping> for example, Happy-generated files seem to split into some parse tables and fixed execution code
12:24:24 <napping> yeah, parsec would be an example.  guess I can't expect to re-use too much
12:24:32 <Philippa> *nod*. Yeah, that can be done for a variety of families of grammar
12:24:46 <napping> hs-plugins would be another option, but compile time seems a bit much
12:24:52 <Philippa> heh, yes
12:25:18 <napping> I'm thinking about replacing an existing thing using SDF which is a bit slowish, but something like 1s overhead
12:26:23 <Philippa> *nod*. I suspect the reason most aren't is that parser generators are really a thing of imperative, first-order tradition
12:26:26 <napping> on the other hand, the full CFG and ambiguity DAG output is necessary
12:26:33 <Philippa> *nod*
12:26:59 <napping> If I can figure out what's up with lists, the new BNFC CYK thing might be interesting
12:27:24 <Philippa> the ambiguity DAG'll rule out parsec then, but if CFGs are the right class you might well be able to whip up a quick applicative parser and see if that does the job fast enough?
12:27:45 <Philippa> (you'll want some flavour of tagging of alternatives, I guess)
12:28:02 <napping> I really need a parse dag rather than forest or things will explode
12:28:31 <napping> not sure that's incompatible with an applicative-style interface, but I don't think I've seen one
12:29:20 <Philippa> I guess you'd be looking at something packrat-flavoured at that point
12:30:24 <napping> the ones with side-to-side preference?
12:30:36 <carter> ambiguous parsers ca be applicatives....
12:30:44 <carter> just not monadic
12:30:52 <napping> yeah, but the ones I've seen produce collections of parses
12:30:55 <Philippa> napping: the ones that memoise which productions they've tried where
12:31:15 <carter> theres a bit of subtle engineering to do the DAG rep right
12:31:59 * hackagebot prednote 0.12.0.0 - Build and evaluate trees of predicates  http://hackage.haskell.org/package/prednote-0.12.0.0 (OmariNorman)
12:33:26 <Philippa> carter: yeah, I'm thinking you'd effectively reconstruct it from the memo table rather than the usual left-bias
12:33:53 <carter> sounds roughly right
12:34:31 <napping> something like that's probably workable (though epsilon-cycles might be messy)
12:34:45 <carter> napping: so you want a "specify the parser at runtime, do some transformations, run it"
12:34:46 <carter> ?
12:34:56 <napping> yeah, pretty much
12:35:02 <carter> i have some plans for that that won't land / happen till sometime next year realistically
12:35:04 <napping> well, parse a language with an extensible grammar
12:35:08 <carter> ok
12:35:12 <carter> why at runtime
12:35:21 <carter> why not "recompile with new grammar bits"
12:35:29 <carter> or the like
12:35:30 <carter> yeah
12:35:37 <carter> so you want a GLL or GLR parser basically
12:35:39 <carter> cool!
12:35:41 <napping> a program has a grammar description and definition written in that syntax
12:35:46 <carter> happy has a GLR mode
12:35:55 <carter> that may need some love, lispy  was playing with it recently
12:36:11 <napping> Yeah, that was one of the more promising things I'd seen
12:38:09 <carter> for the near term, if you want to actually *USE* such powers
12:38:13 <carter> playing with happy
12:38:20 <carter> and using its GLR
12:38:31 <napping> Just thought I'd check if there was anything actually designed to be used like that, before trying to hack one out of a parser generator myself
12:38:41 <carter> HAPPY
12:38:43 <carter> has that support
12:39:00 <carter> its a research problem to do it for a parser combinator lib, correctly
12:39:07 <carter> if you want to use such a tool now
12:39:15 <carter> figure out how to us ehappy for it
12:39:26 <carter> and/or patch it so it works even better if you find it lacking somehow
12:39:53 <carter> if i spent a few months last winter trying to understand how to do the GLL parser combinator approach right...
12:39:59 <carter> theres some subtle things
12:40:13 <carter> expecially if you want it to look like nice parser combinators syntax
12:40:13 <napping> well, BNFC also has a new GLR runtime that might be usable
12:40:18 <carter> bnfc?
12:40:19 <carter> whats that?
12:40:31 <napping> and perhaps makes it more natural to filter ambiguiuities during parsing
12:40:33 <Philippa> carter: I suspect it's only an undergrad project to do it for a combinator lib if you're happy to pull certain classes of trick like explicitly tagging productions
12:40:57 <Philippa> now, doing it /fast/? Yeah, fair enough
12:41:17 <carter> Philippa: exactly, i wanted to not require user level tagging
12:41:22 <Philippa> but combinator libs based on the Applicative interface really aren't that hard to work with
12:41:25 <carter> yeah
12:41:34 <Philippa> *nod* yeah, that's fair enough
12:41:59 * hackagebot penny-lib 0.18.0.0 - Extensible double-entry accounting system - library  http://hackage.haskell.org/package/penny-lib-0.18.0.0 (OmariNorman)
12:42:01 * hackagebot penny-bin 0.18.0.0 - Extensible double-entry accounting system - binary and documentation  http://hackage.haskell.org/package/penny-bin-0.18.0.0 (OmariNorman)
12:42:06 <carter> i want it to be a drop in replacment for any other applicative / alternative etc api parser combinator
12:42:11 <napping> carter: bnfc is a parser or frontend generator
12:42:21 <Philippa> I'm kinda reaching the stage where I prefer tagging to some extent, even if it's automatic tagging by a 'generator' recursive monad
12:42:36 <Philippa> but that's because having a finite grammar is a nice thing
12:42:40 <napping> but it was also the vehicle for some parsing work in ICFP13
12:43:17 <napping> basically saying that CYK is actually pretty nice if you use sparse matrices, and pull some fancy tricks to make lists not have dense parses
12:43:56 <shepheb> is there a Haste IRC channel? I've got a project (mostly) written in Haskell that wants porting to Javascript, and Haste looks like it should support my use-case.
12:45:03 <napping> and the core of the process is some linear algebra over arbitrary semirings, so it looks like your grammar just needs to supply a function for concatenating a pair of parses
12:45:30 <carter> cool
12:45:43 <carter> napping link to the relevant papers ?
12:45:49 <carter> Philippa you may be right about tagging
12:46:05 <carter> but, otoh, I really really would love to make it a drop in replacement
12:46:11 <Philippa> *nod*
12:46:15 <carter> but that migth be the only "practical way"
12:46:18 <napping> which would be a place to apply SDF style rules like "if a substring parsed as an A, don't consider parsing it as a B", and "don't consider parses of an expression with production Exp * Exp if either child parsed was made with production Exp -> Exp + Exp"
12:46:21 <carter> the user must name the things
12:46:45 <Philippa> carter: I still need to get back to that VPL/VDL-based parser one of these years
12:46:45 <merijn> shepheb: There is also ghcjs which can compile (almost) arbitrary haskell code to JS, although it's still very experimental
12:46:46 <carter> napping: link to paper please / authors pages?
12:46:55 <carter> vpl/vdl?
12:47:04 <Philippa> Visibly Pushdown/Delimited Language
12:47:08 <napping> Efficient Divide-and-Conquer Parsing of Practical Context-Free Languages Jean-Philippe Bernardy and Koen Claessen
12:47:26 <napping> www.cse.chalmers.se/~bernardy/PP.pdf‎
12:47:27 <carter> thanks
12:47:37 <napping> bnfc is also pretty cool in it's own right
12:47:38 <carter> i htink i looked at it beofre, but handy either way :)
12:47:42 <carter> thansk
12:47:58 <shepheb> merijn: I'm looking at that too, but it seems like Haste will be simpler to get running if it will serve my use-case. turns out I'm using TH, which Haste doesn't support, but only to auto-generate the Lenses for some records; they can be handwritten instead if Haste will work otherwise.
12:48:00 <carter> i may have looked at it eons ago, but sounds worth rereading
12:48:04 <napping> one of these days I should hack field labels into the grammar and make it spit out attribute grammars too, if somebody hasn't gotten around to it in the meantime
12:48:06 <Philippa> basically they're CFGs where you can only recurse when the recursion is bracketed (or delimited by something that effectively acts as two brackets back-to-back), and specific tokens are always open, close, delimit or non-brackets so you can lexically determine the stack behaviour of a PDA
12:48:14 <FreeFull> I think I should write my own merge sort
12:48:42 <Philippa> to rephrase: they're CFGs where you can treat each production as being locally a regex and get away with it :p
12:49:04 <napping> interesting. I don't entirely get what the CYK stuff is with lists but it seems to rely on delimiters too
12:49:11 <carter> cool
12:49:20 <Philippa> which sums up what's nice about them: you can do all the same analyses you can do on regexes
12:49:31 <carter> what analyses are those/
12:49:42 <carter> though being able to reason locally is always a win :)
12:49:42 <Philippa> (admittedly with pretty vicious worst-case complexities, but OTOH: you can do things like predict how much lookahead you need when automatically)
12:51:11 <Philippa> so no more try/cut by hand
12:52:31 <carter> ??
12:54:00 <banister> is 'fix' the same thing as the y combinator?
12:54:01 <Philippa> the y combinator is an implementation of fix
12:54:14 <banister> Philippa: so the y combinator is fix but works in a strict language?
12:54:25 <S_J> what is the efficient way to concat strings? since (++) is terrible? roll your own?
12:54:28 <Philippa> carter: I can eg calculate that the language is LL(n), and the value of n
12:54:38 <Philippa> same for other approaches
12:54:45 <carter> kk
12:54:54 <Philippa> banister: nah, there's a separate "strict Y". The canonical Y operator requires a non-strict language
12:54:58 <FreeFull> Well, that's weird
12:55:15 <Philippa> S_J: the associativity of your concatenations matters
12:55:16 <FreeFull> ghci is saying my sort' is :: Ord a => [t] -> [a]
12:55:24 <Philippa> alternatively, don't use Strings
12:55:48 <banister> Philippa: hmm, so is there anything the y combinator cna do that fix cannot? because 'fix' seems to be a much simpler implementation, no?
12:56:11 <Philippa> banister: You can write the Y combinator in the pure lambda calculus
12:56:16 <Philippa> which doesn't have recursion natively
12:56:47 <Philippa> (instead, you build it using a fixpoint operator such as Y)
13:41:28 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
13:41:28 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
13:41:28 --- names: list (clog Y_Less Azel devth dialelo Taneb Guest8107 chee1 solrize_ zrot quchen Velpoman dkasak_ BobFunk resnik perlite spion Okasu perspectival schell Wizcrack doomlord lambdakind drchip codesoup joefiorini voxpopuli twanvl_ Jesin iago pantech arenz marr apples` kingugo Tinned_Tuna kofno augur gvoron1 _justjust breck7_ paintcan seschwar_ Guest85622 message144 shintah ehaliewicz EvilPenguin mellum banister napping davidt_ applicative cronject dcoutts_ Desheng)
13:41:28 --- names: list (io2 Ankhers jadatkins Kiryx merijn conal pentace xplat_ conehead manung Franciman nan` prk wole ceii pkrnj mizu_no_oto niko Demos totos__ jchild brainwash VegBerg thealanwattsriot mgccl nominolo visof ts33kr matheus23 egblu3 gabor alanz thunderrd locallycompact hiroakip thalassarche d_arcy c_wraith dysinger bogdanp julmac harovali foxnorth Pullphinger Amadiro morazow nimish tensorpudding exitmouse gbeshers Sculptor jvrmaia bb010g eduardo_ raichoo swistak35)
13:41:28 --- names: list (mrsolo zamomin devinus luksow Der_Dackel ozgura path[l] mjs2600 insejn ptc donri2 nick8325 yfyf konundra S_J trism joelb NiceOneBrah hannese simon nabilhassein bananagram copumpkin eacameron flux0r joehillen tiffany kylcarte Mowah jfischoff mhooge Thra11_ supersym tharper utterglee benprew jmelesky datura_ Rarrikins finity dubsg Igloo alszar threesome wolfnn anon123 danharaj ajhager paddymahoney Reite sleepynate amathew Guest12648 Apocalisp TIHan)
13:41:28 --- names: list (BeardedCoder iol ioanel timemage vishesh dgpratt_ seq99`` aalvarez CaptainLex Jeanne-Kamikaze cfricke xymox kmrhb resttime tikhon Jonno_FTW OlegYch bbloom Caztiel Ov3rload jascase901 isomorphic startling uu1101 Luke hive-mind SyntaxNinja jzl kobain WraithM cads shreesh s00pcan JaRoel|4D Alice3 baisong Wizek xilo kadoban tomboy64 glosoli pmade b2coutts goldkatze jj515 lambdanaut saml MrFahrenheit akurei nexx favonia erochester talzeus nooodl JobV arborist)
13:41:28 --- names: list (k00mi clemensg otulp Noldorin Cerise donri lemao Pranz manud Puffton pkkm osa1 DrCode disperse53 rodrigovidal skchrko weie_ mannyv kennyd_ ismlages Zenol DexterLB whaletechno randomclown torkjak kludge` idoru Kuraitou sunfun Nik05 q66 cheezey SoupEvil kstuart phienone ccxCZ Tehnix listofoptions cdidd jaimef machisuji Mon_Ouie chuzz danvet linux_noob_666 MrWoohoo joneshf-work gthorslund felipe_ gg7 Kabaka dented42 edsko djcoin ggnmk gentleben meretrix Adios)
13:41:28 --- names: list (alang mceier neena xexonixxexillion DT` hamishmack troutwine otto_s_ cognominal Philonous_ shesek preflex bicgena charlesofarrell_ uranther mauke steshaw_ shanse wtw ski bsmt dav nkpart EpicOut Athas joogi Liskni_si tomaw rpenguin_ pjstadig hpc aristid guerrilla iulian flowsnake Neqoxec dpwright KitB tulcod ousado osfameron sgso xinming vili apaku purefn1 junsuijin ivan` chrisdotcode_ RichyB mlamari jlamothe blackdog adimit mgsloan1 predator117)
13:41:28 --- names: list (sirspazzolot jssanders alpounet bartavelle dju marienz FreeFull brianloveswords yam araujo NihilistDandy leifw [swift] Mortomes McManiaC zvrba fgomez shergill tavelram adnap vk_ blochchain dmwit epsylon parcs Excureo DarkFox algae scottschecter Tarential ecube dino- Guest55528 dwierenga dgvncsz0f hape01 cajla Work_jack palmje aoh mrshoe Ke FireFly saep Bio kakos tridactyla SegFaultAX pdxleif BigEndian brandonw Ycros n-dolio jrslepak frontendloader _br_)
13:41:28 --- names: list (yiannis_t Hafydd hiratara dsantiago Maxdamantus rfw chirpsalot obcode jeff_s1 milessabin tpsinnem-away wunki monochrom ninegrid burp amatsu `0660 tertl3 Jaxan bduc scottj ozataman levi doshitan vsayer LevelOneDev chenwl Nimatek gereedy Enigmagic aford dreixel twn ethercrow jdoliner dogmaT dexter1 tomejaguar jdhutah cmears centrinia bytbox adlan annulus- orospakr Twey gambogi Squid_Tamer munro Khady robinbb-freenode oldmanstan Adeon DustyDin1o jbauman)
13:41:28 --- names: list (Kaidelong IanKelling SLi leroux carter bobry demolithion satshaba1 satshabad brixen dyreshark mmathis maksbotan mac01021_ gilbertw1 scshunt lambdabot bscarlet Croms Iceland_jack lenstr Will| tahu mimi_vx PHO_ mikee Jello_Raptor vehk eyck ab9rf canissimia idnar stass Gracenotes threedaymonk Sunhay_ DigitalKiwi wollw acfoltzer stvc MoALTz cschneid jml ParahSail1n Lemmih qz mietek blakesmith ktosiek sShintah mstksg lightquake isenmann solancile floatingman)
13:41:28 --- names: list (canta mjo mortberg Raynos tylergillies_ JuanDaugherty sinclair|net c_14 stepcut nik_89 thorsten` sg raft tshirtman brisbin reactormonk helgikrs fxrh inr Cale valdyn dqd colah jyyou tortrot xnyhps wormphlegm dropdrive sclv anhall djahandarie osnr machisuji_ mike2 Tekerson sajith KaneTW arkeet tunixman heath kloeri Odd_Bloke FUZxxl mxf knyppeld1nan divarvel froztbyte Draconx _janne BMeph akraut etherfreak vvv_ mantovani drewr Erstarrung MouseTheLuckyDog jrib)
13:41:28 --- names: list (zero7 davean sevvie Entroacceptor zebr hdevalence|away flazz tnks Raynes mrpantoufle iteratee_ quicksilver bd__ chrisdone trafficoffee theorbtwo dsirenko_ Bigcheese Ralith go|dfish pikhq d3lxa si14 alej stelleg hellome nullcone_ Sabey upgrayeddd chexxor lopex bentrevor sordina1 tomh- dcoutts vnz pettter b0c1 lattenwald drdo qwandor hiyakashi tdammers tg Baughn_ ciaranm srcerer AntiSpamMeta Krakarn-- Morgawr michaf gnuvince zoktar etrepum spligak albel727)
13:41:28 --- names: list (descender hpd seneca nitrodex _flow_ cods ssbr eL_Bart0 shutdown_-h_now wilfredh puzza007 chickenflu warpy Xorlev ortmage ps-auxw bbee akahn xorox90_ lokydor chrisbuchholz talzeus_ shennyg kav vivekrai Ghoul_ Vertue IbnFirnas jodaro_ xrl gdeest ehd DrSyzygy stevejb` joeyh kini cdk stevejb troydm waterlaz Licenser hfaafb nwf jhh morolin banjiewen M-ou-se dthibodeau mykhal blz37 palaga doomlord_ NeatBasis_ ggherdov mak` Paks mikecaruso Eridius gseitz sepeth)
13:41:28 --- names: list (kloplop321 farn yano aleator milli brett Internet13 bcoppens Martty knz cmsd2 destiny tudalex vpm mathmonkey neurocyte ivan\ nonconvergent mmaruseacph2 Khisanth Myk267 fijimunkii rgrinberg thebnq s_quark zomg arbn petantik bogner electrogeek BrianHV newsham earthy vobi karatekid sclv_ Belgarion0 bezik tero- edwtjo mero de-Vri-es vvein levitation[A] koala_man JustAPerson apples nanothief_ maoe Arnoldz_ ByronJohnson Tene f8l Th0mas tomprince wto linduxed)
13:41:28 --- names: list (noplamodo thorkilnaur__ averell nxorg8 thirsteh mlinksva kxra redjohn plucas dan_johnsin SaBer melter neektza1 latro`a zerokarmaleft myme1 janinge dabradley ggreg otterdam ocharles epta ysuzuki aess saiam Natch elgot resure mechairoi Valodim awruef hackagebot Philippa tsou lunarjar WhereIsMySpoon Svedrin byorgey `bps liori mlh ahihi so asjo kshannon h_chiro_ goodmanio stiell alexander__b mel- warpaint int-e sm dakrone Tribal ezrios Bynbo7 sleepybug flux)
13:41:28 --- names: list (kaw ReinH joar bogner_ tych0 Deewiant tippenein Mayzie noam_ dustinswan zxq9 noddy plhk saiam^ Phlogistique jlaire jmcarthur nuttycom1 joshc ido ninzine phryk gemelen Hardolaf peltchu akiress_ MasseR Guest10475 gbluma_ Jimi` Laney mixi thetallguy2 Elision mapreduce schlumpi theDon zaphar_p1 kqr1 Gothmog_ kranius cow-orke1 k0ral pcapriotti deggis javawizard slobo_ SHODAN s4msung bstrie mux a11235 xplat ahf BlastHardcheese geoffh jlewis duairc JPohlmann)
13:41:28 --- names: list (integral Brando753 tvaalen Cryovat brendan gpampara_off rce brainproxy othiym23 davorak_ suiside udoprog drmegahertz agundry Plex- ent zenzike_ arnsholt dixie_ saurik luite Saizan lispy hvr ofan mviljamaa Maior thorsten1 jlouis fayden MetaCosm shiona wchun ernst mollerstrand statusfa1led Boreeas ehamberg mami_ tswett bholst_ Yawgmoth_ ChongLi companion_cube Boney bind Sourceless shepheb flori skypers smarter Arnoldz Zariel Kyzza supki guymann liyang)
13:41:29 --- names: list (joachifm vmeson briden joelteon ski_ hiredman jroesch Dtgr Ornedan schoppenhauer mornfall CosmicRay Soft kaol ttm pqmodn_ malorie_ dilinger_ Gilly arkx thoughtpolice ryanakca mr- Razz ziman thetallguy aninhumer pr xenophon zorzar `^_^v raid Edoxile sohum ClaudiusMaximus hpaste nikolah zw01 greymalkin fall_ Nickeeh yan_ Blkt aformeny bgamari dsp_ swook` Watcher7 ejls Yaniel killy9999 xaimus macron luminous jaspervdj confound_ Zesler mkrull Eliel ft anachron)
13:41:29 --- names: list (SirChurchill Ezku b_jonas johnw kosmikus almondjelly copton jix Riussi_ lahwran Fubar^ mononofu pyykkis natte notdan zeiris_ ParahSailin horlicks Draggor lpsmith mikeplus64 fry bigs kooga barrucadu haasn robbert majoh betawaffle gds Ptival inarru geal taylorgb ipuustin Walther ccasin jayne Reisen bitraten davorb-cellphone ibid Bwild Jaak lpvb CindyLinz aszlig zaiste def-lkb_ arcatan Spockz tromp_ cjay jamwt dmp1ce yeltzooo necroyeti willb1 Dashkal Chousuke)
13:41:29 --- names: list (jang1 nlogax mjrosenb Starfire_ mrd_ Ulrar petekaz`` cynick davd tessier fryguybob caligula__ b52 __main__ asante MK_FG gbarboza dlundy deavid elliott bergmark poucet XMunkki_ bqp fikusz ericmj pharaun Vq seantallen birkenfeld cruxeternus sp3ctum Clint mendez_ Dybber mgaare mokus magicman anders^^_ isomorphismes geekosaur wagle sipa pnielsen Kinnison n00dle tamiko dextrey OrangeDuck wavewave @ChanServ dumbhat LeaChim fabjan chrra mattp__ lulf Proteumus)
13:41:29 --- names: list (Counter-Strike relrod Rembane pfoetchen prophile sunnavy_ finnrobi pi8029 away_sondr3 TML ve genisage wereHamster gridaphobe klugez ion dario^CIP ljhms_ solirc Rutger`_ cross danr pyrtsa jliikka solarus taruti nicoo jkpl liszt profmakx petanqk opqdonut stomp SuperNoeMan bxc rs0 Kneiva_ TheSpectre Sagi \q sdx23 kryft)
13:45:37 <banister> im trying to understand this code from 'write scheme in 48 hours' " readExpr input = case parse (spaces >> symbol) "lisp" input of"
13:45:40 <banister> what does the "lisp" string do there?
13:45:45 <banister> it doesnt seem to be used/relevant anywhere
13:46:25 <pmade> banister: parsec will use it in error messages an the name of the input.
13:46:38 <banister> pmade: ah cool
13:46:42 <banister> thx
13:46:43 <Cale> It's meant to be the filename usually
13:47:08 <pmade> Yeah, I was about to say that it's useful for giving a filename.
13:54:25 <S_J> how do i do conditional compilation with a flag iun cabal?
13:57:39 <merijn> Is there a version of guard for Alternative?
13:58:12 <pmade> S_J: There are examples in the Cabal User Guide.
13:58:18 <hpc> :t guard
13:58:19 <lambdabot> MonadPlus m => Bool -> m ()
13:58:29 <hpc> @src Alternative
13:58:30 <lambdabot> class Applicative f => Alternative f where
13:58:30 <lambdabot>     empty :: f a
13:58:30 <lambdabot>     (<|>) :: f a -> f a -> f a
13:58:48 <hpc> merijn: if p then pure () else empty
13:59:00 <hpc> i don't think it's explicitly defined anywhere though
13:59:04 <merijn> hpc: Sure, I was just wondering whether that already existed
13:59:10 <merijn> Yet another argument for AMP!
13:59:19 <hpc> AMP?
13:59:29 <merijn> hpc: Applicative Monad Proposal
13:59:35 <hpc> ah yes
13:59:48 <merijn> Which obviously includes Alternative => MonadPlus too
14:00:12 <hpc> the MonadPlus laws are not yet decided
14:00:14 <merijn> Which would make it sensible to generalise guard to "guard :: Alternative f => Bool -> f ()"
14:05:11 <merijn> oh...hah
14:05:11 <eduardo_> applicative:I did it!!! Thanks… I've managed to install wxHaskell
14:05:11 <merijn> I actually have MonadPlus, so I might as well use guard
14:07:01 * hackagebot sloane 0.1.5 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-0.1.5 (AndersClaesson)
14:07:35 <merijn> I'm slightly annoyed that cereal and binary both don't have functions to read a specific value
14:08:29 <merijn> Like "specific :: Eq a => a -> Get a; specific v = get >>= \x -> if x == v then return x else empty"
14:18:54 <jophish_> Yo yo yo
14:19:11 <ljsc> Any vim users have haskell-mode working with cabal-dev?
14:20:01 <jophish_> On OSX, is it remotely possible to have haskell platform use clang and libc++ instead of gcc and libstdc++
14:20:20 <jophish_> This is becoming a little bit of a nightmare with regards to linking
14:20:38 <jophish_> I'm hoping to integrate the Haskell I'm writing into a c++ project which requires libc++
14:20:41 <jophish_> (and clang)
14:21:02 <Yaniel> is it possible to have something NOT use clang on OSX these days?
14:21:39 <hpc> anything's possible with the power of *friendship*
14:21:42 <jophish_> Yaniel: using -v3 with Setup build shows things using /usr/bin/gcc :(
14:22:03 <Yaniel> what OSX version?
14:22:09 <jophish_> Yaniel: 10.8
14:22:41 <Yaniel> oh and I have exported CC=clang in my .bashrc
14:23:07 <jophish_> I'd really like some global variable (hahaha) allowing me to pass -stdlib=libc++ to clang when it's run by ghc
14:23:13 <jophish_> Yaniel: I'll do that right away
14:23:50 <eduardo_> How do I redistribute a program that I built with "ghc --make" to other computers? I built a wxHaskell demo. If I try to run the app on other computer it references a library located on ~/.cabal/...
14:24:29 <jophish_> Yaniel: with CC=clang, this still seems to be using 'usr/bin/gcc'
14:24:42 <jophish_> For a little context, I'm compiling llvm-general
14:26:51 <dmwit> eduardo_: Hm, are you sure?
14:27:01 * hackagebot smartcheck 0.1 - A smarter QuickCheck.  http://hackage.haskell.org/package/smartcheck-0.1 (LeePike)
14:27:05 <dmwit> eduardo_: The default is static linking, so if it's referencing a library at all, I wouldn't expect it to be one in ~/.cabal.
14:27:28 <dmwit> (or in ~/.ghc, which is what you probably (?) meant)
14:28:17 <dmwit> If anything, it's referencing the wx libraries. And I think it's pretty reasonable to expect to need those on the machine you're running your binary on.
14:28:24 <merijn> jophish_: 10.8 doesn't have gcc
14:28:36 <merijn> jophish_: The gcc binary is a compatibility wrapper around clang
14:29:04 <jophish_> merijn: oh, that's a good start
14:29:07 <jophish_> swesome
14:29:25 <merijn> jophish_: "gcc --version" "i686-apple-darwin11-llvm-gcc-4.2"
14:29:25 <jophish_> It still remains to get a system completely free of libstdc++ though
14:29:58 <jophish_> :) "Apple LLVM version 5.0 (clang-500.1.61) (based on LLVM 3.3svn)" for me
14:30:15 <merijn> jophish_: Might need to look into the ghc configure scripts how to mess with the stdlib
14:30:29 <Jay> HELLO ALL .SORRYY FOR CAPS....I JUST WANT TO LEARN HASKELL WHERE WILL I START
14:31:00 <dmwit> ?where tutorials
14:31:00 <lambdabot> http://haskell.org/haskellwiki/Tutorials
14:31:26 <jophish_> merijn: ah, sounds super. Do you mean compile ghc from source, or a script used by ghc when configuring libraries?
14:31:37 <ion> If you know caps are bad, why use them in the first place?
14:31:46 <Jay> Hiope i dont forget other language
14:32:11 <Jay> Thank you lamdabot
14:33:04 <ion> You usually don’t forget old things by virtue of learning new things.
14:33:04 <eduardo_> dmwit: I get the following message: "dyld: Library not loaded: ~/.cabal/lib/wxc-0.90.1.0/ghc-7.6.3/libwxc.dylib"
14:33:32 <ljsc> Jay: I used http://www.cs.yale.edu/homes/hudak/SOE/ back in the day. Still one of my favorite technical books.
14:36:19 <dmwit> eduardo_: Very strange! Have you requested dynamic linking in your ~/.cabal/config or the cabal file you're using to build your executable?
14:36:56 <[swift]> eduardo_: IIRC wxHaskell builds a "local" version of some of its dependencies. I used it as an example when I needed to do something similar with llvm. Maybe check if they have exposed an option to disable this and use the system version?
14:37:40 <eduardo_> dmwit: I haven't touched ./cabal/config
14:38:41 <eduardo_> [swift]: I'll look for an option to force it to use the system version
14:39:01 <dmwit> The cabal file doesn't have any flags.
14:39:03 <dmwit> So that's not a good sign.
14:39:47 <ReinH> ljsc: oh hey there's a kindle edition, cool
14:40:00 <eduardo_> dmwit: I installed this package: https://github.com/wxHaskell/wxHaskell
14:40:32 <[swift]> the wxc package is the source of the problem
14:40:42 <ljsc> ReinH: Nice. Didn't know that. Might want to preview first though, there's a bunch of graphical examples IIRC.
14:41:04 <[swift]> it's a custom build type so perhaps they've added options in Setup.hs. there are none in the main cabal file, though.
14:41:18 <applicative> eduardo_: oh, wait, you built everything and it works, now you want to run it on another machine?
14:41:31 <eduardo_> applicative: yup!
14:41:56 <eduardo_> applicative: What's the point in building a gui application and not being able to redistribute it? LOL
14:42:02 <applicative> well, yes
14:42:06 <applicative> what os are you using
14:42:24 <eduardo_> applicative: Mountain Lion 10.8.4
14:42:28 <applicative> oh ok
14:42:38 <applicative> you will need something like cabal-macosx
14:42:48 <applicative> which will wrap up all the needed stuff in an app
14:42:54 <eduardo_> applicative: nice!
14:43:42 <ReinH> ljsc: the large format kindle books tend to do pretty well with diagrams and such
14:43:47 <eduardo_> applicative: so, now I have to uninstall wxHaskell packages and reinstall them using cabal-macosx?
14:43:53 <ReinH> compared to the first kindle editions
14:43:55 <applicative> at the moment there is some mistake, it may not look in the right place for stuff
14:44:05 <applicative> no, eduardo_ this is a matter of how you build.
14:44:06 <ljsc> Interesting. Good to know.
14:44:09 <applicative> let me find and example
14:44:12 <applicative> an example
14:44:58 <ReinH> ljsc: Amazon calls them "Optimized for larger screens", which means it'll still look pretty meh on a phone but the layout will be much better on a tablet, display, etc
14:45:22 <ReinH> So I don't know about this particular book but there's a good chance that it'll look good on big enough screens
14:46:32 <applicative> here's a simple demo https://github.com/michaelt/one-dollar-words eduardo_
14:46:56 <eduardo_> applicative: thanks! I'll have a look
14:47:00 <applicative> it uses reactive-banana, reactive-banana-wx so they will be needed, but that's irrelevant
14:47:27 <applicative> eduardo_: the point is, if you set things up that way, with a cabal file and so on, then
14:47:48 <applicative> cabal configure followed by cabal build will result in an osx .app in dist/build/something
14:48:01 <eduardo_> then I can use cabal-macosx to build a self-contained app ?
14:48:22 <applicative> yes
14:48:22 <eduardo_> applicative: ok !! let me try it and see what I can do
14:48:32 <applicative> you need to call it in the Setup.hs file https://github.com/michaelt/one-dollar-words/blob/master/Setup.hs
14:49:03 <eduardo_> applicative: I've just cloned the repo
14:49:46 <applicative> can you do something like 'which Rez' to see where some of these things are on your machine
14:50:07 <eduardo_> applicative: /usr/bin/Rez
14:50:26 <applicative> eduardo_: right, cabal-macosx may need a little patch
14:50:30 <applicative> just a sec
14:50:37 <eduardo_> cabal-macosx is installed here
14:52:10 <merijn> There's no way to selectively toggle the warning for shadowed bindings, right?
14:52:15 <applicative> eduardo_: I think it may look in the old places for Rez and some other os x utilities
14:53:06 <applicative> any see if it works, I think you have the newer setup with /usr/bin or symlinks there, cabal-macosx is looking in /Developer/blah which is out of vogue
14:54:07 <eduardo_> applicative: what if I make symlinks in the dirs where cabal-macosx expects them to be?
14:54:52 <geekosaur> eduardo_, you're likely to find that more difficult than you might wish
14:55:11 <napping> Can I set up a cabal package to run a shell script before the build?
14:55:53 <eduardo_> applicative: how can I try cabal-macosx to see what happens? do I run cabal install ?
14:55:56 <napping> running "system \"prepare.sh\"" in a pre-build hook gets the wrong working directory if I run cabal install outside the project directory
14:56:11 <geekosaur> /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer
14:56:24 <geekosaur> except when it's just /Applications/Xcode.app/Contents/Developer
14:56:49 <geekosaur> or something under /Applications/Xcode.app/Contents/Developer/Library
14:58:04 <napping> oh, guess I just needed that to be "./prepare.sh"
14:58:19 <dmj`> @def a = 0/0
14:58:20 <lambdabot>  Defined.
14:58:23 <dmj`> > a == a
14:58:24 <lambdabot>   Ambiguous occurrence `a'
14:58:24 <lambdabot>  It could refer to either `L.a', defined at L.hs:1...
14:59:02 <geekosaur> most single-letter bindings like that are used by simple-reflect, I think
14:59:03 <eduardo_> applicative: I have used macosx-app in the past to bundle executables into an app package
14:59:39 <dmj`> @def hmmm = 0/0
14:59:40 <lambdabot>  Defined.
14:59:46 <dmj`> > hmmm = hmmm
14:59:47 <lambdabot>   <hint>:1:6: parse error on input `='
14:59:54 <dmj`> > hmmm == hmmm
14:59:57 <lambdabot>   False
15:00:30 <dmj`> How do I check for the NaN case when dividing?
15:00:37 <applicative> eduardo_: oh good
15:01:05 <chrisdone> > 1/0 == 1/0
15:01:05 <applicative> eduardo_: I think this version may look in the right place if cabal-macosx as it is doesn't work https://github.com/michaelt/cabal-macosx
15:01:06 <lambdabot>   True
15:01:13 <chrisdone> i think 1/0 is infinity
15:01:14 <c_wraith> > isNan (0/0)
15:01:14 <chrisdone> uhhh
15:01:15 <lambdabot>   Not in scope: `isNan'
15:01:15 <lambdabot>  Perhaps you meant `isNaN' (imported from Prelude)
15:01:16 <Jay> 1=1
15:01:20 <c_wraith> > isNaN (0/0)
15:01:21 <lambdabot>   True
15:01:28 <geekosaur> NaNs can't be compared meaningfully
15:01:44 <Jay> 1/0 is undefined
15:01:45 <eduardo_> applicative: thanks! let me try it
15:01:46 <c_wraith> > isInfinity (1/0)
15:01:48 <lambdabot>   Not in scope: `isInfinity'
15:01:48 <lambdabot>  Perhaps you meant one of these:
15:01:48 <lambdabot>    `isInfinite'...
15:01:52 <c_wraith> > isInfinite (1/0)
15:01:53 <lambdabot>   True
15:01:53 <chrisdone> NaNs generally aren't meaningful
15:02:08 <chrisdone> it's like having a NotACharacter value for Char
15:02:12 <eduardo_> applicative: last commit was 2 minutes ago
15:02:13 <chrisdone> stupid
15:02:20 <eduardo_> applicative: usr/bin added
15:02:26 <applicative> right
15:02:31 <eduardo_> applicative: how convenient!
15:02:35 <chrisdone> we don't have null pointers, but NaN is close enough
15:02:36 <applicative> it is the revision I installed a while back
15:03:29 <enthropy> undefined is also close
15:04:02 <chrisdone> _|_ in general =(
15:04:45 <chrisdone> in ml only functions and statements contain bottom afaik, if you have a value, it's a value, not a pandora's box of surprises
15:05:13 <jophish_> Hmm, I have a teeny tiny program which uses llvm-general to JIT a function to return 42, and print that. The executable is 37MB
15:05:13 <chrisdone> oh well. gotta get ndm's `check' utility working again ;)
15:05:25 <eduardo_> applicative: I've just installed it
15:05:26 <hpc> chrisdone: that's just because it's strict :P
15:05:34 <chrisdone> hpc: ja
15:06:13 <quchen> jophish_: GHC links everything statically. That includes libraries and the runtime, and can get quite big quickly.
15:06:40 <quchen> You can also link dynamically though.
15:06:59 <quchen> That'll probably still be a few megs (runtime), but not as absurd as 37 megs.
15:07:07 <quchen> (Stripping also helps a little.)
15:08:05 <Jay> >0/0
15:08:09 <jophish_> yeah, strip saved me 10MB
15:08:23 <jophish_> Hello world is 1MB after strip
15:08:33 <Jay> > hmmm == hmmm
15:08:36 <lambdabot>   False
15:09:00 <Jay> > 0/0 = ''
15:09:01 <lambdabot>   <hint>:1:5: parse error on input `='
15:09:09 <Jay> > 0/0 == ''
15:09:10 <lambdabot>   <hint>:1:10:
15:09:11 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
15:09:33 <hpc> Jay: what do you think '' is?
15:09:45 <Jay> I was just playing :D
15:09:50 <hpc> :P
15:10:21 <Jay> I have lot of doubts in math ... Haskell I like it ...
15:10:26 <eduardo_> applicative: runghc Setup configure / Configuring wxHello-0.1.0... / Setup: At least the following dependencies are missing: / cabal-macosx -any, wx -any
15:11:46 <dmj`> chrisdone: ah k think i see, isNaN was key. Trying to do a RWH exercise.
15:11:52 <hpaste> dmj pasted “find line direction” at http://lpaste.net/91642
15:12:32 <eduardo_> applicative: do you know what that means?
15:12:54 <eduardo_> applicative: do I have to run `cabal build` before running `runghc Setup configure`?
15:13:12 <geekosaur> likely it meeans you need runghc Setup configure --user
15:13:29 <geekosaur> or `cabal configure` (no package name)
15:14:41 <banister> why do i sometimes have to use --make when compiling?
15:15:02 <hpaste> dmj revised “find line direction”: “find-line direction” at http://lpaste.net/91642
15:15:26 <geekosaur> banister, because you're running an old ghc which doesn't follow package dependencies by default?
15:15:47 <banister> geekosaur: ah ok thx
15:16:14 <quchen> geekosaur: Wait, new GHC versions don't require --make at all?!
15:16:18 <merijn> quchen: No
15:16:23 <merijn> quchen: Haven't for ages
15:16:29 <geekosaur> (old ghc's behavior is rather befuddling; it will find modules in packages for the compile step, but not remember them for the link step, so any dependencies needed by those modules will cause link time errors)
15:16:30 <dmj`> banister: http://www.haskell.org/ghc/docs/latest/users_guide.pdf,  page 44
15:16:35 <quchen> Haha, wow. I've always been passing it when compiling multiple modules automatically.
15:16:46 <geekosaur> quchen, my understanding is --make is always on in newer ghc
15:16:54 <merijn> quchen: Although you should just be using cabal anyway ;)
15:16:57 <quchen> So it's a NOOP flag?
15:17:03 <Clint> now it is
15:17:08 <geekosaur> (possibly unless you use -package foo)
15:17:10 <luite> geekosaur: yeah unless you specify -c
15:17:13 <quchen> merijn: Cabal is a little much for small test scripts.
15:17:20 <luite> or other things that force single shot mode
15:18:17 <quchen> merijn: Also makefiles annoy me far less than Cabal when I'm trying to hack around in something (e.g. just put a -O flag on a specific file, recompile everything for profiling etc)
15:18:31 <eduardo_> geekosaur: thanks!
15:20:10 <luite> quchen: OPTIONS_GHC pragma for the first, --enable-executable-profiling, --enable-library-profiling the latter
15:20:28 <hpc> quchen: i think you can cabal install -O, too
15:20:48 <luite> hpc: not for a single file
15:21:23 <luite> (or if you can, pls tell me how :) )
15:21:29 <quchen> luite: I said "me" in that sentence. :-P
15:21:52 <eduardo_> applicative: I've built the app bundle using cabal-macosx: the same thing happend. Someone has had the exactly same problem as me on stackoverflow: http://stackoverflow.com/questions/10615968/static-linking-wxhaskell-on-mac-os-x
15:22:32 <quchen> But even then I couldn't do a "recompile, run, cat result | less" with Cabal, could I?
15:23:04 <luite> quchen: yeah but no why... perhaps your cabal-fu just needs some adjustments ;)
15:23:31 <luite> hmm, i tend to use the shell && for that :)
15:24:43 <quchen> luite: Me too. And then I put that into a makefile :-P
15:25:44 <banister> can someone explain how/why this function doesn't take any parameters but still (supposedly) is useful? https://gist.github.com/banister/9967a1cc62427dc4740d
15:25:55 <S_J> how can I define an arbitrary that generates a [(String, String, String)] where one string is only from a set of 4 dofferent strings? also empty strings are not allowed
15:25:56 <banister> (parsec function)
15:26:15 <geekosaur> banister: Parsec maintains a parse state
15:26:26 <napping> banister: it's a parser, doesn't need to be a function
15:26:34 <geekosaur> this is represented in the type as "Parser someresulttype"
15:27:02 <napping> you run it with something like "parse :: Parser a -> String -> Maybe a" (but more complicated for error messages and location info and stuff)
15:27:50 <napping> whether or not the Parser type is implemented as / contains functions, it would work just as well if it was pure data
15:28:24 <luite> S_J: use the Arbitrary instance for list? x <- arbitrary ["a", "b", "c", "d"]; return (x,y,z)
15:28:39 <quchen> banister: The easiest version of a parser type is `Parser a = String -> [(a, String)]`. It's a little similar to a State monad that eats its state piecewise and aggregates a result along the way.
15:28:46 <luite> S_J: oh bah that's the wrong way
15:28:48 <luite> sorry
15:29:07 <alexander__b> is there any way to do games in haskell without having to just use bindings that force you to basically do half your stuff in an imperativy style?
15:29:26 <quchen> "Parser LispVal" therefore stands for a function that consumes a String and produces LispVals (and remaining strings it hasn't looked at yet).
15:29:35 <banister> quchen: ah so the monad type is itself inherently a function
15:29:41 <hpc> alexander__b: there's nothing wrong with imperative style in haskell
15:29:43 <alexander__b> I'm talking "real games". the ones that require a physics engine (typically written in C) and OpenGL (... "typically written in C")
15:29:43 <banister> (pardon me if that doesnt make sense)
15:29:51 <hpc> alexander__b: but yes, there are abstractions that can be useful
15:29:59 <hpc> i don't know that they are ready for AAA games, though
15:30:04 <quchen> banister: Something along those lines, yes. The Monad instance is a newtype of a function-thing. :-)
15:30:32 <alexander__b> hpc: we have our own physics engine for a game... we would really like to use someone else's, lol.
15:30:35 <quchen> banister: RWH has a chapter that describes how to build a parser that explains it in detail.
15:30:42 <merijn> ooh, fun times
15:30:43 <napping> banister: why that definition is useful is unrelated to whether or not Parser is implemented as a function
15:30:46 <merijn> I got GHC to crash again
15:30:51 <ion> ghci -package-name base
15:30:52 <quchen> banister: You don't have to know it in order to use Parsec though, it's just interesting background knowledge.
15:30:57 <alexander__b> hpc: so something like Box2D and OpenGL in Haskell, but as functional as possible would be desirable.
15:31:04 <napping> banister: you might say it's defining a useful constant
15:31:22 <banister> napping: im a noob, i need something to hold on to at this point ;)
15:31:25 <napping> the constant being a description of a grammar for parsing some kind of value
15:31:29 <liyang> alexander__b: I don't think the tools and infrastructure are quite as comparable for AAAA games. Yet. We're getting there.
15:31:40 <mstksg> alexander__b: you don't have to
15:31:40 <napping> just like you might have a toplevel definition of
15:31:47 <hpc> alexander__b: join #haskell-game and ask there
15:31:49 <napping> defaultHostname = "foo.example.com"
15:31:55 <alexander__b> liyang: I sincerely doubt anyone would call any of the games I've worked on triple A, let alone quadruple A, whatever that is.
15:31:57 <alexander__b> hpc: cool, thanks
15:32:09 <S_J> how do i write my own arbitrary? i never get how to implement typeclasses
15:32:37 <liyang> alexander__b: I'm just taking the piss referring to AAAAA games.
15:32:56 <Philippa> liyang: hah. AAA infrastructure is ludicrous these days, in an "everyone builds scary amounts of their own" way
15:33:07 <S_J> and now cabal says the tests pass even if they fail, how can quickcheck report failure to cabal?
15:33:09 <quchen> S_J: Have you looked at the implementations that already ship with QuickCheck? http://hackage.haskell.org/packages/archive/QuickCheck/latest/doc/html/src/Test-QuickCheck-Arbitrary.html#arbitrary
15:33:16 <Philippa> I guess having the PS4 and xbone on x86 will be mildly helpful, at least
15:33:25 <quchen> S_J: There are pretty easy ones for Bool, Ordering and so on
15:33:28 <hpc> > text $ "liyang: i prefer "++repeat 'A'++" games"
15:33:35 <hpc> > "liyang: i prefer "++repeat 'A'++" games"
15:33:36 <lambdabot>   mueval-core: Time limit exceeded
15:33:39 <lambdabot>   "liyang: i prefer AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
15:33:43 <quchen> S_J: Don't worry about shrink too much, focus on `arbitrary`
15:33:46 <hpc> right, text doesn't do infinite very well
15:33:47 <liyang> Aaaaaaaaaargh.
15:34:16 <liyang> alexander__b: as to how to do things in a functional style, look into FRP if you haven't already. Not sure that's *the* way to do things, but it's certainly *a* way.
15:34:22 <joelteon> > "they're eating her! and now they're going to eat me! oh my g" ++ repeat 'o'
15:34:23 <lambdabot>   "they're eating her! and now they're going to eat me! oh my goooooooooooooo...
15:34:37 <mstksg> that's a lot of goo
15:34:51 <hpc> goo goo gajoob
15:36:11 <mstksg> alexander__b: you're also going to have to accept that some things are inherently stateful ... the trick is separating what is from what isn't.
15:36:40 <alexander__b> mstksg: I know this, of course. I'd just like to have as much functional stuff as possible, and not just... imperative haskell.
15:36:42 <mstksg> stateful isn't a bad thing ... treating non-stateful things as stateful is what is abusable
15:37:05 <hpc> that is the way to making everything stateful
15:38:05 <sm> better imperative haskell than imperative other-thing!
15:38:42 <hpc> i have probably said this before, but haskell is my favorite imperative language and perl is my favorite functional language
15:39:17 <blackdog> hpc: curious as to why the second half :)
15:39:26 <sm> likewise
15:39:44 <flux0r> yep
15:39:50 <hpc> prototypes, list flattening, and hashes
15:39:51 <ion> ditto
15:39:51 <monochrom> perl is a write-only language to me
15:40:09 <flux0r> good god i hate reading perl
15:40:10 <hpc> prototypes let you write functions that are vaguely like forM and company
15:40:16 <johnw> must motivate you to do it right the first time :)
15:40:27 <hpc> list flattening is an interesting alternative to comprehensions
15:40:37 <hpc> hashes are just generally nice catch-all containers
15:40:59 <mstksg> sounds like you just like the parts of perl that are in ruby
15:41:05 <hpc> haha
15:41:17 <liyang> hpc: they see you trollin', they hatin'... lurkin' they tryin' to catch you codin' dirty.
15:41:18 <flux0r> that's how i use javascript objects
15:41:19 <johnw> flux0r: i must say, I hate reading Tcl even more
15:41:21 <monochrom> I am also not impressed by the business with $v, @v, $v[4]
15:41:25 <Hafydd> How is list flattening an alternative to list comprehensions?
15:41:34 <flux0r> haven't done that one
15:41:36 <blackdog> hpc: i always kind of hated list flattening in perl
15:41:41 <johnw> list incomprehensions
15:41:42 <blackdog> ended up with references all over the place
15:41:50 <Hafydd> Hahah.
15:42:11 <blackdog> hpc: i do agree on hashes, though. it'd be great to have nicer syntax for that in haskell.
15:42:25 <hpc> blackdog: one of the tricks i have used before on command-line utilities is
15:42:32 <hpc> %options = get command-line options
15:42:38 <hpc> %defaults = get defaults from db
15:42:48 <hpc> %options = (%defaults, %options)
15:43:15 <monochrom> well, the business with perl's $v, @v, $v[4] is similar to the business with lisp's "v has a value binding and a function binding". I am not impressed by either.
15:43:18 <Guest12648> blackdog: catching on that: a hash in haskell is a list of 2-tuple, right? (I'm a beginner in haskell)
15:43:25 <hpc> monochrom: yeah, that part is a wart
15:43:35 <blackdog> Guest12648: well, you can use lookup to treat it that way
15:43:36 <hpc> Guest12648: it's weirder than that
15:43:42 <joelteon> Guest12648: there are lots of hash implementations in haskell
15:43:42 <hpc> Guest12648: it's more like
15:43:46 <blackdog> but it's an O(n) operation, so it's not really an acceptable substitute.
15:43:51 <hpc> > ["key", "value", "key", "value"]
15:43:52 <lambdabot>   ["key","value","key","value"]
15:43:53 <blackdog> you'd use Data.Map usually.
15:44:04 <hpc> Guest12648: except unordered wrt key-value pairs
15:44:16 <blackdog> but then instead of "foo = {}" you get "let foo = Map.empty" etc - bit clumsier.
15:44:26 <hpc> Guest12648: oh, in haskell - ignore what i said
15:44:29 <Guest12648> hum
15:44:30 <ion> hpc: ITYM %options' = (%defaults, %options)
15:44:33 * ion ducks
15:44:37 <hpc> ion: lol
15:44:41 <prophile> is there a Monad instance for Data.Map?
15:44:46 <Guest12648> hpc: you were speaking about which lang?
15:45:06 <elliott> prophile: no, you can't do return
15:45:08 <S_J> i dont see one for String or [Char], onyl for Char. I want (String,String,String) and the middle string is ither "Int","File","Double" or "String´"
15:45:16 <hpc> the way it was actually used is some kind of "blahblah($dbh, %defaults, %options)"
15:45:17 <prophile> elliott: well, I thought maybe with (Monoid key) => or something
15:45:21 <hpc> Guest12648: perl
15:45:28 <elliott> then I suspect law violation
15:45:31 <elliott> prophile: it's an Applicative apart from pure, though
15:45:37 <elliott> don't know about (>>=)
15:45:46 <Guest12648> hpc: oh right; never tried it and not planning to
15:46:00 <hpc> Guest12648: it takes a state of mind to appreciate ;)
15:46:06 <ion> Many things are also Applicative apart from pure and (<*>).
15:46:24 <prophile> interesting
15:46:25 <prophile> thanks elliott
15:47:00 <blackdog> hpc: yeah, i use that trick in ruby, but foo.merge(bar)...
15:47:06 <Guest12648> hpc: the only positive thing I ever heard about perl is cpan
15:47:07 <blackdog> bit more explicit
15:47:17 <ion> In Haskell: foo <> bar
15:47:37 <blackdog> ion: i don't think hash merging is a monoid, is it?
15:47:42 <blackdog> it's not commutative
15:47:54 <johnw> Guest12648: wasn't CPAN the first such globally available repository of free source of its kind, when it came out?
15:48:01 <luite> blackdog: you mean associative?
15:48:06 <hpc> blackdog: monoids aren't commutative, they are associative
15:48:11 <hpc> hash merging is definitely associative
15:48:14 <blackdog> luite: gah, you're right
15:48:27 <hpc> if you take the "ignore one, use the other" method of collision resolution
15:48:40 <hpc> not sure about how other methods would work
15:48:47 <blackdog> clearly i am insufficiently caffeinated :) been talking about abelian groups lately
15:49:00 <Guest12648> johnw: no clue but it must have been as it was launched in 1993 O_o
15:50:12 <cschneid> is there a function to get all subsequences, except only ones that are in order?  [1,2,3] => [1],[2],[3],[1,2],[2,3],[1,2,3]?
15:50:25 <quchen> hpc: Hash merging? You mean like `hash a (hash b c)`? That's associative?
15:50:29 <luite> cschneid: is [1] not in order?
15:50:35 <blackdog> quchen: hash as in dictionary
15:50:41 <quchen> blackdog: Aaaaah.
15:50:45 <luite> cschneid: on sorry
15:50:52 <luite> cschneid: for some reason i read 'not'
15:50:58 <cschneid> luite: yeah, it is. Basically a restricted form of Data.List subsequences.
15:50:59 <blackdog> quchen: this is why overloading without strict type constraints is evil :)
15:51:16 <quchen> blackdog: ?
15:51:20 <luite> cschneid: subsequences, Data.List
15:51:33 <cschneid> luite: but that would give me [1,3] in my small example - which isn't in order.
15:51:47 <S_J> so an Instance of Arbitrary has to be a new type of Data? it cant be a String but with only somepossible values? can someone help me i dont get how to do thi
15:51:48 <S_J> s
15:51:49 <luite> cschneid: oh you mean consecutive
15:51:51 <monochrom> the right word is "consecutive"
15:51:59 <cschneid> luite: yeah, sorry - didn't have a good word for that.
15:52:23 <blackdog> quchen: i mean overloading "hash" in english to mean a hash function as well as a key-value store
15:52:29 <blackdog> quchen: weak attempt at a joke.
15:52:32 <quchen> Oh, I see.
15:52:34 <quchen> Hah. :-P
15:52:36 <ion> > let inOrder xs = and $ zipWith (<) xs (drop 1 xs) in filter inOrder . subsequences $ [1,2,3,1]
15:52:38 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[1]]
15:52:49 <luite> > (inits >=> tails) "abc"
15:52:50 <lambdabot>   ["","a","","ab","b","","abc","bc","c",""]
15:54:31 <quchen> Subsequences sounds a lot like the power set.
15:54:33 <quchen> > filterM (const [True, False]) [1,2,3]
15:54:34 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
15:54:51 <FreeFull> quchen: Doesn't fullfill the constraints
15:55:04 <quchen> I should work on my reading comprehension.
15:55:23 <FreeFull> > filter (not . null) . (inits >=> tails) $ "abc"
15:55:24 <lambdabot>   ["a","ab","b","abc","bc","c"]
15:56:47 <cschneid> :t >=>
15:56:49 <lambdabot> parse error on input `>=>'
15:57:05 <quchen> :t (>=>)
15:57:05 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:57:16 <quchen> a >=> b = \x -> a x >>= b
15:57:26 <cschneid> so that works inside the list monad in this case?
15:57:27 <c_wraith> the fish is swimming the same direction as the argument. >_>
15:57:28 <quchen> It's like function composition, but for monadic functions.
15:58:18 <S_J> how do I call arbitray for a specific type? just for testing it?
15:58:35 <luite> S_J: give it a type annotation
15:58:48 <johnw> and use the function that gives you sample
15:59:22 <johnw> sample' (arbitrary :: Int)
15:59:50 <johnw> sample' (arbitrary :: Gen Int)
15:59:57 <quchen> (Is there a way of telling sample' how many results to generate?)
16:00:03 <johnw> I got: [0,1,-2,3,-18,64,-35,99,197,-837,797]
16:00:06 <johnw> so, use take?
16:00:47 <liyang> (>=>) and (<=<) are more like composition for monadic functions.
16:02:08 <cschneid> am I right that the inits >=> tails part is inside the list monad? So that's where the multiplying of outputs happens?
16:02:16 <luite> cschneid: yes
16:02:32 <cschneid> and if I wanted to add "only answers with length 2" I could throw on a guard clause?
16:03:31 <FreeFull> If you wanted only answers with length 2, you could use a different implementation
16:03:32 <quchen> cschneid: (inits >=> tails) xs   =   inits xs >>= tails   -- This first generates the list of inits, and then splits out each one of them using tails. You're left with a list of all consecutive sub-lists.
16:03:34 <monochrom> yes. but there is a much cheaper algorithm
16:03:36 <luite> it'd be better to not generate them in the first place
16:03:57 <quchen> monochrom: zip`ap`tail? :-D
16:03:59 <cschneid> sure. I'm mostly trying to understand the syntax.
16:04:02 <monochrom> yes
16:04:16 <S_J> *Main> sample' (arbitrary :: Int)
16:04:16 <S_J> <interactive>:70:10:
16:04:16 <S_J>     Couldn't match expected type `Int' with actual type `Gen a0'
16:04:23 <FreeFull> > (zip`ap`tail) [1,2,5,3,6,7]
16:04:24 <lambdabot>   [(1,2),(2,5),(5,3),(3,6),(6,7)]
16:04:25 <quchen> S_J: Gen Int
16:04:27 <quchen> Not just Int
16:04:32 <FreeFull> quchen: Not quite
16:04:35 <cschneid> how would I use guard in this situation, without having a named bound var to check against?
16:04:39 <FreeFull> Since this gives you tuples
16:04:40 <S_J> oh nm
16:04:45 <applicative> eduardo_: sorry, I vanished; did you make a Setup.hs that uses cabal-macosx. It should probably include 'ChaseWithDefaults' ; you build by doing 'cabal configure; cabal build; open dist/build/blah.app'
16:04:49 <quchen> FreeFull: Well, the same principle
16:04:57 <quchen> FreeFull: Plus the singletons
16:05:17 <FreeFull> Singletons aren't of length 2
16:05:26 <applicative> eduardo_: I mean following the example of e.g. the wxHello in cabal-macosx/examples/wxHello
16:05:34 <FreeFull> Hmmm
16:05:46 <FreeFull> > (zip3`ap`tail`ap`tail) [1,2,3,4,7,4,8,2]
16:05:48 <lambdabot>   [(1,2,2),(2,3,3),(3,4,4),(4,7,7),(7,4,4),(4,8,8),(8,2,2)]
16:05:48 <quchen> Oh, he said "only". Did I mentions I need to work on my reading comprehension? I'll do that in bed. Good night everyone.
16:06:03 <FreeFull> > (zip3`ap`tail`ap`tail.tail) [1,2,3,4,7,4,8,2]
16:06:04 <lambdabot>   Precedence parsing error
16:06:04 <lambdabot>      cannot mix `Control.Monad.ap' [infixl 9] and ...
16:06:10 <applicative> do we have reading comprehensions yet in haskell?
16:06:11 <FreeFull> Aww
16:08:12 <eduardo_> applicative: I tried to build the example that came with cabal-macosx
16:08:41 <FreeFull> applicative: I don't think Reader is in MonadPlus
16:08:57 <eduardo_> applicative: I tried the example. I didn't try adapting to my program
16:09:18 <FreeFull> Could have Maybe comprehensions though
16:09:21 <enthropy> @ty inits >=> tails >=> ap (<$) (guard . (==2) . length)
16:09:22 <lambdabot> [a] -> [[a]]
16:09:30 <eduardo_> The example did work on the first machine, but it did not work on the second, which does note have cabal
16:09:52 <enthropy> cschneid: ^^ you're better off naming the variable I think
16:10:09 <cschneid> enthropy: really, I'm better off with a smarter algorithm :)  But thank you for that
16:10:10 <hpaste> js pasted “arbitrary” at http://lpaste.net/91651
16:10:17 <S_J> dont get it ^^
16:11:04 <enthropy> S_J: you could have    arbitrary  = liftM3 Triplet arbitrary arbitrary arbitrary
16:12:41 <S_J> how do i do the special String whoich should only be one of those four?
16:13:09 <c_wraith> at the type level?  you don't.
16:13:09 <enthropy> @hoogle oneOf
16:13:10 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
16:13:10 <lambdabot> Text.ParserCombinators.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
16:13:10 <lambdabot> Test.QuickCheck.Gen oneof :: [Gen a] -> Gen a
16:13:21 <c_wraith> oh, as a parser.  Yeah, those work
16:14:04 <enthropy> @hoogle :: [a] -> Gen a
16:14:04 <lambdabot> Test.QuickCheck.Gen elements :: [a] -> Gen a
16:14:04 <lambdabot> Test.QuickCheck elements :: [a] -> Gen a
16:14:04 <lambdabot> Test.QuickCheck.Gen growingElements :: [a] -> Gen a
16:15:48 <S_J> i dont get it, obv i will never get one of those four if i gen random data and those are the ones i want to check for
16:16:55 <merijn> Control.Monad.Writer.pass sucks to implement :(
16:17:13 <c_wraith> S_J: instance Gen Foo where arbitrary = Foo <$> oneOf ["foo", "bar"]
16:17:40 <c_wraith> S_J: it doesn't generate random elements then check to see if they're on the list.
16:17:49 <c_wraith> S_J: it picks something from the list at random
16:25:34 <edwardk> merijn: its frustrating because so many otherwise decent writer instances could exist but for that method
16:28:47 <hpc> i think you can implement MonadState with listen and pass
16:29:13 <hpc> unless the docs are horribly misleading
16:29:50 <dmwit> :t pass
16:29:51 <lambdabot> MonadWriter w m => m (a, w -> w) -> m a
16:31:11 <c_wraith> does anything even *use* pass?
16:31:35 <hpc> why does it even exist?
16:33:01 <johnw> it allows you to functionally mutate the monoid element, right?  So, pass () (const mempty) would reset the writer log
16:33:15 <johnw> sorry, pass ((), cons mempty)
16:33:17 <johnw> t
16:33:39 <banister> johnw: do you understand the state monad or do you feel the intuition is always just beyond your grasp
16:33:40 <johnw> odd that it wants a tuple
16:33:50 <johnw> banister: I understand it very well
16:34:08 <johnw> I've not only rewritten myself, but I've written using only adjunctions
16:34:17 <johnw> that will give you the most foundational understanding
16:34:20 <banister> johnw: what's an adjunction?
16:34:30 <S_J> c_wraith: could ficx the whole arbitrary for me? (String, String, String) where middle String is oneOf
16:34:47 <S_J> because i jus tdont get how. ty
16:35:46 <johnw> banister: it's rather hard to answer that
16:36:53 <johnw> and I'm not sure it would be clarifying at this point
16:37:15 <johnw> here is the code, if it helps at all: https://github.com/jwiegley/posts/blob/master/Adjunctions%20in%20Haskell/Adjunction.hs
16:37:18 <apples`> is there a good place to learn about adjunctions as they relate to haskell?
16:37:32 <johnw> apples`: Ralph Hinze has a great paper on them
16:37:36 <johnw> they are *everywhere* in Haskell
16:37:49 <haasn> every monad arises from an adjunction
16:37:50 <johnw> currying and uncurrying are an adjunction
16:37:51 <merijn> edwardk: I have something that *is* a writer, it's just that I'm having a hard time implementing the lifting
16:38:06 <apples`> johnw: cool, i'll check out his stuff
16:38:08 <edwardk> what is the shape of the monad?
16:38:15 <johnw> wrapping a type with Maybe forms an adjunction
16:38:30 <edwardk> you can generally compose and inline away the definitions of the various liftPass-like combinators to work out what it should be
16:38:33 <merijn> edwardk: Well, I think I have it implemented, although, tbh I just fiddled with it until it typechecked
16:38:55 <johnw> apples`: http://www.cs.ox.ac.uk/ralf.hinze/LN.pdf
16:39:02 <apples`> thanks!
16:39:29 <johnw> that paper gets heavy really fast, but read it a few times and have Awodey handy, and it will get better with each read :)
16:39:30 <c_wraith> S_J: Gen is a monad.  just use do notation.  arbitrary = do s1 <- something ; s2 <- oneOf ["foo", "bar"] ; s3 <- whatever ; return $ constructor s1 s2 s3
16:39:39 <apples`> will do
16:39:58 <hpaste> merijn pasted “Pipes MonadWriter” at http://lpaste.net/91652
16:40:08 <merijn> edwardk: Essentially that is what I have now
16:40:44 <edwardk> thats a lot of parameters
16:40:45 <danharaj> edwardk: what is the utility of the collage of a profunctor?
16:41:02 <merijn> edwardk: I didn't come up with Proxy :)
16:41:11 <edwardk> i know =)
16:41:15 <danharaj> that's a lot of parameters without a cute phrase like i m a s t a b u
16:41:17 <johnw> banister: do you have a particular question about the State monad?
16:41:19 <monochrom> Hrm! if Hinze recommends learning adjunction, I should learn it!
16:41:35 * monochrom is a fan of Hinze :)
16:41:42 <edwardk> danharaj: dunno. it exists, it could be implemented, so i did.
16:41:56 <johnw> banister: I'd be happy to help clarify them for you if I can
16:41:57 <edwardk> helped me learn more about profunctors, and profunctors form the basis of everything in lens these days
16:42:02 <applicative> eduardo_: sorry, this is a bit laborious; i can move wxHello from one machine to another if I put ChaseWithDefaults instead of DoNotChase in the Setup.hs  For some reason I have to build with more-than-usual-privileges and of course the app is bigger
16:42:26 <banister> johnw: it just seems pretty important to grok it, as apparently it's the mental model you should have in mind for fully understanding IO and Parsec
16:42:36 <danharaj> edwardk: I noticed. I'd love to learn about the theoretical underpinning of lens nowadays.
16:42:42 <merijn> edwardk: The main issue I have is, that I have to lift the eventual function through a whole bunch of monadic actions, most of which will ignore it
16:42:57 <monochrom> State will still not help fully understand IO
16:43:09 <danharaj> edwardk: also I noticed that there's a canonical idea of an algebra for a profunctor that seems to subsume every recursive type and its fold. :3
16:43:12 <eduardo_> applicative: That's fine for me… I don't mind the app being bigger, nor having to build with more priviledges!
16:43:20 <edwardk> merijn: anyways, that is basically 'Free' over the Request and Response types, with embedded effects in m, so the code for that pass should match up with the FreeT instance of MonadWriter
16:43:40 <monochrom> Fiction -> (a, Fiction) does not explain forkIO
16:43:50 <johnw> @unmtl State s a
16:43:50 <lambdabot> s -> (a, s)
16:44:04 <johnw> so you can decompose State into a function: State -> (a, State)
16:44:15 <johnw> that is, I give you a state, you give me back a value and a new state
16:44:21 <johnw> then I can take this new state and give it back to you
16:44:24 <johnw> and get a new value and a new new state
16:44:30 <edwardk> danharaj: i tripped over the concept before but never got back to it
16:44:30 <johnw> rinse, wash, repeat
16:44:34 <johnw> that's really all that State is
16:44:50 <johnw> the State monad abstracts these details behind the Monad interface, and do-notation makes it convenient to use
16:44:53 <ion> Thanks for “-- Adjunction.hs ends here”, without it i would have ended up blocking forever.
16:44:53 <johnw> but there is nothing magical
16:45:03 <johnw> ion: lol
16:45:05 <edwardk> monochrom: clearly you should adopt the yielding IO approach ;)
16:45:07 <johnw> ion: old habit
16:45:22 <edwardk> @google yielding IO free monad
16:45:24 <lambdabot> http://comonad.com/reader/2011/free-monads-for-less-3/
16:45:24 <lambdabot> Title: The Comonad.Reader » Free Monads for Less (Part 3 of 3): Yielding IO
16:45:36 <danharaj> best io formalism
16:45:40 <danharaj> coroutines are best routines
16:46:00 <johnw> banister: does that make it any clearer?
16:46:03 <edwardk> we use it in ermine to good effect
16:46:15 <banister> johnw: thanks, i'll save it for reading later when the whiskey wears off ;)
16:46:20 <merijn> edwardk: Is that defined anywhere? I can't seem to find FreeT instance of MonadWriter in free?
16:46:23 <edwardk> lets the whole language be pure, and just gets it interrogated from the outside
16:46:38 <edwardk> merijn: if its missing, clearly you should send me a patch based on your implementation ;)
16:46:40 <eduardo_> applicative: what version of wxwidgets do you have on your machine?
16:46:46 <merijn> edwardk: :(
16:47:25 <johnw> and my thanks to edwardk for explaining to me how State really worked :)
16:47:25 <danharaj> edwardk: you should add delimited control with a monadfix instance to your ermine IO :P
16:47:32 <danharaj> (I think monadfix can only be defined for Cont if you have mutable cells)
16:47:57 <merijn> edwardk: So far I've patched GHC twice, patched exceptions, patched pipes and some other I can't remember and now I have Yet Another Yak Shaving assignment without getting any further on my own code >.<
16:48:06 <edwardk> =)
16:48:13 <edwardk> sounds like an average wednesday ;)
16:48:15 <blackdog> merijn: and thus progress is made
16:48:34 <edwardk> did you send me a patch for whatever it was for exceptions?
16:48:58 <merijn> edwardk: Yes, you preceded to give commit rights on exceptions and make me fix the rest too >.>
16:49:08 <edwardk> ah ys
16:49:11 <edwardk> i remember now
16:49:22 <danharaj> exceptions?
16:49:28 <danharaj> is that an exceptions library that doesn't suck?
16:49:29 <merijn> I'm Pretty Sure (TM) my MonadWriter is correct, it's just horribly inelegant...
16:49:30 <edwardk> wanted to make sure that was you and not some other poor sucker^H^H^H^H^H^Hhelpful individual
16:49:43 <edwardk> danharaj: it is 'the obvious implementation i couldn't find'
16:50:02 <edwardk> whether that sucks or not is up for interpretation
16:50:18 <edwardk> i just needed _something_ so i could have it for lens 3.10
16:50:24 <danharaj> ooh
16:50:32 <danharaj> I thought lens was 'complete'
16:50:41 <edwardk> since Control.Exception.Lens was using MonadCatchIO-transformers and that doesn't build with head
16:50:55 <edwardk> nah we probably hav 70 or so open issues we're slowly chipping away at
16:51:43 <edwardk> 3.10 will pull out zippers into a separate package, fix compatibility with GHC HEAD and have some performance improvements here and there
16:51:50 <danharaj> exciting
16:51:56 <edwardk> generally pretty mild stuff, but still useful
16:52:03 <danharaj> btw have you seen Adam Gundry's thesis on pi types in System FC?
16:52:07 <hpaste> js pasted “arbitrary poroblems” at http://lpaste.net/91653
16:52:12 <edwardk> nope
16:52:43 <danharaj> It just got posted recently, it was something I've been waiting for to come out. It is a nice read.
16:52:49 <danharaj> I would say a pleasant read, in fact.
16:53:18 <johnw> danharaj: link?
16:53:34 <danharaj> https://personal.cis.strath.ac.uk/adam.gundry/thesis/
16:53:45 <danharaj> The treatment of type inference is really nice.
16:53:47 <johnw> thank you
16:53:56 <johnw> sounds like a great topic
16:54:32 <edwardk> danharaj: placed near the top of the pile =)
16:54:41 <danharaj> edwardk: such an honor :P
16:55:13 <edwardk> oh, i found a neat result today when hacking on the kan extensions/lifts
16:55:20 <johnw> oh?
16:55:22 <danharaj> did you implement prolog in 1 line of code?
16:55:25 <johnw> do tell
16:55:34 <edwardk> there is another comonad-to-monad-transformer _almost_
16:56:15 <edwardk> Ran w Identity a  forms a monad for w a comonad, but it isn't as powerful as the monad you get out of Rift w Identity
16:56:27 <edwardk> the difference is between
16:56:40 <edwardk> w (a -> r) -> r    and (a -> w r) -> r
16:56:55 <johnw> do comonads have a notion of costrength?
16:57:06 <danharaj> I'm surprised they are both monads. The first one looks like it could be just an applicative.
16:57:12 <Philippa> danharaj: cheers, I really should've grabbed that already given that I've chatted with Adam about it in person!
16:57:13 <edwardk> where there exists a morphism from w (a -> r) -> a -> w r, but not one in the other direction in general.
16:57:17 <merijn> oh!
16:57:25 <merijn> I think I have a more elegant approach: http://lpaste.net/91652
16:57:28 <danharaj> Philippa: I believe you are mentioned in the Acknowledgements section :)
16:57:32 <merijn> Now I just need to come up with better names :p
16:57:40 <edwardk> the arrow from (a -> w r) -> w (a -> r) can only exist for representable 'w's
16:58:05 <danharaj> That makes sense.
16:58:07 <Philippa> danharaj: awesome, I didn't know :-)
16:58:09 <S_J> http://lpaste.net/91653 <- c_wraith
16:58:15 <merijn> I'm pretty sure that ought to be correct
16:58:15 <johnw> edwardk: I just saw you making that point about representability in that context somewhere else like, yesterday.  SO was it?
16:58:30 <edwardk> which means that Ran w Identity is a monad for all comonads w (which is an interesting exercise in its own right), but it can only 'lift' the comonadic actions into monadic actions for comonads that are representable -- of which all of them are isomorphic to the Traced comonad.
16:58:49 <johnw> that's interesting
16:59:43 <danharaj> I didn't know all representable comonads are iso to Traced.
16:59:43 <edwardk> which is kind of an interesting result and showcases that you can get something similar to Rift-based comonad-to-monad transformer (that monad wasn't something i expected to actually work!) but where it isn't _quite_ powerful enough to work in general
16:59:59 <edwardk> all representable functors are isomorphic to (x ->)
17:00:05 <johnw> right, that point
17:00:09 <danharaj> oh yeah duh
17:00:13 <edwardk> (x ->) is a comonad iff x is a monoid
17:00:22 <danharaj> I did a long shift on monday/tuesday :P
17:00:50 <edwardk> so if you have something like a comonad on data Pair a = Pair a a   -- then really what you're doing is manipulating some Monoid on Bool.
17:01:01 <merijn> edwardk: Actually, free doesn't have classes for any of the state/writer/reader/rws transformers
17:01:15 <edwardk> merijn: man you have so much work ahead of you!
17:01:19 * merijn sighs
17:01:38 <merijn> I will never finish a haskell project...
17:01:52 <edwardk> sure you will. it'll just be one of mine
17:02:10 <hpc> merijn: you should pick a less sysiphean task than "do what edwardk does" ;)
17:02:14 <merijn> I need to adopt edwardk's approach
17:02:30 <edwardk> merijn: beat your head on the problem for 6 years, then start asking for help?
17:02:45 <merijn> hpc: I figured "native haskell implementation of ZMQ with nice STM support" was pretty standalone and un-abstract
17:02:57 <merijn> Any gullible fools that want to write my code for me? :>
17:03:07 <merijn> hpc: Shows what I know...
17:03:20 <blackdog> merijn: you're working on pure haskell zmq stuff?
17:03:36 <merijn> blackdog: Yes
17:03:37 <startling> merijn, just write something where people can show off one-liners with lambdabot
17:03:44 <startling> guaranteed to impress
17:03:47 <blackdog> that could be very cool.
17:04:02 <edwardk> startling: worked for lens! =)
17:04:31 <edwardk> though i had to hand evaluate stuff in here for months before cale put it in =)
17:04:35 <merijn> blackdog: Yes! But I keep getting drawn into yak shaving exercises :p
17:04:50 <blackdog> i was helping a new haskeller work on something like that
17:05:00 <blackdog> https://github.com/xrl/zmqhs
17:05:12 <blackdog> i think it's languishing a bit though
17:05:47 <blackdog> merijn: i hit some weird limits in the zeromq C lib when i tried to connect with heaps of sockets at once
17:05:51 <S_J> s1 <- arbitrary :: String; that doesnt put a String in s1
17:06:01 <blackdog> even though the ulimit stuff and sysctl limits were all absurdly high
17:06:08 <S_J> i really dont get it, cant jus tsomeone do th whole thing
17:06:18 <blackdog> so i shall watch your progress with considerable interest :)
17:08:04 <edwardk> arbitrary :: String is saying that arbitrary itself has type String, not the result of arbitrary.  (that would perforce be Char in the [] monad)
17:08:15 <edwardk> you mean (s1 :: String) <- arbitrary
17:08:21 <merijn> blackdog: I actually want a non-conduit/pipes/iteratee approach. i.e. I want ZMQ sockets more like Chan/TChan, shared by multiple threads
17:08:34 <edwardk> or s1 <- arbitrary :: WhateverMonadYouAreIn String
17:08:53 <blackdog> merijn: i'd be happy with that. but then, i never properly grokked the benefit you get from iteratee & friends anyway.
17:08:57 <twoolie> S_J: Couldn't match expected type `String' with actual type `Gen a0'  =>>  s1 <- arbitrary :: Gen String
17:09:03 <blackdog> my spider looks very imperative - lots of mvars and iorefs
17:09:06 <merijn> blackdog: I will probably implement a pipes interface too, since I'm using pipes internally anyway, but my main focus would be more of a distributed actor model
17:09:17 <S_J>  Illegal signature in pattern: String
17:09:19 <S_J>         Use -XScopedTypeVariables to permit it
17:09:40 <edwardk> S_J: turn on that extension then ;)
17:10:12 <twoolie> S_J: if you use `s1 <- arbitrary :: Gen String` you don't need scoped type variables
17:10:30 <merijn> blackdog: The main issue with that approach is ensuring sockets get garbage collected and how to deal with writes to "closed" sockets, but I'll worry about that when I get there
17:10:45 <danharaj> I think GHC should just have that on by default.
17:10:48 <MouseTheLuckyDog> Interesting question: can every possible error in a program be made  into a type error  by sufficiently sophisticated choice of types?
17:10:52 <danharaj> Since we're already flouting Haskell98.
17:11:11 <blackdog> MouseTheLuckyDog: you run into turing completeness problems
17:11:22 <merijn> blackdog: otoh, if you have a fixed set of long-lived ZMQ sockets (as you should) neither of those should be a problem
17:11:25 <blackdog> so, no, if you want a guarantee that the type checker will terminate
17:11:25 <twoolie> something something dependent typing?
17:11:47 <merijn> blackdog: Actually, you can, just at the cost of turing completeness
17:11:49 <blackdog> merijn: yeah, i had a few thousand but they were set up statically
17:12:04 <blackdog> merijn: isn't that what i said? :)
17:12:10 <S_J> and how do i use oneof with those?
17:12:14 <merijn> blackdog: A few thousand? That seems...rather high for ZMQ
17:12:33 <merijn> blackdog: I'm referring to ZMQ sockets here, just to make sure we're on the same page
17:12:45 <blackdog> merijn: independent threads doing various things. in the end i switched it to a single socket that handed out jobs within the haskell runtime
17:12:47 <Saizan> blackdog: turing completeness isn't so relevant, it just means you're going to weed out some good programs too
17:13:10 <merijn> blackdog: I don't see why you would need a few thousand ZMQ sockets for that?
17:13:19 <blackdog> merijn: each thread had its own socket
17:13:34 <banister> MouseTheLuckyDog: would: (fix (+2)) (i.e an infinite loop)   be considered an error?
17:13:41 <merijn> blackdog: You could have just had a Push on the server and Pull on all remote clients?
17:13:42 <startling> MouseTheLuckyDog: no.
17:13:56 <startling> at that point you're just as likely to write an error in the types, aren't you?
17:14:08 <blackdog> merijn: i was trying to treat each thread as an independent entity
17:14:08 <Saizan> MouseTheLuckyDog: in theory yes, even if not in haskell, but then actually implementing that program will get much harder
17:14:27 <twoolie> S_J: jhttp://lpaste.net/91653
17:14:30 <Saizan> MouseTheLuckyDog: and yeah, there's the problem of making sure the spec you've encoded in the types is correct itself
17:14:39 <blackdog> so there are 50 physical machines and several thousand running threads on each machine
17:14:59 <merijn> blackdog: oh, I actually wanted nicer integration between haskells TChan/Chan things and ZMQ sockets for remote communications
17:15:05 <blackdog> merijn: in the end it wasn't too bad to have one socket per machine then dispatch with a bunch of threads all pulling from an mvar
17:15:12 <merijn> blackdog: The C bindings don't play well with Chan's :)
17:15:21 <banister> blackdog: have you read/looked at simon marlow's new book?
17:15:26 <blackdog> banister: only skimmed
17:15:35 <banister> blackdog: what's your impression of it?
17:15:45 <merijn> blackdog: Right, I want to just have one socket per machine and then have multiple thread read directly from that ZMQ socket
17:15:48 <blackdog> banister: it seems interesting and useful. i mean, it would. it's simon.
17:16:01 <blackdog> merijn: yeah, that's more or less what i've hacked up
17:16:06 <merijn> blackdog: Well, not necessarily one per machine, but you get what I mean :)
17:16:33 <blackdog> a feeder thread pulls from zeromq and puts into an mvar, an army of threads are waiting on that mvar
17:16:58 <blackdog> but it's a bit aggravating to have to simulate what there's already a perfectly good communication protocol for
17:17:14 <blackdog> (and then there's the fiddling for returning aggregated results..)
17:17:45 <merijn> Anyhoo, past bed time for me
17:17:52 <blackdog> (btw, quick spruik: meanpath.com is at least partially haskell. yay meanpath. :P)
17:18:01 <merijn> And apparently I need to write mtl instance for free tomorrow >.>
17:18:37 <S_J> twoolie: Couldn't match expected type `Gen String' with actual type `[Char]'
17:18:37 <S_J>     In the expression: "foo"
17:18:37 <S_J>     In the first argument of `oneof', namely `["foo", "bar"]'
17:20:40 <S_J> does quickcheck ALWAYS generate the empty stuff like [] and ""?
17:22:07 <byorgey> S_J: oneof takes a list of generators, not a list of values
17:22:19 <byorgey> S_J: perhaps you want 'elements' instead
17:22:42 <byorgey> oneof :: [Gen a] -> Gen a;  elements :: [a] -> Gen a
17:23:27 <byorgey> S_J: I'm not sure what you're asking.  The Arbitrary instance for lists will generate the empty list.
17:24:22 <S_J> yes, ty!
17:24:39 <S_J> now can i rewrite it as not being a Triplet but just a (String,String,String)?
17:24:53 <S_J> byorgey: everytime?
17:25:46 <byorgey> S_J: no, (String,String,String) already has an Arbitrary instance
17:25:49 <ion> I’m not sure what code you’re talking about, but try replacing Triplet with (,,)
17:26:30 <byorgey> S_J: it is highly likely to generate the empty list at least once every time you run the tests.  I am not sure whether it is guaranteed.
17:27:36 <jnhnum1_> is there any way to make synonyms for constraints?
17:27:37 <jnhnum1_> for example
17:28:17 <byorgey> jnhnum1_: yes, with GHC 7.6, if you enable the  ConstraintKinds extension
17:28:25 <jnhnum1_> oh
17:28:56 <jnhnum1_> awesome
17:29:02 <byorgey> otherwise, there is a kind of kludgy way
17:29:09 <twoolie> S_J: I think this is what you need http://lpaste.net/91653
17:30:20 <byorgey> twoolie: that does not type check
17:30:29 <byorgey> you can just get rid of   oneof $
17:30:44 <byorgey> elements :: [a] -> Gen a
17:30:54 <twoolie> indeed your right, i misread
17:32:38 <hpaste> byorgey annotated “arbitrary poroblems” with “A more funner way” at http://lpaste.net/91653#a91655
17:33:34 <haasn> :t curry3
17:33:35 <lambdabot>     Not in scope: `curry3'
17:33:35 <lambdabot>     Perhaps you meant `curry' (imported from Data.Tuple)
17:33:56 <haasn> I would write that as “curry3 Triplet” where curry3 f x y z = f (x,y,z)
17:35:14 <startling> :t \f -> ((f .) .) . (,,,)
17:35:15 <lambdabot> ((d -> (a, a1, a2, d)) -> c) -> a -> a1 -> a2 -> c
17:36:35 <haasn> :t that's a 4-tuple
17:36:36 <lambdabot> Not in scope: `that's'
17:36:36 <lambdabot>     Ambiguous occurrence `a'
17:36:36 <lambdabot>     It could refer to either `L.a',
17:36:37 <haasn> oops
17:37:00 <haasn> meant to be a reply to startling, not a :t =)
17:37:15 * hackagebot FunGEn 0.4.2 - FUNctional Game ENgine  http://hackage.haskell.org/package/FunGEn-0.4.2 (SimonMichael)
17:38:11 <startling> oh, I always accidentally count the number of commas
17:38:34 <geekosaur> fencepost error
17:40:49 <ReinH> those fence posts are tricksy
17:41:48 <startling> geekosaur: oh, it's good to have a name for that
17:46:06 <ericmoritz> I'm stumped; any idea why this can't compile but works fine in ghci? https://gist.github.com/ericmoritz/2d6f59c8698315a3d217
17:46:48 <hpc> is there a function in a package somewhere for chunking a list into lists of (lists of length n)?
17:46:49 <haasn> ambiguous type error or something?
17:47:10 <haasn> ericmoritz: ghci uses extended defaulting rules, which makes that default to Maybe (). I'm guessing you get an ambiguous type error in GHC
17:47:35 <ericmoritz> yeah
17:47:55 <haasn> add a type signature :) eg. (Nothing :: Maybe ())
17:48:04 <haasn> alternatively, turn on extended defaulting rules when compiling
17:48:09 <haasn> note also that putStrLn . show = print
17:49:14 <ericmoritz> is it because just using Nothing doesn't specify what kind of Maybe it is?
17:49:19 <haasn> yes
17:49:31 <haasn> :t Nothing
17:49:32 <lambdabot> Maybe a
17:49:43 <ericmoritz> now it is clear thanks
17:52:21 <FreeFull> Too bad Haskell isn't smart enough to tell that you don't need to know what Maybe it is to show Nothing
17:55:17 <heatsink> hpc, splitIntoN in the edenskel package
17:55:52 <heatsink> Actually, that's a list of N lists
17:56:14 <heatsink> chunk in the edenskel package does what you want
17:57:16 * hackagebot prednote 0.14.0.0 - Build and evaluate trees of predicates  http://hackage.haskell.org/package/prednote-0.14.0.0 (OmariNorman)
18:02:21 <banister> how long is this going to be available for free online btw? anyone know? http://chimera.labs.oreilly.com/books/1230000000929/ch06.html
18:02:32 <banister> thisi mean http://chimera.labs.oreilly.com/books/1230000000929
18:02:53 <banister> (parallel and concurrent programming in haskell)
18:04:59 <ReinH> banister: I think it'll eventually be free forever?
18:05:07 <ReinH> but I bought it and thought it was a great deal
18:05:30 <kloplop321> I'm working on a little testing / helping code (which works!) http://puu.sh/3WsJX.png And I want to know if there's an easier way to come up with a Data.Time.Clock.NominalDiffTime without going to the effort of specifying two arbitrary dates, reading, etc., just to get some value > 0.5 seconds? I am currently using a thread delay of 600 ms to get this value.
18:05:32 <banister> ReinH: interesting, i wonder what's the economic rationale for that? won't most people (who presumably always have access to the internet) have no incentive to purchase it?
18:05:36 <blackdog> ReinH: it's hard to avoid the initial "$32 for an ebook?" reaction.
18:05:40 <ReinH> banister: no idea
18:05:45 <blackdog> i'm sure the value is there, though.
18:05:50 <ReinH> blackdog: for me it's about the content, not how many bits I'm receiving
18:06:04 <ReinH> Also the ebook+paper deal is good
18:06:06 <blackdog> ReinH: yeah, it's irrational. interesting how pricepoints get set, though.
18:06:24 <ReinH> it is!
18:06:30 <c_wraith> kloplop321: the secret is reading the instance list for the type
18:06:46 <c_wraith> kloplop321: one of the instances listed is Num NominalDiffTime
18:07:10 <c_wraith> kloplop321: And that instance happens to mean that numeric literals can have that type.
18:07:42 <kloplop321> So I can use fromInteger to change it to what I want?
18:07:55 <c_wraith> (though NominalDiffTime has no sensible implementation of (*), so Num is a bit weird)
18:08:33 <c_wraith> kloplop321: What do you mean by "change it to what I want"?
18:09:01 <kloplop321> Integer -> a, leads me to believe that I can say `let diff = fromInteger 40000000` or whatever and it may work
18:09:38 <c_wraith> that would be 40 million seconds, but yeah...
18:09:44 <c_wraith> but my point was, you can just use literals
18:09:50 <c_wraith> let diff = 40000000
18:10:07 <c_wraith> numeric literals in haskell are polymorphic
18:10:19 <c_wraith> :t 5
18:10:20 <lambdabot> Num a => a
18:10:30 <c_wraith> It works for *any* instance of Num
18:10:38 <kloplop321> Thanks, I'll try this out :)
18:10:52 <lightquake> why does ghc require libgmp.so.3 as opposed to a newer version?
18:12:16 * hackagebot penny-lib 0.20.0.0 - Extensible double-entry accounting system - library  http://hackage.haskell.org/package/penny-lib-0.20.0.0 (OmariNorman)
18:12:18 * hackagebot penny-bin 0.20.0.0 - Extensible double-entry accounting system - binary and documentation  http://hackage.haskell.org/package/penny-bin-0.20.0.0 (OmariNorman)
18:12:32 <kloplop321> c_wraith: Thanks again!
18:12:40 <c_wraith> you're welcome
18:15:17 <BMeph> lightquake: Short answer: Because it works. ;)
18:21:25 <ericmoritz> is there a name for an (a -> m b) function? I've been calling them monad makers but I'm sure there's a proper name for them
18:21:51 <edwardk> a kleisli arrow
18:21:52 <haasn> kleisli arrow
18:21:57 <c_wraith> ericmoritz: if you don't want to just call them functions...
18:22:15 <lingxiao> edwardk : may I bother you for a second?
18:22:17 <haasn> ‘m’ is the monad, not ‘m a’
18:22:19 <lingxiao> :)
18:22:23 <haasn> so a monad maker isn't accurate either
18:22:45 <c_wraith> still, kleisli arrow means something a bit more than function.  It tells you that there's an m present
18:23:07 <edwardk> The Kleisli category of a monad m has arrows that look like (a -> m b) basically using (>=>) to glue them together.
18:23:19 <edwardk> lingxiao: sure
18:23:20 <liyang> I call the ‘m b’ part a ‘monadic action’, or sometimes just an ‘action’. Like what everyone said above, just the ‘m’ part is the monad.
18:23:30 <ericmoritz> haasn: yeah I know that monad maker is incorrect because I'm not making a monad
18:23:36 <haasn> compare newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }
18:23:38 <djahandarie> I forget all the silly names for mondaic values.
18:23:45 <haasn> instance Monad m => Arrow (Kleisli m)
18:23:47 <djahandarie> Was mote one? I think it was.
18:23:59 <lingxiao> edwardk : awesome. So (not sure if you remember) I was asking you about machines with bi-directional flow of data?
18:24:18 <lingxiao> And you said there's an older version of machines that could do that (Before you added Tee and Wye presumably)
18:24:22 <edwardk> lingxiao: sure. have you looked at the Proxy type in machines? thats basically the stuff i had for bidirectional flow
18:24:55 <edwardk> bit different. i was tupling up the 'protocol' into a product type of product kind, but thats about it
18:25:10 <heatsink> Those man mudflaps
18:25:14 <heatsink> oh sorry
18:25:15 <heatsink> wrong window
18:25:45 <ericmoritz> edwardk: I just learned how to use >=> tonight; it's pretty dang handy
18:26:27 <heatsink> Is that the monadic (.)?
18:26:29 <edwardk> er sorry not machines. i meant the Proxy type in pipes
18:26:35 <edwardk> heatsink: more or less
18:26:36 <ericmoritz> heatsink: basically
18:26:42 <edwardk> i think technically you want (<=<) for that
18:26:44 <edwardk> :t (<=<)
18:26:44 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
18:26:50 <edwardk> i forget which fish is which
18:27:10 <edwardk> :t (.)
18:27:11 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:27:11 <haasn> doesn't matter, they're the same (up to isomorphism) :)
18:27:23 <edwardk> :t (Control.Comonad.=<=)
18:27:24 <lambdabot> Control.Comonad.Comonad w => (w b -> c) -> (w a -> b) -> w a -> c
18:27:24 <liyang> edwardk: come visit Japan. We can show you all the fishes. (Then eat them.)
18:27:25 <lingxiao> edwardk : I'm sorry I tried to find `Proxy` in every file in src, but cannot find it somehow?
18:27:38 <haasn> edwardk: if it helps, (<=<) is like (<<<)
18:27:42 <edwardk> lingxiao: ^-- see above. i meant Pipes =)
18:27:45 <lingxiao> this is version  0.2.3.1
18:27:55 <lingxiao> Oh hahaha
18:28:28 <edwardk> anyways Proxy is the same design i converged on (modulo whether we cps or not, etc)
18:28:45 <danharaj> edwardk: so in which ways is your version better ;)
18:29:22 <haasn> edwardk: Proxy is still a special case of machines though isn't it?
18:29:23 <edwardk> i obtained it by starting with 'singularity' style channels, taking the base functor for sending messages up and downstream and then 'splitting it' so you didn't have to have it run in an external thread. that yielded the design that pipes has for Proxy now.
18:29:30 <edwardk> danharaj: that i wrote it 2 years earlier?
18:29:36 <danharaj> haha yes
18:29:43 <lingxiao> DOH!
18:29:44 <edwardk> danharaj: and then mentioned it to Tekmo? =)
18:29:45 <danharaj> but I remember you said you didn't have a story for resources
18:30:08 <lingxiao> edwardk : also can I ask you why you did this:  `data Step k o r = forall t. Await (t -> r) (k t) r`
18:30:14 <edwardk> machines doesn't have a story for resources mostly out of apathy
18:30:19 <danharaj> good reason
18:30:21 <edwardk> lingxiao: consider Source
18:30:23 <lingxiao> why is t an existential?
18:30:27 <lingxiao> ok..
18:30:50 <edwardk> if you use Await (k r) r  then to map over Step you need a Functor for k right?
18:31:06 <lingxiao> yup
18:31:06 <danharaj> lingxiao: k t labels demands that ask for a value of type t. you don't get to choose the value.
18:31:13 <edwardk> that means the Monad for machines needs a _known_ functor for k
18:31:35 <danharaj> get to choose the type*
18:31:35 <edwardk> as it is we can make a Machine monad independent of the choice of k
18:31:46 <edwardk> this is the trick that makes Yoneda f a Functor even when f isn't
18:32:16 <haasn> it still blows my mind that Codensity f is a Monad for *all* f
18:32:21 <edwardk> and it means that when you go to use the Machine/Plan/etc data types that we can do so without signatures in more cases
18:32:54 <edwardk> Source can then feel free to quantify over the 'k' without a constraint on it
18:33:14 <edwardk> and it is then clear that it can't use Await, because it doesn't know anything about k!
18:34:01 <edwardk> by constructing them in that fashion you can directly utilize a source as if it was a machine that took any kind of input you want
18:34:24 <edwardk> it makes 'stubbing' out a tee with a source for one of its inputs easy to do
18:35:01 <edwardk> i started with the obvious, wound up with the type inference headache that made them hard to use in practice, and then decided to use the Yoneda trick
18:35:40 <edwardk> Await (Yoneda k r) r
18:35:54 <edwardk> for the Lan-like Yoneda
18:36:10 <lingxiao> woa I think I need to understand this Yoneda thingy before I could fully appreicate what you said...
18:36:25 <lingxiao> does reading about Yoneda lemma on wikipedia gets me cloer?
18:36:27 <lingxiao> closer*
18:36:30 <edwardk> lingxiao: consider this statement. f a  and (forall r. (a -> r) -> f r)   are isomorphic
18:36:33 <edwardk> for any Functor f.
18:36:52 <lingxiao> right ok
18:36:54 <edwardk> to see that lets write the functions to convert both ways
18:37:04 <edwardk> write: Functor f => f a -> (a -> r) -> f r
18:37:25 <edwardk> that should be pretty simple
18:38:28 <edwardk> in the other direction it is just: lowerYoneda :: (forall r. (a -> r) -> f r) -> f a     which is lowerYoneda f = f id
18:38:41 <haasn> :t id ?? id
18:38:42 <lambdabot> ((a -> a) -> b) -> b
18:38:49 <edwardk> :t flip fmap
18:38:49 <lambdabot> Functor f => f a -> (a -> b) -> f b
18:39:12 <edwardk> :t flip fmap . ($id)
18:39:13 <lambdabot> Functor f => ((a1 -> a1) -> f a) -> (a -> b) -> f b
18:39:24 <edwardk> :t ($id).flip fmap
18:39:25 <lambdabot> Functor f => f a -> f a
18:39:55 <edwardk> when you put the appropriate rank 2 type on the first one of those, those are identify functions.
18:40:33 <edwardk> that is the co-Yoneda lemma.  there are other variants of the yoneda lemma, that involve whether you use a universal or existential and if you deal with co- or contra- variant functors.
18:41:28 <edwardk> f a    is isomorphic to exists r. (f r, r -> a)      for a Functor f as well.
18:41:39 <thoughtpolice> i should really finish my writeup of Shachaf's little CoYoneda/Yoneda tutorial
18:41:47 <thoughtpolice> although i have less intuition for Yoneda than CoYoneda
18:41:54 <edwardk> since we know nothing about 'r' other than it exist the only thing you can do with that function is fmap it
18:42:13 <edwardk> thoughtpolice: notice in the last 24 hours i went and fixed up the terminology in the kan-extensions package to be more standard w.r.t yoneda/coyoneda, etc.
18:42:28 <edwardk> http://hackage.haskell.org/package/kan-extensions
18:42:41 <danharaj> edwardk: idk if what you call the co-Yoneda lemma is what ncatlab likes to call the co-Yoneda lemma.
18:42:48 <edwardk> lingxiao: the existential form of it is the one i use in Step
18:43:21 <edwardk> danharaj: hence the shift in terminology in there over the last day or two
18:43:25 <applicative> eduardo_: sorry, i keep vanishing as usual; i have brew install wxmac, which seems to be wx 2.9.something
18:43:27 <thoughtpolice> edwardk: nice!
18:43:36 <lingxiao> wow man that was more than a sprinkle of gold dust, it's going to take me sometime to fully digest it.. but thanks for the explanation!!
18:43:38 <danharaj> ah ok. I think their co-yoneda lemma is the existential formulation?
18:43:41 <edwardk> http://hackage.haskell.org/packages/archive/kan-extensions/3.6.2/doc/html/Data-Functor-Yoneda-Reduction.html describes todd trimble's http://ncatlab.org/nlab/show/Yoneda+reduction, etc.
18:44:17 <lingxiao> thoughtpolice: when you finish your tutorial where can I find it?
18:44:42 <thoughtpolice> i was going to put it on School of Haskell
18:44:53 <lingxiao> ah ok awesome thanks
18:44:53 <thoughtpolice> when i say i need to 'complete it' i really mean i need to write like 3 or 4 more paragraphs
18:45:07 <thoughtpolice> mostly just exercise-y stuff
18:45:17 <edwardk> you need it to be on the covariant argument, so the stuff at the top of http://ncatlab.org/nlab/show/co-Yoneda+lemma is hard to map over
18:45:51 <edwardk> i may have the terminology still flopped around for all i know
18:46:21 <thoughtpolice> lingxiao: sure, shachaf's explanation was pretty good (it was here on IRC,) so hopefully making it more visible will be useful
18:46:54 <benzrf> hey
18:46:56 <mapreduce> tabemann: That's a shame about the Scala book, perhaps it was one of the crappy ones that tries to make Java programmers comfortable.
18:47:20 <benzrf> who thinks it would be a really terrible idea to make functions be a typeclass instead of a type
18:47:38 <benzrf> like you can instantiate a typeclass to make your values applicable like functions
18:47:50 <edwardk> danharaj: i'm not wedded to my backwards terminology iff it turns out to be backwards. let me know
18:47:54 <benzrf> pls tell me exactly why this is a truly horrible idea
18:48:17 <edwardk> i eventually do the right thing, but only after exhausting all the wrong options first. I'm american after all.
18:48:23 <lingxiao> thoughtpolice: er not sure how to access shachaf's explanation... do you remember which concepts you had to understand en-route to understanding CoYoneda/Yoneda concepts?
18:48:42 <edwardk> lingxiao: really its just about reading the type of 'fmap'
18:48:46 <edwardk> :t fmap
18:48:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:48:50 <blackdog> edwardk: the right way, the wrong way, and the edwardk way. It's like the right way, but slower.
18:48:51 <edwardk> :t flip fmap
18:48:51 <lambdabot> Functor f => f a -> (a -> b) -> f b
18:49:10 <haasn> benzrf: it would be pointless
18:49:36 <benzrf> haasn: buuuut muh dsls
18:50:00 <edwardk> if we tuple up the arguments, we can have (f a, a -> b) -> f b
18:50:10 <edwardk> but then if we bundle up the args, there is no point in exposing the 'a' parameter
18:50:14 <danharaj> edwardk: Well as I understand it, Yoneda is representing a functor by End_C (F C)^(_ -> C) while Coyoneda is representing it with a Coend.
18:50:26 <haasn> benzrf: on second thought, maybe not as pointless
18:50:57 <edwardk> so we get data Yoneda f b = forall a. Yoneda (f a) (a -> b) -- such that if you take those arguments and pass them to flip fmap you get an f b
18:51:08 <edwardk> danharaj: actually that sounds right to me
18:51:15 <edwardk> apparently in my fix i flipped them around again =)
18:51:18 <danharaj> edwardk: So that Yoneda you just typed would be Coyoneda :P
18:51:34 <edwardk> danharaj: sure. i just name them all 'Yoneda' to maximize confusion
18:51:36 <joelteon> Cocoyoneda
18:51:37 <danharaj> http://ncatlab.org/nlab/show/co-Yoneda+lemma
18:51:54 <thoughtpolice> lingxiao: CoYoneda is actually very intuitive to grasp in Haskell, at least. i'll just mimmick shachaf's explanation: let's say you have an instance of Functor where the fmap is expensive. like a strict binary tree
18:53:12 <joelteon> Yoyoneda
18:53:12 <haasn> benzrf: but it would probably be very hard to do right
18:53:12 <danharaj> edwardk: It doesn't help that Maclane's co-Yoneda isn't important enough to be called co-Yoneda :P
18:53:12 <thoughtpolice> lingxiao: so we could do fmap (*2), then fmap (+) over a 'Tree Int' for example. but ideally, we'd just do both at once: fmap ((*2) . (+1))
18:53:12 <edwardk> danharaj: if you wanted to shuffle around the 4 yoneda modules in kan-extensions and send me a patch i'd probably take it =P
18:53:12 <thoughtpolice> the fact that is valid is Functor law #2
18:53:12 <lingxiao> edwardk : ahhh I get what you're saying now, not sure why first time around it just bounced off of my head.. hhaha
18:53:12 <thoughtpolice> (er, that first (+) should be (+1), sorry)
18:53:12 <danharaj> edwardk: If you saw my git histories at work you would realize I am the last person you want a patch from ;)
18:53:14 <lingxiao> thoughtpolice: but I like what you're saying too so please keep going
18:53:53 <edwardk> lingxiao: anyways you can play that 'bundling up the args of fmap' trick 2 different ways. one yields an existential (the coend danharaj and i are talking about) and one yields a universal
18:54:02 <thoughtpolice> lingxiao: so one way to fix this is just to bundle the Functor up with a function in a tuple. so instead of a Tree Int, we would contain a (Tree Int, Int -> Int). when we want the final tree, we just apply the function to it
18:54:22 <thoughtpolice> we can then compose functions cheaply: just compose another function of Int -> Int onto the one you already have
18:54:37 <edwardk> nicely 'Yoneda f' gives you a verison of 'f' with a baked in fmap in such a way that multiple fmaps over it, will just bolt them into the one use of fmap on the underlying 'f' when you finally 'pull the trigger' and lower it back out
18:54:49 <edwardk> so it is a form of 'forced fmap fusion' when you look at it that way
18:54:58 <thoughtpolice> lingxiao: so as a data type, that would be: data FTree a = FTree (Tree Int) (Int -> Int)
18:55:05 <haasn> First time I've seen “Data.Functor”
18:55:07 <thoughtpolice> lingxiao: two generalizations will turn this into CoYoneda
18:55:32 <lingxiao> ahh ok I really like this optimizing angle
18:55:36 <tabemann> back
18:55:36 <thoughtpolice> number one: we don't care what the initial type of the tree is. it just has to match the domain of the function paired with it. we can do this with ExistentialQuantification
18:55:47 <edwardk> danharaj: i'm not a huge stickler about patch cleanliness ;)
18:55:49 <tabemann> mapreduce: I think it was actually the O'Reilly one
18:55:49 <danharaj> edwardk: your terminology looks right in the End case, idk if Yoneda Reduction refers to co-Yoneda or just using Yoneda as a calculational tool in ends?
18:56:00 <edwardk> danharaj: http://ncatlab.org/nlab/show/Yoneda+reduction
18:56:15 <edwardk> it was an attempt to borrow todd trimbles term
18:56:17 <thoughtpolice> lingxiao: so, now we have - data FTree a = forall b. Ftree (Tree b) (b -> Int).
18:56:17 <lingxiao> +1 for spelling ExistentialQuantification correctly and not getting lost in all the letters
18:56:38 <thoughtpolice> lingxiao: the final generalization: we don't care you had a Tree! we just need to have a Functor
18:56:45 <edwardk> the problem is the data type itself isn't the reduction its the way you smash together the bits that is yoneda reduction in his terminology
18:56:55 <benzrf> what is yoneda?
18:56:57 <danharaj> yeah
18:57:08 <thoughtpolice> so we get 'data Thing a = forall b. Thing (f b) (b -> a)'
18:57:15 <thoughtpolice> lingxiao: this is the definition of CoYoneda
18:57:25 <thoughtpolice> data CoYoneda a = forall b. CoYoneda (f b) (b -> a)
18:57:43 <edwardk> benzrf: ways to pull out the function you are mapping over a functor so that its guts are exposed and you can play with it
18:57:56 <lingxiao> which looks a lot like this: "forall t. Await (t -> r) (k t) r"
18:58:13 <thoughtpolice> lingxiao: yep!
18:58:19 <edwardk> lingxiao: read that as Await (CoYoneda k r) r
18:58:31 <lingxiao> ohh that's what you said like 45 lines up haha
18:58:35 <edwardk> lingxiao: then it is obvious what is going on
18:58:39 <lingxiao> but this time it's more than reandom letters
18:58:39 * tabemann is wondering whether his Java (with Multiverse) impl. of the Santa Claus problem will be longer than his Haskell impl....
18:58:41 <thoughtpolice> lingxiao: so CoYoneda, like edwardk said, sort of performs an fmap-fusion over a data structure. if you write out functions to convert functors to and from CoYoneda, that will be clear
18:58:51 <edwardk> you can fmap over CoYoneda f   without knowing anything about f
18:59:21 <danharaj> edwardk: By the way, if you think of a non-functorial type constructor F as |*| -> * then CoYoneda F being Lan Inclusion F turning it into a functor is the right way to think about functorification. I think that is cute. :)
18:59:24 <tabemann> (why am I implementing this, in Java, anyways?)
18:59:24 <thoughtpolice> lingxiao: here's a fun exercise if you'd like
18:59:30 <heatsink> Does the 'k' have anything to do with continuations?
18:59:30 <lingxiao> ok wow you guys are actually really good at explaning things, this is amazing
18:59:44 <edwardk> instance Functor (Coyoneda f) where fmap ab (Coyoneda fr ra) = CoYoneda fr (ab.ra)
18:59:51 <danharaj> Perhaps it is you who are really good at being explained to.
18:59:53 <lingxiao> yes
18:59:56 <applicative> heatsink: yes it is odd
19:00:32 <thoughtpolice> lingxiao: given 'data CoYoneda f a = forall b. CoYoneda (b -> a) (f b)', implement: liftCoYoneda :: f a -> CoYoneda f a, and also implement lowerCoYoneda :: Functor f => CoYoneda f a -> f a
19:00:57 <danharaj> edwardk: btw is there a mnemonic device for remembering which arg goes first in {L,R}{ift,an}?
19:01:01 <edwardk> anyways i can flip the terminology between co-Yoneda and yoneda-reduction if need be
19:01:06 <thoughtpolice> lingxiao: now, take 'data Yoneda f a = Yoneda (forall b. (a -> b) -> f b)', and implement 'liftYo :: Functor f => f a -> Yoneda f a' and 'lowerYo :: Yoneda f a -> f a'
19:01:19 <edwardk> danharaj: i read the args from ran left to right Ran f g a = (a -> f r) -> g r
19:01:24 <thoughtpolice> lingxiao: finally, prove that '(lowerCoYo (fmap h (fmap g liftCoYo x))) == fmap (h . g)'
19:01:30 <thoughtpolice> and also prove '(lowerYo (fmap h (fmap g liftYo x))) == fmap (h . g)
19:01:54 <thoughtpolice> lingxiao: this is a fun exercise, and it also proves Yoneda/CoYoneda do an equivalent 'fmap fusion' for functors. in fact, if you have a functor, CoYoneda f, Yoneda f, and f are all the same!
19:02:14 <thoughtpolice> (when 'f' is not a functor, Yoneda and CoYoneda do different things)
19:02:24 <edwardk> also interesting is that there are uses for things like CoYoneda f where f is _not_ a functor.
19:02:31 <thoughtpolice> lingxiao: unfortunately i must leave now. if you try the exercise i hope you like it :)
19:02:33 <danharaj> like I just mentioned :P
19:02:36 <edwardk> e.g. CoYoneda IORef
19:02:58 <lingxiao> thoughtpolice: yup thank you for the different angle you took on the explanation!
19:03:04 <lingxiao> and the exercises!
19:03:25 <edwardk> CoYoneda IORef a    is a reference to some type you don't know and a function from that type to a that you can use to read from it with
19:03:51 <edwardk> its just the 'source' side of an IORef
19:04:01 <edwardk> but in exchange you can fmap over it
19:04:05 <danharaj> IORef is a functor from |*| to *. You're just kan extending it via the faithful inclusion.
19:04:12 <haasn> edwardk: what exactly is http://hackage.haskell.org/packages/archive/comonad-transformers/3.0.4/doc/html/Data-Functor-Composition.html#t:Composition useful for?
19:04:42 <edwardk> haasn: there are several Compose like functors you need to use in practice, because there are for instance many monads that you can derive from compositions
19:04:45 <heatsink> Delayed arrays in Repa seem like a specialization of CoYoneda to arrays
19:05:06 <edwardk> it is used to let you compose/decompose independent of the choice of newtype so i don't have to write so many combinators ;)
19:05:15 <haasn> heatsink: CPS is another example of a specialization of (Co?)Yoneda to Identity
19:05:23 <haasn> edwardk: fair enough
19:05:29 <haasn> edwardk: it's just curious to only see a single instance
19:05:40 <edwardk> haasn: category-extras used to have more of them
19:05:56 <edwardk> given a monad and a pointed functor, their composition can form a monad in 3 ways
19:05:56 <danharaj> You can also newtype if you want different instances.
19:05:59 <haasn> R.I.P. category-extras
19:06:04 <edwardk> well, actually at least 3 ways
19:06:51 <edwardk> given a distributive law of MN -> NM, NM -> MN, or an 'absorption law' for MNM -> MN or MNM -> NM  all gives rise to different monads.
19:06:58 <edwardk> mark p jones showed that back in 93 or so
19:07:08 <edwardk> back before monad transformers showed up
19:07:17 <edwardk> when folks were talking about how to compose monads
19:08:29 * haasn .oO( Wrapped' (o f g x) (f (g x)) )
19:09:11 <heatsink> data Cont a = Cont (forall r. (a -> r) -> r)
19:10:00 <heatsink> I can't make it fit CoYoneda.  Maybe it's a Yoneda.
19:10:11 <edwardk> heatsink: ContT is a special case of Codensity/Ran as well
19:11:12 <heatsink> Were you explaining those earlier?  I missed that.
19:11:53 <edwardk> newtype Ran f g a = Ran (forall r. (a -> f r) -> g r)   -- Codensity f = Ran f f;     use Codensity (Const b) = Ran (Const b) (Const b)   and you get (a -> b) -> b  for a fixed b giving you Cont
19:11:54 <haasn> Codensity = forall b. ContT b
19:12:43 <edwardk> picking Const (m b) gives you ContT  you can play with parens and argument structure to suit yourself
19:13:19 <edwardk> haasn: Yoneda is a special case of Ran. Ran Identity ~ Yoneda, Lan Identity ~ CoYoneda
19:14:01 <edwardk> CPSing is Codensity Identity = Yoneda Identity = Ran Identity Identity
19:14:33 <edwardk> er heatsink
19:17:11 <heatsink> Okay, i see how the types work out
19:24:02 <danharaj> edwardk: Why does profunctor-extras only have Rift and not the other 3?
19:24:44 <edwardk> give me the definitions of kan extensions  and left kan lift for the profunctor category and i'll happily add them
19:24:57 <edwardk> i wrote that as the first kan lift code i managed to think through
19:25:16 <edwardk> just following the ncategory cafe discussions
19:25:27 <danharaj> ah
19:25:36 <danharaj> I thought there may have been a technical limitation
19:25:53 <haasn> wait, whoa, Codensity (Reader s) = State s ?
19:26:01 <danharaj> yes, welcome to the spacejam
19:26:04 <edwardk> nah, should be pretty straight forward to work through from the laws
19:26:06 <edwardk> haasn: =)
19:26:16 <danharaj> although see dolio's comonad reader article
19:26:19 <edwardk> haasn: see 'kan extensions ii' for motication
19:26:23 <edwardk> er motivation
19:26:37 <danharaj> http://comonad.newartisans.com/reader/2012/unnatural-transformations-and-quantifiers/index.html
19:26:50 <augur> Codensity (Reader s) = State s only if we have univalence :X
19:26:52 <haasn> I was a bit confused by the implication that lowerCodensity :: State s a -> Reader s a -- but I guess it makes sense, that's just evalStateT
19:27:13 <edwardk> Codensity f isn't isomorphic to f, it can be bigger
19:27:24 <edwardk> it just has a canonical way to shrink back down
19:28:53 <haasn> so lift . lowerCodensity ≠ id ?
19:29:46 <haasn> makes sense, in the State s example the output state of the original action would get removed when lowering/lifting again
19:30:00 <edwardk> https://groups.google.com/d/msg/fa.haskell/ai9EDhjGG2I/DOy-KkFpleQJ shows an abuse of this 'slightly bigger' nature using Codensity STM to give very long distance backtracking.
19:30:24 <edwardk> i figure STM showed a non-trivial application of Codensity
19:31:03 <haasn> what exactly does Oracle s let you do that STM does not?
19:31:26 <edwardk> needRef :: Ref s a -> Oracle s Bool
19:31:39 <edwardk> lets you tell if you are going to look at a reference in the future
19:31:49 <danharaj> haha nice
19:31:56 <edwardk> if you do then that will return True, if not, False.
19:32:03 <edwardk> if you play paradox games it'll tell you True ;)
19:32:45 <edwardk> it does so by first deleting the contents of the reference and telling you False. If you ever do read from it, it backtracks to that point and tells you True =P
19:32:55 <edwardk> (and leaves the contents in place
19:33:14 <edwardk> it uses Codensity so it can't callCC, but it can backtrack all the way there
19:33:45 <edwardk> i used it to showcase the power of Codensity even in the absence of callCC to backtrack
19:37:45 <haasn> neat trick
19:39:31 <edwardk> another good use of Codensity is Codensity (Free f) which can be built up cheaper than Free f most of the time when you ever wind up with left associated binds
19:41:56 <haasn> I saw the somewhat peculiarly typed ‘improve’
19:42:16 <haasn> (why not :: Codensity (Free f) a -> Free f a ?)
19:43:43 <haasn> I guess the latter way prevents people from just passing a lift'd Free f they have lying around and expecting it to be improved
19:43:47 <haasn> I mean the former way
19:43:49 <haasn> w/e
19:53:30 <mstksg> anyone here ever use esqueleto?  having problems trying to translate a complicated sql query
19:54:10 <mstksg> http://stackoverflow.com/questions/18115404
20:07:50 <edwardk> haasn: using the quantified form means you get to use nothing you couldn't have used to build a Free in the first place. Codensity (Free f) is bigger than Free f, but (forall m. MonadFree f m => m a) is 'the same size as (Free f a), but may be implemented differently
20:20:09 <edwardk> preflex: xseen danharaj
20:20:09 <preflex>  danharaj was last seen on freenode/#haskell 48 minutes and 19 seconds ago, saying: haha nice
20:31:34 <ianf> looking for an irc channel dedicated to formal language theory. figured this was the best place
20:32:00 <hiptobecubic> that's funny
20:32:18 <hiptobecubic> although you're probably right. most of the people that would be there are probably also here
20:32:44 <ahill-89> It's certainly not the worst channel for it, I'll give him that.
20:32:59 <ianf> do you happen to know of any channels dedicated to constructing formal langues?
20:33:03 <ianf> languages*
20:33:39 <ianf> ##math is garbage
20:33:52 <hiptobecubic> #php
20:33:57 <ianf> lol
20:34:23 <carter> which sort of formal languages?
20:34:24 <ahill-89> Ow, no. I wouldn't inflict that channel on anyone.
20:34:33 <carter> context free grammars or formal models?
20:34:47 <ianf> formal models related to computing
20:34:58 <carter> which kind
20:35:07 <ianf> hmm
20:35:24 <ianf> discrete
20:35:25 <ianf> ?
20:35:31 <carter> like, distributed computation
20:35:35 <carter> models of computation
20:35:37 <ianf> oh
20:35:38 <carter> formal models
20:35:43 <carter> or
20:35:43 <ianf> discrete (raster) graphics
20:35:55 <carter> lets zoom out
20:35:57 <carter> whats the goal
20:36:02 <hiptobecubic> i'm confused
20:36:03 <Neqoxec> descrete models of former raster graphics?
20:36:12 <carter> yeah, whats the goal
20:36:19 <ianf> describing data in formal language
20:36:20 <carter> then we'll figure out what you meant by formal models
20:36:28 <carter> to do ______
20:36:33 <ianf> anything
20:36:37 <ianf> describe data
20:36:39 <hiptobecubic> discrete rasta models in formalwear
20:36:45 <ianf> lol
20:37:00 <carter> like, specifying png files?
20:37:03 <carter> or pgm files?
20:37:13 <carter> or
20:37:15 <ianf> formal language theory
20:37:15 <carter> XML
20:37:16 <carter> or
20:37:29 <carter> in old school CS that was push down automatas and friends
20:37:38 <carter> for parsing and stuff
20:37:55 <ianf> ah, okay
20:38:05 <hiptobecubic> what's new school?
20:38:08 <carter> idk
20:38:24 <ianf> new school is garb
20:38:57 <Neqoxec> according to wikipedia, formal language theory is basically the study of programming syntax and semantics
20:39:20 <carter> nope
20:39:24 <carter> we should edit that
20:39:40 <hiptobecubic> yeah that doesn't right
20:39:44 <carter> who calls PL that
20:39:51 <carter> someone who doesn't know about the ACM
20:39:59 <carter> or the definition of the words
20:40:02 <carter> as used in books
20:40:04 <carter> or internet
20:40:12 <carter> link?
20:40:20 <Neqoxec> https://en.wikipedia.org/wiki/Formal_language
20:40:30 <carter> ohh
20:40:49 <carter> linguistics
20:40:50 <carter> yeah
20:40:51 <carter> thats fine
20:40:57 <carter> errr
20:41:26 <ianf> thanks for the pushdown automata reference
20:41:58 <carter> np
20:42:12 <carter> fixed it
20:42:14 <carter> "In computer science, formal languages are used among others as the basis for defining the grammar of programming languages and formalized versions of subsets of natural languages"
20:42:26 <carter> before it said
20:42:35 <carter> In computer science, formal languages are used among others as the basis for defining programming languages and formalized versions of subsets of natural languages
20:42:57 <carter> thanks Neqoxec
20:43:03 <carter> i think i made it for factlike
20:43:08 <carter> *more fact like
20:43:16 <hiptobecubic> except for a lucky few languages, that grew organically willy nilly as people demanded features
20:43:41 <Hafydd> Formal languages are also used to define the semantics of programming languages, in some cases.
20:44:31 <carter> Hafydd true, if you can make it more accurate, go crazy
20:44:42 <Hafydd> Is it really "as the basis for", and not just "for"?
20:44:44 <carter> i just did the smallest edit that they wont revert withouth a citation eeded
20:44:48 <carter> where
20:45:02 <carter> i didn't touch anything aside from "the grammar of"
20:45:05 <Hafydd> Where it says "as the basis for".
20:45:26 <Hafydd> Oh, it's from Wikipedia? That explains the weasel language.
20:45:36 <carter> Hafydd: read the ruby parser sometime, thats an abyss
20:45:48 <ahill-89> Let's not.
20:46:00 <Hafydd> Let'
20:46:02 <Hafydd> s not do what?
20:46:14 <carter> dont' read the ruby parser
20:46:19 <Hafydd> Okay.
20:46:21 <carter> it will stare back at you
20:46:54 <carter> to have a pleasant experience writing a correct ruby parser, i fear i'd have to invent new tech
20:51:49 <tabemann> blarg
20:52:07 <tabemann> coding up the santa claus problem with multiverse (a java STM impl.) was not fun
20:52:53 <latermuse> tabemann: why wasnt it fun? hard to get multiverse working correctly?
20:54:04 <tabemann> I got multiverse working at work earlier today on a different problem, dining philosophers, but the thing is that there is so much extra crap when dealing with multiverse (or, it seems, any other Java STM impl., from the example code I've seen), when compared with Haskell STM, which is very succinct and elegant, especially in comparison
20:54:26 <tabemann> multiverse itself at least basically worked out of the box without a hitch
20:54:51 <latermuse> haskell STM ties my brain into a knot, but is great to work with after i figured out how to work with it
20:55:10 <tabemann> if I had my way I would just show Haskell STM examples to my coworkers for my STM lecture, but no, they're Java programmers and want Java examples
20:55:36 <tabemann> so I'm showing them both
20:55:51 <ahill-89> Could you quietly sneak in a slide about "And this is how much nicer it looks in Haskell"?
20:55:55 <ahill-89> Oh, yes.
20:55:56 <ahill-89> That.
20:56:31 <latermuse> http://www.haskell.org/haskellwiki/Simple_STM_example
20:56:44 <tabemann> I'm wondering if I should make an aside about how horrible write skew is (multiverse is MVCC, haskell STM is log-based)...
20:57:18 <tabemann> nah
20:57:42 <hiptobecubic> mvcc?
20:57:49 <tabemann> multi-version concurrency control
20:57:56 <tabemann> basically what most databases today do
20:58:04 <tabemann> it was introduced in STM by clojure
20:58:18 <carter> clojure stm is mvcc?!
20:58:35 <tabemann> in MVCC you basically take a snapshot of the world at the start of a transaction, and at the end of a transaction only retry them if the *writes* conflict, not reads and writes
20:58:50 <tabemann> carter: yep
20:59:15 <LevelOneDev> Can anyone help explain why this statement is failing? x is an integer and primes is a list of integers
20:59:17 <LevelOneDev> takeWhile (< (sqrt (fromInteger x))) primes
20:59:33 <LevelOneDev> I can't seem to get it to convert from Integer to Float
20:59:47 <tabemann> somehow I'm unsettled by the idea, though, that most databases can have write skew, as I somehow suspect that most SQL coders haven't ever heard of write skew...
21:00:05 <RichyB> tabemann, er- that's if you configure your system for repeatable-read isolation
21:00:48 <RichyB> tabemann, postgresql at least (and I suspect other RDBMSes also) has an isolation level called SERIALIZABLE which prevents write skew too.
21:00:58 <hiptobecubic> latermuse, appV fn x = atomically $ readTVar x >>= writeTVar x . fn
21:01:04 <hiptobecubic> Isn't that "modify" ?
21:01:09 <tabemann> at least Clojure and Multiverse have an "ensure" operation, where one can take a STM-controlled variable and make sure that it has not be modified by the end of the transaction (but you have to do that manually); I'm not aware of anything like "ensure" in SQL...
21:01:14 <hiptobecubic> or is there no modify in the STM monad
21:01:44 <latermuse> hiptobecubic: I dont think there is a modify.
21:02:17 <tabemann> modifyTVar :: TVar a -> (a -> a) -> STM ()
21:02:20 * hackagebot kan-extensions 3.7 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-3.7 (EdwardKmett)
21:02:26 <RichyB> tabemann, I point this out as someone who has introduced a write-skew bug into live production (fortunately no live users ever hit the race condition that triggered it) for a while because I hadn't really cottoned on to the fact that ZODB is repeatable-read, not serializable. :)
21:02:30 <latermuse> for modifying TVars
21:03:09 <tabemann> RichyB: somehow I suspect most database coders aren't aware of the difference between serializable and repeatable-read isolation
21:03:42 <LevelOneDev> Guess I will keep googling
21:04:01 <RichyB> tabemann, get them to write and then have to fix one bug caused by it. :)
21:04:15 <hiptobecubic> what is write skew?
21:05:16 <tabemann> there's the classic "if you have two accounts, whose shared balance must be above a certain value, and you have two transactions, one which deducts money from one account if the sum will be above the limit and the other which does the same but with the other account, and both transactions commit simultaneously, you can get a total balance less than the limit"
21:05:19 <tabemann> that's write skew
21:05:52 <tabemann> in other words
21:06:11 <hiptobecubic> isn't that just... what's the name
21:06:22 <tabemann> you cannot maintain invariants between multiple values in a transaction where not all those values are written, because only written values are checked for conflicts and not read values
21:06:42 <RichyB> hiptobecubic, suppose I have a table orders (part#, destination) and I'm maintaining a second table countOutStandingOrders (part#, int)
21:07:10 <RichyB> oh scratch that, my example is still terrible
21:07:17 <hiptobecubic> i think i get it
21:07:24 <hiptobecubic> but I thought there was another name for this
21:07:37 <ahill-89> LevelOneDev: You're getting a type error from that expression way back there?
21:07:39 <hiptobecubic> when you check a var, then act on it, but there's a gap between the check and action in which it can be modified
21:07:56 <hiptobecubic> which can then invalidate the check and make the action an error
21:08:00 <tabemann> in Clojure and Multiverse you have the workaround that you can explicitly "ensure" specific STM-controlled variables, so that it will be as if they *had* been written except the value isn't changed
21:08:11 <RichyB> tabemann, oh that's nice.
21:08:17 <tabemann> but that still is non-ideal, because you have to do it explicitly as a programmer; the STM impl. won't do it for you
21:08:25 <LevelOneDev> ahill-89: yes
21:08:55 <LevelOneDev> ahill-89: No instance for (Floating Integer) arising from use of sqrt
21:09:16 <ahill-89> So, let's look at the type signature of the things we're using.
21:09:19 <ahill-89> :t (<)
21:09:20 <lambdabot> Ord a => a -> a -> Bool
21:09:25 <hiptobecubic> :t sqrt
21:09:26 <ahill-89> :t sqrt
21:09:26 <lambdabot> Floating a => a -> a
21:09:27 <lambdabot> Floating a => a -> a
21:09:57 <RichyB> hiptobecubic, well, write skew is a specific kind of race condition.
21:09:58 <ahill-89> So (<) expects both of its arguments to be of the same type.
21:10:06 <tabemann> hiptobecubic: that only applies when the check is to multiple variables and not all those variables are being written
21:10:20 <ahill-89> LevelOneDev: And Integer is not an instance of Floating.
21:10:27 <tabemann> if you check a variable, and then write to it, you can't have write skew
21:10:36 <LevelOneDev> Ah, Yeah it's comparing my list of integers to it
21:10:50 <ahill-89> Well, the integers in the list, but yes.
21:11:01 <LevelOneDev> yes
21:11:10 * tabemann wonders if databases have anything like "ensure", and if they do, do database programmers use it
21:11:21 <LevelOneDev> Should I then convert it back to an integer? Or am I just doing this wrong
21:11:29 <hiptobecubic> tabemann, RichyB ok thanks
21:13:12 <ahill-89> LevelOneDev: You can map fromInteger over your list and that will make the types check out.
21:13:25 <LevelOneDev> http://pastebin.com/y7cirLfi ok sounds good
21:13:28 <ahill-89> Whether that's the best thing to do in context, I'm not sure.
21:13:30 <LevelOneDev> This is what I was trying to write
21:13:33 <mauke> The paste y7cirLfi has been copied to http://lpaste.net/91658
21:14:54 <tabemann> you could also do: takeWhile (< (floor (sqrt (fromInteger x)))) primes
21:14:59 <LevelOneDev> Whoops the type signature should be primeFactor :: Integer -> [Integer]
21:15:25 <ahill-89> tabemann's solution is better.
21:16:39 <LevelOneDev> Ok cool. I thought my problem was with sqrt and not <
21:18:29 <LevelOneDev> Thanks for the help guys
21:18:34 <ahill-89> np
21:20:29 <tabemann> the thing I personally find confusing in Haskell is that you *have* to use floor or ceiling to convert from RealFracs to Integrals, being used to just directly casting in C, C++, and Java
21:20:47 <tabemann> so I find myself wondering "why the f will fromRational not give me an Integral..."
21:21:21 <tabemann> but it's probably a good idea in reality; you should have to explicitly choose floor or ceiling for such things
21:21:28 <mauke> or truncate
21:22:15 <sacundim> i can compile my package with cabal-dev but not with Travis CI.  Any well-known pitfalls I shoudl check for?
21:22:20 * hackagebot free-operational 0.4.0.0 - Operational Applicative, Alternative, Monad and MonadPlus from free types.  http://hackage.haskell.org/package/free-operational-0.4.0.0 (LuisCasillas)
21:22:46 <c_wraith> it also makes you very aware of crossing the integral/floating boundary.  Sometimes people do that *way* too freely in C
21:23:20 <blackdog> c_wraith: i remember being amazed that Angband had no floating-point math in it at all
21:23:37 <blackdog> looking back, obviously it didn't really need it, but i was not at all focused on writing minimal code back then.
21:24:05 <tabemann> for many applications, if you don't need *that* much dynamic range, you can get away with fixed point all right
21:24:15 <heatsink> DOOM had no floating-point math
21:24:18 <c_wraith> for some applications, floating point is just wrong..
21:24:20 <carter> c_wraith blackdog  whats this about how the type classes fill me with rage?
21:24:26 <tabemann> yes, it's more painful than floating point, as you have to explicitly manage your decimal point, but it works
21:24:36 <blackdog> carter: hm?
21:25:13 <c_wraith> Like, I remember Quake 3 levels were size-constrained mostly by the *resolution* of float.  You could get lots of detail near the origin, but as you got further away, adjacent float values were *feet* apart in the world scale.
21:25:15 * tabemann remembers when he used a computer, and this was one with a GUI too, which lacked a floating point unit
21:25:16 <carter> blackdog:  we don't have the right standard num classes to support interesting fancy number types
21:25:31 <carter> well, by fancy I mean "simple" or "unusual"
21:25:33 <carter> very well
21:25:43 <Demos> heatsink: well doom had fixed point math, and they likely would have used floating point if not for people's computers being shit
21:25:54 <heatsink> yeah
21:26:08 <tabemann> back when doom came out most people didn't have floating point units, or if they had them they were shitty
21:26:13 <carter> theres still neat hardware out there thats only got saturating or fixed point math
21:26:15 <tabemann> x87 ftw
21:26:23 <c_wraith> 32-bit fixed-point numbers would have served Q3 better than floats did, as world coordinates.
21:26:43 <Demos> but fixed point is a pain
21:26:51 <c_wraith> well.  It's a pain in C
21:27:02 <Demos> true
21:27:02 <tabemann> what's needed is a way to automatic all the decimal point management involved in fixed point
21:27:10 <carter> c_wraith: there a C extension for fixed point
21:27:18 <carter> thats in the  newest standards
21:27:21 <c_wraith> carter: fascinating.  How well supported is it?
21:27:22 <tabemann> i.e. put the decimal point position in the type, and automatically change it for the resulting types based on the input types
21:27:28 <carter> c_wraith wait till it lands
21:27:30 <carter> its not there yet
21:27:33 <carter> as in
21:27:46 <carter> clang folks only started putting C11 in clang head I hear
21:27:47 <c_wraith> oh.  so "it may be there in a few years.  It wasn't available back then." :)
21:28:15 * tabemann remembers when he programmed without templates in C++ because he didn't trust the compiler to properly support them
21:29:11 <tabemann> I'd probably wait half a decade until anything new can be trusted to be implemented properly
21:29:32 <tabemann> across multiple platforms
21:30:04 * tabemann was working not to long ago with a C compiler that didn't support C99!
21:30:11 <tabemann> s/to/too
21:30:17 <Demos> was it mdvc :D
21:30:22 <Demos> *msvc :D
21:30:36 <tabemann> it was the C compiler used with OS-9 (I mean OS-9, not Mac OS 9)
21:30:37 <TIHan> https://github.com/TIHan/FQuake3
21:30:47 <carter> dman, i thought i had one of the papers
21:31:38 <sacundim> whoah, somebody knows about OS-9
21:31:47 <tabemann> but the company I was working with was writing their own device drivers for OS-9, because no one was writing device drivers for it anymore yet they were stuck with their entire shop floor process being based on OS-9
21:33:37 <carter> FOUND IT http://www.open-std.org/JTC1/SC22/WG14/www/projects#18037
21:33:40 <carter> http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1169.pdf
21:36:05 <carter> c_wraith this may all be in some part of c11 or something
21:36:06 <carter> idk
21:36:08 <carter> need to read more
21:37:09 <RichyB> c_wraith, the ease of accidentally converting between float and int in C amuses me a little, given that float<->int conversion used to apparently be really really slow on x86 chips.
21:37:29 <RichyB> I'm talking, like, Pentium 1 era here, but still.
21:39:05 <c_wraith> I'm pretty sure my first computer preceded the x86 era. :)
21:39:15 * tabemann 's first computer ran on a 6502
21:39:54 <tabemann> seconds on a 68030
21:40:02 <tabemann> second*
21:40:22 <carter> RichyB : theres still a multi cycle cost
21:40:48 <blackdog> carter: my first was a lovely little 8088 XT. man, i loved that thing.
21:41:02 <blackdog> whoops, meant that to be directed at c_wraith. DYAC.
21:43:15 <RichyB> carter, meh, gets blown away dozens of times over by one L2 miss.
21:43:24 <carter> true
21:43:35 <carter> otoh, i'm competing against BLAS  in my use cases
21:43:44 <RichyB> ah yes that would do i
21:44:01 <carter> granted, thats still noise relatively because its still l1/l2 transfer bounded
21:46:55 <jnhnum1_> what does it mean that <*> for Applicative functors "sequences computations"?  I understand that it combines results, but I don't know how the laws imply any sort of ordering on evaluation
21:47:30 <carter> jnhnum1_; easy example, parsers!
21:47:50 <carter> like
21:47:57 <jnhnum1_> ok, so that's an example which utilizes the fact that it sequences computations
21:48:16 <carter> with *only applicative*
21:48:21 <carter> you can only parse tuples I think
21:48:28 <carter> or recursions thereof
21:48:29 <carter> ish
21:48:32 <carter> thats not quite true
21:48:34 <carter> ignore me i'm tired
21:48:39 <carter> you're asking a good question though
21:48:44 <carter> albeit at 1am
21:48:49 <carter> (at least fo rme)
21:48:51 <jnhnum1_> haha west coast over here
21:49:02 <carter> <shakes fist>
21:49:52 <carter> the honest answer is applicative is simpler than a monad
21:49:55 <maxiepoo> jnhnum1_: well do you understand how monads sequence computations (just trying to get more context)
21:50:13 <carter> maxiepoo thats a different sequencing....
21:50:21 <maxiepoo> yeah
21:50:36 <maxiepoo> I just want to know where jnhnum1_ is coming from
21:50:36 <carter> @src Applicative
21:50:37 <lambdabot> class Functor f => Applicative f where
21:50:37 <lambdabot>     pure  :: a -> f a
21:50:37 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
21:50:49 <jnhnum1_> maxiepoo: yeah I think so, although in a somewhat fuzzy sense
21:51:03 <carter> jnhnum1_: so what you may be missing
21:51:08 <carter> is that applicative doesn't say what ordering
21:51:17 <carter> errm
21:51:36 <jnhnum1_> oh I see
21:51:43 <carter> don't hold me to that
21:51:46 <jnhnum1_> (I think)
21:51:46 <carter> i could be wrongish
21:51:56 <carter> actualy lets work this out
21:52:06 <carter> wheres typeclassopedia again?
21:52:14 <carter> www.haskell.org/haskellwiki/Typeclassopedia
21:52:41 <maxiepoo> the key difference between an applicative and a monad
21:52:53 <carter> is that the effects are "indepdent"
21:53:06 <maxiepoo> is that you can't generally use the "result" of an applicative to determine the next computation
21:53:18 <carter> maxiepoo: you can't period
21:53:34 <maxiepoo> well you can if it's also a monad
21:53:37 <carter> yes
21:53:44 <carter> sorry
21:53:55 <carter> on pedantic=11 mode
21:53:59 <maxiepoo> haha
21:54:21 <carter> u <*> pure y = pure ($ y) <*> u
21:54:30 <maxiepoo> but yeah so you can sequence a bunch of applicative computations
21:54:30 <carter> is the "doesn't matter what order you do it"
21:54:41 <maxiepoo> and combine them in a pure way
21:54:50 <sacundim> the applicative interface does not allow you to choose later actions based on the results of earlier ones, i think might be the pedantic=12 statement
21:54:50 <carter> yes
21:55:06 <carter> yes
21:55:09 <carter> its not eval
21:55:16 <carter> monads have the power of eval
21:55:32 <carter> which also means libraries with monadic interfaces can't do neat runtime optimization crazies
21:55:33 <carter> as much
21:55:40 <maxiepoo> parsers are a good example
21:55:42 <carter> yup
21:55:58 <carter> theres REALLY cool things you can do with a parser thats not monadic
21:56:19 <sacundim> like enumerate the strings it accepts
21:56:35 <carter> in some breadthfirst way, yeah
21:57:42 <jnhnum1_> hmm ok so carter, the law you mentioned basically says that the order doesn't matter for pure functions
21:57:47 <carter> yes
21:57:55 <jnhnum1_> but obviously for applicative parsers the order in which you parse things matters
21:57:58 <carter> yes
21:58:06 <carter> every applicative has AN order for the effects
21:59:06 <carter> so every applicative has primops
21:59:07 <jnhnum1_> I guess another way of saying that the order doesn't matter for pure functions is just that pure functions have no effects, so it doesn't matter when that lack of effects happens
21:59:19 <carter> yes
21:59:22 <maxiepoo> right
21:59:26 <carter> you can only combine them with "pure" operations
21:59:34 <sacundim> applicative is basically a heterogeneous list of actions, with a function as its tail to combine their results
21:59:58 <carter> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
22:01:08 <carter> relatedly: whose the lurker named applicative ? :)
22:02:12 <maxiepoo> not to bombard you with links but this is a pretty clear formulation of how applicatives are equivalent to just accumulating effectual results: http://blog.ezyang.com/2012/08/applicative-functors/
22:02:33 <jnhnum1_> oh cool I will read that
22:02:40 <jnhnum1_> ezyang is pretty good at explaining things
22:03:09 <carter> i'm terrible at explainign things
22:03:29 <hpaste> sacundim pasted “Free(ish) applicative type” at http://lpaste.net/91659
22:03:41 <carter> yeah
22:03:48 <maxiepoo> and I've found when writing my own applicative instances sometimes it's more intuitive to figure out how the "Monoidal" functions would be written
22:03:48 <carter> theres no "canonical order"
22:04:00 <maxiepoo> similar to my experience with Monads and join vs (>>=)
22:06:09 <dpwright> I have some code which uses System.Win32.DLL, and I'm attempting to debug it by putting some prints in
22:06:40 <maxiepoo> Debug.Trace?
22:06:47 <dpwright> for example, I have this function: "shutdownHandle h = print "hello" >> getLine >> freeLibrary h"
22:07:02 <carter> unsafePerformIO $! putStrinLn "halp"
22:07:10 <carter> oh
22:07:12 <dpwright> that function is in the IO monad anyway, so I figured just print would be ok..
22:07:16 <carter> yup
22:07:17 <carter> :)
22:07:18 <dpwright> but
22:07:28 <dpwright> "hello" doesn't get printed
22:07:28 <carter> i was making a bad joke
22:07:39 <carter> did you try doing it in do notation?
22:08:05 <maxiepoo> ah
22:08:11 <maxiepoo> does it print if you press enter?
22:08:15 <dpwright> but it is doing the getLine, because it just stops until I press enter, at which point it crashes with a segmentation fault (which is the problem I'm trying to debug)
22:08:34 <dpwright> it might, if freeLibrary didn't crash it :-)
22:09:23 <dpwright> carter: I haven't tried do notation, I could give that a try... doesn't that resolve to basically the same thing though?
22:10:18 <dpwright> carter: Just tried it... exactly the same
22:10:36 <carter> ok
22:10:38 <maxiepoo> http://hackage.haskell.org/packages/archive/base/4.2.0.0/doc/html/System-IO.html#v%3AhFlush to flush stdout but I doubt that will help you since it seems the bug is in freeLibrary
22:10:45 <carter> i'm tired so i may make bad suggestions :)
22:10:50 <carter> night all
22:12:10 <dpwright> night :-)
22:13:01 <dpwright> maxiepoo: Thanks -- tried that, and it worked... a load of my printout got printed out before I got an error "hFlush: illegal operation (handle is not open for writing)"
22:13:33 <dpwright> I wonder if that's related to its not flushing
22:14:46 <maxiepoo> not flushing is the normal behavior, it's irritated me when writing repls
22:15:26 <dpwright> mmm, that is a bit annoying... but I guess I can make a little "print and flush" helper to solve that
22:15:43 <maxiepoo> yeah it's a whole lazy IO thing...
22:16:02 <stacky> if your handle is LineBuffered then shouldn't print flush automatically?
22:16:07 <dpwright> I wonder why the stdout "handle is not open" thing is happening
22:16:12 <dpwright> oh wait, silly me
22:16:16 <dpwright> I flushed the wrong handle
22:16:20 <stacky> haha
22:16:59 <dpwright> can get in a lot of trouble doing that in a japanese toilet...
22:17:29 <dpwright> ooook... that's interesting
22:18:21 <dpwright> my printouts print
22:18:27 <dpwright> and... the crash has gone away
22:18:42 <maxiepoo> uh
22:18:57 <maxiepoo> congrats?
22:19:08 <dpwright> \o/
22:19:56 <dpwright> thanks everyone!
22:20:03 <dpwright> be even better if I understood
22:20:22 <dpwright> oh wait
22:20:34 <dpwright> I'm on a roll today
22:21:07 <dpwright> forgot about the getLine I put in
22:21:30 <dpwright> ok, thanks!  I have working printouts now so I can look into the crash a bit more
22:21:44 <stacky> good job dpwright, you're my best friend!
22:22:02 <maxiepoo> oh hai doggy
22:40:32 <sacundim> edwardk: you've been on a renaming spree, huh
22:47:22 * hackagebot free-operational 0.5.0.0 - Operational Applicative, Alternative, Monad and MonadPlus from free types.  http://hackage.haskell.org/package/free-operational-0.5.0.0 (LuisCasillas)
23:02:20 <edwardk> sacundim: decided i'd go through and correct the worst of my old mistakes
23:02:22 * hackagebot bindings-posix 1.2.4 - Low level bindings to posix.  http://hackage.haskell.org/package/bindings-posix-1.2.4 (MauricioAntunes)
23:07:20 <sgk284> Can anyone here point me to a sample usage of the Writer Monad? I've looked at RWH, All About Monads, and a bunch of other places and can't seem to find a fully functioning example from start to finish. I can't figure out how to use this monad
23:07:22 * hackagebot bindings-posix 1.2.5 - Low level bindings to posix.  http://hackage.haskell.org/package/bindings-posix-1.2.5 (MauricioAntunes)
23:07:48 <sgk284> just need a way to extract a value from the monad, do a computation, store a log line, and return the value... was hoping it'd be simple
23:08:02 <sgk284> :currently, I'm manually munging tuples
23:09:25 <maxiepoo> what do you mean by fully functioning example? A sample usage or declaration?
23:09:39 <roboguy_> sgk284: did you look at the lyah example?
23:10:28 <sgk284> maxiepoo: like from start to finish, with a main method
23:10:54 <sgk284> most provide a minimal function, but no way to run it. perhaps I'm approaching it all wrong
23:11:18 <roboguy_> maybe runWriter is what you want?
23:11:30 <sgk284> just confused, and an example that I can load into ghci, type 'main' <cr> that shows how to extract a value, set a value and append a log line is all I'm really lookign for :)
23:12:30 <sgk284> yea, I think that's what I want... but can't figure out how to use it. It takes a `Writer w a` as it's only argument
23:12:36 <sgk284> but I have a function that I want to run...
23:13:17 <sgk284> I'd expect it to take the intial state and a function and return a new state (or a tuple in this case)
23:13:31 <sgk284> but I'm kind of new to haskell so just trying to wrap my head around it
23:13:33 <roboguy_> sgk284: apply the function and use runWriter on that
23:13:46 <maxiepoo> ah
23:14:28 <maxiepoo> the "writing" type that you use has to be a monoid
23:14:31 <startling> sgk284, Writer doesn't do any state
23:14:44 <maxiepoo> that's why you don't need an "initial state"
23:14:53 <sgk284> oh, so maybe that's where I'm getting confused. Trying to treat it like the State Monad but with the addition of 'tell'
23:15:13 <startling> sgk284, nope. all it has is "tell"
23:15:23 <startling> :t runWriter
23:15:25 <lambdabot> Writer w a -> (a, w)
23:15:47 <sgk284> If it only has tell, what's the second type parameter for?
23:15:55 <startling> :t tell "hello, world"
23:15:55 <lambdabot> MonadWriter [Char] m => m ()
23:16:18 <startling> > runWriter ( tell "hello, world!" >> tell "goodbye...")
23:16:19 <lambdabot>   ((),"hello, world!goodbye...")
23:16:53 <zvrba> what is the status of 64-bit ghc for windows?
23:16:56 <sgk284> ah.... I think that makes more sense
23:17:05 <sgk284> thank you startling maxiepoo roboguy_
23:17:21 <sgk284> I'll dig back into it and see if I can make something work now
23:17:22 * hackagebot bindings-posix 1.2.6 - Low level bindings to posix.  http://hackage.haskell.org/package/bindings-posix-1.2.6 (MauricioAntunes)
23:17:23 <startling> sgk284, execWriter is also useful
23:17:29 <twoolie> sgk284: if you want logging, perhaps using the LoggingT monad transformer on top of state?
23:17:39 <startling> > execWriter (tell "hello, world!" >> tell "goodbye...")
23:17:40 <lambdabot>   "hello, world!goodbye..."
23:17:59 <sgk284> yea, I was confused because I understand runState and assumed runWriter was similar
23:18:27 <maxiepoo> it is similar
23:18:27 <sgk284> I'll look into LogginT too, thanks twoolie
23:18:44 <maxiepoo> > execWriter (Sum 3 >> Sum 5)
23:18:45 <lambdabot>   Couldn't match type `Data.Monoid.Sum'
23:18:45 <lambdabot>                with `Control.Monad.Tr...
23:19:12 <maxiepoo> > execWriter ((tell $ Sum 3) >> (tell $ Sum 5))
23:19:13 <lambdabot>   Sum {getSum = 8}
23:19:31 <twoolie> sgk284: http://hackage.haskell.org/packages/archive/monad-logger/0.2.3.2/
23:20:15 <sgk284> thanks
23:21:26 <twoolie> actually, this would be a better link http://hackage.haskell.org/package/monad-logger
23:47:28 * hackagebot fay 0.16.0.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.16.0.1 (AdamBergmark)
