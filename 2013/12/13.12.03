00:01:15 <dp_wiz> mzero: uhm.. it has only "default: False" and "description: ..." lines. Like the aeson package wich is obviously is on hackage.
00:02:24 <mzero> you may need manual: False
00:02:44 <mzero> without that, cabal can explore if turning on the flag will allow the code to install in a given situation
00:03:05 <mzero> with it, then the flag becomes only something at the user's descretion
00:04:07 <mzero> mind you, I don't know if Hackage2 takes that into account ---- but without it, cabal could try turning on that flag, and hence -fhpc, for some poor unsuspecting user
00:04:10 <radish> mzero: can't recreate the bug, must be my code!
00:04:19 <radish> but /where/??
00:04:24 <mzero> post the code?
00:04:51 <dp_wiz> mzero: doesn't change anything..
00:04:52 <radish> mzero: i'm trying to post just the relevant bits but somehow i can't recreate it...
00:05:14 <mzero> also be clear, if you write     fn = newMvar 1     -- then later use fn in two places.... you'll get two MVars, not one
00:06:53 <radish> mzero: yes i know, but the return of one of those calls should be the same mvar if i pass it around, yes?
00:07:19 <radish> mzero: oh snap i should probably be careful to make sure to use <- at least once before i pass that around lol
00:07:45 <mzero> EXACTLY! that is just what I was going to warn you of
00:08:23 <mzero> otherwise you are passing around an    IO (MVar a)    -- a computation to create a new MVar.... a perfectly nice thing to do, but not what you were after
00:08:28 <dp_wiz> mzero: solved by moving -fhpc from ghc-options to ghc-prof-options. P.S.: "400 bad request isn't exactly helpful when uploading packages..."
00:08:44 <mzero> file that bug at Hackage2!
00:09:27 <mzero> (aside: I love getting people to see that     Map String (IO ())    is a perfectly good way to manage a command table!
00:09:33 <radish> side note, i first came upon that problem playing with designing my own language - i was aghast at the notion of a difference between doing something, and talking about doing something ;)
00:09:40 * hackagebot hedn 0.1.8.1 - EDN parsing and encoding  http://hackage.haskell.org/package/hedn-0.1.8.1 (AlexanderBondarenko)
00:12:23 <c_wraith> radish: isn't that the difference between a function pointer and a function call, though, from the right viewpoint?
00:13:13 * hackagebot rmonad 0.8.0.1 - Restricted monad library  http://hackage.haskell.org/package/rmonad-0.8.0.1 (GaneshSittampalam)
00:13:13 * hackagebot hedn 0.1.8.1 - EDN parsing and encoding  http://hackage.haskell.org/package/hedn-0.1.8.1 (AlexanderBondarenko)
00:16:26 <radish> c_wraith: i guess so, but if you obfuscate that kind of stuff it gets fuzzy. which is a good thing in some cases but obviously not all. anyway, its kind of a big breakthrough that got me to understand haskell's notion of IO when i was starting out.
00:16:53 <klrr_> is litecoinpool good if i do small mining? (i have 64ish ksh) or is there a better one for me then? i also dont plan to mine 24/7 but only on the day
00:17:21 <radish> klrr_: try haskell-blah
00:17:41 <klrr_> ups wrong channel sry!
00:18:03 <klrr_> (though i was in #litecoin, did not notice that i switched channel)
00:18:51 <radish> klrr_: no worried :)
00:19:00 <radish> klrr_: no worries* :)
00:34:13 <radish> okay i pasted it
00:34:28 <radish> has to do with passing the mvar out
00:34:57 <radish> oh shoot no never mind i screwed it up again
00:42:27 <roboguy_> Hmm, the Control.Comonad package doesn't seem to have a NonEmpty instance but I definitely see it in the Hackage page. Any ideas?
00:43:24 <roboguy_> In fact, when I try :i Comonad, the only instances it lists are the "Monoid m => ((->) m)" instance and the "((,) e)" instance
00:45:43 <shachaf> Where did you look for it?
00:45:44 <shachaf> I see it.
00:47:41 <roboguy_> shachaf: well, I mean there must be something weird going on with my installation. When I try :i Comonad in ghci it doesn't list it. also it won't let me do "extract (1 :| [])" because it says there isn't a NonEmpty Comonad instance
00:47:59 <shachaf> I see it at http://hackage.haskell.org/package/comonad-4.0/docs/src/Control-Comonad.html#line-167
00:48:12 <shachaf> Perhaps it is a version issue. Or a scope issue. Who knows.
00:49:20 <roboguy_> shachaf: yeah I saw that too. Very frustrating. Do you know if there is some other package that provides Control.Comonad that I might be importing instead?
00:49:51 <roboguy_> cabal says I have comonad versions 3.1 and 4.0 installed (both provide NonEmpty instances)...
00:50:53 <shachaf> Uh oh, that sounds like a bad idea.
00:51:17 <shachaf> Maybe you're importing things from two packages that expect different versions of things.
00:51:24 <radish> is there a regular array library that isn't as confusing as repa?
00:51:37 <arkeet> like array?
00:51:41 <arkeet> or vector
00:51:47 <radish> i don't like vector
00:51:52 <arkeet> :(
00:51:55 <radish> it confuses me
00:52:07 <radish> its simpler but actually working with it is a hassle
00:52:14 <arkeet> you should work on not getting confused by things
00:52:21 <roboguy_> shachaf: Do you know a way to see which package and package version I'm importing Control.Comonad from?
00:53:30 <radish> map (\y-> fromList (map (\x-> fromList.fn x y) [1..10]) [1..10]
00:53:36 <radish> no thanks
00:53:45 <radish> and its not even regular
00:53:50 <radish> :(
00:54:09 <radish> array uses tuples to ensure regularness yes?
00:54:40 <c_wraith> I have never written vector code that looks like that
00:55:08 <radish> c_wraith: maybe i should work on not confusing myself! :D
00:55:21 <radish> c_wraith show me that example the way you would write it
00:57:25 <c_wraith> Well, first..  if you want a multidimensional array, vector isn't a good choice, unless you want to do the index mapping manually.
00:57:47 <c_wraith> and doing the index mapping manually is *way* better than creating a vector of vectors.
00:58:14 <c_wraith> (you can even use the Ix functions for it, if you like)
00:59:56 <radish> c_wraith: thats kind of where i find myself now lol
01:00:14 <radish> c_wraith: what would you suggest i do?
01:00:32 <c_wraith> At a first pass, use Array unless there's something specifically wrong with it
01:01:02 <radish> c_wraith: i read somewhere that it's outdated or something
01:01:39 <radish> c_wraith: i think it's on the array page with the standard tutorial, you know? can't recall that site's name but everything is up there 1 sec
01:02:53 <c_wraith> eh.  It doesn't have the best performance, but if you want complicated indexing, it's still got the friendliest interface.
01:03:27 <radish> c_wraith: dude, thank you. hero for the day.
01:03:47 <radish> c_wraith: been at this thing all week and its just one thing after another but you know how it does.
01:33:36 <arkeet> ocharles: I watched your lhug pipes talk. it was good.
01:33:38 <arkeet> :)
01:37:15 <identity> Why does cabal repl only configure my library but not open an interpreter session for it?
01:38:20 <jle`> identity: hm. does it just exit?
01:38:27 * hackagebot iCalendar 0.3.0.1 - iCalendar data types, parser, and printer.  http://hackage.haskell.org/package/iCalendar-0.3.0.1 (ChristianRoedliAmble)
01:38:35 <identity> jle`: Yep. just configures the library and does nothing else
01:38:41 <identity> wait -- I may have yet to set source dirs, actually
01:39:08 <identity> well, that didn't change anything
01:39:36 <jle`> huh.
01:39:55 <jle`> do you happen to have a public repo of your project directory
01:40:23 <jle`> actually don't post it for me, i would likely not be able to answer you
01:40:32 <jle`> but others might be able to
01:40:41 <identity> jle`: oh, no. nothing like that yet. I just started writing the code
01:40:50 <identity> just a toy project really
01:41:05 <jle`> did you initialize the sandbox?
01:41:27 <identity> yep
01:43:03 <Feuerbach> try running it with -v/-v3, might give you some insight
01:45:25 <identity> Hmm. Tells me very little. Just some random debugging information .. creating dist/build, etc, then linking.. and nothing.
01:45:54 <Feuerbach> could you paste the whole output?
01:46:17 <identity> sure. sec.
01:47:02 <identity> http://paste.ubuntu.com/6513604
01:48:23 <Feuerbach> what cabal version is it? what's the exit code?
01:51:12 <identity> Feuerbach: v 1.18.0.2 and exit code seems to be 0
01:57:44 <Feuerbach> does it work in a different directory, for a different project, without a sandbox?
02:00:02 <identity> Feuerbach: indeed it seems to work yes
02:01:15 <Feuerbach> now bisect it to determine what exactly causes the problem. Is it the sandbox, the project, this particular directory?
02:03:01 <identity> Feuerbach: I appreciate your help, but it's really not an issue at this point really. Or rather, I can't really be bothered looking into this quite right now
02:04:59 <Feuerbach> okay then
02:35:59 <tarruda> whats the most current way to manage multiple ghc databases? I just tried to install hsenv but it fails
02:36:38 <Feuerbach> that would be cabal sandboxes
02:38:38 <tarruda> Feuerbach: I see it requires cabal 1.18 which is not the version that comes with haskell-platform
02:38:44 <tarruda> how can I upgrade cabal?
02:39:13 <tarruda> nevermind
02:39:16 <tarruda> thanks
02:43:40 * hackagebot process 1.2.0.0 - Process libraries  http://hackage.haskell.org/package/process-1.2.0.0 (HerbertValerioRiedel)
02:46:39 <BoR0> can anyone help me with setXY http://lpaste.net/96514, I don't have an idea of how to implement it
02:47:11 <identity> BoR0: You almost definitely do not want to use lists for this kind of thing.
02:47:38 <identity> they are incredibly inefficient(and awkward to use) for updates
02:47:58 <BoR0> okay, what should I use? I want to use something from scratch because I want to learn more
02:48:14 <identity> You could use Arrays, for example.
02:48:20 <identity> Mutable ones, for best efficiency
02:48:29 <identity> I think vectors can do more than one dimensions as well
02:49:05 <BoR0> what are Arrays? can I implement it easily without using any already defined data structure
02:49:49 <identity> BoR0: Arrays are in base AFAIK.
02:50:06 <identity> BoR0: and.. well, no, probably not.
02:50:08 <identity> not efficiently
02:50:08 <Hafydd> Unless the update happens to be prepending items to the list.
02:50:15 <BoR0> what do they use in background? pairs?
02:50:33 <identity> BoR0: I really don't know. Probably some rather low level stuff
02:50:41 <identity> like C arrays or some such
02:50:51 <BoR0> oh, I see. so there is no easy way to implement arrays barebones?
02:51:26 <Hafydd> There's a way to implement an array-like tree, which you seem to have in mind.
02:51:39 <identity> Theta(1) random access and updates, no, not easily.
02:51:42 <BoR0> hmm, I see, that could work
02:51:43 <identity> you can do trees, yes.
02:51:51 <dcoutts_> BoR0: arrays with O(1) indexing have to be provided by the implementation, since there's no way to implement that directly using ordinary data types
02:52:16 <BoR0> I am not interested in performance atm, I just want to learn how to implement them first in Haskell. I already know how to do it in C
02:52:32 <identity> BoR0: In that case, you could just stick with lists, though they will be awkward to use
02:52:34 <Hafydd> You know how to implement arrays in C!? Incredible.
02:52:48 <identity> Hafydd: I think he's referring to Matrices
02:52:59 <BoR0> Hafydd, not incredible. I just wanted to point out that I have a sense of matrices in imperative like languages.
02:54:07 <Hafydd> There's an array package that uses type-level natural numbers to allow matrix operations to be statically checked, I believe.
02:54:15 <Hafydd> Er, a matrix package, I mean.
02:54:24 <dcoutts_> BoR0: so what is it you want to do exactly?
02:54:30 <identity> BoR0: for your list implementation, you could implement it in terms of splitAt I guess
02:54:36 <BoR0> dcoutts_, for fun I want to implement game of life
02:54:50 <identity> BoR0: oh, you should have said that, then.
02:55:03 <dcoutts_> BoR0: ok, and you're happy to use ordinary Haskell arrays?
02:55:17 <Hafydd> STArrays seem ideally suited for something like a cellular automaton.
02:55:30 <identity> BoR0: In that case, you may want to consider thinking about a different way to represent the grid, instead of using matrices as you would in imperative languages
02:55:39 <BoR0> well, I want to learn in general how to represent matrices in Haskell, that's my first plan. game of life is just a test
02:55:46 <identity> oh.
02:55:50 <BoR0> identity, aha, what would that be then?
02:56:10 <BoR0> will array like trees work for that case?
02:56:11 <dcoutts_> actually pure arrays are fine for game of life, produce a whole new grid on each iteration
02:56:37 <dcoutts_> it's only if you want to implement the optimisation where you only update some cells that you need to use a mutable array
02:56:58 <identity> BoR0: Well, there are several ways to do it. In reality, you could just maintain some data-structure containing coordinates of living cells and so on
02:57:25 <BoR0> I see, so a pair (list of pairs) would do it maybe?
02:57:28 <dcoutts_> BoR0: why not just a 2d array of cells?
02:57:44 <BoR0> dcoutts_, that's what I want to represent, somehow :D
02:57:50 <dcoutts_> ok, do it directly!
02:57:55 <dcoutts_> Array (Int, Int) Cell
02:58:11 <dcoutts_> gameStep :: Array (Int, Int) Cell -> Array (Int, Int) Cell
02:58:29 <Hafydd> I don't know why they call Conway's Game of Life a game.
02:58:32 <BoR0> I don't understand that notation Array (Int, Int) Cell
02:58:46 <identity> BoR0: Array is the data type I mentioned before
02:58:56 <dcoutts_> http://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array.html
02:59:27 <dcoutts_> BoR0: it's not special notation as such, Array is a type, it has two type parameters: the index type and the element type
02:59:31 <BoR0> oh, okay. but if I were to not use any package, what way would you pick? list of lists, list of tuples?
02:59:50 <dcoutts_> BoR0: a 1d array has index type Int, a 2d array has index type (Int, Int), etc ...
03:00:11 <lykos_> I'm learning how to use cabal (I'm using EclipseFP), and I'm trying to figure out how I would best use recources. For example, I have a .jpg that my current code loads, and that my binary finds in it's current directory when running. How would I abstract this to work with cabal?
03:00:17 <dcoutts_> BoR0: and array, really, it's the clearest for what you're doing
03:00:21 <dcoutts_> and/an
03:00:30 <Hafydd> Data.Array isn't a "package" as you're thinking. It's in Haskell2010's standard library: http://www.haskell.org/onlinereport/haskell2010/haskellch14.html#x22-20100014
03:00:45 <dcoutts_> Hafydd: it is a package, the array package.
03:00:54 <dcoutts_> the one I just linked to
03:01:16 <Hafydd> I know that it is a package.
03:01:54 <dcoutts_> oh Data.Array, sorry, wasn't sure which hairs we were splitting :-)
03:02:02 <Hafydd> It's a package in the same sense that base is a package.
03:02:15 <BoR0> so basically Array is implemented in C, just like say Int is? and there is no elegant way to implement arrays in pure haskell without using any packages?
03:02:34 <dcoutts_> BoR0: not if you want O(1) lookups
03:02:54 <BoR0> okay, and what if performance was not so important to me? list of lists, list of tuples, array-like trees or something else?
03:02:57 <tovarish> BoR0, no because modifyting an array has side effect
03:03:00 <dcoutts_> BoR0: you can do a Map (Int, Int) a, and get O(log n) lookup and update
03:03:10 <tovarish> so that must be hidden under a black box monad
03:03:29 <dcoutts_> BoR0: but here's the thing to notice: you do not need mutation!
03:03:43 <identity> BoR0: This is what I was referring to before. Unless you do want to use these black magic arrays, you are forced to resort to thinking about other ways to represent your data
03:04:00 <dcoutts_> BoR0: the standard way to implement a cell game is not to use array mutation. You just construct a new game grid from the old one.
03:04:17 <dcoutts_> BoR0: so if you're trying to learn a functional style, do this.
03:04:20 <Hafydd> Or, using a tree-like structure, only part of it.
03:04:30 <identity> Using the same mindset you use when doing imperative programming for implementing data structures for some problems will not get you far, because of the differences of imperative languages that have mutable data and free side effects and a pure functional language
03:05:12 <BoR0> okay, this conversation already helps me. so, if I want to implement setXY the way I started, I would need to construct a new list from the old one that includes the modifications?
03:05:16 <dcoutts_> BoR0: I'd say that using immutable arrays is more of a functional approach than if you use a Map or something and use it by doing incremental updates as you would by modifying an array in C.
03:05:20 <identity> BoR0: yes.
03:05:36 <dcoutts_> BoR0: so you need to discard the notion of setXY completely
03:05:59 <dcoutts_> think in terms of constructing the entire next game grid, based on the current one
03:06:19 <BoR0> so, with game of life, I don't have set/get, I only have step?
03:06:26 <dcoutts_> right
03:06:32 <dcoutts_> gameStep :: Array (Int, Int) Cell -> Array (Int, Int) Cell
03:06:58 <dcoutts_> BoR0: well, you have get, not set
03:07:15 <dcoutts_> BoR0: look at the functions available for constructing an array, all in one go.
03:07:20 <dcoutts_> http://www.haskell.org/onlinereport/haskell2010/haskellch14.html#x22-20100014
03:07:51 <dcoutts_> but once constructed, you don't get to modify it
03:08:50 <dcoutts_> BoR0: so you must think of it in terms of constructing the whole grid, not in terms of modifying individual cells of an existing grid.
03:09:04 <BoR0> I see, okay, great. thanks for the guidelines. I'll try and do it with Array
03:09:10 <dcoutts_> good luck!
03:13:53 <cinimod> I wanted to comment on an old haskell reddit
03:14:21 <cinimod> But there are no boxes for comments like I see on new haskell reddits
03:14:41 <dv-> older posts are archived
03:15:20 <cinimod> dv-: what is the protocol / etiquette then? Do I re-reddit?
03:16:23 <dv-> that would work
03:16:53 <cinimod> Any ideas on what I should do?
03:18:31 <cinimod> It seems one cannot contact the author of a comment on reddit either
03:19:25 <dv-> there are private messages on reddit
03:19:34 <cinimod> Oh sorry I misread that as would *not* work
03:20:03 <cinimod> Ah a private message is probably better in this case
03:22:42 <identity> when using cabal sandboxes.. do the dependencies have to be installed into the sandbox even though they are installed globally?
03:27:38 <cinimod> No
03:29:04 <cinimod> dv-: I have sent a private message - thanks for the off topic help
03:53:34 <danilo2> Hello! Is this a bug or am I missing a feature? When I'm installing libraries with cabal I can set my custom packaggeDB's paths (with --package-db and simmilar flags), but I cannot use these flags to list packages, so ... I'm unable to list packges in custom DB's?
03:55:36 <dcoutts_> danilo2: you mean with cabal list? yes, I think that is indeed a missing feature
03:55:42 <dcoutts_> you can still use ghc-pkg list/describe
03:56:14 <dcoutts_> danilo2: note that you can use ghc-pkg field blah category
03:57:53 <danilo2> dcoutts_: Hmm so whats the difference between cabal list and ghc-pkg list? I'm asking because I want to connect to some api and list packages with more options than currently possible
03:58:22 <danilo2> dcoutts_: We were tlaking couple of days ago about it 0 graphicaly displaying packages - but I had to do another thinks and now I'm, back to this task
03:58:46 <dcoutts_> danilo2: try it, see ghc-pkg list [--simple-output] and e.g. ghc-pkg describe base
03:59:09 <dcoutts_> ghc-pkg has a more machine oriented interface (cabal itself uses it)
03:59:33 <danilo2> dcoutts_: I see, that Cabal-install has got inside some new data structures (like: PackageDisplayInfo) so it has to provide some "nicer" results than clean GHC API
04:00:07 <danilo2> dcoutts_: I suppose this structure has got fields like "available versions" etc - so If I would use clean GHC API I would need to define it by myself - I prefer to use ready one in this case :)
04:00:49 <dcoutts_> danilo2: ghc-pkg only deals with installed packages
04:01:32 <danilo2> dcoutts_: Ou - so I need to stick with cabal-install in this case :) Thank you very much. Anyway I filled a bug about missing options in "cabal list" on the github :)
04:01:51 <dcoutts_> danilo2: it'll get fixed if you send a patch :-)
04:05:35 <danilo2> dcoutts_: heh ... I do not like your argument parsing way (you know why and I know why it has to be implemented like it is), but ok, I'll do it, but noit now and I do not think today - but until weekend it should be done unless something bad happens to me :P
04:14:38 <akegalj_> how to implement repeatM :: Monad m => m a -> m [a] ?
04:14:54 <akegalj_> is it posible or only for lazy monads?
04:15:19 <danilo2> dcoutts: Ok I've got a question: I do not see any word about "--package-db" in Setup.hs (there is plenty of options for all the commands). I've searched the whole cabal-install and such otpion is nowhere defined there
04:15:22 <merijn> akegalj_: You can implement it for any monad, but it will never return for some of them
04:15:42 <danilo2> dcoutts: It is defined in Cabal library, but how is it displayed in cabal-install "--help" command?
04:16:15 <akegalj_> merijn: thnx. i thouht it was like that
04:16:57 <merijn> akegalj_: Doesn't mean it'll be useless, you might want an infinite loop in IO, for example. Although it'd make more sense to use forever rather than repeatM in that case
04:17:39 <danilo2> dcoutts: Ok I've got it - it is imported from Cabal library, thank you :)
04:17:42 <frxx> repeatM = sequence . repeat
04:27:32 <akegalj_> frxx: that ends with a stack overflow
04:28:09 <frxx> what did you pass?  try repeatM (print 10)
04:32:03 <mm_freak> repeatM does not work in IO
04:32:51 <mm_freak> in fact i can't think of a nontrivial monad in which it does
04:33:06 <mm_freak> except perhaps Writer
04:33:37 <hpc> repeatM_ would perhaps be more useful
04:33:46 <mm_freak> that's just forever
04:33:48 <mm_freak> :t forever
04:33:49 <lambdabot> Monad m => m a -> m b
04:33:55 <hpc> oh yes, duh
04:35:37 <sbidin> About repeatM: if it doesn't work for IO, how could I mimic it's behaviour? How would I create an infinite lazy list of results of an infinite number of the same IO operation?
04:35:59 <mm_freak> sbidin: how are you going to consume those values?
04:36:08 <hpc> return (repeat . unsafePerformIO)
04:36:15 <hpc> return . repeat . unsafePerformIO -- rather
04:36:17 <sbidin> mm_freak: I'll take 100 of them, then sum them up.
04:36:26 <mm_freak> sbidin: sounds like a job for pipes then
04:36:42 <hpc> (don't do what i just said)
04:37:22 <mm_freak> runEffect (forever (c >>= yield) >-> P.take 100 >-> consume)
04:37:24 <mm_freak> something like that
04:37:46 <sbidin> mm_freak: pipes as in the library? there isn't a more lightweight approach to this?
04:37:55 <mm_freak> sbidin: pipes is lightweight
04:38:56 * hackagebot language-puppet 0.10.3 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.10.3 (SimonMarechal)
04:39:07 <sbidin> mm_freak: I understand, I was just hoping there was some simple a-few-lines approach I could do, using just the Prelude. I'm a bit amazed I never needed the infinite IO actions thing before.
04:39:12 <sbidin> mm_freak. Thanks for the help!
04:39:21 <mm_freak> as most haskell abstractions it's just a thin layer around regular functions =)
04:39:26 <tomejaguar> I think it's sequence that is the problem
04:39:40 <mm_freak> sbidin: well, there are more hacky ways to do it
04:40:04 <mm_freak> producer :: (X -> IO a) -> IO ()
04:40:21 <mm_freak> produces 100 and applies the function for each
04:40:49 <mm_freak> but that's really ugly and a lot less composable…  it may pay off to just learn pipes now =)
04:42:06 <tomejaguar> sbidin, mm_freak: relevant https://ghc.haskell.org/trac/ghc/ticket/8189
04:55:02 <merijn> sbidin: If you're gonna only use a finite number, use replicate and sequence
04:55:18 <merijn> :t sequence . replicate 10
04:55:19 <lambdabot> Monad m => m a -> m [a]
04:55:28 <merijn> Actually, may replicateM already exists?
04:55:30 <merijn> :t replicateM
04:55:31 <lambdabot> Monad m => Int -> m a -> m [a]
04:55:34 <merijn> There you go
04:57:56 <tomejaguar> merijn: It overflows the stack for large n.  See the trac link I posted.
04:59:00 <tomejaguar> ("It" being replicateM)
04:59:11 <tomejaguar> (or sequence)
05:12:34 <nomeata> Hi. I need someone who is good at producing code where GHC generates error messages.
05:13:05 <nomeata> In particular, I need code that generates an error message with "arising from the dependency ... in the instance declaration" in ghc HEAD.
05:13:18 <nomeata> Anyone here familiar with FunDeps that can whip something up?
05:20:21 <Cale> nomeata: got one
05:21:08 <nomeata> Cale: cool, lemmesee!
05:21:29 <merijn> tomejaguar: Sure, but there's no real way to avoid that without changing the semantics
05:21:30 <Cale> http://lpaste.net/96515
05:22:26 <Cale> annotated with the actual error
05:22:42 <nomeata> Cale: hmm, strangely, on GHC master, this gives a simple "No instance for (C Integer String)" error...
05:22:49 <Cale> oh, okay
05:22:54 <Cale> I only have 7.6.3 here
05:22:55 <nomeata> Maybe it is a bug there
05:23:40 <Cale> Well, that's also a perfectly good way to explain what's gone wrong
05:23:53 <danr> what happens if you add an instance for C String String as well?
05:23:58 <Cale> You can't
05:24:06 <Cale> Well, you'll get a completely different error
05:24:18 <Cale> oh, C String String
05:24:21 <Cale> okay
05:24:40 <danr> yes :
05:24:42 <danr> )
05:25:09 <Cale> I'm not sure how that'll affect things (apart from it'll require FlexibleInstances)
05:25:26 <Cale> Doesn't otherwise change things on my end
05:26:20 <Cale> Adding an instance for C Integer String (which would be relevant to the error in question) should produce a message about conflicting functional dependencies
05:26:34 <nomeata> Cale: it does
05:26:54 <nomeata> I guess it simply is a regression in GHC
05:27:09 <Cale> It's one of those things which is probably a little hard to control
05:27:28 <adimit> QuickCheck question: I'm using Data.Tree to represent a type hierarchy with an obvious subtypeOf relation. I'm trying to write a quickcheck property that'll go through an arbitrary tree and make sure the subtype relation holds between each node and its children. However, the recursive step fails: QuickCheck "gives up."
05:27:35 <Cale> Because it would be affected by which problem with the code you notice first while compiling it
05:28:31 <adimit> here's the code: http://lpaste.net/96517
05:29:56 <adimit> (if I leave out the recursive step, i.e. the tail of the list I'm passing to conjoin, the test runs fine, but it obviously only tests the root node, not all child nodes.)
05:30:36 <mreh> adimit: subtype?
05:31:28 * hackagebot system-random-effect 0.3.1 - Random number generation for extensible effects.  http://hackage.haskell.org/package/system-random-effect-0.3.1 (ClarkGaebel)
05:31:30 * hackagebot cabal2nix 1.56 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.56 (PeterSimons)
05:31:32 * hackagebot bytestring-builder 0.10.4.0.1 - The new bytestring builder, packaged outside of GHC  http://hackage.haskell.org/package/bytestring-builder-0.10.4.0.1 (LeonSmith)
05:31:33 <adimit> mreh: I'm of course constructing a type hierarchy over the tree in the arbitrary instance for Tree (Type ()). The algorithm is based on Schubert numbering (i.e. a simple preorder traversal.)
05:31:34 * hackagebot indian-language-font-converter 0.1 - Indian Language Font Converter  http://hackage.haskell.org/package/indian-language-font-converter-0.1 (AkashJagdhane)
05:31:36 * hackagebot indian-language-font-converter 0.2 - Indian Language Font Converter  http://hackage.haskell.org/package/indian-language-font-converter-0.2 (AkashJagdhane)
05:32:23 <mreh> adimit: that's a little beyond what I can help you with
05:32:26 <adimit> so the subtype tests looks like subtypeOf :: Type a -> Type a -> Bool.
05:34:08 <adimit> mreh: :-) I guess I'll take it to SO or -cafe then…
05:36:38 * hackagebot gitignore 1.0.0 - Apply GitHub .gitignore templates to already existing repositories.  http://hackage.haskell.org/package/gitignore-1.0.0 (RickyElrod)
05:36:40 * hackagebot zeromq3-haskell 0.5.1 - Bindings to ZeroMQ 3.x  http://hackage.haskell.org/package/zeromq3-haskell-0.5.1 (ToralfWittner)
05:36:42 * hackagebot sequor 0.4.2 - A sequence labeler based on Collins's sequence perceptron.  http://hackage.haskell.org/package/sequor-0.4.2 (GrzegorzChrupala)
05:36:44 * hackagebot idris 0.9.10.1 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.10.1 (EdwinBrady)
05:36:46 * hackagebot glade 0.12.5.0 - Binding to the glade library.  http://hackage.haskell.org/package/glade-0.12.5.0 (HamishMackenzie)
05:37:47 <nomeata> Cale: thx, recorded at https://ghc.haskell.org/trac/ghc/ticket/8592
05:41:29 <Peaker> Maybe "fix" could be called "recursively", that way you could nicely say:  f = recursively go 0 where go recurse !acc [] = ... ; go recurse !acc (x:xs) = ... recurse xs ...
05:41:48 * hackagebot gtkglext 0.12.5.0 - Binding to the GTK+ OpenGL Extension  http://hackage.haskell.org/package/gtkglext-0.12.5.0 (HamishMackenzie)
05:41:50 * hackagebot vte 0.12.5.0 - Binding to the VTE library.  http://hackage.haskell.org/package/vte-0.12.5.0 (HamishMackenzie)
05:41:52 * hackagebot postgresql-libpq 0.8.2.5 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.8.2.5 (LeonSmith)
05:41:54 * hackagebot naturalcomp 0.0.1 - Natural-order string comparison  http://hackage.haskell.org/package/naturalcomp-0.0.1 (HironaoKomatsu)
05:41:56 * hackagebot rmonad 0.8.0.1 - Restricted monad library  http://hackage.haskell.org/package/rmonad-0.8.0.1 (GaneshSittampalam)
05:42:09 <Peaker> (name things based on how they're used/useful, and not based on what they fundamentally/mathematically are?)
05:42:27 <donri> RecursionFactoryFactory
05:43:34 <adimit> donri: you're missing the 'Abstract' prefix.
05:43:42 <quicksilver> sometimes we don't realise how they're useful until later
05:43:58 <quicksilver> like the way some people think that 'whenJust' is a better name for 'for_'
05:44:06 <quicksilver> and other people think that you just need to learn what 'for_' means.
05:44:34 <donri> > fix ("Factory"++)
05:44:35 <lambdabot>   "FactoryFactoryFactoryFactoryFactoryFactoryFactoryFactoryFactoryFactoryFact...
05:44:41 <Peaker> well, "for_" is indeed more generic than "whenJust"
05:44:56 <Peaker> but is "least defined fixpoint" more generally useful than "recursively" applying some function?
05:45:07 <companion_cube> :t for_
05:45:07 <lambdabot>     Not in scope: `for_'
05:45:07 <lambdabot>     Perhaps you meant one of these:
05:45:07 <lambdabot>       `F.for_' (imported from Data.Foldable),
05:45:17 <companion_cube> :t F.for_
05:45:17 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
05:45:26 <quicksilver> I was commenting on your argument not your example
05:45:30 <donri> traverse is a better name
05:45:41 <quicksilver> I think recursively is not a terrible name for fix.
05:45:43 <merijn> Well, you know...there's only two hard problems in computer science
05:45:50 <Peaker> quicksilver: so more specifically, name things based on they're *generally* used/useful?
05:46:02 <quicksilver> (1) people who are wrong on the internet (2) profit???
05:46:03 <merijn> Cache invalidation, *naming things* and off-by-one errors
05:46:24 <quicksilver> Peaker: I don't disagree, I just think you'd have to rename things a lot to stick to that
05:46:29 <dcoutts> naming things is so hard
05:46:35 <merijn> I oppose recursively on the grounds that it's too long to type
05:46:37 <quicksilver> because one of the things about good abstractions is they end up being more useful than you realised
05:46:40 <merijn> dcoutts: Word.
05:46:49 <donri> There's only 10 types of people: those who understand binary, those that don't and those who get off-by-one jokes?
05:46:54 <Peaker> if GHC had a   {-# LANGUAGE NoRecursions #-} like (the opposite of) Mu, and fix->recursively, it'd prevent a lot of accidental recursions
05:46:57 <merijn> dcoutts: I spent more time confused about what I should name stuff than I do coding...
05:46:58 * hackagebot hedn 0.1.8.1 - EDN parsing and encoding  http://hackage.haskell.org/package/hedn-0.1.8.1 (AlexanderBondarenko)
05:47:00 * hackagebot iCalendar 0.3.0.1 - iCalendar data types, parser, and printer.  http://hackage.haskell.org/package/iCalendar-0.3.0.1 (ChristianRoedliAmble)
05:47:02 * hackagebot process 1.2.0.0 - Process libraries  http://hackage.haskell.org/package/process-1.2.0.0 (HerbertValerioRiedel)
05:47:04 * hackagebot language-puppet 0.10.3 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.10.3 (SimonMarechal)
05:47:06 * hackagebot lord 2.20131203 - A command line interface to online radios.  http://hackage.haskell.org/package/lord-2.20131203 (rnons)
05:47:26 <Peaker> instead of "let rec", just use "recursively" :)
05:47:28 <dcoutts> merijn: I spent much of the weekend trying to name things in a new binary serialisation API
05:47:51 <dcoutts> incidentally, it's over 2x faster than binary or cereal
05:47:52 <merijn> dcoutts: I should just pay someone to come up with names for me, I'd be so much more productive!
05:48:10 <dcoutts> merijn: na, it'd never work, you would not be happy with the result :-)
05:48:13 <merijn> dcoutts: ugh, so now I need to rewrite my serialisation code to use that library? >.>
05:48:20 <donri> dcoutts: nice! is it using bytestring Builder yet? i read lennart experimented with it and it was slower
05:48:29 <adimit> Apropos recursion, I've posted my question above to SO, if anybody is interested: http://stackoverflow.com/questions/20352717 :-)
05:48:42 <dcoutts> merijn: don't you just use generic deriving?
05:48:49 <dcoutts> donri: it is using builder
05:49:04 <donri> dcoutts: oh wait this is not a new version of binary?
05:49:19 <Cale> nomeata: https://groups.google.com/forum/#!topic/haskell-cafe/hu1qN-Mxw5k
05:49:20 <dcoutts> donri: yes, it's intended to replace the Binary class in the binary package
05:49:22 <Peaker> dcoutts: cool, known reasons for the speed benefits?
05:49:31 <dcoutts> Peaker: yes, known
05:49:50 <dcoutts> it uses a clever trick by Simon Meier
05:49:51 <Cale> nomeata: There it is in another context, I wonder if we can reproduce something like that message
05:50:00 <Peaker> dcoutts: ah, that's what I was hoping to hear about :)
05:50:06 <donri> dcoutts: is this using tekmo's Storable trick? he said it was 5x faster (but requires IO)
05:50:13 <dcoutts> donri: no
05:50:16 <donri> oh
05:50:40 <dcoutts> Peaker, donri: basically, it turns out that the reason binary and cereal are slow is because their continuations are huge
05:51:01 <Peaker> dcoutts: huge as in the reference graph they keep alive (GC-wise)?
05:51:07 <Cale> nomeata: here's another: http://www.haskell.org/pipermail/haskell-cafe/2008-December/052093.html
05:51:30 <Peaker> dcoutts: not sure what the size of a continuation means
05:51:42 <dcoutts> Peaker, donri: each time they suspend, they have to allocate a load of stuff to do with buffers offsets etc.
05:51:54 <dcoutts> plus the continuation takes half a dozen args
05:52:28 <dcoutts> so what they gain in doing the writing into buffers directly, they loose on the management of all the info to do that
05:52:33 <nomeata> Cale: with the latter, I don’t get that error message in either HEAD or 7.6
05:52:48 <Peaker> dcoutts: what's the alternative?
05:52:54 <Cale> nomeata: I get...
05:53:04 <dcoutts> Peaker, donri: so the trick is that the Binary instances just produce a list of instructions for what to write out!
05:53:13 <Cale> http://lpaste.net/96519
05:53:32 <dcoutts> Peaker, donri: ie a deep embedding, and then an interpreter does the final binary encoding
05:53:34 <Peaker> dcoutts: that's only for the Put side of things, isn't it?
05:53:38 <dcoutts> yes
05:53:48 <Peaker> dcoutts: ah, so the Get stuff isn't changed?
05:53:56 <dcoutts> no, the get works similarly
05:54:08 <dcoutts> it parses pre-decoded tokens
05:54:26 <Peaker> ah, so sort of a "Free" transform of both Get and Put to simplify and make the closures cheaper?
05:54:33 <dcoutts> yes
05:54:34 <nomeata> Cale: ah, I see. I should not change Control.Monad.State to Control.Monad.Trans.State (which I did because the former is not available in my GHC tree)
05:54:45 <Peaker> dcoutts: cool, thanks for the explanation :)
05:55:24 <dcoutts> Peaker: so not only is it faster, but using a deep embedding allows for different interpreters which is rather interesting
05:55:43 <nomeata> Cale: but even stranger, StateT from Control.Monad.State is just a re-export of Control.Monad.Trans.State.
05:55:45 <Peaker> dcoutts: what can the different interpreters do?
05:55:49 <dcoutts> Peaker: e.g. could serialise to different formats, and potentially not just binary ones
05:56:01 <dcoutts> Peaker: can easily encode to generic terms
05:56:18 <dcoutts> Peaker: or could have a decoder that keeps more info a produces better error messages
05:56:23 <dcoutts> a/and
05:56:30 <Peaker> dcoutts: ah, nice, though that only works for the lowest-level primitives. Or can you add a new "primitive" to the Free encoding?
05:56:34 <dcoutts> rather than just "decode error at offset 3456463"
05:56:37 <nomeata> Cale: ah, nevermind
05:57:18 <dcoutts> Peaker: this is intended to be used for self-describing binary formats, like MsgPack, so describing errors in terms of that low level structure makes some sense
05:57:26 <Peaker> dcoutts: i.e: the deep embedding eventually generates something like [Put word32le, Put word16le, Put bytestring, ...] but you might want: "Put this kind of CustomType" in there, so that different interpreters can encode CustomType in different ways
05:57:50 <Peaker> (not using the same low-level words and bytestrings)
05:58:07 <dcoutts> Peaker: it's not quite that low level, it's putSigned, putUnsigned, putText, putBytes, putSequence, putMapping
05:58:30 <dcoutts> Peaker: MsgPack (and other JSON-like binary formats) have this low level structure already
05:58:53 <nomeata> Cale: but inlining the class definition yields the same effect: The error message changed in HEAD
05:59:31 <dcoutts> Peaker: but yes, we do have a fixed set of primitives, chosen carefully to allow some flexibility in the external format
05:59:31 <Peaker> dcoutts: does it use an ADT to describe the primitives?  it could in theory use "OO" style and describe the primitives via a record of the destructures/supported operations, so you can extend them with new primitives
05:59:59 <dcoutts> Peaker: and it has to be fast, so it's not supposed to have too much complex structure
05:59:59 <Peaker> though I guess then you can't add new interpreters
06:00:03 <Peaker> (classic expression problem)
06:00:26 <dcoutts> right, fixed set of primitives, which have to be chosen carefully
06:00:52 <Peaker> yeah, and the low-level-ness of the primitives does yield some uniformity across the different possible encodings which can also be a plus
06:02:30 <merijn> dcoutts: I'm not serialising haskell data, so no, I'm not using generic deriving
06:02:43 <merijn> dcoutts: I'm "parsing" binary data
06:03:21 <merijn> dcoutts: On that note, I don't suppose your library supports a nice way to parse variable fields within fixed-width fields?
06:03:54 <dcoutts> merijn: ah ok, in that case none of this applies. The binary package does both use cases: serialising Haskell values, and working with externally-defined formats (though that's not extremely clear in the API)
06:04:16 <dcoutts> merijn: so you don't use the Binary class
06:04:16 <merijn> dcoutts: And it doesn't do the latter particularly well >.>
06:04:47 <dcoutts> merijn: suggestions welcome
06:05:02 <merijn> dcoutts: Well, I have haskell representations for some bits and pieces, but I want those to just serialise/deserialise to the wire representation
06:05:20 <dcoutts> merijn: the main change we want to make now is to clarify the API by clearly separating the two use cases, serialisation vs handling externally-defined binary formats
06:06:13 <Peaker> dcoutts: it would be nice to have pickler combinators where you can control the wire format
06:06:15 <merijn> dcoutts: Ok, so my biggest problem/pet peeve so far was the following use case. I have a 20 byte field which consists of a variable length null terminated string padded with null bytes.
06:06:33 <Peaker> defining Get/Put manually (which you need to do if you want wire format control) inherently has some ugly duplication
06:07:22 <merijn> dcoutts: I had a huge annoyance trying to do that in any of the three libraries I tried (attoparsec, cereal and binary), so a nice way to deal with that would be great.
06:07:23 <dcoutts> Peaker: it does, though it turns out that it's quite tricky to do the (un)picking in a compositional way and fast
06:07:27 <Peaker> pickler combinators are not easy in Haskell! One of the examples where static typing does make things more difficult (though of course the statically typed code has much nicer guarantees, as always)
06:07:55 <dcoutts> merijn: hmm, why not just grab 20 bytes as a bytestring and then trim it?
06:07:58 <Cale> I've seen pickler/unpickler combinator libraries
06:08:00 <Peaker> dcoutts: I would love pickler combinators that are in some non-Hask category -- so that you can even generate C code from the definitions
06:08:13 <Hodapp> generating C code wha?
06:08:22 <Peaker> Cale: none seem to be properly cabalized (except one I saw for some XML format, but I need wire format picklers)
06:08:33 <Peaker> Hodapp: for compatibility across other languages with the same wire format
06:08:36 <Cale> Well, yeah, I was actually thinking of hexpat-pickle
06:08:44 <Cale> and one other String parsing library before that
06:08:54 <Hodapp> Peaker: oh, this isn't something that already exists?
06:08:55 <Cale> The static typing doesn't seem to be the hard bit though
06:09:08 <Peaker> Hodapp: not that I know of. The closest is "protocol buffers" which doesn't let you control the wire format
06:09:18 <Hodapp> hmm, yeah
06:09:27 <merijn> dcoutts: That works but 1) the code for that is ugly, 2) it's useless overhead for no good reason in a parser that should be fast
06:09:43 <Peaker> Cale: with dynamic typing, you can do pickler combinators more easily, by e.g: throwing a lambda in there that takes a hetero-dict of the "context" of named things that were already encoded/decoded earlier
06:10:03 <Cale> http://research.microsoft.com/pubs/64036/picklercombinators.pdf
06:10:49 <dcoutts> merijn: so you want a getWhile and skipWhile
06:10:59 <Peaker> Cale: yeah, not cabalized and requires some polish for "Real Work (TM)", I think
06:11:13 <Cale> Yeah, nowadays, you'd have an Applicative instance in there
06:11:15 <Peaker> Cale: and it also doesn't explicitly give control of the wire format
06:11:20 <Cale> and derive most of the stuff in there from that
06:11:33 * hackagebot tasty 0.4.1.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.4.1.1 (RomanCheplyaka)
06:11:35 <Peaker> Cale: the pickler combinator is invariant, not covariant, iirc, so can't be Functor/Applicative/etc
06:11:36 <donri> dcoutts: could you use this to write an interpreter that flips endianness for example?
06:11:38 <Cale> and yeah, you'd want primitives which give various wire-format-level parts
06:11:53 <dcoutts> donri: yes, though I'm not sure how useful that is :-)
06:12:01 <donri> dcoutts: someone wanted a newtype wrapper for that but i don't think it's possible to do generically in current binary
06:12:02 <Peaker> Cale: i.e: something like: data PU a = PU (Get a, a -> Put)
06:12:05 <Cale> oh, right
06:12:07 <exicer> Er, stupid question: I have a type DLError, and I want to use that in another datatype. So I would do data BiggerError = DLError | SomethingElse, right ?
06:12:12 <Peaker> Cale: so you get none of the nice machinery, which is part of why it's hard
06:12:19 <Cale> Wait...
06:12:25 <dcoutts> donri: it's the wrong thing to do. It shows they're using the Binary class for the wrong purpose.
06:12:46 <Cale> oh, yeah, you don't quite have Applicative, but perhaps something analogous
06:12:47 <donri> dcoutts: hm could you do it localized to a newtype wrapper's Binary instance? but yes i agree :)
06:13:01 <Cale> Instead of fmap, you take functions in both directions
06:13:03 <Peaker> Cale: if you dive into this and figure out something nice, it's worth at least blogging about it :)
06:13:14 <Peaker> Cale: I remember trying and not figuring out something nice
06:13:35 <Cale> and I feel like something analogous to liftA2 should be possible here, but maybe with an extra parameter or so
06:13:49 <dcoutts> donri: no, in my new Binary class, you could not do it with a newtype wrapper, but you could do it with a formatter. So instead of using the formatter that produces MsgPack you could write another one that produces MsgPack-WrongEndian format
06:14:42 <dcoutts> donri: the point of the Binary class is that it is for serialising Haskell types, and so you are not allowed to care about the wire format that it produces (just some general properties, fast, portable etc).
06:15:07 <donri> dcoutts: yeah
06:15:27 <merijn> dcoutts: getWhile but with a fixed limit, because if I'm parsing data from the network I don't want to blindly assume a fixed width field of 20 characters will indeed be properly null-termintated.
06:15:34 <donri> dcoutts: i'm still confused though, is this a replacement for binary or a replacement for Binary inside binary?
06:15:40 <dcoutts> merijn: mm
06:15:40 <Peaker> Cale: invariant equivalents for Functors/Applicative/Monad sound like they should be a thing, but arent' yet
06:15:45 <bennofs> if maybe data PU a b = PU (Get a, b -> Put) would be a profunctor?
06:15:45 <merijn> dcoutts: Because then someone could DOS me by leaking memory when they just never send a null byte
06:15:46 <dcoutts> donri: the latter
06:16:00 <dcoutts> donri: we want to fix up the binary package and get it into the HP
06:16:04 <donri> dcoutts: whatever the case it would be nice to get something-anything standardized in platform
06:16:07 <donri> yeah :)
06:16:23 <Peaker> Cale: the PU stuff might be useful guidance as they have the (non-generalized) PU combinators that are like Monadic stuff
06:16:25 <dcoutts> merijn: sure I understand
06:16:34 <merijn> dcoutts: So now I end up reading a fixed-width bytestring, extracting it from the monad. Doing a "takeWhile (/=0)" and then returning that
06:17:20 <donri> ain'tNoThing = (/=0)
06:19:47 <dcoutts> Peaker: so the tricky thing with making compositional unpicking fast is the alternatives. Suppose you have a tag to tell you which alternative to take. In non-compositional code you can just read the tag and do a case on the tag. With compositional then you need it to be more like a parser with some mechanism for limited lookahead or backtracking
06:20:09 <dcoutts> Peaker: it requires more from the Get monad, imposes costs for everyone
06:20:31 <dcoutts> e.g. attoparsec has unlimited backtracking and so can never release its input
06:20:44 <dcoutts> Get has no backtracking and so is faster simpler and can release the input
06:21:09 <dcoutts> but then obviously that makes compositional parsing hard
06:22:09 <Peaker> this could be done in non-Hask: getByte >>> choice [(1, opt1), (2, opt2), (3, opt3)]   would this be considered compositional?
06:22:26 <Peaker> maybe s/choice/dispatch
06:23:15 <dcoutts> Peaker: but you have to be able to generate that from something like  blah <|> blah <|> blah
06:23:43 <dcoutts> and it's not always the case that the tag immediately precedes the alternatives
06:24:06 <Peaker> dcoutts: why not require explicit "dispatch" tables
06:24:21 <Peaker> dcoutts: that's why we have Arrow combinators for (though not from the Arrow class which is useless)
06:24:25 <Peaker> s/why/what
06:24:27 <dcoutts> mm
06:24:36 <Peaker> dcoutts: using Arrow-like combinators you can have the tag not immediately precede the dispatch
06:25:13 <dcoutts> Peaker: maybe, if it can be done within the confines of what we provide with Get then that'd be great, and perhaps then the binary package could provide that
06:26:30 <Peaker> well, not using ordinary non-compositional monadic style here is only appealing to me because of the ability to treat the Get computation as transparent rather than opaque (allowing to "see through" the (non-)lambdas)
06:26:44 <Peaker> Get supports lambdas anyway, so might as well just do it non-compositionally?
06:31:57 <Feuerbach> Does anyone know what could be the source of this travis error? https://travis-ci.org/feuerbach/tasty/builds/14865402
06:33:43 <Feuerbach> (It seems that hsc2hs has disappeared.)
06:37:51 <bergmark> Feuerbach: https://twitter.com/travisci/status/407673023022395392
06:38:36 <exicer> So is there a way to do the following (http://lpaste.net/96521) without using TestAWrapper in TestB ?
06:38:44 <bergmark> seems they updated to ghc 7.6.3
06:39:58 <donri> exicer: no, but you could type class a smart constructor, say "testA"
06:40:04 <donri> not necessarily recommending it though :)
06:40:25 <exicer> donri: Hmm, what would you reccommend? :P
06:40:38 <donri> accepting what you have :)
06:40:42 <exicer> Doing it in some other way? :P
06:40:55 <exicer> I would have thought this is a common thing to want to do though
06:41:05 <exicer> but I'm just going to end up wrapping and unwrapping loads
06:41:08 <exicer> which seems unnecessary
06:41:21 <supki> exicer: what's the point of data constructor String?
06:41:41 <exicer> Just a placeholder
06:41:54 <Feuerbach> bergmark: cheers!
06:42:14 <exicer> I'm trying to work out how to handle errors
06:42:36 <donri> exicer: well you could look at things like uniplate (also in lens) for type-directed traversals of nested types
06:43:16 <exicer> donri: Okay, will take a look
06:45:01 <donri> exicer: http://skillsmatter.com/podcast/scala/uniplate
06:57:56 <zol> If I have a list of tuples, and I want to filter based on the second element, but return the whole tuple, how would you do this?
06:58:20 <donri> filter (pred . snd)
06:58:49 <donri> filter doesn't change the elements
06:59:06 <zol> donri: oh, wow -- I never even thought about dot operator :(
06:59:14 <donri> \o/
07:02:30 <BoR0> why did you use pred there?
07:02:49 <donri> oh sorry forgot that's in prelude
07:02:55 <donri> i meant "insert your predicate here"
07:03:02 <BoR0> oh, I thought predecessor. sorry :)
07:03:10 <donri> > pred True -- ;)
07:03:11 <lambdabot>   False
07:03:23 <BoR0> > pred False
07:03:24 <lambdabot>   *Exception: Prelude.Enum.Bool.pred: bad argument
07:03:28 <donri> :t filter (pred . snd)
07:03:28 <lambdabot> [(a, Bool)] -> [(a, Bool)]
07:03:33 <donri> hihi
07:07:39 <ij> I've got a = IO stuff, what's the simplest way to do function f with the a discard the results and then do somthing else with it?
07:08:13 <quicksilver> x <- a; f x; g x; h x;
07:08:14 <quicksilver> ???
07:08:28 <quicksilver> not entirely sure I understand your question ij, but that might be the answer
07:08:59 <Skola> 'mapM (f . readFile) manyFiles' leads to 'openBinaryFile: resource exhausted (Too many open files)' How can I prevent opening too many files at once?
07:09:22 <quicksilver> use a strict version of readFile
07:09:32 <quicksilver> readFile uses (broken) interleaved IO
07:10:22 <Skola> I use import System.IO.UTF8
07:10:53 <Skola> which indeed is lazy
07:11:12 <ij> quicksilver, Hmm, I wanted to do that in a >>/>>= pipeline.
07:11:18 <Skola> is there a strict equivalent?
07:13:58 <Tinned_Tuna> Skola: http://hackage.haskell.org/package/text-0.11.3.1 and http://hackage.haskell.org/package/bytestring-0.10.4.0 should allow you to construct a strict UTF8 readFile
07:14:36 <quicksilver> ij: a >>= (\x -> f x >> g x >> h x)
07:15:10 <Tinned_Tuna> Skola: http://hackage.haskell.org/package/text-0.11.3.1/docs/Data-Text-IO.html, "The entire file is read strictly, ..."
07:15:34 <Skola> Tinned_Tuna: just found the same, thanks :}
07:24:49 <intrados> Is there a way to map over record fields? I want to mappend each field from one record on to each field in another
07:24:49 <startling> hey, Env is different from Writer.
07:24:57 * startling is enlightened.
07:25:11 <startling> intrados, what does your data type look like?
07:25:27 <donri> intrados: there's gmappend in generic-deriving
07:26:02 <startling> intrados, one thing you might do is write a Monoid instance for it where the fields of one argument are mappended to their counterparts.
07:26:15 <donri> https://hackage.haskell.org/package/generic-deriving-1.6.2/docs/Generics-Deriving-Monoid.html
07:26:30 <donri> you can use that to write a 3-line Monoid instance
07:26:37 <startling> or derive it automatically, yeah.
07:27:02 <intrados> Thanks. gmappend looks like just the thing
07:27:28 <donri> assuming your record only has one constructor
07:30:05 <donri> actually gmappend only works for instances of GMonoid (although derivable), more likely you want mappenddefault (and even better use it to write a Monoid instance)
07:30:45 <startling> I have data Freely e (f :: * -> *) a = Purely a | Freely (e (Freely e f) a). I feel like I can write a Monad instance for it (maybe with (Comonad (e (Freely e f)))?) but I don't see it.
07:40:52 <startling> Wow, StandaloneDeriving is surprisingly useful.
07:42:37 <startling> Especially when dealing with UndecidableInstances and terrible complicated kinds, heh.
07:48:40 <intrados> If I want to convert an multi-typed JSON array to Haskell, is http://lpaste.net/96522 the best I can do?
07:48:50 <intrados> (while staying away from HLists)
07:49:51 <bergmark> intrados: Either Foo Bar seems more appropriate
07:49:51 <donri> intrados: why not data Baz = Foo | Bar
07:50:43 <bergmark> Either! ;)
07:50:47 <startling> intrados, do you Baz Nothing Nothing to be legal?
07:50:58 <intrados> bergmark: It's a simplification, there are actually more than just two types
07:50:59 <startling> *do you want
07:51:02 <donri> well i was assuming there's actually more than two alternatives
07:52:14 <bergmark> donri wins
07:52:20 <donri> ;)
07:53:57 <skypers_> hello!
07:54:18 <skypers_> I have a type that could be summed up as a String
07:54:21 <intrados> donri: Don't I sort of lose type information if I do that? I later want to have functions with Foo in the type signature
07:54:24 <skypers_> called Foo for instance
07:54:56 <skypers_> I’d like to hash that Foo into a Word32
07:55:03 <skypers_> read as: hash a String into a Word32
07:55:32 <skypers_> it would be neat if the hash is smaller as possible, and unique for each String
07:55:33 <skypers_> any idea?
07:55:37 <k00mi> intrados: you could use a GADT
07:59:15 <intrados> k00mi: How? Not `data Baz a where Baz :: a -> Baz a`, right?
08:01:53 <startling> I'm not sure how GADTs would help here either.
08:02:22 <k00mi> intrados: I annotated you paste
08:02:32 <k00mi> s/you/your/
08:03:10 <Twey> intrados: What's wrong with HLists?
08:03:34 <Twey> Or some kind of n-ary tuple, anyway.  They're not all that scary with DataKinds and friends.
08:04:03 <bergmark> k00mi: i like it
08:06:20 <intrados> Twey: Well, they seem not to interact with other libraries well. For example, I couldn't use `mapConcurrently` with them (I think).
08:06:59 <k00mi> wait, the GADT thing doesn't work because you can't have [Foo, Bar]
08:07:24 <Twey> k00mi, bergmark: The problem with that GADT version is that the ‘a’ for all the elements of ‘json’ is the same.  So that's either a list of Baz Foo or a list of Baz Bar, but not a list mixing Baz Foo's and Baz Bar's (which I think is what intrados was asking for).
08:07:39 <intrados> k00mi: Yeah. That's what I was just going to ask about
08:07:40 <k00mi> Twey: yep, just realized that
08:07:50 <Twey> You can get around it with an existential type, but you shouldn't.  The proper solution here is an HList or other n-ary tuple.
08:08:17 <donri> doesn't existential just get you back to the non-gadt version
08:08:21 <Twey> Basically, yes
08:08:35 <donri> you throw away the phantom type basically
08:09:50 <intrados> Twey: When you say proper solution, you mean that I ought to do that rather than the record method?
08:09:53 <Twey> intrados: If you want to run a function on an HList that expects a list, you'll need to either convert the HList to a list or else convert the function to use HLists, yes.
08:10:09 <Twey> intrados: Depends how much you care about type-safety
08:10:21 <Twey> I would probably have a go at it, but not if I were on a deadline :þ
08:10:52 <Twey> Oh, the record method you've done there is rubbish though
08:11:30 <Twey> The proper way is just data Baz = BazFoo Foo | BazBar Bar; you don't need to represent values that can be both an int and a string, for example
08:12:50 <Twey> (‘the proper way’ that doesn't involve encoding the type in Haskell's type-system, that is)
08:13:35 <intrados> Yes. I think I would like to have the type encoded in the type system which is what seems to make things difficult
08:13:59 <Twey> Then HLists are the way to go
08:15:14 <Twey> I would use a GADT to restrict the possible types, as intrados did, then you can use an eliminator that takes a function for each possible type
08:16:08 <intrados> Twey: Yeah. They are seeming increasingly inevitable. Is making HList an instance of Traversable non-sensical or prohibitively difficult?
08:21:13 <hattmammerly> let minus (x:xs) (y:ys) = case (compare x y) of LT -> x : minus xs (y:ys); EQ -> minus xs ys; GT -> minus (x:xs) ys; minus xs _ = xs
08:21:22 <hattmammerly> what's wrong with the last statement there?
08:21:38 <hattmammerly> I get a pattern error on minus xs _ = xs
08:21:57 * hackagebot markup-preview 0.2.0.2 - A simple markup document preview (markdown, textile, reStructuredText)  http://hackage.haskell.org/package/markup-preview-0.2.0.2 (MariusGhita)
08:24:44 <inf-groupoid> hattmammerly: Perhaps - let minus (x:xs) (y:ys) = case (compare x y) of { LT -> x : minus xs (y:ys); EQ -> minus xs ys; GT -> minus (x:xs) ys }; minus xs _ = xs
08:25:24 <quchen> hattmammerly: Parenthesize the case
08:25:27 <quchen> :t let minus (x:xs) (y:ys) = case (compare x y) of { LT -> x : minus xs (y:ys); EQ -> minus xs ys; GT -> minus (x:xs) ys}; minus xs _ = xs in minus
08:25:28 <lambdabot> Ord a => [a] -> [a] -> [a]
08:29:59 <nomeata> Hi. Is there a good reason why "newtype T = MkT a b c" could not be equivalent to "newtype T = MkT (# a, b, c#)"?
08:30:45 <nomeata> ah, probably because unboxed tuples don’t work well in polymorphic contexts...
08:34:38 <Twey> intrados: Nonsensical
08:35:21 <Twey> intrados: ‘HList’ is not a type but a type family; you can think of an HList as being like a generalization of tuples
08:38:18 <Twey> intrados: About the only functions you can meaningfully map onto an arbitrary HList is id or const, since you have no idea about the types inside
08:46:19 <dmj`> Is there a way to do point free w/ pattern matching? Like case (Right 1) of { Right -> print . show }
08:47:00 <dmwit> dmj`: That is what catamorphisms do.
08:47:07 <dmwit> They are the function version of pattern matching.
08:47:31 <dmwit> e.g. for your case, either (print . show) (error "inexhaustive pattern match") (Right 1)
08:47:51 <dmwit> well
08:47:55 <dmwit> What I said is not quite precise.
08:48:22 <dmwit> There is probably a name for the function version of pattern matching, and it's not catamorphism. But the catamorphism is usually what you want anyway.
08:48:22 <Saizan> another way is to use prisms from lens i guess
08:48:33 <supki> :t (^!_Right.to show.act print)
08:48:34 <lambdabot> Show b => Either c b -> IO ()
08:48:51 <dmj`> > Right 1 >>= either print (\_ -> error "oops")
08:48:52 <lambdabot>   Couldn't match type `GHC.Types.IO ()'
08:48:52 <lambdabot>                with `Data.Either.Eith...
08:49:00 <dmj`> oops :0
08:49:11 <donri> print . show, heh
08:49:26 <dmwit> > either print (\_ -> error "oops") (Right 1) -- dunno where that bind came from, I gave you the exact code to use =P
08:49:27 <dmj`> > Right 1 >>= either return (\_ -> error "oops")
08:49:27 <lambdabot>   <IO ()>
08:49:28 <lambdabot>   Could not deduce (GHC.Num.Num (Data.Either.Either b b0))
08:49:28 <lambdabot>    arising from th...
08:49:33 <dmwit> no bind!
08:49:59 <dmwit> Though I guess I probably got the order of arguments to either wrong.
08:50:09 <dmwit> > either (\_ -> error "oops") print (Right 1)
08:50:10 <lambdabot>   <IO ()>
08:50:44 <FreeFull> Chairs and robot monkeys
08:51:45 <dmj`> dmwit: it makes sense, but for longer expressions I have to use where. either handleError handleSuccess where handleSuccess = print; handleError = logError . B8.pack . show
08:51:56 <dmwit> why?
08:52:05 <dmwit> either (logError . B8.pack . show) print
08:52:38 <dmwit> maybe you meant s/have to/prefer to/, in which case, okay
08:53:09 <dmj`> well the above expression isn't that long, in snap sometimes my handlers have longer monadic expressions
08:53:44 <dmj`> currentUser >>= maybe the404 handleUser where handleUser u = do ... lots of stuff
08:54:29 <dmj`> sometimes a case statement seems to make sense, was wondering if it could be point free
08:55:18 <bergmark> LambdaCase?
08:55:44 <bennofs> Is there a nice way to write a function Int -> [a] -> [[a]] that splits the list every n elements?
08:55:56 <startling> isn't there a typeclass like t m a -> (m a -> m b) -> t m b somewhere?
08:56:45 <donri> :t chunksOf
08:56:46 <lambdabot> Int -> [e] -> [[e]]
08:56:56 <donri> @hoogle chunksOf
08:56:57 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
08:56:57 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
08:56:59 <tomejaguar> startling: For monad transformers?
08:57:02 * hackagebot ex-pool 0.1.0.2 - Another fork of resource-pool, with a MonadIO and MonadCatch constraint  http://hackage.haskell.org/package/ex-pool-0.1.0.2 (KimAltintop)
08:57:02 <donri> eh, split package
08:57:15 <startling> tomejaguar, not necessarily monad transformers, but yeah.
08:57:25 <dmj`> bergmark: yes, lambdacase seems to be what I'm looking for.
08:58:20 <tomejaguar> startling: Well you need some condition on t.  Anyway I heard a rumour that this is not possible for monad transformers in general.  There was a discussion on Reddit about a year ago when Tekmo said that signature was missing from the definition of monad transformers and edwardk said it was too restrictive for monad transformers in general.
08:58:53 <startling> tomejaguar: sure. of course it isn't possible for monad transformers in general.
08:59:15 <startling> (that's why I'm asking about a typeclass).
09:00:30 <tomejaguar> Oh right.  Well if you understand why it's not possible for monad transformers in general then I'd love you to explain it to me!  I didn't understand it.
09:02:38 <quicksilver> tomejaguar: 'monad transformers in general' doesn't mean anything very precise I don't believe.
09:02:41 <dmwit> http://hackage.haskell.org/package/mmorph-1.0.0/docs/Control-Monad-Morph.html#v:hoist
09:02:47 <startling> dmwit: ah, mmorph
09:02:53 <startling> that's what I'm thinking of. thanks!
09:03:13 <quicksilver> if you mean "t :: (* -> *) -> (* -> *)" such that (Monad m) implies (Monad t m)
09:03:30 <quicksilver> then some things generally considered to be monad transformers fail that criterion.
09:05:27 <tomejaguar> I guess my question is "Which monad transformer isn't an MFunctor (from the mmorph package)"
09:05:55 <sx> is it possible to map a generic function to a tuple of values which all satisfy the class the function needs?
09:05:56 <tomejaguar> Err no I don't mean that.
09:06:08 <startling> tomejaguar: that's a valid question. I'm not sure.
09:06:14 <dmwit> tomejaguar: perhaps there's some contravariant (or invariant) monad transformer out there
09:06:30 <startling> tomejaguar: to me it's intuitively obvious that you can't write it in terms of "lift", so that's why I said "of course".
09:06:51 <bennofs> what's a contravariant monad transformer?
09:07:08 <startling> dmwit, would they have "lift"?
09:07:09 <dmwit> One where you want hoist's first argument to go the other way. ;-)
09:07:13 <tomejaguar> I mean something else, but I can't work out what it is right now :S
09:07:30 <dmwit> contraHoist :: Monad m => (forall a. n a -> m a) -> t m b -> t n b
09:07:50 * dmwit ponders ContT
09:08:01 <dmwit> I notice it isn't on the list of instances of MFunctor.
09:08:06 <dmwit> ?unmtl ContT r m a
09:08:06 <lambdabot> (a -> m r) -> m r
09:08:33 <startling> dmwit, oh, interesting.
09:08:34 <dmwit> hoistCont :: (forall a. m a -> n a) -> ((b -> m r) -> m r) -> ((b -> n r) -> n r)
09:08:37 <dmwit> Did I get that right?
09:08:42 <startling> I think so.
09:08:52 <dmwit> Alright. Now let me stare and see if I believe it can be done. =P
09:08:57 <bennofs> If we can make Cont an instance, then we can make any monad transformer an instance, as Cont is the "Mother of all monads", no?
09:09:01 <startling> I think you'd need a (forall a. n a -> m a) too.
09:09:03 <dmwit> right
09:09:07 <dmwit> so this one is invariant
09:09:26 <startling> bennofs: is that what people mean by that?
09:09:42 <bennofs> They mean that all Monads can be implemented in terms of Cont I think
09:09:50 <bennofs> Not sure if that also holds for transformers
09:09:50 <startling> I always thought it was a reference to the historical context.
09:10:01 <bennofs> @google Mother of all monads
09:10:02 <lambdabot> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
09:10:02 <lambdabot> Title: A Neighborhood of Infinity: The Mother of all Monads
09:10:52 <startling> I might be wrong.
09:11:10 <dmwit> tomejaguar: Does this answer your unasked question?
09:12:57 <bennofs> (a -> m r) -> m r looks a lot like a partially applied (>>=) to me. Is that just coincidence or does it have some deeper reason?
09:13:09 <tomejaguar> bennofs, startling: I always understood it as "all monads can be implemented in terms of" but I never believed it :)
09:13:56 <tomejaguar> dmwit: I think it answers some question, but I'm still just confused :S :)
09:15:10 <dmwit> tomejaguar: okay =)
09:15:14 <piezo> hi ! I have a Cabal API question
09:15:22 <piezo> given a [Dependency] list, how can I compute the list of packages that Cabal would install to satisfy them ?
09:15:58 <bennofs> piezo: why do you need this?
09:16:06 <bennofs> (what do you want to do?)
09:16:55 <piezo> I'm making a script to compute the common dependencies of a package set
09:19:04 <bennofs> piezo: IIRC dependency resolution is not in the Cabal API, but in cabal-install itself (which is not available as a package). So you will have to do the dependency resolution yourself or run "cabal configure" and then read dist/setup-config (There all packages have been resolved IIRC)
09:19:34 <piezo> in order to avoid having packages duplicated in each sandboxes
09:20:16 <bennofs> piezo: ? You cannot easily share packages between sandboxes
09:20:17 <piezo> bennofs: ok thanks
09:20:33 <bennofs> piezo: The packages might have been linked against different versions of their dependencies
09:20:55 <piezo> bennofs: sandboxes use the global packages, right ?
09:21:35 <piezo> or even child sandboxes specified with --sandbox
09:21:39 <bennofs> piezo: they don't use packages from ~/.cabal I think. This wouldn't be a good idea, because it wouldn't solve cabal hell effectively then
09:22:53 <bennofs> Suppose I have packages A, B, C, D where D depends on some version of C, A depends on C <= 3, D and B depends on C > 3, D. If you install A in a sandbox and B in a different sandbox, you cannot share the package D
09:23:42 <dcoutts> this is one of the differences between nix-style and simple sandboxing, nix-style does allow sharing
09:23:49 <piezo> oh, right I've just checked that...
09:24:06 <piezo> so what I'm doing is pointless :(
09:24:41 <bennofs> dcoutts: You mean nixos can handle this for haskell packages? I thought it was a limitation in GHC itself
09:25:33 <startling> Pretty sure it is.
09:26:05 <bennofs> I cannot depend on C >= 3 (directly) and C < 3 (dependency) in one program
09:26:30 <startling> bennofs: yeah.
09:26:49 <monochrom> read my http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox . you can have multiple cascaded package databases. this means you can have a tree of sandboxes, for example.
09:27:17 <dcoutts> bennofs: I'm not making a specific claim about nix or nixOS, I'm just talking about the technique (which we want to steal for Cabal).
09:27:41 <bennofs> dcoutts: and what is that technique?
09:27:51 <bennofs> I don't know how it would work with GHC
09:27:58 <startling> I think dcoutts means that nixos can avoid redownloading packages.
09:28:02 <piezo> monochrom: yes ! This is what i'm looking for
09:28:03 <dcoutts> bennofs: the nix style persistent package store
09:28:22 <monochrom> thank you for choosing monochrom!
09:28:36 <dcoutts> startling: not just redownloading, it can reuse instances between different environments, where as a simple sandbox approach does not allow that
09:28:47 <startling> yeah.
09:28:48 <piezo> monochrom: but I thought that ~/.cabal was the implicit root
09:29:06 <startling> but you can't have GHC use multiple versions of a package in any case.
09:29:12 <dcoutts> bennofs: yes to do this with ghc directly needs some changes in ghc/ghc-pkg
09:30:52 <monochrom> piezo: see the whole article. ~/.cabal has files but not any roster of packages
09:30:55 <bennofs> So any shared package would need to be linked against exactly the version of other packages I have in my sandbox in order to be shared
09:34:26 <piezo> monochrom: sorry, I meant ~/.ghc (user database)
09:35:00 <levi> It would be nice if all the identical versions of things were just links to the same copy, though.
09:35:49 <bennofs> But for it to be identical, all it's dependencies need to be identical too, so that's pretty unlikely in my view
09:35:50 <nomeata> nice strictness signatures: Strictness: <L,A><S(SS(LLLLC(S)LLLLLLLLLLLLLL)LLLLLLLLLLLLLL),U(U(U,U,U,U,U,U,U),U(U(U(U,U,U,U,U,U,U),U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U),A,A,A,A,A,C(U(U)),A,C(C
09:35:51 <nomeata> 1(U)),A,A,A,A,A,C(C1(U)))><S(SS),U(U,U)>m,
09:35:56 <nomeata> (that’s from Data.Complex)
09:36:39 <monochrom> that is strangely long
09:57:09 * hackagebot socketio 0.1.0.0 - Socket.IO server  http://hackage.haskell.org/package/socketio-0.1.0.0 (TingYenLai)
10:07:28 <robstewartuk1> Dr Simon Peyton Jones. It finally happened https://twitter.com/robstewartUK/status/407930376238411776/photo/1
10:08:20 <Eelis> robstewartuk1: does this have any effect on his work on ghc?
10:08:43 <robstewartuk1> It only serves to fuel it :-)
10:08:53 <Eelis> in what way?
10:12:11 * hackagebot socketio 0.1.0.1 - Socket.IO server  http://hackage.haskell.org/package/socketio-0.1.0.1 (TingYenLai)
10:13:10 <triliyn> Does anyone have tips for installing Idris on Windows?
10:14:31 <triliyn> I'm trying to cabal install it but there's one final dependency that's failing in the build phase
10:14:31 <alexrj> Yeah, the trickiest part is LLVM, which is optional
10:14:42 <shachaf> You can find some words of infinite wisdom at http://www.vex.net/~trebla/humour/tautologies.html
10:15:33 <alexrj> triliyn: are you installing any of the c dependencies first? you cannot just cabal install it
10:17:22 <triliyn> alexrj: oh, C dependencies aren't mentioned on the download page
10:18:24 <k00mi> triliyn: FYI, there is #idris
10:18:51 <triliyn> k00mi: thanks
10:21:40 <AVariedDeveloper> So I have a type-class "Exercise".  Anything which is an Exercise, can be queried for a position based upon time (Exercise x => x -> Double -> Vec3), and can draw a diagram based on time (Exercise x => x -> Double -> IO ()).  I realized I was thinking too much in terms of classical OO, when I realized you can't have a "IORef Exercise" or a "[Exercise]".  I've seen a few solutions I'm trying to choose between.
10:21:40 <AVariedDeveloper>   I could make a record of functions, but this feels a little messy/ugly to me, although maybe it shouldn't.  I could use existential types, but I've read those are generally a sign of poor design.  I could create an ADT instead of an instance, but I'm going to end up with like 20 exercises, each pretty large, and it'd be a huge mess to have them in one module IMO.  One final I thought I had was to do "data ExerciseBox
10:21:40 <AVariedDeveloper>  = EBCircle Circle | EBSquare Square | EBLine Line" and then have "boxPositionByTime EBCircle circle =  positionByTime circle".  That way I get the simplicity of one ADT in all of my 'client
10:21:41 <AVariedDeveloper> ' code, I get to split all the complex logic for each exercise into modules, but that one box type is still going to be a mess of (# of Exercises) x (# of functions).  Thoughts on how I should attack this?
10:25:44 <byorgey> AVariedDeveloper: use a record of functions.  I don't find that messy/ugly at all.  data Exercise = Exercise { position :: Double -> Vec3, draw :: Double -> IO () }
10:26:27 <edwardk> tomejaguar: implement it for 'ContT r'. that is the problem. there the monad occurs in negative position.
10:29:26 <AVariedDeveloper> byoregy:  You're right.  It felt ugly because it reminded me too much of the way I see people attaching functions ad-hoc to objects in JavaScript (I've seen some things), but with the static typing/explicit record it's actually pretty nice.  Only thing I can't see is a way to supply default values for some parts of it, while still requiring values to be supplied for other parts, but that's certainly an easy thing to live with
10:33:56 <skypers> hello
10:35:46 <AVariedDeveloper> Hello
10:36:07 <byorgey> AVariedDeveloper: typically the way you do that is by creating defaultExercise :: Exercise  with default values for everything, then when you want to override only some of them you can write e.g.   defaultExercise { draw = ... }
10:36:42 <c_wraith> or just write a helper function, if not every field has a useful default
10:36:58 <byorgey> AVariedDeveloper: if that doesn't make sense (e.g. some values are *always* required), you can write functions which take the required values and fill in the rest with default values
10:37:17 <AVariedDeveloper> byorgey:  Yeah, I saw that.  My biggest issue with that, is that you can't enforce the "creator" to fill in the rest of the fields (the ones which don't have defaults).  With type-classes you get a warning if you forgot to fill in one of the functions.
10:37:52 <byorgey> AVariedDeveloper: right, if some fields do not have defaults then you cannot use the defaultExercise method.
10:37:54 <AVariedDeveloper> byorgey:  That's a good point.  I mean either way, this is a very very small issue, it'll be easy enough to verify by hand that I'm passing in the parameters I need at the end of the day.  Just thinking hypothetically
10:39:24 <byorgey> AVariedDeveloper: out of curiosity, how are you drawing the diagrams?
10:40:12 <AVariedDeveloper> byorgey:  Out of lines, circles, simple shapes.  It gets filtered through an abstraction down to HOpenGL
10:41:09 <byorgey> OK.  I was going to suggest http://projects.haskell.org/diagrams, though if using OpenGL is important to you we don't have a good OpenGL backend at the moment
10:43:25 <AVariedDeveloper> Wow, that looks pretty nice!  Unfortunately OpenGL is very important because the exercise is just drawing a HUD above a 3d simulation, but maybe if I get far eough into the project and a nicer HUD becomes priority I'll look into working on a GL back-end for that
10:45:34 <byorgey> AVariedDeveloper: OK, makes sense
10:45:58 <byorgey> AVariedDeveloper: We do have the beginnings of an OpenGL backend already: https://github.com/bergey/diagrams-opengl
10:47:24 <AVariedDeveloper> The only potentially nasty thing, is some of these functions take advantage of a "self" argument to call other functions on itself.  If someone wanted to be really nasty they could do "function-1 myCircleRecord $ mySquareRecord" but that would almost have to be purposeful
10:50:00 <byorgey> AVariedDeveloper: you don't need to do that.  You can tie the knot when you create the record.  Instead of  { ..., foo :: Exercise -> Bar -> Baz, ... }  just have  { ..., foo :: Bar -> Baz, ... }  and then you can do things like  myExercise = Exercise { ..., foo = selfFunction myExercise, ... }
10:50:35 <byorgey> you can even package that up inside your function to create exercises
10:51:03 <AVariedDeveloper> hmm, perfect!
10:51:12 <byorgey> mkExercise requiredArg = let e = Exercise { ..., foo = selfFunction e, ... }  in e
10:51:55 <byorgey> see http://www.haskell.org/haskellwiki/Tying_the_Knot
10:52:39 <byorgey> well, that page is long and rambling, but just the basic idea is the important part
10:52:52 <byorgey> laziness + recursively defined values = cyclic data structures
10:53:43 <AVariedDeveloper> That's pretty cool actually, reminds me of some loeb/moeb article I tried to wrap my head around recently.  But its making sense nowq
10:55:15 <byorgey> yep, it's a similar idea, loeb is like this on steroids
10:55:24 <byorgey> and moeb is like loeb on... more steroids?
10:55:24 <AVariedDeveloper> Yeah haha
10:56:32 <byorgey> one caveat: if you create a recursive Exercise like this, the "self arguments" don't magically update when you update some other field
10:57:08 <byorgey> so if updating these Exercise values after they have been created is important, it will take some extra work.
10:57:19 <byorgey> but if they are immutable once created then you're all set.
10:58:22 <AVariedDeveloper> So... they are immutable, but once you take default values into effect, they will often be "modified" once.  Let's say I have a record which has three functions.  a, b, c.  b is supposed to be able to call "c" on the record.  I can do that easily enough with this concept.  Now, "a" is supposed to call "b".  If I have a default implementation of "a" (like we discussed wtih a default constructor above) is there
10:58:22 <AVariedDeveloper>  any possible way to tie the knot when b & c are added.  Due to the nature of the fact you aren't really modifying records but creating changed copies, there isn't really a way to have a, b, and c all reference the same thing in that manner, right?  Maybe I'm better off just having them take "Exercise" as a paremeter
11:00:02 <byorgey> OK, here's another possible solution, which works even with updates:  keep fields like  rawFoo :: Exercise -> Bar -> Baz  taking an Exercise parameter, but don't export rawFoo.  Instead, export a function  foo :: Exercise -> Bar -> Baz; foo e = (rawFoo e) e
11:00:35 <byorgey> i.e. foo takes care of applying the function to the self argument, whatever "self" happens to be at the moment.  You don't export rawFoo so there is no danger of it being used incorrectly.
11:01:03 <AVariedDeveloper> Hmm. That's interesting and could work.  Thank you for all of this help
11:01:09 <byorgey> sure.
11:01:21 <byorgey> good luck!
11:06:54 <ginmaniac> hey guys, I am using haskell with hmatrix package for a NN project. I have already implemented the NN in octave and noticed it to be much faster than haskell. So I have written two small "test" programes and octave is way faster: http://dpaste.com/1491639/ I don't understand why it is. I thought hmatrix and octave are using the same backend? Tell me if I am understanding or doing something terribly wrong, I
11:06:56 <ginmaniac> am very new to haskell.
11:08:42 <erisco> how do you write an escape sequence for a non-printable ascii character in Happy parser?
11:12:18 * hackagebot github-backup 1.20131203 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20131203 (JoeyHess)
11:12:20 * hackagebot git-repair 1.20131203 - repairs a damanged git repisitory  http://hackage.haskell.org/package/git-repair-1.20131203 (JoeyHess)
11:15:32 <cinimod> ginmaniac: I haven't looked but it may be that marshalling and un-marshalling are taking a long time in the haskell binding - you could try a more computationally intensive example. Alternatively you could try contacting the author of the package.
11:16:48 <cinimod> ginmaniac: hmmm 1000 x 1000 matrix multiplication should be reasonably intensive but there are 1e6 values to be marshalled
11:17:35 <cinimod> ginmaniac: And it uses lists to hold the matrix
11:17:48 <cinimod> ginmaniac: That's not going to be good
11:18:05 <razieliyo> hi
11:18:14 <razieliyo> is there any way to increase the stack level?
11:18:26 <razieliyo> max level I mean
11:19:32 <cinimod> ginmaniac: How about finding eigenvectors? That's O(n^3) so you shouldn't need much data to be marshalled.
11:19:59 <peddie> razieliyo: +RTS -K100M sets it to 100 MB for example
11:21:07 <ginmaniac> cinimod: thank you for your reply. so marshalling is the process of calling the 'backend' for example a C library with the data?
11:21:41 <ginmaniac> cinimod: okay, I try eigenvectors
11:22:04 <razieliyo> reading out there, it seems that I can't process too big data because some unknown reason
11:22:10 <razieliyo> ghc: panic! (the 'impossible' happened)
11:22:10 <razieliyo>   (GHC version 7.4.1 for i386-unknown-linux):
11:22:10 <razieliyo> 	linkBCO: >= 64k literals
11:22:12 <cinimod> ginmaniac: yes marshalling is the process of turning haskell data into data required by the foreign package
11:23:17 <razieliyo> just printing a big set of data, that's what I get
11:28:01 <c_wraith> razieliyo: I think that limit was removed in ghc 7.6
11:28:41 <razieliyo> c_wraith, hmm, I'll update my ghc, and let's try
11:31:34 <spaceships> i'd like to use a series of guard expressions but mzero throws error with my State/Reader/IO stack... can i redefine it ?
11:36:22 <bennofs> spaceships: what do you want to happen one mzero?
11:37:49 <spaceships> bennofs: return () ideally ...
11:38:04 <bennofs> spaceships: why use guard then at all if nothing happens?
11:38:36 <bennofs> (on failure)
11:38:42 <spaceships> good point :) i just like it since it doesn't need indentation
11:38:52 <spaceships> right now i have a series of nested when's
11:39:21 <bennofs> spaceships: then you don't want return () on failure really. You want to exit from the computation
11:39:26 <spaceships> yeah.
11:39:29 <bennofs> spaceships: Use the MaybeT transformer
11:39:36 <bennofs> > runMaybeT $ mzero
11:39:36 <lambdabot>   Not in scope: `runMaybeT'
11:39:44 <bennofs> @let import Control.Monad.Trans.Maybe
11:39:45 <lambdabot>  Defined.
11:39:59 <bennofs> > runMaybeT $ lift [1,2,3] >> mzero
11:40:00 <lambdabot>   [Nothing,Nothing,Nothing]
11:40:08 <spaceships> oooh, gracias!
11:40:55 <bennofs> runMaybeT gives you a 'm (Maybe a)'. If your a is () and you just want to ignore failure, you can use void to ignore the value:
11:40:59 <bennofs> @ty void . runMaybeT
11:41:00 <lambdabot> Functor f => MaybeT f a -> f ()
11:41:46 <spaceships> cool. thanks!
11:42:19 <bennofs> does anyone know if tasty supports 'switches' for providers (not just options) ?
11:43:26 <skypers> hey, what happens if I adjust a Map on a non-existent key?
11:44:05 <skypers> ok, nothing
11:44:09 <razieliyo> ghc: panic! (the 'impossible' happened)
11:44:09 <razieliyo>   (GHC version 7.6.3 for i386-unknown-linux):
11:44:09 <razieliyo> 	stack depth overflow
11:46:39 <skypers> ok, I need to 1. lookup ; 2. use maybe and insert/adjust/update
11:46:44 <skypers> sounds correct
11:47:32 <c_wraith> razieliyo: Report it on the GHC trac, then
11:47:43 <razieliyo> fine
11:50:35 <computionist> Does anyone know if there's a Qt binding for haskell?
11:51:34 <Feuerbach_> bennofs: do you mean a yes/no switch?
11:51:40 <klugez> Not an up-to-date one. This one seems to have seen work last: http://www.gekkou.co.uk/software/hsqml/
11:52:23 <ginmaniac> cinimod: I think you are right. I did some tests for example calculating the eigenvector of (100><100) [1..] is 0.026 for haskell and 0.097 for octave but as soon as it gets bigger (> 300*300) octave becomes faster.
11:52:58 <computionist> klugez: thanks. I'll look into it a bit.
11:54:20 <ginmaniac> cinimod: I am not quiet sure, but octave has to start its interpreter first, that's another disadvantage. I am not quiet sure what to do with my knowledge. It sucks to do a reimplementation in anther language if you know it will be much slower :/ thx for your help
11:58:33 <JuanDaugherty> computionist, hs favors gtk+
11:59:15 <JuanDaugherty> gin maniac, don't use interactive stuff if you're looking for somekina special efficiency
11:59:24 <JuanDaugherty> *ginmaniac
12:01:38 <worldsayshi> Hello haskellers! I'm trying to encode some haskell data to Json using Text.JSON and it almost works as intended. But my Map turns into a list when converted. I've found a section of Text.JSON that is controlled using a C-style macro: "#if !defined(MAP_AS_DICT)". I haven't worked with such syntax in Haskell before, what do I need to do to define MAP_AS_DICT? Do I need to recompile Text.JSON?
12:02:28 <worldsayshi> Perhaps that question is better for Stackoverflow...
12:03:39 <JuanDaugherty> my guess would be another pound define and yes, that compile unit and any others affected
12:09:15 <cariveri> I think Im urged to create a global variable. Is that possible in haskell?
12:09:25 <startling> cariveri, not "global", no.
12:09:35 <startling> well
12:09:47 <startling> global immutable "variables" are all Haskell has. :)
12:09:51 <tovarish> cariveri, with unsafePerformIO you can do thet
12:09:55 <tovarish> s/thet/that/
12:10:19 <startling> cariveri, but there's all kinds of tools for creating local variables with potentially-large scopes.
12:10:22 <startling> cariveri: e.g. State
12:10:56 <worldsayshi> I suppose I should be able to set a C macro variable in the cabal file...
12:11:18 <geekosaur> which package is that? check that it doesn't already have a flag in the cabal file
12:12:28 <bennofs> cariveri: If you really, really know what you're doing you can do this with unsafePerformIO. But note that this is frowned upon and has caused many issues in parallizing GHC for example (iirc)
12:12:43 <startling> please don't do it with unsafePerformIO.
12:12:48 <startling> likely State does all you need.
12:13:15 <bennofs> What is the proper way to wait for a TVar to match a certain criteria?
12:14:21 <simpson> bennofs: Probably test the TVar's contents to see if it meets your needs, and if not, `retry`.
12:15:01 <bennofs> simpson: that gives "Thread blocked indefinitely in an STM transaction"
12:16:09 <Feuerbach> that's indeed the proper way. If you get an exception, then you're doing something wrong
12:16:54 <Feuerbach> the exception is thrown when there's no thread that holds a reference to that var, so there's no chance it's going to be changed to meet the criterion
12:17:03 <Feuerbach> *no other thread
12:17:09 <simpson> ^^
12:17:25 <simpson> bennofs: BTW, the `check` utility function in Control.Monad.STM might help.
12:17:56 <simpson> check :: Bool -> STM () will retry the transaction unless its predicate is True.
12:18:15 <bennofs> yeah, I tried atomically $ readTVar myTvar >>= check . predicate
12:18:15 <cariveri> startling: could I perhaps pass through a variable and operate on it? see independent events should be able to see the current "data" so to speak. like relevant all places get access to x and can assign x.y = new value ?
12:18:38 <startling> cariveri: yep, that's exactly what State does.
12:19:13 <simpson> bennofs: So which other threads have a reference to myTvar there?
12:19:18 <cariveri> ok thank you. Ill look it up and see how far I can get.
12:19:37 <bennofs> simpson: I indeed had an error in my logic. It works now :)
12:22:10 <startling> cariveri: cool. :) We'd love to help if you have specific questions.
12:30:26 <worldsayshi_> I can't find how to set a cabal flag from a user package. Although I can find how to do it from the command line: http://www.haskell.org/ghc/docs/6.10.3/html/Cabal/builders.html#flag-control
12:35:15 <monochrom> huh? GHC 6.10.3? how old was that?
12:35:34 <worldsayshi_> Ah, think I found how: http://stackoverflow.com/questions/7456982/how-to-configure-build-dependencies-in-haskellcabal
12:39:38 <worldsayshi> Yeah, should look for up to date docs on that :/
12:40:54 <monochrom> bookmark http://www.haskell.org/cabal/users-guide/
12:41:38 <monochrom> hell, bookmark my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml , it has a link to that near the beginning
12:48:26 <bennofs> can different threads of a program have different working directories?
12:48:33 <monochrom> no
12:49:01 <bob___> hi
12:49:22 <bob___> Can I ask a question?
12:49:32 <bennofs> Don't ask to ask, just ask
12:49:42 <monochrom> don't answer to answer. just don't answer.
12:50:00 <bennofs> :)
12:50:21 <bob___> so I have this function but it always return (0,1) I really don't know why https://gist.github.com/dorafmon/be2f3747a0819c2cbb72
12:50:28 <bob___> Can you spot my mistake?
12:50:32 <bob___> Cheers :)
12:51:04 <bennofs> what is it supposed to do?
12:51:21 <monochrom> instead, I would ask: why it should not always return (0,1)?
12:52:17 <bob___> it should return something else actually
12:52:47 <monochrom> base case: when n=0, h n = h 0 = (0,1)
12:52:48 <bob___> its this function : h(n) =	 { (0,1)	if n=0 { (2ab-aa, aa+bb) where (a,b)=h(n/s)	if n is even { (b, a+b) where (a,b)=h(n-1)	if n is odd
12:53:17 <int-e> bob___:  try | odd n = (d, (c+d))
12:54:25 <wzy> Seems to me every branch will evaluates to (0, 1)
12:54:50 <bob___> to int-e: why?
12:54:56 <monochrom> yeah, if you want (b, a+b) for n odd, it's (d, c+d), not (c, c+d).
12:55:18 <int-e> bob___: well you didn't specificially say so but I'm assuming that your intention is to compute Fibonacci numbers
12:56:00 <bob___> Yes the first element of returned tuple should be fib number
12:56:03 <Yuu-chan> Please recommend me some convenient 2d graphics library for writing a very simple game. Currently I'm looking at SDL bindings.
12:56:25 <triliyn> Yuu-chan: gloss is also pretty nice
12:56:32 <startling> seconding gloss.
12:56:38 * bennofs too
12:57:29 <Yuu-chan> Thanks!
12:59:08 <bob___> thanks, problem solved
12:59:57 <monochrom> you may have perhaps not used "where", but used "let" instead. then you could use "a,b" in both branches without clash
13:00:24 <monochrom> | even n = let (a,b) = h (div n 2) in ((2*a*b)-(a*a), ((a*a)+(b*b)))
13:00:41 <monochrom> | odd n = let (a,b) = h (n-1) = (b, a+b)
13:01:07 <monochrom> err, | odd n = let (a,b) = h (n-1) in (b, a+b)
13:01:18 <bob___> Than's nice :)
13:01:21 <bob___> good to know
13:02:04 <bob___> why I cannot have |even n = (a,b) where a = ... , b= ...
13:02:24 <bob___> |odd n = (a,b) where a = ...; b= ...
13:02:36 <bob___> I tried this but it gives me syntax error
13:02:51 <int-e> you can write  h n | even n = ... where ...; h n | odd n = ... where ...; etc.
13:02:57 <fizruk_> where's are common for all guards
13:03:11 <bob___> oh okay
13:03:15 <bob___> thanks guys
13:03:32 <int-e> it's just how the syntax is defined.
13:03:40 <bob___> nice language, I am a beginner, but it's very elegant
13:04:52 <blablub> is there a way in GHC to use arrow notation with an arrow that has a type class constraint on its arguments?
13:06:13 <erisco> what is the most practical haskell regex library? (ie in common use)
13:07:49 <bobfang> whois bobfang
13:10:25 <bobfang> \whois ecube
13:10:49 <simpson> bobfang: Hi! Welcome to #haskell. Are you interested in learning more about Haskell?
13:11:27 <bobfang> Yeah sorry about that, I am new to irc
13:11:36 <bobfang> sorry for the trash messages
13:11:40 <simpson> Happens.
13:12:34 * hackagebot universe 0.4.0.4 - Classes for types where we know all the values  http://hackage.haskell.org/package/universe-0.4.0.4 (DanielWagner)
13:13:00 <ReinH> erisco: so you've gone through happy and alex and now you want to use regexp? Why not just use parsec?
13:13:50 <ReinH> erisco: http://ocharles.org.uk/blog/posts/2012-12-10-24-days-of-hackage-parsec.html
13:13:51 <erisco> ReinH, I am trying to keep things simplistic. Happy is fairly simple. Alex is not. Parsec is a parser combinator and I do not want that route
13:14:07 <ReinH> Why do you not want that route?
13:14:12 <ReinH> It might well be the best route.
13:14:52 <erisco> if I wanted parser combinators I have my own library
13:15:02 <quchen> I think Parsec is a lot simpler than Regex.
13:15:13 <quchen> Also readable, maintainable, typesafe and all that.
13:15:30 <quchen> Unless you really want quick-and-dirty regex, use a parser.
13:15:50 <erisco> ... thanks but I am looking for regex
13:16:05 <bennofs> ocharles: In your new tasty post, maybe you should also mention tasty-th ? (A straight port of test-framework-th to tasty)
13:16:20 <ParahSailin> parsec is so quick to use
13:16:23 * ReinH sighs
13:16:54 <ReinH> @hackage regex-base
13:16:54 <lambdabot> http://hackage.haskell.org/package/regex-base
13:17:02 <ReinH> has a number of different backends, including... parsec
13:17:26 <ParahSailin> does it do TH tricks to make a parsec parser from a regex?
13:17:34 <ReinH> But I seriously don't understand how anyone could prefer regexp over a library like parsec
13:17:48 <erisco> it is terse and simplistic
13:18:09 <ParahSailin> you can go back to perl and we won't think any less of you
13:18:35 <ReinH> erisco: have you even looked at parsec?
13:19:18 <blablub> i prefer regex over parsec when the expression comes from some external source (e.g. user input)
13:19:25 <Luke> erisco: parsec looks like a human readable protocol spec and regexp is well... regexp
13:19:33 <Luke> i prefer the human readable
13:20:01 <erisco> I am not going to justify myself. I am just looking for regular expressions. I have looked at the base package but am seeking documentation for it
13:20:02 <Luke> though I do agree that in the total of programmers in the world, regexp is probably more recognized than parsec
13:20:21 * ReinH shrugs
13:20:25 <ReinH> Well, good luck then
13:20:50 <ReinH> Google seems to know where the docs are.
13:21:56 <blablub> erisco: have a look at hackage, there are plenty of backends
13:22:18 <blablub> erisco: which one is best may depend on taste
13:22:49 <blablub> erisco: PCRE for example adds a dependency to libpcre ... posix-like otoh have less features, and so on
13:23:27 <ReinH> There's an entire HaskellWiki page on regular expressions.
13:23:43 <ReinH> It's the first result for googling about haskell regular expressions.
13:24:01 <ocharles> ReinH: thanks for the kind words about linear :)
13:24:05 * ocharles is just checking IRC logs
13:24:27 <ocharles> bennofs: thanks, didn't know about that one
13:24:30 <ocharles> must have missed it!
13:24:45 <chrisirc> I'm looking for a clear explanation how to specify whether a named expression (or function result) should be shared (reused) or not (recalculated).
13:25:00 <chrisirc> explanation *on how to..
13:25:16 <ReinH> ocharles: Knowing that distribute is a thing is quite helpful.
13:25:54 <ocharles> bennofs: oh it's yours, I guess? awesome :)
13:25:55 <chrisirc> It seems like when adding/removing strictness annotations, sharing behaviour changes "randomly".
13:26:16 <ReinH> ocharles: how to "specify"? Or do you want to be able to reason about when the compiler will share results?
13:26:46 <ocharles> ReinH: was that q for chrisirc ?
13:26:49 <ReinH> chrisirc: you might benefit from creating a small test case and then dumping GHC core to analyze the differences between different strictness annotations
13:26:56 <ReinH> ocharles: sorry
13:27:13 <ReinH> chrisirc: I don't think it's "random", but it might not be clear what's happening without looking under the hood
13:27:21 <Feuerbach> ocharles, bennofs: I didn't know about it, too. Will add to the README right away
13:27:41 <ocharles> Feuerbach: can you add tasty-ant-xml, if you haven't already? I was meant to PR your docs on that, but forgot :)
13:28:39 <chrisirc> ReinH, that's what I feared I would have to do... I would have hoped that the language designers specified this somewhere.
13:29:21 <quchen> chrisirc: In general things with names (... only, i.e. no parameters) are kept in memory, and not calculated more than once. If you have a top-level binding "fibo = <list of fibo numbers>", then values calculated will stay calculated. If you have a definition that runs out of scope (e.g. fibo in a "where" clause) then it is lost and recalculated again should you call the parent function again.
13:29:36 <Clint> dmwit: which representable-functors did you test universe 0.4.0.4 with?
13:29:38 <Feuerbach> ocharles: oh, another omission!
13:30:00 <ReinH> chrisirc: It is specified by, e.g., http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=4BD17FFFBAFCFFE1026C038702BA72E5?doi=10.1.1.35.2016&rep=rep1&type=pdf
13:30:04 <quchen> chrisirc: Functions are always re-calculated on every call, so when you have a function "fibo n = <n-th fibonacci number>" that will do the entire calculation each time you give it an "n" no matter what.
13:30:19 <ciaranm> that's not how you link to a DOI, ReinH...
13:30:28 <ReinH> ciaranm: a DOI?
13:30:38 <Feuerbach> bennofs: btw, what was your "switches" question about? did you figure it out?
13:30:42 <chrisirc> quchen, I think "in general" is essential in your explanation, since I've got a case where just adding "!" will make some value unshared even though it doesn't go out of scope.
13:30:47 <ciaranm> ReinH: see the DOI in the URL!
13:31:09 <ReinH> ciaranm: I don't understand citeseer urls
13:31:13 <quchen> chrisirc: Could you paste the code?
13:31:27 <quchen> chrisirc: I don't think strictness annotations change menoization.
13:31:35 <chrisirc> quchen, I'll have to rewrite it since I'm not allowed to post it.
13:31:39 <ciaranm> ReinH: that probably won't work for anyone else because of the sessionid thing in there. just google DOI 10.1.1.35.2016 for it...
13:32:45 <ReinH> ciaranm: sigh, why does citeseer do this stupid stuff
13:32:59 <ReinH> @google A Natural Semantics for Lazy Evaluation
13:33:07 <lambdabot> http://www.cse.chalmers.se/edu/course/DAT140_Types/Launchbury.pdf
13:33:08 <lambdabot> Title: A Natural Semantics for I&y Evaluation
13:33:26 <chrisirc> ReinH, I got the pdf, thanks
13:33:32 <chrisirc> reading it now.
13:33:45 <ocharles> Good ol I&y evaluation
13:34:10 <bennofs> Feuerbach: I ended up using optionCLParser (or how was that member called?)
13:34:20 <bennofs> Feuerbach: I wanted to have a boolean toggleable option
13:34:22 <chrisirc> yeah, the title is "A Natural Semantics for Lazy Evaluation"
13:34:31 <ReinH> hahaha
13:34:34 <bennofs> Feuerbach: like optparse-applicatives switch parser
13:34:46 <Feuerbach> bennofs: right
13:34:49 <ciaranm> ReinH: well the point of DOIs is that you don't have to give URLs for them
13:35:35 <Feuerbach> bennofs: you just define a (wrapped) Bool option, and then tweak the CLI parser
13:35:37 * monochrom likes "a natural semantics for lazy evaluation". good paper.
13:36:06 <bennofs> Feuerbach: that's what I did. I just thought that maybe there was a more integrated solution :D
13:36:29 <ReinH> ciaranm: If you say so :) Like I said, I don't know how to citeseer
13:36:31 <monochrom> the "natural" there is not daily English. it specifically means big-step operational semantics
13:37:37 * hackagebot data-stringmap 0.9.2 - An efficient implementation of maps from strings to arbitrary values  http://hackage.haskell.org/package/data-stringmap-0.9.2 (SebastianPhilipp)
13:37:58 <monochrom> (well, I guess the first person who chose the word "natural" (Stratchey? Plotkin?) felt it natural.)
13:38:23 * monochrom feels that small-step is more natural :)
13:39:43 <monochrom> chrisirc: see also my http://www.vex.net/~trebla/haskell/lazy.xhtml
13:40:02 <monochrom> it is "lazy" that specifies sharing. call-by-name alone doesn't.
13:42:21 <ReinH> a.k.a. "call by need"
13:45:07 <ReinH> So how specifically do strictness annotations affect sharing? Do they affect normalization?
13:46:17 <Feuerbach> sharing - no; normalization - yes
13:46:19 <rotemy> Hi, I need some advice with Aeson for a simple JSON parsing task - I've been using Generics for parsing simple lists of objects, but I can't figure out a way to easily extract it from a deeply nested structure (for instance, if I have {"result": {"a": {"b": {"c": [...]}}}}, I need to extract what "c" holds). Any quick/easy way to do this without declaring lots of intermediate data types?
13:46:34 <cschneid> rotemy: check out lens-aeson.
13:47:43 <ReinH> Feuerbach: Are you saying that strictness doesn't affect sharing?
13:48:11 <Feuerbach> ReinH: correct (to the best of my knowledge)
13:48:14 <rotemy> cschneid: oooh, looks interesting (although very black-magicky). Thanks!
13:48:52 <cschneid> rotemy: it's fairly complicated in how it works, but is super easy in how to use it
13:49:05 <ReinH> Feuerbach: But if call-by-need sharing depends on normalization, and strictness affects normalization...
13:49:15 <rotemy> cschneid: I see. Will give it a try. Thanks a bunch!
13:49:51 <Feuerbach> what do you mean by "call-by-need sharing depends on normalization"?
13:50:00 <cschneid> rotemy: most importantly you can chain them.  So   json ^? key "result" . key "a" . key "b" . key "c" . _Array
13:50:05 <cschneid> or something like that would extract what you want there
13:50:36 <ReinH> Feuerbach: for instance, (\x -> x * x) (f 1 2) will be normalized to let z = f 1 2 in (\x -> x * x) z, right?
13:51:05 <ReinH> And this let binding is what allows sharing, right?
13:51:40 <rotemy> cschneid: So then I don't really need the Generics behavior, right? because I can just extract the fields I need...
13:51:54 <rotemy> cschneid: so I don't need to derive Generic etc.
13:52:02 <cschneid> rotemy: dunno, never used the generics stuff. From what I understand it's useful to build auto-parsing structures.
13:52:14 <cschneid> rotemy: but I'm a newbie to haskell too :)
13:52:19 <cschneid> hell if I know what I'm doing
13:52:28 <rotemy> cschneid: LOL, feel that way too
13:52:30 <dmwit> Clint: 3.2.0.2
13:52:39 <monochrom> I am not comfortable with "depends on normalization". you have to normalize, and normalize only one way. when you don't have a choice, I can't say "depends". there is no choice. depends on what choice?
13:52:40 <rotemy> Just trying to understand how to reasonably use JSON APIs with it
13:52:44 <cschneid> rotemy: for me, I keep getting better, and that feeling never even shifts :)
13:52:51 <Feuerbach> ReinH: not "normalized" (because it's not a normal form yet), but roughly yes
13:53:06 <cschneid> rotemy: yeah, for practial behavior, Aeson to parse into real structures, and lenses (either for the data structures, or the raw json)
13:53:21 <cmtptr> "func :: (Foo f, Bar b) => f -> b" vs "func :: Foo -> Bar"  I have a very lose grasp on the difference between these two ways of writing a signature.  can someone explain or point me to something that explains?
13:53:23 <dmwit> Clint: But I saw that there were some oddities with 3.2.0.1, which I tried to rule out by an appropriate constraint on comonad-transformers.
13:53:26 <dmwit> Clint: How'd I do?
13:53:27 <monochrom> and yeah, make it "desugar"
13:54:04 <monochrom> anyway, strictness annotation does not change sharing, at least I haven't observed an instance.
13:54:06 <Clint> dmwit: http://lpaste.net/96531
13:54:18 <ReinH> monochrom: acknowledged
13:54:33 <Clint> (with 3.2.0.2)
13:54:33 <ReinH> Feuerbach: How does strictness affect normalization?
13:54:44 <Feuerbach> ReinH: sorry, I think I misunderstood. I guess you're referring to "normalization" in the paper, not the reduction-normalization
13:54:56 <cadabra> I have a lazy problem... Try this: $ echo foo > bar; $ ghci: writeFile "bar" (show (read "asdf" :: Int)). After prelude.read fails, "bar" is empty.
13:55:27 <Feuerbach> (I just opened the paper — have seen it a long time ago)
13:55:57 <ReinH> Feuerbach: Ah :) Which normalization are you referring to?
13:55:57 <rotemy> cschneid: BTW running the examples in GHCi fails (it expects Text, not [Char] for keys etc.)
13:55:58 <cadabra> I guess I need to force eval the second argument before invoking writeFile? Is there a general pattern for this kind of thing? Making sure your inputs are good before you go ahead and do something.
13:56:13 <cschneid> rotemy: yeah, you'll want the overloadedstrings extension
13:56:16 <dmwit> cadabra: Yes, there is a general pattern: only use total functions.
13:56:22 <cschneid> it's just good. :)
13:56:29 <Feuerbach> ReinH: I was referring to the usual lambda-calculus-normalization (under beta-reduction)
13:56:38 <cadabra> dmwit: are you referring to read?
13:56:41 <dmwit> I am.
13:56:47 <cschneid> rotemy: also I just made up that line. No idea if it works. :-p
13:56:53 <dmwit> Clint: (I'm still trying to figure out your complaint, by the way.)
13:56:55 <cadabra> How can I tell if a function is total by its signature?
13:57:03 <monochrom> no, cadabra
13:57:04 <dmwit> cadabra: cannot.
13:57:20 <cadabra> Right. So the type system lied to me :/
13:57:30 <dmwit> The type system never promised totality.
13:57:33 <dmwit> So it didn't lie.
13:57:34 * rotemy is reading about OverloadedStrings
13:58:04 <monochrom> sometimes, the type system doesn't lie, in fact tries to tell you "you have non-termination" by inferring a type too-good-to-be-true
13:58:11 <cadabra> Let's phrase it like this: How can an end user ensure that they're only using total functions?
13:58:13 <rotemy> cschneid: ok, just got a tiny bit wiser. Thanks!
13:58:43 <cschneid> rotemy: basically instead of "Foo" being :: [Char], it's defined as IsString, which can be auto-cast into String, Text, ByteString, as requested by a function.
13:58:50 <dmwit> cadabra: It's a very hard problem. For the nonce, perhaps the best advice I can give you is "read the documentation".
13:58:52 <cschneid> it makes the whole thing so much nicer to work with
13:59:23 <rotemy> cschneid: ok, this lens thing is pretty awesome
13:59:25 <dmwit> cadabra: Typically, languages that try to track totality spend rather a lot of effort on that problem.
13:59:28 <monochrom> cadabra: consider http://perl.plover.com/classes/OOPSLA/samples/slide068.html :)
13:59:34 <dmwit> cadabra: and often get it wrong =)
13:59:42 <rotemy> I wonder why it's not the top hit in Google when searching for "parse json haskell"
14:00:19 <rotemy> at least it should be mentioned in the same first hit as the "traditional" aeson approach (which stars in all top 10 hits more or less)
14:00:20 * dmwit mumbles something about the halting problem
14:01:11 <cschneid> rotemy: lenses are super complicated weird things. But they make actually programming haskell much nicer.
14:02:10 <Feuerbach> lenses are simple. 'lens' is complicated.
14:02:12 <monochrom> cadabra: you could say: ban handwritten recursion, and compose only from a chosen subset of functions from let's say Prelude. compliance to this can be syntactically checked. if the chosen subset is large enough, you can still write many practical programs.
14:02:18 <rotemy> cschneid: well, it's not that the default Aeson business is any less weird
14:02:24 <rotemy> cschneid: the :. notation and all that
14:02:53 <dmwit> Clint: Well, at least here, rep-functors has instance Representable w => Representable (TracedT s w) in src/Data/Functor/Representable.hs:163.
14:02:56 <dmwit> Clint: Do you not have that?
14:03:32 <monochrom> but I personally couldn't care less. oh I care about termination, I prove my program terminates. I don't care about restricted languages.
14:03:38 <cadabra> Is there a total variant of read?
14:03:45 <dmwit> Clint: Which would mean to me that your error is off its rocker, since Representable f is in the context and hence Representable (TracedT s f) should be provable.
14:03:48 <dmwit> cadabra: reads
14:03:52 <nomeata> luite_: Hi. Is hdiff down?
14:03:55 <ReinH> @hackage safe
14:03:56 <lambdabot> http://hackage.haskell.org/package/safe
14:04:03 <donri> Feuerbach: yeah, i miss the simplicity of the costate comonad coalgebra...
14:04:26 <ReinH> cadabra: safe includes a lot of total replacements for partial functions from Prelude
14:04:38 <tolt> This may seem like an odd request but does anyone know a book similar to Effective Java but written for Haskell?
14:04:40 <cadabra> Thanks
14:04:51 <donri> RWH?
14:04:56 <donri> don't know the java one though
14:05:03 <monochrom> cadabra: Text.Read has readMaybe. Prelude has reads. for reads, see my http://www.vex.net/~trebla/haskell/reads.xhtml
14:05:14 <dmwit> Clint: Maybe I can ask you to try to work out what's gone wrong on your machine?
14:05:14 <davidfetter_disq> RWH?
14:05:24 <levi> I don't remember much about what's in Effective Java.
14:06:13 <geekosaur> @where rwh
14:06:14 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:06:18 <monochrom> hmm, yeah, I may have seen the book Effective Java a long long time ago
14:06:30 <tolt> Alright. I guess I'm looking for something that explains ways to write haskell in some sort of semi standardized way
14:06:45 <levi> There are a lot of handy, practical things in Real World Haskell, but it also aims at teaching Haskell to newcomers, so some things are written in a way that you wouldn't really do them in practice because the things you'd really do haven't been introduced yet.
14:06:50 * geekosaur is tempted to say he didn't know there was such a thing, but that'd just be mean >.>
14:07:02 <monochrom> haha
14:07:08 <tolt> levi, exactly. I've read RWH.
14:07:33 <Hodapp> I've avoided reading RWH at lunch because it takes to long to explain to coworkers what Haskell is.
14:07:35 <monochrom> no, there is no haskell book that says, "write this way, it's semi standardized, don't write alternatives"
14:07:50 <jonsterling> My heart leaps whenever I see “RWH”, since I assume it's referring to Robert W Harper...
14:07:58 <levi> My suggestion would be to read good Haskell programs.
14:08:18 <Taneb> Hodapp, I have actually submitted as part of my course to be assessed a blog post I wrote that basically says "Haskell doesn't suck"
14:08:21 <monochrom> and I know why. it is because the language itself already nurtures good taste in you. I can safely tell you "go with your heart", and you will still not write bad code.
14:08:22 <quchen> tolt: You mean a style guide? There are many of those. Here's the one for GHC: https://ghc.haskell.org/trac/ghc/wiki/Commentary/CodingStyle
14:08:23 <tolt> monochrom, that's not exactly what I mean. Effective Java discusses things like when to actually throw exceptions.
14:08:37 <quchen> Oh. That's something else then. Ignore my link.
14:09:02 <monochrom> well then, what I just said applies even more
14:09:16 <maurer> jonsterling: What's wrong with bob?
14:09:17 <levi> Haskell's community is not quite as settled about things like that as Java's community is.
14:09:19 <Hodapp> Taneb: In my case, it's just hard to explain, because I have a lot of coworkers who can understand why you might want to program, but can't understand why you'd ever need something besides C/C++ to do it effectively.
14:09:33 <jonsterling> maurer: It leaps in a good way, to be clear!
14:09:50 <Eduard_Munteanu> Are there any proposals / tentative implementations of placeholders for types? Something that let's you write things like "foo :: Maybe _" and the '_' is inferred.
14:10:02 <Eduard_Munteanu> s/let's/lets/
14:10:06 <levi> Some people use exceptions, others prefer to use some variety of error-handling monad.
14:10:21 <jonsterling> maurer: Currently working my way through his HoTT lectures. Bob Harper Type Theory Storytime has literally replaced television for me.
14:10:30 <monochrom> but! why don't I bring up http://www.drmaciver.com/2009/03/exceptions-for-control-flow-considered-perfectly-acceptable-thanks-very-much/ for good measure :)
14:10:34 <levi> Both can be examples of 'effective Haskell' as well.
14:10:43 <Eduard_Munteanu> I'm asking because xmonad layout types are horrible, and this might help get some meaningful type sigs.
14:11:15 <maurer> jonsterling: Ah. I am in the class you are watching the lectures from :P
14:11:33 <jonsterling> maurer: I envy you!
14:12:18 <levi> maurer: Well, he's not a huge fan of Haskell, if you'd fault him for that.
14:13:02 <thebnq> jonsterling: are these lectures publicly available?
14:13:10 <monochrom> Hodapp: perhaps don't explain anything. just say "I read this book for leisure". no one is supposed to question "why do you need leisure".
14:13:26 <maurer> levi: Some of his opinions tend to get blown out of proportion - most of his haskell-hating is directed at the people who think it's a perfect proven safe paradise like his idealized sml is
14:13:43 <Hodapp> maurer: you mean it's not?!
14:13:49 <maurer> :P
14:14:13 <jonsterling> thebnq: Yeah! http://www.cs.cmu.edu/~rwh/courses/hott/
14:15:14 <levi> maurer: I think he's pretty clear about his opinions, and I think he does a reasonable job of backing them up, and also admitting on occasion that Haskell's design choices aren't entirely without merit. ;)
14:15:16 <thebnq> jonsterling: wow nice thanks!
14:15:39 <jonsterling> levi: Agreed! Haskeller's would do well to listen to at least most of Bob's criticisms, particularly those regarding ADTs, laziness, and type classes vs. modules.
14:15:55 <jonsterling> thebnq: No problem. I've got them all downloaded onto my iPad, wonderfully entertaining.
14:16:47 <simpson> Some of his opinions are insufferable, though. I am hard-pressed to put up with the argument that non-statically-typed languages are "typeless" or "untyped".
14:17:18 <maurer> simpson: If you are using a particular definition of the word typed, they are either untyped or unityped
14:17:28 <levi> simpson: His argument is perfectly sound, it just hinges on a particular definition of 'type'.
14:17:39 <lispy> they're not based on type theory. But they certainly have some notion of type.
14:17:49 <lispy> levi: right
14:18:19 <maurer> simpson: Specifically, he is using the notion of type where you know some property about a variable or expression without having to solve a potentially turing complete problem
14:18:19 <simpson> After one has encountered ANS FORTH, one has a new appreciation for the "subtle" difference between types which are irrelevant or only contribute to behavior and not interface, and truly untyped languages.
14:18:38 <Peaker> jonsterling: Bob says Haskell has no Nat type because of laziness. But we do have strictness annotations?  The question here is the default
14:19:20 <levi> A "dynamically-typed" language is uni-typed with a single sum-type that is classified at run-time to its various cases.
14:19:38 <Peaker> jonsterling: I think Bob says a lot of weird things about Haskell that seem like Haskell is something he read about (e.g: "unsafePerformIO to get anything done", wat?)
14:19:39 <shachaf> Peaker: No, even data N = Z | S !N has _|_
14:19:50 <Hodapp> is Bob the guy behind existentialtype?
14:19:54 <maurer> Hodapp: yes
14:20:14 <simpson> levi: Yeah, that's the kind of thing that just sounds like it is coming from somebody that doesn't actually understand the data models behind these various languages.j
14:20:29 <Hodapp> he comes off like an insufferable asshole in the "dynamic typing is static typing" post
14:20:29 <levi> If you look at an interpreter for a dynamically-typed language, it'll be clear to you that that's *precisely* what dynamic typing is.
14:20:29 <maurer> Peaker: Yeah, it turns out that because of the top level laziness being unremovable, you can't actually describe a nat. By default you use a conat, and if you're careful you have Nat + Bottom
14:20:33 <jonsterling> simpson: Oh please, "Somebody decided this was a type, even though it isn't, so it must be!"...
14:20:34 <Peaker> shachaf: !Nat exists as a (semi-)type
14:20:50 <donri> shachaf: not when promoted though, right?
14:20:58 <Peaker> maybe pseudo is a better word there
14:21:00 <maurer> Peaker: My understanding is that strictness is only usable in arguments to constructors
14:21:04 <levi> All data is stored in some sort of union type and is distinguished at run-time via tags or something.
14:21:07 <maurer> Peaker: e.g. I couldn't write 3 :: !Nat
14:21:10 <monochrom> if you ask me, Harper should listen to my criticism
14:21:10 <simpson> levi, jonsterling : Many object-based languages have quite strict and strong type annotations for object literals.
14:21:17 <maurer> (assuming 3 were sugar for S S S Z
14:21:28 <jonsterling> And I'm done. Bye #haskell :(
14:21:29 <maurer> monochrom: Namely?
14:21:45 <monochrom> well I'm lazy, I'll write some when he listens :)
14:21:58 <levi> simpson: If they're checked at compile time, then they introduce static types.
14:22:04 <maurer> simpson: You can have that, but that's static typing
14:22:17 <maurer> simpson: In fact, you can actually argue that you're not only in static typing, but are closer to haskell than ML
14:22:25 <maurer> simpson: Because objects are negative types, just like all haskel types
14:22:29 <maurer> *haskell types
14:22:29 <maurer> :P
14:22:37 <Hodapp> negative types?
14:22:37 <simpson> levi, maurer : So a language where e.g. `1` must be an integer literal is statically typed there?
14:23:01 <maurer> simpson: I mean, that portion is
14:23:22 <maurer> Arguably, all languages are statically typed
14:23:26 <maurer> it's just that some of them only have one type
14:23:29 <levi> simpson: Some languages have a few primitive static types along with their single dynamic union type.
14:23:44 <maurer> What you're suggesting there is that they might have 2 types, one of which is an integer, and the rest is everything
14:23:48 <Peaker> Bob has a lot of awesome articles, but I think he's a bit irrational, sometimes (apparently, at least) intentionally dense when it comes to competitors of his own baby, SML.
14:24:29 <simpson> levi: Okay, so this is statically-typed Python, right: [42, 4.2, "str", u"\N{SNOWMAN}", {}]
14:25:03 <Peaker> e.g: augustuss shows Bob example "if" as a function, Bob says "if" is just a special case of "case" so is lazy because "case" is
14:25:10 <levi> simpson: The secret to understanding his argument is not to get defensive over the definitions of terms. If you take his terminology at face value and work out what he's saying, you'll see he's quite right about it, it's just that most people are talking about a different thing as a 'type' than he is.
14:25:25 <maurer> simpson: No, in fact none of that is
14:25:28 <simpson> levi: I hear the same thing about many a New Age guru.
14:25:37 <Clint> dmwit: so one relevant datum i neglected to mention is that representable-functors has been patched to build with comonad 4.0
14:25:40 <Hodapp> levi: He's 'right' about it, but he is also a dick about it.
14:25:44 <maurer> simpson: In python, there is no restriction over what you can do with an integer literal
14:25:48 <simpson> maurer: But it's six literals, all of which are known to the compiler, and all of which can only have one type.
14:25:53 <maurer> simpson: Nope
14:25:58 <maurer> simpson: 42 can have a lot of types
14:26:05 <dmwit> Clint: Right, I explicitly reject comonad-4.0 in the dependencies (right?).
14:26:09 <Clint> right
14:26:18 <maurer> simpson: the only one the compiler could even _possibly_ know is {}
14:26:20 <Peaker> simpson: Python's different types are a lot more like a big sum type's data constructors than they are like static types
14:26:31 <dmwit> Clint: So that shouldn't be a problem?
14:26:40 <maurer> simpson: the rest depends on the presence or non-presence of functions in a variety of classes
14:26:44 <dmwit> Clint: nomeata put some details on the same problem on the github issue tracker
14:26:53 <Peaker> (i.e runtime tags, not types)
14:27:03 <dmwit> Clint: But I'm having trouble even getting the package *configured* with the versions he's claiming cabal picked. -_-
14:27:29 <simpson> Peaker: Aren't e.g. CPython's actually more like a bunch of different types all belonging to a single typeclass, in terms of implementation?
14:28:06 <Clint> dmwit: this may become easier for us to get a handle on once edwardk fixes adjunctions
14:28:12 <Clint> or i could just be very, very confused
14:28:14 <Peaker> simpson: more like all are of PyObject record type, filling in different values for the fields
14:28:37 <simpson> Peaker: Which IIUC is similar to how GHC chooses to implement typeclasses, right?
14:29:03 <levi> simpson: Having a parser classify a literal integer as some sort of number does not constitute a type system. Unless the runtime is storing it as an unboxed number in the same heap as everything else, it's in some sort of a tagged union data type that constitutes the single static type of the runtime.
14:29:04 <simpson> I'm very confused by this assertion that 42 could be anything *but* an int literal.
14:29:05 <nomeata> dmwit: oh, yes, sorry, I only later noticed that this is against a patched version of representable-functors, including your patches at: https://github.com/ekmett/representable-functors/pull/2
14:29:06 <Hodapp> "is implemented by" does not imply "is".
14:29:18 <Peaker> simpson: it passes records out-of-band. the values of the instance types aren't records
14:29:24 <nomeata> dmwit: I guess I shouldn’t have asked you to upgrade if your dependency hasn’t yet
14:29:38 <simpson> levi: If everything were stored as an unboxed chunk of data on the heap, then wouldn't we have a Forth-like untyped system?
14:29:54 <levi> simpson: If you didnt' also have a static type system, then yes.
14:30:15 <monochrom> perhaps it's more productive to write code
14:30:18 <dmwit> nomeata: hrm
14:30:26 <dmwit> nomeata: So, I'm not sure I understand where I stand at this point, then.
14:30:47 <simpson> levi: Okay. So does RPython change this point of view at all?
14:30:49 <dmwit> nomeata: Is the "universe" that's up on Hackage incompatible with the versions of its dependencies it claims it works with that are up on Hackage?
14:31:04 <dmwit> that question was awkward
14:31:06 <nomeata> dmwit: likely not
14:31:10 <dmwit> okay
14:31:22 <dmwit> Okay, but we want to make sure it's future-proof, too.
14:31:29 <nomeata> dmwit: the problem probably only arises with the patched versions in debian – sorry about that
14:31:30 <levi> simpson: The fact is, a "dynamic type" system consists of a single static type called 'value' or something that is a sum-type of all the kinds of values that the runtime can distinguish. You can either call it "dynamic typing" or "runtime classification of values", it amounts to the same thing.
14:31:37 <dmwit> nomeata: So I was just about to post a comment to the github issue, but now maybe I ask you directly.
14:31:48 <dmwit> nomeata: What version of comonad is it trying to build against?
14:31:50 <dmwit> (if any)
14:32:20 <simpson> levi: Okay. So when RPython takes the output from a Python compiler and turns it into fully-static native code by inferring all types, including user-defined classes and subclasses, is it somehow reducing the dynamic types to static types?
14:32:49 <nomeata> dmwit: 4.0
14:33:07 <dmwit> ok
14:33:13 <Peaker> simpson: yes, "somehow" = "inference" and not possible in the general case unless you just infer "Object" everywhere inference fails
14:33:46 <dmwit> Okay, so representable-functors as it is on Hackage has a comonad<4 constraint. So I'm a little less worried about that, then.
14:34:16 <simpson> Peaker: Alright. So then the compiler *does* encode sufficient information into its output to determine that e.g. 42 is uniquely an int.
14:34:18 <nomeata> dmwit: yes
14:34:19 <dmwit> I'm not sure I want to check out the repositories of my dependencies just yet if they're still in flux.
14:34:39 <maurer> simpson: RPython is specifically compiling a subset of the language python - the subset which it can infer enough about to compile efficiently
14:34:40 <levi> simpson: The language itself would still conceptually be uni-typed, but the runtime could infer types and generate more efficient code when the program was amenable to such analysis.
14:34:44 <dmwit> But thanks for the heads-up... I'll be sure to carefully double-check a couple versions next time I do a version bump.
14:34:57 <Peaker> simpson: maybe I haven't followed earlier, but I don't understand what the 42 thing is about
14:35:18 <simpson> maurer: Except RPython doesn't act on Python source; it acts on the output of a Python compiler.
14:35:48 <simpson> Peaker: It's just an example of an object literal that has a type that cannot vary, according to the language spec.
14:36:02 <simpson> There are other types, but I like ints. They're simple and easy to think about. Also FORTH.
14:36:06 <Peaker> simpson: if you can practically know the static type of subexpressions at compile-time via inference or explicitness, it is static typing. If you cannot know them statically (or even, such static classifications do not exist), it is a dynamic language. Python is the latter, and there are no static types you could even infer
14:36:35 <Peaker> simpson: yes, some Python subexpressions can be statically type-inferred, and some can't. So in the general case, you can't infer
14:37:09 <Peaker> you might gain a lot of value, in both error checking and performance, if you do infer what you can in Python, but of course you will not infer all
14:37:26 <levi> simpson: FORTH is *untyped*, while most modern dynamic languages are uni-typed. A typeless language is memory-unsafe, while a uni-typed language is memory-safe (assuming garbage-collection or something similar in effect).
14:37:30 <Peaker> Also, tacking on inference to a language is not going to work nearly as well as designing the language and its inference together to work well
14:37:32 <maurer> simpson: You do realize that RPython is called that for "Restricted Python". The name explicitly states that they are dealing with a subset of the language.
14:37:34 <simpson> Okay. So this whole "gradual-typing" thing I keep hearing about doesn't exist?
14:37:54 <simpson> maurer: Sure. However, the exact subset isn't well-defined.
14:38:20 <levi> Gradual typing is a *language extension* that introduces a type system that *includes* the original uni-type, but also adds other types.
14:38:27 <maurer> simpson: As far as gradual typing, it exists, insofar as thos elanguages instead of just having "Thing" as a type, have several other types as well
14:38:33 <maurer> simpson: And just frequently use "Thing"
14:38:57 <simpson> So those would be languages that are neither dynamically- nor statically-typed?
14:39:07 <Peaker> simpson: if you take a "unityped" languages and add some types to it beyond the all-in-one "Object" type, I guess you get gradual typing
14:39:11 <levi> They are gradually-typed.
14:39:16 <nomeata> Clint: btw, haskell-hopenpgp-tools_0.0.1 FTB
14:39:26 <simpson> Okay! I feel like I'm learning more about types. Thanks.
14:39:45 <nomeata> Clint: seems to be related to optparse-applicative
14:40:05 <levi> simpson: Haskell has had sort of the opposite problem, and this is why SYB/Data.Generic/Data.Dynamic exist now.
14:40:12 <maurer> simpson: The problem here is that you are confusing language - if we use typing in the rwh sense, then all languages are statically typed, it's just that the "dynamically typed" ones are unityped, statically typed ones use mostly small types, and gradually typed ones have one big type that's always there, and sometimes have small types
14:40:16 <nomeata> Clint: you want a bug about this?
14:41:03 <levi> In haskell, everything's given a static type, but the type information is *gone* at runtime, so you can't do 'typecase'/reflection operations.
14:41:44 <Clint> nomeata: nah, i'll take a quick look in a few minutes
14:41:52 <levi> Except what exists as the runtime-discriminators of sum-types.
14:41:55 <nomeata> Clint: thx
14:42:22 <simpson> maurer: So what about "untyped" languages?
14:42:39 <levi> So these libraries exist in Haskell to automatically generate a 'uni-type' for the data you want to be able to get the type of at runtime.
14:42:46 <maurer> simpson: untyped languages are just unityped
14:43:16 <levi> simpson: untyped languages don't even try to keep track of what kind of values are which at runtime. The programmer is expected to keep track.
14:43:27 <maurer> simpson: The only difference is in what structure is present on the particular single type they have
14:43:43 <maurer> simpson: In a python unitype, they may have a field saying something about what's inside
14:44:00 <simpson> And in a FORTH cell?
14:44:10 <simpson> There's just a number, right?
14:44:37 <levi> A FORTH cell holds... some value, but there's no way of knowing at runtime what kind, except by explicit programmer convention.
14:44:38 <maurer> simpson: In a forth cell you effectively just have a byte
14:44:48 <maurer> wel, I dunno if it's a byte b/c I don't know forth
14:44:51 <maurer> but you have some data
14:44:56 <maurer> and it has an interface that allows you to read it
14:45:27 <levi> If you store an integer in a cell, and some other word tries to read it as a floating point value, you'll just get garbage.
14:45:40 <simpson> ANS FORTH says that the values in the heap and the stack and the dictionary are simultaneously values, pointers, half-words, etc. all at once.
14:46:09 <levi> simpson: In other words, they are a non-discriminated union type.
14:46:42 <simpson> I think that they're just numbers that can be endlessly reinterpreted.
14:46:49 <levi> Same thing.
14:47:05 <simpson> So is there a difference between "non-discriminated union type" and "numbers" then?
14:47:20 <levi> At the level of the language there is.
14:47:25 <levi> At the runtime level, no.
14:47:31 <maurer> simpson: Yes, in the sense that you have to pick whether it's a pointer, half-word, etc. when you interact with it
14:47:50 <simpson> Now I'm really confused. So languages having their own sense of type does matter? Or it doesn't?
14:48:23 <maurer> What matters is what you get to statically know about how a thing can be defined and used
14:49:07 <simpson> Okay. So Python having compile-time information about 42 doesn't matter, but FORTH having no information about 42 does matter. Right?
14:49:50 <Peaker> simpson: if Python made any use of compile-time information about sub-expressions of known types, it would have gradual typing, but afaik, it doesn't
14:49:52 <maurer> You seem to be missing the point, and I don't have further time to discuss this, I'll leave it to levi
14:49:57 <levi> simpson: It has compile-time information at some point in the compile phase, but it doesn't do anything with it except to choose the right variant of the single value type to store it as.
14:50:47 <Peaker> simpson: if it immediately throws away any inference it does do -- then this inference doesn't constitute static typing, since static typing is about using this information for error checking, documentation, performance, etc.
14:51:09 <levi> simpson: This would all be much clearer to you if you were to write a little dynamic language interpreter, or look at the code for one.
14:52:08 <Peaker> simpson: if you made a dialect of Haskell that did away with the type inference, type checking, all the error checking and performance that come from those, that dialect would become dynamically typed, despite being almost the same language
14:53:05 <simpson> levi: Well, that's part of the confusion; last time I did write such a compiler, I had no problem telling ints from other values.
14:53:06 <Peaker> well, it would have some problems with resolution of type-classes, but we could add explicit annotations about those
14:53:35 <Peaker> simpson: aren't you saying that at some point in the compilation process, you knew the types of some of the sub-expressions?
14:53:48 <levi> simpson: How did you store an integer, though?
14:54:44 <simpson> levi: Well, *last* time, it was (Int 42) in Haskell. The time before that, it was just 42 in Python. So the first time, it was as part of a sum type representing all of the possible types, and the second time, it was as an independent type that could be discriminated from other types.
14:54:53 <simpson> Peaker: Sure!
14:55:23 <Peaker> simpson: "Int 42" so the "Int" was a runtime tag, a data constructor of a large sum type of all possible runtime values in your language?
14:55:25 <levi> simpson: Right. Both times, your interpreter could discriminate types based on untime information.
14:55:31 <levi> s/untime/runtime
14:55:33 <Sculptor> d'oh!
14:58:11 <levi> simpson: In order to make a language that does not have static types *safe*, you must keep track (via some type tag or some similar mechanism) of the type of all values. This makes them effectively members of a single 'value' type, whether you actually implement it that way or not. Then the language semantics can ensure that you don't interpret a value in a way other than it was intended.
14:58:40 <Clint> nomeata: fixed
14:58:45 <edwardk> @tell jfischoff re: lagrangian, you could   replace (Mode s, Mode r) => AD2 s r Double with Mode s => AD s Double  -- by using the ComposeMode mode.
14:58:45 <lambdabot> Consider it noted.
14:59:02 <nomeata> Clint: will you update the Debian package?
14:59:53 <Clint> nomeata: i can, but not until a few hours from now
15:00:03 <simpson> Peaker, levi : Okay. So the types are only something that emerge on a higher level of abstraction than the actual native code that is being run, then. At the end of the day, there are no types in the actual executed code.
15:00:09 <nomeata> Clint: no hurries
15:00:15 <nomeata> Clint: and thx
15:00:15 <Clint> ok
15:01:42 <simpson> Sorry, I can tell that I'm being a bother. I'm just so easily confused, that's all. Thanks again!
15:02:47 * hackagebot hopenpgp-tools 0.0.2 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.0.2 (ClintAdams)
15:03:25 <levi> simpson: It's not really 'wrong' to refer to what Python does as 'dynamic typing', it's just that what it calls 'typing' is different than what type theorists are talking about.
15:04:54 <levi> And that distinction is very important to Robert Harper, but not so much to your everyday programmer. He's got very principled reasons behind his argument, and he's correct about it, but it's not something for Python programmers ought to get upset about.
15:05:50 <levi> If you really want a solid grasp on what he's talking about, he wrote a lengthy textbook on it.
15:06:17 <levi> And he's released his drafts for free as well.
15:07:50 <simpson> I dunno. It all sounds pretty confusing and unhelpful to the actual implementation of compilers and other practical day-to-day code.
15:08:16 <levi> It's not unhelpful at all to implementers of compilers or designers of programming languages.
15:08:25 <Peaker> levi, simpson: But I think his argument that "dynamic typing is a straitjacket, not static typing" is something for Python programmers to get upset about -- as they just disagree.  Whether or not you're free to put compile-time constraints on sub-expressions (static types) or not (Only one type to assign to them all) can be viewed as a dynamic-typing=straitjacket thing
15:09:07 <Peaker> does the language give me the freedom/tools to specify meaningful constraints on sub-expressions? Or does it force me to say every sub-expression is just an unconstrained (at compile-time) "Object"?
15:09:38 <levi> Python does not let you make any constraints on the kinds of values that are passed into a method.
15:09:59 <levi> You can check them for sanity *after* the method is called.
15:10:12 <arrdem> levi: technically true, but you can use wrapper functions to typecheck before invocation of the target
15:10:18 * arrdem runs
15:10:34 <Feuerbach> and it's not just about constraints... the Python "types" can be expressed as a single simple recursive algebraic data type. If that's all you need... fine.
15:10:44 <levi> But the wrapper has to accept the values first before it can check them. It's all runtime discrimination.
15:11:12 <Feuerbach> roughly http://ro-che.info/docs/2013-05-31-dynamic-oo-haskell.html#7.0
15:11:24 <simpson> levi: Well, I'm obligated to point out `def f((a, b)):` at a minimum.
15:11:49 <levi> simpson: And when will you get an error if you pass it something other than a pair?
15:12:30 <simpson> levi: There might not even be an error, I think.
15:12:50 <levi> Well, that's not much of a constraint then!
15:13:25 <Peaker> simpson: f(5) compiles fine :(
15:13:48 <solrize__> python 3 eliminated that syntax iirc.  a regression if you ask me.
15:14:00 <levi> My Python is very rusty, but if I remember correctly a stack trace on a dynamic typing error would be thrown by the method that received the bad value. Which is my point; the language can't prevent you from writing nonsensical things.
15:14:00 <simpson> Okay. So if the compiler type-checks things prior to calls, then that's a stronger typing system?
15:14:00 <Peaker> simpson: the "straitjacket" Bob is talking about is this -- you can't put compile-time constraints on anything
15:14:02 <solrize__> but yeah, it's checked at runtime
15:14:23 <Peaker> simpson: not prior to calls -- but prior to running anything
15:14:24 <simpson> So what about something like Factor, where all words must be typed, but the type of things on the stack is dynamic?
15:14:24 <levi> simpson: Then it's a *typing system*; that's Bob's point.
15:15:02 <levi> It's a typing system when the compiler is able to rule out nonsensical things. It's runtime value discrimination when the runtime rules out nonsensical things.
15:15:03 <simpson> You can write anything in Factor's REPL, but you can't compile words unless they've got correct stack inference.
15:15:15 <simpson> Okay. So when you have both, do you have both static and dynamic typing?
15:15:28 <levi> Yes.
15:15:50 <levi> Data.Dynamic is 'dynamic typing' for Haskell.
15:15:52 <simpson> But not gradual typing.
15:16:20 <Peaker> simpson: one aspect (stack use) can be statically typed whereas another can be dynamically typed.  Haskell's termination is dynamically typed, whereas other Haskell things are statically typed
15:16:41 <Peaker> simpson: Haskell would be more statically typed if it also used types to indicate whether expressions terminate or not
15:16:55 <simpson> Interesting. Is there a scale of static typing?
15:16:56 <levi> Gradual typing is for when your default is unityped values, but you want have *some* types as well, optionally.
15:17:18 <Peaker> simpson: I'd guess more of a space than an axis(scale)
15:17:35 <Peaker> simpson: different runtime invariants can be stated/restricted in compile-time(static) or left unrestricted(dynamic)
15:17:51 <monochrom> it should be a lattice, not scale, of static typing. because if you have one million aspects, then there are 2^(one million) choices of what to type statically.
15:17:55 <Peaker> I'd say the Haskell spirit is about moving as many from the latter group to the former group
15:17:58 <levi> Types constrain the textual form of the language, so that things that don't pass the type checker are not valid expressions in the language.
15:18:31 <cariveri> startling: I turned my Tree into State Tree, but the actual problem remained. at program start there are actions registered which could be given a global accesspoint, but giving them the initial state of the my Tree does not make sense at all. In that case I would have to re-register the actions anytime an action is performed.
15:18:50 <Peaker> levi: s/textual/syntactic or "terms of the language"
15:19:31 <startling> cariveri, I think you're confused.
15:19:34 <Peaker> cariveri: a "State Tree" receives a state and returns a new-state. Why can't it receive the new state each time it runs? (assuming I understand you correctly)
15:23:13 <lightquake> what's the difference between ByteString and, say, Vector Word8?
15:23:32 <acowley> lightquake: Optimizations and API
15:23:42 <Peaker> also GC pinning semantics, I think
15:23:54 <acowley> lightquake: There was an effort to replace ByteString with Vector Word8 by providing the same API, but performance lagged a bit so the effort stalled.
15:23:54 <lightquake> ah, ok
15:23:59 <acowley> yes, the GC pinning is different
15:24:12 <levi> simpson: Types are a means of describing some correctness properties of the program such that program terms that violated those properties would cause the program text to not be a valid example of a program in that language.
15:24:23 <lightquake> so they conceptually represent the same thing but they're implemented differently and have different performance
15:24:42 <acowley> lightquake: Yes
15:25:18 <simpson> levi: Okay. And then properties like whether a valid expression can become invalid in a bigger context are orthogonal?
15:26:08 <levi> simpson: I'm not entirely sure what you mean; could you rephrase the question?
15:26:49 <dcoutts_> acowley: is the GC pinning really different? I thought vector used pinned arrays and used pointers internally a lot.
15:27:10 <simpson> levi: Say that you have an expression that, according to typing rules of the language, is valid. However, when placed into a hole in a bigger otherwise-valid program, the entire program becomes invalid. This is not necessarily related to typing, right? It could be some other syntactic problem?
15:27:37 <levi> simpson: It could be a typing problem or it could be related to the grammar, I guess.
15:28:10 <cariveri> Peaker: I just dont know how I would pass the current state to the action handle. lets say I got: onActionActivated open (openFile "xy" window otherGTKstuff), that is once and for all. I could pass the initialState of my Treedata but what for? it would always use that initial one instead of the current one.
15:28:11 <simpson> Okay. So (wrongly-typed) implies (invalid), but not necessarily the other way around?
15:28:27 <Peaker> cariveri: where do you store the current one?
15:28:33 <levi> Yes, syntax errors are a counterexample.
15:28:40 <acowley> dcoutts_: Yes, I believe so. a BS is a ForeignPtr, while Vector uses ByteArray
15:29:02 <simpson> Alright. I think I'm understanding so far.
15:29:06 <Tordek> so, I have 2 questions that seem to be quiet opposite on the "i know haskell" scale:
15:29:11 <dcoutts_> acowley: that'd make vector better
15:29:15 <Tordek> 1) when do I use type/data/newtype?
15:29:37 <dcoutts_> acowley: ah, but is it a pinned bytearray?
15:29:43 * dcoutts_ should just check
15:29:45 <Peaker> simpson: (wrongly-typed) may not be invalid, all type systems will always reject some valid programs.  (invalid) must be (wrongly-typed) (if the validity is in an aspect that's statically typed)
15:29:49 <acowley> dcoutts_: But I want to share my ByteString with some C code and just trust that the GC doesn't move it!
15:30:04 <dcoutts_> acowley: that's not a problem
15:30:24 <Tordek> 2) are arrows more powerful than monads? what about applicatives? how do I know if something should be 'built' as a monad or as applicative?
15:30:26 <simpson> Peaker: Whoa, wait, what's that first part? Is that some Godelian sort of rule?
15:30:46 <acowley> Anyway, no Vector is not pinned
15:31:08 <Peaker> simpson: I think so, I am not sure what the source of that rule is, but it is a rule (for non-trivial type systems, I'd guess)
15:31:12 <levi> Peaker: It depends on whether you're defining 'valid' as 'would have been valid in an untyped language' or 'is accepted by the compiler as valid'.  I meant the latter.
15:32:20 <Peaker> acowley, dcoutts_: http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial claims that Data.Vector.Storable is pinned
15:32:23 <levi> The type checker may reject some programs that would have been valid if it weren't for the type errors. But they are nevertheless rejected and thus invalid according to the rules of the language.
15:32:52 <Peaker> levi: ah, that's just tautological, of course, so I assumed that wasn't the question
15:33:13 <cariveri> Peaker: Thats what Id like to know. I dont know where the current state could be retrieved from in order to compute the next one.
15:33:26 <dcoutts_> Peaker: but that's Storable
15:33:51 <acowley> Peaker: You can see in http://hackage.haskell.org/package/vector-0.10.9.1/docs/src/Data-Vector-Primitive-Mutable.html#MVector
15:34:07 <acowley> Peaker: It's calling newByteArray, which produces an unpinned array
15:34:09 <Peaker> dcoutts_: well, a storable vector of Word8 would be like a pinned ByteString?
15:34:26 <Peaker> acowley: is that used for storable ones too?
15:35:08 <acowley> No, Storable is a ForeignPtr
15:35:11 <cariveri> startling: do you see my problem?
15:35:38 <startling> cariveri: not at all.
15:35:49 <startling> cariveri: I think maybe you're thinking in a procedural way.
15:35:57 <acowley> I can't remember who was doing the Vector Word8 implementation of Byte String. Was it Bas van Dijk?
15:36:11 <startling> cariveri, if you could post code we could tell you how to write it Haskellily.
15:36:37 <acowley> Here we go https://github.com/basvandijk/vector-bytestring
15:36:47 <dcoutts_> acowley: yes, I stand corrected. I was sure Roman used to love using pairs of pointers and incrementing a pointer, rather than doing base+offset all the time.
15:36:50 <acowley> And he used Storable Vectors!
15:37:05 <begriffs> Is there a way to configure GHC to skip the docs during installation? I don't see anything in the manual (https://ghc.haskell.org/trac/ghc/wiki/Building/Installing).
15:37:25 <levi> simpson: It's also the case, however, that you can rewrite your program in the typed language to use a sum type and do the same kind of runtime discrimination of values that the uni-typed language would be doing.
15:37:26 <Peaker> cariveri: it sounds like you're in IO, and wondering how to have a "current state" of some tree. Sounds like you need an IORef for that, or a StateT Tree   around your IO computation.
15:37:43 <monochrom> levi: you could follow one historical path (of two). it says: begin with no static type errors, just runtime type errors, call them "stuck" because you can't proceed. then, add static type rules, now all programs that pass it will not get stuck, but the converse is false.
15:37:48 <Peaker> Tordek: depends what you mean by "powerful"
15:38:00 <Peaker> Tordek: an interface with more structure to it is more powerful for the user, but more restricting for the implementor, and vice versa
15:38:20 <simpson> monochrom: Interesting.
15:38:34 <dcoutts_> begriffs: https://ghc.haskell.org/trac/ghc/wiki/Building/Using
15:38:55 <levi> simpson: If you find that interesting, you really ought to read Harper's book.
15:39:03 <Peaker> Tordek: forget "Arrow", it's a bad library :)    "Applicative" has less structure than "Monad" -- so from a user's perspective, it is less powerful. From an implementor's perspective, it is more powerful.  So as a user, you should prefer Applicative until you actually need the extra power of Monad. This lets you work with more interesting implementations that do more useful stuff
15:39:09 <cariveri> Peaker: yes. almost everthing is IO due to gtk functions.
15:39:14 * monochrom merely read Pierce's book
15:39:24 <levi> That works too.
15:39:35 * monochrom actually read two of Pierce's books! :)
15:39:41 <levi> That requires a monetary commitment up front, though.
15:39:56 <Peaker> cariveri: so you can use an IORef Tree for the current tree state.  Then you can write function with State Tree types, and apply them on the IORef:  modifyIORef treeRef (execState theComputation)
15:39:57 <dcoutts_> acowley: so bytestring could and should be unpinned. For passing strings to C code, for short strings the cost of copying is small, while bigger strings are pinned anyway, and for really short C calls one can use unsafe and it's effectively pinned anyway.
15:40:04 * tac has one of Pierce's books and is looking for anyone who wants it, because he doesn't want it any more.
15:40:11 * monochrom actually pirated both
15:40:19 <startling> tac, which book?
15:40:25 * tac is keeping the other two, because he likes them better. tac actually owns all three.
15:40:31 <dcoutts_> acowley: and for getting strings from C code, C libs that care about performance let you use client-allocated buffers, so we'd still be ok.
15:40:32 <tac> Advanced Topics in TaPL
15:40:37 <Peaker> dcoutts_: what size causes strings to be pinned?
15:40:39 <mm_freak_> cariveri: "due to gtk functions" is bad reasoning for "everything is IO" =)
15:40:46 <dcoutts_> acowley: except mmap, and we can handle that one specially.
15:40:58 <dcoutts_> Peaker: it's ~1.4k iirc
15:41:15 <Peaker> dcoutts_: 1k isn't that small to be copying around repeatedly to C calls
15:41:19 <acowley> dcoutts_: Maybe so, it's worth trying to dig up where Bas left things with his Vector Word8 implementation of ByteString to try to understand why performance was worse.
15:41:32 <levi> tac: What do you consider the 3rd book? I think he's an author or editor of at least 4, if you count Software Foundations.
15:41:35 <Peaker> dcoutts_: 16 cache lines destroyed, and about 1microsecond of overhead on a C call is a lot
15:41:43 <acowley> Yeah, that's a lot of overhead
15:41:50 <dcoutts_> Peaker: if the C call is that short it can be unsafe.
15:42:01 <Peaker> dcoutts_: it may persist the ptr somewhere
15:42:07 <cariveri> startling: main = do init {registerActions (initil values); mainGUI } late when receiving an action call like open file with data. then the state inside main should modified the way I think it. shall I really lpaste the code?
15:42:11 <acowley> Oh no, not another safe/unsafe FFI discussion :(((
15:42:22 <dcoutts_> Peaker: then it was broken already and we don't need to worry :-)
15:42:31 <tac> levi: The baby categories book he has.
15:42:32 <Peaker> dcoutts_: why? for pinned that isn't broken
15:42:41 <dcoutts_> Peaker: because it has no way to track the lifetime
15:42:47 <levi> tac: Ahh, okay.
15:42:50 <tac> levi: SF isn't in print, afaik
15:43:01 <Peaker> dcoutts_: not necessarily:   one API may take ownership of the ptr, another API may release it
15:43:37 <levi> I think it changes too much for it to be worth publishing by anything other than an on-demand publisher.
15:43:52 <dcoutts_> Peaker: well, it's not a corner case I'm interested in
15:44:22 <Peaker> does ByteString have something like foreignPtr's touch to keep it alive manually?
15:44:28 <acowley> SF changes constantly, and works pretty well when read in emacs while you're doing the exercises
15:44:48 <dcoutts_> Peaker: the representation is exposed, but we don't make any particular promises.
15:45:04 <dcoutts_> Peaker: certainly the public API doesn't
15:46:28 <Peaker> dcoutts_: hmm.. so ByteStrings aren't really pinned unless you dig into their ForeignPtr and touch it
15:46:31 <dcoutts_> Peaker, acowley: so it's possible we could have some small regressions for foreign interop, but the big prize is faster small string handling and lower memory overheads.
15:46:58 <levi> simpson: Another way to think of the distinction is that a type system discriminates terms of the language, while a runtime-checked system only discriminates values at runtime. As a programmer you can infer what typed you'd intend for your language terms to have (and thus what sorts of values will be involved), but that's in your head rather than as a checkable property of the program itself.
15:46:58 <dcoutts_> Peaker: no, they are pinned, ForeignPtr is always pinned.
15:47:46 <Peaker> dcoutts_: hmm.. I'm just abusing terminology.  ByteString is indeed not safe to use as a raw ptr to C code that takes ownership without touching the internal ptr.  I guess it's obvious from the API, but I've never realized it yet
15:48:41 <acowley> You can check out, https://github.com/basvandijk/vector-bytestring/issues/3
15:48:46 <acowley> but the links seem to be dead
15:49:08 <athan> anyone have experience using JACK with Haskell?
15:49:10 <Peaker> dcoutts_: if Unboxed Vector of Word8 takes over ByteString for most uses -- that's where you can do the small->copy, large->unsafe or pin thing.  and ByteString can become a mainly-FFI thing? As merely an exposed wrapper for ForeignPtr Word8
15:49:20 <cariveri> Peaker,startling  here http://lpaste.net/96532
15:49:47 <acowley> You can also start using Vector Word8 to see if it affects you, http://hackage.haskell.org/package/vector-bytestring-0.0.0.1
15:49:56 <acowley> I think there's just not a lot of pressure on the issue
15:50:16 <acowley> if Bas had come out in front on all or most of the benchmarks, people probably would have been on board with a switch
15:50:28 <acowley> But performance regressions tend to be unpopular
15:50:34 <Peaker> cariveri: do you know what IORefs are?
15:50:50 <ij> Damn, if only I would've known IO is data. I thought it's a typeclass and that's why I couldn't make sens of this all.
15:50:55 <dcoutts_> acowley: or just changing the bytestring impl
15:51:32 <Peaker> ij: upper-case left of => is type-class, upper-case right of => (or if no => exists) is a type
15:51:42 <cariveri> Peaker: no I dont. does it mean my program does not allow for the state solution?
15:52:52 <Peaker> cariveri: a program can be in IO, or State, but not both at the same time.  It can be in   StateT of IO   which is very similar to being in both at the same time, but then some things might not work if they expect IO specifically (and not StateT of IO).   If you're in IO, the simplest thing to do is an IORef
15:53:17 <Peaker> cariveri: when using a library like Gtk+, I *think* the various Gtk functions that take IO actions as arguments expect IO and not "StateT of IO"
15:53:27 <Peaker> cariveri: so as a beginner, I wouldn't go there, I'd just use IORef
15:53:41 <Peaker> cariveri: IORef is basically a mutable location like you know from imperative languages
15:54:14 <Peaker> cariveri: do { ref <- newIORef 1 ; writeIORef ref 2 ; new <- readIORef ref ; print new } -- prints 2
15:58:51 <mm_freak_> IORef is not the simplest thing to do
15:59:17 <mm_freak_> MVar is it…  same simple interface, safety builtin, fairness builtin
16:00:40 <levi> IORef is simpler in itself, but requires more thought to use correctly. MVar is more complex in itself, but is probably simpler to use when it applies.
16:00:53 <c_wraith> not the same interface, in an important way.  an MVar with many readers has to serialize reads
16:00:57 <mreh> how would you guys deploy changes to service written in haskell code with little downtime?
16:01:11 <c_wraith> what kind of service?
16:01:15 <mreh> I was thinking just interpret the thing
16:01:22 <mreh> c_wraith: a web server
16:01:26 <mm_freak_> mreh: NixOS
16:01:39 <mm_freak_> you can write a nix expression for your haskell service
16:01:52 <levi> To minimize downtime, you could put them behind a proxy and do a live switchover.
16:01:52 <ij> Can I make haskell print something that would show AST/type sigs or a combination of those?
16:02:01 <dmj`> mreh: are you using any process monitoring tools like angel or god?
16:02:12 <mreh> dmj` no
16:02:15 <c_wraith> mreh: start up the new version, switch your reverse proxy's config to point to the new one, wait a bit, shut down old one
16:02:16 <mreh> why might I?
16:02:18 <mm_freak_> ij: of its own source code?
16:02:23 <levi> I think Yesod's got some associated infrastructure for doing that.
16:02:25 <vuohi15v> feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!!
16:02:28 <vuohi15v> feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!!
16:02:31 --- mode: ChanServ set +o monochrom
16:02:32 <vuohi15v> FHGFH feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!! feces!!!!
16:02:34 <mreh> nice
16:02:34 --- mode: monochrom set +b *!*@178-75-174-227.bb.dnainternet.fi
16:02:35 --- kick: vuohi15v was kicked by monochrom (vuohi15v)
16:03:03 <ij> mm_freak_, No, of any haskell source file.
16:03:17 <mreh> c_wraith, they both listen on port 80, can you do that in a unix system?
16:03:17 <mm_freak_> ij: in that case you can use hint
16:03:19 --- mode: monochrom set -b *!*@77.224.247.181
16:03:26 --- mode: monochrom set -o monochrom
16:03:42 <cariveri> live I think concurrence is negligable in my case. actions are perform one at a time and in worst case I think I could block other actions meanwhile.
16:04:02 <startling> I like how to way to make a library name haskelly is to start it with "h".
16:04:08 <startling> cariveri, sorry, I was afk
16:04:12 <ij> mm_freak_, What is it and how can I use it?
16:04:13 <mreh> mm_freak_: this looks a lot like what the chef project is trying to achieve
16:04:20 <c_wraith> mreh: no, use a reverse proxy on 80 that forwards requests to a configurable port that your service runs on.
16:04:21 <dmj`> mreh: angel will ensure your process keeps running, when you want to deploy just swap out the binary and send a HUP signal, angel will reload w/ the new binary
16:04:22 <levi> mreh: It seems the simplest solution woudl be to make them listen on other ports and have your reverse proxy listen on 80.
16:04:38 <mreh> yeah okay
16:04:41 <mm_freak_> mreh: i'm not familiar with chef
16:04:42 <c_wraith> mreh: advantages include not running your service with privileges, and terminating SSL in something like nginx
16:05:02 <dmj`> you can use python fabric to automate deploys, simpler than chef
16:05:08 <cariveri> Peaker: startling I linked my code. state seems to be no option since im in IO (gtk). IORefs  and MVAR was suggested to me.
16:05:09 <dmj`> imo
16:05:24 <mreh> dmj` chef is for deploying changes to the configuration of the OS
16:05:39 <mm_freak_> mreh: anyway, i'm using nix commercially with success
16:05:51 <mm_freak_> it has some unique advantages compared to other deployment strategies i've seen
16:05:59 <mreh> mm_freak_: i'll look into it
16:06:03 <dmj`> mreh: it can do more than that...
16:06:09 <mm_freak_> ij: i'd ask you to use your favorite search engine…  "haskell hint" should work =)
16:06:41 <levi> cariveri: StateT IO is also an option; you just have to prefix your IO actions with 'liftIO'
16:07:04 <Peaker> levi: it's a problem if you have functions like:  registerCallback :: (Foo -> IO ()) -> IO ...
16:07:09 <mm_freak_> mreh: one of the most interesting advantages is that if deployment fails, nothing changes, like you've never actually run the command to perform it =)
16:07:09 <merijn> cariveri: I believe the problem is that gtk uses callbacks, so if you actually want to do something that's visible to your program, you need to affect global state and MVar's are one of the simpler ways to do it
16:07:19 <mreh> the two haskell processes would both be reading from a shared acid-state database, so I'd have to shut one down before the other, but I could work around that
16:07:22 <levi> Peaker: Ahh, yes, I have run into that.
16:07:36 <mm_freak_> mreh: you can use a third process for data
16:07:37 <mreh> unless acid-state can run in a server
16:07:42 <mreh> yeah
16:07:45 <merijn> levi: gtk uses callbacks, so you're pretty much stuck using some form of MVar/TVar
16:07:51 <dmj`> mreh: acid-state can run in its own process on its own server
16:08:07 <merijn> mreh: I don't believe acid-state supports multiple processes accessing the same database anyway
16:08:10 <mm_freak_> mreh: be one of the first to try distributed-process in a real world setting =)
16:08:18 <dmj`> merijn: it does
16:08:19 <merijn> mreh: The approach is have one process acces it and the others talk to that
16:08:22 <mm_freak_> i haven't myself yet
16:08:32 <mm_freak_> mreh: aka "cloud haskell" =)
16:08:39 <merijn> dmj`: Last I checked it does by having one process talking to acid-state and the rest talking to that
16:08:53 <levi> In that case I tend to store things in an MVar/TVar and then move them into State to manipulate them (assuming non-trivial manipulation across nested function calls, anyway).
16:08:53 <merijn> dmj`: Which is to say, it doesn't support multiple processes accessing the same database
16:08:56 <mreh> I'm about to deploy my app in drupal, but I'm looking for viable alternative for the future
16:09:04 <mm_freak_> merijn: conceptually it doesn't support that
16:09:22 <merijn> mm_freak_: Conceptually it does, *technically* it doesn't
16:09:32 <merijn> i.e. you can fake it
16:10:07 <mreh> mm_freak_: will read about it
16:10:11 <cariveri> merijn: ok. Ill give it a try tomorrow.
16:10:12 <dmj`> merijn: right, there is no replication or sharding yet
16:10:18 <cariveri> thank you very much. all of you!
16:10:20 <merijn> dmj`: Multiple process access to acid-state doesn't even make technical sense, considering the way it's implemented (i.e. mmap + log)
16:10:24 <mm_freak_> merijn: no, conceptually it doesn't because of safecopy versioning
16:10:54 <mm_freak_> you have to pretend to have only one version
16:11:02 <mm_freak_> which is wrong and dangerous
16:11:05 <merijn> Isn't acid-state replication just "cp/scp" >.>
16:11:13 <mm_freak_> that's replication
16:11:15 <mm_freak_> not sharing
16:11:19 <merijn> mm_freak_: ok, I stand corrected, it neither technically nor conceptually support sharing\
16:11:25 <merijn> mm_freak_: That was in response to dmj`
16:11:29 <mm_freak_> ah
16:11:51 <merijn> That's the entire beauty of acid-state's design, you don't need to build in replication
16:12:01 <dmj`> merijn: I don't see acid-state using mmap ootb
16:12:01 <merijn> And sharding acid-state doesn't even make sense
16:12:29 <mm_freak_> that makes acid-state the first true nosql database =)
16:12:29 <mreh> why not?
16:12:45 <merijn> mreh: Why it doesn't make sense?
16:12:49 <mm_freak_> the others just pretend not to be relational, but acid-state actually isn't
16:12:53 <mreh> facebook shard their memcache data across 800 machines
16:13:01 <merijn> I actually object to calling acid-state a database
16:13:15 <mreh> okay, RAM cloud
16:13:19 <mreh> happy?
16:13:25 <mreh> :)
16:13:26 <donri> acid-state could do sharding with a special data structure
16:13:31 <dmj`> you can simulate relational queries in acid-state w/ ixSet
16:13:34 <merijn> mreh: Because acid-state persists heap object, haskell not having distributed data structures doesn't have a useful notion of splitting a heap object into multiple pieces
16:13:41 <donri> it would be hard to shard arbitrary data structures though
16:13:41 <merijn> mreh: Hence, sharding does not make sense
16:13:49 <mm_freak_> acid-state would allow sharding conceptually, but that brings us back to the single-version-assumption
16:13:57 <mm_freak_> class Shard a
16:14:09 <merijn> dmj`: Sure, you can also implement a relational DB in bash, I don't see anyone calling bash a database, though
16:14:36 <dmj`> bash doesn't give you ACID compliance
16:14:52 <mm_freak_> i think "database" is a misnomer anyway
16:14:52 <haasn> I prefer to think of acid-state as a persistency mechanism for memory values
16:14:58 <mm_freak_> "state" is a more sensible name
16:15:06 <haasn> “database” to me implies querying it partially
16:15:15 <haasn> ie. having a 10 GB large database that you don't have to load fully into process memory
16:15:50 <mm_freak_> haasn: to me that has more to do with caching than with the data itself
16:16:11 <mm_freak_> in principle acid-state could support that
16:16:18 <merijn> haasn: Like I said, acid-state persists heap objects with ACID guarantees. Which is really cool and useful, but calling it a database makes it look like a poor second-rate database, instead of a first-class unique solution to a hard problem
16:16:21 <mreh> acid-state will just continue to consume all available memory
16:16:33 <levi> With a large enough address space and a good kernel virtual memory system, why *not* put it in your process's address space?
16:16:35 <mreh> correct?
16:16:41 <merijn> mreh: Yes
16:17:10 <mreh> could it effectively be turned into a cache by using virtual memory?
16:17:14 <haasn> levi: how reliable is swapping in reality, though?
16:17:15 <mm_freak_> levi: because kernels suck at swapping…  they can only do it on a per-page basis with no semantic information about the data
16:17:16 <mreh> some kind of restriction on memory size
16:17:25 <haasn> I mean, how reliable is swapping to not kill all of your other programs
16:17:33 <haasn> “kill” as in “make really slow”
16:17:34 <mm_freak_> swapping is very reliable, but too slow
16:17:55 <mm_freak_> haasn: in that sense not reliable at all
16:18:01 <merijn> haasn: Extremely
16:18:06 <levi> haasn: mmap doesn't use your system swap file; the file you've mmapped is the swap file.
16:18:12 <mreh> why not use a very small page size
16:18:12 <merijn> haasn: Look at how badly varnish outperforms stuff like memcache
16:18:39 <mm_freak_> mreh: you don't get to choose the page size =)
16:18:45 <mreh> damn
16:18:50 <mreh> :(
16:18:50 <merijn> haasn: See also this PHK column on using the OS vm subsystem: https://queue.acm.org/detail.cfm?id=1814327
16:18:59 <mm_freak_> levi: it's still per-page
16:19:07 <haasn> levi: oh, okay
16:19:17 <mm_freak_> levi: and you would need a clever way to make the memory region non-continuous
16:19:23 <merijn> haasn: Could also be titled as: abusing kernel design knowledge for fun and profit
16:19:57 <merijn> mm_freak_: Why would you need to make it non-contiguous?
16:20:00 <levi> mm_freak_: Why would you need to make it non-continuous?
16:20:06 <merijn> mm_freak_: We have 64-bit address spaces
16:20:16 <haasn> a related question: what's the best way to deal with accidental/badly-optimized haskell quickly consuming all of my system memory?
16:20:19 <merijn> mm_freak_: Just skip ahead by a few kilobyte (or whatever your page size)
16:20:21 <mreh> are there any transparently caching distributed databases?
16:20:23 <mm_freak_> can you choose which regions are mapped?
16:20:31 <merijn> mm_freak_: Why bother?
16:20:46 <merijn> mm_freak_: Just map the entire file...
16:20:50 <mm_freak_> merijn: if you don't bother, you're back to regular swapping
16:20:59 <mreh> haasn: make all your data structures strict?
16:21:06 <dmj`> haasn: seq
16:21:09 <merijn> mm_freak_: I don't understand what you mean?
16:21:11 <levi> mm_freak_: It won't swap anything in that you don't access.
16:21:20 <merijn> mm_freak_: It *is* regular swapping, that's the point
16:21:27 <dmj`> merijn: if acid-state had its own query language would you call it a database
16:21:29 <merijn> mm_freak_: The only difference is where you swap too
16:21:42 <levi> mm_freak_: Correct me if I'm wrong, but you seem to misunderstand how mmap works.
16:21:44 <mreh> I read as haskell style guide that told me to make all constructors strict
16:21:52 <haasn> dmj`: I mean, assuming I run such a program. How do I prevent it from either crashing all of my programs or slowing the system to a crawl?
16:21:57 <mreh> s/read as/read a/
16:22:00 <mm_freak_> ah, now i get how you want to use mmap =)
16:22:01 <maurer> mreh: What
16:22:05 <maurer> mreh: No
16:22:16 <maurer> mreh: making all constructors strict is definitely not normal style
16:22:19 <merijn> dmj`: Adding a query language to acid-state runs counter to its current design, so anything with a query language would no longer be acid-state imo
16:22:24 <levi> When you mmap a file, *nothing* is paged into active memory, regardless of how big the file is.
16:22:26 <haasn> maurer: some recommend it
16:22:30 <levi> At least not immediately.
16:22:36 <mreh> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
16:22:40 <haasn> mreh: depends on the structure in question, obviously
16:22:40 <mm_freak_> but the mmapped region holds the serialized representation of the data…  that's not what acid-state does
16:22:44 <mreh> maurer: there
16:22:46 <merijn> mm_freak_: The beauty is that you don't double swap when you want to persist the data to disk
16:22:48 <mm_freak_> you still have the actuall data value in memory
16:23:03 <mm_freak_> i.e. the (Map X Y, Integer, String)
16:23:09 <mreh> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md#data-types
16:23:14 <merijn> mm_freak_: Sure, mmap is barebones, you'd have to implement your own log, etc.
16:23:33 <mm_freak_> it's also not necessary, because it will likely be slower than the transaction log approach
16:23:35 <haasn> mreh: if you need actual nonstrictness (eg. lazy lists, recursive structures, etc.) then you'd obviously not strictify the field, but for many purposes a strict data structure (especially holding boring stuff like records) will be much more beneficial as a first approximation to the performance of your algorithm
16:23:36 <dmj`> haasn: what is this program doing exactly
16:23:38 <haasn> of course, this all depends
16:23:39 <mm_freak_> and probably a lot more difficult to get right
16:24:06 <mreh> haasn: okay, good to know
16:24:21 <haasn> dmj`: for example, say I try to evaluate “sum [1..100000]” but while typing that my cat stepped on the keyboard and added a dozen 0’s
16:24:35 <merijn> Anyone know how much, if any, overhead safecopy reading/writing incurs compared to plain old Data.Serialize?
16:24:53 <maurer> mreh: Strictness can be valuable, but ``make everything strict'' seems vastly overkill
16:25:25 <mreh> maurer: there definitely are cases where strictness can cause inefficiency
16:25:28 <mm_freak_> merijn: safecopy has type and version information in addition to the plain stuff
16:25:30 <maurer> mreh: I'll also note that he doesn't follow his own styleguide https://github.com/tibbe/hyena/blob/master/Network/Wai.hs
16:26:14 <mreh> maurer: send him a pull request :)
16:26:16 <merijn> mm_freak_: oh, so you couldn't even use it with a fixed format anyway?
16:26:22 <ij> I found some code in a case statement: "Left err -> printInterpreterError err" Isn't printInterpreterError a very unhaskellish function name?
16:26:50 <haasn> mreh: bottom line is to evaluate it for each algorithm/structure specifically
16:26:54 <maurer> mreh: No, he did it the right way
16:26:57 <mm_freak_> merijn: not sure what you mean
16:27:04 <donri> mm_freak_: not type information though i don't think?
16:27:12 <levi> ij: Why does it strike you as unhaskellish?
16:27:23 <maurer> mreh: My point is that this style guide should not be taken as a super correct thing, given that even the author does not adhere to it.
16:27:28 <haasn> levi: too long? :)
16:27:32 <dmj`> haasn: it's unlikely the cat's paw would hit the 0 key a dozen times, it would obviously hit the 'o' key and the type checker would save you from evaluation
16:28:07 <merijn> mm_freak_: I'm interfacing with an externally defined data format that comes in several versions, I was wondering whether I could do something with safecopy to make things cleaner then the "dynamically switch to the relevant version parser" think I have now
16:28:34 <mm_freak_> donri: not sure actually
16:28:38 <mreh> maurer: he does qualify the absolute strictness rule "Constructor fields should be strict, unless there's an explicit reason to make them lazy."
16:28:53 <levi> maurer: That file was checked in 4 years ago.
16:29:18 <maurer> levi: I guess? I just looked at his style guide, then started looking through code, assuming there was no way he could acutally code like this
16:29:40 <maurer> levi: And sure enough, the first data definition I saw with arguments was not strict
16:29:40 <haasn> mreh: I think strictifying (and unboxing?) Environment could legitimately be an improvement, though I wouldn't quote myself on it without proper benchmarks
16:29:58 * zRecursive What will happen if haskell defaults "strict" not "lazy" ?
16:30:21 <haasn> zRecursive: many people will complain on #haskell, most likely
16:30:36 <ij> levi, I'm guessing InterpreterError is data of defined type so, it should've been an instance of Show typeclass(printInterpreterError should become show)?
16:31:00 <donri> mm_freak_: it doesn't really need to anyway; the migrations are dispatched with type classes and families
16:31:08 <levi> maurer: Well, style does tend to evolve over time.
16:31:09 <zRecursive> haasn: maybe
16:31:35 <Tordek> Peaker: awesome, thansk for the explanation
16:32:14 <haasn> zRecursive: suggestion: take every library on hackage and compare benchmarks
16:32:25 <levi> ij: I think it's haskellish to use long names where they're helpful and short ones where context makes it obvious what they identify. And often 'show' is not what you want for printing things to users.
16:32:55 <maurer> mreh: I mean, the easy counterpoint to "should be strict" is that your program will never be made wrong by making a strict field lazy, but may be made wrong by making a lazy field strict
16:33:11 <maurer> mreh: So to me, it makes more sense to code normally, then annotate for strictness as an optimization if it becomes necessary
16:33:28 <zRecursive> sure
16:33:35 <mreh> maurer: what do you mean by "wrong"?
16:33:45 <mreh> it wont change the semantics
16:33:47 <levi> maurer: I think the counterargument to *that* is that space leaks are harder to track down than problems caused by over-strictness.
16:33:49 <mreh> will it?
16:34:05 <maurer> mreh: It can cause programs to go from working fine to not terminating
16:34:19 <levi> strict vs. lazy is very much a semantics issue.
16:34:25 <mm_freak_> levi: is that a valid counterargument?
16:34:25 <levi> Well, strict vs. non-strict.
16:34:38 <mm_freak_> do you find <<loop>> easier to resolve than a stack/heap overflow?
16:34:45 <mreh> I suppose if you consider evaluating bottom
16:35:14 <levi> mm_freak_: Yes.
16:35:29 <maurer> The "bad stuff" aside from possible negative perf effects that can happen from strictness are <<loop>>, accidental bottom evaluation, and unbounded computation loops not detected by the blackholer
16:35:31 <levi> Hit break, look at what's executing... done!
16:35:33 <mm_freak_> levi: then you haven't debugged custom MonadFix/ArrowLoop instances yet ;)
16:36:12 <mreh> those classes make my brain hurt enough
16:36:31 <maurer> I dunno, I'm not arguing against strictness annotations, I'm saying that you shouldn't just make everything strict because some guy said he thinks this might be a good idea
16:36:43 <maurer> Strictness annotations are a great perf tool
16:36:47 <mm_freak_> i agree
16:37:07 <mreh> okay
16:37:14 <levi> Most people have some experience debugging unexpected loops in strict languages. Not many people have experience debugging space leaks due to lazy evaluation.
16:37:18 <shachaf> Obviously the right answer is to use a total language.
16:37:19 <mm_freak_> in fact i don't even write strict constructors…  strictness belongs into functions
16:37:24 <mreh> do we have a good agreed upon style guide?
16:37:32 <merijn> shachaf++
16:37:42 <srh_> shachaf--
16:37:43 <levi> mreh: Clearly not. ;)
16:37:43 <maurer> shachaf: I have been writing a lot of agda lately...
16:37:55 <shachaf> hi srh_
16:37:59 <mm_freak_> mreh: yes:  "write code that others can understand now and you can understand in six months" =)
16:39:06 <mm_freak_> levi: so how do you solve this new source of bugs?  pretend to write C and make everything strict again?
16:39:16 <mm_freak_> learn to deal with nonstrict semantics
16:39:31 <mm_freak_> my personal experience is that i have trouble writing correct programs in strict-by-default languages
16:39:44 <mm_freak_> to a haskell programmer strict-by-default is a new source of bugs
16:39:50 <mm_freak_> and you have to learn to deal with it
16:39:55 <levi> mm_freak_: tibbe's style guide clearly doesn't advocate making *everything* strict.
16:40:14 <maurer> mm_freak_: Strict constructors can make sense. For example, http://hackage.haskell.org/package/containers-0.5.3.1/docs/src/Data-Map-Base.html the Map type is strict on keys
16:40:34 <mm_freak_> levi: i advocate not to begin with strictness…  begin with the default and adjust your functions if they are overly nonstrict
16:41:00 <mm_freak_> maurer: that's strictness by data dependency
16:41:03 <mm_freak_> it's natural
16:41:07 <maurer> mm_freak_: Not just by data dependency
16:41:08 <levi> I tend to glean style hints from good code rather than people who give style advice, anyway.
16:41:16 <maurer> mm_freak_: It's also unpacked and annotated
16:41:39 <mm_freak_> maurer: it's still natural, so it makes sense to optimize there
16:41:45 <maurer> Yes
16:42:10 <maurer> My point is that it makes sense, since you mentioned that you thought that 16:31 < mm_freak_> in fact i don't even write strict constructors…
16:42:16 <mm_freak_> levi: not sure if you consider my code good code =)
16:42:25 <maurer> And so I wanted an example of a pretty much unambiguously correct strict constructor
16:42:37 <mm_freak_> if you do, then you might agree with my style advice =)
16:43:03 <mm_freak_> maurer: an unpacked field is again naturally strict
16:43:10 <levi> mm_freak_: I don't know if I've read any of your code! But it's probably better than mine. I'm not saying I *disagree*, just that I don't think your point of view is necessarily the only valid one.
16:43:43 <mm_freak_> levi: well, that's true
16:44:17 <levi> I'm sure tibbe has good reasons for the style he advocates, and I think I've seen other code written that way as well. I am sure there are merits to it as well as drawbacks.
16:44:39 <danilo2> dcoutts: Hello :) Are you here now? I've got a fast question connected to a patch to Cabal-install
16:44:48 <mm_freak_> levi: i can back up my style advice with some reasoning though:  it helps you write code that is easy to read, easy to reason about (unexpected strictness can be surprising) and also fast
16:44:52 <jle`> is it idiomatic to do something like data Parser = P?  have the data constructor be just a single letter?
16:45:02 <jle`> would that be mixed up with module qualifiers
16:45:45 <levi> mm_freak_: I'd be interested to see you debate it with tibbe, but I will humbly withold final judgement on who's right. ;)
16:45:54 <mm_freak_> jle`: i don't see a way to confuse those…  the namespaces are separate
16:46:06 <jle`> i mean congitively
16:46:17 <jle`> is it common to have one-letter data constructors?
16:46:17 <mm_freak_> levi: i might have had that debate already =)
16:46:38 <levi> That doesn't help me much! And you clearly didn't convince him.
16:46:42 <startling> jle`: it's not common.
16:47:12 <mm_freak_> jle`: i think Parser doesn't hurt, but P actually might =)
16:47:40 <Eduard_Munteanu> Is there an equivalent typeclass notion for GADT existentials? I think it would be a type family whose rhs can be inferred.
16:48:06 <jle`> i just want a nice scheme so i can easily avoid having the type constructor being the same as the data constructor
16:48:13 <Eduard_Munteanu> s/equivalent/analogous/
16:48:55 <Eduard_Munteanu> Actually hm, I haven't tried letting an associated type family instance undefined.
16:48:56 <mm_freak_> jle`: for newtypes and single-constructor data types it's quite common
16:49:26 <mm_freak_> jle`: unless you use DataKinds it's trivial to tell them apart in code
16:49:45 <jle`> would it be 'cool'
16:49:48 <jle`> ?
16:49:54 <jle`> or would it be unidiomatic
16:50:00 <mm_freak_> to write P?
16:50:06 <jle`> to use single letter data constructors
16:50:26 <mm_freak_> i think it's a question of style, not idiom
16:50:39 <mm_freak_> so you will get subjective answers
16:51:13 <mm_freak_> my personal opinion is:  don't do it, it's not cool and may bite you later when you have to tell P, A, T, L, Li, Lo and Pr apart =)
16:52:38 <ij> Can I do "getChar >>= last . map fun . repeat" simpler than that with fun being of Char -> IO () type?
16:54:13 <mm_freak_> ij: that's a type error
16:54:20 <mm_freak_> unless you don't mean 'last' from the prelude
16:54:21 <Eduard_Munteanu> ij: I don't think that does what you think it does
16:54:56 <Eduard_Munteanu> @hoogle repeatM
16:54:56 <lambdabot> No results found
16:55:11 <dmj`> that would not terminate
16:55:16 <ij> That's the point.
16:55:20 <mm_freak_> ij: if what you mean is 'fmap (last . map fun . repeat) getChar', then you get a loop
16:55:36 <mm_freak_> ij: what's the application?
16:55:40 <ij> SDL main loop.
16:55:42 <Eduard_Munteanu> getChar >>= mapM_ fun . repeat  ?
16:55:54 <Eduard_Munteanu> ij: oh, use forever for that
16:55:58 <Eduard_Munteanu> :t forever
16:55:59 <lambdabot> Monad m => m a -> m b
16:56:14 <Eduard_Munteanu> forever $ do  ...
16:56:25 <mm_freak_> ij: you can use 'forever' if you plan to terminate the application by crashing it with an exception =)
16:56:34 <mm_freak_> otherwise i'd just use an explicit recursive function
16:56:57 <Eduard_Munteanu> @hoogle exit
16:56:57 <lambdabot> Graphics.UI.GLUT.Initialization exit :: IO ()
16:56:57 <lambdabot> System.Exit exitFailure :: IO a
16:56:57 <lambdabot> System.Exit exitSuccess :: IO a
16:57:23 <mm_freak_> exit* throw exceptions
16:57:35 <Eduard_Munteanu> Ah, yeah.
16:57:45 <mm_freak_> and it would be even worse if they didn't ;)
16:58:18 <Eduard_Munteanu> ContT r IO a  :P
16:58:25 <ij> So why would it throw exceptions?
16:58:33 <mm_freak_> or just IO
16:58:43 <joneshf-laptop> exitSuccess throws an exception? that "sounds" wrong,but semantically makes sense
16:58:44 <mm_freak_> ij: how else do you terminate a program from within an IO action?
16:58:50 <dmj`> forever $ do { c <- getChar; when (c == 'a') exitSuccess; print a }
16:58:56 <dmj`> print c
16:59:15 <dmj`> joneshf-laptop: I agree
16:59:28 <mm_freak_> joneshf-laptop: it doesn't sound wrong to me
16:59:36 <mm_freak_> killThread throws an exception as well
16:59:51 <Eduard_Munteanu> Exceptions are supposed to be exceptional. :P
16:59:58 <mm_freak_> it's the sane way of unexpected, but managable exit
17:00:06 <mm_freak_> it is exceptional
17:00:32 <mm_freak_> 'a >> b' is supposed to perform the effects of a and b in order
17:00:39 <Twey> forever $ getChar >>= join (bool exitSuccess . print)
17:00:41 <mm_freak_> if a throws, this doesn't happen
17:01:08 <Eduard_Munteanu> Twey: bool?
17:01:20 <Twey> (bool, the magic function whose order of arguments changes depending on what you need!)
17:01:25 <joneshf-laptop> mm_freak_, i just mean that the name has "success" in it, so on first hearing it you'd think everything is all fine, but then you think about what it would have to do, and it makes sense
17:01:44 <Twey> Eduard_Munteanu: bool ∷ a → a → Bool → a
17:01:46 * monochrom said yesterday: does not support dynamic typing, except for... exceptions!
17:01:51 <mm_freak_> joneshf-laptop: don't confuse "exception" with "error" =)
17:02:05 <mm_freak_> the "exception" in exceptions is related to control flow
17:02:31 <Eduard_Munteanu> Twey: where is that defined?
17:02:42 <Twey> Eduard_Munteanu: bool f _ False = f; bool _ t True = t
17:02:59 <Twey> Nowhere (or rather, several places); it's just one of those bits of folklore
17:03:15 <Twey> @hoogle bool
17:03:15 <lambdabot> package bool-extras
17:03:15 <lambdabot> package boolexpr
17:03:15 <lambdabot> package bools
17:03:24 <Twey> @hoogle a -> a -> Bool -> a
17:03:25 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
17:03:25 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex3 :: a -> a -> a -> Vertex3 a
17:03:25 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector3 :: a -> a -> a -> Vector3 a
17:03:27 <Twey> Bah
17:03:45 <Rylee> @hoogle a -> a
17:03:45 <lambdabot> Prelude id :: a -> a
17:03:45 <lambdabot> Data.Function id :: a -> a
17:03:45 <lambdabot> GHC.Exts breakpoint :: a -> a
17:14:28 <dainanaki2> I'm having a bit of trouble figuring out how to write an instance declaration for show for these data types:
17:14:29 <dainanaki2> data Project f = Project (f (Task f))
17:14:29 <dainanaki2> data Task f = Task { taskName :: Text, subtasks :: f (Task f) }
17:14:57 <Rembane> dainanaki2: What do you want to show?
17:15:49 * enthropy suggests deriving (Show)
17:15:56 <dainanaki2> doesn't work
17:16:03 <geekosaur> how do you show a function?
17:16:07 <Twey> enthropy: No Show instance for f
17:16:14 <Twey> (or rather, f (Task f)
17:16:16 <Twey> )
17:16:17 <dainanaki2> I'd like to be able to fill in f with [] or some other functor that can show things with constraint (Show a, (Show (f a))
17:16:21 <geekosaur> (hint: you "can", sort of. but what do you intend)
17:17:13 <dainanaki2> Not that it necessarily has to be a functor, but some sort of parametrically polymorphic container.
17:18:23 <jmcarthur> i'm not sure i see why deriving wouldn't work
17:18:25 <dainanaki2> I'm just trying to figure out what the instance declaration is supposed to look like / hoping that there's some way to avoid using UndecidableInstances
17:18:55 <Twey> jmcarthur: How does one Show an f (Task f)?  E.G. for f = IO?
17:19:38 <Twey> data VoidFunctor a
17:19:38 <enthropy> it can make up a constraint for  Show (f (Task f))
17:19:45 <enthropy> deriving instance Show (f (Task f)) => Show (Task f)
17:19:49 <jmcarthur> i see, would need some way of saying   forall a. Show (f a)
17:19:58 <jmcarthur> or undecidable instances
17:20:06 <jmcarthur> ah or just that
17:20:09 <enthropy> now the problem is to define the Show (f (Task f)) instance
17:20:15 <enthropy> which is no easier I guess
17:20:32 <jmcarthur> i think that's fine
17:20:42 <jmcarthur> [Task []], for example
17:20:48 <jmcarthur> already done
17:21:09 <jmcarthur> looks like that still needs undecidable instances though
17:21:19 <danilo2> Which is the best JSON library in Haskell? aeson? :)
17:21:27 <jmcarthur> Variable `f' occurs more often than in the instance head in the constraint: Show (f (Task f))
17:21:33 <dainanaki2> jmcarthur: That's my main question
17:21:47 <dainanaki2> Is there some way to do this without using undecidable instances?
17:21:50 <enthropy> well that subtasks list can go on forever
17:21:53 <jmcarthur> i think i would just go with undecidable instances. it's not such a bad extension. it just sounds scary
17:22:13 <jmcarthur> enthropy: i don't understand
17:22:35 <enthropy> the (Task f) also contains a value with type (f (Task f)) which also ...
17:22:44 <monochrom> if you turn on undecidable instances, and type-checking terminates, you are not too bad yet :)
17:22:56 <jmcarthur> enthropy: i don't think this will be a problem
17:23:34 <jmcarthur> enthropy: i just tested it. it works fine
17:23:42 <dainanaki2> hmm, I'm just not clear on how to determine whether I am creating scenario with looping instances.
17:24:03 <jmcarthur> dainanaki2: you can always just try it and see. if you get tired of waiting, you broke it ;)
17:24:11 <jmcarthur> dainanaki2: (ghc will force termination eventually anyway, just with failure)
17:24:25 <dainanaki2> lol, not necessarily the rigor I was hoping for, but I guess I can fudge it.
17:24:30 <mm_freak_> danilo2: aeson is widely used and convenient
17:24:40 <mm_freak_> so it's no mistake to use it =)
17:24:43 <enthropy> it blows a -fcontext-stack rather easily
17:24:44 <danilo2> mm_freak_: Ok, thank you :)
17:25:12 <enthropy> but maybe there are cases where typechecking will get stuck as you describe
17:25:46 <jmcarthur> ghc has a loop counter of some sort, iirc, so there doesn't even have to be some sort of stack overflow i think
17:26:24 <jmcarthur> in any case, if it builds, it's not an invalid program, so it's still not really a bad extension
17:28:11 <enthropy> there's an "In defense of UndecidableInstances" in http://www.haskell.org/communities/11-2013/html/report.html
17:29:33 <dainanaki2> I strongly suspect that once I hook this into my non-trivial code that I'm going to have some looping instances :D
17:30:38 <dainanaki2> welp, nevermind
17:30:59 <dainanaki2> the instance declarations are horrible, but it works. thanks, folks.
17:39:54 <edwardk> > ("hello","world")^._2
17:39:55 <lambdabot>   "world"
17:42:12 <c_wraith> > ["hello","world"]^._2
17:42:13 <lambdabot>   No instance for (Control.Lens.Tuple.Field2
17:42:13 <lambdabot>                     [[GHC.Types....
17:42:26 <c_wraith> oh, good
17:42:27 <edwardk> > ("hello","world")^?ix 1
17:42:28 <lambdabot>   Just "world"
17:42:43 <edwardk> > ("hello","world")^?!ix 1
17:42:44 <lambdabot>   "world"
17:43:09 <chrisblake> is there any function that reads in a string/text datetime and gives back a UTCTime? Text -> Maybe UTCTime ?
17:43:34 <chrisblake> I don't see anything on hoogle.
17:44:05 <Cale> chrisblake: parseTime?
17:44:33 <Cale> (That uses String)
17:44:35 <chrisblake> Cale: that looks about right; I'll take a look into that, thanks! :D
17:44:54 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Format.html
17:46:39 <danilo2> Hello! Could somebody tell me, if a datatype is not derriving by Generic, could I somehow "derive" it in other file, than it is declared?
17:47:24 <c_wraith> danilo2: there is a StandaloneDeriving extension in GHC that might do what you want.  (insert all standard warnings about orphan instances)
17:48:12 <danilo2> c_wraith: Thank you, I'm checking it right now :)
17:51:00 <danilo2> c_wraith: By the way, why does not all datatypes in Haskell derive basic "things", like Typeable, Generic or even more simple, like Show ?
17:51:24 <jle`> danilo2: sometimes you do'nt want to use the default show?
17:52:11 <jle`> also i like having control over my instances
17:52:25 <c_wraith> sometimes you just don't need it for your use cases, and no one else has asked.  sometimes you can't derive it automatically, (like State or something), and it's unclear if any manual instance can be useful
17:52:30 <danilo2> jle`: Ok this make sense, but wht about the Typeable and Generic?
17:53:02 <jle`> yeah, some things don't even have a possible derived Show (ie, thigns that contain non-showable things, like functions)
17:53:11 <Cale> Typeable would make sense, but Generic is too much
17:53:15 <c_wraith> Generic is really new, most people don't even think about it existing yet.
17:53:19 <Cale> Generic would break abstractions
17:53:31 <Cale> Since you can't control the export of the instance
17:53:31 <danilo2> c_wraith: If I do not need them is no problem here - they do not slow down my program and are transparent - so why not to deriver Generic in all my datatypes?
17:53:52 <c_wraith> Typeable isn't derivable for a *huge* class of types, at the moment.  It'll be better in GHC 7.8+
17:53:53 <danilo2> Cale: Could you tell more about it please?
17:54:22 <enthropy> c_wraith: 2 or 3 years?
17:54:28 <Cale> danilo2: It's basically similar to forcing the user to export all the data constructors of their types
17:55:40 <danilo2> Cale: so If my datatype derives Generic it automaticaly exports all of its data constrctors? Is it available to users or are they only exported "under the hood" ?
17:55:42 <enthropy> danilo2: there is this whole discussion http://www.haskell.org/pipermail/ghc-devs/2013-October/002889.html
17:55:52 <Cale> Well, no, it's only equivalent to doing so
17:56:47 <danilo2> enthropy, Cale: Thank you. Enthropy: I'll read it, thanks!
18:00:33 <Cale> danilo2: It's because if you derive Generic, you can get a Rep for any value of the datatype, which you can then take apart and manipulate and then later convert back to a new value of that datatype, whose invariants might not be satisfied, even if the module that datatype came from hid the data constructors from you in order to prevent just that.
18:03:08 <danilo2> Cale: Ok, but is this really so much dangerous? I mean - right now I can copy-paste a library and change code inside it. If someone is using Generics and doing such things, he is doing it for a reason. I can right now create monads, which does not satisfy monad laws also - is this not simmilar problem?
18:03:27 <danilo2> Cale: I havent readed the discussion yet - I think it will clarify a lot
18:04:20 <Cale> danilo2: It makes types less meaningful to allow users to break any abstraction at will.
18:04:20 <lemao> Is it possible to call a class method from a C wrapper?
18:04:57 <Cale> Also, it has a big effect on what library authors can then do.
18:05:26 <danilo2> By the way - I'm trying to create standalone deriving and I'm getting an error: "Can't make a derived instance of `Generic ModuleName': The data constructors of `ModuleName' are not all in scope" What does it mean? Is it impossible to create Generic instance for Distribution.ModuleName.ModuleName? (Cabal library)
18:05:32 <Cale> If you're writing a library, perhaps you want to obscure the implementation of a datatype because you expect it to change in the future
18:06:30 <Cale> But the Generic instance would betray you in that. Users of your library who made use of the generic representations of your structures would then have their programs break when you updated the representation, where otherwise, it would have been abstract.
18:06:54 <Cale> I mean, it's just all the usual good things about being able to abstract implementations of things.
18:07:17 <danilo2> Cale: I see your point, of course! I'm simply amazed how much Generic gives and I'm thinking if we cannot do it better. Lets see an example - I'm using Cabal library and cabal-install ("as a library" - it will become library in the future) and I want to serialize Distribution.ModuleName.ModuleName to JSON
18:07:59 <danilo2> Cale: And now I've got a problem - I cannot change Cabal library (to make this datatype derve Generics) and I cannot use StandaloneDeriving (error is 5 lines up)
18:09:08 <danilo2> Cale: Writing ToJASON instances for all the needed datatypes is to much work, is there any way I can solve it? (This is why I've asked about the default Generics)
18:12:00 <Cale> danilo2: Isn't there TemplateHaskell stuff in aeson to do that already?
18:12:11 <Cale> (are you using aeson?)
18:12:31 <danilo2> Cale: yes aeson, but I did not see TH stuff here yet
18:12:35 <danilo2> Cale:brb
18:13:02 <Cale> http://hackage.haskell.org/package/aeson-0.6.2.1/docs/Data-Aeson-TH.html
18:20:45 <enthropy> lemao: are you trying to foreign export?
18:21:12 <raisdead> I am trying to use fay. It depends on fay-base. I installed fay (and its dependences) in a sandbox. It appears as if fay-base is not registed becasue I get an error "cannot find package fay-base" What is the proper way to install an application globally while using a sandbox for dependencies?
18:21:12 <enthropy> or is this trying to call a C++ class?
18:25:26 <danilo2> Cale: Ok, I'm this way I wanted to do it is I think in this case wrong. I've created over 15 calls to Aeson's 'deriveJSON' (TH function),, because I want to serialize to JSON results of "cabal list", which is Distribution.Client.List.PackageDisplayInfo, but it stills gives me errors about missing instances
18:25:49 <danilo2> Cale: And now the errors are aobut instances like " No instance for (FromJSON                        (PackageDescription.CondTree                           PackageDescription.ConfVar                           [Package.Dependency]                           PackageDescription.Benchmark))
18:26:25 <danilo2> Cale: Sorry for the formatting. Anyway, do you have any idea what shoudld I do now? Making own datatypes and copying the data does noit sounds resonable
18:27:02 <Cale> Yeah, I can imagine that JSONifying all of Cabal's datatypes would be a pretty huge undertaking. If you just want certain details, then making your own datatypes sounds like the right thing to do.
18:28:44 <danilo2> Cale: I want Distribution.Client.List.PackageDisplayInfo (this is result from "cabal list <pkg name>" - and creating own DataTypes would be huge effort also ... Is there any other way?
18:31:21 <danilo2> Cale: the Distribution.Client.List.PackageDisplayInfo is defined here (if you want to see it): https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/List.hs
18:31:58 <Cale> hmm, this seems like something it might be good to ask dcoutts about
18:32:17 <Cale> I'm not all that familiar with the insides of Cabal
18:33:54 <danilo2> Cale: Ok, I'll ask dcoutts tommorow (I mean in couple of hours, because I think dcoutts is not available now)
18:34:28 <danilo2> Cale: I am afraid it is not easy and doable in simple way :( Anyway, thank you for the help ! :)
18:36:34 <schell> i have a lens question - lets say i have b = (0,Just (1,2)), and i want to access the value 2, i use _2.to fromJust._2
18:37:36 <schell> but what about setting?
18:38:17 <schell> also - i guess it would be better to use a getter that would return a Maybe value
18:38:30 <Saizan> you need prisms
18:38:36 <Saizan> _Just in particular
18:39:28 <schell> hmmm - prisms
18:39:53 <schell> so a prism is like a lens but with some extra monadic...handling?
18:41:22 <roboguy_> schell: not really. it can have one or zero targets
18:41:27 <simpson> > Just 6 & _Just %~ (*7)
18:41:28 <lambdabot>   Just 42
18:41:37 <simpson> > Nothing & _Just %~ (*7)
18:41:38 <lambdabot>   Nothing
18:42:16 <simpson> > (0, Just (1, 2)) & _2 . _Just . _2 %~ (*21)
18:42:18 <lambdabot>   (0,Just (1,42))
18:42:49 <roboguy_> schell: a lens has one target and a prism has one or zero targets, basically
18:43:01 <schell> roboguy_: ah, okay
18:43:03 <simpson> ^^ I probably can't explain it better than that.
18:43:23 <schell> and why the term 'prism' - what's the analogy?
18:44:12 <simpson> A prism splits a single coherent beam of white light into a spectrum of colors.
18:44:39 <simpson> _Just splits the traversal so that in case of Nothing, nothing happens, and in case of Just, the value inside Just is traversed.
18:45:04 <simpson> > Right 7 & _Right %~ (*9)
18:45:05 <lambdabot>   Right 63
18:46:36 <schell> ok, that makes sense, thanks
18:48:04 <sjw> oops
18:48:07 <sjw> @run showSigned (showHex) 0 (-2147483648 :: Int32)  ""
18:48:08 <lambdabot>   "-*Exception: Numeric.showIntAtBase: applied to negative number -2147483648
18:48:36 <sjw> @run -(-2147483648 :: Int32)
18:48:37 <lambdabot>   -2147483648
18:48:44 <frx> honestly I find non-infix version more readable
18:48:45 <frx> > over _Right (*2) (Right 5)
18:48:47 <lambdabot>   Right 10
18:51:27 <lispy> :t printHex
18:51:28 <lambdabot> Not in scope: `printHex'
18:51:33 <lispy> :t showSigned
18:51:34 <lambdabot> Real a => (a -> ShowS) -> Int -> a -> ShowS
18:51:43 <georges> when should one use Maybe/Either and when error?
18:52:00 <jle`> georges: use Either when you want to record a reason for the Nothing
18:52:44 <georges> that much I know :)
18:53:21 <jle`> oh you mean Either vs Error?
18:53:30 <georges> yes
18:56:05 <georges> are there any guidelines when to prefer one over the other?
18:57:59 <Cale> Use Either if you want the exceptional condition to actually be handled.
18:58:24 <Cale> error is for stuff you don't expect to ever happen
18:58:57 <georges> like failing to write to a file?
18:59:19 <lispy> it really depends
18:59:31 <roboguy_> georges: well, it depends I guess. can the execution of the program still continue in any reasonable way if that write fails?
18:59:50 <augur> hmm hmm hmm
19:00:01 <Cale> The errors thrown by error are very tricky to catch (because they rely on the evaluation of the expression containing them to happen inside of a catch), and can only be caught from IO
19:00:02 <augur> i like the type signature   f a b -> g a -> g b
19:00:06 <lispy> failing to write happens because the disk fills up, then error is okay.
19:00:18 <augur> i wonder if its anything interesting
19:00:24 <Cale> So usually, if you throw an error, you do it because you just want the whole program to die right away
19:00:25 <augur> @hoogle f a b -> g a -> g b
19:00:26 <lambdabot> Control.Monad.Reader runReaderT :: ReaderT r a -> r -> m a
19:00:26 <lambdabot> Control.Monad.Trans.Reader runReader :: Reader r a -> r -> a
19:00:26 <lambdabot> Control.Monad.Reader runReader :: Reader r a -> r -> a
19:00:34 <Cale> (from pure code, that is)
19:00:38 <lispy> Cale: did you see sjw's example above?
19:00:48 <lispy> Cale: showSigned fails to show a sined value :(
19:01:09 <Cale> huh, weird
19:01:22 <lispy> It seems to happen because the negation of that number is still negative
19:01:24 <Cale> oh, no
19:01:30 <Cale> The base is negative
19:02:18 <Cale> er, no
19:02:21 <Cale> hmm
19:02:49 <sjw> it is due to the 2s complement negation breaking for - 2 ^ (n - 1)
19:02:58 <lispy> > -(-2147483648 :: Int32)
19:02:59 <lambdabot>   -2147483648
19:02:59 <lispy> yeah
19:03:18 <georges> thanks all!
19:03:35 <Cale> oh, right, hah
19:03:55 <Cale> Yeah, didn't pay attention to the fact that it was an Int32
19:04:39 <sjw> so the question is: should showSigned be partial?
19:04:56 <Rarrikins> @hoogle showSigned
19:04:57 <lambdabot> Numeric showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS
19:04:58 <Cale> I think that could be fixed
19:05:05 <Cale> :t toRational
19:05:06 <lambdabot> Real a => a -> Rational
19:05:23 <Cale> > showSigned (showHex) 0 (-2147483648 :: Rational) ""
19:05:24 <lambdabot>   No instance for (GHC.Real.Integral GHC.Real.Rational)
19:05:24 <lambdabot>    arising from a use...
19:05:24 <sjw> you would need (forall a. a -> ShowS) -> a -> ShowS
19:05:25 <Rarrikins> > showSigned shows 2 5
19:05:26 <lambdabot>   <[Char] -> [Char]>
19:05:28 <Rarrikins> > showSigned shows 2 5 ""
19:05:29 <lambdabot>   "5"
19:05:32 <sjw> or something
19:06:01 <Cale> oh, right, hmm
19:06:18 <sjw> > showSigned (showHex) 0 (toIntegral ((-2147483648 :: Int32))
19:06:19 <lambdabot>   <hint>:1:60:
19:06:19 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
19:06:26 <Cale> toInteger would help
19:06:33 <sjw> > showSigned (showHex) 0 (toIntegral ((-2147483648 :: Int32)))
19:06:34 <lambdabot>   Not in scope: `toIntegral'
19:06:35 <lambdabot>  Perhaps you meant one of these:
19:06:35 <lambdabot>    `fromIntegra...
19:06:42 <sjw> you get the idea
19:06:50 <Cale> > showSigned (showHex) 0 (toInteger (-2147483648 :: Int32)) ""
19:06:50 <lambdabot>   "-80000000"
19:07:15 <Cale> However, that would require an additional constraint
19:07:50 <Cale> > abs (-2147483648 :: Int32)
19:07:51 <lambdabot>   -2147483648
19:07:58 <sjw> hah
19:08:02 <Cale> Well, there's really nothing for it :)
19:08:19 <sjw> :t showHex
19:08:19 <lambdabot> (Integral a, Show a) => a -> ShowS
19:08:22 <Cale> (just checking that abs was consistent with negation there)
19:08:27 * hackagebot fast-logger 2.0.0 - A fast logging system  http://hackage.haskell.org/package/fast-logger-2.0.0 (KazuYamamoto)
19:08:29 * hackagebot wai-logger 2.0.0 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-2.0.0 (KazuYamamoto)
19:08:55 <Cale> :t showSigned
19:08:56 <lambdabot> Real a => (a -> ShowS) -> Int -> a -> ShowS
19:09:23 <Cale> It only needs Real, that means it can't use toInteger, but it does have access to toRational
19:10:14 <sjw> the problem is that the first argument also uses 'a'
19:10:26 <Cale> yeah
19:10:37 <sjw> so as I said, you would need something like (forall a. Real a => a -> ShowS) ...
19:10:49 <sjw> which is a bit heavyweight ...
19:11:10 <Cale> Or just split it into an integral and fractional version
19:12:00 <lispy> I'm not really sure what abs should return here
19:12:21 <Cale> lispy: Well, there's nothing better that it could produce
19:12:31 <Cale> (except perhaps bottom, if you like that)
19:12:42 <lispy> maxBound is better in some ways
19:12:47 <lispy> Kind of depends on what you want
19:13:02 <sjw> abs :: a -> a is broken anyway
19:13:04 <Cale> Given that Int32 silently allows other overflows with wraparound...
19:13:04 <sjw> for this reason
19:13:28 <c_wraith> > abs minBound :: Int
19:13:28 <lambdabot>   -9223372036854775808
19:13:29 <sjw> Cale: yeah, the main issue is that showHex raises an error ...
19:13:50 <Cale> I suppose another option would just be to make showHex, etc. more robust
19:13:52 <c_wraith> > (abs minBound :: Int) == minBound
19:13:52 <lambdabot>   True
19:14:03 <lispy> I wonder if fixing negate would be the simpliest fix
19:14:04 <sjw> yup
19:14:05 <c_wraith> proof that Int is unsigned!
19:14:06 <lispy> "fixing"
19:14:22 <c_wraith> > (abs minBound :: Word32) == minBound
19:14:23 <lambdabot>   True
19:14:44 <lispy> such as defining negate minBound == maxBound, for ints
19:14:50 <sjw> maybe the issue here is that showSigned promises to behave with negative numbers
19:15:03 <schell> man - lenses and the state monad really make things tidy
19:15:16 * sjw nods
19:16:09 <ij> How do I update a data type with only one of the fields supplied?
19:16:16 <ij> derp
19:16:29 <ij> How do I update and take other values from last record.
19:16:47 <Clint> record { thing = newthing }
19:16:54 <Rarrikins> f (Zomg _ b c) a = Zomg a b c
19:17:15 <Rarrikins> Ahh, with records, Clint's is better.
19:24:11 <ij> How do I put two IO a into MyDataType { x :: a, y :: a } with the least effor?
19:24:31 <ij> Will I have to write a lot of lambdas?
19:24:58 <Rarrikins> ij: liftM2 should work.
19:25:03 <Rarrikins> @type liftM2
19:25:04 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:25:50 <Rarrikins> So, liftM2 MyDataType ioX ioY should give you an IO MyDataType.
19:26:27 <ij> Oh, nice.
19:31:53 <carter> > -(-2147483648 )
19:31:54 <lambdabot>   2147483648
19:31:58 <carter> > -(-2147483648:: Int )
19:31:59 <lambdabot>   2147483648
19:32:02 <carter> > -(-2147483648:: Int32)
19:32:03 <lambdabot>   -2147483648
19:32:04 <carter> :(
19:32:51 <carter> lispy: c_wraith  Cale : does this have a ticket on trac?
19:33:12 <c_wraith> carter: is it different than C?
19:33:16 <carter> c_wraith: what is?
19:33:31 <carter> hrmm
19:33:48 <c_wraith> I think that's just an expected edge case.
19:33:50 <carter> > - (- 2^63 :: Int64)
19:33:51 <lambdabot>   -9223372036854775808
19:33:53 <carter> oh
19:33:55 <carter> ok
19:33:57 <c_wraith> except by people who run into it.
19:34:24 <c_wraith> two's complement representation requires that there be one more negative number in the range than positive.
19:34:30 <carter> ahh
19:34:30 <carter> ok
19:34:53 <carter> good point
19:34:54 <carter> been a long day
19:54:39 <paulschellin> So I've been attempting to get several versions of lambdabot to connect to freenode, but either due to my lack of irc knowledge or Haskell networking knowledge, but I continuously get a message "Plugin 'irc' failed with: <<timeout>>" when I try to use irc-connect. Has anyone else seen this?
19:56:49 <pavonia> There was large Haskell wiki page with all the category theory type classes and their laws explained. Anyone recalls the name of that?
19:57:04 <paulschellin> pavonia: Typeclassopedia?
19:57:30 <pavonia> Yep, thanks!
19:57:48 <paulschellin> sure thing!
20:09:57 <paulschellin> @help
20:09:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:10:01 <paulschellin> @list
20:10:01 <lambdabot> What module?  Try @listmodules for some ideas.
20:10:09 <paulschellin> @listmodules
20:10:09 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
20:10:24 <paulschellin> @version
20:10:24 <lambdabot> lambdabot 5.0
20:10:24 <lambdabot> git clone git://github.com/mokus0/lambdabot.git
20:18:40 * hackagebot wai-app-static 2.0.0 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-2.0.0 (MichaelSnoyman)
20:18:42 * hackagebot wai-eventsource 2.0.0 - WAI support for server-sent events  http://hackage.haskell.org/package/wai-eventsource-2.0.0 (MichaelSnoyman)
20:18:44 * hackagebot wai-extra 2.0.0 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-2.0.0 (MichaelSnoyman)
20:18:46 * hackagebot wai-frontend-monadcgi 2.0.0 - Run CGI apps on WAI.  http://hackage.haskell.org/package/wai-frontend-monadcgi-2.0.0 (MichaelSnoyman)
20:18:48 * hackagebot wai-handler-fastcgi 2.0.0 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-2.0.0 (MichaelSnoyman)
20:23:51 * hackagebot wai-handler-launch 2.0.0 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-2.0.0 (MichaelSnoyman)
20:23:53 * hackagebot wai-handler-scgi 2.0.0 - Wai handler to SCGI  http://hackage.haskell.org/package/wai-handler-scgi-2.0.0 (MichaelSnoyman)
20:23:55 * hackagebot wai-test 2.0.0 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-2.0.0 (MichaelSnoyman)
20:23:57 * hackagebot wai-websockets 2.0.0 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-2.0.0 (MichaelSnoyman)
20:23:59 * hackagebot warp 2.0.0 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.0.0 (MichaelSnoyman)
20:26:28 <lispy> wow. such hackagebot. very update.
20:29:01 * hackagebot warp-static 2.0.0 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-2.0.0 (MichaelSnoyman)
20:29:03 * hackagebot warp-tls 2.0.0 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-2.0.0 (MichaelSnoyman)
20:29:04 <carter> SNOYMAN
20:29:05 * hackagebot http-client 0.2.0.0 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.2.0.0 (MichaelSnoyman)
20:29:07 * hackagebot http-client-conduit 0.2.0.0 - Frontend support for using http-client with conduit  http://hackage.haskell.org/package/http-client-conduit-0.2.0.0 (MichaelSnoyman)
20:29:08 <carter> ls hehe
20:29:09 * hackagebot http-client-multipart 0.2.0.0 - Generate multipart uploads for http-client.  http://hackage.haskell.org/package/http-client-multipart-0.2.0.0 (MichaelSnoyman)
20:29:23 <dainanaki> thank goodness for snoyman
20:29:44 <carter> heh
20:29:53 <dainanaki> even if you don't agree with all of his opinions, he has built so much stuff!
20:30:19 <carter> fact
20:31:13 <dainanaki> I feel like the Haskell community ought to figure out some way to show appreciation to some of the more prolific library writers.
20:31:28 <carter> dainanaki: they get paid :)
20:31:48 <carter> get prolific enough any software ecosystem, jobs start existing
20:32:16 <dainanaki> The way I see it, they are paving the way for the rest of us to get paid to do Haskell one day.
20:32:46 <dainanaki> idunno, I just have a lot of admiration for those guys.
20:34:11 * hackagebot http-client-openssl 0.2.0.0 - http-client backend using the OpenSSL library.  http://hackage.haskell.org/package/http-client-openssl-0.2.0.0 (MichaelSnoyman)
20:34:13 * hackagebot http-client-tls 0.2.0.0 - http-client backend using the connection package and tls library  http://hackage.haskell.org/package/http-client-tls-0.2.0.0 (MichaelSnoyman)
20:34:15 * hackagebot http-conduit 2.0.0 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.0.0 (MichaelSnoyman)
20:34:17 * hackagebot http-reverse-proxy 0.3.0 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.3.0 (MichaelSnoyman)
20:34:19 * hackagebot keter 1.1.0 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.1.0 (MichaelSnoyman)
20:58:41 <paulschellin> So I'm seeing what appears to be a number of very strange parsing errors made by GHC on a particular library I'm trying to install (stateref). It is complaining about comment lines and comment blocks not having matching quotes (though they do). Is this something that I'm somehow causing perhaps?
20:59:31 <shachaf> Perhaps.
21:00:35 <lispy> that package looks really old
21:00:53 <lispy> Upload dateThu Nov 19 17:27:06 UTC 2009
21:01:05 <paulschellin> I'm not very familiar with language extensions, and this library uses MultiParamTypeCLasses and some other one
21:01:41 <lispy> that code seems to be defunct
21:01:45 <lispy> The repo link is broken
21:01:57 <paulschellin> Yeah, though it's written by James Cook (mokus0) who hosts the lambdabot repo that is being used in this channel
21:02:21 <paulschellin> https://github.com/mokus0/stateref
21:02:34 <paulschellin> ^ the new repo link
21:11:47 <paulschellin> It seems that stateref gets pulled in by random-fu through random-source.
21:12:07 <paulschellin> How does anyone else get lambdabot working then? Something must be wrong with my setup.
21:17:38 <lispy> Who runs lambdabot these days?
21:17:43 <lispy> You might ask them
21:18:17 <paulschellin> @listmodules
21:18:17 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
21:18:27 <paulschellin> @activity
21:18:27 <lambdabot> 1*total 1*#haskell
21:18:37 <paulschellin> @system
21:18:37 <lambdabot> Unknown command, try @list
21:18:45 <paulschellin> @help system
21:18:45 <lambdabot> system provides: listchans listmodules listservers list echo uptime listall join part leave msg quit flush admin ignore reconnect
21:18:48 * hackagebot yesod 1.2.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.2.4 (MichaelSnoyman)
21:18:48 <shachaf> int-e runs lambdabot these days.
21:18:50 * hackagebot yesod-auth 1.2.4 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.4 (MichaelSnoyman)
21:18:52 * hackagebot yesod-bin 1.2.5 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.5 (MichaelSnoyman)
21:18:54 * hackagebot yesod-core 1.2.6 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.6 (MichaelSnoyman)
21:18:56 * hackagebot yesod-persistent 1.2.2 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-1.2.2 (MichaelSnoyman)
21:19:45 <shachaf> But there are lots of other people you might ask.
21:19:58 <paulschellin> Ah, ok. I had originally tried to use int-e's git repo before mokus0, but then when I asked this lambdabot where it came from, it said mokus0:
21:20:01 <paulschellin> @version
21:20:02 <lambdabot> lambdabot 5.0
21:20:02 <lambdabot> git clone git://github.com/mokus0/lambdabot.git
21:20:38 <shachaf> What's using stateref?
21:20:51 <paulschellin> random-source
21:21:12 <paulschellin> At least it was for mokus0's version
21:21:56 <adnap> How do I install a package (via github) that is newer than the version on hackage?
21:22:25 <paulschellin> adnap: Clone it, then cabal configure && cabal build
21:22:57 <paulschellin> Then when it's done building, you can install it
21:22:58 <adnap> paulschellin: I got to cabal configure, but there are uninstalle dependencies. Do I have to cabal install thoes one-by-one?
21:23:47 <paulschellin> It depends on if the version you're using depends on other packages which are also higher versions than those found by cabal
21:23:58 * hackagebot yesod-static 1.2.2 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.2.2 (MichaelSnoyman)
21:24:00 * hackagebot monad-logger 0.3.3.0 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.3.0 (MichaelSnoyman)
21:24:15 <adnap> paulschellin: In the "no" case, what do I do?
21:24:48 <paulschellin> Then you should be able to pass the list of packages to cabal install and it should handle the rest for you
21:26:12 <adnap> Does cabal remove packages that are only dependencies of some other package when that package is uninstalled?
21:26:33 <paulschellin> Not that I know of.
21:27:06 <paulschellin> I don't even think you can "uninstall" packages through cabal, I think it's through a ghc utility
21:27:13 <adnap> ghc-pkg remove
21:27:25 <paulschellin> adnap: Yeah, exactly
21:27:58 <adnap> paulschellin: Does cabal build install the package after it builds it?
21:28:42 <adnap> :O
21:28:45 <adnap> Netsplit?
21:28:48 <paulschellin> I've never tried that, I normally just use "&&" to only run the install process if the build completed successfully
21:28:49 * hackagebot wai-app-file-cgi 2.0.0 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-2.0.0 (KazuYamamoto)
21:28:51 * hackagebot mighttpd2 3.0.0 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.0.0 (KazuYamamoto)
21:29:31 <adnap> paulschellin: You said "cabal configure && cabal build", so the last step is cabal build
21:30:07 <paulschellin> Sorry, I left out the install step explicitly
21:30:33 <paulschellin> I haven't had much luck getting things to build, so I've been trying not to get ahead of myself.
21:31:01 <paulschellin> cabal configure && cabal build && cabal install
21:33:49 * hackagebot wai-websockets 1.3.1.3 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-1.3.1.3 (MichaelSnoyman)
21:33:51 * hackagebot http-client 0.2.0.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.2.0.1 (MichaelSnoyman)
22:02:34 <scripty> http://lambda-the-ultimate.org/node/1546 lol
22:03:53 * hackagebot wai-app-file-cgi 2.0.1 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-2.0.1 (KazuYamamoto)
22:08:08 <pavonia> If I need to add unnecessary extra information to my data type to create an Applicative instance, is that in indication I actually don't want an Applicative instance?
22:08:46 <shachaf> Maybe.
22:08:51 <simpson> pavonia: How so?
22:09:34 <heatsink> If you don't want to use the Applicative methods, then you probably don't want an Applicative instance
22:10:07 <heatsink> If you want to use the Applicative methods but they don't seem compatible with your data type, then it's time to decide whether it's really an Applicative.
22:10:24 <pavonia> It's basically a Map with some extra features but without extra information I can't create a meaningful pure function
22:10:25 <heatsink> The wording of your question seems odd.
22:10:44 <pavonia> Yeah, it would be nice to use them
22:12:46 <pdxleif> Some people have an "Apply" typeclass, that's like Applicative, but without the "pure".
22:13:03 <jle`> actually yeah, i was wondering about that
22:13:12 <jle`> why is pure a necessary part of Applicative?
22:13:22 <heatsink> I'd go with whatever best reflects the semantics of the problem.  You might want to have an applicative and a non-applicative version of the type.
22:13:28 <shachaf> What does that question mean?
22:13:37 <jle`> shachaf: me?
22:13:40 <shachaf> Yes.
22:13:51 <jle`> well i mean you can define Applicative however you want, categorically
22:14:00 <jle`> but i feel like applicative 'solves' the case of needing <*>
22:14:06 <jle`> but i don't see why <*> requires pure
22:14:21 <shachaf> It doesn't, hence 22:06 <pdxleif> Some people have an "Apply" typeclass, that's like Applicative, but without the "pure".
22:14:33 <slapMyBishop> For people who have been regulars of the channel for a long time, as the #Haskell channel always been this popular on Freenode?  +1100 people, really?
22:14:42 <jle`> so Applicative === Apply + pure?
22:14:44 <shachaf> But let's say "for the same reason we have Monoid but not Semigroup"
22:14:48 <jle`> === is "is defined as"
22:14:49 <simpson> slapMyBishop: Generally, yeah.
22:14:50 <pdxleif> pure is necessary for it to satisfy the laws for Applicative; without that, it could only satisfy Functor laws.
22:15:01 <jle`> oh the Applicative laws involve pure
22:15:08 <shachaf> jle`: With laws and such, of course.
22:15:28 <jle`> that's kind of circular though
22:15:37 <pdxleif> Just like Apply = Functor + <*> ?
22:15:42 <slapMyBishop> simpson: wow, I'm very impressed.  I didn't think Haskell had that much of a user base outside of algebraists(sp?)
22:15:49 <shachaf> What's circular?
22:16:02 <pdxleif> circular reasoning is its own reward
22:16:06 <shachaf> No, #haskell was smaller in the past than it is now.
22:16:13 <shachaf> This is true for most IRC channels.
22:16:36 <jle`> shachaf: applicative laws mandate pure, but applicative laws were written to standardize the applicative interface
22:16:50 <jle`> so the question of why the applicative interface requires pure is unanswered
22:16:58 <slapMyBishop> the biggest thing to happen to Haskell was a youtube video of a Google Talk(?) I think, which garnered an impressive number of views.
22:17:09 <nisstyre> slapMyBishop: there are actually those of us who use Haskell to write Real (tm) programs
22:17:09 <jle`> it's just arbitrary, Applicative is defined as Apply + pure?
22:17:32 <shachaf> No, Apply isn't even mentioned in base anywhere.
22:17:40 <slapMyBishop> nisstyre: that's impressive.
22:18:00 <jle`> i meant as a definition
22:18:07 <jle`> theoretically (mathematically?)
22:18:08 <shachaf> Anyway, like I said, for the same reason Monoid has mempty.
22:20:10 <shachaf> Hmm, when I joined #haskell there were ~300 users.
22:20:42 <jle`> so Applicative is an over-answer to "i need some way to <*>"
22:20:47 <jle`> it answers that and more
22:21:52 <shachaf> If that's the question you're asking, then maybe Applicative is an over-answer.
22:22:22 <shachaf> But there are lots of ways that monoids are nicer than semigroups.
22:22:23 <jle`> if all i wanted to do was <*>, applicative allows that and more
22:22:36 <shachaf> Yes.
22:23:09 <shachaf> That's true because Applicative has more than <*>
22:28:56 * hackagebot mighttpd2 3.0.1 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.0.1 (KazuYamamoto)
22:32:00 <nisstyre> slapMyBishop: it's actually not that hard with things like http-conduit and aeson
22:32:03 <nisstyre> amongst other things
22:32:46 <slapMyBishop> nisstyre: tell that to my former self who banged his head against the computer screen trying to complete some Project Euler
22:32:48 <paulschellin> It seems like my relationship with cabal and hackage is a really bumpy one. Half the time I'm exploring interesting packages and testing them out in ghci, and the other half of the time I'm unpacking the package, digging for that one line that breaks compatibility, then attempting to install it all over again, most likely needing to repeat a few times...
22:37:39 <nisstyre> slapMyBishop: well, project euler is not a good way to learn any programming language tbh
22:37:49 <nisstyre> it's a good way to learn number theory and algebraic geometry though
22:38:16 <lispy> Doesn't it also teach you dynamic programming?
22:38:27 <lispy> I've not really done many of the problems, but that's what I've herad
22:39:33 <slapMyBishop> oh man.  My professor was lying then?  I told him I needed to get up my Haskell-fu in a hurry and he said do the Project Eulers like a boss.
22:40:30 <paulschellin> Individuals respond differently to the stimuli of various learning methods
22:43:35 <lispy> slapMyBishop: I bet what your professor was getting at is this: You need to use the language and write some real programs.
22:43:53 <lispy> slapMyBishop: Just, you know, start small.
22:44:59 <slapMyBishop> well the beginning Project Eulers were fine, and then it started ramping up pretty quickly.  I think I halted at some convex geometry problem.
22:45:24 <lispy> Read the prelude. Make sure you can implement everything in there from scratch.
22:45:57 <lispy> If you made it that far with project euler then you may already be beyond that
22:46:44 <slapMyBishop> well I don't remember making any bona fide programs.  I remember just scripting with Haskell and enjoying the math-iness of it.
22:51:29 <zRecursive> slapMyBishop: I wonder how you "scripting with Haskell" ?
22:52:08 <zRecursive> It seems haskell needs to compile the programs ?
22:52:29 <paulschellin> zRecursive: runhaskell works pretty well for scripting
22:52:35 <slapMyBishop> maybe scripting is the wrong word?  I just meant that I made single-item methods, not a program where things are talking to each other.
22:53:13 <zRecursive> paulschellin: thx
22:53:59 * hackagebot crypto-pubkey-types 0.4.1 - Generic cryptography Public keys algorithm types  http://hackage.haskell.org/package/crypto-pubkey-types-0.4.1 (VincentHanquez)
22:54:01 * hackagebot crypto-pubkey 0.2.3 - Public Key cryptography  http://hackage.haskell.org/package/crypto-pubkey-0.2.3 (VincentHanquez)
22:59:29 <roboguy_> hmm, how would you build a classic list zipper with the Zipper from lens?
23:01:10 <mm_freak_> roboguy_: the result would be of type Top :>> [a] :>> [a]
23:01:13 <mm_freak_> uhm
23:01:15 <mm_freak_> roboguy_: the result would be of type Top :>> [a] :>> a
23:03:46 <mm_freak_> does that help?
23:03:54 <roboguy_> mm_freak_: how would you take a list and turn it into that? I don't fully understand how the types work here...
23:04:29 <mm_freak_> roboguy_: the first step is to turn the list into its corresponding 1-zipper
23:04:36 <mm_freak_> the 'zipper' function does that
23:05:41 <roboguy_> mm_freak_: yeah, that would give me Top :>> [a] right (in this context)?
23:06:37 <mm_freak_> exactly
23:06:56 <mm_freak_> the next step is to expand the zipper using a traversal like 'traverse'
23:07:08 <mm_freak_> within, fromWithin, etc.
23:09:01 * hackagebot text 1.0.0.0 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.0.0.0 (BryanOSullivan)
23:09:34 <roboguy_> I wonder if I'll ever get used to lens type signatures like within :: MonadPlus m => LensLike' (Indexing (Bazaar' (Indexed Int) a)) s a -> (h :> (s :@ j)) -> m ((h :> (s :@ j)) :>> a)
23:10:28 <shachaf> That's going out of lens into its own package.
23:21:52 <jle`> i feel like i always have to re-ask this, but is there an idiomatic x >>= f >>= f >>= f ... n times?
23:22:31 <jle`> my solutions have always been unsatisfying
23:30:01 <paulschellin> jle`: Could that be maybe like a foldWith-style solution?
23:42:07 <jle`> paulschellin: like foldl (>>=) x (replicate n f) ?
23:42:38 <jle`> @pl \n -> foldl (>>=) x (replicate n f)
23:42:38 <lambdabot> foldl (>>=) x . flip replicate f
23:43:01 <pdxleif> @t iterate
23:43:01 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
23:43:04 <jle`> maybe something a bit more built-in
23:43:31 <pdxleif> Maybe something like http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:iterate, and just take the last element?
23:43:33 <jle`> like from Control.Monad
23:44:11 <pdxleif> You could write a recursive function to do that, real quick
23:44:40 <pdxleif> http://hackage.haskell.org/package/monad-loops-0.3.0.2/docs/Control-Monad-Loops.html ?
23:46:40 <jle`> i feel like there should be a library function, i seem to need to do it so often
23:46:44 <jle`> maybe i'll look there
