00:01:11 <Kron> nurupo: http://lpaste.net/96678
00:01:16 <Kron> check that out
00:01:25 <Kron> run "printFinalTree"
00:01:45 <Kron> it scans the depth of the tree and builds a 2^n x 2^n ascii grid
00:01:52 <Kron> and then prints it in a neat square
00:02:20 <nurupo> Kron: that's what i got so far, which is of course wrong :) you really need to insert in a specific position in a list https://gist.github.com/nurupo/5204b6a50ce86ceac1ed
00:02:44 <chrisdone> mgsloan: i've been aware of the concept of modal editing and its *possible* benefits for years. this personal research http://chrisdone.com/posts/emacs-key-analysis was what inspired me (i.e. data/evidence) =p but you and donri can take credit if you want, tho you both tout the editing language and not really the RSI savings ;)
00:02:47 <nurupo> for the .gif above it constructs ["00000000","00000000","00000000","11111111","00000111","00001111","11111111","11100000"]
00:03:15 <mgsloan> chrisdone: Oh true true, this is where all the vague and pseudo qualification came from
00:03:31 <nurupo> initially `n` is a dimension of a final matrix
00:03:42 <Kron> actually my solution works perfectly
00:04:16 <nurupo> oh wow, so much code
00:04:45 <Kron> note that I instanced show for Colours too
00:05:15 <Kron> xt and yt are just debug samples, i'll remove them
00:06:21 <Kron> removed
00:11:09 <Kron> oh
00:11:15 <Kron> you'll note this:
00:11:19 <Kron> getColour (Node _ _ _ _) 0 _ = undefined
00:11:33 <Kron> that's explicitly a kind of failure pattern. It should never reach that pattern
00:11:40 <Kron> I should probably replace it with a proper error message
00:14:37 * hackagebot purescript 0.1.15 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.15 (PhilFreeman)
00:14:37 * hackagebot treeviz 0.0.1 - Visualization of computation decomposition trees.  http://hackage.haskell.org/package/treeviz-0.0.1 (DavidBanas)
00:35:41 <tangentstorm> hey all. any chance we could get your haskell eval bot to come live in #learnprogramming?
00:37:30 <copumpkin> tangentstorm: int-e runs the bot now, but might be able to make it join :)
00:38:19 <tangentstorm> we had lambdabot in there for a couple days a long time ago but he disappeared. :)
00:39:04 <arkeet> great, I forgot who's in charge of lambdabot now.
00:39:09 <arkeet> was it ion
00:40:35 <Taneb> int-e,
00:40:57 <arkeet> oh I knew it was an i-person
00:41:16 <Taneb> :)
00:42:04 <Ralith> shachaf can tell it to go places, I think
00:42:47 <mikeplus64> hm, ghc 7.7 has closed type families, but why not also have closed data families? they would be like GADTs, but not.
00:43:13 <tangentstorm> @system listchans
00:43:13 <lambdabot> Unknown command, try @list
00:43:27 <tangentstorm> @list
00:43:27 <lambdabot> What module?  Try @listmodules for some ideas.
00:43:32 <tangentstorm> @list system
00:43:32 <lambdabot> system provides: listchans listmodules listservers list echo uptime
00:43:44 <tangentstorm> @listchans
00:43:44 <lambdabot> ##categorytheory ##crypto ##logic ##manatee ##megaharem ##proggit ##villagegreen #agda #arch-haskell #csa_uva #darcs #diagrams #dreamlinux-es #esoteric #fedora-haskell #friendly-coders #functionaljava #gentoo-haskell #gentoo-uy #ghc #happs #haskell #haskell-arcade #haskell-blah #haskell-books #haskell-br #haskell-fr #haskell-freebsd #haskell-game
00:43:44 <lambdabot> #haskell-gsoc #haskell-in-depth #haskell-infrastructure #haskell-lens #haskell-llvm #haskell-overflow #haskell-pl #haskell-soc #haskell.au #haskell.cz #haskell.de #haskell.dut #haskell.es #haskell.fi #haskell.hr #haskell.it #haskell.jp #haskell.no #haskell.ru #haskell.se #haskell.tw #haskell_ru #hscraft-srv #jhc #jtiger #learnanycomputerlanguage #
00:43:44 <lambdabot> ledger #lesswrong #lw-prog #macosx #macosxdev #rosettacode #scala #scalaz #scannedinavian #snapframework #tanuki #teamunix #unicycling #xmonad #yi
00:44:34 * tangentstorm 's ears perk up at #haskell-game :)
00:45:39 <tangentstorm> @join #learnprogramming
00:45:39 <lambdabot> Not enough privileges
00:45:41 <tangentstorm> aww
00:45:58 <dv-> check your privilege
00:46:08 <cswords_> looool
00:46:21 <tangentstorm> it doesn't know me yet.
00:46:31 <tangentstorm> @botsnack :)
00:46:32 <lambdabot> :)
00:46:45 <tangentstorm> i don't think it accepts bribes
00:51:24 <begriffs> OK, I've got another cabal question. When I do cabal update it changes files in ~/.cabal/packages/hackage.haskell.org rather than ~/.cabal-sandbox/packages but I think cabal install references the latter so the updates aren't helping me.
00:51:48 <shachaf> Ralith: Nope, not unless int-e adds me to the admins file.
00:51:57 <shachaf> int-e: ☝
00:52:05 <Ralith> shachaf: oh, huh. I assumed 'cuz you were lecturing gwern the other day.
00:52:09 <shachaf> (Or unless I cheat, but, y'know, cheating.)
00:57:00 <Ralith> begriffs: 'cabal update' updates the database, it doesn't upgrade anything
00:58:51 <begriffs> Ralith: it's updating 00-index.tar in my user package database but 00-index.tar in the sandbox database is unaffected which is screwing cabal install up I think
00:59:05 <Ralith> oh, I misunderstood
00:59:09 <Ralith> disregard me
00:59:23 <begriffs> I wonder if I have to mess with "package-db" in .cabal/config...
01:03:06 <easy_framework> is haskell good as your first prog lang
01:03:19 <johnw> easy_framework: sure!
01:03:54 <easy_framework> Really ?
01:03:59 <easy_framework> What about web programming with it ?
01:04:29 <johnw> easy_framework: you may not be able to start seeing immediate results as quickly as other languages
01:04:59 <easy_framework> yesod is there .. i read about it
01:04:59 <easy_framework> okay
01:05:14 <johnw> Haskell will teach you some good principles
01:06:03 <easy_framework> oh
01:06:20 <easy_framework> I just want to host programs online
01:06:31 <easy_framework> that could be used universally
01:06:41 <easy_framework> like even on an old webos / symbian phone
01:07:04 <johnw> if you just want to make web pages do stuff as rapidly as possible, Haskell may not be the best option; if you want to learn programming in order to do a lot of it in your lifetime, Haskell is an awesome choice
01:07:47 <easy_framework> I don't want to do it rapidly but eventually is it poss to achieve simple web apps with haskell ?
01:07:53 <johnw> sure
01:08:06 <johnw> yesod is pretty good at creating the scaffolding to get you started
01:08:55 <easy_framework> have you used it ?
01:09:06 <johnw> yep
01:09:13 <easy_framework> wow do you have an example ?
01:09:31 <easy_framework> Or can you tell how would the code look to add 2 number from browser ?
01:09:46 <johnw> have you seen the yesod book?
01:10:23 <nisstyre> easy_framework: Snap is pretty easy
01:10:33 <nisstyre> and simpler than Yesod
01:10:39 <easy_framework> ok
01:10:40 <Cale> I'm not sure I'd approve of using Yesod to teach Haskell... it has too many weird additional languages built into it that you'd have to get through as well.
01:10:49 <easy_framework> any1 using haskell on arch here?
01:10:53 <nisstyre> easy_framework: yes
01:11:26 <nisstyre> Cale: I disapprove of using Yesod as well
01:11:41 <nisstyre> especially if you want relatively new Haskell users to be able to modify/grok the code
01:12:00 <easy_framework> nisstyre, you on arch ??
01:12:03 <nisstyre> (which I do, since I want to write a web app for a university website with Haskell)
01:12:06 <nisstyre> easy_framework: yes
01:12:08 <easy_framework> what all packages do I need to start ??
01:12:16 <easy_framework> pacman can't find haskell
01:12:51 <nisstyre> easy_framework: pacman -Syu ghc cabal-install should be ok
01:13:12 <easy_framework> ok
01:13:35 <nisstyre> easy_framework: you may want to install a new version of cabal though
01:13:43 <nisstyre> I don't think the version in the repos supports sandboxes
01:14:24 <nisstyre> so, install cower from the AUR, then cower -d cabal-install-git ; cd cabal-install-git ; makepkg ; pacman -U *xz
01:15:19 <nisstyre> er sorry, cabal-dev-git
01:15:35 <nisstyre> or cabal-dev even
01:15:44 <nisstyre> (so many choices, ugh)
01:15:51 <easy_framework> its 60 MB !!
01:15:55 <nisstyre> yeah
01:15:57 <easy_framework> wow
01:16:01 <nisstyre> I'm lucky
01:16:07 <nisstyre> there's an Arch repo 20 minutes from me
01:16:11 <easy_framework> pacman -S ghc cabal-install
01:16:13 <nisstyre> (university of Waterloo)
01:16:57 <easy_framework> lol
01:16:57 <easy_framework> ok
01:17:10 <nisstyre> easy_framework: have you run the mirror script?
01:17:11 <easy_framework> would i need anythign else than ghc cabal-install ?
01:17:18 <nisstyre> it picks the closest/fastest mirror for you
01:17:23 <nisstyre> easy_framework: no
01:17:35 <easy_framework> For web framework ?
01:17:43 <nisstyre> cabal update ; cabal-install snap
01:18:07 <nisstyre> then follow the snap documentation
01:18:08 <easy_framework> any website for snap
01:18:26 <nisstyre> http://snapframework.com/
01:19:02 <easy_framework> license ?
01:19:09 <easy_framework> Ok
01:19:22 <easy_framework> how to start with haskell any book/resource you recommend ?
01:19:57 <nisstyre> learnyouahaskell.com
01:23:44 <mimi_vx> nisstyre: +1 .. greatbook
01:24:14 <mimi_vx> easy_framework:  and other web frameworks .. Yesod, Happstack ...
01:24:42 <mimi_vx> easy_framework: static web generator .. hakyll
01:24:48 <easy_framework> kk
01:24:49 <easy_framework> Haskell must be having an official list of frameworks
01:25:38 <mimi_vx> easy_framework: why ? is any for python ? ruby?
01:26:07 <easy_framework> Yesod/Happstack/Snap I found these three
01:27:11 <Sgeo> :t fmap return
01:27:11 <lambdabot> (Monad m, Functor f) => f a -> f (m a)
01:27:57 <Sgeo> @djinn a -> b -> a -> f b
01:27:57 <lambdabot> -- f cannot be realized.
01:28:04 <Sgeo> @djinn (Functor f) => a -> b -> a -> f b
01:28:05 <lambdabot> Error: Class not found: Functor
01:28:17 <Sgeo> :t (return .)
01:28:18 <lambdabot> Monad m => (a -> b) -> a -> m b
01:28:49 <Sgeo> @djinn (a -> b) -> a -> f b
01:28:49 <lambdabot> -- f cannot be realized.
01:28:53 <johnw> in the case where the functor is (->) e, then fmap return will do what you're looking for
01:28:58 <Sgeo> Cool
01:29:21 <Sgeo> I don't have a good intuition for turning (Functor f) => f a with the function thing yet
01:29:55 <johnw> f a -> f (m b) in that case is then (c -> a) -> c -> m b
01:30:16 <johnw> think of fmapping over functions as mutating the return value
01:30:31 <johnw> so for a function a -> b, if you want to change b to m b, then fmap return
01:30:57 <Sgeo> I already knew the fmapping over functions what that does, it's just the f a -> f (m b) into (c -> a) -> c -> m b I didn't get
01:31:00 <Sgeo> thank you
01:42:18 * easy_framework installing haskell and looking into snap/yesod
01:54:08 <mangaba_leitosa> easy_framework: My hypothesis is thatt some weeks/months must pass before installing/learning haskell for the first time and being able to use any of its web frameworks :-)
01:54:29 <mangaba_leitosa> "between", not "before" :-)
01:54:45 <easy_framework> some weeks with what ??
01:55:24 <mangaba_leitosa> easy_framework: the learning curve for Haskell is steep :-)
01:55:54 <easy_framework> Oh
01:55:56 <easy_framework> Where shud we start ?
01:56:27 <easy_framework> I try want to start with a lang for web develop .. but not that i really like python/perl/ruby
01:57:22 <mangaba_leitosa> easy_framework: you'll need to learn the fundamentals basic of functional programming if you did not do this before...
01:58:32 <easy_framework> I didn't do anything before except for a c++ that used a local font from here and printed the output also saved it in file etc
01:58:40 <easy_framework> It was a calc based program
01:58:48 <easy_framework> Also I had color in my program :p
02:04:37 <merijn_> preflex: seen Tekmo
02:04:37 <preflex>  Tekmo was last seen on #haskell-lens 8 days, 10 hours, 30 minutes and 9 seconds ago, saying: I really wish pattern match failures were redefined to be equivalent to `mzero`
02:20:20 <jle`> easy_framework: you might run into some practical problems beucase haskell is very different from c++
02:20:47 <easy_framework> are you all trying to scare me ?
02:20:49 <jle`> also starting web dev in haskell you have a lot less support than you would if you started in python, etc.
02:20:57 <jle`> not that we don't love you :)
02:21:01 <jle`> it's jjust i remember starting in ruby
02:21:07 <jle`> and finding one hundred tutorials
02:21:10 <jle`> with every google
02:21:14 <easy_framework> ya
02:21:17 <jle`> in haskell i can hardly find a couple :|
02:21:21 <easy_framework> Yep
02:21:28 <simpson> easy_framework: You should learn a language before trying to do things with it.
02:21:29 <easy_framework> Did you try Dart or GO ?
02:21:37 <easy_framework> ya
02:22:00 <easy_framework> I am a lawyer so basically i want to host my tax calc apps for everyone
02:22:09 <jle`> haskell's a grea tlanguage though :) just don't want you to be too discouraged if you run into walls starting off with a big project right away
02:22:10 <easy_framework> I want to jump into web orientied lang
02:22:57 <jle`> well always happy to welcome more haskell web devs :)
02:23:46 <easy_framework> jle`, but your correct haskell is way to diff and I need web dev lang basically
02:23:54 <jle`> there are a lot more mental hoops to jump through in haskell than other languages in terms of web dev i feel...but i think that yesod, snap, etc. do a good job of abstracting as much of it away as possible
02:24:03 <valdyn> easy_framework: there is not web dev language
02:24:10 <Cale> jle`: I don't know about that
02:24:18 <easy_framework> valdyn, Dart ?
02:24:52 <Cale> I think you ultimately have to jump through those hoops regardless, it's just Haskell doesn't let you be lazy about doing things the right way.
02:25:17 <easy_framework> some1 said try HTML5 apps when I tried i found that its HTML + JS + some server program again .. its like Rails/flask/mojolicious again
02:25:20 <Cale> Well, depending on what you're talking about.
02:25:56 <valdyn> easy_framework: that looks like a javascript replacement to me, not like what you were talking earlier (backend code)
02:26:33 <easy_framework> yep thats the issue .. tht is y i didn't want to try it
02:26:39 <easy_framework> I want something that works universally
02:26:47 <valdyn> easy_framework: so dart can be used where one might use java applets or
02:26:58 <valdyn> easy_framework: javascript or flash for instance
02:26:58 <easy_framework> yep
02:27:03 <easy_framework> ya
02:27:09 <Cale> There are a lot of frameworks out there for various dynamically typed languages which get you up and running quickly with something which gradually becomes more and more of a disaster to try to maintain.
02:28:38 <pharaun> <- has some experience with what Cale is referring to
02:28:55 <pharaun> and it is *not* fun to maintain these things
02:29:19 <easy_framework> omg
02:29:38 <easy_framework> What is the most modern way to host a program on your server which could be access by most devices ?
02:29:57 <valdyn> easy_framework: does not exist
02:30:18 <Rembane> easy_framework: ZeroMQ. :D
02:30:28 <valdyn> easy_framework: don't serve anything but html and probably javascript -> everything else will exclude many users
02:30:42 <pharaun> and css
02:30:57 <valdyn> yea, I meant that too
02:31:01 <pharaun> some occasional images is probably cool too :)
02:31:05 <valdyn> easy_framework: so dart is wrong
02:31:38 <easy_framework> Ok
02:31:57 <easy_framework> I think picking up haskell is just not the right idea then like you all said
02:32:03 <Cale> easy_framework: why?
02:32:21 <Cale> easy_framework: I didn't say that, in fact, I disagree with that sentiment :)
02:33:26 <jle`> it's a good idea
02:33:26 <easy_framework> I think Web programming in haskell with framework is heck of a job
02:33:40 <ousado> there's no quick and easy way to do web development because it's not an easy thing
02:33:43 <Cale> Well, it's a heck of a job in any language.
02:33:43 <merijn_> valdyn: You can use haskell where one might use java applets, JS or flash too :p
02:33:54 <merijn_> valdyn: Yay ghcjs \o/
02:33:59 <Rembane> It's hard to make strong typing and the web a good fit imo
02:34:00 <mangaba_leitosa> easy_framework: for frontend, there is a haskell-like language, Elm
02:34:11 <mangaba_leitosa> easy_framework: I didn't look into it myseld for real yet, though
02:34:13 <valdyn> easy_framework: depends on what you want to do. Even as a very early beginner you can pick up some haskell basics and already have a great tool to solve projecteuler.net
02:34:14 <easy_framework> Elm ?
02:34:22 <merijn_> Rembane: lolwut? No it's not
02:34:23 <mangaba_leitosa> easy_framework: yes, it compiles to Javascript
02:34:37 <merijn_> Rembane: Why would it be?
02:34:37 <jle`> actually you might want to just take a shot at NoBackend all together with something liek hoodie
02:34:42 <mangaba_leitosa> easy_framework: http://en.wikipedia.org/wiki/Elm_%28programming_language%29
02:34:43 <ousado> easy_framework: you could try haxe or you could take a look at ocaml/js_of_ocaml/eliom
02:34:50 <jle`> where the background is abstracted away for you completely
02:34:55 <jle`> you don't even need a 'framework'.
02:35:02 <valdyn> merijn_: i think someone did an i386 vm in javascript too -> lets do web apps in assemble ;)
02:35:09 <Cale> Rembane: I disagree. The difficulties don't go away when you use dynamically typed languages, they just become bugs instead of type errors.
02:35:20 <Cale> (or bugs instead of difficulties defining your types)
02:35:21 <ousado> maybe there something similarly evolved in haskell-land, I don't know
02:35:27 <merijn_> valdyn: The difference is, ghcjs is a good idea :)
02:35:33 <easy_framework> ok
02:35:34 <jle`> Cale: well you get the illusion of being productive :P
02:35:36 <easy_framework> Nobackend ? jle`
02:35:58 <merijn_> valdyn: It has a JS FFI, supports lightweight threads, STM and all GHC haskell extensions :)
02:36:05 <mangaba_leitosa> easy_framework: as far as I understand, with Elm, you write the browser-side frontend in Elm, and the backend in another language, such as Haskell
02:36:10 <jle`> nobackend is a sort of design philosophy around deploying web apps...it's admittedly pretty new and still being developed
02:36:10 <zett_zelett> https://mukeshiiitm.wordpress.com/2011/05/12/kadanes-algorithm/ Is this true? Can’t you implement Kadane’s algorithm more elegantly in Haskell?
02:36:22 <mangaba_leitosa> easy_framework: so you'd have to learn even more :-)
02:36:22 <easy_framework> ok
02:36:23 <jle`> in terms of a design philosophy/approach
02:36:25 <jle`> but
02:36:27 <Rembane> merijn_: Everything is text. :D
02:36:27 <jle`> checkout Hoodie
02:36:40 <Rembane> Cale: Indeed.
02:36:41 <zett_zelett> Oh, wait.
02:36:42 <zett_zelett> http://stackoverflow.com/questions/9041835/kadanes-algorithm-in-scala
02:36:53 <jle`> easy_framework: http://hood.ie/
02:37:00 <jle`> no backend, just frontend stuff
02:37:06 <mangaba_leitosa> easy_framework: but I'm going to try the Elm approach when I have enough time to learn it
02:37:17 <easy_framework> ok
02:37:23 <jle`> never worry about databases, all that yucky stuff
02:37:30 <jle`> you know...things that take actual time to learn how to use
02:37:34 <easy_framework> I think haskell is not just right for a newbie mangaba_leitosa you were right
02:37:47 * merijn_ strongly disagrees
02:38:09 <jle`> haskell is a good language for a newbie but i don't recommend making your first project a web app
02:38:09 <merijn> I would say learning haskell as a first language is probably the best way to go
02:38:12 <mangaba_leitosa> easy_framework: it's right. But don't expect it to be an easy path :-)
02:38:23 <merijn> The only other language I support as a first language is Agda or Idris :>
02:38:24 <easy_framework> I think for server side programming Perl/Python/Ruby is the way to go
02:38:37 <jle`> for learning? maybe
02:38:44 <jle`> for real work?
02:38:44 <valdyn> easy_framework: for small things yes, so maybe for you
02:38:45 <jle`> nah
02:38:56 <FreeFull> Idris or Agda as a first language? Are you mad?
02:39:12 <pharaun> for learning how web basics/etc works sure, but for securing things down, making sure its as bullet proof, works, etc, haskell imo
02:39:18 <easy_framework> I think I would use Perl in the end
02:39:19 <mangaba_leitosa> merijn: but easy_framework already did C++
02:39:29 <mangaba_leitosa> merijn: so it will not be the first language :-)
02:39:34 <pharaun> ah
02:39:46 <easy_framework> You guys .. I did a cpp program in 45 days
02:40:00 <merijn> FreeFull: I had a discussion with some colleagues about how to teach programming, we reached consensus that this is the optimal order to learn programming: Agda/Idris/Coq -> assembler -> haskell -> C -> something silly OO lang like python/ruby + a scheme/lisp
02:40:01 <easy_framework> it took my 30 days to understand how to compile a cpp program
02:40:23 <mangaba_leitosa> merijn: what about Prolog? :-)
02:40:23 <easy_framework> n then one week to understand how to implement a new font in the program and then color and then overnight I did it
02:40:29 <FreeFull> merijn: Why?
02:40:30 <merijn> mangaba_leitosa: Oh, good point
02:40:53 <mangaba_leitosa> easy_framework: then probably you are not afraid of difficulties and Haskell will be good for you :-)
02:41:06 <merijn> FreeFull: Because dependent types will force you to actually think and understand what you're trying to write. assembler will actually force you to understand what machines do
02:41:12 <Cale> easy_framework: This is unfortunately one of those things where you're probably not going to get a really coherent answer by asking lots of people, because everyone has different ideas and expectations in mind for what developing a web service means, and there is a wide spectrum there.
02:41:20 <merijn> FreeFull: and haskell and C let you practically use said things :)
02:41:28 <begriffs> merijn: cool. The ultimate developer bootcamp curriculum.
02:41:42 <merijn> FreeFull: Also, after agda + assembler, everything else should be piss easy
02:41:46 <jle`> merijn: i had a similar discussion with a colleague and he seemed to insist on Java -> Java -> Java
02:41:50 <easy_framework> I think web develop is not easy yet ..
02:42:13 <easy_framework> brb guys gotta close the office join you in a while
02:42:14 <Cale> easy_framework: It's not really easy in any language, when you put it in absolute terms.
02:42:26 <easy_framework> UI is the war
02:42:32 <merijn> FreeFull: There was some debate about asm first vs dependent types first, but in the end we reached consensus that a REPL + dependent types would probably be easier to see things working in :p
02:42:32 <easy_framework> UI is at war
02:44:46 <Cale> It's *doable*, but all the web-related standards are quite messy, and anything which involves any kind of fancy communication with lots of mostly-anonymous untrusted users makes security issues tricky.
02:44:59 <mangaba_leitosa> easy_framework: how much backend functionality you need? If you tax calculator can be fully done on the browser side, Elm might be worth look into :-)
02:45:15 <mangaba_leitosa> "worth looking"
02:45:33 <Cale> I tend to think that the frameworks in Haskell tend to do a pretty good job of helping you get that right.
02:46:33 <mangaba_leitosa> easy_framework: here you'll find some trivial examples demonstrating the Elm code on the left side and a working app on the right side of the browser window http://elm-lang.org/Examples.elm :-)
02:47:59 <mangaba_leitosa> easy_framework: e. g. this one is a simple graphical app reacting to mouse events with only 4 lines of code:  http://elm-lang.org/edit/examples/Reactive/ResizeYogi.elm :_)
02:48:24 <Cale> But if you're not concerned with security or performance or how solid your web application is, or how easy it will be to maintain in 2 years, then sure, one of these dynamically typed languages might be easier for you to get started with :P
02:50:15 <Cale> There are plenty of frameworks out there with which you can do a half-assed job much more easily than using Snap/HAppStack/Yesod/etc.
02:51:59 <jle`> i think he left
02:52:09 <arkeet> I should do the same
02:53:12 <zett_zelett> How the fuck is Haskell to implement Kadane’s algorithm in only two lines of code?
02:53:19 <zett_zelett> What kind of messed up magic is this?
02:53:31 <zett_zelett> +able
02:54:37 <Cale> zett_zelett: Well, to be fair, it's not so many lines of code in most languages
02:55:25 <zett_zelett> Cale: Yes, but it is something very imperative.
02:55:34 <arkeet> is it?
02:56:16 <zett_zelett> I thought so.
02:56:28 <Chousuke> Haskell is still pretty decent for imperative programming.
02:56:32 <sipa> if you express it as "iterate through the array, and for each entry compute ...", yes
02:57:06 <sipa> if you express it as "for every end position, compute ... based on a recurrance relation", no
02:58:56 <zett_zelett> I think it’s very hard to describe the essense of this algorithm.
02:59:58 <sipa> for every end position, the maxsubarraysum is either 0, or the maxsubarraysum of the previous position plus the current value, whichever is larger
03:00:00 <ReinH> zett_zelett: apparently not? ;)
03:00:04 <arkeet> @let kadane = snd . foldl' (\(a,b) x -> let a' = max 0 (a+x) in (a', max b a')) (0,0)
03:00:05 <lambdabot>  Defined.
03:00:07 <arkeet> how about one line.
03:00:36 <arkeet> maybe that ought to use bang patterns in the tuple.
03:00:57 <zett_zelett> Oh, well.
03:01:11 <arkeet> iterating through a list while keeping some state is exactly what foldl does.
03:01:33 <arkeet> I basically adapted the python example on wikipedia.
03:01:35 <arkeet> :c
03:02:30 <zett_zelett> Hm, sipa, I’m not sure that’s correct – what does this do on [1,-3]?
03:02:55 <arkeet> > kadane [-2,1,-3,4,-1,2,1,-5,4]
03:02:57 <lambdabot>   6
03:03:55 <Cale> > let kadane = snd . foldr cons (0,0) where cons x (here,soFar) = (max 0 (here + x), max soFar here) in kadane [-2,1,-3,4,-1,2,1,-5,4]
03:03:56 <lambdabot>   6
03:04:42 <Cale> > let kadane = snd . foldr cons (0,0) where cons x (here,soFar) = (max 0 (here + x), max soFar here) in kadane [1,-3]
03:04:43 <lambdabot>   0
03:04:55 <arkeet> that looks wrong.
03:04:56 <Cale> hm
03:04:59 <arkeet> > kadane [1,-3]
03:05:00 <lambdabot>   1
03:05:29 <arkeet> anyway a foldl' is probably the right way to do it.
03:05:34 <Cale> oh, right
03:05:43 <Cale> I missed the update!
03:05:51 <arkeet> heh.
03:06:49 <Cale> > let kadane = snd . foldr cons (0,0) where cons x (here, soFar) = let here' = max 0 (here + x) in (here', max soFar here') in kadane [1,-3]
03:06:50 <lambdabot>   1
03:06:53 <Cale> yes
03:07:11 <arkeet> hm, I think there's a better way.
03:07:36 <Cale> Of course, using foldl' and getting the strictness right would be better for performance
03:07:51 <Cale> (it should work in either direction just fine though)
03:11:21 <arkeet> @let kadane2 = maximum . scanl (\a x -> (max 0 (a+x))) 0
03:11:22 <lambdabot>  Defined.
03:11:33 <arkeet> I think that works.
03:11:37 <easy_framework> back
03:12:16 <isomorphic> > computeS (extract (Z :. 2) (Z :. 2) (fromListUnboxed (Z:.2) [1,2])) :: Array U DIM1 Int
03:12:17 <lambdabot>   Not in scope: type constructor or class `U'Not in scope: type constructor o...
03:12:32 <isomorphic> … hrm.  No repa.
03:12:39 <easy_framework> installing snap
03:12:50 <Cale> > let kadane = snd . foldr cons (zero,zero) where { zero = (0,[]); x +^ (y,ys) = (x+y,x:ys); cons x (here, soFar) = let here' = max zero (x +^ here) in (here', max soFar here') } in kadane [-2,1,-3,4,-1,2,1,-5,4]
03:12:51 <lambdabot>   (6,[4,-1,2,1])
03:13:14 <arkeet> what a mess =(
03:13:15 <merijn> zett_zelett: On account of very imperative code, I love haskell for imperative code, and I'm not the only one :)
03:13:31 <merijn> IO all day, erry day :>
03:13:32 <Cale> Eh, not so bad, just squished onto one line
03:13:33 <mgsloan> > let kadane = maximum . scanl (\x y -> max 0 x + y) 0 in kadane [-2,1,-3,4,-1,2,1,-5,4]
03:13:34 <lambdabot>   6
03:14:06 <arkeet> are you sure that's correct
03:14:09 <mgsloan> nope
03:14:11 <arkeet> :p
03:14:15 <mgsloan> :D
03:14:17 <merijn> I dunno what kadane is
03:14:21 <arkeet> http://en.wikipedia.org/wiki/Maximum_subarray_problem
03:14:30 <mgsloan> But the shorter it is, the more likely it's correct!
03:14:40 <mgsloan> (to a point)
03:14:42 <arkeet> =(
03:14:46 <merijn> I'm pretty sure mgsloan's computes the max difference between array elements in sorted order
03:15:29 <mgsloan> I don't think so
03:15:59 <merijn> oh wait, I'm not even sure what it does anymore :p
03:16:05 <arkeet> whatever it does it's wrong :p
03:16:15 <arkeet> > let kadane = maximum . scanl (\x y -> max 0 x + y) 0 in kadane [-1,-2]
03:16:16 <lambdabot>   0
03:16:19 <arkeet> uh
03:16:23 <arkeet> oh right uh
03:16:31 <mgsloan> I don't think it's wrong
03:16:31 <merijn> hah :p
03:16:37 <arkeet> hm it might be correct by accident
03:16:39 <mgsloan> its behavior is identical to the examples above
03:16:42 <Cale> > let zero = (0,[]); (y,ys) ^+ x = (x+y,x:ys); kadane = maximum . scanl (\x y -> max zero x ^+ y) zero in kadane [-2,1,-3,4,-1,2,1,-5,4]
03:16:43 <mgsloan> Bullcrap
03:16:43 <lambdabot>   (6,[1,2,-1,4])
03:16:48 <mgsloan> its correct by construction
03:16:51 <mgsloan> because I thought about it
03:17:00 <mgsloan> I just didn't want to assert its correctness because it's 3 AM here
03:17:02 <arkeet> ;)
03:17:03 <mgsloan> and I need to sleep
03:17:10 <merijn> Quick, someone use @check to verify!
03:17:42 <arkeet> @check \x -> kadane2 x == maximum . scanl (\x y -> max 0 x + y) 0 x
03:17:43 <lambdabot>   Couldn't match expected type `a0 -> [c0]'
03:17:43 <lambdabot>              with actual type `[a...
03:17:54 <mgsloan> Why do you think that was an accident? Because I managed to whip up a far more elegant implementation?
03:18:01 <mgsloan> Anywho
03:18:05 <arkeet> I don't think it's any more or less elegant ;)
03:18:05 <merijn> arkeet: The (.) is wrong there
03:18:08 <arkeet> duh
03:18:15 <arkeet> @check \x -> kadane2 x == (maximum . scanl (\x y -> max 0 x + y) 0) x
03:18:17 <lambdabot>   +++ OK, passed 100 tests.
03:18:36 <arkeet> @check \x -> kadane2 x == kadane x
03:18:38 <lambdabot>   +++ OK, passed 100 tests.
03:18:47 <arkeet> it's also 3am here.
03:18:59 <Cale> Are you sure it's not using [()] as the type? ;)
03:19:04 <merijn> It's a whopping noon here and I only understand half this code
03:19:05 <Cale> oh, right 0
03:19:06 <arkeet> does () have a Num instance?
03:19:11 <arkeet> also +
03:19:13 <merijn> Cale: Not unless () has a Num instance :p
03:19:15 <Cale> > 0 :: ()
03:19:16 <lambdabot>   No instance for (GHC.Num.Num ()) arising from the literal `0'
03:19:16 <lambdabot>  Possible fix...
03:19:19 <arkeet> :)
03:19:19 <Cale> okay, good
03:19:23 <Cale> Never know what's in lambdabot
03:19:36 <arkeet> it would be pretty weird for () to have a Num instance
03:19:41 <mgsloan> Hahaha, says Cale, chief captain of caleskell
03:19:42 <FreeFull> () can have a num instance. A pretty boring one.
03:19:47 <arkeet> sure
03:19:49 <merijn> arkeet: There was a Num instance for [()] a while back
03:19:53 <Cale> mgsloan: That's why I know best :)
03:19:54 <arkeet> see that one's ok
03:20:03 <mgsloan> Cale: Yup :D
03:20:03 <Cale> See, yeah, I was thinking there was
03:20:08 <Cale> Wasn't sure
03:20:15 <merijn> > 0 :: [()]
03:20:16 <lambdabot>   No instance for (GHC.Num.Num [()]) arising from the literal `0'
03:20:16 <lambdabot>  Possible f...
03:20:19 <merijn> awww
03:20:23 <mgsloan> > (+1) + (*2) $ 3
03:20:24 <lambdabot>   No instance for (GHC.Show.Show a0)
03:20:24 <lambdabot>    arising from a use of `M1208061176751...
03:20:32 <mgsloan> Aww no NumInstances
03:20:47 <Cale> But even if there's no instance in Pristine.hs, people can put them in L.hs
03:21:46 <mgsloan> @pl maximum . scanl (\x y -> max 0 x + y) 0
03:21:46 <lambdabot> maximum . scanl ((+) . max 0) 0
03:22:07 <mgsloan> zett_zelett: How's that for short! ^
03:22:29 <arkeet> @let instance a ~ () => Num [a] where (+) = (++); (-) = (\\); fromInteger = flip genericReplicate (); (*) = liftA2 (const (const ())); abs = id; signum = take 1
03:22:29 <lambdabot>  Parse failed: TypeFamilies is not enabled
03:22:31 <arkeet> aw.
03:22:37 <arkeet> @let instance Num [()] where (+) = (++); (-) = (\\); fromInteger = flip genericReplicate (); (*) = liftA2 (const (const ())); abs = id; signum = take 1
03:22:38 <lambdabot>  Defined.
03:23:32 <arkeet> > 2 * 3 :: [()]
03:23:33 <lambdabot>   [(),(),(),(),(),()]
03:23:55 * easy_framework Scared!! As Haskell is my first lang and I am going to try it right away
03:24:16 <arkeet> @let import Data.NumInstances
03:24:17 <lambdabot>  Defined.
03:24:21 <arkeet> > (+1) + (*2) $ 3
03:24:22 <lambdabot>   10
03:24:38 <Cale> easy_framework: http://learnyouahaskell.com/chapters :)
03:25:17 <easy_framework> Cale, yep I am already reading it
03:25:24 <easy_framework> starting-out
03:26:13 <Chousuke> easy_framework: don't run away when you first see weird maths-sounding jargon. most of the basic stuff is mind-bending only to the "good brain exercise" levels :P
03:26:39 <easy_framework> kk
03:27:03 <arkeet> and remember, monads are like burritos.
03:27:14 <easy_framework> lol
03:27:15 <easy_framework> ok
03:27:18 <Chousuke> :P
03:27:51 <Chousuke> arkeet: but what if you like eating just the contents of burritos?
03:28:01 <arkeet> that's unsafe and is not recommended :(
03:28:03 <easy_framework> What is different btw a functional language and a OO lang?
03:28:08 <arkeet> a lot
03:28:45 <arkeet> well, I don't think they're mutually exclusive. scala is kind of both.
03:28:58 <easy_framework> ok
03:28:59 <arkeet> but there are many differences between haskell and most OO langs that it would be easier to list the similarities.
03:29:16 <arkeet> (maybe. I haven't tried.)
03:29:20 <easy_framework> ok guys for how long shud I learn haskell and then try snap?
03:29:41 <Chousuke> easy_framework: functional programming generally favours declarative style (== expressing what you want) while OO favours imperative style (== expressing what the computer should do)
03:30:41 <FreeFull> I don't think functional is anywhere near as declarative as logic
03:30:56 <Chousuke> well, of course
03:31:23 <easy_framework> ok
03:31:39 <Chousuke> easy_framework: long story short, that's a difficult question :)
03:31:46 <easy_framework> snap is installing since last 15 mins
03:31:59 <easy_framework> ok
03:31:59 <Cale> FreeFull: It can be, it depends on how you use it.
03:32:39 <Cale> FreeFull: You can treat Prolog in a pretty operational way too (and often have to, if you want your programs to perform well).
03:32:53 <Chousuke> easy_framework: as far as how long you'll need to study haskell to use snap... I dunno, you'll at least need to be able to read Haskell and understand basic haskell things like types and typeclasses
03:33:20 <Chousuke> and then you probably can learn as you go.
03:34:05 <easy_framework> till where in that online book ?
03:34:11 <Cale> Basically once you make it through LYAH
03:34:23 <arkeet> probably should try to read the whole thing
03:34:24 <arkeet> :)
03:34:41 <arkeet> except maybe the part on zippers
03:34:54 <Cale> yeah, you shouldn't need to know about zippers :)
03:34:59 <easy_framework> I think it would take about 2-3 months to read the whole book and about 6 months to use basic haskell smartly
03:35:20 <arkeet> if you take your time, sure :)
03:35:23 <easy_framework> I would do reading haskell only for 5-6 hours a day that too on sat/sun only
03:35:42 <Chousuke> easy_framework: are you in a hurry? :)
03:36:02 <easy_framework> Chousuke, I do want to host my programs online as fast as I can
03:36:07 <Cale> easy_framework: When I first started back in 2001 or so, it took me about 2 months to feel like I could do something useful with Haskell, and about a year before I was really comfortable. We have better tutorials and documentation now though.
03:36:14 <arkeet> Chousuke: it's a shame the language isn't called curry, we could have a rhyme
03:36:29 <Chousuke> you'll at least want to understand the usual type classes ie Functor, Applicative, Monad, etc. before you start with snap
03:37:08 <Cale> Well, you might be able to get by without really understanding them fully.
03:37:18 <Chousuke> because those are things that get used everywhere and documentation will assume you already know what they do
03:37:21 <Cale> After all, you just need to learn to use particular ones
03:37:23 <Cale> But yeah
03:37:25 <easy_framework> 6 months and then only i can try snap practically
03:37:46 <easy_framework> snap or yesod or happstack ??
03:38:03 <easy_framework> I would ask this question after 6 months now
03:38:20 <Chousuke> easy_framework: or you could just read the very basics, then start with snap and go back to learning when you see something new.
03:38:36 <Chousuke> that's a possibility, though I don't know how well it would work
03:38:49 <easy_framework> What can I say I know the very basics ??
03:39:09 <Chousuke> well, you need to know the syntax at least :P
03:39:33 <easy_framework> lol
03:39:33 <easy_framework> ok
03:39:35 <Chousuke> after all, you can't even figure out what you don't understand if you have no idea how to interpret haskell code in the first place.
03:39:46 <easy_framework> omg snap is still compiling something
03:40:22 <Cale> easy_framework: Yeah, snap is a rather large bunch of libraries, and they all have lots of dependencies.
03:41:01 <arkeet> if you want to work with something more lightweight, ocharles just wrote a nice article introducing scotty :) http://ocharles.org.uk/blog/posts/2013-12-05-24-days-of-hackage-scotty.html
03:41:08 <arkeet> of course you still need to know the haskell basics
03:42:25 <easy_framework> I would do with snap .. let it compile
03:42:55 <easy_framework> Cale, Do you program for a living ?
03:43:03 <Cale> easy_framework: yeah
03:44:13 <easy_framework> when did you start and with what?
03:44:33 <Cale> When did I start programming, or when did I start programming for money? :)
03:44:45 <Cale> I started programming when I was 9 years old in Basic.
03:44:50 <Chousuke> easy_framework: do read that blog post though. I think it does a pretty good job showing basic Haskell code without using anything too fancy
03:45:34 <Cale> and I've been picking up new programming languages ever since
03:45:53 <easy_framework> Cale, Did you do web apps ?
03:46:06 <easy_framework> Chousuke, ok
03:46:57 <Cale> Most of my programming work has been in Haskell. I worked for skedge.me on their web application backend, at first attempting to maintain a horrible mess which we'd inherited written in a language called Groovy.
03:47:11 <Cale> and then later we rewrote the system in Haskell
03:47:26 <easy_framework> Wow what is that site all about?
03:48:19 <easy_framework> ok
03:48:25 <easy_framework> Well Is it in Haskell ?
03:48:25 <Cale> If you have a business, skedge.me will run your employee's calendars via a web interface, and you can have customers make appointments which will appear on those calendars.
03:48:40 <Cale> and basically, lots of things surrounding that
03:48:52 <nurupo> how to drop first elements in a list until a negative number is reached?
03:48:54 <Cale> It's written in Snap
03:49:07 <Cale> dropWhile (>= 0)
03:49:26 <nurupo> > dropWhile (>=0) [1, 2, 3, 4, -1, 5, 6, 7]
03:49:27 <lambdabot>   [-1,5,6,7]
03:49:40 <easy_framework> ok
03:49:40 <Cale> easy_framework: Well, the backend is in Snap, and the frontend is mostly Javascript.
03:49:47 <nurupo> > tail dropWhile (>=0) [1, 2, 3, 4, -1, 5, 6, 7]
03:49:48 <lambdabot>   Couldn't match expected type `(a2 -> GHC.Types.Bool) -> [t1] -> t0'
03:49:49 <lambdabot>        ...
03:49:50 <Cale> I don't know much about the frontend.
03:49:55 <nurupo> > tail $ dropWhile (>=0) [1, 2, 3, 4, -1, 5, 6, 7]
03:49:56 <lambdabot>   [5,6,7]
03:50:02 * hackagebot tasty-ant-xml 1.0.0.2 - Render tasty output to XML for Jenkins  http://hackage.haskell.org/package/tasty-ant-xml-1.0.0.2 (OliverCharles)
03:50:19 <easy_framework> Cale is slow on my pc .. JS based sites are slow on my pc
03:50:31 <Cale> easy_framework: Which browser do you use?
03:50:36 <easy_framework> firefox
03:50:43 <FreeFull> nurupo: You probably should use drop 1 rather than tail
03:50:45 <easy_framework> arch linux
03:51:15 <Cale> easy_framework: Perhaps try Chrome and see if it's any better for you. I used to use Firefox, and there are still some things it does better than Chrome, but I use Chrome now because it's a bit faster.
03:51:53 <easy_framework> chrome isn't faster on my 1 ghz dual core laptop with 6 gigs of ram idk y
03:52:15 <easy_framework> snap installed too
03:52:20 <Cale> cool
03:54:53 <easy_framework> Cale, how to check if its working ?
03:56:06 <Cale> mkdir myproject ; cd myproject; snap init
03:58:27 <easy_framework> snap command not found
03:58:37 <Cale> oh
03:58:52 <Cale> You used cabal install snap to install the snap library?
03:59:02 <Cale> Is ~/.cabal/bin in your $PATH?
03:59:39 <easy_framework> cabal install snap ... after 30 mins Snap installed
03:59:40 <easy_framework> yep
03:59:43 <easy_framework> no
04:01:37 <nurupo> > tail $ dropWhile (/=1) [1, 2, 3, 4, -1, 5, 6, 7]
04:01:38 <lambdabot>   [2,3,4,-1,5,6,7]
04:01:54 <nurupo> > tail $ dropWhile (/=-1) [1, 2, 3, 4, -1, 5, 6, 7]
04:01:54 <Cale> What I like to do is move everything from there to ~/bin and then make that directory into a symlink. You can also edit ~/.cabal/config appropriately if you want binaries to be installed elsewhere.
04:01:54 <lambdabot>   Not in scope: `/=-'
04:01:54 <lambdabot>  Perhaps you meant `/=' (imported from Data.Eq)
04:02:41 <Cale> nurupo: (as you probably realised, /= and - need a space between them)
04:02:52 <nurupo> yeah
04:06:17 <arkeet> > tail $ dropWhile (/= -1) [1, 2, 3, 4, -1, 5, 6, 7]
04:06:18 <lambdabot>   [5,6,7]
04:06:42 <arkeet> > tail $ dropWhile (/= -1) [1, 2, 3, 4, -1]
04:06:43 <lambdabot>   []
04:06:50 <arkeet> > tail $ dropWhile (/= -1) [1, 2, 3, 4]
04:06:51 <lambdabot>   *Exception: Prelude.tail: empty list
04:06:54 <arkeet> =(
04:08:03 <easy_framework> Cale, how to remove snap ?
04:09:12 <Cale> easy_framework: at this point, since you just started, the easiest way to remove everything would be to delete your ~/.ghc and ~/.cabal assuming you just installed the thing as user
04:09:52 <easy_framework> no but i want cabal i want it to install yesod
04:10:24 <Cale> Well, you'll probably end up needing a good portion of what you just built for snap with yesod as well
04:10:57 <Cale> You can unregister packages with ghc-pkg unregister <pkgname> but that doesn't actually remove the files
04:10:58 <hexagenic_> > tailMay $ dropWhile(/= (-1)) [1, 2, 3, 4]
04:10:59 <lambdabot>   Not in scope: `tailMay'
04:11:23 <hexagenic_> :<
04:11:35 <hexagenic_> > import Safe
04:11:36 <lambdabot>   <hint>:1:1: parse error on input `import'
04:12:20 <Cale> If you want to recover the disk space, you'll have to delete the relevant bits under ~/.cabal/*/packagename-version
04:13:07 <arkeet> > drop 1 $ dropWhile (/= -1) [1, 2, 3, 4]
04:13:08 <lambdabot>   []
04:13:14 <arkeet> drop 1 is a safer tail.
04:13:32 <arkeet> > preview _tail $ dropWhile (/= -1) [1, 2, 3, 4]
04:13:34 <lambdabot>   Nothing
04:13:39 <arkeet> > preview _tail $ dropWhile (/= -1) [1, 2, 3, 4, -1]
04:13:40 <lambdabot>   Just []
04:13:51 <arkeet> lenstastic.
04:14:17 <hexagenic_> :t _tail
04:14:18 <lambdabot> Cons (->) f s s a a => LensLike' f s s
04:15:14 <hexagenic_> > drop 1 []
04:15:15 <lambdabot>   []
04:15:23 <hexagenic_> :>
04:23:29 <exicer> I have some types that look like IO (Either String a). Would it be possible to wrap this up with a monad transformer? Does that even make sense? I've never really used them..
04:28:31 <supki> exicer: that's  EitherT String IO a  (from either package); wrapping makes sense if you want EitherT's >>= semantics (i.e. early termination)
04:28:50 <supki> exicer: (also I'd use something better than String for an "error" type)
04:29:03 <exicer> supki: What would you use?
04:29:10 <exicer> supki: Is this just because string is slow ?
04:31:32 <supki> exicer: I would use a custom data type probably
04:31:46 <supki> exicer: it's not about speed, but about making types more precise
04:32:29 <exicer> supki: Ok, thanks. I'll have a look at EitherT.
05:05:47 <nurupo> is there a way to increment `call` every time `f` is called?
05:07:36 <nurupo> https://gist.github.com/nurupo/5204b6a50ce86ceac1ed
05:07:40 <simon> nurupo, inside a monad, yes.
05:10:18 <nurupo> simon: example?
05:11:26 <simon> making one
05:12:56 <arkeet> what
05:13:08 <shachaf> I agreet.
05:13:11 <shachaf> argkeet?
05:13:22 <arkeet> you just need an accumulator sort of thing
05:13:24 <arkeet> in the recursion
05:13:50 <simon> shachaf, parakeet
05:14:32 <arkeet> uh
05:14:34 <arkeet> where is lpaste bot
05:14:35 <arkeet> http://lpaste.net/96692
05:14:39 <arkeet> nurupo: ^
05:15:22 <simon> I guess that's less cryptic than using a state monad :)
05:15:25 <arkeet> f' :: Integer -> [String] -> [String]
05:15:31 <nurupo> can i somehow use zipWith here?
05:15:41 <arkeet> probably
05:15:49 <simon> nurupo, zipWith works with two lists. do you have two lists of something?
05:15:57 <arkeet> you can make them!
05:16:10 <shachaf> The trouble with an answer like "inside a monad, yes" is that even if there's some way you can make technical sense of it, it's making monads sound like magic and like something is going on that you couldn't do yourself.
05:16:32 <shachaf> State, the monad, is just one way of expressing an answer.
05:17:07 <nurupo> oh wow
05:17:20 <nurupo> just opened irc log
05:17:27 <nurupo> i'm missing a lot of messages
05:17:36 <nurupo> the web log from /topic
05:17:55 <arkeet> weird
05:18:05 <shachaf> Why are there two log links in the topic?
05:18:23 <shachaf> The tunes.org one is good enough.
05:18:41 <Twey> One is the old (raw) logs; the other is chrisdone's fancy log-browsing interface
05:19:26 <arkeet> > (0$0`seq`)
05:19:27 <lambdabot>   The operator `GHC.Prim.seq' [infixr 0] of a section
05:19:27 <lambdabot>      must have lower pr...
05:19:59 <arkeet> whatever I'll just use parens
05:20:10 <Twey> What's a nice library for showing a visual plot of a function?
05:20:18 <arkeet> nurupo: http://lpaste.net/96693
05:20:28 <arkeet> wait.
05:20:32 <arkeet> the seq isn't necessary at all.
05:20:37 <Twey> (from Integer or Double to Double)
05:20:38 <arkeet> or is it.
05:20:40 <arkeet> I'm not sure.
05:20:59 <arkeet> lazy IO is evil.
05:21:12 <arkeet> or at least nasty.
05:21:22 <Twey> Purely for playing around on the command-line; I'd like to be able to just perform an action and see a plot
05:21:29 <k00mi> Twey: I had good experience with easyplot
05:22:01 <Twey> Nice, thanks
05:23:03 <arkeet> https://www.youtube.com/watch?v=2jdJGdA7AYs from around 2:48
05:23:28 <arkeet> good examples of why lazy IO is evil or at least nasty
05:23:54 <nurupo> arkeet: shouldn't that be `foo' :: Integer -> [String] -> [String]`?
05:24:18 <arkeet> no
05:24:36 <arkeet> :t zipWith
05:24:36 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
05:24:59 <arkeet> also, see what happens if you take out "s `seq`"
05:25:08 <arkeet> I'm too tired to think about it.
05:25:10 <arkeet> and too lazy to try it.
05:25:57 <arkeet> I'm guessing it makes no difference.
05:27:24 <arkeet> it's that time where I go to bed.
05:32:20 <donri> arkeet: although i'd argue the problem with that example is it's using both lazy and non-lazy IO, ie., withFile isn't lazy. of course, part of the problem is that this isn't tracked in the types...
05:32:44 <Twey> I wouldn't have nearly such a problem with lazy IO if it were clearly indicated in the types
05:32:45 <donri> maybe if we had like a LazyHandle lazy (handle) IO would be less bad
05:33:35 <donri> although maybe that only solves this particular problem; there are many others
05:51:00 <nurupo> if i have "Some" and ["Random", "Text"], how can i make it ["SomeRandom", "Text"]?
05:52:14 <Iceland_jack> > let (x:xs) = ["Random", "Text"] in (("Some" ++ x):xs)
05:52:15 <lambdabot>   ["SomeRandom","Text"]
05:55:13 <donri> > ["Random","Text"] & upon head <>~ "Some"
05:55:14 <lambdabot>   ["RandomSome","Text"]
05:55:17 <donri> :(
05:56:17 <donri> > ["Random","Text"] & _head %~ ("Some"++)
05:56:19 <lambdabot>   ["SomeRandom","Text"]
05:56:47 <sdx23> If i got a "n `mod` 2 == 0" guard, is there an easy/elegant way to do n/2 without "casting"? Right now I'm with http://lpaste.net/1926610990548385792
05:57:23 <mauke> | even n = n `div` 2
05:57:34 <sdx23> :t div
05:57:35 <lambdabot> Integral a => a -> a -> a
05:57:53 <mauke> | (n', 0) <- n `divMod` 2 = n'
05:58:20 <sdx23> ah, nice. Thanks. And is there more of an advantage to even other than being more readable?
06:04:44 <Philonous> sdx23, It states your intentions more clearly
06:05:14 <sdx23> Philonous: ya, that's true
06:05:50 <sdx23> and far nicer code; just been thinking much about performance stuff the last days.
06:07:56 <nurupo> how i split a long line of code in several smaller in haskell?
06:09:43 <Iceland_jack> Depends on the line of code, you can define subexpressions in let or where clauses or just split them with a new line
06:10:19 <Iceland_jack>     [ x + y | x ← numbers₁, y ← numbers₂ ]
06:10:20 <Iceland_jack> could become
06:10:20 <Iceland_jack>     [ x + y
06:10:20 <Iceland_jack>     | x ← numbers₁
06:10:23 <Iceland_jack>     , y ← numbers₂
06:10:26 <Iceland_jack>     ]
06:10:32 <Iceland_jack> Depending on your preference
06:14:58 <Hafydd> That dangling ] is ugly as shit.
06:16:01 <Hafydd> I'd say write it in do-notation instead, but apparently the current GHC doesn't optimise that as well.
06:19:57 <Iceland_jack> Hafydd: Your free to use your preferred style when writing examples on #haskell
06:20:03 <Iceland_jack> *Feel
06:20:57 <Hafydd> *you're
06:21:04 <Iceland_jack> Hafydd: I corrected it
06:21:32 <Hafydd> Oh. That works, too.
06:22:26 <Hafydd> Well, yes, I will feel free do that, and I welcome any comments on my style.
06:23:38 <Iceland_jack> It's possible to argue about style until the cows come home, I don't see it adding much
06:24:00 <Hafydd> My intention isn't to argue about anything.
06:24:14 <Iceland_jack> Fair enough
06:30:50 <Philonous> Can I hide globally installed packages in a cabal sandbox? They don't have profiling enabled
06:40:26 <dcoutts_> Philonous: no
06:40:28 <Feuerbach> Philonous: how about unregistering them from the global db (and never installing anything there again)?
06:42:32 <Philonous> Feuerbach, that means I can't use the package manager to install xmonad etc.
06:45:00 <Feuerbach> yeah, that's unfortunate
06:46:31 <Feuerbach> is it a big deal though? sounds like you're already comfortable with cabal — why not just cabal install xmonad?
06:48:17 <Philonous> Indeed, why use a package manager at all
06:50:04 <Philonous> Heh, sorry, didn't mean to be rude.
06:50:36 <ij> Should ~/.cabal/bin be in my path?
06:50:57 <Philonous> ij, If you want to use the binaries in there without having to specify the full path, yes
06:51:07 <Philonous> ij, I've added it to mine
06:51:38 <Philonous> I think otherwise you might get problems when cabal doesn't find alex, happy etc.
06:51:43 <ij> And c2hs.
06:52:30 <Feuerbach> Philonous: in my experience (and in yours, as I can see), mixing the package manager and cabal doesn't work well, for various reasons. Messing with the global db is one of them
06:59:55 <ij> Is cabal a package manager or a build tool?
07:00:01 <Philonous> Feuerbach, True. It's surprising, though. I wonder how hard it is to hack ghc to ignore the global db
07:00:25 <dwcook> ij, both.
07:01:10 <ij> Why both?
07:01:19 <ij> Aren't there enough package managers in the world?
07:01:29 <dwcook> Not for Haskell packages.
07:02:03 <ij> What's so special about haskell packages?
07:03:54 <dcoutts_> ij: Cabal packages can be used with ordinary package managers too. It's just that for people working on a lot of haskell packages (e.g. source trees not just published releases) it's useful to have something that can work with that
07:05:32 <dcoutts_> ij: for example, not all packages on hackage are available through distros, and indeed you'd never expect that to be the case, but you still want the advantages of package management when working with a package that someone only published 5min ago
07:06:23 <ij> Why couldn't a haskell repo be set up?
07:07:11 <dcoutts_> ij: distro repos are designed for the case where all packages can be installed simultaneously with consistent dependencies.
07:07:22 <dcoutts_> distros do a lot of hard work to make that be the case
07:07:30 <dcoutts_> (which is very useful)
07:08:07 <dcoutts_> ij: also, you'd still need custom tool to work with systems that don't have package managers, like osx and windows
07:08:27 <ij> We need to already.
07:09:06 <ij> By that I mean we've got this "cabal" thing, we might as well package some other pkg man with haskell, no?
07:09:10 <dcoutts_> ij: and there are semi-automatic tools for translating .cabal packages to rpm deb etc. The distro folks use those tools to help them package Haskell libs for the distro.
07:11:16 <Feuerbach> Philonous: ignore the global db altogether? I don't think it's a good idea. Where would you get 'base' from, for example?
07:11:52 <geekosaur> you may be looking for hsenv, which lets you virtualize an entire ghc installation?
07:12:09 <Feuerbach> Philonous: and apparently you can do that: -no-global-package-db
07:12:27 <Feuerbach> (that's ghc's flag, not cabal's)
07:12:46 <dcoutts_> ij: I'm not actually aware of any package managers that do what cabal does. Most package managers are designed for binary packages where you've already decided the versions of all dependencies.
07:13:18 <ij> Are you talking about the version number intervals?
07:13:39 <Feuerbach> the exact versions that you're going to build against
07:13:42 <dwcook> cabal is comparable to npm, for example, which provides Node packages, including source (in fact in that case it'd be hard not to include that).
07:14:22 <dwcook> But less so to apt, which is primarily for installing programs and the libraries they use.
07:14:41 <dwcook> Though apt can also fetch source packages.
07:14:58 <dcoutts_> ij: yes, the version ranges
07:15:50 <ij> I can't get xmobar working. I'm trying to include this line into commands field "                   , Run Volume "default" "Master" "volume" 5
07:16:22 <ij> and when I have "volume" instead of [] it says there are errors in the xmobarrc.
07:16:53 <ij> "Config" (line 42, column 5):\nunexpected "s"\nexpecting space or "Run"
07:27:56 <Philonous> geekosaur, That might actually work.
07:28:48 <geekosaur> ij: that's best asked over in #xmonad, but you are running into xmobar's config being a very sucky thing. you probably need ["volume"] there.
07:29:07 <geekosaur> (xmobar config looks like haskell but is not, and its parser is infamously bad at error reporting)
07:30:17 <enthropy> geekosaur: it used to be much worse
07:30:27 <enthropy> ie. just a call to reads
07:33:45 <geekosaur> ij: it also reports missing plugins as a syntax error, so you might make sure the volume plugin is actually compiled into your xmobar
07:34:13 <ij> This was my previous problem, yes.
07:34:30 <ij> Ah, I thought it's haskell.
07:35:42 * hackagebot hruby 0.1.3 - Embed Ruby in your Haskell program.  http://hackage.haskell.org/package/hruby-0.1.3 (SimonMarechal)
07:41:06 <Philonous> Feuerbach, couldn't I just copy base over to the sandbox?
07:43:57 <enthropy> geekosaur: https://github.com/jaor/xmobar/issues/139
07:45:44 * hackagebot aeson-toolkit 0.0.0 - A generalization of Aeson over Failure  http://hackage.haskell.org/package/aeson-toolkit-0.0.0 (SimonHengel)
07:51:10 <Eduard_Munteanu> Is there some TH magic that can turn typeclasses into GADTs?
08:13:51 <exicer> How can I get a value of type IO a into EitherT String IO a  ?
08:14:04 <mauke> liftIO
08:14:22 <exicer> mauke: Wouldn't that lift IO a into IO IO a ?
08:14:28 <mauke> wat
08:14:35 <Eduard_Munteanu> exicer: it's not like liftM
08:14:36 <exicer> Yeah, clearly I am missing something ;p
08:14:45 <Eduard_Munteanu> Or even plain lift.
08:14:46 <exicer> Oh
08:14:46 <mauke> IO IO is a kind error
08:14:51 <Eduard_Munteanu> :t liftIO
08:14:52 <lambdabot> MonadIO m => IO a -> m a
08:15:00 <exicer> Eduard_Munteanu: Ohh
08:15:04 <exicer> Okay, thanks :)
08:15:11 <Eduard_Munteanu> :t Control.Monad.Trans.lift
08:15:12 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
08:15:20 <mauke> :t lift
08:15:25 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
08:15:34 <Eduard_Munteanu> :t liftBase
08:15:35 <lambdabot> Not in scope: `liftBase'
08:15:40 <Eduard_Munteanu> @hoogle liftBase
08:15:40 <lambdabot> No results found
08:15:45 <Eduard_Munteanu> Nevermind.
08:16:21 <timthelion> Is there a "data-subset" ghc-extention that would allow me to write "data Foo = A | B | C" "subset Bar of Foo = A | B"?
08:17:43 <Eduard_Munteanu> timthelion: you could make a GADT
08:18:02 <timthelion> Eduard_Munteanu: does GADT provide support for that?
08:18:28 <Eduard_Munteanu> data Set = Foo | Bar
08:19:02 <timthelion> Eduard_Munteanu: you mean data Set = Foo Foo | Bar Bar?
08:19:31 <Eduard_Munteanu> data Value :: Set -> * where A :: Value s; B :: Value s; C :: Value Foo
08:19:45 <Eduard_Munteanu> timthelion: no, that's DataKinds stuff.
08:21:07 <timthelion> Eduard_Munteanu: woow that's ugly syntax ;) what does it do?
08:21:18 <ParahSailin> does what you asked
08:21:38 <enthropy> another encoding is   data A = A; data B = B; data C = C; class Foo t; instance Foo A; instance Foo B; instance Foo C; class Bar t; instance Foo A; instance Foo B
08:22:13 <enthropy> and have some method in the classes that converts the constructor into say a number
08:22:22 <Eduard_Munteanu> timthelion: it defines a (closed) kind Set, with types Foo and Bar. Then you have a GADT parametrized by Set.
08:22:26 <enthropy> GADT is better
08:22:41 <timthelion> aha, I see :) so then a function that took Bar would be of type "f :: Value Bar -> a" and a function that took Foo would be of type "g :: Value Foo -> a"?
08:22:43 <Eduard_Munteanu> Another approach is playing some subtyping tricks.
08:23:02 <Eduard_Munteanu> timthelion: yes.
08:23:38 <timthelion> Hm, perhaps one could write some template haskell to make that syntax palatable.  Though it's probably better with line breaks ;)
08:23:44 <Eduard_Munteanu> It's not easy to extend to more complex memberships.
08:23:55 <Eduard_Munteanu> timthelion: it surely is
08:30:51 * hackagebot smallcheck 1.1.0.1 - A property-based testing library  http://hackage.haskell.org/package/smallcheck-1.1.0.1 (RomanCheplyaka)
08:32:03 <Eduard_Munteanu> timthelion: another, more extensible way goes like   class (:>) (a :: Set) (b :: Set) where cast :: Value b -> Value a;   instance (s :> s) where cast x = x;    data Value :: Set -> * where A :: (s :> Bar) => Value s; B :: (s :> Bar) => Value s; C :: (s :> Foo) => Value s
08:32:18 <Eduard_Munteanu> If you want to encode it as supertyping, that is.
08:33:20 <Eduard_Munteanu> And you have Foo :> Bar, "Foo extends Bar".
08:36:54 <tangentstorm> hey, thanks int-e ! :)
08:43:41 <dwcook> Am I just missing it, or does this not list what it's supposedly a duplicate of? https://ghc.haskell.org/trac/summer-of-code/ticket/42
08:45:02 <dwcook> On a related topic, I'm interested in Haskell MUD engines people might know about.
08:45:19 <dwcook> s/MUD engines/MUDs or MUD engines/
08:45:39 <dwcook> So far I've found Yogurt.
08:48:58 <dwcook> Err, except that's a *client* library
08:49:22 <danilo2> Hello! Is there a way in Haskell to get name of a particular lens? I mean I've got a datatype "X{_field1 :: Int}" and I want to create a function "nameOf", so that "nameOf(field1)" will return String "field1" ?
08:49:48 <danilo2> I know this is doable using Generics, but I'm just thinking if there is somethink like that implemented in lenses?
08:50:39 <Eduard_Munteanu> danilo2: you can name the lenses yourself instead of relying on _x -> x
08:50:53 * hackagebot tasty 0.4.2 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.4.2 (RomanCheplyaka)
08:51:17 <Eduard_Munteanu> danilo2: actually you could just get the Name from TH.
08:51:18 <donri> functions don't have names, that's a peculiarity of record fields
08:52:36 <danilo2> Eduard_Munteanu: But I want to rely on "_" prefix. The goal I want to achive is a function, "printField", which will work as follows: "printField x field1" should output "field1 = 11".
08:52:56 <danilo2> Eduard_Munteanu: So I wanted to get the "name" of the argument (which is a lens)
08:54:12 <danilo2> Eduard_Munteanu: But ok, It seems the only way is to get it from TH. Its not perfect, but its ok. Thanks :)
08:55:29 <Eduard_Munteanu> Not sure if it's possible to have Show instances for function types, especially those involved in lenses.
08:56:14 <Eduard_Munteanu> It might work if you have unique types for fields.
08:58:24 <danilo2> Eduard_Munteanu: Unique types across all fields? I'm aksing because we are not allowed to have different types with the same name as far as I know
08:58:42 <Eduard_Munteanu> danilo2: yes
08:59:07 <danilo2> Eduard_Munteanu: Could you please tell a little more where such restriction comes from ?
09:00:45 <Eduard_Munteanu> danilo2: what I meant was you need unique types if you want Show instances for fields, e.g. fooInt :: Foo -> Int will have a Show (Foo -> Int) instance. If types repeat, you get overlapping instances.
09:01:27 <Philonous> Feuerbach, --ghc-options=-no-global-package-db doesn't seem to affect cabal
09:02:12 <danilo2> Eduard_Munteanu: Ah ok, of coure. Ok this does not suit my problem. I was only thining, that maybe lenses have some mechanism inside and allow for remembering the names :) Than you :)
09:07:28 <Eduard_Munteanu> danilo2: try using   makeLensesFor :: [(String, String)] -> Name -> Q [Dec]   instead.
09:07:37 <Feuerbach> Philonous: cabal passes its own db flags to ghc. So apparently those come later and override yours. And it wouldn't work well anyway.
09:07:49 <Eduard_Munteanu> danilo2: if you generate the names yourself, you can remember them somewhere
09:08:50 <Eduard_Munteanu> Or write a TH wrapper around that to declare names.
09:08:50 <danilo2> Eduard_Munteanu: I'll do it this way. Thanks! :)
09:09:16 <Philonous> Feuerbach, Why wouldn't it work?
09:09:47 <Philonous> Feuerbach, I've told cabal to clear the package db stack in the conf file, now it sullies itself when I query the db
09:10:18 <danilo2> By the way, there is a library System.Console.ANSI, which has got functions to color terminal output. On Unixes we can use functions returning ANSI codes (simple String) and on Windows we have to use the IO version.
09:10:29 <Feuerbach> Philonous: as I said, the global db contains essential packages (base, ghc-prim). You can't install them independently
09:10:46 <danilo2> I want to ask you, why such library does not uses ANSI codes on obth platforms and does not have a "rpinter" which will on windows convwet the codes to IO calls?
09:11:00 <Philonous> Feuerbach, I copied them over to the local package dir and recached. GHC seems to think they are working fine.
09:11:21 <Feuerbach> Philonous: oh that's dirty
09:11:25 <danilo2> I'm thinking about writing wrapper for it because operating on Strings rather than IO Strings is sometimes much more convinent
09:11:38 <Feuerbach> danilo2: oh that's dirty
09:11:41 <Eduard_Munteanu> danilo2: System.Console.ANSI sounds ANSI terminal-specific. :)
09:12:33 <danilo2> Eduard_Munteanu: Yes, especially in this library, like System.Console.ANSI.Windows? heh :)
09:13:16 <Eduard_Munteanu> I suspect neither is the proper approach.
09:13:22 <danilo2> Feuerbach: Why do you think it is dirty? It allows you to create formatting functions, which return String and then print them to console.
09:13:51 <Eduard_Munteanu> danilo2: I think something more like   data ColoredText = CT Color Text   and making a list of that is better.
09:14:33 <Eduard_Munteanu> Then the printing bits can interpret it properly.
09:15:05 <Philonous> Feuerbach, I'm not sure whether that was meant for me, but since there doesn't seem to be a clean solution I'l have to settle for one that works.
09:16:23 <Feuerbach> Philonous: yes, it was for you (too :). Sure, if it works for you, and you're happy with it, then go for it. If I were you, I'd try to clean up my global db instead.
09:16:58 <Feuerbach> e.g. you could install the profiling packages using your package manager
09:17:01 <danilo2> Eduard_Munteanu: Maybe you are right. The idea with ColoredText datatype seems much more pure.
09:17:56 <danilo2> By the way - is there any other library for printing colored text than "ansi-terminal" ? I havent found any, but maybe there is something better?
09:18:42 <Feuerbach> I'm not aware of anything better. I use it too
09:19:23 <hopf> how do I declare that (a,a) is a functor?
09:19:33 <Feuerbach> there's a higher-level package built on top of it. Something like wl-ansi-pp
09:19:34 <Philonous> Feuerbach, I'm not admitting defeat yet.
09:19:39 <Feuerbach> but I don't use it
09:19:50 <Feuerbach> hopf: using a newtype
09:20:05 <Feuerbach> newtype Pair a = Pair (a,a)
09:20:46 <hopf> Feuerbach: ahh, okay. Thanks!
09:21:00 <Iceland_jack> hopf: instance Functor Pair where fmap f (Pair (a, a)) = let fa = f a in Pair (fa, fa)
09:21:43 <Philonous> Iceland_jack, That won't work.
09:22:17 <Iceland_jack> haha, oops
09:22:18 <Philonous> instance Functor Pair where fmap f (Pair (a1, a2)) = Pair (f a1, f a2)
09:22:34 <Iceland_jack> brainfart
09:23:04 <danilo2> Feuerbach: I didnt know the wl-ansi-pprint. It's intereting but I tdo not think it solves my problem. It seems that we can chang te color of whole Document there and in this situation the solution from Eduard_Munteanu  is much more beautifull :)
09:30:35 <danilo2> Does anybody know why (++) operator is efined only for lists and is not defined as (++) = mappend ? I understand people could define it in some wrong cases, but If I'm defining custom Text datatpyes I would love to concatenate them using (++)
09:31:29 <Iceland_jack> for similar reasons that map isn't defined as fmap
09:31:30 <FreeFull> danilo2: You could always use <>
09:31:32 <quchen> danilo2: Reason: history.
09:31:44 <Eduard_Munteanu> danilo2: you can also use basic-prelude
09:31:50 <chrisdone> the reason is more random
09:32:02 <chrisdone> people were actually quite into (++) = mappend
09:32:21 <Eduard_Munteanu> :t (++)  -- has changed IIRC
09:32:22 <lambdabot> [a] -> [a] -> [a]
09:32:23 <chrisdone> the proposal had consensus, but was never implemented
09:32:35 <chrisdone> and then (<>) slipped in under the rug
09:32:35 <danilo2> Eduard_Munteanu: I'm usng basic-prelude and I have defined (++)=mappend by myself - only asking why it is not so by default
09:32:41 <FreeFull> :t (<>)
09:32:42 <lambdabot> Monoid m => m -> m -> m
09:32:43 <chrisdone> because "it looks like other libraries"
09:32:57 <nadirs> hi everyone
09:32:57 <frx> how do basic-prelude and classy-prelude compare?
09:33:08 <Eduard_Munteanu> Well, normal Prelude sucks in many ways. :)
09:33:12 <chrisdone> basic-prelude is like a more modern efficient prelude
09:33:28 <nadirs> danilo2: isn't the opposite true? I.e. "mappend = (++)" for lists?
09:33:31 <chrisdone> classy-prelude is all your prelude functionns typeclass'd up
09:33:32 <osa1> how is RWS monad different from a Reader/Writer/State monad transformer?
09:33:42 <Feuerbach> danilo2: I didn't quite get your problem with wl-ansi-pprint
09:33:47 <chrisdone> osa1: it's only one layer
09:33:51 <Eduard_Munteanu> frx: classy-prelude defines *a lot* of classes, for basic stuff. Basically a bunch of CanFoo when said type provides a Foo thingy.
09:34:03 <osa1> chrisdone: okay so other than that they're identical?
09:34:13 <danilo2> Yeah - I've implemented many functions like "print s = liftIO $ print s" in "my" prelude to change the return type from IO() to (MonadIO m , Show s) => s -> m ()
09:34:27 <Eduard_Munteanu> osa1: not very different, might be more efficient though.
09:34:30 <chrisdone> osa1: hm, taking stacking order into account, i think so
09:34:45 <danilo2> Eduard_Munteanu: more efficient? In what sense?
09:34:56 <chrisdone> in the sense of not layering three monad stacks?
09:34:57 <Eduard_Munteanu> danilo2: faster
09:35:28 <danilo2> Eduard_Munteanu: faster to compile or faster final binaries? If the second is true, why ?
09:35:30 <Eduard_Munteanu> Transformers have a bit of overhead.
09:35:49 <Eduard_Munteanu> The second.
09:36:30 <nadirs> a question about readability/style: in this lpaste (http://lpaste.net/7817994914389557248)
09:36:31 <nadirs> is the use of lambda in the function `func` unreadable and if so can it be trivially improved?
09:36:36 <danilo2> Eduard_Munteanu: hmm this is very interesting to me. Could you please tell a little more? What transformers give an overhead and why arent they optimized by the compiler?
09:37:56 <quchen> nadirs: Use 'where' and give the sub-function a name
09:38:24 <Feuerbach> nadirs: lambda is ok, I'd use flip instead of the section, though
09:38:41 <Eduard_Munteanu> danilo2: things like 'lift' (including the implicit lifts in passthrough instances of Monad*) do involve a call and dictionary passing.
09:38:46 <Feuerbach> or even eta-expand func
09:39:08 <danilo2> Eduard_Munteanu: Unless they are not inlined and optimized by compiler?
09:39:40 <danilo2> Eduard_Munteanu: If I declare my custom print (with liftIO) with INLINE pragma, it has got no overhead I think?
09:39:47 <Feuerbach> nadirs: actually... does that type-check?
09:39:50 <Eduard_Munteanu> danilo2: they can't be inlined unless you specialize first, and I think that depends on the stack.
09:40:05 <nadirs> Feuerbach: I think I forgot a parens
09:40:06 <jmcarthur> danilo2: generally avoid using INLINE unless you know you need it. ghc is very likely to inline simple, nonrecursive functions anyway
09:40:14 <Iceland_jack> Would it make sense to have a PostProcessing type class (with postprocess :: a -> a) for processing values before they get displayed by ghci?
09:40:26 <nadirs> Feuerbach: like this http://lpaste.net/7817994914389557248
09:40:47 <Iceland_jack> for example with lists:
09:40:47 <Iceland_jack>     instance PostProcess [a] where postprocess = take 200
09:41:06 <jmcarthur> Eduard_Munteanu: ghc doesn't require monomorphizing for inlining to work, afaik
09:41:14 <jmcarthur> i would be surprised if it did
09:41:15 <danilo2> jmcarthur: I know that, but I've got somewhere here a little example (using repa and accelerate), where INLINE pragma on simple one line function boosted the algorithm twice
09:41:24 <Feuerbach> nadirs: it doesn't typecheck
09:41:33 <nadirs> Feuerbach: section means the backticks notation, right?
09:41:37 <jmcarthur> danilo2: ah, for repa/accelerate stuff you basically can't trust ghc's inliner, right
09:41:46 <jmcarthur> danilo2: nor ghc's strictness analyzer
09:41:46 <Eduard_Munteanu> jmcarthur: maybe not, but how do you inline a typeclass method that's not specialized?
09:42:19 <jmcarthur> Eduard_Munteanu: oh you mean into a context that's not specialized
09:42:27 <Feuerbach> nadirs: yes
09:42:39 <danilo2> Eduard_Munteanu: They do not hae to be speciualized. As far as I know, when GHC is compiling tuff it is putting source code of not specialized functions into compiled "chunks" and use them where they should be inlined
09:42:47 <nadirs> Feuerbach: you say it doesn't typechecks?
09:42:48 <Eduard_Munteanu> jmcarthur: yeah, polymorphic caller, SPECIALIZE in the library.
09:42:48 <jmcarthur> Eduard_Munteanu: yeah, this is a reason why ghc will expose "unfoldings" from modules for the optimizer to have access to elsewhere
09:43:02 <nadirs> *typecheck
09:43:16 <Feuerbach> nadirs: the problem is that you both introduced the function's argument and then also construct a function, but the type signature says it only accepts one argument
09:43:41 <Feuerbach> so either remove 'x', or apply the right-hand side to x
09:43:45 <Feuerbach> I prefer the latter
09:43:55 <nadirs> Feuerbach: ah, yes I mistakenly added x after func!
09:44:04 <jmcarthur> Eduard_Munteanu: if i define  foo = f . show  in module A and  bar = A.foo :: Int -> String  in module B, it can usually still be specialized and inlined, due to the unfoldings in the .hi that ghc generates
09:44:05 <Eduard_Munteanu> danilo2: methods have different implementations based on the type
09:44:16 <Feuerbach> func x = whilePositive x $ \x -> ...
09:44:29 <Feuerbach> that's the most readable version for me
09:44:48 <nadirs> Feuerbach: ok, I'll apply that style
09:44:55 <Eduard_Munteanu> jmcarthur: I was thinking of typeclasses and their methods in particular
09:45:03 <jmcarthur> Eduard_Munteanu: i was using Show
09:45:29 <Eduard_Munteanu> jmcarthur: well not sure then, what gets inlined, foo or show or both?
09:45:36 <jmcarthur> both
09:45:54 <jmcarthur> Eduard_Munteanu: it will inline foo, then specialize and inline show
09:46:03 <Eduard_Munteanu> Oh, alright.
09:46:26 <nadirs> Feuerbach, quchen:  I still can't tell whether a lambda or a named function with "where" is better (mostly because can't come up with a name that doesn't require the reader to read the where alias)
09:46:31 <Eduard_Munteanu> Yeah, GHC supercompiles unlike many other compilers. :)
09:46:38 <Eduard_Munteanu> So it can do that.
09:46:44 <jmcarthur> it's nothing like supercompilation, really
09:46:59 <Eduard_Munteanu> No?
09:47:22 <jmcarthur> supercompilers usually involve some awesomeness to handle recursion, at minimum
09:47:27 <jmcarthur> ghc totally refuses to inline recursive functions
09:47:36 <Feuerbach> nadirs: personally, I'd stick with lambda
09:47:43 <nadirs> it would be the "fooify" kind of name
09:47:59 <Eduard_Munteanu> jmcarthur: just to be sure, that Show there, does Prelude have SPECIALIZE pragmas?
09:48:13 <jmcarthur> Eduard_Munteanu: it might, but i think SPECIALIZE is irrelevant here
09:48:30 <lispy> what is the definition of supercompilation? I've looked in the past and never found anything that I could make sense of.
09:48:31 <nadirs> Feuerbach: ok, I'll stick with that. Thanks a lot for the feedback! (quchen, thank you too)
09:48:31 <Eduard_Munteanu> Ok, so you mean it decides automatically to some extent.
09:49:14 <lispy> Is it technique for doing symbolic simulation at compile time for the purpose of optimization?
09:49:19 <jmcarthur> Eduard_Munteanu: if there is a SPECIALIZE pragma for the particular instance we're concerned with, it will most likely fire the generated rewrite rule after inlining foo. if there is not, it will most likely inline the show method of that particular instance anyway, unless it's recursive, achieving the same result
09:49:40 <Eduard_Munteanu> lispy: at the minimum, some notion of whole-program optimization, across compilation units.
09:49:41 <jmcarthur> Eduard_Munteanu: when you can inline, specialize doesn't help much. when you can't, specialize might still help.
09:50:50 <Eduard_Munteanu> lispy: unlike e.g. C compilers building each .c (the compilation units) separately, and they can only link them together.
09:50:51 <jmcarthur> Eduard_Munteanu: since inlining achieves specialization anyway, when inlining into a monomorphic context
09:51:27 <lispy> anecdotally, I've had a lot of success using SPECIALIZE for optimizations
09:51:32 <Eduard_Munteanu> jmcarthur: I was thinking you can inline the dict call itself
09:51:53 <lispy> Especially when I want to be general between numeric types but efficient at run time
09:51:54 <Eduard_Munteanu> E.g. in your foo above.
09:52:12 <lispy> I'm kind of impressed by how much it helps
09:52:17 <jmcarthur> yes
09:52:40 <jmcarthur> well-placed SPECIALIZE pragmas can do seemingly magical things. it is underutilized, i think
09:53:33 <jmcarthur> it's a shame that ghc doesn't do any sort of monomorphizing on its own. i don't have an idea of how hard it is to tell whether its worth the space it takes up.
09:55:43 <stolaruk> How can I use "reads" to parse "Data.Text"? Is it true that I need to use some special parsing library if I don't want to unpack the Text that I want to parse?
09:56:22 <quchen> You should use a parser if you want to parse things.
09:56:40 <stolaruk> quchen: Meaning, don't use "reads"?
09:56:42 <quchen> I don't recommend using Read except for hacking
09:56:43 <Eduard_Munteanu> stolaruk: what do you want to "read"?
09:57:00 <stolaruk> Eduard_Munteanu: A type I defined with "data"
09:57:37 <stolaruk> It's a one-off sort of thing. Not something I am doing more than once or twice in my program. Just once I think.
09:59:36 <stolaruk> Originally I made a map of value constructors to Data.Text, then I realized I could just use "reads"
09:59:49 <stolaruk> and thought that would be the typical way to do it
10:00:21 <jmcarthur> lispy: supercompilation is roughly partial evaluation that can add sharing, even recursively. for example, when partially evaluating a loop, a supercompiler is more likely to be able to avoid infinite expansions and just have the resulting expression refer to itself as well.
10:00:57 <jmcarthur> lispy: a supercompiler can often do things like fusion without requiring you to write libraries especially for that purpose
10:01:25 <jmcarthur> Eduard_Munteanu: ^^
10:02:03 <c_wraith> I still want a pragma for "specialize this function based on the value of any arguments known at compile-time"
10:02:17 <Eduard_Munteanu> Yeah, I guess my idea of supercompilation was nowhere near.
10:02:18 <jmcarthur> s/add sharing/detect or add sharing/
10:02:35 <Shin-LaC> in parsec, is there something like manyTill, but where the terminator is optional?
10:02:38 <jmcarthur> c_wraith: i want that, but for runtime ;)
10:03:13 <Eduard_Munteanu> Shin-LaC: many foo  then  optional term ?
10:03:17 <c_wraith> jmcarthur: hmm.  I guess the hotspot jvm does something like that.
10:03:24 <jmcarthur> well... sort of
10:03:47 <Shin-LaC> Eduard_Munteanu: I need manyTill's behavior of checking for the terminator first, so I can't use many
10:03:50 <jmcarthur> i'm thinking more of a partial evaluation + hotspot combination
10:03:51 <Shin-LaC> I mean, I am using many right now
10:03:57 <Shin-LaC> with notFollowedBy to check for the terminator
10:04:11 <Shin-LaC> but something like manyTill would convey my intent better, I think
10:04:25 <jmcarthur> take any closure in memory and compile it to machine code
10:05:03 <c_wraith> What I want is significantly simpler - it's mostly a bookkeeping exercise.
10:05:08 <jmcarthur> yeah
10:05:21 <jmcarthur> i'm going for more pie in the sky stuff
10:05:48 <c_wraith> I just want higher-order functions to be able to inline their arguments. :)
10:06:01 <Eduard_Munteanu> Shin-LaC: you can recurse explicitly: rec = [] <$ term <|> (:) <$> foo <*> rec
10:06:21 <jmcarthur> well, they can. you're talking about something more specific, aren't you?
10:06:42 <Eduard_Munteanu> Shin-LaC: err
10:07:03 <c_wraith> I mean something like map (+1) specializing at compile-time to something with the (+1) inlined
10:07:13 <Eduard_Munteanu> Shin-LaC: rec = [] <$ term <|> (:) <$> foo <*> rec <|> pure []
10:07:22 <jmcarthur> ah, that's actually quite harder than you make it seem
10:07:41 <Shin-LaC> Eduard_Munteanu: aah, I see
10:07:42 <jmcarthur> that's in the realm of supercompilation, unless your map function is written with fusion in mind in the first place
10:08:10 <c_wraith> It seems like it's just specializing on an argument value...  Terrible for code size, though.
10:08:19 <jmcarthur> c_wraith: unless you're willing to not have the recursive stuff specialized, in which case you could just specialize the SATed implementation of map
10:08:30 <jmcarthur> oh you just mean duplicate the code
10:08:32 <jmcarthur> i see
10:08:35 <c_wraith> yes
10:08:55 <c_wraith> similar to what the SPECIALIZE pragma does for types already.
10:09:18 <jmcarthur> ah, you're basically just asking for the ability to "inline" recursive functions into local let bindings or something
10:10:11 <jmcarthur> hmm. it's not quite that i guess. this wouldn't suffer the difficulty of avoiding recursive expansion
10:10:20 <jmcarthur> i see how this would be a pragma
10:10:29 <c_wraith> It's something that seems like it'd be easy enough to add, but hard to balance sufficiently to actually get performance gains from.
10:11:00 <c_wraith> After all, if you end up generating 100 different specialized versions of map, there's no guarantee that's a win
10:11:05 <Eduard_Munteanu> I wonder, could you do termination checking only for the purpose of cutting off inlining at some point?
10:12:25 <Eduard_Munteanu> Or to perform constant folding or loop unrolling.
10:12:46 <jmcarthur> c_wraith: a SATed map can be inlined with its first argument, actually
10:13:09 <jmcarthur> c_wraith: you could even use ghc's magical inline function to make sure it does so
10:13:28 <c_wraith> I don't think I know what SAT means in this context..
10:13:40 <jmcarthur> Static Argument Transform
10:13:48 <c_wraith> ah
10:14:08 <jmcarthur> c_wraith: where the recursive part is in a where binding or something, but the arguments that never change are bound once at the function's top level
10:15:19 <jmcarthur> c_wraith: http://blog.johantibell.com/2010/09/static-argument-transformation.html
10:15:28 <c_wraith> oh, is that the same thing as the worker/wrapper transform?
10:15:59 <jmcarthur> not quite
10:16:04 * hackagebot system-random-effect 0.4.0 - Random number generation for extensible effects.  http://hackage.haskell.org/package/system-random-effect-0.4.0 (ClarkGaebel)
10:16:52 <jmcarthur> this is something can be done just syntactically
10:17:08 <jmcarthur> ghc even has an optimization pass that can do it, but i don't know how effective it is
10:17:31 <jmcarthur> worker wrapper is more of a general class of optimizations, most of which tend to require some thought on part of the programmer
10:18:43 <jmcarthur> i think i'm wrong about worker wrapper, actually. there are a lot of cases that can be done automatically by compilers
10:19:02 <jmcarthur> e.g. turning a recursive loop into a wrapper and a worker with unboxed arguments
10:19:30 <jmcarthur> but i still maintain that this is a different thing
10:20:51 <jmcarthur> SAT is kind of the opposite of lambda lifting, i think
10:21:08 <c_wraith> I actually was at a presentation Andy Gill did on his work on worker/wrapper.  He seemed to believe just about all of the different cases can be automated, but it's a lot of work to do so.
10:21:40 <jmcarthur> i guess SAT is actually a special case of worker wrapper
10:21:51 <c_wraith> Yeah, it's the simplest case
10:22:07 <jmcarthur> i think gill's reverse example is a tougher one to do automatically
10:22:50 <nadirs> question: when I define a parametric data type can I restrict its type parameter to a typeclass or should I just do it on the functions that operate on such data type?
10:23:00 <c_wraith> nadirs: just do the latter
10:23:28 <nadirs> c_wraith: thanks. Can you confirm me that it doesn't make sense to do the former?
10:23:52 <monochrom> it makes sense to the writer. it doesn't make sense to the reader
10:24:17 <monochrom> the writer always wants to write less. the reader always wants no strings attached.
10:24:20 <c_wraith> nadirs: it's harder to do right than you think, and it often ends up making things difficult for users unnecessarily
10:24:32 <c_wraith> :t M.singleton
10:24:33 <lambdabot> k -> a -> M.Map k a
10:24:46 <c_wraith> Note how that signature doesn't put an Ord constraint on k?
10:24:59 <c_wraith> Sometimes you don't actually *need* the constraint
10:25:27 <c_wraith> (though it's tough to do much with the resulting map without the Ord constraint..)
10:25:42 <jmcarthur> :t M.toList
10:25:42 <lambdabot> M.Map k a -> [(k, a)]
10:26:55 <nadirs> c_wraith: my understanding is that you only need constraints when you operate on a data type value, not when you define data types
10:27:40 <c_wraith> nadirs: and only sometimes when you operate on the value, even. jmcarthur and I pointed out a couple functions that work with Data.Map that don't have the Ord constraint on the keys, because they don't need it.
10:28:13 <c_wraith> nadirs: so leaving the constraint out allows them to be used in some extra cases, which is sometimes handy
10:28:35 <Iceland_jack> > (snd . head . M.toList . M.singleton ()) id $ 'a'
10:28:36 <lambdabot>   'a'
10:29:17 <jmcarthur> c_wraith: i'm reading gill and hutton's paper on worker wrapper now. this actually seems quite a bit more automatable than i thought. the only part that seems to require a programmer is knowing what more efficient representation to use for the worker and how to convert back and forth, and the compiler can do all the rest.
10:29:38 <jmcarthur> this almost seems possible to make into a library
10:30:03 <jmcarthur> (the user would have to write the non-recursive bodies, unfortunately)
10:30:24 <c_wraith> Iceland_jack: except () is actually an instance of Ord. :P
10:30:41 <Iceland_jack> ah damn
10:30:43 <Iceland_jack> > (snd . head . M.toList . M.singleton id) id $ 'a'
10:30:44 <lambdabot>   'a'
10:30:47 <c_wraith> > () < ()
10:30:48 <lambdabot>   False
10:30:53 <monochrom> hehe
10:31:17 <Iceland_jack> But creating a singleton map and extracting the only value from it is a very useful thing! :)
10:35:00 <jmcarthur> it could be pretty useful to have some way of getting ghc to take a function f and generate a function g for you such that:  fix g = f
10:36:04 <hpc> jmcarthur: it exists
10:36:06 <jmcarthur> maybe it could be exposed in the form of some sort of Fix type class, so it can just apply whatever fix to it you want.
10:36:07 * hackagebot language-ecmascript 0.15.4 - JavaScript parser and pretty-printer library  http://hackage.haskell.org/package/language-ecmascript-0.15.4 (AndreyChudnov)
10:36:11 <jmcarthur> hpc: oh?
10:36:20 <hpc> it's called const
10:36:25 <jmcarthur> ugh
10:36:29 <hpc> > fix $ \_ -> 5
10:36:30 <lambdabot>   5
10:36:32 <hpc> ;)
10:36:32 <jmcarthur> yeah yeah
10:36:57 <jmcarthur> i obviously need to tighten the spec
10:37:11 <jmcarthur> not sure how
10:37:15 <dirk103> heyo!
10:37:55 <dirk103> So I'm stuck running hello world :( I'm using Leksah and when I got Package | Run. it just spits out ========== 127 ==========================
10:37:56 <hpc> jmcarthur: you would tighten it by what happens when it is not passed to fix
10:38:00 <dirk103> Infact almost anything I do outputs that
10:38:24 <hpc> so \_ -> [1..] would be [1..] no matter what
10:38:49 <hpc> but \xs -> 1 : (map succ xs) would be different
10:39:19 <cariveri> hey everyone. does anyone recommend a haskell code completion plugin for vim?
10:40:17 <supki> cariveri: neco-ghc
10:40:21 <jmcarthur> dirk103: it is not my impression that lots of people actually use leksah, so i don't know how likely you are to get an answer quickly
10:41:12 <blochchain> i've asked this here before, but does anyone have any good examples of discrete math problems that necessitate loops and temp variables in an imperative language, but are declarative and elegant in Haskell? Specifically something i prove correct in a non-trivial way.
10:42:10 <dirk103> oh, haha okay. well according to their website leksah is 'the' IDE of choice for haskell lol
10:42:20 <jmcarthur> heh
10:42:39 <Shin-LaC> is it a good idea to write down each function's type for documentation purposes?
10:42:43 <Shin-LaC> what's the preferred style?
10:43:04 <Iceland_jack> Shin-LaC: Every top-level function at least
10:43:16 <blochchain> Shin-LaC: yes, all top-level functions should have type signatures
10:43:19 <ij> fix (+3) ends in an Exception: <<loop>> on ghci, why's that
10:43:23 <Shin-LaC> ok, thanks
10:43:34 <Iceland_jack> Generally for locally defined functions as well
10:43:46 <blochchain> and anything else that has a non-obvious or tricky type signature
10:43:50 <simpson> ij: (+) is probably strict in both arguments.
10:44:04 <copumpkin> for Int it is
10:44:09 <copumpkin> or Integer
10:44:21 <copumpkin> you could define a Num instance where that would produce something (nonetheless infinite)
10:44:48 <Shin-LaC> ok, so I'll just use :t in ghci and fill them in
10:44:55 <Shin-LaC> or is there a tool to do it automatically?
10:45:13 <simpson> Shin-LaC: You should be able to look at a function that you write and have a good idea of what the types would be.
10:45:15 <Iceland_jack> Shin-LaC: Sometimes you'll want to specialize the type signatures that ghc gives you
10:45:23 <Iceland_jack> depending on your application
10:45:29 <sm> would anyone know why linking with system-filepath fails with "can't find section .text" on windows (wine) ?
10:45:59 <Shin-LaC> simpson, Iceland_jack: yes, I just wanted to start with automated output for speed and then fix it
10:48:19 <cariveri> supki: neco-ghc failed to install. thanks aynway
10:49:11 <supki> cariveri: what's the error message?
10:50:03 <Shin-LaC> the syntax coloring in sublime is getting messed up
10:51:48 <cariveri> supki: failed to install some packages: happy version >=1.17 is required, and haskell-src-exts-1.14.0
10:52:44 <Shin-LaC> should I type all the parsec parsers too?
10:53:31 <Iceland_jack> Shin-LaC: Do you have a reason not to?
10:53:33 <dirk103> I'm just getting started on functional programming coming from C++. I chose Haskell because the people dont seem as weird as Lisp people.
10:53:44 <Iceland_jack> In general you should yes
10:53:45 <dirk103> What do you guys think of Lisp?
10:54:30 <supki> cariveri: well. yeah, you'll need to install happy separately (for hlint, which ghc-mod depends on)
10:56:40 <Iceland_jack> Lisp is cool but there is no “the Lisp community”, Schemers are very different from Common Lispers which are very different from Clojurists which are…
10:56:54 <dirk103> ya
10:57:08 <dirk103> Haskell seems a lot cooler too
10:57:23 <blochchain> they seem to be a little elitist and recalcitrant
10:57:29 <dirk103> yes
10:57:49 <blochchain> absolutely insistent that parentheses are the best syntax, and that you just don't "get it"
10:58:09 <blochchain> i think Paul Graham solidified those kinds of opinions
10:58:27 <dirk103> Haskell seems to have a great library system
10:58:32 <blochchain> the parentheses is just one example
10:58:40 <chrisdone> they have a good point about parentheses. that's a bad example
10:59:02 <dirk103> Is haskells version of the standard library implemented like in C++ where it's a bunch of header files and you can get completely different versions of the same standard library
10:59:20 <dirk103> it seems like there's a ton of different compilers for haskell, do they all have their own library or do they share a common one?
10:59:39 <chrisdone> there's only really ghc that endures
10:59:39 <Iceland_jack> dirk103: There's really only one “the” Haskell compiler, the ghc
10:59:46 <chrisdone> otherwise, haskell compilers come and go
11:00:01 <statusfailed> Is there a nice lens for working on the xth element of a vector?
11:00:12 <statusfailed> which I guess you could call "indexing" if you wanted
11:00:13 <supki> statusfailed: ix?
11:00:33 <chrisdone> yhc, jhc, hugs, uhc, etc. start out useful and then bitrot
11:00:51 <dirk103> what is this FP complete?
11:00:57 <Iceland_jack> A company
11:01:05 <Iceland_jack> You can find information about them on their website
11:01:13 <dirk103> is GHC a completely opensource not owned by a company ?
11:01:47 <chrisdone> @google how to use google
11:01:48 <lambdabot> http://searchengineland.com/guide/how-to-use-google-to-search
11:01:48 <lambdabot> Title: How To Use Google To Search
11:01:52 <dirk103> GHJ:P
11:01:54 <statusfailed> supki: perfect! thanks :)
11:02:33 <blochchain> i've asked this here before, but does anyone have any good examples of discrete math problems that necessitate loops and temp variables in an imperative language, but are declarative and elegant in Haskell? Specifically something i prove correct in a non-trivial way.
11:02:41 <chrisdone> i like that there's actually a page for how to use google search
11:03:29 <dirk103> being annoying because maybe it was just by chance but a lot of the stuff i was reading last night made haskell sound like some kind of a best implemented on FP complete proprietary language
11:03:39 <Shin-LaC> ok, I actually have a reason not to give explicit types to my parser functions
11:03:49 <Shin-LaC> some are shared between different parsers with different internal states
11:03:51 <dirk103> with a subscription fee per year which is really gross
11:04:11 <Shin-LaC> and writing the fully generic type seems to confuse more than it clarifies
11:04:19 <Iceland_jack> dirk103: FPComplete is just a company, you're free not to use their services
11:04:46 <simpson> dirk103: Haskell is roughly as old and free as Python.
11:05:10 <simpson> dirk103: I personally use vim to edit and GHC to compile. All open-source and all freely available.
11:05:12 <dirk103> ahhh okay cool
11:06:47 <Mokosha> hi, anyone here have a good grasp on STM and/or GLFW?
11:07:17 <vektor> haskell newbie wants a code review: https://github.com/vektordev/haskell-playground/blob/master/src/TicTacToe.hs
11:07:28 <joelteon> does FP complete have project hosting or is it like an interactive gist?
11:07:44 <FliPPeh> So I wonder, is there a way to put a type constraint on a function that basically states "for any state monad of which the state type is t"?
11:08:07 <Iceland_jack> vektor: You may want to use a special data type for the board states: data State = Empty | X | O
11:08:11 <FliPPeh> f :: (MonadState Type m) => m () did not work
11:08:17 <simpson> FliPPeh: You could use something like `MonadState t a`.
11:08:21 <blochchain> vektor: have you used hlint?
11:08:22 <simpson> How did it not work?
11:08:27 <vektor> iceland_jack: might be worth it.
11:08:31 <vektor> blockchain: nope
11:08:44 <Iceland_jack> vektor: It increases type safety and makes the intention clearer
11:08:48 <blochchain> vektor: that's the absolute key, always start there. it's amazingly effective
11:08:52 <FliPPeh> simpson: "Non type-variable argument in the constraint: MonadState StateType m"
11:08:56 <Iceland_jack> Also second what blochchain said
11:08:59 <vektor> actually, I think there's some tiny functions missing /unimplemented in there. gotta check it in full once I get there
11:09:09 <blochchain> vektor: realistically, it would be way easier to just use a 2D list for this application
11:09:18 <vektor> kinda have no overview atm what still needs doing in there
11:09:25 <Mokosha> this program doesn't seem to register input events (i.e. seems like an infinite loop), but I suspect there's something wrong with the way that I'm using STM: https://gist.github.com/Mokosha/34eda7bd2d6b5cafd5a3
11:09:35 <simpson> FliPPeh: Oh, you might need a special LANGUAGE pragma?
11:10:11 <blochchain> vektor: data Board = [[Bool]], and then have an implementation of the show function to print the X's and O's
11:10:12 <vektor> Kinda know that the TTTField data structure sucks. Well, it at least keeps many portions of the code readable (though large)
11:10:29 <vektor> bool?
11:10:35 <vektor> it's 3 states afaik
11:10:43 <vektor> ' ', 'X','O'
11:10:52 <blochchain> a right nm
11:11:01 <blochchain> use what Iceland_jack suggested
11:11:04 <FliPPeh> simpson: FlexibleContexts it is, thanks!
11:11:27 <vektor> alright
11:11:38 <blochchain> that's safer too, as you can't have bugs in which other chars are assigned
11:11:41 <vektor> what does hlint do, how does it work?
11:11:54 <blochchain> vektor: look it up (not to be snarky)
11:12:26 <stolaruk> vektor: hlint is going to be your best friend. It gives you tips on how you could refactor your code for readability and conciseness
11:12:53 <blochchain> vektor: so:    data Square = X | O | Empty; data Board = [[Square]];      that also lets you do boards of any size, which could be interesting
11:13:04 <jmcarthur> cool! sequenceA for static length vectors is the same as transpose
11:13:16 <jmcarthur> it's what i would expect, but i just never thought about it before
11:13:18 <joelteon> can I install happy without reinstalling the whole haskell platform?
11:13:22 <vektor> blochchain: I actually just did look this up: http://www.dict.cc/?s=snarky
11:13:24 <vektor> :D
11:13:27 <Iceland_jack> blochchain: (on the flip side it allows you to break the 3×3 invariant)
11:13:31 <vektor> ;-)
11:13:32 <joejev> is there a better way to write the function: merge :: [a] -> [a] -> [a]
11:13:37 <blochchain> Iceland_jack: true
11:13:46 <Iceland_jack> But it makes it far nicer to manipulate
11:13:56 <joejev> merge as bs = concat $ zipWith (\a b -> [a,b]) as bs
11:14:04 <blochchain> Iceland_jack: that was my thought
11:14:58 <jmcarthur> joejev: i don't think that's even correct
11:14:59 <joejev> joelteon: on arch it is in the community repo I think, so you can use pacman to reinstall it
11:15:07 <khyperia> Hmm... lists are arbitrary length, fixed type, tuples are fixed length, arbitrary type... is there such thing as a fixed length, fixed type data structure?
11:15:13 <blochchain> vektor: also, generalize the getWinner function, don't explicitly cover every case
11:15:16 <jmcarthur> > let merge as bs = concat $ zipWith (\a b -> [a,b]) as bs in merge [1,2,3] [4,5,6]
11:15:17 <lambdabot>   [1,4,2,5,3,6]
11:15:24 <jmcarthur> joejev: ^^
11:15:34 <jmcarthur> oh wait
11:15:36 <jmcarthur> wrong merge
11:15:38 <vektor> blochchain: that'd require me to use another structure. Will do when I get to that point of refactoring
11:15:41 <jmcarthur> i thought you meant as in merge sort
11:15:45 <blochchain> vektor: which is possible if you use a list
11:15:46 <joelteon> joejev: oh, on osx, my mistake
11:15:47 <jmcarthur> you really mean interleave
11:15:51 <vektor> top priority is to verify this code and get it working
11:16:09 <blochchain> vektor: you're just like me when i started out :P
11:16:19 <vektor> whatcha guys think of the last 2 functions? is it apparent what they're supposed to do?
11:16:29 <blochchain> vektor: if i could give you a single tip, it would be to read more, write less, and delete once you realize it isn't ideal
11:16:37 <joejev> jmcarthur: I was wondering what that is called, is that in the standard libs or no?
11:16:44 <joejev> or is that implemenmtation fine?
11:16:46 <Iceland_jack> vektor: Why would you accept a unit/() as an argument
11:16:48 <blochchain> vektor: you'll write yourself into a corner and then waste a ton of time trying to fix it
11:17:03 <vektor> Iceland_jack: so that it complies with an external interface
11:17:35 <Iceland_jack> What borked interface is that?
11:17:38 <stolaruk> vektor: My learning process has been read LYAH, start coding, read RWH, hlint my code always, learn/recall a "trick" and refactor refactor refactor
11:17:58 <vektor> almost through LYAH by now
11:18:04 <kristof> in practice, how useful is GHC's graph reduction technique for improving the performance of code, and in what areas do you see this performance gain? Typically numerical, or also in symbolic operations?
11:18:06 <vektor> felt I could use some practicing
11:18:25 <joejev> stolaruk: I agree with the refactor thing; however, it is cute going back and looking at my project euler problems from when I just started haskell
11:18:28 <kristof> stolaruk: Didn't know haskell had a lint utility, that is nice
11:18:53 <stolaruk> joejev: Yeah I've heard other say that, too. ;)
11:19:21 <stolaruk> kristof: It is a VERY smart utility, it points out lots of great things
11:19:45 <vektor> Iceland_jack: Well, any game/simulation I implement for this project needs to be evaluated by a common statistics module. The statistics module is agnostic of the game's implementation. but since the game might have some sort of state (TTT does not, I can pretty much run a full simulation on a set of AI agents in one run) I need to inject that state into the function as well.
11:20:03 <lightquake> are there any common libraries out there that actually use phantom types to track 'taintedness' of input for, e.g., interpolation?
11:20:05 <joejev> Does anyone here know anything about diophantine equations? I am working on a library for solving quadratic diophantine eqs and I was having trouble on a specific case
11:20:31 <Iceland_jack> vektor: So you intend on replacing the unit by some state-type later on
11:20:33 <vektor> https://github.com/vektordev/haskell-playground/blob/master/src/SimplifAIFramework.hs <- see SimState here.
11:20:39 <vektor> Not for TTT
11:20:43 <stolaruk> My biggest breakthroughs thus far was when I realized I could refactor lots of my "do" blocks into beautiful chained binds, and then more recently when I realized I could use fmap and (<$>) in many places; lots of refactoring ensued
11:20:47 <vektor> but for other games, I use other stuff but ()
11:20:58 <Iceland_jack> Okay..
11:21:52 <stolaruk> Of course I had read all about monads (binds) and functors (fmap) but seeing where I could use them in my code was huge.
11:21:55 <blochchain> did i miss anything? got disconnected
11:21:58 <vektor> i.e. a artificial life simulation might be a bit more complex.
11:22:24 <joejev> stolaruk: when I learned how to use (<$>) that was a great day
11:22:31 <vektor> so I need to inject stuff into it. But the way it's now, I can use both those games in practically the same context
11:22:35 <stolaruk> joejev: Yeah major eye opener
11:22:43 <jmcarthur> stolaruk: for chaining, i tend to prefer (<=<) or (>=>) over (=<<) or (>>=)
11:22:55 <vektor> Iceland_jack: is that a decent way of handling this kind of dependency
11:22:57 <vektor> ?
11:23:09 <stolaruk> jmcarthur: I didn't know anything about those until hlint told me I could use em ;)
11:23:17 <kristof> stolaruk: I thought you were talking about graph reduction for a second (my previous question), so I was confused :P
11:23:26 <vektor> what does <$> do exactly? I know I use it somewhere in my code, but it's pure magic to me.
11:23:28 <joejev> jmcarthur: I like those when I am writing a function in pointfree form
11:23:33 <jmcarthur> vektor: it's fmap
11:23:53 <stolaruk> jmcarthur: Still don't understand em much but so far for my purposes my code has composed very well into chained >>=s
11:24:05 <joejev> vektor: it is infixed fmap, a <$> b = a `fmap` b = fmap a b
11:24:15 <vektor> slick
11:24:16 <khyperia> I've learned so many obscure operators, functions, and styles through hlint
11:24:20 <jmcarthur> stolaruk: (=<<) is to ($) as (<=<) is to (.)
11:24:34 <Iceland_jack> (<=<) and (>=>) don't get enough love imo
11:24:45 <mauke> I'm a fan of <*
11:24:59 <joejev>  mauke: what does that one do?
11:25:02 <vektor> fmap is essentially [(x,y)| x<-a, y<-b] right?
11:25:12 <Iceland_jack> no
11:25:12 <quchen> fmap is map for lists.
11:25:13 <joejev> vektor: um, no
11:25:13 <jmcarthur> (>=>) are much better for explaining the monad laws, too.    return >=> x = x; x >=> return = x; (x >=> y) >=> z = x >=> (y >=> z)
11:25:14 <stolaruk> no
11:25:19 <Iceland_jack> jmcarthur: absolutely
11:25:24 <mauke> joejev: it's like >> but returns the result of the first action
11:25:29 <Iceland_jack> doing it with (>>=) is painful
11:25:30 <ion> I’m not sure i have ever used (>=>). (<=<) is so much like (.) and i don’t tend to use (>>>) either.
11:25:43 <joejev> so it is like flip (>>)
11:25:50 <mauke> joejev: no
11:25:51 <jmcarthur> i tend to use the "forward" composition operators for "stateful" monads like state or IO
11:25:51 <khyperia> ion, what is (>>>)?
11:25:55 <joejev> wait, yeah
11:26:01 <jmcarthur> and "backward" for everything else
11:26:12 <mauke> > "ab" >> [1,2,3]
11:26:13 <lambdabot>   [1,2,3,1,2,3]
11:26:16 <Shin-LaC> what's the best way to chain actions so that both results are returned? in a tuple or list?
11:26:21 <quchen> khyperia: flip (.) for functions (from Control.Category)
11:26:23 <mauke> > flip (>>) "ab" [1,2,3]
11:26:24 <lambdabot>   "ababab"
11:26:26 <khyperia> ah
11:26:28 <mauke> > "ab" <* [1,2,3]
11:26:29 <monochrom> (>>>) is an operator of Arrow. however, as a special case, it is (.) for functions.
11:26:29 <lambdabot>   "aaabbb"
11:26:30 <ion> khyperia: flip (.)
11:26:31 <jmcarthur> (i prefer to think of (<=<) and (=<<) as "forward" actually, but i flipped my terminology since most people don't)
11:26:32 <stolaruk> vektor: Have you gotten thru the functor and applicative functor section of LYAH yet?
11:26:40 <monochrom> err, it is flip (.) for functions
11:26:41 <ion> khyperia: (for the purposes of what i was talking about)
11:26:48 <quchen> a <* b = do { result <- a; b; return result }
11:26:58 <quchen> … in monadic language
11:27:04 <vektor> nope
11:27:16 <vektor> only the small lookahead in the modules (I think) section
11:27:17 <mauke> Shin-LaC: like liftA2 (,)?
11:27:25 <stolaruk> vektor: Then you're gonna have a hard time understanding <$> and fmap
11:27:26 <jmcarthur> the confusing thing about those operators is that there is a directionality for effects and a directionality for results, and they don't *have* to line up (they do for the standard monad operators, but not necessarily for the standard applicative operators)
11:27:32 <vektor> * typeclasses section
11:27:37 <vektor> alright
11:27:49 <Shin-LaC> mauke: yes, but I want to use it for parsers
11:27:52 <vektor> will come back here with that problem then until I read through that
11:27:57 <Shin-LaC> for example, say I have a float parser and a space parser
11:28:11 <Shin-LaC> I'd like to be able to write (a,b) <- float space float
11:28:11 <mauke> ok
11:28:31 <Shin-LaC> with something between float and space and float that keeps the output of float but throws away that of space
11:28:43 <mauke> (a,b) <- liftA2 (,) float (space >> float)
11:29:09 <Shin-LaC> hm
11:29:10 <quchen> mauke: You mean liftA2 (,) (float <* space) float? :-)
11:29:23 <Shin-LaC> any way to avoid the parentheses?
11:29:32 <mauke> (a,b) <- liftA2 (,) float $ space >> float
11:29:36 <khyperia> I personally like applicative for that - (a, b) <- (,) <$> float <*> (space *> float)
11:29:36 <quchen> Eww.
11:29:45 <vektor> so, to get back to those 2 last functions of mine... if you guys can tell me what they do by briefly looking at them, I guess I didn't quite f it up. Any volunteers? ;-)
11:29:47 <mauke> khyperia: agreed
11:29:49 <ion> What khyperia said
11:30:01 <Shin-LaC> ah, yes, the applicative looks better
11:30:21 <Shin-LaC> but if I have, say, four floats, I'd rather not have to nest all the spaces and floats in parentheses
11:30:27 <stolaruk> khyperia: That's really cool. I was looking for places I could use (,) in my code today.
11:30:36 <quchen> (,) <$> float <* space <*> float  -- Less parentheses :-)
11:30:44 <Shin-LaC> ok, now it's perfect
11:30:53 <Shin-LaC> thanks!
11:30:54 <khyperia> yeah, I wasn't sure on the precedence of <* vs. <*>
11:30:58 * chrisdone casts quchen out 
11:31:05 <ion> quchen: I’d add parens to that to make it clearer for the reader.
11:31:15 <ion> (,) <$> (float <* space) <*> float
11:31:22 <vektor> ouch... I just saw something that is likely to cause a bug in my code.
11:31:33 <quchen> chrisdone: Pff.
11:31:40 <vektor> lines 106/110... declaring agents twice
11:31:41 <stolaruk> Haskell is so expressive you gotta be careful to always keep your code readable
11:31:46 <vektor> what'll that lead to?
11:31:51 <quchen> khyperia: All of the <X> operators are infixl 4 I think
11:31:58 <Iceland_jack> stolaruk: Ain't that the truth
11:31:58 <khyperia> yep, just checked in ghci
11:32:02 <mauke> harbl = (<* space); (,) <$> harbl float <*> float
11:32:29 <stolaruk> Somewhere in RWH they say "don't make your code so dense that you can't read it anymore"
11:32:58 <khyperia> I've got a huge problem with that, stolaruk. It takes me a loong time to read through haskell code.
11:33:14 <khyperia> then again, haskell is just naturally more dense than other languages.
11:33:41 <stolaruk> khyperia: Right, there is just so much more on so fewer lines. Probably doesn't take much longer to read the equivalent code in any other language
11:33:45 <Iceland_jack> stolaruk: Something which is not brought up enough: Individual snippets of “clever” code may be fairly understandable in isolation but not when combined
11:34:01 <khyperia> Exactly, stolaruk.
11:34:37 <pterygota> i'm getting an error trying to 'cabal install hoogle'
11:35:00 <pterygota> [11 of 46] Compiling General.Web      ( src/General/Web.hs, dist/build/General/Web.o )
11:35:01 <pterygota>  
11:35:01 <pterygota> src/General/Web.hs:44:19:
11:35:01 <pterygota>     Not in scope: data constructor `ResponseBuilder'
11:35:05 <Shin-LaC> hrm
11:35:13 <Shin-LaC> it does get kind of confusing with multiple spaces
11:35:22 <stolaruk> Iceland_jack: Yeah I started using "maybe" a lot, and then I binded two "maybe"s together, and it got a bit intense
11:35:31 <Iceland_jack> Good example
11:35:44 <hpc> :t maybe >>= maybe
11:35:44 <lambdabot>     Occurs check: cannot construct the infinite type:
11:35:45 <lambdabot>       b0 = a1 -> (a0 -> b0) -> Maybe a0 -> b0
11:35:45 <lambdabot>     Expected type: ((a0 -> b0) -> Maybe a0 -> b0)
11:35:54 <hpc> :(
11:35:58 <monochrom> I make a distinction between dense and clever. they have some overlap but not the same.
11:36:11 <mauke> :t maybe ?call ?me
11:36:12 <lambdabot> (?call::b, ?me::a -> b) => Maybe a -> b
11:36:19 <monochrom> clever means the proof of correctness is long and creative
11:36:36 <monochrom> dense just means short and productive
11:36:53 <mauke> as in "you dense motherfucker!"
11:37:20 <Iceland_jack> monochrom: There are also some idioms that aren't that ‘clever’ (join f x = f x x) but just look like noise to those unfamiliar with it (and it doesn't save a whole lot of characters either)
11:37:49 <quchen> > zip`ap`tail [1..10]
11:37:50 <lambdabot>   Couldn't match expected type `[a0 -> b0]'
11:37:50 <lambdabot>              with actual type `[a...
11:38:07 <mauke> quchen: $
11:38:08 <quchen> That with parentheses, for example
11:38:08 <ion> > (zip`ap`tail) [1..10]
11:38:09 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
11:38:20 <monochrom> I do not refrain from clever code. but I do include a sufficient proof sketch in comments
11:39:10 <mauke> .oO( just like Fermat )
11:39:16 <hpc> i write my clever code carefully so i don't have to revisit it
11:39:23 <hpc> if i have to revisit clever code, i rewrite it less cleverly
11:39:27 <stolaruk> What do you guys think of lines > 80 chars? Of course some ppl say that this is a bad thing. How often is code kept under 80 cols in practise?
11:39:32 <quchen> bad.
11:39:42 <mauke> stolaruk: never
11:39:45 <hpc> stolaruk: i don't really care; 80 is really narrow
11:39:53 <quchen> Right. That's the point.
11:39:53 <stolaruk> hpc: I agree
11:40:09 <hpc> and if you are physically incapable of showing lines longer than 80 characters, you deserve to not read the code
11:40:35 <quchen> If you are physically incapable of shortening the line to under 80 characters your code is crap.
11:40:42 <stolaruk> It's not like we are all typing on old terminal monitors where the lines get wrapped
11:41:16 * hackagebot aeson-toolkit 0.0.1 - A generalization of Aeson over Failure  http://hackage.haskell.org/package/aeson-toolkit-0.0.1 (SimonHengel)
11:41:30 <hpc> quchen: what about 40 characters?
11:41:33 <hpc> what about 120?
11:41:39 <hpc> what makes 80 the ideal number?
11:42:01 <quchen> Consensus on a standard on line length does. And history.
11:42:12 <valdyn> hpc: no one said that 80 is ideal
11:42:17 <hpc> then you aren't really arguing readability, though
11:42:27 <stolaruk> They DO say 80 is the ideal in RWH
11:42:33 <Kron> does anyone know how to prove [~P : P -> Q] in formal logic? using just natural deduction, no de morgan's laws
11:42:54 <hpc> it's not really RWH's place to decide that
11:43:13 <mauke> > 0x80
11:43:14 <lambdabot>   128
11:43:20 <Iceland_jack> INT
11:43:24 <hpc> I've dealt with code where the identifiers alone are long enough to make 80-columns untennable
11:43:26 <Kron> I personally restrict my code to around 70 lines
11:43:32 <zett_zelett> 137 would be an ideal length.
11:43:41 <Kron> then you probably need smaller names or local abbreviations I think
11:43:47 <zett_zelett> It’s a beautiful prime!
11:43:53 <stolaruk> hpc: It's in a section on guidelines for writing readable code. Which is primarily why I'm bringing it up here. I wonder how much consensus there actually is on this. I personally don't want to go out of my way to make my code lines that short
11:43:53 <hpc> if you try to strictly adhere to it, you would be writing your code like foo(bar, baz,<nl>quux,<nl>schnoz)
11:43:57 <heatsink> What is :, Kron
11:44:04 <quchen> zett_zelett: You can't beat 127.
11:44:32 <Kron> sorry, |-
11:44:38 <zett_zelett> What?
11:44:48 <zett_zelett> What makes 127 more beautiful than 137?
11:44:51 <monochrom> Kron: it looks like -> introduction and ~ elimination are involved
11:44:54 <stolaruk> 10
11:44:54 <Kron> I'm trying to find out a way to prove [~P |- P -> Q]
11:44:56 <valdyn> stolaruk: its not about hard limits
11:45:07 <Kron> probably, but I don't quite know how
11:45:11 <stolaruk> valdyn: I hope not ;)
11:45:15 <quchen> zett_zelett: 2^n-1! 127 is such a round number!
11:45:16 <Kron> I'm basically proving that all things are implied by false things
11:45:30 <hpc> stolaruk: just write good code ;)
11:45:38 <stolaruk> hpc: Yeah I like that.
11:45:39 <monochrom> no, you are basically using the rules of natural deduction
11:45:44 <vektor> ex false quod libet, huh?
11:45:45 <hpc> any consensus you happen to follow is just icing on the cake
11:45:46 <Iceland_jack> Kron: No, you're attempting to prove that all things are implied by the negation of the assumption holding
11:45:56 <joejev> p -> q == ~p or q, use that
11:45:59 <hpc> any consensus you don't happen to follow is probably not a useful consensus
11:46:05 <Kron> joejev: I can't
11:46:07 <Kron> that's the thing
11:46:15 <Kron> what if I can't use -> transformation
11:46:16 <joejev> Kron: why not?
11:46:16 <monochrom> no, joejev, that is not part of natural deduction. look up natural deduction
11:46:28 <Kron> I basically need to prove p -> q is the same thing as ~p v q
11:46:36 <monochrom> but well, it should go to #haskell-blah
11:46:44 <Kron> sure
11:46:49 <Kron> I actually originally went to ##logic
11:46:51 <Kron> but no-one's there
11:47:11 <joejev> ah
11:47:17 <solirc> Anyone ever seen an instance (Exception String) on Hackage?
11:47:27 <joejev> sorry about that, looked it up
11:47:32 <Shin-LaC> no, I think the applicative approach doesn't scale after all
11:47:40 <solirc> (or ever felt the need for itR
11:49:36 <Shin-LaC> what if I want to throw away the result of two parsers in a row?
11:49:39 <statusfailed> is it possible to apply multiple mutators simultaneously with lens?
11:49:58 <frx> statusfailed can you give an example?
11:50:07 <statusfailed> ok, let's say I have (1, 2, 3)
11:50:15 <simpson> statusfailed: Well, ultimately, I think that you have to pick one of them to go first.
11:50:18 <quchen> ignore1 *> ignore2 *> don't_ignore
11:50:21 <quchen> Shin-LaC: ^
11:50:31 <statusfailed> I want to apply different functions to each field, say show, (*10) and log
11:50:56 <statusfailed> actually, I don't necessarily need to change the types
11:51:01 <statusfailed> but that would be cooler
11:51:12 <simpson> > (1, 2, 3) & _1 *~ 10 & _2 +~ 4
11:51:13 <lambdabot>   (10,6,3)
11:51:35 <simpson> > (1, 2, 3) & _1 *~ 10 & _2 .~ 'a'
11:51:37 <lambdabot>   (10,'a',3)
11:51:52 <statusfailed> so the problem is that the (1, 2, 3) structure might come from another, somewhat expensive lens
11:52:00 <statusfailed> say, parsing a JSON string
11:52:05 <statusfailed> and I don't want to do it 3 times
11:52:09 <zett_zelett> quchen: 127 = 2⁷-1 is indeed beautiful. I never thought of it that way.
11:52:10 <Shin-LaC> quchen: I'm trying to do ign1 *> ign2 *> keep1 <* ign3 <*> keep2 , but it's not working
11:52:28 <simpson> statusfailed: You'll have to share it locally somehow.
11:52:31 <zett_zelett> quchen: Is there a story behind your name?
11:53:55 <Shin-LaC> I can use parentheses
11:54:06 <Shin-LaC> but I wanted to avoid them
11:54:14 <Shin-LaC> how do I find out the precedence of an operator?
11:54:22 <statusfailed> simpson: might that look like this? let x = someString ^? bigLens in (x & _1 %~ show & _2 %~ log)
11:54:23 <mauke> :i in ghci
11:54:35 <Shin-LaC> thanks
11:54:46 <supki> > (1, 2, 3) & partsOf each %~ zipWith id [(+2), (*4), subtract 10]
11:54:48 <lambdabot>   (3,8,-7)
11:54:58 <Shin-LaC> they're all infixl 4
11:55:23 <simpson> statusfailed: That'd be a working start, yeah.
11:55:26 <statusfailed> supki: does that require each function to have the same type?
11:55:56 <supki> statusfailed: yeah, they're in a list
11:56:57 <statusfailed> supki: ... ha whoops :p
11:57:45 <statusfailed> ok, these two suggestions are cool, I can go from here- thanks :)
12:00:07 <Shin-LaC> (,) <$> float <*> float <- this works
12:00:19 <Shin-LaC> (,) <$> sp *> float <*> float <- this doesn't
12:00:47 <Shin-LaC> (,) <$> (sp *>) float <*> float <- but this does
12:02:38 <Shin-LaC> grr
12:03:38 <jmcarthur> Shin-LaC: having to use parens here and there is a far cry from "doesn't scale"
12:04:06 <jmcarthur> Shin-LaC: i don't think anybody has been advertising Applicative as being a way to avoid parentheses
12:04:12 <Shin-LaC> jmcarthur: yes, but it's confusing
12:04:22 <Shin-LaC> why do I need parentheses there?
12:04:27 <heatsink>  Applicative is a way to replace parentheses with angle brackets
12:04:31 <jmcarthur> Shin-LaC: is it confusing when you need parens for a math expression?
12:04:50 <Shin-LaC> well, no
12:05:16 <jmcarthur> there has to be some sort of precedence, and sometimes it isn't what you want, but it's what you have.
12:05:53 <scott_> (,) <$> (sp *> float) <*> float -- seems to me like (,) is getting arguments (sp *> float) and float (via Applicative). Does it make sense that way?
12:06:13 <scott_> I may be misunderstanding, too ;)
12:06:21 <jmcarthur> that sounds right to me
12:06:31 <jmcarthur> == liftA2 (,) (sp *> float) float
12:06:37 <scott_> Right
12:07:31 <Shin-LaC> the crazy thing is that the parser seems to produce a Float instead of two
12:07:41 <Shin-LaC> I have the precedence completely wrong, I guess
12:08:52 <heatsink> Is it valid to put only one float in the input string at that position?
12:10:15 <Shin-LaC> oh
12:10:16 <Shin-LaC> ooh
12:10:38 <Shin-LaC> I got it
12:11:31 <kayloos> I'm using Network.Curl and having trouble with responses that are ISO-8859-1. Its easy to find a conversion function (Text.Encoding, Text.ICU), but I don't know how to only perform the conversion if the encoding is ISO-8859-1 and do nothing if it is the correct encoding (UTF-8)
12:11:48 <Shin-LaC> however, now I'm thinking
12:12:42 <heatsink> If your parser is one_float <|> two_floats then you should left-factor it to one_float >>= (\f -> ((f,) <$> one_float) <|> return f)
12:13:11 <Shin-LaC> hm, no, I can't use a list
12:13:19 <Shin-LaC> because I might have different types
12:13:23 <Shin-LaC> so yeah, it has to be a tuple
12:15:53 <Shin-LaC> hm, honestly not sure if applicative notation is better than do notation
12:15:57 <Shin-LaC> it's certainly more compact
12:17:06 <vektor> tried hlint. cabal seems not to agree with me, but hlint seems to work
12:18:28 <jmcarthur> Shin-LaC: it's not really about the notation. it's that it's more general (works for more types).
12:18:36 <jmcarthur> Shin-LaC: the notation could be written in terms of monad, too
12:19:03 <jmcarthur> Shin-LaC: there are syntax sugars for applicative, too. idiom brackets, is one. it's not built into haskell though
12:19:03 <Shin-LaC> I see
12:19:17 <Shin-LaC> but for my parser, which style is better?
12:19:21 <heatsink> Eliminating temporary variables is good when the variables wouldn't have informative names
12:19:33 <jmcarthur> Shin-LaC: there's a preprocess called "she" that desugars idiom brackets. also, the idris languages supports them natively.
12:19:56 <jmcarthur> Shin-LaC: i prefer applicative combinators when i can help it. i do think it's easier to think about than monads.
12:20:08 <jmcarthur> Shin-LaC: but it's an acquired taste, as with most things haskell
12:20:18 <Shin-LaC> heatsink: true, but in this case the names would be informative
12:20:33 <ij> dcoutts, You mentioned earlier the version ranges. But couldn't those be managed as packags with different name suffixes inside of a regular pkg mans, with some simple wrapper script around it?
12:20:36 <Shin-LaC> in fact, I have to replace them with a comment saying what it returns
12:21:03 <jmcarthur> point free is something i handle on a case by case basis
12:21:10 <jmcarthur> if i'm going to need comments to explain it, it shouldn't be point free
12:21:18 <jmcarthur> with experience you will probably make more things point free
12:21:27 <jmcarthur> as you get better at understanding it
12:21:38 <jmcarthur> it becomes more natural
12:22:03 <jmcarthur> i think for a lot of code the point free version is much easier to understand, but i would understand somebody who is unfamiliar with it having trouble
12:33:36 <blochchain> is there a standard library function that returns a bool for divisibility?
12:35:14 <jmcarthur> blochchain: i'm not aware of one. i normally just use mod and (==)
12:35:19 <Hafydd> @hoogle a -> a -> Bool
12:35:20 <lambdabot> Prelude (<) :: Ord a => a -> a -> Bool
12:35:20 <lambdabot> Data.Ord (<) :: Ord a => a -> a -> Bool
12:35:20 <lambdabot> Prelude (<=) :: Ord a => a -> a -> Bool
12:35:20 <Sgeo> Are there widely-popular packages that use unsafePerformIO purely for performance reasons? (Unlike unamb, which uses it for a particular semantic effect)
12:36:00 <jmcarthur> Sgeo: normally if unsafePerformIO would be useful for performance then you could get away with just using ST, safely, instead
12:36:19 <jmcarthur> Sgeo: but i guess i can think of an example. h/o...
12:38:51 <jmcarthur> Sgeo: well, it no longer uses it apparently, but the speculation package used to use an unsafeIsEvaluated function to avoid doing some work if some other thunk has already been forced.
12:38:58 <Sgeo> Why can't I nest [| |]
12:39:10 <Sgeo> jmcarthur: hmm, I thought ByteString did it?
12:39:18 <jmcarthur> used unsafePerformIO?
12:39:26 <scott_> blochchain: There's even/odd, but in general I guess just use mod and (==)
12:39:34 <blochchain> yeah i did that
12:39:38 <jmcarthur> Sgeo: i don't think it would use it only for performance. maybe for some FFI sort of stuff
12:39:48 <blochchain> it seems like something of that nature would be in prelude
12:40:34 <blochchain> just an infix that returns a bool about even division
12:40:35 <Sgeo> FFI sort of stuff? Byte-level manipulation? Couldn't pure versions of everything be written without manipulations on that level?
12:40:38 <blochchain> not a big deal, tho
12:41:25 <jmcarthur> Sgeo: well, at some point you have to allocate and mutate arrays
12:41:44 <jmcarthur> Sgeo: bytestrings has a low-level enough implementation that it needs some unsafePerformIO for that
12:41:48 <jmcarthur> *bytestring
12:42:42 <klugez> One reason is they are designed to be able to pass to C, so they have to be known at byte-level.
12:42:48 <jmcarthur> blochchain: well, there are even and odd functions, for the case that you are checking with (`mod` 2)
12:42:55 <Sgeo> If you're allocating and mutating arrays for FFI reasons, why not make that an FFI package, and if you're representing the string as an array you're mutating, isn't that a performance-related decision?
12:43:25 <jmcarthur> Sgeo: it's also semantics
12:43:30 <jmcarthur> Sgeo: arrays are not linked lists
12:43:57 <jmcarthur> sometimes semantics and performance are not entirely orthogonal
12:44:08 <blochchain> https://github.com/plsql/Haskell-Snippets/blob/master/primes.hs     this works. does it look sound and efficient?
12:44:37 <sipa> well, IntMap is sort-of a pure array (from a semantic point of view)
12:45:13 <jmcarthur> but it's not.
12:45:22 <jmcarthur> [[IntMap a]] = Int -> Maybe a
12:45:44 <jmcarthur> static-length arrays:  [[Array i a]] = Fin i -> a
12:46:09 <sipa> yes, only sort-of
12:46:22 <copumpkin> Scala's Vector is a "pure array"
12:46:25 <copumpkin> we could implement that in Haskell
12:46:26 <FireFly> What is Fin?
12:46:45 <Sgeo> Probably a type for an integer less than i
12:46:55 <jmcarthur> FireFly: Fin i is a natural number less than i
12:47:06 <scott_> Fin stands for finite
12:47:12 <FireFly> Is that implementable in Haskell?
12:47:14 <FireFly> hrm
12:47:21 <copumpkin> in roundabout ways, yes
12:47:24 <jmcarthur> it is, although it's not necessary useful
12:48:11 <jmcarthur> data Fin (n :: Nat) where Z :: Fin (Succ Zero); S :: Fin a -> Fin (Succ a)
12:48:13 <Sgeo> I guess my concern is whether sometimes writing very performant code requires writing unidiomatic Haskell
12:48:22 <jmcarthur> *necessarily
12:48:44 <jmcarthur> i guess GADTs and DataKinds aren't exactly Haskell proper
12:48:47 <copumpkin> I think working with indices is generally a bad thing
12:48:52 <copumpkin> so avoid it wherever possible :)
12:49:09 <jmcarthur> Sgeo: it's very rare that you have to drop to such a low level
12:49:17 <jmcarthur> Sgeo: it's actually just nice that you can, if you have to
12:49:34 <triliyn> You can write it without data kinds, it's just that you can't disallow silly things like S String
12:49:41 <jmcarthur> right
12:50:03 <jmcarthur> you can do without GADTs, too
12:50:10 <jmcarthur> it just gets less straightforward
12:53:17 <scott_> blochchain: Your divides seems opposite to what I expect (2 `divides` 10 should be True)
12:53:49 <blochchain> ah i changed the name
12:54:01 <blochchain> and mistakenly inversed the meaning
12:54:10 <blochchain> scott_: thanks for that. any other observations?
12:54:21 <scott_> In sieve, you should use pattern matching instead of head/tail
12:56:06 <blochchain> ah good call i already covered pattern matching earlier in the paper, forgot about that
12:56:26 * hackagebot pandoc 1.12.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.12.2 (JohnMacFarlane)
13:03:55 <quchen> zett_zelett: Yes there is a story, but that would probably be OT here
13:04:57 <joejev> I am getting an issue with cabal sdist, it says it cannot find my module
13:05:21 <joejev> I have the hs-sourcec-dirs set to src, where it is
13:05:35 <dronte> Hi everyone! I need a bit of help. I have a program i need to run, but it is not compiling. The authors say it was testes with ghc 6.10. Cat that be possible? What is the easyest way of getting ghc-6.10 ?
13:05:53 <dronte> *tested
13:06:05 <joejev> dronte: why isn't it compiling? what is the error(s)?
13:08:43 <jrmithdobbs> so this may be an odd, but i think useful/common, example of it, but does haskell (ghc) have an answer to something like Hiera::Config.load_backends() for dynamically loading external haskell code/modules at runtime?
13:08:47 <jrmithdobbs> https://github.com/puppetlabs/hiera/blob/master/lib/hiera/config.rb
13:09:05 <dronte> I'll show you now, but it's cabal file says it needs base<=4
13:11:36 <dronte> yes, and that's the error
13:12:39 <jrmithdobbs> actually this looks like an interesting approach
13:12:41 <jrmithdobbs> http://hackage.haskell.org/package/plugins-1.5.4.0
13:13:26 <dronte> joejev: got the problem&
13:15:34 <joejev> dronte: what was it?
13:16:28 <dronte> cabal says I need base <= 4
13:17:01 <joejev> you will probably need to install another, older, version of ghc to build that then
13:17:13 <joejev> err, not ghc but base
13:17:15 <mauke> what if you edit the cabal file?
13:17:53 <geekosaur> joejev, you were correct the first time. base is tied to ghc
13:19:32 <joejev> speaking of cabal, anyone know why it cannot find my module when I run sdist?
13:19:52 <dronte> If I edit cabal i get a compilation error "    Could not deduce (Eq a) arising from a use of `=='"
13:20:11 <jrmithdobbs> wait, i thought haskell couldn't dynamically reload code like erlang? is it just that the bits to do the dirty work are there and there's no combining "platform" so to speak? because it looks like using ghc you can build and relink and reload so long as the code is designed to interact with the reloading bits correctly
13:21:16 <dronte> i tried to buid ghc-6.10 but there is a problem with old shared library...
13:23:03 <ReinH> jrmithdobbs: it's possible and some people are working on it
13:26:07 <jrmithdobbs> ReinH: ya, i just ran across plugins on hackage, that with rigorous design limitations is a good chunk of the way there (no idea how pratical it is to actually use, i'm just reading the haddocks and hscolour output it links atm ;p)
13:27:22 <ReinH> jrmithdobbs: we've talked about live code reloading a couple times on the haskell cast :)
13:27:39 <ahg_> How do I pronounce (>>) and (>>=)?
13:27:49 <joejev> sequence and bind
13:27:54 <ahg_> thanks!
13:28:02 <ReinH> definitely seems like some form of live code reloading will be practical soon
13:31:24 <dronte> matter of fact I can't even download a prior release off haskell platform
13:31:30 <shachaf> If you say "sequence" people will think you mean sequence.
13:34:23 <chrisdone> reinh: i've tested with simply having references that emacs is aware of. so you say e.g. $(updateable 'foo_) where foo_ is some IO action and then updateable makes a `foo' function and a `foo_ref' variable. when you go on a definition and hit C-M-x, emacs sends let foo_ = …; writeIORef foo_ref foo_. i did that a little bit with my irc server and a simple snap server. but that's just for development, not production "hot-swapping"
13:35:23 <joelteon> isn't there a package that provides a datatype that's like an Either/Maybe hybrid
13:35:29 <joelteon> it's A | B | AB
13:35:29 <chrisdone> These?
13:35:33 <joelteon> yes
13:35:37 <chrisdone> yes, these
13:35:42 <khyperia> how do I turn [a,b,c,d,e] into [(a, b), (b, c), (c, d), (d, e)]? (basically connect the 1st and 2nd, 2nd and 3rd, etc)
13:36:09 <chrisdone> > let xs = [a,b,c,d,e] in zip xs (tail xs)
13:36:10 <lambdabot>   [(a,b),(b,c),(c,d),(d,e)]
13:36:18 <nivox> I'm stuck with compile error I can't seem to solve on a simple piece of code. Anyone care to take a look? http://lpaste.net/96707
13:36:19 <khyperia> ah, just thought of that right before you said that, thanks!
13:39:12 <klrr_> nivox: put the error at the end of the file, the lines that ghc spits out is wrong now :P
13:39:14 <dronte> gys why anu link on http://www.haskell.org/platform/prior.html kiks me to the main page?
13:39:55 <nivox> klrr_, ohhh... you're right... I'll fix that right away
13:40:25 <dronte> nivox you are talking to me?
13:41:29 <joejev> why does my package candidate not have the documentation for the modules, like, te modules are not links to their docs?
13:41:35 <nivox> klrr_: ok now the error is at the end: http://lpaste.net/96707
13:42:19 <nivox> dronte: I'm talking to anyone who's listening :-)
13:43:36 <dronte_> <nivox>: sorry, still noot familiar with what happens here(
13:44:41 <Sgeo> runEffect $ ((liftIO $ putStrLn "Producer") >> yield 'a') >-> ((liftIO $ putStrLn "Consumer") >> await >> return ())
13:45:01 <Sgeo> Printing Consumer first makes sense... but I still don't understand the overall implications of pull-based vs push-based pipes
13:45:02 <prooftechnique> So I'm trying to wrap CreateProcess in a newtype so I can avoid an orphan instance. What's the right way to do that?
13:46:35 <prooftechnique> I'm just trying to derive Show at the moment, for simplicity's sake
13:47:58 <Philonous> prooftechnique, cunning newtype deriving needs the base type to have that instance already.
13:48:27 <prooftechnique> Hmm
13:50:25 <prooftechnique> Is there a general way to show records? I guess I could write an instance for my newtype and just try to get it to show the fields of the record
13:51:38 <prooftechnique> It's for an application, so I'm not *way* worried about the orphan instance, I just thought it'd be a good opportunity to learn about how to avoid them
13:51:44 <monochrom> if you can't "deriving Show", you will have to write code by hand
13:53:30 <Sgeo> Isn't there an extensionf for writing deriving Show etc. in a standalone way
13:53:31 <Sgeo> ?
13:53:46 <prooftechnique> There is, and that's what I'm using now
13:53:48 <monochrom> yes, but it also implies orphaned instance
13:53:55 <prooftechnique> I just wanted to avoid orphan instances
13:54:17 <monochrom> or rather, we're exploring options
13:54:32 <Philonous> Sgeo, -XStandaloneDeriving
13:54:55 <Philonous> Sgeo, You can say "deriving instance Show Foo"  but you still have the problem that the instance is orphan
13:55:12 <Sgeo> What's so terrible about orphan instances?
13:55:17 <codygman> I believe that map is expecting a monad, but not sure. Should I be using mapM?: http://lpaste.net/96712
13:55:33 <Philonous> Sgeo, You'll invariably end up with multiple conflicting ones.
13:55:36 <Sgeo> If two people write two libraries, and I want to get them to interoperate, what's wrong wth an orphan instance as glue?
13:55:45 <Sgeo> Hmm... separate module to contain it?
13:55:58 <Philonous> Instances are always exported/imported
13:56:15 <Sgeo> Oh... hmm, maybe things need to be reworked to allow for multiple instances
13:56:25 <Sgeo> Doesn't SML have something like that?
13:56:30 <Sgeo> Or.. one of the MLs?
13:57:12 <monochrom> there is no type class in the MLs. you will have to be very lax about "like that". therefore, I don't know what you mean.
13:57:35 <joejev> is there an issue with my cabal package? I uploaded it as a package candidate and there are no docs even though I ran the cabal haddock command first
13:57:36 <Philonous> Yes, but you end up with problems. For example if you change Ord instances your Maps will suddenly be inconsistent
13:57:59 <joejev> http://hackage.haskell.org/package/diophantine-0.1.0.0/candidate
13:58:40 <Hodapp> hrmmm... if I want to do something like: data Foo = [ Foo|Bar ] how do I go about accomplishing that?
13:58:59 <Useful_idiot> hey guys, which would be the proper place to place questions about category theory?
13:59:14 <monochrom> what do you want to convey in the notation "[ Foo|Bar ]"?
13:59:25 <Philonous> Hodapp, data Foo = Foo | Bar ?
13:59:42 <joejev> Hodapp: data Foo = [Foo] | [Bar] ?
13:59:53 <Hodapp> joejev: I don't want it to be uniformly one or the other.
14:00:07 <nlogax> [Either Foo Bar] ?
14:00:39 <monochrom> I guess you want me to guess.
14:00:59 <Hodapp> seems you already have ;)
14:01:10 <chrisdone> huh, haskell is officially a real language
14:01:14 <joejev> Hodapp: Lists are homogenous, so nlogax's answer is probably the best
14:01:25 <chrisdone> i'm getting illiterate emails from people asking for me to help with their homework
14:01:49 <monochrom> send them to me! I can charge them for a fee
14:02:08 <codygman> I figured my problem out btw.
14:02:32 <monochrom> wait, "I can charge them for a fee" sounds like double charging!
14:02:38 <Hodapp> monochrom: well, if I had something like... data Baz = Foo | Bar, then I could easily have [Baz] being a type, right?
14:02:50 <monochrom> yes
14:02:55 <Useful_idiot> Hodapp, data FooBar = Foo | Bar; type FooBarList = [FooBar]
14:03:44 <monochrom> but in "data Baz = Foo | Bar", Foo is a value, not a type; Bar is a value, not a type. do you know this?
14:05:03 <jrmithdobbs> ReinH: you know of anything actually using plugins or something similar with published example code?
14:05:19 <monochrom> it may be advisable to write like "data BazType = FooConstructor | BarConstructor" to remind everyone about this
14:05:36 <monochrom> because by the time you hit "data Foo = Foo | FooFoo" it may be lost
14:05:39 <Hodapp> hmmmm...
14:05:41 <chrisdone> monochrom: haha. “here's ten bucks, kid. don't tell your mother” “it'll cost you more than that”
14:06:43 <monochrom> hmm, a kid who can bargain like that is a kid who can protect himself/herself quite a bit
14:11:22 <Boreeas> What exactly does "Could not deduce (a ~ [a])" mean
14:12:00 <enthropy> > (\x -> x:x) undefined
14:12:02 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
14:12:15 <enthropy> Boreeas: it's the same as that error
14:12:22 <monochrom> it means you have a subexpression such that part of your code wants it to be type a, and part of your code wants it to be type [a]. you are unable to make up your mind.
14:12:44 <Boreeas> ah, alright, thanks
14:14:25 <Boreeas> chrisdone: yeah, it's being taught here in first semester cs lectures for the last couple of years
14:14:38 <jmcarthur> :t (a ~ [a]) => a
14:14:39 <lambdabot> parse error on input `=>'
14:14:45 <jmcarthur> haha oops
14:14:48 <jmcarthur> :t undefined :: (a ~ [a]) => a
14:14:49 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0]
14:14:49 <lambdabot>     In the expression: undefined :: a ~ [a] => a
14:14:49 <lambdabot>     Couldn't match type `a' with `[a]'
14:15:08 <Mokosha> hi everyone =), can anyone explain to me why this program hangs: https://gist.github.com/Mokosha/34eda7bd2d6b5cafd5a3
14:16:43 <jmcarthur> Mokosha: i don't know, but if you mean it's not responding to keyboard input, it's because you never set of a handler for it.
14:17:10 <jmcarthur> *set up
14:17:27 <Mokosha> the version with the handler also "hangs"
14:18:01 <Mokosha> in the sense that it becomes unresponsive (i.e. I cannot interact with the window) but the main update loop still runs (i.e. colors on the screen change)
14:20:43 <Mokosha> is there any initial setup I need to do with an STM variable after I create it but before I try to read from it?
14:22:57 <joelteon> Is there a canonical AWS library or should I use hS3?
14:25:57 <scott_> It seems like [a] -> [a] -> Bool (with no constraints) is always a needlessly restricted form of [a] -> [b] -> Bool... is this true?
14:26:23 <jmcarthur> Mokosha: perhaps you need to run pollEvents or something. not sure what the default is in regards to swapBuffers
14:27:25 <codygman> How do you make a lazy bytestring? Or should I just make a normal bytestring and use it with the lazy bytestring library? You can't do that right? Also, how can I make a word8 from a string? That's probably not something I should be doing either right?
14:27:39 <jmcarthur> scott_: the question is "can every function of type [a]->[a]->Bool be generalized to [a]->[b]->Bool"?
14:27:44 <scott_> jmcarthur: Yes
14:27:54 <jmcarthur> i suspect you may be right, but am not certain
14:28:09 <jmcarthur> i think you are right
14:28:32 <enthropy> for convenience you might do something like:     f xs ys = null (drop 10 (xs ++ ys))
14:28:47 <Mokosha> jmcarthur: huh, running poll events gets rid of the hang... I'll look into it, thanks!
14:28:55 <jmcarthur> enthropy: yeah, but you can also write that differently with the same result
14:28:58 <enthropy> which would need an unsafeCoerce or so to generalize to the [a] -> [b] -> ...
14:29:00 <scott_> I guess the intuition is forall a. [a] can only know the shape of the list, so [a] -> [a] -> Bool can only use the shapes of the two lists, so they don't need the same type
14:29:02 <enthropy> yes
14:29:43 <_shad_> Hi, I have problem with programs design.
14:29:47 <_shad_> here is function alignMatrix :: [Maybe Int] -> [[String]] -> [[String]] that calculates(or extract from 1st argument) max length for every column and add spaces to fields if necessery for pretty printing.
14:29:53 <_shad_> Unfortunately, one use case of alignMatrix is similar to
14:29:59 <_shad_> f = { pageStatusList <- mapM $ map (analyzePage . downloadPage) urlList ;
14:30:03 <_shad_> matrix = map (\x,y) -> [x, y]) $ zip pageStatusList urlList ;
14:30:08 <_shad_> mapM_  pustStrLn $ concat $ alignMatrix (Just 9 : Nothing) matrix }
14:30:09 <scott_> Right... (++) forces the same type there but you are still only using the shape of the list, so unsafeCoerce would be valid (but obviously not a good way to write the function)
14:30:17 <_shad_> f print first string only when ALL pages are downloaded and analyzed.
14:30:22 <jmcarthur> _shad_: too much code. please use lpaste.net
14:30:24 <_shad_> Problem is alignMatrix can't deal with IO String and call mapM force program to wait.
14:30:28 <_shad_> ok
14:40:06 <joejev> how does hackage get the docs for the modules? does it generate them based on the haddock comments automagically or do I need to somehow add them myself?
14:40:39 <enthropy> joejev: they get built from your upload (provided it can be compiled on the server)
14:40:55 <codygman> How do you get the first element of a [Bytestring] (Lazy that is)?
14:41:09 <joejev> enthropy: how long does that take, and is there a way to see if it did not work?
14:41:28 <HectorAE> codygman, head
14:41:38 <HectorAE> No?
14:42:18 <enthropy> the old hackage used to be 8 hours or so... I think the new one generates them in a much shorter time
14:43:13 <joejev> enthropy: does it do this for candidates? I wanted to make sure all of the documentation was in order on the site before I made it live
14:43:33 <_shad_> I have problem with programs design http://lpaste.net/96715 . Can anybody help?
14:43:35 <enthropy> these are packages you upload via the web-interface?
14:43:49 <joejev> yes
14:44:58 <jmcarthur> a rather interesting function. i wonder how much work it would be to write without pipes? even with pipes it was a big awkward.
14:45:00 <jmcarthur> runIdentity . runEffect . liftA2 (>->) (forever . traverse yield . reverse . toList) (traverse $ const await)
14:45:15 <jmcarthur> :: Traversable t => t a -> t a
14:45:22 <jmcarthur> reverse all the elements
14:46:14 <jmcarthur> rev (Map.fromList [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g')]) == Map.fromList [(1,'g'),(2,'f'),(3,'e'),(4,'d'),(5,'c'),(6,'b'),(7,'a')]
14:47:06 <jmcarthur> the main awkwardness from pipes is that use of forever. needed it to make the type more general :\
14:47:21 <jmcarthur> maybe there is a better way to do that
14:51:50 <henk> I’m trying to use strptime from Data.Time.Parse to parse the output of "date" and it returns 'Nothing': http://lpaste.net/96718 Why? (I just tried importing System.Locale but that did not help)
14:53:04 <jmcarthur> wow, what a terrible type that function has
14:53:11 <jmcarthur> no information about what went wrong
14:53:44 <Philonous> Why does cabal ignore the package-db setting in the cabal.sandbox.config? Is that a bug or intentional?
14:54:35 <Philonous> Surprisingly, cabal sandbox hc-pkg does actually use it.
14:54:50 <Eduard_Munteanu> Is there some TH that can convert typeclasses to GADTs?
14:58:19 <lightquake> what does cabal sandbox hc-pkg do?
14:59:39 <Philonous> It runs ghc-pkg in the current sandbox
15:00:03 <lightquake> why isn't it called cabal sandbox ghc-pkg then?
15:00:18 <Philonous> Presumably because cabal is compiler-agnostic
15:00:50 <lightquake> oh right
15:03:28 <slack1256> What is the name of the extension that lets me do (read "5" :: Int) in code?
15:03:46 <Eduard_Munteanu> slack1256: that's not an extension
15:03:56 <larsrh> So, today I found out about `default`. The Haskell report says that it only applies to `Num`, but I could also use it to affect compilation for stuff like `quickCheck $ const True`.
15:04:03 <larsrh> Am I reading the report wrong?
15:04:32 <geekosaur> where did you test it? ghci has extended defaults
15:04:46 <larsrh> geekosaur: GHCi indeed
15:05:30 <larsrh> geekosaur: is this documented somewhere?
15:05:44 * geekosaur is looking for it
15:06:02 <scott_> If you type :set in GHCi it says what's enabled
15:06:10 <larsrh> Found it. It's in the user guide.
15:06:16 <geekosaur> the extension is ExtendedDefaultRules
15:06:28 <larsrh> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/interactive-evaluation.html
15:07:15 <geekosaur> interestingly it is *not* documented with the other extensions
15:07:27 <geekosaur> (which is where I was looking)
15:07:32 <danilo2> Hello :) I'm trying to find the most elegant way to write a function - I can write it "normal" way, but I would love to hear any suggestions and see some fancy ways of solving :)
15:07:33 <danilo2> I've got list of lists of Ints and I want to partition it based on some number of front ints, like partition 2 [[1,2,3],[1,2,5],[1,3,8]] should return {[1,2] -> [[1,2,3],[1,2,5]] , [1,3] -> [1,3,8]}, Where "->" is a Data.Map association
15:13:52 <lightquake> danilo2: how would you write it?
15:14:09 <danilo2> lightquake: brb, I'll paste it here in a moment
15:16:43 <codygman> I just got a rather confusing arrow type error, at least I can't seem to make sense of it: http://lpaste.net/96719
15:19:55 <danilo2> lightquake: http://lpaste.net/96720
15:20:59 <lightquake> > M.empty
15:21:00 <lambdabot>   fromList []
15:21:50 <lightquake> danilo2: so, one thing you could do is use M.insertWith, which uses a combining function
15:22:08 <lightquake> > foldr (\xs -> M.insertWith (++) (take 2 xs) [xs]) [[1,2,3],[1,2,5],[1,3,8]]
15:22:09 <lambdabot>   Couldn't match expected type `Data.Map.Base.Map [a0] [[a0]]'
15:22:09 <lambdabot>              w...
15:22:16 <lightquake> oh right
15:22:23 <lightquake> > foldr (\xs -> M.insertWith (++) (take 2 xs) [xs]) M.empty [[1,2,3],[1,2,5],[1,3,8]]
15:22:25 <lambdabot>   fromList [([1,2],[[1,2,3],[1,2,5]]),([1,3],[[1,3,8]])]
15:22:41 <lightquake> the other thing you could do is M.fromListWith:
15:22:42 <klrr_> ocharles: http://ocharles.org.uk/blog/posts/2013-12-07-24-days-of-hackage-threepenny-gui.html s/feedbcak/feedback in "threepenny-gui is thus a collection of common UI elements, a way of composing them into web pages, and the ability to watch these interface elements for interactions. threepenny-gui also uses web sockets to provide a tight feedbcak loop between the client and the server.", thanks for the great series!
15:23:07 <lightquake> > M.fromListWith (++) . map (\x -> (take 2 x, [x])) $ [[1,2,3],[1,2,5],[1,3,8]]
15:23:08 <lambdabot>   fromList [([1,2],[[1,2,5],[1,2,3]]),([1,3],[[1,3,8]])]
15:23:21 <arkeet> that's probably the best thing to do.
15:23:30 <arkeet> foldr is also not appropriate ;)
15:23:45 <arkeet> (use foldl')
15:24:25 <arkeet> > groupBy ((==) `on` take 2) . sort $ [[1,2,3],[1,2,5],[1,3,8]]
15:24:26 <lambdabot>   [[[1,2,3],[1,2,5]],[[1,3,8]]]
15:24:27 <danilo2> lightquake: Oh, nice! insertWith inserts even if the key was not there - thank you
15:25:05 <arkeet> > groupBy ((==) `on` take 2) . sort $ words "abc abcd acef afg abdg af"
15:25:06 <lambdabot>   [["abc","abcd","abdg"],["acef"],["af","afg"]]
15:25:23 <danilo2> arkeet: your are right with the foldr - I'll be more carefull with that :)
15:26:00 <arkeet> you don't need a Map to do this. ;)
15:26:21 <danilo2> arkeet: I know, but I want my output to be a map :)
15:26:25 <arkeet> ok ;)
15:26:55 <arkeet> ocharles: I also spot "ealrier"
15:29:38 <Philonous> Is :trace supposed to eat up all my RAM?
15:31:02 <lightquake> codygman: so, your basic problem is that getTitle doesn't have the type that you think it does
15:31:42 <lightquake> give me a second so i can actually build your thing and get the right type
15:34:39 <lightquake> specifically, it has type L.ByteString -> IOSArrow XmlTree String
15:58:29 <gaze__> Hey so if I'm looking for what "~" means, what should I be googling for?
15:59:02 <scott_> gaze__: Equality constraints
16:01:22 <k0001> Is there a commonly used type for a “non empty Text” on Hackage or should I define my own if I want that?
16:03:48 <gaze__> http://lpaste.net/96722 , line 18 is giving me trouble
16:04:10 <gaze__> could not deduce (R i ~ R j). Any idea what the right thing to do here is?
16:06:49 * hackagebot http-types 0.8.3 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.8.3 (AristidBreitkreuz)
16:07:12 <Saizan> gaze__: try removng the type annotation from iflo
16:08:26 <gaze__> Saizan: Oooh. Okay so how would I actually write the type for it?
16:10:13 <Saizan> gaze__: see annotation
16:10:31 <Saizan> note line 11 too
16:13:24 <gaze__> what's that do?
16:14:49 <Saizan>  it brings the 'i' in scope for the type signature on iflo
16:27:48 <Eduard_Munteanu> Weird...
16:28:15 <Eduard_Munteanu> If I enable GADTs some instance declaration fails to typecheck.
16:28:20 <HugoDaniel> http://www.dcs.gla.ac.uk/~muffy/SPJ_oration.pdf
16:28:47 <aristid> Eduard_Munteanu: and i thought you were just expressing general bewilderment about the ways the world work
16:28:49 <Eduard_Munteanu> It says a type variable is ambiguous and can't deduce a class constraint.
16:29:07 <Eduard_Munteanu> aristid: GHC must mean the world to me :P
16:29:18 <aristid> Eduard_Munteanu: and it should
16:32:50 <Hodapp> huh... interesting the sorts of recursion that Haskell just makes very natural
16:34:46 <Hodapp> up till about undergrad: "Recursion is super-cool! Recursion is, like, a way to compute factorial! Recursion is a thing that only occurs when functions call themselves. That's about it."
16:36:34 * mangaba_leitosa does not tend to use recursion in haskell :-)
16:36:53 <Hafydd> Nice!
16:36:53 * hackagebot gravatar 0.5.3 - Look up gravatar image urls by email address  http://hackage.haskell.org/package/gravatar-0.5.3 (PatrickBrisbin)
16:36:56 * hackagebot bencoding 0.4.1.0 - A library for encoding and decoding of BEncode data.  http://hackage.haskell.org/package/bencoding-0.4.1.0 (SamTruzjan)
16:36:57 <mangaba_leitosa> it's more like fold, map etc
16:37:06 <Hafydd> Regarding the SPJ letter, I mean.
16:38:06 <Hodapp> well, it's a bit different when you get into Lisp and Haskell where a number of very basic things are just defined recursively
16:38:07 <simon> Hodapp, at my department, the very first BSc course you get is a functional programming one.
16:38:14 <Hodapp> simon: I approve of this.
16:43:26 <Saizan> Eduard_Munteanu: GADTs imply MonoLetBinds or however it's called
16:43:50 <Eduard_Munteanu> Saizan: oh, interesting.
16:43:55 <Saizan> Eduard_Munteanu: i.e. it prevents some generalizations
16:44:00 <Eduard_Munteanu> Saizan: any reason why though?
16:44:18 <Saizan> makes constraint solving easier
16:44:43 <Saizan> it's in the OutsideIn paper
16:45:55 <Eduard_Munteanu> Thanks, I guess I'll just add signatures and shuffle things around.
16:46:29 <Eduard_Munteanu> Whoa... I just discovered http://hackage.haskell.org/package/generic-deriving
16:54:34 <Eduard_Munteanu> Argh, I can't derive Generic1 for some function types.
16:54:57 <cariveri_> hey. how call widgetVisible :: WidgetClass self => Attr self Bool ?
16:55:33 <Eduard_Munteanu> cariveri_: you should provide a link to the docs... I suspect this is a gtk2hs function, but you should mention it.
16:56:51 <cariveri> Eduard_Munteanu: yes sure https://hackage.haskell.org/package/gtk-0.12.4/docs/Graphics-UI-Gtk-Abstract-Widget.html
16:57:11 <shiona> sorry for possible quit/join spam, our network is having issues
16:58:39 <Eduard_Munteanu> cariveri: it's a "function" with no arguments.
16:59:15 <augur> so what is this i've read about scala having an everything-is-a-type model?
16:59:29 <Eduard_Munteanu> cariveri: Attr is a ReadWriteAttr which you can use 'get' on.
16:59:50 <Eduard_Munteanu> cariveri: get :: o -> ReadWriteAttr o a b -> IO a
17:00:08 <augur> you can do it with typelevel nats, FireFly
17:00:16 <augur> ack what
17:00:18 <augur> hahaha
17:00:20 <augur> oh wow
17:00:22 <Eduard_Munteanu> cariveri: so I think it would go like    get someObject widgetVisible
17:00:28 <cariveri> Eduard_Munteanu: yes I tried that "get widgetVisible", but how does it know where to get from?
17:00:35 <augur> i was scrolled to the top of my scrollback
17:00:42 <cariveri> Eduard_Munteanu: exactely that did not work.
17:00:47 <Eduard_Munteanu> cariveri: get takes the object as the first parameter
17:00:52 <augur> so whenever someone said something, it ticked up one, and looked like people were talking
17:00:58 <augur> but in a convo from ages ago
17:00:59 <augur> hahaha :D
17:01:00 <cariveri> oh wait...
17:01:45 <ion> augur: Time travel
17:01:52 <augur> ion: :)
17:01:54 <Eduard_Munteanu> cariveri: looks like widgetVisible is just a value representing that visibility property, get does the actual IO
17:02:19 <mekeor> hm. do i really want to write "type Number = (Read t, RealFloat t) => Complex t"? i had to {-# LANGUAGE Rank2Types, ImpredicativeTypes  #-} for this purpose... :/  – i just don't want to have to write "(Read t, RealFloat t) => Complex t" everywhere...
17:03:28 <Eduard_Munteanu> mekeor: that works only if you mean  (forall t. (Read t, RealFloat t) => Complex t) -> (forall t. (Read t, RealFloat t) => Complex t) -> ...   instead of Number -> Number -> ...
17:03:48 <Eduard_Munteanu> mekeor: most likely you want a constraint synonym instead
17:03:49 <cariveri> Eduard_Munteanu: it worked. Ive just overseen a conflict of two get function. so get object attribute was good.
17:04:30 <mekeor> Eduard_Munteanu: oh, uhm, ah, er. okay... so? what does that mean?
17:04:33 <Eduard_Munteanu> mekeor: type IsComplex t = (Read t, RealFloat t)  might shorten things a bit
17:04:44 <mekeor> wow
17:05:01 <Eduard_Munteanu> mekeor: it means those Numbers contain unrelated types
17:05:35 <mekeor> hm, i see
17:05:45 <mekeor> thank you :)
17:07:01 <Eduard_Munteanu> mekeor: mind numeric operations will most likely instantiate those types and force them to be equal, because e.g. (+) :: Num a => a -> a -> a
17:07:50 <Eduard_Munteanu> mekeor: tldr, unless you know you want that thing, don't use the rank 2 variant.
17:08:11 <mekeor> okay, yeah, i see, thanks :)
17:09:10 <mekeor> hmm.
17:09:36 <mekeor> i have also "type VariList = [([String],Number)]" ...
17:09:48 <Eduard_Munteanu> mekeor: that's fine
17:10:04 <Eduard_Munteanu> mekeor: er, no, the Number there isn't fine
17:10:07 <mekeor> yeah.
17:10:46 <Eduard_Munteanu> You probably had to turn on ImpredicativeTypes too.
17:11:01 <mekeor> yep
17:11:16 <mekeor> Eduard_Munteanu: i mentioned that ;)
17:11:33 <Eduard_Munteanu> Ah, missed it.
17:12:09 <mekeor> this is ugly/messy/frustrating
17:14:34 <mekeor> originally, i had "type Number = Complex CReal". but i want "Number" to mean more generally "(Read t, RealFloat t) => Complex t" such all those functions of type "Number -> ..." also work for Double and Float etc..
17:14:56 <mekeor> Eduard_Munteanu: it seems i have to change the type signature of all those functions, right?
17:15:26 <Eduard_Munteanu> mekeor: might be nicer to (ab)use typeclasses for this: class IsComplex a where f :: a -> a -> ...   instance (Read a, RealFloat a) => Complex a where f = ...
17:15:32 <Eduard_Munteanu> mekeor: yeah
17:16:21 <Eduard_Munteanu> Er, IsComplex (Complex a) in the instance
17:16:23 <mekeor> Eduard_Munteanu: did you mean IsComplex instead of Complex there?
17:16:24 <mekeor> yeah
17:16:26 <mekeor> :)
17:16:33 <mekeor> er... whut.
17:16:58 * mekeor is confused
17:19:25 <cariveri> Eduard_Munteanu: can I Import hidden package Graphics.UI.Gtk.Signals? I wanted to circumvent the inaccessability of a buttonEnter Signal by adapting "buttonActivated = Signal (connect_NONE__NONE "clicked")" https://hackage.haskell.org/package/gtk-0.12.0/docs/src/Graphics-UI-Gtk-Buttons-Button.html#buttonActivated
17:21:59 * hackagebot hspec-meta 1.8.0 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.8.0 (SimonHengel)
17:22:01 * hackagebot hspec-expectations 0.4.0 - Catchy combinators for HUnit  http://hackage.haskell.org/package/hspec-expectations-0.4.0 (SimonHengel)
17:23:01 <Eduard_Munteanu> cariveri: hm, dunno
17:24:24 <jle`> that's what haskell package for rendering figures?
17:24:28 <flebron> Hi! Is there a name for \f x -> mconcat (map f x)? (Other than (mconcat .) . map, of course :))
17:25:06 <Eduard_Munteanu> @type \f x -> join (fmap f x)
17:25:07 <lambdabot> (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
17:25:10 <jle`> sort of like a generic concatMap?
17:25:19 <Eduard_Munteanu> @type (>>=)
17:25:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:25:35 <Eduard_Munteanu> @type flip (>>=)
17:25:36 <lambdabot> Monad m => (a -> m b) -> m a -> m b
17:26:01 <Eduard_Munteanu> flebron: it's (>>=), morally.
17:26:04 <flebron> jle`: Indeed :)
17:26:24 <flebron> Only the m changes :)
17:26:54 <Eduard_Munteanu> Arguably Monads should be Functors implicitly.
17:27:25 <khyperia> I *really* want "class (Applicative m) => Monad m"
17:27:26 <flebron> Well, mconcat also needs Monoid.
17:27:36 <khyperia> flebron, it uses the [] monad
17:27:52 <khyperia> if you're using arrays, of course
17:27:59 <khyperia> lists, what am I saying
17:28:10 <Eduard_Munteanu> :t \f x -> mconcat (map f x)
17:28:11 <lambdabot> Monoid a => (a1 -> a) -> [a1] -> a
17:28:20 <pavonia> cariveri: There probably is such a signal in one of the superclasses of button
17:28:43 <dainanaki> I'm playing around with the pipes library right now. Is there a good way to trigger early termination of a Producer from outside of the Pipe?
17:28:45 <flebron> You need monoid there to concat the results of f.
17:29:01 <gaze__> hey guys, how do you represent a DAG with a zipper? A tree makes total sense to me at least, but I don't know how do you do an update if multiple items refer to you?
17:29:34 <Eduard_Munteanu> khyperia: monads generally aren't applicatives though... I mean outside Haskell.
17:29:50 <khyperia> ah
17:29:53 <khyperia> didn't know that
17:30:16 <jle`> Eduard_Munteanu: i mean...don't you get <*> and pure for free, if you have a monad?
17:30:28 <khyperia> flebron, join is usually the same as mconcat, for things that have both Monoid and Monad instances (I think).
17:31:40 <Peaker> @type [join, mconcat]
17:31:41 <lambdabot> [[[a]] -> [a]]
17:31:42 <jle`> kylcarte: how do you figure? or do you mean a generic mconcat
17:31:44 <Eduard_Munteanu> jle`: in Hask yes, but generally they're unrelated
17:32:08 <Peaker> khyperia: only list has join/mconcat of same type
17:32:11 <jle`> Eduard_Munteanu: are you saying that they are theoretically/conceptually unrelated, but one could coerce a monad to act like an applicative?
17:32:13 <khyperia> ah
17:32:51 <Eduard_Munteanu> jle`: conceptually unrelated, though I'm not sure you can even coerce them generally.
17:33:15 <khyperia> since mconcat :: [] a -> a (or [] (m a) -> (m a) if you want to specialize), and join :: m (m a) -> (m a), right?
17:33:31 <Eduard_Munteanu> jle`: in categories which aren't CCCs for instance
17:34:01 <jle`> khyperia: (Monoid a) => Maybe a is a monoid, but its join is pretty different than mconcat
17:34:10 <jle`> er
17:34:14 <jle`> from list's join
17:34:18 <khyperia> wait, how is it a monoid?
17:34:21 <jle`> actually i don't know what im saying anymore
17:34:40 <jle`> kylcarte: adding Nothing leaves the value unchanged, adding a Just adds the values inside the Just
17:35:16 <jle`> > mconcat [Nothing, Just "c", Just "b", Nothing, Just "c"]
17:35:18 <lambdabot>   Just "cbc"
17:35:31 <khyperia> there's an instance "instance Monoid a => Monoid (Maybe a)", is that what you're talking about?
17:35:51 <jle`> i mean that Maybe a is a monoid if a is a monoid?
17:36:11 <jle`> Maybe a is also a monoid even if a isn't
17:36:17 <jle`> in its MonadPlus instance
17:36:23 <joejev> when should someone use the State monad, lets say I have a record data MyState, should I put that in a state monad, or can I just write function of type MyState -> MyState
17:36:39 <Cale> joejev: You can absolutely just write functions
17:36:46 <khyperia> yeah, there's a "instance MonadPlus Maybe", didn't see that
17:37:02 <Cale> joejev: A value of type State s a is internally just a function s -> (s,a) anyway
17:37:23 <jle`> joejev: state monad is no more powerful than normal functions...they are the same thing.  it just does the boilerplate in chaining that you would normally do yourself
17:37:49 <joejev> jle`: what do you mean by boilerplate chaining in this context?
17:37:54 <jle`> if you had a function (a, state) -> (b, state), and you wanted to apply it twice to a, you'd have to manually pattern match things out
17:37:55 <arkeet> > Just 1 `mplus` Just 2
17:37:56 <lambdabot>   Just 1
17:37:56 <Cale> joejev: If you find yourself writing something in the style where you're passing along an extra parameter, and tupling your result with some intermediate state for the sake of recursion, then using the State monad will probably clean things up
17:38:11 <Cale> (because it's just a wrapper around that functional programming idiom)
17:38:12 <arkeet> jle`: the First monoid is the corresponding monoid to Maybe's MonadPlus instance
17:38:24 <Eduard_Munteanu> joejev: with normal functions you have to take care of feeding the state value throughout calls
17:38:27 <Cale> For example, consider the problem of taking a tree of type:
17:38:28 <arkeet> > First 1 <> First 2
17:38:29 <lambdabot>   No instance for (GHC.Show.Show a0)
17:38:29 <lambdabot>    arising from a use of `M8212865417997...
17:38:35 <arkeet> wuh
17:38:39 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
17:38:40 <arkeet> oh.
17:38:46 <arkeet> > First (Just 1) <> First (Just 2)
17:38:47 <lambdabot>   First {getFirst = Just 1}
17:38:48 <joejev> ahh, so the state monad is more for when you have a value that depends on the state being something?
17:39:18 <Cale> and writing a function Tree a -> Tree Integer which relabels the tree from left to right with integers from 0 up to n-1 where there are n Branch nodes in the tree
17:39:20 <jle`> joejev: yeah, it's for doing operations on a value that depend on a changing state
17:39:22 <Eduard_Munteanu> joejev: no, it's just like normal functions except more convenient because it passed the state around automatically.
17:39:29 <Eduard_Munteanu> *passes
17:39:52 <Eduard_Munteanu> :t state
17:39:53 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
17:39:54 <jle`> i guess you could do state monad with () as the value all the time
17:39:57 <Cale> If you write this recursively, you'll have a little problem deciding what to label the root
17:40:08 <jle`> but at that point you might as well just do the manual threading
17:40:13 <Cale> (it should be one more than the last label used when labelling the left subtree)
17:40:30 <Cale> So, the traditional way to do this would be to write a helper like:
17:40:56 <joejev> so if all the data I care about is contained in the MyState record, then the State monad is not needed?
17:40:56 <jle`> anyone know of a good flow chart/diagrams package for haskell?
17:40:57 <Cale> relabel' :: Tree a -> Integer -> (Integer, Tree Integer)
17:41:15 <Cale> jle`: Well, there's diagrams, though it's not specifically for flow charts
17:41:23 <jle`> joejev: if you are just updating a state repeatedly with no inputs then yeah, there really isn't any necessity
17:41:39 <jle`> the only purpose of the state monad is to make chaining functions more seamless/less headachey
17:41:42 <Cale> and this relabel' would look like:
17:41:59 <Cale> relabel' n Tip = (n,Tip)
17:42:21 <joejev> jle`: Thanks, I was doing a game simulation to test strategies, and I just wanted to be sure I wansn't missing out on some elegant solution, but it sounds like my implementation is fine
17:43:17 <jle`> joejev: consider pushing to a list, you have push 1 -> ((), [1]).  It's not trivial to do, say, push twice.  you'd have to pattern match out the list, pattern match out the original value, and then reapply.  state monad just takes care of that for you by letting you do something like push 1 >> push 2, to push twice.
17:43:24 <Cale> relabel' n (Branch x l r) = let (n',l') = relabel' n l; newLabel = n'; (n'',r') = relabel' (n'+1) r in (n'', Branch newLabel l' r')
17:43:31 <Cale> ^^ but that is easy to screw up
17:43:50 <Cale> So, that's what the State monad is for, when you have code which looks just like that
17:45:16 <Cale> Well, to complete that example, you'd then have  relabel t = snd (relabel' t 0)
17:45:29 <Cale> relabel :: Tree a -> Tree Integer
17:45:31 <joejev> so in that example, is the state wrapping the list or the ()?
17:46:25 <Cale> If I rewrote this using the State Integer monad, I'd first define:
17:46:28 <jle`> joejev: the state is the list and the () is the result value..but you could have a function like pop that returns a value (not a ()) depending on the state
17:46:40 <Cale> label = do x <- get; put (x+1); return x
17:46:49 <Cale> relabel' Tip = return Tip
17:47:02 * hackagebot control-bool 0.2.1 - Useful combinators for boolean expressions  http://hackage.haskell.org/package/control-bool-0.2.1 (FumiakiKinoshita)
17:47:25 <Cale> relabel' (Branch x l r) = do l' <- relabel l; x' <- label; r' <- relabel r; return (Branch x' l' r')
17:47:32 <Cale> ^^ much harder to get wrong than before
17:47:34 <Cale> and then
17:47:42 <byorgey> jle`: it shouldn't be too hard to create some abstractions for building flow charts on top of diagrams.  diagrams can already provide you with layout, shapes for nodes, text, and nice arrows between nodes.
17:47:47 <Cale> relabel t = evalState (relabel' t) 0
17:48:53 <joejev> well, I guess what I have really doesn't fit that pattern, thanks guts
17:48:56 <joejev> guys*
17:49:04 <jle`> push n = \s -> ( (),  s ++ [n] ), pop = \(x:xs) -> ( x, xs )   --- push and pop are functions that return state-dependent operations.
17:49:05 <ij> I've got some data, how do I make a CArray out of that data?
17:49:09 <Cale> Yeah, it's a bit rare to actually need it
17:49:14 <jle`> and return a (value, state) tuple
17:50:02 <Cale> ij: Which type is CArray?
17:50:19 <jle`> if you wanted to push and pop, you'd have to push n, then pattern match the state, then apply pop to it. with state monad, you just push 2 >> push 3 >> pop, to get (3, [2]).
17:50:39 <jle`> (push should have been push n = \s -> ( (), n:s ))
17:50:44 <ij> Cale, http://hackage.haskell.org/package/carray-0.1.5.2/docs/Data-Array-CArray.html
17:50:51 <joejev> I wonder where that would appear?
17:51:16 <jle`> joejev: it appears often in games, where say, you want to chain state-changing operations
17:51:26 <Cale> ij: Ah, you use the IArray class operations
17:51:35 <jle`> like you have a MoveDown operation that affects a GameState
17:51:40 <Cale> http://hackage.haskell.org/package/array-0.4.0.0/docs/Data-Array-IArray.html
17:51:47 <Cale> see 'array' and 'listArray' here
17:52:10 <jle`> but state is relaly only meaningful if you want to return return values AND the updated state.
17:52:14 <jle`> *state monad
17:52:36 <jle`> if you just return the updated state only, then there is no need to pattern match anything out...the composition of functions is trivial
17:54:10 <jle`> it's useful for random number generation, where you want to get the number that is generated, as well as the updated generator/seed
17:54:51 <ij> hmm, Cale: So I make an `array' and simply feed it to the function that needs a CArray?
17:57:03 * hackagebot treeviz 0.0.2 - Visualization of computation decomposition trees.  http://hackage.haskell.org/package/treeviz-0.0.2 (DavidBanas)
17:58:30 <Cale> ij: Yeah, you'll do something like  array (l,u) [(i,f i) | i <- [l..u]] :: CArray IndexType ElementType
17:58:55 <Cale> where f is a function for getting the ith element
17:59:09 <Cale> and l and u are your lower and upper bounds
17:59:24 <Cale> Or you can use listArray, if you have a list of the appropriate length
17:59:29 <ij> With the :: I hint the type checker what I want to get out of that fun?
17:59:38 <Cale> yeah
17:59:44 <Cale> That may or may not be necessary
18:00:01 <ij> I see, I'll try it then.
18:00:06 <Cale> If you apply a function to the result of this which needs a CArray explicitly, then it'll figure out which type of array to build
18:00:24 <ij> I'll try to arrange that. :)
18:26:06 <imalsogreg> Any snap/heist users around?
18:26:20 <shachaf> @where snap
18:26:21 <lambdabot> http://snapframework.com/ #snapframework
18:26:28 <imalsogreg> Thanks.
18:32:34 <a|i> which area of industry has haskell found its place?
18:32:51 <shachaf> @google haskell in industry
18:32:51 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
18:32:52 <lambdabot> Title: Haskell in industry - HaskellWiki
18:34:13 <a|i> web startups? I don't see a haskell web framework with a high traction.
18:34:44 <chrisdone> happstack, snap and yesod are the big three popular ones
18:35:11 <geekosaur> a|i, it's more complex than that. facebook uses haskell to generate php, I believe
18:35:13 <a|i> compare it to other frameworks, not other haskell packages.
18:35:47 <a|i> geekosaur: doesn't facebook compile php to c++?
18:38:13 <carter> not anymore
18:38:17 <carter> hiphop is now a vm
18:38:43 <carter> geekosaur: i'm pretty sure they're not using haskell there
18:39:20 <a|i> why would they use php generator? it's slow. people use static language generator, not dynamic.
18:39:44 <carter> ask them
18:40:16 <carter> because they used enough php that its worth investing in making it fast
18:40:37 <a|i> what about financial applications? is haskell at least dominant there?
18:40:54 <chrisdone> they're using haskell but for some things e.g. https://github.com/facebook/lex-pass
18:41:38 <chrisdone> and their service quality system is/being changed to a haskell dsl
18:44:29 <ij> Why does complex number constructor in hackage is written as "!a :+ !a" — with bangs, not without?
18:44:56 <carter> strictness is kinda nice
18:44:58 <carter> for this
18:45:06 <Eduard_Munteanu> ij: because other number types are strict too
18:46:22 <chrisdone> ij: probably the question can be more often phrased “why without bangs?"
18:46:42 <ij> I had no idea there's a thing called strictness .
18:46:54 <ij> So it makes it evaluate it when received?
18:46:59 <ij> The "a"s.
18:47:05 <Eduard_Munteanu> Yeah.
18:47:15 <chrisdone> forcing the constructor will force the fields
18:50:48 <carter> which is a good thing
18:55:52 <_shad_> Hi everyone! I need a bit of help with this http://lpaste.net/96715 problem
19:17:14 * hackagebot quickcheck-instances 0.3.4 - Common quickcheck instances  http://hackage.haskell.org/package/quickcheck-instances-0.3.4 (AntoineLatter)
19:18:51 <Saizan> _shad_: i can't tell, do you use info from the other matrixes to print the first one?
19:19:25 <pragmatism> back
19:22:15 * hackagebot hspec 1.8.0 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.8.0 (SimonHengel)
19:24:03 <ij> What can I use to fromInteger to a Float with an Int, not an Integer?
19:24:19 <geekosaur> :t fromIntegral
19:24:20 <lambdabot> (Integral a, Num b) => a -> b
19:24:39 <_shad_> Saizan : no. My problem is alignMatrix can't deal with IO String so I have to do pageStatusList <- mapM ... so mapM wait for complete result
19:26:47 <Saizan> _shad_: sorry, i meant first row
19:28:43 <Saizan> _shad_: my point is that if you can rewrite alignStrings so it takes just one element rather than a list then you can put it into the original mapM?
19:30:10 <_shad_> Saizan: Good idea. Thanks
19:31:12 <dirk103> this functional business is so completely foreign to me.
19:31:32 <dirk103> haskell seems a little overwhelming with keywords and organization of stuff. is it as complex as it looks?
19:31:36 <Saizan> i guess another way could be using pipes or conduits, but i'm not _that_ familiar with those
19:32:28 <Saizan> dirk103: not really, once you get more familiar with it
19:32:31 <Cale> dirk103: In absolute terms, it's not all that complex. I suppose once you factor in all the GHC extensions, there's a good bit more to learn. The hard part though is just teaching yourself to program again in this new way :)
19:34:32 <Cale> dirk103: I would say C++ is still about 5 times more complicated though, even after you include GHC's extensions :)
19:34:42 <dirk103> is it a bit sloppy dealing with things (like GTK) built in non functional languages?
19:35:04 <Cale> Haskell's FFI is pretty good as far as that sort of thing goes
19:35:13 <Cale> and for GTK specifically, there's a rather good binding
19:35:51 <Cale> http://hackage.haskell.org/package/gtk
19:36:15 <dirk103> one last googlable question. i was looking at multithreading and is it magically handled by the language or what?
19:36:47 <Cale> GHC has really good concurrency and parallelism support, but there's no automatic parallelisation
19:37:15 <Cale> The closest thing to implicit parallelism is via a primitive called par
19:37:57 <Cale> Evaluating par x y will cause x to be added to a queue of things to be evaluated on some processor if there's time available before it's needed, before proceeding with y as the result.
19:38:32 <dirk103> cool
19:39:45 <dirk103> is lisp and other functional languages like haskell in that you kind of specify what you want as a result and it does some magic? or is that specific to haskell ?
19:39:46 <Cale> Adding annotations of that sort will never change the result of your program, so it can be attempted harmlessly, and there are some libraries of things built in terms of that, notably Control.Parallel.Strategies
19:39:56 <jack_rabbit> dirk103, Lisp is a family of languages.
19:40:19 <Cale> Well, what Haskell is doing isn't really magic. The language does give the compiler some options as to what order things are evaluated in though.
19:40:57 <Cale> But lazy evaluation is a particular evaluation order (outermost first, with bound variables evaluated at most once)
19:40:58 <dirk103> oh i know, it just seems like a fairly complex thing to implement
19:41:15 <Cale> and you can always use that as a pretty good approximation of what will happen
19:41:36 <Cale> Lisps usually use strict evaluation (innermost first)
19:41:46 <Cale> and usually they allow effects to occur during any evaluation
19:43:03 <Cale> Haskell maintains the property that expression evaluation is referentially transparent (if you evaluate an expression in isolation, it will always produce the same result in context)
19:44:47 <Cale> That's really really useful for testing programs and understanding how they work, but it means that we have to approach I/O a bit differently
19:54:56 <Kron> dirk103: it sort of depends on the variant of lisp
19:55:16 <Kron> common lisp is incredibly referentially nontransparent and impure and sort of compromisey
19:55:35 <Kron> some dialects of scheme are much closer to haskell in terms of pure declaration
19:55:47 <L8D> Whereas Scheme is a lot more minimalistic and pure.
19:55:52 <Kron> I think prolog, haskell and other MLs like ocaml have the most declarativeness tothem
19:56:01 <Kron> *to them
19:57:28 <Kron> hmmm
19:57:39 <Kron> is there any builtin function that splits a list into various sublists of length n?
19:58:37 <shiona> > chunksOf 3 [1..20] -- like this?
19:58:38 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
19:58:47 <Kron> oooh yess!
19:58:54 <Kron> where's that from? It's not in Data.List
19:58:56 <shiona> data.list.split
19:59:09 <shiona> capitalized of course
19:59:19 <Kron> ah
19:59:24 <Kron> so... there are submodules to Data.List?
19:59:37 <shiona> at least this, yes
19:59:37 <Kron> I assumed Data.List just absorbed them all
19:59:56 <haasn> Kron: Data.List.Split is in a separate package (split)
20:00:03 <haasn> Data.List is from base
20:00:11 <Kron> ah
20:00:33 <jack_rabbit> That's something I find weird about Haskell packages, too. They're not like Java packages.
20:00:37 <Kron> how do I get this then?
20:01:37 <jack_rabbit> Kron, do you have cabal-install?
20:01:42 <Kron> I do!
20:01:48 <jack_rabbit> cabal install split
20:03:13 <jmcarthur> ooh, structured-haskell-mode looks nice
20:03:56 <jack_rabbit> jmcarthur, that an emacs mode?
20:04:04 <jmcarthur> it's a minor mode
20:04:08 <jmcarthur> https://github.com/chrisdone/structured-haskell-mode
20:04:17 <jack_rabbit> cool. I don't like the modes I have for Haskell right now.
20:04:32 <jmcarthur> it's just the haskell equivalent to paredit
20:05:00 <L8D> I didn’tknow chrisdone did haskell...
20:07:21 * hackagebot GLFW-b 1.4.2 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.4.2 (BrianLewis)
20:08:48 <dirk103> this seems so cool
20:08:50 <dirk103> and foreign
20:10:50 <jmcarthur> what does?
20:11:23 <jmcarthur> oh, just haskell?
20:47:27 <codygman> Anyone know of any shopping cart type libraries for haskell? Maybe something for Yesod or Happstack? Perhaps I'm asking the wrong question, but coming from a python/django background they have things like Django-oscar and django-cart.
20:48:00 <zee_hax0r> I stole mine from Walmart
20:48:45 <codygman> zee_hax0r: I can't seem to find it: https://github.com/walmartlabs
20:51:15 <zee_hax0r> I guess sense of humor got blocked within the no-sense of humor monad!
20:51:51 <codygman> zee_hax0r: Or perhaps that wasy my sense of humour ;)
20:51:52 <startling> I'm curious if any of you have seen this, or can think of a constraint makes a Monad instance possible: https://gist.github.com/startling/7f90ba0778910c90b8b1
20:57:25 <haasn> startling: what on earth is the ‘f’ doing here?
20:58:47 <startling> haasn, it lets me add more information in a particular way
20:58:51 <startling> one sec
20:59:22 <startling> (I'm pretty sure Free isn't isomorphic, if that's what you're asking)
21:00:54 <khyperia> I think what haasn is asking is how f is used.
21:01:01 <khyperia> as in what is it's point
21:02:22 <startling> https://gist.github.com/startling/7f90ba0778910c90b8b1
21:02:47 <startling> oh wait a second
21:02:53 <startling> hahaha
21:02:56 * startling facepalm
21:03:19 <haasn> startling: would you accept (e ~ Tagged) or (e ~ Const) as valid solutions to your question? :)
21:03:43 <startling> I meant something else and then I changed it when I was tired last night and forgot what I was doing.
21:03:46 <startling> Thanks !
21:05:55 <L8D> What’s the difference between ^, ^^, and **?
21:06:12 <startling> L8D: their types
21:06:18 <startling> :t (^)
21:06:18 <lambdabot> (Integral b, Num a) => a -> b -> a
21:06:24 <startling> @src (^)
21:06:24 <lambdabot> x ^ 0            =  1
21:06:24 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
21:06:24 <lambdabot>   where f _ 0 y = y
21:06:24 <lambdabot>         f x n y = g x n
21:06:24 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
21:06:26 <lambdabot>                       | otherwise = f x (n-1) (x*y)
21:06:28 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
21:06:43 <startling> L8D: see http://www.haskell.org/haskellwiki/Power_function
21:07:03 <arkeet> ^ takes natural number exponents, ^^ takes integer exponents (possibly negative) but requires division
21:07:04 <arkeet> :t (^^)
21:07:05 <lambdabot> (Fractional a, Integral b) => a -> b -> a
21:07:08 <L8D> startling: thanks
21:07:08 <arkeet> hence the Fractional constraint
21:07:13 <arkeet> ** is floating point power
21:07:21 <arkeet> basically.
21:07:26 <startling> :t (**)
21:07:27 <lambdabot> Floating a => a -> a -> a
21:07:40 <startling> (it's part of the Floating typeclass)
21:08:17 <arkeet> > 1 :: [()]
21:08:19 <lambdabot>   [()]
21:08:22 <arkeet> oh it's still there.
21:08:47 <joelteon> > 1 :: [Int]
21:08:48 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
21:08:48 <lambdabot>    arising from the literal `...
21:08:52 <joelteon> wat
21:08:57 <startling> it's just [()]
21:08:57 <L8D> :t ()
21:08:58 <lambdabot> ()
21:09:05 <L8D> :t (1, 2, 3, 4)
21:09:06 <lambdabot> (Num t, Num t1, Num t2, Num t3) => (t, t1, t2, t3)
21:09:09 <arkeet> > [(),()] * [(),(),()]
21:09:11 <lambdabot>   [(),(),(),(),(),()]
21:09:13 <abg>  /part
21:09:15 <startling> it should be Monoid a => Num [a]
21:09:21 <arkeet> startling: why?
21:09:34 <startling> arkeet, because then we can do more silly things in irc one-liners
21:09:40 <arkeet> I mean
21:09:42 <startling> it only needs mempty, yeah.
21:09:43 <arkeet> how does it make sense?
21:09:49 <L8D> :t (1,2)
21:09:50 <lambdabot> (Num t, Num t1) => (t, t1)
21:09:59 <haasn> startling: then what number is ["foo","bar"] and how does it compare to ["blah","startling"]?
21:09:59 <L8D> Are ()s dynamic lists?
21:10:05 <startling> it doesn't. you just need a typeclass that gives you at least one element.
21:10:13 <L8D> I thought they were used for tuples
21:10:21 <haasn> L8D: (,) etc. are tuples
21:10:23 <arkeet> haasn: that's not a question a Num instance is required to answer.
21:10:26 <startling> L8D: () is a type that just contains ()
21:10:42 <startling> L8D, it's a singleton type
21:10:43 <arkeet> > mempty :: ()
21:10:44 <lambdabot>   ()
21:10:46 <haasn> arkeet: okay, what is ["foo","bar"] * ["blah","startling"] ?
21:10:52 <arkeet> haasn: yes, better question.
21:10:52 <L8D> Oh...I thought that tuples were only for two elements
21:10:56 <arkeet> let startling answer that.
21:11:02 <arkeet> I'd put liftA2 mappend, though.
21:11:03 <L8D> > ["foo","bar"] * ["blah","startling"]
21:11:04 <lambdabot>   No instance for (GHC.Num.Num [[GHC.Types.Char]])
21:11:04 <lambdabot>    arising from a use of `...
21:11:10 <startling> haasn: heh, good question
21:11:14 <arkeet> a better question is how to define subtraction.
21:11:15 <startling> L8D: it's not really a tuple
21:11:21 <arkeet> > [(),(),()] - [()]
21:11:22 <lambdabot>   [(),()]
21:11:28 <startling> waiiit
21:11:29 <arkeet> () is a 0-tuple.
21:11:31 <haasn> > [] - [()]
21:11:32 <startling> > 1 :: ()
21:11:33 <lambdabot>   can't find file: L.hs
21:11:33 <lambdabot>   []
21:11:44 <startling> ^ would that instance be legal?
21:11:49 <arkeet> what instance?
21:11:51 <startling> Num ()
21:11:52 <L8D> :k (Int, Int)
21:11:52 <lambdabot> *
21:11:53 <haasn> startling: yes
21:11:57 <arkeet> sure
21:12:02 <haasn> startling: define everything as const ()
21:12:04 <arkeet> let everything return ()
21:12:08 <startling> I think you could do Num a => Num [a], then
21:12:20 <haasn> > toInteger [(),(),(),()]
21:12:20 <arkeet> the point of [()] is that it's the natural numbers.
21:12:21 <lambdabot>   No instance for (GHC.Real.Integral [()])
21:12:21 <lambdabot>    arising from a use of `GHC.Real...
21:12:26 <startling> arkeet: I know.
21:12:44 <arkeet> and that it's lazy.
21:13:13 <haasn> L8D: no, tuples may be of any length ≥ 2
21:13:18 <arkeet> > 0 :: Nat
21:13:19 <lambdabot>   Not in scope: type constructor or class `Nat'
21:13:22 <haasn> L8D: note that tuples of different lengths are entirely unrelated types
21:13:22 <arkeet> @let data Nat = Z | S Nat deriving (Eq,Show,Ord)
21:13:23 <lambdabot>  Defined.
21:13:23 <L8D> haasn: got it
21:13:28 <haasn> L8D: there's no connection between a 2-tuple and a 3-tuple, for example
21:13:48 <L8D> So they can be used as structs?
21:13:58 <haasn> yes
21:14:00 <L8D> and can be indexed?
21:14:04 <startling> not really.
21:14:05 <L8D> with (!!)
21:14:06 <haasn> no
21:14:09 <L8D> then how?
21:14:21 <arkeet> they can be indexed by pattern matching.
21:14:21 <startling> L8D: you can deconstruct them
21:14:22 <L8D> I know there is fst and snd
21:14:24 <haasn> > let (_,_,_,field,_,_) = (1,2,3,4,5,6) in field
21:14:25 <lambdabot>   4
21:14:27 <nisstyre> L8D: what you would use a struct for in other languages you usually want a product type for in Haskell. tuples are like generic product types
21:14:31 <L8D> but how would you access the nth field?
21:14:40 <arkeet> by pattern matching on the nth component.
21:14:49 <arkeet> like above.
21:14:52 <L8D> okay
21:14:54 <nisstyre> > let thrd (_,_,x) = x in thrd (1,2,3)
21:14:55 <lambdabot>   3
21:14:59 <haasn> L8D: in real world code you'd use your own record instead of a tuple for clarity
21:15:12 <L8D> It seems like there are some things that cannot be achieved without pattern matching in haskell
21:15:21 <haasn> L8D: data Foo = Foo { field1 :: Type1, field2 :: Type2, field3 :: Type3 }
21:15:22 <arkeet> you mean like everything?
21:15:24 <L8D> haasn: thanks
21:15:48 <L8D> arkeet: Is that how the standard library is implemented?
21:15:53 <arkeet> @src snd
21:15:53 <lambdabot> snd (_,y) =  y
21:15:59 <L8D> holy shit
21:16:08 <L8D> I never realised that Haskell was _that_ bootstrapped
21:16:17 <haasn> fwiw in GHC HEAD you could use GADTs/DataKinds stuff to simulate arbitrary-sized tuples together with generalized (static) indexing
21:16:21 <arkeet> everything in haskell basically consists of function application, pattern matching, and primops
21:16:24 <L8D> no wonder GHC is 200 mb
21:16:39 <haasn> L8D: GHC is like 1 MB of compressed source code iirc
21:16:49 <haasn> most of that 200 mb is binaries, and libraries
21:17:01 <haasn> and dependencies
21:17:15 <L8D> hm...
21:17:16 <haasn> I think the vast, vast majority of the GHC download is the included copy of minGW
21:17:37 <L8D> Now I think of haskell in a whole new wau
21:17:39 <L8D> way*
21:17:54 <L8D> I knew that there was some optimization by design
21:17:56 <L8D> but damn
21:18:04 <haasn> not everything is bootstrapped, of course. There are some things that can't be defined *in* Haskell, like seq (at least not without other extensions)
21:18:06 <nisstyre> arkeet: and type checking, and kind checking, and type class instantiation, and io actions, and all of that other stuff
21:18:18 <haasn> and all of the primops (like Int addition) are external
21:18:22 <arkeet> nisstyre: I was talking about evaluation
21:18:30 <nisstyre> arkeet: oh ok
21:18:36 <L8D> @src (!!)
21:18:36 <lambdabot> xs     !! n | n < 0 = undefined
21:18:36 <lambdabot> []     !! _         = undefined
21:18:36 <lambdabot> (x:_)  !! 0         = x
21:18:36 <lambdabot> (_:xs) !! n         = xs !! (n-1)
21:18:58 <arkeet> note: @src lies a little sometimes.
21:19:06 <haasn>  @src likes a lot, often
21:19:08 <haasn> lies*
21:19:15 <arkeet> for the actual source you should look at the docs.
21:19:16 <L8D> yeah, it should be throwing errors and the first two lines
21:19:22 <arkeet> hoogle makes things easy to find.
21:19:30 <haasn> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-List.html#%21%21
21:22:29 <L8D> @src (++)
21:22:29 <lambdabot> []     ++ ys = ys
21:22:29 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
21:22:29 <lambdabot> -- OR
21:22:29 <lambdabot> xs ++ ys = foldr (:) ys xs
21:22:45 <L8D> @src (:)
21:22:45 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:22:50 <arkeet> (:) is a data constructor.
21:22:55 <L8D> wat
21:22:56 <haasn> (:) is built into Haskell
21:23:01 <arkeet> for the list type.
21:23:07 <L8D> :(
21:23:14 <arkeet> you can think of it as: data [a] = [] | a : [a]
21:23:19 <haasn> (It's actually another example of something that can't be defined *in* haskell, simply because of the syntax though)
21:23:30 <haasn> or data [] a = [] | a : [] a
21:23:34 <arkeet> sure.
21:23:34 <L8D> Is there a list somewhere of everything that is built-in?
21:23:40 <haasn> L8D: the haskell report
21:23:47 <L8D> Link?
21:23:52 <arkeet> @where report
21:23:52 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
21:23:54 <haasn> http://www.haskell.org/onlinereport/haskell2010/
21:24:36 <haasn> http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1160006
21:24:56 <L8D> Why does haskell have to be so cool but so impractical!?
21:25:16 <L8D> At least for my line of work
21:26:06 <arkeet> why is it impractical?
21:26:24 <L8D> because I do web programming stuff
21:26:34 <haasn> L8D: web programming is an area haskell is known to excel at
21:26:47 <haasn> look at yesod, happstack, snap, warp, etc.
21:26:56 <L8D> But you have to use Bytestrings and all that
21:27:20 <arkeet> what for?
21:27:36 <arkeet> (and what's wrong with them?)
21:27:49 <haasn> that depends strongly on the level of abstraction; and with the right helpers, working with ByteString is no more complicated than working with other data types
21:27:56 <L8D> I’ve been told that is what you need to use to do things efficiently
21:28:08 <haasn> it depends highly on the task
21:28:21 <L8D> There are a lot of cool things you can do with Haskell, but you can use those cool things in web programming
21:28:24 <haasn> ByteString has specific semantics
21:28:59 <L8D> It’s not like you’re going to need to generate infinite lists of numbers
21:29:08 <L8D> at most, you’ll do a bunch of regular expressions.
21:29:27 <L8D> but V8’s regexp library is a billion times faster than GHC’s
21:29:38 <haasn> in Haskell land we tend to not use regexps
21:29:50 <haasn> in favor of our deliciously higher level parser combinator libraries etc.
21:30:18 <L8D> Hm...But don’t those still use regexps in some way?
21:30:25 <arkeet> no?
21:30:30 <L8D> or do they do byte-by-byte parsing?
21:30:36 <jle`> er
21:30:36 <haasn> depends on the library
21:30:46 <L8D> Well, pandoc is pretty slow
21:30:47 <haasn> most of the time they work with Char streams
21:30:57 <newsham> l8d http://commandcenter.blogspot.com/2011/08/regular-expressions-in-lexing-and.html
21:31:21 * haasn is of the strong opinion that regexps are “write-only”
21:31:40 <jle`> is MonadPlus synonymous with Successs/Failure-type monads?  or is that only one way to implement a MonadPlus?
21:31:49 <newsham> dont use a ferrari to go to the store for milk
21:31:58 <jle`> the only MonadPlus's in base (Maybe and []) are all success/failure type monads
21:32:10 <jle`> but i was wondering if this was just a concidence or if it's like an actual law
21:32:45 <khyperia> If I want to have a dictionary/list of tuples/whatever from String to a (Typeable t) => t, what would that look like?
21:32:59 <khyperia> basically saying "list of *something*s"
21:33:13 <haasn> jle`: mzero >> f = f >> mzero = mzero -- is an actual requirement
21:33:15 <haasn> jle`: so that counts as a sort of “failure condition”
21:33:18 <L8D> Well still, Haskell doesn’t seem appropriate for my line of work
21:33:21 <jle`> i mean i guess you could always implement Maybe with 'backwards' "right-catch"/Last rules.
21:33:23 <L8D> You can’t write a streaming JSON parser in 20 lines of Haskell
21:33:27 <haasn> jle`: there's no requirement on what mplus does, however, other than that it's associative and mzero is its identity
21:33:35 <arkeet> khyperia: it would look like a dictionary/list of tuples/whatever from etc.
21:33:37 <L8D> And all the haskell-to-JS transpilers suck
21:33:43 <newsham> l8d: unless you want something that runs super super fast, dont use haskell for writing servers.   http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
21:33:53 <newsham> use something slower like nginx
21:34:00 <haasn> jle`: so in practice, failure `mplus` x = x, meaning mplus *has* to be some sort of “pick the non-failed value”
21:34:20 <khyperia> arkeet, the thing is, the elements are all different types - some are functions, some are values, etc.
21:34:31 <khyperia> and I'm unsure of how to write the type for that
21:34:36 <jle`> haasn: would i be wrong to write an article explaining MonadPlus as the "success/failure monad class"?
21:34:48 <arkeet> khyperia: well,
21:34:51 <arkeet> (1) don't do that.
21:34:54 <arkeet> (2) look at Dynamic
21:34:58 <arkeet> (which is basically Typeable t => t)
21:34:59 <jle`> where errors earlier in a composition propagate all the way to the end
21:34:59 <haasn> jle`: I don't think it would be wrong, no
21:35:03 <khyperia> Right.
21:35:16 <haasn> jle`: in fact, ‘guard’ (the canonical “fail if condition is false” function) is implemented via MonadPlus
21:35:21 <haasn> jle`: but be sure to mention what the precise laws are
21:35:27 <haasn> “success” and “failure” aren't clearly defined
21:35:29 <jle`> haasn: yes, i know that guard works exactly to those means
21:35:46 <arkeet> > [1] `mplus` [2,3]
21:35:47 <lambdabot>   [1,2,3]
21:35:48 <jle`> but i wasn't sure if all monadplus's had to be meaningful with guard
21:36:01 <L8D> newsham: I still don’t see advantages to that since Node.js does pretty much the same thing with libuv though it’s abstracted
21:36:09 <startling> is there a reason there's no (Monoid e, Monad w) => Monad (EnvT e w) instance?
21:36:10 <haasn> MonadPlus's laws ensure that guard False >> x = mzero
21:36:11 <jle`> er..had to have a meaningful result when used with guard
21:36:22 <arkeet> what's EnvT?
21:36:29 <jle`> haasn: ah, that's exactly what i was looking for
21:36:48 <startling> arkeet: it's in comonad. data EnvT e w a = EnvT e (w a)
21:36:59 <newsham> l8d: node does not outperform nginx
21:37:00 <jle`> hm. actually there are still questions. but i must think of how to formulate them.
21:37:14 <arkeet> startling: becuase you should be using WriterT instead.
21:37:26 <haasn> MonadPlus's laws also ensure that (guard False >> x) `mplus` return y = return y
21:37:36 <startling> arkeet, it's annoying to have to convert between them. :(
21:37:57 <jle`> does MonadPlus ensure something like (return x >>= guard False >>= return y) = return x?
21:38:00 <jle`> er
21:38:00 <haasn> MonadPlus's laws *don't* ensure that (guard True >> return x) `mplus` return y = return x
21:38:01 <newsham> also node is neither strongly typed or statically typed
21:38:02 <jle`> mempty
21:38:04 <jle`> sorry
21:38:17 <jle`> return x >>= guard False >>= return y = empty
21:38:32 <arkeet> that's a type error.
21:38:33 <haasn> jle`: do you mean if  return x >> guard False >> return y = mzero -- ?
21:38:47 <arkeet> well, return _ >> x = x
21:38:57 <jle`> er yeah, i mean mzero
21:38:59 <haasn> and _ >> mzero = mzero
21:39:00 <jle`> return x >>= guard False >>= return y = mzero
21:39:08 <haasn> note: guard False = mzero
21:39:08 <jle`> also i mean >>
21:39:10 <jle`> heh.
21:39:38 <jle`> so mzero >> return y has to be mzero?
21:39:42 <haasn> yes
21:40:11 <jle`> okay
21:40:37 <jle`> is this just a "law" or is a default implementation or something that enforces this?
21:40:40 <jle`> language-wise
21:40:58 <arkeet> most "laws" aren't enforced by anything.
21:41:09 <jle`> ah ok.
21:41:35 <jle`> still, the 'spirit' of MonadPlus is success/failure
21:41:49 <jle`> yes?
21:42:03 <jle`> it's not altogether apparent from the documentation
21:42:05 <haasn> L8D: http://hackage.haskell.org/package/pipes-aeson <- seems to be related to streaming JSON or w/e
21:42:10 <jle`> oh wait...it is.
21:42:18 <jle`> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#t%3AMonadPlus silly me
21:42:49 <jle`> well..it's not altogether apparent from the name
21:42:53 <jle`> who chose the name MonadPlus anyway
21:43:11 <haasn> iirc there used to be a MonadFailure that only had mzero
21:43:48 <haasn> or maybe that was just a plan to get “fail” out of Monad? no idea
21:44:07 <haasn> why isn't guard implemented in terms of ‘fail’, anyway?
21:44:38 <startling> fail isn't very flexible.
21:44:56 <startling> it can't raise an error in e.g. ErrorT String
21:45:32 <arkeet> don't use fail. also don't use ErrorT.
21:45:32 <jle`> huh i wonder what meaing mplus even has
21:45:38 <startling> sorry, EitherT
21:45:40 <jle`> > Just 5 `mplus` Just 6
21:45:41 <lambdabot>   Just 5
21:45:55 <jle`> so it's like First huh.
21:45:58 <startling> > Nothing `mplus` Just 6
21:45:59 <haasn> jle`: exactly
21:45:59 <lambdabot>   Just 6
21:46:05 <startling> jle`: it's a monoid on a monad
21:46:06 <jxv> jle, it's like monoid for monads
21:46:27 <haasn> (for Maybe, that is)
21:46:38 <jle`> What is it useful for...something like Alternative, but Monads?
21:46:53 <startling> it's Alternative from back in the day before Alternative existed
21:47:00 <jle`> when would you want to use mplus instead of <|> ?
21:47:01 <haasn> the big differecne to alternative is that alternative doesn't have the mzero >> _ = mzero law
21:47:04 <startling> *before Applicative existed
21:47:13 <jle`> ah
21:47:13 <startling> haasn: oh, that's interesting
21:47:14 <BMeph> ...before Applicative...
21:47:27 <jle`> i feel like there should be two different classes then
21:47:36 <jle`> one with mzero and one with <|>
21:47:46 <jle`> can someone tell the haskell maker plz.
21:47:56 <haasn> many parts of the hierarchy could be split up into tiny independent classes
21:47:59 <haasn> but at the cost of gigantic and confusing contexts
21:47:59 <arkeet> there's already been some discussion on that.
21:48:01 <startling> jle`, mzero/empy is useful for Alternative though
21:48:08 <haasn> and sometimes there's no justification for providing only one
21:48:12 <arkeet> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
21:48:25 <startling> class (Monad m, Alternative m) => MonadPlus m
21:48:49 <arkeet> are there any types with Alternative and MonadPlus instances that disagree?
21:48:50 <jle`> startling: yeah, i meant that.
21:49:03 <startling> arkeet: good question.
21:49:07 <jle`> but
21:49:16 <jle`> i think haasn makes the good point
21:49:26 <jle`> hm
21:49:28 <arkeet> there is one good point, and he makes it.
21:49:38 <jle`> that means empty and mzero have different purposes
21:49:45 <jle`> empty when you use <|>/choice
21:49:46 <haasn> arkeet: it's absolutely possible, as far as the laws are concerned
21:49:49 <jle`> mzero when you >>/sequence
21:49:58 <arkeet> haasn: I'm not asking whether it's possible ;)
21:50:02 <jle`> how unfortunate
21:50:59 <jle`> but i guess it could be assumed that the mzero/empty chimera (mzerempty) would satisfy both mzerempty <|> return a = return a, and mzerempty >> _ = mzerempty
21:51:16 <jle`> where the second constraint is only for monads and not for alternatives
21:51:34 <arkeet> jle`: give the thing I linked a read ;)
21:51:45 <haasn> jle`: what about mzerempty *> _
21:52:15 <haasn> aside: is there any difference between (>>) and (*>)? I forgot
21:52:24 <haasn> I think the last time I asked this we proved that they have to be equivalent
21:53:05 <arkeet> proved how??
21:53:20 <arkeet> anyone who writes instances that make them inequivalent should be shot.
21:53:21 <jle`> perhaps that if they weren't, a law somewhere would be broken
21:53:29 <haasn> arkeet: via If f is also a Monad, it should satisfy pure = return and (<*>) = ap (which implies that pure and <*> satisfy the applicative functor laws).
21:53:50 <arkeet> oh, then it's not hard to show (*>) = (>>)
21:53:52 <haasn> specifically, (<*>) = ap  implies (*>) = (>>)
21:53:54 <haasn> yes
21:55:01 <haasn> note: shouldn't this say “which implies that return and ap satisfy the applicative functor laws”?
21:55:05 <haasn> pure and <*> already do.
22:17:37 * hackagebot aws-sdk-text-converter 0.2.0.0 - The text converter for aws-sdk.  http://hackage.haskell.org/package/aws-sdk-text-converter-0.2.0.0 (YusukeNomura)
22:47:12 <Sgeo> If not writing in the WAI ecosystems, what reasons are there currently to use conduit instead of pipes?
23:00:49 <Sgeo> Reading some of Snoyman's posts.... I finally see something that actually concerns me about pipes over conduit (still haven't processed the finalization stuff)
23:00:56 <Sgeo> "pipes: How do I fold?"
23:06:49 <arkeet> Sgeo: what do you mean?
23:07:53 <arkeet> oh
23:07:55 <arkeet> that's the title
23:14:50 <udevd> hi! I'm having [String,String,String,String] and would like to read all strings to form (Int,Int,Int,Double). How to do it nicely?
23:15:22 <Iceland_jack> Well [String, String, String, String] is not a type, I'm guessing you have a [String] of length four?
23:15:53 <udevd> yup, it was implicite
23:16:15 <Iceland_jack> > (\[a, b, c, d] -> (read a, read b, read c, read d) :: (Int, Int, Int, Double)) ["5", "6", "7", "3.1415"]
23:16:16 <lambdabot>   (5,6,7,3.1415)
23:16:40 <udevd> It doesn't look >nicely
23:16:41 <udevd> :P
23:17:13 <udevd> i thought there may be better-looking way
23:17:15 <Iceland_jack> That's not a problem with the answer :)
23:17:25 <Iceland_jack> you shouldn't use a 4-tuple
23:18:01 <jle`> the reason why it's ugly is because it's usually not what you want to actually do :)
23:18:27 <udevd> later i'm transforming it into proper type, but *somewhere* i need to read the data
23:18:32 <jle`> on top of the fact that 4tuples are rarely necessary, it looks to me like you are using a list as a data structure
23:18:34 <jle`> er
23:18:43 <jle`> as an array/indexed data structure
23:18:57 <Iceland_jack> udevd: Yes, so just drop the intermediate tuple then
23:19:35 <Iceland_jack> If you're going to end up with a data type
23:19:35 <Iceland_jack>     data A = A Int Int Int Double
23:19:35 <Iceland_jack> (in which case you wouldn't need the type annotation) then do it right off the bat
23:19:39 <udevd> i wanted to separate reading from anything else :P
23:19:55 <Iceland_jack> What is ‘everything else’ here?
23:19:56 <jle`> udevd: can you lpaste some context?
23:20:21 <udevd> jle`: it's rather complicated... and not so well-written
23:20:23 <Iceland_jack> Separating reading from the actual data structure that you want doesn't make a lot of sense to me
23:20:49 <udevd> but i can say that this (int,int,int,double) i want to read is basically channel number from detector and time of trigger
23:21:23 <udevd> and later i need to translate three integers into type `Wire` (fired wire in detector), which is not simple 3 ints
23:21:36 <udevd> (i'm using IntMap.lookup to do so)
23:22:27 <udevd> if i'd insert all this lookup into reading module, it'd look bad
23:22:28 <udevd> :P
23:23:16 <jle`> probably not as bad as using a 4ple
23:23:24 <jle`> :)
23:23:27 <jle`> but how can i know
23:26:18 <Iceland_jack> I prefer reading all my values into nested tuples
23:26:43 <Iceland_jack> (((Int, String), Bool, Float), Word8)
23:27:14 <udevd> why for?
23:27:28 <Iceland_jack> I don't actually :)
23:28:50 <jle`> i don't like currying so i reimplemented foldl to take in a 3ple
23:29:17 <Iceland_jack> yeah currying innit, what's it good for
23:29:38 <jle`> myFold (f, a, xs) = foldl' f a xs
23:29:45 <Iceland_jack> beautiful :)
23:29:54 <jle`> fixing haskell one function at a time
23:31:05 <Iceland_jack> > let take' = uncurry take in take'(6, "testing")
23:31:05 <Iceland_jack> doesn't look so bad though
23:31:06 <lambdabot>   "testin"
23:33:13 <jle`> i think there's someone in here actually who believes currying should have been non-default, so that we could have default values
23:33:19 <jle`> like unironically
23:35:04 <Iceland_jack> Well to that point, I feel Haskell sometimes bends over backwards to express default values (QuickCheck, CreateProcess, …) but come on
23:35:13 <codygman> Hi all, 2 problems. 1) My code isn't working and I'm not sure why it isn't being evaluted even though I used System.IO.Strict. 2) I'm sure problems with my code and a much simpler way to update a json object in a file. Here is my code: http://lpaste.net/96726
23:35:54 <udevd> codygman: and error is...? this one in line 25?
23:36:14 <udevd> on line*
23:36:16 <codygman> udevd: I'm sorry, the error is that the program doesn't produce output.
23:36:27 <codygman> udevd: That is a stylistic error
23:36:36 <Iceland_jack> codygman: Have you tried surrounding the SIO.print with other prints?
23:36:51 <codygman> Iceland_jack: No, but I'll try that now.
23:38:46 <Sgeo> lookup = go
23:38:46 <Sgeo>   where
23:38:47 <Sgeo> wat
23:39:03 <Sgeo> Is that related to the weird STRICT_1_OF_2(go) thing on the next line?
23:39:21 <Iceland_jack> Sgeo: It's an optimization
23:39:58 <averell> BN
23:40:09 <Iceland_jack> http://stackoverflow.com/questions/9757515/haskell-platform-nested-functions-and-optimization
23:41:00 <codygman> Iceland_jack: It gives an error when I surround SIO.print of "add an instance declaration for (Show (IO (SIO.SIO ())))". I'm guesing this means I'm doing things all wrong because that should be necessary right?
23:41:06 <Sgeo> hmm, ty
23:41:57 <Iceland_jack> codygman: What did you write exactly?
23:42:27 <codygman> Iceland_jack: http://lpaste.net/96726 If you are asking what I was doing, I was just trying to use aeson to update values in a json file.
23:42:35 <Sgeo> :t isJust
23:42:35 <lambdabot> Maybe a -> Bool
23:42:49 <Iceland_jack> I mean what was the change you made that resulted in that error message
23:42:59 <codygman> Iceland_jack: Sorry, adding that now
23:43:07 <Sgeo> Is combining isJust with lookup any less efficient than member?
23:43:58 <Iceland_jack> Sgeo: Possibly, why would you want to do that?
23:44:10 <codygman> Iceland_jack: Updated it at http://lpaste.net/96726
23:44:19 <Sgeo> Seems a bit silly to define trivial compositions
23:44:24 <Sgeo> Explictly
23:44:25 <codygman> line 29
23:44:36 <Iceland_jack> codygman: You can't ‘print’ and IO action
23:44:38 <Iceland_jack> *an
23:45:21 <Iceland_jack> When I said ‘surround’ I mean above and below:
23:45:21 <Iceland_jack>     putStrLn "first"
23:45:21 <Iceland_jack>     SIO.print …
23:45:24 <Iceland_jack>     putStrLn "last"
23:45:52 <Iceland_jack> :t print (print undefined) -- is most assuredly a type error
23:45:53 <lambdabot> IO ()
23:46:05 <udevd> well
23:46:06 <udevd> xD
23:46:11 <Iceland_jack> hah... except in lambdabot
23:46:27 <Iceland_jack> But lambdabot is ridiculously modded, still: egg on my face
23:46:54 <udevd> yup, in ghci >    No instance for (Show (IO ()))
23:46:55 <udevd>       arising from a use of `print'
23:46:55 <codygman> Iceland_jack: Alright, that leads me to the problem of how do I map my updateModels function to an IO (Maybe [Product]) updating each one of the model names to "lulzmodel"? My misunderstanding and reading the type errors led me to satisfy the compiler using return. This worked in ghci, but as we know didn't work after I compiled/ran my program.
23:47:04 <arkeet> > print undefined
23:47:05 <lambdabot>   <IO ()>
23:47:11 <Iceland_jack> codygman: You seem to be confused
23:47:22 <Iceland_jack> There is *no* reason to make getJSON impure
23:47:50 <Iceland_jack> You may want to familiarize yourself more with IO
23:48:15 <Iceland_jack> If you want to define a local value in the do-notation you use let
23:48:52 <Iceland_jack>     main = do
23:48:52 <Iceland_jack>         let d ∷ Maybe [Product]
23:48:52 <Iceland_jack> 	    d = decode getJSON
23:48:52 <Iceland_jack> 	
23:48:58 <Iceland_jack> modulo indentation :)
23:50:45 <udevd> Iceland_jack: ...and there comes > in print d
23:50:51 <udevd> or can i actually omit `in`
23:51:43 <Iceland_jack> You omit ‘in’, that's right
23:51:56 <codygman> Iceland_jack: Actually getJSON has IO because it reads from a file. In what I posted I just stubbed it in there. I do agree that I am confused though, perhaps I'll go back to typeclassopedia lol
23:52:33 <udevd> Iceland_jack: so for example: let d::Int \\ d=2 \\ print d
23:52:35 <udevd> would work?
23:52:59 <Iceland_jack> > do let {d = 2}; print d
23:52:59 <Iceland_jack>     
23:53:00 <Iceland_jack> yes
23:53:00 <lambdabot>   <IO ()>
23:53:08 <Iceland_jack> > do let {d :: Int; d = 2}; print d
23:53:08 <lambdabot>   <IO ()>
23:53:12 <udevd> i can't see how it distringuish local variables from IO monads
23:53:22 <mirpa> When should I define return value of foreign function as an IO? IO like file read/write... what about functions which use eg. malloc in C. What is IO in terms of FFI?
23:53:25 <Iceland_jack> What do you mean udevd?
23:53:56 <udevd> i mean, i can write all this in one line using {;..;..};
23:54:14 <udevd> but shouldn't there be some indentation when writing in normal style?
23:54:16 <Iceland_jack> Ah I think I get your question
23:54:29 <Iceland_jack> indentation tells you where the local binding stops
23:54:29 <udevd> :3
23:55:05 <Iceland_jack> in reality it's:
23:55:05 <Iceland_jack> > do { line <- getLine; let {d :: Int; d = 2}; print (d, line) }
23:55:06 <lambdabot>   <IO ()>
23:55:29 <Sgeo> This looks cool http://hackage.haskell.org/package/pointless-fun-1.1.0.1/docs/Data-Function-Pointless.html
23:56:31 <Iceland_jack> Making do without braces it's:
23:56:31 <Iceland_jack>     do line ← getLine
23:56:31 <Iceland_jack>        let d ∷ Int
23:56:31 <Iceland_jack>            d = 2
23:56:34 <Iceland_jack>        print (d, line)
23:56:36 <udevd> so `let' and `print' are having the same indentation and `d::Int` and `d=2` should have +1 tab?
23:56:39 <udevd> oh, right
23:57:18 <Iceland_jack> You can define multiple values in the let clause
23:57:26 <Iceland_jack> you can also define monadic values
23:58:17 <Iceland_jack>     do let readThenPrint ∷ IO ()
23:58:17 <Iceland_jack>            readThenPrint = putStrLn =<< getLine
23:58:17 <Iceland_jack>        readThenPrint
23:58:50 <Iceland_jack> Just like you can create shell commands without running them in your favourite shell
23:58:57 <nurupo> Iceland_jack: why do you have "::" as '∷'?
23:59:13 <Iceland_jack> Force of habit
23:59:33 <nurupo> does it compile?
23:59:40 <Iceland_jack> yes, using UnicodeSyntax
23:59:46 <nurupo> interesting
