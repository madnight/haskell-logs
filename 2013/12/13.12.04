00:15:33 <jle`> how in a list monad do i filter out all elements not passing a predicate?
00:15:43 <jle`> *how do
00:15:45 <jle`> like in a do block
00:15:46 <quchen> jle`: guard
00:15:56 <quchen> :t guard
00:15:56 <lambdabot> MonadPlus m => Bool -> m ()
00:16:14 <quchen> do { x <- [1..10]; guard (even x); return x }
00:16:16 <quchen> > do { x <- [1..10]; guard (even x); return x }
00:16:18 <lambdabot>   [2,4,6,8,10]
00:18:42 <jle`> > do { x <- [1..10]; guard True; return x }
00:18:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
00:18:51 <jle`> it is a mystery to me.
00:18:54 <jle`> that is ok.
00:19:20 <shachaf> @undo do { x <- [1..10]; guard True; return x }
00:19:20 <lambdabot> [1 .. 10] >>= \ x -> guard True >> return x
00:19:28 <shachaf> Mystery gone.
00:21:29 <frx> @src guard
00:21:29 <lambdabot> guard True  =  return ()
00:21:29 <lambdabot> guard False =  mzero
00:25:00 <jle`> my intuition says return x should return the original x?
00:25:24 <jle`> x is the superposition of [1..10]...so wouldn't return x return that superposition?
00:25:52 <shachaf> x is a specific arbitrary value in [1..10].
00:25:59 <shachaf> Good combination of words.
00:26:57 <jle`> > do { x <- [1..10]; guard (even x) }
00:26:58 <lambdabot>   [(),(),(),(),()]
00:27:15 <jle`> that makes sense to me
00:27:39 <jle`> i am not seeing why that list appaers to result in a filtered x when you return x
00:28:05 <arkeet> > [ x | x <- [1..10], even x ]
00:28:06 <lambdabot>   [2,4,6,8,10]
00:28:11 <ion> jle: Try evaluating the >>=s by hand.
00:28:46 <arkeet> note: m >>= f = concat (map f m)
00:29:17 <jle`> > do { x <- [1..10]; y <- [11..20]; guard (even x); return y }
00:29:18 <lambdabot>   [11,12,13,14,15,16,17,18,19,20,11,12,13,14,15,16,17,18,19,20,11,12,13,14,15...
00:30:27 <jle`> > do { x <- [1..10]; y <- [11..20] }
00:30:28 <lambdabot>   The last statement in a 'do' block must be an expression
00:30:28 <lambdabot>    y <- [11 .. 20]
00:30:36 <jle`> > do { x <- [1..10]; [11..20] }
00:30:37 <lambdabot>   [11,12,13,14,15,16,17,18,19,20,11,12,13,14,15,16,17,18,19,20,11,12,13,14,15...
00:30:52 <jle`> it is replacing every value in x
00:30:55 <jle`> with [11..20], right?
00:31:02 <jle`> > do { x <- [1..10]; [11..12] }
00:31:04 <lambdabot>   [11,12,11,12,11,12,11,12,11,12,11,12,11,12,11,12,11,12,11,12]
00:31:35 <jle`> > do { x <- [1..10]; y <- ['a','b']; guard (even x); return y }
00:31:36 <lambdabot>   "ababababab"
00:31:41 <danilo2> dcoutts: Hello dcoutts :) Are you here? I was talking yesterday with Cale and he suggested me, you will be the best person to ask about my problem :)
00:33:27 <jle`> > [(), (), (), (), ()] >> return [1..10]
00:33:28 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,...
00:34:11 * hackagebot aws-sdk-xml-unordered 0.1.0.0 - XML parser for aws-sdk  http://hackage.haskell.org/package/aws-sdk-xml-unordered-0.1.0.0 (ShoheiYasutake)
00:37:02 <jle`> i'll work out the >>= manually i think.
00:37:40 <arkeet> please do.
00:58:05 <BoR0> why is it that ":t do { return [1..10] }" has type m [t] but ":t do { x <- [1..10]; return x }" has type [t] (non-monadic)?
00:58:37 <shachaf> Because they are different.
00:58:39 <BoR0> how?
00:58:53 <ion> do { x <- foo; return x } = do { foo } = foo
00:58:53 <shachaf> You can drop the "do" from the first one. It's just the value "return [1..10]"
00:58:54 <arkeet> there is nothing that makes them the same.
00:58:56 <ion> foo ≠ return foo
00:59:12 <arkeet> one of them is return [1..10]; the other is [1..10] >>= return
00:59:28 <BoR0> aha, that clarifies it. thanks
00:59:55 <BoR0> so, "do" doesn't necesarrily return a monadic value?
01:00:01 <arkeet> do is syntax.
01:00:30 <arkeet> > do True
01:00:31 <lambdabot>   True
01:01:29 <ion> bor0: “do { 42 }” doesn’t use monads at all (because the desugaring rules for that expression just drop the “do”) but that’s not why your expression didn’t say “Monad m => …”. You constrained it to the [] monad with “x <- [1..10]”.
01:03:08 <BoR0> what is the name of the >> operator? and what does it do? I think I know about bind >>= but not about this one
01:03:14 <shachaf> @src >>
01:03:14 <lambdabot> m >> k      = m >>= \_ -> k
01:03:15 <arkeet> it's called >>
01:03:18 <shachaf> Now you know.
01:03:59 <BoR0> aha, I see. okay, great!
01:04:19 <ion> “and then”
01:04:33 <arkeet> right shift
01:04:34 <shachaf> "thereafter" or "whence"
01:05:06 <ion> “wince” whenever you’re confused
01:05:25 <arkeet> I call it ">>"
01:05:32 <BoR0> so, it's "chaining" monads in a way?
01:05:50 <arkeet> it's chaining, in a way, but not monads
01:05:57 <ion> Not monads but monadic values.
01:05:58 <shachaf> "Monad" means a type constructor like "IO" or "Maybe"
01:06:23 <shachaf> A value can't be a monad.
01:06:35 <BoR0> and monadic values say for Maybe are Nothing and Just x?
01:06:40 <arkeet> sure
01:06:54 <BoR0> great! thanks for clearing notation for me and explaining >>
01:07:04 <shachaf> Often called "actions".
01:07:38 <hvr> w00t... text-1.0.0.0 released?
01:08:54 <danilo2> Hello, could someone clarify a little thing to me please? :) I understand, that mplus for lists is defined as (++). I've seen in Cabal-install following code: "combine f x g y  = fromJust (fmap f x `mplus` fmap g y)" , 'fmap f x' is a list, so everything betweeen parenthesees results in list, am I wrong?
01:09:21 <arkeet> danilo2: your assumption that 'fmap f x' is a list is wrong.
01:10:31 <Cale> fmap f x *could* be a list, but it could be many things
01:10:35 <Cale> :t fmap
01:10:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:10:49 <shachaf> In this case it is not a list.
01:10:57 <pdxleif> jle: replicateM can apple a "monadic action" n number of times
01:11:11 <Cale> and yeah, in this case, the fromJust forces it to be a Maybe
01:11:23 <ion> It can also pear a functor action.
01:11:32 <danilo2> Cale, arkeet: arkeet you're right. Cale - I know it but I was sure it is a list, but you are right it is not in this example. I did not notice a little fmap osmewhere in the code, thank you!
01:12:12 <arkeet> ion++
01:12:42 <dv-> > fmap (+1) (Just 1)
01:12:43 <lambdabot>   Just 2
01:22:10 <statusfa1led> Is there a way to use Trifecta with Data.Text.Lazy?
01:24:17 * hackagebot tianbar 0.2.2.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.2.2.0 (AlexeyKotlyarov)
01:41:00 <pdxleif> Would there be any reason why you'd choose one over the other between "putStrLn $ unlines foo" vs "mapM putSrLn foo"?
01:41:38 <Cale> pdxleif: Well, those programs are both more easily extended in different ways
01:41:42 <Cale> Apart from that, no
01:41:53 <Kinnison> The former is an IO () and the latter a [IO ()] ?
01:42:07 <Kinnison> Or does mapM move the IO out
01:42:07 <pdxleif> mapM_, then
01:42:08 <Cale> the latter is an IO [()]
01:42:09 * Kinnison can never remember
01:42:15 <Kinnison> Cale: ta
01:42:18 <Cale> but yeah, mapM_ would fix that
01:42:35 <pdxleif> I guess I was just thinking runtime efficiency
01:42:47 <pdxleif> making a big string, vs, repeated IO actions, I dunno
01:43:28 <Cale> For runtime efficiency, my gut reaction is that the one with unlines might be marginally faster, but the difference if any is extremely small.
01:44:20 <pdxleif> sounds convincing
01:44:28 <Cale> (It could even go the other way, I don't know)
01:44:55 <frx> Kinnison map alone would give you [IO ()]. mapM is sequence . map f
01:45:17 <Twey> Is there a Pipes equivalent to xml-conduit?
01:46:03 <arkeet> not yet! (you can write one.)
01:46:06 <arkeet> unless there is.
01:46:36 <Twey> Last I knew, calls to IO were expensive and thus the unlines version was quite a lot faster (for sufficiently large input).  That was a while ago, though.
01:46:51 <Twey> arkeet: Heh
01:47:08 <arkeet> I can't immediately find one though.
01:47:12 <Kinnison> frx: That's the bunny, I've been away from haskell for too long
01:48:06 <arbn> Twey: You should start to write one, get 75% done, put it up on GitHub, and then write a blog post about how easy it is.
01:51:10 <Twey> arbn: Haha.  I'm looking for something quick to drop into a small program I'm thinking of writing.  If there's nothing for pipes then I won't use pipes :þ  I might write one later, though, since that does seem like a hole.
01:56:56 <danilo2> Hello :) What does "deriving Data" mean? I havent found info about it and googling it doesnt give me any resonable info - if somebody would tell me what keywords should I look for it would be great :)
01:57:08 <dp_wiz> lens question. i have a map of map of ints. how do i point a view (or set) at the value of inner map?
01:57:08 <dp_wiz> lenses are supposed to be composable with a simple (.), but `map ^. at 42 . at 314` gives a type error of no instance `Num ()`...
01:58:49 <chrisdone> danilo2: the module is Data.Data
01:58:56 <chrisdone> danilo2: http://hackage.haskell.org/package/base-4.5.0.0/docs/Data-Data.html
01:59:07 <danilo2> chrisdone: Thank you! :)
01:59:22 * hackagebot cake3 0.2.1.0 - Third cake the Makefile EDSL  http://hackage.haskell.org/package/cake3-0.2.1.0 (SergeyMironov)
01:59:30 <nisstyre> danilo2: if you don't know, you can extend ghc to derive instances for things
01:59:48 <nisstyre> e.g. http://hackage.haskell.org/package/generic-deriving
02:00:25 <jle`> i think i understand it now.  [1..10] >>= \x -> guard (even x) >> return x is really [1..10] >>= (\x -> guard (even x) >> return x)...which makes sense in Maybe (guard (even x) will return Nothing for odd x, so it'll totally skip the return; guard (even x) will return [] for odd x, so return x will result in [x] for even x and [] for odd x (because [] >> anything is []))...so then you concat it all together
02:00:27 <jle`> at the end.  so if we consider the entire \x -> guard (even x) >> return x as its own function, it is a function that returns [x] for even x and [] for odd x.  okay sorry for flooding.
02:00:46 <supki> dp_wiz:  at  is a lens into Maybe value at key, so you need to traverse it:  map ^? at 42 . traverse . at 314 . traverse
02:00:56 <jle`> +
02:00:59 <danilo2> chrisdone, nisstyre: ahh this is for generics, I'm sorry - I knew that, but I somehow forgot that "Data.Data" is connected to it (not many times I've touched custom generics). Thank you!: )
02:01:00 <supki> dp_wiz: alternatively, use ix
02:01:17 <dp_wiz> supki: ix?
02:01:24 <supki> dp_wiz: which should behave the same as  at . traverse  for all At instances
02:01:47 <chrisdone> danilo2: note that the Data class is different to the newer Generic class. deriving Data is its own extension, as is deriving Typeable
02:02:12 <chrisdone> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/deriving.html
02:02:22 <supki> > M.fromList [(1, M.fromList [(2, 3)])] ^? ix 1.ix 2
02:02:23 <lambdabot>   Just 3
02:02:32 <dp_wiz> supki: yay. thanks
02:02:37 <supki> > M.fromList [(1, M.fromList [(2, 3)])] ^? at 1.traverse.at 2.traverse
02:02:38 <lambdabot>   Just 3
02:02:44 <chrisdone> actually there's nothing useful on that link
02:03:36 <bartavelle> can someone point me to the tool that converts haddocks links so that I can publish my haddocks on the web ?
02:04:11 <bartavelle> or is it an option of cabal haddocks ?
02:05:47 <chrisdone> bartavelle: run `cabal haddock' in your package directory and it generates docs in dist/
02:05:59 <bartavelle> yes, but links to external packages are bad
02:06:45 <bartavelle> I suppose I could fix that with sed, but I guess there is already a solution out there
02:07:12 <danilo2> chrisdone: hmm, ok I see it. Thank you very much for this information!
02:08:17 <chrisdone> welcome
02:10:09 <BoR0> is my thinking correct here? http://lpaste.net/96538
02:11:52 <shachaf> In general "unwrap" is not a word you want associated with >>= in your head.
02:12:25 <BoR0> if 5 is wrapped with Just, we get Just 5. doesn't bind kind of "unwrap" it?
02:13:02 <tovarish> no it doesn't unwrap values
02:13:13 <chrisdone> unJust is more like unwrapping, if anything
02:13:15 <shachaf> And if it is Nothing?
02:13:33 <shachaf> chrisdone: No need to bring that into the picture.
02:13:34 <BoR0> it will not unwrap anything, since >>= Nothing = Nothing
02:13:37 <chrisdone> you get no birthday presents
02:14:04 <shachaf> BoR0: More generally, with most monads it makes even less sense than with Maybe to talk about unwrapping.
02:14:13 <shachaf> That's why I said what I said.
02:14:24 <BoR0> okay, can you suggest an alternative word to "unwrap"?
02:14:38 <shachaf> I don't know.
02:14:40 <chrisdone> bind
02:15:04 <BoR0> ok, if I replace all ocurrences of "unwrap" with "bind" on that lpaste, will my thinking be correct
02:15:05 <shachaf> The idea that there's "a value in" >>='s argument in the first place is problematic.
02:15:11 <arbn> BoR0: Just wave your hands vigorously while saying "unwrap" and look annoyed.
02:15:22 <shachaf> No, that usage of "bind" doesn't really make sense.
02:15:33 <shachaf> arbn: Are you just trying to be unhelpful here?
02:15:52 <chrisdone> BoR0: probably it's better to ask some pentrating questions than make statements and ask how accurate they are
02:16:18 <shachaf> BoR0: Think of a few other examples. For instance, in addition to Maybe Int, think of [Int], Char -> Int
02:16:21 <dp_wiz> supki: yes, getting with (^?) and ix works. updating an existing element works too. but how to insert a new element?
02:16:26 <arbn> shachaf: No.
02:17:13 <BoR0> my question was, with bind operator, can we get x out of (Just x), and we can get x out of m (Just x) ?
02:17:59 <shachaf> Are you trying to get any sort of idea about monads in general here, or are you just talking about Maybe?
02:18:38 <shachaf> If you're talking about Maybe, then the function we're talking about here has this type: (a -> Maybe b) -> Maybe a -> Maybe b
02:18:58 <BoR0> about both I think :)
02:19:23 <shachaf> OK, well, I recommend that you read the FAQ.
02:19:27 <shachaf> @where faq
02:19:27 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
02:19:33 <BoR0> now especially that you told me to not look at it as "unwrapping"
02:20:13 <shachaf> My new recommendation is not to look at it at all.
02:20:49 <BoR0> but I am used to analogies, and you only make it harder for me :D
02:20:57 <tovarish> bind is the operation to use the magic wand
02:21:08 <quchen> BoR0: Like shachaf mentioned, (>>=) does not take anything out of the first operand, although in special cases that may be a convenient (and bad and wrong) way of looking at it. Going that way does more harm than good.
02:22:01 <BoR0> so, it is wrong to say that m a >>= b will pass non-monadic value a to b?
02:22:15 <quchen> You're mixing types and functions here.
02:22:16 <arbn> BoR0: When you say "unwrap"... what do you mean by that? Could you elaborate upon that operation further? I think people here are suspecting that you're thinking of containers.
02:23:03 <BoR0> I am thinking of a box with something in it. so box >>= function will pass that something to the function, which then the function will do something to something and return that new something in a new box
02:23:30 <BoR0> is this wrong?
02:23:32 <chrisdone> that's an okay start
02:23:51 <tovarish> BoR0, you're describing fmap not bind
02:24:04 <tdammers> chrisdone: until you encounter the List monad...
02:24:12 <chrisdone> tdammers: works fine for the list monad
02:24:38 <chrisdone> it's just vague as to be an uninteresting statement
02:25:21 <begriffs> BoR0: here's how I think of bind. http://blog.begriffs.com/2013/08/haskell-monads-explained-without-words.html
02:25:34 <chrisdone> BoR0: does your long statement say much more than: Monad m => (a -> b) -> m a -> m b?
02:25:38 <chrisdone> oops
02:25:42 <chrisdone> BoR0: does your long statement say much more than: Monad m => (a -> b) -> (a -> m b) -> m b?
02:25:59 <quchen> begriffs: If you disable Javascript the title is spot on.
02:26:07 * chrisdone smacks the water out of his ear
02:26:10 <arbn> BoR0: Monad pedagogy is a controversial topic. I suggest you go look at more monad examples and revise your intuitions of the operators on your own. :) Your lpaste didn't contain any obvious errors, IMO.
02:26:17 <chrisdone> BoR0: does your long statement say much more than: Monad m => m a -> (a -> m b) -> m b?
02:26:30 <BoR0> what long statement?
02:26:47 <chrisdone> box >>= function will pass that something to the function, which then the function will do something to something and return that new something in a new box
02:26:47 <chrisdone> vs
02:26:48 <chrisdone> (>>=) :: Monad m => m a -> (a -> m b) -> m b?
02:27:11 <BoR0> I don't know. all I can understand from looking at that type is what I wrote
02:27:45 <BoR0> m being box, a being something, and m b being a box with new something
02:27:55 <chrisdone> sure
02:28:23 <chrisdone> what the 'something' action is and what form the 'box' takes will depend entirely on the monad instance, of course
02:28:28 <arbn> BoR0: Monads are very abstract. The only "meaning" is the types of the operators, really. Comparisons like that help at first, but once you see more examples, you won't need them.
02:28:30 <shachaf> chrisdone: You're that person who always tries to stretch some container analogy to fit the idea of "monad", no matter how ill-suited, right?
02:28:37 <shachaf> @quote kmc box
02:28:37 <lambdabot> No quotes match. And you call yourself a Rocket Surgeon!
02:28:50 <shachaf> @quote kmc "container"
02:28:51 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
02:28:57 <begriffs> quchen: Ha, I hadn't tried that. Pure zen. :)
02:29:01 <chrisdone> shachaf: you're that guy who says people are that guy because it's easier than saying anything interesting, right?
02:29:14 <Twey> BoR0: What you wrote is absolutely fine
02:29:29 <quchen> Don't fight over Monads please
02:29:54 <shachaf> I meant concretely. I remember there was a person doing that, and I don't remember who it was.
02:29:54 <yobla> exactly ... people might think, Haskell was all about monads otherwise ...
02:29:58 <shachaf> But whatever.
02:30:03 <Twey> BoR0: That's an accurate assessment of the type of (>>=) ☺
02:30:29 <BoR0> I understand from LYAH that box analogy helps at first, but eventually breaks. that's okay. what I wanted to know is, that if we have m (Just x) we can extract x out of it (monadic), and that if we have (Just x) we can extract x out of it too. is this correct?
02:30:56 <merijn_> BoR0: Yes
02:31:07 <Twey> BoR0: Somewhat
02:31:09 <tovarish> m (Just x) ??? why it doesn't look correct?
02:31:13 <dp_wiz> supki: hm.. i've figured how to add items to an inner map: map & ix 42 <>~ singleton 314 False
02:31:13 <dp_wiz> but it doesn't create an empty map if the first key is not-existent...
02:31:28 <tomejaguar> CSV file processing: I know about cassava.  Any other options I should check out?
02:31:29 <BoR0> tovarish, return $ Just 5
02:31:29 <merijn_> BoR0: But m is a type, Just a value, so you're mixing levels
02:31:36 <supki> dp_wiz: you can't insert new elements with  ix
02:31:38 <tomejaguar> Just want something quick and easy.
02:31:41 <merijn_> BoR0: Probably you mean "m (Maybe x)"?
02:31:43 <tovarish> BoR0, it won't be m (Just x)
02:31:45 <BoR0> merijn_, what is m in m (Maybe x) ?
02:31:53 <tovarish> you can have m (maybe t) with t a type
02:32:04 <tovarish> or M (Just x) with x a value and M a type constructor
02:32:07 <merijn_> BoR0: Whichever Monad your "return $ Just 5" example returned in :)
02:32:07 <supki> > M.empty & at 1 ?~ 2
02:32:09 <lambdabot>   fromList [(1,2)]
02:32:18 <supki> > M.empty & ix 1 .~ 2
02:32:19 <lambdabot>   fromList []
02:32:32 <BoR0> ah, okay. my bad in notation. what I meant is m (Maybe x)
02:32:33 <supki> > M.empty & at 1 .~ Just 2
02:32:35 <lambdabot>   fromList [(1,2)]
02:32:47 <merijn_> BoR0: The thing with typeclasses is that *which* "return" is used is decided by the type
02:32:53 <merijn_> > return 5 :: [Int]
02:32:54 <lambdabot>   [5]
02:32:58 <merijn_> > return 5 :: Maybe Int
02:32:58 <supki> dp_wiz: l ?~ x  is the same as  l .~ Just x
02:32:59 <lambdabot>   Just 5
02:33:06 <Twey> BoR0: Maybe is a monad, so ‘m x’ would suffice for your example (though we usually name type variables starting from a)
02:33:09 <merijn_> > return 5 :: Either String Int
02:33:09 <lambdabot>   Right 5
02:33:29 <dp_wiz> > M.empty & at 1 . at 2 ?~ 3
02:33:30 <lambdabot>   Could not deduce (GHC.Num.Num ()) arising from the literal `2'
02:33:30 <lambdabot>  from the co...
02:33:39 <Twey> BoR0: The other thing that's backwards in that statement is that you can't necessarily ‘extract’ something from a monad, i.e. there's no function Monad m ⇒ m a → a
02:34:01 <merijn_> BoR0: Did you read "You Could Have Invented Monads"?
02:34:10 <BoR0> no, only LYAH
02:34:16 <tovarish> Twey, there is always something like that (but not that exactly) otherwise the monad will be useless
02:34:18 <merijn_> @google You Could Have Invented Monads
02:34:18 <Twey> BoR0: What you *can* do is ‘push’ a function into the monad such that if it ever gets called, it will be called with the value ‘inside’ the monad (which is what (>>=) does).
02:34:19 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
02:34:19 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
02:34:26 <bernalex> merijn_: what's that? sounds interesitng
02:34:34 <Twey> tovarish: That's not true
02:34:36 <merijn_> BoR0: That's the only monad tutorial worth reading
02:34:42 <merijn_> bernalex: See last line ;)
02:34:43 <supki> > M.empty & at 1 . non M.empty . at 2 ?~ 3 :: M.Map Int (M.Map Int Int)
02:34:45 <lambdabot>   fromList [(1,fromList [(2,3)])]
02:34:53 <tovarish> Twey, i never see a usefull monad without an exit
02:34:59 <merijn_> All the others are nonsense with burrito's and failed half comprehension
02:35:01 <merijn_> tovarish: IO?
02:35:02 <Twey> tovarish: You've never used IO?  :þ
02:35:02 <bernalex> merijn_: I already sort of groked monads, but I'll read it
02:35:08 <tovarish> merijn_, what is main ?
02:35:15 <bernalex> brian beckman's explanation is reasonably good IMO
02:35:25 <bernalex> https://www.youtube.com/watch?v=ZhuHCtR3xq8 for those who are interested
02:35:26 <dp_wiz> supki: wow much category such lens
02:35:27 <supki> dp_wiz: if you want to create nested Maps take a look at non/anon
02:35:34 <Twey> tovarish: ‘Extract’, Comonad a ⇒ w a → a, is one of the defining functions for comonads
02:35:35 <merijn_> tovarish: A way to run the resulting action, it doesn't escape from the IO monad
02:35:38 <BoR0> the difference between "return $ Just 5" and "Just 5" is that the first is a monadic value (instance of Monad), and the second is only instance of data Maybe?
02:35:39 <Twey> Er, Comonad w
02:35:46 <chrisdone> Twey: haha, dat unicode
02:35:57 <merijn_> BoR0: Maybe is an instance of Monad, the difference is this:
02:36:05 <tovarish> merijn_, sorry i could have thingsa "extracted" from IO with main
02:36:07 <merijn_> > return $ Just 5 :: [Maybe Int]
02:36:08 <lambdabot>   [Just 5]
02:36:09 <tovarish> but I can do it only once
02:36:16 <merijn_> > return $ Just 5 :: Maybe (Maybe Int)
02:36:16 <Twey> tovarish: That's not what's happening
02:36:17 <lambdabot>   Just (Just 5)
02:36:29 <tovarish> i say something LIKE m a -> a not something which is exactly m a -> a
02:36:44 <merijn_> BoR0: Maybe is an instance of Monad, "Monad m => m" says "any monad will work"
02:36:44 <tovarish> Twey, main succeed in excuting my IO and getting the value
02:37:19 <BoR0> I don't understand sorry. :t return $ Just 5 and :t Just 5 are different
02:37:26 <Twey> tovarish: main is just a value; it's not ‘extracted’ anywhere.  The value of main is interpreted by the runtime, to be sure, but there's no ‘extraction’ going on — it doesn't even make sense to ‘extract’ the value from IO, in the same way it doesn't make sense to extract a cake from a recipe book
02:37:37 <merijn_> BoR0: So "(>>=) :: Monad m => m a -> (a -> m b) -> m b" says it'll work for *any* Monad, even if if you don't know yet which one
02:37:40 <tovarish> Twey, as you want
02:38:02 <quchen> @quote shachaf /bin/ls
02:38:02 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
02:38:05 <tovarish> interpreting IO is what I call extracting
02:38:15 <merijn_> BoR0: You can specialise it to work like "Maybe a -> (a -> Maybe b) -> Maybe b" or to lists "[a] -> (a -> [b]) -> [b]"
02:38:16 <Twey> BoR0: But ‘:t return 5 ∷ Maybe Int’ and ‘:t Just 5’ are the same
02:38:32 <merijn_> BoR0: You're right, "return (Just 5)" and "Just 5" are different
02:38:33 <coburrito> BoR0: (return $ Just 5) wraps 5 in *two* monads, basically.
02:38:33 <Twey> (in the case of Maybe, return = Just)
02:38:50 <merijn_> > return 5 :: Maybe Int
02:38:51 <lambdabot>   Just 5
02:39:00 <Twey> tovarish: That's a completely different operation to an eliminator like ‘maybe’
02:39:27 * hackagebot aws-sdk-xml-unordered 0.1.0.1 - The xml parser for aws-sdk  http://hackage.haskell.org/package/aws-sdk-xml-unordered-0.1.0.1 (ShoheiYasutake)
02:39:28 <merijn_> BoR0: There's no reason why a monad cannot contain another monad inside
02:39:34 <merijn_> > return 5 :: [Int]
02:39:35 <lambdabot>   [5]
02:39:44 <tovarish> Twey, yes but it's an exit way, there is always something like that to each monad, there are entry points (other than return) and exit poitns
02:39:45 <merijn_> > return (return 5) :: [[Int]]
02:39:46 <lambdabot>   [[5]]
02:39:48 <coburrito> coburrito: The 'm' means that the outer monad is generic... you didn't define it in GHCi.
02:39:52 <tovarish> that's what made each monad unique
02:39:52 <BoR0> aha, okay. so return $ Just 5 is doubly "wrapped"
02:39:56 <merijn_> BoR0: Yes
02:39:59 <coburrito> BoR0: ^
02:40:01 <BoR0> great! phew
02:40:28 <merijn_> BoR0: Well, another difference is that with "Just" you fix the wrapping monad to be Maybe, while return can wrap *any* monad, including lists
02:40:33 <Twey> tovarish: Not in Haskell :þ  The runtime has a way of executing IO, but there's nothing in the Haskell language (modulo unsafePerformIO and friends) that will let you do that
02:40:37 <merijn_> > return (return 5) :: [[Int]]
02:40:38 <lambdabot>   [[5]]
02:40:42 <BoR0> I see
02:40:44 <merijn_> > return (Just 5) :: [[Int]]
02:40:45 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
02:40:45 <lambdabot>              with actual typ...
02:40:50 <tovarish> Twey, there is the main function which allow me to exit from IO
02:40:51 <merijn_> > return (Just 5) :: [Maybe Int]
02:40:52 <lambdabot>   [Just 5]
02:41:00 <Twey> tovarish: main is just a value, not a function
02:41:06 <tovarish> remove the main function and IO become totally useless
02:41:31 <tovarish> i call it function because i'm used to call main a function, even if it's not a function
02:41:32 <Twey> tovarish: There's nothing special about main as compared to any other IO () value, except that the runtime picks it up and does magical non-Haskell stuff with it
02:41:39 <tdammers> tovarish: the same could be argued about C - remove main(), and your program isn't a program anymore
02:41:47 <quchen> Twey: Is unsafePerformIO even standard? I can't find it in the Report
02:41:55 <merijn_> BoR0: Anyway, reading "You Could Have Invented Monads" may help, I googled the link a while back, or you just google that name and the top link should be the right blog
02:42:04 <merijn_> quchen: It's in Haskell2010, in the FFI
02:42:07 <BoR0> so if we have return x = Just x for Maybe monad, why doesn't return $ Just 5 give Just (Just 5) to us?
02:42:19 <Twey> tovarish: But that doesn't ‘extract’ the () from it (‘const ()’ is an easy way to do that, but doesn't have nearly the same effect)
02:42:20 <merijn_> BoR0: It will, if you ask for it
02:42:29 <merijn_> > return (Just 5) :: Maybe (Maybe Int)
02:42:30 <lambdabot>   Just (Just 5)
02:42:33 <Twey> quchen: Isn't it under the FFI section?
02:42:36 <BoR0> aha
02:42:39 <tovarish> tdammers, exactly, because we're always in a monad (in any language) and in the IO monad, and the main function is always the way to escape it (ie run the program)
02:42:44 <BoR0> but what does it do without specifying :: ... ?
02:42:51 <quchen> Twey: I'm looking but I don't see it. Maybe I'm searching wrong though.
02:42:58 <merijn_> :t return (Just 5)
02:42:59 <lambdabot> (Monad m, Num a) => m (Maybe a)
02:43:17 <merijn_> BoR0: Without the type signature it's polymorphic, it can be any Monad instance
02:43:33 <BoR0> polymorphic! that clarifies it! great
02:43:34 <Twey> quchen: Hm, I can't find it either.  It might well be non-standard.
02:43:45 <tdammers> tovarish: not really. From the Haskell point of view, there is nothing special about main
02:44:01 <tovarish> tdammers, it's the equivalent of IO () -> ()
02:44:02 <tdammers> it's just an IO value, and nothing "escapes"
02:44:04 <quchen> Twey: All I can find are unsafePointer... functions.
02:44:10 <Twey> tovarish: You mean, const ()?
02:44:17 <tdammers> the type of main is IO (), not IO () -> ()
02:44:30 <tdammers> the runtime, however, *does* treat main specially
02:44:31 <merijn_> BoR0: Yes, all typeclasses are polymorphic, unless you specify a type OR type inference sees which type you wanted (actually, this is the only way, the type annotation just explicitly tell the type inference what you want :)
02:44:36 <BoR0> so m in m (Maybe a) is polymorphic. and we can "cast" it to whatever we would want later
02:44:51 <tovarish> tdammers, the main is a code between my compiler and me to say do it, run it, extract the value, each time I run the program
02:45:32 <merijn_> BoR0: Well, not so much cast. But GHC decides which "version" of return you wanted/needed based on the type it infers and until it infers a type, the 'm' is flexible
02:45:39 <tdammers> main is an IO action; it's not special, except that the runtime will look for it and run/evaluate it
02:45:50 <Twey> tovarish: ‘main’ isn't a function that extracts something from IO.  That's not what the type says, and not how it works.  The *runtime* is capable of running an IO program and getting the result, a fundamentally different operation from an ‘extraction’ operation, but that's not a function you can call within Haskell.  main is not that function, but the *argument* to that function, if you prefer to
02:45:52 <Twey> think of it as a function at all.
02:45:53 <merijn_> BoR0: For example, once it infers you meant list you can't cast it to another Monad afterwards
02:46:20 <tdammers> maybe we should clear up how a 'function' in Haskell is not the same as a 'function' in C
02:46:40 <BoR0> I somewhere read that IO String can't be converted to String. but with this discussion I think the opposite, what is wrong now?
02:47:14 <merijn_> BoR0: The discussion here, because some of the participants are using a "bad" definition of conversion/extraction
02:47:28 <tdammers> IO String cannot be converted to String because there is no function of type IO a -> a (barring unsafePerformIO)
02:47:38 <tovarish> Twey, the runtime is capable of running ... >> that's excatly what I'm speaking about, it's the exit of IO
02:47:50 <BoR0> so what held for Maybe monad (extracting x from Just x) doesn't necesarilly hold for IO monad?
02:48:10 <tdammers> tovarish: yes, the runtime is some sort of magic runIO machine
02:48:25 <tdammers> but it is important to understand the *the runtime* is that machine, not main itself
02:48:28 <tovarish> tdammers, thank you for recognizing that there is an exit for the IO
02:48:32 <arbn> BoR0: For Maybe, you weren't really extracting. You were putting the value back into a Just at the end with return. All monadic expressions have a return at the end.
02:48:45 <tovarish> I said main, because it's the convention between the runtime and me
02:48:45 <tdammers> tovarish: again, there is an exit, but it lies outside the realm of Haskell
02:48:46 <merijn_> BoR0: Yes, some *specific* monads may provide tools for extracting values (i.e. Maybe and list, for example). But the generic monad class does not provide a way to do that
02:48:59 <tovarish> tdammers, so there is an exit
02:49:01 <tdammers> yes
02:49:03 <merijn_> BoR0: Since IO doesn't provide a function to extract values, there's no way to get them out
02:49:04 <tdammers> but it is not main
02:49:06 <tovarish> that's all I say since the beginning
02:49:15 <Twey> tovarish: That's not part of Haskell, though, and the operation is fundamentally different an ‘extract the value’ operation like maybe.
02:49:35 <yobla> BoR0: you could say that instead of extracting the value out of the monad, you are putting the function to modifiy it inside the monad
02:49:47 <tovarish> wwhere did i say insiode the haskell world ? where ? i was speaking generally for any usefull monad I encounter in life
02:50:07 <tdammers> the fact that IO is a monad is largely irrelevant in that discussion, really
02:50:08 <BoR0> but from my lpaste return (Just 5) >>= \y -> y >>= \x -> Just $ x+1
02:50:08 <BoR0>  I basically removed the monadic value of it
02:50:15 <Twey> quchen: It seems the '98 FFI Addendum had unsafePerformIO, but not the 2010 FFI specification
02:50:19 <tdammers> IO is a monad because that's convenient, but it wouldn't have to be
02:50:26 <mm_freak_> @quote list of files
02:50:26 <lambdabot> No quotes for this person. I don't think I can be your friend on Facebook anymore.
02:50:37 <quchen> mm_freak_: Quoted it earlier already :-)
02:50:38 <merijn_> BoR0: This blog post is a good explanation of IO (although it's down right now) http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
02:50:42 <mm_freak_> ah =)
02:50:42 <alpounet> @quote ls
02:50:42 <lambdabot> ghc says: falls under the monomorphism restriction
02:50:42 <BoR0> and turned it into just a non-monadic value
02:50:44 <tdammers> we could make a Haskell flavor where the main entry point is a value of a non-monadic type
02:50:50 <alpounet> meh
02:51:02 <tdammers> let's say we have a type Program
02:51:17 <alpounet> that was actually the case at some point
02:51:22 <BoR0> so what merijn_ said makes sense to me, but arbn and yobla said the opposite
02:51:49 <merijn_> BoR0: It's still a "monadic" value, it's just now in a *specific* monad, which means you know more than just "it's a monad"
02:52:08 <merijn_> BoR0: Once you know more than "it's a monad", you can also do *more* than what monads let you do
02:52:13 <mm_freak_> IO is a monad, because history revealed that it's pretty much the least restrictive abstraction for first class actions
02:52:16 <coburrito> BoR0: Just 5 is a monadic value, which is what you end up with in your lpaste.
02:52:24 <mm_freak_> before that we didn't even have first class actions
02:52:35 <BoR0> merijn_, but previously it was m (Maybe a) and now it's just Maybe a. I "removed" 1 "box" instance out of it
02:53:00 <merijn_> BoR0: It's also a type error :)
02:53:16 <merijn_> BoR0: The first >>= requires you "re-add" the box
02:53:34 <mm_freak_> if IO were a GADT you would probably have a constructor like this:  Pass :: IO a -> (a -> IO b) -> IO b
02:53:39 * quchen thinks we should bring "join" into the game here.
02:53:42 <BoR0> I get that, but "return (Just 5)" are two boxes, right?
02:53:47 <merijn_> BoR0: "m a -> (a -> m b) -> m b" <- you're required to end with the same 'm'
02:53:48 <mm_freak_> reason:  you want to be able to use putStrLn on getLine's result in a sensible way =)
02:54:10 <merijn_> BoR0: One exception, is if you have the same monad two times, you can do "join :: Monad m => m (m a) -> m a"
02:54:28 <merijn_> BoR0: join just being "join x = x >>= id"
02:55:17 <merijn_> BoR0: Which works out correctly, if you look at the type of >>=, it becomes "m (m a) -> (m a -> m a) -> m a"
02:55:43 <BoR0> I see. so this is the case if we have same monad applied 2 times?
02:55:51 <merijn_> BoR0: Yes
02:56:01 <merijn_> BoR0: It won't work if you have two diffent ones
02:56:01 <BoR0> so did I implicitly use "join" on my lpaste?
02:56:11 <merijn_> I didn't see the lpaste?
02:56:12 <mm_freak_> BoR0: monads allow you to go from an arbitrary number of applications of M to A to just M A
02:56:31 <mm_freak_> A -> M A, M A -> M A, M (M A) -> M A, M (M (M A)) -> M A, etc.
02:56:34 <BoR0>  (Just 5) >>= \y -> y >>= \x -> Just $ x+1 this gives from m (Maybe a) to (Maybe a)
02:56:39 <BoR0> merijn_, ^ from the lpaste
02:56:50 <coburrito> merijn_: http://lpaste.net/96538
02:57:04 <mm_freak_> that's the categorical view…  not sure if it helps a beginner understand what this is all about
02:57:17 <mm_freak_> better just try reading "IO" as "ProgramWithAResultOfType" =)
02:57:30 <merijn_> BoR0: Yes, that's join iff return gives a Maybe
02:57:35 <merijn_> BoR0: Otherwise it's a type error
02:57:54 <BoR0> my bad, I meant return (Just 5) >>= \y -> y >>= \x -> Just $ x+1
02:58:43 <merijn_> > (return (Just 5) :: Maybe (Maybe Int) >>= \y -> y >>= \x -> Just $ x+1
02:58:44 <lambdabot>   <hint>:1:43: parse error on input `\'
02:58:44 <BoR0> ahhh, I think I can even see the join. id >>= \x -> Just $ x + 1, that's the join part isn't it?
02:58:56 <merijn_> BoR0: Yes
02:58:56 <mm_freak_> return (Just 5) >>= f = f (Just 5)
02:59:15 <merijn_> > (return (Just 5) :: Maybe (Maybe Int)) >>= \y -> y >>= \x -> Just $ x+1
02:59:16 <lambdabot>   Just 6
02:59:28 <merijn_> > (return (Just 5) :: [Maybe Int]) >>= \y -> y >>= \x -> Just $ x+1
02:59:28 <lambdabot>   Couldn't match type `Data.Maybe.Maybe' with `[]'
02:59:29 <lambdabot>  Expected type: [GHC.Types...
02:59:33 <mm_freak_> Just 5 >>= \x -> Just (x + 1) = Just 5 >>= \x -> return (x + 1)
02:59:40 <BoR0> where does join come from? I know that only bind and return are sufficient for Monad
02:59:42 <mm_freak_> Just 5 >>= \x -> return (x + 1) = fmap (\x -> x + 1) (Just 5)
02:59:45 <merijn_> BoR0: See, it only types check if you return into Maybe
02:59:57 <merijn_> BoR0: join is literally "join x = x >>= id"
03:00:09 <merijn_> BoR0: Since >>= works for any Monad, join works for any monad too
03:00:32 <mm_freak_> you can also define fmap, join and return and derive (>>=) from those =)
03:00:34 <coburrito> > return (Just 4)
03:00:35 <lambdabot>   No instance for (GHC.Show.Show (m0 (Data.Maybe.Maybe a0)))
03:00:36 <lambdabot>    arising from ...
03:01:17 <mm_freak_> see the symmetry?  M (M A) -> M A <- A
03:01:17 <BoR0> I can't run out of questions. this conversation helped me a lot, but I'll just try and sort things in my head now. thanks a lot to all of you
03:01:18 <merijn_> BoR0: It's the power of typeclasses and monads, you can use the monad typeclass/interface to implement generic functions (like join) that work on any monad, without knowing what they are
03:01:36 <mm_freak_> join comes from the right (M (M A) -> M A), return comes from the left (M A <- A)
03:01:42 <merijn_> BoR0: The beauty is, if you implement your own monad and make an instance for it, join will automatically work on it!
03:01:47 <merijn_> See also:
03:01:51 <merijn_> @hackage monad-loops
03:01:51 <lambdabot> http://hackage.haskell.org/package/monad-loops
03:02:08 <merijn_> A library full of generic monadic loops, that work with any Monad
03:02:31 <merijn_> Even the ones that haven't been written yet :)
03:03:23 <mm_freak_> that's also one of the reasons why monads make most sense in a language with full (arbitrary-kinded) polymorphism =)
03:03:38 <mm_freak_> monads in C# won't make you as happy as in haskell
03:03:59 <merijn_> mm_freak_: Might be overshooting on the "understandable jargon"-scale, there ;)
03:04:12 <BoR0> mm_freak_, a -> m a, and m a -> m a is fine. but m (m a) -> m a is strange to me. if that is possible, then why isn't m a -> a possible?
03:04:45 <dv-> it is possible
03:04:46 <coburrito> BoR0: You're good. Write some code with monads. The compiler can teach you a lot. :)
03:04:54 <tomejaguar> dv-: ???
03:04:56 <merijn_> BoR0: It recommend taking a piece of paper and the type signature of >>= and playing with it on paper
03:05:08 <dv-> :t fromJust
03:05:09 <lambdabot> Maybe a -> a
03:05:13 <merijn_> dv-: No it's not, please stop trying to confuse someone finally starting to get it
03:05:27 <merijn_> dv-: 1) fromJust is bad 2) it only works on Maybe and we're talking monads in general
03:05:37 <tdammers> m a -> a is not possible in a general way
03:05:51 <mm_freak_> BoR0: monads guarantee a path from anything to M A
03:05:52 <tdammers> many monads, but not all, define a function that does exactly that
03:06:01 <mm_freak_> BoR0: they do not guarantee a path to A
03:06:12 <tdammers> but it's not part of the Monad typeclass, and it's certainly not guaranteed to exist
03:06:18 <tdammers> (or even make any sense)
03:06:43 <tomejaguar> tdammers: They do?  Which standard ones?  I can think of Identity, and Writer.
03:07:02 <tdammers> tomejaguar: the usual runFoobar convention
03:07:03 <coburrito> :t fromMaybe
03:07:03 <lambdabot> a -> Maybe a -> a
03:07:05 <tdammers> mostly
03:07:15 <mm_freak_> BoR0: here is an IO interpretation:  form an action that produces an action (IO (IO A )) you can naturally construct an action that produces an action and runs it right away (IO A)
03:07:16 <merijn_> tomejaguar: Maybe, List, State, Reader, Writer :)
03:07:24 <tdammers> fromMaybe technically qualifies, but it is partial, which means it cheats
03:07:29 <mm_freak_> BoR0: and i mean "natural" in a very deep, categorical sense =)
03:07:37 <merijn_> tomejaguar: Either, tuple, functions... :p
03:07:41 <mm_freak_> ('join' is a so-called "natural transformation")
03:07:50 <tomejaguar> Maybe, List, State, Reader: no, Writer: yes
03:07:57 <merijn_> tdammers: fromJust is partial, fromMaybe is fine
03:08:07 <tdammers> sorry, had them confused
03:08:15 <tdammers> fromMaybe doesn't really fit the bill
03:08:16 <BoR0> (>>=) :: Monad m => m a -> (a -> m b) -> m b. if I set a = m c then m (m c) -> (m c -> m b) -> m b. how can/does the second function extract c from m c?
03:08:19 <tdammers> I meant fromJust
03:08:22 <tdammers> :t fromMaybe
03:08:22 <lambdabot> a -> Maybe a -> a
03:08:34 <coburrito> Not sure why fromJust is mentioned so often, when fromMaybe is 50% less evil. :P
03:08:34 <tomejaguar> Either, functions: no
03:08:42 <mm_freak_> BoR0: it doesn't
03:08:53 <mm_freak_> the function gets passed an 'm c', not a 'c'
03:08:53 <merijn_> coburrito: fromMaybe is 100% less evil
03:08:54 <tomejaguar> coburrito: fromJust is 100% evil and fromMaybe is 0% evil.
03:08:57 <tdammers> of course you can build total Maybe a -> a functions for specific instances of a that do fit the bill
03:09:09 <tdammers> but they are not as general as the desired Maybe a -> a
03:09:12 <tomejaguar> tdammers: ???
03:09:22 <tdammers> well
03:09:23 <tomejaguar> Oh
03:09:26 <merijn_> BoR0: The second function is allowed to use >>= inside
03:09:28 <mm_freak_> BoR0: but the function can apply another (>>=)
03:09:29 <tomejaguar> You mean where a is not a type variable
03:09:31 <BoR0> so basically we won't have X >>= return Y but X >>= Y ?
03:09:36 <merijn_> BoR0: It can do whatever it wants inside :)
03:09:37 <tomejaguar> Well then you are right :)
03:09:45 <tdammers> you could define runMaybe = fromMaybe 0
03:09:58 <tomejaguar> tdammers: Ha!  You could define runMaybe = const 0
03:10:23 <merijn_> BoR0: But the internal >>= will still produce an "m x" as >>= always returns something in the same monad
03:10:40 <tomejaguar> Still, I contend the only usual monads I know with parametric 'm a -> a' are Identity and Writer.
03:11:12 <danilo2> hello dcoutts! Can I ask you a question?
03:11:24 <merijn_> BoR0: Imagine I have "f :: c -> m b" and "x :: m c", now I can implement "m c -> m b"  by doing "x >>= f"
03:12:10 <BoR0> and if you had c -> m b you'd had to do x >>= return f, right?
03:12:12 <merijn_> BoR0: So the function I pass to >>= is "something >>= (\x -> x >>= f)"
03:12:30 <Twey> A fun way to check whether things break if the types you use don't conform to your expectations is to stick a Void in there
03:12:36 <tdammers> tomejaguar: yes, you could, but not without introducing additional constraints on the type a
03:12:37 <Twey> Nobody expects a Void
03:12:42 <merijn_> And now the first >>= would be "m (m c) -> (m c -> m b) -> m b"
03:13:16 <tdammers> either way, you'll end up with either Maybe SomeSpecificType -> SomeSpecificType or SomeTypeclass a => Maybe a -> a
03:13:20 <tomejaguar> tdammers: Agreed, but then that's trivial.  If I introduce constraints on the type 'a' I can give you a function 'IO a -> a'.
03:13:30 <tdammers> yes, correct
03:13:43 <tdammers> that is kind of my point
03:14:09 <tdammers> you can't write a total function of type forall a. Maybe a -> a
03:14:50 <BoR0> aha, I can see it why it's possible now merijn_ thanks for the thorough explanation :)
03:14:51 <tomejaguar> OK I got confused when you said "m a -> a is not possible in a general way.  many monads, but not all, define a function that does exactly that".
03:15:08 <tdammers> yeah
03:15:09 <tomejaguar> It seemed to me you were saying that many monads support "m a -> a" for polymorphic a.
03:15:19 <tdammers> e.g. runIdentity *is* total
03:15:32 <tdammers> and there is absolutely no problem there, for obvious reasons
03:15:38 <tomejaguar> Yes, and 'fst . runWriter' is total.  But I can't think of any others.
03:15:43 <tomejaguar> (That work polymorphicall)
03:16:10 <tdammers> evalState
03:17:04 <tdammers> runReader
03:17:12 <tdammers> well not quite
03:17:17 <tomejaguar> Ah yes, I'm being silly.  For some reason I was thinking that the state argument had to be polymorphic.
03:17:23 <tdammers> :D
03:17:38 <tomejaguar> But for any particular instance 'State MyState' you are fine.
03:17:43 <tdammers> yes
03:17:49 <tomejaguar> OK ignore my nonsense wittering :)
03:18:12 <tdammers> it's actually an interesting discussion for me, never thought about things this way
03:18:23 <tomejaguar> Glad something good came of it :)
03:20:32 <tdammers> come to think of it, it's probably a matter of whether a given monad supports failure in a meaningful way or not
03:20:48 <tdammers> e.g., Maybe fails with Nothing, List fails with [], etc.
03:21:11 <tdammers> but for Identity and State, there aren't really any reasonable failure modes
03:21:56 <tdammers> and the failure case (Nothing, [], Left, etc.) is exactly the thing that makes the m a -> a function partial for those monads
03:22:40 <tomejaguar> In those cases, yes.  For IO you have exceptions as failure, but you also have the fact that it's IO.
03:23:23 <tomejaguar> If I define 'MySpecialNonFailingMonad' that can only be run in IO, then it won't support 'MySpecialNonFailingMonad a -> a' even though it doesn't fail.
03:24:32 * hackagebot http-conduit 2.0.0.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.0.0.1 (MichaelSnoyman)
03:25:33 <tdammers> tomejaguar: converting from one monad to another is a different scenario
03:25:57 <Iceland_jack> unsafeCoerce? :)
03:26:07 <tdammers> :P
03:26:08 <tomejaguar> Argh
03:27:00 <tdammers> unsafePerformIO . runRWST
03:27:05 <tdammers> \o/
03:27:49 <Iceland_jack> It was so simple!
03:37:21 <Maxdamantus> :t let int = (undefined :: Int); double = (undefined :: Double); (a --> b) c = (a `asTypeOf` c) `seq` b in fromIntegral `asTypeOf` (int --> double)
03:37:22 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
03:37:33 <Maxdamantus> Eh. Worked in ghci.
03:37:51 <Twey> You need to brace lets
03:37:54 <Maxdamantus> Ah.
03:38:15 * Maxdamantus wonders if any languages just expect you to do typing like that, rather than by providing another universe of syntax and scopes.
03:38:26 <Maxdamantus> :t let { int = (undefined :: Int); double = (undefined :: Double); (a --> b) c = (a `asTypeOf` c) `seq` b } in fromIntegral `asTypeOf` (int --> double)
03:38:26 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
03:38:49 <ocharles> Anyone know if Ben Foppa/Robot Gymnast is here?
03:41:00 <Twey> That's interesting
03:41:46 <Twey> Maxdamantus: Looks like lambdabot always parses -- as a comment, even where Haskell says it should be part of a token
03:42:03 <Maxdamantus> Ah. Didn't think of that.
03:42:16 <FireFly> You could use ~>
03:42:27 <Maxdamantus> :t let { int = (undefined :: Int); double = (undefined :: Double); (a ~> b) c = (a `asTypeOf` c) `seq` b } in fromIntegral `asTypeOf` (int ~> double)
03:42:28 <lambdabot> Int -> Double
03:43:07 <Twey> Maxdamantus: Agda *kind of* does.  It has a separate syntax for typing definitions, but inline type annotations are just a function.
03:43:24 <Twey> (and types and values share a namespace)
03:43:39 <Maxdamantus> Twey: a function that it needs to apply to use as a type though, presumably?
03:44:12 <Twey> Maxdamantus: I don't understand your question
03:45:08 <Maxdamantus> Twey: (int ~> double) above isn't evaluated: the only thing used is its type.
03:45:28 <Twey> Maxdamantus: There's a function _∋_ : ∀ {a} (A : Set a) → A → A
03:47:13 <Twey> Which is just id, with the type explicitly provided.  So you write (Int → Double) ∋ fromIntegral
03:47:42 <Twey> The type is evaluated, but its argument isn't (during typechecking)
03:47:49 <Twey> Second argument, that is
03:51:57 <int-e> paulschellin: I had no trouble at all installing stateref, but the package does rely on the C preprocessor, which may have its own ideas about things that look like characters and strings.
03:52:34 <Rc43> Hi, guys.
03:53:00 <Rc43> Is there prefix notation for type of list? I mean something like "List a" instead of "[a]".
03:53:06 <Rc43> I need it for code generation.
03:53:21 <Iceland_jack> Rc43: You can define it yourself
03:53:38 <Iceland_jack>     type List a = [a]
03:53:55 <tomejaguar> Rc43: are you sure you wouldn't prefer to use Template Haskell? :)
03:54:04 <Maxdamantus> Can't you just write ([])?
03:54:07 <Iceland_jack> @let type List a = [a]
03:54:07 <Iceland_jack> > [1,2,3,4] :: List Int
03:54:07 <lambdabot>  .L.hs:152:6:
03:54:07 <lambdabot>      Multiple declarations of `List'
03:54:07 <lambdabot>      Declared at: .L.hs:15...
03:54:08 <lambdabot>   [1,2,3,4]
03:54:16 <Maxdamantus> >> [1, 2, 3] :: ([]) Int
03:54:21 <Maxdamantus> > [1, 2, 3] :: ([]) Int
03:54:22 <lambdabot>   [1,2,3]
03:54:22 <merijn_> > [1,2,3,4] :: [] Int
03:54:23 <lambdabot>   [1,2,3,4]
03:54:32 <Maxdamantus> or without the brackets.
03:54:34 <Iceland_jack> Yes, listen to the others instead
03:54:36 * hackagebot servius 1.1.1 - Serve Shakespearean templates via Warp  http://hackage.haskell.org/package/servius-1.1.1 (MichaelSnoyman)
03:54:38 * hackagebot keter 1.1.0.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.1.0.1 (MichaelSnoyman)
03:54:40 * hackagebot wai-handler-webkit 2.0.0 - Turn WAI applications into standalone GUIs using QtWebkit.  http://hackage.haskell.org/package/wai-handler-webkit-2.0.0 (MichaelSnoyman)
03:54:42 * hackagebot wai-handler-devel 2.0.0 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-2.0.0 (MichaelSnoyman)
03:55:05 <Maxdamantus> :t let { int = (undefined :: Int); double = (undefined :: Double); (a ~> b) c = (a `asTypeOf` c) `seq` b } in ([1, 2, 3], [4, 5, 6]) `asTypeOf` ([int], [double])
03:55:05 <lambdabot> ([Int], [Double])
03:55:08 <Maxdamantus> > let { int = (undefined :: Int); double = (undefined :: Double); (a ~> b) c = (a `asTypeOf` c) `seq` b } in ([1, 2, 3], [4, 5, 6]) `asTypeOf` ([int], [double])
03:55:09 <lambdabot>   ([1,2,3],[4.0,5.0,6.0])
03:55:25 <Maxdamantus> \o/
03:55:39 <merijn_> Does Haskell have a proper function for uppercasing text/strings somewhere?
03:55:55 <Rc43> tomejaguar, nothing complex, just setting extraction rules for Coq
03:56:02 <haasn> > let eval = id &&& typeOf in eval $ ([1,2,3], [4,5,6.0])
03:56:04 <lambdabot>   (([1,2,3],[4.0,5.0,6.0]),([Integer],[Double]))
03:56:18 <Rc43> Iceland_jack, yep, I did it temporarily, but want without extra manually written lines
03:56:37 <tomejaguar> merijn_: toUpper?
03:56:43 <Maxdamantus> :t let eval = id &&& typeOf in eval $ ([1,2,3], [4,5,6.0])
03:56:44 <lambdabot> (Fractional t1, Num t, Typeable t, Typeable t1) => (([t], [t1]), TypeRep)
03:56:54 <tomejaguar> merijn_: Or do you mean capitalizing initial letters?
03:56:57 <merijn_> tomejaguar: No, that doesn't deal with ligatures
03:57:11 <Maxdamantus> TypeRep is the inverse of this system.
03:57:13 <haasn> > let eval = id &&& typeOf in eval . eval $ ([1,2,3], [4,5,6.0]) -- Maxdamantus
03:57:13 <lambdabot>   ((([1,2,3],[4.0,5.0,6.0]),([Integer],[Double])),(([Integer],[Double]),TypeR...
03:57:14 <merijn_> The type for toUpper means it by definition can't uppercase unicode properly
03:57:29 <tomejaguar> merijn_: I mean Data.Text.toUpper
03:57:30 <haasn> now just need a pretty showS for it to add the :: notation and stuff :)
03:57:32 <merijn_> oh, looks like I want Data.Text.ICU
03:58:27 <tomejaguar> merijn_: What is it about the type signature that's wrong?
03:58:29 <merijn_> tomejaguar: Oh, that one seems to work too
03:58:53 <merijn_> tomejaguar: "Char -> Char" can't properly uppercase because the uppercase of some single characters is multiple characters
03:58:53 <Rc43> Oh, ye, `([]) Int' just works.
03:58:58 <Lethalman> :t toLowerCase
03:58:59 <lambdabot> Not in scope: `toLowerCase'
03:59:01 <Lethalman> :t toLower
03:59:02 <lambdabot> Char -> Char
03:59:09 <tomejaguar> merijn_: Ha, OK!   How confusing.
03:59:15 <merijn_> tomejaguar: Example: "baﬄe"
03:59:35 <merijn_> tomejaguar: that has an ffl ligature, whose uppercase is FFL (because there are no uppercase ffl ligatures)
03:59:52 <merijn_> Data.Text.toUpper isn't broken though, which is a pleasant surprise
04:00:22 <merijn_> tomejaguar: Unicode is confusing :p Some character's uppercase is locale dependent, for example
04:00:39 <tomejaguar> merijn_: Relevant: http://www.reddit.com/r/haskell/comments/1rlvdu/the_string_type_is_broken_how_do_string_and_text/
04:00:40 <Twey> ß should be uppercased to SS in German, &c.
04:00:44 <Entroacceptor> it uses word16, doesn't that break somewhere, to?
04:00:45 <nlogax> Uppercase ß is SS
04:00:47 <Entroacceptor> *too
04:00:51 <nlogax> Oops, too slow :)
04:00:57 <Twey> Hehe
04:01:02 <Maxdamantus> > toUpper 'ı'
04:01:03 <lambdabot>   'I'
04:01:04 <merijn_> Entroacceptor: Text uses UTF-16, which is fine
04:01:14 <merijn_> Entroacceptor: Things break if you use UCS-2
04:01:24 <Entroacceptor> good to know
04:01:29 <merijn_> Entroacceptor: (which is UTf-16 without properly implementing the variable length codepoints)
04:01:37 <tomejaguar> Twey, nlogax: There was some disagreement about that: http://www.reddit.com/r/haskell/comments/1rlvdu/the_string_type_is_broken_how_do_string_and_text/cdoqenl
04:01:50 <tomejaguar> Personally I don't know what is "supposed" to happen though.
04:01:53 <merijn_> C#, etc. claim to be UTF-16 but are actually UCS-2
04:01:54 <nlogax> tomejaguar: Well, according to Unicode
04:02:08 <tomejaguar> nlogax: Fair enough.
04:02:17 <Maxdamantus> Linux's vfat driver only does UCS-2 -_-
04:02:43 <merijn_> Maxdamantus: Probably because windows filesystems are defined to use UCS-2 names
04:02:46 <Maxdamantus> Was upgrading Rockbox's UCS-2 support to UTF-16 then went to test it and found that Linux didn't so it, so cbf
04:03:01 <Maxdamantus> Ah, are they?
04:03:29 <merijn_> Maxdamantus: Yes, so no need to guess encodings in windows
04:03:34 <merijn_> Same for OSX, I believe
04:03:43 <Twey> tomejaguar: According to the German standards, ß should become SS in uppercase (unless they've had another spelling reform since last I looked)
04:03:48 <Maxdamantus> OS X doesn't use UTF-8?
04:03:59 <merijn_> Maxdamantus: Define "use UTF-8"
04:04:39 <Twey> Maxdamantus: Linux doesn't define a canonical encoding for… anything, really
04:04:48 <tomejaguar> Twey: There seem to be some sort of controversy: http://en.wikipedia.org/wiki/Capital_%C3%9F
04:04:50 <Twey> Oh, right, the vfat driver
04:05:10 <Maxdamantus> typical applications tending to encode (when they need to) to UTF-8 for filenames and have the filesystems (HFS, at least) just store the bytes.
04:05:11 <merijn_> Maxdamantus: unix doesn't define any encoding, everything is just bytes, so you can never know what encoding a filename/etc is.
04:05:32 <Twey> The encoding is whatever the system encoding defines
04:06:01 <merijn_> Maxdamantus: OSX specifies an encoding for filesystem (which really is the only reasonable way to have user specifyable unicode strings as names), I thought it was UTF-16, but not 100% sure
04:06:04 <Twey> tomejaguar: Unlike English, the German government has a standards body dedicated to spelling &c.
04:06:06 <Maxdamantus> Mm .. when you mount using vfat with the default options, it just writes single bytes into the 16-bit fields used for UCS-2 (apparently not UTF-16 now) filenames.
04:06:11 <merijn_> What the rest of the OS uses is irrelevant
04:06:37 <Twey> tomejaguar: And the capital eszett isn't standard (yet)
04:06:44 <tomejaguar> Twey: Sure, but it seems the German government has chosen to require it for some uses and not others.
04:06:53 <tomejaguar> "in 2010 the use of the capital sharp s became mandatory in official documentation when writing geographical names in all-caps"
04:06:54 <Maxdamantus> but there's some "utf8" or something option that interprets those bytes as UTF-8 and encodes them to UCS-2 (and vice versa)
04:07:16 <Twey> Oh, I missed that
04:07:31 <nlogax> geographicalNameToUpper
04:07:33 <Twey> So they have had another spelling reform since last I looked :þ (albeit a rather restricted one)
04:07:38 <Twey> Dammit Germany
04:07:50 <Entroacceptor> so now toUpper ß depends if the word is a geographical location or a name? :)
04:07:55 <tomejaguar> nlogax: :D
04:08:05 <Twey> Entroacceptor: Yes >.<
04:08:28 <Twey> Entroacceptor: Please make your government stop T_T
04:08:43 <FireFly> "straße" → "STRASSE" ?
04:09:07 <FireFly> hm, capital sharp s
04:09:16 <Twey> FireFly: Depends whether it's part of a geographical name or not :þ
04:09:26 <FireFly> >.<
04:09:31 <Entroacceptor> I've even seen Strasze on signs :)
04:09:45 <FireFly> Entroacceptor: wait, not as a ligature?
04:09:52 <Twey> German language standards change faster than Lojban
04:09:55 <FireFly> (which would make it ß of course)
04:11:59 <Entroacceptor> personally I like the ẞ, so it's fine that one standard body (the one for locations) adopted it
04:12:53 <Twey> Entroacceptor: It'd be great if it were unilaterally adopted, but adopting it only for geographical names just makes everyone's lives harder
04:13:25 <Entroacceptor> Twey: nobody will blame anyone if they get it wrong, except if you publish maps
04:13:38 <Twey> Heh
04:14:38 * hackagebot hackage-proxy 0.3.0 - Provide a proxy for Hackage which modifies responses in some way.  http://hackage.haskell.org/package/hackage-proxy-0.3.0 (MichaelSnoyman)
04:14:39 <Entroacceptor> and the governmental rules only really apply to officials, administration, judges, soldiers and students anyway
04:17:55 <Entroacceptor> during the last reform some major newspapers stayed with the old spelling
04:19:16 <nlogax> Apple Maps uses SS http://i.imgur.com/ohL8seGh.jpg , Google takes the easy way out and uses lowercase
04:20:04 <Entroacceptor> what is the reason for uppercasing, anyway..
04:21:33 <Hafydd> Uppercase letters were invented so that classes, types and constructors could be distinguished from other identifiers in Haskell.
04:21:48 <Maxdamantus> That's Gross.
04:21:49 <nlogax> :D
04:22:08 <hpc> they were later repurposed for marking the beginning of sentences, and german nouns
04:22:31 <Twey> Hafydd: Actually, they were invented to clearly distinguish defined symbols from variables, but the Haskell people got confused
04:22:58 <Twey> And fell into the trap of grouping constructors and types, even though constructors are in a different namespace
04:24:39 * hackagebot hexpat 0.20.5 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.20.5 (StephenBlackheath)
04:24:41 * hackagebot yesod-bin 1.2.5.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.5.1 (MichaelSnoyman)
04:25:50 <Maxdamantus> Don't people already group types and type constructors?
04:26:07 <Maxdamantus> Might as well group constructors too.
04:26:54 <Maxdamantus> >> 4 :: Maybe
04:26:55 <Maxdamantus> > 4 :: Maybe
04:26:56 <lambdabot>   Expecting one more argument to `Data.Maybe.Maybe'
04:27:08 <Twey> Maxdamantus: You mean, since types and type constructors are grouped, we should group values and *value* constructors, right?  :þ
04:27:24 <Maxdamantus> Yes.
04:27:25 <Twey> (that's reasonable, anyway: type constructors are just type functions)
04:27:28 <Maxdamantus> > 4 :: Show
04:27:29 <lambdabot>   Expecting one more argument to `GHC.Show.Show'
04:28:06 <Twey> Yeah; the problem with that is that you can't distinguish between variables and constructors in patterns, so you end up with id bar = bar becoming invalid if someone defines a constructor bar
04:28:28 <Twey> (à la Agda)
04:28:31 <hpc> obviously we should number the parameters
04:28:33 <hpc> id 1 = 1
04:28:37 <hpc> what could possibly go wrong?
04:28:58 <fizruk_> hpc, define factorial
04:29:04 <Maxdamantus> const #1 = \##1 -> #1
04:29:12 <hpc> haha
04:29:30 <Twey> Heh
04:29:43 <Twey> Doesn't allow for deconstruction
04:29:46 <hpc> anyway, i like how the current capitalization works
04:29:51 <hpc> caps for constructors, lower for variables
04:30:14 <hpc> which you can extend from data constructor to type constructor and constraint constructor
04:30:25 <Twey> hpc: It's fine in patterns, but gives you types and constructors looking the same
04:31:00 <hpc> Twey: it just needs to be made more clear to new programmers which scope is which
04:31:03 <merijn_> Twey: I like to think of it as "it gives you constructors and constructors looking the same" :)
04:31:06 <hpc> possibly with coloring
04:31:42 <Twey> merijn_: Types aren't constructors :þ  They're even on the same namespace (hence the data Foo = Foo monstrosity)
04:32:09 <merijn_> Twey: You're just implicitly assuming constructors == "value constructor"
04:32:11 <Twey> hpc: You could have all defined values (types, constructors, and definitions) have upper-case and then just lower-case variables, which would provide a clear syntactic distinction between everything
04:32:12 <hpc> type constructors are type constructors
04:32:16 <merijn_> I disagree with that assumption
04:32:29 <hpc> there are types that are not constructors
04:32:29 <Twey> hpc: Or vice versa, which is an established tradition from Prolog
04:32:30 <merijn_> Type constructors are a subset of constructors and so are value constructors
04:32:37 <hpc> there are many types that contain constructors
04:32:42 <hpc> and there are types with no constructors at all
04:33:13 <hpc> and data Foo = Foo adds the name Foo to two namespaces
04:33:17 <hpc> they are not the same
04:33:23 <merijn> The fact that type and data constructors aren't in the same namespace just adds to the clarity
04:33:32 <Twey> merijn_: Then you're also confusing types and type constructors, though I don't really like to think of types and type constructors as being different things (for the same reason I don't like to distinguish values and functions)
04:33:46 <merijn> Twey: How am I confusing types and type constructors?
04:33:46 <Twey> hpc: Exactly… but they look exactly the same
04:34:17 <hpc> Twey: but in different namespaces; that's what should be taught instead of changing the coding style
04:34:27 <hpc> because you need to learn it anyway
04:34:42 * hackagebot hjsmin 0.1.4.4 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.1.4.4 (AlanZimmerman)
04:34:52 <merijn> And because else I need to come up with a type name *and* a constructor name
04:34:59 <merijn> Coming up with one name is enough of a pain as-is
04:35:01 <hpc> even something like (#haskell doesn't do colors so bear with me)
04:35:13 <jg> hi all, could someone help me out with the types in a trivial function? http://pastebin.com/80xWqysp
04:35:14 <mauke> The paste 80xWqysp has been copied to http://lpaste.net/96540
04:35:16 <hpc> data *Maybe* *a* = /Nothing/ | /Just/ *a*
04:35:43 <Twey> merijn: Under your scheme, you justify ‘constructors’ having a different convention, be they type constructors or value constructors… but then simple types also have that convention, whereas simple values don't
04:35:55 <hpc> Twey: type signatures are functions of sort too
04:35:57 <Twey> hpc: I approve
04:36:09 <hpc> id :: a -> a -- this is perfectly valid until some jerk defines data a = ...
04:36:11 <Twey> (maybe just one sigil, though)
04:36:19 <hpc> unless you want explicit foralls everywhere
04:36:24 <nlogax> jg: Add a `deriving Show` at the end of your data declaration
04:36:29 <Twey> hpc: Right, hence the idea of distinguishing between values and variables
04:36:43 <hpc> ...
04:36:46 <hpc> variables are values too
04:36:50 <Twey> You either say Id : a → a or id : A → A
04:36:52 <hpc> you mean constructors and values
04:37:15 <Twey> hpc: No, I mean (free) variables and (defined) values
04:37:24 <Twey> (or constructors)
04:37:26 <jg> nlogax: thanks! I need to read up on this Show thingy (typeclass?)
04:37:42 <hpc> i have no idea what you mean by "defined values"
04:37:43 <merijn> Twey: What is a "simple type"?
04:37:50 <nlogax> jg: Yep
04:37:52 * Maxdamantus thinks he's going to make a language that uses the `asTypeOf` system he thought of for stating types.
04:37:55 <merijn> Twey: Relatedly what is a "simple value"?
04:37:57 <hpc> in any event, it's more useful to distinguish just constructors
04:38:00 <hpc> at both the type and value levels
04:38:09 <Twey> merijn: A ‘concrete type’, as opposed to a constructor expression
04:38:11 <Maxdamantus> but with explicit universal quantification.
04:38:13 <hpc> this would go a lot easier if you get your terminology right
04:38:15 <Twey> ‘Int’ vs. ‘Maybe a’
04:38:42 <merijn> Twey: Int is a type constructor in much the same way as Nothing is a value constructor
04:39:00 <Twey> merijn: I'm not the one who insisted on distinguishing them :þ
04:39:27 <merijn> Twey: I'm not distinguishing, I'm pointing out my logic still applies
04:39:42 <merijn> Twey: I don't see how either Int or "Maybe a" invalidate my previous remarks?
04:39:54 <Hafydd> Either Int (Maybe a)
04:40:37 <merijn> Maybe is a type constructor, hence capitalised, 'a' is a variable, hence lowercase
04:40:40 <Twey> merijn: So you'd have a type-level that consists entirely of ‘type constructors’ (like Int or Maybe) and ‘type variables’ (like a)?
04:40:40 <merijn> Where's the confusion?
04:40:46 <merijn> Twey: Yes
04:41:07 <Twey> I see
04:41:12 <merijn> Twey: constructors -> uppercase, variables -> lowercase. It works that way at both type and value level
04:41:38 <merijn> The notion of "concrete types" is kind of a fairy tale sold to confused beginners which serves to confuse them even more
04:42:22 <Twey> merijn: But there are three types of entity on the value level: value constructors, free variables, and bound variables
04:42:51 <merijn> Twey: Those are on the type level too, think of constraints and explicit forall quantification
04:43:10 <Twey> Hrm
04:43:14 <merijn> It's just that leftmost forall == "free"
04:43:18 <Twey> Yes, I'm convinced
04:43:34 <Maxdamantus> Would you say the type variables are only bound under something like -XScopedTypeVariables or whatever?
04:44:02 <merijn> Maxdamantus: RankNTypes
04:44:20 <merijn> "(forall a . a -> a) -> Foo" <- a is clearly bound there
04:44:43 * hackagebot hamlet 1.1.7.5 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.7.5 (MichaelSnoyman)
04:44:45 * hackagebot shakespeare 1.2.0.3 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.2.0.3 (MichaelSnoyman)
04:44:47 * hackagebot shakespeare-css 1.0.6.5 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.6.5 (MichaelSnoyman)
04:44:49 * hackagebot shakespeare-i18n 1.0.0.5 - A type-based approach to internationalization.  http://hackage.haskell.org/package/shakespeare-i18n-1.0.0.5 (MichaelSnoyman)
04:44:51 * hackagebot shakespeare-text 1.0.0.10 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-1.0.0.10 (MichaelSnoyman)
04:44:56 <merijn> The more I talk to people, the more I believe glossing over "forall" and kinds at the beginning is a mistake
04:46:00 <merijn> That means you can skip this intermediate step with "concrete types", etc. which just seems to confuse beginners
04:46:52 <Twey> I agree
04:46:52 <Maxdamantus> a looks free to me there where it exists.
04:47:15 <Twey> Well, a concrete type is just a type of kind *; it's just terminology
04:47:15 <Maxdamantus> It doesn't exist outside the bracketed bit.
04:47:36 <Twey> Maxdamantus: It's free outside the type function, but inside it's bound (to the parameter)
04:47:38 <merijn> Maxdamantus: Free usually means the environment gets to pick the value of 'a', here the environment is explicitly disallowed from picking 'a'
04:48:01 <donri> Twey: aww but what about my perfectly concrete types of kind Vertex :(
04:48:08 <merijn> Maxdamantus: Because the function requires something that works on any 'a', meaning the function can bind and use whichever 'a' iit likes
04:48:15 <Maxdamantus> merijn: but the outside doesn't see it.
04:48:45 <merijn> Maxdamantus: Well, before we continue this discussion we'll need to settle on a definition of 'free'
04:49:02 <Twey> donri: You can't use them as types; are they really concrete?
04:49:02 <Maxdamantus> if you use -XScopedTypeVariables: id :: forall a. a -> a; id v = let w :: a {- a is bound -}; w = v in w
04:49:28 <merijn> As I said, mine is -> "free -> environment picks value, bound -> local scope has fixed the value to something"
04:49:28 <donri> Twey: ok i guess your point is they can only be used as part of other types?
04:49:37 <Twey> donri: Aye
04:49:38 <donri> fair
04:49:53 <merijn> But you can use non-* kinds as part of other types!
04:49:54 <Twey> donri: A concrete type is something that has a value
04:50:06 <Twey> Ugh
04:50:12 <donri> yeah, like Void
04:50:13 <Twey> donri: A concrete type is something that has 0..n values :þ
04:50:13 <merijn> So if a concrete type is something that can be used, then * can't be concrete
04:50:19 <donri> ok bottom, always with bottom
04:50:27 <merijn> eh, concrete can't be *, etc.
04:50:35 <danilo2> Hello :) Is there in haskell a class which provides a function "empty" ? Like Monoids, but without mappend? I know there is Data.Default - but "default" is not the same as "empty"
04:50:39 <donri> merijn: at the term-level
04:50:47 <Maxdamantus> It seems odd to discuss whether something that doesn't exist is free or bound.
04:50:50 <Twey> donri: There isn't even a concept of having a value of type 3
04:50:57 <merijn> danilo2: Pointed, but it's not in the default libraries and it's usefulness is debatable
04:51:09 <donri> Twey: hah i was just about to use that as an example
04:51:12 <donri> literally
04:51:38 <merijn> Maxdamantus: None of this "exists" :p
04:51:39 <donri> ?? :: (3 :: Nat) no can do mister
04:51:39 <lambdabot>  :: (3 :: Nat) no can do mister
04:51:41 <Maxdamantus> the variable is only used in the construction of another type.
04:51:43 <donri> wat
04:52:00 <donri> 3 :: Sing 3, sure thang sir
04:52:17 <Maxdamantus> The language could provide another construct to represent exactly (forall a. a -> a) (in the RankNTypes meaning)
04:52:28 <Maxdamantus> and there would more clearly be no variable to discuss the freedom of.
04:52:29 <Twey> donri: How about this: ‘a concrete type is a thing T of kind * for which the value “x has type T” is well-defined’
04:52:36 <Twey> s/value/relation/
04:52:38 <merijn> Maxdamantus: "forall a . Eq a => a -> a", then
04:52:47 <merijn> Maxdamantus: Or any arbitrary more complex RankNType
04:53:16 <donri> Twey: sounds good. i vaguely prefer "term" because value invokes connotation of having uh, a concrete value (gah!)
04:53:30 <Maxdamantus> merijn: same thing. Inside, `a' is a variable that is to be substituted.
04:53:47 <merijn> Maxdamantus: Yes, so?
04:53:54 <Maxdamantus> merijn: so inside, it's a free variable.
04:53:59 <merijn> Maxdamantus: Same applies to your SCTV example
04:54:14 <Twey> donri: Except that terms and types are distinguished in type theory (a term is a syntactic expression that has a type)
04:54:17 <merijn> Maxdamantus: bound/free depends on who gets to pick what it can be substituted *with*
04:54:36 <merijn> Twey: That border is vague once you have dependent typing
04:54:48 <merijn> It's Sets all the way down
04:54:52 <Twey> donri: I corrected it to ‘relation’ later, though: the word ‘value’ isn't in the corrected version
04:54:54 <Twey> merijn: Indeed
04:54:57 <Twey> Well, Types
04:54:58 <merijn> Or, well, up in most usual terminology
04:55:03 <donri> Twey: :)
04:55:16 <donri> yeah agda calls 'em Set, misleadingly
04:55:26 <merijn> donri: So does Coq, doesn't it?
04:55:31 <donri> don't know coq
04:55:37 <donri> idris changed it to Type
04:55:38 <Maxdamantus> merijn: in my SCTV example, `a' was already bound in the context I said it was.
04:55:49 <Twey> In general anything from before HoTT calls it ‘Set’
04:56:02 <merijn> donri: In terms of syntax, Coq is to Agda as as Ocaml is to haskell :p
04:56:12 <donri> makes sense
04:56:15 <Twey> Until HoTT there's no point in a distinction
04:56:30 <merijn> donri: Would you say Idriss is at a point where it's worth learning yet?
04:56:42 <merijn> donri: versus, say, learning Agda instead
04:56:44 <donri> Twey: well sets and types are both defined in theory and what we're using in these programming languages are types, no?
04:56:58 <donri> (is there anything that uses set theory for verification?)
04:57:13 <donri> merijn: i haven't looked too closely at either
04:57:19 <donri> merijn: idris has better vim support ;)
04:57:52 <merijn> donri: Ah, so Idris it is ;)
04:58:01 <donri> merijn: https://github.com/idris-hackers/idris-vim
04:58:19 <donri> merijn: in particular http://edwinb.wordpress.com/2013/10/28/interactive-idris-editing-with-vim/
04:59:09 <Twey> donri: Yes, but up to HoTT sets and types are identified: for a term x to have type τ is for the object x to be a member of the set τ
04:59:49 <Twey> donri: HoTT introduces higher inductive types that aren't necessarily sets but still have a well-defined typing relation
04:59:51 <donri> Twey: yes but the inverse isn't implied, is it?
05:00:04 <donri> it's not wrong to say Set, it's just more right to say Type ;)
05:00:40 <Twey> donri: Well, without HITs I think sets directly correspond to types
05:01:15 <Twey> Mind you, that doesn't mean that *set theory* directly corresponds to *type theory*, because there's an implicit logic in set theory that isn't necessarily the one arising from type theory
05:03:04 <donri> i don't know the terminology (or much of the theory for that matter!) but aren't types singular and sets pluralistic?
05:03:27 <donri> a value only has one type which is known, but it can be a member of many sets, not all known
05:03:37 <Twey> donri: No
05:04:06 <Twey> The notion of a ‘principle type’ is a Haskell thing, and even then it goes away with certain extensions
05:04:27 <Twey> (type families, for example)
05:04:34 <donri> hmm I think the HoTT book is where i read this, incidentally
05:04:45 * hackagebot wai-extra 2.0.0.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-2.0.0.1 (MichaelSnoyman)
05:04:47 * hackagebot wai-test 2.0.0.1 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-2.0.0.1 (MichaelSnoyman)
05:04:49 * hackagebot warp 2.0.0.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.0.0.1 (MichaelSnoyman)
05:04:51 * donri only a few pages in, though
05:04:53 <Twey> donri: I suspect you misread :þ
05:07:13 <tomejaguar> IIRC In HoTT a term has exactly one type.
05:07:28 <tomejaguar> But maybe it's an issue of terminology.
05:07:40 <Twey> The term (Int, 3) has both the types Σ (A : Type). A  and the types Σ (A : Type). Int, for example
05:08:10 <Twey> s/and the types/and/
05:09:03 <Twey> But the types are distinct, and not just syntactically: (Bool, true) also has the first type, but not the second
05:09:36 <tomejaguar> Nice example.
05:09:46 * hackagebot uri-conduit 1.1.1.1 - Read and write URIs  http://hackage.haskell.org/package/uri-conduit-1.1.1.1 (MichaelSnoyman)
05:09:48 * hackagebot xml-catalog 1.1.0.1 - Parse XML catalog files  http://hackage.haskell.org/package/xml-catalog-1.1.0.1 (MichaelSnoyman)
05:09:50 * hackagebot xml-conduit 1.1.0.9 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.1.0.9 (MichaelSnoyman)
05:09:52 * hackagebot xml-hamlet 0.4.0.6 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.4.0.6 (MichaelSnoyman)
05:09:54 * hackagebot yesod-core 1.2.6.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.6.1 (MichaelSnoyman)
05:09:57 <tomejaguar> Twey: Is there any such example that does not use dependent types?
05:10:13 <Twey> tomejaguar: That doesn't use dependent types
05:10:32 <donri> sigma is codependent? ;)
05:10:47 <Twey> The argument is a type, so that ‘Σ’ can be just a type function
05:10:54 <Twey> You can write it with type families in Haskell
05:11:04 <Twey> (… I think)
05:12:16 <tomejaguar> Twey: Yeah is there some term that's an element of two distinct types both of which do not use pi or sigma
05:14:39 <Twey> tomejaguar: Sure, all you need is type functions.  You can replace Σ in the example above with the Haskell ∀ (though it's syntactically awkward to show without explicit type application).
05:14:56 * hackagebot yesod-routes 1.2.0.2 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.2.0.2 (MichaelSnoyman)
05:16:22 * Hodapp stares blankly at #haskell
05:16:32 <tomejaguar> Twey: OK, I don't understand dependent types then :S
05:18:39 <Hodapp> I'm fiddling around here trying to make sense of comonads. I suppose dependent types are much lower on my list to make sense of.
05:18:40 <tomejaguar> Twey: So it seems like specialisation is the only form of "subtyping" that's allow.  Does that sound right?
05:19:51 <Twey> tomejaguar: ‘Dependent types’ means that you can have value terms whose types are functions of other values.  So  Σ (n : Int). if n == 0 then Bool else Int  is a dependent type (the type of the second element of the pair depends on the value of the first).  If you replace ‘Int’ with ‘Type’ then you're talking about a type depending on another type, which isn't dependent typing.
05:20:24 <Twey> tomejaguar: It sounds almost right in a way that suggests the reasoning behind it might be very wrong
05:20:31 <tomejaguar> Twey: haha
05:20:55 <tomejaguar> Notice that universal quantification is used as a form of subtyping in lens, for example
05:21:07 <Twey> I don't know lens well yet, sorry
05:21:11 <tomejaguar> I'm wondering if it's explicitly recognised as such somewhere
05:21:40 <Twey> tomejaguar: Subtyping is a different concept entirely
05:22:20 <tomejaguar> Well, 'Functor f => (a -> f b) -> c -> f d' is a lens, and 'Applicative f => (a -> f b) -> c -> f d' is a traversal, thus every lens is somehow a "subtype" of traversal, i.e. you can use a lens anywhere a traversal is expected without a conversion function.
05:23:37 <Twey> tomejaguar: To give a value-level analogue, parametric polymorphism is to say that (\x → x + 1) can evaluate to 2 or 3 depending on whether 1 or 2 is passed in, while subtyping is to say that 3.0 can be implicitly converted to 3
05:23:49 <tomejaguar> Int -> Int is a subtype of a -> a in Haskell, but this "quantification subtyping" is the only subtyping allowed in Haskell.
05:24:00 <Twey> (or vice versa, rather: 3 can be implicitly converted to 3.0)
05:24:18 <tomejaguar> Twey: Yeah but there's a better sort of subtyping: a -> a can be converted to Int -> Int, like I said.
05:24:29 <Twey> tomejaguar: Right, but that's not subtyping at all
05:24:36 <tomejaguar> Ah, that's what I was asking.
05:24:41 <tomejaguar> You're saying that's not called subtyping?
05:24:48 * hackagebot authenticate-oauth 1.4.0.8 - Library to authenticate with OAuth for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.4.0.8 (HiromiIshii)
05:24:59 <Twey> The type ‘a → a’ is actually a type function ‘∀ a. a → a’, i.e. the type is a function of some other type (bound to the parameter a)
05:26:33 <Twey> So you can apply it to the type ‘Int’ and get a type ‘Int → Int’, but you can't arbitrarily replace an already fully-evaluated type like ‘Int’ with a ‘more general’ type like ‘Rational’, which is what subtyping is
05:26:34 <tomejaguar> Hmm, OK so you do not call it subtyping, but a value of type 'a -> a' automatically gets upcast to 'Int -> Int' if I use it in a context that requires it.  Seems like subtyping to me.
05:27:06 <Twey> tomejaguar: It's not upcasting, it's more like function application.  The application is just hidden from you by the Haskell syntax.
05:27:21 <tomejaguar> Well maybe that's what subtype *ought* to be :)
05:27:33 <tomejaguar> s/subtype/subtyping/
05:28:07 <Twey> You can't cast to an arbitrary subtype, but you can pass a value into the type function with the aim of getting out the type you want
05:29:20 <tomejaguar> Well what is subtyping?  I don't know a formal definition.
05:29:35 <tovarish> tomejaguar, it's include from set
05:30:27 <Hodapp> Is that HoTT book pretty accessible for someone like myself who is not too well-versed in type theory?
05:30:48 <Twey> tomejaguar: Subtyping is a relation that says one (concrete, fully-evaluated) type is ‘more general’ than another, and usually a rule in the type system that says that a type can be (implicitly or explicitly) converted to a ‘more general’ type
05:31:12 <Twey> Hodapp: Yes: it spends the first chapter explaining dependent type theory
05:32:22 <Twey> tomejaguar: Subtyping lets you do, for example, the equivalent of ((3 :: Int) :: Rational)
05:33:22 <Twey> I.E. a value that has been decided to have one type can be deliberately upcast to a more general type
05:34:09 <tomejaguar> Twey: Sure, that looks like a type function '(r : Rationalable) -> r -> Rational' to me.
05:34:31 <Twey> That's different from parametric polymorphism in that parametric polymorphism just lets you say ‘the type of this hasn't been decided yet, but you can decide it later based on reference to a different term’
05:34:41 <Twey> But once you decide it, it's fixed
05:34:44 <lemao> is there a way to enforce a single instance of a type class?
05:34:49 * hackagebot iconv 0.4.1.2 - String encoding conversion  http://hackage.haskell.org/package/iconv-0.4.1.2 (DuncanCoutts)
05:34:58 <Twey> lemao: Sounds like you don't want a type class
05:35:29 <Twey> tomejaguar: That's not syntactically correct
05:36:01 <tomejaguar> In Haskell it's not, but in some type theory couldn't you make something of that?
05:36:09 <fizruk_> A is a subtype of B if you "can substitute" value of type A in place where value of type B is expected ?
05:36:53 <Twey> tomejaguar: No: Rationalable there is a type, so r is a value, so you can't pass in something of type r (there is nothing whose type is a value)
05:37:26 <Twey> I suspect you're getting confused with typeclasses, but the translation of a typeclass is actually: (r : Set) → Rationalable r → r → Rational
05:37:27 <tomejaguar> Rationalable could be a kind
05:37:29 <lemao> Twey: I am trying to implement an abstract package (methods in a type class) that can be implemented by other packages (done by different developers). This abstract package A has an FFI export and I would like to dispatch to an instance implemented in another package when the FFI function is called
05:37:49 <lemao> Twey: this is quite common in OO
05:37:52 <Twey> tomejaguar: Try to write it?  =)
05:37:53 <tomejaguar> Twey: I'm thinking that Rationalable be the same sort of thing as Type
05:38:10 <tomejaguar> Twey: Not in Haskell!  In some sort of type theory one could come up with.
05:38:20 <Twey> tomejaguar: You're pretty close to Agda syntax there
05:38:25 <tomejaguar> OK
05:38:41 <fizruk_> in some sort of type theory you can have both parametric and subtype polymorphism
05:39:01 <fizruk_> there are pretty orthogonal afaic
05:39:10 * tomejaguar needs to learn Agda
05:39:19 <Twey> Yes, of course, you can come up with a type theory where true : Bool and true : Int and true : Fish and nobody will bat an eyelid :þ
05:39:51 <fizruk_> Twey, subtyping may be good for records
05:41:13 <Twey> fizruk_: It's complicated :þ  Subtyping itself is good and sound, but it often interacts with other things in ways that aren't well-understood and can produce surprising results and suddenly make your theory inconsistent
05:42:18 <Twey> lemao: But why do you need only one instance of your typeclass?
05:43:58 <jmcarthur_mobile> Subtyping is pretty much guaranteed to interfere with inference in some way, too
05:44:16 <lemao> Twey: It is an unusual scenario, but a real one. Let me step back to give you the why.
05:44:30 <jmcarthur_mobile> Those effects can be limited to where you actually use subtyping though
05:44:56 <jmcarthur_mobile> Many decent type extensions interfere with inference
05:48:39 <Twey> tomejaguar: Oh, better explanation of why your ‘Rationalable’ won't work: only things of type Type_n can have values (i.e. Type is the type of all types).  You can have arbitrary things in Type, like adding Rationalable : Type₁, but you can't generally extend the typing relation to deal with them
05:51:21 <lemao> Twey: There is an existing EXE (c/c++) that dynamically loads a shared lib with a specific API (this is not developed by me). So I want to provide a base Haskell package that implements the expected FFI interface so that anyone can easily implement shared libs for this exe without having to deal with the FFI machinery. i.e. I want to make it very easy to create these shared libs in haskell. Now, the EXE calls a start() function when the shared l
05:51:21 <lemao> ib is loaded and a stop() when the shared lib is unloaded (when the EXE is closing) method.
05:53:15 <lemao> Twey: How to hide the FFI? In OO I would create an abstract base class or an interface that would be called by the FFI and anyone would be able to create a separate package that has a static {} hook to register an impl of this abstract class.
05:54:01 <startling> lemao, I think maybe you're overthinking things.
05:54:31 <lemao> startling: If I am that would be great. Enlighten me.
05:56:30 <lemao> Twey, startling: to me it comes down to the fact that GHC does not provide a similar static {} statement that is present in JAva, for instance.
06:00:30 <lemao> startling: what alternative do you have in mind?
06:00:47 <Twey> lemao: Why can't you just make a function registerHandler ∷ IO () → IO () → IO () that will register the start() and stop() callbacks?
06:01:11 <Twey> I see no benefit from typeclasses here
06:01:56 <Twey> Or even define data LibHandler = LibHandler { startCallback, stopCallback ∷ IO () }; registerHandler ∷ LibHandler → IO ()
06:02:00 <lemao> Twey: when would the impl package call registerHandler? I think the type class is an attempt of mine to work around the fact that there is no 'static { registerHandler this }' in haskell
06:02:31 <startling> lemao, sorry, there's quite a bit more to your conversation than I expected, and I'm running out to work right now.
06:02:44 <lemao> startling: no problem.
06:03:09 <lemao> Twey: remember that there is no main :: IO (). You have the exe loading the shared lib and calling start() then stop() FFI.
06:03:38 <alpounet> well, your static block could be compared to writing a global IORef
06:03:40 <lemao> Twey: start() and stop() is impl in the base package.
06:03:41 <alpounet> or something like that
06:04:07 <BoR0> if I have Just (Just (... Just x)...), can I recursively unpack it until "Just x" ?
06:04:25 <BoR0> like, recursively apply join somehow
06:05:26 <Twey> lemao: It sounds like you're trying to write a plugin
06:05:43 <Twey> lemao: Have you seen the plugins package?
06:05:44 <donri> Twey: It sounds like you're trying to imitate a certain paperclip
06:05:56 <Twey> Hehe
06:06:02 <Twey> ‘Would you like some help with that?’
06:06:17 <danr> BoR0: it has a different type every time. You could do this with typeclass and some extensions houwever
06:07:05 <startling> BoR0, you can't recursively apply join, but you can apply it exactly as many times as you need.
06:07:20 <Twey> lemao: The question ultimately comes down to whether you want to dynamically load the pure-Haskell part as well as the FFI part
06:07:24 <BoR0> okay, thanks :)
06:07:27 <startling> if the amount of times you need it varies, your program might not be well-typed.
06:07:45 <BoR0> I am just curious about how strict the type system really is :)
06:07:46 <startling> but, if you want a convenient shorthand "do what I mean" thing the typeclass hack would work.
06:08:08 <startling> BoR0, well, you could do something like
06:08:34 <startling> BoR0, data Maybe a = Only (Maybe a) | Just a | Nothing
06:08:42 <Twey> lemao: If you don't, it doesn't matter if the pure-Haskell part doesn't compile without the user code: you can just provide some code that references an undefined name and let the user write that name.  If you do, you should write a library that interfaces with the FFI, and have *it* load a plugin using the plugins package to get references to the in the Haskell plugin
06:09:09 <startling> BoR0, and then Only (Only ...) is all the same type.
06:09:23 <BoR0> interesting, and basically I would pattern match against Just x?
06:09:47 <startling> BoR0: yep, but you'd have to take care of the Only case too.
06:10:22 <startling> the thing about the Prelude Maybe is that Just a and Just (Just a) are different types.
06:10:23 <donri> how would you do that with type classes though? overlap?
06:10:55 <startling> donri: I guess you can't, thinking about it more.
06:11:12 <startling> danr had me thinking you could >.>
06:11:17 <danr> maybe you can't
06:11:26 <danr> let me try
06:11:27 <donri> i think you could with overlap, which is evil
06:11:38 <danr> well I did have a disclaimer that you would need extensions!
06:11:57 <donri> quite, i'm just curious if it needs evil extensions ;)
06:11:59 <startling> donri, does that let you have an instance for everything that isn't Maybe?
06:12:05 <donri> yes
06:12:11 <startling> yeah, that makes sense.
06:12:14 <donri> Maybe a is more specific than a
06:12:27 <startling> oh, neat
06:12:34 <donri> neat but evil :)
06:12:51 <startling> I didn't realize there was a (partial?) ordering of types for typeclass resolution.
06:13:07 <donri> there's no ordering, it's about specificity
06:13:20 <donri> if two are equally specific you get ambiguity
06:14:07 <startling> donri, isn't that a partial order?
06:14:27 * donri wonders if it would be possible/useful to have closed type classes with ordered overlap
06:14:36 <donri> startling: maybe :)
06:14:39 <mangaba_leitosa> @pl let (a, b) = (1, 2) in (b, a)
06:14:39 <lambdabot> (line 1, column 5):
06:14:39 <lambdabot> unexpected "("
06:14:39 <lambdabot> expecting "()", natural, identifier or "in"
06:14:49 <mangaba_leitosa> pl doesn't understand 'let ... in' ?
06:14:58 <startling> @pl \(a, b) -> (b, a)
06:14:58 <lambdabot> uncurry (flip (,))
06:15:17 <startling> haha, that's kind of clever
06:15:29 <mangaba_leitosa> startling: yes, but I tried it on a more complex expression with let and found out that it couldn't understand even a simple let
06:15:42 <startling> mangaba_leitosa, you might be right.
06:15:59 <mangaba_leitosa> startling: my expression actually was \(acc, g') list -> let (x, g'') = pick g' list in (x:acc, g'')
06:16:05 <startling> http://hackage.haskell.org/package/pointfree
06:16:29 <donri>  @pl doesn't use a complete parser
06:16:57 <donri> although pointfree depends on HSE... is @pl a separate implementation?
06:17:07 <donri> the error formatting suggests parsec
06:17:19 <startling> I guess it might be.
06:17:22 <mangaba_leitosa> ah, ok, I tried 'pointfree' and it also fails:
06:17:37 <mangaba_leitosa> $ pointfree 'let (a, b) = (1, 2) in (b, a)'
06:17:38 <mangaba_leitosa> pointfree: pointfree: not supported: PatBind
06:17:48 <startling> oh, that makes sense.
06:17:48 <donri> yeah that looks more like HSE :)
06:18:06 <startling> you can't do pattern deconstruction pointlessly in general.
06:18:11 <danr> unwrapping maybes!!! http://lpaste.net/96545
06:18:43 <mangaba_leitosa> startling: ah, ok
06:18:45 <Twey> lemao: But I think the right way to do this is to build a *library* that abstracts the process of interfacing with the FFI
06:18:46 <donri> danr: wait, this works without overlapping?
06:18:55 <danr> it has undecidable instances
06:19:02 <donri> that's not the same
06:19:10 <danr> but yes, no overlap
06:19:24 <Iceland_jack> @pl (\(a, b) -> (b, a))
06:19:24 <lambdabot> uncurry (flip (,))
06:19:25 <startling> UndecidableInstances does that???
06:19:48 <danr> what!
06:19:56 <danr> i could replace UndecidableInstances with FlexibleContexts
06:20:13 <danr> sweet
06:20:36 <startling> that's even more confusing.
06:20:47 <startling> oh, I see.
06:20:47 <Twey> (as much as possible)
06:20:55 <dp_wiz> Is there a reason why lens-aeson refuses to convert numbers without fractional part to Double?
06:20:58 <startling> MultiParamTypeClasses makes it unambiguous.
06:21:15 <startling> if you were to write a instance Unwrap X X it'd be overlapping.
06:21:27 <danr> startling, isn't it?
06:21:37 <startling> danr: hm?
06:21:37 <edwardk> dp_wiz: that'd be part of the internal encoding from aeson
06:21:57 <danr> startling: startling, isn't it?
06:22:25 <startling> danr, isn't what what?
06:22:26 <edwardk> dp_wiz: you can use _Number, but ultimately there is a subtle law issue involved
06:22:54 <dp_wiz> yeah, but _Number gives... aeson Number
06:23:19 <danr> I'm just saying that it is a bit startling that it was possible
06:23:33 <startling> danr: hahahahaha
06:23:35 <dp_wiz> and there's no "floatingValue"...
06:23:36 <donri> \o/
06:24:50 <danr> :)
06:32:35 <lemao> Twey: sorry, was on a call. Yes, I saw the hs-plugins and I am planning to use it in the future. However, I am dealing with a slightly diff problem: a plugin to an external EXE. So there is FFI in the middle here.
06:33:52 <lemao> Twey: humm, I take that back. Maybe the hs-plugins can help me here.
06:35:01 <lemao> Twey: it is just that I don't need 2 layers of dynamic loading of shared libs, just a single one. The hardest part is abstracting out the FFI to expose a clean Haskell API to the implementing packages.
06:36:13 <lemao> Twey: Unless, I link the base package that uses hs-plugins into the EXE and then use a pure HS plugin load.
06:44:00 <Twey> lemao: That's what I'd do
06:44:11 <Twey> If you can modify the executable
06:44:28 <Twey> Otherwise I'd go for the two-layer approach
06:45:30 <lemao> Twey: Yes, let me try that route.
06:47:17 <lemao> Twey: However, aside from what I need, I was expecting an easier time abstracting out the FFI for other packages. I still think something like Java's static {} is missing in haskell modules, since it would have been easy to solve this problem with the registerHandle + static {} to make sure that is hooked up at the right time
06:47:46 <Twey> lemao: That's just global state; you can do that in Haskell too, but obviously it's discouraged
06:49:44 <lemao> Twey: it is global state as much as global variables initialized in main :: IO (). It's just that we don't have a main :: IO () for shared libs.
06:52:41 <Twey> lemao: Not quite.  When you initialize ‘global’ state in main, you're limiting the scope to the functions to which the reference is passed.  Your problem here is that you have no way to pass the reference to the code that will be called.  You can get around this by using unsafePerformIO to give you a top-level IORef, which is strictly equivalent to the Java.  This is horrible, horrible design, though.
06:53:15 <Twey> Maybe justified in that it's FFI, but I would avoid it if at all possible.
06:53:44 <lemao> Twey: what about a std start :: IO () and stop :: IO () (once per shared lib) in the same way that there is a single main :: IO () for haskell exes?
06:54:06 <Twey> lemao: That seems like a much more reasonable proposition
06:54:37 <lemao> Twey: at least I can hide the FFI and say implement these two functions (or one or none) and then call registerHandle and be done with ot
06:54:38 <lemao> it
06:54:39 <Twey> Well, you'd probably want start ∷ IO a and stop ∷ a → IO () so that you could pass state between them
06:54:50 <lemao> Twey: true!
06:55:58 <lemao> Twey: then hs_init() would automatically call start :: IO a and hs_exit() would call stop :: a -> IO a (or start and exit to be consistent)
06:56:39 <lemao> Twey: I meant init and exit :-)
06:56:56 <Twey> I think enter/exit is the appropriate matched pair
06:57:14 <Twey> But yes, that sounds good
06:57:27 <Twey> I don't do much FFI, though, so there may be non-obvious caveats
06:57:46 <lemao> Twey: enter/exit plus explicit support for dynamic libs (.so/.dylib) in cabal would make this quite easy
06:59:12 <lemao> Twey: I don't know much either and stuggled a bit to find pointers to creating these "c" dynamics libs in haskell. It works now, but I don't want have every single one creating one having to understand that.
06:59:36 <lemao> Twey: hence why I am trying to find a good design to abstract this FFI stuff
07:02:09 <lemao> Twey: thanks for the discussion.
07:05:00 * hackagebot HMap 0.91 - Fast heterogeneous maps.  http://hackage.haskell.org/package/HMap-0.91 (AtzeVanDerPloeg)
07:05:02 * hackagebot network-ip 0.2 - Internet Protocol data structures  http://hackage.haskell.org/package/network-ip-0.2 (MikhailVorozhtsov)
07:10:01 * hackagebot HMap 0.912 - Fast heterogeneous maps.  http://hackage.haskell.org/package/HMap-0.912 (AtzeVanDerPloeg)
07:11:41 <maybefbi> how do I use hdevtools with cabal-dev ?
07:14:31 <merijn> Are there any benchmarks of how pipes-binary compares to rolling your own code using pipes-parse or without pipes?
07:15:13 <esoto> anyone knows why some language designers change 'Maybe' to 'Option'? that seems odd
07:15:55 <merijn> esoto: Option predates Maybe
07:16:04 <esoto> oh
07:16:07 <merijn> esoto: Option is what was used in SML, which predates Haskell
07:16:26 <esoto> well why did haskell rename 'Option' to 'Maybe'?
07:16:39 <merijn> esoto: OCaml, F#, etc. are all from the ML school of design
07:17:14 <merijn> esoto: Because it seems the Haskell committee took a design approach of "let's do nothing the way ML does it" :p
07:17:26 <esoto> :P
07:17:49 <merijn> The exact reasoning is probably lost in the mists of time, unless Lennart is here
07:19:27 <geekosaur> don't see him
07:20:15 <merijn> geekosaur: Me neither
07:20:30 <merijn> Then again, I guess it's work day still
07:24:18 <merijn> If I have to support multiple serialisation formats for a data type, is there a better way than having multiple "Get Foo"/"Foo -> Put" functions?
07:24:25 <jonkri> > read "" :: Text
07:24:26 <lambdabot>   Not in scope: type constructor or class `Text'
07:25:02 * hackagebot HMap 1.0.1 - Fast heterogeneous maps.  http://hackage.haskell.org/package/HMap-1.0.1 (AtzeVanDerPloeg)
07:25:30 <Twey> merijn: Define ‘better’.  What's wrong with that?
07:26:45 <merijn> Twey: It becomes rather cumbersome quickly
07:27:16 <merijn> Maybe I just need to restructure my parsing with the new pipes stuff first before worrying about this
07:27:57 <Twey> You could probably pass the desired format around implicitly with a singleton GADT and perhaps a type family
07:28:38 <merijn> Twey: What do you mean by a singleton GADT?
07:33:06 <merijn> Twey: oh, you mean encode the difference in the type with a phantom parameter?
07:33:06 <Twey> Gah, my GHC is too old to play around with it
07:33:09 <Twey> But yes
07:33:27 <merijn> Twey: That won't work for deserialisation, though
07:33:44 <Twey> And then have the SingI instance of the GADT encode the getFoo and putFoo functions
07:33:57 <arseniiv> hello haskellers!
07:33:59 <merijn> Twey: Because it requires you to know which format you're deserialising *before* you start deserialising
07:34:10 <Twey> Ah, right — you don't want to do that
07:36:00 <Twey> Hrm
07:37:45 <merijn> So right now I have a "Get a -> Producer a" thing in pipes and I first have a pipe parse the first bit, then inspect it and pass a different "Get a" to the followup bit later
07:38:14 <Twey> Oh, there are pipes involved
07:38:27 <merijn> And I just feel there should be a nicer way to deal with this
07:39:02 <Twey> I'd probably just parse it with all the deserializers in turn and take the first one that didn't fail
07:39:21 <esoto> what is SML for 'Either'?
07:39:27 <Twey> Not sure how that translates into a pipe
07:39:31 <Twey> esoto: a + b
07:39:36 <Twey> IIRC
07:40:04 * hackagebot BlogLiterately 0.7.0.2 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.0.2 (BrentYorgey)
07:40:21 <merijn> Twey: It's a proper protocol, so there's a version signifier at the start, hence I can deterministically figure out which Get/Put to use after I deal with that
07:42:33 <Twey> merijn: You can't have the first stage of the pipeline produce a pipe?
07:43:00 <merijn> Twey: Well, that's sorta what I was wondering how to do :)
07:43:42 <Twey> Ah — I don't really know enough about pipes to give good advice on that, I think
07:44:09 <merijn> My current implementation predates the the pipes-4 release, so I hand coded everything using Binary, but now that there's pipes-parse/pipes-binary I was thinking maybe those could simplify things, but pipes-binary seems to rely on the Binary typeclass, which I don't have (since I have multiple formats for the same thing)
07:44:52 <mekeor> do you know where i can find that website showing (presentation-like) slides which explain (sum and product types and) zippers?
07:45:05 * hackagebot MFlow 0.3.3 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.3.3 (AlbertoCorona)
07:45:24 <guiraldelli> Hi, all! I'm learning Haskell and I have one (and I'm sure stupid question)... is it here the correct place to ask it?
07:45:40 <merijn> mekeor: I'm guessing you mean Cale's diagrams, but I forgot their current location
07:45:54 <mekeor> merijn: hm. :(
07:45:58 <merijn> guiraldelli: Anything haskell related is on-topic, no matter experience level
07:46:05 <Cale> Wait, I have diagrams for sums and products?
07:46:12 <guiraldelli> Thank you! So goes the question...
07:46:18 <merijn> Cale: The foldr/scanl, etc. things, no?
07:46:30 <Cale> That doesn't sound like what mekeor wants
07:46:33 <byorgey> merijn: that doesn't sound similar to what mekeor is asking for at all.
07:46:40 <merijn> Maybe I need to read better
07:46:43 <merijn> oh
07:46:45 <Cale> http://cale.yi.org/share/Folds.png -- those are here
07:47:01 <mekeor> found it!! http://www.scs.stanford.edu/11au-cs240h/notes/
07:47:02 <guiraldelli> I'm doing a "function composition software" for my purposes in university, and I would like to structure the types.
07:47:22 <guiraldelli> I have a `type Variable = String`
07:47:39 <tomejaguar> Woah those are cool diagrams.
07:47:42 <guiraldelli> And a `data Function = ...` that is a record.
07:48:16 <merijn> guiraldelli: "type Variable = String" probably doesn't do what you want, is your goal to create a "new" type that can't be confused with String?
07:48:23 <guiraldelli> The thing is: I would like to have something like `data Composed = Variable | Function`. How do I do it in Haskell?
07:48:36 <guiraldelli> (Clearly I come from OO world.)
07:49:35 <merijn> guiraldelli: You'd do something like "data Composed = Variable String | Function FuncRecord" where FuncRecord is the old "Function" record type you have
07:49:40 <guiraldelli> In fact, I would like to make the code "easy to read" and using a "type Variable = String" makes sense in the context.
07:50:14 <guiraldelli> Just that?
07:50:25 <guiraldelli> Dammit, so easy.
07:50:27 <byorgey> or you could do   data Composed = ComposedVar Variable | ComposedFun Function
07:50:50 <Cale> guiraldelli: You *need* the data constructors though, there's no getting away without them
07:50:58 <merijn> guiraldelli: That creates a new type (Composed) which introduces a constructor Variable that takes a String and a constructor Function that takes a FuncRecord
07:51:53 <guiraldelli> Cale: hummm.. Makes sense! Thank you so much! :)
07:52:21 <guiraldelli> merijn: Thank you, too! :) Solved part of my problem. Now question 2...
07:52:48 <jinji> does someone use egison?
07:53:31 <Twey> guiraldelli: You can also call FuncRecord Function: constructors live in a different namespace to types (so long as your Function constructor isn't also called Function).
07:53:49 <guiraldelli> If I had to create another level, let's suppose "data Argument = Composed | Expression"...
07:54:08 <guiraldelli> How would I add it, since "Composed" has two constructors?
07:55:03 <guiraldelli> Twey: haven't got the idea? Are you saying that record names can be different from type constructors functions?
07:55:24 <Twey> guiraldelli: The syntax for data declarations is ‘data <type name> = <constructor name> <arg types> | <constructor name> <arg types> | …’
07:56:22 <Twey> guiraldelli: If you want your Argument to be composed of either a ‘composed thing’ that holds an argument of type Composed, and an ‘expression thing’ that holds an argument of type Expression, you can write: data Argument = ComposedThing Composed | ExpressionThing Expression
07:57:02 <guiraldelli> Twey: Dammit! I'm feeling so stupid, now. Thank you very much!
07:57:03 <Twey> Since <type name> and <constructor name> are in different namespaces, it is also valid to write: data Argument = Composed Composed | Expression Expression, unless you have some other constructor called ‘Composed’ or ‘Expression’
07:57:29 <guiraldelli> Twey: just perfect! Thank you so much! :)
07:58:19 <quicksilver> but that then stops you from using them as constructors in the types themselves, unless the types are in a different module...
07:58:28 <guiraldelli> For the current code I have to write today, I think all you have cleared enough my doubts. :) Thank you very much, people! :)
07:58:50 <guiraldelli> And congrats for the friendly approach to the beginners. :)
08:19:23 <CusCo_> Hi, can anyone help me in haskell?
08:19:35 <cschneid> CusCo_: don't ask to ask, just ask :)
08:19:47 <cmtptr> do we have to help IN haskell?
08:20:02 <cmtptr> (I say "we" but I actually don't know anything useful)
08:24:48 <CusCo_> cschneid: I've a function that expects this parameter:  (Show a, Show b, Ord a, Ord b) => (Either b a -> Set [Either b a]) -> Tree (Either b a) -> Bool   But I dont' know what is Tree (Either b a)
08:25:22 <tomejaguar> CusCo_:
08:25:26 <tomejaguar> what is Tree?
08:25:52 <tomejaguar> Or are you stuck even there?
08:25:53 <CusCo_> tomejaguar: ata (Eq a, Show a) => Tree a = Void | Node a [Tree a] deriving (Eq, Show)
08:25:59 <CusCo_> tomejaguar: data (Eq a, Show a) => Tree a = Void | Node a [Tree a] deriving (Eq, Show)
08:26:26 <tomejaguar> OK, so 'Either a b' is a datatype whose values are either a value of 'a' or a value of 'b'
08:26:42 <tomejaguar> So 'Tree (Either a b)' is your tree datatype where the nodes have the type 'Either a b'.
08:26:50 <tomejaguar> Do you understand what 'Tree Int' is, for example?
08:27:20 <Eduard_Munteanu> Is there a connection between Free, Cont and existentials in CPS form (type Exists f = forall r. (forall a. f a -> r) -> r) ?
08:28:24 <Eduard_Munteanu> :t callCC
08:28:25 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
08:29:16 <danr> CusCo_: You're using "stupid theta": https://ghc.haskell.org/trac/haskell-prime/wiki/NoDatatypeContexts
08:30:48 <Eduard_Munteanu> CusCo_: why are you using those contexts?
08:31:22 <Eduard_Munteanu> In there rarer case that you need one to derive stuff, use StandaloneDeriving, but here it doesn't seem to be the case.
08:31:27 <tomejaguar> CusCo_'s code: http://lpaste.net/5191787150651162624
08:31:50 <tomejaguar> CusCo_: What's the question about the code?
08:32:52 <CusCo_> tomejaguar: can you give me an input example for the function iscorrect?
08:34:21 <Cale> Node (Right 5) [Void, Node (Left "hello") [], Node (Right 9) [Void, Void]]
08:34:34 <Cale> Is a value of type  Tree (Either String Integer)
08:35:53 <tomejaguar> iscorrect :: (Ord t1, Ord t, Show t1, Show t) => (Either t t1 -> Set.Set [Either t t1]) -> Tree (Either t t1) -> Bool
08:35:55 <Cale> CusCo_: Did you write this code in the first place?
08:36:01 <tomejaguar> CusCo_: ^^ GHCi will tell you that
08:36:41 <Cale> Or is it from somewhere else?
08:37:31 <CusCo_> tomejaguar: yes, i know, but i don't have a pratce with Either, can you give me an input example that return me a Bollean?
08:37:59 <tomejaguar> Oh I see.  You want some arguments.
08:38:09 <Cale> I'm very confused about the intended purpose of this code
08:38:29 <CusCo_> Cale: sorry for my english...
08:39:10 <Cale> CusCo_: It's okay, I'm just curious what this program is supposed to do
08:39:32 <tomejaguar> eitherTree :: Tree (Either Int String)
08:39:33 <tomejaguar> eitherTree = Node (Left 1) [Node (Left 2) [], Node (Right "Hello") [], Void]
08:39:47 <tomejaguar> ^^ There's a value of type Tree (Either Int String)
08:40:28 <CusCo_> Cale: you give it a grammar and a tree, and you have to control that the grammar is in the treee (sorry for my english)
08:41:10 <Cale> CusCo_: So it's like some kind of puzzle from somewhere?
08:44:23 <CusCo_> Cale: do you know what is context-free grammar?
08:44:42 <CusCo_> #haskell.it
08:44:59 <Cale> yes, I do
08:45:03 <CusCo_> join #haskell.it
08:46:08 <CusCo_> tomejaguar: thank you
08:47:15 <Cale> ghci> iscorrect f Void
08:47:19 <Cale> True
08:47:27 <Cale> ghci> iscorrect f (Node (Right 'p') [])
08:47:27 <Cale> True
08:48:05 <CusCo_> Cale: thak youuuuuuuuuu....you are a Genius!!!
08:48:10 <Cale> Many inputs will cause non-exhaustive pattern errors, because f is incomplete
08:48:36 <Cale> I haven't yet found an input which actually results in False
08:48:53 <Cale> (only errors and True)
08:49:26 <Cale> ghci> :t iscorrect f
08:49:27 <Cale> iscorrect f :: Tree (Either Char Char) -> Bool
08:49:36 <Cale> ^^ you can determine the correct type of input like that
08:50:05 <CusCo_> Cale: thank you!!!!! <3
08:50:42 <Cale> I think this program is completely broken
08:51:10 <Cale> I sort of get what it looks like it's trying to do
08:51:25 <CusCo_> Cale: why?
08:51:37 <Cale> Well, look at my second input there
08:51:46 <Cale> 'p' isn't mentioned in the grammar at all
08:52:11 <Flonk> Ugh, TemplateHaskell is weird. TupE turns a List into a Tuple Expression, is there something that can do the reverse?
08:52:28 <Cale> Flonk: Why would you need one?
08:52:55 <CusCo_> Cale: for you, what can i do?
08:53:26 <Flonk_> I should get a proper irc client.
08:53:32 <Cale> CusCo_: iscorrect f (Node (Right 'p') []) -- why is this correct?
08:53:39 <Flonk_> Cale: I want to somehow determine the length of a tuple
08:54:04 <tomejaguar> Flonk_: don't you just want to quote the tuple?
08:54:05 <Cale> CusCo_: If you look at the given 'f', the grammar that it suggests doesn't involve 'p' at all
08:54:13 <CusCo_> Cale: I don't know...can you help me to modify the code?
08:55:15 <Flonk_> tomejaguar: I want to do some relational database stuff, and it feels like the length of a tuple would be a nice thing to know
08:55:33 <Cale> CusCo_: I don't know enough about what it's actually trying to do, apart from something involving the grammar and the tree. If it's meant to check that every one of the paths through the tree from the root to a leaf is matched by the grammar, then it's failing in that.
08:56:06 <Flonk_> tomejaguar: What do you mean by quoting a tuple? ''tuple?
08:56:06 <Cale> Flonk_: You know the length of a tuple statically by looking at it
08:56:41 <Cale> Flonk_: Tuples of different lengths have completely separate types, so there's no way you can be confused about what the length of a tuple is at runtime.
08:57:31 <Cale> Like, you could write functions:
08:57:41 <Flonk> Cale: Yep, I know that.. I just want to derive some nice setter and getter functions for tuples of different length
08:58:26 <Cale> So, probably the length of tuple you're generating code for is a parameter to your Template Haskell code.
08:59:13 <Flonk> Cale: yep!
08:59:23 <Cale> (at least, that would seem the sensible way to go about it from my point of view)
09:00:00 <tomejaguar> Flonk: can you be more precise about what you're trying to do exactly?
09:00:12 <Cale> So, if you want to generate the syntax for a tuple of that length, you can use tupE with an appropriately-sized list according to that parameter.
09:00:45 <CusCo_> Cale: I have a grammar, for example: V->cAs|VA    A->V|{}  and you give it for example: cs the program have to return True
09:01:39 <Cale> CusCo_: okay, that sounds reasonable, but then, why is the second parameter to iscorrect a tree rather than a String?
09:02:42 <CusCo_> Cale: f  is our grammar and tree is an invented grammar
09:03:11 <Cale> I'm not sure what you mean by invented grammar
09:04:13 <Flonk> tomejaguar: nevermind, I think I just figured out why what I was trying to do makes no sense at all
09:05:14 <Cale> Flonk: Just given the general sound of what you're trying to accomplish, you might be interested in some of the things that lenses can do
09:05:49 <CusCo_> Cale: sorry...it is a Tree and not a String because we have to verify if the Tree is correct Tree of the grammar in F
09:06:07 <Cale> CusCo_: hmm
09:07:05 <Cale> > view _2 (1,"hello",3,[4,5],"apple")
09:07:06 <lambdabot>   "hello"
09:07:44 <Flonk> Cale: I've read quite a few things about them, and they seem really useful, yeah
09:07:46 <Cale> > over _2 reverse (1,"hello",3,[4,5],"apple")
09:07:48 <lambdabot>   (1,"olleh",3,[4,5],"apple")
09:08:02 <Cale> > set _2 "pear" (1,"hello",3,[4,5],"apple")
09:08:03 <lambdabot>   (1,"pear",3,[4,5],"apple")
09:08:24 <Cale> This _2 lens is polymorphic, and there are instances for many sizes of tuple
09:08:28 <Cale> :t _2
09:08:29 <lambdabot> (Functor f, Field2 s t a b, Indexable Int p) => p a (f b) -> s -> f t
09:09:04 <Cale> (and there are analogous ones up to _9)
09:09:06 <Flonk> Cale: It's type is pretty cryptic, but I think I understand
09:09:20 <Cale> You probably don't *actually* want to use the bigger ones anyway
09:09:43 <Cale> Anything involving larger tuples is a strong sign that you should be defining a new data type
09:10:09 <Cale> Yeah, the type is kind of crazy :)
09:10:10 <CusCo_> Cale: how can i modify my code?
09:11:04 <Cale> CusCo_: I can't really say, I'd have to know what it means precisely for a tree to be a tree of the grammar here.
09:13:39 <Cale> CusCo_: Is the empty tree always a tree of any grammar?
09:13:53 <Cale> CusCo_: It seems like that's implied by this code.
09:14:07 <CusCo_> Cale: yes
09:14:25 <Cale> So it's not a parse tree
09:14:30 <Cale> I don't really know what this means :)
09:22:06 <newsham_> fyi http://arxiv.org/abs/1208.0954
09:23:47 <ij> Did you find that from hackernews?
09:24:46 <newsham_> no, from irc
09:25:50 <ij> There was an extensive discussion about this there, so I just wondering.
09:26:30 <tomejaguar> Seems highly implausible.
09:26:55 <newsham_> indeed, thats why I mention it
09:27:26 <ij> tomejaguar, ha
09:35:18 * hackagebot nanomsg-haskell 0.2.0 - Bindings to the nanomsg library  http://hackage.haskell.org/package/nanomsg-haskell-0.2.0 (IvarNymoen)
09:54:24 <Eduard_Munteanu> Is there no usable automatic reindentation command for haskell-mode in Emacs?
09:55:18 <Eduard_Munteanu> I'd like to reindent some record updates.
10:00:49 <Kinnison> Eduard_Munteanu: mark the region and do M-x indent-region
10:02:09 <Eduard_Munteanu> Kinnison: hm, if I do that it justs yanks the first two lines rightwards and gives me a "Parse error" in the echo area.
10:02:21 <Eduard_Munteanu> That is, even for toplevel declarations.
10:02:51 * Kinnison just managed to make it work to reindent a list, but perhaps that's too simplistic
10:02:56 <Eduard_Munteanu> It also seems to convert everything to lowercase.
10:02:57 * Kinnison has no other suggestions, sorry
10:03:00 <levi> It might depend on which indent mode you're using?
10:03:19 <Eduard_Munteanu> levi: hm, maybe... I use the "smartest", haskell-indentation-mode
10:03:30 <levi> That's what happens in hi2 indentation mode anyway, so it might not work on any of them.
10:03:55 <levi> I'm not sure any of them are smart enough to re-indent like that, unfortunately.
10:04:45 <xfce-x64> is it possible to do web programming with haskell ?? it is easy to learn .. I am a newbie
10:04:56 <levi> xfce-x64: Yes, and... it depends?
10:04:58 <Eduard_Munteanu> It also insists on moving me to the previous line when I try to trim the spaces to the left with backspace.
10:05:18 <levi> Eduard_Munteanu: That's one of the things hi2 fixes, IIRC.
10:05:37 <levi> Eduard_Munteanu: It's not shipped with haskell-mode yet, though, you have to get it separately.
10:05:38 <Eduard_Munteanu> xfce-x64: there are a few choices there, some involve more magic, some less.
10:06:30 <intrados> Is there some reason for ghc not to compile these to the same thing: http://lpaste.net/96549 ?
10:06:51 <dmwit_> I am trying to use cabal test and the detailed-0.9 interface. I've got a Group of tests that advertises concurrently=True, but still only seem to be using one core.
10:06:57 <dmwit_> Why?
10:07:01 <xfce-x64> most magicial option ? Eduard_Munteanu for web dev in haskell
10:07:34 <dcoutts> dmwit: that says it's safe to run concurrently, it's not a demand.
10:07:35 <levi> xfce-x64: If things go well, I think a newbie could get some things going quickly with Yesod, Happstack, or Snap. On the other hand, they've got some complexity under the hood that might get you stuck if things take a wrong turn at some point.
10:07:42 <dcoutts> whether it does or not depends on the test runner
10:07:48 <Eduard_Munteanu> xfce-x64: by magic I mean more complex... I think Yesod is a good representative of that.
10:07:51 <Hodapp> xfce-x64: what brought you to Haskell?
10:07:53 * Kinnison feels that happstack was easiest to get something real going in
10:08:12 <dmwit> dcoutts: Okay. Can I ask the test runner to run them concurrently?
10:08:12 <dcoutts> dmwit: it's really for the case when you have some tests where it's not safe to run them concurrently, to ask test runners not to.
10:08:21 <levi> Happstack currently has a bunch of really nice walkthrough documentation.
10:08:23 <c_wraith> intrados: are you compiling with optimizations on?
10:08:27 <dcoutts> dmwit: that depends on the test runner you use
10:08:41 <dmwit> dcoutts: I just type "cabal test"; which runner does that use?
10:09:00 <dcoutts> dmwit: oh some simple builtin one that probably does not do anything clever
10:09:08 <Eduard_Munteanu> Argh, haskell-mode doesn't seem to work at all for record updates.
10:09:22 <dmwit> =(
10:09:33 <dcoutts> dmwit: this stuff has yet to be properly integrated with test framework / tasty
10:09:39 <dmwit> Okay. Where do I look for more sophisticated runners, then?
10:09:41 <intrados> c_wraith: -O2
10:09:42 <xfce-x64> Hodapp, I know a senior programmer of FreeBSD .. he said start with haskell .. if you can't then sorry quit programming and learn Javascript or some cool recent n modern implementation of same
10:10:31 <levi> xfce-x64: http://happstack.com/docs/crashcourse/index.html
10:10:52 <bennofs> How do you call a datastructure that contains IORefs, TVars, etc and is part of a ReaderT and is setup when you run the monad?
10:10:59 <levi> xfce-x64: Also, http://learnyouahaskell.com/ for basic language learning.
10:11:03 <dmwit> dcoutts: I'm checking out tasty now. Thanks for the clarification.
10:11:11 <Hodapp> xfce-x64: If he told you to quit programming because you couldn't learn one particular language, you should probably go punch him in the balls.
10:11:19 <Eduard_Munteanu> bennofs: Env, Context, Configuration...
10:11:36 <Eduard_Munteanu> (Config, shorter)
10:11:47 <bennofs> I just thought that having a Config data type and a Settings data type might be confusing ...
10:12:02 <levi> xfce-x64: On the other hand, you certainly can learn Haskell if you want to. It's not *that* hard, and you could have an advantage if you aren't already familiar with other languages.
10:12:08 <c_wraith> intrados: oh, I see.  The difference is that GHC doesn't supercompile.  As such, it doesn't realize that mconcat [[3], [2], [1]] is the same as [3] <> [2] <> [1]
10:12:30 <c_wraith> intrados: it would have to run the mconcat at compile-time to see that those expressions are the same
10:12:42 <xfce-x64> levi, thanks a lot :P
10:12:52 <xfce-x64> levi, did you do any web dev with haskell yet?
10:12:52 <c_wraith> intrados: because mconcat is recursive, it can't just inline it away.
10:13:00 <levi> xfce-x64: It's a very *deep* language, but the basics are very easy to pick up.
10:13:39 <levi> xfce-x64: I haven't done any serious web dev, but I have written some minor programs in happstack, yesod, and snap.
10:14:02 <Hodapp> c_wraith: "supercompile"?
10:14:09 <xfce-x64> ok .. do i have to learn all three ?? or just happstack is fine for small programs ?
10:14:17 <Eduard_Munteanu> Heh, no
10:14:40 <levi> xfce-x64: Any of them are fine, you can just pick one to start with.
10:14:42 <intrados> c_wraith: Ah, that makes sense. Thanks
10:14:59 <c_wraith> Hodapp: supercompilation is more or less evaluating as much of a program at compile-time as possible, reducing it to the minimal amount of runtime work.
10:15:49 <bennofs> Is there a STM "lock" type?
10:15:52 <c_wraith> Hodapp: for instance, any pure function applied to constant arguments could be calculated at compile-time.  And lots of more subtle things, too
10:15:54 <levi> xfce-x64: I think happstack is a good one to start with, especially if you use happstack-lite
10:16:19 <Eduard_Munteanu> bennofs: you can use (T)MVars if you want locking.
10:16:33 <xfce-x64> levi, ok .. i get it .. thanks but i want to know if I want to host them on my own webserver .. what all would i need ?
10:16:34 <bennofs> Maybe I just want a TVar Bool
10:16:41 <intrados> c_wraith: Is supercompiling not done because it's hard? Or are there other tradeoffs?
10:16:48 <Hodapp> c_wraith: What compilers actually do this?
10:16:58 <Eduard_Munteanu> bennofs: MVar () is more common
10:17:46 <bennofs> Eduard_Munteanu: ah, thanks!
10:18:07 <c_wraith> intrados, Hodapp: There have been some experimental versions of GHC that do supercompilation, actually.  Supero is the name of one of them.  It ends up taking forever, and often generating huge executables.  There are clearly tradeoffs involved
10:18:23 <Eduard_Munteanu> bennofs: and you can probably write a bracket-like helper to wrap critical section in.
10:18:28 <simpson> intrados, Hodapp : The general term for this sort of work is *partial evaluation*. It is, to put it politely, a hard problem.
10:18:54 <levi> xfce-x64: Mostly you just copy the binary and some other files to your server and run them there.  It's easiest at first to just build and run the programs in the same place, but deployment isn't super hard or anything as long as you can run programs on the server.
10:20:05 <quchen> You can use TH to supercompile things if you really need it.
10:20:16 <christianpbrink> Anyone have a sense of how soon GHC 7.8 is going to be released?
10:20:53 <quchen> christianpbrink: As far as I know it'll still be this year.
10:20:57 <c_wraith> it seems like it should be soon.
10:21:19 <Hodapp> quchen: TH?
10:21:25 <c_wraith> But there's not much left of "this year" to do it in, especially since the last two weeks of december are basically dead.
10:21:25 <Hodapp> oh, Template Haskell
10:22:48 <christianpbrink> Pretty noobish question but… is it possible to start using a pre-release version of 7.8 right now?  I want to start using GHCJS but don't want to muck around with what has been described to me as a complicated install process, pre-7.8.
10:23:06 <bennofs> Can I hide a constructor without hiding the datatype in an import hiding statement?
10:23:21 * Guest90631 sory net broke
10:23:28 <dcoutts> christianpbrink: in principle yes, in practice it's a bit tricky. I'd suggest waiting for an RC
10:23:51 <quchen> Hodapp: Yep, à la https://github.com/quchen/articles/blob/master/useful_techniques.md#poor-mans-supercompiler
10:24:01 <christianpbrink> ok thanks dcoutts
10:35:26 * hackagebot errors 1.4.4 - Simplified error-handling  http://hackage.haskell.org/package/errors-1.4.4 (GabrielGonzalez)
10:44:35 <skypers> hey guys
10:44:43 <skypers> what do you think of that snippet in terms of FRP:
10:44:47 <skypers> http://lpaste.net/96551
10:47:50 <skypers> I think I can add side-effect FRP with IORef
10:47:54 <skypers> what do you think?
10:58:43 <jle`> is there an adjective-ish version of Functor?
10:58:51 <jle`> like Monad has monadic
10:59:01 <alpounet> functorial
10:59:03 <alpounet> i guess
10:59:08 <jle`> heh.
10:59:29 <jle`> like monadic __.  i was going to say functor-based __.
11:00:07 <alpounet> jle`: i've heard it used in pure math courses
11:00:46 <alpounet> it's most likely widely spread there, but we don't see it often in haskell writings indeed
11:01:59 <zol> When implementing a string alignment algorithm, how should you deal with the construction of optimal alignments? I have figured out how to calculate the longest common subsequence/scoring of an alignment, but not sure how you should construct the
11:02:01 <zol> damnit
11:02:06 <zol> mistype!
11:03:06 <zol> I find it impossible to test recursive functions as you write them, how do you go about it? I feel like I can't test it until it is done already.
11:04:46 <jle`> zol: when possible, avoid explicit recursion
11:04:58 <jle`> zol: when not possible, the best way to test is to refactor out parts of your function into smaller functions and test those
11:05:29 <jle`> alpounet: thanks, i'll keep that in mind
11:05:53 <zol> jle`: Hard to do that when the whole function depends on itself! Also, homework demands recursion. -_-
11:06:00 <zol> jle`: Thanks
11:06:09 <georges_> how many spaces do you use for identation?
11:06:21 <jle`> usually when you are writing an explicitly recursive function we are actually using a higher-order design pattern/model
11:06:32 <jle`> very rarely will you run into a recursive case that isn't some higher-order thing
11:06:41 <jle`> ah i see
11:06:50 <georges_> indentation*
11:07:02 <quchen> I use 6.
11:07:07 <bennofs> 2
11:07:19 <jle`> georges_: i use 4 myself
11:07:43 <jle`> zol: care to post it on lpaste?
11:09:11 <georges_> three answers, all different :)
11:09:18 <georges_> i take it there are no guidelines on this
11:09:46 <nadirs> Hi. georges, are you talking about Haskell code indendation?
11:09:53 <nadirs> *indentation
11:10:03 <georges_> yes
11:10:07 <georges_> hello
11:10:18 <haasn> georges_: 2
11:10:38 <nadirs> I use 4 in any language I write in.
11:10:57 <zol> jle`: sure, but it is quite complex and I don't want to bother anyone -- could be that I just don't understand my homework well enough... http://lpaste.net/7127916067900358656
11:11:09 <frxx> I use 4 in all languages but haskell, where I use 2
11:11:23 <zol> jle`: So it is optAlignment that I am trying to complete, furthest down in the paste
11:11:34 <jle`> i use 4 in most except for ruby where 2 seems to be super-standard for some reason
11:12:02 <jle`> zol: alas something has come up and i have to go, my apologies, don't want to keep you waiting for noting.  but someone here might be able to help you
11:12:11 <nadirs> zol: which is, if I think about it, curious, considering how much more concise Haskell tends to be, compared to other (e.g. C-like) languages
11:12:31 <zol> jle`: np, thanks :)
11:12:37 <nadirs> *(I meant frxx, sorry zol I always mistake quotes :P)
11:13:00 <jle`> i also use tabs in C/C++ for some reason.
11:13:08 <jle`> i find that it helps me shift my mental state
11:13:26 <jle`> so i don't accidentally end up writing the wrong code or thinking the wrong way in the wrong language
11:13:44 <nadirs> jle`: might it be because of Linux source code conventions?
11:14:05 <georges_> what about tabs vs spaces?  since they matter for syntax should i have any preference
11:14:24 <quchen> Haskell: spaces. Or people will get angry.
11:14:28 <Taneb> georges_, for Haskell, go for spaces
11:14:48 <nadirs> georges: I've grown some sort of dislike against tabs
11:14:52 <jle`> don't use tabs ever
11:14:56 <jle`> :)
11:15:10 <jle`> nadirs: yes that too.
11:15:27 <christianpbrink> When ghc 7.8 is ready for release… what's the process like?  I.e. is it announced x days in advance, or does it just appear on the downloads page one day and bam it's ready to go?
11:15:36 <jle`> tabs are always a Bad Idea(tm) i feel.  the only reason to use them is to conform
11:15:53 <quchen> christianpbrink: So the release date is somewhere around September 2013.
11:16:01 <nadirs> jle`: +1 for conforming
11:16:02 <quchen> It then gets pushed back periodically.
11:16:04 <Hodapp> You have a really wide spacebar, and a very narrow Tab key. This means that spaces are more important than tabs. If the reasoning I kept hearing in grade school about listening being more important than talking because you have two ears and one month is right, then obviously this is right too.
11:16:17 <Cale> Often there's a prerelease a week or so in advance
11:16:49 <quchen> Right now the 7.8 branch hasn't even been forked off yet.
11:16:59 <tomejaguar> Hodapp: The key observation is that that is not reasoning :)
11:17:23 <Cale> Your tab key is much wider than your "E" key, which means that tab is more important than the letter E.
11:17:30 <nadirs> is 7.7 even around already?
11:17:41 <jle`> Cale: that's why they have a whitespace programming language that avoides those little keys altogether
11:17:42 <quchen> nadirs: 7.7 is "7.8 development".
11:17:56 <quchen> nadirs: There is no official release of uneven versions.
11:18:19 <nadirs> quchen: Ha, didn't know it. Thanks!
11:18:36 <christianpbrink> @quchen So basically I should not be standing by waiting for this, delaying a project by what may not in fact be "just a few days".
11:18:36 <lambdabot> Unknown command, try @list
11:19:11 <quchen> christianpbrink: Are you planning on writing code that works with 7.8 but not 7.6? Do you absolutely require 7.8?
11:19:14 <Hodapp> tomejaguar: SHHHHHH!
11:19:35 <quchen> In other words, why not upgrade in a month?
11:19:39 <christianpbrink> I just want to start using GHCJS instead of writing a new component of my web app directly in JS
11:19:42 <christianpbrink> @quchen
11:19:42 <lambdabot> Unknown command, try @list
11:20:01 <christianpbrink> It can always wait of course, JS works, it just sucks
11:20:31 <quchen> With GHCJS I don't know what you should do, but I acknowledge the problem.
11:20:55 <Shapeshifter> Can someone think of a relatively simple data type I could re-implement for show in a presentation? List would be ok but I'm pretty sure the whole Cons story seems weird to my Java audience. On the other hand, a kind of "Pair" would be almost too simple and boring... Something like a Triple, but a wee bit more complicated would be nice.
11:20:58 <Cale> If you want to use GHCJS right now, I believe you need to use GHC HEAD
11:21:17 <quchen> Shapeshifter: Maybe Maybe?
11:21:30 <geekosaur> I was thinking Either
11:21:33 <Shapeshifter> quchen: Yeah I thought of that but I'm not sure I can manage to get that across :|
11:21:42 <td123> Cale: I believe ghcjs also has a virtual machine available to download so that you can play around with it
11:21:47 <quchen> "return (-1) is rubbish"
11:22:46 <Cale> :t return (-1)
11:22:47 <lambdabot> (Monad m, Num a) => m a
11:23:00 <quchen> "'return (-1);' is rubbish"
11:23:05 <td123> here is the installation instructions for the vagrant vm: https://github.com/ghcjs/ghcjs#installation
11:23:14 <Cale> :t 'return (-1)'
11:23:14 <lambdabot>     lexical error in string/character literal at end of input
11:23:21 <quchen> Cale: Semicolon! :-)
11:23:23 <Cale> :t 'return (-1);'
11:23:24 <lambdabot> parse error on input `;'
11:23:30 <Cale> wow
11:23:39 <Cale> haha
11:23:41 <quchen> "return -1" would have been even easier.
11:23:52 <Cale> :t return -1
11:23:53 <lambdabot> (Monad m, Num (a -> m a)) => a -> m a
11:23:56 <quchen> Eww.
11:23:57 <nivox> Shapeshifter: what about a classical binary tree?
11:24:00 <quchen> Nevermind haha
11:24:35 <Shapeshifter> nivox: maybe...
11:25:04 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
11:25:06 <Cale> or
11:25:17 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a)
11:25:32 <quchen> Or maybe simpler, "data Tree a = Leaf a | Branch"!
11:25:38 <Cale> lol
11:26:11 <Cale> Either of my trees will show off most of the features of algebraic datatypes
11:26:22 <nivox> yup exactly
11:27:14 <nivox> I think trees are a nice (and rather easy to understand) way to present algebraic datatypes... at least it was for me...
11:27:34 <Shapeshifter> Yeah I'll use a tree.
11:27:36 <Shapeshifter> Thanks.
11:27:44 <Cale> It helps when you first see that syntax if you've ever seen BNF notation in your life
11:27:53 <Shapeshifter> Also shows off 'deriving'.
11:28:41 <nadirs> Shapeshifter: there was an introductive talk about Haskell at 8thlight I while ago. If you have time to give a look at it: http://vimeo.com/63671397
11:28:47 <nadirs> *a while ago
11:29:32 <nouitfvf_> !hoogle
11:29:44 <nouitfvf_> !hoogle ($)
11:30:23 <Shapeshifter> nadirs: nice, thanks.
11:30:40 <nadirs> you're welcome
11:31:02 <geekosaur> @hoogle ($)
11:31:02 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
11:31:02 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
11:31:02 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
11:31:35 <robonerd-> does haskell have concept of null? like if you had some number, could it be 0,1,2.. but also be NULL and not a number at all?
11:31:45 <Heffalump> robonerd-: see the Maybe type
11:32:06 <Heffalump> that flags the possibility of the value not being there explicitly in the type system
11:34:14 <robonerd-> Heffalump so can you take any type, and add some kind of 'maybe' customizer flag to it, and now you have data that can either not be there, or be there of the given type?
11:34:36 <OPERATOR> http://www.youtube.com/watch?v=0IgSArHmdl0
11:34:57 <nlogax> @src Maybe
11:34:58 <lambdabot> data Maybe a = Nothing | Just a
11:37:51 <nlogax> robonerd-: Put your type in place of the a there ^
11:41:37 <nivox> robonerd-: for example the partial java function "public Integer quotient(int dividend, int divisor)" which returns null in case divisor is 0 becomes "quotient :: Integer -> Integer -> Maybe Integer
11:42:27 <nivox> robonerd-: when the divisor is 0 the return will be Nothing... otherwise it'll be Just the quotient
11:43:22 <quchen> > let quotient x 0 = Nothing; quotient x y = Just (x `div` y) in (4 `quotient` 2, 4 `quotient` 0)
11:43:23 <lambdabot>   (Just 2,Nothing)
11:43:38 <FreeFull> Why doesn't Java even mark its types as nullable
11:43:56 <quchen> FreeFull: Because they all are
11:44:15 <FreeFull> I like Maybe/Option
11:44:19 <nlogax> Even the primitives?
11:44:43 <Hodapp> Ceylon, for instance, makes a distinction between types that are nullable or not.
11:47:38 <nivox> nlogax: nope the primitives cannot be null... and when you pair that with Java's auto-boxing/unboxing of primitive types things can get interesting :-)
11:48:04 <robonerd-> hmm
11:48:09 <robonerd-> primitives cannot be null huh
11:48:15 <robonerd-> is that good design?
11:48:19 <robonerd-> shouldn't all types be nullable?
11:48:40 <Hodapp> er, I'd go with none of them :P
11:48:43 <nlogax> nivox: Urk, I had managed to repress that
11:48:56 <byorgey> robonerd-: why?
11:49:49 <robonerd-> dunno
11:49:54 <robonerd-> im asking more than anything
11:50:16 <quchen> NullPointerExceptions are bad.
11:50:33 <byorgey> robonerd-: the inventor of nullable types thinks it was a terrible mistake.
11:50:36 <byorgey> robonerd-: see http://qconlondon.com/london-2009/presentation/Null+References:+The+Billion+Dollar+Mistake
11:50:40 <quchen> And I don't think Null has any benefit over a Maybe-like types.
11:50:58 <nlogax> Everyting nullable is like GHC sneaking `... | Null` into all your types, that would be incredibly rude
11:51:05 <robonerd-> isn't nullable the same as a type with maybe?
11:51:29 <FreeFull> robonerd-: No, because it can cause havoc if you don't check for null
11:51:31 <quchen> robonerd-: The compiler can tell you when you forget checking the Nothing case. You can't do that for Null.
11:51:38 <robonerd-> if you had a non maybe non nullable integer type, and you hadn't set it yet, what would its uninitialized value be?
11:51:40 <nivox> nlogax: :-) at work I periodically have to track down some incomprehensible NullPointerException regarding primitive types... that keeps it fresh into my mind :-)
11:51:41 <FreeFull> You can't skip the Maybe check unintentionally
11:51:50 <byorgey> robonerd-: you can't do that.
11:52:00 <byorgey> robonerd-: Haskell doesn't have "uninitialized" things.
11:52:14 <robonerd-> how would some integer type of data become initialized?
11:52:49 <nlogax> nivox: Sorry :(
11:52:54 <dv-> :t undefined
11:52:54 <lambdabot> a
11:53:06 <quchen> robonerd-: "a = 3 :: Int"
11:53:18 <blablub> robonerd: in plain haskell, you do not have variable "variables", you have just values
11:53:18 <quchen> That initialized "a" as Int with value 3.
11:53:54 <blablub> robonerd-: variable names are just aliases for their value
11:53:54 <byorgey> robonerd-: in some languages you can "declare a variable" and then only later initialize it with a value.  In Haskell, all you can do is give names to values.  You can't declare variables.
11:54:16 <robonerd-> so you set up slots, which values are put into or not?
11:54:31 <byorgey> I don't understand the question.
11:54:43 <blablub> robonerd-: "slot" describes mutable variables. in haskell, everything is immutable
11:54:55 <robonerd-> then how can you give a name to a value if its immutable?
11:55:07 <blablub> robonerd-: just thuink of every haskell variable being "const"
11:55:14 <nivox> robored-: it's more like you give label to values... if there's no value... there's no label
11:55:14 <robonerd-> fascinating
11:55:19 <robonerd-> ah, reference
11:55:30 <robonerd-> do values carry their label around with them?
11:55:33 <robonerd-> or is the label the gateway to the value
11:55:39 <byorgey> the latter.
11:55:40 <blablub> no, the "label" is an alias
11:55:48 <robonerd-> so label is like a proxy
11:55:53 <blablub> everywhere you write the label, you could as well just insert the value
11:55:55 <robonerd-> a shortcut
11:55:58 <blablub> so the label is ju8st a shorthand
11:56:03 <robonerd-> ok
11:56:08 <robonerd-> seems reasonable
11:56:12 <dv-> you can have uninitialized records
11:56:17 <byorgey> dv-: shush
11:56:24 <byorgey> ;-)
11:56:51 <robonerd-> ok so null bad, but maybe good
11:57:09 <robonerd-> maybe is where we explicitely declare our type to be present or maybe not
11:57:22 <nivox> yup
11:57:54 <nivox> or better when you want to explicitely declare our *value* to be present or maybe not
11:58:12 <robonerd-> ah right
11:58:16 <robonerd-> yes
11:58:41 <blablub> robonerd-: this comes naturally if you have algebraic data types
11:59:04 <robonerd-> where may i read a good overview of ADT?
11:59:47 <nlogax> My first real Haskell program was an IRC bot, it did something like `let Just msg = decode data`, and the compiler warned me that i didn't cover the `Nothing` case. That was the only place it ever crashed (usef it to crash if parsing failed)
12:00:00 <nlogax> Hooked after that :P
12:00:17 <quchen> robonerd-: You could start reading LYAH, which mentions algebraic datatypes along the way. It also goes over all the other stuff.
12:00:19 <quchen> @lyah
12:00:20 <lambdabot> Unknown command, try @list
12:00:22 <quchen> @where lyah
12:00:23 <lambdabot> http://www.learnyouahaskell.com/
12:00:40 <robonerd-> yea, started a few times, but not smart enough to understand haskell
12:00:42 <blablub> robonerd-: i don't know, but the classic introductions such as LYAH and RWH should cover it
12:00:49 <robonerd-> i think i need to study the foundational concepts more first
12:01:05 <quchen> I'm not sure the benefits of algebraic datatypes can be made obvious by reading something about them specifically (and out of context).
12:02:56 <johnw> robonerd-: maybe http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
12:03:12 <robonerd-> thank you johnw reading now
12:04:06 <johnw> essentially there is a algebra that lets you build up complex types from other types, and that algebra is basically "addition" (sum types) and "multiplication" (product types)
12:04:23 <johnw> it's not much more than that, but the implications are amazing
12:04:34 <robonerd-> hmm
12:04:42 <robonerd-> ok so you can build types based on relationship, vs just data
12:04:43 <robonerd-> ?
12:04:50 <johnw> well, like say I have an Int type
12:04:58 <robonerd-> k
12:05:03 <johnw> I can make a Pair of Ints by creating the product type (Int, Int)
12:05:16 <johnw> i.e., data Pair = Pair Int Int
12:05:31 <johnw> a sum type would be: data Pair = OnePair Int | AnotherPair Int
12:05:37 <nadirs> I'm wandering a bit off but have a question: what's the (please forgive me) "semantic" difference between Maybe (Nothing) and Either (Left)
12:05:52 <johnw> Nothing cannot contain a value?
12:06:14 <johnw> there is no semantic difference between Maybe a and Either () a
12:06:32 <robonerd-> ok so product type joins types
12:06:37 <johnw> robonerd-: yep
12:06:43 <robonerd-> and a sum type joins data
12:06:49 <johnw> a sum type select between types
12:06:53 <johnw> selects
12:06:57 <sx> can someone explain me why my code does not work? It says that initialState is ambiguous (http://lpaste.net/5314432200941240320)
12:07:02 <johnw> Either is a sum type, because it can be either a Left value or a Right value
12:07:05 <nadirs> johnw: I've sometimes seen `Either String a` as a means to display a message when a failure happens (which makes the left value a "non-value", so to speak)
12:07:06 <nlogax> Like a tagged union in C, except better
12:07:11 <FireFly> product is a bit akin to C `struct`, sum is a bit akin to C `union`
12:07:25 <robonerd-> FireFly interesting analogy
12:07:32 <robonerd-> i don't quite understand union nor sum type lol
12:07:34 <johnw> nadirs: right, but the error message is actually carried in a value
12:07:42 <robonerd-> a sum type selects between types?
12:07:52 <johnw> robonerd-: a sum type is either one type or another type but not both
12:08:03 <robonerd-> shouldn't it be called an or type?
12:08:11 <FireFly> Sure
12:08:11 <johnw> you can think of it that way, sure
12:08:17 <johnw> "and" types and "or" types
12:08:18 <robonerd-> ok
12:08:22 <johnw> actaully, there is a basis for thinking of it that way
12:08:29 <nadirs> johnw: which leads me into even more confusion when I read about Writer :P
12:08:38 <johnw> in the way that product and coproducts are represented in logic
12:08:43 <FireFly> It just happens that product/sum is "analogous" to and/or
12:09:04 <johnw> nadirs: what kind of confusion?
12:09:07 <FireFly> (consider how * and + behaves for {0,1} to represent false/true, for instance)
12:09:12 <robonerd->  <johnw>	 i.e., data Pair = Pair Int Int <- where does the (Int, Int) formatting go?
12:09:15 <robonerd-> i don't see it present
12:09:30 <johnw> robonerd-: Pair Int Int is semantically equivalent to Pair (Int, Int)
12:09:37 <Cale> Well, it's close
12:09:47 <FireFly> johnw: you mean, to (Int, Int)  ?
12:09:48 <nadirs> Firefly: I think that's somehow related to the truthyness|falsyness of 1|0 (which happen to also be mempty for product|sum)
12:10:03 <robonerd-> well how would i know when to use which?
12:10:06 <blablub> robonerd-: (,) is a constructor just as Pair is
12:10:12 <Cale> Not quite equivalent, because Pair (undefined, undefined) and Pair undefined are different values if you use the second definition.
12:10:13 <robonerd-> so | is to sum types what ( , ) is to product types?
12:10:14 <robonerd-> in syntax
12:10:20 <johnw> Cale: yes, that is true
12:10:22 <johnw> equivalent-ish
12:10:30 <blablub> robonerd-: it is just syntactic sugar over something that may be called Pair internally
12:10:30 <nadirs> johnw: isn't Writer also used in a similar way of `Either String a` to carry on a message?
12:10:39 <robonerd-> (,) is constructor for.. List?
12:10:47 <johnw> nadirs: Writer can be used for many more things
12:10:58 <Cale> robonerd-: pair
12:11:04 <rck> I'm using the bcrypt library on hackage and the validatePassword function returns False for all inputs under ghci (inputs are embedded in source, not typed in at prompt) but returns True for valid passwords when compiled. Why?
12:11:07 <robonerd-> oh
12:11:10 <robonerd-> what's constructor for list?
12:11:13 <robonerd-> or array
12:11:15 <johnw> the other day I used a Writer to accumulate the parts of a Text Builder
12:11:28 <Cale> robonerd-: The constructors for lists are [] (the empty list) and (:)
12:11:50 <blablub> robonerd: "[]" constructs an empty list, ":" constructs a longer list out of a list and an element
12:11:51 <Cale> Every list is either [] or it is of the form (x:xs) where x is an element, and xs is another list
12:11:57 <nadirs> johnw: yes, as Either can too, right? I'm just thinking about that kind of usage that you'd associate to Exception propagation in other languages
12:11:59 <robonerd-> is (,,) a constructor for a triplet?
12:12:02 <Cale> yes
12:12:21 <johnw> nadirs: Writer accumulates every "tell" into a Monoid; Either is not required to use a Monoid as its Left type
12:12:24 <robonerd-> wow, : operates interestingly. like how APL takes input
12:12:33 <nlogax> > (,,) 1 2 3
12:12:34 <lambdabot>   (1,2,3)
12:12:37 <robonerd-> from right to left from first item from left 1 item at a time
12:12:50 <Cale> For instance when you write the list [1,2,3] it's syntax sugar for 1 : (2 : (3 : []))
12:13:14 <robonerd-> is Pair a List of 2 elements?
12:13:18 <nadirs> johnw: so Either is like just a step, while Writer can represent a whole travel?
12:13:21 <Cale> no, pairs are separate
12:13:32 <johnw> nadirs: there really is no inherent connection between Writer and Either
12:13:34 <robonerd-> they use same characters for their constructors?
12:13:37 <Cale> All the elements of a list must be of the same type
12:13:37 <nooodl> :t (3, "hello")
12:13:38 <lambdabot> Num t => (t, [Char])
12:13:40 <blablub> robonerd-: without sugar, you can define a list like this: data List = Cons a List | Nil
12:13:42 <robonerd-> er no
12:13:42 <nooodl> :t [3, "hello"]
12:13:42 <lambdabot>     No instance for (Num [Char]) arising from the literal `3'
12:13:43 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
12:13:43 <lambdabot>     In the expression: 3
12:13:47 <Cale> Pairs may have differently typed components
12:13:54 <robonerd-> sorry i missed something above. ok, so i understand ()
12:13:57 <robonerd-> for tupes, and [] for list
12:14:17 <johnw> nadirs: Writer accumulates a monoidal value over a range of "statements"; Either represents either one value type or another value type
12:14:30 <zol> jle`: Solved it! Tiny error in my algorithm however :)
12:14:30 <robonerd-> Cale why must all elements of a list be of same type?
12:14:41 <Cale> Because that's usually what you want
12:14:49 <robonerd-> what if it isn't?
12:14:54 <Cale> Then you use tuples
12:15:00 <sx> if I use generic types, can I use them in every context where i would use a normal type? (by generic types I mean lower case type variables)
12:15:01 <Cale> (or something like them)
12:15:10 <rck> thoughts on why ghci returns False for ByteString -> ByteString -> Bool but compiled code returns True?
12:15:11 <Cale> Or you create your own datatype
12:15:17 <johnw> robonerd-: heterogeneous lists -- lists that accept varying types -- are not necessary most of the time; I've never actually needed one in Haskell
12:15:46 <robonerd-> johnw where do you stuff a loose collection of various objects having various types?
12:15:53 <Cale> Most of the time, if you want a heterogeneous list, you really want a list of values of some type which has a small finite number of cases.
12:16:05 <johnw> you can simulate them by creating a set of related types using an ADT, like data Grouped = TypeA A | TypeB B | TypeC C, etc.
12:16:16 <Cale> A list of elements of arbitrarily many different types which aren't known to you, is pretty useless.
12:16:32 <johnw> then you can have [Grouped], which allows heterogeneity among however many different constructors you created
12:16:35 <Cale> This is because types are compile-time information, not run-time information.
12:16:36 <nadirs> johnw: ok, I have some trouble not comparing all these various types. For instance, Either represents two possible outcomes; if there can be more than two I think of Lists. Is that a way of thinking that should be avoided?
12:16:58 <Cale> So, not knowing the type of something pretty much means all you can do with it is pass it around. You can't inspect it.
12:17:15 <johnw> nadirs: a list is a value product, and an Either is a sum product.  If you could have three possible outcomes, you'd need an ADT
12:17:24 <johnw> a value sum, I meant
12:17:45 <johnw> i.e., a list are not an unbounded Either type, no such thing exists
12:18:00 <Cale> johnw: ... wat
12:18:18 <Cale> I totally do not understand what you said in the last 3 lines
12:18:22 <johnw> "Either represents two possible outcomes; if there can be more than two I think of Lists"
12:18:27 <fizbin> Or you could build Either a (Either b (Either c d)) - type things, but then people will look at you funny.
12:19:08 <Cale> Lists don't really help you with more than two possibilities so much as custom sum types do.
12:19:18 <johnw> right, that's what I was saying :)
12:19:18 <nadirs> johnw: in LYAH I've read that lists are used to represent non-deterministic values
12:19:35 <Cale> er, all right
12:19:41 <johnw> nadirs: in a non-determistic result, you have multiple values, not a choice among possibilities
12:19:51 <Cale> oh, that was a quote from nadirs
12:19:52 <Cale> I see
12:20:15 <johnw> Cale: don't worry, I was starting to confuse myself too
12:20:31 * fizbin has used stuff that ended up typed as things like that cascade of Eithers, or a similar (2-)tuple cascade, but never directly.
12:20:44 <johnw> a cascade of eithers is a disguised ADT
12:20:54 <nadirs> johnw: right. I think I just need to reorder my thoughts. Thanks for all the good answers, I just learned I have to learn what a value product and a value sum are :)
12:20:57 <johnw> a casced of tuples is a disguished ADT with one constructor :)
12:21:24 <fizbin> Only sometimes that's what I end up with when combining different processing stages with binary operators.
12:21:26 <johnw> nadirs: a product of anything is AxB, or A*B, or (A, B), depending on context
12:21:53 <Cale> nadirs: I'm not sure johnw's use of the word "value" as a modifier of "sum" and "product" is standard in any way.
12:21:55 <johnw> nadirs: a sum of anything is A+B, or A|B
12:22:05 <johnw> no, I regret using "value"
12:22:14 <johnw> I was trying to distinguish an Either value from Either-the-type
12:22:21 <Cale> ah, okay
12:22:41 <johnw> the reason by (A, B) is a product, is that for every possible A, you have every possible B
12:23:09 <johnw> A+B is a sum, in that you have every possible A or every possible B, which is a set whose size is equal to "all of A plus all of B"
12:23:17 <robonerd-> http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/ <- great read. anyone know of a read that explains calculus in the same way?
12:23:18 <johnw> wow, my typing accuracy is wretched today
12:23:27 <nadirs> johnw: does it make sense to assimilate product vs sum to map vs fold (sorry, I can't help but trying to make comparisons with anything)
12:23:33 <Cale> If the type A has n defined values, and the type B has m defined values, then the type (A,B) has n*m defined values. This is why we refer to pairs as products.
12:23:48 <Cale> Analogously, Either A B will have n + m defined values.
12:24:06 <johnw> robonerd-: don't the later articles in that series touch on derivatives and integration?  if not, they should; that connection is explored elsewhere on the Web
12:24:26 <Cale> i.e. it will have Left x for each x of type A, and in addition to that, it'll have Right y for each y of type B
12:24:29 <nadirs> Cale: is (monad?)product what mapM is for?
12:24:42 <Cale> er
12:24:47 <johnw> nadirs: I don't follow
12:24:51 <Cale> This has nothing to do with monads
12:25:26 <Cale> mapM is essentially a for-each loop written to work in an arbitrary monad.
12:25:44 * hackagebot holy-project 0.1.0.0 - Start your Haskell project with cabal, git and tests.  http://hackage.haskell.org/package/holy-project-0.1.0.0 (yogsototh)
12:25:48 <nadirs> no, wait, maybe I meant filterM.
12:25:56 <FreeFull> There is forM
12:26:11 <FreeFull> Which is mapM with the arguments swapped around
12:26:11 <Cale> oh, you might be thinking of the way that sequence computes a Cartesian product of sorts
12:26:17 <nadirs> I remember an example where you can define powerset by simply saying `filterM (const [True, False])`
12:26:21 <nadirs> or something similar
12:26:21 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
12:26:22 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
12:26:26 <Cale> ^^ like that
12:26:29 <FreeFull> :t filterM
12:26:30 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
12:26:46 <Cale> That's not a product at the type level, but it is enumerating the elements of a particular Cartesian product.
12:26:54 <FreeFull> List monad magic
12:27:41 <Cale> length (sequence xs) = product (map length xs)
12:28:36 <johnw> one way I think of the list monad is as "embedded for loops"; so Cale's sequence can be read as: for (i in [1,2,3]) { for (j in [4,5]) { for (k in [6,7,8]) { return [i,j,k] } } }
12:28:43 <Cale> (Until the length gets too long, because derpy length produces an Int instead of an Integer)
12:29:04 <nadirs> johnw: which is how I first think of List
12:29:05 <robonerd-> anyone in seattle want to meet up and teach me haskell? i'll buy lunch
12:29:08 <johnw> genericLength!
12:29:09 <FreeFull> I've never seen a list long enough to overflow Int though
12:29:14 <jj2baile> :t sequence
12:29:14 <lambdabot> Monad m => [m a] -> m [a]
12:29:24 <johnw> robonerd-: you should ask mgsloan!
12:29:26 <Cale> FreeFull: It's not hard at all to make one using sequence
12:29:33 <robonerd-> johnw ty
12:29:36 <nadirs> until I read about List as a monad, which brought in all that magic FreeFull referred to
12:29:42 <Cale> > sequence (replicate 100 [0,1])
12:29:43 <lambdabot>   [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
12:29:52 <Cale> That list will overflow length
12:29:54 <johnw> where the list monad really starts to seem magical is when it's use becomes implicit
12:30:04 <geekosaur> is it possible, even? ghc's Int should always be at least the same size as a pointer, I think; it's hard to point to more objects than the hardware can address
12:30:06 <johnw> like when using it with mfilter
12:30:32 <FreeFull> It takes a long time to evaluate length on long lists
12:30:33 <johnw> then the "for loops" analogy becomes impossible to see
12:30:53 <Cale> You mean filterM
12:31:05 <Cale> It's possible to see if you think about it hard enough...
12:31:16 <robonerd-> yes
12:31:19 <robonerd-> just imagine a screw, duh
12:31:21 <johnw> ah, right
12:31:24 <johnw> > filterM (const [True, False]) [1,2,3]
12:31:25 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:31:56 <Cale> You have a nested loop for each element of the list, where you enumerate the values True and False
12:32:36 <Cale> "do I keep this element, or don't I?"
12:33:00 <nadirs> Cale: with that wording ("nested loop for each") it's much clearer!
12:33:04 <sx> Can someone understand why this simple example can't deduce the type variable p for 'op'? http://lpaste.net/4000528819499827200
12:33:37 <johnw> sx: what's the exact error?
12:33:45 <nadirs> I guess escape from procedural thinking is not so easy as I thought :P
12:33:53 <`Jake`> Is there any kind of relatively widespread preference of using "newtype" rather than "type"?
12:34:10 <Cale> `Jake`: They're not equivalent, but yes.
12:34:18 <sx> johnw: http://lpaste.net/96560
12:34:18 <`Jake`> thanks
12:34:28 <benmachine> sx: because Bar p is just Int
12:34:32 <johnw> sx: I think you need a proxy to carry the 'p'
12:34:41 <benmachine> so bar :: Foo p => Int which gives no clues to what p is
12:34:45 <nadirs> `Jake`: type is just an alias
12:34:46 <johnw> bar :: Foo p => proxy p -> Bar p would work
12:34:49 <Cale> `Jake`: 'type' is kind of pointless -- it just helps you obscure which type something really still is, and makes it hard to look through documentation for relevant operations
12:34:54 <johnw> then you can specify which 'p' you mean when calling 'bar'
12:35:13 <Cale> `Jake`: newtype defines a properly new type which the type system won't let you confuse with the original
12:35:15 <johnw> would it work with data or newtype?
12:35:18 <`Jake`> yeah, I guess that makes sense
12:35:25 <johnw> (asked of sx)
12:35:55 <sx> so when i use newtype it recognizes p?
12:36:02 <johnw> i don't think so, I was just wondering
12:36:14 <tomejaguar> Cale: type's been really useful for me lately.  I've been using it to fill in concrete types in types with parameters.
12:36:17 <johnw> i think you need a proxy, or some type which represents a 'p'
12:36:19 <`Jake`> thanks again, I'll go ahead and use newtype then
12:36:30 <Cale> tomejaguar: Well, I'm selling it a little short
12:37:03 <Cale> tomejaguar: But I've always been somewhat upset that it wasn't designed slightly differently. A few small tweaks to how it interacted with modules would make it far more useful.
12:37:58 <Cale> You can't export a type synonym without exporting the equality between that synonym and the original type.
12:38:31 <fizbin> Go newtype!
12:38:38 <Cale> It would have been nice to have used 'type' as a kind of module-level newtype, where you can use the original type transparently within a module, and have it be abstracted from the outside.
12:38:57 <tomejaguar> Cale: That's a nice idea.
12:39:25 <sx> i solved it by using: data Bar p = Bar Int, this seems to keep the p in it
12:39:36 <johnw> sx: ok, that's good to know
12:40:59 <Cale> sx: Yes, that'll work. The problem is basically that you'd written what was essentially  bar :: Foo p => Int
12:41:26 * flebron wonders if he can ask a Hakyll question here, or if he should just wait a couple more hours at #hakyll :s
12:41:37 <nadirs> > newtype NadirA = NadirA Int
12:41:38 <lambdabot>   <hint>:1:1: parse error on input `newtype'
12:41:53 <nadirs> > type NadirA = NadirA Int
12:41:54 <lambdabot>   <hint>:1:1: parse error on input `type'
12:42:09 <johnw> sx: would a newtype work?
12:42:19 <Cale> sx: So p would never be possible to determine, since it didn't *really* occur to the right of the =>
12:42:22 <sx> johnw: it did not
12:42:44 <Cale> (as type synonyms are just syntactic sugar and not something that the typechecker is fully aware of)
12:42:47 <sx> Cale: but that makes type a nearly useless construct
12:42:52 <Cale> YES!
12:42:57 <Cale> It is nearly useless
12:42:58 <johnw> sx: types are just synonyms
12:43:12 <Cale> And that's what I was just complaining about now ;)
12:43:13 <johnw> they can help the reader, but they don't help the compiler all that much
12:43:32 <johnw> I use them to avoid repetition
12:43:50 <johnw> like, type FooT m a = StateT MyStateType m a
12:44:07 <Cale> I would use newtype in johnw's case ;)
12:44:14 <Cale> But yeah, there are use cases.
12:44:27 <johnw> newtype requires a lot of new instances sometimes
12:44:28 <Cale> Lens is one
12:44:48 <johnw> although GeneralizedNewtypeDeriving goes a long way
12:44:49 <Cale> Sure, but I don't use monad transformers lightly
12:45:07 <Cale> Or if I do, I'm using them so lightly that they won't show up in any of my type signatures at all
12:45:22 <johnw> actually, I usually use newtype then too :)
12:45:27 <johnw> i was just inventing an example
12:45:33 <Cale> (either I use them for one-liners, or whole libraries, and almost nothing in between)
12:45:46 * hackagebot github-post-receive 1.0.0.0 - Github post-receive server library  http://hackage.haskell.org/package/github-post-receive-1.0.0.0 (ShoheiYasutake)
12:47:36 <robonerd-> is there any programming construct where you like, 'change context' to some entity in the language and issue code 'as' that entity? imagine a function being passed an object, function changes context to object, runs some code, and it's as if object ran that code.
12:47:50 <Cale> um
12:47:54 <johnw> what is an "object"?
12:48:26 <Cale> robonerd-: Haskell is referentially transparent, so when you evaluate an expression, it's always going to evaluate to the same thing, regardless of the context in which you do that evaluation.
12:48:39 <fizbin> robonerd-: This is #haskell. What language were you working in?
12:49:14 <flebron> I think he means the Haskell equivalent of the following JS code: var f = function() { return this.x; }; obj = {x:1}; f.apply(obj);
12:49:27 <Cale> Now, that doesn't hold of execution of IO actions. We do have threads as well, and executing IO actions in different threads can certainly produce different results.
12:49:37 <flebron> For some undefined notion of "Haskell equivalent of".
12:49:49 <Cale> If you want to cause another thread to execute IO actions you send to it, you need to set something up explicitly for that though.
12:50:15 <robonerd-> why are they called IO actions and not acts?
12:50:22 <FreeFull> Maybe you could send the IO actions over Chan and sequence them in
12:50:23 <robonerd-> is an IO action a noun/construct?
12:50:27 <Cale> Because they're actions in the IO monad.
12:50:39 <Cale> values of type IO t are called IO actions
12:50:41 <robonerd-> ok what is an IO action?
12:50:45 <robonerd-> hm
12:50:51 <robonerd-> why are they called actions?
12:50:59 * johnw grabs the popcorn
12:51:06 <FreeFull> An IO action is a value in IO
12:51:07 <Cale> Because they're values which represent anything your computer can do.
12:51:11 <simply> robonerd-: because they represent actions upon the *gasp* real world
12:51:18 <FreeFull> So for example  getLine :: IO String
12:51:18 <robonerd-> what does the little t mean after the IO ?
12:51:27 <flebron> A type.
12:51:32 <simply> A type variable
12:51:34 <Cale> For example, getLine :: IO String represents the action of getting a line of text from the user on the terminal
12:51:35 <robonerd-> ooo
12:51:36 <simply> It can be any type you like
12:51:45 <flebron> putStrLn "Hello, World" is an action that, when you execute it, will print "Hello, World\n".
12:51:47 <Cale> Its result is a String
12:51:58 <robonerd-> so action in haskell is defined as any function which operates with the external environment?
12:52:05 <Cale> IO actions are not functions
12:52:09 <flebron> It doesn't need to be a function.
12:52:14 <Cale> They have no parameters
12:52:15 <simply> robonerd-: in Haskell, actions are values, but not functions, they're not called
12:52:22 <fizbin> robonerd-: Go read the first few chapters of http://learnyouahaskell.com/. It'll make you happier.
12:52:29 <robonerd-> okie
12:52:31 <flebron> You can compose these "actions", for instance, getLine >>= putStrLn.
12:52:34 <simply> You 'weave' them inside other IO actions in order to have them executed
12:52:50 <FreeFull> It's like making a tree that represents a program, and then executing it later
12:52:54 <FreeFull> The tree is just data
12:53:00 <Cale> robonerd-: However, C programmers abuse the word "function" to mean something similar, so you can be forgiven
12:53:32 <simply> Cale: to be fair, functions in haskell aren't actual functions, just partial functions
12:53:44 <Cale> simply: They're total functions if you look at them the right way
12:53:46 <robonerd-> [12:45:52] <flebron>	 You can compose these "actions", for instance, getLine >>= putStrLn.
12:53:47 <robonerd-> [12:45:54] <simply>	 You 'weave' them inside other IO actions in order to have them executed
12:53:54 <robonerd-> those both interest me, and i don't fully understand them either
12:54:08 <tomejaguar> Cale: so are C functions if you look at them the right way ;)
12:54:11 <robonerd-> please begin with definition of "action"
12:54:14 <Cale> tomejaguar: no
12:54:19 <robonerd-> then i can read those 2 statements
12:54:26 <tomejaguar> Cale: no?
12:54:27 <Cale> simply: In fact, they're a little more than total functions, they're monotone maps between directed-complete partial orders
12:54:32 <flebron> For any type t, a value of type IO t is called an "action".
12:54:47 <flebron> (IO action, to be precise.)
12:54:58 <johnw> robonerd-: an "IO action" is an expression in the IO monad with side effects that must be evaluated by the Haskell runtime to yield a value
12:55:07 <flebron> IO t has, as semantics, "A computation in the IO monad that returns a value of type t".
12:55:14 <flebron> (That's one of the possible semantics you can give it.)
12:55:33 <tomejaguar> Cale: if you're willing to enlarge the meaning of your types enough, then you can definitely make C functions real mathematical functions.
12:55:36 <johnw> i.e., you cannot always determine which Int an IO Int will yield by reading just the source code
12:55:40 <Cale> tomejaguar: There's no really meaningful sense in which you can consider things like network interaction and concurrency using simple functions.
12:55:48 <flebron> So getLine has type IO String, and it is "A computation in the IO monad that returns a value of type String."
12:56:17 <simply> Cale: I don't see how that's true, surely if I have a Haskell function of type T -> T (for some unspecified T), it's not necessary that T be a partial order, much less so that my function be a monotone map
12:56:20 <robonerd-> ahh
12:56:20 <tomejaguar> Cale: Sure you can.  Just define the denotation of a C 'int' to be "IO action returning an int", etc.
12:56:32 <flebron> These are not functions, getLine doesn't "take" anything.
12:56:48 <robonerd-> tomejaguar how would you make c functions real math functions? and including things like network and concurrency
12:56:49 <flebron> If you want to force it, you could say getLine "takes" the state of the world, and "returns" a pair (state of the world, String).
12:56:54 <robonerd-> what cale raised.
12:56:56 <Cale> simply: Values of every type are partially ordered by a definedness relation
12:56:56 <flebron> So that it "modifies" the state of the world.
12:56:57 <tomejaguar> Then 'void main(int)' is a function from IO actions returning an int to IO actions returning unit.
12:57:30 <tomejaguar> Its denotation would be essentiall what '>>= main' is in Haskell.
12:57:52 <tomejaguar> 'A f(B)' would correspond to '>>= f' in general
12:58:17 <Cale> simply: Where the bottom value of the order represents nontermination (or applications of "error"), and x <= y whenever the occurrences of _|_ in x can be substituted in some fashion to obtain y
12:58:20 <nadirs> http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
12:58:25 <Cale> (roughly)
12:58:36 <simply> Cale: Ok, I see what you mean, but I fail to see how match failures and the likes apply in that context
12:58:38 <Cale> _|_ meaning "bottom"
12:58:48 <Cale> Pattern match failure is _|_
12:59:13 <Cale> i.e. the semantics treats it the same as an infinite loop or a call to "error"
12:59:18 <johnw> Cale: or a call to "fail" if it happens to the left of "<-"
12:59:27 <fizbin> Is _|_ a type or a value?
12:59:30 <Cale> value
12:59:36 <Cale> It's a value in each type
12:59:40 <Cale> > undefined
12:59:41 <lambdabot>   *Exception: Prelude.undefined
12:59:54 <Cale> ^^ you can use undefined as a way to get _|_
13:00:00 <johnw> fzibin: Bool is the type whose inhabitants are [True, False, _|_]
13:00:00 <Cale> :t undefined
13:00:01 <lambdabot> a
13:00:07 <johnw> (in Haskell)
13:00:09 <fizbin> For some values of the word "get"
13:00:48 * hackagebot github-post-receive 1.0.1.0 - Github post-receive server library  http://hackage.haskell.org/package/github-post-receive-1.0.1.0 (ShoheiYasutake)
13:00:53 <Cale> We could make a diagram of [Bool], where _|_ is at the bottom, and then immediately above that are [] and _|_ : _|_
13:01:02 <johnw> you can actually use the fact that a failed pattern match in the Maybe monad results in a Nothing to build very simple, yet convenient, parsers
13:01:34 <Cale> and then above _|_ : _|_ are (False : _|_), (True : _|_), (_|_ : []), and (_|_ : (_|_ : _|_))
13:01:45 <Cale> and so on
13:02:08 <Cale> and that would be the Hasse diagram for the definedness partial order
13:02:12 <simply> Still...that seems a bit like arguing that "all C expressions live within the IO monad and thus C is pure"
13:02:16 <Cale> If you want, I can actually draw that diagram
13:02:34 <Hodapp> simply: uh, I'm pretty sure some guy actually wrote an article saying exactly that.
13:02:36 <Cale> Every definable Haskell function is an order-preserving function between those partial orders
13:03:00 <Cale> For an example of something which is *not* definable
13:03:11 <simply> Hodapp: yeah, I read it, I remember it being rather enjoyable
13:03:33 <Cale> The type () has two values, _|_ and ()
13:03:46 <Cale> A halting oracle might have type () -> Bool
13:03:57 <Cale> where it sends _|_ to False and () to True
13:04:09 <Cale> But this isn't order-preserving, so it's not definable.
13:04:24 <allsystemsarego> Hi all, I have a bit of Parsec code that works, but isn't generic enough, is anyone bored enough to do a code review? http://lpaste.net/96561
13:04:29 <fizbin> Cale: It is order-preserving.
13:04:40 <jinji> Cale: are u familier with miranda laws?
13:04:53 <fizbin> Since your halting oracle is just as order preserving as "const True".
13:04:53 <Cale> No, because _|_ <= () but False </= True in the definedness order.
13:05:13 <Cale> fizbin: Read my description of the function again
13:05:21 <Cale> I send _|_ to False, and () to True
13:05:25 <fizbin> Right, I know.
13:05:34 <Cale> This is a valid *function* between the types, but it is not a computable function.
13:05:44 <fizbin> But in the definedness order, what's the order between False and True?
13:05:50 <Cale> They are incomparable
13:05:58 <fizbin> Or ... oh, definedness is a *partial* order.
13:05:59 <Cale> It's a partial order
13:06:01 <Cale> yes
13:06:30 <Cale> jinji: Oh right, they were called laws, not views
13:06:44 <Cale> (but they were pretty much the same thing as views)
13:06:51 <fizbin> Hrm. So "const True" is fine, since adding order isn't a big deal.
13:07:01 <Cale> right!
13:07:13 <simply> Well, since it's a partial order, T < T for all T, so...
13:07:22 <Cale> _|_ <= () and True <= True
13:07:24 <Cale> so no problem
13:07:40 <fizbin> But by taking two things that were in a <= relationship, and sending one to True and one to False...
13:07:49 <Cale> Is impossible!
13:07:50 <startling> Cale: oh, that's interesting
13:08:08 <fizbin> Wait, so all distinct Haskell values are incomparable.
13:08:14 <fizbin> In definedness,
13:08:16 <fizbin> .
13:08:22 <Cale> All the fully defined values are
13:08:26 <simply> fizbin: as long as they're completely defined
13:08:33 <jinji> Cale: wadler calles it views
13:08:40 <Cale> jinji: Yeah.
13:09:01 <Cale> jinji: They're more or less the same thing, expressed in somewhat different ways
13:09:28 <fizbin> And (x, y) <= (z, q) iff x == z and y <= q ?
13:09:52 <simply> Doesn't this all mean that the category of haskell types doesn't have a terminal object?
13:09:56 <Cale> btw, it is really annoyingly hard to search the web for information about the programming language Miranda's feature called "laws"
13:09:56 <fizbin> Where == is ... um... Haskell value equality and <= is in definedness.
13:10:05 <Cale> because of the US :D
13:10:07 <joelteon> > 1 `(<)` 2
13:10:08 <lambdabot>   <hint>:1:4: parse error on input `('
13:10:09 <joelteon> :(
13:10:21 <jinji> Cale: could u see please pm
13:10:47 <Cale> simply: The type with only _|_ is both initial and terminal.
13:11:15 <Cale> er, sorry, it's not initial
13:11:25 <simply> Cale: it is, isn't it?
13:11:27 <Cale> There's no initial object
13:11:33 <fizbin> So (0, _|_ :: Bool) and (0, True) are comparable in the definedness p.o., but (1, _|_ :: Bool) and (0, True) aren't.
13:11:35 <Cale> You can send _|_ to anything
13:11:45 <simply> Oh, yeah, that's right
13:12:03 <Cale> fizbin: that's right
13:12:08 <intrados> How do you express a structural context when HMapping? Here's an example: http://lpaste.net/96562
13:17:29 <simply> This is slightly off-topic, but I'm looking for Master's degrees in theoretical computer science in Europe, any recommendations?
13:17:37 <simply> And by slightly I mean wildly
13:18:12 <Cale> intrados: Try giving fst an explicit type signature there and see if it works then
13:18:21 <Cale> (There might be a better way, but try that)
13:18:44 <donri> chalmers, oxford, utrecht?
13:19:47 <simply> donri: thanks, I was already considering Oxford, I'll check the other two out
13:19:57 <donri> glasgow? :D
13:20:22 <Taneb> simply, I'm at York.
13:20:43 <lingxiao> hey all, so I'm reading this paper: "System FC with Explicit Kind Equality" by Weirich et al
13:20:53 <lingxiao> and some others about system Fc
13:20:58 <Taneb> simply, if you're considering Oxford, you're probably too good for York, though
13:21:14 <lingxiao> and I relized that there's a lot of fundamental concepts/details about the core that I do not understand
13:21:21 <simply> Taneb: the fact that I'm considering Oxford doesn't mean Oxford is considering me...
13:21:24 <lingxiao> and prob should read some on typed lambda calclus too
13:21:28 <Taneb> simply, :P
13:21:34 <simply> And, at any rate, my best option is probably Amsterdam
13:21:38 <lingxiao> so my question is: does anyone know some simple, introductory material I coudl read?
13:21:42 <Taneb> simply, there also isn't that much Haskell on the course, alas
13:22:21 <intrados> Cale: Like this? http://lpaste.net/96562 I get the same error
13:22:35 <simply> Taneb: I can live with that, as long as there's enough logic and type theory
13:22:38 <donri> simply: utrecht is in NL; are you? lots of haskell stuff from there
13:22:50 <donri> /people
13:23:02 <Cale> intrados: No, give the concrete type you want to use it at
13:23:05 <simply> donri: I'm afraid I'm spanish. Zero theoretical CS research here.
13:23:14 <Saizan> intrados: i think you should rather give a type annotation to f, so that you can specify the ctx parameter of Fun
13:23:14 <Cale> So (Int, Char) -> Int
13:23:24 <Cale> Or that
13:23:36 <donri> simply: oh :) i thought because amsterdam
13:23:57 <simply> donri: It's just that the master in Logic and Computation they have there seems just too interesting
13:24:12 <Saizan> data Fun (cxt :: k1) (getb :: k2) = Fun (forall a. FunCxt cxt a => a -> FunApp getb a)
13:24:35 <Taneb> simply, I'm doing joint maths and computer science, it's alright but not great
13:24:42 <Saizan> so the function has to be polymorphic, except for what cxt gives you
13:25:02 <simply> Taneb: hey, that's what I'm majoring in!
13:25:32 <intrados> Saizan: Right. But I can't figure out what ctx I need to provide
13:25:48 <Saizan> intrados: in your case i suspect f :: Fun (Int, Char) Int would work
13:26:15 <yesthisisuser> lingxiao: I suppose you are already familiar with the untyped lambda calculus
13:26:25 <intrados> Saizan: Well, the problem is I want it to work with arbitrary tuples. Is that possible?
13:26:50 <lingxiao> yesthisisuser: uh I wouldn't really know to be honest, so I'm casting a wide net just in case
13:27:31 <Cale> Saizan: ah, okay
13:28:11 <khyperia> (Opinion question incoming): What would be more beneficial to my coding skills and the haskell community? A small custom language compiler hooked into GHC, or a small Haskell editor?
13:29:15 <Cale> What language would your compiler compile? :)
13:29:18 <byorgey> khyperia: what kind of custom language?
13:29:29 <scriptor> will it compile to js?
13:29:32 <Saizan> intrados: it doesn't seem too easy with these combinators
13:29:46 <simply> scriptor: you mean some languages don't?!
13:30:06 <Cale> lol, compile javascript via GHC into x86 via the LLVM backend
13:30:10 <yesthisisuser> lingxiao: well, if you know Haskell, you already are :) but it would probabl help to pick up some book on that first before moving on to typed λ Calculus and System-F
13:30:12 <khyperia> Probably my own language, I've got a bunch of ideas running through my head. Some sort of lambda-calculus-based language that would probably compile to GHC Core and then hand it off to GHC to go the rest of the way (and so in the creation of it, would improve GHC's api)
13:30:36 <Saizan> intrados: but possible
13:30:42 <scriptor> would you say you have more ideas for languages than for editors, khyperia?
13:31:02 <lingxiao> yesthisisuser: oo any ideas on what books are head and shoulders above the rest? or would a simple google/amazon search suffice
13:31:11 <khyperia> Well, yeah, although "an editor" can't take very many approaches.
13:31:24 <intrados> Saizan: The obvious generalization doesn't seem to work for me. http://lpaste.net/96562
13:31:39 <intrados> Saizan: Is it a rank-n types thing?
13:31:59 <Saizan> intrados: it's more a "being creative with gadts and typeclasses" thing
13:32:09 <allsystemsarego> Hi all, I have a bit of Parsec code that works, but isn't generic enough, is anyone bored enough to do a code review? http://lpaste.net/96561
13:32:21 <LadyAurora> scriptor: all possible editors exist, and this editor is Emacs
13:32:26 <Saizan> intrados: maybe i can write up a possible solution, let me see
13:32:27 <Cale> khyperia: If your editor can be aware of the offside rule and move an entire block in an analogous fashion whenever any edit causes the first non-whitespace character after a layout keyword to move, then I might even use it :D
13:33:06 <scriptor> LadyAurora: you're saying my irc client's an editor too?
13:33:30 <LadyAurora> scriptor: yes
13:33:43 <Cale> Nobody's written anything for vim or emacs which does that right. There was a Haskell text editor called yi, and it makes a half-assed attempt at it which doesn't really work quite right.
13:34:11 <yesthisisuser> lingxiao: You could try http://tinyurl.com/nvwns65
13:34:24 <khyperia> Throwing my idea for an editor out there: Basically, an extensible plugin-script system such as vim, but instead of vimscript or whatever it's called, have it be haskell.
13:34:37 <flebron> you know, gotta hand it to haskell. when my code compiles, it's a quite sure sign that i've got a clue how it works.
13:34:43 <Cale> Yeah, you should maybe take a look at yi
13:34:53 <khyperia> Doesn't install on my system.
13:34:59 <flebron> It took me an hour to make this Hakyll code compile, but I think I have an idea of what it's doing now :p
13:35:01 <khyperia> So that's an issue.
13:35:11 <Cale> yeah, I don't think anyone's been maintaining it
13:35:13 <LadyAurora> Cale: that's because the offside rule is hard. Referees are making plenty of mistakes when it comes to offsides.
13:35:15 <Cale> but there's a lot of stuff there
13:35:21 <Cale> LadyAurora: haha
13:35:47 <khyperia> because yi kind of slightly depends on the unix package
13:35:50 <khyperia> which is a problem
13:35:53 <fizbin> flebron: now, now, it's perfectly possible to write your types so that compiling cleanly tells you very little about your program's potential correctness.
13:36:13 <Cale> khyperia: oh, windows
13:36:22 <flebron> That would be my nightmare. Spend an hour with the compile time errors, just to deal with dynamic errors as well :(
13:36:44 <lingxiao> yesthisisuser: ah awesome, thanks a lot!
13:36:45 <Cale> I wonder why it relies on unix
13:37:18 <khyperia> looks like the dependency "stack" or whatever it's called goes yi -> vty -> unix
13:37:23 <lingxiao> also could someone explain this sentence to me? "Coercions are proof terms witnessing the equality between types (and kinds)"
13:37:33 <LadyAurora> khyperia: windows sucks, use the "free" operating system that doesn't even have good async IO support
13:37:34 <lingxiao> the word "witnessing" is really throwing me off
13:37:41 <lingxiao> what does it mean to "witness"?
13:37:50 <khyperia> LadyAurora, I'm stuck on windows, not my choice
13:38:11 <geekosaur> a proper windows version of vty would be somewhat difficult since the ansi escape emulation in cmd.exe windows is somewhat limited and the correct way to do it is device control calls
13:38:12 <byorgey> khyperia: yi depends on unix-compat, not unix. It claims to work on Windows.
13:38:25 <byorgey> you have to build it with GTK though.
13:38:33 <byorgey> instead of vty.
13:38:34 <LadyAurora> khyperia: and I'm merely being sarcastic.
13:38:35 <yesthisisuser> lingxiao: Personally, I read a lot of tutorials and wiki-type articles to build up some intuition at the same time I read the book
13:38:43 <khyperia> byorgey, could you explain?
13:38:52 <byorgey> khyperia: yi has multiple GUIs
13:39:00 <khyperia> and how do I install it with GTK?
13:39:13 <byorgey> khyperia: see http://www.haskell.org/haskellwiki/Yi#Windows
13:39:49 <lingxiao> byorgey: hey brent :)
13:39:58 <khyperia> Whelp, then my cabal got corrupted and cabal update doesn't fix it.
13:40:07 <byorgey> hi lingxiao =)
13:40:39 <Cale> khyperia: ghc-pkg check can often tell you how bad the problem is
13:40:59 <byorgey> khyperia: what do you mean by "my cabal got corrupted"?
13:41:05 <byorgey> cabal update is not intended to fix corruption.
13:41:31 <vvladdmir> I hav
13:41:31 <Cale> Yeah, all cabal update does is download the latest package list
13:41:34 <khyperia> "cabal: internal error when reading package index: could not read tar file entry. The package index or index cache is probably corrupt. Running cabal update might fix it."
13:41:44 <Cale> oh
13:41:48 <Cale> huh!
13:42:06 <piezoid> allsystemsarego: I annotated your code http://lpaste.net/96561
13:42:11 <Cale> Find your local .ghc directory and delete it?
13:42:24 <Cale> I don't know where that is in Windows, maybe under Documents and Settings?
13:42:27 <arkeet> I got that once.
13:42:35 <arkeet> waiting and doing cabal update later fixed it.
13:42:35 <lingxiao> yesthisisuser: word me too. the deeper I dig into this stuff, the less tutorials for dummies I find
13:42:36 <arkeet> :(
13:42:38 <khyperia> %appdata%\ghc is I think where it is
13:43:03 <Saizan> intrados: http://lpaste.net/96567 <- it's possible there's a more idiomatic way, but i'm not familiar enough with the combinators in hlist
13:43:10 <zol> jle`: I solved it! :)
13:43:21 <khyperia> Oh, hey, spamming cabal update a couple times worked.
13:43:22 <Cale> Yeah, that sounds right, especially if your username ends up somewhere along that path
13:43:27 <Cale> wow
13:43:42 <arkeet> this was also on windows.
13:43:44 <zol> jle`: http://lpaste.net/2117944589514964992
13:44:10 <khyperia> Oh. Yeah. I remember why yi doesn't install. It says "loading package cairo-0.12.4" then drops to "Failed to install yi" without any error messages
13:44:12 <zol> jle`: Not sure how to improve readability more than that. :(
13:44:43 <monochrom> No, it is %appdata%\cabal\packages\hackage.haskell.org\00-index.*
13:44:54 <monochrom> it has nothing to do with GHC
13:44:57 <allsystemsarego> piezoid, thanks, I'll have a look
13:45:32 <LadyAurora> zol: it's Haskell, so it's more readable than 99.99% of the code around
13:47:37 <intrados> Saizan: Thanks so much. I think I can understand how it works
13:49:28 <yesthisisuser> lingxiao: http://zeroturnaround.com/rebellabs/what-is-lambda-calculus-and-why-should-you-care/
13:49:57 <lingxiao> yesthisisuser: woa thanks for sticking with my question!
13:50:19 <yesthisisuser> lingxiao: Also, the book he recommends there is worth checking out.. Benjamin Pierce's "Types and Programming Languages"
13:50:20 <lingxiao> and for finding that site, judging by the number of pretty pictures and the font, it's totally what I should start with
13:50:41 <lingxiao> will check that as well! thank you!
14:02:25 <khyperia> Hmm... any idea why cairo on windows would fail to load?
14:03:21 <geekosaur> does it bundle windows libraries? if not, you probably need to find windows gtk libraries for any of it to work
14:03:24 <LadyAurora> "the devs are morons" is always a good explanation
14:03:39 <khyperia> I do have the windows gtk libraries
14:03:51 <khyperia> they're on my path, etc
14:03:56 <geekosaur> does it know where to find them?
14:04:10 <khyperia> It *installed* fine, just fails to load
14:04:11 <geekosaur> (windows is really annoying that way, there is no standard mechanism for finding devel libraries)
14:04:13 <geekosaur> oh
14:04:23 <geekosaur> that I have no idea :/
14:04:59 <LadyAurora> khyperia: does the arch/bitness match?
14:05:10 <khyperia> how do I check?
14:07:33 <LadyAurora> All ways I can think of, like running objdump on the libraries, are terrible hacks.
14:08:00 <khyperia> And what are you even talking about? The gtk libraries?
14:08:10 <khyperia> A couple binaries in there say win64, so it should be good
14:08:15 <LadyAurora> Yes.
14:08:41 <LadyAurora> khyperia: and the program binary is win64 too?
14:08:49 <khyperia> what program binary?
14:09:09 <LadyAurora> I don't know.
14:09:19 <LadyAurora> The thing that attempts to load cairo.
14:09:35 <khyperia> I'm installing yi, which loads cairo in the process of installing
14:10:15 <LadyAurora> So if I were you, I'd try win32 GTK stuff.
14:10:39 <LadyAurora> Unless GHC can be told to generate win64 code, which I'm not sure is possible.
14:12:11 <geekosaur> I think it's upcoming? wasn't that one of the things fpcomplete was doing?
14:12:48 <LadyAurora> geekosaur: future is irrelevant when the present is your concern
14:13:07 <geekosaur> but it is quite relevant to "which I'm not sure is possible"
14:13:16 <geekosaur> it is possible, someone just had to do the work
14:13:21 <geekosaur> ghc hq is mostly linux...
14:14:21 <khyperia> win32 binaries did not work
14:18:31 <sx> i'm trying to parse a large file (~150mb), each line is parsed into a struct, resulting into a list of that struct. at the moment i'm using parsec with string (which is most likely both a problem), is there a way i can parse each line lazy?
14:19:00 <sx> because i need only 2 lines at a time
14:22:12 <joelteon> attoparsec supports that iirc
14:24:17 <pavonia> Is Parsec not parsing lazily?
14:27:48 <jxv> I'm a little confused about netwire's stepSession vs stepWire. Should I grab the 's' from stepSession then give it to stepWire?
14:34:50 <khyperia> Can anyone help me with this yi problem?
14:35:51 <merijn> Any experienced pipes users around? (specifically pipes-parse)
14:35:52 <nstdloop> Hey guys. I am writing a basic text based rpg and want to do it in Haskell. I'm not really sure how I should structure it or how I should make it interface with user input. I would appreciate any guidance/tips.
14:36:04 <hpc> nstdloop: try #haskell-game
14:39:31 <nstdloop> hpc: I will
14:42:31 <enigmuriatic> does anyone have a good source discussing which prelude functions are implemented in assembly?
14:43:01 <merijn> enigmuriatic: Everything mentioned in Primops, most likely
14:43:02 <monochrom> I am a good source. and the answer is: almost none.
14:43:21 <merijn> enigmuriatic: Although pretty much nothing in Prelude consists of primops
14:43:30 <merijn> enigmuriatic: Also, define "implemented in assembly"
14:43:59 <LadyAurora> enigmuriatic: probably nothing
14:44:29 <LadyAurora> Expect Haskell and some very tiny bits of C, I'd guess.
14:44:36 <enigmuriatic> i mean, at some point things have to be directly converted into machine code, right?
14:44:50 <enigmuriatic> for example, i can't find the definition of (+) in Prelude
14:45:04 <LadyAurora> enigmuriatic: yes, that's what GHC does. It's a compiler.
14:45:14 <merijn> enigmuriatic: The implementation of (+) depends on the type
14:45:43 <LadyAurora> enigmuriatic: the actual implementation of (+) for types like Int is a primop
14:45:43 <merijn> enigmuriatic: Just because GHC generates assembly for functions, doesn't mean those functions have to be implemented in assembly
14:45:56 <merijn> enigmuriatic: Most C compilers are implemented in C
14:46:07 <merijn> Not in asm
14:46:35 <LadyAurora> enigmuriatic: IOW, it's implemented in the compiler itself. Which happens to be Haskell, but could be anything else if the devs wanted.
14:46:52 <LadyAurora> merijn: GCC and Clang are in C++
14:46:58 <enigmuriatic> LadyAurora: that's what i meant, i didn't word it well
14:47:11 <enigmuriatic> LadyAurora: you are correct, GCC just switched to C++
14:48:00 <LadyAurora> enigmuriatic: about a year ago, you mean?
14:48:04 <enigmuriatic> yeah
14:48:09 <merijn> LadyAurora: I'm pretty sure gcc was C last I checked?
14:48:12 <enigmuriatic> in terms of C, that's "just" :P
14:48:17 <geekosaur> it was a recent switch
14:48:20 <LadyAurora> merijn: not since 4.8
14:48:24 <geekosaur> but yes, they have apparently switched
14:48:44 <merijn> "gcc -v" -> "gcc 4.2.1" that might explain :D
14:49:05 <LadyAurora> Apple or BSD?
14:49:11 <merijn> Yes :p
14:49:34 <quchen> merijn: That's not good enough, this is a constructive channel after all :-D
14:50:16 <hpc> quchen: but the language isn't constructive!
14:50:54 <merijn> quchen: I'm using both, though :)
14:53:34 <mkscrg> can anyone recommend a trie implementation based on Text (or maybe ByteString)?
14:56:29 <bz> :t (->)
14:56:30 <lambdabot> parse error on input `->'
14:56:40 <merijn> :k (->)
14:56:40 <lambdabot> * -> * -> *
14:56:55 <merijn>  Unless you're confused and looking for lambda syntax
14:57:04 <bz> what's :kind?
14:57:18 <FreeFull> It tells you about the "types" of type constructors
14:57:47 <merijn> bz: Types are to values as kinds are to types
14:57:56 <merijn> i.e. a "kind" is the "type of a type"
14:58:30 <merijn> "1 :: Int" and "Int :: *" (Int has kind *), * being the kind of "normal" fully applied types
14:59:04 <merijn> "Maybe :: * -> *" since "Maybe" takes a type as argument and returns a new type (Maybe Int, for example)
14:59:20 <merijn> Either :: * -> * -> *, since it takes two types as arguments
14:59:25 <bz> :k (<-)
14:59:26 <lambdabot> parse error on input `<-'
14:59:37 <bz> had to try
14:59:49 <merijn> So "->" (a function type constructor) has "* -> * -> *" it takes two types and returns a type
14:59:54 <Bor0> so, if we had data Test x y, :k Test would be * -> * -> * ?
15:00:03 <merijn> Bor0: Correct
15:00:12 <Bor0> cool, that's interesting to know. thanks
15:00:17 <bz> merijn: (->) is right assoc, right?
15:00:24 <jle`> although remember x and y represent types (Int, Bool, etc.), not values
15:00:36 <jle`> typically we represent types with a,b,c... and values with x,y,z...
15:00:41 <merijn> Bor0: You can also have more complex kinds, like so: "data Test f x = Test (f x)"
15:00:44 <jle`> values as in 1, True, etc.
15:00:55 <merijn> Bor0: Here "Test :: (* -> *) -> * -> *"
15:01:08 <merijn> Bor0: Because 'f' takes one argument and thus must have kind * -> *
15:01:31 <merijn> bz: Yes
15:01:35 <Bor0> aha, but why (* -> *) -> * -> *, is it not simply (* -> *) -> * ?
15:01:54 <jle`> giving it a (* -> *) and a * will produce a *
15:01:58 <merijn> Bor0: It takes 'x' as argument to and the end result is a new type
15:02:11 <merijn> The first * is the 'x', the second * is the returned type
15:02:22 <Bor0> ah, right
15:02:43 <Bor0> does notation * -> * have a special name? star-notation or star-arrow notation or something
15:03:01 <merijn> Bor0: GHC calls them kind signatures
15:03:03 <jle`> kind signature?
15:03:05 <jle`> yea
15:03:12 <jle`> just like a -> b is a type signature
15:03:20 <merijn> Bor0: There's even an extension in GHC (KindSignatures) that lets you explicitly write them in your code
15:03:55 <Bor0> is it wrong to call "length :: [a] -> Int" a prototype of the length function?
15:04:05 <LadyAurora> Bor0: data Test f = Test (f Int) would be (* -> *) -> *
15:04:22 <merijn> Bor0: Also, now it should be clear why writing "instance Functor Either where ..." results in a kind error saying that "Functor expects kind * -> *, but is receiving * -> * -> *", since Either has a different kind than Functor expects
15:04:28 <LadyAurora> Assuming that's possible.
15:04:45 <merijn> Bor0: In haskell it's usually called the type signature/type annotation of the length function
15:05:05 <Bor0> ok, type signature and kind signature. remember those :) thanks again
15:05:12 <merijn> Bor0: Since type signatures can be anywhere (even after function definition) there's no real notion of "prototype"
15:05:22 <Bor0> oh, they can?
15:06:25 <merijn> Bor0: Yes
15:07:04 <merijn> Bor0: Haskell requires no ordering on the definition of functions/variables in your source, the only ordering that matters is that one for pattern matching
15:07:09 <Bor0> hmm, that's also interesting, even if it's unusual to put them anywhere else from the start of the code
15:07:32 <Bor0> ah yes, pattern matching overlaps, I received that error a bunch of times :D
15:07:51 <merijn> Bor0: In haskell the most recommended style is to just have them the line(s) before your definition, rather than at the top of the file
15:08:35 <Bor0> yeah, that's what I meant, at the start of each definition
15:10:57 <Bor0> anyway, after today's morning discussion I wrote a post on my blog (which makes it easier for me to remember stuff), so feel free to bash me if what I wrote doesn't make sense at all :) http://haskellmath.blogspot.com/2013/12/understanding-monads-boxing.html
15:12:16 <johnw> I would not use the words "boxing" and "unboxing" to talk about monads
15:12:29 <johnw> it leads toward a container-centric view, which is not what monads are
15:12:44 <scriptor> what view would be better?
15:12:45 <Bor0> yeah, which is why I put those words in quotes. ah, but not in the title
15:12:50 <johnw> it's not that some containers do not have monadic behaviors, but that not all monads even resemble containers
15:13:00 <johnw> scriptor: "computational contexts" in the most accurate and general term I've heard
15:13:05 <scriptor> ah
15:13:13 <Bor0> could you give an example of a monad that doesn't represent a container?
15:13:16 <johnw> IO
15:13:21 <johnw> ()
15:13:29 <johnw> wait, not ()
15:13:30 <Bor0> but couldn't IO be thought of as a small computer in a container?
15:13:33 <johnw> I'm thinking of data Null a = Null
15:13:41 <LadyAurora> () is wrong kind
15:13:47 <Taneb> (->) r
15:13:53 <johnw> yeah, (->) r
15:14:07 <merijn> johnw: How about "monads"? :p
15:14:19 <johnw> the classic quote to remember is: "A monad is a container as much as /bin/ls contains a list of files."
15:14:23 <LadyAurora> johnw: your Null monad is 99% full
15:14:24 <AshyIsMe> does lambdabot do a "seen" command?
15:14:31 <quchen> "a :: (->) r" is a box that contains whatever a applied to the environment yields.
15:14:33 <johnw> merijn: how do you mean?
15:14:43 <AshyIsMe> or rather, my real question, has anyone seen chrisdone recently?
15:14:50 <johnw> AshyIsMe: I've seen him very recently
15:14:53 <merijn> johnw: I was just being pedantic :p
15:15:01 <merijn> AshyIsMe: preflex has a a seen
15:15:06 <merijn> preflex: seen chrisdone
15:15:07 <preflex>  chrisdone was last seen on #haskell 12 hours, 39 minutes and 9 seconds ago, saying: Twey: haha, dat unicode
15:15:30 <johnw> chrisdone was on another IRC server much more recently, but he's asleep now
15:15:39 <AshyIsMe> ah ok
15:15:49 <AshyIsMe> i was gonna ask him how using his haskell shell instead of bash has been ggoing
15:15:58 <Bor0> haskell shell, what? :D
15:16:07 <djahandarie> "hell"
15:16:20 <AshyIsMe> https://github.com/chrisdone/hell
15:16:23 <djahandarie> Wow.
15:16:27 <AshyIsMe> yeah i like the name haha
15:16:29 <djahandarie> I was just joking about the name LOL
15:16:33 <LadyAurora> Haskell's hell.
15:16:43 <Bor0> wow.
15:16:51 <djahandarie> Well, great minds think alike I guess.
15:17:06 <AshyIsMe> he only did it the other week
15:17:21 <AshyIsMe> someone came in here and asked if there was one and chrisdone was like "woah, good idea"
15:17:40 <johnw> Bor0: even Maybe Int is not a boxed Int, since there is no box in the case of a Nothing; it's like a box that can also be a crumpled up ball of cardboard :)
15:17:51 <LadyAurora> Is preflex still around?
15:17:58 <quchen> preflex: seen preflex
15:17:58 <johnw> preflix: seen LadyAurora
15:17:59 <preflex>  what
15:18:01 <johnw> preflex: seen LadyAurora
15:18:01 <preflex>  LadyAurora was last seen on #haskell 10 seconds ago, saying: Is preflex still around?
15:18:05 <begriffs> Hey all, I just released a tool to deploy Haskell web apps to Heroku. https://github.com/begriffs/heroku-buildpack-ghc
15:18:28 <jle`> Bor0: how about Parsers
15:18:31 <Bor0> johnw, that's a nice example. how do you image monads yourself?
15:18:43 <johnw> Bor0: I don't have any concrete image of them
15:18:56 <LadyAurora> I want the link to the monad blog post.
15:19:05 <Bor0> johnw, so, every monad instance is a story about itself?
15:19:11 <johnw> Bor0: you got it!
15:19:26 <jle`> Bor0: yes, monads aren't all 'connected' in some profound way
15:19:30 <LadyAurora> Monad is like two functions that satisfy a bunch of laws.
15:19:41 <LadyAurora> That's all.
15:19:47 <jle`> that's like saying C, Java, Prolog, Haskell all use text editors to write source code
15:19:57 <Bor0> just like if I were to program a bluetooth app in C and each function from the bt API would be a monad, I'd have to refer to the API documentation to understand it
15:20:05 <johnw> when I do think of monads "in the buff", so to speak, I think in terms of adjunctions; but that rarely helps me reason about Haskell monads
15:20:12 <jle`> it's not like understanding text editors will help you understand any of them, or knowing that Haskell is written in a text editor will give you any insight on Java
15:20:39 <jle`> monads aren't really conceptually united in any non-superficial way
15:21:01 <LadyAurora> jle`: but if you know Haskell you don't need insight on Java
15:21:04 <Bor0> what do the laws guarantee for monads in general? besides programmer's expectations
15:21:07 <schell> isn't it just that they implement bind and return?
15:21:18 <jle`> Bor0: well...they guaruntee that they are monads
15:21:20 <jle`> heh.
15:21:23 <quchen> Bor0: Pretty much just that, the programmer's expectations.
15:21:33 <LadyAurora> schell: no, you forgot laws
15:21:34 <quchen> Bor0: For example they say that "return" can't have any effects.
15:21:35 <jle`> i can call anything i want a "List"...but if it doesn't act like a list, it's not really useful to call it a list
15:21:50 <Bor0> I see
15:21:52 <schell> but haskell monads aren't required to obey the laws, correct?
15:22:03 <quchen> schell: Stronly encouraged, but not strictly required.
15:22:05 <schell> they should, but that isn't enforced by the compiler
15:22:06 <jle`> schell: syntactically, no
15:22:06 <LadyAurora> They are, else generic code will break.
15:22:08 <alpounet> for those of you who want to have their minds blown and see monads (and other things) differently, i suggest this talk, by sigfpe (Dan Piponi): http://vimeo.com/6590617
15:22:12 <Bor0> schell, I was told that they aren't. but haskell programmers would look strange at you if you didn't follow the rules :)
15:22:18 <jle`> i can syntactically name anything any nonsense name i want
15:22:22 <schell> exactly
15:22:47 <schell> and whatever can happen will happen - so at some point you should expect a so called monad to break the monad laws :)
15:23:17 <jle`> it is 'syntactically' a monad...but it's not actually what a mathematical/idea of a monad is
15:23:44 <quchen> An important exception here are monads that don't obey the laws, but all of their applications are wrapped up in the program so that the disobedience does not leak out. That's pretty special territory though.
15:23:50 <jle`> Bor0: one non-container example of a monad i am fond of is a Parser function
15:24:01 <Bor0> so I am trying to grasp the philosophy behind haskell. why did they choose to implement all those algebraic abstract structures in practice? is it mostly because of mathematical correctness?
15:24:02 <quchen> And people are of different opinins about those of course.
15:24:05 <jle`> a funcion that takes a string returns a parsed item
15:24:17 <jle`> Bor0: becuase they are useful?
15:24:21 <jle`> why do you implement arrays in C?
15:24:37 <Bor0> but I don't have the notion of functor, or monad, or set in C at all
15:24:39 <quchen> Bor0: Monads were first introduced to conveniently handle IO in Haskell I think.
15:24:53 <quchen> Then further applications of it were found.
15:25:02 <jle`> Bor0: you don't have a lot of useful structures in C either...and a lot of useful structures in C weren't in its predecessor languages
15:25:09 <monochrom> monad is useful. that should end the question.
15:25:13 <jle`> they are just useful structures
15:25:24 <LadyAurora> Monad is the old name for PowerShell.
15:25:43 <Bor0> ok, so it was an accident to find out that monad would be this useful
15:26:10 <merijn> Bor0: The mistakes is thinking that people *started out* with the mathematical structures
15:26:32 <quchen> I don't think it was an accident, it required someone pretty clever to see the connection to categories.
15:26:35 <merijn> Bor0: The original haskell versions didn't have monads and multiple functional languages predate it (SML, Clean)
15:26:40 <monochrom> "but C does not provide ____" is a question for ##c, not for #haskell. why should we be responsible for other people's omissions.
15:26:57 <merijn> Bor0: Over time, as functional programming progressed people figured out what was useful and things got added
15:27:10 <jle`> s/functional/any
15:27:20 <LadyAurora> monochrom: ##c is deprecated, use #haskell instead
15:27:20 <Bor0> monochrom, I understand. but I think you missed the context. my question is already answered by merijn, which is Bor0: The mistakes is thinking that people *started out* with the mathematical structures
15:27:22 <merijn> Bor0: By the time haskell was designed functional programming languages had been researched for (help me out here) I think about 15-20 years
15:27:52 * apo helps merijn out, leaves them standing in the rain
15:27:55 <quchen> HM was discovered in the early 70s wasn't it
15:27:56 <merijn> Bor0: So people started designing haskell with several decaded of FP experience and even *then* they didn't know/realise monads were useful
15:28:07 <apo> Tell me when you want in again
15:28:08 * apo runs
15:28:20 <merijn> quchen: That's math, though, not an actual programming language you could run :p
15:28:31 <monochrom> some people do start out with some mathematical structures
15:28:43 <merijn> Bor0: Applicative is even more recent than monad, I believe late 90s?
15:29:07 <quchen> merijn: Sure, but the line is pretty blurry.
15:29:35 <merijn> Bor0: As monochrom mentions *some* people (i.e. researchers with a fetish for that sort of thing) try and pilfer mathematical concepts and apply them to functional programming, the ones that work out get adopted over time. The ones that don't are forgotten
15:30:01 <merijn> Bor0: Others start out programming and think "hey, this all looks the same, I wonder if there's a mathematical definition of this thing"
15:30:19 <LadyAurora> So monads are a fetish! I knew it!
15:30:39 <merijn> Bor0: For some perspective, haskell predates Java by 5-6 years, a lot of trial and error has happened :)
15:31:19 <monochrom> I don't think it is important which side one starts from. well, it may be important for a stamp-collector type historian. but you said "philosophy", not "history". in terms of "philosophy", it is only important that theory and practice work together.
15:31:50 <merijn> Sure, both sides work and to get anywhere you want both types of people
15:31:57 <koala_man> merijn: Lisp predates Haskell by 27-32 years, depending on how you count.
15:32:27 <Cale> I wonder which of those camps we should consider Ed to be in
15:32:32 <merijn> koala_man: Sure, but lisp predates almost everything still in common use by decades, so that feels like an odd comparison :p
15:32:35 <Cale> He's done a lot of both, I think :)
15:32:43 <ystael> merijn: as an inventor of the CT scan said in his Nobel prize lecture - "Fourteen years would elapse before I learned that Radon had solved this problem in 1917." :)
15:33:01 <jle`> there was a big explosion of non-strict & pure languages in the half decade or so preceeding Haskell
15:33:02 <LadyAurora> merijn: Lisp predates itself
15:33:11 <LadyAurora> It wasn't invented, it was discovered
15:33:18 <quchen> Cale: Problem is you can't ask him, or he will tell you that he's just throwing paint at walls.
15:34:49 <koala_man> merijn: I meant, to help you out which how long fp had been researched before haskell
15:36:22 <FreeFull> Haskell is quite a bit different from Lisp
15:36:33 <koala_man> fortunately
15:36:47 <FreeFull> ML family
15:37:00 <LadyAurora> Imagine Haskell in Lips clothings.
15:37:02 <monochrom> well, after 30 years, you expect differences. even Java has slightly different syntax from Algol 60.
15:37:16 <merijn> koala_man: I was thinking "modern" FP, not lisp/scheme style FP
15:37:25 <solrize> @pl xy = [(x,y) | x<-mp, y<-mp]
15:37:25 <lambdabot> xy = [(x, y) | x <- mp, y <- mp]
15:37:25 <merijn> i.e. SML, ocaml, Clean, Haskell type FP
15:37:26 <troydm> how is Haskell ML family?
15:37:29 <koala_man> oic
15:37:50 <ReinH_> solrize: there are no points in that expression :)
15:37:51 <troydm> SML, OCaml and other ML languages are ML family
15:38:07 <solrize> hmm
15:38:08 <troydm> but Haskell, Miranda and Clean or different i think
15:38:12 <merijn> troydm: Who said haskell was ML?
15:38:16 <solrize> @pl mp >>= (\x->(mp>>=return.(x,)))
15:38:16 <lambdabot> (line 1, column 28):
15:38:16 <lambdabot> unexpected ","
15:38:16 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
15:38:16 <troydm> *are*
15:38:23 <merijn> I guess I missed Miranda and Isabelle
15:38:31 <solrize> @pl mp >>= (\x->(mp>>=(\y->return (x,y))))
15:38:31 <lambdabot> (`fmap` mp) . (,) =<< mp
15:38:31 <Cale> Nobody actually wrote The Common Lisp HyperSpec, it just appeared on the Internet one day. The LispWorks company it refers to is a nested set of shell corporations that nobody can figure out who set them up.
15:38:40 <solrize> hehe
15:38:46 <jle`> recursively defined of course.
15:39:12 <Cale> of course
15:39:16 <yesthisisuser> all of this makes me wonder.. what would a more "modern" functional language than Haskell look like.. i.e., what will a modern FP language look like in 10-15 years from now
15:39:30 <merijn> yesthisisuser: Depends which way you wanna go
15:39:31 <Cale> yesthisisuser: Look at Agda and Coq for hints
15:39:43 <ReinH_> > let f = join (liftM2 (,)) in f [1..3] -- solrize
15:39:44 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
15:39:47 <quchen> Idris sounds like a probable intermediate state.
15:39:51 <merijn> yesthisisuser: There's more type stuff (i.e. dependent types like Agda, Coq, Idris and Epigram)
15:39:53 <Cale> Or Idris, yes
15:39:57 <solrize> reinh thanks ;)
15:40:02 <solrize> reinh_
15:40:04 <yesthisisuser> yes, but in terms of syntax.. it's not that different
15:40:04 <stass> merijn: so by modern you mean statically typed?
15:40:10 <FreeFull> Dependent typing is still in its infancy for usefulness for the average fp developer
15:40:16 <stolaruk> Haskell is not very old at all.
15:40:18 <merijn> stass: statically typed, mostly pure
15:40:22 <merijn> stolaruk: Define old?
15:40:31 <merijn> stolaruk: Haskell is 23 years old
15:40:33 <Bor0> what is so special about Coq?
15:40:34 <solrize> yesthisisuser, look at ats ?
15:40:48 <Cale> yesthisisuser: uh... it's even pretty different in terms of syntax
15:40:50 <Bor0> (I only know about it that people use it to prove theorems, but what makes it special?)
15:40:51 <solrize> or disciple?  or even some parts of rust which is not fp at all ?
15:41:05 <stolaruk> merijn: In terms of years, yes I know it was created in 1990 but 1998 was the first standard against which ppl could write books and such
15:41:21 <schell> have you guys heard of anyone implementing their own private hackage?
15:41:26 <Cale> I'd say Coq's syntax is a step backward in lots of ways (It looks more like ML in places), but Agda has some fun things like mixfix operators.
15:41:28 <schell> can cabal do that?
15:41:36 <ReinH> solrize: but you just just prefer f xs = (,) <$> xs <*> xs for readability
15:41:39 <ReinH> *might just
15:41:48 <Cale> But why are we really interested in syntax rather than semantics?
15:41:57 <yesthisisuser> Cale: yeah, I guess it is .. hehehe..
15:42:13 <solrize> reinh hmm i think the listcomp is more readable.  i just thought there was some simple way to do that with >>=
15:42:13 <merijn> Bor0: Coq and Agda have dependent types, which means the types of things can *depend* on values
15:42:23 <solrize> agda has nice syntax
15:42:34 <solrize> but, i'd like to see linear types
15:42:39 <merijn> Bor0: This makes it possible to write functions with a type like "if the argument is True, return a tuple, if it is False, return a list"
15:42:39 <monochrom> I think "type hole" will definitely be common in future functional languages
15:42:43 <ReinH> solrize: depends on if you think applicative syntax is readable :)
15:42:54 <Cale> Agda's actual language syntax seems okay to me, but I hate the standard library's overuse of unicode symbols
15:42:57 <merijn> Bor0: i.e. the type of the function depends on the value of input it gets
15:43:02 <ReinH> "syntax"
15:43:07 <yesthisisuser> so dependent typing is one thing that is going to be there for sure it seems
15:43:07 <Cale> It makes the language really hard on my hands to type
15:43:09 <Bor0> merijn, but can't javascript do that? and javascript has a lot of FP stuff
15:43:18 <monochrom> and maybe some story that supercedes modules and type classes
15:43:20 <jle`> i don't know if you cna say that dependent typing is the way of the future.
15:43:27 <Cale> After an hour or two of playing around with it, my hands are sore
15:43:30 <jle`> it's too early to tell i feel
15:43:41 <merijn> Bor0: Coq and Agda can do it *statically typed*
15:43:54 <stolaruk> Cale: Things like <$> and <*> and >=> are not easy to type, either :(
15:43:56 <donri> Cale: is that with the \bla inputs in emacs agda-mode?
15:43:59 <Bor0> hmm, but, how does that make it statically typed?
15:44:11 <Cale> stolaruk: They're better than constantly reaching over for \
15:44:19 <merijn> Bor0: So it will verify the types are correct, like in haskell. No runtime errors like you'd get in javascript where you just return what you like and if you get it wrong, your program breaks
15:44:22 <jle`> Bor0: look up Learn You an Agda
15:44:24 <jle`> :)
15:44:24 <donri> i haven't really used it but i imagine the foremost problem is learning what \bla to type, since it's not clear from existing code
15:44:25 <Cale> donri: yeah
15:44:32 <ReinH> stolaruk: they're not really that hard to type once you do it a few tymes
15:44:37 <ReinH> *times
15:44:44 <Bor0> hmm, I'll have a look at that, thanks
15:44:44 <merijn> Bor0: That doesn't make it statically typed, I just mean that even thought the type depends on the value, it's still typechecked
15:44:48 <scriptor> and visually they stand out a lot more
15:44:48 <ReinH> (foo) isn't that easy to type either
15:44:56 <Bor0> merijn, yeah I see, that's interesting
15:45:04 <Cale> stolaruk: Those infix operators might be hard to type, but they also occur less frequently than unicode characters do in typical Agda code
15:45:06 <stolaruk> ReinH: Actually I can see they wouldn't be so hard on a Qwerty, I'm tying on a Dvorak
15:45:10 <quchen> ReinH: On some non-US keyboards some of the operators are really awkward though
15:45:20 <monochrom> I recently found that "*.VOB" is hard to type, but that's another story. well, harder than ">>=", really.
15:45:25 <stolaruk> Cale: True they don't appear THAT often
15:45:25 <ReinH> quchen: well I am once again thankful for my American privilege ;)
15:45:30 <donri> ReinH: programmer dvorak-style layout + some autopair editor plugin? easy!
15:45:54 <merijn> quchen: US-International layout is the only correct layout :
15:45:56 <jle`> i always just assumed non-US people had a spare US keyboard they swapped out for when they programmed
15:45:56 <merijn> :p
15:46:05 <ReinH> This is your periodic reminder that Data.Vector is really, really, really fast o_O
15:46:22 <quchen> merijn: I don't even know what that is.
15:46:23 <Bor0> but, I believe some time ago I played with data keyword in Haskell and I managed to have both char and an int in a list
15:46:23 <Saizan>  donri if you have the symbol in the emacs buffer M-x describe-char will tell you how to type it
15:46:43 <Cale> Bor0: Maybe through an existential type
15:46:46 <donri> Saizan: sure. but not from skimming things from random sources like on the web
15:46:50 <stolaruk> Is it easy to remap things in vim
15:46:54 <monochrom> what is "autopair editor plugin"? does it mean "I want to do pair programming, but I am alone, so use an editor plugin to mimick a person"?
15:46:58 <startling> stolaruk: yeah.
15:47:08 <Bor0> Cale, so, it is still possible to do something like that in Haskell? e.g. return either a list or True
15:47:09 <yesthisisuser> vim is basically a big remap
15:47:09 <merijn> quchen: It's the default Dutch keyboard layout, US layout with dead keys for stuff like umlauts/diaeresis and that stuff
15:47:10 <stolaruk> startling: Can you remap EVERYTHING if you really wanted to?
15:47:17 <Cale> Bor0: But in order to make that meaningful, you either lost all information about what the Char and Int were, or you decided on some fixed interface through which you could observe them.
15:47:22 <quchen> merijn: Hm. Sounds like what I've poorly reinvented.
15:47:25 <Saizan> donri: true, but you can copy paste :)
15:47:25 <startling> stolaruk: sure.
15:47:32 <nisstyre> Bor0: the intro to this paper has an excellent description of what a dependently typed language does http://lucacardelli.name/Papers/PhaseDistinctions.pdf
15:47:35 <donri> monochrom: :) it's one name for the type of plugin that adds ) when you type ( etc
15:47:54 <monochrom> oh! that's much more plausible, yeah
15:48:08 <donri> Saizan: sure, one can probably find a work flow for it. i'm just saying, i'd expect it to be one annoyance compared to "ascii programming"
15:48:11 <stolaruk> There must be some sort of vim ready-made remap for Dvorak
15:48:29 <monochrom> "Pair Programming with Eliza: a Monologue"
15:48:30 <donri> stolaruk: why would you need that
15:48:56 <Saizan> donri: yeah, but tbh the most annoying part is indeed reaching for \, i've found
15:49:02 <stolaruk> donri: I can type on both Qwerty and Dvorak and thus would like to be able to use same muscle memory for each layout
15:49:03 <Cale> Bor0: There's also Dynamic/Typeable
15:49:11 <jle`> i like using that negation unicode character but it i feel like the effect of it is lost when you have to put that (.) there
15:49:13 <Cale> :t toDyn
15:49:14 <lambdabot> Typeable a => a -> Dynamic
15:49:15 <startling> donri, hjkl would be a pain with dvorak
15:49:17 <donri> Saizan: okies :) couldn't you remap that to something, though i wouldn't know what i'll admit...
15:49:18 <Cale> :t fromDyn
15:49:19 <lambdabot> Typeable a => Dynamic -> a -> a
15:49:21 <jle`> in order to modify a predicate
15:49:22 <Cale> :t fromDynamic
15:49:23 <lambdabot> Typeable a => Dynamic -> Maybe a
15:49:29 <stolaruk> donri: What startling said
15:49:37 <donri> startling: i hear it's OK with dvorak. it's awful with colemak but why use hjkl anyway
15:49:46 <jle`> donri: hjkl is life
15:49:51 <startling> donri, nethack muscle memory
15:49:54 <donri> hjkl are the least useful keys in vim
15:50:03 <monochrom> <monochrom> I want to refactor that into a function. <eliza> is it because you had a hard time with functions in your childhood?
15:50:07 <jle`> i like having j at my index finger
15:50:13 <startling> donri: eh?
15:50:14 <Cale> > map fromDynamic [toDyn (4 :: Integer), toDyn (pi :: Double), toDyn "Hello"] :: [Maybe Integer]
15:50:15 <lambdabot>   [Just 4,Nothing,Nothing]
15:50:18 <stolaruk> Anyway I'm thinking of learning vim as my Haskell "IDE"
15:50:20 <Cale> > map fromDynamic [toDyn (4 :: Integer), toDyn (pi :: Double), toDyn "Hello"] :: [Maybe String]
15:50:20 <startling> I do stuff like c20j all the time.
15:50:20 <lambdabot>   [Nothing,Nothing,Just "Hello"]
15:50:24 <merijn> monochrom: And how does I don't like this code make you feel?
15:50:33 <Cale> Bor0: ^^ you can do things like that
15:50:40 <jle`> stolaruk: just do it; you will end up using it for more than just Haskell
15:50:48 <stolaruk> jle`: Yeah likely so
15:50:49 <Bor0> I see
15:50:56 <stolaruk> I used to use Emacs but no more
15:51:11 <jle`> stolaruk: find a lot of good plugins though.
15:51:25 <stolaruk> jle`: Yeah I'll google around and whatnot
15:51:36 <LadyAurora> Emacs has evil so
15:51:38 <Cale> Bor0: You practically never want that
15:51:39 <stolaruk> I ordered the O'Reilly Vim book
15:51:44 <donri> startling: i tend to default to text objects and larger motions rather than small motions with counts but alright. there are plenty of other mappings that do the same, like Enter for "line down"
15:51:58 <Bor0> @src toDyn
15:51:58 <lambdabot> toDyn v = Dynamic (typeOf v) (unsafeCoerce v)
15:52:07 <jle`> that was helpful :)
15:52:10 <Cale> Bor0: If you're stuffing a bunch of things into a single list, there's got to be something that they all have in common, because when you take them out of the list again, you're going to do some bunch of things with them.
15:52:31 <monochrom> hey! I think actually the following conversation holds true of most programmers. <programmer> I want to use a class and a method, not a function, for this. <eliza> is it because you had a hard time with functions in your childhood?
15:52:34 <Bor0> Cale, yes, that perfectly makes sense. so, in Agda this is well possible?
15:52:39 <jle`> :t toDyn (4 :: Integer)
15:52:40 <lambdabot> Dynamic
15:52:47 <Cale> If you can decide what those things are, you can instead put those things, applied to the values, into the list.
15:52:52 <LadyAurora> unsafeCoerce is awesome
15:53:02 <startling> donri: fair enough
15:53:05 <Cale> No, Agda doesn't make that any more possible than it is in Haskell.
15:53:25 <startling> donri: I use relative line numbering so it's more natural for me to do hjkl with counts
15:53:43 <Cale> (In fact, I don't think Agda has an analogue of Typeable, even)
15:53:46 <Bor0> Cale, but I was told Bor0: This makes it possible to write functions with a type like "if the argument is True, return a tuple, if it is False, return a list"
15:54:01 <ReinH> Bor0: heterogenous lists are a red herring: they're almost never what you want, and they're as easy to use as they are useful. ;)
15:54:10 <Cale> Oh yes, you can write that type
15:55:02 <donri> startling: but yes switching to dvorak hjkl was the biggest pain point. i tried various mappings like C-hnei (the keys on hjkl) but in the end i just learnt to use the alternatives that are built in
15:55:19 <Cale> Bor0: In a dependently typed language, you could write something like  f :: (x :: Bool) -> (if x then (Bool, String) else [Integer])
15:55:28 <donri> like BS C-p C-n Space
15:55:44 <donri> also C-h is BS so that already works :P
15:55:52 <monochrom> hmm, I have an evil plan. is it doable in Agda? define function monoco from nats to types, monoco 0 = Int, monoco n = [monoco (n-1)]. define list monolist and its type such that monolist!!n :: monoco n
15:56:13 <LadyAurora> donri: C-h is bullshit?
15:56:17 <Cale> monochrom: sure
15:56:22 <donri> backspace
15:56:28 <monochrom> ok good :)  or evil :)
15:56:31 <donri> vim calls backspace <BS>
15:56:44 <Cale> monochrom: You'll need to define some kind of special list type for that
15:56:54 <LadyAurora> I don't know I don't use vim
15:57:02 <monochrom> ok, not so good, but not the end of the world
15:57:07 <Cale> monochrom: But I've done it before
15:57:13 <monochrom> or, not the end of hell :)
15:57:45 <donri> LadyAurora: emacs?
15:57:48 <Cale> Well, maybe there are general list-like types in the library I don't know about which would let you do it directly.
15:58:03 <Saizan> monolist :: List (Sigma Nat monoco) would also work with a specialized !!
15:58:06 <Cale> It's easy enough to imagine a list type which took as its type parameter a type-valued function of the index
15:58:14 <Cale> i.e.
15:58:14 <LadyAurora> donri: ed is the standard text editor
15:58:24 <LadyAurora> donri: yes, Emacs
15:58:24 <donri> \o/
15:58:32 <donri> ok, Bspace then :)
15:58:57 <jinji> Cale: hi
15:59:04 <Cale> jinji: hi
15:59:23 <donri> no wait emacs calls it DEL
16:00:12 <jinji> Cale: I wrote a sentence, could u please have look it in pm
16:00:50 <LadyAurora> jinji: a sentence? Who was the accused?
16:07:50 <triliyn> monochrom: wouldn't that just be monoco n = Int?
16:07:56 <triliyn> oh wait
16:07:57 <triliyn> Never mind
16:12:31 <jinji> Cale,
16:13:29 <dangerouslyNubil> Hey, everyone. Newbie here, if anyone has time for a few questions?
16:13:46 <solrize> don't ask to ask.  just ask ;)
16:14:10 <LadyAurora> Can I ask to ask?
16:14:44 <sipa> yes, as long as the asking-degree is odd.
16:14:45 <solrize> LadyAurora, if you have to ask, you can't afford it
16:14:59 <dangerouslyNubil> Can anyone give me a breakdown on Haskell's whitespace rules? I can't make the parser happy with anything I do.
16:15:34 <solrize> dangerouslyNubil, erm, there's not a one-sentence answer.  look in a tutorial, or paste the code you're having trouble with to lpaste.org
16:16:03 <dangerouslyNubil> Okay, I'll hunt around before I post back here. Thanks
16:17:07 <quchen> dangerouslyNubil: I don't think he meant RTFM. It's just difficult to guess what your specific code error is without seeing it.
16:18:12 <hpc> dangerouslyNubil: rarely in here will you get RTFM as an answer; quite often you will get "what have you tried" though
16:19:03 <yesthisisuser> and please paste your code at http://lpaste.net/new/haskell
16:23:25 <dangerouslyNubil> http://lpaste.net/96570 So here's the code I've been working on for the past hour or so. The only errors I get are parse errors, between the two `putStrLn` calls or the `n <- getLine` call. Indented with only spaces, no tabs
16:24:08 <quchen> Don't indent the case
16:24:09 <solrize> Just Int is not a value
16:24:24 <quchen> Oh and that.
16:24:24 <solrize> i think you mean Just n
16:25:27 <solrize> read n <- getChar    ?     I think you mean getLine  and i don't think you can use read that way
16:25:32 <solrize> read `fmap` getLine
16:25:34 <Cale> monochrom: http://lpaste.net/96571
16:35:06 <merijn> solrize: Incidentally, that's readLn
16:35:09 <merijn> :t readLn
16:35:10 <lambdabot> Read a => IO a
16:35:14 <solrize> oops hehe
16:36:50 <hpc> @src readLn
16:36:51 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
16:36:55 <hpc> almost
16:37:30 <hpc> the difference is that read errors are exceptions at IO-time instead of evaluation time
16:37:46 <ion> @src readIO
16:37:46 <lambdabot> Source not found. It can only be attributed to human error.
16:37:59 <ReinH> Hmm... It's kind of annoying to write Haskell in the school of haskell editor when there's a fully fledged Haskell IDE right next door...
16:38:15 <ion> Something like evaluate $!! (read x)
16:38:45 <ion> Uh, no. It’ll only evaluate to WHNF.
16:38:53 <ion> evaluate . read
16:39:57 <ReinH> aaaand they're gone
16:40:03 <ion> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/System-IO.html#readIO
16:41:54 <mekeor> did you guys read <http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/>? :)
16:43:55 <ion> I have watched the video. ’Twas good.
16:47:32 <mekeor> i don't quite understand those "holes"... :/
16:48:24 <ion> Did you watch the video?
16:48:54 <mekeor> nope :)
16:49:06 <ion> It might make it clearer for you.
16:49:51 <mekeor> the sound is horrible. there is a disturbing beep-tone in the background...
16:50:48 <ion> IIRC the audio gets a bit better after a while.
16:52:07 <Peaker> mekeor: I haven't seen that, but I'm guessing by holes you mean holes in data types, representing derivatives of data types?
16:52:22 <ion> yeah
16:54:32 <mekeor> yep
16:56:57 <Peaker> mekeor: (a, a, a)   if you have one hole in that tuple, then you have one of: (_, a, a) | (a, _, a) | (a, a, _)      the original tuple is a*a*a or a^3.  The one-hole type is: a^2 + a^2 + a^2    or 3*a^2.   a^3 -> 3*a^2 looks familiar! :)
16:58:18 <Peaker> mekeor: the "one hole context" thing is useful as a "cursor" allowing overwriting one of the a's in the original representation
17:00:38 <khyperia> mekeor, reading through that article, is there a datatype in base that defines "data Void" or similar?
17:00:45 <khyperia> I guess I could hoogle it
17:01:08 <ion> Not in base. http://hackage.haskell.org/package/void
17:01:12 <khyperia> ah
17:02:49 <Sgeo> Why does Pipes.Aeson export functions that take a single value and return a Producer, instead of pipes that repeately take data and give data
17:07:41 <mekeor> Peaker: yeah, i got that
17:07:54 <Peaker> mekeor: so what part don't you get?
17:08:00 <startling> Sgeo, you need a first value, I think
17:08:07 <mekeor> uhm. i'm thinkin'. uhm..
17:08:12 <startling> I might be thinking of something else
17:10:03 <mekeor> Peaker: so. let L(a) be the list of a's. then L(a):=1+a*L(a)... uhm. i don't understand what i exactly get when i derive that function/data_type.
17:10:25 <mekeor> Peaker: i mean, i get L(a)=1/(1-a), that's okay, i got that, too.
17:10:44 <mekeor> Peaker: but... uhm. how do i exactly get the type of the zipper?
17:11:01 <Peaker> I didn't watch the video, I'd have to work it out from scratch
17:11:16 <mekeor> i didn't watch the video either. i just read the article
17:14:19 <mekeor> ah, oh. okay. so L(a)=1/(1-L(a)). deriving that and afterwards doing some basic arithmetic on it, you get L'(a)=1/(1-a)^2=L(a)^2. ah, okay.
17:19:27 <mekeor> so, if you have "data Tree a = Empty | Node a (Tree a) (Tree a)", that is T(a)=1+a*T(a)^2. if you derive that, you get T'(a)=a*2*T(a)*T'(a)+T(a)^2 and thus you get T'(a)=T(a)^2/(1-2*a*T(a))=T(a)^2*L(2*a*T(a))......
17:19:58 <mekeor> but what does he mean with "To get the list zipper we take the product of an a with a pair of lists L(*a)." (at <http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/>)?
17:20:26 <zRecursive> What's other difference between "newtype" and "data" besides "newtype only has one constructor" ?
17:20:54 <geekosaur> newtype only exists inside the compiler; it has no runtime representation
17:21:02 <Peaker> zRecursive: only 1 field too
17:21:14 <geekosaur> (in particular it means it doesn't introduce an extra bottom)
17:21:50 <Peaker> geekosaur: it could work for all products, not just newtype if seq wasnt sacred
17:21:54 <zRecursive> geekosaur: Is newtype like macro in lisp ?
17:22:09 <Peaker> zRecursive: no
17:22:37 <zRecursive> Then what does "exists inside the compiler" mean ?
17:22:51 <geekosaur> you could say that it tells the compiler to forget a type
17:23:51 <zRecursive> In "newtype ScreenId = S Int deriving ...", forget what ?
17:23:57 <Peaker> zRecursive: it's just a way to define a new (potentially abstract) data type with the exact same runtime representation as another type, but with different instances attached, and considered a separate type during compilation ("inside the compiler")
17:24:21 <geekosaur> if you use data there, you get a thing that wraps an Int, and takes extra space, and potentially can hold bottom instead of an S Int
17:24:34 <Peaker> zRecursive: easiest to understand via examples
17:24:42 <geekosaur> if you use newtype, it only stores the Int --- but the knowledge that it is an Int is hidden behind the S
17:24:56 <geekosaur> and yes, easiest to understand with examples
17:25:06 <Peaker> zRecursive: newtype Mass = Mass Double ; newtype Temperature = Temperature Double
17:25:44 <Peaker> zRecursive: Mass/Temperature are distinct types at compile-time but compiled into the exact same runtime code
17:25:46 <mekeor> zRecursive: i think, in run-time, a variable (fooN :: NFoo) where "newtype NFoo = NFoo Integer" is really just stored as an integer while (fooD :: DFoo) where "data DFoo = DFoo Integer" is a stored as a pointer on an integer...
17:26:22 <geekosaur> more than that, DFoo is stored as a combination of a constructor slot and a pointer to an Integer
17:26:36 <mekeor> oh, okay :]
17:26:52 <geekosaur> whereas NFoo is just the Integer, but the compiler "forgets" that unless you pattern match the NFoo constructor
17:27:03 <geekosaur> so it lets you "forget" or "hide" the type
17:27:10 <zRecursive> thanks
17:27:11 <geekosaur> without introducing runtime overhead
17:27:34 <Peaker> zRecursive: so compared to using Double for mass/temperature you gain type safety (can't confuse them) and lose no performance
17:32:18 <zRecursive> In "data ScreenDetail = SD { screenRect :: !Rectangle }", will "!" cause the compiler do different things ?
17:33:27 <zRecursive> In fact, i am not sure when i need to add "!" in data fields ?
17:34:03 <mekeor> zRecursive: you might want to take a look at http://www.haskell.org/haskellwiki/Newtype#Examples ;)
17:34:16 <zRecursive> mekeor: thx
17:34:23 <geekosaur> ! forces evaluation
17:34:43 <zRecursive> in runtime ?
17:35:45 <Cale> zRecursive: when you pattern match against the SD constructor, the screenRect will also be evaluated.
17:36:00 <zalzane> im doing project euler problems; why does this solution to 5 run so damn slow http://hastebin.com/luwunekuxu.hs
17:36:23 <zRecursive> Cale: How about no "!" ?
17:37:13 <Cale> zRecursive: then matching against a pattern like  SD x  won't evaluate x
17:37:35 <zRecursive> i need to think it over
17:37:43 <Cale> zalzane: don't use brute force?
17:38:04 <zalzane> i cant think of a solution faster than this one, and the imperative version runs in 5 seconds
17:38:13 <Cale> > foldl1 lcm [1..20]
17:38:14 <lambdabot>   232792560
17:38:16 <zalzane> i assume im doing something really bad that haskell doesnt like but idk what it is
17:38:18 <Cale> done
17:38:25 <zalzane> but thats like cheating
17:38:45 <Cale> Well, if you feel it's cheating, implement lcm (or gcd) yourself
17:38:55 <mekeor> zalzane: you should align your code nicer. also use guards instead of ifs, if possible. take a look at http://hastebin.com/hohitagumi.vhdl
17:39:13 <Cale> gcd is only a couple of lines and it's much faster to compute via the Euclidean algorithm than what you're doing
17:40:10 <zalzane> ill try both
17:40:17 <mekeor> zalzane: or even http://hastebin.com/fixilatipu.vhdl
17:40:27 <ddere> sorry can someone point me to a reference where i can learn about what the '~' char means in haskell function type signatures?
17:40:30 <jle`> how am i to use iterateM_ to iterate a fixed number of times?
17:40:33 <mekeor> mekeor: oh, no. that doesn't work
17:40:52 <Cale> ddere: To the left of => ?
17:41:01 <ddere> Cale: yeh
17:41:05 <Cale> ddere: It's type equality, a ~ b means that a and b must be equal types
17:41:19 <ddere> Cale: aahhhh ok thanks
17:41:22 <ddere> :)
17:41:53 <Cale> I'm not totally sure why they couldn't use = for type equality
17:42:08 <mekeor> zalzane: that code looks nice, IMO: http://hastebin.com/fodexudema.vhdl :)
17:42:15 <Cale> But hopefully for some reason
17:42:21 <zalzane> thanks
17:42:21 <monochrom> @src gcd
17:42:21 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
17:42:21 <lambdabot> gcd x y = gcd' (abs x) (abs y)
17:42:21 <lambdabot>    where gcd' a 0  =  a
17:42:21 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
17:42:37 <zalzane> @src lcm
17:42:37 <lambdabot> lcm _ 0     =  0
17:42:37 <lambdabot> lcm 0 _     =  0
17:42:37 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
17:42:40 <Cale> That source is outdated!
17:42:41 <zalzane> neat
17:42:55 <startling> > gcd 0 0
17:42:56 <Cale> We finally have gcd 0 0 = 0
17:42:56 <lambdabot>   0
17:43:00 <monochrom> yeah, but it is a good starting point
17:43:15 <Cale> (by deleting that stupid special case)
17:43:31 <startling> having 0 as the output of gcd function is weird
17:43:45 <Cale> It is the greatest element of the divisibility lattice
17:43:45 <mekeor> zalzane: but.. uhm. i have no idea about your algorithm :/
17:43:51 <zalzane> yeah its all over hte place
17:43:57 <startling> > gcd 7 13
17:43:58 <lambdabot>   1
17:44:10 <Cale> er, sorry, the least
17:44:19 <Cale> (I was thinking upside down!)
17:44:23 <startling> 1 is a factor of 0
17:44:44 <mekeor> :D
17:44:54 <Cale> n divides m means that there is some k such that n * k = m
17:45:06 <ReinH> Man, Data.Csv is pretty awesome... if that's what you're into.
17:45:16 <mekeor> where k∈Z\{0}?
17:45:23 <startling> Cale, there is some k such that 1 * k = 0
17:45:40 <Cale> mekeor: k in Z
17:46:02 <startling> there is some k in Z such that 1 * k = 0
17:46:10 <Cale> yes there is
17:46:22 <mekeor> n|m <=> n·k=m where |k|<=|n|, k in Z. fine?
17:46:25 <startling> this whole gcd function is wrong :(
17:46:32 <Cale> So 1 divides 0
17:46:47 <Cale> actually, I change my mind, I wasn't thinking upside down
17:46:56 <ij> I'm trying to liftM two heavy IO as onto a function and then loop it with forever. But it seems that the heavy IOs are repeated as well and re-retreived.
17:47:32 <mekeor> O.o
17:47:36 <startling> what is a "heavy IO"?
17:47:46 <ij> Loading of some JPGs for a SDL scene.
17:47:48 <Cale> Every number is a divisor of 0
17:48:05 <startling> Cale: yeah, so it makes sense for gcd 0 0 = _|_
17:48:06 <Cale> But 0 divides nothing except 0
17:48:15 <ij> doSDL >> forever (return do_frames `ap` getVideoSurface `ap` loadJPGs)
17:48:16 <Cale> But 0 divides 0
17:48:38 <jle`> 0 doesn't divide 0...
17:48:49 <jle`> 0/0 is an indeterminate form
17:48:50 <jle`> isn't it?
17:48:54 <Cale> n divides m means that there exists k in Z such that n * k = m
17:48:56 <ij> It is.
17:48:59 <jle`> ah
17:49:00 <startling> jle`: we're not talking about division
17:49:05 <jle`> it divides it in integer divisoin
17:49:09 <jle`> i'm guessing?
17:49:12 <startling> "divides" is a property independent of (/)
17:49:16 <jle`> i see
17:49:20 <Cale> We're talking about divisibility not division
17:49:34 <monochrom> write "x ⊑ y" to mean "x divides y". observe that ⊑ is a partial order. in this order, the greatest lower bound of 14,16 is 2. the greatest lower bound of 0,0 is 0.
17:49:42 <jle`> i understand
17:49:46 <jle`> my error
17:49:51 <jle`> and i feel bad.
17:50:05 <startling> haha
17:50:11 <Cale> Thanks monochrom :)
17:50:12 <startling> "integer division" isn't such a bad way to put it
17:50:22 <jle`> apparently haskell doesn't think so
17:50:28 <jle`> > 0 `div` 0
17:50:29 <lambdabot>   *Exception: divide by zero
17:50:34 <startling> @src div
17:50:35 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
17:50:38 <ReinH> Cale: what's the difference between divisibility and invertibility?
17:50:47 <startling> @src Num Integer
17:50:47 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
17:51:10 <monochrom> reword "divides" to "has a multiple being" to see that it is about multiplication.
17:52:05 <ReinH> I guess another way of putting this is: what is the relationship between groups and meet-semilattices?
17:52:08 <Cale> gcd a b = d if and only if (d divides a and d divides b, and whenever x divides a and x divides b, we have x divides d)
17:52:16 <johnw> ReinH: fyi, the connection between divisibility and invertibility is explored over the course of many chapters in Lawvere's book "Intro to Conceptual Mathematics"
17:52:22 <codygman> How would I get the day out of a LocalTime?
17:52:28 <johnw> there he explores it in the context of sections and retractions of morphisms
17:52:29 <ReinH> johnw: thanks :) I guess I'll be reading that soon
17:52:41 <ReinH> johnw: awesome sounds fascinating
17:53:32 <mekeor> codygman: http://hackage.haskell.org/package/time-1.4.1/docs/Data-Time-LocalTime.html#g:3 maybe?
17:53:44 <Cale> Note the similarity abstractly with the categorical product: P = A x B if there are arrows pi_1: P -> A, and pi_2: P -> B, and whenever we have arrows a: X -> A, and b: X -> B, there is a unique arrow u: X -> P
17:53:49 <ReinH> johnw: ooh I found a PDF :) http://fef.ogu.edu.tr/matbil/eilgaz/kategori.pdf
17:53:58 <johnw> i.e., if composition is like multiplication, then the question "what h fulfills the equation f . h = g or h . f = g?" is a like a question about division, since h sort of equals "g / f" or "f / g"
17:54:06 <mekeor> codygman: that is, utcToLocalTime maybe?
17:54:19 <johnw> and he gives some nice diagrams to help build intuition
17:54:33 <mekeor> codygman: but i'm not sure. i just guessed. dunno
17:54:35 <ReinH> johnw: makes sense
17:54:56 <mekeor> what does "µα.T" mean at http://en.wikipedia.org/wiki/Recursive_data_type#Isorecursive_types ?
17:55:28 <Cale> We can turn the integers into a category where there's a unique arrow n -> m whenever n divides m, and then gcd is the product in that category, and lcm is the coproduct.
17:55:47 <johnw> ReinH: in that PDF, pages 39-135
17:55:49 <ReinH> $30 for the kindle edition isn't terrible compared to some textbooks
17:55:51 <ReinH> johnw: thanks :)
17:56:15 <ReinH> johnw: I splurged on the second edition ;)
17:56:30 <johnw> yeah, I bought the paper too, but I'm reading it as PDF
17:56:52 <johnw> i think I found the 2nd ed. PDF somewhere
17:57:08 <Cale> mekeor: It means the fixed point of the type function \a -> T
17:57:12 <ReinH> johnw: I have it on the kindle now
17:57:23 <johnw> I hope it doesn't mangle the diagrams and equations
17:57:29 <monochrom> presumably, T is a type expression that may use the type variable α. and µα.T means a recursive type based on that. maybe I call the recursive type R? then I can write the equation R = (T except plug R into α)
17:58:12 <ReinH> johnw: kindle layouts have gotten much better
17:58:26 <sansor> hi, why is it not possible to use bang patterns on the type variables? declare something like: type MaybeS a = Maybe !a
17:58:27 <monochrom> you can also say, newtype R = (T exception plug R into α), since we're talking about isorecursive types
17:58:40 <monochrom> s/exception/except/
17:58:45 <codygman> meteor: I'm not sure.. basically I'm trying to get the current time and then convert that to the in the past utc time.
17:58:50 <Cale> I say "the" fixed point, but there's not always one. μ is used to indicate the least fixed point with respect to inclusion, and ν for the greatest fixed point if I recall correctly.
17:58:55 <mekeor> but why is "nat = µα.1+α"?
17:59:08 <mekeor> that'd mean that nat is a type constructor, wouldnt it?
17:59:17 <monochrom> err, newtype R = Ctor (T except plug R into α)
17:59:43 <geekosaur> sansor: type creates an alias
17:59:44 <Cale> mekeor: Well, nat = 1 + nat, right? i.e. it's the disjoint union of a one element type and itself
18:00:01 <geekosaur> sansor: ! is, sadly, not actually part of a type
18:00:01 <monochrom> "data Nat = Unit | Ctor Nat". do you agree?
18:00:08 <mekeor> Cale: yeah
18:00:14 <mekeor> yeah, monochrom
18:00:20 <sansor> geekosaur: or say something like data MyR = MyR {x :: Maybe !Int}
18:00:23 <mekeor> wait. what's Ctor?
18:00:31 <Cale> monochrom is using Haskell syntax
18:00:33 <mekeor> yeah, Suc. okay.
18:00:36 <Cale> right
18:00:38 <monochrom> haskell forces me to tag on a data constructor
18:01:02 <monochrom> I guess if you understand "nat = 1 + nat", I don't need haskell
18:01:19 <mekeor> but i don't understand nat = µa.1+a
18:01:37 <Cale> Well, you can think of that as being like  fix (\a -> 1 + a)
18:01:40 <Cale> at the type level
18:01:47 <mekeor> ah, hm.
18:01:53 <geekosaur> sansor: same problem. it's part of constructor syntax, not part of type syntax; so you can't use it at all in `type`, and in `data` only on the whole (Maybe Int) not inside the Maybe
18:02:06 <mekeor> so it's like nat = 1 + 1 + 1 + ... ?
18:02:09 <monochrom> ok, iff "x = f x", you can write "x = μ a. f a"
18:02:09 <Cale> yeah
18:02:26 <geekosaur> one could imagine a language in which strictness were part of the type system, and then both of those would be legal
18:02:33 <monochrom> if you ask why, it is "definition of μ"
18:02:35 <mekeor> ah, okay, cool :D
18:02:48 <mekeor> so µ is like \ for types, right?
18:02:49 <sansor> geekosaur: ok, that makes sense
18:02:55 <Cale> it's like fix and lambda
18:02:56 <Cale> together
18:02:59 <monochrom> no, it is a quantifier
18:03:00 <geekosaur> but in Haskell it's not actually part of the type system, it's part of a constructor and can only apply to the direct argument of that constructor
18:03:04 <sansor> geekosaur: is there a nice-looking way to achieve what i tried to do?
18:03:09 <Cale> made into its own quantifier
18:03:11 <sansor> geekosaur: i mean
18:03:13 <monochrom> (err, "no" to "like lambda")
18:03:25 <mekeor> hm, okay...
18:03:28 <sansor> geekosaur: force evaluate something that i put in Maybe
18:03:38 <geekosaur> I can't think of one offhand
18:03:41 <Cale> We're not going to pass any parameters to nat, right?
18:03:55 <Cale> So it's not making a type-level function, we're taking the fixpoint of a type level function
18:04:16 <Cale> (without necessarily introducing type-level functions proper into our type system)
18:04:22 <geekosaur> I think you'd have to define your own replacement for Maybe that had a strict constructor (data MyMaybe a = MyNothing | MyJust !a)
18:04:33 <geekosaur> again, because it's part of the constructor, not part of the type
18:04:42 <mekeor> so, finally. nat=1+nat. define f(a)=1+a. then, nat=f(nat)=fix f=µa.1+a   -- or so?
18:04:55 <ij> The frame function doesn't get called and the string isn't printed. Any ideas why? (I think the problem's in the last line.) http://sprunge.us/GhgO
18:05:06 <monochrom> yes
18:05:07 <Cale> yeah
18:05:09 <geekosaur> maybe when the type theorists are done with nat they can come up with somethig :)
18:05:33 <monochrom> fixed points are very easy, once you decide to let the symbols do the work
18:05:43 <mekeor> :D
18:06:06 <Raggi11> would anyone be so kind to explain to me why this always returns the value from the first param? xD http://lpaste.net/96572
18:06:20 <geekosaur> ij, what is the `return` supposed to be doing?
18:06:38 <monochrom> "x = f x iff x = μ a. f a" is a very syntactic law.
18:06:54 <geekosaur> because what it *is* doing is passing up an unevaluated IO action, which forever will ignore
18:06:57 <Cale> Raggi11: because x + (x * x) -> x + 0 -> x
18:07:08 <mekeor> so, you could read "µ" as "fix (λ...", right? because nat=µa.1+a=fix(\a.1+a)   :D
18:07:09 <sansor> geekosaur: ok, so i guess i'll have to seq it manually for that case
18:07:13 <sansor> geekosaur: thanks
18:07:16 <ij> geekosaur, It's needed for "ap" function, which nees the function to be of type "m (a -> b)" or like.
18:07:40 <Raggi11> thanks that somewhat makes sense xD
18:07:54 <Cale> Raggi11: It doesn't use spacing to determine order of operations :)
18:08:03 <monochrom> and μ is defined just to support anonymous recursion, i.e., you can now get rid of the name "x".
18:08:13 <ij> geekosaur, why will it ignore it?
18:08:30 <Cale> mekeor: Yeah.
18:08:33 <geekosaur> I think you're using that incorrectly
18:08:50 <Cale> mekeor: But μ is available even in some type systems where λ at the type level isn't.
18:08:52 <pavonia> Raggi11: Do you know what "where x*y = 0" is doing?
18:08:55 <geekosaur> the problem is, what you're getting out of that is an IO (IO a)
18:08:59 <ij> i'm not good with haskell yet.
18:09:12 <Cale> (but you can always think of it that way)
18:09:16 <Raggi11> no I guess I don't
18:09:33 <Cale> Raggi11: It's defining the function (*)
18:09:44 <ij> geekosaur, Because forever returns m a(IO ()) and >> before it recasts it to IO a(IO IO ())?
18:09:50 <Cale> Raggi11: You're shadowing the Prelude's definition, and replacing it with one that always gives 0
18:09:56 <Cale> (locally to ble)
18:10:38 <mekeor> Cale: wow O.o
18:10:53 <Raggi11> thanks, I'm trying to wrap my head around this xD
18:11:18 <geekosaur> ij: that is expecting to apply a pure function to the result of a couple of monadic functions and return something in the same monad. since you are sending in a "hidden" IO function as the "pure" function, you get back something that is IO (IO ())) instead of (IO ()). `ap` is not what you wanted there
18:11:37 <Cale> mekeor: Well, it's implicitly available in Haskell 98 by defining recursive types, even though Haskell 98 has nothing remotely approximating lambda at the type level.
18:12:11 <geekosaur> (the outer IO gets "run" and its result discarded. unfortunately, what it is discarding is the IO action you actually wanted to "run")
18:12:27 <Cale> (Well, you *do* have parametric type definitions, I suppose...)
18:12:39 <ij> Aha, I see.
18:12:54 <Cale> So perhaps that's a bad example
18:12:56 <Cale> hehe
18:13:05 <ij> geekosaur, hmm, wait. So forever wants a pure function?
18:13:13 <geekosaur> no, ap does
18:13:16 <Cale> :t forever
18:13:17 <lambdabot> Monad m => m a -> m b
18:13:19 <Cale> :t ap
18:13:19 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:13:50 <geekosaur> right, other waty around. t wants a monadic function but you are wrapping yours in `return` as if it were pure
18:13:54 <geekosaur> and even that would be wrong
18:14:32 <ij> By the way, why does ap want a monadic function, not a pure on like liftM*
18:14:48 <Deams> Hi :)
18:15:15 <ReinH> ij: because ap is designed to work with pure functions that have already been lifted
18:15:16 <Cale> Just write  (do surface <- getVideoSurface; scene <- makeScene; frame surface scene) -- maybe it's a little verbose, but it requires no thought to typecheck this in your head.
18:15:17 <byorgey> ij: why do giraffes have long necks instead of short ones?
18:15:23 <byorgey> ij: that's just what ap is.
18:15:50 <ReinH> ij: you might like to consider ap's applicative synonym, <*>, and fmap's applicative synonym <$>
18:15:52 <byorgey> ReinH: that's not really true.  ap works perfectly well with non-pure, non-lifted functions.
18:15:54 <geekosaur> I think you're reaching for applicatives here but I'm still not good with applicatives
18:16:14 <ReinH> byorgey: that's true as well
18:16:24 <ReinH> :t (<$>)
18:16:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:16:28 * hackagebot stats 0.1 - command line statistics  http://hackage.haskell.org/package/stats-0.1 (cheecheeo)
18:16:44 <geekosaur> you might think of `ap` as an early, primitive attempt at applicatives
18:16:52 <geekosaur> (which is suggested by its name)
18:17:16 <ReinH> ij: <$>, a.k.a. fmap,  can be used to lift a pure function, which is more clear if you read its type like (a -> b) -> (f a -> f b)
18:17:37 <ReinH> :t (<*>)
18:17:37 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:18:05 <ReinH> :t (,) <$> [1..3]
18:18:06 <lambdabot> (Enum a, Num a) => [b -> (a, b)]
18:18:12 <geekosaur> in any case, you're probably better off with do notation for now; I'm not sure how to phrase this properly in either applicative or monad-applicative style :/
18:18:30 <geekosaur> at some point I really need to sit down and figure both of those out properly
18:19:15 <ij> I will use do notation as the last resort and try out applicatives before it.
18:19:36 <Cale> Well, you need join, I think.
18:19:55 <geekosaur> yes, I mentioned that earlier
18:19:59 <Cale> join (liftM2 frame getVideoSurface makeScene) will typecheck
18:20:06 <geekosaur> join would do it but it "feels" wrong
18:20:08 <ij> geekosaur, hmm, I didn't notice you did
18:20:13 <Cale> I think you really need join
18:20:39 <Cale> frame is determining from its arguments which computation to execute next
18:20:41 <slack1256> What is the paper by oleg that disscusses the pros and cons of initial and final encoding?
18:20:46 <Cale> Applicative doesn't have that freedom
18:20:56 <slack1256> I don't know even what they are, so...
18:21:05 <geekosaur> urgh. I thought I had mentuoned that, maybe I wiped it out and started replying to something else you said instead
18:21:57 <geekosaur> intended to mention `join` as a continuation to [05 02:04] <geekosaur> ij: that is expecting to apply a pure function to the result of a couple of monadic functions and return something in the same monad. since you are sending in a "hidden" IO function as the "pure" function, you get back something that is IO (IO ())) instead of (IO ()). `ap` is not what you wanted there
18:22:13 <Cale> right
18:22:28 <geekosaur> since join turns an (m (m a)) into an (m a)
18:22:38 <ij> Join solved it.
18:22:52 <Cale> ij: But really, you ought to write the do-block I gave :P
18:22:54 <ij> I have two nice bmps on the screen now! \o/
18:22:56 <geekosaur> ^
18:23:03 <ij> Cale, Why?
18:23:22 <Cale> Easier to manipulate, easier to tell what's going on.
18:23:27 <Cale> join is a weird thing in IO
18:24:01 <ij> do it is then
18:24:03 <Cale> It's like "take this IO action which is going to produce an IO action, and turn it into one which runs the action and then its result"
18:24:15 <Cale> Which is *okay*
18:24:17 <ij> It's not wrong, it's just hard to follow?
18:24:20 <Cale> yeah
18:25:02 <monochrom> you do not have to choose between <*> and do. you can choose between <*> and >>=.
18:25:18 <Cale> Right, you could use >>=
18:25:38 <Cale> which since it looks like you enjoy using >> a lot, you might get also enjoy using >>= explicitly
18:25:45 <Cale> -get
18:26:25 <ReinH> I would definitely write frame using do notation
18:26:30 * hackagebot stats 0.1.1 - command line statistics  http://hackage.haskell.org/package/stats-0.1.1 (cheecheeo)
18:26:40 <ReinH> I can't see any advantage to chaining all those >>'s
18:26:46 <ij> IO actions don't get executed, unless they chain's returned from main?
18:26:53 <Cale> yeah, that's what the do-notation will desugar into anyway
18:27:06 <Cale> ij: right, unless they're part of main
18:27:17 <ReinH> ij: do notation isn't bad at all, it's often the most elegant way to write something
18:27:22 <Cale> ij: (either directly or because they're part of an IO action which is part of main)
18:27:37 <ReinH> ij: also for this makeScene = return Scene `ap` loadBMP "a.bmp" `ap` loadBMP "b.bmp"
18:27:46 <ij> ReinH, I did a bad thing, I read a "considered harmful" and believed it for the wrong reasons.
18:27:52 <ReinH> ij: you might want to look at how that would work in applicative notation:
18:27:53 <Cale> Well, that one's a liftM2
18:28:10 <ij> Cale, I very much liked the lack of mentioning 2.
18:28:15 <ReinH> step 1: pure Scene <*> loadBMP "a.bmp" <*> loadBMP "b.bmp"
18:28:29 <ij> :t pure
18:28:29 <lambdabot> Applicative f => a -> f a
18:28:32 <ReinH> ij: by pure f <*> x = f <$> x
18:28:47 <ReinH> step 2: Scene <$> loadBMP "a.bmp" <*> loadBMP "b.bmp"
18:29:40 <ReinH> which could also be written as liftA2 or liftM2, but this applicative data constructor idiom is quite common so you might as well get used to seing it :)
18:29:56 <ReinH> You'll find it in e.g. optparse-applicative and Data.Csv and so on
18:30:33 <ij> I read this thing about category theory and... is "pure" the "id" of Applicative category?
18:30:37 <Cale> I'm okay with liftM2, but I don't think I'd normally use liftM3, I'd switch to Applicative notation at that point.
18:30:57 <ReinH> Cale: I'm sort of indifferent to liftM2 vs. applicative notation
18:31:12 <Cale> ij: Well... that... Applicative isn't a category
18:31:31 <ReinH> ij: pure is similar to id in a hand-wavy way :)
18:31:54 <ij> Okay, I will understand this one day then.
18:31:55 <Cale> ij: return and (<=<) and the arrows a -> M b where M is a monad give a sort of category, called the Kleisli category for M
18:32:07 <Cale> return gives the identity arrows on that category
18:32:20 <Cale> But Applicatives don't have that
18:32:21 <ReinH> For instance, function composition (of endofunctors a -> a) forms a monoid with (.) and id
18:32:45 <Cale> :t (<=<)
18:32:46 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
18:32:49 <ReinH> While monad action composition (of a -> m a) forms a monoid with (>=>), monad composition, and return
18:33:02 <ReinH> *endofunctions
18:33:03 <Cale> ^^ note that this is just like composition, only with arrows of the form a -> m b
18:33:03 <ReinH> sry
18:33:24 <Cale> The monad laws can actually be expressed as:
18:33:26 <ReinH> a.k.a. Kleisli composition
18:33:30 <Cale> return <=< f = f
18:33:34 <Cale> f <=< return = f
18:33:41 <ReinH> compare those to monoid laws :)
18:33:44 <Cale> (f <=< g) <=< h = f <=< (g <=< h)
18:33:53 <Cale> Or the laws for a category's composition
18:33:57 <ReinH> right
18:34:02 <enigmuriatic> so, i'm looking for a provable discrete math algorithm that can be implemented in haskell without too much language-specific weirdness that someone with a cursory knowledge of the language could understand
18:34:14 <ReinH> it's all one big interrelated ball of string I mean math
18:34:20 <ij> This is all a bit ahead of me.
18:34:34 <Cale> (the arrows have different types and the composition of arbitrary pairs of arrows isn't defined, so you get a proper category rather than a monoid)
18:34:39 <ReinH> ij: basically, there is a way in which id and pure are very similar, yes
18:34:44 <ReinH> ij: but it requires a bit of math to show it :
18:34:47 <ReinH> :)
18:35:17 <Cale> enigmuriatic: Does gcd count as discrete math?
18:35:38 <Sgeo> @pl fix $ \x -> x
18:35:38 <lambdabot> fix id
18:35:40 <ReinH> enigmuriatic: for what values of "algorithm" are you accepting answers? :)
18:36:20 <Cale> Maybe a permutations or subsequences function?
18:36:37 <ReinH> ij: are you familiar with folds?
18:36:59 <ij> Only the fold[rl] ones, but not Foldable.
18:37:12 <ReinH> ij: have you ever tried folding functions?
18:37:15 <Sgeo> :t fix $ \loebResult x -> fmap ($ loebResult) x
18:37:15 <lambdabot>     Occurs check: cannot construct the infinite type:
18:37:16 <lambdabot>       t0 = f0 ((t0 -> f0 b0) -> b0)
18:37:16 <lambdabot>     In the second argument of `fmap', namely `x'
18:37:48 * Sgeo goes to cheat
18:37:54 <Sgeo> :t \x -> fmap (\a -> a (loeb x)) x
18:37:54 <lambdabot> Not in scope: `loeb'
18:38:01 <ij> ReinH, In the sens that I've summed lists, yes.
18:38:13 <Sgeo> :t fix $ \loeb -> \x -> fmap (\a -> a (loeb x)) x
18:38:14 <lambdabot> Functor f => f (f b -> b) -> f b
18:38:14 <enigmuriatic> Cale, it does but that is kind of too trivial
18:38:24 <Sgeo> :t fix $ \loeb x -> fmap (\a -> a (loeb x)) x
18:38:24 <lambdabot> Functor f => f (f b -> b) -> f b
18:38:35 <Sgeo> :pl fix $ \loeb x -> fmap (\a -> a (loeb x)) x
18:38:44 <Sgeo> @pl fix $ \loeb x -> fmap (\a -> a (loeb x)) x
18:38:45 <lambdabot> fix (fmap . flip id =<<)
18:38:49 <enigmuriatic> if you assume Euclid's it's trivial and we've already proven Euclid's in class
18:39:02 <Sgeo> Does... anyone intuitively understand how that works?
18:39:15 <enigmuriatic> Cale: i'm looking for something concise but clever, which displays the power of the language in being pure, modular and provable
18:39:49 <ReinH> > let f = foldr (.) id [succ, succ, succ] in f 1 -- ij
18:39:50 <lambdabot>   4
18:39:56 <ReinH> :t foldr (.) id
18:39:57 <lambdabot> [b -> b] -> b -> b
18:40:31 <Sgeo> Ok, I'm having some trouble parsing (fmap . flip id =<<)
18:40:46 <Sgeo> There's two operators in there and it's scaring me a bit
18:40:56 <ReinH> ij: Haskell can infer that the functions have to be endofunctions (of type a -> a). This is, in fact, the endofunction monoid.
18:41:08 <Sgeo> Is it ((fmap . flip id) =<<)?
18:41:23 <Sgeo> :t fix ((fmap . flip id) =<<)
18:41:24 <lambdabot> Functor f => f (f b -> b) -> f b
18:41:30 <Sgeo> Seems to
18:42:46 <ReinH> @unpl (fmap . flip id =<<)
18:42:47 <lambdabot> (\ e -> e >>= \ h -> fmap (\ c -> c h))
18:43:23 <ReinH> @do (\ e -> e >>= \ h -> fmap (\ c -> c h))
18:43:23 <lambdabot> (\ e -> do { h <- e; fmap (\ c -> c h)})
18:45:15 <ReinH> well that wasn't super revealing
18:46:46 <joelteon> I must be crazy
18:46:50 <Sgeo> Ok, dynamically-typed languages are giving me some sort of PTSD-lite thing... saw the word "flatten" in some Haskell docs and got nervous
18:46:53 <monochrom> yes
18:46:57 <joelteon> how do I take IO (Maybe a) and a -> Maybe b and get IO (Maybe b)
18:46:59 <joelteon> without using case
18:47:02 <joelteon> there has to be an easy way to do it
18:47:31 <Sgeo> fmap with bind?
18:47:36 <joelteon> ohhhh
18:47:50 <Sgeo> :t fmap (>>= Just)
18:47:51 <lambdabot> Functor f => f (Maybe b) -> f (Maybe b)
18:47:55 <monochrom> fmap does the case for you :)
18:47:57 <ij> ReinH, Should I do on-paper math of haskell-related ma(th)gic? Or will it come with thinking and time by itself?
18:48:25 <Sgeo> :t fmap (>>= (const $ Just ()))
18:48:26 <lambdabot> Functor f => f (Maybe a) -> f (Maybe ())
18:48:58 <Sgeo> monochrom: actually, it's >>= doing the case, fmap's just doing the IO
18:49:07 <monochrom> oh oops
18:49:14 <Sgeo> wanted to say getting inside, but... there is no right phrasing, is there?
18:50:24 <Sgeo> :t \iom amb -> fmap (>>= amb) iom
18:50:25 <lambdabot> (Monad m, Functor f) => f (m a) -> (a -> m b) -> f (m b)
18:50:35 <Sgeo> @pl \iom amb -> fmap (>>= amb) iom
18:50:35 <lambdabot> flip (fmap . (=<<))
18:51:45 <ReinH> > foldr (+) a [b,c,d] -- ij
18:51:46 <lambdabot>   b + (c + (d + a))
18:52:01 <ReinH> ij: now replace (+) with (.) and drop the parens (b/c composition is associative)
18:52:46 <ReinH> foldr (.) id [f,g,h] = f . g . h . id
18:53:11 <Deams> Someone could guide me on using hlint with winghci?
18:53:47 <monochrom> use hlint at the command prompt
18:54:43 <Sgeo> Could probably add it as a tool
18:55:13 <Deams> Sgeo : That's what I was trying to achieve in fact.
18:59:12 <Deams> Ok I'll forget about windows and go back to Debian. thanks anyway :)
19:03:29 <Sgeo> Deams: is hlint in your path?
19:03:40 <Sgeo> If so, I would just follow what the GHC compiler tool does
19:03:48 <Sgeo> As a guideline
19:19:22 <Deams> Sgeo: I'll check it, thanks :)
19:19:28 <Sgeo> yw
19:34:17 <qwebirc375383> Anyone have a good page on <$> ? I can't seem to find one anywhere.
19:35:27 <roconnor> <$> is fmap
19:36:26 <Sgeo> Sadly, although that is technically completely accurate, it might not give some intuitions on how it's often used
19:36:53 <monochrom> but you can now search with "fmap"
19:37:15 <roconnor> oh
19:37:30 <roconnor> f <$> x <*> y  is liftA2 f x y
19:37:39 <roconnor> f <$> x <*> y  <*> z is liftA3 f x y z
19:40:56 <zRecursive> :t (<$>)
19:40:57 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:45:47 <Sgeo> *sigh*
19:46:09 <Sgeo> Yesod uses conduits which ... I think I prefer pipes. Snap does its own thing. What does Happstack do?
19:46:15 <Sgeo> I just... want to play with pipes
19:47:21 <geekosaur> happstack predates both (and even the enumerators that fathered both)
19:48:20 <Sgeo> Every enumerator-like library seems to want an attoparsec connection
19:50:11 <Sgeo> http://pastie.org/8529816
19:50:41 <Sgeo> Since this do doesn't do anything that requires Monad over Applicative (iiuc), would be nice if it resulted in applicative code
19:50:53 <dmj`> what function is flip fmap?
19:50:57 <dmj`> @typ flip fmap
19:50:58 <lambdabot> Functor f => f a -> (a -> b) -> f b
19:51:11 <enthropy> @type (<&>)
19:51:11 <lambdabot> Functor f => f a -> (a -> b) -> f b
19:51:19 <biscarch> So I have `type Key = ByteString` and I have a function that uses `Key` as a parameter. It works when I pass in a string literal with OverloadedStrings but not when I pass in a ByteString
19:51:21 <dmj`> where's that from?
19:51:25 <enthropy> lens
19:51:39 <dmj`> @typ (&)
19:51:40 <lambdabot> a -> (a -> b) -> b
19:51:43 <dmj`> I see
19:51:45 * hackagebot monoid-subclasses 0.3.4.1 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.3.4.1 (MarioBlazevic)
19:51:54 <roconnor> biscarch: strict or lazy bytestring?
19:52:50 <dmj`> enthropy: any other functions outside of lens? Don't want to introduce another dependency
19:53:17 <enthropy> it might be worth it
19:53:23 <biscarch> roconnor:  Data.ByteString, so Strict I believe
19:53:46 <dmj`> enthropy: you can get pretty far w/ RecordWildCards w/o using lens
19:54:02 <roconnor> both the parameter and function are using the same module?
19:54:46 <biscarch> roconnor:  ah, crap. library is using lazy
19:55:11 <Sgeo> Once fought with an FTP library that used lazy I/O
19:55:12 * Sgeo cries
19:55:28 <roconnor> no library should be using lazy I/O
19:55:35 <roconnor> only very very simple applications.
19:55:44 <biscarch> it's the riak-haskell-client
19:55:46 <Sgeo> This was a few years ago
19:56:21 <enthropy> dmj`: seems a bit messy if you have more than one record to deal with
19:56:28 <biscarch> specifically: http://hackage.haskell.org/package/riak-0.7.0.2/docs/src/Network-Riak-Types-Internal.html#Key
19:56:46 * hackagebot vector-algorithms 0.6.0.1 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.6.0.1 (DanDoel)
19:56:55 <shachaf> pcapriotti++ # free monad post series
19:57:25 <Sgeo> The library was started in 2004.... and updated in 2013
20:00:10 <ReinH> biscarch: show us the ctual code (see /topic)
20:01:13 <Sgeo> :t flip (<$)
20:01:13 <lambdabot> Functor f => f b -> a -> f a
20:01:19 <Sgeo> @hoogle Functor f => f b -> a -> f a
20:01:20 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
20:01:20 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
20:01:20 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
20:01:51 <slack1256> When people discusses initial/final encoding, finally tagless, this is all in the context of DSL in haskell right?
20:01:53 <Sgeo> meh, feels like it would be more intuitive to use flip (<$) sometimes (parsers that if they parse return a specific value)
20:02:14 <slack1256> if so, how do you begin to learn about them?
20:02:22 <slack1256> pure papers? or a book?
20:02:58 <khyperia> Oh. Right. All this time I've been doing "const value <$> parser". *facepalm*
20:03:11 <AshyIsMe> :t (<$)
20:03:11 <lambdabot> Functor f => a -> f b -> f a
20:03:16 <roconnor> @type ($>)
20:03:17 <lambdabot>     Not in scope: `$>'
20:03:17 <lambdabot>     Perhaps you meant one of these:
20:03:17 <lambdabot>       `$' (imported from Data.Function),
20:03:34 <khyperia> ($>) wouldn't make sense, since the left side is pure
20:03:43 <khyperia> and you discard it
20:06:06 <Sgeo> :i (<*)
20:06:27 <dmj`> @typ (<*)
20:06:27 <lambdabot> Applicative f => f a -> f b -> f a
20:06:28 <Sgeo> infixl :)
20:06:33 <Sgeo> Wanted the infix
20:06:55 <Sgeo> err
20:06:56 <Sgeo> Prelude Data.Attoparsec Control.Applicative> pure 1 <* pure 2 <* pure 3
20:06:56 <Sgeo> 1
20:07:20 <khyperia> that would be 1 no matter the fixity
20:07:21 <Sgeo> How... did GHCi manage to avoid complaining about not ... knowing what Applicative instance to use, or something?
20:07:31 <khyperia> use :t ?
20:08:14 <khyperia> looks like it's just (Num a, Applicative f) => f a
20:08:46 <Sgeo> How does it decide it's ok to say it's an Integer, though?
20:09:04 <khyperia> I think it defaults to using Integer if it has a Num at the end
20:09:11 <khyperia> but not sure about how the Applicative works
20:09:17 <biscarch> ReinH: Is this good? http://lpaste.net/96580
20:10:31 <khyperia> although looks like "print $ pure 1" doesn't work... so ghci is doing something weird with defaults
20:10:49 <Sgeo> <* reminds me of prog1. I like prog1
20:11:28 <osa1> anyone knows IRC name of ekmett https://github.com/ekmett/trifecta ? if I remember correctly he was very active on IRC and I need to ask something to him
20:12:12 <startling> osa1: edwardk
20:12:13 <Sgeo> edwardk I think
20:12:24 <osa1> alright, thanks. sending privmsg.
20:13:59 <enthropy> Sgeo: It ends up trying  IO Integer
20:14:56 <enthropy> printf "%d\n" 3 -- in ghci this ends up assuming it's IO
20:21:03 <slack1256> I was disconnected before, restating "how to begin with DSLs in haskell? research paper? a book?
20:26:06 <Saizan> i think there was a workshop not long ago?
20:26:11 <maxiepoo_> slack1256: do you want to write a dsl for a specific purpose or do you just want to know what all the fuss is about?
20:27:05 <Saizan> anyhow most info is going to be in the form of papers or blogs, i don't think there's a book for this
20:27:40 <slack1256> maxiepoo_: what all the fuss is about, specially why is prefereable a initial enconding or a final one.
20:28:19 <slack1256> Saizan: I would like ideally is a succesion of papers "oh read this one first, then this, then that one, etc"
20:28:53 <Saizan> a "final" one can save you from interpretation overhead
20:29:31 <Saizan> but can harm sharing, iiuc
20:29:56 <Saizan> slack1256: i wonder if someone has a reading list like that, maybe edwardk
20:30:34 <slack1256> Usually you can follow the track of "most cited" papers to an original and read your way up
20:30:49 <slack1256> but in this area I am totally lost, because first I don't have a CS background
20:32:11 <enthropy> slack1256: another term to look for is embedded-DLSs
20:35:11 <slack1256> well, that yield more results
20:43:46 <shackleford> How can I create a convenient String or Text representation of a data type which I defined? Say for this arbitrary `Person` type? http://lpaste.net/96581
20:44:41 <shackleford> Like the toString() we use in Java or similar languages.
20:44:54 <dmwit> You already did, with "deriving Show".
20:44:55 <dmwit> no?
20:45:21 <SaaD> I might be way off, but maybe you need to serialize it?
20:45:21 <Saizan> or do you not find that "convenient"?
20:46:21 <shackleford> But its displayed as `Person {name = "Nick", age = 20}`. I mean something such as "name: Nick, age: 20". That can be applied to any `Person` value.
20:46:30 <SaaD> http://hackage.haskell.org/package/cereal
20:47:16 <dmwit> If you want a different format than what Show gives you, just write a pretty-printer.
20:47:34 <Cale> shackleford: Maybe use the aeson library along with its template haskell stuff to get a JSON representation?
20:47:45 <dmwit> It's not too tricky. If you take a shot and get stuck, we can help you get unstuck.
20:48:07 <Cale> Or, well, I don't know what the goal is, if you just wanted a string like you showed, writing it by hand is going to be easier than anything else.
20:49:08 <jle`> is record wildcards considered good style yet
20:49:34 <c_wraith> I think it's pretty accepted
20:49:57 <dmwit> Record wildcards strikes me as one of those things that gets added because it's convenient for writing one-offs, but should be avoided in production code.
20:50:16 <dmwit> I don't have any particular story of where it's bitten me. It just seems to have the same flavor as other things that have bitten me.
20:50:23 <Cale> It's fine, but the one downside I've found is if you ever write some tool to do source -> source translations of Haskell syntax, the wildcards mean that your binders aren't mentioned anywhere.
20:50:49 <solrize> http://alexott.net/en/fp/books/   <--- nice
20:51:22 <Cale> i.e. the actual names of the variables don't appear in the syntax, so if you needed those, you're out of luck :)
20:51:36 <c_wraith> I've seen one use for record wildcards that is really clever - and possibly too clever.  Foo{} <- calculateFuncationsForThisEnvironment
20:51:49 <Cale> oh, that one isn't record wildcards
20:52:00 <c_wraith> Isn't it?
20:52:13 <Cale> That's Haskell 98, whether the type that Foo is defined by is defined using record syntax or not
20:52:43 <c_wraith> oh, I mean when it introduces additional names into scope in the do block
20:52:52 <Cale> Oh Foo{..} then
20:53:00 <c_wraith> oh, whoops
20:53:12 <Cale> It's a special case in the syntax that you can always match against a constructor followed by {} to ignore all of its parameters
20:53:45 <c_wraith> yeah, I just got mixed up there
20:54:16 <Cale> Yeah, that is pretty cute
20:54:40 <Cale> I can see it being really useful when trying to start refactoring really horrible code
20:57:12 <SaaD> Anyone using acid-state?
20:57:16 <jle`> yeah Just{} is syntax for Just _
20:57:46 <ParahSailin> i used acid-state
20:58:02 <SaaD> I'm playing with this example https://github.com/acid-state/acid-state/blob/master/examples/KeyValue.hs
20:58:29 <dmj`> Saad: yea
20:58:32 <slack1256> solrize: just something I was looking for
20:58:33 <chrisdone> shackleford: you can achieve what you want with Data.Data
20:58:34 <SaaD> And wanted to change it, so I could store something different than a String
20:58:45 <SaaD> Namely a [String]
20:59:14 <ParahSailin> [String] is probably an instance of SafeCopy
20:59:30 <ParahSailin> not much you'd have to change
20:59:50 <dmj`> You'll need to migrate, that code doesn't create checkpoints on close though
21:00:23 <SaaD> http://lpaste.net/96582
21:00:24 <ParahSailin> can you use {} record thing if you did not declare the data type with named fields in record syntax?
21:00:35 <ParahSailin> ah yeah if you can use it with Just, i guess so
21:00:47 <ij> Can I make an alternative data constructor for a record?
21:01:16 <enthropy> > case [] of (:) {} -> 1
21:01:16 <SaaD> Checkpoints?
21:01:17 <lambdabot>   *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
21:04:07 <chrisdone> recordwildcards is something i used to use a lot more often than i do now
21:04:14 <SaaD> The last commit to the acid-state project was two months ago... I wonder why it's not more active; it seems an interesting and important project.
21:04:41 <chrisdone> it becomes annoying not being immediately sure whether the name in this context is a function or a variable
21:04:46 <Cale> SaaD: I agree
21:05:07 <SaaD> Is there any other data store that stores haskell data structures?
21:05:20 <khyperia> chrisdone, do you mind if I ask some questions about what the FPComplete local IDE will be like? I have a specific question in mind: Will opening local files be nearly standalone, or will a huge project file hierarchy have to be set up?
21:05:36 <Cale> I think RecordWildCards is something that if you use it sparingly, it's really really good for some very specific sorts of programs, but pretty unnecessary in others.
21:05:42 <khyperia> Specifically, I'd like to know if it's possible for me to open stuff up in the ghc repository and not screw things up
21:05:42 <ParahSailin> SaaD: i ended up moving on from acidstate to using cereal directly
21:05:55 <khyperia> it will be possible*
21:06:01 <ParahSailin> SaaD: but that was only really because i didnt want to keep the whole store in memory
21:06:07 <Cale> In particular, it's very nice for doing object oriented programming in Haskell
21:06:24 <Cale> Where you have record types with lots of functions in them
21:06:58 <chrisdone> khyperia: we're removing the module/file dichotomy which means no name munging, so that should help. no sure how easy it would be to get ghc's to compile without its build system, though
21:07:04 <Cale> and you need to fill in those functions -- it saves you from using lambdas, and you can use pattern matching nicely instead of a bunch of nested case expressions and such
21:07:13 <ParahSailin> SaaD: the problem domain in this case lent itself well to using multiple pages of stores serialized as files with cereal, and an index table in memory
21:07:34 <SaaD> ParahSailin: Why wouldn't you want to keep the whole store in memory? It's way faster that way, and memory is cheap nowadays
21:07:47 <ParahSailin> SaaD: i considered making that an instance of SafeCopy, but wasnt really worth the extra amount i would have had to write to do so
21:08:00 <khyperia> chrisdone, what do you mean by build? Basically I'm just looking for an editor helper, and then the actual compiler is invoked separately - or is this not the features targeted by the IDE?
21:08:23 <ParahSailin> SaaD: hard limit on hardware
21:08:33 <dmj`> Saad: memory isn't cheap, even w/ amazon
21:09:07 <chrisdone> khyperia: i guess you could just use it without the type info/goto definition. it needs to be able to compile the file to do that
21:09:26 <ParahSailin> SaaD: this app had to run on one particular machine with only 8GB, and only a few pages would ever need to be in memory at once, more would just be profligate
21:09:39 <dmj`> SaaD: unless you build your own and colocate, but that has its own costs. You could get a static IP from your ISP, but what if your power goes out.
21:09:41 <chrisdone> dmj`: lol, yeah, i don't know where this saying comes from. “memory is cheap”. it seems to be backed up with nothing
21:09:46 <khyperia> chrisdone, ah. Thanks for the info!
21:09:52 <chrisdone> khyperia: welcome =)
21:09:54 <dmj`> chrisdone: completely agree
21:10:09 <ParahSailin> SaaD: i dont think manager would have taken to the idea that they need to buy more ram for this one machine just so i could basically waste it
21:10:44 <joelteon> anybody know where I can get a binary of happy for ubuntu?
21:11:18 <chrisdone> dmj`: it's why, for example, StackOverflow gzips its page cache, because it's cheaper to compress/decompress than to store it
21:11:44 <SaaD> http://www.newegg.com/Product/Product.aspx?Item=N82E16820161579
21:11:50 <SaaD> Not that bad...
21:12:17 <chrisdone> SaaD: you bought one?
21:13:59 <SaaD> chrisdon: No, just looking at prices... I remember when PC's used to have 64KB ram
21:14:32 <chrisdone> SaaD: at least *your8 memory's not failing =)
21:14:49 <SaaD> lol
21:15:32 <shackleford> Hey, guys. So I did some Googling, and found that (it seems to me. correct me if I) you can use named
21:16:00 <shackleford> Hey, guys. So I did some Googling, and found that (it seems to me. correct me if I'm wrong) you can use named  parameters as functions to get a type's fields
21:16:17 <shackleford> http://lpaste.net/96583 This is what I was going for, is it passable?
21:17:04 <chrisdone> shackleford: fwiw hard tab characters are not recommended for haskell
21:17:58 <shackleford> chrisdone: Yeah, I noticed the parser can be picky.
21:17:58 <solrize> shackleford, you've just shadows the outer definitions of name and age there
21:18:03 <solrize> shadowed
21:19:39 <shackleford> So, am I doing something different than I thought I was?
21:24:18 <dmj`> shackleford: http://lpaste.net/96583
21:25:40 <dmj`> toString is the same thing as show, no need to use "in", ignore my deriving (Read)
21:26:35 <jle`> what does ghc-mod/hlint's "redundant flip" mean?
21:27:22 <shachaf> I assume it means that you have a flip which is redundant.
21:27:37 <dmwit> shackleford: You are doing what you thought you were.
21:27:43 <dmwit> solrize is just confused.
21:27:45 <jle`> shachaf: yeah, but if i take it out...it breaks
21:28:06 <dmwit> And dmj` hasn't been following along.
21:28:27 <dmj`> dmwit: as usual ;)
21:28:28 <dmwit> oh wait, no
21:28:37 <dmwit> dmj` may have been following along, but is giving bad advice. =)
21:28:47 <dmj`> once again, as usual
21:28:50 <dmwit> (It's considered good form for Show instances to produce valid Haskell code as output.)
21:29:24 <dmj`> dmwit: what isn't valid about the string produced
21:29:49 <shachaf> Well, take it out in a non-program-altering way.
21:29:57 <dmwit> > Name: Daniel, age: 32
21:29:57 <lambdabot>   <hint>:1:13: parse error on input `,'
21:30:11 <dmwit> dmj`: According to lambdabot, not enough parentheses to be a tuple. For starters.
21:31:34 <dmj`> > let { name = "me"; age = 99 } in "Name: " ++ name ++ ", age: " ++ show age
21:31:35 <lambdabot>   "Name: me, age: 99"
21:31:44 <dmj`> dmwit: it's valid
21:32:17 <tomberek> let's say i have a type family Next a.  Is there a way to check for cycles at the type level? So Next Int = Double   and Next Double = Int?  I can witness this right now with witness :: TTrue ~ TypeEq Int (Next (Next Int)) => ()  \n witness = undefined. The typechecker will confirm that it is true. Can I create a similar mechanism for cycles of unknown lenght? I've tried to use Fix, but end up with either unapplied type synonyms or 
21:32:19 <dmj`> dmwit: are you looking at the 'updated stuff' section
21:32:48 <jle`> http://lpaste.net/96585
21:32:52 <dmwit> dmj`: No, I'm saying it's good form for the String produced by show to be valid Haskell code.
21:33:00 <shackleford> So, I'm confused now. Which is preferable: The instance of Show, or the toString function? My gut says instance of Show.
21:33:11 <dmwit> shackleford: toString
21:33:26 <dmwit> dmj`: e.g. "Person { name = \"foo\", age = 32 }" is okay, yours is not
21:33:48 <jle`> does it jst mean that i should be switching the arguments?
21:33:50 <dmwit> > show (M.fromList [(32,45)]) -- for another example
21:33:51 <lambdabot>   "fromList [(32,45)]"
21:33:59 <shackleford> dmit:  Why is that?
21:34:09 <dmj`> dmwit: because of Read
21:34:27 <dmwit> shackleford: Primarily so that it's easy to use ghci.
21:34:49 <dmwit> shackleford: If the Show instance produces valid Haskell, you can copy-and-paste to get the value from previous commands.
21:35:10 <dmj`> > read "[1,2,3]" :: [Int]
21:35:11 <lambdabot>   [1,2,3]
21:35:22 <dmwit> dmj`: Show and Read should work together. But that's orthogonal to the advice that show and GHC work together.
21:35:46 <dmj`> dmwit: I didn't write toString, I just made it an instance of show
21:36:32 <dmwit> Yes, I know.
21:36:34 <shackleford> dmwit: So, I should keep it as valid Haskell unless it absolutely needs to be formatted otherwise?
21:36:40 <dmwit> And I'm saying making it an instance of Show is bad advice.
21:37:03 <dmwit> shackleford: Show instances should produce valid Haskell. Functions you write on the side can do whatever they want, of course.
21:38:07 <jle`> it is so tempting ti instance show though because i want to be able to just use print T.T
21:39:51 <dmj`> dmwit: Is it more a stylistic concern?
21:40:04 <dmwit> I gave the reason above: it is so that it is easier to use ghci.
21:41:41 <dmj`> dmwit: data List a = Nil | Cons a (List a) doesn't abide
21:47:53 <jle`> i did not realize that emacs had an IRC client
21:48:59 <tippenein> emacs is an os
21:49:08 <tippenein> :)
21:50:31 <scottj> jle`: emacs doesn't have an IRC client. it has like 3+
21:51:21 <shackleford> tippenein: A whole minute and no one made the "If only it had a good editor" joke. I'm impressed.
21:51:45 <scottj> shackleford: because with evil-mode it does now :)
21:53:24 <tippenein> scottj: my thoughts exactly
21:53:59 <AshyIsMe> i should give evil-mode a  go
21:55:50 <dmj`> its called evil mode for a reason ;)
21:58:05 <shackleford> "The editor wars are over. Vi and Emacs both lost to Sublime." - some guy on the internet
21:59:25 <dmj`> emacs has a full blown lisp, vim has vimscript?
22:02:35 <jle`> did he just log on to comment on emacs and leave?
22:03:11 <jle`> maybe he has a highlight on on the word emacs
22:15:43 <apples> hi, i have a couple questions about this GADT. what's the best way to store a mapping between String and Expr a (where a can be either Int or String here), and how do i perform substitution on all instances of Var in an Expr a using such a mapping? http://lpaste.net/96590
23:12:18 * hackagebot egison 3.1.0 - The world's first language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.1.0 (SatoshiEgi)
23:12:31 <dawik> edwtjo: yo
23:15:09 <dmwit> "unfree"?
23:17:21 <dert> anyone here using OSX 10.9 with macvim for writing haskell?
23:37:11 <chemuduguntar> hi all
23:37:23 <chemuduguntar> I would like to aggregate a list
23:37:42 <chemuduguntar> where i can specify the terms of aggregation
23:38:14 <chemuduguntar> for e.g. with sum ... the initial value is 0 ... and the act of summation adds each elements to the `initial value`
23:38:21 <dmwit> ?src sum
23:38:21 <lambdabot> sum = foldl (+) 0
23:38:30 <dmwit> Though a modern implementation would probably be
23:38:33 <dmwit> sum = foldl' (+) 0
23:38:55 <jle`> chemuduguntar: this 'aggregation' is the definition of a fold
23:39:04 <jle`> you provide your 'act of summation' as the first argument
23:39:08 <jle`> (in your case, it is (+))
23:39:14 <jle`> your 'intial value' as the second argument
23:39:16 <jle`> (in your case, it is 0)
23:39:23 <chemuduguntar> exactly what I need :)
23:39:24 <jle`> and then your list as the final argument
23:40:13 <dmwit> You may also like: foldr, mconcat
23:41:01 <chemuduguntar> thanks :)
23:41:11 <chemuduguntar> was hoping to delay meeting the folds
23:41:14 <chemuduguntar> but here i go
23:41:58 <solrize> foldl' is more modern than foldl ?  hmm
23:42:06 <jle`> more trendy perhaps
23:42:17 <dmwit> Yes, it is more modern.
23:42:41 <jle`> chemuduguntar: i like to think of fold as a 'primitive' operation in functional programming
23:42:53 <jle`> sort of like for loops and while loops in C/imperative programming
23:43:04 <jle`> fold is your bread/butter
23:43:13 <chemuduguntar> is foldr just a orthogonal version of foldl .. from the type signatures it seems they do the same thing if you switched the arguments?
23:43:47 <chemuduguntar> hmm map is something like foldl (:) [] ?
23:43:55 <jle`> foldr is folding backwards, from the right to left
23:43:58 <dmwit> The two folds replace (:) constructors with function calls. foldr associates the function calls to the right; foldl associates the calls to the left.
23:44:05 <dmwit> > foldr f z [w,x,y]
23:44:06 <lambdabot>   f w (f x (f y z))
23:44:10 <dmwit> > foldl f z [w,x,y]
23:44:11 <lambdabot>   f (f (f z w) x) y
23:44:24 <jle`> i had no idea that lambdabot does not complain on undefined functions like that
23:44:32 <dmwit> f is not undefined.
23:44:43 <dmwit> :t f
23:44:44 <lambdabot> FromExpr a => a
23:44:52 <jle`> ah, clever
23:44:53 <dmwit> ?hackage simple-reflect
23:44:53 <lambdabot> http://hackage.haskell.org/package/simple-reflect
23:45:09 <jle`> @info FromExpr
23:45:09 <lambdabot> FromExpr
23:45:20 <solrize> > let mymap f xs = foldr (\y ys -> f y : ys) []  in mymap (*2) [1..5]
23:45:21 <lambdabot>   <[Integer] -> [Integer]>
23:45:25 <dmwit> "@info" auto-corrects to "@undo".
23:45:31 <solrize> what?
23:45:55 <dmwit> solrize: s/xs//
23:46:21 <solrize> > let mymap f  = foldr (\y ys -> f y : ys) []  in mymap (*2) [1..5]
23:46:22 <lambdabot>   [2,4,6,8,10]
23:46:32 <solrize> aha ;)  thanks
23:53:02 <georges> hello
23:53:53 <georges> under the hood is thunk like a function that, when evaluated, gets replaced with a value?
23:54:01 <georges> function pointer*
23:54:16 <dmwit> yes
23:54:53 <dmwit> In fact, it's a function pointer both before and after evaluation. Before evaluation, it jumps to something complicated; after evaluation, it jumps to code that immediately returns.
23:55:01 <dmwit> in GHC
23:55:16 <dmwit> Other compilers are of course free to implement laziness another way. =)
23:55:25 <georges> then fetching list elements causes mutation
23:55:35 <dmwit> Yes, laziness is write-once mutation.
23:56:15 <georges> can this cause any threading issues?
23:56:29 <c_wraith> it would if there wasn't purity
23:56:38 <dmwit> In GHC, the runtime carefully manages all the threading issues.
23:56:42 <c_wraith> purity means the only threading issue is that sometimes things get recalculated
23:56:53 <georges> that is cool
23:56:56 <c_wraith> But the window for that happening is pretty small
23:57:20 <c_wraith> Because GHC actually writes more than once.  It writes a "this is being calculated now" value while it's evaluating a thunk
23:57:38 <c_wraith> And if another thread runs into that, it just waits for the calculation to finish.
23:57:41 <georges> so from the point of view of a haskell programmer no mutation takes place
23:57:48 <c_wraith> right
23:58:36 <c_wraith> Note that GHC actually has two different runtimes, one multithreaded, one single-threaded
23:58:43 <c_wraith> They handle details about this a bit differently
23:59:12 <c_wraith> the single-threaded runtime still writes a "calculation in progress" value, but if it hits it, it crashes with a message saying it went into an infinite loop
23:59:35 <c_wraith> > let xs = tail xs in xs
23:59:38 <lambdabot>   mueval-core: Time limit exceeded
23:59:48 <georges> Is there any difference to consider when using haskell vs OS threads? or is it always safe to evaluate lists in parallel
23:59:50 * dmwit chuckles
23:59:54 <c_wraith> ok, lambdabot is running things with the multithreaded runtime for some reason
