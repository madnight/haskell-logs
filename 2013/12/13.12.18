00:00:39 <mm_freak> noprompt: if the predicate is based on file contents you could do this:  getDirectoryContents >>= filterM (fmap p . readFile)
00:00:59 <mm_freak> if the predicate itself is impure, you can do this:  getDirectoryContents >>= filterM p
00:01:25 <mm_freak> (i'm assuming getDirectoryContents :: IO [FilePath], which is not quite true)
00:01:29 <noprompt> yeah, maybe i'll scratch that for now.
00:01:45 <noprompt> i don't want to write code and not understand it.
00:01:55 <mm_freak> you can understand it
00:02:00 <mm_freak> read the types involved =)
00:02:06 <mm_freak> fmap :: (a -> b) -> IO a -> IO b
00:02:24 <mm_freak> readFile :: FilePath -> IO String
00:03:32 <mm_freak> if you read "IO String" as "ProgramThatResultsInA String", the types should start to make sense
00:05:20 <noprompt> mm_freak: give me a second here. i'm meditating on the fmap bit.
00:06:13 <mm_freak> noprompt: you have an action that produces a String, and you want to get an action that produces the length of that string instead
00:06:19 <mm_freak> you have a function length :: String -> Int
00:06:25 <mm_freak> fmap length :: IO String -> IO Int
00:06:48 <mm_freak> fmap length getLine :: IO Int
00:07:09 <dv-> or length `fmap` getLine
00:07:15 <mm_freak> in other words:  map a pure function over the result of an IO action
00:09:26 <dv-> and you can chain it
00:09:32 <dv-> :t succ `fmap` length `fmap` getLine
00:09:33 <lambdabot> IO Int
00:10:14 <mm_freak> noprompt: unlike in most other languages, actions are first class in haskell…  in other languages (say C) you act on results
00:10:15 <noprompt> ok, i think i'm getting somewhere.
00:10:31 <mm_freak> noprompt: x = getline();  y = f(x);
00:10:36 <mm_freak> in haskell you act on the action itself
00:10:41 <mm_freak> fmap f getLine
00:10:51 <noprompt> mm_freak: right, right. i'm coming from Clojure here if that helps at all.
00:11:17 <mm_freak> i think first class actions are unique to haskell and its decendants =)
00:11:27 <Sgeo> If you've ever passed around a 0 argument function to execute later, possibly repeatedly or not at all, that might give you some idea
00:11:35 <Sgeo> Except IO a are not functions
00:11:37 <mm_freak> descendants
00:12:04 <shachaf> First-class actions are in the mind of the beholder.
00:12:24 <shachaf> I declare that "hello world" is a first-class action, and putStrLn is an interpreter for it.
00:12:42 <shachaf> You can combine actions using (++) (meaning "do this then do that") and so on.
00:13:19 <Sgeo> (defn io-pr [some-string] (fn [] (pr some-string)))
00:13:42 <mm_freak> i don't think it's a bad idea to introduce IO as an action EDSL
00:13:58 <mm_freak> even though there are other possible interpretations
00:14:22 <Sgeo> In Haskell, you're always using the equivalent of io-pr and the like. You don't get to run such things yourself though, ultimately, main gets run
00:14:25 <mm_freak> also i'm not quite sure whether shachaf is disagreeing =)
00:15:44 <noprompt> attempting to make connections between haskell and languages i know, outside of pure functions, has proven to be fruitless.
00:15:54 <noprompt> not being a negtive nancy here. :|
00:16:48 <mm_freak> noprompt: do-notation makes the impression that you're acting on results/values, but that's not the truth
00:17:01 <mm_freak> for IO you're always acting on actions themselves
00:17:06 <Sgeo> Haskell has a tendency to do that, have things named similarly to other things in more common languages, but not being a real connecion
00:17:14 <mm_freak> so to fully understand IO you should probably try without do-notation for a while =)
00:17:33 <mm_freak> remember that every do-block translates into applications of 'return' and (>>=)
00:17:35 <noprompt> the goal of the program should be trivial. get a list of files from a directory, place them in a map by extension, the move them to potentially new directories with the respective name of the extension. ie. all *.bmp files go in bmp/
00:17:40 <mm_freak> (ignoring edge cases)
00:18:05 <Sgeo> Suppose you have getFilePaths :: IO [FilePath]
00:18:29 <Sgeo> getFilePaths >> \filePaths -> {- some code here -}
00:18:32 <Sgeo> oops
00:18:32 <mm_freak> noprompt: first step:  write a function to move a single file
00:18:37 <Sgeo> getFilePaths >>= \filePaths -> {- some code here -}
00:18:45 <Sgeo> That entire expression has a type IO something
00:18:46 <mm_freak> noprompt: move :: FilePath -> IO ()
00:18:53 <noprompt> Sgeo: yes, but that would require me groking >>
00:19:05 <noprompt> mm_freak: ok, i'll start there.
00:19:09 <mm_freak> noprompt: then lift that function to move a list of files:  mapM_ move :: [FilePath] -> IO ()
00:19:11 <Sgeo> On the right of the >>= that \filePaths -> whatever is a function
00:19:16 <noprompt> whoa.
00:19:21 <Sgeo> The argument it gets is a pure value, [FilePath]
00:19:29 <noprompt> eh, erm.
00:19:37 <noprompt> let's stop here guys.
00:19:45 <noprompt> i appreciate you trying to help me.
00:20:31 <mm_freak> noprompt: mapM_ turns A -> IO B into [A] -> IO ()…  if you have an action that acts on something, then mapM_ will turn that action into one that does the same operation for a list
00:20:40 <mm_freak> noprompt: example:  putStrLn :: String -> IO ()
00:20:50 <mm_freak> it writes a single line to the stdout
00:20:51 <noprompt> but it's obvious to me that i need to learn *way* more about haskell before i attempt to do anything.
00:21:00 <mm_freak> mapM_ putStrLn :: [String] -> IO ()
00:21:05 <mm_freak> writes a list of strings
00:21:28 <mm_freak> main = mapM_ putStrLn ["hello", "there", "buddy"]
00:21:30 <AVM2> noprompt have you read Learn You a Haskell?
00:21:33 <mm_freak> try it =)
00:22:17 <noprompt> mm_freak: define "action"
00:22:26 <mm_freak> noprompt: something of type IO A for some A
00:22:32 <noprompt> AVM2: most of it.
00:22:36 <mm_freak> getLine is an action
00:22:54 <mm_freak> main is an action
00:22:57 <mm_freak> main :: IO ()
00:23:07 <noprompt> when i think i understand something, i don't.
00:24:02 <mm_freak> noprompt: don't try to understand this stuff without writing code =)
00:24:17 <noprompt> mm_freak: of course! that's what i'm trying to do!
00:24:18 <noprompt> haha!
00:24:45 <mm_freak> noprompt: it all boils down to understanding the types involved
00:24:59 <gamegoblin> Hi all. Sorry for the dumb question. Had a bit too much to drink and can't think of what to google. How do you impose class constraints in a data declaration? I have a type Tree which is either a leaf or a node, the leaf can be a few types of a certain class and the node just contains two trees. How do I impose the class constraint on the leaf types? Sorry if this makes no sense.
00:25:13 <johnw> you can use GADTs to do that
00:25:16 <Cale> gamegoblin: Which class?
00:25:47 <Ralith> gamegoblin: normally people impose such constraints on the functions that actually require them, not the type definition
00:25:49 <gamegoblin> Cale: I have a class called "SLearner" a tree can either be an SLearner or a pair of two trees
00:25:52 <shachaf> gamegoblin: The usual answer is not to do that in the first place.
00:25:56 <gamegoblin> oh ok
00:26:04 <noprompt> mm_freak: right. this is what i meant by needing to learn more.
00:26:19 <mm_freak> gamegoblin: make that "class" a regular type instead
00:26:30 <shachaf> johnw: I wonder why people keep bringing up GADTs when using GADTs is entirely orthogonal to constraints on constructors.
00:26:43 <mm_freak> gamegoblin: data Tree a = Leaf | Node a (Tree a) (Tree a)
00:26:49 <mm_freak> gamegoblin: Tree Stuff
00:26:54 <gamegoblin> Well SLearner just specifies that all implementing instances just define a "train" and a "predict" function
00:26:59 <mm_freak> data Stuff = IntStuff Int | FloatStuff Float
00:27:00 <noprompt> well thanks for trying to help everyone
00:27:20 <gamegoblin> tbh I should just do this when sober
00:27:23 <mm_freak> noprompt: someone mentioned LYAH…  read it (again)
00:27:26 <Cale> shachaf: Because initially, GADT syntax enabled that
00:27:26 <gamegoblin> thanks for the help
00:27:41 <mm_freak> @where lyah
00:27:41 <lambdabot> http://www.learnyouahaskell.com/
00:29:31 <shachaf> Cale: How initially are we talking?
00:29:53 <shachaf> It looks like it worked fine in 2002.
00:30:02 <Cale> Well, what did?
00:30:14 <Cale> The stupid context?
00:30:28 <Cale> Or actually putting class dictionaries in your data constructors?
00:30:28 <shachaf> No, the context on a constructor.
00:30:40 <Cale> I'm pretty sure that didn't exist at all in 2002
00:30:59 <shachaf> Well, I'm going by haskell/02.11.21:15:51:15 <esap> data Obj f = Functor f => forall a. (XMLDump a) => f a
00:31:17 <shachaf> Which is also an existential but has the Functor constraint on the outside, without a forall.
00:31:29 <Cale> hmm!
00:32:06 <shachaf> I mean, as soon as ExistentialQuantification existed, I'd expect it to work.
00:32:33 <shachaf> It isn't directly existential but it's close.
00:32:44 <shachaf> (enough that you turn it with the same flag in GHC and so on)
00:35:28 * hackagebot monad-logger 0.3.3.2 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.3.2 (MichaelSnoyman)
00:35:42 <paulschellin> So my insomnia has left me intrigued by the "literate" programming concept. Does anyone here have experience with using it in "production" scientific work?
00:42:05 <xintron> In python I've previously used regexp (for simplicity and speed) to parse HTML and extract the <title> value. Would it be more efficient to just parse the html string byte by byte and fetch the value inside title in haskell than using regexp?
00:42:38 <xintron> (maybe my solution to parse byte by byte in Python wasn't efficient enough but it  was hard to come close to the speed of regex)
00:44:59 <arkeet> ok, so copatterns look nice
00:46:07 <bartavelle> xintron, well, nothing prevents you from reusing that regexp in haskell, but this is probably not a great idea
00:46:20 <bartavelle> and there certainly is a library that will do the parsing for you
00:47:34 <xintron> bartavelle, ofc there is a library for it but I thought it would be a good idea to try and parse it manually (as I learn more about haskell)
00:47:36 <bartavelle> xintron, http://hackage.haskell.org/package/tagsoup
00:49:05 <bartavelle> then you should probably look at attoparsec, as you seem interested in performance
00:50:36 <anthezium> anybody know the $foo i can use to get my home directory in a .cabal/config setting?  is it $home?
00:51:56 <paulschellin> anthezium: For most *nix systems the environment variable should be $HOME
00:52:04 <anthezium> yeah but it's not a shell script
00:52:29 <anthezium> are environment variables inherited when .cabal/config is being processed?
00:52:37 <anthezium> there's stuff like $prefix in there
00:52:39 <paulschellin> I'm not familiar
00:52:41 <anthezium> but they're all lower-case
00:54:07 <paulschellin> The config file looks like a bizarre dialect of haskell though, or is that just me?
00:54:17 <anthezium> yup
00:54:24 <anthezium> haskell-style comments @ least
00:54:50 <anthezium> haha
00:54:53 <anthezium> i tried $home
00:55:01 <anthezium> and now it's putting things in ./$home/.cabal
00:55:47 <paulschellin> I think you'd have to change the prefix elsewhere maybe
00:56:54 <anthezium> gah what is this dsl
00:57:09 <anthezium> there must be some way to call a function
00:57:33 <anthezium> or perhaps there is only macro-expansion
01:01:06 <paulschellin> anthezium: The file is parsed here: https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/Config.hs
01:01:21 <anthezium> whoa
01:01:29 <anthezium> thanks dude i was looking for exactly this
01:01:30 <paulschellin> "loadConfig" is the function name
01:02:43 <paulschellin> No problem, though there may be some documentation somewhere that would be faster to find it...
01:14:15 <Cale> shachaf: I'll build GHC 6.2 and try it :)
01:14:25 <Cale> shachaf: I remember this being added in 6.4 myself.
01:14:37 <Cale> (but I could be wrong!)
01:15:06 <Cale> or... see if I can get a binary working :)
01:15:20 <Cale> (Probably tricky to compile such an old GHC with modern base)
02:00:35 <anthezium> paulschellin: as far as I can tell, it looks like those env-var-style things only get expanded sometimes? the PathTemplateVariable sum type seems to cover them, and get used in substituteInstallDirTemplates https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Simple/InstallDirs.hs  I'm confused as to whether this code is invoked when I run cabal, or if it only applies when you're in a directory that contains a .cabal file etc
02:01:50 <dcoutts_> anthezium: the templates are mostly used in the cabal command line flags (and cabal config files, which correspond to command line flags)
02:01:57 <dcoutts_> there are no templates in .cabal files
02:02:27 <dcoutts_> for the most part, the --help says what vars are usable in each case
02:02:30 <anthezium> dcoutts_: what i'm trying to do is understand which things in .cabal/config get template-expanded
02:02:44 <dcoutts_> the same ones as the command line flags
02:03:01 <dcoutts_> so look at the output of --help
02:04:07 <dcoutts_> anthezium: the ones that are not mentioned there are the prefix and other install dirs ones (because that's just the same behaviour as classic ./configure)
02:04:31 <anthezium> dcoutts_: and there's no way to get $HOME, right?
02:04:36 <dcoutts_> nope
02:04:44 <dcoutts_> they're not env vars
02:04:51 <anthezium> this is grasp
02:04:55 <anthezium> *i
02:05:05 <anthezium> but e.g.
02:05:27 <anthezium> remote-repo-cache: needs to be a path
02:05:36 * hackagebot fpco-api 1.0.0 - API interface for the FP Complete API.  http://hackage.haskell.org/package/fpco-api-1.0.0 (ChrisDone)
02:06:05 <anthezium> so i can't do anything like remote-repo-cache: $home/.cabal/packages
02:06:14 <dcoutts_> correct
02:06:25 <anthezium> so i guess i just need to keep different versions of my .cabal/config for different usernames
02:06:36 <anthezium> different $HOME in general
02:06:43 <anthezium> that's too bad
02:07:09 <dcoutts_> it's not an unreasonable feature to want, if you sent in a patch it'd probably be accepted
02:07:21 <dcoutts_> you're not the first to suggest it
02:18:21 <anthezium> dcoutts_: where does the code that performs the substitutions for e.g. $os, $arch live?  the stuff in Simple/InstallDirs.hs is too specific, right?
02:19:26 <dcoutts_> anthezium: no it's all there. Originally this was only for the --prefix --libdir etc, the installation directories
02:19:46 <dcoutts_> and we allowed $os $arch to be used as vars in the install dirs
02:19:59 <dcoutts_> along with $pkgname $compiler etc
02:23:04 <anthezium> dcoutts_: so i'd need to grab the home path from System.something, add a HomeVar constructor to that sum type, add like ++ homeTemplateEnv foo, then shoot pkgId compilerId platform are threaded through as arguments how many levels
02:23:50 <hoknamahn> hello chaps. does anyone know how to decode heterogeneous array like this http://codepad.org/V3ZZDy9C with aeson?
02:23:52 <dcoutts_> anthezium: sounds about right
02:24:42 <quicksilver> hoknamahn: I've not used Aeson in anger but isn't there a fallback type of Value
02:24:49 <quicksilver> so you can decode that as [Value] - array of Values
02:24:51 <quicksilver> something like that
02:25:14 <dcoutts_> hoknamahn: it'll decode it directly to an Array which is a Vector Value
02:25:23 <dcoutts_> so you can then just take it from there
02:27:31 <Cale> lol, who produced that JSON in the first place?
02:28:06 <hoknamahn> Cale, they are the smart guys ;)
02:31:37 <hoknamahn> thanks guys, I'll give it a go
02:32:38 <quicksilver> Cale: there are reasons to have JSON with heterogenous arrays - like a table which is column-homogenous but stored in row-major order.
02:33:28 <hoknamahn> the reason those guys made it as heterogeneous array was ability to read it from a stream in known order
02:35:22 <Cale> I'm not sure why you'd really want that over the convenience of just using a JSON object.
02:36:01 <Cale> (in this case)
02:36:10 <Cale> But I dunno, maybe they have some crazy reason :)
02:37:27 <hoknamahn> their files are huge and they want to be able to read some bits in known order
02:37:33 <hoknamahn> this is what they say
02:37:58 <hoknamahn> not beautiful but works. my first thought was like yours: "lol" :)
02:41:02 <quicksilver> Cale: defined streaming order
02:41:09 <quicksilver> in general
02:42:21 <Cale> quicksilver: Well, what makes defined streaming order important for the things shown in the paste there?
02:43:09 <Cale> You have a file version, and some counts of points, vertices, and primitives
02:43:31 <hoknamahn> Cale, it is just a bit to illustrate what I mean
02:43:39 <hoknamahn> the whole format is more complex
02:44:10 <Cale> hoknamahn: Well, yeah, but you could always pull out the stuff where the order isn't important and structure it better :)
02:44:33 <hoknamahn> in this case order is vital
02:45:12 <Cale> What happens if the point and vertex counts are swapped?
02:45:43 <quicksilver> Cale: no idea, that's why I said "in general" ;)
02:49:52 <hoknamahn> Cale: point is a container for vertices, so if our geometry is a box then we have 24 vertices and 8 points. You cannot swap them.
02:50:56 <Cale> Oh, I see. They're like, giving a count of the number of points and then immediately starting with the first one
02:51:27 <Cale> I think I'd rather nest them :P
02:52:09 <Cale> You could give a count of the number of points and then have a field alongside that which was an array of point objects
02:52:33 <Cale> and then each of those would have a vertex count along with an array of vertices
02:52:39 <Cale> and so on
02:52:52 <Kuhmuhschuh> hi, does 'registerDelay :: Int -> IO (TVar Bool)' create a new thread?
02:55:40 * hackagebot stylish-haskell 0.5.9.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.9.0 (JasperVanDerJeugt)
03:00:05 <m3ga> :t primToST
03:00:07 <lambdabot> Not in scope: `primToST'
03:00:43 <m3ga> :t runST
03:00:44 <lambdabot> (forall s. ST s a) -> a
03:05:46 <gamegoblin> I have the declaration "data Tree = Leaf a | Node (Tree, Tree)". Is there a way to specify a class constraint on the type "a" ?
03:06:08 <FliPPeh> gamegoblin: Only within the functions that operate on that structure
03:06:19 <Hafydd> Not without GADTs.
03:06:37 <Hafydd> Or... something.
03:06:47 <merijn> gamegoblin: Why do you think you want a class constraint on a?
03:06:49 <FliPPeh> foo :: SomeClass a => Tree a -> ...
03:07:13 <gamegoblin> merijn: Because I need to guarantee a certain function will work on it
03:07:24 <merijn> gamegoblin: Then constrain 'a' in the function?
03:07:27 <FliPPeh> Then just have the constraint in that function
03:07:34 <gamegoblin> Gotcha
03:07:42 <gamegoblin> Makes sense I suppose
03:07:57 <FliPPeh> If the function is something fundamental it will propagate anyways
03:07:57 <fryguybob> Kuhmuhschuh: It does not look to me like it does.
03:08:12 <merijn> gamegoblin: The thing is, even if you could add a constraint to "data Tree a", you'd still have to add the constraint to the function *anyway*
03:08:53 <gamegoblin> I know you'd have to add it anyway. For some reason it just feels like without adding it to Tree, "invalid" trees can be created (though not used meaningfully...)
03:09:39 <merijn> gamegoblin: Not if you don't export the constructors from your module
03:10:17 <gamegoblin> merijn : ahhhhh. Good idea.
03:10:17 <merijn> If you only export "empty :: Tree a" and "insert :: Ord a => a -> Tree a -> Tree a" you can only create trees with Ord elements
03:10:42 <gamegoblin> good insight, thanks
03:10:46 <merijn> gamegoblin: You can even specify the only some constructors are exported, rather than all/none
03:10:50 <FliPPeh> "makeLeaf :: SomeClass a => a -> Tree a" is what I'd export
03:11:02 <gamegoblin> Good call, all
03:11:20 <gamegoblin> Now that that problem is solved... bedtime... 5am here. Night.
03:11:37 <donri> merijn: that's awkward though... now you can pattern match but only partially
03:32:27 <jmcarthur> donri: with GADTs that could still make sense, though
03:35:51 <donri> jmcarthur: with gadts you could make it not partial :)
03:36:05 <jmcarthur> donri: that's what i mean
03:36:10 <donri> i know
03:36:28 <donri> although no guarantees ghc will pick up on the totality
03:36:34 <jmcarthur> :(
03:41:52 <donri> yeah :(
04:21:02 <nexx> does the curl package work with the cygwin version of libcurl?
04:31:49 <FliPPeh> So I realize my current approach is probably as elegant as it gets, but I'll try anyways. So have a little state monad that contains a few nested maps ("envChannels :: Map String IRC.Channel" where IRC.Channel contains another map "Map String IRC.ChannelUser"). That means that whenever I modify anything for any user I have to copy the whole channel (not too bad), but I'll also have to copy the whole channel list of unaffected channels so any operation that ch
04:32:08 <FliPPeh> Is there a way to do this better without going all out using MVars or IO?
04:32:35 <quchen_> FliPPeh: No, updating a Map does not copy the entire map.
04:32:47 <quchen_> Most of it can be shared.
04:33:17 <quchen_> Updating an element in a Map requires O(log n) new nodes to be allocated, that's it.
04:33:29 <FliPPeh> I'm not even worried about performance implications, just the whole deal of having the function that should only be concerned with modifying a user having to return the whole channel list still
04:33:42 <FliPPeh> It just doesn't seem nice
04:34:45 <FliPPeh> "renameChannelUser :: String -> String -> String -> ChannelList -> ChannelList"
04:34:53 <FliPPeh> This is what I'd like to avoid
04:35:04 <jmcarthur> FliPPeh: wait, you're sure you want to write haskell? ;)
04:35:05 <FliPPeh> renameChannelUser should not be concerned with the whole channel list, but it *has* to
04:35:20 <FliPPeh> There must be some dark magic that I can conjure!
04:35:29 <jmcarthur> FliPPeh: this is just how purely functional programming works
04:35:30 <FliPPeh> There always is :(
04:35:50 <jmcarthur> i don't see why this is undesirable
04:35:55 <FliPPeh> Sometimes I just miss my beloved C pointers :(
04:37:16 <FliPPeh> Oh well, it's still much nicer now than it was before I discovered Data.Map.alter
04:39:08 <quchen_> You could also use an IORef to keep track of the channel list, learn to hate it, and then come back to the current solution.
04:39:24 <FliPPeh> Yeah nah
04:40:38 <exicer_> I'm using httpconduit, and want to catch all HttpExceptions - is there an easy way of doing it, or do I have to explicitly deal with each constructor?
04:40:50 <kinslayer> So I got a piece of code running downloading json, which runs fine, but how can I make it more robust when the server isn't responding ? for instance it sometimes gives a recv: resource vanished (connection reset by peer)
04:41:12 <FliPPeh> kinslayer: That would be an exception that you can catch
04:41:31 <kinslayer> Okay actually I think I ask the same question as exicer
04:41:40 <exicer_> Yay!
04:41:41 <exicer_> :p
04:41:53 <kinslayer> since I also use that library
04:42:24 <kinslayer> so I just catch some httpException and make it wait a little ?
04:42:56 <FliPPeh> Well, if you get the exception that a resource it vanished, that probably means the http connection is terminated and you need to try again
04:42:59 <exicer_> kinslayer: I think there is a timeout thing you can set in the request
04:43:02 <FliPPeh> I don't think you can wait
04:43:22 <kinslayer> well it fires a new requests everytime so
04:43:25 <exicer_> kinslayer: Then it will just give a timeout exception
04:43:29 <kinslayer> I could wait and try again
04:43:43 <kinslayer> that was what I meant originally
04:44:09 <kinslayer> it is some price data from some exchange...
04:44:34 <exicer_> so if there is a timeout, you want to wait a bit and then make a new request ?
04:45:03 <kinslayer> nono if it says connection reset I wait some seconds and send a new request
04:46:05 <kinslayer> Also I get it inside some IO action and I can't really take the data out of that action while it is running (which it does continuesly), so how can I get the data ?
04:47:55 <exicer_> I'm afraid I'm a bit of a haskell novice, so I don't really know :S
04:48:03 <exicer_> Maybe if you could put it in a paste somewhere ?
04:48:28 <kinslayer> well I am just trying to get my code to do that...
04:48:47 <kinslayer> However for now I should prob. Just implement this exception thing, I am also a bit of a newb... :D
04:49:16 <kinslayer> however I like that this is such a friendly community
05:10:36 <kinslayer> Right so now I should have a somewhat more robust system up and running...
05:16:30 <nexx> I'm trying to install curl on windows, but I'm getting " Missing C library: curl", but it is there. Doing cabal configure with -v3 I see a "-IC:\\Program Files (x86)\\Haskell Platform\\2013.2.0.0\\lib/include" just before cabal complains about a missing foreign library. Could the "/" instead of "\\" be the problem?
05:18:01 <dcoutts> nexx: presumably you are passing --extra-include-dirs
05:18:12 <nexx> dcoutts yes
05:18:27 <dcoutts> nexx: and presumably you are not passing --extra-lib-dirs=
05:19:00 <dcoutts> -I is the flag for the header file search path
05:19:08 <dcoutts> -L is the flag for the lib search path
05:19:25 <nexx> yes, also set CPPFLAGS and LDFLAGS because the configure scritp didn't see the extra parameters
05:19:32 <dcoutts> so that explains why you passing --extra-include-dirs turns into a -I flag
05:19:55 <dcoutts> and why it's still complaining about a missing lib (and not complaining about missing headers)
05:20:26 <dcoutts> nexx: so you usually need to pass both, one to tell it where the headers are, and one for where the libs are
05:20:36 <dcoutts> as they're usually not in the same place
05:20:40 <dcoutts> e.g. include dir vs lib dir
05:20:44 <nexx> oh didn't see your "not"
05:21:20 <nexx> I'm using "--extra-lib-dirs=C:\\cygwin\\lib --extra-include-dirs=C:\\cygwin\\usr\\include"
05:23:18 <dcoutts> nexx: hmm, I'm not sure it'll work to use cygwin libs, since ghc itself is not a cygwin app, but you can always try it and see :-)
05:23:53 <dcoutts> nexx: but what about the C:\\Program Files (x86)\\Haskell Platform\\2013.2.0.0\\lib/ that you mentioned before? where is the curl lib + headers?
05:25:17 <nexx> lib is in C:\cygwin\lib header in C:\cygwinusr\include. The thing with the \ instead of the // is generated by cabal or ghc
05:26:18 <nexx> / instead of \\
05:27:43 <dcoutts> nexx: well, run with -v3 and see what it says when it does the test link, the problem may simply be that the linking fails
05:28:10 <dcoutts> and like ./configure tests, that's interpreted as the C lib being missing (as that's the usual explanation)
05:28:40 <dcoutts> nexx: you could see that it's calling gcc with -IC:\cygwin\usr\include and -LC:\cygwin\lib
05:28:54 <dcoutts> nexx: btw, I'm not sure why you're doubling up the \\'s, does that work on windows?
05:29:25 <dcoutts> will windows just ignore the extra \ ?
05:30:05 <dcoutts> you don't need it for escaping, that's only if you're using Haskell string syntax
05:34:36 <nexx> dcoutts as I said that is from the -v3 output. I don't find any more usefull information in that.  The include and lib folders are also there
05:35:39 <dcoutts> nexx: try running the gcc invocation yourself and see what gcc reports. My suspicion would be that the linking fails because it's a cygwin lib
05:39:23 <nexx> dcoutts how do I generate the .c file? The one which cabal tries to compile gets cleaned up
05:40:22 <dcoutts> nexx: iirc, it's just a simple C main function, but it #includes the headers specified in the .cabal file
05:43:48 <byorgey> Sibi_: Re: Typeclassopedia vs All about monads, my recommendation is: both!
05:44:25 <byorgey> there are bound to be things that each does better than the other.
05:46:39 <Hodapp> I eagerly await a monad tutorial that uses a monad-analogy analogy.
05:47:01 <FliPPeh> Monads are like burritos
05:47:11 <Iceland_jack> “Monads are a lot like monad-analogies, confusing at first but once you understand them they just become annoying.”
05:47:58 <mr-> That's mean. I don't think Monads are annoying. But maybe I don't understand every single analogy either.
05:48:31 <Iceland_jack> Monads aren't annoying but that meta-monad-analogy was a bad one
05:48:50 <Iceland_jack> Analogously to monad-analogies themselves
05:48:53 <kryft> The best way to understand monad-analogies is to just go work with a lot of them
05:48:59 <Iceland_jack> hah
05:48:59 <yitz> Hodapp: search for my comment in this reddit thread: http://www.reddit.com/r/haskell/comments/126dlg/why_are_analogies_and_metaphors_used_so_much_in/
05:49:01 <kryft> -go
05:49:37 <FliPPeh> My favourite analogy is that monads are just fancy values
05:50:17 <mr-> FliPPeh: does that work well with Const Void? ;-)
05:50:30 <FliPPeh> It's a fancy nothing
05:50:55 <mr-> Ok, it's a very good analogy
05:50:57 <augur> Iceland_jack: monads are a lot like monad-analogies -- absolutely essential, provided you have the right ones in mind
05:51:45 <Hodapp> yitz: ....wow
05:52:04 <Hodapp> I'm still partial to 'a dildo factory, staffed by midgets'
05:52:06 <augur> conveniently, (almost?) all functors we use in practice are tuple-like, therefore the container analogy is sufficient.
05:52:35 <augur> really, just understanding lists as monads is almost enough
05:53:31 <timthelion> augur: Monads are a lot like foldr, except people understand foldr and use monads.
05:53:55 <augur> timthelion: i didnt understand foldr for a very long time, until i started learning about initial algebras
05:53:57 <timthelion> The same applies for CPS...
05:54:15 <timthelion> augur: honestly :0
05:54:28 <yitz> augur: initial algebras? isn't foldr.com enough?
05:54:31 <augur> its unfortunate that most explanations of folds are just in terms of lists
05:54:40 <timthelion> The only hard part about foldr, is that foldr and foldl have their arguments in a different order.
05:54:47 <augur> yitz: lol
05:54:58 <augur> timthelion: and they have a different meaning :)
05:55:10 <timthelion> augur: well, since it's explained in terms of lists, it is understandable...
05:55:29 <augur> timthelion: yes, thats what i mean. i only grokked it once i saw more examples of folds for other types
05:55:46 <augur> now i can fold in my sleep!
05:55:50 <timthelion> augur: the thing is that Monads and folds are identical.
05:56:02 <augur> no, they're really not identical even remotely
05:56:08 <quchen_> Was about to say
05:57:01 <augur> i do think that learning about monads made me more comfortable with purely abstract reasoning tho. thank god for catsters
05:57:15 <augur> well, categorical abstract reasoning
05:57:18 <quchen_> You have some monoid business going on in both, but those are distant-cousin-monoids I guess
05:57:37 <augur> you dont have monoid business going on anywhere with folds
05:57:45 <quchen_> You don't?
05:57:49 <augur> no.
05:58:04 <quchen_> Hm, well then I don't know what a fold is.
05:58:13 <timthelion> augur: a list is a f*n monoid. So if a foldr operates on a list...
05:58:13 <augur> quchen_: a fold is an initial algebra. :)
05:58:30 <quchen_> augur: Thanks, now I know what I don't know what a fold is.
05:58:49 <mr-> augur: a fold is the universal arrow from the initial algebra to whatever algebra you want
05:59:09 <augur> timthelion: lists are a monoid with [] and (++), but the fold is not over that structure
05:59:21 <augur> timthelion: foldr is fold over [] and (:) which is not monoidal
05:59:35 <augur> mr-: well yes, more that.
05:59:49 * timthelion cries
05:59:55 <augur> and by more i mean more correctly so. :)
06:00:35 <FliPPeh> magic, got it
06:00:48 <mr-> and then you look at what it means to give an algebra, and it is just what you need to replace the constructors, which is what fold does :-P
06:01:03 <augur> timthelion: to get a true monoidal fold, you need to work with an F-algebra that obeys the monoid laws on its constructors
06:01:19 <mr-> timthelion: there there
06:01:41 <augur> mr-: yep. thats how i really grokked it -- by seeing that in all sorts of places, and then finally understanding this whole business about how its structural recursion
06:02:01 <zett_zelett> Can’t you think about monads just as monads from category theory?
06:02:03 <nexx> dcoutts with the / thing I get "No such file or directory", when I correct it to \\, I get "command not found". For some reason the shell does not find gcc as windows absoulte path. It seems I have to translate the whole thing
06:02:08 <zett_zelett> of*
06:02:09 <timthelion> zett_zelett: nope
06:02:13 <mr-> augur: cool, I first had to understand it for lists, to be able to gernalize
06:02:16 <timthelion> zett_zelett: monads are NOT monads.
06:02:28 <zett_zelett> But I read they’re ALMOST monads?
06:02:30 <augur> zett_zelett: thats what we're talking about, more or less, but that doesnt make it easier!
06:02:38 <mr-> zett_zelett: you can, but that does not help
06:02:41 <quchen_> timthelion: You mean Monads are not monads?
06:02:49 <timthelion> quchen_: :P
06:02:49 <dcoutts> nexx: and with just \ ?
06:02:54 <mr-> timthelion: are you talking about "fail"?
06:02:55 <augur> yeah haskell monads arent true monads because of all sorts of stuff that is essentially irrelevant.
06:03:02 <timthelion> mr-: yes
06:03:05 <quchen_> augur: ⊥?
06:03:23 <mr-> sutpid stupid fail
06:03:24 <augur> quchen_: that, and the lack of laws
06:03:47 <mr-> quchen_: you of all people should know about fail ;->
06:03:56 <quchen_> Never heard of it.
06:04:06 <quchen_> I think it was removed in my private future delusional world
06:04:10 <FliPPeh> :t fail
06:04:11 <lambdabot> Monad m => String -> m a
06:04:58 <timthelion> lambdabot: Can Monads fail?
06:05:04 <nexx> dcoutts the \\ is escaping for the console. In the bash error message the \\ are replaced by \
06:05:12 <mr-> @faq Can Monads fail?
06:05:12 <lambdabot> The answer is: Yes! Haskell can do that.
06:05:47 <dcoutts> nexx: so I'm unclear in what you're saying about what is failing, and what component is reporting the error. A log would help
06:06:30 <mr-> augur: do you also understand unfold that way? ;-)
06:09:15 <timthelion> augur: monads in haskell do not lack laws, so long as you use safe-haskell.  It's just that those laws are only so strict as to cover the type signatures os >>= >> and return.  They are not so strict as to cover the monadic laws.
06:10:13 <augur> timthelion: they most definitely do lack laws
06:10:29 <augur> the laws are expected to hold, but there is nothing in haskell that enforces them
06:10:37 <augur> so you can define non-monads as instances of Monad
06:10:47 <augur> mr-: sort of, yes, actually
06:10:56 * hackagebot ZipperAG 0.3 - An implementationg of Attribute Grammars using Functional Zippers  http://hackage.haskell.org/package/ZipperAG-0.3 (prmartins)
06:11:05 <illissius> hi, any GHC wizards around?
06:11:09 <illissius> it's telling me this: (ghc 7.8)
06:11:14 <illissius>     Could not deduce (i ~ i1)
06:11:15 <illissius>     from the context (f1 i ~ f i1)
06:11:32 <illissius> but shouldn't that exactly imply (f1 ~ f, i ~ i1)?
06:11:56 <opqdonut> not if f1 and f are e.g. type families
06:12:00 <timthelion> augur: you act as if you are some precise mathematician, yet you fail to see simple truths.  Haskell's Monads do have laws(properties that absolutely hold) but these laws are not the monadic laws, they are not even a subset, give that category theory monads are non-typed.
06:12:05 <illissius> type variables can't be type families
06:12:32 <augur> timthelion: whenever people talk about the monads in haskell not having laws, they mean they dont obey the monad laws.
06:13:09 <augur> well, that was an interesting "conversation"
06:13:44 <mr-> I don't get his point
06:14:26 <opqdonut> illissius: eithery you're wrong or I'm misunderstanding you
06:14:54 <mr-> Now I wonder if there's something fundamentally flawed with my take on Monads
06:16:03 <opqdonut> illissius: consider this. I define "type family Foo a; type instance Foo () = (); type instance Foo Bool = ()"
06:16:23 <opqdonut> illissius: now ":t () :: (Foo () ~ Foo Bool) => ()" works in GHC, while "() :: (() ~ Bool) => ()" doesn't
06:16:35 <xnyhps> illissius: I've also noticed that, given type equality constrains are never decomposed. I'm quite curious why.
06:16:47 <opqdonut> illissius: i.e. we have a situateion "f1 i ~ f i1" without having "i ~ i1"
06:16:59 <opqdonut> illissius: (with f=f1=Foo, i=(), i1=Bool)
06:17:26 <illissius> opqdonut: I know type families aren't injective
06:17:34 <illissius> opqdonut: but type variables cannot be instantiated to type families
06:18:36 <opqdonut> ok maybe I'm just misunderstanding the issue. do you have some example code that fails? does it work in another version of ghc?
06:19:21 <illissius> like, you can't go from `Foo a` to `f a` where f ~ Foo, because Foo isn't really a first-class type
06:19:55 <opqdonut> yeah, you're right, Foo behaves like a type synonym
06:20:03 <opqdonut> (for example it doesn't have a kind)
06:22:05 <L8D> Hey, can I get a code review? I am really not sure if I’m sticking to the conventions.
06:22:08 <L8D> https://gist.github.com/L8D/8007803
06:23:04 <illissius> xnyhps: maybe someone should ask on the ML? :-)
06:23:20 <nexx> dcoutts the wrong gcc was used ._. Now I installed it with the libcurl download for windows
06:23:29 <nexx> dcoutts thanks
06:24:20 <dcoutts> nexx: ok good, but just to double check, you are using the gcc that comes with ghc now, and not the cygwin one (as that would not work)
06:24:40 <nexx> yes
06:24:47 <quchen_> L8D: Comments are missing.
06:24:56 <L8D> quchen_: Comments for what?
06:25:13 <quchen_> Exactly.
06:25:42 <xnyhps> It's especially weird because a given f a ~ g b can not be used to solve a wanted f a ~ g b, because the wanted constraint is decomposed before it can interact with the given constraint.
06:26:24 <L8D> quchen_: is there some documentation on the syntax of comments in base?
06:27:28 <mr-> L8D: there is a readMaybe in Text.Read
06:27:54 <L8D> mr-: I don’t like Text
06:28:00 <L8D> nor did I have time to install it
06:28:02 <quchen_> L8D: Not sure what you mean - comments start with "--" and then describe what the code around them does. "execWord" doesn't tell me much, "execWord -- does this with that, careful because `op` is not total" might be helpful
06:28:20 <yogert> L8D: I'm probably not the best person to comment on your code, but for the most part looks good. I'm not sure your approach for the interpreter is the best, and the 'do' in main is superfluous, but in my non expert opinion is looks fine
06:29:04 <L8D> quchen_: look at http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-List.html#take
06:29:36 <mr-> L8D: Text.Read is in base..
06:29:46 <quchen_> L8D: Oh, that is Haddock markup. See http://www.haskell.org/haddock/doc/html/index.html
06:29:48 <mr-> L8D: are you saying you don't have base?
06:29:52 <L8D> quchen_: thanks
06:30:00 <illissius> xnyhps: interesting... I'm heading out right now, but I'll inquire about this on g-h-users when I get back
06:30:09 <L8D> mr-: No, I thought that the Text singleton library wasn’t in base
06:30:30 <quchen_> Haddock makes the HTML comments nice to read but noises the code-level comments up a little.
06:30:32 <xnyhps> illissius: Cool. :)
06:30:44 <quchen_> (If "noising up" wasn't an expression, it is now.)
06:31:14 <mr-> L8D: But I think your code looks fine. It's a bit weird that everything that is not an integer is assumed to be an operator, though
06:31:45 <L8D> mr-: Oh yeah, RL is basically FORTH
06:33:50 <quchen_> L8D: run "10 +" creates a runtime error (because op assumes the list is at least 2 operands long)
06:34:08 <quchen_> Compile it with -W and it'll tell you about the non-exhaustive patterns :-)
06:34:21 <L8D> o.o
06:34:26 <L8D> thanks for telling me that
06:34:39 <quchen_> Hooray for strong typing
06:43:48 <FliPPeh> After having to maintain a fairly large python application
06:43:59 <FliPPeh> Hell yes hooray for strong typing
07:01:48 <exicer_> I'm trying to wrap the exceptions that might arrise from httpconduits httpLbs method. I want the exceptions to instead be Left values. If I have something like: http://lpaste.net/97163, how can I catch these exceptions ?
07:05:05 <FliPPeh> Control.Exception.try actionThatCouldFail
07:05:12 <FliPPeh> Is what I'd do
07:05:22 <FliPPeh> :t try
07:05:23 <lambdabot> Exception e => IO a -> IO (Either e a)
07:06:11 <exicer_> FliPPeh: Will check it out, cheers
07:06:28 <FliPPeh> λ> try (throw . userError $ "HAH") :: IO (Either IOError String)
07:06:28 <FliPPeh> Left user error (HAH)
07:07:09 <FliPPeh> But I will avoid exceptions whereever possible so I may not be the best source of advice :>
07:07:21 <FliPPeh> advise even
07:07:39 <exicer_> FliPPeh: I pretty much want to avoid the exceptions, they are just in the library I'm using
07:16:02 * hackagebot haskoin-protocol 0.0.1.1 - Implementation of the Bitcoin network protocol messages  http://hackage.haskell.org/package/haskoin-protocol-0.0.1.1 (PhilippeLaprade)
07:55:56 <merijn> Does anyone remember which paper introduced the idea of improving values? Google Scholar isn't turning up anything :\
07:59:27 <fryguybob> merijn: conal mentioned a couple papers here: http://conal.net/blog/posts/another-angle-on-functional-future-values
08:10:33 <merijn> fryguybob: I read about them in the push-pull FRP paper, and remember the original idea was from like the late 80s, early 90s (in a functional pearl, maybe?) I guess I should just dig through the push-pull references
08:14:40 <fryguybob> merijn: The link I gave links to http://dl.acm.org/citation.cfm?id=99402  Is that what you are looking for?
08:15:10 <merijn> fryguybob: Oh, that might be it, thanks!
08:18:17 <rck> I keep getting "incomplete input" when using Aeson to decode a JSON string into a data type using eitherDecodeStrict. The data type has 3 constructors and I'm using TH to generate the ToJSON/FromJSON instances
08:18:23 <rck> anyone have Aeson experience?
08:22:27 <WraithM_> Perhaps look at what TH is spitting out. Are you familiar with -ddump-splices (I'm not, it's just what came up when looking for ways to see the output of TH)?
08:24:24 <marx2> :t (\x f g -> f x *> g x) -- is there a function like this that combines f and g?
08:24:26 <lambdabot> Applicative f => t -> (t -> f a) -> (t -> f b) -> f b
08:32:38 <rasfar> marx2: could it be Kleisli?
08:32:45 <rasfar> :t (>=>)
08:32:46 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
08:33:02 <marx2> no. I want to pass a to both functions
08:34:06 <rasfar> :t (&&&)
08:34:07 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
08:34:33 <rasfar> *shrug* back to work...
08:46:41 <supki_> :t liftA2 (*>)
08:46:42 <lambdabot> (Applicative f, Applicative f1) => f (f1 a) -> f (f1 b) -> f (f1 b)
08:47:17 <Taneb> I made GHC 7.6.3 panic accidentally help
08:48:25 <marx2> supki of course.. thanks!
08:48:27 <Taneb> It got confused over a non-existent kind incompatibility
08:48:41 <rasfar> ah
08:48:50 <Taneb> Any GHC chaps wnat to see my code to try and work out how this happened?
08:50:09 <supki_> :t flip . (flip .) $ liftA2 (*>) :: Applicative f => t -> (t -> f a) -> (t -> f b) -> f b
08:50:10 <lambdabot> Applicative f => t -> (t -> f a) -> (t -> f b) -> f b
08:50:36 <tdammers> rck: a pragmatic way would be to check what the ToJSON instance spits out for a given value, and see if that parses back correctly
08:52:03 <c_wraith> Taneb: put sample code on lpaste
08:52:25 <Taneb> c_wraith, I'm not sure how much is need to cause the problem
08:52:47 <c_wraith> Then figure it out.  Or search ghc's trac to see if someone else already has.
08:53:48 <Taneb> Found a single line that if I remove it (and change something else to "undefined") there isn't a problem
08:59:54 <f-a> not sure if the correct channel. I am using Graphics.UI.SDL. Is there any way to resize (as in: double the size) of an image?
09:00:09 <f-a> I am browsing the library on hackage but no dice
09:01:09 * hackagebot ajhc 0.8.0.10 - Haskell compiler that produce binary through C language  http://hackage.haskell.org/package/ajhc-0.8.0.10 (KiwamuOkabe)
09:01:55 <Taneb> c_wraith, http://lpaste.net/97167
09:02:05 <eacameron> so Monads require "return" which places something "inside" the context. Is there a typeclass which does the opposite (for those types for which it makes sense)?
09:02:45 <rasfar> f-a: browsing http://hackage.haskell.org/package/SDL-0.6.5/docs/doc-index-All.html, "image" never occurs. what type is your image?
09:02:58 <c_wraith> Taneb: wow.  That's pretty bad.  The only thing I can say about that is yep, totally broken. check the GHC trac, report the bug if it's not in there.
09:03:49 <BeardedCoder> Anyone mind helping with a typeclass question. https://gist.github.com/ccarter/8025695
09:03:50 <f-a> rasfar: I am currently using blitSurface to blit a surface on the screen
09:04:20 <f-a> hance, Surface
09:04:42 <Taneb> c_wraith, someone beat me to it :) https://ghc.haskell.org/trac/ghc/ticket/8135
09:05:54 <c_wraith> Taneb: that saying ghc 7.8.1 is due "soon" 4 months ago makes me sad. :(
09:06:24 <rck> c_wraith: agreed! is there an eta?
09:06:48 <c_wraith> rck: it's still "soon", afaik
09:07:09 <bernalex> rck: it took me far too long to figure out that you meant ETA and not eta as in... eta reduce.
09:07:13 <c_wraith> However, it's late enough in december that I wouldn't expect it before january at this point.  Too many people taking breaks for the holidays.
09:07:28 <rck> bernalex: haha I did the same thing when rereading
09:07:34 <c_wraith> (It's not the first time a ghc release has slid to january because of the holidays)
09:08:20 <haasn> edwardk: there's no operator for traverseOf_, right? seems to be there's a distinct niche for operator versions of void'd operations!
09:08:50 <edwardk> nothing
09:09:18 <edwardk>  get enough shit from folks about the operators i do have, i'm not in a hurry to make a bunch of new ones that break all the existing conventions ;)
09:10:20 <rasfar> f-a: I think this is an SDL question, and it seems like blitSurface is poorly suited to rescaling; see for example http://stackoverflow.com/questions/17027289/resize-image-sdl-c
09:11:00 <rasfar> doing a search for sdl blitsurface resize turns up quite a lot
09:11:24 <f-a> thnks rasfar, I will search and eventually harass(sp) people on #sdl
09:11:52 <rasfar> FWIW, I'm using Haskell GLFW-b and very happy with it so far
09:12:28 <rasfar> had to write my own text-blitting as that's only in the non-"-b" one, but otherwise has everything I need
09:12:55 <f-a> will look into that rasfar , thanks
09:13:34 <merijn> eacameron: You are perhaps wanting Comonad?
09:13:52 <merijn> eacameron: Comonad has "extract :: Comonad w => w a -> a"
09:13:56 <edwardk> eacameron: Comonad
09:15:01 <eacameron> merijn: edwardk: interesting...always wondered what those were; now I have a reason to find out
09:15:06 <eacameron> thanks
09:15:42 <edwardk> eacameron: look at the comonad package if you want to get a sense of what the 'mtl' looks lke turned inside out and dualized
09:16:08 <eacameron> edwardk: "mtl"?
09:16:21 <merijn> eacameron: "coX" in math speak is just "X with the arrows flipped" so "a -> m a" becomes "m a -> a", "m (m a) -> m a" (join) becomes "m a -> m (m a)", etc.
09:16:21 <edwardk> monad transformer library
09:18:07 <eacameron> merijn: that might have been the most useful thing I've learned in a long time ;)
09:18:27 <eacameron> edwardk: ahh...yeah, haven't gotten there yet either
09:19:00 <edwardk> eacameron: i recommend going through the mtl and learning your way around monad transformers before seriously tackling comonads
09:19:42 <eacameron> edwardk: ok...will do; any resources you recommend?
09:20:26 <f-a> rasfar: http://hackage.haskell.org/package/SDL-gfx-0.6.0/docs/Graphics-UI-SDL-Rotozoomer.html for future reference, this should do the trick.
09:20:48 <piezo> hi
09:20:50 <edwardk> i was first introduced to monad transformers by going through http://www.haskell.org/haskellwiki/All_About_Monads and by going back to the original papers by wadler on them
09:21:07 <piezo> what is the best way to make multilayer program transformations (for example "a + (-b)" -> "a - b") on a AST encoded with a functor fixpoint ?
09:21:16 <edwardk> well, not any papers by him on monad transformers, but his early papers on monads in haskell in general
09:21:45 <merijn> eacameron: Also, first learning to implement State/Reader/Writer and then extending that to implement StateT/ReaderT/WriterT is a good exercise
09:21:58 <piezo> i see only pattern matching involving Fix, or monadic catamophisms ?
09:22:01 <edwardk> piezo: with lens that'd be something like 'rewrite $ \case Add a (Neg b) -> Just (Sub a b); _ -> Nothing'
09:22:15 <edwardk> with an explicit fixpoint i guess it'd be
09:22:25 <merijn> eacameron: Extra bonus is that it's almost impossible to write a solution for thosethat type checks but is still wrong
09:22:33 <edwardk> piezo: with lens that'd be something like 'rewrite $ \case Mu (Add a (Mu (Neg b))) -> Just (Mu (Sub a b)); _ -> Nothing'
09:23:13 <edwardk> merijn's approach is pretty solid.
09:23:20 <piezo> edwardk: oh i didnt' think about lens
09:23:52 <edwardk> you can screw up a few things like: pass, local, the (>>=) of state if you aren't careful, but thats about it
09:24:35 <merijn> eacameron: The usual hints to get started are "newtype MyState s a = MyState { runMyState :: s -> (a,s) }" with "get :: MyState s s" and "put :: s -> MyState s ()" and then implement Functor, Applicative and Monad for "MyState s"
09:25:05 <edwardk> interestingly the best way i know to know i ave the right definition for a monad is to write the harder _indexed monad_ definition for it, and if that typechecks i'm basically set.
09:25:23 <haasn> merijn: but (a,b) becomes Either a b
09:25:26 <edwardk> because those few cases with pass, local (>>=), etc. that are ambiguous now have only one definition
09:25:44 <merijn> eacameron: The extension to a state transformer is then simply "newtype MyStateT s m a = MyStateT { runMyStateT :: s -> m (a,s) }", "get :: MyStateT s m a", "put :: s -> MyStateT s m ()"
09:25:47 <edwardk> haasn: thats because the arrows defining (a,b) inverted.
09:25:54 <haasn> oh, yes
09:25:56 <quicksilver> like a mathematician proving a theorem by proving an even harder theorem
09:26:18 <haasn> CT arrows, not occurrences of -> in the Haskell type signature, I guess.
09:26:23 <edwardk> quicksilver: well, i think of it as one where the compiler can give me more support because i've given it tighter constraints
09:26:25 <edwardk> haasn: yeah
09:26:38 <merijn> edwardk: Sure, there are some things you can screw up, but usually those result in things that are very obviously wrong, rather than subtly wrong :p
09:26:45 <eacameron> merijn: edwardk: awesome...I'll do some digging
09:27:01 <quicksilver> edwardk: yes, well the typical maths example is by strengthening the theorem you give the inductive step more to work with
09:27:06 <edwardk> merijn: well, i had bad definitions for many comonad transformers for many years =)
09:27:09 <quicksilver> edwardk: so the harder theorem turns out easier to prove.
09:27:53 <haasn> edwardk: I'm undecided on whether that's a statement about how little people care about comonad transformers or about how confusing comonad transformers are
09:27:55 <edwardk> merijn: other examples are liftCallCC vs. liftCallCC'
09:28:08 <edwardk> haasn: well, it was more that i made bad assumptions
09:28:22 <merijn> edwardk: Sure, but I was refering explicitly to implementing State/Reader/Writer, not monad transformers in general
09:28:30 <edwardk> merijn: sure =)
09:28:52 <edwardk> merijn: just pointing out why i tend to be so pedantic about splitting things up and solving the harder problem first =)
09:28:57 <merijn> Clearly Cont is a whole different ballgame in debugging subtlety :p
09:30:03 <merijn> Can anyone give me some input on how to reduce the RankNTypes overkill I have at the moment?
09:30:24 <edwardk> merijn: ?
09:30:30 <merijn> http://lpaste.net/97168 <-
09:30:55 <edwardk> that is ... hideous
09:30:58 <merijn> I have Producers/Consumers (from pipes) that are polymorphic in their base monads and that I use with two different base monads in the same function
09:31:03 <merijn> edwardk: Agreed :)
09:31:05 <haasn> merijn: (forall m' r' . Monad m' => (Producer ByteString m' r', Consumer ByteString m' r', ...))
09:31:13 <merijn> haasn: Nope
09:31:26 <haasn> :(
09:31:44 <merijn> haasn: Because I'm mixing and matching the underlying monad stacks on all of them
09:31:49 <edwardk> can you fix it to Identity for m' and hoist?
09:32:07 <merijn> I can *probably* get rid of the r' polymorphism
09:32:16 <edwardk> you can kill the r' polymorphism with Void
09:32:38 <merijn> edwardk: No, because some return values, but I don't believe they all have to be fully rank-2
09:32:40 <haasn> you could do something like what lens does with Pretext/ALens
09:32:49 <haasn> (maybe)
09:33:17 <edwardk> that'd give you foo :: MonadSafe m => Producer ByteString Identity Void -> Consumer ByteString Identity Void -> Producer Frame Identity Void -> Consumer Frame Identity Void -> Effect m ()
09:33:19 <merijn> edwardk: Well, Essentially I have a stack "m" and "ReaderT r (StateT s m)" and I need to use them with both
09:33:58 <edwardk> merijn: you should be able to host Producer s m a to Producer s n a given a monad homomoprhism from m to n no?
09:34:24 <edwardk> 'return . runIdentity' is such a monad homomorphism from Identity to any m
09:34:25 <merijn> edwardk: Maybe? I remember something like that, but last time I asked no one responded with what library that was
09:35:06 <edwardk> merijn: i never published one, but would if asked. you can write combinators specific to Producer/Consumer though
09:35:21 <edwardk> and Void should work there since you universally quantified over the result type
09:35:22 <haasn> mmorph has hoist
09:35:33 <haasn> (of course not for Producer/Consumer)
09:35:52 <merijn> edwardk: No, because I have a pipe (inside the function body) which returns a value that I need
09:36:05 <merijn> edwardk: Fixing to Void rather than polymorphic will mean I can't get that result
09:36:18 <haasn> hoisting a Consumer/Producer/whatever is really easy
09:36:21 <edwardk> but if its universally quantified i can instantiate the type to Void
09:36:29 <edwardk> unless you didn't mean to
09:36:30 <haasn> you only need to map over the ‘M’ constructor of Proxy
09:36:53 <edwardk> if you need to instantate that thing to any other type from there you can follow up with absurd
09:36:55 <haasn> (as well as recursing into Request/Respond, obviously)
09:37:02 <bennofs> merijn: just fmap absurd over it to regain the polymorphic type
09:37:06 <merijn> edwardk: But that would crash
09:37:09 <edwardk> you have distinct universally quantified 'r's in each one
09:37:21 <edwardk> you can't ever use any of those 'r's you're getting now unless your type isn't what you wrote
09:37:21 <merijn> Yes
09:37:31 <heath> haskell 2014 is a minor release, right? when's the next major release scheduled?
09:37:34 <edwardk> (forall m' r' . Monad m' => Producer ByteString m' r')
09:37:51 <edwardk> that has t be able to produce any r' i want it to, but it knows nothing about r', so r' is a _|_
09:37:57 <edwardk> it already is Void
09:37:59 <merijn> edwardk: I can't use the r from those, but in a pipes pipeline "foo >-> myPipe >-> bar" all rs need to unify
09:38:18 <merijn> edwardk: I have (internally) a pipes that has a specific (non-polymorphic) return, that I need
09:38:22 <bennofs> edwardk: fmap absurd foo >-> myPipe >-> fmap absurd bar
09:38:22 <edwardk> merijn: and wat i'm saying is tat if you fmap absurd you aren't doing any damage you aren't already suffering
09:38:28 <merijn> edwardk: But I use the consumers with that pipe and another pipe
09:38:40 <merijn> edwardk: Which, without polymorphic return, doesn't unify
09:38:42 <edwardk> the r' is already a bottom.
09:38:45 <haasn> edwardk: unsafeCoerce for performance ;)
09:38:48 <merijn> edwardk: It's not
09:39:07 <haasn> merijn: consider: what forms can (forall r. Maybe r) have?
09:39:23 <edwardk> merijn: i challenge that what you have just stated is impossible. If I give you foo :: Maybe a   what is foo?
09:39:25 <merijn> Is everyone just glossing over my explanation or something?
09:39:43 <edwardk> merijn: your explanation doesn't make any sense.
09:39:54 <merijn> The reason I need is because I'm using the same argument consumer within *two* different pipelines
09:40:10 <edwardk> merijn: sure. so fmap absurd in both cases.
09:40:11 <merijn> The result of the consumer and producer need to unify with whatever the middle of the pipeline has
09:40:37 <merijn> My pipes have different, but fixed real return values
09:40:44 <merijn> Which I need to access
09:41:04 <haasn> merijn: are you confusing the values flowing through the pipe with the ‘r’ parameter?
09:41:10 <merijn> No
09:41:24 <merijn> The 'r' parameter is the result produced when the pipe terminates
09:41:48 <haasn> the type signature you gave guarantees that the pipes passed as arguments never terminate
09:41:55 <merijn> It does not
09:41:58 <edwardk> then (forall m' r' . Monad m' => Producer ByteString m' r') is a producer that can't leave a result when the pipe terminates.
09:42:19 <merijn> edwardk: The middle of the pipe can produce a result, which is the result of the entire pipeline
09:42:25 <haasn> merijn: it's the same as (forall r. Maybe r), I can't possibly pass any Just in other than Just ⊥
09:42:39 <merijn> haasn: Because your example doesn't have a place that can produce rs
09:42:43 <merijn> haasn: My code does
09:42:59 <merijn> In fact, I have two places, producing two different concrete types of r's
09:43:07 <merijn> And I need my consumer to be composed with both of them
09:43:23 <merijn> Hence, my Consumer needs to be polymorphic in r, even though the final pipeline won't be
09:43:55 <haasn> you mean, in case *your* proxy terminates? (not the ones passed as arguments)
09:43:56 <edwardk> merijn: with the universal quantifier where you have it the explanation you just gave makes no sense to me, but i have to go.
09:44:07 <merijn> haasn: Yes
09:44:25 <edwardk> merijn: does your code currently typecheck and work?
09:44:43 <haasn> merijn: fmap absurd won't break that; if there's no ‘Pure’ case generated by any of the two arguments (which there can't possibly be, because you can't invent an arbitrary r), then “absurd” never gets applied
09:45:00 <haasn> note: nobody is suggesting you write fmap absurd $ a >-> b >-> c
09:45:07 <haasn> but rather fmap absurd a >-> b >-> fmap absurd c
09:45:10 <haasn> in case that clears it up
09:45:23 <merijn> edwardk: This code typechecks, I haven't tested *this* specific code, but yes that works
09:45:37 <merijn> haasn: But that's hardly an improvement of the code
09:45:56 <edwardk> merijn: you asked how you could eliminate the rank-n ness of it.
09:45:56 <haasn> merijn: perhaps not; but it would at the very least allow you to get rid of RankNTypes
09:46:14 <edwardk> merijn: hoisting and a couple fmap absurds frees you from rank-n
09:46:24 <edwardk> whether that is good is another judgment call ;)
09:46:30 <haasn> edwardk: (ignoring the fact that hoist is RankN unless you specialize it ;))
09:46:32 <merijn> edwardk: I need rank-n already anyway
09:46:49 <tac> Rank-n is everyone's god-given right to higher order stuff.
09:47:00 <merijn> I don't want to eliminate rank-n per se, I just wanted the signature to suck less :)
09:47:01 <edwardk> then 'd probably choose based on whether ot not it was forcing me to put rank-n signatures everywhere
09:47:27 <merijn> Since it's not the most friendly one I ever wrote :p
09:47:31 <edwardk> gotta run, just realized my wife isn't going to be picking me up. car trouble.
09:47:37 <haasn> of course, eliminating RankN most likely allows you to drop the signature and have it inferred ;)
09:47:48 <merijn> edwardk: ok, good luck :)
09:48:05 <merijn> haasn: But I write explicit signatures for all top-level anyway
09:48:24 <haasn> merijn: type AProducer x = Producer x Identity Void -- could make the sig a bit cleaner
09:48:30 <merijn> Speaking of which, I really need type level holes so I can partially specify my types but not bother with the bits I don't know yet
09:48:47 <haasn> to be fair, that works just as well for type AProducer x = Monad m => Producer x m r
09:49:24 <merijn> That would especially help with stuff like pipes/lens where I know the rough structure of the type I want, but don't always know how to fill bits in and GHC could just infer those
09:51:14 * hackagebot cabal-debian 4.0.4 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-4.0.4 (DavidFox)
09:52:02 <mangaba_leitosa> create a cabalization for a debian package
09:57:33 <satc> @pl f a (\b -> a + b)
09:58:38 <merijn> Is there a cleaner way to write "yield foo >> cat" in pipes?
09:58:48 <merijn> Or rather
09:58:59 <merijn> "(yield foo >> cat) >-> myPipe"
10:02:32 <bennofs> merijn: so basically "consing" a value onto the stream?
10:02:33 <mm_bureau> merijn: cleaner?
10:02:44 <mm_bureau> what would be cleaner than that?
10:04:00 <merijn> mm_bureau: Feels like "useless use of cat"
10:04:38 <mm_bureau> merijn: it isn't
10:05:32 <mm_bureau> 'yield foo >> cat' is very readable
10:05:35 <merijn> mm_bureau: In complete context I have "return ((yield rest >> cat) >-> decoder, encoder)", which looks rather ugly
10:05:50 <mm_bureau> but it isn't ugly
10:05:58 <mm_bureau> i understood your code on first sight
10:07:01 <dario> ouch
10:09:32 <w0rm_x> > 5
10:10:59 <merijn> @botsnack
10:11:06 <merijn> No lambdabot? :(
10:11:31 <w0rm_x> ...
10:13:08 <geekosaur> netsplit
10:32:44 <Psycho_pr> Why is it that when you write a function which uses other function the signature of the new function becomes something like Int -> Int -> Int? I mean, it's still just Int -> Int, no?
10:33:35 <Peaker> Psycho_pr: it completely depends on what your function looks ilke
10:33:42 <merijn> Psycho_pr: Yes, no, maybe.
10:33:43 <merijn>       
10:33:55 <merijn> Psycho_pr: That question is completely unanswerable without an example paste of the code you're refering too
10:34:17 <merijn> s/too/to
10:37:29 <rasfar> Psycho_pr: you will tend to see parentheses in the type, if your function takes another function as a parameter.
10:37:40 <rasfar> (if htat's what you mean by "uses")
10:44:13 <dmj`> is it possible to get upload stats when using put() ?
10:44:34 <Peaker> dmj`: what are you talking about? :)
10:47:12 <dmj`> wrong channel :)
10:51:18 <mm_bureau> Expr has a bunch of weird artifacts
10:51:26 <mm_bureau> > x^y
10:51:30 <lambdabot>  mueval-core: Time limit exceeded
10:51:31 <mm_bureau> that's because
10:51:42 <mm_bureau> > y == 0
10:51:45 <lambdabot>  False
10:52:07 <Peaker> > 2^(-1::Integer)
10:52:10 <lambdabot>  *Exception: Negative exponent
10:52:16 <mm_bureau> > y - 1 < y
10:52:18 <lambdabot>  False
10:52:34 <merijn> > 1 :: Expr
10:52:36 <lambdabot>  1
10:52:46 <merijn> I'm not sure what I was expecting
10:53:01 <Hexagenic> > foo = 2^(-1)
10:53:03 <lambdabot>  <hint>:1:5: parse error on input `='
10:53:09 <Hexagenic> > let foo = 2^(-1)
10:53:10 <lambdabot>  not an expression: `let foo = 2^(-1)'
10:53:16 <mm_bureau> > odd y
10:53:17 <lambdabot>  True
10:53:20 <mm_bureau> > odd (y - 1)
10:53:21 <lambdabot>  True
10:53:40 <rasfar> > let foo = 2^(-1) in foo  -- ?...
10:53:41 <lambdabot>  *Exception: Negative exponent
10:54:19 <mm_bureau> for negative exponents you need Fractional and (^^)
10:54:31 <mm_bureau> > 2 ^ (-1) :: Rational
10:54:31 <rasfar> ah, right
10:54:32 <lambdabot>  *Exception: Negative exponent
10:54:36 <mm_bureau> > 2 ^^ (-1) :: Rational
10:54:37 <lambdabot>  1 % 2
10:54:47 <rasfar> whew...
10:56:14 <mm_bureau> > 2 ^^ (-1) :: Expr
10:56:16 <lambdabot>  recip 2
10:56:54 <rasfar> > y ^ 0
10:57:45 <mm_bureau> @botsnack
10:58:02 <rasfar> hope that wasn't my fault...
10:58:37 <nicoo> > y ^ 0
10:58:57 <ReinH> what have you done
10:59:00 <ReinH> o_O
11:00:17 <td123> > 1 + 1
11:00:18 <rasfar> λ> 3
11:00:31 <rasfar> (lucky I didn't try 2)
11:02:50 <lambdabot> :)
11:02:52 <lambdabot>  can't find file: L.hs
11:02:52 <lambdabot>  1
11:02:53 <lambdabot>  2
11:03:39 <rasfar> but no 3 of course; FliPPeh used λ> earlier, but I had failed to notice they also typed the answer themselves
11:04:05 <rasfar> > y ^ 0 :: Expr
11:04:07 <lambdabot>  1
11:04:34 <nicoo> > y ^ 0
11:04:35 <lambdabot>  1
11:04:42 <nicoo> Phew
11:04:49 <joelteon> > 0 ^ 0
11:04:50 <lambdabot>  1
11:04:58 <tac> > 0 ** 0
11:04:59 <scriptor> what's Expr?
11:04:59 <lambdabot>  1.0
11:05:20 <joelteon> scriptor, it's a type from a library that allows you to view expressions more easily
11:05:20 <rasfar> > y * (recip y) :: Expr  -- i don't know what Expr is in this context
11:05:22 <lambdabot>  y * recip y
11:05:24 <merijn> scriptor: short for expression
11:05:27 <joelteon> > foldl f a [b,c,d,e]
11:05:28 <lambdabot>  f (f (f (f a b) c) d) e
11:05:31 <scriptor> joelteon: ah, thanks
11:05:32 <Iceland_jack> > foldr f e [a, b, c, d] :: Expr
11:05:33 <lambdabot>  f a (f b (f c (f d e)))
11:05:41 <joelteon> > scanl f a [b,c,d,e]
11:05:42 <lambdabot>  [a,f a b,f (f a b) c,f (f (f a b) c) d,f (f (f (f a b) c) d) e]
11:05:46 <tac> Looks like black magic to me :[
11:05:50 <joelteon> it is
11:06:11 <nicoo> joelteon: Is not :]
11:06:21 <merijn> It uses typeclass trickery to turn things into Expr values and combines those
11:06:27 <scriptor> any template magic?
11:06:33 <merijn> No
11:06:35 <scriptor> ooh, nice
11:06:38 <tac> > id :: Expr
11:06:40 <lambdabot>  Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
11:06:40 <lambdabot>              with actual type `a0 -> a0'
11:06:41 <merijn> There's a library on hackage for it, forgot the name though
11:06:48 <joelteon> simple-reflect
11:07:03 <tac> @type a
11:07:04 <lambdabot> Expr
11:07:11 <pqmodn> > (f :: Expr) + (g :: Expr)
11:07:13 <lambdabot>  f + g
11:07:14 <tac> > id a :: Expr
11:07:15 <lambdabot>  a
11:07:28 <joelteon> > liftA2 (==) f g $ e
11:07:29 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
11:07:29 <lambdabot>    arising from a use of `Debug.SimpleReflect.Vars.f'
11:07:29 <lambdabot>  The type variable `b0' is ambiguous
11:07:29 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
11:07:29 <lambdabot>  Note: there are several potential instances:
11:07:39 <scriptor> > filter even [1,2,3,45] :: Expr
11:07:40 <lambdabot>  Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
11:07:40 <lambdabot>              with actual type `[a0]'
11:10:03 <kinslayer> After I have been browsing the documentation for Network.HTTP.Conduit it doesn't seem obvious how to increase the timeout, any hints ?
11:12:21 <ReinH> simple reflect is an awesome library
11:12:51 <ReinH> just the fact that you can do that at all is pretty amazing
11:15:58 <kinslayer> ReinH: Are you the one on the HaskellCast ?
11:21:21 * hackagebot fpco-api 1.0.1 - API interface for the FP Complete API.  http://hackage.haskell.org/package/fpco-api-1.0.1 (ChrisDone)
11:26:41 <ReinH> kinslayer: yes :)
11:26:56 <kinslayer> ReinH: Okay it is a really nice show...
11:27:12 <ReinH> kinslayer: thanks :)
11:27:15 <kinslayer> ReinH: However how is it with the next episode ?
11:27:27 <ReinH> kinslayer: we're taking a break for the holidays but we have january and february lined up
11:27:45 <kinslayer> ReinH: I will look forward to that...
11:27:55 <ReinH> me too :)
11:29:30 <kinslayer> ReinH: I might not learn all that much, however it is great fun...
11:30:20 <ReinH> kinslayer: I hope it gets people excited about doing their own learning, at least :)
11:31:09 <kinslayer> ReinH: I am fairly new to haskell, but I am getting better at it... At this point it is trial and error with some assistance from books
11:31:21 * hackagebot pretty-show 1.6.3 - Tools for working with derived `Show` instances and generic  inspection of values.  http://hackage.haskell.org/package/pretty-show-1.6.3 (IavorDiatchki)
11:32:19 <kqr> the best thing about the cast is how each episode just gets better
11:32:42 <kqr> ReinH, will some guests reappear or do you have a long line already?
11:34:26 <fizbin> Does Monoid imply Eq?
11:34:39 <joelteon> no
11:34:57 <fizbin> If not, is there any sensible Monoid instance without an Eq instance?
11:35:21 <fizbin> Oh wait, of course there is.
11:35:22 <simpson> fizbin: data Endo a = Endo (a -> a)
11:35:22 <shachaf> Sure. Functions, for instance.
11:35:45 <fizbin> I was thinking [a], where a has no Eq instance.
11:37:10 <joelteon> [IO ()]
11:38:07 <fizbin> Is there any way to ask "is this thing (of type a) the same as mempty :: a" without depending on (Eq a) => ?
11:38:25 <joelteon> there really isn't
11:39:34 <joelteon> do you have a specific type in mind, or is this in general
11:39:46 <txrxcx> > Just 6 >>= return . (+1)
11:39:47 <lambdabot>  Just 7
11:40:52 <kqr> txrxcx, fmap (+1) (Just 6)
11:41:05 <kqr> txrxcx, is the same thing, if you for some reason would like to know
11:42:27 <txrxcx> well i didnt want to know and now because i know i lost some other knowledge that i needed bc my brain is full! so ty not! where did i put my keys...
11:43:26 <lingxiao> hey all
11:43:33 <lingxiao> is anyone familiar with this document: http://web.cecs.pdx.edu/~mpj/thih/TypingHaskellInHaskell.html
11:43:36 <lingxiao> by Mark Jones?
11:44:47 <ReinH> kqr: we've got a pretty good list
11:45:25 <kqr> ReinH, awesome. care to share or would you rather keep it under cover until the episodes air?
11:45:29 <lingxiao> it's a simple implementation of Haskell's type checking system in, err, Haskell
11:45:44 <ReinH> kqr: going to keep it under wraps :)
11:45:50 <ReinH> some surprise is good :)
11:46:13 <kqr> fair enough
11:46:23 * hackagebot network-bitcoin 1.5.1 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.5.1 (ClarkGaebel)
11:46:26 <kqr> (also provides some protection in the event one of the guests suddenly can't, i suppose ;) )
11:46:30 <kinslayer> ReinH: Yeah surprises are great..
11:51:24 * hackagebot system-random-effect 0.4.1 - Random number generation for extensible effects.  http://hackage.haskell.org/package/system-random-effect-0.4.1 (ClarkGaebel)
11:54:30 <bz> can llvm optimize single constructor data decls to newtype?
11:55:51 <triliyn> bz: newtypes have different semantics than regular types, so I don't think it would
11:56:24 * hackagebot units 1.1 - A domain-specific type system for dimensional analysis  http://hackage.haskell.org/package/units-1.1 (RichardEisenberg)
12:13:20 <m1dnight> quick question: what is the name of <|> ?
12:13:22 <m1dnight> hard to google :p
12:13:32 <tac> Alternate?
12:13:43 <tac> > Just 1 <|> Just 3
12:13:45 <lambdabot>  Just 1
12:13:51 <tac> > Nothing <|> Just 3
12:13:53 <lambdabot>  Just 3
12:13:59 <m1dnight> yes!
12:14:00 <m1dnight> that was it
12:14:04 <m1dnight> found it immediatly on google :)
12:14:18 <tac> I think it's also rather monoid-y
12:14:21 <sm> or http://www.haskell.org/hoogle/?hoogle=<|>
12:14:25 <tac> > mappend (Just 1) (Just 3)
12:14:27 <lambdabot>  No instance for (Data.Monoid.Monoid a0)
12:14:27 <lambdabot>    arising from a use of `e_113'
12:14:27 <lambdabot>  The type variable `a0' is ambiguous
12:14:27 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
12:14:27 <lambdabot>  Note: there are several potential instances:
12:14:32 <tac> hm maybe not
12:14:46 <m1dnight> should be euhm
12:14:58 <m1dnight> mappend (Just (Sum 1)) (Just (Sum 2))
12:14:59 <Iceland_jack> > Just (Product 1) <> Just (Product 15)
12:15:01 <lambdabot>  Just (Product {getProduct = 15})
12:15:08 <m1dnight> oh
12:15:10 <notdan> should be rather applicativ-y iirc
12:18:00 <nooodl> tac:
12:18:02 <nooodl> > First (Just 3) <> First (Just 4)
12:18:04 <lambdabot>  First {getFirst = Just 3}
12:18:05 <nooodl> > First Nothing <> First (Just 4)
12:18:06 <lambdabot>  First {getFirst = Just 4}
12:18:16 <tac> @type First
12:18:17 <lambdabot> Maybe a -> First a
12:24:23 <jle`> (<|>) is a monoidal operation, but it is in general a different operation that is defined by the mappend instance
12:25:11 <jle`> it's intended to behave something like First, except generalized to all Alternative's.
12:41:01 <bz> case f
12:43:41 <bz> is there a builtin version of "f b | True = 1 | False = 0"?
12:44:27 <pavonia> fromEnum
12:45:03 <bz> pavonia: thanks
12:45:03 <shachaf> const 1
12:45:24 <pavonia> heh, right
12:46:01 <bz> shachaf: not sure i understand. const 1 False = 1 != 0
12:46:20 <shachaf> bz: The function you wrote is const 1
12:46:25 <pavonia> > let f b | True = 1 | False = 0 in f False
12:46:27 <lambdabot>  1
12:46:28 * hackagebot HaRe 0.7.0.9 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.0.9 (AlanZimmerman)
12:46:30 <rasfar> oh, haha
12:46:44 <rasfar> first pattern always matches
12:46:45 <Dasuraga> I'm playing around with Conduit... is there a decent way to "fuse" two sources ?
12:46:53 <bz> meh
12:46:55 <Dasuraga> to create 1 source that gets values from both of them?
12:47:52 <Clint> Dasuraga: in alternation or what?
12:48:37 <Dasuraga> in alternation, yeah
12:49:06 <Dasuraga> It feels like the sort of thing that would already be present as a combinator, but I didn't see anything as such
12:51:01 <fizbin> @src mconcat
12:51:01 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:51:45 <jle`> rasfar: you can probably do something hackish with fromEnum
12:52:12 <jle`> > map fromEnum [True, False]
12:52:14 <lambdabot>  [1,0]
12:52:26 <jle`> not sure if that is what you want
12:58:50 <Dasuraga> oh, I found zip , from that I can easily build a combiner
13:00:13 <computionist> Seeing as this is #Haskell, I have something super off topic. A friend of mine will be in Cleveland and is looking for people to see and places to go.
13:01:14 <shachaf> There's a channel for off-topic things (and you're in it).
13:01:20 <merijn> computionist: If you know it's super off-topic, why ask it here instead of #haskell-blah or similar?
13:01:30 <computionist> I did and they sent me here.
13:01:53 <computionist> Anyway forget I asked I didn't mean to upset your poor sensibilities.
13:07:04 <rasfar> jle`: wasn't my question actually (and pavonia beat me on the draw by about 1 second on the fromEnum solution).
13:07:26 <rasfar> but I am wondering how dependable fromEnum would be -- could that, in principle, be "subject to change without notice"?
13:08:49 <rasfar> anyone using OpenAL? i'm trying it out, but having some trouble opening a device.
13:08:51 <jle`> it might be in the report
13:09:07 <jle`> but i do [False .. True] all the time so i hope not
13:09:30 <rasfar> i believe you're right and it's specified in the 98 Report
13:12:45 <rasfar> allDeviceSpecifiers tells me I have ["PulseAudio Software","ALSA Software","PortAudio Software"]
13:13:46 <rasfar> so would (Just device) <- openDevice (Just "ALSA Software") be enough, or do I need some scheme-y wrapper syntax in there?...
13:18:28 <rasfar> Just "ALSA Software" seems to be the only one that doesn't return Nothing
13:18:38 <rasfar> wonder why I hear nothing...
13:19:50 <kinslayer> is there a way in haskell to work with unix fifo ?
13:20:52 <aristid> kinslayer: yes you can open them like any other file
13:21:15 <kinslayer> okay, is there a better way to get something like a erlang mailbox ?
13:21:19 <geekosaur> they have the same restrictions in haskell as they have everywhere else, though
13:21:56 <ion> kinslayer: Within a program or between processes?
13:22:09 <kinslayer> ion: between processes
13:22:19 <aristid> kinslayer: unix sockets?
13:22:44 <ion> kinslayer: For “like Erlang” the first thing i’d look at would be http://hackage.haskell.org/package/distributed-process
13:23:02 <kinslayer> ion: That might be interesting...
13:23:38 <kinslayer> I was thinking that a combination of erlang and haskell would be pretty much a killer language...
13:23:50 <kinslayer> much be a killer language*
13:24:12 <tel> Does anyone know how to use Bound with an "untied" expression type?
13:24:45 <kinslayer> so when the stability is "experimental" how is that valued ? Not production ready but fine for small scale test ?
13:24:48 <ion> kinslayer: Here’s a nice talk about it: http://skillsmatter.com/podcast/home/haskell-cloud
13:24:53 <tel> I'd like to annotate the expression with cofree, but both Bound and cofree want to use the same variable to recurse on
13:25:58 <kinslayer> ion: isn't that from the galois channel ?
13:27:41 <merijn> kinslayer: Have you looked at Cloud Haskell?
13:27:59 <kinslayer> merijn: not really yet.
13:29:11 <kinslayer> for I am looking at the video about haskell in the cloud
13:29:17 <strbean> hello folks
13:30:40 <rasfar> (yep, a C example of OpenAL works...)
13:30:50 <strbean> kinslayer: this isn't what you're asking for, but relevant
13:31:05 <strbean> I've seen mentions of deploying haskell on heroku in passing
13:31:07 <strbean> https://github.com/begriffs/heroku-buildpack-ghc
13:31:18 <kinslayer> strbean: Well I am looking at different solutions
13:32:49 <strbean> yah, I haven't really investigated the subject, just thought it might be relevant
13:32:54 <strbean> what stack are you using?
13:33:02 <merijn> rasfar: There seem to be quite a few layers between the haskell code you entioned and a C example?
13:33:49 <merijn> rasfar: Have you tried lower level access methods? Also, I have no clue how we're supposed to know what "allDeviceSpecifiers" and "openDevice" are
13:33:54 <kinslayer> well I am not going to deploy this as of yet
13:34:14 <fizbin> Does any Monoid instance actually override mconcat?
13:34:54 <fizbin> Also, isn't the default mconcat (foldr mappend mempty) pretty much guaranteed to suck, performance-wise?
13:35:02 <joelteon> yes
13:35:10 <shachaf> No.
13:35:14 <joelteon> No
13:35:22 <shachaf> (To the second question. I have no idea about the first.)
13:35:32 <joelteon> Plenty of Monoid instances override mconcat, I think
13:35:36 <joelteon> I'm pretty sure Data.Map does
13:35:45 <kinslayer> strbean: however if I were to do this within a program (since that is a possibility) is that easier
13:36:01 <rasfar> thanks merijn; i'm trying to zero in on the fulcrum of my issues...
13:36:26 <rasfar> the C uses PulseAudio for one, and loads a .wav file from the current directory
13:36:52 <rasfar> the Haskell example is from http://bluishcoder.co.nz/articles/haskell/openal.html
13:37:16 <merijn> rasfar: Have you tried just using the C code via the FFI?
13:37:43 <rasfar> oh, I suppose that would be a possibility. I've never used Haskell FFI, so tend to try to use the higher-level bindings first.
13:37:59 <Euroskeptic> hi there. if i want to get into haskell what is a good book to start with?
13:38:13 <rasfar> it compiles, and runs without issues, just no sound. maybe it's as simple as a soft volume I need to set...
13:38:34 <kinslayer> Euroskeptip: learn you a haskell
13:38:42 <Euroskeptic> thanks :D
13:38:58 <kinslayer> euroskeptic: freely available online
13:39:01 <fizbin> Huh. Data.Map overrides mconcat to be based on a strict version of foldl, instead of the default foldr.
13:39:03 <donri> @where lyah
13:39:03 <lambdabot> http://www.learnyouahaskell.com/
13:39:14 <Euroskeptic> cool thx
13:39:32 <strbean> kinslayer: I'm just getting my feet wet with haskell so I don't know much about the administration aspects of it, but I built a gentoo virtual machine for home development purposes (ghc doesn't like the new OSX yet)
13:39:37 <rasfar> there is also a delay commensurate with the buffer sizes, so I do believe the bluishcoder example is playing the audio -- I'll keep at it...
13:40:01 <strbean> kinslayer: setting up gentoo is a lot of work but the haskell / cabal setup is relatively easy
13:40:01 <fizbin> Fair enough, but I'm just surprised that an mconcat implementation wouldn't mappend pairwise, then mappend the pairs, etc.
13:40:13 <kinslayer> strbean: play I am also just starting out
13:40:18 <strbean> kinslayer: going with a different linux distribution I'm sure it wouldn't take much time at all
13:40:18 <kinslayer> okay*
13:40:38 <kinslayer> strbean: I am on Mint or debian all the time
13:40:59 <strbean> I'd see what people in this channel have to say about who has the best maintained packages for haskell
13:41:07 <strbean> debian would certainly be a good choice
13:41:33 * hackagebot haskoin-script 0.0.1 - Implementation of Bitcoin script parsing and evaluation  http://hackage.haskell.org/package/haskoin-script-0.0.1 (PhilippeLaprade)
13:41:36 <kinslayer> strbean: debian is just conservative with their packages, it has to be really stable to get into the package manager
13:41:58 <Euroskeptic> im currently trying to get picbuntu on a 1gb ram mini pc
13:41:58 <joelteon> Does idempotent specifically describe a function that only transforms its output once, or which transforms it 0 or 1 times
13:42:03 <rasfar> furthermore, the example TestDevice.hs from http://www.haskell.org/haskellwiki/OpenAL returns status 0 for Just "PulseAudio Software" (it's not designed to actually play a sounds)
13:42:26 <Euroskeptic> good for going to anyones house and turning their tv into a computer.
13:42:36 <silasm> strbean: a lot of packages that I haven't been able to build elsewhere because they only support the latest version of GHC (e.g. Yi, I think) have built for me more easily on Arch (which makes sense)
13:43:04 <merijn> rasfar: If you are decently comfortable with C, the FFI will be fairly unsurprising. If not, it might be better to fiddle with higher level libraries first
13:43:11 <rasfar> joelteon: it will transform the input every time, but the input will equal the output on the second and all subsequent iterations
13:43:25 <joelteon> yeah, that's what I was trying to ask
13:43:34 <merijn> joelteon: It depends on the field your in
13:43:37 <binroot> @pl \x -> all null (words x)
13:43:37 <lambdabot> all null . words
13:43:46 <merijn> joelteon: In math idempotent means "f(x) = f(f(x))"
13:44:01 <rasfar> okay, i'll fiddle for a while yet, then maybe explore that FFI! thanks for your support merijn
13:44:11 <merijn> joelteon: In distributed systems it means that performing an operation N>1 times is indistiguishable from performing it once
13:44:18 <joelteon> I see
13:44:43 <silasm> strbean: then again that's a double-edged sword, a lot of things wouldn't build because they relied on things that had been changed in my GHC (e.g. Prelude.catch was an issue for a long time)
13:45:12 <merijn> joelteon: The latter sense also applies to parallel/concurrent programming. "C = 1" is idempotent, "C = C + 1" is not, etc.
13:49:30 <rasfar> is there a word for a function than alternates? x == f^2 x == f^4 == x ..., and f x == f^3 x == ... , but not necessarily x == f x ?
13:50:03 <c_wraith> f = (* (-1))
13:50:15 <triliyn> merijn: aren't those two notions the same if you model operations as functions from states to states?
13:50:28 <rasfar> that's a good example, but not the name/term...
13:50:36 <c_wraith> Yeah, I don't know a name for it
13:50:59 <c_wraith> I guess you could say that f^2 is an eigenfunction?
13:51:04 <merijn> triliyn: I think so, but last time I used the latter notion here I got yelled at by math people :p
13:51:50 <rasfar> oh yeah? i'll have to refresh on operator/spectral theory terminology
13:52:19 <Cale> rasfar: an involution
13:52:22 <jle`> could it be that f is its own inverse
13:52:32 <rasfar> ah! thanks Cale
13:52:42 <c_wraith> ooh, a mathematician knows the answer!
13:53:12 <kinslayer> @hoogle openFIFO
13:53:13 <lambdabot> No results found
13:53:16 <kinslayer> @hoogle openFIFOs
13:53:17 <lambdabot> No results found
13:53:37 <rasfar> @hoogle namedpipe
13:53:38 <lambdabot> System.Posix.Files.ByteString namedPipeMode :: FileMode
13:53:38 <lambdabot> System.Posix.Files namedPipeMode :: FileMode
13:53:38 <lambdabot> System.Posix.Files createNamedPipe :: FilePath -> FileMode -> IO ()
13:53:43 <rasfar> whoa!!
13:54:20 <rasfar> kinslayer: FIFO is synonymous with "named pipe"
13:54:24 <kinslayer> rasfar: Oh I just saw someone use openFIFO in code so I thought that was the name, but I had no idea what library it came from
13:54:49 <kinslayer> rasfar: but obviously it is better to use the correct name :D
13:55:15 <rasfar> i was surprised; i didn't expect results there...
13:55:19 <kinslayer> now I just need to go and dig into those libraries
13:55:33 <binroot> @pl \x -> all null (words x)
13:55:33 <lambdabot> all null . words
13:57:36 <jrmithdobbs> @hoogle [(Maybe a,Maybe b)] -> [Maybe (a,b)]
13:57:37 <lambdabot> No results found
13:58:48 <jrmithdobbs> @hoogle (Maybe a,Maybe b) -> Maybe (a,b)
13:58:50 <lambdabot> No results found
14:00:04 <jle`> > (,) <$> Just 1 <*> Just 2
14:00:06 <lambdabot>  Just (1,2)
14:00:18 <jle`> hm but it's not over a tuple
14:00:26 <jrmithdobbs> ya
14:02:04 <joelteon> :t liftA2 (uncurry (,))
14:02:05 <lambdabot>     Couldn't match type `(a0, b1)' with `b0 -> c0'
14:02:05 <lambdabot>     Expected type: a0 -> b1 -> b0 -> c0
14:02:05 <lambdabot>       Actual type: a0 -> b1 -> (a0, b1)
14:02:10 <joelteon> :t liftA2 (curry (,))
14:02:11 <lambdabot> Applicative f => f a -> f b -> f (b1 -> ((a, b), b1))
14:02:16 <joelteon> ok, that's not right
14:02:46 <joelteon> Anybody here have experience with acid-state? Is there a canonical way to implement unique indexes in it?
14:02:58 <rose> I partially apply a DB connection to some DB access functions. When I have the last line of the DB access be liftIO $ PutStrLn "something", I can have a return type of IO (). But if I want to return the results from the function, I must return a type Action IO (), and then the expected type of the DB connection is IO Pipe, and its actual type is Action IO Pipe, because I access the connection <- passedInConnection in the same
14:02:58 <rose> do block that returns the Action
14:03:33 <rose> How can I access the DB connection as an IO Pipe and not an Action IO Pipe?
14:04:20 <merijn> rose: Might help to specify which libraries you are using?
14:04:22 <fizbin> What's a good name for the symbol >@> ?
14:04:29 <fizbin> "step to the right"?
14:04:45 <AVM> at fish
14:04:47 <pqmodn> sushi
14:04:52 <AVM> ^
14:05:00 <rose> merijn: mongodb
14:05:14 <fizbin> Okay, but what about <@> ? Two-headed sushi?
14:05:14 <rose> docs here: http://hackage.haskell.org/package/mongoDB-1.4.1.1/docs/Database-MongoDB-Query.html
14:05:22 <joelteon> OR do you guys know of a data structure that provides unique index-like behavior for multiple fields of a single element?
14:05:24 <pqmodn> hmm
14:08:06 <donri> joelteon: data-store, tables, ixset
14:08:50 <enthropy> tables really needs a link to it's examples to make sense
14:08:52 <donri> joelteon: they should all have safecopy instances too
14:09:05 <joelteon> do you recommend any of those in particular, donri?
14:09:25 <joelteon> data-store looks pretty nasty
14:09:48 <donri> joelteon: ixset is the easiest to use but has the least static safety and some weird behavior (possibly bugs even)
14:10:09 <joelteon> tables is interesting
14:10:11 <donri> joelteon: tables is kinda crazy and has a nasty bug that's making it not so useful for me
14:10:14 * merijn voices his usual "I don't think acid-state should be used as a database replacement" objection
14:10:15 <joelteon> what's that?
14:10:24 <donri> joelteon: i haven't used data-store, so i'm going to recommend it. :)
14:10:38 <merijn> joelteon: My objection is that acid-state makes for a poor database
14:10:44 <joelteon> why's that
14:10:55 <joelteon> I'm not married to acid-state yet, just exploring whether it would be a good idea to use it or not
14:11:01 <donri> merijn: multi-key generated indices are useful regardless of acid-state
14:11:10 <donri> they do happen do go well with acid-state though
14:11:20 <donri> just like any other containers
14:11:23 <joelteon> well, I'm asking about multi-keys because I only need them if I'm not using a DB engine that enforces it
14:11:23 <merijn> It's not designed to be a database, it's designed to persist haskell heap objects in a safe manner
14:11:29 <joelteon> acid-state just stores values
14:11:53 <rose> merijn: do you have any suggestions?
14:12:09 <merijn> You can store like a map or arbitrary data structure that way, but you're kinda forcing it into a usecase it wasn't optimised for
14:12:16 <joelteon> right
14:12:42 <merijn> I haven't really used any haskell database bindings, but my goto databases are either BerkeleyDB or SQLite
14:12:54 <donri> i disagree there
14:13:18 <merijn> donri: With what specifically?
14:13:18 <donri> and i think happs-state and happs-ixset were sort of developed together initially
14:13:36 <donri> although it was before my time so
14:13:42 <sclv_> yes they were
14:13:54 <merijn> Ok, maybe wasn't designed is a bit overstated.
14:14:04 <merijn> But the design lends itself better to other usecases
14:14:05 <donri> merijn: i don't think using these data structures "forces acid-state into a usecase it wasn't optimized for"
14:14:20 <donri> not sure what you mean though
14:14:29 <donri> it works for any safecopy instance
14:14:35 <Guest79111> merijn: so, what's the difference between using database and persisting Haskell objects? When would you use one vs the other?
14:14:40 <donri> there are no further requirements to speak of really :p
14:14:52 <sclv_>  donri what's the nasty bug?
14:15:00 <merijn> Well, if you're going to have tons of keys I would just use SQLite/BerkeleyDB over acid-state
14:15:03 <joelteon> I'm curious about what kind of performance I can get in acid-state vs postgres
14:15:12 <donri> sclv_: the inverted indices don't work at all
14:15:16 <merijn> Guest79111: It depends how you use your database
14:15:25 <donri> sclv_: which are pretty fundamental to the use cases for these data structures
14:15:49 <sclv_> joelteon: i'd love to see some numbers on that
14:15:51 <merijn> Guest79111: SQL databases are much better at scanning, joining and indexing large numbers of keys (even data sizes that are bigger than RAM)
14:15:53 <joelteon> yeah
14:16:00 <joelteon> I think I might do some benchmarks today
14:16:00 <merijn> Guest79111: acid-state will always hold all state in RM
14:16:02 <sclv_> right. sql is good for doing sql-like things
14:16:07 <joelteon> I'm waiting on a long-running SQL query for work
14:16:20 <donri> joelteon: acid-state will add almost no overhead for queries, over the chosen data structure
14:16:21 <sclv_> acid-state is more to solve the case where _everything_ persistant went into a db
14:16:35 <sclv_> even when it fit comfortably in memory
14:16:41 <sclv_> and wasn't being queried in a fancy relational manner
14:16:50 <sclv_> which came up a bunch with webapps
14:16:54 <merijn> Guest79111: If you have like a global state for a daemon/program/whatever that you want to preserve through crashes, then acid-state is cool
14:16:55 <joelteon> I wonder how long it takes to open a localstate
14:17:06 <joelteon> oh, now THAT is a good idea
14:17:09 <sclv_> so there were a bunch of acid-state-like libs in different languages
14:17:21 <sclv_> like prevayler in java etc (i think that was the first)
14:17:50 <sclv_> i've done dumb acid-state-like-things in the past before it was cleaned up and made easily usable
14:17:58 <sclv_> these days i might be tempted to use it directly
14:18:00 <merijn> Don't take my objection to use SQLite/BerkeleyDB over acid-state as a complaint about acid-state. I think it's a really cool, useful and nifty library
14:18:22 <merijn> But many people seem to try and fit usecases better suited to a more traditional database into acid-state for no real reason
14:18:45 <joelteon> well I've never used acid-state, so I don't have a good intuition for what's better suited for it vs a traditional database
14:18:47 <donri> joelteon: openLocalState can be anything from instant to infinity, since it replays (pure) events
14:18:54 <joelteon> right
14:18:59 <joelteon> so that's what the "checkooints" are for
14:19:06 <joelteon> checkpoints, actually
14:19:22 <donri> joelteon: even with checkpoints it can be infinity depending on the safecopy instances
14:19:22 <yogert> Hey, how would I resolve this dependency issue? I  am trying to use the Codec.BMP module which depends on bytestring == 0.10.*, and requires the user to provide it with ByteString data as well. When I use both Codec.BMP and ByteString I get a duplicate symbol error. I figured that BMP was compiled against bytestring 0.10.1, so I reinstalled bmp forcing it to use 0.10.2. This worked, but I still get the issue, presumably with the import of ByteString itse
14:19:30 <merijn> joelteon: data bigger than RAM -> traditional db, scanning/joining large numbers of objects -> SQL
14:19:40 <joelteon> I see
14:19:50 <donri> joelteon: for example things like ixset just serialize as lists, and to read them back you have to calculate the indices again
14:20:04 <joelteon> but even in a traditional DB, you rarely/never want to hit data that is not in RAM
14:20:06 <donri> joelteon: which may involve arbitrary (pure) code
14:20:12 <joelteon> right
14:20:23 <merijn> joelteon: crash resistant global state -> acid-state, small data-sets or direct access to haskell datastructures (without having to serialise/deserialise) -> acid-state
14:20:40 <kinslayer> hmm I opened a file, now I can close it :S
14:20:46 <nstdloop> What exactly is ..?
14:20:57 <nstdloop> Clearly it isn't an infix function
14:21:02 <nstdloop> because you can't use it like (..) 1 n
14:21:06 <kinslayer> I just called openFile "filepath" ReadWriteMode
14:21:23 <nstdloop> So what is it?
14:21:28 <triliyn> nstdloop: it's syntax for enumFrom or enumFromTo, depending on how you use it
14:21:32 <merijn> joelteon: You don't want to hit data not in RAM, but say you have 1 million entries and someone queries your site (or whatever) you will have to look scan through to find the relevant ones
14:21:37 <donri> i wouldn't use acid-state for like, running statistical calculations on ginormous datasets. sql can be great for that sort of thing
14:21:56 <nstdloop> ah
14:22:02 <triliyn> [a..b] --> enumFromTo a b
14:22:21 <joelteon> @pl \x y -> [x..y]
14:22:21 <lambdabot> enumFromTo
14:22:30 <shachaf> Or enumFromThen or enumFromThenTo
14:22:36 <nstdloop> is there a reason it can't be used as (..)?
14:22:39 <triliyn> Right, or that
14:22:40 <joelteon> @pl \x y z -> [x,y..z]
14:22:40 <lambdabot> enumFromThenTo
14:22:51 <donri> on the other hand, for your average web application, sql is like the least optimal solution for persistence you could possibly come up with, whereas acid-state can be great
14:22:57 <ion> enumFrom_then_to_
14:22:58 <shachaf> (..) is a syntax error.
14:23:00 <dwcook> nstdloop, it's just syntax.
14:23:05 <dwcook> Not a function.
14:23:06 <fizbin> I have three operators to name: <@>, >@>, and ~@~. The first two could conceivably be called "put your hands on your head" and "a step to the right", but then to keep up the theme ~@~ would have to be named something like "pelvic thrust", which doesn't work.
14:23:14 <joelteon> nstdloop: same reason you can't do [] x for x
14:23:17 <joelteon> err
14:23:20 <joelteon> [] x for [x]
14:23:42 <jle`> why can't i do
14:23:43 <sclv_> @hoogle Handle -> IO ()
14:23:44 <lambdabot> System.IO hClose :: Handle -> IO ()
14:23:44 <jle`> (x) [ ]
14:23:44 <lambdabot> GHC.IO.Handle hClose :: Handle -> IO ()
14:23:44 <lambdabot> System.IO hFlush :: Handle -> IO ()
14:23:46 <jle`> :)
14:23:51 <nstdloop> Alright. I guess it makes sense because it can be so many different functions
14:23:59 <sclv_> kinslayer: ^^
14:24:11 <silasm> fizbin: can I suggest "shrug" for ~@~?
14:24:18 <dwcook> jle`, that looks syntactically correct to me
14:24:26 <yogert> in ghci, is there any way to see exactly what modules are being loaded with the :m command?
14:24:35 <kinslayer> well it didn't work with hClose (however it ran inside emacs, so I shut it down and started it up again....)
14:24:38 <sclv_> donri: actually i don't think sql is at all nice for statistical calcs on ginormous datasets!
14:24:40 <donri> yogert: it should be there in the default prompt
14:24:48 <jle`> dwcook: darn you're right.  i was talking about using (x) as an infix operator with the inputs ([) and (])
14:24:49 <sclv_> kinslayer: hClose is in System.IO
14:24:56 <donri> yogert: otherwise maybe :show [imports|modules] or something
14:25:03 <kinslayer> well the handle didn't close with that function
14:25:12 <jle`> postfix
14:25:12 <donri> sclv_: duno, haven't really done anything of that sort :P
14:25:15 <orzo> is there a way to configure local mirrors for cabal?
14:25:16 <sclv_> donri: in fact streaming calcs over vector or whatever are ideal
14:25:21 <yogert> donri: well I mean the version etc
14:25:27 <orzo> caching mirrors
14:25:37 <sclv_> sql is just one way to handle out-of-band datasets
14:25:41 <sclv_> but lazy io is another
14:25:45 <sclv_> or pipelike stuff
14:25:47 <donri> sclv_: i guess what i'm trying to express is that it can be great at getting acceptable performance out of somewhat arbitrary queries, on large datasets
14:25:55 <rose> I asked the question about monod use in mongodb with code shown here: http://stackoverflow.com/questions/20669578/monad-use-in-mongodb-access
14:25:56 <donri> maybe not statistics
14:25:57 <sclv_> right but those are more filterish or lookup queries
14:26:09 <sclv_> if you want everything and then to crunch it, there are better ways
14:26:12 <dcoutts_> orzo: you can of course use a caching http proxy, cabal respects the http_proxy env var
14:26:25 <donri> yeah wrong term
14:26:26 <sclv_> and also if you want a query that requires touching every row (i.e. not on something that's indexed nicely) then there are better ways
14:26:40 <yogert> donri: I think im having an issue with two versions of bytestring installed, and I want to see what version is being used. I suppose I could just compile to program and look at what ghc says
14:27:10 <donri> yogert: you should never have any other number of bytestring builds except one, the one that came with ghc
14:27:30 <donri> yogert: but try :show packages, maybe
14:28:34 <donri> yogert: actually :show linker seems to do it
14:29:01 <yogert> donri: yeah, i'm not sure how this came about, but it has been the source of a lot of headaches. I have 10.1 and 10.2 I think
14:29:04 <yogert> and thanks ill try that
14:29:44 <donri> ghc-pkg list bytestring, then ghc-pkg unregister bytestring-1.2.3 for the version that didn't come with ghc
14:29:59 <donri> and use cabal, it solves these problems for you
14:31:43 <yogert> donri: Ill give that a shot. Although I can't remember all of the details at the moment, I think I ran into some trouble with that route. But ill let you know how it goes
14:33:32 <yogert> geh… somethings fucked up. I shouldn't have two package.conf.d files, as shown by ghc-pkg, should i?
14:33:53 <donri> yogert: normally you should yes
14:34:01 <donri> at least on linux, duno other systems
14:34:14 <donri> one /usr one $HOME
14:34:36 <yogert> oh, okay, yeah thats what I was seeing. What's the difference between the two?
14:35:02 <donri> one is --global one is --user
14:35:18 <donri> global probably comes from your OS package manager
14:38:39 <ReinH> Someone wanted to do something "without using map" so I offered `let totallyNotMap f (x:xs) = f x : totallyNotMAp f xs`. Why do people put these weird constraints on their solutions?
14:39:00 <yogert> okay, well i've resolved the issue by hiding the package in the global database (0.9.2.1). Is that the wrong way to fix this?
14:39:37 <donri> yogert: well you should probably unregister it, and not the global one because that's the one ghc depends on probably
14:41:00 <L8D> What is the difference between IO [String] and [IO String]
14:41:15 <johnw> one is an action producing a list of strings
14:41:21 <johnw> the other is a list of actions each producing a string
14:41:25 <FreeFull> ReinH: Could have offered them a fold-based map
14:41:28 <FreeFull> Or fmap
14:41:28 <merijn> L8D: The former is an IO action that produces a list of Strings, the latter is a list of actions that produce strings
14:41:29 <johnw> you can convert from the latter to the former using "sequence"
14:41:33 <johnw> but not in the other direction
14:41:40 <FreeFull> Or <$>
14:42:06 <donri> ReinH: homework maybe?
14:42:19 <FreeFull> [IO String] is something like  [getLine, getLine]
14:42:23 <merijn> L8D: Try this one in ghci: "map print [1..10] !! 3"
14:42:33 <merijn> :t map print [1..10]
14:42:34 <lambdabot> [IO ()]
14:42:55 <Cale> i.e. if you have a list of actions, you can write an action which will run each of them in turn and collect a list of the results, but once you have that action producing a list, there's no way to pull it apart again into each of its steps.
14:42:59 <merijn> L8D: See also: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
14:43:43 <L8D> Well, I want to mconcat getContents and mapM readFile
14:44:55 <Cale> L8D: uhhhh, mapM readFile filenames will produce a list of strings, and getContents will produce a single string
14:45:04 <Cale> So you can't mconcat those
14:45:14 <jle`> you can cons it?
14:45:17 <Cale> yeah
14:45:20 <L8D> I’m wanting to do: map readFile filenames >>= (getContent:)
14:45:32 <L8D> map readFile filenames >>= (getContent:) >>= mconcat
14:45:38 <L8D> or mapM
14:45:50 <Cale> L8D: That doesn't make sense. What do you want your program to actually do, in English?
14:46:07 <L8D> I want it to work like a concatenation program
14:46:13 <Cale> okay
14:46:16 <L8D> I’m getting a list of filenames from getArgs
14:46:40 <L8D> and I want to concateate all of them including the stdin
14:46:56 <L8D> concatenate*
14:47:05 <simpson> Why not have an action for writing out a single file to stdout, and using mapM on that?
14:47:11 <Cale> So  do fileContents <- mapM readFile filenames; mapM_ putStr fileContents; xs <- getContents; putStr xs
14:47:29 <Cale> Or you could merge those two mapMs into one
14:47:35 <L8D> Cale: Well, I don’t want to go to stdout
14:47:42 <L8D> I want to store them in an IO String
14:47:46 <Cale> oh, well, fine
14:48:07 <jle`> one big string?
14:48:09 <Cale> So  do fileContents <- mapM readFile filenames; xs <- getContents; return (concat fileContents ++ xs)
14:48:26 <L8D> Can we do that lazily?
14:48:46 <Cale> hmm
14:49:01 <L8D> Like: getArgs >>= map readFile >>= (getContents:) >>= mconcat
14:49:01 <Cale> That'll already be *somewhat* lazy
14:49:14 <Cale> That code doesn't make sense
14:49:23 <L8D> Why?
14:49:35 <jle`> what you put after >>= has to return an IO a
14:49:55 <Cale> The left argument to >>= is an IO action, the right argument is a function from the results of that IO action to further IO actions to be performed.
14:50:06 <L8D> jle`: Doesn’t mconcat do that? Or does mconcat IO a -> a?
14:50:14 <Cale> huh?
14:50:14 <jle`> :t mconcat
14:50:15 <lambdabot> Monoid a => [a] -> a
14:50:19 <L8D> oh
14:50:24 <L8D> then just concat
14:50:28 <jle`> :t concat
14:50:29 <lambdabot> [[a]] -> [a]
14:50:34 <donri> :t join
14:50:35 <lambdabot> Monad m => m (m a) -> m a
14:50:38 <donri> :t sequence
14:50:39 <lambdabot> Monad m => [m a] -> m [a]
14:50:46 <donri> are you thinking of either of these
14:51:04 <L8D> :t map readFile
14:51:06 <lambdabot> [FilePath] -> [IO String]
14:51:13 <Cale> (getContents:) already doesn't make sense on the right of >>=
14:51:29 <L8D> :t (getContents:)
14:51:30 <lambdabot> [IO String] -> [IO String]
14:51:50 <Cale> Because it doesn't produce an IO action, and the action on its left isn't producing a list of IO actions
14:52:14 <Cale> mapM readFile filenames  produces a list of String values
14:52:29 <L8D> Cale: I want a list of IO String values
14:52:30 <Cale> (it's an IO action which has a result which is a list of Strings)
14:52:30 <tac> :t sequence (fix (getContents:))
14:52:31 <lambdabot> IO [String]
14:52:41 <L8D> :t (getContents:)
14:52:42 <lambdabot> [IO String] -> [IO String]
14:52:48 <L8D> :t mapM readFile
14:52:49 <lambdabot> [FilePath] -> IO [String]
14:52:53 <Cale> I suppose you could map readFile filenames, but that would be confusing in this context.
14:52:56 <L8D> I want [IO String]
14:52:59 <Cale> Why?
14:53:02 <donri> makes no sense though because getContents reads the whole input
14:53:07 <L8D> So I can prepend getContents
14:53:19 <Cale> Well, I suppose you could
14:53:34 <Cale> If you're just going to run all the actions in turn after that, why not just write what you mean?
14:53:38 <L8D> And then concatenate them together
14:53:40 <ReinH> L8D: what are you actually trying to do?
14:53:41 <Cale> You *could* write:
14:53:51 <donri> you could mapM hGetContents over a list of handles
14:54:04 <Cale> sequence (getContents : map readFile filenames)
14:54:07 <L8D> donri: good idea
14:54:20 <donri> or what cale wrote
14:54:41 <Cale> But you could also just write:
14:55:04 <Cale> do x <- getContents; xs <- mapM readFile filenames; return (x:xs)
14:55:11 <Cale> Which is the same
14:55:23 <jle`> oh are we playing this game now
14:55:32 <jle`> (:) <$> getContents <*> mapM readFile filenames
14:56:01 <Cale> before I did that, I would likely write  liftM2 (:) getContents (mapM readFile filenames)
14:56:09 <Cale> but... whatever
14:56:16 <Cale> Just use do notation :P
14:56:20 <donri> :t (:) <$> getContents <*> mapM readFile []
14:56:21 <lambdabot> IO [String]
14:59:28 <rose> Could anyone answer this question on monad use? http://stackoverflow.com/questions/20669578/monad-use-in-mongodb-access
15:01:12 <ion> Please see the example in http://hackage.haskell.org/package/mongoDB-1.4.1.1/docs/Database-MongoDB.html
15:02:33 <zett_zelett> Everything under the sun is in tune.
15:03:34 <L8D> ahah!
15:03:51 <L8D> getArgs >>= sequence . (getContents:) . map readFile >>= return . concat >>= putStr
15:04:15 <jle`> um
15:04:25 <L8D> what?
15:04:45 <jle`> did you want to just print it this whole time?
15:04:49 <jrmithdobbs> jle`: so this works but is way more convoluted than I was hoping for
15:04:55 <Peaker> L8D: If you have Control.Lens, you can replace >>= return . concat     with <&> concat
15:05:01 <jrmithdobbs> > [(Just (1::Int),Nothing),(Just (2::Int),Just (3::Int))] & foldMapOf (traverse) ((\x y -> [case (x,y) of (Just x,Just y) -> Just (x,y); (_,_) -> Nothing]) <$> view _1 <*> view _2) & catMaybes
15:05:05 <lambdabot>  [(2,3)]
15:05:21 <L8D> jle`: No, I have just been printing it to test it
15:05:30 <L8D> The real code I
15:05:38 <rose> ion: That example doesn't address my question
15:05:42 <L8D> 'll be using is everything up to the return . concat part
15:05:44 <Cale> L8D: Why don't you like my do-notation?
15:05:52 <jle`> it looks like it does the same, but is much less readable haha.
15:06:05 <Cale> Also, if you're going to chain >>= with composite functions, you might prefer using =<<
15:06:13 <jrmithdobbs> jle`: oh did you actually have a working answer I missed?
15:06:21 <Cale> (because then the data all flows in one direction)
15:06:29 <jle`> jrmithdobbs: sorry, was talking to L8D
15:06:32 <jrmithdobbs> ;p
15:06:55 <ion> rose: http://hackage.haskell.org/package/mongoDB-1.4.1.1/docs/Database-MongoDB-Query.html#v:access won’t work?
15:07:06 <edwardk> jrmithdobbs: foldMapOf traverse = foldMap
15:07:08 <Cale> Peaker: You can always replace  x >>= return . f  with  fmap f x
15:07:23 <Peaker> Cale: <&> is fmap, but it would ruin the flow/direction of everything in this case :)
15:07:43 <Cale> oh, it's one of those backward things :P
15:07:47 <jrmithdobbs> edwardk: ya what I'm using it on isn't just traverse, that's just what i'm playing with in ghci
15:07:59 <Peaker> Cale: I used to prefer =<< because of the reason you mention, but since I discovered >>=, <&>, & are all infixl 1 so can be chained nicely without parens, I use that instead
15:08:03 <Cale> I tend to just switch to using =<< when in a situation like this
15:08:16 <Peaker> Cale: but instead of (.) I use multiple <&> or multiple &
15:08:44 <Cale> & kind of rubs me the wrong way
15:08:51 <Peaker> foo & lift & run    instead of foo & run . lift
15:09:12 <Cale> why not  run . lift $ foo ?
15:09:25 <Peaker> Cale: because if I want =<< then suddenly I need to import <=< and even use parens
15:09:34 <Cale> what?
15:09:50 <Peaker> Cale: maybe I want:   print =<< (run . lift $ foo)     <-- yuck
15:10:03 <Peaker> Cale: print =<< run . lift $ foo    doesn't paren correctly
15:10:11 <edwardk> > [(Just (1::Int),Nothing),(Just (2::Int),Just (3::Int))] & foldMap ((\x y -> [sequenceOf both (x,y)]) <$> view _1 <*> view _2) & catMaybes
15:10:13 <lambdabot>  [(2,3)]
15:10:16 <Peaker> foo & lift & run >>= print
15:10:35 <rose> ion: access takes a Pipe and not an Action IO Pipe. The issue is that I'm accessing the Pipe not from within a do-block, but from top-level scope
15:10:41 <jle`> totally clueless on lenses, how do i apply a function to the first part of a tuple?
15:10:47 <Cale> tbh, I'd probably write  print =<< run (lift foo)
15:10:52 <Peaker> jle`: yourTuple & _1 %~ function
15:10:59 <jle`> hoolging (a->b) -> (a,c) -> (b,c) doesn't seem to give anything useful
15:11:01 <jle`> ah thanks
15:11:10 <edwardk> :t over _1
15:11:11 <lambdabot> (Field1 s t a b, Indexable Int p) => p a b -> s -> t
15:11:17 <edwardk> over _1 (+1) (2,3)
15:11:19 <edwardk> > over _1 (+1) (2,3)
15:11:22 <lambdabot>  (3,3)
15:11:23 <Peaker> Cale: and then the "run" argument has 4-level deep application, so you have to write:    print =<< (run . lift . f . bar) foo
15:11:55 <Cale> I don't know what kind of code you're writing that gets you into this situation :)
15:12:25 <Peaker> Cale: Pipelines of functions are pretty common in all kinds of code I wrote
15:12:31 <Cale> Well... sure
15:12:48 <Cale> But I mean =<< with a huge parameter on its right
15:12:55 <Peaker> and some of the elements in the pipe-line are effectful, some aren't, so it's nice to be able to use >>= & <&> according to the kinds of functions I'm applying
15:13:00 <jrmithdobbs> edwardk: can you think of a more concise way to do what i'm after there? ([(Maybe a,Maybe b)] -> [(a,b)])
15:13:13 <Cale> Seems uncommon to me, or maybe I just define intermediate things differently from you
15:13:36 <Peaker> Cale:  myExpressionTree & traversed %%~ effectfulTransformF . g . h >>= moreStuff <&> pureTransformEventually
15:13:39 <augur> http://www.reddit.com/r/haskell/comments/1t7cfe/recursion_in_type_theory/
15:13:43 <augur> if anyone's interested.
15:13:53 <Dasuraga> here's a fun problem I'm trying to figure out : I have this stream of characters I'm getting from a UDP port, what I'd like to do is augment this stream with a series of 'ticks' , by putting in a character 't' every 100ms. Basically I want to build a stream such that I'm sure that there's at least one value every 100ms
15:13:56 <Peaker> Cale: since I discovered the magic combo of the 3 infixl1 operators, I use less intermediates :)
15:14:13 <augur> ill be crashing to sleep now, but i hope some peeps here will find that an interesting little musing
15:14:20 <Cale> Yeah, I wouldn't do that, I'd just write do-notation, lol.
15:15:39 <Cale> There are certain cases where it's nice to be points-free, but eventually it can be obnoxious to maintain code of that sort.
15:15:48 <edwardk> > [(Just 1, Just 2)]^..traverse.to (sequenceOf both)._Just
15:15:51 <lambdabot>  [(1,2)]
15:16:02 <Cale> I've often found myself replacing uses of 'maybe' with case expressions, on a kind of similar note.
15:16:09 <edwardk> try cleaning that up
15:16:11 <edwardk> gotta run
15:16:40 * hackagebot type-eq 0.4 - Type equality evidence you can carry around  http://hackage.haskell.org/package/type-eq-0.4 (GaborLehel)
15:17:02 <pqmodn> > [(Just 1, Just 2), (Just 3, Nothing)]^..traverse.to (sequenceOf both)._Just
15:17:05 <lambdabot>  [(1,2)]
15:17:20 <Peaker> > [(Just 1, Just 2)]^..mapped.to (sequenceOf both)._Just
15:17:22 <lambdabot>  No instance for (Control.Lens.Internal.Setter.Settable
15:17:22 <lambdabot>                     (Control.Lens.Internal.Getter.Accessor
15:17:22 <lambdabot>                        (Data.Monoid.Endo [(b0, b0)])))
15:17:22 <lambdabot>    arising from a use of `e_112'
15:17:22 <lambdabot>  Possible fix:
15:17:46 <merijn> Dasuraga: How precise do you want to be?
15:18:08 <merijn> Dasuraga: i.e. does it matter if your timer drifts? How accurate do you want to be?
15:18:31 <Peaker> Cale: I don't use "maybe" much, because it's just a less nice syntax for a case expression. Only if I have an existing function name or a really nice points-free for the Just case will I use it
15:18:43 <Peaker> Cale: and if I have something nice to call an intermediate, I'll use do notation and do that
15:18:47 <merijn> Dasuraga: Could be as simple as "forever $ threadDelay 100000 >> sendChar"
15:18:54 <Peaker> Cale: but if the intermediate name is just some silly var name -- I prefer the pipe-line
15:19:05 <jle`> > map (uncurry (<*>) . over _1 (fmap (,))) [(Just 1, Just 2), (Just 4, Nothing)] -- jrmithdobbs
15:19:08 <lambdabot>  [Just (1,2),Nothing]
15:19:16 <Cale> > toListOf (traverse . to (sequenceOf both) . _Just) [(Just 1, Just 2)]
15:19:19 <lambdabot>  [(1,2)]
15:19:30 <Cale> yay, immediately somewhat more readable ;)
15:19:57 <Dasuraga> merjin : it doesn't need to be that precise
15:20:26 <jrmithdobbs> :t map (uncurry (<*>)
15:20:27 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:20:36 <Dasuraga> I guess my issue is more that I already have all this framework to generate this initial list, I don't reallly know how to "intersperse" values into it
15:20:43 <jrmithdobbs> erm
15:21:09 <CADD> :t map (uncurry (<*>))
15:21:10 <lambdabot> Applicative f => [(f (a -> b), f a)] -> [f b]
15:21:13 <Peaker> Cale: I'm used to ^..   toListOf looks like: 5 `plus` 6
15:21:16 <Peaker> Cale: heh
15:21:32 <Cale> I hate essentially all of the infix operators in lens
15:21:57 <Cale> ^.. isn't among the worst sort though
15:22:01 <Peaker> Heh, I love most of them :)
15:22:01 * djahandarie too, probably
15:22:45 <Peaker> I hate when some silly library makes up operator names. But for A) pretty generic stuff B) fundamental stuff that upgrade the whole Haskell experience   I make my exception :)
15:22:54 <Cale> The worst thing imo are all the things like //~
15:23:31 <Cale> Does anyone *really* need an operator for dividing the target of a numerically valued lens by some value?
15:23:42 <Peaker> All the +=, -=, *=,  +~, -~, *~  stuff is essentially the same -- since it reuses names we already know and just adds ~ or = to add a meaning we have to remember just once
15:23:43 <Cale> Or could we just leave that up to over?
15:24:00 <Cale> Yeah, even += I would get rid of
15:24:44 <Peaker> > (1, 2) & _1 -~ 100
15:24:48 <lambdabot>  (-9
15:25:09 <c_wraith> huh.  lambdabot just went nuts
15:25:10 <Cale> %~ and %= aren't so bad
15:25:36 <CADD> Cale: they essentially are implemented with over
15:25:42 <Cale> CADD: I'm aware of that
15:26:09 <CADD> Cale: its then just a standardization of that semantic convenience
15:26:12 <Peaker> (1, 2) & _1 %~ (- 100 + 3 + 5)  VS.  (1, 2) & _1 -~ 100 + 3 + 5
15:26:14 <triliyn> We should replace them all with spelled-out versions, or perhaps just provide both
15:26:17 <triliyn> percentTilde
15:26:23 <Peaker> oops, %~ subtract (100 + 3 + 5),  even more bah :)
15:26:32 <Cale> CADD: That convenience is so convenient that we don't need to define all these special cases of it IMO
15:26:37 <jrmithdobbs> sequenceOf is nifty, hadn't played with Sequenced much yet
15:26:47 <triliyn> What is %~ anyway? Modulus or something?
15:26:51 <triliyn> @src (%~)
15:26:51 <lambdabot> Source not found. My brain just exploded
15:27:01 <jrmithdobbs> triliyn: apply function to (infix lens map)
15:27:05 <c_wraith> no, % is the symbolic version of "modify" in lens
15:27:07 <triliyn> oh
15:27:24 <CADD> Cale: you are right, there is a fine line to tow between convenience and simplicity. these constructs are more familiar to imperative programmers
15:27:25 <triliyn> So it kind of breaks the convention
15:27:26 <Peaker> triliyn: %~ is basically a pun where "modulus" became "modify" due to both being called "mod" in short
15:27:39 <triliyn> ah, that's silly :P
15:27:49 <Peaker> Cale: do you think there is a better use for the names <known operator with ~/= suffix> ?
15:27:52 <CADD> Cale: and i know that simplicity isnt even the right way to put it, maybe orthogonality works better.
15:28:07 <Peaker> Cale: I think saving parenthesis every single time I do arithmetic is a worthy thing to have
15:28:27 <CADD> Cale: plus at least the way its being done isnt just some hack.
15:28:50 <Cale> Peaker: Being available for use.
15:28:59 <Peaker> Cale: did anyone on hackage use any of those?
15:29:06 <Cale> Maybe not!
15:29:29 <Cale> But that doesn't mean we should dump a few dozen of them into scope when one or two will do!
15:29:36 <Peaker> well, in the *very* rare case you want to use those operators, Haskell has import semantics
15:29:54 <Cale> We could make a similar argument that Data.List should define specialised versions of map for arithmetic
15:30:01 <Cale> Why doesn't it do that?
15:30:17 <CADD> Cale: you are right, that is why there are other libraries that take a more purist approach
15:30:19 <Peaker> new Haskell code that I write is using lenses everywhere, so these operators save me from wrapping stuff in annoying sections quite a bit -- and they only cost me a namespace that I'd never use anyway
15:30:48 <CADD> Cale: although not to say lens isnt purist up to that point
15:30:54 <Cale> There's a reason that functions are first class, and it's to some extent precisely to avoid this kind of noise in libraries!
15:30:54 <Peaker> Cale: they wouldn't be as general.. operators should be reserved for relatively general stuff
15:31:28 <CADD> Cale: again, not saying you are wrong. but repetition helps get concepts across
15:31:54 <Cale> CADD: You mean, taking all these operator definitions as examples of how to apply lens?
15:32:08 <CADD> Cale: yeah
15:32:17 <Cale> If that's the intent, I would have them moved into a separate package, or at least a separate module.
15:32:25 <Peaker> Cale: I don't think it means much to talk about how many operators there are in lens -- maybe about how many naming schemes there are. Because the cost of having +~, vs having +~, -~, *~, etc is virtually the same (you have to remember about the same amount to use them)
15:32:27 <CADD> Cale: i think that is a good idea :D
15:32:59 <Cale> Peaker: But you have to wonder about other operators
15:33:01 <Peaker> I suggested they have Control.Lens.Operators and they did (yay!) (the only module I import open/unqualified, since I hate import* in general)
15:33:07 <Cale> Whether or not there's a special version
15:33:15 <Cale> Why don't we have >>=~ ?
15:33:18 <Cale> (or do we?)
15:33:43 <CADD> Cale: only one way to find out
15:33:44 <Peaker> well, it's an interesting suggestion :)
15:33:51 <CADD> very
15:33:57 <Cale> It's a terrible suggestion
15:34:08 <CADD> lol, its an extrapolation
15:34:12 <Peaker> it's not going to be as useful as arithmetic
15:34:21 <Peaker> but I'd accept it as valid :)
15:34:25 <CADD> same
15:34:29 <Cale> Obviously it will typecheck
15:34:33 <Cale> That doesn't make it tasteful
15:34:44 <CADD> lol, code is data and data is code
15:34:54 <CADD> why limit the programmer?
15:34:57 <jle`> still waiting for a library function foo f x = iterate (>>= f) (return x), btw.
15:35:04 <Cale> Also, .~ does the wrong thing
15:35:09 <Cale> :t (.~)
15:35:10 <lambdabot> ASetter s t a b -> b -> s -> t
15:35:40 <nooodl> jle`: would that be "iterateM" or something?
15:36:11 <Cale> This should have type  ASetter s t (a -> b) (a -> c) -> (b -> c) -> s -> t
15:36:19 <Cale> Right?
15:36:26 <Cale> But no
15:36:50 <CADD> Cale: if it was agda
15:36:54 <Peaker> Cale: Well, :~ or := were not available for use, iirc
15:36:56 <jle`> nooodl: yes but there is no such thing.  maybe i should submit something to monad-loops
15:37:10 <Cale> My point isn't that it would be a good idea
15:37:20 <Cale> But that this whole mess is bad :P
15:37:30 <CADD> Cale: i dont see why not
15:37:39 <CADD> Cale: i would love to see a proof of concept
15:37:49 <Cale> It's using convention to shave off a slight few characters
15:37:56 <Peaker> Cale: foo & point .~ 5    is nicer than:  point %~ const 5 $ foo
15:38:03 <Cale> rather than just making people use the general things which are already in place
15:38:46 <Cale> It's the same kind of ugliness as having concatMap be its own function :)
15:39:12 <Cale> Only without the excuse that it can be more efficient for stupid compilers
15:39:15 <Peaker> Cale: well, everyone agrees the benefit is rather minor (though spread over a *lot* of little savings).  You think the cost is high, but I don't think it's very high.  And I really like appealing to a Python programmer with:   players . around 1 target . health -= fireDamage
15:39:52 <Peaker> rather than  %=  subtract fireDamage
15:40:21 <Peaker> so I think the (admittedly low) benefit is worth the (IMO low) cost
15:40:25 <Cale> I guess I just don't care *quite* that much about appealing to Python programmers.
15:40:45 <CADD> I think you are both right
15:40:49 <Peaker> well, that's a side benefit :)  It also appeals to other imperative programmers :)  I am also interested in selling Haskell to potential collaborators
15:40:55 <CADD> really, avoid sucess at all costs
15:41:01 <CADD> but also make haskell do cool things
15:41:15 <Cale> I have no interest in selling Haskell to anyone. It should stand on its own two legs or die.
15:41:16 <Peaker> but I prefer -= damage    over %= subtract damage  for me too -- it's less noisy
15:41:25 <Cale> :D
15:41:47 <Peaker> Cale: Well, selling Haskell means that I can use it in the workplace for more things, because others agree it is good, which means I don't have to use Python or other nonsense
15:41:55 <CADD> haskell is a language labratory. lets experiment.
15:42:10 <CADD> that as well
15:42:23 <Peaker> (though the selling thing is just a side-benefit, of course, I like slightly less noise in many of my code lines for me too)
15:42:36 <Peaker> (even if it means a very commonly-used library has more noise in it)
15:43:00 <Cale> CADD: See, but if Peaker goes and makes Haskell too popular, eventually enough new users will complain whenever it gets used too much as a laboratory that it won't be a good laboratory.
15:43:29 <CADD> Cale: thats why we have things like agda :D
15:43:41 <jle`> and what happens when agda gets too popular?
15:43:54 <jle`> there won't always be more dry trees
15:43:55 <CADD> Cale: come on, agda-mode in emacs is the best thing since sliced bread.
15:44:03 <Cale> jle`: We'll burn that bridge when we cross it :)
15:44:18 <jle`> where is that dry trees reference from.
15:44:19 <CADD> Cale: the proof general is cool too
15:44:51 <Cale> CADD: It is pretty good, but it doesn't really make the Agda standard library much easier on my hands.
15:45:18 <Cale> CADD: The one thing which prevents me from playing with Agda more is all the unicode syntax causing my hands to ache after an hour or two.
15:45:36 <Peaker> I hate unicode syntax too :(
15:45:39 <jle`> maybe agda should ship a keyboard
15:45:53 <CADD> Cale: idk, i dont find typing \r any more harder than ->
15:45:54 <Cale> My keycaps are already blank
15:46:25 <Peaker> CADD: how do you know that you should type \r and not -> ?
15:46:34 <CADD> Cale: call me weird but i actually like my code looking like the research papers i read.
15:46:49 <Peaker> CADD: I like that too - which is why I wish more research papers used ascii notation :P
15:46:49 <Cale> I tend to type -> with my index and thumb, while \ is far enough away that I end up hitting it with my pinky.
15:46:57 <CADD> Peaker: becasue \r is a shortcut for \right with renders to the unicode ->
15:47:21 <CADD> Peaker: thats true as well.
15:47:21 <Peaker> CADD: what I mean is -- it's not discoverable. Whereas ascii is, because the keys on the keyboard have the little drawings on them to help :)
15:47:21 <Cale> (I don't use the usually-taught method to type, my hands tend to float over the keyboard a little, and they remain at an angle with it)
15:47:31 <jle`> i'll never get used to it, there is something endearing about ->
15:47:39 <jle`> reminds me of my days as a freelance ascii artist.
15:47:48 <Cale> Peaker: They do some things to make it discoverable
15:47:55 <Peaker> I don't mind -> being *rendered* as an arrow, and other unicode renderings, as long as there is a semi-obvious/discoverable way to type them
15:47:56 <Cale> Peaker: you can point at a character and ask about it
15:48:07 <CADD> Peaker: that is right too.
15:48:11 <Cale> but that's obviously not as good as just being able to look at it
15:48:30 <Peaker> Cale: well, the problem is that it doesn't work in various contexts (I can't do it on the PDF) -- assuming I get the right character rather than an empty square
15:49:01 <CADD> ive actually been getting really interested in twelf recently
15:49:03 <Cale> I actually kind of mind -> being rendered as an arrow, so long as we're going to have layout-sensitive syntax (which I do like), and store our code in plain text files (which I care a bit less about)
15:49:16 <Cale> Because it converts two columns into one
15:49:46 <Cale> Though I guess you could be just like Agda mode presently is, and immediately do the replacement as you type
15:50:00 <Cale> and then it's not like there's really a -> in the file
15:51:15 <Peaker> in Lamdu we render stuff with an automatic layout we think is nice, and use renderings of symbols, but we make those symbols as discoverable as possible, for right arrow you can type "->" or "pi" (it's a pi type) or the unicode arrow (and maybe we should add more)
15:51:30 <Peaker> (and we don't use plain text files to store the code)
15:52:06 <Cale> Is this the weird language with the wildly different font sizes, or something else? :)
15:52:29 <Cale> oh, it is :D
15:52:48 <Peaker> Cale: heh.. we might need to get a handle on the font size craziness :)
15:52:56 <Peaker> though we like the ability to make things smaller to de-emphasize them
15:53:04 <Peaker> (e.g: the parameter names in function applications)
15:53:20 <Peaker> we use a gray color and smaller font for that
15:53:22 <Cale> Somehow whenever I see the screenshots, I envision fractal programs with terms at ever decreasing scales.
15:53:35 <Peaker> :-)  If you have many nested where clauses, that'll happen :)
15:53:41 <Peaker> code in "where" is also de-emphasized by being smaller
15:54:00 <Peaker> though maybe we should be more cautious about doing that
15:54:20 <CADD> Peaker: how are let ... in ... 's emphasized?
15:54:36 <Peaker> CADD: we don't have "let ... in ..."  we prefer "where"
15:55:00 <CADD> Peaker: aww, ok
15:55:16 <Cale> Oh, so where is an expression form
15:55:26 <Cale> Right, right
15:55:47 <Cale> I remember this coming up before :)
15:56:01 <CADD> its an expression form?
15:56:05 <Peaker> Cale: well, we're not sure about that -- maybe just have a local "where" not in a binding clause -- which we don't currently have, or just extract to a separate definition which does have "where" (but it forces you to name it)
15:56:30 <Peaker> or just put a "where" in the binding context "above" the position you want the name
15:57:03 <Peaker> in a lazy language, you can have let/where only where names are bound, if you want
15:58:16 <Peaker> we might not be a lazy language eventually though (or rather, laziness will probably use explicit thunk types, and a nice UI to hide the mess that may result)
15:58:35 <Cale> Peaker: Do you use your named-parameters-everywhere to do an order-invariant sort of currying?
15:58:44 <Peaker> Cale: yeah (not implemented yet)
15:59:02 <Peaker> Cale: of course the named parameters do not require you to ever type a parameter name (except when first defining the called function)
15:59:06 <Peaker> (or when defining its type)
15:59:53 <Peaker> except it's not really currying, just a lot of eta-expansions behind the scenes, hidden by the UI
16:00:02 <Cale> My first impression of them is that they're still a bit visually noisy, but they would be helpful to beginners, or just people who are new to a given library.
16:00:27 <Cale> (obviously in general it's very nice to have such things in some cases, but I'm talking about having it everywhere like you do)
16:00:38 <Peaker> Cale: well, I guess functions where the parameters need not be named can use a presentation mode for that.. But seeing a bunch of params of the same type without names even as an expert is terrible
16:00:51 <Cale> yes
16:01:08 <Peaker> Cale: yeah, it's far from being optimized for real-world use yet.. the UI will surely need tuning when it stops being a toy :)
16:02:53 <davidfetter_disq> !help
16:02:55 <davidfetter_disq> hrm
16:02:59 <davidfetter_disq> lambdabot, help
16:03:00 <Cale> @help
16:03:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:03:04 <Cale> @list
16:03:05 <lambdabot> What module?  Try @listmodules for some ideas.
16:03:07 <jle`> ok glass, help
16:03:09 <Cale> oh, right :D
16:03:21 <davidfetter_disq> @listmodules sql
16:03:21 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
16:03:58 <davidfetter_disq> wow, cool. can i /msg lambdabot rather than spam the channel with my explorations?
16:04:02 <Cale> yes
16:04:12 <davidfetter_disq> perfect!
16:05:09 <jle`> is there any way i can invite lambdabot to a custom
16:05:41 <jle`> so i can have something like a private message conversation and still be able to use it
16:06:13 <Cale> I can make it join a channel for you
16:06:21 <Cale> Provided I'm still an op ;)
16:06:37 <jle`> ah ok
16:06:50 <shachaf> jle`: You can run your own lambdabot.
16:07:06 <Cale> (If you want to make that permanent, you'll have to talk to the person running lambdabot, who I think is int-e at the moment.)
16:07:07 <shachaf> Probably better than bringing the real lambdabot to tiny channels.
16:07:14 <Cale> Or that, yeah
16:11:42 <Sgeo> How does (Given a) => r make any sense? How does the type-checker not assume that the (Given a) => is unnecessary? And if it doesn't do that, how do typeclasses... ever make sense?
16:11:58 <Sgeo> :t \a b c -> const () $ a + b
16:11:59 <lambdabot> Num b => b -> b -> t -> ()
16:12:09 <Sgeo> :t (\a b c -> const () $ a + b) 5 5
16:12:10 <lambdabot> t -> ()
16:12:44 <Sgeo> Hmm, why did it call it t? (not as interesting a question)
16:13:40 <pqmodn> if you're motivated i think you'll find the answer in GHC's "renamer"
16:14:32 <Sgeo> More motivated to understand the typeclass thing, to try to understand reflection
16:15:46 <pqmodn> Sgeo: is there more context to your question about "Given a => r"? not sure i understood.
16:16:26 <Sgeo> http://hackage.haskell.org/package/reflection-1.3.2/docs/Data-Reflection.html
16:16:34 <Sgeo> give takes a type of (Given a) => r
16:16:42 <Sgeo> I'm not even sure how that would be constructed
16:17:06 <pqmodn> ah, that's above my pay grade.
16:17:18 <Sgeo> Also, that reify/reflect example
16:17:18 <Sgeo> >>> reify 6 (\p -> reflect p + reflect p)
16:17:19 <Sgeo> 12
16:17:37 <Sgeo> That doesn't exactly illustrate how to use it to avoid needing to pass arguments around, which I thought was the point
16:17:38 <pqmodn> Given a => a would seem plausible, but i'm not sure what it means when the qualified type is not bound
16:18:13 <tbelaire1> Hello
16:18:21 <jle`> hello tbelaire1
16:18:38 <Cale> Sgeo: With unsafeCoerce, anything is possible
16:18:38 <tbelaire1> I've got a Behavior [UI Element] I want to turn into "UI Behavior [Element]"
16:18:55 <tbelaire1> I'm working with threepenny-gui
16:19:04 <Cale> Sgeo: but really, note that both type parameters occur on the left of the =
16:19:14 <Sgeo> If I have a (Given a) => b -> b, and I supply it with a b, would I lose the Given?
16:19:36 <Cale> I assume you're talking about:
16:19:39 <Cale> newtype Gift a r = Gift (Given a => r)
16:19:40 <glaebhoerl> Sgeo: it helps to think of => as just a magic function. i.o.w. `Given a -> r` needs a `Given a` to make an `r`. `Given a => r` is the same except the `Given a` is inferred/provided by the compiler.
16:19:49 <Sgeo> Not even looking at the newtype or implementation
16:19:57 <Sgeo> Just trying to understand how to use it
16:20:00 <Cale> Well, what type are you looking at?
16:20:19 <Sgeo> give, and trying to imagine how I would use give/given
16:20:46 <Cale> Well, you can push that constraint outward if it helps you read the type
16:21:24 <Cale> give :: forall a r. Given a => a -> r -> r
16:21:54 <Cale> Actually, I'm not sure that'll work ;)
16:21:58 <Sgeo> If I'm using Haskell Platform, is it safe for me to cabal install cabal-install?
16:21:58 <glaebhoerl> Cale: no you can't, for the same reason that `a -> (Given a -> r) -> r` is not the same as `Given a -> a -> r -> r`
16:22:02 <Cale> There might be some magic here
16:22:06 <Cale> yes
16:22:18 <Cale> because of the need to unsafeCoerce
16:22:26 <Sgeo> And will it get me 1.18... looks like it will... oh, I misread your yes
16:22:27 <Sgeo> crud
16:23:11 <glaebhoerl> again, Given a => r should be thought of as a function... it actually has nothing to do with unsafeCoerce
16:23:43 <Cale> But it's not.
16:23:47 <Sgeo> But how can I trust the compiler to not get rid of the Given a? The necessity of it isn't obvious in the type, I think
16:23:51 <Cale> It's a constraint
16:23:51 <shachaf> Given is just a special-cased version of reflection?
16:24:05 <Cale> (or a constrained type)
16:24:31 <shachaf> I mean what it's for.
16:24:39 <Sgeo> shachaf: I think so. And I still don't get how reflection is useful though, I want a better example than that cruddy example in the docs that makes it look like I might as well just pass around an argument
16:24:57 <shachaf> I wrote an explanation of reflection once.
16:25:01 <glaebhoerl> gah, is the user guide for the upcoming version of GHC online anywhere?
16:25:03 <shachaf> http://stackoverflow.com/a/17794883
16:25:07 <Sgeo> Of how to use it or how it works?
16:25:10 <glaebhoerl> or actually I want the docs for base
16:25:15 <glaebhoerl> but w/e
16:25:18 <shachaf> How it works.
16:25:24 <glaebhoerl> https://ghc.haskell.org/trac/ghc/wiki/TypeLevelNamingIssues look at point 5 under Issues at the bottom
16:25:28 <glaebhoerl> that function will be in GHC 7.8
16:25:30 <Sgeo> Oh :/ for once in my life, I would really prefer the former
16:25:34 <shachaf> If you want to figure out how to use it you can just read the original paper.
16:25:48 <shachaf> Which goes to a lot more trouble to make it work, of course.
16:25:52 <glaebhoerl> it works the same way:
16:25:55 <glaebhoerl> gcastWith :: (a :~: b) -> ((a ~ b) => r) -> r
16:25:56 <glaebhoerl> gcastWith Refl x = x
16:26:25 <glaebhoerl> ((a ~ b) => r) is some term that needs evidence that a ~ b before it can make an r
16:26:27 <shachaf> glaebhoerl: Hooray, that's going into GHC?
16:26:45 <shachaf> I wonder why it's called gcastWith given that gcast's type is pretty different.
16:26:57 <glaebhoerl> the function takes that evidence from a :~: b (which is a GADT) and provides it
16:27:12 <shachaf> Is (Typeable a, Typeable b) => Maybe (a :~: b) going into GHC?
16:27:13 <glaebhoerl> (it's the same principle as the maybe and either functions)
16:27:23 <glaebhoerl> shachaf: yes, both of those are :)
16:27:31 <shachaf> Hooray.
16:27:39 <joelteon> Can you put class constraints on associated types?
16:27:47 <shachaf> Apparently things can happen when you send messages to mailing lists.
16:28:05 <glaebhoerl> joelteon, (unfortunately?) no
16:28:29 <joelteon> ok
16:29:12 <glaebhoerl> shachaf: I'm not a huge fan of the gcastWith name either, if you can suggest a better one for them to use, maybe it's not too late :)
16:29:31 <shachaf> Where else does the ((a ~ b) => r) -> r pattern appear?
16:29:33 <shachaf> I've seen it before.
16:29:52 <glaebhoerl> (it's called that because it's kind of a generalization of castWith :: (a :~: b) -> a -> b)
16:30:38 <glaebhoerl> shachaf: uhm, which part of the pattern do you mean? the whole thing? I'm guessing you know about CPS
16:30:53 <Sgeo> Could I just use reflect Proxy?
16:30:53 <shachaf> I mean with the equality constraint and all.
16:31:03 <Sgeo> Whenever I want, within the extent of the reify?
16:31:07 <shachaf> Literally that exact string.
16:31:20 <shachaf> Anyway I don't remember.
16:31:57 <glaebhoerl> shachaf: I have basically the same thing in a package of mine, http://hackage.haskell.org/package/type-eq-0.4/docs/Type-Eq.html#v:withEq, but I don't know if you've ever come across it
16:32:07 <shachaf> Not sure.
16:32:12 <Sgeo> Apparently not
16:32:14 <glaebhoerl> other than that, no idea
16:32:24 <Sgeo> But... I don't want to need to pass around proxies
16:32:28 <shachaf> Sgeo: By the way, it might be helpful to realize that reify is encoding an existential type.
16:32:47 <Sgeo> Is that the explanation of why I can't just use reify Proxy?
16:32:59 <shachaf> reify :: a -> (exists s. Reifies s a *> Proxy s)
16:33:08 <shachaf> (But actually using it with that type is kind of useless.
16:33:11 <Sgeo> Because now I still don't get the use
16:33:19 <shachaf> Did you read the paper?
16:33:22 <shachaf> @google prepose.pdf
16:33:24 <lambdabot> http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
16:33:24 <lambdabot> Title: Functional Pearl: Implicit Configurations
16:33:31 <Sgeo> I'll try it again, I guess
16:33:56 <shachaf> It might be sufficient to stop at the simple version where you just reflect natural numbers.
16:34:13 <glaebhoerl> Sgeo: might help if you realize it's just like the reader monad, except the value gets passed with magic at the type level
16:34:32 <shachaf> It's not all that magic except for the implementation.
16:34:33 <glaebhoerl> (i think you could even make a MonadReader instance if it weren't for `local`)
16:34:43 <shachaf> In particular the natural number version isn't really magic at all.
16:34:56 <Sgeo> glaebhoerl: that's nice except for the part where I seem to be relying on reflecting on an argument that reify gives me, making it more like writing out the reader monad than actually using something convenient like the reader monad
16:35:57 <AfC> I have a Map. It's a lovely Map, with keys and values and everything. It's not _that_ large. Few 10s of MB at most. Unfortunately, I need to persist it somewhat reliably.
16:36:01 <shachaf> You can write e.g. instance Reifies ... => MyClass ... where ...
16:36:08 <glaebhoerl> (the value over the reader monad is that you get the same kind of guarantees about always-the-same-value as you do with type classes in general, and related performance optimizations, and with more advanced ConstraintKinds hacking you can even synthesize your own typeclass dictionaries at runtime)
16:36:09 <AfC> I can control concurrent access etc, so I'm wondering if just using Data.Serialize or so would be sufficient, or whether I should be using some acid-state thing, or a Haskell binding to gdbm, or...
16:36:19 <AfC> Any suggestions?
16:36:32 <glaebhoerl> Sgeo: reify <=> runReader, reflect <=> ask
16:36:37 <glaebhoerl> it's not that different
16:36:40 <lightquake> shachaf: ekmett's implementation is the one that relies on ghc's typeclass internals, right?
16:37:22 <Sgeo> Except when I use ask it's able to get its 'argument' without me explicitly giving it. reflect wants an argument
16:37:34 <glaebhoerl> Sgeo: there's some example code included in the package which it might be helpful to look at
16:38:21 <glaebhoerl> Sgeo: oh, you're right, I was thinking of the old implementation which used Tagged and not Proxy
16:40:23 <Cale> glaebhoerl: I see your point, but I'm rather confused about how GHC deals with this. It seems to run counter to some assumptions I have about how GHC deals with constraints and type variables. Is it possible to write anything like this *without* the unsafeCoerce, where you're able to convince it to eliminate a typeclass constraint on a polytype?
16:40:57 <glaebhoerl> Cale: yes, that's why I linked the example using equality constraints
16:41:04 <Cale> hmm
16:41:23 <Cale> How is it that GHC is willing to bind r to a polytype?
16:41:37 <Cale> Is that new?
16:41:46 <glaebhoerl> Cale: it works as of GHC 7.0 :)
16:41:51 <Cale> hm
16:41:52 <Cale> :)
16:42:37 <glaebhoerl> I'm not sure I can give a compact and coherent explanation of why it works right now, it's been a while since I thought it through (and even then my understanding is more intuitive than concrete)
16:42:47 <Cale> I guess I have a bunch of old assumptions about what GHC will do when unifying types in my head :)
16:42:59 <shachaf> Cale: Wait, which thing are you talking about now?
16:43:21 <Cale> shachaf: There's an r in either example
16:43:26 <shachaf> Oh, is this about glaebhoerl's (f a ~ g b) email?
16:43:32 <Cale> er, no
16:43:38 <shachaf> Are you talking about reflection?
16:43:42 <L8D> :t (~)
16:43:43 <lambdabot> parse error on input `)'
16:43:52 <L8D> What is the ~ operator?
16:43:55 <Cale> https://ghc.haskell.org/trac/ghc/wiki/TypeLevelNamingIssues 5 here at the bottom, or the type of 'give' in the reflection
16:43:59 <shachaf> L8D: Type equality.
16:44:11 <L8D> shachaf: In what cases would you use that?
16:44:58 <glaebhoerl> Cale: basically what helped my understanding is that it's just a CPS transform, except you can CPS transform not only values but also types and constraints
16:45:07 <countoren> http://lpaste.net/97175   any help?
16:45:18 <shachaf> Oh.
16:45:20 <Cale> Well, I can understand what it does at runtime
16:45:33 <Cale> It's just I'm surprised at GHC's willingness here :)
16:46:49 <Aetherspawn> Is there a Russell Johnston (rpjohnst) here?
16:47:40 <pavonia> countoren: it requires an Address not a String for the to/from parameters
16:47:58 <countoren> o
16:48:08 <glaebhoerl> Cale: anyway, to get a better explanation of it you'd probably have to ask someone like Simon or Edward :)
16:48:13 <Cale> yeah
16:48:33 <countoren> pavonia: thanks ill check it
16:50:20 <L8D> When would you need to compare types?
16:50:49 <glaebhoerl> L8D: you're not comparing them, you're requiring them to be equal
16:50:50 <shachaf> It is not a type equality check. It's a constraint.
16:50:59 <Cale> L8D: When you've forgotten one of them via an existential
16:51:08 <glaebhoerl> for example, id :: a -> a and id :: (a ~ b) => a -> b are the same thing
16:51:20 <Cale> (sort of)
16:51:20 <L8D> oh
16:51:23 <glaebhoerl> more commonly you need this kind of thing with type families
16:51:29 <L8D> So it’s used in type declarations
16:51:42 <L8D> Not equations
16:51:43 <startling> yes.
16:51:45 <Cale> L8D: yes, only in types
16:51:49 <L8D> got it
16:52:46 <jle`> it's a function on types, not on data/values
16:53:09 <shachaf> It's not really a function.
16:53:12 <L8D> Is there any way or point to defining your own type-functions like (~)?
16:53:14 <Cale> L8D: You can in various ways pass around *evidence* that two types are equal which arrives perhaps via a different path from the values of those types, in order to be able to perform some operation that needs them to be the same.
16:53:15 <jle`> operator
16:53:18 <jle`> ?
16:53:36 <Cale> L8D: Well, ~ is very much built in
16:53:47 <L8D> I mean functions that deal with types alone, meant for the compiler to use
16:53:49 <Cale> L8D: But there is a point to defining your own constraints on types
16:54:20 <L8D> I guess there would be no use to them anyways...
16:54:21 <Cale> and yes, type functions in general
16:54:30 <Cale> We use type-level functions all the time
16:54:45 <L8D> Example?
16:54:47 <Cale> (->) is a type level function which takes two types and gives you the type of functions from one to the other
16:54:59 <L8D> Oh
16:55:03 <Cale> Maybe is a type-level function which takes a type t and gives you the type Maybe t
16:55:08 <L8D> I thought you meant user-defined type-level functions
16:55:18 <L8D> But not data constructors
16:55:22 <Cale> But also user-defined type level functions are often quite handy
16:55:23 <shachaf> Sgeo: Maybe looking at how it works will help you understand what it's good for.
16:55:29 <Cale> If I'm defining a vector space type class
16:55:38 <Cale> I might add an associated type synonym like:
16:55:43 <Cale> class VectorSpace v where
16:55:48 <L8D> I know.
16:55:49 <Cale>   type Scalar v
16:56:00 <Cale> This makes Scalar into a type level function
16:56:21 <Cale> associating each type which is an instance of VectorSpace with its type of Scalars
16:56:30 <Sgeo> This I can see the use of:
16:56:30 <Sgeo> Prelude Data.Reflection Data.Proxy> give 5 (given + given) :: Integer
16:56:31 <Sgeo> 10
16:56:57 <shachaf> reify 5 (\x -> reflect x + reflect x) -- seems nicer to me
16:57:07 <Sgeo> shachaf: but you need to pass around that x
16:57:11 <shachaf> Yes.
16:57:22 <Sgeo> Might as well write flip ($) 5 (\x -> x + x)
16:57:26 <Cale> Sgeo:  give 5 (give 6 (given + given))  WHERE IS YOUR GOD NOW?
16:57:35 <shachaf> Yes, or just 5 + 5
16:57:45 <L8D> Prelude Data.Reflection Data.Proxy> give 5 (give 6 (given + given))
16:57:46 <shachaf> You are correct that there are easier ways to compute the number 10.
16:57:46 <enthropy> how about 10
16:58:00 <L8D> > give 5 (give 6 (given + given))
16:58:02 <lambdabot>  Not in scope: `give'Not in scope: `give'Not in scope: `given'Not in scope: `...
16:58:12 <L8D> > import Data.Reflection; give 5 (give 6 (given + given))
16:58:13 <lambdabot>  <hint>:1:1: parse error on input `import'
16:58:17 <L8D> -.-
16:58:19 <Cale> L8D: It's not available
16:58:34 <enthropy> int-e might enable it?
16:58:40 <enthropy> @let import Data.Reflection
16:58:41 <lambdabot>  .L.hs:98:1:
16:58:41 <lambdabot>      Data.Reflection: Can't be safely imported!
16:58:41 <lambdabot>      The package (reflection-1.3.2) the module resides in isn't trusted.
16:58:41 <Cale> I'm also not sure I'd trust bringing it into scope
16:58:44 <shachaf> It's not really necessary.
16:58:52 <shachaf> I'd probably trust reflection.
16:58:56 <Cale> It *might* be fine
16:59:00 <shachaf> At least, there are things in lambdabot I trust much less.
16:59:12 <Cale> heh, well, okay :)
16:59:13 <shachaf> reflection is only mildly magic
16:59:25 <shachaf> But let's build natural number reflection ourselves.
16:59:27 <shachaf> :t Proxy
16:59:28 <lambdabot> Not in scope: data constructor `Proxy'
16:59:33 <dmwit> ?tell nomeata I'm not sure what the suckless folks would think of yeganesh-style functionality. At the moment, dmenu doesn't store anything on disk between runs.
16:59:34 <lambdabot> Consider it noted.
16:59:35 <shachaf> @let data Proxy a = Proxy deriving Show
16:59:36 <lambdabot>  Defined.
16:59:41 <shachaf> @let data Zero; data Succ n
16:59:42 <lambdabot>  Defined.
16:59:48 <glaebhoerl> btw I think reflection might've been added to GHC 7.8 too (or at least I read somethings in some emails which seemed to be implying such)... but I haven't been able to actually find it in the source, so maybe not
16:59:50 <shachaf> @let class Gimme a where gimme :: Proxy a -> Int
16:59:51 <lambdabot>  Defined.
16:59:55 <glaebhoerl> or maybe I just wasn't looking in the right place
16:59:59 <shachaf> @let instance Gimme Zero where gimme _ = 0
17:00:00 <lambdabot>  Defined.
17:00:05 <dmwit> ?tell nomeata As far as I'm concerned there's no reason dmenu can't have that functionality. But I don't plan on writing it or doing whatever politics would be required to get the dmenu folks to accept such a patch. =P
17:00:05 <lambdabot> Consider it noted.
17:00:10 <shachaf> @let instance Gimme n => Gimme (Succ n) where gimme _ = 1 + gimme (Proxy :: Proxy n)
17:00:11 <lambdabot>  Defined.
17:00:16 <L8D> @let data Peano = Zero | Succ Peano
17:00:17 <lambdabot>  Defined.
17:00:22 <shachaf> > gimme (Proxy (Succ (Succ (Succ Zero))))
17:00:23 <lambdabot>  Couldn't match expected type `L.Peano -> L.Proxy a0'
17:00:23 <lambdabot>              with actual type `L.Proxy a1'
17:00:26 <shachaf> Sigh/.
17:00:27 <shachaf> @undefine
17:00:28 <lambdabot> Undefined.
17:00:37 <Cale> @zippy -- does this work?
17:00:37 <lambdabot> Unknown command, try @list
17:00:45 <startling> shachaf, that's neat.
17:00:52 <shachaf> > gimme (Proxy (Succ (Succ (Succ Zero))))
17:00:53 <lambdabot>  Not in scope: data constructor `Succ'Not in scope: data constructor `Succ'No...
17:00:59 <shachaf> > gimme (Proxy :: Proxy (Succ (Succ (Succ Zero))))
17:01:02 <lambdabot>  3
17:01:15 <shachaf> Whoever cares, do you see how that works?
17:01:22 <Sgeo> Are give and given defined in terms of reify/reflect?
17:01:26 <startling> I didn't really realize you could use Proxy and typeclasses to do "* -> a"
17:01:39 <startling> I'm not sure why I didn't realize it.
17:02:05 <Sgeo> Nope
17:02:31 <shachaf> My advice is to forget give and given and just understand reify and reflect.
17:02:53 <shachaf> :t gimme
17:02:54 <lambdabot> Gimme a => Proxy a -> Int
17:04:01 <Sgeo> give and given sound like better fit for the use-case though, of not needing to thread around configuration data
17:04:09 <Sgeo> I'll read the paper when I get home
17:04:25 <Cale> Sgeo: Well, if that's all you want, there's implicit parameters too.
17:04:39 <Sgeo> I thought people disliked implicit parameters
17:04:51 <shachaf> Implicit parameters aren't supposed to work in the instance (?x :: Int) => ... case
17:05:04 <shachaf> In some versions of GHC they do.
17:05:17 <Cale> Yes, but nobody has come out in favour of actually using this hackery either :)
17:05:49 <shachaf> My Gimme class isn't hackery.
17:05:56 <shachaf> Well. It's not unsafeCoerce.
17:05:58 <Cale> shachaf: I'm referring to given/give
17:07:18 <joelteon> What's wrong with this? http://lpaste.net/97177
17:07:46 <shachaf> @let reify :: Int -> (forall n. Gimme n => Proxy n -> r) -> r; reify 0 k = k (Proxy :: Proxy Zero); reify n k = reify (n-1) (\(p :: Proxy v) -> k (Proxy :: Proxy (Succ v)))
17:07:46 <lambdabot>  Parse failed: Parse error: =>
17:07:50 <Sgeo> Ok, trying to play with given/give at GHCi, giving me some headaches
17:07:57 <Sgeo> I'll just go read the paper later
17:09:12 <pavonia> joelteon: If Bar maps to the same type for different classes, it's not clear which instances to use for baz and qux
17:09:23 <joelteon> I see
17:09:29 <Cale> (especially for qux)
17:09:36 <joelteon> is there a way to resolve that, or am I doing it wrong
17:09:50 <Cale> Use an associated data?
17:10:13 <joelteon> oh, that makes sense.
17:10:14 <Cale> If you replace type with data, you'll note that the error goes away
17:16:16 <dawik_> is there an alternative to paranthesis for flow control?
17:17:55 <Iceland_jack> Do you mean *control flow*?
17:18:06 <dawik_> yes
17:18:12 <Iceland_jack> Parentheses only group expressions, they're not related to control flow
17:19:08 <dawik_> ah, then my question is: how to group expressions other than with parantehses
17:19:21 <Peaker> dawik_: using precedence shenanigans
17:19:21 <Iceland_jack> Well you can use ($)
17:19:45 <Iceland_jack> You may want to read this dawik_: http://stackoverflow.com/questions/940382/haskell-difference-between-dot-and-dollar-sign
17:19:51 <dawik_> example please > :)
17:20:04 <Iceland_jack> dawik_: There is one in the link
17:20:05 <dawik_> i will
17:23:12 <Peaker> dawik_: instead of (long expression here) (another long expression here)   you can often use: long expression here $ another long expression here
17:23:31 <jle`>  $ kinda reminds me of the spine of a butterfly
17:23:33 <Peaker> dawik_: $ has the lowest precedence and is also application so it is parsed the same way
17:23:40 <jle`> it spreads its parentheses wings over both sides ^.^
17:24:15 <jle`> f x $ g y    => (f x) (g y)
17:24:50 <johnw> (f x) (g y) should be the same thing as f x (g y)
17:25:17 <jle`> just wanted a somewhat symmetric-looking example of butterfly wings.
17:25:35 <Peaker> (f <@~> x) (g <~@> y) can be  f <@~> x $ g <~@> y
17:26:05 <jle`> @_@ so pretty
17:26:05 <lambdabot>  so pretty
17:26:26 <jle`> huh apparently lambdabot agrees
17:27:50 <Fuuzetsu> Peaker: I don't think you'd ever end up in a (f x) (g y) scenario where ‘f x $ g y’ is the same seeing as it's just ‘f x (g y)’
17:28:22 <Fuuzetsu> oh, someone mentioned this already
17:28:23 <Peaker> Fuuzetsu: if operators are involved in making the function, you do
17:28:38 <Peaker> (i.e: instead of "f x", it is "foo <~> bar"
17:28:42 <Peaker> )
17:29:45 <scott_> (f . g) (x + y)  =>  f . g $ x + y -- for another example
17:30:54 <cdk_> @src reverse
17:30:55 <lambdabot> reverse = foldl (flip (:)) []
17:41:15 <jle`> i wish i could do something like ¬p instead of ¬.p, where p is a predicate a -> Bool
17:42:33 <dawik_> > foldl (\x y -> x ++ y) "" $ map show $ take 3 [1..]
17:42:34 <lambdabot>  "123"
17:42:54 <dawik_> it does not group funs i noticed
17:43:03 <scott_> You can write (\x y -> x ++ y) as simply (++)
17:43:52 <dawik_> orly
17:44:13 <dawik_> neat
17:44:31 <dawik_> so i take it the parantheses there is necessary?
17:44:54 <scott_> Yeah. You can use any operator as a function by surrounding it in parentheses
17:45:07 <jle`> :t (++)
17:45:08 <lambdabot> [a] -> [a] -> [a]
17:45:10 <scott_> Similarily you can use any function as an operator by surrounding the name in `backticks`
17:45:30 <scott_> (I use "fuction" vs.' "operator", but they're all just functions. Operators just have special syntax.)
17:46:03 <jle`> dawik_: what do you mean by it does not group funs?
17:46:23 <dawik_> anonymous function
17:47:11 <dawik_> first fold argument
17:47:27 <Fuuzetsu> Peaker: hence why I said ‘(f x) (g y) scenario where ‘f x $ g y’ is the same’ because that covers for any operators
17:47:52 <Peaker> Fuuzetsu: where what is the same? I don't understand
17:48:01 <joelteon> so for associated datatypes, the data declaration is within the instance declaration, is it?
17:48:01 <joelteon> or can you put it on its own
17:48:12 <johnw> within
17:48:27 <dawik_> > foldl (++) $ "" $ map show $ take 3 [1..]
17:48:29 <lambdabot>  Couldn't match expected type `[GHC.Base.String] -> [a0]'
17:48:29 <lambdabot>              with actual type `[GHC.Types.Char]'
17:48:37 <dawik_> hm
17:48:53 <dawik_> that was a massive fail
17:49:08 <jle`> $ associates left to right
17:49:17 <scott_> The problem is that it parenthesizes on the right, effectively. That's equivalent to:
17:49:22 <Fuuzetsu> I'm just saying that you'd never have a scenario where you end up with code like ‘(f x) (g y)’ that you can replace with ‘f x $ g y’ because if you can replace it with that, you'll just have ’f x (g y)’ to begin with. It doesn't really matter.
17:49:26 <scott_> foldl (++) ("" $ map show $ take 3 [1..])
17:49:26 <jle`> so you are really doing foldl (++) ("" $ map show ..... i stop writing because scott_ has got this
17:49:35 <scott_> There it's trying to use "" as a function
17:49:49 <scott_> jle`: :P
17:50:00 <Fuuzetsu> "" is my favourite function
17:50:15 <scott_> It can be, with OverloadedStrings!
17:50:19 <jle`> haha
17:50:19 <ion> fuuzetsu: (id <> reverse) ("foo" <> "bar")
17:50:48 <Fuuzetsu> ion: What about it?
17:51:00 <Fuuzetsu> hm
17:51:02 <Fuuzetsu> wait
17:51:33 <Fuuzetsu> I see. Alright.
17:51:38 <scott_> Hmm, (id <> reverse) is my new favourite palindrome generator
17:51:50 <dawik_> "<scott_> Yeah. You can use any operator as a function by surrounding it in parentheses" mind blown
17:52:06 <Fuuzetsu> > (id <> reverse) "foo"
17:52:07 <lambdabot>  "foooof"
17:52:10 <scott_> > (+) 5 10
17:52:12 <lambdabot>  15
17:52:29 <Fuuzetsu> > (id <> reverse <> take 3) "foo"
17:52:30 <lambdabot>  "fooooffoo"
17:52:35 <Fuuzetsu> > (id <> reverse <> take 3) "foozzy"
17:52:36 <lambdabot>  "foozzyyzzooffoo"
17:53:14 <ion> (FWIW, i prefer that expression with the parens.)
17:53:47 <enthropy> > (++) `flip` "table" $ "a "
17:53:48 <lambdabot>  "a table"
17:54:25 <Fuuzetsu> I think operator sections are cooler
17:54:50 <enthropy> odd that you can't (`flip`) -- 0-argument section?
17:55:23 <shachaf> I agree that it is odd.
17:55:24 <Fuuzetsu> It's for your own good.
17:55:45 <jle`> enthropy: where would the first and second arguments go? left and right?
17:55:51 <scott_> Hey, you can even use operators infix with parentheses
17:55:56 <scott_> > flip flip 5 (+) 10
17:55:57 <lambdabot>  15
17:56:02 <dmwit> jle`: Same place they would go for flip without any decorations.
17:56:03 <jle`> scott_: haha
17:56:14 <Fuuzetsu> > flip flip 5 (-) 10
17:56:15 <lambdabot>  5
17:56:20 <Fuuzetsu> not quite
17:56:20 <jle`> dmwit: yeah, so there's no point
17:56:23 <scott_> Heh
17:56:28 <dmwit> Says you!
17:56:30 <enthropy> jle`: (`f`) should be like (f) except that (`f`) takes two arguments there
17:56:48 <shachaf> (`f`) should be the same as (f)
17:56:51 <enthropy> unless you have -XPostfixOperators ... in which case it's forced to take only one extra argument
17:56:52 <shachaf> > let (+) = 5 in (+)
17:56:54 <lambdabot>  5
17:57:03 <shachaf> That's perfectly allowed, no PostfixOperators needed.
17:57:07 <shachaf> It is not a section.
17:57:20 <dmwit> jle`: What if I have a bunch of definitions that use `flip` with differing sections, and for uniformity, I want the last one to also look like a section?
17:57:25 <enthropy> (`f`) === f `asTypeOf` (undefined :: a -> b -> c)
17:57:27 <dmwit> jle`: Then there would be a point, I think.
17:57:49 <shachaf> enthropy: No, (`f`) should behave like (+). No type annotation necessary.
17:57:59 <dmwit> jle`: I think with flip this argument is a bit out there, but it doesn't seem all that far out there if you admit that flip is not the only function the language has. ;-)
17:58:00 <shachaf> By annotation I mean you know what I mean.
17:58:10 <enthropy> shachaf: I'm trying to say that it restrict the type
17:58:13 <enthropy> *should
17:58:25 <shachaf> But (+) doesn't. And `flip` is just like +
17:58:27 <enthropy> but you can disagree -- it's not getting implemented
17:58:51 <dmwit> enthropy: Why should it restrict the type?
17:59:01 <enthropy> because that's slightly more useful
17:59:11 <scott_> :t (2 `negate`)
17:59:12 <lambdabot> Num a => a
17:59:21 <scott_> Wait, what? That's not what GHCi said,
17:59:25 <scott_> (2 `negate`) :: Num (t -> t1) => t -> t1
17:59:29 <shachaf> scott_: See the conversation above.
17:59:40 <dmwit> scott_: :set -XPostfixOperators, probably
17:59:45 <scott_> Ah
17:59:48 <scott_> I'll read up on that
17:59:54 <enthropy> > let (!) x = product [1 .. x] in (5 !)
17:59:57 <lambdabot>  120
18:01:08 <dmwit> enthropy: Okay, so I think I mostly prefer uniformity over DWIM. So
18:01:14 <dmwit> ...so I'm not sure I agree with that argument.
18:01:18 <dmwit> But at least I understand it now.
18:01:51 <shachaf> I prefer DMWIT over DWIM
18:02:07 <dmwit> <3
18:26:19 <jle`> is there any way i can do ¬p instead of ¬.p, p :: a -> Bool ?
18:26:42 <scott_> Perhaps notP f = not . f
18:27:13 <jle`> like i want to filter on ¬p, filter (¬p) xs
18:27:19 <jle`> but i can't do that :|
18:27:24 <trolling> so what actually is a zygohistomorphic prepromorphism?
18:28:28 <jle`> scott_: ah so define ¬ f = not . f?
18:28:34 <scott_> Sure
18:28:38 <jle`> but then i can't use ¬ on both predicates and bools
18:28:48 <jle`> oh well.
18:29:10 <naiveheuristic> Is it okay if I abandon haskell now that my cs course is over?
18:29:29 <trolling> jle`: you might be able to hack around it with typeclasses
18:29:35 <trolling> but I wouldn't recommend it
18:29:44 <lykos_> Does anyone here have experience with the threepenny-gui library? I'm trying to create a sink from the hover event, but the event is of type Event (), so I'm not sure how to parse it so that the sink only activates after the event.
18:29:55 <jle`> trolling: huh that's interesting. thanks
18:31:22 <trolling> something along the lines of class Negatable n where { generalNot :: n -> n }; instance Negatable Bool where { generalNot = not }; instance (Negatable b) => Negatable (a -> b) where { generalNot f = generalNot . f } perhaps
18:31:52 <jle`> yeah that makes sense.
18:32:37 <ij> What does the T suffix mean? ListT, StateT
18:32:43 <lingxiao> Hey is anyone familiar with this document by mark jones: http://web.cecs.pdx.edu/~mpj/thih/TypingHaskellInHaskell.html
18:32:51 <lingxiao> and could answer a couple questions? :D
18:33:01 <jle`> ij: it's a monad transformer
18:33:40 <shachaf> Just ask your questions.
18:33:54 <shachaf> Don't put people on the spot.
18:34:00 <shachaf> ij: Transformer (as in monad transformer)
18:34:56 <oio> can i make a windows binary on mac os x ?
18:35:13 <lingxiao> Ok it's about Section 8. Type Schemes
18:35:56 <lingxiao> Type scheme is represented by `data Scheme = Forall [Kind] (Qual Type)`, which the author states "There is no direct equivalent of Forall in the syntax of Haskell. Instead, implicit quantifiers are inserted as necessary to bind free type variables."
18:36:02 <lykos_> Does anyone here have experience with the threepenny-gui library?
18:36:37 <lingxiao> now this doc is written in 2000 so I imagine things have changed a bit, could someone point to me whether the comment is still true?
18:36:45 <shachaf> It is still true in standard Haskell.
18:36:47 <fryguybob> lykos_: I'm sure someone does.
18:37:06 <shachaf> Syntax for it is provided by a GHC extension, but this document is just talking about Report Haskell.
18:37:37 <zRecursive> :src fix
18:37:47 <zRecursive> @src fix
18:37:47 <lambdabot> fix f = let x = f x in x
18:37:48 <lingxiao> shachaf: I assume you're talking to me? if not ignore this question: what do you mean by talking about report Haskell
18:38:06 <shachaf> Haskell as described by the Haskell report.
18:38:11 <shachaf> @google report haskell
18:38:12 <lambdabot> http://www.haskell.org/onlinereport/
18:38:12 <lambdabot> Title: The Haskell 98 Language Report
18:38:17 <lingxiao> I guess I was asking if the implementation of data scheme has been updated since this document and where I can go to find the current implementation
18:38:27 <shachaf> The latest version is Haskell 2010. It still has no explicit forall.
18:38:27 <oio> can i cross compile from mac os x to windows
18:38:29 <oio> ?
18:38:44 <shachaf> What you want is the specification, not the implementation. It's described in the Haskell Report.
18:38:47 <shachaf> @google haskell 2010
18:38:47 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_2010
18:38:48 <lambdabot> Title: Haskell 2010 - HaskellWiki
18:39:32 <shachaf> Oh, you mean a new version of THIH?
18:39:33 <shachaf> I doubt it.
18:40:08 <shachaf> Allowing explicit foralls is all sorts of trouble.
18:40:30 <shachaf> But look up "rank-2 types" or "rank-n types" for more information.
18:41:02 <lingxiao> shachaf: so I shouldn't use foralls in my function signatues? even if I restrain it soem with predicates?
18:41:14 <shachaf> You can use them if you want.
18:41:25 <lingxiao> like `forall a. (a ∈ Monoid) => ..`
18:41:35 <shachaf> Most Haskell code is written for GHC or other Haskell implementations with extensions.
18:42:13 <shachaf> Oh, come on, ∈? :-(
18:42:28 <lingxiao> lol sorry.. `Monoid a`*
18:42:35 <shachaf> Anyway, you can do whatever you want. I can't answer "should" questions.
18:43:29 <lingxiao> I guess what I'm really asking is how polymporhic types are actually described
18:43:58 <lingxiao> since by the authors own admission: "Unfortunately, we have not yet found a satisfactory way to enforce this, and, after considering several alternatives, we have settled for the representation shown here because it allows for simple implementations of equality and substitution. "
18:44:13 <lingxiao> he seems to think it's bit of a hack? or am I reading this paragraph wrong
18:44:22 <lingxiao> and you said "What you want is the specification, not the implementation. It's described in the Haskell Report."
18:44:38 <lingxiao> so I should look for it in the Haskell Report still? based on the refined version of my question
18:45:08 <Clint> what's the type you're trying to express?
18:46:23 <lingxiao> Type Schems. which in THIH looks like: `data Scheme = Forall [Kind] (Qual Type)`
18:47:43 <lingxiao> which relies on the use of a `Type` built with this value constructor: `TGen Int`
18:48:25 <lingxiao> where the `Int` denotes the location of `Kind` inside the list of `Kind` in `Scheme`, if you follow me
18:51:04 <l0cust> Hey, y'all. Is there a way to put a type constraint in a type synonym?
18:51:33 <twiceler> I0cust: yep. I think it's Rank2Types
18:52:37 <pavonia> Is there a general way to get rid of "lift"s in a monad stack? Some monadic functions like "ask" don't need to be lifted, but others like IO actions or my custom monad functions do
18:52:53 <danharaj> :t ask
18:52:54 <lambdabot> MonadReader r m => m r
18:53:54 <pavonia> Huh? This is different from what I get: ask :: (Monad m) => ReaderT r m r
18:54:12 <jmcarthur> pavonia: Control.Monad.Reader from mtl has that
18:54:23 <jmcarthur> pavonia: you might be just using Control.Monad.Trans.Reader
18:54:27 <lingxiao> pavonia: for any datatype that's a monad, you can implement an instance of monadReader
18:54:58 <lingxiao> where you can define ask as `lift ask`, so it is lifted
18:55:01 <lingxiao> still
18:55:32 <pavonia> So if I want my functions to be automatically lifted I need a smiliar class for my monad?
18:55:35 <jmcarthur> pavonia: also, if you use MonadIO, you only need to use liftIO (once) instead if lift (N times, depending on size of monad stack)
18:55:53 <lingxiao> yes, this is an example of what you need to do:
18:55:57 <lingxiao> https://gist.github.com/anonymous/4711c52d12cfdb268575
18:56:28 <lingxiao> pavonia: taken from this website: http://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-Reader.html
18:56:42 <lingxiao> click on "source" on the top right corner, and it'll give you the source file for Control.Monad.Reader
18:56:55 <byorgey> l0cust: yes, you need the ConstraintKinds extension, not Rank2Types
18:56:56 <lingxiao> you can find the code I pasted about half way down
18:57:28 <twiceler> byorgey: I just tried Rank2Types; that works for me
18:57:34 <byorgey> really? OK
18:57:37 <pavonia> lingxiao: okay, thanks
18:57:41 <lingxiao> yup np
18:58:33 <twiceler> http://lpaste.net/97182
19:00:44 <lingxiao> pavonia: I meant to say for any datatype that's a monadTransformer, sorry
19:01:40 <pavonia> yeah, I think I see the general pattern
19:05:24 <lingxiao> jmcarthur: is that because IO is always on the "bottom"?
19:05:55 <lingxiao> but how does it determine how many times `lift` should be applied for arb sized stack up to some size?
19:06:30 <jmcarthur> each monad transformer has to have an instance of MonadIO. each just calls the liftIO below it. IO's instance is just the identity
19:06:50 <lingxiao> ah, very elegant
19:07:56 <gamegoblin> I have a list and a list of indices. What is the best way to extract the elements specified by the list of indices from the first list?
19:08:09 <gamegoblin> I can think of a few ways to do it. Was wondering the best.
19:08:53 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
19:08:53 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:31 2013]
19:08:53 --- names: list (clog xl1 sagittarian gamegoblin Guest20149 Michael__ amindfv masteraka kfish trecer dmj` startling zintinio sritchie refold tabemann yogert l0cust hamid twiceler Neqoxec erochester ystael cognominal jxv mno2 steven807 path[l] fijimunk1i lingxiao egork8n__ ujihisa sellout- mreh zRecursive apaku amatsu strobegen tomboy64 AlainODea flubba codesoup stolaruk osa1 watermind csakatoku jamesaanderson rose__ Francisco rodrigovidal federkas_ Ralith vyorkin cmsmcq)
19:08:53 --- names: list (talzeus mreca hashcat Jesin j2j julian_ kylcarte amosr ij litherum gfontenot synacktic Aetherspawn jmcarthur_mobile nisstyre ashnur maxs_ jcvfen frxx gehmehgeh oleo Watabou predator217 nullFxn yogurt_truck xinming_ alang netj Baughn mm_freak Sgeo Myk267 Feuerbach_ anunakki darthdeus q66 coreyn1 malaclyps coeus mceier maxs__ Taneb johntromp etorreborre `^_^v synonymous cyphase dgpratt Pullphinger augur Kron Peaker AfC nstdloop mwc sababa MrGwen horlicks)
19:08:53 --- names: list (ocharles reizuki__ [mth] zacts yrdz Guest26363 Euroskeptic c_wraith tawm L8D wagle marsam mikecaruso Philonous_ araujo Artpicre alderz_ uniquenick Dashkal u__ AntiSpamMeta Swizec Asminthe antheziu1 triliyn ozgura [[zz]] ant0wn4 koninkje_away tiffany pjstadig sepp2k nominolo xye bananagram thalassarche jizanthapus rekahsoft pavonia thunderrd lopex tomh-__ liesen__ xrl_ alvelcom xkb Reiser cschneid mimi_vx amontez averell duairc vobi abesto Xorlev ericmj)
19:08:53 --- names: list (mimico__ kloeri machisuji cynick nbouscal seanparsons Edoxile Jaxan luigy thirsteh zebr myme Blkt mechairoi tril Boreeas upgrayeddd runde peddie greymalkin hdevalence raid davidbe_ drmegahertz tero- drdo lambdabot ivan\ vondraco Adeon _d3f maksbotan bkolera tridactyla jorj SegFaultAX opto alexsdutton mrb_bk companion_cube pfoetche1 cjay byorgey Walther lostman bb010g M-ou-se ejls junsuijin MrWoohoo qz integral Iceland_jack tristan_1 fmapE DonVitoC- xrq ormaaj)
19:08:53 --- names: list (aloiscochard|off bxc_ ido_ vivekrai__ ircbrowse vendethiel flux ixian8 bobry Sibi_ posco_ bishboria dsirenko si14_ Nickeeh Shou loans jefimenko swistak35 troydm ninedotnine ellipsis_ enthropy satc Kobata mawuli FreeFull jml jrmithdobbs trism d-snp moto9 uiop anders^^ joe9 Luke eribeiro xymox liyang ForNeVeR _justjust n00dle merijn yano pmade Raynos nooodl latro`a arrdem Sculptor voxpopuli MrFahrenheit Jonno_FTW timemage gallais CADD ccc razieliyo ehd)
19:08:53 --- names: list (reiddraper Martingale thinker341 guampa klugez tarmil wolfnn noam _Vi maoe pfurla yacks jungnam hamilyon Matrixiumn whaletechno jrslepak HugoDaniel hamishmack zasimov ADexter ZsoL matt_1979 tych0- tdammers m3ga sShintah kludge` bens Null-A Pengoo thetallguy1 Paprikachu td123 zz_zz_highPriest shanse DarkFox schlumpi old fall_ thoradam_ divyansr eevar supki_ kaw_ saiam_ NickHu_ Yarou_ aninhume1 zomg sw1nn kcliu dreixel_ popx Tene _5kg JesuZ Khisanth djahandarie)
19:08:53 --- names: list (unlink MK_FG thorkilnaur kbotnen emaphis rfw kwos effy flori RichyB kakos brandonw preflex mauke ivan` jcurbo otto_s_ pnielsen yusukesuzuki joelteon raek peterbb nik_89 dibblego iron_houzi OlegYch Morley93 speckle Mortomes mjo marcopolo2 neptunepink dnewby TheFuzzball Sorella Mortomes__ mak` Excureo ValicekB isomorphic vervic cdk_ joneshf-work fikusz jdoliner_ jle` jchee eyck thetallguy Tesseraction cdk carter nicoo webframp {[^-^]} s2r2 sclv_ StoneCypher)
19:08:53 --- names: list (Kruppe donri sross07 smarter wchun m1dnight Internet13 ciaranm Guest78473 Adios bgamari smith_ cizra DT`` ghorn Tarential geekosaur Thulsadum tg tpsinnem koz atomicturtle cbw kinslayer pikhq lacrosse DistantStar thebnq shesek ryanakca wrunt hackagebot twn MitchW nklein tahu akiress jrw ttuegel bgresham jlamothe ninzine dv- randomclown kofno sfvisser GGMethos dmwit doomlord_ saep aristid sclv shachaf tsurutom Kneiva Nahra Meistarin Kuba theorbtwo MetaCosm)
19:08:53 --- names: list (felipe_ ninegrid Natch Zariel mastensg gemelen m09 dhrosa dsantiago sipa gdsx stiell trystero cmsd2 katis dumbhat isenmann majoh mero cryzed phryk Nafai ibid BlankVerse_ Soft earldouglas kqr Rylee_ seliopou Apage43 _br_ CindyLinz brisbin pdxleif Ornedan fran vsayer jdoliner- AleXoundOS kekimmo bz wilfredh adnap adbge Eridius Hardolaf Sieben__ pyrtsa Deewiant jliikka sordina1 Gracenotes_ emma ginmania1 BlastHardcheese lahwran blast_hardcheese orospakr chrisirc)
19:08:53 --- names: list (_janne Fnar betawaffle cross finnrobi spaceships b2coutts bstrie mgaare_ iulian mux pharaun ccasin stchang RevJohnnyHealey rdevilla AshyIsMe jayne lightquake quicksilver theDon lpsmith jj2baile go|dfish GaveUp dpwright AtnNn Valodim zerokarmaleft jnylen ahf jamesjb xaimus hpd lokydor og01 kshannon Hodapp davorak relrod confound dqd rhodesd Hafydd leroux aoh annulus simon Kinnison _mkrull kloplop321 mlh Dodek idoru flazz pyr jyyou aegray_ voyd bunzen g0dmoney-)
19:08:53 --- names: list (apples marmaton jazu_ mrd jzl_ dmilith zaphar_ps mist11 srhb jackhill gbarboza dsp_ mandu jb55_ vhz michaelpj yriw eyem maaku ggherdov nitin2 mau_ zalzane Psycho_pr boyscared franckverrot hpc pyykkis strax zeroskillor CosmicRay natte Cale zpconn Polarina Ycros milli ktosiek staykov DustyDingo dested jack_rabbit jonke mokus drbean pseudolio johnw b_jonas MasseR sm MooGoo tehroflmaoer AshleyWaffle apo_ bholst mr- stevely_ caligula nkpart bd___ larsrh capisce so)
19:08:53 --- names: list (yggr aford jlouis_ sam_d davean Jello_Raptor DarkLinkXXXX aji nullcone_ adnauseam meretrix dan64 acfoltzer dyreshark gereedy Spaceghost neurocyte dawik_ bitemyapp alessand1o munro_ Gothmog_ pqmodn wto Eagle_Erwin SquidTamer vishnix noplamodo_ joshbohde b0c1 bartavelle bitraten1 saurik scott_ trolling vpm Phill123 stepkut hive-mind FireFly mononofu cdidd FliPPeh xnyhps zeiris_ Tehnix lulf_ osfameron asm89 def-lkb wormphlegm jlewis brainproxy tomaw vikraman)
19:08:53 --- names: list (donotbeliveme epsylon dp_wiz_ jfhall_ mike2 barrucadu andrewsw_ jaspervdj hattmammerly banjiewen froztbyte Corey kaol verrens ClaudiusMaximus tromp dlundy spacebug_ ethercro1 stbuehler `0660 akaposi Reisen d3lxa ahihi ParahSailin jonasw moop Nik05 jcande nsno_ ByronJohnson wollw_ Bwild_ notroot_ Ulrar mlen drewr Brando753 bsmt rasmusto_ franksh Arnar_ skypers malorie_ exicer_ koala_man bcoppens mmaruseacph2 chipdude Derander_ sdx32 Kabaka mrshoe zz_robj_)
19:08:53 --- names: list (nikola dario joeyh ipuustin_ demolithion prinsen_ Javafant ozataman_ qwandor fxrh r``t talzeus__ dcoutts sunnavy edwtjo h_chiro_ [swift] mietek_ Lemmih_ krakrjak_ benmachine fser sddhrthr1 Licenser mendez alios_ kerrick Athas zso WraithM robert_ lattenwald lasts__ juuhaa biscarch newsham mm_bureau tensorpudding phienone flebron japesinator jedai42 hc fflam mirsal Twey sondove otterdam Rembane daoo OrangeDuck japaric killy9999 everamzah mshroyer ikarus jbauman)
19:08:53 --- names: list (linduxed kryft helgikrs hiredman pcapriotti bearclaw_ vvein_ kini heath Bigcheese joe_k gniourf zsolti TDJACR lab-notes geoffh albel727 obcode Belgarion0 profmakx slobo DigitalKiwi gargawel orzo fryguybob pi8027 Pad^ tavelram_ rs0 brixen_ radioxid adlan tobyp shutdown_-h_now bezik thoughtpolice tessier shepheb_ wting Fubar^ anhall_ joshsz_ dropdrive aseidl joogi wunki burp udevd dixie Jaak magicman acharles boegel|work xplat benj_ jmcarthur deavid eagleflo Ke)
19:08:53 --- names: list (k4nar ndngvr `bps SLi descender zarul jamil inr epta vvv squimmy Dtgr bigos vmeson hellome BMeph ibab jaimef Cradam pveglia croys idnar gseitz lusory Ptival helmut copton nurupo SHODAN mavam solarus Nimatek Nshag quaestor mikeplus64 jxport yam _1126 Razz liori bgyss kseo jodaro charlesofarrell_ petanqk chirpsalot copumpkin niko dustinswan shennyg dgvncsz0f ricky_clarkson mangaba_leitosa levi Boney Gunni ziman JPohlmann Elision crs_ fionnan earthy Heffalump)
19:08:53 --- names: list (mrmonday etrepum mikeI Sornaensis XMunkki Martty_ sgs evax identity opqdonut ion dtkatch FreakyPenguin pp^_ int-e maurer stass knyon cpa necronian cods stelleg Watcher7 paulschellin tippenein Chousuke shiona Vorpal dougdougdoug numberten dflemstr Sagi tomejaguar taruti tomprince marienz absence Fuuzetsu yeltzooo9 Laney Tordek statusfailed kenkku_ Liskni_si necroyeti lispy Annamaria jang1 pierreghz raphie bergmark xahry Janiczek bernalex c_14 mortberg jrib stvc)
19:08:53 --- names: list (PatrickRobotham Cryovat macron frontendloader Draggor kadoban lasanbr stephe zero7_ jzelinskie yeshuah kxra gpampara_off spion unsymbol notdan Plasmastar hvr simpson heikkih lieven_ Amadiro sunfun nwf knyppeldynan majackson valdyn otulp honkfestival __main__ joachifm zoktar peltchu xintron scolobb ReinH inarru_ TheBrayn bind1 Clint Excedrin topi` scshunt edunham robbert` Yawgmoth SirChurchill mollerst1and mattp__ zw01 \q ConstantineXVI s4msung imalsogreg)
19:08:53 --- names: list (jorendorff_away nemesit|znc justinjaffray keelo kittenso1p mlinksva zenzike paz lpaste jroesch ortmage_ bicgena ehamberg binq morolin davorb gridaphobe dju leocassarani Lindrian Raynes canta eL_Bart0- Starfire pietore endojelly PHO_ ofan bbee m6n Entroacceptor FUZxxl dilinger nablack farn Cerise satshabad dschoepe fergusnoble arnsholt leifw dziga IbnFirnas_ akraut puzza007 kosmikus ssbr tinyghost ft dogmaT_ a11235 KitB kragniz Igloo Guest97959 pfeyz osnr)
19:08:53 --- names: list (ashooby aszlig mrowe ocfx Enigmagic ent ljhms Maxdamantus dabradley Tribal Svedrin mythmon solirc fabjan jix helgar mena sajith tpatja simonnn rmunroe hongminhee deggis luite_ vnz fayden haasn petantik Will| mixi tamiko mantovani gsnedders peder @ChanServ sohum edk zeroXten jamwt1 Vq bogner KaneTW yac erikl_ henk Saizan zol k00mi adimit mp uu1101 gspr cic ernst _flow_ colah IanKelling othiym23 geal sa1 jonsterling Phlogistique alexsdut2on mviljamaa lzm BrianHV)
19:08:53 --- names: list (castor2)
19:08:59 <BMeph> gamegoblin: I'd say 'map (list!!) indices', but YMMV.
19:09:16 <gamegoblin> That's what I currently have written
19:09:19 <gamegoblin> Seems decent
19:09:21 <startling> gamegoblin, best way would be to read it into an array and then index it
19:09:46 <startling> the array way is O(n), the (!!) way is O(n^2) I think
19:09:46 <AshyIsMe> > map ([1..3] !!) [10..1]
19:09:48 <lambdabot>  []
19:09:56 <BMeph> startling: I see your pedantry, and Salute you, Sir. ;þ
19:09:56 <AshyIsMe> hmm
19:09:57 <startling> well, not quite.
19:10:06 <scott_> AshyIsMe: [10..1] == []
19:10:12 <scott_> Try [10,9..1]
19:10:15 <startling> the (!!) way is O(n * m) or something
19:10:20 <AshyIsMe> > map ([1..3] !!) [10,9..1]
19:10:22 <lambdabot>  [*Exception: Prelude.(!!): index too large
19:10:32 <AshyIsMe> hmm
19:10:34 <startling> [10,9..1]
19:10:37 <startling> > [10,9..1]
19:10:38 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
19:10:44 <jle`> you are doing [1,2,3] !! 10
19:10:47 <startling> AshyIsMe: oh, you did it backwards
19:11:09 <jle`> remember that in a section, thing goes in the "missing" spot, to the right of the !!
19:11:12 <gamegoblin> startling: I have never used arrays in haskell, which type should I use?
19:11:28 <AshyIsMe> ah yeap that makes sense
19:11:36 <startling> gamegoblin: you probably shouldn't worry about it.
19:11:39 <AshyIsMe> > map (!! [1..3]) [10,9..1]
19:11:40 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
19:11:40 <lambdabot>              with actual type `[t0]'
19:11:58 <startling> gamegoblin, write what you're doing in a clear way and then optimize the bottlenecks
19:12:05 <gamegoblin> Not too performance dependent, so I think the n*m solution will do
19:12:05 <jle`> AshyIsMe: you are doing 10 !! [1,2,3]
19:12:08 <startling> but you asked for "the best" way. :)
19:12:26 <AshyIsMe> oh right, the lists around the wrong way
19:13:03 <jle`> your section was right the first time ^^
19:13:06 <AshyIsMe> > map ([10,9..1] !!) [1..3]
19:13:07 <lambdabot>  [9,8,7]
19:13:10 <AshyIsMe> woo
19:13:38 <AshyIsMe> > map ('foobar' !!) [1..3]
19:13:39 <lambdabot>  Syntax error on 'foobar'
19:13:39 <lambdabot>  Perhaps you intended to use -XTemplateHaskell
19:13:48 <jle`> "
19:13:50 <AshyIsMe> i'll take this into a local ghci
19:14:09 <jle`> '' is a character literal
19:17:20 <levi> Hrm, cabal is telling me it can't read the output of ghc-pkg dump. :(
19:20:55 <pavonia> I'm a bit confused, where do the Reader and ReaderT types here come from? http://hackage.haskell.org/package/mtl-2.1.2/docs/Control-Monad-Reader.html#t:ReaderT
19:24:45 <lingxiao> try the source on this one: http://www.haskell.org/ghc/docs/6.10.2/html/libraries/mtl/Control-Monad-Reader.html
19:25:14 <geekosaur> http://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-Trans-Reader.html
19:25:22 <pavonia> but that's a different version
19:25:25 <rose__> I have an object of type Action IO [String]. How can I print the strings?
19:25:40 <geekosaur> oh, right, I jumped to the wrong place
19:25:41 <nisstyre> rose__: do you have a function that can access the [String] parameter?
19:25:53 <nisstyre> i.e. Action -> [String]
19:25:59 <rose__> checking...
19:26:08 <geekosaur> um, wait, it's not.
19:26:10 <nisstyre> rose__: also is that Action (IO [String]) ?
19:26:13 <jle`> Action m a -> a
19:26:16 <pavonia> geekosaur: my problem is, I can't see from the source code how these types are (re-)exported
19:26:18 <nisstyre> or Action IO [String]
19:26:19 <rose__> yes
19:26:20 <geekosaur> mtl-2.1.2 re-exports transformers-0.3.0.0
19:26:26 <nisstyre> ok
19:26:29 <geekosaur> it's a wrapper
19:26:54 <byorgey> rose__: what is Action?
19:27:16 <rose__> data Action m a Source
19:27:17 <rose__> A monad on top of m (which must be a MonadIO)
19:27:24 <rose__> *take out the "Source"
19:27:29 <pavonia> geekosaur: it only exports MonadReader and asks
19:27:35 <rose__> here's the full context: http://stackoverflow.com/questions/20669578/monad-use-in-mongodb-access?noredirect=1#comment30951186_20669578
19:27:47 <pavonia> http://hackage.haskell.org/package/mtl-2.1.2/docs/src/Control-Monad-Reader-Class.html#MonadReader
19:28:17 <pavonia> oh wait, that's a completely different module >.<
19:28:22 <joelteon> How do you explicitly export associated types?
19:28:46 <byorgey> rose__: in what package is Action defined?
19:29:03 <lingxiao> shachaf: followed up on your link about haskell report, I see what you mean by spec vs impl. thanks!
19:29:39 <rose__> http://hackage.haskell.org/package/mongoDB-1.4.1.1/docs/Database-MongoDB-Query.html#t:Action
19:29:41 <rose__> byorgey:
19:29:43 <duairc> Is it possible to run Q [Dec] splices in GHCi, and if so, how?
19:29:59 <geekosaur> ReaderT comes from Control.Monad.Reader.Class
19:30:10 <byorgey> rose__: it looks like you are supposed to use the 'access' function to turn an  Action m a  into an  m (Either Failure a)
19:30:12 <geekosaur> hm, wait
19:30:13 <triliyn> What C libraries does the "process" package depend on?
19:30:24 <geekosaur> Control.Monad.Trans.Reader
19:30:26 <joelteon> actually, what I need to know is whether haddock can section class methods
19:30:38 <geekosaur> which is not in mtl directly
19:31:06 <joelteon> and it doesn't appear that it can
19:31:09 <byorgey> rose__: the point is that a value of type   Action IO [String]  represents a description of a computation which can get some strings from a database
19:31:09 <geekosaur> it's from transformers, as I mentioned earlier and you saw the different version number but not that it's a different package entirely
19:31:20 <byorgey> rose__: so you have to 'run' it with 'access'
19:31:47 <pavonia> It seems I have a completely other problem here, i.e. having two different versions or ReaderT, one from transformers and one from an old mtl version :D
19:32:11 <pavonia> which doesn't import transformers at all
19:32:56 <geekosaur> mtl1
19:34:00 <pavonia> yep, which my gtk package depends on :(
19:34:45 <geekosaur> you have a very old gtk then, I think
19:34:47 <jle`> rose__: if you're inside the Action monad
19:34:59 <jle`> you might want to bind it to xs <- (your action io [string])
19:35:26 <Sgeo> plugins needs a C compiler?
19:35:32 <jle`> oh i didn't read SO question
19:37:42 <lingxiao> uh reading the haskell report, on this page: http://www.haskell.org/onlinereport/decls.html
19:38:12 <rose__> byorgey: Thanks! You're right
19:47:01 * hackagebot fpco-api 1.0.2 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.0.2 (ChrisDone)
19:49:18 <joeyh> triliyn: no C libraries, although it does include rather a lot of C code used via FFI
19:50:32 <triliyn> joeyh: well I mean, is there anything I need to build manually before I cabal install it?
19:50:43 <triliyn> Because cabal install is failing with "ExitFailure 1"
19:51:03 <joeyh> look for the error message earlier in the build output
19:51:30 <triliyn> hmmm
19:51:40 <triliyn> "undefined reference to `isascii'"
19:58:33 <int80_h> anyone have a url to an example of a tcp server using Data.Conduit.Network?
19:58:44 <int80_h> Data.Conduit.Network 1.0, I mean.
20:02:19 <AVM> test
20:02:23 <int80_h> hi
20:02:25 <AVM> hi
20:02:51 <int80_h> know anything about conduits?
20:03:19 <simpson> int80_h: Yes, but it's not pretty. What are you building?
20:03:41 <AVM> im pretty sure there was something about a conduit in mass effect
20:04:12 <int80_h> a tcp server
20:04:31 <johnw> int80_h: you're still going to have to listen and accept normally
20:04:41 <johnw> you use conduits to stream the data to/from the socket after you've accepted
20:04:46 <int80_h> all the examples for Data.COnduit.Network are old
20:05:12 <int80_h> I thought runTCPServer sets up a connection
20:05:59 <johnw> print =<< (bindPort 8080 HostAny >>= \s -> sourceSocket s $$ sinkLbs)
20:06:01 <int80_h> there are old examples using just runTCPServer, but the types have changed
20:06:08 <johnw> should listen on port 8080, and print whatever is sent there using, say, netcat
20:07:03 * hackagebot fpco-api 1.0.3 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.0.3 (ChrisDone)
20:07:30 <Clint> int80_h: you could look at http-reverse-proxy
20:08:23 <int80_h> Cline: Trying to use Data.Conduit.Network
20:08:30 <int80_h> Clint: Trying to use Data.Conduit.Network
20:08:45 <Clint> int80_h: yes, it uses that
20:08:48 <int80_h> ah
20:10:16 <int80_h> dependencies are base,bytestring, and parsec
20:10:25 <int80_h> doesn't use network-conduit
20:12:29 <Clint> int80_h: what?
20:12:58 <int80_h> http-reverse-proxy has the dependencies I mentioned above, doesn't use network-conduit
20:13:18 <int80_h> Data.Conduit.Network
20:13:36 <Clint> int80_h: http://hackage.haskell.org/package/http-reverse-proxy
20:15:22 <int80_h> weird I was totally looking at the wrong page. thanks :)
20:17:18 <int80_h> Clint: this was exactly what I needed. Thanks :)
20:18:27 <int80_h> bah, it uses network-conduit 0.6, not 1.0
20:18:31 <AVM> anyone here used netwire?
20:18:45 <AVM> or even successfully ran through the tutorial...
20:19:07 <int80_h> nope, I've just used reactive banana
20:19:42 <AVM> when i do
20:19:49 <AVM> for 3 . pure "yes"
20:19:53 <AVM> it type checks
20:19:58 <AVM> but if i do
20:20:04 <AVM> for 3 . "yes"
20:20:09 <AVM> as in the examples, it doesnt work
20:25:52 <jle`> does netwire use overloaded strings?
20:26:59 <AVM> its supposed to
20:27:06 <AVM> i think
20:27:11 <AVM> according to the tute
20:28:58 <jle`> try enabling OverloadedStrings
20:31:04 <AVM> i think that was it
20:31:12 <AVM> im surprised  i havent heard of that extension before
20:32:10 <AVM> if you have something like
20:32:19 <AVM> forever $ putStrLn "hello"
20:32:27 <AVM> that prints hello until you hit ^C
20:32:31 <AVM> is there a way
20:32:35 <AVM> to print the output
20:32:38 <AVM> to a file
20:33:03 <AVM> so if it prints 100 hellos before you hit ^C the file will have 100 hellos in it
20:33:26 <apples> hPutStrLn
20:33:44 <Sgeo> checking for value of __GLASGOW_HASKELL__... 706
20:33:51 <Sgeo> Why am I getting this when trying to install plugins?
20:33:56 <Sgeo> From cygwin
20:34:11 <Sgeo> (And does it make sense to attempt to install it from Cygwin, since it seems to want a compiler?)
20:34:38 <quchen> Sgeo: What's a plugin?
20:34:46 <Sgeo> There's a package called plugins
20:35:11 <quchen> Ah.
20:35:52 <quchen> Anyway, some packages rely on a certain GHC version to be installed. The CPP macro __GLASGOW_HASKELL__ is used to identify the compiler version the module is compiled with.
20:40:00 <rose__> Has anyone gotten this error when not intentionally writing concurrent code? "thread blocked indefinitely in an MVar operation"
20:40:26 <rose__> here's the relevant code http://lpaste.net/97192
20:41:16 <rose__> I can provide more source if necessary
20:48:15 <solidus-neon> hey all
20:48:52 <solidus-neon> is there any reason that a haskell based wm like xmonad would get significantly worse graphics performance than kde / gnome
20:49:42 <Clint> edwardk: this is your regularly-scheduled adjunctions harassment
20:50:13 <quchen> I'm pretty sure XMonad just sends signals like "this window goes here" to the X server, which is really cheap to calculate.
20:50:15 <nisstyre> solidus-neon: do you have graphical errors?
20:50:19 * edwardk hits snooze but notes he has the day off tomorrow to work on it =)
20:50:23 <edwardk> i'm actually working on a related project right now even
20:50:31 <edwardk> which is trying to figure out a nicer representable-tries
20:50:51 <nisstyre> yeah the only problems I've had with xmonad are windows not showing up properly
20:50:57 <nisstyre> usually fullscreen ones
20:51:03 <nisstyre> (which I thought they had fixed)
20:51:33 <solidus-neon> nisstyre: no but running darkplaces (origonal quake enhanced) i get 28 fps in xmonad fullscreen and ~111 in kde
20:51:46 <solidus-neon> so i'm curouse if i'm doing something really wrong with xmonad
20:51:49 <nisstyre> solidus-neon: that's weird
20:51:58 <nisstyre> solidus-neon: you're just using the default xmonad.hs ?
20:51:58 <solidus-neon> or if xmonad is just worse at graphically intensive things
20:52:01 <solidus-neon> yeah
20:52:25 <solidus-neon> main = xmonad $ defaultConfig
20:52:42 <nisstyre> solidus-neon: I had a problem with xmonad where a game wouldn't show up, I would get the music and stuff but the window never displayed
20:52:49 <nisstyre> worked fine when I tried it in xfce
20:54:13 <solidus-neon> nisstyre: hmm, this points to xmonad doing something wrong with setting up / presenting opengl contexts
20:55:39 <nisstyre> solidus-neon: yeah, I have no idea how to debug it
20:58:20 <solidus-neon> hmm, going to compare glxinfo between the two, brb
21:00:42 <flebron> Hi. Say I have data T f a = T a (f (T f a)), and type RoseTree = T [], what's the cleanest way to automatically derive a Show instance for either T or RoseTree?
21:02:38 <solidus-neon> huh, glxinfo is exactly the same
21:03:12 <solidus-neon> even tried running it in kde in windowed mode to see if it could be that xmonad isn't making a fullscreen context
21:03:48 <Sgeo> Whee
21:03:54 <Sgeo> 'a' `HCons` 5 `HCons` HNil
21:03:58 <Sgeo> H['a', 5]
21:05:58 <BMeph> flebron: Show f => Show T f a where... -- the remainder is left as an exercise. ;)
21:06:39 <BMeph> flebron: Er, rather - Show (f b) => Show T f a where... -- the remainder is left as an exercise. ;)
21:07:22 <BMeph> No, that's not necessary....
21:07:41 <shachaf> flebron: What type is Cofree, as in a cofree comonad.
21:07:53 <shachaf> So look at that.
21:08:04 <flebron> BMeph: is there a way to derive it automatically, not with me typing it?
21:08:15 <flebron> shachaf: Thanks, I don't know where I got it from, but it's a really cool idea :)
21:11:24 * flebron should not have googled that. "telescoped :: (Functor f, Functor g) => [(Cofree g a -> f (Cofree g a)) -> g (Cofree g a) -> f (g (Cofree g a))] -> (a -> f a) -> Cofree g a -> f (Cofree g a)"
21:14:12 <ion> Coffee
21:15:59 <solidus-neon> caffiene
21:27:40 <blaenk> with channels, if i read from a channel it consumes the data there right? if I duplicate the channel with dupChan, and I read the channel from one of the copies, does it consume the data from the other as well? or will the other be able to consume it as well
21:28:59 <johnw> if you dup, the "duplicate" is empty
21:29:08 <johnw> but anything written to either one from then on becomes available to both
21:29:26 <johnw> also, I don't think consume from one affects the other, but that's easy to test
21:29:26 <blaenk> thanks
21:29:32 <blaenk> yeah will test right now
21:36:16 <blaenk> johnw: yeah it's available to read from both, one doesn't consume the other's :)
21:36:32 <johnw> also, unless you really need a Chan, I recommend a TChan
21:36:39 <blaenk> thanks I'll look into that
21:39:21 <Sgeo> Why does the plugins package need a C compiler, exactly?
21:40:33 <blaenk> maybe it'll say in the cabal file
21:40:46 <blaenk> uses ffi for something
21:45:08 <joelteon> does this look like the typeclass antipattern to you guys? https://github.com/joelteon/bot/blob/master/src/Network/Bots.hs#L30
21:49:07 <rose__> I'm surprised I can't put the True indented on the next line, or not indented... how can I split up this line into two?  where resultsAreValid = True)
21:49:42 <joelteon> the thing that's ringing my alarm bell is the fact that every single method takes bot as the first argument
21:49:54 <joelteon> but several of those methods call others defined in the class
21:50:01 <joelteon> and you really can't do that on a simple record type
21:51:12 <pavonia> rose__: You can but it has to be more intended then "resultsAreValid"
21:51:23 <pavonia> *indented
21:52:11 * hackagebot fpco-api 1.0.4 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.0.4 (ChrisDone)
21:52:14 <rose__> pavonia: You're right. Why?
21:52:37 <joelteon> but at the same time, half of those only carry bot as the first argument to constraint the associated types to all be the same
21:52:44 <pavonia> rose__: because of the offside-rule
21:52:46 <joelteon> if there's a better way to do that, that would probably solve it
21:56:37 <Sgeo> Is the plugins package supposed to work on Windows?
22:04:23 <Sgeo> http://stackoverflow.com/questions/12363216/problems-trying-to-install-the-plugin-package
22:04:30 <Sgeo> Same problem, I ... should be using 7.6
22:05:08 <Sgeo> But __GLASGOW_HASKELL__ gives 706
22:05:50 <Sgeo> Ok, that's apparently correct... but plugins still fails
22:06:52 <rose__> how can I elegantly string together many assertEqual's and where's in a case branch?
22:07:06 <rose__> *in a single case branch
22:21:05 <johnw> rose__: I really don't know what youmean
22:32:35 <blaenk> theres no modifymvar function for tmvar huh
22:32:51 <johnw> nope
22:32:53 <blaenk> so I just atomically read it and write it back?
22:32:56 <johnw> but you don't need one
22:32:59 <johnw> yep
22:33:10 <blaenk> atomically read, then atomically write? or am i somehow supposed to do something like atomically $ (read and write)
22:33:22 <rose__> johnw: In a case branch, I match on Just strings, and then I want to assert some properties about those strings. e.g. there must be two strings, and the first must be "first string"
22:33:22 <blaenk> cause atomically read then atomically write seems like it can cause inconsistencies no?
22:33:40 <johnw> modifyTMVar tv f = do { x <- takeTMVar tv; putTMVar tv (f x) }
22:33:51 <blaenk> then atomically $ modifyTMVar ?
22:33:55 <johnw> yes
22:33:57 <blaenk> thanks johnw
22:34:30 <johnw> noting that it blocks until something is in the TMVar to mutate, of course
22:34:43 <blaenk> got it
22:34:44 <joelteon> takeTMVar tv >>= putTMVar tv . f
22:35:06 <blaenk> that name always makes me lol
22:35:08 <johnw> yeah
22:35:16 <blaenk> think i told you last time too, have a friend named joel that really likes pokemon
22:35:28 <joelteon> i think pokemon are pretty cool
22:35:43 <blaenk> i think you're pretty cool
22:35:49 <joelteon> thanks man
22:35:53 <blaenk> sure brah
22:38:37 <joelteon> so i'm pretty sure this framework is both too general and too specific to be useful
22:38:41 <joelteon> but that won't stop me from putting it on hackage
22:40:14 <pavonia> rose__: Do you know what guards are? You can use them in case branches too
22:41:06 <zRecursive> :t guard
22:41:07 <lambdabot> MonadPlus m => Bool -> m ()
22:41:39 <pavonia> not that
22:41:41 <blaenk> isnt guard func diff from guard syntax? guard b vs |
22:42:01 <zRecursive> > guard (2 > 3)
22:42:03 <lambdabot>  No instance for (Control.Monad.MonadPlus m0)
22:42:03 <lambdabot>    arising from a use of `e_123'
22:42:03 <lambdabot>  The type variable `m0' is ambiguous
22:42:03 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
22:42:03 <lambdabot>  Note: there are several potential instances:
22:42:05 <jle`> yeah in this context i think guards make more sense
22:42:14 <jle`> as in the syntax
22:43:26 <johnw> > guard (2 > 3) :: Maybe Int
22:43:27 <lambdabot>  Couldn't match type `()' with `GHC.Types.Int'
22:43:28 <lambdabot>  Expected type: Data.Maybe.Maybe GHC.Types.Int
22:43:28 <lambdabot>    Actual type: Data.Maybe.Maybe ()
22:43:46 <jle`> heh
22:45:02 <FliPPeh> So what exactly does hGetLine do? Read byte for byte and turn every byte into an individual char?
22:45:16 <FliPPeh> So to read UTF8 I'll have to use Data.Text?
22:47:58 <rose__> johnw: I want to do something like this: Multiple assertEqual's in a single case branch http://lpaste.net/97201
22:48:13 <joelteon> FliPPeh: I don't remember exactly, but I think if you want to guarantee you're getting UTF8 you should use Text
22:48:40 <zRecursive> guard (3 > 0) >> listToMaybe (drop 3 [1..9])
22:48:50 <zRecursive> > guard (3 > 0) >> listToMaybe (drop 3 [1..9])
22:48:51 <lambdabot>  Just 4
22:49:00 <pavonia> FliPPeh: see http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#g:23
22:49:21 <rose__> How can I assert multiple assertEqual's in a single case branch, like this? http://lpaste.net/97201
22:49:27 <zRecursive> > guard (3 > 5) >> listToMaybe (drop 3 [1..9])
22:49:29 <lambdabot>  Nothing
22:50:05 <blaenk> is there some function or abstraction for
22:50:09 <blaenk> let a = b
22:50:12 <blaenk> somefunc a
22:50:13 <blaenk> a
22:50:25 <blaenk> so that a gets applied to the function, but also the result of the expression is a
22:50:59 <pavonia> blaenk: Do you mean in a do-block?
22:51:11 <blaenk> don't think so, in fact, that's within a do-block
22:51:19 <blaenk> for example in this case
22:51:35 <blaenk> I want to check a map to see if some value exists for some key. if it doesn't, then I want to create it
22:51:37 <blaenk> so I do
22:51:39 <joelteon> :t (<~)
22:51:41 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
22:51:45 <joelteon> oh, that's not it
22:52:02 <blaenk> Nothing -> do let ch = newTChan; putTMVar channels $ Map.insert key ch; ch
22:52:16 * hackagebot quickcheck-instances 0.3.5 - Common quickcheck instances  http://hackage.haskell.org/package/quickcheck-instances-0.3.5 (AntoineLatter)
22:52:29 <blaenk> that's part of a case expression that yields the channel, whether it exists already or not
22:53:05 <blaenk> case Map.lookup key chans of
22:53:33 <jle`> rose__: not too familiar with hunit (if this is what you are using), but you can use assertEqual on a tuple
22:53:36 <joelteon> isn't newTChan like IO (TChan a) or something
22:53:57 <jle`> although that doesn't really give as useful of message
22:54:02 <blaenk> so to recap/rephrase, I need to get a channel (let channel =). this channel probably already exists in the map, in which case I just return it. if not though then I need to create it, put it in the map, then yield it as well
22:54:19 <blaenk> yeah that's true I think
22:54:28 <blaenk> I'll fix that
22:55:17 <pavonia> I'm pretty sure there's a Map function for lookup and insert, but not in this monadic context
22:56:19 <blaenk> oh, well the map is inside an mvar, themap <- takeTMVar themvar, so as far as I know themap is a straight up map
22:57:25 <pavonia> but you can't create a new channel while doing a lookup
22:57:32 <blaenk> ohh I see
22:58:04 <Sgeo> Is plugins or hint preferred these days?
22:59:34 <blaenk> hmm yeah I'm stuck now, don't know what to do here haha
23:00:00 <blaenk> says the last statement must be an expression
23:01:39 <Sgeo> In a do block?
23:01:46 <blaenk> yeah
23:02:00 <Sgeo> do { a <- foo } there's no reason to use a at that point if it's the last thing
23:02:05 <Sgeo> So just get rid of the a ,_
23:02:25 <blaenk> got it. the problem is I do need a, so I do a <- foo; a
23:02:51 <Sgeo> Well, if you want to execute a, sure
23:03:09 <Sgeo> > do {a <- Just (Just 5); a}
23:03:11 <lambdabot>  Just 5
23:03:26 <Sgeo> hmm
23:03:31 <Sgeo> > do {a <- Just 5; a}
23:03:31 <blaenk> yeah for some reason that's not working for me, within a do block within a case expression branch
23:03:32 <lambdabot>  No instance for (GHC.Show.Show b0)
23:03:32 <lambdabot>    arising from a use of `M464921629073938979627999.show_M4649216290739389796...
23:03:32 <lambdabot>  The type variable `b0' is ambiguous
23:03:32 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
23:03:32 <lambdabot>  Note: there are several potential instances:
23:03:40 <Sgeo> > do {a <- Just 5; a}
23:03:41 <lambdabot>  No instance for (GHC.Show.Show b0)
23:03:41 <lambdabot>    arising from a use of `M87764070218146088428014.show_M87764070218146088428...
23:03:41 <lambdabot>  The type variable `b0' is ambiguous
23:03:41 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
23:03:42 <lambdabot>  Note: there are several potential instances:
23:03:46 <Sgeo> err
23:03:49 <Sgeo> > do {a <- Just 'a'; a}
23:03:50 <lambdabot>  Couldn't match expected type `Data.Maybe.Maybe b0'
23:03:50 <lambdabot>              with actual type `GHC.Types.Char'
23:04:02 <Sgeo> Oh, right
23:04:17 <blaenk> will paste, I think it's something blatantly obvious
23:04:18 <Sgeo> blaenk: what's the error?
23:04:19 <Sgeo> Ok
23:05:43 <blaenk> so for context. channels is an mvar containing a map (of strings to channels), so I take out the map into chans. then what I need to do is get the channel for a particular key, within the map. if the channel exists (for the given key) then duplicate that channel and thats our result. otherwise, create a new channel, put it into the map, then return the newly created channel
23:05:45 <blaenk> https://gist.github.com/blaenk/f0a59ba5ea9da236f2aa
23:06:31 <blaenk> the error I'm getting is "the last statement in a 'do' block must be an expression"
23:07:44 <nisstyre> blaenk: a let in a do block isn't really an expression
23:07:47 <Sgeo> Why do you need that let chan?
23:07:57 <nisstyre> well, it isn't an expression
23:08:02 <nisstyre> it's a binding
23:08:04 <bz> does ghc export its type system through an api?
23:08:06 <blaenk> well I don't know if I need the let, but I do need the channel that results from that process
23:08:14 <nisstyre> blaenk: then return it
23:08:23 <blaenk> so return ch in both cases right
23:08:51 <blaenk> yeah it says the same thing
23:08:57 <blaenk> the last statement in a do block must be an expression
23:09:04 <pavonia> blaenk: If you want to return the channel from the action, you have to use "return ch"
23:09:04 <Sgeo> You still need to get rid of that let
23:09:05 <blaenk> pointing at the line "let chan = ..."
23:09:19 <blaenk> if you refresh the page, it'll reflect the changes I made (return ch)
23:09:22 <blaenk> and the error persists
23:09:44 <pavonia> Yes, that let = ... is not an expression
23:10:11 <blaenk> would you be kind enough to tell me how it's supposed to be, cause I'm pretty confused
23:10:17 <pavonia> put "return chan" after it (or remore the let part completely)
23:10:26 <Sgeo> Erase these characters:
23:10:28 <Sgeo> let chan =
23:10:38 <blaenk> ohhhhh I see what the problem is now
23:10:47 <blaenk> it's complaining that the containing do block's last statement isnt an expression right
23:10:57 <blaenk> I thought it was complaining about the last statement in the case branches' do blocks
23:11:27 <nisstyre> blaenk: let a = ... is one piece of syntax
23:11:40 <nisstyre> even if the contents of ... contain more do blocks
23:12:19 <blaenk> got it, thanks
23:12:45 <blaenk> I was confused because it was pointing at the let chan, so I was thinking that it was saying that the last statement in the case branches' do blocks werent an expression
23:12:59 <blaenk> thanks :)
23:15:56 <blaenk> if I want to continuously read from a channel, forever, how would I do that: forever $ liftIO $ atomically $ do { a <- readmvar ; do stuff}
23:16:19 <blaenk> I should state I guess that I'm using STM, TMVar
23:16:24 <blaenk> er I mean TChan
23:16:30 <blaenk> so I meant readTChan
23:16:45 <_Vi> Is qtHaskell too old to be used with recent Haskell Platform?
23:18:13 <dagano> is haskell school of expression a decent book?
23:18:46 <Sgeo> blaenk: you can't really do much from inside STM
23:18:59 <Sgeo> Just read and write TVars (or other things based on them)
23:19:03 <lispy> dagano: http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue3/SoE_Review
23:19:20 <lispy> dagano: that's a review of the book. I haven't read the book myself so I can't directly comment.
23:19:24 <blaenk> oh, pfft. I was meaning to write to a websocket
23:19:30 <blaenk> so that can't be done?
23:19:42 <blaenk> it can be done with regular MVars and Chans right?
23:19:51 <blaenk> I only switched to stm cause someone recommended it earlier heh
23:19:55 <dagano> lispy: nice .. thanks
23:21:14 <johnw> you don't have to live inside STM entirely
23:21:33 <johnw> forever $ do { x <- atomically (readTChan chan); ... do something with x ... }
23:21:40 <blaenk> ohh I see
23:21:41 <blaenk> thanks
23:26:56 <blaenk> on this page: http://jaspervdj.be/websockets/example.html at the very bottom, the last code example. it does handle catchDisconnect forever $, that'll handle with catchDisconnect in any of forever's iterations?
23:27:10 <blaenk> so it won't only handle it on the first
23:28:29 <joelteon> sure, because the exception is thrown all the way up the call stack
23:28:50 <blaenk> oh okay thanks
23:28:56 <blaenk> exceptions in haskell have always confused me
23:29:01 <blaenk> will have to research them a bit more later
23:29:25 <blaenk> there's like errors and exceptions and sometimes they use those words interchangeably it seems
23:29:35 <blaenk> then there's left/write from either, etc.
23:29:44 <jle`> blaenk: the chapter on exceptions in the Marlow text was very helpful for me in understanding it
23:29:49 <jle`> it's available for free online
23:29:52 <blaenk> thanks, I'll look up that marlow
23:30:10 <jle`> Parallel & Concurrent Haskell
23:30:12 <blaenk> the parallel and concurrent programming one, nice, seems relevant to what I'm doing
23:30:15 <jle`> programming
23:30:20 <blaenk> thanks for the suggestion
23:31:01 <joelteon> exceptions are a totally different beast from EIther
23:31:03 <joelteon> Either
23:31:16 <joelteon> or any other sum types designed to represent failure
23:31:43 <blaenk> exceptions are built into the language, right, thats the impression I get from "thrown all the way up the call stack"
23:31:46 <zRecursive> :t catch
23:31:47 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
23:32:23 <zRecursive> :t bracket
23:32:24 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
23:35:28 <johnw> blaenk: I think it would be truer to say that exceptions are built into the runtime, not the language itself
23:35:36 <blaenk> alright sure
23:35:52 <johnw> i'm not sure that every Haskell implementations needs to treat them the same; I'm uncertain about that part of the Haskell report, need to read that again
23:36:03 <blaenk> got it
23:37:20 <johnw> i find exceptions pretty easy to deal with in Haskell, it just requires a lot of thought to deal with them correctly
23:39:43 <Saizan> that seems like a contradiction
23:41:39 <johnw> well, let's say then that the machinery is simple, but the implications are not
23:41:40 <jle`> if i use a js compiler like haste, would i be able to compile the more used and useful libraries?  (mtl etc.)
23:42:39 <rose__> I wrote a REPL, but I want the delete key to work when I'm entering input. Right now when I hit the backspace key, more characters are appended to what I wrote, like this: "this is the input^?^?^?^?"
23:43:41 <jle`> rose__: yeah, haskell's built in getLine and other interactive capabilities are quite primitive
23:43:52 <jle`> ^? is the backspace signal that your terminal actaully sends to the program
23:43:57 <jle`> try looking into haskeline
23:44:29 <rose__> jle`: thanks!
23:45:00 <simpson> I have a big complex AST kind of tree type, and I'd like to write a pretty-printer with minimal boilerplate. Is there any easier way than writing out a recursive pretty-printer for each case?
23:45:07 <simpson> (There's got to be a better way!!)
23:49:34 <simpson> I mean, Show's not terribly bad, but I was hoping for something smarter and more flexible.
23:50:47 <Saizan> there are pretty printing combinators
23:51:07 <Saizan> but you'd still need to write your recursion
23:51:40 <nisstyre> simpson: maybe http://hackage.haskell.org/package/generic-deriving-1.6.2
23:51:42 <Saizan> maybe you can use syb for something
23:52:22 <simpson> This is to pretty-print the original syntax of the parsed language that the AST is from, not a debugging representation; the Show instance works fine for that.
23:52:30 <pqmodn> i vaguely remember seeing something that defines pretty printing and grammar from one specification
23:53:10 <pqmodn> however i can't remember enough to even find it with google, so maybe i'm misremembering
23:53:35 <simpson> I've worked with (and on) several such things, but they always suck in one way or another. I'm quite content redefining it.
23:53:46 <pavonia> you could write a parser for it and then run it on all possible inputs until it find one that matches your AST >_>
23:53:46 <pqmodn> this, i think http://hackage.haskell.org/package/invertible-syntax
23:53:48 <nisstyre> simpson: is it really that hard to just write a pretty printer as a set of mutually recursive functions? :|
23:54:23 <Saizan> simpson: what part do you think a library could help you with, then?
23:54:37 <simpson> nisstyre: No; my hands are just getting tired. There are 25 different constructors on this AST. :T
23:54:53 <simpson> Saizan: Dunno; I keep finding myself surprised by parts of tasks that I didn't realize I was repeating.
23:55:12 <nisstyre> simpson: do you do any desugaring?
23:55:23 <nisstyre> or do you not want that to happen at that point?
23:55:34 <simpson> nisstyre: Each desugaring step will happen later.
23:55:42 <simpson> Er, I mean, independently of printing.
23:55:58 <simpson> This is E; it's gotta get desugared to Kernel-E.
23:57:53 <jle`> simpson: do you want to find something where you don't have to specify how to print every constructor?
23:58:19 <simpson> jle`: I just want to type less. My hands hurt.
23:58:36 <augur> beep boop
