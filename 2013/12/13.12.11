00:01:51 * talios reinstalls haskell platform via the OSX .pkg file - holy crap, 1.few gb needed? geebus that's huge.
00:04:43 <earthy> talios: do you have any idea of the size of xcode or visual studio? :)
00:06:15 <talios> yep - sadly.  which makes it even worse - having to have Xcode installed, along side everything
00:06:18 <talios> worst IDE ever
00:07:02 <talios> hah - of course, I also have 2 olders haskell platforms installed as well!  GONE.
00:11:14 <talios> oh yay - cabal can't even install cabal-install :( what little I know of Haskell I like, cabal.... not so much
00:13:14 <mgsloan> talios, sounds like you might be interested in giving the IDE at fpcomplete.com a spin!  You don't need to mess around with cabal that way - a bunch of packages are already installed
00:13:48 <mgsloan> If a package isn't installed and it doesn't depend on an external library, then it can often be installed by adding it to your extra packages list
00:14:00 <mgsloan> (external library = some C lib orso)
00:14:00 <talios> mgsloan - heh, I'm actually trying to compile/patch idris :)    Looks like cabal is looking for an old homebrew installed GHCi/cabal packages, which no longer exist
00:14:21 <talios> tho fpcomplete does look tasty
00:14:32 <mgsloan> :D
00:14:37 <dcoutts_> talios: sounds like you didn't remove your old ghc package database
00:15:48 <talios> I could kiss you :)
00:16:01 * hackagebot language-objc 0.4.2.8 - Analysis and generation of Objective C code  http://hackage.haskell.org/package/language-objc-0.4.2.8 (JohnLato)
00:16:01 * hackagebot posix-paths 0.2.0.2 - POSIX filepath/directory functionality  http://hackage.haskell.org/package/posix-paths-0.2.0.2 (JohnLato)
00:16:04 <talios> that led me to finding ~/.ghc and files under it :)
00:16:09 <talios> now I'm rocking
00:16:11 <mgsloan> Also, try out cabal's sandboxes, that's a very nice way to avoid having to do the whole "delete my ~/.cabal/ and start again" thing
00:16:14 <mgsloan> Nice :D
00:17:11 <kuznero> Hi All!
00:17:35 * talios passes the time waiting for java podcast cohosts to show up by getting haskell working on this machine. thats good times.  screw those pikers ( ok, ones sick, ones router exploded )
00:18:52 * talios wonders what is it about idris that lets it have a java backend where haskell doesn't ( or hasn't succeeded in yet ), I wonder if its anything to do with idris being strict.  Must ask edwinb about that.
00:20:08 <Ralith> talios: it's mainly because idris has a really simple terminal IR
00:20:15 <Ralith> it's easy to translate to nearly anything
00:20:40 <Ralith> (I think there is a JVM haskell, though, but I don't believe it's a ghc backend)
00:21:55 <talios> Ralith - I've been playing with Frege a bit, which is the closest I've seen to a working JVM "haskell".
00:23:10 <Ralith> there's OpenQuark too, but it's kinda shitty and dead
00:30:52 <mm_freak> chrisdone: server types?
00:31:49 <mm_freak> chrisdone: fastirc will not make a difference between clients and servers in the future…  it should be easy enough to write an IRC server using it
00:31:54 <mm_freak> but it's not done yet
00:37:25 <Sgeo> > (\((=='a') -> True) -> "It's 'a'") 'a'
00:37:26 <lambdabot>  "It's 'a'"
00:37:37 <Sgeo> Is that abusive of view patterns?
00:42:05 <quchen> Yes.
00:42:12 <mm_freak> Sgeo: in a sense…  but you can also abuse pattern guards
00:43:13 <mm_freak> alternatively you can use (notice the difference) a regular guard
00:43:47 <quchen> LambdaCase!
00:44:25 <identity> What library would be ideal for proper text input on the command line that allows backspace and so on?
00:44:37 <identity> just readline?
00:45:08 <mr-> identity: have you looked at haskeline?
00:45:16 <identity> mr-: nope, not at all
00:45:50 <identity> mr-: thanks! It looks active and complete
00:45:55 <identity> I'll take a look
00:46:12 <ghorn__> identity: it also has things like tab completion
00:46:19 <ghorn__> and history
00:46:20 <identity> ghorn__: oh, god, beautiful!
00:46:35 <mr-> identity: it's used by many important haskell projects. (like darcs and ghci IIRC)
00:46:53 <identity> I see
00:47:16 <identity> that sounds excellent
00:47:32 <mr-> so it's quite portable too :-)
00:51:00 * hackagebot crunghc 0.1.1.1 - A runghc replacement with transparent caching  http://hackage.haskell.org/package/crunghc-0.1.1.1 (AkioTakano)
01:12:51 <identity> are there any libraries for command line output formatting or just output formatting in general for haskell? I basically want to do output some columns of output, and content inside columns may need to have linebreaks added etc
01:15:54 <identity> think I found one
01:15:58 <identity> disregard my question
01:16:07 <dv-> which one
01:16:29 <identity> boxes
01:16:33 <identity> @hackage boxes
01:16:34 <lambdabot> http://hackage.haskell.org/package/boxes
01:19:21 <mirpa> http://lpaste.net/96865
01:20:30 <shachaf> tibell_: Any reason the Data.Sequence Foldable instances implement foldr instead of foldMap?
01:21:38 <mirpa> * updated with ghci output
01:23:36 <boom583> How would this simple C program look in Haskell? https://pastee.org/ywv5r
01:24:01 <boom583> Would you mind porting it quickly for me to see? I don't know any Haskell or functional programming, so I'm curious.
01:24:08 <boom583> It's only 15 lines.
01:25:46 <jle`> boom583: i can probably give you a not-as-clean solution in one line
01:26:02 <boom583> sure, go for it :)
01:26:16 <boom583> or feel free to make it cleaner if that's what haskell programmers usually do
01:27:08 <mirpa> boom583: http://lpaste.net/96867
01:27:57 <boom583> what does this have to do with functional programming? looks imperative to me
01:28:04 <jle`> :t putStrLn "type in" >> readLine >>= (\x -> putStrLn (if x > 10 then "more than" else "less than"))
01:28:06 <lambdabot>     Not in scope: `readLine'
01:28:06 <lambdabot>     Perhaps you meant one of these:
01:28:06 <lambdabot>       `readFile' (imported from Prelude),
01:28:16 <jle`> :t putStrLn "type in" >> Data.Text.readLine >>= (\x -> putStrLn (if x > 10 then "more than" else "less than"))
01:28:17 <lambdabot> Not in scope: `Data.Text.readLine'
01:28:19 <jle`> darn.
01:28:24 <tdammers>  mirpa: hah, mine looked almost exactly the same, except I used <$> instead of fmap
01:29:08 <identity> jle`: getLine?
01:29:09 <jle`> boom583: the imperativeness is syntactical sugar
01:29:09 <identity> or readLn
01:29:17 <identity> @hoogle readLn
01:29:18 <lambdabot> Prelude readLn :: Read a => IO a
01:29:18 <lambdabot> System.IO readLn :: Read a => IO a
01:29:25 <jle`> identity: yeah, i meant readLn
01:29:49 <boom583> jle`: what do you mean?
01:29:54 <jle`> boom583: what's happening is that it is combining IO action objects into one big one
01:30:13 <jle`> basically main = ... is an IO object that is basically some kind of instruction graph
01:30:25 <jle`> that we build using single instruction objects
01:30:38 <jle`> and combine/merge together using >>= and >>
01:30:48 <teneen> what's the dual of a functor?
01:30:50 <jle`> the do notation is syntactical sugar for the >>= / >>
01:31:07 <jle`> @undo do { x <- getLine; putStrLn x }
01:31:07 <lambdabot> getLine >>= \ x -> putStrLn x
01:31:11 <boom583> hmok
01:31:12 <jle`> that's the desugaring
01:31:40 <jle`> basically, getLine is an object that represents an action. maybe if you're from C you can think of it as a little packet of C code
01:31:47 <jle`> and putStrLn is also a little instruction packet
01:31:57 <jle`> and what the operator >>= does is it looks at the two packets and merges them into one
01:31:59 <haasn> teneen: a contravariant functor?  I guess the technical dual is just the equivalent element in Cat^op, but I'm not sure if that's a contravariant functor or something else
01:32:21 <jle`> the end result is a new little packet
01:32:34 <jle`> a new little packet of c code, or assembly, or machine code, or what have you
01:32:58 <mirpa> What is wrong with: (fmap fromJust . takeWhile isJust) <$> mapM (const f) [1..] -- f :: Get (Maybe a) ...howto fix memory leak?
01:33:30 <teneen> Why not this: class DualFunc f where dfmap :: (f a -> f b) -> a -> b?
01:33:54 <boom583> jle`: might as well be chinese
01:34:00 <boom583> will learn you a haskell teach me this?
01:34:21 <jle`> learn you a haskell will teach you how to practically use it
01:34:35 <jle`> you actually don't need to understand what's under the hood at first really
01:34:42 <nisstyre> fpcomplete has some good stuff on how to write "production" Haskell
01:34:46 <jle`> you can 'pretend' it's imperative :)
01:34:49 <nisstyre> at least, the http-conduit tutorial is good
01:35:00 <boom583> hmok
01:35:09 <jle`> http://blog.jle.im/entry/id/6
01:35:14 <AshyIsMe> man hlint is cool
01:35:19 <jle`> but read through LYAH though
01:35:37 <nisstyre> there are some "hard way" tutorials too
01:35:40 <tdammers> jle`: minus a few edge cases that may or may not bite you...
01:35:51 <jle`> but i am sure you can understnad how the haskell code that the other people gave would help
01:36:10 <jle`> it probably reads like imperative code and i'm sure you can see what it's trying to do
01:36:21 <jle`> i recommend you just don't worry aobut it now
01:36:25 <jle`> :)
01:40:50 <jle`> tdammers: if you think of it that way then you are missing out on a lot of the power of haskell
01:40:59 <jle`> i feel like that is the bigger risk
01:41:05 <jle`> than having it bite you
01:41:08 <jle`> and you'll probably hit it first
01:43:37 * talios sighs and gives up on haskell again, stupid cabal - can't seem to shake these old homebrew references. no matter what I rm from my system. hrm.
02:06:10 * hackagebot tasty 0.5.2 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.5.2 (RomanCheplyaka)
02:12:35 <jle`> don't do it talios there is still so much to live for
02:12:48 <talios> :)
02:14:06 <talios> so far I'm totally removed all haskel-platforms, rm -rf'd my ~/.ghc and ~/.cabal and ~/Library/Haskel directories, and yet - the moment I run cabal update, I seem to get references to homebrew in Library/Haskel/doc/* and other files
02:14:24 <talios> this is worse than dealing with a type system :)
02:16:36 <MrWoohoo> what os?
02:16:52 <talios> OS/X Mavericks - the oner Haskell hates ;)
02:16:58 <talios> -r
02:17:03 <identity> talios: you could try building the haskell platform
02:17:06 <identity> it's really not difficult
02:17:35 <MrWoohoo> heh. i use it too. i nevel know which bit from which install it is using
02:17:45 <dcoutts_> talios: what kind of references to homebrew?
02:17:58 <dcoutts_> talios: Haskell packages from homebrew?
02:18:00 <talios> hrm, i thought I just installed platform.pkg
02:18:18 <dcoutts_> talios: did you install ghc via homebrew before?
02:18:26 <talios> dcoutts_ - pre-mavericks I had installed ghc via homebrew
02:18:39 <identity> talios: did you remove it yet via homebrew?
02:18:49 <talios> yep - afaik I have
02:18:51 <dcoutts_> talios: ok, so check where your ghc, ghc-pkg & cabal are coming from, e.g. using which
02:19:00 <identity> talios: did you check your path and make sure that cabal isn't being run from the bin directories instead of ~/.cabal/bin ?
02:20:16 <talios> ahah!  even tho I removed ghc from homebrew, looks like it left all the files behind, and that was being picked up on the path
02:20:25 * talios does a bit more rm love
02:30:02 <MrWoohoo> Hmmm, O have version 7.6.3 installed. whats the current version of ghc?
02:31:06 <merijn> talios: Haskell Platform provides an uninstaller for OSX
02:31:11 <talios> w00t - cabal working again :)
02:31:13 * hackagebot ordrea 0.2.0.0 - Push-pull implementation of discrete-time FRP  http://hackage.haskell.org/package/ordrea-0.2.0.0 (AkioTakano)
02:31:18 <merijn> talios: oh, you installed via homebrew?
02:31:37 <merijn> talios: I personally would just recommend installing the binary platform on OSX
02:31:51 <talios> merijn - a long time ago it seems - and bitrot set in :)
02:34:05 <dcoutts_> MrWoohoo: that's the latest release (7.8 RCs are out soon, but don't expect stable releases for a while yet)
02:34:22 <MrWoohoo> thanks
02:36:04 <merijn> MrWoohoo: In general GHC follows an even version is release, uneven is development pattern
02:38:04 <Yuu-chan> Btw, how to install cabal packages on OSX without installing GCC additionally? There is a problem with C preprocessing in some packages.
02:38:49 <talios> Yuu-chan - http://justtesting.org/post/64947952690/the-glasgow-haskell-compiler-ghc-on-os-x-10-9 worked for me.   Assuming your talking the mavericks issue
02:39:14 <volko> Yuu-chan: do you have llvm installed?
02:39:27 <dcoutts_> Yuu-chan: there's advice here http://www.haskell.org/platform/mac.html
02:39:42 <Yuu-chan> talios: oh, thank you!
02:40:32 <Yuu-chan> Yes, I hadn't that problem before updating to Mavericks
02:40:55 <talios> just sharing the love and help the rest of the channel has given me tonight already :)
02:41:47 <volko> ah
02:41:56 <Yuu-chan> This is a lovely channel indeed.
02:42:13 <volko> I guess homebrew's llvm solved that for me
02:42:22 <volko> I never noticed there was a problem :p
03:13:17 * piezoid happy with cabal's allow-newer :)
03:18:43 <mreh> Is there anything that nicely wraps up the shiny new cryptographically strong RNGs API?
03:19:28 <mreh> or do I have to handle my own reseeding?
03:32:34 <AshyIsMe> hmm, vim seems to be really slow with a long haskell file (3k lines or so)
03:32:52 <AshyIsMe> wonder if there's a bug in vim2hs somewhere
03:36:24 <tdammers> my money is on syntax highlighting
03:36:38 <tdammers> but then, 3k is not a lot
03:39:03 <MrWoohoo> help I have a version version 6.10.1 of ghci living in /usr/bin.... I am using macports to install haskell (not currently installed) and want to purge this crufty 6.x version stuff. Where else should I look for old haskell stuff?
03:41:45 <AshyIsMe> yeah
03:41:55 <AshyIsMe> changing the file to blah.txt and editing like that is fast
03:42:00 <AshyIsMe> probably highlighting
03:44:02 <ghorn__> AshyIsMe: my emacs is significantly slower if I have really long strings (like 100s of lines) inside a haskell file
03:44:09 <ghorn__> 3k lines should normally be not a problem
03:44:16 <ghorn__> i don't know for vim though
03:44:53 <AshyIsMe> it's a silly file
03:45:12 <AshyIsMe> csv data layed out as a valid named haskell list
03:48:16 <MrWoohoo> is the best way to install ghci on osx maverick's 'port install haskell-platform'?
03:49:14 <mlen> MrWoohoo: did you consider to switch to homebrew?
03:49:52 <MrWoohoo> I used homebrew long, long ago. Is ports dead again or something?
03:53:03 <mlen> I think there are a lot more people using homebrew (none of my friends that have macs use macports)
03:53:39 <mlen> support looks well, some packages are precompiled (including ghc)
03:53:42 <Psycho_pr> +1 for brew
04:06:00 <mreh> why isn't there an Integral instance of ByteString :(
04:10:15 <Cale> mreh: How would that make sense?
04:10:53 <Adeon> can I somehow check which typeclass implementations have been defined for some data type in ghci
04:11:05 <shachaf> :i
04:11:24 <Adeon> ooh, thanks
04:11:48 <alpounet> it'll show the instances for the typeclasses in scope
04:11:58 <Adeon> yeah I figured
04:13:11 <mreh> Cale: join all the bits to make a very large integer
04:13:48 <mreh> I suppose I only have to multiply each bit by 8^(n-1), where n is it's position in the string
04:13:51 <mreh> then add
04:14:02 <Peaker> What is :- ? Is it a GHC HEAD thing?
04:14:22 <Peaker> I see a type signature that looks like (Functor f, ...) :- foo          without any =>   and I can't read that :)
04:14:46 <alpounet> isn't it from 'constraints' ?
04:15:03 <alpounet> yeah: http://hackage.haskell.org/package/constraints-0.3.4.2/docs/Data-Constraint.html#g:3
04:15:08 <Peaker> very possibly
04:15:16 <shachaf> Sounds like it. It's just a data type.
04:15:20 <shachaf> @google what constraints entail
04:15:21 <Peaker> (in lens)
04:15:22 <lambdabot> http://comonad.com/reader/2011/what-constraints-entail-part-1/
04:15:22 <lambdabot> Title: The Comonad.Reader » What Constraints Entail: Part 1
04:17:23 <alpounet> http://neocontra.blogspot.fr/2013/06/controlcategory-now-with-kind.html covers it too I think
04:18:47 <weltensegler_> A minor stylistic question: Why is it generally disadvised to use a space after a lambda? I feel like this is a silly question, but every style guide i come across mentions this.
04:20:16 <alpounet> weltensegler_: probably just habits
04:20:19 <Feuerbach_> weltensegler_: because we don't do this in lambda calculus notation
04:20:27 <alpounet> from lambda calculus yeah
04:20:40 <Cale> It's a bit weird of a thing to *mention*
04:20:53 <Cale> But yeah, it's true, we usually don't put a space.
04:21:07 <Cale> I don't think there's an especially important reason for it though.
04:21:27 * hackagebot csound-expression-dynamic 0.0.1 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.0.1 (AntonKholomiov)
04:21:29 * hackagebot csound-expression-typed 0.0.1 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.1 (AntonKholomiov)
04:21:31 * hackagebot csound-expression 3.1.0 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-3.1.0 (AntonKholomiov)
04:21:33 * hackagebot temporal-csound 0.2.1 - brings together temporal-music-notation and csound-expression packages  http://hackage.haskell.org/package/temporal-csound-0.2.1 (AntonKholomiov)
04:21:39 <flux> if it's a style commonly used, then it should be in the style guide?
04:21:56 <weltensegler_> Cale, thanks for the linguistic side note.
04:24:00 <quchen> The only place where you need a space after the "\" is when the pattern is irrefutable, e.g. `\ ~(a,b) -> ...`.
04:25:47 <Cale> Or you can use extra parens
04:25:57 <Cale> \(~(a,b)) -> ...
04:26:01 <Cale> (I've seen that)
04:27:03 <chrisdone> there's also the weird styles like putting no spaces inbetween tuples and list commas
04:27:14 <chrisdone> (a,b) instead of (a, b)
04:27:23 <Cale> I just do that randomly
04:27:43 <Iceland_jack> ( a ,b )
04:27:56 <Cale> Well, I don't put the spaces elsewhere :P
04:27:59 <chrisdone> iceland_jack: it burnses us!
04:28:03 <weltensegler_> I didn't know about the tilde ~. What is the advantage of marking an irrefutable pattern as such?
04:28:08 <Iceland_jack> ;)
04:28:27 <Cale> weltensegler_: The ~ means that a match against the pattern succeeds without checking
04:28:39 <hpc> > let (Just x) = Nothing in 5 -- weltensegler_
04:28:41 <lambdabot>  5
04:28:45 <Cale> weltensegler_: Only if you use one of the bound variables inside the pattern will the argument be evaluated.
04:28:46 <hpc> > let (Just x) = Nothing in x -- weltensegler_
04:28:48 <lambdabot>  *Exception: <interactive>:3:5-22: Irrefutable pattern failed for pattern (Da...
04:28:50 <chrisdone> weltensegler_: because lambdas force their argument
04:29:22 <hpc> chrisdone: lambda doesn't force the argument, pattern matching does
04:29:26 <Cale> *pattern matches* force their argument
04:29:26 <Cale> (or scrutinee)
04:29:33 <Cale> A plain lambda on its own wouldn't
04:29:35 <chrisdone> \(B x y) ->   =  \z -> case z of B x y -> …
04:29:37 <chrisdone> well, yeah
04:29:45 <chrisdone> but i'm just using context and english
04:30:05 * chrisdone wonders of irritably
04:30:26 <mr-> aren't ~ and "irrefutable patterns" different concepts?
04:30:35 <mr-> Ah, one implies the other
04:31:19 <hpc> mr-: in the same way that ! and seq are different concepts ;)
04:31:28 <hpc> or let-in and where
04:31:56 <quchen> chrisdone: For single-letter tuple elements I'm fine with no spaces.
04:33:15 <mr-> hpc: no, "let (a,b) = ..." is an irrefutable pattern, but ~ makes any pattern irrefutable (even those that might fail to match)
04:33:32 <mr-> (according to the "gentle introduction", at least ;-)
04:34:23 <hpc> mr-: let-in and ~ matching are identical
04:34:48 <hpc> there's nothing you can define in once that can't be desugared to the other
04:37:03 <jmcarthur> do we still not have a concise way to work with natural numbers as singleton types?
04:37:34 <hpc> jmcarthur: i thought we had numeric literals at the type level at this point?
04:37:35 <jmcarthur> e.g. where you don't have to say how much it succs
04:37:53 <hpc> i remember people going nuts about it a year ago
04:37:56 <mr-> hpc: yes, but consider, for example foo ~(Just x) = x; foo Nothing = 0. Here ~ makes a refutable pattern irrefutable. ~ makes a pattern irrefutable, but not every irrefutable pattern arises that way. That's what I wanted to say ;-)
04:38:14 <jmcarthur> hpc: but i don't think that allows me to use a literal value which will automatically get the right type, right?
04:38:17 <Hodapp> mr-: what does that ~ mean?
04:38:38 <jmcarthur> hpc: i would still have so say S (S (S (S (S (S Z))))) or something
04:38:49 <jmcarthur> (afaik)
04:38:57 <mr-> Hodapp: it's a lazy pattern
04:39:53 <jmcarthur> hpc: i guess i could use a proxy and type annotations instead...
04:40:41 <chrisdone> there's a slight difference with ~x and let which is the implicit fix
04:49:58 <chrisdone> hei donri
04:50:14 <donri> tjenare
04:54:44 <alpounet> jmcarthur: singletons may help?
04:54:58 <jmcarthur> alpounet: still no literal syntax for it :(
04:55:15 <jmcarthur> alpounet: so still have to say it succs a lot
04:56:19 <jmcarthur> alpounet: in the past, i've predefined some combinators for working in base ten. still ugly though
04:56:24 <alpounet> jmcarthur: I thought we had type level literals?
04:56:28 <alpounet> https://ghc.haskell.org/trac/ghc/wiki/TypeNats/Basics
04:56:32 * hackagebot simplessh 0.2.0.1 - Simple wrapper around libssh2  http://hackage.haskell.org/package/simplessh-0.2.0.1 (thoferon)
04:56:33 <alpounet> with Nat and Symbol
04:57:03 <jmcarthur> alpounet: yeah it looks like i might be able to do what i said earlier... a proxy with a type annotation that has a literal in it
04:57:58 <jmcarthur> alpounet: that's not until 7.8 is out though, right?
04:58:26 <donri> jmcarthur: 7.6 has TypeLits
04:58:40 <donri> maybe even 7.4, not sure
04:58:52 <jmcarthur> donri: that's the name of the extension? i can't seem to get it to work
04:59:20 <donri> jmcarthur: the extension is DataKinds and TypeOperators (for list cons)
04:59:20 <alpounet> http://www.haskell.org/ghc/docs/7.6.3/html/libraries/base-4.6.0.1/GHC-TypeLits.html
04:59:24 <donri> jmcarthur: GHC.TypeLits is a module
04:59:32 <donri> (yes, confusing)
04:59:40 <jmcarthur> donri: wait, DataKinds enables type literals too? i didn't know that
04:59:49 <alpounet> 7.4 doesn't seem to have this module thought
05:00:06 <donri> jmcarthur: yes, i think the syntax comes with datakinds
05:00:10 <jmcarthur> ah
05:00:15 <alpounet> jmcarthur: well it promotes the natural literals
05:00:22 <donri> TypeLits is where the identifiers they translate to live
05:00:32 <jmcarthur> got it
05:00:33 <jmcarthur> thanks
05:00:41 <donri> (yes, confusing)
05:07:02 <reizuki> how do I make decisions depending on which datatype my variable is? I have problems when one of possible types takes an argument. I tried using the underscore _ but it doesn't work that way: http://ideone.com/wS46Db
05:07:35 <reizuki> (don't mind the function's name and purpose, it is meant only for an example)
05:10:01 <Philonous_> reizuki, pattern matching
05:10:39 <Cale> reizuki: You don't mean which datatype, you mean which data constructor
05:10:57 <Cale> and yeah, you want to write something like:
05:10:57 <Cale> isFull Empty = False
05:11:05 <Cale> isFull (Full _) = True
05:11:15 <Cale> Actually, make that:
05:11:17 <Philonous_> http://ideone.com/9o8VMe
05:11:21 <Cale> isFull (Full _) = True
05:11:25 <Cale> isFull _ = False
05:11:39 <Philonous_> Wait, the site ate my changes
05:11:53 <Philonous_> Well, Cale postet it in here anyway
05:13:01 <jmcarthur> alpounet, donri: unfortunately, type level nats aren't structured, so i have no way to define a type class with instances for all of them, and i can't find a way to define a mapping from type lits to my own nat type. type families suffer from the same problem, since they aren't structured.
05:13:17 <jmcarthur> *since the type lits aren't structures
05:13:20 <jmcarthur> *structured
05:14:14 <jmcarthur> alpounet, donri: the problem is explained here https://ghc.haskell.org/trac/ghc/wiki/TypeNats/MatchingOnNats , but the solution they propose doesn't seem to actually work around the problem. i still see no way to define instances for that type class or something like it
05:16:05 <jmcarthur> alpounet, donri: the class C at the top of that page is pretty much exactly what i *want* to do
05:16:09 <alpounet> jmcarthur: maybe you should email ghc-users stating what you'd like to do, etc? it feels like there should be a way to do what you want here
05:18:09 <Hodapp> huh, so I've already been using lazy pattern matches, just not realized it...
05:18:18 <reizuki> Cale: ah, so I shouldn't use the vertical line thing | ?
05:18:24 <reizuki> thanks
05:21:50 <haasn> reizuki: pattern matching is cheaper, more idiomatic and more general than equality checking (via Eq/==)
05:21:53 <haasn> pattern matching is built into the language
05:22:09 <jmcarthur> they also say in that page "The good news is that the function FromNat1 is injective so, in fact, it is possible to determine the input from the output. We modified GHC's type checker to make it aware of this fact.", but i'm not seeing this injectivity in practice
05:22:25 <haasn> this is why we tend to frown on overuse of == in general, not too long ago we had a discussion in here about the drawbacks of using (x == Nothing) or (xs == [])
05:22:29 <alpounet> jmcarthur: maybe *that* bit is only in 7.8?
05:22:33 <alpounet> have you tested with head?
05:22:36 <jmcarthur> could be
05:22:41 <jmcarthur> no, i don't have a build
05:22:46 <haasn> jmcarthur: it's HEAD only, sorry
05:22:46 <jmcarthur> maybe tonight
05:22:52 <jmcarthur> haasn: i see. thanks
05:22:54 <haasn> GHC 7.6's type families pretty much do nothing
05:22:58 <jmcarthur> yeah
05:23:01 <jmcarthur> okay
05:23:16 <jmcarthur> g2g. thanks for the help everybody
05:23:20 <mangaba_leitosa> haasn: is 'null' better than xs == []?
05:23:25 <Cale> mangaba_leitosa: yes
05:23:34 <Cale> mangaba_leitosa: consider the type
05:23:38 <Cale> :t (== [])
05:23:39 <haasn> mangaba_leitosa: ‘null’ is more general; it's still not a reallly good practice
05:23:39 <lambdabot> Eq a => [a] -> Bool
05:23:42 <Cale> :t null
05:23:43 <lambdabot> [a] -> Bool
05:23:54 <haasn> mangaba_leitosa: in the vast majority of cases you'd just be best off explicitly pattern matching
05:24:00 <haasn> case xs of [] -> ...
05:24:05 <haasn> rather than case null xs of True -> ...
05:24:15 <Hodapp> haasn: why's that?
05:24:19 <Cale> Unless you really do just want to check if the list is empty or not and that's it.
05:24:34 <Cale> If you're going to start taking apart the list when it isn't empty, then you shouldn't be using null
05:24:55 <mangaba_leitosa> haasn: sometimes I write 'if null l || head l == x'
05:24:55 <mreh> is there a good CPRNG library with a good range of implementations of something like the Random class in System.Random
05:26:44 <haasn> Hodapp: well, the argument goes that you're carrying around useless, meaningless information (the Bool) without it being inherent that the Bool represents whether or not the list is empty. whereas a pattern match is really unique; and by pattern matching on stuff instead of using checks/‘deconstructor’ functions you gain advantage of coverage checking, better optimizations, inlining, etc.
05:27:22 <haasn> Hodapp: it's simple enough to mix up the cases of a Bool; whereas it's harder to mix up the cases of a pattern match in which you bind variables
05:27:56 <b_jonas> true
05:28:37 <haasn> mangaba_leitosa: hmm, foldr (const . (==x)) True -- :P
05:31:14 <osa1__> question to ghc-mod.vim users: GhcModCheck takes too long and even in async mode it's annoying, is there a way to make it faster somehow? maybe with some additional parameters to ghc or something like that?
05:36:23 <donri> osa1__: -fno-code makes it faster, but doesn't check templates
05:36:36 <donri> osa1__: there's also hdevtools
05:36:48 <osa1__> donri: I just switched from hdevtools
05:36:56 <donri> :)
05:37:04 <osa1__> it didn't work very well in my case
05:37:17 <donri> it doesn't support cabal sandboxes directly
05:37:56 <osa1__> so can I pass additional parameters to GhcModCheckAsync? maybe I can bind another shortcut for -fno-code
05:39:07 <donri> not to my knowledge, it's a global option that is only read once i think
05:40:25 <donri> but i'm not sure about that so you could try writing a command for setting the global option temporarily
05:41:38 * hackagebot base-io-access 0.2.0.0 - The IO functions included in base delimited into small, composable classes  http://hackage.haskell.org/package/base-io-access-0.2.0.0 (bheklilr)
05:42:38 <osa1__> donri: I don't know how hdevtools works and if it's really related with it but I had one problem: when I edit more than 15+ Haskell files, vim becomes basically unresponsive. every new character shows up in 2 seconds etc.
05:43:05 <donri> osa1__: are they in different projects?
05:44:07 <osa1__> donri: good questions. short answer is yes. long answer is file structure is something like: folder1/folder1.cabal folder1/folder2/.cabal and I'm editing files both from folder1 and folder2
05:44:51 <bergmark> i've never gotten multiple projects to work with anything
05:45:04 <osa1__> so it's problematic in ghc-mod too?
05:45:10 <osa1__> what's going wrong in that cases?
05:45:19 <donri> osa1__: and you're working from the same CWD?
05:45:29 <osa1__> donri: CWD is folder1
05:45:43 <osa1__> and I'm editing files from both folder1 and folder2, where folder2 is subfolder of folder1
05:45:48 <osa1__> and I have cabal files in both folder1 and folder2
05:46:23 <donri> osa1__: maybe try :lcd folder2 in a new window when working on that
05:46:50 <donri> osa1__: hdevtool makes a socket in CWD so i imagine in your case it uses the same socket and has to reload everything when you switch between the two projects
05:47:00 <donri> not 100% sure how it works exactly though
05:47:37 <osa1__> another problem I had is with FFI files, type checking doesn't work
05:47:47 <osa1__> but apparently it doesn't work with ghc-mod too
05:47:51 <osa1__> (hsc files)
05:48:01 <donri> yeah that sounds probable
05:48:06 <donri> i wish we had something that used cabal repl
05:48:18 <donri> (and that repl/ghci supported the necessary features like subexpr types)
05:49:09 <osa1__> does cabal provide an API for it's REPL?
05:49:11 <donri> osa1__: if all you're using them for is the check commands though you could try one of my cabal vim compilers and :make
05:49:27 <mreh> Why doesn't GHC like this?: catch (getEnv "FOO") (const $ return "<Nothing>")
05:49:29 <chrisdone> osa1__: ho, ho, ho!
05:49:41 <osa1__> donri: what other use do they serve? I thought it's all about checking and linting
05:49:46 <mreh> Ambiguous type variable `e0' in the constraint:
05:49:46 <mreh>       (GHC.Exception.Exception e0) arising from a use of `catch'
05:49:50 <osa1__> donri: I'd like to try your compilers
05:49:55 <chrisdone> mreh: if that's Control.Exception then the excception type will be ambiguous
05:50:07 <chrisdone> mreh: look at the type of catch
05:50:13 <donri> osa1__: the killer features they provide is inspecting the types of subexpressions and the equivalent of ghci's :info
05:50:16 <chrisdone> :t Control.Exception.catch
05:50:17 <mreh> chrisdone: const doesn't care about the type of its second argument
05:50:17 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
05:50:19 <donri> and type insertion
05:50:21 <chrisdone> mreh: so?
05:50:35 <mreh> chrisdone: does it still need to be instantiated?
05:50:43 <osa1__> type insertion?
05:50:45 <chrisdone> mreh: yes
05:50:48 <mreh> okay
05:50:50 <mreh> :(
05:50:57 <donri> osa1__: if you're already using vim2hs you have one of them already, just :compiler cabal. if not, i'm also working on a split up of vim2hs so there's vim-cabal, but it's not very complete
05:51:10 <chrisdone> mreh: but you can use SomeException to handwave it away
05:51:19 <osa1__> yeah I'm using vim2hs
05:51:41 <osa1__> okay I run :compiler cabal, now what should I do?
05:51:45 <chrisdone> mreh: catch (getEnv "FOO") (const (return "<Nothing>") :: SomeException -> IO String)
05:52:05 <chrisdone> mreh: although it's probably nicer if you look at the type of exception that getEnv will throw. presumably IOException
05:52:05 <donri> osa1__: type insertion means you call a command on an identifier and it inserts its type signature on the line above
05:52:07 <statusfailed> weiiiiiird... random-fu has a CDF class of distributions but not PDF?
05:52:16 <statusfailed> is there a reason for that I wonder?
05:52:19 <mreh> chrisdone: agreed
05:52:21 <donri> osa1__: then :make (for quickfix) or :lmake (for location list)
05:52:24 <mreh> thanks
05:52:43 <osa1__> donri: lol. it called my makefile
05:52:58 <donri> osa1__: it shouldn't do that if you did :compiler cabal
05:53:15 <osa1__> donri: ah yeah I had to do that for every buffer
05:53:27 <donri> osa1__: :compiler! cabal to make it global
05:53:51 <mreh> suprised System.Environment.getEnv doesn't let you provide a default
05:53:52 <osa1__> donri: yup, thanks. yeah that a simple solution and seems to work
05:53:52 <donri> osa1__: or better set up an autocmd FileType haskell,cabal compiler cabal
05:54:05 <mreh> is haskell' still something
05:54:34 <rdevilla> mreh: it has its niches
05:54:52 <rdevilla> I think finance is big into functional programming and Haskell
05:54:54 <donri> osa1__: (the one in vim2hs sets -fno-code though, probably not a good thing)
05:55:05 <rdevilla> and of course academics
05:55:16 <donri> osa1__: also you'll need to be in folder2 to make that (since cabal build works by CWD)
05:55:34 <donri> osa1__: btw if you're using tmux you could try tpope's :Make thing for async
05:55:36 <osa1__> donri: yeah, just realized that. it's bad ;-(
05:55:53 <mreh> Haskell prime
05:55:57 <chrisdone> lol
05:55:59 <mreh> not haskell
05:56:00 <rdevilla> mreh: whoops wrong channel
05:56:04 <osa1__> no I'm not using tmux, I'm using gvim (actually qvim, qt port of same thing)
05:56:09 <rdevilla> I was discussing haskell in another channel as well ._.
05:56:16 <mreh> :)
05:56:24 <rdevilla> did not realize this was actually #haskell
05:56:37 <chrisdone> osa1__: question: how long does time (gvim +q) take?
05:56:39 <FliPPeh> How can I insert stuff into a Data.Map so that both keys "foo" and "FoO" would reference the same item?
05:56:45 <mreh> @slap rdevilla
05:56:45 * lambdabot locks up rdevilla in a Monad
05:56:59 <FliPPeh> The docs don't appear to cover that or I'm way too tired to understand :(
05:57:01 <companion_cube> FliPPeh: normalize your keys before (to lowercase for instance)
05:57:10 <osa1__> ➜  ~  time gvim +q
05:57:12 <osa1__> gvim +q  0.10s user 0.01s system 45% cpu 0.246 total
05:57:13 <osa1__> ➜  ~  time qvim +q
05:57:15 <osa1__> qvim +q 2&> /dev/null  0.09s user 0.00s system 43% cpu 0.215 total
05:57:16 <osa1__> chrisdone: ^
05:57:18 * rdevilla unsafePerformIO's out
05:57:22 <FliPPeh> companion_cube: See, I'm just way too tired to come to that conclusion myself! Thanks :)
05:57:52 <companion_cube> FliPPeh: you could create a newtype for case-insensitive strings
05:58:02 <companion_cube> and compare them after lowercasing
05:58:07 <mreh> woah woah woah
05:58:13 <mreh> a whole newtype for that
05:58:14 <FliPPeh> That's an idea, but I don't think I need to go that far
05:58:36 <companion_cube> mreh: so that all functions of Map work in a case-insensitive way
05:58:38 <FliPPeh> I'll just process the keys beforehand
05:58:44 <donri> * rdevilla disappears in a puff of realworld-passing magic
05:59:44 <osa1__> donri: maybe I shouldn't expect that much from vim, running cabal repl from terminal and then :r should work
06:00:06 <donri> osa1__: that's what i tend to do yeah
06:00:54 <mreh> I forgot you can do newtype deriving
06:01:44 <jcristovao> hello... somewhat dumb question: what single letter would you use for 'monoid' abbreviation... given that m is usually used for monad(ic), and I've seen (z) used for MonadPlus
06:03:33 <Cale> Well, the monoid operations also use m?
06:03:49 <Cale> :t mempty
06:03:50 <lambdabot> Monoid a => a
06:03:53 <Cale> :t mappend
06:03:54 <lambdabot> Monoid a => a -> a -> a
06:05:01 <FliPPeh>     Expected type: String -> WriterT [Message] IRC ()
06:05:01 <FliPPeh>       Actual type: String -> WriterT [Message] IRC ()
06:05:06 <FliPPeh> Now this is akward
06:05:10 <jcristovao> yeah, that would be an option, and one could look at the function type and see what the 'm' would be refering to
06:05:29 <jcristovao> but I just wanted to check if any other 'non-written' convention was used
06:05:39 <MichProgrammer> good morning everone!
06:05:47 <Cale> g'morning :)
06:06:19 <MichProgrammer> Im working on some Homework and was referred here by #Programming :D
06:06:51 <Cale> Haskell?
06:07:22 <tdammers> there needs to be a programming language named "Homework"
06:07:39 <zett_zelett> There needs to be a programming language namen "Nirvana".
06:07:39 <tdammers> any question about it would, by definition, be a homework question
06:07:46 <Cale> MichProgrammer: Anyway, feel free to ask any questions you might have about the language :)
06:08:37 <FliPPeh> so "lift f arg" killed my compiler but "lift $ f arg" did not, that's nice
06:08:47 <MichProgrammer> yes haskell, its the last section of my programming languages class
06:11:01 <haasn> FliPPeh: that error message could be an incompatibility between WriterT and Strict.WriterT
06:11:09 <jmcarthur_mobile> FliPPeh: that confusing error message is bug report worthy
06:11:30 <FliPPeh> jmcarthur_mobile: GHC told me to report it as a bug even, because apparently it's impossible
06:11:32 <haasn> though I *think* GHC should include the module prefixen if they differ
06:11:33 <tdammers> MichProgrammer: so what's your question?
06:11:39 <FliPPeh> But I'm far too busy to get into that process now
06:11:58 <MichProgrammer> Here is my first.
06:12:00 <jmcarthur_mobile> FliPPeh: I always feel the same way when somebody suggests I file a bug
06:12:03 <FliPPeh> It seems to be a fairly easy bug to cause so I bet it's been reported dozens
06:12:07 <MichProgrammer> Syntax error in declaration (unexpected `}', possibly due to bad layout) is a message recieved from this line ....
06:12:26 <MichProgrammer> nelehelp a n | nelehelp a (n-1)
06:12:44 <haasn> FliPPeh: got a hpaste?
06:12:50 <jmcarthur_mobile> I wish there was a ridiculously easy way to file bug reports. Would likely increase the rate of bug reports significantly
06:13:12 <haasn> jmcarthur_mobile: --upload-file-automatically-when-ghc-panics
06:13:14 <jmcarthur_mobile> Trac is just clunky
06:13:35 <FliPPeh> haasn: queue people panicing about their secret sources :)
06:13:46 <haasn> FliPPeh: hence it being a flag :)
06:13:48 <FliPPeh> haasn: I'll try to isolate it a bit
06:16:42 * hackagebot cufft 0.1.0.3 - Haskell bindings for the CUFFT library  http://hackage.haskell.org/package/cufft-0.1.0.3 (RobEverest)
06:16:51 <Philonous_> FliPPeh, Probably everyone thinks it must have been reported and so nobody actually did
06:17:36 <FliPPeh> Philonous_: It's always like that :)
06:18:19 <haasn> :t insertWith $ comparing (map toLower)
06:18:20 <lambdabot>     Not in scope: `insertWith'
06:18:20 <lambdabot>     Perhaps you meant one of these:
06:18:20 <lambdabot>       `IM.insertWith' (imported from Data.IntMap),
06:21:14 <chrisdone> osa1__: thanks ;)
06:21:20 <FliPPeh> Grah, can't isolate it enough
06:21:36 <FliPPeh> My test case fails with the same error message but without the "please report the bug" part
06:24:19 <MichProgrammer> Ok all, I put my question in a paste http://pastebin.com/5fU1tNar I am not sure why this will not compile, any adepts see the issue?
06:24:23 <mauke> The paste 5fU1tNar has been copied to http://lpaste.net/96871
06:25:28 <MichProgrammer> popup blocker got whoever just messaged
06:25:35 <MichProgrammer> sry please try again
06:25:40 <FliPPeh> Well, it's not legal syntax
06:25:52 <FliPPeh> You have a guard specified but no follow up
06:26:15 <MichProgrammer> o? in line 6? i am new to haskell . which portion is the guard?
06:26:16 <FliPPeh> I think you want to replace that "|" with another "="
06:26:26 <FliPPeh> Because "|" starts a function guard
06:26:36 <MichProgrammer> so i lack an 'otherwise'?
06:27:02 <ion> No, what flippeh said.
06:27:04 <FliPPeh> You lack the guard condition and the "what to do if condition is true" part
06:27:18 <FliPPeh> So I think you don't want a guard :)
06:27:23 <FliPPeh> http://lpaste.net/96872
06:27:24 <FliPPeh> rather that
06:27:41 <FliPPeh> Functions are not like data types where you add additional lines with |
06:28:03 <MichProgrammer> okey with that simple change my complier error becomes "- Cannot infer instance "
06:28:04 <FliPPeh> Because of pattern matching the previous function is not overwritten
06:28:28 <MichProgrammer> like in ML '|' ok ic what I was doing there
06:28:59 <magicman> Writing JS for a bit. Amount of times bitten by mutable datastructures: 5 and counting -_-
06:29:13 <FliPPeh> Yes, the function will currently recursively call itself until 0 and then return [] and do nothing with the results
06:29:23 <FliPPeh> What should the function do?
06:30:31 <MichProgrammer> repeat elemets of a list nele [1,2] 3 -> [1,1,1,2,2,2]
06:30:31 <intrados> How would I translate GHC's type output into something it will accept as input? For example: MapMerge (DimensionOf b1) ((':) ((,) * Number) ('(,) * Number Length ('Neg 'One)) ('[] ((,) * Number))) sum,
06:31:13 <MichProgrammer> http://lpaste.net/96872
06:31:22 <MichProgrammer> I think i shold have it fixed with this
06:31:59 <reizuki> do I need to close "where" block somehow?
06:32:27 <reizuki> I have a "where" block inside a "do" block that works fine if there's nothing after it
06:32:45 <MichProgrammer> FliPPeh I see what you said about returning nothing, which I think I fixed in http://lpaste.net/96872 but line 1 reports that it cannot infer instance
06:33:04 <FliPPeh> MichProgrammer: Because you switched the arguments above :)
06:33:04 <reizuki> but as soon as I try to code anythin afterwards, it spits errors at me
06:33:16 <FliPPeh> "nele (x:xs) n = (nelehelp x n) ++ (nele xs n)" is how it should be
06:33:30 <reizuki> (this is inside hspec test definition)
06:35:35 <MichProgrammer> FliPPeh, I made that suggested change, but complier still returns an error at line 1 that it cannot infer instance. Im so new im not sure how to troubleshoot this problem
06:36:03 <FliPPeh> MichProgrammer: Works for me, but I added the type signature to the function
06:36:08 <FliPPeh> nele :: [a] -> Int -> [a]
06:36:32 <haasn> MichProgrammer: you have ‘n’ and ‘xs’ swapped in line 2
06:37:19 <MichProgrammer> FliPPeh, my instructor said type signatures were unnecessary, is this a case where it is necessary?
06:37:31 <FliPPeh> They are unnecessary but good practice
06:37:39 <FliPPeh> Highly annoying to read code without them
06:37:43 <MichProgrammer> do i need it because i used a wildcard '_' ?
06:39:22 <MichProgrammer> haasn thank you that is correct also!
06:39:37 <FliPPeh> But I said that 7 minutes ago :c
06:39:41 <haasn> type signatures are not quite unnecessary
06:39:42 <FliPPeh> I feel robbed
06:39:46 <MichProgrammer> o
06:39:48 <haasn> :t show . read
06:39:49 <lambdabot> String -> String
06:39:50 <ion> michprogrammer: Type signatures are great documentation for humans and as an additional bonus the compiler will verify that the code matches them.
06:40:03 <haasn> okay, this one works in GHCi/lambdabot because of extended defaulting
06:40:54 <MichProgrammer> FliP ic you did too. Thanks for all of your help guys and talking me through this one
06:40:57 <haasn> :t let f id = (id 'a', id False) in f
06:40:57 <lambdabot>     Couldn't match expected type `Char' with actual type `Bool'
06:40:58 <lambdabot>     In the first argument of `id', namely `False'
06:40:58 <lambdabot>     In the expression: id False
06:41:08 <haasn> :t let f :: (forall a. a -> a) -> (Char, Bool) in f id = (id 'a', id False) in f
06:41:09 <lambdabot> parse error on input `='
06:41:15 <haasn> :t let f :: (forall a. a -> a) -> (Char, Bool); f id = (id 'a', id False) in f
06:41:16 <lambdabot> (forall a. a -> a) -> (Char, Bool)
06:41:31 <FliPPeh> The short form is, type signatures are not *that* important to the compiler unless it can't defer on its own, but they are incredibly important for yourself
06:41:41 <haasn> actually I think that one technically isn't Haskell either
06:41:43 <FliPPeh> Because for most functions you can tell by the signature alone what it's supposed to do
06:41:52 <haasn> Well, it's trivial enough to construct an ambiguous type scenario via type type classes
06:41:54 <haasn> eg. Show/Read
06:42:01 <haasn> or RealFloat/Fractional
06:42:17 <haasn> s/RealFloat/Real/
06:42:19 <MichProgrammer> FliPPeh I see what you are saying about the information contained in a sig being valuable for programmers and compilers
06:42:26 <haasn> And I though I finally understood the Num hierarchy..
06:42:38 <FliPPeh> One does not simply understand haskell numerics
06:42:51 <ion> I want read . (:: Integer) . show to be sugar for read . (id :: Integer -> Integer) . show
06:43:49 <dv-> why not (read :: String -> Integer) . show
06:43:51 <ion> or alternatively (\x -> x :: Integer)
06:43:59 <ion> dv: In general, not just in this specific example.
06:44:16 <ion> One wouldn’t use “read” anyway.
06:45:30 <FliPPeh> reads > read
06:45:44 <haasn> ion: why not (read :: _ -> Integer)
06:46:09 <haasn> (actually your example would need the composition the other way round
06:46:35 <haasn> I sometimes wish I would just write 0::Int instead of (0 :: Int)
06:46:38 <haasn> I could*
06:46:52 <haasn> that is, for example, foo 0::Int bar
06:47:32 <ion> I prefer :: with a very low “precedence”.
06:49:09 * Eduard_Munteanu lols at Conjoined's superclass constraints.
06:49:22 <Eduard_Munteanu> class (Choice p, Corepresentable p, Comonad (Corep p), Traversable (Corep p), Strong p, Representable p, Monad (Rep p), MonadFix (Rep p), Distributive (Rep p), ArrowLoop p, ArrowApply p, ArrowChoice p) => Conjoined p
06:49:44 <ion> The Conjoined from Revelation Space?
06:49:57 <Hafydd> Looks very conjoined to me.
06:50:01 <Eduard_Munteanu> Close, the one from 'lens'. :)
06:50:22 <edwardk> Eduard_Munteanu: Conjoined is everything you can say about (a -> b) and (newtype Indexed i a b = Indexed { runIndexed :: i -> a -> b })
06:50:44 <edwardk> Eduard_Munteanu: making it more minimal is just like trying to asemble a ship in a bottle using chopsticks
06:51:44 <Eduard_Munteanu> edwardk: hm, I see... I would have expected a simpler set of properties to yield (->) though, but I guess you also want it compatible with Arrow and other classes?
06:52:17 <danilo2> Hello! Which library should we choose if we want to to generate html code using Haskell library? I want to construct HTML documents using something like applicative (parsec life style) or using some datatypes composition.
06:52:36 <danilo2> Could you rwecommend any library? :)
06:55:09 <alpounet> danilo2: blaze-html is pretty much a standard there
06:55:24 <edwardk> Eduard_Munteanu: the issue is that the 'simpler set of properties' implies all the rest
06:55:27 <alpounet> it uses various combinators and an efficient builder
06:55:45 <tdammers> blaze-html, or anything built upon it... assuming you want to work at the DOM level
06:55:54 <danilo2> alpounet: Thank you. I was looking into it right now. I could not find any information if it allows for applicative style html composition - do you know the answer?
06:56:09 <tdammers> alternatively, there are some template systems that are DOM-agnostic and work on HTML source code instead
06:56:14 <danilo2> tdammers: yeah, exactly
06:56:15 <alpounet> it's generally used in a monadic way yeah
06:56:15 <Eduard_Munteanu> Heh.
06:56:36 <danilo2> alpounet, tdammers: cool, thank you :)
06:56:40 <edwardk> Eduard_Munteanu: by making the ridiculous class in one place i can enable all the combinators to use whatever machinery they need to 'slop' all of the mass of the i -> a -> b to one side of the ->  or the other.   (i, a) -> b   or a -> (i -> b)
06:56:59 <edwardk> because it is both representable by (i ->)  and corepresentable by (i,)
06:57:23 <Eduard_Munteanu> Ah, I missed the indexing bit.
06:57:34 <edwardk> different combinators in lens need representability (if they are lens-like), and corepresentability (if they are prism like)
06:57:38 <eacameron> I want a simple partial function (- 10) but that obviously doesn't work because Haskell thinks it's negation
06:57:58 <Eduard_Munteanu> :t subtract
06:57:58 <Cale> eacameron: (subtract 10)
06:57:59 <lambdabot> Num a => a -> a -> a
06:58:15 <edwardk> in the case of (a -> b) this is trivial, they are representable/corepresentable by Identity
06:58:20 <Eduard_Munteanu> eacameron: not sure what you mean by "partial"
06:58:22 <eacameron> Cale: Eduard_Munteanu: thank you!
06:58:33 <Cale> eacameron: Or you can write (+(-10))
06:58:38 <Cale> If you're golfing :)
06:58:59 <edwardk> but the extra machinery avoids us incurring an unnecessary '(),' or '() ->' and thus increases sharing
06:59:11 <eacameron> Eduard_Munteanu: what's the right term? curried function?
06:59:29 <Eduard_Munteanu> eacameron: oh, partial application of a function
06:59:47 <eacameron> Eduard_Munteanu: yeah...sorry
07:00:03 <Eduard_Munteanu> eacameron: it's a bit confusing because "partial function" normally means a function that isn't defined for all inputs.
07:00:08 <edwardk> removing Conjoined basically means doubling the number of combinators in large portions of the library, and the performance hack of the 'conjoined' combinator is 30% performance more or less across the board
07:00:36 <eacameron> Eduard_Munteanu: oh yes...I remember that now. I got the two confused.
07:00:36 <edwardk> so i live with the amount of crap people give me about it ;)
07:01:54 <Eduard_Munteanu> edwardk: heh, I was only remarking it fits well into lens :P
07:09:16 <danilo2> alpounet: Do you know how could you write this example: http://lpaste.net/96877 using applicative style?
07:10:01 <danilo2> alpounet: I do not think it is currently possible, but I could be wrong
07:17:53 <jeltsch> Hi, I am trying to check a Cabal package for consistency before uploading it to Hackage.
07:18:17 <jeltsch> I run “cabal upload -c ⟨*.tar.gz file⟩.”
07:18:43 <jeltsch> However I get the error message 404 Not Found.
07:18:44 <alpounet> danilo2: the monad underneath blaze-html doesn't have an applicative instance
07:19:11 <alpounet> aand i'm not sure applicative would make that much sense
07:19:20 <alpounet> would would you like your code to look like?
07:19:24 <alpounet> how would*
07:19:29 <jeltsch> cabal-install version 1.18.0.2using version 1.18.1.2 of the Cabal library
07:22:14 <danilo2> alpounet: It would make sense - in my opinion. Anyway Blaze.Markup is Monoid and its mappend could be used to concatenate different html tags, so it is easy to use it in the form it is :)
07:24:21 <Jonatha__> why doesn't Num a imply Ord a?
07:24:43 <nstdloop> why doesn't Num a imply Ord a? (changed name)
07:25:49 <Philonous_> nstdloop, Because some Num instances like Complex don't have canonical orderings?
07:26:08 <nstdloop> Ah. That makes sense. I was only thinking of the Reals
07:28:47 <chrisdone> hvr: poke
07:31:51 * hackagebot HMap 1.0.3 - Fast heterogeneous maps.  http://hackage.haskell.org/package/HMap-1.0.3 (AtzeVanDerPloeg)
07:32:12 <deech> Hayoo appears to be down.
07:32:23 <deech> The site's up, but queries don't work.
07:32:28 <chrisdone> haha, i read that as fast horrendous maps. that would be an interesting library
07:36:52 * hackagebot yesod-routes 1.2.0.3 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.2.0.3 (MichaelSnoyman)
07:38:17 <byorgey> chrisdone: they are really fast, but 75% of the time they give you the wrong answer.
07:38:59 <byorgey> and occasionally they cause your computer to suddenly reboot.
07:39:07 <byorgey> but they are super fast!
07:39:43 <Clint> sold!
07:40:05 <Philonous_> If they can't deliver on time they'll crash your program in embarrassment so you don't notice.
07:50:37 <chrisdone> z
07:50:40 <chrisdone> oops
07:54:26 <tdammers> oh, so that's what PHP uses for its "arrays"
07:55:22 <scriptor> tdammers: what?
07:55:47 <HugoDaniel> :D
07:55:49 <zomg> I'd guess something that isn't an array =)
07:57:31 <zomg> they actually have something called SplFastArray and also another one which can only use numeric indexes
07:57:43 <zomg> which probably use something closer to a C array as the container =)
07:57:53 <scriptor> SplFixedArray, yes
07:58:25 <scriptor> basically just has you set the size of the whole array
07:58:28 <Luke> seems like scala is becoming hugely popular for writing websites
07:58:35 <scriptor> so it's allegedly better with memory usage
07:58:41 <Luke> shows we're on the right path w/ haskell =)
08:01:55 * hackagebot yesod-platform 1.2.5.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.5.1 (MichaelSnoyman)
08:07:29 <nstdloop> How can I find my haddock_docdir for haskell-mode for vim?
08:07:38 <nstdloop> (aka where is the master index.html file)
08:08:45 <donri> nstdloop: possibly ~/.cabal/share/doc/index.html
08:29:44 <donri> nstdloop: possibly ~/.cabal/share/doc/index.html
08:30:01 <nstdloop> I think I found it by acking ~ for index.html
08:30:13 <nstdloop> ~/Library/Haskell/doc
08:30:16 <nstdloop> does that make sense?
08:30:46 <donri> maybe, don't know osx
08:31:31 <jophish> Yo yo yo
08:31:50 <jophish> I've been thinking about something similar to RAII in haskell
08:32:24 <donri> RAII is difficult with GC, especially without RC
08:32:36 <jophish> I don't think that RAII was quite the right word
08:32:58 <jophish> I meantL A system to ensure that files are closed, and resources are not leaked
08:33:03 <jophish> meant*
08:33:17 <khyperia> and how does GC not do that?
08:33:31 <khyperia> Do you mean some sort of "destructor"?
08:33:45 <jophish> this is pretty easy with monads, just pass in a function which uses the file handle to a wrapper which will close the file
08:34:08 <donri> monads aren't strong enough to get it just right though
08:34:11 <donri> you need indexed monads
08:34:12 <jophish> kekimmo: donri http://lpaste.net/96880
08:34:27 <jophish> something like this
08:34:32 <donri> jophish: that's not exception-safe though
08:34:35 <donri> :t withFile
08:34:36 <lambdabot>     Not in scope: `withFile'
08:34:36 <lambdabot>     Perhaps you meant one of these:
08:34:36 <lambdabot>       `writeFile' (imported from Prelude),
08:34:48 <donri> @hoogle withFile
08:34:49 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
08:34:49 <lambdabot> System.Posix.ByteString.FilePath withFilePath :: RawFilePath -> (CString -> IO a) -> IO a
08:34:59 <donri> @hoogle bracket
08:34:59 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:34:59 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:34:59 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:35:00 <jophish> ah, :/
08:35:20 <jophish> I was just about to propose this as a general form
08:35:31 <donri> it is the general form :)
08:35:40 <jophish> how do these handle exceptions then?
08:35:43 <donri> but it's not always good enough
08:35:47 <donri> there's a whole paper on this btw http://okmij.org/ftp/Computation/resource-aware-prog/region-io.pdf
08:36:28 <donri> jophish: basically they wrap the bind to "f" in an exception handler to run close
08:36:33 <jophish> cool beans
08:37:00 * hackagebot Paillier 0.1.0.3 - a simple Paillier cryptosystem  http://hackage.haskell.org/package/Paillier-0.1.0.3 (onemouth)
08:37:47 <donri> withFile name mode = bracket (openFile name mode) hClose
08:37:57 <donri> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Exception-Base.html#bracket
08:38:13 <donri> it should be noted that this plays badly with lazy IO though
08:38:36 <donri> if your "f" is hGetContents, the result is the empty string
08:38:57 <donri> because it's closed before the lazy IO is forced
08:38:57 <jophish> why's that?
08:38:59 <jophish> ah
08:39:14 <jophish> thanks for the education, donri
08:40:26 <donri> quite welcome :)
08:40:39 <khyperia> I find that kinda nifty. A pure value's thunks (such as String), when evaluated, perform IO actions.
08:41:05 <donri> nifty?
08:41:12 <khyperia> It's cool. I like it.
08:42:11 <donri> it's kind of beautiful in theory, though there are problems with it in practice
09:00:45 <jake_> hello. is this a good and precise way of thinking about functors vs applicatives vs monads?  http://adit.io/imgs/functors/recap.png
09:01:32 <cschneid> jake_: in general yeah. As much as a picture can.
09:01:50 <jake_> yes as precise as can be conveyed with kiddie pictures :)
09:02:00 <cschneid> jake_: I really liked LYAH's chapters building up functor -> applicative -> monad, showing what each does, and then where each leaves something out, and how the next step fixes that
09:02:48 <jake_> cschneid: would that be in chapter 11?
09:03:00 <cschneid> jake_: sure looks like it, just pulled it up
09:03:08 <cschneid> and it's been a while, but if I remember right, that's what made it click
09:04:36 <jake_> wait, shouldnt that be 2 rather than 3 in the Monad picture?
09:05:07 <cschneid> jake_: hmm, presumably?
09:05:34 <jake_> cschneid: anyway thanks I will read that chapter
09:06:06 <cschneid> jake_: yeah, it just is a nice way to build up the stack of types, showing why each step is nice. I had to keep playing with it a bunch to really understand what was going on
09:06:24 <cschneid> (I'm at the advanced newbie level)
09:13:23 <cariveri> why do haskell programmers need to exchange the keyboard so often?
09:14:38 <cschneid> cariveri: I don't know. Why?
09:14:45 <donri> they "type" too much?
09:14:57 <cariveri> cschneid: because "Haskell" is strongly typed
09:15:30 <cariveri> hi everyone
09:15:37 <cschneid> HAHAHAHAHAHAHAHA
09:15:40 <cschneid> :)
09:18:01 <jophish> List comprehensions used to be for every monad?!
09:18:05 <jophish> blimey
09:18:28 <enthropy> and they are again with -XMonadComprehensions
09:19:56 <jake_>  they were enabled by default before?
09:22:23 <cschneid> I've not actually run across a time where list comprehension would have saved more than a few lines inside the list monad. Is there a good reason for the special syntax, rather than just using `do`?
09:22:35 <jophish> Could someone give me a killer example of where this is useful?
09:23:43 <_jgr> itc: examples that can kill
09:27:31 <cariveri> is someone there from gtk2hs here?
09:28:08 <Clint> too many adverbs
09:29:26 <Peaker> cschneid: I think the appeal of comprehensions is that they look like the math notation
09:29:56 <cschneid> I could see that. But they're equivalent to list monad do notation, yes? Same "power"?
09:30:22 <cariveri> Clint: do you maintain parts of gtk2hs?
09:30:29 <quicksilver> cschneid: it's a very direct translation
09:30:39 <quicksilver> just a slightly different order
09:31:11 <quicksilver> so yes, (vanilla haskell) list comprehensions are just simple sugar around the list monad
09:31:21 <Clint> cariveri: no, i do not
09:31:21 <quicksilver> although, it is conceivable they optimise differently
09:34:38 <donri> last i heard, monad comprehensions made list comprehensions optimize worse
09:34:42 <donri> /less
09:35:11 <donri> (but same as do notation, IIRC)
09:36:40 <quicksilver> list comprehension was implemented as a direct-to-core translation and was specifically designed to make the fusion optimisations apply where possible. I think.
09:36:52 <quicksilver> It sounds possible that monad comprehensions couuld have broken that :)
09:37:41 <donri> i also heard concatMap is hard to fuse with streams, but i think i read it's easy with foldr/build fusion?
09:38:13 <donri> dcoutts? :)
09:40:58 <donri> http://www.reddit.com/r/haskell/comments/oolyt/why_are_guards_in_the_list_comprehension_faster/
09:43:32 <jophish> I saw a list of long operators in haskell libraries. Does anyone have a link to this
09:43:53 <jophish> The longest were from XMonad, little diagrams of screen layouts
09:44:03 <donri> nah you just need http://hackage.haskell.org/package/lens-3.10.0.1/docs/Control-Lens-Operators.html
09:45:24 <haasn> (****//***)
09:45:30 <haasn> what lens operator would that be?
09:48:51 <donri> no clue
09:49:29 <Kron> Haskell clearly should adopt unicode so we can have the silliest operators of any programming language
09:50:55 <fizruk> :t \(<!@#$%^&*/|\:-+~?>)->(<!@#$%^&*/|\:-+~?>)
09:50:57 <lambdabot> t -> t
09:51:19 <haasn> Kron: haskell is fully unicode-compatible. there's even an extension to allow unicode symbols for syntactical elements
09:51:20 <cschneid> self documenting code.
09:51:32 <Kron> haasn: today I learned
09:51:49 <haasn> > let (≥) = (>=) in 5 ≥ 3
09:51:51 <lambdabot>  True
09:51:57 <jophish> "I've seen code in Garry's Mod addons where the author didn't realise you could write -x to negate x, but also didn't realise 0-x was an option - so they used x - 2*x instead. It was pretty special."
09:52:12 <Kron> lol
09:52:36 <haasn> jophish: sounds like WoW addons, another big platform of “first time coders copy/pasting things”
09:53:15 <Kron> interestingly I read an article that implies some of the interesting properties of the PHP / Javascript code ecologies come from a similar background
09:53:27 <Kron> lots of fire time coders copypasting things leading to a horrible mess
09:53:34 <Kron> *first
09:53:48 <jophish> > let
09:53:49 <lambdabot>  not an expression: `let'
09:53:51 <haasn> Kron: sounds pretty much like my first time coding (in PHP and JavaScript, fittingly)
09:53:56 <cschneid> and/or the incentive to learn more programming.
09:54:02 <cschneid> no hating on new programmers
09:54:03 <jophish> > let (💃) = (>=) in 5 >= 3
09:54:04 <lambdabot>  True
09:54:09 <jophish> :/
09:54:12 <Kron> haasn: Gasp. You were one of Them! D:
09:54:14 <jophish> > let (💃) = (>=) in 5 💃 3
09:54:15 <lambdabot>  True
09:54:35 <haasn> Kron: in my defense, I was 10
09:54:39 <Kron> hah
09:54:59 <Kron> man, I was telling this to a few friends of mine: I grew up programming on QBASIC
09:55:00 <jophish> ☃
09:55:09 <haasn> Kron: I actually started with QBASIC, too. Are you me?
09:55:33 <haasn> Kron: wait, let me guess; you switched to Haskell from C#?
09:55:43 <Kron> people ask me why i'm trying so hard to move upwards into more restrictive languages like Haskell ("You can't even change variables!"), and it's sort of hard to explain my gut feelings without a history lesson
09:55:51 <Kron> no, from common lisp actually
09:55:55 <Kron> but anyway
09:56:03 <Kron> I came, originally, from a language with no functions
09:56:35 <Kron> why would you want to use functions? Use GOTO. You can use GOTO for anything, who needs complicated stuff like function calls that restrict your program control flow?
09:56:52 <mangaba_leitosa> language with no function? what would be the reason of existence of such a language?
09:57:00 <Kron> no functions
09:57:02 <Kron> no function calls
09:57:11 <Kron> you had to use goto labels and pass around global state (no scoping)
09:57:16 <tac> The reason people want restrictive languages is that freedom and responsibility are the same thing.
09:57:21 <Kron> right
09:57:21 <geekosaur> mangaba_leitosa, ever work with MS-BASIC?
09:57:30 <geekosaur> note, I do not mean QBASIC
09:57:31 <tac> When you work in a language that LETS you do anything, you are RESPONSIBLE for everything.
09:57:37 <Kron> and after I crawled into proper procedural programming
09:57:43 <Kron> and then I crawled into object oriented programming
09:57:52 <Kron> I realized that I certainly wasn't done crawling to better places
09:57:54 <Kron> so I went to lisp
09:57:57 <mangaba_leitosa> geekosaur: basic had 'def' for defining functions afair :_)
09:57:58 <jophish>  let (☃) = (++) in "Merry " ☃ "Christmas!"
09:58:02 <Kron> and now I'm trying to climb into haskell
09:58:04 <geekosaur> nope
09:58:08 <Kron> and later, possibly Idris or something
09:58:10 <jophish> > let (☃) = (++) in "Merry " ☃ "Christmas!"
09:58:12 <lambdabot>  "Merry Christmas!"
09:58:41 <Kron> I tried Prolog but it strikes me as a bit too toy-like and not necessarily a strict improvement over standard procedural / functional stuff
09:58:43 <haasn> > generalCategory '☃'
09:58:44 <geekosaur> there are dialects of BASIC which have functions, but the dialects that ran on ancient microcomputers didn't
09:58:45 <lambdabot>  OtherSymbol
09:58:47 <fizruk> Kron, pure math, on paper
09:58:53 <Kron> hah
09:59:04 <mangaba_leitosa> geekosaur: 'def fna(x) = x*x' :-)
09:59:05 <geekosaur> you had GOSUB linenumber
09:59:09 <Kron> y'know, it's kind of funny, I was talking to my gf about this earlier yesterday
09:59:23 <mangaba_leitosa> geekosaur: 'DEF FN: a pair of keywords introduced in the early 1960s to define functions'
09:59:25 <Kron> for the longest time, learning how to program was a problem of reductionism
09:59:40 <Kron> you have this idea in your head but you want to break it down into really basic steps so even a computer can do it
09:59:43 <haasn> it's cool that ☃ is a legitimate operator symbol. I'll be sure to work it into every program I write from now on
09:59:58 <mangaba_leitosa> haasn: is it a cellphone?
10:00:02 <Kron> addresses and counters and gotos and all that stuff. As languages got better it slowly started to become closer and closer to just the human level abstraction
10:00:05 <haasn> mangaba_leitosa: it's a snowman
10:00:10 <mangaba_leitosa> :-)
10:00:12 <Kron> you state the program like you'd think about the program
10:00:13 <haasn> mangaba_leitosa: do you have a snowman-shaped cellphone?
10:00:16 <Kron> factorial n = product [1..n]
10:00:26 <geekosaur> mangaba_leitosa, wonderful. try that on an Apple ][ or TRS-80 Model I/III
10:00:27 <haasn> Kron: I have a feeling you'd like ASP
10:00:41 <Kron> but Haskell is a real kick in the pants because it never really stopped, it went ABOVE human abstractions
10:00:52 <haasn> and into inhuman ones? :)
10:00:53 <mangaba_leitosa> haasn: probably :-)
10:00:55 <geekosaur> mangaba_leitosa, I spoke precisely, you do not have the option of picking whatever dialect you'd prefer, you get the dialect that actually existed on existing machines
10:00:59 <Kron> no longer am I learning to break down my reasoning into smaller steps, I'm trying to build up my reasoning to higher abstractions and concepts
10:01:00 <fizruk> Kron, for not toy-like Prolog see Mercury (i think)
10:01:12 <Kron> like coding in a language of weak superintelligent AIs
10:01:17 <mangaba_leitosa> geekosaur: ok, I thought that def was universal :-)
10:01:18 <haasn> I use, like, actual programs written in Mercury
10:01:19 <haasn> isn't that cool?
10:01:31 <Kron> monoids and monads and lenses and function combinators and so many new concepts
10:01:38 <fizruk> haasn, that's cool :)
10:01:39 <Kron> it hurts in a really good way
10:02:23 <geekosaur> very little was universal. microcomputers had what fit in their tiny ROMs, not full Dartmouth BASIC implementations
10:02:37 <mangaba_leitosa> geekosaur: I never really used def, though, because you could only do arithmetics with it :-)
10:02:39 <geekosaur> heck, Apple BASIC didn't even support floating point originally
10:03:06 <geekosaur> (main reason to buy an external disk drive: you could load a floating-point BASIC)
10:03:50 <haasn> Kron: and then eventually Haskell seems dumb and simplistic to you and you began treading upon the wonderful world of Agda
10:03:57 <Kron> that is the plan
10:04:07 <Kron> actually I'm not sure if Agda is necessarily the best bet
10:04:19 <fizruk> haasn, I heard you don't execute programs written in Agda
10:04:23 <fizruk> just compile
10:04:29 <Kron> i'm thinking it's actually reasonably okay to stick with Haskell and try and climb with it into dependant typing
10:04:36 <Zekka> Sorry to bother folks -- I'm currently writing some code that uses lists to manage nondeterminism, and it's gotten to the point where my list is so large it doesn't seem reasonable -- is there another way I should be managing nondeterminism?
10:04:39 <Kron> Haskell itself seems to be going places at an extremely rapid place
10:04:41 <Kron> *pace
10:04:46 <Kron> it's not a very static system
10:04:57 <haasn> fizruk: there's a runtime system but they haven't yet figured out how to prove it's correct using its own type system
10:05:18 <Zekka> From what I can tell Haskell is evaluating most of my list (at least to the point where the elements are thunks)
10:06:11 <Kron> hmmm, do you have a copy of your code online, Zekka? Lpaste or the like?
10:06:12 <haasn> Zekka: maybe something like LogicT?
10:06:24 <fizruk> haasn, I thought that was because Agda's RTS is slow
10:06:41 <Zekka> Kron - One second. I'm actually kind of tempted to do some microoptimization first because I think the way I've written it now is slow for other reasons
10:06:45 <Zekka> It's possible this is a non-issue
10:06:52 <Kron> sure
10:06:53 <Kron> good luck
10:07:08 <Zekka> Thanks.
10:07:14 <haasn> Zekka: it's possible the list usage may be legitimate but some surrounding code is inefficiently traversing it (eg. folding over it twice, blocking GC)
10:07:52 <Zekka> Right now I'm using a lot of concatenation -- doesn't that require a copy operation?
10:08:27 <Zekka> Because that might be part of the reason for its slowness if that's the case
10:10:41 <Kron> Zekka: in languages like haskell with immutable structures, there's a concept known as 'sharing'
10:10:50 <Kron> basically if the language can do with a pointer, it will use one
10:11:06 <Kron> wait... actually this is strict list concatenation
10:11:12 <Kron> so it will have to at least replicate the first list
10:11:18 <Kron> sorry, was thinking of it in terms of trees
10:11:47 <Kron> but this really tripped me up a lot myself when reasoning about haskell code efficiency
10:11:59 <Kron> > tails [1,2,3,4]
10:12:00 <lambdabot>  [[1,2,3,4],[2,3,4],[3,4],[4],[]]
10:12:02 <Zekka> Right now I'm writing a treelike data structure to simulate concatenation to see if that helps
10:12:10 <Kron> this only generates a list of 5 poitners to various parts of the first list
10:12:19 <Kron> it doesn't actually generate 15 new numbers in a new set of lists
10:12:22 <Kron> *5 pointers
10:12:29 <haasn> Zekka: it depends a lot on the specifics
10:12:29 <Kron> so this can make a lot of code deceptively fast
10:12:38 <haasn> Zekka: if you right-associate your concatenation and iterate through it cleanly then it shouldn't be a problem
10:12:58 <Zekka> haasn - Can you clarify what you mean by right-association in this case?
10:13:19 <Kron> a * (a * (c ...))
10:13:21 <Kron> sorta like that
10:13:27 <Kron> it takes each piece as it goes along
10:13:34 <haasn> Zekka: [1..7] ++ ([9..13] ++ ([18..30] ++ [35..40]))
10:13:52 <haasn> perhaps look at the definition of (++) to understand why this can have a big impact
10:13:53 <Zekka> That's what I felt like you might mean: I don't specify a specific order in most cases, and usually use the concat function for three or more items, except in one case
10:13:55 <haasn> @src (++)
10:13:55 <lambdabot> []     ++ ys = ys
10:13:55 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:13:55 <lambdabot> -- OR
10:13:55 <lambdabot> xs ++ ys = foldr (:) ys xs
10:14:06 <haasn> ‘ys’ is never inspected
10:14:23 <haasn> but ‘xs’ is taken apart
10:14:39 <Kron> while it may look like it would generate a big function call stack, laziness actually makes it kinda-sorta-tail-recursive
10:14:47 <Kron> though calling it tail recursive is a bit of mental abuse of notation I guess
10:15:05 <Kron> haskell doesn't really quite have a function call stack in true compiled execution, as far as I know
10:15:13 <Kron> the call stack only exists in a programmer's head
10:15:31 <Zekka> Thanks for being willing to help out, by the way -- I'll paste my code as it was in a second
10:15:53 <haasn> Kron: heh, it recurses into the tail of xs ;)
10:16:35 <haasn> Kron: haskell uses an evaluation stack, not an execution stack
10:16:42 <Cale> uh
10:16:43 <haasn> you follow the chain of value dependencies
10:16:43 <Zekka> I think I found another problem that I hadn't considered: in a second I'll see if you agree
10:16:45 <haasn> I mean
10:16:47 <haasn> GHC uses one
10:16:50 <Cale> There's a stack in GHC's implementation, but it's more of a pattern matching stack than it is a call stack.
10:16:53 <haasn> Haskell doesn't specify an implementation model
10:16:54 <Zekka> and if I'm right I should slap myself
10:17:26 <haasn> for every “case .. of”, GHC first needs to evaluate the .. before it can continue with the branches
10:17:32 <Cale> right
10:17:35 <haasn> this is the evaluation stack
10:17:36 <Kron> unless you do ~(x:xs)
10:17:41 <haasn> Kron: yes
10:17:44 <Kron> in which case you're probably going down a very silly path
10:18:08 <Cale> Kron: Well, unless you *know* that eventually the thing will evaluate to a nonempty list
10:18:23 <haasn> yeah, for example if you know it's infinite
10:18:42 <haasn> (because you generate it yourself. but the pattern match needs to be lazy in order to prevent it from blackholing)
10:18:47 <Kron> hmmmmm, hadn't thought of the infinite list example
10:18:57 <Zekka> Right, here's the code: http://pastebin.com/L9z7Lj8J
10:19:01 <mauke> The paste L9z7Lj8J has been copied to http://lpaste.net/96881
10:19:13 <Zekka> Oh, should have used lpaste: pastebinit defaulted to pastebin though
10:19:14 <haasn> lazy pattern matches have legitimate use cases, also for cases in which you only have a single constructor like ~(x,y)
10:19:41 <haasn> :t allOf
10:19:42 <lambdabot> Profunctor p => Accessing p All s a -> p a Bool -> s -> Bool
10:19:54 <Zekka> If you're wondering, the problem I just realized I had was that allOf used nub -- I think I forgot about that
10:20:06 <Zekka> if I'm not mistaken that greatly increases the number of traversals
10:20:20 <haasn> Zekka: ‘nub’ is a pretty big no if you're trying to avoid storing a huge list in memory
10:20:35 <Zekka> Also, that's not stdlib allOf (I wasn't even aware a function by that name was in the stdlib) but one defined on line 8
10:20:41 <haasn> use something like a foldl' with an internal strict HashSet or whatever
10:20:46 <Zekka> Yeah -- I'd forgotten my definition used that
10:21:03 <Cale> Zekka: (The allOf that lambdabot knows about is from the lens library)
10:21:05 <haasn> Zekka: ‘stdlib’ is a pretty far stretch, the allOf I referenced is from lens :)
10:21:10 <Zekka> Suffice to say it worked fine before the list started getting reasonably large
10:21:39 <Kron> correct me if i'm wrong, but isn't asStrings just pure?
10:21:42 <Kron> asStrings = pure
10:21:50 <Kron> or wait no
10:21:53 <Kron> it's map pure
10:21:54 <haasn> Kron: no, map pure
10:21:58 <Kron> yeah sorry, mental misstep
10:22:04 <Zekka> You're right, it is
10:22:14 <Kron> I guess "map (:[])" is less confusing in any case
10:22:24 <Kron> also it is a neat excuse to use the monkey operator
10:22:24 <haasn> > comparing length "(:[])" "pure"
10:22:25 <lambdabot>  GT
10:22:33 <haasn> Kron: wait, I cannot unsee that now
10:22:43 <Kron> the monkey operator is the best operator
10:22:49 <Kron> also I like defining happy operators
10:22:53 <Kron> (^.^) f g = ...
10:22:59 <haasn> ^@.. snail operator
10:23:07 <haasn> I also like <<>~ rat
10:23:08 <Zekka> I'm a little bit inconsistent about return vs list notation because I was planning to use this to show some friends some Haskell sample code and I figured that using list-specific notation and functions would be easier for them to drok
10:23:23 <Zekka> grok*
10:23:23 <Kron> yeah I figured, Zekka
10:23:33 <Kron> the only reason I mentioned pure was that you were already using the list monad
10:23:41 <Kron> and pure sort of fits more neatly into the monadic context
10:23:44 <Kron> or return I guess
10:23:51 <Kron> I'm not sure of the differences between return and pure
10:23:56 <haasn> Zekka: I *think* the associativity of monads means return $ concat [c,c,c2] = [c,c,c2]
10:23:58 <Zekka> I'm pprobably going to explain the binding on 16 and 17 as an 'extended foreach'
10:24:02 <triliyn> return is for monads, pure is for applicatives
10:24:26 <Zekka> I was going to say what triliyn just did in response
10:24:33 <haasn> at least in this context
10:24:33 <haasn> but I could be completely wrong
10:24:47 <triliyn> Since monads are always supposed to be applicatives, pure should be available wherever return is and should do the same thing
10:24:53 <Zekka> I think 'foreach' is pretty accurate until you realize that monads aren't necessarily collections so I feel like it fits
10:25:03 <Kron> gotcha
10:25:17 <Zekka> haasn - I'm not sure, one second and I'll check
10:25:20 <triliyn> But for historical reasons there's a separate monad function in case there's no applicative instance for some reason
10:25:27 <Zekka> my gut is that it isn't but I'm not sure
10:25:57 <Zekka> return . concat $ ["abc", "def", "ghi"] is ["abcdefghi"], no?
10:26:10 <haasn> Zekka: yeah; and I just checked, it isn't the same
10:26:15 <Zekka> If you're wondering, removing nub makes it instant
10:26:24 <Zekka> and I feel sufficiently humbled at making a mistake that dumb
10:26:52 <Zekka> There's not actually much reason for nub to have been there because unique occurrences really aren't a big deal for this program
10:26:56 <haasn> it's not dumb, coming to terms with GHC's evaluation strategy and how standard functions interact is a fairly good skill to learn :)
10:27:06 <Kron> > return . concat $ ["abc", "def", "ghi"]
10:27:07 <lambdabot>  No instance for (GHC.Show.Show (m0 [GHC.Types.Char]))
10:27:07 <lambdabot>    arising from a use of `M205484136776341282118576.show_M2054841367763412821...
10:27:07 <lambdabot>  The type variable `m0' is ambiguous
10:27:07 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
10:27:07 <lambdabot>  Note: there are several potential instances:
10:27:32 <Zekka> > (return . concat $ ["abc", "def", "ghi"]) [String]
10:27:33 <lambdabot>  Not in scope: data constructor `String'
10:27:35 <Zekka> > (return . concat $ ["abc", "def", "ghi"]) :: [String]
10:27:36 <lambdabot>  ["abcdefghi"]
10:27:55 * haasn wonders if that module name is internally incremented once for each evaluation
10:28:08 <Zekka> I'm personally wondering what the number started with
10:28:09 <haasn> that would be a lot of evaluations
10:28:17 <Zekka> I didn't think Lambdabot was that popular
10:28:43 <haasn> a bot that serves the whole universe and then some is a happy bot
10:28:55 <Kron> lambdabot is love, lambdabot is life
10:29:01 <Kron> embrace lambdabot
10:29:47 <haasn> Zekka: explain it like Linq; non-Haskell programmers understand that apparently :)
10:30:23 <Zekka> haasn - It's a Java crowd with some Pythonists, I think, so I'm probably going to say comprehensions for pythonists and foreach for Java fans
10:30:40 <Zekka> There's also at least one nonprogrammer who's probably going to be very confused
10:31:05 <raphie> does anyone know of a way to read input from stdin until you reach an EOF? I'd like to get [String] back. I hoogled for IO [String] but couldn't find anything
10:31:16 <Kron> just tell them monads are monoids in the category of endofunctors
10:31:21 <haasn> Zekka: the hardware guy who thought this was a Haswell convention or something?
10:31:24 <Kron> while they're confused, steal all the pizza and slip away into the night
10:31:41 <Zekka> haasn - No, my girlfriend, who wants to go out for dinner afterwards.
10:31:41 <Kron> raphie, I think there's getContents?
10:31:52 <dv-> :t lines <$> getContents
10:31:53 <lambdabot> IO [String]
10:31:53 <Zekka> And the undergrad who's flunking his intro CS course.
10:32:12 <Kron> http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:getContents
10:32:19 <Kron> I'm not sure if it terminates on EOF or not though
10:32:43 <haasn> Kron: it does
10:32:45 <Kron> but in theory.... concat getContents
10:32:56 <Zekka> I'm actually probably going to be showing this off twice: once to some Haskellers so they can give their thoughts on it as a teaching exercise (this evening) and later to some non-Haskellers so I can try and spur some interest
10:33:02 <Kron> oh wait no you just want a [String] not a String
10:33:05 <Kron> so yes just getContents
10:33:10 <haasn> Kron: getContents is just a String :)
10:33:20 <haasn> IO String, rather
10:33:21 <Kron> I misread his question! D:
10:33:32 * Kron scuttles away
10:33:35 <haasn> dv- already gave the solution; assuming raphie wants lines
10:33:59 <haasn> of course, these days we'd tell you to use pipes or whatever rather than lazy IO
10:34:09 <triliyn> lines <$> getContents
10:34:19 <triliyn> Or however you want it to be divided
10:34:40 <triliyn> oh, someone already said that
10:35:37 <Kron> is there a problem with lazy IO for stdin?
10:35:54 <Zekka> Kron - What kind of a problem?
10:36:05 <Kron> just wondering why haasn referenced pipes
10:36:58 <allsystemsarego> http://lpaste.net/96882 - What is the equivalent parser to "satisfy is_x" ?
10:36:59 <triliyn> I think for reading from stdin it's not USUALLY very bad, but sometimes it is
10:37:10 <triliyn> And if you're reading from a socket or something you really want to have more control
10:37:44 <haasn> Kron: I'm not actually sure about STDIN; maybe something related to it closing prematurely?
10:37:59 <Kron> what do you mean by satisfy, allsystemsarego?
10:38:14 <Kron> wait I probably don't know enough to answer your question
10:38:14 <Kron> don't know Parsec
10:39:07 <haasn> allsystemsarego: I'm not sure what exactly you want to know
10:40:27 <allsystemsarego> @hoogle satisfy
10:40:27 <lambdabot> Text.ParserCombinators.ReadP satisfy :: (Char -> Bool) -> ReadP Char
10:40:28 <lambdabot> Text.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
10:40:28 <lambdabot> Text.ParserCombinators.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
10:40:47 <allsystemsarego> I want satisfy for a custom ADT instead of Char
10:41:17 <haasn> allsystemsarego: oh, parsec is a bit annoying to work with if you have non-Char streams
10:41:31 <haasn> there's in fact no direct equivalent, you can implement your own via http://hackage.haskell.org/package/parsec-3.1.4/docs/src/Text-Parsec-Char.html#satisfy
10:41:36 <allsystemsarego> oh, what's a good alternative approach then?
10:41:45 <allsystemsarego> I see
10:41:59 <allsystemsarego> thanks haasn
10:42:52 <haasn> allsystemsarego: I don't actually know; I eventually gave up trying to find a parser combinator library that made it easy to work with non-Char streams
10:43:06 <haasn> in my specific use case I ended up using ‘binary’ instead (to parse Word8 streams)
10:43:39 <allsystemsarego> ok, makes sense
10:43:48 <haasn> to me it really, really seems like http://hackage.haskell.org/package/parsers-0.9/docs/Text-Parser-Char.html#t:CharParsing should be reworked to be general in the token type
10:47:00 <haasn> @tell edwardk it seems to me like we could get a lot of very easily obtained generality by reworking the ‘parsers’ classes to work for token types other than Char; and then maybe making the Parser type in trifecta a bit more general
10:47:00 <lambdabot> Consider it noted.
10:47:34 <simpson> haasn: You've seen Text.Parsers.Combinators, right?
10:47:36 <Zekka> Is there a more idiomatic/stdlib way to express "putStrLn . words =<< forM [0..number] $ \_ -> randomChoice names" ? The last bit takes a random name number times.
10:48:14 <haasn> @tell edwardk the main concern would be absence of ‘text :: Text -> m Text’ as well as the ByteString and stuff inside Parser, which could be a performance hit; I think
10:48:14 <lambdabot> Consider it noted.
10:48:22 <Zekka> actually, it takes it number + 1 times
10:48:40 <reqefghrd> ciao
10:48:41 <reqefghrd> !list
10:48:42 <monochrom> reqefghrd: http://okmij.org/ftp
10:49:09 <Zekka> er, that should be 'unwords', I think
10:49:37 <Zekka> it also needs parens to correct for order of operations
10:49:48 <haasn> simpson: yeah that's quite useful but I think it still lacks fundamental ways to actually build parsers in the first place, ie. ‘satisfy’, ‘any’
10:51:10 <simpson> haasn: Sure. Out of curiosity, what were you planning on parsing?
10:54:42 <allsystemsarego> simpson, haasn was responding to my question here: http://lpaste.net/96882
10:54:44 <haasn> simpson: .torrent files; I forgot and can't seem to find the name of the encoding scheme it uses internally
10:55:09 <haasn> simpson: and on further inspection ‘binary’ did seem much more suited to the task than what I was planning on doing at the time
10:56:12 <haasn> simpson: the challenge was to generate an AST that had each node labelled with the ByteString that it was parsed from; but I wanted them to all be shared directly from the original ByteString - the idea was to use something like those parsers' abilities to know where in the stream they are to cut out that fragment
10:56:13 <Kron> how does one place typeclass constraints on type variables in a new type declaration?
10:56:34 <haasn> but binary can do the same, assuming I figure out the length
10:56:56 <haasn> Kron: what do you mean?
10:57:07 <haasn> Kron: in new data types (or newtypes) or in type synonyms?
10:57:20 <Kron> type (Ord a) => Thing a = Blah | Blee | Bloo
10:57:33 <haasn> Kron: short answer: you don't
10:57:36 <simpson> haasn: Mm.
10:57:42 <Kron> ok!
10:57:53 <haasn> Kron: observe that putting an ORd a constraint on the data type gains you absolutely nothing
10:58:13 <simpson> @tell edwardk Curses, I totally forgot. What's the story on left-recursive grammars? I want to parse things like "a statement, or a series of statements separated by newlines."
10:58:13 <lambdabot> Consider it noted.
10:58:14 <haasn> all it does is force you to include that constraint on *any* function involving a Thing a
10:58:36 <Kron> I suppose so, but isn't that a good thing?
10:58:37 <haasn> it does *not*, as you may expect, allow you to remove the constraint
10:58:52 <Kron> more constraints make it more expressive of exactly what it is meant to do
11:00:12 <ksira> I'm trying to learn applicative style. How do I rewrite (fmap . fmap) f ?
11:00:21 <Kron> if the entire point of Thing a is to make it some wrapper around stuff to be ordered or whatever, I don't see any reason to let people make non orderable Things
11:00:33 <haasn> ksira: (fmap <$> fmap) f
11:00:41 <haasn> (I'm kidding)
11:00:54 <Kron> ((.).(.)) f
11:00:56 <fizruk> fmap fmap fmap f
11:00:57 <Kron> the tits operator
11:01:06 <haasn> (f.:)
11:01:25 <ksira> ahh, my mind is blown now.
11:01:26 <Kron> is .: even defined in any default library?
11:01:30 <Kron> or do we have to make it ourselves?
11:01:30 <haasn> Kron: pointless-fun
11:01:40 <Kron> ksira: the joke is that in this context, fmap is exactly equal to (.)
11:01:41 <Kron> same thing
11:01:43 <Kron> so...
11:01:47 <Kron> fmap fmap fmap
11:01:50 <Kron> (.) . (.)
11:01:56 <Kron> fmap (.) (.)
11:01:58 <haasn> Kron: we don't know that here, actually
11:02:05 <Kron> oh?
11:02:08 <haasn> > (fmap . fmap) f [[x,y],[z,w]] :: [[Expr]]
11:02:10 <lambdabot>  [[f x,f y],[f z,f w]]
11:02:17 <cmtptr> what is this <$> that you guys keep writing and that hasn't appeared in any of the haskell texts I've been reading?
11:02:26 <haasn> cmtptr: (<$>) = fmap
11:02:27 <Kron> cmtptr, it appears in Learn You A Haskell
11:02:28 <triliyn> It's just fmap
11:02:31 <fizruk> is there an existing solution to run untrusted code in a virtual machine, get some results, etc., preferably from Haskell?
11:02:32 <haasn> cmtptr: it's just an operator version of it
11:02:32 <Kron> on the applicative functors page
11:02:34 <ksira> shorthand for fmap.
11:03:03 <ksira> so <$> <$> <$> is what I'm looking for then, lol
11:03:10 <haasn> cmtptr: I don't know what haskell texts you have been reading but you might be interested in http://www.haskell.org/haskellwiki/Typeclassopedia :)
11:03:20 <haasn> ksira: syntax error
11:03:28 <Kron> technically
11:03:30 <haasn> (<$>) <$> (<$>)
11:03:34 <Kron> (<$>) <$> (<$>)
11:03:34 <fizruk> ksira, (<$>)(<$>)(<$>)
11:03:37 <Kron> since they're operators
11:03:41 <Kron> now you can be even MORE confusing
11:03:46 <Kron> :D
11:03:48 <haasn> (.) `fmap` (<$>)
11:03:51 <Kron> lol
11:04:15 <fizruk> haasn, that's not the same as (fmap . fmap) :p
11:05:05 <fizruk> also, please, take a look at my question, anybody ^
11:05:20 <cmtptr> Kron, that's the main one I've been reading.  maybe I'm not to it yet or I glanced over it
11:05:21 <ksira> thanks for all the confusion guys... Now I can write applicative style in style!
11:05:25 <cmtptr> (learn you a haskell)
11:05:59 <cmtptr> also ghci doesn't know about it why I tried :t (<$>)
11:06:12 <triliyn> :m + Control.Applicative
11:06:18 <Cale> fizruk: Well, lambdabot uses mueval to evaluate expressions. It's not quite the same as running arbitrary untrusted code though.
11:06:18 <cmtptr> ah
11:07:16 <Kron> cmtptr: http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors
11:07:18 <Kron> it's on chapter 11
11:07:31 <cmtptr> thanks
11:07:52 <fizruk> Cale, yeah I know about mueval, yet I want to run arbitrary executable in a virtual machine (any), collect results or report about failures
11:07:57 <levi> Is anyone here familiar with the various Lava HDL packages on Hackage?
11:08:15 <levi> I just got a little FPGA dev board set up and it would be fun to experiment with.
11:09:08 <fizruk> Cale, seems like this problem keeps recurring so I though maybe there's an existing solution (perhaps even in Haskell)
11:09:12 <Cale> fizruk: Yeah, I don't know about anything Haskell-specific in that regard
11:09:30 <[swift]_> so let's say i use "mapM foo bar", where foo returns an "IO Maybe Baz", and I then use catMaybes to get a list of only the Just values. my question is: is there a more efficient way but still clean way to do this?
11:09:45 <fizruk> Cale, do you know about something similar which just does not use Haskell?
11:10:25 <[swift]_> at the moment all i can think of is to use foldM to build up the list. there doesn't seem to be a nice preexisting solution, though, unless i'm missing something
11:10:50 <shaladdle> Hi folks, I'm trying to update cabal-install on OS X 10.9 and I get this output: http://pastebin.com/suMypDyX . I installed haskell-platform from the website, and I have had previous veresions on my computer before. I did what the website suggested and set up ghc-clang-wrapper.
11:10:54 <mauke> The paste suMypDyX has been copied to http://lpaste.net/96884
11:10:57 <shaladdle> Anyone have this problem before?
11:11:39 <fizruk> :t catMaybes
11:11:40 <lambdabot> [Maybe a] -> [a]
11:12:12 <levi> [swift]_: Is there a performance problem? It may not be as inefficient as you think.
11:13:49 <[swift]_> levi: at the moment i haven't measured one, no. that's why i'd only bother with another solution if it was clean. i don't want to uglify my code over an imaginary problem =)
11:14:30 <fizruk> :t fmap catMaybes :: IO [Maybe a] -> IO [a]
11:14:30 <lambdabot> IO [Maybe a] -> IO [a]
11:15:49 <stee1rat> hey guys, could someone help me with xmonad here?
11:15:55 <[swift]_> fizruk: that is another way of expressing the same thing, though, right? mapM will construct the entire intermediate list before catMaybes runs over it, either way, as i understand it
11:16:12 <levi> stee1rat: You can ask, but #xmonad would probably have more xmonad-specific knowledge.
11:17:02 <stee1rat> oh, sorry, i'll try to ask there :) it's just the xmonad.org says i should join this channel
11:17:11 <Cale> fizruk: I was thinking of codepad, but I don't know what it uses.
11:17:40 <fizruk> Cale, virtual machines, firewalls and paranoia :)
11:17:58 <triliyn> [swift]_: that shouldn't need to construct the entire list, I think
11:17:59 <fizruk> Cale, http://codepad.org/about :)
11:20:34 <levi> [swift]_: I think the mapM will still work lazily; it's a combination of sequence and map, and sequence is just a foldr.
11:21:11 <[swift]_> levi/triliyn: this may be a misunderstanding on my part
11:21:20 <triliyn> oh wait, actually, now I'm less sure
11:21:30 <[swift]_> i thought the same about sequence
11:21:31 <triliyn> Because I DON'T think sequence is always lazy
11:21:36 <triliyn> @src sequence
11:21:37 <lambdabot> sequence []     = return []
11:21:37 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:21:37 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
11:22:07 <Saizan> it depends on what >>= for the particular monad does
11:22:15 <triliyn> Right
11:22:22 <triliyn> I'm not sure whether it's strict for IO
11:22:38 <levi> Well, we wouldn't have discussions about lazy IO if IO was always strict, would we?
11:22:49 <Saizan> (>>=) for IO is strict in its first argument
11:23:27 <Saizan> to get "lazy I/O" you need to use unsafeInterleaveIO (or things defined with it, tbc)
11:23:33 <triliyn> hmmm, I think that makes IO sequence strict
11:23:39 <[swift]_> yeah, it seems that way to me
11:23:54 <Saizan> yup
11:23:55 <[swift]_> so i think if I use mapM the entire intermediate list gets constructed
11:24:06 <Cale> It does.
11:25:11 <[swift]_> well, i guess it's foldM or nothing =)
11:26:05 <Cale> Are you expecting many occurrences of Nothing?
11:26:29 <levi> I'm not sure filtering out the Nothings during construction will save you a lot, unless there are a lot of Nothings.  You still have to process every element.
11:26:51 <Cale> Given that you're in IO, you could use an IORef
11:27:32 <fizruk> if there's a long list with a single Nothing at the end, you would be forced to construct the whole list except for last element (I think)
11:27:46 <[swift]_> i probably actually won't make any change, since i haven't measured a problem and it looks like it'll make things uglier. but yeah, i'm expected to process on the order of 1000 items at a time, with sometimes many Nothings
11:28:08 <Cale> For example...
11:28:52 <levi> [swift]_: You could always use one of the streaming libraries if you want to ensure things are processed in chunks.
11:29:17 <[swift]_> levi: heh, i was just thinking that if Tekmo was here he'd tell me to use pipes =) i really need to start using pipes more
11:29:57 <Cale> do r <- newIORef id; let { tell x = modifyIORef r (. (x:)) }; forM xs (... something which uses tell...); f <- readIORef r; return (f [])
11:30:52 <Cale> (assuming you want to write the elements of the list in order, rather than in reverse. If reverse is okay, just use an ordinary list instead of a function)
11:31:33 <[swift]_> Cale: reverse is OK, but the "something which uses tell" is actually STM, so for this particular case it won't work. that's a useful pattern to keep in mind, though
11:31:51 <Cale> Well, STM has TVars
11:32:29 <[swift]_> true. i guess basically i could move the loop _into_ the STM code
11:33:01 <[swift]_> i have a habit of trying to keep transactions tiny which is perhaps not always necessary
11:33:08 <Cale> Oh, is it like forM xs (\x -> atomically ...) ?
11:33:18 <Cale> You *should* try to keep transactions tiny if possible
11:33:20 <[swift]_> yup
11:33:59 <Cale> In that case, you can still do it, just produce an IO action as part of the result of the STM transaction, and have that optionally involve tell.
11:34:09 <Cale> (and then execute the IO action after the transaction)
11:34:22 <Cale> Or indeed, just use Maybe in there! :)
11:35:11 <[swift]_> ahh, that's an interesting idea! (producing an IO action from STM) i had never thought of that. even if I don't use that here, I bet that will be useful at some point
11:36:18 <levi> Personally, I would use Pipes or something to chunk/interleave things, but that may just be the limits of my Haskell knowledge speaking.
11:36:22 <raphie> is there a map which will pass in the index in the list, or should I roll my own?
11:36:56 <supki> @ty imap
11:36:57 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
11:37:14 <ion> @ty pop3
11:37:15 <lambdabot> Not in scope: `pop3'
11:37:21 <raphie> supki: thanks!
11:37:23 * hackagebot elm-repl 0.1.0.2 - a REPL for Elm  http://hackage.haskell.org/package/elm-repl-0.1.0.2 (EvanCzaplicki)
11:38:28 <[swift]_> levi: it's probably the right choice. i just need more experience with pipes. i use them for e.g. network IO, but i guess they still feel like a big hammer to me (probably because i don't use them much)
11:38:46 <zett_zelett> OMG, Microsoft chairman Bill Gates live in the Frasier Crane show!
11:40:12 <Cale> raphie: map f . zip [0..]
11:41:17 <Cale> imap is part of lens, I suppose you could use that, but I wouldn't pull in all of lens just to get it :P
11:41:44 <Cale> The idiomatic thing when you want indexed list operations is just to zip with [0..]
11:41:56 <bennofs> @ty imap
11:41:57 <lambdabot> FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
11:42:13 <moscowdriver> i need help
11:42:14 <Cale> :t \f -> zipWith f [0..]
11:42:15 <lambdabot> (Enum a, Num a) => (a -> b -> c) -> [b] -> [c]
11:43:07 <Cale> moscowdriver: So long as you mean help with a Haskell-related question, you've come to the right place :)
11:46:04 <S11001001> bennofs: unfortunately for reasons you typically get only Int for that i and some given f e.g. []
11:46:15 <S11001001> no fun
11:56:25 <Kron> hmmmm
11:56:40 <Kron> if I define a data type with a record field called length, how would haskell deal with the namespace clash?
11:56:52 <Kron> would it sort of choose length based on type inference or would that be an error?
11:57:38 <geekosaur> it'll complain unless you refer to them qualified
11:57:54 <geekosaur> Prelude.length vs YourModuleName.length
11:59:38 <ReinH> you can import Prelude hiding (length) if you want
12:02:07 <chrisdone> any structured-haskell-mode users?
12:02:08 <Kron> nah I'll just pick a more expressive name
12:02:19 <Kron> I'd love to install structured-haskell-mode actually
12:02:20 <Kron> like, today
12:02:32 <Kron> but right now i'm trying to get these bloody lenses to lens
12:02:47 <chrisdone> use a pokéball
12:03:14 <Kron> I try to press a b a b
12:03:23 <Kron> but it tells me it is a type error and I used be using a a b b
12:03:24 <chrisdone> doesn't work?
12:03:31 <Kron> damn statically typed pokemon technology
12:05:30 <Kron> I'm actually making a lot of progress now that I've forgone the template haskell magic
12:05:35 <Kron> and am making the lenses myself
12:05:46 <Kron> it makes me a bit more cognizant of what on earth is going on
12:05:56 <Kron> it's quite elegant now that I'm starting to grok it
12:07:26 * hackagebot scotty-fay 0.0.1 - Fay integration for Scotty.  http://hackage.haskell.org/package/scotty-fay-0.0.1 (hdgarrood)
12:11:57 <Kron> hmmm
12:12:03 <Kron> how exactly does the Getter type work?
12:17:50 <bennofs> Kron: Getter s a is really just a function s -> a
12:18:07 <Kron> hmmmm
12:18:11 <Kron> can getters take variables?
12:18:16 <bennofs> Kron: only represented a bit differently so that it can be composed with Lenses/Traversals/...
12:18:27 <bennofs> Kron: what do you mean by "take variables"?
12:18:41 <chrisdone> bennofs: why “s”?
12:18:41 <Kron> say you want a getter that queries a specific location in a structure
12:18:49 <Kron> so it's not just boss.HP
12:18:58 <Kron> it's map.(location (1,2))
12:19:00 <Kron> or something
12:19:09 <Kron> map as in like... a cartographic map
12:19:16 <Kron> not a function map or a hashmap
12:19:22 <ReinH> Kron: map as in: something that can be indexed?
12:19:22 <Kron> geeze we've really overloaded the word map
12:19:25 <Kron> yes!
12:19:31 <Kron> how about... uh... zone?
12:19:32 <ReinH> :t ix
12:19:33 <lambdabot> (Indexable (Index m) p, Ixed f m) => Index m -> p (IxValue m) (f (IxValue m)) -> m -> f m
12:19:36 <Kron> zone.(location (1,2))
12:19:48 <Kron> ... what is that?
12:19:57 <bennofs> > M.fromList [(1,2), (2,3)] ^.. ix 1 -- Something like this?
12:20:00 <lambdabot>  [2]
12:20:03 <ReinH> make your map thing an instance of those typeclasses and map ^. ix (1,2)
12:20:04 <bennofs> > M.fromList [(1,2), (2,3)] ^.. ix 2 -- Something like this?
12:20:05 <lambdabot>  [3]
12:20:12 <ReinH> or use a map thing that is already one, like Data.Map or Data.Array
12:20:56 <Kron> I'm trying to build a structure that is meant to be modified with extreme regularity
12:21:04 <Kron> so I'm opting to write a quadtree
12:21:09 <ReinH> > M.fromList [((1,2),2)] ^? ix (1,2)
12:21:11 <lambdabot>  Just 2
12:21:16 <Kron> but Indexable does seem nice
12:21:23 <ReinH> Kron: quadtrees are indexable
12:21:26 <Kron> definitely
12:21:29 <Kron> i'll look into it
12:21:41 <Kron> but still, in general, i also want to kind of know how to write my own lenses
12:21:49 <ReinH> :t lens
12:21:50 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
12:21:51 <Kron> so I return to my earlier question: can we add variables to our lenses?
12:21:56 <Kron> ix seems to have one
12:22:04 <bennofs> chrisdone: Lens often uses s/t for the whole structure and a/b for the part, so I adapted that convention (it's Overloaded f p s t a b)
12:22:15 <ReinH> Kron: ix takes an argument
12:22:19 <Kron> right
12:22:31 <Kron> how does it do that? currying?
12:22:41 <ReinH> that determines which index you are lensing into, and technically it's a Prism iirc because of potential failure
12:22:48 <Kron> ix returns ((Int, Int) -> (a -> b))?
12:22:52 <ReinH> :t ix
12:22:53 <lambdabot> (Indexable (Index m) p, Ixed f m) => Index m -> p (IxValue m) (f (IxValue m)) -> m -> f m
12:22:58 <bennofs> ReinH: it's a Traversal, not a prism
12:22:58 <ReinH> :t ix 1
12:22:59 <lambdabot> (Num (Index m), Indexable (Index m) p, Ixed f m) => p (IxValue m) (f (IxValue m)) -> m -> f m
12:23:02 <ReinH> bennofs: ah right
12:23:09 <benmachine> :t ix (1 :: Integer)
12:23:10 <lambdabot> (Indexable Integer p, Ixed f m, Index m ~ Integer) => p (IxValue m) (f (IxValue m)) -> m -> f m
12:23:22 <Kron> I'm trying to structure it in such a way such that failure is basically impossible
12:23:25 <bennofs> the pretty type (simplified) is ix :: i -> Traversal' s a
12:23:32 <Kron> it pretends to be a 2D array while using a quadtree as the representation
12:23:46 <ReinH> Kron: you can use ^?! when you don't expect the traversal to fail
12:23:49 <chrisdone> bennofs: but why “s”?
12:23:49 <Kron> when accessing subnodes of a leaf node, it will pretend that they're all the leaf node
12:24:12 <bennofs> chrisdone: Do you mean why lens uses s all over?
12:24:19 * chrisdone nods
12:24:24 <ReinH> > M.fromList [((1,2),2)] ^?! ix (1,2)
12:24:26 <lambdabot>  2
12:24:44 <ReinH> So that the type signature could be stab
12:25:11 <chrisdone> bennofs: i presume it comes from twanvl's convention if nothing else
12:25:20 <bennofs> ReinH: didn't you ask this question in your interview with Edward?
12:25:22 <chrisdone> bennofs: but i don't understand that either
12:25:26 <ReinH> bennofs: I think I did :)
12:25:35 <ReinH> and I think I made the stab joke too
12:25:45 * bennofs remembers that there was something more to it ...
12:25:53 <ReinH> Kron: the quadtree is an implementation detail that you should hide behind a generic map-like interface
12:25:59 <chrisdone> http://twanvl.nl/blog/haskell/overloading-functional-references uses “s”
12:26:13 <chrisdone> maybe “structure”?
12:26:17 <ReinH> Kron: and I would suggest just using a Data.Map for now :p
12:26:36 <Kron> that doesn't strike me as very efficient or educational
12:26:46 <ReinH> Kron: well how many things do you want to learn at the same time?
12:26:49 <Kron> isn't Data.Map basically a hash tree?
12:26:53 <ReinH> I usually do best with one at a time
12:27:09 <ReinH> it's a trie iirc
12:27:27 <chrisdone> i don't think it's a trie
12:27:38 <quchen> It's a standard tree
12:27:40 <geekosaur> fingertree, last I looked?
12:27:47 <chrisdone> just a binary tree
12:27:54 <ReinH> Oh right
12:28:17 <chrisdone> i suppose a trie would assume some knowledge about the structure of the key additional to order
12:28:28 <quchen> `data Map k a = Tip | Bin (size etc) (k, a) !(Map k a) !(Map k a)` I think.
12:28:36 <ReinH> it just uses the Ord constraint to balance right?
12:29:01 <Kron> anyway
12:29:22 <FreeFull> Not the most efficient thing in the world
12:29:25 <Kron> I'm assuming ix itself is not a getter, but (ix (1,2)) is a getter
12:29:27 <benmachine> ReinH: it uses the Ord constraint to... work
12:29:31 <Kron> ix being some sort of uncurried getter
12:29:41 <Kron> that you curry with a location to generate the true getter
12:29:47 <ReinH> benmachine: unordered-containers
12:29:53 <benmachine> FreeFull: it's log-n in most of the ways you could reasonably expect it to be
12:30:01 <benmachine> ReinH: is different :P
12:30:15 <ReinH> benmachine: but is an existence proof for not needing Ord "to work" :p
12:30:21 <benmachine> ReinH: I mean, it depends what you mean by "balance"
12:30:24 <quchen> unordered-containers is the HashMap business?
12:30:28 <ReinH> quchen: yeah
12:30:29 <benmachine> ReinH: sure, you don't need it, but you can use it
12:30:38 <chrisdone> hashable gives you an Int
12:30:47 <ReinH> benmachine: right, it's obviously using Ord as an optimization
12:30:50 <quchen> Hm. Well that's not that different from Map, is it? The keys are generted by hashes, basically
12:30:51 <ReinH> I thought it used Ord to balance the tree
12:30:58 <ReinH> but I could be wrong
12:31:08 <FreeFull> benmachine: You'd expect a map to have O(1) access
12:31:17 <quchen> It uses Ord for insertion, but the balancing is based on subtree sizes I think.
12:31:22 <benmachine> ReinH: aiui the idea is that the root of the tree is some element and the left subtree is things less than it and the right subtree is things greater
12:31:36 <benmachine> FreeFull: that's a colourful lie perpetuated by false memory models :P
12:31:50 <benmachine> FreeFull: and in any case, log-n isn't that different from 1 to be honest
12:32:07 <benmachine> FreeFull: you might reasonably expect better constant factors than Map gets you, but it's still not bad
12:32:09 <FreeFull> benmachine: Everything on a real computer is O(1) for a sufficiently large 1, I suppose =P
12:32:16 <benmachine> FreeFull: :)
12:32:21 <ReinH> heh
12:32:36 <ReinH> Kron: ix is a function that takes an argument and returns a function
12:32:38 <benmachine> FreeFull: but seriously it's literally impossible to have O(1) lookup in a "true" sense because it takes longer than O(1) to even read the key
12:32:44 <benmachine> although I suppose it depends what you're counting
12:33:01 <benmachine> you can get it in O(1) lookups :)
12:33:18 <quchen> FreeFull: Where 1 is the size of the computer's memory? :-þ
12:33:19 <FreeFull> benmachine: Reading is non-constant?
12:33:26 <S11001001> @pl \i -> f i (const . i)
12:33:26 <lambdabot> ap f (const .)
12:33:49 <FreeFull> quchen: Well, I'm talking about time complexity, which I suppose is ultimately bounded by memory assuming no external inputs
12:34:12 <benmachine> FreeFull: like I said, depends what you count, but if you assume reading a single bit is a constant-time operation then if you've got arbitrarily many keys they've got to be at least log n long each
12:34:16 <benmachine> log n many bits
12:34:47 <FreeFull> I'm pretty sure the longest-possible running program that terminates on a modern computer would take many, many times the age of the universe to terminate
12:35:05 <Kron> the universe's life is practically O(1) anyway
12:35:16 <bennofs> chrisdone: Another nice side effect is that s becomes the state if you use the lens stateful combinators
12:35:21 <FreeFull> benmachine: That's only if you allow for arbitrary-sized data
12:35:23 <ReinH> That's an interesting definition of "terminate" ;)
12:35:25 <benmachine> FreeFull: I can write a bash script that nominally takes that long :P
12:35:33 <quchen> FreeFull: You don't need a longest-running program for that. Just try to brute force a random 256-bit integer.
12:35:36 <benmachine> FreeFull: but as you pointed out, if you don't then everything is O(1)
12:35:40 <benmachine> 'cause you run out
12:36:28 <ReinH> FreeFull: all programs terminate at the heat death of the universe...
12:36:35 <ReinH> And that is my existential comment of the day
12:36:58 <quchen> IDEAS ARE BULLETPROOF
12:37:13 <quchen> Or heat death proof. Whatever you like.
12:37:18 <ReinH> Also I just solved the halting problem QED
12:37:30 * hackagebot fast-tagsoup-utf8-only 1.0.5 - Fast parser for tagsoup package  http://hackage.haskell.org/package/fast-tagsoup-utf8-only-1.0.5 (MikhailKuddah)
12:37:31 <quchen> halts = const True
12:37:34 <ReinH> I await my Turing Award.
12:39:06 <chrisdone> hmm, yeah. a tree based on Eq rather than Ord wouldn't know whether to go left or right
12:39:18 <chrisdone> so it would just be a list
12:39:36 <quchen> chrisdone: Insertion would be easier though.
12:39:39 <Kron> pfft, who needs Eq anyway?
12:39:40 <chrisdone> lol
12:39:53 <chrisdone> quchen: insert = nub .: (:)
12:39:58 <Kron> just insert stuff in front and pick a random element for the get
12:40:04 <quchen> Oh, nevermind, right.
12:40:12 <quchen> Insertion in a list is pretty easy as well.
12:40:35 <chrisdone> (well, maybe nubBy fst, but ja)
12:40:42 <chrisdone> w/e
12:41:34 <benmachine> chrisdone: mm. if the only question you can ask is "is this the right one?" you need to look at most of the things to find anything
12:41:42 <chrisdone> the paper that Data.Map is based on is nice. i've never implemented a Map. it would a be fun exercise to do
12:42:18 <benmachine> I bet it would be quite easily to do not very well
12:42:20 <chrisdone> benmachine: i mean for insertion. you can't insert in a binary tree with only Eq (or you end up with a list)
12:42:26 <quchen> chrisdone: Oh, it's interesting? I always thought Map was just some form of auto-balancing thing.
12:42:34 <quchen> Right subtree > 2*left subtree -> rotate
12:42:37 <chrisdone> it's not that interesting, just an easy read
12:42:42 <benmachine> chrisdone: oh right, sure, but that's basically the same :P
12:43:35 <ReinH> chrisdone: which paper?
12:43:51 <chrisdone> benmachine: yeah, with Eq for lookup you have a tree but only list access
12:43:57 <chrisdone> http://groups.csail.mit.edu/mac/users/adams/BB/
12:44:00 <ReinH> the easy papers go to the top of the pile :)
12:45:23 <quchen> ReinH: Got space for a hilarious one? http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.116.9158&rep=rep1&type=pdf
12:45:40 <ReinH> quchen: omg I've seen this one before :D
12:46:01 <quchen> It always makes me laugh loudly once I re-understand slowsort :-D
12:46:25 <quchen> Luckily I forget how it works after a year so I can experience it again and again
12:46:36 <Kron> LOL
12:47:59 <chrisdone> “The question is, can we do better, that is, worse?”
12:48:02 <chrisdone> =)
12:49:26 <quchen> Looking through a linear list in worse than n steps is also pretty impressive
12:49:50 <quchen> Well, linear-ish. But slowsort shadows all the other algorithms.
12:50:27 <quchen> My Haskell implementation takes forever to sort [1..100] even.
12:50:38 <quchen> And it gets *much* worse with more elements.
12:51:30 <ReinH> I still prefer the sort that just randomizes the list and checks to see if it was sorted
12:51:40 <ReinH> so easy to implement, so deliciously slow
12:52:08 <quchen> ReinH: But that one does not always terminate (almost surely though), and does a lot of unnecessary comparisons.
12:52:17 <quchen> Slowsort on the other hand makes no redundant steps.
12:52:29 <chrisdone> it's like researchers are being cruel to the programmers featured in Daily WTF by giving them ideas
12:52:37 <ReinH> yes I'm sorry my inefficient sort is to inefficiently inefficient.
12:52:59 <ReinH> quchen: oh it's guaranteed to terminate if run forever. Wait.
12:53:15 <chrisdone> “Intuitively, a reluctant algorithm for a problem P is one which wastes time in a way that is sufficiently contrived to fool a naïve observer.”
12:53:23 <ReinH> hahahaha
12:53:35 <ReinH> "Sort the list"
12:53:39 <ReinH> "But I don't wanna"
12:53:51 <ReinH> "The algorithm demonstrated some reluctance."
12:54:32 <chrisdone> :p
12:54:51 <piezoid> ReinH: you can track multiple lists, randomize them and select the most sorted -> genetic sort :)
12:55:38 <quchen> Or you could do SleepSort! O(n) sorting of any list!
12:55:41 <chrisdone> “are you done with that report yet?” “*closes pacman screen* still working on it, boss. here's my progress report” “okay, keep up the good work”
12:58:56 <quchen> chrisdone: I'm looking forward to the day I can finally use sleek Linux desktop switching to fool someone!
12:59:44 <chrisdone> quchen: oh yeah?
13:00:09 <chrisdone> reinh: your twitter says “Writes and speaks about Ruby and stuff.” i demand an explanation for this ლ(ಠ益ಠლ)
13:00:16 <ReinH> chrisdone: well I do.
13:00:29 <quchen> ReinH: We all do things like these, but we don't mention them in public!
13:00:34 <ReinH> hah
13:00:53 <ReinH> chrisdone: fixed
13:05:15 <chrisdone> reinh: excellent :3
13:05:28 <chrisdone> reinh: you could do an Outdoor Wee version of the haskellcast https://www.youtube.com/watch?v=qnqtCqb2IYw
13:07:26 <chrisdone> reinh: speaking of which, is there another planned?
13:11:15 <ReinH> chrisdone: oh my god
13:11:38 <ReinH> chrisdone: not for december but yes
13:11:41 <ReinH> holidays :(
13:11:46 <chrisdone> yay
13:12:12 <chrisdone> meanwhile i subsist on Dan Carlin's Hardcore History and Brian Cox's The Infinite Monkey Cage
13:13:37 <Hodapp> <3 Dan Carlin
13:13:40 <Hodapp> what's the latter one about there?
13:16:12 <chrisdone> hodapp: just a science popularization podcast. it's Brian Cox, Robin Ince as the hosts and they invite a few scientists or mathematicians on and at least one comedian, sometimes Allan Moore. it's a bit of fun =)
13:16:56 <jodaro> heh, that outdoor wee bit is pretty funny
13:18:34 <Twey> haskell-mode question: can I alter my C-c C-l binding so it loads the file into GHCi, then executes a command there?
13:19:19 <chrisdone> hodapp: e.g. https://www.youtube.com/watch?v=pU-w6G1ws9Q
13:19:33 <Iceland_jack> Twey: what command should be executed?
13:19:46 <chrisdone> twey: with inf-haskell, umm, maybe. with my mode, ja easy
13:20:22 <chrisdone> maybe something like
13:20:38 <Twey> I'd like to run ‘main’ after loading it in
13:21:28 <chrisdone> (progn (inferior-haskell-send-command (inferior-haskell-process) (concat ":load " (buffer-file-name)))
13:21:29 <chrisdone>        (inferior-haskell-send-command (inferior-haskell-process) ":main"))
13:22:10 <chrisdone> oh wait
13:22:16 <chrisdone> there's a function right here to do it
13:22:21 <chrisdone> inferior-haskell-load-and-run
13:22:30 <Twey> Ah, cool.  :þ
13:23:43 <codygman> I'm wanting to avoid cabal-hell. How should I install packages? Should I just use cabal-dev for every new project? Should I never use "cabal install"? How do you guys install packages?
13:24:43 <quchen> codygman: Sandboxes!
13:24:44 <startling> codygman: new cabal releases have cabal sandbox
13:25:24 <razieliyo> can I somehow purify ->  IO a?
13:25:44 <codygman> quchen, startling: Cool, what version has sandboxing? Hmm I guess I can look it up since I want to know more ;)
13:26:02 <Twey> razieliyo: What does that mean?
13:26:08 <Hodapp> chrisdone: thanks, I'll have to check that out!
13:26:11 <quchen> codygman: Since 1.18
13:26:17 <Hodapp> chrisdone: only science podcast I have so far is Star Talk with NDT
13:26:26 <quchen> Just run "cabal update && cabal install cabal-install" and you'll get it
13:26:45 <razieliyo> Twey: get rid of IO
13:27:20 <startling> razieliyo: you can run it in IO.
13:27:37 * hackagebot base-io-access 0.2.1.0 - The IO functions included in base delimited into small, composable classes  http://hackage.haskell.org/package/base-io-access-0.2.1.0 (bheklilr)
13:27:58 <codygman> So after using "cabal sandbox init" does it set some environmental variables or create a special directory? In the future, from that directory, will cabal install install to that sandbox?
13:28:09 <chrisdone> <codygman> I'm wanting to avoid cabal-hell
13:28:10 <razieliyo> the thing is that I'd like to get rid of "IO a" being the return of randRIO
13:28:12 <chrisdone> ho, ho, ho!
13:28:14 <startling> codygman: yep
13:28:26 <chrisdone> there are only two certain things in life. tax, and cabal hell
13:28:29 <quchen> codygman: You'll get a ".cabal" directory in your working dir
13:28:39 <quchen> (Or something like that)
13:28:44 <cmtptr> chrisdone, I avoid it by not using cabal
13:28:53 <geekosaur> razieliyo, you can't, learn to work with it instead of trying to work against it
13:28:56 <monochrom> razieliyo, I believe that no one knows what you mean. show actual code.
13:29:00 <codygman> chrisdone: LOL... fair enough.
13:29:13 <codygman> startling, quchen: Thanks
13:29:15 <chrisdone> cmtptr: makefiles?
13:29:18 <razieliyo> geekosaur: okay, that answers me, thanks!
13:29:21 <cmtptr> yep
13:29:30 <chrisdone> cmtptr: but then how do you install dependencies?
13:29:37 <chrisdone> manually?
13:29:38 <quchen> Manually.
13:29:40 <cmtptr> I don't
13:29:45 <chrisdone> lol
13:29:45 <Twey> razieliyo: You can throw it away: const () ∷ IO a → ()
13:29:58 <cmtptr> 1) I'm still learning haskell, 2) that's a job for my OS
13:30:04 <quchen> That's what I do, at least. I should switch my workflow to Cabal some day.
13:30:14 <geekosaur> razieliyo, you lift pure code into IO, you do not take things out of IO. most notably is the >>= operator which you can think of as registering a callback for when the IO action is run, which can see the pure value (but must produce something in IO)
13:30:17 <chrisdone> cmtptr: aww
13:30:22 * chrisdone pats cmtptr on head
13:30:45 <Twey> razieliyo: But if you're really asking how to ‘unwrap’ the value, then no, you can't.  An IO String ‘contains’ a string in the same sense that /bin/ls ‘contains’ a list of files, as the quote goes.  ☺
13:31:37 <Twey> cmtptr: Depending on your OS, your package manager might be able to do it.  The Gentoo Haskell overlay has a fairly large selection of packages.
13:31:50 <Clint> and debian and nixos
13:31:55 <razieliyo> geekosaur, Twey: thanks for your comments
13:32:26 <Twey> (I should really learn to use λb's quote functionality)
13:32:28 <cuci_> hi guys! I'm trying out haskell from fpcomplete and at some point they use the function Cons with no introduction. Any ideas what function is that? google just confuses it with :
13:32:45 <Iceland_jack> cuci_: It's some function they define themselves no doubt
13:32:51 <Iceland_jack>     data List a = Nil | Cons a (List a)
13:33:08 <Iceland_jack> or a value/data constructor
13:33:20 <startling> cuci_: yeah, it's nothing standard but probably what Iceland_jack says
13:33:29 <Twey> cuci_: If it has a capital C, it's probably another name for the list constructor (for a list type they've defined instead of the standard one, for pædagogic purposes).
13:33:47 <Twey> cuci_: Constructors always begin with a capital letter (or a : if they're operators).
13:33:58 * startling kicks Twey's aesc
13:34:24 <Twey> startling: Why would you do such a thing?  ☹
13:35:20 <cuci_> ok so if defined in another file in that directory it's available to any other files in that dir?
13:35:37 <Iceland_jack> cuci_: it has to be imported
13:35:54 <cuci_> I have not done that
13:36:47 <cuci_> I've written this file in the same directory: https://www.fpcomplete.com/clone-active-code/0YmJFBM1hN
13:36:53 <cuci_> if Cons imported?
13:37:27 <cuci_> s/if/is
13:37:38 * hackagebot base-io-access 0.2.2.0 - The IO functions included in base delimited into small, composable classes  http://hackage.haskell.org/package/base-io-access-0.2.2.0 (bheklilr)
13:40:28 <imYourBreda> evening all
13:40:40 <imYourBreda> is there reflection in Haskell?
13:40:50 <Twey> cuci_: Cons is in scope in Main, where it's defined.  Anywhere else you'll have to explicitly bring it into scope by saying ‘import Main’.
13:41:10 <startling> import Main isn't really a great idea
13:41:19 <imYourBreda> can i write a totally unsafe function which accepts any kind of type (like empty interface un Go)?
13:41:29 <imYourBreda> s/un/in
13:41:31 <chrisdone> @quote risk
13:41:31 <lambdabot> quicksilver says: #haskell : Sometimes we answer your question, sometimes we lay hideous traps which will devour your soul. It's a risk you take.
13:41:34 <Iceland_jack> imYourBreda: You can use Data.Dynamic but you probably don't want to
13:41:36 <startling> :t const 12 -- imYourBreda
13:41:37 <lambdabot> Num a => b -> a
13:41:48 <Twey> imYourBreda: You can write completely safe functions that accept any kind of type
13:41:50 <startling> (b is any type)
13:41:52 <Iceland_jack> imYourBreda: I may have misunderstood your question
13:42:10 <Iceland_jack> You can easily define functions that accept any type
13:42:14 <imYourBreda> So here is the problem I am trying to solve
13:42:17 <imYourBreda> i need json unmarshaling
13:42:19 <Twey> imYourBreda: Haskell has something called reflection, but it's not much like reflection from e.g. Java.
13:42:30 <imYourBreda> which can unmarshal into arbitrarily complex type
13:42:38 <geekosaur> have you looked at the aeson library?
13:42:43 <imYourBreda> like record in a record, containing list, containing records etc
13:42:48 <Twey> imYourBreda: A typeclass is the usual answer to that
13:43:00 <startling> imYourBreda, it would probably be better to use aeson's classes and the aeson TH helpers for that
13:43:07 <Twey> As Aeson does
13:45:07 <imYourBreda> thanks
13:45:17 <imYourBreda> this template haskell thingie looks so weird to me
13:45:29 <startling> imYourBreda: it's just a macro system for haskell.
13:45:30 <Twey> It looks that way to everybody.
13:45:34 <startling> heh.
13:46:02 <imYourBreda> its basically code generation, right?
13:46:07 <Twey> Yes
13:46:25 <startling> imYourBreda: yeah, compile-time code generation.
13:46:26 <imYourBreda> do we need it cause the type system is not perfect?
13:46:30 <Kron> it's basically what happens when a lisp facehugger manages to scree and leap and grab onto haskell's face
13:46:40 <startling> imYourBreda: it's helpful for deriving things you can't do safely at run-time
13:46:47 <imYourBreda> meh lisp
13:46:48 <Twey> imYourBreda: It's mostly just for convenience
13:46:49 <Kron> we need it to get rid of boilerplate and the like
13:46:53 <imYourBreda> enjoy your one type :P
13:47:07 <scriptor> there's more than one type in most lisps...
13:47:17 <Kron> I don't know any lisps with one type
13:47:17 <imYourBreda> enforced at compile time?
13:47:20 <Kron> yes
13:47:25 <imYourBreda> really?
13:47:27 <scriptor> typed racket?
13:47:31 <Kron> I used to program in common lisp with static type declarations
13:47:34 <scriptor> shen?
13:47:35 <Kron> it's just optional, that's all
13:47:38 <Kron> shen is incredible
13:47:41 <Twey> Kron: Someone actually uses them?  :þ
13:47:45 <Kron> yes?
13:47:51 <Kron> :P
13:47:57 <startling> Twey, this is #haskell, remember.
13:48:04 <Kron> you don't use them with large heterogenous lists or the like
13:48:05 <Twey> Fair point
13:48:09 <Kron> but otherwise it really doesn't hurt
13:48:16 <Kron> just tell the compiler what everything is
13:48:18 <Kron> and let it sort itself out
13:49:27 <Twey> Oh, I know they're alright, though optional typing is always going to hurt a bit.  I just think you're the first CL-user I've met who uses the type annotations without being forced to.  :þ
13:50:16 <Kron> I don't know how much people like Paul Graham here
13:50:28 <imYourBreda> I like him
13:50:44 <sipa> jaspervdj: did i just see you on tram 9? :)
13:50:44 <Kron> but basically a million years ago I read On Lisp and the one lesson I took away from it was that expressability comes easy in lisp, but you have to fight for efficiency and speed
13:50:46 <imYourBreda> though he is a bit fanboyish
13:50:59 <Kron> kind of the opposite of an imperative language like Java (which I used to use prior)
13:51:16 <Kron> so yeah, I used to code in lisp and do my very best to 'fight for speed' or whatever
13:51:25 <alevy> i'm getting strange behavior with setting GHC_PACKAGE_PATH where `ghc` doesn't seem to pick up on the system/user databases but ghc-pkg does. anybody see anything similar?
13:51:30 <imYourBreda> Kron: I don't know, you can never have enough types that's fo sho
13:51:33 <Kron> it wasn't quite the same reasons people here like type systems I think
13:51:38 <imYourBreda> my life is easier since I am dealing with static languages
13:51:43 <Kron> which is about security and programmer-programmer readability
13:52:35 <imYourBreda> Like the other day I had to debug some crappy php code I was crying for my mum. I feel blind when I look at a function in dynamic languages.
13:52:48 <Kron> right
13:53:02 <imYourBreda> Documentation kinda mitigates it but then why not document it at the type level
13:53:28 <Kron> there's... I think the word is 'idiom'? There's an idiom in the haskell community that type systems are meant for programmers as much as they are meant for compilers
13:53:38 <earthy> more.
13:53:43 <Kron> it's there like a very precise formulaic comment
13:53:50 <imYourBreda> Imperative programming destroys my soul. Every time i have to write a for loop something dies in me
13:53:51 <Kron> that has guaranteed consequences in the executable
13:54:49 <Kron> That isn't quite how I used to use lisp type declarations, I generally gave elaborate comment blocks before each function
13:54:49 <timthelion> imYourBreda: Yeah,  type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t is SOO much easier to understand than english language docs.
13:54:54 <Kron> the type declarations were for speed mostly
13:55:15 <Kron> timthelion: to be fair, you can use type synonyms
13:55:20 <Kron> something I abuse liberally
13:55:24 <imYourBreda> timthelion: there are exceptions but generally it is much better
13:55:26 <Kron> type Location = (Int, Int)
13:55:27 <Kron> etc.
13:56:03 <jaspervdj> sipa: Uh, if thats tram 9 in Zurich, yes :-/
13:56:07 <Kron> also, it helps to use this:
13:56:08 <Kron> ghci> :info Lens'
13:56:08 <Kron> type Lens' s a = Functor f => (a -> f a) -> s -> f s
13:56:13 <sipa> jaspervdj: yes :)
13:56:17 <edwardk> timthelion: yes, we have so many lens libraries in scheme and PHP =)
13:56:25 <timthelion> Kron: I like Elm's extensible records for that stuff. Then you can do: type location = {x:Int,y:Int}
13:56:35 <drexler> timthelion lens could wrap that up in an easier to understand type. the reason it doesn't is so that libraries can write their own lens without depending on the lens library
13:56:44 <Kron> isn't that haskell syntax too?
13:56:47 <drexler> lenses*
13:56:50 <Kron> well, not quite
13:57:03 <Kron> data Location = SomeConstructor { x :: Int, y :: Int }
13:57:13 <jaspervdj> sipa: Cool, I didn't see you though
13:57:15 <timthelion> Kron: that's far less convenient
13:57:15 <Iceland_jack> Kron: Elm's records are quite different
13:57:19 <chrisdone> twey: did you try structured-haskell-mode? =)
13:57:22 <jaspervdj> I wasn't wearing glasses which might account for it
13:57:32 <edwardk> drexler: actually the reason it doesn't is because if it did we'd have to write a couple hundred boilerplate conversions between things and you'd have even more horrible inference woes
13:57:45 <chrisdone> jaspervdj: have you tried a boosted board?
13:58:05 <sipa> jaspervdj: you must be close, i got off 2 stops further :)
13:58:06 <simpson> edwardk: Was there any magic to left-recursive things in parsers/trifecta, or do I just need to rewrite all my rules to not have any?
13:58:09 <edwardk> drexler: the 'exposed' structure of lenses is what lets you glue a traversal onto a lens, onto a prism onto a getter and get a fold.
13:58:21 <Kron> chrisdone: just to make this clear, is there a risk this will delete my emacs configuration?
13:58:23 <timthelion> edwardk: I think you should use whole words for your type variables rather than single letters. What does "s t a b" stand for?
13:58:25 <edwardk> simpson: the price of recursive descent is you need to manually eliminate left recursion
13:58:34 <simpson> edwardk: Alrighty! I can do that.
13:58:34 <drexler> edwardk I see, thanks for clarification
13:58:36 <imYourBreda> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t    <--- Holy shit I am so unused to this nowadays
13:58:40 <simpson> timthelion: "stab", of course.
13:58:46 <chrisdone> kron: no, that's a joke
13:58:50 <edwardk> s = source or state, a and b are to unify with the a and b in the type signature of traverse or fmap
13:58:52 <edwardk> :t traverse
13:58:53 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:58:53 <Kron> okay!
13:59:10 <chrisdone> kron: or am i joking now? >:)
13:59:16 <edwardk> t is the letter after s, some people use 'target' as a mnemonic for it
13:59:31 <edwardk> it used to just be 'a b c d' then shachaf talked me into letting him change to s t a b
13:59:57 <timthelion> edwardk: Why don't you write type Lense source transverse fmapBefore fmapAfter = ...
14:00:11 <edwardk> in general i do _not_ like using long variable names for unification variables though, their main purpose is for unification, figuring out what has to match up with what, and using long names makes it very easy to get names that almost match up but dont
14:00:42 <edwardk> timthelion: because if you typo one of those names its almost unfindable, if you make a typo on 's' its pretty easy to pattern match
14:00:52 <edwardk> the shorter names permit visual chunking easier as well
14:01:10 <timthelion> edwardk: emacs has autocompletion for preventing typos
14:01:44 <chrisdone> i don't mind the short letters as long as there's a mnemonic
14:01:50 <edwardk> also the type signatures stretch the edge of spanning a line as it is,  making them 8x longer with no more information content makes them no longer fit in my head
14:02:21 <Kron> hmmmm
14:02:22 <Kron> "structured-haskell-mode-0.0.0 depends on haskell-src-exts-1.14.0 which failed
14:02:23 <Kron> to install."
14:02:26 <chrisdone> although it would be fun if in a library you could specifiy mnemonics
14:02:31 <Kron> do I need some sort of haskell source?
14:02:41 <edwardk> i'm perfectly okay with using long names for data types, things that span long lifetimes in code, but i don't see that type variables meet that guideline
14:02:49 <chrisdone> kron: that version is on hackage
14:02:54 <chrisdone> kron: why did it fail?
14:03:03 <Kron> I'm trying to cabal install
14:03:10 <edwardk> the #haskell-lens folks like to tease me about my penchant for "alpha-reduction"
14:03:11 <Kron> and then it gives me this one final error message
14:03:16 <edwardk> so your mileage may vary
14:03:23 <Kron> cabal: Error: some packages failed to install:
14:03:23 <Kron> haskell-src-exts-1.14.0 failed during the configure step. The exception was:
14:03:23 <Kron> ExitFailure 1
14:03:23 <Kron> structured-haskell-mode-0.0.0 depends on haskell-src-exts-1.14.0 which failed
14:03:23 <Kron> to install.
14:03:30 <chrisdone> is there anything about happy/alex?
14:03:41 <Kron> hmmmm
14:03:41 <Kron> aha
14:03:44 <chrisdone> cabal tends not to bother installing or checking for binaries up front and leaves you to realise it
14:03:45 <Kron> "setup: The program happy version >=1.17 is required but it could not be found."
14:03:51 <chrisdone> cabal install happy alex
14:03:53 <Taneb> edwardk, I think it is possible to write Unbox instance for the various types in linear
14:03:56 <Kron> gotcha
14:04:04 <edwardk> Taneb: go for it
14:04:15 <edwardk> Taneb: should work fine
14:04:18 <hpc> you'll probably also want to copy the resulting binaries onto your path
14:04:29 <hpc> or at least add ~/.cabal/bin to your path
14:04:42 <Kron> ok
14:04:44 <Taneb> edwardk, I started but then stopped
14:05:06 <hpc> ("want" there may or may not be "need" btw)
14:05:23 <edwardk> Taneb: well, when you start up again, ill graciously accept a patch =)
14:05:36 <Taneb> :P
14:06:21 <Kron> I just installed happy and alex
14:06:25 <Kron> but it gives me the same error message
14:06:30 <chrisdone> edwardk: otoh, it shouldn't matter that much what type variables a library uses. your tool (e.g. haddock or ghci) should make it easy to display it how you want =)
14:06:41 <imYourBreda> do you find the fact the you can only catch an exception in the IO monad constraining?
14:06:47 <chrisdone> newbies could say "use source, target, from and to instead of s t a b"
14:07:03 <jaspervdj> sipa: Zurlindenstrasse
14:07:11 <imYourBreda> my other option is to juggle maybes or eithers?
14:07:12 <edwardk> chrisdone: i've given up on that pipedream, but hey, if it makes you happy to dream ;)
14:07:15 <Kron> hmmm
14:07:24 <chrisdone> edwardk: pipedream? how hard can it be?
14:07:34 <edwardk> chrisdone: hard enough that it isn't being done? =)
14:07:42 <chrisdone> edwardk: maybe nobody thought of it?
14:08:04 <edwardk> no its been something folks have ben talking abut afaict since the 70s
14:08:27 <Kron> chrisdone: any idea why it would give the same error message?
14:08:30 <edwardk> presenting code to the user in their chosen grammar/syntax/style, putting it in a neutral format for sharing, and restyling it as you want, etc.
14:08:32 <chrisdone> we must be talking about something very different if simply changing the names of unification variables is hard
14:08:55 <startling> Kron, are they in your PATH?
14:08:58 <chrisdone> hmm
14:08:59 <Kron> yes
14:09:04 <edwardk> changing variable names is the surface of a very deep well of problems
14:09:12 <Kron> wait hold up
14:09:34 <Kron> hah, my mistake
14:09:37 <Kron> "/.cabal/bin"
14:10:02 <chrisdone> edwardk: maybe. i tend to like wearing down the layers rather than trying to cut through in one go and failing
14:10:11 <edwardk> dave herman's thesis gave at least a type system for macros to permit hygienic variable reassignment http://www.ccs.neu.edu/home/dherman/ but even the system there shows a bit about how fraught with peril things get in the presence of macro systems
14:10:40 <augur> edwardk: so combinator chart parsers?
14:10:40 <joelteon> So does cabal use $HOME/.cabal for all its configuration stuff by default?
14:10:47 <edwardk> you get variable names you like in exchange for them being out of sync with habits established in the documentation. the abstraction leaks
14:11:03 <edwardk> augur: back to my earlier link to the bernardy paper?
14:11:21 <augur> edwardk: was that the one that talks about matrix parsing algos for CYK?
14:11:27 <edwardk> augur: yes
14:11:46 <augur> edwardk: i more or less get the gist of whats going on it it, sure
14:11:56 <edwardk> augur: combine it with my recent work on sparse morton ordered matrices to get a better sparse matrix rep
14:12:40 <edwardk> augur: then we can define a module homomorphism from the lexer to the parser that takes care of the first stage of lexing. nobody wants to be context free down to the char level.
14:13:20 <edwardk> i'll tackle context sensitivity when i have more time =)
14:13:28 <Kron> alright, I think it compiled! Just to make this clear: Do I need to load ~/.cabal/bin into the load-path of emacs as well?
14:13:28 <edwardk> gotta run
14:14:15 <chrisdone> kron: umm. try this: M-! happy --version
14:14:34 <chrisdone> kron: if it works, you're gold. if it doesn't, throw the computer out the window
14:14:35 <Kron> command not found, heh, okay
14:14:41 <chrisdone> hold up
14:14:46 <augur> edwardk: 0_0
14:15:15 <chrisdone> kron: try this (setenv "PATH" (shell-command-to-string "echo $PATH"))
14:16:23 <Kron> yeah it works
14:16:24 <Kron> awesome
14:16:33 <chrisdone> \o/
14:16:42 <chrisdone> kron: do you know paredit-mode?
14:17:16 <Kron> I used to use SLIME back in the day, not paredit
14:17:19 <Kron> I assume they're similar?
14:18:05 <chrisdone> slime is the backend to talk to the lisp implementation. paredit is a syntactical editing mode
14:18:31 <Kron> trying out your test suite
14:18:33 <Kron> or: Assertion failed: (string= (buffer-substring-no-properties (point-min) (point-max)) (plist-get test :end-buffer-content))
14:18:55 <chrisdone> kron: eh, don't worry about that. i'm still working out the kinks on the test suite
14:19:00 <Kron> gotcha
14:20:28 <Kron> why is the mode called "SHM?" :P
14:20:35 <chrisdone> kron: structured-haskell-mode
14:20:49 <chrisdone> is a bit too long to put in your modeline
14:20:56 <Kron> I mean the question mark
14:21:07 <chrisdone> oh, that means it hasn't parsed anything yet, so probably isn't working
14:21:30 <Kron> save-current-buffer: Searching for program: no such file or directory, structured-haskell-mode [2 times]
14:21:30 <chrisdone> it should say "SHM" once it's working
14:21:35 <chrisdone> D:
14:21:38 <Kron> it's been flashing me this
14:21:47 <chrisdone> is structured-haskell-mode in the PATH?
14:21:47 <Kron> when I try writing in a haskell file
14:21:57 <Kron> it should be, let me double check
14:22:10 <Athas> Can anyone recommend a good book on data-parallel programming?
14:22:51 <Kron> hmmm, I'm not sure if it's in the load-path
14:23:12 <chrisdone> kron: does structured-haskell-mode work in the terminal?
14:23:15 <donri> Athas: there's a chapter on repa in http://chimera.labs.oreilly.com/books/1230000000929
14:23:18 <quchen> Athas: Marlow's book has chapters on Repa and Acelerate
14:23:20 <quchen> +c
14:23:34 <quchen> I'm the Donri echo again haha
14:23:58 <Kron> If I do M-: structured-haskell-mode it just outputs t
14:24:16 <chrisdone> kron: in your terminal shell
14:24:23 <Athas> donri, quchen: thanks :-) but I'm interested in a more general treatment.
14:24:27 <Kron> kron@navi:~/Programming/Haskell/structured-haskell-mode/elisp$ structured-haskell-mode
14:24:27 <Kron> structured-haskell-mode: user error (Pattern match failure in do expression at src/Main.hs:31:3-14)
14:24:46 <Hodapp> good guy O'Reilly
14:24:50 <Hodapp> lets you read the ebook online
14:25:09 <Athas> Hodapp: whenever I read a free ebook, I always feel guilty and buy it.
14:25:13 <Athas> It's a pretty good sales strategy.
14:25:30 <chrisdone> kron: nevermind. the path in emacs isn't right. but you can configure the specific place. run which structured-haskell-mode in your terminal and put (setq shm-program-name "<the path>")
14:25:56 <Kron> gotcha
14:26:12 <chrisdone> athas: i donate to the author
14:26:12 <Hodapp> Athas: It works on me. I check out a little of the book, and I'll often buy it. It helps that O'Reilly has not been a dick to me in terms of how they handle ebooks.
14:26:34 <Hodapp> it's wonderful to get the books DRM-free and in nearly any format.
14:26:46 <Kron> okay
14:26:50 <Kron> it's not showing the question mark anymore
14:26:57 <Kron> hah
14:27:00 <Kron> it seems to be working :D
14:27:06 <chrisdone> kron: you should see a highlight over syntactical nodes
14:27:10 <Kron> what's the red zone? the quarantine font?
14:27:15 <Kron> yeah there's a grey zone and a red zone?
14:27:21 <chrisdone> yeah, that's the quarantine font
14:27:23 <Kron> it also properly C-js
14:27:35 <chrisdone> grey means "current node", red means "parse error, fix it"
14:27:56 <Kron> gotcha
14:27:59 <chrisdone> if the red is annoying,  you can just change the face and look in the modeline for "SHM!" when there's an error
14:28:27 <chrisdone> if you don't have a dark theme the current node grey is probably too dark. i'm using zenburn
14:30:15 <chrisdone> if i go to heaven and walk through the pearly gates and see god and he waves his arm at heaven and says "whaddayathink?" i'll look upon the splendour and infinite sparkling beauty and say “not bad. but i prefer zenburn”
14:30:39 <Ralith> hahaha
14:31:44 <Kron> I use a very dark theme, yeah
14:31:54 <Kron> it fits really well with my mode
14:32:00 <chrisdone> sweet =)
14:32:09 <donri> chrisdone: is there no standard way to get a color by semantic name like "visual mark" or "comment" and use that?
14:32:10 <Kron> though I'll probably tweak my haskell-mode to not include paren-matching
14:32:19 <Kron> I have a paren-matching grey font that's quite a lot like your current node font
14:32:24 <Kron> and current node does the same thing
14:32:38 <chrisdone> donri: not that i know of yet. i can't find a precedent for "current node"
14:32:52 <Kron> chrisdone: I think there is, but there's no real precedent for current node
14:32:54 <Kron> you'll need paren-match
14:33:04 <donri> chrisdone: yeah that's why i suggested reusing semantics from comments or marks :)
14:33:06 <Kron> from my .emacs ...
14:33:07 <Kron>  '(linum ((t (:inherit (shadow default) :foreground "dim gray"))))
14:33:07 <Kron>  '(show-paren-match ((t (:background "gray20")))))
14:33:08 <chrisdone> that sucks a bit because i use paren match separately
14:33:18 <Kron> I use gray20 as my paren-match
14:33:19 <chrisdone> my paren match is zenburn-green
14:33:52 <Kron> anyway
14:33:58 <Kron> chrisdone: I'll play with this later
14:34:02 <Kron> I need to go make myself some food
14:34:12 <Kron> I'll ping you with any bugs and eccentricities
14:34:22 <chrisdone> donri: i don't think that's a good idea
14:34:24 <chrisdone> kron: =)
14:34:47 <donri> better than hardcoding a color IMO but alright :)
14:35:01 <chrisdone> well, it's customizable
14:35:07 <chrisdone> like the ansi colors in the terminal
14:35:21 <chrisdone> they're bold red, blue, green, etc. by default
14:35:23 <Kron> I wanna make my quarantine orange
14:35:30 <Kron> I like orange, red is too harsh D:
14:35:40 <donri> chrisdone: do the colorthemes customize those?
14:36:14 <Kron> chrisdone: structured-haskell-mode has no M-x customize-group
14:36:23 <Kron> which isn't really necessary but it's a nice addition for easy customization
14:36:26 <tiffany> I don't like zenburn much
14:36:29 <tiffany> there isn't enough contrast
14:36:37 <Kron> same, I'm slightly more contrasty
14:36:50 <Kron> slightly darker background, though it's also slightly transparent so I can see my rotating wallpaper
14:36:58 * donri is the only programmer ever to like light-background colorthemes
14:37:08 <Kron> oh god does ANYONE like default emacs?
14:37:11 <Kron> that black on white?
14:37:12 <Rembane> donri: Which one is your favorite?
14:37:13 <Kron> it's horrifying
14:37:15 <tiffany> I've been using lucious for a while
14:37:18 <Rembane> Coding on paper ftw!
14:37:22 <donri> Rembane: depends and varies :P
14:37:26 <Rembane> donri: ^^
14:37:38 <Kron> y'know what else has a light-background colortheme, donri?
14:37:40 <Kron> notepad!
14:37:41 <Kron> D:<
14:37:43 <donri> Kron: default emacs and vim is horrid, yes
14:37:46 <monochrom> I use white for background in editors, black for background in terminals. I don't know why.
14:37:47 <tiffany> I used to use a light-coloured background
14:37:59 <Kron> lol
14:37:59 <tiffany> everything else on my system is light coloured
14:38:06 <Kron> monochrom: the irony of that style coming from someone called monochrom
14:38:08 <Kron> is just delicious
14:38:19 <donri> monochrom: i call that post-modern skeumorphism
14:38:26 <monochrom> actually, I know why. default syntax colours in editors seem to work better with white background
14:38:50 <Feuerbach> donri: which theme do you use for vim? Mine is 'github' right now (light background)
14:39:01 <chrisdone> sorry, i got d/c'd
14:39:13 <donri> Feuerbach: light solarized on this machine, which looks shit on the laptop where i instead use vylight currently
14:39:21 <monochrom> (therefore, I have to tell nano to not colourise, it's in a black background terminal. yes, some colours are really dark.)
14:40:18 <Feuerbach> I tried solarized, but didn't like it for the editor. It's still my terminal theme, but partly just of laziness to change it back
14:40:28 <donri> in emacs i currently use espresso (yes i use both vim and emacs! ;))
14:40:31 <chrisdone> donri: yeah, color themes customize faces. i think having my own face is the proper thing to do here. each mode has its own set of faces if the faces are something new
14:40:50 <donri> chrisdone: alright; i thought it was a hardcoded RGB
14:41:22 <monochrom> "Tony" has many faces too in The Imaginarium of Dr Parnassus :)
14:41:26 <chrisdone> kron: the group is shm
14:41:43 <chrisdone> kron: (maybe it should be structured-haskell-mode)
14:41:45 <donri> Feuerbach: yeah one of my reasons for using solarized is ubuiquity; i have it in vim, the terminal, the irc client, even some browser userstyles :P
14:41:45 <Kron> ahhh
14:41:56 <donri> ubiquity*
14:41:57 <chrisdone> part of the haskell group
14:43:46 <donri> monochrom: great flick
14:43:49 <chrisdone> i don't mind default emacs. i like the purple =p
14:43:53 <donri> monochrom: (i take it you know the why of the many faces?)
14:44:05 <chrisdone> it's fabulous =p
14:44:08 <monochrom> I don't think I know
14:44:20 <donri> chrisdone: i think default emacs is better than default gvim, although haven't really thought about it...
14:44:50 <chrisdone> use of red for comments is a bit sucky, though
14:45:04 <Kron> I quite like orangey brown
14:45:23 <donri> monochrom: well ledger died before finishing every scene
14:45:54 <monochrom> that fact I know, but just not sure whether that is the key cause
14:46:42 <donri> monochrom: it is. they rewrote the script to include this in the plot and his friends pitched in to make the final scenes. works because that's the kind of movie it was anyway :P
14:48:16 <donri> chrisdone: incidentally i've been meaning to turn your lpaste colors into a vim colorscheme ;)
14:48:25 <chrisdone> :D
14:48:51 <chrisdone> lpaste's lack of color, anyway =p
14:49:07 <donri> yeah it might not work well for "real work". but it's purdy
14:49:32 <chrisdone> i was thinking of doing one for emacs too
14:50:00 <donri> and i like subtle syntax highlighting anyway
14:50:19 <donri> makes code read more like text and less like a children's coloring book
14:50:37 <chrisdone> yeah =)
14:50:51 <monochrom> then you should apply a black-and-white filter to LYAH :)
14:51:07 <donri> ;)
14:51:13 <ion> Is there something wrong with children’s coloring books?
14:51:36 <chrisdone> ion: they're for children
14:51:36 <donri> the cute pictures in LYAH are there to comfort you the way they always ask if the victim in movies wants a blanket
14:51:57 <monochrom> yes, I don't know what colour to put where
14:51:58 <chrisdone> yeah, LYAH's color theme is unusable outside of the book. i tried it
14:52:31 <donri> i prefer parent's coloring of children's drawings :) http://imgur.com/a/WD4uy
14:52:45 <chrisdone> haha
14:53:00 <monochrom> and I don't like the unsaid rule "you are supposed to add your own drawings, not just colour the given drawing"
14:53:41 <monochrom> conclusion: children's colouring books are the antithesis to programming by design and derivation
14:54:30 <khyperia> @hoogle imap
14:54:30 <chrisdone> i always drew stuff ontop of colouring books
14:54:30 <lambdabot> package imapget
14:54:31 <lambdabot> package bimap
14:54:31 <lambdabot> package multimap
14:55:02 <chrisdone> donri: it's a new artform
14:56:37 <benzrf> ok is the basic idea of monad transformers that the type constructor for one is parameterized with an existing monad, then the monadic value contains another monadic value that is itself bound after applying the binding for the transformer?
14:58:18 <monochrom> yes for the first part, no understand for the second part
14:58:44 <AshyIsMe> random question, does anyone know of a typing suggestions system for osx/windows ?
14:59:09 <AshyIsMe> im wonedring why we can have pretty amazing word suggestions on touch screen tablet keyboards but that it isn't integrated into the desktop os' aswell
14:59:50 <benzrf> what does ~ signify
14:59:56 <donri> benzrf: type equality
14:59:59 <monochrom> depends on context
15:00:00 <benzrf> ahihi:
15:00:00 <benzrf> *ah
15:00:15 <donri> it can also signify a lazy pattern
15:02:16 <ahihi> benzrf: you highlight me a lot!
15:02:34 <benzrf> ahihi: sorry
15:02:36 <benzrf> :[
15:05:31 <ahihi> benzrf: it's not a big deal :P I just find it odd, does your client have some kind of overly eager auto-completion mechanism or something?
15:06:10 <donri> i think benzrf has an overly eager tab-hitting finger
15:08:00 <chrisdone> or a keyboard cat
15:09:20 <benzrf> ok so im trying to implement something like a monad transformer as an experiment
15:09:27 <benzrf> I have:
15:09:27 <benzrf> data MaybeT m a = JustT (m a) | NothingT deriving (Show, Eq)
15:09:36 <benzrf> this passes fine
15:09:54 <benzrf> if I try to do this:
15:09:55 <benzrf> instance (Monad s) => Monad (MaybeT s) where (JustT v) >>= f = JustT $ v >>= f; NothingT >>= _ = NothingT
15:10:00 <benzrf> I get
15:10:00 <benzrf>     Could not deduce (s ~ MaybeT s)
15:10:05 <benzrf> ?!
15:10:05 <lambdabot> Maybe you meant: v @ ? .
15:10:19 <shachaf> That's just an ordinary type error.
15:10:31 <benzrf> i dont see what's wrong tho
15:10:48 <shachaf> @paste the full error
15:10:48 <lambdabot> Haskell pastebin: http://lpaste.net/
15:11:05 <S11001001> benzrf: in the v arg to >>= in the JustT case, what's v's type?
15:11:13 <shachaf> (I see what's wrong but I bet GHC was giving you information you didn't give us.)
15:11:37 <benzrf> S11001001: Monad s => s a, right?
15:11:52 <quchen> I think your transformer type is the wrong way round anyway: what you're encoding is `Maybe (m a)`, not `m (Maybe a)`.
15:11:52 <S11001001> benzrf: right.  So, in the expression (v >>= blah), what is the type of blah required to be?
15:11:56 <chrisdone> the Amelie soundtrack makes for uplifting hacking music =)
15:12:12 <benzrf> a -> s a?
15:12:17 <S11001001> a -> s b, but close enough
15:12:19 <benzrf> ohhh
15:12:21 <benzrf> i feel silly
15:12:26 <benzrf> >_>
15:12:26 <S11001001> good :)
15:12:40 <benzrf> git dang type systems
15:12:53 <levi> I saw Amelie, but I can't recall what the soundtrack sounds like.
15:13:16 <monochrom> the type system is right to reject this one. it is a brain fart.
15:13:17 <chrisdone> levi: =o it wouldn't be the same without the soundtrack!
15:13:35 <chrisdone> levi: http://grooveshark.com/#!/album/Amelie+Soundtrack/206248
15:13:36 <benzrf> monochrom: i know
15:13:42 <levi> Well, I saw it with the soundtrack, it's just been a really long time!
15:14:03 <shachaf> This is off-topic.
15:14:52 <chrisdone> No talking to eachother like humans!
15:15:11 <benzrf> ok, so are monad transformer type constructors not instances of monad?
15:15:36 <quchen> benzrf: Types can be monads, type constructors can't.
15:15:39 <S11001001> benzrf: it doesn't matter.  You can't change monad between the two arguments to >>=.
15:15:41 <monochrom> no. instead, it is "instance Monad m => Monad (MaybeT m)"
15:15:42 <shachaf> quchen: What?
15:15:46 <benzrf> S11001001: i know
15:15:56 <quchen> shachaf: Well "Just" is a type constructor, but it's not a monad.
15:16:02 <benzrf> monochrom: that's what im trying to do
15:16:06 <monochrom> Just is not even a type constructor
15:16:09 <quchen> Eh
15:16:10 <quchen> Oh.
15:16:12 <shachaf> Yes. But "Maybe" is a type constructor, and a monad. Just is neither.
15:16:16 <quchen> Talk about brainfarts.
15:16:21 <quchen> Pardon the interruption.
15:16:23 <benzrf> monochrom: but in that case, how do I delegate to the submonad?
15:16:42 <S11001001> it is extremely likely that you're just seeing that it's impossible to write a correct Monad for your MaybeT formulation
15:16:45 <quchen> My brain yelled "DATA" and I complied.
15:16:47 <benzrf> hmm, ok
15:17:03 <benzrf> :i StateT
15:17:07 <S11001001> you can't get the "maybeness" out of the bind
15:17:11 <benzrf> right
15:17:17 <S11001001> because s will only sequence s-actions
15:17:22 <benzrf> i know :p
15:17:44 <S11001001> if s was also Traversable you could do it, but this is almost certainly not what you want
15:18:14 <monochrom> I am not even convinced that it is doable. that is, I am not convinced that "data MaybeT m a = JustT (m a) | NothingT" is a monad.
15:18:32 <benzrf> yeah
15:18:35 <benzrf> that seems right :i
15:19:30 <benzrf> what other stdlib monads are T's over Identity besides State?
15:19:48 <monochrom> you are probably mistaken to think that monad transformers are always just wrappers. they are not. look at StateT s m a = s -> m (a, s). it is not just a wrapper over m a.
15:21:03 <benzrf> ah, writer
15:21:25 <quchen> Reader and Cont too, probably
15:21:32 <quchen> Parsec
15:21:43 <monochrom> in fact, it is neither a wrap around m a nor letting m wrap around s->(a,s). it is a non-trivial interaction.
15:22:00 <shachaf> monochrom: like, adjunctions and stuff, y'know?
15:22:21 <shachaf> (s ->) . m . (s,)
15:22:35 <mgsloan> Oh yeah, the amelie soundtrack is excellent.  Yann Tiersen, yo!
15:22:43 <benzrf> :[
15:22:51 <benzrf> god damn im confused
15:23:13 <monochrom> all confusions are caused by wrong assumptions
15:23:23 <benzrf> ;_;
15:23:49 <monochrom> in this case, your wrong assumption is "just because the type level is a wrapper, therefore the value level is also a wrapper"
15:24:10 <monochrom> the world isn't that simple.
15:24:57 <benzrf> why are you being so hurtful
15:25:15 <benzrf> jk, jk
15:25:23 <shachaf> I enjoy the Amélie sound track also. But not in this channel.
15:25:52 <monochrom> I am only truthful. some truths hurt.
15:26:09 <monochrom> in fact, sometimes I am only tautological.
15:26:22 <mgsloan> :D
15:27:04 <shachaf> monochrom is wise.
15:30:50 <Lindrian> How would I write this in point free style: f x y = (5 + x) / y ?
15:31:27 <benzrf> @pl f x y = (5 + x) / y
15:31:27 <lambdabot> f = (/) . (5 +)
15:32:00 <benzrf> Lindrian: why do you want tomboy64 ?
15:32:05 <benzrf> *yp
15:32:07 <benzrf> *to
15:32:11 <Lindrian> wat
15:32:17 <benzrf> *why do you want to
15:32:29 <Lindrian> im trying to learn for my exam
15:33:18 <Lindrian> @pl g x y = x y
15:33:18 <lambdabot> g = id
15:33:20 <Lindrian> cool
15:33:22 <Lindrian> i got that one right
15:33:25 <AshyIsMe> is there something like zip that will pad the shorter list so nothing is missed from the longer list?
15:33:39 <Twey> AshyIsMe: Pad it with what?
15:33:53 <AshyIsMe> that could be an argument
15:33:56 <startling> Hm, I wonder if that's a legal Applicative.
15:33:58 <AshyIsMe> Nothing maybe
15:34:11 <Twey> > zip ([1, 2, 3] ++ repeat 0) ['a', 'b', 'c', 'd']
15:34:12 <lambdabot>  [(1,'a'),(2,'b'),(3,'c'),(0,'d')]
15:34:29 <startling> newtype PadList a = PadList (a -> [a]);
15:34:30 <Twey> Only works if you know which list is the longer, of course
15:34:39 <AshyIsMe> ah yeap, cool
15:35:36 <Twey> Lindrian: You're taking an exam on point-free functions?
15:37:00 <Lindrian> im taking an exam on haskell and point free is a standard question
15:37:07 <Lindrian> we're asked to turn two functions into point free style
15:37:20 <ReinH> o_O
15:37:38 <ReinH> Twey: just do it to both lists :p
15:37:42 <monochrom> good exam questions are hard to fine
15:37:53 <Twey> ReinH: Haha
15:37:53 <monochrom> s/fine/find/
15:38:03 <Twey> Aye
15:38:03 <startling> unpl-ing them would be a better question, I think.
15:38:28 <Zekka> startling - Can't you just find the corresponding number of args and add them to both sides?
15:38:38 <startling> Zekka: I don't know what you mean.
15:38:46 <Twey> ‘Given this function in Monad, write an equivalent function using only Applicative.’
15:38:52 <Lindrian> @pl f x y = 3 + y/x
15:38:52 <lambdabot> f = ((3 +) .) . flip (/)
15:39:06 <Zekka> Well, with f x y = (5 + x) / y, you get f = (/) . (5 +), right?
15:39:07 <Lindrian> hmm, my solution was f = flip ((/) . (3+))
15:39:11 <startling> oh, my PadList isn't a Functor
15:39:11 <Lindrian> is mine wrong?
15:39:39 <Zekka> Can't you solve any problem of that type by figuring out what type they want and adding the right number of arguments to both sides -- i. e. f x y = ((/) . (5 +)) x y?
15:39:41 <monochrom> expand flip ((/) . (3+)) x y to find out
15:39:47 <ReinH> :t flip ((/) . (3+))
15:39:48 <lambdabot> Fractional c => c -> c -> c
15:40:21 <startling> what's the Functor-like thing where you xmap :: (a -> b) -> (b -> a) -> f a -> f b
15:40:22 <Twey> Zekka: This is called ‘η-expansion’
15:40:24 <startling> ?
15:40:32 <ReinH> Lindrian: there is often more than one way to skin/pointfree a cat/function
15:40:41 <Zekka> TWey - Googling.
15:40:42 <monochrom> startling: is that profunctor?
15:40:46 <Lindrian> ReinH: right, but i feel as if mine should be correct
15:40:47 <startling> monochrom: no
15:40:52 <startling> monochrom: profunctor is higher-kinded
15:40:57 <FireFly> I don't think it is, Lindrian
15:40:58 <monochrom> I see
15:40:59 <Twey> Zekka: (you're right, I just thought you'd like to know the name for it :þ)
15:41:12 <FireFly> > flip ((/) . (3+)) 4 5
15:41:13 <lambdabot>  2.0
15:41:13 <Zekka> Does it entail anything aside from that?
15:41:41 <Twey> Zekka: Any function f is equivalent to the function (\x → f x)
15:41:44 <ReinH> bifunctor?
15:41:51 <startling> ReinH: nope.
15:41:53 <Twey> It's not a bifunctor
15:42:06 <FireFly> Lindrian: expand the function applications one at a time and you'll see why
15:42:09 <Twey> It's kind of like a pro(?)functor, but I don't know of one where the two types are the same
15:42:09 <startling> it's a contravariant functor and a regular one at the same time (?)
15:42:17 <Lindrian> what does that mean FireFly?
15:42:19 <ReinH> Ah.
15:42:28 <supki> @hackage invariant
15:42:28 <Zekka> Twey - Is expanding a function a correct way to take it out of point-free form, or is there something I don't know about point-free functions?
15:42:28 <lambdabot> http://hackage.haskell.org/package/invariant
15:42:32 <supki> startling: ^
15:42:34 <Zekka> expanding a function that way a correct way*
15:42:37 <startling> supki: aha
15:42:49 <FireFly> flip ((/) . (3+)) x y = ((/) . (3+)) y x = ...
15:42:55 <Zekka> I mean, it's a cheaty way, but if you were an instructor would you give points for correctness?
15:43:05 <Twey> Zekka: I would say so, yes
15:43:41 <FireFly> Zekka: I guess a good "unpl" question would specify that the result must not contain any uses of (.), say
15:43:48 <ReinH> :t flip (const fmap)
15:43:49 <lambdabot> Functor f => (a1 -> b) -> a -> f a1 -> f b
15:44:11 <Twey> Unless there's some way to define a normal form that captures the obvious intuition
15:44:11 <FireFly> (though I bet someone snarky would just work around that by replacing them with (\f g x -> f (g x)) everywhere..
15:44:12 <Zekka> What about uses of 'let b f g x = f (g x) in'?
15:44:50 <Twey> (which would obviously have to be part of the question definition
15:44:52 <Twey> )
15:45:07 <startling> are there invariant applicative functors?
15:45:21 <Lindrian> @pl g x y = [ y z | z <- [1..x] ]
15:45:21 <lambdabot> g = flip flip [] . ((:) .) . flip ((<-) . (| z) . ($ z)) . enumFromTo 1
15:45:25 <Lindrian> my eyes
15:45:29 <S11001001> FireFly: replace with fmap :)
15:45:29 <Lindrian> it burns
15:46:13 <FireFly> Lindrian: I hope the exam isn't asking you to rewrite that in points-free style :|
15:46:19 <Lindrian> it is
15:46:26 <Zekka> I'm so sorry.
15:46:28 <ReinH> o_O
15:46:31 <FireFly> whyy
15:46:32 <ReinH> what kind of exam is this
15:47:09 <Lindrian> final course exam
15:47:09 <Zekka> I always got the impression that points-free style was pretty pointless in the long run
15:47:16 <monochrom> g x y = map y [1..x], no? = map y (enumFromTo 1 x), no? and then you know how to continue.
15:47:24 <Zekka> But it's weird since whenever I write a function in points-free style it has more points in it than I started with
15:47:36 <Lindrian> no lambda, enum or list comprehensions allowed
15:47:42 <ReinH> Zekka: it can be a very expressive style, but arbitrarily making things point-free is not always going to improve them.
15:47:49 <Zekka> I think you missed my puns.
15:48:13 <ReinH> Zekka: the . are not the points :p
15:48:28 <Twey> g = flip map . enumFromTo 1
15:48:36 <Twey> It's not so bad.
15:49:01 <monochrom> "f . g" in Haskell is written "f o g" in SML, and then you get no point, no punct, and no pun
15:49:14 <monochrom> it is punfree style
15:49:27 <Lindrian> Twey: no enum
15:49:31 <codygman> So I understand how the code: sum . filter even $ [1..4] works, but then when I look at the type of (.) I don't get it
15:49:33 <codygman> :t (.)
15:49:34 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:49:38 <Twey> Lindrian: Sorry?
15:49:41 <ReinH> Lindrian: what?
15:49:48 <Lindrian> Twey: the exam stated i could not use enum
15:49:56 <ReinH> Lindrian: the exam is stupid.
15:50:03 <Twey> I don't know what that means
15:50:09 <quchen> Haskell exam. 1.: don't use Haskell
15:50:11 <startling> :t enum
15:50:12 <lambdabot> (Enum a, Functor f, Profunctor p) => p a (f a) -> p Int (f Int)
15:50:13 <Lindrian> tell that to my teacher
15:50:18 <Twey> enumFromTo is not enum
15:50:19 <Zekka> Codygman - . takes a thing of bs to cs and a thing of as to bs, and gives you a thing of as to cs
15:50:24 <monochrom> no no, all of you misunderstand. "don't use enum" simply means "don't use the [1..x] notation".
15:50:35 <Zekka> Sum is a thing of lists of numbers to numbers, and filter even is a thing of lists of numbers to lists of numbers
15:50:46 <Lindrian> dont use lambda-expressions, list comprehensions or enumeration
15:50:48 <Twey> And it's the translation of [1 .. x]; the only way to do without it is to write it yourself
15:50:48 <Lindrian> thats what it says
15:50:57 <Zekka> So sum . filter even is a thing of lists of numbers to numbers
15:51:03 <Zekka> and [1..4], of course, is a list of numbers
15:51:04 <Twey> I suspect ‘enumeration’ means expressions like [1 .. x] here.
15:51:06 <Zekka> Does that help?
15:51:14 <monochrom> don't attribute to teacher error what can be attributed to student error
15:51:42 <startling> student error is teacher error. :)
15:52:35 <monochrom> my experience from #math etc taught me: students always misinterpret and misrepresent teachers.
15:53:04 <ReinH> monochrom: http://en.wikipedia.org/wiki/Wiio's_laws
15:53:15 <Twey> Heh, indeed
15:53:19 <monochrom> it's why I always asked: where can I read the original verbatim question?
15:53:36 <ReinH> "If a message can be interpreted in several ways, it will be interpreted in a manner that maximizes the damage."
15:54:06 <Lindrian> i looked at the solution, f = curry $ (3.0+) . (uncurry  $ flip (/))
15:54:12 <Lindrian> oh wait
15:54:14 <Lindrian> wrong answer.-
15:54:19 <Lindrian> g1 = flip map . (flip take $ iterate (+1) 1)
15:54:20 <Lindrian> there
15:54:31 <ReinH> o_O
15:54:31 <quchen> ReinH: A great example of the second law.
15:54:40 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #10 :)
15:54:42 <Twey> Heh.
15:54:45 <Lindrian> that should be equal to g x y = [y z | z <- [1..x]]
15:55:54 <Lindrian> ugh im gonna fail this exam.
15:56:24 <ReinH> monochrom: yep :)
15:57:02 <ReinH> I don't understand the purpose of ad-hoc pointfree exercises. What is supposed to be taught by this?
15:57:17 <Lindrian> there is a bunch of questions that ask me to provide the type for stuff like (.)(:), (:(.)) etc. How should think when trying to solve these?
15:57:41 <startling> Lindrian, get your teacher on the line plz
15:57:53 <ReinH> I would probably think about opening ghci
15:57:53 <monochrom> I am not even convinced that homework and exams have teaching as a purpose. the main purpose is to attain a high variance in marks.
15:58:14 <Zekka> I'd probably ask GHCi to find the type first, and then see if I can work it out
15:58:17 <startling> Lindrian, (:) = (.) . (.), right?
15:58:20 <johnw> Lindrian: rewrite things like (:(.)) with points.
15:58:24 <ReinH> and then I would probably think about using :t
15:58:34 <startling> Lindrian, then (.) (:) = (.) $ (.) . (.)
15:58:46 <ReinH> startling: probably not? That's usually (.:)?
15:58:47 <monochrom> most schools have policies discouraging "all students get pretty much the same mark"
15:58:54 <startling> ReinH: oh hahahaha
15:58:58 * startling o.o
15:59:03 <ReinH> I suspect (:) is... (:)? ;)
15:59:17 <Lindrian> johnw: i feel as if i should know this by now, but what does it mean to rewrite with points?
15:59:27 <startling> Lindrian, as a lambda with parameters
15:59:32 <ReinH> Lindrian: eta expansion: f => \x -> f x
15:59:39 <Lindrian> aha
15:59:54 <ReinH> and also
16:00:01 <ReinH> :t (.)(:)
16:00:01 <lambdabot> (a -> b) -> a -> [b] -> [b]
16:00:35 <Lindrian> this is hard
16:00:42 <Lindrian> and it feels very pointless
16:00:48 <ReinH> that's because it is
16:00:52 <ReinH> in both meanings
16:01:51 <FireFly> It isn't for nothing that points-free style is sometimes called "pointless style"
16:02:05 <Lindrian> i dont know where to start when it comes to writing those expressions with points
16:02:19 <startling> Lindrian: ok, let's walk through (.) (:)
16:02:21 <Twey> Lindrian: Stick variables on the end.  Apply the functions.
16:02:31 <Zekka> Well, first figure out how many arguments they want you to give it
16:02:38 <Zekka> For (.)(:) you can get up to three so let's do that
16:02:39 <startling> Lindrian, (.) (:) = \f -> (:) . f
16:02:49 <Zekka> \x y z -> (.) (:) x y z per eta reduction
16:03:09 <startling> Lindrian, \f -> (:) . f = \f a -> (:) (f a)
16:03:23 <startling> Lindrian, \f a b -> f a : b
16:03:26 <Twey> Zekka: That seems like a bad idea.  One at a time should be easier.
16:03:43 <Zekka> Really? Both seem about as simple to me
16:03:55 <startling> > (.) (:) (+ 1) 0 []
16:03:56 <lambdabot>  [1]
16:04:15 <Zekka> If you're going to actually use the definitions of the functions to simplify further I guess that's fine too.
16:04:17 <ReinH> startling: maybe sliiiiightly better to call that one \f a bs -> f a : bs
16:04:20 <Twey> Zekka: Your approach require the ability to look at the function and guess how many arguments it's supposed to take, which is not always a simple task even for someone proficient in Haskell
16:04:25 <startling> ReinH: fair enough
16:04:31 <Twey> requires**
16:04:37 <Zekka> Twey - Since when are functions supposed to take a certain number of arguments?
16:04:47 <Lindrian> hm who should i be listening to here?
16:04:50 <Twey> Zekka: That is one of the reasons it's difficult ☺
16:04:52 <Hodapp> FireFly: So J is not your favorite language?
16:04:54 <Zekka> You can make them take from none to the number of arrows at the top-level of the type signature.
16:04:54 <ReinH> Lindrian: everyone at the same time
16:04:56 <monochrom> since I came here and decreed it
16:05:07 <Zekka> I'm assuming if the instructor doesn't tell you then you've got free reign
16:05:12 <FireFly> Hodapp: ..it's actually a language I enjoy
16:05:25 <ReinH> Er. Functions (excluding nullary ones, a.k.a. constants) always take exactly one argument.
16:05:29 <Hodapp> FireFly: I've yet to learn it, but it looks interesting.
16:05:33 <FireFly> Hodapp: ...and trains is probably one of my favourite parts of it
16:05:36 <Lindrian> startling: could you explain this transformation  (.) (:) = \f -> (:) . f
16:05:38 <Hodapp> trains?
16:05:39 <Zekka> ReinH - Yeah, but it's a useful convenience to say they take more than one
16:05:46 <Lindrian> oh i misread
16:05:47 <Lindrian> nevermind
16:05:48 <FireFly> (which is one of its main facilities for tacit programming, i.e. points-free style)
16:05:51 <shachaf> ReinH: You're undermining yourself with those parentheses.
16:05:58 <startling> Lindrian: it's switching (.) to infix notation
16:06:01 <ReinH> Zekka: I think it's a confusing inaccuracy
16:06:02 <Lindrian> yeah
16:06:05 <Lindrian> i just realized
16:06:19 <startling> Lindrian, you could interpolate a step by saying (.) (:) = ((:) .)
16:06:27 <Lindrian> yeah
16:06:29 <Zekka> In which cases is it confusing? (Legitimate question, not sarcasm)
16:06:50 <ReinH> shachaf: what I'm saying is equavelent to "functions take exactly zero or one argument"
16:07:11 <ReinH> Zekka: it's confusing when someone says to "figure out how many arguments a function takes", for instance.
16:07:26 <FireFly> Hodapp: basically, it gives meaning to juxtaposition of first-order functions (since it can't be application in that case) in a way that is useful for avoiding explicit variables
16:07:33 <ReinH> shachaf: or, "functions that do not take zero arguments take one argument"
16:07:35 <shachaf> ReinH: Yes, and that's confusing and not correct from almost any perspective I can think of.
16:07:38 <Zekka> Yeah, that's a point. It's more correct to say 'figure out how many arguments appear in the definition'
16:07:45 <johnw> Lindrian: (.) can be rewritten with points as \x y -> x . y
16:07:51 <ReinH> shachaf: Do I need to qualify that with "functions in Haskell"?
16:07:58 <Zekka> Which is what I was trying to get at, most likely, if I misspoke along those lines
16:08:07 <shachaf> Oh, were you talking about some other kind of function?
16:08:09 <Hodapp> FireFly: I suppose I'd have to use the language to grasp what you mean.
16:08:17 <sipa> how many arguments does (id) take?
16:08:32 <monochrom> @quote monochrom 17-ary
16:08:32 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
16:08:33 <hpc> sipa: as many as you want!
16:08:34 <shachaf> In Haskell "a function takes exactly one argument" is correct. "a function takes at most one argument" is just weird.
16:08:39 <ReinH> shachaf: so far you've said that I'm confusing and not correct both for saying that functions take one argument and for saying that there is partial application.
16:08:43 <sipa> hpc: yup :P
16:08:46 <ReinH> shachaf: This seems incompatible.
16:08:46 <Hodapp> monochrom: oh my god, that is such an awful pun.
16:08:57 <hpc> sipa: just like fmap, (.), and (+)
16:08:58 <monochrom> then again maybe not many people watched The Sound of Music
16:09:05 <shachaf> ReinH: No. I like "a functions has exactly one argument".
16:09:26 <ReinH> shachaf: so you don't consider nullary functions to be a thing.
16:09:27 <shachaf> But "nullary ones" makes no sense in that context.
16:09:29 <ReinH> Ok.
16:09:29 <Hodapp> monochrom: I helped out with a production of it. It's burned permanently into my soul.
16:09:40 <monochrom> oh good :)
16:10:07 <sipa> do { a; [ deer, female deer ] }
16:10:42 <sipa> or something
16:10:42 <shachaf> @google everything is a function in haskell
16:10:44 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
16:10:45 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
16:10:58 <Lindrian> startling: how should I go about for (:(.)) which I think is invalid?
16:11:13 <startling> Lindrian, it isn't!
16:11:18 <startling> :t (.) : (.)
16:11:19 <lambdabot>     Couldn't match expected type `[(b0 -> c0)
16:11:19 <lambdabot>                                    -> (a0 -> b0) -> a0 -> c0]'
16:11:19 <lambdabot>                 with actual type `(b1 -> c1) -> (a1 -> b1) -> a1 -> c1'
16:11:21 <Iceland_jack> > do { "a"; [ "deer", "female deer" ] }
16:11:22 <lambdabot>  ["deer","female deer"]
16:11:31 <startling> Lindrian: oh, yes it is. :)
16:11:36 <Lindrian> :p
16:11:37 <ReinH> shachaf: I'm reading that right now actually.
16:11:38 <startling> :t (:)
16:11:39 <lambdabot> a -> [a] -> [a]
16:11:43 <Zekka> I'm obliged to make the cheaty response to "everything is a function" and say "Are modules functions?"
16:11:50 <startling> Lindrian: (.) does not have type [a] for any a
16:11:55 <Iceland_jack> Zekka: Well comments definitely are
16:12:03 <shachaf> Zekka: The post's answer to the question is "no".
16:12:06 <Zekka> Iceland - How? Can you clarify?
16:12:11 <Zekka> shachaf - Yeah, I figured as much
16:12:22 <mgsloan> Zekka: If not for typeclasses, they probably could be
16:12:23 <Zekka> But I've run into the same statement from people who believe the answer is 'yes'
16:12:27 <staykov> hey, im following this guide http://jonathan.tang.name/files/scheme_in_48/tutorial/firststeps.html
16:12:35 * shachaf sighs
16:12:40 <Lindrian> startling: how would the expression be expanded?
16:12:41 <Zekka> I have a feeling I've unintentionally stepped into some interesting territory
16:12:43 <ReinH> shachaf: Ok, so functions are things with an (->). Makes sense.
16:12:44 <Iceland_jack> Zekka: They have type ∷ Code → Code where the output is the initial Haskell code with everything following them stripped out, a bit like ‘flip const’ (no I'm kidding)
16:12:45 <Zekka> ANyway, reading the post
16:13:06 <staykov> for some reason i cant get the first program to compile, the error that i get is "The last statement in a 'do' block must be an expression"
16:13:24 <monochrom> sipa, you should see my http://www.mail-archive.com/haskell-cafe@haskell.org/msg92742.html
16:13:28 <staykov> using ghc 7.6.3
16:13:29 <mgsloan> (not that I think higher order modules are worth dropping typeclasses by any means)
16:13:48 <hpc> higher order modules are a mistake imo
16:13:50 <shachaf> staykov: In general you should paste your full program and full error when asking a question like this.
16:13:59 <staykov> shachaf: the first program on that page
16:14:07 <mgsloan> hpc: probably so, I definitely prefer a simple module system, much cleaner
16:14:07 <shachaf> staykov: And yet, I'd still say it.
16:14:10 <hpc> it needlessly mixes "program organization" with "program semantics"
16:14:19 <shachaf> staykov: In this case it's probably an indentation thing. Tabs behave more or less like eight spaces to GHC.
16:14:21 <mgsloan> hpc: But they do have some nice properties for eliminating boilerplate
16:14:26 <staykov> http://pastie.org/8546028
16:14:40 <staykov> shachaf: mine is indented with the first non-whitespace char as it says in the guide
16:14:42 <hpc> eh, if you need to reduce boilerplate at that level you are better off with TH
16:15:10 <shachaf> staykov: Hmm, OK. @paste the full error, too. :-)
16:15:13 <Iceland_jack> Actually comments could be infix operators...
16:15:14 <Iceland_jack> > let pre -.- post = pre ++ tail (dropWhile (/= '\n') post) in "some code\n" -.- "comment\nmorecode"
16:15:15 <lambdabot>  "some code\nmorecode"
16:15:51 <sipa> monochrom: i don't get the 'la'
16:15:54 <ReinH> (-.-) is my new favorite operator.
16:16:10 <staykov> shachaf: nvm it is an indentation problem, my editor uses 4 spaces
16:16:14 <ReinH> I need to figure out a use for (-.-) and (^.^)
16:16:15 <Zekka> Who was it that said that idiomatic Haskell looks like emoticon stew?
16:16:16 <Fuuzetsu> ReinH: Doing what?
16:16:18 <Fuuzetsu> heh
16:16:21 <ReinH> Fuuzetsu: whatever
16:16:21 <monochrom> think of that as "lalala". and I am not very satisfied with it either. perhaps "lol" is better
16:16:26 <Zekka> Because if anything I think that's just more motivation to learn it
16:16:27 <shachaf> staykov: Well then.
16:16:53 <ReinH> staykov: if your editor is displaying something other than the actual number of spaces in the file, make it stop doing that.
16:17:53 <monochrom> but I love how the T line really brings us back to do, it really does. it was a stroke of genius. :)
16:18:17 <staykov> its somewhat annoying to have to line it up like that
16:18:20 <Twey> ReinH: Looks like they belong in lens to me :þ
16:18:22 <Zekka> monochrom - What are you referring to?
16:18:58 <ReinH> Twey: I'm going to figure out some way to make (-.-) (^.^) and (~.~) make sense and then use them for... something.
16:19:13 <johnw> ReinH: linear has ^-^
16:19:18 <hpc> ReinH: an acme package that does error handling?
16:19:20 <ReinH> johnw: not good enough
16:19:25 <ReinH> hpc: seems good.
16:19:29 <hpc> different levels of error severity
16:19:33 <ReinH> yes
16:19:36 <startling> hahaha
16:19:37 <Zekka> A parser for text messages?
16:19:40 <ReinH> hahaha
16:19:44 <hpc> (^.^) = log
16:19:47 <ReinH> wait
16:19:48 <hpc> (-.-) = error
16:19:52 <hpc> (~.~) = warn
16:19:56 <zRecursive> haha
16:20:03 <startling> (~.~) looks angrier than (-.-) to me
16:20:04 <johnw> acme-awakening.  -.- leads to ~.~ leads to ^.^ leads to O.O
16:20:04 <ReinH> s ^.^ t = s ++ " ^.^ " ++ t
16:20:05 <ReinH> and so on
16:20:07 <ReinH> epic
16:20:14 <hpc> haha
16:20:21 <Zekka> You could just alias them to prelude funcftions in a module you include  in every project you write
16:20:30 <startling> heh
16:20:34 <FireFly> hpc: surely error should be (>.<)
16:20:36 <startling> @hackage faces
16:20:36 <lambdabot> http://hackage.haskell.org/package/faces
16:21:00 <ReinH> > let s ^.^ t = s ++ " ^.^ " ++ t in "Hello!" ^.^ "Emoticons are awesome!"
16:21:01 <lambdabot>  "Hello! ^.^ Emoticons are awesome!"
16:21:02 <ReinH> Yep.
16:21:11 <ReinH> FireFly: awesome.
16:21:22 <mgsloan> @hackage plumbers
16:21:22 <lambdabot> http://hackage.haskell.org/package/plumbers
16:21:24 <ReinH> I wish (>^.^)> was valid for the full Kirby experience.
16:21:50 <zRecursive> :t (<*)
16:21:50 <lambdabot> Applicative f => f a -> f b -> f a
16:21:57 <ReinH> mgsloan: oh my god it's full of stars
16:22:59 <mgsloan> ReinH: Yup!  A full menagerie of pointless combinators :D
16:23:40 <Zekka> I'm trying to figure out what plumbers is for but I can't
16:23:43 <Hodapp> mgsloan: that sounds like a good title for a paper
16:23:49 <Fuuzetsu> Zekka: for plumbing
16:23:54 <Zekka> Which sense do they mean 'pointless' in?
16:24:13 <aphury> Given f :: a -> a -> a  I want stick in g :: a -> a -> a at f's "first parameter", such that f . g :: a -> a -> a -> a ... is there such a thing?
16:24:19 <hpc> Zekka: either; pointless is usually pointless anyway ;)
16:24:36 <Zekka> I'll be honest, I'm still at the stage where I kind of mentally die at walls of type signatures
16:24:38 <ReinH> mgsloan: such pointless
16:24:49 <ReinH> FireFly: Ok I've got an idea.
16:24:54 <ReinH> > let a >.< b = maybe (Left b) Right a in Nothing >.< "ERROR: nothing there!"
16:24:55 <lambdabot>  Left "ERROR: nothing there!"
16:25:01 <ReinH> (Yes, this is flip note from Control.Error.Util)
16:30:10 <Twey> :t \a -> catch a (\e -> return undefined)
16:30:11 <lambdabot>     No instance for (Exception e0) arising from a use of `catch'
16:30:11 <lambdabot>     The type variable `e0' is ambiguous
16:30:11 <lambdabot>     Possible fix: add a type signature that fixes these type variable(s)
16:30:16 <Twey> What's going on here?
16:30:48 <Iceland_jack> :t \a -> catch a (\(SomeException e) -> return undefined)
16:30:49 <lambdabot> IO a -> IO a
16:31:06 <Twey> :t \a -> catch a ((\e -> return undefined) :: Exception e => e -> IO a)
16:31:07 <lambdabot>     No instance for (Exception e0) arising from a use of `catch'
16:31:07 <lambdabot>     The type variable `e0' is ambiguous
16:31:07 <lambdabot>     Possible fix: add a type signature that fixes these type variable(s)
16:31:14 <Twey> Why must I pick a specific instance?
16:31:34 <geekosaur> SomeException is the "any instance"
16:32:13 <Twey> How?  And why doesn't the code I posted work?
16:32:14 <geekosaur> otherwise, you are able to specify by the type you use which exceptions you want to catch and which to pass on
16:32:33 <geekosaur> but that means it needs to be able to determine the type
16:33:03 <Twey> Ah, I see
16:44:43 <haasn> :t catching
16:44:44 <lambdabot>     Ambiguous occurrence `catching'
16:44:44 <lambdabot>     It could refer to either `Control.Exception.Lens.catching',
16:44:44 <lambdabot>                              imported from `Control.Exception.Lens' at /home/lambda/.lambdabot/State/L.hs:39:1-29
16:44:49 <haasn> eep
16:44:54 <haasn> :t Control.Exception.Lens.catching
16:44:56 <lambdabot> MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m => Getting (First a) SomeException a -> m r -> (a -> m r) -> m r
16:47:12 <startling> lovely type name.
16:51:27 <mizu_no_oto> With Shelly, is there a nice way to have stdout and stderr always be redirected to a given file?
16:53:08 * hackagebot hfov 1.0.2 - Field-of-view calculation for low-resolution 2D raster grids.  http://hackage.haskell.org/package/hfov-1.0.2 (JeremyApthorp)
16:53:18 <haasn> startling: I have the feeling there are some redundancies in it that could be optimized, got any ideas?
17:03:09 * hackagebot GLFW-b-demo 1.0.6 - GLFW-b demo  http://hackage.haskell.org/package/GLFW-b-demo-1.0.6 (BrianLewis)
17:07:18 <mizu_no_oto> Can you redirect stdout of a haskell program to a file from within the program itself?
17:08:12 <Fuuzetsu> you can specify an output stream
17:08:44 <Fuuzetsu> http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html
17:09:04 <Fuuzetsu> you can openFile to get on IO Handle and use the Handle to write to
17:09:08 <Fuuzetsu> I think that should work.
17:09:47 <aphury> Is there a way to combine two functions f, g :: a -> a -> a  such that f . g :: a -> a -> a -> a where f .g x y z = f (g x y) z  ?
17:10:29 <Fuuzetsu> aphury: you just did
17:10:48 <aphury> Fuuzetsu: yeh, but if f, g :: a->a->a->a ?
17:11:04 <Jeebs> Hey - working on homework and I think I'm doing my pattern matching wrong. Attempting to make a function that takes a list of lists and combines them into one list
17:11:04 <Jeebs> http://pastie.org/8546109
17:11:08 <aphury> I need somehow a "general way" to "stick" a function g into f's "first argument"
17:11:12 <Jeebs> Could anyone give me some guidence?
17:11:55 <Fuuzetsu> aphury: Hm, I don't think I follow what result you actually want
17:12:56 <mizu_no_oto> Fuuzetsu:  I'm trying to get the entire output of a Shelly script to be redirected to a file; it prints to stdout and I would rather not refactor everything to call modified versions of run that redirects output to a file
17:14:44 <aphury> Fuuzetsu: Suppose you have data Term = Constant Int | Add Term Term. What you have is a function \x y  -> Add x y   and you want it to become \x y z -> Add (Add x y) z ... But next time, you may have \x y z -> Add (Add x y) z and want \x y z w -> Add (Add (Add x y) z) w
17:15:02 <L8D> mizu_no_oto: ./script.sh < out_file
17:15:07 <L8D> whoops
17:15:13 <L8D> ./script.sh > out_file
17:16:14 <Fuuzetsu> mizu_no_oto: redirect it on command line when calling the program
17:17:48 <stevely> Jeebs: 1) your type signature is off. 2) "tail" in (head:tail) can match []
17:17:54 <Fuuzetsu> aphury: Oh. Eh, I'd just build up the terms from \x y -> … and call it multiple times
17:17:56 <L8D> or even: ./script.sh | tee out_filew
17:20:28 <aphury> Fuuzetsu: I'm not sure what you mean. So if you have ... -> Add (Add x y) z and you want the Add (Add (Add x y) z) w     -- what do you mean?
17:21:02 <Jeebs> thanks!
17:21:07 <Twey> aphury: Looks like (`Add` z) . f
17:21:11 <Fuuzetsu> aphury: you wouldn't have a 4 argument function, you'd just call your 2 argument function more times
17:23:04 <osa1> anyone here read SPJ's "implementing fun langs" book? I think in current version codes are ported to Haskell from original Miranda version, right? or is Miranda really that similar to Haskell? it's like a subset of Haskell. (also, there are some cases where type names in the book text is written with lowercase first letter but in the code it's uppercase, which I think indicates code parts are rewritten for Haskell?)
17:23:28 <aphury> Twey, Fuuzetsu: thanks, I've to think about your answers.  : )
17:25:08 <Twey> osa1: Apparently some of the code was rewritten in Haskell (citation Fuuzetsu, personal correspondence)
17:29:21 <osa1> this book is weird. there is this comment in code in the book "In Gofer I propose to compose this with some function CoreProgram -> String, which will illustrate some sort of execution machine, and then give this composition to catWith from my utils" which seems like put there by mistake because it doesn't make sense in the context
17:29:49 <osa1> more like a comment of author that needed to be removed before publishing
17:32:13 <osa1> oh wow there are also problems in code parts, like in the place where author explains (.) function -- expanded version is wrong
17:33:13 * hackagebot fixedprec 0.2.1.0 - A fixed-precision real number type  http://hackage.haskell.org/package/fixedprec-0.2.1.0 (PeterSelinger)
17:38:43 <aphury> Twey, Fuuzetsu: Does one of you have some minutes to take a look over my code? I still haven't grasp what you've mentioned.
17:40:51 <Fuuzetsu> aphury: Well, I'm sure someone can help you out if you paste it up somewhere!
17:41:18 <aphury> --> http://lpaste.net/96894
17:41:57 <Fuuzetsu> osa1: which edition? SPJ or SPJ and Lester?
17:42:34 <osa1> Fuuzetsu: SPJ and Lester
17:42:49 <Fuuzetsu> if the second, some of the code has been translated to Haskell inside the book. Unfortunately, the book sources are so old that I'm unable to get it to compile. I did start to translate myself though actually, to ease it up for anyone reading.
17:43:04 <Fuuzetsu> Although no longer in book format but in a git repo with per-section branch tags
17:43:48 <Fuuzetsu> note however that if you know Haskell, you'll be just fine reading the Miranda version, it's very similar, there are a few differences but they are easy to figure out
17:44:05 <osa1> Fuuzetsu: yeah I know Haskell
17:44:53 <osa1> Fuuzetsu: okay I'll do that because this version is annoying with wrong code and nonsense comments
17:45:11 <osa1> also, some definitions are missing
17:45:30 <osa1> for example pprProgram
17:46:24 <Fuuzetsu> osa1: I can publish some of the Haskell code I already wrote this far but it's only up to section 2 (not had time recently) if you're interested
17:47:32 <osa1> Fuuzetsu: no I'm not looking for a working and complete Haskell code, I'm translating on-the-fly while reading it but it's annoying when I see nonsense comments etc. other than that I have no problems with reading some other programming language and I'm fairly experienced in Haskell
17:48:48 <osa1> Fuuzetsu: um, where can I find old version?
17:49:20 <osa1> Fuuzetsu: so is this version only partially translated to Haskell?
17:49:27 <Fuuzetsu> osa1: Of the book? No idea. AFAIK the with Lester version is the recommended one… It's slightly less in-depth in some sections
17:49:43 <Fuuzetsu> osa1: Yes, there is, SPJ sent it to me but I haven't managed to get it to compile
17:54:21 <Cale> aphury: You should really configure your text editor to convert tabs to spaces.
17:54:51 <aphury> Cale: yeh, I'm sorry. Tried to fix it within the paste, but didn't work well.
17:55:20 <Cale> (It's not a problem in your current code, but the Haskell compiler will treat your tabs as aligning to multiples of 8 spaces, so if they're not being displayed like that, tab characters can result in misleading behaviour)
18:08:58 <aphury> g2g
18:22:18 <stepkut> so, I am using the GHC API to compile and load a module into a running program. But, now I want to watch not just that module, but any modules it depends on and recompile if any of those change. Any idea if there is a function to return the transitive closure of 'local' imports for a module? Or do I need to write it up myself? trying to find anything in the ghc api haddock docs is a major hunting expedition :)
18:44:56 <Fuuzetsu> stepkut: Uhh, I think there's something or the other…
18:45:41 <stepkut> currently I am looking at depanal and looking for downsweep and upsweep -- but no idea if I am on the right track :)
18:47:17 <Fuuzetsu> I think it's possible to get the dependency graph…
18:48:23 * hackagebot colors 0.1.1 - A type for colors  http://hackage.haskell.org/package/colors-0.1.1 (FumiakiKinoshita)
18:54:10 <m3ga> is there a way to put multiline/block comments in a cabal file?
18:56:01 <m3ga> ah, seems like enclosing the text in { } seems to work
18:58:24 <stepkut> Fuuzetsu: seems that depanal might do the trick
18:58:43 <Fuuzetsu> cool
19:02:50 <Redz> what can template haskell do? create new data types and functions?
19:04:43 <TheStik> hi!
19:05:07 <TheStik> I got a quick question, regarding monads, map & IO()
19:05:40 <heatsink> Template Haskell can create most Haskell declarations
19:06:03 <heatsink> Think of it as a data structure representation of Haskell source code
19:06:28 <Cale> TheStik: Feel free to hang around and ask questions :)
19:08:20 <Redz> heatsink: thank you. i just needed a confirmation of my understanding. :)
19:08:42 <TheStik> http://pastebin.com/eAJV2LSp
19:08:45 <TheStik> any ideias?
19:08:47 <mauke> The paste eAJV2LSp has been copied to http://lpaste.net/96896
19:10:34 <Cale> TheStik: Why are you using mapM_ there?
19:10:46 <Cale> TheStik: Your function doesn't involve IO
19:10:46 <Redz> uh. a tuple isn't a monad.
19:11:14 <TheStik> doh!
19:11:32 <TheStik> too much copy&paste
19:11:37 <TheStik> sry =(
19:11:45 <Cale> (well, this tuple type constructor *could* be an instance of Monad...)
19:11:45 <TheStik> thanks for your help =D
19:11:52 <Cale> No problem
19:12:39 <Cale> xs !! (length xs - 1) is the same as last xs
19:15:55 <tromp> unless xs is longer than maxBound::Int
19:17:05 <Cale> hah, yes
19:24:58 <lightquake> what is the difference between the least fixed point and the greatest fixed point?
19:26:35 <Saizan> lightquake: are we talking about types? in haskell none
19:27:08 <lightquake> in general, then
19:27:20 <Saizan> in general least fixed points have folds while greatest fixed points have unfolds
19:27:26 <TheStik> Cale && tromp : that isn't my code... =X lol
19:27:59 <Saizan> lightquake: more technically one produces an inductive type while the other a coinductive one
19:33:29 * hackagebot cipher-aes128 0.5 - AES128 using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.5 (ThomasDuBuisson)
19:33:31 * hackagebot commsec 0.3.3 - Provide communications security using symmetric ephemeral keys  http://hackage.haskell.org/package/commsec-0.3.3 (ThomasDuBuisson)
19:56:05 <TheStik> hi again
19:56:30 <TheStik> this time a really trouble for me =(
19:57:14 <TheStik> if (map fst listaF1) == (map fst listaF2) then do something with the corresponding snd. How to?
19:58:28 <brgsp> i need help
19:59:48 <pavonia> TheStik: Have you looked at zipWith?
20:00:04 <TheStik> OMW pavonia
20:00:30 <pavonia> :t zipWith
20:00:31 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
20:01:18 <TheStik> pavonia: not my solution
20:01:34 <TheStik> both lists are of type: ([String],Int)
20:01:53 <pavonia> What do you mean by the corresponding snd? There are two lists of second elements here
20:01:54 <TheStik> that's where the map fst comes from
20:02:34 <TheStik> basically
20:02:49 <TheStik> if that [String] in L1 == [String] in L2
20:03:20 <TheStik> then both int go to F which chooses one given a bunch of cryteria
20:03:27 <TheStik> (sorry for some poor english)
20:03:40 <TheStik> but!
20:03:54 <TheStik> the catch is, neither of the lists are sorted in anyway
20:04:08 <TheStik> so, I was REALLY thinking of doing a crazy thing
20:04:22 <pavonia> you can sort them first
20:04:29 <TheStik> and for every [String] in L1, search the entire L2...
20:04:48 <TheStik> you can sort tuples?
20:05:06 <pavonia> yes
20:05:18 <pavonia> But I guess it won't help if your lists have differents length
20:05:28 <TheStik> they do
20:05:33 <TheStik> or, can have
20:05:43 <pavonia> hmm
20:06:21 <pavonia> so you can loop through the first list and find the corresponding element in the secons list with "lookup"
20:06:23 <startling> TheStik: I think lists are the wrong datatype for you
20:06:28 <startling> have you seen Data.Map?
20:06:41 <startling> I think there's a convenience function or five that will do what you're asking
20:07:30 <TheStik> :t lookup
20:07:31 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
20:09:05 <TheStik> startling: I was trying ot stay away from Map
20:09:11 <TheStik> I've considered them though
20:09:37 <twiceler> TheStik: What are you trying to do? At a high level?
20:09:48 <startling> TheStik: why's that?
20:10:23 <TheStik> startling: don't really "get them" well enough to feel comfortable working with them
20:10:54 <twiceler> TheStik: I think you'll have a much easier time working with them to than to do what you want to do with lists
20:11:23 <TheStik> twiceler: Best way to put it is: you get two files (from args) and in each one you have a string (more than 1 word per line) followed by a number then \n
20:11:50 <ReinH> ]th
20:12:26 <TheStik> if a given string is in file 1 and file 2, get both number (which may be different) and pass them on to another function, so it tells you which of the two to write to a third file, alongside the corresponding string
20:13:01 <twiceler> TheStik: You should absolutely use Data.Map
20:13:25 <twiceler> > :i Data.Map.intersection
20:13:26 <lambdabot>  <hint>:1:1: parse error on input `:'
20:13:37 <twiceler> :i Data.Map.intersection
20:13:47 <simpson> She doesn't have :i.
20:13:56 <simpson> :t Data.Map.intersection
20:13:57 <lambdabot> Ord k => M.Map k a -> M.Map k b -> M.Map k a
20:13:57 <twiceler> :t Data.Map.intersection
20:13:58 <lambdabot> Ord k => M.Map k a -> M.Map k b -> M.Map k a
20:14:09 <twiceler> :t Data.Map.intersectionWith
20:14:10 <lambdabot> Ord k => (a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
20:15:17 <TheStik> Oh! and another "thing": if a given string isn't in the other file, you just add it =\
20:16:08 <twiceler> :t Data.Map.intersectionWithKey
20:16:09 <lambdabot> Ord k => (k -> a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
20:17:57 <TheStik> ok, I'm sold xD
20:18:56 <twiceler> For that last operation,
20:19:01 <twiceler> :t Data.Map.unionWithKey
20:19:03 <lambdabot> Ord k => (k -> a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
20:21:14 <twiceler> So I've written a module where I used language-c to read a C header file, and then Template Haskell to write bunch of C binding. The thing is the C header is from a library that should already be installed.
20:21:35 <twiceler>  I want to use a configure script to find the header, and I'm just wondering the best way to approach this with Cabal
20:21:57 <twiceler> Specifically, how do I get the header's location back to my source code?
20:23:00 <gienah> Cabal knows about pkg-config
20:25:12 <gienah> twiceler: search for pkg-config in the Cabal docs: http://www.haskell.org/cabal/users-guide/developing-packages.html
20:26:10 <twiceler> gienah: Thanks, that looks helpful!
20:26:21 <gienah> no worries :)
20:26:38 <twiceler> The thing is, as of right now, I simply have a FilePath variable in my source code that points to the header.
20:27:18 <twiceler> Do you have any ideas how I could make that depend on the output of autoconf or something?
20:27:36 <twiceler> In a non-hacky way, if possible
20:28:35 <gienah> yeah like I know a stupid, hacky, broken way to do it, the broken example is hmatrix - a hack that I have to patch around on gentoo - it just hard codes junk then gives up when its not there
20:29:09 * gienah would prefer pkg-config if the library had that
20:29:49 <twiceler> This would be for cublas, so I'd imagine it has a pkg-config
20:29:56 <gienah> (although hmatrix is trying to find blas libs and stuff, which is difficult)
20:31:19 <gienah> yeah like it probably does, I could try installing it
20:33:27 <twiceler> Just looked at the hmatrix build program - looks scary!
20:33:42 <twiceler> Right now I have an autoconf script that finds the directory with the include files
20:34:10 <twiceler> (at least for my computer)
20:35:04 <twiceler> Is it a sin if I have something like this in my source code: headerPath = readFile "../../headerPath.txt"?
20:35:32 <twiceler> which then is fed to a lot of Template Haskell upon install?
20:35:41 <geekosaur> bad idea, it makes assumptions about where it's being run from at runtime
20:36:14 <geekosaur> or are you saying that is being evaluated by TH code at compile time?
20:36:20 <jrmithdobbs> If it's TH code it's compile time no?!
20:36:30 <twiceler> geekosaur: Yes, being evaluated at compile time with TH
20:36:40 <twiceler> geekosaur: And never relevant afterwords
20:37:02 <geekosaur> jrmithdobbs, the way that was phrased suggested it was a runtime thing fed to TH-generated code
20:37:04 <geekosaur> it was confusing
20:37:31 <twiceler> I feel like maybe much of this should go into a "Setup.hs" file, but I'm inexperienced with Cabal and I've only ever seen "defaultMain" or really scary Seup files...
20:37:47 <jrmithdobbs> twiceler: Seems fine if ugly to me
20:39:15 <twiceler> jrmithdobbs: Okay cool. I think this whole practice I'm doing is pretty ugly!
20:39:32 <jle`> is there anywhere i can just find a list of all the twitter accounts of famous haskell people.  right now i'm just reading through people's retweets and adding the occasional developer of libraries
20:39:56 <twiceler> I've thought of just taking the TemplateHaskell slices and just sticking that in as a static file as well :)
20:40:11 <gienah> twiceler: this is sad, even on gentoo nvidia-cuda-toolkit does not seem to have a .pc pkg-config file
20:41:43 <twiceler> gienah: Cool, thanks for looking into that. I'll hope for the autoconf script
20:43:41 <gienah> twiceler: nvidia-cuda-toolkit is a binary package on gentoo, so its probably pretty standard on other distros, maybe you might have this file: cat /opt/cuda/bin/nvcc.profile
20:45:33 <gienah> twiceler: or maybe: google for: m4 autoconf nvidia
20:46:39 <twiceler> gienah: I think the script that I've already gotten from https://github.com/tmcdonell/cublas works.
20:47:00 <gienah> twiceler: ok, neat
20:47:05 <twiceler> I was just wondering about the best way to pull the information out from that autoconf script in my source code.
20:47:34 <twiceler> gienah: And it sounds like I'll do that in a very hacky way
20:53:36 <gienah> twiceler: you don't need to do anything hacky, Cabal will do it for you with Trevor's script, search for buildinfo.in http://www.haskell.org/cabal/users-guide/developing-packages.html#example-using-autoconf
20:54:09 <gienah> twiceler: and that is what Trevor is doing here: https://github.com/tmcdonell/cublas/blob/master/cublas.buildinfo.in
20:54:38 <gienah> twiceler: where you want to change the file name to your-pkg-name.buildinfo.in
20:56:57 <twiceler> gienah: But then I'm using Template Haskell to read a C header file
20:57:41 <twiceler> gienah: So my current plan is to make another file using the same autoconf script, and then in my source dir, read that file to see where to find the C header
20:58:39 <twiceler> *I should say I'm using language-c to read a C header file, then Template Haskell to write a bunch of code
20:59:48 <gienah> twiceler: maybe you can set something else in the .buildinfo.in files, like: include-dirs:
21:00:23 <twiceler> gienah: And then is there a standard way to read that from a source file? Or should I just parse through it myself?
21:00:52 <twiceler> gienah: Or is there some way to "observe" these Cabal variables?
21:01:03 <gienah> twiceler: well, cabal is reading it and cabal should use it to set the ghc options, you could see by running cabal with --verbose=3
21:02:29 <gienah> --verbose=3 prints out lots of useless junk, the useful stuff is the command line options to ghc
21:02:59 <twiceler> I just want to make sure I'm communicating what I'm trying to do well. I have a Haskell source file where I read a C header (where I get the location from a standard variable) and then write some Template Haskell code. So I don't know how I could use ghc command line options to set that variable
21:04:16 <twiceler> Like I basically have a function f :: FilePath -> Q [Dec] and I call it in one of my source files using the C header filepath
21:04:26 <zRecursive> twiceler: How about using environment varaables ?
21:04:26 <agibiansky> Hello! Could someone help me out with Data.Dynamic? I'm getting the following error: Can't apply function <<[MyType] -> [Char]>> to argument <<[MyType]>>, which seems nonsensical..?
21:05:06 <twiceler> zRecursive: like Bash environment variables? Or do you mean something else?
21:05:36 <zRecursive> OS envirionment variables
21:06:26 <jle`> :t getEnv
21:06:27 <lambdabot>     Not in scope: `getEnv'
21:06:28 <lambdabot>     Perhaps you meant `getAny' (imported from Data.Monoid)
21:06:36 <jle`> :t System.Environment.getEnv
21:06:36 <lambdabot> String -> IO String
21:06:42 <augur> does anyone know if its possible to eliminate mutually recursive datatypes algorithmically?
21:06:49 <jle`> oh do you mean in your cabal file
21:07:03 <jle`> ignore me plz
21:07:27 <jle`> :)
21:07:38 <gienah> twiceler: or {-# LANGUAGE: CPP #-} at the top of the file, and make the configure.ac script pass -DINCLUDE_DIR_I_WANT=/some/path in .buildinfo.in cpp-options
21:07:40 <twiceler> jle`: Nope, in my source files! I think that's what he means
21:07:56 <jle`> mhm reading back that makes sense
21:08:23 <gienah> twiceler: s/cpp-options/cc-options/
21:09:18 <jrmithdobbs> twiceler: Yes the -XCPP route is probably what you want.
21:09:24 <TheStik> Thank you all
21:09:26 <TheStik> good night!
21:10:12 <gienah> twiceler: and: f = INCLUDE_DIR_I_WANT
21:10:25 <twiceler> AHHH I see!
21:11:04 <gienah> twiceler: I am hoping that it will run the C pre-processor before template haskell
21:11:06 <twiceler> Okay perfect, that's exactly what I'd want to do
21:11:21 <jrmithdobbs> gienah: Should
21:11:46 <twiceler> gienah: I think the c preprocessor comes first. That way you can have those fancy IFDEFs
21:12:03 <gienah> twiceler: jrmithdobbs: neat, thanks
21:12:11 <twiceler> (not that I've ever seen them along with Template Haskell code)
21:13:36 <jrmithdobbs> Should rename the file .hs.erb and require ruby as a build dep. just for the funny looks.
21:14:28 <jrmithdobbs> Or .hs.in and be extra evil
21:28:42 <agibiansky> Anyone? Experience with weird Data.Dynamic issues?
21:35:42 <nurupo> :?
21:38:33 <nurupo> > Nil
21:38:34 <lambdabot>  Not in scope: data constructor `Nil'
21:39:06 <nurupo> is there an alternative way to write an empty list "[]"?
21:40:13 <startling> nurupo: not really.
21:40:35 <nurupo> what about ML?
21:40:36 <startling> you can think of [] (the type) as data [a] = [] | a : [a]
21:41:06 <nurupo> yeah, i know that
21:41:58 <startling> > let empty = [] in empty -- nurupo: well, you can do this :)
21:41:59 <lambdabot>  []
21:42:12 <nurupo> startling: #222 in http://cs.fit.edu/~ryan/cse4250/study.pdf
21:43:12 <jle`> nurupo: you can do any the monoid-related ones
21:43:18 <startling> ^
21:43:22 <jle`> mempty
21:43:24 <jle`> mzero
21:43:26 <jle`> empty
21:43:28 <nurupo> ?
21:43:36 <jle`> > mempty :: List
21:43:37 <lambdabot>  Not in scope: type constructor or class `List'
21:43:37 <lambdabot>  Perhaps you meant `Last' (imported from Data.Monoid)
21:43:38 <jle`> oops
21:43:39 <startling> > mempty :: [Int]
21:43:40 <lambdabot>  []
21:43:41 <nurupo> > cycle "example"
21:43:42 <lambdabot>  "exampleexampleexampleexampleexampleexampleexampleexampleexampleexampleexamp...
21:43:43 <jle`> > mempty :: [Int]
21:43:44 <lambdabot>  []
21:43:48 <jle`> > mzero :: [Int]
21:43:49 <lambdabot>  []
21:43:53 <jle`> > empty :: [Int]
21:43:54 <lambdabot>  []
21:43:59 <startling> > filter (const False) $ repeat 0
21:44:00 <jle`> Haskell will usually be able to infer that you wnat a list
21:44:04 <lambdabot>  mueval: ExitFailure 1
21:44:04 <lambdabot>  mueval: Prelude.undefined
21:44:17 <nurupo> what about [[]]?
21:44:18 <startling> :<
21:44:38 <startling> nurupo, well, in Haskell there's another syntax devoted to lists ...
21:45:05 <startling> > map pure "ab" :: [String]
21:45:06 <lambdabot>  ["a","b"]
21:45:23 <startling> I'm not sure what e is supposed to be.
21:45:30 <jle`> nurupo: this is probably getting to the hack-ish level
21:45:32 <jle`> but
21:45:40 <jle`> > pure mempty :: [[Int]]
21:45:41 <lambdabot>  [[]]
21:45:48 <jle`> > return mzero :: [[Int]]
21:45:49 <lambdabot>  [[]]
21:46:00 <startling> > ""
21:46:01 <lambdabot>  ""
21:46:05 <jle`> it'll make sense in whatever context you're in though usually, if you really do want [[]]
21:46:14 <nurupo> > return mzero :: [(Int)]
21:46:15 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
21:46:16 <lambdabot>              with actual type `m0 a0'
21:46:16 <jle`> startling: clever :P
21:46:38 <jle`> nurupo: do you mean [[Int]]?
21:46:50 <jle`> because you just wrote [Int], essentially
21:46:53 <nurupo> jle`: could you help with others from #222 http://cs.fit.edu/~ryan/cse4250/study.pdf ?
21:46:54 <gamegoblin> In parsec, what would a function look like that took an integer N, and parsed precisely N floats?
21:47:39 <jle`> nurupo: hard for me to know what your prof wants without the context of the class
21:47:50 <nurupo> it wasn't even covered, heh
21:48:16 <jle`> well [()] is return ()
21:48:18 <nurupo> it's a sample question from some years ago that may or may not appear on exam
21:48:30 <pavonia> gamegoblin: something like do { i <- integer; replicateM i float } maybe
21:48:34 <jle`> you know about return/pure right?
21:48:49 <nurupo> nope
21:48:49 <jle`> also ([]) is just []
21:48:58 <startling> is that different in ML?
21:49:07 <jle`> it should be the same in ML
21:49:31 <jle`> just checked.
21:50:21 <gamegoblin> pavonia: good call
21:50:57 <jle`> nurupo: "return" can be thought of a function that wraps the item in the type, in this context.  so return 5 will put 5 inside a list.  pure is the same function
21:51:09 <startling> > return 5 :: [Int]
21:51:10 <lambdabot>  [5]
21:51:15 <startling> > pure 5 :: [Int]
21:51:16 <lambdabot>  [5]
21:51:52 <nurupo> (return 5 :: [Int]) : (return 4 :: [Int])
21:51:56 <nurupo> Ю (return 5 :: [Int]) : (return 4 :: [Int])
21:52:00 <nurupo> > (return 5 :: [Int]) : (return 4 :: [Int])
21:52:01 <lambdabot>  Couldn't match type `GHC.Types.Int' with `[GHC.Types.Int]'
21:52:01 <lambdabot>  Expected type: [[GHC.Types.Int]]
21:52:01 <lambdabot>    Actual type: [GHC.Types.Int]
21:52:30 <jle`> remember that :'s right hand side must be an element in the list
21:52:35 <jle`> er, left hand
21:52:40 <jle`> and :'s right hand side is the list itsself
21:52:42 <nurupo> right
21:52:49 <jle`> son the left side was a list of ints
21:53:03 <jle`> you would expect on the right side to be a list of whatever is on your left side
21:53:08 <jle`> so you expect a list of list of ints
21:53:30 <jle`> > [5] : [[6],[7],[8]]
21:53:31 <lambdabot>  [[5],[6],[7],[8]]
21:54:36 <jle`> > 1:2:3:mempty
21:54:37 <lambdabot>  [1,2,3]
21:55:02 <jle`> now that just feels wrong
21:55:06 <jle`> in my soul.
21:55:20 <jle`> > pure 1 <|> pure 2 <|> pure 3
21:55:22 <lambdabot>  No instance for (Control.Applicative.Alternative f0)
21:55:22 <lambdabot>    arising from a use of `e_1123'
21:55:22 <lambdabot>  The type variable `f0' is ambiguous
21:55:22 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
21:55:22 <lambdabot>  Note: there are several potential instances:
21:55:42 <nurupo> :t empty
21:55:43 <lambdabot> Alternative f => f a
21:55:58 <jle`> > pure 1 <|> pure 2 <|> pure 3 :: [Int]
21:55:59 <lambdabot>  [1,2,3]
21:56:09 <nurupo> > empty
21:56:10 <lambdabot>  No instance for (Control.Applicative.Alternative f0)
21:56:10 <lambdabot>    arising from a use of `e_1'
21:56:10 <lambdabot>  The type variable `f0' is ambiguous
21:56:10 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
21:56:10 <lambdabot>  Note: there are several potential instances:
21:56:19 <jle`> you need to specify a specific type
21:56:44 <nurupo> that's what what i tested it for :)
21:56:54 <jle`> :)
21:56:59 <jle`> > empty :: Maybe Int
21:57:00 <lambdabot>  Nothing
21:57:27 <jle`> i don't think you can do anything too fancy with tuples without using tuple syntax/literals though
21:57:43 <jle`> maybe osmething with id/uncurry
21:57:49 <jle`> er, curry
21:57:57 <jle`> :t curry
21:57:57 <lambdabot> ((a, b) -> c) -> a -> b -> c
21:58:06 <jle`> :uncurry
21:58:08 <jle`> :t uncurry
21:58:09 <lambdabot> (a -> b -> c) -> (a, b) -> c
21:59:22 <nurupo> what is the key difference between foldl and foldl'?
21:59:58 <startling> @google foldr foldl foldl'
21:59:59 <lambdabot> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
21:59:59 <lambdabot> Title: Foldr Foldl Foldl' - HaskellWiki
22:00:03 <nurupo> foldl' has some protection from infinite recursion?
22:00:32 <startling> > foldl (+) (repeat 1)
22:00:33 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
22:00:33 <lambdabot>    arising from a use of `M124067862173704527319956.show_M1240678621737045273...
22:00:33 <lambdabot>  The type variable `a0' is ambiguous
22:00:33 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
22:00:33 <lambdabot>  Note: there are several potential instances:
22:01:04 <startling> > foldl' (+) 0 (repeat 1) -- no
22:01:08 <lambdabot>  mueval-core: Time limit exceeded
22:02:02 <startling> > foldl (+) 0 (repeat 1) -- wellllll
22:02:06 <lambdabot>  mueval-core: Time limit exceeded
22:02:16 <startling> (oh, I thought it would overflow)
22:03:59 <copumpkin> > foldr (+) 0 (repeat 1)
22:04:00 <lambdabot>  *Exception: stack overflow
22:04:16 <copumpkin> startling: foldl never returns anything, and overflows come from reducing thunks
22:04:29 <copumpkin> foldr returns a nice value
22:04:39 <copumpkin> that just happens to depend on the next, that depends on the next, and so on
22:05:12 <startling> copumpkin: oh, I see
22:05:30 <nurupo> :t Nil
22:05:31 <lambdabot> Not in scope: data constructor `Nil'
22:05:49 <startling> > foldl (+) 0 (replicate 10000 1)
22:05:50 <lambdabot>  10000
22:05:54 <nurupo> oh, read it wrong
22:05:57 <startling> > foldl (+) 0 (replicate 10000000000 1)
22:06:01 <lambdabot>  mueval-core: Time limit exceeded
22:06:15 <nurupo> > foldl' (+) 0 (replicate 10000000000 1)
22:06:18 <startling> > foldl (+) 0 (replicate maxBound 1)
22:06:18 <lambdabot>  mueval-core: Time limit exceeded
22:06:22 <lambdabot>  mueval-core: Time limit exceeded
22:06:26 <startling> aww
22:12:08 <trillioneyes> > foldr (*) 0 (replicate 10000000000 1)
22:12:09 <lambdabot>  *Exception: stack overflow
22:12:44 <trillioneyes> hmmm, I see why that doesn't work, but it's unfortunate
22:12:59 <QF-MichaelK> Is there anything like codeacademy for haskell?
22:13:12 <trillioneyes> > foldr (*) 1 $ 0 : [1..]
22:13:13 <lambdabot>  *Exception: stack overflow
22:13:24 <trillioneyes> Wait, I would have expected that one to work o.o
22:13:34 <trillioneyes> oh, I guess * just isn't defined by pattern matching
22:14:17 <startling> > foldr (*) (1 :: [()]) $ 0 : [1..]
22:14:19 <lambdabot>  No instance for (GHC.Num.Num [()])
22:14:19 <lambdabot>    arising from a use of `GHC.Num.*'
22:14:19 <lambdabot>  Possible fix: add an instance declaration for (GHC.Num.Num [()])No instance ...
22:14:19 <lambdabot>    arising from the arithmetic sequence `1 .. '
22:14:19 <lambdabot>  Possible fix: add an instance declaration for (GHC.Enum.Enum [()])
22:14:27 <startling> aw, it disappeared
22:14:42 <startling> > foldr (*) (S Z) $ 0 : [1..]
22:14:43 <lambdabot>  Not in scope: data constructor `S'Not in scope: data constructor `Z'
22:15:42 <startling> trillioneyes, it would work if you had a Num instance with a non-strict (*)
22:17:21 <trillioneyes> startling: right, but I think I remember reading that all the built-in instances have strict arithmetic
22:17:29 <startling> trillioneyes: yeah.
22:17:37 <startling> there used to be a lambdabot instance Num [()]
22:17:47 <trillioneyes> How silly
22:18:05 <enthropy> > genericLength [1 .. ] > (4 :: Nat)
22:18:06 <lambdabot>  Not in scope: type constructor or class `Nat'
22:18:10 <enthropy> > genericLength [1 .. ] > (4 :: Natural)
22:18:11 <lambdabot>  True
22:19:43 <startling> aha, "Natural"
22:19:45 <pharaun> best way to get ghc on solaris? it looks like i want ghc 7.0.3 then i can compile it upward?
22:20:09 <startling> :t Succ
22:20:09 <lambdabot> Not in scope: data constructor `Succ'
22:20:20 <startling> oh, right
22:20:29 <enthropy> @hackage numbers
22:20:29 <lambdabot> http://hackage.haskell.org/package/numbers
22:20:35 <startling> > foldr (*) (1 :: Natural) $ 0 : [1..]
22:20:36 <lambdabot>  0
22:20:41 <startling> trillioneyes: ^
22:21:13 <enthropy> hmm, I thought there was a Natural with a more efficient representation being used here
22:21:24 <enthropy> but that one is just data Natural = Z | S Natural
22:22:20 <startling> > let inf = fix (+ (1 :: Natural)) in 0 * inf
22:22:21 <lambdabot>  0
22:22:27 <startling> > let inf = fix (+ (1 :: Natural)) in inf * 0
22:22:31 <lambdabot>  mueval-core: Time limit exceeded
22:22:32 <startling> aww.
22:22:49 <enthropy> needs some unamb
22:34:57 <Kron> hmmmm
22:35:03 <Kron> does anyone know how to use paredit?
22:48:04 <jle`> > curry id 1 2
22:48:05 <lambdabot>  (1,2)
22:48:08 <jle`> there
22:48:31 <jle`> a tuple w/out a tuple literal
22:48:36 <gienah> Kron: no, but I sort of thought that paredit was a lisp thing, an alternative that you might be able to persuade to work with haskell is smartparens: https://github.com/Fuco1/smartparens/blob/master/README.md
22:48:54 <Kron> I'm actually trying to learn how to use structured haskell mode
22:49:00 <Kron> and I heard it was somewhat based on paredit
22:52:09 <jle`> > uncurry (curry id) (1,2)
22:52:10 <lambdabot>  (1,2)
22:56:39 <jrmithdobbs> :t curry id
22:56:40 <lambdabot> a -> b -> (a, b)
23:00:47 <startling> :t (,)
23:00:48 <lambdabot> a -> b -> (a, b)
23:01:03 <startling> > uncurry (,) (1, 2)
23:01:04 <lambdabot>  (1,2)
23:02:33 <pavonia> :t uncurry id
23:02:34 <lambdabot> (b -> c, b) -> c
23:03:13 <startling> heh
23:03:18 <startling> :t curry id
23:03:19 <lambdabot> a -> b -> (a, b)
23:23:03 <dmj`> does haskell have good facilities for interoping w/ .net?
23:23:23 <startling> .net is such a bad name
23:23:32 <Kron> how do you map a function across both elements of a tuple?
23:23:56 <startling> Kron, you don't really
23:24:16 <startling> > over both (+ 1) (0, 1) -- but you can do silly stuff with lens
23:24:18 <lambdabot>  (1,2)
23:24:20 <Kron> I understand there's no general way, but is there still a well known shortcut?
23:24:25 <Kron> ahh, perfect
23:24:25 <Kron> yes
23:24:41 <dmj`> > (length *** length) ([1..10], [1..10])
23:24:42 <lambdabot>  (10,10)
23:24:45 <startling> I think there's an arrow thing too
23:24:51 <dmj`> arrows
23:25:20 <startling> there isn't really. oh well.
23:25:25 <dmj`> startling: why is it a bad name
23:25:50 <shachaf> startling: That is not all that silly.
23:26:20 <Kron> I kinda wanted something like that
23:26:28 <Kron> "over both fn" is a very... human readable line I guess
23:26:30 <startling> shachaf, I'm not convinced.
23:26:33 <Kron> I appreciate human readable code
23:26:39 <startling> Kron, don't worry, you can spell it unreadably too. :)
23:26:53 <Kron> yes well i'm not diving into lens operators just yet
23:26:55 <Kron> :P
23:27:08 <startling> I like "over" though, yeah
23:27:10 <startling> very readable.
23:27:40 <Kron> same
23:27:43 <startling> > (0, 1) & both %~ (+ 1)
23:27:45 <lambdabot>  (1,2)
23:27:46 <Kron> what's the operator version?
23:27:47 <Kron> %=?
23:27:53 <startling> (%~)
23:28:10 <shachaf> I don't get it.
23:28:30 <startling> Kron, (x=) operators do stuff in MonadState
23:28:46 <shachaf> Why does every time that someone mentions lens turn into people saying "hey, you can also do this unreadably using the same library"?
23:29:18 <startling> shachaf, secretly we all like to show off our ability to understand unreadable code.
23:29:46 <edwardk> this explains the popularity of APL, perl, and J
23:33:06 <Kron> Perl happened when someone looked at line noise and decided to make an interpreter for it
23:33:21 <nexx> lol
23:33:50 <Kron> J happened when a Matlab programmer looked at Perl and said "Needs more arrays."
23:33:58 <Kron> at least, that's how the story goes in my head
23:34:59 <shachaf> I'm even more tired of the Perl hate.
23:35:56 <startling> yeah. :(
23:36:27 <nisstyre> there's nothing really wrong with perl
23:38:36 <Kron> I don't hate it, I just like poking fun at it :$
23:38:40 <Kron> along with the lisp parentheses
23:38:52 <Kron> I actually think J is really damn cool
23:38:58 <Kron> I'm not sure if I'll ever learn it though
