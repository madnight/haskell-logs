00:00:53 <dmwit> georges: Getting your hands on a genuine OS thread might be harder than you think. =)
00:01:28 <dmwit> Or: what do you mean by "when using OS threads"?
00:01:35 <georges> forkOS
00:01:45 <dmwit> forkOS does not create a new OS thread.
00:01:51 <c_wraith> There are unsafe tools available that can be used to make it bad to evaluate something in parallel...  But if they do, it's generally considered a bug in whatever code used the unsafe tools in a way that messed up GHC.  The unsafe tools are provided because they can do some extra nice stuff, but it's up to the programmer to make sure the way they're used is compatible with GHC's evaluation model
00:02:12 <c_wraith> forkOS is terribly misnamed
00:02:23 <georges> ah I see
00:02:58 <dmwit> You might like http://dmwit.com/gtk2hs
00:03:02 <c_wraith> it's just about creating haskell threads that always do their FFI calls from the same native thread.
00:03:18 <c_wraith> Which is important for same native libraries, that use thread-local storage
00:03:48 <dmwit> All the sections except "Best Practice" and "The Guts" are actually non-gtk2hs-specific information about threading in GHC.
00:04:44 <georges> how does haskell manage thread safe evaluation of thunks? does it use locks, or?
00:04:45 <dmwit> In fact, one of these days I plan on splitting out the non-gtk2hs-specific bits so I can stop saying that. =P
00:05:00 <georges> or rather, how does GHC do it
00:05:06 <dmwit> Thunks are not evaluated in parallel unless you explicitly ask for it.
00:05:39 <c_wraith> GHC makes evaluation thread-safe by leaning on purity.  It only makes a best-effort attempt at preventing duplicate evaluation
00:05:52 <c_wraith> If it fails, something may actually get evaluated twice
00:06:10 <c_wraith> But it's ok, because you always get the same result, anyway
00:06:13 <c_wraith> It's just wasting a little CPU time.
00:06:22 <dmwit> Remember: the evaluation of a thunk *never* does IO.
00:07:05 <georges> what if thread A starts evaluating a thunk and thread B tries to do the same before thread A finished. does thread B wait?
00:07:17 <dmwit> Usually, yes.
00:09:13 <dmwit> Oh. Perhaps you are asking an implementation question.
00:09:17 <georges> so why does purity help? not quite getting it
00:09:25 <georges> yes
00:09:27 <dmwit> In that case, I'm not sure the answer. I'm pretty sure that the implementation is lockless.
00:09:56 <c_wraith> purity helps because it means that it doesn't need to be perfect about preventing duplicate evaluation
00:10:00 <c_wraith> it doesn't need locks
00:10:18 <c_wraith> or memory fences, etc
00:10:20 <georges> ah
00:10:27 <dmwit> In fact, I suspect that the implementation doesn't even bother with atomic swaps or anything like that. Just boring old read and set instructions.
00:10:50 <c_wraith> yep
00:11:29 <dmwit> Just "replace the function pointer with one that says 'wait!', do some computation, then replace the function pointer with one that says 'here's the answer lol'".
00:11:56 <georges> :)
00:13:52 * hackagebot vector-algorithms 0.6.0.1 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.6.0.1 (DanDoel)
00:13:52 * hackagebot egison 3.1.0 - The world's first language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.1.0 (SatoshiEgi)
00:16:15 <jle`> the purity is that data structures won't actually ever change
00:16:37 <jle`> so you don't have to worry about reading data in the wrong order and getting different data
00:16:45 <jle`> if someone changes it before someone is supposed to read it
00:16:56 <jle`> or if someone tries to read it at the wrong point in the act of changing it
00:17:36 <jle`> in an impure lazy language, you have to worry about that
00:17:38 <chemuduguntar> I've created a trivial data type ( data Vector2 = Vector2 Int Int) - what's the easiest/ correct way of operator overloading in haskell for e.g. + :: Vector2 -> Vector2 -> Vector2
00:18:00 <dmwit> instance Num Vector2 where Vector2 a b + Vector2 a' b' = ...
00:18:12 <c_wraith> the implementation *does* rely on pointer updates being atomic.
00:18:49 <jle`> :t (+)
00:18:49 <lambdabot> Num a => a -> a -> a
00:18:50 <c_wraith> err, pointer *writes* being atomic, to be precise about it.
00:18:59 <jle`> that means that (+) will work on anything that is a Num
00:19:02 <c_wraith> No reading half the previous pointer and half the new pointer.
00:19:05 <jle`> (a Num is like an OOP interface)
00:19:15 <dmwit> jle`: wut
00:19:17 <c_wraith> Not really much like OOP
00:19:18 <jle`> so all you have to do is make your Vector2 a Num...make it match the interface
00:19:26 <jle`> so it'll overload
00:19:29 <jle`> is that ok? :|
00:19:52 <jle`> darn
00:20:04 <c_wraith> making your own types instances of existing classes is a good thing
00:20:30 <jle`> i mean, an ok explanation
00:20:34 <c_wraith> .. assuming the semantics of the class are compatible with the semantics of your type
00:21:04 <c_wraith> Can you meaningfully implement the required parts of Num for your type?  Then you probably should.
00:21:45 <dmwit> Well. The correct way is probably to use something like vector-space. But the easiest way is to implement Num.
00:21:54 <jle`> you need to also implement (*) if you want it to be a num
00:22:14 <jle`> otherwise scary things happen
00:23:40 <chemuduguntar> is the term operator overloading even a thing? i just copied it from my c++ brain
00:24:19 <dmwit> Sort of, though things are both  more restrictive and less restrictive in Haskell than in C++.
00:25:08 <jle`> operators don't have any special overloadability over normal functions
00:25:09 <dmwit> More restrictive: the type you give the overloading must conform to a predetermined schema. Less restrictive: you can overload any name you like, operator or otherwise, not just the magical few chosen by the language syntax writer.
00:25:39 <chemuduguntar> so you can do things like v1 `foo` v2
00:25:40 <dmwit> I'm sure whatever tutorial you're reading to learn Haskell will have a more than adequate section on type classes, which you should read nowish.
00:26:04 <jle`> the idea is that when you specify something like Num a in your type signature, it means that you can (+), (*), (-), negate, abs, etc. that a
00:26:16 <jle`> and it is the responsibility of that a to implement its own way of handling those functions
00:26:42 <jle`> so if I wanted to define a type MyNum, and I wanted to make it a Num, I would have to implement by hand all of those functions
00:26:48 <jle`> but I could really implement them "however i want"
00:27:03 <jle`> that's where the 'overloading' comes in
00:27:25 <jle`> where some libraries implement their (+), (-)'s, etc. in weird ways
00:27:32 <jle`> that allow for some expressiveness kinda maybe.
00:27:41 <dmwit> > (cos^2 + sin^2) 30
00:27:42 <lambdabot>   No instance for (GHC.Show.Show a0)
00:27:42 <lambdabot>    arising from a use of `M7849086379325...
00:27:48 <dmwit> > (cos^2 + sin^2) 30 :: Double
00:27:49 <lambdabot>   No instance for (GHC.Num.Num
00:27:50 <lambdabot>                     (GHC.Types.Double -> GHC.T...
00:27:55 <jle`> that is, libraries provide types that implement (+) (-) etc.. in weird ways.
00:27:56 <dmwit> too bad
00:28:30 <jle`> but as long as the type is declared to be a Num, you are allowed to use (+) etc.
00:28:34 <jle`> if it isn't, then the compiler yells at you.
00:28:54 <jle`> and that's good, because if it didn't yell at you, the code probably woudln't work anyway
00:29:14 <jle`> *if it was set up to not yell at you
00:39:33 <xintron> Reading Learn you a Haskell and saw the following (not yet explained): \l@(x:xs) -> (x,length l). What does the l@(x:xs) mean? Does it take the first element of each sublist and assign to x, keeping l as the full list?
00:40:11 <c_wraith> xintron: that's what it means.
00:40:19 <xintron> In other words, the following would do the same? \x -> (head x, length x)
00:41:00 <c_wraith> not exactly the same thing, but the only difference is how it will crash if it's given an empty list
00:41:10 <c_wraith> > head []
00:41:11 <lambdabot>   *Exception: Prelude.head: empty list
00:41:28 <c_wraith> > (\(_:_) -> ()) []
00:41:29 <lambdabot>   *Exception: <interactive>:3:2-13: Non-exhaustive patterns in lambda
00:41:33 <redtricycle> So what does ||| mean? hard to google for
00:42:06 <c_wraith> redtricycle: it's an operator defined in a library you're using.  Look it up in the library docs
00:42:14 <redtricycle> ah
00:42:20 <redtricycle> using xmonad
00:42:21 <xintron> c_wraith, thanks for the clarification. I'm guessing that the non-head way is more efficient as well?
00:42:43 <c_wraith> xintron: maybe slightly, but the difference should be pretty trivial.
00:43:06 <c_wraith> redtricycle: ah, then there's a lot of library to check.  Try searching in hoogle or hayoo
00:43:11 <xintron> ok. Thanks for the clarification :)
00:43:23 <geekosaur> redtricycle, http://xmonad.org/xmonad-docs/xmonad/XMonad-Layout.html#v:-124--124--124-
00:43:36 <dmwit> redtricycle: There's also #xmonad. =)
00:44:17 <dmwit> > let l@(x:xs) = [] in (x, length l)
00:44:18 <lambdabot>   (*Exception: <interactive>:3:5-17: Irrefutable pattern failed for pattern l...
00:44:25 <apples> hi, i have a couple questions about this GADT. what's the best way to store a mapping between String and Expr a (where a can be either Int or String here), and how do i perform substitution on all instances of Var in an Expr a using such a mapping? http://lpaste.net/96590
00:44:28 <dmwit> > let x = [] in (head x, length x)
00:44:29 <lambdabot>   (*Exception: Prelude.head: empty list
00:44:45 <dmwit> But more importantly...
00:44:46 <redtricycle> geekosaur: aaah, thanks
00:44:58 <dmwit> > let l@(x:xs) = [] in length l
00:44:59 <lambdabot>   *Exception: <interactive>:3:5-17: Irrefutable pattern failed for pattern l@...
00:45:05 <dmwit> > let l = [] in length l
00:45:06 <lambdabot>   0
00:45:20 <geekosaur> unfrortunately that definition won't tell you much; basically it's a "smart" switch that remembers what state it is in. mod-space toggles the switches in the active path of the layoutHook to switch between possible layouts
00:46:07 <geekosaur> ("active path" meaning that ifyou have something like onWorkspace in your layoutHook, it won't pay any attention to layouts for different workspaces)
00:46:17 <dmwit> apples: Store a mapping between String and Either (Expr Int) (Expr String) or similar.
00:47:14 <apples> well, i will eventually have more than just those two..is there a better way besides using a sum type?
00:47:14 <dmwit> apples: For substitution, you'll need to think about what you want to do when you're expecting to get a String variable and find your map has an Int one instead (and vice-versa).
00:47:20 <adnap> apples: http://hackage.haskell.org/package/text-1.0.0.0/docs/Data-Text.html#v:replace
00:47:45 <dmwit> adnap: Did you look at apples' paste?
00:48:38 <apples> for substitution, i'm thinking i'd have a signature like Mapping -> Expr a -> Maybe (Expr a) -- i don't want to worry about distinguishing the two possible errors atm
00:48:45 <dmwit> apples: There is not really a better way than using a sum type. However, your sum type can be more sophisticated than Either, if necessary. =)
00:48:46 <adnap> dmwit: Yes
00:49:13 <apples> adnap, i don't think that will help me very much
00:49:32 <dmwit> apples: Yes, using Maybe seems like a fine strategy.
00:50:51 <adnap> apples: Sorry, I didn't read carefully.
00:51:40 <apples> i'm not sure how the function would look though. say i have subst m (Var s) = ... and i perform a map lookup. how do i check the `a` in my Expr a is the same type as the value in my map?
00:51:56 <dmwit> By looking at the tag of the Either.
00:52:26 <apples> right, that's for one of the two
00:52:43 <apples> but how do i know which tag is correct?
00:52:47 <dmwit> Ah, I see what you're complaining about.
00:53:17 <adnap> What is the type of 's' in '(Var s)'?
00:53:18 <dmwit> One way would be class Subst a where subst :: Mapping -> Expr a -> Maybe (Expr a)
00:53:29 <dmwit> adnap: String
00:53:30 <apples> adnap, String
00:53:55 <adnap> Oh, I see.
00:53:57 <dmwit> apples: Then you would have two instances, one for String and one for Int; and in those instances, you know the other type in question.
00:54:21 <apples> dmwit, aha! i like that. thanks
00:56:10 <dmwit> apples: If you want to be really fancy, you deBruijn index your variables and use even more GADTs to have a type-level mapping from indices to types. Then you can be statically sure that your mapping has expressions of the appropriate type when you do your lookup.
00:56:14 <dmwit> But that's a *lot* more work.
00:57:10 <apples> sounds pretty cool though. is there a place to read up more about that?
00:57:19 <dmwit> looking it up now
00:58:32 <dmwit> www.monoidal.net/papers/qhaskell.pdf‎
00:59:30 <dmwit> bedtime
00:59:43 <apples> awesome, i'll give this a read after i finish it the other way. thanks again, dmwit
01:43:58 * hackagebot flock 0.3.1.6 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.3.1.6 (ErikHesselink)
01:44:48 <natarr> Hey im having trouble understanding some syntax and wondering if someone could help me out...specifically an operator that looks like " ^: "
01:50:57 <tdammers> natarr: operators are functions, too
01:51:26 <tdammers> except that they use infix syntax instead of prefix, and precedence and fixity rules are applied
01:51:42 <tdammers> what exactly is your problem?
01:53:55 <natarr> @tdammers sorry, my client keeps crashing. I'm seeing it in a datatype: data ParseTree n t = Leaf t | n :^ [ParseTree n t]
01:53:55 <lambdabot> Unknown command, try @list
01:54:17 <tdammers> ah, I can see how that is confusing
01:54:32 <tdammers> OK, let's consider this data definition:
01:54:50 <tdammers> data ParseTree n t = Leaf t | Branch n [ParseTree n t]
01:54:58 <tdammers> straightforward, right?
01:55:00 <natarr> mmm
01:55:12 <tdammers> now let's use a different name for Branch
01:55:23 <natarr> Ahh, so is it like shorthand?
01:55:24 <tdammers> data ParseTree n t = Leaf t | (:^) n [ParseTree n t]
01:55:26 <natarr> boom
01:55:32 <ReinH> heh smiley face
01:55:55 <tdammers> ReinH: I once used >:-> for a really evil operator
01:55:57 <natarr> you have no idea how long i was struggling with that
01:56:05 <tdammers> heh
01:56:32 <tdammers> you just need to realize that operator syntax is also valid in patterns and constructors
01:57:19 <natarr> yup it just didn't click till now
01:57:27 <natarr> thanks a ton
01:57:35 <tdammers> np
02:04:17 <ReinH> I like :> for Cofree
02:04:54 <ReinH> er :<
02:05:17 <t7> why is bytestring encode (Int64, (Float, Float), (Float, Float)) making a 45 byte string?
02:05:29 <t7> > 8 + 2*4 + 2*4
02:05:30 <lambdabot>   24
02:06:03 <t7> does it have to track which endian or something?
02:07:27 <t7> wtf float is 13 bytes
02:09:01 * hackagebot bumper 0.5.1.2 - Automatically bump package versions, also transitively.  http://hackage.haskell.org/package/bumper-0.5.1.2 (ErikHesselink)
02:13:00 <danilo2> Hello! I've noticed, that Distribution.InstalledPackageInfo.InstalledPackageInfo does not have got field bugReports, when the Distribution.PackageDescription.PackageDescription does have such field. Is this a bug or am I missing something?
02:14:02 * hackagebot case-insensitive 1.1.0.2 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-1.1.0.2 (BasVanDijk)
02:24:03 * hackagebot blaze-markup 0.5.1.6 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.5.1.6 (JasperVanDerJeugt)
02:25:59 <holoed> Has anybody used the wiring pi (Raspberry Pi Lib) from Haskell? And published the FFI files?
02:29:31 <holoed> What's the best tutorial for linking to an exported function from a linux shared library ?
02:34:04 * hackagebot blaze-html 0.6.1.2 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.6.1.2 (JasperVanDerJeugt)
02:40:43 <Skola> (\n -> n * 2 + 1) <$> [1..] seems faster than [1,3..]
02:40:47 <Skola> Why is this?
02:41:31 <dEPy> Is it racism if I preffer to hire someone who knows erlang better than rails  for  rails project rather than someone that knows mostly rails.
02:41:51 <dEPy> ?
02:42:24 <dEPy> or what should I call this... languageism or smth
02:42:36 <Kinnison> railsism
02:42:41 <dEPy> lol
02:43:00 <helmut> hi. is it a bug that the haskell-src-exts package does not declare a dependency on happy? (configure errored out here, but after installing happy it works)
02:43:03 <dEPy> Unfortunatelly it's not my decision. But I think we're hiring a rails guy. :/
02:43:50 <skypers> hey, who knows reactive-banana here?
02:44:10 <skypers> I’m trying to make my own FRP lib using banana, but there’s some thinks I don’t get
02:44:22 <supki> helmut: no, you can't depend on executables in cabal
02:44:26 <skypers> like how to build an Event?
02:44:28 <helmut> supki: thx
02:46:03 <skypers> constructing Behavior is quite okay for me
02:46:26 <skypers> we can use pure for constant behavior, and stepper to apply a stream of events on a value
02:46:32 <skypers> and then get a behavior
02:47:23 <dcoutts_> helmut, supki: package can declare deps on build tools, using the "build-tool" field. However, cabal-install does not currently handle those kinds of deps automatically.
02:49:07 <tdammers> dEPy: idk for Rails, but for PHP, I'd prefer someone who hates PHP over someone who is deeply into it
02:49:49 <zomg> tdammers: I'd rather have someone who doesn't hate things because they're not perfect =)
02:50:01 <tdammers> zomg: PHP transcends "not perfect"
02:50:18 <tdammers> Python is "not perfect". JavaScript is "not perfect". Even Haskell is "not perfect"
02:50:26 <Feuerbach> helmut: see also https://github.com/haskell-suite/haskell-src-exts/issues/14 and https://github.com/haskell/cabal/issues/220
02:50:27 <tdammers> but PHP is in a different boat altogether
02:50:31 <zomg> well you get the point hopefully... :D the language does some things easily but it has its own set of... "peculiarities"
02:50:39 <zomg> hating it is kind of silly.
02:50:49 <tdammers> well sure, hate is a bit exaggerated
02:50:59 <zomg> I get the sort of hating it as a joke thing but there are people who literally could rage about it for hours
02:51:03 <tovarish> lambda calculus is perfect
02:51:15 <tdammers> tovarish: then go program in it, by all means
02:51:28 <tovarish> tdammers, no it's just a toy
02:51:33 <tdammers> :D
02:51:58 <tdammers> zomg: what I mean is that someone who really loves PHP obviously doesn't see why it is so horribly inappropriate for so many things
02:52:11 <zomg> dEPy: are you looking to do a longer term hire or? I might be up for some short term stuff
02:52:18 <zomg> tdammers: yep :)
02:52:25 <mangaba_leitosa> how can I see the module search path used by ghc?
02:52:46 <eplawless> but what if you love PHP partly out of nostalgia, and partly because it's broken in really hilarious ways?
02:52:46 <tdammers> doing things right is almost impossible in PHP; you have to settle for something around the "80% correct" mark most of the time
02:53:09 <zomg> define "doing things right"
02:53:11 <eplawless> I think there are legitimate reasons to love PHP
02:53:20 <mangaba_leitosa> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/separate-compilation.html#search-path only says that the concept of the search path exists, but no word about how to get to it  :-(
02:53:25 <zomg> eplawless: one thing certianly is it's super easy to deploy for simple things
02:53:42 <tdammers> zomg: I could give a few examples
02:53:51 <tdammers> zomg: take error handling
02:54:03 <zomg> There's a lot of efforts to make that more sane nowadays
02:54:05 <Twey> I've never met someone who really loves PHP
02:54:27 <eplawless> Look at how great this operator is! http://php.net/manual/en/language.oop5.paamayim-nekudotayim.php
02:54:36 <zomg> Literally the best
02:54:38 <tdammers> the thing is, getting error handling right in PHP requires a lot effort, and even then you won't get to 100%
02:54:53 <Twey> I've met people who really love Web programming, and use PHP for it for various reasons (it's the only thing they know, it's what their server supports, it lets them smoothly transition from plain HTML, …)
02:54:53 <tdammers> and that's not because error handling is inherently unsolvable
02:55:01 <tdammers> it's just inherently unsolvable in PHP
02:55:16 <tdammers> there are lots of arguments for PHP
02:55:16 <zomg> Dunno, I've never really had any problems with that so I can't really say
02:55:17 <tomejaguar> Is there a standard way to add new 'deriving' ability to GHC?
02:55:37 <Twey> But I've never met someone who knows a bunch of different programming languages, has done Web programming proficiently in all of them, but would still choose PHP if free from all constraints
02:55:38 <dEPy> zomg: at first short period but if it works out fine we'd like to hire that person for full time
02:56:00 <tdammers> for starters, there are three different error handling mechanisms in PHP
02:56:02 <tdammers> three.
02:56:06 <eplawless> Twey, what about Facebook and Yahoo?
02:56:09 <skypers> tomejaguar: do you know GeneralizedNewtypeDeriving?
02:56:16 <tdammers> and you can make some effort in unifying them, but you'll never get to 100%
02:56:25 <zomg> The thing is you don't have to
02:56:37 <skypers> tomejaguar: or StandaloneDeriving
02:56:41 <tomejaguar> skypers: I don't think that's what I want.
02:56:47 <tomejaguar> Ah I don't know about StandaloneDeriving
02:56:49 <tomejaguar> What's that then?
02:57:03 <eplawless> I'm not seriously advocating for using PHP in any setting ever, but I bet someone could make an argument
02:57:05 <Twey> eplawless: They use PHP for backwards compatibility; in the case of Facebook, they compile their ‘PHP’ to C++, use other languages where possible, and are investing a lot of effort into programming-language development
02:57:11 <skypers> standalone deriving statements
02:57:11 <tomejaguar> I want to be able to derive Contravariant, Profunctor and ProductProfunctor instances.
02:57:19 <tomejaguar> skypers: Oh right yeah I know about that.
02:57:31 <tdammers> zomg: but I *want* to. If something fails in my web application, I want to log it as an error and return a 500 response
02:57:41 <eplawless> Twey, but PHP has moxie
02:57:44 <tomejaguar> But I want to enlarge the set of things that GHC can derive.  For example there are extensions to derive Functor and Foldable.
02:57:51 <skypers> well, deriving a Profonctor might not be as trivial as you expect it to be?
02:57:56 <zomg> tdammers: that's just a matter of telling php to log errors and it actually does that out of the box then
02:58:04 <tomejaguar> skypers: but it is :)
02:58:19 <dEPy> zomg: but we want a freelancer because we work remotely
02:58:21 <Twey> eplawless: What's that?
02:58:24 <tomejaguar> It's completely trivial in the same way that Functor and Contravariant are
02:58:27 <mangaba_leitosa> [R] how can I see the module search path used by ghc?
02:58:38 <skypers> so GHC should already able to do that
02:58:38 <tdammers> zomg: sort of, kind of, but I can't hook into all of them
02:58:50 <skypers> deriving instance Profunctor YourStuff
02:58:53 <skypers> have you tried?
02:59:03 <Twey> mangaba_leitosa: If you pass the verbose flag you can see what it looked for, I think
02:59:07 <zomg> tdammers: you don't have to hook into all of them, as I said it does that by default as long as you just configure the error log
02:59:19 <eplawless> Twey, http://dictionary.reference.com/browse/moxie?s=t :D :D :|
02:59:25 <tomejaguar> skypers: GHC doesn't support it.  It's trivial in practice, but it's just not implemented.
02:59:36 <skypers> I see
02:59:38 <tdammers> zomg: errors, exceptions, return values, and globals wrapped in some sort of accessor function?
02:59:38 <skypers> well
02:59:42 <yesthisisuser> I am reading the Idris tutorial.. and my only question is "why aren't we funding this?" hehe. no but seriously, what does Haskell have that Idris is not capable of?
02:59:42 <tdammers> zomg: I don't think so
02:59:46 <Twey> eplawless: Ah :þ
02:59:58 <Twey> eplawless: (don't use that dictionary; it's terrible)
03:00:08 <tomejaguar> So I wonder how to implement it.
03:00:10 <Twey> yesthisisuser: Did anybody say it did?  :þ
03:00:16 <skypers> well, just write the instance then?
03:00:25 <tomejaguar> Yeah, problem is I have about ten of these things :)
03:00:27 <zomg> tdammers: errors and exceptions if unhandled all show up in the logs, return values should be handled by your code anyway and if not handled, your code probably would produce an error which in turn gets logged in the end
03:00:31 <skypers> Profunctor are not really wide-spread in libraries
03:00:38 <tomejaguar> Yeah that's a shame
03:00:38 <Twey> yesthisisuser: If Haskell has something Idris is lacking, you should probably tell edwinb.  I think he'd rather it didn't.  :þ
03:00:42 <skypers> I think it’s quite okay it’s not in GHC core
03:00:46 <mangaba_leitosa> Twey: thanks. It seems that 'ghc -v' it still doesn't list them
03:00:49 <yesthisisuser> Twey: well, then why doesn't Haskell support dependent types?
03:00:50 <skypers> not really, tomejaguar
03:01:02 <tomejaguar> I take it back about ProductProfunctor though.  Arguably there are two consistent definitions for the instance.
03:01:03 <skypers> except edwardk, I don’t know anyone using Profunctors
03:01:03 <yesthisisuser> Twey: is it because of non-strictness?
03:01:08 <tdammers> zomg: return values are wrong anyway, because they make error handling an opt-in thing instead of opt-out
03:01:09 <Twey> yesthisisuser: But Idris is new and in flux, and sometimes people discover issues with it.
03:01:10 <tomejaguar> skypers: Now you know two :)
03:01:17 <skypers> what do you use them for?
03:01:17 <tdammers> that is, you have to make an active effort to detect them
03:01:20 <skypers> I’m curious
03:01:24 <tomejaguar> My database library is heavily reliant on them.
03:01:25 <edwardk> skypers: i spent the last week talking to folks who use them, just not in haskell
03:01:40 <skypers> because using covariant and contravariant at the same time is quite hard for me to imagine situations
03:01:47 <tdammers> either way, it's completely ridiculous to have three incompatible error handling systems
03:01:50 <zomg> tdammers: well yeah, it's sort of how things just go with languages other than haskell :D
03:01:50 <skypers> edwardk: ocaml?
03:01:56 <Twey> yesthisisuser: Historical reasons, mostly.  Haskell supports doing most things you could do with dependent types.
03:02:00 <edwardk> skypers: nah, mostly real category theory =)
03:02:06 <tomejaguar> edwardk: Who were they?
03:02:11 <mangaba_leitosa> Twey: ghc -v says that it read /usr/lib/ghc-7.6.3/package.conf.d/package.cache , but doesn't list the paths
03:02:19 <skypers> tomejaguar: do you have an example of your Profunctor uses?
03:02:28 <Twey> yesthisisuser: There's also still some research to be done on compiling dependent types to efficient code (which is being done in Idris, amongst other things)
03:02:40 <tdammers> zomg: not really. Python? consistent. Java? consistent. C#? consistent. D? consistent. C++? uhm, no, but C++ is a monster anyway/.
03:03:15 <Twey> tdammers: http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
03:03:25 <edwardk> skypers: mike johnson, jeremy gibbons, robert rosebrugh, zinovy diskin, etc.
03:03:26 <yesthisisuser> Twey: ok.. interesting.. it almost feels like the syntax of Idris is the future of Haskell.
03:03:29 <skypers> Profunctors are really too abstract for me up to know; they’re too damn hard to imagine a use case
03:03:47 <Entroacceptor> Twey: I know people who know other languages but refuse to do web programming in anything but php
03:03:47 <skypers> ok edwardk
03:03:48 <Twey> yesthisisuser: Maybe it is.  I'd certainly like that.  It won't happen until Idris has a few more years under its belt, though.
03:03:56 <skypers> and talking about profunctors
03:04:02 <benj_> I love how there are interleaved conversations about the benefits of PHP and Idris. I just don't know which one to choose now.
03:04:05 <Twey> Entroacceptor: For what reasons?
03:04:09 <tdammers> Twey: yes, I know - it's different though
03:04:12 <skypers> it’s curious how google knows quite a few about them :)
03:04:14 <companion_cube> Entroacceptor: Stockholm syndrom
03:04:15 <yesthisisuser> Twey: i mean it is refreshing to not have to deal with 100+ GHC extensions.. hehe
03:04:17 <Entroacceptor> "PHP is great"
03:04:17 <edwardk> skypers: (->)
03:04:27 <Twey> tdammers: Only in that the most common one in PHP is ridiculous :þ
03:04:32 <companion_cube> "PHP is allcaps", maybe
03:04:32 <tdammers> Twey: Haskell's failure modes at least have some logic to them, and the type system mostly has your back
03:04:33 <skypers> (.) . (.) . (.) ?
03:04:34 <tomejaguar> skypers: OK so imagine I have a database query that has type 'Query (Wire String, Wire Int)', that is, a query with a string column and an int column.  (Wire basically means column).  Then I want to run it.  I know how to convert a 'Wire Int' (i.e. Int column) to a [Int], and I know how to convert a 'Wire String' to a [String].  These are 'QueryRunner (Wire Int) Int' and 'QueryRunner (Wire String) String'.  These are profunctors.  They are also prod
03:04:36 <skypers> or something like that
03:05:39 <Twey> Entroacceptor: There was a guard in my initial claim: « … who knows a bunch of different programming languages, has done Web programming proficiently in all of them … » :þ
03:05:43 <skypers> tomejaguar: ok, but hm
03:05:49 <skypers> what do you feed dimap with?
03:05:50 <zomg> tdammers: I'm pretty sure if you don't check your return values in java or python you could end up with something unexpected. Eg. when working with databases, possible null values and such
03:06:00 <tdammers> no
03:06:15 <Twey> tomejaguar: You got cut off after ‘They are also prod…’
03:06:16 <tdammers> if you try to connect to a database in python, and it fails, it'll throw
03:06:21 <tomejaguar> Twey: thanks
03:06:35 <tdammers> you can choose to catch, or let it bubble
03:06:35 <tomejaguar> They are also product profunctors because I can "multiply" them and get 'QueryRunner (Wire String, Wire Int) (String, Int)' allowing me to convert my 'Query (Wire String, Wire Int)' to '[(String, Int)]'.
03:06:45 <tdammers> but sweeping it under the rug takes active effort
03:06:46 <tomejaguar> skypers, Twey: ^^
03:07:29 <zomg> tdammers: maybe connecting, but say you do a query which doesn't return anything.. also in Java, unchecked nulls are a pretty common bug, NullReferenceExceptions are pretty common with java apps =)
03:07:30 <skypers> ok so profunctors imply 4 typevariables then
03:07:33 <skypers> btw:
03:07:35 <skypers> https://www.google.com/?gws_rd=cr&ei=uFygUqPaD8PDyQO_ooCwBQ#q=profonctor&safe=off
03:07:43 <tomejaguar> If I have my 'QueryRunner (Wire String, Wire Int) (String, Int)', then I can give rmap '(String, Int) -> Foo' and get a 'QueryRunner (Wire String, Wire Int) Foo' (just by mapping over the resultant list'
03:07:51 <skypers> it’s quite… a poor profonctor-base :D
03:07:52 <tomejaguar> skypers: profunctors have 2 type variables.
03:07:55 <tdammers> zomg: if it returns an empty result set, then that's what you'll get, but that's not an exception
03:08:05 <tdammers> and you don't normally have to check for that
03:08:07 <skypers> tomejaguar: yeah well I mean dimap
03:08:15 <tdammers> your code simply should be able to handle an empty collection
03:08:18 <skypers> dimap uses 4
03:08:28 <skypers> iirc, it’s:
03:08:32 <tdammers> but if the query is malformed, or the SQL server signals an error, then the query throws
03:08:57 <skypers> dimap :: (Profunctor p) => (a -> b) -> (c -> d) -> p b c -> p a d
03:08:58 <skypers> right?
03:09:00 <tomejaguar> I can also have '(Wire String, Wire Bar, Wire Int) -> (Wire String, Wire Int)' just by column projection, and I can lmap that to get ''QueryRunner (Wire String, Wire Bar, Wire Int) Foo'
03:09:08 <tomejaguar> skypers: lmap + rmap = dimap
03:09:10 <zomg> tdammers: I don't know if you've always worked with programming gods or something, but code that doesn't check nulls correctly in Java is a common thing in my experience
03:09:16 <tomejaguar> lmap f . rmap g = dimap f g
03:09:43 <skypers> so if you weren’t using Profunctors, would it be less convenient to use?
03:09:54 <skypers> :t dimap
03:09:55 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
03:10:00 <skypers> yeah I was right
03:10:14 <tomejaguar> The profunctor itself only has two type variables
03:10:27 <skypers> @src (->) dimap
03:10:27 <lambdabot> Source not found. Are you on drugs?
03:10:27 <tdammers> zomg: yes, I know, and that's one of the things where I consider Java broken
03:10:34 <skypers> @src dimap (->)
03:10:34 <lambdabot> Source not found. It can only be attributed to human error.
03:10:38 <Twey> What's the difference between a profunctor and a bifunctor?
03:10:40 <tdammers> zomg: that's kind of orthogonal to error *handling* though
03:10:51 <skypers> Twey: profunctors are covariant in the second parameter
03:10:52 <Twey> Oh, never mind
03:10:56 <skypers> and contravariant in the first one
03:10:59 <tomejaguar> If I didn't use Profunctor/ProductProfunctor I would have to have a lot of adhoc functions which do the same thing, rather than just use the Profunctor/ProductProfunctor interface.
03:10:59 <Twey> Yeah, just saw it
03:11:07 <tdammers> zomg: the problem there is that all user-defined types in Java are nullable, and you can't do anything about it
03:11:15 <tomejaguar> Also they give a bit of additional type safety since they introduce more parametricity
03:11:23 <tdammers> zomg: so you have to check, or have the runtime throw NullReferenceExceptions
03:11:36 <skypers> ok so (->) is a Profunctor
03:11:54 <skypers> that means, if we have two functions like (+1) and (show), we can… what? :D
03:12:03 <skypers> :t dimap (+1) show
03:12:04 <lambdabot> (Num b, Show c, Profunctor p) => p b c -> p b String
03:12:12 <skypers> jesus.
03:12:43 <skypers> it’s not a representative use
03:12:48 <skypers> :t dimap show (+1)
03:12:49 <lambdabot> (Num d, Show a, Profunctor p) => p String d -> p a d
03:12:56 <tomejaguar> :t fmap (+1)
03:12:57 <lambdabot> (Functor f, Num b) => f b -> f b
03:12:59 <esoto> if I reverse the profunctor do I get a confunctor?
03:13:08 <skypers> esoto: confunctor?
03:13:10 <esoto> (badumtish)
03:13:11 <tomejaguar> esoto: That's a great idea.
03:13:40 <tomejaguar> I've got to go, but I hope you all love Profunctors now.
03:14:01 <skypers> :t dimap show (+1) (+)
03:14:02 <lambdabot>     Could not deduce (Num (String -> String)) arising from a use of `+'
03:14:02 <lambdabot>     from the context (Show a)
03:14:02 <lambdabot>       bound by the inferred type of it :: Show a => a -> String -> String
03:14:04 <tomejaguar> Also I'm going to write about them for 24 Days of Hackage, so keep your eyes ope
03:14:10 <Kli_> can anyone help me? http://lpaste.net/5191787150651162624
03:14:25 <skypers> :t dimap show ((+) . show)
03:14:26 <lambdabot>     Could not deduce (Num String) arising from a use of `+'
03:14:26 <lambdabot>     from the context (Show a, Show c, Profunctor p)
03:14:26 <lambdabot>       bound by the inferred type of
03:14:44 <skypers> yeah, too weird for me
03:14:50 <skypers> I don’t even see the use of such a thing
03:14:58 <skypers> and it’s quite the same for Contravariant
03:15:07 <skypers> I understand Contravariant on Predicate
03:15:08 <tomejaguar> > dimap (+1) (++" is a nice number") show $ 10
03:15:09 <lambdabot>   "11 is a nice number"
03:16:00 <skypers> > (++" is a nice number") . show . (+1) $ 10
03:16:01 <lambdabot>   "11 is a nice number"
03:16:20 <skypers> I did the same with less words
03:16:23 <skypers> :–’]
03:16:32 <tomejaguar> Right, for (->) 'dimap f g h = g . h . f'
03:16:40 <skypers> that’s so weird!
03:16:46 <tdammers> "is a nice string if followed by itself" is a nice string if followed by itself
03:17:26 <Kli_> lambdabot: can you hepl me: http://lpaste.net/5191787150651162624
03:17:42 <merijn> skypers: Rather than starting with profunctors, I found it helpful to start with contravariant functors and then realise that a profunctor is a bifunctor where one has been replaced with a contravariant functor
03:18:13 <webserver_define> how to implement haskell with fast cgi?
03:18:14 <merijn> skypers: bifunctor being "(a -> c) -> (b -> d) -> f a b -> f c d
03:18:36 <merijn> skypers: i.e. think of a functor that can map over both sides of an Either
03:18:37 <skypers> tdammers:
03:18:38 <skypers> > fix ("is a nice string if followed by itself"++)
03:18:39 <lambdabot>   "is a nice string if followed by itselfis a nice string if followed by itse...
03:18:47 <skypers> :)
03:19:03 <skypers> merijn: I know contravariant functors
03:19:14 <skypers> I just have hard issues to say “Oh, I could use them!”
03:19:20 <skypers> it’s really too abstract
03:19:26 <skypers> even more than Monoid
03:19:32 <skypers> which are _useful_
03:19:46 <skypers> I don’t see the useful part within contravariant functors, nor profunctors
03:19:57 <webserver_define> Fastcgi + haskell ?
03:20:22 <troydm> webserver_define: http://hackage.haskell.org/package/fastcgi
03:20:27 <merijn> webserver_define: Does it need to be fastcgi?
03:20:40 <webserver_define> merijn, no
03:20:48 <merijn> webserver_define: There is *probably* a fastcgi package somewhere, but most haskell frameworks use their own webserver
03:21:02 <mr-> skypers: some functors simply happen to be contravariant.. One instance of usefulness is the fusion law! ;-)
03:21:24 <skypers> mr-: I just need examples :)
03:21:34 <webserver_define> I just want to use my cpp programs on the web .. some1 said cpp + fastcgi is no good enough .. also i wanted to learn a language .. so a freebsd program gave me your address
03:21:37 <merijn> skypers: I like to think of contravariant functors as "sinks" (i.e. where 'f a' is an 'a consumer')
03:22:01 <skypers> hm
03:22:02 <skypers> sinks?
03:22:04 <identity> Is someone here that considers themselves rather familiar with cmdargs? :)
03:22:06 <merijn> skypers: Which means that contravariant fmap uses "b -> a" to turn an "a consumer" into a "b consumer"
03:22:06 <skypers> contramap length
03:22:11 <skypers> on a String predicate
03:22:20 <skypers> what does it consume?
03:22:27 <skypers> I actually see them as adaptors
03:22:30 <skypers> like
03:22:33 <merijn> skypers: Yes
03:22:37 <merijn> skypers: That's what I was saying
03:22:56 <skypers> “Oh yeah, I have a predicate on a String, so I can get the same predicate on a list of a using length!”
03:22:58 <merijn> skypers: "contramap length" turns an Int consumer into a String consumer, which is similar to an adaptor
03:22:59 <tomejaguar> skypers: Adaptors is a good intuition I think.
03:23:18 <skypers> ok
03:23:28 <skypers> and what’s the intuition for profunctors?
03:23:34 <skypers> pingpong-ing values?
03:23:51 <skypers> well no, they’re not even related
03:23:52 <merijn> If functor is a producer adaptor and contravariant functor a consumer adaptor, then profunctor is a "pipe" adaptor :)
03:24:02 <skypers> ah
03:24:04 <skypers> ohoh
03:24:04 <tomejaguar> exactly
03:24:08 <merijn> i.e. it transforms both the incoming and outcoming side
03:24:15 <skypers> I see
03:24:39 <merijn> skypers: Hence the dimap g h f = g . f . h (or whatever the "correct" order is)
03:24:42 <tomejaguar> Yes very nice explanation.
03:25:06 <skypers> ok
03:25:11 <skypers> indeed
03:25:14 <skypers> I got it now
03:25:16 <skypers> just one finale question
03:25:25 <merijn> skypers: Now profunctors are really more general, but I this initial intuition I found helpful :)
03:25:29 <skypers> why isn’t it in Data.Functor.Profunctor?
03:25:47 <merijn> Ask edwardk :p
03:26:13 <skypers> I don’t actually want to import lens to use profunctors
03:26:24 <skypers> it would be great to move them into Data.Functor :)
03:26:37 <mr-> there's Data.Profunctor, isn't there?
03:26:44 <mr-> in the profunctors package
03:26:53 <bartavelle> heresy ! why wouldn't you want to import lens ? do you realize this means you are not using lens ?
03:26:59 <merijn> skypers: profunctors is a seperate package
03:27:10 <skypers> ok, ok
03:27:20 <skypers> I was looking for in the wrong package
03:39:12 * hackagebot hakyll 4.4.2.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.4.2.0 (JasperVanDerJeugt)
03:45:10 <dert> anyone here using osx 10.9 + macvim for haskell?
03:47:58 <merijn> I'm using 10.8, if that counts? (Probably not :))
03:57:05 <statusfa1led> I have a weird problem with cabal failing to update or get packages (through a proxy)
03:58:07 <statusfailed> cabal requests /packages/archive/00-index.tar.gz, and then gets a 301
03:58:14 <statusfailed> (which is all fine)
03:58:31 <statusfailed> but then wen requesting /packages/index.tar.gz, it fails
03:59:32 <statusfailed> oh, in the first connection it has "Connection: Keep-Alive" and "Proxy-Connection: Keep-Alive"
03:59:50 <statusfailed> then it says "recovering connection to localhost:3128" in the second request
04:00:01 <statusfailed> then: "<socket: 7>: resource vanished"
04:00:28 <statusfailed> so maybe my proxy is closing the connection?
04:01:54 <dert> @merijn unfortunately not. I think mavericks broke my ghc-mod and I can't figure out how to fix it :(
04:01:54 <lambdabot> Unknown command, try @list
04:02:10 <dert>  @merijn unfortunately not. I think mavericks broke my ghc-mod and I can't figure out how to fix it :(
04:02:47 <dert> it works just fine in terminal mode, but for some reason macvim is broke
04:36:03 <mangaba_leitosa> is it normal that a 64-bit haskell program is a bit slower than the same program compiled for 32-bit?
04:36:15 <sachin_> q\
04:37:15 <mangaba_leitosa> (like, 35 seconds vs. 50 seconds execution time?)
04:37:53 <merijn> mangaba_leitosa: That's even normal for C programs
04:38:28 <mangaba_leitosa> merijn: and why? It's the first time I installed a 64-bit Linux, so I decided to benchmark it :-)
04:38:29 <merijn> Well, I'm not sure how much slower, but it's a not unheard of to see 20% slowdown by switching to 64bit
04:38:56 <mangaba_leitosa> merijn: maybe I need to switch back to 32-bit :_)
04:39:01 <merijn> mangaba_leitosa: 64-bit => 64bit pointers => less pointers fit in cache -> inefficiency
04:39:24 <mangaba_leitosa> merijn: aha, makes sense
04:39:50 <merijn> The main reason to switch to 64bit is the address space, not increased speed. In *most* cases 64bit is slower, unless the additional memory lets you compensate for the slowdown
04:40:31 <mangaba_leitosa> merijn: well, I did not hope to get increased speed, but significant slowdown was also not my expectation :-)
04:40:51 <merijn> A roughly 50% slowdown seems a bit on the high side, but I'm unsure how haskell fares
04:41:05 <merijn> mangaba_leitosa: Using String in your code by any chance?
04:41:24 <mangaba_leitosa> merijn: mostly ByteString
04:41:45 <merijn> Might wanna profile and see where the time is spend
04:41:51 <mangaba_leitosa> merijn: and some Double arithmetics, including Random
04:43:23 <mangaba_leitosa> merijn: also, GC stats show 90% productivity for 32-bit, but only 77% productivity for 64-bit
04:46:21 <mangaba_leitosa> merijn: so, the slowdown seems to be GC just because of 64-words and 64-bit pointers, like you said
04:46:43 <Twey> mangaba_leitosa: http://en.wikipedia.org/wiki/X32_ABI
04:46:58 <mangaba_leitosa> merijn: for 64-bit, 38 GB allocated in the heap vs. 20 GB allocated for 32-bit. Double as much, that is
04:47:53 <mangaba_leitosa> Twey: 64-bit native binary, but 32-bit pointers? Can I use this in haskell?
04:48:05 <Twey> mangaba_leitosa: I think so
04:48:41 <mangaba_leitosa> Twey: thanks, will check it out. Does it require a specially recompiled GHC?
04:48:52 <Twey> IIRC GHC can compile via LLVM, and LLVM should be able to compile to x32
04:49:03 <Twey> Not sure how you'd set it up, though
04:49:35 <mangaba_leitosa> didn't try LLVM so far :-)
04:50:40 <gsnedders> mangaba_leitosa, merijn: x86_64 can be quicker because one has more general purpose registers, and one can rely on features like SSE, SSE2, MMX as they are part of the instruction set. x86_64 is one of the few archiectures where the 64-bit impl can be quicker because it has other improvements.
04:51:30 <Toolkit> Hi, I guess you get a lot of people here asking for help for their homework right?
04:51:37 <Twey> Oh, hi gsnedders — you're alive!
04:51:43 <Twey> Toolkit: Not all that many, actually
04:52:03 <Twey> (or at least, not in ways that make it obvious that that's what they're doing :þ)
04:52:09 <Toolkit> ;P
04:52:22 <mangaba_leitosa> gsnedders: not what I can see for my simple haskell program, though. But slowdown I'm observing corresponds to double amount of memory allocated by GHC garbage collector for the 64-bit binary
04:52:26 <Toolkit> Well I liek the honest aproach
04:52:30 <gsnedders> Twey: I am? Oh!
04:53:08 <Twey> gsnedders: I haven't seen you about in years — I thought you'd vanished from the face of the Internet.
04:53:26 <gsnedders> mangaba_leitosa: I don't know so much about GHC's output to comment :)
04:53:38 <gsnedders> Twey: Where did you know me from? I come across too many people in my travels. :)
04:53:45 <Twey> Toolkit: If you have a question about Haskell, we'll answer it.  If the question is ‘here's my homework problem; what's the answer?’ we probably won't.  :þ
04:54:21 <Twey> gsnedders: #linguistics, I think… back when it was better :þ
04:54:59 <Toolkit> I understand that ;)
04:55:04 <gsnedders> Twey: Oh, right!
04:56:03 <gsnedders> Twey: Like, your nick was familiar, just couldn't place it. I was thinking it was probably when I used to be in here a fair bit a number of years back, but #linguistics sounsd more plausible, given the far smaller community. :)
04:57:53 <Bus> can anyone give me an example for data Tree  when the Tree is a generic Tree and not BST? For example, one node can have 0,1,2,3,4... sons? Thank you
04:57:58 <merijn> gsnedders: Sure, I'm not saying 64bit is *never* faster, but the times it's faster is restricted to a very small and specific subset of code
04:58:08 <merijn> gsnedders: General purpose code is almost always slower
04:58:43 <Twey> Bus: There's a ‘rose tree’ in Data.Tree
04:59:33 <merijn> Toolkit: In general no one minds homework questions, as long as they are of the form "I have to achieve A, I did B and expected C, but got D, why?" rather than "I need to do A, tell me how"
04:59:33 <Twey> Which has data Tree a = Node { rootLabel :: a, subForest :: [Tree a] }
04:59:36 <mr-> Bus: data Tree a = Node a [Tree a]
04:59:40 <Bus> Twey: Thank you very mutch
05:00:29 <Toolkit> I guess thats fair. No one should do other peeps homework
05:01:10 <esoto> gwrite(p(0,y,eq(x,1)),[x,y])
05:01:11 <esoto> gwrite(p(0,y,num(1)),[x,y])
05:01:14 <mr-> Dunno.. some peeps might enjoy doing other peeps homework.
05:01:16 <esoto> oops
05:01:20 <Bus> mr-: can you give me an input example?
05:01:25 <Twey> Bus: The usual example you see is data Tree a = Leaf a | Branch (Tree a) (Tree a), with labels only on the leaves; you can generalize that to n children as … | Branch [Tree a]
05:01:39 <mr-> Bus: Node "Foo" [] would be a tree that is a leaf
05:01:55 <esoto> wtf my mouse automatically pastes thing in irc when I use the middle button
05:02:02 <merijn> mr-: Wouldn't want to deny TA's the "pleasure" of deciphering completely confused FP code :)
05:02:09 <Twey> esoto: This surprises you?
05:02:14 <merijn> esoto: middle mouse is traditionally paste in unix terminals
05:02:16 <tdammers> esoto: that's what the middle button is supposed to do in X
05:02:24 <Twey> And all of Linux
05:02:38 <tdammers> Twey: X11, really
05:02:52 <merijn> tdammers: in BSD it works on the console too, not sure about linux, though
05:02:57 <mangaba_leitosa> merijn: interesting. I was using -with-rtsopts=-H640m, and for 32-bit program, this increased the speed somewhat, but with 64-bit, using the lower value -H128m or not using it at all increased speed and GC productivity :-)
05:03:05 <tdammers> merijn: which console? vtty?
05:03:17 <merijn> tdammers: The console console
05:03:34 <esoto> well I'm using windows (cygwin), and I think ubuntu did something else(?)
05:03:38 <crxy111> hi
05:03:48 <Twey> tdammers: I'm pretty sure it does it in older versions of X, too
05:03:56 <merijn> esoto: Be glad you didn't learn this with more embarassing clipboard content :p
05:04:03 <esoto> :P
05:04:26 <Twey> Also the VC (with gpm) and various toolkits running on directfb, at least
05:05:26 <mr-> Bus: as an exercise, you could write a function [a] -> Tree a that turns a list in a (linear) tree
05:05:33 <mangaba_leitosa> merijn: by using lower -with-rtsopts=-H value, I ended up with 35 seconds (32-bit) vs. 39 seconds (64-bit) instead of 35 vs. 50 as was with -H640m
05:06:30 <merijn> mangaba_leitosa: That sounds more reasonable :)
05:11:58 <tdammers> merijn: freebsd has a mouse on the console?
05:13:30 <ginmaniac> Hey, is there a library function like groupByN Int -> [a] -> [[a]]; e.g. groupByN 2 [1..4] = [[1,2],[3,4]] I wasn't able to find one using hoogle
05:13:32 <merijn> tdammers: Sure, why not?
05:13:33 <georges> wasnt there something like readMaybe  in the Prelude of newer versions of GHC?
05:13:41 <merijn> georges: Yes, Text.Read
05:13:49 <merijn> GHC 7.6 and later
05:14:03 <merijn> georges: Eh, well not in Prelude, obviously
05:14:15 <georges> yes :). thanks
05:14:56 <tdammers> merijn: dunno, really... because it's text-mode or sth
05:15:12 <merijn> tdammers: Seems like a poor excuse for no mouse support :)
05:15:23 <tdammers> merijn: point taken
05:16:03 <merijn> tdammers: It supported both serial and USB mouse support on the console as long as I remember (10+ years now? )
05:16:34 <tdammers> fun fun fun... I didn't know that
05:16:48 <tdammers> probably because all the freebsd machines I've ever worked with were headless servers
05:16:57 <merijn> hmm, I can't quite figure out the pipes types I want...every time I think I get close I get stuck...
05:17:45 <merijn> I have a ByteString producer and want to use pipes-parse to first construct a value from it and then switch to construct a different type of values
05:18:01 <merijn> But I'm not quite sure how to get it the way I want..
05:18:38 <merijn> So I have "Producer ByteString m r", "Pipe ByteString Foo m r" and "Foo -> Pipe ByteString Bar m r"
05:19:00 <merijn> But I dunno how to nicely fit them together
05:26:38 <cariveri> Hi. Whats a good tree like structure for when children get replaced often? it seems to much if the whole tree needs to be re-established.
05:27:01 <cariveri> *too much
05:29:51 <merijn> cariveri: You only need to update log n tree nodes
05:30:01 <merijn> i.e. only the nodes between the updated node and the root
05:30:23 <xintron> Oh, so lambdabot is using stunnel instead of adding support for TLS in the source. That's an easy way to solve it! :)
05:31:57 <merijn> Dammit, where's the entire pipes cult when I need their help? >.>
05:32:10 <cariveri> merijn: no sorry. I meant replacing to include removal and creation of new ones.
05:32:18 <quchen> merijn: Retorically asking to ask? :-þ
05:32:26 <quchen> Add an "h" somewhere
05:33:22 <merijn> quchen: Well, I already asked a couple of times, but only got silence in response >.>
05:33:34 <quchen> cariveri: Any update of a single node - modification, addition, removal - is only O(log(n)) steps in a Set or Map.
05:34:01 <merijn> Even less if you use IntMap isntead of Map
05:34:11 <quchen> Why is that?
05:35:15 <merijn> Because max complexity of IntMap is O(min(k,n)) where k is the number of bits in Int
05:35:43 <quchen> And how is that achieved?
05:36:18 <merijn> quchen: The docs have to paper references, I dunno the details from the top of my head :)
05:36:25 <merijn> s/to paper/two paper
05:36:38 <donri> doesn't that mean it's only better (in terms of complexity) if you have more than 2^k keys
05:37:27 <cariveri> merijn: so usually one would not say have a node and can quickly access the parent container to remove this one or to prepend something?
05:37:31 <donri> uuhh
05:37:44 <merijn> donri: No, it's better on many workloads and the worst case is the same as worst case for normal Map
05:38:15 <merijn> donri: IntMap is strictly superior to Map, if you can use Int keys
05:38:34 <donri> merijn: unless you need "size" ;)
05:38:46 <quchen> > maxBound :: Int -- Too small!
05:38:47 <lambdabot>   9223372036854775807
05:39:21 <merijn> donri: True, although that's probably trivial to fix by adding a counter to IntMap
05:39:38 <merijn> donri: Since that only adds constant overhead to every operation :p
05:39:38 <cariveri> merijn: seems you suggest traversing the tree for a task that would be in O(1) in OO-manner
05:39:57 <merijn> cariveri: I'm unsure what that question even means
05:41:27 <triliyn> cariveri: do you know of zippers?
05:41:55 <triliyn> They allow you to make many consecutive local updates without "losing your place" and having to traverse the tree again
05:41:55 <cariveri> triliyn: yes I think. but whats the connection?
05:42:51 <cariveri> triliyn: by zipper you did not mean something like zipWith ?
05:43:37 <triliyn> cariveri: no, I mean a data structure that represents a tree (or list or similar) with a "focused" slot
05:44:11 <merijn> hmm, maybe I just want "myProducer >-> myParser >-> await" to get an "Effect m Foo" and then use that with my parser for the remainder. Although the ">-> await" seems redundant?
05:45:00 <Guest37823> hi
05:45:14 <Guest37823> i was wondering how to simplify this code:
05:45:35 <Guest37823> http://lpaste.net/4096521012147912704
05:45:53 <Guest37823> lines 9 and 10
05:46:12 <Guest37823> I was trying to use a placeholder like (_ e1 e2), but that didn't work
05:46:28 <donri> merijn: but i mean, doesn't that mean that unless you have <k keys, the complexity is always O(k), but to reach that complexity with Map you need b^k keys?
05:46:34 <tinhead> triliyn: Finger trees?
05:46:35 <donri> i'm surely missing something obvious, but alas
05:47:07 <triliyn> tinhead: I have heard of finger trees, but I don't actually know what they are
05:47:19 <tinhead> triliyn: Data.Sequence
05:47:57 <kartoffelbrei`> merijn: have you tried the 'for' function? it seems to fit your 'Foo -> Pipe ByteString Bar m r' type-wise. But I'm not sure if that's what you want.
05:48:03 <cariveri> perhaps I explain: I want to realisze an onClick X (being "connected" with a node) {remove,add new,prepend...}. so far the data Tree = Tree a children where children = [Tree a]
05:48:41 <cariveri> triliyn: so does zipper seem to fit for this?
05:49:30 <merijn> kartoffelbrei: No, because for will execute the effect multiple times
05:49:48 <triliyn> cariveri: sorry, I am addled by morning drowsiness and I'm not sure if zippers are what you want or not
05:49:49 <pavonia> Guest37823: If you really have to get rid of the boilerplate, you might want to look at the uniplate package
05:49:57 <triliyn> Hopefully someone else is more coherent
05:50:21 <merijn> kartoffelbrei: I need to only parse a single Foo to decide which parser to use for the rest of the ByteString stream
05:50:43 <cariveri> triliyn: I wont mind. :)
05:50:50 <merijn> kartoffelbrei: So given my ByteString producer I need to read enough to parse Foo and then switch to my actual parser for the stream
05:51:27 <merijn> kartoffelbrei: Actually, for doesn't even typecheck
05:52:20 <kartoffelbrei> merijn: i didn't try it out, it just looked like it might work. sorry.
05:52:41 <merijn> kartoffelbrei: "Foo -> Pipe" expects another Pipe as the first argument, not a Producer
05:53:10 <triliyn> cariveri: a zipper allows you to kind of save a place in the tree, so that if you make n updates it's O(log n + n) instead of O(n log n), if all the updates are in approximately the same place
05:53:21 <Guest37823> pavonia: thanks!
05:53:32 <pavonia> yw
05:53:55 <triliyn> (would that just be O(n)? I think it would...)
05:55:14 <triliyn> cariveri: I think this is the same asymptotic complexity as you'd get in an imperative language, because you still have to find the node you want to modify
05:55:28 <triliyn> But maybe I'm missing something
05:55:34 <merijn> donri: You don't need b^k keys to reach that with Map, it depends on the distribution of keys in the keyspace
05:55:53 <merijn> donri: You only need b^k keys with uniform distribution, I think.
05:56:10 <merijn> donri: Also, note that that's *worst* case complexity for IntMap, average case is much better
05:56:32 <donri> i think intmap has better constant factors too, but duno
05:57:39 <merijn> donri: So *worst* case you'll have identical performance to Map up to the number of keys needed to reach O(k), after which you're guaranteed better. And the average case and constant factors for IntMap are better than Map
05:58:11 <kartoffelbrei> merijn: i can get it to typecheck by changing Producer to Producer'. But otherwise you are right.
05:58:47 <frx> I think that cariveri doesn't understand that you don't need to copy entire immutable tree just to modify/add/remove a single node
05:58:47 <merijn> kartoffelbrei: At any rate, even if it typechecks it has the wrong semantics
05:58:56 <kartoffelbrei> merijn: yeah
05:59:24 <merijn> Essentially what I need is "feed initial parser until it returns, then use leftovers and the producer feeding into the initial parser to feed the subsequent parser"
06:00:18 <radish> whats the simplest way to divide two integers and get an integer that represents the fractional result rounded away from zero?
06:01:09 <radish> i'm thinking div (a +b -1) b
06:01:27 <radish> or how does div round negative numbers?
06:01:34 <donri> quchen: Int is signed so you have maxBound*2 keys
06:01:36 <radish> b will always be positive
06:01:53 <donri> > fromIntegral (maxBound :: Int) * 2 == 2^64
06:01:55 <lambdabot>   False
06:02:05 <donri> :(
06:02:13 <radish> donri  try 2^64 -1
06:02:21 <radish> 2^ 63
06:02:24 <radish> need sign bit
06:02:28 <mr-> > fromIntegral (maxBound :: Int) * 2 - 2^64
06:02:29 <lambdabot>   -2
06:02:31 <mr-> :-)
06:02:33 <merijn> > abs (fromIntegral (minBound :: Int)) * 2 == 2^64
06:02:34 <lambdabot>   True
06:02:42 <merijn> <- skillz
06:03:15 <donri> why abs
06:03:26 <merijn> Well, I guess it'd work with -2^64
06:03:28 <donri> oh minBound
06:03:42 <merijn> > fromIntegral (minBound :: Int) * 2 == -(2^64)
06:03:43 <lambdabot>   True
06:04:02 <merijn> Didn't pay attention during signed integer ranges in class, huh? ;p
06:04:13 <donri> i haven't finished high school so no
06:04:25 <radish> > fromIntegral (maxBound :: Int) == (2^ 64) -1
06:04:26 <lambdabot>   False
06:04:30 * hackagebot snap 0.13.1.2 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.1.2 (DougBeardsley)
06:04:40 <radish> > fromIntegral (maxBound :: Int) == (2^ 31) -1
06:04:41 <lambdabot>   False
06:04:48 <radish> > fromIntegral (maxBound :: Int) == (2^ 63) -1
06:04:49 <lambdabot>   True
06:04:55 <radish> :D
06:05:02 <tdammers> they teach signed integer ranges in highschool? :X
06:05:13 <radish> tdammers: i should hope so!
06:05:13 <donri> tdammers: no, that's the point :p
06:05:36 <skypers> is there some one that knows how to create a value :: Event a in reactive-banana?
06:05:36 <radish> donri: 2^ (n -1) -1
06:05:49 <radish> the first is for the sign, the second for zero
06:05:52 <skypers> I think we an build Behavior with the stepper function
06:05:59 <skypers> but what’s about Event?
06:06:49 <donri> radish: the point was to show that you get 2^64 keys, ie. include the whole negative space
06:07:56 <radish> > (fromIntegral (maxBound :: Int)) + (fromIntegral (minBound :: Int)) + 1
06:07:57 <lambdabot>   0
06:08:08 <radish> > (fromIntegral (maxBound :: Int)) + (abs (fromIntegral (minBound :: Int))) + 1
06:08:09 <lambdabot>   18446744073709551616
06:08:09 <triliyn> > abs minBound :: Int
06:08:10 <lambdabot>   -9223372036854775808
06:08:26 <radish> > log2 ((fromIntegral (maxBound :: Int)) + (abs (fromIntegral (minBound :: Int))) + 1)
06:08:27 <lambdabot>   Not in scope: `log2'
06:08:27 <lambdabot>  Perhaps you meant `log' (imported from Prelude)
06:08:35 <radish> > log 2 ((fromIntegral (maxBound :: Int)) + (abs (fromIntegral (minBound :: Int))) + 1)
06:08:36 <lambdabot>   Could not deduce (GHC.Float.Floating
06:08:36 <lambdabot>                      (GHC.Integer.Type...
06:08:40 <radish> D:
06:08:46 <radish> someone help me out here!
06:09:13 <triliyn> :t fromIntegral
06:09:14 <lambdabot> (Integral a, Num b) => a -> b
06:09:36 <donri> > maxBound + 1 :: Int
06:09:37 <lambdabot>   -9223372036854775808
06:10:07 <triliyn> > log 2 ((fromIntegral (maxBound :: Int)) :: Double + (abs (fromIntegral (minBound :: Int))) + 1)
06:10:08 <lambdabot>   <hint>:1:94: Illegal literal in type (use -XDataKinds to enable): 1
06:10:21 <triliyn> > log 2 (((fromIntegral (maxBound :: Int)) :: Double) + (abs (fromIntegral (minBound :: Int))) + 1)
06:10:22 <lambdabot>   No instance for (GHC.Show.Show a0)
06:10:22 <lambdabot>    arising from a use of `M3123276639265...
06:10:31 <triliyn> hmm
06:10:40 <donri> :t logBase
06:10:41 <lambdabot> Floating a => a -> a -> a
06:10:44 <donri> :t log
06:10:45 <lambdabot> Floating a => a -> a
06:10:56 <radish> which ones which?
06:11:04 <triliyn> oh, log is natural logaritm I guess
06:11:08 <donri> @src log
06:11:08 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
06:11:15 <triliyn> > logBase 2 (((fromIntegral (maxBound :: Int)) :: Double) + (abs (fromIntegral (minBound :: Int))) + 1)
06:11:16 <lambdabot>   64.0
06:11:17 <donri> log = logBase 10, i think?
06:11:25 <radish> thanks
06:11:28 <triliyn> > log 2.17
06:11:29 <lambdabot>   0.7747271675523681
06:11:36 <triliyn> oh, maybe
06:11:38 <triliyn> > log 10
06:11:39 <lambdabot>   2.302585092994046
06:11:46 <triliyn> ...wait
06:11:51 <skypers> oh no one?
06:11:51 <triliyn> > log e
06:11:51 <radish> > log 999
06:11:52 <k00mi> > log (exp 1)
06:11:52 <lambdabot>   can't find file: L.hs
06:11:52 <lambdabot>   log e
06:11:53 <lambdabot>   1.0
06:12:03 <triliyn> > exp 1
06:12:04 <lambdabot>   2.718281828459045
06:12:11 <triliyn> oh, that explains it
06:14:04 <donri> oh natural, naturally. :p
06:18:48 <benzrf> @ping
06:18:48 <lambdabot> pong
06:18:57 <benzrf> @hoogle Int -> [a] -> [[a]]
06:18:58 <lambdabot> Prelude drop :: Int -> [a] -> [a]
06:18:58 <lambdabot> Data.List drop :: Int -> [a] -> [a]
06:18:58 <lambdabot> Prelude take :: Int -> [a] -> [a]
06:19:04 <benzrf> lame
06:19:57 <triliyn> :t replicate
06:19:58 <lambdabot> Int -> a -> [a]
06:20:11 <benzrf> triliyn: so?
06:21:08 <triliyn> Your signature is a special case of replicate's signature... are you looking for a function that does something specific?
06:21:30 <benzrf> ahihi:
06:21:31 <benzrf> *ah
06:21:34 <benzrf> I'm looking for
06:21:49 <benzrf> split 3 [1, 2, 3, 4, 5, 6, 7] => [[1, 2, 3], [4, 5, 6], [7]]
06:21:59 <triliyn> ah
06:22:16 <triliyn> I think that might be called group in Data.List or something
06:22:23 <BoR0> you can use splitAt recursively
06:22:31 <benzrf> :t group
06:22:32 <lambdabot> Eq a => [a] -> [[a]]
06:22:35 <benzrf> ??
06:22:35 <donri> :t chunksOf
06:22:36 <lambdabot> Int -> [e] -> [[e]]
06:22:40 <benzrf> :D
06:22:47 <donri> @hoogle chunksOf +split
06:22:47 <lambdabot> Could not find some databases: split
06:22:47 <lambdabot> Searching in:
06:22:47 <lambdabot>   .
06:22:48 <benzrf> @where chunksOf
06:22:48 <lambdabot> I know nothing about chunksof.
06:22:53 <donri> @hackage split
06:22:53 <lambdabot> http://hackage.haskell.org/package/split
06:22:58 <benzrf> @src chunksOf
06:22:58 <lambdabot> Source not found. Just what do you think you're doing Dave?
06:23:02 <benzrf> ??
06:23:06 <benzrf> where is chunksOf located?
06:23:12 <donri> Data.List.Split
06:23:12 <benzrf> is it in the haskell platform>
06:23:15 <benzrf> thanks :)
06:23:16 <donri> yes
06:23:23 <donri> yw
06:24:20 <BoR0> cool, a predefined function for that! how can we see the definition of chunksOf?
06:24:43 <mr-> using hoogle
06:24:55 <mr-> http://hackage.haskell.org/package/text-1.0.0.0/docs/src/Data-Text.html#chunksOf
06:24:57 <jophish> Yo yo yo
06:25:20 <jophish> I have a custom monad: type M a = Mem -> (a, Mem)
06:25:30 <jophish> I have return and >>= defined well for this,
06:25:39 <jophish> but I can't figure out how to make it an instance of Monad
06:25:50 <tomejaguar> jophish: That's isomorphic to 'State Mem'
06:25:51 <donri> jophish: you'd need to newtype
06:26:12 <jophish> yeah, I know that, I'm reimplementing things to learn
06:26:14 <tomejaguar> newtype M a = M (Mem -> (a, Mem))
06:26:30 <fizbin> "type" defines a type alias.
06:26:44 <benzrf> :t replicate
06:26:45 <lambdabot> Int -> a -> [a]
06:26:45 <fizbin> You can't declare instances of an alias.
06:26:48 <benzrf> @pl \n a -> sequence (replicate n a)
06:26:49 <lambdabot> (sequence .) . replicate
06:27:04 <jophish> ah, I see
06:27:06 <benzrf> o wait
06:27:08 <benzrf> :t replicateM
06:27:09 <lambdabot> Monad m => Int -> m a -> m [a]
06:27:13 <fizbin> Or rather, you can, but that's the same as trying to define an instance of the thing the alias points to.
06:27:21 <donri> well you can with TypeSynonymInstances, but (r ->) is already a Monad
06:27:44 <donri> plus it'd be orphan
06:27:57 <tomejaguar> Also wouldn't it require FlexibleInstances, or something?
06:28:14 <tomejaguar> Anyway, yeah newtype is the way to go.
06:28:26 <fizbin> In any case, jophish, you want to wrap your type in newtype or data.
06:28:39 <donri> also it has the wrong type to be a monad without newtype
06:28:40 <jophish> fizbin: super, thanks
06:28:51 <jophish> thanks all
06:29:59 <pavonia> jophish: Also try to prove if the monad laws hold for your implementation
06:30:29 <tomejaguar> donri: Technical question: Suppose (->) did not already have a monad instance.  Could I make 'Mem -> (a, Mem)' a monad with FlexibleInstances?
06:31:41 <donri> tomejaguar: kind error :)
06:32:10 <merijn> tomejaguar: You'd need a newtype, but yes
06:32:18 <merijn> tomejaguar: Incidentally, that's just State
06:32:32 <fizbin> Well, State Mem
06:32:55 <merijn> "newtype State s a = State (s -> (a, s))" <-
06:33:06 <radish> > mod 25 (-30)
06:33:07 <lambdabot>   -5
06:33:22 <radish> > mod (-25) 30
06:33:23 <lambdabot>   5
06:33:42 <tomejaguar> donri: Ah right.  merijn: I was asking whether it would be possible *without* the newtype.
06:33:59 <merijn> tomejaguar: No
06:34:13 <merijn> tomejaguar: Monad requires a type of kind * -> *
06:34:14 <tomejaguar> donri: I guess there's no way to even /write/ that because you need something with one parameter :)
06:34:17 <tomejaguar> Yeaph
06:34:33 <benzrf> @pl \(a, b, c) -> a ++ b ++ c
06:34:33 <lambdabot> (line 1, column 9):
06:34:33 <lambdabot> unexpected "c"
06:34:33 <lambdabot> ambiguous use of a non associative operator
06:34:35 <radish> mod 25 30
06:34:38 <radish> > mod 25 30
06:34:39 <lambdabot>   25
06:34:46 <benzrf> @pl \(a, b, c) -> (a ++ b) ++ c
06:34:46 <lambdabot> (line 1, column 9):
06:34:46 <lambdabot> unexpected "c"
06:34:46 <lambdabot> ambiguous use of a non associative operator
06:34:49 <benzrf> ?
06:34:50 <radish> <3
06:34:55 <benzrf> @pl \(a, b, c) -> (a ++ b ++ c)
06:34:55 <lambdabot> (line 1, column 9):
06:34:55 <lambdabot> unexpected "c"
06:34:55 <lambdabot> ambiguous use of a non associative operator
06:34:58 <benzrf> ?!
06:34:58 <lambdabot> Maybe you meant: v @ ? .
06:34:59 <donri> tomejaguar: (Mem ->) will have the right kind but then you get e.g. return :: a -> Mem -> a
06:35:36 <radish> you can put lambdas outside of parenthesis?
06:35:42 <benzrf> radish: well yesthisisuser
06:35:44 <benzrf> *yes
06:35:57 <benzrf> @pl (\(a, b, c) -> a ++ b ++ c)
06:35:57 <lambdabot> (line 1, column 10):
06:35:57 <lambdabot> unexpected "c"
06:35:57 <lambdabot> ambiguous use of a non associative operator
06:36:02 <benzrf> ?!
06:36:02 <lambdabot> Maybe you meant: v @ ? .
06:36:29 <benzrf> w/e
06:40:02 <nooodl> @pl (\(a, b, c) -> a ++ (b ++ c))
06:40:02 <lambdabot> (line 1, column 10):
06:40:02 <lambdabot> unexpected "c"
06:40:02 <lambdabot> ambiguous use of a non associative operator
06:40:15 <nooodl> hum
06:41:47 <mr-> apparently @pl can't do patternmatching
06:42:30 <int-e> right. @pl can't even do tuples very well.
06:42:32 <geekosaur> no, pointfree pattern matching can't really be done since it introduces points. also @pl predates lambdacase
06:42:37 <int-e> @pl \(a,b,c) -> a
06:42:37 <lambdabot> (line 1, column 7):
06:42:37 <lambdabot> unexpected "c"
06:42:37 <lambdabot> ambiguous use of a non associative operator
06:42:52 <tomejaguar> @pl \(a,b) -> a
06:42:53 <lambdabot> fst
06:43:03 <tomejaguar> Maybe pl should be taught to use lens :)
06:43:11 <int-e> uhm ...
06:43:28 <nooodl> yeah i guess there's not even really a sane result for @pl \(a,b,c) -> a
06:43:40 <int-e> tomejaguar: I guess a @pl-lens would be nice.
06:44:07 <tomejaguar> nooodl: @pl \(a,b,c) -> a = view _1
06:44:34 <danilo2> merijn: You've written yesterdays to me (after I asked about something providing mempty without mappend): Pointed, but it's not in the default libraries and it's usefulness is debatable. I'm sory, I had to do something and didnt noticed it. Coudl you please tell me more why it is not usefull?
06:44:55 <danilo2> merijn: And why every Monoid is not always Pointed?
06:45:11 <tomejaguar> danilo2: Monoids are not of the right kind to be pointed
06:45:42 <tomejaguar> danilo2: The usefulness of Pointed is debated because instances cannot be required to satisfy any non-automatic laws.
06:45:58 <merijn> danilo2: There are no laws for Pointed
06:46:10 <danilo2> tomejaguar: Hmm, I do not know Pointed. I was looking only for something providing "empty" function - something like Monoid but without mappend. There is Default, but "default" means something else than "empty"
06:46:12 <merijn> danilo2: So knowing that something is Pointed doesn't really tell you anything
06:46:21 <tomejaguar> If f is Functor and Pointed an interesting law is fmap f . point = point . f, but this is a free theorem.
06:46:26 <merijn> danilo2: Actually, I was confused anyway
06:46:40 <merijn> danilo2: Because Pointed doesn't have mempty, so I think my brain was just misfiring
06:46:49 <tomejaguar> danilo2: What do you want exactly?  I don't think Pointed is so bad ...
06:46:56 <merijn> danilo2: The closest thing to mempty without mappend is Data.Default
06:47:10 <merijn> "class Default a where def :: a"
06:47:49 <merijn> danilo2: What would you do with a class that only provides "empty"?
06:47:54 <danilo2> merijn: I know the best is Default rigt now, but why not to have in Haskell something like FunnyNameForEmpty, with method mempty and tell, that every Monoid is FunnyNameForEmpty ?
06:48:01 <tomejaguar> merijn: Isn't that worse than Pointed, when it comes to laws?
06:48:10 <danilo2> tomejaguar: I've written that couple lines above: I was looking only for something providing "empty" function - something like Monoid but without mappend. There is Default, but "default" means something else than "empty"
06:48:15 <merijn> danilo2: Why *would* it exist?
06:48:17 <mr-> danilo2: do you want Maybe? ;-)
06:48:23 <merijn> danilo2: Is there any useful argument for it's existence?
06:48:26 <danilo2> mr-: no
06:48:33 <merijn> tomejaguar: Default doesn't even pretend to be mathematical
06:48:56 <merijn> tomejaguar: It's worse in terms of lack of laws, but otoh it doesn't pretend to give you anything to reason about
06:48:59 <tomejaguar> danilo2: Can you give us an example datatype and instance??
06:49:06 <tomejaguar> merijn: Does Pointed?
06:49:07 <jophish>  is there an inverse of sequence
06:49:09 <danilo2> merijn: yes - purity! Look, we sometimes need to use mempty on objects - you can imagine lot of objects that could be empty! But not always thwey provide mappend
06:49:21 <jophish> M [a] -> [M a]
06:49:28 <merijn> danilo2: You can't use mempty on anything
06:49:31 <danilo2> merijn: Additional, not every object, which could be empty has default value, so default is something else
06:49:31 <merijn> mempty is a value
06:49:44 <merijn> danilo2: Yes, but how would you use it?
06:49:48 <Bus> how can I convert a RoseTree in a List?
06:50:03 <merijn> Bus: By writing code that appends every item in it to a list? :)
06:50:24 <mr-> Bus: Data.List's Tree is an instance of Foldable. Foldable provides some toList
06:50:29 <mr-> sorry
06:50:33 <mr-> Data.Tree's Tree
06:50:39 <nooodl> jophish: there isn't
06:50:40 <danilo2> merijn: hmmm, simple - for example, I create data Config = Config { files :: [File], ... }
06:50:45 <jophish> I didn't think so
06:50:48 <FireFly> danilo2: bu twhat does "empty" mean, in terms of axioms?
06:51:03 <merijn> danilo2: I mean, if I read "empty" somewhere, what does it tell me?
06:51:11 <danilo2> merijn: and now instance FunnyEmpty Config where mempty = Config { files = mempty, ... }
06:51:20 <merijn> danilo2: And why should I use "empty" for that, instead of whatever data type I need?
06:51:37 <merijn> danilo2: Yes, but what's the point?
06:51:42 <FireFly> In particular, consider how integers form a monoid with both (+) and (*), but with different "empty" values. Which one is right?
06:51:51 <merijn> danilo2: Why not just "emptyConfig = Config { files = [] ...}"?
06:51:59 <danilo2> merijn: It does nto tell you much. It only tells you it is empty. So it dfoes nto have any laws, but If there would be something such as empty it would make some laws together with for example "mappend" creating Monoids
06:52:07 <Bus> merijn: can you give me an example?
06:52:12 <FireFly> (with an associative operation you could formalise the concept of "empty" as identity for the operation, but with no operation, well...)
06:52:18 <merijn> Bus: Of what?
06:52:38 <Bus> code that convert RoseTree in to a List?
06:53:13 <danilo2> merijn: Just because if you change the type in obne place you do not have in another
06:53:16 <danilo2> merijn: brb
06:53:40 <merijn> Bus: No, I'm not being paid to TA students this year and even if I was "give me example code to do this" hardly sounds like a proper question. Maybe someone is willing to help if you show what code you tried and tell us what you 1) expected it to do and 2) what it did instead
06:53:45 <tomejaguar> danilo2: Config is a Monoid, assuming the other fields are appropriate.
06:54:08 <danilo2> FireFly: In terms of axioms? What do you mean?
06:54:39 <danilo2> tomejaguar: Config could be mopnoid f wee assume we can "add" it to something,. but if we cannot, than it is not Monoid
06:54:40 <FireFly> danilo2: what does it *mean* for something to be the empty value?
06:54:44 <merijn> danilo2: Abstraction just because you can is a good way to make all code incomprehensible
06:54:59 <tomejaguar> danilo2: Sure, you just (++) the two 'files' fields.
06:55:09 <merijn> danilo2: Just because you *can* define an abstraction doesn't mean you should. So far all your arguments boil down to "We could define empty for this"
06:55:23 <FireFly> danilo2: for a monoid the meaning of mempty is clear: it's an identity element
06:55:25 <merijn> danilo2: To which the response is "Yes, we could. But we won't unless there's a reason to do so"
06:55:28 <tomejaguar> danilo2: You're going to have to give a more specific example.
06:55:34 <danilo2> FireFly: If something is monoid than it has empty cvalue and can be added. I know what I'm talking about has no so strong laws as Monoids - just asking about it
06:56:11 <merijn> danilo2: The lack of laws is an argument to not do it. The laws of monoid are valuable, you can think of what monoids do and write nicely generic code
06:56:13 <danilo2> tomejaguar: heh, in this example yes, but if field is string ? and it is "name :: String" ? you see, there is no mappend in such configs
06:56:24 <merijn> danilo2: There is no generic code you can write with just a notion of "empty"
06:56:25 <tomejaguar> danilo2: Then what is empty!!??
06:57:00 <danilo2> tomejaguar: for String, empty String perhaps? "" ?
06:57:12 <mr-> danilo2: like.. Nothing?
06:57:19 <danilo2> mr-: no
06:57:23 <mr-> hehe
06:57:32 <tomejaguar> danilo2: Then mappend should be (++)!
06:57:37 <danilo2> mr- : more "like default value"
06:57:39 <FireFly> danilo2: okay, let's take a more direct example. Would you make Int an instance of this has-an-empty-value typeclass? what would its empty value be? why?
06:58:03 <danilo2> but not exactly default - hmm, I think I'll prepare soem examples and shouw you :)
06:58:14 <tomejaguar> danilo2: Examples would be great!
06:58:21 <danilo2> Not now, but evening or tommorow if I could :)
06:58:32 <tomejaguar> Give it a go.
06:58:56 <benzrf> FireFly: 0
06:58:56 <tomejaguar> Many things are easier with specific examples.
06:59:17 <FireFly> benzrf: why?
06:59:25 <merijn> danilo2: You don't just need examples of where you can use empty, you need an example of why empty is *better* than just writing "" or []
06:59:48 <tomejaguar> Or, myEmptyConfig
07:00:28 <danilo2> merijn: I know. I'm just thinking about something that has got many fields and when you are developing the datatype and changing types, you do not have to jump in several places in the code, because you know, that even if you change the type of field it would be "empty" in particular instance
07:00:58 <tomejaguar> danilo2: Again I think an example would be useful here
07:01:41 <danilo2> tomejaguar: I know, but the problem is I have to go right niow. I will prepare it on the evenjing or tommorow. It will not be very complicated
07:01:43 <danilo2> :)
07:02:00 <tomejaguar> OK, I look forward to seeing it :)
07:02:21 <fryguybob> Does anyone know if there is a link to download all of hackage still?
07:02:27 <merijn> What was the reverse dependency site for hackage?
07:03:03 <fryguybob> merijn: http://packdeps.haskellers.com/reverse ?
07:03:26 <tomejaguar> @google hackage reverse dependency
07:03:27 <lambdabot> http://packdeps.haskellers.com/reverse
07:03:28 <lambdabot> Title: Reverse Dependencies
07:03:45 <tomejaguar> fryguybob: I found a link to download all of old Hackage
07:04:09 <tomejaguar> fryguybob: http://old.hackage.haskell.org/packages/archive/00-archive.tar
07:04:14 <tomejaguar> Can't remember where I found it.
07:04:28 <fryguybob> tomejaguar: Yeah I think I found that one before, I'll ask in #hackage.
07:05:32 <merijn> fryguybob: Thanks :)
07:09:09 <Guest37823> I just ran into an error message I can't quite figure out
07:09:14 <Guest37823> here's the code:
07:09:15 <benzrf> Guest37823: pls paste Itkovian
07:09:15 <Guest37823> http://lpaste.net/4482174131474792448
07:09:16 <benzrf> *it
07:09:34 <Itkovian> sure dude :-p
07:09:38 <benzrf> Guest37823: you're trying to add Maybes
07:09:49 <benzrf> the result of eval is a Maybe INt
07:09:53 <Guest37823> so do I have to use fromJust ?
07:09:58 <benzrf> no!
07:10:06 <benzrf> if you do that, you'll error as soon as you hit a Nothing
07:10:11 <benzrf> in that case, why use Maybe at all?
07:10:29 <benzrf> im gonna say that you probably want to do this:
07:10:33 <Bus> merijn: Tree : []
07:10:36 <Guest37823> it's required further down, when dealing with division by zero
07:10:40 <pavonia> > liftM2 (+) (Just 10) (Just 20)
07:10:41 <benzrf> > (+) <$> Just 1 <*> Just 2
07:10:41 <lambdabot>   Just 30
07:10:42 <lambdabot>   Just 3
07:10:47 <benzrf> or what pavonia said
07:11:01 <pavonia> Erm no, Applicatives are niver :P
07:11:07 <pavonia> *nicer
07:11:13 <benzrf> pavonia: well, he could use liftA2
07:11:18 <benzrf> it's the same as liftM2 anyway
07:11:34 <benzrf> Guest37823: addMaybes = liftM2 (+)
07:11:42 <benzrf> Guest37823: you can now add two Maybe Ints
07:11:48 <benzrf> Guest37823: if either is a Nothing youll get Nothing
07:12:24 <jophish> Monad M => ([a] -> M b) -> ([M a] -> M b)
07:12:38 <jophish> I don't suppose anything like this is standartd
07:12:41 <jophish> standard*
07:13:06 <benzrf> jophish: youre misusing caps there
07:13:19 <benzrf> i believe ull find that that type sig is invalid syntax
07:13:35 <iamtakingiteasy> hello, how do i compose two functions, like justify . foo, where "justify" takes one argument and "foo" takes three ?
07:13:45 <jophish> benzrf: good spot
07:13:52 <iamtakingiteasy> i wish to define it as bar = justify . foo
07:13:55 <merijn> iamtakingiteasy: Using lambdas to provide the additional arguments
07:13:59 <jophish> Monad m => ([a] -> m b) -> ([m a] -> m b)
07:14:00 <Guest37823> thanks for the help!
07:14:08 <benzrf> merijn: ew lambdas
07:14:11 <iamtakingiteasy> merijn: no point-free way?
07:14:13 <merijn> iamtakingiteasy: "bar x y = justify . foo x y"
07:14:27 <merijn> iamtakingiteasy: You can do it point-free, but you shouldn't as it'll be horrific
07:14:31 <benzrf> iamtakingiteasy: lambdabot's @Pl
07:14:38 <merijn> @pl \x y -> justify . foo x y
07:14:39 <lambdabot> ((justify .) .) . foo
07:14:42 <benzrf> ew
07:14:44 <iamtakingiteasy> whoa
07:14:47 <merijn> ^ don't do that
07:14:54 <iamtakingiteasy> okay, thanks, i wouldn't
07:14:57 <benzrf> i feel like theres a way to do it w/ monads or applicatives
07:14:58 <benzrf> but w/e
07:15:04 <benzrf> pl form isnt worth that much
07:15:04 <benzrf> ;p
07:15:16 <merijn> Well, you could use reader monad + curry/uncurry
07:15:29 <merijn> But that seems a ridiculous amount of effort to avoid the two variables :)
07:15:37 <iamtakingiteasy> aha
07:15:42 <BoR0> what does point-free mean?
07:15:59 <merijn> BoR0: A point is the term used to refer to (variable) names
07:16:11 <merijn> BoR0: Thus a point-free expression is one without variables
07:16:19 <BoR0> ah, I guessed so. because there were points (dots) in the first and in the point free example :)
07:16:37 <benzrf> BoR0: foo . bar is point-free, \a -> foo (bar a) is not
07:16:42 <merijn> BoR0: Ironically point-free expressions usually have more points :p
07:16:49 <BoR0> haha
07:17:30 <mr-> right, because point-free is not point-less
07:17:38 <merijn> Pointfree code can be nice, but forcing it can result in unreadable mess
07:17:47 <benzrf> it makes me feel Clever
07:18:25 <BoR0> it starts to look like LISP
07:18:47 <BoR0> @pl \x y z -> (x, y, z)
07:18:47 <lambdabot> (,,)
07:18:58 <BoR0> what
07:19:13 <merijn> BoR0: You can use tuples as functions too :)
07:19:17 <apo> wow
07:19:18 <merijn> > (,) 1 2
07:19:19 <lambdabot>   (1,2)
07:19:23 <merijn> > (,,) 1 2 3
07:19:24 <lambdabot>   (1,2,3)
07:19:32 <BoR0> cool
07:19:36 <merijn> With the TupleSections syntax you can even do
07:19:40 <merijn> > (,2,) 1 3
07:19:41 <lambdabot>   (1,2,3)
07:19:49 <merijn> That requires an extension, though
07:20:07 <tomejaguar> Woah TupleSections is more powerful than I thought!
07:20:17 <tomejaguar> I kind of assumed you could have only one hole.
07:20:20 <merijn> tomejaguar: TupleSections is awesome :)
07:20:42 <Guest37823> how can I use liftM2 with `div` ?
07:20:54 <Guest37823> liftM2 (`div`) (eval e1) (eval e2) leads to an error message
07:20:57 <benzrf> Guest37823: just use liftM2 div?
07:21:05 <benzrf> why are you putting backticks around it?
07:21:23 <Guest37823> to turn it into an infix operator
07:21:28 <benzrf> ...
07:21:31 <benzrf> but you're not using it infix
07:23:21 <FireFly> Guest37823: the backticks makes it infix and the parens make it prefix again :p
07:23:22 <benzrf> Guest37823: do you understand that operators are just functions?
07:23:22 <mr-> it's sad that (`foo`) does not work
07:23:29 <benzrf> only the syntax is different
07:23:36 <FireFly> try liftM2 div (eval e1) (eval e2)
07:23:37 <bearclaw> `` is a syntaxic trick
07:23:43 <benzrf> if I say 'add a b = a + b', add is now _exactly_ the same function as +
07:23:49 <bearclaw> it does not change the signature of foo
07:24:06 <FireFly> mr-: yeah, that seems a bit weird considering it does work with sections
07:24:24 <FireFly> mr-: I'd expect `foo` to work the same as an operator everywhere..
07:24:33 <tomejaguar> Then you could have `(`foo`)`
07:24:48 <Guest37823> Firefly: thanks!
07:25:24 <Guest37823> benzrf: yes, I know that operators are just functions.
07:25:31 <Guest37823> http://lpaste.net/4482174131474792448
07:25:34 <Guest37823> it still doesn't work
07:25:38 <FireFly> > 1 `(+)` 2  -- this works?
07:25:38 <lambdabot>   <hint>:1:4: parse error on input `('
07:25:47 <FireFly> tomejaguar: you wouldn't necessarily, no
07:25:48 <Guest37823> sorry, div works
07:26:04 <Guest37823> but the other condition, when e2 == 0 doesn't
07:26:06 <tomejaguar> FireFly: Why not?
07:26:24 <FireFly> tomejaguar: if `foo` behaved like an operator, then if that works `(+)` would also work, no?
07:26:38 <FireFly> and it doesn't, evidently
07:27:55 <benzrf> Guest37823: you're not evalling e2
07:28:08 <tomejaguar> Oh, it doesn't work now, but if you expect `foo` to work the same as an operator everywhere then it's natural to allow `(`foo`)` to work too.
07:29:02 <merijn> mr-: (`foo`) does work
07:29:10 <merijn> mr-: You can even use it to do operator slicing
07:29:11 <benzrf> Guest37823: so e2 :: Expr
07:29:27 <merijn> :t (`elem`[1..10])
07:29:28 <lambdabot> (Enum a, Eq a, Num a) => a -> Bool
07:29:33 <merijn> > (`elem`[1..10]) 2
07:29:34 <lambdabot>   True
07:29:41 <mr-> > (`div`) 4 5 -- merijn
07:29:42 <lambdabot>   <hint>:1:7: parse error on input `)'
07:29:50 <Guest37823> benzfr, thanks! So, something like "liftM (eval e2) == 0  ?
07:29:54 <merijn> Oh, hmm, maybe it only works if you slice it?
07:30:01 <tomejaguar> I think so.
07:30:09 <mr-> (`foo` x) just turns it into a unary function
07:30:26 <mr-> I guess ;-)
07:30:58 <pavonia> Guest37823: Note that you would evaluate e2 twice if it isn't equal 0
07:32:02 <joeyh> has anyone used cabal's new extra-prog-path option? Seems it might allow explicitly build-depending on eg c2hs and make cabal install do the right thing to install it before building
07:32:30 <merijn> joeyh: You could already explicitly depend on external programs
07:32:55 <tomejaguar> Hey joeyh are you Joey Hess from Debian?
07:33:02 <Guest37823> pavonia: so you're implying I should add a 'where' clause to avoid recomputation?
07:33:02 <joeyh> tomejaguar: sure
07:33:04 <benzrf> Guest37823: do you understand what liftM2 does?
07:33:08 <merijn> Actually, I guess maybe not in a way that installs things
07:33:15 <tomejaguar> joeyh: Thanks for making Debian great :)
07:33:24 <joeyh> right, cabal would install them to ~/.cabal/bin and then fail to find them ..
07:33:41 * joeyh needs to make debian greater by putting the new cabal in it ;)
07:34:13 <Guest37823> benzfr: it 'lifts' the arguments to become Monads and then evaluates them
07:34:15 <pavonia> Guest37823: yes, or maybe use let in a do block
07:35:17 <dcoutts> joeyh: I think when I added extra-prog-path, that I also made it add its target bindir to the path, so it should look in ~/.cabal/bin
07:35:25 <tomejaguar> joeyh: Ooh yes please.
07:35:26 <benzrf> Guest37823: no, it does the opposite :p
07:35:34 <dcoutts> joeyh: I *think* anyway, haven't tried it recently :-)
07:35:35 <benzrf> Guest37823: it 'lifts' a function to work on monads
07:35:47 <benzrf> Guest37823: in this case, the monadic values are Maybes
07:36:00 <joeyh> dcoutts: you mean it looks there by default too?
07:36:02 <benzrf> Guest37823: so liftM2 (+) gives you a function that takes two Maybes and adds them and gives a Maybe
07:36:19 <dcoutts> joeyh: yes, but as I say that's just my recollection, haven't tried it recently.
07:36:28 <joeyh> this has been a pain point for my non-haskell cabal-using users, so I eagerly look forward to trying it
07:36:32 <charlie_sanders> anyone use FPComplete ?  How do I get the welcome page to stop coming up
07:37:14 <dcoutts> joeyh: right, that's why I was thinking of doing it, though don't recall if I actually did :-)
07:38:12 <joeyh> of course ~/.cabal/bin is the other pain point ..
07:38:22 <joeyh> pity there's no default user ~/bin PATH
07:38:40 <donri> sure there is, ~/.local/bin
07:38:53 <dcoutts> joeyh: right, the ~/bin problem is a real pain, that there's no common place that is on the user's $PATH
07:39:05 <Guest37823> benzfr: thanks for the explanation
07:39:07 <dcoutts> donri: is that on the $PATH in recent linux distros?
07:39:18 <benzrf> Guest37823: liftM2 is for functions with 2 args, that's what the 2 means
07:39:21 <donri> dcoutts: at least on fedora, yes
07:39:33 <benzrf> Guest37823: you can use liftM for 1-arg functions
07:39:41 <dcoutts> donri: mm, so it is
07:39:44 * hackagebot gpah 0.0.2 - Generic Programming Use in Hackage  http://hackage.haskell.org/package/gpah-0.0.2 (JohanJeuring)
07:40:32 <joeyh> hmm, not on Debian but if fedora has a standard, that's a good 1st step. (Debian has a ~/.local already at least)
07:42:33 <donri> dcoutts: i think python uses basically PREFIX=$HOME/.local for user installs (at least pip)
07:43:10 <dcoutts> donri: that .local thing is new, but if it's becoming more of a standard that's great
07:43:31 <donri> dcoutts: it's a few years old but yes
07:44:34 <donri> i think only .local/share is "standard" (in xdg-basedir) but the rest follow naturally and are becoming de facto standards
07:45:38 <donri> (it's a weird standard though because /usr/{local,}/share is for static-but-arch-independent package data, whereas $XDG_DATA_HOME is for "user specific data files")
07:46:29 <donri> of course the FHS itself is weird. :P
07:51:41 <benzrf> see you guys
07:52:43 <cmtptr> HE CAN SEE ME?
07:52:59 <donri> god is always watching
07:54:01 <matthiasgoergens> I have a tree (Data.Tree.Tree Char), and a word ([Char]), and now I want to see whether any path from root to leave is that word.
07:54:10 <matthiasgoergens> Can I express that as a fold or traverse?
07:54:20 <matthiasgoergens> (or foldM..)
07:55:46 <joeyh> dcoutts: hmm, cabal 1.18 has configure --extra-prog-path, but it seems to reject extra-prog-path: in cabal file
07:56:02 <dcoutts> joeyh: sure, it's not a .cabal file thing
07:56:04 <joeyh> (tried both in the top stanza and my Executable stanza)
07:56:06 <tomejaguar> matthiasgoergens: Nice problem.  Sounds like something in the list (indeterminate choice) monad to me.
07:56:17 <joeyh> oh, http://coldwa.st/e/blog/2013-08-21-Cabal-1-18.html said it was
07:56:59 <dcoutts> joeyh: it says " config file option: extra-prog-path. "
07:57:19 <dcoutts> joeyh: config file, meaning ~/.cabal/config, or a local config file. Not a .cabal file feature.
07:57:23 <joeyh> aah
07:57:45 <pavonia> matthiasgoergens: Why not use flatten?
07:57:50 <dcoutts> joeyh: and note that this is deliberate, it should not be available within a .cabal file
07:58:33 <mr-> matthiasgoergens: can't you just walk the tree along that word? (sorry, that's not a fold solution)
07:58:36 <tomejaguar> pavonia: There are nodes on the branches.
07:59:37 <pavonia> Oh, I misread the type signature
08:00:47 <matthiasgoergens> pavonia, the tree is big, and I know that I can bail out early.
08:01:24 <matthiasgoergens> pavonia, also, flatten loses information that I need.
08:01:25 <pavonia> maybe something like \w -> all $ zipWith elem w (levels tree)
08:02:04 <pavonia> oh, no
08:02:22 * pavonia is quiet now :P
08:02:33 <mr-> Bah.. Tree.Zipper has no "findChild" anymore
08:02:34 <matthiasgoergens> I'm first seeing whether I can extract all paths from root to leaves via traverse or fold or so.
08:02:58 <matthiasgoergens> A tree is a comonad, isn't it?
08:03:15 <tomejaguar> Yes
08:03:25 <matthiasgoergens> mr-: which package is Tree.Zipper in?
08:03:49 <matthiasgoergens> mr-: Yes, I'm basically trying to walk that tree (or rather, prune it).
08:04:22 <mr-> monochrom: data.tree.zipper
08:04:35 <mr-> err
08:04:35 <mm_freak> trees aren't comonads in general, but i think zippers are always comonads
08:04:36 <matthiasgoergens> hey, I think I can express it as an unfold.
08:04:44 <mr-> matthiasgoergens: Data.Tree.Zipper ;-)
08:04:51 <matthiasgoergens> mr-: Yes, but what Cabal package?
08:04:57 <mr-> rosezipper
08:05:23 <matthiasgoergens> Thanks.
08:09:04 <mr-> But I am sure there's something nicer in lens
08:09:34 <joeyh> dcoutts: testing, it looks like extra-prog-path is not set by default. When I do set it, it works; cabal finds happy, alex, c2hs as installed by cabal
08:09:56 <matthiasgoergens> Actually, I just noticed that my tree only ever has 28512 nodes.
08:10:02 <matthiasgoergens> So I can just generate all paths.
08:10:04 <matthiasgoergens> No need for pruning.
08:10:04 <dcoutts> joeyh: re-reading that blog post, it says that it sets it in the ~/.cabal/config for new users
08:10:13 <dcoutts> joeyh: so it will not change existing installations
08:10:35 <cariveri> How to equip a tree with a unique id? and Do I have to put an id into the node itself? data Tree = Tree Node [Tree Node]
08:11:13 <joeyh> yep, also, cabal doesn't ensure that build-tools get installed before building. Seems that also listing them in build-depends is a workaround hough
08:11:40 <mr-> cariveri: I don't understand that question. Do you want to enumerate the Nodes?
08:11:42 <benzrf> hi
08:11:44 <dcoutts> joeyh: using build-depends is wrong, it'll cause it to be reinstalled again and again
08:11:49 <joeyh> hmm
08:11:53 <benzrf> does the platform stdlib contain anything like a multiset?
08:12:22 <cariveri> mr-: you could say so yes. the unique id allows finding and removing children et.c.
08:12:34 <dcoutts> joeyh: actually it will not work at all, it'll fail to build for alex & happy.
08:12:57 <joeyh> just tried it with alex and it seemed to work
08:13:07 <triliyn> cariveri: if you only want the root node to have an id, you can say data Tree = TreeWrapper Id Node [Node]
08:13:28 <joeyh> er, no
08:13:31 <triliyn> Otherwise yes, it would be best to attach them to nodes
08:13:59 <joeyh> darn. so close :)
08:14:04 <triliyn> er, wait
08:14:07 <benzrf> @info Foldable
08:14:08 <lambdabot> Foldable
08:14:15 <benzrf> @about Foldable
08:14:15 <lambdabot> Unknown command, try @list
08:15:16 <cariveri> It would be great if there is standard implementations on a Tree with Id.
08:18:38 <merijn> Sounds like Map to me...
08:21:10 <triliyn> Map doesn't expose a tree-like interface though, does it? You can only manipulate it as an association table thing
08:22:25 <matthiasgoergens> I think perhaps I'll write my own tree walking function.  With a bit of luck and patience, I can then stare at it long enough, and discover an already implemented well-known structure.
08:24:11 <cariveri> merijn: did you mean to  suggest mapping each node to an id in a map?
08:26:20 <tomejaguar> matthiasgoergens: That is often my approach too :)
08:28:39 <donri> dcoutts: is tracking executables WONTFIX or TODO? e.g. is it considered desirable or the wrong thing to do anyway?
08:29:00 <dcoutts> donri: oh it's certainly desirable, along with other kinds of deps like C libs
08:31:27 <int-e> @hoogle (a -> b -> c) -> ([a] -> c) -> ([b] -> c) -> [a] -> [b] -> [c]
08:31:28 <xfce-x64> any using haskell for cgi?
08:31:28 <lambdabot> No results found
08:31:35 <donri> it would be nice if there was a standard way to ask the system to install pkg-config dependencies... i wonder if packagekit has that, hmm
08:31:48 <issam> hi
08:31:53 <issam>  is it possible to find the type of a variable in Haskell?
08:31:57 <issam> beside ` : t var `?
08:32:07 <issam> for example, lookup
08:32:15 <donri> issam: sure, you get editor integration for that with ghc-mod or hdevtools
08:32:31 <mr-> hmm.. is there a fmapM anywhere?
08:32:52 <int-e> @type liftM
08:32:53 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
08:33:01 <donri> :t traverse
08:33:02 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:33:02 <quchen> :t T.traverse -- mr-
08:33:03 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:33:05 <issam> donri: I don't get it :(, I want to print the type of '3' for exxample
08:33:13 <issam> under "main = do"
08:33:14 <int-e> mr-: what would that do?
08:33:25 <quicksilver> yes, fmapM is traverse although it's not immediately obvious perhaps
08:33:34 <quicksilver> there used to be something called FunctorM or something
08:33:42 <quicksilver> but Traversable generalises it all.
08:33:44 <mr-> oh, traverse!
08:33:44 <mr-> Thanks
08:34:07 <donri> issam: yes, with e.g. vim you could move the cursor to "3" and use :GhcModType or :HdevtoolsType
08:34:11 <mr-> int-e: it would gernalize mapM to the type (a -> m b) -> f a -> m f b
08:35:07 <donri> issam: with ghc-mod in emacs it's C-c C-t
08:35:58 <donri> issam: with SUblimeHaskell it's ctrl-k ctrl-h ctrl-t
08:36:31 <issam> donri: I see, thanks thats a good add, just tried it ;),  but I want to process expressions based on their type, not to see it for myself :) :)
08:36:41 <issam> if you know what i mean
08:36:48 <donri> issam: in that case there's Typeable
08:36:50 <donri> :t typeOf
08:36:51 <lambdabot> Typeable a => a -> TypeRep
08:37:08 <donri> issam: but it's not usually what you want
08:37:13 <issam> so, print (typeOf 3) would work?
08:37:16 <donri> issam: perhaps you want a type class?
08:37:19 <issam> aha
08:37:23 <donri> > typeOf 3
08:37:24 <lambdabot>   Integer
08:37:38 <donri> > typeOf 3 == typeOf '3'
08:37:39 <lambdabot>   False
08:37:53 <issam> lol @ lambdabot :P
08:38:01 <issam> nice
08:38:04 <donri> what?
08:38:17 <quicksilver> if you try to use Typeable to process arguments based on their type then you're doing it wrong.
08:38:21 <issam> quite intrigued by lambdabot's answers
08:38:23 <quicksilver> throw the program away and try again
08:38:31 <issam> anyhow i guess i need to import something
08:38:35 <issam> for typeOf to work?
08:38:43 <quicksilver> Data.Typeable
08:38:48 <Tinned_Tuna> > typeOf '3'
08:38:49 <lambdabot>   Char
08:38:53 <Tinned_Tuna> > typeOf "3"
08:38:53 <lambdabot>   [Char]
08:38:54 <donri> issam: but what is your actual goal, what are you trying to achieve?
08:38:56 <Tinned_Tuna> > typeOf . read "3"
08:38:57 <lambdabot>   Could not deduce (Data.Typeable.Internal.Typeable b0)
08:38:57 <lambdabot>    arising from the a...
08:39:44 <issam> donri: I am to implement the "typing" in simple lambda calculus
08:40:24 <issam> https://dl.dropboxusercontent.com/u/30688032/lambda.png
08:40:46 <issam> the one inside the redbox
08:40:53 <issam> are you familiar with this?
08:41:04 <donri> ok, i imagine you're supposed to use your own types for that
08:41:09 <issam> yes
08:41:16 <issam> the first problem i encountered
08:41:31 <issam> is how i would define a function that expects a generic type and return that type
08:41:37 <issam> for example
08:41:47 <issam> typeOf x:: generic_type -> type
08:41:58 <issam> haskell quite confuses me :S
08:42:01 <donri> yes, that's type classes
08:42:26 <issam> but i need to define `generic_type` right?
08:42:56 <issam> for T-Var for example
08:43:06 <issam> I must return the type of a given 'x' variable
08:43:24 <issam> hence my first question
08:43:24 <ystael> issam: are you trying to represent the types of simply typed lambda calculus as haskell types?  you should probably be representing them as haskell values
08:43:45 <donri> yes, what ystael says
08:44:29 <donri> you would probably have a haskell ADT to represent the types and some environment to look up types in
08:44:36 <issam> <ystael>: so I should manually define the type that 'x' can take?
08:44:46 <issam> like boolean, int and string
08:44:55 <ystael> you should have a haskell type whose values are the types of simply typed lambda calculus
08:45:28 <ystael> the left half of that box you pasted tells you what your haskell types should look like
08:46:02 <issam> i see
08:46:04 <ystael> and your STLC typing judgment is not the same thing as the haskell typing judgment ::
08:46:06 <issam> you mean under types
08:46:07 <donri> unless you're doing an embedding, but the syntax bit in that picture implies you're parsing programs
08:46:08 <issam> T->T
08:46:18 <issam> its simply parsing yes
08:46:31 <ystael> issam: right, and that arrow is not the same thing as the haskell type arrow
08:46:50 <issam> ah okay makes much more sense now
08:47:29 <issam> so to return type for a variable x using T-Var, I should use the types I defined in the syntax
08:49:27 <issam> right?
08:49:29 <ystael> issam: yes
08:50:30 <issam> Thanks a lot! :)
08:50:43 <ystael> you're welcome, good luck
09:21:37 <phao> Hi. Does using OpenGL (as taught here http://www.haskell.org/haskellwiki/OpenGLTutorial1 ) in haskell is much of a performance penalty?
09:22:53 <phao> I know there is a lot of performance issues in using a graphics API which has to do with the I/O process in itself (from processor to video card, etc). So I imagine it could be that using OpenGL like that doesn't add to performance penalties.
09:24:06 <quchen> Hmpf, a Set monad would be really useful so I don't have to use my own >>= operator.
09:24:29 <quchen> I guess this is one scenario where RebindableSyntax makes sense?
09:24:32 <simpson> phao: No, it performs fine.
09:25:07 <phao> simpson, are there some documents comparing performance of doing usual opengl in c or in C++ with GCC and this one?
09:26:22 <phao> In terms of "user-friendliness", where the user is the programmer, this API on top of usual opengl (this explained in the tutorial) seems much better...
09:26:57 <simpson> phao: I don't know of any useful benchmarks.
09:27:12 <simpson> phao: From personal experience, the GL bindings are *not* the bottleneck.
09:27:43 <phao> simpson, could you tell me some of the stuff you did or tried to do?
09:28:16 <simpson> phao: I wrote graphics drivers and have made Python go at nearly the speed of C with GL. Language doesn't matter.
09:28:22 <phao> I am not an expert.. I just started studying computer graphics, and honestly, the opengl API might be considered good by most people, but I didn't get to be a fan of it
09:29:32 <phao> simpson, that's nice... I don't think I will be doing any of that advacend stuff
09:29:39 <phao> Anyway... thank you.
09:31:15 <phao> Changing subjects a little bit... Is it just me, but it's actually easier to do TDD in functional programming style?
09:31:36 <phao> s/but/or
09:32:14 <simpson> I'd say that it's just you.
09:32:25 <phao> heh
09:32:43 <simpson> (Does "functional programming style" mean anything? Are PyUnit tests in that style?)
09:34:06 <quchen> In (Haskell) functional programming "TDD" generally stands more for "Type driven development".
09:35:04 <Phlogistique> phao: It's easier to test pure functions
09:38:33 <quchen> @check \xs -> sort xs == sort (reverse xs)
09:38:34 <lambdabot>   +++ OK, passed 100 tests.
09:38:37 <quchen> :-=
09:38:54 <quchen> s/:-=/:-)    ← I hope that clears things up!
09:39:07 <phao> thanks all
09:39:08 <quchen> … trailing slash. Goddammit
09:39:14 <supki> @check \xs -> reverse xs == sort xs
09:39:15 <lambdabot>   +++ OK, passed 100 tests.
09:40:52 <WraithM_> @check \x -> 12 == 7
09:40:53 <lambdabot>   *** Failed! Falsifiable (after 1 test):
09:40:53 <lambdabot>  ()
09:41:33 <mr-> supki: did you break it?
09:41:34 <fizbin> @check \xs -> reverse (1 : xs) == sort (1 : xs)
09:41:35 <lambdabot>   *** Failed! Falsifiable (after 4 tests and 3 shrinks):
09:41:35 <lambdabot>  [2]
09:42:26 <fizbin> @check \xs -> length (1 : xs) < 3
09:42:27 <quchen> @check \x -> x == ()
09:42:27 <lambdabot>   *** Failed! Falsifiable (after 5 tests and 5 shrinks):
09:42:27 <lambdabot>  [0,0]
09:42:28 <lambdabot>   +++ OK, passed 100 tests.
09:43:08 <fizbin> @check \xs :: [Int] -> reverse xs == sort xs
09:43:08 <lambdabot>  <unknown>.hs: 1: 5:Parse error: ::
09:43:18 <mr-> @check \xs -> reverse (xs :: [Int]) == sort (xs :: [Int])
09:43:19 <lambdabot>   *** Failed! Falsifiable (after 3 tests and 1 shrink):
09:43:19 <lambdabot>  [0,1]
09:43:21 <mr-> aha
09:43:35 <fizbin> mr-: Right, that's what I suspected.
09:43:37 <mr-> If you omit the type it gives you [] 100 times? ;-)
09:43:51 <WraithM_> lol
09:43:59 <fizbin> Maybe it assumes xs is of type [()] ?
09:44:40 <fizbin> @check \xs -> length (xs) < 3
09:44:42 <lambdabot>   *** Failed! Falsifiable (after 4 tests):
09:44:42 <lambdabot>  [(),(),()]
09:44:49 <mr-> maybe
09:44:51 <tomejaguar> That's weird.  Why would it assume ()?
09:45:08 <fizbin> Ha. So, yeah. A list is apparently just [()] if not otherwise type-constrained.
09:45:22 <fizbin> And for that type, sort xs == reverse xs == xs
09:45:33 <Amadiro> simpson, well, that's a bit of a strawman.. the *bindings* won't be the bottleneck as such, but the opengl version the tutorial describes he was pointing to is very very outdated, so it will effectively be the bottleneck by disallowing you to use any of the GL technology added after 2005
09:45:38 <donri> tomejaguar: ExtendedDefaultRules
09:45:56 <donri> it's meant to make ghci less surprising. i think it has the opposite effect.
09:46:06 <simpson> Amadiro: Ah, that's a good point.
09:46:10 <Amadiro> You can use that to make fancy GUIs and simple 2D games, or games with iOS-level graphics just fine, but you won't be able to use those to make something fancy looking that actually taxes your average modern GPU
09:46:28 <simpson> Amadiro: To be fair, the iperf demo's still relevant.
09:46:30 <tomejaguar> donri: Oh, this is for GHCi only?
09:46:38 <Amadiro> simpson, what's that?
09:46:49 <donri> tomejaguar: it's an extension that's only on by default in ghci
09:46:54 <simpson> Amadiro: Classic demo in the Mesa repository that continues to have relevant numbers.
09:46:56 <tomejaguar> Oh right.
09:48:13 <Amadiro> simpson, all I can find is a TCP benchmarking tool called iperf
09:48:48 <inf-groupoid> Is there any shorthand for "(,) <$> xs <*> ys"?
09:49:28 <quchen> inf-groupoid: liftA2 (,)
09:49:35 <tomejaguar> inf-groupoid: There's also 'liftA2 (,) xs ys' if you like that.
09:49:46 <inf-groupoid> Ah, thanks!
09:50:38 <it3ration> morning all
09:50:59 <simpson> Amadiro: Oh, sorry, wires crossed; it's called ipers. http://cgit.freedesktop.org/mesa/demos/tree/src/demos/ipers.c
09:51:00 <Amadiro> simpson, are you referring to this? http://cgit.freedesktop.org/mesa/demos/tree/src/perf
09:51:48 <simpson> Amadiro: There are all kinds of things in there, yes.
09:52:03 <Amadiro> simpson, ah, no.. that's quite outdated, I wouldn't use that as a benchmark of any kind
09:52:22 <Amadiro> In fact, it wouldn't be strange if that code would run slower on modern hardware than on old one
09:52:38 <Amadiro> since a lot of the stuff it does is not officially supported anymore (vendors are just nice and keep things compatible)
09:52:50 <simpson> Amadiro: Mesa's not your ordinary vendor. :3
09:52:52 <Amadiro> and it doesn't test any of the new functionality
09:53:04 <Amadiro> simpson, well, we're not talking about just benchmarking mesa, are we...
09:54:20 <Amadiro> New opengl implementations are even technically free to not implement glLoadIdentity() and friends at all, if they don't want to be backwards compatible, but well, people do like to play old games :)
09:54:30 <simpson> Amadiro: Mesa's primary targets are 2D desktops.
09:54:43 <simpson> Anyway, I'm sorry; I don't really want to argue. I was just trying to help.
09:55:14 <Amadiro> simpson, sure, but as I said, it's not really a good general benchmark.
09:55:34 <simpson> Amadiro: There is no good general benchmark. The "all-around" benchmarks aren't open-source.
09:55:50 <Amadiro> simpson, unfortunately, yeah
09:55:50 <tiffany> amadiro: not just old games
09:56:40 <tiffany> there's still plenty of games using gl 2.1, and even some using 1.x (like minecraft)
09:57:12 <Amadiro> tiffany, I think minecraft upgraded to 2.1 a while ago
09:57:15 <simpson> To be fair, Minecraft's poorly implemented.
09:57:19 <Amadiro> they put in a new renderer
09:57:21 <simpson> Didn't even use VBOs from 1.5.
09:58:13 <tiffany> I don't think it has updated quite yet
09:58:27 <tiffany> they have post-processing shaders now, but they're only an experiment to see how many users can't run them
09:58:50 <tiffany> simpson: it does use display lists though
09:59:27 <simpson> tiffany: dlists still have to be repacked every time; if the client had been packing its own VBOs, it could have had finer-grained control over what was rendered.
09:59:42 <simpson> Sorry, this is a bad intersection of two of my pet peeves; I'll shut up now.
10:00:49 <tiffany> mesa's primary target isn't 2d desktops
10:01:05 <tiffany> if you mean non-3d-accelerated systems like I think
10:01:51 <tiffany> the majority of people using mesa right now are those with intel integrated graphics
10:02:04 <simpson> Well, sure. They've got half the market after all.
10:04:26 <lasanbr> ahh it's a wonderful day!
10:15:31 <Deams> Hi I'm trying to install Haste on windows using cabal. Everything seems to be ok for the installation part but when trying to compile the Hello world I got a strange error : couldn't find module Prelude
10:15:56 <Deams> I didn't find anything related to the web. Does someone have an idea on what's going on?
10:16:48 <quchen> Not finding Prelude is very odd. Could you paste the hello world source?
10:16:51 <quchen> @where paste
10:16:51 <lambdabot> http://lpaste.net/new/haskell
10:18:03 <Deams> quchen: http://lpaste.net/96598
10:18:13 <bennofs> Maybe Haste doesn't have a Prelude? It's for writing javascript, after all.
10:19:16 <quchen> Did you run `haste-boot`?
10:19:23 <Deams> yes :/
10:19:45 <Deams> if i try to compile using the -v option, I got :
10:20:24 <Deams> Using binary package database: C:\Users\Mickaël\AppData\Roaming\haste\packages\p ackage.cache wired-in package ghc-prim mapped to ghc-prim-0.3.0.0-d5221a8c8a269b66ab9a07bdc23 317dd wired-in package integer-gmp mapped to integer-gmp-0.5.0.0- wired-in package base not found. wired-in package rts mapped to builtin_rts wired-in package template-haskell not found. wired-in package dph-seq not found. wired-in package dph-par not found. **
10:20:37 <matthiasgoergens> I've done the Tree folding I was talking about (http://lpaste.net/96599)
10:21:04 <andkore> #quickcheck
10:21:24 <andkore> whoops, sorry. quick question: is quickcheck deterministic?
10:21:32 <quchen> No
10:21:39 <quchen> Test cases are randomly generated
10:21:41 <Deams> quchen: http://lpaste.net/96600 easier to read :)
10:21:53 <andkore> right, that's what I had read. that seems unfortunate
10:22:03 <quchen> andkore: SmallCheck is deterministic (and exhaustive).
10:22:28 <donri> (up to depth)
10:22:30 <andkore> ah ok, thanks
10:22:36 <simpson> I thought that QuickCheck was deterministic in its Arbitrary instances?
10:22:48 <donri> andkore: you can supply/reuse a seed though
10:22:57 <andkore> ah, interesting
10:23:14 <andkore> I imagine this doesn't cause problems all that often. Considering it can probably generate a lot of test cases...
10:23:24 <andkore> still, I'll check out smallcheck
10:28:29 <Deams> I'll try to reinstall everything (cabal, haste...)
10:32:33 <Deams> s*** still don't work -_-
10:33:27 <Cale> Deams: What are you having trouble with?
10:33:48 <Cale> oh, missing dph?
10:34:13 <Deams> Cale: Trying to use Haste compiler but end up with this error : http://lpaste.net/96600
10:34:45 <Cale> could you paste the output of  ghc-pkg list ?
10:35:22 <Cale> oh, er
10:36:01 <Cale> hmm, I suppose it might also have something to do with how haste uses ghc, but let's just see what that tells us
10:36:40 <Deams> Cale: here you go http://lpaste.net/96601
10:37:13 <Cale> right, okay
10:38:12 <Cale> So, haste itself is supposed to come with its own version of the Prelude and various basic libraries
10:38:25 <Cale> and I'm not sure why it's not finding its own versions of these things
10:39:11 <zol> What is the difference between truncate and round?
10:39:21 <Deams> I'm asking myself the same question. I tried on another computer and no problem at all.
10:39:27 <Cale> > truncate 3.7
10:39:28 <lambdabot>   3
10:39:32 <Cale> > round 3.7
10:39:33 <lambdabot>   4
10:39:35 <zol> Oh, right, it's semantical differences..
10:39:40 <zol> Cale: Thanks!
10:39:52 <Cale> Deams: Oh, haste-pkg
10:40:02 <Cale> What does  haste-pkg list  report?
10:40:27 <Cale> Does it list base?
10:40:50 <zol> You can debug in GHCi? :? shows something about breakpoints
10:41:28 <Deams> Cale: No, no base. Only ghc-prim, integer-gmp and rts.
10:42:10 <quchen> zol: There's a recent video about using the debugger. http://www.youtube.com/watch?v=1OYljb_3Cdg&feature=share&list=PLxj9UAX4Em-Ij4TKwKvo-SLp-Zbv-hB4B&index=1
10:42:35 <zol> quchen: Thank you!
10:42:58 <raek_> (the user's guide: https://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html)
10:43:00 <Cale> Deams: I expect something must have gone wrong when installing the libraries. Is it possible that you have a broken copy of the repository?
10:43:42 <Deams> Cale: I see what you mean, but how could I know that?
10:44:28 <Cale> I'm not sure
10:44:39 <Cale> Apart from re-downloading things :P
10:45:04 <Deams> :D
10:46:28 <Deams> I installed Haste through cabal. After checking Cabal options, It doesn't seem like there's a uninstall one. How could I uninstall haste and try to install it again?
10:46:50 <dcoutts> Deams: just install it again
10:47:17 <quchen> dcoutts: Can --reinstall cause any damage when no packages depend on it?
10:48:12 <dcoutts> quchen: no. It's just that it's not possible for cabal to detect if you have things that depend on it but that are not themselves registered (ie so cabal would not know about them)
10:50:38 <Deams> so reinstalled it using cabal : cabal install haste-compiler
10:50:51 <Deams> still the same problem. :(
10:52:21 <dcoutts> Deams: what is this haste\packages\package.cache ? do you need to reset that?
10:52:37 <dcoutts> Deams: it looks like that package db is empty, does not contain base, so no Prelude
10:52:58 <dcoutts> reinstalling haste-compiler isn't going to affect that package db
10:54:09 <Deams> should I try to reinstall world ?
10:54:19 <Deams> or the whole platform?
10:54:31 <dcoutts> Deams: no, none of that would help
10:54:45 <dcoutts> Deams: try deleting C:\Users\Mickaël\AppData\Roaming\haste
10:55:53 <dcoutts> and then look at how to use haste to re-initialise whatever it is it needs
10:56:37 <Deams> ok thx trying. :)
10:57:17 <dcoutts> Deams: the point is that haste has installed some per-user data files, so deleting programs & reinstalling would not help that. Those files would still be there.
10:57:28 <dcoutts> so clean that out, start that bit from fresh
10:58:29 <Deams> ok :)
11:05:13 <pavonia> When you do a map (the function) on a large map (the data structure), will that result in two large maps in the heap?
11:11:12 <Deams> I tried to delete haste folder and install everything directly from source. Still the same issue.
11:16:29 <byorgey> pavonia: only if you retain references to both of them
11:16:42 <byorgey> pavonia: if you don't use the old one anymore, it can be garbage collected
11:17:15 <pavonia> Hhm, I do use both
11:19:27 <ReinH> byorgey: I talked to some Ruby folks on Tuesday and used my limited understanding of diagrams internals to talk about how awesome monoids are :)
11:19:48 <ReinH> pavonia: how else would you be able to use both if they weren't both in memory? :)
11:20:29 * hackagebot oauthenticated 0.1.0 - Simple OAuth for http-client  http://hackage.haskell.org/package/oauthenticated-0.1.0 (JosephAbrahamson)
11:21:12 <pavonia> ReinH: I thought GHC could at least do something clever to just store the difference in data of both maps, because the tree structure is identical, only the values differ
11:21:59 <ReinH> pavonia: that's fair, but I don't believe there's a general solution that would allow GHC to do that
11:22:19 <pavonia> yeah
11:22:47 <bennofs> I'm not sure, but maybe GHC will avoid storing the keys 2 times?
11:22:58 <bennofs> Could work through sharing
11:23:18 <ReinH> pavonia: when you change a list [a,b,c,d] to [a,b,c',d'], all you really need to do is replace the b -> c link with a b -> c' link, so I see what you mean
11:26:22 <ReinH> byorgey: does diagrams use a meet-semilatice for calculating envelopes (greatest lower bound seems like the correct think to calculate)?
11:26:43 <ReinH> or a tropical monoid?
11:26:51 <ReinH> so many abstractions to choose from...
11:27:17 <pavonia> bennofs: I think so, the keys should share the same reference
11:30:39 <byorgey> ReinH: uh, nothing that complicated.  It uses the monoid on   Option (v -> Max R2)
11:30:56 <byorgey> i.e. pointwise maximum, with a distinguished empty element thrown in
11:31:25 <byorgey> ReinH: though I'm always interested to hear ideas of other abstractions that could make it better.
11:31:26 <ReinH> byorgey: that's isomorphic to a arctic monoid (tropical but with max and -inf), so yes. ;)
11:31:26 <chrisdone> sup
11:31:35 <ReinH> chrisdone: sup :)
11:31:39 <byorgey> ok, sure.
11:31:50 <chrisdone> arctic monoid?
11:31:56 <chrisdone> keep talkin'
11:32:01 <ReinH> chrisdone: <Z, max, +inf>
11:32:13 <byorgey> google returns absolutely no hits for "arctic monoid"
11:32:22 <ReinH> er <Z, max, -inf>
11:32:45 <ReinH> where where max x (-inf) = x = max (-inf) x
11:33:34 <ReinH> tropical semiring is a min-plus algrbra, so named because the inventor lived in a tropical clime (really).
11:33:55 <ReinH> arctic semiring is the opposite, a max-plus algebra, so named because mathematicians are HILARIOUS
11:34:21 <chrisdone> D _D
11:35:05 <ReinH> byorgey: you'll have a bit more luck with tropical. My introduction was roconnor's excellent post http://r6.ca/blog/20110808T035622Z.html
11:36:11 <adrian_berg> http://hackage.haskell.org/package/containers-0.5.3.1/docs/src/Data-Map-Base.html#mergeWithKey mergeWithKey :: Ord k => (k -> a -> b -> Maybe c) -> (Map k a -> Map k c) -> (Map k b -> Map k c) -> Map k a -> Map k b -> Map k c
11:36:50 <adrian_berg> will someone explain what this is?
11:37:30 <ReinH> adrian_berg: it's merge with key ;)
11:37:57 <bergmark> adrian_berg: it seems like it takes two functions to konvert Map k a and Map k b to a Map k c, and if the key is in both it calls (k -> a -> b -> Maybe c)?
11:37:58 <ReinH> adrian_berg: it's a universal combining function through which other things like unionWith and intersectWith can be written
11:38:43 <ReinH> adrian_berg: for instance, look at the definitions of unionWithKey and so on.
11:39:13 <reizuki> hello, I don't know if it's a right place to ask, but I would light to go through a course which would help me understand functional paradigm. I've been considering SCIP lectures + book in Scheme or http://learnyouahaskell.com in Haskell, obviously. Does anyone have experience with these or can recommend something else for a comprehensive starting course?
11:39:28 <reizuki> SICP*
11:39:41 <chrisdone> LYAH?
11:40:05 <ReinH> reizuki: it's not quite a course but I would suggest LYAH and then Real World Haskell, and actually writing some code as you go.
11:40:13 <bergmark> reizuki: sicp is great but covers a lot that isn't function programming, learn you a haskell is supposedly also very good
11:40:24 <bergmark> +al
11:40:32 <ReinH> reizuki: although SICP is very valuable for a basic introduction to computer science, not just FP. Almost anyone would benefit from going through SICP.
11:40:56 <ReinH> So the two choices are definitely not exclusive.
11:41:22 <reizuki> yeah, I plan to code a lot and discuss things through with my brother as we go through the course, he's more theoretical/algorithmical type of guy while I'm on the practical side of things usually
11:41:23 <chrisdone> ReinH: i liked john carmack's view on that, which is you can read any undergraduate book and learn something new, even as an expert
11:41:53 <ReinH> chrisdone: that's a pretty good view :)
11:42:15 <ReinH> reizuki: seems good, the most important thing is to do rather than just watch imo
11:42:23 <reizuki> so I planned to go through the Haskell course on my own and go through SICP with my brother, thanks for confirming there won't be a lot of redundancy :)
11:42:29 <ReinH> chrisdone: it's almost like Carmack is a smart dude with a lot of experience :)
11:43:05 <ReinH> chrisdone: btw Vector performance continues to be a black art to me. Got a 2x speedup the other day by inlining a method :D
11:43:08 <reizuki> well the one thing I liked about SICP is that the course has A LOT of exercises + solutions
11:43:17 <reizuki> as I went quickly through first chapters
11:43:30 <chrisdone> ReinH: huh, weird
11:43:31 <reizuki> haven't checked learnahaskell though :)
11:43:37 <chrisdone> ReinH: what was the code?
11:43:48 <ReinH> chrisdone: just some trivial cellular automata generator
11:43:56 <chrisdone> was it not fusing properly?
11:44:05 <ReinH> chrisdone: the method in question was part of a tight loop, but it was small enough that it should have been inlined anyway
11:44:10 <ReinH> chrisdone: I should check the core.
11:44:13 <byorgey> reizuki: LYAH doesn't have any exercises.  You might be interested in my course materials here: http://www.cis.upenn.edu/~cis194/
11:44:30 <byorgey> well, here actually: http://www.cis.upenn.edu/~cis194/lectures.html
11:44:33 <chrisdone> ReinH: oh, you think it was passing in an instance dictionary instead of inlining?
11:44:42 <ReinH> chrisdone: yeah
11:44:57 <chrisdone> nod
11:45:11 <ReinH> chrisdone: but I really should look at core
11:45:11 <dnewby> I liked the exercises in Programming in Haskell
11:45:30 <ReinH> byorgey: I like how monads are week 12 :)
11:46:36 <nadirs> byorgey: nice resource, bookmarked :)
11:47:00 <reizuki> byorgey: thanks, great ! I presume since it's homework there aren't any example solutions to compare mine after I'm done or stuck?
11:47:05 <chrisdone> ReinH: someone should implement a core (or STG) viewer with a mapping to the original source
11:47:09 <ReinH> byorgey: I'd like to see / make some Haskell learning materials that actually walk through basic proofs too. For instance when learning about folds and monoids, proving that list concatenation is associative.
11:47:16 <ReinH> chrisdone: ooh, source maps, genius
11:47:45 <chrisdone> i've done that with core in interpreted mode, because it sticks breakpoints in every expression. but it's trickier for -O2 compiled code
11:47:45 <nadirs> hey reizuki if you want we can work on these separately and then compare them afterwards. I'd put them on github
11:47:53 <ReinH> byorgey: a basic flexing of the structural induction muscles would be useful for later on imo
11:47:56 <chrisdone> (breakpoints contain source locations)
11:48:03 <ReinH> chrisdone: right
11:48:27 <chrisdone> but i'd love to basically write an expression and then hit an editor key and it popup with the core for that expression
11:48:36 <byorgey> ReinH: yes, that would be very cool.  If I ever teach this course in expanded form (this was only a 1/2-credit course) I would certainly include that.
11:48:44 <chrisdone> due to common subexpression elimination it would have to take care to include enough core to be complete
11:48:45 <nadirs> reizuki: (having someone else to compare to would also be a good motivation to me :)
11:49:01 <ReinH> byorgey: nice :)
11:49:15 <byorgey> reizuki: there are no example solutions on the website, but if you email me I am happy to send you my solutions
11:49:44 <byorgey> nadirs: I may teach this course again, I'd rather you didn't make your solutions publically accessible on github, if you don't mind
11:49:49 <ReinH> byorgey: mind if I pm?
11:49:55 <byorgey> ReinH: sure
11:50:06 <chrisdone> ReinH and byorgey sitting in a tree
11:50:24 <byorgey> H-A-S-K-I-N-G
11:50:27 <chrisdone> =p
11:50:30 <nadirs> byorgey: sure, I didn't think about that :P
11:50:33 <ReinH> amazing.
11:51:23 <dnewby> I like the idea of proof-oriented material, even if it's a light overview for peopel who already know the language, and not an intro to it
11:51:35 <chrisdone> luite_: did you figure out a reliable way to get source locations for -O2 compiled code?
11:51:43 <reizuki> nadirs: sure, why not :) however I think we should respect the no public solutions thing. do you have a hosting place for non public repos?
11:51:47 <chrisdone> luite_: from core or stg
11:52:48 <nadirs> reisuki: well, the only thing that comes to my mind is something like google drive or dropbox with proper permission settings.
11:53:00 <Deams> Hey all, I'm still struggling with Haste compiler installation. Could someone give me a hand?
11:53:09 <ReinH> dnewby: cool :)
11:53:13 <byorgey> nadirs, reizuki: bitbucket also allows you to have private shared git repos
11:53:37 <nadirs> byorgey: good one, thanks for the input
11:53:39 <ReinH> dnewby: one issue is that these proofs are seen as so trivial that it's often hard to find them!
11:54:00 <ReinH> But as Feynman said, there are only two kinds of theorems: theorems whose proofs are trivial and theorems that have not been proven yet. ;)
11:54:25 * nadirs goes making a bitbucket account
11:54:30 <chrisdone> http://2.bp.blogspot.com/-X2IZfLZfvKU/UdATKmpEoWI/AAAAAAAAX34/ivq7tJbUnAI/s800/2006-12-25-what-would-richard-feynman-do.png
11:55:36 <ReinH> hahaha
11:55:43 <ReinH> not bad
11:55:45 <jefimenko> it's incomplete
11:55:48 <jefimenko> what if there's no bongo drum around
11:56:07 <jefimenko> and no women and no interesting physics problems
11:56:31 <aleksejs_> Hi, newbie question: what should I use if I want to detect which special key was pressed, like arrows, pgup/dn etc?
11:56:38 <ReinH> Also it fails to include the chase skirt identity arrow
11:56:57 <ReinH> aleksejs_: depends on what environment you are detecting keypresses in :)
11:57:03 <aleksejs_> cli
11:57:25 <ReinH> aleksejs_: So just attached to a tty or some sort of curses type thing?
11:57:55 <ReinH> Generally: these keys send escape sequences, although arrows are a bit of a problem.
11:59:33 <orzo> is an "association list" a *sorted* list of pairs?  Or does order not matter?
11:59:51 <aleksejs_> is there a way to get an code of the key pressed?
12:01:10 <ReinH> byorgey: btw I just found out about the FARM workshop and feel even worse for not coming to ICFP this year :(
12:01:43 <ReinH> orzo: it is ordered but not (necessarily) sorted.
12:02:25 <inf-groupoid> Is there anything like a "seq" for arrays, which forces its elements to be evaluated to WHNF "in order"?
12:03:48 <ReinH> inf-groupoid: you can map it, but why do you want to do this?
12:04:17 <orzo> thanks, reinH
12:04:51 <inf-groupoid> ReinH: I am trying to speed up a toy program that computes the longest common subsequence of two lists.
12:05:02 <ReinH> aleksejs_: getChar should work. Try `getChar >>= putStrLn . show` in ghci and then press an arrow or w/e key.
12:05:14 <ReinH> aleksejs_: you might need to use NoBuffering mode, which probably won't work on windows...
12:05:29 <aleksejs_> i'm on linux
12:05:33 <ReinH> inf-groupoid: you shouldn't need to do that then
12:06:02 <ReinH> aleksejs_: for me, `getChar >>= putStrLn . show` prints the escape sequence for the arrow key I press
12:06:07 <joelteon> How do you install happy without happy?
12:07:01 <inf-groupoid> ReinH: So, then, it is expected that the program be slow when given inputs like [0..1000] and [0,2..2000]?
12:07:27 <inf-groupoid> The program is here: http://lpaste.net/96604
12:08:42 <ReinH> inf-groupoid: it's expected that some versions of the program will be slow, but it is unlikely that forcing will fix them :)
12:08:54 <inf-groupoid> Ah.
12:09:06 <ReinH> inf-groupoid: for instance, you're doing a lot of indexing into structures where indexing is expensive :)
12:09:26 <ReinH> (!) is O(n)
12:09:32 <inf-groupoid> Oh!
12:09:42 <inf-groupoid> I did not expect that.
12:10:35 <ReinH> inf-groupoid: Haskell lists are linked lists :)
12:10:35 * hackagebot JuicyPixels 3.1.2 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.2 (VincentBerthoux)
12:11:00 <Eduard_Munteanu> Is there a reason newtypes can't be existential?
12:11:06 <inf-groupoid> ReinH: Yes, I know that.
12:11:50 <ReinH> inf-groupoid: indexing into a linked list requires traversing the list up to the index :)
12:12:22 <inf-groupoid> ReinH: But if (!) is calculated a second time on the same index, the list should not have to be traversed again.
12:13:26 <tomejaguar> inf-groupoid: What do you mean by "should"?
12:14:34 <inf-groupoid> tomejaguar: If I understand correctly, listArray should (lazily) build an array whose elements are the same as those of a given list.
12:15:33 <adrian_berg> bergmark: I think your guess is accurate, but what about Map k a - > Map k b?
12:15:47 <inf-groupoid> tomejaguar: Since the array's elements are initialized lazily, the first time I do "arr ! i" for any "i", I expect that the list should be traversed until the i-th element is found.
12:16:06 <adrian_berg> this is in response to your response in me asking how the mergeWithKey function works
12:16:09 <tomejaguar> inf-groupoid: Oh right.  Yes what you say sounds plausible.
12:16:18 <inf-groupoid> tomejaguar: But if I do "arr ! i" a second time for the same "i", the array should be queried directly, instead of re-traversing the list.
12:16:23 <adrian_berg> I still don't understand how it works
12:16:25 <byorgey> Eduard_Munteanu: newtypes could in theory have "pure" existentials, i.e.   newtype Foo a = Foo (Bar a b)
12:16:32 <byorgey> Eduard_Munteanu: but those are not very useful.
12:16:55 <pavonia> adrian_berg: Are you asking how it works or what it does?
12:16:57 <ReinH> inf-groupoid: "the array should be queried directly" doesn't make sense to me. An expression (x ! i) that appears in multiple places may be be shared.
12:17:02 <Eduard_Munteanu> byorgey: pure how, like a strong sum?
12:17:18 <byorgey> Eduard_Munteanu: you can't have something like  Foo a = Eq b => Foo (Bar a b), though, because newtypes are supposed to have the same runtime representation as what they wrap, so there would be no place to put the dictionary
12:17:34 <byorgey> Eduard_Munteanu: by pure in this case I just mean "without any class constraints"
12:19:08 <adrian_berg> pavonia: how it works, mainly, but also what it does, because maybe I have a misconception
12:19:22 <nadirs> beginner question: is there something like python's pip's requirements.txt to express the modules needed by a project? Is a cabal package the simplest solution for defining dependencies?
12:19:42 <ReinH> inf-groupoid: oh, your arr is an array
12:19:52 <inf-groupoid> ReinH: Yes.
12:19:56 <inf-groupoid> ReinH: My intuition about (boxed, immutable) arrays is that they are a bunch of thunks that, when forced, are initialized to a corresponding element in a list. Is this right?
12:20:06 <Eduard_Munteanu> byorgey: hm, thanks, I can see the dict issue.
12:21:08 <ReinH> nadirs: this is what cabal and .cabal files are for.
12:21:34 <ReinH> nadirs: if you use `cabal init` in the root directory of your Haskell project it will create a .cabal file for you.
12:21:36 <tomejaguar> inf-groupoid: That's also my intuition but I don't know if it's actually true ;)
12:21:45 <ReinH> inf-groupoid: that seems reasonable :)
12:22:33 <inf-groupoid> Like 30 minutes ago, I was wondering whether there is some way to initialize immutable arrays other than using lists.
12:22:42 <nadirs> ReinH: thanks! I'll try it right away
12:23:58 <inf-groupoid> Now, instead of wondering, I will ask: Is there some way to initialize arrays other than using lists? For example, passing directly a function takes an index and returns a value.
12:25:24 <pavonia> adrian_berg: It's merging two maps by applying the first function to all elements that ale in both maps. After that it's applying the other functions to the resulting map, so that elements that are only present in either of the maps are handled properly
12:26:17 <Eduard_Munteanu> inf-groupoid: why not initialize it with  [ (i, f i) | i <- indices ] ?
12:27:10 <pavonia> adrian_berg: Imagine a Venn diagram. The first functions defines what to do with the intersection of all elements, the second for A \\ B, and the third for B \\ A (at least that's my understanding)
12:28:50 <inf-groupoid> Eduard_Munteanu: My problem is the need to traverse a potentially long list to compute the last elements of a potentially big array.
12:29:39 <inf-groupoid> Eduard_Munteanu: Oh, never mind. I misunderstood.
12:29:56 <Eduard_Munteanu> inf-groupoid: I don't think 'array' provides that. Under certain circumstances the list could be fused away.
12:30:02 <inf-groupoid> Eduard_Munteanu: My problem is that I cannot tell in advance how I should order that list.
12:30:58 <Eduard_Munteanu> inf-groupoid: then who are you passing that function to, and how does it know the required order of indices?
12:31:35 <Eduard_Munteanu> inf-groupoid: do you mean you want to build an array statefully?
12:32:06 <tomejaguar> inf-groupoid: Can you describe your use case?
12:33:27 <inf-groupoid> Eduard_Munteanu: An immutable array is a bunch of lazy thunks, right? Using the existing Data.Array interface, when each thunk is forced, a list is traversed to find the value of the corresponding array element. Instead of traversing the list, I want to evaluate a function that takes the index as argument.
12:34:08 <inf-groupoid> tomejaguar: http://lpaste.net/96604 -- My use case is speeding this code. "lcsseq [0..1000] [0,2..2000]" is horribly slow.
12:34:15 <Eduard_Munteanu> inf-groupoid: use unboxed arrays then
12:34:41 <Eduard_Munteanu> inf-groupoid: or you can force the value when you construct it.
12:35:07 <ReinH> inf-groupoid: have you tried memoizing instead?
12:35:10 <Eduard_Munteanu> Not exactly sure what you're thinking of, but I should mention Data.Array arrays aren't lists themselves.
12:35:34 <inf-groupoid> ReinH: The array itself is what I am using for memoization purposes. :-|
12:35:45 <inf-groupoid> Eduard_Munteanu: I am aware of that.
12:36:20 <ReinH> inf-groupoid: I would just use something like Data.MemoCombinators :)
12:36:23 <inf-groupoid> I only said that forcing the thunk corresponding to an element requires traversing a list. (If I understand correctly, that is.)
12:36:30 <ReinH> inf-groupoid: No sense in writing all the memoization boilerplate yourself
12:36:44 <inf-groupoid> Ah!
12:37:04 <ReinH> inf-groupoid: that sort of thing is difficult to get right due to, e.g., laziness ;)
12:37:33 <inf-groupoid> Oh, these memoization combinators look interesting. :-)
12:37:45 <Eduard_Munteanu> inf-groupoid: not if you construct it from an (i, f i).
12:38:01 <ReinH> inf-groupoid: so this is the normal naive lcs, right?
12:38:08 <ReinH> > let longest xs ys = if length xs > length ys then xs else ys; lcs (x:xs) (y:ys) | x == y = x : lcs xs ys | otherwise = longest (lcs (x:xs) ys) (lcs xs (y:xs)); lcs [] _ = []; lcs _ [] = [] in lcs [1,2,3,5] [1,2,3,4]
12:38:09 <lambdabot>   [1,2,3]
12:38:59 <Eduard_Munteanu> inf-groupoid: if you pass the [(i, f i)] to array, then dereferencing a certain i doesn't require going over that list, I don't think the array backbone is lazy.
12:39:46 <Deams> Hey again everyone.
12:39:47 <Eduard_Munteanu> inf-groupoid: an array has thunks in the cells.
12:40:13 <Eduard_Munteanu> inf-groupoid: that is, only the value is behind the thunk
12:40:22 <inf-groupoid> Eduard_Munteanu: That just allows me to "configure" (so to speak) which elements take the longest to force - the ones that are closest to the end of the list.
12:40:34 <inf-groupoid> Eduard_Munteanu: Yes, I am aware that each cell is a thunk.
12:41:31 <Eduard_Munteanu> :t listArray
12:41:31 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
12:41:37 <Eduard_Munteanu> :t array
12:41:38 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
12:41:56 <Deams> I'm having trouble installing haste-compiler because of the "base" dependency.
12:42:50 <inf-groupoid> "listArray bounds elems" is the same as "array bounds $ zip (range bounds) elems", IIUC.
12:42:54 <Eduard_Munteanu> inf-groupoid: just to be clear, I mean 'arr ! i' only hides the 'e' behind the thunk, not constructing the cell itself.
12:43:44 <ReinH> inf-groupoid: so with some loss of generality you can do: import qualified Data.MemoCombinators as M; memoizedLCS = M.memo2 intList intList lcs where intList = M.list M.integral
12:44:12 <Eduard_Munteanu> That is, once you have an array, the list has already been evaluated in the index argument and spine.
12:44:50 <ReinH> inf-groupoid: although this library also looks interesting http://hackage.haskell.org/package/monad-memo
12:47:12 <inf-groupoid> Eduard_Munteanu: "once you have the array, the list has already been evaluated in the index argument and spine" --> Then why would (!) be O(n)?
12:47:24 <ReinH> inf-groupoid: that's true for lists, not arrays. My mistake
12:47:26 <inf-groupoid> ReinH: lemme see
12:47:46 <inf-groupoid> It's !! for lists AFAIK. :-O
12:47:49 <ReinH> and ofc it's (!!) for lists so I'm just all around wrong :D
12:48:13 <Eduard_Munteanu> > let ar = array (1,2) [(1, 1), (expensive, 2)]; expensive = sum [1..10000000] `seq` 2 in ar ! 1
12:48:18 <lambdabot>   mueval-core: Time limit exceeded
12:48:19 <lambdabot>  mueval: ExitFailure 1
12:48:19 <lambdabot>  mueval: Prelude.un...
12:48:37 <Eduard_Munteanu> > let ar = array (1,2) [(1, 1), (2, 2)]; expensive = sum [1..10000000] `seq` 2 in ar ! 1
12:48:38 <lambdabot>   1
12:48:48 <Eduard_Munteanu> inf-groupoid: ^^
12:48:56 <inf-groupoid> Ah!
12:49:24 <ReinH> Eduard_Munteanu: well the second one doesn't use expensive...
12:50:11 <ReinH> I think you mean
12:50:13 <ReinH> > let ar = array (1,2) [(1, 1), (2, expensive)]; expensive = sum [1..10000000] `seq` 2 in ar ! 1
12:50:14 <lambdabot>   1
12:50:37 <ReinH> so arrays are strict in their indexes
12:50:40 <Eduard_Munteanu> ReinH: no, my point was array cells themselves are strict
12:50:48 <Eduard_Munteanu> ReinH: exactly
12:51:03 <ReinH> Eduard_Munteanu: well, the second example doesn't use expensive in the array construction :)
12:51:31 <Eduard_Munteanu> ReinH: oh... I meant to show it's not just lambdabot slowness and it works for non-expensive computations in the index.
12:51:49 <ReinH> well expensive is never evaluated...
12:52:04 <Eduard_Munteanu> I know, I didn't bother deleting it in the 2nd run.
12:52:12 <ReinH> I thought you were showing that it's strict in keys and non-strict in values :)
12:52:29 <ReinH> oh ok :)
12:52:31 <Eduard_Munteanu> ReinH: both examples were meant to illustrate the first part
12:52:38 <ReinH> alright :)
12:52:47 <ReinH> well I tacked on non-strict in values for you ;)
12:52:56 <tomejaguar> > let ar = array (1,2) [(1, 1), (2, expensive)]; expensive = undefined `seq` 2 in ar ! 1
12:52:57 <lambdabot>   1
12:53:08 <Eduard_Munteanu> Yep. :)
12:53:11 <ReinH> tomejaguar: that's... extremely expensive :)
12:53:20 <tomejaguar> Depends if you've got insurance
12:53:23 <ReinH> heh
12:53:28 <Deams> seems like cabal can't install base due to version numbers... Someone know how to resolve this kind of problem?
12:53:29 <ReinH> maximally expensive
12:53:35 <Eduard_Munteanu> tomejaguar: hm, that's odd...
12:53:48 <ReinH> Eduard_Munteanu: doesn't seem odd?
12:54:02 <Eduard_Munteanu> Oh, duh, I was reading it as   (expensive, 2)
12:54:03 <tomejaguar> expensive = undefined `seq` 2 is just expensive = undefined, anyway
12:54:17 <Eduard_Munteanu> Yeah, makes sense.
12:54:42 <Eduard_Munteanu> Deams: you shouldn't cabal install base
12:54:46 <ReinH> inf-groupoid: memo-combinators is pretty great :)
12:54:56 <Eduard_Munteanu> Deams: just update your Haskell Platform
12:56:04 <Deams> I'm using the last version :/ But seems Haste-compiler doesn't like it.
12:56:17 <ReinH> speaking of which, haskell.org/platform still lists 2013.2.0.0 as latest when 2013.4.0.0 was (supposed to have been) released on Nov 4th?
12:56:41 <inf-groupoid> ReinH: I am going to rewrite this using memo-combinators. :-)
12:57:02 <ReinH> inf-groupoid: seems good :)
12:57:11 <ReinH> inf-groupoid: did you see my version?
12:57:19 <ReinH> inf-groupoid: the memoized version gets pretty good performance :)
12:57:42 <ReinH> sometimes naive algorithms just need a little memoization :)
12:58:47 <ReinH> btw has anyone upgraded to Mavericks yet? How's HP working?
12:59:31 <ReinH> Oh there's a thread https://www.mail-archive.com/ghc-devs@haskell.org/msg02809.html
13:00:09 <inf-groupoid> ReinH: I'm checking it out.
13:01:10 <ReinH> So the story is that GHC 7.6.3 doesn't work on Mavericks and 7.6.4 hasn't been released yet, so HP is holding off?
13:01:16 <ReinH> Well, glad I haven't updated yet o_O
13:01:52 <chirpsalot> ReinH: GHC 7.6.3 doesn't work on Mavericks?
13:02:19 <Kaini> ReinH, it works for me, but i've not built anything "complex" yet
13:02:21 <chirpsalot> It seems to be working for me.
13:02:34 <monochrom> what is Mavericks? does it mean XCode 5?
13:02:37 <ReinH> chirpsalot: maybe it does, I'm just going by what I've read
13:02:38 <chirpsalot> I have mostly just been using ghci for quick things, though.
13:02:43 <Deams> 5hours to install a simple lib and still doesn't work :D I'm cursed.
13:02:47 <ReinH> monochrom: I think I just mean XCode 5, yes.
13:02:53 <ReinH> And I think you just have to hack around the lack of gcc?
13:02:54 <monochrom> then see the topic at the end
13:03:00 <ReinH> ah
13:03:07 <ReinH> monochrom: thanks
13:03:29 <ReinH> Well, maybe today is the day I upgrade to Mavericks then.
13:07:24 <chirpsalot> ReinH: "upgrade" :P.
13:07:50 <chirpsalot> I have had other problems with it, so I would advise caution :).
13:09:25 <ReinH> chirpsalot: oh joy :/
13:09:35 <ReinH> yeah I'm not really sure why I would upgrade
13:09:39 <ReinH> except, well, it's new
13:09:42 <ReinH> so maybe not
13:10:03 <Twey> Because the Apple gods have decreed it
13:10:49 <Deams> Someone knows a simple gui library? I'm developing a 9 men's morris game.
13:13:45 <chirpsalot> ReinH: Chrome crashes a bunch now, and if you read PDFs Preview has some more issues now. It's still usable, though.
13:14:01 <ReinH> chirpsalot: well chrome already crashes a bunch for me :)
13:14:21 <ReinH> in fact it just crashed like 10 minutes ago
13:15:44 * hackagebot hzk 2.0.0 - Haskell client library for Apache Zookeeper  http://hackage.haskell.org/package/hzk-2.0.0 (DiegoSouza)
13:15:51 <chirpsalot> ReinH: hmmm, I didn't have any problems before. Ah well. Mileage may vary.
13:29:33 <ReinH> chirpsalot: oh it's been varying...
13:41:12 <raek_> has "trivial" been replaced by (==>) in QuickCheck 2?
13:44:18 <awestroke> How can a computation be liften from the IO monad? I'm trying to understand the code in http://ocharles.org.uk/blog/posts/2013-12-05-24-days-of-hackage-scotty.html. My guess is that ActionM is ultimately transformed into an IO action and composed with all other IO actions, am I correct?
13:44:36 <awestroke> lifted*
13:45:50 <ReinH> awestroke: from Scotty's source (http://hackage.haskell.org/package/scotty-0.5.0/docs/src/Web-Scotty-Types.html#ActionT)
13:46:17 <ReinH> awestroke: ActionM a = ActionT IO a, which means that ActionM is a monad stack with IO at the base, which means that liftIO takes an IO action and runs it in the IO monad.
13:46:24 <hpc> awestroke: your intuition is pretty much correct
13:46:25 <ReinH> :t liftIO
13:46:26 <lambdabot> MonadIO m => IO a -> m a
13:46:50 <hpc> eventually you do some kind of runActionM which produces IO Something
13:46:58 <johnw> "lifting" allows a base computation to be lifted to run in the current transformer
13:47:01 <ReinH> awestroke: although technically, it transforms an IO action into an m a of the MonadIO m :)
13:47:07 <ReinH> rather than the other way around
13:47:22 <ReinH> and then eventually *that* is run in IO, so yes
13:48:05 <YuleAthas> I'm trying to install th-orphans 0.8 on GHC 7.4.1 and I get this error from cabal: 'th-orphans-0.8 failed during the building phase. The exception was: ExitFailure 11'.
13:48:11 <johnw> if your base state is being naked, then you lift yourself into clothing in order to act within society, even though you're still naked underneath
13:48:24 <awestroke> How many explanations must one read before understanding monads?
13:48:29 <YuleAthas> So... GHC is segfaulting?
13:48:32 <johnw> awestroke: exactly one more than you think
13:48:40 <YuleAthas> awestroke: one, but it has to be the right one.
13:48:51 <mizu_no_oto> Is there a name for the general technique of handling errors via sum types like Maybe and Either, to distinguish it from things like return codes, error codes, and exceptions?
13:49:04 <YuleAthas> mizu_no_oto: well... it's monadic error handling.
13:49:13 <johnw> awestroke: you can understand *a* particular monad long, long before you understand Monad in isolation from its instances
13:49:15 <ReinH> awestroke: you don't understand monads by reading explanations, you understand monads by *giving* explanations.
13:49:22 <YuleAthas> mizu_no_oto: it's conceptually the same thing as return codes, just abstracted away.
13:49:29 <johnw> Maybe is a super easy monad
13:49:48 <ReinH> awestroke: if nothing else, by explaining to your computer how you want to use them ;)
13:49:50 <johnw> return a = Just a; join (Just (Just a)) = Just a; join _ = Nothing
13:49:55 <johnw> there, that's all there is to the Maybe monad
13:50:03 <begriffs> When I run "cabal update" what is it changing on my local filesystem exactly?
13:50:25 <ReinH> johnw: fmap f (Just a) = Just (f a); fmap _ _ = Nothing
13:50:26 <johnw> begriffs: the set of available packages in ~/.cabal should be all
13:50:41 <awestroke> alright thanks guys :)
13:51:14 <mizu_no_oto> YuleAthas: it's a bit different from return codes, because return codes don't use a Sum type but conflate error values and actual values - if atoi returns 0, did they pass in "0" or "not a number"?
13:51:56 <ReinH> johnw: join isn't quite as useful without fmap ;)
13:52:00 <YuleAthas> mizu_no_oto: no, it's just a different implementation.  You pass output parameters (pointers to memory) if the return value alone would be ambiguous.
13:52:07 <begriffs> johnw: looking at the files in ~/.cabal none of them seem to list packages and versions (I'm on a mac).
13:52:08 <johnw> ReinH: I don't think about fmap when I think of join in my head
13:52:13 <ReinH> johnw: ok :)
13:52:24 <YuleAthas> And I suppose errno represents which constructor of the "error type" is used.
13:52:42 <ReinH> johnw: but how do you get your m (m a) without fmapping an action?
13:52:43 <johnw> ReinH: I think "how can two contexts combine to form a composition context"?
13:52:54 <johnw> join (Just (Just a)) = Just a, doesn't require me to use fmap
13:52:58 <ReinH> that's true :)
13:53:02 <johnw> i only need fmap if I don't know what functor I'm using
13:53:14 <YuleAthas> mizu_no_oto: I think return codes and monadic error handling are simular, in that error/success-information is always passed directly to the caller.  This is in contrast to exception systems, where a table is consulted to see who should handle the error condition.
13:53:16 <ReinH> And join is the essence of monad, acknowledged.
13:53:43 <ReinH> everything else comes (at least in principle) from functor and applicative
13:59:35 <YuleAthas> On a Debian system, where am I supposed to get libgmp.so.3 nowadays?
13:59:59 <apo> just install gmp?
14:00:01 <ReinH> johnw: join is also what makes it all monoidy, ofc ;)
14:00:13 <johnw> YuleAthas: sometimes, you can even just symlink your existing libgmp.so under that name
14:00:25 <johnw> ReinH: join, return and the laws, sure
14:00:34 <johnw> but I also see join as the "meat" of it
14:00:40 <ReinH> johnw: yes exactly :)
14:00:54 <johnw> often when I'm writing a new monad, I write join, and then use substitution to arrive at >>=
14:00:57 <YuleAthas> johnw: ugh, yes, that's what I ended up doing.
14:01:02 <ReinH> the way a monad joins is what really defines that monad's behavior
14:01:13 <ReinH> yep!
14:01:13 <YuleAthas> Really weird that the Haskell Platform doesn't work on Debian Stable.
14:01:23 <ReinH> YuleAthas: seems like a bug?
14:01:39 <johnw> ReinH: would you say that monoids are also defined by multiplication?  although, what mempty ends up being is sometimes just as critical
14:01:55 <johnw> there are times when I use monoids simply to have mempty, not because I need mappend
14:02:07 <ReinH> johnw: ok, join is what makes them all semigroupy ;)
14:02:20 <johnw> right
14:02:25 <FreeFull> A class with mempty and without mappend probably wouldn't have enough laws
14:02:34 <johnw> ReinH: edwardk's Bind class
14:02:49 <johnw> FreeFull: I mean, a monoid with mappend, but I don't necessarily need it
14:02:58 <johnw> i want it for the laws, and the option to use it
14:03:17 <johnw> to represent "I don't know"
14:03:35 <quchen> begriffs_: Rename .cabal, then run "cabal update". You'll see the files generated by that command.
14:03:38 <johnw> in a way, Data.Default is mempty without any laws or mappend
14:04:08 <johnw> begriffs_: you can implement "cabal update" without cabal very trivially, btw
14:04:08 <ReinH> johnw: well, you can form a free monoid from Data.Default right?
14:04:14 <johnw> just so you know that very little is being done by that command
14:04:32 <ReinH> i.e. given a set with identity, you can form a free monoid via First or Last?
14:05:08 <johnw> ReinH: when you said free monoid, I thought of []
14:05:15 <ReinH> johnw: right, not S* :)
14:05:19 <ReinH> a different free functor
14:05:31 <quchen> begriffs_: I think the main database is in ~/.cabal/packages/hackage.haskell.org/00-index.tar.
14:05:35 <johnw> you mean, just "monoidizing" any set with a distinguished element?
14:05:41 <ReinH> right
14:05:56 <johnw> yeah, I suppose you could use lots of semigroups to give you the mappend definition
14:05:57 <ReinH> isomorphic to the Maybe monoid
14:06:26 <ReinH> i.e. invertible by mapping Nothing with your distinguished member
14:06:42 <quchen> YuleAthas: The GHC build servers link against an old version of libgmp, I had the same error.
14:06:56 <quchen> Apparently the next release will be built on upgraded servers.
14:06:57 <johnw> essentially, cabal update comes down to downloading 00-index.tar.gz, and sticking it in your .cabal as 00-index.tar
14:07:12 <johnw> (ungzipped, of course)
14:07:12 <ReinH> johnw: yeah
14:07:14 <ReinH> johnw: not sure how useful this is
14:08:03 <quchen> YuleAthas: One risky method you could try is symlinking .so.3 to whatever GMP version you have installed. I don't know whether that works and if it does what it breaks.
14:08:18 <quchen> I ended up compiling GHC myself to get proper linking.
14:08:36 <ReinH> quchen: I suppose it breaks GHC, but probably not much else...
14:09:03 <quchen> ReinH: You can't break a non-running ghc :-þ
14:09:24 <ReinH> quchen: well that's fair :)
14:09:34 <ReinH> then I suppose it can't break anything ;)
14:09:47 <quchen> In a perfect world no.
14:10:03 <ReinH> I guess I don't know how secure gmp is
14:10:04 <quchen> But there is going to be some program that depends on the lowest GMP version available. There is always such a program.
14:10:14 <ReinH> heh
14:10:50 * hackagebot cmdargs 0.10.6 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.10.6 (NeilMitchell)
14:10:54 <quchen> That program is VMLinuz. I dare you to try that out. :-þ
14:11:31 <ReinH> no thanks
14:23:23 <Yuu-chan> Kudos to those who recommended me gloss.
14:26:29 <quchen> I just wish Gloss had anti-aliasing
14:26:39 <quchen> And if it did I wished I knew about it
14:27:35 <joeyh> are there test builds of the next haskell platform someplace?
14:27:39 * joeyh needs a newer ghc on windows
14:29:17 <Zack__> I'm puzzling over some homework, it's about tree traversal
14:29:23 <Zack__> now, I get how to traverse a tree
14:29:26 <lightquake> is there a good length-typed vector package? (i.e., one where you can express the notion of 'vector of length 5' while still getting good performance)
14:29:29 <Zack__> however, I'm supposed to find the maximum value
14:29:36 <Zack__> but I can't see how I can retain that information
14:29:51 <quchen> joeyh: There is no next platform right now; it's in the planning phase on the mailing lists
14:30:06 <ReinH> quchen: use antialiasing in gloss with this one weird trick: implement antialiasing. ;)
14:30:06 <Zack__> I mean, I visit node after node, but if I kept an accumulator, it would just be overwritten with any maximum found in a subtree
14:30:41 <Zack__> (the tree can contain elements in any order, so it's not like a priority queue)
14:30:53 <ReinH> joeyh: the wording could probably better reflect that, i.e. by not saying that 2013.4.0.0 was released in november...
14:30:57 <lightquake> Zack__: why do you say that? what traversal function are you using?
14:31:23 <Zack__> lightquake: I wrote a function quite similar to what you find on wikipedia
14:31:27 <ReinH> Zack__: can you implement maximum on a list with an accumulator?
14:31:33 <Zack__> http://en.wikipedia.org/wiki/Tree_traversal
14:31:45 <Zack__> ReinH: yes, I know how to find the maximum in a list
14:32:00 <ReinH> Zack__: ok, and what makes a tree different?
14:32:13 <Zack__> just put the first element in the accumulator when you start, then compare every element in the rest of the list to the value in the accumulator and swap if bigger
14:32:30 <ReinH> right, and why can't you do that for a tree?
14:32:31 <Zack__> ReinH: in a list I look at one element after another
14:32:40 <ReinH> Zack__: that's what you do in a tree too.
14:32:53 <ReinH> You just decide in what order you want to traverse the tree
14:32:55 <Zack__> in a tree, I'm suddenly dealing with a lot of subtrees
14:32:59 <ReinH> but the traversal is still sequential
14:33:14 <Zack__> oh, I think I get it now
14:33:18 <monochrom> accumulator works, but there are other ways.
14:33:23 <Zack__> I just ignore part of the tree
14:33:34 <Zack__> monochrom: what are the other ways?
14:33:35 <monochrom> for a tree, do not refrain from multiple recursive calls
14:33:42 <ReinH> Zack__: at any given time you are looking at exactly one node in the tree
14:33:46 <jrmithdobbs> so, i think I've just realised that Data.Default is not as useful as I think it should be ...
14:34:05 <jrmithdobbs> is there not a way to define an instance for an algebraic type without phantom type/gadt trickery?
14:34:21 <Zack__> monochrome: that was my problem: I didn't see how to maintain an accumulator when making multiple recursive calls
14:34:46 <jrmithdobbs> eg, i want data TypeA = TypeA1 { a123 :: String } | TypeA2 { a1234 :: Int } deriving (Show) ; deriving instance Default TypeA where ... ;
14:34:48 <monochrom> tree_max (Branch number left_subtree right_subtree) = maximum [number, tree_max left_subtree, tree_max right_subtree]
14:35:05 <lightquake> jrmithdobbs: why are you writing 'deriving instance Default' and not just 'instance Default TypeA where ...'?
14:35:08 <jrmithdobbs> there doesn't seem to be a way to specifiy (stmt :: (TypeA TypeA1))
14:35:10 <ReinH> jrmithdobbs: it can't be derived, no, but you can write your own instance
14:35:14 <jrmithdobbs> lightquake: typo
14:35:27 <lightquake> instance Default TypeA where def = TypeA1 "hello world"
14:35:47 <ReinH> Zack__: what tree definition are you using?
14:36:04 <jrmithdobbs> right, but I want to be able to do something like ((def :: TypeA2), (def :: TypeA1))
14:36:17 <Zack__> ReinH: something predefined from the homework exercises ;)
14:36:24 <ReinH> jrmithdobbs: you can only have one default value.
14:36:25 <jrmithdobbs> i can figure out-ish how to do it with phantom types but was wondering if i was missing a way to do it without
14:36:32 <Zack__> data NTree = NilT  | Node Int NTree NTree
14:36:53 <ReinH> Zack__: so a binary tree.
14:36:54 <Zack__> i.e. a tree of integers; can be empty (NilT) or contain a node with a value and two subtrees
14:36:58 <Zack__> yes
14:37:10 <jrmithdobbs> ReinH: ok, thanks, so it is limited the way I thought, even if I expressed it poorly :)
14:37:17 <lightquake> jrmithdobbs: for that you need something phantom type-like, because there's no other way to distinguish a default TypeA1 from a default TypeA2
14:37:54 <jrmithdobbs> now i need to go stare at a wall and figure out if rearranging this is worth the pay off ;p
14:38:17 <ReinH> jrmithdobbs: is foo :: TypeA1 a valid type signature?
14:39:10 <jrmithdobbs> ReinH: not currently no, TypeA1 in the example is a type constructor, so TypeA would need to be transformed to something like: MyClass => a TypeA a = ... etc
14:39:11 <begriffs_> Oh, if I am using a cabal sandbox do I have to call "cabal update" differently? I see my sandbox has a .cabal-sandbox/packages/00-index.tar
14:39:37 <dcoutts_> begriffs_: no, that doesn't change
14:39:37 <begriffs_> Maybe a regular update only affects ~/.cabal but not the sandboxed one
14:40:15 <ReinH> Zack__: how would you implement fmap for your tree?
14:40:20 <jrmithdobbs> ReinH: i'm just playing around trying to avoid doing any real work in dec, really :)
14:40:41 <lightquake> begriffs_: iirc as long as you're in the directory with the .cabal-sandbox you can just use the usual cabal commands
14:40:42 <begriffs_> dcoutts_: the sandbox one just says which packages are cached, and the ~ one says which are remotely available I'm guessing?
14:41:11 <ReinH> jrmithdobbs: if foo :: TypeA1 isn't a valid type signature, how can you write a function with that signature? ;)
14:41:21 <dcoutts_> begriffs_: you can take a look, vi .cabal-sandbox/packages/00-index.tar
14:41:48 <jrmithdobbs> ReinH: surprisingly, I'm going to thank you for that comment
14:41:55 <ReinH> jrmithdobbs: :p
14:42:04 <jrmithdobbs> ReinH: I hadn't thought about it from that angle, but if I had I'd have saved myself a lot of second guessing just now
14:42:39 <stolaruk> I have an (a -> b) function and a [Maybe [a]] ... how can I map the function over each list of a's inside each Maybe in the Maybe list?
14:43:06 <ReinH> jrmithdobbs: right, and answering "how do I make a default isntance for both TypeA1 and TypeA2" is the same as answering "how do I make foo :: TypeA1 and foo :: TypeA2 valid type signatures" ;)
14:43:10 <roconnor_> stolaruk: fmap . fmap . fmap
14:43:22 <stolaruk> roconnor_: wow, ok I'll try it
14:43:31 <ReinH> fmap `fmap` fmap `fmap` fmap... don't listen to me
14:43:44 <quchen> :t (.).(.)
14:43:45 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:43:49 <ReinH> :t fmap . fmap . fmap
14:43:50 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
14:43:59 <quchen> inb4 ackertuple :-þ
14:44:17 <Zack__> ReinH: I'm not too familiar with fmap
14:44:34 <ReinH> Zack__: fmap for lists is: fmap f (x:xs) = f x : fmap f xs
14:44:40 <ReinH> Zack__: for lists, it's just map
14:45:19 <ReinH> Zack__: for binary trees, it's a lot like lists, except you have to recurse twice. (Because binary trees are just like lists, except they recurse twice)
14:45:20 <jrmithdobbs> ReinH: so the (eternal) question is, should TypeA become (TypeA a), or should I create separate types and given them shared membership in another class and use that restriction on the fuctions
14:45:28 <Zack__> ReinH: ah, that makes more sense. Thanks for the clarification
14:45:30 <ReinH> jrmithdobbs: good luck with that ;)
14:45:38 <jrmithdobbs> ReinH: hence: stare at wall comment ;p
14:46:05 <ReinH> Zack__: let's take this to #haskell-blah and write max for binary trees together :)
14:46:19 <Zack__> ReinH: thanks!
14:47:27 <jrmithdobbs> ReinH: at least my questions are making more and more sense over time. :)
14:48:00 <Bor0> how many #haskell-x channels are there? besides game and blah
14:48:16 <shachaf> Dozens.
14:48:18 <quchen> ReinH: #haskell-overflow is probably more appropriate.
14:48:31 <snizzo> I have to parse a gramma composed by integers and '('    ')' with happy. I really can't get out. From where I have to start? Like... using sequences?
14:48:41 <shachaf> Yes, #haskell-blah already has enough of people talking about Haskell.
14:48:42 <Eduard_Munteanu> Bor0: there are a few language-specific channels too
14:48:43 <snizzo> I already have the lexer which generates token
14:49:40 <Eduard_Munteanu> snizzo: what do ( ) mean?
14:50:10 <Eduard_Munteanu> Lists? Like (1 2 5 2)?
14:50:15 <snizzo> Eduard_Munteanu: example: 3 4 5 6 ( 4 3 2 ) 4 5
14:50:18 <snizzo> exactly
14:51:03 <snizzo> I achieved to parse a list successfully using the sequences part of the manual
14:51:11 <Eduard_Munteanu> snizzo: that's easy to parse even top-down
14:51:18 <snizzo> but I really can't get to parse lists of lists
14:52:06 <snizzo> for now I have this part of grammar working http://pastebin.kde.org/ppobbjcwn
14:52:15 <snizzo> the commented part was my attempt to solve it
14:52:53 <Eduard_Munteanu> snizzo: it seems to me you want an AST like data Foo = IsNumber Integer | IsFoo Foo
14:53:11 <Eduard_Munteanu> er...
14:53:16 <snizzo> AST?
14:53:24 <Eduard_Munteanu> Abstract syntax tree.
14:53:44 <snizzo> can you point me to some documentation also? sorry I'm new to haskell, I'm trying to learn :)
14:54:40 <Eduard_Munteanu> snizzo: I was just saying your sequence is composed of elements, which are either a number or another sequence.
14:55:33 <snizzo> wait... IsNumber has to be implemented or is automatically available in haskell?
14:55:54 <FreeFull> snizzo: the data Foo thing declares it
14:56:05 <snizzo> ohh yeah they are constructors
14:56:30 <stolaruk> @let
14:56:30 <lambdabot>  Define what?
14:56:46 <Eduard_Munteanu> data Elem = IsNumber Integer | IsSequence [Elem]
14:56:52 <stolaruk> @let tryMe = [Just [1..10], Nothing, Just [11..20]]
14:56:54 <lambdabot>  Defined.
14:57:11 <stolaruk> @fmap . fmap . fmap chr $ tryMe
14:57:12 <lambdabot> Maybe you meant: slap faq
14:57:41 <stolaruk> Uh..?
14:58:34 <FreeFull> > fmap . fmap . fmap chr $ tryMe
14:58:35 <lambdabot>   Couldn't match type `[GHC.Types.Char]' with `a0 -> b0'
14:58:35 <lambdabot>  Expected type: [GHC...
14:58:56 <stolaruk> @let tryMe = [Just [100..110], Nothing, Just [111..120]]
14:58:57 <lambdabot>  .L.hs:143:1:
14:58:57 <lambdabot>      Multiple declarations of `tryMe'
14:58:57 <lambdabot>      Declared at: .L.hs:1...
14:59:27 <stolaruk> > fmap . fmap . fmap Data.Char.chr $ tryMe
14:59:28 <lambdabot>   Couldn't match type `[GHC.Types.Char]' with `a0 -> b0'
14:59:28 <lambdabot>  Expected type: [GHC...
14:59:45 <stolaruk> I don't know what I'm doing wrong here.
14:59:52 <Eduard_Munteanu> snizzo: you need to think about your grammar
15:00:05 <FreeFull> > fmap (fmap (fmap chr)) $ tryMe
15:00:06 <ReinH> quchen: yep, my mistake was summarily corrected :)
15:00:08 <lambdabot>   [Just "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n",Nothing,Just "\v\f\r\SO\SI\DLE\DC1...
15:00:43 <stolaruk> fmap . fmap . (fmap chr) $ tryMe
15:00:46 <stolaruk> > fmap . fmap . (fmap chr) $ tryMe
15:00:47 <lambdabot>   Couldn't match type `[GHC.Types.Char]' with `a0 -> b0'
15:00:47 <lambdabot>  Expected type: [GHC...
15:01:16 <stolaruk> @FreeFull How would that be written using (.)
15:01:17 <lambdabot> Unknown command, try @list
15:01:28 <stolaruk> gaaah sorry
15:01:36 <stolaruk> FreeFull: How would that be written using (.) ?
15:02:15 <mauke> > (fmap . fmap . fmap) chr tryMe
15:02:17 <lambdabot>   [Just "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n",Nothing,Just "\v\f\r\SO\SI\DLE\DC1...
15:02:25 <stolaruk> oh wow
15:02:28 <stolaruk> haha
15:03:11 <stolaruk> Thanks FreeFull, mauke, and roconnor_
15:03:26 <mauke> > fmap fmap fmap fmap fmap fmap fmap fmap chr tryMe
15:03:27 <lambdabot>   [Just "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n",Nothing,Just "\v\f\r\SO\SI\DLE\DC1...
15:03:28 <stolaruk> I was really stumped
15:03:36 <mauke> YOU'RE WELCOME
15:03:38 <FreeFull> mauke: That's just cheating
15:04:18 <stolaruk> mauke: Is it typically written that way?
15:04:38 <mauke> ... no?
15:05:00 <stolaruk> ok
15:05:03 <Twey> Haha
15:05:13 <Twey> This is why people say Haskell is confusing
15:05:16 <lightquake> > tryMe
15:05:17 <lambdabot>   [Just [1,2,3,4,5,6,7,8,9,10],Nothing,Just [11,12,13,14,15,16,17,18,19,20]]
15:05:27 <mauke> it's not like I understand how it works
15:05:37 <mauke> I just added fmap until lambdabot stopped complaining
15:05:42 <Twey> Hahah
15:05:42 <lightquake> does lambdabot have lens in scope?
15:05:51 <hpc> @remember mauke I just added fmap until lambdabot stopped complaining
15:05:51 <lambdabot> I will never forget.
15:05:53 <mauke> > upon
15:05:54 <lambdabot>   No instance for (Control.Lens.Internal.Indexed.Indexable
15:05:55 <lambdabot>                   ...
15:05:55 <quchen> lightquake: Yes.
15:06:03 <shachaf> fmap fmap fmap fmap fmap fmap = fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
15:06:17 <stolaruk> > 100.to chr
15:06:18 <lambdabot>   No instance for (GHC.Num.Num
15:06:18 <lambdabot>                     (p0 GHC.Types.Int (f0 GHC....
15:06:24 <lightquake> > tryMe^..traverse.traverse.chr
15:06:25 <lambdabot>   Couldn't match type `GHC.Types.Int'
15:06:25 <lambdabot>                with `a0
15:06:25 <lambdabot>                ...
15:06:27 <FreeFull> :t upon
15:06:28 <lambdabot> (Data s, Data a, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
15:06:38 <lightquake> :(
15:06:56 <FreeFull> > tryMe & upon .~ 4
15:06:57 <lightquake> oh that doesn't do what i want anyway
15:06:57 <lambdabot>   Couldn't match type `p0 (Control.Lens.Internal.Setter.Mutator b1)'
15:06:58 <lambdabot>         ...
15:07:31 <lightquake> > tryMe^..traverse.traverse.traverse.chr
15:07:32 <lambdabot>   Couldn't match type `GHC.Types.Int'
15:07:32 <lambdabot>                with `a0
15:07:32 <lambdabot>                ...
15:07:35 <lightquake> > tryMe^..traverse.traverse.traverse.to chr
15:07:37 <lambdabot>   "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4"
15:07:41 <lightquake> sort of!
15:08:35 <donri> > tryMe ^.. template . to chr
15:08:37 <lambdabot>   ""
15:08:39 <donri> :(
15:08:56 <lightquake> @type tryMe
15:08:56 <FreeFull> Wasn't there some sort of deep traversal thing that traversed until it found a matching type
15:08:57 <lambdabot> (Enum t, Num t) => [Maybe [t]]
15:09:01 <codygman> :t replicateA
15:09:02 <lambdabot>     Not in scope: `replicateA'
15:09:02 <lambdabot>     Perhaps you meant one of these:
15:09:02 <lambdabot>       `Seq.replicateA' (imported from Data.Sequence),
15:09:14 <donri> > tryMe ^.. biplate . to chr
15:09:15 <lambdabot>   ""
15:09:19 <donri> > tryMe ^.. tinplate . to chr
15:09:20 <lambdabot>   ""
15:09:24 <donri> > tryMe ^.. uniplate . to chr
15:09:25 <lambdabot>   Couldn't match type `GHC.Types.Int' with `[Data.Maybe.Maybe [t0]]'
15:09:25 <lambdabot>  Expecte...
15:09:28 <lightquake> > (tryMe :: [Maybe [Int]]) ^.. template. to chr
15:09:29 <lambdabot>   "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4"
15:09:31 <donri> in which i try all versions to see if any DWIM
15:09:40 <lightquake> defaulting!
15:09:44 <donri> ya
15:10:10 <lightquake> i'm still curious how to express the original function, though
15:11:05 <johnw> > tryMe ^..biplate.to chr
15:11:07 <lambdabot>   ""
15:11:14 <johnw> ah, because they are defaulting to Integer
15:11:27 <johnw> > let tryMe2 = [Just [(100 :: Int)..110], Nothing, Just [111..120]]
15:11:29 <lambdabot>   not an expression: `let tryMe2 = [Just [(100 :: Int)..110], Nothing, Just [...
15:11:32 <johnw> @let tryMe2 = [Just [(100 :: Int)..110], Nothing, Just [111..120]]
15:11:33 <lambdabot>  Defined.
15:11:36 <johnw> > tryMe2 ^..biplate.to chr
15:11:38 <lambdabot>   "defghijklmnopqrstuvwx"
15:12:22 <FreeFull> Not quite
15:12:52 <lightquake> oh wait it's not going to be ^..
15:13:13 <FreeFull> > tryMe2 ^. biplate . to chr
15:13:14 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
15:13:14 <lambdabot>    arising from a use o...
15:15:29 <lightquake> aha
15:15:42 <lightquake> > over (mapped.mapped.mapped) chr tryMe
15:15:44 <lambdabot>   [Just "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n",Nothing,Just "\v\f\r\SO\SI\DLE\DC1...
15:16:06 <dario`> :t over
15:16:06 <lightquake> > tryMe & mapped.mapped.mapped %~ chr
15:16:07 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
15:16:07 <lambdabot>   [Just "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n",Nothing,Just "\v\f\r\SO\SI\DLE\DC1...
15:34:58 <mpjones> Newbie question: I think I'm after a function with this signature: (a -> b) -> a -> m b so that I can write: myfunc >>= (blah snd) where myfunc returns a (String,String) and I want a String in the Maybe context. I am doing something foolish?
15:35:26 <Eduard_Munteanu> :t return . ?f
15:35:26 <lambdabot> (Monad m, ?f::a -> b) => a -> m b
15:35:36 <shachaf> You probably want fmap (blah snd) myfunc
15:35:54 <shachaf> But note that myfunc probably isn't a function so calling it that is confusing.
15:35:56 <mpjones> Sorry, blah was a place holder for the function I'm after I think
15:35:59 <Eduard_Munteanu> Also 'arr f'.
15:36:14 <mpjones> Sorry, not super up on the correct words yet :)
15:36:19 <shachaf> mpjones: OK, then fmap snd myfunc
15:36:32 <shachaf> You can also write myfunc >>= return . snd
15:36:37 <shachaf> @src liftM
15:36:37 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
15:36:45 <shachaf> Which is what liftM does for you.
15:37:00 <shachaf> @@ @pl @undo @src liftM -- equivalent
15:37:01 <lambdabot>  (line 1, column 1):
15:37:01 <lambdabot> unexpected "<"
15:37:01 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:37:03 <shachaf> Bah.
15:37:39 <mpjones> I though liftM was: (a -> b) -> m a -> m b
15:37:53 <shachaf> It is.
15:38:07 <mpjones> I feel like I don't have the first "m". Hmm much to learn
15:39:17 <shachaf> What is the type of myfunc?
15:39:39 <mpjones> String -> Maybe (String, String)
15:40:45 <mpjones> I have something like: (return "") >>= myfunc >>= ...something with snd to get a Maybe String...
15:41:02 <mpjones> Confused about how to build put that last piece
15:41:03 <shachaf> But you wrote myfunc >>= ...
15:41:03 <Iceland_jack> mpjones: You don't need to do return "" >>= ...
15:41:11 <shachaf> I see.
15:41:22 <mpjones> Thanks, that was an awkward example
15:41:36 <Iceland_jack> mpjones: Maybe you should use the do-notation while you're getting familiar with monads
15:41:40 <mpjones> I'm pretty clueless, but I'm not actually doing (return "") in my code
15:42:05 <mpjones> I've done a little bit of do-notation, I was trying to experiment with >>=
15:42:12 <mpjones> Thank you for the suggestion though
15:42:45 <Iceland_jack> Maybe getting it to work using do-notation and then translating it to monadic notation, which is a completely mechanical task
15:43:32 <mpjones> Fair enough, thanks.
15:43:50 <mpjones> Poking around a bit maybe I just want myfunc >>= (Just . snd)
15:44:08 <Iceland_jack> Just = return :)
15:44:16 <Iceland_jack> and you can omit the parentheses
15:44:27 <Iceland_jack> @ty return :: a -> Maybe a
15:44:27 <lambdabot> a -> Maybe a
15:44:31 <Iceland_jack> @ty Just
15:44:31 <lambdabot> a -> Maybe a
15:44:33 <mpjones> Ahh, clicking into place.
15:44:51 <mpjones> So I should thank shachaf as well.
15:45:01 <mpjones> Thank you both
15:45:07 <Iceland_jack> also, instead of:
15:45:07 <Iceland_jack>     ma >>= return . snd
15:45:08 <Iceland_jack> you should write:
15:45:08 <Iceland_jack>     fmap snd ma
15:45:12 <shachaf> I was hoping someone else would mention it but I guess not.
15:45:24 <shachaf> return "" >>= myfunc = myfunc ""
15:45:31 <shachaf> That's one of the monad laws.
15:45:37 <shachaf> So you have myfunc "" >>= return . snd
15:45:44 <Iceland_jack> I alluded to it but mpjones said it wasn't the actual code
15:45:48 <shachaf> But liftM f m = m >>= return . f
15:45:54 <roboguy_> You can represent type equality with ~. Is there any way to represent type inequality?
15:46:01 <shachaf> So you have liftM snd (myfunc ""), i.e. fmap snd (myfunc "")
15:46:01 <Iceland_jack> roboguy_: no
15:46:06 <shachaf> roboguy_: Not really.
15:46:08 <mpjones> Actual code: processInfo tags _datamap = tags >>= (M.lookup "github") >>= processTag >>= return . snd
15:46:12 <roboguy_> Hmm, that seems strange to me
15:46:36 <geekosaur> there is yet another round of complaining about that on libraries@ currently
15:46:37 <Eduard_Munteanu> roboguy_: you can represent negation of equality
15:46:45 <AshyIsMe> so let's take a vote, Do I?:
15:46:56 <AshyIsMe> A) Fix bugs in my nodejs site?
15:46:57 <AshyIsMe> or
15:47:06 <AshyIsMe> B) Rewrite the whole thing in haskell with snap?
15:47:07 <geekosaur> (I think it's libraries. take N of the record extension discussion)
15:47:12 <shachaf> mpjones: OK, so you keep changing your code. :-(
15:47:15 <roboguy_> Eduard_Munteanu: Wouldn't that effectively be the same as type inequality? How would you do that?
15:47:54 <mpjones> Sorry, if that wasn't helpful. Haven't done much IRC questioning, so didn't know if providing it all without context would be useful or not. I guess I'll err on that in the future :)
15:47:56 <jmcarthur_mobile> type NotEqual a b = forall r. Equal a b -> r
15:47:58 <Eduard_Munteanu> roboguy_: for one thing it won't really help with instance resolution
15:48:11 <roboguy_> Eduard_Munteanu: Ah, well that's why I'm asking...
15:48:26 <Eduard_Munteanu> Or other type trickery that involves constraints.
15:48:31 <roboguy_> (to help with instance resolution)
15:48:32 <jmcarthur_mobile> roboguy_: it's pretty hard to instantiate that.
15:48:36 <shachaf> jmcarthur_mobile: Yes, except that doesn't work very well.
15:48:42 <jmcarthur_mobile> Right
15:48:44 <Eduard_Munteanu> The only thing it does is prevent you from writing values of said thing.
15:48:53 <shachaf> In Haskell98+Rank2Types you can't even make foo :: NotEqual Char Bool
15:49:01 <shachaf> (Assuming a Leibniz equality definition for Equal.)
15:49:15 <shachaf> You need GHC's dubious implementation of GADTs/TypeFamilies to make it work.
15:49:16 <jmcarthur_mobile> Indeed
15:49:25 <roboguy_> Hmm. Basically, I'm trying to find a good way to represent subtyping in Haskell since some problems seem most naturally expressed with subtypes
15:49:31 <jmcarthur_mobile> And it's really ugly
15:49:41 <Iceland_jack> roboguy_: Type classes go a long way
15:49:55 <roboguy_> and with the solution I'm working on right now, type inequality in instance definitions would be useful
15:50:05 <Iceland_jack> and are nicer imo, don't fight the language you're using
15:50:19 <shachaf> Then your solution is probably ill-suited for Haskell.
15:50:20 <jrmithdobbs> roboguy_: so far my experiences with haskell and subtypes is: you think you want this, you really don't
15:50:27 <Eduard_Munteanu> roboguy_: er, why inequality? The subtyping relation isn't an inequality in the same sense as type equality.
15:50:45 <roboguy_> I know I've heard that a lot, but I'm curious to at least see what it's like to try
15:51:04 <jrmithdobbs> roboguy_: gadts + typefamilies is probably what you want to look at
15:51:08 <roboguy_> Might learn some more about the type system in the proess
15:51:11 <Eduard_Munteanu> roboguy_: you want to define a separate subtyping relation
15:51:11 <roboguy_> *process
15:51:36 <roboguy_> Eduard_Munteanu: I have a (Subtype subtype supertype) class right now
15:51:45 <roboguy_> with a Iso' that converts between them
15:51:45 <jrmithdobbs> roboguy_: it's messy and ugly but you can make it usable for small cases
15:52:18 <Eduard_Munteanu> roboguy_: yeah, that seems reasonable
15:52:47 <roboguy_> The other motivation is finding a good way to represent the sorts of object hierarchies that seem to arise frequently in GUI systems. Maybe this is working against the language, but I want to try and make sure there isn't a nice way
15:52:51 <Eduard_Munteanu> roboguy_: well, they're not isomorphic though
15:53:10 <roboguy_> Eduard_Munteanu: actually, good point
15:53:22 <Eduard_Munteanu> The safe operation for subtypes is upcasting, downcasting isn't safe.
15:53:27 <jrmithdobbs> roboguy_: i'm fighting back and forth with something similar re: related types in json http apis written in oo environments
15:53:42 <jrmithdobbs> roboguy_: i went down the gadt route and *was not* happpy with the resulting usability
15:54:04 <Eduard_Munteanu> roboguy_: you might also want to have a look at O'Haskell for ideas.
15:54:11 <roboguy_> A good analysis of subtyping and whether or not it's even feasible in Haskell would be nice
15:54:12 <Eduard_Munteanu> @google o'haskell
15:54:14 <lambdabot> http://www.haskell.org/haskellwiki/O'Haskell
15:54:14 <lambdabot> Title: O'Haskell - HaskellWiki
15:54:35 <jrmithdobbs> roboguy_: what's closest to what i'm going to end up with splitting out the relationship (think of it as a id<->id map table in an rdbms) and then using tuples or newtypes on tuples to combine the relationships
15:54:39 <jrmithdobbs> roboguy_: if that makes sense
15:55:43 <OscarZ> I have naive understanding of type systems and its not immediately obvious what kind of advantages a powerful type system like Haskell would give you? As I understand a type system is just a safe guard to prevent me from using wrong kind of arguments to functions and those can be caught compile time
15:56:05 <jrmithdobbs> roboguy_: luckily in my case all this can happen in the transform egress/ingress point in the code and not actually dirty up my use of the "real" datatypes in the code
15:56:46 <FreeFull> OscarZ: I'm guessing you haven't seen type classes yet
15:56:46 <Eduard_Munteanu> OscarZ: that's the basic idea, yes, but types are also useful for abstraction, especially when rich.
15:56:55 <OscarZ> Is powerful type system just an extremely flexible language that gives you that kind of type-safety or is there more to it?
15:57:35 <FreeFull> A powerful type system will allow things like Quickcheck to work
15:57:56 <OscarZ> oh.. I've just listened to some podcast about Quickcheck
15:58:51 <FreeFull> Haskell allows things like parametric polymorphism on return values, and type constructors (such as Maybe and Either)
16:00:04 <jmcarthur_mobile> OscarZ: almost all bugs are due to the wrong argument being passed to a function. A powerful type system let's you make more flexible contracts for arguments without sacrificing safety
16:00:16 <jmcarthur_mobile> *lets
16:00:44 <jmcarthur_mobile> Also, yes, type classes. They don't make much sense without types
16:01:05 <jrmithdobbs> i like to analgoize haskell's type system to python and ruby's duck typing, except your ducks can never launch the missles
16:01:25 <Rarrikins> What if I want to make a game in which ducks launch missiles?
16:01:37 <FreeFull> You explicitly let them
16:01:41 <jrmithdobbs> then you have a MissleLauncherDuck
16:02:51 <jrmithdobbs> :t flip view
16:02:52 <lambdabot> b -> Getting a b a -> a
16:02:57 <jrmithdobbs> :t (^.)
16:02:58 <lambdabot> s -> Getting a s a -> a
16:03:07 <OscarZ> FreeFull: whats parametric polymorphism on return values ?
16:03:09 <jrmithdobbs> where is that but now infix?
16:03:13 <jrmithdobbs> s/now/not/
16:03:52 <jrmithdobbs> because (var ^.) is ugly vs (view var)
16:04:05 <FreeFull> OscarZ: You can have a function such as   Monoid a => Int -> a
16:05:08 <FreeFull> > let foo :: Monoid a => Int -> a; foo x = mconcat . replicate x mempty
16:05:09 <lambdabot>   not an expression: `let foo :: Monoid a => Int -> a; foo x = mconcat . repl...
16:05:11 <FreeFull> > let foo :: Monoid a => Int -> a; foo x = mconcat . replicate x mempty in foo 39
16:05:12 <lambdabot>   Couldn't match expected type `a0 -> [c0]' with actual type `[a1]'
16:05:23 <FreeFull> > let foo :: Monoid a => Int -> a; foo x = mconcat (replicate x mempty) in foo 39
16:05:24 <lambdabot>   ()
16:05:32 <roboguy_> jmcarthur_mobile, Eduard_Munteanu, shachaf: This needs a lot of work, but here's a rough example of what I have in mind: http://lpaste.net/96610
16:05:41 <FreeFull> That rather useless function is polymorphic in its return type
16:05:56 <roboguy_> jrmithdobbs ^
16:06:09 <jrmithdobbs> :t (^)
16:06:10 <lambdabot> (Integral b, Num a) => a -> b -> a
16:06:24 <jrmithdobbs> oh, ha
16:06:47 <OscarZ> FreeFull: i have been looking at Clojure latest.. is that something like creating an infinite sequence
16:07:07 <FreeFull> OscarZ: No, that'd be generators or laziness
16:07:08 <jrmithdobbs> roboguy_: you're at about the point there where I decided it wasn't worth it to keep pursuing, if it makes you feel better ;p
16:07:32 <Eduard_Munteanu> roboguy_: downcasts aren't sound
16:07:35 <FreeFull> This is the same function being able to produce output of different types
16:07:40 <roboguy_> jrmithdobbs: haha, I'm not sure if that makes me feel better or not
16:07:45 <OscarZ> ok
16:07:54 <roboguy_> Eduard_Munteanu: because you lose information?
16:07:55 <Eduard_Munteanu> roboguy_: also, isn't an upcast from sub to super?
16:08:14 <Eduard_Munteanu> roboguy_: because you need more information
16:08:20 <roboguy_> Eduard_Munteanu: I thought of upCast as going up the hierarchy and downCast as going down
16:08:32 <roboguy_> maybe that's not necessarily the intuitive definitions though
16:08:40 <Eduard_Munteanu> roboguy_: assuming up means base class?
16:08:45 <roboguy_> Eduard_Munteanu: yeah
16:09:01 <roboguy_> Eduard_Munteanu: like up would be more specific to less specific
16:09:09 <roboguy_> With what I have here anyway
16:09:31 <Eduard_Munteanu> Aren't base classes supertypes wrt the derived classes?
16:09:53 <Eduard_Munteanu> Yeah.
16:09:54 <roboguy_> Eduard_Munteanu: yeah. so maybe it would make sense to flip those names
16:10:28 <OscarZ> FreeFull: how is that more flexible than some java method with signature Monoid foo(int i); ?
16:10:40 <roboguy_> Eduard_Munteanu: don't we need a way to go from a supertype to a subtype in order to make new types?
16:10:47 <OscarZ> where Monoid is some interface
16:11:33 <Eduard_Munteanu> roboguy_: not a coercion
16:12:07 <roboguy_> Eduard_Munteanu: what would it be then?
16:12:28 <Eduard_Munteanu> roboguy_: for example (A, B, C) <: (A, B), but you can't take any (A, B) and pretend you have an (A, B, C).
16:12:51 <roboguy_> Eduard_Munteanu: true
16:13:15 <roboguy_> Eduard_Munteanu: what's a good way to make a "new type" constructor then?
16:13:38 <schell> are there companies that use an internal hackage server?
16:13:39 <FreeFull> OscarZ: I don't know Java
16:13:52 <roboguy_> right now I'm basically using what I'm calling "upCast" in the paste to make new "subtypes"
16:14:40 <FreeFull> OscarZ: What if you wanted the result to be both an Integral and Num?
16:15:28 <roboguy_> on an unrelated note, lenses seem like a good choice for representing "objects" in a GUI library so far (in this admittedly very small example at least)
16:16:03 <Eduard_Munteanu> roboguy_: you could rephrase it as: (t <: A) => t -> MembersOfA   I think
16:17:25 <roboguy_> Eduard_Munteanu: What's MembersOfA? Also, I hate to start talking about this and leave but I really have to go right now. I'll be back in a couple hours if you're still interested in talking about it then
16:17:53 <Eduard_Munteanu> roboguy_: er, tommorrow then, it's 2 AM here. :)
16:18:06 <roboguy_> Eduard_Munteanu: Ahh, well good night
16:19:13 <Bor0> can we have a category A and category B so that arrows in category B somehow combines the objects in category A? I want to understand if fold can be seen like this from category theory view
16:20:02 <Eduard_Munteanu> If B is a subcategory of A perhaps.
16:20:29 <Eduard_Munteanu> Not sure that's anywhere close to folds though.
16:20:52 <Bor0> how would one define fold in terms of category theory?
16:21:10 <shachaf> What does "combines the objects" mean?
16:21:19 <ReinH> another way to put it is: if all Foldables are Functors in Haskell, is there a similar relationship between catamorphisms and functors?
16:21:30 <shachaf> Why are you thinking about categories?
16:21:41 <OscarZ> FreeFull: i think thats possible with Java generics to some extent.. something like <? extends Integral & Num).. but I see what you mean, probably much nicer to express that kind of thing in Haskell
16:21:41 <shachaf> ReinH: No, Foldable has nothing to do with any of it.
16:22:12 <ReinH> shachaf: I was explaining how fmap is a functor, and mentioned that folds are catamorphisms
16:22:58 <Eduard_Munteanu> "fmap is a functor" isn't really well phrased. :/
16:23:12 <ReinH> Eduard_Munteanu: that's fair
16:23:17 <FreeFull> OscarZ: What about something like    Functor f => (a -> b) -> f a -> f b   where f is something like Maybe
16:23:20 <ReinH> fmap maps arrows to arrows in Hask
16:23:49 <ReinH> and its laws are the functor laws
16:23:57 <Eduard_Munteanu> fmap is the arrow-mapping part of the functor. The object-mapping part is the type constructor.
16:24:00 <ReinH> so what is a well phrasing of the relationship between fmap and functor?
16:24:04 <ReinH> Eduard_Munteanu: ok makes sense :)
16:24:18 <OscarZ> FreeFull: my javac crashed :(
16:24:27 <StoneCypher> is learn you a haskell still the place for an outsider to get started?
16:24:37 <shachaf> It is a place.
16:24:53 <Eduard_Munteanu> StoneCypher: people still point newcomers at it, yes.
16:24:58 <StoneCypher> thanks
16:25:01 <ReinH> basically, I think Bor0 thought that "functors is a homomorphism" and "catamorphism is a homomorphism" implied that functors and catamorphisms were similar in a way that they are not
16:25:10 <ReinH> er "a functor is a homomorphism"
16:25:27 <shachaf> I'm not sure what "folds are catamorphisms" means but it sounds like someone trying to make things seem complicated.
16:27:03 <Redz> whats the easiest way to link the input/output of two handles to each other?
16:27:05 <ReinH> shachaf: I think it's correct to say that the concept of catamorphisms is a generalization of the concept of folds?
16:27:34 <shachaf> What are both of these concepts?
16:28:11 <Eduard_Munteanu> Redz: forkIO (hGetContents i >>= putStr o)   ?
16:28:27 <ReinH> well, folds are defined through structural induction and recursion, right?
16:28:48 <OscarZ> Haskell must be able to compile these type
16:29:10 <ReinH> and a catamorphism is a homomorphism from an initial algebra to some other algebra
16:29:26 <ReinH> so both my naive understanding and, e.g.,  wikipedia seem to agree that these are related concepts
16:30:48 <shachaf> I'm not sure what you mean by "fold" here.
16:30:52 <ReinH> The Haskell wiki page on catamorphisms (http://www.haskell.org/haskellwiki/Catamorphisms) says that "Catamorphisms are generalizations of the concept of a fold in functional programming."
16:31:02 <shachaf> Does it mean something other than "catamorphism"?
16:31:44 <ReinH> You're not an obtuse person so I'm assuming that I am failing to express myself correctly, but I'm not sure how I am failing. :/
16:31:53 <OscarZ> what kind of system or "logic" is used to express Haskell types?
16:32:39 <Eduard_Munteanu> OscarZ: logic? It probably fits intuitionistic logic best.
16:32:57 <Eduard_Munteanu> (well, I'm not clear on your "express")
16:33:46 <ReinH> OscarZ: the system is based on http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
16:34:31 <ReinH> shachaf: in this sense, I believe, a fold is a catamorphism but not all catamorphisms are folds. I'm not sure how to clarify the second half further.
16:34:33 <geekosaur> ghc actually uses System Fc
16:34:42 <OscarZ> Eduard_Munteanu: I dont know much about this stuff.. Haskell obviously has a powerful type system, I was wondering if its based on some kind of formalism etc..
16:34:45 <shachaf> What's a catamorphism that isn't a fold?
16:34:52 <ReinH> shachaf: that's what I don't know :)
16:34:57 <jrmithdobbs> ReinH: so if a catamorphism being a transformation from one algebra to another then it is by definition a generalized fold isn't it? I'm not understanding the question? if a fold is a -> b; and a catamorphism is m a -> n b; then all folds are catamorphisms but not all catamorphisms are folds
16:35:14 <shachaf> "m a -> n b"?
16:35:15 <ReinH> jrmithdobbs: isn't that what I just said?
16:35:26 <shachaf> "a -> b", for that matter?
16:35:26 <OscarZ> ReinH: thanks.. i think I've been pointed there before :) probably way over my head
16:35:31 <jrmithdobbs> ReinH: yes but i typed it slower
16:35:32 <Eduard_Munteanu> Folds are structural, I think.
16:35:35 <jrmithdobbs> ReinH: !
16:36:12 <ReinH> well, folds in Haskell are ofc constrained to operate on types in Hask
16:37:15 <Eduard_Munteanu> Structural means it's also constrained to inductive types.
16:37:20 <ReinH> Right.
16:37:32 <ReinH> It's also constrained to endomorphisms?
16:37:40 <ReinH> Since we have to stay in Hask
16:37:44 <OscarZ> can you guys recommend some introductory stuff on type systems in general? any good books?
16:37:51 <jrmithdobbs> ReinH: erm, I mispoke and confused myself, if a fold is a -> b, and a catamorphism is (effectively) m a -> n b, doesn't that simplify to a -> b in the unconstrained case making them equivilent and all catamorphisms are in fact at worst constrained folds?
16:37:59 <Eduard_Munteanu> OscarZ: TAPL is rather nice
16:38:14 <ReinH> jrmithdobbs: what are a -> b here and what are m and n?
16:38:26 <Eduard_Munteanu> ReinH: I don't think they're functors
16:38:38 <ReinH> Eduard_Munteanu: did something I say imply that they are functors?
16:38:41 <jrmithdobbs> ReinH: m and n are the containing algebras, a -> b are anything seing as that's pretty much the definition of a fold
16:38:51 <Eduard_Munteanu> ReinH: "stay in Hask" :)
16:38:53 <ReinH> Eduard_Munteanu: they are not structure preserving, so they can't be functors, right?
16:39:09 <jrmithdobbs> ReinH: any type in the category hask * (if i'm using that right)
16:39:10 <Eduard_Munteanu> I think we're mixing different levels here.
16:39:31 <ReinH> Eduard_Munteanu: this is category theory so I am pretty sure I am mixing an infinite number of levels and poorly understanding all of them :/
16:39:37 <ReinH> I should probably just finish my book and come back
16:39:53 <shachaf> How about only using the word "fold"? It's shorter than "catamorphism".
16:40:01 <Eduard_Munteanu> ReinH: in the category of monoids, arrows are homomorphisms. But functors are another story.
16:40:18 <jrmithdobbs> shachaf: cause he's trying to understand the distinction between the two?
16:40:21 <jrmithdobbs> (if there is one)
16:40:27 <ReinH> Eduard_Munteanu: well functors are cateogry homomorphisms and... now I've gone all crosseyed.
16:41:01 <geekosaur> catamorphism is the mathematical construct, fold is its realization in haskell?
16:41:02 <ReinH> Eduard_Munteanu: but not all category morphisms are functors, right?
16:41:22 <ReinH> I'm just going to go read more Lawvere
16:41:27 <Eduard_Munteanu> ReinH: all arrows in Cat are functors.
16:41:28 <shachaf> What does "category morphism" mean?
16:41:32 <Eduard_Munteanu> ^^
16:42:01 <ReinH> shachaf: an arrow A -> B for some categories A and B?
16:42:09 <Eduard_Munteanu> I guess we're assuming some moral idea of structure preservation.
16:42:17 <shachaf> What's "an arrow", then?
16:42:26 <Eduard_Munteanu> Eh, that's true by definition then.
16:42:32 <jrmithdobbs> i think i've decided that haskell is really just an enticing trick to get real world engineers to learn category theory
16:42:35 <jrmithdobbs> heh
16:42:39 <ReinH> shachaf: that thing between A and B? ...
16:43:05 <joelteon> has this happened to anyone with xcode 5? https://gist.github.com/anonymous/56c8de666903fbb2a0ff
16:43:06 <schell> do any of you guys use your own internal hackage?
16:43:13 <ReinH> a morphism is a structure preserving mapping, so a category morphism preserves the category laws, right?
16:43:41 <schell> joelteon: yes - there's some notes on that here -> http://www.haskell.org/platform/mac.html
16:43:47 <Eduard_Munteanu> ReinH: yeah, but that's just a general idea.
16:44:10 <shachaf> Here's a category for you: The objects are (small) categories, and there are only identity arrows, nothing else.
16:44:25 <ReinH> Eduard_Munteanu: but there are category morphisms that do not map id, etc, and do not follow the functor laws
16:44:34 <ReinH> shachaf: in that category, all morphisms are functors, right?
16:44:37 <shachaf> What does "morphism" mean?
16:44:43 <joelteon> schell, you mean ghc-clang-wrapper?
16:44:53 <AshyIsMe> joelteon: the notes on that page fixed the same issue for me the other day.  I used the script option rather than installing gcc
16:44:54 <shachaf> In that category, all the morphisms are pebbles.
16:45:05 <joelteon> I'm already using ghc-clang-wrapper
16:45:23 <ReinH> shachaf: a map between two objects, in this case between an object and itself (so an automorphism)?
16:45:30 <AshyIsMe> oh, could be something different then
16:45:36 <shachaf> That's not what "automorphism" means either.
16:45:39 <ReinH> ok
16:45:42 <Eduard_Munteanu> ReinH: we don't really talk about morphisms where "homo-" doesn't apply.
16:45:51 <schell> is there a channel for hackage-related talk?
16:45:56 <shachaf> #hackage
16:46:02 <schell> shachaf: thanks ;)
16:46:09 <shachaf> People seem to get this idea that you do this backwards, that you "define" functor by saying "it's an arrow in the category of categories".
16:46:13 <monochrom> wait, can't I simply use "morphism = arrow"?
16:46:15 <ReinH> shachaf: in what way is a mapping from an object to itself not an automorphism
16:46:16 <ReinH> ?
16:46:38 <shachaf> "automorphism" means "an isomorphism between an object and itself", i.e. an invertible morphism. But never mind that.
16:46:41 <Eduard_Munteanu> ReinH: automorphisms are endo + iso
16:46:42 <ReinH> shachaf: it is an isomorphism that maps an object to itself?
16:46:44 <joelteon> It says "<built-in>:2:2: Not in scope: `#'" what is <built-in>?
16:46:53 <joelteon> what's it referring to?
16:47:00 <ReinH> shachaf: so please, how is that morphism not an automorphism?
16:47:00 <shachaf> Anyway, let's forget about categories for a moment and talk about sets.
16:47:16 <shachaf> Which morphism? What?
16:47:19 <ReinH> ...
16:47:21 <monochrom> joelteon, see the topic at the end for XCode 5
16:47:24 <Eduard_Munteanu> ReinH: you mentioned two objects
16:47:39 <ReinH> ok
16:47:41 <geekosaur> monochrom, this is *with* that script
16:47:42 <Fusebox|2> Hey there. I'm trying to get gloss working so I can do some simple game implementation to practice monads. What's the best way to install and test it?
16:47:47 <monochrom> oops, sorry
16:47:55 <ReinH> shachaf : Here's a category for you: The objects are (small) categories, and there are only identity arrows, nothing else.
16:47:58 <joelteon> monochrom: are you referring to ghc-clang-wrapper?
16:48:01 <geekosaur> (and sorry, I have no idea.)
16:48:04 <ReinH> In that category, how are all morphisms not automorphisms?
16:48:07 <ReinH> they are endo and iso, are they not?
16:48:19 <ReinH> they map an object to itself, they are invertible.
16:48:34 <shachaf> Yes, they are. "a map between two objects, in this case between an object and itself (so an automorphism)?" isn't generally true, though.
16:48:44 <shachaf> And also irrelevant, which is why I said never mind.
16:49:00 <ReinH> ok, so "a.k.a. an automorphism" is incorrect because I was sloppy.
16:49:03 <ReinH> I accept that
16:49:51 <shachaf> Let's try to use the simplest words we can.
16:50:07 <shachaf> Long words bad, short words good.
16:50:13 <ReinH> what automorphism means is an invertible mapping from an object to itself, a.k.a. an isomorphism from an object to itself
16:50:22 <ReinH> I get that.
16:51:09 <shachaf> OK, but it's not relevant.
16:51:13 <Eduard_Munteanu> Mind there are automorphisms which aren't identities.
16:51:45 <Eduard_Munteanu> (e.g. permutations)
16:51:58 <khyperia> General objective advice question: I feel like I'm getting pretty good at Haskell, I got a patch into GHC, etc., but it still doesn't feel "natural" to me. Are there any specific advanced tutorials/projects I could do, or does the feeling of "natural-ness" just come with time and a lot of code written?
16:52:27 <ReinH> Eduard_Munteanu: right
16:53:10 <shachaf> You asked whether there are category morphisms that aren't functors.
16:53:24 <shachaf> The answer is that "category morphism" is meaningless phrase, on its own.
16:53:54 <jrmithdobbs> Eduard_Munteanu: wait, how can you have an automorphism that isn't an identity? you just hurt my head
16:54:00 <ReinH> shachaf: is "mapping between categorties" a meaningful phrase?
16:54:12 <shachaf> Arrows don't exist on their own. "so-and-so is an arrow between A and B" is something that makes sense to say *when you're talking about some particular category*.
16:54:29 <shachaf> Then you have arrows *in that category*, and they have domains and codomains and all that.
16:54:43 <shachaf> No, "mapping" isn't a meaningful phrase unless you say what it means.
16:56:06 <ReinH> so if I have a category A and a category B, A -> B is only meaningful within some context that defines A and B?
16:56:14 <ReinH> or that includes A and B
16:56:20 <Eduard_Munteanu> jrmithdobbs: take pairs of type (a, a). Swapping the elements is an automorphism that's not an identity.
16:56:25 <zbcm> I can't even begin to understand how to program in a functional language like Haskell, does anyone know of any open source software written in Haskell that I could take a look at? As simple as possible..
16:56:46 <Cylta> zbcm: +1 about question. I'm interested too
16:57:03 <Lajjla> Does anyone know how to get the desktop of a specific XID with haskell xlib?
16:57:26 <jrmithdobbs> Eduard_Munteanu: oh that is indeed important
16:57:43 <watermind> khyperia: it'd take me quite some time to know enough about ghc to get some patch there... I'd expect anyone contributing to have gotten to the point where it feels natural
16:57:49 <OscarZ> zbcm: I like this one: http://learnyouahaskell.com/
16:57:51 <watermind> khyperia: what about it doesn't feel natural to you?
16:58:19 <ReinH> Eduard_Munteanu: right, an automorphism in the category of sets can permute the set (shift the elements of its set around in a specified way).
16:58:38 <watermind> khyperia: because I suppose different people may feel that way for different motives
16:58:42 <khyperia> Reading it, writing it, it just feels "restrictive" in the sense that my old language, C#, got to the point of very easy to conceptualize what and how I would make code before I wrote it
16:59:01 <khyperia> I think that's the key - I don't know what I'm going to do before I do it.
16:59:06 <zbcm> OscarZ, no, not a tutorial. I can get the syntax just fine, it's the functional design that confuses me. I was asking for some open source code to poke around in.
16:59:15 --- mode: ChanServ set +o shachaf
16:59:23 <ReinH> Eduard_Munteanu: i.e. Data S = A | B | C can have a function f :: S -> S that maps A to B and B to C and C to A
16:59:55 <ReinH> Eduard_Munteanu: and since this is both endo (S -> S) and an isomorphism, it is an automorphism. Right?
16:59:55 <OscarZ> ReinH, Eduard_Munteanu: interesting stuff.. I've always wondered about category theory .. what the hell it is about :D
16:59:56 <watermind> kylcarte: well it is restrictive, since you are missing effects
17:00:04 <ReinH> OscarZ: I clearly have no idea :D
17:00:04 --- mode: shachaf set +b *!*@unaffiliated/nevzets
17:00:09 --- kick: Lajjla was kicked by shachaf (ban evasion)
17:00:12 --- mode: shachaf set -o shachaf
17:00:52 <ReinH> er data S, but you get the idea
17:00:55 <monochrom> zbcm: consider my http://lpaste.net/52480
17:00:58 <Eduard_Munteanu> ReinH: yeah
17:01:22 * hackagebot wai-logger 2.0.1 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-2.0.1 (KazuYamamoto)
17:01:24 <zbcm> Ah great, thanks.
17:01:24 <watermind> kylcarte: there are a few things that, in my experience, people tend to find it difficult getting used to
17:01:31 <ReinH> Eduard_Munteanu: which is why automorphisms in the category of sets are sometimes called permutations? Yay I remembered something! :D
17:01:35 <shachaf> ReinH: Let's forget about categories and talk about monoids, so we don't have two different levels of categories confusing us.
17:01:47 <ReinH> shachaf: yes please, and if you'd like we can go to overflow
17:01:54 <watermind> kylcarte: a big one (not sure if it is your case) is lazyness... not understanding how it works, but understanding how to use it
17:02:01 <jrmithdobbs> no please don't
17:02:08 <ReinH> ok :) up to shachaf
17:02:14 <ReinH> shachaf: let's talk about monoids.
17:02:15 <jrmithdobbs> ReinH,shachaf: ^
17:02:48 <watermind> kylcarte: that is intimately related with purity (which is the restriction) because often the way to get around lack of effects is to take advantage of lazyness
17:03:41 <watermind> kylcarte: so one thing I personally would recommend is to try to explore using lazyness as a way to achieve modularity
17:04:13 <ReinH> jrmithdobbs: you can join us in #haskell-overflow :)
17:04:19 <watermind> kylcarte:  a nice exercise for instance, would be something like programming a Dijkstra shortest path algorithm
17:04:55 <watermind> kylcarte: without directly implementing the usual imperative specification
17:05:30 <watermind> kylcarte: or any shortest path algorithm for that matter
17:06:40 <Shin-LaC> now you have to decide how to represent a graph in haskell
17:07:17 <watermind> Shin-LaC: meh... even in an imperative language, for this kind of problem, you don't usually represent it as a dynamic data structure
17:07:41 <watermind> Shin-LaC: representation here could be pretty much the same as in an imperative language, you just want easy access
17:07:58 <watermind> forward star form should do the trick
17:08:55 <Shin-LaC> using knot tying?
17:09:29 <quup> Hi, is there some haskell notebook software (similar to sage or mathematica)? I'd like one just for easier playing around getting comfortable with haskell
17:09:40 <Hodapp> that is a good question...
17:09:58 <watermind> Shin-LaC: no, why complicate? just a simple array of pairs
17:10:04 <Hodapp> I use Emacs in haskell-mode, but it's a bit limited in that regard. I can type and execute in an editor buffer, but it's not really a notebook
17:10:55 <watermind> Shin-LaC: sorry you don't even need an array of pairs, if you take the indexes to be the nodes
17:11:26 <watermind> Shin-LaC: so just a node-indexed-array whose elements are the respective node neighbours
17:12:01 <khyperia> Can I get a list of "contextless" (that don't require a "project file" to be next to the source file) haskell editors? All I know of are emacs and vim.
17:13:01 <quchen> quup: There's ghci.
17:13:13 <quchen> khyperia: I use Sublime.
17:13:26 <Shin-LaC> watermind: he'll want edge weights too for dijkstra's algorithm, but yeah
17:13:39 <khyperia> Haven't tried that.
17:13:41 <watermind> Shin-LaC: true yes of course
17:13:53 <quup> quchen: yea, that's what I'm playing in now, but I really like the notebook model for playing around with code :)
17:15:18 <watermind> Shin-LaC: what I like about this exercise is that rather than go straight for a dijkstra you can start with naive algorithms and successively improve on them
17:15:22 <quchen> quup: I don't think the notebook model fits Haskell very well, it's about modifying values of previous values. When all values are immutable, that isn't very useful.
17:15:42 <quchen> quup: What you can do of course is edit a source file, reload it in GHCi with :r, and then play around with the contents.
17:15:43 <watermind> Shin-LaC: e.g. a first step could be simply constructing the list with all paths from the root
17:15:54 <quchen> The key here is that you always start from scratch again.
17:16:06 <watermind> Shin-LaC: then change it so to avoid loops
17:16:43 <quup> quchen: I'll try that for a bit, thanks
17:17:04 <watermind> Shin-LaC: then play with the sequence in which you grow your tree of paths
17:17:06 <watermind> etc etc
17:17:19 <quchen> quup: I don't think there is a way to auto-reload your file in GHCi when you change it though.
17:17:51 <quchen> quup: You can of course write a script a la "when X changes recompile it" and have it open in a separate window.
17:18:32 <watermind> in the end the implementation is quite a bit different from a direct translation of the usual impertive description of Dijkstra
17:23:33 <Shin-LaC> I am trying to parse a log file using parsec
17:23:38 <Shin-LaC> I want to parse floating point numbers
17:24:13 <Sgeo> In the Stmt type
17:24:18 <Sgeo> (Template Haskell)
17:24:21 <Sgeo> What is ParS?
17:24:22 <Shin-LaC> is there any premade parser for that?
17:24:33 <Sgeo> BindS, LetS, and NoBindS seem kind of obvious
17:24:50 <Eduard_Munteanu> Shin-LaC: there's 'float' in Text.Parsec.Token
17:25:26 <shachaf> Sgeo: Google suggests that it's for parallel comprehensions.
17:25:32 <Shin-LaC> ah, that's great
17:25:34 <Shin-LaC> thanks
17:28:28 <Shin-LaC> but why can't I do float <*> float ?
17:29:01 <Eduard_Munteanu> Shin-LaC: how does <*> make sense there?
17:29:05 <Iceland_jack> @ty (<*>)
17:29:05 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:29:11 <Iceland_jack> Shin-LaC: ↑
17:29:27 <Iceland_jack> @ty \float -> float <*> float
17:29:28 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> b0
17:29:28 <lambdabot>     Expected type: f0 a0
17:29:28 <lambdabot>       Actual type: f0 (a0 -> b0)
17:29:56 <Shin-LaC> you're right, it doesn't
17:31:49 <Shin-LaC> (,) <$> float <*> float
17:31:50 <Shin-LaC> maybe this
17:34:36 <khyperia> thanks for the suggestion, quchen, I kinda like Sublime.
17:35:19 <quchen> khyperia: It gets better when you configure it, unfortunately you can't take the cloused-source-ness away. :-\
17:35:20 <Shin-LaC> I tried reading this: http://book.realworldhaskell.org/read/using-parsec.html but it seems to be based on an old version of Parsec
17:35:44 <quchen> Shin-LaC: RWH is from 2007 I think, so that's possible
17:35:59 <Shin-LaC> and I can't find any simple introduction to parsec 3
17:36:18 <quchen> Parsec hasn't changed dramatically since RWH I think though
17:37:25 <Shin-LaC> well, at the end of that chapter they introduce applicative parsing by defining their own applicative instance for GenParser
17:37:36 <Shin-LaC> while parsec seems to have applicative support built-in now
17:38:29 <quchen> And just leaving away the custom Applicative doesn't help?
17:39:16 <Shin-LaC> well, the main problem I'm having is that "parse" wants a "Parser", which I assume is the new name of GenParser, but "float" is a "ParsecT"
17:40:24 <Shin-LaC> To run your parser, please look to runPT, runP, runParserT, runParser and other such functions.
17:40:25 <Shin-LaC> ok
17:41:22 <Shin-LaC> so now parsec is based on monad transformers instead of monads?
17:42:16 <quchen> Shin-LaC: Yes.
17:42:21 <khyperia> type Parser = ParsecT String () Identity
17:42:21 <Eduard_Munteanu> Shin-LaC: float is a record field
17:42:55 <Eduard_Munteanu> Shin-LaC: you need to generate that token parser first
17:43:19 <Eduard_Munteanu> Shin-LaC: there's one already done in the .Language module, IIRC.
17:43:47 <freimacx> if nothing interesting is going on, I need to drone a bit about IO things. As in I have a small problem I'm kind of lost with.
17:43:53 <zbcm> I'm still finding this incredibly hard to grasp, I wrote an example that is totally wrong(in both design and syntax). How would I do something like this? http://lpaste.net/96612
17:44:29 <Shin-LaC> hm, I see
17:44:51 <freimacx> I want to read a filename from a command-line argument and then read that file. But then getArgs is already :: IO String, and openFile wants a String as its  filepath argument. Now, there's some piping to be done outside do-notation, but I never get down to those things.
17:45:17 <freimacx> is there some standard solution to this?
17:45:30 <zbcm> Or any articles that explain functional vs imperative design.
17:45:45 <quchen> freimacx: How familiar are you with >>= and do notation?
17:45:45 * freimacx used to understand the type of (>>=), in the olden days.
17:46:09 <Eduard_Munteanu> freimacx: there's a standard answer, at least: http://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F   :)
17:46:19 <freimacx> At one point I wrote a tutorial. But that was five summers and five thousand years ago.
17:46:31 <quchen> Must have been ahead of its time then
17:46:36 <phserr> freimacx, or try reading http://learnyouahaskell.com/input-and-output
17:46:51 <quchen> zbcm: What do you want your program to do?
17:47:30 <quchen> zbcm: I see "hangman" written there but I don't see how that relates to the code sketch.
17:48:07 <quchen> zbcm: The general logic would be starting "loop gameState" where gameState stores the word, which guesses you've made, and how hung the hangman is.
17:48:20 <quchen> Then wait for user input, and based on that modify the game state.
17:48:43 <zbcm> Well my question would be how do I store how many guesses have been made?
17:49:13 <zbcm> In an imperative language I would just increment count.
17:49:22 <Rarrikins> zbcm: At the end, you do loop (if elem x word then succ count else count, x')
17:49:32 <Shin-LaC> what is the advantage of using monad transformers in parsec?
17:49:34 <freimacx> zbcm: well, here you want to recurse.
17:49:41 <Rarrikins> zbcm: Or actually, loop (if elem x word then succ count else count) x'
17:49:58 <freimacx> Shin-LaC: do notation turns out to be really intuitive in parsec, for one.
17:50:00 <Eduard_Munteanu> Shin-LaC: your parser can do IO for example
17:50:00 <Rarrikins> zbcm: Then loop is loop count x = ...
17:50:23 <zbcm> OH I see, thanks.
17:50:36 <Shin-LaC> freimacx: that's with monads, it doesn't need monad transformers
17:50:36 <Rarrikins> zbcm: And x <- getLine is x' <- getLine, since x would already exist.
17:51:25 <freimacx> Shin-LaC: well, not necessarily. Right now, I have a problem that may involve binding from two IO monads, and there doesn't seem to be a clear do-notation solution.
17:52:33 <freimacx> "binding from two IO monads": taking a IO String and feeding a function that's :: String -> IO.IOMode -> IO.Handle.Types.Handle
17:52:35 <quup> What am I missing? Shouldn't foldl (!!) [[1],[2],[3]] [0,0] extract 1?  http://fpaste.org/59432/94324138/
17:52:43 <shachaf> There is only one IO monad.
17:52:53 <monochrom> Shin-LaC: see my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#monad
17:53:35 <scott_> quup: The first argument of foldl has type (a -> b -> a)
17:53:39 <scott_> quup: (!!) doesn't fit that type
17:53:42 <scott_> :t (!!)
17:53:43 <lambdabot> [a] -> Int -> a
17:54:03 <quup> scott_: thanks fro :t!
17:54:06 <quchen> zbcm: Here's a minimal example that keeps track of your guesses: http://lpaste.net/96614
17:54:27 <zbcm> That really helps thanks.
17:54:46 <quchen> zbcm: I kept everything in GameLoop instead of breaking it up in smaller pieces, so the code looks pretty ugly.
17:55:00 <quchen> I hope it makes it easier to read slowly without having to jump around though.
17:55:18 <zbcm> I can understand it easily enough, thanks.
17:55:20 <Shin-LaC> monochrom: thanks
17:56:09 <snizzo> how can I tell happy to get the first item on a list of int and the following are leaves? (all separated by blank)
17:56:26 <snizzo> example: "1 2 3 4"
17:56:47 <snizzo> Root 1 [Leave 2, Leave 3, Leave 4]
17:57:39 <snizzo> I tried with this small grammar but fails http://pastebin.kde.org/pxuhpaiqy
18:01:46 <quchen> zbcm: I've annotated it with a refactored version if you prefer that one.
18:01:55 <zbcm> sure thanks
18:01:58 <quchen> And now I'm off to sleep. Good night everyone.
18:02:03 <zbcm> Night
18:05:34 <freimacx> by the way, is there something like :: a->[a]->[[a]] that splits a list into a list of lists at every occurrence of a separator? (my example would be :: Char -> String -> [String])
18:05:49 <shachaf> See Data.List.Split (not in base)
18:06:52 <freimacx> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
18:07:07 <freimacx> there's splitAt, but that takes an integer position and returns a tuple.
18:07:15 <shachaf> Yes. It's not there.
18:07:20 <freimacx> ?splitAt 7 "Oh bitty box!"
18:07:20 <lambdabot> Unknown command, try @list
18:07:20 <shachaf> I suggest Data.List.Split instead.
18:08:05 <freimacx> which in turn cannot be found in the aforelinked ghc library documentation. I'm lost.
18:08:28 <freimacx> oh
18:08:39 <jrmithdobbs> he said it's not part of core, search hackage ;p
18:08:39 <freimacx> when you said "it's not in base" I understood "it's not in Prelude".
18:11:54 <orzo> I want a haskell function like linux's coreutils DIRNAME(1). I've found at least two packages: system-filepath and filepath.  Is there anything in the base libraries?  If not, what package should I use?
18:12:24 <freimacx> wonderful. the recomended cabal upgrade (cabal-install) failed to install.
18:12:30 <Rembane> orzo: Build something with foldr! :D
18:14:14 <freimacx> that said, I distinctly remembered the function name sepBy. Was it removed from Prelude for some reason?
18:14:34 <shachaf> @google sepBy
18:14:34 <lambdabot> http://www.haskell.org/hoogle/?hoogle=sepBy
18:14:34 <lambdabot> Title: sepBy - Hoogle
18:15:11 <Rarrikins> @hoogle sepBy
18:15:12 <lambdabot> Text.ParserCombinators.ReadP sepBy :: ReadP a -> ReadP sep -> ReadP [a]
18:15:12 <lambdabot> Text.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
18:15:12 <lambdabot> Text.ParserCombinators.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
18:15:31 <geekosaur> @index SepBy
18:15:31 <lambdabot> bzzt
18:15:31 <orzo> most convenient would be FilePath -> FilePath
18:15:51 <Rarrikins> It looks like it's just for parser combinators, which wouldn't be in Prelude.
18:15:55 <freimacx> bahh. nothing cabal installs. I was already working on my thing hard-coding the inputs into code, I just wanted marginal more convenience/generality.
18:16:43 <freimacx> it's not hard to think of a flaky implementation using naive recursion, or something like take . length. until  and so forth.
18:16:44 <Cylta> about cabal. how much data will it consume, to install every cabal module?
18:16:45 * geekosaur notices /nick, points to end of /topic
18:17:56 <freimacx> I distinctly remember the name "sepBy". One of the first things I tried, still trying names from memory into ghci.
18:18:12 <Rarrikins> freimacx: What did it do?
18:18:15 <freimacx> (sepBy is the Data.List.Split function that does what I want)
18:18:52 <freimacx> exactly what Data.List.Split.sepBy does. :: a -> [a] -> [[a]], split a list at every occurrence of a separator.
18:18:59 <Rarrikins> Oh, OK
18:19:27 <orzo> can cabal tell me if a package x is already a (possibly indirect) dependency so that i can prefer it over an alternative package y ?
18:27:48 <zbcm> http://lpaste.net/96616 parse error on line 7 am I using Guards wrong?
18:30:13 <monochrom> no, you're using "where loop n" wrong. one correct way is to combine it with line 7. there are other ways.
18:31:43 <zbcm> Ok yeah that fixed it, is there a way that I can format it neater
18:31:44 <zbcm> ?
18:31:53 <monochrom> you also need to align line 13 differently. align "if" under line 12's "guess"
18:32:07 <monochrom> what is neater?
18:32:45 <zbcm> Yeah I caught that myself.
18:32:54 <zbcm> As in not all on the same line.
18:33:55 <monochrom> ok, <4 spaces>where loop n <newline> <6 spaces>| n == 1 = rope <newline> etc
18:34:16 <zbcm> Oh ok thanks.
18:50:48 <joelteon> Is there any package that can resize images and doesn't depend on imagemagick?
18:51:59 <joelteon> oh wait, I don't need to resize, I just need information
19:01:15 <Sgeo> "10+ things that you can do with MFlow and you can't with your Web framework"
19:01:31 <Sgeo> Thanks for assuming that my web framework isn't Seaside or the Racket web server :/
19:02:14 <monochrom> why do you even read it
19:02:32 <Sgeo> Also, continuation-based web frameworks do have problems, but I guess a page about one isn't going to go into details about that
19:02:49 <Sgeo> @hoogle (<**)
19:02:49 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
19:02:58 <Sgeo> ..
19:03:14 <simpson> http://haskell-web.blogspot.com/2013/11/10-things-that-you-can-do-with-mflow.html This, right?
19:03:22 <simpson> I'm skeptical of this all working if JS is disabled.
19:03:47 <leroux> Has anyone had issues installing scotty? I'm getting tons of Not in scope: data constructor `ResponseSource' errors.
19:04:09 <Sgeo> Hmm, maybe I overreacted
19:04:44 <Sgeo> The page seems to imply that it's optional, so it could be restricted to pages that make sense
19:04:57 <Shin-LaC> I am so, so sorry I decided to try using parsec
19:05:49 <Sgeo> simpson: I can vouch for 10 (for certain), and I believe 8 and 9, in some other web frameworks, without Javascript
19:06:06 <Sgeo> But the cost of 10 is ugly urls
19:06:10 <Sgeo> generally
19:06:50 <Sgeo> Oh, and 7
19:07:28 <simpson> I'm going to gently guess that this whole thing has somewhere between little and no content-negotiated rendering.
19:07:30 <Sgeo> simpson: here's a web framework that does something similar: http://www.seaside.st/about/examples/counter
19:07:55 <simpson> Partially because that tends to be a weakness of statically-typed frameworks, and partially because it sounds like they want to focus on flash and pizzazz instead of practical, solid stuff.
19:08:22 <simpson> Sgeo: Gah, those URLs are ugly. :3
19:08:44 <Sgeo> But clicking back works ;)
19:08:53 <simpson> Yes. :3
19:09:13 <Sgeo> And it's more like imperative code than typical web code
19:09:58 <simpson> But yeah. My favorite "Well, okay, let's be oneupsmen here" thing is http://airbr.us/h/lol/stats/health.svg
19:10:03 <simpson> And then http://airbr.us/h/lol/stats/health.json
19:10:37 <path[l]> what are the problems with continuation based web frameworks
19:11:14 <simpson> path[l]: Hold on, I'll tell you in a second. >:3
19:11:18 <Sgeo> path[l]: ugly URLs, need to store state, said state is often opaque, URLs expire
19:11:24 <Sgeo> As far as I'm aware
19:12:35 <Sgeo> Racket web server has a "stateless" one which is still stateful but, by restricting the available language, allows the state to be serialized, where it can be sent to other systems or stored in a cookie
19:12:59 <Sgeo> iirc
19:13:36 <Sgeo> By opaque imagine I said "non-serializable"
19:14:01 <Sgeo> Hmm, I bet if NewLisp had continuations they could be serialized
19:14:12 <path[l]> ah I see
19:15:21 <Sgeo> Hmm, one of the goals of MFlow:
19:15:22 <Sgeo> "For scalability-sensitive applications, to avoid the fat state snapshots that continuation based frameworks need to cope with these two previous requirements. State replication and horizontal scalability must be possible."
19:16:00 <Sgeo> Oh, Smalltalk continuations could probably be serialized. ... Smalltalkers have managed to serialize a RUNNING DEBUGGER
19:17:32 <Sgeo> Well, any Smalltalk application is serializable I guess
19:18:27 <Hodapp> Sgeo: serialize... a running debugger... wha?
19:19:05 <Sgeo> http://marianopeck.wordpress.com/2012/01/19/moving-contexts-and-debuggers-between-images-with-fuel/
19:19:48 <Sgeo> Well, I guess the way I phrased it isn't shocking... I can serialize my IRC client just by hibernating my computer
19:19:53 <Sgeo> Well, serialize that and more
19:21:50 <Hodapp> I find it interesting that Alan Kay seemed to advocate OOP not for a pervasive design of every little part of the whole application, but for larger parts of it.
19:22:13 <Hodapp> and it turned to "OBJECTS ALL THE WAY DOWN!"
19:22:21 <Sgeo> Erlang?
19:22:37 <Hodapp> oh, of course, Fuel came from INRIA
19:22:43 <Hodapp> INRIA always releases crazy stuff
19:22:51 <Hodapp> crazy French
19:23:38 <Hodapp> Maybe something like Erlang. Kay at one point said that he envisioned that, for instance, every single object in the system should have a URL.
19:23:44 <Hodapp> I think.
19:24:14 <Sgeo> Go play with every single Tcl OO system, tell me if you think that's still a good idea
19:25:06 <Sgeo> (Tcl OO systems typically represent objects as strings that are made into commands. So, no automatic garbage collection of objects, but each object has a unique serializable reference)
19:25:51 <Hodapp> Hey, someone just goofed up and accidentally implemented "string typing" instead of "strong typing".
19:25:52 <Hodapp> Honest mistake.
19:27:20 <Sgeo> Hey, Tcl does have an interesting metaprogramming story
19:27:26 <Sgeo> I think Rebol's is better, but still
19:27:31 <Shin-LaC> does parsec not have a parser for non-whitespace characters?
19:27:33 <Shin-LaC> I can't find one
19:27:56 <chemuduguntar> what's the best way to make multiple let bindings
19:28:25 <chemuduguntar> I want to do something like: let a = [1, 2, 3], b = length a ... -- where b is 3
19:29:22 <joelteon> semicolons or newlines
19:30:20 <Sgeo> Ok, so this example MFlow code... it's certainly not ugly URLs... but perhaps a bit excessively transparent
19:30:26 <Sgeo> https://3f5d41f5-8948-4a04-85b4-0466ed5c8b67-app.fpcomplete.com/noscript/()/()/false/()/next/1false
19:30:32 <chemuduguntar> yes! thanks joelteon
19:44:07 <Hodapp> Sgeo: metaprogramming story?
19:45:27 <Sgeo> Hodapp: commands can take strings and eval them in their own context
19:45:43 <Sgeo> Which is how every control structure is written, basically -- no real special forms
19:46:06 <Sgeo> if is a function that takes several strings and chooses which to eval
19:46:27 <Sgeo> The interesting part isn't the strings, it's the eval-based approach
19:46:48 <Sgeo> More like interpretation, where macros are more like compilation
19:52:48 <Shin-LaC> ok
19:53:12 <Shin-LaC> I have a file with separate sections followed by various entries
19:53:29 <Shin-LaC> like: header entry entry header entry header entry entry
19:53:51 <Shin-LaC> I want to parse that with parsec
19:54:15 <Shin-LaC> but I can't use sepBy entry header, because I don't want to throw away the headers
19:54:16 <xpika> is it possible to define a function deepmap which evaluates both deepmap (+1) [1,2,3] => [2,3,4] and deepmap (+1) [[1],[2],[3]] => [[2],[3],[4]]
19:55:01 <jmcarthur> xpika: i don't know, but it's possible to define a tree type that captures the latter thing with just fmap
19:55:11 <jmcarthur> xpika: instead of nested lists
19:55:23 <jmcarthur> xpika: alternatively, you could just compose fmaps
19:55:36 <jmcarthur> > fmap (+1) [1,2,3]
19:55:37 <lambdabot>   [2,3,4]
19:55:46 <jmcarthur> > (fmap.fmap) (+1) [[1],[2],[3]]
19:55:47 <lambdabot>   [[2],[3],[4]]
19:55:58 <Shin-LaC> I think the problem I'm having is that when it gets to the second header it tries to read it as an entry
19:56:04 <geekosaur> sepBy is not the right thing there. probably you want what in BNFish notation would be: document = section | document section; section = header entry+
19:56:22 <geekosaur> where entry+ is many1 entry in Parsec-ese
19:57:06 <Shin-LaC> hm
19:57:07 <geekosaur> and | is <|>
19:57:17 <xpika> something like instance deepMappable [[a]]
19:57:20 <Shin-LaC> so I should put the newline inside the entry parser
19:57:47 <geekosaur> you did not mention the formatting of entries (or for that matter sections)
19:58:34 <Shin-LaC> each section and entry is a line
19:58:51 <jmcarthur> > fmap (+1) (Compose [[1],[2],[3]])
19:58:53 <lambdabot>   Not in scope: data constructor `Compose'
19:58:54 <geekosaur> ok, so yes, I would make the newline part of each of those
19:59:07 <geekosaur> it *could* be factored out but is probably not worth it
19:59:08 <jmcarthur> > fmap (+1) (Data.Functor.Compose.Compose [[1],[2],[3]])
19:59:08 <Shin-LaC> I did that, but it does not seem to make a difference
19:59:09 <lambdabot>   Not in scope: data constructor `Data.Functor.Compose.Compose'
19:59:12 <jmcarthur> darn
19:59:25 <Shin-LaC> it still tries to read the second header as an entry
19:59:26 <Shin-LaC> and fails
19:59:41 <Shin-LaC> at least, I think that's what's happening
19:59:41 <jmcarthur> xpika: in addition to my earlier suggestions, there's Data.Functor.Compose, which would allow what i just tried in lambdabot to work
19:59:50 <geekosaur> the real question is, how do you know a header from an entry? you may need to use try on the entry parser so that it can backtrack if parsing as an entry fails partway through
20:00:08 <Shin-LaC> I think I need to use try
20:00:15 <Shin-LaC> can I combine try with many1?
20:00:51 <geekosaur> yes, it will backtrack and return failure so you can retry it as a section
20:00:55 <geekosaur> er, as a header
20:01:09 <Shin-LaC> is there any way I can have it try the header first?
20:01:19 <geekosaur> alternatively you could have it try section <|> entry, but then keeping entries with their headers is harder
20:01:25 <Shin-LaC> yeah
20:01:27 <geekosaur> er, try header <|> entry
20:01:40 <geekosaur> so yes, you can do that, you just make more work for yourself keeping the entries with their headers
20:01:58 <Sgeo> When will Blaze go away and be replaced by a REAL monad (possibly Writer)?
20:02:04 <geekosaur> which is why I described it the other way
20:02:23 <Shin-LaC> yes
20:02:32 <Shin-LaC> hrm
20:02:46 <Shin-LaC> maybe I can have the entry parser try the header parser first, and if it succeeds, fail?
20:03:31 <geekosaur> there is notFollowedBy, but then you're parsing the same thing more times, I think
20:03:49 <geekosaur> I mean, if you must then you must, but I would call that a badly misdesigned protocol
20:04:34 <Shin-LaC> I don't know, it seems pretty straightforward to me
20:04:47 <geekosaur> also, are you guilty of premature optimization?
20:05:09 <Shin-LaC> perhaps
20:05:16 <geekosaur> no, I would say any parser which needs to start by failing some other parse as you just described is not so much straightforward as backwards
20:05:39 <zbcm> How would I go about converting a one character string to a char?
20:05:40 <joelteon> how do I get an FD from a Handle?
20:05:44 <geekosaur> if it is that necessary then your protocol is DEFINITELY misdefined
20:05:51 <zbcm> wait.. nevermind, dumb question.
20:05:54 <geekosaur> @hoogle handleToFd
20:05:54 <lambdabot> System.Posix.IO.ByteString handleToFd :: Handle -> IO Fd
20:05:54 <lambdabot> System.Posix.IO handleToFd :: Handle -> IO Fd
20:05:55 <Shin-LaC> I didn't define it
20:06:02 <mzero> zbcm: (:[]) is a fun way!
20:06:06 <geekosaur> that doesn't mean it's not misdesigned
20:06:09 <mzero> > (:[]) 'a'
20:06:10 <lambdabot>   "a"
20:06:17 <zbcm> :)
20:06:18 <mzero> it's the monkey operator!
20:06:24 <Shin-LaC> consider the .ini file format
20:06:28 <Shin-LaC> it works pretty much the same way
20:06:31 <mzero> but return can also work in the right context
20:06:37 <mzero> > (return 'a') :: String
20:06:38 <lambdabot>   "a"
20:06:40 <geekosaur> there is a lot of crap "designed" by php or ruby or javascript or etc. that should be shot, burned, and ejected into the sun
20:06:41 <Shin-LaC> and it's considered pretty straightforward
20:06:56 <mzero> lastly, you could just bracket it:
20:06:59 <mzero> > [ 'a' ]
20:07:01 <lambdabot>   "a"
20:07:15 <zbcm> i just used head
20:07:59 <mzero> joelteon: handleToFd
20:08:06 <mzero> assuming you want an Fd
20:08:09 <mzero> not a FD
20:08:28 <geekosaur> I think FD is the same thing just in Gtk-ese? unless they changed it when I wasn't looking
20:08:31 <Shin-LaC> argh, notFollowedBy sounds like what I need here, but it would look really confusing in the code
20:08:47 <geekosaur> Shin-LaC, yes, it would look very confusing. but in this case you can phrase it without that
20:08:57 <joelteon> mzero: fast-logger takes an FD
20:08:58 <geekosaur> entry = not-[ followed by whatever
20:09:02 <joelteon> I'm guessing they're not exactly the same
20:09:05 * mzero is typing slower than other people's responses are coming out!
20:09:19 <geekosaur> which is more easily said than a notFollowedBy parser
20:09:31 <Shin-LaC> wait, I don't understand, what's not-[
20:09:34 <geekosaur> and allows you to fail on the first character so you also don't need try-backtracking
20:09:59 <geekosaur> noneOf "[", IIRC
20:10:07 <Shin-LaC> aah
20:10:11 <chrisblake> guys, can you match multiple patterns in a case statement? like:
20:10:11 <chrisblake> case foo of
20:10:11 <chrisblake>   Just (SomeMonad a) -> dosomethingwith a
20:10:15 <Shin-LaC> yeah, in the .ini case
20:10:24 <geekosaur> notFollowedBy expects a full parser, and is overkill if you have only a single character to deal with as in ini files
20:10:28 <Shin-LaC> unfortunately I can't decide on the first character here
20:11:11 <roboguy_> chemuduguntar: yeah, if SomeMonad is a data constructor
20:11:35 <chrisblake> roboguy_: *chrisblake, and thanks :)
20:11:48 <roboguy_> oh oops
20:12:19 <geekosaur> the point that I have been walking around without saying outright: parsing the way you want to is fairly easy in languages which have mutable variables, because they can easily hold onto the header while parsing entries. to do that easily in Haskell you want to parse it the way I said initially
20:12:44 <Shin-LaC> geekosaur: yes, I see your point
20:13:13 <Shin-LaC> I could use Parsec's internal state thing though, right?
20:13:24 <geekosaur> you could, but it's a pain
20:15:01 <geekosaur> if you are realy set on writing it that way, go ahead. it will be a pain in the butt and not very clean, because you're writing a mutable-state procecural-like thing in haskell, and for maintainability I would really want to do it the more haskelly way and only restructure if it turned out I really needed to do it the ugly way
20:15:23 <Shin-LaC> I don't want to do it that way
20:15:29 <Shin-LaC> but I have a different format where I might
20:16:04 <Shin-LaC> well, actually
20:16:22 <Shin-LaC> what if each entry contains a reference to its section, though?
20:16:50 <Shin-LaC> I guess I still need mutable state
20:17:08 <Shin-LaC> or, hm
20:17:13 <Shin-LaC> I could parse it as a list of entries
20:17:19 <Shin-LaC> and then group them by section identifier
20:17:33 <Shin-LaC> is there a clean way to do that?
20:18:16 <Shin-LaC> there is "group" but it has to do with text, apparently
20:19:22 <Shin-LaC> this is no longer about parsing, of course
20:20:09 <Shin-LaC> er
20:20:19 <Shin-LaC> I could use groupBy, but it requires contiguous sections
20:21:04 <Shin-LaC> but I could sort it first
20:21:45 <Shin-LaC> not really the way you'd do it in an imperative language, but maybe that's the best way in haskell
20:22:07 <Sgeo> In pipes, does (flip for) basically turn (function that takes argument and returns a producer) into a pipe?
20:22:23 <Sgeo> Wait, no
20:23:07 <augur> where can i find something about the problems with subtyping for type checking
20:26:06 <chrisdone> augur: i like this article http://brianmckenna.org/blog/row_polymorphism_isnt_subtyping the casting in subtyping seems pretty undesirable
20:27:10 <augur> chrisdone: anything about the lack of a unique most general type, tho?
20:27:29 <augur> or whatever the problem is with type checking subtypes
20:32:11 <chrisdone> augur: i dunno much more than that
21:23:30 <nurupo> my function's value is "test"
21:24:26 <nurupo> and return type is [String]
21:25:06 <nurupo> hm
21:42:17 <nurupo> didn't expect parsing input to be so hard in haskell
21:44:30 <Hafydd> I don't believe that your function's value is "test" and its value is [String]. That's two type mismatches.
21:45:03 <nurupo> yeah, that was the problem
21:45:23 <nurupo> it complained about [String] and [Char] mismatch
21:46:11 <nurupo> i just was playing with something, don't know haskell much, got it working with "test":[]
21:46:29 <Hafydd> FYI, that's the same as ["test"].
21:49:19 <chemuduguntar> is there a equivalent of (cond) ? trueValue : falseValue in haskell
21:49:43 <[swift]> chemuduguntar: if ... then ... else ...
21:49:51 <chemuduguntar> ok
21:50:25 <[swift]> chemuduguntar: to be clear, 'if' in haskell is an expression, so it really is the same as ?: in C
21:51:26 <chemuduguntar> ok
21:54:00 <nurupo> hm, now my program only reads first line, instead of reading till eof
21:54:44 <mzero> paste it somewhere?
21:54:49 <chrisdone> @where lpaste
21:54:50 <lambdabot> http://lpaste.net/new/haskell
21:55:00 <nurupo> will have to tackle that after sleep
21:58:44 <MitoticSpindle> I have a string such as "xxxooxo". And I have an arbitrary index within this list which I want to replace a character at. What's the simplest noob-friendly way to do this? Right now I'm using recursion with guards, but it seems like maybe I'm being clumsy.
21:59:05 <MitoticSpindle> For instance, I am passing the current index as an argument each recursive call (incremented by one each time)
21:59:24 <mzero> :t splitAt
21:59:24 <lambdabot> Int -> [a] -> ([a], [a])
21:59:55 <MitoticSpindle> Big picture: I'm implementing naughts and crosses and the user gives a coordinate as an input and I want to replace the character in the grid with the user's symbol at their coordinate.
21:59:59 <MitoticSpindle> hmm will take a look ta
22:00:34 <mzero> (assuming you want general direction here, not just the code)
22:11:18 <jzelinskie> theory question: what is a combinator?
22:11:37 <tinyghost> oh I've actually been wondering the answer to that as well
22:11:45 <dmwit> ?wiki combinator
22:11:45 <lambdabot> http://www.haskell.org/haskellwiki/combinator
22:12:58 <slack1256> For... reasons, I need to add a Typeable instance to the Regex datatype of Text.Regex.Posix
22:13:30 <slack1256> should I make a newtype of that and then make the instance? or can I make just where I want?
22:13:44 <jzelinskie> thanks dmwit that helps a lot
22:14:26 <mzero> slack1256: I think that Typable in the near future will only be derivable - if I recall correctly - so perhaps a newtype is best
22:15:00 <smith_> Which command line option parser library should I use?
22:15:44 <slack1256> yeah, I meant use deriving Typeable. well newtype then is
22:16:16 <slack1256> smith_: I am using cmdargs right now, I can say is the best (because I haven't used other) but so far I really like it.
22:16:27 <slack1256> *I can't
22:16:32 <smith_> slack1256: Thanks, I'll go with that.
22:17:01 <mzero> What's wrong with System.Console.GetOpt
22:17:07 <mzero> in base - and always there
22:18:35 <slack1256> Exactly what is wrong with GetOpt in C
22:18:41 <slack1256> no wait that isn't an argument
22:19:05 <mzero> especially since it isn't really like C's getopt at all
22:19:36 <slack1256> I really like modes in my cmd-apps (a la darcs) so far cmdargs can do that, can GetOpt?
22:19:41 <slack1256> if so I might check it out
22:19:45 <mzero> I admit that I shy away from cmdargs - too much impurity
22:19:53 <slack1256> because is in base and stuff
22:20:04 <mzero> GetOpt doesn't by itself
22:20:16 <mzero> but it is pretty easy to use it to do that
22:25:20 <Fusebox|2> I'm encountering a stupid error. I have simplified the function and retain the error. Can anybody spot what's wrong? http://lpaste.net/96628
22:25:39 <mzero> no = on line 2
22:25:40 <Fusebox|2> doh
22:25:45 <Fusebox|2> just saw that
22:25:46 <Fusebox|2> thanks!
22:26:52 <mzero> Fusebox|2: I just annotated that paste with an alternative
22:27:13 <Fusebox|2> Sounds good!  I'll check
22:27:39 <Fusebox|2> Ah yes. Under what circumstances would that be preferred?
22:27:52 <mzero> all!
22:27:55 <Fusebox|2> Oh.
22:28:02 <Fusebox|2> haha
22:28:43 <mzero> fewer lines, fewer words, makes the intent very clear, no need to name a value used just once ('number'), etc...
22:29:09 <Fusebox|2> With that method can I have conditionals before the equals sign or would pattern matching fail there?
22:30:25 <mzero> you can only pattern match in the head clauses - you neeed the guard (the |  ) to have a conditional
22:30:29 <Fusebox|2> To rephrase: any time I need to evaluate a boolean expression, I'll need to use guards or case, right?
22:30:32 <Fusebox|2> cheers
22:30:59 <mzero> well, unless the expression is == <constant>   --- because that can often be done in the pattern
22:31:22 <Fusebox|2> ah, good
22:32:17 <mzero> so we sometimes see        parseArg ('n':'o':arg) = (False, arg)     ;   parseArg arg = (True, arg)
22:32:27 <mzero> note the pattern match against constant characters
22:33:56 <MitoticSpindle> That's neat. I love Haskell.
22:34:03 <mzero> me too!
22:34:43 <lispy> I almost always use isPrefixOf instead of that
22:35:30 <lispy> But I guess in this case it's nice because you're dropping the "no" when it's present
22:36:29 <mzero> right - it would be pretty situationally dependentant if I'd go this route vs. isPrefixOf or some other approach
22:36:34 <lispy> (The reason I prefer to use isPrefixOf, is that when yoeu discover that you want more control over matching you end up rewriting it to use a function anyway)
22:37:17 <mzero> OTOH, when matching against a numeric 0, almost always the pattern match route
22:37:47 <lispy> Save the guards for more interesting work.
22:38:48 <mzero> Guards! Guards! The prisioner is escaping IO!
22:40:21 <Fusebox|2> I lol'd
22:40:23 <dmwit> stripPrefix is almost always better than isPrefixOf.
22:41:09 <shachaf> :t strippingPrefix
22:41:10 <lambdabot> (Eq a, Applicative f, Choice p) => [a] -> p [a] (f [a]) -> p [a] (f [a])
22:41:27 <shachaf> Hmm, I think that was renamed to "prefixed".
22:41:46 <dmwit> More general is better.
22:41:58 <shachaf> Anyway, it's, like, totally a prism and stuff.
22:42:08 <newsham> ?instances Choice
22:42:08 <lambdabot> Couldn't find class `Choice'. Try @instances-importing
22:43:24 <shachaf> Market a b, WrappedArrow p, UpStar f, Tagged, Kleisli m, Forget r, DownStar w, Cokleisli w, (->), Procompose p q, Reviewed, Indexed i
22:44:22 <simpson> I know what some of these words mean!
22:44:55 <shachaf> Choice is vaguely my fault.
22:45:16 <shachaf> But it's much better than what we had before!
22:48:13 <lispy> dmwit, shachaf: neato burrito
22:48:21 <lispy> That's a lens-ism?
22:48:39 <lispy> ?hoogle strippingPrefix
22:48:39 <lambdabot> No results found
22:48:48 * lispy weeps
22:48:55 <shachaf> Yes.
22:49:05 <shachaf> It's a prism.
22:49:12 <shachaf> :t prefixed
22:49:13 <lambdabot> (Eq a, Applicative f, Choice p) => [a] -> p [a] (f [a]) -> p [a] (f [a])
22:49:17 <shachaf> Oh, there.
22:49:33 <shachaf> > preview (strippingPrefix "abc") "abchello"
22:49:34 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
22:49:40 <shachaf> > preview (prefixed "abc") "abchello"
22:49:42 <lambdabot>   Just "hello"
22:49:59 <shachaf> int-e: Deprecation warnings should be nicer than ☝
22:50:29 <shachaf> > over (mapped.prefixed "abc".each) toUpper ["blah", "abchello", "abcdefg"]
22:50:30 <lambdabot>   ["blah","abcHELLO","abcDEFG"]
22:50:43 <shachaf> > review (prefixed "abc") "hello"
22:50:44 <lambdabot>   "abchello"
22:51:04 <lispy> :t refixed
22:51:05 <lambdabot>     Not in scope: `refixed'
22:51:05 <lambdabot>     Perhaps you meant `prefixed' (imported from Data.List.Lens)
22:51:15 <lispy> preview -> review, prefixed -> ??
22:51:32 <lispy> So much pun potential
22:51:36 <shachaf> > prefixed "abc" # "hello"
22:51:37 <lambdabot>   "abchello"
22:52:00 <shachaf> Think of it as a sum type.
22:52:16 <simpson> Oh, I see, Choice is related to Profunctor.
22:52:29 <simpson> Profunctors still hurt my head.
22:56:32 <shachaf> Profunctor is not complicated.
22:56:56 <simpson> But they look so much like Arrows.
22:57:06 <shachaf> Nah, it's way nicer.
22:57:30 <shachaf> If you understand Functor and Contravariant then Profunctor should be easy.
22:58:00 <simpson> The signatures, I mean. They look like Arrow signatures.
22:58:22 <simpson> And it's weird because most of the time, GHC picks (->) for the Profunctor of choice.
22:58:53 <shachaf> Forget about Arrow. I'd rather spend minimal time thinking about that class.
22:59:02 * shachaf = h8r
22:59:26 <shachaf> arkeet: It's not just that I'm a h8r. I'mm a hater.
22:59:47 <shachaf> Anyway, that's just because lens is weird in order to be backwards-compatible with Traversable.
23:00:06 <shachaf> Otherwise we would be using more interesting Choice instances.
23:00:53 <Sgeo> @djinn (a -> a) -> (b -> b) -> (a -> b) -> (a -> b)
23:00:53 <lambdabot> f _ a b c = a (b c)
23:02:09 <slack1256> the compile function on http://hackage.haskell.org/package/regex-posix-0.95.2/docs/Text-Regex-Posix-ByteString.html
23:02:23 <slack1256> shouldn't it be pure? or because the ffi has to be in the IO monad?
23:03:04 <simpson> Okay, I don't get (#.) and (.#), I guess.
23:03:13 <shachaf> Ignore them.
23:03:21 <shachaf> They're probably going away in the next version of GHC.
23:03:29 <shachaf> Just an ugly performance hack which is sort of my fault.
23:03:29 <dmwit> slack1256: That's a bit obnoxious.
23:03:43 <simpson> Okay.
23:03:51 <shachaf> slack1256: That's a "medium level API".
23:03:54 <edwardk> shachaf: pure profunctor lenses may have been given a new lease on life. i'm playing with them again
23:04:00 <edwardk> shachaf: though in a more general setting
23:04:04 <shachaf> edwardk: Oh? What's new?
23:04:32 <edwardk> shachaf: spent a couple of days making them rigorous, was curious if i could use them to subsume the notion of delta-lenses.
23:05:06 <shachaf> Delta-lenses?
23:05:14 <edwardk> basically figured out how to write them up in something intelligible to a non-haskeller i think
23:05:15 <shachaf> Rigorous as in figured out more laws for them, or what?
23:06:16 <edwardk> a.) i think i figured out how to read xplat's laws properly, and b.) figured out how to encode the proper details of the indexing structure, tied the index back to the notion of constant complement, etc.
23:06:40 <edwardk> but in particular i am starting to get intuition for what they mean when the profunctor is over another category
23:07:41 <shachaf> That sounds interesting.
23:08:03 * shachaf hasn't really thought about any of this in months.
23:08:09 <edwardk> basically decided to do that to huddle inside for warmth. Fahrenheit almost met Celsius here today
23:09:56 <shachaf> And there I was complaining that it was slightly below 0°C at night here!
23:10:52 <shachaf> What were xplat's laws again?
23:17:15 * hackagebot egison 3.1.1 - The world's first language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.1.1 (SatoshiEgi)
23:17:47 * chrisdone . o O ( there was already one on the moon? )
23:37:02 <simpson> :t right
23:37:03 <lambdabot> ArrowChoice a => a b c -> a (Either d b) (Either d c)
23:37:09 <jrmithdobbs> Is there a synonym for zipWith ($)
23:37:20 <jrmithdobbs> :t zipWith ($)
23:37:21 <lambdabot> [b -> c] -> [b] -> [c]
23:37:43 * simpson . o ((b ~> c) -> Either d b ~> Either d c)
23:38:23 <simpson> jrmithdobbs: IIRC there's a second Applicative newtype of [] called ZipList which might be useful.
23:41:45 <scott_> > getZipList $ ZipList [(*2),(+4)] <*> ZipList [3,10]
23:41:46 <lambdabot>   [6,14]
23:42:21 <scott_> :t \fs xs -> getZipList $ ZipList fs <*> ZipList xs
23:42:21 <lambdabot> [a1 -> a] -> [a1] -> [a]
23:42:39 <scott_> I guess that's the type you want... but it's not exactly shorter than zipWith ($)
23:44:15 <simpson> :t ala
23:44:16 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
23:44:53 <Sgeo> Hmm. Could I use http-reverse-proxy to effectively run WAI middleware on a non-Haskell webserver
23:44:53 <Sgeo> ?
23:45:38 <jrmithdobbs> > ZipList [view _1, view _2] <*> ZipList [(1,2),(3,4)] & getZipList
23:45:39 <lambdabot>   [1,4]
23:46:25 <jrmithdobbs> Actually exactly what I'm after
23:47:02 <shachaf> @let zap = zipWith id
23:47:04 <lambdabot>  Defined.
23:49:35 <nickela> hello, I have a question about vinyl. I need:   extract :: t -> PlainRec a -> [(String,t)]
23:49:46 <nickela> extract returns all fields of type t with their names from PlainRec
23:50:16 <Sgeo> Is there a way for me to downvote a package on Hackage with extreme prejudice?
23:50:37 <nickela> it there a way to write this function without using custom typeclasses?
23:50:59 <jrmithdobbs> Sgeo: Sure so long as you insert something jn the request back to the front end that isn't spoofable but can differentiate backened re-requests from the middleware back "through" the stack (header with siphash and shared key, eg )
23:51:13 <Sgeo> "Adds cors support to WAI" = Just shove Allow-Access-Control-Origin: * in front of each response
23:51:20 <jrmithdobbs> Sgeo: Seen same done with rack and ngnix
23:53:19 <jrmithdobbs> Sgeo: You get a req/s throughput hit (significant sometimes) but it's possible to do
23:53:44 <Sgeo> https://github.com/seanhess/wai-middleware-headers/blob/master/Network/Wai/Middleware/Headers.hs
23:53:46 <Sgeo> I want to cry
23:54:39 <simpson> "This represents the right Kan lift of a Profunctor q along a Profunctor p in a limited version of the 2-category of Profunctors where the only object is the category Hask, 1-morphisms are profunctors composed and compose with Profunctor composition, and 2-morphisms are just natural transformations."
23:54:49 <simpson> Okay! I think it's time for bed.
