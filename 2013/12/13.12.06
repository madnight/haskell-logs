00:01:27 <ReinH> simpson: oh is that what it represents.
00:02:34 <bartavelle> I'd like to get a list of strings given a type. I have written a typeclass for this, and default instances, so that I can write "getScopes (undefined :: MyType)", isn't there a nicer way to do this ?
00:03:25 <bartavelle> err, (def :: MyType)
00:03:36 <bartavelle> because for some reason undefined gets evaluated here :(
00:06:20 <bartavelle> ah it's not evaluated, that was another one, grrr
00:11:54 <quicksilver> bartavelle: well you can keep around a name of each type, defined or otherwise.
00:12:10 <quicksilver> or you can somehow annotate some nearby convenitn value with a phantom of that type
00:12:37 <quicksilver> there are a few options depending on the structure of your program but I don't think it's something to get too hung up about, it's pretty trivial aesthetics
00:13:02 <bartavelle> yes, but I wondered if there was a computation structure that would do that for me
00:13:16 <bartavelle> that would statically be able to know which types I'm using in it
00:13:23 <bartavelle> hum I'm getting ahead of myself
00:13:40 <bartavelle> my use case is the google api, where you need to say which scopes you want to use when authenticating
00:14:16 <bartavelle> if I write some kind of external DSL to query and work with it, it would be trivial to parse the computation and extract all the types used, thus all the scopes
00:14:22 <bartavelle> but is that possible for an internal dsl ?
00:14:41 <bartavelle> not the proper terms either
00:14:50 <bartavelle> a dsl where I could use the language functionnalities
00:15:03 <bartavelle> (such as writing a monad, except it might be an arrow here ?)
00:18:32 <quicksilver> deep vs shallow embedding, bartavelle
00:18:58 <bartavelle> yeah internal / external is another concept
00:19:17 <quicksilver> the general answer to your question is "yes"
00:19:19 <quicksilver> :)
00:19:23 <bartavelle> hehehe
00:19:25 <quicksilver> given an actual problem
00:19:34 <quicksilver> there is normally a way of embedding teh types statically in the context
00:19:47 <quicksilver> so that the right thing can be extracted by the type checker without extra work on your part
00:20:01 <quicksilver> it might be a parameter to an ADT (phantom or otherwise, GADT perhaps)
00:20:16 <quicksilver> or it might be deduced by a type family
00:20:26 <quicksilver> but, it's quite hard to tell without an actual code design.
00:20:35 <bartavelle> if I go the ADT way, I am leaving all the native control structures behind, right ?
00:21:05 <quicksilver> well not necessarily. ADTs can contain functions; ADTs can be instances of Monad etc.
00:21:12 <bartavelle> ah indeed
00:21:31 <quicksilver> an important tradeoff is normally that if you allow general computation (functions etc) you lose introspection
00:21:37 <quicksilver> you can't do a case-match on the contents of a function
00:21:48 <quicksilver> so you can't do magic substitution or optimisation
00:21:55 <quicksilver> it really does depend what you're trying to do.
00:22:02 <bartavelle> I don't think it matters for my use case
00:22:06 <bartavelle> I'll try to think about this after I finish a first iteration, thanks
00:31:50 <helmut> when trying to install darcs on opensuse using cabal, it errors out failing to link -liconv. I can see that the debian package disables iconv, but I don't see how that happens, --flags=-libiconv does not have any effect.  any ideas?
00:37:16 <frms> [6~[6~
00:50:59 <valdyn> helmut: see the diff
00:52:01 <valdyn> helmut: meaning "apt-get source darcs", then look at the .diff.gz file
00:54:48 <helmut> valdyn: the diff does not contain the string iconv
00:55:05 <helmut> valdyn: actually the diff is a .tar.gz
00:55:18 <valdyn> helmut: so debian did probably not disable it compared to upstream, it seems
00:56:06 <helmut> the build log indicates that darcs is build without iconv there
00:56:24 <helmut> see https://buildd.debian.org/status/fetch.php?pkg=darcs&arch=amd64&ver=2.8.4-3%2Bb1&stamp=1369753127
00:57:01 <helmut> my issue being that I cannot build darcs on opensuse though. I only reached for the debian log to see if I could borrow some bits
00:58:27 <valdyn> helmut: see this comment "-- Note that the Setup script checks whether -liconv is necessary." in darcs.cabal
01:00:22 <helmut> okok, I do see that, but why does it determine it to be necessary on opensuse? (even though there is no libiconv there)
01:03:49 <valdyn> helmut: im not quick at reading haskell
01:07:23 <valdyn> helmut: in Setup.lhs, theres a function "iconv_prog" that represents a C program. Setup.lhs simply tries to compile it and adds -liconv depending on the outcome
01:08:46 <valdyn> helmut: i believe you might have another issue preventing you to compile, obviously it cannot compile that program then either even if -liconv would not be needed
01:10:22 <Dasuraga> do people use darcs much?
01:10:36 <valdyn> i see it sometimes
01:11:03 <valdyn> im sure the haskell people use it alot
01:11:11 <sopvop> darcs is great for small number of contributors.
01:11:36 <chrisdone> it's not as popular as it was due to git
01:12:00 <sopvop> or maybe due to github
01:12:14 <helmut> valdyn: thanks for your help, I tried manually building iconv_prog. it builds and executes successfully without any gcc command line parameters
01:12:48 <valdyn> helmut: so maybe gcc returns something that Setup.lhs does not expect
01:13:19 <helmut> hmm. anyway I'll also need someone to install curl headers before I can go on. *sigh*
01:13:54 <chrisdone> sopvop: just git in general. hg had bitbucket the same year as github
01:14:16 <helmut> darcs is kinda required for contributing back in the haskell ecosystem. for instance the agda standard library is maintained using darcs
01:14:17 <chrisdone> git has magit, decent branch switching, speed
01:14:32 <Sgeo_>     Couldn't match expected type `main::Interactive.Foo'
01:14:32 <Sgeo_>                 with actual type `main::Interactive.Foo'
01:14:33 <chrisdone> helmut: that's mostly wrong
01:14:44 <chrisdone> in the past it was truer, but i haven't even got darcs installed
01:14:50 <Sgeo_> (Not asking for help on this, I know what I did, just noting the less than helpful message)
01:16:11 <helmut> chrisdone: not claiming that git wasn't required, but darcs is still used in a number of places, especially in the scientific part
01:17:11 <sopvop> happstack is still on darcs (and I double stepcut will move to git)
01:17:27 <sopvop> I doublt
01:17:32 <sopvop> doubt
01:18:35 <chrisdone> maybe in 2008, it's true that darcs was popular in the haskell (and lisp) world
01:19:09 <chrisdone> now when i see a darcs repo, i can't even be bothered contributing patches
01:19:18 <BoR0> can "words" be implemented in terms of fold? I am just interested if it is possible, I know that it'd be pain to do it
01:20:33 <chrisdone> bor0: sure
01:21:20 <arkeet> any function on a list can be implemented with foldr.
01:21:27 * arkeet tries implementing words
01:21:43 <chrisdone> arkeet: bored?
01:21:48 <arkeet> yes
01:21:57 <quicksilver> any streaming list process (meaning, it continues to produce output while processing only part of the input) can be implemented as a foldr.
01:22:03 <AshyIsMe> chrisdone: how's using hell going?
01:22:09 <c_wraith> I thought foldr only gave your primitive recursion - that it can't do ackerman-level calculations
01:22:17 <shachaf> foldr + post-processing
01:22:20 <shachaf> words = realWords . foldr (:) []
01:22:24 <arkeet> :)
01:22:39 <c_wraith> gave *you*
01:22:45 <BoR0> @src realWords
01:22:45 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
01:22:50 <BoR0> haha. oh I see.
01:22:53 <quicksilver> foldr doesn't even give you all of primrec unless you post-process.
01:23:05 <shachaf> foldr + unfoldr
01:23:08 <quicksilver> and as shachaf points out eloquently post processing rather reduces the problem to trivial.
01:23:09 <BoR0> > words.foldr (:) [] "test test"
01:23:10 <lambdabot>   Couldn't match type `[GHC.Types.Char]' with `a0 -> GHC.Base.String'
01:23:10 <lambdabot>  Expect...
01:23:21 <ReinH> a cunning use of the toList fold
01:23:35 <arkeet> ok I quit
01:24:07 <shachaf> Anyway Haskell supports foldr on infinite lists which is weird.
01:24:22 <arkeet> only as weird as Haskell.
01:24:42 <shachaf> Yes. Haskell is weird.
01:24:52 <ReinH> shachaf: categories are weird.
01:25:04 <sipa> @faq Can Haskell be nonweird?
01:25:04 <lambdabot> The answer is: Yes! Haskell can do that.
01:25:22 <shachaf> @remember pigworker The usual style is to write as if everything is inductive, and if it still works on infinite data, to pat ourselves on the back for using Haskell rather than ML. I'm certainly guilty of that.
01:25:22 <lambdabot> It is forever etched in my memory.
01:25:34 <ReinH> haha
01:25:36 <shachaf> Hmm, maybe it's better without the last sentence.
01:25:39 <shachaf> @forget pigworker The usual style is to write as if everything is inductive, and if it still works on infinite data, to pat ourselves on the back for using Haskell rather than ML. I'm certainly guilty of that.
01:25:39 <lambdabot> Done.
01:25:45 <shachaf> @remember pigworker The usual style is to write as if everything is inductive, and if it still works on infinite data, to pat ourselves on the back for using Haskell rather than ML.
01:25:45 <lambdabot> Done.
01:26:09 <chrisdone> he who controls the present controls the past
01:26:10 <c_wraith> > foldr (\c r -> if isSpace c && null r then "" else c:r) "" "testing... "  -- my favorite use of foldr, because it looks weird and does something as lazily as possible.
01:26:11 <lambdabot>   "testing..."
01:26:27 <ReinH> codata? no, no one could possibly need that.
01:26:53 <shachaf> Do we have any sneaky uses of foldr in the sneaky database?
01:26:55 <shachaf> @where sneaky
01:26:55 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
01:26:57 <ReinH> c_wraith: it... lazily removes a trailing space?
01:26:57 <shachaf> @where sneaky2
01:26:57 <lambdabot> lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []
01:26:59 <jle`> why does Maybe even exist if we can always just use [a] and [] instead of Just a and Nothing
01:27:04 <jle`> i call shenanigans
01:27:07 <c_wraith> ReinH: removes all trailing spaces
01:27:13 <shachaf> @where sneaky3
01:27:13 <lambdabot> I know nothing about sneaky3.
01:27:16 <arkeet> c_wraith: it removes a lot more than that
01:27:16 <shachaf> Oh well.
01:27:28 <arkeet> > foldr (\c r -> if isSpace c && null r then "" else c:r) "" "hello c_wraith"
01:27:29 <lambdabot>   "hello c_wraith"
01:27:32 <arkeet> oh.
01:27:34 <arkeet> oh null.
01:27:52 <arkeet> > foldr (\c r -> if isSpace c then "" else c:r) "" "hello c_wraith" -- removes c_wraith
01:27:53 <lambdabot>   "hello"
01:28:09 <c_wraith> Yes, that's why I didn't write that code. It would be less clever. :)
01:28:40 <c_wraith> and it would remove me
01:29:10 <ReinH> oh. oh.
01:29:14 <ReinH> that's clever.
01:29:30 <ReinH> it folds to the left.
01:29:30 <c_wraith> I know it's clever because I didn't write it.
01:29:45 <ReinH> such clever
01:29:46 <ReinH> wow
01:29:52 <quicksilver> you have to accumulate your list of words so far
01:29:57 <c_wraith> I got it when someone showed up in here having *nearly* written it while doing some homework.
01:30:02 <quicksilver> so you have to fold over a tuple, or similar
01:30:15 <shachaf> > foldr (\c r -> if isSpace c then "" else c:r) "c_wraith second cousin second cousin"
01:30:16 <lambdabot>   <[Char] -> [Char]>
01:30:18 <c_wraith> And I got it to work before I understood how exactly it works.
01:30:20 <shachaf> Sigh.
01:30:24 <shachaf> > foldr (\c r -> if isSpace c then "" else c:r) "" "c_wraith second cousin second cousin"
01:30:25 <lambdabot>   "c_wraith"
01:30:36 <quicksilver> generally when you're translating arbitrary primitive recursion into a foldr you need to use a tuple to hold all the other parameters
01:30:39 <quicksilver> ("state" if you will)
01:30:53 <ReinH> wait, lambdabot can show functions?
01:31:04 <c_wraith> sometimes it can
01:31:05 <chrisdone> it has a Show instance
01:31:05 <arkeet> "show"
01:31:08 <jle`> ikr
01:31:10 <c_wraith> > print ()
01:31:11 <lambdabot>   <IO ()>
01:31:13 <ReinH> neat
01:31:14 <arkeet> > chr
01:31:15 <lambdabot>   <Int -> Char>
01:31:21 <jle`> i think it uses typeable
01:31:21 <ReinH> I would support adding this to my ghci
01:31:26 <arkeet> it does.
01:31:31 <arkeet> ReinH: I wouldn't.
01:31:41 <ReinH> arkeet: mine, not yours :p
01:31:44 <arkeet> that's fine!
01:31:48 <ReinH> that's what I said :
01:31:49 <ReinH> :)
01:32:08 <jle`> anyways can someone explain to me why Maybe even exists when you can just use [a] for Just a and [] for Nothing.  this is an outrage.
01:32:09 <ReinH> or at least being able to set it on and off
01:32:54 <shachaf> jle`: I don't get it.
01:33:13 <ReinH> jle`: maybes have exactly 0 or 1 value
01:33:14 <jle`> shachaf: in every case you use Maybe, you can replace Just a with [a], and Nothing with []
01:33:20 <jle`> and it'll all work the same
01:33:34 <ReinH> jle`: but the reverse is not true
01:33:44 <c_wraith> jle`: sometimes you want to statically disallow getting 2 results
01:34:14 <jle`> boo static guaruntees how boring yall are stiffs
01:34:16 <quicksilver> jle`: in every case that you use String, you can use Integer and encode your numbers in UTF8 as a very large number.
01:34:35 <quicksilver> jle`: if every case that you use Double you can use Integer with the IEEE representation of Doubles.
01:34:48 <quicksilver> in fact we can just use Integers for everything. computers just process numbers after all.
01:34:59 <c_wraith> the only data type is a sequence of bits
01:35:03 <jle`> quicksilver: yes but this is just a simple regex kind of swap
01:35:15 <quicksilver> the language of full of such swaps
01:35:17 <quicksilver> mor or less simple
01:35:27 <quicksilver> you're right that that the list/maybe one is particular simple
01:35:34 <quicksilver> that's why listToMaybe and maybeToList both exist
01:35:43 <ReinH> jle`: anywhere you have a single number you can use a singleton array of that number
01:35:44 <quicksilver> but it's still useful to use the type system.
01:35:46 <ReinH> why not?
01:36:06 <ReinH> lists are perfectly capable of representing "exactly one value"
01:36:12 <ReinH> so why use plain old values? how boring!
01:36:34 <quicksilver> or indeed a list of lists (of one list of one number). Or a list of lists of lists... etc :)
01:36:44 <ReinH> why use numbers? use [()] instead.
01:37:16 <ReinH> but wrap them in a list so we know we have exactly one value
01:37:44 <ReinH> Who needs 2 when we have [[(),()]]
01:38:13 <BoR0> :D
01:38:18 <ReinH> And if we have a maybe number that is Just 2, then that is obviously [[[(),()]]]
01:38:18 <chrisdone> p_p
01:38:21 <ReinH> Ok I'll stop now.
01:38:46 <BoR0> wouldn't that be LISP instead of Haskell?
01:39:00 <chrisdone> q_q
01:39:19 <ReinH> BoR0: the parens are supposed to be on the outside in lisp
01:39:31 <ReinH> I think you want ((([],[])))
01:40:22 <shachaf> I think the point was made a while ago.
01:40:23 <BoR0> yes, but even if we can replace Maybe with lists, we are starting to work generally on lists, i.e. list processing. I always thought that it is in the philosophy of Haskell to be able to "talk" (in a non-cryptic way) to the language once everything is set up
01:40:44 <ReinH> shachaf: I may have gotten slightly carried away.
01:42:10 <jle`> if you do it that way then you work against MonadPlus
01:42:18 <jle`> MonadPlus makes it as easy as possible to swap Maybe and []
01:42:46 <jle`> in fact any function written for Maybes can be trivially generalized to use MonadPlus and then work with p[
01:42:48 <jle`> []
01:43:29 <Taneb> jle`, not quite, for example the maybe function
01:43:52 <shachaf> Writing Maybe when you mean Maybe is nice.
01:44:06 <shachaf> Then your type says what you mean and what your function can and can't do.
01:44:11 <jle`> @src maybe
01:44:11 <lambdabot> maybe n _ Nothing  = n
01:44:11 <lambdabot> maybe _ f (Just x) = f x
01:44:52 <jle`> hmmmmm maybe n _ [] = n, maybe _ f [x] = f x
01:45:07 <jle`> oh i see what you mean
01:45:13 <jle`> you can't pattern match generally
01:45:22 <jle`> that sucks :|
01:45:34 <jle`> pattern match generically
01:45:35 <dv-> ? maybe n _ Nothing = n
01:46:13 <dv-> oh generically
01:48:10 <chrisdone> > snd . foldr (\x (c,xs) -> case x of '>' -> (flip const,xs); '<' -> ((:),xs); _ -> (c,c x xs)) ((:),[]) $ "Hello, <b>World</b>!"
01:48:11 <lambdabot>   "Hello, World!"
01:48:13 <chrisdone> i like this use of foldr
01:49:03 <ReinH> also clever
01:59:23 <chrisdone> srhb: hello fellow hetzner user
03:32:39 <allsystemsarego> > filter (/=[]) $ (split . whenElt) even [1,1,3,5,2,4,8,6,7,9,3,1,4,4]
03:32:39 <lambdabot>   [[1,1,3,5],[2],[4],[8],[6],[7,9,3,1],[4],[4]]
03:32:55 * hackagebot HMap 1.0.2 - Fast heterogeneous maps.  http://hackage.haskell.org/package/HMap-1.0.2 (AtzeVanDerPloeg)
03:32:57 <allsystemsarego> is there a more elegant way of expressing this?
03:33:03 <allsystemsarego> > filter (/=[]) $ (split . whenElt) even [1,1,3,5,2,4,8,6,7,9,3,1,4,4]
03:33:04 <lambdabot>   [[1,1,3,5],[2],[4],[8],[6],[7,9,3,1],[4],[4]]
03:34:32 <mauke> > groupBy ((==) `on` even) [1,1,3,5,2,4,8,6,7,9,3,1,4,4]
03:34:33 <lambdabot>   [[1,1,3,5],[2,4,8,6],[7,9,3,1],[4,4]]
03:35:24 <mauke> > groupBy ((&&) `on` odd) [1,1,3,5,2,4,8,6,7,9,3,1,4,4]
03:35:26 <lambdabot>   [[1,1,3,5],[2],[4],[8],[6],[7,9,3,1],[4],[4]]
03:35:34 <allsystemsarego> nice
03:35:43 <allsystemsarego> thanks mauke
03:35:59 <arkeet> groupBy is most fun to use with things that aren't equivalence relations.
03:36:18 <allsystemsarego> arkeet, example?
03:36:38 <arkeet> you just saw one.
03:36:53 <mauke> are you sure?
03:37:02 <arkeet> yes
03:37:10 <arkeet> > ((&&) `on` odd) 2 2
03:37:11 <lambdabot>   False
03:37:12 <arkeet> not reflexive.
03:37:18 <mauke> oh, that one
03:37:20 <mauke> yeah
03:37:30 <mauke> > groupBy (<) [1,1,3,5,2,4,8,6,7,9,3,1,4,4]
03:37:31 <lambdabot>   [[1],[1,3,5,2,4,8,6,7,9,3],[1,4,4]]
03:46:55 <t7> Maybe a -> Maybe a -> Maybe a
03:47:00 <t7> @hoogle Maybe a -> Maybe a -> Maybe a
03:47:00 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
03:47:01 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
03:47:01 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
03:47:22 <t7> > mplus (Just 1) (Just 2)
03:47:23 <lambdabot>   Just 1
03:47:43 <t7> > (mplus (Just 1) nothing, mplus nothing (Just 1))
03:47:44 <lambdabot>   Not in scope: `nothing'
03:47:44 <lambdabot>  Perhaps you meant `_Nothing' (imported from Contro...
03:47:51 <t7> > (mplus (Just 1) Nothing, mplus Nothing (Just 1))
03:47:51 <lambdabot>   (Just 1,Just 1)
03:49:05 <mauke> > mappend (Just "a") (Just "b")
03:49:06 <lambdabot>   Just "ab"
03:55:24 <issam>  hi folks
03:55:25 <issam> <issam> im somewhat confused by the lambda calculus symbols
03:55:25 <issam> <issam> Gamma |- x : T for example
03:55:25 <issam> <issam> Gamma is the state right?
03:55:25 <issam> <issam> but what does ' |- ' mean?
03:55:50 <apo> bitwise or with negative x
03:55:52 * apo hides
03:56:30 <mauke> I think it's some kind of context annotation
03:56:48 <quicksilver> |- is not a lambda calculus symbol
03:56:51 <quicksilver> it's a logical symbol
03:57:00 <quicksilver> it's traditional read as "entails"
03:57:07 <mauke> well, : isn't LC either
03:57:28 <quicksilver> indeed
03:57:40 <quicksilver> that looks like type theory (which is a logic)
03:57:55 <mauke> >implying
03:58:01 <quicksilver> Gamma |- x : T reads "The context Gamma entails that the term x has type T"
03:58:22 <quicksilver> entailment is closely related to implication in "normal" logics.
04:09:26 <haasn> I don't understand what the difference between entailment ⊢ and implication → or ⇒ is
04:09:58 <merijn_> Is there a more efficient way to parse small chunks of a ByteString than just feeding the BS into a Get, stuff the unused bit in State, do some stuff, get the remainder from State and feed into the next Get, etc.
04:11:48 <maxs_> merijn_: are you using a lazy list for the chunks?
04:12:35 <merijn_> maxs_: No, using strict BS with IO operations
04:13:04 <merijn_> And I need to do some IO based on the stuff I parse, so I can't just read a large lazy chunk and use a single large Get
04:14:22 <maxs_> yeah, I can't think of a faster approach
04:16:39 <maxs_> are you splitting lines? because it is a delimited file?
04:20:45 <snizzo> how can I get a formal grammar specification from a happy parser? Anyone knows maybe some place to start?
04:21:46 <merijn_> maxs_: No, I'm parsing a protocol whose initial design, unfortunately, didn't have a version number. Now fortunately they managed to retrofit a way to sniff between new and old versions so you can remain backwards compatible, but it means alternatingly parsing a few bytes to see which protocol version you need to talk to not confuse the other side
04:23:12 <issam> <quicksilver>: thanks, so the premise for T-abs (https://dl.dropboxusercontent.com/u/30688032/lambda.png)
04:23:14 <merijn_> i.e. write a fake length header, see what the other guy wrote, then based on wether it's old, new or backwards compatibility header decide on the rest of the header to write on your side, then parse further to see which version is being used (if a new or backwards compatible header), etc.
04:23:41 <issam> means, Gamma and x of type t1 entails t2 of type T2?
04:23:41 <maxs_> merijn_: ah yeah, cool
04:24:21 <ocharles> Anyone have any tips on proving monad associativity laws?
04:24:24 <ocharles> I have a monad that breaks them, but I can't figure out why it breaks them :(
04:24:30 <ocharles> https://gist.github.com/ocharles/e9abc976bd60ce44d303 is the code in question
04:27:06 <quicksilver> issam: yes. It means "Given all the facts in Gamma, together with the fact that 'x' has type T1, we can deduce that t2 has type T2"
04:28:24 <issam> quicksilver Thanks!
04:33:19 <BoR0> http://lpaste.net/96639 can this be beautified or somehow optimized?
04:33:59 <quicksilver> rather than using fst and snd, BoR0
04:34:03 <mauke> :t chunksOf
04:34:04 <lambdabot> Int -> [e] -> [[e]]
04:34:13 <mauke> > chunksOf 4 [1 .. 15]
04:34:14 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15]]
04:34:15 <quicksilver> just match the tuple that splitAt produces.
04:34:16 <merijn> BoR0: You can replace p with a direct pattern match on tuple
04:34:46 <merijn> BoR0: http://lpaste.net/96639
04:34:59 <BoR0> aha, neat
04:35:07 <merijn> Probably you should use better names, but anyway :)
04:35:22 <BoR0> :D
04:35:42 <merijn> BoR0: You can assign to arbitrarily complex patterns. If you want to throw some lists and more tuples on the left it'd still work
04:35:49 <nickela> Hello All! Here is vinyl experts?
04:36:14 <quicksilver> no you want #flooring for that? ;)
04:36:20 <BoR0> merijn, how hard would now be to rewrite that function by using folds?
04:36:21 <nickela> I need write function: extract :: t -> PlainRec a -> [(String,t)]
04:36:40 <nickela> that extracts all fields of type t from PlainRec
04:37:00 <nickela> I break my mind :-/
04:37:38 <merijn> BoR0: I'm not sure this fits a fold in a trivial way. Since you want to chunk it in pieces of 4. You *can* do it using fold, but it'll probably become harder to follow than what you have now
04:38:24 <BoR0> I know that fold is powerful. I just want to see how it would solve a problem like this. is it by using 2 or more folds? or recursively folding?
04:39:37 <quicksilver> the fold can't use splitAt because the fold needs to process the list elemebt by element
04:39:41 <merijn> BoR0: folds are generally when you have "a -> b -> a" and [b]
04:39:45 <quicksilver> whilst splitAt wants to be given the whole list
04:39:56 <merijn> That, yeah
04:40:03 <quicksilver> however you can solve the problem as a whole using a foldr certainly
04:40:21 <merijn> You could pre-split into chunks of 4, but then why bother with fold, just do things in the chunking function :p
04:40:28 <BoR0> I tried foldr with splitAt but I got stuck
04:43:01 <merijn> BoR0: Yeah, because those two don't really combine well :)
04:43:16 <BoR0> so what would be a different approach? :)
04:43:34 <quicksilver> > foldr (\x (chunks,partial) -> if length partial == 3 then (chunks ++ [x:partial],"") else (chunks,x:partial)) ([],[]) "abcdefghijklmnop"
04:43:35 <lambdabot>   (["mnop","ijkl","efgh","abcd"],"")
04:43:41 <quicksilver> like that BoR0
04:44:04 <BoR0> wow
04:44:09 <BoR0> neat, let me try to grasp that. thanks
04:44:09 <quicksilver> but obviously you have to extract the "answer" and, hmm, I build the answer backwards for no good reason
04:44:25 <BoR0> I don't think that's a huge problem :D reverse $ fst would do it, no?
04:44:44 <quicksilver> > foldr (\x (chunks,partial) -> if length partial == 3 then ((x:partial):chunks,"") else (chunks,x:partial)) ([],[]) "abcdefghijklmnop"
04:44:45 <lambdabot>   (["abcd","efgh","ijkl","mnop"],"")
04:44:54 <quicksilver> not a big problem but it was actually simpler to get it the right way around.
04:45:31 <BoR0> oh, I see what you are doing. makes perfect sense
04:45:45 <BoR0> I knew it had something to do with length. but I kept thinking in terms of foldr + splitAt
04:45:48 <quicksilver> I gave the variables long names as a clue :)
04:45:57 <BoR0> thanks for that. I should start doing that too :)
04:46:16 <quicksilver> you have to process character-by-character because it's a fold over characters
04:46:26 <quicksilver> but you can keep complicated "state" by folding over a tuple
04:46:31 <quicksilver> in the "b" part of the type:
04:46:33 <quicksilver> @type foldr
04:46:34 <lambdabot> (a -> b -> b) -> b -> [a] -> b
04:46:57 <quicksilver> so it's quite analagous to an imperative loop
04:47:01 <quicksilver> with local variables in the loop body
04:47:09 <quicksilver> they become the components of your tuple
04:48:16 <BoR0> I understand. thanks!
04:51:09 <tomejaguar> http://lpaste.net/96642
04:51:17 <tomejaguar> ^^ Can anyone tell me why this doesn't type check?
04:51:38 <merijn> tomejaguar: WOuld help if you paste the error :p
04:52:10 <tomejaguar> merijn: done
04:52:34 <merijn> tomejaguar: Also, you use chooser in your function, but don't have a MonadChoose constraint
04:52:49 <merijn> oh, you fixed that :p
04:53:04 * hackagebot hfsevents 0.1.5 - File/folder watching for OS X  http://hackage.haskell.org/package/hfsevents-0.1.5 (LuiteStegeman)
04:53:07 <tomejaguar> merijn: Yeah I fixed that :) I get the same error either way, which is strange.
04:54:19 <merijn> tomejaguar: oh
04:54:21 <tomejaguar> It seems to be defaulting to m = (Int ->)
04:54:23 <tomejaguar> or something strange
04:54:29 <tomejaguar> But I don't know why it would do that.
04:54:29 <merijn> tomejaguar: computation is missing an argument
04:54:35 <tomejaguar> Is it?
04:54:41 <tomejaguar> Oh my god
04:54:43 <mauke> type signature says it takes an int
04:54:45 <tomejaguar> OK how dumb
04:54:48 <merijn> tomejaguar: :p
04:54:49 <mauke> also, ex
04:54:55 <tomejaguar> Thank you :)
04:55:10 <quicksilver> and that is why people don't like the monad instance for (->)
04:55:15 <tomejaguar> ex should have an argument.  computation shouldn't.  I just needed to get rid of the Int -> from the type
04:55:18 <quicksilver> nicely exemplified by tomejaguar  :)
04:55:29 * merijn loves the monad instance for (->)
04:55:39 <quicksilver> the monad instance for (->) made that error message more confusion
04:55:39 * tomejaguar stands as a proud example.
04:55:43 <tomejaguar> Yes it is
04:55:49 <tomejaguar> And I wasted about 30 mins on that.  How annoying
04:56:04 <quicksilver> because the =<< which is the top connective there unified with the (->) in the type sig
04:56:09 <quicksilver> using the -> monad instance
04:56:15 <quicksilver> I didn't really use the right words there
04:56:20 <quicksilver> hope it made sense to someone anyway
04:56:22 <merijn> quicksilver: I know, but I still love it. Like my guinea pig peeing on my pants, it's annoying but I can't hate the little guy :p
04:56:34 <danilo2> Hello! I've noticed, that Distribution.InstalledPackageInfo.InstalledPackageInfo does not have got field bugReports, when the Distribution.PackageDescription.PackageDescription does have such field. Is this a bug or am I missing something?
04:57:19 <Jookia> Is there some way to ... reference an item in a list uniquely? RIght now the idea I have is just having each entry having IDs, but that kind of pollutes the data structures. Indices are subject to change. :l
04:57:20 <tomejaguar> quicksilver: Yeah I know exactly what you mean.  I have used (->)'s monad instance very happily before, but the error message I got just now was very puzzling ...
04:57:47 <merijn> Jookia: Depends on what you need to reference it for?
04:57:48 <mauke> I thought it was obvious
04:58:19 <merijn> Jookia: Why do you need a reference to an item rather than the item itself?
04:58:40 <Jookia> That's a very good question, I should've asked the actual thing, I haven't looked at my notes in weeks. One sec
04:59:12 <quicksilver> haskell values are often as good as references in another language, in that they are really only pointers so you're not copying unnecessary stuff around
04:59:42 <quicksilver> if you need the reference because the thing can change (whatever that means) then you might store the things in a Map or IntMap where the keys are some unique ID type.
05:00:31 <Jookia> Okay, I have a simulation and I want a way for objects to 'respond' to events such as collision. My current idea would be to have some kind of protocol that events 'mutate' objects and return new objects.
05:01:21 <Jookia> It's kind of weird designing a simulation where the per-frame processing is defined and deterministic without spaghetti code...
05:02:10 <merijn> Jookia: Treat events like a "Object -> Object" function and just map it over your list of objects?
05:02:29 <Jookia> In traditional simulations, events are sent to objects and objects just do what they want with them, so I suppose that's what I was getting at. But I suppose the functional way to do it, would to have events be functions that mutate data structures. That'd also give me the advantage of being able to make events limited due to types
05:02:31 <quicksilver> or Object->[Object] if they can multiply
05:02:41 <Jookia> Yeah, thanks guys/rubber ducks.
05:02:43 <Jookia> :v
05:02:47 <quicksilver> but if the Objects need to be able to 'see' other objects then just mapping over the list might not be enough.
05:03:18 <merijn> Jookia: ANother functional way is to not have objects at all, but just "Event -> Result" functions and apply them to every event :)
05:03:38 <quicksilver> sometimes you precalculate an environment for each object (other things close enough to see?) and then map (Environment -> Object -> [Object]) over them
05:03:47 <merijn> There was a neat blog post on "OO" haskell, lemme see if I can find it
05:03:58 <Jookia> merijn: That's one way, but there's a bit of a downside for using higher order functions: Serialization
05:04:34 <merijn> Jookia: That's true
05:05:28 <Jookia> It gets ugly when you 'loop' functions like in FRP: You can't save the functions' internal state so they become kind of black boxes
05:06:14 <merijn> If you need to serialise the events as "Environment -> Object -> [Object]" approach is probably better
05:06:37 <Jookia> merijn: Yeah.
05:07:14 <merijn> Plays well with the list monad too, by the looks of it :)
05:07:18 <Jookia> Is there any research on serializing higher-order functions?
05:07:59 <merijn> Jookia: Cloud Haskell has some stuff into that, but they mostly fake it by mapping higher order functions to id's + arguments and sending those
05:08:11 <merijn> Jookia: I believe there's a paper that discusses how they send function to other nodes
05:08:32 <merijn> Erlang does code serialisation too, but they have a VM so they can just ship bytecode
05:09:28 <Jookia> Hmm. I suppose I don't mean the functions themselves, but in the context of loading/saving higher order function's state. One way would to be to make the 'working' part of the functions that are actually higher-order (returning new functions, looping, etc) private, but having a 'constructor' that could specify initial state. Or I don't know.
05:09:56 <Jookia> The main problem is that with simulations it'd be nice to load/save state of the world, not just the world itself.
05:11:14 <merijn> Jookia: What state does your world have that isn't the world itself? Why does it have that state?
05:12:11 <merijn> Speaking of state, if I have 'StateT s IO a' and want access to the "current" state in an exception handler I guess I have to store that state in an MVar/TVar?
05:12:31 <merijn> Since the handler will only get the initial state...
05:12:35 <Jookia> merijn: Let's say, velocity for objects. Each function call moves it and can accept parameters that change velocity. In the end all that's exposed is the position. The simulation loop composed of functions would have the internal stuff
05:12:57 <merijn> Jookia: Why do you only expose position and not velocity, then?
05:13:39 <Jookia> merijn: It's an example, particularly in functional reactive programming. The idea is that you have a 'model', but all the logic is in functions and whatnot.
05:15:34 <merijn> Sure, but also means serialising is near impossible, since I don't think anyone has worked on a serialisable FRP library
05:15:45 <Skola_> Is there a name for the type of sequence that has a mapping f(n)? (in contrast to sequences that depend on the previous number?
05:17:40 <Jookia> Maybe I should toy around with serialising FRP
05:18:21 <Jookia> Who knows. Ciao
05:21:46 <danilo2> Hello :) What is the most "pure way in Haskell to sort list of objects by a field? I mean - I've got a list :: [X], and I want sort by (X ^. field1) (I\m using lenses) - I'm looking for a fancy maybe lens related way :)
05:24:42 <merijn> :t sorBy -- ?
05:24:42 <lambdabot>     Not in scope: `sorBy'
05:24:43 <lambdabot>     Perhaps you meant one of these:
05:24:43 <lambdabot>       `sortBy' (imported from Data.List),
05:24:44 <merijn> eh
05:24:46 <merijn> :t sortBy -- ?
05:24:47 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
05:25:03 <merijn> Usually combined with
05:25:04 <Hafydd> > sortBy (compare `on` snd) [('a',2),('b',3),('c',1)]
05:25:04 <lambdabot>   [('c',1),('a',2),('b',3)]
05:25:35 <danilo2> Hafydd: ah, compare `on` - Ok thank you!
05:25:54 <dv-> > sortBy (comparing snd) [('a',2),('b',3),('c',1)]
05:25:55 <lambdabot>   [('c',1),('a',2),('b',3)]
05:25:55 <haasn> > sortBy (comparing snd) [('a',2),('b',3),('c',1)]
05:25:56 <danilo2> merijn - I was looking for "compare `on`" stuff - I forgot something like "on" exists
05:25:56 <lambdabot>   [('c',1),('a',2),('b',3)]
05:26:18 <danilo2> haasn: thank you :)
05:26:23 <skypers> hi
05:26:37 <skypers> :t comparing
05:26:38 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
05:26:45 <skypers> @index comparing
05:26:45 <lambdabot> bzzt
05:26:50 <Hafydd> @hoogle comparing
05:26:50 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
05:27:00 <Hafydd> I forgot about that.
05:27:06 <merijn> What's preferred? nesting ReaderT and StateT or just going directly with RWST?
05:27:34 <skypers> sounds like on compare
05:27:52 <dv-> apparently WriterT has bad performance
05:27:53 <Hafydd> Because it is!
05:28:09 <skypers> dv-: I heard of that, do you have more details?
05:28:13 <haasn> :t let sortOf l = partsOf l %~ sort in sortOf
05:28:14 <lambdabot> Ord a => Traversing (->) Mutator s t a a -> s -> t
05:29:03 <dv-> skypers: no more than that. it was a post on r/haskell
05:29:51 <quicksilver> Writer tends to build up large thunks in the "log" part
05:29:59 <quicksilver> that might be what the poor performance referred to
05:30:10 <merijn> Which doesn't matter if you're just gonna set it W of RWST too ()
05:30:33 <merijn> Anyhoo, I'm never sure whether I should prefer RWST or ReaderT+StateT
05:31:14 <skypers> btw
05:31:24 <skypers> one can write a strict WriterT, aren’t they?
05:35:37 <quicksilver> skypers: yes. There is one somewhere.
05:36:08 <quicksilver> and it's probably even better to CPS transform the tuple away
05:36:19 <merijn> Oh wait, I think my API forces me to have a separate StateT, so I guess that solves my problem :p
05:36:23 <quicksilver> but I've never used writer enough to care :)
05:38:54 <skypers> I use RWST
05:39:03 <skypers> I guess it suffers from the same issue than WriterT
05:39:49 <flebron> So SPJ says there's a problem with inferring the type of f here. Why is f not :: T a -> Bool -> Bool? Clearly the return type must be Bool. The second parameter is sometimes returned, so it's also Bool. And the first T could be just any T, could it not? http://codepad.org/5B6HsXHw
05:41:50 <merijn> flebron: Case requires all constructors to have the same type, so T2 is forced to have type T Bool
05:42:15 <merijn> flebron: Hence f will be T Bool -> Bool -> Bool
05:42:35 <merijn> flebron: You'd need a higher-ranked case to deal with your code
05:42:45 <flebron> merijn: What does it mean for "all constructors to have the same type"?
05:42:56 <flebron> Surely I can pattern match on Nothing and on Just a.
05:43:43 <merijn> flebron: Yes, but this doesn't work: "case x of Just (a :: Int) -> undefined; (Nothing :: Maybe Bool) -> undefined"
05:43:59 <merijn> flebron: I.e. both the Just and Nothing case must be "Maybe Int"
05:44:21 <merijn> flebron: Likewise, both "T1 _" and "T2" must be "T Bool", becuase "T1 _" is type T Bool
05:44:38 <merijn> flebron: Therefore the input type of f must be "T Bool" and not "T a"
05:44:46 <flebron> So it's a limitation of the case statement, then?
05:45:22 <merijn> flebron: You need a case-of with a type like "T a -> (forall a . T a -> Bool) -> Bool" for this to work
05:46:04 <merijn> flebron: Well, of the type system and how it interacts with case, but yes.
06:09:03 <bartavelle> > runParser (many1 anyChar) () "dummy" "Noël"
06:09:05 <lambdabot>   Not in scope: `runParser'Not in scope: `many1'
06:09:05 <lambdabot>  Perhaps you meant `many' (i...
06:09:15 <bartavelle> > runParser (many anyChar) () "dummy" "Noël"
06:09:16 <lambdabot>   Not in scope: `runParser'Not in scope: `anyChar'
06:09:21 <merijn> Is anyone aware of some examples using bidirectional pipes? I think my troubles come from trying to stuff a bidirectional problem into a single pipe, but I can't find any good examples of using bidirectional pipes
06:09:29 <bartavelle> anyway, this destroys my utf-8 character with Parsec
06:09:44 <bartavelle> anybody knows a trick to get it back to its proper value ?
06:09:58 <bartavelle> (Right "No\235l")
06:09:59 <merijn> bartavelle: Try Parsec on text?
06:10:02 <bartavelle> I do
06:10:30 <bartavelle> type Parser = ParsecT T.Text () IO
06:10:46 <merijn> Why is "No\235l" broken?
06:10:55 <bartavelle> it's latin1-ized
06:10:59 <bartavelle> should be 2 bytes
06:11:09 <bartavelle> (the accentuated letter)
06:11:25 <merijn> Who says it's not?
06:11:28 <bartavelle> and it should print as an actual letter, not an escaped hex value
06:11:33 <merijn> bartavelle: It does
06:11:41 <merijn> bartavelle: Are you using "show"?
06:11:52 <bartavelle> show, T.putStrLn, pritn ...
06:12:02 <bartavelle> hum
06:12:05 <merijn> putStrLn "No\235l" <- this prints Noël properly for me
06:12:06 <bartavelle> didn't check T.putStrLn
06:12:11 <merijn> print and show are both wrong
06:12:17 <bartavelle> interesting
06:12:24 <merijn> bartavelle: Or rather, they're right
06:12:32 <merijn> bartavelle: But do something different from what you expect :)
06:13:17 <merijn> bartavelle: show (and thus print) produce a "haskell parseable string", which means it includes escapes for stuff like unicode and thus does *not* look the same as putStrLn on the string directly
06:13:19 <bartavelle> now I'll have to figure out how to fix my Pretty instance
06:13:40 <merijn> Which is why using show on Char/String is bad if you want to output things
06:14:19 <bartavelle> the "string" function in ansi-wl-pprint is likely to be bugged then
06:14:23 <bartavelle> I'll check this
06:14:38 <merijn> bartavelle: Sounds likely
06:14:43 <bartavelle> or more likely the Show instance
06:15:04 <merijn> bartavelle: Show is supposed to produce escape sequences
06:15:22 <letrec> Hello all. I have a question regarding Data.Typeable and cast. I can see cast's implementation and I still cannot "see" how the evaluation of "(cast 'a')  :: Maybe Char" works. Cast returns a Maybe b (where b is Typeable) and then it tries to specifies its type with Maybe Char?
06:15:57 <bartavelle> merijn, certainly, but putDoc should produce that's nice to read
06:16:18 <bartavelle> anyway I'll try to find the root of my problem
06:16:19 <bartavelle> thanks
06:16:20 <h007> why does deriving Show does not work on the following type def
06:16:20 <h007> data Tree k a = Leaf a | Node (k (Tree k a))
06:16:41 <h007> am i missing a language extension?
06:16:58 <Rarrikins> You might need (Show k, Show a) =>
06:17:05 <Rarrikins> But I'm not sure.
06:17:37 <Rarrikins> @let data Tree k a = Leaf a | Node (k (Tree k a)) deriving Show
06:17:37 <lambdabot>  .L.hs:147:26:
06:17:38 <lambdabot>      Ambiguous occurrence `Tree'
06:17:38 <lambdabot>      It could refer to either...
06:17:46 <Rarrikins> @let data Zomg k a = Leaf a | Node (k (Zomg k a)) deriving Show
06:17:47 <lambdabot>  .L.hs:148:24:
06:17:47 <lambdabot>      No instance for (Show (k (Zomg k a)))
06:17:47 <lambdabot>        arising from...
06:18:27 <Rarrikins> @let data Zomg k a = (Show (k (Zomg k a)) => Leaf a | Node (k (Zomg k a)) deriving Show
06:18:27 <lambdabot>  Parse failed: Parse error: |
06:18:41 <Rarrikins> @let data (Show (k (Zomg k a)) => Zomg k a = Leaf a | Node (k (Zomg k a)) deriving Show
06:18:41 <lambdabot>  Parse failed: Parse error: =
06:18:44 <Rarrikins> Blah
06:20:51 <Flonk> > let t="tro";r=const;o="lo";l=(<>) in t`r`o`l`o`l`o`l`o`l`o
06:20:52 <lambdabot>   "trololololo"
06:25:45 <h007> anyone? how to fix this error:  No instance for (Show (k (Tree k tl tn))) ?
06:25:49 <bartavelle> merijn, it seems that in the end, it was all my fault, not ansi-wl-pprint
06:26:02 <merijn> letrec: cast doesn't actually cast, if the two types are identical it'll return Just, if they are different it returns Nothing
06:27:11 <merijn> letrec: It mostly has a usecase when using existential quantification, where you may know a value is Typeable, but might not know it's actual type. In that case you can use cast to check whether they match
06:27:23 <merijn> letrec: It doesn't actually try to convert anything
06:27:37 <merijn> > cast 'c' :: Maybe Char
06:27:38 <lambdabot>   Just 'c'
06:27:42 <merijn> > cast 'c' :: Maybe Int
06:27:43 <lambdabot>   Nothing
06:28:21 <merijn> Rarrikins: No, you never need a constraint on datatypes
06:28:43 <merijn> Rarrikins: Please don't ever write code using DataTypeContexts for newbies, in fact, please don't write any code using it ever.
06:28:55 <supki> h007: if you want to derive Show instance for that datatype you can use standalone deriving
06:29:04 <supki> h007: default deriving is kinda limited
06:29:59 <merijn> h007: The problem is that since you have "k (Tree k tl tn)" it needs derive a Show instance for k, which it can't because it doesn't know what k is
06:30:04 <h007> supki: how to i do that? i tried adding StandaloneDeriving lang ext, is that it? or do i need to give an instance def?
06:30:05 <letrec> merijn: thank you. So when cast checks the types with typeOf x = typeOf (fromJust r), from type inference (because I have explicitly written  :: Maybe Char)  knows that b is Maybe b.
06:30:21 <merijn> letrec: Yes
06:30:24 <supki> h007: yes
06:30:26 <letrec> merijn: thank thank you.
06:30:45 <supki> h007:  deriving instance (Show a, Show (k (Tree k a))) => Show (Tree k a)  or something like that
06:31:47 <merijn> letrec: If you're using existential quantification you can sometimes "hide" the type, but keep the typeclass dictionary with the value. In which case "cast" can use that Typeable typeclass dictionary to compare the *actual* type against the type you asked for. If they match you get 'Just' (thus once again letting you know the type of the value), otherwise you get Nothing and you can't do much with the value
06:32:32 <merijn> h007: StandaloneDeriving like supki write should work, I think. If not you'll have to write your own instance by hand
06:33:14 <h007> supki,merijn: doesn't seem to work :( data Tree k a = E | L a | N (k (Tree k a))
06:33:44 <h007> i just add "deriving instance (Show a, Show (k (Tree k a))) => Show (Tree k a)" to the type def?
06:33:45 <merijn> h007: ok, then you'll have to write it by hand
06:34:01 <merijn> h007: No, you write that on a separate line
06:40:47 <vmalloc> Hey there, noob question regarding parsing JSON with lense - how can I elegantly extract a list of values from a nested structure in which a certain level is a list of objects? For instance - {"a": {"b": [{"field": 1}, {"field": 2}]}}, and I want to collect a list from the 'field' values so that I'll get [1, 2]
06:45:32 <danilo2> Hello! If I could I would love to ask you how would you do something liek that: I've got 2 maps : Map String X and Map String Y. I want to combine them to something like Map String (X, Maybe Y)
06:45:34 <h007> supki,merijn: it works, i needed to more extensions though: FlexibleContexts, UndecidableInstances
06:46:14 <supki> vmalloc: json ^.. key"a".key"b"._Array.folded.key"field"._Integer
06:47:30 <vmalloc> supki: Ooh...
06:47:48 <letrec> merijn: thx!
06:47:53 <vmalloc> supki: Just out of curiosity, where could I have found the answer (references?)
06:47:55 <skypers> danilo2: try a foldr on it
06:48:21 <merijn> vmalloc: #haskell-lens probably? :)
06:48:27 <supki> vmalloc: I don't know if there are good tutorials on lens-aeson
06:48:28 <skypers> or hm
06:48:37 <supki> it assumes you know lens
06:48:43 <nooodl> danilo2: combine mx my = Data.Map.mapWithKey (\k x -> (x, Data.Map.lookup k my)) mx
06:49:01 <skypers> fromList . zipWith yourMaybeFunction `on` toList
06:49:13 <skypers> danilo2: ^
06:49:25 <vmalloc> supki: awesome
06:49:40 <vmalloc> supki: thanks!
06:49:54 <supki> vmalloc: https://www.fpcomplete.com/user/tel/lens-aeson-traversals-prisms looks interesting
06:50:17 <danilo2> nooodl : interesting - I think I was looking for sometihng like mapWithKey. Thanks!
06:50:20 <skypers> oh that’s interesting, there’re minimum and maximum in Data.List, but no minmax
06:50:23 <skypers> like
06:50:28 <skypers> minmax :: [a] -> (a,a)
06:50:50 <h007> supki,merijn: do you know how to create a functor instance of such a type?
06:51:29 <danilo2> skypers: I'm always forgettig about the power of "on". noooodl's solution is nice also, thanks :)
06:51:38 <supki> h007: Functor instances can be derived with -XDeriveFunctor
06:51:53 <merijn> supki: Likely not here
06:52:11 <merijn> h007: "instance Functor k => Functor (Tree k) where ..."
06:52:16 <h007> how do i do if i want a custom one?
06:52:30 <danilo2> skypers: althought I think, nooodl's solution should be faster, because tolsit and fromlist will look for all elements in O(n), where mapWithKey should be accessing and writing in log(n)
06:52:47 <supki> merijn: works for me
06:52:51 <merijn> h007: That basically says that the "Functor (Tree k)" instance requires that k is a Functor, which you need to fmap inside the "k (Tree k a)"
06:52:58 <merijn> supki: Oh, in that case, score :)
06:53:34 <merijn> h007: Can't hurt to implement it yourself, looks like good practice :)
06:53:38 <skypers> @let minmax :: [a] -> (a,a); minmax [] = error ""; minmax l@(x:_) = foldl (\(mn,mx) x -> (min x mn,max x mx)) (x,x) l
06:53:39 <lambdabot>  .L.hs:152:29:
06:53:39 <lambdabot>      No instance for (Ord a) arising from a use of `min'
06:53:39 <lambdabot>      ...
06:53:49 <skypers> @let minmax :: (Ord a) => [a] -> (a,a); minmax [] = error ""; minmax l@(x:_) = foldl (\(mn,mx) x -> (min x mn,max x mx)) (x,x) l
06:53:51 <lambdabot>  Defined.
06:54:04 <skypers> minmax [1,2,8,2,86,-3,0]
06:54:07 <skypers> > minmax [1,2,8,2,86,-3,0]
06:54:09 <lambdabot>   (-3,86)
06:54:27 <skypers> that function should be in Data.List
06:55:30 <skypers> it’s better than let mn = minum x; mx = maximum x in (mn,mx)
06:55:57 <skypers> > maximum []
06:55:58 <lambdabot>   *Exception: Prelude.maximum: empty list
06:57:21 <merijn> The reverse dependency lookup lets you look for packages by package dependencies, is it possible to look for the use of specific modules?
06:59:11 <nomeata> skypers: but not with this implementation please. Or at least provide a strict minmax'
07:00:35 <exicer> Is there an introductory lens tutorial that anyone could reccommend ?
07:02:23 <skypers> yeah well
07:02:27 <skypers> minmax and minmax'
07:02:36 <skypers> I’m not sure it’s mandatory
07:02:39 <skypers> since you have sum
07:02:41 <skypers> and not sum'
07:04:09 <nomeata> we don’t have sum'? hmm, true. but at least sum is implemented as a right fold
07:04:45 <nomeata> so with the specializations for Int and Integer, the strictness analyzer will turn it into a strictly accumulating sum'
07:07:15 <skypers> nomeata: yeah
07:07:20 <skypers> then minmax can be right as foldr :)
07:07:52 <nomeata> did I say right fold? I meant left fold :-)
07:08:16 <nomeata> ah, and you have a left fold there. good :-)
07:08:38 <nomeata> I suggest to use foldl', you certainly want to evaluate the pair in your minmax function
07:08:55 <benzrf> hi, what imports do you recommend putting into my bot's haskell eval feature by default?
07:08:59 <benzrf> Control.Monad?
07:09:55 <nomeata> benzrf: System.IO.Unsafe :-)
07:10:03 <_jgr> Hi
07:10:04 <benzrf> hmm
07:10:07 <benzrf> ill do that then
07:10:07 <benj_> Data.Profunctor
07:10:18 <benzrf> benj_: what's a profunctor?
07:21:23 <vmalloc> supki: is there a way to obtain a list of tuples, grouping multiple fields for each object? Was looking for something like it in the lens documentation, but it's infinite...
07:27:11 <supki> vmalloc: not in any released version IIRC
07:27:45 <supki> vmalloc: in HEAD there is Getter/runGetter thing which lets to combine getters
07:28:27 <vmalloc> hmm
07:28:31 <supki> i.e. [(1,2,3),(4,5,6)] ^.. folded.(runGetter $ liftA2 (,) (Getter _1) (Getter _2)) => [(1,2),(4,5)]
07:29:25 <vmalloc> supki: ok, so if I can't use it and have to fetch multiple fields I have to parse the JSON twice? seems somewhat inefficient? or is there a way to partially "store" a lens so that I can save that part of the computation? (sorry for being totally noob here)
07:35:39 <supki> vmalloc: well, you can store parsed JSON somewhere, but you still have to traverse array twice I think
07:36:14 <vmalloc> Two traversals is less painful than reparsing...
07:37:02 <vmalloc> supki: only problem is that I can't figure out which part of the lens expression actually does the parsin... the input is a string...
07:39:15 <jorgno> Good day to all, I'm having some problems forcing evaluation in parallel. I have a list of lists containing a custom data type which is implements NFData (e.g. [[NFData]]) and I'm trying to use "runEval $ parList rdeepseq list" which my program just quickly jumps past, and even if i put something like "force" in front it won't do it in parallel, any suggestions?
07:43:21 <WhatIsMonad> So let's say I have a set of functions, they only perform one particular transformation, (a -> b), but each also maintains a "state" so to speak.  Each one takes this state parameter and returns a value of the same type.  So calling code doesn't care about the state parameter other than to maintain and pass it back in.  So basically the type of these things is "a -> b -> (a, c)".  Like I said, I have a set of
07:43:22 <WhatIsMonad>  these functions, which each have this useful "b -> c" computation, but each function has its own type of internal state.  So ideally I'd like some sort of abstraction that lets me express "[(a, (a -> b -> (a, c))]" except unfortunately "a" is different for each one, making it non-hemogounous.  One hack I could do is to have the function bound to an IORef of its state and then ahve the function return an IORef
07:43:22 <WhatIsMonad>  of c, which makes the functions homogonous by storing their state "internally" but that just feels terrible
07:46:39 <fizbin> WhatIsMonad: So... does every function use its own state?
07:47:04 <fizbin> That is, no two functions share state with each other?
07:47:18 <WhatIsMonad> fizbin:  Exactly
07:47:51 <fizbin> If so, perhaps would it be better to consider these functions as having some sort of recursive type, like:
07:48:02 <supki> vmalloc: the first  key  traversal parses the JSON
07:48:11 <fizbin> data Funky b c = b -> (c, Funky b c)
07:48:42 <supki> vmalloc: you can parse JSON explicitly with _JSON prism and store that somewhere
07:49:53 <fizbin> Then, even if "a" is different everywhere, if "b" and "c" are the same, all your functions now have the same type.
07:51:06 <WhatIsMonad> fizbin:  So basically, I have a functino which takes a state value, an input, and then returns an output along with a function of the same type.  And it returns the new function partially applied to the new state
07:51:09 <WhatIsMonad> That's really really cool
07:51:42 <fizbin> Well, yeah.
07:51:44 <snizzo> how can I make an happy parser rule to get just the first element (of a list divided by blanks) as the head, and children then?
07:51:54 <snizzo> without using blanks?
07:51:57 <WhatIsMonad> Thank you!  That's a cool thought
07:53:32 <WhatIsMonad> And then I suppose, if I did have functions which needed to "share" state, I could have them all in a record, and have functions take the record and return the record, so one function could also "modify" other functions in a similar manner
07:53:58 <fizbin> Sure.
07:57:26 <WhatIsMonad> then if I want a set of "methods grouped with data" ala OOP which is open for multiple implementations but allows each implementation to have its own data, all the read only methods are of type "Arguments -> Result" and all modification methods are of type "Arguments -> (Result, NewRecord)" and the implementation could just have a "mkRecord givenState" and the modification ones can modify the state and every method
07:57:26 <WhatIsMonad>  takes a state internally.  Never thought of using partial application in quite this manner but its seems like a powerful and clean idea
07:58:36 <merijn> WhatIsMonad: That's a very common way to do it
07:59:59 <WhatIsMonad> I have some very messy code to clean-up haha.  I've done enough first-class-function style programming that haskell wasn't completely foreign to me, but I'm realizing some of it is still an extremely different way of thinking (which I'm sure I'll be noticing for years)
08:00:40 <overx> hey :)
08:01:03 <overx> I need help to resolve a problem with dependences
08:01:21 <overx> anyone?
08:01:50 <heatsink> go ahead and ask a question
08:02:26 <overx> well i'm trying to install Network
08:02:31 <mauke> overx: anyone what?
08:03:08 <overx> but cabal throws me: Resolving dependencies... cabal: cannot configure deepseq-1.3.0.2. It requires base >=4.3 && <4.8
08:03:33 <heatsink> What version of base is installed?  ghc-pkg list shows that
08:03:59 <heatsink> The 'base' package comes with ghc, so you can't change that unless you install a different ghc version
08:04:28 <overx> ok, what version is recommended to install easily Network?
08:04:29 * heath waves good morning
08:04:38 <mauke> overx: why don't you already have Network?
08:05:07 <dcoutts> overx: what version of ghc are you using?
08:05:35 <overx> 6.10.3
08:05:47 <mauke> ooh, ancient
08:06:09 <overx> before i have 7.6.3 and it gives me the same error
08:06:24 <dcoutts> overx: ok, so it's fine to use a really old ghc, but you'll have to pick libs that go with it, which means old ones.
08:06:54 <dcoutts> overx: in particular, network-2.4.0.1 works with ghc-6.10
08:07:13 <dcoutts> with deepseq-1.3.0.0
08:07:52 <dcoutts> overx: though you ought to have a good reason to choose to use such an old ghc. If you don't care then just pick the latest haskell platform version.
08:07:57 <overx> ouh
08:08:01 <overx> it works
08:08:07 <hvr> overx: fyi, deepseq-1.3.0.2 effectively requires GHC >= 7.0
08:08:24 <overx> with this version it is not necessary to install Network
08:08:28 * hackagebot palette 0.1.0.0 - Utilities for choosing and creating color schemes.  http://hackage.haskell.org/package/palette-0.1.0.0 (jeffreyrosenbluth)
08:08:37 <overx> ghc comes with it?
08:08:55 <dcoutts> overx: the Haskell Platform comes with ghc and a bundle of standard libs, including network
08:09:12 <overx> okey dcoutts
08:09:19 <overx> thank you for all
08:18:42 <RoryHughes> What is haskell?
08:19:37 <RoryHughes> Iv'e heard it's not even real...
08:20:38 <fizbin> RoryHughes: Go to www.haskell.org. Read.
08:31:38 <mangaba_leitosa> fizbin: but does haskell.org even address the problem of Haskell being real?
08:33:03 <cariveri> hi. whats the right function for:f:[X] -> [Y] when having a g:X -> Y ?
08:33:11 <fizbin> map?
08:33:16 <nicoo> cariveri: map
08:33:17 <merijn> mangaba_leitosa: Can programming languages even be realy?
08:33:32 <nicoo> merijn: real*
08:33:46 <merijn> mangaba_leitosa: What does real even mean? Who am I? What is this?
08:33:50 <companion_cube> I thought Haskell was complex
08:33:51 <cariveri> oh I forgot to say g:X -> IO Y
08:34:01 <nicoo> mangaba_leitosa: Haskell is as real as C. Which is to say, not at all ; language is but an artificial construction of the mind
08:34:05 <fizbin> Oh. You want mapM
08:34:10 <fizbin> :t mapM
08:34:12 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
08:34:40 <cariveri> oh cool ! thanks. I guess thats it.
08:35:13 <fizbin> If you don't really need the resulting list, there's also mapM_
08:35:17 <fizbin> :t mapM_
08:35:18 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
08:35:46 <mangaba_leitosa> merijn: I didn't say that I knew the answers :_)
08:35:51 <nicoo> fizbin: It is strang to call this one map, by the way :]
08:36:09 <nicoo> companion_cube: Bad pun spotted, btw
08:36:20 <companion_cube> ;)
08:36:34 <cariveri> fizbin: I need the result.
08:38:08 <mangaba_leitosa> nicoo: is English even real? :-)
08:38:25 <fizbin> "What is truth?"
08:38:27 <nicoo> mangaba_leitosa: English is a language. It isn't real.
08:39:32 <mangaba_leitosa> nicoo: ok, so, English is imaginary, right?
08:41:16 <mangaba_leitosa> nicoo: are Ancient Greek or Latin real? If they are imaginary, why study them instead of imagining a new one? :-)
08:42:17 <merijn> ow, doing pipes type signatures in your head hurts >.>
08:42:27 <scriptor> because they're imaginary to a lot of people already
08:42:44 <snizzo> what would you suggest for writing a simple lexer/parser in haskell?
08:43:03 <merijn> snizzo: Parsec/attoparsec, depending on whether you're parsing text or binary data
08:43:12 <fizbin> uuparsing is also pretty nice.
08:43:38 <merijn> edwardk has a parsing library too, so supposedly that's the most featureful and correct one, but I've never used trifecta :p
08:44:59 <nicoo> mangaba_leitosa: English, Greek (ancient or modern) and Latin are all imaginary, yes (for the notion of reality I picked). Their value lie in the belief that we agree on their semantics
08:45:14 <nicoo> s/agree/sometimes agree/
08:45:23 <snizzo> merijn: My aim is to parse config files, not languages :)
08:45:49 <mangaba_leitosa> nicoo: what about the distinction between artificial and natural languages then? :-)
08:46:06 <mangaba_leitosa> nicoo: if any language is an artificial construction of the mind :-)
08:46:35 <mangaba_leitosa> nicoo: also, live languages and dead languages :-)
08:47:19 <mangaba_leitosa> nicoo: maybe we should also consider the problem of determining whether Haskell is live :-)
08:47:35 <nicoo> mangaba_leitosa: “Natural” languages are those who were not designed from the ground up by a single person (or a small comitee). I believe that it is mostly a problem of design timescale
08:47:55 <companion_cube> most 'artificieal' languages aren't either
08:48:01 <companion_cube> -e
08:48:04 <merijn> snizzo: I would use parsec for config files too, it's pretty easy
08:48:16 <companion_cube> unless you think php is "designed" :p
08:48:26 <nicoo> companion_cube: Ruby is a good exemple of organic growth, yes
08:48:29 <nicoo> Damn, too slow
08:48:42 <nicoo> companion_cube: Thankfully, it is troll-day
08:48:54 <haasn> supki: oh, thanks for that! I was thinking about how to do that best the other day, ReifiedGetter is perfect
08:49:03 <haasn> what else can we reify? folds?
08:49:05 <dwcook> PHP evolved; after all, it couldn't have been intelligently designed.
08:49:20 <mangaba_leitosa> nicoo: makes sense, but e. g. interlingua (http://en.wikipedia.org/wiki/Interlingua) is created by a associaction of persons :-)
08:49:38 <haasn> ah yeah, ReifiedFold gives us monadplus too
08:49:43 <mangaba_leitosa> nicoo: but you mentioned a small comitee
08:49:48 <fizbin> dwcook: "evolved" vs. "intelligently designed" are not the only two possibilities.
08:50:05 <dwcook> fizbin, I know, it was a joke.
08:50:21 <nicoo> dwcook: It could have been planted on Earth by mischevious aliens to confuse the hell out of us.
08:50:21 <mangaba_leitosa> nicoo: very foresighted of you :-)
08:50:26 <geekosaur> natural stupidity trumps artificial intelligence?
08:51:46 <nicoo> mangaba_leitosa: Yeah. Probably an accident, foresight doesn't sound like me.
08:51:52 <mangaba_leitosa> nicoo: :_)
09:08:58 <overx> hey
09:09:05 <overx> I have other doubt
09:09:46 <overx> how can I specify HostAddress (IPv4) by Word32
09:09:48 <overx> ?
09:11:16 <overx> I want something like this: a <- connect h (SockAddrInet 6667 "174.143.119.91")
09:11:59 <mauke> connectTo "174.143.119.91" (PortNumber 6667)
09:12:03 <nomeata> With unboxed tuples, a higher order function like foldl could have an argument of "a -> b -> (# a #)" and this way the inner function can decide whether it wants to be strict or lazy
09:12:15 <nomeata> this would avoid having separate ' versions of higher order functions
09:12:26 <nomeata> is that right?
09:13:00 <overx> in what module is there connectTo?
09:13:27 <mauke> Network
09:13:37 * hackagebot palette 0.1.0.1 - Utilities for choosing and creating color schemes.  http://hackage.haskell.org/package/palette-0.1.0.1 (jeffreyrosenbluth)
09:14:12 <overx> i'm trying with Network.Socket
09:14:38 <mauke> why?
09:14:42 <overx> there are any difference?
09:14:45 <mauke> yes
09:14:52 <overx> ah ok
09:15:02 <overx> i'm going to look for Network only
09:16:24 <pavonia> overx: perhaps you're looking for inet_addr
09:19:42 <overx> ok now there aren't errors
09:19:44 <overx> a <- recvFrom "irc.freenode.net" (PortNumber 6667)
09:19:55 <overx> but it doesn't receive data
09:20:11 <pavonia> Don't use PortNumber
09:20:26 <monochrom> why are you using recvFrom?
09:20:34 <mauke> pavonia: ?
09:21:31 <pavonia> mauke: IIRC, the constructor PortNumber uses another bit oorder than the Num instance
09:21:42 <mauke> pavonia: what Num instance?
09:22:05 <pavonia> Num PortNumber
09:22:24 <mauke> what's PortNumber?
09:22:39 <pavonia> Are you kidding me?
09:22:45 <overx> xD
09:22:58 <mauke> pavonia: no, but you've confused yourself
09:23:10 <mauke> 'PortNumber 6667' does not use the type PortNumber
09:23:11 <pavonia> Why?
09:23:21 <overx> what can I use?
09:23:23 <mauke> PortNumber is a data constructor here
09:23:30 <mauke> overx: well, what are you trying to do?
09:23:47 <RenRenJuan> not knowing if an interlocutor is kidding or not is awkward
09:23:53 <pavonia> mauke: What type is that then?
09:24:01 <mauke> PortID
09:24:03 <overx> i'm trying connecting to irc
09:24:12 <mauke> overx: so why not use connectTo?
09:24:28 <overx> yes
09:24:34 <overx> before of recvFrom
09:24:36 <pavonia> Oh, okay. I meant "don't use PortNum", sorry
09:24:44 <mauke> wat
09:24:49 <monochrom> recvFrom has nothing to do with connectTo
09:24:58 <mauke> you don't seem to understand how network connections work
09:25:02 <overx> no
09:25:05 <overx> in haskell no
09:25:19 <mauke> not in haskell. I mean in general
09:25:44 <overx> i'm get used to work with sockets in java and python
09:26:00 <overx> haskell confuse me
09:26:07 <mauke> haskell is the same
09:26:33 <overx> if you say that recvFrom has nothing to do with connectTo is not the same
09:26:58 <overx> all the times is necessary connect with host first
09:27:08 <overx> it's*
09:27:11 <mauke> yes
09:27:18 <mauke> and that's what connectTo does
09:27:39 <overx> for this reason recvFrom needs connectTo xD
09:27:41 <mauke> recvFrom, on the other hand, creates a listening socket, waits for an incoming connection, reads everything sent to it, and returns it as a string
09:27:47 <mauke> no
09:27:52 <mauke> you don't want a listening socket
09:27:54 <merijn> overx: No, recvFrom has nothing to do with connectTo
09:28:01 <overx> ah ok
09:28:05 <merijn> overx: connectTo already returns a file handle you can read from
09:28:10 <overx> i don't understand well that function
09:28:19 <overx> you are absolutely right
09:28:44 <monochrom> the haskell story is pretty much like the java story, actually.
09:29:24 <monochrom> when you were attempting "connect" and HostAddress and SockInAddr etc, you were doing the C story, not the java story.
09:30:33 <overx> one i am connected how can i work with Handler?
09:30:39 <overx> once*
09:30:55 <mauke> hPutStr, hGetLine
09:31:27 <monochrom> whereas the java story goes like: connect, get an InputStream, now simply use ordinary InputStream methods in java.lang...
09:31:53 <monochrom> the haskell story goes similarly: connectTo, get a Handle, now simply use ordinary Handle functions in System.IO
09:32:08 <overx> you're very good
09:32:16 <overx> haskell has got a good community
09:32:19 <overx> :D
09:32:44 <monochrom> the most bloody important commonality is that you don't bloody use "network-specific" read/write. you use ordinary read/write. it's just a Handle. or InputStream.
09:33:19 <mauke> just like C!
09:33:28 <mauke> dohoho
09:33:47 <monochrom> well, the C story is different at connection time
09:34:33 <mauke> sadly
09:34:55 <overx> I started with haskell this year at university
09:35:02 <overx> it's a interesting language
09:39:44 <donri> overx: btw there are libraries for irc. or maybe you're doing it for fun and learning.
09:39:56 <overx> i'm doing it for learning
09:40:10 <donri> no fun then? :)
09:40:40 <overx> haha
09:40:53 <overx> it's clear xD
09:48:31 <merijn> monochrom: Not if you use a proper OS like Plan9! :D
09:49:41 <monochrom> I guess it is a unix story rather than a C story
09:54:09 <cariveri> hello again:) How would you guys suggest to handle duplicate data structures? like in "data I = A{same}|B{same}|C{same}|D{differs}". would you translate it to  "data I = S{same,Itype}|D{differs}" ?
09:54:49 <cariveri> in java one would inherit things.
09:55:09 <cschneid> cariveri: you could make {same} a type in its own right
09:55:27 <cschneid> data Same = Same Int Int Int;  data I = A Same | B Same | C Same
09:55:45 <monochrom> sometimes I translate. sometimes I don't. but I never inherit.
09:55:58 <cschneid> it's a shared concept, so you can probably come up with a reasonable name.
09:56:50 <stolaruk> I'm having a hard time understanding how (++) can be inefficient. (++) is right associative, so that "a" ++ "b" ++ "c" ++ "d" is the same as "a" ++ ("b" ++ ("c" ++ "d")) ...
09:56:52 <monochrom> note that "data I = A {ix :: Int} | B {ix :: Int} | C {ix :: Int} | D {ib :: Bool}" is totally valid.
09:56:59 <stolaruk> So, ("c" ++ "d") is evaluated first. Then we have ("b" ++ "cd") and then "a" ++ "bcd", right?
09:56:59 <reasonable> cschneid: Sorry, I already came up with it! :-P
09:57:12 <stolaruk> It's not like the left side of an inner (++) is re-evaluated by an outer (++). Where is the inefficiency?
09:57:35 <cariveri> monochrom: what do you mean totally valid? reasonable to do?
09:57:48 <monochrom> it is legal
09:58:24 <cschneid> and reasonable imo - clarity is best :) if it's clearer to make a new type, do that. If not, don't...
09:58:43 * hackagebot scotty 0.6.0 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.6.0 (AndrewFarmer)
09:58:47 <monochrom> stolaruk, "c"++"d" is not evaluated first. instead, apply lazy evaluation to see what happens to head ("a"++("b"++("c"++"d")))
09:58:47 <donri> stolaruk: what if you have [1..99] ++ [100]?
09:59:01 <simpson> stolaruk: 'c':[] ++ 'd':[] is 'c':'d':[]
09:59:12 <simpson> A new list is created every time; the list spines can't be reused.
09:59:47 <cariveri> ok thanks. Ill try to make it a data of its own right and see what the actuall patternmatching looks like then.
10:00:24 <stolaruk> > head ("a"++("b"++("c"++undefined)))
10:00:25 <lambdabot>   'a'
10:00:25 <monochrom> "a"++("b"++("c"++"d"))) is still best under eager evaluation, but the reason is different
10:00:42 <stolaruk> Wow, interesting.
10:01:05 <stolaruk> > [1..10] ++ [11]
10:01:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
10:01:56 <stolaruk> That feels counterintuitive given the parens.
10:02:26 <monochrom> does it?
10:02:47 <monochrom> has parentheses ever really meant "evaluate first", not merely "parse first"?
10:02:49 <c_wraith> stolaruk: first thing to learn about lazy evaluation - functions happen first, not the data they are applied to
10:02:50 <ion> If you eagerly evaluate "c"++"d", then appending a single character to front is just a matter of adding a single cons.
10:03:13 <monochrom> 0 * (12983 + 39383)  do you really, honestly, evaluate 12983 + 39383 first?
10:03:14 <ion> s/appending/inserting/
10:03:26 <c_wraith> prepending
10:03:31 <stolaruk> monochrom: I would think that a computer would
10:03:43 * hackagebot wai-middleware-static 0.4.0 - WAI middleware that intercepts requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.4.0 (AndrewFarmer)
10:03:45 * hackagebot wai-middleware-static 0.4.0.1 - WAI middleware that intercepts requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.4.0.1 (AndrewFarmer)
10:03:46 <monochrom> "if False then 0 else (12983 + 39383)" do you evaluate 12983 + 39383 first?
10:04:17 <monochrom> err oops, wrong example
10:04:18 <stolaruk> monochrom: In that case the if would short circuit, that seems intuitive
10:04:23 <ion> “if…then…else…” doesn’t tend to evaluate the branches eagerly in eagerly evaluated languages.
10:04:34 <monochrom> "if True then 0 else (12983 + 39383)" do you evaluate 12983 + 39383 first?  "1 : 0 ? (12983 + 39383)"?
10:05:10 <monochrom> ok, if you believe short-circuiting, then consider lazy evaluation to include some short-circuiting
10:05:33 <stolaruk> Ok, makes sense
10:06:20 <c_wraith> the thing that I found really important to understanding lazy evaluation was thinking in terms of when constructors get pattern-matched.
10:06:55 <c_wraith> Because pattern-matching a constructor is what allows lazy evaluation to pause and previous control-flow to resume.
10:07:04 <monochrom> in 0 * (12983 + 39383), in Haskell, for the type Int, the computer does evaluate 12983 + 39383 first. but I did not ask about the computer. I was asking about you. *you*.
10:07:35 <c_wraith> monochrom: Actually, that's implementation-dependent.  the computer might evaluate 0 first.
10:07:39 <monochrom> I am trying to make you unlearn the highschool story "evaluate parentheses first".
10:07:49 <monochrom> yes, that too
10:08:31 <monochrom> the correct story is "parse first". but they don't want to teach you a separate parsing story. so they merge parsing with evaluation for a shorter story.
10:08:49 <overx> lazy evaluation man
10:08:50 <mauke> they taught me parsing, sort of
10:08:51 <stolaruk> I see.
10:08:53 <overx> more extern redex
10:08:57 <mauke> we drew expression trees
10:09:07 <begriffs> Anyone run into an issue where cabal install picks old versions of packages unless you explicitly specify new versions in your cabal file?
10:09:50 <mauke> and we learned how to say expressions: "2 * (3 + 4) is the product of 2 and the sum of 3 and 4"
10:12:51 <sdrodge> edwardk: Would trifecta be a good tool that might allow for vertical alignment of argument patterns (regex does not seem powerful enough given the possibility of nested parens) when editing Haskell code in vim?
10:12:58 <overx> how can I keep permanently a client with connecTo?
10:13:18 <overx> Have I explained myself clear enough?
10:18:31 <edwardk> sdrodge: its turing complete, so you can do it there ;)
10:21:13 <Jack99> Hi,
10:21:23 <Jack99> I've got a problem with writing a generator for unbalanced trees
10:21:33 <Jack99> I managed to write on for balanced trees
10:21:41 <Jack99> for the unbalanced one, I thought I could use "frequency"
10:21:53 <Jack99> Here is the lpaste: http://lpaste.net/7204738786419277824
10:21:58 <Jack99> it includes the error message as well
10:22:12 <Jack99> I'd appreciate your help.
10:26:34 <pavonia> Jack99: I think you're missing a comma in line 23
10:28:51 <Jack99> pavonia: You're right! I was so fixated on the error message that I missed that
10:30:28 <joelteon> What datastructure should I use to store a bunch of strings, then filter out the ones that contain a certain character?
10:31:07 <carminemlt> set password
10:31:12 <trolling> joelteon: [String]? :)
10:31:19 <joelteon> ok
10:31:24 <joelteon> anything more efficient
10:31:32 <intrados> Does it make sense that when working with datakinds, I get a parse error on pasting in GHCs suggested type signature?
10:31:34 <trolling> how big are your strings
10:31:40 <joelteon> not more than 15 characters
10:31:52 <trolling> [String] should serve your needs pretty reasonably
10:31:56 <joelteon> ok
10:32:04 <joelteon> not bytestring or text or anything, just string?
10:32:07 <haasn> intrados: can you paste the type signature?
10:32:15 <trolling> you could use [Text] if you were so inclined
10:32:23 <trolling> personally I probably wouldn't bother with data that short
10:33:00 <intrados> haasn: It's a pretty baroque signature (from unittyped) but I can put something on lpaste in a second.
10:33:21 <Jack99> OK, I now fixed the code at http://lpaste.net/7204738786419277824
10:33:31 <Jack99> one more question: as you'll see there is some repetitionh
10:34:07 <Jack99> but if I define a 'where' clause like, "select = frequency [(1, (sizedArbNTree 0)),    (9, (sizedArbNTree (n-1)))]"
10:34:18 <Jack99> then I'm using the same result in both call, aren't I?
10:34:27 <Jack99> If so, what is a good workaround for that?
10:34:46 <Jack99> (I mean, a workaround that avoids copy/paste programming like in my sample code)
10:35:14 <Jack99> http://lpaste.net/7204738786419277824
10:36:07 <overx> Someone knows what problem are here:
10:36:37 <overx> http://pastebin.com/RTV3GfPv
10:36:42 <mauke> The paste RTV3GfPv has been copied to http://lpaste.net/96651
10:37:29 <overx> ouh it's a simple error sorry
10:37:29 <overx> xD
10:37:33 <intrados> haasn: http://lpaste.net/96652
10:38:19 <haasn> intrados: I think you need to remove the kind annotations (*)
10:38:31 <haasn> GHC likes to append those for polykinded types but it's a syntax error
10:38:48 * hackagebot pretty-show 1.6.2 - Tools for working with derived `Show` instances and generic  inspection of values.  http://hackage.haskell.org/package/pretty-show-1.6.2 (IavorDiatchki)
10:39:01 <fizbin> @check x + 99 < 21 * x - x*x
10:39:03 <lambdabot>   *** Failed! Falsifiable (after 1 test):
10:39:11 <intrados> haasn: What sorts of things can replace them?
10:39:21 <haasn> [(,) Number] -- looks like a type error one way or the other
10:39:36 <haasn> maybe that isn't a kind annotation after all? I'm unsure
10:39:45 <haasn> s/type error/kind error/
10:40:13 <haasn> intrados: but I can also urge you to look at http://hub.darcs.net/nand/units ;)
10:40:15 <ion> >
10:40:21 <haasn> no guarantees about having a cleaner API but at least I can help you figure out type errors :)
10:40:26 <haasn> (assuming you get it to build)
10:40:32 <fizbin> @check x + 99 >= 21 * x - x*x
10:40:33 <lambdabot>   +++ OK, passed 1 tests.
10:40:39 <ion> > let foo = x + 99; bar = 21 * x - x*x in (foo < bar, foo == bar, foo > bar)
10:40:40 <lambdabot>   (False,False,True)
10:41:03 <haasn> > x <= x
10:41:04 <lambdabot>   True
10:41:11 <fizbin> > let x = 10 in x + 99 >= 21 * x - x*x
10:41:12 <lambdabot>   False
10:41:15 <haasn> > 2*x > x
10:41:16 <lambdabot>   False
10:41:30 <haasn> > 2*x <= x
10:41:31 <lambdabot>   True
10:41:51 <FreeFull> :t x
10:41:52 <lambdabot> Expr
10:42:00 <FreeFull> > x == x
10:42:01 <lambdabot>   True
10:42:04 <FreeFull> > x <= x
10:42:05 <lambdabot>   True
10:42:09 <ion> > x == var "x"
10:42:10 <lambdabot>   True
10:42:13 <fizbin> > map (\x -> (x, x + 99 >= 21 * x - x*x)) [7..12]
10:42:14 <lambdabot>   [(7,True),(8,True),(9,True),(10,False),(11,True),(12,True)]
10:42:21 <nurupo> i'm having a hard time parsing an input of http://waa.ai/65K could someone help me?
10:43:07 <nurupo> that's what i have right now https://gist.github.com/nurupo/5204b6a50ce86ceac1ed
10:44:16 <nurupo> the problem is that the program terminates after the first line of input
10:44:54 <haasn> > map (\x -> (x, 99 >= 20 * x - x*x)) [7..12]
10:44:55 <lambdabot>   [(7,True),(8,True),(9,True),(10,False),(11,True),(12,True)]
10:46:09 <nurupo> and i'm not sure on how to get IntererOnLine1 lines of input to construct the QuadTree data structure by using interact
10:46:19 <intrados> haasn: Thanks for the pointer to 'units'; I'll look into it. In the meantime though, I'd like to try to understand the problem with the current type signature. I think the '*' is 'kind'. I also get parse errors on (':), for example. Is that syntax deprecated in favor of the sugared list notation?
10:47:24 <haasn> intrados: ': should certainly work but right now I'm getting parse errors on '(:) and (':) too
10:47:31 <haasn> I remember being confronted with this a while ago
10:47:59 <heath> if an an object within the collection matches the object being edited, replace the existing object with the new object, e.g. collection: [ {id: 1, data: "foo"}], existing_object: {id: 1, data: "bar"} -- Is there a function within the prelude which would be ideal for this scenario?
10:49:47 <donri> haasn, intrados: do you have -XTypeOperators?
10:49:53 <intrados> donri: Yes
10:50:11 <haasn> intrados: probably some underlying ambiguity with the grammar somewhere, looks like you just need to use ':  to work around it
10:50:13 <donri> i don't see it in your paste
10:50:15 <haasn> or even better, sugared list notation
10:50:45 <intrados> donri: Yeah. I added it when actually pasting the type signature
10:51:11 <haasn> I'm more thrown off by the (,) thing
10:53:22 <fizbin> @check 99 + x*x >= 20 * x
10:53:23 <lambdabot>   +++ OK, passed 1 tests.
10:53:54 <donri> haasn: those are kind signatures, aren't they?
10:54:21 <haasn> donri: yeah
10:55:22 <donri> haasn: so what's the problem? :)
10:55:53 <donri> presumably it's something like, '['(a,Zero)] :: [(*,Number)]
10:56:25 <donri> intrados: did you enable KindSignatures?
10:57:02 <intrados> donri: I just did. Still get parse error on :
10:57:25 <donri> intrados: it should be ':
10:57:41 <trolling> w 32
10:58:03 <intrados> The character it's throwing the error on is : in ((':) ...
10:59:06 <haasn> donri: yeah you're right, I just realized how hard it is to debug kind signatures in GHCi
10:59:09 <donri> intrados: ok well it's quite conceivable there's a parsing bug there. the pretty-printer is a separate thing. have you tried translating it to infix?
10:59:18 <haasn> donri: '[ '(a,Zero)]
10:59:22 <intrados> donri: Yes. Without much success
10:59:22 <haasn> donri: I think '['( is a problem
11:00:47 <intrados> I mean, it gets rid of the parse errors but there still seem to be other errors
11:00:56 <donri> aha, getting parsed as a Char literal or something?
11:01:16 <donri> intrados: well the question was about parse errors ;) new question?
11:02:49 <intrados> Well, there are puts during the translation where I can't just do it mechanically
11:03:13 <intrados> donri: Like, I'm not sure how to make sense of ('(,) * Number b Pone)
11:04:00 <donri> intrados: yeah it's a mess. * and b are the kinds and not part of the type signature
11:04:00 <niteria> @pl \a -> (a, a)
11:04:00 <lambdabot> join (,)
11:04:03 <haasn> what's the schedule for 7.8 like?
11:04:35 <haasn> intrados: you should be able to leave off the kind annotations and have them inferred
11:04:50 <haasn> (I'm talking about the ones that occur after eg. forall (a :: ...)
11:05:02 <hiawatha> Can we use haskell with a web framework or for web dev ?
11:05:07 <haasn> hiawatha: yes
11:05:12 <donri> intrados: '(Number,Pone) :: (*,b)
11:05:18 <hiawatha> haasn, how./
11:05:28 <donri> @where web
11:05:28 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
11:05:34 <donri> bbl
11:05:43 <haasn> donri: oh, that's handy
11:05:59 <haasn> hiawatha: I think yesod is the most popular, you might as well have a look at it first
11:06:23 <intrados> So does ((,) * Number) become '(Number, a) :: (*, b) or something?
11:06:38 <hiawatha> is this lang good as your first lang ?
11:06:43 <c_wraith> yeah, the type printer in recent GHC can produce output that isn't remotely correct
11:07:41 <c_wraith> hiawatha: yeah, it's a pretty good language for all sorts of stuff.  Learning to program is one thing it's decently good for.
11:07:48 <fizbin> hiawatha: Wait, first programming language?
11:07:49 <haasn> hiawatha: in my heavily biased opinion, sure; as long as you have proper introductions :)
11:08:21 <hiawatha> ok
11:08:23 <nurupo> can someone help me parsing input with interact?
11:08:24 <haasn> there are some “simpler” variants like Helium that aim to make it more newcomer-friendly by omitting eg. type classes and making error messages more welcoming, but I personally think those can be worked around
11:08:27 <hiawatha> fizbin, yep first
11:08:41 <hiawatha> helium huh
11:09:36 <nurupo> i'm new with haskell and pretty much stuck as of now
11:09:52 <haasn> :t interact
11:09:53 <lambdabot> (String -> String) -> IO ()
11:09:59 <haasn> nurupo: what exactly do you want to achieve?
11:10:16 <haasn> unrelated: does anybody know how much integration yesod has for client-side development via ghcjs yet?
11:10:25 <haasn> what about any of the other web frameworks?
11:10:28 <hiawatha> nurupo, oh what did you try before?
11:10:45 <haasn> ooh ooh ooh ooh
11:11:00 <nurupo> haasn: i'm trying to parse input of http://waa.ai/65K, that's what i got so far https://gist.github.com/nurupo/5204b6a50ce86ceac1ed
11:11:11 <c_wraith> haasn: I don't think any of them have much integration with ghcjs yet, since it isn't really released yet.  (At least, not in a form that's easy to use)
11:11:46 <haasn> I have an idea: implement a websockets backend for distributed-process and compile two cloud haskell clients, one for the server side and one for the client side
11:12:11 <c_wraith> If you could get that working cleanly, it'd be really slick.
11:13:01 <luite_> haasn: not much work yet, but there is some interest in this kind of thing yeah (also from me)
11:13:34 <luite_> cloud haskell is a bit limited though, in that you always do top level calls, you can't serialize closures
11:13:56 <nurupo> hiawatha: ^
11:14:04 <luite_> with ghcjs you can, so you could move some calculation to a web worker
11:14:39 <haasn> nurupo: (I can't load your first link) are you just looking to process each line individually, producing a String of output for each?
11:14:44 <luite_> (or even remote, but the serialization is ghcjs-specific)
11:15:00 <nurupo> haasn: the link is http://cs.fit.edu/~ryan/cse4250/quad.html
11:15:19 <luite_> haasn: got any application in mind for this?
11:15:22 <haasn> nurupo: it looks to me like ‘interact’ is the wrong approach here
11:15:39 <haasn> luite_: nope; I just thought it'd be a cool way to have client side code communicate with a web side backend in an interactive fashion
11:15:45 <c_wraith> has cdsmith been active recently?
11:15:47 <haasn> luite_: eg. whenever you click on an element that requires interactivity
11:16:38 <luite_> haasn: right
11:16:39 <nurupo> haasn: even so, i have to parse the input with interact, it's one of requirements
11:17:10 <nurupo> right now, with the code i posted, the problem is that the program terminates after the first line of input
11:17:26 <nurupo> also, i'm not sure on how to get next IntererOnLine1 lines of input to construct the QuadTree data structure by using interact
11:18:20 <luite_> haasn: i guess i should try to compile a simple demo for this, when ghcjs is released to hackage, so people have a good starting point
11:19:15 <luite_> shouldn't be too hard, probably :)
11:20:01 <haasn> luite_: also, I thought sending closures over the wire was one of the main points of distributed-process
11:20:04 <luite_> but first i need to fix some rts and compiler bugs, haven't been doing much ghcjs dev for a month, so i need to catch up a bit, make sure that everything is stable :)
11:20:25 <haasn> doesn't it assign a unique idetnfier to every function, and then serialize that identifier along with its (serializable, as a requirement) arguments?
11:20:32 <haasn> to send a closure
11:21:20 <luite_> haasn: yeah it's top-level function plus arguments, but you can't send something that closes over arbitrary (free) vars
11:21:43 <luite_> you need ghc eden or similar for that
11:22:06 <luite_> unless they extended cloud haskell and ghc recently for this :)
11:22:09 <haasn> nurupo: well, you already have the rest of the lines as ‘rest’, so you can just use “take (read x) rest” to get the next X lines as a list; map further functions over it to get the individual integers and stuff
11:22:20 <haasn> and implement whatever logic you want to implement based on that
11:22:31 <luite_> (in that case, ghcjs should probably add support for converting the closure format)
11:23:00 <nurupo> haasn: thanks, will try doing that
11:23:18 <luite_> the latest ghcjs doesn't rely on js closures anymore, so it's theoretically possible to support all this :)
11:23:36 <luite_> (js closures are opaque, so they make serialization from within js itself impossible)
11:24:06 <haasn> nurupo: if your calculation function looks something like g :: [Input] -> Output then you can recurse like  f (x:xs) = g input : f rest where (input, rest) = splitAt (read x) xs -- to split the remaining lines in half
11:24:12 <nurupo> haasn: it's just my first haskell code, so i'm kind of confused of how to start :) will say if i will get stuck again
11:24:14 <haasn> and you'll get a list of the results for each block
11:25:03 <haasn> might as well replace ‘Input’ and ‘Output’ by String in my example, for clarity
11:25:04 <luite_> anyway,
11:25:14 <luite_> <- back to work on ghcjs, finally, again :)
11:25:26 <fryguybob> luite_: :D
11:25:36 <luite_> hey fryguybob
11:25:39 <heatsink> Wait, there's an easy way to serialize closures?
11:25:44 <haasn> luite_: sounds cool :)
11:27:46 <luite_> heatsink: with ghcjs there is, with ghc it's a bit harder
11:28:34 <luite_> heatsink: although there are primops for that
11:28:40 <luite_> not sure if they work in regular ghc
11:29:13 <heatsink> It would be a useful thing to have
11:29:40 <heatsink> The Control.Distributed stuff is hard to work with
11:31:04 <luite_> at any rate they'd be somewhat risky to work with, you need to have exactly the same compiled code for deserializing them
11:32:25 <heatsink> I've run into issues where polymorphic functions don't instantiate like you'd expect
11:32:47 <heatsink> so code appears well-typed, but it crashes
11:33:13 <heatsink> because a polymorphic function gets serialized at the wrong type
11:42:38 <carminemlt> Hi everyone. I'm trying to wrap my head around functor concept from Typeclassopedia. I am confused about ((,) e) and ((->) e).
11:43:17 <roconnor> ((,) e)  means (e, ??)  and ((->) e)  means (e -> ??)
11:43:36 <carminemlt> roconnor: (e, ??) as in a tuple, right?
11:43:42 <roconnor> yes as a pair
11:43:47 <carminemlt> ok
11:43:52 <ion> let f = (e,): fmap :: (a -> b) -> (e, a) -> (e, b)
11:44:06 <ion> let f = (e ->): fmap :: (a -> b) -> (e -> a) -> e -> b
11:44:21 <carminemlt> reasoning about (e -> ??) I ended up with something that resembles (.)
11:44:29 <ion> Bingo
11:44:29 <roconnor> carminemlt: that is the correct answer.
11:44:30 <carminemlt> ion: exactly
11:44:51 <shachaf> Mapping over the result of a function is like composing a function to it.
11:44:53 <mauke> > (sqrt `fmap` (+1)) 1
11:44:54 <lambdabot>   1.4142135623730951
11:45:27 <tomejaguar> can I tell "cabal install" to install a particular version of a package?
11:45:39 <ion> cabal install packagename-packageversion
11:45:59 <tomejaguar> Ah that was easy.  Thanks!
11:46:03 <carminemlt> ok, thanks for your help!
11:46:11 <roconnor> carminemlt: any time
11:46:22 <ion> carminemlt: This may or may not be helpful: http://heh.fi/haskell/functors/#function-instance
11:47:55 <carminemlt> ion: will surely take a look. I'm coming from "Craft of functional programming" which left me in a limbo and with a lots of "?" about functors, monads, arrows & co. So any help and/or pointer is appreciated. Thanks
11:48:08 <ion> carminemlt: Have you read LYAH?
11:48:10 <ion> @where lyah
11:48:10 <lambdabot> http://www.learnyouahaskell.com/
11:48:53 <carminemlt> ion: not yet, but it's in my wishlist
11:49:05 <ion> carminemlt: You can read it for free online.
11:49:07 <shachaf> Mapping over the input of a function is also like composing a function to it, except on the other side.
11:51:05 <carminemlt> ion: LYAH, looks like a fine book.
11:51:53 <heatsink> Isn't that comapping, shachaf?
11:53:21 <jle`> read LYAH
11:53:36 <jle`> before anyhting else.
11:53:39 <jle`> :)
11:54:19 <carminemlt> jle`: Ok, will put Typeclassopedia on hold then, and follow your advice
11:54:41 <shachaf> carminemlt: If you're understanding Typeclassopedia there's no reason not to keep reading it.
11:54:53 <monochrom> arrow is seldom used, if you don't know it you'll survive. but I disbelieve that Craft of Functional Progrmaming leaves functor and monad unclear.
11:55:03 <fizbin> @check (\x ->  24 + x*x >= 10 * x )
11:55:04 <lambdabot>   *** Failed! Falsifiable (after 9 tests):
11:55:05 <lambdabot>  5
11:55:05 <joelteon> @. pl undo do { a <- [-1,0,1]; b <- [-1,0,1]; return (a,b) }
11:55:05 <lambdabot> (line 1, column 2):
11:55:05 <lambdabot> unexpected "-"
11:55:05 <lambdabot> expecting expression
11:55:20 <joelteon> @. pl undo do { a <- [0,1,2]; b <- [0,1,2]; return (a,b) }
11:55:21 <lambdabot> (`fmap` [0, 1, 2]) . (,) =<< [0, 1, 2]
11:55:30 <joelteon> ...ok
11:55:42 <ion> liftA2 (,) [-1,0,1] [-1,0,1]
11:55:53 <byorgey> carminemlt: if you've already read "Craft of functional programming" there's no need to read LYAH, you would probably find it rather slow going.  Maybe just read some of the later chapters of LYAH... whatever seems like it would be helpful
11:56:00 <ion> or: (,) <$> [-1,0,1] <*> [-1,0,1]
11:56:28 <joelteon> oh, good idea
11:57:50 <carminemlt> monochrom: I'm not saying it leaves those topics unclear as an absolute. Just that I wasn't able to write any non trivial code after reading about monads in that book. Not sure how to explain.
11:58:22 <carminemlt> monochrom: perhaps my expectations were unrealistic
11:58:47 <ReinH> joelteon: join (liftA2 (,))
11:58:50 <joelteon> yep
11:59:03 <ion> The transformation rules in https://gist.github.com/ion1/7016798 would change [-1,0,1] >>= \a -> [-1,0,1] >>= \b -> return (a,b) into (\a -> \b -> id (a,b)) <$> [-1,0,1] <*> [-1,0,1]
11:59:50 <monochrom> depending on how non-trivial is "non-trivial", reading books may be insufficient for writing non-trivial code, monad or C.
12:00:06 <monochrom> programming does not seem to be a spectator sport
12:00:14 <mauke> pfft
12:00:29 <mauke> I wrote my first programs with pen and paper, without a computer
12:01:05 <Hodapp> pfffft
12:01:05 <ion> ditto
12:01:10 <jrmithdobbs> mauke: i'm not sure if you're being facetious but i really did too =/
12:01:11 <Hodapp> Turing beats you all
12:01:38 <ion> I didn’t have a computer but i had access to some books and magazines about programming. Unfortunately, the languages were BASIC and DOS batch.
12:01:51 <mauke> jrmithdobbs: it's true! I found a book about BASIC and was fascinated
12:02:12 <mauke> the book didn't mention ELSE, I didn't understand WHILE, but I had IF and GOTO so that was ok
12:02:24 <carminemlt> monochrom: I wrote a script in ruby to fetch zipped content and upload to my ftp server. Trying to port that code from ruby to haskell, proved to be quite hard with just the knowledge I got from that book.
12:02:46 <mauke> I wrote a fibonacci program
12:02:58 <fizbin> My first programming was in BASIC. On a TI-99/4a
12:03:40 <monochrom> carminemlt, was ruby your 10th language? 9th language? 3rd language?
12:03:56 <carminemlt> monochrom: In the end I made it. But I had to go to read other stuff too. I've been pleased with the book, and the exercises.
12:04:21 <carminemlt> monochrom: hmmm, I'd say 19th
12:04:27 <carminemlt> monochrom: oops. 10th
12:04:57 <monochrom> there you go. compare your haskell experience with your 1st language experience, the 1st time you learned programming. don't compare to the 10th time.
12:05:16 <jrmithdobbs> mauke: ya mine was basic on one of those ti somethings with tvout (and no cassette attachment, hence, transcribing)
12:05:17 <monochrom> because haskell is sufficient different
12:05:42 <RevJohnnyHealey> I started with basic on an apple IIe clone.
12:06:07 <tinyghost> I started with visual basic on Windows XP
12:06:14 <carminemlt> monochrom: Will meditate on my youth's experience with C= basic :)
12:07:39 <RevJohnnyHealey> I remember learning the hard way to number my lines by 10s.
12:08:12 <carminemlt> RevJohnnyHealey: at first it was more copying code from the manual or magazines.
12:08:14 <path[l]> haha
12:08:26 <path[l]> I was taught that very early on
12:08:28 <path[l]> 10 begin
12:08:34 <ReinH> RevJohnnyHealey: I numbered my lines by 100s. I was all about future proofing.
12:08:45 <carminemlt> ReinH: :)
12:09:17 <ion> carminemlt: You have likely been programming in the same neighborhood of languages and decided to visit another continent.
12:09:18 <path[l]> I dont think I ever rote large enough programs to have to number in the 100s
12:09:28 <lightquake> is there any particular reason to use namespaces like pkg/my-function vs pkg-my-function?
12:09:48 <byorgey> lightquake: in what language?
12:09:54 <lightquake> wait, this isn't #emacs
12:10:03 <carminemlt> ion: Exactly! And the trip is amazing
12:14:25 <carminemlt> see you guys
12:18:45 <TallerGhostWalt> So I have a fairly small haskell program that has been compiling for like 2 hours
12:19:01 <TallerGhostWalt> Any way to figure out where in the file it is hanging?
12:21:13 <Cale> TallerGhostWalt: That's interesting. Can you put the source on lpaste.net?
12:22:30 <Cale> TallerGhostWalt: There are various ways to make compiling take exponential time/space in Haskell 98, but most of them are rather contrived. With UndecidableInstances, you can actually write things which will take forever.
12:23:28 <peddie> TallerGhostWalt: Some programs take forever to build with higher optimization settings; if you're on -O2 you could try reducing it
12:23:42 <luite_> more likely it's some inlining or specialization problem (if you compile with optimization)
12:23:57 <luite_> use some higher verbosity setting to see in which stage it fails
12:24:46 <TallerGhostWalt> yeah, it happened when I switched some lists to vectors
12:25:22 <TallerGhostWalt> cale: let me turn verbosity on and see where it is getting caught then I will
12:29:53 <TallerGhostWalt> http://lpaste.net/96654
12:32:27 <TallerGhostWalt> compiling with -threaded, -O2
12:34:11 <TallerGhostWalt> compiles just fine in with -O2 taken out
12:35:25 <ReinH> TallerGhostWalt: btw (\x -> LocationPath x) = LocationPath
12:35:35 <ReinH> data constructors are just functions
12:39:33 <TallerGhostWalt> ReinH: thx
12:40:57 <zett_zelett> I want to understand what "=>" means in haskell, but that’s really hard to google.
12:41:08 <zett_zelett> What’s it called?
12:41:18 <tac> type classes?
12:41:26 <tac> ad hoc polymorphism?
12:42:02 <donri> intrados: if you have a *, it's probably a kind signature :)
12:42:14 <donri> unless it's used as an operator :P
12:42:27 <ion> zett_zelett: Type constraints.
12:42:33 <zett_zelett> Thanks!
12:42:36 <ion> or class constraints
12:43:00 <tac> or prolog in yer typechecker
12:43:11 <Cale> tac: Please don't call it ad-hoc
12:43:24 <tac> Cale: Why's that?
12:43:32 <Cale> Because it's not ad-hoc polymorphism
12:44:02 <tac> I've seen it called that before. It's certainly more disciplined than most languages, though.
12:44:17 <Cale> With ad-hoc polymorphism, you normally can't use ad-hoc polymorphic things to define more ad-hoc polymorphic things (using a single definition)
12:44:29 <nurupo> haasn: can you give an example of splitting in half you mentioned?
12:44:33 <nurupo> >nurupo: if your calculation function looks something like g :: [Input] -> Output then you can recurse like  f (x:xs) = g input : f rest where (input, rest) = splitAt (read x) xs -- to split the remaining lines in half
12:44:36 <ReinH> tac: type class constraints are kind of the opposite of ad hoc polymorphism
12:44:38 <tac> (But to me, class constraints are just an implicit parameters anyway)
12:44:42 <Cale> Consider how sort :: (Ord a) => [a] -> [a] works on many types despite only being defined once.
12:45:03 <Cale> You can't do that with ad-hoc polymorphism
12:45:38 <tac> Well, call it what you want, but I don't think my usage is unprecedented:
12:45:39 <tac> http://www.haskell.org/haskellwiki/Polymorphism#Ad-hoc_polymorphism
12:45:51 <skypers> hi
12:46:21 <Cale> Lots of people have been confused about this, because the original paper which introduced typeclasses was called "How to make ad-hoc polymorphism less ad-hoc"
12:46:40 <ReinH> Maybe someone should fix the wiki page
12:47:31 <Cale> But I think it's a mistake to call type class polymorphism "ad-hoc polymorphism".
12:49:20 <Cale> It's much more closely related to parametric polymorphism. If you want to call it something other than type class polymorphism, then call it "bounded parametric polymorphism"
12:49:31 <tac> It's just an inferred parameter in any case :X  (Dependently-typed thinking for the win).
12:50:20 <Cale> All the dependently typed systems presently do a really shitty job of implementing typeclasses
12:50:47 <tac> I think that's an exaggeration.
12:51:13 <Cale> Well, they don't complain at all when there are multiple solutions to instance resolution, and instead just pick an arbitrary one.
12:51:36 <tac> Yeah. That's not the right thing to do.
12:52:09 <South> Quick question:
12:52:28 <South> Is there a simple function of type a -> [a -> a] -> a that I'm missing?
12:52:34 <South> or a -> [a -> a] -> [a]
12:52:54 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
12:52:54 <South> I wrote one but don't know what to call it or if it's super common and I'm just missing something obvious.
12:52:55 <lambdabot>   [5,7,10,25,32]
12:53:05 <Cale> > map ($ 5) [id, (+2), (*2), (^2), (2^)]
12:53:06 <South> thank you @Cale!
12:53:06 <lambdabot>   [5,7,10,25,32]
12:53:17 <South> :t sequence
12:53:18 <lambdabot> Monad m => [m a] -> m [a]
12:53:30 <Cale> I used sequence with the function monad
12:53:35 <Cale> So m a = e -> a
12:53:38 <South> Yeah, that makes perfect sense
12:54:05 <South> Is there an obvious analog to support scanning instead of folding?
12:54:16 <South> like this : a -> [a -> a] -> [a]
12:54:17 <ion> > [id, (+2), (*2), (^2), (2^)] <*> pure 5
12:54:18 <lambdabot>   [5,7,10,25,32]
12:54:32 <South> ah wait
12:54:44 <South> I want to get this
12:55:27 <South> f [id, (+2), (*2)] 5 = [5, 7, 14]
12:55:44 <South> so it scans over the functions, not applies it to each of them
12:56:55 <ReinH> :t scanl (.) id
12:56:55 <lambdabot> [c -> c] -> [c -> c]
12:57:16 <heatsink> :t foldr ($)
12:57:17 <lambdabot> b -> [b -> b] -> b
12:58:12 <South> ah perfect
12:58:15 <South> :t scanr ($)
12:58:16 <lambdabot> b -> [b -> b] -> [b]
12:58:16 <ReinH> > scanl (.) id [id, (+2), (*2)] <*> pure 5
12:58:17 <lambdabot>   [5,5,7,12]
12:58:30 <ReinH> not quite
12:58:38 <South> scanr ($) [id, (+2), (*2)] 5
12:58:51 <heatsink> :t (const :: a -> [a -> a] -> a)
12:58:52 <lambdabot> a -> [a -> a] -> a
12:58:54 <heatsink> I found the simplest one!
12:59:13 <South> Haha, why didn't mine work? :P
12:59:19 <South> foldrr ($) [id, (+2), (*2)] 5
12:59:23 <South> foldr ($) [id, (+2), (*2)] 5
12:59:36 <silver> > foldr
12:59:37 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable b0)
12:59:37 <lambdabot>    arising from a use ...
12:59:38 <heatsink> Use > to evaluate
12:59:53 <ReinH> :t foldr ($)
12:59:54 <lambdabot> b -> [b -> b] -> b
13:00:16 <South> oh thanks heatsink
13:00:29 <South> > scanr ($) 5 [id, (+2), (*2)]
13:00:30 <lambdabot>   [12,12,10,5]
13:03:24 <ReinH> > let f [] _ = []; f (g:gs) n = g n : f gs (g n) in f [id, (+2), (*2)] 5
13:03:25 <lambdabot>   [5,7,14]
13:03:32 <ReinH> now what type of traversal is f?
13:03:42 <South> Yeah ReinH that's what I have written actually
13:04:21 <South> Not sure what that means :(
13:04:28 <nadirs> hi everyone
13:05:11 <byorgey> hi nadirs
13:05:19 <ReinH> nadirs: hi
13:05:55 <WhatIsMonad> If I'm doing "Color4 (realToFrac r) (realToFrac g) (realToFrac b)" is there a nicer way to do that as a one-liner?  If it was Javascript I'd do "Color4.apply(null, [r,g,b,a].map(realToFrac))" but I haven't found a haskell equivelent to apply (probably due to type safety)
13:06:37 <snizzo> What am I doing wrong on the first line? http://pastebin.kde.org/ptcmiomer
13:06:46 <snizzo> I can't get it
13:07:15 <South> WhatIsMonad: You can do let[r', g', b'] = fmap realToFrac [r, g, b] in Color4 r' g' b'
13:08:12 <South> WhatIsMonad: assuming r, g, b are of the same type to begin with
13:08:26 <WhatIsMonad> South: Yes they are, and thank you!
13:08:39 <South> np!
13:08:44 <WhatIsMonad> Just curious, map and "fmap" are equivelent int his case, right?
13:08:50 <South> yeah
13:08:57 <South> fmap is just more general
13:09:05 <South> :t map
13:09:06 <lambdabot> (a -> b) -> [a] -> [b]
13:09:12 <South> :t fmap
13:09:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:09:14 <fizbin> In fact, fmap is defined as map for lists.
13:09:41 <South> WhatIsMonad: The Functor f is [] in map's case
13:10:25 <WhatIsMonad> South:  Sorry, I phrased the question poorly, I'm aware of what fmap is.  I was more curious if there's a stylistic reason in using it here.  Most tutorials I've seen use "map" whenever they are knowingly working a list, so I have been.  Wasn't sure if that was bad
13:10:25 <nadirs> snizzo: what are you trying to achieve there?
13:10:27 <skypers> I think there’s a lambdabot cmd for that
13:10:28 <skypers> like
13:10:36 <skypers> @src [a] fmap
13:10:36 <lambdabot> Source not found. You type like i drive.
13:10:42 <skypers> @src fmap [a]
13:10:42 <lambdabot> Source not found. :(
13:10:48 <skypers> someone?
13:10:56 <nadirs> @src fmap :: [a]
13:10:56 <lambdabot> Source not found.
13:11:00 <ReinH> South: if you're doing that a lot you just might want to write a constructor fractionalColor4 r g b = Color4 (realToFrac r) (realToFrac g) (realToFrac b)
13:11:05 <South> WhatIsMonad: I typically use fmap everywhere but I don't think anyone would have anything against using map instead.
13:11:12 <pavonia> @src [] fmap
13:11:13 <lambdabot> fmap = map
13:11:20 <ReinH> pavonia: nice
13:11:32 <skypers> South: I use map when working on lists
13:11:36 <skypers> because of mapM
13:11:38 <skypers> and so on
13:11:50 <South> skypers: that makes sense
13:12:07 <skypers> but sometimes I write fmap instead, and fix the line back :D
13:12:22 <WhatIsMonad> ReinH:  I was actually writing that function.  Just thought taht "rgbaToC4 (RGBA r g b a) = Color4 (realToFrac r) (realToFrac g) (realToFrac b) (realToFrac a)" was kinda an ugly way to write it
13:12:37 <South> haha
13:13:05 <skypers> WhatIsMonad: it’s quite okay
13:13:44 <skypers> btw, you can’t do what you want with functors here :)
13:13:51 <skypers> because you’d change the category
13:14:07 <skypers> and Haskell’s functors are endofunctors
13:14:28 <South> skypers: what are we talking about now?
13:14:31 <heatsink> snizzo, that looks like a happy file.  I think happy requires a :- symbol before the first parse rule
13:14:33 <ReinH> skypers: er
13:15:06 <ReinH> skypers: they are endofunctors in Hask.
13:15:08 <fizbin> :t let a ^ b = a (realToFrac b) in \f a b c -> f ^ a ^ b ^ c
13:15:09 <lambdabot> (Fractional b, Fractional b1, Fractional b2, Real a, Real a1, Real a2) => (b2 -> b1 -> b -> t) -> a2 -> a1 -> a -> t
13:15:17 <fizbin> WhatIsMonad: ^^
13:15:45 <ReinH> fizbin: clever
13:15:47 <apples> you could parameterize Color4 w/ a type and derive functor. then you could do fmap realToFrac $ Color4 r g b
13:16:27 <WhatIsMonad> heh this stuff is crazy
13:16:31 <byorgey> where is Color4 defined?
13:16:33 <South> fizbin: wow, haha
13:16:39 <fizbin> WhatIsMonad: That is, you could also write your expression as (let a ^ b = a $ realToFrac b in Color4 ^ r ^ g ^ b)
13:17:24 <ReinH> instance Functor Color4 where fmap f (Color4 r g b) = Color4 (f r) (f g) (f b) -- is a valid functor
13:18:05 <fizbin> ReinH: That depends on how Color4 is defined.
13:18:17 <skypers> yeah
13:18:19 <ReinH> fizbin: assuming it's some sort of Color4 a
13:18:21 <heatsink> snizzo: also the types don't match.  The first rule has type Tree Int while the other rules have type [Tree Int]
13:18:26 <ReinH> which iirc it is
13:19:14 <South> data Color4 a = !a !a !a !a
13:19:21 <South> Assuming he's using OpenGL
13:19:24 <ReinH> right
13:19:31 <ReinH> er
13:19:38 <fizbin> So it really should already have a Functor instance.
13:19:45 <ReinH> there's a data constructor ;)
13:19:51 <South> Yeah I missed a Color4 in there, lmao
13:20:21 <South> fizbin: I think it doesn't because it's supposed to only have numeric values
13:20:41 <ReinH> Oh it is already a functor
13:21:02 <ReinH> realToFrac <$> Color4 r g b a
13:21:33 <South> gotta go, thanks for the help guys!
13:21:43 <snizzo> nadirs, heatsink: yeah it's happy there. I'm trying to generate a parsing tree from a string like "( 1 2 3 4 5 )" where 1 is the father of all the other children.
13:22:14 <ReinH> it's a Functor, Applicative, Foldable, Traversable
13:22:22 <ReinH> It plays nicely with others
13:22:54 <snizzo> I can't get why it's wrong
13:23:24 <charlie_sanders> I have to same I'm liking haskell much better than scala sof ar
13:23:38 <pavonia> snizzo: What error do you get?
13:23:39 <heatsink> "( 1 2 3 )" should produce Node 1 [Node 2 [Void], Node 3 [Void]] ?
13:23:54 <snizzo> heatsink: yeah that's right
13:25:36 <heatsink> Rules are statically typed like Haskell functions.  You need separate rules for one tree and for lists of trees.
13:26:03 <nadirs> snizzo: your first line looks like is missing a declaration though, shouldn't it be something like:
13:26:05 <nadirs> functionName arg = <expression>
13:26:10 <nadirs> ?
13:26:26 <heatsink> nadirs, this file is preprocessed by happy to product a haskell module
13:26:39 <nadirs> heatsink: ah, my bad then
13:26:39 <heatsink> *produce
13:27:19 <heatsink> Also, you should write type signatures for rules.  Type signatures help make error messages more understandable.
13:27:20 <nadirs> heatsink, snizzo: I don't know happy, I'm afraid I can't help there
13:28:39 <tomejaguar> Does anyone here use esqueleto?
13:29:39 <snizzo> heatsink, pavonia: here are execution errors
13:29:41 <snizzo> http://pastebin.com/LdbKGSnj
13:29:46 <mauke> The paste LdbKGSnj has been copied to http://lpaste.net/96659
13:30:11 <snizzo> thanks, I'll use lpaste.net from now on
13:30:22 <tomejaguar> mauke: Do you have a bot to do that?
13:30:26 <skypers> “happy”
13:30:30 <heatsink> The message "Couldn't match type `[Tree Int]' with `Tree Int'" is because you need separate rules for one tree and for lists of trees
13:30:30 <skypers> what a lovely name for a lib :)
13:30:35 <heatsink> No, mauke types really fast
13:30:46 <heatsink> :p
13:31:26 <tomejaguar> My next lib is going to be called delightful
13:31:32 <snizzo> heatsink: ok, I'll inspect now
13:31:47 <heatsink> What will delightful do?
13:32:35 <nurupo> can someone help me with a function that given a 2d list would return a list of quarters?
13:32:35 <nurupo> https://gist.github.com/nurupo/5204b6a50ce86ceac1ed
13:32:48 <Rembane> nurupo: What's a quarter?
13:33:30 <nurupo> Rembane: 1/4
13:33:54 <ReinH> nurupo: you want the boxs function from Richard Bird's sudoku solution
13:34:07 <ReinH> nurupo: http://www.cs.dartmouth.edu/~cs8/F2009/examples/Sudoku.lhs
13:34:27 <nadirs> nurupo: by looking at your gist I'd say "splitAt" should help you
13:34:35 <nurupo> i have the algorithm written down in the paste, i just can't convert it in haskell
13:34:42 <ReinH> which iirc is map concat . concat . chunksOf 2 . split . map split
13:34:48 <nurupo> nadirs: yes, it would
13:34:52 <ReinH> :t map concat . concat . chunksOf 2 . split . map split
13:34:53 <lambdabot>     Couldn't match type `[a1] -> [[a1]]' with `[[[a0]]]'
13:34:53 <lambdabot>     Expected type: Splitter a1 -> [[[a0]]]
13:34:53 <lambdabot>       Actual type: Splitter a1 -> [a1] -> [[a1]]
13:34:53 <nurupo> but how do i recurse...
13:35:06 <byorgey> > let f = transpose . map (take 2) in (f . f) ["1234", "5678", "9098", "7654"]
13:35:07 <lambdabot>   ["12","56"]
13:35:13 <nurupo> wow
13:35:23 <ReinH> oh I forgot the transpose
13:35:45 <byorgey> > let f = transpose . map (chunksOf 2) in (f . f) ["1234", "5678", "9098", "7654"]
13:35:46 <lambdabot>   [[["12","56"],["34","78"]],[["90","76"],["98","54"]]]
13:36:01 <ReinH> :t let split = chunksOf 2 in map concat . concat . map transpose . split . map split
13:36:02 <lambdabot> [[a]] -> [[a]]
13:37:03 <snizzo> heatsink: I still can't get it. Since it is a recursive definition, shouldn't it be ok?
13:37:09 <ReinH> > let split = chunksOf 2 in (map concat . concat . map transpose . split . map split) ["1234","5678","9098","7654"]
13:37:11 <lambdabot>   ["1256","3478","9076","9854"]
13:37:14 <moto9> does ghci have a command to see all known instances of a class?
13:37:37 <nurupo> byorgey: thanks :) now i will go read haskell docs to make sense of what it does
13:38:01 <ReinH> Also fun fact: this function is an involution
13:38:05 <zett_zelett> Is "Num a => a" really considered a type in itself or would one say "3 is a type of class Num" or something like that?
13:38:09 <ReinH> > let boxs = let split = chunksOf 2 in (map concat . concat . map transpose . split . map split) in (boxs.boxs) ["1234","5678","9098","7654"]
13:38:10 <lambdabot>   ["1234","5678","9098","7654"]
13:38:46 <byorgey> zett_zelett: Num a => a  is a type.
13:39:13 <byorgey> zett_zelett: the types  Int, Integer, and so on are also types, which are instances of the class Num
13:39:17 <byorgey> zett_zelett: 3 is not a type.
13:39:21 <ReinH> nurupo: read this http://www.cs.dartmouth.edu/~cs8/F2009/examples/Sudoku.lhs
13:40:02 <heatsink> snizzo: What tree should the parser create for the input "( 1 ( 2 3 ) )" ?
13:40:58 <snizzo> heatsink: Node 1 [Node 2 [Node 3 [Void]]
13:41:11 <heatsink> Okay, but that's not what your parsing rules say
13:41:24 <nurupo> > let f = transpose . map (chunksOf 4) in (f . f) ["12345678", "90123456", "78901234", "56789012", "34567890", "09876543", "21098765", "43210987"]
13:41:25 <lambdabot>   [[["1234","9012","7890","5678"],["5678","3456","1234","9012"]],[["3456","09...
13:41:44 <zett_zelett> Has "=>" any additional meaning other than being the symbol syntactically needed to describe class constraints? (It looks like a symbol for natural transformations, which it probably doesn’t denote) I get confused with viewing this as a real type, it requires getting used to.
13:42:09 <cariveri> if the a sub function is IO the calling one must return IO also right?
13:42:16 <shachaf> No, it's pretty much only constraints.
13:42:17 <ReinH> nurupo: did you see boxs?
13:42:29 <zett_zelett> Thank you, shachaf and byorgey.
13:42:31 <shachaf> Sometimes people define ~> for natural transformations.
13:42:47 <ReinH> cariveri: I'm not sure what you're asking.
13:42:48 <scriptor> zett_zelett: can't answer your specific question, but one way to read it is "assuming a has typeclass Num, then ..."
13:42:58 <snizzo> heatsink: the last 2 rules are useful because with that I can get successions, and they generate a list. I learnt them from haskell happy manual. The first one I think it's useful to get the first element (the father) and then Tree which means children
13:43:07 <snizzo> am I failling implementing or thinking?
13:43:10 <ReinH> zett_zelett: it looks more like the symbol for "implies" :)
13:43:15 <snizzo> or both? :)
13:43:26 <heatsink> snizzo, let's go through the parsing rules for the example string "( 1 ( 2 3 ) )"
13:43:34 <nurupo> ReinH: i bookmarked the link
13:43:43 <ReinH> nurupo: it's the function you want :)
13:43:46 <heatsink> I'm using letters x, y, z for variables
13:43:54 <byorgey> ReinH: no, it isn't
13:44:07 <byorgey> ReinH: it has an extra concat
13:44:12 * hackagebot ADPfusion 0.2.0.0 - Efficient, high-level dynamic programming.  http://hackage.haskell.org/package/ADPfusion-0.2.0.0 (ChristianHoener)
13:44:13 <heatsink> For the entire string, the parser matches "( 1 x )" and outputs Node 1 x
13:44:15 <byorgey> though that's easy to fix of course.
13:44:21 <byorgey> mine has too few concats.
13:44:21 <ReinH> byorgey: oh I see.
13:44:24 <zett_zelett> scriptor: That’s probably the reason why I’m thrown off – any other type I can read as "functions from …" or "integers" or something like that. But with "Num a => a" I just don’t know what to call this collection.
13:44:38 <heatsink> For x, the parser matches "( 2 y )" and outputs Node 2 y
13:44:38 <ReinH> byorgey: well I think nurupo should want my function :)
13:44:54 <heatsink> For y, the parser matches "3" and outputs [Node 3 [Void]]
13:45:11 <heatsink> So the whole string parses to Node 1 (Node 2 [Node 3 [Void]])
13:45:21 <byorgey> ReinH: our functions are equivalent; I leave the proof as an exercise.  Yours looks more efficient.
13:45:22 <cariveri> ReinH: map f l ; f x = g x ; g x = do unavoidableIO return v . then all the upper functions need to pass IO in the return type right?
13:45:24 <scriptor> zett_zelett: yeah, it's new notation, I think it comes from when writing proofs you start out listing all the "givens" or "assumptions"
13:45:25 <heatsink> Note that I used parentheses
13:45:34 <heatsink> Do you understand so far, snizzo?
13:45:38 <scriptor> "new notation" to me, that is
13:45:46 <zett_zelett> Would some background on type theory (as developed by mathmaticians) help me understand this better?
13:46:21 <snizzo> heatsink: yeah
13:46:28 <heatsink> Okay
13:46:28 <byorgey> zett_zelett: no, that's not necessary.
13:46:29 <shachaf> @quote mathematicians
13:46:30 <lambdabot> luqui says: sigh: mathematicians.  can't live with 'em, can't prove 'em wrong.
13:46:35 <shachaf> @quote kmc mathematicians
13:46:35 <lambdabot> kmc says: Haskell isn't really designed by mathematicians.  it's designed by people who programmers would consider to be mathematicians and mathematicians would consider to be programmers
13:46:36 <scriptor> zett_zelett: looks like it comes straight from here http://en.wikipedia.org/wiki/List_of_logic_symbols
13:46:45 <scriptor> (first thing in the table)
13:46:48 <nadirs> question: shouldn't ghc come with Data.Text package included?
13:46:49 <snizzo> heatsink: so the problem is the "int" rule?
13:46:55 <heatsink> No
13:46:57 <FreeFull> You can prove them wrong by showing a flaw in their reasoning
13:47:28 <byorgey> zett_zelett: the general form is    constraints => type
13:48:01 <byorgey> zett_zelett: if   foo :: C => T,  it means that  foo has type T, assuming the constraints C are satisfied
13:48:06 <heatsink> The result of this example is erroneous because you have a Node containing a Tree Int in its second field, but the definition of Tree says that a Node should contain a [Tree Int] in its second field
13:48:06 <snizzo> heatsink: the first rule should be like this? '(' int Tree ')'  { Node $2 [$3] }
13:48:07 <nadirs> I'm probably missing ghc-mod
13:48:17 <heatsink> No
13:48:33 <byorgey> so if  foo :: Num a => a,  it means that  foo has any type  a  you like ... as long as that type is an instance of Num
13:48:42 <snizzo> oh
13:48:56 <heatsink> Your parsing rules say to match any of three possible situations
13:49:05 <heatsink> However, one of those situations creates a Tree Int
13:49:06 <zett_zelett> Would be legal to have type Num a => (Eq a => a), since the latter part is considered a type as well?
13:49:11 <heatsink> and the other two create a [Tree Int]
13:49:12 * hackagebot ADPfusion 0.2.0.1 - Efficient, high-level dynamic programming.  http://hackage.haskell.org/package/ADPfusion-0.2.0.1 (ChristianHoener)
13:49:14 * hackagebot ADPfusion 0.2.0.2 - Efficient, high-level dynamic programming.  http://hackage.haskell.org/package/ADPfusion-0.2.0.2 (ChristianHoener)
13:49:20 <shachaf> zett_zelett: It is legal in GHC but not in Haskell 2010.
13:49:28 <zett_zelett> Okay.
13:49:37 <byorgey> nadirs: no, ghc does not come with Data.Text, though the Haskell Platform does
13:49:39 <shachaf> It's sensible, though.
13:49:50 <heatsink> so, in some situations, the parser could return either a Tree Int or a [Tree Int]
13:49:51 <ReinH> byorgey: it's actually Bird's :)
13:49:59 <nadirs> byorgey: thanks, I've solved by installing ghc-mod (I'm on Arch)
13:50:05 <snizzo> heatsink: ohhhhh now I got it
13:50:16 <zett_zelett> Why don’t they permit it in Haskell 2010?
13:50:48 <snizzo> I have to return always the same type from all rules of Tree
13:50:51 <heatsink> yes
13:51:02 <ReinH> cariveri: what do the types tell you?
13:51:03 <nadirs> > let bla :: Num a => (Eq a => a) -> a; bla x = x
13:51:04 <lambdabot>   not an expression: `let bla :: Num a => (Eq a => a) -> a; bla x = x'
13:51:05 <heatsink> you can split it into one rule for Tree Int and a different rule for [Tree Int]
13:52:32 <snizzo> heatsink: you mean creating an other data type?
13:52:34 <vmalloc> Hi, can anyone help out a noob trying to use Lens's `alongside` on Control.Lens.Aeson? It's extremely baffling and I've been trying to get something working with no success so far...
13:52:43 <snizzo> sorry for I'm newbie :/
13:53:04 <shachaf> If alongside is baffling then maybe it's not what you want.
13:53:22 <ReinH> vmalloc: ask and we'll find out :)
13:53:56 <heatsink> I mean creating another parsing rule
13:54:13 * hackagebot BiobaseXNA 0.7.0.2 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.7.0.2 (ChristianHoener)
13:54:26 <heatsink> tree : '(' int treelist ')
13:54:33 <vmalloc> ReinH: I'm trying to extract multiple fields out of a structure with a single expression - something like json ^.. key "something" . alongside (key "a") (key "b")
13:54:56 <ReinH> vmalloc: what do you want the result to be?
13:54:57 <heatsink> treelist : tree treelist | tree
13:55:12 <vmalloc> ReinH: something like (value_of_field_a, value_of_field_b)
13:55:18 <Cale> vmalloc: alongside isn't the thing you want
13:55:23 <vmalloc> ReinH: I don't want to parse the json twice to get both fields
13:55:35 <heatsink> Actually, you need another case for the tree leaf. tree : int | '(' int treelist ')'
13:55:54 <vmalloc> Cale: possibly, have another suggestion?
13:55:55 <Cale> alongside might be used if you wanted to extract two different bits of two different JSON structures
13:56:08 <Cale> I suppose you *could* use it along with (\x -> (x,x))
13:56:18 <Cale> (as a getter, anyway)
13:56:38 <vmalloc> Cale: ok, so assuming I want to extract both fields, what's the most elegant way that doesn't involve parsing twice?
13:56:57 <Cale> You probably want both
13:57:08 <vmalloc> I tried accomplishing it with Text.JSON's JSValue madness, but it comes out extremely verbose
13:57:21 <nurupo> byorgey: could you explain what `in (f . f) ["1234", "5678", "9098", "7654"]` part does?
13:57:32 <Cale> er, no
13:57:33 <vmalloc> Cale: ok, sorry - I'm a total newbie. Can you give an example?
13:58:00 <Cale> Yeah, that's wrong, hmm, I wonder if lens has what I'm thinking of
13:58:02 <ReinH> nurupo: (f . f) x = f ( f x )
13:58:12 <Cale> (probably does)
13:58:42 <nurupo> ReinH: but f takes no arguments
13:58:58 <shachaf> vmalloc: alongside doesn't do what you want.
13:59:09 <shachaf> What you do want is not really easily doable, alas.
13:59:12 <nurupo> let f = transpose . map (chunksOf 2) in (f . f) ["1234", "5678", "9098", "7654"]
13:59:13 * hackagebot BiobaseBlast 0.0.0.1 - BLAST-related tools  http://hackage.haskell.org/package/BiobaseBlast-0.0.0.1 (ChristianHoener)
13:59:18 <vmalloc> Cale: ok, so I'll step back a bit - do you know of an elegant way not involving lenses? I feel dirty using all that black magic for such a trivial task
13:59:26 <ion> nurupo: “let <bindings> in <expression>” is syntax. <bindings> are in scope for <expression>.
13:59:33 <ReinH> nurupo: why don't you think f takes arguments?
13:59:42 <Cale> vmalloc: Just parse the JSON once, and then apply two different lenses to it?
13:59:50 <ReinH> > let f = fmap (+1) in f [1,2,3] -- nurupo does f take an argument?
13:59:51 <lambdabot>   [2,3,4]
14:00:52 <snizzo> heatsink: really thank you, really I'd like to offer you a beer :)
14:00:56 <vmalloc> Cale: I couldn't figure out how to apply the lenses on parsed JSON... Should I use Text.JSON for getting a JSValue? Should I use something from Aeson?
14:00:57 <Cale> vmalloc: aeson has a type called Value for representing arbitrary JSON values in an already-parsed form
14:01:00 <nurupo> > let f = \ _ -> fmap (+1) in f [1,2,3]
14:01:01 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable1 f0)
14:01:01 <lambdabot>    arising from a use...
14:01:30 <ion> > let f = \ _ -> fmap (+1) in f "ignored" [1,2,3]
14:01:31 <nurupo> > let f _ = fmap (+1) in f [1,2,3]
14:01:31 <lambdabot>   [2,3,4]
14:01:32 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable1 f0)
14:01:32 <lambdabot>    arising from a use...
14:01:33 <Cale> and as far as I know the lenses in lens-aeson apply to that type
14:02:19 <Cale> vmalloc: So you should only have to decode your string once
14:02:35 <Cale> vmalloc: and then you can apply different lenses to it to extract the bits you're interested in
14:02:38 <vmalloc> Cale: ok, it's possible that I got everything messed up with Text.JSON attempts
14:03:09 <nurupo> > fmap (+1) [1,2,3]
14:03:10 <lambdabot>   [2,3,4]
14:03:10 <vmalloc> Cale: I'll try to go back to the docs and see what I missed
14:03:14 <Cale> (that's even assuming you want to use lenses to do it -- it's also reasonable just to pattern match in many cases)
14:03:30 <ReinH> nurupo: fmap (+1) [1,2,3] = (fmap (+1)) [1,2,3]
14:03:33 <vmalloc> Cale: Thanks!
14:03:38 <Cale> http://hackage.haskell.org/package/aeson-lens-0.5.0.0/docs/Data-Aeson-Lens.html
14:03:39 <ReinH> = let f = fmap (+1) in f [1,2,3]
14:03:43 <nadirs> nurupo: try removing the _ from the f declaration
14:03:45 <Cale> If you look at the ghci examples here
14:04:01 <Cale> They start off by defining a Maybe Value by using decode
14:04:05 <nurupo> nadirs: it's fine, i'm just messing around
14:04:14 * hackagebot BiobaseFasta 0.0.1.0 - conduit-based FASTA parser  http://hackage.haskell.org/package/BiobaseFasta-0.0.1.0 (ChristianHoener)
14:04:17 <nadirs> nurupo: haha ok
14:04:19 <Cale> The work of decoding the JSON will only be done once, when that constant gets evaluated
14:05:03 <nurupo> ion: yep, i understood the let <> in <> construct
14:05:09 <nurupo> ion: thanks :)
14:05:34 <ReinH> nurupo: pop quiz: how many arguments does fmap take?
14:06:30 <ion> > let f = (+) in f 3 4
14:06:31 <lambdabot>   7
14:06:45 <ion> > let f = (+) 3 in f 4
14:06:46 <lambdabot>   7
14:06:50 <ion> > let f = (+) 3 4 in f
14:06:51 <lambdabot>   7
14:07:07 <WhatIsMonad> Is there a way to have GHC compile executables such that they trace and print that trace upon hitting an exception?  When I try to debug my code in GHCi GHCi just segfaults without working at all, i'm thinking due to gtk2hs and OpenGL combo
14:07:15 <nadirs> ReinH: does the answer change if you replace fmap with any other function?
14:07:26 <ReinH> nadirs: it might, but not by much.
14:07:28 <Cale> > fmap (+2) (*2) 5
14:07:29 <lambdabot>   12
14:07:52 <ion> If it segfaults in C bindings, perhaps try gdb.
14:08:06 <ReinH> well, if we're saying that constants are not unary functions, then no
14:08:09 <ReinH> it does not change
14:08:18 <ion> The C function that crashes might give an idea of what to look for.
14:08:35 <Cale> > fmap map (+) 5 [1,2,3]
14:08:36 <lambdabot>   [6,7,8]
14:08:38 <ReinH> er nullary functions
14:09:26 <WhatIsMonad> When I run my program compiled via GHC, it works up until I perform a certain actions, then gives me "<<loop>>" and crashes
14:09:39 <WhatIsMonad> exits* not crashes
14:09:43 <WhatIsMonad> When I try to run "main" of my program inside GHCi, GHCi segfaults almost immediately
14:09:50 <Cale> > fmap foldr fmap (+2) 5 [(*2), (*3)]
14:09:51 <lambdabot>   36
14:09:54 <WhatIsMonad> So the C function won't really help me nail down my atual bug
14:10:26 <begriffs> Has anyone noticed cabal-install sometimes picking out-of-date package versions when newer ones are available? (even after cabal update)
14:10:27 <ReinH> Cale: appearances notwithstanding ;)
14:10:59 <Cale> WhatIsMonad: um, what is this program?
14:11:16 <ion> I’d say it’s fair to say “id takes 1 parameter” even though
14:11:18 <ion> > id id id id id id id id id id id 42
14:11:20 <lambdabot>   42
14:11:29 <Cale> WhatIsMonad: <<loop>> means that your program needed the value of a variable while attempting to compute that same variable.
14:11:54 <nisstyre> > let a = a in a
14:11:58 <lambdabot>   mueval-core: Time limit exceeded
14:12:01 <Cale> WhatIsMonad: i.e. your program is observably in an infinite loop, and so the RTS just ends the infinite loop early by killing the program.
14:12:18 <ion> Thereby solving the halting problem
14:12:21 <WhatIsMonad> Cale:  Yeah that's exactly right.  Issue is, its a decently sized program, and i've made a lot of changes since last testing the broken functionality
14:12:37 <ion> whatismonad: git bisect?
14:12:38 <nisstyre> ion: solving *a* halting problem
14:12:40 <WhatIsMonad> I wish I could just get an error message indicating the expression it was attempting to compute that looped
14:13:07 <joelteon> you can figure out whether for(;;){} halts
14:14:12 <ReinH> ion: yes, it takes an argument and returns value. Just like every other function ;)
14:14:18 <Cale> WhatIsMonad: If you compile with profiling turned on, and run the program with +RTS -xc
14:14:29 <Cale> WhatIsMonad: then you'll get a cost-centre trace at the point that the program dies
14:14:33 <WhatIsMonad> Cale:  Thanks, I'll give that shit
14:14:46 <ion> wat
14:14:55 <WhatIsMonad> errr give that a shot*
14:14:57 <WhatIsMonad> haha
14:15:05 <ReinH> close enough
14:15:10 <WhatIsMonad> Dangerously far away though
14:15:13 <ReinH> paging Dr. Freud
14:16:53 <ion> Give that shit a shot.
14:17:18 <WhatIsMonad> lol
14:17:35 <ReinH> Because you're worth it.
14:18:04 <ion> Because you’re worth shit.
14:18:23 <mm_freak> you probably give that a shit as well
14:18:28 <nurupo> ReinH: two arguments?
14:18:38 <ReinH> nurupo: What if I told you fmap takes one argument?
14:18:41 <ReinH> nurupo: what would that mean?
14:19:02 <heatsink> you're welcome, snizzo
14:19:38 <ReinH> nurupo: If I told you that all functions take a single argument and return a value, what value does `fmap (+1)' return?
14:19:51 <nurupo> ReinH: it would mean an incomplete function that has nly the first agrument assigned so far
14:20:05 <ReinH> nurupo: Yes, and we call these functions "partially applied"
14:21:22 <ReinH> nurupo: and what does it return?
14:22:00 <ReinH> (I should really get into the habit of saying provide or something other than return, shouldn't I)
14:22:09 <nurupo> ReinH: oh, a partially applied function, of course!
14:22:21 <ReinH> nurupo: yep :)
14:22:36 <shachaf> "partially applied" is a close to meaningless term.
14:22:59 <ReinH> shachaf: why so?
14:23:08 <shachaf> You can give it a precise meaning but almost no one uses that.
14:23:20 <shachaf> @quote ddarius partial
14:23:21 <lambdabot> ddarius says: (f x) is a partial application iff f x == (curry (uncurry f) x)
14:23:33 <byorgey> ReinH: because all functions only take one argument.
14:23:51 <byorgey> so there's nothing "partial" about applying them.
14:24:26 <eikke> I'm trying to combine 'free' and datatypes-a-la-carte/compdata to add checked exceptions to a DSL, but fail on one part. Anyone interested to take a look?
14:24:28 * ReinH shrugs
14:24:36 <tac> Yeah. A function in Haskell is, by definition, a map that takes *an* input to *an* output.
14:24:47 <ReinH> I understand the distinction, but I don't think people are confused by this use of "partially applied"
14:25:01 <tac> Sometimes, that input might be a tuple, though, or maybe the output is, itself, another funciton.
14:25:05 <shachaf> Yes, but maybe they *should* be confused by it.
14:25:12 <byorgey> ReinH: I just think people would be slightly *less* confused if you just didn't use that term at all.
14:25:20 <shachaf> ==byorgey
14:25:36 <ReinH> byorgey: in the context of fmap, we need some way to talk about what `fmap f` is
14:25:51 <shachaf> It's fmap applied to an argument.
14:25:58 <byorgey> it is a function.
14:26:03 <shachaf> That too.
14:26:14 <Feuerbach_> what's the problem with "partially applied"?
14:26:23 <nurupo> yeah, i studied that, for example, `let fun x y = x` expands to `let fun = \x -> \y -> x`
14:26:28 <ReinH> Feuerbach_: technically, it is impossible to partially apply a Haskell function
14:26:31 <shachaf> That it's nearly meaningless and suggests that things work in a way that they don't.
14:26:47 <shachaf> ReinH: I'm not sure what that means either.
14:27:00 <ReinH> shachaf: seriously?
14:27:12 <Feuerbach_> it depends on your definition of "partially applied", of course. If you can't partially apply a function, then perhaps your definition isn't very useful
14:27:29 <shachaf> Yes.
14:27:38 <Cale> An application is a partial application if it has a function type.
14:27:43 <shachaf> My bar is higher when your sentence starts with "technically,".
14:27:47 <Cale> PROBLEM SOLVED
14:27:48 <shachaf> Cale: I like ddarius's definition.
14:27:49 <Feuerbach_> Cale: exactly
14:27:52 <shachaf> @quote ddarius partial
14:27:52 <lambdabot> ddarius says: (f x) is a partial application iff f x == (curry (uncurry f) x)
14:28:12 <shachaf> Note that it handles things like _|_, side effects (if your language has them), and so on.
14:29:00 <nadirs> Cale: that's just perfect
14:29:10 <nadirs> @quote ddarius
14:29:10 <lambdabot> ddarius says: ski has corrupted many.
14:29:39 <nadirs> hm, what?
14:29:41 <byorgey> the pedagogical point is, it's better to use the simplest terminology that is correct, rather than using complex terminology just in the hopes of connecting to some intuition the learner may already have.
14:29:49 <tomejaguar> Does anyone know how persistent works?
14:30:13 <Feuerbach_> on a different subject, a guy posted his monad tutorial on /r/haskell and then shortly removed it. I wonder if we were too harsh and unwelcoming (srsly)
14:30:57 <shachaf> Was it the one that made me sad?
14:31:33 <shachaf> Hmm, no, that one is still up.
14:31:48 <Feuerbach> :)
14:31:57 <Feuerbach> here's the link https://medium.com/p/f93c9ddf7014
14:32:04 <tomejaguar> It seems to still be there: http://www.reddit.com/r/haskell/comments/1s9mgj/i_dont_quite_get_monads_so_maybe_i_will_be_able/
14:32:15 <tomejaguar> Oh, but the user is deleted
14:32:16 <Feuerbach> of course it's awful, but still
14:32:41 <Feuerbach> tomejaguar: the submission is removed, but is still accessible by the reddit permalink
14:32:49 <Feuerbach> (I believe)
14:32:57 <tomejaguar> I see
14:34:17 <eikke> I'm kinda stuck on the 'undefined' at line 34 https://gist.github.com/NicolasT/7833209
14:34:46 <eikke> been trying quite a couple of things, but none seem to work as expected (and I think my types are correct)
14:36:00 <nurupo> can i somehow get rid of extra [] in [[["12","56"],["34","78"]],[["90","76"],["98","54"]]] to make it [["12","56"],["34", "78"],["90", "76"],["98","54"]]?
14:36:18 <nurupo> :t [[["12","56"],["34","78"]],[["90","76"],["98","54"]]]
14:36:19 <lambdabot> [[[[Char]]]]
14:36:23 <ReinH> :t concat
14:36:24 <lambdabot> [[a]] -> [a]
14:36:38 <eikke> :t head [[[]]]
14:36:39 <monochrom> eikke: what is the type of caseF? where can I read about it?
14:36:39 <lambdabot> [[a]]
14:36:47 <nurupo> > map concat [[["12","56"],["34","78"]],[["90","76"],["98","54"]]]
14:36:48 <lambdabot>   [["12","56","34","78"],["90","76","98","54"]]
14:36:53 <ReinH> nurupo: just concat
14:37:01 <eikke> monochrom: http://hackage.haskell.org/package/compdata-0.7.0.1/docs/Data-Comp-Sum.html
14:37:24 <ReinH> eikke: best to avoid partial functions when possible (it's almost always possible)
14:37:35 <nurupo> ReinH: it removed inner [], but i needed the middle ones
14:37:40 <eikke> ReinH: agree
14:37:44 <nurupo> hm
14:37:53 <ReinH> nurupo: which ones are you talking about?
14:37:56 <FireFly> > concat [[[1,2],[3,4]]]
14:37:57 <lambdabot>   [[1,2],[3,4]]
14:38:03 <nurupo> ><nurupo> can i somehow get rid of extra [] in [[["12","56"],["34","78"]],[["90","76"],["98","54"]]] to make it [["12","56"],["34", "78"],["90", "76"],["98","54"]]?
14:38:04 <eikke> monochrom: I thought I just need 'Free' in place of the undefined, but GHC is certain my thinking is wrong
14:38:12 <ReinH> nurupo: right, so concat
14:39:04 <nurupo> ReinH: but it returns [["12","56","34","78"],["90","76","98","54"]]
14:39:04 <nurupo> instead of [["12","56"],["34", "78"],["90", "76"],["98","54"]]?
14:39:13 <ReinH> nurupo: what does?
14:39:27 <nurupo> > map concat [[["12","56"],["34","78"]],[["90","76"],["98","54"]]]
14:39:28 <lambdabot>   [["12","56","34","78"],["90","76","98","54"]]
14:39:33 <nurupo> > concat [[["12","56"],["34","78"]],[["90","76"],["98","54"]]]
14:39:34 <lambdabot>   [["12","56"],["34","78"],["90","76"],["98","54"]]
14:39:38 <nurupo> oh
14:39:40 <ReinH> nurupo: why do you keep doing `map concat` when I keep telling you to do concat? ;)
14:40:02 <nadirs> > concat $ concat [[["12","56"],["34","78"]],[["90","76"],["98","54"]]]
14:40:03 <lambdabot>   ["12","56","34","78","90","76","98","54"]
14:40:17 <nadirs> hm, too much concat, probably :P
14:40:18 <ion> > (concat . concat . concat) [[["12","56"],["34","78"]],[["90","76"],["98","54"]]]
14:40:19 <lambdabot>   "1256347890769854"
14:40:26 <nadirs> ha
14:41:01 <nurupo> > (concat . concat . concat . concat) [[["12","56"],["34","78"]],[["90","76"],["98","54"]]]
14:41:02 <lambdabot>   Couldn't match type `GHC.Types.Char' with `[a0]'
14:41:02 <lambdabot>  Expected type: [[a0]]
14:41:02 <lambdabot>    ...
14:42:09 <nurupo> :t [["12","56"],["34","78"],["90","76"],["98","54"]]
14:42:09 <lambdabot> [[[Char]]]
14:42:20 <nurupo> why it's not [[String]] ?
14:42:29 <ion> @src String
14:42:30 <lambdabot> type String = [Char]
14:42:52 <ion> And because GHC isn’t smart enough to turn that back.
14:43:03 <nadirs> by the way is there any guideline to follow about when to use (.) instead of ($), like there in the concat example?
14:43:07 <monochrom> Free a :: Free (Throws e :+: f) a, therefore a :: (Throws e :+: f) (Free (Throws e :+: f) a), is that right?
14:43:35 <nurupo> i think my ghc previously complained about String != [Char]
14:43:40 <osa1> hmm, module link in project hackage page gives 404, is this a bug? http://hackage.haskell.org/package/GLFW-b (click to only exported module)
14:43:41 <nurupo> or am i mistaking
14:43:59 <eikke> monochrom: think so yes (although those functor fixpoint are a nightmare to parse in my head)
14:44:18 <monochrom> therefore, in "caseF whatever (\x -> ...) a", x :: f (Free (Throws e :+: f) a). that is, not simply "x :: f (Free f a)"
14:44:37 <ion> nadirs: “(foo . bar . baz . quux) x” can be eta-reduced and “bar . baz” can be refactored out of it verbatim and given a name. Neither applies to “foo $ bar $ baz $ quux $ x”. If you’re unsure if you should use ($) or not, you probably shouldn’t.
14:44:50 <South> Hey again everyone
14:44:58 <eikke> monochrom: but I already unwrapped the Free?
14:45:16 <South> Is anyone here really familiar with Pipes?
14:45:27 <monochrom> no, read again.
14:45:31 <eikke> otherwise the first arg to caseF wouldnt work (and the thing does what it's expected to do, both at compile- as well as runtime)
14:45:48 <monochrom> "Free a :: Free (Throws e :+: f) a, therefore a :: (Throws e :+: f) (Free (Throws e :+: f) a)". that unwraps the "Free".
14:45:52 <nadirs> I've heard arguments against the abuse of (.) because it affects readability (not that I agree with such statement)
14:46:14 <ion> nadirs: Abuse of either is bad. Good use of either is good.
14:46:35 <ion> I’d say ($) is easier to abuse, but things like (foo .) . bar are just evil.
14:46:50 <nurupo> Could not find module `Data.Text' \ Perhaps you meant Data.Set (from containers-0.4.2.1) \ Use -v to see a list of the files searched for.
14:46:52 <nurupo> huh
14:46:59 <nadirs> ion: I like using (.) whenever I can, though I often worry whether I'm forcing its use or not :P
14:47:32 <nadirs> nurupo: had that exact issue earlier on today
14:47:35 <nurupo> i'm trying to import Data.Text in order to use `chunksOf`
14:47:42 <eikke> monochrom: ah, I think I start to understand what you mean
14:47:50 <nadirs> just install the haskell platform (or ghc-mod)
14:47:52 <monochrom> a more semantic way: in "caseF whatever (\x -> ...) a", how do you know that x does not contain a Throw down the road?
14:48:24 <eikke> I need to keep applying catch all the way till the end somehow
14:48:29 <nurupo> emacs?
14:48:30 <nurupo> why
14:48:34 <monochrom> yes
14:49:06 <eikke> so something like (Free . fmap (\a'' -> catch a'' handler))
14:49:20 * hackagebot ADPfusion 0.2.0.3 - Efficient, high-level dynamic programming.  http://hackage.haskell.org/package/ADPfusion-0.2.0.3 (ChristianHoener)
14:49:29 <eikke> monochrom: whoa, that compiles
14:49:50 <nadirs> nurupo: what OS are you in?
14:49:51 <nadirs> (notice how I'm explicitly avoiding the common joke Vimmers when Emacs is mentioned :P)
14:49:57 <nadirs> *Vimmers do
14:50:03 <nurupo> haskell-platform looks better :)
14:50:07 <ReinH> ion: (foo .) . bar is evil, foo .: bar is perhaps slightly less so
14:50:31 <ReinH> nadirs: us vim users  outnumbered here, I suspect
14:50:49 <nurupo> nadirs: kubuntu 12.04
14:51:09 <nadirs> ReinH: I've noticed that tendency too (around the web) :P
14:51:48 <nadirs> nurupo: you've already found the package (on apt maybe?) you needed?
14:51:52 <nurupo> nadirs: ghc-mod depends on >emacs23 emacs23-bin-common emacs23-common haskell-mode libm17n-0 libotf0 m17n-contrib m17n-db
14:51:57 <nurupo> yeah, i got it
14:52:01 <nurupo> no problem :)
14:52:10 <nurupo> haskell-platform it is
14:52:12 <nadirs> nurupo: good :)
14:52:34 <nadirs> it's strange ghc-mod requires emacs
14:52:37 <nurupo> i just asked why does ghc-mod depend on emacs
14:52:40 <nadirs> I've just installed it
14:52:41 <eikke> monochrom: thanks a lot
14:52:47 <monochrom> you're welcome
14:52:53 <chrisdone> the whole "emacs is an OS lolol" joke would be a joke if it wasn't entirely true and "uh huh?"-worthy =)
14:53:12 <nurupo> anyone here from emacs irc client?
14:53:16 <chrisdone> me
14:53:25 <ReinH> chrisdone: I particularly enjoy the games. Shame about the text editor. Etc.
14:53:32 <nadirs> but I've no emacs
14:53:52 <monochrom> emacs is just one concurrency library away from being an OS.
14:53:53 <chrisdone> i feel violated when someone VERSION's me
14:54:04 <nurupo> chrisdone: :P
14:54:04 <nadirs> chrisdone: quoting big Bob Kelso: "it's funny cause it's true"
14:54:30 <monochrom> I used to do email and newsgroups in emacs
14:54:56 <sellout-> chrisdone: My favorite part of the joke is “… lacking a decent text editor”, since Emacs has a Vim implementation.
14:54:56 <monochrom> also, please CTCP TIME me, you won't regret it :)
14:55:00 <chrisdone> nadirs: i dunno, there has to be an element of ludicrousness about it. probably it only works within the vim community
14:55:41 <chrisdone> it's like that steve yegge post about haskell, i guess
14:55:53 <nurupo> i also have custom ctcp
14:56:04 <chrisdone> haskellers didn't find it that funny
14:56:10 <ReinH> sellout-: Emacs has a bug-ridden implementation of half of vim :)
14:56:27 <monochrom> what did it say? "haskell is a static type non-strict functional language"?
14:56:43 <chrisdone> monochrom: http://steve-yegge.blogspot.it/2010/12/haskell-researchers-announce-discovery.html
14:57:02 <chrisdone> ReinH: vim has a bug-ridden implementation of 1% of emacs
14:57:03 <monochrom> oh well
14:57:30 <monochrom> perhaps I should write a "vim researchers announce discovery of industry users who care" too
14:57:33 <chrisdone> ReinH: although maybe 1% is too high a figure, thinking about the feature disparity
14:57:46 <ReinH> chrisdone: vim folks wouldn't call those "features
14:58:15 <ReinH> chrisdone: Also I'm worried that I won't be able to find affordable foot pedals, etc.
14:58:41 <nadirs> oh my, whs
14:58:52 <nadirs> *what did I started :P
14:59:00 <chrisdone> monochrom: i think it's a group thing. it's like how if you're an american black guy who's grown up in that culture, you're not comfortable with people outside of that culture using the word 'nigga'. similarly, nerds don't like non-nerds using the word 'nerd' in a similar amicable way
14:59:23 <Saizan> i still don't get what/who is being made fun of in the yegge post
14:59:25 <chrisdone> you can't self-deprecate a culture you yourself aren't a part of, i think is the key
15:01:33 <silver> Saizan, all of them!
15:02:39 <chrisdone> Saizan: sums it up http://www.reddit.com/r/haskell/comments/eeqw9/steve_yegge_haskell_researchers_announce/c17ljr9
15:03:04 <mloveless> please pardon the noob question but I've fallen into the ghci and cannot get out! halp pls?
15:03:18 <nadirs> admittedly I found Yegge's article quite amusing
15:03:35 <Saizan> mloveless: :quit
15:03:46 <mloveless> :Saizan thanks!
15:04:05 <nadirs> as a person who is IRL surrounded by people who don't give a shit about Haskell
15:04:47 <nurupo> how do i deal with the Data.Text error? https://gist.github.com/nurupo/5204b6a50ce86ceac1ed
15:05:13 <nurupo> ignore the missing main
15:05:34 <chrisdone> you're mixing String and Text
15:05:36 <chrisdone> what's the question?
15:06:22 <nurupo> oh, there are pack and unpack functions
15:06:34 <nurupo> btw, what is the difference between Text and String?
15:06:40 <chrisdone> there are, but then what would be the point in using text?
15:06:48 <chrisdone> oh
15:06:55 <ehtesh> Has anyone tried out haskell koans? I'm having a hard time getting it running with cabal sandbox on my machine. Here's some output: https://gist.github.com/shurane/40c54de823a6c0a2c7bb
15:07:06 <nurupo> chrisdone: i need to return String eventually, since i use interact
15:07:08 <chrisdone> nurupo: read this documentation http://hackage.haskell.org/package/text-1.0.0.0/docs/Data-Text.html
15:07:23 <monochrom> cabal is at 1.19 already?!
15:07:24 <chrisdone> nurupo: you might as well use chunksOf from Data.List.Split
15:07:32 <chrisdone> n-n-n-n-n-nineteen
15:08:56 <nurupo> chrisdone: argh, Could not find module `Data.List.Split'
15:09:03 <chrisdone> cabal install split
15:10:08 <Eduard_Munteanu> Is there some TH magic that can take a typeclass and make a newtype for each method, and perhaps also make a GADT to represent the class?
15:12:12 <danilo2> Hello :) What editor / IDEwould you suggest for a big Haskell project? We are right now developing several Haskell libraries using cabal sandboxes and we are using sublimeText. I've tried SublimeHaskell, but it does not work in many situations. Even if everything is proper ocnfigured, youre not always getting syntax completion or type checkoing
15:12:53 <danilo2> I'm thinking right now about switching to vim, emacs or leksah, but I wanted to ask you if you are using one of these solutions and can tell if it is better than others?
15:12:53 <nurupo> chrisdone: now i get https://gist.github.com/nurupo/5204b6a50ce86ceac1ed
15:13:10 <nurupo> chrisdone: haskell errors are kind of confusing
15:13:38 <nurupo> why does it expect xs to be [[String]] anyway?
15:15:08 <c_wraith> nurupo: you sound like you've been paying attention to chrisdone's rant on reddit about tracking down type errors. :)
15:15:33 <Eduard_Munteanu> danilo2: emacs is workable even if you're a vim user, with evil... and haskell-mode seems to be the best IDE-ish thing for Haskell around.
15:16:02 <Eduard_Munteanu> I've recently switched to Emacs, from Vim.
15:16:07 <monochrom> please don't attribute to haskell what comes from GHC
15:16:26 <nadirs> danilo2: there's FPcomplete's IDE, but I've never used it, can't speak for it
15:17:02 <danilo2> Eduard_Munteanu: I see there are some people around using emacs here. Are you using it by yourself at work ?
15:17:03 <monochrom> @type chunksOf
15:17:04 <lambdabot> Int -> [e] -> [[e]]
15:17:09 <monochrom> nice
15:17:22 <ion> @quote emacs
15:17:22 <lambdabot> emacs says: [comment just above a bug in haskell-mode's elsip file] ;; Not sure if it's useful/needed and if it actually works"
15:17:24 <monochrom> @type concat . transpose . map (chunksOf 4)
15:17:25 <FireFly> danilo2: there are quite a few vimmers in here too, btw
15:17:25 <lambdabot> [[e]] -> [[e]]
15:17:29 <ion> @quote vim.*emacs
15:17:29 <lambdabot> ion says: let es = ["vim", "emacs", "nano"] in map (\e -> intercalate " and " (delete e es) ++ " suck, learn " ++ e) es
15:17:36 <FireFly> (use whichever editor you prefer--I happen to prefer vim)
15:17:38 <danilo2> nadirs: I looked at it - it does not have even text completion built in
15:17:41 <nurupo> oh, i see
15:17:41 <Eduard_Munteanu> danilo2: I'm not a typical example, I get to pick my own means, language included. :)
15:18:10 <nurupo> chrisdone: i found the mistake
15:18:32 <mgsloan> danilo2: It does have autocompletion - use Ctrl+Space
15:18:57 <danilo2> Eduard_Munteanu: I know. I think nobody using "Haskell" is typical programmer and can be grouped with others ;) But out of curious - are you using it in your everyday work ?
15:18:58 <mgsloan> danilo2: Not for anything but identifiers yet, but that's gonna happen sometime
15:19:49 <Eduard_Munteanu> danilo2: yeah, FSVO work. I have a few projects I'm Haskelling on at the moment.
15:20:33 <danilo2> Eduard_Munteanu: Ok, thank you :) Hmmm I think I'll go with emacs or vim. Trying emacs first :)
15:25:13 <Eduard_Munteanu> Though my impression of haskell-mode's indentation is rather negative.
15:25:28 <begriffs> danilo2: I made a screencast about using haskell with vim. Might be useful for you. http://blog.begriffs.com/2013/08/connecting-vim-with-your-haskell-repl.html
15:25:45 <ReinH> begriffs: nice! What vim plugins do you use?
15:25:51 <ReinH> (for haskell, specifically)
15:25:59 <danilo2> begriffs: watching it right now :)
15:26:08 <Eduard_Munteanu> Well, I tend to follow a more C-ish style, i.e. I prefer indenting a fixed amount instead of lining up after keywords.
15:26:15 <flebron> Hi. Why do I get a stack overflow in let n = 10^7 :: Int; r = getRandomR (0, 1); in do {x <- replicateM n r; y <- replicateM n r; return . sum $ zipWith (/) x y}?
15:26:36 <ehtesh> monochrom: seems like it, that's what cabal-git on archlinux said
15:26:41 <ReinH> danilo2: I often open ghci on a file and then use :e to pop open a vim session
15:26:46 <ReinH> begriffs: ^
15:27:24 <koala_man> flebron: replacateM can't be lazy, since the monad enforces ordering
15:29:40 <ReinH> begriffs: please keep doing stuff like http://blog.begriffs.com/2013/12/popularizing-haskell-through-easy-web.html :)
15:29:48 <ReinH> begriffs: because popularizing haskell ftw
15:30:15 <danilo2> ReinH, begriffs: ok, thats interesting. Does vim has got good hASKELL CODE AUTOCOMPLETION OR TYPE CHECKING ?
15:30:25 <danilo2>  ReinH, begriffs: sorry for the caps
15:31:58 <begriffs> danilo2: I haven't gotten the Haskell type integration working in vim, but there are plugins out there. I should give it another try.
15:32:02 <haasn> nurupo: (sorry for my late reply):
15:33:09 <haasn> > let x:xs = ["4","hello","world","foo","bar","XYZ","YZX","ABC"]; (data,rest) = splitAt (read x) xs in concat data ++ " |||| " ++ unwords rest
15:33:10 <lambdabot>   <hint>:1:66: parse error on input `data'
15:33:18 <haasn> > let x:xs = ["4","hello","world","foo","bar","XYZ","YZX","ABC"]; (vals,rest) = splitAt (read x) xs in concat vals ++ " |||| " ++ unwords rest
15:33:19 <lambdabot>   "helloworldfoobar |||| XYZ YZX ABC"
15:33:19 <begriffs> ReinH: yeah I'd like all this stuff to be easy. I still have a lot to learn myself about building real apps in haskell, but as I learn I'll share what I can through the blog and through tools.
15:33:20 <haasn> oops :)
15:34:24 <nurupo> if i have `data Something = Else Else Else` and `xs=[Else, Else, Else]`, what can i apply to create Something out of the list? something like `Something (xs !! 0) (xs !! 1) (xs !! 2)` ?
15:35:23 <shachaf> That first Else is different from the other two.
15:35:28 <shachaf> What's the type Else?
15:35:44 <nurupo> just some type
15:35:50 <shachaf> Wait, it seems like you're confused.
15:35:56 <jrmithdobbs> using lens ... I have a [MyType] and I want to modify a (the same) field of each MyType using the lens host_name, what I've got so far is: (zipper myListofMyTypes & withins traversed >>= withins host_name <&> focus .~ "what" <&> rezip)
15:35:59 <shachaf> Something isn't even a data constructor here.
15:36:22 <ReinH> danilo2: yes it does.
15:36:27 <jrmithdobbs> but that only modifies the head of [MyType] ... why?
15:36:30 <bos> @pl \a b -> f (g a b)
15:36:30 <lambdabot> (f .) . g
15:36:41 <bos> :t on
15:36:41 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
15:37:07 <ReinH> danilo2: check out neco-ghc for completion
15:37:19 <mzero> haasn: why would you have the index, as a string, at the start of that list?
15:37:32 <ReinH> danilo2: check out Syntastic for type checking and linting
15:37:33 <danilo2> ReinH: Ok, that is very nice. Are there some good configs out there or sohuld I spend a month collecting it for my own? :)
15:37:49 <ReinH> danilo2: I've got mine but it's somewhat ad hoc
15:37:51 <ReinH> one sec
15:37:55 <shachaf> on is one of those functions whose implementaiton is easier to understand than its type.
15:38:01 <shachaf> @src on
15:38:01 <lambdabot> (*) `on` f = \x y -> f x * f y
15:38:50 <nurupo> schell: if i have some data type and a list of values that type can be instantiated from, what functions can i apply to instantiate the it?
15:39:04 <nurupo> *instantiate it
15:39:34 <schell> i think you may have meant that for shachaf
15:39:42 <mzero> nurupo: That would only make sense if a) the data type's constituent data values are all of the same type - and b) the list is just the right length ---
15:39:48 <mzero> so, generally, this isn't done
15:39:57 <mzero> is there a reason you have the values in a list?
15:39:58 <nurupo> schell: right :)
15:40:13 <nurupo> mzero: a function returned them
15:40:22 <mzero> what do you expect to happen if the list is too short or too long?
15:40:28 <ReinH> danilo2: https://github.com/reinh/dotvim
15:40:45 <nurupo> mzero: they are of the same type and the length is always the right one
15:41:10 <mzero> if the function returning those values ALWAYS returns the right number of values - then it should be returning a tuple, not a list
15:41:14 <nurupo> i.e. the function always returns a list of 3 elements of the same type
15:41:15 <danilo2> ReinH: Thank you! I'll try it right now :)
15:41:40 <mzero> but let's say you're right - there is nothing direct - you need to pattern match the list to extract the values, then apply the constructor
15:41:52 <danilo2> ReinH: Btw. Does it supports cabalized libraries? (to typecheck them and provide code completion?)
15:42:06 <shachaf> nurupo: A list isn't the right type here, then.
15:42:11 <danilo2> ReinH: Do I have to somewhat config a project, or it should work out of the box ?
15:42:15 <mzero> so given   data Foo = Foo Int Int Int      then we can have    mkFooFromList :: [Int] -> Maybe Foo      and
15:42:28 <ReinH> danilo2: it'll use ghc to provide type / identifier info iinm
15:42:34 <mzero> mkFooFromList [a, b, c] = Just $ Foo a b c      ;  mkFooFromList _ = Nothing
15:43:23 <ReinH> danilo2: take a look at the neco-ghc docs
15:43:29 <danilo2> ReinH: Ok, so if I'm using Cabal to build my project and especially cabal sandboxes to develop several libraries at once, It is not supposed to work ?
15:43:32 <nurupo> mzero: what would change if that was a tuple?
15:43:45 <mzero> or if you want to live dangerously:     mkFooFromList :: [Int] -> Foo      mkFooFromList [a,b,c] = Foo a b c    ; mkFooFromList _ = error "There were supposed to be only 3!"
15:43:46 <danilo2> ReinH: Ah, ok
15:43:49 <danilo2> ReinH: thanks :)
15:44:21 <mzero> Ah - well if it were a tuple.....       mkFooFromTuple :: (Int, Int, Int) -> Foo     mkFooFromTuple (a,b,c) = Foo a b c
15:44:31 <mzero> easy peasy, and no chance for disaster (like there is with the list)
15:45:00 <nurupo> mzero: can i convert [a, b, c] to (a, b, c)?
15:45:12 <mzero> no - only by pattern matching -
15:45:20 <mzero>  again -- lists have no garuntee of size
15:45:30 <mzero> so you have to handle what happens if the list is too long or too short
15:45:31 <shachaf> Yes, but that's not a type. A type would be [a] -> (a,a,a) is harder.
15:45:44 <mzero> (this is actually a major advantage of Haskell - no cheating here!)
15:45:49 <shachaf> s/ is harder/
15:46:18 <mzero> by the time you convert [Int] -> (Int, Int, Int)   --- you might as well have constructed your Foo directly
15:46:31 <mzero> which leads to the question - why are you getting a list?
15:46:39 <monochrom> programming is full of XY problems
15:46:48 <mzero> are you parsing input and dont't know how many you'll have?
15:46:52 <ReinH> mzero: let uncurry3 f (a,b,c) = f a b c :)
15:47:17 <nurupo> mzero: the function just takes a list and transforms it
15:47:31 <nurupo> mzero: and returns a list of c elements
15:47:33 <mzero> but but - what if it is given a different sized list?
15:47:33 <heatsink> That's sexist, monochrom
15:47:40 <monochrom> haha
15:48:14 <nurupo> mzero: it still returns a list of c size. c as in constant
15:48:22 <ReinH> heatsink: well, given that XX is vastly underrepresented, XY is presumably the cause of most problems ;)
15:48:42 <mzero> then change that function - make it return a tuple
15:48:45 <tomejaguar> http://lpaste.net/96660
15:48:50 <mzero> list is the wrong type for such a thing
15:48:50 <tomejaguar> ^^ Quiz: what do you think the semantics should be?
15:48:54 <heatsink> I suppose so :)
15:49:14 <nurupo> mzero: then i need to convert the list to a tuple, that's why i asked that
15:49:38 <ReinH> nurupo: this would be easier to talk about if we knew what you were doing
15:49:50 <mzero> paste us a bit of code
15:50:23 <mzero> because follow you back --- you said it takes a list, and no matter what size, produces a list of 3 elements ---- that function should be trivial to change to produce a 3-tuple
15:50:38 <monochrom> oohhh, I love semantic questions
15:50:38 <shachaf> Or a Foo
15:51:27 <tomejaguar> monochrom: I love your answers, so it sounds like a great match :)
15:51:33 <mzero> indeed! Shoot for the Foo!  (actually, I'm waiting for nurupo to tell us that sometimes it is a Foo and sometimes a Bar... and then we want to show how to pass in a constructor.... :-)  )
15:51:34 <shachaf> i love monoids
15:51:36 <shachaf> they are so easy
15:51:53 <shachaf> mzero: That's just a CPSed tuple.
15:52:11 <monochrom> hmm, I don't know
15:52:40 <nurupo> mzero: one sec
15:53:04 <monochrom> I am inclined to #1. but I am just guessing. I don't know the semantics of SqlQuery.
15:53:36 <tomejaguar> monochrom: But if you had to give it a semantics, what do you think would make sense from a composability point of view?
15:53:38 <mzero> Monoids - it is hard to be believe that such a simple thing can be a source of such beauty and joy!
15:53:52 <shachaf> Monoids are just free monoid monad monad algebras.
15:54:02 <donri> mzero: monadplus on the other hand, such an ugly beast ;)
15:54:06 <monochrom> then I would define it to be #1
15:54:20 <mzero> watch who yer callin' ugly!
15:54:27 <mzero> :-)
15:54:33 <tomejaguar> monochrom: Do you have particular rationale for that?
15:54:55 <tomejaguar> (Just trying to gather some evidence here about what others think)
15:55:23 <Javran> @hoogle (Monad m) -> m a -> m ()
15:55:24 <lambdabot> Warning: Unknown type Monad
15:55:24 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
15:55:24 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
15:55:30 <monochrom> each SqlQuery is already its own select. if you >>= two SqlQuery's, it is the cartesian product of two select's.
15:55:41 <shachaf> @hoogle Monad m => m a -> m ()
15:55:41 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
15:55:41 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
15:55:41 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
15:55:44 <shachaf> Hmph.
15:55:45 <shachaf> :t void
15:55:46 <lambdabot> Functor f => f a -> f ()
15:55:51 <shachaf> Ah, better.
15:56:13 <Javran> shachaf: thanks, exactly this one.
15:56:35 <tomejaguar> monochrom: FWIW I agree with you.  However 2 is what esquelto generates.  My database library results in 2 for the "equivalent" structure of code.
15:56:47 <monochrom> of course, internal code can eliminate subqueries and simplify other ways. but I'm speaking conceptually.
15:57:56 <ReinH> is void = fmap (const ())?
15:57:59 <tomejaguar> Understood.  The two options are far from equivalent though (1 has one row, 2 potentially many)
15:58:19 <tomejaguar> ReinH: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Monad.html#void
15:58:23 <tomejaguar> (i.e. yes)
15:58:29 <ReinH> wewt
15:58:36 <shachaf> There is no other implementation.
15:58:43 <chrisdone> wüt
15:59:16 <tomejaguar> wʊt
15:59:26 <monochrom> I don't know esquelto's rationale
15:59:26 <mgsloan> wät
15:59:28 * hackagebot RNAFold 1.99.3.4 - RNA secondary structure prediction  http://hackage.haskell.org/package/RNAFold-1.99.3.4 (ChristianHoener)
16:00:01 <monochrom> but I would challenge them to prove that their semantics satisfy monad laws, if I cared enough
16:00:10 <donri> ReinH: or better, (() <$)
16:00:12 <chrisdone> it was proposed to change void = (() <$)
16:00:17 <donri> \o/
16:00:49 <chrisdone> as fmap (const ()) has lame performance implications
16:01:08 <shachaf> The functions are equal.
16:02:16 <nurupo> mzero: here https://gist.github.com/nurupo/5204b6a50ce86ceac1ed
16:02:43 <ion> class Functor f where { …; void :: Functor f => f a -> f () } There, now with even better performance.
16:02:45 <tomejaguar> monochrom: I think the rationale is "do the simplest thing that will possibly work to get a syntax a bit like SQL's"
16:03:01 <tomejaguar> I don't think having a decent semantics was ever high on the agenda.
16:03:05 <hopf> any advice on implementing the same kind of sieve here, only smarter and using less heap? http://lpaste.net/96662
16:03:38 <monochrom> that's how some people who monads, eh? "I just want to use do-notation in my EDSL"
16:03:47 <monochrom> s/who/use/
16:04:28 * hackagebot RNAdesign 0.0.2.1 - Multi-target RNA sequence design  http://hackage.haskell.org/package/RNAdesign-0.0.2.1 (ChristianHoener)
16:04:29 <monochrom> the road to PHP is paved with well-intentioned syntax
16:05:04 <monochrom> perhaps s/intentioned/intended/
16:05:36 <nurupo> mzero: `quarterly` takes (size of the list / 2) and list, and returns [[quarter1], [quarter2], [quarter3], [quarter4]]
16:06:04 <mzero> yes, I see now
16:06:19 <mzero> actually, I think there is a bug in there, but I get the idea
16:06:21 <mzero> I'd do this
16:06:27 <mzero> I'd change the signature to
16:06:35 <chrisdone> shachaf: fmap (const ()) can only be no-oped when you know the Functor instance at compile time. so you might end up jumping through a bunch of monad layers with polymorphic code. (() <$) doesn't suffer from this problem
16:06:49 <mzero> quarterly :: Int -> [String] -> ([String], [String], [String], [String])
16:06:58 <mzero> and inside do
16:06:59 <nurupo> mzero: i recursively divide the matrix into quarters and eventually construct a tree in the `otherwise` cause
16:07:18 <tomejaguar> monochrom: Right, it's a big pain.
16:07:21 <mzero> let [a, b, c, d] = transpose .......    in (a, b, c, d)
16:07:46 <mzero> that will at least cause the system to fail at the simplest point where it should not
16:07:49 <mzero> NOW
16:07:54 <shachaf> chrisdone: Yes, but the functions are equal.
16:08:17 <mzero> in buildTree you can do something like        let (a, b, c, d) = quarterly ....  in Node a b c d
16:09:07 <chrisdone> shachaf: so?
16:09:09 <mzero> your code would probably be cleaner if it you defined   type CharArray = [String]
16:09:31 <nurupo> ><mzero> let [a, b, c, d] = transpose .......    in (a, b, c, d)
16:09:34 <nurupo> how do i do that?
16:09:44 <mzero> you write exactly that
16:10:22 <mzero> sorry      let s = transpose....      [a, b, c, d] = (concat . s . s) xs   in (a,b,c,d)
16:10:27 <mzero> move the computation into the let
16:10:30 <Cylta> about heavy calculations, like matrix multiplication. Can haskell with it lazy calculation actually handle millions of equasion in memory, if I actually need very small portion of this data calculated?.. seems like a good idea, if haskell will fnd a way how to avoid calculating everything else. from other side, size of stack should be enormous... Does it work for heavy calculations, or I do better simply use "do" everywhere?
16:10:47 <mzero> (use a semicolon, or put the second equation on its own line)
16:11:09 <nurupo> mzero: could you just give a full line? :)
16:11:10 <mzero> do you expect each branch of a Node to have the same depth?
16:11:28 <ReinH> shachaf: so fmap (const ()) and (() <$) are equal in some sense, but there may be performance implications for the fmap version?
16:11:41 <mzero> let s = transpose . map (chunksOf n); [a,b,c,d] = (concat . s . s) xs in (a,b,c,d)
16:12:02 <nurupo> oh, that makes sense
16:12:05 <ReinH> (equal in the obvious sense of function equiality, I suppose)
16:12:06 <shachaf> There are performance implications for both. They might be different.
16:12:11 <ion> reinh: (<$) is in the Functor class so an instance can theoretically provide a more efficient implementation than fmap . const
16:12:22 <ReinH> ion: makes sense.
16:14:25 <chrisdone> ReinH: this is why edwardk proposed changing it in base
16:14:46 <nurupo> mzero: as of now they are of the same length, aren't they?
16:14:56 <nurupo> i might change that later
16:15:00 <mzero> what are?
16:15:23 <nurupo> >do you expect each branch of a Node to have the same depth?
16:15:40 <nurupo> branches
16:16:24 <mzero> also, your declaration for QuadTree doesn't do what you think
16:16:48 <mzero> data QuadTree = Pixel Pixel | Node ...     is probably what you wanted
16:17:35 <nurupo> what is the default type of Pixel in data QuadTree = Pixel | ...?
16:17:39 <nurupo> Num?
16:17:46 <mzero> that is a nullary constructor
16:17:52 <mzero> like Nothing or True or False
16:17:53 <nurupo> hm
16:17:55 <mzero> or []
16:18:26 <mzero> so you have the data type Pixel having two nullary constructors   Black and White
16:18:49 <mzero> whereas QuadTree has a nullary constructor (no data!) called Pixel, and a 4-constructor called Node
16:19:01 <ReinH> Cylta: you can, e.g., map a function onto a matrix containing a million members and then, if you only retrieve a few of those values, only evaluate those few function applications.
16:19:14 <ReinH> Cylta: but there is nothing magical about "do" that would help here.
16:19:30 * hackagebot threefish 0.2.5 - The Threefish block cipher and the Skein hash function for Haskell.  http://hackage.haskell.org/package/threefish-0.2.5 (AntonEkblad)
16:19:31 <johnw`> ReinH: hello!
16:19:51 <nurupo> it still complains about types, huh
16:20:05 <ReinH> > head 10 $ map (+1) [1..]
16:20:06 <lambdabot>   Could not deduce (GHC.Num.Num [[GHC.Integer.Type.Integer] -> t])
16:20:06 <lambdabot>    arising...
16:20:11 <ReinH> woops
16:20:15 <ReinH> > take 10 $ map (+1) [1..]
16:20:16 <Cylta> ReinH: i mean, that if I have to calculate a row or a column to get a specific value. normally I would calculate whole table and later use that data. but with haskell it's probably possible to ask it to calculate only required columns\rows.
16:20:16 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
16:20:18 <ReinH> johnw`: hi
16:20:53 <ReinH> Cylta: depending on the data structure you are using, yes. The above maps a function onto an infinite list and only calculates the first 10.
16:21:14 <johnw`> Cylta: it's possible in other languages too, it's just that Haskell makes it very natural to do so
16:21:27 <ReinH> Cylta: You might want to look at Data.Vector, Data.Array, or things like Repa
16:21:43 <johnw`> for C++ there is a library called "Blaze" which will let you compute only the parts of the matrix computation that are actually needed
16:21:52 <ReinH> Cylta: so if Haskell can handle infinity I'm pretty sure it can handle millions ;)
16:22:15 <Cylta> ReinH: haha =) okay =)
16:22:28 <Cylta> ReinH: but i'm talking about million steps in depth..
16:22:31 <merijn> Any pipes experts around that can weigh in on the possibility of "closing" one direction of a bidirectional pipe?
16:23:45 <nurupo> mzero: Couldn't match expected type `QuadTree' with actual type `Pixel' \ In the first argument of `Node', namely `Black' \ In the expression: Node Black Black Black Black
16:23:50 <nurupo> with Pixel Pixel
16:24:44 <johnw`> merijn: what do you use bidirectional pipes for?
16:24:51 <mzero> Yes, because Black is a value of type Pixel, and the values in Node need to be a QuadTree
16:25:06 <nurupo> oh
16:25:09 <mzero> so you'd need to write    Node (Pixel Black) (Pixel Black) ...
16:25:10 <nurupo> that's ugly :)
16:25:15 <nurupo> yeah, just did that
16:25:22 <mzero> yes, because your base case isn't right!
16:25:35 <nurupo> ?
16:25:53 <mzero> your base case should be   | ["1"] = Pixle Black      |  ["0"] = Pixel White
16:26:08 <mzero> and if you think about it - you don't really need n!
16:26:19 <ReinH> Cylta: The question then becomes whether results of applying those steps are accumulated strictly or by building ever-longer thunk chains
16:26:41 <nurupo> oh, the branches are not of equal depth then
16:26:44 <mzero> I know this probably all seems harder than it should be.....
16:26:45 <ReinH> Cylta: and whether the compiler can optimize this for you
16:26:56 <L8D> Is there a shorter way to write \x -> x - 96 ?
16:27:02 <mzero> nurupo: sure they are
16:27:06 <nurupo> the base case shouln't be just a single number
16:27:08 <merijn> johnw`: I need to handshake on a socket, which means I need to "parse a bit, report what to send back on the socket, parse another bit, etc." until the handshake is done, at which point I can just stream frames
16:27:21 <L8D> Or really... (\x -> x - 96) . ord . toLower
16:27:24 <Cylta> ReinH: anyway. should I think of depth of haskell lazy stack, or most likely it's bigger, than I need?
16:27:54 <nurupo> mzero: the base case is a list of only 1's or 0's
16:27:55 <merijn> johnw`: Intially I was trying to use a unidirectional pipe, but then I need access to the relevant socket downstream in my pipeline. Which was 1) really cumbersome to write and 2) logically ugly
16:27:55 <mzero> did you want to replace any square block of all one color with a color
16:27:56 <mzero> ?
16:28:07 <mzero> you could do    | xs == replicate .... = Pixel Black
16:28:10 <mzero> !
16:28:12 <nurupo> mzero: not a single "1" or "0"
16:28:16 <merijn> johnw`: Although I'm open to better suggestions
16:28:17 <ReinH> Cylta: discussions of tail recursion vs guarded recursion like http://stackoverflow.com/questions/3429634/foldl-is-tail-recursive-so-how-come-foldr-runs-faster-than-foldl might be of use in understanding this
16:28:50 <nurupo> mzero: that's the thing i'm doing btw http://cs.fit.edu/~ryan/cse4250/quad.html
16:28:50 <mzero> BTW, nurupo - what do you plan to do if n and the dimensions of xs don't jive?
16:28:58 <mzero> perfect
16:29:11 <mzero> than instead of     Node (Pixel Black)....       just use   Pixel Black
16:29:17 <mzero> for those two lines
16:29:20 <ReinH> Cylta: this is another good one http://stackoverflow.com/questions/13042353/does-haskell-have-tail-recursive-optimization
16:29:45 <ReinH> Cylta: you can overflow Haskell's evaluation stack, yes.
16:30:05 <ReinH> > (iterate succ 1) !! 1000000
16:30:06 <lambdabot>   *Exception: stack overflow
16:30:09 <johnw`> ReinH: I learned the other day that what you're overflowing is the pattern matching stack
16:30:24 <nurupo> mzero: why so?
16:30:25 <ReinH> johnw`: for the above?
16:30:27 <johnw`> i.e., the pattern match is awaiting further evaluation before it can complete
16:30:44 <johnw`> in other words, there is no "call evaluation stack" as there is for other languages
16:30:53 <johnw`> let me find the reference
16:31:02 <ReinH> johnw`: I know there's no call stack. I think what I'm describing as the evaluation stack is in fact the pattern matching stack.
16:31:07 <johnw`> ah, ok
16:31:30 <ReinH> johnw`: SimonM talks about this a bit when he talks about backtraces :)
16:31:33 <ReinH> (in the podcast)
16:31:54 <ReinH> johnw`: he didn't flinch when I called it the evaluation stack so I guess I'm not being totally unintelligible when I use that term ;)
16:32:21 <ReinH> johnw`: but yes, would love a reference.
16:32:32 <merijn> johnw`: Anyway, I'll just go sleep or play video games and wait to see whether the pipes mailing list has any suggestions
16:32:40 <johnw`> http://www.haskell.org/haskellwiki/Stack_overflow
16:32:43 <johnw`> that's the page I was thinking of
16:32:58 <johnw`> merijn: Tekmo is usually active in a few hours, he'll know :)
16:33:03 <merijn> johnw`: Worst case I can use a "Maybe ByteString" as upstream pipe, but the downside of that is that you can "accidentally" send a Just upstream when it's no longer around
16:33:18 <merijn> johnw`: Yeah, but it's already 1.30 so I'm not staying up for him :p
16:33:47 <johnw`> merijn: oh well, I'm a conduit guy so I can't help :)
16:33:47 <merijn> i.e. I don't get as strong a static guarantee as I'd like
16:33:59 <johnw`> I added two new functions to stm-conduit last week: gatherFrom and drainTo
16:34:05 <L8D> Also, is there a simple way to sum two numbers in a tuple?
16:34:14 <johnw`> L8D: you mean, (4,3) => 7?
16:34:15 <ReinH> johnw`: cool
16:34:28 <nurupo> mzero: hm, actually, i think you are right. i want a pixel to be a base case
16:34:33 <L8D> johnw`: yeah
16:34:35 <mgsloan> > uncurry (+) (4,3)
16:34:36 <lambdabot>   7
16:34:47 <johnw`> mgsloan: I was about to use Lens :)
16:34:48 <ReinH> johnw`: Ah! I remember this page. I think this is why I call it an evaluation stack: "When GHC is evaluating a thunked expression it uses an internal stack. "
16:35:00 <L8D> mgsloan: cool
16:35:03 <mgsloan> johnw`: Hah, very "simple" :)
16:35:52 <ReinH> johnw`: yeah this is a great page thanks
16:36:16 <johnw`> ReinH: sure!
16:36:25 <L8D> How would you implement fibonacci using iterate?
16:36:52 <L8D> or is that possible?
16:36:56 <watermind> L8D: start with a pair
16:37:26 <watermind> and make a list of pairs
16:37:32 <watermind> for instance
16:37:43 <flebron> iterate (a, b) -> (a+b, a)
16:37:57 <flebron> starting with (1, 0)
16:38:07 <L8D> I could do: map fst $ interate (\(x,y) -> (y, x + y)) (0, 1)
16:38:35 <flebron> sure
16:38:35 <L8D> iterate*
16:38:43 <L8D> but that is ugly
16:38:55 <ReinH> L8D: maybe implementing fib with iterate is ugly :)
16:39:07 <L8D> haskell should never be ugly
16:39:31 <L8D> unless you’re working with HTTP requests
16:39:35 <ReinH> heh
16:39:53 <L8D> or implementing your own monads
16:40:05 <L8D> or working with Text
16:40:12 <ReinH> or implementing fib with iterate
16:40:21 <dmj`> fib = 1 : 1 : do { (a,b) <- zip fib (tail fib); return (a + b) }
16:40:23 <L8D> what’s the big deal with 'Text' ?
16:40:30 <ian_m> still don't see why it has to be ugly :)
16:40:46 <L8D> implementing fib with iterate is ugly
16:40:52 <L8D> and it doesn’t need to be
16:40:54 <johnw`> > sumOf both (3,4)
16:40:57 <lambdabot>   7
16:41:03 <flebron> if it is, it needs to be
16:41:05 <flebron> because it is.
16:41:08 <ReinH> fmapE: I like the applicative version.
16:41:17 <L8D> since there are prettier ways of implementing the fibonacci sequence
16:41:24 <flebron> not with iterate
16:41:33 <L8D> well, yes.
16:41:54 <L8D> but the point is, you don’t need to use the iterate method
16:41:57 <eikke> :t iterate
16:41:58 <lambdabot> (a -> a) -> a -> [a]
16:42:05 <flebron> in conclusion, eating soup with a fork is uncomfortable, and it doesn't need to be. there are better ways to eat soup, and they don't involve forks.
16:42:14 <L8D> > take 10 $ zipWith (+) fib (tail fib)
16:42:15 <lambdabot>   Not in scope: `fib'
16:42:15 <lambdabot>  Perhaps you meant `fix' (imported from Data.Function)N...
16:42:25 <L8D> whoops
16:42:48 <L8D> > fib = 0:1:zipWith (+) fib (tail fib); take 10 fib
16:42:49 <lambdabot>   <hint>:1:5: parse error on input `='
16:42:56 <L8D> > let fib = 0:1:zipWith (+) fib (tail fib); take 10 fib
16:42:57 <lambdabot>   <hint>:1:54:
16:42:57 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
16:43:02 <ReinH> heh
16:43:05 <flebron> s/;/in/
16:43:09 <L8D> > let fib = 0:1:zipWith (+) fib (tail fib) in take 10 fib
16:43:10 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
16:43:14 <flebron> there you go
16:43:29 <L8D> what’s the difference between in and where?
16:43:37 <ReinH> now for bonus points, write it using fix
16:44:15 <South> L8D: You can write let ..variables.. in ..function...
16:44:24 <nurupo> > let fib = 0:1:zipWith (+) fib (tail fib) in cycle fib
16:44:25 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:44:41 <South> L8D: Or ..function.. where ...variables
16:44:57 <L8D> > let fib = 0 : scanl (+) 1 fib in take 10 fib
16:44:58 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
16:45:02 <South> L8D: They're very similar, mostly stylistic, but sometimes one fits better than the other.
16:45:43 <L8D> hm...
16:45:43 <ian_m> > take 10 (fix ((0:) . scanl (+) 1))
16:45:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
16:45:59 <ReinH> ian_m: you get a cookie ;)
16:46:06 <ian_m> hurray
16:46:17 <L8D> isn’t that pretty much a y combinator?
16:46:23 <L8D> fix
16:46:24 <ReinH> ian_m: the zipWith version is interesting too as it uses applicative notation
16:46:28 <L8D> > :type fix
16:46:28 <ReinH> @src fix
16:46:28 <lambdabot> fix f = let x = f x in x
16:46:29 <lambdabot>   <hint>:1:1: parse error on input `:'
16:46:30 <flebron> eww
16:46:45 <flebron> let fib f (a, b) = (a+b):f (b+a,a)
16:46:58 <ReinH> zipWith (+) <*> tail is a useful combinator :)
16:47:33 <ReinH> and \f -> zipWith f <*> tail is more useful.
16:47:39 <flebron> > let fib f (a, b) =  (b + a): f (b + a, a); fix f = f (fix f) in (fix fib) (0, 1)
16:47:40 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
16:48:06 * flebron did not start his sequence with 0, commits sepukku.
16:48:07 <jrmithdobbs> :t (\f -> zipWith f <*> tail)
16:48:08 <lambdabot> (b -> b -> c) -> [b] -> [c]
16:48:18 <L8D> :t fix
16:48:19 <lambdabot> (a -> a) -> a
16:48:24 * flebron then pushes sepukku to master
16:48:25 <jrmithdobbs> :t (zipWith ($))
16:48:25 <lambdabot> [b -> c] -> [b] -> [c]
16:48:32 <johnw`> flebron: lol
16:48:57 <jrmithdobbs> so isn't \f -> zipWith f <*> tail ; just zipWith3; ?
16:49:00 <jrmithdobbs> :t zipWith3
16:49:01 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
16:49:07 <jrmithdobbs> oh noes, i see
16:49:10 <ReinH> > let pairwise f = zipWith f <*> tail; partiallyOrdered = and . pairwise (<=) in partiallyOrdered [1,4,2,3]
16:49:11 <lambdabot>   False
16:49:20 <ReinH> pairwise is not a great name, but w/e
16:49:21 <ian_m> for you iterate fans:
16:49:25 <ian_m> > take 10 $ map fst (iterate (uncurry (+) &&& fst) (1,0))
16:49:27 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
16:49:41 <L8D> :t (&&&)
16:49:41 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:49:52 <L8D> wut
16:49:52 <ian_m> see? not ugly
16:50:01 <L8D> ian_m: thank you
16:50:07 <ReinH> ian_m: fsvo ugly
16:50:09 <flebron> > not ugly
16:50:10 <lambdabot>   Not in scope: `ugly'
16:50:18 <ian_m> np :)
16:50:20 <L8D> rofl
16:50:46 <L8D> what is a cleaner way of writing: intercalate "\n" ?
16:51:32 <L8D> > intercalate "\n" $ words "asdf asdf asdf"
16:51:33 <lambdabot>   "asdf\nasdf\nasdf"
16:51:58 <ReinH> that's pretty clean.
16:52:21 <roboguy_> L8D: You could do unlines $ words "asdf asdf asdf"
16:52:21 <L8D> I don’t like the "\n", it needs to be '\n' only if there is a function that does so
16:52:28 <ReinH> but unwords might be cleaner
16:52:30 <ReinH> er unlines
16:52:40 <L8D> ooh
16:52:43 <L8D> unlines works
16:52:47 <monochrom> but unlies is slightly different
16:53:03 <ian_m> I prefer unlies to lies
16:53:22 <ReinH> I mean, if you want to intercalate "\n", I don't feel like saying intercalate "\n" is that dirty.
16:53:38 <roboguy_> L8D: unlines . words will give you a \n at the end though
16:53:42 <dmj`> > reverse . drop 1 . reverse . concatMap (++"\n") . words $ "asdf asdf"
16:53:43 <lambdabot>   "asdf\nasdf"
16:53:44 <monochrom> cleaner = intercalate "\n"
16:53:50 <monochrom> now cleaner is cleaner
16:53:59 <ReinH> this is the winner
16:54:15 <dmj`> double reverse ftw
16:54:24 <dmj`> ;)
16:54:28 <L8D> Well, I had: putStrLn $ intercalate "\n" wordlist
16:54:31 <monochrom> reverse . drop 1 . reverse will use too much memory on a long list
16:54:35 <L8D> now I have: putStr $ unlines wordlist
16:54:49 <roboguy_> L8D: ahh, okay that does work then
16:54:52 <ReinH> dmj`: sometimes you just want a little more O(n) in your function. ;)
16:55:00 <copumpkin> double reverse ftl
16:55:09 <copumpkin> you can do things to the end of a list without it
16:55:13 <copumpkin> while still being lazy!
16:55:25 <ReinH> copumpkin: via the cunning use of foldr!
16:55:26 <monochrom> double reverse consumes memory faster than light
16:55:32 <copumpkin> ReinH: or even weirder things!
16:55:47 <ReinH> I'm sure there are lots of weird things!
16:55:51 <monochrom> double reverse takes more time than chuck norris
16:56:06 <dmj`> ReinH: O(n) is my middle name
16:56:07 <copumpkin> @let foo n xs = zipWith const xs (drop n xs)
16:56:08 <lambdabot>  Defined.
16:56:12 <copumpkin> > foo 5 [1..15]
16:56:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:56:53 <L8D> :t foo
16:56:53 <lambdabot> Int -> [b] -> [b]
16:56:56 <ReinH> dmj`: that's a long, but not overly long, name.
16:56:58 <L8D> :t drop
16:56:58 <lambdabot> Int -> [a] -> [a]
16:57:11 <copumpkin> L8D: it's a lazy dropRight
16:57:23 <copumpkin> there's also a slightly roundabout way to write a fully lazy takeRight
16:57:24 <monochrom> "shot through the cache, and you're to blame, you give O(n) a bad name"
16:57:25 <L8D> :t dropRight
16:57:25 <lambdabot> Not in scope: `dropRight'
16:57:36 <ReinH> > take 10 . foo 5 $ [1..]
16:57:37 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:57:40 <ReinH> And so it is!
16:57:57 <L8D> > take 10 . drop 5 $ [1..]
16:57:58 <lambdabot>   [6,7,8,9,10,11,12,13,14,15]
16:58:30 <copumpkin> well, as lazy as you'd imagine a takeRight can be
16:59:04 <ReinH> copumpkin: it just sits around eating cheetoes.
16:59:19 <copumpkin> @let leftovers [] ys = ys; leftovers xs [] = xs; leftovers (x:xs) (y:ys) = leftovers xs ys
16:59:20 <lambdabot>  Defined.
16:59:24 <copumpkin> :t leftovers
16:59:24 <lambdabot> [t] -> [t] -> [t]
16:59:52 <copumpkin> @let dropRight n xs = zipWith const xs (drop n xs)
16:59:52 <copumpkin> @let takeRight n xs = leftovers xs (drop n xs)
16:59:53 <lambdabot>  Defined.
16:59:53 <lambdabot>  Defined.
16:59:59 <copumpkin> > takeRight 5 [1..15]
17:00:00 <lambdabot>   [11,12,13,14,15]
17:00:25 <copumpkin> it isn't necessarily productive (unlike dropRight), but it's lazy
17:00:34 <ReinH> right
17:01:38 <L8D> lazy as in...doesn’t use reverse?
17:02:00 <dmj`> skeet70: is that jon skeet?
17:02:08 <monochrom> lazy means on-demand
17:02:55 <L8D> well, technically any pure function should be lazy in Haskell
17:02:57 <copumpkin> L8D: it doesn't force the thing to all live in memory
17:03:06 <L8D> got it
17:03:13 <copumpkin> unlike reverse :)
17:03:17 <johnw`> > under reversed (take 5) [1..15]
17:03:18 <lambdabot>   [11,12,13,14,15]
17:03:30 <copumpkin> :)
17:03:36 <L8D> How are prelude take and drop non-lazy?
17:03:42 <copumpkin> they are lazy
17:03:45 <johnw`> worst fibonacci ever:
17:03:46 <L8D> oh
17:03:46 <johnw`> > foldr (\_ (reverse -> xs@(x:y:_)) -> reverse xs ++ [x + y]) [1,1] [1..10]
17:03:47 <copumpkin> they just operate on the other side of the list
17:03:47 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144]
17:03:53 <dmj`> @src reversed
17:03:53 <lambdabot> Source not found. Wrong!  You cheating scum!
17:03:54 <L8D> then what is the point of takeRight?
17:04:05 <L8D> nvm
17:04:05 <johnw`> dmj`: it's in lens
17:04:11 <ReinH> take 5 is best take.
17:04:38 <dmj`> johnw: ah lambdadot has no src info on lens?
17:04:51 <johnw`> would you seriously want it to? ;)
17:04:59 <dmj`> johnw`: good to see someone else sport the tilde btw
17:05:08 <dmj`> or whatever ` is
17:05:09 <johnw`> you mean the backquote?
17:05:13 <dmj`> ya :)
17:05:14 <L8D> grave or backquotes
17:05:17 <L8D> tilda is ~
17:05:18 <johnw`> > foldr (\_ xs@(reverse -> (x:y:_)) -> xs ++ [x + y]) [1,1] [1..10]
17:05:19 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144]
17:05:37 <johnw`> my znc instance is "johnw"
17:05:45 <L8D> 8~)
17:06:22 <L8D> ’`'
17:06:23 <identity> I'm not quite into sandboxes with cabal yet .. Is it really required to reinstall a package into a sandbox even if you have it 'globally'?
17:06:38 <identity> e.g. I have cmdargs installed, ghc is telling me it's not found
17:06:44 <monochrom> `^_^v has backquote too
17:06:50 <L8D> Why can’t every language in the world use npm?
17:06:55 <c_wraith> identity: required, and the whole point
17:07:00 <johnw`> what is npm?
17:07:05 <L8D> node package manager
17:07:08 <identity> c_wraith: ah. okay
17:07:17 <L8D> https://npmjs.org/
17:07:22 <c_wraith> identity: the whole point is that it builds things without depending on stuff installed globally.
17:07:38 <dmj`> identity: are you using hsenv or cabal sandbox
17:07:51 <identity> c_wraith: Yeah, I guess I get that. Except I would have figured it would go ahead and .. copy packages if it was possible or something
17:07:58 <identity> or maybe allow that as an option
17:08:01 <identity> dmj`: cabal sandbox
17:08:10 <monochrom> identity: see my http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox for a discussion
17:08:19 <nurupo> any idea what is wrong with my tree counting? https://gist.github.com/nurupo/5204b6a50ce86ceac1ed
17:08:55 <identity> monochrom: alright, I'll take a look
17:09:29 <nadirs> nurupo: typo on line 6,2
17:09:32 <L8D> nurupo: line 6, tree not thee
17:09:55 * nurupo facepalms
17:14:38 <monochrom> yes, it is a facepalm moment :)
17:14:42 <pavonia> nurupo: What about "sum $ map treeCount [a,b,c,d]"?
17:15:17 <nurupo> pavonia: what about it?
17:15:17 <monochrom> also, you may like: treeCountBlack (Pixel Black) = 1; treeCountBlack (Pixel White) = 0. then you don't need Eq.
17:15:52 <pavonia> nurupo: Just a suggestion for making it less verbose
17:16:16 <nurupo> pavonia: i don't understand what your code does
17:16:26 <nurupo> and it seems still to require treeCount
17:16:40 <monochrom> oh christmas tree, oh christmas tree, how much I like to count thee!
17:16:54 <pavonia> nurupo: but it's shorter than "(treeCount a) + (treeCount b) + (treeCount c) + (treeCount d)" :)
17:17:10 <nurupo> i see
17:17:18 <pavonia> just a suggestion
17:19:35 <nurupo> pavonia: what does '$' do?
17:20:27 <pavonia> it's function application, so f $ g x is the same as f (g x)
17:20:53 <pavonia> but due to its precedence you don't need the parentheses
17:23:02 <dmj`> @src ($)
17:23:02 <lambdabot> f $ x = f x
17:23:24 <L8D> nurupo: basically, it evaluates everything to the right of it first
17:23:30 <dmj`> nurupo: it is the parenthesis replacer
17:23:46 <nurupo> nice to know
17:24:21 <L8D> so instead of: print (map toLower (words "asdf"))
17:24:33 <L8D> you can do: print $ map toLower $ words "asdf"
17:25:05 <nurupo> @src .
17:25:05 <lambdabot> (f . g) x = f (g x)
17:25:05 <lambdabot> NB: In lambdabot,  (.) = fmap
17:25:24 <joneshf-laptop> hmm, does cabal only install each package with one core when you use `-jX` or whatever the multicore flag is?
17:25:43 <Cale> L8D: That would imply that it was strict function application.
17:25:51 <Cale> L8D: The stuff to the left will still be evaluated first
17:26:09 <Cale> f $ x = f x, it's just that $ has low operator precedence
17:27:40 <L8D> is `f $ x = f x` psuedo code?
17:27:44 <Cale> no
17:27:51 <Cale> That's the definition in the Prelude
17:27:58 <L8D> I thought you have to do: ($) f x = f x
17:28:05 <Cale> nope
17:28:20 <Cale> So f $ x will still proceed with the evaluation of f, and x will only be evaluated if f or something inside it decides to pattern match on it.
17:28:21 <L8D> then why have I been defining my operators that way all along?
17:28:26 <Cale> I don't know
17:28:30 <Cale> You don't have to
17:28:45 <L8D> :(
17:29:04 <L8D> :( looks even sader with a monospaced font
17:29:15 <identity> wat, no Text instance of Default?
17:31:02 <Cale> What class is Default?
17:31:28 <triliyn> It's probably something like class Default a where def :: a
17:31:28 <Cale> Oh this? http://hackage.haskell.org/package/data-default-0.5.3/docs/Data-Default.html
17:31:31 <identity> yep
17:31:34 <identity> cmd args uses it
17:31:35 <Cale> Why not use mempty?
17:31:35 <triliyn> For producing arbitrary values of member classes
17:31:40 <identity> Cale: I don't know, really
17:31:51 <identity> it exists for string, precisely as ""
17:32:13 <identity> maybe I'll submit a pull request
17:32:22 <Cale> All of these as far as I can tell are monoids
17:34:01 <identity> Would it not be possible to define a general instance for all monoids, then?
17:34:14 <identity> instance Monoid a => Default a where def = mempty?
17:34:33 <copumpkin> that overlaps with everything
17:34:43 <triliyn> Doesn't it only overlap with monoids?
17:34:58 <shachaf> No. It overlaps with everything.
17:34:58 <copumpkin> not given the resolution mechanism
17:35:04 <identity> oh
17:35:07 <copumpkin> first it looks at the instance head
17:35:27 <Cale> It only checks the constraint *after* committing to the instance
17:35:55 <triliyn> hmm, okay
17:36:06 <identity> So it looks at "a", in this case, and then starts checking constraints?
17:36:20 <Cale> (it has to be that way, because it's always possible that you provide an instance to satisfy the constraint in a future module)
17:36:49 <Cale> yeah
17:36:53 <identity> i see.
17:37:03 <Cale> Once it decides that "yes, this instance matches"
17:37:17 <Cale> So that instance will overlap with anything else
17:39:49 <lispy> Just use overlapping instances, geez ;)
17:40:05 <lispy> And if you still have issues, flip on incoherent instances
17:41:25 <lispy> For some reason that just made we wonder. Would OO inheritance work better if there was a contract for each case that required certain laws. Like we do for type classes.
17:41:46 <monochrom> overlapping instance does not fulfill the "provide a default" specification
17:42:19 <monochrom> yes. in fact multiple inheritance isn't a problem when contracts are present and enforced
17:42:41 <monochrom> multiple inheritance is merely a pushout or pullback, I forgot which.
17:43:10 <lispy> I see what you did there. You brought up CT
17:43:13 <monochrom> maybe I should throw in "pushback" and "pullout" for good measure :)
17:43:18 <lispy> heh
17:43:43 <L8D> I wonder if I could use npm with Haskell/Cabal
17:44:30 <lispy> That sounds like a bad idea
17:44:33 <lispy> :)
17:44:48 <lispy> The one time I had to use npm I kept getting type errors at run-time :(
17:45:05 <lispy> So I'm just imagining cabal hell + run-time type errors
17:47:46 <monochrom> are you two talking about the same npm?
17:48:17 <Cale> What's npm?
17:48:24 <lispy> I'm thinking of node package manager
17:48:30 <lispy> it's a javascript ism
17:49:14 <L8D> I’m thinking of node package manager
17:49:21 <L8D> lispy: what type errors?
17:49:55 <identity> well, submitted pull request
17:51:13 <L8D> JavaScript doesn’t have type errors, it has questionable behavior.
17:51:23 <L8D> [] + [] == ''
17:51:33 <joelteon> what curses binding do you guys suggest?
17:52:07 <L8D> joelteon: nanocursrs
17:52:27 <lispy> joelteon: vty?
17:52:35 <lispy> joelteon: and vty-ui if you're doing a gui
17:52:38 <mzero> hscurses
17:53:08 <lispy> (I think strictly speaking vty may not use ncurses at all, not sure)
17:53:41 <lispy> L8D: I think the type errors were in the package I was trying to use and not npm inself.
17:53:52 <lispy> L8D: it was something about a String not being a String
17:53:53 <joelteon> vty looks good in the "it has documentation" sense
17:54:04 <L8D> lispy: were you using javascript packages with it?
17:54:12 <lispy> joelteon: and vty-ui has a long pdf document describing proper use
17:54:19 <lispy> L8D: yeah
17:54:27 <L8D> that makes no sense
17:54:40 <L8D> npm doesn’t run any code when installing packages
17:54:59 <L8D> it just downloads them and reads their dependencies and then downloads those
17:55:09 <joelteon> wow, an actual PDF
17:55:27 <L8D> maybe a package's json file was broken
17:58:51 <lispy> L8D: I was just following the instructions. Maybe it was the install package that was freaking out and I got confused
17:59:47 <L8D> Well, my point is that npm kicks ass
18:00:23 <L8D> It’s fast, simple, and easy to use with any language or codebase that loads modules by file
18:00:45 <L8D> there are tons of ruby, python, and even C modules up on npm
18:01:12 <nlogax> I've had broken package.json files mucking stuff up. I don't understand how they managed to publish them, I guess there's no validation
18:01:49 <L8D> nlogax: well, npm needs to read the package.json in order to determine the version, name, dependencies, etc. in order to publish
18:02:07 <nlogax> L8D: Oh, then I don't know
18:02:41 <L8D> there are modules that don’t really use their package.json as well as they should however
18:04:02 <nlogax> Here's one, searched my emails https://github.com/mranney/node_redis/pull/185
18:06:04 <nurupo> what do i do if i want to add printing of an integer to a function?
18:06:14 <ReinH> joelteon: vty is kind of sketchy but vty-ui seems well written
18:06:31 <L8D> nurupo: As in...Have an integer printed when the function is called?
18:06:39 <nurupo> fun n = putStrLn $ show n; <rest of the function> -- doesn't work
18:06:54 <nlogax> nurupo: Check out Debug.Trace perhaps
18:07:09 <L8D> nurupo: Haskell is designed to do that stuff
18:07:22 <nurupo> i get Parse error: naked expression at top level
18:07:26 <L8D> Perhaps try: fun n = do
18:07:37 <L8D>   print n
18:07:46 <ReinH> well, putStrLn . show is just print
18:07:55 <ReinH> fun d = do { print n } is also just print
18:07:55 <L8D>   return <rest of function>
18:08:18 <L8D> ReinH: I can’t type that fast on these rubber domes!
18:08:53 <L8D> fun = do { print n; return <rest of function> }
18:09:02 <nlogax> nurupo: Yeah you need to use do notation or >> instead of ;
18:09:07 <ReinH> nurupo: if your function needs to do IO then it will need to be in the IO monad (unless you do it using unsafe IO, like with Debug.Trace)
18:09:07 <nisstyre> is there a function like (Show a, IsString b) => a -> b ?
18:09:07 * lispy hugs his cherry red mxs
18:09:23 <nisstyre> lispy: I have the same switches
18:09:46 <L8D> nisstyre: http://www.haskell.org/hoogle/
18:10:04 <lispy> nisstyre: I really enjoy typing on this keyboard and it's nothing special other than the cherry reds
18:10:10 <nisstyre> L8D: already did that
18:10:12 <lispy> nisstyre: does that match your experience?
18:10:20 <nisstyre> lispy: yes
18:10:29 <nisstyre> lispy: I also like how my keyboard could kill a person
18:10:33 <lispy> heh
18:10:57 <L8D> cherry blues man...MX blues...
18:11:11 <L8D> I’m tellin' ya mon
18:11:25 <L8D> Cherry MX Blues are _the_ shit bra
18:11:51 <nurupo>     Couldn't match expected type `Int' with actual type `m0 b0' \ Expected type: m0 a0 -> m0 b0 -> Int \ Actual type: m0 a0 -> m0 b0 -> m0 b0
18:16:09 <nurupo> so, how do i print an int in a function?
18:16:19 <nurupo> can't get it to work
18:16:35 <copumpkin> you don't
18:18:20 <Iceland_jack> nurupo: Do you want to pass the function a number to print?
18:18:21 <L8D> nurupo: fun n = do { print n; return <rest of function> }
18:18:40 <Iceland_jack> nurupo: fun n = print n (or simply, fun = print)
18:19:39 <ReinH> nurupo: http://www.haskell.org/tutorial/io.html
18:19:52 <ReinH> nurupo: or perhaps http://www.haskell.org/haskellwiki/Haskell_IO_for_Imperative_Programmers
18:20:04 <ReinH> nurupo: will helpe explain why you can't print from anywhere in a function
18:20:30 <nurupo> i just want to debug a function
18:20:32 <nurupo> https://gist.github.com/nurupo/5204b6a50ce86ceac1ed
18:20:43 <ReinH> nurupo: then use Debug.Trace
18:22:08 <ReinH> nurupo: you might enjoy this video https://www.youtube.com/watch?v=8tpCcSIVLf4
18:22:25 <nurupo> i still get the same error even with traceShow
18:23:09 <heatsink> You can't solve compile-time errors by inserting code to print stuff
18:23:26 <ReinH> nurupo: then figure out what the error is or tell us so we can help you
18:23:43 <ReinH> nurupo: but as heatsink says, if it won't compile then adding debug statements won't make it compile
18:23:50 <Hodapp> ...sometimes you can in C++ >_>
18:23:50 <nurupo> ReinH: it's in the pase i just posted
18:24:27 <heatsink> naruto, the paste you posted has 'print', which is causing the problem
18:24:32 <byorgey> nurupo: a function that returns Int cannot print things
18:24:48 <nurupo> even with traceShow it's the same error
18:25:07 <nurupo> heatsink: get my nick right
18:25:25 <joeyh> is it safe to call withSocketsDo more than once?
18:25:25 <byorgey> nurupo: can you show us what you mean by "with traceShow"?
18:25:30 <nlogax> nurupo: You're using return :: Monad m => a -> m a
18:25:46 <nlogax> nurupo: But you say `treeCountBlackPixels :: Int -> QuadTree -> Int`
18:25:55 <nurupo> nlogax: define Monad
18:25:56 <nlogax> nurupo: So if all you did was replace print with trace..
18:26:27 <nlogax> nurupo: Definitely not Int :)
18:27:10 <nurupo> nlogax: without that do {...; return ...} it works just fine
18:27:21 <nurupo> nlogax: `sum` returns an int
18:27:31 <nurupo> nlogax: where does the monad comes from?
18:27:39 <nlogax> nurupo: From your use of the `return` function
18:28:09 <nlogax> nurupo: Try something like treeCountBlackPixels n (Node a b c d) = traceShow n $ sum (map (treeCountBlackPixels ((n * n) `div` 4)) [a, b, c, d])
18:29:30 <nurupo> that works
18:29:41 <nurupo> still, i wonder what's wrong with return...
18:30:21 <nlogax> nurupo: You can get the type of stuff in ghci with :t functionName, if you do that for return you will see its type, and it doesn't match the type of your function
18:30:45 <nurupo> :t return
18:30:46 <lambdabot> Monad m => a -> m a
18:30:49 <nurupo> hm
18:30:59 <byorgey> nurupo: what's wrong with return is that your function is supposed to create an Int, and  do { print ...; return ... }  is not an Int.
18:31:10 <byorgey> it is an  IO Int.
18:31:36 <byorgey> in the same way that a recipe is not a cake.
18:31:37 <nlogax> nurupo: `do { stuff; morestuff; }` gets desugared into `stuff >> morestuff`, and (>>) :: Monad m => m a -> m b -> m b
18:32:12 <nlogax> So that's also a mismatch with your function type
18:35:58 <nlogax> nurupo: If you have `treeCountBlackPixels :: Int -> QuadTree -> IO Int`, then your code with print should work. Then you also need to `return` in your other equations, so that you get IO Int in those as well. But I suspect you didn't really want that
18:39:35 <ij> I'm really want to write some code that would use fftw. The dft wants a CArray (Complex r) -> CArray (Complex r), but isn't fft usually real -> complex? http://hackage.haskell.org/package/fft-0.1.6/docs/Math-FFT.html#v:dft
18:47:44 <ij> Oh, there's the real version below, how dumb.
18:49:49 * hackagebot zasni-gerna 0.0.6 - lojban parser (zasni gerna)  http://hackage.haskell.org/package/zasni-gerna-0.0.6 (YoshikuniJujo)
18:50:54 <quup> I run into functions with ' at the end, does that have any special meaning or is it the haskell equivalent of myVar etc?
18:51:21 <shachaf> I don't know what "myVar" means but it has no meaning to the compiler.
18:51:33 <shachaf> Sometimes it means a strict version, or a second version.
18:51:35 <Iceland_jack> quup: f' just a common way of denoting an “alternative definition” of g
18:51:38 <Iceland_jack> *of f
18:51:46 <quup> thanks
18:51:54 <Iceland_jack> Yes also what shachaf said
18:52:27 <quup> so when I see code with something'''''' it just means the writer was unimaginative then
18:52:46 <hpc> it means the writer didn't know what they wanted to do, i would say
18:53:18 <Iceland_jack> Maybe, also if you're practicing your Haskell and want to implement say the “head” function you can't call it head since it clashes with the one from the Prelude
18:53:34 <Iceland_jack> You could hide it (import Prelude hiding (head)) or just name your version head'
18:53:46 <Iceland_jack> Of course you wouldn't do this in a library
18:54:13 <triliyn> let ' = 6 in '
18:54:16 <triliyn> > let ' = 6 in '
18:54:17 <lambdabot>   <hint>:1:7: parse error on input `='
18:54:20 <triliyn> awww
18:54:33 <nurupo> :v
18:54:35 <shachaf> > let 'a' = 'b' in 'c'
18:54:36 <lambdabot>   'c'
18:55:00 <Iceland_jack> > let foo@'a' = 'a' in foo
18:55:01 <lambdabot>   'a'
18:55:07 <Iceland_jack> > let foo@'a' = 'b' in foo
18:55:08 <lambdabot>   *Exception: <interactive>:3:5-17: Irrefutable pattern failed for pattern fo...
18:55:41 <rck> using the Codec.Archive.Zip library that seems to use Data.Binary under the hood; when you feed the Zip lib an invalid bytestring (say, a text file or something) it calls  fail which just prints to stdout and continues. Is there some way to catch monadic fail here?
18:55:53 <nurupo> a language with reserved `foo` and `bar` :)
18:56:07 <Iceland_jack> nurupo: Who said it was reserved?
18:56:21 <nurupo> Iceland_jack: ?
18:57:06 <nurupo> i'm just talking about a hypothetical programming language
18:57:15 <nurupo> no idea what you are talking about
18:57:38 <Iceland_jack> I thought you'd mistaken the as pattern as a keyword
18:58:52 * nurupo just said something along the lines of "imagine a language in which `foo` and `bar` are reserved"
18:59:03 <Iceland_jack> Sure
19:00:01 <zomg> nurupo: that would be evil
19:00:20 <hpc> there's some precedent for it
19:00:29 <hpc> java reserves goto, but doesn't use it for anything
19:12:27 <nurupo> is there a nice way to split an Int number into a list of digits [Int]?
19:12:50 <shachaf> > map digitToInt "12345"
19:12:51 <Iceland_jack> map read (show number)
19:12:51 <lambdabot>   [1,2,3,4,5]
19:12:58 <Iceland_jack> ah or that ;P
19:13:05 <shachaf> > map digitToInt . show $ 12345
19:13:06 <lambdabot>   [1,2,3,4,5]
19:13:11 <shachaf> Or just do the usual thing.
19:13:27 <nurupo> > let fun n = concatMap n:[] in fun 12345
19:13:28 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable b0)
19:13:28 <lambdabot>    arising from a use ...
19:13:57 <shachaf> > unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, x `div` 10)) 12345
19:13:58 <lambdabot>   [5,4,3,2,1]
19:14:14 <shachaf> Of course that will handle 0 in the sensible way rather than the way you might want.
19:15:40 <Iceland_jack> can also use divMod
19:15:40 <Iceland_jack> > unfoldr (\x -> if x == 0 then Nothing else Just (swap (x `divMod` 10))) 12345
19:15:41 <lambdabot>   [5,4,3,2,1]
19:18:13 <nurupo> haskell doesn't support geometric series, right?
19:19:11 <shachaf> What does it mean for a language to support geometric series?
19:19:39 <nurupo> well, i mean generate a list of numbers that are of geometric series
19:19:52 <nurupo> i want to 1*1 + 2*5 + 3*25 + 4*125 ...
19:19:53 <triliyn> Not with syntax, but you can write a function that does it
19:19:58 <Iceland_jack> You can make such a list in Haskell
19:20:16 <triliyn> That is not itself a geometric series I think
19:20:26 <shachaf> Haskell supports lists of numbers (even colists!) and it supports generating them.
19:20:27 <triliyn> It's a... power series?
19:20:31 <copumpkin> > zipWith (*) [1..] (map (2^) [0..])
19:20:32 <lambdabot>   [1,4,12,32,80,192,448,1024,2304,5120,11264,24576,53248,114688,245760,524288...
19:20:40 <copumpkin> > zipWith (*) [1..] (map (5^) [0..])
19:20:41 <lambdabot>   [1,10,75,500,3125,18750,109375,625000,3515625,19531250,107421875,585937500,...
19:20:48 <Iceland_jack> > [ i % 5^i | i <- [1..] ]
19:20:48 <shachaf> Well, not every list of numbers.
19:20:49 <lambdabot>   [1 % 5,2 % 25,3 % 125,4 % 625,1 % 625,6 % 15625,7 % 78125,8 % 390625,9 % 19...
19:20:59 <copumpkin> > iterate (5*) 1
19:21:00 <lambdabot>   [1,5,25,125,625,3125,15625,78125,390625,1953125,9765625,48828125,244140625,...
19:21:13 <nurupo> wow
19:21:24 <nurupo> that's awesome
19:21:45 <copumpkin> > let series = 1 : map (5*) series in series
19:21:46 <lambdabot>   [1,5,25,125,625,3125,15625,78125,390625,1953125,9765625,48828125,244140625,...
19:22:35 <triliyn> shachaf: what lists of numbers does it not support?
19:22:38 <shachaf> > iterate hug copumpkin
19:22:39 <lambdabot>   [copumpkin,hug (copumpkin),hug (hug (copumpkin)),hug (hug (hug (copumpkin))...
19:22:55 <copumpkin> lol
19:22:56 <shachaf> triliyn: Uncomputable ones!
19:23:13 <nurupo> yeah, i like `iterate (5*) 1` :)
19:24:24 <triliyn> shachaf: hmmm, I was going to say you could enumerate every possible list of numbers but that doesn't work for lists of reals
19:24:37 <triliyn> (And haskell doesn't even have reals as far as I know, though floats are pretty close)
19:25:06 <shachaf> triliyn: You can't write a program to generate the busy beaver sequence.
19:25:40 <triliyn> shachaf: but the sequence is representable in haskell, isn't it?
19:25:47 <triliyn> You just can't know which one it is
19:25:49 <shachaf> What does that mean?
19:26:32 <triliyn> It seems like you should be able to define in haskell a list that contains every list of integers
19:26:41 <Hodapp> It can represent reals... just not all of them. Actually, if you pick a real number randomly, the probability is almost 1 that Haskell can't represent it.
19:26:43 <triliyn> I don't know, maybe I'm confusing it with the diagonalization argument
19:27:23 <shachaf> Are you counting infinite lists?
19:27:34 <triliyn> I think so...
19:27:38 <copumpkin> you can't
19:27:42 <shachaf> In that case, no.
19:27:47 <triliyn> Okay
19:27:57 <shachaf> By that diagonalization argument. :-)
19:27:59 <triliyn> hmmm, right, because infinite lists of integers can encode reals
19:28:08 <Hodapp> shachaf: can an uncountable list exist?!
19:28:15 <copumpkin> what does that mean?
19:28:17 <shachaf> I don't know what an uncountable list is.
19:28:44 <triliyn> A list that contains every element of an uncountable set?
19:29:25 <triliyn> I think such a thing can't exist, because then you could map the natural numbers onto the uncountable set
19:29:26 <Hodapp> that doesn't count!
19:29:40 <ReinH> triliyn: are uncountable sets enumerable?
19:30:05 <shachaf> I like the busy beaver sequence. It's a good sequence.
19:30:06 <triliyn> ReinH: not by the natural numbers
19:30:46 <ReinH> triliyn: are there other kinds of enumerable sets?
19:31:30 <triliyn> ReinH: "enumerable" sounds like it means "only by the natural numbers", but I wasn't completely sure
19:31:53 <Hodapp> I had thought that 'enumerable' meant that it could be put in 1:1 correspondence with the natural numbers.
19:32:12 <Feuerbach> that would be countable
19:32:33 <ReinH> perhaps enumerability isn't the best way to express this
19:32:43 <shachaf> I have no idea what anyone is trying to express.
19:32:58 <ReinH> shachaf: you are fond of saying that :)
19:33:13 <ReinH> triliyn: how would you construct an uncountable list?
19:33:31 <shachaf> You still haven't said what "uncountable list" means.
19:34:03 <triliyn> ReinH: I don't think you can, if we take "uncountable list" to be "a list containing every element of an uncountable set"
19:34:06 <codygman> Hi, I have some confusion with fmap and functional composition. Could someone help me figure out what I'm misunderstanding? Here is code which I'd like to return "excitingPosts": http://lpaste.net/96668
19:34:49 <shachaf> How about we say that Haskell has no uncountable types, because every Haskell program is finite. So there's no issue!
19:34:52 <codygman> what I'm not understanding*
19:35:04 <Iceland_jack> codygman: Where is the problem?
19:35:22 <nisstyre> shachaf: does Haskell have real numbers?
19:35:30 <shachaf> Only computable reals.
19:35:46 <nisstyre> fair enough I guess
19:35:49 <codygman> Iceland_jack: The excitingPosts function. I'm not composing things in the filter correctly I think?
19:35:54 <triliyn> hmmm, I wonder under what set of operations the computable reals are closed?
19:36:05 <triliyn> Addition and subtraction I'm pretty sure
19:36:09 <Iceland_jack> codygman: Well you don't seem to be using “posts” at all
19:36:12 <triliyn> Probably not exponentiation
19:36:20 <ReinH> :t fmap filter
19:36:21 <lambdabot> Functor f => f (a -> Bool) -> f ([a] -> [a])
19:36:31 <shachaf> Whichever the way the wind blows, / whichever the way the world goes, / Is perfectly all right with me!
19:36:35 <ReinH> triliyn: filter takes a list.
19:36:42 <triliyn> Actually I don't even know what the computable reals are; I'm thinking of algebraic reals, but that is also an interesting question
19:36:43 <Iceland_jack> :t map filter -- it should be map afaict
19:36:43 <lambdabot> [a -> Bool] -> [[a] -> [a]]
19:36:51 <Iceland_jack> :t map . filter -- oops
19:36:52 <lambdabot> (a -> Bool) -> [[a]] -> [[a]]
19:36:55 <Hodapp> I know some examples of things that are not computable reals.
19:36:58 <Feuerbach> shachaf: I'd call the type Integer -> Bool uncountable
19:37:00 <Hodapp> but I'm not sure what computable ones are.
19:37:14 <shachaf> Feuerbach: Every inhabitant of it is a finite Haskell program.
19:37:16 <Hodapp> halting probability would be uncomputable, right?
19:37:31 <codygman> Iceland_jack: I'm basically trying to filter a "Post" by title but return the actual [Post]
19:38:00 <nooodl> Hodapp: right
19:38:20 <ReinH> it looks like you want something like filter (maybe False (endsWith "!" . title))
19:38:22 <Iceland_jack> codygman: What is the “newPosts” doing there then?
19:38:38 <Hodapp> What about irrational numbers?
19:38:43 <ReinH> or filter (endsWith "!" . title) . mapMaybes
19:38:47 <Feuerbach> shachaf: well, it's just one of many possible denotations... but I see your point
19:39:08 <codygman> Iceland_jack: I'm just trying to simulate getting data from somewhere (like a webpage) that could have Nothings. basically it's a function to get posts from somewhere. Hope that makes sense.
19:39:11 <nooodl> ReinH: catMaybes?
19:39:16 <ReinH> er catMaybes yes
19:39:39 <shachaf> Feuerbach: Oh, you're ro-che.
19:39:41 <Iceland_jack> codygman: Are you sure you didn't mean to use the argument “posts” as “newPosts”?
19:39:48 <shachaf> I didn't know that was your nick. Or maybe I did and I forgot.
19:39:52 <codygman> Iceland_jack: I updated the code. I meant to take posts out of main: http://lpaste.net/96668
19:40:01 <Sgeo> Why do so many Haskell libraries suck?
19:40:50 <monochrom> oh neat, now we will have the next cartesian-closed comic debating over denotations of Nat->Bool
19:41:14 <Sgeo> scotty sucks and no one seems to realize... unless there's some ScottyM a -> ActionM a or similar that I can't find
19:41:56 <zomg> Sgeo: I'd imagine them to be accepting of patches adding any functionality that would make the library suck less
19:42:00 <Sgeo> If I have a Scotty application, I don't see a way to make it act as a sub-application
19:42:01 <nurupo> i think i'm starting liking haskell :)
19:42:23 <Sgeo> zomg: hmm, maybe I should look into that
19:42:42 <nurupo> > cycle "haskell "
19:42:43 <lambdabot>   "haskell haskell haskell haskell haskell haskell haskell haskell haskell ha...
19:43:16 <zomg> > let ballmer = cycle "developers "
19:43:17 <lambdabot>   not an expression: `let ballmer = cycle "developers "'
19:43:20 <zomg> aww
19:43:21 <zomg> lol
19:43:24 <ij> lol
19:43:29 <monochrom> prove or disprove: cycle "haskell " = cycle "haskell " ++ "kitty"
19:43:53 <nurupo> btw, why lambdabot uses '>'?
19:44:03 <nurupo> it's usually used for quoting
19:44:04 <nooodl> cycle "haskell " ++ "mushroom mushroom"
19:44:10 <shackleford> Does anyone have experience implementing other languages in Haskell? I'm working through Write Yourself a Scheme right now, and I was wondering what others might have to say about it.
19:44:22 <ReinH> nurupo: > is used for literate haskell programs
19:44:34 <zomg> shackleford: I implemented a partial php evaluator out of madness
19:44:37 <Sgeo> monochrom: I can't see a way to distinguish those by any means, not sure if that really means equiv. or not. Certainly Haskell couldn't prove equality
19:44:40 <Feuerbach> shachaf: yeah, I've got a few nicks to keep things interesting
19:44:47 <zomg> shackleford: the write yourself a scheme thing is pretty good I think
19:44:59 <Sgeo> Does Write Yourself a Scheme include call/cc?
19:45:02 <Sgeo> Maybe I should try it
19:45:04 <codygman> shackleford: How is Write Yourself a Scheme? I've got it scheduled for my next free weekend :D
19:45:13 <shackleford> zomg: You... you intentionally brought more PHP into the world?
19:45:25 <zomg> lol
19:45:43 <nisstyre> Sgeo: I doubt it
19:45:48 <zomg> What makes things worse it was actually slower than the php interpreter itself!
19:45:50 <nisstyre> Sgeo: but it shouldn't be hard to implement
19:46:00 <nurupo> shackleford: btw, now you can do almost everything with js + html5
19:46:19 <Sgeo> Would rather implement delimited continuations, but tutorials would be less likely to have those
19:46:36 <Sgeo> And undelimited continuations may be easier to implement for some runetimes
19:46:37 <zomg> nurupo: really depends what exactly it is you're doing but yeah a lot can be done with those
19:46:41 <monochrom> an independently written incomplete PHP interpreter is unlikely to bring more PHP to the world
19:46:43 <nurupo> shackleford: i saw a book recently, something like "developing applications for windows 8 with javascript and html5"
19:47:16 <ksira> Can anyone help me with the Template haskell needed to use n-D vectors in ekmett's linear library?
19:47:34 <zomg> Yeah I mostly did the php thing out of curiosity really, wanted to see how much I could bend Haskell to do something that behaved completely differently from it :D
19:47:36 <nurupo> here http://www.apress.com/9781430244011
19:47:44 <nurupo> >Pro Windows 8 Development with HTML5 and JavaScript
19:47:47 <shackleford> codygman: I like it. It's very well written, thoroughly explains all example code, and provides challenging extra steps. Note: If you run Ubuntu 13.04, there's apparently an oddity where the Text.ParserCombinators.Parsec isn't included via apt-get, and it wasn't there when I built the haskell platform from source either.
19:47:47 <nurupo> :)
19:47:55 <zomg> in case anyone is curious :P https://github.com/jhartikainen/hs-language-php
19:48:21 <nurupo> on linux one can develop with js + html too
19:48:57 <nurupo> QML or QWebKit based application
19:50:54 <Hodapp> QML isn't really HTML; it's just an EcmaScript dialect that Qt uses for some native stuff
19:51:06 <genisage> Does anybody know if there's a way to search for a function by type in ghci? In case I don't feel like going to hoogle.
19:51:09 <nurupo> yeah, it's not js
19:51:37 <monochrom> ghci cannot do it. you have to use hoogle.
19:51:39 <Ralith> genisage: you can install hoogle locally
19:51:41 <joelteon> genisage, you could write a ghci command that uses hoogle
19:52:00 <genisage> okay, thanks.
19:52:15 <Sgeo> > (/) <$> sum <*> fromIntegral . length $ [1,2,3]
19:52:16 <lambdabot>   2.0
19:52:32 <nurupo> Hodapp: but with QWebKit it can be mostly js, here is an example https://github.com/thinreports/thinreports-editor
19:52:36 <Sgeo> > sum/fromIntegral.length $ [1,2,3]
19:52:37 <lambdabot>   No instance for (GHC.Show.Show a0)
19:52:37 <lambdabot>    arising from a use of `M6978416645834...
19:53:33 <shackleford> > [0..]
19:53:34 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
19:54:49 <genisage> What do the angle brackets do?
19:54:57 * hackagebot intset 0.1.1.0 - Pure, mergeable, succinct Int sets.  http://hackage.haskell.org/package/intset-0.1.1.0 (SamTruzjan)
20:00:51 <pavonia> :t (<$>)  -- genisage
20:00:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:00:58 <pavonia> :t (<*>)
20:00:58 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:01:45 <pavonia> <$> is fmap, <*> function application for Applicative instances
20:02:32 <Iceland_jack> > show <$> Just 255
20:02:33 <lambdabot>   Just "255"
20:02:42 <Sgeo> > (,) <$> [1,2,3] <*> [4,5,6]
20:02:43 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
20:02:44 <Iceland_jack> > (+) <$> Just 255 <*> Just 10
20:02:45 <lambdabot>   Just 265
20:03:14 <Iceland_jack> > let add = liftA2 (+) in Just 255 `add` Just 10
20:03:15 <lambdabot>   Just 265
20:04:02 <Sgeo> You know what sucks? When languages that have good variadic functions don't implement liftAn or liftMn or whatever when they're copying Haskell because... Haskell doesn't have it
20:05:04 <nurupo> how can i shorten (fun (var + 1) a) ++ (fun (var + 2) b) ++ (fun (var + 3) c) ++ (fun (var + 4) d) ?
20:05:07 <Iceland_jack> What languages don't do that?
20:05:31 <codygman> I'm still having some confusion with fmap. I've made a smaller example complete with the type error: http://lpaste.net/96673 Basically I'm trying to create the data source which the fmap example here would expect: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
20:05:32 <Sgeo> Iceland_jack: more like libraries, I guess
20:05:52 <Sgeo> http://sgeo.tumblr.com/post/38587255013/straight-translations-of-monads-from-haskell-to-x#disqus_thread
20:06:16 <Iceland_jack> nurupo: Something like: concat [ fun (var + i) j | i <- [1..4] | j <- [a,b,c,d] ]
20:06:48 <ReinH> Iceland_jack: that would require the ZipList monad though wouldn't it?
20:06:50 <Iceland_jack> Or: concat [ fun (var + i) j | (i, j) zip [1..4] [a,b,c,d] ] without an extension
20:06:59 <joelteon> will the Prelude in 7.8 have (<>) instead of (++)?
20:07:11 <Iceland_jack> No, just ParallelListComp
20:08:37 <ReinH> what about something like: concat $ zipWith (fun . (var+)) [1..] [a,b,c,d]
20:08:50 <Iceland_jack> Sgeo: That just sounds like unfamiliarity with why lift{A,M}{,2..5} exist, not sure what else to say
20:09:17 <nurupo> Iceland_jack: Not in scope: `i', `j'
20:09:40 <Iceland_jack> Meant to write: concat [ fun (var + i) j | (i, j) <- zip [1..4] [a,b,c,d] ]
20:10:05 <Iceland_jack> codygman: fmap does let you map over a list (it's the same thing as map)
20:10:06 <nurupo> heh
20:10:21 <Iceland_jack> You may want to map an fmap
20:10:23 <ReinH> Iceland_jack: right, you're just implementing your own ZipList ;)
20:10:31 <Iceland_jack> ReinH: What do you mean?
20:11:14 <Iceland_jack> It's one way of writing it, not implementing one thing or another
20:11:42 <codygman> Iceland_jack: So why am I getting that specific error? I thought I understood fmap, but I have something wrong and don't know what.
20:11:57 <ReinH> Iceland_jack: it behaves like ZipList is what I'm saying
20:12:01 <Iceland_jack> Sure
20:12:09 <Iceland_jack> using ZipList is very bulky
20:12:23 <ReinH> unfortunately, yes
20:12:43 <ReinH> Iceland_jack: but you can just zipWith fun . (var+) directly
20:12:58 <Iceland_jack> You can write it in many ways
20:15:18 <Sgeo> Hmm. wai-extras has a jsonp middleware... but WAI middleware can only be applied to the Application as a whole, correct?
20:15:58 <Sgeo> If I were to use a jsonp middleware (which I'm not likely to do, but let's imagine), I would probably only want it on a select few resources
20:16:11 <zomg> Sgeo: as long as the types match you can do whatever
20:16:27 <Iceland_jack> codygman: (sorry I can't offer much constructive at this very moment, you should try to get a better feel for the difference between fmap and map trying your teeth on smaller examples)
20:16:34 <Sgeo> zomg: WAI middleware is just an Application -> Application
20:16:57 <zomg> Sgeo: yes, and you can have something else in front of it to determine whether it's the jsonp route or not and only then include the jsonp stuff :)
20:17:11 <codygman> Iceland_jack: Alright, will do.. Thanks for the help though.
20:17:29 <Sgeo> zomg: so a function that takes a middleware and a function to make that determination as arguments?
20:17:45 <zomg> Yeah for example
20:18:03 <Sgeo> maybeMiddleware :: (Request -> Bool) -> Middleware -> Middleware
20:18:19 <Sgeo> Don't know what that should be called or if it already exists
20:18:24 <shackleford> So, in the midst of writing my scheme, it occurred to me that since everything is a list in Scheme, all my standard functions could simple list handling. I then thought I could make one function that could fill the needs of the four arithmetic operators, which I cannot get to work. Is there anyway to get this done or should I write separate functions for each operator? code here --> http://lpaste.net/96674
20:19:32 <Sgeo> shackleford: could make a function to take a binary function and turn it into one that accepts a list
20:19:54 <Bor0> codygman, you need to wrap the fmap around a map, because you are working on [Maybe]
20:19:57 <Sgeo> There is already such a function. Try both writing one yourself and finding the pre-existing function, if your goal is to learn Haskell
20:20:47 <codygman> Bor0: Oh I see, thats what Iceland_jack was trying to say too I think.
20:20:52 <shackleford> Sgeo: Is it map I'm looking for?
20:20:53 <Sgeo> Oh, I guess that's what schemeOp is supposed to be?
20:21:02 <shackleford> Yes
20:21:06 <Iceland_jack> codygman: (yes: I also meant to write ‘cut your teeth’) :)
20:21:28 <Iceland_jack> > map (fmap show) [Nothing, Just 5, Nothing, Just 10]
20:21:29 <Sgeo> shackleford: I guess you're getting a type error?
20:21:29 <lambdabot>   [Nothing,Just "5",Nothing,Just "10"]
20:21:32 <triliyn> shackleford: I think you actually might be looking for foldr (or foldl)
20:21:37 <Sgeo> Look at how you're using schemeOp in its definition
20:21:55 <Iceland_jack> codygman: Does the above example seem helpful?
20:22:29 <Sgeo> hmm, I need to look closer at that
20:22:51 <codygman> Iceland_jack: Yes it does, though I think I need to read up more on types. I think I'll do the Learn Haskell the Hard Way tutorial again. It seems like a lot more things are clicking but I still have a lot of blind spots.
20:23:11 <Sgeo> shackleford: that type you wrote for schemeOp is a specialization of map, but is map really the function you want to write?
20:23:28 <Iceland_jack> No problem, just remember that ‘map’ is ‘fmap’ for lists
20:23:50 <Iceland_jack> > (fmap show Nothing, fmap show (Just 5))
20:23:51 <lambdabot>   (Nothing,Just "5")
20:23:55 <triliyn> Sgeo: it's not actually a specialization of map because the final result is b, not [b]
20:24:07 <Sgeo> ...ooh, oops
20:24:08 <Sgeo> >.>
20:24:13 <Sgeo> ty
20:24:34 <shackleford> Sgeo: Thinking about it now, the fold family makes more sense than map, but I need to read up on them, and make sure I understand them.
20:24:41 <ReinH> Sgeo: I think map is a specilization of the function you're talking about :)
20:28:35 <zomg> Sgeo: basically for the middleware, you could do something like have your handler that does the processing as `Application`, then you could easily have another `Application` which looks at the pathInfo, and then say if the pathInfo is "jsonp", you return `jsonp myHandler`
20:29:14 <zomg> Sgeo: that way you could easily test if the URL matches something and handle it differently
20:29:20 <nurupo> why does `map read (words "9 14 17 22 23 44 63 69 88 94 113 -1")` fail?
20:29:24 <nurupo> > map read (words "9 14 17 22 23 44 63 69 88 94 113 -1")
20:29:25 <lambdabot>   [*Exception: Prelude.read: no parse
20:29:37 <shachaf> Try a smaller example.
20:29:50 <Iceland_jack> > map read (words "9 14 17 22 23 44 63 69 88 94 113 -1") :: [Int]
20:29:51 <lambdabot>   [9,14,17,22,23,44,63,69,88,94,113,-1]
20:29:56 <Iceland_jack> Works fine for me
20:30:01 * hackagebot purescript 0.1.15 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.1.15 (PhilFreeman)
20:30:06 <nurupo> oh, specify a type for read
20:30:17 <Sgeo> Why would... read throw an exception, instead of type erroring...
20:30:20 <triliyn> :t map read (words "5 a ;")
20:30:20 <lambdabot> Read b => [b]
20:30:22 <Sgeo> Should we blame defaulting?
20:30:35 <Iceland_jack> Sgeo: Yes basically
20:30:45 <Iceland_jack> > read "()"
20:30:46 <triliyn> What type was it defaulting to?
20:30:46 <lambdabot>   ()
20:30:49 <Iceland_jack> ↑
20:30:57 <triliyn> ...really?
20:31:09 <triliyn> That's such a weird choice
20:31:22 <nurupo> how can i `take` from the list, until an element equals X?
20:31:37 <Iceland_jack> That's not related to read it self but rather ghci
20:31:41 <nurupo> not equals X, i mean
20:31:47 <triliyn> Yeah, I know that
20:31:48 <Iceland_jack> nurupo: takeWhie
20:31:50 <simpson> :t takeWhile
20:31:51 <lambdabot> (a -> Bool) -> [a] -> [a]
20:31:51 <Iceland_jack> @ty takeWhie
20:31:52 <lambdabot>     Not in scope: `takeWhie'
20:31:52 <lambdabot>     Perhaps you meant one of these:
20:31:52 <lambdabot>       `takeWhile' (imported from Data.List),
20:31:55 <Iceland_jack> @ty takeWhile
20:31:56 <lambdabot> (a -> Bool) -> [a] -> [a]
20:31:56 <triliyn> (Though I thought ghci only defaulted numeric types)
20:32:08 <nurupo> thanks :)
20:32:33 <Iceland_jack> triliyn: This happens when you try to test code using QuickCheck, if you do: verboseCheck (\x -> reverse (reverse x) == x) you'll get a bunch of lists of type [()]
20:32:46 <simpson> > takeWhile (<10) [1..]
20:32:47 <lambdabot>   [1,2,3,4,5,6,7,8,9]
20:33:41 <triliyn> > minBound
20:33:42 <lambdabot>   ()
20:33:49 <triliyn> hmmm, my ghci doesn't do that
20:33:54 <Iceland_jack> > minBound == maxBound
20:33:55 <lambdabot>   True
20:34:09 <triliyn> Prelude> minBound
20:34:10 <triliyn> <interactive>:2:1:
20:34:10 <triliyn>     Ambiguous type variable `a0' in the constraint:
20:34:10 <triliyn>       (Bounded a0) arising from a use of `minBound'
20:34:10 <triliyn>     Probable fix: add a type signature that fixes these type variable(s)
20:34:10 <triliyn>     In the expression: minBound
20:34:12 <triliyn>     In an equation for `it': it = minBound
20:36:47 <roboguy_> triliyn: minBound is different for different types
20:37:05 <roboguy_> so it needs either an explicit type signature or some other context that tells haskell what it's type is
20:37:15 <triliyn> roboguy_: I know; we are discussing the various cases in which some evaluators will default ambiguous types
20:37:16 <roboguy_> > minBound :: Int
20:37:17 <lambdabot>   -9223372036854775808
20:37:22 <Cale> roboguy_: I think triliyn's point was the fact that lambdabot is using more aggressive defaulting
20:37:23 <Cale> yeah
20:37:25 <roboguy_> ah, okay I missed that
20:37:42 <triliyn> And apparently quickcheck too
20:38:35 <roboguy_> > maxBound
20:38:36 <lambdabot>   ()
20:38:39 <roboguy_> Huh
20:38:50 <triliyn> GHCi doesn't do this
20:39:12 <triliyn> (Though I do think GHCi defaults numeric types to Integer or Float)
20:39:20 <shackleford> So, by using foldl1 I've written a function to handle arithmetic operations on lists, can this be improved? http://lpaste.net/edit/96674
20:40:07 <Iceland_jack> shackleford: I don't see the foldl1
20:40:23 <roboguy_> shackleford: I would say yes
20:40:48 <shackleford> Iceland_jack: Line 3
20:41:01 <Cale> schemeOp _ [] = 0 ?
20:41:11 <Iceland_jack> Line 3 is 'schemeOp _ [] = 0'
20:41:26 <Cale> Also, you linked the edit page
20:41:29 <roboguy_> wait, yeah I misread. I thougt you were asking if foldl1 could improve the code. I don't see foldl1 either
20:41:32 <roboguy_> wait, yeah I misread. I thougt you were asking if foldl1 could improve the code. I don't see foldl1 either
20:41:37 <roboguy_> wait, yeah I misread. I thougt you were asking if foldl1 could improve the code. I don't see foldl1 either
20:41:45 <Cale> roboguy_: ...
20:41:46 <roboguy_> oops sorry about that
20:41:57 <shackleford> Sorry, guys, didn't update the paste, here's the current code http://lpaste.net/96674
20:41:58 <roboguy_> I scrolled up and I thought it wasn't submitting that for some reason
20:42:19 <Cale> That *also* doesn't use foldl1
20:42:20 <roboguy_> shackleford: you can replace (x:xs) with xs
20:42:31 <Cale> oh
20:42:37 <Cale> after another refresh, it does
20:42:39 <Iceland_jack> Cale: Well it does for the non-empty case
20:43:01 <Cale> (My browser might've cached it)
20:43:19 <Cale> That seems broken for (*)
20:43:32 <Cale> schemeOp (*) [] will be 0
20:43:37 <Cale> which is derpy
20:43:47 <Iceland_jack> Exactly, you need an explicit empty value
20:44:15 <Iceland_jack> which is what you do with foldl
20:44:24 <shackleford> Cale: I get the same result with product [1..100], fwiw
20:44:28 <nurupo> > words (take 1 ["1 2 3", "4 5 6", "7 8 9"])
20:44:29 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
20:44:29 <lambdabot>              with actual type...
20:44:37 <Cale> shackleford: Well, that's fine for nonempty lists
20:44:46 <roboguy_> > product []
20:44:47 <lambdabot>   1
20:44:49 <Iceland_jack> nurupo: take 1 gives you a list, you want head
20:44:55 <Iceland_jack> > words (head ["1 2 3", "4 5 6", "7 8 9"])
20:44:55 <Cale> shackleford: But multiplying the empty list should give 1
20:44:56 <lambdabot>   ["1","2","3"]
20:44:59 <Iceland_jack> I believe
20:45:06 <nurupo> Iceland_jack: :)
20:45:24 <Cale> Because you want  product (xs ++ ys) = product xs * product ys
20:45:30 <shackleford> Cale:Ok, I'll change that, then.
20:45:58 <Cale> and so   product ys = product ([] ++ ys) = product [] * product ys
20:46:20 <roboguy_> shackleford: but summing an empty list should give you 0
20:46:25 <Cale> and cancelling product ys gets us  1 = product []
20:47:04 <copumpkin> @src tails
20:47:04 <lambdabot> tails []         = [[]]
20:47:04 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
20:47:35 <Cale> > tails "echo"
20:47:36 <lambdabot>   ["echo","cho","ho","o",""]
20:47:44 <Cale> > concat . tails $ "echo"
20:47:45 <lambdabot>   "echochohoo"
20:48:09 <Cale> > concat . inits $ "stutter"
20:48:09 <lambdabot>   "sststustutstuttstuttestutter"
20:48:16 <Iceland_jack> > "I " ++ (concat . tails $ "echo") ++ "se you"
20:48:17 <lambdabot>   "I echochohoose you"
20:50:05 <vonDraco> lmao @ the stutter
21:12:12 <monochrom> irc factoid: server does not send you what you said. when you see your own writing, it is your client's doing. corollary: you may not know whether the server receives it at all.
21:12:47 <monochrom> but if you hit <enter>, you do know your client sends it.
21:19:00 <heatsink> So your own speech doesn't always appear to yourself in the same order that other people see it?
21:19:16 <monochrom> that is right
21:19:25 <heatsink> IRC isn't sequentially consistent
21:24:51 <joelteon> right
21:34:25 <haasn> monochrom: attempts to send it
21:34:40 <haasn> if I'm not connected to the server in the first place, I'll get an error message instead
21:35:53 <monochrom> ah, right, good
21:37:22 <lispy> monochrom: my client slows down if I paste a lot of lines. Is that server or client side?
21:37:35 <lispy> I always assumed it was a throttling on the server side
21:37:35 <haasn> > view (_head.replicated 3 <> folded) "stutter"
21:37:36 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
21:37:36 <lambdabot>    arising from a use o...
21:37:54 <haasn> ah
21:38:01 <haasn> > toListOf (_head.replicated 3 <> folded) "stutter"
21:38:02 <lambdabot>   No instance for (Data.Monoid.Monoid
21:38:02 <lambdabot>                     (Control.Lens.Inter...
21:38:09 <haasn> grr, needs ‘base’ update
21:38:27 <haasn> lispy: could be both
21:38:34 <haasn> lispy: the way I know it, servers will just kill you for Excess Flood
21:38:44 <haasn> lispy: as usual, you can debug by pasting into a dumb client like netcat
21:39:03 * haasn tries
21:39:18 <lispy> haasn: cheers. I'm not set up to do that by hand at the moment :)
21:39:24 <monochrom> it is client side, lispy
21:39:26 <lispy> do let me know what you learn
21:40:04 <haasn> lispy: :adams.freenode.net NOTICE nand`test :*** Message to haasn throttled due to flooding
21:40:08 <haasn> I receive it slowly on my other client
21:40:22 <haasn> freenode does it server side. And if it does, you should get a NOTICE
21:40:32 <haasn> So you can check for NOTICEs when flooding to know if your client throttles or not
21:40:40 <lispy> oh right. freenode has extensions.
21:41:05 <haasn> the behavior of popular IRCds tends to be quite inconsistent I've found
21:57:23 <Kron> is there a computational overhead to wrap a value in a Just and then unwrap it later?
21:57:50 <Kron> like if you were trying to make a function that returns the last element of a list, is it slower to make it go [a] -> Maybe a and try to return Nothing if its given []?
22:00:04 <nurupo> can someone help me with a tree constructing? i described my problem here https://gist.github.com/nurupo/5204b6a50ce86ceac1ed
22:01:26 <Kron> nurupo, you can pattern match across x
22:01:39 <Kron> case x of 1 =
22:01:41 <Kron> 2 =
22:01:42 <Kron> 3 =
22:01:43 <Kron> etc.
22:01:59 <Kron> what exactly do you need help with?
22:02:43 <nurupo> oh, it's the last comment there
22:03:48 <nurupo> the provided code will create several instances of top-level nodes (subtrees), each instance of which will contain only a  single black pixel
22:04:10 <Kron> ahhhhh I see
22:04:32 <Kron> here's what you'd like to do, without exceptionally complicated mechanics:
22:04:40 <Kron> make an addTree function
22:05:02 <Kron> addTree :: String -> QuadTree -> QuadTree
22:05:12 <Kron> like that; it takes a given quadtree and returns a new quadtree with the new node in it
22:05:14 <Kron> not too difficult
22:05:27 <Kron> then simply fold your addTree
22:05:41 <nurupo> so i till have several 1st nodes with 1 pixel each, several 2nd nodes with 1 pixel in each, several 3rd nodes and several 4th nodes
22:05:42 <nurupo> when i want only one 1st, 2nd, 3rd and 4th nodes with all corresponding pixels in them
22:05:42 <nurupo> those are top-level nodes
22:05:56 <Kron> treelist = foldr addTree inputlist emptyTree
22:06:53 <nurupo> hm
22:07:09 <Kron> right now, I assume you're doing a map
22:07:18 <Kron> treelist = map constructTree inputlist
22:07:29 <Kron> and that will simply convert every pixel in the list into a tree, giving you a list of trees
22:07:41 <Kron> what you want to do is fold all the pixels into the same tree
22:07:41 <nurupo> don't understand
22:07:52 <Kron> okay, let me slow down
22:07:59 <Kron> do you know what a 'map' or a 'fold' is?
22:08:51 <nurupo> wow intenet. for some reason i'm getting ~15 lines of irc chat in a single second
22:09:12 <Kron> ah, that explains a lot
22:10:38 <Kron> do you have any questions about the solution I've posed for you?
22:10:47 <nurupo> Kron: map applies a function on every element of a list
22:10:47 <nurupo> Kron: don't know what fold does
22:10:52 <Kron> okay
22:11:10 <Kron> basically, fold takes a given function and recursively does it to everything in a list
22:11:25 <Kron> foldr (+) 0 [1,2,3,4]
22:11:33 <Kron> --> 1 + (2 + (3 + (4 + 0)))
22:11:45 <Kron> foldr is a "right fold", notice how the brackets slant rightwards
22:11:48 <nurupo> how is it different from map?
22:11:54 <Kron> a map does this:
22:11:58 <Kron> map (*2) [1,2,3,4]
22:12:04 <Kron> --> [2,4,6,8]
22:12:06 <tac> > map (*2) [1,2,3,4]
22:12:07 <lambdabot>   [2,4,6,8]
22:12:14 <Kron> a map applies a single operator to everything in a list
22:12:17 <Kron> to generate a new list
22:12:19 <nurupo> i see
22:12:20 <nurupo> > foldr (+) 0 [1,2,3,4]
22:12:21 <lambdabot>   10
22:12:28 <tac> > map reverse ["Hello", "World"]
22:12:28 <Kron> there ya go
22:12:29 <lambdabot>   ["olleH","dlroW"]
22:12:44 <nurupo> > foldr (+) [1,2,3,4]
22:12:45 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable t0)
22:12:45 <lambdabot>    arising from a use ...
22:12:47 <Kron> foldr (++) [] ["Hello", "World", "!"]
22:12:51 <c_wraith> > foldr (+) 0 [1,2,3,4] :: Expr
22:12:52 <lambdabot>   1 + (2 + (3 + (4 + 0)))
22:12:52 <Kron> you will need a 'final' value
22:12:54 <Kron> notice the 0
22:12:56 <Kron> notice the []
22:13:02 <Kron> that's the base value, the final one
22:13:05 <Kron> (4 + ???)
22:13:17 <Kron> > foldr (++) [] ["Hello", "World", "!"]
22:13:18 <lambdabot>   "HelloWorld!"
22:13:42 <Kron> that's a right fold
22:13:53 <Kron> a left fold just slants leftwards
22:14:04 <Kron> > foldl (+) 0 [1,2,3,4] :: Expr
22:14:05 <lambdabot>   0 + 1 + 2 + 3 + 4
22:14:18 <Kron> it's (((0 + 1) + 2) + 3) + 4
22:14:28 <nurupo> okay
22:14:30 <Kron> > foldr (/) 1 [1,2,3]
22:14:31 <lambdabot>   1.5
22:14:37 <Kron> > foldl (/) 1 [1,2,3]
22:14:38 <lambdabot>   0.16666666666666666
22:14:48 <Kron> you can see why this may matter in some cases and not matter in other cases
22:15:09 <Kron> if using the fold functions are too confusing for you, you can just write out a normal recursive function
22:15:15 <Kron> just like you did for constructTree
22:15:25 <Kron> but folds let you do neat things
22:15:33 <Kron> like you can say stuff like this:
22:15:47 <Kron> factorial n = foldl (*) 1 [1..n]
22:15:53 <Kron> that's a one line factorial program
22:16:00 <Kron> it multiplies all the numbers from 1 to n
22:16:42 <Kron> so basically, you want to do this:
22:16:59 <Kron>   finalTree = foldl addTree emptyTree inputlist
22:17:15 <Kron> we start with the emptyTree and then we keep adding trees onto it
22:17:32 <Kron> addTree :: QuadTree -> String -> QuadTree
22:17:44 <Kron> it will take a tree and a string and return a new tree
22:17:50 <Kron> basically a slightly modified constructTree
22:18:37 <nurupo> but final tree can have only 4 subtrees
22:18:51 <Kron> indeed
22:19:07 <Kron> you'll have to make an addTree function that always returns a well formed tree with 4 subtrees all the way down
22:19:27 <nurupo> when here the number of subtrees is dictaded by number of inputs in the list
22:22:46 <Kron> also, your code has a type error
22:22:55 <Kron> it's constructTree :: String -> QuadTree
22:23:06 <Kron> or alternatively, constructTree :: [Char] -> Quadtree
22:23:10 <Kron> String = [Char]
22:23:14 <Kron> [String] = [[Char]]
22:23:23 <Kron> constructTree only takes a list of characters and generates one tree
22:23:32 <Kron> it doesn't take a list of lists of characters (a list of strings)
22:23:49 <nurupo> i noted that in comments
22:24:05 <Kron> gotcha
22:25:15 * hackagebot treeviz 0.0.1 - Visualization of computation decomposition trees.  http://hackage.haskell.org/package/treeviz-0.0.1 (DavidBanas)
22:27:19 <nurupo> finalTree = foldl addTree emptyTree ["41", "42", "23", "24", "431"] -> finalTree = addTree (addTree (addTree (addTree (addTree emptyTree "41") "42") "23") "24") "431"
22:27:32 <nurupo> correct?
22:27:57 <arkeet> sure
22:28:50 <Kron> yes
22:29:39 <nurupo> hm
22:31:00 <Cale> http://cale.yi.org/share/Folds.png -- diagrams of what the various folds do
22:34:31 <Kron> note: foldl' is a strict version of foldl
22:34:39 <Kron> generally speaking when you use foldl you want to use foldl'
22:34:47 <Kron> it just evaluates things as it goes along
22:35:01 <nisstyre> Kron: I doubt that's always true
22:35:29 <Kron> yeah, it's only a general rule of thumb I find
22:35:40 <Cale> It's almost always true
22:35:53 <Cale> One exception being reverse, which is a little more efficient with foldl
22:36:05 <Cale> You usually either want foldr or you want foldl'
22:37:21 <Cale> @src foldr
22:37:21 <lambdabot> foldr f z []     = z
22:37:21 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:37:58 <Cale> foldr passes control to f immediately in the recursive case, which means that it has the advantage of being able to stop and produce a result early
22:38:11 <Cale> > foldr (\x xs -> 2*x : xs) [] [1..]
22:38:12 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
22:38:18 <Cale> > foldr (\x xs -> x : x : xs) [] [1..]
22:38:19 <lambdabot>   [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16...
22:38:24 <Cale> and it works on infinite lists
22:38:28 <Cale> @src foldl
22:38:29 <lambdabot> foldl f z []     = z
22:38:29 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:38:59 <Rylee> @src (:)
22:39:00 <lambdabot> Source not found. Maybe if you used more than just two fingers...
22:39:02 <Cale> foldl on the other hand just applies itself to new arguments until it reaches the end of the list, building up a large expression as it goes
22:39:34 <Cale> Usually you'll want to avoid the memory cost of that expression, and the potential stack overflow after the foldl reaches the end if the function is strict.
22:39:49 <Kron> nurupo: http://lpaste.net/96678
22:40:08 <Cale> (which is why you'd want foldl' to allow f to reduce before continuing down the list)
22:40:09 <Kron> here's my implementation of what I think you're trying to do
22:40:16 <nurupo> Kron: i'm confused as of how to implement addTree
22:40:16 <nurupo> does that look right? https://gist.github.com/nurupo/5204b6a50ce86ceac1ed
22:40:16 <nurupo> i keep already existing nodes and add only in a needed one
22:40:16 <nurupo> although i'm not sure about the base case
22:40:42 <nurupo> *ony to a needed one
22:40:42 <nurupo> *only
22:40:49 <Kron> nurupo you're on the right track!
22:40:54 <Kron> you'll note your function is very similar to mine
22:40:56 <Cale> Rylee: (:) is one of the two constructors for lists
22:41:03 <Kron> you have to account for the case where your addTree runs into a pixel
22:41:14 <Kron> (it has to replace the pixel with a node with 4 empty spaces, white pixels)
22:41:29 <Cale> Rylee: Every list is either the empty list [] or it is a list of the form (x:xs) where x is an element of the list, and xs is another list.
22:41:53 <Cale> > 1 : (2 : (3 : (4 : (5 : []))))
22:41:54 <lambdabot>   [1,2,3,4,5]
22:41:55 <Kron> I also used "" instead of [] as the base case, but that is a stylistic choice
22:42:05 <Kron> "" is an empty list that is clearly [Char]; you can use [] if you prefer
22:42:17 <Cale> (the [1,2,3,4,5] syntax is actually just syntax sugar for what I wrote)
22:42:56 <Kron> yeah it's useful to think of lists like this:
22:43:09 <Kron> data [a] = [] | a:[a]
22:43:24 <Kron> though that's honestly an abuse of notation and not how it's written in source
22:45:03 <nurupo> Kron: what does "@" pattern mean in "tree@(Node a b c d)"?
22:45:14 <Kron> it's simply a label, nurupo
22:45:22 <Cale> By the way Kron, about your question earlier, it is ever so slightly slower to construct a Maybe value first, because that will involve some extra allocation and an additional pattern match. However, if there's a case in which you really have to produce Nothing, you're better off using Maybe.
22:45:24 <Kron> it saves "tree = (Node a b c d)"
22:45:28 <nurupo> oh, now i remember
22:45:34 <Kron> it's just a way of making it more compact
22:45:38 <Kron> if you don't like it
22:45:40 <Cale> (and the performance cost is usually trivial)
22:45:42 <Kron> you can just put a where block
22:45:54 <Kron> "   where tree = (Node a b c d)" at the bottom
22:46:05 <Kron> Cale: gotcha
22:46:15 <Cale> It's far better to use Maybe Integer than doing something dumb like reserving -1 for an error case.
22:47:38 <Kron> nurupo: editted the lpaste for clarity
22:47:39 <Cale> (In fact, with certain optimisations, it might even be faster to use Maybe Integer then, since GHC does pointer tagging for already-evaluated values, which will make it obvious without having to dereference the pointer whether it was Nothing or Just)
22:47:43 <nurupo> Kron: and why you do
22:47:43 <nurupo> `'1' -> Node (addTree tree xs) b c d`
22:47:43 <nurupo> instead of
22:47:43 <nurupo> `'1' -> Node (addTree a    xs) b c d`?
22:48:23 <Kron> perhaps I didn't do it right
22:48:25 <nurupo> if it's a first node, don't we want to get into first node's subtree?
22:48:53 <Kron> yeah
22:49:02 <Kron> in retrospect I think I confused my design a bit
22:49:11 <Kron> with some earlier tree code I was working on a few weeks ago
22:49:15 <Kron> I think you are correect! good catch
22:49:19 <Kron> let me fix my code
22:49:54 <Kron> oh!
22:49:56 <Kron> you'll also note
22:49:59 <Kron> I made your trees visible
22:50:09 <Kron> if you look at the tree declaration, I implemented a show for your trees
22:50:20 <Kron> so now you can evaluate your trees in ghci and it will print them out for you
22:50:24 <Kron> easier to debug that way
22:50:53 <Kron> edited once more to fix it
22:57:31 <nurupo> Kron: also, i think emptyList should be Pixel White
22:57:48 <Kron> oh, sure
22:57:53 <nurupo> because we might have an empty list in finalTree
22:58:06 <Kron> emptyTree you mean, but yeah
22:58:17 <nurupo> yes, emptyTree
22:58:23 <Kron> okay, done
22:58:29 <Kron> I think it's pretty clean now altogether
22:58:40 <Kron> I used a where block to cut down on repetition
22:58:48 <nurupo> Kron: thanks a lot, will try this out :)
22:59:09 <Kron> good luck!
22:59:24 <Kron> I enjoyed the excuse to do some simple haskell coding, I rarely get an opportunity to
23:14:57 <nurupo> Kron: it works :)
23:15:04 <Kron> awesome!
23:15:17 <nurupo> that was interesting
23:15:18 <Kron> take a closer look at folds for future endeavours!
23:15:34 <Kron> most functional languages have them
23:15:41 <Kron> I originally learned to use folding in common lisp
23:15:51 <Kron> but they exist in everything from python to ocaml
23:17:39 <nurupo> now if i only could `show` it appropriately
23:17:44 * nurupo is thinking
23:17:48 <ParahSailin> @hoogle lzcnt
23:17:49 <lambdabot> No results found
23:18:13 <Kron> I alerady have you a show for your quadtrees
23:18:18 <ParahSailin> does ghc have the lzcnt primop from sse4?
23:18:18 <Kron> what are you trying to show?
23:18:20 <Kron> *gave you
23:21:08 <nurupo> Kron: say i have a tree like this http://i.imgur.com/u40h0fD.gif
23:21:34 <Kron> ah, I don't know how to depict it graphically
23:21:44 <Kron> I made a simple string representation
23:23:03 <nurupo> Kron: each node corresponds to a quarter of a black and white image like that http://i.imgur.com/STMVPA9.gif
23:23:11 <nurupo> so i need to display something like that http://i.imgur.com/8vKk6PT.gif
23:23:25 <Kron> hmmm
23:23:29 <Kron> that's a really interesting question
23:24:03 <Kron> we could do an ASCII depiction!
23:24:17 <nurupo> i'm given final matrix's dimensions
23:24:17 <nurupo> well, a dimension, it's always a square
23:24:19 <vonDraco> how often will one use the state monad?
23:24:41 <chrisdone> fairly often
23:25:04 <vonDraco> damn
23:30:23 <chrisdone> monochrom: https://gist.github.com/chrisdone/4a62278438b219433b4b nearly ready for a beta release \o/
23:35:01 <begriffs> chrisdone: that looks so cool. I love the little animations showing what the actions mean.
23:37:11 <chrisdone> begriffs: http://2.bp.blogspot.com/-JYPXG2GqjYI/UL_fKTFuvlI/AAAAAAAABOI/11Fv5XbvNBc/s1600/goo.gif =p
23:38:57 <chrisdone> begriffs: do you use emacs?
23:39:42 <begriffs> Not yet. I've always used vim, but emacs looks pretty cool, especially with those modes.
23:46:39 <AshyIsMe> does that have bindings for evil mode?
23:46:49 <chrisdone> nope
23:47:21 <chrisdone> it's easy to author them though, probably
23:47:31 <Ralith> "Going to parent end: shm/goto-parent-end jumps to the parent end of the parent.
23:47:35 <Ralith> "
23:47:39 <Ralith> is that supposed to say parent twice?
23:47:41 <AshyIsMe> my fingers will die again if i go back to bare emacs
23:48:04 <chrisdone> ralith: nope, just the last one =)
23:48:39 <Ralith> ^^
23:49:36 <chrisdone> ashyisme: there's also https://github.com/chrisdone/god-mode =p
23:50:29 <chrisdone> i haven't had rsi since i started using it 4 months ago
23:51:14 <chrisdone> buuut if you already use evil-mode, doesn't matter
23:51:29 * mgsloan takes vague credit for pseudo inspiring the creation of god-mode
23:54:12 <mgsloan> (mostly for touting the benefits of vimlike keybindings)
23:55:35 * Ralith is pretty happy with just plain old capslock control
23:55:36 <Kron> how do you add an element into a list every k places?
23:57:01 <Ralith> intercalaten n x xs = take n xs ++ (x : intercalaten n x (drop n xs))
23:57:03 <Ralith> with suitable base case
23:57:08 <Ralith> probably
23:57:22 <mgsloan> Ralith: Yeah, I use capslock as my xmonad modkey.  Used to use the windows key, till I realized I was doing some rather bizzare hand contortions all the time
23:57:44 <mgsloan> Now windows key is caps lock, to punish me for pressing it :P
23:57:48 <Ralith> heh
23:58:15 <mgsloan> (ALSO FOR SOME REASON IT WAS HARD TO REBIND IN XMODMAP)
23:59:55 <johnw> l
