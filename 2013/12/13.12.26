00:00:07 <jfischoff> cabal repo is new
00:00:14 <jfischoff> repl
00:00:25 <jfischoff> you can add the dep to lib and it will work
00:00:30 <jfischoff> but that is lame
00:00:49 <jfischoff> it will unblock you though
00:00:51 <mpjones> Ahh, yeah, fair
00:00:59 <mpjones> Thanks, might try that
00:01:45 <jfischoff> are you using a sandbox?
00:02:02 <jfischoff> if not then don't use cabal repl and you should be fine
00:02:19 <mpjones> I'm using a sandbox
00:02:33 <mpjones> They seemed like a good idea :)
00:02:38 <jfischoff> there new
00:02:57 <jfischoff> I tend avoid them unless I need them
00:04:36 <mpjones> Fair enough.
00:07:28 <mpjones> Confused again, I :l src/Main.hs and it works. Then I run :break Ball 43 and it says: module 'Ball' is not interpreted; try ':add *Ball' first, so I do: :add *Ball and then :break Ball 43 and it works but then :step main complains that "main is not in scope" so I do :l src/Main.hs and it forgets about the break point. Erk.
00:07:49 <mpjones> Not life and death. I'm only setting a break point to practice it. Maybe it isn't so important :/
00:09:39 <jfischoff> now I can't help you, having only set one breakpoint in ghci ever.
00:10:27 <mpjones> Fair enough mate, thank you for your time
00:25:31 <bartavelle> mpjones, there is some option to tell it to load all the files in interpreted mode
00:25:35 <bartavelle> not sure which though
00:30:40 <mpjones> Ah, thanks. I'll look for that
00:42:48 <raphie> whenever I try to install most things cabal says that packages would be broken. how do I avoid this?
00:44:08 <c_wraith> don't ever run cabal update.
00:44:56 <c_wraith> raphie: for a more useful answer, see http://www.vex.net/~trebla/haskell/sicp.xhtml
00:47:50 <johnw> raphie one thing to do is to take all the package that would be broken by the install, and add them to the install line
00:48:00 <johnw> that way, cabal can try to find an install plan that makes all of them happy
00:48:15 <raphie> huh, I'll try that out
00:48:44 <johnw> I tend to do this often: force install a package that breaks a ton of packages; reinstall all of the broken packages at once, continue until all is good.  If that takes too long, I just wipe and rebuild the world
00:49:29 <c_wraith> I normally start with wiping.  Saves time.
00:49:37 <johnw> yeah, it usually does
00:49:56 <johnw> that's why I maintain "cabal-reset" and "cabal-bootstrap" scripts in my bin directory
00:50:16 <johnw> plus some strategically chosen constraints in ~/.cabal/config
00:51:43 <raphie> npm solves this problem really nicely for node packages -- each library has its own local copy of the dependencies
00:52:05 <johnw> nix does that too
00:52:13 <bartavelle> raphie, you can use "cabal sandbox" for this
00:58:32 <Gracenotes> hm. I think coding a lot of Java has made me much more tolerant of boilerplate in Haskell
01:01:35 <Gracenotes> especially when it comes ot writing long type signatures
01:04:56 <navaati> hey ! if a monad is just a monoid in the category of endofunctors (what's the problem ?), then... what is mappend in this monoid ?
01:05:19 <raphie> Gracenotes: if you've got truly long type signatures, you might consider making a new data type
01:06:14 <Gracenotes> as an example of one of these: Ord a => CurrentQueue a -> InsertionMap a -> Maybe Time -> Maybe a
01:07:23 <Gracenotes> everything *means* something, but... well, I've mainly committed to fully qualifying all top-level and where-decl types (but not let decls, actually...).
01:17:28 <jle`> fair enough :) hlint only complains when i don't specify top-levels
01:18:04 <jle`> if there is a common pattern though and things get hairy i do make a data type
01:18:17 <jle`> i just find that specifying type signatures is a good way to plan out what i'm going to do
01:18:26 <jle`> sometimes i don't even know where to start
01:18:33 <jle`> but when i write out a type signature, everything writes itself
01:20:28 <raphie> if I find myself passing the same series of arguments over and over I just make a new type
01:23:48 <Gracenotes> in theory two of the above types come from a larger type. although one is being recursed upon, so probably needs to be separate
01:24:09 <c_wraith> If I find myself passing the same series of arguments over and over, I look to see if it makes sense to reorganize my code to close definitions over the bindings of those values.
01:25:18 <jrw> navaati: http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem
01:25:48 <jrw> tl;dr: functor composition.
01:27:32 <jrw> well. depending on which "binary operation" you mean, it could be join.
01:28:41 <mpjones> fwiw my earlier issue is solved by doing: :m *Main *Ball in cabal repl exe:breakout which loads them both into scope as interpreted files
01:30:28 <johnw> jrw: I wouldn't say it's functor composition, but the ability to merge functoral contexts; functor composition implies that you have multiple, composed contexts, ala Compose
01:34:17 <m1dnight> Does anybody happen to know an example of some sort where they showcase an 'edit view' with Snap framework? (ie: render a view with a given model)
02:32:51 <navaati> jrw: thanks. i did not really understand, but that was expected ^^
02:33:54 <navaati> or maybe... mappend is join ?
02:37:40 <johnw> join is an mappend'ing of the context
02:37:43 <johnw> f (f a) -> f a
02:37:57 <johnw> if you ignore the 'a' part, it's similar to: f * f -> f
02:38:03 <johnw> (where * is mappend)
02:39:43 <donri> join = concat = mconcat for lists, but that's incidental
02:41:55 <navaati> johnw: that's what i thought. and return is putting in an mempty context
02:42:34 <johnw> pretty much
02:43:22 <johnw> a -> f a, ignoring the 'a', is like () -> f, which is really the same thing as just 'f'
02:44:29 <johnw> so, monads are just "monoids at the functor level", with the 'a' just coming along for the ride
02:45:11 * hackagebot classy-prelude 0.7.0 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.7.0 (MichaelSnoyman)
02:45:12 * hackagebot classy-prelude-conduit 0.7.0 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.7.0 (MichaelSnoyman)
02:45:12 <johnw> when I first heard that famous phrase about monads and monoids, I thought it was intentional obfuscation
02:45:12 * hackagebot classy-prelude-yesod 0.7.0 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.7.0 (MichaelSnoyman)
02:45:13 * hackagebot mono-traversable 0.2.0.0 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.2.0.0 (MichaelSnoyman)
02:45:13 * hackagebot persistent 1.3.0 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.3.0 (MichaelSnoyman)
02:45:15 <johnw> but it really is the one of the clearest ways of thinking about them
02:46:43 <notdan> I do doubt that a little bit
02:46:57 <notdan> ('monads as monoids' being the clearest way of thinking about monads)
02:46:57 <johnw> notdan: why is that?
02:47:42 <johnw> whenever I want to implement >>=, I think "what is join for this monad?"  And to answer that, I think, "What does it mean to mappend everything that's not 'a' in the type 'm a'"
02:48:09 <notdan> In Haskell monads are defined with 'bind', not with join
02:48:19 <notdan> and bind has a clearer computational intepretation
02:48:41 <johnw> I understand them through join first, then I proceed to writing >>= usually
02:48:51 <jle`> this sounds inherently subjective
02:48:58 <johnw> must be
02:49:00 <notdan> I guess so
02:49:24 <jle`> but i like thinking of monads as giant self-nested objects, and at the end you collapse them somehow into one
02:49:34 <johnw> I find thinking about >>= for Map to be of much greater intuitive difficulty than join for Map
02:49:46 <donri> obviously kleisli categories are the clearest way to think about mon ads
02:50:00 <johnw> donri++
02:50:11 * hackagebot persistent-mongoDB 1.3.0.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.3.0.1 (MichaelSnoyman)
02:50:13 * hackagebot persistent-mysql 1.3.0 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-1.3.0 (MichaelSnoyman)
02:50:15 * hackagebot persistent-postgresql 1.3.0 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.3.0 (MichaelSnoyman)
02:50:17 * hackagebot persistent-sqlite 1.3.0 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-1.3.0 (MichaelSnoyman)
02:50:19 * hackagebot persistent-template 1.3.0 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.3.0 (MichaelSnoyman)
02:50:20 <johnw> also, I did say "one of the clearest", and not "the clearest"
02:50:27 <donri> (:
02:51:02 <johnw> at least it beats tortillas, or however burritos are supposed to be smashed together
02:51:59 <jle`> what is an example of a non-endofunctor?
02:52:12 <jle`> er
02:52:15 <jle`> a functor that is not endo
02:52:21 <navaati> i usually prefer join, but i guess it depends on the particular monad. For example join for Maybe is way clearer
02:52:41 <navaati> jle`: well, Set is one of these
02:53:01 <jle`> is it a functor that has no way to "join"?
02:53:05 <navaati> no
02:53:14 <aristid> join is usually clearer for exposition, but in usage, >>= appears to be way more common.
02:53:20 <aristid> Set is not a functor
02:53:43 <navaati> the Functor class is all endofunctors in the Hask category (the category of haskell types)
02:54:03 <jle`> they map haskell types to other haskell types?
02:54:10 <aristid> or i think it is an (endo)functor, but in a subcategory in hask
02:54:13 <navaati> aristid: isn't Set a functor from Hask to Ordor something like that ?
02:54:20 <aristid> navaati: Mordor!
02:54:29 <johnw> Set does not follow the functor laws
02:54:34 <navaati> aristid: ah, from Ord to Ord ?
02:54:56 <aristid> navaati: i think so
02:54:58 <navaati> (haha, oops)
02:55:09 <navaati> ok, so still an endofunctor
02:55:10 <jle`> it says here in [generic source] that endofunctors are functors for which start and target category is the same.  what does 'start' and 'target' mean?
02:55:18 <aristid> navaati: i'm not really sure tho
02:55:19 <donri> isn't Functor always an endofunctor, ie. in Hask
02:55:21 * hackagebot yesod-auth 1.2.5.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.5.2 (MichaelSnoyman)
02:55:23 * hackagebot yesod-core 1.2.6.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.6.3 (MichaelSnoyman)
02:55:25 * hackagebot yesod-form 1.3.4.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.4.2 (MichaelSnoyman)
02:55:26 <johnw> Set is not a functor at all
02:55:27 * hackagebot yesod-persistent 1.2.2.1 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-1.2.2.1 (MichaelSnoyman)
02:55:29 * hackagebot yesod-routes 1.2.0.5 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.2.0.5 (MichaelSnoyman)
02:55:30 <donri> and not all functors are Functors
02:55:34 <aristid> johnw: why not?
02:55:52 <navaati> i guess it does't follow the laws
02:55:59 <donri> oh yeah navaati said the same
02:56:01 <johnw> aristid: fmap f . fmap g = fmap (f . g)
02:56:10 <johnw> for Set, fmap g might change the membership of the Set
02:56:20 <johnw> for example, fmap (const 1) would reduce the Set down to one member
02:56:40 <aristid> hmm is it not possible to say somehow that the funciton argument to f must be a strict monotonous function?
02:56:45 <aristid> *to fmap
02:57:06 <johnw> it wouldn't be a functor then, but some more specialized entity with more laws I guess
02:57:09 <adelbertc_> isnt there also an issue in that functors state forall a, b whereas Set is constrinaed to Eq and/or Ord
02:57:29 <aristid> adelbertc_: that was the subcategory thing we were talking about:)
02:57:35 <navaati> Set is an endofunctor in the category whose elements are types of Ord and morphisms are injections \o/
02:58:20 <aristid> navaati: but it isn't apparently
02:58:34 <johnw> I guess you could call it a restricted functor
02:58:44 <donri> jle`: in the case of a function a -> b, a is the source object and b is the target object
02:58:48 <johnw> in the sense of a restricted monad, the classic example of which is a Set
02:59:02 <jle`> donri: so what about the Maybe functor?
02:59:09 <aristid> if there are restricted monads, surely restricted functors exist the same way:)
02:59:10 <jle`> er, the Maybe Functor
02:59:12 <adelbertc_> aristid - ah, missed it in the scrollback
02:59:22 <johnw> aristid: yeah, guess so, huh :)
02:59:28 <navaati> well if morphisms are injections, it is impossible that different elements end up being same elements, so the laws hold, don't they ?
02:59:30 <jle`> is it () -> a or something
02:59:58 <aristid> navaati: oh
03:00:29 <navaati> (maybe i mixed up injections and surjections, that's totaly possible)
03:00:44 <donri> jle`: all Functors are endofunctors in the Hask category, both "a" and "b" are objects of Hask
03:01:18 <navaati> jle`: for example a in an object of Hask, well then Maybe a is also an object of hask (they're both haskell types !)
03:01:19 <jle`> so the qualification of 'endo-' is one that is not necessarily needed if you know you are in Haskell
03:01:29 <johnw> jle`: right, it's implied
03:01:44 <aristid> is (forall a. a) in Hask also?
03:01:46 <donri> you could define other types of functors in haskell, but not via the Functor class
03:01:47 <navaati> (except if you'r in ekmett's libraries)
03:02:12 <johnw> jle`: a mapping of Haskell types to equivalent C types would be a functor, just not one you could program with in Haskell
03:02:13 <jle`> for Maybe a, what is the source object/category?
03:02:15 <navaati> aristid: you mean undefined or shit like that ? errrr, good question
03:02:27 <aristid> navaati: no i mean polymorphic types
03:02:31 <donri> aristid: i tend to think of Hask as kind *, duno if that's correct. but in that case then yes, bottom is *
03:02:49 <johnw> actually, it wouldn't be a functor unless you could also map every function between Haskell types to an equivalent C function between the equivalent C types
03:03:36 <aristid> johnw: that's what a compiler does!
03:03:46 <navaati> i guess the functor from CTypes to Hask exist, tho :  it's basically the ffi
03:03:49 <donri> jle`: Hask and Hask
03:03:54 <navaati> aristid: hahaha :D
03:04:22 <johnw> navaati: if it were the FFI, "fmap" would always return the functional equivalent!
03:04:38 <johnw> instead, while the FFI can map types, it works with a fixed set of functions on both sides
03:05:10 <navaati> ok, from C to, errr.... (IO Hask), if you know what i mean :-*
03:05:16 <johnw> real functors map both objects and morphisms, so that every morphism in the source category has an image in the target category
03:05:21 <jle`> donri: i guess I am not understanding where the 'mapping' is happening, what is being mapped to what?  Is a () being mapped to an Int? or Maybe Int being mapped to an Int? or am i understanding this improperly
03:05:22 <donri> jle`: uh the category is Hask, the source object is Maybe a (which is in Hask) and the target object is Maybe b (also in Hask)
03:05:42 <navaati> johnw: i can import every C function using the ffi : my fmap is the "import" declaration
03:05:58 <donri> i think this is a definition of Functor that doesn't have to be an endofunctor: http://hackage.haskell.org/package/categories-1.0.6/docs/Control-Categorical-Functor.html
03:06:12 <navaati> donri: you sure ?
03:06:18 <johnw> navaati: hmm.. interesting thought
03:06:42 <donri> navaati: no, picture me as a dog with the subtitle "i have no idea what i'm doing"
03:07:24 <aristid> johnw: do functors really have to map objects? why isn't mapping the morphisms enough?
03:07:29 <navaati> i'd tell that the source is a and the target is Maybe a, and the functor can bring morphisms in Hask (from a to b) in the Maybe world
03:07:37 <navaati> (from Maybe a to Maybe b)
03:07:38 <johnw> aristid: how do you define a morphism without objects?
03:08:01 <jle`> donri: is this all under the context of being fmapped (a->b) ?
03:08:03 <johnw> as far as I can tell, in some interpretations of category theory, objects exists solely to differentiate morphisms!
03:08:04 <notdan> aristid: they have to map objects properly. So for g:a->b F(g) has to have a type Fa -> Fb
03:08:21 <navaati> aristid: was wondering the same. because being able to map every object in the target category sound a lot like pure, which is not in Functor
03:08:28 <notdan> what is 'fmapped'?
03:08:51 <jle`> i'm trying to understand the context/meaning of 'source' and 'target'
03:09:24 <notdan> Haskell's 'Functor' is an enfunctor on the types. So if you have a functor F you get object mapping "for free"
03:09:34 <notdan> namely, for every type 'a' you have a corresponding type F a
03:09:58 <notdan> jle`: if you have a morphism g:a->b, source(g)=a, target(g) = b
03:09:59 <donri> oh yeah class Functor f a a => Endofunctor f a
03:10:00 <jle`> so the source is a, and the target is F a?
03:10:17 <navaati> notdan: oh, yeah, objects are types, not values. my bad
03:10:21 <aristid> ah right the objects are the types,not the values :D
03:10:26 <notdan> source and target of what?
03:10:27 <aristid> navaati: lol two fools same error
03:11:01 <johnw> navaati: oh, one reason ffi's import is probably not a functor is that effects are involved.  A C function from the FFI is really a -> IO b, unless you know it's pure and are willing to use unsafeInterleaveIO
03:11:02 <jle`> notdan: well, reading a definition of endofunctor somewhere. 'endofunctor is a functor for which the start and target category are the same'
03:11:16 <navaati> but eh ! isn't it that we are all confused because Functors are morphisms in the category of idunnowhat ?
03:11:21 <johnw> err, unsafePerformIO
03:11:40 <johnw> navaati: in the category of categories
03:11:49 <notdan> Applicatives in haskell are really monoidal functors http://cstheory.stackexchange.com/questions/12412/explaining-applicative-functor-in-categorical-terms-monoidal-functors
03:12:15 <navaati> johnw: oh sh!!!
03:12:17 <notdan> jle`: oh yeah. Haskell's Functors has the same source and target: the category of types Hask
03:12:31 <jle`> notdan: but what does 'source' and 'target' mean in this context?
03:12:40 <johnw> heh, if you just master "functor" and "monoid", pretty much all of the cool Haskell abstractions derive from one or a combination of those two :)
03:12:40 <notdan> jle`: Hask contains haskell's types as object and functions as morphisms
03:13:52 <navaati> so, are we talking about source and target of the Functor's morphisms, or of the Functor itself (which is a morphism, meh) ?
03:13:53 <notdan> jle`: well in CT functors are morphisms in the category of categories; functor F can have arbitrary source and target. So functor X:A->B maps objects and morphisms from the category A to objects and morphisms of the category B
03:14:05 <donri> jle`: basically * -> *
03:14:17 <jle`> oh, so we are talking about Maybe
03:14:19 <notdan> Endofuncor has the same source and target, for example Maybe: Hask -> Hask
03:14:22 <jle`> not Maybe Int
03:14:35 <navaati> jle`: yup
03:14:51 <jle`> so Maybe is a functor that takes a type a and returns a type maybe a
03:14:58 <notdan> Exactly
03:15:00 <jle`> and they are both hask types
03:15:04 <johnw> jle`: that's one half of its functorness
03:15:10 <notdan> yep
03:15:16 <jle`> johnw: what's the other half?
03:15:18 <notdan> Both Int and Maybe Int are valid haskell types
03:15:20 <navaati> jle`: fmap
03:15:25 <notdan> thats why Maybe is an endofunctor
03:15:29 <johnw> it maps any function a -> b to a function Maybe a -> Maybe b, and obeys the functor laws
03:16:42 <navaati> one thing confuses me tho : isn't (forall a. Maybe a) a subset of Hask ? So isn't Maybe a functor from Hask to (a subset of Hask) ?
03:16:44 <jle`> so this is a part of the definition of functor
03:16:57 <donri> fmap :: (Hask a b) -> (Hask (f a) (f b))
03:17:16 <jle`> you need both the * -> *, and the (a -> b) -> (Maybe a -> Maybe b)
03:17:18 <Breadmonster> !src concat
03:17:28 <johnw> jle`: right, and the laws
03:17:30 <donri> @src concat
03:17:30 <lambdabot> concat = foldr (++) []
03:17:35 <navaati> jle`: yes sir, and the laws
03:17:50 <notdan> donri: hm I have troubles processing this notation; what does Hask a b stnd for?
03:18:00 <navaati> notdan: same here
03:18:01 <Breadmonster> donri: Why not this: concat = foldl' (++) []
03:18:01 <Breadmonster> ?
03:18:04 <notdan> navaati: well yeah, but it's not a problem
03:18:14 <donri> newtype Hask a b = Hask (a -> b) deriving Category  -- ;)
03:18:16 <notdan> (re: subset thingie)
03:18:18 <jle`> yes it does seem like Maybe's * -> * is mapping a set to a subset; does that matter?
03:18:24 <jle`> there seems to be no fixed point
03:18:25 <Breadmonster> I was doing the 99 Haskell problems, and I used that.
03:18:30 <notdan> it doesnt matter
03:18:34 <johnw> notdan: Hask a b is the objects a and b in Hask and all morphisms between them
03:18:51 <jle`> as long as you consider a category of which both *'s are subsets
03:19:01 <jle`> *for which
03:19:03 <jle`> of
03:19:05 <jle`> grammar
03:20:06 <jle`> so making an endofuncor a monoid...
03:20:12 <jle`> you have the product operation
03:20:14 <jle`> the <>
03:20:17 <jle`> which is join
03:20:25 <jle`> and then you have the identity
03:20:27 <jle`> which is...return?
03:20:32 <johnw> yes
03:20:58 <jle`> the identiity is an identity in that
03:21:01 <jle`> if you fmap return
03:21:03 <jle`> and then join
03:21:05 <jle`> it's the same thing
03:21:07 <jle`> ?
03:21:14 <johnw> take the monoid algebra: () -> m, m * m -> m
03:21:29 <jle`> > join $ fmap return (Just 5)
03:21:30 <lambdabot>  Just 5
03:21:31 <johnw> now "lift" this algebra up to the level of functors: a -> f a, (f * f) a -> f a
03:21:40 <notdan> Breadmonster: foldlr works on infinite lists
03:21:41 <notdan> > let xs = map (\a -> [a]) [1,1..] in foldl' (++) [] xs
03:21:44 <lambdabot>  mueval-core: Time limit exceeded
03:21:45 <notdan> > let xs = map (\a -> [a]) [1,1..] in concat xs
03:21:47 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:21:53 <notdan> ^ Breadmonster
03:22:24 <Breadmonster> notdan: How does foldl' work on infinite lists but not foldr?
03:22:36 <johnw> I just found a blog article which seems very relevant to our entire discussions: http://dorchard.wordpress.com/2011/10/18/subcategories-in-haskell-exofunctors/
03:22:44 <navaati> foldr starts with the end. on infinite lists, there's no end
03:22:56 <notdan> Breadmonster: http://stackoverflow.com/a/384919/363344
03:22:59 <jle`> so is return then defined as...the thing for that monad that if you <> it, it leaves the object unchanged?
03:23:03 <Breadmonster> notdan: Thanks :)
03:23:18 <notdan> navaati: it's the other way around, http://stackoverflow.com/a/384919/363344
03:23:23 <johnw> > take 10 $ foldr (:) [] [1..]
03:23:24 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
03:23:28 <johnw> foldr does not "start at the end"
03:24:06 <johnw> the "r" means right-associative, not right-to-left
03:24:09 <Gerldus> Hello everybody! I want to install Fay (https://github.com/faylang/fay/wiki), but it fails with type-eq-0.4 failed during the building phase. The exception was: ExitFailure 1
03:24:15 <notdan> You can think of 'foldr f [] xs' as a way to replace all the (:) in the list with `f`
03:24:32 <Gerldus> I'm new to Haskell and cabal at all. running on OS X 10.9
03:24:54 <notdan> Gerldus: can you please paste the whole log?
03:25:01 <notdan> to the pastebin
03:25:15 <donri> @lpasrte
03:25:16 <lambdabot> Haskell pastebin: http://lpaste.net/
03:25:17 <donri> @lpaste
03:25:17 <lambdabot> Haskell pastebin: http://lpaste.net/
03:25:19 <donri> lol
03:25:20 <johnw> jle`: yes, m >>= return = m, is one of the monad laws
03:25:28 <donri> @where lpaste
03:25:28 <lambdabot> http://lpaste.net/new/haskell
03:25:31 <johnw> that's actually the monoid law, recast in terms of the monad operations
03:26:01 <jle`> i keep on slipping between thinking of Maybe as the functor and Maybe a
03:26:07 <donri> johnw: that's why kleisli is a good way to think of monads! id = return
03:26:08 <notdan> Breadmonster: http://www.haskell.org/haskellwiki/Fold#List_folds_as_structural_transformations I like that picture
03:26:14 <johnw> donri: agreed
03:26:31 <johnw> jle`: you might like this: http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html
03:26:39 <Breadmonster> Hmm, thanks :)
03:26:40 <navaati> ah, nice article ! being able to use these 'singleton subcategories' with monads would be so damn useful
03:26:40 <Gerldus> notdan: surely, here it is http://lpaste.net/97560. Now I see warning about version
03:27:02 <navaati> (when do we get rmonad in the prelude !@#$%^$#@#$%^)
03:27:24 <donri> Gerldus: what version of ghc is this?
03:27:52 <notdan> Gerldus: oh you are using Mavericks aren't you?
03:28:01 <notdan> Gerldus: or maybe the latest xcode?
03:28:08 <notdan> I had similar problems
03:28:12 <notdan> 1 sec
03:28:24 <Gerldus> notdan: yes, Mavericks and the latest XCode
03:28:27 <jle`> now this identity...is a type or a morphism?
03:28:51 <jle`> (does that make sense as a question)
03:29:11 <notdan> Gerldus: you should use this script: http://www.haskell.org/pipermail/haskell-cafe/2013-October/111174.html
03:29:27 <donri> oh CPP strikes again
03:29:44 <notdan> Gerldus: the problem is some haskell packages were using the CPP preprocessor, but apple has decided to suddenly replace gcc with clang
03:29:54 <navaati> jle`: does not really makes sense, when talking about the monoidal and monadic operations, you're outside of the category
03:29:56 <notdan> and clang does not understand gcc preprocessor flags
03:30:19 <notdan> jle`: which identity?
03:30:21 <Breadmonster> notdan: For finite lists, is there a speed difference between foldl' and foldr?
03:30:29 <navaati> jle`: of course, since in haskell all is in Hask, it happens that fmap, join, and such are also in Hask, and are also morphisms in Hask, and<<<
03:30:31 <jle`> so your monoidal product is a way to get from (Maybe (Maybe Int)) to Maybe Int, right?
03:30:51 <jle`> Maybe x Maybe -> Maybe
03:30:58 <notdan> Gerldus: also your happy seems to be a little bit out of date,are you using the latest haskell platform?
03:31:10 <Gerldus> notdan: GHC 7.6.3
03:31:22 <Gerldus> notdan: Installed few days ago.
03:31:27 <notdan> Breadmonster: not sure. Foldl' is strict though
03:31:34 <Gerldus> I'll try now the script
03:33:33 <jle`> when I think of a product function like Int x Int -> Int, the idenitity is an item in the set of Ints (??) that, when producted with another item, returns that same item
03:33:36 <vektor> folds don't behave as I expected, I just noticed:  foldl (/) 36 [2,3] -> (( 36 / 2 ) / 3 ) -> 6 apparently is how foldl works. No big surprise. foldr (/) 36 [2,3] seems to be ( 36 / ( 3 / 2 ) ) = 24. But why?
03:33:43 <jle`> but when I look at Maybe x Maybe -> Maybe
03:33:51 <jle`> i am not sure how to interpret an idenitity in this context
03:34:31 <notdan> vektor: foldr is right-associative
03:35:03 <notdan> vektor: http://www.haskell.org/haskellwiki/Fold#List_folds_as_structural_transformations
03:35:03 <navaati> jle`: well the identity is Just
03:35:06 <navaati> partially applied
03:35:12 <notdan> navaati: huh?
03:35:18 <notdan> what do you guys mean by the identity?
03:35:25 <vektor> but how does right-associativity flip my 2 and 3 there?
03:35:27 <jle`> my previous notion of idenitity, for Ints, is that it's an item in the set of Ints that leaves another item unchanged.  but this notion does not carry over in the Maybe because is there even a set of Maybes?
03:36:02 <navaati> so it's actually the "wrapping with Just' operation which is the identity
03:36:35 <jle`> so where Maybe is the type-level function
03:36:40 <jle`> Just is the data level function?
03:36:42 <navaati> notdan: we're (trying to) talking about the identity of the monad's monoid (in the category of endofunctors, what's the problem ?)
03:36:58 <jle`> so it's like saying that Int is the type, 1 is the data
03:37:05 <jle`> Maybe is the type function, Just is the data function
03:37:08 <navaati> jle`: no
03:37:10 <jle`> is that an appropriate analogy?
03:37:13 <jle`> okay
03:37:15 <jle`> darn
03:37:19 <navaati> well, not really i guess
03:38:02 <navaati> Int in a monoid in Hask, Maybe is a monoid in... well you know, "what's the problem"
03:38:07 <notdan> vektor: oh, sorry. foldr (/) 36 [2,3] = (2/(3/36))
03:38:40 <Gerldus> notdan: I've done everything with script, then tried to `cabal install cabal cabal-install`. But version remain the same: cabal-install version 1.18.0.2 using version 1.18.1.2 of the Cabal library
03:39:07 <zett_zelett> Isn’t it foldr (/) [2,3] 36?
03:39:10 <Gerldus> How to choose version 1.19.x?
03:39:31 <zett_zelett> No.
03:40:02 <vektor> whoops. That kinda explains it. Yeah. Thankes, notdan. So the accum is always on the right end of things with a foldr.
03:40:20 <jle`> i mean i get the concept of "if you (join . fmap Just) a Maybe, it leaves it unchanged."  so does that mean that the monoidal product is the same as join . fmap f?  but how is that represented by Maybe x Maybe -> Maybe?
03:40:26 <kinslayer> I would like to be better at haskell so that I wouldn't be so afraid to write a website with something like snap.
03:40:43 <notdan> Int is not a monoid per se in Hask
03:40:43 <navaati> but i'm talking about things i don't really understand. first i need to understand what is this category of endufunctors, what are its objects, what are its morphisms, what is its identity (the category's one, not monoid's one), what is its morphisms composition operation
03:40:54 <kinslayer> However I just don't really understand enough haskell to write any significant code in snap or other frameworks.
03:41:01 <vektor> > foldr (/) 36 [2..4]
03:41:02 <lambdabot>  7.407407407407407e-2
03:41:08 <vektor> ahhh. Yeah.
03:41:30 <navaati> notdan: you mean because you must choose between + and * ?
03:41:32 <notdan> vektor: http://www.haskell.org/haskellwiki/Fold#List_folds_as_structural_transformations with 'foldr f z' you just replace (:) with f and [] with z
03:41:36 <jle`> i am just having a hard time relating the idea of return with the idea of the product Maybe x Maybe
03:41:42 <jle`> but i will read the article that johnw linked to
03:41:48 <notdan> vektor: so 2:3:[] becomes 2/3/36
03:41:50 <jle`> it sounds like it covers this
03:42:09 <vektor> notdan: which is evaluated right-associatively.
03:42:12 <vektor> alright
03:42:19 <jle`> kinslayer: scotty not doing it for you?
03:42:19 <notdan> jle`: do you know about the >=> operator?
03:42:39 <jle`> notdan: i know it, but i do not know how it relates to Maybe x Maybe -> Maybe
03:42:49 <jle`> like i know what it does, computationally
03:43:02 <notdan> jle`: put it this way, there is a standard function composition. And we also know that 'f . id = f'. Returns is similar but for monadic composition >=>
03:43:08 <kinslayer> well I just feel like when something is not working I am really feeling confused, and it seems somewhat easier to work on the local machine in haskell at least for now, and what is scotty ?
03:43:14 <navaati> jle`: fish is the morphism composition in the kleisly category
03:43:33 <notdan> kinslayer: scotty is a micro web framework for haskell, much like ruby's sinatra
03:43:37 <jle`> kinslayer: it's a fairly low-level web framework
03:43:43 <jle`> minimal magic
03:43:55 <kinslayer> oh that would be nice, gotta check it out, thanks
03:44:14 <kinslayer> Well I got around to write something which interacts with mongoDB
03:44:48 <jle`> notdan: okay, so how can i represent the idea of a monoidal product on functors in terms of kleisly arrows?
03:44:55 <kinslayer> so now I just need someway to shuffle stuff into that module properly gonna use some form of sockets for that :D
03:45:07 <jle`> kinslayer: great :) what database wrapper/orm are you using?
03:45:16 <notdan> Maybe :: forall a. a -> Maybe a. (Maybe x Maybe) ~~ (forall a. a -> Maybe a x forall a. a -> Maybe a)
03:45:36 <notdan> you can compose two functions (a -> Maybe a) with (>=>)
03:45:36 <kinslayer> jle`: I just use Database.MongoDB I really hate orm's
03:45:43 <notdan> so that's the interpretation of the product
03:45:58 <kinslayer> jle`: and also I really don't like the sql databases very much
03:47:04 <notdan> For functions you have mempty = id; mappend = (.). Similarly for monads mempty = return; mappend = (>=>)
03:47:08 <jle`> kinslayer: you might find yourself being fond of typesafe orms ^.^  but if your wrapper has a lot of type safety then that is cool too
03:47:48 <jle`> :t (>=>)
03:47:48 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
03:47:54 <jle`> oh that's neat.
03:47:59 <notdan> :t (.)
03:47:59 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:48:11 <jle`> so what is a (a -> m b) ?
03:48:19 <kinslayer> I am not sure about how typesafe my wrapper is, however when all data being pushed to the DB will already have been through a program I will write and being parsed so I think it should workout...
03:48:23 <jle`> is there a name for that?
03:48:32 <notdan> jle`: kleisly arrow
03:48:36 <Gerldus> notdan: Can you help me one more time?
03:48:40 <jle`> okay. so Just is a kleisly arrow
03:48:42 <notdan> kleisli*
03:48:51 <notdan> Gerldus: sure
03:48:57 <jle`> about about the kind * -> F * ?
03:49:02 <jle`> (is that proper kind notation)
03:49:07 <jle`> like, whatever Maybe is
03:49:14 <jle`> is that a type kleisly arrow?
03:49:18 <notdan> I don't think so, I am not really keen on kinds tbh
03:49:21 <notdan> :k Just
03:49:22 <lambdabot>     Not in scope: type constructor or class `Just'
03:49:22 <lambdabot>     A data constructor of that name is in scope; did you mean -XDataKinds?
03:49:31 <notdan> oh right
03:49:36 <notdan> functions dont have kinds
03:50:04 <notdan> :k Maybe
03:50:04 <lambdabot> * -> *
03:50:24 <jle`> kinslayer: here is a cute story.  i had a fairly large project with a lot of places where queries enter and exit, and where i use those.  one day, I decided to change one of my data fields to be nullable.  or maybe change one of their types from Double to Int.
03:50:27 <Gerldus> notdan: I still can't install Fay because it requires cabal v1.19, and I have just 1.18. I've run `cabal install cabal cabal-install`, but version remained the same. How to upgrade?
03:50:41 <jle`> kinslayer: GHC immediately told me every single place in my application where there would be a problem
03:50:44 <jle`> if I had been using, say, Ruby
03:50:52 <jle`> I might have noticed maybe 90% of them
03:50:58 <jle`> the other 10% showing up some time in production
03:51:03 <jle`> very fantastically
03:51:12 <kinslayer> jle`: yeah the GHC is pretty awesome about that
03:51:33 <jle`> but i guess NoSQL things don't have schemas
03:51:55 <jle`> does it go 'into' your database as something type-less?
03:52:00 <donri> who needs an external database anyway :)
03:52:03 <jle`> (this is my own curiosity)
03:52:11 <jle`> if you decided to change a field to be a different type
03:52:29 <jle`> is there a single point where you could change one thing
03:52:39 <jle`> and every single problem point shows up?
03:52:59 <jle`> there might not be an equivalent concept in nosql admittedly
03:53:25 <donri> nosql document stores tend not only to be schemaless, they tend to enforce no structure on individual documents
03:53:41 <jle`> so does that mean that type safety is inherently limited?
03:53:45 <donri> so you can have two BlogPosts with different fields
03:54:08 <AlainODea> Gerdlus: building Cabal from github is described here.  It's not as wild as it sounds :) http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
03:54:21 <jle`> if you change what you put in at one location, would you have to worry yourself about what you take out at another?
03:54:32 <AlainODea> Gerdlus: I did that recently to avail of cabal sanboxes
03:55:05 <notdan> AlainODea: you can install the latest cabal straight from hackage; no need to use the git version
03:55:17 <jle`> or would changing the place where you persist your data not affect the places where you retrieve it
03:55:31 <jle`> like, as far as the compiler knows
03:55:43 <donri> jle`: depends on how you interact with the external database from haskell. if haskell is doing all the interactions, you could enforce the types on that end
03:56:03 <AlainODea> notdan: cabal install cabal? I did this a few weeks ago so was there a new release of cabal to hackage
03:56:30 <notdan> cabal install cabal-install
03:56:31 <notdan> ;S
03:56:41 <jle`> hm i'll look into it more
03:57:05 <jle`> it just sounds like type safety's power is more limited than with a fixed schema database
03:57:16 <donri> jle`: it's not just nosql though. nullable in sql is usually still the same type, but in e.g. the persistent package it becomes Maybe
03:57:34 <notdan> yeah many nosql databases have server-side functions that they can run
03:57:46 <notdan> in mongodb they are written in JS, which is... well javascript
03:58:01 <jle`> donri: yeah, but you give persistent a schema in terms of haskell types (Maybe) and it'll enforce it at every point of entry and every point of exit
03:58:19 <AlainODea> notdan: Gerdlus did that and it didn't work.  I had the same thing happen to me. Maybe something strange with PATH on Ubuntu using haskell-platform from APT
03:58:36 <donri> jle`: exactly. you could do the same with any other type of storage or database
03:58:57 <jle`> but you need a schema of some sort, some sort of expecation?
03:59:11 <donri> jle`: which you can encode in haskell, outside the db
03:59:12 <jle`> some way to explicitly specify what kind of data you are expecting to find?
03:59:35 <jle`> yes, persistent can wrap nosql just as well as sql
03:59:43 <jle`> so what is the advantage of using one over the other?
03:59:46 <jle`> as your backend?
03:59:56 <jle`> is it just interoperability with existing databases?
04:00:08 <donri> which ones?
04:00:14 <jle`> but if you enforce schemas, aren't you losing the entire spirit of nosql in the first place?
04:00:14 * hackagebot monad-logger 0.3.4.0 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.4.0 (MichaelSnoyman)
04:00:16 * hackagebot wai-extra 2.0.1.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-2.0.1.2 (MichaelSnoyman)
04:00:41 <kinslayer> so a stupid question does scotty support stuff like websockets ?
04:00:48 <jle`> you can do the thing where you explicitly specify your data, your schema, outside the db, but then isn't that against the spirit of nosql?
04:00:58 <jle`> kinslayer: i think wai handles websockets
04:00:58 <donri> kinslayer: it should, because i think wai does
04:01:29 <donri> jle`: duno what the spirit is :) it's a vague term, nosql
04:01:30 <kinslayer> Hmm Maybe this could be appropriate in the project I work on at the moment.
04:02:47 <jle`> donri: heh. well the whole 'point' of nosql is that you can have flexible and dynamic data and schemas and stuff, right?  but if you do strict type checking of all of your schemas and enforce them rigidly then it's like what's the real advantage
04:03:15 <AlainODea> jle`: in practice there's no performant way to use the same data access patterns (querying, navigation, iteration) on all backing data stores without writing some application-specific code for each.
04:03:17 <jle`> notdan, navaati -- thanks for your help, i best be off but you guys were good help
04:03:24 <donri> jle`: maybe. probably. people do the same with sql though, people rarely use databases properly :P
04:03:35 <notdan> yeah i'll get going too
04:03:38 <notdan> was nice talking to you
04:04:19 <AlainODea> jle`: the advantage of NoSQL is that you can enforce schemas in code instead of in the data store which allows for much more flexibility in directly modeling the true invariants of your data.
04:05:22 * hackagebot yesod-core 1.2.6.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.6.4 (MichaelSnoyman)
04:05:30 <jle`> AlainODea: ah that makes sense
04:05:30 <donri> much like runtime type checking! :)
04:05:46 <jle`> you can still have schemas, but your schemas don't have to be erelated to your data store's native schemas?
04:05:46 <kinslayer> hmm so now my cabal complain about  Wai-Extra not being able to install... :(
04:05:54 <jle`> kinslayer: are you sandboxing?
04:06:07 <kinslayer> err no I am not using cabal-dev
04:07:24 <henk> How would I find out which timezone abbreviations Data.Time.ZonedTime does understand? It recognizes CEST just fine, but just returns '+0000' for NUT, which is wrong …
04:07:43 <kinslayer> jle`: should I use someform of sandbox to build scotty ?
04:08:19 <jle`> kinslayer: yes if possible
04:08:42 <jle`> not sure if it'll help, but try it and post your error
04:08:44 <kinslayer> jle`: so I should build in cabal-dev (then what to do with deployment ?)
04:09:01 <jle`> kinslayer: in deployment you would hopefully have a clean slate
04:09:28 <kinslayer> ah so my build error is from my having something that conflicts :D
04:09:32 <jle`> perhaps
04:09:38 <jle`> also once you get all your packages running
04:09:45 <jle`> you should lock their versions down
04:09:48 <jle`> in your .cabal file
04:10:03 <jle`> so when you move to deployment, cabal will build exactly what versions it needs of everything
04:10:24 <kinslayer> That is always a good idea, so how do I lock my .cabal ?
04:10:39 <kinslayer> wouldn't there be some clever command for that ?
04:11:17 <kinslayer> well well wai-extra-2.0.1 still wont install....
04:11:53 <jle`> kinslayer: what is the exact error? can you lpaste it?
04:12:00 <kinslayer> I will try
04:12:17 <jle`> fair warning, i am heading off now
04:12:24 <jle`> but if you post your error people will be more able to help
04:12:54 <jle`> send me a query if you have any unresolved problems
04:13:31 <AlainODea> kindlayer: you need cabal 1.19 which is not released to Hackage.  Install from Github is described here: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
04:13:36 <kinslayer> http://lpaste.net/97561
04:24:21 <zett_zelett> I’m depressed.
04:24:27 <zett_zelett> I want to read Learn You A Haskell.
04:24:43 <zett_zelett> But I’m always interrupted and for four days I’ve been reading the same chapter over and over.
04:25:30 <zett_zelett> And I feel like I already know it all, but I’m not acquainted with anything and I haven’t internalize anything.
04:25:32 <zett_zelett> : – /
04:26:57 <dv-> sell your earthly posessions, find a cave,...
04:31:45 <Cr8> zett_zelett: build something
04:35:58 <vyorkin> zett_zelett: the same problem (%
04:39:28 <zett_zelett> Cr8: What do you mean by that?
04:40:00 <Cr8> I find it's easier to internalize concepts after you've applied them in anger
04:40:19 <Gerldus> Hey guys! I'm trying to `cabal install fay`, but having troubles with type-eq. Can someone help with this?
04:41:55 <Gerldus> Also there is a weird warnings that tell "The directory /Users/arthurfayzrakhmanov/Library/Haskell/ghc-7.6.3/lib/<SMTH>" is not in system search path. What should I do?
04:45:47 <zett_zelett> I want to implement natural numbers as a data type.
04:45:51 <zett_zelett> How shall I go about it?
04:51:02 <donri> zett_zelett: it's either zero or the successor of another natural number. do you know how to define sum types?
04:52:06 <zett_zelett> Yeah, I tried to define it as `data Nat = Zero | Succ Nat`.
04:52:23 <zett_zelett> But then I wouldn’t know how 0 could be understood as a natural number?
04:52:43 <donri> zett_zelett: ah, you want number literals?
04:52:48 <zett_zelett> Yeah.
04:52:59 <zett_zelett> (Also, zero notoriously is no natural number.)
04:53:17 <donri> you'd need to write a Num instance
04:53:36 <zett_zelett> Isn’t this discouraged?
04:53:49 <zett_zelett> Oh, no.
04:53:56 <zett_zelett> Sorry, I misunderstood you.
04:54:09 <donri> you can define it as data Nat = One | Succ Nat if you prefer. there doesn't seem to be any consensus on if zero is natural or not
04:54:55 <zett_zelett> I know, donri. ; – )
04:56:58 <zett_zelett> How can I make something an instance of Num (and Enum, and Ord), though?
04:57:21 <zett_zelett> I mean, I know how to make something an instance of a typeclass, but I need to know what to specify.
04:57:33 <zett_zelett> Oh, hoogle!
04:57:35 <donri> see http://hackage.haskell.org/package/base-4.6.0.0/docs/Prelude.html#t:Num
04:58:26 <donri> it's gonna be a bit awkward for Nat though, e.g. negate (Succ Zero)
04:59:00 <zett_zelett> Isn’t there a better way, then?
04:59:16 <donri> not if you want number literals
05:01:59 <zett_zelett> Hm. This is a bit disappointing.
05:02:13 <bitemyapp> Scotty's source code is pretty entertaining.
05:02:24 <Gerldus> #caball
05:03:00 <Gerldus> How can I jump to another one chanell?
05:05:14 <gronkalonk> hi peoples
05:05:44 <donri> Gerldus: /join
05:06:17 <donri> Gerldus: the channel is #hackage though
05:07:26 <Gerldus> donri: thank! I have trouble with cabal and Fay
05:07:42 <donri> Gerldus: yes, didn't you get help with that before? CPP issue with clang?
05:08:22 <Gerldus> donri: It's look like my case, but I'm unsure.
05:09:12 <gronkalonk> why won't anyone extend haskell to include uniqueness types/linear types so that we can experiment with dumping IO/ST for effectful computations?
05:09:26 <Gerldus> donri: Asked on Stack http://stackoverflow.com/questions/20785260/cant-install-fay-on-mac-os-x-mavericks
05:09:39 <donri> sorry i don't use os x
05:10:17 <gronkalonk> don't need to dump them, just nice with more ways of doing the same things
05:11:23 <quchen> gronkalonk: There is not enough supply or demand to implement such a feature.
05:11:39 <vektor> general programming question ahead: Is it possible to link a executable file to a .so/.dll file only after the exec. has started? i.e. I start the exe, generate the .dll file afterwards, but before actually calling the functions the .dll exposes, and link the .dll before calling those functions.
05:12:51 <gronkalonk> can I file it as bug?
05:13:19 <gronkalonk> and also perhaps the response of " There is not enough supply or demand to implement such a feature"'
05:13:28 <gronkalonk> I think it is also a bug
05:14:31 <donri> vektor: dynamic linking?
05:15:06 <quchen> No, it's not a bug. It doesn't exist by design. A bug is something that unexpectedly exists.
05:15:23 <donri> @hackage plugins does this for haskell
05:15:29 <lambdabot> http://hackage.haskell.org/package/plugins does this for haskell
05:15:29 <quchen> Haskell cannot read email on a source level. That's also not a bug.
05:15:55 <gronkalonk> if I find clever way of framing it as bug, will it be a bug?
05:15:59 <ciaranm> no
05:16:16 <ciaranm> bug: people think linear types are a good way of doing anything
05:17:06 <gronkalonk> ciaranm, haha you're that gentoo troll right?
05:17:16 <gronkalonk> never thought I'd see you here
05:17:24 <quchen> @ops
05:17:24 <lambdabot> Maybe you meant: pl oeis docs
05:19:04 <donri> needs @where
05:19:16 <donri> but do we need ops now?
05:20:38 <fizruk> vektor: you also might be interested in libffi package
05:23:25 <zett_zelett> I just want Nat₀ with some number literals. : – /
05:24:03 <vektor> donri: what does that package do? will it help with implementing this function: https://github.com/vektordev/haskell-playground/blob/master/src/RuntimeCompiler.hs (the actual implementation below is just to keep the compiler from complaining)
05:25:09 <donri> vektor: yes, but it doesn't prevent evil
05:25:46 <vektor> well, I guess I have to add safehaskell then
05:26:01 <vektor> is that possible? adding safehaskell to plugins?
05:26:16 <donri> should be. but safehaskell doesn't provide safe compilation
05:26:28 <donri> http://hackage.haskell.org/trac/ghc/wiki/SafeHaskell/SafeCompilation
05:28:31 <donri> vektor: this might interest you for that http://hackage.haskell.org/package/restricted-workers
05:30:24 <vektor> so many links to check out. I didn't suspect it was so hard to get that stuff done when I started it.
05:30:45 <vektor> restricted workers allows me to create sub-processes / "threads" that have restricted hardware/OS access? Damn, that sounds just about right.
05:31:12 <donri> vektor: you could look at mueval if all you want is something like what lambdabot does
05:31:33 <donri> @hackage mueval
05:31:33 <lambdabot> http://hackage.haskell.org/package/mueval
05:31:48 <donri> that's using the ghc interpreter rather than compiling
05:31:58 <vektor> I don't think lambdabot could do it. I essentially want to plug a genetic algorithm (which is only developed at runtime) into my program.
05:32:24 <vektor> I think I'd rather use a compiler there. Not sure though, I might end up trying out both.
05:33:01 <donri> vektor: doesn't sound like you need secure sandboxing though?
05:33:10 <vektor> Oh, you want some skynet?
05:33:12 <vektor> :D
05:33:19 <donri> or is the code getting compiled coming from an untrusted source
05:33:39 <vektor> I don't consider the genetic algorithm itself trustworthy. :D
05:33:58 <donri> heh
05:34:00 <vektor> Because that's the core concept: AI algorithm rewrites itself in an Artificial Life simulation.
05:34:19 <vektor> So if the GA decides to produce unsafe / evil code, not good.
05:34:39 <donri> what about some kind of deep embedding instead
05:34:46 <vektor> I mean, I don't suspect skynet to break free from this project. But it'll prolly crash/break my system if I screw it up :D
05:35:00 <vektor> deep embedding?
05:35:08 <donri> :) well you could run the program itself in a sandbox, without building sandboxing into the program itself
05:35:39 <vektor> I doubt the sandbox will withstand that kind of punishment for long enough to produce results
05:35:39 <donri> deep embedding as in, some edsl that you interpret at runtime that can thus modify itself at runtime
05:37:08 * vektor is reading up on DSLs.
05:39:21 <vektor> oh. Essentially, I seem to have tried making my own interpreted DSL for this exact problem before, when I tried to implement it in c++.
05:39:55 <m1dnight> could anyone help me with a query?
05:39:56 <m1dnight> I have a query that should return a single event (select on prim key)
05:40:07 <m1dnight> but the function returns it in the form of a list
05:40:15 <m1dnight> getEvent :: Handler App Sqlite Event | This is what I want
05:40:24 <m1dnight> getEvent :: Handler App Sqlite [Event] | This is what is is atm
05:42:40 <donri> m1dnight: it probably doesn't know that statically. also, what if there's no event? but you can apply "head" to get the first event or error if there's zero
05:43:06 <donri> fmap head getEvent :: Handler App Sqlite Event
05:43:11 <vektor> m1dnight: or instead of erroring, you could use maybe.
05:43:19 <m1dnight> oh yeah that's a good idea
05:43:27 <donri> :t listToMaybe
05:43:28 <lambdabot> [a] -> Maybe a
05:43:35 <m1dnight> i think i have it working now though, but it won't compile with my code that uses it
05:43:38 <donri> can be used instead of head
05:43:39 <m1dnight> lets figure that one out first
05:43:57 <m1dnight> protip: *having* to build a calendar app with Snap if you *just* learned monads -> bad idea
05:44:17 <donri> or, great idea :)
05:45:23 <vektor> m1dnight: depends
05:45:30 <m1dnight> not really no :p I have zero experience with haskell
05:45:30 <m1dnight> all I'm doing is copy pasting code from examples and just making it work :p
05:45:30 <m1dnight> im gonna be glad if I get a 10/20 :p
05:45:50 <vektor> I learned c++ the hard way. Then I learned ogre3d after a few weeks of c++. Not saying it was pleasant, but I think I hardly ever learned  that fast again.
05:46:06 <m1dnight> that's what I hate atm, i'm not learning anything
05:46:15 <m1dnight> I can figure out the basic type inferencer errors
05:46:17 <m1dnight> but that's about it
05:46:27 <m1dnight> I have no grasp on the inner workings whatsoever
05:46:29 <m1dnight> and that's what I hate
05:46:48 <m1dnight> If I had like a month or smth, okay, but not in a week :p
05:49:18 <jfischoff> @tell mgsloan I thought you might appreciate this, http://hackage.haskell.org/package/modulespection-0.1.0.5 now that the parsing works with CPP and other extensions
05:49:19 <lambdabot> Consider it noted.
05:50:49 <donri> jfischoff: hmm hmm looks like a nicer http://hackage.haskell.org/package/language-haskell-extract ?
05:51:42 <jfischoff> donri: until you look at src ;:
05:52:15 <jfischoff> language-haskell-extract doesn't use haskell-src-exts or the GHC API for parsing
05:52:25 <jfischoff> it completely ignores comments for instance
05:52:27 <donri> jfischoff: i don't think there's a nice way to do this so any source will be scary :)
05:52:35 <jfischoff> its really annoying
05:52:35 <haf> hi
05:52:43 <donri> it used to use HSE
05:53:23 <jfischoff> donri: I'm using the GHC API so more code will parse correctly
05:53:34 <haf> can someone help me understand how to chain machines together? https://github.com/pocketberserker/FsMachines
05:53:34 <donri> jfischoff: nice
05:53:35 <jfischoff> assuming you are using GHC ;)
05:53:49 <haf> it comes from https://github.com/ekmett/machines
05:53:51 <donri> jfischoff: how does it parse Data.Monoid, where does it find the source?
05:54:12 <jfischoff> donri: it also only tries to find function names I think
05:54:21 <haf> trying to write plans for piecewise IO and serialisation and crc checksumming
05:54:27 <haf> and I can't see the forest for all the trees
05:54:30 <jfischoff> donri: it doesn't use the source
05:54:32 <donri> jfischoff: (you might've misread me; i said yours looked nicer ;))
05:54:45 <jfischoff> donri: oh
05:54:54 <jfischoff> :)
05:55:35 <jfischoff> donri: anyway the GHC API can just load the Data.Monoid module and get the exports
05:55:48 <Geraldus> Can someone help with this: `Illegal literal in type (use -XDataKinds to enable): 1`
05:56:03 <donri> jfischoff: oic it's basically doing :browse?
05:56:08 <jfischoff> yep
05:56:08 <donri> neato
05:56:29 <jfischoff> exactly, I looked at the browse code to figure out how to do it ;)
05:56:53 <jfischoff> pretty much copied and pasted it and cleaned it up
06:01:03 <pavonia> I want values of my data type to be composable in two direction, as a sum and as a product. What could I use as an alternative to Alternative (for sum) for data types that don't take an argument, when I already use Monoid for product?
06:01:22 <kinslayer> zett_zelett: Have you tried writing small programs ? I find that to be the most effective way to learn programming, including haskell
06:01:50 <donri> pavonia: newtype wrapper
06:02:18 <haf> Does somebody know a good resource for piecewise monadic (and monoid-based/incremental hashing) IO?
06:02:25 <haf> Can anybody read this?
06:02:44 <pavonia> Hhm, that isn't really nice
06:02:57 <t4ck> Does somebody know a good resource for piecewise monadic (and monoid-based/incremental hashing) IO?
06:03:15 <Hafydd> t4ck: yes, we can read it.
06:03:21 <t4ck> I'm finding an explosion of 'this is how my library does it'
06:03:26 <t4ck> Hafydd: thanks for replying
06:03:29 <jfischoff> pavonia: http://hackage.haskell.org/package/algebra-3.1/docs/Numeric-Algebra-Class.html#t:Semiring
06:03:29 <pavonia> donri: You mean using two Monoid instances, right?
06:03:31 <t4ck> I never know about these web clients
06:03:37 <donri> pavonia: agreed. i think edwardk has additive and multiplicative monoids somewhere...
06:04:04 <donri> oh yeah jfischoff's link
06:04:04 <jfischoff> yeah actually a semiring might be too much structure
06:04:29 <donri> and semigroups not monoids. the monoids package has them but deprecated :(
06:04:45 <jfischoff> like donri said, you might just want Additive and Multiplicative
06:05:05 <t4ck> How do you do piecewise IO guys?
06:05:07 <pavonia> jfischoff: Are there no operators for this class?
06:05:19 <jfischoff> the operators are in the superclasses
06:05:36 <Hafydd> t4ck: I may not be able to answer your question, but I'm curious to know what "piecewise monadic IO" is, and how it relates to incremental hashing.
06:05:59 <t4ck> Hafydd: I'm just trying to write a functional kafka client.
06:06:14 <t4ck> piecewise is that I want somehow to control the memory versus speed equation
06:06:24 <t4ck> not doing everything in large batches
06:06:40 <t4ck> having a tuner on the non-functional-requirement pieces of the client
06:06:49 <Hafydd> Ah.
06:07:04 <t4ck> it's being able to construct your computation without executing it
06:07:07 <t4ck> and being able to inspect it
06:08:01 <t4ck> having a functional "declarative" way (similar to applicative functors in web frameworks) of specifying running side-effects (which are only side effect to the extent that they need to be a part of the running/windowed state that the serialiser/writer (?) is doing)
06:08:30 <t4ck> there are things that are stateful from start and onwards; gzip for example
06:08:42 <t4ck> (lazy fold)
06:09:03 <t4ck> then there are things that need to go inside the byte stream, crc32 numbers, on different pieces of data/serialised types
06:09:07 <pavonia> donri, jfischoff: Okay, thanks
06:09:16 <t4ck> Hafydd: does it make sense?
06:09:52 <t4ck> Hafydd: I've found https://github.com/ekmett/machines but the code there, as well as https://github.com/pocketberserker/FsMachines is too opaque for me to get just out of the box
06:09:57 <merijn> t4ck: Yes, although I don't think there is (necessarily) an existing way to do everything you want
06:10:00 <t4ck> so I need documentation to read more
06:10:08 <Hafydd> t4ck: I don't see how that differs from Haskell's standard IO facilities, except possibly for the requirement to "somehow to control the memory versus speed equation".
06:10:16 <merijn> t4ck: Probably you want to take a look at pipes (or conduits, but I believe pipes is more elegant)
06:10:47 <Hafydd> That will rely on the garbage collector's behaviour, I can only imagine.
06:10:54 <merijn> t4ck: pipes deals with stream operations (such as gzip, crc32, etc.) so you can do them incrementally (and thus with fairly static memory consumption)
06:10:55 <t4ck> that's not the main requirement
06:11:20 <t4ck> how are they different from OOP streams?
06:11:33 <merijn> t4ck: Although they're not really inspectable. You could define your own "inspectable pipeline" type and then reify that into pipes for execution
06:11:55 <merijn> t4ck: Conceptually I'm guessing they're pretty similar to OOP streams, but I'm not too familiar with the latter
06:12:14 <t4ck> that's what I want to go beyond
06:12:29 <merijn> t4ck: The pipes tutorial is fairly simple and they have a rather active mailing list for beginner and advanced questions
06:12:49 <merijn> t4ck: Maybe start here and see whether it's relevant for you: http://hackage.haskell.org/package/pipes-4.0.1/docs/Pipes-Tutorial.html
06:13:27 <t4ck> starts out good, let me have a read
06:28:40 <jfeltz> i know it's wrong to have a hard-on for github, but has someone written a script to accelerate the github/hackage package submission cycle?
06:30:20 <tristan_1> damn, is there no 'race' that takes a list, I have 3 functions I wanted to pass to race,hehe
06:30:42 <Rarrikins> What is race supposed to do?
06:30:43 <jfischoff> jfeltz: I think you just volunteered yourself
06:30:57 <tristan_1> Rarrikins: runs two IO functions concurrently
06:31:35 <bennofs> jfeltz: I'd also be interrested in a script for that! I've been thinking about integrating it with travis-ci and upload a new version only if the 'version' field in the package cabal file changed and all tests pass.
06:31:35 <tristan_1> and kills the other if one ends
06:33:57 <jfischoff> bennofs: oh good idea
06:35:25 * hackagebot quickcheck-property-comb 0.1.0.1 - Combinators for Quickcheck Property construction and diagnostics  http://hackage.haskell.org/package/quickcheck-property-comb-0.1.0.1 (jfeltz)
06:36:32 <bennofs> I wonder how deployment on travis-ci works when you have multiple builds in your build matrix
06:36:38 <zcourts> Is it possible to refer to a constructor B from another constructor C in the same data declaration? Something like data A = B {f1::Int} | C {f2::String, f3:: [B]} - causes compile error saying B is already in scope
06:37:24 <donri> tristan_1: you could foldM race
06:38:19 <donri> hmm will that do what you want though
06:38:33 <jfischoff> zcourts: you're using B as a type and constructor, I assume you would get a not in scope error
06:38:42 <donri> you'd be racing races, i think
06:38:46 <donri> might work
06:38:52 <tristan_1> hm, don't think so. no worries if it isn't something exists already. Its just for an example right now, so I'm just using forkIO
06:39:09 <tristan_1> will come back to it later
06:40:18 <bennofs> tristan_1: you might like waitAnyCancel from the async package
06:40:21 <donri> tristan_1: although i think you want waitAnyCancel
06:40:25 <donri> yeah
06:40:27 <kinslayer> Okay I would really like to get this fixed, wai-extra wont build since System.Log.FastLogger isn't exporting logStrBuilder, so how can I fix this ?
06:40:37 <zcourts> jfischoff: ahhh - overlooked treating B as both. thanks
06:41:39 <tristan_1> bennofs: donri ah, ok, that does look like what I want, thanks!
06:45:34 <donri> fmap snd . waitAnyCancel <=< mapM async
06:58:23 <m1dnight> could somebody kickstart me on how to have a form in Snap, with values filled in? (it should be used to edit values)
06:59:03 <donri> m1dnight: probably want to look at digestive-functors
06:59:40 <Clint> why doesn't snap like reform?
07:00:28 <donri> too type safe ;)
07:01:17 * Clint squints.
07:06:22 <mm_freak_> with snap you would probably use digestive-functors
07:07:04 <mm_freak_> i prefer digestive-functors anyway…  i wish it would work better with happstack
07:20:08 <dsfsdfs> Can I use typeclasses in records?
07:20:40 <merijn> dsfsdfs: That depends on what you mean
07:20:51 <dsfsdfs> Something like this: data Foo = Foo {foo :: Num a => [a]}
07:22:01 <Saizan> dsfsdfs: yes, that means foo is a list of any Num instance the user might like, btw
07:22:12 <merijn> dsfsdfs: Yes, but it requires one of two possible extensions, though
07:22:15 <Saizan> dsfsdfs: so when you build it you're going to be very restricted
07:22:40 <merijn> dsfsdfs: Which depends on what you want
07:22:53 <merijn> Saizan: It's a compile error for me unless you enable extensions
07:23:03 <merijn> dsfsdfs: How do you plan to use that list?
07:23:31 <dsfsdfs> merijn: I haven't decided yet. Just exploring the possibilities.
07:23:56 <merijn> dsfsdfs: With the RankNTypes extension this works and forces people to provide a polymorphic list
07:24:10 <dsfsdfs> merijn: I should have asked: "Is it possible without extensions?"
07:24:17 <merijn> dsfsdfs: No
07:24:24 <dsfsdfs> Ah, OK. Thank you.
07:25:04 <merijn> dsfsdfs: On the other hand, extensions are not necessarily something to avoid
07:30:37 * hackagebot luautils 0.1.2 - Helpers for Haskell integration with Lua  http://hackage.haskell.org/package/luautils-0.1.2 (AnupamJain)
07:33:12 <derdon> where in the quickcheck docs can I find how the signature of property functions have to look like?
07:37:12 <Feuerbach> derdon: look at the instances of the Testable class (or something similar)
07:38:35 <derdon> http://hackage.haskell.org/package/QuickCheck-2.6/docs/Test-QuickCheck-Property.html#g:1 doesn't really help me much
07:39:24 <derdon> Property is defined as "type Property = Gen Prop" and neither Gen nor Prop is documented
07:39:53 <derdon> and the documentation of Testable is just "The class of things which can be tested, i.e. turned into a property."
07:40:21 <derdon> are all haskell packages documented like this?
07:40:37 <Feuerbach> yes, no exceptions
07:40:55 <Feuerbach> what's your goal? if you just want to write properties, then you only need instances Testable Bool and (Arbitrary a, Show a, Testable prop) => Testable (a -> prop)
07:41:37 <Feuerbach> we're bad at writing docs, hence this channel
07:42:01 <derdon> :|
07:42:47 <Feuerbach> perhaps you can help us?
07:43:32 <derdon> I'm only a beginner and fail to get how quickcheck works
07:43:40 <Saizan> tbf quickcheck has a separate tutorial/docs
07:43:53 <Saizan> they might be a bit stale but are nice
07:43:56 <Feuerbach> try this: http://ocharles.org.uk/blog/posts/2012-12-08-24-days-of-hackage.html
07:44:33 <derdon> Saizan: the one from the haskell wiki or the manual which uses framesets?
07:44:59 <derdon> Feuerbach: thanks, maybe this'll help
07:45:07 <Saizan> the manual
07:46:01 <derdon> totally unrelated note: it's almost the year 2014
07:46:04 <Feuerbach> ocharles: btw, that article says that smallcheck generates random data, which is not true (there's no randomness there). Could you fix that?
07:50:08 <derdon> my question is: is the number of parameters for a property restricted in any way? may a property have one, two, three, ... parameters?
07:50:15 <Feuerbach> any number
07:50:28 <derdon> that's magic! how does it work?
07:50:31 * hackagebot quickcheck-property-comb 0.1.0.2 - Combinators for Quickcheck Property construction and diagnostics  http://hackage.haskell.org/package/quickcheck-property-comb-0.1.0.2 (jfeltz)
07:50:54 <jfeltz> ok, enough package spamming for one day XD
07:51:06 <Feuerbach> because of the Testable instances that I cited above
07:51:15 <Feuerbach> they are inductive
07:51:24 <Feuerbach> and anything Testable is a property
07:52:18 <derdon> in my code, no instance of Testable is created explicitly. no function called property or exhaustive is defined
07:52:38 <derdon> there is only a custom Arbitrary instance
07:52:51 <Feuerbach> you write functions, and those are already instances of Testable
07:53:00 <derdon> hmm
07:53:18 <Feuerbach> the function type, I mean
07:54:07 <derdon> every function that returns a Bool is a Testable because of the builtin "instance Testable Bool where ..." definition?
07:54:46 <Saizan> combined with the  (Arbitrary a, Show a,Testable prop) => Testable (a -> prop) one
07:55:01 <Saizan> well, as long as the arguments of the function fits those constraints
07:56:24 <derdon> and this can easily been by reading the docs? maybe I'm too dumb for this
07:56:32 <derdon> *be seen
07:56:57 <Feuerbach> I copypasted those instances directly from the docs you linked
07:57:09 <Feuerbach> you just have to learn to interpret them
07:57:27 <Saizan> look at the "instances" under the Testable class declaration
07:57:50 <Feuerbach> but only if you want to know how it works. As a user, just read a tutorial
07:59:08 <derdon> Feuerbach: to be honest, I was put off by the official manual because it's using framesets and well, they are so nineties that I thought this must be outdated documentation
08:01:45 <Feuerbach> maybe you'll like smallcheck's docs better: http://hackage.haskell.org/package/smallcheck-1.1.1/docs/Test-SmallCheck.html
08:01:51 <Feuerbach> (disclosure: I wrote it)
08:02:50 <Saizan> derdon: it is for version 1, but the usage hasn't changed, it mostly got a few more features
08:04:21 <Feuerbach> derdon: and if you find something that could be improved in smallcheck's docs, please open an issue or even send a pull request
08:04:53 <Feuerbach> it's hard for us to see where novices struggle
08:05:14 <derdon> Feuerbach: nice! this looks much better. starred the repo. won't use it in my current code because it's homework for uni and they expect us to use quickcheck
08:05:30 <derdon> Feuerbach: but I will probably use it when coding haskell outside of uni
08:06:53 <navaati> derdon: wich univ does expect you to use haskell ?
08:07:21 <derdon> navaati: I'm a CS student at the University of Bremen, Germany.
08:07:48 <derdon> and I'm very happy that we code in haskell because the language is really awesome :)
08:08:20 <navaati> in wich year ?
08:08:27 <derdon> third semester
08:08:34 <navaati> meh
08:08:41 <derdon> hm?
08:08:49 <navaati> maybe i should have done university...
08:09:08 <derdon> it's never too late ;)
08:09:50 <navaati> in my school, they expect us to use, you know, java. oh, simple java tho, else the teacher would not understand the code
08:09:59 * navaati hangs himself
08:10:24 <derdon> navaati: we program in Java as well.
08:10:40 <derdon> well, I currently don't because I only took two courses this semester :D
08:11:01 <navaati> but i dunno if any school knows about haskell in crappy france
08:11:02 <ciaranm> well you should do a cs or maths degree, not a programming degree
08:11:17 <ciaranm> don't go to a french university!
08:11:27 <derdon> navaati: France? don't you have to do everything in OCaml then? :P
08:11:29 <navaati> oh, java is not (so much) the problem
08:11:33 <ciaranm> they have this silly idea that they can teach you science subjects in french. which is obviously absurd.
08:14:06 <derdon> you can't do "True == True == True" in Haskell :(
08:14:10 <navaati> derdon: the only one using ocaml in france are the classes prépa, which are extremelly hard math class (math with number and stuff, not maths like in CS) intended to make you pass the extremely selective engineering school entry exams
08:14:22 <derdon> doesn't even math allows this kind of notation?
08:14:34 <tac_> derdon: what does math have to do with it? o__O
08:15:04 <ciaranm> the only language that allows that kind of insanity is perl6...
08:15:13 <derdon> tac_: well, part of haskell's syntax looks very much like math. e.g. list comprehensions
08:15:27 <navaati> ciaranm: oh it's worse, i'm in a network and telecom school ^^
08:15:59 <derdon> ciaranm: at least also Python supports it. in Python,  you can even write "2 < 4 < 5" :)
08:16:43 <tac_> derdon: If you've ever tried to implement a language before, you would know that weird syntax that doesn't follow the rest of the rules adds a lot of unnecessary complexity to the language.
08:16:50 <ciaranm> derdon: that's not just because of a crazy boolean to integer conversion, is it?
08:16:57 <navaati> but then, the CS degree are actually math and CS degree, and the first semester is, too, a big selective uninteresting math hammer
08:17:01 <tac_> In Haskell, (==) is just a function. It's not syntax
08:17:03 <tac_> @type (==)
08:17:04 <lambdabot> Eq a => a -> a -> Bool
08:17:08 <geekosaur> ciaranm, also Icon
08:17:09 <tac_> @type 2 == 3
08:17:09 <lambdabot> Bool
08:17:17 <derdon> ciaranm: no. "2 < 4 < 5" is translated to "2 < 4 and 4 < 5"
08:17:19 <ciaranm> i mean, you could make (==) return a type like ChainableComparison Int
08:17:26 <ciaranm> and do it still at the type level
08:18:02 <derdon> tac_: yeah, I see now why it shouldn't be supported in haskell
08:18:11 <ciaranm> so (==), (<) etc would return effectively a pair (the value, the result), and then 'if' would look at the result and chained comparisons would look at the value
08:18:21 <ciaranm> but it's ugly
08:19:02 <Feuerbach> what about 2 < 10 > 5 vs 5 < 2 < 10?
08:19:20 <Feuerbach> you'd need to differentiate the two
08:19:34 <Feuerbach> because one is true and the other is false
08:20:06 <mangaba_leitosa> ciaranm: are you Frenchman yourself? You believe that French is too poor a language to be used for teaching ?
08:20:45 <derdon> Feuerbach: "2 < 10 > 5" is translated to "2 < 10 and 10 > 5" so this is consistent
08:20:49 <mangaba_leitosa> is it so underdeveloped?
08:20:50 <ciaranm> mangaba_leitosa: i've experienced french scientific writing, where they insist upon using government-mandated words that no-one knows to refer to technical things that have a perfectly good english name
08:21:11 <ciaranm> mangaba_leitosa: everyone knows what "email" is. there was no need for "couriel".
08:21:12 <mangaba_leitosa> ciaranm: :-)
08:21:37 <mangaba_leitosa> hm, couriel sounds cool :-)
08:21:42 <Feuerbach> derdon: my point is that those two comparisons should be equivalent, they are just a flipped version of one another
08:21:56 <Feuerbach> let x = 2 < 10 in (x > 5, 5 < x)
08:22:03 <cschneid> ciaranm: how much does it affect people working in industry? is it a small hurdle to learn the global words, or is it a real hinderance?
08:22:33 <ciaranm> cschneid: everyone else writes in english. and badly written foreign english is far easier to read than french with fake translations of technical terms.
08:22:39 <ciaranm> french scientists aren't allowed to use a word in a publication until the government has come up with an appropriate translation
08:23:04 <cschneid> ciaranm: right. Was just wondering how much people just say "Screw it" in industry and use the more normalized global terms.
08:23:13 <cschneid> I figure all the time, except when mandated otherwise?
08:23:17 <navaati> cschneid: the problem with france is that a majority of post high-school students still struggle horribly with english
08:23:21 <derdon> and what is the French word for "list comprehension"? Im curious because there is no good German translation for this term
08:23:54 <ciaranm> derdon: well it took twenty years before french people were allowed to talk about email, so they're probably not allowed to discuss list comprehensions yet
08:24:05 <ciaranm> germans would just call them "listkomprehensions"
08:24:35 <mangaba_leitosa> derdon: my english-russian dictionary says it's just a list generator :-)
08:24:36 <navaati> derdon: i've never seen a translation ever... "compréhension de liste", lol ?
08:24:53 <ciaranm> navaati: report to l'academie francaise for re-education
08:25:13 <derdon> my prof used the term "Listenumschreibungen". If you google it, you almost only get results from his slides
08:25:25 <navaati> ciaranm: hey ! i say courriel ! (sometimes)
08:25:45 <ciaranm> derdon: tell him to teach in english like everyone else!
08:26:13 <derdon> ciaranm: he. english lectures only start in masters, I think.
08:26:27 <charlie_sanders> "Listenumschreibungen" means list comprehensions ?
08:26:41 <derdon> charlie_sanders: only if you ask my prof
08:27:07 <derdon> otherwise, there is no German translation
08:28:02 <navaati> anyway, i don't live in france, i live in marseille
08:28:12 <geekosaur> heh
08:28:16 <derdon> "umschreiben" means "to paraphrase" by the way
08:28:32 * navaati wonders how does one say "list comprehension" in arab...
08:28:40 <ciaranm> marseille doesn't speak french. it sings it.
08:28:52 <navaati> x), so so
08:31:54 <navaati> so, hem, are CS courses in other country free of math analysis crap ?
08:32:07 <ciaranm> well you could do a "software engineering" degree
08:32:20 <bizarrefish> Hi all
08:32:22 <ciaranm> and spend your time learning how to draw UML diagrams instead
08:32:33 <navaati> ciaranm: wait, no
08:33:15 <tac_> A math-free CS degree? That sounds quite pragmatic.
08:33:39 <navaati> tac_: depends on what you call maths
08:34:06 <ciaranm> you could do a degree in "games development"
08:34:08 <enigmuri_> has there ever been an inquiry or review of whether haskell code that doesn't use any monads or unsafe functions can be guarenteed not to change state? I find those things interesting in terms of being able to trust other people's libraries
08:34:18 <navaati> i mean, when you do CS, do you care about reimann and shit ?
08:34:19 <tac_> A proper CS degree probably doesn't need a lot of math. But surely it needs discrete and an introduction to logic.
08:34:38 <enigmuri_> you should definitely learn at least basic discrete math though
08:34:42 <Dodek> navaati: at my university, in the first year on CS degree, out of 9 courses, only 4 are non-math.
08:34:44 * sm wonders how many hackage libs don't use any monads
08:34:46 <tac_> Proof-theoretic classes on languages, parsing, or computation are probably worth it to have at some point in small doses
08:34:47 <enigmuri_> graph theory, induction, etc.
08:34:52 <enigmuri_> makes a huge difference
08:34:54 <ciaranm> algebra, topology, category theory
08:35:00 <ciaranm> analysis, so you learn how to do proofs
08:35:01 <mangaba_leitosa> navaati: I am from russia and after finishing the school I wanted to study CS, but the only way to do so was to study 'applied maths' with 2 years of math analysis first. computer-related subjects began at the third year. So I went to study linguistics instead :-)
08:35:04 <enigmuri_> sm, i just mean theoretically
08:35:10 <navaati> tac_: all of these are fine
08:35:17 <enigmuri_> for security-critical stuff, and just as a thought experiment
08:35:35 <ciaranm> enigmuri_: considering how lists are monads...
08:35:40 <ciaranm> enigmuri_: and 'Maybe'
08:35:40 <enigmuri_> yeah i know
08:35:50 <enigmuri_> i mean unsafe monads
08:35:50 <ciaranm> i think you're confusing monads and IO
08:35:53 <enigmuri_> "sticky
08:35:56 <enigmuri_> " monads
08:35:56 <geekosaur> but neither is regularly used *as* a monad
08:35:59 <simon> at my university, if you don't count the algorithms course as a math course (only math-dependent), there's only two math-courses.
08:36:17 <enigmuri_> mangaba_leitosa: if you like linguistics, check out compilers
08:36:18 <simon> (mandatory 1st-year courses, that is)
08:36:23 <enigmuri_> a lot of that is straight linguistics
08:36:25 <navaati> i mean, i
08:36:32 <enigmuri_> all the language syntax specs and parsing
08:36:49 <mangaba_leitosa> enigmuri_: right, what's somewhat related :-)
08:37:12 <mangaba_leitosa> "that's" even
08:37:35 <enigmuri_> transferring is always an option too
08:37:45 <navaati> i mean, i know discrete maths, logic, category theory are maths. but they're related to CS
08:37:58 <derdon> why is the dollar sign required in http://hackage.haskell.org/package/QuickCheck-2.6/docs/Test-QuickCheck-All.html#v:quickCheckAll
08:38:23 <jfischoff> it is no longer required in recent versions of GHC
08:38:34 <derdon> I guess it has some special meaning and is not to be cunfused with the function application ($), is it?
08:38:34 <navaati> derdon: it's template haskell
08:38:45 <jfischoff> but was used to signify a template haskell splice
08:38:47 <Feuerbach> it is required
08:38:56 <Feuerbach> it's not top-level
08:39:02 <mangaba_leitosa> navaati: I ended up having many discrete maths courses when studing linguistics, but luckily not as much math analysis
08:39:07 <jfischoff> oh
08:39:11 <mangaba_leitosa> "studying"
08:39:39 <jfischoff> Feuerbach: you need it for expression splices I guess
08:39:57 <derdon> what is a splice?
08:40:09 <Feuerbach> yes — otherwise you won't be able to distinguish them from simple expressions
08:40:35 * hackagebot modulespection 0.1.0.6 - Template Haskell for introspecting a module's declarations  http://hackage.haskell.org/package/modulespection-0.1.0.6 (JonathanFischoff)
08:40:36 <jfischoff> yeah good point
08:40:37 * hackagebot hsimport 0.1 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.1 (DanielTrstenjak)
08:40:41 * derdon pulls out hist "MAGIC!" stamp
08:41:02 <navaati> mangaba_leitosa: russia seems similar to france. math as a way of selecting students eh ?
08:41:21 <derdon> navaati: that's the usual game for all science-related fields
08:41:25 <mangaba_leitosa> navaati: probably :-)
08:41:31 <derdon> first semester is a filter
08:41:41 <geekosaur> derdon: template haskell lets you generate haskell code at compile time. a splice is how you integrate that generated code into the compiler's internal representation of the current module
08:42:17 <derdon> geekosaur: ah, thanks for the explanation!
08:42:22 <geekosaur> the result of a template haskell expression is a fragment of a syntax tree, which must be spliced into the module's syntax tree
08:42:51 <geekosaur> (but can be spliced in in multiple places, if that is appropriate for what you are doing)
08:43:30 <derdon> you say that as if I knew what I am doing :D
08:43:57 <geekosaur> study compilers a bit. this is less haskell specific than compiler design foo
08:44:05 <geekosaur> abstract syntax trees and such
08:44:12 <navaati> derdon: were are you from ?
08:44:27 <derdon> ah. will have to dig my dragon book sometime again
08:44:32 <derdon> navaati: Bremen, Germany
08:45:05 <bizarrefish> I'm playing with the unm-hip image processing library, and I've hit an issue: http://lpaste.net/97566 This is just me trying to load an image in ghci and display it. I've used "display" constructor before with a filter I generated, and when working properly, it pops open imagemagick's "display" with the image in it.
08:45:29 <geekosaur> the tricky thing with template haskell is you can;t simply generate haskell source code, you must generate internal syntax trees
08:45:32 <navaati> derdon: or you can think of template haskell as "inserting source code" :p
08:45:49 <bizarrefish> Would I be correct in saying this problem is not my fault?
08:46:07 <notdan_> hi
08:46:31 <derdon> geekosaur: this sounds cleaner to me and not tricky. isn't it one step less anyway?
08:46:51 <geekosaur> it saves a step or two and is potentially more type safe
08:47:02 <derdon> navaati: one semester costs me 261,10 EUR :)
08:47:07 <geekosaur> but it does mean you need to know more about how the compiler's syntax trees work
08:47:20 <derdon> (inlcuding a ticket for tram and bus)
08:47:41 <derdon> geekosaur: in general or specifically how the GHC works?
08:47:45 <navaati> derdon: same price for one year. what's your point ?
08:47:57 <geekosaur> specifically ghc
08:48:01 <derdon> navaati: damn. wanted to mock because it's quite cheap
08:48:12 <derdon> geekosaur: alright
08:48:14 <geekosaur> there are lots of details in how you can build syntax trees; you need to know something about ghc's specifics
08:48:42 <geekosaur> which means TH is inherently compiler specific (and in fact currently only exists for ghc, not jhc/ajhc, uhc, etc.)
08:49:06 <navaati> hehe. we don't have the transports though, but there are usually "state student housing" near colleges
08:49:06 <mangaba_leitosa> derdon: I spent $0 yearly :-)
08:49:15 <derdon> :O
08:49:23 <derdon> mangaba_leitosa: where is that possible?
08:49:28 <mangaba_leitosa> derdon: in russia
08:49:35 <derdon> nice
08:49:59 <navaati> in russia, college studies you (hem sorry)
08:50:07 <mangaba_leitosa> but now, every year there are less and less free places available
08:50:09 * derdon cringes
08:50:10 <ciaranm> i get paid!
08:50:27 <navaati> ciaranm: in third semester ?
08:50:34 <ciaranm> navaati: for a PhD
08:50:52 <navaati> oh, yeah. sure
08:52:09 <Feuerbach> geekosaur: do you by any chance know anything about this FSEventStreamEventFlags bug http://stackoverflow.com/q/18415285/110081?
08:53:13 <geekosaur> no, sorry
08:53:24 <geekosaur> haven't done anything with fsevents on os x
08:53:54 <Feuerbach> yeah, seems as if no-one has ever used or tested that API
08:53:56 <sm> geekosaur: interesting about TH thanks. Would straight haskell be a better choice if someone was designing a haskell macro language today ?
08:54:21 <Feuerbach> sm: what do you mean? it is straight haskell
08:54:34 <sm> I mean, generating surface-level haskell rather than syntax treess
08:54:35 <Feuerbach> it's the AST that is compiler-specific
08:54:40 <Feuerbach> ah
08:54:42 <geekosaur> I don't think so? this gets into the ongoing discussion about "hygienic macro systems"
08:54:46 <sm> since the programmer is thinking  at that level already
08:55:15 <sm> and it would be (more) compiler agnostic
08:55:35 <Feuerbach> how about shell's/perl's eval? how many people love it?
08:55:38 <geekosaur> more compiler agnostic, quite possibly harder to do some things
08:56:14 <geekosaur> and I try very hard to avoid eval in both shell and perl because they can be quite complex to use properly (especially when user-provided input is involved)
08:56:32 <Feuerbach> yep, they're a nightmare
08:57:22 <sm> SPJ expressed envy of racket's macro system in some recent panel discussion
08:57:26 * geekosaur looks at SO question again, wonders if by some chance those flags are not single bits
08:59:03 <Feuerbach> they are: https://developer.apple.com/library/Mac/DOCUMENTATION/Darwin/Reference/FSEvents_Ref/Reference/reference.html
08:59:13 <Feuerbach> (there's a table near the end of that page)
08:59:16 <geekosaur> mm, yes, they are bits (just grepped in CoreFramework)
08:59:47 <geekosaur> was hoping they'd turn out to be disjoint enums or something where a naive comparison would not work right / masking is needed
09:04:11 <rose_> Why does this simple function work in GHCI, but not when compiled with GHC? http://lpaste.net/97567
09:05:19 <Feuerbach> because you supplied the wrong type
09:05:23 <shachaf> rose_: For the reason GHC says -- the type doesn't match.
09:05:27 <Feuerbach> ask ghci for the correct one
09:13:01 <magnap> The type is String -> [[String]]
09:17:04 <monochrom> rose_: in general, please don't use ghci as a standard. it behaves different deliberately "for convenience".
09:17:16 <rose_> thanks
09:17:31 <monochrom> so, if something "works" in ghci but not elsewhere, ghci is wrong.
09:18:13 <monochrom> to a large extent, I would even just say "in general, please don't use ghci", except that it would be really inconvenient
09:19:11 <Feuerbach> yeah, you'd be asking too much. Besides, in that case it wasn't wrong at all.
09:19:17 <monochrom> the exact criterion for correct use of ghci: read the ghc user's guide to see what's different, then you know how to use it correctly.
09:19:56 <monochrom> people don't read docs enough
09:20:33 <Feuerbach> too often things work without reading the docs. That must be the source of the problem.
09:21:22 <dv-> how come the standard IO functions aren't MonadIO m => ...?
09:21:51 <Feuerbach> some of them can't be, like bracket
09:22:13 <Feuerbach> also, they probably predate the MonadIO class
09:22:15 <Taneb> Also for functions in base that would create a circular dependency
09:22:28 <Feuerbach> well, MonadIO could be easily moved into base
09:22:42 <Taneb> True
09:22:55 <Taneb> But I don't think there are too many people calling for that :)
09:23:25 <monochrom> pervasive MonadIO is premature generalization
09:26:02 <enigmuri_> https://github.com/plsql/Haskell-Snippets/blob/master/conway.hs    any comments?
09:27:50 <FreeFull> enigmuri_: numRowsStr:(numColsStr:(numItersStr:(prob:[])))   You should get rid of all those parentheses
09:27:57 <enigmuri_> thanks
09:28:04 <enigmuri_> weird that hlint didn't catch that
09:28:16 <FreeFull> : has the right associativity that you don't need them
09:28:41 <enigmuri_> is right associativity the right associativity? :P
09:28:44 <enigmuri_> i suppose so
09:28:57 <FreeFull> I mean as in the correct associativity
09:29:07 <enigmuri_> i know, i was just punning on that
09:29:32 <FreeFull> concat . (map getPStr)   You can get rid of the parentheses here too, since function application associates tighter than operators
09:29:57 <FreeFull> concat . map f    is also the same as   concatMap f
09:30:30 <enigmuri_> thanks
09:30:42 * hackagebot statistics 0.10.5.2 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.10.5.2 (AlexeyKhudyakov)
09:30:45 * hackagebot tasty 0.7 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.7 (RomanCheplyaka)
09:31:29 <dv-> :t map read `fmap` (?getArgs :: IO [String])
09:31:30 <lambdabot> (Read b, ?getArgs::IO [String]) => IO [b]
09:31:53 <FreeFull> enigmuri_: The way applyRules is formatted is a bit confusing
09:33:09 <FreeFull> enigmuri_: I'd bind the listArray bit to a name for better readability
09:33:54 <dv-> you can also update Arrays with // instead of making a new one
09:34:19 <enigmuri_> i used IArray
09:34:22 <enigmuri_> (immutable)
09:34:45 <enigmuri_> the idea of a mutable array seemed a little too imperative for me :P
09:35:00 <enigmuri_> Conway's GOL is an interesting example of weaknesses in purely functional languages
09:35:08 <dv-> :t (//)
09:35:09 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
09:35:26 <FreeFull> "update", // actually returns a new array
09:35:42 * hackagebot tasty-golden 2.2.0.2 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.2.0.2 (RomanCheplyaka)
09:35:46 <FreeFull> :t (Data.Array.IArray.//)
09:35:47 <lambdabot> (Ix i, Data.Array.Base.IArray a e) => a i e -> [(i, e)] -> a i e
09:35:59 <FreeFull> See, there is one for IArray
09:36:06 <enigmuri_> ah thanks
09:36:11 <enigmuri_> i mean, i need to make a new array anyway though
09:36:28 <enigmuri_> because the reference one can't be altered in a piecemeal manner (that's how the GOL works)
09:38:38 <FreeFull> Fast implementations actually skip areas that won't change
09:40:00 <FreeFull> You know that any change will happen somewhere near where there was previously change
09:40:10 <FreeFull> So big blank areas can be pretty much completely skipped
09:40:17 <FreeFull> It doesn't really matter for a simple implementation though
09:41:08 <navaati> FreeFull: how do you do this ? by maintaining a list of what changed ?
09:42:39 <FreeFull> navaati: You'd probably keep track of it in bigger chunks
09:42:59 <k_bx> Hi everyone! Do you use ".cabal-sandbox/bin/" binary or "dist/dist-sandbox-$ID/" one after build?
09:43:12 <k_bx> (after cabal install)
09:43:22 <FreeFull> That sort of thing gets handled automatically if you implement something like hashlife though
09:45:23 <k_bx> I also asked in mailing list, but just thought it's a "quick to answer question" http://www.haskell.org/pipermail/libraries/2013-December/021869.html
09:50:00 <scottj> is there a haskell IMAP library that supports IDLE?
10:01:50 <mm_freak_> the haskellwiki stylesheet could use a few improvements
10:03:42 <joelteon> Is there a way to figure out what existential type variables resolve to in ghci
10:05:38 <m1dnight> Could anyone help me out? I'm almost certain that there is a function that takes [Maybe a] and returns Maybe [a] and Nothing if once of the elements is Nothing
10:05:53 <notdan> :t sequence
10:05:54 <lambdabot> Monad m => [m a] -> m [a]
10:06:07 <notdan> > sequence [Just 1, Just 2]
10:06:08 <lambdabot>  Just [1,2]
10:06:12 <notdan> > sequence [Just 1, Nothing]
10:06:13 <lambdabot>  Nothing
10:06:32 <m1dnight> YES!
10:06:36 <m1dnight> me dumb dumb :p
10:06:36 <m1dnight> thanks guys!
10:10:43 <ParahSailin> @hoogle [Maybe a] -> Maybe [a]
10:10:44 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:10:45 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
10:10:45 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
10:12:10 <cschneid> is prelude's sequence a reexport of the one in Control.Monad - or otherwise equivalent?
10:13:23 <dv-> yes
10:16:28 <pranz> @src sequence
10:16:28 <lambdabot> sequence []     = return []
10:16:28 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:16:28 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
10:26:13 <glaebhoerl> (always opportunistically coming here when a question pops into my head...)
10:26:57 <glaebhoerl> is there any use case for exporting some constructors of a datatype and not others? i.e. has anyone done it for reasons or seen it done?
10:27:31 <augur> hmm
10:28:07 <augur> sequence is very much a fold.   foldr (liftM2 (:)) (return [])   iinm
10:28:32 <augur> which means it should be possible to define sequence for all polynomial functors
10:29:28 <augur> is sequence an instance of a commutation law? i dont know if the relevant commutation laws hold
10:31:33 <danharaj> :t sequence
10:31:33 <lambdabot> Monad m => [m a] -> m [a]
10:32:32 <FreeFull> :t T.sequence
10:32:33 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
10:32:42 <danharaj> :t sequence . fmap sequence
10:32:42 <lambdabot> Monad m => [[m a]] -> m [[a]]
10:33:59 <danharaj> :t fmap sequence . sequence
10:34:00 <lambdabot> (Monad m, Monad f, Functor f) => [f (m a)] -> f (m [a])
10:34:19 <danharaj> :t join . fmap sequence . sequence
10:34:19 <lambdabot> (Monad m, Functor m) => [m (m a)] -> m [a]
10:34:37 <danharaj> :t sequence . fmap join
10:34:38 <lambdabot> Monad m => [m (m a)] -> m [a]
10:34:52 <danharaj> augur: If sequence is a distributive law those ought to be equal.
10:35:07 <augur> which ones name?
10:35:12 <augur> the last two?
10:35:14 <danharaj> yeah
10:35:21 <augur> sure
10:35:27 <danharaj> join . fmap sequence. sequence == sequence . fmap join
10:35:33 <augur> but do that, is the question :)
10:35:44 <augur> in general, for F-algebras
10:35:57 <augur> well, F-algebras that are monads
10:36:40 <danharaj> probably
10:36:43 <augur> i really wish haskell had an automatic fold generation facility
10:36:55 <augur> you could do it now properly now given associated types
10:36:57 <BMeph> glaebhoerl: it's more usual to export "smart constructor/destructor" functions instead; I don't think there's a way to specify access to some, but not all, of a type's constructors.
10:38:20 <glaebhoerl> BMeph: sure there is:
10:38:22 <glaebhoerl> module Foo (Foo(Bar, Baz)) where
10:38:24 <glaebhoerl> data Foo = Bar | Baz | Quux
10:38:44 <augur> class FAlgebra a where { type f :: * -> * ; fold :: (f b -> b) -> a -> b }
10:38:47 <augur> or something like that
10:38:47 <glaebhoerl> I just don't see why you would ever want to do that :)
10:39:29 <cschneid> glaebhoerl: data WebString = Unsafe String | Safe String.  export only unsafe, and a function that lets you go Unsafe -> Safe w/ whatever encoding.
10:40:05 <cschneid> glaebhoerl: but otherwise you can blindly fmap over WebString with normal string functions, and it would work for both kinds? (does this example really work? is there a better way?)
10:40:21 <glaebhoerl> hm
10:41:09 <shachaf> cschneid: Surely newtype SafeString = SafeString String would be a better way. :-)
10:41:16 <glaebhoerl> cschneid: I think the question boils down to whether there's any utility to allowing clients to do _only partial_ pattern matches
10:41:27 <glaebhoerl> (because for constructing, a 'smart constructor' function works just as well)
10:41:31 <glaebhoerl> or rather hm
10:41:43 <shachaf> For what it's worth I can't think of a use case, which is why I said nothing.
10:42:17 <glaebhoerl> not necessarily partial because they can still do `foo (Unsafe s) = blah; foo _ = blahblah;`
10:42:18 <shachaf> Only allowing some matches doesn't sound so great to me.
10:42:26 <glaebhoerl> they just can't explicitly check for `Safe`
10:42:33 <shachaf> You can't be exhaustive without a catch-all pattern.
10:42:37 <glaebhoerl> right
10:42:48 <shachaf> You can *check* for Safe, you just can't extract the String.
10:43:12 <shachaf> It seems to me that the only thing you really care about in this case is constructing, though.
10:44:07 <glaebhoerl> shachaf: hmm? do you mean actually check for it somehow, or just deduce, by looking at the implementation, that if it's not `Unsafe` it couldn't be anything else?
10:44:28 <shachaf> Oh, I just meant the latter.
10:44:34 <shachaf> Of course that's not sufficient if there are more unexported constructors.
10:44:46 <glaebhoerl> and/or if you don't know what they are :)
10:44:53 <shachaf> Sure.
10:45:18 <shachaf> I guess there's no API stability guaranteed about unexported constructors.
10:45:22 <cschneid> (sorry for trying and failing. Was trying to see a useful thing for partial exports.)
10:46:21 <glaebhoerl> cschneid: it was helpful, thanks :)
10:47:35 <glaebhoerl> shachaf: anyway, the reason for my wondering is that there's this idea for Rust to remove `priv` as a thing and everything not explicitly `pub` would be private, and one casualty of that is that enum variants would always have the same visibility as the enum, and you couldn't change them individually
10:47:41 <glaebhoerl> and I was wondering whether that's actually a loss
10:47:49 <glaebhoerl> but it doesn't seem like it is
10:58:20 <benzrf> using sequence on Reader is basically an inverted version of map, right?
10:58:48 <augur> hmm
10:59:24 <augur> sequenceReader :: [a -> b] -> a -> [b]
10:59:42 <benzrf> map :: (a -> b) -> [a] -> [b]
10:59:56 <augur> sequenceReader fs x = map ($x) fs
10:59:56 <augur> probably
11:00:06 <benzrf> ^what i meant
11:00:12 <edwardk> yes
11:00:30 <benzrf> i think i finally grok ((->) r) monad instances
11:00:31 <benzrf> :D
11:00:43 <augur> benzrf: oh?
11:00:52 <augur> you should write an evaluator for hutton's razor
11:00:58 <benzrf> what's hutton's razor?
11:00:58 <augur> i think it makes it pretty clear what it's doing
11:01:10 <augur> hutton's razor is a beautiful little toy EDSL
11:01:38 <benzrf> i also think I might just slightly get mt's
11:01:40 <benzrf> a little bit
11:01:41 <benzrf> :I
11:01:45 <augur> where you have an Expr data type like, say,   data Expr = Lit Int | Add Expr Expr | Mul Expr Expr
11:01:50 <augur> and you define an evaluator for it
11:01:53 <augur> eval :: Expr -> Int
11:01:55 <augur> or whatever
11:01:58 <numberten> d
11:02:22 <benzrf> augur: and?
11:02:24 <augur> and you do successful versions of Expr, with richer structure, eg. add lets, division, etc.
11:02:39 <benzrf> well i did make a shitty tiny lisp a while back
11:02:44 <augur> benzrf: well, the various little points of variation let you implement with different monads
11:03:04 <augur> for instance, adding division is a motivation for using the Maybe monad, because division isnt total: no division by zero
11:03:12 <benzrf> but i didnt know MT's yet, so I ended up doing messy crap instead of using StateT w/ my Either
11:03:22 <augur> adding let is a motivation for Reader
11:03:53 <augur> the main point tho is implementing it using monadic stuff, rather than by hand plumbing
11:04:23 <augur> its a nice way to get the feel of monads, i think
11:04:38 <augur> get a sense of what they're really doing
11:04:42 <benzrf> hold on a sec, i thought MTs were usually implemented with newtype around any monad around transformer monad?
11:05:08 <augur> reader is, of course, just the implicit environment monad. thats how you really want to think about it
11:05:43 <mmmm> what is your point ben
11:06:13 <mmmm> I would second that writing evaluators is a good way to get a feel for monads and transformers
11:06:14 <benzrf> well, it seems the opposite is true for Reader
11:06:16 <benzrf> T
11:07:19 <mkulkin> Hi, everybody. Can you  please recommend a Haskell library for parsing URLs like "scheme://user:password@host:port/path". I've found Network.URI but it's output need a lot of polishing before being able to use it
11:07:19 <augur> i dont like monad transformers, they're too confusing :(
11:07:28 <benzrf> augur: rly?
11:07:38 <benzrf> they are just nested monads
11:07:38 <mmmm> I don't think they're too confusing once you understand monads
11:08:33 <augur> benzrf: a) every time i try to use a monad from the libs, its in some transformer wrapper and i can never get it to work properly, b) the behavior of the transformer on other monads is sort of confusing
11:09:02 <benzrf> augur: for a, ignore the wrapper and just use the default type alias thingy
11:09:07 <benzrf> and for b i dont know what u mean
11:09:13 <m1dnight> allParams <- sequence . map getParam $ ["eventDescription", "eventStart", "eventTitle"] # Because getParam is of type 'Maybe ByteString', how come my allParams is of type [Maybe ByteString]? Shouldn't this be Maybe [ByteString] ?
11:09:19 <augur> i mean, it's not uniformly true that if you have two monads, f and t
11:09:39 <augur> why t
11:09:41 <augur> lets say g
11:10:00 <augur> that fT m and gT m   put the f in the same place relative to m
11:10:04 <mgsloan> I'm not too happy about transformers myself, they lead to crappy type errors.  Imho they're mostly nice for allowing you to conveniently construct a new monad via GeneralizedNewtypeDeriving
11:10:06 <augur> sometimes you get fT m a = f (m a)
11:10:10 <augur> sometimes you get gT m a = m (g a)
11:10:18 <benzrf> ok
11:10:23 <benzrf> but that's because monads are funky
11:10:26 <augur> yes, it is
11:10:37 <benzrf> just ignore the impl and use the uniform interface
11:10:39 <benzrf> :)
11:10:39 <augur> im not saying it doesnt make sense at a purely logical level
11:10:47 <augur> just that i dont like them!
11:10:50 <benzrf> ok
11:11:01 <benzrf> well i have yet to actually use them
11:11:06 <benzrf> so feel free to disregard my opinions
11:11:07 <augur> i wish i understood effect handlers better
11:11:28 <augur> they seem quite interesting
11:11:46 <mgsloan> Yeah, they make sense, and they are useful.  I just wish people didn't put emphasis on them as something "core to grokking haskell" as they're uglier than most haskell idioms
11:12:02 <augur> factoring out independent effects into parallel, rather than nested, effectfulness
11:12:08 <m1dnight> :t sequence . map getParam
11:12:10 <lambdabot> Not in scope: `getParam'
11:12:15 <benzrf> mgsloan: u talking about mt's?
11:12:21 <mgsloan> benzrf: Yup!
11:12:23 <benzrf> ok
11:12:49 <mgsloan> I've just met people who were really into haskell till they ran into arrows or MTs
11:12:50 <benzrf> augur: as somebody who believes in the zen of python, i agree with you
11:12:52 <mgsloan> and ditched it at that point
11:14:19 <mgsloan> (becuase they were given the false impression that arrows / MTs are accepted as best practices)
11:15:58 <c_wraith> augur: what do you do when things really aren't parallel?  Take non-determinism and state-passing, for instance.
11:16:20 <augur> c_wraith: well then you have to nest, i think
11:16:40 <ImUrBreda> if I ignore the return value of atomicModifyIORef'
11:16:43 <augur> c_wraith: which is fine. i just like the idea of being forced to nest _only_ when effects really aren't independent
11:16:43 <ImUrBreda> the update never happens
11:16:50 <ImUrBreda> any workaround?
11:17:04 <benzrf> ImUrBreda: why are you using that
11:17:13 <mgsloan> Now, don't get me wrong, a few incidental transformers here and there can be really nice.  What I don't like is transformers being used in APIs
11:17:33 <ImUrBreda> benzrf: ? cause i want to update an ioref atomically?
11:17:47 <c_wraith> ImUrBreda: uh.  what exactly are you saying?  If you don't perform an Io action, it doesn't happen?
11:19:13 <c_wraith> ImUrBreda: because that's the only way I can read your statement that matches experimental results
11:19:14 <ImUrBreda> c_wraith:  _ <- Ref.atomicModifyIORef' instances upd     return $ H.setBody ok H.resp
11:19:21 <ImUrBreda> i want to do something like this
11:19:48 <ImUrBreda> so i want to update the value and return an OK response
11:19:55 <ImUrBreda> it doesnt seem to happen for me
11:19:58 <ImUrBreda> i just get the OK response
11:20:04 <benzrf> why are you using iorefs?
11:20:15 <ImUrBreda> benzrf: mostly cause im a noob
11:20:22 <ImUrBreda> and i know no alternatives
11:20:22 <benzrf> that seems clear
11:20:26 <c_wraith> ImUrBreda: how are you determining that the IORef's contents didn't change?
11:20:41 <ImUrBreda> c_wraith: the update function is buggy
11:20:46 <ImUrBreda> it should raise an error
11:21:15 <benzrf> ImUrBreda: why do you need mutation?
11:21:24 <benzrf> what are you using this for?
11:21:29 <ImUrBreda> benzrf: i keep track of connected servers
11:21:43 <benzrf> couldn't you do that purely?
11:21:50 <c_wraith> ImUrBreda: oh. don't *ever* count on exceptions coming out of pure code where you expect them to in IO
11:21:51 <benzrf> or is that bad performance?
11:22:00 * benzrf doesnt know anything about performance in haskell
11:22:04 <ImUrBreda> benzrf: i dont think so
11:22:33 <c_wraith> benzrf: IORefs are slower - what they give you is asynchronous ability to see that the value has changed
11:22:43 <ImUrBreda> c_wraith: what you are saying is REALLY interesting
11:23:14 <Enigmagic> ImUrBreda: what is the type of upd
11:23:25 <c_wraith> > do { _ <- return undefined ; [1, 2, 3] }
11:23:26 <lambdabot>  [1,2,3]
11:23:41 <ImUrBreda> Enigmagic:   upd :: Instances -> (Instances, ())
11:25:16 <Enigmagic> ImUrBreda: in any case you don't need the `_ <-` since it should be returning IO ()
11:25:43 <ImUrBreda> Enigmagic: my monad is IO SomeOtherType
11:25:55 <ImUrBreda> thats why i did that
11:26:06 <ImUrBreda> (back to haskell from a long break btw)
11:26:49 <ImUrBreda> tried it i indeed dont need it
11:28:00 <c_wraith> ImUrBreda: I can't reproduce what you're saying.
11:30:03 <Enigmagic> ImUrBreda: it's only needed when the type isn't a `Monad m => m ()` ... and even then ghc will issue a warning, not an error.
11:30:17 <c_wraith> ImUrBreda: the execution of atomifModifyIORef' results in an error message with all four of the following functions, in my test: undefined, \_ -> undefined, \_ -> (undefined, ()), and \_ -> (0, undefined0
11:30:42 <c_wraith> ImUrBreda: and all of those are with _ <- ...
11:30:51 <c_wraith> (I was using an IORef Integer)
11:31:17 <monochrom> "x <- y" with x unused is no stricter than "_ <- y"
11:31:20 <ImUrBreda> let me doublecheck if i do the update at all
11:31:49 <ImUrBreda> hahh, i think i use Data.Map.adjust and my key is not existing
11:31:59 <ImUrBreda> so thats why update doesnt run if that is clear xd
11:32:08 <ImUrBreda> sorry for wasting your time guys
11:32:15 <festcrane> Is there a way to look up operators? I'm wondering where (.:) is defined.
11:32:46 <geekosaur> http://holumbus.fh-wedel.de/hayoo/hayoo.html
11:32:58 <c_wraith> monochrom: hmm.  I suppose ghci doesn't evaluate the () if it's executing something with the type IO ()
11:33:25 <festcrane> Thanks geekosaur, that's perfect
11:34:24 <monochrom> that depends on what exactly you enter at the ghci prompt. recall that your command may cause ghci to add a printing phase that evaluates what need not be evaluated.
11:34:46 <c_wraith> Yeah, that's cute.
11:35:12 <monochrom> time to wave around my "please don't use ghci" wand again :)
11:35:14 <c_wraith> return $ trace "hello" () --  doesn't output anything.
11:35:34 <c_wraith> return $ trace "hello" "there" -- outputs insane stuff!
11:35:50 * hackagebot tasty-ant-xml 1.0.0.5 - Render tasty output to XML for Jenkins  http://hackage.haskell.org/package/tasty-ant-xml-1.0.0.5 (OliverCharles)
11:36:11 <c_wraith> and by "insane", I actually mean "it makes sense, it's just really ugly"
11:36:20 <monochrom> hrm, interesting
11:37:09 <benzrf> whats wrong with ghci
11:37:15 <c_wraith> This is just because ghci breaks all the rules, inspecting the type of the expression before it determines what it's going to do with it.
11:37:21 <benzrf> > trace 3
11:37:21 <lambdabot>  Not in scope: `trace'
11:37:34 <benzrf> what does trace do
11:37:42 <c_wraith> it's from Debug.Trace
11:37:47 <benzrf> oh
11:37:56 <c_wraith> It causes a string to be output when the expression is evaluated
11:38:14 <monochrom> ghci adds many special cases and exceptions for convenience. that's what's wrong with it.
11:38:39 <monochrom> it is the same road to PHP
11:39:09 <c_wraith> There are...  3 different cases for IO expressions?  IO (), Show a => IO a, and IO a?
11:39:37 <c_wraith> My test relied on the difference between the first and second cases.
11:39:46 <mada> can parsec's parser combinations be grouped and "opted" together?
11:40:26 <mada> say I have a field with two possible values. For the first one, it's followed by a path, and then a message. For the second value, it's just a message
11:41:16 <mada> I think I might need to use choice, but grouping "field path message" or "field message", depending on the value
11:41:51 <monochrom> message <|> (path >> message)
11:42:16 <monochrom> choice is, of course, <|> on steroid
11:42:25 <mada> monochrom: thank you
11:50:52 <lightquake> how do you pronounce <-, bind?
11:55:17 <pavonia> lightquake: http://www.haskell.org/haskellwiki/Pronunciation
11:55:57 <lightquake> 'from' makes sense
12:07:13 <docsis> Hello
12:07:57 <docsis> Hello everyone
12:08:57 <Jeanne-Kamikaze> sup
12:09:42 <shiona> hi docsis
12:10:27 <navaati> hey
12:10:37 <navaati> :t choice
12:10:37 <lambdabot>     Not in scope: `choice'
12:10:38 <lambdabot>     Perhaps you meant `choose' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
12:10:45 <navaati> meh
12:10:53 * hackagebot happstack-heist 7.2.1 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-7.2.1 (JeremyShaw)
12:11:13 <L8D> :t choose
12:11:14 <lambdabot> Random a => (a, a) -> Gen a
12:11:17 <navaati> :i Tagged
12:11:32 <L8D> :i Ord
12:11:34 <navaati> lambdabot, no :i ?
12:11:41 <L8D> @src choose
12:11:41 <lambdabot> Source not found. :(
12:12:05 <twirlobite> can one integrate hlint with an editor like notepad++?
12:12:06 <navaati> hem, how do i :i with lambdabot ?
12:12:26 <quchen> navaati: Lambdabot doesn't have :i
12:12:49 <navaati> twirlobite: probably not with notepad++, but with a more advanced ide, sure. doesn't eclipse FP do it ?
12:12:56 <navaati> quchen: sad
12:13:06 <navaati> lambdabot, you deceive me
12:13:18 <quchen> Lambdabot isn't GHCi.
12:14:16 <twirlobite> navaati: eclipse fp is too heavyweight for me :/
12:14:25 <twirlobite> navaati: i want something minimal
12:14:57 <docsis> shiona: hi
12:15:07 <navaati> twirlobite: well there is emacs but it isn't necessarily "minimal"
12:15:25 <navaati> not sure if it has a hlint minor mode or something
12:15:46 <navaati> why does Tagged have three parameter instead of the two expected ?
12:16:35 <rose_> Why do I get this error when I use the OverloadedStrings syntax extension? http://lpaste.net/97575
12:16:35 <shachaf> One of them is a kind parameter.
12:16:43 <shachaf> rose_: What is the type of (++)?
12:16:47 <navaati> shachaf: should't this appear somewhere ?
12:17:05 <shachaf> What where?
12:17:20 <navaati> shachaf: that it's a kind parameter
12:17:39 <navaati> shachaf: oh. in ghci :i output i mean
12:17:40 <shachaf> Do you have PolyKinds turned on?
12:17:43 <navaati> yep
12:18:18 <shachaf> Then you have to know. I don't know.
12:18:32 <shachaf> For more fun, try defining "data Foo k a = Foo" and :i Foo
12:18:34 <monochrom> is there any plan to generalize Oh Christmas Tree to Oh Season's Data.Traversable? :)
12:18:55 <rose_> shachaf: It's (++) :: [a] -> [a] -> [a], and because "?\n   " is [Char], so it treats question and answer as [Char], but I thought the overloaded Strings would convert Text to String
12:19:22 <shachaf> rose_: OverloadedStrings certainly doesn't do that.
12:19:34 <monochrom> "Oh Season's Data.Traversable, how you're subject to lens" :)
12:20:03 <navaati> rose_: overloaded strings converts strings to text, not the other way around
12:20:04 <shachaf> It turns string literals -- like "abc" -- into other things -- in particular, fromString "abc"
12:20:27 <rose_> thanks
12:20:27 <shachaf> navaati: Only string *literals*. It does nothing at all for strings in general.
12:20:45 <Enigmagic> shachaf: i think that is fixed for 7.8 .. https://gist.github.com/NathanHowell/fec601e281e81e1d1922
12:20:54 <shachaf> rose_: You could use mappend
12:20:59 <navaati> shachaf: that was a gross simplification : the parameter of fromString is indeed a string
12:21:02 <shachaf> (Data.Monoid.<>) :: Text -> Text -> Text
12:21:24 <shachaf> Enigmagic: I wouldn't call that "fixed", but it's an improvement.
12:21:38 <shachaf> Enigmagic: It would be nice if the different kind variables had different names.
12:21:56 <navaati> type role ? wtf is this ?
12:22:43 <Enigmagic> shachaf: yeah well at least you can tell what is a kind variable now ;)
12:22:56 <navaati> so in this gist k and a are type variables, and k and k (the other ones) are kind variables ?
12:23:07 <Enigmagic> navaati: http://typesandkinds.wordpress.com/2013/08/15/roles-a-new-feature-of-ghc/
12:23:22 <monochrom> navaati, the truth "fromString :: String -> ..." does not contradict the truth "OverloadedString works on string lits only"
12:23:54 <navaati> Enigmagic: \o/
12:24:03 <Enigmagic> navaati: k is a kind variable, which is the kind of types a and k
12:24:08 <navaati> monochrom: indeed
12:24:34 <navaati> Enigmagic: does that mean that a and k must be of the same kind ?
12:24:36 <monochrom> for non-lits, you always have to add fromString by hand
12:24:58 <shachaf> It doesn't.
12:24:58 <lightquake> since we're also getting OverloadedLists, can we get OverloadedMaps next? :D
12:25:01 <shachaf> One day GHC will learn about letters other than k.
12:25:26 <pavonia> twirlobite: I've never used it myself, but you might want to look into the NppExec plugin
12:26:08 <monochrom> I am waiting for OverloadedJuxtaposition. juxtaposition means for example "x y z". currently it is syntax for function application only.
12:27:07 <pavonia> What else would you use it for?
12:27:07 <Enigmagic> navaati: you know what... i actually thought it did but never have checked. shachaf is right.
12:27:18 <dwcook> Applying Applicatives maybe
12:27:59 <navaati> monochrom: is it a joke or a real idea ? it sounds neat but maybe there is a trick making it stupid...
12:28:00 <monochrom> "x y z" could be syntax for x <$> y <*> z. "m k" could be syntax for m `Data.Map.lookup` k.
12:28:31 <Cale> shachaf: kkkkk k kkkk kkkkkkk kk kkkkkk. k kkkk kk kkkkkkkkk kkkk kkkkk!
12:28:32 <Enigmagic> navaati: if you specify the kind variable then it does work as intended
12:28:33 <twirlobite> pavonia: thanks pavonia, i'll give it a look
12:28:57 <monochrom> for now, I consider it an April 1st plan. but there is no decision procedure to decide whether an idea is a joke vs real.
12:29:26 <monochrom> those who have learned from history know that there is no difference between joke and real.
12:29:27 <Cale> monochrom: Yeah, that's one of those ideas which is both very good and very bad all at the same time
12:29:51 <Enigmagic> navaati: e.g. https://gist.github.com/NathanHowell/217757043f23378cc83e
12:30:06 <navaati> Cale: well.... that's what LANGUAGE pragme is for, eh :D ?
12:30:12 <dwcook> I once asked why that syntax wasn't overloaded and someone responded something along the lines of it would be hard to keep track whether you're doing real function application or <*> or whatnot
12:30:43 <navaati> Enigmagic: ah, ineresting
12:30:48 <mada> Is there any usual way of importing Parsec's <|> without clashing with Control.Applicative one?
12:31:01 <Cale> navaati: *Kind* of. We do have to be cautious still about the direction the language takes I think, even with LANGUAGE pragmas.
12:31:06 <dwcook> mada, import qualified
12:31:44 <shachaf> mada: What, Applicative's (<|>) isn't compatible?
12:31:46 <dwcook> import qualified Text.Parsec as P
12:31:54 <mada> dwcook: oh, ok. I hoped for a way to rename the function or something like that, so I didn't have to qualify all uses of parsec's functions
12:32:00 <shachaf> Well, Alternative's. Control.Applicative's. You know.
12:32:13 <dwcook> mada, you can import some things qualified and some not
12:32:20 <lightquake> mada: import Text.Parsec hiding ((<|>)) ?
12:32:22 <shachaf> mada: You can import Parsec multiple times, once hiding (<|>) and once qualified.
12:32:25 <dwcook> import qualified Text.Parsec ((<|>)) as P
12:32:32 <dwcook> I thik
12:32:33 <FreeFull> dwcook: Well, there are proponents for idiom brackets
12:32:34 <dwcook> think*
12:32:36 <mada> that's it
12:32:37 <mada> thank you both
12:32:39 <lightquake> shachaf: they're the same operation, it's weird
12:32:56 <dwcook> FreeFull, what's that mean?
12:32:56 <mada> lightquake: so I can just hide parsec's <|> and use Applicative's
12:33:03 <lightquake> mada: yes, it looks like
12:33:04 <shachaf> lightquake: That's what I expected.
12:33:10 <shachaf> So just do that.
12:33:15 <FreeFull> As in, something like  (| x y z |) gets translated into x <$> y <*> z
12:33:17 <lightquake> i wonder why they did that.
12:33:31 <shachaf> Well, Parsec predates Control.Applicative.
12:33:37 <dwcook> FreeFull, so the purpose would be to make it obvious it's not plain old function application?
12:33:56 <haasn> the purpose would probably be to distinguish it from x y z
12:33:58 <FreeFull> mada: I think parsec is where <|> originally came from
12:34:05 <lightquake> and the author didn't want to get rid of <|> for compatibility?
12:34:07 <haasn> (which could be equally valid)
12:34:18 <FreeFull> dwcook: Well,  it really just makes it look nicer
12:34:23 <mada> FreeFull: I just found that out on SO (that parsec predates applicatives)
12:34:41 <mada> historical reasons I guess
12:34:46 <FreeFull> It does work with applicatives and alternatives
12:34:53 <FreeFull> I like using applicative style
12:35:04 <monochrom> Parsec's older <|> has a different operator precedence from Applicative's <|>. changing precedences breaks a lot of other people's existing code
12:35:17 <quchen> I think the problem with Parsec's <|> is that it has a different fixity, so you cannot replace it with Alternative's version everywhere
12:35:28 <dwcook> Though it's unclear to me what rule would translate (| x y z |) into x <$> y <*> z, mostly the (<$>)
12:36:03 <shachaf> The rule defining (| |)
12:36:08 <monochrom> but you could add a clause to PVP to say "major version jump allows changing precedences"
12:37:06 <dwcook> shachaf, of course, but that rule hasn't been defined in this conversation
12:37:09 <monochrom> it can be very simple. the first one is always <$>. the rest are always <*>s. it is that simple.
12:37:19 <dwcook> Hmm. I guess.
12:37:25 <dwcook> But then you couldn't use it for, say, Map.
12:37:28 <FreeFull> Idris has idiom brackets
12:37:43 <shachaf> monochrom: Is it that simple?
12:37:44 <monochrom> that is right. wait for OverloadedJuxtaposition for the full generality :)
12:37:58 <dwcook> :)
12:38:03 <dwcook> Can't wait.
12:38:09 <shachaf> What is (| f (g x) (h y) |)?
12:38:11 <shachaf> What happens with operators?
12:38:34 <shachaf> What happens with let, do, list comprehensions, ...?
12:38:48 <monochrom> I don't know how to do it yet. but with the depravity of type classes and type families and what not, what can possibly go wrong?
12:39:01 <lightquake> monochrom: yeah, i mean you have to allow changing precedence *somewhere* and major jumps are as high as you can go
12:39:51 <joneshf-laptop> shachaf, what's wrong with (| f (g x) (h y) |) === f <$> (g x) <*> (h y)
12:39:53 <joneshf-laptop> ?
12:40:13 <joneshf-laptop> or are you suggesting it could be seen also as...
12:40:16 <shachaf> joneshf-laptop: Nothing.
12:40:26 <shachaf> joneshf-laptop: What happens with (| (f (g x)) (h y) |)?
12:40:43 <joneshf-laptop> f <$> (g <$> x) <*> (h <$>)
12:40:45 <joneshf-laptop> ?
12:40:52 <benmachine> hmm
12:40:54 <joneshf-laptop> there's a y in there somewhere
12:40:57 <shachaf> Many things could be seen as many things.
12:41:17 <shachaf> I don't know what the right rule for idiom brackets is, if there is one, but it requires some thinking.
12:41:20 <benmachine> shachaf: so, there's at least two implementation of idiom brackets
12:41:25 <benmachine> *s
12:41:34 <shachaf> Do they agree on every expression?
12:41:49 <benmachine> I have no idea
12:42:16 <benmachine> but your tone seems to suggest that implementing it would require lots of headscratching
12:42:27 <benmachine> I'm just saying, maybe it's actually not that much?
12:42:36 <joneshf-laptop> well, if we let it be only in the top level, you canstill do normal haskell within them right?
12:42:40 <joneshf-laptop> erm
12:42:42 <joneshf-laptop> normal application
12:43:20 <joneshf-laptop> but if you force all application to be applicative then how do you get normal function application?
12:43:22 <shachaf> It might not be that much.
12:43:30 <joneshf-laptop> also, was this covered in the paper?
12:53:40 <ReinH> Unapplicative bananas? |) f a b (| ;)
12:54:00 <ReinH> I will call them unbanana brackets
12:54:05 <ccxvxcv> Is it possible to use TypeRep to tell fromDynamic what to output?
12:55:16 <ccxvxcv> I could use TH or do it inside the IO monad.
12:55:25 <ccxvxcv> If it's possible.
12:55:36 <ccxvxcv> Let me show an example...
12:56:08 <joneshf-laptop> hmm, https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/idiom.html
12:57:04 <ifesdjeen> does anyone know how to extract state from ST monad?
12:57:26 <shachaf> ifesdjeen: That question doesn't quite make sense. Have you seen the FAQ entry on this?
12:57:29 <shachaf> @where faq
12:57:29 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
12:58:03 <monochrom> cannot extract state from ST. cannot.
12:58:10 <ifesdjeen> thanks
12:58:23 <ifesdjeen> yesterday someone told me here that it is possible :)
12:58:28 <ifesdjeen> therefore my question)
12:58:51 <shachaf> I recommend trusting monochrom.
12:58:52 <ifesdjeen> so basically there's no difference between using ST monad and IO monad then
12:58:59 <ifesdjeen> i trust him
12:59:03 <ccxvxcv> Say, I have the following: data Foo = Foo | Oof; data Bar = Bar; l = [toDyn Foo, toDyn Bar]. Can I somehow get Foo and Bar back?  I'm OK with TH, IO, or Strings.  Ideas?
12:59:06 <shachaf> There's an important difference.
12:59:23 <ifesdjeen> if the difference is in threading, i don't really need it :)
12:59:48 <monochrom> ST is less capable than IO.
13:00:08 <ifesdjeen> right
13:00:13 <monochrom> for that lesser capability, you buy runST
13:00:34 <ccxvxcv> Obviously, I don't want to explicitly define all possible cases.
13:00:56 * hackagebot fay-jquery 0.6 - jQuery bindings for Fay.  http://hackage.haskell.org/package/fay-jquery-0.6 (AdamBergmark)
13:01:04 <ifesdjeen> ok, probably that brings me to an original question: how can I test some piece of code that involves IO monad?...
13:01:06 <shachaf> I,I ST is more capable than IO. for that greater capability, you lose input and output
13:01:26 <monochrom> heh, that is a valid view too
13:01:29 <ifesdjeen> interesting )
13:01:32 <ccxvxcv> ifesdjeen: What do you mean by "test"?
13:01:45 <ifesdjeen> ccxvxcv: to write a unit-test
13:01:47 <ifesdjeen> hspec
13:01:49 <ifesdjeen> maybe
13:01:52 <ifesdjeen> doesnt' matter really
13:02:22 <monochrom> yes, it depends on what observations you make during testing.
13:03:02 <ifesdjeen> i just need to make an exact match
13:03:13 <monochrom> example 1: you only observe stdin and stdout. so just use a shell and redirection
13:03:33 <ifesdjeen> not really, i just have a hashtable within st monad
13:03:36 <monochrom> example 2: you observe filesystem changes. well that's very much harder. set up some chroot jail, maybe.
13:03:56 <ifesdjeen> ah, no, everything is much easier
13:04:03 <ifesdjeen> i just define something in a hashtable
13:04:08 <ifesdjeen> then read it from there
13:04:38 <Geraldus> Hello friends! Can anybody help to beat Mavericks? http://stackoverflow.com/questions/20785260/cant-install-fay-on-mac-os-x-mavericks/20787144?noredirect=1#comment31162237_20787144
13:04:40 <navaati> ifesdjeen: maybe you should use a State monad...
13:05:13 <ifesdjeen> navaati: i'm using hashtables package, they offer only io and st monads :)
13:06:14 <navaati> ifesdjeen: ah. i thought that by hashtables you meant good old Data.Map
13:06:31 <ifesdjeen> navaati: i wish, probably will end up rewriting to use Data.Map
13:09:48 <ifesdjeen> oh, now I'm really confused with it all :)
13:10:34 <navaati> could i do some trickery so that "(m :: M NoMissiles a) >> (n :: M NoMissiles b)" is of type "MyMonad NoMissiles b", but "(m :: M Missiles a) >> (m :: M NoMissiles b)" is of type "M Missiles b" ?
13:10:42 <navaati> if you see what i mean ?
13:10:49 <ifesdjeen> oh...
13:10:53 <ifesdjeen> let me read it once again
13:11:15 <ifesdjeen> i don't know tbh
13:14:39 <ifesdjeen> monochrom: look, here it kind of says it's possible to extract value from ST monad, or? http://www.haskell.org/haskellwiki/Monad/ST
13:14:48 <navaati> so basically i have "M :: Bool -> * -> *" and i want that >>= has the type "M b1 t1 -> (t1 -> M b2 t2) -> M (b1 || b2) t2" and i realize that it wont work and i'm sad
13:14:50 <ifesdjeen> monochrom: namely by readSTRef
13:14:58 <navaati> but maybe there's a trick ? anyone ?
13:16:38 <shachaf> There is indeed a trick of sorts.
13:17:07 <lispy> navaati: are you trying to work with indexed monads?
13:17:29 <lispy> If so, you won't be able to reuse the existing Monad class in general.
13:17:42 <shachaf> launchMissiles :: M Missiles ()
13:17:51 <monochrom> extract value yes
13:17:54 <lispy> You may well find this useful: http://hackage.haskell.org/package/category-extras-0.53.5/docs/Control-Monad-Indexed.html
13:18:04 <shachaf> walkTheDog :: M b ()
13:18:34 <shachaf> Now (walkTheDog >> walkTheDog) :: M b (); (launchMissiles >> walkTheDog) :: M Missiles ()
13:19:07 <navaati> lispy: oh, "indexed monads", that's how it's called ? cute
13:19:28 <lispy> navaati: Well, yours are slightly different, but yes
13:19:32 <shachaf> Indexed monads is not the same thing.
13:19:34 <navaati> thanks for the pointer
13:19:40 <lispy> ireturn :: a -> m i i a
13:19:49 <lispy> They use two type indices
13:20:35 <ifesdjeen> hey guys, sorry to bother you, i'm just completely lost here.. I'm trying to use an ST monad with RealWorld, but runST doens't seem to play with it...
13:20:43 <ifesdjeen> i'm getting "Couldn't match type `s' with `RealWorld'" somehow
13:20:52 <shachaf> You aren't supposed to use RealWorld.
13:21:48 <ifesdjeen> shachaf: is there any function that does similar thing to runST that works with RealWorld?..
13:21:54 <c_wraith> RealWorld is available for hacks that want to treat ST and IO the same.
13:22:03 <shachaf> Mostly only a secret one.
13:22:15 <ifesdjeen> secret one?..
13:22:27 <navaati> sigh... when even rmonads aren't enough. does that mean i've become a grown up ?
13:22:31 <shachaf> As a rule you should understand ST and IO quite well -- including GHC's implementation -- before you use anything like that.
13:22:33 <lispy> ifesdjeen: could you tell us a bit more about what you're trying to do?
13:22:39 <shachaf> navaati: I gave you a solution above.
13:23:45 <ifesdjeen> lispy: i'm trying to write a little lisp interpreter in haskell
13:23:54 <ifesdjeen> already got most of things running
13:23:58 <ifesdjeen> like closures and so on
13:24:05 <navaati> shachaf: ah, i thouht it was an application of IndexedMonads ! yepee, i'm not a grown up !
13:24:11 <navaati> thanks
13:24:42 <shachaf> My answers are so simple that they are ignored.
13:25:04 <navaati> eheh sorry :3
13:25:31 <lispy> ifesdjeen: neat. And what do you use runST for?
13:25:46 <navaati> so i define instance Monad (M a) and that's good right ?
13:25:49 <BlairA> quit
13:26:17 <ifesdjeen> lispy: long story.. i first have asked wether it's possible to test some code that involves IO monad (which I'm using for hashtable lookups)
13:26:35 <ifesdjeen> lispy: someone told me i shouldn't use IO and should use ST instead
13:26:59 <ifesdjeen> lispy: i used ST, but ran into the problem that most of ST stuff doesn't work with RealWorld binding
13:27:22 <eskatrem> whois peaker
13:27:37 <navaati> ifesdjeen: what's the problem with testing ? make composable functions in the ST monad, run them, see if the result is as expected, and then so what ?
13:27:39 <simpson> ifesdjeen: Could you pastebin some of your code to lpaste, perhaps?
13:27:44 <lispy> ifesdjeen: Hmm...how did RealWorld come up?
13:27:53 <lispy> ifesdjeen: are you using stToIO?
13:27:56 <ifesdjeen> lispy: no
13:28:22 <ifesdjeen> lispy: i'm trying to define a type with an ST monad, like: type Environment k v = H.BasicHashTable RealWorld k v
13:28:43 <ifesdjeen> otherwise I'd have to pass `s` (which is a ST binding) everywhere
13:28:49 <ifesdjeen> at least how I understood it
13:28:59 <lispy> ?hoogle BasicHashTable
13:29:00 <lambdabot> No results found
13:29:04 <navaati> ifesdjeen: you definitely need to use State with a Map.
13:29:05 <lispy> What is BasicHashTable?
13:29:28 <ifesdjeen> lispy: https://github.com/gregorycollins/hashtables/blob/master/src/Data/HashTable/IO.hs that one
13:29:38 <ifesdjeen> navaati: i'll try that one
13:30:02 <glasserc> Hi, this is my first time using Cabal and I'm getting an error when trying to install the current version of unix-time on Ubuntu x86_64. Output is http://lpaste.net/97576 . Am I doing something obviously wrong?
13:30:09 <lispy> ifesdjeen: if you use RealWorld there you're effectively using IO.
13:30:21 <ifesdjeen> i see
13:30:54 <navaati> :t stToIo
13:30:55 <lambdabot>     Not in scope: `stToIo'
13:30:55 <lambdabot>     Perhaps you meant `stToIO' (imported from Control.Monad.ST.Safe)
13:30:59 * hackagebot fast-logger 2.1.0 - A fast logging system  http://hackage.haskell.org/package/fast-logger-2.1.0 (KazuYamamoto)
13:30:59 <navaati> :t stToIO
13:31:00 <lambdabot> ST RealWorld a -> IO a
13:31:01 * hackagebot wai-logger 2.1.0 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-2.1.0 (KazuYamamoto)
13:31:02 <lispy> Actually, in that link I followed it still doesn't make sense
13:31:08 <navaati> eww
13:31:17 <lispy> I see type BasicHashTable k v = IOHashTable (B.HashTable) k v
13:31:21 <ifesdjeen> right
13:31:28 <ifesdjeen> that's how i ended up with IO
13:31:42 <lispy> that's differenth than: type Environment k v = H.BasicHashTable RealWorld k v
13:31:53 <aristid> ifesdjeen: i thought you wanted to try Data.Map?
13:32:08 <ifesdjeen> aristid: didn't get there just yet
13:32:56 <lispy> newtype HashTable s k v = HT (STRef s (HashTable_ s k v))
13:33:01 <benbangert> I'm constructing a list-like structure, and my access is usually by index to pull words out, however I also need to fairly frequently determine if a word is in the list, and if it isn't, append it. What's the best structure to use for that?
13:33:02 <lispy> That seems like a more likely definition
13:33:08 <allsystemsarego> mystery_function ((+10),(+11)) [20..22] => [(30,31),(31,32),(32,33)] -- what is that mystery function?
13:33:09 <supki_> glasserc: looks like you don't have  configure  in PATH (or installed)
13:34:10 <lispy> ifesdjeen: If I were you, I would use Data.Map + state monad for now and make a note to revisit rank-2 types and ST monad.
13:34:22 <ifesdjeen> lispy: ok, rewriting it all to Data.Map :)
13:34:29 <ifesdjeen> thanks aristid lispy navaati
13:34:36 <ifesdjeen> started a rewrite
13:34:55 <lispy> Okay, just make sure to revisit :) ST is powerful and good to know.
13:35:17 <lispy> The rank-2 trick it uses is nice when used sparringly
13:36:05 <simpson> So, what do people think of http://research.microsoft.com/apps/mobile/showpage.aspx?page=/en-us/projects/fstar/ ?
13:36:26 <ciaranm> nothing good has ever come out of microsoft research
13:36:39 <simpson> I am highly skeptical of the statement about verifying F* in F*, but otherwise it looks like an interesting bit of R&D-powered language research.
13:36:39 <lispy> simpson: first time seeing it, so no opinion yet :)
13:36:44 <hpc> ciaranm: except for quite a bucket of ghc extensions ;)
13:37:02 <lispy> ciaranm: lots of interesting work comes out of MSR, actually.
13:37:13 <hpc> F# wasn't so bad either once you get past the typechecking-left-to-right thing
13:37:18 <glasserc> supki_: oh, thanks. Shouldn't it be using the configure script from inside the package?
13:37:56 <ciaranm> the last thing i saw coming out of microsoft research refused to wear shoes whilst giving a talk
13:38:24 <lispy> simpson: forturately on that claim you can read the POPL paper and see if they're full of it :)
13:38:46 <simpson> lispy: Well, Tarski's Undefinability tells me that, on some level, they must be full of it.
13:39:20 <simpson> But on the other hand, it looks like their toolchain can't prove *all* propositions, so maybe they just mean that they've verified large swaths of it and not the entire formal system.
13:39:31 <simpson> *prove/disprove, that is.
13:39:56 <lispy> simpson: http://www.cl.cam.ac.uk/~jrh13/papers/holhol.html
13:40:10 <lispy> verification is always relative to something
13:40:19 <lispy> and abstracts are typically vague about what :(
13:41:34 <simpson> lispy: Ah, what a gem of a paper; it *does* directly address my concerns.
13:41:56 <lispy> That John Harrison...
14:04:48 <navaati> @hoogle itraverse
14:04:48 <lambdabot> No results found
14:04:51 <navaati> :t traverse
14:04:52 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
14:04:58 <navaati> :t traversed
14:04:59 <lambdabot> (Applicative f1, Traversable f, Indexable Int p) => p a (f1 b) -> f a -> f1 (f b)
14:06:48 <bitemyapp> This seems to work: scotty 3000 $ (middleware logStdoutDev) >> (middleware $ staticPolicy (addBase "./test")) >> wordRoute
14:06:52 <bitemyapp> but I thought >> "threw away" the result and moved onto the next, how does it know to execute the middleware?
14:06:56 <bitemyapp> I don't think I understand Scotty's ActionT/ScottyT/ScottyM
14:07:22 <hpc> bitemyapp: (>>) is not const
14:07:39 <hpc> (x >> y) = "do x, then do y" (for a very metaphorical definition of "then")
14:07:55 <hpc> in the case of IO, it's fairly basic
14:08:10 <hpc> and then there's stuff like Maybe, which is a more illuminating example
14:08:16 <bitemyapp> hpc: okay, but does that mean the middleware function is mutating some kind of global state so that the app runner will execute the middleware?
14:08:18 <hpc> > (Just 5) >> (Just 7)
14:08:19 <lambdabot>  Just 7
14:08:25 <hpc> > Nothing >> (Just 7)
14:08:26 <lambdabot>  Nothing
14:08:43 <bitemyapp> the return type of middleware is Network.Wai.Middleware -> ScottyM ()
14:09:08 <hpc> i don't think it will be global state, but some kind of local state that is syntactically hidden by ScotyM
14:09:19 <hpc> so yeah, middleware is manipulating state behind the scenes
14:09:37 <hpc> surely you can't encode all the information it produces in just the type ()
14:09:37 <bitemyapp> that's the part I'm struggling with is how.
14:09:41 <bitemyapp> I know that, but I don't understand how it's doing what it's doing.
14:10:11 <bitemyapp> newtype ScottyT e m a = ScottyT { runS :: StateT (ScottyState e m) m a }
14:10:39 <hpc> ah, that's easy
14:10:55 <bitemyapp> well for somebody that knows what they're doing :)
14:11:00 <hpc> let's pretend for a bit that (ScottyState e m) is "s"
14:11:05 <hpc> bitemyapp: well, easy to explain
14:11:07 <bitemyapp> okay.
14:11:10 <hpc> less easy to understand ;)
14:11:40 * bitemyapp listens
14:11:41 <hpc> newtype FakeScottyT s m a = ScottyT { runS :: StateT s m a}
14:12:04 <hpc> and we unwrap the newtype and FakeScottyT = StateT
14:12:07 <navaati> ping edwardk
14:12:18 <edwardk> pong
14:12:22 <hpc> so, the way StateT does it is... /me hoogles
14:13:09 <navaati> on the Operator page of the lens wiki, there is a deadlink : the %@= operator points to IndexedSetters page, which does not exist
14:13:22 <edwardk> its a wiki. you can just fix it =)
14:13:49 <hpc> bitemyapp: can't find it quickly, will just have to re-derive it
14:14:02 <navaati> eh. actually, yes x). i don't know where to find this operator though
14:14:18 <hpc> newtype StateT s m a = StateT {runStateT :: s -> m (s, a)}
14:15:51 <hpc> (>>) (StateT f) g = StateT {runStateT s = let (s, a) = (f s) in g s} -- ommitting some wrapping and unwrapping because it's really boring
14:16:03 * hackagebot purescript 0.2.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.1 (PhilFreeman)
14:16:36 <hpc> bitemyapp: but basically, in (>>) for StateT you have two values to keep track of; the state s and a return value a
14:16:41 <hpc> s gets passed on and a is ignored
14:17:31 <hpc> second example which i can actually keep in my head all at once, is Maybe
14:17:39 <hpc> (>>) Nothing _ = Nothing
14:17:46 <hpc> (>>) (Just x) y = y
14:18:01 <hpc> so (x >> y) = "if x is nothing, nothing, else y"
14:18:04 <bitemyapp> I understand how >> and Maybe work.
14:18:13 <hpc> and the hidden state being passed around is "we don't have anything"
14:18:16 <bitemyapp> I don't understand how the state is getting changed or scoped. That's the part that confuses me.
14:18:33 <hpc> it's not being changed
14:18:43 <hpc> you can think of an action with state as a function which takes the state
14:18:48 <hpc> and returns both a value and a new state
14:19:38 <hpc> so get = \s -> (s, s)
14:19:51 <hpc> put s = \s1 -> (s, ())
14:19:59 <hpc> incrementOne s = (s + 1, ())
14:20:06 <hpc> incrementOne :: State Int ()
14:20:31 <hpc> then (>>) and (>>=) hide the parameter passing
14:21:15 <hpc> incrementTwo = \s -> let (s1, _) = incrementOne s; (s2, _) = incrementOne s2 in (s2, ())
14:21:18 <hpc> ick
14:21:28 <hpc> incrementTwo = incrementOne >> incrementOne
14:21:57 <hpc> is it making a bit more sense now?
14:22:30 <bitemyapp> I have a coarse grained and inaccurate conception of it, but I at least get the whole, "hiding the fact that we're actually chaining a tuple, for which we're ignoring the right hand side return value"
14:22:38 <bitemyapp> left hand being our "state"
14:22:51 <hpc> yep
14:22:53 <bitemyapp> but until I grapple with it in some direct way, I don't think it'll stick.
14:23:00 <bitemyapp> good enough for now.
14:23:03 <bitemyapp> hpc: thank you very much.
14:23:14 <hpc> try it with StateT a bit; you can pattern match on it and manipulate the function itself
14:23:19 <hpc> ghci <3
14:24:01 <bitemyapp> hpc: I'm a lisper - I live or die by GHCi :)
14:24:04 <hpc> ghci will also help you get used to the lots of extra StateT and runStateT which gets hidden away as well
14:24:26 <hpc> and why when you search hoogle for (>>=) definitions they always look like ass
14:25:53 <bitemyapp> hpc: hahaha, that makes a lot of sense.
14:27:16 <bitemyapp> hpc: I found the type the StateT is parameterized against, starting to grok how this works now. :)
14:27:25 <hpc> :)
14:27:39 <navaati> edwardk: modif done but there are still deadlinks for iover and such that i didn't find
14:27:59 <edwardk> iover is in Setter now i think
14:28:01 <bitemyapp> ScottyState is a record of {middlewares :: [Wai.Middleware], routes :: [Middleware m], handler :: ErrorHandler e m}
14:28:27 <benbangert> is there a cabal sandbox version of runghc?
14:28:37 <edwardk> navaati: http://hackage.haskell.org/package/lens-3.10.1/docs/doc-index-All.html may help
14:29:11 <bitemyapp> benbangert: I think there's a standard environment variable for this
14:29:25 <bitemyapp> benbangert: I usually use Makefiles or put a script I can source to set the package location environment variable.
14:29:40 <benbangert> bitemyapp: ah, don't suppose you have an example of that?
14:29:42 <bitemyapp> benbangert: HTH: GHC_PACKAGE_PATH=./.cabal-sandbox/x86_64-linux-ghc-7.6.3-packages.conf.d: ghci -XOverloadedStrings
14:29:50 <bitemyapp> benbangert: most certainly do, that's from my "make shell"
14:30:02 <bitemyapp> that's how I tell ghci to use my damn sandbox :)
14:30:09 <bitemyapp> maybe it will work for runghc/runhaskell?
14:31:04 * hackagebot purescript 0.2.1.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.1.1 (PhilFreeman)
14:31:40 <benbangert> bitemyapp: hmmm, getting a     Failed to load interface for `Prelude` error
14:32:42 <bitemyapp> in this function: addMiddleware m s@(ScottyState {middlewares = ms}) = s { middlewares = m:ms }
14:32:51 <bitemyapp> wtf is s@(...) doing?
14:33:03 <bitemyapp> {-# LANGUAGE GeneralizedNewtypeDeriving, FlexibleInstances, MultiParamTypeClasses #-}
14:33:05 <L8D> How can I make unions in haskells?
14:33:11 <exicer> Is there a module for safe list operations, or do I need to make my own ?
14:33:14 <bitemyapp> L8D: you mean algebraic data types?
14:33:20 <navaati> bitemyapp: it's giving a name for something you pattern match on
14:33:34 <bitemyapp> exicer: just pattern match.
14:33:46 <bitemyapp> exicer: head is perfectly safe. just don't be silly.
14:33:50 <navaati> exicer: there is
14:33:57 <L8D> bitemyapp: I mean like, C-like unions
14:33:57 <navaati> it's called safe i think
14:34:16 <L8D> Where there are different types in one type
14:34:22 <monochrom> bitemyapp: s@(ScottyState {middlewares = ms}) means ScottyState {middlewares = ms} plus also using the name s to refer to the whole thing
14:34:47 <bitemyapp> monochrom: oh, so it's like destructuring in Clojure. cool.
14:34:57 <navaati> L8D: in haskell there's only things like tagged unions, they're called sum type and you do them with | and different constructor names
14:35:07 <monochrom> another example: t@(x:xs) against [1,3,2]. now x refers to 1, xs refers to [2,3], and t refers to [1,3,2]
14:35:24 <L8D> navaati: Can you give me an example?
14:35:27 <monochrom> I don't know clojure. I cannot compare.
14:35:32 <bitemyapp> monochrom: very cool, thank you.
14:35:56 <bitemyapp> monochrom: Clojure has a generalized destructuring thing to it. it's what they use instead of pattern matching.
14:36:02 <monochrom> yikes, s/[2,3]/[3,2]
14:36:14 <bitemyapp> I understood.
14:36:22 <navaati> L8D: "data MySumType = HereIsAChar Char | HereIsANumber Int"
14:36:36 <navaati> MySumType can contain a Char or an Int
14:36:50 <L8D> navaati: Oh okay
14:36:56 <bitemyapp> L8D: just use algebraic data types.
14:37:03 <L8D> I thought that was how it worked
14:37:11 <navaati> depending on which constructor you use (the two constructors of this type are HereIsAChar and HereIsANumber)
14:37:18 <L8D> Can you nest them inside structs?
14:37:33 <L8D> And other type definitions
14:37:52 * L8D assumes you can
14:37:56 <navaati> L8D: what you call structs are product types, like "data MyProduct = MyProd Int Char" and no you can't
14:38:14 <navaati> you can nest products into sums, though
14:38:30 <L8D> Then what are: data Person = Person { name :: String, age :: Int }
14:38:48 <navaati> and you can nest sums into products defining thet separately and using their name of course
14:38:59 <FreeFull> Enums are sum types
14:39:30 <Clint> L8D: that's record syntax
14:39:37 <navaati> L8D: it's a Product type, equivalent to "data Person = Person String Int" with a pair of functions name and age to access its fields
14:39:47 <navaati> (and a bit more stuff)
14:39:55 <L8D> interesting
14:40:29 <L8D> So then...Records, products, and tuples can store the same data
14:40:38 <navaati> L8D: exactly
14:41:26 <navaati> what does change is the intent for us humans, but for the compiler and the computer scientist they are all products
14:42:34 <fl00r> haha...computer scientist /= human?
14:45:14 <navaati> fl00r: eh, did i say that :p ?
14:45:15 <fl00r> nah
14:45:28 <navaati> doh... why does "execState (zoom traversed (_2 %@= (\i a -> i))) (zip ['a'..] [1..3])" gives me "[('a',1),('b',1),('c',1)]" ?
14:45:46 <navaati> why is the index always 1 ?
14:46:27 <fl00r> ghci
14:46:35 <fl00r> oops
14:47:51 <fread2282> > zip ['a'..] [1..3]
14:47:52 <lambdabot>  [('a',1),('b',2),('c',3)]
14:48:04 <fread2282> > execState (zoom traversed (_2 %@= (\i a -> i))) (zip ['a'..] [1..3])
14:48:06 <lambdabot>  [('a',1),('b',1),('c',1)]
14:48:59 <fread2282> :t execState
14:48:59 <lambdabot> State s a -> s -> s
14:49:04 <navaati> > execState (zoom traversed (_2 %@= (+))) (zip ['a'..] [10..13])
14:49:05 <lambdabot>  [('a',11),('b',12),('c',13),('d',14)]
14:49:25 <fread2282> @hoogle execState
14:49:25 <lambdabot> Control.Monad.Trans.State.Lazy execState :: State s a -> s -> s
14:49:26 <lambdabot> Control.Monad.Trans.State.Strict execState :: State s a -> s -> s
14:49:26 <lambdabot> Control.Monad.State.Lazy execState :: State s a -> s -> s
14:49:35 <navaati> > execState (zoom traversed (_2 %@= (+))) (zip ['a'..] (repeat 10 5))
14:49:37 <lambdabot>  Couldn't match expected type `a1 -> [GHC.Types.Int]'
14:49:37 <lambdabot>              with actual type `[a0]'
14:49:41 <navaati> :t repeat
14:49:42 <lambdabot> a -> [a]
14:50:38 <fread2282> > execState (zoom traversed (_2 %@= (+))) (zip ['a'..] (take 5 (repeat 10)))
14:50:39 <lambdabot>  [('a',11),('b',11),('c',11),('d',11),('e',11)]
14:51:00 <navaati> > execState (zoom traversed (_2 %@= (+))) (zip ['a'..] (replicate 10 5))
14:51:01 <lambdabot>  [('a',6),('b',6),('c',6),('d',6),('e',6),('f',6),('g',6),('h',6),('i',6),('j...
14:51:23 <navaati> > execState (zoom traversed (_2 %@= (+))) (zip ['a'..] (replicate 5 10))
14:51:24 <lambdabot>  [('a',11),('b',11),('c',11),('d',11),('e',11)]
14:51:32 <fread2282> > execState (zoom traversed (_2 %@= (\i a -> a))) (zip ['a'..] [1..3])
14:51:37 <lambdabot>  [('a',1),('b',2),('c',3)]
14:51:43 <navaati> anyway, i still doesn't know what the heck is with this
14:51:55 <Cale> What are we attempting to do here?
14:52:08 <chakibouhajjou> Hi
14:52:12 <navaati> fread2282: i was giving bad example but you can /msg lambdabot
14:52:13 <Cale> chakibouhajjou: hello
14:52:33 <chakibouhajjou> I am a programmer and I am learning haskell
14:52:34 <fread2282> navaati: yeah
14:52:46 <navaati> Cale: i'd expect the index to be 1 then 2 then 3... like, y'know, an index. but it's always 1
14:52:48 <Cale> chakibouhajjou: Feel free to ask any questions you might have here :)
14:53:21 <fread2282> > execState (zoom traversed (_2 %@= (\i a -> (i,a)))) (zip ['a'..] [1..3])
14:53:22 <lambdabot>  Occurs check: cannot construct the infinite type:
14:53:22 <lambdabot>    b0 = (GHC.Types.Int, b0)
14:53:56 <Cale> Excuse me while I look up which thing %@= is
14:54:11 <aaronlevin> Anyone wnt to field a simple haskellmode-vim question? I can't get the type commands to work (e.g., `_t`). `:GHCi` works, and others do, but not the type ones. Any ideas or tips for debugging?
14:54:42 <shachaf> %@= is indexed %= , presumably.
14:54:43 <navaati> Cale: doesn't the index propagate from traversed trough _2 ? or maybe i absolutely don't understand this index and lens thing
14:54:44 <donri> aaronlevin: did you do :compiler ghc and :make?
14:54:44 <donri> i suggest you try ghcmod-vim instead though
14:56:00 <chakibouhajjou> What is the simplest explanation of Monads ?
14:56:16 <shachaf> chakibouhajjou: The FAQ has some good links.
14:56:23 <shachaf> Have you seen it?
14:56:24 <shachaf> @where faq
14:56:24 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
14:56:39 <aaronlevin> donri: yes, tried that and still didn't work. I don't get an error. Just a no-op. (I'm testing it on a vanilla file that just does `main do putStrLn "test"`
14:56:45 <Cale> chakibouhajjou: How far along are you in understanding Haskell generally? Do you know how type classes work?
14:57:04 <chakibouhajjou> Cale Not yet
14:57:11 <chakibouhajjou> Cale: Not yet
14:57:31 <Cale> Okay, so you'll almost certainly want to look into what type classes are about before you understand the Monad type class.
14:57:41 <shachaf> chakibouhajjou: Then the short answer (other than "read the FAQ", which you should do anyway) is "don't worry about monads, learn Haskell first".
14:57:42 <aaronlevin> donri: I'll try ghcmod.
14:58:06 <chakibouhajjou> tx
14:58:32 <fread2282> chakibouhajjou: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
14:58:40 <hpc> chakibouhajjou: learnyouahaskell goes through the concepts in the right order, and is quite approachable
14:59:11 <shachaf> fread2282: That article is full of wrong and misleading things. :-(
14:59:13 <Cale> Once you know a bit about type classes, I might recommend this little article of mine: http://www.haskell.org/haskellwiki/Monads_as_computation
14:59:32 <fread2282> shachaf: like what?
15:00:44 <shachaf> Like the idea of "wrapped values" and "unwrapping", for instance.
15:01:06 * hackagebot purescript 0.2.1.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.1.2 (PhilFreeman)
15:01:14 <Cale> Isn't the index of _2 always 1?
15:01:27 <Cale> > iover _2 (\i a -> i) ("Hello", "there")
15:01:28 <lambdabot>  ("Hello",1)
15:01:39 <navaati> Cale: ah ! shouldn't the index of the list propagate ?
15:01:41 <shachaf> Yes, I think so.
15:01:53 <shachaf> I think it's getting unindexed in the next version?
15:01:55 <navaati> what if i want the index in the list ?
15:02:31 <navaati> s#in#in/of#
15:02:40 <Cale> I think it would be more idiomatic to zip the list with [0..]
15:03:03 <Cale> Rather than trying to come up with some fancy indexed traversal to make that happen
15:03:30 <Cale> (I'm sure there's a way to make it happen, but why?)
15:04:02 <navaati> Cale: ah, but actually i'd like to use zoom in a (StateT [a]) with a (StateT a) computation and still have access to the index
15:04:07 <navaati> isn't it possible ?
15:04:35 <fread2282> shachaf: but isn't that correct for Functors?
15:05:16 <navaati> fread2282: no, not necessarily. besides, monads are functors
15:05:36 <shachaf> fread2282: It's hard to call something like that "correct" or "incorrect".
15:05:46 <shachaf> I would say that it's a very bad analogy and also misleading.
15:06:13 <navaati> errrr, i can't remember the typical "functor for which the notion of wrap doesn't apply" example...
15:06:21 <Cale> navaati: IO?
15:06:39 <navaati> Cale: ah, not bad ^^
15:07:40 <xxx-man> Cale: hi
15:07:43 <Cale> hi
15:08:45 <Cale> > execState (modify (iover traversed (\i x -> i+x))) [10,20,30] -- navaati
15:08:46 <lambdabot>  [10,21,32]
15:09:36 <Cale> hmm
15:09:36 <fread2282> Cale: it makes sense for me
15:09:37 <shachaf> :t execState . modify
15:09:37 <lambdabot> (s -> s) -> s -> s
15:09:39 <fread2282> you have to think of the "box" of being more than just a box
15:09:41 <stepkut> I want to create a map from Int to values -- but my Int's are going to be sequential starting from 0 -- should I use IntMap or Seq? I am going to be doing almost entirely lookups
15:09:53 <Cale> shachaf: indeed :)
15:10:13 <Cale> fread2282: Yeah, it can work
15:10:29 <Cale> (I did write Monads as Containers after all)
15:10:30 <shachaf> @quote kmc container
15:10:30 <lambdabot> kmc says: [After discussing monads, containers, and tortillas] therefore the key difference between a container and a monad is delicious carne asada
15:10:32 <shachaf> Not that.
15:10:39 <shachaf> @quote kmc "container"
15:10:41 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
15:10:42 <navaati> Cale: crap... I was trying "execState (traverse %@= (\i (a,b) -> (a,b+i))) (zip ['a'..'c'] (repeat 10) :: [(Char,Int)])" without success
15:10:44 <navaati> and without understanding what was wrong
15:10:44 <navaati> :t modify
15:10:46 <lambdabot> MonadState s m => (s -> s) -> m ()
15:10:52 <fread2282> you have to stretch things a bit, but that is the best explanation of monads I've seen
15:10:52 <Cale> fread2282: But it's kind of a difficult and somewhat unhelpful analogy to really understand that case properly
15:10:58 <Ralith> stepkut: you might even consider using an array
15:11:08 <stepkut> Ralith: oh yeah!
15:11:08 <Cale> fread2282: http://www.haskell.org/haskellwiki/Monads_as_computation is what I usually lead off with these days
15:11:36 <shachaf> Almost all people who use that analogy also turn out to say wrong things about the thing they're analogizing.
15:11:39 <xxx-man> Cale: could u please for a second see pm
15:12:11 <hpc> fread2282: if you have to stretch, it's not the best ;)
15:12:24 * stepkut totally forgot about IArray
15:12:46 <shachaf> stepkut: You don't need efficient updates?
15:12:57 <stepkut> shachaf: I don't need any updates
15:13:21 <dhrosa> is it more accurate to say a Monad lets you define what it means to chain computations?
15:13:35 <stepkut> shachaf: really.. anything would work, because I will likely have < 4 elements total :)
15:14:33 <navaati> dhrosa: you mean a monoid in the category of endofunctors ? (ok, ok, i shut up, hem, sorry)
15:14:34 <shachaf> stepkut: Inserts, whatever.
15:14:47 <shachaf> stepkut: But in that case it doesn't matter. I would say to use the least fancy thing you can think of.
15:14:50 <dhrosa> also why does that adit.io site remind me so much of Learn You a Haskell..
15:15:03 <stepkut> shachaf: I am adding support to clckwrks for multiple page styles per theme -- so I need some way to select which page style you want to use -- but all the variants are know at compile time -- since someone has to actually create the different page layouts
15:16:28 <stepkut> I could almost use an algebraic data-types and a case statement -- but not really -- since new themes can be loaded at runtime and I don't want to set a predefined list of available styles
15:16:32 <stepkut> at least.. I don't think I do :)
15:21:15 <eskatrem> I am having problems installing the package lens:
15:21:15 <eskatrem> src/System/IO/Error/Lens.hs:93:1:
15:21:15 <eskatrem>     Illegal type variable name: `'
15:21:15 <eskatrem>     When splicing a TH declaration: _AlreadyExists :: forall .
15:21:18 <eskatrem>  
15:21:19 <navaati> stepkut: why not a simple list ?
15:22:05 <shachaf> Isn't that what you get when you have multiple versions of TH installed or something?
15:22:27 <shachaf> I recommend checking things along that general path.
15:22:37 <stepkut> navaati: why not not a simple list?
15:25:18 <joelteon> eskatrem: you reinstalled TH
15:26:06 <eskatrem> shachaf, joelteon : I checked indeed, there are various TH stuff in my .cabal, one for derive, one for template-haskell, and one for lense which I want to install
15:29:53 <dsrx> pl
15:30:03 <dsrx> > pl
15:30:04 <lambdabot>  Not in scope: `pl'
15:30:04 <lambdabot>  Perhaps you meant one of these:
15:30:04 <lambdabot>    `pi' (imported from Prelude),
15:30:04 <lambdabot>    `l' (imported from Debug.SimpleReflect),
15:30:04 <lambdabot>    `p' (imported from Debug.SimpleReflect)
15:30:07 <dsrx> err
15:30:26 <shiona> @pl \x -> x+2 -- ?
15:30:26 <lambdabot> (2 +)
15:30:30 * shachaf mentions that you can /msg lambdabot.
15:30:30 <dsrx> there we go, thank you
15:30:31 <simpson> dsrx: Were you trying to use @pl ?
15:30:58 <glasserc> supki_: turns out there was a .tar.gz file on my PATH. I'm not exactly sure why that caused this failure, but thanks for the help all the same.
15:30:59 <dsrx> shachaf: i was messaging lambdabot but couldn't get it to respond to anything because I couldn't remember the @ prefix
16:15:00 <navaati> hummm. what is the difference between traverse and traversed ?
16:15:09 <haasn> :t traversed
16:15:10 <lambdabot> (Applicative f1, Traversable f, Indexable Int p) => p a (f1 b) -> f a -> f1 (f b)
16:15:15 <haasn> this one is indexed
16:15:27 <haasn> ‘traverse’ is not from lens, so we can't generalize it
16:15:41 <haasn> ‘traversed’, like ‘folded’ and ‘mapped’ are indexed
16:15:45 <haasn> oh, mapped isn't
16:15:47 <haasn> :t mapped
16:15:48 <lambdabot> (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
16:16:54 <navaati> hummmmm. so what is the difference between traversed and itraversed ?
16:17:04 <eikke> would anyone familiar with typelits and sings care to help me out with https://gist.github.com/NicolasT/8140553 (basically, line 21)?
16:17:08 <jakedust> does anyone have any examples of Haskell being used in data analysis?
16:17:21 <jakedust> as in R-like data analysis
16:17:37 <navaati> :t traverse
16:17:37 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:19:06 <tristan_1> jakedust: http://shop.oreilly.com/product/9781782169437.do
16:19:23 <navaati> haasn: you seem to know lens well. do you know how i can get the index when zooming into a list state with traverse ?
16:19:53 <jakedust> tristan_1: while this book seems interesting, do you have any experience with it? I tend to avoid Packt books after some bad experiences
16:20:29 <tristan_1> jakedust: yea, I tend to avoid them too, I don't have experience with this book :(
16:20:52 <tristan_1> most haskell for data analysis I just know about in the sense it is used a lot internally at companies
16:20:59 <tristan_1> but not sure of any resources
16:21:01 <tristan_1> besides this
16:21:01 <haasn> navaati: I'm not sure what exactly you're asking
16:21:52 <dhrosa> let's say I have a list, and I want to perform a bunch of operations on a subset of the list, let's say, flip the middle part around, how would I go about doing that in a nice general way?
16:22:26 <haasn> navaati: you want to zoom from State [a] b  into State a b  and do.. what exactly?
16:22:41 <dhrosa> and then return the modified entire list *
16:22:43 <simpson> dhrosa: There's a nice lensy way to do it, but in general, you'd want to write a helper function that cuts out the middle of the list.
16:23:30 <navaati> haasn: ive got a "doThings :: State [Blah] ()" with "doThings = zoom traversed doThing" and "doThing :: State Blah ()", and i want, in doThing, to access the index of the Blah i'm currently operating on
16:24:09 <jakedust> yeah, I've heard some people saying that it's heavily used internally by some companies, especially investment banks, but I haven't seen any packages in hackage or elsewhere
16:24:32 <dhrosa> import CreditSuisse.SecretInternals
16:24:47 <jakedust> :D
16:25:17 <navaati> haasn: i can't find another way to do this, since stuff like mapState do not allow to modify the type of the state (so i can't zoom in, which is so convenient)
16:25:57 <navaati> dhrosa: maybe look at zippers ?
16:26:10 <haasn> navaati: zoom (traversed.withIndex) lets you have doThing as State (Int, Blah)
16:26:15 <haasn> which is a rough first approximation I guess
16:26:25 <haasn> What you really want is Int -> State Blah ()  ?
16:26:33 <navaati> ah ! i guess this withIndex was the piece i was missing !
16:27:01 <dhrosa> thanks, I'll re-reread lyah's section on zippers
16:27:21 <navaati> haasn: i tried to go with Int -> State Blah () but i couldn't find a way to do it
16:27:28 <navaati> :t withIndex
16:27:28 <lambdabot> (Functor f, Indexable i p) => Overloading p (Indexed i) f s t (i, s) (j, t)
16:27:30 <haasn> edwardk: can ‘zoom’'s profunctor be generalized from -> to indexed p?
16:27:43 <haasn> no, it can't
16:27:50 <haasn> at least not in the way we want it to
16:28:07 <haasn> there's no profunctor in ‘m c’ either way
16:29:45 <navaati> :t traverse.withIndex
16:29:46 <lambdabot>     Couldn't match type `Indexed i0 s0 (f1 t1)' with `a0 -> f0 b0'
16:29:46 <lambdabot>     Expected type: p0 (i0, s0) (f1 (j0, t1)) -> a0 -> f0 b0
16:29:46 <lambdabot>       Actual type: Overloading
16:29:57 <navaati> :t traversed.withIndex
16:29:58 <lambdabot> (Applicative f1, Traversable f, Indexable Int p) => p (Int, a) (f1 (j, b)) -> f a -> f1 (f b)
16:31:41 <haasn> :t \f -> zoom (traversed.withIndex) $ use _1 >>= zoom _2 . f :: Monoid b => (Int -> State a b) -> State [a] b
16:31:42 <lambdabot>     Could not deduce (t ~ (Int -> m1 (State [a1] b1)))
16:31:42 <lambdabot>     from the context (Monoid b)
16:31:42 <lambdabot>       bound by the inferred type of
16:32:51 <Modius> Any users of ghc-mod?  It doesn't appear to show inexhaustive pattern matches. . .
16:35:38 <zRecursive> @wn inexhaustive
16:35:39 <lambdabot> No match for "inexhaustive".
16:36:04 <haasn> :t (\f -> zoom (traversed.withIndex) $ use _1 >>= zoom _2 . f) :: Monoid b => (Int -> State a b) -> State [a] b
16:36:04 <lambdabot> Monoid b => (Int -> State a b) -> State [a] b
16:36:09 <haasn> Oops.
16:36:16 <simpson> zRecursive: It means that, in a case expression or other pattern match, you failed to match all possible patterns.
16:36:17 <haasn> That was an embarrassingly silly type error :)
16:36:23 <haasn> navaati: ^
16:36:38 <benbangert> I asked earlier, but maybe someone else is around now.... I got a structure that stores a list of words. 90% of access is to pull up a word by list index, 10% is to see if a word exists and appends it if it doesn't exist. Best structure for this list? Right now I'm using Data.Sequence
16:37:12 <zRecursive> simpson: maybe WordNet in lambdabot it too old
16:37:41 <quchen> benbangert: For lots of lookups use Data.(Int)Map.
16:38:06 <monochrom> use two structures. an array and a set.
16:38:07 <simpson> zRecursive: It's not a common dictionary word.
16:38:20 <zRecursive> yeah
16:38:47 <benbangert> monochrom: yea, using a Data.Sequence + Map had occured to me as well
16:40:59 <navaati> haasn: whooooo, it works
16:41:41 <navaati> the weird stuff is that the index is sort of part of my state, Int -> State ... would be better, but well
16:41:52 <haasn> navaati: see the second version I suggested :P
16:42:04 <navaati> :t use
16:42:04 <lambdabot> MonadState s m => Getting a s a -> m a
16:42:39 <navaati> haasn: oh yeah, sure
16:42:58 <benbangert> quchen: IntMap doesn't seem to let you determine if the value is present in the map efficiently?
16:43:03 <navaati> (i was in lambdabot fiddling with 'withIndex')
16:43:09 <Modius> Either GHC-mod (can't find it there) or the GHC API is filtering out the "Pattern match(es) are non-exhaustive" warning from getting to me
16:43:11 <navaati> now it's perfect
16:43:25 <Modius> I get the other warnings, just not that One
16:44:11 <Philonous> Why does GHC complain about non-exhaustive (GADT) patterns and suggest patterns that it won't accept because the type of the value that's being matched prohibits them?
16:44:12 <Modius> Can anyone using GHC-mod or have it installed run it directly - > ghc-mod check blah.hs in any file that has an incomplete pattern?
16:44:32 <navaati> oh, and i didn't understoot a single word of the stuff about profunctor, what's the consequence ?
16:47:43 <quchen> benbangert: Well, O(n). You can implement 'find' as a fold, which should have reasonable performance.
16:48:23 <quchen> Not sure how well "find p . elems" does in comparison.
16:49:38 <benbangert> quchen: at least the lookup by index would be O(1)... hmmm
16:49:59 <benbangert> ideally I'll have to use two structures as monochrom mentioned
16:50:32 <quchen> benbangert: O(log(n)), not O(1).
16:50:51 <quchen> Oh wait, for IntMap it's faster, nevermind.
16:50:54 <benbangert> quchen: index by lookup in the Map isn't O(1)?
16:51:01 <benbangert> ah good, was good say....
16:51:02 <nisstyre> IntMap is very fast
16:51:51 <nisstyre> I replaced some code that was using strict arrays with IntMap and it improved performance dramatically :D
16:51:52 <quchen> It's O(number of bits in an Int), I was thinking about Map
16:52:11 <nisstyre> (I assume the person who wrote it had no idea of the complexity of arrays)
16:52:30 <benbangert> nisstyre: the strict intmap I assume?
16:53:18 <nisstyre> benbangert: I didn't know there were two versions, however it shouldn't matter since the entire thing was getting initialized anyway
16:53:23 <nisstyre> so a slow startup cost
16:55:12 <nisstyre> benbangert: this is what I mean http://hackage.haskell.org/package/containers-0.2.0.1/docs/Data-IntMap.html
16:55:35 <nisstyre> the complexity is O(min(n,W)) where W = number of bits in the int
16:55:49 <benbangert> ahh, right
16:55:54 <Ralith> nisstyre: "the complexity of arrays"?
16:56:27 <quchen> W is really log(MAX_INT) because you can only have MAX_INT keys in your map.
16:56:42 <nisstyre> Ralith: specifically Data.Array
16:56:46 <benbangert> Ralith: from what I've read, dealing with arrays is not as pleasant cause it gets tangled up in monads, while some of these other structures play nicer in purely functional contexts
16:57:01 <nisstyre> benbangert: in this case it was immutable arrays
16:57:17 <nisstyre> so, yeah, not great for expensive operations
16:57:26 <quchen> It's not too bad to use Vector etc. But the Map API is hard to beat when it comes to convenience.
16:57:33 <nisstyre> IntMap is a good pure solution to mapping integers to things
16:57:51 <quchen> Unless it's obviously a bad idea or you have some benchmark results, go with Map and friends.
16:57:55 <Ralith> benbangert: that's an unrelated concern
16:58:20 <benbangert> I'll probably have to use two structures eventually, but I'll deal with slower performance for now to ensure I get the fundamental algo working first
16:58:41 <Ralith> nisstyre: I'd expect an array to be much cheaper, assuming your data is dense
16:59:11 <Ralith> nisstyre: or unless you were performing lots of updates, of course
16:59:18 <nisstyre> Ralith: they were using // repeatedly
16:59:24 <nisstyre> Ralith: it was modelling a CPU
16:59:28 <FireFly> quchen: well, number of bits in an int = log MAX_INT ...
16:59:28 <nisstyre> so tons of updates
16:59:37 <benbangert> I have a decent amount of updates to this structure
16:59:40 <Ralith> ah
16:59:44 <Ralith> how large a memory space?
16:59:49 <benbangert> but not nearly as many as lookups
16:59:54 <nisstyre> possibly hundreds of mb
17:00:20 <Ralith> might be worth trying a STUArray if you don't actually need persistence
17:00:25 <nisstyre> so as you imagine it could only run very tiny things before becoming very slow
17:00:39 <nisstyre> Ralith: I'll look into that
17:00:42 <quchen> FireFly: Sure.
17:00:48 <nisstyre> I can benchmark that vs. IntMap
17:01:00 <quchen> (Which is what I said.) :-)
17:01:01 <Ralith> STUArray is the go-to 'mutable algorithm in haskell' solution, imo
17:01:09 <Ralith> destructive, rather
17:01:52 <benbangert> Ralith: yea, I mean, every so often I'll want to serialize the structure back to disk. but I don't serialize it frequently
17:02:04 <Ralith> benbangert: what are you talking about?
17:03:14 <benbangert> a largish list of words that is looked up by index int 90% of the time, and queried by value ~5% and added to about 1-5% of the time by appending
17:03:51 <benbangert> ~14k words in my current list
17:04:33 <benbangert> I'm porting Megahal (from C/Python) to Haskell :)
17:05:20 <Ralith> why not keep a separate word -> key map?
17:06:11 <benbangert> yea, two structures would be best performance-wise
17:06:20 <monochrom> I have a cunning plan! use Haskell FFI to use Python's data structures which are written in C
17:06:29 <quchen> Or you could use a bimap.
17:06:33 <benbangert> I'm still a beginner on haskell though, so keeping a simpler structure helps at the moment
17:06:41 <nisstyre> monochrom: what's the point of that?
17:06:50 <nisstyre> Python has like 3 data structures
17:06:50 <Ralith> nisstyre: maximizes silliness.
17:06:51 <Chousuke> what is a "largish list"? 100k?
17:06:58 <monochrom> they are fast
17:06:58 <Ralith> Chousuke: 17:02:32 < benbangert> ~14k words in my current list
17:07:03 <Chousuke> oh, hm
17:07:08 <Chousuke> that's not very large at all
17:07:22 <benbangert> yea, and that 14k words have been built up over like, 7 years of operation, so the odd's that a word won't be in the list at this point seems slim
17:07:52 <benbangert> so adding a word will be quite rare, its mainly determining if a word is in the list, and 90% of access is by list index
17:08:38 <nisstyre> benbangert: if you don't mind the occasional false positive, bloom filters are fast and space efficient ways of telling if something is in a set
17:09:37 <nisstyre> if it's rare that a word is not in the list then it might be a great choice
17:09:51 <nisstyre> since the fp rate would be lower
17:12:22 <quchen> While you're testing things, also have a look at Bimap.
17:12:28 <quchen> @hackage bimap
17:12:28 <lambdabot> http://hackage.haskell.org/package/bimap
17:12:57 <quchen> It's a thin wrapper around Data.Map that gives you logarithmic complexity in both directions.
17:13:26 <quchen> There's no IntMap analogon though.
17:13:52 <benbangert> quchen: that does look almost exactly like the type of access I want
17:16:19 * hackagebot xss-sanitize 0.3.4.1 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.4.1 (GregWeber)
17:16:34 <schell> anyone have any library recommendations for user authentication?
17:19:23 <bitemyapp> schell: http://www.haskell.org/haskellwiki/Web/Libraries/Sessions_and_Authentication
17:19:50 <schell> bitemyapp: great, thanks
17:20:04 <danharaj> edwardk: http://takeichi.ipl-lab.org/~asada/papers/arrStrMnd.pdf
17:20:11 <danharaj> pretty nice account of profunctor strength
17:22:04 <stolaruk> I recently read about MonadPlus and guard in RWH, and I recall having read about it in LYAH. Having written a bunch of Haskell code by this point, I think I could find a number of places in my code that could be refactored to use "guard" (instead of "if" or whatever). Do you find that you use "guard" fairly often? Just curious.
17:23:07 <danharaj> edwardk: in particular `first` should be dinatural in its extra parameter. I'm not sure if that's implied by parametricity.
17:23:10 <monochrom> I don't use guard often. because I don't use MonadPlus often. but it may be true that I use P(guard | MonadPlus) often
17:23:42 <stolaruk> monochrom: How about "when" and "unless"?
17:24:17 <monochrom> I don't use them often. even P(when/unless | Monad) is not high
17:24:17 <danharaj> edwardk: and finally, in an old version of profunctor you had a lenticular typeclass, which is shown to be equivalent to `first` and their notion of internal strength when you're over a cartesian category, which Hask is.
17:24:41 <stolaruk> monochrom: I'm afraid I don't understand the notation you're using
17:24:56 <monochrom> P(X | Y) is probability notation. do you know it?
17:25:01 <quchen> monochrom tried to say "no". ;-)
17:25:14 <monochrom> I try to be precise.
17:25:26 <stolaruk> Ah. Back in high school I probably did, as I recall taking a college prep prob and statistic course which I actually enjoyed very much ;)
17:25:29 <shachaf> danharaj: Are you talking about old Lenticular or new Lenticular?
17:25:45 <shachaf> Wait, maybe old Lenticular was the only Lenticular.
17:25:49 <shachaf> I just called them all Lensy.
17:25:50 <schell> bitemyapp: looks like i'll be trying out clientsession
17:25:56 <danharaj> shachaf: this lenticular http://hackage.haskell.org/package/profunctors-3.1.1/docs/Data-Profunctor.html#t:Lenticular
17:26:05 <stolaruk> quchen: Ah, I see :)
17:26:33 <monochrom> P(guard | MonadPlus) is the conditional probability "when I do use MonadPlus, how likely do I use guard in that case". I think it may be high, but I didn't count carefully.
17:26:48 <shachaf> Yes, that was the original Lensy.
17:26:51 <stolaruk> monochrom: I see.
17:26:58 <monochrom> because P(guard) is not very relevant
17:27:22 <shachaf> edwardk pushed it despite my objections. :-(
17:27:30 <shachaf> But it's gone now so it's not so bad.
17:28:01 <danharaj> well it seems it wasn't so particularly bad
17:28:07 <danharaj> theoretically at least
17:49:26 <bitemyapp> ddellacosta: cheers :)
17:54:11 <ddellacosta> bitemyapp: mornin'
17:58:33 <ddellacosta> bitemyapp: ha, just realized this is #haskell, not #clojure...heh
17:59:15 <dwcook> What's the most appropriate type to use for receiving textual data from the network where I'd also like to strip any trailing '\r' characters?
18:00:24 <dwcook> I'm currently using ByteString but I'm not sure it has a strip-from-end operation.
18:01:22 * hackagebot ghc-parser 0.1.0.0 - Haskell source parser from GHC.  http://hackage.haskell.org/package/ghc-parser-0.1.0.0 (gibiansky)
18:04:22 <edwardk> danharaj: holy crap we got the name for strength right!
18:04:35 <dwcook> I suppose let strip char str = if singleton char `isSuffixOf` str then init str else str
18:05:06 <Jesin> What library would you guys recommend for prime factorization?
18:06:08 <mm_freak_> Jesin: arithmoi
18:06:18 <mm_freak_> for anything number-theory
18:06:36 <Jesin> I also found http://hackage.haskell.org/package/factory
18:06:44 <jakedust> question since I don't have my ghc handy: how does haskell deal with signed zeros and NaNs?
18:06:47 <Jesin> dunno how those compare
18:07:13 <dwcook> > 0 / 0 /= 0 / 0
18:07:14 <lambdabot>  True
18:07:32 <Jesin> > 0.0 == (-0.0)
18:07:34 <lambdabot>  True
18:07:39 <Jesin> > (-0.0)
18:07:40 <lambdabot>  -0.0
18:07:56 <shachaf> GHC floats are IEEE floats.
18:08:17 <jakedust> nice.
18:08:25 <mm_freak_> Jesin: here is a way to compare:  arithmoi uses a combination of wheel and ECM factorization
18:08:53 <mm_freak_> Jesin: factory doesn't seem to implement factoring at all
18:09:08 <mm_freak_> oh, it does
18:09:15 <jakedust> > 0 / 0
18:09:16 <lambdabot>  NaN
18:09:20 <jakedust> > -0 / 0
18:09:21 <lambdabot>  NaN
18:09:24 <shapr> @quote
18:09:24 <lambdabot> RootLabs says: Bitcoin remains the most efficient method to buy drugs & transfer wealth from anti-govt zealots to hackers.
18:09:30 <shachaf> Also you can /msg lambdabot.
18:09:37 <aleksejs_> Hi, I have a list of tuples, and i need to leave only unique by comparing only fst. Like foo [(1,1), (2,2), (2,3)] = [(1,1), (2,2)]
18:09:41 <mm_freak_> Jesin: it does through an awkward type class "Algorithmic"
18:09:44 <Jesin> > let x = 0.0 / (0.0 :: Double) in x >= x
18:09:44 <lambdabot>  False
18:09:49 <Jesin> > let x = 0.0 / (0.0 :: Double) in x <= x
18:09:50 <lambdabot>  False
18:09:55 <Jesin> > let x = 0.0 / (0.0 :: Double) in x `compare` x
18:09:56 <lambdabot>  GT
18:10:13 <jakedust> ouch.
18:10:44 <Jesin> aleksejs_: use nubBy
18:10:46 <Jesin> :t nubBy
18:10:47 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
18:10:56 <Jesin> aleksejs_: it's in Data.List
18:11:38 <Jesin> > Data.List.nubBy fst [(1,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
18:11:39 <lambdabot>  Occurs check: cannot construct the infinite type:
18:11:40 <lambdabot>    a0 = (a0, b0) -> GHC.Types.Bool
18:11:40 <lambdabot>  Expected type: (a0, b0) -> (a0, b0) -> GHC.Types.Bool
18:11:40 <lambdabot>    Actual type: (a0, b0) -> a0
18:11:42 <tac> > nubBy (const $ const True) [1..100]
18:11:43 <lambdabot>  [1]
18:11:46 <Jesin> ...wait what
18:11:59 <Jesin> > Data.List.nubBy ((==) `on` fst) [(1,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
18:12:00 <lambdabot>  [(1,1),(2,2),(3,1)]
18:12:01 <Jesin> there we go
18:12:22 <Jesin> aleksejs_: Data.List.nubBy and Data.Function.on
18:12:37 <aleksejs_> Jesin, thanks!
18:13:24 <triliyn> ((==) `on`) also exists under the name comparing, but I don't know where it lives
18:13:31 <triliyn> nubBy (comparing fst)
18:13:33 <Jesin> triliyn: nope
18:13:34 <shachaf> triliyn: No, that's compare `on`
18:13:37 <stolaruk> dwcook: did anyone answer your question? I'd also very much like to know the answer. Presently I'm using "Text" in my app, but I'm wondering if I should switch to "ByteString", given that my app is essentially a Telnet server...
18:13:49 <triliyn> oh, hmm, right
18:13:54 <jakedust> > isNaN(0.0/0.0)
18:13:55 <lambdabot>  <hint>:1:12: lexical error at character '\FS'
18:14:09 <jakedust> cough cough
18:14:15 <Jesin> mm_freak_: yeah, factory may or may not be fast, but it looks awkwardly designed
18:14:17 <jakedust> > isNaN 0.0 / 0.0
18:14:18 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Bool)
18:14:18 <lambdabot>    arising from a use of `GHC.Real./'
18:14:18 <lambdabot>  Possible fix:
18:14:18 <lambdabot>    add an instance declaration for
18:14:18 <lambdabot>    (GHC.Real.Fractional GHC.Types.Bool)
18:14:24 <jakedust> damn parens =p
18:14:25 <Jesin> I'll go for arithmoi
18:14:30 <Jesin> thanks ^_^
18:14:50 <Jesin> > isNan (0.0 / 0.0)
18:14:51 <lambdabot>  Not in scope: `isNan'
18:14:51 <lambdabot>  Perhaps you meant `isNaN' (imported from Prelude)
18:14:57 <Cale> jakedust: Your first command had a weird character in it just before the . in the second 0.0
18:14:57 <Jesin> > isNaN (0.0 / 0.0)
18:14:58 <lambdabot>  True
18:15:16 <Jesin> > isNaN (recip 0.0)
18:15:18 <lambdabot>  False
18:15:23 <Jesin> > recip 0.0 :: Double
18:15:24 <lambdabot>  Infinity
18:15:31 <Jesin> > recip (-0.0) :: Double
18:15:32 <lambdabot>  -Infinity
18:15:35 <Jesin> nice
18:15:41 <jakedust> Cale: weird
18:16:00 <Jesin> > let x = 0.0 in compare x x -- this is still weird
18:16:01 <mm_freak_> =)
18:16:02 <lambdabot>  EQ
18:16:24 <jakedust> wait, wat.
18:16:25 <Cale> > let x = 0/0 in compare x x
18:16:26 <lambdabot>  GT
18:16:36 <Cale> ^^ that's the weird one
18:16:39 <jakedust> oh.
18:16:51 <Jesin> derp, thanks Cale
18:17:06 <jakedust> Cale: AFAIR, IEEE754 doesn't define a cmp/compare function, so that's just implementation-defined behavior
18:17:13 <Cale> yes
18:17:29 <mm_freak_> > let x = 0/0 in x == x
18:17:31 <lambdabot>  False
18:17:32 <jakedust> MPFR raises an exception in this case
18:17:38 <Cale> But it doesn't give EQ because 0/0 is not supposed to be equal to itself
18:17:40 <jakedust> exception as in IEEE754 exception
18:17:47 <Jesin> > let x = 0/0 in x < x
18:17:48 <lambdabot>  False
18:17:48 <jakedust> i.e. a flag in some register, usually
18:17:48 <Jesin> > let x = 0/0 in x > x
18:17:49 <lambdabot>  False
18:18:13 <mm_freak_> > let x = 0/0 in x /= x
18:18:14 <lambdabot>  True
18:18:31 <jakedust> indeed, which is better than returning Maybe RealFloat
18:18:32 <Jesin> NaN isn't common enough to special-case that.
18:18:39 <mm_freak_> the float domain is weird
18:18:56 <jakedust> mm_freak: it is a very defined and specific kind of weirdness
18:19:17 <jakedust> arithmetic with floating point numbers is pretty well defined
18:19:20 <Jesin> In fact I kind of hope the value of "let x = 0 / (0 :: Double) in compare x x" isn't mandated by the Haskell standard...
18:19:24 <jakedust> and the standards are as sane as they can be
18:19:31 <mm_freak_> why is it defined that way?  it feels like a singularity to have one value, for which equality is not reflexive
18:20:06 <nstdloop> I've been reading some code that uses Lens and reading about it. It seems that += and -= are infix functions, but I can't find any documentation for them on hoogle, could anyone point me to a good place where I can get a better look at them?
18:20:14 <mm_freak_> having an equality that is not an equivalence relation doesn't sound well-defined to me
18:20:19 <Jesin> Ord is supposed to be a typeclass representing totally-ordered types
18:20:22 <Jesin> which Double isn't
18:20:26 <jakedust> mm_freak_: http://www.cs.berkeley.edu/~wkahan/ieee754status/why-ieee.pdf
18:20:28 <shachaf> nstdloop: Hayoo
18:20:43 <edwardk> > runState (_2 += 4) (1,2)
18:20:45 <lambdabot>  ((),(1,6))
18:20:50 <jakedust> it talks about most issues with floating-point arithmetic
18:20:54 <edwardk> > runState (_2 -= 2) (1,2)
18:20:55 <lambdabot>  ((),(1,0))
18:21:07 <edwardk> > runState (_2 -= 2; _2 += 1) (1,2)
18:21:08 <lambdabot>  <hint>:1:18: parse error on input `;'
18:21:08 <jakedust> and Kahan is the man who ensured we all have nice FPUs.
18:21:12 <edwardk> > runState (do _2 -= 2; _2 += 1) (1,2)
18:21:13 <lambdabot>  ((),(1,1))
18:22:02 <Jesin> perhaps there should be an option in GHC to make NaNs trigger an exception
18:22:05 <Jesin> or something
18:22:06 <Jesin> actually
18:22:29 <Jesin> can't most environments be configured to cause NaNs to raise exceptions?
18:22:36 <Jesin> like, hardware-wise
18:22:37 <Cale> Anyone know whether there's a good algorithm for factoring an integer into a square and squarefree part (better than general factoring)?
18:22:43 <jakedust> Jesin: they do
18:22:47 <Jesin> without slowdown in the execution of other operations
18:22:50 <jakedust> they raise FPU exceptions
18:22:54 <jakedust> which means a flag is set.
18:23:04 <jakedust> a flag that no one cares about or reads
18:23:11 * jakedust is a mathematician and cares about this kind of thing
18:23:39 <Jesin> jakedust: hm, is this also true of SSE and AVX and such?
18:23:43 <Cale> Ah, apparently MathWorld says it's not known.
18:23:52 <jakedust> Jesin: SSE yes.
18:23:54 <mm_freak_> Cale: not really…  you might try a special-purpose algorithm for finding small factors and remove multiples of them
18:24:04 <Jesin> k, cool
18:24:21 <jakedust> the MXCSR (sic) register stores the exceptions
18:24:22 <Jesin> jakedust: does that include comparisons of existing NaN values?
18:24:36 <jakedust> in x86-like architectures, at least.
18:24:43 <jakedust> (which is a given, assuming SSE =p)
18:24:48 <Jesin> k
18:24:53 <Cale> Supposedly, even just recognising that an integer is squarefree might be as hard as general factorisation.
18:24:57 <jakedust> Jesin: AFAIK, yes.
18:25:22 <mm_freak_> jakedust: i don't really like arguments of the form: "it's proven/well-defined/shown/…, just read these 50 pages"
18:25:27 <Jesin> hmm
18:25:38 <mm_freak_> jakedust: could you summarize how NaN ≠ NaN is well-defined?
18:25:43 <mm_freak_> by any standard of "well-defined"
18:25:44 <Jesin> jakedust: I've also heard something about "quiet" vs "signaling" NaNs
18:25:46 <jakedust> mm_freak_: it's a very readable text from the guy who defined this kind of stuff
18:26:08 <Jesin> mm_freak_: well-defined as in, it's not *unspecified*
18:26:21 <Jesin> mm_freak_: it is specified that NaN is never equal to anything.
18:26:29 <jakedust> yup, and floating-point numbers have a canonical partial order, IIRC.
18:26:33 <Jesin> By the IEEE comparison operation.
18:26:50 <mm_freak_> i might read it, if this becomes relevant for my integer brain some day =)
18:27:16 <Jesin> mm_freak_: NaNs in general tend to be annoying.
18:27:22 <jakedust> Jesin: quiet and signaling NaNs are implementation-defined, so you can never count on them, IIRC
18:27:22 <stolaruk> Happy holidays to all. I'm a bit drunk and currently smoking a cigar. Hope you are all having as good a time.
18:27:39 <stolaruk> May Haskell have a good new year as well.
18:27:45 <Jesin> jakedust: hmm, I see
18:27:48 <Jesin> By the way
18:27:54 <jakedust> the standard doesn't require for implementations to make a distinction between them
18:28:09 <mm_freak_> stolaruk: thanks, you too
18:28:36 <jakedust> but technically they were meant to help distinguish between intended and  unintended NaNs
18:28:45 <mm_freak_> Jesin: well, by that standard PHP is well-defined by its implementation =)
18:29:14 <Jesin> mm_freak_: IEEE 754 is a documented standard.
18:29:30 <mm_freak_> Jesin: i know
18:29:49 <mm_freak_> my point is:  if you allow an equality not to be a proper equivalence relation, there must be a very very very good reason
18:29:50 <Jesin> mm_freak_: Any computer on which "NaN == Nan" is a True statement violates that standard.
18:30:11 <Jesin> I personally agree
18:30:19 <prophile> is Float/Double not required to be IEEE Float/Double?
18:30:22 <mm_freak_> in fact IEEE 754 /requires/ this weirdness
18:30:30 <Jesin> however, the IEEE guys who wrote the thing did not
18:30:37 <edwardk> danharaj++ # best christmas present ever
18:30:41 <stolaruk> mm_freak_: Let's hope 2014 sees continued interest in Haskell eh. When I started learning this language in May of this year, I wasn't too optimistic about its future, but after following developments on reddit and elsewhere, I've grown more and more optimistic.
18:31:25 <mm_freak_> stolaruk: i'm certainly not going to give up on haskell for my work in 2014 =)
18:31:33 <mm_freak_> most of my infrastructure already depends on it
18:31:38 <Jesin> It'd be hard to fix equality, but we could fix this just in Haskell
18:31:49 <jakedust> it wouldn't be fixing it.
18:31:58 <Jesin> > let x = 0.0 / (0.0 :: Double) in compare x x
18:31:58 <lambdabot>  GT
18:32:00 <jakedust> it'd be ruining equality.
18:32:24 <jakedust> Inf != Inf too
18:32:29 <mm_freak_> Jesin: maybe there is a good reason for this abnormality
18:32:34 <Jesin> > let x = 1.0 / (0.0 :: Double) in compare x x
18:32:34 <mm_freak_> i don't know, that's why i'm asking
18:32:35 <lambdabot>  EQ
18:32:35 <jakedust> hem, actually no.
18:32:38 <stolaruk> mm_freak_: Sounds good to me :) I decided that I would give it my all and try to become a "good" Haskell programmer, and I intend to continue this adventure as well
18:32:52 <jakedust> meh
18:32:57 <jakedust> transfinite arithmetic is always weird.
18:33:38 <stolaruk> mm_freak_: To me, Haskell started out as this odd and radical language; at this point it simply makes sense. ;)
18:34:13 <jakedust> stolaruk: it started out as an academic language, which means it was odd (because it was published) and radical (idem)
18:34:52 <Jesin> mm_freak_: I don't know why they decided NaNs are never equal, but I do know that "compare x x" evaluating to "GT" is weird, and that could be fixed by changing the default "compare"
18:34:56 <stolaruk> jakedust: Sorry, what do you mean by
18:35:03 <stolaruk> "idem"?
18:35:16 <Jesin> currently we have "compare x y = if x == y then EQ else if x <= y then LT else GT"
18:35:31 <jakedust> stolaruk: Sorry,  "Id. (masculine and neuter) and Ead. (feminine) (Latin, short for idem and eadem, "the same") are the terms used to denote the previously cited source (compare ibid.)."
18:35:54 <jakedust> that is, idem means "the same source as the last reference"
18:36:03 <jakedust> a bit more general than that, but meh
18:36:03 <stolaruk> jakedust: Ah, ok.
18:36:11 <Jesin> we could instead have "compare x y = if x <= y then (if x == y then EQ else LT) else GT"
18:36:25 * hackagebot purescript 0.2.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.2 (PhilFreeman)
18:36:49 <Jesin> WHICH WOULDN'T HELP
18:36:50 <Jesin> derp
18:36:54 <Jesin> let's see
18:36:55 <jakedust> Jesin: :)
18:37:14 <jakedust> compare NaN NaN should either raise an exception-like thing or return nothing
18:37:19 <stolaruk> jakedust: Yes, I think Haskell's roots in academia have proven to be very much to its advantage. For example, the "ivory tower" stuck to lazy evaluatation, which kept the language pure
18:37:25 <stolaruk> if that makes sense
18:37:26 <mm_freak_> stolaruk: sounds like this: http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
18:37:26 <Jesin> jakedust: it can't "return nothing"
18:37:29 <mm_freak_> =)
18:37:36 <jakedust> Jesin: Maybe nothing? ;)
18:37:40 <prophile> case (x <= y, y <= x) of { (True, True) -> EQ; (True, False) -> LT; (False, True) -> GT; (False, False) -> error "covered in bees" }
18:37:48 <Jesin> jakedust: it can't evaluate to Nothing either
18:38:06 <stolaruk> mm_freak_: I've read that before ;)
18:38:09 <jakedust> Jesin: stop coercing reality into your boolean logic :)
18:38:12 <stolaruk> it's funny
18:38:19 <Jesin> nice, prophile
18:38:43 <jakedust> stolaruk: as much as I like lazy evaluation (and I really do), I hate how it makes ghc a black box
18:38:52 <sheijk> Jesin: to handle iee-754 you'd need a fourth case in compare to signal "not equal but neither greater nor less"
18:39:01 <jakedust> I can't reason about the memory or CPU usage of a haskell program at all.
18:39:07 <Cale> jakedust: How does lazy evaluation do that?
18:39:09 <Cale> what?
18:39:10 <jakedust> or any other lazily evaluated language
18:39:26 <jakedust> because God knows what kind of optimization the compiler can do.
18:39:36 <Cale> The thing which makes GHC's evaluation a black box is that it's not using lazy evaluation :)
18:39:40 <Jesin> sheijk: yeah I guess there's no getting around that extra operation =/
18:39:59 <Cale> If it were just using lazy evaluation, that would be totally predictable
18:40:24 <jakedust> really?
18:40:26 <Cale> But it finds cases where strict evaluation is better automatically, and uses strict evaluation there.
18:40:32 <sheijk> imho you're better of with not using floats unless you do something involving numeric simulations
18:40:45 <prophile> or graphics
18:40:57 <jakedust> as in it would always use the most memory possible? =p
18:41:09 <stolaruk> jakedust: I hear you. Have you tried profiling your programs? I'm still a bit of a newbie when it comes to Haskell, but after profiling my program, by implementing some "best practices" I was able to reduce my program to 25% of its original runtime
18:41:09 <Cale> Still, lazy evaluation is a *pretty* good approximation most of the time
18:41:22 <sheijk> prophile: even with graphics you don't need full ieee-754
18:41:24 <Jesin> jakedust: nah, it could use more memory if it wanted
18:41:47 <Cale> When I reason about program performance, I just assume that lazy evaluation is going to be used everywhere, and then just get pleasantly surprised sometimes when the programs run faster.
18:41:51 <prophile> sheijk: well, your GPU does
18:41:51 <sheijk> most gpus didn't support NaNs properly until quite recently, in some cases not even +/-inf
18:41:54 <Cale> (or use less space)
18:42:00 <jakedust> sheijk prophile: ieee754 is mostly relevant to mathematicians, physics-guys and other hard scientists doing numerical work
18:42:07 <stolaruk> jakedust: Namely I used foldl' instead of foldr in a certain function that was taking far too long
18:42:07 <speckle> some still don't support double precision!
18:42:13 <prophile> okay, not the full 754
18:42:14 <prophile> point taken
18:42:14 <sheijk> jakedust: exactly.
18:42:27 <Jesin> Cale: hm, so does it, for example, automatically use (foldl' f) instead of (foldl f) whenever it can deduce that f is strict in both arguments?
18:42:34 <Cale> Jesin: yeah
18:42:43 <Jesin> nice
18:42:50 <jakedust> sheijk: which is exactly why I care about ieee754 compliance =p
18:42:52 <Cale> Jesin: Well, it amounts to that
18:43:00 <Jesin> even nicer
18:43:38 <mm_freak_> the nice thing about lazy evaluation is that it allows better abstractions, which prevents bugs…  the downside is that from time to time it does lead to a space leak
18:43:41 <Cale> Yeah, it's not a hard-coded rule which recognises and substitutes the definition of foldl, but rather something which is done uniformly everywhere.
18:44:01 <Cale> You can have space leaks with strict evaluation too though.
18:44:10 <mm_freak_> but this isn't really a problem…  most of those are only difficult to locate, but easy to fix once located
18:44:19 <Cale> Space usage is tricky business in any setting.
18:44:25 <jakedust> I'm the kind of person who cares about machine epsilons and those other machine-based stuff =p
18:44:40 <Jesin> Cale: yeah, for example strictly evaluating an infinite list when you only need the first two elements.
18:44:42 <Jesin> ^^
18:44:43 <jakedust> which means that Haskell to me is a great language to play with, but not to work with
18:44:45 <stolaruk> Cale: Yeah I've realized lately, through reading and whatnot, that you have to strike a balance between lazy and strict
18:44:47 <Cale> Jesin: :D
18:44:57 <mm_freak_> if the relevant part of your program isn't huge, you can generally just make an educated guess and bruteforce from there
18:45:01 <Cale> stolaruk: and lazy is the right default, imo
18:45:15 <Cale> stolaruk: You only get most of the benefits of lazy evaluation if it's the default
18:45:28 <stolaruk> Cale: Well "lazy composes well" and in Haskell we compose a lot, don't we ;)
18:45:32 <Cale> right
18:45:44 <jakedust> lazy is the default default for most applications
18:45:46 <Cale> and if you're not lazy by default, then you end up with nothing to compose in your libraries
18:45:53 <jakedust> ehm, right default.
18:46:03 <mm_freak_> jakedust: i guess as a mathematician you would want results as soon as possible
18:46:05 <Jesin> Also, I love that you can have a program where "main = getContents >>= (putStr . f)"
18:46:18 <Jesin> and still have it output things at a reasonable rate
18:46:22 <Cale> btw, you can also write that as  interact f
18:46:34 <Cale> :t interact
18:46:35 <lambdabot> (String -> String) -> IO ()
18:46:44 <Jesin> nice
18:46:45 <mm_freak_> jakedust: high performance haskell is a bit slower than C on average, but much faster to write, and usually easy to parallelize
18:47:03 <jakedust> mm_freak_: not even as soon as possible, but as soon as I can guarantee
18:47:21 <Jesin> Cale: the program I was writing took binary input and produced text output, though, so I was using "main = Data.ByteString.Lazy.getContents >>= (putStr . f)"
18:47:25 <stolaruk> mm_freak_: Seems that if you are willing to do some detailed profiling and optimization, you can beat C's performance, no?
18:47:33 <mm_freak_> stolaruk: sometimes
18:47:37 <jakedust> mm_freak_: parallelizing is nice for some things, but in some cases I really want to make sure that the compiler is choosing the right instruction
18:47:56 * jakedust has read more x86 asm than he would want in a lifetime
18:47:56 <Jesin> jakedust: any examples?
18:48:01 <mm_freak_> stolaruk: haskell beats C when it comes to parallelization, but especially floating point number crunching is still faster in C
18:48:28 <mm_freak_> jakedust: your low level knowledge may be standing in your way =)
18:48:37 <mm_freak_> jakedust: i'm saying this, because that was true in my case
18:48:39 <jakedust> Jesin: in abstract, checking if using an AVX instruction is better than a SSE instruction.
18:48:51 <twiceler> jakedust: I'm interested; what kind of stuff do you work on?
18:49:05 <stolaruk> jakedust: Have you optimized Haskell to the assembly level?
18:49:13 <jakedust> stolaruk: nope, only C.
18:49:18 <stolaruk> jakedust: Do tell we are all interested ;)
18:49:21 <Cale> -ddump-asm :)
18:49:25 <zRecursive> me too
18:49:31 <jakedust> I haven't used Haskell for any serious numerical stuff yet =p
18:49:46 <Cale> (but looking at core is usually far more useful)
18:49:50 <mm_freak_> jakedust: you should just try it out…  and by "trying out" i mean, do something nontrivial
18:50:10 <jakedust> twiceler: my research is in distance geometry
18:50:10 <stolaruk> jakedust: So your assembly optimizations are optimizations on C?
18:50:32 <twiceler> jakedust: I ask because I do numerical stuff in Haskell... But I'm also pretty new to programming and definitely don't know much low-level stuff :)
18:51:09 <Jesin> hm.
18:51:18 <jakedust> stolaruk: my assembly optimizations tend to be checking which way gcc/clang manages to optimize better my code =p, though I sometimes delve into lower-level stuff
18:51:20 <zRecursive> The lowest low-level is 0 and 1  :)
18:51:23 <stolaruk> twiceler: what sort of numerical stuff? Are you "crunching" lots of numbers
18:51:34 <jakedust> like checking what OpenBLAS is doing for my arch
18:51:48 <stolaruk> jakedust: Well, sounds pretty hard core
18:51:54 <jakedust> (in my case, a Phenom X6 at home and a haswell i7 at the lab)
18:52:00 <mm_freak_> one properly written page of repa code probably outperforms thousands of lines of carefully written C code (because a haskell RTS can do stuff C can't do as easily)
18:52:23 <Jesin> mm_freak_: "repa"
18:52:23 <Jesin> ?
18:52:24 <stolaruk> mm_freak_: what is repa
18:52:30 <mm_freak_> and if that doesn't do the trick, import the 'accelerate' modules instead of the repa modules and let it run on the GPU =)
18:52:39 <twiceler> stolaruk: Lately, yeah. Doing linear algebra stuff, mainly.
18:52:39 <jakedust> stolaruk: not really, you just have to get familiar enough with x86/x64 asm
18:52:40 <Jesin> wait what
18:52:54 <mm_freak_> IMO in most domains low level optimization is not the way to go any longer
18:52:55 <Cale> http://hackage.haskell.org/package/repa
18:53:09 <twiceler> stolaruk: I've been using hmatrix. I made some CUBLAS bindings as well...
18:53:14 <mm_freak_> Jesin: what Cale said
18:53:15 <jakedust> stolaruk: I can't write x86 asm to save my life, but I can usually understand it enough to see if it's not doing more work than needed
18:53:19 <stolaruk> I say mad props to anyone who knows any assembly, that is the black magic
18:53:30 <stolaruk> jakedust: interesting
18:53:36 <Jesin> mm_freak_: "accelerate" modules?
18:53:37 <Jesin> hm.
18:53:46 <Jesin> http://hackage.haskell.org/package/accelerate
18:53:46 <mm_freak_> @hackage accelerate
18:53:47 <lambdabot> http://hackage.haskell.org/package/accelerate
18:54:11 <jakedust> I recommend any MIPS-based asm to anyone who wants to learn enough to play with it
18:54:15 <stolaruk> "Repa provides high performance, regular, multi-dimensional, shape polymorphic parallel arrays. All numeric data is stored unboxed. Functions written with the Repa combinators are automatically parallel provided you supply +RTS -Nwhatever on the command line when running the program."
18:54:20 <jakedust> x86 is awful to write by hand
18:54:27 <mm_freak_> the APIs of repa and accelerate are very similar, so often you can translate repa code to accelerate code very easily
18:54:29 <mm_freak_> in some cases even verbatim
18:54:30 <Jesin> Wow.
18:54:37 <Jesin> Wow
18:54:51 <amosr> they happen to be made by the same group of people :-)
18:54:56 <Cale> wow, many buzzword, such features
18:54:57 <Jesin> goddamn.
18:55:21 * jakedust still is unhappy that all the x87-based optimizations he learned are completely useless nowadays
18:55:22 <twiceler> Accelerate is really an incredible library
18:55:22 <stolaruk> BTW I recently tried compiling my code for my 4 cores, it ran slower. Is this to be expected, given that I'm doing nothing manually for threading or parallellism?
18:55:43 <zRecursive> jakedust: MIPS ? then which OS to you use ?
18:55:55 <Cale> stolaruk: If you didn't use par or have multiple threads, or use any of the libraries for parallelisation, then yeah, it'll just run a bit slower.
18:55:59 <mm_freak_> jakedust: don't feel bad…  my x86 knowledge became useless as well
18:56:23 <jakedust> zRecursive: you can learn a MIPS-like arch by using emulators
18:56:36 <zRecursive> oh
18:56:39 <Cale> stolaruk: You'll be incurring the cost of starting up and scheduling multiple capabilities when those aren't going to do any work for you.
18:56:50 <mm_freak_> Cale: you would just link the single-threaded run-time then, so the pars wouldn't make a speed difference
18:56:54 <stolaruk> Cale: Ok, makes sense. Besides "-O2" then are there any compiler flags I use and expect to get better performance for "free"?
18:56:54 <jakedust> zRecursive: I just don't think that learning x86 asm is useful enough
18:57:08 <jakedust> mm_freak_: x87 is the FPU
18:57:12 <mm_freak_> jakedust: i know
18:57:31 <jakedust> mm_freak_: and since nowadays everyone uses SSE (which makes sense), aaargh.
18:57:48 <twiceler> stolaruk: Not from any *actual* knowledge, but I've heard -fllvm can improve things
18:57:51 <Cale> stolaruk: I wouldn't bother with anything more than -O2 without knowing more
18:57:52 <amosr> stolaruk: sometimes -fvia-llvm -optlo-O3 to compile using LLVM will give better performance for tight loops
18:58:02 <lpsmith> stolaruk, if you are interested in parallelism,  no,  not without using a library that uses it
18:58:03 <mm_freak_> jakedust: and tomorrow they'll be using something different and you'll have to write even more switches
18:58:18 <stolaruk> such replies, much knowledge
18:58:20 <Cale> yeah, you can try compiling via LLVM instead of using GHC's native code generator, and for some programs that'll do better
18:58:25 <jakedust> mm_freak_: that is life :)
18:58:32 <Cale> (but it might also be slower)
18:58:42 <jakedust> mm_freak_: that said, I myself don't care about which micro-arch you run
18:58:45 <stolaruk> Sorry but what is LLVM? I've heard this acronym b4
18:58:46 <Jesin> I hope LLVM can catch up to native someday.
18:58:52 <lpsmith> although there are some libraries that'll use parallelism behind the scenes without needing too much in-depth knowledge of the technique
18:58:52 <lpsmith> for some computations
18:58:56 <jakedust> mm_freak_: the guy who writes the BLAS you use does
18:58:56 <Jesin> stolaruk: http://llvm.org/
18:59:01 <stolaruk> kool
18:59:22 <Cale> Jesin: Well, it would be really embarrassing if it were straight up better ;)
18:59:26 <Jesin> stolaruk: it's an open-source compilation framework; it's also Apple's compiler of choice.
18:59:31 <mm_freak_> has anyone tried yarr?
18:59:34 <stolaruk> ahh
18:59:36 <jakedust> lpsmith: most BLAS/LAPACK-like libraries use all the cores you have available by default.
18:59:38 <Cale> After all the work that's gone into GHC's new NCG.
18:59:39 <mm_freak_> (as an alternative to repa)
18:59:53 <stolaruk> Jesin: Must have something to do with Objective C then?
18:59:54 <twiceler> jakedust: Seriously?
19:00:16 <jakedust> twiceler: OpenBLAS has a different asm codebase for each micro arch in the last few years
19:00:19 <jakedust> AMD and Intel.
19:00:58 <twiceler> jakedust: I feel like such an idiot... I could have made my code run so much faster
19:01:11 <mm_freak_> jakedust: well, library-implemented parallelism has the problem that it's local
19:01:18 <jakedust> by default it uses as many threads as your CPU says it has
19:01:19 <Jesin> stolaruk: there is a good objective-C frontend that produces LLVM bitcode
19:01:26 <jakedust> but you can limit it to less threads
19:01:30 <mm_freak_> no easy global parallelism, no migrations, etc.
19:01:48 <jakedust> mm_freak_: that's why you distribute your workload into small enough packages
19:02:12 <Jesin> stolaruk: it is, however, written in C++, and it compiles C and C++ pretty well.
19:02:12 <stolaruk> Jesin: I see
19:02:28 <Jesin> like, its support for the latest C++ standard
19:02:31 <jakedust> matrix operations nowadays are basically reducing the operation into sizes your CPU can handle well enough
19:02:37 <Jesin> was fully-developed before GCC's, iirc.
19:02:56 <jakedust> Xeon Phis have awesome 512-bit registers.
19:03:03 <jakedust> well, they will have.
19:03:12 <mm_freak_> jakedust: let me tell you how i parallelize my code…  usually i just replace a "map" by a "parMap rdeepseq" and voila…  regardless of what it is i am parallelizing =)
19:03:20 <stolaruk> BTW when ppl say "compile to native code", what do they mean?
19:03:34 <stolaruk> What exactly is native code?
19:03:49 <jakedust> mm_freak_: thing is, on a lower level you can really get amazing performance improvements
19:04:14 <jakedust> mm_freak_: AVX can give almost double the performance on raw floating point operations
19:04:22 <Jesin> stolaruk: native code is the stuff your processor interprets.
19:04:23 <twiceler> jakedust: I just read the Wikipedia article on distance geometry. So would things like PCA/multi-dimensional scaling be related?
19:04:28 <geekosaur> stolaruk: as opposed to compiling to some virtual bytecode (JVM, CLR, Parrotcode, etc.)
19:04:36 <jakedust> twiceler: yup.
19:04:40 <mm_freak_> jakedust: that will be a benefit for a computation that runs for weeks
19:04:48 <jakedust> mm_freak_: ;)
19:04:48 <Jesin> stolaruk: that is, your CPU is a hardware-based interpreter for its "native code".
19:04:50 <stolaruk> So then it means compiling for "your CPU:
19:04:50 <geekosaur> (or erlang's BEAM)
19:04:56 <stolaruk> ok
19:05:12 <twiceler> jakedust: Cool. Isomap? I took a class recently on something called "Diffusion Maps" which might be up your alley
19:05:38 <jakedust> twiceler: http://dga2013.icomp.ufam.edu.br/images/uploads/DGA2013-TopFiveBestPapers-01-AlencarBonatesLiberaliAloise-BPforMultiDimScalClusterPartition-slides.pdf
19:05:42 <mm_freak_> jakedust: however, if the computation only runs for 1 day, let it run for 1.2 days, but use one day less for development =)
19:06:43 <jakedust> twiceler: This is how we tend to work on clustering and MDS :) (I know all the authors, heh)
19:07:14 <mm_freak_> anyway, enough haskell marketing for today =)
19:07:33 <jakedust> mm_freak_: development time is easy
19:07:47 <jakedust> y'know, we grad students don't get paid well =p
19:07:56 <mm_freak_> hehe, indeed
19:08:17 <monochrom> precisely because you don't get paid well, you should work less hard.
19:08:47 <jakedust> academia isn't a market.
19:09:06 <jakedust> if you work less hard, you just get kicked out.
19:09:06 <mm_freak_> you're selling your brainpower
19:09:11 <mm_freak_> that's a market =)
19:09:20 <julianb> Hi. I'm having some trouble with this ( http://lpaste.net/97582 ) code. The problem itself is that when I try to V.write, I get a "No instance for (V.MVector ST Word8)", which I have no idea how to fix...
19:09:54 <jakedust> mm_freak_: the brainpower to euro/dollar/bitcoin/whatever rates aren't really good :)
19:10:37 <stolaruk> jakedust: Write a much needed Haskell book based on your research and we will luv u 4eva
19:11:50 <jakedust> stolaruk: maybe in some decades :)
19:12:39 <Cale> julianb: That error sounds like you've confused an ST action which produces Word8 values for an MVector of Word8 values somewhere
19:14:29 <julianb> Cale, that could only be in the line "vector <- V.replicate words (255 :: Word8)" but thats an MVector of Word8 values
19:14:47 <Cale> julianb: It would be nice to see the entire text of the error and/or not just have a snippet from your source file
19:14:58 <Cale> oh
19:15:07 <Cale> vector is being used as an ST action
19:15:15 <Cale> on the last line of the big do-block
19:15:41 <Cale> Perhaps you meant to freeze it or something
19:15:58 <julianb> well, I actually meant to return it
19:16:00 <Jesin> hmm.
19:16:08 <julianb> here's the code with the error: http://lpaste.net/97583
19:16:29 <Jesin> mm_freak_ or anyone else familiar with the "accelerate" library and similar
19:16:59 <Cale> Yeah, that error is a bit misleading, the real problem was that you were using vector as an ST action, which caused the types of everything else to be inferred strangely
19:17:15 <julianb> so it's that last line causing problems?
19:17:41 <Cale> yes
19:17:50 <monochrom> I very much doubt that you can "return vector" either. the vector is not supposed to escape your runST session.
19:17:53 <Cale> Also, you won't be able to return the vector
19:18:02 <Cale> because it's still a mutable vector
19:18:26 <julianb> so I should convert it to an immutable one somehow?
19:18:30 <Cale> and can only be accessed in that one ST action. The type of runST won't let it escape.
19:18:38 <Cale> Yes, using freeze
19:18:39 <julianb> that's what you meant by freeze
19:18:50 <julianb> there's no freeze in http://hackage.haskell.org/package/vector-0.10.0.1/docs/Data-Vector-Generic-Mutable.html
19:18:55 <Cale> freeze :: PrimMonad m => MVector (PrimState m) a -> m (Vector a)
19:19:01 <Cale> in Data.Vector
19:19:33 <julianb> oh, all right :)
19:19:35 <julianb> thanks
19:19:40 <twiceler> is there no runVector, like there is a runSTArray?
19:20:04 <julianb> there's a STVector type
19:20:07 <monochrom> there is no runSTArray either
19:20:13 <Axman6> you'd need return vector for that code to work anyway right?
19:20:13 <twiceler> freeze will copy the vector; but if you just want the vector at the end of your computation, you should be able to get the vector without making a copy
19:20:14 <mm_freak_> Jesin: i've used accelerate a few times
19:20:20 <julianb> monochrom, there is a runSTArray
19:20:26 <Cale> monochrom: Yes there is
19:20:30 <mm_freak_> Jesin: if you have a question, just ask =)
19:20:30 <monochrom> oh well
19:20:31 <Cale> runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
19:20:33 <Jesin> I have a somewhat-expensive function siis :: Double -> Double -> Double -> Bool.
19:20:39 <Axman6> I think there's an unsafeFreeze too
19:20:44 <twiceler> monochrom: Yeah, it's just runSTArray = runST . unsafeFreeze
19:20:54 <Jesin> I would like to be able to evaluate it in parallel on a large set of points.
19:21:08 <julianb> is there any important difference between freeze and unsafeFreeze?
19:21:29 <Cale> julianb: If you modify the mutable array after the unsafeFreeze, anything can happen
19:21:32 <twiceler> julianb: freeze makes a copy; unsafeFreeze does not.
19:21:33 <Jesin> a large SPARSE set of points, that is
19:21:35 <mm_freak_> Jesin: would that make a proper map?  i mean, can you express it as an array 'map'?
19:22:16 <julianb> fair enough so as to avoid unsafeFreeze...
19:22:34 <Cale> In this case, using unsafeFreeze would be safe
19:22:48 <Jesin> :t map (map (map (f :: Double -> Double -> Double)))
19:22:48 <lambdabot>     No instance for (FromExpr Double) arising from a use of `f'
19:22:49 <lambdabot>     Possible fix: add an instance declaration for (FromExpr Double)
19:22:49 <lambdabot>     In the first argument of `map', namely
19:22:55 <Jesin> :t map (map (map (undefined :: Double -> Double -> Double)))
19:22:56 <lambdabot> [[[Double]]] -> [[[Double -> Double]]]
19:22:56 <Cale> because your ST action is ending, and nothing will ever be able to touch the MVector again
19:22:59 <twiceler> Using unsafeFreeze as the *last* call is always safe. Which is why I like runSTArray
19:23:07 <Jesin> ... derp
19:23:14 <Cale> yeah, it would be good to have that in the vector package
19:23:22 <Axman6> Jesin: [siis a b c | a <- as, b <- bs, c <- cs] `using` parListN size -- from http://hackage.haskell.org/package/parallel-2.2.0.1/docs/Control-Parallel-Strategies.html
19:23:36 <Jesin> :t map (map (map (undefined :: (Double, Double, Double) -> Bool)))
19:23:36 <julianb> is there anything other than avoiding index checks for unsafeRead and unsafeWrite?
19:23:37 <lambdabot> [[[(Double, Double, Double)]]] -> [[[Bool]]]
19:23:40 <Jesin> ^ there we go
19:23:55 <Axman6> that's not really what you want is it?
19:24:02 <Jesin> Axman6: only if it's lazy.
19:24:16 <mm_freak_> Jesin: the nesting level doesn't matter
19:24:20 <Axman6> also, liftM3 siis as bs cs `using` parListN size
19:24:22 <twiceler> Jesin: ?
19:24:50 <Jesin> hm.
19:24:54 <Jesin> actually
19:25:01 <Jesin> I need this list of points to be generated dynamically
19:25:03 <twiceler> Jesin: If your points are sparse, does that mean you throw away some of your results?
19:25:06 <Axman6> Jesin: what form is are the points you want to evaluate the function on in?
19:25:07 <mm_freak_> Jesin: array maps on multidimensional arrays are easy to express with accelerate, as long as you can express the function to map in accelerate's Exp language
19:25:49 <Jesin> alright, let's see.
19:25:49 <Axman6> accelerate only really supports CUDA though, so it's not that useful to many people
19:25:53 <mm_freak_> Jesin: as for the sparsity you can either pre-filter or let GPU parallelism handle it
19:26:00 <Jesin> My actual application here is, I'm doing a flood-fill along a 2D surface in 3D space.
19:26:30 <mm_freak_> Jesin: try to express it using repa first
19:26:35 <Jesin> I don't know ahead of time which points I need to evaluate at.
19:26:42 <mm_freak_> if repa can't express it, accelerate can't express it either
19:27:04 <mm_freak_> Jesin: http://chimera.labs.oreilly.com/books/1230000000929
19:27:38 <mm_freak_> (you can read it online, but if you like it and can afford it, please buy the dead tree version) =)
19:28:24 <dhrosa> is there a general typelcass or notion that is like the opposite of return? Like, taking a Just value out of a Maybe, a singleton item out of a list, etc, and possibly throwing an exception if not possible
19:28:26 <twiceler> Jesin: I just looked at what flood-fill is... It seems very much sequential?
19:28:48 <dhrosa> by notion I meant function*
19:29:24 <Jesin> twiceler: https://en.wikipedia.org/wiki/File:Wfm_floodfill_animation_queue.gif
19:29:27 <triliyn> dhrosa: generally that is considered a bad idea
19:29:28 <Jesin> does it still look sequential?
19:29:35 <triliyn> And I don't think there is a unified interface for it
19:29:43 <Jesin> dhrosa: yes
19:29:47 <twiceler> dhrosa: The thing is, all of those functions are partial. But the *idea* is comonads, perhaps
19:29:53 <Jesin> dhrosa: however, it does not apply to Monads
19:30:05 <Jesin> twiceler: the idea is actually "copointed"
19:30:33 <edwardk> dhrosa: none of those examples are actually instances of Comonad, because they can fail, but that is what you're generally fishing towards
19:30:43 <twiceler> Jesin: Thanks! Is copointed : functor :: comonad : monad ?
19:31:03 <edwardk> twiceler: more like pointed : copointed :: monad : comonad
19:31:06 <Jesin> twiceler: nope
19:31:22 <edwardk> functor = cofunctor, so there isn't a useful analogy there ;)
19:31:23 <Jesin> http://hackage.haskell.org/package/comonad
19:31:49 <twiceler> Ahh, thanks! Right, a functor needn't have a "return" sort of thing
19:31:59 <edwardk> functor :: (a -> b) -> (f a -> f b)   when you turn the arrows around you get (b -> a) -> (f b -> f a), which is just a functor again
19:32:12 <edwardk> when you turn around return :: a -> m a  you get extract :: m a -> a
19:32:39 <edwardk> and (=<<) :: (a -> m b) -> (m a -> m b)   becomes extend :: (m b -> a) -> (m b -> m a)
19:33:13 <edwardk> i used (=<<) rather than (>>=) for technical reasons, as the latter doesn't dualize nicely
19:33:25 <triliyn> edwardk: why don't you get (f b -> f a) -> (b -> a) for cofunctors?
19:33:39 <frxx> what do you mean by that? (doesno't dualize nicely)
19:33:57 <dhrosa> what are Pointed and Copointed supposed to represent exactly?
19:34:05 <edwardk> triliyn: its not 'every arrow' that you turn around, but rather the ones 'in the category' the outer -> there is definitional
19:34:23 <Jesin> class Pointed f where point :: a -> f a
19:34:24 <edwardk> a functor takes every arrow (a -> b)  and gives yu a new arrow (f a -> f b)
19:34:25 <triliyn> hmm
19:34:31 <joelteon> frxx: it's just that (>>=) corresponds to `flip extend'
19:34:31 <Jesin> class Copointed f where point :: f a -> a
19:34:37 <edwardk> notice the 'arrow' in the middle doesn't show up in that definition
19:34:45 <tac> More generally, a functor is a mapping which "preserves commuting diagrams"
19:34:53 <joelteon> Jesin: Pointed is an Applicative with only pure
19:34:56 <joelteon> and Copointed is the dual
19:35:09 <Jesin> joelteon: exactly
19:35:19 <edwardk> using ~> for arrows 'in the category under consideration': (a ~> b) -> (f a ~> f b)     -- (a ~> m b) -> (m a ~> m b)       (a ~> m a)
19:35:55 <edwardk> the problem is that (>>=) muddles the two kinds of arrows. m a -> (a ~> m b) -> m b    -- lets us recognize "one of the arrows in the category" but the other is split up
19:35:58 <Jesin> also, a "pointed functor" should satisfy "fmap f (point a) = point (f a)"
19:36:17 <joelteon> Jesin: were you not the guy asking about Pointed
19:36:19 <Modius> When destructuring etc. what's the way to bind the outer construct too?  E.g. have a tuple's (a, b) but also have c bound to the entire tuple.
19:36:22 <edwardk> Jesin: which is a free theorem
19:36:26 <Jesin> joelteon: nope
19:36:31 <joelteon> i forgot how to scroll weechat
19:36:36 <joelteon> ok, whoever it was: see what I said to Jesin
19:36:37 <Jesin> <dhrosa> what are Pointed and Copointed supposed to represent exactly?
19:36:40 <Axman6> Modius: c@(a,b)
19:36:42 <joelteon> dhrosa: ^
19:37:20 <Modius> Thanks
19:37:47 <dhrosa> oh there we go
19:38:02 <Jesin> edwardk: ... huh, I should've noticed that.
19:38:34 <edwardk> Jesin: the fact that the only stateable law for pointed is a free therem w.r.t Functor is why Pointed doesn't have Functor as a superclass any more.
19:38:50 <edwardk> it adds no value from a law perspective and rules out applications like Set.singleton
19:39:00 <Jesin> ah
19:39:52 <Jesin> ... everything that exports a one-arg constructor is a potential Pointed instance.
19:40:01 <dhrosa> joelteon: is it kind of like Pointed is anything that can be "boxed", and Copointed is anything that can be "unboxed"?
19:40:04 <Jesin> And many things that don't.
19:40:20 <edwardk> Jesin: pretty much
19:41:01 <triliyn> Jesin: anything that exports a one-arg constructor in its parameterized type, wouldn't it be?
19:41:11 <Jesin> triliyn: yes, thanks
19:41:25 <triliyn> data Fish a = Worm [a] | Bird Int couldn't use point = Bird
19:41:59 <Jesin> yeah
19:41:59 <dhrosa> also, I have a function applyOn :: (a->a) -> (Int, Int) -> [a] -> [a], second argument is lower and upper bounds. it takes a functionand applies it to part of a list, which argument order makes the most sense?
19:42:03 <shachaf> But it could have point x = Worm [x], or [], or [x,x], or (repeat x)...
19:42:11 <edwardk> Jesin: also, you still want point a = ZipList as where as = a : as -- etc.
19:42:13 <dhrosa> the function first or the bounds first?
19:42:16 <rose_> What might have gone wrong with this install of pretty-show? Here's the cabal install output: http://lpaste.net/97584
19:42:18 <flazz> is there a better way to express the following? ... where f = = (:: Word32) . fromIntegral
19:42:35 <flazz> i want point free, but i don't want a cumbersome annotaion
19:42:38 <edwardk> and the issue with point is like shachaf notes, the choice is very underconstrained
19:42:42 <Jesin> yeah "one-arg constructor" was a bad analogy
19:42:43 <shachaf> dhrosa: If you're using indexing like that it's possible that you shouldn't be using a list in the first place.
19:42:49 <edwardk> which is one reason why i'm somewhat down on pointed
19:43:05 <shachaf> edwardk: But affine traversals!
19:43:07 <dhrosa> shachaf: what should I use instead, Array or something?
19:43:15 <shachaf> dhrosa: I don't know.
19:43:45 <Jesin> by the way, the Monad instance for Stream a = a :> Stream a
19:43:48 <edwardk> shachaf: you were the one who taked me out of adding them in lens 4.0 ;)
19:44:17 <prophile> Jesin: is there one?
19:44:25 <edwardk> prophile: yes, it diagonalizes
19:44:26 <shachaf> edwardk: I like to stay on the other side of whichever decision you settle on, to keep things balanced.
19:44:34 <prophile> hrnf
19:44:40 <prophile> it looks a lot like Cofree Identity
19:44:41 <shachaf> (Actually I'm not convinced about affine traversals at all. I'm just sad about them.)
19:44:45 <prophile> which doesn't have a monad instance
19:44:49 <edwardk> shachaf: I appreciate you jumping up and down on the other side of the seesaw
19:44:51 <prophile> this troubles me somehow
19:44:57 <edwardk> prophile: it could
19:44:58 <shachaf> Cofree Identity does have a Monad instance.
19:45:12 <shachaf> Cofree f doesn't in general.
19:45:35 <shachaf> Well. A potential one.
19:45:37 <prophile> the way cofree is defined - in the free package at least - needs Alternative for a monad instance
19:45:41 <edwardk> Cofree admits several monads
19:45:47 <prophile> k
19:45:50 <triliyn> What is Cofree? I've read a bit about Free but I don't know which of the function arrows in its haskell implementation are also categorical arrows
19:45:52 <shachaf> prophile: Monad instances are not unique.
19:46:09 <shachaf> triliyn: All of them!
19:46:29 <shachaf> triliyn: data Cofree f a = Cofree a (f (Cofree f a))
19:46:37 <Jesin> (->) is an arrow on Hask
19:46:41 <shachaf> It's like Free with a product instead of a sum.
19:46:47 <edwardk> freeness (and cofreeness) are about whether a functor is left (or right) adjoint to a forgetful functor.
19:46:48 <prophile> shachaf: I see, so what guides the choice of which monad instances library authors provide?
19:47:03 <triliyn> hmm
19:47:05 <edwardk> a "free monad" is left adjoint to the forgetful functor that "forgets a monad is a monad and only remembers it is a functor"
19:47:10 <shachaf> prophile: Taste.
19:47:15 <Jesin> hmm
19:47:28 <edwardk> a "cofree comonad" is right adjoint to a forgetful functor that "forgets a comonad is a comonad and only remembers it is a functor"
19:47:49 <prophile> shachaf: hrm
19:47:50 <triliyn> I don't really remember what an adjoint is
19:47:59 <prophile> this seems somehow displeasing
19:48:01 <Jesin> it seems to me there should be a way to provide multiple instances, provided you specify which one you need... it occurs to me that this is called "newtype" and already exists.
19:48:01 <edwardk> http://stackoverflow.com/a/13352580/34707 talks about it more technically
19:48:05 <prophile> what other types admit multiple monad instances?
19:48:42 <edwardk> prophile: note, the different comonads for Cofree f requre different things of 'f'
19:48:46 <prophile> scratch that, writer has at least two for the dual of its monoid
19:49:06 <twiceler> So the all the derivatives (1st, 2nd...) of a function are an example of Cofree Vector Number?
19:49:07 <Jesin> prophile: [a] can have join = concat or join = head
19:49:13 <twiceler> loosely
19:49:18 <shachaf> Jesin: Er, no it can't.
19:49:26 <prophile> Jesin: join = head doesn't obey the monad laws I don't think
19:49:28 <edwardk> prophile: things like this are why we don't have an instance of Monoid for Int, is it max/minBound, +/0, */1, min/maxBound...
19:49:29 <Jesin> ...
19:49:39 <Jesin> derp
19:49:41 <Jesin> should've known
19:49:44 <prophile> edwardk: right, that seems sane
19:49:49 <edwardk> prophile: for the few cases this arises we typically use newtypes
19:49:56 <prophile> I was wondering why one would be picked where there's ambiguity
19:49:57 <shachaf> In particular the secret of Cofree is this: For any comonad W, a comonad homomorphism :: W a -> Cofree F a corresponds to a natural transformation (i.e. function, here) :: W a -> F a
19:50:17 <shachaf> Unless I mixed it up somehow.
19:50:20 <prophile> I'm also reminded of the Monoid instance for Maybe which I seem to remember being pretty unpleasant
19:51:17 <edwardk> prophile: here the choice is pretty canonical. the Identity case is "the odd man out", as that only works for representable functors, which are functors isomorphic to (->) x
19:51:50 <prophile> okay
19:52:05 <prophile> thanks edwardk and shachaf
19:52:06 <edwardk> prophile: it s also a matter of taste, as i offer a streams package that captures the other comonad/monad.
19:52:23 <edwardk> prophile: so you have somewhere else you can get the other instance
19:52:38 <edwardk> prophile: http://hackage.haskell.org/package/streams-3.1.1/docs/Data-Stream-Infinite.html
19:56:48 <Jesin> edwardk: don't Streams actually have a Monad instance for every https://en.wikipedia.org/wiki/Pairing_function ?
19:57:24 <edwardk> you'd need it to be associative iirc
19:57:59 <edwardk> also to have a unit
19:58:20 <Jesin> hm.
19:58:23 <Jesin> I wonder if there are any.
19:58:26 <edwardk> which i think shows there shouldn't be any interesting ones
19:59:24 <edwardk> now, we have a comonad for ((->) e) given a monoid on 'e'. that monoid is your pairing functon basically
19:59:38 <edwardk> but it's not stream like
20:00:46 <Jesin> hm, alright.
20:01:31 * hackagebot domain-auth 0.2.1 - Domain authentication library  http://hackage.haskell.org/package/domain-auth-0.2.1 (KazuYamamoto)
20:01:33 * hackagebot rpf 0.2.5 - Receiver Policy Framework  http://hackage.haskell.org/package/rpf-0.2.5 (KazuYamamoto)
20:02:32 <Jesin> > let xs = [0,1,2] in liftA3 (,,) xs xs xs
20:02:34 <lambdabot>  [(0,0,0),(0,0,1),(0,0,2),(0,1,0),(0,1,1),(0,1,2),(0,2,0),(0,2,1),(0,2,2),(1,...
20:04:37 <Jesin> edwardk or anyone else: I'm curious about Haskell's caching abilities.
20:04:51 <edwardk> have you read "stretching the storage manager"?
20:05:06 <Jesin> nope
20:05:57 <edwardk> @google stretching the storage manager peyton jones elliott
20:05:58 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.1948
20:05:59 <lambdabot> Title: CiteSeerX — Stretching the storage manager: weak pointers and stable names ...
20:06:38 <edwardk> that covers a lot about different designs you can use for caching/memoizaton
20:09:35 <Jesin> hm, thanks.
20:10:19 <edwardk> also look at data-memocombinators, representable-tries, uglymemo, and my recent lpaste about generic memoization
20:10:29 <edwardk> that should give you a good survey of the field
20:11:21 <Jesin> alright
20:11:21 <Jesin> hm
20:11:42 <joelteon> :t ਥ
20:11:42 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
20:11:57 <joelteon> whose fault is it that lambdabot has UTF8 trouble? is it mine or hers
20:12:14 <Rylee> everyone'sssssssssssss
20:12:17 <dhrosa> :t ਥ
20:12:17 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
20:12:19 <Rylee> speaking of lambdabot
20:12:21 <dhrosa> :t (ਥ)
20:12:21 <lambdabot> Not in scope: `'
20:12:22 <lambdabot> Not in scope: `'
20:12:27 <joelteon> lol...
20:12:29 <Rylee> how on earth does one set up the src plugin
20:12:42 <joelteon> so lambdabot doesn't get UTF8
20:13:30 <danharaj> edwardk: Reading Moggi's '89 paper on monads and noticed: "Since monads and adjunctions are 2-category concepts, the most natural way to model computations (and
20:13:30 <danharaj> datatypes) for more complex languages is simply by
20:13:30 <danharaj> monads (and adjunctions) in a suitable 2-category."
20:14:09 <Jesin> ^_^
20:15:03 <Jesin> heh
20:15:11 <dhrosa> :t 'ਥ'
20:15:12 <lambdabot>     lexical error in string/character literal at end of input
20:15:23 * monochrom fears 2-category!
20:15:41 <danharaj> you're right
20:15:45 <danharaj> we should be talking about bicategories
20:15:51 <Jesin> danharaj: I'm curious now how he arrived at that conclusion.
20:15:52 <danharaj> strictness is for catholics
20:15:57 * monochrom fears that too
20:16:23 <shachaf> danharaj: No, talk about weak 2-categories.
20:16:29 <danharaj> shachaf: same thing
20:16:34 <joelteon> talk about 2-big-2-category
20:16:42 * monochrom prefers week 2 categories
20:16:43 <shachaf> Not exactly.
20:17:12 <Jesin> seriously though
20:17:29 <danharaj> it's a general principle
20:17:42 <danharaj> which he uses to justify the laws for tensorial strength for monads he lists.
20:18:04 <Jesin> danharaj: are you saying a category theorist looked at monads and decided "this would be a good model for computation"?
20:18:12 <danharaj> yes.
20:18:18 <danharaj> and it happened before Haskell was a thing.
20:18:19 <monochrom> Moggi certainly did
20:18:26 <Jesin> How
20:18:30 <Jesin> I want to see that
20:18:47 <Jesin> I mean, the way it happened in Haskell was pretty clearly
20:18:59 <Jesin> that people wanted a pure way to structure IO computations
20:19:17 <Jesin> Monads were put into the language for that reason.
20:20:00 <Jesin> I'd like to know how this guy found "computations" when looking for things that monads could model.
20:20:08 * Jesin googles
20:20:22 <joelteon> I wonder how the hell somebody thought of using monads to represent IO
20:20:26 <binroot> @pl  \a b c -> min (min a b) c
20:20:26 <lambdabot> (min .) . min
20:20:47 <tac> Monads are just a convenient way to talk about algebraic structures. And most effectful "computations" end up forming some kind of algebraic structure
20:20:51 <dhrosa> what does @pl do?
20:20:58 <Iceland_jack> makes it pointless
20:20:59 <joelteon> pointfree equations
20:21:01 <dhrosa> ah
20:21:03 <Jesin> waaaaiiit
20:21:09 <joelteon> @pl \f g -> f . g
20:21:09 <lambdabot> (.)
20:21:21 <joelteon> takes a function with arguments and gives it in a form without arguments
20:21:24 <Jesin> this footnote... "Programs are identified with total functions from values to values."
20:21:25 <binroot> i've found pointfree notation very unreadable
20:21:29 <joelteon> usually, yeah
20:21:35 <joelteon> i only use it in pretty trivial situations
20:21:43 <tac> Jesin: It's a bit of a lie in Haskell, but it's pretty close
20:22:24 <mm_freak_> Jesin: i don't know how moggi did it, but when you understand monads as ∀ a. a → M a ← M (M a) and understand computations as M A, then this is quite natural
20:22:26 <Jesin> danharaj: "Computational lambda-calculus and monads", is that what you're reading?
20:22:32 <danharaj> yeah
20:22:35 <mm_freak_> Jesin: at least natural for me
20:23:11 <mm_freak_> the first expression pretty much means that:  a monad is something that allows you to go from an arbitrary number of applications of M to just one
20:23:15 <Jesin> mm_freak_: ah, that makes sense.
20:23:44 <Jesin> though
20:23:47 <monochrom> if you really mean what you say --- to find how Moggi figured it out --- your best bet is to interview him face to face.
20:23:52 <Jesin> yeah
20:24:32 <Jesin> I guess he was into computer science a lot as well, so yeah
20:25:23 <savior> Random question, how often do you guys deal with C programmers migrating to haskell?
20:25:26 <Jesin> yeah this paper appears to be mostly about Haskell-before-it-was-invented
20:25:27 <Jesin> cool
20:25:28 <mm_freak_> i think a category theoriest is trained to see these things as much as a group theorest is trained to identify monoids as a sensible abstractions for things you can combine
20:25:33 <mm_freak_> theorist
20:25:51 <mm_freak_> wow!
20:25:52 <mm_freak_> such typo!
20:25:58 <Jesin> hm?
20:26:02 <Jesin> ah
20:26:19 <monochrom> crossing theorist with priest? :)
20:26:26 <nisstyre> mm_freak_: as a sensible abstractions sounds more jargony
20:26:36 <mm_freak_> monochrom: yeah, i thought of edwardk when i wrote it =)
20:26:47 <mm_freak_> hehe
20:27:20 <monochrom> ok, now edwardk is a priest too. we can ask him for wedding ceremonies!
20:28:11 <mm_freak_> "and do you, mister monochrom, want to become adjoint to …"
20:28:19 <monochrom> I do!
20:28:47 <monochrom> "now you can put that -| sign between the two of you"
20:28:56 <Jesin> https://www.youtube.com/watch?v=BipvGD-LCjU <-- relevant
20:28:57 <joelteon> "honey, I think it's time for this relationship to be dual"
20:28:59 <Jesin> so very relevant
20:29:00 <Jesin> :D
20:29:15 <Jesin> "When we first met we simply connected, my heart was open but too dense"
20:29:19 <Jesin> ^_^
20:29:56 <mm_freak_> "you may now return your wife"
20:31:47 <mm_freak_> Jesin: nice =)
20:31:53 <joelteon> i'd like to endofunct /her/
20:36:40 <joelteon> whoops
20:44:36 <edwardk> monochrom: i was ordained by the universal life church about 15 years ago. i actually can officiate weddings ;)
20:45:36 <dhrosa> officially officiate
20:45:58 <joelteon> but with the library he's writing that should be out in january, he can generalize that to all legal functions
20:46:07 <edwardk> amusingly enough they screwed up getting me ordained and almost screwed up a friend's wedding as a result, so they sainted me for free "for my patience".
20:47:05 <edwardk> they threw in a doctorate in divinity as well
20:48:08 <scshunt> edwardk: hahaha
20:48:47 <dsrx> nice edwardk
20:48:52 <edwardk> i've been tempted to throw it on the resume for a long time ;)
20:51:11 <amosr> the real money is in divorces
21:00:35 <bitemyapp> how would I ">>" a list of functions?
21:00:46 <bitemyapp> my fumbling around with foldM and foldM_ have been abortive so far.
21:01:17 <Iceland_jack> bitemyapp: You can simply do mapM_ ($ value)
21:02:16 <bitemyapp> myApp = mapM_ (>>) [(middleware logStdoutDev), (middleware $ staticPolicy (addBase "./test")), wordRoute]
21:02:30 <bitemyapp> that failed with a type error
21:02:37 <Iceland_jack> that's not what I said
21:02:56 <Iceland_jack> You presumably want to those functions to a value first?
21:03:23 <bitemyapp> this is the original that works:  myApp = (middleware logStdoutDev) >> (middleware $ staticPolicy (addBase "./test")) >> wordRoute
21:03:24 <nisstyre> > foldl1 (>>) [[1],[2]]
21:03:25 <lambdabot>  [2]
21:03:26 <Iceland_jack> *want to apply
21:03:31 <nisstyre> > foldl1 (>>) [print "a", print "b"]
21:03:32 <lambdabot>  <IO ()>
21:03:33 <Iceland_jack> aah
21:03:39 <Iceland_jack> bitemyapp: you just want sequence
21:03:51 <nisstyre> yeah it looks like you want to sequence them
21:03:59 <bitemyapp> foldl1 (>>) worked
21:04:01 <Iceland_jack> You're not working with “lists of functions” like you said
21:04:05 <Iceland_jack> @src sequence
21:04:05 <lambdabot> sequence []     = return []
21:04:05 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:04:05 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
21:04:15 <Iceland_jack> byorgey: ı
21:04:20 <Iceland_jack> bitemyapp: ↑
21:04:42 <bitemyapp> how would you describe this? - [(middleware logStdoutDev), (middleware $ staticPolicy (addBase "./test")), wordRoute]
21:05:11 <Iceland_jack> bitemyapp: sequence_ [(middleware logStdoutDev), (middleware $ staticPolicy (addBase "./test")), wordRoute]
21:05:27 <bitemyapp> okay, so that worked.
21:05:34 <bitemyapp> foldl1 (>>) and sequence_ have worked.
21:05:40 <Iceland_jack> Yes, they're the same thing
21:05:40 <Iceland_jack>  
21:05:56 <Iceland_jack> except foldl1 fails for the empty case with run-time error
21:05:56 <bitemyapp> if you say so, the type signatures are rather different :)
21:06:04 <nisstyre> yeah don't use foldl1
21:06:07 <nisstyre> it was just an example
21:06:12 <nisstyre> it isn't exception safe
21:06:15 <bitemyapp> *** Exception: Prelude.foldl1: empty list
21:06:17 <bitemyapp> I see that.
21:06:25 <Iceland_jack> what do you mean bitemyapp?
21:06:30 <Iceland_jack> @ty foldl1 (>>)
21:06:31 <bitemyapp> and sequence_ does not. Very interesting.
21:06:31 <lambdabot> Monad m => [m a] -> m a
21:06:32 <Iceland_jack> @ty sequence
21:06:33 <lambdabot> Monad m => [m a] -> m [a]
21:06:38 <bitemyapp> foldl1 :: (a -> a -> a) -> [a] -> a
21:06:43 <nisstyre> bitemyapp: sequence_ handles empty lists
21:06:49 <nisstyre> foldl1 assumes there is at least one element
21:06:51 <bitemyapp> oh woops, I didn't apply the first argument.
21:06:58 <Iceland_jack> If you're discarding the resulting value like your example code showed, then you want sequence_
21:07:20 <bitemyapp> Cool. Thanks. :)
21:08:16 <f-a> hello. I calling "cabal install --reinstall -p hyphenation" to get profiling for this particular library. Cabal fails because this lib depends on unordered-containers (which I have but not the profiling version). How to tell cabal "hey, reinstall everything necessary to get me profiling for library x"?
21:09:49 <bitemyapp> Iceland_jack nisstyre thank you both very much. :)
21:10:08 <bitemyapp> should've just settled for a moment, looked at the type signature of my list, and hoogled :)
21:11:37 * hackagebot profunctors 4.0.2 - Profunctors  http://hackage.haskell.org/package/profunctors-4.0.2 (EdwardKmett)
21:12:14 <dhrosa> is ++ any more or less efficient than repeated :?
21:12:20 <L8D> If I did: data Item = ItemNumber Int | ItemString String
21:12:30 <L8D> Would ItemNumber have the type of Int -> Item ?
21:12:34 <nisstyre> dhrosa: they do different things
21:12:36 <Axman6> hmm, how do I use forall on two type variables in a data constructor? I've got forall k', b. Cons ((k, a) -> [(k', b)])  (MapReduceList k' b k'' c)
21:13:02 <dhrosa> couldn't you implement ++ with repeated : application?
21:13:06 <Axman6> it is
21:13:10 <Axman6> @src (++)
21:13:11 <lambdabot> []     ++ ys = ys
21:13:11 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
21:13:11 <lambdabot> -- OR
21:13:11 <lambdabot> xs ++ ys = foldr (:) ys xs
21:13:11 <nisstyre> dhrosa: if you need to append just one element, then reversing the list and consing them on, then reversing it when you're done is more efficient than ++
21:15:06 <Axman6> edwardk: any help with my forall query above?
21:15:06 * edwardk looks
21:15:11 <dhrosa> here's my actual problem I guess, let's say I have a list of 10 things, and a list of 20 things, I want to take elements from the second list and put them on the end of the first, what's the most efficient way to do that?
21:15:28 <Axman6> hmm, it's not forall (k', b). is it?
21:15:33 <dhrosa> is combining them with ++ and then using splitAt more piggy than take and drop and init and etc?
21:15:37 <edwardk> no , at all
21:15:39 <edwardk> forall a b.
21:15:39 <zRecursive> > reverse $ 1:(reverse [3,2,1])
21:15:40 <lambdabot>  [3,2,1,1]
21:15:42 <Axman6> guess not
21:15:44 <Axman6> ah, thanks
21:16:45 <dhrosa> hmm, now that I think about it, I remember LYAH implementing zippers with a reversed list for reasons nisstyre said
21:16:56 <nisstyre> dhrosa: it's called a snoc list
21:17:05 <nisstyre> snoc = cons in reverse ;)
21:17:23 <lispy> > reverse "cons"
21:17:24 <lambdabot>  "snoc"
21:17:52 <lispy> a reversed list is awfully similar to a stack
21:19:50 <dhrosa> haskell lists are somewhat similar to data List = Cons a List | Empty, right? meaning that they're trivial to prepend to but harder to append to?
21:20:06 <Axman6> yes
21:20:06 <L8D> What are all of the ways of performing pattern matching?
21:20:10 <Axman6> @src []
21:20:10 <lambdabot> data [] a = [] | a : [a]
21:20:43 <nisstyre> L8D: there's really only one way
21:20:48 <dhrosa> aha, but then that makes reading from the front easy too
21:20:48 <lispy> L8D: do you mean, what are all the places in the grammar where you can pattern match? Or do you mean, what are all the allowed patterns?
21:20:57 <L8D> I know there is case x of (x:xs) -> xs
21:21:02 <L8D> And f (x:xs) = xs
21:21:15 <lispy> and do Foo x <- baz; ...
21:21:24 <lispy> and \Foo x -> ...
21:21:25 <nisstyre> L8D: afaik everything gets desugared to case eventually
21:21:32 <dhrosa> L8D: that works for any constructor of a datatype
21:21:36 <lispy> and let Foo x = ...
21:21:46 <dhrosa> like Just x, Nothing, [], (x:xs), etc
21:22:15 <dhrosa> and you can nest it too, like Just (x:xs)
21:22:44 <nisstyre> L8D: it's much easier for the people writing the compiler if they only have to handle patterns in one way, so they let the parser handle some varying surface forms of it, but the real matching happens in case expressions
21:25:04 <L8D> So... function definition, case ofs, and where/let definitions
21:25:33 <nisstyre> L8D: http://www.haskell.org/onlinereport/exps.html#pattern-matching
21:25:45 <nisstyre> "Patterns appear in lambda abstractions, function definitions, pattern bindings, list comprehensions, do expressions, and case expressions"
21:28:32 <L8D> nisstyre: thank you very much!
21:28:56 <L8D> I'm very underqualified to write a curriculum on haskell
21:29:11 <nisstyre> L8D: no problem, if you ever have any questions about syntax then the report is the best place to look first
21:30:23 <nisstyre> L8D: oh and "where" gets transformed into a let by the compiler
21:30:26 <L8D> nisstyre: Thanks for the help
21:31:32 <binroot> @pl \s1 s2 -> -1 + floor $ (max s1 s2)/2
21:31:32 <lambdabot> (line 1, column 11):
21:31:32 <lambdabot> unexpected "-"
21:31:32 <lambdabot> expecting lambda abstraction or expression
21:31:50 <binroot> @pl \s1 s2 -> (-1) + floor $ (max s1 s2)/2
21:31:51 <lambdabot> ((-1 + floor) .) . flip flip 2 . ((/) .) . max
21:32:04 <binroot> @pl \s1 s2 -> floor ((max s1 s2)/2) - 1
21:32:05 <lambdabot> flip flip 1 . (((-) . floor) .) . flip flip 2 . ((/) .) . max
21:32:18 <binroot> loool i really don't like pointfree anymore
21:32:46 <nisstyre> binroot: pl doesn't know about other combinators
21:32:54 <nisstyre> like Data.Function.on
21:32:59 <binroot> oh
21:33:00 <joelteon> @pl \((a,b),c) (g,f) -> (((g a,g b),g (f b)),f (g a))
21:33:01 <nisstyre> or the arrow ones, I think
21:33:02 <nisstyre> not sure
21:33:03 <lambdabot> uncurry (uncurry ((const .) . flip flip snd . (ap .) . flip flip fst . ((.) .) . ap (flip . (liftM2 (liftM2 (,)) .) . (`ap` (flip (.) . flip id)) . (liftM2 ((.) . (,)) .) . (. flip id) . ap . ((,) .) . flip id) ((flip id .) . flip id)))
21:33:03 <lambdabot> optimization suspended, use @pl-resume to continue.
21:33:15 <binroot> LOL
21:33:58 <joelteon> let's see if it's clever enough for this
21:34:02 <dhrosa> that's terrifying
21:34:17 <joelteon> @pl \f g a b -> f (g a) (g b)
21:34:17 <lambdabot> join . ((flip . ((.) .)) .) . (.)
21:34:20 <joelteon> :t join . ((flip . ((.) .)) .) . (.)
21:34:21 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
21:34:24 <joelteon> :t liftM2 `asAppliedTo` (+)
21:34:24 <lambdabot> (Monad m, Num r) => (r -> r -> r) -> m r -> m r -> m r
21:34:29 <joelteon> whoops
21:34:42 <L8D> @src []
21:34:42 <lambdabot> data [] a = [] | a : [a]
21:34:49 <joelteon> i forgot how to haskell
21:35:44 <frx> L8D lambdabot lied there
21:36:05 <L8D> I know
21:36:26 <L8D> I’m just trying to see how type constructor operators are defined
21:36:38 <nisstyre> dhrosa: this is also terrifying https://gist.github.com/nisstyre56/8142941
21:36:47 <nisstyre> (that code is generated)
21:37:43 <joelteon> it's lisp!
21:37:44 <L8D> Is it supposed to do that?
21:38:32 <dhrosa> frx: is it a lie because "data [] a" isn't valid syntax?
21:38:47 <frx> right
21:39:03 <nisstyre> @src (->)
21:39:03 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
21:39:08 <nisstyre> @src ->
21:39:08 <lambdabot> Source not found. That's something I cannot allow to happen.
21:39:14 <nisstyre> why not lie for that too?
21:39:19 <joelteon> its not a data constructor
21:39:29 <nisstyre> oh I guess you can't get type constructor source
21:40:24 <nisstyre> although
21:40:26 <nisstyre> @src Maybe
21:40:26 <lambdabot> data Maybe a = Nothing | Just a
21:43:24 <YellPika> @src ($)
21:43:24 <lambdabot> f $ x = f x
21:44:17 <dhrosa> the definition for $ looks so silly without context
21:45:00 <nisstyre> @src (.)
21:45:00 <lambdabot> (f . g) x = f (g x)
21:45:01 <lambdabot> NB: In lambdabot,  (.) = fmap
21:45:02 <YellPika> And seems to be a little.... magical
21:45:16 <Axman6> YellPika: the magic is in the associativity
21:45:18 <triliyn> > (+1) . [1,2,3]
21:45:19 <lambdabot>  Couldn't match expected type `a0 -> c0' with actual type `[t0]'
21:45:43 <YellPika> Axman6: It's not just that. I'm finding it behaves funny when RankNTypes are involved
21:45:51 <Axman6> f . g . h $ x = (f . g . h) x
21:45:54 <triliyn> Lambdabot's (.) is not fmap
21:46:02 <Axman6> ah, no idea then
21:46:40 * hackagebot asn1-encoding 0.8.1.2 - ASN1 data reader and writer in RAW, BER and DER forms  http://hackage.haskell.org/package/asn1-encoding-0.8.1.2 (VincentHanquez)
21:46:46 <YellPika> Trying to think of an example...
21:46:56 <lispy> triliyn: it was at one point, but those changes were probably rolled back when Cale stopped being the maintainer.
21:47:23 <lispy> triliyn: While it would be interesting for Prelude.. to be fmap, it was confusing for only lambdabot to have that convention
21:48:31 <L8D> Why can’t one curry (,)
21:48:55 <L8D> Where (1,) becomes Num a => b -> (a, b)
21:49:26 <nisstyre> > ((+1) .) (*2) $ 3
21:49:27 <lambdabot>  7
21:49:36 <simpson> L8D: You need the TupleSections pragma to do so.
21:49:55 <nisstyre> oh I misread that as .
21:49:57 <nisstyre> damn this font
21:50:14 <nisstyre> and yes, -XTupleSections
21:50:37 <dhrosa> is that just an oversight in the language?
21:50:51 <lispy> dhrosa: yes
21:51:29 <joelteon> yeah, it's not in the spec
21:51:40 * hackagebot asn1-parse 0.8.1 - Simple monadic parser for ASN1 stream types.  http://hackage.haskell.org/package/asn1-parse-0.8.1 (VincentHanquez)
21:51:55 <amosr> hacks beget hacks
21:52:49 <dhrosa> what is hackagebot doing, just advertising random packages?
21:53:14 <amosr> dhrosa: it's when someone uploads a new version of a package, I believe
21:53:17 <joelteon> hackagebot broadcasts every upload
21:53:20 <dhrosa> oh
21:53:26 <Axman6> bleh, why doesn't unorderded-containers provide an adjustWithDefault or something
21:53:45 <L8D> Does haskell have sets?
21:53:49 <Axman6> yes
21:53:51 <joelteon> @hoogle Set
21:53:51 <lambdabot> Data.Set module Data.Set
21:53:51 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment Set :: LogicOp
21:53:51 <lambdabot> Data.Set data Set a
21:53:58 <L8D> sweet
21:54:03 <Axman6> there's also Data.HashSet
21:54:19 <Axman6> and Data.HashMap.{Lazy, Strict} which I'm struggling with
21:54:20 <L8D> Is there syntactic sugar for them?
21:54:36 <joelteon> not yet
21:54:43 <YellPika> Question: If I define "f <| x = f x" (with $-like associativity and precedence), and "foo :: a -> (forall b. b -> b) -> a; foo x f = f x", then why does "foo 3 $ id" compile while "foo 3 <| id" doesn't?
21:54:51 <amosr> isn't "Data.Set.fromList [1,2,3]" sweet enough?
21:55:48 <YellPika> L8D: GHC HEAD has OverloadedLists
21:56:08 <johnw> what is the type of <|?
21:56:33 <benbangert> has anyone else tried to install binary on osx lately? it worked on my mbp, but its throwing an error on install on my mini
21:56:41 <YellPika> johnw: Same as $
21:56:45 <johnw> :t ($)
21:56:46 <lambdabot> (a -> b) -> a -> b
21:57:16 <johnw> can you show us the error that you get?
21:57:17 <benbangert> this is the error I get trying to install the binary package, http://paste.ofcode.org/rUZ3Bz4J3HAXkLTBGTyKhf
21:57:51 <YellPika> Couldn't match expected type `forall b. b -> b' with actual type `a0 -> a0`.
21:58:03 <johnw> benbangert: you need to use gcc-4.2 as your C preprocessor
21:58:09 <johnw> benbangert: do you use homebrew?
21:58:16 <benbangert> yea
21:58:24 <johnw> then edit your settings file, underneath .cabal
21:58:36 <johnw> (or it may be in the tree whtere ghc is installed)
21:58:42 <johnw> and change /usr/bin/gcc to /usr/local/bin/gcc-4.2
21:58:57 <YellPika> I understand why it won't compile with <| (the operator implicitly makes id monomorphic [I think]), but I don't understand how $ succeeds...
21:59:31 <johnw> YellPika: yeah, that's odd
21:59:39 <benbangert> johnw: ah, ok. I don't see gcc in the config file in .cabal
21:59:46 <johnw> not config, "settings"
22:00:17 <benbangert> ah, I have no ~/.cabal/settings
22:00:28 <johnw> use find
22:00:34 <johnw> look in .cabal, and the tree where ghc is installed
22:01:15 <benbangert> ah, /usr/local//Cellar/ghc/7.6.3/lib/ghc-7.6.3/settings?
22:01:20 <johnw> exactly
22:02:19 <benbangert> johnw: awesome, that did the trick. thanks!
22:03:02 <YellPika> Hrm, I guess I'll throw my Q on to StackOverflow and see what comes up...
22:03:55 <L8D> What about dynamic string maps?
22:06:48 <L8D> \{name = name} -> name == username
22:09:04 <joelteon> yeah
22:09:17 <joelteon> Map
22:09:21 <joelteon> or HashMap
22:10:40 <joelteon> wait...what?
22:11:17 <frx> what do you mean by dynamic string map?
22:11:34 <L8D> A map where you have string fields which map to something
22:11:54 <frx> Map String Something
22:12:08 <L8D> K
22:12:18 <frx> @hoogle Map
22:12:19 <lambdabot> Data.Map module Data.Map
22:12:19 <lambdabot> Data.Map.Lazy data Map k a
22:12:19 <lambdabot> Data.Map.Strict data Map k a
22:13:22 <joelteon> that was weird notation you had
22:14:43 <L8D> I was writing something like: getNicks >>= filter \Whois {nick = nick} -> nick == "L8D"
22:16:15 <mikeplus64> @pl \Whois{nick = nick} -> nick == "L8D"
22:16:15 <lambdabot> (line 1, column 7):
22:16:15 <lambdabot> unexpected "{"
22:16:15 <lambdabot> expecting letter or digit, operator, pattern or "->"
22:16:15 <joelteon> so what you'd want to do is use Map String Whois
22:16:19 <joelteon> or probably Map Text Whois
22:16:31 <mikeplus64> or HashMap Text Whois
22:16:37 <Iceland_jack> :t (undefined :: IO [String]) >>= filter undefined
22:16:38 <lambdabot>     Couldn't match type `[]' with `IO'
22:16:38 <lambdabot>     Expected type: [String] -> IO String
22:16:38 <lambdabot>       Actual type: [String] -> [String]
22:16:50 <Iceland_jack> :t (undefined :: IO [String]) >>= filterM undefined
22:16:50 <lambdabot> IO [String]
22:16:54 <joelteon> eh, depends on the size of your text
22:18:55 <adnap> Hello
22:19:06 <adnap> What is the encoding of String?
22:19:15 <lightquake> adnap: a linked list of unicode codepoints
22:19:18 <johnw> is it UCS4?
22:19:43 <joelteon> > maxBound :: Char
22:19:44 <lambdabot>  '\1114111'
22:19:49 <lispy> johnw: I think so
22:19:53 <lispy> johnw: but not 100% certain
22:20:45 <adnap> I need UTF-8, so is http://hackage.haskell.org/package/utf8-string good?
22:20:51 <joelteon> use text
22:21:00 <lightquake> adnap: what are you *actually* trying to do?
22:21:01 <lispy> I thought text was utf-16
22:21:02 <adnap> What is the encoding of Text?
22:21:06 <joelteon> utf-8
22:21:09 <joelteon> You shouldn't really ever be using String
22:21:17 <lightquake> like, what is the actual task you are trying to accomplish here
22:21:30 <adnap> lightquake: Nothing
22:22:00 <lightquake> both String and Text conceptually represent a sequence of values of type Char
22:22:14 <lightquake> the values of type Char represent Unicode characters
22:22:33 <lispy> http://hackage.haskell.org/package/text-1.0.0.0/docs/Data-Text.html <-- says Text is utf-16
22:22:36 <joelteon> ok
22:22:38 <joelteon> well
22:22:44 <adnap> I am interested in implementing a spec that calls for UTF-8 specifically.
22:22:45 <joelteon> there are multiple ways you can transform a text value into a byte sequence
22:22:52 <lightquake> lispy: implementation detail
22:23:03 <joelteon> mostly in Data.Text.Encoding
22:23:08 <lightquake> yes
22:23:22 <lispy> adnap: You can think of handling the encoding during input/output and then using whatever representation you want inside your program.
22:23:30 <joelteon> but it doesn't really matter what text actually *is*
22:23:37 <joelteon> it matters how it's used
22:23:44 <joelteon> what it conceptually is
22:23:45 <adnap> So, my subgoal is to read ASCII and write a UTF-8 encoded string to a file
22:23:55 <lightquake> you'll want to use encodeUtf8 and decodeUtf8 in Data.Text.Encoding
22:24:16 <lispy> adnap: if you're not already aware of this, I would recommend taking a few minutes to read it: http://www.joelonsoftware.com/articles/Unicode.html
22:24:27 <lispy> ascii is utf-8 compatible
22:24:28 <adnap> lispy: I think I read that once
22:24:54 <benbangert> Don't suppose anyone knows offhand if bimap is strict or lazy? It doesn't seem to have any submodules one way or the other
22:25:23 <lightquake> any ASCII text that only contains bytes < 128 is also a valid UTF-8 encoding of that same text
22:25:34 <lightquake> if you're using the upper 128 you're going to have to fuck about with code pages or something
22:25:50 <mikeplus64> adnap: if all you need is ASCII, then you could get away with just using ByteString
22:26:21 <lightquake> mikeplus64: ew, don't do that
22:26:37 <adnap> It seems like people aren't reading what I am typing.
22:27:00 <mikeplus64> ascii and utf-8 are interchangeable
22:27:04 <mikeplus64> like lispy said
22:27:44 <dhrosa> is there a built-in function for applying a function to a list, but only on the elements where a condition holds?
22:27:44 <lightquake> well
22:28:01 <lightquake> that's because with unicode it's *really* easy for people to fall into X-Y problems
22:28:08 <lispy> dhrosa: well, what would the type be? Then you could hoogle for it
22:28:13 <adnap> encodeUtf8 and decodeUtf8 are what I want
22:28:29 <adnap> I think lightquake is right that I should use the Text type within the program
22:28:31 <lispy> adnap: that sounds right
22:28:54 <lightquake> dhrosa: i'd just define an auxiliary function with f x | p x = g x; | otherwise = x
22:28:56 <adnap> And I *specifically* need UTF-8 because that is part of the spec I am implementing
22:29:01 <lightquake> where p is the predicate and g is the map function
22:29:05 <lispy> dhrosa: but, I doubt you'll find a library function for that
22:29:25 <mikeplus64> you should use Text, no doubt, but it's worth knowing if all you will ever need/want is ascii, you can just use ByteStrings, because any ascii string is also utf-8
22:29:50 <adnap> lightquake: Don't you think it's kind of annoying to start doubting a person right away, thinking they have an X-Y problem?
22:30:06 <lightquake> adnap: 90% of all unicode questions are X-Y problems, in my completely unscientific experience
22:30:21 <dhrosa> nothing comes up with (a->a) -> (a->Bool) -> [a] -> [a], or the first two swapped
22:30:39 <dhrosa> well, until comes up, but that's not what I want
22:30:44 <mikeplus64> dhrosa: you can make that with map
22:30:52 <lispy> dhrosa: hoogle tries them swapped automatically :)
22:30:57 <joelteon> adnap: I would agree, if it wasn't usually an X-Y problem, heh
22:31:17 <dhrosa> yeah, that can pretty easily be done with map and a lamba or auxilary function, but so can a lot of things :p
22:31:19 <mikeplus64> dhrosa: mapIf f pred = map (\x -> if pred x then f x else x)
22:36:59 * hackagebot hamlet 1.1.7.6 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.7.6 (MichaelSnoyman)
22:36:59 * hackagebot shakespeare 1.2.0.4 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.2.0.4 (MichaelSnoyman)
22:37:25 <joelteon> oh good
22:41:54 * hackagebot stm-firehose 0.1.2 - Conduits and STM operations for fire hoses.  http://hackage.haskell.org/package/stm-firehose-0.1.2 (SimonMarechal)
22:42:44 <lispy> unsafeExtinguish
22:57:09 <adnap> How can I convert a ByteString to UTF-8, where each byte is interpreted as hex and converted to the characters 0 through F?
22:58:05 <adnap> Well, what I meant to ask is: is there a function to do this?
22:59:04 <edwardk> you want 2 chars output per byte?
22:59:58 <adnap> edwardk: Well, I thought a UTF-8 character is one byte, so are 0 through F encoded in one byte?
23:00:11 <johnw> a byte is 00-ff
23:00:47 <edwardk> adnap: 0..f encodes a nybble. a byte is 2 nybbles. utf-8 encodes a character as between 1-4 bytes
23:00:56 <adnap> Is the unicode encoding of 'f' one byte?
23:01:01 <dhrosa> adnap: yes
23:01:09 <dhrosa> adnap: ASCII characters under UTF-8 map to a single byte
23:01:12 <adnap> Right
23:01:16 <edwardk> he chacters for the symbols '0'..'f' are all representable with one byte though
23:01:43 <adnap> So, I want to convert each byte in the ByteString to the one-byte UTF-8 encoding of 0 through f
23:02:29 <edwardk> i can 't parse from your statement which inputs are hex strings
23:02:36 <edwardk> er input and/out output
23:03:02 <edwardk> so you want to spit out 2 output chars for each input byte?
23:04:44 <adnap> Okay, say the input is 0000 1000 1100 and the UTF-8 encoding of '0' is 1111 and the UTF-8 encoding of '8' is 0110. Then, the input is 0x080 in hex, and the UTF-8 encoding is 1111 0110 1111
23:05:01 <edwardk> > base 16 # 65
23:05:03 <lambdabot>  "41"
23:05:32 <adnap> "say" means "accept these completely made up encodings..."
23:06:13 <adnap> :t base
23:06:15 <lambdabot> (Integral a, Applicative f, Choice p) => Int -> p a (f a) -> p String (f String)
23:06:47 <edwardk> > "hello"^..folded.from enum.re (base 16)
23:06:48 <lambdabot>  ["68","65","6c","6c","6f"]
23:07:11 <edwardk> smash together and season to taste
23:07:15 <adnap> I'm confused
23:07:29 <adnap> The type of the function should be ByteString -> ByteString
23:07:51 <johnw> adnap: is this what you want?  http://hackage.haskell.org/package/hex-0.1.2/docs/Data-Hex.html
23:08:09 <edwardk> > Data.ByteString.pack (Data.ByteString.pack "hello" ^..Data.ByteString.Lens.packedChars.from enum.re (base 16))
23:08:10 <lambdabot>  Not in scope: `Data.ByteString.pack'Not in scope: `Data.ByteString.pack'
23:08:14 <frx> @hoogle base
23:08:15 <lambdabot> Text.Html base :: String -> HtmlAttr
23:08:15 <lambdabot> Text.XHtml.Strict base :: String -> HtmlAttr
23:08:15 <lambdabot> Text.XHtml.Frameset base :: String -> HtmlAttr
23:08:21 <edwardk> i don't knw what is in scope on lambdabo
23:08:26 <adnap> johnw: Yeah, I think os
23:08:30 <adnap> *so
23:08:36 <edwardk> and you need to get it to fix te lengh of each hex code at 2 chars, etc.
23:08:42 <edwardk> so that is a partial solution
23:09:21 <adnap> I also found http://hackage.haskell.org/package/base16-bytestring-0.1.1.5/docs/Data-ByteString-Base16.html
23:10:00 <edwardk> someone, probably haasn pasted a concise version of what you want using lens here several months ago
23:10:08 <johnw> ok, I actually prefer base16-bytestring
23:10:12 <johnw> s/ok/oh yeah
23:10:14 <adnap> Well, I don't know how to use lens
23:10:36 <johnw> edwardk: isn't lens a rather heavyweight solution to this particular problem?
23:10:37 <adnap> And since all I need is a ByteString -> ByteString function, lens seems like overkill
23:10:44 <edwardk> :t Numeric.showIntAtBase
23:10:44 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
23:11:07 <edwardk> hint: lens is always overkill, but it also usually contains an answer
23:11:12 <edwardk> feel free to go off and find another way
23:11:12 <johnw> hahah
23:11:20 <edwardk> i'll stop trying to help =P
23:11:29 <johnw> @remember edwardk hint: lens is always overkill, but it also usually contains an answer
23:11:29 <lambdabot> It is stored.
23:12:08 <dhrosa> when haddock tells me that something has 14/15 coverage, how do I know what the uncovered item is?
23:12:24 <edwardk> dhrosa: by looking at all of the things. =/
23:12:59 <dhrosa> every function and data type I have is commented.. let's see if data constructors need it too
23:13:28 <edwardk> dhrosa: is the module itself commented?
23:13:28 <dhrosa> nope
23:13:38 <edwardk> -- | ...    module ...
23:13:51 <adnap> Data.ByteString.Base16.encode is wrong. It maps BS.pack [15] to "0f"
23:14:07 <dhrosa> edwardk: nope, that was it
23:14:08 <adnap> The output is always a multiple of 2
23:14:09 <dhrosa> thanks
23:14:15 <adnap> *output length
23:14:39 <edwardk> adnap: yes, because it is an integral number of bytes. each nybble in a byte becomes a char in your output string, each byte cntains two nybbles.
23:16:26 <adnap> I see
23:17:44 <edwardk> > ("0123456789abcdef" !!) <$> [1,2,3,4,3]
23:17:45 <lambdabot>  "12343"
23:18:05 <adnap> I am a bit confused by this spec then.
23:18:14 <johnw> what does the spec say?
23:19:39 <adnap> http://www.bittorrent.org/beps/bep_0003.html All strings in a .torrent file that contains text must be UTF-8 encoded. pieces maps to a string whose length is a multiple of 20. It is to be subdivided into strings of length 20, each of which is the SHA1 hash of the piece at the corresponding index.
23:20:04 <adnap> So, a SHA1 hash is 20 bytes, but I think its UTF-8 encoding would be 40 bytes.
23:20:16 <adnap> If represented in hex.
23:20:21 <dhrosa> when I generate documentation using "cabal haddock", it complains "The documentation for the following packages are not installed. No
23:20:39 <dhrosa> and of course the generated docs don't link to the correct thing, how can I fix this?
23:21:37 <dhrosa> the packages that i'm using are network and colour, which do have docs
23:23:32 <adnap> Oh, I guess 0000 through 1111 are all valid UTF-8 code points
23:23:48 <adnap> So a SHA1 hash can be decoded as UTF-8
23:24:24 <lightquake> it can, but why would you?
23:24:43 <adnap> lightquake: Did you see the spec I just quoted?
23:24:59 <lightquake> ... wait, no it can't, because a SHA1 has can be an arbitrary value which might be invalid UTF-8.
23:25:42 <lightquake> adnap: yes, so it sounds like `pieces` is going to be a list of strings, each of which will be 20 characters long
23:25:54 <adnap> Oh, I keep mixing up 8 and 4 bits
23:26:07 <lightquake> i.e., 0123456789abcdef1234
23:26:07 <adnap> So, there are bytestrings that are not valid UTF-8 code points?
23:26:20 <joelteon> sure
23:26:37 <adnap> If the strings are SHA1 hashes, they are 20 bytes
23:26:50 <adnap> But it also says that strings have to be UTF-8 encoded
23:26:54 <adnap> So, I'm confused
23:26:54 <edwardk> adnap: yes
23:26:58 * hackagebot hslogstash 0.3.6 - A library to work with, or as, a logstash server  http://hackage.haskell.org/package/hslogstash-0.3.6 (SimonMarechal)
23:27:06 <joelteon> only the first 127 bytes are characters on their own
23:27:15 <joelteon> the rest are part of multibyte chars
23:27:17 <lightquake> adnap: they're string representations of the SHA1 hashes
23:27:20 <joelteon> in UTF8
23:27:31 <adnap> Like "0fea0
23:27:32 <lightquake> in much the same way that the string "255" is 3 bytes long even though 255 < 2^8
23:27:33 <adnap> ?
23:27:44 <adnap> I thought so, but then the string length would be 40
23:27:59 <adnap> Because each byte is two characters in UTF-8
23:28:16 <adnap> e.g. 0000 1111 is "0f"
23:28:32 <lightquake> ... wait, you're right, it looks like it might just be a sequence of bytes
23:28:48 <lightquake> let me just actually look at a torrent file
23:28:55 <adnap> But if it's just a sequence of bytes, then some bytes could be invalid UTF-8
23:29:01 <adnap> ...code points
23:29:09 <lightquake> right
23:29:14 <lightquake> so don't interpret it as utf-8
23:29:28 <adnap> The spec says all strings must be UTF-8
23:29:44 <lightquake> no, all strings *that contain text* are utf-8
23:29:53 <adnap> No, all .torrent files "that contain text"
23:30:11 <adnap> OMG
23:30:12 <adnap> I see
23:30:19 <adnap> I interpreted the sentence wrong
23:30:38 <adnap> "that contain text" is modifying "strings" and not ".torrent file"
23:30:47 <adnap> ....in "
23:30:48 <adnap> All strings in a .torrent file that contains text must be UTF-8 encoded."
23:31:06 <adnap> D:
23:31:06 <lightquake> in fact i just picked some random torrent file and ran it through xxd; the values in 'pieces' are in fact bytes
23:31:20 <lightquake> not encoded
23:31:21 <adnap> What is xxd? I need to learn how to do this
23:31:26 <lightquake> so you'll want to store that as a ByteString
23:31:42 <adnap> Oh, I have this program
23:31:43 <lightquake> or, a list of ByteStrings
23:31:51 <adnap> lightquake: Thanks, I get it
23:31:54 <lightquake> xxd is a unix utility for hex dumping
23:32:22 <edwardk> xxd = successor to od?
23:32:26 <adnap> Oh, I remember I use hexdump
23:32:33 <adnap> But I also seem to have xxd
23:32:57 <lightquake> edwardk: not sure, I just use xxd because by default it shows the original as well
23:33:04 <lightquake> with nonprintable characters replaced with .
23:33:05 <edwardk> fair
23:33:23 <adnap> I don't use these programs very much though, so I'm not comfortable with them. I remember being confused once by the ordering of the output
23:33:32 <jrw> based on man page copyright dates, od looks more (recently) maintained.
23:34:04 <lightquake> probably
23:34:22 <lightquake> i don't hexdump enough to care :)
23:34:31 <jrw> nor does it matter :)
23:35:38 <adnap> What is there to maintain? XD
23:35:50 <edwardk> od is an old standard
23:36:26 <adnap> edwardk: Do you know if anyone is writing a Lens book?
23:36:39 <edwardk> adnap: not off hand
23:36:44 <lightquake> new and exciting research in the field of hexdump theory shows that there are actually 25*7* possible 8-bit values
23:36:55 <adnap> lol
23:37:12 <lightquake> is there enough to say about lens to write a book?
23:37:19 <adnap> The package, yes
23:37:51 <edwardk> there was talk about writing a book on bidirectional transformations at the bx workshop at the beginning of december
23:38:05 <adnap> Anyway, books don't have to be a certain length. I just want a resource that explains the entire package, so I don't have to read a bunch of separate blog posts or watch videos
23:38:11 <edwardk> but lenses are just one tool in that toolbox
23:38:40 <edwardk> you're in luck, we have such a book. you can run cabal haddock ;)
23:39:04 <lightquake> a Control.Lens.Tutorial would be a good idea, i think
23:39:07 <adnap> I watched Simon's video on Lens. That helped the most, and contains about all I know about lens
23:39:10 <lightquake> pipes has Pipes.Tutorial and it's incredibly nice
23:39:19 <edwardk> a copy of this monolithic tome is available for your perusal, with index at hackage.haskell.org/package/lens
23:39:33 <adnap> edwardk: The type signatures are confusing
23:39:57 <lightquake> that reminds me, i need to work more on my type simplifier
23:40:10 <edwardk> lightquake: i'm not a huge fan of cluttering packages with modules like that, you get a bunch of data types that have no purpose in every executable for all time. we have a large set of examples in the lens install already
23:40:22 <edwardk> adnap: that is kind of the price of admission with lens
23:40:26 <adnap> I tried to read it, and I had to hop around to find out things like (->) is a Profunctor
23:40:41 <adnap> All the signatures have very general types
23:40:44 <edwardk> the alternative is that the package just flat won't work for many usecases and you'd be force to stop and rewrite everything without lens
23:41:04 <lightquake> edwardk: Pipes.Tutorial is just a bunch of comments, there's no actual code
23:41:36 <edwardk> lens chooses to favor remaining usable when your problem gets more complicated over approchability
23:41:56 <lightquake> plus there's value in having a good obvious starting point; if i want to get started with lens it's not obvious to me where to look.
23:42:13 <edwardk> lightquake: if you want to work on improving Control.Lens to include a bigger tutorial component, i'm all ears
23:42:14 <enthropy> @hackage lens
23:42:14 <lambdabot> http://hackage.haskell.org/package/lens
23:42:28 <lightquake> edwardk: the problem is I don't know if I know enough about it to do so
23:42:32 <enthropy> there's lots of explanation there of where to start
23:42:47 <edwardk> lightquake: learn, write something, solicit more help
23:43:05 <edwardk> tere is also a brief starting tutorial on lens.github.io
23:43:34 <lightquake> it's funny how that website format makes me immediately assume i'm being sold something
23:43:41 <edwardk> and one in the README, and one in where enthropy linked, and a onger one in Control.Lens, and more material on the wiki, so there is a lot of starting material you can gather
23:43:51 <adnap> edwardk: I remember a part of the doc that makes the signatures more specific in comments above or below the real type signature.
23:44:02 <edwardk> bootstrap has taken on that 'tone'
23:44:12 <lightquake> yeah, i definitely like the simplified type signature part of the docs
23:44:13 * enthropy found those "simpler type signatures" very helpful
23:44:19 <adnap> edwardk: But, as an example, "over" does not have one
23:44:21 <edwardk> adnap; yes, we do that to try to make them a bit more accessible
23:44:58 <edwardk> adnap: put issues in the bug tracker or submit patches. we're happy to work on improving docs when we know there is a problem
23:45:04 <lightquake> i wish the simpler type signatures could also show up in the error message, but obviously it's not really possible to do that without adding features to ghc
23:45:08 <adnap> So, my ideal book/resource would explain as much of the lens package as possible with less general type signatures
23:45:31 <adnap> Like Simon does in his video
23:45:50 <edwardk> i'm more inclined to write something that helps bring the audience up to fully understanding the real type signatures
23:45:52 <enthropy> maybe that can be a \bot plugin
23:46:01 <edwardk> but that is my personal bent
23:46:07 <edwardk> simon is much better at community outreach
23:46:13 <edwardk> but i really don't like lying about types ;)
23:46:28 <lightquake> enthropy: right, that's the thing i'm sort-of hacking on: given a type, and a bunch of type synonyms, find the 'simplest' version of that type
23:46:30 <adnap> edwardk: How can I understand the real type signatures without understanding things like Profuctors and other math concepts?
23:46:58 <lightquake> though 'simplest' is obviously not well-defined so perhaps 'find a simpler version' is better.
23:47:12 <edwardk> perhaps a better question is why are you afraid of learning what a profunctor is? it comes down to one function signature
23:47:22 <adnap> edwardk: I did try to learn what it was
23:47:26 <edwardk> :t dimap
23:47:27 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
23:47:34 <adnap> I had to go to different blog posts
23:47:43 <adnap> I think one was sigfpe's or something
23:47:51 <adnap> Whatever his name is
23:47:57 <adnap> It was pretty hard
23:48:05 <edwardk> that is a profunctor. in all its glory. it's a suped-up fmap
23:48:35 <edwardk> er suped-up functor
23:48:43 <adnap> Well, I would also like a resource that explains the real types
23:48:43 <edwardk> which offers a suped up fmap
23:48:48 <adnap> Jsut something that starts from scratch
23:49:17 <edwardk> https://github.com/ekmett/lens/wiki/Derivation
23:49:27 <edwardk> that starts from scratch and tries to motivate the structure of lens
23:49:57 <adnap> Not quite. "From here, we'll assume that you are acquainted with the types for Functor, Foldable and Traversable and can at least hand-wave the laws for them (see Typeclassopedia)."
23:50:19 <dsrx> typeclassopedia is a great resource
23:50:19 <edwardk> i have to start somewhere
23:50:35 <edwardk> and the typeclassopedia is pretty accessible. byorgey is a better writer than i am
23:50:39 <adnap> Well, I'll try that
23:51:18 <joejev> I tried hoogle, but is there a common, existing function :: ((a -> b,a -> b)) -> (a,a) -> (b,b)
23:51:20 <speckle> hello :) is leksah up to date with haskell at the moment, or should I just go with emacs/vim plugins?
23:51:22 <adnap> I just searched "Derivation" for Profunctor and didn't see anything, so I guess this page isn't comprehensive
23:51:28 <edwardk> foldable/traversable are about on par with monad in terms of generality and "being part of the culture"
23:51:49 <edwardk> adnap: that page doesn't get that far. it predates profunctors even being used in lens
23:52:02 <adnap> edwardk: Okay, so it's not what I want
23:52:13 <edwardk> that page is more in line with a amped up version of SPJ's talk
23:52:23 <adnap> I'm prepared to wait until there is a single resource that explains the whole package
23:52:42 <adnap> Because I can't figure it out by reading the documentation
23:55:33 <edwardk> you may be waiting a long time. there are a lot of parts to lens, and t doesn't all fit into one narrative very well, at the same level of accessibility ;)
23:56:55 <edwardk> as shachaf said at one point, the problem with getting to the bottom of lens is there is still a group of us down there at the bottom, digging ;)
23:57:47 <adnap> Well, I only want to learn it for fun. If it's not fun to learn right now because I can't put together the information from so many sources, I'll wait until it is or die first.
