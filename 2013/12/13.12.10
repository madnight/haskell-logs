00:04:10 * hackagebot instrument-chord 0.1.0.3 - Render Instrument Chords  http://hackage.haskell.org/package/instrument-chord-0.1.0.3 (AlanHawkins)
00:04:12 * hackagebot hspec-expectations-lens 0.1.0.0 - Hspec expectations for the lens stuff  http://hackage.haskell.org/package/hspec-expectations-lens-0.1.0.0 (MatveyAksenov)
00:22:51 <Skola> Cale my nacci function wasn't even correct, as it discarded the first q terms
00:27:08 <rtpg> wait, if Kleisli Arrows are arrows, then we can use proc notation in monads?
00:28:59 <Saizan> if you want, do-notation is nicer though
00:29:28 <cwraith> also, you use proc notation with kleisli arrows, which are wrappers around the monad.
00:29:44 <c_wraith> The difference is a bunch of extra newtype wrappers everywhere
00:31:15 <drbean> What is the _ pattern called? Throw-away wild-card?
00:32:26 <AshyIsMe> wildcard i think
00:32:39 <AshyIsMe> don't take my word for it though
00:36:16 <Cale> Yeah, it's called wildcard in the report.
00:37:32 <moop> so, why can't i do something like "doubleMe x = x + x" in ghci, but can do it by writing that in a file and then loading it in ghci?
00:37:54 <scott_> You can do "let doubleMe x = x + x" in ghci
00:37:54 <arkeet> because ghci syntax for defining things is different.
00:37:57 <arkeet> â†‘
00:38:30 <arkeet> pretend a ghci session is inside a big do block in IO
00:38:33 <kini> to be more precise, when you're typing in ghci you're typing in a do block
00:38:36 <kini> right
00:38:44 <arkeet> not precisely, but yes
00:39:18 <moop> oh
00:42:02 <moop> arkeet: so, what you mean, is that you can't define a function in a fuction without the 'let' keyword
00:42:18 <arkeet> in a function?
00:42:22 <arkeet> nothing's "in a function" here
00:42:54 <zett_zelett> do block â‰  function
00:43:02 <moop> er, sorry :D
00:43:03 <arkeet> you have to use let for the same reason you have to use let in:
00:43:10 <arkeet> main = do
00:43:10 <arkeet>   let doubleMe x = x + x
00:43:10 <arkeet>   ...
00:43:42 <moop> i see, i see
00:43:44 <shachaf> arkeet: But ghci isn't a do block!
00:43:50 <arkeet> I said "pretend"
00:43:59 <shachaf> If I can write "data T = T" why can't I write "x = 5"?
00:44:12 <shachaf> I mean: Is there a good reason to disallow it?
00:44:12 <arkeet> that's why pretending only goes so far.
00:44:37 <zett_zelett> On that topic: How can one define functions within a hugs session?
00:44:52 <shachaf> ^Dapt-get install ghc^M
00:45:12 <shachaf> (Or is that ^J?)
00:45:32 <zett_zelett> You canâ€™t?
00:45:35 <zett_zelett> Seriously?
00:46:28 <shachaf> Not that I know of. But there is little reason to be using Hugs anyway.
00:49:09 <Cale> zett_zelett: I still remember when you couldn't do it in ghci either.
00:49:32 <Cale> Normally when you're playing around with GHCi, you want to have a text editor open in a second window
00:49:50 <Cale> Each time you save, you just tap :r and it reloads your file
00:50:11 <moop> Cale: nice nice, ty
00:51:36 <arkeet> I thought hugs let you define things, without using let.
00:51:38 <arkeet> but don't use hugs.
00:52:49 <scott_> It's fun defining instances by "following the types"… I just defined Functor and Monad instances for Cont and I don't even understand the definitions I came up with yet :)
00:52:57 <johnw> haha
00:53:04 <johnw> been there before
00:54:06 <johnw> one fun thing to do is to assume you don't need the Cont newtype wrapper, and then watch how the instance simplifies
00:54:41 <zett_zelett> I may need to use hugs because they said we should use it in our course (and yes, we are doing Haskell in our course â€“ awesome!).
00:55:02 <zett_zelett> And by course I mean lecture in computer science.
00:56:53 <Cale> It's a bit weird for them to still be using hugs...
00:57:19 <Iceland_jack> Exactly
01:07:01 <yesthisisuser> One thing that is confusing is that the term "type declaration" is used.. sometimes for "type signature" .. and sometimes to mean a data definition
01:07:25 <arkeet> I've never heard the term "type declaration" before, I think.
01:07:47 <kini> I have, but only to refer to type signatures
01:07:57 <kini> data definitions are type definitions not type declarations
01:08:10 <kini> (though really you should just call them data definitions)
01:08:15 <yesthisisuser> http://en.wikibooks.org/wiki/Haskell/Type_declarations
01:08:35 <kini> haha, well then :)
01:08:43 <yesthisisuser> "A type declaration like this has two effects"
01:08:53 <yesthisisuser> so here it is used to mean data declaration
01:09:01 <yesthisisuser> but in other contexts
01:09:02 <kini> yup, I haven't read this wikibook
01:09:05 <kini> you're right
01:09:38 <yesthisisuser> then i found myself using it as synonymous with "type signature"
01:09:48 <yesthisisuser> and thought.. hmmm.. wait a minute
01:09:57 <yesthisisuser> what does it really mean..
01:10:15 <arkeet> solution: don't use it
01:10:15 <yesthisisuser> so maybe it should be avoided.. it is probably better
01:10:19 <yesthisisuser> yes .. agreed
01:10:29 <yesthisisuser> its better to say "type signature" for that
01:11:22 <yesthisisuser> and data constructor or value constructor
01:11:37 <yesthisisuser> so i guess that problem solved.. hehe
01:14:02 <yesthisisuser> then, the other thing that still annoys me is the lack of proper terminology for "undefined" and similar ""definitions"" that still appear under the name "Miscellaneous functions" in the Haskell documentation
01:15:10 <rtpg> when I install something via cabal, are the sources stored anywhere?
01:17:01 <helmut> hi. can I controll the location of ~/.cabal and ~/.ghc via environment variables?
01:20:29 <yesthisisuser> rtpg: in the cabal config file, there is an "install-dirs" directive.. the cabal config file is usually under ~/.cabal/config/ on Unix-like OS
01:24:20 * hackagebot shakespeare-css 1.0.6.6 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.6.6 (MichaelSnoyman)
01:31:21 <adimit> rtpg: alternatively, you could just use `cabal unpack`.
01:39:22 * hackagebot websockets 0.8.1.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.8.1.0 (JasperVanDerJeugt)
01:42:14 <identity> Is Data.Binary the de facto serialization library?
01:42:26 <identity> or would you guys recommend something better?
01:42:30 <johnw> some people prefer cereal, some binary
01:44:22 * hackagebot mega-sdist 0.2.10.3 - Handles uploading to Hackage from mega repos  http://hackage.haskell.org/package/mega-sdist-0.2.10.3 (MichaelSnoyman)
01:44:25 <identity> hmm
01:49:23 * hackagebot digestive-functors 0.6.1.1 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.6.1.1 (JasperVanDerJeugt)
01:49:25 * hackagebot digestive-functors-blaze 0.6.0.2 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.6.0.2 (JasperVanDerJeugt)
01:49:27 * hackagebot digestive-functors-happstack 0.6.0.1 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.6.0.1 (JasperVanDerJeugt)
01:49:29 * hackagebot digestive-functors-heist 0.8.3.0 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.8.3.0 (JasperVanDerJeugt)
01:49:31 * hackagebot digestive-functors-snap 0.6.0.1 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.6.0.1 (JasperVanDerJeugt)
01:54:24 * hackagebot websockets 0.8.1.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.8.1.1 (JasperVanDerJeugt)
02:02:22 <Yep> Hi, given the following code http://lpaste.net/96815 I get an error: bsrc - Expected type: Data.Conduit.Internal.Source Maybe (Flush Builder.Builder) Actual type: Data.Conduit.Internal.Source (ResourceT IO) (Flush Builder.Builder)
02:02:42 <Yep> any ideas where i've gone wrong :(?
02:07:30 <johnw> i don't think you want to return an action here
02:07:39 <johnw> your "do" block is a Maybe block
02:07:53 <johnw> also, you shouldn't need CL.consume
02:08:00 <johnw> don't return bodyChunks
02:08:25 <johnw> just at the end run: bsrc $= builderToByteStringFlush $= CL.map fromChunk
02:08:29 <johnw> and return a Producer
02:08:40 <johnw> unless you really want to take conduit out of the loop
02:09:26 * hackagebot aws-sdk-xml-unordered 0.2 - The xml parser for aws-sdk  http://hackage.haskell.org/package/aws-sdk-xml-unordered-0.2 (ShoheiYasutake)
02:15:31 <Yep> johnw: thanks! I'm new to conduits so doing my best to use them based on prior code... I'll read up on conduits a little more. In my case I only need to use them to test a wai middleware module
02:24:32 <johnw> well, if you want reduce to a ByteString you can use Data.Conduit.Binary.sinkLbs
02:24:45 <johnw> if you really need it to be strict, you can then strictify the result
02:34:36 <t7> how do you understand a function you came up with that is only partially in your head?
02:35:05 <bezirg> hi hskll ppl
02:35:50 <bezirg> are MVars equivalent to Java&Scala futures?
02:39:00 <adimit> few things are equivalent between Java and Haskell.
02:44:27 <hvr> bezirg: aren't 'futures' single-assignment read-only storage locations?
02:44:30 * hackagebot persistent-template 1.2.0.6 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.2.0.6 (MichaelSnoyman)
02:44:32 * hackagebot path-pieces 0.1.3.1 - Components of paths.  http://hackage.haskell.org/package/path-pieces-0.1.3.1 (MichaelSnoyman)
02:44:34 * hackagebot warp-static 2.0.0.1 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-2.0.0.1 (MichaelSnoyman)
02:44:44 <johnw> when people say "futures', I think of Async, not MVar
02:45:06 <hvr> johnw: I think of IVars :-)
02:45:15 <johnw> i haven't used IVars yet
02:45:42 <hvr> http://hackage.haskell.org/package/ivar-simple  --  IVars are write-once (immutable) variables. They can be read, an operation that will block until a value was written to the variable. They can be written to exactly once.
02:45:44 <seanparsons> If I have a String "\u4354" and want to decode it into a Char, is there anything at all sensible for doing that which already exists?
02:46:30 <nooodl> if you're absolutely sure it'll always contain one Char maybe `head` does the trick?
02:46:46 <nooodl> or is the string "\\u4354" here
02:47:39 <hvr> johnw: ASync is more like IVar + IO-action to produce the value afaics
02:47:54 <seanparsons> Sorry that, not a literal String but one that contains those 6 characters.
02:52:43 <bezirg> i will check both Async and IVar, ty
02:54:16 <zol> I have realized why I find it so unintuitive to write point-free style. I always start writing my functions first by giving the function a name, and then declaring the arguments!
02:54:52 <zol> So after I am finished with the function, I don't bother thinking about how to turn it into point-free style. Now that I know what's wrong, I can fix it! :D
02:54:57 <rtpg> zol, pointfree style is only useful in certain cases I've found
02:55:19 <rtpg> Like when you're working with streams (lists) , the thought process lends itself well to pointfree
02:55:25 <johnw> i use pointfree all over the place
02:55:55 <johnw> it can be easier to read, although just as often the opposite is true too
02:56:14 <rtpg> I basically use pointfree where I'd use loops in imperitive
02:56:25 <rtpg> like "do this on all these objects"
02:56:44 <rtpg> composing two functions works pretty nicely too in point free
02:58:56 <johnw> i'm not sure that "pointfree or not pointfree" is a fully conscious decision either; one of the two usually just feels/looks better
02:59:09 <rtpg> agreed
02:59:26 <rtpg> just trying to say you shouldn't force pointfree on every function either
02:59:43 <johnw> right, that can get ridiculous fast
03:00:09 <zol> I believe they will deduct points on my exam if you don't answer in point-free style.
03:00:33 <rtpg> in that case, the questions will probably be pointfree friendly
03:01:21 <zol> rtpg: On the contrary, I believe they will be especially tricky and devious. :'(
03:02:20 <rtpg> is this a beginner's class?
03:02:25 <benj_> pointfree helps readability up to a point...
03:02:40 <zol> benj_: after that it just becomes pointless...
03:03:45 <zol> rtpg: What is your definition of beginner?
03:05:36 <rtpg> Are you still just doing stuff on lists? Are you doing a bunch of things in the IO monad? Are you playying with MVars?
03:05:47 <rtpg> Are you doing some fun type-level programming?
03:06:04 <zol> rtpg: Latest lecture was about par, pseq and seq.
03:06:19 <rtpg> sound like you're pretty far along then...
03:08:23 <zol> rtpg: Yeah, writing a simple parser for a made up language at the moment. I'm just feeling frustrated about some small things at the moment. Thanks for chiming in.
03:09:34 <rtpg> isn't there a backwards version of $?
03:12:44 <merijn_> rtpg: Control.Lens has (&)
03:12:47 <merijn_> :t (&)
03:12:48 <lambdabot> a -> (a -> b) -> b
03:12:56 <merijn_> But that requires a dependency on lens
03:13:51 <merijn_> zol: I usually start by writing functio names and type signatures, rather than argument names :)
03:14:00 <rtpg> +1
03:14:08 <rtpg> writing the types make it a lot easier
03:14:39 <rtpg> plus with haskell usually if you figure out a function of the right type it usually does the right thing (especially in monads)
03:14:40 <merijn_> Then I start by composing my named (but unimplemented) functions to write the rest
03:15:26 <zol> merijn_: I do that first too, and then the function name again and the name for the arguments -- guess I should stop to think after the type signature what the most appropriate way of implementing the function can be, and whether it should be PFS or not.
03:15:47 <eikke> TDD - Type Driven Development
03:16:11 <merijn> zol: I just write "foo = undefined" after every type :p
03:16:59 <zol> eikke: +1
03:17:00 <Eduard_Munteanu> Is this a known lens? foo :: (Functor f) => Lens' a s -> Iso (s -> f s) s (a -> f a) a;  foo s = iso (s %%~) (^. s)
03:19:35 * hackagebot hoogle 4.2.26 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.26 (NeilMitchell)
03:19:48 <Eduard_Munteanu> It's meant to transform functions on a substructure to functions on the respective substructure's container.
03:21:05 <Flonk> Does nubBy assume that its argument is commutative?
03:21:17 <merijn> :t nubBy
03:21:18 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
03:21:30 <merijn> Flonk: Good question, no clue :)
03:21:51 <Flonk> merijn: I'll dig through the source, then :P
03:21:59 <Eduard_Munteanu> Flonk: it has to, if it's equivalent to nub with Eq.
03:22:32 <Eduard_Munteanu> Because that argument should be an equivalence relation.
03:22:42 <Flonk> Eduard_Munteanu: Good point
03:24:57 <Eduard_Munteanu> Hm, I think that iso should be a lens.
03:25:28 <Eduard_Munteanu> Because it loses information when going from (a -> f a) to (s -> f s).
03:27:11 <dv-> is there any TH magic that will look at a json file and generate the haskell data types to parse it into?
03:28:06 <merijn> dv-: Dunno if that exists, but you can easily write it
03:28:16 <merijn> dv-: Since you can execute arbitrary haskell code i TH
03:35:24 <dv-> Couldn't match type `ByteString' with `ByteString'
03:35:25 <dv-> hm
03:36:07 <identity> dv-: lazy bytestring vs strict bytestring possibly?
03:36:07 <Eduard_Munteanu> dv-: there are about 4 kinds of bytestrings
03:36:10 <Arjunax> I seem to not understand scoping! Please help me understand why this fails:
03:36:11 <Arjunax> test bar = let bar' = bar - 1 in
03:36:12 <Arjunax>   foo where
03:36:12 <Arjunax>     foo = bar'
03:36:35 <identity> Arjunax: the bar' only exists after "in .. "
03:36:55 <identity> oh, i see
03:37:17 <identity> i'm not sure why that doesn't work or if it's supposed to work
03:37:29 <bartavelle> is haskell reddit subforum broken, or is there a reason why my post isn't showing after an hour ?
03:37:38 <Eduard_Munteanu> Arjunax: where attaches to the declaration of test
03:38:08 <identity> bartavelle: what is your username?
03:38:14 <bartavelle> bartavelle
03:38:19 <bartavelle> identity, http://www.reddit.com/r/haskell/comments/1sjcox/running_arbitrary_computations_in_a_specific/
03:38:41 <Arjunax> Eduard_Munteanu: thanks, but how is it possible to make the things from let available within a later where "block"?
03:38:53 <identity> bartavelle: in reality, the whole of reddit's rating system is fundamentally flawed as explained by an article recently posted to /r/programming
03:38:56 <identity> which might be the cause of it
03:39:27 <bartavelle> bleh, I'll never get an answer then :(
03:39:34 <identity> bartavelle: which may be what happened to yoru post
03:39:41 <identity> but it doesn't seem to have received a downvote
03:39:57 <Eduard_Munteanu> > let foo = { let bar = 5 in baz where baz = bar } in foo
03:39:59 <lambdabot>  <hint>:1:11: parse error on input `{'
03:40:19 <Eduard_Munteanu> > let foo = do { let bar = 5 in baz where baz = bar } in foo
03:40:20 <lambdabot>  <hint>:1:35: parse error on input `where'
03:40:44 <Arjunax> wow thanks Eduard_Munteanu, I'll try that
03:40:52 <Eduard_Munteanu> > let foo = do let bar = 5 in { baz where baz = bar } in foo
03:40:53 <lambdabot>  <hint>:1:29: parse error on input `{'
03:40:56 <Eduard_Munteanu> Argh.
03:41:01 <Eduard_Munteanu> > let foo = do let bar = 5 in do { baz where baz = bar } in foo
03:41:02 <lambdabot>  <hint>:1:38: parse error on input `where'
03:41:12 <Arjunax> ok
03:41:17 <Eduard_Munteanu> Wait, nevermind, that can't work.
03:41:42 <Arjunax> kk, I'll wait, very thankful for your help
03:41:54 <Arjunax> or isn't there a way?
03:41:57 <identity> bartavelle: as there is clearly something silly going on here, I would go ahead an repost it
03:42:16 <identity> bartavelle: since it is literally possible for threads to disappear into some blackhole of nothingness
03:42:24 <identity> your thread isn't under new either or anything
03:42:53 <bartavelle> isn't it more suitable for stackoverflow anyway ?
03:43:00 <Eduard_Munteanu> Arjunax: ah, it's a lambdabot issue... try using { } around your entire let .. in .. where ..
03:43:06 <identity> bartavelle: probably aye
03:43:21 <bartavelle> thanks for looking at this, will post on SO
03:43:25 <identity> np
03:43:47 <Arjunax> like so?
03:43:48 <Arjunax> test bar = {let baz = bar - 1 in
03:43:48 <Arjunax>   foo where
03:43:48 <Arjunax>     foo = baz}
03:44:10 <Arjunax> because that doesn't work
03:44:25 <Eduard_Munteanu> Arjunax: that should be 'where bar = ...' no?
03:44:41 <Arjunax> no
03:45:01 <Eduard_Munteanu> Oh, I misread.
03:45:22 <Eduard_Munteanu> Arjunax: what error does it throw out?
03:45:58 <Eduard_Munteanu> Arjunax: you probably need a 'do' before '{'
03:46:04 <Arjunax> with the {} like that it says " parse error on input `{'"
03:46:08 <Arjunax> ok
03:46:37 <Arjunax> http://pastebin.com/c0YQ6Lue thats the code btw
03:46:39 <mauke> The paste c0YQ6Lue has been copied to http://lpaste.net/96821
03:48:49 <Eduard_Munteanu> Arjunax: that still attaches to test I think
03:49:39 <Arjunax> I guess you're right but how can I get it to work
03:52:41 <Arjunax> I thought it was trivial and because of that didn't open a stackoverflow question, but it seems like it is not, so I might go ahead and open a question
03:53:47 <moop> oh, cool, haskell has pipes
03:54:23 <Eduard_Munteanu> Arjunax: try braces like I said
03:54:38 <Eduard_Munteanu> moop: what sort of pipes?
03:57:53 <mr-> the dot? ;-)
03:59:07 <Cale> Arjunax: What was your question?
04:00:35 <Cale> Arjunax: Why baz isn't in scope in the where clause for test?
04:01:38 <Arjunax> yes
04:01:45 <Cale> Arjunax: That would be because it's defined by the let expression on the right of the = sign. The where clause is not part of that expression, it's part of the declaration of 'test'. One property that this allows is that where clauses scope over multiple guards
04:01:56 <Cale> e.g. if you have
04:02:05 <Cale> foo x | x < y = ...
04:02:13 <Cale>       | x > y = ...
04:02:19 <Cale>       | x == y = ...
04:02:23 <Cale>   where y = ...
04:02:45 <Cale> y is bound in all the guards which are to the left of the = signs
04:02:56 <Cale> (as well as on the right hand side of all those equations)
04:03:05 <Arjunax> okay
04:03:12 <Arjunax> so that's beacuse of the let?
04:03:20 <zett_zelett> Why is this not a strict function? let or' :: Bool -> Bool -> Bool; or' = ($!) (||)
04:03:28 <Arjunax> Cale: and how do I get it to work
04:03:43 <Cale> Well, the things bound by a let are only in scope in the expression following the 'in'
04:03:52 <moop> Eduard_Munteanu the |
04:03:55 <zett_zelett> I don't get it, I thought I told Haskell to evaluate (||) strictly, by concatenating with ($!)?
04:04:01 <Cale> (and the where clause, no matter how you've layed it out, is not part of that expression)
04:04:03 <zett_zelett> composing*
04:04:31 <Cale> (||) evaluates its *first* argument in any case
04:04:59 <Cale> i.e. in technical terms, (||) really is a strict function. It just sometimes produces one which isn't strict.
04:05:48 <Arjunax> okay, so there is no convenient way to get this working?!
04:06:06 <Cale> http://lpaste.net/96821
04:06:13 <zett_zelett> Cale: So, how would I get a real non-strict version and a real strict-version of (||)?
04:06:16 <Cale> You could write it like my annotation there
04:06:24 <Cale> or:
04:06:34 <Arjunax> ahh okay
04:06:37 <moop> so, what does darcs offer that git doesnt have?
04:06:42 <Arjunax> so the problem is the mixing of let and where
04:06:52 <zett_zelett> Like or' âŠ¥ _ = âŠ¥, or' _ âŠ¥ = âŠ¥ and or'' âŠ¥ True = True and or'' True âŠ¥ = True?
04:07:05 <Cale> http://lpaste.net/96821 like my second annotation
04:07:22 <Eduard_Munteanu> moop: reordering patches based on dependencies
04:07:24 <Cale> Arjunax: You mixed them the wrong way around, the stuff in the where clause will be in scope in the let
04:07:44 <Arjunax> okay
04:07:51 <Cale> Arjunax: The where clause is part of the entire *declaration*, while the (let ... in ...) is an *expression*
04:08:17 <Eduard_Munteanu> Cale: it should be possible to force it to bind to the let though, no?
04:08:41 <Arjunax> okay, I got it
04:08:49 <Cale> Eduard_Munteanu: What do you mean by that? The declarations inside the let can have their own where clauses
04:08:52 <Arjunax> Well thank you guys very much! :identity, Eduard_Munteanu and Cale
04:08:55 <Arjunax> big time ;)
04:09:02 <moop> Eduard_Munteanu but, aren't dependencies linear? patch a comes with dependancy a, patch b with dep b, patch c...
04:09:06 <Cale> But the expression in the 'in' part can't because 'where' is not an expression form.
04:10:33 <Cale> zett_zelett: The second one you "can't" -- at least not without something unsafe. For the first, the easiest way is just to pattern match on both arguments
04:10:35 <Eduard_Munteanu> Cale: binding to the declaration bit... but I'm unsure, would it work before or after the 'in ...' part?
04:11:14 <Eduard_Munteanu> > let foo = bar where bar = 3 in foo
04:11:15 <zett_zelett> Cale: Okay, that makes sense.
04:11:16 <lambdabot>  3
04:11:19 <zett_zelett> Thanks!
04:11:19 <Eduard_Munteanu> Hm.
04:11:24 <Cale> Eduard_Munteanu: before
04:11:39 <Eduard_Munteanu> > let foo = bar { in foo } where bar = 3
04:11:40 <lambdabot>  <hint>:1:17: parse error on input `in'
04:12:07 <Cale> > let { foo = bar where { bar = 3 } } in foo
04:12:09 <lambdabot>  3
04:12:11 <Eduard_Munteanu> That's record syntax.
04:12:28 <Cale> Yours was, yes (until the 'in')
04:12:29 <Eduard_Munteanu> > let foo = bar in { foo } where bar = 3
04:12:30 <lambdabot>  <hint>:1:18: parse error on input `{'
04:12:46 <Eduard_Munteanu> I see, so it can't really work after the in ..
04:44:46 * hackagebot warp 2.0.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.0.1 (KazuYamamoto)
04:47:30 <zett_zelett> Canâ€™t you use â€˜whereâ€™ in lamdba expressions?
04:48:24 <int-e> not directly.
04:48:46 <int-e> > (\x -> let a = b where b = x in a) 42
04:48:48 <lambdabot>  42
04:50:26 <int-e> zett_zelett: 'where' is part of the function binding syntax.  foo ...patterns... | guard0 = ...x... | guard1 = ...y... where x = ...; y = ...
04:58:09 <zett_zelett> I donâ€™t know what the function binding syntax is, yet. But many thanks for your answer.
05:04:48 * hackagebot io-streams 1.1.2.2 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.2.2 (GregoryCollins)
05:20:21 <t7> @hoogle (a, b) -> ([a], [b])
05:20:22 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
05:20:22 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
05:29:51 * hackagebot graceful 0.1.1.2 - Library to write graceful shutdown / upgrade service.  http://hackage.haskell.org/package/graceful-0.1.1.2 (NoriyukiOhkawa)
05:34:36 <reizuki> can I specify a temporary name for an expression inside function definition so I don't have to type it multiple times?
05:35:03 <Eduard_Munteanu> reizuki: yes sure, let / where
05:35:19 <Eduard_Munteanu> > let x = 5 in x + x
05:35:21 <lambdabot>  10
05:35:38 <alpounet> > 1+x where x = 4
05:35:39 <lambdabot>  <hint>:1:5: parse error on input `where'
05:36:01 <alpounet> always been annoyed by this not working but well
05:36:09 <Eduard_Munteanu> It used to, IIRC.
05:36:39 <Eduard_Munteanu> > let somevalue = 1 + x where x = 4 in somevalue
05:36:40 <lambdabot>  5
05:37:18 <alpounet> yeah you need the let
05:37:26 <alpounet> you can't use just where
05:38:04 <alpounet> don't worry it doesn't work in ghci either
05:38:49 <helmut> @pl f ((a, b), (c, d)) = ((a, c), (b, d))
05:38:49 <lambdabot> f = uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (,)))
05:39:39 <helmut> hmm. this probably crosses the border to obfuscation...
05:41:13 <alpounet> yeah, the readability police arrests people for less than that
05:41:13 <mr-> Nah, that's great
05:46:55 <tdammers> it does have a certain poetry to it
05:48:02 <tdammers> Uncurry! Uncurry! Flip flip second... ap... flip flip first! Dot-dot-dot, dot-comma; dot-flip-dot; dot dot comma dot, dot, comma.
05:48:09 <tdammers> almost a Haiku :P
05:49:54 * hackagebot graceful 0.1.1.3 - Library to write graceful shutdown / upgrade service.  http://hackage.haskell.org/package/graceful-0.1.1.3 (NoriyukiOhkawa)
05:50:48 <fjdddd> Could anyone help me to define MyStruct and Struct that are used in this example: http://www.haskell.org/haskellwiki/FFICookBook#Working_with_structs?  I can't make it work.
05:53:39 <int-e> tdammers: flips, uncurries and aps / with too much punctuation / that is point-free code
05:54:07 <int-e> I can't count, drop the 'and' :)
05:56:26 <fjdddd> merijn: Do you know how to define MyStruct and Struct which are used here: http://www.haskell.org/haskellwiki/FFICookBook#Working_with_structs?
05:57:38 <mauke> data Struct = MyStruct{ a :: CInt, b :: CChar, c :: CDouble }
05:58:33 <fjdddd> mauke: Indeed, thanks!
05:58:46 <fjdddd> Do you have an account on the wii?
05:58:50 <fjdddd> wiki*
05:59:38 <mauke> not on this pc
05:59:55 * hackagebot tasty-ant-xml 1.0.0.3 - Render tasty output to XML for Jenkins  http://hackage.haskell.org/package/tasty-ant-xml-1.0.0.3 (OliverCharles)
06:02:07 <fjdddd> mauke: Could you add that declaration later please?  I requested an account, but nominolo seems to be busy.
06:05:10 <fjdddd> Also, (MyStruct a, b, c) has to be changed to (MyStruct a b c).
06:07:19 <WJWH> how can i get hackage to display the haddock information for my packages?
06:08:47 <merijn> WJWH: They will be automatically build by a cron job, at some point
06:09:24 <merijn> WJWH: Unless your code uses C bindings that are not available on the hackage machine/otherwise does not compile on the hackage machine, in which case your haddocks will be broken indefinitely
06:09:54 <donri> i think they build on upload now
06:09:56 * hackagebot lifted-async 0.1.0.1 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.1.0.1 (MitsutoshiAoe)
06:10:14 <merijn> Anyway, things that don't build on hackage are still broken, sadly :(
06:10:45 <donri> you can upload docs that you built yourself though
06:10:53 <merijn> donri: Oh? How?
06:10:59 <merijn> Is this a hackage2.0 thing?
06:11:04 <donri> yes
06:11:16 <donri> http://hackage.haskell.org/api#documentation-core
06:12:47 <donri> i don't know more than that though, like, does it have to be haddocks, what directory structure, how does cross-linking work
06:13:38 <donri> you could use http://hackage.haskell.org/package/standalone-haddock though
06:15:00 <WJWH> I made two packages so far, one of them uses FFI bindings so that might cause it
06:15:16 <WJWH> the other one doesn't do anything fancy though
06:15:20 <asdf1234> so it turns out there's only one line left in ghc head that the clang cpp errors out on
06:26:27 <statusfa1led> Does there exist a DSL for building directed acyclic graphs? [D[D[D[D[D[D[D[D[D[D[D[D
06:27:05 <chrisdone> irssi user?
06:27:19 <ion> Thatâ€™s a good example of a directed acyclic graph.
06:27:27 <ion> > let cyclic = cycle "[D" in cyclic
06:27:28 <lambdabot>  "[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[D[...
06:27:39 <statusfa1led> ha, frozen terminal
06:27:55 <statusfa1led> chrisdone: how did you know?
06:27:58 <chrisdone> that's what she said
06:28:05 <chrisdone> statusfa1led: because irssi sucks like that =)
06:28:08 <statusfa1led> heh
06:30:55 <byorgey> statusfailed: not that I know of, but the techniques described in http://www.andres-loeh.de/ASGDSL/ASGDSL.pdf work very nicely for building DAGs
06:31:25 <byorgey> might be nice to build the sort of DSL you want based on those techniques
06:32:11 <byorgey> in fact you can build cycles too
06:32:45 <ij> Why does this happen? http://sprunge.us/TARJ
06:33:39 <byorgey> ij: could be a bytestring version mismatch
06:33:53 <byorgey> ij: do you have multiple versions of bytestring installed?  (You can check with  'ghc-pkg list bytestring')
06:34:37 <byorgey> seeing package version numbers in your type errors usually (though not always) indicates this sort of package version mismatch
06:35:13 <ij> Seems so. what can I do to fix that?
06:35:22 <Philonous_> Can someone explain why (lx <= uy && ly <= ux) || (ly <= ux && uy >= lx) would evaluate about 25% faster than just the left side (lx <= uy && ly <= ux) ?
06:36:17 <byorgey> ij: if the problem is simply GHCi picking up the wrong version, you can fix it by hiding one of them (ghc-pkg hide bytestring-0.10.2.0)
06:36:23 <Philonous_> ( all mentioned variables are chars )
06:36:23 <statusfailed> byorgey: thanks! ill take a look
06:37:25 <byorgey> ij: however, ideally you would uninstall all but one of them
06:37:38 <Philonous_> Heck, (lx <= uy && ly <= ux) || (lx <= uy && ly <= ux) (both sides of the || the same) is even faster O_o
06:37:48 <byorgey> ij: but if you have other packages built against both versions that may be difficult (but it might be the only way to solve the problem)
06:38:06 <byorgey> ij: you can try 'ghc-pkg unregister bytestring-0.10.2.0' and see what it says will break.
06:38:37 <asdf1234> Philonous_: I'd question the tests if that's the case
06:38:44 <byorgey> ij: worse comes to worst, you can nuke your user package DB (rm -rf ~/.ghc) and start over.
06:39:50 <Philonous_> asdf1234, I can reliably reproduce it.
06:40:18 <asdf1234> Philonous: fully compiled?
06:40:22 <byorgey> Philonous: magical GHC gnomes
06:40:37 <Philonous> asdf1234, Yes, -O2, measured with criterion
06:40:59 <byorgey> Philonous: the gnomes get lazy when you give them boring things to do, so it takes longer
06:41:00 <asdf1234> Philonous: how much faster is faster?
06:44:07 <Philonous> asdf1234, 8.6Âµs for the simple version 5.5Âµs with the redundant (||) for a series of 65 Set lookups
06:45:34 <asdf1234> Philonous: I dunno. At that scale, I don't know how much you can take away from a test ... maybe try looking at what ghc builds?
06:46:18 <Philonous> I'll try that
06:46:30 <asdf1234> what are the types for your functions?
06:47:09 <Philonous> chars
06:49:23 <rtpg> is there a place that explains what happens with unsafePerformIO?
06:49:38 <rtpg> does it get re-evaluated at every query?
06:50:58 <Feuerbach> rtpg: it's re-evaluated by the same rules as any other Haskell value. The only difference is that it performs IO every time it gets evaluated
06:51:58 <rtpg> Feuerbach, so it's evaluated every time it's queried?
06:52:08 <asdf1234> keyword being evaluated.. will ghc perform an action multiple times you escape the IO monad?
06:52:30 <Feuerbach> rtpg: what do you mean by "queried"?
06:52:59 <rtpg> as in: when the RTS checks whether it's in HF or not
06:53:27 <rtpg> I don't know the proper term, but if we look at how the STG works, when the closure for the value gets entered
06:55:47 <quchen> I don't think you have to look at the STG to understand this. Each unsafePerformIO is evaluated only once, but due to inlining or being repeatedly re-generated (e.g. f _ = unsafePerformIO ...) one mentioning of unsafePerformIO may appear in multiple places during evaluation.
06:58:00 <nogeddaf> hi there, does anyone know where I can find the definition of the class Constructor?
06:58:01 <Philonous> asdf1234, The effect remains when I increase the test size to 200k (distinct) lookups
06:58:14 <Philonous> I'll try to look at the output
06:58:40 <merijn> rtpg: Basically, GHC can decide to inline huge swaths of code, causing the unsafePerformIO to happen multiple times
06:58:59 <merijn> rtpg: And it's very hard to predict how GHC will inline/move code chunks
06:59:15 <quchen> nogeddaf: Do you have local documentation in ~/.cabal/share/doc? If yes you could just click on the index there and Ctrl+F in your browser
06:59:32 <quchen> (If Hoogle/Hayoo don't help, that is)
06:59:48 <nogeddaf> I tried Hoogle but without success :(
07:00:18 <Feuerbach> rtpg: no, the closure gets updated with the result of unsafePerformIO. So next time you "query" it no IO is performed
07:00:31 <merijn> ocharles: Small comment on your blog: It would be nice if the individual posts had a next/prev link for browsing through the 24 days of Hackage thing
07:00:59 <merijn> nogeddaf: Hoogle only indexes a subset of Hackage
07:01:10 <quchen> nogeddaf: What about :i Constructor in GHCi when the thing is loaded from somewhere?
07:01:18 <merijn> nogeddaf: If you enable Documentation in your cabal configuration it will install local documentation for all libraries you install
07:01:47 <nogeddaf> oh: that works!
07:01:51 <nogeddaf> cheers
07:04:30 <asdf1234> Philonous: the only thing I can see is that for the short expression, GHC looks up the ord function for char instead of using the primitive it should know it can use
07:04:46 <asdf1234> with -O2
07:05:14 <asdf1234> and only if the first case fails
07:05:57 <merijn> oh, if I can now upload documentation separately, does cabal have a way to do that for me or do I need to kludge something together using curl?
07:06:27 <merijn> Or has someone already wrote another program for that
07:07:08 <asdf1234> Philonous: additionally, the short function doesn't get auto-inlined because of the lookup
07:08:09 <srhb> > take 10 [10^6, 10^9 .. ]
07:08:10 <lambdabot>  [1000000,1000000000,1999000000,2998000000,3997000000,4996000000,5995000000,6...
07:08:15 <srhb> What's going on there?
07:08:51 <srhb> does it just subtract one from the other?
07:09:14 <srhb> Of course it does. herp
07:09:17 <geekosaur> it can't infer geenral sequences, only additive ones
07:09:26 <rtpg> srhb, it's taking steps of (10^9-10^6)
07:09:27 <statusfailed> srhb: makes you pause for a second though :D
07:09:52 <srhb> > take 10 $ map (10^) [6,9..]
07:09:53 <lambdabot>  [1000000,1000000000,1000000000000,1000000000000000,1000000000000000000,10000...
07:09:58 <srhb> I cannot brain.
07:10:03 <rtpg> technically , nothing could infer general sequences, as even sequences defined by polynomials are of infinite variety
07:14:12 <srhb> Has anyone tested if that effect works in an empty channel? Where you ask a stupid question and immediately realize why you're being dense? :-)
07:14:31 <srhb> Or is the potential embarassment a necessary component?
07:14:53 <rtpg> srhb, you're talking about the rubber duck effect
07:14:56 <quchen> srhb: Rubber duck debugging?
07:15:04 * hackagebot tasty 0.5 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.5 (RomanCheplyaka)
07:15:06 * hackagebot tasty-golden 2.2.0.1 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.2.0.1 (RomanCheplyaka)
07:15:11 <srhb> Oh really, it has a name? Haha.
07:15:30 <quchen> srhb: https://en.wikipedia.org/wiki/Rubber_duck_debugging
07:15:34 <srhb> Fantastic.
07:15:50 <nogeddaf> I met a guy once who had a physical rubber duck on his desk to talk to
07:16:24 <capisce> I've met that guy too
07:16:30 <nogeddaf> :)
07:16:47 <nogeddaf> did you ask him if it worked?
07:17:02 <capisce> no, I asked the duck
07:17:07 <nogeddaf> ha ha
07:17:20 <asdf1234> Philonous: yup, it gets propagated all the way down.. GHC looks up the compare function for the second <=
07:17:33 <bearclaw> we need a version with voice pattern analysis so that it could tell if you're bulls***ing it
07:17:45 <rtpg> on the unsafePerformIO thing : pastebin.com/cinZWw6A
07:18:09 <rtpg> if I load this into ghci, and I try to run h2, it reads 2 chars, only prints the first
07:18:18 <rtpg> and then the second call to h2 just prints the second character from the first call
07:19:43 <asdf1234> rtpg: why bother computing something twice when you know it has the same result? :)
07:20:04 <rtpg> basically, I'd like to figure out how I could "invoke" h many times to try and basically make cat
07:20:22 <asdf1234> rtpg: use the IO monad
07:20:32 <asdf1234> and don't performUnsafeIO
07:21:00 <asdf1234> GHC will optimize away all of those "unnecessary" side effects
07:21:31 <fjdddd> what's the best way to translate typedef enum foo {...} bar; to haskell?  should I simply define a product type?
07:21:56 <rtpg> asdf1234, this is for experimentation on some other stuff (with arrows), I'm not against using the IO monad
07:22:20 <Cale> rtpg: Add NOINLINE pragmas to everything
07:22:20 <asdf1234> rtpg: your problem is a result of GHC thinking your functions don't have side effects and so only need to be evaluated once
07:22:42 <giogadi> I just had the WEIRDEST runtime errors that for some reason the type system never caught
07:22:53 <asdf1234> rtpg: as for the IO monad, you still get that arrows
07:23:01 <asdf1234> rtpg: look into kleisli arrows
07:23:06 <Cale> Ugh
07:23:18 <Cale> Kleisli is such a bad Arrow instance though :P
07:23:27 <Cale> *especially* for IO
07:23:30 <Philonous> asdf1234, Did you just do the work for me? :>
07:23:42 <giogadi> I wanted to create a singleton priority queue (using pqueue) with an element whose key is the monoid identity, or mempty
07:23:46 <asdf1234> Philonous: maybe; could be wrong though
07:23:51 <Cale> It disobeys the property that (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k)
07:23:56 <giogadi> but I accidentally typed `mempty` (note the backticks)
07:24:06 <giogadi> and the compiler didn't complain at all
07:24:21 <Cale> which means that your Arrow code will do things which are insane and dependent on the actual way that you expressed the wiring
07:24:22 <giogadi> and instead the pqueue was just silently being created as an empty pqueue
07:24:31 <Philonous> asdf1234, If it was true it would be a bug though, wouldn't it?
07:24:36 <klrr_> is there any easy to use drawing library that is quite easy to "hook into" a existing game? currently using sdl1.2 bt encountering suvere bugs and i think both gloss and diagrams are too advanced for me (have not learnt about vectors in school yet)
07:24:51 <Cale> klrr_: Gloss is super simple
07:24:59 <klrr_> it is?
07:25:00 <asdf1234> Philonous: Dunno. There might be a reason for it. I don't have a deep enough understanding of it to know for sure.
07:25:01 <giogadi> so, if I have a function that takes no variables and add backticks (e.g. `Data.Monoid.mempty`) what exactly is happening?
07:25:12 <klrr_> Cale: well, will look into it again then :P
07:25:18 <Cale> klrr_: Yeah, in fact, maybe too simple :P
07:25:47 <klrr_> i only need to draw boxes really
07:25:57 <klrr_> could even be same colors
07:26:05 <Cale> Ah, in that case, you'll be fine :)
07:26:10 <FliPPeh> Is there something like a "Maybe IO.Handle" but not Maybe, simply an empty, invalid handle? The reason I'm asking is because when I need a handle in a State monad, for a connection with some data to it for example, I *have* to use maybe unless I do the connecting *before* I run that state which doesn't look good :(
07:26:14 <klrr_> well, thanks will look into it then
07:26:16 <dwcook> giogadi, give an example expression containing that
07:26:21 <dwcook> It's not valid all by itself
07:27:00 <giogadi> dwcook: Data.PQueue.Prio.Min.singleton `mempty` someValue
07:27:39 <giogadi> dwcook: it's weird isn't it?
07:28:14 <dp_wiz> Is it possible to get an UUID primary key in Persistent (instad of serial)?
07:28:14 <Flonk> Is there a way to find out when a file was last modified using Haskell?
07:28:37 <asdf1234> Flonk: try System.Directory
07:28:52 <Flonk> asdf1234: Thanks, I will!
07:28:56 <Cale> :t System.Directory.getModificationTime
07:28:57 <lambdabot> FilePath -> IO time-1.4.0.1:Data.Time.Clock.UTC.UTCTime
07:29:16 <dwcook> giogadi, not really. That's just infix application.
07:29:23 <Cale> heh, interesting that it shows the package qualifier
07:29:39 <dwcook> giogadi, it's the same as if you'd written: mempty Data.PQueue.Prio.Min.singleton someValue
07:29:41 <giogadi> dwcook: but why would it try to infix apply a function that takes no arguments?
07:29:45 <asdf1234> Cale: well the type isn't in scope :P
07:29:55 <dwcook> giogadi, there's no such thing as a function that takes no arguments. Every function takes one.
07:30:01 <FliPPeh> http://lpaste.net/96825 <- basically, how do I get rid of the "Maybe Handle" and have it just a Handle so I don't have to litter all my class functions with maybe?
07:30:01 <Flonk> Cale: Ah, perfect!
07:30:06 * hackagebot tasty 0.5.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.5.1 (RomanCheplyaka)
07:30:06 <dwcook> giogadi, anyway, mempty, depending on the instance, can be a function.
07:30:53 <asdf1234> hypothetically it doesn't make sense for a function to not have an argument
07:31:01 <asdf1234> just by definition of a function
07:31:02 <giogadi> dwcook: I'm not sure I follow. I was constraining the key type to be an instance of Monoid
07:31:05 <klrr_> Cale: is it possible to draw stuff in gloss without using one of its pre-defined loops?
07:31:17 <giogadi> dwcook: and according to Hoogle the only definition of mempty is mempty :: a
07:31:30 <dwcook> giogadi, yes, and some instances of monoid can define an mempty that's a function.
07:31:35 <dwcook> Oh, I see.
07:31:39 <dwcook> Yeah, that'd be too general.
07:31:49 <dwcook> If it were just any instance of Monoid.
07:31:58 <asdf1234> well, do we want to call a type constructor a function?
07:32:04 <dwcook> Try showing more of the code.
07:32:09 <giogadi> Ok, one moment
07:33:45 <Cale> klrr_: I don't think there is, which is a little sad. It would be nice if it gave you some lower level thing which just did the OpenGL rendering of a Picture.
07:33:48 <giogadi> http://lpaste.net/96826
07:33:58 <giogadi> dwcook: http://lpaste.net/96826
07:34:28 <giogadi> dwcook: the weirdest part is that I can simply remove the backticks and it compiles just as well, but actually works as intended
07:34:56 <mr-> Cale: I am sure a patch would be appreciated ;-)
07:34:58 <giogadi> dwcook: line 39 btw
07:35:08 * hackagebot tasty-ant-xml 1.0.0.4 - Render tasty output to XML for Jenkins  http://hackage.haskell.org/package/tasty-ant-xml-1.0.0.4 (OliverCharles)
07:35:50 <giogadi> dwcook: wait a minute, there's a small error. remove the 'q' from line 39
07:37:24 <asdf1234> Philonous: I'd be interested in seeing how this function compares: http://lpaste.net/96828
07:38:16 <asdf1234> Philonous: except I botched the order.. one sec
07:38:44 <giogadi> dwcook: OH I see that Monoid b => (a -> b) is also a Monoid instance
07:39:13 <dwcook> giogadi, ah, yep, you've figured it out
07:39:19 <giogadi> but
07:39:25 <giogadi> dwcook: doesn't it still feel wrong?
07:39:31 <dwcook> Not really
07:39:36 <giogadi> dwcook: I mean I haven't 100% uncovered why this is the case but I'm sure that instance is the cause
07:39:40 <dwcook> Like I said, mempty can be a function
07:39:46 <asdf1234> Philonous: should be ok now.. anyway, curious to see how this compares: http://lpaste.net/96828
07:40:00 <dwcook> In fact, that instance has to be the cause.
07:40:21 <dwcook> Because it's the only one for functions, and mempty *must* be a function as you use it there.
07:41:33 <giogadi> dwcook: I guess I'm still unsettled by the behaviour of backticking a non-binary function
07:42:01 <dwcook> giogadi, it's constrained to be one by the way you're using it.
07:42:28 <asdf1234> I had no idea you could backtick a non-binary function
07:42:39 <giogadi> asdf1234: wtf right?
07:42:52 <Philonous> asdf1234, Don't you need an extension for that?
07:43:02 <giogadi> asdf1234: and in my very specific case it happened to raise NO compiler errors
07:43:02 <asdf1234> Philonous: for what?
07:43:13 <Philonous> asdf1234, postfix operators
07:43:56 <asdf1234> Philonous: I don't know?
07:44:03 <asdf1234> giogadi: That's really strange. O.o
07:46:53 <giogadi> I can't seem to find any documentation on what exactly backticking a non-binary function does
07:46:59 <asdf1234> Philonous: Oh! That's the magic hash. It isn't a postfix operator. It's a special symbol.
07:47:14 <rtpg> are the conduits in conduit arrows?
07:47:24 <asdf1234> Philonous: You use it with GHC primitives.
07:47:42 <Philonous> asdf1234, Ah, no, I was talking about backticking non-binary functions, but I didn't follow the whole discussion, so never mind ;)
07:47:55 <dwcook> giogadi, you're coming at it from the wrong angle. Since you wrote something of the form a `f` b, f *must* be a function-returning function, or else it won't type check.
07:47:56 <asdf1234> Philonous: Oh, OK :)
07:48:10 <giogadi> dwcook: so where's the function coming from?
07:48:53 <giogadi> anyone else that wants to join in on the non-binary backtick conundrum can check out line 39 here: http://lpaste.net/96826
07:48:53 <dwcook> giogadi, well, you already discovered that it's using the Monoid instance for functions.
07:49:04 <dwcook> Look at the definition and evaluate it in your head using that.
07:49:34 <dwcook> My basic point is â€“ It *is* a "binary function", as you put it.
07:51:38 <dwcook> giogadi, so you have instance Monoid b => Monoid (a -> b), right?
07:51:38 <giogadi> Okay, I'll try taking a deep look at that instance. Instance definitions for (->) always confused me to be honest
07:51:58 <asdf1234> Oh, ok.. since the mempty instance here gets resolved to a binary function?
07:52:17 <dwcook> giogadi, what is b?
07:52:28 <dwcook> b has to be something you can apply, right? So it must be a function.
07:52:42 <dwcook> Conveniently, there is a Monoid instance for functions.
07:52:46 <dwcook> As we just used.
07:53:06 <giogadi> I'm still trying to wrap my head around this
07:53:40 <asdf1234> giogadi: think of -> as an infix operator in type signatures ... ((->) r) is like r -> _
07:54:38 <Philonous> asdf1234, Your primop version is in the middle of the other two
07:54:46 <asdf1234> lol
07:54:51 <Philonous> asdf1234, Indeed
07:56:21 <giogadi> dwcook: when you say "b has to be something you can apply", can you elaborate?
07:56:39 <giogadi> I'm still trying to put together what types a and b are in this case
07:56:51 <dwcook> giogadi, okay, so let's say you have a `mempty` b. mempty :: (Monoid a) => a. With me so far?
07:57:05 <dwcook> Well
07:57:09 <dwcook> it's more specific than that
07:57:19 <dwcook> but that's its most general type, which we're going to use to get the specific type as it's used here
07:57:41 <dwcook> giogadi, the only things that can be applied are functions.
07:57:41 <giogadi> dwcook: I'm not certain I follow your notation there
07:57:57 <dwcook> It's just standard Haskell. Which part was unclear?
07:58:00 <asdf1234> Philonous: that's very interesting; I'd like to give you cmm code that fixes the lookup, but I don't know how that would work with criterion
07:58:16 <asdf1234> meh
07:58:16 <Philonous> asdf1234, That is to say, it's exactly as fast as the packed version
07:58:22 <giogadi> what's the point after b for instance?
07:58:33 <giogadi> is that composition?
07:58:47 <dwcook> giogadi, that was another sentence, sorry.
07:58:56 <asdf1234> Philonous: which one's the packed version?
07:59:02 <giogadi> oh ok ok ok yeah that's very clear
07:59:17 <giogadi> please continue
07:59:51 <dwcook> giogadi, okay, so a `mempty` b is the same as mempty a b. Since function application goes from left to right, first we evaluate mempty a. So which instance of Monoid do we take mempty from?
08:00:24 <giogadi> the function PQ.singleton, which is a function
08:00:44 <Philonous> asdf1234, I have a tayp "data Range = Single Char | Range Char Char" and I'm comparing a version with unboxed chars to one which is polymorphic in it's contents (so, boxed), and you code with the primops is almost exactly as fast as the polymorphic version
08:00:45 <dwcook> giogadi, no, that doesn't determine it at all.
08:00:58 <dwcook> Notice I didn't even mention it in this example.
08:01:03 <giogadi> right, ok
08:01:18 <giogadi> so ok
08:01:23 <giogadi> since mempty has to be applied to a
08:01:32 <giogadi> the value of mempty must be a function to apply to a
08:01:45 <dwcook> Correct.
08:01:47 <giogadi> and as you said there's only one instance of Monoid for functions
08:01:58 <Philonous> asdf1234,unpacked, even
08:02:04 <asdf1234> Philonous: ah.. well, my code does have to do heap accesses and unbox the characters.. it'd be faster if it used unboxed chars
08:02:16 <dwcook> So mempty :: (Monoid b) => a -> b, according to that instance.
08:02:19 <piezoid> hi
08:02:22 <asdf1234> Philonous: comparing is super-cheap
08:02:34 <dwcook> giogadi, then what is the type of mempty a?
08:02:37 <piezoid> I'm looking for a deep embedding DSL framework.
08:02:46 <piezoid> I read syntactic (Feldspar) and compdata papers, the fonctional pearl about circular programs for HOAS, etc...
08:03:10 <asdf1234> Philonous: (relative to looking up functions or accessing the heap)
08:03:19 <piezoid> I'm a bit lost, there is so many approaches...
08:03:41 <giogadi> dwcook: mempty a is something that can be applied to a type b of instance Monoid
08:03:46 <giogadi> meaning mempty a is also a function
08:03:47 <piezoid> do you have any experience with one of those ?
08:03:51 <giogadi> aaaah
08:03:54 <dwcook> giogadi, we're not at that point yet.
08:04:01 <giogadi> hrm
08:04:05 <dwcook> giogadi, given that you only see the expression mempty a, what is its type?
08:04:35 <asdf1234> dwcook: depends on the monoid instance
08:04:59 <dwcook> We've already resolved the only Monoid instance we need to for that.
08:05:17 <dwcook> If you have a function :: a -> b and you apply it to an a, you have a b.
08:05:23 <giogadi> oh right
08:05:32 <dwcook> So what do we end up with?
08:05:33 <giogadi> so I get the mempty defined by the instance of Monoid for b
08:05:38 <dwcook> No.
08:05:43 <giogadi> no?
08:06:04 <dwcook> No, mempty is only mentioned once, and we've already figured out which one it is.
08:06:19 <giogadi> mempty is mentioned again in the definition of mempty for (a -> b) instance
08:06:34 <dwcook> Doesn't matter, we're just talking about types for now.
08:06:44 <dwcook> What is the most general type of mempty a?
08:06:47 <giogadi> ok, well that means mempty a must be of type b right
08:06:53 <dwcook> Almost.
08:07:00 <dwcook> You're missing one vital piece of information.
08:07:11 <Philonous> asdf1234, I don't understand, though. Unboxed fields should be inlined into the constructor, shouldn't they? So when I match on Range {-# UNPACK #-} !Char {-# UNPACK #-} !Char  I don't need another heap access, do I?
08:08:00 <dwcook> Remember that b must be an instance of Monoid, so mempty a :: (Monoid b) => b
08:08:24 <dwcook> Now that we know the type of that, let's evaluate mempty a b.
08:08:36 <dwcook> What do we know about the type of mempty a since we're applying it to be?
08:08:44 <dwcook> s/be/b/
08:09:21 <giogadi> we know that the type of mempty a must be something that can be applied
08:09:33 <dwcook> Right, which can only be one thing, namelyâ€¦?
08:10:01 <giogadi> a function from b -> .... I'm not sure where
08:10:08 <dwcook> Right, a function.
08:10:14 <dwcook> So we use the function instance for Monoid *again*.
08:10:21 <giogadi> ok
08:11:02 <giogadi> so mempty a :: Monoid b, c => b -> c ?
08:11:10 <dwcook> So then mempty a b :: (Monoid c) => c (I just wrote c to make it clear that it's not the same as the b we had earlier)
08:11:22 <dwcook> Not quite
08:11:26 <dwcook> We already figured out what b is
08:11:34 <dwcook> It's a function
08:11:38 <giogadi> oh right
08:12:23 <dwcook> See if you can work out what mempty's most general type is given that we use it in this expression: mempty a b
08:12:48 <dwcook> Or as used in that expression, I should say
08:13:51 <dwcook> Remember to expand Monoid instances as necessary
08:13:53 <giogadi> mempty :: (Monoid c) => a -> b -> c ?
08:14:04 <giogadi> no I'm just guessing
08:14:11 <dwcook> That looks right to me.
08:14:43 <giogadi> I now have maybe 75% confidence in why this is happening, but it's shaky. dwcook thanks so much for walking me through this
08:14:48 <dwcook> No problem. :)
08:14:50 <giogadi> I need just sit with this for a little longer
08:15:10 <dwcook> Sometimes stepping away from a problem and not actively thinking about it, then coming back is helpful.
08:15:37 <giogadi> dwcook: that explains the monoid thing. but I also constrained it to be an Ord type. are functions also Ords?
08:16:23 <dwcook> giogadi, doubtful.
08:16:33 <dwcook> What did you constrain exactly?
08:17:07 <giogadi> dwcook: check out lines 22 and 39 http://lpaste.net/96826
08:18:09 <dwcook> giogadi, keep in mind that the mempty there is a function, not whatever type you constrained to be a Monoid.
08:19:35 <giogadi> ah yeah you're right
08:24:28 <Flonk> hmm.. how do I turn an (a,IO b) into an IO (a,b)?
08:25:14 * hackagebot vault 0.3.0.3 - a persistent store for values of arbitrary types  http://hackage.haskell.org/package/vault-0.3.0.3 (HeinrichApfelmus)
08:25:16 * hackagebot yesod-pure 0.1.0.2 - Yesod in pure Haskell: no Template Haskell or QuasiQuotes (deprecated)  http://hackage.haskell.org/package/yesod-pure-0.1.0.2 (MichaelSnoyman)
08:25:17 <asdf1234> :t \(a,b) -> b >>= \b' -> return (a,b')
08:25:18 <lambdabot> Monad m => (t, m t1) -> m (t, t1)
08:25:30 <asdf1234> flonk: \(a,b) -> b >>= \b' -> return (a,b')
08:25:37 <dwcook> Beat me to it
08:25:38 <Cale> :t uncurry (liftM2 (,) . return)
08:25:39 <lambdabot> Monad m => (a1, m a2) -> m (a1, a2)
08:25:47 <dwcook> Cale, show-off :D
08:25:53 <Cale> (but do it the way asdf1234 said)
08:26:26 <Flonk> asdf1234: Well, should have been able to think of that myself
08:26:27 <Flonk> Thanks
08:29:39 <bennofs> What packages do you recommend for parsing a HTML package and getting some informations out of it? (Plain html, no js)
08:30:02 <tdammers> scraping?
08:30:05 <tdammers> tagsoup should work
08:30:45 <tdammers> http://hackage.haskell.org/package/tagsoup
08:34:08 <Flonk> I feel like IO gets really messy really fast
08:35:16 * hackagebot yesod-platform 1.2.5 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.5 (MichaelSnoyman)
08:35:33 <bennofs> tdammers: Do you know how I could, for example, get all rows of a table that have exactly 6 table data (td) elements as children?
08:35:57 <piezoid> bennofs: xml-conduit have nice XPath like combinators : http://hackage.haskell.org/package/xml-conduit-1.1.0.7/docs/Text-XML-Cursor.html
08:36:00 <Cale> Flonk: Not really
08:36:11 <danilo2> Hello, this could be very nooby question, but what does such syntax mean? "canny (constant -> low) (constant -> high) = ..." (this is not a type - this is function "canny" definition)
08:36:15 <Cale> Flonk: It's no messier than your average imperative language
08:36:25 <tdammers> bennofs: not out of the box, but it shouldn't be too hard once you have some sort of tree-shaped data structure
08:36:35 <Cale> (and often tidier)
08:36:37 <bennofs> danilo2: I think that's view patterns extension
08:37:05 <danilo2> bennofs: Ok, thanks. I'll check it out :)
08:39:07 <Flonk> Cale: Probably just a matter of getting used to it, yeah
08:39:11 <bennofs> piezoid: thanks, that looks really neat
08:39:32 <Cale> Flonk: especially if you use do-notation
08:40:13 <Cale> Flonk: That function you wanted earlier, what did you want to use it for?
08:40:29 <_d0t> hello, gentlemen. How do I check that the udp socket (from Networ.Socket) has data to read?
08:40:52 <bennofs> _d0t: do you have a Socket or a Handle?
08:41:04 <_d0t> bennofs: Socket
08:41:12 <_d0t> sockV4 <- socket AF_INET Datagram 0
08:42:08 <Flonk> Cale: Checking which user last logged on to a PC in the network
08:42:25 <Flonk> Cale: Wanted to move the IO out of the tuple so I could use sequence
08:43:32 <triliyn> I bet you could use Lens maybe to sequence without pulling the IO out
08:43:42 <Cale> Flonk: It's just slightly weird to need that in particular (it's a bit unusual to have a list of pairs of values and IO actions in the first place)
08:44:08 <_d0t> triliyn: Control.Lens ?
08:44:37 <Cale> (and usually when you do, you're going to be processing that list somehow, so as to pick out IO actions from it and run just those)
08:44:40 <triliyn> _d0t: yes, but I was talking about Flonk's problem, not yours
08:44:44 <Flonk> triliyn: It's good getting the hang of IO first though :P
08:44:45 <triliyn> I don't know anything about sockets
08:44:51 <_d0t> ok, sry
08:45:17 * hackagebot http-client 0.2.0.3 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.2.0.3 (MichaelSnoyman)
08:45:26 <Flonk> Cale: hmm
08:45:41 <Cale> Flonk: How'd you get a list of pairs of values and IO actions? :)
08:47:04 <Flonk> Cale: What I'm doing is getting all directories in a directory (IO [FilePath]), then fmapping over them and pairing each FilePath up with an IO UTCTime
08:47:25 <Flonk> So then I end up with [(FilePath, IO UTCTime)]
08:48:10 <Cale> Why not just run the IO [FilePath] first, so you have [FilePath], and then mapM or forM over that list
08:48:21 <bennofs> traverse (\(a,b) -> fmap ((,) a) b) :: [(a, IO b)] -> IO [(a,b)]
08:48:23 <triliyn> :t mapM
08:48:24 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
08:48:25 <bennofs> @ty traverse (\(a,b) -> fmap ((,) a) b) :: [(a, IO b)] -> IO [(a,b)]
08:48:26 <lambdabot> [(a, IO b)] -> IO [(a, b)]
08:48:32 <triliyn> (forM is just mapM with its arguments flipped)
08:49:03 <Cale> do dirs <- getDirectories; forM (\dir -> do t <- getModificationTime dir; return (dir, t))
08:49:18 <Cale> :: IO [(FilePath, UTCTime)]
08:49:32 <Cale> oops
08:49:38 <Cale> do dirs <- getDirectories; forM dirs (\dir -> do t <- getModificationTime dir; return (dir, t))
08:49:56 <Cale> (missed the list to iterate over :)
08:50:02 <Cale> do dirs <- getDirectories; forM dirs $ \dir -> do t <- getModificationTime dir; return (dir, t)
08:50:08 <Cale> you can also avoid the parens like that
08:50:17 * hackagebot regular-extras 0.2.3 - Additional functions for regular: arbitrary,  coarbitrary, and binary get/put.  http://hackage.haskell.org/package/regular-extras-0.2.3 (JosePedroMagalhaes)
08:50:27 <Cale> I'm not 100% certain why the $ is required to eliminate the parens here, it's a little weirdness of the Haskell grammar
08:51:01 <Cale> forM :: [a] -> (a -> IO b) -> IO [b]
08:51:08 <Flonk> Cale: Hmm, let me quickly think that through
08:51:09 <Cale> is like a for-each loop
08:51:09 <exicer> Does anyone know if it is possible to repeat the previous command in ghci haskell-inferior mode in emacs (like pressing the up arrow in ghci)
08:51:16 <Flonk> Cale: flip mapM right?
08:51:19 <Cale> yeah
08:51:57 <Cale> You can think of the a -> IO b as a loop body, which is a function of the value in the list corresponding to the current iteration
08:52:05 <Philonous> exicer, M-p
08:52:10 <Cale> the [a] is the list of values to loop over
08:52:18 <exicer> Philonous: Thanks.
08:52:22 <Cale> and we produce as the result of the IO action it builds, a list of the results of each iteration
08:52:37 <Cale> You could write forM yourself like this:
08:52:49 <Philonous> exicer, As in "previous" and M-n as in "next"
08:52:53 <Cale> forM [] f = return []
08:53:13 <Cale> forM (x:xs) f = do v <- f x; vs <- forM xs f; return (v:vs)
08:54:00 <Cale> (same thing as mapM with the args flipped, but it's often convenient to have the f last, because it's going to be a big lambda with some do-block inside it)
08:54:16 <francescopa> come
08:54:19 <Flonk> Cale: I see..
08:54:22 <francescopa> ciao
08:54:30 <Cale> francescopa: hello!
08:55:18 * hackagebot http-conduit 1.9.5.3 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.5.3 (MichaelSnoyman)
09:00:52 <Flonk> Cale: Seems like mapM/forM was precisely what I was looking for in the first place
09:00:54 <Flonk> Thanks for the help!
09:01:02 <merijn> I had already achieved the level where I had to linewrap my type signatures, now I seem to have ascended to the point where I need linewrap single types >.>
09:01:16 <merijn> Flonk: Also rembmer "mapM_" if you don't care about the result list
09:01:20 <merijn> :t mapM_
09:01:21 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
09:01:44 <merijn> Flonk: It throws away the 'b' results, keeping only the side effects
09:02:18 <Flonk> merijn: Ah, thats handy. I've used sequence_ before
09:05:29 <merijn> Flonk: mapM_ is scretely just "mapM_ f = sequence_ . map f" :p
09:05:56 <byorgey> o no, you gave away the secret!
09:06:11 <merijn> The truth cannot be silenced!
09:06:21 <Flonk> I will not disclose this outside #haskell, I promise.
09:08:28 <merijn> There's no way to alias types on import, right? I will just have to "type Foo = Bar" I guess?
09:08:29 <donri> :t liftM sequence_ (liftM liftM) `asTypeOf` mapM_
09:08:31 <lambdabot>     Couldn't match type `m0 ()' with `()'
09:08:31 <lambdabot>     Expected type: [a10 -> r0] -> [a10] -> ()
09:08:31 <lambdabot>       Actual type: (a10 -> m0 b0) -> [a10] -> m0 ()
09:08:35 <donri> :(
09:08:45 <asdf1234> :t mapA
09:08:46 <lambdabot>     Not in scope: `mapA'
09:08:46 <lambdabot>     Perhaps you meant one of these:
09:08:46 <lambdabot>       `mapM' (imported from Control.Monad.Writer),
09:09:04 <donri> :t liftM (liftM sequence_) liftM `asTypeOf` mapM_
09:09:05 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m ()
09:09:07 <asdf1234> :t (<*>)
09:09:07 <donri> there
09:09:08 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:09:10 <byorgey> merijn: sadly not
09:09:19 <asdf1234> :t fmap (<*>)
09:09:20 <lambdabot> (Functor f, Applicative f1) => f (f1 (a -> b)) -> f (f1 a -> f1 b)
09:09:25 <donri> mapM_ is secretly liftM (liftM sequence_) liftM  ;)
09:09:27 <merijn> byorgey: ByteString is such a wastefully long name >.>
09:09:38 <bennofs> Does conduit require you to handle a Maybe everytime you await?
09:09:50 <byorgey> asdf1234: perhaps you are looking for Data.Traversable.traverse
09:10:06 <merijn> :t T.traverse
09:10:07 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:10:16 <byorgey> which works for any Applicative instead of being unnecessarily restricted to Monad, and at the same time generalizes from lists to any Traversable functor
09:10:17 <asdf1234> byorgey: nah.. just messing around; mapM_ seems weird since you're throwing away your context anyway
09:10:37 <byorgey> asdf1234: it's not the context but the results which get thrown away.
09:10:43 <merijn> asdf1234: You're keeping the context, you throw the results away
09:10:50 <asdf1234> ah
09:10:52 <byorgey> asdf1234: however, you are right that Monad is not required, that is a historical accident.
09:10:52 <asdf1234> my mistake :P
09:10:54 <merijn> :t mapM_
09:10:55 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
09:11:00 <byorgey> you only need Applicative.
09:11:01 <merijn> :t mapM
09:11:02 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
09:11:05 <donri> bennofs: awaitForever, maybe?
09:11:08 <asdf1234> but yeah, monad isn't needed here, is it?
09:11:09 <merijn> It's the [b] that's thrown away
09:11:19 <byorgey> asdf1234: right
09:11:19 <asdf1234> well, maybe it is
09:11:32 <merijn> asdf1234: Applicative is sufficient
09:11:33 <asdf1234> but we can't tell from that specific bit
09:11:39 <merijn> :t T.mapM_
09:11:40 <lambdabot> Couldn't find qualified module.
09:11:42 <merijn> actually
09:11:45 <merijn> Foldable, I guess
09:11:49 <merijn> :t F.mapM_
09:11:50 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
09:11:57 <merijn> really?
09:12:00 <merijn> Monad?
09:12:06 <merijn> Colour me surprised
09:12:10 <bennofs> :t F.traverse_
09:12:11 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
09:12:17 <donri> why wouldn't M_ be m onad
09:12:21 <bennofs> :t F.for_
09:12:22 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
09:12:25 <ij> > length "\xff0"
09:12:27 <lambdabot>  1
09:12:28 <merijn> donri: oh, I guess AMP will fix that :)
09:12:36 <donri> duno if it will
09:12:37 <ij> It's 1 because of utf8?
09:12:54 <merijn> ij: That question is very confused
09:12:56 <asdf1234> :t "\xff0"
09:12:57 <lambdabot> [Char]
09:13:02 <merijn> ij: String is a list of characters
09:13:12 <merijn> ij: The length of a list with one character is 1, obviously
09:13:17 <asdf1234> show '\xff0'
09:13:17 <geekosaur> note that a character is a codepoint
09:13:31 <asdf1234> > show '\xff0'
09:13:32 <lambdabot>  "'\\4080'"
09:13:43 <geekosaur> I think they've confused utf8 with unicode
09:13:57 <merijn> donri: Well, the only reason to have mapM_ use Monad would seem to me is the fact that Applicative is not a superclass of Monad and would thus cause it to not work for monads
09:14:16 <merijn> @google Joel Unicode
09:14:17 <lambdabot> http://www.joelonsoftware.com/articles/Unicode.html
09:14:17 <lambdabot> Title: The Absolute Minimum Every Software Developer Absolutely, Positively Must Kno...
09:14:32 <asdf1234> > show 0xff0
09:14:33 <lambdabot>  "4080"
09:14:41 <merijn> ij: Read that and realise the Char is a unicode character, not a byte
09:14:42 <donri> merijn: yes, but even post-AMP do you expect base to change constraints of things like that or even deprecate them anytime soon?
09:15:03 <merijn> donri: Well, since the new type is backwards compatible, why not?
09:15:30 <merijn> donri: i.e. with AMP any Monad will be Applicative so changing the type of mapM_ will still work with monads
09:15:59 <asdf1234> what about monads without a defined fmap
09:16:10 <arkeet> > ord '\xff0'
09:16:11 <lambdabot>  4080
09:16:29 <arkeet> asdf1234: those won't compile
09:16:30 <asdf1234> because they were created before applicative was a superclass of monad
09:16:31 <merijn> asdf1234: Defining fmap using just Monad is trivial
09:16:32 <donri> merijn: i'm pondering if it could be possible to have code break with "could not deduce Monad" here, not sure though...
09:16:56 <merijn> asdf1234: Just define a default implementation of "fmap f x = x >>= return . f"
09:16:57 <bennofs> asdf1234: AMP is about making Applicative and therefore Functor a superclass of Monad
09:17:19 <merijn> asdf1234: So even if a type only implements Monad, it'll still work
09:17:23 <asdf1234> bennofs: I got that. My question was about backwards compatibility
09:17:39 <merijn> asdf1234: See the AMP wiki proposal, which discusses this
09:17:43 <byorgey> merijn: uh, false.  If a type only implements Monad itwill be an error.
09:18:27 <byorgey> the current AMP proposal dos not include anything like default implementations for superclasses.
09:18:41 <merijn> I thought it did?
09:18:46 <arkeet> no
09:18:52 <donri> no, you still need to write fmap = liftM for each instance
09:18:52 <merijn> Sad
09:18:59 <donri> same for applicative
09:19:06 <arkeet> it includes warnings in 7.8 that monads without functor/applicative instances will break in7.10
09:19:21 <donri> superclass stuff is harder than one might think
09:19:32 <byorgey> merijn: that may come later.
09:19:58 <byorgey> but part of the reason it's taken so long to happen is precisely because no one can ever agree on these higher-level features so it just kept getting stalled.
09:20:07 <byorgey> the current proposal does the bare minimum to add Applicative => Monad.
09:20:15 <fizbin> merijn: That Joel on Software article omits many points that even bit-slingers need to know. (such as the surrogate pairs crap)
09:20:54 <asdf1234> > 4080 .&. 255
09:20:56 <lambdabot>  Ambiguous occurrence `.&.'
09:20:56 <lambdabot>  It could refer to either `Data.Bits..&.',
09:20:56 <lambdabot>                           imported from `Data.Bits' at L.hs:56:1-16
09:20:56 <lambdabot>                        or `Test.QuickCheck.Property..&.',
09:20:56 <lambdabot>                           imported from `Lambdabot.Plugin.Haskell.Eval.Truste...
09:21:05 <donri> consider if Functor had some implicit fallback on Monad, now Monad has to be defined before Functor, and it needs a Functor constraint so it has to be defined after. ie, you have to put everything in one module or figure out cyclic imports :P
09:21:27 <asdf1234> let band = Data.Bits.(.&.)
09:21:36 <asdf1234> > band 4080 255
09:21:37 <lambdabot>  Not in scope: `band'
09:21:37 <lambdabot>  Perhaps you meant one of these:
09:21:37 <lambdabot>    `and' (imported from Data.List),
09:21:37 <lambdabot>    `F.and' (imported from Data.Foldable)
09:21:50 <asdf1234> > let band = Data.Bits.(.&.)
09:21:50 <maurer> > let band = Data.Bits.(.&.)
09:21:51 <lambdabot>  not an expression: `let band = Data.Bits.(.&.)'
09:21:51 <lambdabot>  can't find file: L.hs
09:21:53 <notdan> 0140542.0.
09:21:57 <donri> it's @let
09:21:57 <maurer> > let band = Data.Bits.(.&.) in band 4080 255
09:21:59 <lambdabot>  Not in scope: data constructor `Data.Bits'Ambiguous occurrence `.&.'
09:21:59 <lambdabot>  It could refer to either `Data.Bits..&.',
09:21:59 <lambdabot>                           imported from `Data.Bits' at L.hs:56:1-16
09:21:59 <lambdabot>                        or `Test.QuickCheck.Property..&.',
09:21:59 <lambdabot>                           imported from `Lambdabot.Plugin.Haskell.Eval.Truste...
09:22:06 <arkeet> > 4080 .&. 255
09:22:07 <lambdabot>  Ambiguous occurrence `.&.'
09:22:08 <lambdabot>  It could refer to either `Data.Bits..&.',
09:22:08 <lambdabot>                           imported from `Data.Bits' at L.hs:56:1-16
09:22:08 <lambdabot>                        or `Test.QuickCheck.Property..&.',
09:22:09 <lambdabot>                           imported from `Lambdabot.Plugin.Haskell.Eval.Truste...
09:22:09 <asdf1234> lol
09:22:12 <arkeet> > 4080 Data.Bits..&. 255
09:22:13 <lambdabot>  240
09:22:24 <asdf1234> ah ok
09:22:27 <asdf1234> thanks
09:22:32 <arkeet> yeah it's a bit weird
09:22:34 <fizbin> :let  band = (Data.Bits..&.)
09:22:37 <asdf1234> I think I'll just move this to my terminal
09:22:40 <arkeet> yes
09:22:43 <arkeet> or pm with lambdabot
09:23:17 <fizbin> @let Â band = (Data.Bits..&.)
09:23:17 <lambdabot>  .L.hs:163:1: Not in scope: data constructor `ï¿½'
09:23:41 <merijn> fizbin: It didn't claim to be the "end-all" guide to unicode
09:23:42 <arkeet> your client is outputting weird characters.
09:23:43 <byorgey> wat
09:23:48 <arkeet> invisible ones.
09:23:48 <merijn> fizbin: It's the *bare minimum*
09:23:53 <fizbin> @let band = (Data.Bits..&.)
09:23:53 <lambdabot>  .L.hs:163:8:
09:23:54 <lambdabot>      No instance for (Bits a0) arising from a use of `Data.Bits..&.'
09:23:54 <lambdabot>      The type variable `a0' is ambiguous
09:23:54 <lambdabot>      Possible cause: the monomorphism restriction applied to the following:
09:23:54 <lambdabot>        band :: a0 -> a0 -> a0 (bound at .L.hs:163:1)
09:24:02 <arkeet> monomorphism restriction.
09:24:04 <merijn> fizbin: Knowing about surrogate pairs is not something everyon *needs* to know
09:24:11 <merijn> fizbin: Text deals with that stuff just fine
09:24:30 <arkeet> let bos do the hard stuff so you can us Text and be happy.
09:24:39 <arkeet> use*
09:24:41 <merijn> fizbin: (to my great pleasure I found out Text even properly uppercase ligatures into multi-characters :))
09:24:53 <arkeet> cool
09:25:16 <fizbin> merijn: Well... so you need to know that even if you're using a 16-bit char type, the number of char elements in a string may not be the number of unicode code points.
09:25:38 <merijn> fizbin: That's only relevant in bad languages
09:25:53 <asdf1234> fizbin: [Char] uses 32-bit chars doesn't it?
09:25:56 <arkeet> yes
09:26:03 <merijn> fizbin: If your String type doesn't think in unicode code points, your language is bad and you should feel bad
09:26:28 <maurer> asdf1234: My understanding is that it uses implementation-specific encoding of unicode codepoints
09:26:34 <maurer> asdf1234: Rather than specifically 32-bits
09:26:43 <fizbin> Fair enough. But if you're stuffing Chars into Word16s and thinking that you're doing UTF-16...
09:26:54 <arkeet> > toUpper 'ï¬'
09:26:55 <lambdabot>  '\64257'
09:27:04 <maurer> fizbin: If you wannt to do stuff with various encodings, there are packages for that
09:27:06 <asdf1234>  maurer: fair enough :P
09:27:07 <merijn> fizbin: Then you're an idiot, and he does mention that UTF-16 is variable length in that article
09:27:08 <arkeet> > text $ toUpper 'ï¬'
09:27:09 <lambdabot>  Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
09:27:09 <lambdabot>  Expected type: GHC.Base.String
09:27:10 <lambdabot>    Actual type: GHC.Types.Char
09:27:11 <fizbin> The answer of course is that one shouldn't do UTF-16
09:27:12 <arkeet> re.
09:27:16 <arkeet> > text $ [toUpper 'ï¬']
09:27:17 <lambdabot>  ï¬
09:27:21 <arkeet> heh.
09:27:30 <merijn> arkeet: Doesn't work for toUpper
09:27:33 <arkeet> clearly.
09:27:34 <arkeet> :P
09:27:34 <donri> both String and Text say "Ã©eÌ" is length 3
09:27:35 <merijn> arkeet: Wouldn't typecheck
09:27:37 <maurer> fizbin: Sometimes you have to speak a protocol to some asshole using UTF-16
09:27:42 <donri> that may be correct by all standards, duno
09:27:43 <merijn> arkeet: Because toUpper returns Char
09:27:44 <arkeet> merijn: I know.
09:27:45 <asdf1234> 8 bits should be enough for anybody :P
09:27:51 <arkeet> I was just curious :V
09:27:55 <merijn> Text uses UTF-16 internally
09:27:56 <fizbin> maurer: Don't I know it.
09:28:00 <arkeet> fizbin: what's wrong with utf-16?
09:28:17 <asdf1234> arkeet: it has the disadvantages of both utf8 and utf32
09:28:18 <merijn> arkeet: utf-8 is more elegant and uses less space in most settings
09:28:45 <merijn> arkeet: There is not a single thing UTF-16 does better than it's main competitors (utf-8 and utf-32)
09:28:45 <donri> where most = i'm merkan dammit!
09:28:51 <arkeet> sure
09:28:53 <arkeet> but it's not *evil*
09:29:13 <donri> utf-16 does bindings support better in some cases
09:29:14 <MattY> it also has advantages of both utf8 and utf32? :))
09:29:19 <merijn> arkeet: Most incompetents market UCS-2 as UTF-16, thus leading to lots of things claiming to be UTF-16 to be actually broken
09:29:22 <donri> (that's the motivating reason for text using it)
09:29:32 <arkeet> merijn: yes, that is bad.
09:29:37 <asdf1234> MattY: I wish it worked that way
09:29:57 <maurer> donri: "bindings support" ?
09:30:17 <donri> maurer: interfacing with C libraries
09:30:22 * hackagebot HaTeX 3.9.1.0 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.9.1.0 (DanielDiaz)
09:30:29 <donri> a number of important ones use utf-16
09:30:41 <donri> like ICU and i think the windows api
09:30:52 <MattY> asdf1234 it has a size advantage compared to utf32 and convenience advantage compared to utf8
09:31:03 <asdf1234> ah yes.. back in the days when we thought we wouldn't need more than 16 bits
09:31:15 <arkeet> MattY: how is it more convenient than utf-8?
09:31:23 <maurer> UTF16 is kind of sad because you both have bloat ( latin chars use twice as much space ) and you can't just increment the pointer to get the next codepoint
09:31:26 <arkeet> it does have a size advantage over utf-8 for certain languages though
09:31:38 <MattY> arkeet more unicode characters fit in a sinle utf16 char than utf8 char
09:31:48 <arkeet> yes, but not all
09:31:49 <arkeet> :p
09:32:06 <arkeet> which means you still have to be careful with the ones that don't
09:32:19 <psc> hey can anyone tell my why this does not work  in haskell ( ghci will not load this function) "broken x:xs = x"  I know that "working (x:xs)= x" works but i often forget the braces  and maybe I can remember them  better when I know why exactly they must be there.
09:32:19 <maurer> MattY: I think you're saying codepoint for the first "character", and have no clue what you mean by "char" for the second two
09:32:20 <MattY> you don't if the ones you are interested in fit :)
09:32:23 <asdf1234> utf16 also doesn't play nicely with things that expect ascii or latin-1
09:32:27 <donri> though the utf-8 port of text was slower because of the added complexity of utf8
09:32:28 <maurer> MattY: As you can't have a utf16 8-bit segment
09:32:30 <arkeet> and yeah you mean code unit.
09:32:45 <arkeet> MattY: that kind of thinking leads to uh.
09:32:50 <arkeet> breakage.
09:33:14 <asdf1234> and then there's the whole little-endian, big-endian thing
09:33:16 <MattY> not all software needs to support all the languages in existence
09:33:30 <donri> i wonder how utf* compare to each other in size when compressed
09:33:31 <maurer> psc: You are performing a pattern match in the argument, pattern matches need to be parenthesized
09:33:44 <maurer> psc: It'd be similar if you had done "data A = A Int"
09:33:49 <arkeet> donri: hopefully they're all similar.
09:33:50 <quchen> psc: "working x:xs" is parsed as "(working x):xs" I think
09:33:58 <donri> wouldn't there be a lot of compressable redundancies in utf>8?
09:33:58 <maurer> psc: Then when you wrote your function, you'd  have to do f (A i) = some exp with i
09:34:04 <srhb> I have a list of parsers that I want to sequence, collecting their results, but if I run out of input after one of these parsers, I want to short-circuit out (with the results I have so far) -- does this sound like an existing function?
09:34:23 <arkeet> donri: yes, like half the bytes being zero for ascii text in utf-16.
09:34:25 <arkeet> :p
09:34:28 <quchen> srhb: "many"?
09:34:32 <asdf1234> srhb: sounds like the choice combinator from your parser library of choice
09:34:32 <donri> yeah like that
09:34:42 <quchen> srhb: Oh, different parsers.
09:34:50 <arkeet> but asking how well ascii compresses is kind of missing a lot, I think
09:35:00 <maurer> donri: Yeah, which is an argument about 16, but 32 gains the power that all the codepoints fit into 32 bits
09:35:02 <srhb> asdf1234: how so? choice picks one of them. Sequence matters.
09:35:14 <maurer> donri: So to advance the codepoint stream, you can just do pointer math, rather than having to check bits
09:35:15 <asdf1234> srhb: does it not pick the first one?
09:35:25 <arkeet> it would be interesting to compare how e.g. japanese text compresses in the various encodings
09:35:29 <donri> it seems the main reason utf8 is popular besides ascii back-compat is compactness, but it seems compression would solve that more generically anyway
09:35:31 <asdf1234> srhb: if not, maybe have a look at a packrat parsing lib .. they have definitive ordering
09:35:34 <srhb> asdf1234: Yes. But the second might yield results, too.
09:35:37 <arkeet> utf-8, utf-16, utf-32, shift-jis (yes they still use that a lot!)
09:35:45 <arkeet> and euc-jp
09:35:51 <simpson> Don't forget Big5!
09:35:54 <arkeet> that's chinese.
09:36:01 <asdf1234> srhb: wait, what? you want to parse something twice?
09:36:33 <srhb> asdf1234: No, I want to parse [parser1, parser2, parser3 <-- end of input, stop here, parser4...]
09:36:34 <arkeet> although if I was compressing text I'd probably treat it as a stream of code points.
09:36:47 <psc> thx
09:36:49 <arkeet> because it would make me feel better.
09:37:05 <asdf1234> donri: also, utf8 is super-convenient for not having to worry about endianness and BOMs
09:37:14 <donri> that's true
09:37:39 <asdf1234> srhb: you could use a many/choice combinator and then run parser4 over the result
09:38:46 <donri> i think ascii back-compat is the worst misfeature of utf8 though :P
09:38:49 <srhb> asdf1234: I don't think I'm expressing the pattern clearly. Nevermind. ^^
09:38:54 <asdf1234> >.<
09:38:56 <asdf1234> sorry
09:39:12 <donri> it's perhaps the primary reason people still get encodings wrong all the time :P
09:39:18 * donri hyperbole
09:40:16 <asdf1234> donri: people get encodings wrong all the time because unicode is complicated
09:40:25 <donri> well there's that
09:40:36 <simpson> Also because people figure that encoding is somehow automagic.
09:41:41 <asdf1234> simpson: to be fair, most of the time it is
09:41:46 <asdf1234> simpson: until it breaks
09:42:17 <simpson> asdf1234: That's the kind of thinking that led to e.g. IRC's lack of Unicode support. :c
09:42:18 <donri> well that's my point, it seems more automagic due to ascii compat
09:42:21 <bennofs> Why is there no http-conduit or xml-conduit without the conduit part? :O
09:42:27 <srhb> failSeq (x:xs) = do { f <- parse; if moreInput then f:failSeq xs else f:[] } -- is what I want I think.
09:42:35 <donri> bennofs: pipes versions are in the works
09:42:44 <srhb> Oops, missing a return
09:42:50 <asdf1234> bennofs: there's an http package ;)
09:43:02 <donri> and it's now 10x faster!
09:43:07 <bennofs> Just something like simpleHTTP, without conduit, but supporting HTTPS?
09:43:10 <bennofs> donri: :)
09:43:25 <donri> bennofs: also http-streams
09:43:44 <donri> and curl, which loves to segfault
09:43:45 <pmade> bennofs: Take a look at the new http-client.
09:44:08 <asdf1234> simpson: haha, how so?
09:44:21 <pmade> bennofs: http-client was extracted from http-conduit.
09:44:32 <asdf1234> donri: just run it in real mode
09:44:38 <donri> ?
09:44:48 <merijn> donri: To avoid segfaults, it's a joke ;)
09:45:01 <simpson> asdf1234: Read the RFCs for IRC. Encoding is totally unspecified and negotiation is ad-hoc. We use UTF-8 by convention, but there are many IRC networks that use Shift-JIS or Big5 and there's no indication of that anywhere in the protocol.
09:45:02 <donri> i don't know what real mode is
09:45:15 <merijn> donri: kernel mode with direct addressing
09:45:23 <Eduard_Munteanu> Shouldn't a bifunctor expose bimap :: (a -> b -> (c, d)) -> f a b -> f c d?
09:45:48 <bennofs> @ty bimap
09:45:49 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
09:45:53 <srhb> Alternatively I want to "choice parsers" while there is new input, removing the first parser each time.
09:45:54 <donri> oic
09:46:05 <srhb> Maybe I'm just imagining that this is a general pattern :P
09:46:31 <Eduard_Munteanu> Bifunctor is more like F :: (C -> C) x (C -> C)
09:47:01 <asdf1234> simpson: you're right, that is a mess
09:47:58 <asdf1234> srhb: generally, while one instance of a parser is running, it can't tell that there is or isn't new input.. it just has a stream of some sort coming in.. I'm not sure what you want to do
09:48:05 <Eduard_Munteanu> Wait, I remember a bifunctor theorem.
09:48:16 <bennofs> Eduard_Munteanu: But then Either isn't a bifunctor anymore, is it?
09:48:28 <srhb> asdf1234: Which is good. A failure inside a parser is a catastrophic failure that I want to bail out on. But if I run out of input "between parsers" that's fine.
09:48:32 <bennofs> I guess bifunctor in haskell just means covariant in the first and second argument
09:48:35 <klugez> simpson: To be fair not many programs that started in 1988 got Unicode right.
09:49:13 <asdf1234> srhb: so you want to use one parser, and then if there's a failure, backtrack and try with another, right?
09:49:36 <srhb> asdf1234: Yes, and each time one parser fails, I will never want to try that parser or parsers before it in the list again.
09:50:20 <asdf1234> srhb: ok, so that's what choice is for :3
09:50:20 <srhb> So choice (1,2,3), choice (2,3) -- 1 failed, two succeeded, then I ran out of input. I get only [result of 2]
09:50:24 <srhb> Hmm!
09:50:29 <srhb> Can you elaborate? :P
09:51:13 <asdf1234> srhb: what library are you using?
09:51:13 <Eduard_Munteanu> bennofs: you can convert (a -> c) -> (b -> d) -> ... into (a -> b -> (c, d)) -> ...
09:51:18 <srhb> asdf1234: attoparsec
09:51:44 <levi> simpson: I am implementing a haskell IRC server now. The RFCs are a bit of a joke. The original is horribly underspecified, while the more updated ones are mostly ignored by real implementations. :P
09:51:50 <asdf1234> srhb: the choice combinator tries to parse input with a list of parsers
09:52:10 <asdf1234> srhb: if one succeeds, it moves on to the next step
09:52:10 <srhb> asdf1234: Yes.
09:52:28 <asdf1234> srhb: if one fails, it tries the next sequentially in the list
09:52:53 <srhb> asdf1234: Right. And say [1,2,3,...] -- 1 fails, two succeeds. Now I want to try only from 3 upwards and collect their results as well
09:53:08 <Eduard_Munteanu> :t curry (***)
09:53:09 <lambdabot>     No instance for (Arrow (,)) arising from a use of `***'
09:53:09 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
09:53:09 <lambdabot>     In the first argument of `curry', namely `(***)'
09:53:11 <quchen> srhb: Like this? http://lpaste.net/96837
09:53:17 <Eduard_Munteanu> :(
09:53:21 <quchen> And then stick it in 'many' if you need it multiple times
09:53:54 <Eduard_Munteanu> :t curry (***) ?x
09:53:55 <lambdabot>     Could not deduce (Arrow (,)) arising from a use of `***'
09:53:56 <lambdabot>     from the context (?x::a)
09:53:56 <lambdabot>       bound by the inferred type of
09:53:59 <srhb> quchen: Err.. Let me just parse that. :-)
09:54:16 <Eduard_Munteanu> :t curry (?f *** ?g)
09:54:16 <lambdabot> (?f::b -> c, ?g::b' -> c') => b -> b' -> (c, c')
09:54:22 <bennofs> Eduard_Munteanu: to run a function (a -> b -> (c,d)), I need both an 'a' and a 'b'
09:54:26 <asdf1234> srhb: so you want to fold over a list of parsers, basically? :P
09:54:46 <bennofs> Eduard_Munteanu: if I have a function (a -> c) and a function (b -> d), I can already get a c if I only have an 'a'
09:54:47 <srhb> asdf1234: Basically yes, but shortcircuiting of I run out of input "between parsers"
09:55:13 <wojtekM_> I need some help by an expert in optics. I'm trying to create Data.Thyme.UTCTime from components. I have year, month, day, hour, minute, second as separate Ints. I've been trying to figure it out by myself for a fair while, to no avail. I believe the reason of my failure to be lenses.
09:55:19 <srhb> I think that's my problem, folds don't short-circuit.
09:55:46 <quchen> Folds can short-circuit
09:55:51 <srhb> Oh?
09:55:51 <Eduard_Munteanu> bennofs: yes, but it's trivial because bimap f id and bimap id g are functorial in each component separately
09:56:19 <bennofs> Eduard_Munteanu: can you write bimap :: (a -> b -> (c,d)) -> Either a b -> Either c d?
09:56:30 <asdf1234> wojtekM_: can you rephrase?
09:57:00 <asdf1234> wojtekM_: Oh. I don't think you can build UTCTime.
09:57:28 <asdf1234> wojtekM_: time is very finicky about maintaining its integrity
09:58:02 <Eduard_Munteanu> bennofs: sure... bimap (curry (Left *** Right))
09:58:11 <Eduard_Munteanu> :t curry (Left *** Right)
09:58:12 <lambdabot> a -> b1 -> (Either a b, Either a1 b1)
09:58:27 <wojtekM_> asdf1234: Sure you can. But I just have no idea how.
09:58:38 <Eduard_Munteanu> Er.
09:59:41 <quchen> srhb: Try implementing Data.List.find with foldr!
09:59:43 <asdf1234> wojtekM_: convert your time to the difference between the TAI epoch and the time you want and then convert it to UTC?
10:00:03 <quchen> find p = foldr ? ?
10:00:05 <Eduard_Munteanu> bennofs: given f, g such that bimap f g :: Either a b -> Either c d, f :: a -> b, g :: c -> d. I can translate that to bimap' (curry (f *** g)).
10:00:12 <jle`> can someone explain to me why Alternative requires Applicative?
10:00:26 * hackagebot zip-archive 0.2 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.2 (JohnMacFarlane)
10:00:38 <asdf1234> jle`: because that's how it's defined :P
10:00:42 <fizruk> bennofs, assuming c depends on a only and d depends on b only, one can use bottom to get c/d from (a -> b -> (c, d)) ?
10:00:46 <wojtekM_> asdf1234: UTCTime (gregorian # YearMonthDay 1000 1 1) ????
10:00:50 <Eduard_Munteanu> @djinn ((a -> b), (c -> d)) -> (a -> c -> (b, d))
10:00:50 <lambdabot> f (a, b) c d = (a c, b d)
10:00:55 <Eduard_Munteanu> bennofs: ^
10:01:02 <bennofs> Eduard_Munteanu: but you wan't to do it the other way around, no?
10:01:06 <jle`> but could we have an Alternative on Functors instead?
10:01:11 <Eduard_Munteanu> jle`: Alternative is a monoid on Applicatives
10:01:15 <bennofs> So Either is not a bifunctor=
10:01:17 <bennofs> ?
10:01:36 <bennofs> @djinn (a -> b -> (c,d)) -> Either a b -> Either c d
10:01:36 <lambdabot> -- f cannot be realized.
10:01:37 <asdf1234> wojtekM_: where does UTCTime come from?
10:01:38 <Eduard_Munteanu> bennofs: Either is a bifunctor, just that not all bifunctors are Bifunctors as currently defined.
10:01:45 <jle`> Eduard_Munteanu: is there a parallel concept on functors?
10:01:47 <asdf1234> wojtekM_: the constructor isn't exported from Data.Time
10:01:50 <jle`> a monoid on functors
10:02:01 <bennofs> Eduard_Munteanu: Either cannot have the dimap you proposed
10:02:06 <Eduard_Munteanu> jle`: there's one on Monad, which is MonadPlus.
10:02:30 <bennofs> @djinn (a -> c) -> (b -> d) -> Either a b -> Either c d
10:02:30 <lambdabot> f a b c =
10:02:30 <lambdabot>     case c of
10:02:30 <lambdabot>     Left d -> Left (a d)
10:02:30 <lambdabot>     Right e -> Right (b e)
10:02:51 <jle`> Eduard_Munteanu: yeah i have heard...and the properties/laws for MonadPlus are all based on their behavior under >>=
10:03:09 <jle`> so I see that in MonadPlus, their monad-ness is essential in their behavior
10:03:13 <wojtekM_> asdf1234: From Data.Thyme.Clock.POSIX
10:03:30 <jle`> but for Alternative, their behavior/laws are based on <|>, which does not seem to have anything to do with pure or <*>
10:04:14 <asdf1234> wojtekM_: have a look at Data.Thyme.Clock.TAI
10:04:15 <wojtekM_> asdf1234: I will not believe someone wrote a time handling library without the ability to create a time value.
10:04:18 <Eduard_Munteanu> jle`: it is... compare it for Maybe. Nothing is both mzero and empty
10:04:32 <Eduard_Munteanu> jle`: for Applicatives, <*> matters
10:04:49 <Eduard_Munteanu> jle`: x >>= f  ~   f <*> x
10:04:53 <asdf1234> wojtekM_: problem is that time is really complicated :P ... if you want difftimes, it's fairly easy.. as for creating times in the future, well, those are subject to change
10:05:05 <asdf1234> wojtekM_: same with in the past
10:05:27 * hackagebot haskintex 0.3.1.0 - Haskell Evaluation inside of LaTeX code.  http://hackage.haskell.org/package/haskintex-0.3.1.0 (DanielDiaz)
10:05:39 <asdf1234> wojtekM_: your only fixed point of reference is the present and the haskell time libraries reflect that
10:06:11 <Eduard_Munteanu> jle`: mempty `mplus` x = x  ~   empty <|> x = x
10:06:28 <bennofs> I wonder why thyme doesn't define monoid instance for it's time difference
10:06:30 <fizruk> Eduard_Munteanu, that law does not use <*> or pure
10:06:30 <bennofs> s
10:07:01 <Eduard_Munteanu> Sure, I wasn't there yet. :)
10:07:08 <fizruk> Eduard_Munteanu, perhaps `m1 *> empty <|> m2 = m2` or something will do :)
10:07:17 <wojtekM_> asdf1234: Yes, time handling is complicated indeed. But Data.Time and Data.Thyme seem fairly advanced.
10:07:31 <asdf1234> wojtekM_: they try to make it hard for you to mess up
10:07:48 <jle`> Eduard_Munteanu: what i'm saying is that MonadPlus's laws involve >>=, but Alternative's laws don't involve <*>
10:08:22 <jle`> in fact I could define something with identical behavior to Alternative with non-applicatives? even non-functors?
10:08:23 <fizruk> jle`, f <*> empty <|> y = y
10:08:27 <wojtekM_> asdf1234: If that's the case, they won. But I do believe there is intrinsic complexity, too.
10:08:27 <asdf1234> wojtekM_: what I'd do is calculate a difftime from taiEpoch and then convert it to utctime
10:08:31 <jle`> fizruk: ah okay
10:08:42 <Eduard_Munteanu> jle`: find me one x such that x <|> y = y, with x different from empty, made out of pure only. :)
10:09:31 <wojtekM_> asdf1234: I can calculate the number of seconds from hour, minute, second, but I was after an elegant way.
10:10:12 <wojtekM_> asdf1234: Elegant would mean converting TimeOfDay to DiffTime, I believe.
10:10:29 <Eduard_Munteanu> jle`: it should be straightforward to prove   pure f <*> pure x <|> _ = f x
10:10:35 <wojtekM_> asdf1234: But there are lenses involved, I don't get them.
10:10:55 <Eduard_Munteanu> Er, pure (f x)
10:11:07 <asdf1234> wojtekM_: you can go from time of day to difftime with timeOfDayToTime
10:11:19 <jle`> acutally, where can i find these Alternative laws that I have been referring to?
10:12:06 <asdf1234> wojtekM_: you shouldn't need a lens to do that; just use your unadulterated time
10:12:31 <Eduard_Munteanu> jle`: the docs say "a monoid for Applicatives" which is pretty much sufficient to derive them
10:12:50 <Eduard_Munteanu> @where typeclassopedia
10:12:50 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
10:13:07 <jle`> i feel like you could also derive a monoid on applicatives as a Last-type monoid, not just a First-type one
10:13:12 <quchen> Eduard_Munteanu: pure f <*> pure x = pure (f x) is an Applicative law I think. That leaves the equation with "pure (f x) <|> _" which depends on the Alternative you're using.
10:14:21 <wojtekM_> asdf1234: Okay, I see it.
10:14:22 <Eduard_Munteanu> quchen: the latter can only be the rhs of <|> only if pure (f x) is empty too.
10:14:22 <quchen> I think Alternative doesn't have laws involving <*> because nobody bothered with having that discussion lately.
10:14:38 <wojtekM_> asdf1234: timeToTimeOfDay = view timeOfDay
10:15:21 <Eduard_Munteanu> :t liftA2
10:15:22 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:15:26 <Eduard_Munteanu> Er.
10:15:27 <fizruk> jle`, correct, the particular instance is just handy when you treat alternatives as backtracking computations, I think
10:15:36 <Eduard_Munteanu> :t liftA2 ($)
10:15:37 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
10:16:01 <asdf1234> wojtekM_: that will give you a difftime from the start of the day, though, I believe
10:16:04 <quchen> Eduard_Munteanu: What about right-biased <|>?
10:16:48 <Eduard_Munteanu> quchen: yeah, though that's only relevant for shortcut evaluation.
10:16:50 <jle`> fizruk: this 'handy' instance is enforced by the laws of MonadPlus, but unenforced by the laws of Alternative?
10:17:07 <fizruk> jle`, alternative is a monoid but, as applicativeness implies some effects, it is reasonable to execute as little effects as possible
10:17:07 <Eduard_Munteanu> quchen: you could say  x <|> empty = x  and  empty <|> x = x  disregarding that
10:17:07 <asdf1234> jle`: monadplus is a clusterfuck
10:17:08 <jle`> (the concept of a 'handy' instance)
10:17:38 <quchen> It's not clusterfuck, it just has one law that's probably a bad idea, m >> mzero = mzero.
10:18:23 <quchen> Associativity is certainly useful, and "mzero >>= _= mzero" also makes sense for most (all?) standard instances.
10:18:56 <Eduard_Munteanu> quchen: also, if (Applicative f) and (Monoid t), then liftA mconcat = foldr (<|>) mempty
10:18:59 <Eduard_Munteanu> :t mconcat
10:19:00 <lambdabot> Monoid a => [a] -> a
10:19:46 <Eduard_Munteanu> :t liftA mconcat
10:19:47 <lambdabot> (Applicative f, Monoid b) => f [b] -> f b
10:20:33 <Eduard_Munteanu> Er, that's misleading on my part.
10:20:41 <asdf1234> does "mzero >>= _ = mzero" make sense for lists? :/
10:20:44 <quchen> I was about to ask where this is going :-)
10:20:59 <jle`> here's how i feel, I think.  Alternative behaves like a First-like monoid and is for the most part no different.  However, it useful to imagine Applicative actions that "branch and try", backtracking out.  This branching-and-trying (that the *intent* of an Applicative is to be sequenced in parallel) is the true spirit of Alternative
10:21:03 <jle`> and the meaning of Christmas
10:21:07 <quchen> asdf1234: Sure. mzero = [], and >>= is concatMap. concatMap f [] = [].
10:21:23 <jle`> asdf1234: mzero >>= _ = mzero is indeed meaningful for lists
10:22:08 <jle`> > return 5 >> mzero >> return 6 >> return 7 :: [Int]
10:22:09 <lambdabot>  []
10:22:16 <Eduard_Munteanu> quchen: I wanted to say f should preserve monoidal structure.
10:22:31 <quchen> Ah.
10:22:48 <quchen> Eduard_Munteanu: But in the bigger picture, "empty <*> _ = empty" is not implied by this, right?
10:22:54 <cariveri> Hi. does anyone know example code with capturing keyboard controles liek Ctrl+x , shift key and so on?
10:23:14 <asdf1234> > return 5 >>= []
10:23:16 <lambdabot>  Couldn't match expected type `a0 -> m0 b0' with actual type `[a1]'
10:23:18 <fizruk> jle`, I haven't seen Alternative with a different meaning than branching-and-trying, though I'm not 100% sure that's correct for all real cases
10:23:25 <jle`> quchen: i think <*> can be thought of as an in-series action, and <|> can be thought of as a parallel action
10:23:29 <quchen> > return 5 >> []
10:23:30 <lambdabot>  []
10:23:33 <jle`> so in a sense they are on completely different domains
10:23:46 <quchen> Sure, but then so are >>= and mplus
10:23:51 <fizruk> jle`, not completely, you have empty!
10:23:51 <Eduard_Munteanu> quchen: that's not a law for Alternative I think.
10:24:07 <quchen> Eduard_Munteanu: Right. But it's the equivalent of "mzero >>= _ = mzero"
10:24:30 <jle`> also consider, asdf1234
10:24:33 <quchen> So the question initially asked was why there are no laws between Alternative and Applicative besides the constraint
10:24:38 <Eduard_Munteanu> quchen: oh, well... I guess so. MonadPlus is more like a ring.
10:25:09 <jle`> > [1..10] >>= (\x -> guard (even x) >> return x)
10:25:11 <lambdabot>  [2,4,6,8,10]
10:25:24 <jle`> mzero is the result of [1], [3], etc.
10:25:24 <vlopez> @free fmap
10:25:25 <lambdabot> Extra stuff at end of line in retrieved type "Functor f => (a -> b) -> f a -> f b"
10:25:28 <Eduard_Munteanu> quchen: however, note empty <|> x = x makes it rather difficult not having empty <*> x = empty
10:25:37 <jle`> so attempting to `return` out of an mzero gives you nothing in the end
10:25:53 <vlopez> @free fmap
10:25:54 <lambdabot> Extra stuff at end of line in retrieved type "Functor f => (a -> b) -> f a -> f b"
10:26:36 <quchen> Eduard_Munteanu: How so?
10:26:56 <jle`> quchen: that wa sa distinction I saw; MonadPlus defines series behavior, Alternative defines parallel behavior
10:27:17 <fizruk> jle`, if empty should represent a "backtrack" command, then you should expect empty <*> x == empty (i.e. no actions are being executed after a backtrack command)
10:27:30 <jle`> and how you treat success/failure in the context of series vs the context of parallel
10:28:00 <asdf1234> I concede that mzero >>= _ = mzero makes sense :P
10:28:01 <fizruk> jle`, did you mean Applicative instead of MonadPlus?
10:28:14 <quchen> I don't see how "empty <|> x" is related to "empty <*> _ = empty" :-\
10:28:26 <fizruk> quchen, it's not? :)
10:28:28 <quchen> (Or "difficultly related")
10:28:29 <jle`> fizruk: I split my statement into two lines, unfortunately.  I was talking exclusively in the context of failure/success
10:28:39 <jle`> Applicative does not have the concept of failure/success inherently
10:28:49 <quchen> fizruk: I was referring to Eduard_Munteanu's comment above ("quchen: however ...")
10:29:46 <jle`> i feel like if anything, x <*> empty = x is the "implied behavior"
10:29:47 <Eduard_Munteanu> quchen: well, usual patterns go like  f <*> x <|> g <*> y <|> ... . For f <*> x = pure f' <*> pure x' = pure (f' x') = empty implies stuff like pure id <*> pure x = pure (id x) = pure x empty  which is rather trivial.
10:29:56 <fizruk> jle`, but once you mention "trying" in "branching-and-trying" you have to talk about failure/success, don't you?
10:30:03 <Eduard_Munteanu> = empty
10:30:18 <jle`> fizruk: the the success/failure concept comes from Alternative
10:30:23 <jle`> it is not inherent to Applicative
10:30:28 <jle`> many applicatives do not involve a trying/failure concept
10:30:38 <jle`> but alternatives must
10:30:54 <jle`> or rather, alternative is where that concept 'enters the picture'
10:31:14 <jle`> just like how monadplus is where success/failure 'enters the picture' for monads
10:32:07 <Eduard_Munteanu> quchen: so pure _ = empty. Now, if there's x /= empty such that empty <*> x = x, I think it violates functor laws.
10:32:25 <fizruk> > pure 1 :: [Int]
10:32:26 <lambdabot>  [1]
10:32:33 <fizruk> > empty :: [Int]
10:32:34 <lambdabot>  []
10:33:11 <Eduard_Munteanu> quchen: because f and pure (\x -> f x) should be equivalent fmap-wise
10:33:13 <quchen> Eduard_Munteanu: Hmm, makes sense
10:33:36 <fizruk> jle`, can't find your message I was referring to :)
10:33:48 <quchen> Although that's going around a lot of corners to arrive at the conclusion.
10:33:56 <jle`> fizruk: "but once you mention..."
10:34:04 <jle`> i might have misinterpreted
10:34:08 <jle`> :)
10:34:09 <Eduard_Munteanu> Er. fmap f vs (pure f <*>)
10:34:22 <Eduard_Munteanu> :t (pure f <*>)
10:34:22 <lambdabot> (Show a, Applicative f, FromExpr b) => f a -> f b
10:34:23 <asdf1234> :t fmap f
10:34:24 <lambdabot> (Functor f, Show a, FromExpr b) => f a -> f b
10:34:38 <quchen> That equivalence is an Applicative law even.
10:34:40 <asdf1234> nice timing
10:34:52 <joelteon> :t (pure ?f <*>)
10:34:53 <lambdabot> (Applicative f, ?f::a -> b) => f a -> f b
10:36:21 <Eduard_Munteanu> Which means  fmap f x = empty,  leaving only effectful computations non-empty. But fmap id isn't an identity for those.
10:40:38 <asdf1234> I hate when super glue super-glues its container shut.
10:41:03 <Elision> for a minute I thought that was supposed to be some metahor for a haskell problem
10:41:23 <Eduard_Munteanu> It's like Nothing making a mess out of Just something.
10:41:37 <Elision> I really want it to be
10:41:49 <jle`> i feel like alternative's behavior is only meaningful if pure x <*> empty = pure x and that should be a satisfying link to applicative.  however, I feel like it is unable to distinguish, without explicit laws, a left-favoring or a right-favoring implementation
10:41:55 <asdf1234> heheh
10:42:10 <jle`> Elision: perhaps he is referring to types that do not export their data constructors?
10:42:20 <jle`> so you cannot pattern match things out of them?
10:42:47 <jle`> but that doesn't involve anything gluing itself
10:42:50 <jle`> hm.
10:42:54 <jle`> i am at a loss.
10:43:04 <fizruk> > pure (+1) <*> []
10:43:06 <lambdabot>  []
10:43:16 <Elision> heh
10:43:38 <Eduard_Munteanu> jle`: it can define it like  Just x <*> _ = Just x, Nothing <*> _ = Nothing
10:43:42 <Elision> yeah, me too
10:44:01 <jle`> Eduard_Munteanu: hm?
10:44:06 <Eduard_Munteanu> Er.
10:44:09 <Elision> maybe something along the lines of tying a knot with the state monad that gets itself in a mess?
10:44:29 <Eduard_Munteanu> Just f <*> Just x = f x
10:44:52 <Eduard_Munteanu> Just (f x), bleh
10:44:56 <monochrom> it is simpler to say: I hate it when an infinite loop infinitely loops.
10:45:03 <fizruk> Eduard_Munteanu, hm.. empty <*> x might be neither empty nor x
10:46:02 <fizruk> Eduard_Munteanu, so empty <*> x = empty is not following from monoid and applicative laws?
10:46:07 <jle`> i feel like empty must be chosen to satisfy x <*> empty = x
10:46:35 <jle`> i do not know if i can make a conclusin about empty <*> x though
10:46:39 <Rc43_> Why this is impossible from theoretical point? http://lpaste.net/96841
10:47:02 <fizruk> jle`, empty ~ "backtrack", so x <*> empty ~ empty
10:47:03 <Eduard_Munteanu> jle`: you want  x <*> empty = x  usually
10:47:06 <Eduard_Munteanu> Blah.
10:47:13 <Eduard_Munteanu> x <*> empty = empty
10:47:25 <Rc43_> I understand that r has type Either Int String, but why there is no polymorphism or something else?
10:47:35 <Eduard_Munteanu> fizruk: but if it uses 'x', then it ignores empty, right?
10:47:36 <jle`> oh yeah
10:47:41 <jle`> sorry, i see my confusion
10:47:48 <c_wraith> Rc43_: because r's type prevents it from being a value of the response, regardless of the expression that created it.
10:47:53 <asdf1234> rc43: because you forgot your unsafeCoerce# :P
10:47:58 <geekosaur> you told it not to deconstruct, but it needs to deconstruct and reconstruct. it is not polymorphic, it has a specific type which is wrong
10:48:10 <geekosaur> you are looking for duck typing, you won't find it here
10:48:29 <fizruk> jle`, is some cases though you can't "undo" some effects (e.g. IO), so f <*> empty = empty does not necessarily hold
10:48:31 <Rc43_> c_wraith, why term can't have two types?
10:48:40 <geekosaur> ???
10:48:43 <jle`> fizruk: well IO is not an alternative for that reason :P
10:48:56 <c_wraith> Rc43_: because that'd make type checking useless?
10:49:02 <geekosaur> right, you want duck typing. why term can't have two types = terms have one type by definition
10:49:04 <jle`> send_missiles <|> sign_treaty
10:49:13 <Rc43_> asdf1234, I didn't, just doint generation of java code from functional language and thought about shuld I bind all type variables to generic parameters or not
10:49:15 <fizruk> jle`, isn't it? O_o
10:49:32 <geekosaur> that type might be polymorphic, but is not in  this case, you gave it a specific type
10:49:50 <Eduard_Munteanu> fizruk: I mean it can't possibly support  pure f <*> empty /= empty  without stumbling onto  fmap f empty /= empty  and by parametricity you shouldn't really be able to check for empty.
10:50:02 <fizruk> jle`, ok it's MonadPlus anyway which is the same thing
10:50:17 <Rc43_> geekosaur, there is no way to do it safely in theory or it it is just not done in haskell by any reasons?
10:50:25 <jle`> fizruk: monadplus deals with series, alternative deals with parallel
10:50:38 <asdf1234> Rc43_: class IsIntOrBool a  :D
10:50:44 <geekosaur> Rc43_, are you confusing implementation with typing?
10:51:07 <geekosaur> I would expect that with optimization enabled, it actually does optimize away the deconstruct/reconstruct. but you still have to get the type right
10:51:24 <fizruk> jle`, MonadPlus is Alternative for Monads
10:51:26 <geekosaur> and you are asking: make my strictly typed language not typed here
10:51:34 <c_wraith> Rc43_: the problem is that doing that coercion often is *wrong*.  Types exist to prevent bugs.  If you just tell the compiler to add coercions wherever it is possible, it prevents fewer bugs.
10:51:40 <geekosaur> if you want to call that theory, then yes, it is theory
10:51:41 <Eduard_Munteanu> I'm not sure whether you can prove it though, I'll think about it.
10:52:29 <Rc43_> geekosaur, I don't talk about dynamic types; just constructors could catch not all parameters of their "type", but only parameters they use (here String but not Int and String)
10:52:39 <geekosaur> I have no idea what you just said
10:53:02 <jle`> fizruk: monadplus's deal with >>= typically.  although there is mplus but nobody uses that and it should have belonged in applicative >.>
10:53:02 <Eduard_Munteanu> I don't think Alternative is all that parallel, it's only parallel for backtracking Applicatives.
10:53:12 <Eduard_Munteanu> But that's true of MonadPlus too.
10:53:20 <geekosaur> you have Either Int String, you want to use it as Either Bool String without making the type right
10:53:27 <c_wraith> Rc43_: remember.  Types exist to *prevent bugs*. If you say "go ahead and accept wrong types sometimes if you see a way it'd maybe work", you're missing the whole point.
10:53:29 <geekosaur> yes, in point of fact, you want a duck type
10:53:30 <fizruk> jle`, if you deal with >>= you
10:53:36 <fizruk> jle`, you
10:53:46 <geekosaur> you can justify it to yourself however you wish, but you want to ignore the type there
10:53:48 <asdf1234> geekosaur: he doesn't understand why the int/bool bit matters since it doesn't factor into the implementation at all
10:54:00 <fizruk> jle`, you're dealing with Monad, MonadPlus arises when you start to use mzero and mplus
10:54:38 <geekosaur> asdf1234, yes, I know that. but the answer is "the typechecker says so. no, you cannot switch off the type checker"
10:54:46 <monochrom> this is a case of: people who haven't designed and validated a type system think that changing an existing type system by a little bit is easy
10:54:52 <Rc43_> c_wrait, not the same that I suggested; in my "possible" typing you still can't put "Left Integer" into "Either Bool String".
10:55:36 <Rc43_> c_wrait, I don't tell that this possible typeing is good or something, just possible
10:55:37 <c_wraith> Rc43_: but r is the argument to the function.  The argument is a value of type Either Int String.  No, you can't use it where you promised you'd provide a value of type Either Bool String
10:55:42 <jle`> fizruk: i guess yes, MonadPlus and Alternative technically define the same things, functionality-wise.  but it's commonly accepted that Alternative should really be what owns <|>/mplus, and MonadPlus is really what owns >>=, i think
10:56:04 <fizruk> jle`, no
10:56:06 <asdf1234> Either Int String -> Either Bool String is very doable, but you either have to coerce the r or deconstruct and reconstruct it
10:56:13 <jle`> this is becuase mplus/<|> do not require >>= to work, they have nothing to do with sequencing
10:56:29 <Rc43_> c_wraith, I can't in concrete type system of haskell; but why it is done so? Does it create holes for new bugs?
10:56:39 <fizruk> jle`, http://stackoverflow.com/questions/10167879/distinction-between-typeclasses-monadplus-alternative-and-monoid
10:56:53 <jle`> http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
10:57:00 <asdf1234> Rc43_: because r in your function is of type Either Int String, not of type Either Bool String
10:57:12 <c_wraith> Rc43_: you can't do it because they have different types.  The type checker does not care in the slightest what the values are.
10:58:11 <c_wraith> Rc43_: it says "you told me the argument is of type Either Int String.  You told me the result is of type Either Bool String.  Now you're telling me to use the argument as the result?  This makes no sense!"
10:58:50 <asdf1234> Rc43_: similar to how you can't get subclass methods without casting in OO languages
10:59:12 <fizruk> jle`, Applicative/Alternative were defined *after* Monad/MonadPlus were defined
10:59:45 <Rc43_> c_wrait, I mean other; we could generalize branchs of pattern matching; analogy -- it is like adt and gadt; in adt you can't specify parameters for every constructor.
10:59:55 <fizruk> jle`, so Monad should have an Applicative superclass while MonadPlus should be just Alternative
11:00:09 <simpson> :t Right 42
11:00:10 <lambdabot> Num b => Either a b
11:00:12 <Rc43_> asdf1234, c_wraith; guys, I understand why it is impossible in haskell; I am talking about other
11:00:26 <c_wraith> Rc43_: Sure, you could hack in something like that.  But it'd ignore the purpose of having a type system.
11:00:40 <geekosaur> it's not even impossible in haskell if you consider unsafeCoerce :p
11:00:49 <asdf1234> ^
11:01:03 <Rc43_> c_wraith, ye, may be; but still not sure fully
11:01:07 <Rc43_> geekosaur, :)
11:01:14 <c_wraith> Rc43_: the whole purpose is preventing bugs. If you start allowing terms of the wrong type to be implicitly coerced because they "look right", you *will* get bugs.
11:02:09 <maurer> Rc43_: If you wanted something that coerced types, it migh tmake snese to build that as an editor/ide extension
11:02:11 <geekosaur> hm, does anyone have some examples of code where someone introduced a poorly considered typeclass instance and ghc proceeded to infer some very surprising types?
11:02:19 <maurer> Rc43_: in the sense that you build, and then when it doesn't work, it says "Did you mean X?"
11:02:29 <geekosaur> because that's pretty much what we're talking about here if you allow it to "guess" what you intended
11:02:32 <maurer> Rc43_: but you really don't want to put that into the core language
11:02:56 <asdf1234> maurer: well, not haskell anyway
11:03:07 <fizruk> Eduard_Munteanu, you can have `empty <*> x` differ from both `x` and `empty` while having `pure f <*> x = f <$> x`
11:03:17 <maurer> asdf1234: I mean, I don't really like dynlangs in general. I am not super sold on them.
11:03:23 <maurer> asdf1234: but at minimum not in haskell
11:04:00 <Rc43_> maurer, such ide extension would be nice
11:04:05 <maurer> asdf1234: I could see the usefulness of correction suggestions in an editor though to catch silly things like forgetting to newtype box/unbox, or forgetting to remove from an error monad
11:04:22 <maurer> Rc43_: My point is that if you wanted this, that would be where you build it, not the compiler
11:04:25 <fizbin> Huh. You know, the way the Scala type system works and the way the scala case match works, you might be able to do something like the crazy Either Int String -> Either Bool String stuff Rc43_ wanted in that language.
11:04:29 <maurer> Rc43_: because you want the source to be unambiguous
11:04:49 <fizbin> That is, I think in scala you could do something like:
11:06:10 <fizbin> def scalaCoerceyThing(arg : Either[Int][String]): Either[Bool][String] = arg match { case r@Right(_) => return r; case _ => return Left(false); }
11:07:25 <simpson> :t \x -> case x of { Right x -> Right x; _ -> Left False }
11:07:26 <lambdabot> Either t b -> Either Bool b
11:07:53 <fizbin> Because I think that scala sets up a type hierarchy such that Right and Left are subclasses of Either, with generic parameters such that Left[Foo] is a subtype of Either[Foo][Bar] for all Bar.
11:08:13 <fizbin> :t \x -> case x of { r@(Right _) -> r; _ -> Left False }
11:08:13 <lambdabot> Either Bool t -> Either Bool t
11:08:18 <fizbin> Oh.
11:08:23 <fizbin> That was unexpected.
11:08:29 <asdf1234> I'll be damned if I can figure out scala
11:08:30 <monochrom> yes geekosaur, lambdabot had (and has? dunno) Num instances for functions, therefore there were a lot of suprises such as 1 2 3. also, if string literals like "123" are typeclass-polymorphic such as IsString a => a, then see article.gmane.org/gmane.comp.lang.haskell.cafe/101620/ for more surprises such as "1" "2" "3". in general, bad classes and bad instances leading to surprises are not only possible, but are already in production code.
11:08:31 <Rc43_> fizbin, ha, maybe scala can do this because of the same reasons that I thought
11:08:43 <Rc43_> fizbin, (I generate java code for data types)
11:10:39 <asdf1234> :t \x -> case x of {(Left _) -> Left True; _ -> unsafeCoerce x}
11:10:40 <lambdabot> Not in scope: `unsafeCoerce'
11:10:42 <monochrom> well, in general, type cavalierism is popular
11:10:52 <fizbin> :t (\x -> case x of { Right x -> Right x; _ -> Left False }) :: (Either Int String -> Either Bool String)
11:10:53 <lambdabot> Either Int String -> Either Bool String
11:11:15 <fizbin> :t (\x -> case x of { r@(Right _) -> r; _ -> Left False }) :: (Either Int String -> Either Bool String)
11:11:16 <lambdabot>     Couldn't match type `Int' with `Bool'
11:11:16 <lambdabot>     Expected type: Either Bool String
11:11:16 <lambdabot>       Actual type: Either Int String
11:11:24 <asdf1234> fizbin: you rebuilt the Right size though :P .. he wants to just coerce it
11:11:38 <fizbin> See, I think that the equivalent will compile in scala.
11:11:44 <asdf1234> :t \x -> case x of {(Left _) -> Left True; _ -> Unsafe.Coerce.unsafeCoerce x}
11:11:45 <lambdabot> Either t t1 -> Either Bool b
11:12:04 <asdf1234> :t \x -> case x of {(Left _) -> Left True; _ -> Unsafe.Coerce.unsafeCoerce x} :: Either Int String -> Either Bool String
11:12:05 <lambdabot>     Couldn't match expected type `Either Int String
11:12:05 <lambdabot>                                   -> Either Bool String'
11:12:05 <lambdabot>                 with actual type `Either Bool b0'
11:12:12 <asdf1234> lol
11:12:48 <fizbin> Well, not the equivalent to what asdf1234 just said. It'll have to be explicitly a case with "Right", not a "case _"
11:13:05 <fizbin> I should go wander over to #scala and try it on their bot.
11:16:09 <fizbin> Woop.
11:16:28 <asdf1234> beep boop
11:16:34 <fizbin> I was wrong; scala can't do it and fails for approximately the same reason haskell does.
11:16:52 <asdf1234> to javascript!
11:19:49 <fizbin> Though I think that's a deficiency in the scala standard lib, and that one could make Either, Left, and Right so that it'd work.
11:20:33 <jle`> fizbin: they were defined after monad/monadplus, so that's a rather unfortunate cause of the current implementation.  i was referring to their functional purpose, however, and their behavior in an ideal world
11:21:03 <jle`> their 'intent'/function so to speak
11:21:37 <jle`> http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal addresses the difference, and the ideal way alternative and monadplus would work together, which makes clear their separation of purpose
11:22:11 <jle`> actually it doesn't
11:22:12 <jle`> oops
11:22:16 <jle`> i could have sworn it did
11:22:18 <fizruk> jle`, their intent functionality is the same
11:22:51 <fizbin> Oh. I wondered why jle` was talking to me about MonadPlus.
11:23:06 <fizbin> fiz* name confusion strikes again!
11:23:13 <fizruk> fizbin, I though you got used to that :)
11:23:17 <fizruk> *thought
11:23:28 <jle`> haha sorry
11:23:52 <jle`> fizruk: it's a little redundant though isn't it, because mplus does not require anyything from >>=
11:23:52 <fizbin> fizruk: Yeah, but I hadn't seen you around today.
11:24:22 <fizruk> =)
11:24:30 <jle`> also monadplus has different intent than alternative, as is evidened by its stronger rules, right?
11:24:56 <jle`> mplus really belongs in alternative, and if it was the case that monadplus/monad were subclasses of alternative/applicative, i don't think it would even be in monadplus
11:24:59 <jle`> monadplus would be monadzero
11:25:11 <fizruk> jlamothe, intent is the same, it just has stronger constraints (namely Monad constraint and mzero >>= _ = mzero)
11:26:24 <fizbin> Rc43_: Though the standard Scala Either type can't do what you want, the scalaz Either replacement does do what you wanted (the scalaz Either replacement is spelled \/ , http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/#scalaz.$bslash$div )
11:26:39 <fizruk> jle`, that last statement seems to be true, yeah
11:29:38 <jle`> fizruk: (assuming applicative is a superclass to monad) what MonadPlus brings to the table --- why it even exists --- is the mzero >>= _ = mzero.  everything else is "covered" by Alternative.  which is why I say that monadplus's unique usefulness/role in the universe is this mzero >>= _ = mzeroness, whereas alternative's unique role in the universe is for <|>/mplus; although of course if you have a MonadPlus
11:29:40 <jle`> you have <|>, but that's the same as saying if you have a Monad you have pure.  Monads have applicative power just as much as Applicative does, but their unique place in the universe is bind and that is what their "role" is (or else you would just need Applicative)
11:29:47 <jle`> i am a little long winded. i should work on that
11:31:06 <fizruk> jle`, oh I forgot about these competing laws: (a `mplus` b) >>= k = (a >>= k) `mplus` (b >>= k) and (return x) `mplus` m = return x
11:32:27 <jle`> well the second one is the conventional behavior of <|>
11:32:37 <jle`> isn't it?
11:32:40 <fizruk> jle`, the first one (called "left distributive law") is holding for most of instances
11:32:57 <fizruk> jle`, yeah, the second is trivial
11:34:03 <jle`> the first one is nice too, but it complicates my worldview slightly
11:34:05 <jle`> :)
11:34:35 <jle`> but it does continue along the lines of monadplus really just offers a meainigful >>= on success/failures
11:35:48 <fizruk> jle`, the second law is not "conventional", btw
11:35:55 <fizruk> jle`, [] breaks that
11:36:22 <jle`> that's rather unfortunate. so mplus and <|> behavior differently on lists?
11:37:15 <fizruk> jle`, no I told you those laws are "competing" :)
11:37:34 <jle`> oh, are they mutually exclusive?
11:38:13 <fizruk> jle`, not exactly (Maybe fulfills both)
11:38:30 <jle`> i wonder where list fails the second
11:38:54 <fizruk> > [1, 2, 3] <|> [4, 5, 6]
11:38:56 <lambdabot>  [1,2,3,4,5,6]
11:39:05 <fizruk> > return 1 <|> [4, 5, 6]
11:39:06 <lambdabot>  [1,4,5,6]
11:40:46 <FliPPeh> What is the thing called where a data type varies with the selected type class instance?
11:41:26 <FliPPeh> For example, if I were to make a connection type class and make IO a member of it, it should have an accompaning data type that represents the result of connection, like "Handle"
11:41:55 <fizruk> FliPPeh, data type families?
11:42:20 <FliPPeh> fizruk: Yes, that's it! Thanks :)
11:44:58 <jle`> fizruk: ah so it breaks that law but still agrees with <|>
11:45:16 <jle`> ?
11:45:27 <fizruk> jle`, it still forms a monoid :)
11:48:53 <augur_> halp
11:49:00 <augur_> ghc is giving me a horrible error :(
11:49:01 <augur_> http://lpaste.net/96844
11:49:54 <joelteon> oh my dear, that's appalling
11:50:43 <geekosaur> augur_, do you have the command line tools installed?
11:51:11 <geekosaur> (all the non-include file errors are knock-ons from missing definitions, I think)
11:51:42 <augur_> geekosaur: which command line tools?
11:51:48 <jle`> i learned today that i don't like the <|>/mplus instances for list :)
11:52:02 <augur_> jle`: oh? why not?
11:52:06 <FliPPeh> Grah, Haskell is all nice and beautiful until you go up to make your own type classes
11:52:08 <jle`> or rather i am wrestling with it
11:52:09 <FliPPeh> Everything broke!
11:52:12 <jle`> come back to me in a week
11:52:16 <geekosaur> you are on a Mac (/Library/...). you need to install xcode's command line tools for the standard include files to be available
11:52:24 <FliPPeh> I just want a connection typeclass that abstracts away HOW you connect to something :(
11:52:32 <augur_> FliPPeh: inah, making your own type classes is easy!
11:52:46 <shachaf> That doesn't mean you need a type.
11:52:50 <augur_> FliPPeh: show us what you got
11:52:52 <geekosaur> with xcode 5.x, "xcodebuild --install" should do it; older versions, it's somewhere in the Preferences in Xcode.app)
11:52:52 <FliPPeh> augur_: Sure it is, but using it later always ends up as a massive pain for me :(
11:52:58 <shachaf> Or a type class, for that matter.
11:53:26 <augur_> geekosaur: standard include files?
11:53:32 <augur_> geekosaur: im terribly confused
11:54:03 <geekosaur> line 10, line 17, line 23, line 30
11:54:06 <levi> augur_: All sorts of evil errors crop up in C code when headers are missing. The first few of the errors are saying things like math.h, stdint.h, etc. can't be found.
11:54:07 <FliPPeh> augur_: http://lpaste.net/96845 - this is broken in all kinds of ways, but I think you can see what I'm trying to achieve
11:54:07 <geekosaur> standard include files.
11:54:18 <geekosaur> it's compiling C code, not Haskell
11:54:26 <fizruk> jle`, list represents "all possible outcomes"
11:54:28 <augur_> levi: geekosaur: oh i see what you mean.
11:54:30 <levi> CPP is evil.
11:54:34 <geekosaur> it needs things like stdio.h that are part of a basic C environment
11:54:54 <FliPPeh> What I want is type have the connection code abstracted away from the application so it'll work just as well with the network module as it would work with Pipes or Conduits or whatever the cool kids are using now
11:55:10 <augur_> FliPPeh: i very much suspect you don't want your class def like that
11:55:16 <geekosaur> I am not sure why it's doing that during the linking step though...
11:55:29 <geekosaur> oh. "HsFFI.h" it's building FFI stubs
11:56:20 <mr-> FliPPeh: what's wrong with your code?
11:56:25 <augur_> should i just install haskell again? :\
11:56:28 <augur_> i have no idea how to solve this
11:56:33 <geekosaur> no, that will not help
11:56:46 <mangaba_leitosa> why not install C again? :-)
11:56:53 <geekosaur> what version of Xcode do you have installed? do you have its matching command line tools installed?
11:57:16 <levi> augur_: Can you compile a simple C program at the command line?
11:57:18 <augur_> geekosaur: dont know which version. i tried xcodebuild --install and it said --install was an invalid option
11:57:18 <FliPPeh> augur_: What would be a better way to define the class then?
11:57:24 <geekosaur> then it's 4.x
11:57:37 <geekosaur> you have to run Xcode.app, go into its Preferences, then find the Downloads tab
11:57:42 <geekosaur> and install the Command Line Tools
11:57:58 <augur_> geekosaur: aha yes, it seems it is indeed 4.6.3
11:57:59 <levi> I recall something about some versions of XCode not having gcc anymore and using clang instead, and ghc not being happy about clang's cpp. But I don't have any direct experience with it.
11:58:10 <augur_> ok, let me do this
11:58:17 <geekosaur> that wouldn't cause this failure, levi
11:58:28 <geekosaur> and they said 4.6.3 so that's not relevant anyway
11:59:34 <levi> Ahh, ok.
12:00:23 <levi> FliPPeh: Are you following along with Chris Done's blog post about Hulk?
12:00:43 <FliPPeh> levi: I think I read a part of it many months ago
12:00:56 <chrisdone> hm, i should make a wee update to that as i rewrote a lot of hulk recently
12:01:08 <chrisdone> the client code is now entirely pure with a simpler monad
12:01:28 <levi> chrisdone: I noticed that rewrite; I like the new way better.
12:01:31 <chrisdone> also ported it to use aeson and fastirc
12:01:33 <chrisdone> cool
12:02:09 <levi> I'm writing my own, mainly for the exercise, but Hulk was definitely an inspiration.
12:02:23 <chrisdone> fun =)
12:03:15 <levi> I did my own attoparsec parser as well, which parses to some types based loosely on http-types.
12:04:05 <chrisdone> mm_freak_: speaking of which it would be nice if fastirc supported server types too
12:04:33 <chrisdone> levi: i also realised the case-insensitive library is a nice for this use-case i.e. matching nicknames and channel names
12:05:20 <chrisdone> and using a Set of users instead of (stupidly) a list
12:05:35 <chrisdone> and Text/BS instead of string. generally making it more modern and less newbie-ish =)
12:06:48 <augur_> geekosaur: command line tools are not listed
12:06:51 <levi> Yeah, I've got sets and bytestrings so far. IRC doesn't really define an encoding, so I decided not to bother with Text.
12:06:55 <chrisdone> it used to run at 130MB~ over long periods and now it sits there at 6MB resident memory, which is nice
12:07:06 <FliPPeh> So if I read it right (or the article I found is old), Hulk uses Network and Handles for connections, which is what I want to avoid :/
12:07:12 <FliPPeh> Hence this type class magic
12:07:44 <levi> FliPPeh: You need to use *something* for connections.  But most of the logic has nothing to do with connections at all.
12:07:56 <geekosaur> urgh I hope they didn't remove the old versions
12:08:26 <FliPPeh> Yes, that's why I'm trying to build a connection type class so the logic is not at all concerned with the connections and it would work with conduits and pipes and the network module alike
12:08:44 <chrisdone> levi: yeah, i thought about that. BS makes more sense for IRC, tho it doesn't matter too much for such obscure servers. Text was just an easier type to convert Text to in my refactorings. BS has fewer string utilities so it will take a wee bit more housekeeping to port to
12:08:50 <geekosaur> oh heck I'd installed xcode 5.0 apparently (unless apple stealth-upgraded me)
12:08:52 <geekosaur> hold on
12:09:02 <levi> FliPPeh: I have a layer that uses Pipes to move data in and out of the raw sockets, but once things are parsed into IrcMessages, nothing is concerned about where they came from at all.
12:09:15 * geekosaur looks for the direct download url
12:09:30 <FliPPeh> levi: Which is exactly what I want to do
12:09:31 <geekosaur> and they killed connect.apple.com too :/
12:09:45 <FliPPeh> Except not with pipes but with anything
12:09:50 <chrisdone> flippeh: yeah the only code concerned with Handles is in Server.hs
12:10:00 <augur_> geekosaur: ill just install the newest xcode, hows that :p
12:10:11 <FliPPeh> But since the handler code occasionally has to send a message in response, at that point you *will* need to be concerned with the connection
12:10:20 <FliPPeh> Hence type class
12:10:32 <levi> FliPPeh: So, you should figure out what sort of types you want your pure functions to work on. They shouldn't care at all about handles or pipes or whatever, just about some abstract kind of messages or events or something.
12:10:34 <chrisdone> flippeh: you do need to be able to handle things like killing conections, of course
12:10:35 <geekosaur> probably easiest excet you'll also need to look at the URL at the end of the /topic to fix ghc to work with clang's cpp
12:11:29 <chrisdone> if the user doesn't respond to PING for a while, or if they QUIT, you should be closing the connection, for example
12:11:32 <FliPPeh> levi: I know, that's why I keep saying I don't care about HOW the connection is implemented, just that whatever implements it implements it using the type class that my functions understand.
12:11:56 <chrisdone> flippeh: i did it like this, fwiw: https://github.com/chrisdone/hulk/blob/master/src/Hulk/Server.hs#L98
12:12:14 <levi> FliPPeh: You might want to try approaching things from a different viewpoint. Think about what kind of data is managed by the server and how that data will be transformed by the various messages that the server might receive.
12:12:28 <chrisdone> flippeh: the pure code writes (with the writer monad) a list of instructions back, like "close this client", "send these lines to the handle"
12:12:29 <geekosaur> augur_, if you want to stick with your current xcode instead of adding the clang change to your list of woes... are you running 10.7 or 10.8?
12:12:45 <geekosaur> (if you're running 10.9, you do need the new xcode and welcome to the new pain)
12:12:54 <jxv> what's a good boxed-array for doing bit manipulation?
12:13:48 <levi> FliPPeh: If you can figure out how to model the core of the system purely, then it should be pretty straightforward to figure out how to glue the IO stuff up to it.
12:14:42 <augur_> geekosaur: OS 10.9
12:14:55 <augur_> new xcode it is :D
12:14:55 <geekosaur> ok, you definitely need the new xcode
12:15:02 <geekosaur> the old one won't work quite right on 10.9
12:15:51 <geekosaur> also if you use a third party package manager (fink/homebrew/macports) you might want to check for any upgrade concerns
12:17:04 <augur_> geekosaur: why this is downloading: http://existentialcomics.com/comic/6 wittgenstein shows russell his private language
12:17:21 <chrisdone> levi: i still have a TODO item to write some unit tests for Client.hs. that would be cool. also, some bad decisions like the user authentication types can be fixed. i didn't know how to do it at the time of writing, but now i think a really nice way would be a monad that contains the session type would really be a nice way to ensure correctness, statically
12:17:24 <geekosaur> ...? mispaste?
12:17:40 <augur_> geekosaur: no? :P
12:17:43 <augur_> while**
12:18:08 <augur_> i need something to do while i download a billion gigs of Xcode, so i figure i'd show you a funny philosophy comic!
12:18:32 * geekosaur has plenty vying for his attention already :/
12:18:48 <chrisdone> levi: e.g. this code is very problematic, because if you move the withChannel expression outside of asRegistered, either by refactoring or whatever, you've created a security hole https://github.com/chrisdone/hulk/blob/master/src/Hulk/Client.hs#L640
12:18:54 <levi> chrisdone: My analog to your Client monad has a type that keeps track of the registration state, and the command dispatch does case analysis on it as the first thing. So I don't even have a proper User in the state until registration completes.
12:19:01 <chrisdone> levi: but by sticking "registered/unregistered" in the type of the monad, that'd statically prevent it
12:19:23 <chrisdone> hmm
12:20:29 <levi> I'd be intereted to see what the approach you just described would end up looking like, though.
12:20:48 <levi> I'm not entirely happy with my implementation.
12:22:16 <chrisdone> maybe if the type was Msg = RegisteredMsg RegMsg | UnregisteredMsg UnregMsg then you could dispatch on it and still get pattern completeness warnings
12:22:52 <levi> I will probably end up changing the name of this if I ever post it on github or hackage, but if you want to look at what I've done you can find it here: http://cgit.pinealservo.com/pipes-irc-server/
12:22:55 <chrisdone> how do you handle the NICK command? that can be handled either unregistered (in which case it's accepted or rejected), or registered (in which case it sends notification to channels you're in)
12:23:25 * chrisdone clones
12:23:52 <levi> Since the command dispatch does case analysis on the registered state as a first step, the registered and unregistered versions of NICK are handled by completely different functions.
12:24:42 <chrisdone> ahh, i see it
12:24:52 <levi> This is my first haskell project that's more than one file and even remotely close to doing what I want it to, so forgive the mess. :)
12:24:53 <chrisdone>     case cReg of
12:24:54 <chrisdone>       Unreg   {} -> unregHandler msg
12:24:54 <chrisdone>       RegUser {} -> regHandler   msg
12:25:35 <chrisdone> yeah, i like this approach
12:25:36 <anoni> hi
12:25:56 <levi> hi, anoni
12:25:56 <anoni> quick question, what is the difference between foldl and foldl'?
12:25:58 <chrisdone> probably my monadic idea is overengineering it a bit, there aren't many unregistered commands you can send
12:26:12 <levi> The version with ' is strict, the other is lazy.
12:26:22 <chrisdone> foldl is almost useless
12:26:23 <ciaranm> obviously!
12:26:39 <ion> anoni: You almost certainly want to use foldl' instead of foldl.
12:26:39 <anoni> i'm not sure to grasp what strict refers to
12:26:44 <WraithM_> foldl builds up thunks, foldl' does not.
12:26:44 <ion> @src foldl
12:26:45 <lambdabot> foldl f z []     = z
12:26:45 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:26:46 <ion> @src foldl'
12:26:47 <lambdabot> foldl' f a []     = a
12:26:47 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:27:14 <chrisdone> hm, i wonder whether using :force in ghci would be a good way to see what's happening
12:27:58 <levi> By default, haskell doesn't evaluate the parameters to functions when the function is evaluated. It hangs on to them in their un-evaluated state in case they're needed later. This is really nice sometimes, but when you are doing a left-fold, it's usually not what you want.
12:28:29 <anoni> foldl (+) 1 [1,2] will do 0+1+2 then evaluate?
12:29:01 <chrisdone> levi: code looks nice to me
12:29:27 <ReinH> anoni: check out http://www.haskell.org/haskellwiki/Performance/Strictness
12:29:39 <levi> chrisdone: Thanks! It has been through a few refactorings at this point, and I am reasonably happy about most of it.
12:30:08 <chrisdone> levi: is this handling case-insensitivity of users and chans? =p
12:30:09 <levi> Although I may regret the way I use the nickname as a key all over the place when I implement nick changes.
12:30:25 <chrisdone> levi: haha, yeah
12:30:58 <chrisdone> i think i used the nick as a key originally and ended up using the Handle. making sure everything's updated makes me nervous otherwise
12:31:47 <ReinH> :t either -- levi
12:31:48 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
12:33:28 <levi> ReinH: What in particular is that in reference to?
12:33:50 <chrisdone> levi: maybe he's just happy and wanted to tell the world =p
12:34:27 <levi> (I have started refactoring a couple of places to use a failure monad instead of nested logic, but I haven't pushed any of those changes yet)
12:35:35 <chrisdone> oh yeah, MonadLogger is pretty neat
12:35:40 * chrisdone adds to TODO list to add to hulk
12:35:59 <levi> And regarding case-insensitivity... I don't think I've done that yet. There are incomplete bits all over the place. :)
12:36:17 <chrisdone> :]
12:36:38 <ReinH> levi: oh never mind
12:37:04 <chrisdone> monadlogger is abstracted over the particular kind of logging, so you can have a pure logger with Writer or whatever (good for testing), and an immediate IO logger for development with debug on, and a to-file or syslog logger for production :3
12:37:43 <levi> ReinH: Is that an 'oh, I was mistaken' never mind, or an 'oh, you're hopeless and I don't have time to elaborate' never mind? ;)
12:37:53 <ReinH> levi: haha it's not what you want
12:38:19 <levi> Heh, OK, good.
12:38:20 <chrisdone> johnw: monadlogger!!
12:38:56 <johnw> woohoo!
12:40:25 <levi> I will take a look at monadlogger when I get to that point. Thanks for the tip.
12:41:10 <chrisdone> levi: are you going to be using the server for anything?
12:41:22 <ReinH> levi: although parseMessage = let note n = either (const $ Left n) id in void . yield . note "ERROR Bar Parse" . parseMany parseMsgOrLine
12:41:29 <ReinH> levi: might be a bit cleaner
12:43:32 <levi> I have actually done quite a bit of moving things around since my last git push, but I'm not certain about some of the changes so I haven't committed to them yet.
12:43:44 * chrisdone callCC gotoBed
12:47:10 <levi> ReinH: That's a good change, I think. I hadn't encountered the 'note' idiom yet when I wrote that, but I learned about it recently while investigating better ways to handle some of the logic in my command handlers.
12:48:24 <ReinH> `note' is actually for maybes but close enough :)
12:49:50 <levi> parseMessage is really just an awkward bit of pipes glue; I got it working and forgot about it.
12:50:41 <chrisdone> reinh: i lost the code now. that was either (const $ Left x) Right?
12:51:17 <chrisdone> :t either (const (Left ())) id
12:51:18 <lambdabot> Either a (Either () b) -> Either () b
12:51:25 <chrisdone> :t either (const (Left ())) Right
12:51:26 <lambdabot> Either a b -> Either () b
12:51:50 <chrisdone> i'd expect the latter, but maybe i'm missing the context
12:52:08 <chrisdone> :t left
12:52:08 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
12:52:14 <chrisdone> uh, not that left
12:52:29 <chrisdone> :t Data.Bifunctor.first
12:52:30 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
12:55:28 * chrisdone climbs back into bed
13:01:40 <ReinH> chrisdone: eh?
13:02:14 <quchen> chrisdone: Yeah sorry about that :-Ã¾
13:02:18 <ReinH> oh right, yeah I'm sure there's something more fit than either but either is in prelude :p
13:02:23 <augur_> geekosaur: ok, xcode installed (according to AppStore)
13:03:39 <geekosaur> augur_, ok, now you need `xcode-select --install` to get the command line tools (it's no longer part of the downloads in the xcode app)
13:03:39 <boom583> I'm trying to decide if I should port my program from C++ to Haskell. I'm thinking years into the future, and wondering if it will be worth the trouble and learning curve.
13:03:48 <boom583> How do I determine this?
13:03:52 <augur_> geekosaur: hold on, xcode is "installing components"
13:04:07 <joejev> boom583: what is it?
13:04:28 <joejev> boom583: and are the libraries you used available in haskell?
13:04:48 <geekosaur> ok. that might also do this but I would not bet on it, when it's done doing its thing run the xcode-select --install, if it fails with "not available" that's just it having a losy way of saying "no updates waiting to install"
13:04:50 <boom583> According to this answer: http://stackoverflow.com/a/2079678
13:04:53 <boom583> "Object-oriented languages are good when you have a fixed set of operations on things, and as your code evolves, you primarily add new things."
13:04:56 <boom583> "Functional languages are good when you have a fixed set of things, and as your code evolves, you primarily add new operations on existing things."
13:05:05 <augur_> geekosaur: ok
13:05:30 <boom583> In my program, I have a fixed (or slowly changing) set of "superthings" (superclasses). But I create new things all the time by creating subclasses
13:05:53 <boom583> so I guess that more suited for OO?
13:05:56 <boom583> hmm
13:06:16 <boom583> joejev: just using the standard lib here
13:06:56 <nlogax> boom583: Did they consider type classes? Seems like that's more "fixed set of operations" and lets you add new things
13:07:08 <Philonous> boom583, The thing you say that "Object-oriented languages are good at", I think what you are describing is Ad-Hoc polymorphism. OO is just one way to get that.
13:07:21 <Philonous> boom583, Haskell has ad-hoc polymorphism
13:07:38 <ReinH> It's a bit less ad-hoc though.
13:07:52 <joelteon> add hawk polymorphism
13:07:57 <scriptor> nlogax: right, that SO question basically  just restated the expression problem
13:08:05 <marcopolo2> I'm trying to display the time in a dzen window in xmonad, but I'm getting some errors I don't understand
13:08:09 <scriptor> and Haskell's solution to that, at least partially, was typeclasses
13:08:16 <marcopolo2> I'm also new to haskell so that will probably explain it :P
13:08:33 <ReinH> if you want to colocate data and behavior, there are other ways to do it. Records being one.
13:08:36 <boom583> Also, in C++ I find myself doing template metaprogramming to get custom types. Will Haskell make life easier here?
13:08:42 <boom583> metaprogramming is pain
13:08:47 <augur_> geekosaur: lol
13:08:55 <marcopolo2> Here's my xmonad.hs: https://www.refheap.com/21658 ; and I'm getting "couldn't match X String with IO String"
13:09:06 <augur_> i tried  `xcode-select --install`  and i get a popup saying it needs to install the command line tools in order to do that
13:09:11 <boom583> c++ template metaprogramming IS functional programming. So C++ has these two separate worlds
13:09:15 <boom583> so i'm not sure
13:09:22 <geekosaur> ok, that sounds right
13:09:41 <nicoo> boom583: Why are you saying that C++ templates are functionnal ?
13:10:04 <epta> hayoo returns `Internal Server Error. A web handler threw an exception. user error (Codec.Compression.BZip: not enough memory)` :[
13:10:43 <geekosaur> yes :(
13:10:57 <boom583> nicoo: template metaprogramming is that :) This talk is about the similarities of template metaprogramming in C++ and Haskell: https://www.youtube.com/watch?v=_uJMKxmoo68
13:11:10 <boom583> nicoo: using templates is not functional
13:11:14 <quchen> boom583: Template metaprogramming is a makeshift preprocessor. C++ was not built to have it, and it is accordingly pleasant to work with it.
13:11:21 <boom583> yeah
13:11:26 <boom583> that's right
13:11:41 <quchen> Haskell on the other hand was built from scratch around a strong theoretical basis.
13:11:52 <boom583> And by the way, Haskell vs. OCaml? That's another descision I'm trying hard to make
13:12:10 <boom583> if I'm to break into the func prog
13:12:39 <Philonous> boom583, I wonder which answer you expect in a Haskell channel ;)
13:12:47 <boom583> :D
13:12:48 <ocharles> Hmmm, is there a way to use let bindings in list comprehensions without getting irrefutable pattern match failures? E.g., [ foo | x <- [0..10], let Just foo = blah !! x ] ?
13:13:18 <ocharles> I'd like that to just skip things where blah !! x is nothing. I could guard for it
13:13:35 <shachaf> Just foo <- [blah !! x]
13:13:40 <nicoo> boom583: OCaml is easier to learn, and compares well to Haskell, IMHO
13:13:49 <boom583> nicoo: ok
13:13:53 <quchen> If functional programming is what you want, there's not much that compares to Haskell: it's the only widely known language that is purely functional. If on the other hand you're trying to get stuff doneâ„¢, there are other languages to consider as well. OCaml is one of them I think.
13:14:05 <shachaf> (But that use of (!!). :-( )
13:14:08 <quchen> And the lisps and what have you.
13:14:24 <boom583> does haskell make parallel computing (for instance a for loop million times (e.g. monte carlo method)) easier on any platform? i heard ocaml sucks at that?
13:14:28 <simpson> quchen: Does "purely" mean anything here? I think I've got a good grasp on "functional" now, but "purely functional" still seems nebulous.
13:14:34 <nicoo> quchen: Yeah, but Lisp isn't typed at all
13:15:02 <nicoo> boom583: OCaml is getting there (for //ism), but yes, Haskell is more mature for this
13:15:02 <ReinH> boom583: Haskell has a pretty great parallelism and concurrency story
13:15:03 <marcopolo2> nicoo: Clojure has core.typed
13:15:03 <quchen> nicoo: Well, there's typed Clojure for example. But that's a makeshift type system again.
13:15:20 <boom583> ok
13:15:27 <ocharles> shachaf: ah, yes
13:15:34 <nicoo> quchen: â€œmakeshift type systemâ€ always give me shudders :>
13:15:45 <Philonous> simpson, Ocaml allows you to have arbitrary side-effects in any "function".
13:15:51 <marcopolo2> quchen: I wouldn't say makeshift, it's just a library that adds optional type checking
13:15:59 <boom583> haskell appears to be more popular than ocaml though... more vibrant community
13:16:09 <nicoo> Philonous: Why quotation marks around function?
13:16:12 <simpson> Philonous: So languages without side-effects are "pure"? Does this make Joy a purely functional languages?
13:16:48 <Philonous> nicoo, Because it ceases to be a function when it's result can depend on the phase of the moon or RMS' mood
13:16:55 <ReinH> nicoo: because functions with arbitrary side effects aren't functions?
13:16:56 <quchen> simpson: When we say "purely functional" we're talking about side effects. Haskell is built around not having them. (Compare that to say Scheme, where you can use "display" anywhere in your code.)
13:17:07 <nicoo> Philonous: Or the state hidden in your monad
13:17:15 <augur_> geekosaur: well, GHC isnt complaining now!
13:17:23 <simpson> quchen: Where "side effect" means any change to any part of the system which is not accounted for in the type, correct?
13:17:27 <augur_> no verbose output, but it seemed to have compiled without problem
13:17:31 <ReinH> nicoo: no, those are still functions.
13:17:33 <geekosaur> yay
13:17:41 <marcopolo2> What type is 'X String' ?
13:17:55 <nicoo> boom583: Using both, I would say that, for most practical purposes, their respective popularity isn't a criterion
13:18:00 <ReinH> a function must produce the same output for each input
13:18:13 <joejev> marcopolo2: a string within the X monad
13:18:19 <boom583> nicoo: why do you use both?
13:18:25 <trolling> marcopolo2: ReaderT XConf (StateT XState IO) String
13:18:50 <quchen> simpson: That sounds about right.
13:19:18 <marcopolo2> thanks joejev trolling
13:19:20 <nicoo> boom583: Because I love both, and because they are both great languages to work with, albeit with different design choices
13:19:33 <simpson> quchen: Okay. So languages like Joy and Factor, which account for all side effects in their types, are purely functional, relying on the interpretation of concatenation in concatenative languages as row-polymorphic function composition?
13:19:44 <nicoo> so one might be more suited than the other for some things
13:19:57 <boom583> nicoo: i see. you mentioned that ocaml is "getting there" with parallelism. how so?
13:20:12 <boom583> i guess it's quite a while until it is fully ready..
13:20:28 <simpson> quchen: Then surely Scheme and Smalltalk kids and grandkids are purely functional by virtue of having functions and having type systems that account for their side effects?
13:21:28 <marcopolo2> If I'm in the IO monad, how do I get a string into the X monad? Does that even make sense?
13:21:40 <ReinH> boom583: if the question is "Can haskell do that?" the answer is yes. If the question is "Is haskell right for me?" then you're going to have to try it and see for yourself.
13:21:49 <boom583> What book would you recommend for a beginner in Haskell who doesn't know shit about functional programming?
13:21:50 <Philonous> nicoo, There is no state hidden in monads.
13:21:56 <quchen> ReinH, well said.
13:21:57 <boom583> there are tons of books on haskell.org
13:22:06 <boom583> not sure which to pick
13:22:16 <ReinH> boom583: start with learn you a haskell and real world haskell
13:22:18 <quchen> simpson: I don't understand anything after you said "concatenative".
13:22:21 <joejev> boom583: LYAH is cute
13:22:25 <startling> marcopolo2, "return", but you don't need to be in IO to do it
13:22:26 <geekosaur> marcopolo2, you can't, as such. could you explain what you're really trying to do, preferably including code? also there is the channel #xmonad
13:22:33 <nicoo> boom583: Actually, OCaml already has reasonable support (using libs) for some limited forms of //ism (like Map-Reduce) or for leveraging GPGPU. Full-blown //ism in the runtime is in a feature branch, and should be merged in the mainline reasonably soon
13:22:43 <ReinH> boom583: then if you still want more books, try Programming in Haskell
13:22:51 <ReinH> boom583: but mostly you should learn by doing.
13:22:53 <quchen> Anyway, Scheme is not purely functional (and is untyped), and Smalltalk isn't very functional.
13:22:57 <nicoo> boom583: And +1 for LYAH
13:23:08 <quchen> (Well, Smalltalk is as functional as Haskell is OO I guess.)
13:23:09 <boom583> ok, thanks
13:23:24 <marcopolo2> well in short I'm trying to read the current time, format it, and display it with a dzen window
13:23:25 <nicoo> boom583: And if you want an OCaml book, don't take â€œReal World OCamlâ€ :]
13:23:27 <quchen> (Which is: you can make a case of it but it will make people angry and lead to nothing)
13:23:42 <marcopolo2> I'm pretty sure this is just me having no clue how haskell works, and nothing in particular with Xmonad
13:23:44 <simpson> quchen: "functional", from what I've been told, means that functions can be first-class values and can be built at runtime, closing over other first-class values.
13:23:54 <boom583> nicoo: why, is it bad?
13:24:00 <startling> UndecidableInstances is safe if I only write one instance per class for a particular datatype, right?
13:24:05 <simpson> Which I'm willing to accept as it "correctly" excludes C while including Scheme.
13:24:23 <simpson> quchen: I'm not even trying to make a case. I'm trying to figure out if "purely functional" means anything.
13:24:27 <ReinH> simpson: I suspect there are as many definitions of "functional" as there are people who use the term.
13:24:29 <nadirs> hi everyone
13:24:43 <ReinH> It's not a very useful way to categorize langauges
13:24:51 <startling> I think "has functions" is a reasonable definition of "functional". :)
13:24:51 <geekosaur> marcopolo2, spawn should be MonadIO so you shouldn't need to be in X
13:24:58 <simpson> quchen: Can a language be pure without being functional? Can a language be pure without static types? How about without strong types?
13:25:05 <nicoo> boom583: It is quite good. But they completely forget the existence of the OCaml ecosystem except for the code grown around Core (Jane Street's replacement for the standard lib), and doesn't explein what is native OCaml, what is custom syntax extensions, and so on.
13:25:06 <Philonous> boom583, Typed effects make parallel programming much easier, though. If you know that a parts of your program can't interfere with each other you can just run them in parallel without getting into trouble. That's why parallelising your already written code can often be done with the addition of a few "par"s and "pseqs"
13:25:08 <ReinH> startling: now we've just shifted the buck to defining "functions"
13:25:10 <simpson> startling: But that includes C, and people don't like that.
13:25:19 <startling> simpson, C doesn't have functions.
13:25:23 <nadirs> simpson: doesn't functional refer more to lack of side-effects than to the fact you can pass functions around (which is implied anyway)?
13:25:24 <startling> ReinH, exactly. :)
13:25:43 <ReinH> Functions are what the languages that I call functional have. ;)
13:25:44 <companion_cube> C doesn't have first-class functions*
13:25:45 <nicoo> boom583: So basically, it's a good book for learning OCaml/Core, not OCaml
13:25:45 <boom583> sounds good
13:25:45 <startling> nadirs: no.
13:25:51 <boom583> nicoo: i see
13:26:07 <joejev> companion_cube: can you not pass function pointers?
13:26:10 <simpson> companion_cube: C has types for function pointers.
13:26:19 <marcopolo2> geekosaur: I'm not using spawn
13:26:26 <marcopolo2> here's is what I'm trying to run
13:26:27 <quchen> simpson: The first paragraph of the Wiki entry sums it up I think: https://en.wikipedia.org/wiki/Purely_functional
13:26:28 <marcopolo2> https://www.refheap.com/21660
13:26:28 <simpson> nadirs: No, because that would mean that Lisps, which allow side-effects, are not functional.
13:26:29 <companion_cube> right, but you don't have closures
13:26:33 <startling> companion_cube: that's not at all what I meant.
13:26:39 <companion_cube> well, you could simulate them, but it's awful
13:26:39 <nicoo> simpson, joejev : That's not quite the same as first-class functions, though
13:26:58 <quchen> simpson: The second paragraph is so-so, the third one is trash though. So stop reading after the first one.
13:26:58 <nicoo> companion_cube: Isn't it done in GObject ?
13:27:03 * nicoo <~nicoo@unaffiliated/nicoo> has left #haskell (Running away)
13:27:20 <simpson> quchen: So AFAICT "purely functional" is an idea that isn't actually implemented by anybody at a whole-language level?
13:27:42 <startling> you can /do/ functions in C (see, e.g., any functional language implementation written in C) but it's not a language construct.
13:27:46 <geekosaur> marcopolo2, are you defining dzenConfig? because the one that comes with xmonad does not spawn dzen, it is a DynamicLog configuration record that provides dzen-specific formatting
13:27:53 <nadirs> startling: then is it safe to say that C/C#/python are functional-ish? Since you can pass functions around
13:28:01 <tomejaguar> Can anyone tell me what version issue I am having: http://lpaste.net/96847
13:28:11 <joejev> nicoo: why not, couldn't you write a procedure map, like, void** map((void*)*f(void*),void**,size_t) or something
13:28:26 <simpson> nadirs: Python is as functional as Scheme; you can't really include one and exclude the other. (It's funny to watch people try!)
13:28:31 <joejev> nicoo: syntax might be off a little
13:28:55 <startling> nadirs, python is definitely functional. C is not (I'm being glib by saying "C doesn't have functions" but really what it doesn't have is functions-creatable-at-runtime). I don't know C#.
13:28:57 <joejev> tomejaguar: one is lazy, one is no
13:28:59 <boom583> is it in theory possible to rewrite every c program in haskell and vice versa?  imperative <-> func
13:29:00 <geekosaur> mm, wait, we don't have a dzenConfig
13:29:01 <companion_cube> simpson: I beg to disagree, python's scoping is broken
13:29:03 <joejev> tomejaguar: not*
13:29:05 <ReinH> I do so enjoy watching people try to define functional and function for the 100th time.
13:29:06 <geekosaur> I think yoyu need to show more detail
13:29:07 <startling> boom583: sure.
13:29:07 <companion_cube> whereas scheme has a proper scoping
13:29:13 <boom583> interesting
13:29:23 <nicoo> joejev: Sure, you have higher-order functions. That's only halfway through having first-class functions (since you cannot construct functions at runtime using currification or lambdas)
13:29:24 <tomejaguar> joejev: Really?  Neither of them say lazy.
13:29:26 <marcopolo2> geekosaur: the alertText function already displays text correctly
13:29:30 <quchen> simpson: I'm not sure about the details here, but I think Haskell is at least pretty close to the ideal of a purely functional language. It's mostly where you draw the line between having a Haskell program and running it.
13:29:30 <nadirs> simpson, startling: is that because of side-effects, though? I mean, the fact Scheme is not considered purely functional?
13:29:38 <simpson> nadirs: set!
13:29:39 <geekosaur> ok, so you got that from somewhere else
13:29:45 <startling> nadirs, "purely functional" is different than "functional"
13:29:50 <Hodapp> boom583: Turing-completeness makes that possible, in general.
13:29:51 <startling> and "purely functional" is pretty rare
13:29:57 <Hodapp> boom583: it doesn't necessarily make it possible in a useful sense though.
13:29:58 <nadirs> startling: C# has even lamdas, so hip!
13:30:08 <joejev> tomejaguar: post snippet
13:30:10 <startling> nadirs: good to know!
13:30:11 <ReinH> Hodapp: Turing completeness + the Turing-Church equivalence ;)
13:30:13 <trolling> I like FORTRAN
13:30:24 <nicoo> Hodapp: Doesn't GHC have a C backend ?
13:30:27 <boom583> in c++, i organize my files like Car.h/Car.cpp for each class, and one main.cpp for main(). How are code files organized in Haskell, having no classes?
13:30:35 <geekosaur> marcopolo2, so, if you have something in IO that works, and want to invoke it from a keybinding, use `io` to lift that into X
13:30:35 <startling> nicoo: it did at one point at least.
13:30:40 <ReinH> boom583: Haskell has modules.
13:30:43 <simpson> quchen: I dislike that "purely functional" means something fancy and special which can't be pinned down in a useful manner, that's all. Why describe things with something nebulous and not strictly defineable?
13:30:48 <joejev> boom583: modules
13:30:48 <nicoo> startling: Yes, that's what I remembered
13:30:55 <ReinH> boom583: most of these questions would be answered by trying to program something in Haskell and reading about programming in Haskell. :)
13:30:56 <Hodapp> simpson: It worked for "object oriented", didn't it?
13:30:59 <marcopolo2> geekosaur: io is a function?
13:31:00 <tomejaguar> joejev: http://lpaste.net/96847
13:31:02 <Philonous> Hodapp, It doesn't though. Turing completeness doesn't give you the ability to interface with the OS (as in: write something to the terminal)
13:31:07 <startling> simpson: are you talking about, like, unsafePerformIO or something else?
13:31:08 <geekosaur> yes, it's shorthand for liftIO
13:31:14 <trolling> nebulous and not strictly definable covers pretty much every word in common usage
13:31:22 <trolling> that doesn't make them not useful
13:31:27 <marcopolo2> geekosaur: thanks, I'll try that!
13:31:30 <trolling> mathematical constructions which are precise are the exception, not the rule
13:31:32 <geekosaur> which runs an IO action in any MonadIO (including X)
13:31:33 <Hodapp> trolling: quit using nebulous terms like "nebulous"
13:31:39 <simpson> Hodapp: "Object-oriented" is also a stupid term. Object-based languages are quite different from non-object-based languages in a very precise way which is dependent upon the type system and execution model of the language in question.
13:31:48 <boom583> ReinH: yeah you're right. how about I stfu :D
13:31:48 <quchen> simpson: "No destructive updates" sounds pretty accurate to me. If there is a more accurate description I don't know about it.
13:31:58 <boom583> i'll buy that LYAH for Great Good book
13:31:59 <quchen> (Which is very much possible.)
13:32:03 * Hodapp pokes tippenein
13:32:04 <ReinH> boom583: you can ask questions! But you'd learn more by doing than by asking about doing. :)
13:32:05 <simpson> quchen: So only a subset of Haskell would be purely functional, then?
13:32:09 <boom583> yeah
13:32:11 <tippenein> oh hai Hodapp ;)
13:32:12 <joejev> tomejaguar: try to switch the pack to a lazy pack.
13:32:16 <nicoo> trolling: Mathematical constructs are usually rather precises. The proofs, though ...
13:32:21 <joejev> tomejaguar: that is usually what that means
13:32:28 <Philonous> simpson, When used by Haskellers "purely function" usually means "no arbitrary side-effects" and that's pretty precise.
13:32:41 <nadirs> now, to add some more fuel to fire: is Haskell's IO pure (yes, you can shoot me now :P)?
13:32:46 <trolling> nicoo: but "by symmetry" is such a strong argument, how you can you dismiss proofs like that as nebulous?
13:32:48 <Hodapp> tippenein: o hai!
13:32:48 <nadirs> I've read that post and it was quite convincing
13:32:50 <startling> < startling> simpson: are you talking about, like, unsafePerformIO or something else?
13:32:51 <ReinH> It usually requires referential integrity.
13:32:58 <quchen> simpson: Haskell is a purely functional language to build a value ("main") of type IO (). The runtime system then runs that thing.
13:33:00 <simpson> startling: IORef is a good starting point, I suppose.
13:33:02 <nicoo> trolling: Ahah :>
13:33:12 <quchen> The building part is purely functional, and that's what most people call "Haskell".
13:33:13 <ReinH> nicoo: mathematical constructs are proofs...
13:33:15 <tomejaguar> joejev: Thanks, I'll have a go.  this has stopped building on an upgrade of something, so ... confused.
13:33:20 <geekosaur> tomejaguar, joejev: that import is a strict ByteString, as is the one that it's expecting. you have two versions of ByteString installed
13:33:26 <simpson> Philonous: Hm, so arbitrary side effects are those that are not accounted for by the type of the function in question, right?
13:33:28 <startling> simpson: that's fair.
13:33:32 <geekosaur> and it's trying to mix them
13:33:56 <joejev> tomejaguar: what library is strictBytestringResponse from, it might have a dependency issue
13:34:30 <tomejaguar> joejev: happstack-server-7.1.7.1
13:34:48 <nicoo> ReinH: Only in formal, curry-howard style mathematics
13:35:03 <ReinH> nicoo: er, yes.
13:35:14 <tomejaguar> joejev: Strangely the docs for strictBytestringResponse say it takes a *lazy* bytestring, but the source says strict
13:35:21 <ReinH> As opposed to "informal" mathematics?
13:35:22 <Philonous> simpson, No, it's even stronger: Arbitrary side effects don't occur at all when evaluating a Haskell program. Even a value of type (IO ()) doesn't perform it's effect when evaluated.
13:35:40 <marcopolo2> geekosaur: That worked! thanks!
13:35:43 <ReinH> quchen: that's a very important distinction (creating an IO value is pure, performing may not be).
13:35:45 <trolling> just put aside unsafePerformIO
13:35:48 <nicoo> ReinH: As far as I understood, trolling and I were discussing informal mathematics, where the separation between proof and construct is usually clear
13:36:21 <Philonous> simpson, In haskell, you are building an effectful IO-program in an effects-free (except for bottom) language.
13:36:39 <ReinH> nicoo: But... The only things in any math that are not proofs are the axioms of the system in question.
13:36:50 <ReinH> Well, I should say theorems.
13:36:50 <startling> Philonous, that's a nice idea but ... it's not true.
13:36:53 <ReinH> But the point stands.
13:37:00 <Philonous> startling, How is it now true?
13:37:07 <levi> ReinH: The distinction between formal mathematics and informal mathematics is a pretty well-defined one.
13:37:12 <simpson> Philonous: So, Joy?
13:37:23 <Philonous> startling, not*
13:37:26 <ReinH> levi: so it's defined... formally? ;)
13:37:33 <Philonous> simpson, I don't know joy
13:37:51 <levi> No, I think you're using a different meaning for 'formal' than is meant by 'formal mathematics'
13:37:53 <ReinH> liyang: I know, I just didn't realize we would be talking about informal mathematics.
13:38:05 <KiriKari> Hello. So, programming a microcontroller without an RTOS when you have a lot of timing to consider is quite a nightmare. It is hard to make timing dependencies explicit in the code. Very easy to create subtle bugs that go through all testing without notice then kill someone in the real world. What can Haskell do about this? I hear about atom, anyone tried it? It really is quite horrendous to
13:38:07 <KiriKari> program bare metal in C.
13:38:13 <ReinH> levi: as in, all the math that's relevant is formal afaik
13:38:28 <levi> ReinH: No, not at all.
13:38:29 <startling> Philonous, do you just give some other name than "evaulation" to the part where you run "main"?
13:38:54 <quchen> ReinH: The physicist in me is offended! ;-)
13:38:56 <levi> Formal mathematics is a pretty recent invention, on the mathematical timescale.
13:39:08 <ReinH> Er, all the math that's relevant *to this discussion*
13:39:22 <ReinH> quchen: the naive physicist in you? ;)
13:39:30 <joejev> am I going full stupid, SolveError is data SolveError = ReadError | .... and I get: couldn't match expected type `SolveError'  with actual type `ReadError'
13:39:40 <trolling> I've heard rumours about categories in string theory
13:40:02 <nicoo> quchen: Physics isn't relevant to Mathematics :>
13:40:05 <akegalj> why haskell doesn't have depended types?
13:40:21 <ReinH> levi: my understanding of "informal" is that it implies the use of inductive or heuristic methods, which isn't what we're talking about here.
13:40:43 <ReinH> levi: or maybe I *am* using a different definition.
13:40:46 <startling> akegalj: they're outside of Haskell's intended scope.
13:40:51 <nicoo> trolling: String theory is the takeover of Physics departments (and funding) by undercover mathematicians. Not so surprising they would bring categories :>
13:40:52 <Philonous> startling, Performing an action and evaluating an expression are clearly distinct in haskell.
13:41:02 <levi> You are doing formal mathematics when you apply valid tranformations to Haskell programs to produce new valid Haskell programs. You are doing informal mathematics when you talk about what things mean.
13:41:25 <nicoo> a,
13:41:27 <nicoo> Arg
13:41:32 <levi> ReinH: Formal mathematics is mathematics recast in a formal system, i.e. a set of symbols and transformation rules with no inherent meaning.
13:41:41 <startling> Philonous: ok.
13:41:45 <akegalj> startling: oh, ok. I thought it was somehow not posible to implement that. thnx
13:41:56 <levi> This was the goal of Principia Mathematica, for example.
13:42:01 <trolling> and if you spray semantics about the place it becomes informal
13:42:09 <levi> It's also what you do when proving theorems in Coq.
13:42:12 <quchen> akegalj: Haskell's type system is the most powerful one that still has nice properties like decidable type inference. Recent developments take it beyond that though, and new language extensions are gradually moving towards (aspects of) dependent types.
13:42:14 <ReinH> levi: Ok, then this is a new definition for me. Acknowledged.
13:42:30 <startling> akegalj: nope, it totally is. Take a look at idris and agda if you'd like to see haskell-like dependently-typed languages.
13:42:30 <quchen> (Or maybe one of the most powerful ones, before someone jumps at me for that absolute)
13:43:45 <levi> But almost all mathematicians that aren't into foundations or computing work almost entirely in the informal realm of mathematics, where reasoning about mathematical concepts is separate from the mathematical things that are being reasoned about.
13:43:48 <tac> akegalj: #idris on Freenode
13:44:07 <ReinH> levi: Ok, I think I understand the term now. :)
13:44:16 <akegalj> quchen, startling, tac: thank you all
13:44:20 <tac> levi: In programmer terms, to most mathematicians, proofs are _not_ first-class functions
13:44:26 <tac> rtt
13:44:26 <tac> err
13:44:29 <tac> first-class objects*
13:44:32 <levi> Right.
13:44:42 <tac> nor are propositions
13:45:36 <tac> You also tend to consider something proved once you believe it's possible in principle
13:46:03 <tac> For a programmer, that's like never actually writing your software once you get the specs for it ;)
13:46:18 <levi> Right, in general a mathematical proof is an argument sufficient to convince your fellow mathematicians that you are correct.
13:46:38 <ReinH> heh
13:46:56 <cmtptr> you get specs for software you write?  I want that job
13:47:43 <ReinH> With my pesonal favorite being "trivial".
13:47:54 <tac> The nice thing about mathematics is you develop the field slowly. It's not "can I have the project done next week" :P
13:48:00 <levi> KiriKari: Programming embedded systems in C is my day job. I feel your pain. ;)
13:48:09 <ReinH> When in doubt, see if you can get by on claiming that your proof is trivial. ;)
13:48:22 <levi> "Proof is left as an exercise for the reader"
13:48:52 <tac> I have recently started rating mathematics book by the quality of their exercises.
13:49:10 <yesthisisuser> when you think you understand something, then comes the part where you have to prove it
13:49:14 <tac> Books with no or few or poorly-thought-out exercises are just not very good.
13:49:35 <ReinH> KiriKari: GHC can't give you hard real time guarantees, especially around space (and GC), but iirc there is some work in this direction.
13:49:42 <startling> It's sometime hard to tell whether a certain problem is too hard to deep and evocative but slightly out of my grasp.
13:49:53 <startling> s/to/or
13:50:17 <ReinH> startling: To paraphrase Feynman, there are only two kinds of problems: trivial problems and problems that are too hard.
13:50:24 <startling> heh
13:51:56 <ReinH> tac: so what are your favorite algebra and cat theory books by this metric?
13:52:11 <tac> My favorite algebra book at the moment is Aluffi
13:52:40 <tac> Category theory, I don't know. I haven't seen a CT book I really like.
13:52:47 <ReinH> tac: oh ofc I don't have that one
13:52:53 <vamega> Hi, how can I load a file into ghci if it imports another file I have locally?
13:53:01 <startling> tac: I started that one once. I liked it, but, uh, I can never get into reading books on the computer.
13:53:12 <tac> yeah. I feel you.
13:53:14 <startling> vamega, same way you do normally.
13:53:14 <ReinH> startling: you have a pdf version?
13:53:22 <startling> ReinH: yeah.
13:53:24 <tac> I have to have a physical copy if I'm going to stick to it.
13:53:29 <vamega> :l taxes.hs types.hs
13:53:51 <ReinH> startling: $72 is a bit much to impulse buy a textbook :/
13:53:53 <startling> vamega, just :l taxes.hs should do it
13:53:56 <startling> ReinH, right.
13:53:58 <augur_> geekosaur: well, now i know i shouldnt be using haskell for this until i figure out how to do efficient stateful looks in haskell. :)
13:54:08 <klugez> vamega: File name has to match the module name.
13:54:26 <vamega> klugez - that might be it
13:54:29 <startling> oh, yeah ^
13:54:35 <ReinH> I really want to pick up Categories, Allegories but $$$ :( http://www.amazon.com/Categories-Allegories-North-Holland-Mathematical-Library/dp/0444703683
13:54:46 <ReinH> The definition of a category at the beginning is great.
13:54:56 <ReinH> objectless and takes about 2 pages.
13:55:03 <augur_> i need to generate over 46 billion quadruples of integers, and using haskell lists just aint cutting it
13:55:08 <startling> Math books sometimes have really nice cover art.
13:55:24 <startling> It's like its own genre of design.
13:55:25 <ReinH> augur_: what do you plan on doing with them?
13:55:26 <vamega> so if I have a module called Federal
13:55:33 <tac> The problem with CT books is, I'm convinced CT is not useful to learn for its own sake.
13:55:36 <vamega> does my filename need to be Federal.hs
13:55:40 <vamega> or would federal.hs suffice?
13:55:45 <augur_> ReinH: compensating for my lack of probability theory math :)
13:55:45 <startling> vamega: Federal.hs
13:55:53 <tac> You need to know some amount of algebra and geometry and/or logic to make category theory interesting
13:55:55 * hackagebot diophantine 0.2.0.0 - A quadratic diophantine equation solving library.  http://hackage.haskell.org/package/diophantine-0.2.0.0 (joejev)
13:55:57 <augur_>  /combinatorics math
13:55:59 <ReinH> augur_: Oh Monte Carlo?
13:56:13 <augur_> ReinH: no, just enumeration of all possible situations, and calculating probabilities
13:56:51 <ReinH> augur_: do you want a lazy producer of quads or to keep the whole set in memory for some reason?
13:56:59 <ReinH> what are you doing with the quads?
13:57:03 <wojtekM_> I figured it out.
13:57:05 <wojtekM_> UTCTime (gregorian # YearMonthDay 2013 12 10) (timeOfDay # TimeOfDay 22 46 43)
13:57:35 <augur_> ReinH: lazy is fine, i just dont know enough about efficient stateful haskell to know what to do. im going to write it in C since i understand C's stateful model better.
13:58:16 <ReinH> augur_: How is Haskell not cutting it? Space? Stack?
13:58:43 <augur_> ReinH: haskell's just taking a while the way im doing it, which is almost certainly the _wrong_ way to do it.
13:59:05 <ReinH> augur_: have you tried leaning on Data.Vector for some magical fusion?
13:59:22 <augur_> ReinH: like i said, i dont know enough fancy haskell :)
13:59:32 <augur_> most of my purposes arent data oriented, so i never had to learn this stuff
14:00:05 <ReinH> augur_: you should probably try unboxed vectors and http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
14:01:54 <startling> tables is pretty nice.
14:02:50 <ReinH> startling: edwardk's thing? I've used it for in-memory databasey stuff but for high performance number crunching?
14:03:24 <ReinH> augur_: depending on what you're doing you might also try leaning on your GPU with accelerate
14:03:35 <ReinH> I've been wanting to find some good reasons to use accelerate myself
14:03:59 <klugez> If you happen to have an NVIDIA GPU.
14:04:31 <ReinH> Or want to try an experimental OpenCL backend, I guess
14:04:47 <startling> ReinH: oh, I'm not saying that as part of the this conversation.
14:04:56 <ReinH> startling: oh heh, then yes it is.
14:05:11 <startling> I'm just using it for a thing and it makes things a lot easier.
14:05:11 <ReinH> startling: I haven't tried the new template haskell stuff though, have you?
14:05:16 <startling> nope!
14:05:26 <ReinH> startling: it's in head apparently, not sure if it's been released
14:05:49 <ReinH> but writing the boilerplate has been the major pain point so far, so seems good
14:05:55 <augur_> ReinH: too complicated :)
14:05:59 <ReinH> augur_: ok :D
14:06:05 <ReinH> augur_: but srsly try vector
14:06:12 <startling> ReinH: good to know! I don't see it on github (unless it's >2 months old) but maybe it's somewhere else.
14:06:31 <ReinH> startling: Er, I thought edwardk said it was in master.
14:07:23 <startling> ReinH: oh, so it is, I just never noticed it. :)
14:08:05 <edwardk> who is the master? http://www.youtube.com/watch?v=PnvQ-f5ue94
14:08:15 <startling> oh, it only works for types with no type variables. :(
14:08:16 <ReinH> edwardk: :)
14:08:20 <ReinH> wah wah
14:08:45 <edwardk> tables is a toy
14:09:30 <startling> it's a fun toy
14:12:26 <startling> it really does help in those cases where my instinct is to have a State with four Maps in it
14:12:56 <statusfailed> Yay, dumb question time- where's this function: Monad m => (a -> b -> m c) -> m a -> m b -> m c ?
14:13:11 <statusfailed> I know it's just join and liftM2 but is it in the standard libraries?
14:13:41 <pavonia> Control.Monad, IIRC
14:14:23 <ADexter> hey, can somebody give me a tip on how to make a (or more precise 3) histogram of a (Array U Dim3 Word8) using the Repa Library? Right now I am using foldl and three arrays(histo Red/Green/Blue) which I update using traverse. So I call traverse three times (for each histogram) per value and I don't really think thats the best way.
14:14:25 <cariveri> please I need help. how do thos keyboard events work? http://lpaste.net/96853
14:18:42 <ReinH> ADexter: perhaps you want traverse3?
14:20:08 <ReinH> ADexter: or perhaps you want an array of RGB Word8 instead of 3 arrays
14:23:16 <ADexter> ReinH: thanks, I completly overlooked traverse3
14:23:55 <ReinH> ADexter: oh look at what the google found http://stackoverflow.com/questions/13298778/calculate-an-image-histogram-with-repa
14:26:56 <ADexter> yeah thats kinda the way I do it now. I just thougt that there would be some kind of accum like in Data.Array
14:30:20 <quchen> statusfailed: There's no such function, but you can easily make it via join (liftA2 f x y).
14:31:00 * hackagebot elm-repl 0.1.0.1 - a REPL for Elm  http://hackage.haskell.org/package/elm-repl-0.1.0.1 (EvanCzaplicki)
14:32:54 <ReinH> quchen: that's also `f <$> x <*> y & join` right?
14:33:32 <quchen> ReinH: Yes, liftA2 f x y = f <$> x <*> y
14:36:01 * hackagebot superdoc 0.1.0.0 - Additional documentation markup and Unicode support  http://hackage.haskell.org/package/superdoc-0.1.0.0 (PeterSelinger)
14:37:42 <startling> Does anyone see how (or whether) I can write an instance Monad f => Monad (Term f) ? I'm having trouble and I'm not convinced it can be done.
14:37:58 <shachaf> That depends on what Term is.
14:38:12 <startling> heh, forgot the gist url: https://gist.github.com/anonymous/80e0ca6903322e00a729
14:38:29 <startling> equivalently: is a FreeT possible?
14:38:53 <startling> oh: yes, but, it's not equivalent.
14:42:28 <ReinH> startling: is there an Applicative?
14:42:50 <startling> ReinH, I can't figure that one out, either. :<
14:43:03 <ReinH> startling: what would pure be?
14:43:28 <startling> ReinH: pure = TermT . pure . Var
14:43:45 <startling> sorry, pure = Term . pure . Var
14:44:43 <ReinH> startling: ok, and can you derive <*> from fmap f x = pure f <*> x?
14:46:49 <ReinH> startling: and if you just want monad, you just need join, fmap and pure, right?
14:47:11 <ReinH> and you already have fmap and pure, so define join and derive >>=
14:47:38 <cmtptr> why does this fucking language care so much about how I indent things
14:47:52 <startling> ReinH, "define join" is what I'm having trouble with, alas.
14:47:53 <ReinH> cmtptr: because it is whitespace sensitive.
14:48:01 <geekosaur> if you realy hate it that much, you can use braces instead
14:48:01 <ReinH> startling: :/
14:48:05 <geekosaur> (try that in python...)
14:48:10 <dwcook> cmtptr, you might like to try the braces and semicolons style if you dislike it.
14:48:21 <cmtptr> how do I use the braces with where?
14:48:30 <dwcook> where { foo = â€¦ ; bar = â€¦ }
14:48:57 <cmtptr> a ha, I guess I need the semicolons even if there's a newline
14:49:07 <startling> heh
14:49:21 <cmtptr> that's fine, I can live with that.  still infinitely better.  thanks!
14:52:31 <monochrom> once you open with "{", you have to use explicit ";", iirc
14:52:59 <dwcook> I believe you can still introduce layout within that, however
14:53:06 <monochrom> whereas, if you don't open with "{", you can use newlines or ";"
14:53:26 <dwcook> e.g., one of the definitions can use layout in its own where
14:53:29 <merijn> Haskell indentation demystified: https://en.wikibooks.org/wiki/Haskell/Indentation
14:53:33 <ReinH> Or you could, you know, learn the layout rules, which takes about 5 minutes.
14:53:46 <monochrom> well, inside one "{" block, if you nest another block within, it's a separate choice all over again
14:54:14 <merijn> Do be warned that using braces will lead to shaming and ridicule by most of the haskell community :p
14:54:19 <monochrom> it took me 25 minutes. perhaps I'm dumb.
14:54:22 <cmtptr> ReinH, it's not a problem of learning the rules.  it's a problem of formatting code in such a way that doesn't generate whitespace noise in change logs
14:54:41 <yesthisisuser> beware of tabs also
14:54:51 <c_wraith> it's not really *noise* if it helps clarify meaning
14:55:07 <c_wraith> and the haskell layout rules are pretty innocuous, because they do help clarify meaning.
14:55:36 <cmtptr> it's noise in a diff if changing one line means 5 subsequent lines have to have spaces added just so they line up
14:55:37 <merijn> cmtptr: So you're saying that if you add an outer block in C you don't indent the contents to match?
14:55:59 <cmtptr> please show me where I said that
14:56:06 <ReinH> Most diff tools can disregrard whitespace changes.
14:56:13 <cmtptr> not the point
14:56:21 <geekosaur> you are implying it, because it's the same situation in a different language
14:56:23 <monochrom> in my ideal world, source code is not in text files, but in tree files, and diffs are node diffs, not line diffs
14:56:41 <c_wraith> The point is, having semantic rules mirror syntactic rules is good for understanding.
14:56:51 <merijn> monochrom: In my ideal world lamdu is finished and working perfectly for haskell ;)
14:56:54 <ReinH> cmtptr: No, the point is that changing how you write code to appease the limitations of a tool you use infrequently, rather than for the primary case of *reading it*, seems like a pessimization.
14:56:56 <yesthisisuser> that's what i have been thinking also.. why is there not a format for structured source code
14:57:11 <monochrom> yeah merijn, that will do
14:57:22 <merijn> cmtptr: Why not the point? If you do, I hate you and don't want you on my projects. If you don't, then how are the problems in haskell different from the same in C?
14:57:40 <cmtptr> ReinH, why is my primary tool dictacting how I format my code?  why can't I be trusted to format it legibly?
14:58:11 <ReinH> cmtptr: Aside from compile-time enforcement, how is this different from adhearing to a particular C indent style?
14:58:13 <simpson> yesthisisuser: Smalltalk, etc.
14:58:14 <monochrom> but most programmers are pretty zealot about "source code must be text files and I must be able to use ed if I wanted to"
14:58:26 <c_wraith> monochrom: the one I hear is grep
14:58:28 * geekosaur willing to bet that if your indentation is not correct for the compiler, it's not correct for easy legibility either
14:58:32 <tinyghost> source code should be stored in AST's
14:58:39 <startling> tinyghost: no way
14:58:53 <yesthisisuser> well some sort of tree at least
14:58:57 <startling> linebreaks and comments are important
14:58:57 <ReinH> I've yet to find a case where adhearance to layout rules would reduce the legibility of Haskell code.
14:59:15 <startling> a language-specific ast-diff tool would be useful though
14:59:22 <tinyghost> startling you could store that along with the tree I guess
14:59:43 <monochrom> grep was derived from ed, was it not? in fact the very name "grep" came from an incidental combination of 4 letters, each standing for one command of ed or something
14:59:49 <merijn> tinyghost: You sound like a person who would be able to appreciate Lamdu :)
14:59:53 <yesthisisuser> i think the format itself could be language-agnostic
14:59:58 <tinyghost> what's lamdu?
15:00:09 <yesthisisuser> but the editor would need to know how to display it
15:00:18 <ReinH> Even if we stipulate that layout creates diff noise, if you prefer littering your code with braces and semicolons to littering your diffs with whitespace noise, I don't think you are optimizing correctly.
15:00:23 <merijn> tinyghost: https://github.com/Peaker/lamdu
15:00:31 <merijn> tinyghost: Check it out, it's really cool!
15:00:33 <cmtptr> merijn, your argument is beside the point because I'm not talking about indenting nested blocks.  I'm talking about changing the length of a function name and being forced to add an arbitrary number of spaces to the following 10 lines just so it lines up to satisfy ghc.  that's goddamn retarded, and if you don't see the different then you're also retarded
15:00:39 <merijn> <- Peaker's PR team
15:00:43 <ReinH> monochrom: grep was derived from g/re/p where re is a regular expression, yes.
15:00:43 <tinyghost> merijn cool thanks! :)
15:00:51 <merijn> cmtptr: You don't have to in haskell
15:01:05 <merijn> cmtptr: See the link I pasted earlier explaining how indenting works in haskell
15:01:22 <ReinH> cmtptr: That's... not something you have to do.
15:01:26 <merijn> cmtptr: https://en.wikibooks.org/wiki/Haskell/Indentation
15:01:31 <ReinH> And calling people retarded won't help you prove your point.
15:01:44 <cmtptr> I don't have to prove my point
15:01:55 <cmtptr> I'm just responding to queries
15:01:56 <ReinH> Ok. Calling people retarded won't help you in any way.
15:02:04 <merijn> You don't have to prove your point, you *do* have to be polite
15:02:16 <merijn> There's no room for rude people in #haskell
15:02:45 <cmtptr> heavens me, please accept my sincerest apologies
15:02:47 <monochrom> I don't know. I don't call other people retarded. but I call myself retarded to prove some points.
15:02:48 <merijn> Being grumpy and calling people names is what ##c and ##java are for
15:02:55 <Hodapp> merijn: now, now...
15:03:03 <merijn> monochrom: Calling yourself names isn't rudeness :)
15:03:07 <merijn> Hodapp: It's a joke :p
15:03:12 * nstdloop supports merijn
15:03:12 <ReinH> It's quite easy to format code such that the indent of the rest of the function is not dependent on the length of the function name.
15:03:17 <Hodapp> merijn: It'd be funny if it weren't so true.
15:03:23 <merijn> Hodapp: Although, only half a joke :)
15:04:01 <yesthisisuser> the only language where I've had problem with indentation rules is Python.. but that's a different story
15:04:09 <nstdloop> I need to do something like this (python) a.append(a.pop() - a.pop() + a.pop())  in haskell
15:04:11 <Hodapp> merijn: It's possible sometimes to get what you need in ##java by looking for whoever berated you first and talking shit to him until he backs off.
15:04:11 <nstdloop> tips?
15:04:22 <simpson> nstdloop: What type is `a` here?
15:04:25 <nstdloop> list
15:04:28 <nstdloop> a long list
15:04:53 <simpson> nstdloop: f (a:b:c:xs) = (a - b + c):xs
15:05:07 <ReinH> Hodapp: I prefer creating a sockpuppet and then answering my question in an obviously incorrect way.
15:05:13 <simpson> With the extra clause, of course: f _ = error "Stack underflow, dudes"
15:05:13 <Hodapp> ReinH: ....what?
15:05:15 <maurer> simpson: That may be incorrect
15:05:19 <ReinH> Hodapp: I've never seen irc users more helpful than when they are trying to prove someone else wrong. ;)
15:05:21 <nstdloop> simpson: pop is from the end
15:05:22 <maurer> simpson: I think append puts it on the other side?
15:05:24 <deech> Is there a way to supress only certain warnings? C2HS is causing a bunch of "defined but not used" warnings.
15:05:31 <Hodapp> ReinH: oh, that's clever.
15:05:45 <nstdloop> append adds to the end of a list, pop pulls off the end of a list
15:05:50 * Hodapp takes off his troll crown and puts it in ReinH
15:05:54 <Hodapp> in? ON.
15:05:54 <ReinH> heh
15:05:55 <simpson> nstdloop, maurer : Oh. If you're gonna treat the list as a stack, why not "reverse" the "direction" of the stack?
15:05:55 <Hodapp> ON.
15:05:56 <maurer> nstdloop: Given his f
15:06:02 <maurer> nstdloop: reverse . f . reverse
15:06:17 <nstdloop> Interesting. I'll give that a shot
15:06:23 <maurer> simpson: I mean, that's the way I'd do it, it's more just along the lines of matching up where the "front" and "back" are in pythonese
15:06:40 <maurer> nstdloop: Though if I were you, I'd just try to do the computation with the "front" being the top of the stack
15:06:50 <simpson> maurer: Right. In Python and other languages where you have a vector or array, the "right" end is correct, but in Haskell, the "left" end is quicker.
15:06:58 <maurer> nstdloop: As in a linked list representation (like you'd get from a haskell list), it's O(1) to fuck with the front, and O(n) to fuck with the back
15:06:59 <simpson> Or in Scheme, etc.
15:07:05 <jmcarthur_mobile> If you really must do it that way, you could use Data.Sequence
15:07:05 <nstdloop> Yup yup
15:07:22 <nstdloop> I just have to think about how I fix all my indexing...
15:07:34 <ReinH> nstdloop: wait, you're using the structure like a stack and also like a queue at the same time? Something seems odd.
15:07:52 <monochrom> it seems clear to me that "the top of the stack is the left side" vs "the top of the stack is the right side" is completely arbitrary and endian war.
15:07:56 <jmcarthur_mobile> nstdloop: I'm going to guess you are misusing lists
15:08:05 <nstdloop> I'm porting my solution for project euler 426 from python to haskell as practice in haskell
15:08:32 <nstdloop> so I have a list that I am adding to, and as I am adding to it I'm looking at the last couple elements and doing stuff to them if some conditions are met
15:08:44 <nstdloop> so I only have "one" pass through the lsi
15:08:46 <monochrom> indeed, why left and why right? the top is clearly the top side.
15:09:12 <simpson> monochrom: I'm using quotes because I'm talking about the order of e.g. pretty-printing the data structure.
15:09:20 <ReinH> Pick one side and call it the top. Call the other side the bottom.
15:09:20 <simpson> The top is the top in both languages.
15:09:28 <jmcarthur_mobile> nstdloop: the head of a list should generally be the "active" part
15:09:49 <nstdloop> Right.
15:10:11 <ReinH> nstdloop: ok, you have two stacks, and you want to push onto the "solution stack" based on pops off of the "problem stack"
15:10:32 <nstdloop> ReinH: Actually, they are one and the same
15:10:38 <ReinH> nstdloop: But they needn't be.
15:10:39 <monochrom> nstdloop, in general, porting is usually a poor approach, plugging circles into squares etc
15:10:51 <nstdloop> monochrom: True ture
15:10:53 <nstdloop> true*
15:11:02 <ReinH> nstdloop: You don't need a deque here. You can just use two stacks.
15:11:19 <ReinH> And trying to modify both the top and bottom of a list is going to be painful.
15:11:42 <monochrom> pedagogically, porting also teaches the least.
15:11:43 <nstdloop> ReinH: All I really need to do is fix my indexing so I can use one list and just reverse it from my original treatment
15:11:58 <ReinH> nstdloop: I don't think your python solution is a good haskell solution
15:12:04 <ReinH> So I wouldn't recommend that approach
15:12:26 <nstdloop> That's also possible
15:13:13 <ReinH> reversing a list on every operation or modifying its tail are both smells that you are using lists wrong.
15:13:20 <Peaker> nstdloop: if you need fast access to both sides of your list, instead of a list you might want a Seq: http://hackage.haskell.org/package/containers-0.5.3.1/docs/Data-Sequence.html
15:13:33 <nstdloop> What I mean is I'd just keep it in reversed order
15:13:36 <Peaker> (though I don't know if the problem you're working on needs such access)
15:13:37 <nstdloop> I only need access to one side
15:13:46 <nstdloop> So I just need to flip my thinking
15:14:03 <jmcarthur_mobile> That sounds right
15:14:12 <ReinH> nstdloop: if you need access to one side, call that side "top" and then choose from the available sides whichever side makes the most sense.
15:14:35 <jmcarthur_mobile> No reverse should be necessary at all if you just think in the other direction
15:14:39 <ReinH> For lists, that side is the left side.
15:14:42 <nstdloop> ReinH: That's my thinking.
15:15:32 <merijn> deech: You can surpress the unused warnings for a single file by adding a pragma with the appropriate warning suppressiong flag using {-# GHC_OPTIONS -fnowarn-whatever #-} to the generated file?
15:16:16 <ParahSailin> im not sure how to call other cmm procedures in the same file with native stack frame set up
15:16:38 <merijn> ParahSailin: That sounds like a question that may get better answers in #ghc?
15:16:52 <merijn> ParahSailin: Seems like something that might get lost in the noise here
15:16:57 <ParahSailin> merijn: thanks
15:17:21 <merijn> (It may take a couple hours before anyone there responds, though :p)
15:17:21 <sm> can my code know in general which characters are going to be rendered using two character cells in my console ? Eg 'çŸ¥'
15:18:03 <geekosaur> not easily, you'd need to use a binding to icu
15:18:12 <geekosaur> and even then it's up to the terminal program to some extent
15:18:19 <ParahSailin> æ—¥æœ¬é¬¼å­
15:18:37 <geekosaur> terminals are not good at giving feedback for stuff like that to the programs running in them
15:19:26 <adimit> @pl \r -> (f r,r)
15:19:26 <lambdabot> (,) =<< f
15:19:43 <adimit> gah. no monads, please.
15:19:54 <merijn> adimit: first
15:20:03 <merijn> :t first not
15:20:04 <lambdabot> (Bool, d) -> (Bool, d)
15:20:13 <merijn> oh, no
15:20:14 <merijn> hmm
15:20:19 <adimit> merijn: I need to create the tuple :-P
15:20:31 <adimit> it should be possible with an applicative mini-reader.
15:20:32 <merijn> :t join (first f)
15:20:33 <lambdabot>     Could not deduce (Arrow (,)) arising from a use of `first'
15:20:34 <lambdabot>     from the context (Monad ((,) (b, a)), FromExpr (b, (b, a)))
15:20:34 <lambdabot>       bound by the inferred type of
15:21:15 <adimit> yes.
15:21:32 <adimit> :t (,) <$> show <*> id
15:21:33 <lambdabot> Show a => a -> (String, a)
15:21:44 <adimit> mini-readers are awesome.
15:22:01 <adimit> (as in, ((->) r)
15:22:27 <FliPPeh> For some reason I always feel bad when I'm using the state monad :(
15:22:43 <FliPPeh> Like I'm betraying everything Haskell stands for
15:23:04 <adimit> FliPPeh: quite the contrary. you're using one of Haskell's strong suits: encapsulating state in a Monad!
15:23:24 <adimit> that said, monads are widely over-used. Like in the above @pl example. Though acutally the monadic variant is almost easier to read.
15:23:48 <FliPPeh> The problem is, I write inherently stateful programs, so there really is no choice :)
15:24:13 <yesthisisuser> an MVar would be more betrayal
15:24:25 <FliPPeh> Well, there is of course, but it's not as comfortable and far less maintainable
15:24:33 <adimit> MVars have their place. Though I prefer to just got STM.
15:24:34 <FliPPeh> Yeah, I try to stay away from MVars as much as possible
15:25:20 <nstdloop> Does >>= always guarantee sequential evaluation?
15:25:27 <nstdloop> Or is that just in the IO monad?
15:25:29 <FliPPeh> I think it does
15:25:43 <merijn> nstdloop: Depends on how you define sequential and evaluation :)
15:25:45 <dwcook> nstdloop, it guarantees nothing about evaluation.
15:25:46 <shachaf> "sequential evaluation" isn't quite meaningful.
15:25:51 <nstdloop> single-threadedness
15:25:57 <nstdloop> I guess
15:26:02 <merijn> nstdloop: Think of the list monad
15:26:10 <merijn> nstdloop: What does it mean there?
15:26:17 <shachaf> I don't think the Haskell report talks about threads.
15:26:19 <merijn> nstdloop: for IO and STM you can think of it as sequential, yes
15:26:21 <nstdloop> It's basically concatMap, right?
15:26:24 <FliPPeh> Oh yeah, relying on sequential evaluation in IO is a bit dangerous
15:26:28 <adimit> nstdloop: the point of >>= is to ensure that the right-hand side computation depends on the result of the left-hand side computation.
15:26:34 <adimit> (I think.)
15:26:38 <shachaf> Not really.
15:26:49 <adimit> shachaf: enlighten me :-)
15:26:56 <adimit> if you want.
15:27:21 <quchen> Reverse state violates all the things said so far I think.
15:28:04 <shachaf> It's difficult to violate something that doesn't have a precise meaning.
15:28:19 <FliPPeh> I know that "s <- readFile f; writeFile f s" will fail horribly
15:28:50 <dwcook> That's because of lazy IO, not anything to do with Monad in particular
15:29:18 <quchen> If by sequential you mean "effects on the left of >>= happen before what's on the right" then I would say most Monad instances do that (for some value of "before"), but in general I would be careful with that.
15:29:18 <dwcook> In other words, it has to do with the interaction between the behaviors of readFile and writeFile
15:29:35 <eacameron> recommendations for a commandline args library?
15:30:01 <Feuerbach> eacameron: optparse-applicative
15:31:08 * hackagebot assert-failure 0.1 - Syntactic sugar improving 'assert' and 'error'  http://hackage.haskell.org/package/assert-failure-0.1 (MikolajKonarski)
15:31:08 <eacameron> Feuerbach: cool, I'll look into it
15:31:10 <eacameron> any others?
15:32:08 <quchen> eacameron: http://hackage.haskell.org/packages/search?terms=command+line+argument
15:32:23 <quchen> I think optparse-applicative is the usual recommendation here though.
15:32:38 <eacameron> quchen: hackage needs a 5-star rating system
15:33:05 <adimit> eacameron: social features are slowly finding their way into hackage.
15:33:12 <adimit> i.e. it's on the agenda.
15:33:12 <startling> "fix x and I'll make it five stars"
15:33:16 <merijn> eacameron: rating/recommendation system for hackage is on the agenda
15:33:24 <nstdloop> That would be fantastic
15:33:29 <eacameron> I was joking...but that really would be nice
15:33:49 <nstdloop> It would make the process of identifying good packages much much easier
15:33:51 <dwcook> Post your package to Pinterest
15:33:54 <adimit> I'm not enthusiastic about social hackage. Curious, but I don't know how I feel about it.
15:33:57 <eacameron> can we have a 5-star rating for the users who vote as well? I trust some coders more than others ;)
15:34:02 <monochrom> eacameron: my https://github.com/treblacy/random-read/blob/master/random-read.hs has an example use of optparse-applicative
15:34:03 <quchen> Well there's a "number of downloads" field already. Something like "downloads in the last 100 days" should be fairly easy to implement in the search results.
15:34:52 <eacameron> monochrom: awesome
15:34:52 <adimit> BTW, does anybody have an example of a tying-the-knot with error handling? i.e. when (one of) the recursive step(s) can indicate failure via Maybe or Either?
15:35:50 <startling> I'm not sure how tying the knot has anything to do with it?
15:36:13 <startling> You can wrap the recursive call in a catchError to make it more specific.
15:36:19 <adimit> I think it might not always be doable, because you might need to inspect the recursive step, thus violating laziness.
15:36:31 <startling> and have a list-like error state
15:36:48 <eacameron> dwcook: just read your idea about Pintrest: lol!
15:36:56 <startling> adimit: there's no inspection involved
15:38:42 <adimit> startling: I have two data-types that depend on each other. Specifically, one of the types needs to have a map of the other one, to select which one it is going to choose. The lookup step may of course fail. Now I don't want the map containing monadic error representation values, but the plain values.
15:38:50 <adimit> erh. That wasn't very clear, was it?
15:39:34 <startling> not really. :)
15:40:41 <monochrom> adimit: I would not think "I must tie a knot" or "I must not tie a knot". I carefully specify the problem, then carefully solve it. then, in restropsect, maybe it ties a knot, or maybe it doesn't.
15:42:15 <adimit> say you have data A = A [B] and data B = B A. You *want* m :: Map String A, and you construct Bs from [String]. so mkA :: [String] -> A, but only if lookup can't fail, otherwise it's mkA' :: [String] -> Maybe A
15:42:56 <adimit> monochrom: in the case where two data types directly reference each other and I have an aggregate structure of one, I know I have to implement some form either circularity or indirection.
15:43:10 <monochrom> in retrospect, I did tie a knot involving a Data.Map lookup. but like I said, I started out just solving a problem. the technique was emergent, not prescribed.
15:43:17 <sm> geekosaur: thanks. It looks like I can query the EastAsianWidth property using text-icu, and this will be a pretty strong indicator of the render width in a console
15:43:46 <adimit> monochrom: well, I have my full technique, actually. Now I'd like to get rid of that ugly fromJust :-)
15:43:54 <sm> if I can figure out what brew libs to install for text-icu on osx, that is
15:46:25 <marx2> is it possible to "cast" a to Show a?
15:46:47 <benmachine> marx2: a might in general be a thing that can't be shown
15:46:47 <dwcook> marx2, no. a is a type, Show a is a typeclass constraint.
15:46:52 <dwcook> Please define what you mean by "cast".
15:47:04 <ReinH> adimit: fromJust is an admission that you are doing something that can cause runtime errors.
15:47:10 <marx2> bencmachine if it does not implement Show crashing at runtime will be fine
15:47:12 <benmachine> ReinH: not necessarily
15:47:24 <benmachine> marx2: how about something even more evil?
15:47:26 <marx2> dwcook I want to use it as if it implemented Show a
15:47:37 <ReinH> adimit: it isn't a wart on an otherwise elegant solution, it's an indication that there is something wrong with your solution.
15:47:38 <benmachine> marx2: actually no, my evil hack doesn't work here
15:47:46 <benmachine> marx2: there's not really a way to do what you want
15:47:57 <marx2> :/
15:48:02 <monochrom> I prefer: if it does not implement Show, crashing at compile time is fine. then, use hugs to blur "compile" time and "run" time.
15:48:06 <dwcook> marx2, how are you going to make the distinction?
15:48:18 <marx2> distinction between what?
15:48:21 <benmachine> marx2: tell us about your problem, we might be able to make it go away indirectly
15:48:25 <dwcook> Between things with and without a Show instance.
15:48:27 <adimit> ReinH: depends on whether I make sure beforehand that there is a chance or not that something could turn out Nothing. I don't think it's an "admission of failure" inasmuch as an admission of "I couldn't make the types check out"
15:49:02 <merijn> adimit: Sure, but sometimes when you're using TypeFamilies, etc. you might know more about the types than GHC can understand :)
15:49:07 <marx2> benmachine I want to write Debug.Trace.trace that does not require adding spurious Show  constraints
15:49:17 <benmachine> marx2: so this is for debugging?
15:49:21 <marx2> yes
15:49:22 <adimit> fromJust is in the same league as null checks in, say Java. You can live with it, you just have to be (more) defensive, because you're undermining the type system.
15:49:27 <merijn> adimit: Granted, at that level you no longer need to ask permission for using fromJust :)
15:50:03 <adimit> merijn: yes, that is correct. As spj sometimes like to say: type systems reject some good programs and accept some bad ones.
15:50:05 <startling> marx2: I've been annoyed by the same thing
15:50:11 <benmachine> marx2: okay, do you know what the type is going to be?
15:50:33 <adimit> so sometimes, when you know what you're doing, you fudge. But I'm curious whether I have to fudge in my case.
15:50:38 <monochrom> I am unconvinced that you need such a generic trace.
15:50:41 <adimit> I'd rather not!
15:50:59 <marx2> for example, to track accumulator in myfoldr function I had to temporarily change the type of the function to `myfoldl :: Show d => (d -> a -> d) -> d -> [a] -> d' just for debugging purposes
15:51:02 <dwcook> That reminds me, I've been curious whether there are any legitimate uses of unsafePerformIO.
15:51:13 <dwcook> "Legitimate" meaning "nothing else would serve as well".
15:51:14 <ReinH> adimit: Well, your Map lookup that can't fail is isomorphic to some total function String -> A
15:51:20 <startling> it's annoying having to change (potentially many) type signatures in order to trace a deeply-nested call
15:51:21 <benmachine> dwcook: the FFI is a common one
15:51:22 <sm> stack overflow to the rescue. I got text-icu installed on osx, but it seems too hard for users - special cabal options required. I wonder if I can just hard code a list of all the wide unicode chars
15:51:35 <startling> dwcook, writing (>>=) for IO
15:51:59 <ReinH> adimit: well, some total function from the subset of possible strings -> A
15:52:05 <dwcook> benmachine, basically, you know more about the C library or otherwise than the compiler does?
15:52:06 <monochrom> @quote monochrom debug
15:52:06 <benmachine> startling: that's not really necessary, (>>=) already has access to internals
15:52:06 <lambdabot> monochrom says: it was fun debugging Debug :)
15:52:13 <monochrom> hmm, not that one
15:52:14 <marx2> benmachine it should work with any type to be useful
15:52:14 <adimit> ReinH: the thing is: it *can* fail. *But* I could add another pass beforehand to make sure it doesn't. Plus said function you described is not in Data.HashMap :-) I only get lookup, which always returns a Maybe.
15:52:28 <startling> benmachine: fair enough.
15:52:35 <benmachine> dwcook: not that exactly, you might make a pure function out of impure bits
15:52:43 <merijn> dwcook: Top level MVar/TVar is where I use unsafePerformIO occasionally
15:52:48 <benmachine> dwcook: you want the impure bits to be in IO for your convenience, but the pure interface should not be
15:52:49 <ReinH> adimit: Right, because you can't express "this subset of String" in Haskell's type system. It's still a partial function String -> A.
15:52:49 <adimit> so if I *know* that lookup won't fail, it's OK to use fromJust.
15:53:09 <benmachine> dwcook: or you might use it in combination with e.g. Storable stuff, 'with' &c.
15:53:10 <Peaker> adimit: I never use fromJust, because the error if I'm wrong is opaque
15:53:17 <ReinH> adimit: What do you do in the pass that makes sure it doesn't fail?
15:53:21 <Peaker> adimit: I use: fromMaybe (error "Here's why I think this won't ever be Nothing")
15:53:22 <benmachine> in which case it's nominally an IO operation but in some uses you can hide the IOness
15:53:39 <adimit> Peaker: yes, that's definitely a good practice.
15:53:40 <Peaker> adimit: and of course if I can refactor to avoid the Nothing case I would
15:53:49 <ReinH> adimit: maybe you want a monoid for A to represent your failure/default value?
15:53:55 <benmachine> marx2: you certainly can't do that without type constraints or GHC magic, and I don't know of any way to do it with
15:54:06 <merijn> dwcook: i.e. "myEvilGlobalState :: MVar Foo; myEvilGlobalState = unsafePerformIO newEmptyMVar; {-# NOINLINE myEvilGlobalState #-}"
15:54:29 <adimit> ReinH: I'd rather just go the ErrorT route.
15:54:33 <benmachine> adimit: even failable pattern matches (let Just x = blah) are better than fromJust because you get automatic source location annotations
15:54:37 <adimit> or, actually Either.
15:54:38 <dwcook> benmachine, is this a similar idea to ST?
15:54:48 <benmachine> dwcook: yeah, kinda
15:54:57 <nstdloop> So, typically, is it better style to use >> and >>= or do blocks?
15:55:06 <benmachine> dwcook: except that the type system can't prove what you're doing is safe, especially if you're invoking C libraries
15:55:06 <dwcook> nstdloop, whatever ends up being more readable
15:55:09 <benmachine> nstdloop: no :P
15:55:10 <adimit> yes, fromJust is evil, I know. It's just a proof-of-concept code, I won't even check it into git! :-D
15:55:12 <merijn> nstdloop: I use both, depending on whatever is more readable
15:55:27 <benmachine> nstdloop: i.e. what everyone else said
15:55:30 <ReinH> adimit: you said that you can do something to make sure it doesn't fail. What is that thing?
15:55:32 <merijn> nstdloop: two short expressions? >> or >>=, long form IO code? do-notation
15:55:46 <nstdloop> alright. makes sense
15:56:05 <benmachine> ReinH: think really hard
15:56:09 <benmachine> this sometimes suffices
15:56:52 <adimit> ReinH: the map is generated from a seed list, and all the Strings from the String -> A lookup are from a second seed list. If I check that all values in the latter reference members of the former, lookup cannot possibly fail.
15:57:19 <adimit> both are known exhaustively at the point where I compute my map data structure (it's a type hierarchy, actually.)
15:57:39 <benmachine> marx2: fwiw, with a fully polymorphic function, the type of the argument (and therefore, the knowledge of how to inspect it) just isn't there at all
15:58:16 <benmachine> marx2: the thing is in order to show an Int you run completely different code than to show a Char, so your program needs to know which it has, or have a show-this callback
15:58:27 <benmachine> marx2: a fully polymorphic function doesn't have either so can't do anything
15:58:28 <marx2> benmachine I see
15:59:06 <benmachine> marx2: I'm not an expert on this stuff so I might be wrong, but that's how I understand it
15:59:21 <dwcook> @djinn a -> b
15:59:21 <lambdabot> -- f cannot be realized.
15:59:27 <ReinH> adimit: is your map actually used as a cache / for memoization?
15:59:48 <dwcook> @djinn (Monoid b) => a -> b
15:59:48 <lambdabot> Error: Class not found: Monoid
15:59:52 <adimit> ReinH: sort of, yes.
16:00:07 <monochrom> that is pretty much right. GHC does everything to erase type-related information. only constraints force GHC to carry some type-related information.
16:00:42 <monochrom> for debugging, you should use an interpreter, which saves that information
16:00:45 <adimit> after parsing a signature of a formal system, I want to generate an AST of expressions in that signature. The parsing step for said expressions will depend on finding the right members in the signature.
16:00:51 <Peaker> monochrom: why does it need to "do" anything to erase it? The easiest thing is not to keep it. isn't it?
16:01:27 <benmachine> (oh yes, what I just said applies to GHC and may not apply elsewhere)
16:01:41 <monochrom> I don't know. it's a cool thing to say.
16:01:43 <marx2> so it would be possible to do this in ghci?
16:01:58 * monochrom does everything to do the easiest thing, ok?
16:02:00 <benmachine> marx2: ghci has a debugger, which... might be able to help? I'm not really sure
16:02:10 <benmachine> I've never used it
16:02:16 <merijn> When I saw the ghci debugger in action it was pretty amazing
16:02:17 <benmachine> because obviously my programs never have any bugs <_< >_>
16:02:36 <merijn> But then I still proceeded to not ever use it, because my bugs are usually found to easily >.>
16:02:52 * benmachine high fives merijn 
16:03:07 <adimit> I have the feeling the ghci debugger could be useful, but it's such a steep learning curve that just using trace and some testing code usually does the trick :-\
16:03:24 <monochrom> my programs had a few bugs but not enough to force a debugger
16:03:54 <danilo2> Hello! What should I use to benchmark my Haskell Accelerate / Repa code? I do not want to benchmark a particular function (then I owuld use criterion), but I want simply to print "time" after some operations to see how much time takes loading image form disk or writing it back ?
16:03:56 <ReinH> adimit: So you can prove that your function is total for some known subset of String but can't represent this in the type system. I'd probably use fromMaybe with a nice error message for the Nothing case as Peaker suggested.
16:04:31 <ReinH> danilo2: have you used GHC's profiling features?
16:04:34 <monochrom> so far, in all my programming and not just haskell, I have only used debuggers to follow other people's poorly written code.
16:04:42 <adimit> ReinH: I haven't given up on just using Either yet :-)
16:04:48 <adimit> i.e. proper error handling.
16:05:00 <Peaker> monochrom: did you write some large C systems?
16:05:07 <ReinH> adimit: well, you can `note` your Maybe and then use ErrorT.
16:05:08 <monochrom> no
16:05:11 <Peaker> monochrom: a debugger is very useful there :)
16:05:26 <adimit> now, if I had spent less time in IRC and actually written the damn thing, I'd be a lot wiser now.
16:05:28 <sm> marx2: thanks for working on that
16:05:30 <ReinH> Peaker: Large, hairy C systems? Like, for instance, GHC? ;)
16:05:33 <danilo2> ReinH: not yet. Do they allow me to benchmark this?
16:06:00 <ReinH> danilo2: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/profiling.html
16:06:06 <Peaker> ReinH: the GHC RTS also makes a debugger useful, yeah :)  I think when I debugged a non-trivial patch for the RTS I used print-debugging for some reason
16:06:14 <ReinH> danilo2: you can specify those functions as cost centers and then have GHC report on them
16:06:14 <danilo2> ReinH: Reading it right now :)
16:06:24 <Peaker> ReinH: I guess gdb on a Haskell program to debug its RTS is hard
16:06:28 <danilo2> ReinH: Sounds good, thank you! :)
16:06:35 <monochrom> but I used a debugger on a classmate's poorly written, segfaulting C program to find out that the segfault was an indirect result of pointer cavalierism such as freeing twice or freeing and then using.
16:06:36 <Peaker> Hmm.. for some crashes I think I may have used gdb that way
16:07:12 <monochrom> yes, a debugger for a merely 50-line C program is necessary, but only when it is not written by me.
16:07:17 <ReinH> danilo2: btw you can use this in coordination with criterion, where you're using criterion basically to ensure that you get enough runs to make some statistical sense out of the profiling data.
16:07:22 <Peaker> monochrom: well, even competent programmers sometimes write "poorly written" stuff due to a mistake here and there, that's why we need type systems. Though C's type system doesn't find many of the mistakes a debugger helps find
16:07:22 <danilo2> Peaer: but are we talking about gdb? Is gdb needed to profile Haskell programs ?
16:07:39 <Peaker> danilo2: debug the RTS, not profile
16:07:54 <ReinH> Peaker: I'm talking about the scary C code inside GHC, esp. in the parallel runtime. o_O
16:07:55 <Peaker> danilo2: Runtime System, written in C and embedded into Haskell executables
16:08:23 <danilo2> Peaker: Oh. I'm happy I do not know what it is exactly ;)
16:08:24 <Peaker> ReinH: yeah, the RTS, I made a patch there to speed up StablePtrs and StableNames significantly :)
16:08:37 <ReinH> Peaker: excellent. Better you than me.
16:08:50 <Peaker> so that I can beat jdh's benchmarks on fastest mapping structures in Haskell vs F# :)
16:08:51 <sm> marx2: there must be some GHC.* primitive to dump the first few bytes of binary data, at least
16:08:53 <ReinH> Peaker: We talked to SimonM about it a bit and he basically said "Dragons. Dragons everywhere."
16:09:07 <danilo2> Peaker, ReinH: and If I want to simply print the "time", is it possible? Are there any functions, I should use / avoid ?
16:09:24 <ReinH> Peaker: I'm pretty sure my GHC contributions (if I ever have any) will be strictly limited to the Haskell bits...
16:09:30 <danilo2> Peaker, ReinH: sometimes I do not need very detailed profiling, I just want to print the time
16:09:40 <Peaker> ReinH: heh, the parallelism-thunk stuff is the crux of concurrency difficulty
16:09:54 <Peaker> danilo2: print the time of what?
16:10:05 <ReinH> Peaker: I'm interested in, e.g., replacing the deque with a new fancy dynamic deque, but I am pretty sure I am not competent to do so.
16:10:24 <ReinH> Peaker: but not dropping parallelism on the floor due to fixed deque size seems good
16:11:02 <Peaker> ReinH: oh, the spark queue thing? I asked #ghc about it and dcoutts explained a better idea would be blocking when trying to increase the size of the sparks queue willy-nilly
16:11:06 <danilo2> Peaker: probably cpu time if we wnat to use it as "some kind of benchmark"
16:11:14 <Peaker> danilo2:  http://hackage.haskell.org/package/timeit-1.0.0.0/docs/System-TimeIt.html maybe?
16:11:36 <danilo2> Peaker: oh, interesting. Thanks :)
16:12:20 <ReinH> Peaker: the work stealing deques
16:12:47 <sm> I just made some fancier trace helpers for Show instances - https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Utils.hs#L379
16:14:20 <Peaker> ReinH: for sparks, right?
16:14:20 <sm> I wonder if using unsafePerformIO to check command line args could mess up anything else. And whether doing it often would have any performance impact
16:14:47 <ReinH> Peaker: right
16:14:50 <Peaker> sm: eww
16:15:15 <Peaker> sm: just use optparse-applicative or such, and get your args the proper way? :)
16:15:35 <Peaker> ReinH: yeah, so if you let it grow dynamically, you start "leaking" thunks (over-buffering them, at least)
16:15:51 <Peaker> ReinH: instead, you want to slow down whatever it is that's generating them (e.g: by blocking it) to allow old ones to execute first
16:15:53 <sm> sometimes I need to debug before options are parsed, or in pure code which doesn't have them available
16:16:11 <Peaker> sm: Then put the pure code in a Reader of the program options too?
16:16:38 <sm> it's nice to have a trace that works everywhere even if you didn't plan for it, and that you can toggle on off
16:16:48 <Peaker> sm: why do you need to debug before parsing opts? you can parse opts first thing in your program
16:16:48 <ReinH> Peaker: Right, you might have a space leak, but there's leaks and then there's dropping things on the floor... I'm not sure what the tradeoffs are.
16:17:16 <sm> Peaker: parsing opts is itself pretty tricky and in need of debug output :)
16:17:16 <Peaker> sm: hmm.. I just add Debug.Trace when I need such a trace. I don't want to keep such stuff in supposedly pure code
16:17:26 <Peaker> sm: not with optparse-applicative :)
16:17:40 <sm> yeah it would be
16:17:43 <Peaker> ReinH: but the slow-down-producer solution doesn't drop anything to the flor
16:18:11 <Peaker> sm: well, while you're debugging, temporarily use Debug.Trace. Once it's debugged, would you want it to lie about its purity in the types?
16:18:23 <Peaker> And also, have the traces in the code?
16:18:57 <bos> @pl \(f,g) (x,y) -> (f x, g y)
16:18:57 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
16:19:03 <bos> >:_(
16:19:08 <ReinH> This seems like a case for testing your options parser
16:19:31 <ReinH> bos: something from arrows?
16:19:36 <bos> ReinH: yes
16:19:46 <intrados> Is there a pl equivalent for desugaring do notation?
16:19:51 <shachaf> Yes, @undo
16:20:01 <intrados> shachaf: Thanks
16:20:03 <shachaf> bos: That's one of the most-requested @pl things that doesn't have an easy answer.
16:20:17 <FreeFull> @undo do { x <- y; z <- x; z }
16:20:17 <lambdabot> y >>= \ x -> x >>= \ z -> z
16:20:35 <FreeFull> @pl  y >>= \ x -> x >>= \ z -> z
16:20:35 <lambdabot> join =<< y
16:20:43 <sm> Peaker: I'm still using Debug.Trace. But, now I can insert a quick "dbg LVL " and leave it there, and adjust the debug output at the command line. I got tired of always having to edit code and recompile to adjust debug output
16:20:43 <bos> shachaf: i thought it was (***)
16:20:53 <scott_> bos: uncurry (***) I think
16:21:07 <FreeFull> :t uncurry (***)
16:21:08 <lambdabot> Arrow a => (a b c, a b' c') -> a (b, b') (c, c')
16:21:11 <shachaf> Oh, hmm, right, uncurry (***)
16:21:23 <sm> it clutters the code only slightly and certain functions are handy to leave instrumented this way
16:21:32 <Peaker> sm: you do a lot more Debug.Trace'ing than I do, I guess
16:21:34 <scott_> > uncurry (***) (f, g) (x, y) :: (Expr, Expr)
16:21:35 <shachaf> I must be thinking of something else. There was some sort of tuple thing.
16:21:36 <lambdabot>  (f x,g y)
16:21:44 <ReinH> sm: But you're still littering your code with unsafePerformIO o_O
16:21:55 <Peaker> sm: I do keep around a little git commit with addition of traces sometimes, but I rarely need it
16:22:04 <sm> yeah, I do a lot of tracing (seems the best option at the moment)
16:22:19 <ReinH> sm: I think your code is telling you to test things more. :)
16:22:36 <Peaker> sm: you could be explicit about it in the types: use some Reader/Writer monad combo for everything that can read the configuration and write debug logs
16:22:58 <Peaker> sm: ReinH is probably right, if you had small test cases for small pieces of code, printing would be far less useful
16:23:06 <ReinH> If you're unsure about the behavior of, e.g., option parsing, I think you should write tests for your option parsing.
16:23:07 <sm> ReinH: yup, well that's why I brought it up.. I'm not totally clear how bad this is. If I use it to getArgs, can it also mess up other I/O in observable ways ? I haven't noticed any problems yet
16:23:37 <sm> tests are too static, it's helpful to have traces of your actual code as well
16:24:08 <ReinH> Anything you can observe using traces you can test instead.
16:24:23 <Peaker> ReinH: that's not necessarily true -- but good code should strive for it
16:24:28 <intrados> Is there a package for installing @undo locally like 'pointfree'?
16:24:36 <sm> I think a trace is often a more lightweight & maintainable test
16:24:43 <ReinH> Peaker: If your code doesn't allow you to do that in some case then that's a smell :)
16:24:52 <volko> hrmm, trying to compile accelerate, but I keep getting errors "Couldn't figure out LLVM version!"
16:24:54 <Peaker> sm: a test gives you good/bad feedback if you run it
16:24:55 <volko> I have llvm installed
16:24:59 <volko> through homebrew
16:25:04 <Peaker> sm: a test suite gives you some confidence about the code
16:25:15 <ReinH> sm: Sure, it's more lightweight. Not having tests is also more lightweight than having tests.
16:25:45 <sm> but I can't realistically write and maintain tests for every possible runtime situation. Eg specific data on a user's machine. Having traces built in wins there
16:25:56 <sm> I also have tests. Of course
16:26:35 <ReinH> Good thing you don't need to write tests for every possible runtime situation.
16:26:57 <ReinH> And where you do want that sort of coverage, it's usually for cases where it's pretty easy to get it via QuickCheck
16:27:18 <ReinH> All I'm saying is: needing a bunch of debug statements is a smell that you aren't testing effectively.
16:27:46 <Apocalisp> Is there anything like parser combinators for consuming values that are available all at once?
16:27:47 <sm> I hear you. I think they are complementary techniques though
16:28:11 <ReinH> sm: I think the goal for both is the same: to increase confidence. I think that tests are a superior way to gain confidence.
16:28:19 <shachaf> Apocalisp: What do you mean?
16:28:27 <sm> unless my debug statements are going to distort my programs functioning. Are they ?
16:28:38 <ReinH> sm: They might make it difficult to reason about IO performance
16:29:11 <Apocalisp> shachaf: I mean the input is not a stream of values but random-access, like a Map
16:29:13 <sm> ReinH: you mean even if I don't use --debug ? because of frequently calling unsafePerformIO ?
16:30:07 <asdf1234> I'm having a bit of trouble installing ghc head with dynamic libraries. It seems to compile fine, but when I go to make install, I get an error telling me about a mismatched interface file for GHC.CString (wanted "dyn", got " ") http://lpaste.net/96854
16:30:15 <ReinH> sm: you might be able to set the debug level as a CAS using unsafePerformIO, but it's difficult in general to reason about when unsafe IO will be interleaved
16:30:39 <Feuerbach> The fact that sm wrote one of the very few existing useful programs in Haskell tells me that he knows what he's doing
16:31:09 <ReinH> sm: I would be happier if you could prove that you only perform IO to get the debug level once, and that debug statements with debugging set to off do not perform any subsequent IO.
16:32:03 <ReinH> sm: I'm not at all sure how to prove that because I'm not sure how to reason about unsafe IO :)
16:33:15 <rtpg> anyone know how to install the profiling libs for base?
16:33:16 <sm> ReinH: that was my first approach actually, but I changed it to do IO every time to make it toggleable in ghci
16:33:41 <asdf1234> how does one fix a mismatched interface file error?
16:34:27 <sm> it doesn't feel very nice, but it helps me solve problems and doesn't yet create any that I notice. If it did, I could compile it out in production builds. I'd rather leave it in though
16:35:41 <asdf1234> alternatively, how might I manually make install ghc
16:35:57 <Feuerbach> rtpg: they should come with your GHC or Platform installation, unless you screwed something up
16:36:16 * hackagebot bindings-GLFW 3.0.3.2 - Low-level bindings to GLFW OpenGL library  http://hackage.haskell.org/package/bindings-GLFW-3.0.3.2 (BrianLewis)
16:36:19 <ReinH> sm: I'd be interested to see how that instrumentation affects something with heavy IO like warp.
16:36:43 <ReinH> sm: It seems unlikely to affect non-IO-bound systems in practice, but... who knows?!
16:37:41 <rtpg> Feuerbach : even if I installed just ghc? I think I didn't install haskell-platform (because ubuntu 13.10 was in a bad spot for some stuff)
16:38:12 <Feuerbach> rtpg: binary releases of GHC have profiling libraries
16:38:20 <Feuerbach> or did you do a source install?
16:38:26 <rtpg> binary install
16:38:50 <asdf1234> even a source install builds profiling libraries unless you've mucked around
16:39:25 <rtpg> they should be in /usr/lib/ghc/base-version/ right?
16:40:11 <Feuerbach> rtpg: ${PATH_TO_GHC}/lib/ghc-*/base-*/libHSbase-*_p.a
16:40:24 <sm> we shall see.. thanks for the chat all
16:40:30 <Feuerbach> if you have it, you're fine
16:41:35 <Feuerbach> rtpg: oh, did you install through the pkg manager? then it might be in a different package (like -prof)
16:42:03 <mekeor> i've got a weird/complex question on "how to implement apparent inheritance for record data types in haskell?": http://lpaste.net/96855
16:42:44 <asdf1234> mekeor: you mean like a typeclass?
16:42:47 <rtpg> we have a winner
16:42:52 <rtpg> seems there's a ghc-prof
16:43:20 <asdf1234> mekeor: why's it have to be explicit record types?
16:43:28 <asdf1234> mekeor: why's it have to be explicit records*?
16:44:18 <mekeor> asdf1234: well, it doesn't have to be. you're right :)
16:44:31 <asdf1234> ;)
16:44:40 <mekeor> asdf1234: but it was simpler to give the field a name ;) :P
16:45:12 <mekeor> asdf1234: do you think i should use a type class?
16:45:30 <asdf1234> mekeor: unfortunately, records share namespaces .. unless something's changed, there's no way to "inherit" records without composing data types
16:45:40 <asdf1234> and that's not what you're looking for
16:45:58 <mekeor> yeah
16:46:03 <mekeor> so,... what can i do?
16:46:14 <asdf1234> you could use a typeclass; if you're feeling adventurous, give lenses a shot
16:46:18 * hackagebot GLFW-b 1.4.3 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.4.3 (BrianLewis)
16:46:45 <mekeor> asdf1234: how would lenses solve this issue?
16:47:10 <asdf1234> mekeor: they give you accessors that would be pretty close to what you want
16:47:35 <mekeor> asdf1234: hm, okay
16:47:40 <mekeor> asdf1234: thank you :)
16:47:46 <asdf1234> mekeor: have fun
16:49:06 <cariveri> merijn: hey. could you have a quick look? http://lpaste.net/96856 I dont understand the failure message.
16:49:41 <joelteon> Is there a haskell library for interacting with LXC containers?
16:50:04 <dwcook> cariveri, you tried to compare your a for equality but didn't stipulate that it should have an Eq instance.
16:50:55 <rtpg> how can a reinstall break other libraries
16:51:07 <cariveri_> I never compare b and though ghc wants me to add Eq b. why is that?
16:51:54 <dwcook> cariveri, it says a, not b.
16:52:03 <mekeor> rtpg: do you mean "how can i reinstall a package without breaking other libraries?" or something like that?
16:52:04 <dwcook> You told it that b can have Eq, but not a.
16:52:51 <rtpg> mekeor I guess that is the underlying question
16:52:54 <cariveri_> dwcook: yes.sorry. a of course.
16:53:04 <rtpg> trying to do install world --reinstall gives me a complaint about base versioning
16:53:28 <asdf1234> rtpg: perhaps clear out your ~/.ghc and then install the world freshly
16:54:53 <asdf1234> rtpg: additionally, breaking other packages is really easy :) .. overlapping, incompatible library versions are rather common
16:55:10 <rtpg> but this was a reinstall of the same library
16:55:13 <rtpg> same version
16:55:48 <asdf1234> rtpg: if the dependency resolver tells you it breaks base, you can either force it and break base or reinstall everything and hope for the best
16:56:16 <rtpg> I feel like if I break base I will be bothered by more fundamental issues than profiling
16:56:31 <asdf1234> rtpg: I'd recommend not breaking base
16:57:38 <monochrom> cariveri_: y is a Maybe (Tree (a,b)), no? therefore, "y == Nothing" requires a full Eq over Maybe (Tree (a,b)). if Tree has "deriving Eq", then it in turn requires Eq on both a and b, long story short.
16:58:10 <monochrom> however, "y == Nothing" is the world's worst way to ask "is y Nothing". use pattern matching instead.
16:58:56 <monochrom> getNodeByIdFromList (x:xs) id = case getNodeById x id of Nothing -> getNodeByIdFromList xs id; y -> y
16:59:01 <asdf1234> :i Maybe
16:59:07 <dwcook> @type isNothing
16:59:08 <lambdabot> Maybe a -> Bool
16:59:09 <monochrom> there is no :i
16:59:13 <dwcook> :type isNothing
16:59:19 <dwcook> Oh there we go
16:59:27 <monochrom> there is also no :type
16:59:31 <asdf1234> instance Eq a => Eq (Maybe a)
16:59:34 <dwcook> Anyway, either that or pattern matching
16:59:47 <asdf1234> :t isNothing
16:59:47 <lambdabot> Maybe a -> Bool
16:59:55 <asdf1234> :) :t works, friend
17:00:13 <cariveri_> hmm ok let me see.. in any case I dont need Eq tree and not even Eq a .
17:00:30 <monochrom> "y == Nothing" is so horrible that I don't even bother writing an article to argue against
17:00:40 <asdf1234> you only need Eq if you want to compare values within a type
17:00:46 <dwcook> Similar issue with xs == []
17:00:48 <monochrom> that's right, if you use pattern matching, you won't incur an Eq
17:01:13 <asdf1234> hypothetically, pattern matching is also less costly than ==
17:02:06 <dwcook> > (0 / 0) == (0 / 0)
17:02:08 <lambdabot>  False
17:02:22 <asdf1234> (0 / 0) /= (0 / 0)
17:02:29 <asdf1234> > (0 / 0) /= (0 / 0)
17:02:31 <lambdabot>  True
17:02:59 <asdf1234> > 0 ^ 0
17:03:00 <lambdabot>  1
17:03:04 <asdf1234> > 0 ^ 0 / 0
17:03:06 <lambdabot>  Infinity
17:03:15 <monochrom> catchy saying: languages with ubiquitous equality are of questionable quality :)
17:03:22 <dwcook> I could've done without the parens, I just momentarily forgot that == binds less tightly
17:03:35 <asdf1234> monochrom: so you like scala, huh?
17:03:39 <dwcook> monochrom, what do you mean by "ubiquitous equality"?
17:03:57 <monochrom> that automagically every type enjoys an equality operator
17:03:58 <cariveri_> ok thank you. seems to work with th ecase solution.
17:04:24 <haasn> monochrom: reallyUnsafePtrEquality ;)
17:04:30 <monochrom> that the language encourages you "xs == []" because it is always available
17:04:46 <dwcook> haasn, that's basically what C does for structs and functions, isn't it?
17:04:59 <haasn> dwcook: except GC destroys it
17:05:08 <haasn> and â€˜equalâ€™ values can have different copies on the heap either way
17:05:10 <asdf1234> dwcook: req for short.. as in it'll req your program
17:05:27 <monochrom> asdf1234, I don't know scala. but I heard that scala has ubiquitous equality, and therefore by my standard is of questionable quality
17:06:17 <asdf1234> monochrom: it upholds the java tradition of ubiquitous equality
17:07:27 <chrisdone> monochrom: sometimes i'd like an isEmpty :: Monoid m => m -> Bool for the monoid class
17:07:43 <chrisdone> just to not incur an Eq
17:08:49 <dwcook> chrisdone, how do you implement that for (Monoid b) => a -> b?
17:09:05 <chrisdone> dwcook: huh?
17:09:19 <monochrom> all I want to know about scala I learned from the "we're doing it all wrong" lecture
17:09:22 <dwcook> Actually, that might be doable, come to think about it
17:09:30 <chrisdone> dwcook: you mean for an algebra?
17:09:38 <dwcook> chrisdone, I was asking how you'd implement your hypothetical isEmpty for that particular instance of Monoid
17:09:44 <asdf1234> chrisdone: picture it: a pinned singleton mempty used statically as your empty object.. with really unsafe pointer inequality
17:09:56 <chrisdone> monochrom: re languages with "everything can be equalable and we'll hope you can guess what it means!" -- agreed. they are horrid
17:10:31 <Fuuzetsu> *cough* Java *cough*
17:10:42 <Hodapp> *cough* PHP *cough*
17:10:45 <dwcook> Even worse with dynamic typing. Look at JavaScript's == operator.
17:10:55 <c_wraith> or perl's
17:10:56 <chrisdone> pretty much every popular language other than haskell
17:10:59 <ReinH> o_O
17:10:59 <Fuuzetsu> *cough* <any dynamic language> *coughgoddamnimdying*
17:11:26 * hackagebot monoid-subclasses 0.3.5 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.3.5 (MarioBlazevic)
17:11:35 <dwcook> Python maintains more dignity than JavaScript in that regard, though.
17:11:46 <c_wraith> I like that perl sometimes does equality testing by converting an argument to a string
17:11:46 <Fuuzetsu> ===
17:11:50 <monochrom> I actually read the ECMA doc carefully for the semantics of ==, and I only read half of that lengthy semantics
17:11:50 <dwcook> It at least gives you runtime type errors for weird combinations.
17:12:09 <dwcook> runtime "type" errors*
17:12:22 <monochrom> (because I found that I wasn't using the other half)
17:12:37 <ReinH> chrisdone: http://hackage.haskell.org/package/monoid-subclasses-0.1/docs/Data-Monoid-Null.html
17:12:58 <chrisdone> dwcook: oh! instance Monoid b => Monoid (a -> b) where mempty = const mempty; mappend = (.)? or something?
17:13:04 <gsnedders> dwcook: == never throws, unless ToString(o) does.
17:13:25 <dwcook> gsnedders, my last statement referred to Python.
17:13:26 <chrisdone> reinh: awesome!
17:13:40 <monochrom> I am thinking, for monoids such as "Parser a", emptiness test is a bit too hard, it's probably why emptiness test is not imposed on the Monoid class.
17:13:43 <gsnedders> dwcook: Oh, I got confused by people saying too much too quickly :)
17:13:49 <haasn> chrisdone: mappend = liftA2 mappend
17:13:57 <haasn> chrisdone: mempty = pure mempty -- works for any applicative
17:13:59 <dwcook> chrisdone, yeah, I think that's it.
17:14:05 <ReinH> chrisdone: it should provide a nullDefault m = m == mempty though
17:14:06 <haasn> (.) would be a type error
17:14:06 <chrisdone> haasn: huh, i thought that, but didn't write it =)
17:14:18 <chrisdone> reinh: right, that would be nice
17:14:26 <dwcook> Did anyone else notice that monoid-subclasses package that lambdabot just mentioned is relevant?
17:14:29 <ReinH> chrisdone: time for a PR
17:14:35 <dwcook> Data.Monoid.Null, specifically
17:14:40 <chrisdone> reinh: wat
17:14:43 <ReinH> heh last commit an hour ago, so apparently it's maintained
17:14:51 <ReinH> chrisdone: a pull request
17:14:55 <ReinH> dwcook: I just linked to it :)
17:14:58 <chrisdone> dwcook: yeah, that is *weird*
17:15:04 <chrisdone> * hackagebot monoid-subclasses 0.3.5 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.3.5 (MarioBlazevic)
17:15:05 <monochrom> thanks dwcook, nice
17:15:06 <chrisdone> hahahha
17:15:08 <ReinH> oh yeah
17:15:13 <ReinH> dwcook: yeah weird
17:15:15 <chrisdone> @botsnack
17:15:15 <lambdabot> :)
17:15:16 <ReinH> lambdabot is gaining sentience
17:15:20 <dwcook> ReinH, that was after lambdabot mentioned it. :P
17:15:33 <ReinH> dwcook: indeed, apparently I immediately forgot where I found out about it
17:15:53 <monochrom> perhaps I should thank lambdabot instead
17:15:56 <ReinH> dwcook: what's important is the knowledge, not how the knowledge was acquired. Or something.
17:15:57 <monochrom> thanks lambdabot, nice
17:16:05 <chrisdone> @thanks
17:16:05 <lambdabot> you are welcome
17:16:10 <monochrom> err wait, that's hackagebot, not lambdabot
17:16:17 <monochrom> thanks hackagebot, nice
17:16:36 <dwcook> ReinH, yes, I usually don't remember my sources well either. Unless I'm doing boring research papers. :P
17:16:44 <chrisdone> and monochrom left a line of briefly happy but disappointed faces as he swept over his mistaken thankyous
17:16:45 <dwcook> ("boring" was a descriptor, not a qualifier.)
17:16:52 <monochrom> hackagebot now has amazon-like ability of "customers who like Monoid may also like these packages..."
17:17:03 <ReinH> monochrom: ha!
17:17:09 <chrisdone> :D
17:17:29 <chrisdone> huh, just had an idea
17:17:43 <chrisdone> you could use the markov-chain library to generate haskell ASTs from all lambdabot queries ever
17:17:46 <dwcook> Yes, and there's a scandal over Ubuntu sending your desktop search results to Hackage, which might use them to target you for package suggestions.
17:17:48 <chrisdone> and see if you get any coherent programs
17:18:00 <Fuuzetsu> monochrom: perhaps we need @unthanks!
17:18:06 <chrisdone> you could filter results that don't type check =p
17:18:08 <haasn> @slap lambdabot
17:18:09 * lambdabot secretly deletes lambdabot's source code
17:18:14 <haasn> good riddance
17:18:20 <monochrom> :O
17:18:32 <monochrom> XO
17:18:36 <Fuuzetsu> lambdabot: just use that one infamous GHC version ;~
17:19:12 <Fuuzetsu> dwcook: What's this? Have you got some links?
17:19:45 <haasn> Fuuzetsu: that fortunately doesn't seem to have caught widespread attention among the trolls; â€œwhy does haskell delete my source files?â€
17:19:54 <dwcook> Fuuzetsu, well, replace "Hackage" with "Amazon" and some other things.
17:19:55 <chrisdone> ircbrowse=> select count(*) from event where channel = 1 and text like '> %';
17:19:55 <chrisdone>  275066
17:19:55 <chrisdone> that's a nice source of training data
17:20:17 <Fuuzetsu> haasn: It's okay, I'm sure I could drop a word or seven in relevant places, considering actual help is not appreciated.
17:20:30 <Fuuzetsu> dwcook: Oh yes, I think I heard something about this.
17:20:50 <dwcook> Fuuzetsu, https://www.eff.org/deeplinks/2012/10/privacy-ubuntu-1210-amazon-ads-and-data-leaks
17:21:09 <chrisdone> @let (Â£) = ($) -- british haskell
17:21:09 <lambdabot>  Parse failed: Parse error in pattern: ï¿½ ï¿½
17:21:14 <chrisdone> heyâ€¦ =(
17:21:20 <monochrom> haha british haskell
17:21:32 <dwcook> lambdabot doesn't Unicode? :(
17:21:44 <haasn> sort of. sometimes. maybe
17:21:53 <chrisdone> it normally doesâ€¦
17:21:58 <haasn> > let (Â£) = ($) in id Â£ 3
17:22:00 <lambdabot>  3
17:22:02 <chrisdone> > let Ã¡ = a in ()
17:22:03 <lambdabot>  Ambiguous occurrence `a'
17:22:03 <lambdabot>  It could refer to either `L.a', defined at L.hs:155:1
17:22:03 <lambdabot>                        or `Debug.SimpleReflect.Vars.a',
17:22:03 <lambdabot>                           imported from `Debug.SimpleReflect' at L.hs:110:1-26
17:22:03 <lambdabot>                           (and originally defined in `simple-reflect-0.3.1:De...
17:22:07 <monochrom> using Â£ for function application to save a few parentheses is penny wise, pound foolish :)
17:22:16 <haasn> :t L.a
17:22:17 * dwcook groans.
17:22:17 <lambdabot> (Num e, Ix e) => Array (e, e) e
17:22:24 <chrisdone> monochrom: hehe
17:22:39 * monochrom loves puns!
17:22:43 <Fuuzetsu> dwcook: Thanks. Shame I don't have money to donate to EFF at the moment.
17:22:51 <augur> geekosaur: i found a nice imperative way to do this which probably translates into haskell cleanly. im currently something like 5% done computing :T
17:22:51 <haasn> à¸¿
17:23:04 <monochrom> ooohhh, is that bitcoin?
17:23:04 <chrisdone> i wouldn't be surprised if there's an english guy somewhere using Â£, as it's on the number row on a uk keyboard, really convenient
17:23:15 <chrisdone> adopted bitcoin from gothic?
17:23:16 <augur> monochrom: not in unicode its not
17:23:25 <augur> monochrom: but its been adopted as the bitcoin symbol
17:23:44 <haasn> monochrom: it's technically the Baht symbol
17:23:53 <Fuuzetsu> Let's not mention BitCoin, please. I'm upset enough as it is.
17:24:14 <chrisdone> fuuzsetsu: about not investing in any while you had the chance?
17:24:17 <monochrom> sorry!
17:24:17 * Fuuzetsu could have been rich and be donating thousands to haskell.org right now
17:24:28 <Fuuzetsu> chrisdone: N-nâ€¦ yes ;_;
17:24:48 <chrisdone> i've a friend who invested some thousands of euroes into it a couple years back when it was about 60euro per bitcoin
17:24:56 <chrisdone> he's rather happy
17:26:09 <Fuuzetsu> My problem is that I didn't invest a relatively small amount of money (few hundred Â£) when it wouldn't really affect me and when they were <$1 each, instead I laughed. Now who's laughingâ€¦ Just the other day someone bought a Lamborghiniâ„¢ with BTC.
17:26:30 <augur> chrisdone: a couple years back?
17:26:37 <augur> it was never 60 euros a couple years back
17:26:40 <augur> maybe a couple months back
17:26:57 <dwcook> Same here. I could be paying my college debt at least. :P
17:27:11 <dwcook> Oh well. There will be other money opportunities. Like work.
17:27:25 <monochrom> time flies like an arrow. bitoin shoots through the roof like an arrow.
17:27:26 <dwcook> Same here = I laughed too
17:27:45 <augur> time flies like an arrow, fruit flies like a banana
17:27:49 <Fuuzetsu> dwcook: I'll sure enjoy doing shitty work for a decade to get the money I could get this year from something that wouldn't even affect me if it didn't work outâ€¦
17:27:50 <dwcook> monochrom, actually I'm not entirely certain that'sâ€”You know what, fine, metaphors don't have to be perfect.
17:28:08 <augur> time flies like a banana, fruit flies like an-- wait a second
17:28:32 <dwcook> I used to bullseye time flies in myâ€¦ uh, I forget the line
17:28:47 <dwcook> I don't even know what words are anymore. Figuratively speaking, of course
17:28:58 <augur> dwcook: linguists dont know either, its ok
17:29:19 <dwcook> Oh, so that's *not* something I'm going to learn in my linguistics classes? Welp.
17:29:20 <monochrom> words are like an unfoldr
17:29:20 <chrisdone> augur: ah, maybe. i don't really follow it and i've changed jobs since then so it seems longer back than it was
17:29:38 * chrisdone . o O ( time is change )
17:29:41 <augur> dwcook: there are some answers but they're semi-arbitrary
17:29:45 <monochrom> words is like an unfoldr. unwords is like a foldr. hehehe
17:29:55 * augur . o O ( space is change )
17:30:36 <chrisdone> apparently in human perception, the more you remember the more you think time passed slowly
17:30:59 <augur> that explains why things seem to be whizzing by
17:31:24 <haasn> I'd like to take this opportunity to remind you that you too can be a world-class memory champion
17:31:26 <chrisdone> and in moments of stress/danger, your brain goes into hyperactive recording mode. hence why people feel like time slows down. and why old people say "i feel like i'm having breakfast every five minutes"
17:31:42 * simpson . o O ( The 5th Dimension was a band )
17:31:55 <koala_man> you're saying old people say that because there's no stress or danger?
17:32:10 <dwcook> I imagine life becomes repetitive to a fair degree
17:32:11 <augur> chrisdone: its proportional ofcourse
17:32:14 <chrisdone> koala_man: the idea is that when nothing changes you perceive time as going fast
17:32:35 <haasn> the past two months for me have felt like a lifetime
17:32:38 <dwcook> Well, life already is repetitive, but maybe it feels more so
17:33:27 <chrisdone> although it seems somewhat contradictory to "time flies when you're having fun" =)
17:33:47 <koala_man> chrisdone: why wouldn't it be because a day in the life of an old person is a vanishingly small in proportion to the life already led, or because of generally deteriorating faculties?
17:33:51 <dwcook> I think that phrase means something more like "fun times don't last as long as you'd like"
17:33:54 <augur> hey, does anyone know how to define parsers for attributed grammars?
17:34:04 <augur> top-down attributes, i mean
17:34:07 <chrisdone> or maybe that's the point -- having fun doesn't mean remembering lots
17:34:16 <augur> can you do that in parsec?
17:34:23 <koala_man> "that party was awesome. I don't remember anything!"
17:34:32 <haasn> dwcook: no, it quite literally means time flies when you're having fun - as in you can start some fun activity at 15:00 and then you look at the clock and realize it's 7 am the next morning
17:35:06 <scott_> Time flies like an arrow, fruit flies like a banana
17:35:14 <dwcook> haasn, I think there's somewhat of a difference between experience and memory in this regard
17:35:26 <augur> scott_: beat you to the punch by a few minutes
17:35:26 <dwcook> You feel like time drags on when you're bored
17:35:31 <augur> scott_: sorry!
17:35:33 <scott_> augur: Aw, I wasn't watching
17:35:36 <chrisdone> koala_man: don't know. i heard that's the case -- that old people's perception changes. but it was debated (iirc) whether that's due to being old physically or being old actively (like, do old people do new things or experience much danger or stress?)
17:37:41 <scott_> > undefined `mempty` undefined :: Sum Int
17:37:42 <lambdabot>  Sum {getSum = 0}
17:37:46 <scott_> That is quite the thing
17:38:01 <monochrom> @type mempty
17:38:02 <lambdabot> Monoid a => a
17:38:08 <dwcook> It's because the arguments don't get used at all
17:38:16 <dwcook> In the Monoid instance for functions
17:38:19 <scott_> Yeah, it just turns into mempty :: Sum Int
17:38:25 <monochrom> hrm, no wonder
17:38:44 <scott_> > mempty 1 2 3 4 5 :: Sum Int
17:38:46 <lambdabot>  Sum {getSum = 0}
17:39:18 <dwcook> mempty = const mempty
17:39:49 <monochrom> "vanity of vanity, all is vanity"
17:40:01 <chrisdone> if someone wants to write a ghc plugin because they have copious free time, try writing one that will take a monad instance (like IO, or StateT Bob IO) and transform the (interpreted) core to also print out the line and column of every call to >>= or >>
17:40:03 <scott_> mempty 1 2 3 4 5 => const mempty 1 2 3 4 5 => mempty 2 3 4 5 => const mempty 2 3 4 5 => mempty 3 4 5 => ...
17:40:25 <dwcook> You mean (const mempty)
17:40:34 <dwcook> Wait no
17:40:35 <scott_> That's the same thing
17:40:39 <chrisdone> i'm interested to see how useful a monad debugger like that would be
17:40:49 <dwcook> Yeah I got confused
17:41:57 <chrisdone> if you're feeling smart you can try collecting the bindings in scope that are instances of Show and print those, too. but it's not required for the project
17:54:08 <zRecursive> Why is lambdabot faster than `ghc -ignore-dot-ghci -e "fooFunc" MyUtil.hs` ?
17:55:05 <zRecursive> If the ghci is always running on the server side ?
17:55:21 <zRecursive> > sqrt 1000000
17:55:23 <lambdabot>  1000.0
17:55:41 <Fuuzetsu> chrisdone: I can't think of a single person in #haskell with copious amounts of free time. Then again, there's a lot of people in here.
17:56:34 <zRecursive> faster than `ghc -ignore-dot-ghci -e "sqrt 1000000"` locally
17:56:39 <mgsloan> I do think something along those lines will be the go-to approach to debugging haskell, though
17:57:09 <Fuuzetsu> zRecursive: Not looking into a problem and just making a wild guess, maybe because it has all the relevant modules pre-loaded already?
17:57:16 <Fuuzetsu> into the problem*
17:57:27 <zRecursive> Fuuzetsu: maybe
17:57:28 <mgsloan> it gives the potential for debugging to be benefited by having the "thin shell of IO" (or whatever your stateful monad is)
17:57:50 <mgsloan> And not getting lost in the murk of debugging lazy code that lacks a classical stack
17:58:46 <Fuuzetsu> zRecursive: Other guesses include â€˜faster host computerâ€™ although that'd be greatly mitigated by network latency. Well, the lambdabot source is public, you can dig in. I don't think it really matters.
17:58:47 <mgsloan> It's usually not all that useful for the debugger to be honest about what is being evaluated
17:59:30 <mgsloan> It'd be better for monadic debugging to have a stepwise interface, whereas debugging pure code would allow you to drive evaluation (I suppose hat already has that to some degree)
17:59:45 <zRecursive> Fuuzetsu: It seems lambdabot uses ghci to do evaluation
18:00:31 <nlogax> Doesn't it use mueval?
18:01:15 <Fuuzetsu> I believe so. At least it had problems due to mueval recently. I think it uses it unless whoever hosts it finally gave up on it.
18:02:54 <mgsloan> (not that monadic code isn't pure, it just deserves a different debugging interface, imho)
18:04:10 <chrisdone> mgsloan: and monadic/IO-based code is often the stuff that's harder to test in the REPL in small components, unlike pure, lazy code
18:05:04 <mgsloan> chrisdone: Yep! And if you can capture some values while paused, you can try out the pure bits on these values
18:05:36 <Fuuzetsu> I think it's mostly the IO monad that's hard to test because it's hard to consider every possible failure possibilityâ€¦
18:06:24 <mgsloan> Really, I think this idea can be broader than monadic debugging, though - it could really be pluggable debugging - where you can optionally drive the debugger in different ways depending on the DSL (or whatever you want to call the set of functions you're specializing)
18:07:28 <mgsloan> For example, if paused on a mapM, you might be able to jump to the action that executes for a particular item of the list
18:07:43 <mgsloan> (because there's some special debugger code for mapM)
18:07:59 <johnw> hey mgsloan
18:08:10 <mgsloan> course, this gets really tricky due to the proliferation of functions similar to mapM, you wouldn't want to write this debugging code over and over, afterall
18:08:13 <mgsloan> hey johnw!
18:09:17 <mgsloan> It's actually dinner time, bbl
18:10:29 <FliPPeh> @pf (\m -> sendMessage (msgCmd m) (msgArgs m))
18:10:29 <lambdabot> Maybe you meant: pl bf
18:10:33 <FliPPeh> @pl (\m -> sendMessage (msgCmd m) (msgArgs m))
18:10:33 <lambdabot> liftM2 sendMessage msgCmd msgArgs
18:10:45 <FliPPeh> liftM2?
18:10:48 <Fuuzetsu> mgsloan: There's always the trade-off between â€˜it'd be really cool to haveâ€¦â€™ and â€˜it's relatively easy to implementâ€¦â€™. I imagine that implementing a fully generic debugger might be quite difficult, be it implementation or usability wise.
18:10:55 <FliPPeh> The function monad instance is really confusing to me
18:11:17 <ReinH> FliPPeh: what about the applicative instance?
18:11:23 <Fuuzetsu> @src (>>=) (-> a)
18:11:24 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:11:25 <shachaf> It's probably simpler than you think.
18:11:32 <Fuuzetsu> damn, I never remember the syntax for this
18:11:38 <FliPPeh> ReinH: Same, every instance of function for any type class just confuses the hell out of me :)
18:11:45 <ReinH> FliPPeh: what about the functor instance?
18:11:46 <FliPPeh> It just won't click in my head
18:11:52 <FliPPeh> Same
18:12:02 <ReinH> FliPPeh: what about function composition?
18:12:20 <FliPPeh> That I understand, I also understand that the functor instance does about the same
18:12:24 <FliPPeh> But I don't understand why
18:12:32 <ReinH> FliPPeh: fmap for functions is (.)
18:13:23 <johnw> FliPPeh: let's take the function type 'a -> b'
18:13:30 <johnw> for the purposes of understanding functions as functors,
18:13:42 <johnw> 'a ->' is the functorial "context"
18:13:49 <johnw> and 'b' is the type mapped into that context
18:14:02 <johnw> so fmap over a function is a transformation of the return type
18:14:17 <johnw> given a function 'a -> b', and a function 'b -> c', I can fmap the latter over the former to get 'a -> c'
18:14:42 <johnw> you can also view the "a ->" context as a sort of "environment", which gives you the connection between functions and Reader
18:15:26 <johnw> plus, if you have a -> (a -> b), and you have a way to crush that down into a -> b, then you have the monad meaning of functions (join), so long as you can take any 'b' and wrap it into an 'a -> b' (return)
18:15:57 <johnw> just think of the "a ->" part as a context, and it makes it much easier to think about
18:16:07 <ReinH> johnw: maybe pure would be a good one to go over
18:16:13 <FliPPeh> This is why I love this place, everyone is eager to help solve confusion :)
18:16:24 <ReinH> :t pure
18:16:25 <lambdabot> Applicative f => a -> f a
18:16:31 <danharaj> some are eager to cause confusion
18:16:41 <johnw> well, we're at least eager
18:16:44 <ReinH> heh
18:17:10 <Fuuzetsu> danharaj: pfft, just monoid in category of endofunctors! ;P
18:17:14 <ReinH> if your Applicative is ((->) a) then you need a function a -> b -> a for all b
18:17:28 <ReinH> FliPPeh: do you know any functions of type a -> b -> a?
18:17:39 <augur> man if i knew some math, and understood this problem, i would have an efficient computation!
18:17:43 <FliPPeh> ReinH: const, I'd say
18:17:50 <augur> probably constant time
18:18:10 <ReinH> FliPPeh: right, pure for ((->) a) is just pure = const
18:25:22 <ReinH> :t (<*>)
18:25:22 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:25:38 <ReinH> FliPPeh: can you specialize that type for ((->) a)?
18:26:16 <scott_> You should use a different letter than 'a' for that part
18:26:32 <ReinH> ok
18:26:36 <AshyIsMe> is there a function to map over a list in chunks?
18:26:39 <ReinH> Can you specialize that type for ((->) r)?
18:27:03 <ReinH> AshyIsMe: fmap f . chunksOf n
18:27:07 <ReinH> @hackage split
18:27:07 <lambdabot> http://hackage.haskell.org/package/split
18:27:18 <AshyIsMe> so say i have a list of 100 strings and i want to concatenate each 10 strings togeth....  oh chunksOf
18:27:30 <AshyIsMe> thanks ReinH
18:28:25 <ReinH> > fmap concat . chunksOf 3 $ fmap (:[]) ['a'..'z']
18:28:26 <lambdabot>  ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
18:30:27 <AshyIsMe> hmm, that's not quite what im after
18:30:55 <AshyIsMe> it helps though, cheers
18:36:30 <haasn> > ['a'..'z'] ^.. chunking 3 folded
18:36:32 <lambdabot>  ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
18:40:33 <AshyIsMe> i guess what i want might be called splitList
18:40:47 <AshyIsMe> splitList 10 [1..100]
18:41:06 <AshyIsMe> should return: [[1..10],[11..20]...]
18:41:14 <AshyIsMe> does that exist somewhere?
18:41:36 <AshyIsMe> (for general [a] of course, not just numbers)
18:41:55 <shiona> AshyIsMe: Data.List.Split.chunksOf
18:42:46 <shiona> supposedly in a package called split
18:43:53 <mgsloan> Fuuzetsu: True, but given how often I end up doing some print-based debugging, it'd be well worth spending some time on a complicated yet good solution
18:44:10 * flebron finds that the density of '$' in his code is similar to PHP...
18:44:29 * flebron mostly kids
18:45:30 <AshyIsMe> shiona: ah cheers
18:46:06 * ion mostly adults
18:57:17 <malaclyps> i was reading the haskell subreddit the other day, and i remember someone mentioning a live-coding editor for haskell, in the style of Bret Victor. Its name began with 'l' (I think a pun on lambda), but I can't find it now. Ring a bell for anyone?
19:00:02 <evbogue> is there a definitive article on how to avoid dependency hell in Haskell?
19:02:55 <pavonia> malaclyps: leksah by chance?
19:05:14 <malaclyps> pavonia, not leksah, though similar sounding
19:05:15 <mgsloan> malaclyps: Probably lamdu
19:05:27 <malaclyps> mgsloan, that was it! thank you
19:05:28 <mgsloan> Which really isn't for haskell, it's also a haskell-like language
19:05:38 <mgsloan> (and written in haskell)
19:05:42 <mgsloan> malaclyps: welcome!
19:07:05 <mgsloan> Also, the IDE we're working on at FP Complete has some similar inspirations, providing you information when you need it, and hopefully allowing you to run your program very quickly after changing it
19:07:51 <mgsloan> Certainly not a full realization of Bret Victor's demos, but were definitely keen to work towards that direction
19:10:22 <mgsloan> *we're
19:12:28 <malaclyps> mgsloan, great! I'm enjoying playing around with FPComplete, although I'm only a novice haskeller
19:13:02 <mgsloan> Lamdu is a darn awesome project, though.  It's pretty much setting out to do everything "right", which, unfortunately I fear is too big of a task.  I would rather that it focused on one thing at a time rather than tackling all of 3d accelerated UI / structure editor / version control / new programming language
19:13:18 <shachaf> Isn't it only a 2D accelerated UI?
19:13:22 <mgsloan> malaclyps: Awesome, glad you like it :D
19:13:31 <mgsloan> shachaf: I think they're using OpenGL
19:13:41 <mgsloan> It's 2D, but using triangles
19:14:10 <mgsloan> Also a ton of lens, which is awesome
19:15:11 <mgsloan> Most of the ideas in lamdu are fantastic :D, it seems a bit impractical though :/
19:15:27 <mgsloan> Some really awesome practical projects could spring out of it perhaps
19:32:05 <AshyIsMe> got a link to lambdu?
19:32:31 <shachaf> @google lamdu
19:32:31 <lambdabot> Plugin `search' failed with: user error (https not supported)
19:32:42 <shachaf> Well, that.
19:33:02 <shachaf> int-e: Please fix lambdabot to at least give the URL, if not add https support?
19:33:10 <AshyIsMe> oh without the "b"
19:33:33 <shachaf> Ah. Yes.
19:39:02 <malaclyps> http://peaker.github.io/lamdu/
19:44:50 <augur> mr-: hows the videos coming
19:46:45 * hackagebot ListLike 4.0.2 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-4.0.2 (JohnLato)
20:01:05 <Fuuzetsu> mgsloan: This is the stage where we reach â€˜it'd be really nice to have this but I don't have cycles to spend on itâ€™â€¦
20:02:14 <mgsloan> Fuuzetsu: Indeed.  I am working on tools for haskell, but sofar there are more pressing issues than a domain specific debugger :)
20:03:09 <mgsloan> Which I think is why chrisdone was bringing it up - it'd be great if someone would investigate this stuff
20:03:20 <mgsloan> as currently there isn't something to point at and say "see, it's a good idea!"
20:03:49 <mgsloan> Even if we have some inkling that it'd be really useful
20:09:48 <lispy> mgsloan: what tools are you working on?
20:11:10 <mgsloan> lispy: FP Complete's IDE!
20:11:21 <lispy> did you add cabal support yet?
20:11:33 <mgsloan> Been working on it for ~11 months
20:12:14 <mgsloan> Depends on what you mean - we can install 3rd party dependencies via cabal
20:12:32 <mgsloan> As far as native cabal support for projects, no, that's not in there yet
20:12:54 <johnw> at this moment I'm working on diff support
20:13:15 <mgsloan> We plan to have the ability to export cabal files, but native support for them is not planned.  If there's huge demand it might be considered, though
20:13:21 <lispy> It's kind of hard to take it seriously when it ignores one of the most successful tools we've developed
20:13:54 <rabipelais> hello, does anyone know the name of the type `((->) t)'? I understand how its bind, return, fmap, etc. are what they are, as in I can implement them, but I don't yet understand what they actually *do*
20:14:04 <lispy> rabipelais: it's a function type
20:14:08 <johnw> it's often call the "function functor"
20:14:35 <lispy> rabipelais: due to syntax silliness it looks like that. You can think of it as the function type partially applied. So, something like (t ->)
20:15:09 <rabipelais> I tried googling that, but the name is rather non-specific :(
20:15:12 <lispy> analogous to ((+) t)
20:15:57 <johnw> rabipelais: http://stackoverflow.com/questions/10294272/confused-about-function-as-instance-of-functor-in-haskell
20:15:59 <johnw> does that help?
20:16:07 <mgsloan> lispy: One reason for this is that it's not really that great of a format for an IDE project.  E.g. automatically editing a cabal file would be tough
20:16:28 <rabipelais> yeah, I could figure out for example that bind had to look like bind f g t = f (g t) t merely through the types, but I don't get what it does, semantically
20:17:09 <johnw> mgsloan: well, the Cabal library has a pretty rigorous in-memory representation of everything that can appear in the file
20:17:16 <mgsloan> lispy: Cabal export will likely take the form of substituting parts of your custom cabal file template.  This way you get full control over the output, but don't need to worry about what modules constitute your project
20:17:21 <rabipelais> is it used in "the real world"?
20:17:27 <johnw> you just need to read in the .cabal file, use the in-memory representation, and then later write it back out again
20:17:35 <mgsloan> lispy: But I'm not sure if it'll work like that, I'm just hypothesizing
20:17:35 <johnw> rabipelais: absolutely
20:18:49 <mgsloan> johnw: Right, makes sense.  Still, that isn't exactly automatically editing a cabal file.  E.g. you can't make a good refactoring tool by using HSE pretty print!
20:24:16 <L8D> How would you loop through and print each element in a list?
20:24:25 <johnw> mapM print xs
20:24:29 <johnw> mapM_ even
20:24:37 <johnw> or just print xs
20:24:44 <L8D> I need to learn all the monadic functions
20:24:46 <rabipelais> johnw: waaaaaaait a second, does it work kind of like the reader monad?
20:25:17 <johnw> rabipelais: it is effectively the reader monad, just missing the newtype and some other machinery
20:25:19 <twiceler> mapM_ = sequence_ . map
20:25:22 <Zearen> Is it possible to write a deriving code generation for a custom class
20:25:33 <Zearen> ?
20:25:46 <rabipelais> johnw: oh, thanks a lot for the help (and the patience)
20:26:05 <johnw> with the Reader monad, you "ask" to get the environment; with the function monad, the environment becomes an argument to every action in the monad
20:26:17 <johnw> that's why this works:
20:26:22 <johnw> > join (,) 2
20:26:24 <lambdabot>  (2,2)
20:26:36 <satc> What is the idiomatic way to benchmark against the optimizations you make in a package? I have a package Foo and I wrote benchmarking code for a function bar. Now I made some changes in bar and want to see whether it helped in performance or not.
20:26:58 <L8D> satc: Do you have unit tests?
20:27:09 <johnw> satc: I use criterion
20:28:06 <satc> johnw: I am using criterion too. But how do I compare two versions of the same function. Do I make a change and see if benchmarks changed or is there a better way to compare the performance.
20:28:24 <johnw> write two functions
20:28:32 <johnw> one doing things the old way, one doing them the new way
20:29:07 <Zearen> Like, I could just do some TemplateHaskell and have the user $(deriveBarClass ''Foo), but thats not as pretty as data Foo = ... deriving (BarClass)
20:29:29 <Zearen> I fear my Google-fu is not strong enough.
20:29:46 <johnw> what are you googling for, grasshopper?
20:30:08 <enthropy> Zearen: you don't need the $( )
20:30:49 <enthropy> also another option you might pursue is http://www.haskell.org/haskellwiki/GHC.Generics
20:31:01 <Zearen> Oh, yeah, that's right.  I forgot you could do that at the top level.
20:33:30 <satc> johnw: Yeah! but that will require changing a lot in the package (If I am changing in a lot of places)
20:34:09 <rabipela1s> johnw: oh, that bind there is interesting. Let's see if I get it: (,) has type (a -> (b -> t)) so join (,) has type (b -> t). If join = bind id, then join (,) 2 = (bind id (,)) 2 = id ((,) 2) 2 = ((,) 2) 2 = (2,) 2 = (2,2)
20:34:30 <rabipela1s> s/that bind there/that join there/
20:34:59 <twiceler> I am writing a Haskell library which depends on a C library (cublas)
20:35:20 <twiceler> and it works fine when I compile something which depends on that library with GHC
20:35:40 <twiceler> but with ghci, I'm getting some linking errors (it can't find my foreign function)
20:36:20 <twiceler> does anyone have an idea what might be wrong?
20:36:33 <satc> johnw: I plan of changing the underlying data structure in a package to see performance improvement. That would mean changing all the data types etc.
20:37:11 <Zearen> enthropy: This looks similar to what I want, but I think I'll stick with TH, thanks.
20:38:26 <Zearen> twiceler: IIRC ghci has issues with FFI since the C library isn't linked in.
20:39:21 <enthropy> Zearen: it can be more involved to do it with TH, since (reify ''Foo) varies whether the data has named fields or not (for example)
20:39:59 <enthropy> also TH is slightly more annoying for users, since the splice splits the file in half
20:40:24 <enthropy> so   data X = X Y; deriveFoo ''X; data Y = Y x; deriveFoo ''Y -- won't work
20:40:25 <twiceler> Zearen: Okay. I thought I vaguely remembered that I had it working once, but maybe I'm wrong
20:40:56 <enthropy> data X = X Y; data Y = Y X; deriveFoo ''X; deriveFoo ''Y -- is the slight inconvenience
20:41:46 <Zearen> Hmmm.
20:42:49 <Zearen> I mean, I know for fact that all the data types are going to be single constructor records containing only terminal types.
20:43:13 <Zearen> But yeah, avoiding the splice ordering stuff would be nice.
21:06:55 * hackagebot vty-ui 1.6.1 - An interactive terminal user interface library for Vty  http://hackage.haskell.org/package/vty-ui-1.6.1 (JonathanDaugherty)
21:11:37 <Sgeo> Is Data obsolete or something?
21:11:45 <Sgeo> I see Aeson seems to be trying to switch to GHC.Generics
21:11:48 <Sgeo> Why?
21:11:56 * hackagebot range-space 0.1.1.2 - A Range type with vector-space instances  http://hackage.haskell.org/package/range-space-0.1.1.2 (JohnLato)
21:16:56 * hackagebot cufft 0.1.0.2 - Haskell bindings for the CUFFT library  http://hackage.haskell.org/package/cufft-0.1.0.2 (RobEverest)
21:21:57 * hackagebot language-objc 0.4.2.8 - Analysis and generation of Objective C code  http://hackage.haskell.org/package/language-objc-0.4.2.8 (JohnLato)
21:22:12 <Sgeo> The person who wrote this documentation
21:22:12 <Sgeo> http://hackage.haskell.org/package/IfElse-0.85/docs/Control-Monad-IfElse.html
21:22:16 <Sgeo> Were they drunk at the time?
21:23:05 <L8D> Sgeo: Thereâ€™s a term form it
21:23:07 <L8D> for*
21:25:02 <Sgeo> :t fromMaybe
21:25:03 <lambdabot> a -> Maybe a -> a
21:25:24 <Sgeo> awhen = maybe $ return ()
21:25:28 <Sgeo> :t maybe $ return ()
21:25:29 <lambdabot> Monad m => (a -> m ()) -> Maybe a -> m ()
21:25:44 <Sgeo> ooh, no
21:26:07 <Sgeo> awhen = flip $ maybe $ return ()
21:26:14 <Sgeo> :t flip $ maybe $ return ()
21:26:15 <lambdabot> Monad m => Maybe a -> (a -> m ()) -> m ()
21:26:18 <Sgeo> But at that point it's a bit silly
21:27:57 <Sgeo> I'm still more offended by the documentation
21:28:42 <Sgeo> :t when
21:28:43 <lambdabot> Monad m => Bool -> m () -> m ()
21:29:00 <Sgeo> :t (>>= when)
21:29:01 <lambdabot> Monad m => (m () -> Bool) -> m () -> m ()
21:30:01 <Sgeo> :t (>>= flip when)
21:30:02 <lambdabot> Monad m => (Bool -> m ()) -> Bool -> m ()
21:30:09 <Sgeo> meh
21:43:43 <lispy> Sgeo: ghc.generics is pretty nice, but I don't know anything about the aeson stuff
21:44:04 <Sgeo> Is GHC.Generics a replacement for Data?
21:47:37 <Sgeo> Hmm, I know Data.Map fakes Data, I think, is doing similar for GHC.Generics feasible/sensible?
22:02:42 <Sgeo> Hmm, looks like it might be too easy to accidentally encode a non-total generic function
22:03:12 <lispy> I rarely use Data or GHC.Generics so I don't really feel qualified to answer your questions :)
22:03:35 <lispy> I just know that GHC.Generics is poorly documented (so a bit tricky to figure out) but it's actually quite nice once you get something working.
22:03:41 <lispy> I don't know much about Data.Data.
22:04:37 <Sgeo> http://hackage.haskell.org/package/generic-deriving-1.6.2/docs/Generics-Deriving-Base.html
22:04:37 <lispy> Sgeo: here is an example usage: https://github.com/GaloisInc/aterm-utils/blob/master/src/ATerm/Generics.hs
22:04:44 <Sgeo> Seems to be a good read
22:22:32 <volko> huh
22:22:36 <volko> accelerate-examples installed just fine earlier
22:22:55 <volko> now that I'm building with cuda it won't build though
22:27:05 * hackagebot posix-paths 0.2.0.2 - POSIX filepath/directory functionality  http://hackage.haskell.org/package/posix-paths-0.2.0.2 (JohnLato)
22:44:57 <nstdloop> What's the best way to get the sum of the squares of only the odd-indexed integers in a list?
22:45:16 <nstdloop> Is there a map/fold with a "step"?
22:45:30 <shachaf> Is that some sort of homework question?
22:45:33 <nstdloop> no
22:45:40 <shachaf> Hm.
22:45:44 <arkeet> I would first get a list of the odd-indexed elements
22:46:24 <nstdloop> Should I just write a little function that recurses through the list and returns a new one?
22:46:39 <arkeet> you can do that
22:46:58 <arkeet> tbh lens makes it super easy
22:47:02 <shachaf> You could use the old trick of zipping with an infinite list and then filtering.
22:47:16 <arkeet> > "abcdefghi" ^.. traversed . indices odd
22:47:17 <lambdabot>  Couldn't match expected type `(a0
22:47:17 <lambdabot>                                 -> Control.Lens.Internal.Getter.Accessor
22:47:17 <lambdabot>                                      (Data.Monoid.Endo [a0]) a0)
22:47:17 <lambdabot>                                -> p0 GHC.Types.Char (Control.Lens.Internal.Ge...
22:47:17 <lambdabot>                                                        (Data.Monoid.Endo [a0]...
22:47:27 <arkeet> uh?
22:47:46 <arkeet> yes, that's how I'd do it without lens.
22:48:00 <arkeet> > map snd . filter fst . zipWith (cycle [False,True]) $ "abcdefghi"
22:48:01 <lambdabot>  Couldn't match type `[b1] -> [c0]' with `[(GHC.Types.Bool, b0)]'
22:48:01 <lambdabot>  Expected type: [GHC.Types.Char] -> [(GHC.Types.Bool, b0)]
22:48:03 <lambdabot>    Actual type: [GHC.Types.Char] -> [b1] -> [c0]Couldn't match expected type ...
22:48:05 <lambdabot>              with actual type `[GHC.Types.Bool]'
22:48:08 <arkeet> > map snd . filter fst . zip (cycle [False,True]) $ "abcdefghi"
22:48:09 <lambdabot>  "bdfh"
22:48:14 <arkeet> :/
22:48:25 <nstdloop> nice
22:48:29 <arkeet> > catMaybes . zipWith ($) (cycle [const Nothing,Just]) $ "abcdefghi"
22:48:31 <lambdabot>  "bdfh"
22:48:41 <arkeet> hm, that turned out to be lo nger.
22:49:05 <arkeet> > map snd . filter (odd . fst) . zip [0..] $ "abcdefghi"
22:49:06 <lambdabot>  "bdfh"
22:49:29 <nstdloop> even better
22:49:51 <shachaf> Y'all're missing the sum.
22:50:03 <arkeet> can't sum a string.
22:50:16 <shachaf> > sumOf (ifolded . indices odd) [1,2,3,4,5]
22:50:17 <lambdabot>  Couldn't match expected type `(a0
22:50:17 <lambdabot>                                 -> Control.Lens.Internal.Getter.Accessor
22:50:17 <lambdabot>                                      (Data.Monoid.Endo (Data.Monoid.Endo a0))...
22:50:17 <lambdabot>                                -> p0 a1 (Control.Lens.Internal.Getter.Accessor
22:50:17 <lambdabot>                                            (Data.Monoid.Endo (Data.Monoid.End...
22:50:26 <nstdloop> well then you can just do sum . map (^2) . (the odd ones)
22:50:26 <shachaf> help
22:50:37 <shachaf> Oh, and squaring, right.
22:50:37 <arkeet> shachaf: lens head does something else maybe?
22:50:41 <shachaf> arkeet: Yes.
22:50:43 <shachaf> :t indices
22:50:44 <lambdabot> Ix i => Array i e -> [i]
22:50:47 <shachaf> hi
22:50:47 <arkeet> hahaha
22:50:54 <arkeet> > "abcdefghi" ^.. traversed . Lens.indices odd
22:50:56 <lambdabot>  "bdfh"
22:51:04 <shachaf> > sumOf (ifolded . Lens.indices odd . to (^2)) [1,2,3,4,5]
22:51:05 <lambdabot>  20
22:51:40 <nstdloop> well
22:51:45 <nstdloop> that works
22:52:02 <djahandarie> :t traversed
22:52:03 <lambdabot> (Applicative f1, Traversable f, Indexable Int p) => p a (f1 b) -> f a -> f1 (f b)
22:52:16 <shachaf> It's a shame that traversed is indexed and folded is not.
22:52:18 <nstdloop> and if you wanted the even ones you could just do :%s/odd/even
22:52:21 <arkeet> folded isn't?
22:52:28 <nstdloop> great
22:52:40 <shachaf> :t folded
22:52:41 <lambdabot> (Applicative f1, Foldable f, Contravariant f1) => (a -> f1 a) -> f a -> f1 (f a)
22:52:43 <arkeet> why is that
22:52:45 <djahandarie> I still have no idea what's going on with lenses really.
22:53:02 <shachaf> Because folded is just foldMap-as-Fold.
22:53:13 <shachaf> The weird bit is that traversed is indexed.
22:53:14 <arkeet> right.
22:53:18 <arkeet> that is weird.
22:53:25 <arkeet> how did they do that?
22:53:29 <shachaf> And Intdexed, too!
22:53:44 <shachaf> "they"
22:53:45 <shachaf> ?
22:53:55 <arkeet> edwardk is more than one person.
22:53:58 <shachaf> djahandarie: #haskell-lens
22:54:01 <arkeet> that's the only possible explanation.
22:56:42 <flebron> His last name is Bourbaki.
22:57:12 <johnw> i think he rents space from other people's minds
23:12:00 <nstdloop> Is there a thin wrapper around lists that keeps track of length? This is probably the wrong question to ask, but I need to know the length of list for this algorithm and calling it every time will be very slow
23:12:36 <shachaf> Perhaps the answer is not to use lists.
23:12:47 <nstdloop> shachaf: Perhaps
23:12:54 <johnw> people have made libraries to provide sized lists
23:13:07 <nstdloop> It's probably the wrong approach
23:13:09 <johnw> yeah
23:13:15 <nstdloop> but I haven't managed to bend my mind around a way to avoid it
23:13:44 <shachaf> In general, if you're doing things related to taking a length or indexing (more than once), lists aren't right for you.
23:14:35 <jle`> nstdloop: lists are not meant for indexed storage
23:14:44 <jle`> they are more like control flow/streams
23:14:57 <nstdloop> Ya...
23:15:24 <talios> sounds like Vectors, they tend to track size.  Seems a common example when showing off dependently typed languages
23:25:01 <Sgeo> I guess DeriveDataTypeabale is still useful, but half of it is obsolete?
23:25:11 <Sgeo> DeriveDataTypeable
23:25:24 <arkeet> which half?
23:25:36 <Sgeo> Data
23:25:45 <arkeet> where did you hear that
23:25:58 <Sgeo> I'm under the impression that GHC.Generics is ... to be preferred
23:26:05 <Sgeo> At least, that seems to be the case in aeson
23:26:44 <startling> nstdloop, why do you need the length repeatedly?
23:27:03 <nstdloop> I need to know if an index is at least 3 away from the end
23:27:06 <startling> Sgeo, isn't aeson moving to TH?
23:27:35 <startling> nstdloop: where's the index from?
23:27:47 <nstdloop> It's the index at which I am doing work
23:27:50 <Sgeo> http://hackage.haskell.org/package/aeson-0.6.2.1/docs/Data-Aeson-Generic.html
23:27:54 <nstdloop> it's usually around the front
23:27:58 <Sgeo> "Deprecated: This module will be REMOVED in version 0.7.0.0. Please switch to GHC generics or Data.Aeson.TH instead. These alternatives are less buggy, faster, and more configurable."
23:28:18 <startling> nstdloop, you usually don't do work "at an index" in Haskell
23:28:23 <nstdloop> I'm using a contrived algorithm meant for an imperative language
23:28:28 <nstdloop> that uses array-based lists
23:28:28 <nstdloop> so
23:28:30 <startling> heh :(
23:28:32 <nstdloop> things are a little weird
23:28:42 <startling> nstdloop, there are arrays in Haskell.
23:28:59 <nstdloop> It's a little weird
23:29:15 <nstdloop> because the work is actually all done at the back (or in my Haskell version, the front) of the list
23:30:10 <nstdloop> I think I can refactor this to use pattern matching
23:52:09 <startling> highPriestLOL, could you make your away status changes less noisy, please?
23:53:06 <identity> is there a way to interface with the .cabal file at runtime to retrieve the program's version?
23:53:13 <identity> IIRC I read something about this
23:53:24 <identity> This is so that I do not have to modify version numbers in several places at once.
23:54:40 <shachaf> djahandarie: You should join #-lens!
23:56:43 <identity> Oh, figured it out
23:56:47 <identity> SO to the rescue etc
