00:00:19 <notdan> @lyah <-- a great book btw explains typeclasses and monads in details
00:00:19 <lambdabot> Unknown command, try @list
00:00:24 <notdan> @lyah
00:00:24 <lambdabot> Unknown command, try @list
00:00:45 <notdan> argh
00:00:45 <issam> lol
00:00:46 <triliyn> @where lyah
00:00:46 <lambdabot> http://www.learnyouahaskell.com/
00:00:46 <notdan> http://learnyouahaskell.com/ here it is
00:00:49 <notdan> thanks triliyn  I keep forgetting the commands
00:01:01 <hamid> i love lyah :P
00:01:05 <issam> a fistful of monads
00:01:15 <triliyn> It's a really nice book
00:01:30 <benbangert> quite nice
00:01:43 <benbangert> though there's nothing quite like actually using monads to get a handle on them
00:01:48 <issam> yah, its my number one guide book for haskell
00:02:09 <dhrosa_> the terribly drawn illustrations are great
00:03:02 <hamid> lol dhrosa_ "are great" makes them not terribly drawn ;)
00:03:21 <dhrosa_> I mean, entertaining
00:03:51 <dhrosa_> fun-ctor
00:05:57 <f1rstmistake> Hi, I have a simple haskell app that import just "Text.Pandoc" package and use function in "Text.Pandoc.Walk" package. If I compile with 'cabal' it works fine, but if I compile directly with 'ghc', I need to import 'Text.Pandoc.Walk' package in my hs file. Is there any option sent by cabal to ghc to instruct importing everything begin with "Text.Pandoc"? Thanks.
00:06:39 <f1rstmistake> NOTE: I'm using cross-compilation GHC for iOS.
00:12:22 <Cale> f1rstmistake: You mean 'module' where you said 'package' there. Text.Pandoc.Walk is a module in the pandoc-types package.
00:12:38 * hackagebot HsOpenSSL 0.10.4 - Partial OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.4 (MasatakeDaimon)
00:12:38 * hackagebot coltrane 0.1.0.0 - A jazzy, minimal web framework for Haskell, inspired by Sinatra.  http://hackage.haskell.org/package/coltrane-0.1.0.0 (wellecks)
00:14:14 <Cale> (Which is actually in a separate package from the Text.Pandoc module, which is in the pandoc package.)
00:14:52 <Cale> Text.Pandoc doesn't re-export Text.Pandoc.Walk, so importing Text.Pandoc isn't necessarily enough to make the stuff in Text.Pandoc.Walk available.
00:15:24 <f1rstmistake> Yes, it's module, my mistake. What i don't understand is why when using Cabal, in .hs file, I need to import only "Text.Pandoc".
00:15:38 <Cale> That's strange
00:16:05 <Cale> Are you using the Walkable class, or walk/walkM/query ?
00:17:40 <Cale> The imports you need to make should be independent of whether you're compiling using ghc directly, or whether you're using Cabal.
00:17:57 <f1rstmistake> Sorry, at this moment, I just try existing script at http://johnmacfarlane.net/pandoc/scripting.html, so I haven't learn about it.
00:18:30 <f1rstmistake> If you see on that site, all script, they only import "Text.Pandoc" module.
00:18:47 <f1rstmistake> ic.
00:19:15 <Cale> Yeah, that's wrong. The one which uses walk needs to import Text.Pandoc.Walk
00:19:50 <f1rstmistake> Wait, let me try again to compile without importing "Text.Pandoc.Walk"
00:19:52 <Cale> Maybe it wasn't always like that.
00:20:15 <Cale> Could be that Text.Pandoc on its own used to export walk
00:22:25 <f1rstmistake> This is what I do: I put the script in .hs file and create .cabal package and build it and it build fine.
00:23:09 <f1rstmistake> But if I just execute 'i386-apple-darwin11-ghc Test.hs -staticlib -threaded', it failed unless i put a line 'import Text.Pandoc.Walk' :(.
00:24:03 <Cale> Are you specifying a particular version of pandoc to use in your .cabal file?
00:24:20 <Cale> (and do you have more than one version of pandoc installed)
00:24:21 <Cale> ?
00:25:06 <f1rstmistake> No, it's just default .cabal file with dependencies on base package only.
00:25:24 <f1rstmistake> And there is only one version of pandoc.
00:25:29 <Cale> okay
00:25:55 <Cale> Which version?
00:26:06 <Cale> 1.12.2.1?
00:26:21 <f1rstmistake> Yes, correct!
00:27:20 <pavonia> It shouldn't compile if you don't specify the pandoc dependency. Are you sure it's using the correct .hs file?
00:27:27 <f1rstmistake> I see that in Text/Pandoc.hs, they have something like: "module Text.Pandoc ( module Text.Pandoc.Definition, ..., readers, writers, readMarkdown....
00:27:32 <maybefbi> guys i just changed a few characters in the cumino vim plugin, so that it will run 'cabal repl'
00:27:40 <maybefbi> https://github.com/edwinhere/cumino
00:27:41 <f1rstmistake> Is that means Pandoc by itself exporting all sub modules?
00:27:57 <Cale> f1rstmistake: Not all, just some
00:28:34 <f1rstmistake> pavonia: I think so
00:29:04 <Cale> and in particular, I don't think it ever exports Text.Pandoc.Walk
00:30:33 <Cale> I'm just compiling Pandoc myself now so that I can check
00:31:14 <f1rstmistake> Ic. Thanks.
00:31:36 <Cale> The only way that I can imagine using cabal would make a difference is if it were to somehow use a different version of pandoc where Text.Pandoc re-exports Text.Pandoc.Walk or something
00:31:59 <Cale> But cabal can't magically import modules into your modules
00:32:08 <Cale> It only helps decide which packages are used
00:32:23 <f1rstmistake> Question: How can I know if Text.Pandoc re-exports Text.Pandoc.Walk?
00:33:13 <Cale> Well, one thing we could try is to open up ghci with nothing loaded, and then  :m + Text.Pandoc
00:33:20 <Cale> and see if  walk  ends up being in scope
00:33:29 <Cale> By doing  :t walk  or something
00:33:53 <Cale> You'd know for sure by looking at the haddock or the source for Text.Pandoc
00:35:08 <f1rstmistake> I have the source file, what is the statement showing that it re-export something?
00:36:00 <Cale> It's that thing you pointed out before, you noticed that it has  module Text.Pandoc.Definition  in the export list, along with some others
00:37:07 <f1rstmistake> ic. It's not there.
00:37:58 <Cale> So, that's why it's very confusing to me that it would compile some source code which had a reference to walk, if walk isn't supposed to be in scope.
00:39:53 <Cale> Are you sure that the cabal project is compiling the code which you think it's compiling?
00:42:08 <Cale> (Perhaps make sure there are no stray .o or .hi files, and check that the source it's building really doesn't have that import)
00:42:15 <Cale> It's supposed to fail
00:42:37 <f1rstmistake> That's a good question. I'll start clean. Please wait.
00:46:59 <raphie> what's the current state of Haskell -> LLVM -> Emscripten'd JS?
00:53:17 <f1rstmistake> Cale: You're right! My mistake. I try again creating executable cabal file and put my test hs as main and it failed to compile!
00:53:39 <f1rstmistake> Sorry for the trouble and Thanks for your help.
00:54:11 <Cale> f1rstmistake: Cool, glad you got it sorted out
00:56:26 <f1rstmistake> I have successfully statically linked PanDoc library to iOS app, and here is some stat of iOS binary size:
00:57:03 <f1rstmistake> When linked to simple haskell app, binary size is 5MB. When linked to Pandoc library, it become 55MB.
00:58:25 <f1rstmistake> That's big for iOS binary. Hopefully there's a way to strip binary size.
00:58:58 <Cale> You could try ordinary strip
00:59:16 <Cale> oh, right
00:59:27 <Cale> You can't strip Haskell binaries on iOS :)
00:59:40 <f1rstmistake> Is it using xcode strip? Can you point it out?
00:59:43 <sopvop> why?
00:59:46 <f1rstmistake> ic.
01:00:10 <f1rstmistake> yeah, i read it on haskell ios wiki page.
01:01:07 <Cale> Yeah, iirc, XCode's stripping doesn't realise that the info tables aren't dead code and destroys them
01:04:45 <f1rstmistake> Is that any other stripping tools that we can use? Or it won't possible until xcode strip tools are fixed to support this.
01:05:47 <f1rstmistake> Can i say that currently all Pandoc modules and it's dependencies modules are statically linked into my iOS app binary which cause it grows to 55MB?
01:06:52 <Cale> yes
01:06:58 <Cale> That's exactly why
01:07:21 <notdan> can't you use -split-objs?
01:07:29 <notdan> I think it can reduce the size of the binary
01:07:32 <Cale> Possibly
01:07:49 <Cale> I don't know if -split-objs works for GHC iOS
01:08:18 <f1rstmistake> So to try it I just pass -split-objs to ghc?
01:09:33 <Cale> yeah
01:10:15 <f1rstmistake> I'll try
01:10:28 <fsf-free> how r u
01:16:02 <f1rstmistake> I pass --enable-split-objs to cabal, but it still generate 55MB binary size :(.
01:16:26 <f1rstmistake> I try -split-objs, but it tells me to use --enable-split-objs instead.
01:17:26 <Saizan> f1rstmistake: the libs need to built like that as well
01:20:51 <f1rstmistake> ic. I'll give it a try. Quick question: Is there anyway to remove all installed packages at once? Leaving only base packages that is built along with ghc itself?
01:22:34 <jle`> 55mb now that is a binary.
01:22:48 <f1rstmistake> Can i just remove everything in ~/Library/Haskell/ghc-7.7.xxx?
01:23:59 <Feuerbach> f1rstmistake: that should work, yes
01:24:56 <f1rstmistake> ic. Thanks :)
01:29:50 <f1rstmistake> Is there possible to have different user package path for different cross-compilation target? Currently it is in ls
01:31:25 <f1rstmistake> Is there possible to have different user package path for different cross-compilation target? Currently it is in ~/Library/Haskell/ghc-7.7.xxx. Can I set it to add target host prefix so it become i386-apple-darwin11-ghc-7.7.xxx.
01:32:22 <f1rstmistake> For base library path, by default ghc already prefix library path with cross-compile target: /usr/local/lib/<target>-ghc-7.7.xxx
01:35:44 <f1rstmistake> Currently i use cabal script from https://github.com/ghc-ios/ghc-ios-scripts
01:36:09 <Feuerbach> you'll have to pass something like -no-user-package-db -package-db $DESIRED_PATH
01:36:21 <Feuerbach> or simply use cabal sandboxes
01:37:24 <f1rstmistake> ic. Can I change .cabal/config file at install-dirs user prefix.
01:37:41 <f1rstmistake> Currently it points to: /Users/name/Library/Haskell/$compiler/lib/$pkgid
01:38:29 <f1rstmistake> Can i put environment var before $compiler that point to build target string?
01:38:37 <Feuerbach> ah yes, you'll need to change those as well
01:38:50 <Feuerbach> hmm. dunno
01:39:08 <f1rstmistake> ic. I'll try it first.
01:46:35 * fsf-free Merry X-mas 
01:49:45 <bitemyapp> fsf-free: happy holidays!
01:52:23 <jtcwang1> ^^
01:52:27 <jtcwang1> Merry Christmas!
01:52:59 <jtcwang1> type InfoP a = FilePath -> Permissions -> Maybe Integer -> ClockTime -> a
01:53:17 <jtcwang1> I'm reading Real World Haskell
01:54:13 <jtcwang1> so my understanding is that they're defining a synonym for a function that takes 4 parameters and output one of type a
01:54:47 <fsf-free> bitemyapp, :]
01:54:51 <jtcwang1> uh i'm so confused
01:56:08 <Cale> jtcwang1: Yeah, whenever you see InfoP a in a type, you can replace it by (FilePath -> Permissions -> Maybe Integer -> ClockTime -> a)
01:56:41 <Cale> i.e. a value of type InfoP a is a function which takes parameters of those 4 types and produces some result of type a
01:57:07 <jtcwang1> i see
01:57:13 <jtcwang1> that makes sense
01:57:14 <jtcwang1> thanks
01:57:24 <jtcwang1> Haskell is hard
01:57:27 <jtcwang1> QQ
01:58:42 <bitemyapp> jtcwang: type synonyms aren't a big deal when you're reading them in context.
01:59:08 <bitemyapp> jtcwang: seeing one in the middle of a book when you haven't been following along in code can seem intimidating, but when you roll up your sleeves and are spelunking hackage - it shakes out okay.
01:59:20 <jtcwang> yeah
01:59:28 <jtcwang> i've been thinking about it recently
01:59:35 <jtcwang> things like C and python
01:59:41 <jtcwang> you have very few building blocks
01:59:41 <bitemyapp> I've actually rather enjoyed following Hackage references of types. It's helped me to understand how pieces fit together.
01:59:46 <jtcwang> so its very verbose
01:59:55 <jtcwang> haskell can be cool when you know all the functions etc
02:00:05 <jtcwang> and for learning it has a high learning curve
02:00:08 <jtcwang> imo
02:00:17 <jtcwang> just my little feeling atm :P
02:00:20 <bitemyapp> Hum. python is capable of being succinct, but there's never any good documentation beyond the facade because of the lack of types.
02:00:46 <bitemyapp> Python is rarely meaningfully composable beyond sequential invocation of methods and functions.
02:00:50 <jtcwang> btw how do you reply to ppl
02:00:54 <jtcwang> lol
02:01:16 <jtcwang> yeah that's why i'm learning haskell
02:01:30 <jtcwang> programming shoulnt feel like a chore
02:01:34 <rdevilla> bitemyapp: inheritance?
02:01:45 <jtcwang> i need expressiveness!
02:01:47 <bitemyapp> rdevilla: s/inheritance/programmatic copy-pasta/g
02:01:56 <rdevilla> hrm
02:02:05 <bitemyapp> rdevilla: that's all inheritance is.
02:02:15 <rdevilla> well, then there is polymorphism
02:02:34 <bitemyapp> you can't be as precise, succinct, or safe with inheritance as you can with function composition.
02:03:07 <bitemyapp> Python has a reasonable answer to polymorphism insofar as any dynamic language does (duck typing). Clojure's is better still, but I favor type systems with typeclasses.
02:03:07 <jtcwang> function composition is way more expressive imo
02:03:17 <bitemyapp> jtcwang: it can be, if done properly.
02:03:28 <bitemyapp> no single thing is enough, in any language or paradigm.
02:03:29 <rdevilla> it can also end up in horrible looking stuff (at least to me)
02:03:31 <rdevilla> see @pl
02:04:14 <jtcwang> how longs have you guys been haskelling
02:04:26 <rdevilla> not long, still trying to see the light
02:04:31 <jtcwang> i just recently started
02:04:38 <rdevilla> I have some background in lisp though
02:04:40 <jtcwang> feel like there's a gold mine right in front of me
02:04:53 <jtcwang> don't know how long it'll take for me to be competant
02:04:59 <bitemyapp> jtcwang: off and on since '08, more seriously since Cabal 1.18 got released.
02:05:03 <bitemyapp> because uh...sandbox is godly.
02:05:14 <jtcwang> sandbox?
02:05:17 <bitemyapp> sandbox nuked my last deal-breaker complaints with cabal.
02:05:22 <bitemyapp> jtcwang: cabal sandbox :)
02:05:27 <jtcwang> oh ok
02:05:33 <jtcwang> i keep hearing cabal hell
02:05:43 <bitemyapp> jtcwang: doesn't exist if you use sandboxes.
02:05:47 <bitemyapp> sandboxes are lovely.
02:05:52 <jtcwang> i'll keep that in mind
02:08:10 <jtcwang> equalP :: (Eq a) => InfoP a -> a -> InfoP Bool
02:08:21 <jtcwang> equalP f k = \w x y z -> fw x y z == k
02:08:37 <jtcwang> oops there's a space between fw
02:08:57 <jtcwang> so InfoP a is takes 4 inputs and returns a result of type a
02:09:12 <jtcwang> but i don't get where \w x y z is coming from
02:09:31 <jtcwang> its not really explicit. is this a good style?
02:13:58 <Cale> jtcwang: Well, I don't know if I'd usually use the type synonym, but note that we're taking f :: InfoP a, and k :: a, and we need to produce an InfoP Bool. An InfoP Bool is a function which takes 4 parameters (as we noted before), and produces a Bool result
02:14:34 <Cale> jtcwang: So the lambda there has 4 parameters because of that
02:14:48 <jtcwang> right
02:15:02 <Cale> It doesn't actually matter to us what those parameters are, we're just passing them along to f directly, and then checking if the result is equal to k
02:15:06 <jtcwang> what if my function takes 2 functions and a type a
02:15:19 <jtcwang> each function take 4 parameters
02:15:43 <jtcwang> do i need to do \w x y z z1 z2 z3 z4
02:15:43 <jtcwang> etc
02:15:44 <jtcwang> etc?
02:16:10 <jtcwang> like how do haskell know that my \w x y z are referring to f?
02:16:18 <Cale> They're not referring to f
02:16:33 <Cale> They're the 4 parameters of the function we're producing as the result
02:16:56 <jtcwang> so an anonymous function with 4 parameters
02:16:59 <Cale> yeah
02:17:17 <jtcwang> so what is that line saying there?
02:17:28 <jtcwang> equalP f k = \w x y z -> f w x y z == k
02:17:41 <Cale> So, w :: FilePath, x :: Permissions, y :: Maybe Integer, and z :: ClockTime
02:18:15 <Cale> and the function we're producing takes those things, applies the given function f to them, getting some result f w x y z :: a
02:18:21 <Cale> and then it compares that result with k
02:18:27 <Cale> getting a Bool
02:18:33 <jtcwang> right
02:18:36 <jtcwang> lemme think
02:18:46 <Cale> So the whole right hand side of this equation has type InfoP Bool
02:19:01 <jtcwang> yeap i get that part
02:19:15 <jtcwang> its the wxyz i keep getting confused about
02:19:37 <Cale> Well, you could use better names if you prefer
02:19:38 <jtcwang> where is it getting w x y z (input)?
02:19:48 <jtcwang> from within f?
02:19:52 <Cale> No
02:20:00 <Cale> From whoever applies the function we're producing
02:20:03 <liftM> equalP is producing a function
02:20:23 <Cale> Maybe a simpler example would help
02:20:24 <Cale> Suppose we write
02:20:33 <Cale> f x = \y -> x + y
02:20:46 <Cale> f :: Integer -> (Integer -> Integer)
02:20:58 <jtcwang> liftM: OH I SEE!
02:21:20 <Cale> :)
02:21:24 <jtcwang> its producing a function
02:21:33 <jtcwang> and the function is the anonymous one
02:21:37 <liftM> yes
02:21:47 <jtcwang> *bash head*
02:22:20 <jtcwang> cool all cleared up (for now) now
02:22:21 <jtcwang> thanks guys
02:22:30 <f1rstmistake> (Sorry to interrupt: I think passing --enable-split-objs is ignored by cabal when using cross-compilation. It gives me output: "Warning: ignoring -fsplit-objs")
02:22:53 <f1rstmistake> (And if continue, at the end I'll get build error: cannot find xxx-o-split)
02:22:57 <Cale> f1rstmistake: That's possible. It requires additional work to implement that stuff.
02:23:25 <Cale> (and the cross compiling feature is pretty new and not entirely full-featured)
02:23:39 <f1rstmistake> OK. So I assume both stripping and split-objs is not yet possible to decrease fat binaries on iOS.
02:24:03 <f1rstmistake> Ic. thanks.
02:25:33 <Cale> Probably safe to assume, though I don't really know for certain myself.
02:26:18 <Cale> You might want to ask the Haskell iPhone mailing list
02:26:46 <f1rstmistake> I'd like to know what 'lukexi' means by fixing 'fat binaries' issue as said in this page: https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling/iOS
02:27:07 <f1rstmistake> Sure. I'll do that. Thanks for pointing out
02:44:53 <akira__JP> Hello. I am Matlab and sage user considering to learn Haskell as an embedded programming language (and a little bit curiosity).
02:46:00 <akira__JP> Would you recommend that I should not study Haskell, Matlab is better or something like this?
02:47:44 * hackagebot cubical 0.1.1 - Implementation of Univalence in Cubical Sets  http://hackage.haskell.org/package/cubical-0.1.1 (AndersMortberg)
02:48:34 <johnw> akira__JP: matlab is more specialized, but Haskell has some pretty good mathematical libraries
02:49:17 <akira__JP> Which do you prefer ? johnw
02:50:05 <johnw> I don't do a lot of hard math, but there's linear, repa, accelerate, if you're doing linear algebra, for example
02:51:00 <akira__JP> Well, are you good at elliptic curve and such?
02:51:11 <johnw> no
02:51:11 <akira__JP> Well, are you good at elliptic curve and such? johnw
02:51:19 <akira__JP> Okay.
02:51:43 <akira__JP> sage can deal it, john
02:53:11 <akira__JP> * deal with it.
02:55:36 <akira__JP> Thank you, johnw
02:55:43 <johnw> you're welcome
03:02:45 * hackagebot cubical 0.1.2 - Implementation of Univalence in Cubical Sets  http://hackage.haskell.org/package/cubical-0.1.2 (AndersMortberg)
03:02:47 * hackagebot temporary 1.1.2.5 - Portable temporary file and directory support for Windows and Unix, based on code from Cabal  http://hackage.haskell.org/package/temporary-1.1.2.5 (MaxBolingbroke)
03:06:50 <fsf-free> _janne, hi
03:07:46 * hackagebot ansi-wl-pprint 0.6.7 - The Wadler/Leijen Pretty Printer for colored ANSI terminal output  http://hackage.haskell.org/package/ansi-wl-pprint-0.6.7 (MaxBolingbroke)
03:12:16 <fsf-free> RoryHughes, hi
03:17:39 <Hail_Spacecake> what's a more idiomatic way of writing \x -> head x == '-'
03:17:42 <Hail_Spacecake> ?
03:17:46 * hackagebot temporary 1.2 - Portable temporary file and directory support for Windows and Unix, based on code from Cabal  http://hackage.haskell.org/package/temporary-1.2 (MaxBolingbroke)
03:18:02 <Hail_Spacecake> i.e. a function that takes a string and returns whether or not the first character is -
03:19:34 <Entroacceptor> Hail_Spacecake: ((== '-') . head)?
03:20:08 <Hail_Spacecake> thanks
03:20:09 <Entroacceptor> except that still fails on an empty string
03:20:12 <Hail_Spacecake> oh
03:20:13 <Hail_Spacecake> huh
03:20:18 <Hail_Spacecake> didn't think of that
03:20:20 <navaati> Hail_Spacecake: pattern matching
03:21:00 <RoryHughes> fsf-free: hi back!
03:21:16 <navaati> case string of '-':_ -> True
03:21:29 <navaati>              _ -> False
03:21:46 <bitemyapp> one of the disappointments of using Haskell is that all the cool project ideas are already libraries.
03:22:07 <navaati> Hail_Spacecake: and it doesn't fail on empty string
03:22:09 <bitemyapp> and of those cool project ideas, kmett has implemented roughly 30% or more of them.
03:25:19 <Cale> Heh, perhaps we can augment the old adage that any Haskell beginner will reimplement at least half the Prelude and standard list library with the claim that their first completed project will already be one of Ed Kmett's packages on Hackage.
03:28:04 <Cale> bitemyapp: Of course, you could write some Idris instead, and there wouldn't be as many libraries to get in the way :)
03:28:35 <bitemyapp> Cale: IIIiii...don't really know Idris yet beyond some very preliminary poking.
03:28:55 <bitemyapp> Cale: I know of the idris-hackers org. Any other good learning resources?
03:29:29 <Cale> Just the tutorial
03:29:36 <Cale> http://eb.host.cs.st-andrews.ac.uk/writings/idris-tutorial.pdf
03:30:48 <Cale> Also, probably learning the one or more of the other dependently typed languages simultaneously helps, if you can put up with the little differences in syntax.
03:31:47 <bitemyapp> Cale: what other than Idris, Agda, and Coq?
03:31:55 <Cale> Those three in particular
03:32:54 <bitemyapp> Cale: just wondering, what would be the benefit of learning Idris and Agda concurrently?
03:33:36 <johnw> i've written packages that I later found were already sub-modules within an edwardk package; I think this phenomenon is now a Haskell rite of passage
03:33:39 <Cale> Well, they have similar features, so anything you can find which will help you to learn one of them will probably help you understand the other to a fair extent.
03:34:31 <bitemyapp> Idris and Agda seem to be fairly popular in the Haskell community. Haskell2010 seemed fairly conservative - is there any interest in a dependently typed Haskell?
03:35:30 <Cale> Well, Haskell is slowly moving in the direction of the dependently typed languages
03:36:16 <bitemyapp> right but the pragmas are a haphazard way of doing it, it seems.
03:38:54 <bitemyapp> these are not even first world problems though. More like post-scarcity problems, by any comparison to what most programmers deal with.
03:39:01 <Cale> Idris is sort of at one of the about-halfway points between Coq and Haskell, in that it's actually intended to be used to write programs whose primary purpose is to run instead of being typechecked.
03:39:44 <bitemyapp> Cale: although in fairness to Coq, that CompCert C compiler was built with it.
03:40:04 <Cale> Yeah, you can do real things with Coq if you're serious enough about it.
03:44:20 <johnw> wasn't there a web browser built with Coq too?
03:45:42 <Cale> http://goto.ucsd.edu/quark/
03:46:28 <johnw> hmm.. i'm watching a video of someone using a web browser.  90s nostalgia ftw!
03:49:03 <Rc43> Hello.
03:49:32 <Rc43> Can I somehow use GHC.Base.unsafeCoerce# in my code?
03:49:49 <Rc43> Coq generates code with it in some cases when type systems aren't compatible with each other.
03:49:59 <Rc43> But # breaks parsing of the file.
03:50:30 <Rc43> Or haskell reads it like unsafeCoerce (without #) and then is surprised by # appearance.
03:53:56 <b_jonas> Rc43: parsing the identifiers with sharp needs a language extension flag magic comment in your file
03:54:58 <b_jonas> specifically, at the beginning of the file, {-# LANGUAGE MagicHash #-}
03:55:14 <Rc43> b_jonas, oh, thank you
03:56:00 <b_jonas> (that seems a bit strange becuase you use hash marks in the magic comment that makes ghc recognize hash marks)
03:56:25 <b_jonas> in the ghc manual, see http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/ghc-language-features.html#options-language and http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/syntax-extns.html#magic-hash
04:00:15 <Cale> heh, of course # is always normally allowed in comments :)
04:09:35 <Psycho_pr> Why is add x y = x + y of type Integer -> Integer -> Integer instead of Integer x Integer -> Integer or even Integer -> (Integer -> Integer)?
04:10:03 <Cale> -> associates to the right
04:10:19 <Cale> So Integer -> Integer -> Integer and Integer -> (Integer -> Integer) mean the same thing
04:10:31 <Psycho_pr> Hrmm I see..
04:11:35 <Psycho_pr> thanks
04:11:42 <Cale> No problem! :)
04:11:57 <Cale> Psycho_pr: It's also worth noting that function application associates to the left
04:12:07 <Cale> So when you write  f x y z  it means  ((f x) y) z
04:12:49 <Psycho_pr> Kind of funny notation but I guess it becomes more convenient with many parameters compared with the usual thing in math.
04:13:44 <Psycho_pr> Because otherwise you'd have to write something like f(x,y,z) = f(x,.,.)(y,z) = f(x,y,.)(z)
04:15:34 <Cale> Well, it's also very useful when we have so many higher order functions around
04:15:40 <Cale> (to have all functions be curried)
04:16:04 <Psycho_pr> What's higher order functions?
04:16:16 <Cale> Functions which take other functions as parameters
04:16:32 <Psycho_pr> I see
04:16:37 <Cale> > map reverse (words "here are some strings")
04:16:39 <lambdabot>  ["ereh","era","emos","sgnirts"]
04:16:50 <Psycho_pr> Is this curried function concept only part of haskell is it a mathematical concept?
04:16:59 <Cale> > map (map reverse) [words "here are some strings", words "here are some more"]
04:17:00 <lambdabot>  [["ereh","era","emos","sgnirts"],["ereh","era","emos","erom"]]
04:17:25 <Cale> It's a mathematical concept
04:17:42 <Psycho_pr> cool..
04:18:16 <Cale> The process of taking a function A x B -> C and turning it into a function A -> (B -> C) is called currying, after Haskell B. Curry
04:18:44 <Psycho_pr> I guess we've all done this implicitly many times without realizing..
04:18:51 <Psycho_pr> Especially with tensors
04:19:33 <Cale> Well, yeah, if you've seen the definition of an exponential object, it's closely related
04:21:02 <Cale> map (map (2*)) [[1,2,3],[4,5],[6,7,8]]
04:21:03 <Cale> > map (map (2*)) [[1,2,3],[4,5],[6,7,8]]
04:21:05 <lambdabot>  [[2,4,6],[8,10],[12,14,16]]
04:21:41 <Cale> ^^ here, the fact that map is curried means that I can simply apply it to its first parameter to get another function, which I can then use as the argument to another map :)
04:22:37 <Cale> So, (2*) :: Integer -> Integer, and then map (2*) :: [Integer] -> [Integer], and then  map (map (2*)) :: [[Integer]] -> [[Integer]]
04:22:52 <Psycho_pr> That is cool
04:23:19 <Psycho_pr> BTW what did you mean about exponential object before? I recal something vaguelly related in differential geometry
04:23:30 <Cale> http://en.wikipedia.org/wiki/Exponential_object
04:24:55 <Psycho_pr> I guess it was probably in algebra then
04:30:04 <Cale> and yeah, tensors are related too, because while you get exponential objects by asking for a right adjoint to - x B, so as to give a correspondence between maps A x B -> C and maps A -> C^B, you get the tensor product in the category of vector spaces by asking for a left adjoint to Hom, so there's a correspondence between linear maps U -> Hom(V,W) (i.e. bilinear maps U x V -> W) and linear maps U (x) V -> W
04:33:06 <Cale> I guess I should say "to Hom(V,-)" to make it apparent which possibility I mean there
04:33:22 <Psycho_pr> That's a bit above my head:)
04:35:38 <Cale> Ah, well, that's okay, it's a bit of a digression anyway :)
04:36:23 <Cale> But it's basically just formalisable rationale for why you felt that tensors had something to do with currying :)
04:37:23 <Cale> You get them by a sort of uncurrying in the category of vector spaces :)
04:37:51 <Psycho_pr> uncurrying hah
04:37:57 <Psycho_pr> I like that concept.
04:38:22 <Cale> :t uncurry
04:38:23 <lambdabot> (a -> b -> c) -> (a, b) -> c
04:38:37 <Cale> :t curry
04:38:37 <lambdabot> ((a, b) -> c) -> a -> b -> c
04:38:41 <Psycho_pr> oh wow it's actually a function
04:39:17 <Psycho_pr> > curry \(x,y) -> x+y
04:39:18 <lambdabot>  <hint>:1:7: parse error on input `\'
04:39:25 <Cale> need more parens
04:39:42 <Cale> > curry (\(x,y) -> x + y)
04:39:44 <lambdabot>  <Integer -> Integer -> Integer>
04:39:48 <Psycho_pr> oh
04:39:49 <Cale> > curry (\(x,y) -> x + y) 3 5
04:39:50 <lambdabot>  8
04:40:04 <Psycho_pr> Why does it only output the type and not an actual function?
04:40:13 <merijn> > uncurry (\x y -> x + y) (3,5)
04:40:14 <lambdabot>  8
04:40:16 <Axman6> woah, did lambdabot get an instance Show (a -> b)?
04:40:21 <Axman6> > (+)
04:40:22 <lambdabot>  <Integer -> Integer -> Integer>
04:40:25 <merijn> Psycho_pr: Lambdabot behaviour
04:40:38 <Cale> Psycho_pr: It's typically hard to output descriptions of functions
04:40:43 <jle`> it comes from typeOf
04:40:44 <Axman6> Psycho_pr: what do you want it to show you?
04:40:58 <merijn> Psycho_pr: Lambdabot uses "show" to turn results to Strings and lambdabot has a "Show" instance for functions which just prints their type
04:41:04 <Psycho_pr> Axman6: Something like \x y -> x +y
04:41:29 <merijn> Psycho_pr: If you run "curry (\(x,y) -> x + y)" in ghci it'll produce a type error saying it doesn't know how to print functions
04:41:30 <Axman6> that would work for simple functions, but not generally
04:41:44 <jle`> yeah there is no way to define a general show for functions
04:41:45 <Cale> If there's a way to turn functions into strings which lets you see their implementation, then you can tell the difference between (\x y -> x + y) and (\x y -> y + x), but those are meant to be the same function (at least on Integers)
04:42:07 <Psycho_pr> Interesting..
04:42:26 <Axman6> well, the behaviour is the same but they are different functions...
04:42:30 <Cale> So, you'd be breaking an abstraction which we'd normally like to keep -- referential transparency
04:42:54 <Cale> Two functions are equal if they are pointwise equal
04:43:20 <Cale> (I'm taking this as the definition, at least in this context ;)
04:43:27 <Axman6> for some definitions of equal
04:43:35 <Cale> i.e. f = g if and only if for all x, f x = g x
04:44:00 <jle`> arguably the ideal definition of equal in a pure functional language
04:44:18 <Cale> and the idea of referential transparency is that when two values are equal, we should be able to replace one by the other without affecting the meaning of the program
04:45:20 <Cale> If we allowed show to produce a String which revealed that internal implementation, we'd lose this property, because we might have f = g, but then show f /= show g
04:47:52 <Cale> (also, it would be kind of impractical in real world programs for compiled functions to have to carry around enough information about their original implementation to reproduce their complete source code at will)
04:48:07 <Axman6> so I guess introspection is intentionally not a feature of haskell for those reasons
04:48:14 <Cale> yeah
04:48:42 <Cale> There are other kinds of introspection which also break other nice properties we tend to enjoy in Haskell
04:48:46 <Axman6> I'd never really thought about it; just had a feeling it would never work in haskell, now I know why
04:49:42 <Cale> Being able to tell what type the argument to a polymorphic function is breaks parametricity, and you lose your free theorems, for instance.
04:50:05 <Cale> (of course, this is sometimes useful, so we have the Typeable class for when you need that)
04:50:51 <Cale> But it's a good argument against assuming that everything is magically Typeable all the time everywhere.
04:51:16 <Axman6> what's something that shouldn't be typeable?
04:51:26 <jle`> but that's why we have to explicitly constrain those functions as Typeables, right?
04:51:34 <Cale> As an example of what I'm talking about, when you see that map :: (a -> b) -> [a] -> [b]
04:51:36 <jle`> so parametricity isn't really broken for unconstrainted functions
04:52:01 <Cale> You know that the elements of the resulting list *must* come from applying the provided function to elements of the given list of type [a]
04:52:10 <Cale> That's the only way for map to get values of type b
04:52:22 <Axman6> (or returning an empty list)
04:52:47 <Cale> Well, even in the empty list case, every element of the resulting list satisfies that condition :)
04:52:58 <Axman6> this is true
04:53:02 <jle`> well, the point is that given that type signature, there is one and only one unique implementation
04:53:15 <Axman6> I always struggled to explain that to students when asking them to implement and and or
04:53:21 <Cale> But if instead, we have  map :: (Typeable a, Typeable b) => (a -> b) -> [a] -> [b]
04:53:23 <jle`> and that the type signature alone sufficiently specifies the function's behavior
04:53:27 <Cale> now all bets are off
04:54:09 <Cale> because map can check to see if a = b, and in that case, just produce the input list as the output
04:54:50 <Cale> So, types become less meaningful if you just implicitly start assuming everything is Typeable in every context
04:56:55 <aristid> Cale: you could make all types instances of Typeable but require explicitly putting in the constraint to be able to use it, would that make sense?
04:57:08 <Cale> aristid: yes
04:57:13 <Cale> That'd be fine
04:57:29 <Cale> It's just being able to type-case everywhere that's the problem.
04:58:46 <dzhus> Is it possible to obtain a TH Type given a TypeRep value?
04:58:55 <donri> :t const (const []) `asTypeOf` map
04:58:56 <lambdabot> (a1 -> a) -> [a1] -> [a]
04:59:45 <Axman6> does Chak still go by TacticalGrace?
05:11:48 * Axman6 wishes he had some bitcoins to donate to ocharles 
05:13:06 <Taneb> Axman6, what's a BC worth now?
05:14:09 <randomclown> 700?
05:14:19 <randomclown> Dogecoins are so in right now
05:14:30 <Axman6> much wow
05:14:40 <Axman6>       so currency
05:16:39 <Cale> dzhus: Not as far as I know
05:16:49 <Cale> Well, hmm
05:17:30 <Cale> Yeah, I don't know how :)
05:19:59 <m1dnight> Anybody have a clue on how to parse UTC time, from a string?
05:20:03 <m1dnight> I want to store it in a databas
05:20:34 <m1dnight> Data.Text.Read doens't have what I need
05:21:15 <Axman6> looked in the Time package?
05:21:29 <Axman6> there's definitely parsing functionality there
05:21:44 <Axman6> @hoogle String -> String -> UTCTime
05:21:47 <lambdabot> Foreign.C.Error throwErrnoPath :: String -> FilePath -> IO a
05:21:47 <lambdabot> System.Posix.Error throwErrnoPath :: String -> FilePath -> IO a
05:21:47 <lambdabot> Data.Time.Format readTime :: ParseTime t => TimeLocale -> String -> String -> t
05:21:47 <m1dnight> Yeah I just stumpled upon Time.Clock that seems to have some stuf I need
05:23:01 <m1dnight> hmm, I might just store everything as a string :p
05:23:08 <m1dnight> and validate clientside
05:23:14 <m1dnight> problem solved! :p
05:24:11 <Axman6> D:
05:58:38 <kinslayer> Merry Christmas everybody
06:03:23 <Psycho_pr> kinslayer: Merry day.
06:03:42 <kinslayer> psycho_pr: :D
06:04:01 <kinslayer> well it seems a little quiet in here
06:05:16 <ciaranm> well presents are like a box, so haskellers can't unwrap them. but they do have a way of putting themselves inside the presents, so long as they don't need to get out again.
06:05:53 <kinslayer> ciaram: Well at least you can get the present, although you forget about unsafePerformIO
06:16:04 <larss> is there a more loose version of reads, where looseReads "10foo" would return [(10, "foo")] ?
06:16:25 <larss> oh wait, it does that
06:18:38 <larss> 'readsFunc "LTfoo"' should return '[(LT, "foo")]'. is there such a function?
06:19:08 <Axman6> :t reads
06:19:09 <lambdabot> Read a => ReadS a
06:19:34 <Axman6> > reads "LTfoo" "" :: [(Ordering, String)]
06:19:35 <lambdabot>  Couldn't match expected type `[GHC.Types.Char]
06:19:35 <lambdabot>                                -> [(GHC.Types.Ordering, GHC.Base.String)]'
06:19:35 <lambdabot>              with actual type `[(a0, GHC.Base.String)]'
06:19:48 <Axman6> :t reads "hello"
06:19:49 <lambdabot> Read a => [(a, String)]
06:19:55 <larss> without ""
06:19:57 <geekosaur> pretty sure reads uses haskell tokenization rules, so won't break a word up that way
06:20:04 <Axman6> > reads "LTfoo" :: [(Ordering, String)]
06:20:05 <lambdabot>  []
06:20:41 <Axman6> hmm, what was I thinking of then.
06:20:56 <Axman6> @hoogle String -> String -> a
06:20:57 <lambdabot> Foreign.C.Error throwErrnoPath :: String -> FilePath -> IO a
06:20:58 <lambdabot> System.Posix.Error throwErrnoPath :: String -> FilePath -> IO a
06:20:58 <lambdabot> Network.CGI.Cookie newCookie :: String -> String -> Cookie
06:21:12 <pavonia> > reads "LT foo" :: [(Ordering, String)]
06:21:13 <lambdabot>  [(LT," foo")]
06:21:51 <larss> I would like it to work need it to work without space
06:21:56 <larss> err
06:22:07 <larss> I would like it to work without a space
06:22:27 <pavonia> it can't
06:22:38 <Axman6> well... it can...
06:23:43 <pavonia> that would mean you cannot have Haskell identifiers/constructors that are prefixes of other such identifiers
06:23:56 <Axman6> > let foo (splitAt 2 -> pre:xs) = case pre of "LT" -> [(LT,xs)] in foo "LTfoo"
06:23:57 <lambdabot>  Couldn't match expected type `([a0], [a0])'
06:23:57 <lambdabot>              with actual type `[[GHC.Types.Char]]'
06:24:15 <Axman6> > let foo (splitAt 2 -> (pre,xs)) = case pre of "LT" -> [(LT,xs)] in foo "LTfoo"
06:24:16 <lambdabot>  [(LT,"foo")]
06:24:32 <Axman6> and so on
06:25:04 <Axman6> pavonia: no it doesn't, the return type isn't defined by the string, the return type returns bow the string is parsed
06:25:12 <Axman6> how*
06:25:41 <pavonia> What if you'd have "data Foo = Foo | Fooo"?
06:26:24 <pavonia> Oh wait, you have your results in a list ...
06:26:27 <Axman6> hen Foo(not o) would be Foo, and Fooo would be Fooo
06:26:52 <Axman6> then*
06:27:01 <pavonia> or [(Foo, "o"), (Fooo, "")]
06:27:05 <larss> also "   (LT) foo" will be parsed
06:27:34 <Axman6> generally ReadS only ever returns one parse result
06:27:39 <Axman6> or none
06:28:06 <larss> > reads "   (LT) foo" :: [(Ordering, String)]
06:28:07 <lambdabot>  [(LT," foo")]
06:28:35 <larss> if I have to split it, it is basically the same as parsing it myself
06:29:13 <geekosaur> reads is not a general parser; luckily, parsec is easy to use
06:29:24 <pavonia> larss: I came in to late, what are you actually trying to parse?
06:30:24 <larss> pavonia: "LQfoo", without a space in between
06:30:54 <pavonia> For what set of identifiers?
06:31:49 <larss> or what I am actually doing, data D = Foo | Bar   and then given "Foo10" use reads equivalent to get both Foo and 10
06:32:48 <pavonia> reads already works for numbers
06:33:03 <pavonia> er no
06:34:15 <larss> I know it does, it reads Foo as defined above if I derive Read. but seems it cant read both Foo and 10 whn there is no space in between
06:35:39 <pavonia> because in Haskell numbers in constructor names are allowed too
06:36:06 <pavonia> > return $ span (isAlpha) "LT100" :: [(Ordering, String)]
06:36:07 <lambdabot>  Couldn't match type `[GHC.Types.Char]' with `GHC.Types.Ordering'
06:36:08 <lambdabot>  Expected type: [(GHC.Types.Ordering, GHC.Base.String)]
06:36:08 <lambdabot>    Actual type: [([GHC.Types.Char], [GHC.Types.Char])]
06:36:26 <pavonia> > return $ first read $ span (isAlpha) "LT100" :: [(Ordering, String)]
06:36:27 <lambdabot>  [(LT,"100")]
06:37:44 <sdfscv> Anyone familiar with HXT's readString?  I use withInputEncoding utf8 (the page has encoding="UTF-8"), but it fails to convert &#xd8; to Ø.  Am I doing it wrong?
06:38:30 <larss> pavonia: nice one
06:41:41 <larss> how does first work? I dont underatand its signature.. first :: a b c -> a (b, d) (c, d)
06:42:16 <pavonia> 'a' is an Arrow, you have to specialize it to (->)
06:42:43 <pavonia> > first `asAppliedTo` (undefined :: a -> b)
06:42:44 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable d0)
06:42:44 <lambdabot>    arising from a use of `M850662759527213652519101.show_M8506627595272136525...
06:42:44 <lambdabot>  The type variable `d0' is ambiguous
06:42:44 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
06:42:44 <lambdabot>  Note: there are several potential instances:
06:43:11 <mmmm> Say I have [State a] is there a way to only evaluate up to a certain point, the point which depends on the contents of the State monad? (Much like MapM_ but short circuiting)
06:43:28 <pranz1> larss: basically, if you have a tuple of (b,d)
06:43:38 <pranz1> and an arrow b -> c
06:43:53 <pranz1> larss: you can make an arrow (b,d) -> (c,d)
06:44:03 <larss> what are other examples of arrows besides a function?
06:44:11 <pranz1> only affecting the first element in the tuple
06:44:52 <pranz1> larss: some FRP libraries uses arrows, like some value being an arrow of time
06:45:10 <pranz1> larss: they are usually called behaviors or signals
06:45:22 <larss> I see, interesting
06:46:03 <pavonia> :t first `asAppliedTo` (undefined :: a -> b)
06:46:04 <lambdabot> (a -> b) -> (a, d) -> (b, d)
06:46:10 <pavonia> that's it
06:47:02 <mmmm> I see you can use fail but that isn't really desirable is it
06:47:30 <pranz1> larss: for example, first sqrt (4,4) -> (2,4)
06:49:25 <blochchain> just out of curiosity, what do you think is the best way of generating a list of the coordinates of a 2D array location (r,c)?
06:49:26 <larss> kind of like more generalized map for fst
06:49:35 <blochchain> (a la Conway's game of life)
06:49:55 <pranz1> :t fst
06:49:56 <lambdabot> (a, b) -> a
06:50:13 <pranz1> fst extracts the first element of a tuple
06:50:23 <mmmm> You mean the cartesian product?
06:50:25 <pranz1> first is, as you said, the fmap for (,b)
06:50:40 <pranz1> and second is the fmap for (a,)
06:51:19 <mmmm> you can use cp = liftM2 (,)
06:51:28 <mmmm> then cp [0..x] [0..y]
06:52:06 <larss> what about third? :) or mapping over both elements in a pair?
06:53:42 <pranz1> larss, both f (x,y) = first f &&& second f
06:53:51 <pranz1> :t (&&&)
06:53:52 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
06:53:54 <kqr> larss, over both
06:54:00 <kqr> larss, if you feel ready for lenses
06:54:02 <frxx> > over _3 show (1,2,3)
06:54:04 <lambdabot>  (1,2,"3")
06:54:27 <kqr> λ> over both (+1) (4, 2)
06:54:27 <kqr> (5,3)
06:54:30 <frxx> > over each show (1,2,3,4,5)
06:54:32 <lambdabot>  ("1","2","3","4","5")
06:54:57 <pranz1> :t over
06:54:57 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
06:55:13 <pranz1> >:
06:55:17 <pranz1> I can't into lenses types
06:55:52 <larss> that is neat
06:55:58 <twiceler> :t _3
06:55:59 <lambdabot> (Functor f, Field3 s t a b, Indexable Int p) => p a (f b) -> s -> f t
06:56:23 <nooodl> here the Profunctor p is (->) right?
06:56:31 <twiceler> what nasty type signatures!
06:56:54 <pranz1> nooodl: I guess (,)
06:57:18 <twiceler> :t each
06:57:18 <pranz1> or maybe not by the way
06:57:19 <lambdabot> (Indexable (Index t) p, Each f s t a b) => p a (f b) -> s -> f t
06:57:25 <zort> On Debian, does it make sense to install both the -dev and -prof versions of a library? Will GHC use the profiling one when I use -prof and otherwise use the normal one?
06:57:30 <Guest71474> is there a version of IORef which refers to an unboxed value? I tried installing ArrayRef, which seems to provide this, but this would not compile (not a dependency problem)
06:57:46 <nooodl> nah, it's definitely (->) because you have "show :: p a b"
06:57:47 <geekosaur> zort: yes
06:57:56 <pranz1> ah
06:58:00 <zort> convenient!
06:58:36 <Guest71474> I am trying to optimise some code for fun, and noticed that it is much faster if I use mutable unboxed vectors of length 1 instead of IORef's
07:00:34 <k00mi> Guest71474: that's the unboxed part, IORefs involve quite a bit of pointer chasing
07:02:37 <kqr> pranz1, i cheat and translate "Setting p s t a b" into "Lens s t a b" and "p a b" into "(a -> b)"
07:03:05 <kqr> pranz1, and then I know a "Lens s t a b" is a lens that targets an "a" in a data structure "s" and can transform it into a data structure "t" by replacing the "a" with a "b"
07:03:39 <danielb_> so there is no maintained "IOURef"?
07:07:34 <pranz1> > over _2 (_,3) (5,6)
07:07:35 <lambdabot>  Pattern syntax in expression context: _
07:07:39 <pranz1> > over _2 (1,3) (5,6)
07:07:40 <lambdabot>  Could not deduce (Control.Lens.Internal.Indexed.Indexable
07:07:40 <lambdabot>                      GHC.Types.Int (,))
07:07:40 <lambdabot>    arising from a use of `Control.Lens.Tuple._2'
07:07:40 <lambdabot>  from the context (GHC.Num.Num b, GHC.Num.Num t)
07:07:40 <lambdabot>    bound by the inferred type of
07:07:53 <frx> > set _2 (1,3) (5,6)
07:07:54 <lambdabot>  (5,(1,3))
07:08:09 <danielb_> kOOmi thanks
07:08:15 <danielb_> kOOmi: thanks
07:08:25 <pranz1> frx, trying to figure out how the profunctor can be anything but an arrow
07:08:41 <danielb_> k00mi: thanks (sorry for the spam)
07:09:11 <larss> > over _2 (,3) (5,6)
07:09:12 <lambdabot>  (5,(6,3))
07:09:50 <larss> does that lib ship with haskell platform?
07:10:44 <k00mi> larss: no, it's rather new
07:12:13 <aristid> larss: cabal install lens
07:17:12 <kqr> pranz1, http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html
07:17:14 <kqr> pranz1, does that help?
07:18:05 <kqr> pranz1, or, for a more operational pov, http://hackage.haskell.org/package/profunctors-3.1.1/docs/Data-Profunctor.html
07:20:04 <nooodl> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors this gives (Indexed i) as an example of a Profunctor, which sounds interesting
07:20:13 <kqr> pranz1, from the WrappedArrow newtype it sounds like every arrow is a profunctor, but every profunctor might not be an arrow? i don't know
07:20:34 <kqr> i'm sure someone will have my head for butchering the theory
07:27:06 <benmachine> yeah I think an arrow would be a profunctor
07:27:46 <benmachine> :t \f g p -> arr f >>> p >>> arr g
07:27:47 <lambdabot> Arrow cat => (a -> b) -> (b1 -> c) -> cat b b1 -> cat a c
07:29:55 <FreeFull> Anything that's a contravariant functor and a covariant functor in the right parameters is a profunctor
07:30:04 <FreeFull> I think
07:40:47 <mmmm> Where can I find the instance declaration of Monad ((->) r)?
07:41:46 <aristid> Control.Monad.Instances iirc
07:43:55 <pranz1> kqr, thanks
07:53:15 * hackagebot temporary 1.2.0.1 - Portable temporary file and directory support for Windows and Unix, based on code from Cabal  http://hackage.haskell.org/package/temporary-1.2.0.1 (MaxBolingbroke)
07:55:19 <epta> Whoa, batterseapower is back in town!
08:00:20 <tristan_1> argh, oh right, you can'thave 2 records with fields of the same name, right?
08:00:25 * tristan_1 shakes first
08:01:23 <joelteon> You know, I don't think a library that provides a typeclass for a chatbot is a good idea
08:01:55 * sdfscv is still failing to convert a http response body to a proper haskell string using hxt
08:02:54 <dario`> joelteon: why not? :)
08:03:49 <joelteon> well, I don't think you can really "generalize" a chatbot
08:04:11 <joelteon> monotraversable is designed to work on multiple different structures that can be traversed, lens is for updating deeply nested datatypes, and so on
08:04:19 <joelteon> but a chatbot doesn't work that way
08:05:04 <joelteon> It might be a better idea to provide a datatype with defaults that can be overloaded
08:05:13 <joelteon> but I still want to be able to generalize backends
08:06:06 <joelteon> I was trying to do that with associated types, but every typeclass method has to take the bot as the first argument in that case
08:06:24 <joelteon> and if I want an associated datatype, it has to be a newtype wrapper if you don't want to define it in the instance declaration
08:06:33 <joelteon> which I can't imagine anybody ever would
08:16:56 <pranz> @src over
08:16:57 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:28:56 <dzhus> Why TypeRep contains module in tyConName when a name is defined in a hidden module? http://dpaste.com/1522882/
08:29:20 <lispy> pranz: src only has a few canned examples. It doesn't actually pull from the package source.
08:29:33 <lispy> pranz: Fixing it so that it does would be pretty awesome though.
08:34:20 <geekosaur> dzhus, you might ask that in #ghc (if anyone is around) because it's a ghc implementation thing
08:40:08 <bennofs> Does anyone know why they didn't use ConstraintKinds (ex: 'type Typeable1 (f :: * -> *) = Typeable f') to support backwards compatibility in base 4.7 with the Typeable changes?
08:41:39 <joelteon> did anybody have any clever insights into my dilemma before I disconnected
08:44:11 <danilo2> joelteon: Here are the logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D
08:46:19 <tristan_1> is there any work around for record name conflicts?
08:46:43 <tristan_1> I have 2 records to define for Aeson to be able to decode the json I receieve, and each has a 'occupancy' field
08:56:03 <aristid> is there something like MonadError that also has an instance for IO?
08:56:07 <triliyn> tristan_1: I think the usual practice is to prefix the field name with the record name
08:56:43 <tristan_1> figured it was ssometing like that :(
08:56:55 <triliyn> aristid: do you know about monad transformers?
08:57:01 <tristan_1> that doesn't work if I want Aeson to decode
08:57:07 <tristan_1> since I don't control the json content
08:57:13 <tristan_1> and they have the same field name
08:57:32 <aristid> tristan_1: yes.
08:58:10 <aristid> but adding an ErrorT or EitherT to IO is a bit of duplication because IO also for better or worse _contains_ error handling
08:58:16 <triliyn> tristan_1: I don't know anything about aeson, but shouldn't you be able to write your own decoding instances? Or is that nontrivial?
08:58:17 <aristid> -also+already
08:58:26 <triliyn> aristid: hmmm, I don't know then
08:58:33 <bennofs> tristan_1: you can use the TH function, it allows you to specify a function to override the fieldName -> jsonFieldName mapping
08:59:06 <bennofs> tristan_1: See http://hackage.haskell.org/package/aeson-0.6.2.1/docs/Data-Aeson-TH.html
08:59:13 <tristan_1> bennofs: cool, thanks!
08:59:19 <bennofs> In particular, fieldLabelModifier
08:59:36 <tristan_1> triliyn: yea, but I didn't want to :) it is trivial, but just adding deriving Generic is even more trivial
09:00:06 <dzhus> aristid: exceptions are not semantic errors which are to be handled by short-circuiting monad transformer
09:00:38 <aristid> what?
09:00:52 <aristid> anyways, i guess i can just make a newtype wrapper to get a MonadError instance for IO
09:03:36 <aristid> hmm, or CatchT and MonadCatch
09:06:33 <m1dnight> Could anyone help me? I'm trying "import Locale" but then I get: Could not find module `Locale' It is a member of the hidden package `haskell98-2.0.0.2'.
09:06:46 <m1dnight> But the package "haskell98.." is already installed?
09:07:05 <geekosaur> haskell98 package is only used and only usable in strict haskell98 mode which is obsolete
09:07:11 <m1dnight> damn
09:07:38 <geekosaur> what exactly are you trying to do?
09:07:54 <m1dnight> im trying to parse a datetimestring (from a submit form) to epoch time (to store it in my database)
09:07:58 <m1dnight> I found a solution on SO
09:08:16 <monochrom> on current GHC you now have to pick at most one from: base, haskell98
09:08:17 <m1dnight> http://lpaste.net/97512
09:08:32 <bennofs> m1dnight: I think you can use the time library for that
09:08:34 <geekosaur> System.Locale
09:09:00 <navaati> @hoogle Monoid a => Bool -> a -> a
09:09:01 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
09:09:01 <lambdabot> Control.Exception assert :: Bool -> a -> a
09:09:01 <lambdabot> Control.OldException assert :: Bool -> a -> a
09:09:11 <navaati> meh
09:09:26 <bennofs> navaati: what should that do? SOmething like \b x -> if b then x else mempty ?
09:09:39 <navaati> bennofs: yep
09:10:04 <navaati> would be convenient, wouldn't be ?
09:10:13 <bennofs> navaati: do you have a specific monoid in mind or must the function work for all monoids?
09:10:15 <m1dnight> geekosaur: that works!! :) thank you
09:10:25 <navaati> bennofs: well String
09:10:36 <triliyn> It's basically guard, but for Monoid instead of MonadPlus
09:10:53 <bennofs> > [1,2,3,4,5] >> guard True
09:10:53 <lambdabot>  [(),(),(),(),()]
09:10:59 <bennofs> > [1,2,3,4,5] <* guard True
09:11:00 <lambdabot>  [1,2,3,4,5]
09:11:02 <bennofs> > [1,2,3,4,5] <* guard False
09:11:02 <lambdabot>  []
09:11:13 <bennofs> That should work for strings too
09:11:44 <navaati> ah, quite nice. i was thinking about "when"
09:11:46 <navaati> thx
09:12:13 <triliyn> > when False (return 5) :: [Int]
09:12:14 <lambdabot>  Couldn't match type `()' with `GHC.Types.Int'
09:12:15 <lambdabot>  Expected type: [GHC.Types.Int]
09:12:15 <lambdabot>    Actual type: [()]
09:12:26 <triliyn> oh, hmmm
09:12:26 <mr-> :t when
09:12:27 <lambdabot> Monad m => Bool -> m () -> m ()
09:12:31 <triliyn> Right
09:13:05 <triliyn> @src when
09:13:05 <lambdabot> when p s = if p then s else return ()
09:13:07 <navaati> > when True "lol"
09:13:08 <lambdabot>  Couldn't match type `GHC.Types.Char' with `()'
09:13:08 <lambdabot>  Expected type: [()]
09:13:08 <lambdabot>    Actual type: [GHC.Types.Char]
09:13:41 <triliyn> > when True (">> return ()" >> return ())
09:13:41 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),()]
09:13:46 <bennofs> > 4 <$ when True (replicate 3) <|> when False (replicate 2)
09:13:48 <lambdabot>  Couldn't match type `[a0]' with `()'
09:13:48 <lambdabot>  Expected type: a0 -> ()
09:13:48 <lambdabot>    Actual type: a0 -> [a0]Couldn't match type `[a0]' with `()'
09:13:48 <lambdabot>  Expected type: a0 -> ()
09:13:48 <lambdabot>    Actual type: a0 -> [a0]
09:13:51 <triliyn> > when False (">> return ()" >> return ())
09:13:52 <bennofs> > 4 <$ (when True (replicate 3) <|> when False (replicate 2))
09:13:52 <lambdabot>  [()]
09:13:52 <lambdabot>  can't find file: L.hs
09:13:57 <bennofs> > 4 <$ (when True (replicate 3) <|> when False (replicate 2))
09:13:57 <lambdabot>  Couldn't match type `[a1]' with `()'
09:13:57 <lambdabot>  Expected type: a1 -> ()
09:13:57 <lambdabot>    Actual type: a1 -> [a1]Couldn't match type `[a1]' with `()'
09:13:59 <lambdabot>  Expected type: a1 -> ()
09:14:01 <lambdabot>    Actual type: a1 -> [a1]
09:14:06 <bennofs> > 4 <$ (when True (replicate 3 ()) <|> when False (replicate 2 ()))
09:14:08 <lambdabot>  [4,4,4,4]
09:26:43 <pranz> :t when
09:26:44 <lambdabot> Monad m => Bool -> m () -> m ()
09:27:51 <pranz> :t (<$)
09:27:52 <lambdabot> Functor f => a -> f b -> f a
09:28:52 <aristid> :t fmap . const
09:28:52 <lambdabot> Functor f => b -> f a -> f b
09:29:57 <tristan_1> how can I pass -XOverloadedStrings to 'cabal repl'
09:29:58 <navaati> fmap . const == $>
09:30:06 <navaati> :t ($>)
09:30:07 <lambdabot>     Not in scope: `$>'
09:30:07 <lambdabot>     Perhaps you meant one of these:
09:30:08 <lambdabot>       `$' (imported from Data.Function),
09:30:14 <navaati> :t (<$)
09:30:14 <lambdabot> Functor f => a -> f b -> f a
09:30:28 <navaati> sort of
09:30:36 <pranz> yeah, got that from type signature
09:30:41 <mlen> tristan_1: afair cabal repl is ghci, so :set -XOver...
09:30:58 <navaati> tristan_1: inside REPL, :set -XOverloadedString
09:31:49 <tristan_1> navaati: mlen aaaaah, thanks!
09:41:20 <duairc> Does the >> monad operator have a name?
09:41:24 <duairc> How do people pronounce it?
09:42:01 <bennofs> Maybe 'then'?
09:42:16 <hamid> bind?
09:42:23 <bennofs> bind is already >>=
09:42:28 <hamid> i just guessed i'm n a noob :P
09:42:51 <hamid> bennofs, close though
09:43:04 <duairc> "Then" is good, I'll go with that
09:45:01 <tristan_1> hm, so I can get around my field name overriding issue by defining the data like: data Response = Presence { occupany :: Integer } | HereNow { uuids :: [UUID], occupancy :: Integer }
09:45:23 <tristan_1> but can I not export those records construtors?
09:45:51 <mlen> module Foo (Response(..), ...
09:45:55 <mlen> ah, not export
09:46:02 <mlen> module Foo (Response, ...)
09:46:08 <mlen> afair
09:46:13 <mlen> or empty parens
09:46:29 <triliyn> I think you need the empty parens
09:46:39 <triliyn> Lack of parens is interpreted as (..) usually in import lists
09:48:36 <enthropy> triliyn: how?   import Prelude (Bool) -- doesn't bring True or False into scope
09:48:51 <triliyn> hmm, maybe you don't need empty parens then
09:49:03 <tristan_1> not working
09:49:42 <tristan_1> Response(..) works fine for if I had sometihng jsut like: data Response = Respone { occupancy :: Integer }
09:50:26 <enthropy> tristan_1: you want occupancy and uuids to be exported?
09:50:32 <tristan_1> yea
09:50:48 <enthropy> then you can name them separately:  module Foo (Response, uuids, occupancy)
09:51:08 <enthropy> but this is a bit confusing to people looking at the haddocks for your foo
09:51:36 <enthropy> (uuids will look like a regular function, but there is no sign that you can do  (\x -> x { uuids = [] })
09:51:37 <mmaruseacph2> I don't think it works if you have two records
09:52:09 <enthropy> but that record update syntax will still work
09:52:27 <tristan_1> yea, the constructor still doesn't work
09:52:43 <tristan_1> guess I should just define functions for construction
09:52:46 <enthropy> weren't you asking to hide the constructors?
09:53:03 <tristan_1> that was a different record :)
09:53:26 <tristan_1> andthis was mostly just so I could play around with the records quickly in the repl
09:54:37 <enthropy> then I guess you can go with `module Foo where', or maybe   `module Foo (module Foo, somethingNotDefinedInFooButYouStillWantItExported) where'
09:55:08 <enthropy> or mlen's first response
09:58:03 <tristan_1> argh, dammit, this doesn't work anyway, it requires the json have a 'tag' field :(
09:58:08 <tristan_1> back to using HT
10:08:21 <ciek7> Hello, already asked this question on #yesod but got no answer, so i'll try to ask here.
10:09:31 <ciek7> http://lpaste.net/5717050810454507520 (It's a part of Application.hs) Having just scuffolded site i want to log all requests to stdout or file but in reality it doesn't logs at all.
10:09:42 <ciek7> At least i don't see to where it logs.
10:10:54 <ciek7> http://lpaste.net/1062329052217475072 Full Application.hs.
10:13:49 <pavonia> ciek7: Have you tried with a very small buffer size?
10:16:23 <ciek7> pavonia: Do you mean replacing defaultBufSize with something else? With what for example?
10:16:31 <ciek7> Sorry i'm totally new to yesod.
10:16:43 <ciek7> And to haskell in general.
10:17:05 <pavonia> Well, it's just a shot in the dark, but maybe it buffering the output
10:17:33 <pavonia> so I'd try with something very small, like 10 bytes or so
10:18:57 <ciek7> Okay, let me try it.
10:19:09 <ciek7> Wow, it works now.
10:19:16 <pavonia> oh cool
10:20:36 <ciek7> pavonia: So what was that? default buf size is set to something really big and i was not patient enought to wait until buffer filled?
10:21:00 <pavonia> yes
10:21:13 <pavonia> "The default buffer size (4,096 bytes)."
10:21:39 <ciek7> Got it, thanks for an explanation.
10:22:26 <pavonia> Maybe there's a nice way to flush the buffer on every newline character, I don't know
10:27:39 <ciek7> Also does someone remembers how that talk was called where some guy(i thing it was Don Stewart, it was quite long ago and i wasn't much into haskell yet) explained how did he used haskell to model
10:28:03 <ciek7> unix permissions in his haskell script for some sys-admin task.
10:28:28 <ciek7> There was somthing like Root monad or similar thing.
10:33:29 <Gracenotes> is there a version of the Data.Map balancing algorithm that works with values stored only in leaves?
10:35:51 <Gracenotes> hmm. I think I can do an algorithm with values stored in internal nodes too, but it will be messy (I'll have to walk down to the rightmost descendant of the left child of the target node).
10:38:54 <ciek7> Or maybe it wasn't Don Stewart...
10:39:09 <ciek7> It there was something definitly related to permissions
10:46:34 <zielwasserjunki> Just a short question: i do have a datatype with many constructors, a lot of them need 2 arguments of the same type therefore im  asking myself if theres a way of using a generic kind of patternmatching like: f (_ x y) = ...
10:47:52 <sipa> if you need that, wrap it
10:48:06 <sipa> data ConstructorType = Type1 | Type2 | Type3
10:48:18 <sipa> data DataType = ConstructorType Int String
10:48:21 <joelteon> zielwasserjunki: you cannot wildcard data constructors, no
10:48:30 <joelteon> but you can do what sipa is doing
10:48:48 <sipa> f (DataType _ arg1 arg2) =
10:49:44 <zielwasserjunki> Thank you both!!
10:51:37 <zielwasserjunki> I think ill hardcode it cause i only have to do it just 1 time. nevertheless thank you too sipa
10:51:48 <sipa> yw
10:55:39 <whaletechno> ciek7: http://donsbot.wordpress.com/2007/03/10/practical-haskell-shell-scripting-with-error-handling-and-privilege-separation/ is this what you're looking for?
10:59:28 <ciek7> whaletechno: Exactly, thank you!
11:02:39 <whaletechno> ciek7: you're welcome
11:24:56 <lazynewbie> Hi, are there any docs that describe how Fay works?  I have trouble understanding how the "inside" of a function is inspected (introspected?).
11:29:29 <monochrom> it is perhaps not allowed at all
11:32:54 <Gracenotes> lazynewbie: best I can find is https://github.com/faylang/fay/wiki/Compiler-passes
11:34:05 <Gracenotes> it's fairly from-scratch
11:34:10 <Gracenotes> o u left
11:34:29 <Gracenotes> (compared to something like ghcjs, which runs through a full invocation of GHC)
11:34:38 <monochrom> will likely come back in a minute
11:35:27 <monochrom> yes :)
11:35:42 <Gracenotes> what's past is prologue
11:35:59 * monochrom is a successful prophet
11:36:09 <Gracenotes> :o
11:37:04 <monochrom> now I have to resort to tautologies such as "what connects must disconnect"
11:37:11 <Gracenotes> must have a lazy TCP connection
11:37:37 <Gracenotes> irc
11:38:26 <Gracenotes> sorry, was executing my 'irc' command in a new tab, but all tabs in this profile connect to irssi automatically
11:39:21 <ciek7> Is there any convenience to create seed data for databse in yesod?
11:51:17 * chrisdone notes that gracenotes graces us with his precense =p
11:54:45 <aristid> chrisdone: what does precense mean?
11:56:56 <mgsloan> monochrom is gracing us with his prescience
12:01:31 <jejones_> Is there a concise way to refer to \x -> [x]? ([]) doesn't cut it--which I guess makes sense because it's not infix. I Hoogled "a -> [a]" but didn't find what I was after.
12:02:04 <ciaranm> jejones_: pure
12:02:15 <ciaranm> jejones_: or return
12:02:28 <ciaranm> > return 3 :: [Int]
12:02:29 <lambdabot>  [3]
12:02:45 <jejones_> ciarnm: thanks!
12:03:15 <jejones_> (and apologies for the misspelling :()
12:05:31 <Gracenotes> chrisdone: I've been, uh, giving up IRC for Lent
12:06:26 <quchen> chrisdone is gracing us with his presence again as well. Quite a few people are/were missing around here. Maybe Christmas is on lots of different dates around the globe.
12:07:46 <Gracenotes> well, more actually, my involvement in IRC tends to be proportional with how much Haskell I'm writing, and after a rather dry spell, I'm spending the holiday writing a bunch of data structures functionally.
12:10:37 <skypers_> Maybe as Monad is so sexy :)
12:15:13 <joelteon> Anybody use hslogger? Can someone explain to me how to set the default logger's log format?
12:15:17 <joelteon> I must be a moron.
12:20:30 <ciek7> Okay, i created new executable build target in by yesod cabal project. Imorted Foundation and create main with simple putStrLn. That file compiles just fine but i'm not sure how to use yesod confugred db actions from there.
12:22:34 <identity> ciek7: iirc there's a yesod channel here on freenode as well, which you might want to try
12:24:57 <ciek7> identity: Yeah, tried already. Haven't got a reply for any of my questions.
12:25:23 <ciek7> Basicly i just copy-pasted my cuestions from #yesod to #haskell with 30min time interval.
12:26:02 <Geraldus> Hey buddies! How can I write function of two arguments in point free style? Example here: http://lpaste.net/97516
12:27:04 <Ralith> :t (.) . (.)
12:27:05 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:27:10 <quchen> Geraldus: You can do it, but it's usually not pretty or readable.
12:27:32 <byorgey> Geraldus: fn a b = foo $ zip a b  -->   fn a = foo . zip a  -->  fn a = (.) foo (zip a) -->  fn = ((.) foo) . zip
12:28:24 <byorgey> it is recommended that everyone figures out how to do this once in their life, and then never write code that way
12:28:40 * hackagebot ansi-wl-pprint 0.6.7.1 - The Wadler/Leijen Pretty Printer for colored ANSI terminal output  http://hackage.haskell.org/package/ansi-wl-pprint-0.6.7.1 (MaxBolingbroke)
12:29:09 <Geraldus> Hmmm, seems I haven't understood curring completely.
12:29:14 <danharaj1> edwardk: does spine-lazy leaf-strict work in practice to get composability and predictable thunking?
12:31:10 <Geraldus> byorgey: please explain final reduction
12:31:27 <Geraldus> quchen: Oh, I see )
12:31:58 <marx2> easier to understand when written like this, I think.  fn = (foo .) . zip
12:32:30 <byorgey> Geraldus: maybe if I use more intermediate steps:   fn a = (.) foo (zip a) -->  fn a = ((.) foo) (zip a) --> fn a = ((.) foo) . zip) a  --> fn = ((.) foo) . zip
12:32:43 <marx2> after the first argument is applied to zip, we get (foo . (zip firstArg))
12:33:35 <marx2> the way to read it easier is to count the number of dots, which equals to the number of arguments right-most function takes :)
12:34:22 <Geraldus> marx2: Og, that's make sence!
12:34:44 <Geraldus> Sorry for my ugly English
12:35:40 <pavonia> Why not just "fn = zipWith zip"?
12:36:16 <Geraldus> pavonia: Oh, I'll check
12:37:16 <Geraldus> pavonia: Looks like exactly what I need!
12:37:58 <Geraldus> :t zipWith zip --> [[a]] -> [[b]] -> [[(a,b)]]
12:37:59 <lambdabot> [[a]] -> [[b]] -> [[(a, b)]]
12:41:36 <m1dnight> Does anybody here know how I can get the auto-inserted primary key value in SQLite simple?
12:42:06 <m1dnight> the doc explicitly states "
12:42:13 <m1dnight> or other SQL query that is not expected to return results.
12:43:28 <m1dnight> aha! using query instead of execute does compile so it seems :)
12:44:48 <jeroldhaas> m1dnight: I'd assume query would be expected a Result, but execute wouldn't
12:45:38 <aristid> i wish haskell had proper modules like agda or ML
12:52:52 <danharaj> yup
12:53:10 <danharaj> After working on a production codebase I would really like modules.
12:56:47 <edwardk> danharaj: yes
12:56:54 <danharaj> interesting *scribbes notes*
12:58:02 <Geraldus> Thnanks!
12:58:08 <joelteon> > text 3
12:58:09 <lambdabot>  No instance for (GHC.Num.Num GHC.Base.String)
12:58:09 <lambdabot>    arising from the literal `3'
12:58:09 <lambdabot>  Possible fix:
12:58:09 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Base.String)
12:58:15 <joelteon> > text "hello, world!"
12:58:16 <lambdabot>  hello, world!
12:58:26 <joelteon> > vcat [text "hello", text "world!"]
12:58:27 <lambdabot>  hello
12:58:27 <lambdabot>  world!
13:08:34 <m1dnight> guys, I have a query that just saves an event. I changed it from execute to 'query' but this seems to return [Event], instead of a single event.
13:08:56 <m1dnight> But what I want is, get the ID of the just-inserted record, and then update a value in it's own record for which I need the primkey
13:09:42 <m1dnight> So, I have that function (createURL) that takes an Event (for it's Id). I figured I'd change it's parameter to (Event eId ÃÂ°_ _):xs
13:09:46 <m1dnight> but that gives me a parse error?
13:10:34 <JeroldHaas> Strange, I must need a UTF-8 font...
13:10:47 <m1dnight> oh yeah, there is a faulty char in there
13:10:55 <m1dnight> createURL :: [Event] -> Handler App Sqlite ()
13:10:56 <m1dnight> createURL (Event eId _ _ _ _ _ _):es =
13:10:58 <m1dnight> this :)
13:11:25 <m1dnight> throws: src/Db.hs:95:1: Parse error in pattern: createURL
13:12:01 <m1dnight> and my event has 7 parameters, and I have the 'eId' and 6 underscores
13:12:14 <m1dnight> (7 fields in the Event type I mean)
13:12:37 <pavonia> I think you need parentheses around (...):es
13:12:58 <m1dnight> omg yes :p
13:13:01 <m1dnight> that will be it
13:13:03 <m1dnight> let me try thanks :)
13:14:36 <m1dnight> dang, the query returns and empty list :(
13:17:10 <pavonia> m1dnight: Are you using a package for SQL queries?
13:17:23 <benzrf> @pl \func mod arg -> mod (func arg)
13:17:24 <lambdabot> flip (.)
13:17:27 <benzrf> ??
13:17:38 <benzrf> o:
13:19:32 <m1dnight> Yes, I'm using SQlite.Simple
13:19:48 * m1dnight is a very big haskellnoob, but manageing :p
13:19:50 <m1dnight> managing*
13:20:37 <pavonia> I'm curious, where do you need Events in SQL?
13:21:18 <m1dnight> oh, when I execute the query in sqliteman it doesn't return anything as well
13:21:19 <m1dnight> Query OK
13:21:20 <m1dnight> Row(s) returned: 0
13:21:34 <m1dnight> pavonia: Events is a type I created myself. I'm building a calendar application
13:21:48 <pavonia> Oh, I see
13:23:20 <benzrf> @pl \match then' else' -> if match then then' else else'
13:23:21 <lambdabot> if'
13:23:25 * benzrf facepalms
13:23:27 <benzrf> wait no
13:23:39 <benzrf> @pl \match then' else' input -> if input == match then then' else else'
13:23:39 <lambdabot> (flip .) . flip . (if' .) . (==)
13:23:42 <benzrf> bah
13:24:42 <benzrf> wait...
13:24:52 <benzrf> @pl \match then' input -> if input == match then then' else input
13:24:52 <lambdabot> flip flip id . (ap .) . flip . (if' .) . (==)
13:24:57 <benzrf> pfft
13:25:51 <JeroldHaas> what's with that moon language? more UTF-8?
13:26:01 <benzrf> >
13:26:04 <JeroldHaas> (==)
13:26:10 <JeroldHaas> oh double equals
13:26:18 <JeroldHaas> I'm using a Chinese font
13:26:21 <benzrf> hah
13:26:42 <JeroldHaas> was hoping for better Unicode support
13:27:09 <JeroldHaas> \0x1234
13:27:13 <JeroldHaas> nerp
13:27:20 <JeroldHaas> unless I'm doing it wrong
13:27:29 <JeroldHaas> \0x1234
13:27:36 <JeroldHaas> can't remember, long time
13:27:45 <ion> "\x1234"
13:28:00 <JeroldHaas> for IRC?
13:28:05 <JeroldHaas> \x1234
13:28:08 <JeroldHaas> nerp
13:28:09 <ion> for Haskell
13:28:17 <JeroldHaas> other langs too
13:28:37 <JeroldHaas> IRC needs a MathML or similar
13:28:59 <JeroldHaas> so we can all wall-paste our insanities
13:30:45 <benzrf> install textheworld and use webchat
13:30:46 <benzrf> :-D
13:32:45 <aleksejs_> btw, happy BD Sir Isaac, inventor of calculus
13:33:10 <JeroldHaas> going to check out Leksah
13:33:55 <ImUrBreda> anyone has an example of how to convert between a map and any record with GHC.Generics?
13:34:25 <ImUrBreda> let's say between a Map String Int and records
13:37:11 <dreixel> ImUrBreda: records?
13:37:16 <dreixel> can you give an example?
13:37:57 <ImUrBreda> struct/record
13:38:16 <ImUrBreda> you know the data MyType = MyType {a::Int,b::Int}
13:38:41 <dreixel> but I don't see how to do that non-generically, let alone generically.
13:38:46 <donri> probably want like, fromList [("age",20)] -> [Person {age = 20}]
13:39:10 <donri> i imagine it could be done since GShow is possible? but it'd be partial?
13:39:22 <dreixel> donri: ah, yes, that could be done.
13:39:23 <Peaker> ImUrBreda: you mean if the record field types are all the same?
13:39:37 <benzrf> @pl \(a, b) (x, y) -> (a + x, b + y)
13:39:37 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
13:39:39 <ImUrBreda> Yes, possibly they are the same, possibly they are incompatible
13:39:43 <benzrf> jesus christ
13:39:47 <ImUrBreda> an Either String a would be preferable
13:40:01 <ImUrBreda> as a return value so i can see conversion error
13:40:03 <Peaker> ImUrBreda: but it is statically known whether a Map can be used. What about using json?
13:40:08 <Peaker> ImUrBreda: what's the purpose of these Maps?
13:40:20 <benzrf> @hoogle cartesian
13:40:20 <lambdabot> No results found
13:40:27 <benzrf> is there a cartesian product function?
13:41:14 <benzrf> better: is there a predefined function for calculating the moore neighborhood of a coordinate pir?
13:41:17 <ImUrBreda> Peaker: imagine someting similar to json deserialization
13:41:19 <benzrf> *pair
13:41:48 <Peaker> ImUrBreda: my question is why not use json itself, what is the advantage of a Map here?
13:42:25 <ImUrBreda> Peaker: mostly for learning purposes, I want a minimum viable example of how to do this stuff, can't really read the aeson code for example
13:42:27 <ImUrBreda> too dense for me
13:43:09 <Peaker> ImUrBreda: I found aeson readable.. Using GHC Generics seems difficult to me..
13:43:40 <marx3> > sequence [[1,2,3],[4,5,6]]
13:43:41 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
13:43:44 <ImUrBreda> Peaker: so there is no easy way I guess
13:43:46 <benzrf> ...god dammit
13:53:30 <Gracenotes> danharaj: I feel similarly
13:55:57 <Gracenotes> I wouldn't mind there being some global providers and consumers of modules, though, so you don't have to pass everything in manually.
13:59:01 <Gracenotes> (such that it's, well, modular)
13:59:50 <Clint> did i hallucinate a library that does user input callbacks?
14:02:27 <augur_> :(
14:02:36 <augur_> i dont understand type polarity :\
14:02:42 <augur_> none of this stuff makes sense
14:06:13 <benzrf> :t mapM
14:06:14 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
14:06:44 <benzrf> :t mapM_
14:06:45 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
14:07:31 <benzrf> hmm
14:09:50 <benzrf> @hoogle [(a -> m a)] -> m a -> m a
14:09:52 <lambdabot> Test.QuickCheck.Arbitrary shrinkList :: (a -> [a]) -> [a] -> [[a]]
14:09:52 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
14:09:52 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
14:10:58 <benzrf> hrm
14:11:30 <shiona> :t foldl (>>=)
14:11:31 <lambdabot> Monad m => m a -> [a -> m a] -> m a
14:11:42 <benzrf> yeah i figured that out :P
14:11:49 <shiona> is it actually that?
14:12:01 <shiona> I was a first hunch
14:17:00 <ifesdjeen> is there any way to get a value in a pattern match? for example, I have a function like: eval envRef closure (LispList ((LispFunction (UserFunction fnClosure bindings form)) : args))
14:17:17 <ifesdjeen> and I eant to get this part: ((LispFunction (UserFunction fnClosure bindings form)) as a single value?
14:17:31 <ifesdjeen> without re-creating it
14:17:39 <benzrf> @pl reader . const
14:17:39 <lambdabot> reader . const
14:17:54 <benzrf> *is that a preexisting thing
14:18:00 <benzrf> :t reader.const
14:18:01 <lambdabot> MonadReader r m => a -> m a
14:18:11 <ifesdjeen> ah @
14:18:21 <benzrf> @hoogle MonadReader r m => a -> m a
14:18:21 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> forall a. Data a => a -> m a
14:18:21 <lambdabot> Control.Monad.Reader.Class local :: MonadReader r m => (r -> r) -> m a -> m a
14:18:21 <lambdabot> Control.Monad.Reader local :: MonadReader r m => (r -> r) -> m a -> m a
14:18:26 <ifesdjeen> so it
14:18:39 <ifesdjeen> so it'd be something like eval envRef closure (LispList val@((LispFunction (UserFunction fnClosure bindings form))
14:18:43 <ifesdjeen> thanks!
14:20:21 <benzrf> hold on a second
14:20:22 <benzrf> ...
14:20:35 <benzrf> how do multi-param constraints work??
14:21:12 <aristid> MonadReader Int m =>
14:21:29 <benzrf> no, I mean
14:21:33 <benzrf> what does that mean?
14:21:49 <benzrf> 'Foo x =>' means that x is an instance of foo
14:21:54 <aristid> it means that there needs to be an instance for class MonadReader r m for those two types
14:22:08 <benzrf> typeclasses can take multiple parameters?
14:22:10 <benzrf> since when?
14:22:16 <kkg2121> hey guys, super newbie question here. i'm just starting richard bird's book and came across the composition function (.), which Bird says has a type signature (.) :: (b -> c) -> (a -> b) -> (a -> c) and a definition (f . g)x = f(g(x). can (.) be thought of as a curried function where the uncurried version would take three arguments f, g, and x?
14:22:26 <kkg2121> or is that the wrong understanding of currying?
14:22:29 <aristid> benzrf: since the Multi Param Type Class extension was added:)
14:22:35 <benzrf> oh it's an extension?
14:22:41 <benzrf> boo hiss
14:22:51 <aristid> benzrf: it's a pretty standard extension these days
14:23:01 <aristid> mtl uses it
14:23:25 <benzrf> kkg2121: I guess?
14:23:41 <benzrf> kkg2121: remember, foo x = bar and foo = \x -> bar are the same thing
14:24:17 <benzrf> kkg2121: and '\foo bar -> baz' is the same as '\foo -> \bar -> baz'
14:24:19 <aristid> kkg2121: yes, in haskell functions with more than one parameters are usually represented as curried functions
14:25:24 <twirlobite> isn't "do" notation very...imperative?
14:25:56 <kkg2121> benzrf and aristid: +++ :)
14:26:21 <twirlobite> or am i understanding "do" totally wrong?
14:26:53 <benzrf> :t (+++)
14:26:53 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
14:26:57 <benzrf> twirlobite: do is just syntactic sugar
14:26:59 <vektor> twirlobite: I guess it's as imperative as haskell gets.
14:26:59 <marx3> twirlobite it looks imperative, but `do x <- foo; bar x' is just syntactic sugar for foo >>= \x -> bar x
14:27:05 <benzrf> twirlobite: it just gets translated into an expression
14:27:24 <marx3> and return is a function
14:27:27 <benzrf> twirlobite: it doesnt do anything not done elsewhere
14:27:28 <marx3> :t return
14:27:29 <lambdabot> Monad m => a -> m a
14:27:46 <benzrf> return should be called unit
14:27:49 <twirlobite> ahhh
14:27:55 <aristid> no, it should be called pure
14:28:00 <benzrf> right
14:28:02 <benzrf> my bad
14:28:06 <benzrf> twirlobite: do you know bout monads/
14:28:12 <marx3> (I could have written that as foo >>= bar)
14:28:55 <twirlobite> benzrf: just a bit, not yet, the book i am reading (Graham Hutton's Programming in Haskell) has introduced >>= and do before talking about monads specifically
14:29:14 <benzrf> that doesnt make sene
14:29:16 <benzrf> *sense
14:29:26 <benzrf> you can't talk about >>= in a more general sense than monads
14:29:32 <benzrf> >>= operates on monads and only monads
14:29:41 <benzrf> :t (>>=)
14:29:41 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:29:48 <twirlobite> its the truth, should i explain how he introduced it?
14:29:53 <benzrf> go on...
14:29:58 <gamegoblin>  How do you guys pronounce cabal? Like "cay - bull" or "cah - bull" or "caa - bull" etc?
14:30:11 <benzrf> gamegoblin: i say cuh-ball but im probably wrong
14:30:28 <twirlobite> benzrf: i'll type up the relevant points in a pastebin, hold on
14:30:33 <aristid> benzrf: you can talk about >>= in a more _specific_ sense than monads.
14:30:48 <aristid> twirlobite: does he introduce >>= and do notation in the context of IO?
14:30:50 <benzrf> true...
14:31:05 <twirlobite> aristid: no, in the context of making a parser
14:31:11 <twirlobite> aristid: a functional parser
14:31:16 <aristid> twirlobite: ah
14:31:56 <aristid> twirlobite: do notation can make things look imperative that really aren't:D
14:32:09 <benzrf> twirlobite: look at this
14:32:26 <benzrf> @undo foo; bar; x <- baz; n <- quux x; return n
14:32:27 <lambdabot> <unknown>.hs: 1: 4:Parse error: ;
14:32:30 <benzrf> @undo foo; bar; x <- baz; n <- quux x; return n;
14:32:30 <lambdabot> <unknown>.hs: 1: 4:Parse error: ;
14:32:32 <benzrf> ugh
14:32:39 <benzrf> @undo do {foo; bar; x <- baz; n <- quux x; return n;}
14:32:39 <lambdabot> foo >> bar >> baz >>= \ x -> quux x >>= \ n -> return n
14:32:58 <twirlobite> benzrf: i'm terrible at understanding foo/bar/baz examples, i have basically given up on ever trying to understand them
14:33:02 <benzrf> ahf:
14:33:03 <benzrf> *ah
14:33:03 <marx3> > do x <- [1,2,3]; y <- [10,20,30]; return (x,y)
14:33:04 <lambdabot>  [(1,10),(1,20),(1,30),(2,10),(2,20),(2,30),(3,10),(3,20),(3,30)]
14:33:10 <twirlobite> benzrf: plus, i haven't seen the >> notation :/
14:33:16 <benzrf> @src >>
14:33:17 <lambdabot> m >> k      = m >>= \_ -> k
14:34:15 <benzrf> if you have a line and the rest of the block, it gets translated to the line bound to the rest of the block wrapped in a lambda
14:34:31 <benzrf> on <- lines, the left-hand-side is the lambda's argument
14:34:41 <benzrf> on other lines, the argument is thrown away
14:35:01 <benzrf> if I have this:
14:35:26 <benzrf> do {putStrLn "What's your name?"; name <- getLine; putStrLn "sup " ++ name;}
14:35:27 <benzrf> that's just:
14:36:04 <benzrf> putStrLn "What's your name?" >>= \throwaway -> getLine >>= \name -> putStrLn "sup " ++ name
14:36:05 <benzrf> well, a _ and not a throwaway
14:36:05 <benzrf> but same idea
14:36:18 <ahf> benzrf: :S
14:37:27 <benzrf> twirlobite: if you know about callbacks like in JS, you can think of do-notation as having each line inside a callback to the previous one
14:37:31 <benzrf> nested callbacks
14:38:18 <aristid> please don't involve javascript in this channel unnecessarily! :D
14:39:23 <benzrf> :P
14:39:59 <enthropy> ImUrBreda: http://lpaste.net/97525
14:40:44 <ImUrBreda> enthropy: reading, thanks
14:41:01 <enthropy> this is the predecesor to GHC.Generics... it doesn't seem like the latter has the same metadata about field names
14:41:40 <enthropy> I think you can get the Constr argument out of the result type with some function
14:41:52 <enthropy> say specifying "the first constructor of the data type"
14:42:06 <marx3> twirlobite, try using other monads, like `list` and `maybe` monads. maybe is one of the simplest ones
14:43:31 <larss> can i somehow get size of the haskell object? like size of in C
14:43:32 <twirlobite> benzrf marx3 aristid vektor : http://pastebin.com/XCDGP1AC
14:43:36 <mauke> The paste XCDGP1AC has been copied to http://lpaste.net/97526
14:46:17 <twirlobite> benzrf: marx3 aristid vektor -- sequential composition the way its presented totally "feels" imperative
14:46:35 <twirlobite> even if it all gets translated into one "long function"
14:46:47 <benzrf> yep
14:47:47 <benzrf> so im working on an implementation of a way to ping people seemingly unintentionally
14:48:38 <enthropy> ImUrBreda: this is that slightly-more-convenient version: fromMap m = let self = fromMap' (indexConstr (dataTypeOf self) 1) m in self
14:48:49 <startling> monadic style is very similar to js-style callbacks, though
14:48:56 <startling> just with less syntactic weight.
14:49:23 <benzrf> actually livescript has 'backcalls' which are basically just back-arrow syntax
14:49:44 <benzrf> foo <- bar(baz) becomes bar(baz, (foo) -> ...)
14:49:49 <aristid> twirlobite: ok, good to know it feels that way to you :) are there any consequences of this feeling?
14:50:03 <startling> yeah, do notation is very much about avoiding unnecessary syntactic nestng.
14:50:47 <twirlobite> aristid: well, it feels like...i am either understanding it wrong, or all programs, in the end, functional or imperative, really are executed the same way
14:51:03 <twirlobite> by the computer
14:51:04 <twirlobite> i don't know
14:51:15 <startling> benzrf, you can use it without binding to nest the rest of the block in a nullary function? weeeeird
14:51:32 <aristid> twirlobite: haskell code is actually executed in a somewhat different way than most code, as you'll learn when you try to use gdb or anything like that on it :)
14:51:52 <twirlobite> aristid: why, because of the laziness?
14:52:03 <aristid> twirlobite: i think that's a large part of it
14:52:12 <twirlobite> aristid: i could have a lazy imperative language too though
14:52:14 <aristid> twirlobite: i mean in the end of course, it's all just machine instrucitons
14:52:38 <aristid> twirlobite: well, a lazy language with side effects on evaluation would behave in very confusing ways
14:53:14 <twirlobite> aristid: isn't function application a process with a side effect?
14:53:18 <aristid> no.
14:53:25 <twirlobite> aristid: it's just that the side effect is very carefully documented
14:53:45 <startling> twirlobite, it's a side-effect if you're looking at the implementation.
14:53:51 <aristid> which effect are you talking about?
14:54:04 <twirlobite> an effect similar to assignment
14:54:13 <twirlobite> (assignment in imperative languages)
14:54:16 <aristid> ?
14:54:36 <startling> twirlobite: if you're looking at the implementation, yeah
14:54:50 <twirlobite> hmm
14:55:04 <startling> aristid, there's mutation behind the scenes -- you change an expression in the expression tree to a different one
14:55:24 <aristid> twirlobite: anyways, in your parser example, the way it "looks imperative" is completely unrelated to the imperative machine code it compiles down to. it really is a functional program still.
14:55:33 <aristid> startling: i think the mutation happens mostly on pattern matches, not function application
14:55:53 <startling> aristid: I don't know if we're talking about the same thing.
14:57:08 <mlen> startling: you mean something like application in lambda calculus?
14:57:11 <ifesdjeen> is there any way of testing some function that involves Monadic IO?
14:57:16 <aristid> startling: lazy evaluation could hypothetically be viewed as a kind of mutation, and pattern matches are what forces the constructors, no?
14:57:21 <ifesdjeen> having that said, without quickcheck :)
14:57:34 <startling> aristid: oh, fair enough
14:57:45 <startling> ifesdjeen, what does the IO do?
14:58:05 <ifesdjeen> startling: i'm writing a little handmade lisp in haskell
14:58:11 <benzrf> ifesdjeen: i did that :D
14:58:14 <benzrf> it was p crappy
14:58:15 <ifesdjeen> startling: and most of my functions use IO monad :)
14:58:16 <ifesdjeen> yes
14:58:17 <startling> ifesdjeen, why do you need IO?
14:58:19 <benzrf> oh god why
14:58:19 <ifesdjeen> mine is crappy too
14:58:23 <startling> ifesdjeen, well, let me put it this way
14:58:26 <benzrf> mine wasn't THAT crappy
14:58:26 <benzrf> ;p
14:58:31 <benzrf> mine only used IO for the REPL
14:58:33 <ifesdjeen> mostly because i don't know much haskell
14:58:39 <mlen> ifesdjeen: hunit?
14:58:43 <ifesdjeen> i'm using Hashtables
14:58:50 <benzrf> D:
14:58:51 <ifesdjeen> mlen: i'm using hspec but hunit would work :)
14:58:53 <JordanL> Does anyone have any free time and is willing to help me set up haskell on Debian from scratch?
14:59:03 <benzrf> JordanL: why not apt-get install haskell-platform
14:59:08 <startling> ifesdjeen, you can use ST with hashtables
14:59:13 <startling> and get out of IO
14:59:18 <ifesdjeen> startling: i'll convert it to ST
14:59:24 <JordanL> I mean, cabal, IDEs, the whole 9 yards
14:59:25 <ifesdjeen> just need to get some basics running
14:59:26 <benzrf> state transformer?
14:59:27 <mlen> ifesdjeen: but anyway, you can write your own monads to replace IO (interface matters) and test with them with quickcheck
14:59:28 <aristid> ifesdjeen: you probably want to use unordered-containers, not HashTable :)
14:59:31 <benzrf> JordanL: cabal is in haskell-platform
14:59:35 <ifesdjeen> ah, i see
14:59:38 <startling> you can use Data.Map, too, yeah.
14:59:45 <benzrf> JordanL: haskell-platform IS the whole nine yards
14:59:50 <aristid> startling: unordered-containers is not Data.Map :P
14:59:50 <benzrf> except maybe for an IDE
15:00:00 <benzrf> personally ive just been using vim w/ ghci...
15:00:08 <startling> aristid, hence "too". :)
15:00:09 <benzrf> but that's probably terribl
15:00:10 <benzrf> e
15:00:42 <JordanL> the whole linking ghci to a IDE is so daunting for me :/
15:00:43 <ifesdjeen> tried data.map but it involved bit too much stuff for someone who had no idea about haskell
15:00:44 <aristid> startling: isn't Data.Map usually slower than unordered-containers? :) http://hackage.haskell.org/package/unordered-containers
15:00:57 <quchen> aristid: Are you a bot?
15:01:15 <aristid> quchen: I am a real person!
15:01:22 <twirlobite> aristid: stop lying
15:01:33 <benzrf> JordanL: linking??
15:01:34 <pxqr> why Network.Socket.recv doesn't block os thread?
15:01:36 <benzrf> JordanL: what do you mean?
15:01:51 <benzrf> JordanL: just apt-get install haskell-platform, for starters
15:02:01 <benzrf> JordanL: that should be everything you need except for an IDE, assuming you want tone
15:02:03 <startling> aristid, I don't know.
15:02:05 <benzrf> *one
15:02:16 <JordanL> ok, ill start out and come back to you guys
15:02:19 <JordanL> Thanks
15:02:21 <benzrf> np
15:03:01 <aristid> ifesdjeen: which kind of stuff in Data.Map confused you?
15:03:59 <startling> there /are/ a lot of things in Data.Map but you just need fromList, insert, and lookup
15:04:45 <mmaruseacph2> for all others you only look at the type signature, when you need them
15:06:24 <ifesdjeen> aseidl: can't remember what exaclty was so problematic, but i basically couldn't figure how to put a value into the hashtable, do lookup.. well anything
15:07:51 <startling> > M.insert 1 "hi" $ M.fromList [(2, "bye")]
15:07:52 <lambdabot>  fromList [(1,"hi"),(2,"bye")]
15:08:07 <startling> > M.lookup 2 $ M.fromList [(2, "bye")]
15:08:09 <lambdabot>  Just "bye"
15:08:26 <startling> the thing to realize is that "insert" creates a new map from the old one containing the new value
15:08:39 <startling> other than that it's not really tricky from a new-to-haskell perspective
15:09:18 <ifesdjeen> :)
15:09:22 <ifesdjeen> thanks guys
15:09:34 <ifesdjeen> startling: i'll try it again
15:09:42 <ifesdjeen> now as i understand at least how to do some basics
15:09:48 <ifesdjeen> thanks a ton startling
15:10:27 <startling> ifesdjeen: the other thing you probably want is "import qualified Data.Map as M", which will namespace everything
15:10:38 <ifesdjeen> right
15:10:38 <startling> (some of the names in Data.Map conflict with some in Prelude)
15:10:50 <ifesdjeen> that also probably got me :)
15:11:01 <startling> yeah. it can take a while to get used to ghc's error messages.
15:12:06 <aristid> they're not remotely as bad as c++ error messages though.
15:12:37 <ifesdjeen> :)
15:12:40 <ifesdjeen> true that
15:12:49 <ifesdjeen> actually after a couple of weeks many things become clearer
15:13:27 <startling> I think the thng is that other language implementations teach you to scan an error message and guess what it is, where ghc tells you exactly what the error is and in great detail.
15:15:22 <ifesdjeen> startling: yup, i'm growing to like it :)
15:15:23 <ifesdjeen> still got a long way
15:15:43 <startling> ifesdjeen, good. :)
15:16:08 <JordanL>   do i use terminal or root terminal to install haskell?
15:16:35 <ifesdjeen> JordanL: just use sudo
15:16:38 <startling> how are you installing?
15:16:40 <JordanL> ok
15:16:47 <startling> that's kind of bad advice.
15:16:57 <startling> JordanL, how are you installing it?
15:16:58 <ifesdjeen> hm, i assume apt-get doesn't install otherwise
15:17:04 <ifesdjeen> but yes, may be a bad advise
15:17:25 <startling> e.g. cabal does the wrong thing if you use sudo.
15:18:51 <JordanL> I have no idea how to use unix/debian/command line
15:19:42 <JordanL> should i just constantly use the root terminal
15:19:43 <JordanL> ?
15:19:48 <startling> JordanL: yeah. sudo apt-get install ghc6
15:19:57 <startling> no, use "sudo" where available
15:20:04 <JordanL> i tried
15:20:10 <JordanL> got "user not in sudo"
15:20:18 <gamegoblin> is there a performance benefit to using "let...in..." rather than where when the where is only applied to one expression?
15:20:54 <JordanL> and i wanna try install cabal and all that to configure haskell with an IDE
15:20:59 <JordanL> hopefully emacs
15:21:18 <benzrf> just apt-get install haskell-platform
15:21:32 <JordanL> sudo apt-get install haskell-platform?
15:21:35 <benzrf> yes
15:21:39 <benzrf> when nonroot
15:21:42 <startling> JordanL, become superuser somehow and adduser JordanL sudo
15:21:42 <benzrf> you dont need sudo as root
15:22:47 <benzrf> expected type is what it should be, while actual is what is in the program
15:22:48 <benzrf> right?
15:23:12 <quchen> Yes.
15:23:24 <benzrf> OK
15:23:24 <quchen> Actual = "given"
15:24:52 <k00mi> Peaker: heads-up, lamdu is on the hacker news front page
15:24:59 <benzrf> ok i wrote this http://lpaste.net/1557502184029945856
15:25:08 <benzrf> it is type erroring
15:25:11 <benzrf> and I don't understand why
15:26:11 <Feuerbach> ask the compiler
15:26:21 <Feuerbach> what does it say?
15:27:04 <benzrf> i know what the error is
15:27:14 <benzrf> but I don't understand where the other type is coming from
15:27:21 <Feuerbach> but we don't. how can we help you then?
15:27:41 <benzrf> paste that into ghc or something
15:27:48 <benzrf>     Couldn't match type `Map Coords Tile' with `r0 -> Tile'
15:27:48 <benzrf>     Expected type: r0 -> Tile
15:27:48 <benzrf>       Actual type: World
15:27:49 <benzrf>     In the first argument of `const', namely `world'
15:28:58 <quchen> Paste the full error. And on a website, not in here.
15:29:21 <benzrf> ok
15:29:50 <benzrf> http://lpaste.net/97528
15:30:25 <enthropy> maybe you mean  reader $ const world
15:30:45 <enthropy> maybe you mean (return world)
15:31:18 <benzrf> argh
15:31:20 <benzrf> you're right
15:31:24 <benzrf> *the former
15:31:25 <enthropy> the first argument to foldl can help here
15:31:31 <enthropy> @type reader . const
15:31:32 <lambdabot> MonadReader r m => a -> m a
15:31:36 <enthropy> @type return
15:31:37 <lambdabot> Monad m => a -> m a
15:31:48 <benzrf> @src Reader return
15:31:49 <lambdabot> Source not found. Just try something else.
15:31:53 <benzrf> @src ReaderT return
15:31:54 <lambdabot> Source not found. Whoa.
15:32:02 <quchen> return = const
15:32:09 <benzrf> dur
15:32:13 * enthropy would use return
15:32:13 <benzrf> well i feel silly
15:32:14 <benzrf> >_>
15:32:25 <prophile> @djinn a -> (r -> a)
15:32:26 <lambdabot> f a _ = a
15:32:30 <benzrf> djinn?
15:32:42 <benzrf> oh neat
15:32:43 <benzrf> !
15:33:07 <twirlobite> is there a book/website where there is a list of haskell problems to do, and you can try your hand at them, and then finally compare with a prepared solution for the problem too?
15:33:09 <benzrf> @djinn Maybe a -> b -> Either a b
15:33:09 <lambdabot> f a b =
15:33:09 <lambdabot>     case a of
15:33:09 <lambdabot>     Nothing -> Right b
15:33:09 <lambdabot>     Just c -> Left c
15:33:10 <joelteon> @djinn (a -> r) -> a
15:33:10 <lambdabot> -- f cannot be realized.
15:33:11 <gamegoblin> is there a prelude function that is basically "f h (a,b) = (h a, h b)" ?
15:33:23 <benzrf> dang
15:33:30 <benzrf> gamegoblin: i think arrow has that
15:33:52 <quchen> gamegoblin: Not really. I think you best define it yourself locally. There's "join (***)" if you really want something built-in.
15:34:00 <JordanL> when you use apt-get install haskell-platform on unix, does it install any cabal packages?
15:34:06 <benzrf> i think so
15:34:12 <navaati> :t join (***)
15:34:13 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
15:34:14 <benzrf> the platform is a stdlib
15:34:38 <benzrf> :t join (+++)
15:34:41 <lambdabot> ArrowChoice a => a b c -> a (Either b b) (Either c c)
15:34:45 <benzrf> oh wait
15:34:50 <Clint> :t join (&&&)
15:34:53 <lambdabot> Arrow a => a b c -> a b (c, c)
15:34:58 <benzrf> ^the one i meant probably
15:35:17 <navaati> is there a way to constrain a type when using :t ? like "besides, i want 'a' to be (->)"
15:35:46 <benzrf> :t asAppliedTo
15:35:49 <lambdabot> (a -> b) -> a -> a -> b
15:36:15 <benzrf> :t (++[]) `asAppliedTo` "foo"
15:36:16 <lambdabot> [Char] -> [Char]
15:36:21 <quchen> asAppliedTo = const (with specialized type sig)
15:36:33 <navaati> brilliant
15:36:51 <quchen> :t join (***) `asAppliedTo` (undefined :: a -> b)
15:36:52 <lambdabot> (a -> b) -> (a, a) -> (b, b)
15:37:11 <benzrf> :D
15:37:21 <quchen> There's also "over both" from Lens.
15:37:29 <quchen> :t over both
15:37:30 <lambdabot> (a -> b) -> (a, a) -> (b, b)
15:37:38 <benzrf> :t both
15:37:38 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
15:37:45 <benzrf> :[
15:37:46 <navaati> :t join (&&&) `asAppliedTo` (undefined :: a -> b)
15:37:47 <lambdabot> (a -> b) -> a -> (b, b)
15:38:23 <quchen> join f x = f x x. It's the Reader Monad instance.
15:38:45 <quchen> So join (***) f = (f *** f)
15:38:59 <benzrf> >Identity 3
15:39:16 <benzrf> > Identity 3
15:39:18 <lambdabot>  Identity {runIdentity = 3}
15:39:21 <navaati> good ol' (-> r) monad
15:39:25 <benzrf> > _1 Identity (1, 2)
15:39:26 <lambdabot>  Identity {runIdentity = (1,2)}
15:39:41 <quchen> navaati: (r ->), not (-> r).
15:39:51 <benzrf> :t _1
15:39:52 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
15:40:05 <benzrf> christ
15:40:18 <navaati> quchen: well depends if you think of (->) as an operator or not ^^
15:40:20 <benzrf> > view _1 (1, 2)
15:40:22 <lambdabot>  1
15:40:31 <benzrf> > _1 .~ (1, 2)
15:40:32 <lambdabot>  No instance for (Control.Lens.Tuple.Field1 s0 t0 a0 (t1, t2))
15:40:32 <lambdabot>    arising from a use of `e_1112'
15:40:32 <lambdabot>  The type variables `s0', `t0', `a0', `t1', `t2' are ambiguous
15:40:32 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
15:40:32 <lambdabot>  Note: there are several potential instances:
15:40:36 <benzrf> > _1 ^. (1, 2)
15:40:37 <lambdabot>  Couldn't match type `(t1, t2)'
15:40:37 <lambdabot>                with `(a0 -> Control.Lens.Internal.Getter.Accessor a0 a0)
15:40:38 <lambdabot>                      -> (p0 a1 (f0 b0) -> s0 -> f0 t0)
15:40:40 <lambdabot>                      -> Control.Lens.Internal.Getter.Accessor
15:40:40 <benzrf> argh
15:40:42 <lambdabot>                           a0 (p0 a1 (f0 b0) -> s0 -> f0 t0)'
15:40:50 <quchen> benzrf: Private sesseion maybe?
15:40:56 <benzrf> my bad <_>
15:41:00 <navaati> benzrf: don't try to understand edkmet's lens
15:41:10 <navaati> just use it
15:41:21 <navaati> or you'll go mad
15:41:31 <benzrf> bbbut
15:41:37 <benzrf> i dont like using things i dont understand
15:41:48 <navaati> neither do I. but this...
15:41:55 <navaati> is insane
15:42:50 <benzrf> hmmm
15:42:53 <benzrf> where are logs?
15:42:55 <benzrf> oh w8
15:42:58 <benzrf> hah
15:43:07 <quchen> (r ->) is correct by abuse of notation. (-> r) is always incorrect.
15:43:11 <benzrf> thank god i pasted my code here before my hard drive exploded
15:43:14 <quchen> (As a Monad instance.)
15:43:34 <benzrf> ((->) r)
15:43:36 <benzrf> is crect
15:43:39 <quchen> Yep.
15:44:06 <benzrf> oh sh
15:44:14 <benzrf> hmm
15:44:34 <twiceler> So when GHC 7.8 comes around and we have overloaded record fields (http://www.well-typed.com/blog/84)
15:44:57 <quchen> twiceler: 7.8 won't have overloaded records
15:45:21 <quchen> The plan is to merge it after 7.8's release
15:45:27 <twiceler> will tuples be redefined as, for example, data (,,,a) = (,,) { _1 :: a, _2 :: a, _3 :: a }
15:46:32 <JordanL> what text editor is good on debian?
15:46:53 <quchen> Tuples won't be redefined, but there will be some new typeclasses (think of "HasField1") to make stuff like "_1" work on any tuple.
15:46:58 <twiceler> quchen: Oh. Yeah, I totally misread that. It would be nice for tuples to be records when it comes! no more writing things like (\(a,b,c) -> a))
15:47:03 <AlainODea> benzrf: lens isn't so much a library as a language
15:47:25 <JordanL> my haskell-platform install has been completed?
15:47:50 <benzrf> woo for EDSL
15:48:00 <quchen> twiceler: Well 3-tuples are pretty rare right now.
15:48:17 <benzrf> ["http://tunes.org/~nef/logs/haskell/13.12.25","http://tunes.org/~nef/logs/haskell/13.12.24","http://tunes.org/~nef/logs/haskell/13.12.23","http://tunes.org/~nef/logs/haskell/13.12.22","http://tunes.org/~nef/logs/haskell/13.12.21","http://tunes.org/~nef/logs/haskell/13.12.20","http://tunes.org/~nef/logs/haskell/13.12.19","http://tunes.org/~nef/logs/haskell/13.12.18","http://tunes.org/~nef/logs/haskell/13.12.17","http://tunes.org/~nef/l
15:48:24 <benzrf> shit
15:48:39 <twiceler> quchen: What do you mean? I use them a fair amount...
15:49:25 <JordanL> could someone help me install an IDE on debian for haskel
15:49:30 <quchen> Most of the time it's better to define your own 3-tuple type (such as `data Person = Person Name Age Height`).
15:50:03 <quchen> JordanL: Most people here use Emacs or Vim.
15:50:14 <quchen> Any text editor will do.
15:50:19 <quchen> Very few here use IDEs.
15:50:46 <JordanL> how would i install or use vim, for example?
15:51:00 <quchen> sudo apt-get instlall vim emacs
15:51:02 <quchen> … I would assume
15:51:11 <AlainODea> JordanL: Emacs is my preference.  I followed jekor's youtube content to get off the ground with it.  Learning curve is more than trivial, but worth it
15:51:14 <benzrf> vim is the shit
15:51:41 <benzrf> emacs is practically an OS.
15:51:46 <benzrf> the idea is that it does everything
15:51:48 <quchen> No editor ward please.
15:51:51 <quchen> wars*
15:51:53 <shiona> :D
15:51:58 <AlainODea> benzrf: Vim is also great
15:51:59 <benzrf> builds your project, edits your code, does your IRC, etc
15:52:06 <benzrf> vim is an editor.
15:52:08 <bernalex> benzrf: at least take it to #haskell-blah
15:52:10 <benzrf> and it is AMAZING at being an editor
15:52:21 <JordanL> please no, i wont be responsible an editor-war
15:52:22 <bernalex> benzrf: or, preferably, stfu. editor wars are a bit old by now.
15:52:28 <benzrf> vim is awesome at manipulating text, emacs is awesome at being practically sentient
15:52:36 <quchen> Will you stop it, sir?
15:52:39 <bernalex>  /kick pls
15:52:41 <benzrf> that was my final word
15:52:45 <benzrf> fwiw i use vim
15:52:50 <bernalex> thank you.
15:53:49 <shiona> I chose to use nano for five years because I wanted to stay out of the editor war
15:54:03 <JordanL> could someone help me set up Vim?
15:54:07 <twiceler> I got made fun of for using gedit (just the standard Ubuntu text editor)
15:54:08 <JordanL> I've installed it
15:54:20 <shiona> JordanL: I would recommend you check some vim specific channel
15:54:27 <JordanL> ok
15:54:28 <JordanL> Thanks
15:54:39 <shiona> agh
15:54:41 <navaati> is Text more easily appendable than lists ?
15:54:49 <benzrf> shiona: christ
15:55:15 <mateioprea> @pl f x y z = x + y + 2 * z
15:55:15 <lambdabot> f = flip flip (2 *) . (((.) . (+)) .) . (+)
15:55:23 <aristid> navaati: strict text, no
15:55:24 <nisstyre> navaati: Text can be appended asymptotically quicker afaik, although snoc lists have constant time append
15:55:32 <benzrf> snoc?
15:55:37 <nisstyre> yes, a reversed list
15:55:42 <benzrf> oh i see hah
15:55:45 <benzrf> cute name
15:55:47 <aristid> nisstyre: i thought strict text is just a contiguous array?
15:55:55 <nisstyre> aristid: I might be wrong, idk
15:56:09 <Earnestly> You'd still need to find the end of the list
15:56:10 <quchen> Text probably has a better fusion framework anyway.
15:56:34 <bernalex> shiona: you scared him away! I think we should at least help out with haskell-plugin questions here. although I know some might disagree.
15:56:55 <bernalex> I mean, considering we have the haskellmode and vim2hs authors here...
15:56:55 <nisstyre> hmm actually the snoc list append would still be expensive I guess
15:57:08 <nisstyre> unless you're only appending a few elements
15:57:19 <navaati> i'm wondering about wether using a monad writer or simply returning strings and composing them...
15:57:40 <quchen> Writer with String has *very* poor performance.
15:57:47 <aristid> nisstyre: yes i checked, strict text is an array of utf-16 elements
15:57:54 <Earnestly> Ew :<
15:57:58 <navaati> so, yeah, if using a writer i need a good datatype
15:58:14 <aristid> lazy text however, should have fast appending
15:58:20 <nisstyre> aristid: okay, it's still faster obviously though
15:58:28 <nisstyre> just not asymptotically faster I guess?
15:58:51 <navaati> or i could build a writer that does just putstr... perfs would be good, eh ?
15:58:52 <aristid> nisstyre: it's probably significantly faster
15:58:57 <aristid> in the case of lazy text
15:59:03 <aristid> compared to lists, that is
15:59:15 <quchen> If you want to build up text, String is most likely the wrong type anyway.
15:59:22 <quchen> That's precisely what Text is for.
15:59:32 <nisstyre> yeah, although tbh I think navaati may have been asking more how easy it is to append them with library functions
15:59:59 <nisstyre> and the answer is that both are very easy
16:00:01 <shiona> bernalex: I know and I'm sorry for that
16:00:15 <navaati> oh, no, i was mre asking about perfs/"naturalness for the computer"
16:00:18 <mgsloan> The best thing to use is Data.Text.Lazy.Builder.  However, if you've already got a [Text], it's actually faster just to use strict concat
16:00:27 <navaati> s/mre/more/
16:00:31 <shiona> I just spent a few minutes giving him a heads up on the plugins and telling my very subjective opinions on which to get
16:01:00 <navaati> mgsloan: ah, interesting
16:02:14 <maxiepoo> hey quickCheck question
16:02:20 <maxiepoo> if I know a counterexample to a prop
16:02:22 <mgsloan> navaati: If you're using a writer, then lazy text builder is perfect, since it's already a monoid
16:02:23 <derdon> haskell let's me write code like this: fourtytwo = four `times` ten `plus` two :)
16:02:39 <maxiepoo> can I get quickCheck to try shrinking that?
16:02:51 <maxiepoo> as if it had found the counterexample itself
16:03:39 <quchen> maxiepoo: You can call `shrink` manually
16:03:43 <quchen> > shrink [Just 3, Nothing]
16:03:44 <lambdabot>  [[],[Nothing],[Just 3],[Nothing,Nothing],[Just 0,Nothing],[Just 2,Nothing]]
16:03:50 <maxiepoo> yeah I know
16:04:05 <maxiepoo> but I want it to keep testing the prop and search for a smallest counterexample
16:04:18 <quchen> Doesn't it do that automatically?
16:04:25 <maxiepoo> right
16:04:32 <maxiepoo> but I can't get it to generate a counterexample
16:04:35 <maxiepoo> but I have one
16:04:45 <maxiepoo> I just want to use the quickCheck infrastructure to shrink it
16:05:31 <maxiepoo> oh I can probably just make a generator that always returns my counterexample
16:05:38 <maxiepoo> though that's still kinda annoying
16:06:50 <quchen> maxiepoo: This may be what you're looking for then: http://hackage.haskell.org/package/QuickCheck-2.6/docs/Test-QuickCheck-Property.html#v:shrinking
16:06:52 <navaati> mgsloan: what is the difference between using the builder and just composing peces of text ?
16:07:06 <quchen> maxiepoo: I just looked through the docs though, so I'm not sure about it.
16:08:00 <shiona> well, I tried to ask him back here, but it seems he's not interested :/
16:08:28 <navaati> is is just some sort of "it keeps the individual pieces of text without allocating the intermediate composiions" like (warning impure language example) a StringBuilder in Java ?
16:08:36 <shiona> We have an idiom "the frost will drive the pig home", I believe that will hold here
16:08:46 <navaati> and wouldn't a lazy Text do that anyway ?
16:09:06 <navaati> (since it's lazy)
16:09:41 <mgsloan> navaati: Right, I think with lazy text, appending multiple chars will be in separate buffers
16:10:05 <mgsloan> navaati: Not 100% sure though
16:10:20 <maxiepoo> quchen: nah that's if I want to override the shrink function.
16:11:24 <mgsloan> E.g. if you did (singleton 'a' <> singleton 'b' <> mempty), I think a and b would end up in separate buffers
16:12:32 <navaati> ah, i see, the lazy text, unevaluated, would contain the pieces of text like the string builder (in the thunks) but as the evaluation goes it would still allocate the intermediaries half-composed texts
16:13:13 <mgsloan> Yup!
16:13:16 <navaati> while the builder would directly allocate the whole result
16:13:51 <mgsloan> I think builder allocates it in 128 byte chunks or something like that, so both small and big appends are efficient
16:14:30 <navaati> now i only need to choose between using a writer with the builder or using a writer that directly does io to stdout
16:14:34 <navaati> hum....
16:15:05 <mgsloan> What's the purpose of delaying the output?
16:15:17 <mgsloan> Is it because you're not in the IO monad?
16:15:34 <navaati> well that't the point : i am
16:17:41 <maxiepoo> quchen: actually that works!
16:17:54 <quchen> maxiepoo: It does? Cool. :-)
16:18:01 <maxiepoo> wait
16:18:17 <maxiepoo> now it's not printing the shrunk counterexample
16:19:01 <quchen> are you using forAll? I think that doesn't shrink
16:19:10 <maxiepoo> no it says
16:19:18 <maxiepoo> *** Failed! Falsifiable (after 1 test and 10 shrinks):
16:19:21 <mgsloan> navaati: Well, in that case it seems quite reasonable to just use putStr, preferably the one from Data.Text.IO.  Although, if you're just using "pack" before that, there's not much point to that
16:19:22 <maxiepoo> and then nothing
16:19:33 <quchen> Eh wait, forAll shrinks, but forAllShrink lets you use your own shrinking function.
16:20:21 <quchen> Hm, is that how it displays the empty string maybe?
16:21:09 <maxiepoo> the property returns True for the empty string
16:21:44 <quchen> There are also some functions that perform an IO action for failing properties. I think you can use one of them to trace the shrinking process.
16:23:40 <maxiepoo> oh I bet it's some non-printable character
16:23:48 <maxiepoo> blergh
16:23:56 <maxiepoo> how do I get the value of a result?
16:25:35 <quchen> maxiepoo: This lets you add a callback function for tests: http://hackage.haskell.org/package/QuickCheck-2.6/docs/Test-QuickCheck-Property.html#v:callback
16:25:39 <quchen> See also the Callback type
16:29:21 <maxiepoo> but
16:29:31 <maxiepoo> there's no way to get your hands on the value?
16:33:20 <eskatrem> hi, I need some help to install the package haskell-src-exts. It says it fails to get a version of happy >= 1.17, while I just installed the version 1.19
16:33:26 <quchen> maxiepoo: Not sure :-\
16:33:36 <maxiepoo> it doesn't look like it
16:33:43 <maxiepoo> thanks for your help though
16:33:53 <maxiepoo> I'm going to just wire something up myself using shrink
16:35:51 <countoren_> hi everyone, im building a yesod app and i want to make my homepage(only my homepage) with deferent default layout then the rest of the site what is the best way to do this??
16:41:28 <joelteon> I need to come up with a good type synonym name for m () -> IO ()
16:41:30 <joelteon> what should I call it?
16:41:52 <quchen> liftIO'?
16:41:53 <bennofs> embed?
16:42:16 <bennofs> or runInIO ?
16:42:22 <quchen> ioify?
16:42:45 <quchen> Oh, type synonym.
16:42:46 <quchen> IOLike?
16:44:25 <aristid> Peaker: how close is lamdu to being able to make a screencast? :)
16:45:21 <mgsloan> countoren_: You can have the handler for your homepage return Html.  One convenient function for doing that is "giveUrlRenderer" - if you're using shakespearean templates
16:45:49 <Feuerbach> eskatrem: make sure happy is in your $PATH
16:47:46 <countoren_> mgsloan: ye the thing is that i declare all my js dependancies in the default layout wrapper , and i dont want to have to redaclre them
16:48:03 <eskatrem> Feuerbach: ok, I'll try that
16:48:09 <Peaker> k00mi, aristid: Heh, saw it on HN (actually clicked it by accident when I meant to click something else and had a wat moment, how did I end up on lamdu's page??) :)
16:48:28 <Peaker> aristid: we don't want mass advertising yet -- we'd postpone the HN post if we could :)
16:48:42 <mgsloan> countoren_: You can put that part of your default layout wrapper in a separate function, and use it in your homepage handler
16:48:48 <aristid> Peaker: well it's done :)
16:49:04 <Peaker> well without a video discussion will die down quickly :)
16:49:53 <Peaker> I have a rewrite I wanna do to the lamdu website there, too
16:50:06 <Peaker> to better organize it
16:50:12 <countoren_> mgsloan: basicly i want all defualt layout warpper, well i guess i should just widgetFile on it
16:53:12 <mgsloan> countoren_: Yep, that sounds about right
16:53:38 <countoren_> mgsloan: thanks man ill try it.
16:53:56 <mgsloan> welcome!
16:56:03 <eskatrem> Feuerbach: still failing after I added ~/.cabal/bin to my PATH
16:57:03 <k00mi> Peaker: do you plan to use GHC in lamdu or will you roll your own compiler?
16:57:29 <Feuerbach> eskatrem: can you lpaste the output of `cabal install -v haskell-src-exts`?
16:57:29 <Peaker> k00mi: will start with an existing compiler, probably, but possibly do our own interpreter
16:58:04 <Peaker> k00mi: our type inference efforts are becoming a big struggle, to the point where we might compromise and use an existing type system (despite none of them being exactly what we want)
16:58:15 <Peaker> k00mi: now having performance troubles in our type inference/checking
16:58:49 <k00mi> I see, seems reasonable :)
16:59:47 <Peaker> we might need to have a tiny compiler of our own to adjust our own dialect to Haskell or some other pure FP
16:59:56 <Peaker> (we're close enough that that should be easy)
17:00:46 <eskatrem> Feuerbach: http://pastebin.com/7pfGscvj
17:00:47 <mauke> The paste 7pfGscvj has been copied to http://lpaste.net/97536
17:03:57 <k00mi> Peaker: just don't spend the rest of you days designing/implementing that language :P
17:04:16 <Peaker> k00mi: heh, I'm already frustrated with the amount of time we've spent as it is
17:04:32 <Feuerbach> eskatrem: so, do you have happy in ~/.cabal/bin?
17:05:09 <eskatrem> Feuerbach: yes!
17:05:26 <Feuerbach> hmm
17:06:02 <Feuerbach> what if you also supply --with-happy=$HOME/.cabal/bin/happy ?
17:06:11 <eskatrem> and I added ~/.cabal/bin in my PATH as well
17:06:22 <eskatrem> mbassett: hi
17:06:38 <eskatrem> mbassett: are you working at Universal?
17:06:43 <mbassett> hullo
17:06:45 <mbassett> nope
17:06:46 <mbassett> sorry
17:07:30 <mbassett> actually, I'm curious: what does GHC do when malloc() fails?
17:07:41 <eskatrem> mbassett: it was another mbassett then... sorry
17:07:46 <benzrf|afk> Peaker: how many people are working on lamdu?
17:07:56 <mbassett> eskatrem: I had no idea there were so many :P
17:08:08 <k00mi> Peaker: anyways, exiting project, maybe I will be able to spend some time on it myself
17:08:14 <Feuerbach> mbassett: throws an exception, I think
17:08:16 <Ralith> mbassett: malloc usually doesn't fail; instead, access to overallocated memory faults
17:08:43 <Peaker> k00mi: that would be awesome :)
17:08:46 <Feuerbach> HeapOverflow it is
17:08:50 <Peaker> benzrf: Just 2 of us (hoping more would contribute)
17:09:17 <benmachine> Ralith: ulimit causes malloc to fail, I think
17:09:19 <benzrf> Feuerbach: wow i just realized that i associate stackoverflow with the website so much that I actually forgot it was an error for a second there
17:09:22 <benmachine> which isn't /so/ uncommon
17:09:25 <eskatrem> Feuerbach: it *seems* to be working
17:09:28 <benzrf> Peaker: I totally would if I didn't suck at haskell :D
17:09:51 <mbassett> benmachine: I guess I could try it then!
17:10:04 <Peaker> benzrf: well, getting good at Haskell is much faster when you code stuff up :)
17:10:33 <mbassett> thanks
17:12:13 <maxiepoo> > import Text.Blaze.Html5
17:12:14 <lambdabot>  <hint>:1:1: parse error on input `import'
17:12:21 <eskatrem> Feuerbach: thank you, it worked
17:12:28 <maxiepoo> lambdabot: why u no import
17:12:41 <benzrf> maxiepoo: :-D
17:13:11 <maxiepoo> I've totally seen people do lens stuff on here is that just imported by default?
17:13:16 <maxiepoo> :t (<$>)
17:13:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:13:23 <maxiepoo> :t toHtml
17:13:23 <lambdabot> Not in scope: `toHtml'
17:13:40 <Axman6> lambdabot /= ghci
17:14:32 <benzrf> Axman6: sald
17:14:33 <benzrf> *sadly
17:15:16 <maxiepoo> :module Text.Blaze.Html5
17:15:17 <mgsloan> Peaker: Have you considered targetting a problem like "structure editor + semantic versioning for Haskell"?  I love the grand vision, but it seems like a lot to tackle at once
17:16:35 <Peaker> mgsloan: yeah, but we hope to achieve the benefits of that with interoperability (e.g: reasonable import/export to Haskell)
17:16:55 <mgsloan> Ahh gotcha, excellent!
17:16:57 <bennofs> With better editors, why can't you just depend on the exported items directly rather than one a whole package?
17:17:27 <mgsloan> I guess I mean refining the structural part of it by being able to use it on existing Haskell code
17:17:38 <mgsloan> Using lamdu to hack on lamdu, and the like
17:17:50 <Peaker> mgsloan: we're really preliminary anyway -- we can throw away/replace the dialect we're using 3 times in the next few years :)   Much of the work is the revision control, the UI, etc
17:18:04 <Peaker> well, we definitely mean to use lamdu to hack on lamdu :)
17:18:19 <enthropy> there's no pointfree in lamdu... but there's a straightforward translation usually?
17:18:39 <Peaker> enthropy: what do you mean?
17:19:15 <benzrf> @pl \f s l1 l2 -> foldl (uncurry f) s (zip l1 l2)
17:19:15 <lambdabot> flip flip zip . (((.) . (.)) .) . foldl . uncurry
17:19:20 <nstdloop_> So I've been reading about fix. I sort of get what it does, but... what's the point?
17:19:20 <benzrf> D:<
17:19:23 <enthropy> my understanding was that in lamdu I have to write   map (\x -> f y x) xs
17:19:34 <enthropy> instead of `map (f y) xs'
17:19:50 <nstdloop_> Like how does fix, even on convergent results, figure out when to stop applying the function?
17:19:53 <Cale> nstdloop_: The point is that if your language didn't have recursive definitions, but it did have fix, you could implement all your recursion through fia
17:19:55 <Cale> fix*
17:19:55 <Peaker> enthropy: nope, we intend to have concise partial application like in Haskell, but not via currying
17:20:04 <benzrf> nstdloop_:
17:20:05 <benzrf> @src fix
17:20:05 <lambdabot> fix f = let x = f x in x
17:20:19 <Axman6> it never stops
17:20:20 <Peaker> nstdloop_: point-free recursions
17:20:20 <nstdloop_> Cale: but since we do, do we really need it?
17:20:23 <aristid> Peaker: your kv-db.. i saw that it lists changing the size of the hash table as a future non-implemented feature; why is that something you don't need, do you just always make the tables big from the beginning?
17:20:25 <nstdloop_> When is it actually useufl
17:20:27 <Axman6> but output can be created even without it stopping
17:20:28 * enthropy didn't do much with it... the opengl thing grabs the keyboard directly which doesn't respect the remapping X does for me
17:20:33 <mgsloan> Peaker: Cool!  I'm sure that more people will jump on board once all the base functionality is in place
17:20:35 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
17:20:36 <Axman6> > fix (1:)
17:20:37 <lambdabot>  can't find file: L.hs
17:20:37 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:20:40 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
17:20:41 <lambdabot>  3628800
17:20:48 <Peaker> aristid: that was just a temp hack until we had a k/v store that's not a nightmare to install available
17:21:00 <Peaker> aristid: I just changed it to use sophia, for which I wrote bindings, and I hope it's a good db
17:21:03 <aristid> > fix ((1:) . fmap (+1))
17:21:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:21:18 <aristid> Peaker: oh
17:21:19 <Cale> nstdloop_: It applies the function once to the value which is the result of applying the function :)
17:21:21 <Peaker> aristid: and yeah, we generally do a "lamdu -deletedb" frequently at this point, it's still a toy
17:21:30 <Peaker> mgsloan: :)
17:21:32 <aristid> Peaker: never heard of sophia
17:21:46 <Cale> nstdloop_: fix f = x where x = f x
17:21:54 <Cale> (that's the efficient version, anyway)
17:21:58 <nstdloop_> Ok
17:22:07 <nstdloop_> How does that work to define the factorial function
17:22:13 <eskatrem> Hey, when trying to install Lamdu, I got this error: Lamdu/Data/Expression/Infer.hs:445:5:
17:22:13 <eskatrem>     Not in scope: `Map.traverseWithKey'
17:22:22 <Peaker> aristid: it was on reddit/HN with claims of benchmarking faster than leveldb (no idea how meaningful that is) and seemed like a simple API, so I wrote an embedded binding that's "cabal installable" with no dep. hell
17:22:24 <nstdloop_> It's very... weird.
17:22:26 <Axman6> what's lamdu?
17:22:30 <quchen> > fix (const 3) -- Axman6: fix can stop.
17:22:31 <lambdabot>  3
17:22:33 <Peaker> nstdloop_: imagine "fix" was called "recursively"
17:22:40 <aristid> Peaker: ah so you just embed the C code in the cabal package too?
17:22:48 <Peaker> Axman6: http://peaker.github.io/lamdu/
17:22:49 <Cale> Well, fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) = f where f = (\fac n -> if n == 0 then 1 else n * fac (n-1)) f
17:22:51 <nstdloop_> like fix f = f (fix f)?
17:22:53 <Peaker> aristid: yeah, like GLFW-b
17:23:01 <nstdloop_> oooh
17:23:03 <Cale> and then if we simplify the definition of f there
17:23:25 <nstdloop_> it just passes the function as the first argument to fac and it resolves
17:23:27 <Cale> f = \n -> if n == 0 then 1 else n * f (n-1)
17:23:35 <nstdloop_> well not to fac but to the lambda
17:23:39 <Cale> yeah
17:23:41 <Peaker> nstdloop_: if it was called "recursively", then:   fac = recursively $ \rec n -> if n == 0 then 1 else n * rec (n-1)
17:23:57 <Peaker> I like "recursively" much better than "fix" :)
17:24:05 <nstdloop_> When would you actually ever use this?
17:24:09 <benzrf> it's called 'fix' because it computes the fix point tho
17:24:12 <Cale> The fac parameter is really going to be supplied with the factorial function
17:24:23 <Axman6> fixed point no?
17:24:28 <benmachine> nstdloop_: so, one answer is we don't actually use fix that often
17:24:30 <k00mi> nstdloop_: never in real code
17:24:32 <Peaker> also:   foo = recursively go     where go loop x y z = ... loop here ...
17:24:40 <cwraith> nstdloop_: it's never necessary. Sometimes it makes code slightly cleaner
17:24:48 <Cale> Well, in actual Haskell code? It's somewhat nice occasionally in IO code to write loops
17:24:48 <zRecursive> (f (f (f ...)))
17:24:56 <benmachine> nstdloop_: another is "anonymous recursion"; just like you can use lambdas instead of function bindings, you can use fix instead of recursive bindings
17:25:00 <c_wraith> I like fix :: (IO a -> IO a) -> IO a
17:25:01 <Axman6> > fix f
17:25:02 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
17:25:03 <lambdabot>    arising from a use of `e_1'
17:25:03 <lambdabot>  The type variable `a0' is ambiguous
17:25:03 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
17:25:03 <lambdabot>  Note: there are several potential instances:
17:25:04 <Peaker> If Haskell disallowed recursions and everyone used "recursively" it could have some nice benefits
17:25:17 <startling> > fix f :: Expr
17:25:18 <Cale> fix $ \loop -> do ... ; when condition loop
17:25:18 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
17:25:25 <Peaker> Like many fewer accidental recursions
17:25:27 <Cale> Things like that
17:25:39 <nstdloop_> I see.
17:26:03 <nstdloop_> But for the most part, really, it's not used.
17:26:14 <Cale> Yeah, it's more of theoretical interest than anything
17:26:15 <benmachine> I think I use Cale's pattern a reasonable amount
17:26:18 <Axman6> I'm sure there are some people who use it
17:26:26 <benmachine> rarely, but certainly not never
17:26:29 <Cale> Also, code golfing
17:26:40 <twiceler> Peaker: Totally agreed! So often I'll do something like define > x + y = x + y in a Num instance, but of course I didn't mean that! But instead my code just doesn't terminate...
17:26:43 <Cale> > fix ((0:) . scanl (+) 1)
17:26:44 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:27:40 <zRecursive> :t scanl
17:27:41 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
17:27:46 <Peaker> twiceler: yeah, accidental recursions are really annoying -- and Haskell has crappy runtime debugging so hard to investigate too
17:27:55 <Cale> > scanl (+) 0 [1..10]
17:27:56 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
17:28:05 <Peaker> I had a bad Ord instance defined (Yay minimal instances fixing that!)  causing an infinite loop I wasted hours on
17:28:18 <startling> ouch.
17:28:50 <Cale> > scanl (\x y -> concat ["(f ", show x, " ", y, ")"]) "z" [1..5]
17:28:51 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
17:28:51 <lambdabot>    arising from the literal `1'
17:28:51 <lambdabot>  Possible fix:
17:28:51 <lambdabot>    add an instance declaration for (GHC.Num.Num [GHC.Types.Char])No instance ...
17:28:51 <lambdabot>    arising from the arithmetic sequence `1 .. 5'
17:28:53 <twiceler> Peaker: Yep! I actually just learned about the -xc thing to print a stack trace; I imagine that could help debug such things?
17:28:56 <Peaker> nice to find all recursions/corecursions by searching for "recursively"
17:29:00 <Peaker> twiceler: sometimes..
17:29:06 <Cale> > scanl (\x y -> concat ["(f ", x, " ", show y, ")"]) "z" [1..5]
17:29:07 <lambdabot>  ["z","(f z 1)","(f (f z 1) 2)","(f (f (f z 1) 2) 3)","(f (f (f (f z 1) 2) 3)...
17:29:10 <Cale> right :)
17:29:26 <Peaker> twiceler: -xc prints even caught exceptions which may flood, and mysteriously sometimes the culprit isn't there
17:29:30 <benmachine> > scanl f z [1 .. 5] :: Expr
17:29:31 <lambdabot>  Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
17:29:31 <lambdabot>              with actual type `[Debug.SimpleReflect.Expr.Expr]'
17:29:35 <benmachine> oh whatevs
17:29:50 <Cale> > scanl (f :: Expr -> Expr -> Expr) z [1..5]
17:29:52 <lambdabot>  [z,f z 1,f (f z 1) 2,f (f (f z 1) 2) 3,f (f (f (f z 1) 2) 3) 4,f (f (f (f (f...
17:33:11 <aristid> Peaker: what's the basic data model for lamdu's version control?
17:33:43 <maxiepoo> anyone here use Blaze.Html a lot?
17:33:55 <twirlobite> how can i improve this short haskell program? http://lpaste.net/97537
17:34:00 <startling> maxiepoo, go ahead and ask your question.
17:34:15 <startling> I use it occasionally and I'm sure others here do too.
17:34:33 <maxiepoo> yeah I'm going to get a minimal example
17:34:43 <Peaker> aristid: we have a layered key/value store. On top of a "real" k/v store, there's a versioned one. Each version is a set of keys that changed (added, modified, deleted).  Lamdu serializes code onto the upper key/value store
17:35:13 <dario`> twirlobite: well, "if (length mA == 1) then True else False" is the same as "length mA == 1"
17:35:57 <twirlobite> dario`: haha, yes, just noticed
17:35:58 <benzrf> @hoogle k -> Maybe a -> Map k a -> Map k a
17:35:59 <lambdabot> Data.Map.Lazy insert :: Ord k => k -> a -> Map k a -> Map k a
17:35:59 <lambdabot> Data.Map.Strict insert :: Ord k => k -> a -> Map k a -> Map k a
17:35:59 <lambdabot> Data.Map.Lazy insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
17:36:02 <maxiepoo> I'm using the script tag for some generated javascript
17:36:11 <henk> Any suggestions how to get from a 'ZonedTime' (as in Data.Time.LocalTime) to a 'ZonedTime' with the same 'Day' but with 'TimeOfDay' being 00:00:00 (i.e. 'midnight')?
17:36:14 <maxiepoo> and the js has html strings in it
17:36:14 <Peaker> aristid: there's a "view" that is a snapshot at a particular version. Moving around between versions applies/unapplies on the view
17:36:18 <benzrf> dario`: also those parens are unnecessary
17:36:29 <aristid> Peaker: and the key to the lower one is (upperKey,version)?
17:36:38 <maxiepoo> and Blaze silently fails (sort of)
17:36:53 <maxiepoo> renderHtml . script . toHtml $ "\"</\""
17:37:08 <aristid> Peaker: snapshots are read-only i assume?
17:37:11 <maxiepoo> outputs
17:37:17 <maxiepoo> "<script></script>"
17:37:21 <Peaker> aristid: the "view" is, sort of.  key to the lower one is   (upperKey, view-id) (iirc)
17:37:33 <twirlobite> how can i get the code warnings that lpaste gives me in leksah?
17:37:34 <maxiepoo> even though it's valid Html
17:37:43 <Peaker> aristid: but the version graph is basically serialized into the lower k/v store too
17:37:55 <maxiepoo> took me a long time to figure out that was happening
17:38:31 <Peaker> aristid: each change in the code editor makes a "transaction" to change the upper one, which translates to a version creation, which creates a new key on the lower one, which is a child version with a reference to the parent version.  In conjunction the "view" is updated (it's essentially a cache)
17:38:40 <maxiepoo> 1. why isn't that an error instead of silent failover
17:38:59 <aristid> Peaker: ah so your versioning can be any kind of DAG like in git?
17:39:00 <maxiepoo> 2. how can I get it to not do that
17:39:15 <Peaker> aristid: yeah, but we don't have merges/multi-parents yet :)
17:39:33 <Peaker> aristid: the version control is only the most bare-bones thing that will let us support "undo/redo" and branch switching
17:39:59 <twirlobite> okay, improved now: http://lpaste.net/97538, how can i improve this?
17:40:15 <twirlobite> benzrf: how can i get the warnings that lpaste gives me in leksah?
17:40:35 <c_wraith> twirlobite: those warnings come from hlint
17:40:45 <twirlobite> c_wraith: ahh
17:40:49 <Peaker> twirlobite: you can use guards instead of if/then/else
17:40:54 <benzrf> twirlobite: what's leshak
17:40:56 <benzrf> *leskah
17:41:05 <benzrf> some kind of IDE?
17:41:18 <c_wraith> leksah.  spell it backwards.  and add an l
17:41:18 <twirlobite> yeah
17:41:25 <geekosaur> a Haskell IDE written in gtk2hs
17:41:29 <Peaker> twirlobite: and equalMBunchElems requires non-empty lists, and would crash with empty ones
17:41:30 <twirlobite> benzrf: what ide do you use?
17:41:33 <benzrf> i just use vim
17:41:35 <benzrf> no ides
17:41:49 <Peaker> twirlobite: so it'd be much nicer to inline it into emMap
17:41:52 <benzrf> i should probably use something else
17:41:56 <bennofs> I think those are from hlint
17:41:58 <benzrf> or maybe get some pluginz
17:42:10 <twirlobite> Peaker: right
17:42:36 <Peaker> twirlobite: em_map is not a typo?
17:42:41 <Peaker> is it supposed to be emMap?
17:43:14 <twirlobite> Peaker: yes it is
17:43:35 <Peaker> twirlobite: you seem to be using strings-of-1 instead of just using Char?
17:43:44 <twirlobite> Peaker: mainly, i was thinking about how i count through the list 4 times, but i don't really need to
17:43:48 <Peaker> twirlobite: Haskell is about good static types
17:44:05 <Peaker> twirlobite: Use a precise type like Char if that's what you have, and not a vague type like "String" where you always just take "head" unsafely
17:44:21 <Peaker> twirlobite: yes, you can do a 1-pass count instead
17:44:23 <twirlobite> Peaker: yes, i designed a little theory called "multibunches", preferably MBunch would have type = [a], but that was giving me an error...
17:46:44 <Peaker> twirlobite: why String, btw? Is this for DNA nucleotides?
17:47:03 <Peaker> twirlobite: data Nucleotide = A | G | T | C
17:47:35 <Peaker> twirlobite: emCounts :: [Nucleotide] -> Map Nucleotide Int  ?
17:48:44 <twirlobite> Peaker: yes, nucleotides
17:49:12 <Peaker> twirlobite: use precise types that constraint the program as much as possible to the exact data that is legal
17:49:22 <Peaker> twirlobite: "String" allows non-sense that is illegal
17:49:37 <Peaker> twirlobite: [Nucleotide] guarantees a legal sequence
17:49:46 <twirlobite> Peaker: sounds good, let me rewrite things, and then i'll give it to you again for criticism
17:50:49 <maxiepoo> does anyone know a way around this behavior: http://lpaste.net/97544
17:54:18 <derdon_> the Python package itertools has ifilterfalse but Haskell has no filterfalse?! raaaaage
17:54:51 <enthropy> is that like    \f -> filter (not . f) ?
17:55:00 <startling> filter id ?
17:55:04 <startling> oh, I see
17:55:21 <derdon_> enthropy: yes
17:56:06 <startling> derdon_, in Haskell you would probably write "filter (not . f)"
17:56:22 <derdon_> ``readNat s | (null . filter (not . isDigit)) s = error errmsg``
17:56:37 <derdon_> hmmm, looks too complicated
17:57:10 <derdon_> meaning: "error if there is a non-digit in s"
17:57:15 <aristid> :t any
17:57:16 <lambdabot> (a -> Bool) -> [a] -> Bool
17:57:20 <derdon_> ah, yes. thanks
17:57:32 <derdon_> that's much better
17:57:51 <Peaker> derdon_: composability means we don't have to pollute the namespace with thousands of hard-coded prebaked compositions :)
17:57:54 <aristid> actually you want all
17:57:59 <Peaker> (for trivial compositions)
17:58:02 <aristid> :t all isDigit
17:58:03 <lambdabot> [Char] -> Bool
17:58:23 <Peaker> readNat s | all isDigit = .. good stuff .. | otherwise = error "bad stuff"
17:58:34 <maxiepoo> :t foldMap isDigit
17:58:35 <lambdabot>     Could not deduce (Monoid Bool) arising from a use of `foldMap'
17:58:35 <lambdabot>     from the context (Foldable t)
17:58:35 <lambdabot>       bound by the inferred type of it :: Foldable t => t Char -> Bool
17:58:48 <maxiepoo> :t foldMap (All . isDigit)
17:58:49 <lambdabot> Foldable t => t Char -> All
17:58:58 <maxiepoo> :t runAll
17:58:59 <lambdabot> Not in scope: `runAll'
17:59:02 <derdon_> Peaker: thank you, even better!
17:59:04 <bennofs> :t getAll
17:59:04 <aristid> :t getAll
17:59:05 <lambdabot> All -> Bool
17:59:05 <lambdabot> All -> Bool
17:59:16 <maxiepoo> :t getAll . foldMap (All . isDigit)
17:59:17 <lambdabot> Foldable t => t Char -> Bool
17:59:25 <aristid> maxiepoo: sounds like a pretty convoluted method ;)
17:59:27 <bennofs> :t ala all foldMap isDigit
17:59:28 <maxiepoo> sometimes type classes are annoying
17:59:28 <lambdabot>     Couldn't match type `Bool' with `a0 -> Bool'
17:59:28 <lambdabot>     Expected type: Char -> a0 -> Bool
17:59:28 <lambdabot>       Actual type: Char -> Bool
17:59:33 <bennofs> :t ala All foldMap isDigit
17:59:34 <lambdabot>     No instance for (Foldable ((->) Char))
17:59:34 <lambdabot>       arising from a use of `foldMap'
17:59:34 <lambdabot>     Possible fix:
17:59:59 <bennofs> :t alaf All foldMap isDigit
18:00:00 <lambdabot> Foldable t => t Char -> Bool
18:00:08 <maxiepoo> :t alaf
18:00:09 <lambdabot> Wrapped s s a a => (s -> a) -> ((r -> a) -> e -> a) -> (r -> s) -> e -> s
18:00:14 <maxiepoo> oh lord
18:00:22 <maxiepoo> :t alaf All
18:00:24 <lambdabot> ((r -> All) -> e -> All) -> (r -> Bool) -> e -> Bool
18:00:55 <maxiepoo> it would be nicer with value-level monoids
18:01:28 <startling> "value-level monoids"?
18:01:38 <twirlobite> Peaker: since character frequency calculation is so common, wouldn't it better to make a general function for that purpose rather than making it specific to nucleotides...?
18:02:03 <Peaker> twirlobite: yes, for any Eq type, not just "characters"
18:02:04 <maxiepoo> like in this http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
18:02:21 <bennofs> But ord allows for a more efficient implementation
18:02:24 <Peaker> twirlobite: If stored in a Map, then it needs to be Ord
18:02:48 <twirlobite> Peaker: are you familiar with formal program derivation?
18:03:11 <Peaker> twirlobite: maybe, I'm not sure, can you elaborate? :)
18:03:29 <twirlobite> Peaker: think, dijkstra, tony hoare, richard bird...
18:03:41 <Peaker> ah, don't think so
18:03:46 <twirlobite> hmm
18:03:49 <twirlobite> darn
18:04:27 <Peaker> @type M.unionsWith (+) . map (`M.singleton` 1)
18:04:28 <lambdabot> (Num a, Ord k) => [k] -> M.Map k a
18:04:52 <Peaker> twirlobite: here's a general counter for lists of ordinal keys
18:04:54 <benzrf> @djinn Map k a -> a
18:04:55 <lambdabot> Error: Undefined type Map
18:05:02 <benzrf> hm
18:05:06 <Peaker> benzrf: empty maps?
18:05:44 <twirlobite> Peaker: how do i learn how to come up with that myself....
18:06:39 <Peaker> twirlobite: you see a few use-cases of the Data.Map API and learn common patterns.. unionsWith, fromListWith are useful and once you see an example or two of those you'll probably know when they can be used next
18:06:47 <maxiepoo> oh if anyone was wondering I fixed my problem by using `preEscapedToMarkup` from Text.Blaze
18:07:00 <twirlobite> Peaker: also, remember how we were talking about only needing to make 1 pass? in order to reason about 1 pass vs. 4 passes...don't we kind of need to get..."imperative" with our thoughts>?
18:07:24 <Peaker> twirlobite: the code above with the unionsWith is 1-pass, and not imperative at all
18:07:33 <aristid> :t M.fromListWith
18:07:34 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
18:07:46 <Peaker> :t M.unionsWith
18:07:47 <lambdabot> Ord k => (a -> a -> a) -> [M.Map k a] -> M.Map k a
18:08:19 <twirlobite> Peaker: oh no no, i understand that, i mean with the stuff that i posted before...i "knew" it was making 4 passes, but only because i was (wrongly) thinking of it with my imperative intuition...how could you justify that sort of optimization functionally?
18:08:41 <aristid> Peaker: is the unionsWith there more efficient than the equivalent fromListWith code?
18:09:00 <aristid> :t M.fromListWith (+) . map (,1)
18:09:01 <lambdabot> (Num a, Ord k) => [k] -> M.Map k a
18:09:14 <Peaker> aristid: no idea, that came up to mind first :)
18:09:35 <derdon_> is there already a function for (not . null) ?
18:09:40 <Peaker> twirlobite: the operational semantics of Haskell programs are somewhat imperative, and you have to understand them for efficiency considerations, if that's what you mean
18:10:03 <twirlobite> Peaker: yes...alright, that sounds good then.
18:10:13 <aristid> derdon_: sadly not, but i suspect that you may have another case where it's not actually needed, like last time :)
18:10:27 <startling> derdon_: no.
18:10:27 <Peaker> twirlobite: you need to switch between two modes of thought: For correctness, you think "denotationally", about the meanings denoted by the syntax and how they compose.  For efficiency, you think "operationally", about the order things evaluate, what's kept in memory, etc.
18:10:48 <twirlobite> hmm.
18:11:02 <startling> :t has _Cons [1, 2, 3]
18:11:03 <lambdabot> Bool
18:11:09 <startling> > has _Cons [1, 2, 3]
18:11:11 <lambdabot>  True
18:11:16 <startling> > has _Cons []
18:11:17 <lambdabot>  False
18:11:19 <aristid> startling: heh
18:11:30 <aristid> not really shorter than not.null, but i guess it requires less parens
18:11:33 <Peaker> twirlobite: Haskell makes the former especially great/easy. It makes the latter hard, though :)   Fortunately, programs must be correct all over, but fast only in a small part
18:11:59 <derdon_> startling: aristid: thx, but I think I stick to not.null
18:12:02 <Peaker> > [1,2] ^? _Cons
18:12:03 <startling> :)
18:12:03 <lambdabot>  Just (1,[2])
18:12:15 <aristid> derdon_: can you show your use case anyways?
18:12:26 <startling> not . null is probably the nicest way.
18:12:31 <Peaker> :t _Nil
18:12:32 <lambdabot> Not in scope: `_Nil'
18:13:01 <derdon_> aristid: "if all chars in s are digits and s is not an empty string, do ..."
18:13:06 <Peaker> (:) : Cons  <-->  [] : ???
18:13:06 <startling> sometimes I think we should have a (not .) function named in the Prelude.
18:13:19 <startling> :t _Null
18:13:20 <lambdabot> Not in scope: `_Null'
18:13:22 <aristid> derdon_: pattern match on []
18:13:30 <benzrf> :t has
18:13:30 <lambdabot> Getting Any s a -> s -> Bool
18:13:32 <Peaker> startling: perhaps Bool should be a type-class, and (a->Bool) should be an instance?
18:13:33 <aristid> foo [] = error "Empty string"
18:13:36 <derdon_> aristid: or better on ""
18:13:36 <benzrf> getting any?
18:13:38 <startling> Peaker: haha
18:13:42 <aristid> derdon_: same thing:)
18:13:52 <aristid> derdon_: it needs to be the first pattern of course
18:14:01 <startling> Peaker, Bool b => a -> b, rather
18:14:13 <Peaker> startling: what was funny? :)  I meant seriously: http://hackage.haskell.org/package/Boolean-0.2/docs/Data-Boolean-Overload.html
18:14:40 <startling> it's often hard to tell whether people are joking about overarchitecture here.
18:15:10 <Peaker> I don't know if it's a good idea but it's been seriously suggested :)
18:15:33 <Peaker> By conal, too!
18:15:41 <aristid> for pretty much any value type you can make a class out of it by making everything Applicative-like, no? :)
18:16:05 <derdon__> I was away for a moment, sorry. I blame my irc client
18:16:35 <derdon__> aristid: last thing I heard from you was "derdon_: it needs to be the first pattern of course"
18:16:44 <mgsloan> Hmm, but it doesn't have that type, the purpose of conal's stuff is mostly for deep embeddings
18:16:53 <aristid> derdon__: that was the last thing i said
18:16:54 <benzrf> i demand that all types in all signatures be replaced with typeclasses that are automatically gnerated when a type is declared
18:16:57 <startling> aristid: maybe with prismy typeclasses?
18:16:57 * benzrf bangs his fist on the table
18:17:04 <aristid> startling: ?
18:17:23 <derdon__> ok
18:17:31 <startling> you said "by making everything Applicative-like", but that doesn't give you a way to /create/ values.
18:17:34 <Taneb> Boolean is a library I think would have worked better for fundeps
18:17:39 <aristid> startling: pure
18:17:49 <startling> what.
18:18:06 <aristid> startling: you mean to get values out again? indeed not.
18:18:15 <aristid> startling: but that Bool typeclass doesn't do that either
18:18:23 <Taneb> aristid, you need a value to use pure to make a value?
18:18:29 <aristid> nor does the Num instance for (-> a)
18:18:34 <Taneb> (ignore me, I'm pretty much asleep)
18:19:22 <aristid> i think typeclasses whose sole contribution is lifting every operation applicatively mostly just indicate that we finally need applicative infix notation! :D
18:22:38 <derdon__> so can it be ok (regarding the style) to have patterns where the order matters?
18:22:51 <derdon__> I always thought that should be avoided
18:24:07 <aristid> derdon__: no it's ok, as long as it's not a counter-intuitive order
18:24:19 <derdon__> ah, good
18:31:17 <codygman> Anyone use haskell-mode and emacs? How do you get it to work with cabal (or virthualenv)?
18:38:22 <tippenei1> I'm curious why this is used with a let even though it's called right after defining. https://github.com/haskell/network/blob/master/Network/Socket.hsc#L416
18:40:20 <aristid> tippenei1: it would be hard for it to recurse otherwise
18:40:20 <aristid> see the EINTR handling part
18:41:37 <hoover291> how would one write a program that multiplies every number by every other number.....(then you have all the primes they're just every number that isn't there)
18:41:54 <tippenein> aristid: ah, thanks. I see it now
18:42:46 <startling> > zipWith (*) [1,2..] [1,2..] -- hoover291
18:42:47 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
18:42:55 <startling> oh, that's not right.
18:42:58 <twiceler> no
18:43:04 <startling> > liftA2 (*) [1,2..] [1,2..]
18:43:04 <twiceler> well 1 * any number is that number
18:43:05 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:43:10 <startling> yeah.
18:43:21 <twiceler> so you're not going to get the primes
18:43:23 <aristid> > liftA2 (*) [2..] [2..]
18:43:24 <lambdabot>  [4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,...
18:43:36 <twiceler> *composites
18:43:55 <aristid> i think if you exclude 1 it does work
18:44:05 <twiceler> okay. I see you what you mean. Yep
18:44:05 <startling> not really.
18:44:16 <aristid> well if you have multitudes of infinite time
18:44:19 <startling> you get all the multiples of 2, followed by all the multiples of everything else.
18:44:26 <aristid> lol
18:44:45 <aristid> i guess maybe with some kind of diagonalization..? oh well *shrug*
18:44:52 <AshyIsMe> hoover291: http://www.haskell.org/haskellwiki/Prime_numbers
18:44:56 <AshyIsMe> :P
18:46:01 <aristid> > do x <- [2..]; y <- [2..x]; return (x*y)
18:46:02 <lambdabot>  [4,6,9,8,12,16,10,15,20,25,12,18,24,30,36,14,21,28,35,42,49,16,24,32,40,48,5...
18:46:32 <startling> aristid: isn't that the same thing?
18:46:41 <startling> oh, I see.
18:46:52 <zRecursive> @undo x <- [2..]; y <- [2..x]; return (x*y)
18:46:52 <lambdabot> <unknown>.hs: 1: 3:Parse error: <-
18:47:04 <zRecursive> @undo do x <- [2..]; y <- [2..x]; return (x*y)
18:47:04 <lambdabot> [2 ..] >>= \ x -> [2 .. x] >>= \ y -> return (x * y)
18:47:11 <twiceler> just for clarity:
18:47:27 <twiceler> > do x <- [2..]; y <- [2..x]; return (x / y :: Rational)
18:47:28 <lambdabot>  [1 % 1,3 % 2,1 % 1,2 % 1,4 % 3,1 % 1,5 % 2,5 % 3,5 % 4,1 % 1,3 % 1,2 % 1,3 %...
18:47:51 <twiceler> nevermind
18:48:08 <aristid> > do x <- [2..]; y <- [2..x]; return (x,y)
18:48:09 <lambdabot>  [(2,2),(3,2),(3,3),(4,2),(4,3),(4,4),(5,2),(5,3),(5,4),(5,5),(6,2),(6,3),(6,...
18:48:18 <aristid> i think you meant that?
18:48:39 <twiceler> Yeah. I wanted to be cool and enumerate the rationals. But then I realized what you did would be much more informative anyway
18:48:51 <twiceler> (and I shouldn't have started at 2)
18:50:21 <aristid> so i'm not sure if this revised code actually lists all the composites
18:50:49 <aristid> > sort . take 1000 $ do x <- [2..]; y <- [2..x]; return (x*y)
18:50:51 <lambdabot>  [4,6,8,9,10,12,12,14,15,16,16,18,18,20,20,21,22,24,24,24,25,26,27,28,28,30,3...
18:50:51 <startling> It's not really a decision procedure.
18:51:24 <twiceler> aristid: It will. Any composite is the product of two natural numbers for which neither are one
18:51:53 <startling> is there an isPrime somewhere?
18:52:08 <Clint> in primes there is
18:52:14 <startling> :t isPrime
18:52:15 <lambdabot>     Not in scope: `isPrime'
18:52:15 <lambdabot>     Perhaps you meant `isPrint' (imported from Data.Char)
18:52:20 <startling> not in lambdabot, alas
18:52:32 <aristid> > map head . group . sort . take 1000 $ do x <- [2..]; y <- [2..x]; return (x*y)
18:52:33 <lambdabot>  [4,6,8,9,10,12,14,15,16,18,20,21,22,24,25,26,27,28,30,32,33,34,35,36,38,39,4...
18:52:34 <zRecursive> :hoogle isPrime
18:52:54 <aristid> looks correct
18:53:11 <startling> the "list of all composites up to x" thing is interesting as an upper bound of complexity for a primality test.
18:53:21 <geekosaur> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=Elem&start=10#0:isPrime
18:53:39 <aristid> startling: yes, it's about the worst way short of going to bogosort like techniques :D
18:53:55 <twiceler> startling: Well, Eratosthanes' sieve is better
18:54:06 <twiceler> startling: only up to sqrt x
18:54:18 <twirlobite> is haskell a...fad?
18:54:22 <startling> twiceler: I'm not interested in "better". :)
18:54:29 <zRecursive> > take 9 $ [x*y | x<[2..], y<[2..x]]
18:54:30 <lambdabot>  Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
18:54:31 <lambdabot>              with actual type `[t0]'Couldn't match expected type `Debug.Simpl...
18:54:31 <lambdabot>              with actual type `[Debug.SimpleReflect.Expr.Expr]'
18:54:36 <startling> twirlobite: it's been a fad for about 25 years now, if so
18:55:05 <aristid> zRecursive: the $ there is not necessary, and it has to be <- not <
18:55:07 <zRecursive> > take 9 $ [x*y | x<-[2..], y<-[2..x]]
18:55:08 <lambdabot>  [4,6,9,8,12,16,10,15,20]
18:55:27 <twiceler> twirlobite: If Haskell were a fad, then people wouldn't say "Oh, yeah Pascal, I've heard of that" when I tell them I'm using Haskell
18:55:39 <zRecursive> aristid: yeah
18:56:20 <aristid> > take 10 do []
18:56:21 <lambdabot>  <hint>:1:9: parse error on input `do'
18:56:44 <twiceler> startling: Right, come to think of it, Euclid's algorithm is better than either of these sieves as a test for a single prime
18:57:51 <ion> aristid: I wish
18:58:27 <aristid> ion: you wish do would self-parenthesize?
18:58:43 <benzrf> @pl \p l -> length $ filter p l
18:58:43 <lambdabot> (length .) . filter
18:58:44 <ion> aristid: Yes. Also \ ->, case, if, …
18:58:53 <benzrf> @pl \l p -> length $ filter p l
18:58:53 <lambdabot> (length .) . flip filter
18:59:04 <aristid> ion: ha! also, there should be a \case
18:59:35 <aristid> benzrf: just make a count p l = length $ filter p l helper function
18:59:50 <benzrf> :O
19:00:11 <aristid> or count p = length . filter p if you're feeling pointfree
19:00:12 <Ralith_> benmachine: ah, cool
19:05:51 <dario`> @pl \f (a, b) -> (a+1, f b)
19:05:52 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,) . (1 +))
19:05:55 <dario`> nah..
19:06:55 <twiceler> dario: (+1) *** f
19:07:53 <dario`> twiceler: ah, thx
19:09:51 <zRecursive> :t ap
19:09:52 <lambdabot> Monad m => m (a -> b) -> m a -> m b
19:12:46 <freezway> leanring haskell: how come it says delete is out of scope when I try to use it on a list
19:13:03 <freezway> like delete m lst where m = maximum lst
19:13:09 <geekosaur> @index delete
19:13:09 <lambdabot> Data.HashTable, Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
19:13:26 <geekosaur> it's not in Prelude; import the one appropriate for your data type
19:13:32 <freezway> what?
19:13:36 <freezway> ah
19:13:38 <freezway> thanks
19:18:25 <Gracenotes> hm. yeah, for BSTs like Tree k v = Bin k (Tree k v) (Tree k v) | Tip k v, how are the bin keys determined? does there need to be some operation defined that averages two children keys?
19:19:01 <benzrf> ok, I just finished a simple Wireworld simulator.
19:19:10 <benzrf> can anybody glance at my code and critique it please?
19:19:46 <Gracenotes> and if you're rotating three internal nodes, should these internal keys be recalculated?
19:19:55 * Gracenotes google-fu failing :/
19:24:35 <Gracenotes> I suppose I will have to fall back to just thinking really hard. darn.
19:50:29 <joelteon> can I make haddock freak out if there isn't 100% documentation coverage?
19:51:23 <raisdead> Iam reading the Xmonad man page and found mod+n. which Resize viewed windows to the correct size. I when I use it I do not see an effect. Can someone describe this better?
19:54:13 <raphie> what do you all use for editing haskell? I'm looking for something that'll highlight type errors before I have to compile, etc
19:54:20 * hackagebot hakyll-elm 0.1 - Hakyll wrapper for the Elm compiler.  http://hackage.haskell.org/package/hakyll-elm-0.1 (maxiepoo)
19:54:20 <raphie> (I've just been using sublime text)
19:55:26 <benzrf> vim > st
19:55:29 <benzrf> vim4lyfe
19:55:39 <benzrf> except until i learn emacs maybe if I choose to and like it more
19:57:07 <maxiepoo> raphie: emacs + flycheck will highlight type errors for you
19:59:02 <trillioneyes> raphie: I don't think you can catch type errors in the fully general case without compiling
19:59:21 <trillioneyes> Although yeah, flycheck does incremental compilation or some similar magic, I think?
19:59:42 <trillioneyes> I should try using flycheck some time
20:02:38 <joelteon> I wish the type system was smarter ):
20:03:32 <maxiepoo> are type holes out yet?
20:03:39 <joelteon> Well
20:03:44 <joelteon> I don't wish that at all. I wish *I* was smarter
20:05:41 <shachaf> I really wish it wasn't called "type holes".
20:05:49 <shachaf> Anyway, it's in HEAD, not in any released GHC>
20:06:07 <lispy> shachaf: what would you have preferred?
20:06:07 <shachaf> But last I checked you could do just as well, or better, using ImplicitParams.
20:06:12 <lispy> metavariables?
20:06:15 <shachaf> lispy: Something without the word "type" in it.
20:06:24 <shachaf> Like "holes".
20:06:36 <shachaf> Then we would have a natural name for the type-level version!
20:06:46 <maxiepoo> ah
20:06:54 <lispy> gotcha
20:06:59 <joelteon> implicitparams are cool
20:07:03 <joelteon> anyway, I'll pastebin
20:07:07 <shachaf> But maybe I just don't understand why it's called that.
20:07:35 <cdk> whats the type signature of the alterF that might be included in Data.Map in the future?
20:08:23 <shachaf> I hope that it would be something like (Ord k, Functor f) => k -> (Maybe a -> f (Maybe a)) -> Map k a -> f (Map k a)
20:08:28 <joelteon> Ok, is this possible? http://lpaste.net/97546
20:08:31 <joelteon> I hope it's possible.
20:08:33 <shachaf> I totally abandoned that thread. :-(
20:09:10 <joelteon> I feel like someone here knows type inference better than I do.
20:09:51 <joelteon> whoops forgot to add the error
20:10:17 <joelteon> edited in
20:10:35 <joelteon> isn't flip evalStateT (anything) of type m a -> IO a?
20:10:40 <joelteon> if your base monad is IO?
20:11:02 <startling> alterF :: k -> Lens' (Map k a) (Maybe a) ?
20:11:42 <shachaf> Yes.
20:11:50 <joelteon> I guess the question is whether it's possible to change an existential type during a pattern match.
20:12:27 <startling> why is that necessary? it seems odd to put it in containers when it's so domain-specific, especially because lens already has 'at'.
20:13:02 <startling> I guess lens might need to rebuild the map completely to implement 'at'.
20:13:16 <shachaf> It isn't especially domain-specific.
20:13:31 <startling> it's lens-specific.
20:13:44 <shachaf> Not really.
20:13:51 <shachaf> Well. It's lens-compatible.
20:14:49 <shachaf> f could easily be instantiated as IO or some other Functor.
20:15:14 <startling> I guess so.
20:15:36 <shachaf> People have proposed a bunch of other more specific variations.
20:16:13 <shachaf> This is what you get when you generalize. The fact that it's lens-compatible might be a sign of lens being reasonable.
20:17:02 <shachaf> And it lets you implement most of the Data.Map API efficiently.
20:17:35 <startling> That's true.
20:18:18 <shachaf> Using just traverseWithKey and alterF, you can implement all of these with optimal asymptotic behavior and often with near-optimal constant factors:
20:18:19 <mgsloan> Yes, at some point I saw "type holes" and thought "cool, holes for types! I knew there were those value ones, but type holes would be great"
20:18:21 <shachaf> (!) adjust adjustWithKey alter delete empty findWithDefault foldl foldl' foldlWithKey foldlWithKey' foldr foldr' foldrWithKey foldrWithKey' insert insertLookupWithKey insertWith insertWithKey lookup map mapAccum mapAccumRWithKey mapAccumWithKey mapMaybe mapMaybeWithKey mapWithKey member notMember toList update updateLookupWithKey updateWithKey
20:18:35 <joelteon> damn
20:19:21 * hackagebot modulespection 0.1.0.0 - Template Haskell introspecting a modules declarations  http://hackage.haskell.org/package/modulespection-0.1.0.0 (JonathanFischoff)
20:19:40 <startling> shachaf, "kind holes"
20:24:14 <ion> * holes
20:29:22 * hackagebot modulespection 0.1.0.1 - Template Haskell for introspecting a modules declarations  http://hackage.haskell.org/package/modulespection-0.1.0.1 (JonathanFischoff)
20:29:24 * hackagebot modulespection 0.1.0.2 - Template Haskell for introspecting a module's declarations  http://hackage.haskell.org/package/modulespection-0.1.0.2 (JonathanFischoff)
20:30:18 <jfischoff> the hyphen in the "module's" was the entire change to the new version :(
20:30:46 <jle`> get your act together :P
20:30:50 <jle`> jk merry christmas :)
20:31:06 <jfischoff> merry christmas to all!
20:31:22 <lispy> (and happy new year!)
20:32:57 <duairc> Is it "safe" to unsafeCoerce from one ADT to another if they have the same number of constructors?
20:33:45 <shachaf> Not in general.
20:34:06 <carter> duairc: its actually ok to unwrap and rewrap between the two
20:34:18 <shachaf> The usual rule on unsafeCoerce is "if you have to ask, the answer is no"
20:34:23 * hackagebot cookbook 2.0.0.0 - A delicious set of interdependant libraries.  http://hackage.haskell.org/package/cookbook-2.0.0.0 (NatePisarski)
20:34:23 <carter> yup
20:34:27 <lispy> duairc: I think they also need to have the same parameters to each constructor (more accurately, that you can safely unsafeCoerce all the parameters and they have the same number of them on each constructor)?
20:34:34 <carter> unless youv'e read the source for the RTS, don't :)
20:34:51 <shachaf> Well. There are some specific situations that you can guarantee safe. But you'll need something a lot more specific than "same number of constructors".
20:34:57 <carter> if they're the exact same type though, a newtype is better anyways
20:35:02 <lispy> duairc: I'm basing that claim on pure speculation
20:35:19 <carter> lispy: you may be right, i don't recall though
20:35:23 <shachaf> You'll have to pay attention to things like strictness, unpacking, the optimization level that they're both compiled with.
20:35:26 <carter> yeah
20:35:41 <carter> basically "have you considered using newtype"
20:35:42 <carter> :)
20:35:42 <shachaf> It's very easy to forget the last one, for instance.
20:35:48 <carter> yeah
20:36:26 <duairc> I guess more specifically I'm wondering, if a is a value which is constructed with the nth constructor of an ADT A which has k constructors, if I unsafeCoerce a to another ADT B which also has k fields, will the resulting value b be the nth constructor of B?
20:37:20 <shachaf> It might work in your favor to be more specific rather than less, for this question.
20:37:46 <carter> yeah
20:38:17 <shachaf> Unless you're trying to figure out a very general rule.
20:38:31 <shachaf> In general GHC doesn't guarantee all that much.
20:38:41 <carter> yeah
20:40:06 <duairc> Well, this is kind of a "what if?" train of thought, but now that I think of it, a newtype would actually work for what I'm doing. The code I'm writing is crazy and evil anyway
20:40:21 <duairc> I mean, a newtype would "work" for me as much as unsafeCoerce would
20:40:44 <carter> duairc: what level of evil
20:41:01 <duairc> Template Haskell
20:41:14 <carter> i've some cute evil code that will crash ghci, but give me arbitrary heap pointers in compiled code :)
20:41:30 <carter> (i have no practical use case, i just tried it out a few months ago to amuse myself)
20:41:49 <carter> duairc: what sort of TH stuff are yo doing?
20:41:56 <carter> GHC HEAD has some neat changes to TH
20:42:21 <duairc> Yeah, I'm excited to try it out, but I'm trying to remain compatible with older GHCs for this code
20:42:42 <carter> ouch
20:42:43 <carter> gl!
20:42:48 <carter> CPP may help you there
20:42:55 <duairc> Yeah, I'm using lots of it :)
20:42:57 <carter> have it conditional on the GHC version
20:42:58 <carter> ok
20:42:58 <carter> good
20:43:14 <codygman> Should ghci pick up a "cabal-dev" directory by default even if I have no cabal file?
20:43:20 <carter> ummm
20:43:24 <carter> why
20:43:35 <carter> also use cabal-install 1.18
20:43:38 <carter> its nicer :)
20:44:13 <carter> (if your'e doing sandboxed builds, cabal-install 1.18 is nicee)
20:44:20 <jle`> cabal-dev i think you have to do cabal-dev repl
20:44:23 * hackagebot modulespection 0.1.0.3 - Template Haskell for introspecting a module's declarations  http://hackage.haskell.org/package/modulespection-0.1.0.3 (JonathanFischoff)
20:44:31 <jle`> for for a sandbox-aware ghci
20:44:36 <jle`> but yeah use sandbox in 1.18
20:44:52 <jle`> cabal-dev ghci
20:44:55 <jle`> sorry
20:45:21 <duairc> carter: It's sort of a from-scratch reimplementation of something like Control.Lens.TH, inspired by the new OverloadedRecordFields stuff, in my own idiomatic coding style
20:45:30 <carter> oh
20:45:31 <carter> cool
20:45:39 <carter> duairc: i think jfischoff  is hacking on something related to that
20:45:42 <carter> if you don't know him
20:46:08 <duairc> Not sure if I'll end up using it in serious code, but it's my first time using Template Haskell for anything
20:46:13 <carter> ok
20:46:14 <codygman> Well I'm using debian which provides cabal 1.14 by default.
20:46:14 <carter> well
20:46:16 <duairc> Interesting, I wasn't aware of that
20:46:24 <carter> codygman: that is sad
20:46:30 <codygman> I was sure that ghci was picking up my cabal-dev by default.
20:46:31 <carter> like…. painful
20:46:33 <jfischoff> no I'm doing something different
20:46:45 <carter> oh
20:46:45 <carter> ok
20:46:55 <jfischoff> I just made all the lenses and prisms for the TH types
20:46:56 <codygman> carter: Not really, I never have to fix anything... though in these cases it is a bit annoying to backport things.
20:47:19 <carter> codygman: cabal-install 1.18 has sandboxes of joy
20:47:28 <codygman> carter: I might have to get it lol
20:47:35 <carter> please
20:48:20 <carter> i think 1.20 is landing in the next month or so
20:49:10 <enthropy> duairc: I'm not sure how much sense that project makes (inspired by the new OverloadedRecordFields stuff)
20:49:20 <enthropy> since that new extension is for avoiding TH
20:50:05 <carter> hehe
20:50:17 <codygman> carter: Yeah I'll have to backport ghc 7.8.1... maybe there's an ubuntu ppa I can debianize.
20:50:27 <carter> codygman: there is
20:50:29 <carter> hvr has a ppa
20:51:11 <codygman> carter: Cool, I just found it ;)
20:51:18 <enthropy> it's a decent exercise though (how to use reify, what Dec constructors correspond to the functions you'd write by hand)
20:54:41 <duairc> enthropy: Well, most of the TH is just for autogenerating instances that you could easily write by hand. Some of it is for compaitibility with older GHCs too (that don't have TypeLits), but if you have TypeLits and you don't care about compatibility and you don't mind writing tiresome instances by hand then you don't need TH.
20:55:05 <enthropy> for what?
20:56:18 <duairc> enthropy: Right now, with the machinery in Control.Lens.TH, there's no way to have a lens "x" that will work on any datatype that has an "x" field. You can get it to generate a HasX class, but if you make HasX in your package and I make HasX in my package, they're different classes. What I'm doing does something like Has "x"
20:58:03 <triliyn> duairc: do you know of vinyl? It seems kind of similar to what you're trying to do
20:58:09 <triliyn> (But I've only heard two lines so maybe I'm misunderstanding)
20:58:27 <enthropy> duairc: have you seen the whole list http://www.haskell.org/haskellwiki/Extensible_record#Libraries_on_hackage ?
20:58:36 <duairc> I know of Vinyl, there are some similarities, but it's different
20:58:46 <jfischoff> another approach would be to use GHC.Generics
20:58:54 <jfischoff> or something similar
21:00:08 <enthropy> if everybody uses vinyl or hlist or any of the other libraries in that list, all those "x" will be the same
21:00:18 <enthropy> if they use the same one
21:00:23 <enthropy> the same library
21:00:56 <codygman> I'm guessing that ghc 7.4.1 won't know how to use cabal sandbox, or will it?
21:01:11 <jfischoff> I know it works with 7.4.2
21:01:23 <jfischoff> So I bet it is fine
21:01:47 <jfischoff> I don't think cabal repl works though
21:02:09 <jfischoff> the package-conf flag was renamed to package-db I think
21:02:40 <duairc> This isn't really the same thing as Vinyl or HList though, it's not extensible records
21:02:52 <enthropy> duairc: if you have a  data a ::: b = a ::: b; data A; data B; data C; ... you can write type-level strings as  A:::B:::X:::Y
21:03:06 <enthropy> at some point there was a preprocessor / article with that trick
21:03:08 <duairc> Basically I'm just writing TH to autogenerate instances of a class that looks like this: http://lpaste.net/97548
21:03:14 <enthropy> gives pretty ugly code
21:03:30 <carter> Has n p STAB
21:03:31 <carter> heheh
21:03:40 <duairc> If you make an instance of IsString (Q Type), you can write type level strings like $("hello")
21:03:42 <enthropy> from the user's perspective and it's probably quite slow
21:04:12 <duairc> And that will use TypeLits on newer GHCs, and fall back onto something else on older ones
21:04:48 <carter> hoenstly any code that really depends on fancy types only in newer ghcs, i don't wanna try to make it supported on older ghcs
21:04:52 * enthropy thinks you aren't allowed to splice in Q Type at random
21:05:16 <carter> yeah, pre 7.8 splicing has funny / annoying / frustrating constraints in types
21:05:16 <enthropy> you can't do     instance Foo (T $xyz) -- right?
21:05:39 <enthropy> carter: not about the types, but that the parser isn't expecting it in every place I imagine might be acceptable
21:05:43 <carter> yeah
21:05:47 <carter> that
21:05:54 <carter> the examples i hit are in types though :)
21:07:18 <edwardk> duairc: we're getting something like that with ghc 7.10
21:07:20 <codygman> SO with cabal sandbox I have to have a cabal file to run "cabal repl"?
21:07:29 <duairc> edwardk: I know
21:07:38 <duairc> (I mentioned it above)
21:07:55 <codygman> Isn't there an easy way to install dependencies in a sandbox environment and run ghci based on that environment without having to do anything else?
21:08:04 <codygman> I could have sworn this was possible for me in the past.
21:08:05 <carter> codygman: yup
21:08:13 <carter> well
21:08:19 <carter> cabal repl and friends is supposd to make it nice
21:09:34 <enthropy> oh I was mistaken, you can splice Q Type things in more places than I imagined
21:09:50 <enthropy> instance C $([t| Int |]) -- is perfectly fine
21:09:52 <duairc> Yeah, I haven't run into any problems with it
21:10:03 <duairc> It doesn't work on GHC 6.10 though
21:10:21 <duairc> But I also a splice that makes a Dec of a type synonym
21:10:21 <codygman> carter: Really? I just get "No cabal file found." when I run "cabal sandbox init; cabal repl"
21:10:29 <enthropy> instance $([t|Read Int |]) -- doesn't work
21:10:48 <carter> hehe
21:10:53 <carter> you need a cabal fiel
21:10:55 <carter> for repl
21:11:00 <carter> i think
21:11:09 <carter> may be some plans for 1.20 or 1.22
21:11:32 <duairc> I'm using this https://github.com/duairc/symbols/
21:11:51 <codygman> carter: and ghci doesn't use my sandbox by default right? I was just trying to avoid making a cabal file since I haven't before and this is a throwaway project.
21:11:53 <duairc> Still a WIP... I mean it works, but I want to test it a bit more before releasing it.
21:12:11 <carter> you can pass ghci which package db you want
21:12:18 <carter> look at how HSENV does it
21:12:29 <codygman> carter: Alright, though then I'd have to integrate that into emacs right?
21:12:35 <carter> why emacs?
21:12:37 <carter> idk
21:12:42 <carter> i know nothing
21:13:38 <codygman> carter: well I like loading a repl based on the code I'm editing. Something broke my workflow it seems... and I'm trying to figure out what. I've tracked it down to cabal-dev not being picked up automatically and have been trying to fix that... lol
21:13:50 <carter> i know nothing
21:14:04 <carter> i'v enot used cabal-dev in like 2 years
21:14:08 <carter> or a year
21:14:10 <carter> i forget
21:21:14 <carter> who here is familiar with when i should use which hooks for cabal?
21:22:17 <enthropy> often it doesn't matter
21:22:31 <enthropy> at least that's my experience
21:22:33 <carter> yeah
21:22:41 <carter> i'm inclined to agree
21:22:45 <carter> just sanity checking
21:23:00 <codygman> bleh, I just want to program. Maybe I was using virthualenv before... I'll try that again I guess.
21:24:47 <jle`> codygman: if you're using ubuntu then you can just manually build ghc
21:28:39 <codygman> jle`: Why do you think my problem is building ghc? Does it seem like my install isn't acting normally?
21:40:18 <carter> edwardk: i'm finally using your mini lense :)
21:40:19 <carter> its nice!
21:43:51 <edwardk> hah
21:49:44 <carter> ^. is get and  %~ is function update and .~ is strong update, right?
21:50:10 <carter> edwardk: as usual, i'm using lens to mess with Setup.hs
21:53:33 <jfischoff> is there a withSystemTempFile that uses MonadIO instead of IO lying around?
21:54:12 <edwardk> carter: yes
21:54:16 <jfischoff> oh wait
21:54:28 <jfischoff> I wasn't looking at the newest version ...
21:54:29 <carter> jfischoff: just use lift?
21:54:50 <edwardk> carter: it presumably takes an IO action in negative position
21:55:06 <carter> ah
21:58:31 <danharaj> edwardk: I want to learn a modern logic programming language that has really tight semantics and the best syntax
21:58:36 <danharaj> what'd that be
21:59:16 <ion> C+=
22:00:11 <danharaj> is that real
22:00:13 <danharaj> I can't google it
22:00:45 <edwardk> danharaj: its real, its also a bad antifeminist joke
22:00:48 <maxiepoo> it's not afaik. It's a bad joke
22:01:01 <jfischoff> ugh why is the doCpp function private :( . https://github.com/ghc/ghc/blob/d71bbe79e222ea286c2fd465abfde58280450c3a/compiler/main/DriverPipeline.hs#L2022
22:01:09 <edwardk> ok "real"
22:01:27 <jfischoff> tell me there is an easier way to use the GHC API to parse code ...
22:04:09 <carter> jfischoff: is it private in HEAD?
22:04:29 <mgsloan> jfischoff: I dunno if this is what you're looking for, but if you ignore the STM shenanigans: https://gist.github.com/mgsloan/8028b2ab910eaf2bec02
22:04:48 <jfischoff> I'm pretty sure I linked to HEAD
22:05:11 <ion> Bad, huh? It’s pretty funny. :-P
22:05:29 <jfischoff> mgsloan: no CPP preprocessing though, right?
22:05:31 <maxiepoo> is `head . sort` O(n)?
22:05:37 <maxiepoo> using Data.List's sort
22:05:38 <enthropy> @hackage cpphs
22:05:38 <lambdabot> http://hackage.haskell.org/package/cpphs
22:06:01 <mgsloan> jfischoff: I don't think so.  I didn't want cpp preprocessing, though, since this was for comparing behavior between HSE and GHC
22:06:13 * jfischoff nods
22:07:01 <maxiepoo> ?
22:07:13 <jfischoff> I need CPP … I need everything!
22:07:37 <carter> jfischoff: if its private and you need that to parse things, open a ticket on trac + a patch
22:07:57 <carter> jfischoff: NB, i think dynflags are being phased out, idk
22:08:09 <carter> jfischoff: though i think luite would know
22:08:16 <maxiepoo> it looks like it's not
22:08:26 <jfischoff> I'm not much of a ticket opener
22:08:37 <carter> wellllll
22:08:45 <shachaf> maxiepoo: I thought it was with GHC's Data.List.sort.
22:08:47 <carter> at least to a feature request ticket
22:08:54 <enthropy> jfischoff: you can't use cpphs or call the system's cpp yourself?
22:09:17 <carter> good question
22:09:26 <maxiepoo> I'm trying to work through it
22:09:28 <jfischoff> enthropy: I'm just going to copy and paste the code from doCpp
22:10:02 <maxiepoo> it's a pretty long merge sort impl
22:10:50 <maxiepoo> I think I see why it is O(n)
22:11:39 <carter> ?
22:12:18 <enthropy> maxiepoo: it has to be, no?
22:12:22 <maxiepoo> I'm going to write a lazy sort in a strict language so I'm trying to see which parts NEED to be lazy in order for the complexity to work
22:12:38 <carter> oh
22:12:40 <carter> hrmmm
22:12:49 <carter> maxiepoo: have you read chris okasaki's stuff?
22:13:10 <maxiepoo> some, I've been reading purely functional data structures recently
22:14:11 <carter> cool
22:16:12 <maxiepoo> yeah it seems like it's always a pain to do laziness in strict languages or strictness in lazy languages
22:17:31 <maxiepoo> I wonder if you could use a dependently typed language to guarantee a certain amount of laziness/strictness in a function
22:19:33 <enthropy> if seq had type class it would show up in the type
22:20:18 <shachaf> seq is hardly relevant.
22:20:24 <enthropy> well if something is marked   f :: Seq a => a -> b -> c
22:20:25 <shachaf> Most dependently-typed languages also like to have totality, in which case strictness/laziness becomes irrelevant.
22:20:40 <enthropy> there's some vague sign that `a' might get evaluated without having to pattern match on it
22:20:49 <shachaf> You can do case analysis without seq.
22:21:36 <enthropy> yeah it wouldn't be a guarantee either way
22:22:09 <maxiepoo> shachaf: semantically irrelevant but it could change asymptotic complexity right?
22:22:14 <maxiepoo> like head . sort
22:22:37 <maxiepoo> operationally relevant?
22:23:35 <carter> enthropy: seq WAS in a type class
22:23:37 <carter> now its not :)
22:23:50 <danharaj> edwardk: found it. that's hardly a joke. it sounds like disaffected male teenager's first rant about feminism.
22:24:00 <danharaj> pretty sad that someone put that much effort into it.
22:24:08 <edwardk> yes
22:24:23 <maxiepoo> danharaj: I think it came out of 4chan
22:25:02 <carter> i think so
22:25:15 <simpson> Poe's Law and whatnot.
22:34:35 <carter> ye gods, this is my first  custom Setup.hs
22:34:39 <carter> well
22:34:44 <carter> first really really custom one
22:36:59 <ion> @tell peaker It would be nice if each one of these points had a small play button that opens an inline video demonstration. http://peaker.github.io/lamdu/
22:37:00 <lambdabot> Consider it noted.
22:38:32 <maybefbi> when I run this http://lpaste.net/97551 the screen flickers, and I cant read any text on the terminal properly
22:38:37 <maybefbi> how can I solve that
22:38:46 <maybefbi> *the line flickers
22:39:18 <ion> Byt not clearing the line
22:39:34 <ion> and adding a delay probably
22:40:30 <c_wraith> you are telling it to clear the line and print a value as fast as possible
22:40:38 <c_wraith> why are you surprised that it's doing that?
22:40:57 <maybefbi> uhm i dont want a screen full of doubles
22:41:14 <maybefbi> in the actual code the doubles keep changing
22:41:27 <maybefbi> i just want to see the last double
22:42:00 <c_wraith> Sure, but look at what the code *says*.  print x.  go up a line. clear the line.  start the process over.
22:42:14 <c_wraith> It's going to do exactly that.
22:42:26 <c_wraith> You didn't tell it to slow down anywhere
22:42:52 <c_wraith> You didn't tell it to let you see the number for a bit before erasing it.  etc
22:43:06 <ion> If you print over text in most terminals it will remove the old text without flicker.
22:43:19 <c_wraith> It's just erasing the content immediately after printing it.
22:43:38 <maybefbi> c_wraith: ah cool. will try printing over
22:43:49 <c_wraith> ion: that kinda sucks with doubles though, thanks to their random-ish length
22:44:03 <ion> c_wraith: You clear the rest of the line after printing the double.
22:44:50 <ion> But anyway, if you use a delay you may get away with clearing before printing.
22:45:14 <maybefbi> c_wraith: perhaps i should pad the double with zeroes on the left when it is printed with shorter lengths
22:45:19 <maybefbi> ion: ok
22:46:45 <jle`> if you want to do padding and alignment stuff consider printf
22:47:11 <c_wraith> does GHC's gc tag restrict the number of fields in a record to something less than the number of bits in a word?
22:48:02 <maybefbi> jle`: ok
22:49:18 <c_wraith> I guess the tag could be variable-length - set the last bit to indicate that it lasts another bit, etc.
22:49:19 <c_wraith> Hmm.
22:52:57 <dhrosa_> is there a place I can go to have my code critiqued? I have a functioning command-line Minesweeper game, and I want to see people weed the stupidity out of my code
22:53:14 <dhrosa_> (I started Haskell like 2-3 weeks ago)
22:53:31 <c_wraith> I think /r/haskell or stack exchange's code review would both have good results
22:54:19 <gamegoblin> in instances where you could use . or $, which do you guys prefer?
22:54:48 <gamegoblin> or parens, I guess
22:55:06 <c_wraith> I prefer the one that doesn't depend on the fixity declaration of the operator to mean the right thing.
22:55:46 <ion> gamegoblin: You can not refactor “bar $ baz” out of “foo $ bar $ baz $ quux” verbatim and give it a new name. You can not eta-reduce “foo $ bar $ baz $ quux”. ($) is overused.
22:56:33 <ion> c_wraith: Also, ($) should be infixl. :-P
22:56:42 <dhrosa_> ion: what's wrong with $?
22:57:20 <c_wraith> if ($) was infixl, you *could* eta-reduce "foo $ bar $ baz $ quux"
22:57:43 <jle`> gamegoblin: i feel like you should always use at most one $ per line/parentheses.  where that goes depends on what makes the most sense, conceptually
22:57:47 <ion> dhrosa: Sometimes what i said above, sometimes its overuse can also require more effort from the reader to see the structure of the code compared to just using parens.
22:58:16 <ion> dhrosa: This is not to say there are no appropriate uses for $ instead of equivalent parens.
23:01:03 <rose_> Git drops you into your editor of choice for some commands. How can I write a Haskell program that lets me input text not just via stdin, but also by dropping into vim?
23:01:39 <ion> Create a temporary file, run vim against it, check vim’s exit value and read the file.
23:02:08 <jle`> or for kicks use $EDITOR instead of hard-coding vim, i think that's what git does
23:02:21 <dhrosa_> isn't that basically exactly what git, visudo, etc do?
23:02:35 <c_wraith> yep
23:02:37 <jle`> dhrosa_: did you peek at the filenames? :P
23:02:55 <dhrosa_> yeah
23:03:33 <gamegoblin> What is the difference in " unwords $ zipWith format l n " and " (unwords . zipWith format) l n "
23:03:55 <ion> gamegoblin: Try expanding the definition of (.) manually.
23:04:08 <ion> @src (.)
23:04:09 <lambdabot> (f . g) x = f (g x)
23:04:09 <lambdabot> NB: In lambdabot,  (.) = fmap
23:04:32 <ion> gamegoblin: What does (unwords . zipWith format) l n expand to?
23:04:51 <gamegoblin> so is the issue that my function takes 2 args?
23:04:56 <c_wraith> yes
23:04:59 <gamegoblin> since it seems (f .g ) x only takes 1
23:05:00 <gamegoblin> gotcha
23:06:29 <gamegoblin> for some reason I didn't think of it as an infix operator and just as syntactic sugar for " unwords (zipWith format l n) "
23:07:09 <ion> unwords (zipWith format l n) is fine already. :-P
23:07:23 <gamegoblin> I know
23:07:28 <gamegoblin> But . is so sexy ;)
23:07:38 <c_wraith> (unwords . zipWith format l) n
23:08:23 <lispy> :t ((unwords .) . (zipWith ?format)) ?l ?n
23:08:24 <lambdabot> (?format::a -> b -> String, ?l::[a], ?n::[b]) => String
23:09:37 <ion> fmap fmap fmap unwords (zipWith ?format) ?l ?n
23:09:52 <ion> Aren’t we giving great suggestions that really make the code nicer?
23:09:57 <lispy> Totally
23:10:00 <gamegoblin> Ahahahaha
23:10:08 <gamegoblin> I went with unwords $ zipWith format l n
23:10:09 <lispy> I was especially fond of unwords (zipWith format l n)
23:10:25 <lispy> it's so simple and legible. Very hard to mistake the meaning.
23:11:41 <cbw> Code if for people not for machines
23:12:08 <jle`> my eyes automatically see the butterfly wings thoug
23:12:17 <cbw> -- as my bart massey (my CS proffessor likes to say)
23:12:38 <simpson> cbw: Bart's pretty cool guy. Squints and doesn't afraid of anything.
23:13:03 <gamegoblin> he is paraphrasing SICP, no?
23:13:09 <cbw> simpson: lol you know him?
23:13:23 <gamegoblin> SICP says "Programs should be written for people to read, and only incidentally for machines to execute"
23:13:30 <ion> FWIW, most popular languages are made for coding as if for machines and not people. :-P
23:14:14 <lispy> cbw: nice. Bart is a character. I do agree with him though.
23:14:21 <simpson> cbw: I'm friends with a bunch of CATs and I worked at OSL for three years before going to Seattle for a job.
23:14:41 <cbw> simpson++
23:14:46 <ion> Parsing is hard, let’s pollute everything with syntactic noise. Type inference is hard, let’s make all types explicit. Static typing is annoying (* see above), let’s use dynamic typing.
23:14:51 <gamegoblin> simpson: How do you like seattle? I am moving there in late May/early June for a job.
23:15:29 <cbw> simpson: I bet barts in here somewhere lol
23:16:01 <triliyn> ion: to be fair, if your understanding of type systems only encompasses C-ish things, dynamic typing feels like removing a lot of noisy uninformative type declarations so you can just read the code
23:16:25 <simpson> gamegoblin: I prefer Portland and the Willamette Valley, but it's acceptable.
23:17:17 <gamegoblin> I was just looking for apartments tonight, actually. Housing is so expensive compared to where I live now T_T
23:18:13 <simpson> I work in Fremont and live in Kirkland. Commute's long but housing's affordable. I hope that your new employer gave you an advance.
23:19:01 <cbw> long commutes gives you the change to catch up on podcasts
23:19:04 <gamegoblin> Yes they did, thankfully
23:19:41 * hackagebot modulespection 0.1.0.4 - Template Haskell for introspecting a module's declarations  http://hackage.haskell.org/package/modulespection-0.1.0.4 (JonathanFischoff)
23:20:11 <cbw> I commute from Tualatin to Portland
23:20:12 <cbw> not too bad if traffic is good
23:26:32 <startling> ion, luckily, learning to type is like learning to type.
23:27:11 <jle`> i feel like dynamic typing might have been more for people than for computers
23:27:37 <jle`> i could be completely oblivious to the history/original motivation however
23:30:55 <cbw> I can't decide if I like dynamic tying better or not
23:34:51 <Ralith> startling: XD
23:34:55 <Ralith> jle`: I think that's a given
23:34:58 <johnw> just imagine I had ranted about dynamic types and we'll leave it at that
23:34:59 <Ralith> hardware being what it is
23:35:08 <Ralith> it just turns out not to be so good for people, either, in the long run.
23:35:25 <dhrosa_> are you saying learning to type is like learning to type, or are you saying learning to type is like learning to type?
23:35:33 <johnw> anything that requires better discipline to use effectively, will not be used effectively
23:36:05 <Ralith> ghorn: or both!
23:36:13 <jle`> Ralith: was referring to ion, perhaps i msunderstood him
23:36:23 * yogurt_truck can't unify these ambiguous claims!
23:36:26 <startling> dhrosa_, yes.
23:36:44 <Ralith> jle`: he said 'annoying' as in 'annoying to people', no?
23:37:37 <cbw> The difference is complile type vs run time
23:39:08 <jle`> his rant was apparently lamenting language features made to benefit compilers at the expense of humans
23:39:29 <jle`> the first two examples seemed to go along this line
23:41:34 <Ralith> oh, I see
23:41:41 <joneshf-laptop> if i'm using a sandbox which installs binaries that I want to use during development, what's the best way to have these binaries available on my path?
23:41:46 <Ralith> I read it as just lamenting shortsighted design decisions in general
23:41:54 <joneshf-laptop> with the caveat that i dont want to add each individual path to my .zshrc
23:42:36 <joneshf-laptop> it's not for me personally, it's for working with others
23:42:58 <startling> joneshf-laptop, temporarily?
23:43:22 <joneshf-laptop> more permanent
23:44:03 <joneshf-laptop> but i dont wantto have to have every project needing to have to edit the rc files inorder for the sandboxed bins to be found
23:44:15 <joneshf-laptop> directory names might change
23:44:21 <joneshf-laptop> or new projects started
23:44:22 <joneshf-laptop> etc
23:46:55 <joneshf-laptop> is there a way?
23:46:59 <joneshf-laptop> maybe that's the better question
23:47:23 <joneshf-laptop> and actually, maybe this is more of a general linux question rather than specifically cabal
23:47:37 <jle`> joneshf-laptop: well...do you want to use these binaries outside of your project directory?
23:48:07 <joneshf-laptop> nope
23:48:30 <jle`> hm. i remember this functionality being automatic or something
23:48:37 <jle`> maybe it was for cabal-dev
23:48:47 <jle`> cabal-dev changes your path, doesn't it?
23:49:20 <jle`> there might be cabal sandbox functionality to do something like this automatically for you
23:49:21 <joneshf-laptop> i'm not sure, whenever i used cabal-dev i ended up breaking stuff, so I stopped using it
23:49:42 <jle`> yeah cabal dev changes your path i believe, to include the sandbox bins
23:49:43 * hackagebot modulespection 0.1.0.5 - Template Haskell for introspecting a module's declarations  http://hackage.haskell.org/package/modulespection-0.1.0.5 (JonathanFischoff)
23:50:30 <joneshf-laptop> hmm, i'll look into how it did that
23:50:30 <joneshf-laptop> thanks
23:51:21 <jle`> well, for it to work you had to manually initiate your shell every time you enter the directory and want to work there
23:51:44 <jle`> so if you wanted to follow that model, you could write a shell script to change the path to include it, and then import it using a dot command
23:51:56 <jle`> but i would hope that 1.18's sandboxes had some way to do this automatically for you
23:52:21 <jle`> a shell script in your project directory
23:53:42 <c_wraith> rvm is even creepier.  It does similar stuff by mucking with *everything*
23:55:02 <mpjones> Hi, I'm trying to debug my program. I've got a cabal setup with a library and executable both called "breakout" so I'm running: cabal repl exe:breakout ... but then I want to set a break point in a file from the library part and I do: :break Ball 43 and it says: module 'Ball' is from another package this command requires an interpreted module. How do set a break point in Ball.hs?
23:56:17 <jfischoff> I would just do cabal repl and then :l the executable file
23:56:31 <jfischoff> also I've never found breakpoints to be that useful
23:56:34 <mpjones> Ah, ok, I'll try that
23:56:34 <c_wraith> mpjones: that error message suggests that you can't do it with that structure.  Why do you have a lib/binary split for breakout?
23:56:55 <mpjones> c_wraith: It probably isn't necessary. Just don't know better
23:57:02 <mpjones> Seems like it should be possible though...
23:57:11 <c_wraith> In fact, I probably wouldn't have a library section with a game at all
23:57:11 <jfischoff> lib/exe split is good
23:57:18 <jfischoff> even for a game
23:57:25 <jfischoff> makes testing easier
23:57:26 <joneshf-laptop> https://github.com/haskell/cabal/commit/7dc0a100dde7b013dd740366d831e3416f27b6e4
23:57:27 <joneshf-laptop> hmm
23:57:30 <joneshf-laptop> supposed to be in there
23:57:37 <joneshf-laptop> maybe i need to look int he config file
23:58:31 <mpjones> If I do:  :l src/Main.hs ... then it fails on finding the OpenGL module as that is the executable part of the cabal config, which I guess is why I ended up doing cabal repl exe:breakout so that all the executable dependencies were loaded.
23:58:31 <jfischoff> for better or worse, haskellers tend not to use the debugger features of ghci
23:59:26 <mpjones> Error:    Could not find module `Graphics.Rendering.OpenGL'...    It is a member of the hidden package `OpenGL-2.9.1.0'.
23:59:57 <jfischoff> ugh
