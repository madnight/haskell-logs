00:21:24 <bernalex> anyone related to flops here who can answer questions about copyright and similar for their call to papers?
00:30:55 <simpson> edwardk: I apologize for the late-evening ping. Do you happen to know anything about non-associative operators? I'm parsing a language where `a == b == c` is a syntax error because `==` refuses to associate.
00:31:43 <edwardk> you can use a parser like the Expr parser in trifecta/parsec to deal with that case, just raise the precedence level on both sides, done.
00:32:17 <startling> simpson: what language, out of curiousity?
00:32:27 <startling> (does `(a == b) == True` work?)
00:32:51 <simpson> startling: E!
00:33:11 <simpson> edwardk: Mm, so the one in parsers isn't suitable then?
00:33:27 <edwardk> the one in parsers is the trifecta one i mean
00:33:31 <startling> simpson, man, I wouldn't bother competing with dash.
00:33:38 <startling> that dude never quits.
00:33:48 <simpson> startling: But competing with dash is my anti-drug!
00:35:29 <bernalex> OK. talked to Eijiro about the copyright, and ugghghg! I guess they don't want my paper.
00:39:57 <simpson> edwardk: Ah, I see. So if I want to associate in a "don't care" kind of fashion, I can just pick left or right (probably left), but AssocNone handles cases where no associativity is desired.
00:40:09 <edwardk> yea
00:42:35 <ReinH> edwardk: hai
00:42:47 <edwardk> yo
01:37:37 <donri> bos on upper bounds http://www.haskell.org/pipermail/libraries/2013-December/021777.html
01:37:43 <donri> (and ponies)
01:56:09 <saze> Hi there ! I'm learning Haskell and I have a question I can't find an answer to: is it possible to check a variable against a typeclass ? Say I have a function f a b = a + b so Obviousely a and be need to be members of Num. But they can be floats, Int, or Integer. How would I do that?
01:57:19 <supki> saze: do what?
01:57:21 <saze> my goal ultimately is to do a simple program that ask user to input two numbers and display the sum (yeah, baby steps)
01:58:04 <supki> saze: you can sum any two numbers as long as they are of same type that implements Num
01:59:09 <QF-MichaelK> Are there any good haskell coding tutorials?
01:59:12 <mr-> saze: however, when reading the numbers from your input, you might want to restrict the actual type you want to be able to handle. I would start with Integers
01:59:14 <saze> supki: yep, but how can I programmatically check that a variable belong to Num so that I can display a nice error message if the user entered something that is not a Num ?
01:59:22 <mr-> QF-MichaelK: "learn you a haskell"
01:59:46 <mr-> @google lyah
01:59:48 <lambdabot> http://learnyouahaskell.com/
01:59:48 <lambdabot> Title: Learn You a Haskell for Great Good!
02:00:09 <QF-MichaelK> mr-: Yeah, I liked that one, but I want something that's more random challenges like project euler but more haskell oriented
02:00:13 <QF-MichaelK> or codeacademy
02:00:32 <mr-> Oh.. there are the 99 haskell problems
02:01:09 <supki> saze: you can't know the type of thing in runtime generally
02:01:21 <QF-MichaelK> mr-: Yes, this will do, thank you!
02:01:24 <supki> saze: typically you write a parser and output a nice error message if it fails
02:01:29 <mr-> Other than that.. I don't know. Make up your own challanges! Write, for example, a program that plays TicTacToe with you, or something that solves the 8 queens problem ;-)
02:01:45 <donri> saze: yeah it's a parser issue not a type issue
02:02:02 <donri> saze: the type system will guarantee you get a number. that number can be an exception (bottom).
02:02:23 <donri> s//parsing issue/
02:02:50 <donri> :t readLn
02:02:51 <lambdabot> Read a => IO a
02:03:28 <donri> saze: this reads a line from standard input and parses it into the expected type
02:03:41 <donri> producing an error message if it doesn't parse as that type
02:03:53 <donri> import System.IO first
02:05:03 <bartavelle> I'd like to write generate a tree structure (for a non deterministic game solver) where the type of choices varies at every node (for complex games with many sequences), but I am not sure how to do this. Has anyone an idea ?
02:06:35 <donri> saze: the error message isn't great though, you might like to add an exception handler to write your own message, or use Text.Read.readMaybe with getLine
02:13:10 <saze> donri: supki: thanks, is there a parser a bit like "reads" that verifies something belongs to a typeclass rather than a type ? or do I have to handle all types in Num separately ?
02:16:47 <startling> :t fromInteger . read
02:16:48 <lambdabot> Num c => String -> c
02:17:30 <startling> saze: ^
02:19:55 <supki> saze: you need to be specific about what kinds of numbers you accept
02:21:17 <saze> supki: What if I accept all numbers ? (as my programm will function equally well with any numbers, whether it is a float, an Int, an Integer, a Double ...)
02:22:04 <mr-> > (fromInteger . read) "1.2" -- will not work, though
02:22:05 <lambdabot>  *Exception: Prelude.read: no parse
02:22:49 <supki> saze: I don't think you accept all numbers :)
02:23:06 <supki> saze: what about  Num b => Num (a -> b)  instance, for example?
02:23:24 <supki> or  Num [()]  instance
02:24:43 <donri> saze: i can write a Read instance for my Num type that parses "five" as 5. now try to use that as an integer
02:26:44 <saze> spuki: good call didn't think about that
02:32:24 <saze> thank you guys for your precious help, I'm going back to learning !
02:51:59 <startling> :t read :: (Num a, Read a) => String -> a
02:52:00 <lambdabot> (Num a, Read a) => String -> a
02:54:34 * hackagebot hopfield 0.1.0.1 - Hopfield Networks, Boltzmann Machines and Clusters  http://hackage.haskell.org/package/hopfield-0.1.0.1 (NiklasHambuechen)
03:00:17 <FliPPeh> Just a stylistic question, is it bad practice to name functions like the module they're in, like IRC.Channel.channelDoSomething or is it good enough to let the module names themselves resolve such ambiguities?
03:00:52 <augur> well
03:00:55 <augur> ive got a chart parser
03:00:57 <augur> so theres that
03:01:41 <tdammers> FliPPeh: matter of taste, I guess... there's been some discussion about this, but I'm not sure if there's any consensus
03:01:59 <Kyraimion> FliPPeh, I would say that depends on whether you expect the module to be imported qualified or not
03:03:41 <FliPPeh> So the answer is a crystal clear and unanimous "maybe"
03:03:46 <FliPPeh> Just as I suspected :D
03:03:54 <ReinH> I think it's better to not qualify the names
03:04:03 <ReinH> Give the importer the choice to qualify the module
03:05:20 <tdammers> indeed
03:05:26 <tdammers> I prefer non-prefixed names
03:07:24 <bearclaw> the import haskell system is quite flexible, but it puts a lot of the burden of doing it properly to the module end user I think
03:07:27 <FliPPeh> I think that's the C programmer in me
03:07:39 <FliPPeh> Prefix EVERYTHING
03:07:45 <bearclaw> you have to go through the symbols you use, figure out which are ambiguous and which are not
03:08:12 <bearclaw> I very often end up doing both an import qualified Stuff as Stuff and an import Stuff(a, b, c)
03:13:23 <tdammers> bearclaw: yeah
03:13:38 <tdammers> import qualified Data.Stuff as Stuff; import Data.Stuff (Stuff)
03:13:44 <tdammers> ^ that's a common pattern
03:14:28 <ReinH> happens a lot
03:14:32 <ReinH> Vector, Array, etc
03:15:07 <ReinH> import Data.Vector.StuffIWant; import qualified Data.Vector.OtherStuff as Vector
03:15:07 <bearclaw> this is realy a problem, especially for stuff like all the Text variants redefining readFile or stuff like that
03:15:26 <ReinH> bearclaw: not really? That's why qualified imports are a thing.
03:15:33 <tdammers> it's not a problem, just a nuisance
03:15:36 <bearclaw> I realy see this as some kind of shortcoming of the method resolution, or the way the libs are done
03:15:39 <ReinH> And how many different ways do you really need to read a file at the same time?
03:16:15 <ReinH> It doesn't feel like a problem in practice
03:16:24 <tdammers> I can actually see the use case for a typeclass that unifies the different I/O functions over the various stringish types
03:16:36 <bearclaw> If I decide to change which Text variant I use, I have to patch all uses of readLine in the code
03:16:39 <ReinH> tdammers: sure just get them all to agree.
03:16:44 <tdammers> well
03:16:47 <ReinH> bearclaw: or you could, you know, encapsulate that yourself
03:17:00 <ReinH> we have plenty of tools for encapsulation and abstraction
03:17:15 <tdammers> indeed... one could just make that typeclass oneself
03:17:22 <tdammers> which is what I do when I need it
03:17:33 <quicksilver> one approach for that kind of case is to import qualified as T and just change what T means
03:17:37 <quicksilver> i.e. change the import
03:17:39 <ReinH> if you need to patch a bunch of different code because you change one thing
03:17:44 <ReinH> that's not exactly a good thing
03:18:06 <tdammers> ReinH: it's not the end of the world either, at least not in Haskell
03:18:07 <quicksilver> actually creating a typeclass suggests you're writing code which is explicitl polymorphic over the stringish IO being done
03:18:08 <bearclaw> yes, this boils down to maturity of standard lib , when such common situations are not covered
03:18:19 <ReinH> tdammers: I mean, following the compiler around fixing stuff is ok
03:18:35 <quicksilver> which is quite unusual (because the choices have quite different points in the design space)
03:19:16 <tdammers> quicksilver: suppose I write a parser-combinator library - I really do want to support parsing from all sorts of stringish types
03:19:16 <ReinH> bearclaw: what common situations?
03:19:25 <sinclair|work> http://sinclair.cloudapp.net:5001/ <--- can someone help me test this with chrome ?
03:19:33 <quicksilver> tdammers: that's quite a good example.
03:19:47 <quicksilver> tdammers: one which (unless I've missed something recentish) is currently unsolved ;)
03:20:09 <quicksilver> tdammers: it's hard to design the right polymorphic API which is reasonable close to optimum performance on all the different types.
03:20:27 <quicksilver> presumably that's why so many of the real parsers hardcode for one or more specific types.
03:20:52 <tdammers> yes, indeed
03:21:04 <quicksilver> tdammers: in general library authors have more difficult problems of this type than application authors
03:21:04 <tdammers> and it's one of the reasons why I decided to write my own parser-combinator lib
03:21:20 <quicksilver> because library authors have to try to cater for all possible use cases (well as many as they can)
03:21:33 <tdammers> either that, or decide which use cases to exclude
03:22:04 <quicksilver> I think at some point people hoped that String was an appropriate universal type
03:22:17 <tdammers> hmm, yeah oh well
03:22:19 <quicksilver> because the various 'unpack' type functions could be fused straight into the consumer codes.
03:22:32 <quicksilver> perhaps we don't have SufficientlySmartCompilers after all.
03:22:44 <quicksilver> fusion turns out to be hard.
03:23:35 <tdammers> for my parcom lib, I leave the choice to the user; I just expose a typeclass that you can implement to hook the lib up with your favorite token-stream type, and I provide instances for String, ByteString and Text (both lazy and strict)
03:23:44 <augur> chart parsing in 34 lines of haskell!
03:23:50 <tdammers> they're not optimized for all use cases
03:24:31 <tdammers> and I might add attoparsec-style parsing for some types as an optimization
03:24:43 <quicksilver> tdammers: if your instances aren't optimised for all use cases, maybe you shuoldn't have provided a typeclass at all
03:24:58 <quicksilver> maybe you should have made it higher order and just let people supply a dictionary
03:25:05 <quicksilver> then they could write their own instances
03:25:09 <tdammers> they can
03:25:20 <quicksilver> not for the types you already wrote one for?
03:25:23 <quicksilver> or did I miss something?
03:25:52 <sinclair|work> quicksilver: got chrome mate?
03:25:54 <tdammers> the core lib imports only the instance for [a] (which includes String)
03:26:03 <tdammers> the others are in separate modules
03:26:26 <quicksilver> the globality of instances can trap people even if they're in separate modules
03:26:33 <tdammers> hmm, yes, true
03:26:34 <quicksilver> btu I'm not trying to poke holes
03:26:41 <quicksilver> just pointing out the shortcomings of typeclasses
03:26:50 <tdammers> if it turns out to be a problem, one can use the newtype hack
03:26:54 <quicksilver> true
03:27:38 <quicksilver> sinclair|work: I do, but I'm busy, your request didn't contain enough context for me to decide whether it was interesting to test. It didn't appear to be a questiona bout haskell programming.
03:28:14 <sinclair|work> http://sinclair.cloudapp.net:5001/webrtc
03:28:17 <sinclair|work> in chrome
03:28:27 <sinclair|work> im trying to test connectivity for P2P
03:30:09 <tdammers> anyway, I'm currently the only user of that library, so meh
03:30:14 <sinclair|work> quicksilver: actually, don't worry mate
03:30:39 * quicksilver wonders if that is distributed-process-azure
03:32:13 <quicksilver> tdammers: like I say, not intending to be negative, I'm interested in how you've approached and solved those problems. I just like to tell people why I dislike type classes from time to time :)
03:32:21 <sinclair|work> quicksilver: nah
03:32:58 <sinclair|work> quicksilver: if i want to go elastic scale, id wouldn't be rolling a VM for that :)
03:33:05 <sinclair|work> well, not one i manage at least
03:33:15 <tdammers> quicksilver: no hard feelings ;)
03:33:25 <sinclair|work> quicksilver: amazon beanstalk seems fairly capable at elastic scale tho
03:33:35 <tdammers> quicksilver: http://hackage.haskell.org/package/parcom-lib
03:33:55 <tdammers> for some reason the haddock doesn't appear
03:38:31 <kartoffelbrei> tdammers: had the same problem, this script helped https://github.com/haskell/hackage-server/issues/56#issuecomment-26980828
03:40:15 <tdammers> so basically I should build them manually instead of relying on hackage to do it for me?
03:47:22 <kartoffelbrei> pretty much.
04:08:09 <ReinH> I think I'm going to have to do some Rust
04:15:32 <gienah> ReinH: fyi: there are improvements to new haskell io manager that will be released in ghc 7.8.1, that allow it to run concurrent threads on multiple cores
04:15:55 <merijn> gienah: That was already possible for ages
04:16:01 <hpc> haha
04:16:12 <merijn> gienah: The new IO manager improved the garbage collector to make it not suck :p
04:16:28 <hpc> patch notes: the concurrency that's been in the standard library for years is now actually concurrent
04:16:48 <FliPPeh> I feel I was being lied to for many years
04:17:02 <FliPPeh> :v
04:17:05 <hpc> merijn: i would hardly say the current gc sucks ;)
04:17:48 <merijn> hpc: Well, it's basically impossible to scale beyond 6-8 cores with the 7.6 GC
04:18:05 <merijn> Maybe 10 if you're *really* IO bound
04:18:11 <hpc> ah
04:18:40 <merijn> hpc: One of the major improvements of the 7.8 IO manager is that that scaling has drastically improved
04:19:03 <hpc> i don't think i have any boxes with 10 cores, probably why i never heard about this
04:19:29 <gienah> ReinH: there is a paper about it, note that it basically implements the "future work" from the earlier new io event manager paper
04:19:31 <merijn> hpc: Neither do I, we benchmarked it on a university machine to prove a point
04:19:40 <gienah> http://www.reddit.com/r/haskell/comments/1k6fsl/mio_a_highperformance_multicore_io_manager_for/
04:19:50 <hpc> merijn: at least it's not the $26 bug ;)
04:20:01 <merijn> My point being: "I bet a naive haskell implementation scales way better than our C 100k LOC buggy implementation"
04:20:44 <hpc> a usually true assertion
04:20:45 <merijn> Haskell did end up scaling better than the C code up to about 14 cores, after which the GC did it in
04:21:27 <ReinH> gienah: about what?
04:21:56 <gienah> ReinH: it was just fyi - like because you said you were thinking of hacking Rust
04:22:11 <ReinH> gienah: Oh I'm familiar with the paper.
04:22:34 <gienah> ok, neat
04:24:53 <ReinH> gienah: and Haskell can already do multicore quite well
04:25:20 <gienah> ReinH: yeah - I haven't tried Rust
04:26:00 <hpc> haskell is webscale
04:26:09 <hpc> it supports sparks and multiple capabilities
04:26:25 <Iceland_jack> Did someone say ‘web scale’? My ears are burning
04:26:43 <ReinH> merijn: I thought the new IO manager also improved the locking
04:26:46 <ion> http://fratti.ch/2webscale4u/
04:26:54 <merijn> hpc: I thought it was webscale because of acme-php?
04:27:12 <augur> edwardk: i have a chart parser thats 34 lines of code :T
04:27:28 <silver> woohoo, enterprise-level webscale solution for all of your problems including small penis
04:27:31 <merijn> ion: Nice :)
04:27:43 <augur> and parses 2.67 million bracketings of a^15 in ~10s
04:28:00 <merijn> ion: Doesn't mention node, though :p
04:30:28 <quchen> Maybe we should cloud-enable Haskell too
04:30:35 * Hodapp hits quchen with a stick
04:30:37 <jmcarthur> i don't feel like ghc's default number of phases for purposes of inlining and rewrite rules is large enough. does that mean i am approaching it wrong, or does that seem like it's not too crazy of a possibility?
04:30:46 <ion> quchen: The project cloud be called, say, Cloud Haskell.
04:30:58 <ion> That typo was totally unintentional.
04:30:59 <quicksilver> jmcarthur: it's possible that you are crazy
04:31:20 <quicksilver> jmcarthur: that is a common side-effect of trying to understand the GHC inliner/rewriter
04:31:51 <quchen> ion: I just wanted to use my new buzzword! :-(
04:32:11 <jmcarthur> i'm trying to control the phases of some inlining and rewrite rules i have, and then i want some stream fusion to work *after* my own phase control, but stream fusion needs phase control too, and i've already used up its phases by then
04:32:11 <merijn> quicksilver: s/GHC inliner/rewriter/GHC ?
04:32:18 <quicksilver> jmcarthur: aside from that, no, I can well believe that complex (but sensible) optimisation schemes need more phases.
04:32:22 <merijn> well, that doesn't parse, I guess
04:32:29 <quicksilver> merijn: some bits are more brain breaking that others :)
04:33:17 <jmcarthur> i guess on the plus side i have a way out, but it means overriding the default number of phases. this is a library, too, so it means users would also have to do that :(
04:33:21 <merijn> quicksilver: I read a pigworker paper without ever learning type theory, my brain is now break resistant ;)
04:33:51 <merijn> and/or permanently fractured, you choose...
04:35:26 <jmcarthur> for that matter, it's kind of sad that phases are absolute values
04:35:45 <quicksilver> jmcarthur: be slightly better if they were infinite precision floating point
04:35:46 <jmcarthur> i can't say "i want this to work before these rules in this other library i don't control"
04:35:53 <quicksilver> PHASE 2.4500000102
04:36:04 <quicksilver> why don't people use dense orders more often in computer programs?
04:36:22 <quicksilver> (a partial order would be another approach of course
04:36:25 <quicksilver> with constraints.
04:37:43 <mr-> do we have rational fixities yet?
04:37:46 <jmcarthur> fractional phase numbers would be better, actually, so that i can insert phases between existing ones
04:38:16 <jmcarthur> well, i could do that with partial ordering too i guess. i made a silly assumption by saying that
04:38:17 <int-e> 10 precedences are enough for anyone.
04:38:52 <mr-> except if they aren't :-)
04:38:57 <merijn> Let's make fixity complex, that way GHC can parse however it likes a rationalise it in hindsight!
04:40:01 <tdammers> Let's just ban infix notation from our language entirely, solving the precedence problem once and for all!
04:40:11 <tdammers> *cough*lisp*cough*
04:44:54 <lieven_> tdammers: and at the same time introduce macros :)
04:45:17 <tdammers> not all lisps have messy macros
04:45:38 <tdammers> or maybe they do, I'm not that much of a lisper
04:45:40 <lieven_> the good ones have
04:45:42 <hpc> some lisps have /really/ messy macros
04:45:46 <hpc> like elisp
04:46:03 <hpc> where the only thing better than writing code at runtime is writing dynamic-scoped code at runtime
04:46:10 <hpc> excuse me, "compile time"
04:46:18 <merijn> hpc: Sounds like my kind of language!
04:46:53 * hpc struggles to hold down rant on runtime vs compile time
04:47:38 <lieven_> any interesting language needs read time, macro expansion time, compile time, run time and different environments in all of them
04:48:22 <jmcarthur> there are other interesting possibilities
04:49:07 <jmcarthur> run time could also be interleaved with partial evaluation and compilation, for example
04:49:25 <jmcarthur> perhaps even replacing the static compilation phase
04:49:33 <quicksilver> also interleaved with hardware design and manufacture
04:49:35 <jmcarthur> some macro expansion uses also being replaced
04:49:38 <jmcarthur> haha
04:49:42 <quicksilver> so your execute keeps creating better computers to run on
04:51:14 <lieven_> just in time ASIC design
04:56:39 <himynameisben> Hi , I am a massive noob (had 4 lectures on it) and next week I have an assessed talk with him on it. I'm going to make sure I have the basics down but our prof said he wants us to teach him something he doesn't know. I dont know how extensive his knowledge is but does anyone have an idea of something I could teach him (and understand myself)? Thanks
04:58:16 <quchen> As an unbiased third party I recommend Haskell.
04:58:26 <ReinH> himynameisben: what is this "it" of which you speak?
04:58:51 <himynameisben> sorry Haskell in general
04:59:06 <Iceland_jack> himynameisben: Haskell is excellent, just ask quchen!
05:00:16 <ghorn__> himynameisben: what sort of things are you interested in, to give us some ideas of what might be relevant?
05:04:01 <himynameisben> ghorn__: I honestly don't know what is possible, so far done some basic stuff with lists (zip,folding,mapping and a bit of sorting) so maybe something to do with that if possible?
05:04:58 <ghorn__> have you heard of a zipper?
05:05:10 <ghorn__> they're pretty neat
05:06:19 <ghorn__> http://learnyouahaskell.com/zippers#focusing-on-lists
05:06:42 <ReinH> or some basic comonads
05:07:10 <ReinH> since we're talking about zipper-y things
05:07:37 <merijn> himynameisben: It depends a bit on your own comfort level?
05:08:26 <merijn> I'm not sure how intensive your 4 lectures were :)
05:08:59 <merijn> Maybe GADTs?
05:09:10 <merijn> They're pretty cool and not that hard
05:09:13 <Hodapp> GADT just looks like it should stand for something really profane.
05:09:17 <ReinH> step 1: ask him what he doesn't know.
05:09:25 <himynameisben> Yeah I'd say I'm about the standard on chapter 5 on learn you a haskell (so not far). I think I'll carry on progressing through it and hopefully I'll get to zippers, they sound
05:09:40 <himynameisben> cool*
05:09:46 <merijn> himynameisben: You could try https://en.wikibooks.org/wiki/Haskell/GADT
05:10:01 <merijn> himynameisben: If that's to complicated at the moment, just get back to them later
05:10:55 <Hodapp> ReinH: but what do you do with folks who answer that with "nothing that's important or interesting"?
05:16:18 <ReinH> Hodapp: decide that they are liars?
05:20:13 <FliPPeh> I noticed a common pattern in my code, namely "maybe defaultValue id someMaybeValue"
05:20:22 <FliPPeh> Is there already a function that does pretty much that?
05:20:25 <tdammers> fromMaybe
05:20:30 <tdammers> :t fromMaybe
05:20:31 <lambdabot> a -> Maybe a -> a
05:20:56 <FliPPeh> Many thanks!
05:38:24 <osa1> I'd like to ask a question about "implementing fun langs: a tutorial" if anyone here has that book in hand right now :-)
05:42:39 <joquer> hi
05:42:44 <joquer> help
05:43:19 <joquer> I Have problems installing wxc 0.90.0.4
05:43:30 <joquer> I want to install wx
05:44:36 <joquer> I build and install wxWidgets 3.0.0
05:45:54 <joquer> and wxc seeks version 2.8
05:59:08 <ReinH> osa1: you could also ask it if they don't...
06:00:41 <osa1> okay here's the question: in graph reduction system I don't understand why we need indirection nodes, it's use in page 49 looked completely redundand to me. why not instead have a node (* (sqrt 4)) ? (instead of (* (# (sqrt 4))))
06:00:42 <osa1> ReinH: ^
06:04:59 * hackagebot grid 7.6 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.6 (AmyDeBuitleir)
06:09:03 <jmcarthur_mobile> osa1: I'm out of context, but indirection nodes are often necessary when you need to mutate a node but can't resize it in memory so that new new state can fit
06:09:34 <jmcarthur_mobile> osa1: so you can just change to an indirection instead and point to a new block on the heap
06:10:31 <jmcarthur_mobile> osa1: you need the indirection because you don't always have the ability to just mutate the node's parent to point to the new node instead
06:10:42 <jmcarthur_mobile> *parents
06:12:12 <osa1> jmcarthur_mobile: that kind of thing makes sense but the example in the book does not make sense to me .. not sure if I'm missing anything.
06:16:04 <danilo2> Hello :) Are there any special haskell accelerate / repa irc channels, or should I ask related questions here?
06:21:23 <FliPPeh> And once again I find that developing in haskell happens in 3 steps: program something, see all the patterns where you repeat yourself and build abstractions for them and then find the standard library function that does exactly that
06:39:46 <tdammers> FliPPeh: yes, and I think it's a good pattern
06:40:06 <tdammers> although with a bit of experience,you'll get to step 3 before you're too far into step 1
06:43:32 <ReinH> FliPPeh: hoogle is your friend
06:43:55 <ReinH> @hoogle a -> Maybe a -> a
06:43:55 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
06:43:55 <lambdabot> Prelude asTypeOf :: a -> a -> a
06:43:55 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
06:48:34 <YuleAthas> I really wish fromLeft/fromRight functions were standard...
06:53:45 <joquer> wxc-0.90.0.4 have prooblems
06:53:56 <joquer> in eljgrid
06:53:58 <joquer> .cpp
06:54:59 <joquer> src/cpp/eljgrid.cpp:756:30: warning: ‘bool wxGrid::CanDragColSize() const’ is deprecated (declared at /usr/local/include/wx-2.9/wx/generic/grid.h:1837)
06:55:20 <joquer> wxWidgets 2.9.5
06:55:29 <tdammers> wx is quite a beast
06:56:08 <joquer> help me
06:56:23 <tdammers> sorry, can't :(
06:56:39 <joquer> alternatives to wx
06:56:41 <tdammers> I tried getting wx into a working state a while ago but gave up
06:56:47 <tdammers> postponed the project :)
06:56:48 <tdammers> :(
06:57:43 <joquer> :(
06:58:51 <identity> hmm
06:58:59 <identity> so even newest version of hlint doesn't deal with multiwayif
06:59:00 <identity> :/
06:59:07 <identity> can someone confirm that?
07:01:02 <Twey> joquer: It's just a deprecation warning; if you're not the maintainer of eljgrid.cpp, don't worry about it
07:01:12 <Twey> (or maybe report it as a bug to whoever is)
07:01:41 <joquer> I think that is wxWidget
07:01:45 <joquer> version
07:02:05 <joquer> in my sys I have 2.9.5
07:02:32 <Twey> Apparently it's part of the wxHaskell wrapper.  Make sure you're using the latest version of wxHaskell, and then report it to the maintainer.
07:02:37 <joquer> and I think that the available is 2.9.4
07:03:20 <Twey> To wxhaskell-devel@lists.sourceforge.net apparently
07:03:22 <joquer> wxc is the problem and cabal info wxc say only available with wxWidgets 2.9
07:03:38 <joquer> and 2.9 have 5 branches
07:03:39 <Twey> But your program should still run if it's only issuing a deprecation warning.
07:04:05 <joquer> it doesn't worl
07:04:09 <joquer> *work
07:05:04 <joquer> and wxc branches are 0.90.0.(0, 1, 2,3 4)
07:05:06 <joquer> 5?
07:05:54 <Twey> joquer: Looks like the highest version of wxWidgets currently supported is 2.9; 3.0 might not work
07:06:21 <joquer> aaah!
07:06:34 <joquer> then I uninstall 2.9.5
07:06:42 <joquer> and I'll install 2.9.3
07:06:56 <Twey> (or at least that's the latest version mentioned in the commit messages on GitHub)
07:07:10 <joquer> but 2.9 have 2.9.1
07:07:12 <joquer> 2.9.2
07:07:16 <joquer> 2.9.3
07:07:19 <joquer> 2.9.4
07:07:23 <joquer> and 2.9.5
07:07:33 <Twey> They're minor versions; I'd imagine it doesn't matter all that much
07:07:48 <joquer> I have 2.9.5 and don't work
07:07:56 <joquer> I'll install 2.9.4
07:08:25 <Twey> You'll need to give an error message if you want more specific help.  ‘Doesn't work’ doesn't really tell us anything.
07:09:11 <shapr> Hi, my code doesn't work.
07:09:12 * shapr grins
07:09:34 <Twey> shapr: You are bad people :þ
07:10:22 <joquer> sorry, my english is not good
07:11:39 <joquer> hehe
07:13:48 <merijn> shapr: That explains the C on your final :p
07:15:11 <shapr> merijn: haha, yes!
07:15:32 <shapr> merijn: I really should have put more time into Discrete Math, especially since the proofs were surprisingly Haskell-friendly.
07:16:08 <merijn> shapr: Oh, high-five, discrete math messed me up as well, albeit a while back :p
07:18:36 <identity> discrete math is fun
07:18:55 <Twey> I'm not sure ‘discrete math’ is a useful category, but I like it
07:19:22 <osa1> do I get stack overflow in Haskell if I apply too many arguments? like f n1 n2 ... n10000000 ?
07:19:42 <Twey> osa1: Probably not
07:20:12 <osa1> Twey: I'm currently reading about stack reduction machines and it looks like function application requires a stack
07:20:16 <Twey> You generally get a stack overflow from building up too big a thunk; whether that occurs when you apply too many arguments or not depends on the strictness properties of your function
07:20:17 <johnw> osa1: it's not that kind of stack
07:20:36 <osa1> johnw: what kind of stack is it?
07:20:37 <johnw> Haskell has an "evaluation stack", but not a runtime call stack in the usual sense
07:20:41 <osa1> I know
07:20:54 <johnw> the evaluation stack is for partially evaluated thunks during pattern matching
07:21:00 <osa1> johnw: well obviously call stack in usual sense doesn't overflow in long applications :-)
07:21:31 <osa1> but there is also a stack involved when applying functions, right? I'm looking for a way to overflow it
07:21:33 <johnw> so, if you recurse in such a way that it can't fully determine which pattern match to apply in each case, you'll blow that stack
07:21:43 <johnw> to my knowledge, there is no such stack
07:21:49 <osa1> hmm
07:24:01 <osa1> I'm about to finish my implementation of graph reduction thing and I'll try that long fun application (I know it may not be the exact execution model of Haskell but still ...)
07:24:51 <Phlogistique> osa1: well, to call f a0 a1 a2 ... an you would first need to define f
07:25:17 <osa1> Phlogistique: so?
07:25:41 <Phlogistique> I guess you would prolly hit an other kind of implementation limit before
07:26:09 <osa1> Phlogistique: f x = f ?
07:26:17 <Phlogistique> osa1: try it
07:26:18 <osa1> hmm that doesn't work for typing reasons
07:26:18 <mr-> you think there's a limit to the function-type?
07:26:21 <osa1> > let f x = f
07:26:22 <lambdabot>  not an expression: `let f x = f'
07:26:29 <osa1> let f x = f in f
07:26:32 <shapr> Express yourself!
07:26:33 <osa1> > let f x = f in f
07:26:34 <lambdabot>  Occurs check: cannot construct the infinite type: t1 = t0 -> t1
07:27:00 <osa1> hm
07:37:38 <ziman> @pl \n -> f n (g n)
07:37:38 <lambdabot> ap f g
07:40:11 <Feuerbach_> johnw, Twey, osa1: stack overflow is usually caused by a deep recursion. That in turn may or may not be caused by laziness; that's kind of orthogonal. E.g. something like foldr 0 (+) [1..largeNum] would overflow the stack despite not allocating any thunks
07:42:40 <Twey> @src foldr
07:42:40 <lambdabot> foldr f z []     = z
07:42:40 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:42:43 <lingxiao> hey all, could someone explain to me what this is:
07:42:48 <Twey> Feuerbach_: It allocates plenty of thunks
07:42:51 <lingxiao> and how to use it, and why it's needed
07:43:00 <lingxiao> https://gist.github.com/anonymous/7aaeecdd3a8d62070ed8
07:43:13 <Twey> Oh, actually, never mind
07:43:22 <lingxiao> as opposed to these two ways of expressing the datatype:
07:43:25 <lingxiao> https://gist.github.com/anonymous/05b9aa6da5a13d9f5dd1
07:44:03 <Twey> lingxiao: It captures information in the type
07:44:22 <lingxiao> what information? like the "kind"?
07:44:25 <Twey> And doesn't take a parameter for the constructors
07:45:11 <Twey> lingxiao: Int → Ty3 means it takes an Int and produces a Ty3, but the type of the TyInt constructor in your first example is Ty Int: it takes no parameters and produces something of type Ty Int
07:46:01 <Twey> Quite what that means depends on how the type is used, but it can be used for something like indicating an interpretable value that yields an Int when interpreted
07:46:26 <lingxiao> so how should I declare an instance of Ty?
07:46:30 <lingxiao> or TyInt I mean
07:48:25 <Twey> lingxiao: It's a type, not a class.  There's only one value of type Ty Int, which is the constructor TyInt
07:52:43 <lingxiao> so I can just write `let x = TyInt`, and its type is `Ty Int`. but this is where I'm confused, there's no Int in x
07:54:33 <Twey> lingxiao: There's no Int in an ‘IO Int’ either
07:55:08 <Twey> :t replicate
07:55:09 <lambdabot> Int -> a -> [a]
07:55:35 <Twey> IO and Ty are both type functions.  A Ty Int doesn't have to return something containing an Int for the same reason replicate doesn't
07:55:53 <Iceland_jack> @let data Foo a b = Null deriving Show
07:55:53 <lambdabot>  Defined.
07:55:57 <Twey> … well, if you squint at it a bit.  :þ
07:55:58 <Iceland_jack> > Null :: Foo Int String
07:55:59 <lambdabot>  Null
07:56:00 <Iceland_jack> @undef
07:56:00 <lambdabot> Undefined.
07:56:10 <lingxiao> Twey : ahh so I could refined `Mabye` like this?
07:56:14 <lingxiao> https://gist.github.com/anonymous/f14c5ef4d506d4399653
07:56:44 <lingxiao> as an example, not sure why I need it, but the point is I can express it
07:56:56 <Twey> That's not quite Maybe, but sure
07:57:18 <Twey> Er
07:57:46 <Twey> Actually, that is Maybe, plus the NothingI constructor
07:58:46 <lingxiao> is Ty2 in `data Ty2 = TyInt2 Int | TyBoo2 Bool deriving (Show)` a type function as well?
07:58:47 <Iceland_jack> If you have a
07:58:47 <Iceland_jack>     foo :: MaybeA a -> a
07:58:47 <Iceland_jack>     foo NothingI = ?
07:58:47 <Iceland_jack> ? must have type Int
07:58:57 <Iceland_jack> lingxiao: It's a type constructor
07:59:08 <Iceland_jack> it's not a functor
07:59:10 <Iceland_jack> *function
07:59:20 <Iceland_jack> @data Ty2 = TyInt2 Int | TyBoo2 Bool deriving (Show)
07:59:20 <Twey> lingxiao: No, it's just a type
07:59:20 <lambdabot> Unknown command, try @list
07:59:23 <Iceland_jack> @let data Ty2 = TyInt2 Int | TyBoo2 Bool deriving (Show)
07:59:23 <lambdabot>  Defined.
07:59:29 <Iceland_jack> @kind Ty2
07:59:30 <lambdabot> *
07:59:37 <Iceland_jack> @kind Maybe
07:59:37 <lambdabot> * -> *
07:59:38 <Iceland_jack> @undef
07:59:38 <lambdabot> Undefined.
08:00:49 <lingxiao> @kind Maybe
08:00:50 <lambdabot> * -> *
08:01:37 <lingxiao> but `Maybe` is a kind function
08:01:52 <Twey> lingxiao: No it isn't
08:02:01 <Twey> Maybe takes a type to a type: it's a type function
08:02:11 <Twey> Its kind is * -> *
08:02:38 <`^_^v> i think he just meant its a nice function to have around
08:02:41 <lingxiao> sorry I meant type function
08:03:44 <lingxiao> ok when I add one more value constructor to Ty
08:03:45 <Twey> So what was the ‘but’ for?
08:04:29 <lingxiao> Twey: I was just trying to understand that declaring datatypes using this syntax: `data Ty : * -> * where`
08:05:07 <lingxiao> is not different from this way: `data Ty a = ... `
08:05:11 <lingxiao> https://gist.github.com/anonymous/082cd0a923ca50d251b0
08:05:15 <Twey> lingxiao: There are two things involved here: the GADT (the ‘where’ syntax) and the kind signature (∷ * → *)
08:05:56 <lingxiao> is it represented differently when it's all converted to Core?
08:06:15 <Twey> Pass
08:06:46 <Twey> I would imagine everything gets converted to GADTs with explicit kind signatures, but I'm not qualified to say for sure :þ
08:06:51 <lingxiao> `^_^v : hahaha I'm slow ..
08:06:52 <Twey> Try it and see
08:07:16 <Twey> -fdump-core to GHC will produce a .hcr file containing the Core
08:07:33 <lingxiao> oh word i tried reading that once, my head exploded
08:07:39 <lingxiao> lol D:
08:07:54 <lingxiao> so I don't understand why: https://gist.github.com/anonymous/082cd0a923ca50d251b0
08:08:11 <lingxiao> I can declare some value constructor: `TyStg :: Int -> Int -> Ty Bool`
08:08:20 <lingxiao> for a `Ty` of kind `* -> *`
08:08:36 <lingxiao> since `TyStg` would have kind `* -> * -> *`
08:08:52 <Twey> lingxiao: TyStg is a value, not a type.  It has a type, not a kind.
08:09:02 <lingxiao> sorry yeah just abou to correct myself
08:09:03 <Twey> (specifically, type Int → Int → Ty Bool)
08:09:19 <lingxiao> so it's allowed/
08:09:30 <Twey> When you specify a constructor in GADT notation, you do so by giving its type directly
08:09:31 <Twey> Yes
08:10:06 <Twey> Something like Int → Int → Ty Bool Int would not be allowed, because you'd be providing two (type) arguments to Ty where its kind says it only takes one
08:10:23 <lingxiao> ah that clears it up!
08:10:45 <lingxiao> yeah all the value const. for Ty have diffferent arities it looks like hahaa
08:10:54 <lingxiao> so when is it a good time to use GADTs?
08:11:24 <lingxiao> like what specifically could be expressed by GADTs but couldn't by the old fashion ways of declaring data types
08:11:54 <Twey> GADTs let you restrict the types allowed to be passed to your type constructor to a certain subset of types, by making the constructors return things of different types
08:12:52 <Twey> Before GADTs there was a pattern where you'd provide a type like data Foo a = Foo a and then ‘restrict’ it by hiding the constructors and only exporting functions of types like Int → Foo Int, so you can guarantee that if you have a Foo it's a Foo Int
08:12:57 <lingxiao> wait so in this example:
08:13:00 <lingxiao> https://gist.github.com/anonymous/472ee4c681ce579f6f38
08:13:21 <lingxiao> specifically what could be expressed by Ty3 that couldnt in Ty2?
08:13:22 <Twey> GADTs let you do that right in the constructor, so you can use all the usual pattern-matching notation, and it also helps out the type-checker
08:13:50 <Twey> lingxiao: Nothing; those two definitions are equivalent (apart from the Show instance)
08:14:10 <Twey> But GADTs can also express constructors that return e.g. Ty Bool, which the traditional syntax can't
08:15:32 <Kron> if you use record syntax, can you still use the normal field syntax?
08:15:38 <Kron> (Thing _ _ _ _)?
08:15:40 <Twey> Kron: Yes
08:15:43 <Kron> okay!
08:15:55 <Twey> Kron: But you might want to consider using RecordWildCards instead
08:16:03 <lingxiao> Twey: like in this pair: https://gist.github.com/anonymous/bc4f5ad8bd8cd40286b3
08:16:11 <Twey> Which is shorter and avoids order-dependency
08:16:11 <Kron> what are those?
08:16:41 <lingxiao> now what can you do with this: `data Ty :: * -> * where` that you cannot do with this: `data Ty a where`
08:16:46 <Twey> Kron: data Foo = Foo { x, y, z ∷ Int }; foo Foo { .. } = {- all of x, y, and z are in scope here, with the values from the argument -}
08:16:49 <lingxiao> aside from explicity kind signature
08:17:13 <lingxiao> Twey: the gist above was to your poing about "GADTs can also express constructors that return e.g. Ty Bool"
08:17:16 <Twey> lingxiao: When you start using things like DataKinds, you can restrict the type of a to e.g. an Int
08:17:16 <Kron> is that something I have to import?
08:17:20 <lingxiao> point*
08:17:46 <Twey> Kron: {-# LANGUAGE RecordWildCards #-}
08:19:00 <Kron> hmm
08:19:37 <Twey> Kron: More generally, Foo { .. } means Foo { x = x, y = y, z = z }; you can use it for building records, too
08:20:11 <lingxiao> Twey: I'm not sure what you mean, I'm assuming you mean the PRAGMA DataKinds?
08:20:12 <Twey> (though that's a bit hairier IMO, since you can accidentally pull in things from the environment you didn't mean to)
08:20:50 <lingxiao> are you saying I can write `data Ty Int where ..` but cannot restrict the paramter to type Int in `data Ty: * -> * where` .. ?
08:21:05 <Twey> lingxiao: Yes.  DataKinds promotes all type declarations to the kind level.  So you can talk about types parameterized on Ints, for example (things of kind Int → ★).
08:21:07 <lingxiao> so GADT is more expressive than the delcaration with kind signature
08:21:29 <quicksilver> does the 'adam' who wrote http://www.well-typed.com/blog/84 IRC?
08:21:34 <lingxiao> awesome star btw, and the arrow. wonder how you got those
08:22:23 <Twey> lingxiao: The GADT and the kind signature are orthogonal: you can write GADTs without kind signatures, too.  GADTs let you restrict the type of the value constructors; kind signatures let you restrict the kind of the *type* constructor in the same way.
08:22:45 <Twey> lingxiao: I have keys for them in my keymap
08:25:39 <lingxiao> Twey: ok things are a lot clearer now, thanks!
08:28:14 <Fuuzetsu> Twey: we all know you search for the symbols online and then copy and paste them into your chat window
08:29:39 <Twey> Haha
08:29:57 <Twey> Fuuzetsu: I used the star; now you've seen it
08:30:18 * hackagebot digestive-functors 0.6.2.0 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.6.2.0 (JasperVanDerJeugt)
08:31:10 <Fuuzetsu> Twey: not quite in an actual source file though, was it?
08:32:54 <Twey> Picky
08:41:57 <osa1_> ahh, almost working https://gist.github.com/osa1/7930901 :P
08:42:49 <osa1_> uh, looks like function application parsed completely wrong
08:43:08 <allsystemsarego> :t over
08:43:08 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
08:43:19 <allsystemsarego> @hoogle over
08:43:20 <lambdabot> Graphics.UI.GLUT.Callbacks.Window overlayDisplayCallback :: SettableStateVar (Maybe DisplayCallback)
08:43:20 <lambdabot> Graphics.UI.GLUT.Overlay overlayPossible :: GettableStateVar Bool
08:43:20 <lambdabot> Graphics.UI.GLUT.Overlay overlayVisible :: SettableStateVar Bool
08:43:30 <Iceland_jack> it's from lens
08:43:32 <tinyghost> p stab
08:43:36 <allsystemsarego> :t Control.Lens.over
08:43:36 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
08:44:05 <allsystemsarego> lambdabot, is silly today
08:44:22 <edwardk> > over _2 length ("hello","world")
08:44:24 <lambdabot>  ("hello",5)
08:44:53 <Kron> I'm getting a very interesting unification error
08:45:14 <Cale> allsystemsarego: What's silly?
08:45:19 * hackagebot scotty-fay 0.0.2 - Fay integration for Scotty.  http://hackage.haskell.org/package/scotty-fay-0.0.2 (hdgarrood)
08:45:46 <Cale> > over _1 (*2) (5,"hello")
08:45:47 <lambdabot>  (10,"hello")
08:46:05 <haasn> > (5,"hello") & _1 *~ 2
08:46:06 <lambdabot>  (10,"hello")
08:46:13 <allsystemsarego> actually @hoogle is silly for not pointing me exactly where over is
08:46:21 <Cale> ah
08:46:38 <quicksilver> lambdabot's hoogle index probably doesn't have the lens libraries?
08:46:43 <Cale> Perhaps the hoogle database hasn't been updated with lens
08:46:55 <edwardk> there is one at fpcomplete that has lens in it, iirc
08:47:49 <quicksilver> https://www.fpcomplete.com/hoogle?q=over&env=ghc-7.4.2-stable-13.09
08:48:03 <allsystemsarego> thanks
08:48:05 <quicksilver> ^^ that one gives lens as third hit
08:48:35 <Kron> do you guys ever run into an issue where removing the type declaration is the only way to let a larger function and a helper function unify?
08:49:00 <Twey> No
08:49:13 <Twey> That just means your type declaration is wrong :þ  Ask GHCi what it ought to be
08:49:13 <Kron> okay, then I am probably doing something wrong
08:49:22 <Kron> how do I do that for a scoped helper?
08:49:33 <Kron> the helper is entirely trapped within a larger function
08:50:00 <Feuerbach_> Kron: you may need to use scoped type variables
08:50:07 <Kron> elaborate
08:50:18 <Kron> and it does seem to be an issue involving scoping
08:50:27 <Kron> i'm comparing values from the larger function with values inside the helper function
08:50:35 <Kron> and it can't unify them unless I remove my helper type declaration
08:50:35 <quicksilver> yes, there are cases where there is no possible way to give a type to the helper function
08:50:39 <quicksilver> (in standard haskell)
08:50:47 <Feuerbach_> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
08:50:51 <Kron> that is quite silly
08:50:54 <quicksilver> yes, it is.
08:51:00 <quicksilver> there are, however, reasons.
08:51:16 <quicksilver> anyway, the scopedtypevariable extension is the well understood solution
08:51:21 <Kron> what does 'forall' even mean? It seems to mean so many things...
08:51:32 <Twey> Kron: Lift it out
08:51:41 <Kron> well what if I don't want to stretch this scopedtypevariable extension across my whole program and just want to encapsulate it here or something
08:51:58 <Kron> Twey, I'm trying to avoid that
08:52:33 <Kron> too many helper functions in the global space just makes it... more difficult to read and more difficult to know what's doing what
08:52:55 <Kron> this helper really has no use outside this one specific function
08:53:01 <johnw> does anyone have any idea why commenting out the putStrLn in the following function causes it to "gum up"?  https://gist.github.com/7931066
08:53:10 <osa1_> how can I undo :set +t  in ghci?
08:53:22 <Cale> Kron: Which forall are you having trouble interpreting? It really only means one thing, but depending on where it occurs, it can have a bunch of consequences.
08:53:23 <johnw> a specific usage of gatherFrom that I'm using takes 3s without the putStrLn, and 0.1s with
08:53:26 <allsystemsarego> does anyone have an example of using Parsec to parse tokens other than string characters? I've asked the same question yesterday and didn't get a very clear answer
08:53:45 <Twey> Kron: Lift it out, find out what its type is, then put it back
08:53:49 <Kron> Cale: I did not know that, I was under the impression it meant entirely different things in different contexts
08:54:14 <burbul> IS there any extension which lets you write {a} for Set a ? (Just like you can write [a] for List a.)
08:54:29 <Iceland_jack> burbul: No
08:54:30 <Cale> burbul: nope
08:54:31 <donri> burbul: upcoming GHC has OverloadedLists
08:54:32 <Kron> burbul: Template Haskell?
08:54:40 <donri> burbul: then you can write [a]
08:54:42 <Kron> TH will let you write your own macros like that
08:54:47 <Cale> donri: Really?
08:54:47 <Iceland_jack> donri: Not for the type
08:54:50 <donri> Cale: yep
08:54:57 <donri> oh you want it for the type?
08:54:58 <Twey> donri: Eh?  In the type too?
08:54:59 <Cale> donri: I wouldn't think the *type constructor* would be overloaded
08:55:05 <donri> not in the type no, i don't think
08:55:06 <Twey> That would be scary
08:55:06 <Iceland_jack> Set a is a type
08:55:15 <Iceland_jack> at least that's what I assume burbul meant
08:55:27 <Twey> Kron: It means ‘a type argument goes here’, but unfortunately ScopedTypeVariables uses that also to introduce a scope.
08:55:46 <burbul> We're using a lot of sets in our code, and it would make the type signatures a little nicer.
08:55:50 * donri rather wishes [a] was written (List a) in types :P
08:56:01 <burbul> Just as [a] is a little nicer than List a.
08:56:04 <burbul> Sugar!
08:56:15 <burbul> donri: ymmv
08:56:16 <Iceland_jack> I personally wouldn't mind a little sugar :) {a} for 'Set a' and 'singleton a', {k: v} for 'Map k v' and 'singleton k v'
08:56:23 <johnw> donri: type List a = [a]
08:56:27 <donri> johnw: ;)
08:56:35 <burbul> anyway, thanks
08:57:03 <Cale> Kron: Well, in GHC, it's not treated in a terribly uniform way, largely because Haskell originally never let you quantify your type variables explicitly, and also because just allowing it everywhere and then recovering decent type inference is tricky, so the places where it's allowed to occur have been carefully considered.
08:57:12 <quicksilver> [a]/[a] is a troubling overloading
08:57:13 <Twey> Why stop there?  {a, b} for Set.fromList [a, b], {a: b, c: d} for Map.fromList [(a, b), (c, d)]
08:57:41 <Iceland_jack> Twey: Yes I just omitted that :) I believe most Haskellers are against this though
08:57:44 <quicksilver> because "type of lists of a" is more general but "singleton list containing just the value a" is more specific.
08:57:48 <Twey> Though braces seem like a bad idea
08:57:49 <Kron> Cale: okayy
08:58:15 <quicksilver> (Int,String)/(3,"foo") at least has some kind of universal substitution going for it.
08:58:23 <Twey> Iceland_jack: All we need to do is introduce Agda-style mixfix syntax, and everything's solved.
08:58:29 <Iceland_jack> Twey: Exactly!
08:58:35 <Iceland_jack> [ a ] doesn't look very nice though
08:58:43 <Twey> (except the problems of the poor people who have to work on the parser)
08:59:00 <donri> quicksilver: data Just a = Just a | Unjust!
08:59:05 <Cale> (But if you turn on all the extensions now, it's allowed pretty much everywhere. I'm not sure how well-supported ImpredicativeTypes is though)
08:59:06 * donri hides
09:00:35 <int-e> donri: now think of a good semantics for 'justify'.
09:02:04 <int-e> donri: (I'm leaning towards  justify :: Just a -> a where justify (Just a) = a; justify Unjust = justify Unjust
09:02:07 <int-e> )
09:02:09 <donri> is this edwardk's style of "name driven development"? "i already have a name for it, now i just need to use it for something"
09:03:03 <Feuerbach_> Just need
09:03:42 <donri> justice is blind, but maybe with lenses...
09:15:06 <Twey> Is there a perspective matrix function in linear?
09:15:23 * hackagebot scotty-fay 0.1.0 - Fay integration for Scotty.  http://hackage.haskell.org/package/scotty-fay-0.1.0 (hdgarrood)
09:16:54 <Kron> can we use guards in case-of expressions?
09:17:07 <Peaker> yeah
09:17:08 <Kron> case x of (x:xs) | ... -> | ... ->
09:17:09 <Kron> okay
09:17:29 <Peaker> and lesser known: where clauses for each case too
09:18:24 * Hodapp looks at the Collatz conjecture
09:18:38 <mm_bureau> sometimes i would find it useful to have a super-where that applies to all patterns
09:18:56 <Hodapp> mm_bureau: any relation to mm_freak?
09:19:06 <mm_bureau> Hodapp: /whois mm_bureau
09:19:07 <mm_bureau> =)
09:19:25 * mm_bureau is da mm_freak in da bureau =)
09:19:42 <Hodapp> waaait, it says you're logged in as mm_freak, how does that work?
09:20:00 <mm_bureau> Hodapp: either GROUP or IDENTIFY for mm_freak
09:20:09 <Peaker> mm_bureau: put it in the outer binding clause (func def or what not)
09:20:37 <mm_bureau> Peaker: which looks like this:  f = f' where …; f' … = …
09:21:05 <Peaker> why would you do that? :)
09:21:29 <mm_bureau> Peaker: to have common non-global utility functions for every pattern
09:23:56 <jophish> Yo yo yo, Arrows seem to be nice and useful. Has any thought gone into arrows for tuples of length != 2?
09:24:31 <jophish> I can think of a couple of use cases for 3-arrows
09:24:32 <davean> jophish: how does that differe from (a, (b, c))?
09:24:36 <implementation> :t on
09:24:37 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
09:24:38 <davean> for a 3-tupple
09:24:56 <jophish> davean: it's a little more clunky, that's all
09:25:10 <Kron> is there... like... a zippable typeclass?
09:25:21 <simpson> Kron: Traversable is similar; why?
09:25:22 <mm_bureau> jophish: the arrow pattern is built around cascaded tuples
09:25:28 <Kron> where two structures can be sort of compared element by element in an isomorphic fashion?
09:25:34 <mm_bureau> jophish: see for example (| banana bracket |) notation
09:25:41 <Kron> I was just building some functions for a quadtree implementation of mine
09:25:42 <jophish> mm_bureau: I'll take a look
09:25:48 <Kron> and they had a very similar recursive pattern
09:26:05 <Kron> kind of a simultaneous search on both trees while comparing elements and the like
09:26:10 <mm_bureau> jophish: the best documentation i have found for them is the GHC manual itself…  it's a bit difficult to wrap your head around them without an actual use case
09:26:13 <Kron> was just curious
09:26:24 <Cale> Kron: There is... somewhere.
09:26:25 <mm_bureau> Kron: zippable?  like Applicative?
09:26:31 <Cale> Let me dig it up
09:27:03 <mm_bureau> Kron: if your quadtree is a zipping Applicative, then zip = liftA2
09:27:08 <mm_bureau> zipWith = liftA2
09:27:15 <simpson> :T arr (\(a, (b, c)) -> (a, b, c)) -- jophish
09:27:20 <Kron> sadly, it isn't applicative. At least, not in this instance.
09:27:22 <simpson> :t arr (\(a, (b, c)) -> (a, b, c)) -- jophish
09:27:23 <lambdabot> Arrow a => a (t, (t1, t2)) (t, t1, t2)
09:27:25 <Kron> it's QuadTree a where Eq a
09:27:35 <Kron> due to the Eq constraint I can't make it truly applicative
09:27:37 <Kron> afaik
09:27:48 <mm_bureau> Kron: do you need the Eq constraint at the type definition?
09:28:07 <Kron> not quite, it's an Eq constraint at a particular branch of functions involving inserting and extracting elements from the tree
09:28:18 <Kron> within this branch of functions, I found myself using these zip structures
09:28:30 <Kron> so the zip question only really makes sense in the context of these Eq constraints
09:28:32 <Cale> http://hackage.haskell.org/package/keys-3.10/docs/Data-Key.html
09:28:35 <Cale> there it is
09:28:39 <mm_bureau> Kron: then it doesn't appear to be a problem to implement an Applicative instance
09:28:43 <Cale> class Functor f => Zip f where ...
09:28:51 <Kron> ooh
09:28:55 <Kron> mm_bureau: elaborate
09:29:48 <mm_bureau> Kron: for example this is a zipping or expanding applicative: data QuadTree a = Leaf a | Branch (QuadTree a) (QuadTree a) (QuadTree a) (QuadTree a)
09:30:04 <Kron> hmmmmm
09:30:06 <mm_bureau> zipping = ZipList, expanding = []
09:30:13 <eyebloom> How might I resolve a duplicate instance for instance Foldable ((,) a) ... I guess this compiled in earlier versions of Ghc but now the compiler sees ((,) a) as being equivalent to some other type.
09:30:15 <mm_bureau> just to understand the difference
09:30:56 <Kron> I'll be honest, applicative functors do kind of whoosh over my head
09:31:17 <Kron> I'll probably get back to that later, I'm gonna try to finish what I've started here already
09:31:45 <Kron> I'm wondering if it's even reasonable to try to Eq entire QuadTrees
09:32:08 <mm_bureau> Kron: a zipping applicative means roughly this:  if 'fs' and 'xs' have the same structure, then 'fs <*> xs' is the functions in fs applied to the values in xs at the same positions
09:32:11 <Kron> yeah, I think i'm making a mistake here...
09:32:33 <Kron> ah
09:32:36 <Kron> interesting
09:32:52 <mm_bureau> Kron: where they differ in structure, the leafs are simply discarded…  just like if in zipWith one list is longer than the other, the extra elements are discarded
09:33:44 <mm_bureau> oh and the type i presented was wrong =)
09:34:03 <mm_bureau> data QuadTree a = Leaf | Branch a (QuadTree a) (QuadTree a) (QuadTree a) (QuadTree a)
09:34:08 <mm_bureau> that's a zipping quadtree
09:35:13 <mm_bureau> Kron: the Applicative instance for this type is easy enough to implement, so give it a try =)
09:36:12 <cariveri> hi.   Not in scope: `set'
09:36:16 <cariveri> what is missing?
09:36:52 <pavonia> context
09:36:52 <Kron> I may
09:36:58 <Kron> for now, I'm building a lens
09:37:02 <Kron> out of a getter and setter
09:37:22 <Kron> and doing my best to kowtow to the lens laws while also doing garbage collection and fusing equivalent leafs (the Eq stuff)
09:37:25 <edwardk> it isn't a big jump from that to defining it directly
09:37:34 <Kron> so I'll fall into the applicative abyss later
09:37:55 <edwardk> > let _2 f (a,b) = (,a) <$> f b in ("hello",2) & _2 .~ "Kron"
09:37:56 <lambdabot>  ("Kron","hello")
09:37:57 <cariveri> in IO I want to  set font_size_tag [ textTagSize := 4 ]
09:38:03 <edwardk> > let _2 f (a,b) = (a,) <$> f b in ("hello",2) & _2 .~ "Kron"
09:38:05 <lambdabot>  ("hello","Kron")
09:39:08 <Kron> for all the bellyaching about lens operator creep, "over both (`mod` n) tuple" is one of the nicest ways i've ever seen for applying functions across elements in an int,int pair
09:40:18 <yitz> Kron: *** always worked fine for me. (not saying that lens isn't nice though)
09:40:21 <Cale> Kron: Yes. The core ideas of lens are great
09:40:26 * hackagebot cabal-install-bundle 0.16.0.2.1 - The (bundled) command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-bundle-0.16.0.2.1 (BartoszCwiklowski)
09:40:54 <Cale> > join (***) (`mod` 4) (20,27)
09:40:55 <lambdabot>  (0,3)
09:41:02 <Kron> I'm kinda glad I slogged through this, lenses are really pretty once you get to know them
09:41:36 <Kron> okay, so how exactly does one create a simple lens once they have a getter and a setter?
09:41:54 <Kron> thing = lens getter setter?
09:41:55 <Cale> I don't think & is in any way necessary, and I don't like most of the infix operators that the lens package defines, but thankfully there are prefix versions of most things.
09:42:09 <Cale> That's one way
09:42:13 <edwardk> i confess to an outside observer it may lk like lens goes a bit wild making sure everything fits into the paradigm, but from my perspective using the library, the major limitation of older lens libraries was that they had a very narrow "band of applicability" and once you fell out of it you had to rewrite all your code some other way, and had wasted time. With lens my goal was to pull that "band of applicability" as wide apart as I
09:42:15 <edwardk>  could, to make sure I didn't have the experience of falling out of it and having to scrap and start over to whatever extent was possible.
09:42:40 <simpson> & is nice for defining modifiers that act on multiple parts of a structure at once.
09:42:44 <edwardk> It isn't really written for outreach so much as for making sure that once you are caught in its web you don't get forced out easily
09:42:55 <Cale> :t (&)
09:42:56 <lambdabot> a -> (a -> b) -> b
09:43:02 <Kron> edwardk: I'd love to see some sort of language mod where this basically replaces record field syntax
09:43:08 <Kron> it's a really elegant design
09:43:11 <edwardk> Kron: wait for ghc 7.10
09:43:17 <Kron> I tried listening to your 2 hour presentation on it
09:43:24 <Cale> ^^ it's really easy to rewrite anything which uses (&) into something which doesn't, and which I'd argue is more idiomatic
09:43:25 <edwardk> Kron: then it becomes much more tightly coupled with records
09:43:25 <yitz> edwardk: that was a good goal and we all appreciate that you were able to do it
09:43:41 <Kron> most of the math went over my head but I did get the basic gist of just wrapping getters and setters together and doing combinatorial rodeo
09:44:22 <Clint> edwardk: is there an ETR for adjunctions 4.0?
09:44:51 <edwardk> Clint: if i don't get to it by this weekend you officially have license to give me shit about it constantly.
09:44:59 <Clint> haha ok
09:45:31 <edwardk> sorry. started merging representable-functors and adjunctions together and have been deciding if i want to merge distributive in as well as it is provably the same, etc.
09:46:04 <edwardk> then i kind of got stuck on a conference-after-conference-after-talk-after-conference world tour that just ended ;)
09:49:01 <Kron> ghci> x^.atLocation(2,0)
09:49:01 <Kron> 1
09:49:05 <Kron> hmm, what is this sugar for?
09:49:13 <Kron> view x . atLocation (2,0)?
09:50:12 <mm_bureau> Kron: it's not sugar
09:50:19 <mm_bureau> Kron: x ^. atLocation (2, 0)
09:50:23 <Kron> I mean
09:50:29 <Kron> I know it's actually a proper operator
09:50:32 <Kron> not magic, technology
09:50:35 <Kron> but what's the non-operator form
09:50:46 <Cale> ^. is view
09:50:48 <Kron> ahhh
09:50:55 <Kron> so "view x atLocation (2,0)"
09:50:56 <Kron> ?
09:51:02 <Cale> > view (atLocation (2,0)) x
09:51:03 <lambdabot>  Not in scope: `atLocation'
09:51:11 <Kron> gotcha
09:51:22 <Kron> awesome :D
09:51:28 <Kron> yesss, it's woooorking
09:51:38 <Kron> how do I set things again? %=? 'over'?
09:52:04 <Cale> 'set'?
09:52:30 <Cale> :t set
09:52:30 <lambdabot> ASetter s t a b -> b -> s -> t
09:53:08 <edwardk> %~   is over     .~   is set
09:53:45 <Kron> so how would I set something then
09:53:58 <Kron> x .~ atLocation (2, 0) 0?
09:54:07 <joelteon> :t set _2
09:54:08 <lambdabot> Field2 s t a b => b -> s -> t
09:54:10 <Cale> set (atLocation (2,0)) 0 x
09:54:30 <Kron> awesome :D
09:54:32 <Kron> it wooorks
09:54:48 <Kron> I've been spending days on this. :P
09:55:52 <Cale> Or if you really like the infix operator, you could write  atLocation (2,0) .~ 0 $ x
09:55:59 <Kron> hmmm, when I true to use "Lens'" in my type declaration, it tells me it's an illegal polymorphic type
09:56:10 <hattmammerly> so, those functions that exist for any number of parameters (looking at you, (,,)). how can one define these?
09:56:16 <Cale> Does it suggest an extension to turn on?
09:56:29 <Kron> -XRankNTypes
09:56:30 <Cale> hattmammerly: Those are all separate
09:56:45 <Kron> hattmammerly: template haskell I guess
09:56:48 <Cale> Kron: Add {-# LANGUAGE RankNTypes #-} to the top of your module
09:56:50 <Kron> which isn't real haskell
09:56:55 <Cale> (,,) is built in
09:57:05 <hattmammerly> Cale: yes, but surely there isn't a function defined for every single function until infinity
09:57:09 <Cale> and (,) is a completely separate built in thing
09:57:21 <Cale> Right, in practice, there's a limited number of them
09:57:31 <Cale> The Report guarantees that they exist up to some finite limit
09:57:45 <Cale> (I forget what, I never really use more than pairs anyway)
09:58:34 <hattmammerly> so these are all really individually-defined functions? there's no trick?
09:58:35 <Cale> There is no upper bound on the size of a tuple, but some Haskell implementations may restrict the size of tuples, and limit the instances associated with larger tuples. However, every Haskell implementation must support tuples up to size 15, together with the instances for Eq, Ord, Bounded, Read, and Show. The Prelude and libraries define tuple functions such as zip for tuples up to a size of 7.
09:58:42 <Cale> ^^ from the Report
09:58:47 <hattmammerly> I gave the tuple as an example
09:58:54 <Cale> There's no trick there
09:59:02 <hattmammerly> also exhibiting this is zipWith, zipWith3, so on
09:59:21 <Cale> There are tricks you can pull with typeclasses to get "variadic" functions
09:59:38 <hattmammerly> oh nevermind I guess zipWith only goes to 3
10:00:19 <Cale> If you have tuples with too many components, you tend to be better off defining your own datatype anyway
10:00:37 <Cale> So there's rarely a need for anything larger than a pair, or an occasional triple.
10:00:41 <vmalloc> Quick question - I remember there was some kind of an idiom in Haskell for performing two computations returning Maybe, only evaluating the second if the first returns Nothing (a form of logical 'or'). Do I remember correctly?
10:00:48 <hattmammerly> this was a generic question and (,,) was the function I thought of off the top of my head that exhibits this behavior
10:01:08 <hattmammerly> not actually using tuples, or implementing anything in particular
10:01:11 <hattmammerly> thanks for the info!
10:01:26 <Cale> vmalloc: mplus
10:01:35 <Cale> > Just 5 `mplus` Just 6
10:01:36 <lambdabot>  Just 5
10:01:39 <Cale> > Nothing `mplus` Just 6
10:01:40 <lambdabot>  Just 6
10:01:46 <Kron> what exactly is the risk of scoped type variables anyway?
10:02:02 <Cale> Kron: Risk?
10:02:03 <vmalloc> Cale: thanks!
10:02:19 <Kron> yeah, someone here said that you lose the ability to generate proper type inferences in some cases
10:02:23 <Kron> when you allow in scoped type variables
10:02:42 <Cale> uhhh, I don't think that's true.
10:03:03 <jophish> Who would like a little golf. I'd like to generate the list: [first pred, second pred, first succ, second succ, pred *** pred, pred *** succ, succ *** pred, succ *** pred] Or something equivalent
10:03:16 --- mode: ChanServ set +o Cale
10:03:22 --- mode: Cale set +b *!*@*.Red-2-138-161.dynamicIP.rima-tde.net
10:03:22 --- kick: golongrina was kicked by Cale (golongrina)
10:03:32 <Cale> (privmsg spam)
10:03:35 <Kron> ah.
10:03:38 <Hodapp> eeep
10:03:40 <Kron> Was just... wondering.
10:03:45 --- mode: Cale set -o Cale
10:03:55 <jophish> this is the best I've got: let x = [id, pred, succ] in tail $ liftM2 (zipWith (***)) x x
10:04:25 <joelteon> join (liftM2 (zipWith (***))) [id, pred, succ]
10:06:08 <jophish> joelteon: I'm not sure that's quite right
10:06:11 <Kron> how do the Getter and Setter types work?
10:06:23 <joelteon> well, that's how you simplify the last bit of that
10:06:51 <bennofs> Hmm, there is HaXML, hxt, hxt-monad (not on hackage, last commit 6 months ago), conduit-xml, tagsoup, xml, xml-monad, hexpat. I don't know what to choose when :|
10:07:54 <Cale> Don't forget hexpat-pickle!
10:07:56 <Cale> ;)
10:08:27 <bennofs> and then there is xml-picklers
10:08:41 <joelteon> hxt!
10:08:49 <jophish> joelteon: I can't get it to typecheck,
10:10:15 <joelteon> jophish: I can't get yours to typecheck either
10:12:01 <jophish> joelteon: join (liftM2 (zipWith (***))) [[id], [pred], [succ]] works
10:12:48 <jophish> concat $ join (liftM2 (zipWith (***))) [[id], [pred], [succ]] works*
10:13:16 <quchen> s/concat/join/
10:13:22 <quchen> (Shorter) :-)
10:13:28 <Cale> join (liftM2 (***)) [id, pred, succ]
10:14:49 <jophish> hmm, I don't know where my zipwith came from :/
10:14:51 <jophish> Cale: ah
10:15:00 <bennofs> @index zipWith
10:15:00 <lambdabot> Data.List, Prelude
10:15:01 <joelteon> how do you make an arbitrary function into an Expr? I forget
10:15:36 <rtpg> [| |
10:15:44 <rtpg> [| |] rather
10:16:18 <joelteon> no, that's Exp
10:16:22 <joelteon> Expr is from simple-reflect
10:16:34 <rtpg> ah, sorry, just got here
10:17:03 <donri> bennofs: i like xml-picklers
10:26:54 <piezoid> hi
10:26:58 <piezoid> in the middle of a function signature (forall a. f a) is a generalisation of (f a), right ?
10:27:10 <rtpg> if a isn't bound before, yes
10:27:21 <rtpg> or rather, it's the same thing
10:27:26 <johnw> that all depends
10:27:30 <johnw> can you show us the whole signature?
10:28:11 <rtpg>  a -> b is shorthand for (forall a b. a -> b )
10:28:12 <dwcook> I'm writing a procedure that runs a game server but accepts a function that determines what, of a limited subset of actions, could be taken when I receive input from any client. Does it sound sensible to write a GADT of those actions? I notice many of them are similar to State, but at least one, DisconnectClient, doesn't quite fit.
10:28:17 <piezoid> I'm trying to wrap 'cata :: (Lam a -> a) -> ExpO a -> a' to '(Lam b -> b) -> (forall a. ExpO a) -> b'
10:28:50 <johnw> piezoid:  in that case I believe it means something very different
10:29:08 <johnw> piezoid: (forall a. ExpO a) means that a is not fixed, and the argument must cover any a
10:29:09 <rtpg> cata is definitely more specific
10:30:04 <piezoid> johnw: if so, I can convert it to a fixed type and call cata with it ?
10:30:20 <johnw> no, you cannot
10:30:21 <rtpg> piezoid, no
10:30:30 <johnw> the forall prevents that from happening in that case
10:31:14 <rtpg> a -> (b -> b ) and a-> (forall b. b-> b) are different thigns
10:31:31 <dwcook> It occurs to me that I might be trying to abstract too much too early. I'll try being dumb about it.
10:31:32 <rtpg> one takes an a , and generates a function of b to b, b being fixed
10:31:43 <rtpg> whereas one takes an a, and generates a function that can take any type
10:31:58 <Kron> what exactly is the memory overhead of unresolved thunks?
10:31:59 <Peaker> rtpg: in the first one, there's an implicit "forall b." before the type, right?
10:32:02 <johnw> yeah, I think "const id" would be pretty much the only implementation of that function, barring _|_
10:32:12 <rtpg> yeah, Peaker
10:32:18 <Kron> if you build a structure where many branches of it are consciously left unresolved and are never meant to be touched, you get a lot of thunk fringes
10:32:29 <Kron> should I just resolve them all to some new constructor Empty or something
10:32:31 <johnw> a -> (b -> b) == forall a b. a -> (b -> b)
10:32:37 <Peaker> rtpg: so the difference is only superficial
10:32:57 <Peaker> rtpg: it amounts mostly to argument ordering
10:32:57 <johnw> Peaker: the difference is one of rank
10:33:12 <johnw> a -> (forall b. b -> b) == forall a. a -> (forall b. b -> b)
10:33:15 <johnw> that's very different
10:33:24 <johnw> one is a Rank-1 function type, the other is a Rank-2 function type
10:33:48 <piezoid> I'm reproducing the code in this paper, dection 2.2 : http://www.seas.upenn.edu/~sweirich/papers/bgb-jfp.pdf
10:33:51 <Peaker> well, the forall can just be lifted outside
10:34:01 <johnw> Peaker: yeah?  try it
10:34:11 <johnw> they are two different types
10:34:15 <rtpg> if I have f:: (forall a b. a-> b -> b)
10:34:23 <Peaker> johnw: http://www.haskell.org/haskellwiki/Rank-N_types says that forall can be lifted out so it's still rank 1?
10:34:54 <rtpg> f 2 :: b -> b , but b is fixed to some type
10:34:58 <Peaker> johnw: a -> forall b. ... b ...       is equivalent to   forall b. a -> ... b ...    (up to lifting stuff around)
10:35:11 <johnw> from that page: forall a. a -> (forall b. b -> a)
10:35:18 <johnw> that's not (forall b. b -> b)
10:35:33 * hackagebot azurify 0.4.0.0 - A simple library for accessing Azure blob storage  http://hackage.haskell.org/package/azurify-0.4.0.0 (GregWeber)
10:35:43 <johnw> hmm
10:35:49 <Peaker> johnw: it's not a significant difference
10:35:50 <piezoid> I can make a wraper taking a newtype Exp = Exp { unExp :: forall a. ExpO a }, and it work
10:35:51 <johnw> a later thing it states implies that it could be done
10:36:01 <johnw> "For example: (forall a. a -> a) -> (forall b. b -> b) is a Rank-2 type because the latter forall can be moved to the start but the former one cannot."
10:36:14 <Peaker> johnw: left of (->) forall's are meaningful.  right-of-(->) are just shuffled around (Arg orders)
10:36:16 <piezoid> but I don't clearly see the difference...
10:36:20 <johnw> oh, if I think about that in terms of partial application, it makes sense
10:36:35 <johnw> a -> (forall b. b -> b), partially applied to a, returns forall b. b -> b
10:36:35 <Peaker> johnw: "forall a" is just an extra [implicit] argument (a : *) -> ...
10:36:37 <johnw> which is just rank-1
10:36:56 <Peaker> so flipping that argument with the first arg gives Rank1
10:37:03 <rtpg> I wish there were good examples for this, I don't know any
10:37:09 <Peaker> a -
10:37:14 <Peaker> oops.
10:38:16 <Peaker> forall a. a -> forall b. foo      is basically:  (a : *) -> (x : a) -> (b : *) -> foo     so of course it is equivalent to:   (a : *) -> (b : *) -> (x : a) -> foo    which is  forall a b. a -> foo
10:38:23 <Peaker> (where foo may mention a and/or b)
10:39:05 <Peaker> (a : *) ->   (the "Pi" type that takes a type of kind *, and names it 'a' for the right-hand-side to use)
10:39:40 <Peaker> though I think older GHC respected http://www.haskell.org/haskellwiki/Rank-N_types and called right-of-(->) a Rank1 type, but newer GHC now calls it a Rank2 type
10:39:48 <Peaker> (but maybe I'm confused and it's the other way around)
10:43:44 <piezoid> how can I force the user to provide a polymorphic type and use it with a specific type ?
10:45:18 <Peaker> piezoid: like: runST :: (forall s. ST s a) -> a
10:45:43 <stepkut> how come pi is in the Prelude but not tau :(
10:46:18 <Kaidelong> what's wrong with 2*pi
10:46:34 <piezoid> Peaker: I think this is what I'm doing
10:47:05 <bennofs> How does cabal-install install a package? Does it first resolve dependencies, then write setup/dist-config, and then run Setup.hs?
10:47:27 <stepkut> Kaidelong: it's 33% longer!
10:47:39 <bennofs> s@setup/dist-config@dist/setup-config@g
10:48:02 <piezoid> Peaker: http://lpaste.net/96913
11:00:36 * hackagebot dirfiles 0.1.0.0 -   http://hackage.haskell.org/package/dirfiles-0.1.0.0 (HugoGomes)
11:04:22 <Peaker> piezoid: you just have to ETA expand it
11:04:58 <int-e> @pl
11:04:59 <lambdabot> (line 1, column 1):
11:04:59 <lambdabot> unexpected end of input
11:04:59 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
11:05:01 <Peaker> piezoid: also use Rank2Types extension, not ImpredicativeTypes
11:05:03 <int-e> @pl \x -> () x
11:05:04 <lambdabot> (line 1, column 9):
11:05:04 <lambdabot> unexpected ' '
11:05:04 <lambdabot> expecting variable, "(", operator or end of input
11:05:36 <Peaker> seems like a GHC limitation with RankNTypes
11:08:32 <haasn> > let fibs@(_:xs) = 0 : 1 : zipWith (+) fibs xs in fibs
11:08:34 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:09:28 <oscarvarto> Hello! Does anyone use vim to program in Haskell? I am new to both, and I am struggling trying to "install" this https://github.com/lukerandall/haskellmode-vim
11:09:45 <oscarvarto> How can I produce a vim ball with that source code?
11:10:11 <johnw> > let fibs = 0 : 1 : liftM2 (zipWith (+)) id tail fibs in fibs
11:10:12 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:11:02 <int-e> piezoid, Peaker: Right, ghc can only instantiate 'forall' at the root of types. (so unifying  forall a. ExpO a  with  ExpO b  succeeds)
11:11:15 <cschneid> oscarvarto: vimballs are an outdated way to deal with plugins. Go check out stuff like `vundle` for a nice way to manage & install plugins, and keep them separated
11:11:33 <oscarvarto> cschneid: Thanks
11:12:01 <oscarvarto> Maybe this is a better approach? https://github.com/bitc/vim-hdevtools
11:12:28 <int-e> Which makes sense if you look at System F (or GHC core), where this becomes an explicit application of a type,  (y @ b)
11:12:33 <cschneid> oscarvarto: hdevtools + syntastic is my basic setup.
11:12:48 <cschneid> it's not 100% of what I'd want, but plenty good for my noobish programming uses :)
11:12:58 <donri> oscarvarto: yeah, haskellmode is old and... weird. there are better alternatives for most of the things it does
11:13:12 <johnw> haskell-mode is not old
11:13:16 <johnw> it's being actively developed
11:13:16 <piezoid> Peaker: ok, thanks
11:13:23 <donri> johnw: for vim?
11:13:27 <johnw> ohh
11:13:34 <johnw> sorry, didn't know that "haskellmode" was its own thing
11:13:36 <int-e> (oh. nobody knows what 'y' is. It from this line, the result of eta-expanding iter0 = cata: iter0 x y = cata x y)
11:13:46 <oscarvarto> cschneid: OK. I will try that
11:14:01 <oscarvarto> donri: what do you use?
11:14:30 <donri> oscarvarto: my own vim-haskell and vim-cabal that i don't recommend you try quite yet
11:15:34 <donri> oscarvarto: well for haskellmode alternatives i use vim-hdevtools and ghcmod-vim (they do the same thing, but with different tradeoffs :P) and neco-ghc
11:18:10 <haasn> Anybody here participating in the Munich Haskell meeting?
11:19:05 <donri> oscarvarto: oh and https://github.com/eagletmt/unite-haddock should cover the haddock functionality in haskellmode, though i haven't used either much
11:19:31 <oscarvarto> donri: Thanks a lot for sharing your knowledge
11:28:01 <udevd> :t init
11:28:02 <lambdabot> [a] -> [a]
11:28:06 <udevd> hm
11:29:08 <udevd> @def list2Tuple lst = read $ "(" ++ (init.tail.show) lst ++ ")"
11:29:09 <lambdabot>  Defined.
11:29:22 <udevd> > list2Tuple [1..100]
11:29:24 <lambdabot>  *Exception: Prelude.read: no parse
11:29:32 <udevd> > list2Tuple [1,2]
11:29:34 <lambdabot>  *Exception: Prelude.read: no parse
11:29:34 <oscarvarto> donri: How do I "run" a program with vim-hdevtools?
11:29:44 <[swift]_> so i'm hitting what appears to be a GHC runtime bug that has been fixed in GHC 7.8. how bad is it going to be to upgrade a current haskell platform installation with ghc 7.6.3? do i need to wipe everything out and start from scratch?
11:29:57 <udevd> >read$ "(" ++ "1,2,3"++")"
11:30:05 <udevd> >read$ "(" ++ "1,2,3"++")" :: (Int,Int,Int)
11:30:11 <quchen> udevd: What are you trying to do? 'read' is almost never the answer.
11:30:28 <udevd> i'm just trying if this works
11:30:37 <udevd> apparently, it isn't
11:30:49 <supki> you need a space after >
11:31:01 <scott_> :t list2Tuple
11:31:02 <lambdabot> (Read a, Show a1) => a1 -> a
11:31:18 <scott_> > list2Tuple [1..5] :: (Int, Int, Int, Int, Int)
11:31:19 <lambdabot>  (1,2,3,4,5)
11:31:49 <haasn> @def tuple2List = toListOf each
11:31:50 <lambdabot>  .L.hs:142:23:
11:31:51 <lambdabot>      No instance for (Each (Accessor (Endo [b0])) s0 s0 b0 b0)
11:31:51 <lambdabot>        arising from a use of `each'
11:31:51 <lambdabot>      The type variables `s0', `b0' are ambiguous
11:31:51 <lambdabot>      Possible cause: the monomorphism restriction applied to the following:
11:32:02 <haasn> :t toListOf each
11:32:03 <lambdabot> Each (Accessor (Endo [b])) s s b b => s -> [b]
11:32:05 <haasn> grr
11:32:09 <haasn> stupid monomorphism restriction
11:32:14 <haasn> > toListOfEach (1,2,3,4,5]
11:32:15 <lambdabot>  <hint>:1:24: parse error on input `]'
11:32:16 <haasn> > toListOfEach (1,2,3,4,5)
11:32:17 <lambdabot>  Not in scope: `toListOfEach'
11:32:24 <haasn> > toListOf each (1,2,3,4,5) -- I'm sane, I swear
11:32:26 <lambdabot>  [1,2,3,4,5]
11:32:33 <supki> > undefined & partsOf each .~ [1..5] :: (Int, Int, Int, Int, Int)
11:32:34 <lambdabot>  (1,2,3,4,5)
11:32:43 <quchen> Glad we solved this completely unrelated problem.
11:32:51 <StoneCypher> huhu
11:32:52 <haasn> > undefined & partsOf each .~ [1..5]
11:32:53 <lambdabot>  Couldn't match type `Control.Lens.Each.Index a0'
11:32:53 <lambdabot>                with `Control.Lens.Each.Index a1'
11:32:53 <lambdabot>  NB: `Control.Lens.Each.Index' is a type function, and may not be injective
11:32:53 <lambdabot>  The type variables `a0', `a1' are ambiguous
11:32:53 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
11:33:13 <haasn> oh, it doesn't know the length of the tuple
11:33:28 <haasn> > (0,0,0,0,0) & partsOf each .~ [1..5]
11:33:30 <lambdabot>  (1,2,3,4,5)
11:34:27 <scooty-puff> :t partsOf
11:34:28 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
11:38:02 <donri> oscarvarto: you don't, so not sure what you're asking :)
11:38:33 <scott_> oscarvarto: I use these three keybindings with hdevtools: https://github.com/tsion/dotvim/blob/master/vimrc#L168-L170
11:39:52 <scott_> F1 shows the type of the thing under the cursor, F1 again gives you the type of the enclosing expression and so on. F2 clears/resets that. F3 is just info about thing under cursor.
11:39:57 <oscarvarto> donri: I just typed a simple program, then load it from gchi with :load, then "run" it
11:40:18 <oscarvarto> what is <silent>
11:40:19 <oscarvarto> ?
11:40:21 <donri> oscarvarto: i don't follow. how do you run it in ghci?
11:40:36 <oscarvarto> scott_: ^
11:40:55 <scott_> oscarvarto: Makes it so it doesn't show me the ":HdevtoolsType" in the command window when I type F1, iirc
11:41:04 <donri> yes
11:41:19 <oscarvarto> donri: I call a function
11:41:41 <donri> oscarvarto: ok, vim will suck for embedding ghci, so don't :)
11:42:29 <oscarvarto> donri: I am using a split terminal window with vim in one half, ghci in the other half
11:43:30 <scott_> So what is it you want to accomplish / do you still have any questions?
11:45:16 <[swift]_> does anyone have sitting around the link to that github gist explaining how to install ghc HEAD and get cabal up and running? i can't seem to find it with google =\
11:47:19 <Kron> I'm getting the strangest error with GHCi, or at least, I think it's an error. I'm not sure.
11:47:35 <Kron> summarizing it with some ghci output:
11:47:41 <Kron> ghci> let p n = putStr $ printZone n
11:47:41 <Kron> ghci> :t p
11:47:41 <Kron> p :: Show a => QuadZone a -> IO ()
11:47:41 <Kron> ghci> let p = putStr . printZone
11:47:41 <Kron> ghci> :t p
11:47:41 <Kron> p :: QuadZone () -> IO ()
11:47:48 <Kron> I'm not sure why it would do that.
11:47:53 <joelteon> yeah, monomorphism restriction
11:47:54 <Kron> Also in retrospect I should've probably pastebinned that
11:47:55 <Kron> sorry
11:48:04 <Kron> what's the monomorphism restriction?
11:48:08 <rtpg> in terms of the semantics of haskell, does IO have a specific meaning?
11:48:09 <donri> @where dmr
11:48:09 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:48:16 <Kron> ooh
11:48:17 <scott_> Kron: :set -XNoMonomorphismRestriction and try again
11:48:19 <Kron> thank you lambdabot
11:48:19 <rtpg> based off of the STG paper, I have the feeling that it doesn't
11:48:45 <Philonous_> Kron, Try adding a type annotation
11:48:53 <Philonous_> Kron, To p, I mean
11:49:08 <Kron> hmmm
11:49:09 <Kron> okay
11:49:09 <lingxiao> hey all I have a question about GHC
11:49:25 <lingxiao> when you have some signature with polymorphic types "a -> a -> Bool"
11:49:32 <haasn> rtpg: http://www.haskell.org/onlinereport/haskell2010/haskellch7.html#x14-1420007
11:49:36 <haasn> would probably answer most of your questions
11:50:01 <lingxiao> the compiler has to  know that the first and second paramters must be of the same type
11:50:19 <lingxiao> does anyone know what this particular constraint is called, and how it's implemented in GHC?
11:50:48 <lingxiao> and where I can go to read the explanation of it, including which source file if possible
11:50:56 <lingxiao> I've got this open: https://ghc.haskell.org/trac/ghc/browser/ghc/compiler/coreSyn/CoreLint.lhs
11:51:03 <lingxiao> but I dont seem to see it
11:51:25 <lingxiao> furthermore: a paramterized signature is even more interesting: `f (m a) -> m a`
11:52:19 <scott_> lingxiao: I don't know much about how it's implemented, but are you familiar with unification?
11:52:41 <lingxiao> vaugely familar, in the context of natural language processing
11:52:51 <scott_> Consider these:
11:52:52 <scott_> :t map
11:52:53 <lambdabot> (a -> b) -> [a] -> [b]
11:52:54 <scott_> :t id
11:52:55 <lambdabot> a -> a
11:53:29 <haasn> lingxiao: equality constraint? guessing it's the same as (a ~ b) internally
11:53:41 <scott_> When you do 'map id' it has to unify the 'a' in id's type with the 'a' in map's type and then also the 'b' in map's type, which is what forces [a] and [b] to be the same type, since a and b must be the same
11:53:46 <scott_> :t map id
11:53:47 <lambdabot> [b] -> [b]
11:54:13 <Kron> it's kind of like a constraint propagation system, in a way
11:54:29 <scott_> You might find some good resources if you look up unification... I don't know of a particular resouce
11:54:47 <Kron> :t map
11:54:48 <lambdabot> (a -> b) -> [a] -> [b]
11:54:55 <Kron> :t map (undefined :: Int -> Bool)
11:54:56 <lambdabot> [Int] -> [Bool]
11:55:06 <Kron> it fuses "Int" and "a", "Bool" and "b"
11:55:52 <lingxiao> haasn: not sure what you mean by that? what does `~` mean?
11:55:58 <scott_> :t concatMap
11:55:59 <lambdabot> (a -> [b]) -> [a] -> [b]
11:56:00 <scott_> :t concatMap id
11:56:01 <lambdabot> [[b]] -> [b]
11:56:14 <Kron> ~ is unification, basically
11:56:14 <haasn> lingxiao: (~) :: * -> * -> Constraint
11:56:21 <haasn> lingxiao: it's a constraint that forces two types to be equal
11:56:28 <Kron> (something ~ somethingelse) is a unification between those two types
11:56:30 <haasn> lingxiao: id :: a -> a
11:56:31 <Kron> you mostly see it in GHC errors
11:56:33 <haasn> is the same as:
11:56:46 <Kron> "Error, cannot unify (Int ~ Bool) blah blah" something like that
11:57:55 <rtpg> haasn, I'm actually thinking more in implementation stuff... I'm in the GHC source, looking around to see at what point IO becomes some priveleged element in the system
11:58:34 <lingxiao> Kron: ahh I do see those, thanks for pointing them out, now the error msgs make more sense now
11:58:49 <Kron> yeah, it took me the longest time to figure out what they meant
11:58:51 <haasn> :t (\x -> x) :: (a ~ b) => a -> b
11:58:52 <lambdabot> b -> b
11:58:53 <haasn> (oops, got disconnected)
11:58:55 <haasn> anyway, it type checks over here. (lambdabot?)
11:58:57 <haasn> rtpg: I'm not sure what you mean by privileged
11:58:57 <donri> i think i liked http://pragprog.com/magazines/2013-06/unification back when i read it
11:58:59 <haasn> or privileged element in the system, rather
11:59:01 <haasn> lingxiao: you can have instances like these too
11:59:50 <lingxiao> donri: thanks! I was just about to ask for something like that
12:00:35 <haasn> lingxiao: consider the difference between   instance Monoid (a -> a)   and instance (a ~ b) => Monoid (a -> b)
12:00:59 <lingxiao> they would be the same right?
12:01:04 <donri> they're not
12:01:11 <scott_> What's the difference?
12:01:21 <lingxiao> yeah second scott_
12:01:24 <Kron> actually I'm curious
12:01:35 <donri> i'm not sure if i should answer or if haasn is being socratic :)
12:01:36 <Kron> I've never seen (a ~ b) used in a type declaration before, I didn't know that was possible
12:02:07 <lingxiao> why would  you use it if you can just use the same letters?
12:02:37 <lingxiao> so `instance Monoid (a -> a)` doesn't get translated to `instance (a ~ b) => Monoid (a -> b)` some point down the line?
12:03:04 <Kron> I guess not?
12:05:03 <donri> thing is constraints aren't accounted for during instance resolution
12:05:28 <Saizan> instance (a ~ b) => Monoid (a -> b) applies even when type inference hasn't decide that a ~ b already
12:05:33 <Saizan> *decided
12:05:44 * hackagebot cabalg 0.1.0 - alias for cabal install from given git repo  http://hackage.haskell.org/package/cabalg-0.1.0 (DmitryMalikov)
12:06:01 <scott_> Saizan: So it would just fail later? Does it have a reasonable usecase?
12:06:15 <donri> with (a -> a), you could also have other arrow instances like (Int -> Char), say
12:06:21 <Saizan> scott_: fail?
12:06:33 <scott_> Saizan: I mean if a and b can't unify
12:06:53 <Saizan> scott_: yeah, in that case it will fail, otherwise it'll make them unify
12:06:57 <donri> yes, the constraint is type checked, it just doesn't guide instance resolution
12:07:20 <scott_> So I guess the only difference is instance resolution?
12:07:28 <rtpg> haasn, for example, in the GHC source, it says that IO is just an instance of ST , wrapping some RealWorld datatype, but what is the RealWorld datatype?
12:07:32 <Saizan> scott_: yup
12:07:56 <donri> perhaps an easier example is instances for String (aka. [Char]) vs. an instance for (a ~ Char) => [a]
12:08:31 <donri> with the latter, we can only have that one list instance and the type checker knows that the elements must be chars
12:09:13 <scott_> So the latter is kind of like the former, but not requiring FlexibleInstances (and not allowing other [a]-like instances)?
12:09:25 <donri> with the former, you could also have an [Int] instance
12:09:48 <donri> scott_: yes. it needs type families or gadts though, instead ;)
12:09:58 <scott_> Why is that?
12:10:01 <donri> but it's better because it doesn't mess up type inference
12:10:08 <donri> well ~ isn't standard syntax
12:10:11 <scott_> Oh I see
12:10:14 <scott_>     Illegal equational constraint a ~ Char
12:10:15 <scott_>     (Use -XGADTs or -XTypeFamilies to permit this)
12:10:19 <donri> yep
12:10:33 <scott_> This has been enlightening :)
12:10:58 <donri> so there's a proposal to make overloaded strings use this trick in the IsString instance for, well, String itself
12:11:16 <donri> then (length "foo") would work because length says it has to be a list and IsString says if it's a list it has to be a list of chars
12:11:23 <donri> currently, this is ambiguous
12:11:24 <scott_> ie. instance (a ~ Char) => IsString [a] ?
12:11:28 <donri> yeah
12:11:52 <scott_> Quite interesting
12:12:19 <donri> the price of course is that we won't be able to have any other list instances (without newtyping)
12:12:19 <haasn> rtpg: http://www.haskell.org/haskellwiki/IO_inside
12:12:26 <haasn> donri: I'm not, I just got terribly distracted ;)
12:12:30 <haasn> lingxiao: they aren't, the head is different
12:12:31 <donri> okies
12:12:37 <haasn> lingxiao: instance resolution considers them differently
12:13:05 <lingxiao> im not familiar with this process of instance resolution, is there a place I could read about it?
12:16:11 <lingxiao> or rather, what did you read that made you really get it
12:16:47 <scott_> donri: Has there ever been talk of having instance IsString String and setting that particular instance as "default" for [a]? I mean, is there any kind of extension which could do this?
12:17:09 <scott_> Quite possibly it's a just plain terrible idea
12:17:32 <rtpg> haasn, thanks, this seems to confirm my suspicions about certain things
12:22:16 <d34df00d> Hi!
12:22:30 <d34df00d> I just wrote my first view pattern and am very happy with it, but having a question now.
12:22:37 <rtpg> I remember somebody stating that there is one example of referential transparency being breakable with the IO monad, if the compiler tried optimizing enough
12:22:37 <d34df00d> Is it possible to use view patterns in lambdas?
12:22:43 <johnw> d34df00d: yes
12:22:49 <johnw> d34df00d: you can use them anywhere that you can match a pattern
12:22:56 <johnw> but you may sometimes need extra parens
12:22:57 <d34df00d> johnw: hm, what's the syntax then? I tried to, but seemingly failed.
12:23:05 <d34df00d> Seems like I'm missing a couple :(
12:23:09 <johnw> \(foo -> x) -> x
12:23:29 <d34df00d> Hmm.
12:28:45 <scott_> Imagine a @pl that knew about lens...
12:29:38 <bennofs> aw
12:29:49 <bennofs> that'd be cute
12:30:09 <scott_> Or even arrows...
12:30:12 <scott_> @pl \f g (x, y) -> (f x, g y)
12:30:12 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
12:30:15 <scott_> That's (***)
12:30:41 <bennofs> it's bimap f g :)
12:30:44 <bennofs> @ty bimap
12:30:45 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
12:31:37 <bennofs> @unpl (***)
12:31:37 <lambdabot> (***)
12:32:21 <scott_> Bifunctor is one of the least scary lens classes I've seen
12:33:47 <johnw> isn't Bifunctor from the bifunctors package?
12:34:03 <scott_> Oh, I don't know. I just got it by importing Control.Lens
12:34:19 <supki> Bifunctor is much older than lens
12:34:21 <bennofs> johnw: yes, it is
12:34:30 <johnw> it's a re-export
12:34:35 <scott_> I see
12:37:22 <d34df00d> johnw: getting an error, for example:
12:37:34 <d34df00d> http://bpaste.net/show/0K1F1l4mIup1Czxsabet/
12:37:54 <johnw> (\(_ -> undefined) -> undefined)
12:38:00 <johnw> also, _ is not a function
12:38:06 <johnw> (\(id -> undefined) -> undefined)
12:38:27 <johnw> and i don't think you can pattern match against undefined
12:38:32 <johnw> (\(id -> x) -> x)
12:39:07 <scott_> It would create a local 'undefined' shadowing the usual one
12:39:22 <scott_> > (\(id -> undefined) -> undefined) 2
12:39:24 <lambdabot>  2
12:39:33 <johnw> huh
12:39:38 <johnw> ah, I see
12:39:53 <d34df00d> Yep.
12:40:35 <d34df00d> Oh.
12:40:37 <d34df00d> Thanks.
12:54:34 <haasn> @tell lingxiao I don't actually know; I just sort of picked it up from #haskell. I don't have a solid foundation on how instance resolution actually *works*, but my intuition seems to match GHC's behavior so it works out fine in practice. As for references, I'd try the haskell report (surprisingly readable)
12:54:34 <lambdabot> Consider it noted.
12:55:45 <jj2baile> The view patterns syntax is kind of confusing
12:56:18 <scott_> It's not as bad in named functions, rather than lambdas
12:56:41 <jj2baile> yeah, i mostly meant confusing with respect to lambdas
12:56:49 <haasn> > foldl' (&) (0,1) $ replicate 10 (snd &&& uncurry (+))
12:56:51 <lambdabot>  (55,89)
12:57:52 <benmachine> @quote benmachine view
12:57:52 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
12:58:08 <benmachine> > let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x
12:58:09 <lambdabot>  0
12:59:26 <haasn> whoa
12:59:49 <haasn> are those x's all recursive calls to the same “const 0” function? (except for the bound ones)
13:00:00 <haasn> s/calls to/applications of/
13:00:50 <vmalloc> Hey, how would you guys take two functions returning IO [a], and elegantly make them into a function returning IO [a] which is a concatenation of both lists?
13:01:27 <Peaker> vmalloc: hey hey :) (It's Lotex).
13:01:34 <Peaker> @type liftM2 (++)
13:01:34 <lambdabot> Monad m => m [a] -> m [a] -> m [a]
13:01:43 <vmalloc> Hey :-)
13:01:58 <vmalloc> Peaker: oh right
13:02:22 <benmachine> haasn: honestly I can't even remember
13:02:32 <benmachine> let's see if I can parenthise this up
13:02:33 <vmalloc> Peaker: I'm currently in the project of slowly converting my home automation scripts to Haskell for educational purposed :-)
13:02:51 <Peaker> vmalloc: awesome :)
13:03:07 <benmachine> > let ((\x -> case x of ((\x -> x) -> x) -> x) -> x) = () in x -- there, is that better?
13:03:08 <lambdabot>  ()
13:03:33 <benmachine> haasn: so the key is that the function in a view pattern can unambiguously be a lambda itself
13:03:59 <benmachine> likewise you can have view patterns in case alternatives
13:04:46 <benmachine> so roughly speaking it's a combination of the following two tricks:
13:04:53 <benmachine> > let (\x -> x -> x) = () in x
13:04:54 <lambdabot>  ()
13:04:57 <jophish_> Yo yo yo, everyone
13:04:59 <benmachine> > let (\y -> y -> x) = () in x
13:05:00 <lambdabot>  ()
13:05:29 <benmachine> > case () of id -> x -> x
13:05:30 <lambdabot>  <hint>:1:20: parse error on input `->'
13:05:32 <benmachine> oh
13:05:38 <benmachine> that one actually doesn't work
13:05:43 <benmachine> > case () of (id -> x) -> x
13:05:45 <lambdabot>  ()
13:05:52 <jophish_> I'm trying to get as short and elegant as possible for this wordsearch function: search :: Array (Int, Int) Char -> [String] -> [String]. Search takes an array and a list of words and returns a list of those words that appear in the grid
13:06:02 <jophish_> This is what I have so far: http://lpaste.net/96916
13:06:12 <benmachine> ok now I've confused myself
13:06:12 <jophish_> Can anyone suggest any improvements?
13:08:41 <Peaker> jophish_: I would use either lisp comprehension or map, but both is mixing two distinct styles
13:09:34 <Peaker> jophish_: I think I'd use "do" instead of comprehension to make it less dense and give more verbose names
13:10:08 <udevd> 21:34 < benmachine> > let (\x -> x -> x) = () in x
13:10:14 <udevd> maaaan whaaaat
13:10:17 <allsystemsarego> > extpoly [1,4,9]
13:10:19 <lambdabot>  Not in scope: `extpoly'
13:10:21 <benmachine> udevd: never do this :P
13:10:32 <udevd> what does it even--
13:10:39 <benmachine> udevd: view pattern, equivalent to let (id -> x) = () in x
13:10:42 <jophish_> Brevity was one of the goals. I'll see what a do version looks like
13:10:56 <udevd> >let (id -> x) = () in x
13:11:08 <udevd> and (id->x) means...?
13:11:08 <scott_> jophish_: Don't sacrifice readability for brevity
13:11:09 <Iceland_jack> > let (id -> x) = () in x
13:11:10 <lambdabot>  ()
13:11:13 <Iceland_jack> > let ((\x -> x) -> x) = () in x
13:11:14 <lambdabot>  ()
13:11:17 <Iceland_jack> > let (\x -> x -> x) = () in x
13:11:18 <lambdabot>  ()
13:11:29 <Peaker> jophish_: "pos" instead of "p"?   list comprehension for ds instead of the obscure point-free.   d/ds could be named neighbor/neighbors?
13:11:38 <scott_> > let (length -> n) = "foo" in n
13:11:39 <lambdabot>  3
13:11:47 <udevd> what :D
13:12:01 <donri> scott_: yes this proposed change seems to be blocked on a desire to instead improve the defaulting rules
13:12:04 <udevd> what is this actually doing
13:12:07 <scott_> udevd: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#view-patterns
13:12:12 <jophish_> scott_: Of course, this isn't code I'm going to be maintaining in the future though
13:12:16 <donri> scott_: (ghc already does some defaulting, and even more with ExtendedDefaultRules which is enabled in ghci)
13:12:21 <Peaker> hmm.. "neighbor" is bad, maybe.  "direction" might be better
13:12:55 <udevd> ah it's an arrow expression
13:13:21 <benmachine> udevd: no, it's a view pattern
13:13:21 <scott_> It has nothing to do with arrows as in Control.Arrow, if that's what you mean
13:13:32 <scott_> It's a view pattern confusingly mixed with a lambda
13:13:39 <benmachine> they're an extension whereby you can match on the result of applying a function to something, instead of on the thing directly
13:13:42 <udevd> good, i thought in first place that this is some weird ass pattern matching... knowing it's an extension somehow calms me
13:13:58 <udevd> mhm
13:14:04 <benmachine> it's an extension providing weird-ass pattern matching :P
13:14:18 <benmachine> but view patterns are pretty cool
13:14:55 <udevd> still don't know how it works, i'm reading...
13:15:01 <benmachine> > case Seq.fromList [1,2,3,4,5] of (viewL -> x :> xs) -> (x, xs)
13:15:02 <lambdabot>  Not in scope: data constructor `:>'
13:15:02 <lambdabot>  Perhaps you meant one of these:
13:15:02 <lambdabot>    `Seq.:>' (imported from Data.Sequence),
13:15:02 <lambdabot>    `:+' (imported from Data.Complex),
13:15:03 <lambdabot>    `Seq.:<' (imported from Data.Sequence)
13:15:11 <benmachine> > case Seq.fromList [1,2,3,4,5] of (Seq.viewL -> x Seq.:> xs) -> (x, xs)
13:15:13 <lambdabot>  Not in scope: `Seq.viewL'
13:15:15 <lambdabot>  Perhaps you meant one of these:
13:15:17 <benmachine> bleh
13:15:17 <lambdabot>    `Seq.viewl' (imported from Data.Sequence),
13:15:19 <lambdabot>    `Seq.viewr' (imported from Data.Sequence)
13:15:21 <benmachine> > case Seq.fromList [1,2,3,4,5] of (Seq.viewl -> x Seq.:> xs) -> (x, xs)
13:15:23 <lambdabot>  Couldn't match expected type `Data.Sequence.ViewL a0'
13:15:23 <lambdabot>              with actual type `Data.Sequence.ViewR t0'
13:15:28 <jophish_> Peaker: how would you write a list comprehension for ds neatly? let oneDirs = [id, pred, succ] in [x***y | x<-oneDir, y<-oneDir]
13:15:31 <benmachine> oh never mind
13:15:46 <Iceland_jack> > case Seq.fromList [1,2,3,4,5] of (Seq.viewr -> x Seq.:> xs) -> (x, xs)
13:15:47 <lambdabot>  (fromList [1,2,3,4],5)
13:15:54 <scott_> > let apply f (f -> x) = x in apply (*2) 21
13:15:55 <lambdabot>  42
13:15:56 <Iceland_jack> benmachine: wrong direction :)
13:16:01 <scott_> Who needs regular function application syntax?
13:16:13 <Peaker> jophish_: something like that. Though I think I'd use a Vector2 for the position instead of (Int,Int), and then a simple (Vector2 dx dy) for the direction. And use ordinary iterate (+dir)
13:16:19 <Peaker> jophish_: much nicer/easier to work with
13:16:29 <scott_> Well, I guess I just used it in the right hand part... :p
13:17:03 <scott_> > let ((*2) -> x) = 21 in x
13:17:04 <lambdabot>  42
13:17:06 <jophish_> Peaker: using a tuple means that I can use *** to generate directions, How would this work with Vector2?
13:17:54 <Peaker> jophish_: simple Num instance
13:18:04 <Peaker> jophish_: pos + Vector2 (-1) 1
13:18:36 <Peaker> jophish_: or if you're a purist and don't like Num, you could use Vector2's Applicative instance and use:  (+) <$> pos <*> delta
13:18:42 <scott_> > let ((*) -> f) = 2 in let (f -> x) = 21 in x  -- interestingly this doesn't work with a single let
13:18:43 <lambdabot>  42
13:18:55 <jophish_> That would certainly be easier to understand at a glance
13:19:23 <jophish_> This was more of an exercise in haskell golf. Seeing how short I can get this particular function
13:20:06 <donri> @hackage tau -- stepkut ;)
13:20:06 <lambdabot> http://hackage.haskell.org/package/tau -- stepkut ;)
13:20:41 <udevd> > let {empty _ = False; empty (length->0) = True} in 1
13:20:42 <lambdabot>  1
13:20:56 <udevd> > let {empty _ = False; empty (length->0) = True} in [empty "abracadabra", empty ""]
13:20:57 <lambdabot>  [False,False]
13:20:59 <udevd> :/
13:21:07 <udevd> > let {empty (length->0) = True} in [empty "abracadabra", empty ""]
13:21:08 <lambdabot>  [*Exception: <interactive>:3:6-29: Non-exhaustive patterns in function empty
13:21:15 <udevd> > let {empty (length->0) = True; empty _ = False} in [empty "abracadabra", empty ""]
13:21:16 <lambdabot>  [False,True]
13:22:01 <shiona> what is that "->"
13:22:15 <scott_> A view pattern
13:22:23 <shiona> ok
13:24:28 <stepkut> donri: we need to get it into base
13:26:11 <darthdeus> hey guys, what's a simplest way of shoving a breakpoint onto a line and debugging the code interactively?
13:26:23 <darthdeus> i've never done this in haskell and googling only found Debug.Trace
13:27:21 <Peaker> darthdeus: http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/ghci-debugger.html ?
13:33:03 <donri> stepkut: or pi out of base? always struck me as odd to be in prelude, even
13:33:14 <darthdeus> thanks :) does this work for monads? i'm getting a weird error http://i.imgur.com/4Fnsb4p.png
13:33:23 <darthdeus> but it works for a different line above it
13:38:20 <Hafydd> > acos (-1)
13:38:21 <lambdabot>  3.141592653589793
13:38:33 <Hafydd> I suppose there's that.
13:39:14 <Hafydd> But then everyone would end up defining: pi = acos (-1) in every program.
13:39:38 <Hafydd> So I think it's sensible to have.
13:40:42 <Peaker> darthdeus: "doc" is in scope only within that do block
13:40:57 <darthdeus> but i am in that do block, no?
13:42:35 <shachaf> Are you using the ghci debugger or something?
13:42:42 <darthdeus> ghci debugger
13:42:53 <shachaf> It's hard to tell from that small screenshot. You should go to hpaste.org and paste text instead of using screenshots. :-)
13:45:49 <darthdeus> shachaf: there you go http://lpaste.net/992877893442863104 :) my problem is actually really simple
13:46:00 <darthdeus> i'm trying to explore how the HXT library works
13:46:15 <darthdeus> so i thought i can get a breakpoint inside the do block to work with doc directly
13:46:40 <darthdeus> because runX on that thing returns IO Xml thingy, which is not as easy to work with :) and i'd like to learn to debug anyway
13:52:35 <allsystemsarego> @src foldl1
13:52:36 <lambdabot> foldl1 f (x:xs) = foldl f x xs
13:52:36 <lambdabot> foldl1 _ []     = undefined
13:53:17 <c_wraith> > foldl1 (+) []
13:53:18 <lambdabot>  *Exception: Prelude.foldl1: empty list
13:53:28 <c_wraith> clearly, the source is not actually what ghc uses
13:53:40 <scott_> @src (-)
13:53:41 <lambdabot> x - y = x + negate y
13:53:44 <scott_> @src negate
13:53:45 <lambdabot> negate x = 0 - x
13:53:51 <allsystemsarego> > foldl1 lcm [1..10]
13:53:52 <c_wraith> I think those are accurate.
13:53:53 <lambdabot>  2520
13:54:00 <c_wraith> Those are default implementations in terms of each other.
13:54:05 <sipa> that may actually be the source - instances just have to overwrite one of the defaults
13:54:09 <scott_> Oh? Interesting
13:54:28 <sipa> @src negate Int
13:54:28 <lambdabot> Source not found. You untyped fool!
13:54:39 <c_wraith> @src (<=)
13:54:39 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
13:54:45 <c_wraith> @src compare
13:54:45 <lambdabot> compare x y | x == y    = EQ
13:54:45 <lambdabot>             | x <= y    = LT
13:54:45 <lambdabot>             | otherwise = GT
13:54:51 <c_wraith> same deal.
13:54:55 <c_wraith> mutually-recursive defaults
13:55:06 <c_wraith> Implement whichever is easier, and you get both
13:55:19 <sipa> implement none, and you get <<loop>>
13:58:39 <ReinH> same thing for foldr and foldMap
14:00:41 <Peaker> c_wraith: one of the silliest decision IMO
14:00:56 <Peaker> I don't see how implementing (/=) could ever be easier than implementing (==) or vice versa
14:01:11 <Peaker> Eq and Ord should have each had just 1 method
14:01:49 <Philonous_> Yes, but which one
14:02:49 <scott_> Can you implement the floating point operators if you only get to define one of them?
14:03:05 <scott_> > let nan = 0/0 in nan `compare` nan
14:03:06 <lambdabot>  GT
14:03:09 <scott_> > let nan = 0/0 in nan > nan
14:03:10 <lambdabot>  False
14:03:59 <ReinH> scott_: that tricksy `otherwise`
14:04:13 <scott_> ReinH: Hmm?
14:04:16 <Peaker> Philonous_: I'd choose (==) and (<)
14:04:31 <ReinH> scott_: it's GT because it's not == and it's not <=
14:04:38 <ReinH> but it's also not >
14:04:53 <ReinH> but it claims to be comparable, so...
14:05:02 <Philonous_> @src (<)
14:05:03 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
14:05:03 <scott_> ReinH: My question is could you implement those properly if you only got to define 'compare' for example, and not the other operators
14:05:14 <scott_> Perhaps arguably there shouldn't be Ord instances for the floating point types
14:05:24 <scott_> They don't follow the same laws you might expect
14:05:39 <ReinH> scott_: well, maybe, but the fact that checking the ==, <= and > cases don't give you a total function seems rather disconcerting.
14:06:00 * hackagebot scotty-fay 0.1.1 - Fay integration for Scotty.  http://hackage.haskell.org/package/scotty-fay-0.1.1 (hdgarrood)
14:10:07 <Cradam> looking for the definition of something on hoogle, and come across what looks like a made up word, modificator
14:14:17 <danharaj> edwardk: Not a day goes by where I do not feel delighted when lens solves my problem.
14:14:24 <edwardk> =)
14:15:02 <Philonous_> danharaj, So you write those up?
14:15:18 <danharaj> nope
14:16:33 <ReinH> danharaj: :(
14:17:49 <boom583> What is your reply to this claim: "People are not wired to think functionally. It's more natural to think procedurally." ?
14:18:45 <Philonous_> boom583, Says who?
14:19:02 <boom583> It's one of the common objections "against" functional programming languages
14:19:28 <sipa> i wonder whether people who are first exposed to functional programming have that same impression
14:19:44 <Hodapp> Mathematics appears to have no trouble with working with very functional constructs...
14:19:46 <Philonous_> boom583, No, that was my response ;)
14:19:57 <boom583> Was anyone here first exposed to func prog?
14:20:07 <boom583> And then found proc prog weird?
14:20:07 <Hodapp> I was exposed to Lisp rather early on.
14:20:33 <ryantrinkle> boom583: i've taught several non-programmers haskell; they all had an easier time learning it than imperative programmers who i've taught
14:20:37 <danharaj> anyone who knows how to reduce a polynomial expression to a number was exposed to functional programming
14:20:59 <Hodapp> and procedural languages that don't at least give me some functional constructs I'm accustomed to - lambdas, first-class functions, higher-order functions, map/filter/reduce - just feel too limiting.
14:21:26 <FireFly> boom583: I think it's a matter of what you're used to. I think functional is closer to mathematics
14:21:43 <FireFly> boom583: You don't see people complaining about mathematical notation not being procedural, typically
14:21:54 <boom583> well I'm used to proc prog. wondering whether to bother learning func prog
14:22:18 <FireFly> I'd recommend it. If nothing else, to widen your knowledge and provide another point of view
14:22:34 <boom583> c++ is my current lang of choice. it's fast as hell...
14:22:57 <boom583> been looking into haskell/ocaml, but they look weird lol
14:23:02 <boom583> being func prog
14:23:17 <sipa> them looking weird has surprisingly little to do with being functional
14:23:32 <sipa> i guarantee you that smalltalk will also look weird :p
14:23:44 <StoneCypher> boom583: i started in functional and am also a c++ person
14:23:54 <boom583> StoneCypher: cool!
14:23:59 <boom583> so what's your story
14:24:00 <StoneCypher> as far as what people are wired for, they're not wired for imperative either
14:24:12 <StoneCypher> uh, i started in a lisp dialect (logo) and then i moved on
14:24:50 <ian_mi> I started with C for a few years, switched to C++ for a year or so, tried python for a few months, then switched to haskell
14:25:02 <ian_mi> been using it every since
14:25:04 <hpc> there's a lot of things people aren't wired for
14:25:05 <StoneCypher> boom583: generally, most objections against classes of tool are people who dislike what they're not used to.  internalize them, hear them, and then make your own decision.
14:25:14 <boom583> ian_mi: when did you switch to haskell?
14:25:14 <earthy> I started in basic, then learned logo, then went on to other languages
14:25:28 <ian_mi> boom583: maybe 3 years ago
14:25:30 <sipa> basic -> c -> perl -> java -> haskell -> c++ -> python ...
14:25:49 <earthy> but every language has at least taught me something
14:25:50 <ian_mi> well, I was introduced to it 3 years ago at least
14:25:56 <ian_mi> been using it exclusively for 2
14:26:00 <boom583> ok
14:26:06 <boom583> ian_mi: what made you prefer haskell over c++
14:26:08 <StoneCypher> logo -> (too many) -> c++/erlang mostly
14:26:26 <boom583> if one prefers haskell over c++, it means one is not primarily concerned with speed is one?
14:26:39 <ian_mi> boom583: much less boilerplate, much better abstraction
14:26:44 <boom583> but it seems it produces lot less code
14:26:49 <boom583> ok
14:26:54 <sipa> if you're only concerned with speed, you should write assembly
14:27:00 <sipa> it's always about priorities
14:27:07 <Hodapp> boom583: choosing a language because of its perceived speed is one of the most idiotic forms of premature optimization you can do.
14:27:07 <boom583> sipa: well lol, let's be reasonable :D :D
14:27:08 <ian_mi> for the extra speed I use the LLVM bindings for haskell
14:27:12 <sipa> haskell can be relatively fast compared to interpreted languages
14:27:28 <ian_mi> write everything in LLVM bytecode ^.^
14:27:47 <Hodapp> ian_mi: huh, do you inline LLVM routines?
14:27:52 <Philonous_> boom583, You don't seem to be concerned only about speed, then, either
14:28:19 <boom583> good point
14:28:28 <boom583> ian_mi: so, you're finding that any program you could make in c++ you can also make in haskell?
14:28:42 <ian_mi> Hodapp: I was mostly joking, but I have done that before. Wrote regexs in llvm that were compiled on demand.
14:28:45 <boom583> in other words, is func prog for a particular type of program? and same for proc prog
14:29:00 <Cale> boom583: Haskell is general purpose
14:29:16 <ian_mi> boom583: I use haskell for everything
14:29:37 <boom583> interesting
14:29:39 <Cale> Essentially all of the things which make Haskell good apply equally to any sort of program you'd want to write.
14:29:39 <ian_mi> I think it is well suited for almost everything
14:29:39 <Hodapp> well, if your aim is that your program is completely useless for any sort of static analysis, that's much easier to do in C++
14:29:50 <Iceland_jack> lol
14:29:56 <Fyl> if I reexport another module under a diff. name, haddock throws a warning saying "Could not find documentation for exported module"; is there a way to work around this?
14:30:07 <Cale> Hodapp: lol
14:30:30 <sipa> also, if you insist on weird indentation practices, Haskell may not be for you
14:30:35 <boom583> Why would anyone prefer OCaml over Haskell?
14:30:39 <ian_mi> boom583: I'm currently writing a torrent client in haskell. I don't think I'd be able to manage the complexities of such a program in C++.
14:30:50 <boom583> heh
14:31:03 <Iceland_jack> These language comparisons are boring and have been done to death
14:31:21 <Philonous_> boom583, because they are Robert Harper?
14:31:35 <boom583> ok..
14:31:47 <ian_mi> one of haskell's strength's is concurrency. Cheap threads and great STM support.
14:31:50 <maurer> boom583: Not to defend choosing ocaml, because I use ocaml for work and wish I were using haskell
14:32:02 <Hodapp> maurer: what don't you like about OCaml?
14:32:30 <maurer> boom583: But some things from ocaml are useful, such as the ability to have a cost semantics, or actual modularity, etc.
14:32:42 <Cale> boom583: O'Caml is strictly evaluated, which some people like because it has a somewhat easier cost model, but at the cost of compositionality. Also, O'Caml has a really nice module system compared to Haskell's.
14:32:55 <boom583> ok
14:33:03 <Kron> cost semantics?
14:33:21 <maurer> Hodapp: http://pastebin.com/Jw0zGs0B
14:33:25 <Hodapp> I think it's OCaml, not O'Caml... it's French, not Irish >_<
14:33:28 <mauke> The paste Jw0zGs0B has been copied to http://lpaste.net/96917
14:33:31 <Cale> It's easier to figure out the time and space complexities of programs under strict evaluation.
14:33:54 <maurer> Kron: Cost semantics meaning that it is possible to do formal reasoning about how long your program will run and how much space it needs
14:33:55 <boom583> ian_mi: So if I learn Haskell now, it's essentially 100% guaranteed to save me a ton of time? As opposed to sticking to C++, if i'm thinking years into the future.
14:33:58 <Cale> and of course, Haskell is neither strict nor lazy really
14:34:13 <maurer> Again, I'm not trying to tell you to use ocaml
14:34:17 <Cale> (but lazy is a closer approximation to the evaluation order)
14:34:19 <maurer> it sucks for a number of reasons
14:34:22 <Kron> ah, I see
14:34:27 <maurer> but it isn't strictly worse than haskell
14:34:44 <Kron> boom583: if you learn Haskell now, it's essentially guaranteed to make you save time no matter what language you use
14:34:48 <Hodapp> maurer: ...it's only worse if you actually look at it?
14:34:51 <ian_mi> boom583: If you have to time to learn new things, it will pay off in the long run
14:34:54 <Hodapp> maurer: a sort of lazy worseness?
14:34:59 <boom583> cool
14:35:00 <Kron> the conceptual framework that comes with coding in haskell transcends all languages
14:35:03 <Kron> except prolog
14:35:06 <Kron> but no-one talks about prolog
14:35:11 <Philonous_> boom583, At the end of the day, all those questions won't help you understand Haskell any better. The only thing that will is jumping in and trying it out for yourself
14:35:19 <boom583> true
14:35:23 <Hodapp> Kron: ...all but Prolog? That seems a little arbitrary...
14:35:26 <Kron> grab an interpreter and try some LYAH
14:35:32 <Kron> it's from my experience with prolog
14:35:36 <maurer> Hodapp: No, I meant that there are some axes along which it can be more convenient to work in ocaml
14:35:39 <Kron> it doesn't even have functions
14:35:39 <Iceland_jack> boom583: Expecting a “100% guarantee” of anthing is a completely wrong attitude
14:35:55 <Kron> trying to apply functional programming to a language without functions is... not only difficult, possibly the wrong sort of thing to do
14:36:01 <Hodapp> C++ is known to give wrong attitudes about things.
14:36:01 <Kron> liek trying to program imperatively in haskell
14:36:08 <Kron> you need to program like a prologer in prolog
14:36:11 <maurer> Hodapp: Strictly in my sentence there was similar to pareto conditions, e.g. "The existence of haskell does not preclude ocaml from being pareto optimal"
14:36:15 <boom583> what I find weird about the haskell LYAH book is that its only examples are some weird recursion examples that I will rarely do in practice
14:36:16 <ian_mi> boom583: More importantly for me, it makes programming fun again.
14:36:21 <donri> haskell is the world's finest imperative programming language, didn't you know
14:36:26 <boom583> at least the ones I noticed
14:36:30 <maurer> donri: Those are bob's words...
14:36:33 <Hodapp> donri: okay there, Peyton Jones...
14:36:35 <Kron> donri: don't even start :P
14:37:16 <Kron> boom583: any tutorial book is going to use overly simplistic examples
14:37:18 <ian_mi> boom583: everything is built on recursion. Once you understand those examples, you will be able to move on to combining things with higher order functions
14:37:18 <donri> maurer: that was addressing Kron :)
14:37:21 <Fyl> did spj actually say that?
14:37:27 <boom583> interesting
14:37:32 <maurer> Fyl: Dunno about spj, but bob has said those words to me
14:37:33 <Hodapp> Fyl: I'm fairly sure I have a paper where he says that/
14:37:35 <Kron> even the standard haskell quicksort example everyone uses is actually quite a bad implementation
14:37:38 <maurer> Fyl: though he may have been quoting spj
14:37:50 <Kron> at the very least a partition function is in order
14:38:11 <Kron> optimally you'll need the ST monad to do an in place sort on an array I think
14:38:24 <donri> maurer: your pareto optimal quote or my imperative quote?
14:39:21 <Hodapp> Fyl: Tackling the Awkward Squad, page 3, paragraph 3. "In short, Haskell is the world's finest imperative programming language."
14:39:38 <Fyl> heh :)
14:39:48 <Fyl> maurer: who is bob btw/
14:39:51 <maurer> donri: Your imperative quote
14:39:58 <maurer> Fyl: Bob Harper/rwh
14:40:03 <Fyl> ah
14:40:05 <Hodapp> That paper is April 7, 2010.
14:40:18 <Kron> Kron: recursion
14:40:39 <Hodapp> however, I suppose SPJ could have been quoting someone else.
14:40:53 <ian_mi> The way I look at it, haskell provides all the power of imperative programming, but I only have to use it where it's needed, and it allows me to deal more explicitly with effects I'm handling.
14:41:29 <ian_mi> so in that way I agree, haskell is a great imperative language :)
14:41:41 <boom583> ian_mi: you mean it's imperative within each func
14:41:43 <boom583> ?
14:41:51 <Peaker> ian_mi: Imperative programming gives you simpler guarantees about operational semantics than Haskell gives, though..  and in lower-level imperative languages like C, you can actually have tight control of resources/etc
14:42:04 <Kron> boom583: it's never imperative outside of something called the ST monad, but it has the 'power' of imperative programming
14:42:06 <Peaker> (I mean typical imperative programming gives..)
14:42:08 <Kron> it can do what imperative code can give you
14:42:10 <Iceland_jack> boom583: Don't take the analogy too seriously
14:42:31 <boom583> Are modules (func prog) better than classes (OO prog)?
14:42:34 <boom583> "better"
14:42:36 <boom583> iyo
14:42:51 <Peaker> boom583: It's really weird to categorize FP as "modules"
14:42:55 <ReinH> That's apples and oranges
14:43:05 <Cale> The reason it's very nice for imperative programming, IMO, is that the separation between evaluation of expressions and execution of IO actions makes it especially easy to write your own control structures and other higher-order imperative constructions without worrying about the order of evaluation causing effects to occur too early or too late.
14:43:12 <boom583> oh
14:43:26 <Peaker> boom583: Is FP better than OO?   Sometimes I use OO techniques in my FP.. But if the question is:  FP-languages vs. OO-languages?  Definitely FPL's are better :)
14:43:34 <Kron> I do miss OO
14:43:43 <Kron> haskell has no true OO in it
14:43:52 <Peaker> Kron: what do you miss from "true OO"?
14:43:52 <Iceland_jack> Let's ask #haskell whether FP is better than OO ;)
14:44:06 <Cale> Haskell can do a better job of modelling OO than most typed OO languages. :P
14:44:08 <donri> what is OO?
14:44:08 <Kron> inheritance mostly
14:44:09 <Peaker> Implementation inheritance is a historic mistake
14:44:21 <Peaker> Interface inheritance is lame and type-classes are much nicer :)
14:44:23 <ian_mi> boom583: No, I mean if I need to write something imperative, such as manipulate shared state, I can write that in STM monad, which makes it explicit that I'm only doing STM computations.
14:44:25 <Cale> Inheritance is not something I'd consider central to OO
14:44:28 <Kron> my favorite OO system is actually CLOS
14:44:31 <boom583> ok
14:44:33 <Kron> but I guess that just betrays my bias
14:44:36 <maurer> I actually feel like the jammed in OO in OCaml causes pretty serious problems
14:44:42 <boom583> what replaces inheritance in FP?
14:44:51 <Peaker> Kron: by inheritance, do you mean implementation inheritance or interface inheritance?
14:44:52 <Iceland_jack> boom583:
14:44:52 <Iceland_jack> @where lyah
14:44:52 <lambdabot> http://www.learnyouahaskell.com/
14:44:53 <Kron> basically, encapsulated function fields
14:45:02 <maurer> if one programmer tries to use OO to structure their code, and the other tries to use modules, you can't actually mix them nicely
14:45:08 <Kron> interface inheritance I think
14:45:10 <Cale> Objects are about having values which are specified in terms of their responses to messages.
14:45:13 <Kron> I'm not sure what either means
14:45:21 <Peaker> Kron: interface inheritance is really bad in OO compared with type-classes
14:45:24 <ian_mi> boom583: I can encode exactly the effects I am using in the type of my monad.
14:45:58 <benmachine> maurer: yeah I use OCaml at work and we basically just pretend classes/objects aren't there
14:45:59 <Peaker> Kron: for example, consider the "Show" type-class vs. the "IShow" interface
14:46:18 <ian_mi> boom583: I can handle one effect at a time, to strip them away and get a simpler monad.
14:46:45 <Peaker> Kron: class Show a where show :: a -> String          vs.     interface IShow { string show(); }       Now consider we want to make the "Maybe" type an instance of Show/IShow
14:46:46 <boom583> hehe
14:46:58 <maurer> benmachine: The problem occurs when some guy decides they're a good idea, and writes a bunch of code using them that you later have to interface with
14:47:04 <Peaker> Kron: instance Show a => Show (Maybe a) where ...       <-- conditional instantiation of an interface/type-class
14:47:15 <maurer> benmachine: e.g. our pretty printer is a class that is created by  a functor which takes modules as arguments
14:47:17 <Peaker> Kron: in OO you're screwed. Either Maybe<T> inherits from IShow or it doesn't, regardless of T
14:47:20 <maurer> benmachine: This turns out to have issues
14:47:22 <benmachine> maurer: hah, awesome
14:47:27 <Kron> then I proably mean implementation inheritance
14:47:32 <Peaker> Kron: heh :)
14:47:34 <Kron> I REALLY lile typeclasses
14:47:38 <Kron> *like
14:47:45 <Kron> they're fantastic, every language should have them
14:47:53 <Cale> The way most typed OO languages tie method implementations to classes makes it harder to do object oriented programming correctly.
14:47:56 <Kron> they have this sort of... lisp-macro-y nature to them
14:47:59 <benmachine> I've grown more appreciative of type classes having not had them for a while
14:48:04 <Kron> you use them and you wonder why you've never been able to use it before
14:48:06 <maurer> Kron: Not to start a language war, but type classes are both awesome and awful
14:48:21 <maurer> Kron: Specifically, they forcibly cross module boundaries - you can't _not_ import them
14:48:26 <benmachine> I started out thinking "oh, type classes are basically just like modules only more convenient" but then you see things like lens and Traversable and
14:48:32 <maurer> Kron: Also, once somebody has defined one, you can't select another implementation
14:48:39 <benmachine> it's pretty hard to imagine Traversable without type classes
14:48:40 <Peaker> Kron: implementation inheritance is a really silly way to share code amongst classes + a way to have two modules (superclass and subclass) call each other's methods.   The former has better alternatives in Haskell. The latter is not that useful IME and can be done via a recursive binding
14:48:47 <Cale> You end up with lots of spurious subclassing just to arrange to have different method implementations, and that spurious subclassing makes implementation inheritance seem like a good idea.
14:48:51 <boom583> but how come func prog is getting more and more popular only now?
14:48:58 <boom583> i only ever heard of OO
14:49:03 <maurer> boom583: Faster computers, better tooling, better education
14:49:21 <c_wraith> And functional programming is only like 70 years old now
14:49:25 <c_wraith> it's about time people have heard of it
14:49:37 <Peaker> maurer: If you think of type-class instances as properties of the types themselves, it makes sense that you cannot avoid importing them
14:49:42 <jefimenko> anyone with an education in CS has certainly heard of it
14:49:49 <Peaker> maurer: and it has some distinct advantages, and for the disadvantages there's the newtype workaround
14:49:53 <maurer> Peaker: I understand _why_
14:49:54 <jefimenko> and probably used it at one point
14:50:04 <maurer> Peaker: I'm just saying that they have compositional issues
14:50:13 <Peaker> maurer: it gives nice guarantees that help composition, too
14:50:15 <maurer> Peaker: Where you can write two different valid programs, which cannot compose
14:50:19 <Kron> how do you extend a haskell system though? with newer functionality and special cases?
14:50:22 <benmachine> I do think that type classes are controversial
14:50:26 <Kron> like if you were writing a magic the gathering style game in haskell
14:50:29 <benmachine> they're hard to get right
14:50:33 <Peaker> maurer: valid even with -Werror ?
14:50:36 <Kron> and each new 'card' had special rules
14:50:38 <Kron> stuff like that
14:50:40 <benmachine> but they also get things right that I don't know of any other way to get right
14:50:49 <boom583> maurer: "Faster computers". So, FP is indeed slower by its nature?
14:51:01 <Cale> If the types of objects were simply specifications of what methods/messages they had/responded to (and their types), then you don't need as many subclasses, and you don't need or even want inheritance nearly as often.
14:51:04 <c_wraith> Kron: you generally have a Card data structure that contains functions.
14:51:08 <Peaker> benmachine: Agda's implicits can be an "alternative" to type-classes (which is really just a way to do type-classes), afaik
14:51:09 <benmachine> boom583: FP takes a lot of care and sophistication to make fast
14:51:10 <ReinH> boom583: lol no
14:51:19 <c_wraith> Kron: you just only have one type, instead of hundreds of subtypes for no reason
14:51:22 <maurer> boom583: Depends. FP is not inherently slower, but C-likes are essentially what FP compiles into
14:51:23 <Cale> (i.e. if you specify method implementations when *constructing* objects, not when defining their types)
14:51:30 <monochrom> computers are slower by nature
14:51:31 <maurer> boom583: As a result, with enough tuning you can always make C go as fast
14:51:50 <Cale> Kron: You can do OO just fine in Haskell in the way I'm suggesting typed OO languages ought to do it anyway :)
14:51:58 <maurer> boom583: However, most FP languages rely on the use of some form of garbage collector, which is going to have some overhead, etc.
14:52:05 <boom583> ok
14:52:15 <benmachine> Peaker: yeah, implicits seem pretty cool, although I've found inference has taken literally like ten seconds before
14:52:20 <maurer> Peaker: You can't make it valid with -Werror in the ways I'm thinking of, no, but -Werror weeds out a lot of things you might like to do
14:52:25 <Peaker> Kron: in an OO language you'd define an interface to sub-class in extensions. In Haskell you'd define a record type to generate in extensions
14:52:32 <maurer> Peaker: For example, say I write a package with a cool new datatype that does a bunch of things
14:52:47 <Peaker> maurer: I use -Werror on all my code :P
14:52:48 <maurer> Peaker: And then, I want to write an hxt instance for that type, but don't want to put it in that package so that using it doesn't require an xml serializer
14:52:50 <Cale> Kron: i.e. just create records consisting of the methods which your object responds to. The function which constructs that record may have parameters which will serve as your "private" variables
14:53:04 <benmachine> maurer: I once read an article about how C is actually innately really hard to optimise because pointer aliasing is so ubiquitous
14:53:08 <maurer> Peaker: The easy way to do that is to put it in a separate footype-xml package, which defines the instance
14:53:22 <maurer> benmachine: Yes, it is hard to optimize, but people will hand optimize it
14:53:27 <Peaker> maurer: yeah, orphans may be fine for some special use cases (like that one) in which the *same* author defines the instance.  But third party authors shouldn't do that
14:53:55 <maurer> Peaker: Sure, but now you've gotten to the point where you have flexible guidelines relying on code ownership to figure out who can use typeclasses where to make them safe
14:53:58 <Peaker> maurer: and I'm in favor of an extension that allows a module to exclusively allow only a specific module name (or package) to export some instance to avoid this problem
14:54:03 <monochrom> in a parallel universe, computers are designed for FP, not IP. therefore, their computers run FP faster and IP slower. a C program there is slow because it has to be compiled to Haskell first, and the compiled code uses 7 layers of monad transformers, that's why it's slow.
14:54:05 <maurer> Peaker: That does not strike me as particularly composable
14:54:08 <benmachine> maurer: manual optimisation is never going to catch up to compiler-driven optimisation
14:54:09 <boom583> One case against FP I hear is this: The good looking examples of FP are not fast. You can make them faster, at the cost of hard-to-understand code.
14:54:11 <boom583> Your answer?
14:54:26 <Peaker> maurer: That's a problem when you try to have better dependencies.. I'd classify that under dependency management more than under "type-classes" :)
14:54:32 <maurer> boom583: Depends. I've got plenty of good looking FP code that runs ~as fast as C code
14:54:33 <Cale> boom583: The same is true of code in any language?
14:54:36 <Peaker> maurer: and it has a simple solution (as I mentioned above)
14:54:39 <benmachine> boom583: there's a few answers, one is that a lot of work is going into fixing that
14:54:46 <c_wraith> boom583: you can also make them faster with good-looking code if you have better libraries.  (the libraries may be ugly, but so what?)
14:54:58 <c_wraith> boom583: see the beautiful folds paper for an example
14:54:58 <benmachine> boom583: stream fusion, for example, lets you write code that uses lists and compile it into code that doesn't
14:55:02 <Kron> oh god I look away from the screen for 2 minutes and wall of text ahahaha
14:55:03 <maurer> Peaker: In the module-oriented languages, code outside you rmodule can never make your module invalid, which is arguably more composable
14:55:10 <maurer> Peaker: Don't get me wrong, type-classes are great for engineering
14:55:11 <Cale> But to a much larger extent, naive code in Haskell can be secretly not-naive once it's compiled.
14:55:12 <Kron> thanks for the responses; I'm pretty sure OO can be emulated really well in haskell
14:55:18 <StoneCypher> boom583: are you seriously asking an irc channel to challenge other peoples' opinions
14:55:20 <Peaker> boom583: IME FP is slower than C code written by a C expert. But it has various advantages that (usually) make up for it.  For some code, I prefer C to Haskell when it doesn't make up for it
14:55:23 <benmachine> Kron: yeah we're not always this noisy, but sometimes several cool things come up at once
14:55:42 <maurer> boom583: The other big thing about FP over C is that I've written a bunch of programs using FP that would have taken me literally an order of magnitude longer to do in C
14:55:46 <Cale> Kron: Yeah, I used to have an article about it, but it was on a harddrive that I'm not sure I can get working again
14:55:47 <Peaker> maurer: That property is indeed useful for composability, as are other properties provided by type-classes but not by a module system
14:55:51 <c_wraith> boom583: http://squing.blogspot.com/2008/11/beautiful-folding.html for example
14:55:59 <maurer> boom583: And at this point, programmer time is far more expensive than computer time
14:56:00 <StoneCypher> there is no reason c cannot or should not be functional
14:56:08 <StoneCypher> this whole discussion is an issue of personal preference in most languages
14:56:09 <Cale> Kron: If you want, I could provide a bit of an example, but I have to go eat :)
14:56:14 <Kron> go eat
14:56:16 <Peaker> maurer: that is of course dependent on the particular case
14:56:18 <boom583> i see
14:56:19 <Kron> I'm going to drown in the discussion
14:56:39 <Cale> StoneCypher: There is a reason why writing functional programs in C is unduly difficult. It doesn't have functions.
14:56:41 <Peaker> there's a lot of code written that runs a lot of times and has to be very fast. Machine time is more expensive than programmer time then
14:56:47 <StoneCypher> Cale: :|
14:56:58 <StoneCypher> Cale: it isn't unduly difficult at all, and the style doesn't require language support
14:57:03 <Peaker> Cale: it has functions if you restrict yourself severely and weirdly :)
14:57:03 <maurer> boom583: tl;dr is that unless you're writing HFT code or videogame code (and even sometimes then) any slowdown is probably irellevant to you
14:57:04 <Cale> (not as proper values anyway)
14:57:07 <StoneCypher> Cale: obsequious purism is what leads to this sort of discussion
14:57:26 <maurer> Peaker: Sure, depends on domain, but that domain seems rare
14:57:35 <Cale> StoneCypher: Doing closure conversion by hand isn't my idea of a good time.
14:57:44 <Peaker> maurer: that domain is mostly "systems programming" (OS's, performance-oriented systems)
14:57:46 <StoneCypher> Cale: okay
14:57:58 <Peaker> StoneCypher: C can be functional (mostly, closures are problematic), but it's a tarpit
14:58:00 <maurer> Peaker: I've done systems programming in haskell! It even worked!
14:58:02 <quchen> Cale: Wouldn't writing only pure functions and passing them around via pointers be pretty functional
14:58:03 <quchen> ?
14:58:29 <benmachine> C can be functional, you can write void compileAndRunHaskell(char *program); // :D
14:58:49 <Peaker> maurer: In my non-Haskell time, I implement storage controllers, and they have to be really really fast. Haskell wouldn't work well there. We count the bits we spend in our data structures and the cache misses we have when following every ptr
14:58:55 <monochrom> I concur with benmachine.
14:59:17 <Peaker> benmachine: yeah, C is great at DSLs like that :)
14:59:44 <benmachine> quchen: it would, but wouldn't it be better to have a compiler that's specifically designed to work with that style?
14:59:50 <benmachine> compiler and language
15:00:03 <quchen> Sure.
15:00:19 <Peaker> maurer: the benefits of Haskell, for example, require polymorphic data structures. And bam, you lose the ability to unpack/unbox these structures, and have a lot of extra ptrs/indirection/misses :(
15:00:23 <monochrom> but I disagree with the return type "void". it should return a success-or-failure code
15:00:32 <ReinH> Of course oyu can write functional programs in C. Step 1: write Haskell.
15:00:40 <benmachine> monochrom: it makes me nervous when people agree with me, I'm suddenly worried I'll disappoint them with whatever I say next
15:00:44 <boom583> very interesting stuff
15:00:47 <ReinH> Or some bug-ridden implementation of half of Haskell
15:00:59 <quchen> ReinH: SPJ's tenth rule?
15:01:01 <Kron> pffft, you're all going about it wrong
15:01:04 <ReinH> benmachine: don't worry, we still have low expectations :)
15:01:05 <Kron> Step 1: Write lisp
15:01:10 <Kron> Step 2: Write haskell in lisp
15:01:16 <ReinH> quchen: something like that :)
15:01:17 <Kron> Step 3: Profit?
15:01:19 <benmachine> Step 3. Write GHC in Haskell
15:01:27 <Kron> hah
15:01:30 <ReinH> benmachine: except for the Hard Bits(TM)
15:01:36 <monochrom> Step 3: bankrupcy
15:01:36 <FireFly> What is step 4?
15:01:38 <benmachine> ReinH: depends what you think is hard :P
15:01:42 <Kron> Step 4: Write Idris
15:01:46 <ReinH> benmachine: I think the RTS is pretty hard ;)
15:01:49 <Kron> and make it properly lazy :I
15:02:01 <benmachine> ReinH: but typechecking's a pushover, right :P
15:02:11 <ReinH> benmachine: I didn't say other things were not hard :)
15:02:13 <Peaker> ReinH: mostly because of the parallelism correctness stuff, I think :)
15:02:24 <Peaker> The single-threaded RTS sounds easy :)
15:02:27 <ReinH> Peaker: mostly because of trying to reason about correctness in C ;)
15:02:41 <ReinH> and yes, the parallel bits seem to be where all the dragons have settled
15:03:16 <ReinH> SimonM talked a bit about the arcane debugging techniques he has developed for dealing with the parallel runtime
15:03:44 <monochrom> anyway, is there any discussion more interesting than "how does FP compare to OOP? how easy to make FP fast?" for the 10000th time?
15:04:08 <monochrom> I'll just be frank: I think we were trolled.
15:04:28 <Iceland_jack> monochrom: Can we ban that topic please? :)
15:04:44 <benmachine> no let's not
15:04:58 <ReinH> It's not a less fair topic because you've heard it before
15:04:59 <benmachine> we were trolled but I think nothing actually terrible happened as a consequence
15:05:05 <ReinH> I'm sure it's new to most non-haskellers
15:05:10 <Kron> I got haskell cancer
15:05:12 <Peaker> A channel about a PL is bound to infinitely repeat many discussions :)
15:05:12 <Kron> D:
15:05:29 <hpc> a channel is bound to infinitely repeat all discussions
15:05:35 <benmachine> @quote trolls
15:05:35 <lambdabot> xplat says: the underlying graph of a category is transitive.   transitive graphs have no bridges.  this is why trolls always have problems with category theory.
15:05:36 <monochrom> the part about the 10000th time is key in my opinion on this. from the 1st to the 10th time, I wouldn't call it trolling. but come on, it's the end of 2013, and 2014 is less than a month away. why else do people bring up a dead horse again?
15:05:37 <benmachine> @quote trolls
15:05:37 <lambdabot> jmcarthur says: we calmly talk trolls to death
15:05:38 <ReinH> If people aren't asking us about how FP compares to OO, it probably means Haskell is dead.
15:05:38 <benmachine> @quote trolls
15:05:39 <lambdabot> jmcarthur says: we calmly talk trolls to death
15:05:40 <Peaker> hpc: all of which are in Pi :: CReal
15:05:47 <benmachine> @quote Cale trolls
15:05:47 <lambdabot> Cale says: Here [#haskell], we feed trolls until they explode.
15:05:52 <quchen> Peaker: Glad we're not in a channel of a language that's universally hated. I pick "Haskell vs C" vs "your language sucks" any day.
15:06:09 <Peaker> quchen: I wouldn't enjoy being in #php, I suspect :)
15:06:11 <hpc> welcome to the internet, where science has managed to recreate the experiment of infinite monkeys on typewriters
15:06:16 <ReinH> monochrom: maybe it's not dead to them?
15:06:24 <nicoo> ReinH: Or that OO finally became obsolete
15:06:30 <ReinH> monochrom: it's not like every programmer suddenly learned about FP in 2013
15:06:37 <quchen> Peaker: I didn't wanna state the obvious ;-)
15:06:45 <nicoo> hpc: s/science/technology
15:06:57 <ReinH> Peaker: well, not being in #php and trying to defend it from such accusations
15:07:24 <benmachine> to be honest, comparing different approaches to programming is likely to remain relevant
15:07:24 <quchen> Especially when your only counterargument is "but Facebook uses it"
15:07:26 <ReinH> If it's really such a problem, surely there are definitive answers that can be put on a wiki page.
15:07:45 <Peaker> quchen: or "backwards compatibility" or "other languages are all imperfect too"
15:08:19 <benmachine> ReinH: no answer will be definitive for more than a couple of years at most, IMO
15:08:39 <benmachine> that's one of the things that's exciting about Haskell is that it evolves so fast (and some of its competitors evolve right along with it)
15:08:54 <ReinH> The point is: if we're tired of answering the question, put an answer on the wiki and refer people to it.
15:08:55 <nicoo> benmachine: Yes. Somehow, few people compare stuff to Array Processing Language anymore (though I'm sure it is relevant w.r.t. “Big Data”)
15:09:20 <ReinH> It's a valid question that indicates an interest in Haskell
15:09:28 <benmachine> the other point is: if we're tired of answering the question, we should feel free to go get some other hobbies
15:09:39 <benmachine> we're not the Haskell Question Answerers
15:09:44 <benmachine> we're just people who hang out in here
15:10:37 <StoneCypher> i am the haskell question answerer. which makes that i don't speak haskell all the more entertaining.
15:10:49 <Kron> bah, what we should do is teach lambdabot to answer these questions
15:10:52 <Kron> can't be that hard
15:10:55 <quchen> It can!
15:10:57 <ReinH> or that
15:11:04 <quchen> @faq Can Haskell answer these questions?
15:11:05 <lambdabot> The answer is: Yes! Haskell can do that.
15:11:11 <StoneCypher> Kron: it's quite easy if accept the lord rtfm into your heart as every answer
15:11:16 <Apocalisp> What is the question?
15:11:24 <ReinH> Apocalisp: Yes.
15:11:33 <Cale> monochrom: There are still a lot of people who don't know this stuff!
15:11:36 <dwcook> @faq Can Haskell be used to code the malicious AI that eventually eliminates the human race?
15:11:36 <lambdabot> The answer is: Yes! Haskell can do that.
15:11:53 <ReinH> @faq Can Haskell be?
15:11:54 <lambdabot> The answer is: Yes! Haskell can do that.
15:11:59 <ReinH> Shit just got existential.
15:12:09 <dwcook> I hear that's an antipattern.
15:12:10 <Kron> @faw Can
15:12:10 <Cale> monochrom: It's easy to think that everyone should know by now, but everyone is a lot of people, and FP is still somewhat marginal.
15:12:10 <lambdabot> The answer is: Yes! Haskell can do that.
15:12:17 <shachaf> Can people stop using @faq?
15:12:19 <Kron> now this is just getting silly
15:12:20 <shachaf> (Yes.)
15:12:29 <nicoo> @faq Can GHCi be used to produce a singularity and destroy the Earth?
15:12:29 <lambdabot> The answer is: Yes! Haskell can do that.
15:12:32 <Kron> I didn't even spell faq properly
15:12:39 <ReinH> Kron: close enough
15:12:51 <shachaf> It is just amplified spam.
15:12:52 <Kron> @qap floobidy boobidy
15:12:52 <lambdabot> Maybe you meant: slap faq
15:13:03 <Kron> LOL
15:13:09 <Cale> Some of them *might* be trolls, sure, but sometimes even trolls can learn something if you feed them with valid information.
15:13:12 <nicoo> @pl spam
15:13:13 <lambdabot> spam
15:13:32 <dwcook> nicoo, well that was indeed pointless.
15:13:36 <Cale> (and even if not, then there are lots of lurkers who are likely just starting out too)
15:13:47 <StoneCypher> and now to troll
15:13:53 <StoneCypher> @faq Can Haskell fail?
15:13:53 <lambdabot> The answer is: Yes! Haskell can do that.
15:13:54 <quchen> Accidentially dropping in is the best way of learning from #haskell for me so far, Cale. ;-)
15:13:58 <Kron> it's not like trolling is uncommon in #haskell anyway
15:14:06 <Kron> I remember being trolled by the person who started this channel
15:14:09 <Kron> pretending to be a newbie
15:14:16 <Kron> or something like that
15:14:16 <shachaf> StoneCypher: Trolling is not OK. Please stop.
15:14:23 <StoneCypher> shachaf: ... :(
15:14:26 <benmachine> Kron: oh, I remember that too, that was fun :D
15:14:32 <benmachine> that wasn't really trolling though
15:14:36 <Kron> yeah it's all fun and games when you troll the new girl :P
15:14:37 <nicoo> dwcook: Thanks, someone got the joke \o/
15:14:41 <StoneCypher> it was not.  and people who actually troll are fine.
15:14:46 <Kaidelong> @hoogle fail
15:14:46 <benmachine> that was insincerity, but not for the sake of upsetting anyone
15:14:47 <lambdabot> Prelude fail :: Monad m => String -> m a
15:14:47 <lambdabot> Control.Monad fail :: Monad m => String -> m a
15:14:47 <lambdabot> Control.Monad.Instances fail :: Monad m => String -> m a
15:15:02 <Kron> I felt very embarassed when everyone laughed at my attempts to help at the end
15:15:05 <StoneCypher> benmachine: i was just trying to get a laugh
15:15:06 <Kron> that wasn't nice
15:15:19 <benmachine> StoneCypher: I wasn't talking to or about you
15:15:24 <StoneCypher> ah.
15:15:25 <Kaidelong> > [1,2,3,4] + fail "emptylist"
15:15:26 <lambdabot>  No instance for (GHC.Show.Show t0)
15:15:26 <lambdabot>    arising from a use of `M478062927649009570522374.show_M4780629276490095705...
15:15:26 <lambdabot>  The type variable `t0' is ambiguous
15:15:26 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
15:15:26 <lambdabot>  Note: there are several potential instances:
15:15:38 <Kaidelong> > [1,2,3,4] ++ fail "emptylist"
15:15:39 <lambdabot>  [1,2,3,4]
15:15:44 <Cale> Kron: shapr?
15:15:49 <Kron> I think so
15:15:50 <benmachine> yes
15:16:02 <benmachine> shapr tested us
15:16:06 <benmachine> apparently we passed :P
15:16:13 <Cale> :D
15:16:23 <dwcook> benmachine, how did this test go?
15:16:28 <dwcook> I mean, besides passing
15:16:43 <benmachine> dwcook: he asked us some newbie haskell questions to see if we would be nice to him
15:16:53 <Kron> basically shapr pretends to be a new person and asks basic questions and ropes people like me into helping him
15:17:00 <Kron> and then everyone laughs :$
15:17:12 <dwcook> Oh I see, they didn't even disguise their nick?
15:17:13 <benmachine> Kron: aww we didn't laugh!
15:17:17 <Iceland_jack> That's what you get for being helpful Kron
15:17:17 <benmachine> except, in a good way
15:17:19 <Kron> I feel insecure enough as is trying to learn this language
15:17:48 <Cale> Kron: Don't worry, we were all beginners too :)
15:18:07 <dwcook> From what I've seen of this channel, asking newbie questions is the best way to get lots of people to be helpful.
15:18:08 <Cale> It's good that you're trying to help! It's a good way to learn in itself.
15:18:19 <benmachine> *It's good that you're helping!
15:18:29 <Cale> Indeed, that too!
15:18:31 <Cale> :D
15:19:03 <Kron> I'm still a newbie myself
15:19:12 <Kron> I can't tell if I'm talking out of my ass every time I try to help someone
15:20:21 <Cale> Well, if you mess up some detail here, there are enough people around who you can count on to nitpick, I think :)
15:20:35 <Fyl> Kron: i don't think it gets any better than that
15:21:45 <benmachine> well. I think people can be categorised into those who do and don't worry if they are talking out of their arse, pretty much independent of what they are talking about and how much they know about it
15:21:49 <benmachine> I know which I prefer
15:22:01 <Cale> Kron: So about encoding objects...
15:22:18 <Cale> Kron: You might imagine some type like:
15:23:13 <Fyl> benmachine: which one? :3
15:23:51 <Cale> data GameObject = GO { display :: Picture ; timeStep :: DeltaTime -> GameObject ; handleEvent :: Event -> GameObject ; ... }
15:24:43 <benmachine> Fyl: the former, although ideally not so much that they don't talk at all
15:24:48 <Cale> (and you might want to pass in some representation of the world, and the GameObject results of those things might better be lists or something, and in any reasonable setting, you'd have more methods, but I just want to sketch an idea
15:24:50 <Cale> )
15:25:08 <Kron> Cale: right
15:25:09 <Cale> You might have something like:
15:25:12 <benmachine> but I think I'm going to stop giving inspirational speeches because they are a wonderful way to arse-talk >_>
15:25:23 <Cale> rocket pos vel acc = GO { .. }
15:25:27 <Cale>  where
15:25:52 <ReinH> Kron: we will train the helpfulness right out of you. :D
15:25:54 <Cale>   display = circle 0.5 pos
15:25:56 <Fyl> heh
15:26:10 <benmachine> ReinH: wait, what?
15:26:10 * hackagebot monad-par 0.3.4.6 - A library for parallel programming based on a monad  http://hackage.haskell.org/package/monad-par-0.3.4.6 (RyanNewton)
15:26:37 <StoneCypher> is there a small, relatively simple tool which haskell people need?  i enjoy learning most when i'm doing something of communal value.
15:26:39 <ReinH> benmachine: jokes.
15:26:50 <StoneCypher> an example in my opinion might be erlang's prior need of a sinatra-style stub webserver.
15:26:59 <Kron> hmmmm
15:27:06 <Cale>   timeStep dt = rocket (pos ^+^ (dt *^ vel) ^+^ (dt^2 / 2) *^ acc) (vel ^+^ (dt *^ acc)) acc
15:27:06 <benmachine> ReinH: okay, if you say so :P
15:27:13 <ReinH> benmachine: semi-jokes.
15:27:20 <Kron> StoneCypher: structured haskell mode looks really neat, and is slightly unfinished, but you'll have to ask the developer if you can help him work on it
15:27:23 <Cale> etc.
15:27:26 <Kron> also I'm not sure how much haskell coding is involved
15:27:27 <Kron> may be lisp
15:27:33 <Kron> and may be really damn complicated actually
15:27:35 <Kron> nevermind
15:27:41 <StoneCypher> i would rather build something on my own; given my novice status the damage is easier to limit that way
15:27:46 <Kron> the more I think about it the more vastly complicated it gets in my head
15:27:47 <benmachine> StoneCypher: you might find something you like on here http://www.reddit.com/r/haskell_proposals
15:27:50 <Kron> sure
15:27:53 <StoneCypher> benmachine: win, thank you
15:27:57 <ReinH> benmachine: that's a thing? Awesome.
15:28:51 <Cale> Kron: So, in this pure OO sort of model, you just have the object respond to any of its methods that would normally cause an update with an updated version of itself in the result.
15:29:09 <Cale> Kron: You could also use internal IORefs or something, if you wanted.
15:29:21 <Kron> right
15:29:31 <Kron> StoneCypher: what sort of haskell coding do you want to practice?
15:29:35 <Kron> I myself made a toy natural number library
15:29:39 <Kron> great practice for typeclasses
15:29:44 <Cale> This kind of thing is my favourite application for the RecordWildCards extension
15:29:50 <Kron> also I wrote a basic memoization system (higher order functions)
15:30:01 <Cale> Because it lets you define the methods in a where clause, and give the function parameters naturally.
15:30:02 <Kron> and an 8 queens solver (recursion and general problem solving)
15:30:26 <Cale> (Though I think we probably ought to address that at some point in the actual syntax of records)
15:30:27 <Fyl> i remember someone saying that strictness makes composability harder for OCaml, someone care to elaborate?
15:31:00 <Kron> Fyl: it basically means you keep having to 'finish' each function before you use the next
15:31:04 <Kron> consider something like this:
15:31:07 <Cale> Fyl: There's a lovely old paper called "Why Functional Programming Matters" which gives a few really nice examples of that
15:31:07 <scott_> map f (map g xs) would make an intermediate list in ocaml but not haskell, iiuc
15:31:11 * hackagebot azurify 0.4.0.1 - A simple library for accessing Azure blob storage  http://hackage.haskell.org/package/azurify-0.4.0.1 (GregWeber)
15:31:13 <Kron> map (*2) (map (+3) list)
15:31:26 <Kron> we take a list and we add 3 to everything and multiply each element by 2
15:31:30 <Cale> scott_: Well, it would in Haskell too, but that intermediate list doesn't have to be allocated all at the same time!
15:31:31 <Kron> in ocaml it would make two passes over the list
15:31:35 <Kron> constructing an intermediate list
15:31:39 <Kron> in haskell it makes one pass
15:31:42 <SLi> Hey, I'm writing a program with (bounded) binary input and text output. I think I'll use Data.ByteString.Strict for input, but I'm wondering about whether (and why) I should use ByteStrings for output too, or String. Is there something that either provides but the other doesn't? Unicode support?
15:31:43 <Kron> doing both things to each element
15:32:07 <Cale> (and in GHC, if you turn on optimisations, your program is rewritten not to build the intermediate list cells at all -- it transforms map f . map g into map (f . g)
15:32:08 <Cale> )
15:32:17 <benmachine> I wrote some of this article which has some noise about laziness http://www.haskell.org/haskellwiki/Non-strict_semantics
15:32:33 <benmachine> actually I wrote all of it but I can't remember if it's any good, so just pretend I wrote the good bits
15:32:42 <Fyl> ah I see, i'll take a look at it then, thanks
15:33:00 <Cale> But yeah, laziness means that you don't have to mix the logic for *how far to search through something* into the logic for creating the thing you're searching through.
15:33:02 <SLi> Actually I think I don't want my output to be strict (using Data.ByteString.Strict.interact would force the computation to finish before outputting anything, right?), but I could choose either String or lazy bytestrings for output...
15:33:35 <benmachine> SLi: consider the "text" package for text
15:33:36 <Kron> SLi: you could just flush the buffer after writing to it lazily
15:33:40 <benmachine> it is aptly-named
15:33:42 <Kron> that kidna strictly does it I guess?
15:33:46 <Kron> *kinda
15:33:46 <benmachine> and comes in strict and lazy versions
15:33:50 <Cale> Fyl: For instance, suppose you're writing an AI for some game, you'd really rather define the whole game tree, and then search through it separately, than mix all the considerations about whether some branch is worth exploring into the code which generates the options.
15:33:54 <SLi> Ah, one more option :)
15:33:59 <benmachine> and is really clever at the things that it's really hard to be clever about, like unicode
15:34:22 <benmachine> text is great and every Haskeller should know about it
15:34:44 <Kron> SLi: in general look into the "seq" command
15:35:14 <Peaker> benmachine: recently an article had a bunch of test cases for unicode, does "text" pass them?
15:35:15 <SLi> Kron: yeah, I know about that; I don't think I have a lazy vs strict problem so much as a string vs bytestring vs text problem.
15:35:20 <Cale> Fyl: Or, suppose you're doing a numerical approximation -- it can be much prettier to express an infinite sequence of improving approximations and then separately act on that to determine one which is sufficiently good.
15:35:23 <Kron> gotcha
15:35:43 <benmachine> Peaker: I have no idea
15:35:47 <Cale> Fyl: Or for a simpler example... it lets you do things like this to search for a substring:
15:36:05 <Peaker> it was about the ability to work with the glyphs rather than code-points (reversing them, counting them), I can see if this is not an intended feature.     And about up-casing various special-case glyphs
15:36:09 <SLi> Ha, found a stackoverflow question about it :) http://stackoverflow.com/questions/7357775/haskell-text-or-bytestring
15:36:10 <Cale> > any (isPrefixOf "orl") (tails "Hello, World!")
15:36:12 <lambdabot>  True
15:36:16 <benmachine> Peaker: might need text-icu to be really clever about it
15:36:19 <Peaker> apparently "upcasing" is a locale-specific operation
15:36:26 <benmachine> yep
15:36:36 <benmachine> and changing case of a string can change its length
15:37:24 <Cale> Fyl: In a strict language, building the list of tails, and then checking them to see if any have the given string as a prefix seems really wasteful. Under lazy evaluation, it's just the naive nested-loops thing with an early break.
15:37:36 <StoneCypher> Kron: I don't really know yet
15:37:42 <SLi> Hm, String is... mosty just legacy? So I should basically mostly use Text for text, ByteStrings (either variant) for binary data, and generally avoid String?
15:37:50 <StoneCypher> Kron: i'm sufficiently new and the language is sufficiently large that it's not clear which piece to playwith first
15:38:03 <Fyl> Cale: i see.  would you say it makes sense for a language to be optionally lazy (kinda like the reverse of Haskell) ?
15:38:07 <Kron> start with basic recursive stuff then StoneCypher
15:38:11 <jmcarthur_mobile> String is fine for low perf stuff, really.
15:38:18 <haasn> Fyl: most languages are like this
15:38:18 <Kron> ever written an 8 queens problem solver before?
15:38:38 <Cale> Fyl: Well, it makes sense in that it can be done, but I think it loses a lot of the benefit
15:38:44 <Kron> Fyl: I think every language ranging from C to Ocaml is strict + optionally lazy
15:38:49 <jmcarthur_mobile> Well, unless you need really good unicode aware text processing or, well, byte strings...
15:38:58 <Cale> Fyl: The thing is, if you don't make the default lazy, all your library functions end up being strict.
15:39:02 <jmcarthur_mobile> Or performance of course
15:39:10 <benmachine> OCaml has laziness annotations but they're not really any good if the language is "culturally" strict (all the libraries are strict)
15:39:54 <haasn> is there a good case study of eagerness-by-default vs laziness-by-default for a language like Haskell?
15:39:59 <Fyl> I see, though most languages don't have "first-class" support for laziness
15:40:03 <jmcarthur_mobile> What benmachine said a million times
15:40:14 <Hodapp> who has a recommendation for a simple library to let me write a raster image?
15:40:27 <Fyl> I figure if you wanted to do it in C you'd have to jump through hoops or something, right?
15:40:44 <scott_> Is Show [Char] special-cased? I don't see it in the list of instances when I do :i Show
15:40:55 <benmachine> Fyl: yeah. this is in fairness also what you have to do if you want to handle errors or allocate memory in C :P
15:40:55 <Cale> Fyl: and since the benefit of lazy evaluation mostly has to do with being able to break problems down into new ways that lets you reuse code, it kinda defeats the purpose when you break the problem down like that, and then some library function is too strict and you have to rewrite it.
15:41:10 <benmachine> scott_: yes and no
15:41:30 <benmachine> scott_: there's no magic
15:41:34 <Cale> Also, if you want actual functions in C :)
15:41:42 <benmachine> scott_: there is Show a => Show [a] and Show Char
15:41:46 <monochrom> scott_: the trick is a combination of the showList method and the instance "instance Show a => Show [a]" using a's showList
15:41:56 <Fyl> Cale: C does have functions, the word just doesn't mean the same :]
15:42:09 <Cale> Fyl: well, yeah, that's why I used the word "actual" :)
15:42:25 <Fyl> Cale: but yea I see the problem with strict-by-default
15:42:25 <osa1_> anyone here has working code for exercises in "implementing fun langs: a tutorial" by SPJ?
15:42:37 <scott_> monochrom: Aha! Now it makes sense
15:43:09 <Cale> scott_: This is probably not the way that we'd have designed the Show class today, I think.
15:43:12 <scott_> I guess I thought of Show as just show, but that's not accurate
15:43:29 <Fyl>  /golfclap
15:43:48 <benmachine> Cale: how would you do it?
15:44:17 <Cale> scott_: It's just a consequence of the fact that around the time Haskell was being specified, type classes were still pretty new, so they were very conservative about what sorts of instances you'd be allowed to write
15:44:27 <monochrom> IMO "C has function" is of the same low calibre as "C++ has functors"
15:45:01 <benmachine> Cale: you can't have both instance Show String and instance Show a => Show [a]
15:45:15 <Cale> In particular, in Haskell 98, you can only write instances for a type constructor applied to some distinct variables
15:45:26 <benmachine> well, you can, but only if you sell your soul first
15:45:34 <Cale> benmachine: Well, that's true! :)
15:45:57 <benmachine> monochrom: I agree but I would argue that saying "C doesn't have functions" without further explanation to a C programmer is poor communication
15:46:04 <Cale> So maybe there's a good reason to still do it like this anyway.
15:46:14 <Cale> But yeah, H98 didn't even have FlexibleInstances
15:46:26 <StoneCypher> Kron: no i'm used to fp; i'm an erlang jerk.  it's the language i need to play with, not the rudimentary concepts.
15:46:38 <Cale> So you couldn't write instance Show [Char] even if you wanted to forego the general list instance.
15:46:55 <benmachine> Cale: as much as I think FlexibleInstances is sensible, I like how the H2010 setup means the issue of overlapping instances doesn't even come up
15:47:16 <benmachine> instances are distinct or identical :P
15:47:16 <Kron> ahhh
15:47:17 <Fyl> StoneCypher: how different is erlang from haskell?
15:47:40 <StoneCypher> very
15:47:45 <Kron> StoneCypher: try fiddling with typeclasses and monads then?
15:47:53 <monochrom> benmachine, I would not go to ##c to say "C doesn't have functions" or ##c++ to say "C++ doesn't have functors". If I went to them, I would respect and stick to their vocabulary. but I am not there. I am here, in #haskell. I am using #haskell vocabulary.
15:47:57 <StoneCypher> k.  what's a good useful project in that direction?
15:48:05 <dwcook> monochrom, I like to call what C has "procedures". Unfortunately it's not popular terminology. :P
15:48:05 <Kron> I made natural numbers
15:48:07 <Kron> usign newtype
15:48:10 <benmachine> monochrom: that's a sensible approach
15:48:15 <Kron> basically to allow something to be a part of Num
15:48:30 <Kron> you need to add it to Ord, Eq, Enum, etc. etc. too
15:48:43 <Cale> dwcook: C doesn't even have what I'd call procedures ;)
15:48:46 <benmachine> Kron: newtype over integers?
15:48:47 <Kron> so eventually you end up implementing the number across a big chain of like 10 typeclasses
15:48:49 <Kron> yeah
15:48:56 <Kron> *using
15:48:59 <haasn> dwcook: subroutine :P
15:49:06 <dwcook> Cale, I actually use the term for most concepts of functions. Not Haskell's though. What do you say procedures are?
15:49:06 <Kron> implement it for Show and stuff too
15:49:11 <scott_> Use data Nat = Z | S Nat, even funner
15:49:12 <Kron> and maybe Storable if you're interested in that
15:49:25 <Kron> you can see everything a normal Num like Int is defined for using ":info" I think
15:49:40 <Cale> dwcook: Something more like scheme's procedures. i.e. you're allowed effects, but you still have to capture the values of variables in scope at your point of definition.
15:49:46 <Kron> also make it a monoid I suppose
15:49:55 <dwcook> Cale, besides Scheme, what has those?
15:50:02 <benmachine> yeah you can write natural numbers as ordinary datatypes if you're that way inclined
15:50:05 <Cale> dwcook: All the MLs
15:50:13 <benmachine> inefficient but cute, especially when you realise they're lazy
15:50:32 <scott_> Kron: You sort of get the sum and product monoids for free if you make your type a Num
15:50:36 <dwcook> Cale, what is an example of C failing to do that?
15:50:47 <scott_> Kron: Sum Nat and Product Nat would automatically be monoids
15:50:55 <Kron> scott_: gotcha
15:51:03 <Kron> implementing Enum was the most fun bit
15:51:16 <Kron> getting Nats to go [0,1,2,3] when you type in [..3]
15:51:19 <Kron> is just kinda magical
15:51:31 <scott_> Haha, nice
15:51:34 <benmachine> wait, what?
15:51:38 <Cale> dwcook: Well, in C, I guess you can't even locally define functions anyway.
15:51:40 <benmachine> I'm not sure that's a thing :P
15:52:08 <Kron> or maybe it was [3,2..]
15:52:11 <Kron> I forget how I wrote it
15:52:12 <scott_> Err, yeah, that doesn't parse
15:52:17 <scott_> That would make sense
15:52:19 <dwcook> Cale, oh yeah. C basically just has "global", "compilation-unit-global", and "local", right?
15:52:21 <Kron> but I distinctly remember constructing an enum expression
15:52:22 <benmachine> [3,2..] makes sense, yeah
15:52:23 <Kron> that was unbounded
15:52:26 <dwcook> Or not even "global"
15:52:28 <Kron> and used the natural number bounds to stop at 0
15:52:32 <benmachine> yep
15:52:42 <Kron> hmmmm
15:52:47 <scott_> Works with Data.Natural
15:52:53 <scott_> λ. [3,2..] :: [Natural]
15:52:53 <scott_> [3,2,1,0]
15:52:55 <Cale> dwcook: But if you try to simulate first class procedures by passing around function pointers, you run into the problem that you can't really have new procedures at runtime which you didn't write by hand.
15:53:10 <Cale> (You can only point at stuff which you wrote in its entirety)
15:53:37 <dwcook> I wonder how you'd implement a language containing first-class procedures in C.
15:53:55 <benmachine> Cale: hmmm. like, you can't have a fnptr compose(fnptr f, fnptr g) sort of thing?
15:53:56 <Cale> You usually implement them using closures
15:54:11 <Cale> benmachine: That's a great example of it
15:54:15 <Twey> Why doesn't linear have a quaternion normalization function?
15:54:15 <monochrom> part of defunctionalization may also help
15:54:36 <Cale> benmachine: In fact, that should be *the* canonical example. Thank you for that :)
15:54:41 <joelteon> what is Natural from?
15:54:43 <benmachine> Cale: haha, okay :)
15:54:48 <joelteon> there are several Data.Natural packages
15:55:03 <scott_> joelteon: Sorry, natural-numbers
15:55:08 <joelteon> ok
15:55:20 <Cale> The extent to which a language is a functional language is often the extent to which it makes it easy to work with function composition.
15:56:17 <benmachine> Twey: why don't I have a pony? :(
15:56:38 <Cale> benmachine: Because you didn't cabal install pony
15:56:41 <_justjust> hey, i read about the arrow calculus (http://homepages.inf.ed.ac.uk/wadler/papers/arrows-jfp/arrows-jfp.pdf) and wonder if there are any practical advantages (e.g. for the normal haskeller) over patersons arrow notation sugar
15:56:51 <Cale> http://hackage.haskell.org/package/pony
15:57:01 <benmachine> Cale: ...actually I did
15:57:03 <benmachine> good going, past self
15:57:38 <monochrom> Wadler's arrow calculus has not been implemented. that is one practical concern.
15:58:22 <_justjust> i see, do you know why?
15:58:41 <monochrom> I don't know. I guess because too few people know about it.
15:59:25 <Cale> Also, I think it's kind of okay for it not to be implemented, because Arrow is actually somewhat the wrong thing anyway. We need to get that right first, and then worry about an analogous calculus :)
15:59:52 <Cale> (Or I guess we could do those simultaneously :)
16:00:18 <benmachine> implementation leads to theory at least as often as the other way around
16:00:49 <_justjust> Cale: can you tell me more about what you mean by 'wrong thing anyway'?
16:01:42 <Cale> _justjust: Okay, so a big reason that Arrow exists is to provide some hope for combinator libraries that are able to do some kind of analysis on the computations they define before running them.
16:01:46 <Cale> With Monad
16:01:53 <Cale> whenever you have x >>= f
16:02:19 <Cale> the f is a function, which is completely opaque -- in order to see any part of what it produces, you need to apply it to an argument
16:02:33 <Cale> and that basically means that you have to execute x (whatever that means in context)
16:02:44 <Cale> With Arrow, you have >>>
16:03:24 <Cale> both of the arguments to (>>>) are values of a datatype that the person writing an instance has control over, so perhaps (>>>) can do something to simplify the composition of them
16:03:49 <rtpg> Arrows also have that one paper (Causal Commutative Arrows), where you can basically simplify any composition of Arrows (that implement loop) into one arrow, one loop, and a pure function
16:04:04 <Cale> But Arrow also has arr
16:04:35 <Cale> Whenever you hit an arr f, that's a black box that you can't see inside to do any analysis again
16:04:49 <Cale> That *might* be okay, if arr were sufficiently rare
16:05:26 <Cale> But the way that Arrow is now, and the way that proc/do notation works, you typically end up with arr stuffed in between almost every meaningful pair of computations
16:06:00 <rtpg> If you're using Arrows as an effect system , then arr is kind of a no-op for the kind of interesting optimizations though
16:06:10 <Cale> because Arrow doesn't provide primitives to do the sort of wiring that's required, and instead relies on things like arr (\(x,y) -> (y,x)) to cross wires over for instance
16:07:05 <Cale> So even if all your arrs are this "no-op" sort of thing which just involves manipulating some nested arrangement of pairs into some other nested arrangement of pairs, they still spoil your analysis!
16:08:09 <Cale> and this is, I think a major reason why Arrow doesn't really see more use -- it sort of undermines the niche of applications it would be good for
16:08:36 <ReinH> ocharles: ping
16:09:16 <rtpg> Cale, this paper is kind of interesting given your remarks -> http://cs.yale.edu/c2/images/uploads/ICFP-CCA.pdf
16:09:33 <_justjust> ok thank you Cale and rtpg for the papers
16:09:47 <Cale> At iPwn, we had our own Arrow class, which apart from being broken up more into smaller pieces (arr was still there, but separated out), also included many operations for explicitly swapping, reassociating pairs, and doing things like left and right identity contraction/introduction
16:09:52 <rtpg> you seem to be saying that we need a lot more usage of some more arrow combinators, but that paper is basically "we only want one loop and one arr"
16:10:09 <Cale> Basically, if you look up the definition of a symmetric monoidal category, the isomorphisms there are the stuff that's missing :)
16:10:53 <rtpg> my comprehension is limited to arrows as dataflow diagrams, I try to avoid thinking about the mathematical structures behind them
16:10:57 <Cale> We also implemented a source -> source preprocessor which used our additional primitives to implement the proc/do notation, and that provided some pretty crucial performance benefits.
16:11:09 <Peaker> Cale: what happened with iPwn?
16:11:26 <Cale> Peaker: Ryan ran out of money to fund it
16:12:04 <Peaker> Cale: oh :(  no angel/VC to be found?
16:12:11 <Peaker> Cale: also, how far towards a product did you go?
16:12:28 <arkeet> I don't like arr =(
16:12:37 <Cale> So all our stuff is sitting for a while. Hopefully, we'll be able to return to it at some point and write some papers and open source some of it, if not finish something that we can actually sell.
16:13:46 <Peaker> Cale: any attempts to find funding?  There are some VC's/angels with too much money on their hands
16:15:07 <Cale> Peaker: Well, we had fairly playable combat (it was actually kind of fun just to play against a bunch of AIs), and a big world and lots of art and music and sound effect resources, but that world was empty as far as NPCs were concerned, and a lot of the stuff to take the engine we had and make the game we actually wanted to make hadn't been done yet.
16:15:45 <Cale> Also, at the time, the engine still needed some work to be able to run fast enough on the phones we wanted to run it on. If we were to revive the project now, that might be different :)
16:15:46 <quchen> Cale: What was iPwn in the first place? Searching for it is a little hard, and skimming the scrollback didn't help either.
16:15:57 <slack1256> I ended up on a tiny application with a monad-transformer of 4 layers
16:16:01 <Peaker> Cale: NPCs?
16:16:08 <Cale> Peaker: non-player characters
16:16:14 <slack1256> the thing is, I don't know how to organizate a application on another way, any tips?
16:16:24 <_justjust> rtpg: cc arrows look really interesting, thanks
16:16:49 <Feuerbach_> slack1256: you should at least point to the code
16:16:59 <Cale> Peaker: Basically, we had it to the point where it was a little combat arena (with a gigantic empty world), rather than a full action roleplaying game.
16:17:15 <Peaker> Cale: sounds nice, couldn't you keep the flame going as a side-project or such?
16:17:42 <slack1256> Feuerbach_: Is private code, and ugly and embarrasing
16:18:30 <Cale> Peaker: Yeah, I probably should have another good look at it, and see what I can do. I know that there will have to be a lot of changes made now just because (Arrow (~>)) => ... no longer works
16:18:50 <_justjust> Cale: kickstarter sounds like a good idea for something of which you can show something already
16:18:53 <Cale> (though perhaps Stephen did something about that...)
16:19:00 <Peaker> Cale: heh
16:20:15 <Cale> quchen: It was a company working on an action RPG called BloodKnight for iPhones and other mobile devices in Haskell.
16:20:27 <scott_> What do I need to make (# Foo, Bar #) tuples parse?
16:20:35 <Cale> quchen: We didn't finish it, but I learned a lot about FRP in the process.
16:20:58 <Cale> UnboxedTuples
16:21:01 <tristanStrange> any one playing with this csound-expression thing?
16:21:04 <scott_> Thanks
16:21:09 <arkeet> isn't Arrow basically Strong Profunctor + Category?
16:21:34 <tristanStrange> just getting in to haskell. saw this got all excited and then discovered the first example doesn't work :-/
16:21:42 <Cale> arkeet: Well, there's ***
16:21:51 <arkeet> Cale: f *** g = first f . second g
16:22:06 <arkeet> first and second are provided by Strong
16:22:11 <Cale> arkeet: Oh, right, Strong defines first and second, yeah
16:22:30 <Cale> welll...
16:22:30 <Feuerbach> Cale: you guys created Sodium, didn't you?
16:22:46 <Cale> Feuerbach: Stephen Blackheath did, and he was working with us
16:22:51 <zRecursive> :t second
16:22:52 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
16:22:56 <arkeet> :t second'
16:22:57 <lambdabot>     Not in scope: second'
16:22:58 <lambdabot>     Perhaps you meant `second' (imported from Control.Arrow)
16:23:01 <arkeet> bah
16:23:06 <arkeet> @let import Data.Profunctor
16:23:07 <lambdabot>  .L.hs:97:1:
16:23:07 <lambdabot>      Data.Profunctor: Can't be safely imported!
16:23:07 <lambdabot>      The package (profunctors-4.0.1) the module resides in isn't trusted.
16:23:07 <Cale> Sodium wasn't the FRP system we were using, it was another one that Stephen wrote afterward.
16:23:09 <arkeet> =(
16:23:35 <Peaker> arkeet: the ability to override (***) and (&&&) to do these things in parallel or what not is important, though
16:23:36 <Feuerbach> Cale: I see
16:23:47 <philipdexter> what's the term, might be specific to amortized analysis, of the `thing' that always gives you the worst sequence of operations, kind of the opposite of an oracle
16:23:56 <zRecursive> :t (***)
16:23:57 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
16:23:59 <arkeet> Peaker: is it?
16:24:16 <Peaker> arkeet: I think it's one of the few things still useful in the silly Arrow class
16:24:25 <arkeet> oh, my thing doesn't have (&&&)
16:24:33 <zRecursive> :t (&&&)
16:24:33 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:24:41 <Cale> yeah, there's that too :)
16:24:45 <arkeet> wait it does sort of
16:24:50 <Peaker> arkeet: (&&&) is just (***) . arr (join (,)) ?
16:24:54 <arkeet> yeah
16:25:19 <Cale> So yeah, it's kind of the same thing
16:25:22 <Peaker> though you don't want a black box like "arr (join (,))". You want your data-type to be aware of the splits/flows
16:25:24 <Cale> I'm not sure about the laws
16:25:30 <arkeet> yeah
16:25:44 <Peaker> if you e.g compile it or such
16:25:53 <Cale> The Arrow laws from Hughes' paper are bad anyway because they leave out what's perhaps the most important one :P
16:25:59 <arkeet> which one?
16:26:12 <Cale> (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k)
16:26:15 <arkeet> heh.
16:26:21 <Cale> He specifically rejects that law
16:26:31 <Cale> If you want that law, you give up on the instance for Kleisli
16:26:52 <Cale> But I think that law is required if you want to maintain any kind of sanity while writing Arrow code.
16:26:52 <arkeet> hmm yeah
16:26:58 <ReinH> Well this is cool. GPU programming in Rust by targetting PTX via LLVM. http://www.cs.indiana.edu/~eholk/papers/hips2013.pdf
16:26:59 <jj2baile> philipdexter: The Adversary; Perhaps?
16:27:07 <Cale> It's what allows you to think of Arrow computations by wiring diagrams.
16:27:13 <arkeet> well, Kleisli makes for a fine Strong Profunctor + Category
16:27:19 <Cale> Otherwise, the way that you chop up the diagram matters.
16:27:25 <ReinH> I wonder... is there a way to leverage the GHC LLVM backend to do something like this?
16:27:42 <Cale> I want Arrow = Symmetric Monoidal Category
16:27:52 <Cale> (perhaps with the monoidal part specialised to (,) ())
16:28:29 <ReinH> carter: you've probably looked at this right? (Targetting PTX via LLVM)
16:28:33 <arkeet> that doesn't give you (&&&) does it?
16:28:33 <Cale> and all the isomorphisms that are part of the definition of that made explicit, rather than relying on arr
16:28:38 <philipdexter> jj2baile: yeah, that rings a bell, for some reason the term has slipped my mind temporarily and it's been bugging me all day
16:28:42 <carter> ReinH: eh? eventually yes
16:28:44 <carter> context?
16:28:53 <Cale> arkeet: You're right, it doesn't, on its own :)
16:29:03 <Cale> arkeet: But yeah, we'd add a class for that too.
16:29:23 <ReinH> carter: reading http://www.cs.indiana.edu/~eholk/papers/hips2013.pdf and wondering
16:29:38 <Cale> Sometimes you don't want the ability to arbitrarily duplicate things!
16:29:44 <carter> wondering about what?
16:29:51 <ReinH> carter: about doing that with Haskell
16:29:54 <carter> well
16:30:17 <carter> http://llvm.org/docs/NVPTXUsage.html :)
16:31:13 <carter> ReinH: first try targeting NV PTX using Accelerate
16:31:16 <Cale> Rather than (&&&), you could throw in a class ArrowDiagonal a where dup :: a t (t,t)
16:31:17 <carter> THEN wonder about haskell
16:31:23 <ReinH> carter: fair
16:31:30 <carter> ReinH: the way you write code for GPU is very very very different from CPU
16:31:39 <arkeet> Cale: yeah
16:32:27 <mm_freak> carter: accelerate code looks a lot like repa code
16:32:33 <mm_freak> so it depends on the paradigm =)
16:32:35 <carter> thats because they are
16:32:39 <carter> repa isn't a general array lib
16:32:42 <carter> nor is accelerate
16:32:46 <carter> they don't allow nested operations
16:32:48 <carter> only flat ones
16:33:06 <mm_freak> repa does, but it's a bad idea
16:33:16 <carter> 'cause of how it works
16:33:16 <carter> yeah
16:33:27 <carter> it doesn't have the right sort of concurrency tooling
16:33:31 <carter> for nested parallelism
16:33:36 <mm_freak> anyway, that's not the point
16:33:36 <carter> i' have some plans for that for my stuff
16:33:41 <carter> what is? :P
16:34:08 <mm_freak> the point is that depending on the paradigm CPU and GPU code can look pretty much the same except for different imports
16:34:28 <Kron> hmmm
16:34:34 <carter> yes
16:34:37 <mm_freak> so i disagree with the "very very very different" part of your statement =)
16:34:40 <carter> yes
16:34:40 <carter> well
16:35:03 <carter> of course you can run flat array code on both :)
16:35:13 <zRecursive> :t flip (>>=)
16:35:14 <lambdabot> Monad m => (a -> m b) -> m a -> m b
16:35:16 <carter> i like to think we agree, we're just quibbling on the details
16:35:22 <ReinH> :t (=<<)
16:35:23 <lambdabot> Monad m => (a -> m b) -> m a -> m b
16:35:40 <ReinH> carter: I think you disagree on how many "very"s are appropriate
16:35:45 <mm_freak> carter: do you agree that nested data parallelism can, in principle, look about the same on both?
16:35:57 <carter> yes,
16:35:58 <Kron> I just wrote the first version of my quadtree implementation
16:36:08 <carter> though it needs some care to make sense for gpu perf wise
16:36:11 <carter> i think
16:36:14 <volty> o # f = f o;   mod 1#succ 3 -- it there a way to define o#f  so that '1#succ' gets 'applied' before 'succ 3'?
16:36:15 <Kron> anyone up for just flipping through it and telling me if I'm making any large stylistic problems?
16:36:17 <carter> depending on the target gpu
16:36:19 <mm_freak> carter: then we disagree on the "very very very" part and you have to justify it =)
16:36:21 <Kron> http://lpaste.net/5429899733814476800
16:36:23 <carter> which?
16:36:24 <carter> well
16:36:38 <carter> point me to a nested parallism lib for gpu please :)
16:36:41 <carter> i want to see one
16:36:43 <carter> i'd love to see one
16:36:58 <carter> i want to be wrong so i can build more magical tools
16:36:59 <scott_> volty: No, function application is higher precedence than all operators
16:37:01 <mm_freak> carter: it's difficult, because type definitions are CPU-only in haskell =)
16:37:10 <mm_freak> carter: what you really want is a haskell compiler for GPUs =)
16:37:20 <carter> any good POC work in that space?
16:37:29 <mm_freak> none i'm aware of
16:37:37 <mm_freak> i'd love to see that, too
16:37:41 <carter> ok
16:37:43 <carter> well
16:37:45 <mm_freak> and i think it's very possible, but a lot of work to do
16:37:52 <volty> thx scott_
16:37:58 <carter> if i'm running a multi million dollar data analysis company, i'd love to build it :)
16:38:03 <carter> not there yet
16:38:36 <carter> mm_freak: i like to think some of what i'm doing now (and aim to release soon) could be retarged to do that for gpu
16:38:38 <carter> butidk
16:38:57 <carter> g2g
16:39:07 <mm_freak> carter: i was about to ask =)
16:39:44 <mm_freak> but i'm glad you're leaving…  allows me to get stuff done instead of chatting =P
16:49:34 <nonconvergent> hi
16:53:23 <Fyl> what would be a simple way to implement a 'type function' that is equal to X if the argument is A and equal to Y
16:53:41 <Fyl> ... equal to Y otherwise
16:54:15 <Iceland_jack> You can use type families with defaulting
16:54:16 <Iceland_jack>  
16:54:29 <Fyl> hrmm
16:54:59 <shachaf> You can use the new overlapping type family instances thing.
16:55:15 <shachaf> But it's quite possible that it's just not something you should be doing in the first place.
16:55:23 <Iceland_jack> That's more likely
17:12:34 <h0071> I'm trying to use a heterogeneous list using existential types
17:12:36 <h0071> http://www.haskell.org/haskellwiki/Heterogenous_collections#Existential_types
17:12:49 <shachaf> My advice is to not do that.
17:13:23 <h0071> i am trying to write an unpack function, similar to the pack function, but it doesn't work
17:13:53 <h0071> getting the error: cannot deduce a~a1
17:14:07 <h0071> any idea why?
17:14:16 <shachaf> It is impossible.
17:14:22 <Fyl> when it comes to parsing with Parsec is there any reason to choose between state vs monad?
17:14:32 <hpc> i am going to guess that your code is trying to deduce a~a1
17:14:46 <h0071> hpc: what does that mean?
17:14:50 <Iceland_jack> h0071: ~ is equality on the type level
17:14:57 <Fyl> i feel as if monad accomplishes the same thing as state and more
17:14:59 <hpc> h0071: it means paste a more complete error message with code ;)
17:15:01 <shachaf> That two different types (both called "a") are equal.
17:15:31 <Hodapp> http://www.haskell.org/haskellwiki/Library/PNG . . . hrmph, anybody tested this in awhile? I was using the top 'png' function and it appears to be generating corrupt PNGs
17:15:41 <shachaf> That article isn't that great because it answers the question you ask rather than the question you should be asking.
17:16:54 <copumpkin> shachaf: any more details?
17:18:05 <Hodapp> and it's kind of hard to figure out why it's corrupt, since the programs loading it don't say what the deal is...
17:18:14 <shachaf> copumpkin: That would be nice and constructive of me.
17:18:21 <copumpkin> :)
17:18:24 <monochrom> existential type does not bring you heterogeneous list. quite on the contrary, it asks you to lose information so that you can make a homogeneous list after all. it brings you more homogeneous list, not less.
17:18:52 <h0071> hpc: http://lpaste.net/96921
17:20:22 <shachaf> h0071: The type of unpack means: I can pick any type "a" I like, as long as it's an instance of Show. And unpack will turn an Any into something of that type.
17:20:41 <shachaf> For example, I can pick Bool, and then unpack :: Any -> Bool
17:20:44 <h0071> monochrom: any other way to achieve this ?
17:21:12 <monochrom> there is an Oleg paper on heterogeneous list. I haven't finished reading it.
17:21:26 <arkeet> h0071: what are you trying to use heterogeneous lists for?
17:21:29 <shachaf> That's hard to say because you haven't said what you want to achieve.
17:21:40 <shachaf> But I suspect heterogeneous lists are not the answer.
17:21:44 <shachaf> @where faq might have an answer to your question, though.
17:21:45 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
17:21:57 <h0071> to store a list of annotations which can be of any type
17:22:04 <Iceland_jack> Wanting to use heterogeneous lists is generally (but not always) a sign that you're doing something wrong
17:22:10 <shachaf> What is an annotation?
17:22:18 <shachaf> What can you do with an annotation?
17:22:22 <monochrom> look for "strongly typed heterogeneous collections" by Kiselyov (that's Oleg), Lämmel, Schupke
17:22:32 <dwcook> You can't do anything with a bunch of values of any type, since you don't know what they have in common.
17:22:33 <h0071> an annotation is any piece of information that i can attach to something
17:22:37 <Iceland_jack> h0071: If you want to contain something of type “A or B” you can easily have a list of [Either A B]
17:22:47 <Iceland_jack> If you want to have a dynamic type you can use Data.Dynamic
17:22:55 <shachaf> h0071: OK, let's say you could do that. I give you an annotation, but you don't know what type it is.
17:23:02 <shachaf> What do you do with it?
17:24:06 <monochrom> I agree that "it is any piece of information" is greatly exaggerated
17:24:57 <monochrom> it cannot possibly be my mother's maiden name, or my secret password, for example. there goes a little bit of generality.
17:25:21 <h0071> so does that mean i need to restrict the type of information i can annotation e.g. adding constraints
17:25:30 <hpc> monochrom: ...but is it the name of your pet or your high school?
17:25:31 <monochrom> there are always constraints.
17:26:38 <shachaf> The name of my first pet is a randomly generated sequence of 256 bits.
17:26:50 <arkeet> what encoding?
17:27:05 <BMeph> h0071: Imagine you are in a world built by bondage fetishists - where constraints and restraints are not always and ever bad things to be avoided and circumvented.
17:27:44 <arkeet> h0071: constrained existential things are no better than plain old data types that contain the operations supported by the constraint
17:27:53 <arkeet> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
17:27:59 <arkeet> by no better I mean worse
17:28:08 <shachaf> arkeet: In some ways they can be better.
17:28:53 <BMeph> h0071: That is, don't try to suppress restraints you don't want. Think of constraints (boundaries, characteristics, common factors) that you do want.
17:30:59 <h0071> well, thanks i think i get the idea
17:31:23 <monochrom> anyway, I already named the heterogenous list paper. it's a free country.
17:36:27 * hackagebot swish 0.9.0.10 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.10 (DouglasBurke)
17:40:21 <haasn> has there ever been a case for an extension that allows something like “case ... of pat1, pat2 -> expr; ...” with semantics being “case ... of pat1 -> expr; pat2 -> expr; ...”
17:41:00 <haasn> eg. “case num of 7, 11, 12 -> f num; _ -> somethingElse”
17:41:19 <monochrom> it has always been much wished for, but nothing happened yet
17:41:31 <haasn> tail = \case (_:xs), xs -> xs
17:41:50 <twiceler> haasn: When I have to do something, I usually just code my own
17:42:22 <twiceler> "try" :: [(Bool, a)] -> a
17:42:24 <haasn> I'm not sure whether it should be required that ‘xs’ here has to be of the same type as well, but it would make sense
17:42:25 <monochrom> the last example does pose an issue about name clashes
17:44:48 <monochrom> I guess it is to be resolved just like field names, i.e., allowed iff same type.
17:45:08 <monochrom> after all, names in patterns are selectors, just like field names are.
17:46:28 * hackagebot swish 0.9.0.11 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.11 (DouglasBurke)
17:53:33 <mpjones> Does anyone know anything about the haskellwiki and the code <haskell> reponsible for handling the <haskell> tag? I feel it it producing less than ideal results. Curious to look into it.
17:53:48 <mpjones> oops, ignore that first <haskell>
17:53:51 <haasn> monochrom: a literal desugaring as suggested would have no qualms about name clashes; in fact it would actually allow unbound names to refer to outside bindings too - but I don't think that would be expected or sane behavior, so it makes sense to force the used bound variables to agree
17:54:47 <maik__> what do you think of vinyl? http://www.jonmsterling.com/posts/2013-04-06-vinyl-modern-records-for-haskell.html
17:55:26 <haasn> maik__: the new version of GHC includes an extension that supersedes vinyl's functionality, I think
17:56:40 <haasn> record field accessors are now polymorphic in the record they accept, with a new form of constraint that looks like x { field :: Type } => ...
17:57:00 <haasn> (or something similar, I don't remember the specifics)
17:57:01 <Fuuzetsu> How can I represent something a unicode character like U+0085 in a Haskell string? "\0085" doesn't seem to produce what I expect… I'm asking this in terms of using such character in Alex.
17:57:34 <maik__> haasn, okay thanks, I'll have a look
17:57:47 <haasn> Fuuzetsu: \0085 does indeed refer to the unicode codepoint U+0085, as does \85
17:57:51 <xplat> > [0x85] :: String
17:57:52 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
17:57:53 <lambdabot>    arising from the literal `133'
17:57:53 <lambdabot>  Possible fix:
17:57:53 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Types.Char)
17:57:53 <haasn> oh, unless you meant hex
17:58:05 <Iceland_jack> > "\0085" -- ?
17:58:06 <lambdabot>  "U"
17:58:06 <haasn> yes, I think U+XXXX notation should be hex
17:58:06 <xplat> > show ([0x85] :: String)
17:58:07 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
17:58:08 <lambdabot>    arising from the literal `133'
17:58:08 <lambdabot>  Possible fix:
17:58:08 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Types.Char)
17:58:15 <haasn> > "\0x85"
17:58:16 <lambdabot>  "\NULx85"
17:58:18 <Fuuzetsu> "\20"
17:58:21 <Fuuzetsu> > "\20"
17:58:21 <haasn> > "\x85"
17:58:22 <lambdabot>  "\DC4"
17:58:22 <lambdabot>  "\133"
17:58:26 <haasn> > text "\x85"
17:58:37 <xplat> > "\x20"
17:58:38 <lambdabot>  " "
17:58:43 <Fuuzetsu> I'm just looking to encode stuff like http://www.fileformat.info/info/unicode/category/Zs/list.htm in Alex…
17:58:46 <haasn> oh, it's whitespace
17:58:48 <xplat> "\x61"
17:58:50 <shachaf> \ followed by any number of decimal digits is a codepoint specified in decimal.
17:58:50 <Fuuzetsu> yeah
17:58:58 <xplat> > "\x61"
17:58:59 <lambdabot>  "a"
17:59:02 <haasn> Fuuzetsu: yes, then you want eg. \x205F for MEDIUM MATHEMATICAL SPACE
17:59:09 <Fuuzetsu> > "\x2007"
17:59:10 <lambdabot>  "\8199"
17:59:16 <haasn> > text "\x2007"
17:59:17 <lambdabot>   
17:59:20 <shachaf> Or just write the code point into your source code directly.
17:59:41 <shachaf> > "∀"
17:59:42 <lambdabot>  "\8704"
17:59:51 <haasn> > text "\x2603"
17:59:52 <lambdabot>  ☃
18:00:35 <Iceland_jack> haasn: Thanks! I'm in a Christmas mood now
18:00:41 <Fuuzetsu> shachaf: It's for a lexer, I don't think it'll be readable at all if I end up with a bunch of ‘   |   |   |   |   |   |   |   ’ which just looks like there's nothing between the options
18:00:59 <xplat> > text "in the meadow we can build a \x2603"
18:01:01 <lambdabot>  in the meadow we can build a ☃
18:01:07 <arkeet> ☃
18:01:10 <Fuuzetsu> haasn: I feel bad that my font even has that character.
18:01:37 <Fuuzetsu> At least Agda input method doesn't have it defined as anything.
18:01:40 <shachaf> \& is the best special character.
18:01:56 <haasn> > length "\&"
18:01:57 <lambdabot>  0
18:02:33 <xplat> \& isn't a special character
18:03:29 <haasn> xmodmap -e 'keycode 60 = U2603'
18:03:36 * Hodapp pokes around at the Collatz conjecture some more...
18:03:45 <xplat> > map const 0 "\&" :: [Int]
18:03:46 <lambdabot>  Couldn't match expected type `[GHC.Types.Char] -> [GHC.Types.Int]'
18:03:47 <lambdabot>              with actual type `[b0 -> a0]'
18:03:58 <xplat> > map (const 0) "\&" :: [Int]
18:03:59 <lambdabot>  []
18:04:10 <xplat> it's not a character at all
18:06:00 <shachaf> xplat: That's what makes it special!
18:06:57 <haasn> or “not a character”.
18:07:06 <haasn> oh, wait, that's what xplat already said :(
18:08:16 <haasn> hmm. The report names \& a “null character”
18:08:41 <pavonia> > length "\ \\ \"
18:08:42 <lambdabot>  0
18:08:48 <shachaf> The report also calls getLine a function.
18:11:10 <haasn> \& sort of looks like \☃ in my font
18:11:17 <hamster007> hey guys I have a monad transformer stack. it starts with Identity, and I use runIdentity. Now I want to replace Identity with IO. Can anyone tell me what I should use instead of runIdentity
18:11:47 <haasn> hamster007: there's no function :: IO a -> a
18:11:56 <haasn> (which would be an equivalent to runIdentity :: Identity a -> a)
18:12:07 <dwcook> \& looks like a demon standing next to a throne to me
18:12:20 <haasn> hamster007: the only way to ‘run’ an IO action is to include it in ‘main’, somehow
18:13:45 <Fuuzetsu> Hodapp: What are you doing with it? Can we expect the proof by tomorrow?
18:14:12 <twiceler> :t System.IO.Unsafe.unsafePerformIO
18:14:13 <lambdabot> IO a -> a
18:14:21 <twiceler> (just kidding)
18:14:30 <twiceler> almost definitely not what you want to do
18:14:30 <shachaf> twiceler: That is not helpful.
18:15:28 <twiceler> shachaf: I've been using unsafePerformIO lately. Somtimes it is the right thing to do
18:15:37 <Fuuzetsu> ohboyherewego
18:15:37 <haasn> would it be fair to call unsafePerformIO a performance hack?
18:15:49 <Hodapp> Fuuzetsu: I'm just visualizing what it looks like as bits.
18:15:49 <shachaf> Yes. But it is not the right thing to say in this situation.
18:16:09 <haasn> or are there legitimate use cases that aren't simply for performance (or minor code convenience, but let's assume that doesn't count as a necessity)
18:16:38 <twiceler> As I said, almost definitely not what hamster007 wants to do
18:17:11 <twiceler> haasn: I've been doing FFI calls to C functions. It definitely is useful there
18:17:30 <Fuuzetsu> I think my cabal settings are messed up. I always get two compilation runs, one that spits out .o and another that spits out .dyn_o… This is very inconvenient for development. What did I screw up?
18:17:41 <haasn> oh, of course. The FFI extension has it built in
18:17:43 <Hodapp> Fuuzetsu: http://hodapple.com/files/collatz.png
18:17:45 <Fuuzetsu> If I do --disable-shared it complains about no dyn libraries
18:17:47 <twiceler> haasn: Like sometimes you need to set up a global variable that must be initialized and destroyed
18:18:01 <ADexter> hey, I am trying to build some kind of error level analysis for jpegs with the JuicyPixels package. It kinda works but its very slow. Could somebody look over it and give me a heads up what I am doing horribly wrong? Here's the code: http://lpaste.net/96924
18:18:26 <Fuuzetsu> Hodapp: Cool, how are you generating the visualisation?
18:18:44 <Hodapp> Fuuzetsu: I'm just iterating and converting to bits, really.
18:18:49 <Hodapp> Fuuzetsu: It's something to help me learn some Haskell.
18:19:17 <Hodapp> Fuuzetsu: Each line of that image is an iteration in the Collatz sequence, with the leftmost pixel being least-significant bit.
18:19:54 <twiceler> haasn: Well, sometimes things are unsafe in general. But then you can wrap the unsafe functions, make sure you never to anything leaky, and use unsafePerformIO and pretend everything was really okay (like runST)
18:22:46 <numberten> anyone know if there's a way to turn Strings into Data.Text.Internal.Text? no go with read
18:23:07 <numberten> for use with Network.Mail.SMTP
18:23:17 <haasn> numberten: text provides a function called ‘pack’
18:23:17 <shachaf> Data.Text.Internal.Text is the same type as Data.Text.Text
18:23:29 <haasn> :t T.pack
18:23:30 <lambdabot> Couldn't find qualified module.
18:23:31 <solrize> hackage  ?  :(
18:23:31 <shachaf> You can use that function to convert.
18:23:39 <numberten> tried pack, maybe I was using the wrong one
18:23:46 <haasn> numberten: maybe you were mixing lazy and strict
18:23:50 <numberten> possibly
18:24:36 <numberten> i'll take a look, thanks
18:32:21 <trinketsoup> testing, please respond if you can see this
18:32:47 <trinketsoup> uh oh
18:32:57 <trinketsoup> hello, world?
18:33:08 <arkeet> hello trinketsoup
18:33:14 <trinketsoup> phew, arkeet thanks
18:39:57 <dwcook> trinketsoup, I didn't see it, perhaps you should make another attempt?
18:52:33 <trinketsoup> test dwsoup test
18:53:39 <dwcook> trinketsoup, (I was joking)
18:54:18 <trinketsoup> dwcook: *facepalm* (i even spelt your username wrong because i wasn't using tab completion)
18:54:41 <dwcook> Haha
19:15:24 <copumpkin> does attoparsec not support actual lazy parsing?
19:15:39 <copumpkin> Data.Attoparsec.Lazy got my hopes up but it looks like it just accepts a lazy bytestring
19:16:46 <twiceler> copumpkin: I think that, in general, you can't decide where you will be able to parse successfully until you've read the entire input
19:17:03 <copumpkin> sure
19:17:14 <copumpkin> but there's a fairly common use case of wanting to parse the same thing over and over again
19:17:38 <twiceler> copumpkin: What I've done in that case is split over the "same thing" and then parse each part separately
19:18:03 <copumpkin> how do I split without parsing?
19:18:33 <twiceler> twiceler: well, it depends. If it's simple, you can do something simple (e.g. "lines")
19:18:46 <erisco> test
19:19:21 <copumpkin> it isn't simple
19:19:22 <jmcarthur> copumpkin: doesn't it give you the unconsumed portion of the last chunk when it gives you the result? couldn't you just start over with that, if you're just parsing the same thing over and over?
19:19:35 <copumpkin> yeah, I can do it by hand :)
19:20:12 <twiceler> copumpkin: Yeah, I just remembered that attoparsec has some sort of capability to have a partial result
19:21:30 <twiceler> but I don't really know how it works or anything
19:25:10 <twiceler> copumpkin: Okay, I think I see how you can do it
19:25:54 <copumpkin> I think I do too :)
19:25:55 <twiceler> the Result type of Attoparsec gives you (hopefully) (Done Bytestring a) :: Result a
19:25:57 <copumpkin> it's just more painful
19:25:58 <copumpkin> yeah
19:26:17 <twiceler> so just end the parser where you want to split, and then feed the remaining bytestring back in
19:26:24 <copumpkin> yup
19:27:30 <copumpkin> works :)
19:27:37 <twiceler> nice!
19:28:18 <copumpkin> thanks for helping :)
19:28:50 <twiceler> no problem
19:41:08 <copumpkin> oh err
19:41:11 <copumpkin> I'm stupid
19:48:56 <[swift]> anyone have any idea how much performance i'll lose by using aeson over, say, cereal? i'm loathe to write all those ToJSON/FromJSON instances just to test
19:49:04 <pyon> Is there any way to tell cabal-install to use a specific version of a dependency?
19:49:45 <peddie> pyon: you can specify the dependency package by version along with the package you want to install, e.g. cabal install foo bar-2.2.2  # foo depends on bar
19:49:48 <Iceland_jack> [swift]: You know they can be derived automatically?
19:50:20 <pyon> peddie: Ah, thanks, that worked! :-)
19:50:27 <[swift]> Iceland_jack: yeah, but the docs say the generic instances are slower, which means it'd be an unfair test =\
19:52:11 <Iceland_jack> Have you profiled the difference?
19:53:51 <[swift]> Iceland_jack: no. i will do the work to do a proper test if needed, but if others knew that e.g. aeson is an order of magnitude slower than cereal, it'd be a waste of time for me to reproduce those results
19:54:34 <[swift]> online i can only seem to find aeson tested against other json serialization libraries and cereal/binary/etc tested against other binary serialization libraries
20:06:55 <kayloos> There seems to be quite a few regex libraries, anybody have a suggestion for which one to use?
20:09:01 <mrdiceguy> Hello, anyone know the proper chatroom for ML programming?
20:09:07 <mrdiceguy> if there is even one?
20:09:24 <peddie> kayloos: I like the regex-tdfa* libraries
20:09:57 <solrize> mrdiceguy, #ocaml and #sml maybe
20:10:13 <mrdiceguy> solrize, thanks
20:11:02 <djahandarie> kayloos, I found regex-tdfa to be somewhat difficult to use, but regex-compat-tdfa to be a quite familiar interface with much better inners.
20:11:44 <djahandarie> If regex-tdfa had support for substitution built directly in somehow then I'd almost certainly be happy with it directly.
20:12:20 <L8D> How to I create an array of 0s of n length?
20:12:39 <copumpkin> is a list okay? then you can use replicate
20:12:43 <copumpkin> > replicate 0 10
20:12:44 <lambdabot>  []
20:12:46 <copumpkin> err
20:12:48 <kayloos> djahandarie: Ah ok.. I will only be using it for validating strings
20:12:49 <copumpkin> > replicate 10 0
20:12:50 <lambdabot>  [0,0,0,0,0,0,0,0,0,0]
20:13:04 <L8D> copumpkin: thanks
20:13:27 <djahandarie> copumpkin, too bad that isn't a type error :)
20:14:00 <dwcook> > listArray (1, 10) $ replicate 10 0
20:14:01 <lambdabot>  array (1,10) [(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(7,0),(8,0),(9,0),(10,0)]
20:14:04 <dwcook> \o/
20:14:13 <dwcook> That's taking your request more literally
20:14:23 <roconnor> dwcook: you didn't start your index at 0
20:14:31 <jmcarthur> Vector.replicate 10 0
20:14:34 <dwcook> roconnor, what's wrong with that?
20:14:36 <copumpkin> djahandarie :(
20:14:57 <jmcarthur> > V.replicate 10 0
20:14:58 <roconnor> dwcook: http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html
20:14:58 <lambdabot>  Not in scope: `V.replicate'
20:14:58 <lambdabot>  Perhaps you meant one of these:
20:14:58 <lambdabot>    `P.replicate' (imported from Prelude),
20:14:59 <lambdabot>    `BS.replicate' (imported from Data.ByteString),
20:14:59 <lambdabot>    `BSC.replicate' (imported from Data.ByteString.Char8)
20:15:01 <jmcarthur> sadness
20:15:02 <L8D> What’s the difference between Int and Integer?
20:15:12 <L8D> Is Int the class and Integer an instance of it?
20:15:14 <jmcarthur> L8D: Integer can be arbitrarily large
20:15:26 <jmcarthur> L8D: Int can have a limited number of bits available to it
20:15:32 <jmcarthur> L8D: in ghc, Int is machine int
20:15:39 <L8D> got it
20:15:58 <L8D> Is Integer like... long long
20:16:02 <jmcarthur> no
20:16:06 <jmcarthur> Integer can be much larger
20:16:07 <slack1256> how can load in ghci not exported functions from a module?
20:16:08 <dwcook> Integer is like BigInteger
20:16:09 <rdevilla> L8D: if you had infinite long longs yes
20:16:14 <slack1256> without changing the exported functions
20:16:19 <jmcarthur> > 2^2^2^2
20:16:20 <lambdabot>  65536
20:16:23 <jmcarthur> > 2^2^2^2^2^2^2^2
20:16:28 <lambdabot>  mueval: Prelude.undefined
20:16:31 <jmcarthur> ah poo
20:16:34 <roconnor> jmcarthur: why would you do that?
20:16:35 <jmcarthur> > 2^2^2^2^2^2^2
20:16:40 <lambdabot>  mueval: ExitFailure 1
20:16:40 <lambdabot>  mueval: Prelude.undefined
20:16:41 <L8D> > 1000^1000
20:16:42 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
20:16:50 <jmcarthur> roconnor: for teh sad
20:16:54 <L8D> > 2^2^2^2^2^2^2
20:16:59 <lambdabot>  mueval: ExitFailure 1
20:16:59 <lambdabot>  mueval: Prelude.undefined
20:17:05 <jmcarthur> i went too big too fast
20:17:07 <L8D> > 2^2^2^2^2^2^2 :: Integer
20:17:09 <roconnor> 2^2^2^2^2 isn't going to work
20:17:12 <lambdabot>  mueval: ExitFailure 1
20:17:12 <lambdabot>  mueval: Prelude.undefined
20:17:13 <L8D> -.-
20:17:27 <slack1256> nevermind
20:17:41 <jmcarthur> even just 2^2^2^2^2 is probably too big for lambdabot, but is okay for ghci at least
20:17:42 <L8D> Is there a funciton in the standard libraries for array slicing?
20:17:42 <roconnor> well ... it is borderline
20:17:48 <jmcarthur> L8D: try 2^2^2^2^2 in ghci
20:17:49 <roconnor> yeah, in ghci
20:18:21 <L8D> > 65535^2
20:18:23 <lambdabot>  4294836225
20:18:28 <jmcarthur> L8D: do you mean arrays or do you mean lists?
20:18:29 <L8D> wait....
20:18:32 <dwcook> L8D, do you know specifically that you want arrays, or are you just looking for a sequence type?
20:18:40 <L8D> sequence type
20:18:53 <dwcook> L8D, what sort of slicing? Check out Data.List
20:18:59 <L8D> Basically, (Ord a) => [a]
20:19:15 <jmcarthur> [] :: Ord a => [a]
20:19:32 <jmcarthur> not much else has that type that actually terminates
20:19:51 <L8D> I want to do: slice 5 10 [1..] --> [5, 6, 7, 8, 9, 10]
20:19:56 <dwcook> Hmm yeah, Ords can't be mixed very easily
20:20:14 <dwcook> L8D, you can use [5..10] or enumFromTo, for example
20:20:15 <rdevilla> > drop 4 [1..10]
20:20:16 <roconnor> > drop 5 . take 10 $ [1..]
20:20:16 <lambdabot>  [5,6,7,8,9,10]
20:20:17 <lambdabot>  [6,7,8,9,10]
20:20:19 <dwcook> @type enumFromTo
20:20:20 <lambdabot> Enum a => a -> a -> [a]
20:20:21 <jmcarthur> > take 5 (drop 5 [1..])
20:20:22 <lambdabot>  [6,7,8,9,10]
20:20:25 <dwcook> > enumFromTo 5 10
20:20:27 <lambdabot>  [5,6,7,8,9,10]
20:20:44 <L8D> okay, sweet
20:20:45 <rdevilla> ask a question, get 4 solutions
20:20:46 <L8D> thanks
20:20:47 <rdevilla> HASKELL
20:21:03 <roconnor> > [5..10]
20:21:04 <lambdabot>  [5,6,7,8,9,10]
20:21:17 <dwcook> [a..b] is the same as enumFromTo a b.
20:21:17 <jmcarthur> rdevilla: i pronounced your "HASKELL" like http://img.gawkerassets.com/img/196zdr324f5ksgif/original.gif
20:21:27 <dwcook> Except that it's syntax rather than a function.
20:21:30 <rdevilla> jmcarthur: hahahah
20:22:05 <jmcarthur> dwcook: (buuuuuuut it's actually the same function)
20:22:21 <dwcook> jmcarthur, I'm not sure how that differs from what I said.
20:22:38 <jmcarthur> dwcook: "rather than a function"
20:22:40 <L8D> Is .. a special operator?
20:22:43 <jmcarthur> it's actually a function
20:22:50 <jmcarthur> the same one, in fact
20:22:53 <L8D> Then how does it work?
20:23:02 <L8D> @src (..)
20:23:02 <lambdabot> Source not found. My mind is going. I can feel it.
20:23:03 <Cale> L8D: [a..b] desugars into enumFromTo a b
20:23:04 <dwcook> jmcarthur, I just mean that you can, e.g., pass enumFromTo around, but you can't do the same if you use that syntax.
20:23:08 <jmcarthur> L8D: [a..b] "desugars" to enumFromTo a b
20:23:23 <Cale> The .. on its own isn't anything
20:23:37 <Cale> (The square brackets are part of that syntax)
20:23:52 <L8D> So I could define (..) as an operator and mess stuff up?
20:23:58 <dwcook> No.
20:24:03 <L8D> :(
20:24:18 <dwcook> You can define it as your own operator, but it won't mess up that syntax.
20:24:22 <L8D> Haskell is so sweet and sour
20:24:27 <Cale> It's not available as an operator name
20:24:30 <jmcarthur> > let a .. b = fail in (1 .. 5) "this won't work"
20:24:31 <lambdabot>  <hint>:1:7: parse error on input `..'
20:24:33 <dwcook> > let a .. b = a . b in (+1) .. (+2) $ 0
20:24:35 <lambdabot>  <hint>:1:7: parse error on input `..'
20:24:41 <dwcook> Er, or maybe not?
20:24:53 <jmcarthur> it's reserved
20:25:09 <dwcook> I guess that makes sense
20:25:17 <jmcarthur> hence (.:) instead of (..)
20:25:17 <L8D> What are all the reserved operators and keywords?
20:25:19 <dwcook> I figured they would've done something similar to what they did with the overloading of .
20:25:26 <Cale> The list of reserved operator symbols are  ..  :  ::  =  \  |  <-  ->  @  ~  and =>
20:25:36 <Cale> You can't name infix operators any of those things
20:25:49 <L8D> And why can’t if be a function?
20:26:04 <Cale> It can, but the 'then' and 'else' wouldn't work like that
20:26:22 <jmcarthur> well, there's a syntax extension that allows you to redefine that syntax now, i think
20:26:23 <L8D> Why can’t then and else be error-throwing singletons?
20:26:28 <Cale> You can define a function  if' b t e = case b of True -> t; False -> e
20:26:39 <jmcarthur> RebindableSyntax
20:26:41 <Cale> error throwing?
20:26:51 <dwcook> L8D, you might be interested in Agda. *runs and hides*
20:27:24 <Cale> In Agda, they have mixfix, so you can define a function if_then_else_ which takes parameters in the positions marked by underscores.
20:27:27 <jmcarthur> L8D: ignore dwcook. he's just telling you about the secret languages that you shouldn't know about yet.
20:27:31 <jmcarthur> :)
20:27:32 <L8D> Is that supposed to be a joke?
20:27:32 <Cale> lol
20:27:49 <joejev> quick question about the prelude, why does drop 1 [] work, but tail [] error, why is tail [] not defined as []?
20:27:58 <dwcook> L8D, I was making reference to what Cale just explained. But Agda might break your brain if you don't understand Haskell yet.
20:28:14 <L8D> Well, I know lamdba calculus pretty well
20:28:17 <Cale> joejev: I guess because [] doesn't have a tail.
20:28:44 <joejev> Cale: but dropping 1 element from [] doesn't make sense either really? then you would have -1 element
20:28:54 <L8D> I need to find a good book on how ghc works
20:29:06 <Cale> joejev: That's true :)
20:29:10 <dwcook> Why GHC in particular? Not Haskell?
20:29:11 <L8D> > drop 1 []
20:29:12 <lambdabot>  []
20:29:20 <joejev> Cale: I guess what I am asking is why they use error, when it is considered bad
20:29:21 <L8D> > tail []
20:29:22 <lambdabot>  *Exception: Prelude.tail: empty list
20:29:34 <dwcook> joejev, because some things in the Prelude are misdesigned.
20:29:41 <dwcook> … That wasn't a helpful answer actually.
20:29:42 <jmcarthur> L8D: here's a ridiculously old book that will nonetheless help you a bit on that quest to understand ghc. http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
20:29:43 <Cale> joejev: I don't know. I could probably live without head and tail being in the Prelude, though occasionally they're handy.
20:29:57 <Cale> map head . group . sort  for instance
20:30:11 <jmcarthur> L8D: also, http://research.microsoft.com/apps/pubs/default.aspx?id=67083
20:30:17 <joejev> Cale: really, I think they are prety much bread and butter
20:30:25 <dwcook> I wouldn't use head unless I were absolutely sure my list were non-empty, and I probably wouldn't use it even then.
20:30:35 <bmuk> L8D: www.aosabook.org/en/ghc.html
20:30:41 <Cale> joejev: You almost always would rather pattern match
20:31:11 <bmuk> that article has been helping me wrap my head around it on a high level
20:31:15 <joejev> Cale: ahh, I guess that is true, I do find that if I am calling head or tail, I already know for certain it exists
20:32:15 <dwcook> Still wish Data.List or something had list :: b -> (a -> [a] -> b) -> [a] -> b
20:32:53 <joejev> dwcook: what would the name of that function be?
20:32:59 <Cale> joejev: list
20:32:59 <dwcook> I just said.
20:32:59 <jmcarthur> wait, what's the first argument for?
20:33:04 <dwcook> jmcarthur, []
20:33:10 <jmcarthur> oh, duh
20:33:25 <joejev> dwcook: oh, I am dumb
20:33:26 <jmcarthur> ah, it's just the scott encoding
20:33:30 <Cale> list nil cons xs = case xs of [] -> nil; (x:xs) -> cons x xs
20:33:41 <dwcook> joejev, we all have our dumb moments :)
20:33:54 <joejev> dwcook: lol, I have a couple too many
20:34:25 <dwcook> This is analogous to the actually existing maybe, by the way
20:34:27 <dwcook> @type maybe
20:34:28 <lambdabot> b -> (a -> b) -> Maybe a -> b
20:34:50 <Cale> While I agree that we should have that in the library, I actually don't care much for clever use of the 'maybe' function, and would usually rather see the case expression.
20:34:56 <jmcarthur> dwcook: it's unclear whether your list function is more like maybe or foldr is
20:35:04 <dwcook> @type foldr
20:35:05 <lambdabot> (a -> b -> b) -> b -> [a] -> b
20:35:22 <jmcarthur> i always think of maybe as a fold
20:35:27 <dwcook> jmcarthur, the only difference is what the second argument to the cons-replacing function is.
20:35:31 <jmcarthur> right
20:35:31 <Cale> jmcarthur: Well, obviously, they're both like maybe :)
20:35:34 <joejev> is there a practical difference in foldr and foldl?
20:35:36 <dwcook> Oh, I see what you mean.
20:35:40 <Cale> joejev: yes
20:35:55 <joejev> Cale: I realize foldr must be finite, but how do they differ?
20:36:03 <Cale> joejev: foldr can work on infinite lists, and can produce part of its result before the entire list has been constructed
20:36:18 <Cale> > foldr (\x xs -> x : x : xs) [] [1..]
20:36:19 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
20:36:30 <Cale> @src foldr
20:36:30 <lambdabot> foldr f z []     = z
20:36:30 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:36:45 <Cale> This is because in the nonempty list case, it immediately passes control to f
20:36:49 <Cale> @src foldl
20:36:49 <lambdabot> foldl f z []     = z
20:36:49 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:37:03 <Cale> while foldl greedily applies itself to new arguments until it reaches the end of the list
20:37:42 <joejev> hmm, let me try to write these out to get an idea
20:37:55 <Cale> This also means that foldl will build up a large expression in its second parameter (as large as the input list, except that it will definitely all be in memory by the time foldl hits the end, while the original list might've been lazily constructed)
20:38:33 <nstdloop> @src map
20:38:33 <lambdabot> map _ []     = []
20:38:33 <lambdabot> map f (x:xs) = f x : map f xs
20:38:52 <nstdloop> why isn't map defined using foldl?
20:39:02 <dwcook> Clarity, I imagine
20:39:05 <Cale> Because then it would have no hope of working on an infinite list
20:39:08 <joelteon> and it couldn't be lazy either
20:39:10 <dwcook> Oh, foldl
20:39:13 <dwcook> I misread
20:39:16 <Cale> and it would reverse the list
20:39:33 <nstdloop> foldl not foldr
20:39:46 <Cale> map with foldr would be fine
20:40:03 <nstdloop> you could do map f = fold ((:) . f) []
20:40:06 <nstdloop> right?
20:40:18 <nstdloop> foldl*
20:40:22 <Cale> no!
20:40:25 <Cale> foldr
20:40:31 <Cale> > let mymap f = foldr ((:) . f) [] in mymap (*2) [1..]
20:40:32 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
20:40:38 <Cale> > let mymap f = foldl ((:) . f) [] in mymap (*2) [1..]
20:40:39 <lambdabot>  Occurs check: cannot construct the infinite type: b0 = [b0]
20:40:39 <lambdabot>  Expected type: [b0] -> b0
20:40:39 <lambdabot>    Actual type: [b0] -> [b0]
20:40:46 <Cale> > let mymap f = foldl (flip ((:) . f)) [] in mymap (*2) [1..]
20:40:50 <lambdabot>  mueval-core: Time limit exceeded
20:40:52 <Cale> > let mymap f = foldl (flip ((:) . f)) [] in mymap (*2) [1..10]
20:40:53 <lambdabot>  [20,18,16,14,12,10,8,6,4,2]
20:41:03 <dwcook> Throw in a reverse and you're gold
20:41:04 <dwcook> also a mess
20:41:22 <Cale> "gold" if you never ever want it to work on an infinite list :)
20:41:29 <rdevilla> Why does this not work?
20:41:37 <rdevilla> > let foo [] [] = []
20:41:38 <lambdabot>  not an expression: `let foo [] [] = []'
20:41:38 <nstdloop> why is that? shouldn't foldl go through from the left and foldr go through from the right?
20:41:43 <rdevilla> er
20:41:48 <Cale> @src foldr
20:41:49 <rdevilla> @let foo [] [] = []
20:41:49 <lambdabot> foldr f z []     = z
20:41:49 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:41:49 <dwcook> Cale, meh, strictly evaluated languages get by without ;)
20:41:50 <lambdabot>  Defined.
20:42:01 <rdevilla> @let foo (x:xs) (y:ys) = x:y:(foo xs ys)
20:42:02 <lambdabot>  Defined.
20:42:05 <Cale> @src foldl
20:42:05 <lambdabot> foldl f z []     = z
20:42:05 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:42:05 <rdevilla> > foo [1] [2]
20:42:07 <joelteon> yeah, strictly evaluated languages have ways to work around it
20:42:08 <lambdabot>  [1,2]
20:42:11 <dwcook> And by "get by", I mean "invent things that can approximate lazy structures if they're smart"
20:42:11 <rdevilla> what
20:42:17 <rdevilla> that doesn't work in my ghci
20:42:17 <Cale> they both go through the list from left to right
20:42:18 <dwcook> For example, Python's generators
20:42:18 <nstdloop> @src foldl
20:42:18 <lambdabot> foldl f z []     = z
20:42:18 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:42:31 <CADD> rdevilla: may need to enable some extensions?
20:42:34 <nstdloop> ahhh ok
20:42:46 <rdevilla> CADD: I need to enable extensions to have pattern matches in ghci?
20:42:49 <rdevilla> ._.
20:42:55 <Cale> But foldl does nothing except to apply itself to new arguments until it reaches the end of the list
20:43:10 <Cale> While foldr immediately gives control to f after each step
20:43:16 <nstdloop> makes sense
20:43:25 <CADD> rdevilla: im really not sure. but from it working here and not on your ghci. thats what its seems to me. im completely open to being corrected
20:43:28 <Cale> and only if and when f uses its second argument will the foldr on the rest of the list continue
20:43:34 <dwcook> I thought the main selling point of foldl was tail recursiveness, and you lose that benefit with the non-strict version
20:43:42 <Cale> dwcook: That's true
20:44:22 <Cale> foldl (+) 0 [1,2,3] -> foldl (+) (0+1) [2,3] -> foldl (+) ((0+1)+2) [3] -> foldl (+) (((0+1)+2)+3) [] -> ((0+1)+2)+3
20:44:33 <Cale> Up to this point, the stack has not been used
20:45:11 <Cale> But now the (+) in (...)+3 will need to pattern match on its first argument
20:45:38 <Cale> and that pattern match will wait on the stack while (0+1)+2 is evaluated
20:45:48 <Cale> and then the same thing will happen with (...)+2
20:46:13 <Cale> and if your list is a million elements long, you might have a problem
20:46:36 <joelteon> > foldr (+) a [b,c,d,e,f]
20:46:37 <lambdabot>  b + (c + (d + (e + (f + a))))
20:47:07 <Cale> (foldr is no better to the stack here)
20:47:27 <Cale> So, in order to alleviate that, there's a stricter version of foldl, called foldl'
20:47:47 <Cale> @src foldl'
20:47:48 <lambdabot> foldl' f a []     = a
20:47:48 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:48:33 <nstdloop> the `seq` just forces the evaluation of a
20:48:36 <Cale> It forces the evaluation of the accumulating parameter to occur before the result of the recursive application of foldl' can be observed
20:48:44 <nstdloop> a'*
20:48:47 <Cale> yes
20:50:53 <Cale> (If you like, you can think of it as evaluating a' first and then the foldl' f a' xs afterward, but it's really up to the compiler. The important thing is that before you can pattern match on the result of the foldl', the a' must be evaluated -- the bunch of sequenced expressions keeps things in order just enough to make everything work without using too much stack.
20:50:56 <Cale> )
20:51:36 <Cale> Alternately, you can turn on strictness analysis using -O or -O2, and GHC will almost always be smart enough to get it right.
20:51:52 <Cale> (but still probably better safe than sorry)
20:55:55 <Cale> heh, actually, it might be semantically valid for the compiler to still choose the wrong order with seq
20:56:00 <AshyIsMe> hmm, :HPaste fails for me in a tmux session
20:56:07 <AshyIsMe> '+' invalid register
20:56:15 <Cale> (but it doesn't :)
20:56:24 <AshyIsMe> does the author of vim2hs hang out here?
21:02:31 <zRecursive> :t withSocketsDo
21:02:32 <lambdabot> Not in scope: `withSocketsDo'
21:02:48 <zRecursive> :t Network.withSocketsDo
21:02:49 <lambdabot> IO a -> IO a
22:12:34 <carter> ReinH: current emacs status
22:12:35 <carter> ?
22:13:29 <shackleford> So, out of curiosity, what are some gripes you have with Haskell? Language/libs/implementation, what have you?
22:14:30 <kayloos> The fact that if you don't import your libraries as qualified it's can be very hard to figure out which function comes from where with just reading the code
22:16:37 <kayloos> It is alleviated by good style though, but it is probably my most general annoyance when reading code
22:37:06 * hackagebot wai-app-static 2.0.0.2 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-2.0.0.2 (MichaelSnoyman)
22:37:08 * hackagebot wai-extra 2.0.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-2.0.1 (MichaelSnoyman)
22:37:10 * hackagebot yesod-bin 1.2.5.2 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.5.2 (MichaelSnoyman)
22:37:12 * hackagebot yesod-core 1.2.6.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.6.2 (MichaelSnoyman)
22:37:14 * hackagebot yesod-form 1.3.4.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.4.1 (MichaelSnoyman)
22:43:51 <slack1256> >forM [2,6] (\a -> if a < 4 then Just a else Nothing)
22:43:57 <slack1256> > forM [2,6] (\a -> if a < 4 then Just a else Nothing)
22:43:58 <lambdabot>  Nothing
22:44:36 <slack1256> How can I make that return (Just 2)
22:44:59 <jle`> > let f = Just 2 in f
22:45:00 <lambdabot>  Just 2
22:45:10 <jle`> what do you mean, do you want it to return the first success or the last?
22:45:58 <shachaf> > preview traverse [2,6]
22:46:00 <lambdabot>  Just 2
22:46:09 <prooftechnique> God damn lenses
22:46:10 <shachaf> Unfortunately that won't work with forM.
22:46:13 <prooftechnique> What can't you do?
22:46:15 <shachaf> :t forM
22:46:15 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
22:46:27 <johnw> > mfilter (< 4) [2,6]
22:46:28 <lambdabot>  [2]
22:46:39 <johnw> > listToMaybe $ mfilter (< 4) [2,6]
22:46:40 <lambdabot>  Just 2
22:46:46 <shachaf> > preview (traverse.filtered (<4)) [2,6]
22:46:47 <scott_> :t mfilter
22:46:47 <lambdabot>  Just 2
22:46:48 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
22:46:58 <prooftechnique> :t preview
22:46:58 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
22:47:05 <johnw> mfilter on lists is just filter
22:47:06 <edwardk> prooftechnique: well, if you can figure out something they can't do, submit a bug report and we'll at least look into it. ;)
22:47:07 * hackagebot yi-monokai 0.1.0.0 - Monokai colour scheme for the Yi text editor  http://hackage.haskell.org/package/yi-monokai-0.1.0.0 (MateuszKowalczyk)
22:47:12 <prooftechnique> edwardk: :D
22:47:17 <shachaf> mfilter is pretty weird.
22:47:20 <prooftechnique> I haven't seen preview before
22:47:23 <prooftechnique> Is that a new one?
22:47:25 <shachaf> edwardk: Combining lenses into a traversal!
22:47:39 <shachaf> preview is not new.
22:47:53 <jle`> @src mfilter
22:47:53 <lambdabot> Source not found. Are you typing with your feet?
22:48:19 <edwardk> preview is just view . pre, we've had all 3 of those for a long time
22:48:28 <prooftechnique> Ah, okay
22:48:31 <edwardk> its usually called ^?
22:48:34 <slack1256> mfilter i just What i was looking for
22:48:37 <scott_> Are there any other interesting MonadPlus instances? Where else does mfilter make sense?
22:48:38 <prooftechnique> Oh, now I recognize it
22:48:47 <prooftechnique> I use ^? all the time :D
22:49:54 <Fuuzetsu> Will hackage get all confuse if I try to change a ‘Category’ field of a package and upload a new version or will it do the right thing?
22:50:11 <Fuuzetsu> confused*
22:51:25 <c_wraith> Fuuzetsu: it will neither get confused nor do the right thing
22:51:36 <c_wraith> Fuuzetsu: it will just list it in both categories
22:51:58 <dmwit> Personally, I would call that confused.
22:53:18 <Fuuzetsu> That's indeed what I meant by confused although also what I expected.
22:53:33 <Fuuzetsu> Hm, aren't we allowed to do package re-uploads nowadays?
22:54:19 <simpson> :t mfilter
22:54:20 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
22:54:55 <simpson> :t \pred action -> do { a <- action; guard $ pred a }
22:54:56 <lambdabot> MonadPlus m => (t -> Bool) -> m t -> m ()
22:55:08 <simpson> :t \pred action -> do { a <- action; guard $ pred a; return a }
22:55:09 <lambdabot> MonadPlus m => (b -> Bool) -> m b -> m b
22:56:27 <prooftechnique> edwardk: Seen this? http://neilmitchell.blogspot.it/2013/12/progress-reporting-in-shake.html
22:56:40 <prooftechnique> Machines in action :D
23:00:53 <enthropy> Fuuzetsu: why would that policy have changed?
23:02:57 <Fuuzetsu> Hackage 2 &c
23:12:10 * hackagebot yesod-platform 1.2.5.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.5.2 (MichaelSnoyman)
23:30:19 <Kron> should I be using pred and succ for basic numeric incrementation and decrementation?
23:30:34 <Kron> taking a close look at the type signature, succ and pred work for anything enumerable; not just Nums
23:30:54 <Iceland_jack> Sometimes it makes sense to use them
23:30:55 <Kron> so I guess it's actually more strict and expressive to say "(n - 1)" instead of "pred n"
23:31:05 <Kron> what do you use?
23:31:19 <Iceland_jack> if you have a simple expression:
23:31:19 <shachaf> pred is weird and I prefer to say n - 1 when I mean n - 1
23:31:19 <Iceland_jack>     n - 1
23:31:19 <Iceland_jack> you should never use pred
23:31:36 <enthropy> > pred True
23:31:37 <lambdabot>  False
23:32:13 * hackagebot command-qq 0.2.0.0 - Quasiquoters for external commands  http://hackage.haskell.org/package/command-qq-0.2.0.0 (MatveyAksenov)
23:32:28 <Kron> gotcha
23:36:22 <edwardk> > pred False
23:36:23 <lambdabot>  *Exception: Prelude.Enum.Bool.pred: bad argument
23:36:31 <edwardk> ^-- note pred doesnt wrap.
23:37:04 <edwardk> and so there may be a fair bit of overhead to checking that condition if you just want to subtract 1 here and there
23:38:27 <Kron> gotcha
23:38:35 <Kron> well, it makes no real difference
23:38:42 <Kron> if you say (pred n) and GHC already knows n is an int
23:38:49 <Kron> it'll compile away the difference, won't it?
23:38:53 <Kron> it's more a human readability thing I guess
23:39:08 <Kron> or... hmmm
23:39:32 <Kron> is there a strict difference between pred and (-1) even if GHC knows the argument is a given Num type?
23:40:07 <Iceland_jack> Kron: Well (-1) isn't a function for one ;)
23:40:07 <Iceland_jack> @ty (-1)
23:40:08 <lambdabot> Num a => a
23:40:26 <Kron> you know what I mean :P
23:40:55 <chrisblake> :i (&&&)
23:41:09 <chrisblake> keep forgetting :i doesn't work on lambdabot
23:41:30 <Iceland_jack> Kron: They won't be quite the same
23:41:44 <Iceland_jack> since Enum Int checks for bounds
23:42:07 <Iceland_jack> > (minBound :: Int) - 1
23:42:08 <lambdabot>  9223372036854775807
23:42:10 <Iceland_jack> > pred (minBound :: Int)
23:42:11 <lambdabot>  *Exception: Prelude.Enum.pred{Int}: tried to take `pred' of minBound
23:42:50 <dmwit> > minBound - 1
23:42:51 <lambdabot>  No instance for (GHC.Show.Show a0)
23:42:51 <lambdabot>    arising from a use of `M120625643399308144728204.show_M1206256433993081447...
23:42:51 <lambdabot>  The type variable `a0' is ambiguous
23:42:51 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
23:42:51 <lambdabot>  Note: there are several potential instances:
23:43:01 <dmwit> Int isn't in the default default list?
23:43:17 <dmwit> ?let default (Integer, Double, Int)
23:43:17 <lambdabot>  .L.hs:143:1:
23:43:17 <lambdabot>      Multiple default declarations
23:43:17 <lambdabot>        here was another default declaration .L.hs:120:1-29
23:43:25 <dmwit> ...I see.
23:44:06 <Kron> gotcha
23:44:56 <startling> can we see L.hs somehow?
23:45:08 <startling> I'm sort of curious what's in it.
23:46:01 <dmwit> ?where state
23:46:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/State/
23:46:08 <dmwit> That... is definitely out of date.
23:46:21 <dmj`> lambdabot k
23:47:55 <Kron> is it an okay style to call a helper function "go"?
23:48:08 <Iceland_jack> sure
23:48:15 <Kron> I hear 'go' is the standard
23:48:21 <jle`> ghc seems to think so
23:48:37 <Iceland_jack> It's not a ‘standard’ but it's certainly a popular convention
23:48:53 <Kron> I'd like to abide by convention where possible
23:49:04 <johnw> go is very common in my code
23:49:07 <johnw> and well as loop
23:49:07 <Kron> conveniently the helper functions involve structural recursive traversal and construction
23:49:10 <Kron> so it DOES 'go' places
23:49:21 <Iceland_jack> You can also do <function name>'
23:49:25 <johnw> in fact, I usually use f, go or loop, depending on circumstance
23:49:37 <Iceland_jack> or aux
23:49:42 <Iceland_jack> the world is your oyster
23:49:56 <jle`> i mean if you have a specific name that is better and makes more sense then you should use it, but if there is really no name that pops out, go is a good generic name
23:50:21 <Kron> ooh aux is nice
23:50:22 <edwardk> go was a convention first adopted by dons afaict, that many of us just stole wholesale for wont of a better name
23:50:52 <Iceland_jack> Kron: Go forth and spread the One ‘aux’ identifier!
23:50:53 <Kron> I initially thought of 'rec' but haskell-mode seems to treat it like a keyword
23:50:57 <Kron> so I'm not sure what that is about
23:51:01 <edwardk>  tend to use 'go' or 'step' depending on if it loops internally or not
23:51:05 <Kron> let rec from ocaml or something?
23:51:07 <startling> often you can avoid naming it with an appropriate combinator and a lambda
23:51:10 <jle`> rec is a keyword in ocaml yea
23:51:22 <edwardk> Kron: "do rec"
23:51:24 <startling> DoRec is a language extension
23:51:25 <startling> yeah
23:51:28 <Kron> ahhh
23:51:44 <edwardk> its sugar for MonadFix alongside mdo
23:51:48 <Kron> http://lpaste.net/5429899733814476800
23:52:04 <Kron> I'm trying to practice making self explanatory code
23:52:13 <Kron> I'm not sure if I can make this any more readable
23:52:17 <Kron> I do use "l" a few times
23:52:20 <Kron> maybe I should change that
23:52:26 <Kron> l looks a lot like 1 when you glance over it
23:52:57 <Kron> also is it considered good style to have lots and lots of small functions in the top level or to embed functions in where clauses?
23:53:11 <startling> Kron, you don't need Rank2Types/forall
23:53:13 <Kron> if I have a function that will only be used once (in another function) I generally where it to make it more clear what its purpose is
23:53:22 <Kron> it was giving me type errors without them
23:53:26 <Kron> I had to remove the go type declaration
23:53:31 <Kron> due to the monomorphism restriction
23:53:42 <Kron> and I would like to keep the type declaration in if possible
23:53:52 <startling> are you thinking of ScopedTypeVariables?
23:54:19 <Kron> is there a difference?
23:54:24 <startling> yes.
23:54:32 <Kron> oh wait sorry
23:54:36 <Kron> mental misstep
23:54:46 <Kron> yeah the scopedtype variables were for the go type declaration
23:54:55 <Kron> the other one...
23:54:57 <Kron> Lens'
23:55:11 <startling> oh, got it.
23:55:19 <Kron> Illegal polymorphic or qualified type
23:55:25 <Kron> it told me to use RankNTypes or Rank2
23:55:26 <startling> line 79 still doesn't need a forall. :)
23:55:33 <Kron> so I went with Rank2 to be as specific as possible
23:55:34 <Kron> gotcha
23:55:45 <Kron> I'll be honest I don't understand the forall
23:55:47 <Kron> it's all magic to me
23:55:55 <Kron> ...
23:55:59 <Kron> nevermind, I do need the forall
23:56:02 <Kron> that's a lot of error messages
23:56:03 <startling> Do you?
23:56:28 <Kron>     Could not deduce (a1 ~ a)
23:56:29 <Kron>     from the context (Eq a)
23:56:29 <startling> maybe forall interacts with ScopedTypeVariables somehow
23:56:32 <Kron> that's the most important bit
23:56:35 <Kron> unification error
23:56:48 <dmwit> startling: Yes, see the type annotation in the where block.
23:56:57 <startling> Kron, Control.Lens.Plated might be useful for your code btw
23:57:01 <Kron> oh?
23:57:02 <Kron> do tell!
23:57:15 <johnw> Kron: which line is this in your paste?
23:57:24 <johnw> the one with the type deduction failure?
23:57:32 <Kron> line 89
23:57:35 <startling> dmwit: ah
23:57:47 <startling> I don't think I've ever used ScopedTypeVariables.
23:57:50 <startling> sorry. :<
23:57:57 <Kron> more elaborately
23:57:58 <Kron> QuadTree.hs:89:16:
23:57:58 <Kron>     Could not deduce (a1 ~ a)
23:57:58 <Kron>     from the context (Eq a)
23:57:58 <Kron>       bound by the type signature for
23:57:59 <Kron>                  setLocation :: Eq a => Location -> QuadZone a -> a -> QuadZone a
23:58:01 <dmwit> ScopedTypeVariables is weird about foralls.
23:58:01 <Kron>       at QuadTree.hs:79:16-64
23:58:08 <dmwit> Kron: Please don't paste long errors here.
23:58:11 <Kron> sorry
23:58:26 <Kron> will pastebin them in the future
23:58:31 <dmwit> Specifically: type variables are only put in scope if there's an accompanying forall.
23:58:36 <dmwit> Which is totally backwards, I know.
23:58:37 <dmwit> But hey.
23:58:51 <dmwit> Backwards compatibility, failing to fail to succeed, etc.
23:58:53 <startling> Kron, you make it an instance of Plated (`plate` should traverse all the self-similar children of your thing) and you get some neat combinators out of the deal.
23:59:03 <Kron> hmmmm
23:59:10 <Kron> i've seen 'biplate' referred to a few times in tutorials
23:59:12 <Kron> is that related?
23:59:57 <johnw> Kron: on line 89, try: n@(Leaf old), and then make the result value be n
