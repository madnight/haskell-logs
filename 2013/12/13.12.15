00:13:15 <bz> hm
00:13:31 <bz> how to simplify "either (print . show) print"?
00:14:24 <copumpkin> why would you print . show?
00:14:49 <copumpkin> print (either show id)
00:14:57 <copumpkin> well, .
00:15:05 <copumpkin> print . either show id
00:15:16 <copumpkin> :t left
00:15:17 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
00:15:28 <copumpkin> :t print . left show
00:15:29 <lambdabot> (Show d, Show a) => Either a d -> IO ()
00:16:17 <pavonia> the latter is different
00:17:21 * hackagebot ihaskell 0.2.0.0 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.2.0.0 (gibiansky)
00:17:21 * hackagebot UISF 0.1.0.0 - Library for Arrowized Graphical User Interfaces.  http://hackage.haskell.org/package/UISF-0.1.0.0 (dwincort)
00:23:30 <Feuerbach> anyone from haskell-pkg-janitors online? thoughtpolice, dmwit, sm?
00:27:04 <johnw> what channel is that?
01:37:25 * hackagebot mime-mail 0.4.3 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.3 (MichaelSnoyman)
01:38:24 <kylcarte> has anyone seen an enum instance written for a higher-order type? for instance: 'newtype BoundCoord c = BoundCoord { boundCoord :: Size c -> Coord c }', where both 'Size c' and 'Coord c' roughly correspond to '(c,c)' -- coordinates and sizes of 2D grids?
01:39:19 <kylcarte> toEnum is pretty easy, fromEnum is proving tricky.
01:44:18 <jle`> how are you defining your ordering?
01:46:10 <kylcarte> jle`: lexicographically, so, if the size is the grid is 4x4, then coords go (row = 0, col = 0) (row = 0, col = 1) ... (0,3), (1,0)... (3,3)
01:47:43 <kylcarte> I have already written functions 'lexToEnum :: Size c -> Int -> Coord c' and 'lexFromEnum :: Size c -> Coord c -> Int'
01:48:08 <kylcarte> but I haven't been able to make them fit within the types of the Enum class
01:48:40 <arkeet> you probably shouln't use Enum for that then
01:49:35 <kylcarte> arkeet: that's fair, it just made me curious. Since, you know, Enum provides nice syntax for enumeration.
01:50:22 <identity> kylcarte: what issues did you run into with trying to make it a part of enum?
01:50:34 <identity> Because that strikes me as a somewhat elegant idea, so I'm curious
01:50:48 <identity> is it a kind issue?
01:51:46 <kylcarte> identity: no, it's an issue because fromEnum needs a size to produce an Int, and it doesn't have one because the underlying type is 'Size c -> Coord c'
01:52:53 <kylcarte> likewise, if BoundCoord is redefined to be 'BoundCoord { boundCoord :: Coord c, boundSize :: Size c }', then toEnum becomes a problem, since its type is 'Enum a => Int -> a'
01:53:18 <kylcarte> it's an issue of positive/negative data
01:53:23 <identity> ah.
01:54:17 <kylcarte> I suppose I could use the syntax to enumerate ints and pass the list of Ints to a function 'f :: Size c -> [Int] -> [Coord c]'
01:54:35 <kylcarte> I think that might be the easiest way around it
01:54:51 <kylcarte> and the most readily apparent elegant solution
01:56:05 <arkeet> Size c -> Coord c looks like an odd type to be using anyway
01:56:09 <kylcarte> another route might be to parameterize the BoundCoord type with a type literal representing the grid size, which could be reified into a value
01:57:39 <kylcarte> arkeet: why? a coord is Bound and Enum-erable lexicographically within a bounded grid size.
01:57:53 <arkeet> ??
01:59:38 <kylcarte> try enumerating (Int,Int). you can enumerate one Int, but when do you jump back to 0 and increment the other Int?
02:00:19 <kylcarte> ie. [(0,0),(0,1),(0,2),...,(1,0),(1,1)...]
02:00:21 <jle`> you might want to look into how Repa represents their types
02:00:30 <jle`> wait
02:00:32 <jle`> nvm
02:01:04 <identity> kylcarte: You could just write your own typeclass, as well
02:01:21 <identity> giving toEnum another parameter
02:01:44 <kylcarte> identity: true, and I essentially have for this one type, but then I don't get the nice builtin syntax :)
02:01:53 <identity> no, true
02:05:37 <kylcarte> okay, I think this will do: I already have some function 'indexCoord :: Size c -> Int -> Maybe (Coord c)', which takes a grid Size and an Int and tries to turn it into a Coord in the grid. If the Int points beyond the bounds of the grid, it returns Nothing.
02:06:26 <kylcarte> then I can make a function 'enumCoords sz = mapMaybe (indexCoord sz) :: Size c -> [Int] -> [Coord c]'
02:06:51 <kylcarte> then I can use the handy Enum syntax, and get the list of Coords I want
02:07:26 <rtpg> what's the easiest way to construct a list of elements that implement show?
02:07:44 <rtpg> like, being able to build the list [1,"Hello"]
02:07:50 <arkeet> you don't.
02:08:02 <arkeet> what would you do with such a list?
02:08:19 <rtpg> well, for example,  map show list :: [String]
02:08:27 <arkeet> anything else?
02:08:27 <opqdonut> rtpg: data Showable a = Show a => Showable a
02:08:42 <arkeet> because if you do ↑ then that's about the only thing you can do.
02:08:51 <opqdonut> but see also, http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
02:08:56 <arkeet> ↑
02:09:10 <kylcarte> opqdonut: thanks for providing that caveat.
02:09:12 <opqdonut> but yeah, a list of showables is pretty much equivalent to a list of strings
02:09:41 <rtpg> arkeet, but that's the same with every generic function argument isn't it?  You can only write a definition using typeclass constraints
02:09:59 <arkeet> rtpg: yes, which is why such a thing is no better than a list of Strings.
02:10:14 <opqdonut> well you can do tons of stuff with a Show a => [a]
02:10:20 <arkeet> like what
02:10:23 <opqdonut> (permute it, duplicate elements, ...)
02:10:33 <arkeet> you can do that with [String] too
02:10:35 <opqdonut> they're not that useful things mind you
02:10:37 <opqdonut> yeah
02:11:23 <identity> what was that new case insensitive string thing called in ghc 7.6(was it .6?)
02:11:29 <identity> i could use that now
02:11:34 <arkeet> what new case insensitive string?
02:11:58 <identity> @hackage case-insensitive
02:11:58 <lambdabot> http://hackage.haskell.org/package/case-insensitive
02:12:07 <identity> what I meant was it was added to the haskell platform I think
02:12:20 <arkeet> oh.
02:12:38 <arkeet> yes that's new in the latest platform
02:12:50 <rtpg> I get your points , I'm looking more into some very type-level stuff (where I end up using typeclass instances a lot to group elements) which is why I asked the question.
02:12:59 <kylcarte> it basically boiled down to a newtype wrapper with case insensitive Eq instances, etc.
02:13:04 <kylcarte> IIRC
02:13:08 <rtpg> I just took Show because it's an easy example
02:13:21 <identity> kylcarte: yep
02:13:30 <arkeet> rtpg: please read the thing opqdonut linked
02:14:11 <kylcarte> rtpg: Existentials with class constraints are useful, but they do limit what can be done to the data down to exactly what the constraints provide for
02:14:24 <kylcarte> and they usually aren't worth it
02:14:37 <kylcarte> as per that article. I second the recommendation.
02:14:38 <rtpg> when you're working with type-level naturals, the values and the types are the same anyways
02:16:18 <kylcarte> rtpg: what's your point?
02:17:01 <rtpg> my point being that the arguments about not having access to the data can sometimes not actually be that important, and it's just the typeclass dictionary that you want to exploit
02:17:13 <rtpg> but this is an extremely specific case
02:17:53 <kylcarte> yep, that's just the tradeoff
02:59:24 <jg> hi all. I'm getting this weird "Could not find module `Control.Monad.State'" error. 'mtl' is in build-depends and cabal install mtl says mtl-2.1.2 is already installed
02:59:44 <jg> Has anyone seen this already perhaps?
03:00:02 <arkeet> show cabal file?
03:02:19 <jg> arkeet: http://pastebin.com/vnxBJhmN
03:02:26 <mauke> The paste vnxBJhmN has been copied to http://lpaste.net/96996
03:04:29 <arkeet> um
03:05:14 <arkeet> you don't even have any source files listed
03:05:23 <arkeet> modules
03:05:58 <arkeet> also this looks like a ... strange ... file
03:06:19 <arkeet> you know you can use  cabal init  to generate a cabal file you can start with
03:06:25 <arkeet> and you probably should also read the cabal user's guide
03:06:28 <kuznero> Hi All!
03:06:33 <arkeet> hi
03:17:38 * hackagebot ec2-signature 3.1 - The Amazon EC2 style signature calculator.  http://hackage.haskell.org/package/ec2-signature-3.1 (YusukeNomura)
03:19:46 <notadog> I am creating a program with GUI that launches scripts, and I am progressing well I think considering I started learning haskell a month ago.(my first programming language too.)However, I can't figure out how to unbind "onClicked" events from buttons in a seperate function to the one they were called in. Essentially, I have a grid of 9 buttons, and I want to have some buttons launch programs/scripts with
03:19:48 <notadog> rawSystem, but I also want the ability to have some buttons act as a parent button, and when clicked change all of the 9 buttons to have different labels and onClicked events. so I have something like "onClicked (button1 gui) (nodeCheck (words "filecontainingcommands.txt 1 gui") gui), which sets the button to run the nodeCheck function, which checks if it is a node, if it is, replaces all of the button
03:19:50 <notadog> labels and onClicked events with new ones. However, if I bind the onClicked with "<-", that is only in-scope in that function, not in the nodeCheck one. How do I do what I am trying to do? Sorry If I am not clear.
03:20:32 <FreeFull> notadog: Which GUI framework is this?
03:21:54 <notadog> Gtk2Hs, with the Graphics.UI.Gtk.Builder import. I believe my problem is a lack of understanding of how to access bound IO results from other functions. I am probably wrong though.
03:25:40 <notadog> from what I have read I should be using IORef? I have tried msgHandler <- liftIO $ onClicked (button1 gui) (nodeCheck (words "commands.txt 1 gui") gui) >>= newIORef
03:27:53 <notadog> and then signalDisconnect msgHandler. Which works if the signalDisconnect is in the same function as the onClicked, but not if it is in a different function. And I need it to be in a different function because I need a check to be run on whether the button is a node or not(whether the first item in the list is "node"). I assumed I would need to do this in a seperate function or it would be extremely messy.
03:27:55 <notadog> Or should I be doing this check in the same function as the "onClicked" line?
03:28:45 <notadog> My program is working great other than if I click on a node, and then click on one of the buttons, it runs both the new onClicked and the old one.
03:39:31 <Philonous_> notadog, You don't have to put the ConnectID in a IORref
03:39:46 <Philonous_> notadog, You can just pass it aournd normally.
03:40:43 <Philonous_> If you need it outside the function you create it in you can just return it from the function. If ou're already returning something else you can put it into a tuple
03:48:01 <notadog> Philonous_, thanks! I think that will help me get it working.
03:51:00 <udevd> http://lpaste.net/96997 i'm having >:4:41: parse error on input `='
03:51:20 <udevd> 41st character is 'i' in 'lines'
03:51:38 <udevd> i don't really know why this isn't working :P
03:51:44 <shachaf> 8-space tabs
03:51:46 <Philonous_> udevd, That looks like an indentation problem
03:51:52 <udevd> aaah
03:51:54 <shachaf> (Look at the paste you pasted.)
03:52:07 <Philonous_> udevd, try trplacing tabs with spaces
03:52:09 <udevd> ah yes
03:52:11 <mornfall> :D
03:52:17 <mornfall> python's revenge
03:52:22 <udevd> sublime default uses tabs instead of spaces
03:52:23 <udevd> :P
03:56:17 <donri> udevd: and doesn't treat tabs as 8 spaces wide?
04:05:58 <skypers> @hoogle void . runStateT
04:05:58 <lambdabot> Parse error:
04:05:58 <lambdabot>   void . runStateT
04:05:58 <lambdabot>         ^
04:06:15 <skypers> @hoogle void . execStateT
04:06:15 <lambdabot> Parse error:
04:06:15 <lambdabot>   void . execStateT
04:06:15 <lambdabot>         ^
04:06:18 <skypers> damn it
04:08:17 <notdan> @ty void . execStateT
04:08:18 <notdan> ?
04:08:18 <lambdabot> Monad m => StateT s m a -> s -> ()
04:09:40 <mrwonko> hey, is there some nicer way to write foldr (liftA2 (:) . functionReturningEither) (Right []) list, i.e. mapping some a -> Either a over a list, then turning it from [Either a] into Either [a]?
04:10:41 <donri> mrwonko: i think you forgot Left there?
04:11:36 <donri> :t mapM Right
04:11:37 <lambdabot> [b] -> Either a [b]
04:12:36 <mrwonko> right, replace Either with Either x in my text above
04:12:53 <donri> mrwonko: well then, mapM :)
04:12:59 <mrwonko> wonderful
04:13:08 <donri> assuming you want the monadic behavior of Left
04:13:12 <mrwonko> I do
04:15:05 <Yuu-chan> Is it possible to turn on texture interpolation for bitmap scaling in Gloss?
04:20:48 <FreeFull> :t mapM return
04:20:49 <lambdabot> Monad m => [b] -> m [b]
04:45:54 <Yuu-chan> Guys? Who can provide a little help with Gloss?
04:54:45 <blablub> regarding repa: why is this very slow: computeP $ fromFunction shp $ \(Z :. y :. x :. c) -> fromIntegral $! x + y
04:55:48 <blablub> (this takes 9s, with changing the lambda-expr to "const 1" it takes 1s)
04:56:22 <blablub> (for ~6 million elements)
05:26:47 <|apriori|> hello guys, does anyone know a decent, documented, active haskell lib, which is able to create a data (class) model from an xsd? autogenerate parser + renderer for a given xsd?
05:27:53 <|apriori|> I know of HaXml, but it seems to be quite dated, no longer maintained.. and was yelling, because it not able to properly handle documentation tags.
05:31:20 <mrwonko> is there a point-free if? instead of \x -> if x then a else b
05:32:02 <Rembane> mrwonko: Maybe. Have you got a little bigger example where you want to get rid of the if?
05:33:10 <mrwonko> hmm right, maybe I'm looking at it the wrong way
05:34:22 <mrwonko> I want to count elements that satisfy a condition in an expression. I was going for count = foldl (+) 0 . map ((\x -> if x then 1 else 0) . satisfiesCondition), but thinking about it I should rather do count = length . filter (satisfiesCondition), or maybe there is a function for that already
05:34:27 <mrwonko> *in a list
05:37:00 <Rembane> mrwonko: I think your second solution looks nice
05:37:06 <Yuu-chan> mrwonko: point-free `if' can be expressed as fromJust . lookup [(True, a), (False, b)]
05:39:09 <Yuu-chan> mrwonko: but I agree that the filter solution is better
05:42:02 <bennofs> Is there a package/library for generating valid haskell code in a program?
05:43:49 <Heffalump> bennofs: are you aware of Template Haskell?
05:44:03 <Heffalump> bennofs: also, see the haskell-src and haskell-src-exts packages
05:45:42 <bennofs> Is there a function Dec -> String in template-haskell?
05:46:23 <bennofs> Oh, found it. pprint
05:48:01 <Yuu-chan> bennofs: if you find a way to get rid of fully qualified names (eg. Ghc.Prim.+), please tell me
05:48:18 <jg> hmm, how can i match against a Maybe in  IO (Maybe a) ?
05:48:38 <bennofs> Yuu-chan: I don't really care, because I compile the generated code with the GHC API so the user won't even see it :p
05:49:13 <Iceland_jack> jg: do a ← (ma ∷ IO (Maybe a))
05:49:13 <Iceland_jack>        case a of
05:49:13 <Iceland_jack>          Nothing → …
05:49:13 <Iceland_jack>          Just xs → …
05:49:26 <Yuu-chan> jg: or use monad transformers
05:49:30 <Iceland_jack> or that
05:49:49 <jophish_>  Couldn't match type ‛IO a -> IO a’ with ‛forall a1. IO a1 -> IO a1’
05:49:51 <jophish_> hmm
05:50:36 <Yuu-chan> bennofs: huh, if you compile the generated source anyway, why not to use macros? Or do you need the source in some other place?
05:52:05 <bennofs> Yuu-chan: I want to use a different version of Cabal than the one ghc comes with. So my project cannot depend on Cabal. I want to use GHC to compile an expression with the right Cabal version
05:52:57 <Yuu-chan> bennofs: I thought GHC doesn't use cabal at all...
05:53:04 <jg> Iceland_jack: Many thanks!
05:53:24 <bennofs> Yuu-chan: ghc depends on Cabal, for some reason
05:54:42 <bennofs> Yuu-chan: you can try it yourself. Just run ghci -package ghc. Then Cabal gets loaded
05:54:54 <notdan> It uses cabal for building libraries packaged with ghc, so there is at least that
05:55:15 <bennofs> The GHC API package depends on cabal, for whatever reason
05:56:15 <Yuu-chan> Interesting...
05:56:48 <notdan> oh, I think that's for some lower level modules
05:56:53 <notdan> used for parsing
05:57:19 <notdan> it's related to GHC package databse
05:58:25 <jophish_> I have create :: IO Bool, destroy :: IO () and, use :: IO ()
05:58:44 <jophish_> how can I bracket use with create and destroy, running use and destroy only if create returns true?
05:58:52 <Yuu-chan> Btw, what to do if I want some lens package, but I'm frightened of the number of dependencies Control.Lens need?
05:59:31 <bennofs> Yuu-chan: do you mean you want to use a package that depends on lens or provides lenses?
05:59:58 <bennofs> Yuu-chan: or do you just want to use lenses?
06:00:24 <Yuu-chan> bennofs: yes, I'd want to try some lenses in my game
06:01:17 <Yuu-chan> bennofs: and I'm choosing between lens and data-lens (and probably lenses, but it seems too old and unpopular)
06:01:28 <bennofs> Yuu-chan: You could use lens-family
06:01:54 <notdan> Yeah, it's actually compatible with `lens`, IIRC
06:02:21 <bennofs> Yuu-chan: Btw, why are the number of dependencies a problem for you?
06:02:58 * hackagebot LambdaHack 0.2.10.6 - A roguelike game engine in early and active development  http://hackage.haskell.org/package/LambdaHack-0.2.10.6 (MikolajKonarski)
06:03:19 <bennofs> Most of the packages that lens depends on are pretty small (profunctors, comonads, either, ...) and are pretty useful imo
06:04:19 <Yuu-chan> jophish_: probably something like bracket create (\f -> when f destroy) (\f -> when f use)
06:05:23 <jophish_> Yuu-chan: I went with initialized <- create; if initialized then finally use destroy else print "error"
06:08:08 <jophish_> Hmm, I have the same thing with Maybe resource
06:08:12 <notdan> hm well you are not really using bracket then
06:08:15 <jophish_> this seems like a common problem
06:08:23 <notdan> erm
06:08:41 <notdan> sorry you are using finally, my bad
06:11:26 <Yuu-chan> bennofs: I don't know what to answer >_> Seems I prefer minimalistic solutions and "lens" package looks too scary and bloated
06:15:38 <|apriori|> Yuu-chan, from experience I must tell, lens doesn't make code exactly readable
06:20:16 <Eduard_Munteanu> Hm... what do you think of aligning multi-line function definitions like this: <function name> <args>\n<fixed indent>= <first line>\n<fixed indent>  <second line>\n<...>   ?
06:20:23 <Eduard_Munteanu> e.g.
06:20:24 <Yuu-chan> |apriori|: so I'd want to at least give it a try :)
06:20:30 <Eduard_Munteanu> foo x y
06:20:44 <Eduard_Munteanu>     = x + y +
06:20:55 <Eduard_Munteanu>       x * y
06:21:47 <Eduard_Munteanu> For large definitions, that is.
06:22:01 <Yuu-chan> Eduard_Munteanu: I use similar, but personally prefer hanging = at the end of the clause (same with `where' and `do')
06:22:24 <Eduard_Munteanu> Yeah, that's what I've been using so far as well.
06:22:38 <jophish_> Opinions: http://lpaste.net/96999
06:22:57 <Yuu-chan> Eduard_Munteanu: did you find it less readable?
06:23:05 <jophish_> I think that this could be improved
06:23:10 <jophish_> it doesn't seem quite elegant
06:24:13 <Eduard_Munteanu> Yuu-chan: no, but I've seen people align under hanging '=' or 'do' which is annoying because indentation varies too much. I was thinking of a compromise like this.
06:24:16 <Yuu-chan> jophish_: I think maybeBracket is less magical as it uses an explicit resource
06:25:01 <Yuu-chan> jophish_: whereas boolBracket hides it in a "flag"
06:25:07 <Eduard_Munteanu> longline = do foo
06:25:17 <Eduard_Munteanu>               bar
06:25:25 <Eduard_Munteanu> I find it sort of ugly.
06:25:44 <Iceland_jack>     longline = do
06:25:44 <Iceland_jack>         foo
06:25:44 <Iceland_jack> 	bar -- better
06:25:50 <Iceland_jack> bah! indentation fail
06:26:50 <Eduard_Munteanu> Yeah, I usually prefer a more C-ish indent style, using fixed amounts of space, possibly subtracting to add certain operators...
06:27:18 <Iceland_jack> I'm actually at a loss what to do with a ‘hanging’ lambda abstraction
06:27:20 <Eduard_Munteanu> foo bar baz
06:27:28 <Eduard_Munteanu>     =  bar
06:27:34 <Eduard_Munteanu>    <|> baz
06:27:39 <Iceland_jack>     foo = function $ \bar ->
06:27:39 <Iceland_jack>         longexpression
06:27:46 <Iceland_jack> I find that very ugly
06:28:21 <Iceland_jack> Sometimes I'll do
06:28:21 <Iceland_jack>     foo = function $ \bar -> let
06:28:21 <Iceland_jack>         x = …
06:28:21 <Iceland_jack> 	y = …
06:28:24 <Iceland_jack>         in longexpression
06:28:25 <Eduard_Munteanu> Iceland_jack: I usually only use that for 'fun $ \bar -> do' constructions
06:28:27 <Yuu-chan> Eduard_Munteanu: me too, I decided to use mostly fixed-width indentation
06:28:28 <Iceland_jack> which feels similar to imperative languages
06:28:41 <Iceland_jack> Eduard_Munteanu: Yeah, for do the choice is easy
06:29:06 <Iceland_jack> but sometimes you pass in higher order non-monadic functions
06:29:07 <Eduard_Munteanu> Because most functional lambdas don't occur in the last argument anyway, e.g. map
06:29:29 <Iceland_jack> Yes, it's generally not an issue
06:30:39 <Yuu-chan> But it's hard to come up with a strict and unified style :(
06:30:42 <Iceland_jack> True
06:30:44 <Iceland_jack> There are two ‘non-standard’ styles that I rather like
06:30:53 <Iceland_jack> trailing where and trailing let
06:31:26 <Iceland_jack>     foo x y x = shortExpression where
06:31:26 <Iceland_jack>         bar = undefined
06:31:26 <Iceland_jack>         baz = undefined
06:32:44 <Eduard_Munteanu> I'm at a loss on what to do for multiline instance/class declaration heads, because the body looks oddly indented after 'where'.
06:33:02 * hackagebot HPi 0.4.0 - GPIO and I2C functions for the Raspberry Pi.  http://hackage.haskell.org/package/HPi-0.4.0 (WJWH)
06:33:06 <Eduard_Munteanu> instance BigConstraint
06:33:11 <Yuu-chan> Eduard_Munteanu: how so?
06:33:14 <Iceland_jack> Ah yes
06:33:14 <Eduard_Munteanu>     BigHead
06:33:22 <Eduard_Munteanu> er.
06:33:49 <Iceland_jack> ?
06:33:49 <Iceland_jack>     instance BigConstraint f
06:33:49 <Iceland_jack>       where
06:33:49 <Iceland_jack>         big = …
06:33:51 <Eduard_Munteanu> instance BigConstraint\n<indent_unit>BigHead where\n<indent_unit>
06:34:28 <Iceland_jack> Feldspar uses that style quite extensively I recall
06:34:31 <Yuu-chan> I like
06:34:31 <Yuu-chan> instance BigConstraint f where
06:34:31 <Yuu-chan> <  >big = ...
06:34:31 <Yuu-chan> <  >toBig = ...
06:34:46 <Eduard_Munteanu> Iceland_jack: if the thing before 'where' requires multiple lines, the body after 'where' looks as if it were indented at the same level.
06:35:26 <Yuu-chan> module BigModule where
06:35:51 <Eduard_Munteanu> I don't indent after 'module ... where'.
06:36:05 <Yuu-chan> foo bar = baz `on` bar where
06:36:05 <Yuu-chan> <  >baz = ...
06:36:35 <Eduard_Munteanu> Lemme make a paste to clarify...
06:37:13 <Yuu-chan> Eduard_Munteanu: me too, same with the "parent" namespace in C++ code
06:38:59 <jophish_> Is this reasonable? http://lpaste.net/97000
06:39:24 <jophish_> I seem to always get 0
06:39:37 <Eduard_Munteanu> Yuu-chan, Iceland_jack: http://lpaste.net/97001
06:39:52 <Eduard_Munteanu> Err, method :: type
06:40:08 <Iceland_jack> Eduard_Munteanu: Yeaah.. that looks yuck
06:40:58 <Eduard_Munteanu> I also don't want to double the indent after 'where'.
06:41:25 <Yuu-chan> You can critique my code/style: https://bitbucket.org/yuuri/carcaskell/src/8239c9b6e7ed19cc55e70371f4143b81a9d47ec5/src/Carcaskell/GUI.hs?at=master *sigh*
06:42:39 <Eduard_Munteanu> Yuu-chan: luckily you have those haddock comments, without them it's really hard to spot where stuff starts and ends, at least to me.
06:42:58 <Eduard_Munteanu> I mean, without type sigs.
06:43:20 <Eduard_Munteanu> I wish we had type '_' / placeholders.
06:44:27 <Eduard_Munteanu> E.g. I might still want to write part of the type, for example in xmonad types involving layouts, where layouts involve huge types you don't really want to type.
06:44:37 <Eduard_Munteanu> myConfig :: XConfig _
06:44:54 <Yuu-chan> Eduard_Munteanu: do you mean implicitly typed local variables there?
06:45:00 <Eduard_Munteanu> I ended up making existentials for that purpose.
06:45:42 <Eduard_Munteanu> Yuu-chan: _ stands for a type that should be inferred, so you supply part of the type yourself and the rest is inferred as usual.
06:46:14 <Iceland_jack> Eduard_Munteanu: So you mean:
06:46:15 <Iceland_jack>     head' :: _ → _
06:46:15 <Iceland_jack>     head' = head
06:46:39 <Eduard_Munteanu> That would work, yeah.
06:46:47 <Iceland_jack> Interesting thought
06:47:00 <Eduard_Munteanu> Metavariable unification might be harder on (->) though.
06:47:08 <Iceland_jack> yeah
06:47:11 <Yuu-chan> Isn't there a GHC extension for that? :)
06:47:38 <Eduard_Munteanu> But for ordinary data/newtype type constructors it should do just fine.
06:47:51 <Yuu-chan> Eduard_Munteanu: my question was about things which are hard to spot
06:48:17 <Eduard_Munteanu> Yuu-chan: hm, what do you mean?
06:48:47 <Eduard_Munteanu> Iceland_jack: Agda has those, that's my source of inspiration :)
06:48:53 <Yuu-chan> Eduard_Munteanu> luckily you have those haddock comments, without them it's really hard to spot where stuff starts and ends, at least to me. I mean, without type sigs.
06:49:11 <Iceland_jack> yeah, Agda also has let's on the type level :)
06:49:19 <Iceland_jack> One day.
06:49:26 <Eduard_Munteanu> Yuu-chan: ah, no, I mean you don't have type sigs for some toplevel functions.
06:50:24 <Eduard_Munteanu> For some reason I have a hard time spotting definition endpoints without sigs. :)
06:50:25 <Yuu-chan> Eduard_Munteanu: ah. my bad. Probably I should use hlint and/or -Wall :)
06:52:30 <Eduard_Munteanu> I remember the first time I heard of Haskell, I saw some snippets without type sigs on Wikipedia or something. I thought "hm, yet another PHP, Python, ...". :)
06:52:32 <Yuu-chan> Eduard_Munteanu: thanks for noticing
06:57:56 <Yuu-chan> Eduard_Munteanu: :) Some time I and my friend discussed typing matters (who also saw only such snippets) and he said something like "In C++ each type has strict converting rules, so it has strong typing. Basic has weak one. And Haskell has no typing, as I can see - I'm able to write a function without defining what it must get."
06:58:18 <Eduard_Munteanu> Heh.
06:58:24 <Yuu-chan> Sorry my Engrish.
06:59:02 <aristid> Yuu-chan: "strict converting rules", heh.
06:59:24 <triliyn> unsigned int x = -10;
06:59:35 <aristid> triliyn: that works in haskell too :)
06:59:48 <aristid> > (-10) :: Word64
06:59:49 <lambdabot>  18446744073709551606
07:00:08 * Eduard_Munteanu uses his own dialect which doesn't involve incorporating punctuation outside a quote into the quote
07:00:15 <triliyn> I guess
07:00:27 <triliyn> There are cases that haskell stops though, I think!
07:00:30 <axisofchange> I have a conceptual question that's sort of noobish, mostly looking for a link to some tasty code to read. Lets say I'm doing something like writing a language interpretter or fulfilling user requests--where based on what's actually being evaluated fulfillment -might- require IO... how would I structure something like that? In fact, is that even worrisome at all given that the input will come in via IO anyway?
07:00:46 <triliyn> int x = -10; unsigned int y = x;
07:01:18 <Eduard_Munteanu> axisofchange: no, you can still process the actual data functionally / purely.
07:01:25 <Yuu-chan> Among my favourites are "C string" + " literal cannot be concatenated"
07:01:48 <triliyn> > let x :: Int; x = -10; y :: Word64; y = x in y
07:01:49 <lambdabot>  Couldn't match expected type `GHC.Word.Word64'
07:01:49 <lambdabot>              with actual type `GHC.Types.Int'
07:02:17 <triliyn> Although I guess fromInteger still works...
07:02:46 <axisofchange> Eduard_Munteanu: Despite the fact that I may need to make a database call to complete the evaluation?
07:02:50 <Eduard_Munteanu> axisofchange: consider  main = do { n <- getNumber; let result = processNumber n; putStrLn (show result) }
07:02:56 <Yuu-chan> My first C++ error was smth like n / (n + k) and "Why the heck is it always 0!"
07:03:29 <Eduard_Munteanu> axisofchange: that depends, you can still keep it out of your functional code in many cases.
07:05:43 <Eduard_Munteanu> axisofchange: main = do { fn <- getFilename; cts <- readFile (transformFilename fn); putStr (show (processContents cts)) } instead of IO-izing both transformFilename and processContents.
07:07:18 <Eduard_Munteanu> Just split stuff into smaller bits that take actual data in.
07:07:30 <axisofchange> Eduard_Munteanu: But main itself is IO-ized. Hmm. I think I gather what you're saying.
07:07:52 <Yuu-chan> So, is Eduard Kmett's "lens" the lens library of choice?
07:08:17 <Eduard_Munteanu> Sure, but you no longer really place IO stuff along with your functional transformations.
07:08:27 <Eduard_Munteanu> Yuu-chan: I'm not that Edward :)
07:08:49 <Eduard_Munteanu> Yuu-chan: and yeah, the answer is yes wrt "lens".
07:09:23 <Yuu-chan> Eduard_Munteanu: oh, I misspelled his name
07:12:37 <bearclaw_> a "why is my bad code so slow?" quesion: I have a ~10k long vector of zeros initially and my algorithm produces a list of rules "add x to element of index y". So I'm using Vector, and vUpdateWith idx f v = v V.// [(idx, f $ v V.! idx)] , and it's extremely slow. Am I doing it wrong?
07:12:46 <axisofchange> Eduard_Munteanu: I'm still sort of having a hard time getting my head around the type signature of a function that might do IO but also might not do IO.
07:13:14 <Eduard_Munteanu> axisofchange: it either does or doesn't, really
07:13:39 <Eduard_Munteanu> Unless you might have multiple implementations.
07:14:30 <Yuu-chan> bearclaw_: how often do you call vUpdateWith?
07:14:49 <bearclaw_> 3 times per element, but not in order
07:15:02 <axisofchange> Eduard_Munteanu: But at some point, deeper than main, based on the parameters.. it's either goign to or not going to.
07:15:08 <Eduard_Munteanu> bearclaw_: if those are immutable vectors, updating involves recopying the whole thing
07:15:42 <bearclaw_> well, I was hoping the compiler would detect I don't reuse the old vector state, and so use a mutable vector
07:16:03 <Yuu-chan> bearclaw_: V.// has O(n) complexity, so when you call it thrice for each element of n, the whole algorithm becomes O(n^2)
07:16:20 <Yuu-chan> bearclaw_: unfortunately it can't
07:16:28 <Eduard_Munteanu> bearclaw_: GHC doesn't really do that, unfortunately
07:17:06 <bearclaw_> argh, what would you suggest as data structure then?
07:17:09 <Yuu-chan> bearclaw_: so I guess you should use STVector if you really need incremental updates
07:17:43 <bearclaw_> I don't realy need the incremental, just the end state to be correct
07:17:44 <Yuu-chan> Or to modify the algorithm so it could update the whole vector at once.
07:17:58 <Eduard_Munteanu> bearclaw_: either a mutable vector or something like Seq or Map, depending on the usecase.
07:18:21 <afleck> is there a way to zipWith but keep leftovers?
07:18:29 <Eduard_Munteanu> bearclaw_: or even a plain list if you need to update all of it.
07:18:36 <bearclaw_> because for Map an "update" can  be performed without duplicating it entirely?
07:18:40 <afleck> e.g. zipWith (+) [1,1] [1,1,4] = [2,2,4]
07:18:52 <Eduard_Munteanu> bearclaw_: yes
07:19:02 <Rembane> afleck: concat the shorter list with an infinite list of id.
07:19:25 <Rembane> afleck: zipWith (+) ([1,1] ++ [0..] [1,1,4])
07:19:29 <bearclaw_> but by-index access is algorithmically slower than for a vector
07:19:30 <Eduard_Munteanu> It has O(log n)-ish behavior for update / lookup.
07:19:39 <Rembane> afleck: Just move the ) to the right place. :D
07:19:57 <afleck> Rembane: makes sense, thank you!
07:20:02 <bearclaw_> so on a purely complexity pov the procedural C++ version would be faster
07:20:03 <Eduard_Munteanu> bearclaw_: do you really need to index into it, or could you just map a function over all of it?
07:20:31 <Yuu-chan> afleck: you can easily implement your own: zipWithLeftovers _ [] xs = xs; zipWithLeftovers _ xs [] = xs; zipWithLeftovers f (x:xs) (y:ys) = f x y : zipWithLeftovers xs ys
07:20:33 <Rembane> afleck: No worries.
07:21:03 <bearclaw_> Here is a simplified use case: I read from a file a bunch of (index, amountToAdd) in no particular order and need the result of applying them all
07:21:52 <Eduard_Munteanu> bearclaw_: how large is the actual vector to apply it to? Is it sparse or dense?
07:22:09 <bearclaw_> 10.000 elements
07:22:11 <Rembane> bearclaw_: What about using a Map instead?
07:22:46 <bearclaw_> Rembane: now I understand why a map would perform better, but the complexity would still be sub-optimal
07:23:38 <Eduard_Munteanu> bearclaw_: there's also the option of not reading the vector at all and just keeping the list of transformations around, depending on what you want to do *after* that.
07:23:46 <Rembane> bearclaw_: Ah. Okay.
07:23:59 <bearclaw_> I want to dump the resulting list of applying all the transformations to a file
07:24:30 <aristid> bearclaw_: you might be able to use ST
07:25:57 <Yuu-chan> bearclaw_: or even IO, as long as transformations are read from a file. This would look like a plain old imperative loop
07:26:21 <Eduard_Munteanu> bearclaw_: then you could just read the transformations list, put *that* into a Vector and lookup transformations as you read the input vector and writing the result immediately.
07:28:21 <bearclaw_> but putting the transformation list into a vector would still be a O(n2) operation usign Vector, since operations come unordered
07:29:16 <skypers> hm
07:29:42 <skypers> there’s something I learned today: always returning Maybe a leads into annoying code
07:29:45 <Eduard_Munteanu> bearclaw_: that's a different 'n' though, and you might be able to just accumulate them into a list and sort it
07:29:49 <skypers> everything can fail
07:29:58 <skypers> then I’m stuck to use maybe _everywhere_
07:30:06 <bearclaw_> yeah, a n 3 times bigger in my case :)
07:30:28 <skypers> how do you handle can-fail code?
07:30:34 <skypers> I mean, failure prone
07:31:14 <afleck> if i have a type like Foo a = Foo [a], is there a way to get the list itself after saying, e.g. bar = Foo [1,2,3,4]?
07:31:32 <Yuu-chan> afleck: getList (Foo a) = a
07:31:50 <skypers> afleck: or
07:32:00 <skypers> newtype Foo a = Foo { getList :: [a] }
07:32:38 <Yuu-chan> skypers: probably that's why default head and tail are partial
07:32:54 <skypers> what do you mean?
07:33:06 <afleck> thank you both
07:33:31 <Yuu-chan> head :: [a] -> a, not [a] -> Maybe a, because that would be annoying
07:35:03 <Yuu-chan> But monads make chaining computations, where anything can fail, less painful
07:36:35 <Kaidelong> (it's the approach haskell uses to achieve that and has the advantage of being easily portable to other languages, but it's not the only way)
07:37:22 <Eduard_Munteanu> bearclaw_: I guess you want a mutable vector/array indeed.
07:38:07 <bearclaw_> I'll try it then, thanks
07:39:08 <nadirs> Hello
07:40:35 <Eduard_Munteanu> > runST { v <- listArray (1,5) [1, 0, 1, 0, 1]; writeArray v 3 3; return (show v) }
07:40:36 <lambdabot>  <hint>:1:11: parse error on input `<-'
07:40:42 <Eduard_Munteanu> > runST $ do { v <- listArray (1,5) [1, 0, 1, 0, 1]; writeArray v 3 3; return (show v) }
07:40:43 <lambdabot>  Not in scope: `writeArray'
07:40:52 <Eduard_Munteanu> Gr.
07:42:34 <Eduard_Munteanu> Mind you might want an IO array/vector, thawing/freezing a mutable one involves copying too so it doesn't help.
07:49:55 <jophish_> Yo yo yo
07:50:07 <axisofchange> Eduard_Munteanu: Is this sort of what you meant? http://lpaste.net/97003
07:50:24 <jophish_> I'm ending up using lift a lot in the state monad to lift things from the IO monad
07:50:45 <jophish_> the type I'm returning is StateT GameState IO ()
07:50:57 <jophish_> is it normal to have to do this?
07:51:18 <Iceland_jack> @google lift doing wrong
07:51:19 <lambdabot> http://blog.ezyang.com/2013/09/if-youre-using-lift-youre-doing-it-wrong-probably/
07:51:19 <lambdabot> Title: If you’re using lift, you’re doing it wrong (probably) : Inside 206-105
07:51:20 <Eduard_Munteanu> axisofchange: yeah, that's reasonable, now your parsers are separate from IO logic.
07:51:44 <axisofchange> Eduard_Munteanu: And in the case that I needed to do more processing of the 'google' result I would liftM?
07:53:57 <zomg> Iceland_jack: that's not a very useful article tbh :P
07:54:02 <jophish_> Iceland_jack: yeah, I thought it was a bit odd. I'm not quite sure what to do instead
07:55:45 <Eduard_Munteanu> axisofchange: that is one way (or using <$> which is nicer), but more generally your eval is supposed to do some IO to retrieve some data, just like getLine. So you can use it in the same circumstances 'getLine' is used, if you make  eval :: Command -> IO Result
07:56:10 <jophish_> As far as I can tell I'll still need to use liftIO
07:56:14 <Iceland_jack> zomg: Sorry, I'm way too busy to be useful! :) only have time to passive-aggressively post links
07:57:00 <zomg> Iceland_jack: yeah it might've been more useful if there was a theoretical discussion about monad transformers in general, as it is it doesn't really answer the question =)
07:57:17 <Eduard_Munteanu> jophish_: if you manage to lump IO stuff into a few plain IO functions, you can liftIO those instead.
07:57:25 <jophish_> that's what I've been doing :)
07:57:27 <zomg> well, actually it does answer it if you read between the lines - yes it is normal with the way things work
07:57:30 <zomg> heh
07:57:45 <axisofchange> Eduard_Munteanu: What about the case where it doesn't have to do any IO?
07:58:00 <Eduard_Munteanu> jophish_: alternatively, you can use MonadBase / MonadBaseControl stuff and be polymorphic in the IO monad. Then you don't need to lift at all, just like with State / MonadState.
07:58:32 <Eduard_Munteanu> axisofchange: just   return SomePureResult
07:58:56 <axisofchange> Eduard_Munteanu: Ooooh.
07:58:57 <jophish_> Eduard_Munteanu: Sorry, that's gone over my head a little
08:02:13 <Eduard_Munteanu> jophish_: someIOFunction :: (MonadIO m) => Foo -> m Bar
08:02:31 <axisofchange> Eduard_Munteanu: Thanks.. I think I'm learning. http://lpaste.net/97003
08:02:32 <Eduard_Munteanu> (monadbase is rather unneccessary for simpler stuff)
08:02:32 <jophish_> ah I see
08:03:16 <Eduard_Munteanu> jophish_: now, you have a   MonadIO m => MonadIO (StateT s m)   instance in   http://hackage.haskell.org/package/transformers-0.2.2.0/docs/Control-Monad-IO-Class.html#t:MonadIO
08:03:24 <Eduard_Munteanu> jophish_: so you can just call it directly
08:04:23 <Eduard_Munteanu> jophish_: and you can push liftIO to someIOFunction's definition. If you require a lot of lifting, MonadBase{,Control} redefines a bunch of IO functions in terms of a polymorphic IO-ish monad.
08:04:45 <jophish_> Eduard_Munteanu: Most of the functions are interfacing with OpenGL
08:04:58 <jophish_> I think I can structure this so I'll only need liftIO a couple of times anyway
08:05:55 <Eduard_Munteanu> jophish_: it's nicer to keep your monad stack polymorphic anyway
08:06:32 <Eduard_Munteanu> myFunction :: (MonadIO m, MonadState SomeState m) => Foo -> m Bar
08:06:53 <jophish_> that does look nicer
08:06:57 <countoren_> hello
08:07:00 <countoren_> im trying to build yesod app , and i want a good secure auth system, i thought about not to store passwords in my server and to do the auth with something like firebase . any suggestions/opinions??
08:07:40 <Eduard_Munteanu> If you need all constraints very often, it's possible to define   type MonadJophish m = (MonadIO m, MonadState SomeState m)   with ConstraintKinds.
08:08:49 <Eduard_Munteanu> So you can just say   fun :: MonadJophish m => Foo -> m Bar
08:10:00 <Eduard_Munteanu> I sometimes write   MonadFoo m => A -> io B  if MonadFoo is IO-ish.
08:10:04 <Eduard_Munteanu> Er.
08:10:13 <Eduard_Munteanu> MonadFoo io => A -> io B
08:14:51 <teneen> how can I run a shell command from haskell?
08:15:02 <Eduard_Munteanu> teneen: see System.Process
08:15:17 <bennofs> @hoogle runProcess
08:15:18 <lambdabot> System.Process runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
08:15:36 <Eduard_Munteanu> runProcess doesn't use the shell though.
08:16:01 <lilred> anyone here into intuitionistic logic? I'm trying to encode an union type A|B as a sigma(x:2) type
08:16:01 <bennofs> @hoogle system
08:16:01 <lambdabot> System.Process system :: String -> IO ExitCode
08:16:02 <lambdabot> System.Cmd system :: String -> IO ExitCode
08:16:02 <lambdabot> package system-argv0
08:16:04 <Eduard_Munteanu> runCommand :: String -> IO ProcessHandle
08:17:14 <benmachine> lilred: I'm not very good at it but I've seen that done in Agda
08:17:23 <teneen> can the first argument to runProcess be a plain command?
08:17:23 <Eduard_Munteanu> lilred: don't you mean sigma 2 x?
08:17:34 <teneen> or does it have to be an executable file?
08:17:40 <lilred> Eduard_Munteanu: I'm not yet aware of any standardized notation :P
08:17:53 <Eduard_Munteanu> teneen: file... see runCommand instead
08:18:00 <benmachine> Eduard_Munteanu: I assumed they meant Σ (x : 2) (λ x → if x then onething else theother)
08:18:09 <lilred> benmachine: EXACTLY
08:18:13 <Eduard_Munteanu> Ah, ok.
08:18:44 <lilred> HoTT uses the recursor over booleans
08:18:44 <Eduard_Munteanu> lilred: you can't do sigma in Haskell though
08:19:04 <lilred> Eduard_Munteanu: yeah, my apologies, I only ask here because the other channels I know are dead
08:19:04 <benmachine> yeah when you say encode, what are you trying to encode it in?
08:19:11 <Eduard_Munteanu> You can write Exists, instead.
08:19:17 <Eduard_Munteanu> Ah.
08:20:15 <Eduard_Munteanu> benmachine: presumably encoding algebraic data type as sigma and pi
08:20:21 <Eduard_Munteanu> *types
08:20:36 <benmachine> Eduard_Munteanu: yes, but, like, in Agda, in some other dependently typed PL, or just in theory?
08:20:41 <lilred> in any case I've been suggested to use an if-then-else form on ##logic, which I initially excluded but hell let's do it
08:21:19 <Eduard_Munteanu> benmachine: theoretically, ITT gives you sigma and pi to work with at the very core
08:21:36 <lilred> yeah, you don't actually need sum and product types
08:22:03 <benmachine> Eduard_Munteanu: I don't feel that much affects my question
08:22:33 <lilred> I'm working in ILTT though so (A + B) and (Σ (x : 2) (if x then A else B)) are not directly equivalent
08:23:42 <benmachine> what does the L stand for?
08:24:43 <lilred> linear
08:24:44 <Eduard_Munteanu> lilred: Sigma 2 (Pi (x : 2) (f x)), if 'f' can match on 2's values, i.e. allow pattern-matching
08:25:08 <lilred> meaning that some functions "leak" when you call them
08:25:35 <lilred> and the arguments disappear from context
08:25:38 <Eduard_Munteanu> The above seems linear.
08:25:46 <lilred> yeah, thank you!
08:27:02 <Eduard_Munteanu> Without pattern-matching I'm not sure it's possible linearly.
08:27:14 <lilred> yeah I'm assuming pattern-matching of some kind
08:27:14 <benmachine> Eduard_Munteanu: I'm a little confused, insofar as I expect the second argument of a Sigma to be a function, but I expect Pi (x : 2) (f x) to be a type
08:27:17 <Eduard_Munteanu> I mean, if you use some sort of decidable equality type.
08:28:36 <Eduard_Munteanu> benmachine: that's  (x : 2) -> f x
08:28:49 <lilred> f being rec_2
08:28:57 <benmachine> Eduard_Munteanu: sure, that's also a type
08:29:06 <benmachine> it's a type of functions, not a function itself
08:29:19 <lilred> benmachine: pi types are functions :)
08:29:35 <Eduard_Munteanu> benmachine: it's a type function
08:29:57 <Eduard_Munteanu> benmachine: a function from values to types, more accurately
08:30:19 <Eduard_Munteanu> f : (x : 2) -> Set
08:30:25 <benmachine> Eduard_Munteanu: I would expect Pi (x : 2) (f x) : Set
08:31:19 <Eduard_Munteanu> benmachine: no, it's a function indeed because Sigma : (A : Set) -> (B : A -> Set) -> Set
08:31:44 <benmachine> Eduard_Munteanu: right, but I would expect B to be of the form λ x → some expression involving x that is a Set
08:31:51 <benmachine> not Pi x (blah)
08:32:15 <Eduard_Munteanu> benmachine: it is a lambda, e.g.  f False = A, f True = B  as the actual definition
08:32:30 <benmachine> λ (x : A) → (y : B x) : Π (x : A) (B x)
08:32:58 <Eduard_Munteanu> benmachine: Pi is just a name for (->) that makes it a binder explicitly.
08:33:39 <Eduard_Munteanu> benmachine: yes
08:33:52 <benmachine> Eduard_Munteanu: ho hum, syntax is needlessly confusing here because λ x → has an arrow that is not at all a pi arrow
08:34:33 <Eduard_Munteanu> benmachine: the arrow in the lambda is value-level, the one in the type is one level above
08:35:10 <benmachine> Eduard_Munteanu: okay, so here's my claim: the sigma type that gives you a sum type is Σ 2 (λ x → f x), whereas what you said was Σ 2 (Π (x : 2) (f x))
08:35:52 <Eduard_Munteanu> benmachine: oh, you're right
08:36:00 <benmachine> oh good :)
08:36:07 <Eduard_Munteanu> lilred: ^^
08:36:13 <benmachine> there was a lot of talking at cross-purposes that followed I think :P
08:36:43 <Eduard_Munteanu> Σ 2 f   would do too, if you don't want to involve lambdas.
08:37:02 <Eduard_Munteanu> (where f itself has the type I was wrongly mentioning above)
08:37:08 <lilred> I encoded it using rec_2
08:37:11 <lilred> AKA if-then-else
08:37:19 <benmachine> right
08:37:42 <benmachine> similar thing is done in passing near the bottom of this file https://github.com/pigworker/MetaprogAgda/blob/master/Basics.agda
08:37:47 <axisofchange> Eduard_Munteanu: Thanks so much for your help.
08:37:55 <benmachine> (line 70 onwards)
08:39:27 <lilred> I'm trying to encode x86 into an ILTT language so I can write assembly without screwing up
08:43:14 <dawik> > foldr (\x y -> y ++ show x) "" (reverse ([1..3]))
08:43:16 <lambdabot>  "123"
08:43:24 <Iceland_jack> Still!
08:43:40 * Iceland_jack shakes their head
08:43:41 <dawik> still what?
08:43:59 <Iceland_jack> > "123" -- ← this is still going on :)
08:44:01 <lambdabot>  "123"
08:44:06 <dawik> :D
08:46:14 <Lindrian> @fp f x = (5 – x) / 3
08:46:14 <lambdabot> Maybe you meant: wn v rc pl id faq do bf @ ? .
08:46:19 <Lindrian> @pl f x = (5 – x) / 3
08:46:19 <lambdabot> (line 1, column 6):
08:46:19 <lambdabot> unexpected " "
08:46:19 <lambdabot> expecting operator
08:46:26 <Lindrian> umm
08:46:28 <Iceland_jack> Lindrian: you need an expression
08:46:58 <Iceland_jack> @pl (\x -> (5 - x) / 3)
08:46:58 <lambdabot> (/ 3) . (-) 5
08:47:01 <Iceland_jack> Don't do that though :)
08:47:08 <Lindrian> i see
08:47:09 <Lindrian> okay
08:48:23 <dawik> what would be a nice practical example to start with? i'd like to do a program that handles arguments and maybe does some list magic on the input :)
08:48:44 <dawik> is that feasable? trivial?
08:48:45 <Iceland_jack> You can take a list of numbers and increment them by one
08:49:05 <Iceland_jack>     $ ./prog 1 2 3 4
08:49:05 <Iceland_jack>     2 3 4 5
08:49:24 <dawik> alright :)
08:49:25 <FreeFull> @pl f x = (5 - x) / 3
08:49:25 <lambdabot> f = (/ 3) . (-) 5
08:49:25 <Lindrian> Iceland_jack: im so insecure about the .
08:49:25 <Iceland_jack> @hoogle getArgs
08:49:25 <lambdabot> System.Environment getArgs :: IO [String]
08:49:26 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
08:49:27 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
08:49:33 <Iceland_jack> this should help dawik
08:49:51 <FreeFull> Lindrian: The problem was that you were using – instead of -
08:50:00 <Lindrian> FreeFull: thanks
08:50:08 <Iceland_jack> Lindrian: It's very simple really, if you see a '(f . g) x' that's equal to 'f (g x)'
08:50:28 <Iceland_jack> and if you see:
08:50:28 <Iceland_jack>     (f . g . h . i . j) x
08:50:28 <Iceland_jack> that's equal to
08:50:28 <Iceland_jack>     f (g (h (i (j x))))
08:50:47 <Lindrian> f = (/ 3) . (-) 5 <=> f = (/ 3) ((-) 5) ?
08:51:01 <Lindrian> doesnt look right
08:51:03 <Iceland_jack> Lindrian: no, because there is no argument there
08:51:32 <Iceland_jack> It's really
08:51:32 <Iceland_jack>     (/ 3) . ((-) 5)
08:51:40 <Lindrian> f = (/ 3) . (-) 5 <=> f x = (/ 3) ((-) 5 x) ?
08:51:46 <Lindrian> this would have been corect?
08:51:51 <Iceland_jack> Lindrian: yes
08:51:55 <Lindrian> i see
08:51:57 <FreeFull> ((/ 3) . (-) 5) x    is    ((/3) ((-) 5 x))
08:52:19 <Lindrian> thanks
08:52:33 <Iceland_jack> if you write
08:52:33 <Iceland_jack>     f x = g (h x)
08:52:33 <Iceland_jack> that's the same as
08:52:33 <Iceland_jack>     f x = (g . h) x
08:52:38 <Iceland_jack> which is the same as
08:52:38 <Iceland_jack>     f = g . h
08:53:40 <Iceland_jack> The thing that's probably confusing you is that the operands look ‘messy’
08:54:00 <Iceland_jack> (/ 3) and ((-) 5) instead of ‘a’ and ‘b’
08:54:20 <Lindrian> right
08:54:24 <rasfar> So actually f = (/ 3) . (-) 5 <=> f x = (/ 3) ((-) 5 x) is correct?
08:54:37 <rasfar> oh nm, misread scrollback
08:55:07 <Iceland_jack> > (/ 3) ((-) 5 10)
08:55:07 <Iceland_jack> > 3 / (5 - 10)
08:55:09 <lambdabot>  -0.6
08:55:09 <lambdabot>  can't find file: L.hs
08:55:22 <Iceland_jack> > 3 / (5 - 10)
08:55:23 <lambdabot>  -0.6
08:56:11 <Iceland_jack> It's useful to think of computations as series of function compositions
08:56:17 <Lindrian> does it write the input to file?
08:56:21 <Lindrian> the bot
08:56:40 <Iceland_jack> I believe so
08:56:45 <Lindrian> why??
08:56:47 <Lindrian> http://pepijndevos.nl/images/mind-blown.gif
08:57:11 <Iceland_jack> > let revWords xs = unwords (map reverse (words xs)) in revWords "this is a test"
08:57:12 <lambdabot>  "siht si a tset"
08:57:26 <Iceland_jack> Can be written as:
08:57:26 <Iceland_jack> > let revWords = unwords . map reverse . words in revWords "this is a test"
08:57:27 <lambdabot>  "siht si a tset"
08:57:30 <Hafydd> I'd imagine because the authors were satisfied with an inelegant hack.
08:57:40 <rasfar> but f x = (/ 3) . ((-) 5) x doesn't work, that's the gotcha
08:57:55 <Iceland_jack> It does if you parenthesise it proper
08:58:03 <Lindrian> Iceland_jack: right. I need to get to know $ and . better
08:58:05 <rasfar> @ let f x = (/ 3) . ((-) 5) $ x in f 2
08:58:18 <Iceland_jack> > let f x = ((/ 3) . ((-) 5)) x in f 10
08:58:19 <lambdabot>  -1.6666666666666667
08:58:20 * hackagebot haskoin-crypto 0.0.1.1 - Implementation of Bitcoin cryptographic primitives.  http://hackage.haskell.org/package/haskoin-crypto-0.0.1.1 (PhilippeLaprade)
08:58:29 <Iceland_jack> > let f = (/ 3) . (-) 5) in f 10
08:58:30 <lambdabot>  <hint>:1:22: parse error on input `)'
08:58:33 <rasfar> > let f x = (/ 3) . ((-) 5) $ x in f 2
08:58:34 <lambdabot>  1.0
08:58:34 <Iceland_jack> > let f = (/ 3) . (-) 5 in f 10 -- oops
08:58:35 <lambdabot>  -1.6666666666666667
08:59:13 <Iceland_jack> Lindrian: The definitions are very simple, you just need to develop an intuition about them
08:59:15 <Iceland_jack> @src (.)
08:59:15 <lambdabot> (f . g) x = f (g x)
08:59:15 <lambdabot> NB: In lambdabot,  (.) = fmap
08:59:17 <Iceland_jack> @src ($)
08:59:17 <lambdabot> f $ x = f x
08:59:33 <Iceland_jack> ($) doesn't do anything!
08:59:33 <Lindrian> Iceland_jack: yeah
08:59:47 <Iceland_jack> You can think of it as just adding parentheses
08:59:53 <rasfar> shouldn't that be  f $ x = f (x)  ?
08:59:57 <Iceland_jack> why?
09:00:07 <nooodl> f (x) = f x
09:00:16 <Lindrian> Iceland_jack: would it work to use $ instead of . in your revWords?
09:00:18 <rasfar> if x was any more general expression, the parentheses would be needed
09:00:26 <ion> More specifically, (x) = x
09:00:42 <Iceland_jack> Lindrian: Sure:
09:00:42 <Iceland_jack> > let revWords xs = unwords $ map reverse $ words xs in revWords "this is a test"
09:00:43 <lambdabot>  "siht si a tset"
09:00:50 <Iceland_jack> but then you have to specify the argument
09:01:00 <Iceland_jack>     a $ b $ f x = a (b (f x))
09:01:12 <ion> this test is siht
09:01:17 <nooodl> rasfar: these aren't C preprocessor macros! parentheses are sane
09:01:31 <rasfar> because translating  f $ x  as  f x  is less informative? the problem with too-trivial examples.
09:01:38 <Lindrian> so confusinggggggggg
09:01:39 <Iceland_jack> rasfar: no?
09:01:42 <Lindrian> why would both work
09:01:49 <Iceland_jack> Lindrian: Look at the definition of ($), it's very simple
09:01:51 <ion> rasfar: Would translating it to (f) (x) be more informative?
09:02:07 <rasfar> Iceland_jack: "no" a more general expression than x required parentheses in the translation?
09:02:19 <nooodl> a $ b $ f x = a (b (f x)) = (a . b . f) x
09:02:21 <Iceland_jack> rasfar: that's the point, it's not a translation
09:02:26 <Iceland_jack> it takes an expression as an argument
09:02:34 <Lindrian> nooodl: thanks
09:02:42 <Iceland_jack> If you have:
09:02:42 <Iceland_jack>     (lot's of things) (lot's of other things)
09:02:42 <Iceland_jack> you can insert a ($) between them to reduce the number of parentheses
09:02:42 <Iceland_jack>     lot's of things $ lot's of other things
09:02:46 <rasfar> f $ x = f (x) tells you something about grouping, if we think of x as a general expression (not an atom or whatever you'd call that)
09:03:12 <Yuu-chan> A silly lens question: how to use a lens as a simple value? E.g.  secondField %= func {-some operator here -} firstField
09:03:16 <teneen> is there something like printf but which forms a string instead of printing it?
09:03:16 <Iceland_jack>     f $ x = f (x)
09:03:17 <Iceland_jack> is an identical defintion to
09:03:17 <Iceland_jack>     f $ x = f x
09:03:21 * hackagebot SFML-control 0.2.0.2 - Higher level library on top of SFML  http://hackage.haskell.org/package/SFML-control-0.2.0.2 (AlfredoDiNapoli)
09:03:24 <Iceland_jack> teneen: Yes, printf.
09:03:27 <rasfar> because the $ (in translation) implies the addition of parentheses to the right -- except it seems in certain too-trivial examples. That's all I'm trying to say.
09:03:27 <nooodl> Yuu-chan: ^. i think
09:03:35 <Iceland_jack> printf both forms a string and prints it
09:03:35 <teneen> Iceland_jack: how?
09:03:37 <merijn> teneen: printf can print and produce strings, afaik. But it's kinda ugly
09:03:38 <edwardk> just use ^. to read it
09:03:50 <Iceland_jack> > printf "'tis is a %s\n" "test" :: String
09:03:51 <lambdabot>  "'tis is a test\n"
09:04:03 <edwardk> if ts part of what you're editing, otherwise, grab it with use above
09:04:20 <teneen> Iceland_jack: Ok, great! thanks
09:04:21 <edwardk> ff <- use firstField; secondField %= func ff
09:04:22 <merijn> rasfar: It doesn't imply parentheses on the right, the thing about ($) that matters is its fixity. i.e. ($) has fixity 0, where as function application has fixity 10, hence why ($) does what it does
09:04:36 <Iceland_jack> teneen: It can also be an IO action!
09:04:39 <Iceland_jack> > printf "'tis is a %s\n" "test" :: IO ()
09:04:40 <lambdabot>  <IO ()>
09:04:46 <Iceland_jack> So you can apply printf to a printf
09:04:51 <Iceland_jack> > printf (printf "'tis is a %s\n" "test" :: String) :: IO ()
09:04:52 <lambdabot>  <IO ()>
09:04:58 <rasfar> ah okay, thanks merijn. perhaps fixity is represented by addition of parentheses in some compilers pre-pass... :-p
09:05:01 <Iceland_jack> > printf (printf (printf "'tis is a %s\n" "test" :: String) :: String) :: IO ()
09:05:02 <lambdabot>  <IO ()>
09:05:49 <merijn> rasfar: i.e. fixity specifies how tightly things bind, the relative fixity of (*) and (+) is why "2*4+1" doesn't need parentheses to behave like the math expression, because * binds tighter
09:06:08 <merijn> rasfar: 0 being the lowest fixity means ($) is the least tight binding operator possible
09:06:11 <rasfar> but we're speaking of translations...
09:06:12 <Iceland_jack> There is no compiler ‘pre-pass’ that adds parentheses
09:06:19 <Iceland_jack> rasfar: No we're not
09:06:32 <rasfar> that may depend on the compiler; although I expect most would use the AST
09:06:33 <Yuu-chan> nooodl, edwardk: could you please show how to write it with ^. ?
09:06:33 <merijn> rasfar: Compilers don't have "parentheses" in them, they're just ASTs
09:06:34 <Iceland_jack>     f $ x = f x
09:06:34 <Iceland_jack> is a function, not a translation
09:06:35 <nooodl> f $ x = f (x) isn't some kind of expansion rule
09:06:40 <nooodl> it's an actual definition of $
09:06:51 <merijn> rasfar: You'd use the AST to group, having AST nodes for parentheses is silly
09:06:58 <nooodl> (of course the 0 fixity is the important part)
09:07:20 <merijn> ($) is a function in the same way (.), (++) or (*) are functions
09:07:39 <merijn> > let ($) = const in 1 $ 2 -- you can even define your own version
09:07:41 <lambdabot>  1
09:07:42 <rasfar> but if the parse tree has them (due to desugaring of fixity to parentheses), then the AST can remove them, that seems reasonable and safe proceeding
09:08:32 <Iceland_jack> You can just as well define ($) as
09:08:32 <Iceland_jack>     infixr 0 `apply`
09:08:32 <Iceland_jack>     f `apply` x = f x
09:08:53 <nooodl> i don't know much about parsing stuff but desugaring fixity to parentheses sounds silly
09:09:01 <skypers> hey, when dealing with ErrorT
09:09:08 <skypers> if I want to run IO actions
09:09:12 <skypers> I need lift them up, right?
09:09:17 <Iceland_jack> yes
09:09:17 <skypers> or MonadIO / liftIO
09:09:19 <merijn> skypers: liftIO is your friend
09:09:19 <skypers> hm
09:09:26 <rasfar> np, i'm just putting my neck out just to see where it goes
09:09:31 <skypers> I think I just should use ErrorT
09:09:34 <skypers> up to now
09:09:43 <Iceland_jack> rasfar: Nothing wrong with that :)
09:09:47 <skypers> I have plenty of functions that return IO (Maybe a)
09:09:55 <skypers> and it’s awful to handle
09:10:02 <merijn> skypers: If your base monad explicitly involves IO, you don't even need the MonadIO constraint to use liftIO
09:10:12 <skypers> yeah well
09:10:14 <nooodl> hmm i should really get into the monad transformer thing but i feel like i've never "needed" them
09:10:18 <skypers> I defined my monad like :
09:10:27 <skypers> type M = ErrorT MyErrorType IO
09:10:35 <merijn> skypers: Yeah, liftIO should just work then
09:10:51 <skypers> nooodl: I can’t stop using them now
09:10:53 <skypers> for instance
09:11:05 <skypers> StateT is _very_ useful imho
09:11:19 <countoren_> Hello , im trying to build yesod app , and i want a good secure auth system, i thought about not to store passwords in my server and to do the auth with something like firebase . any suggestions/opinions??
09:12:02 <merijn> nooodl: I use them for stuff like specifying IO actions that have acces to a specific config data structure "ReaderT MyConfig IO a" is a decent type for callbacks/hooks
09:12:56 <aristid> countoren_: how about something like this? http://hackage.haskell.org/package/pwstore-fast
09:14:27 <dawik> yay i did it :D
09:14:29 <dawik> http://vpaste.net/a1187
09:15:01 <nooodl> i wonder how often i've run into situations that would've been easier to deal with using monads i'm not comfortable with like Reader or Writer or State
09:15:05 <dawik> anything off with that Iceland_jack?
09:15:37 <Iceland_jack> dawik: looks OK to me :)
09:15:45 <Iceland_jack> increase s (+ 1) btw
09:15:46 <Iceland_jack> *is
09:16:10 <dawik> is it a built-in function?
09:16:12 <Iceland_jack> no
09:16:15 <Iceland_jack> and also print should give you [2,3,4] for ["1", "2", "3"]
09:16:31 <Iceland_jack> but you should get: 2 3 4
09:16:55 <rasfar> what's the term for "non-monadic" code? so we say "combinator-style" (would that automatically imply non-monadic, in our common parlance?)
09:16:59 <Iceland_jack> dawik: It's called a ‘section’, if you have a function (+) you can form a section as:
09:16:59 <Iceland_jack>     (+ n) or
09:16:59 <Iceland_jack>     (n +)
09:17:04 <rasfar> *do
09:17:16 <Iceland_jack> Where (+ n) = \x -> x + n
09:17:24 <Iceland_jack> and   (n +) = \x -> n + x
09:17:31 <dawik> Iceland_jack: can you give an example? :)
09:17:35 <Iceland_jack> sure! (+1) ;)
09:17:44 <nooodl> (+ 1) = (\x -> x + 1)
09:17:52 <rasfar> (or you can generalise to free sections...)
09:17:59 <Iceland_jack>       increase v = v + 1
09:17:59 <Iceland_jack>     = increase = \v -> v + 1
09:17:59 <Iceland_jack>     = increase = (+ 1)
09:18:39 <Yuu-chan> http://lpaste.net/5840738468350656512 I still don't get it :(
09:18:51 <countoren_> aristid: this is to save and encrypt the password so you are suggesting to save the passwords on my server? wont it be safer to save and auth with 3rd party server?
09:19:28 <edwardk> rasfar: i'd say "non-monadic" is a pretty good term for it ;)
09:19:36 <Iceland_jack> dawik: also you'd like to turn it into strings
09:19:58 <Iceland_jack> so you might write something like:
09:19:58 <Iceland_jack>     map (show . (+1) . read) args
09:20:06 <rasfar> edwardk: thanks. however, that seems to make monadic code the more fundamental, and I don't quite agree with that.
09:20:59 <edwardk> well, i'd say if your type admits a monad then it isn't much of a virtue to deprive it of that structure, but it isn't always the structure you will be using for everything
09:21:04 <rasfar> or can we view non-monadic functions as a special case of some trivial monad? er... I don't think so, you still have that "m a" in the type
09:21:17 <Iceland_jack> rasfar: Identity monad?
09:21:43 <rasfar> @yahoo "identity monad"
09:21:43 <lambdabot> Unknown command, try @list
09:21:49 <rasfar> @hayoo "identity monad"
09:21:49 <lambdabot> Unknown command, try @list
09:21:50 <Iceland_jack> > runIdentity (liftM2 (+) (Identity 5) (Identity 105))
09:21:51 <lambdabot>  110
09:21:53 <Iceland_jack> > 5 + 105
09:21:54 <lambdabot>  110
09:22:11 <rasfar> @src Identity
09:22:11 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
09:23:16 <nooodl> hm... the whole (f⁻¹ . g . f) pattern shows up quite a lot doesn't it
09:23:23 <Iceland_jack> nooodl: It does
09:23:24 <Iceland_jack> dawik: also recall the function ‘unwords’ which takes a list of words and puts spaces between them
09:23:31 <rasfar> i just had a whole schwack of code go monadic, then I changed it back to "non-monadic" (which I tend to prefer). due to trying to use randomRIO, then realising it has some sort of (known) space leak issue.
09:23:54 <nooodl> i've considered "generalizing" a bunch of cases like that into i.e. onTranspose f = transpose . f . transpose
09:24:13 <rasfar> now I'm back to randomR and threading through StdGen, which is also not quite ideal
09:24:17 <nooodl> similarly "onF" for other fs. but that'd probably be harder to read in the end
09:24:19 <dawik> Iceland_jack: oh
09:24:44 <FreeFull> nooodl: That pattern reminds me of functors
09:25:00 <dawik> damn, is `increase v = (+ 1)` supposed to evaluate?
09:25:09 <Iceland_jack> dawik: You should drop the v
09:25:22 <dawik> ah
09:25:51 <Iceland_jack> dawik: Another example of a section is adding exclamation marks
09:25:51 <Iceland_jack>     exclam string = string ++ "!!!"
09:25:59 <Iceland_jack> which can be turned into
09:25:59 <Iceland_jack>     exclam = (++ "!!!")
09:26:25 <rasfar> > (2,,4) 3
09:26:26 <lambdabot>  (2,3,4)
09:26:29 <Iceland_jack> so there's no need to give explicit names to something that can be written as (+ 1) :)
09:27:17 <dawik> Iceland_jack: nice!
09:27:24 <Iceland_jack> > unwords ["2", "3", "4"]
09:27:25 <lambdabot>  "2 3 4"
09:27:29 <Iceland_jack> > putStrLn (unwords ["2", "3", "4"])
09:27:30 <lambdabot>  <IO ()>
09:27:42 <henk_> is there a more elegant way of using default arguments? right now im using http://lpaste.net/97006 and then run it using algorithm 2 []
09:28:19 <Kaidelong> that (f⁻¹ . g . f) patterns seems like it could use a name especially since on groupoids it effectively allows you to use any isomorphism on an object on any other connected object by walking the graph there and back
09:28:34 <Iceland_jack> Kaidelong: There is name for it in group theory :)
09:28:38 <Iceland_jack> or at least a similar thing
09:28:47 <Iceland_jack> dawik: The next challenge can be to take a list of files as an argument and counting the number of characters + file name
09:29:10 <dawik> ok! :D
09:29:23 <Iceland_jack>     $ ./prog a.c b.hs c.cl
09:29:23 <Iceland_jack>     a.c: 535
09:29:23 <Iceland_jack>     b.hs: 353
09:29:23 <Iceland_jack>     c.cl 2010
09:29:36 <rasfar> henk_: you could put the default list in a where clause, that's about it I think?
09:29:47 <Yuu-chan> Hewp me pwease
09:30:33 <rasfar> edwardk, can you help Yuu-chan? http://lpaste.net/5840738468350656512
09:30:58 <rasfar> it's a lens question (not big code)
09:31:03 <Iceland_jack> http://lpaste.net/97006
09:31:05 <d3lxa> how can I add type constraint in a do-notation? I'm trying to debug some code
09:31:07 <Iceland_jack> https://en.wikipedia.org/wiki/Inner_automorphism ← oops
09:31:24 <edwardk> rasfar: i answered yuu-chan above
09:31:30 <Iceland_jack>     f ∶ G → G
09:31:30 <Iceland_jack>     f x = a⁻¹xa
09:31:56 <rasfar> oh! I'm sorry. I'll read that...
09:32:09 <edwardk> replace  field %= M.insert cell (head $ view tiles)    with t <- use tiles; field %= M.insert cell (head t)
09:32:20 <Yuu-chan> I found I can add tiles' <- use tiles, but I wouldn't want an excessive line
09:32:47 <Iceland_jack> d3lxa: What do you mean?
09:32:57 <Yuu-chan> Oh, ok. Thank you Edward!
09:33:05 <Iceland_jack> You can do
09:33:05 <Iceland_jack>     do foo <- (mfoo :: IO String); …
09:33:24 <d3lxa> Iceland_jack: making sure some variable is of the type I think: do { val <- return 15; val :: Int }
09:33:35 <Iceland_jack> Well you can't do that d3lxa
09:33:46 <Iceland_jack> since the final value in a do-block must be monadic
09:33:57 <lingxiao> hey all, I;m reading through some project and I'm getting confused by some record syntax I've never seen before
09:34:04 <d3lxa> Iceland_jack: fine, then: do { val <- return 15; val :: Int; return val }
09:34:15 <Iceland_jack> You can do:
09:34:15 <Iceland_jack>     do val ← return 15
09:34:15 <Iceland_jack>        return (val ∷ Int)
09:34:23 <lingxiao> first define some data type: https://gist.github.com/anonymous/6961c35c704c97ca56fe
09:34:30 <Iceland_jack> Or
09:34:30 <Iceland_jack>     do val ← return 15
09:34:30 <Iceland_jack>        return val ∷ Monad m ⇒ m Int
09:34:37 <d3lxa> Iceland_jack: so you need to add noise to your in-place code?
09:34:45 <lingxiao> then there's an operation that modifies the data type:
09:34:47 <lingxiao> modClassEnv :: ClassEnv -> Id -> Class -> ClassEnv
09:34:47 <lingxiao> modClassEnv ce i c  = ce { classes = \j -> if i == j then Just c else classes ce j }
09:34:49 <hattusili_III> hey, i'm trying to use the http-conduits library, and i can't figure out how to get at the ByteString of the response body to do some processing on it. this is all i have so far : https://gist.github.com/MarkJr94/7975626
09:34:52 <dawik> Iceland_jack: which lib should i be using?
09:34:59 <Iceland_jack> d3lxa: You can also add it to your type signature? This should only be for testing
09:35:08 <Iceland_jack> Haskell is probably able to infer it
09:35:09 <rasfar> > do (v::Int) <- return 15
09:35:11 <lambdabot>  The last statement in a 'do' block must be an expression
09:35:11 <lambdabot>    (v :: Int) <- return 15
09:35:20 <lingxiao> and this part: "ce { ... }" really just confused me a lot, could someone explain?
09:35:25 <Iceland_jack> @hoogle readFile
09:35:25 <lambdabot> Prelude readFile :: FilePath -> IO String
09:35:25 <lambdabot> System.IO readFile :: FilePath -> IO String
09:35:25 <lambdabot> Data.ByteString.Lazy.Char8 readFile :: FilePath -> IO ByteString
09:35:29 <Iceland_jack> dawik: ↑
09:35:31 <d3lxa> Iceland_jack: ok, i'll try :) anyway
09:35:32 <dawik> ty
09:35:37 <Iceland_jack> You're welcome
09:35:55 <rasfar> > do { (v::Int) <- return 15; return v }
09:35:56 <lambdabot>  No instance for (GHC.Show.Show (m0 GHC.Types.Int))
09:35:56 <lambdabot>    arising from a use of `M4800776487957018054575.show_M4800776487957018054575'
09:35:56 <lambdabot>  The type variable `m0' is ambiguous
09:35:56 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:35:56 <lambdabot>  Note: there are several potential instances:
09:36:15 <Yuu-chan> edwardk: `view' can be used when the function gets the record as an argument, not via state, right?
09:36:28 <rasfar> > do { (v::Int) <- return 15 :: IO Int; return v }
09:36:29 <lambdabot>  <IO Int>
09:36:40 <edwardk> Yuu-chan: correct, use works with state.
09:36:50 <d3lxa> Iceland_jack: btw it's because the inferer may screw up that I try to annotate type, to see where it's wrong
09:37:02 <edwardk> gets (view foo) = use foo
09:37:07 <rasfar> > do { (v::Int) <- return 15; return v } :: IO Num
09:37:08 <lambdabot>  Expecting one more argument to `GHC.Num.Num'
09:37:16 <Yuu-chan> Ok. Thank you for your wonderful library!
09:37:16 <Iceland_jack> yeah but then it's not noise d3lxa :) it's part of development
09:37:17 <d3lxa> rasfar: oh really? cool
09:37:21 <rasfar> > do { (v::Int) <- return 15; return v } :: IO Integral
09:37:22 <lambdabot>  Expecting one more argument to `GHC.Real.Integral'
09:37:25 <edwardk> happy to help =)
09:37:38 <Iceland_jack> rasfar: Integral is a type class, not a type
09:37:55 <edwardk> if you have trouble and get your questions ost in the noise here, feel free to ask on #haskell-lens as well, its a bit lower traffic
09:37:57 <rasfar> can you suggest a type to put there?
09:38:02 <Iceland_jack> > do { v <- return 15; return v } :: Integral i => IO i
09:38:03 <lambdabot>  <IO Integer>
09:38:35 <rasfar> > do { (v::Int) <- return 15; return v } :: Integral i => IO i
09:38:36 <lambdabot>  Could not deduce (i1 ~ GHC.Types.Int)
09:38:36 <lambdabot>  from the context (GHC.Real.Integral i)
09:38:36 <lambdabot>    bound by the inferred type of
09:38:36 <lambdabot>             it :: GHC.Real.Integral i => GHC.Types.IO i
09:38:36 <lambdabot>    at Top level
09:38:44 <Iceland_jack> rasfar: You said it's an Int
09:38:46 <d3lxa> rasfar: it says illegal type signature, Perhaps you intended to use -XScopedTypeVariables
09:38:52 <Iceland_jack> > do { (v :: Integer) <- return (15 :: Integer) :: IO Integer; return (v :: Integer) :: IO Integer } :: IO Integer
09:38:53 <lambdabot>  <IO Integer>
09:39:17 <rasfar> d3lxa: what I usually do is put the signature on the right of <- (at end of the line)
09:39:18 <Iceland_jack> d3lxa: You can do: :set -XScopedTypeVariables
09:39:22 <rasfar> no extra parentheses needed
09:39:48 <rasfar>  but you need to write ":: IO T" where T is the type on the left of <-
09:40:13 <d3lxa> Iceland_jack: sometimes the right part of -> is quite long… so I'm unsure on this
09:40:20 <Lindrian> Why is replicate n x = take n [x ..] not a sufficient definition for the prelude version of replicate?
09:40:24 <jophish__> Say I have a data type, Vertex = Vertex (Linear.V3 Float) (Linear.V3 Float) (Linear.V2 Float); position, normal, uv for example. What's the nicest way of writing a list of these to a memory location, so it resembles struct vector{float[3];float[3];float[2]} buffer[N];
09:40:26 <Iceland_jack> Do you mean the right part of <- d3lxa?
09:40:34 <d3lxa> Iceland_jack: oh yes sorry <-
09:40:48 <Iceland_jack> You rarely need to annotate so I don't see what the problem is
09:40:52 <rasfar> Iceland_jack: yeah, I'm just trying to get more comfortable with the interactions of types, of how unification can resolve "subtypes" where class constraints are involved etc...
09:41:08 <Iceland_jack> if it's only tentatively to help you figuring the types out then it shouldn't matter
09:41:19 <dawik> hmm. how to split an IO string to a string? i would expect length to still return the bytes
09:41:29 <dawik> split IO string to list*
09:41:34 <rasfar> d3lxa: I like your technique of using v::Int on its own line, I didn't know you could do that
09:41:50 <Iceland_jack> dawik: lenght returns the number of characters
09:41:54 <Iceland_jack> if applied to Text or String
09:41:57 <Iceland_jack> *length
09:42:20 <rasfar> how "shouldn't matter"?
09:42:31 <d3lxa> rasfar: actually I think you can't, i've tested with this: http://sprunge.us/SDWA
09:42:45 <Iceland_jack> rasfar: If you're going to remove the types 5 minutes later it doesn't matter if it looks ugly
09:42:57 <d3lxa> Iceland_jack: oh that doesn't work, the right part is in a monad, thus it's too complicated :X
09:43:14 <Iceland_jack> d3lxa: The right part of what exactly?
09:43:15 <rasfar> oh I see! haha. / what gets me is how I get into trouble by specifying too many type sigs.
09:43:26 <d3lxa> Iceland_jack: thing <- otherthing
09:43:28 <rasfar> then remove them and everything is fine ... except I haven't learned anything
09:43:40 <Iceland_jack> well the right side must be a monadic value :)
09:43:41 <ij> Why doesn't haskell not let me not constrain the "i" type here: visualize :: CArray i (Complex Double) -> [Double]
09:43:43 <ij> visualize = map (realPart . abs) . elems
09:43:59 <bfootedb> I've caught bits and pieces of a conversation about Taurus Capital, the prop shop in Tokyo, and I was wondering, does anyone know if theyl trading interns this summer from
09:44:57 <bfootedb> That last part should read: Does anyone know if they'll take undergrads as trading interns this summer?
09:44:57 <Iceland_jack> d3lxa: You can do
09:44:57 <Iceland_jack>     do …
09:44:57 <Iceland_jack>        line ∷ String ← getLine
09:44:57 <Iceland_jack>        …
09:44:59 <d3lxa> rasfar: any idea how to make it work, the sprunge upthere?
09:45:00 <Iceland_jack>  
09:45:27 <d3lxa> Iceland_jack: ok I can give a try -XScopedTypeVariables
09:45:59 <katieg> dam this bitch is hot live cam http://instaflurt.com/bella_4u/
09:46:02 <rasfar> I think -XScopedTypeVariables is pretty safe, right?
09:46:18 <Iceland_jack> d3lxa: but if you don't want to you can easily do:
09:46:18 <Iceland_jack>     do …
09:46:18 <Iceland_jack>        line ← getLine ∷ IO String
09:46:18 <Iceland_jack>        …
09:46:21 <Iceland_jack>  
09:46:37 <Eduard_Munteanu> rasfar: yes
09:46:45 <d3lxa> Iceland_jack: very noisy, because I have 4 stacked monads (using yesod here)
09:47:03 <Iceland_jack> First of all d3lxa, do you have top-level type annotations?
09:47:15 <ill_logic_> Hello, does anybody know about developing on ARM? I'm reading that ghci is supposed to come with ghc 7.4.2. I just upgraded my Raspberry Pi to Debian Jesse and got ghc 7.6.3, and it's still not there.
09:47:46 <donri> ill_logic_: ghci on arm isn't supported before 7.8 IIRC
09:47:47 <rasfar> d3lxa: if you go  let val = val :: Int   it will work
09:47:53 <jmcarthur> ill_logic_: i don't think ghci was supported on ARM for those versions. i believe it shoudl be in 7.8 once it's out though
09:48:11 <rasfar> the -XScopedTypeVariables won't help as you have a type error with   val :: Int
09:48:29 <ill_logic_> wtf, I read multiple places ( http://www.haskell.org/pipermail/haskell-cafe/2013-February/106222.html ) that it came with 7.4.2
09:48:34 <ill_logic_> do I have to install specifically 7.4.2 ?
09:48:42 <d3lxa> rasfar: ahah! nice finding
09:49:09 <rasfar> thanks d3lxa
09:49:35 <jmcarthur> ill_logic_: the very next email in that thread claims ghci is not included
09:49:39 <d3lxa> rasfar: but there is a problem, it always type-checks… hum
09:50:10 <ill_logic_> jmcarthur: The next email references 7.4.1
09:50:12 <d3lxa> rasfar: I think it's because it ignore the last defined variable, only considering itself recurisevyl
09:50:18 <ill_logic_> My understanding was specifically about 7.4.2
09:50:26 <rasfar> wow, strange...
09:50:36 <d3lxa> rasfar: so the fix should be to rename the left variable
09:50:56 <jmcarthur> ill_logic_: in any case, my understanding has always been that ghc doesn't officially support arm until 7.8
09:51:06 <d3lxa> rasfar: no it's normal, if you know how haskell works, but yep that works cool, my left variable is _
09:51:17 <ill_logic_> jmcarthur: ghc altogether? or did you mean ghci
09:51:20 <merijn> jmcarthur: Yeah, that's right
09:51:23 <rasfar> right; if you place a demand on it, you'll get the type error:
09:51:25 <merijn> ill_logic_: GHC all together
09:51:25 <rasfar>     val <- return 15
09:51:25 <rasfar>     let val = val :: String
09:51:25 <rasfar>     print "Hello" ++ show val
09:51:46 <merijn> ill_logic_: There is (as you've noticed) buggy support in earlier versions, but ARM is not yet officially supported
09:51:46 <Iceland_jack> rasfar: do : let val' = val
09:51:51 <Iceland_jack> otherwise you're shadowing it
09:51:54 <ill_logic_> I wish the documentation or communications were more clear on that. Maybe it says that somewhere but I never noticed it.
09:52:12 <rasfar> the val' val'' val_' ... thing is one of the things that puts me off monads actually
09:52:25 <d3lxa> rasfar: so this one http://sprunge.us/UYCO works fine, unintrusive and easy to maintain :)
09:52:25 <Iceland_jack> rasfar: Has absolutely nothing to do with monads
09:52:26 <ion> rasfar: Function application binds tighter than any operator. That parses as (print "Hello") ++ (show val)
09:52:29 <Iceland_jack> :t do val <- return 15; let { val' = val :: String }; undefined
09:52:30 <lambdabot>     Could not deduce (Num String) arising from the literal `15'
09:52:30 <lambdabot>     from the context (Monad m)
09:52:30 <lambdabot>       bound by the inferred type of it :: Monad m => m b at Top level
09:52:36 <Iceland_jack> :t do val <- return 15; let { val' = val :: Int }; undefined
09:52:36 <lambdabot> Monad m => m b
09:52:38 <rasfar> i find, in my experience, that it does
09:52:55 <rasfar> ion: right, oops
09:52:56 <d3lxa> Iceland_jack: any comment on the given one, no extension needed, minimal noise and clear
09:53:01 <merijn> ill_logic_: This seems to be the best source of info: https://ghc.haskell.org/trac/ghc/wiki/Platforms
09:53:09 <Iceland_jack> d3lxa: on which given one?
09:53:24 <Iceland_jack> rasfar: You may wrongly associate it with monads when you're talking about shadowing
09:53:26 <d3lxa> Iceland_jack: http://sprunge.us/UYCO I hope _ won't have problem in pattern matching
09:53:27 <benmachine> do-notation is actually one of the few places you can easily make non-recursive bindings
09:53:29 <merijn> ill_logic_: So it's currently tier 2 supported, with features missing
09:53:33 <Iceland_jack> maybe you mean the do-notation but
09:53:43 <Iceland_jack> that's a separate matter
09:53:54 <merijn> ill_logic_: I believe it should move to tier 1 support in 7.8, but I'm not entirely sure
09:53:58 <Iceland_jack> d3lxa: yes that works
09:54:06 <rasfar> ah! using _ to discard the value, no need for perfunctory identifiers to be invented, and no shadowing. sweet.
09:54:21 <merijn> ill_logic_: ghci explicitly being listed as unsupported at the moment
09:54:26 <d3lxa> Iceland_jack: not sure how ghc consider this _ variable though
09:54:33 <Iceland_jack> It just ignores it
09:54:42 <ill_logic_> Well, somebody out there was able to get it working.
09:54:46 <rasfar> d3lxa: it's perfectly safe, it's part of Haskell98 even
09:54:49 <ill_logic_> Perhaps in an unsupported manner.
09:54:50 <benmachine> _ is a pattern like any other variable, except it doesn't bind anything
09:54:55 <d3lxa> so that's a sweat pot, easy way to prove some types are correct
09:54:59 <ill_logic_> I guess I'll have to hack it.
09:55:03 <ill_logic_> as they did
09:55:04 <d3lxa> s/sweat/sweet/ hum
09:55:11 <Iceland_jack> d3lxa: :Þ
09:55:21 <ion> Sweat pot sounds nasty.
09:55:44 <ill_logic_> http://www.haskell.org/haskellwiki/Raspberry_Pi#GHC_Status <- here's a good bit of misleading info
09:56:36 <ill_logic_> I apologize for my tone. I'm just frustrated that I took the time to upgrade my Pi apparently for no reason.
09:56:42 <d3lxa> ion: I'm sorry, please forgive me OTL
09:57:11 <rasfar> (just FTR, let v = v :: Type  blackholes when run)
09:57:12 <ill_logic_> I'll take this to a mailing list. Thanks for the updates.
09:57:34 <ion> ill_logic: I’m using Debian’s GHC package on my Beagle Bone with success. I’d assume it works on Raspi as well.
09:57:46 <d3lxa> rasfar: are you new with haskell? it's a recursive definition, that's why
09:58:12 <Iceland_jack> Nothing to do with monads
09:58:15 <rasfar> i'm new to monadic Haskell, never quite sure what'll happen in there
09:58:18 <d3lxa> it's not like all language are doing: looking at left with the scope then right
09:58:26 <Iceland_jack> Just so that's clear, there is no such thing as monadic Haskell :)
09:58:35 <rasfar> i don't agree
09:58:36 <d3lxa> rasfar: that's independant of monad, it's just the way haskell works, these definitions
09:58:44 <Iceland_jack> You're free to disagree
09:58:59 <rasfar> yes, i understand that, it's okay :)
09:59:04 <Iceland_jack> If you want to give individual pieces of Haskell names you can do that personally
09:59:14 <Iceland_jack> ‘non-functional Haskell’ is Haskell without using functions
09:59:17 <d3lxa> rasfar: actually I said it incorrectly: usual language starts on the right, then on the left*
09:59:21 <ill_logic_> ion: you have gchi?
09:59:35 <ill_logic_> And if so, did you get it from a repository?
09:59:45 <rasfar> if you boild it all down to core, there's no difference
09:59:54 <rasfar> to the programmer dealing with syntax, there's a difference
10:00:13 <Iceland_jack> rasfar: You seem to conflate monads and do-notation
10:00:15 <rasfar> sometimes when I'm unfamiliar with syntax, things that are clear in another context come under doubt
10:00:22 <Iceland_jack> and seem to conflate shadowing with do-notation
10:00:37 <ion> ill_logic: IIRC it doesn’t work, but i may remember incorrectly.
10:00:44 <rasfar> you're breaking things into individual pieces with names, but that's okay :-p
10:00:56 <ill_logic_> ion: Actually I have to head out :( Perhaps I'll try to find you on here later.
10:01:03 <Iceland_jack> ‘you're breaking things into individual pieces with names’ I have no idea what you mean by that
10:01:11 <Iceland_jack> Things have names and I'm using them
10:01:13 <rasfar> it was sort of quoting you
10:01:14 <ill_logic_> Thanks again for help. I'll take it to the mailing list to try to sort out the info that's out there.
10:01:48 <Iceland_jack> You can shadow variables without touching monads or do-notation
10:01:54 <Iceland_jack> > let x = x in x
10:01:58 <lambdabot>  mueval-core: Time limit exceeded
10:02:14 <ion> > let x = '!':x in x
10:02:15 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
10:02:23 <Iceland_jack> > let x = 5 in let x = undefined in x
10:02:24 <lambdabot>  *Exception: Prelude.undefined
10:02:31 <Iceland_jack> Recursive binding and shadowing
10:03:00 <Lindrian> http://pastebin.com/tu3yD77b <--- can someone look at this please?
10:03:02 <mauke> The paste tu3yD77b has been copied to http://lpaste.net/97007
10:04:47 <nadirs> Lindrian: I'm not sure (blind suggestion) but maybe adding a (Ord a) class constraint helps?
10:05:22 <Lindrian> why would that matter?
10:05:29 <Lindrian> we're just taking the first n elements from the list
10:05:43 * geekosaur sees answer but notes that it looks a lot like homework
10:06:01 <benmachine> so, first of all, [x,x,..] is a syntax error, you don't want the second comma
10:06:02 <geekosaur> let's say that Ord is in the right forest but the wrong tree
10:06:02 <nadirs> sorry I tried it
10:06:03 <Lindrian> its from my past exams
10:06:06 <Lindrian> im trying to learn for mine tomorrow
10:06:08 <rasfar> yeah, the "4. " at the start kinda suggests that / oh
10:06:11 <nadirs> it should be (Enum a) constraint
10:06:23 <Lindrian> nadirs: ah yes of course
10:06:25 <Iceland_jack> > [1,1..]
10:06:26 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
10:06:31 <Lindrian> since not all things are enumerable
10:06:36 <geekosaur> yes
10:06:36 <Lindrian> doh
10:06:37 <ion> @type \x -> [x,x..]
10:06:38 <lambdabot> Enum t => t -> [t]
10:06:42 <Lindrian> i knew that :(
10:06:44 <Iceland_jack>   ↑
10:06:56 <benmachine> you might object that you don't need to know anything about x in order to work out what [x, x ..] should be
10:07:05 <ion> Some things that are Enum shouldn’t. But that’s another topic. :-P
10:07:09 <Iceland_jack> heh
10:07:10 <benmachine> but actually you kind of do because just given two values like that you can't work out if they're equal or not
10:07:16 <Iceland_jack> You could define a function that gives you an infinite list of x's
10:07:22 <Iceland_jack> (not ex's I should hope)
10:07:29 <d3lxa> why not something like: let l = x:l in take n l
10:07:31 <benmachine> like, that should definitely work the same as let y = x in [x, y, ..]
10:07:41 <rasfar> you can't "work it out", but don't know "know" by substitutivity?
10:07:46 <benmachine> but suddenly you've got to know that x and y are equal and goodness knows what would happen if they weren't
10:08:11 <benmachine> rasfar: you can't identify things on the basis of being the same variable, because that would break referential transparency
10:08:29 * hackagebot hPushover 0.1.1 - Pushover.net API functions.  http://hackage.haskell.org/package/hPushover-0.1.1 (WJWH)
10:08:35 <jmcarthur> rasfar, d3lxa: you can also say  _foo <- blah  , which allows you to name the variable but suppress ghc's warning about it being unused, if you want the extra documentation about what you're explicitly ignoring
10:08:37 <rasfar> oho! really? I thought sharing was based on that!
10:08:46 <benmachine> rasfar: sharing is fine because sharing is not observable
10:09:03 <benmachine> it doesn't affect the semantics, only the performance
10:09:24 <benmachine> affecting performance not semantics is what optimisation is all about
10:09:47 <rasfar> i don't quite understand the danger here. can you give me an example where something breaks?
10:10:00 <rasfar> if x was an IO computation, then sure...
10:10:10 <benmachine> rasfar: so, let's suppose we have the rule that [x, x ..] was an infinite list of x
10:10:31 <benmachine> rasfar: now, referential transparency requires that let y = x in [x, y ..] is also an infinite list of x
10:10:40 <benmachine> because it shouldn't matter what name we call something, only what it *is*
10:10:52 <Iceland_jack> Maybe GHC should have a special case where:
10:10:52 <Iceland_jack>     [x, y..] = repeat x
10:10:52 <Iceland_jack> when x == y
10:10:59 <Iceland_jack> not requiring the Ord instance :)
10:11:01 <Iceland_jack> *Enum
10:11:12 <benmachine> Iceland_jack: but then how do you typecheck [x, y ..]?
10:11:31 <rasfar> let y = x makes y~x, no?
10:11:39 <haasn> Iceland_jack: what if x /= y?
10:11:49 <Iceland_jack> benmachine: You'd have to expand it before type checking
10:11:49 <benmachine> rasfar: what do you mean by ~?
10:12:00 <rasfar> um, same type or so?...
10:12:07 <benmachine> rasfar: yes, certainly the same type
10:12:47 <FreeFull> haasn: Then it's still y~x
10:12:51 <rasfar> i still don't see the problem (sorry! i am not very quick) -- is there not one more line pending to your explanation above?
10:12:53 <Iceland_jack> haasn: You'd have to use the same identifier or literal for it to work :) something like [2+2, 4..] wouldn't work
10:12:57 <benmachine> in fact let y = x in <blah> means that in <blah>, y is equal to x, y is another name for whatever x is a name for
10:13:00 <Iceland_jack> but it's not meant as a serious suggestion
10:13:05 <udevd> hi! do you know perhaps case when `reads' return more than 1 value in list?
10:13:29 <benmachine> rasfar: well, there's more coming, yes, but I was waiting for you to react, so I can respond accordingly
10:13:44 <rasfar> believe me you have my full attention, thanks benmachine
10:14:02 <khyperia> Does anyone know how 'data' definitions are desugared to Core in GHC?
10:14:18 <benmachine> rasfar: all right, so, suppose I write something like f y = [x, y ..]
10:14:33 <benmachine> rasfar: then this is okay if I call f x, but not if I call f at any other argument...
10:15:07 <benmachine> rasfar: basically what I'm saying is that if you have two things, one called x and one called y, trying to work out if they are the same or not is pretty hard
10:15:36 <benmachine> rasfar: I dunno, I'm trying to say "what you want won't work" but I'm not exactly sure what you want :)
10:15:57 <rasfar> khyperia: try using ghc-core ... the output is a bit much to paste or go through right at this moment...
10:16:11 <jmcarthur> kylcarte: i don't think there is any desugaring for data type definitions. they are just data type definitions
10:16:21 <jmcarthur> err
10:16:25 <jmcarthur> khyperia: ^^
10:16:48 <rasfar> benmachine: i see, so it is a shadowing danger in nesting?
10:17:03 <benmachine> rasfar: no, it's nothing to do with shadowing as such
10:17:25 <rasfar> well, x is unbound in your last example there
10:17:37 <benmachine> yeah, I just assume it's bound somewhere else
10:18:01 <benmachine> my point is you've got this [x, y ..] and that looks like it requires Enum, but then y might be x (and this fact might not be obvious) in which case in your scheme it wouldn't
10:18:09 <rasfar> but where did we begin here? we're talking about whether Enum is really needed for [x,x...]
10:18:35 <Iceland_jack> :t \x y -> [x, y..]
10:18:36 <lambdabot> Enum t => t -> t -> [t]
10:18:42 <khyperia> alright, sure
10:18:54 <benmachine> rasfar: right, basically I'm saying that it's hard to tell whether [x, y ..] is actually really [z, z ..]
10:19:02 <benmachine> so it's hard to tell whether it needs Enum or not
10:19:11 <rasfar> right, okay. / we had   let y = x in [x, y ..]
10:19:28 <benmachine> yep
10:19:32 <epta> Is there any shorthand for `length . filter id`?
10:19:34 <benmachine> do you think that should need Enum?
10:19:34 <rasfar> now if we have f y = let y = x in [x, y ..]
10:19:46 <rasfar> there is no danger (although of course it's silly)
10:19:50 <skypers> hey, why do we have to provide a Error instance in order to be able to throw errors?
10:20:03 <skypers> I mean, MonadError doesn’t explicitely use Error
10:20:17 <benmachine> rasfar: sorry, my examples are getting confused here
10:20:25 <benmachine> rasfar: let's stick to let y = x in [x, y ..] for now
10:20:30 <benmachine> rasfar: should that need Enum?
10:20:39 <rasfar> i'll venture "no" ....
10:21:00 <benmachine> rasfar: (there is not necessarily a right or wrong answer here, but I'm going to explain what I think the problems are in each case)
10:21:19 <rasfar> cool, i appreciate your time
10:21:23 <benmachine> rasfar: ok, so what about if you're writing, say [x, y ..] and x and y are both imported from different modules?
10:21:30 <benmachine> rasfar: I have literally nothing better to do :P
10:21:38 <benmachine> well, there are lots of things I should definitely be doing, but I don't want to
10:21:44 <benmachine> so I'm here instead
10:22:12 <rasfar> alright, but ... we need to keep the example connected to the original, which is only that [x,x..] should be safe
10:22:37 <rasfar> so if x and y are used, and coming from different places, we still need some formal assurance that they're equal
10:22:41 <julianb> uhm, Hi. I'm trying to make a sieve of erastothenes using ST, yet I'm getting some weird error: http://lpaste.net/97008 (both code and error are there)
10:23:12 <nadirs> epta: to me, that looks like the shortest way
10:23:27 <skypers> hey, is there a function to use like when (or unless), but for ErrorT?
10:23:28 <skypers> like
10:23:35 <rasfar> epta: isn't that just  filter?
10:23:37 <skypers> unless (correct) $ throwError…
10:23:41 <rasfar> *length  i mean
10:24:01 <Fuuzetsu> julianb: The error is pretty clear to me: you're using a function ‘readArray’ from ‘MArray’ typeclass on something that's not its instance
10:24:26 <rasfar> :t (filter id)
10:24:27 <lambdabot> [Bool] -> [Bool]
10:24:38 <skypers> I guess I have to use if then else
10:24:38 <rasfar> :t length . filter id
10:24:39 <lambdabot> [Bool] -> Int
10:24:56 <nadirs> > (length . filter id) [True, False, False, True, False]
10:24:57 <lambdabot>  2
10:25:03 <nadirs> > filter [True, False, False, True, False]
10:25:03 <stelleg> seems like there should be a modifyTVar that returns the value
10:25:04 <lambdabot>  Couldn't match expected type `a0 -> GHC.Types.Bool'
10:25:04 <lambdabot>              with actual type `[GHC.Types.Bool]'
10:25:06 <rasfar> epta: so I guess it's length, but only on [a] ~ [Bool]
10:25:06 <notdan> skypers: what's wrong with the snippet you posted, using unless?
10:25:08 <stelleg> ala i++
10:25:13 <nadirs> > length [True, False, False, True, False]
10:25:14 <lambdabot>  5
10:25:31 <nadirs> rasfar: you see, it counts how many True values are there
10:25:56 <benmachine> epta: there's no short name for length . filter f that I'm aware of
10:25:57 <skypers> notdan: imagine I run this in ErrorT MyE IO a
10:25:57 <rasfar> length . filter id $ [True, False, False, True, False]
10:25:57 <ReinH> julianb: As a side note, writing to and reading from an array in ST to return a list is probably not better than just cons'ing onto the list to begin with
10:26:06 <rasfar> > length . filter id $ [True, False, False, True, False]   -- sorry
10:26:07 <lambdabot>  2
10:26:22 <rasfar> oh of course! *blush*
10:26:23 <skypers> unless correct . throwError $ MyE "shit!"
10:26:36 <skypers> it’s ErrorT MyE IO ()
10:26:40 <skypers> it doesn’t type
10:27:03 * geekosaur sees a (->) in the instance and suspects a missing parameter somewhere along the line
10:27:16 <julianb> Fuuzetsu, ReinH, thanks!
10:28:18 <rasfar> benmachine, i guess our discussion has fizzled? thanks though. i  need to study the basics more.
10:28:24 <benmachine> rasfar: no, hold on a sec :P
10:28:37 <rasfar> a'rite...
10:28:45 <benmachine> rasfar: okay, to catch up on what you were saying, Haskell has this property whereby if someone in their library writes myThing = thisOtherThing, then anywhere I have thisOtherThing I should be able to replace it with myThing and everything should work fine
10:29:08 <benmachine> this is referential transparency, and it means abstraction is always safe (up to performance concerns, anyway)
10:29:11 <rasfar> absolutely
10:29:24 <FreeFull> benmachine: Except that myThing might be less polymorphic, which might make things not work
10:29:43 <benmachine> FreeFull: true, but let's say it isn't
10:29:58 <benmachine> rasfar: so it sounds to me like this idea where Haskell can tell that x and x are equal but it can't tell if ThisLibrary.x and ThatLibrary.y are equal breaks that
10:30:16 <benmachine> rasfar: so you can't just freely see an x in your code and think "oh, well, that's 5, so I can replace that with a 5"
10:30:26 <benmachine> because it might *need* to be x so the code can "see" that it's equal to some other x
10:30:58 <rasfar> benmachine: i think i see what you're saying, but in the let y = x in [x,y..] example we had equality by declaration
10:31:26 <benmachine> rasfar: right, but suppose you happen to know that x is actually always 5 at that point in the code
10:31:29 <rasfar> i don't think i'd assert that [x,y..] should be "derivable" under weaker conditions
10:31:48 <benmachine> rasfar: that means if you replace x with 5 in that bit of the code, it breaks, even though you're not changing any values in any real sense
10:31:52 <rasfar> as long as you express that knowledge formally withih the program syntax, should be okay
10:32:14 <benmachine> rasfar: we *want* Haskell to be "blind" to variable names in this way so that we can freely abstract things
10:32:28 <Yuu-chan> Could anyone help with Gloss?
10:32:29 <benmachine> so we can package up subexpressions in let statements wherever we like
10:33:19 <benmachine> rasfar: it's not unreasonable to want a language that can recognise syntactic equality, but it's not Haskell
10:33:28 <benmachine> it makes different tradeoffs
10:33:54 <rasfar> i'm still not convinced, but i'm afraid to dispute it more for fear of annoying you, who wrote stepeval and all... (still grateful for that, whether it works perfectly or not)
10:35:10 <rasfar> (if we could just work from "let y = x in [x,y..]" -- concretely, one or two more bits -- to arrive at something that shows ref. transp. has been broken and caused trouble, i'd be relieved)
10:35:50 <rasfar> or if that's too limiting, we can change the example -- or drop it I guess...
10:35:57 <benmachine> heh
10:36:01 <benmachine> don't worry about annoying me
10:36:05 <benmachine> if I get annoyed I'll go away :P
10:36:18 <rasfar> admittedly it's not a huge concern of mine -- derivable enumerations that is, not annoying you :)
10:36:25 <benmachine> (also I'm not really proud of stepeval, as you hinted it doesn't really work :P)
10:36:33 <benmachine> hmm
10:36:43 <rasfar> well it was the only show in town last i looked
10:36:47 <benmachine> yeah
10:36:52 <benmachine> it's definitely something that *should* exist
10:36:57 <rasfar> yes!
10:37:03 <benmachine> and I'd really like to write something similar for typechecking
10:37:11 <benmachine> but it's harder work than you think when you're starting out :P
10:37:17 <rasfar> i'm puzzled why ghci doesn't provide it
10:37:23 <benmachine> ghci does have a debugger
10:37:39 <rasfar> i know, i've explored it in some depth, but it's not adequate for that purpose
10:37:42 <benmachine> not really used it much myself
10:37:52 * benmachine shrug
10:37:53 <rasfar> hood is closer, but still problematic
10:38:09 <benmachine> ghci is written by people far cleverer than me, so there are probably good reasons it is the way it is :P
10:38:53 <rasfar> that was my feeling too, so i started looking around for other tools. leading me to hood, then hat, and then I came here to ask and was directed to your stepeval
10:39:00 <Lindrian> What is the type of this expression zipWith map'?
10:39:05 <benmachine> I dunno, I think that having [ThisLibrary.x, ThatLibrary.y ..] not able to decide whether it should need an Enum constraint is a violation of RT
10:39:14 <rasfar> :t zipWith map'
10:39:15 <lambdabot>     Not in scope: map'
10:39:15 <lambdabot>     Perhaps you meant one of these:
10:39:15 <lambdabot>       `mapM' (imported from Control.Monad.Writer),
10:39:15 <benmachine> plain and simple
10:39:20 <Iceland_jack> Lindrian: You can ask lambdabot!
10:39:25 <rasfar> :t zipWith map
10:39:25 <benmachine> Lindrian: where does map' come from?
10:39:26 <lambdabot> [a -> b] -> [[a]] -> [[b]]
10:39:33 <Lindrian> ignore the '
10:39:37 <benmachine> oh
10:40:08 <nooodl> > sum [1 | True <- [False, False, True, True, False, True, False]]
10:40:09 <lambdabot>  3
10:40:14 <Lindrian> ha! i was right!
10:40:16 <Lindrian> woho!
10:40:22 <benmachine> :)
10:40:22 <rasfar> benmachine: i guess there's no way to assert their equality in Haskell, so yeah
10:40:41 <triliyn> What is RT?
10:40:47 <benmachine> triliyn: referential transparency
10:40:52 <benmachine> I wonder if there's a wiki page on it, sec
10:40:53 <rasfar> register transfer ... doh!
10:40:53 <triliyn> ah
10:41:08 <triliyn> I know what that is, I just hadn't seen the acronym
10:41:15 <merijn> I was thinking RunTime, so :p
10:41:26 <triliyn> yeah, I was too
10:41:29 <benmachine> at least you weren't thinking retweet
10:41:34 <merijn> triliyn: I've never seen that acronym for referential transparency before either
10:41:37 <int-e> real time
10:41:48 <benmachine> ew, there is a wiki page but it's kind of... wrong
10:41:56 <volko> hmm, not sure why this is giving me a parse error. My code looks just like the example happstack code. http://lpaste.net/5866270434017673216
10:42:05 <volko> I keep getting src/Application.hs:69:9: parse error on input `let'
10:42:31 <skypers> isn’t ErrorT a Functor?
10:42:33 <geekosaur> indentation
10:42:38 <merijn> volko: let is not indented to the same level as 'idb'
10:42:44 <benmachine> skypers: ErrorT r m really ought to be
10:42:45 <skypers> Functor m => Functor (ErrorT e m)
10:42:50 <skypers> yeah it is
10:42:50 <skypers> hm
10:42:52 <rasfar> after  put $ idb {  you need more indentation on the following lines
10:42:54 <geekosaur> volko: indentation matters, your let is indented one space too far and looks like a continuation of the previous expression
10:42:58 <skypers> I got an error on a fmap
10:43:09 <skypers> oh, nvm
10:43:56 <volko> that is how it looks in the tutorial though?
10:43:59 <volko> http://www.happstack.com/docs/crashcourse/index.html#inserting-a-record
10:44:24 <merijn> volko: No, the let there is indented the same as the b above it
10:44:43 <merijn> Also, that's an ugly indent style, should have the 'do' behind the '=' >.>
10:44:43 <int-e> volko: no. note that they only indent three spaces after the 'do', to match the column of the 'b@... <- get'
10:44:54 <volko> oh
10:45:06 <volko> I assumed it was any indentation level
10:45:08 <rasfar> what, we were both wrong?
10:45:12 <volko> such as python defs
10:45:19 <volko> thanks
10:45:19 <int-e> volko: you can also put two spaces after the 'do' instead
10:45:34 <volko> good to know
10:45:39 <rasfar> when i change the indentation as per volko's suggestion the error goes away
10:45:58 <merijn> volko: I would indent like this: http://lpaste.net/5866270434017673216
10:46:04 <int-e> volko: the point is that the block starts *after* the 'do', and all statements have to be indented to the same depth.
10:46:34 <merijn> volko: Additionally, might be worth to spend a few minutes reading the layout rules here: https://en.wikibooks.org/wiki/Haskell/Indentation
10:46:50 <merijn> They're not very difficult and knowing them will avoid confusion
10:47:15 <rasfar> oops, s/volko/merijn/
10:48:23 <ReinH> volko: please don't use {} like you would in C or Java... they don't serve the same purpose.
10:48:34 <volko> Ahh
10:49:05 <merijn> ReinH: What's wrong with his current brace usage?
10:49:14 <merijn> It's not my personal style, but it looks fine to me
10:49:14 <volko> I can add a newline immediately after the do as well then?
10:49:20 <merijn> volko: Yes
10:49:45 <rasfar> it's mostly record syntax, no?
10:49:46 <volko> yeah that makes more sense
10:49:53 <ReinH> merijn: the closing brackets aligned with the first column of the outer scope? o_O
10:49:54 <volko> just woke up, forgot that "do" starts the block :p
10:50:08 <merijn> the first *non-whitespace* character after a layout keyword (of, where, let and do) decides indentation
10:50:08 <volko> ReinH: That shows where the block ends pretty clearly
10:50:11 <volko> for me
10:50:15 <ReinH> merijn: on record syntax especially
10:50:27 <ReinH> volko: there aren't "blocks", that's why I mean by "they don't serve the same purpose"
10:50:33 <merijn> ReinH: If there's a number of fields, yes
10:50:33 <jophish_> I'm writing an interface to glGenBuffers, glGenBuffers takes a pointer to an array of GLuint (32 bit integer) and the size of the array and fills the memory with names of new buffers. Would someone be able to give a little advice about how to write genBuffers :: Int -> IO [GLuint]? I have the version for one buffer: genBuffer= alloca (\u -> glGenBuffers 1 u >> peek u)
10:50:52 <jophish_> I'm not sure how to create a c array, and get the list from that
10:51:08 <merijn> The two line update of idb I would probably do on a single line, but the one on line 35 looks fine
10:52:02 <merijn> volko: Anyway, the wikibook I just linked covers the exact mechanical rules used by GHC, they take like 5 minutes to learn and they explain everything
10:52:08 <ReinH> merijn: 35 is ok, although I don't understand why newItem isn't just Item -> Update ItemDb Item
10:52:38 <skypers> hey, ErrorT is really nice!
10:52:44 <rasfar> jophish_: I don't know if this will help you, but I was able to use BSI.toForeignPtr
10:53:03 <rasfar> ( import qualified Data.ByteString.Internal as BSI )
10:53:46 <skypers> ok now someone can help me
10:53:48 <merijn> jophish_: alloca is probably wrong, as that deallocates after the lambda finishes executing
10:53:54 <skypers> I’m developing a not sure feature
10:53:59 <rasfar> my ByteString came from a BMP read using Codec.BMP
10:54:07 <jophish_> merijn: but by then the value is in haskell,
10:54:18 <skypers> I’ll be removing it if something goes wrong
10:54:20 <jophish_> the integer is only used because the GL function returns void and takes a location to fill
10:54:26 <skypers> how could I still use darcs record?
10:54:33 <skypers> like git branches
10:54:39 <ReinH> Oh, it needs to grab the next item id
10:54:43 <jophish_> rasfar: is bytestring the right tool for 32 bit integers?
10:54:48 <ReinH> and 35 could still just be let i = Item nextItemId p t d
10:55:32 <rasfar> jophish_: likely not, if it's Word8
10:55:51 <jmcarthur> skypers: put some sort of keyword in the patch message, and you can operate on those patches as a set using -p KEYWORD
10:55:52 <rasfar> I guess the BMP is deinterlaced or whatever, so each component is just Word8
10:55:59 <merijn> jophish_: But doesn't openGL expect the buffers to not disappear after the function?
10:56:20 <merijn> jophish_: Anyway, take a look at Foreign.Marshal.Array
10:56:33 <merijn> jophish_: Which has: peekArray :: Storable a => Int -> Ptr a -> IO [a]
10:56:37 <rasfar> (but you're doing something quite different than basic texture loading, so i'll just listen)
10:56:57 <jophish_> merijn: the opengl function looks a little bit like this: genbuffers(int n, int* ret){ for( i = 0; i < n; ++i){ ret[i] = createNewBuffer(); } }
10:57:10 <jophish_> the buffer name is just an integer handle, not the actual buffer
10:57:10 <jmcarthur> skypers: to delete the feature, run darcs obliterate -p KEYWORD -a. to stash the feature, run darcs send -o filename -p KEYWORD -a
10:57:25 <jmcarthur> skypers: to reapply from the stash, run darcs apply filename -a
10:57:54 <merijn> jophish_: Right, so u is a "Ptr GLuint", right?
10:58:02 <jophish_> merijn: exactly
10:58:17 <merijn> jophish_: The Foreign.Marshal.Array function I just mentioned (peekArray) can read a list from an Array
10:58:26 <jophish_> merijn: that sounds perfect
11:00:14 <jmcarthur> jophish_: looks like i'm a bit late, but what merijn just suggested is how i would do it
11:01:03 <jmcarthur> jophish_: along with allocaArray
11:01:15 <nadirs> reizuki: hi there
11:01:21 <jophish_> jmcarthur: sounds like a plan
11:01:47 <Lindrian> how should i think when trying to figure out the type of the function "map zipWith"?
11:02:24 <Eduard_Munteanu> Lindrian: you asked a similar question yesterday I think, are you stuck on something in particular?
11:02:40 <Lindrian> yeah
11:02:52 <jmcarthur> jophish_: btw, you might like to know there is a #haskell-game channel. it's not normally super busy like this one is, but there's sometimes an interesting conversation, and it can be a good place to discuss graphics stuff like this
11:03:03 <Iceland_jack> Lindrian: (You are aware that you can just query ghci)
11:03:15 <Iceland_jack> unless you just want to learn how to infer types by hand
11:03:19 <jophish_> jmcarthur: oh, awesome. Thanks
11:03:41 <Eduard_Munteanu> Lindrian: for map it's really easy, since it transforms a  'a -> b'  into  '[a] -> [b]', you just need to figure what 'a' and 'b' are.
11:03:50 <rasfar> you'd look at each type first, I suppose:
11:03:54 <rasfar> :t map
11:03:54 <Lindrian> http://pastebin.com/BKC6waNV
11:03:55 <lambdabot> (a -> b) -> [a] -> [b]
11:03:58 <mauke> The paste BKC6waNV has been copied to http://lpaste.net/97011
11:03:59 <rasfar> :t zipWith
11:04:00 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
11:04:00 <Lindrian> Iceland_jack: i want to learn to infer
11:04:06 <Lindrian> the pastebin shows my thought process
11:04:27 <osa1_> why cabal says "Warning: unknown license type, you must put a copy in LICENSE yourself." ? I selected license from the list it provided me in `cabal init` ..
11:05:41 <ReinH> Lindrian: you've already applied the (a->b)
11:05:44 <ReinH> to map
11:05:51 <Eduard_Munteanu> Lindrian: that's the type of 'map' *in* 'map zipWith', not the type of 'map zipWith'.
11:05:51 <Lindrian> yeah, so that goes away
11:06:11 <Lindrian> Eduard_Munteanu: right, how should I think about it instead?
11:06:12 <ReinH> map zipWith is going to be of type [a] -> [b]
11:06:15 <ReinH> so plug in an and b
11:06:19 <ReinH> *a and b
11:06:26 <Lindrian> ah right
11:06:35 <Lindrian> ReinH: my problem is figuring out the correct a and b in this case
11:06:38 <Lindrian> i think i just got lucky
11:06:42 <Eduard_Munteanu> Lindrian: you've applied zipWith, so you're left with the result type
11:06:53 <Eduard_Munteanu> [(a -> b -> c)] -> [[a] -> [b] -> [c]]
11:06:54 <ReinH> Lindrian: they come from the f in map f
11:06:58 <ReinH> :t zipWith
11:06:59 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
11:07:29 <Eduard_Munteanu> :t ?f `asTypeOf` map $ zipWith
11:07:30 <lambdabot> (?f::((a -> b -> c) -> [a] -> [b] -> [c]) -> [a -> b -> c] -> [[a] -> [b] -> [c]]) => [a -> b -> c] -> [[a] -> [b] -> [c]]
11:07:38 <Iceland_jack> Lindrian: zipWith ∷ (a → b → c) → ([a] → [b] → [c])
11:07:39 <rasfar> osa1_: you maybe chose the "Other (specify)" option?
11:07:56 <Yuu-chan> What's "?f"?
11:07:56 <ReinH> o_O
11:08:05 <Iceland_jack> so zipWith ∷ x → y where x = (a → b → c), y = ([a] → [b] → [c])
11:08:13 <Lindrian> Iceland_jack: why did you group it like that?
11:08:21 <Eduard_Munteanu> Yuu-chan: implicit params, you can abuse them to that effect
11:08:22 <Lindrian> Iceland_jack: because when you do it becomes obvious
11:08:27 <osa1_> rasfar: no I chose MIT
11:08:29 <Iceland_jack> Lindrian: To help you see the answer
11:08:40 <osa1_> rasfar: this happens whatever I choose
11:08:47 <osa1_> (tried several times)
11:09:01 <rasfar> that sounds not right ... cabal --version?
11:09:03 <Iceland_jack> When you have:
11:09:03 <Iceland_jack>     f ∶ a → b → c → d
11:09:03 <Iceland_jack> it's equal to:
11:09:03 <Iceland_jack>     f ∶ a → (b → (c → d))
11:09:09 <Iceland_jack> since → is right associative
11:09:14 <Eduard_Munteanu> :t ?f $ ?x -- Yuu-chan
11:09:15 <lambdabot> (?f::t1 -> t, ?x::t1) => t
11:09:23 <Lindrian> right
11:09:35 <Lindrian> thanks Iceland_jack
11:09:36 <Lindrian> that helps
11:09:43 <Iceland_jack> :)
11:09:52 <Eduard_Munteanu> Yuu-chan: "that effect" being getting the type of certain subexpressions
11:10:01 <Yuu-chan> Oh, nice
11:10:11 <osa1_> rasfar:
11:10:12 <osa1_> cabal-install version 1.18.0.2
11:10:14 <osa1_> using version 1.18.0 of the Cabal library
11:10:21 <watermind> is there a zipWith that throws an exception on different lengths? or one that returns a Maybe [c] ?
11:10:34 <Yuu-chan> Is it a feature of Lambdabot only?
11:10:44 <ReinH> Yuu-chan: it's a ghc extension
11:11:01 <Eduard_Munteanu> Yuu-chan: implicit params aren't, so it might be possible to get that effect with ghci too
11:11:03 <Iceland_jack> so the x and y in
11:11:03 <Iceland_jack>     map ∶ (x → y) → [x] → [y]
11:11:03 <Iceland_jack> become
11:11:03 <Iceland_jack>     map zipWith ∶ [a → b → c] → [[a] → [b] → [c]]
11:11:04 <ReinH> watermind: "throws an exception"?
11:11:04 <rasfar> osa1_: same as mine, except I'm "using version 1.18.1.2"
11:11:21 <watermind> ReinH: error "ops"
11:11:35 <Iceland_jack> You'd never *use* map zipWith
11:11:41 <ReinH> watermind: I hope not :)
11:11:51 <rasfar> could it be path-related? maybe your path has changed, and there's a version mismatch? although why this would affect "cabal init" (rather than "cabal build")?...
11:12:00 <ReinH> Iceland_jack: I am trying to think of a use for map zipWith :p
11:12:06 <watermind> ReinH: why not? it's better than a silent bug if you do require it to have the same lengths
11:12:21 <ReinH> watermind: but it's worse than a Maybe
11:12:33 <osa1_> should I add -threaded to ld-options or ghc-options?
11:12:58 <Iceland_jack> ReinH: Good luck with that ;)
11:13:13 <watermind> ReinH: true, but does head return a maybe? or does tail?
11:13:26 <ReinH> watermind: perhaps they should :)
11:13:57 <Feuerbach> watermind: not that I know of
11:14:16 <Feuerbach> and the exception-throwing version would actually perform better, because it can be lazy
11:14:22 <Feuerbach> the Maybe version cannot be lazy
11:14:38 <watermind> ReinH: perhaps, there's advantages and disadvantages, but one thing's for sure, you're not going to put Maybe's all over your code to assert every single invariant you may think of
11:14:59 <ReinH> Feuerbach: where "perform better" includes "sometimes causes runtime errors", I suppose
11:15:13 <watermind> ReinH: that would lift everything to the Maybe Monad, and as Feuerbach said you'd also lose lazyness
11:15:41 <ReinH> Maybe isn't such a difficult monad to work with
11:15:49 <Feuerbach> osa1_: probably ld-options (if that's a thing)
11:15:54 <Feuerbach> -threaded is a linker option
11:16:13 <k00mi> it's also a ghc option
11:16:13 <ReinH> watermind: and yes, I generally prefer maybes to partial functions
11:16:37 <osa1_> Feuerbach: is there a way to check if binary if really compiled with -threaded?
11:16:37 <watermind> ReinH: me too, I'm just saying it can depend on the use
11:16:38 <ReinH> unless I'm keeping track of that invariant some other way, but that adds complexity
11:17:47 <watermind> ReinH: point is, if you lift everything to maybe suddenly you're pretty much working with a call-by-value language
11:17:58 <watermind> ReinH: but one where the lifting is explicit
11:18:09 <ReinH> watermind: I don't think "lift everything to maybe" is a fair reduction of "prefer total functions"
11:18:49 <watermind> ReinH: indeed I agree, but it is not a fair reduction of "I hope an exception based verison does not exist" :P
11:18:59 <watermind> *it is
11:19:07 <ReinH> watermind: :p
11:19:41 <ReinH> watermind: If you don't want to lift everything to maybe you are welcome to use fromJust everywhere :D
11:19:55 <watermind> :/
11:20:24 <Iceland_jack> Using Maybe everywhere is really a non-solution
11:20:58 <ReinH> Iceland_jack: no one is suggesting that using Maybe everywhere is a solution
11:21:22 <Iceland_jack> It is quite inelegant when I introduce people to the language
11:21:29 <Iceland_jack> and there are partial functions everywhere though
11:22:04 <Feuerbach> ReinH: you're saying "runtime errors" like it's necessarily something bad. It isn't.
11:22:06 <Iceland_jack> not just easy ones like head that you can pattern match on but something like digitToInt
11:22:43 <Iceland_jack> and they ask “well can't I just catch the exception” which leaves me in the tricky situation of whether I should explain how imprecise exceptions work
11:23:36 <Feuerbach> why are imprecise exceptions a problem for you?
11:23:48 * hackagebot DAV 0.5.1 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.5.1 (ClintAdams)
11:24:01 <mangaba_leitosa> how using maybe affects laziness?
11:24:08 <Iceland_jack> Because catching them and explaining what that means to beginners is an annoying aspect of Haskell
11:24:32 <benmachine> there really ought to be a digitToInt that returns a Maybe
11:24:34 <kinslayer> Okay I want to do something simple take some json, split it up on : and then pretty print it to the screen, not reading it into a data structure, I would want that, but that is later
11:24:36 <Iceland_jack> Indeed
11:25:12 <Feuerbach> Iceland_jack: not sure what you mean. You don't usually need to explain them, and you catch them as usual
11:25:22 <benmachine> in the case of zip with non-equal length input lists, the best solution is possibly something like
11:25:29 <Iceland_jack> Feuerbach: How do you suggest doing that in pure code?
11:25:39 <benmachine> zipWith :: (a -> b -> c) -> [a] -> [b] -> ([c], Either [a] [b])
11:25:44 <rasfar> mangaba_leitosa: since (Just x) : more_maybes  is already in WHNF, so evaluation of x can be delayed  ... perhaps is why?
11:25:45 <Iceland_jack> Which breaks referential transparency
11:25:48 <Feuerbach> Iceland_jack: you don't, but it has nothing to do with impreciseness
11:26:06 <benmachine> although you can do even better than that if you define a custom datatype
11:26:24 <Iceland_jack> Feuerbach: My point is that when you have ‘digitToInt 'z'’, that's a partial function whose exception you cannot catch in a pure function
11:27:01 <dmwit> benmachine: Depends on what your criterion for "best" is, I suppose.
11:27:07 <Feuerbach> Iceland_jack: that is true
11:27:18 <benmachine> dmwit: ah, well, that's what the "possibly" is for
11:27:19 <dmwit> benmachine: I think the zip that appears in the "these" package is pretty darn good for most use cases.
11:27:22 <benmachine> good ol' weasel words
11:27:36 <dmwit> yeah =)
11:27:55 <Feuerbach> hey dmwit
11:28:10 <Iceland_jack> So that is a rather big issue with Haskell — or rather its standard library — that it encourages you to be pure but doesn't give you the tools to do it easily
11:28:12 <dmwit> hey Feuerbach
11:28:14 <watermind> Feuerbach: regarding imprecise exceptions give me a second
11:28:35 <Feuerbach> dmwit: tell me about haskell-pkg-janitors. Is it functional? How do you interact?
11:29:00 <benmachine> dmwit: these is a nice pacakge though
11:29:19 <benmachine> Feuerbach: purely functional, I bet
11:29:28 <dmwit> I don't know much about haskell-pkg-janitors, to be honest.
11:29:40 <dmwit> Some maintainers disappear occasionally, and then people who want to use those packages stick them in h-p-j.
11:29:44 <dmwit> ...and join h-p-j.
11:30:05 <Feuerbach> well I'd like to do exactly that
11:30:07 <benmachine> dmwit: don't know I like the sound of Data.Align.malign though :x
11:30:10 <Feuerbach> but I couldn't find much information
11:30:13 <dmwit> My role is essentially "apply patches other people suggest to X11".
11:30:32 <dmwit> benmachine: It is a wonderful pun, don't you think? =D
11:30:44 <rasfar> benmachne: lol!
11:30:59 <benmachine> dmwit: is it a pun, or is it just a combination of a letter and a word that happens to be another word :P
11:31:27 <ReinH> benmachine: yes
11:31:34 <dmwit> I believe the naming scheme was intentionally set up as it was so that malign could be one of the names. =)
11:31:40 <benmachine> haha, okay
11:31:41 <rasfar> and will this choice of name affect the decisions of future contributors about semantics...
11:32:23 * Yuu-chan learned a new word
11:32:38 <Feuerbach> sorry, I had terrible network lags. If anyone said something to me since my last msg, please repeat
11:32:45 <benmachine> Yuu-chan: see also: malignant
11:33:08 <benmachine> Feuerbach: see the logs in the topic?
11:33:10 <rasfar> ben9
11:33:22 <Feuerbach> benmachine: good idea :)
11:36:57 <Lindrian> Is this implementation of the map function correct? map f = foldr (\x xs -> (f x):xs) []
11:37:19 <mr-> yes
11:37:20 <Feuerbach> dmwit: is there a mailing list or IRC channel for h-p-j?
11:37:23 <Lindrian> boom
11:37:23 <Lindrian> thanks
11:37:38 <Iceland_jack> You can drop the (f x) parentheses Lindrian :)
11:37:43 <Lindrian> foldl would not work because the start value would not work when trying to rebuild the list, no?
11:38:01 <Iceland_jack> :t \f -> foldr (\x xs -> f x:xs) []
11:38:01 <Lindrian> since xs is [] for the first time with foldr
11:38:01 <lambdabot> (a -> a1) -> [a] -> [a1]
11:38:43 <Lindrian> and : appends to the head of list, which would be weird with foldl
11:38:45 <Lindrian> i believe?
11:39:32 <Feuerbach> yes, foldl just a wrong tool for the job there
11:39:36 <mr-> > let  weirdMap f = foldl (\xs x -> (f x):xs) [] in weirdMap (+1) [1,2,3] -- Lindrian
11:39:38 <lambdabot>  [4,3,2]
11:39:39 <Feuerbach> e.g. it won't work with infinite lists
11:39:45 <benmachine> you can write map with foldl but only in a terrible way
11:39:50 <benmachine> ok
11:39:52 <benmachine> to rephrase
11:39:59 <benmachine> you can write a map-like function that isn't reall map with foldl
11:40:18 <psc> hi is there a easy way,to see how functions like foldl are implemented on a offline system ?
11:40:24 <Lindrian> Feuerbach: yes, wont work on infinite lists and it would produce a inverted result
11:40:44 <Feuerbach> Lindrian: not necessarily, you can e.g. append or reverse in the end
11:41:00 <Feuerbach> or reverse in the beginning
11:41:18 <ReinH> Lindrian: map f = foldr ((:) . f) [], yes
11:41:20 <Feuerbach> but don't do that :)
11:41:36 <skypers> do you know whether there’s a binding for the emscripten program for Haskell?
11:41:49 <benmachine> :t let map f xs = foldl (\a x -> a . (f x :)) id xs [] in map
11:41:50 <lambdabot> (b -> a) -> [b] -> [a]
11:41:53 <mangaba_leitosa> rasfar: well, the discussion above mentions losing laziness by using Maybe, not gaining it...
11:42:31 <mangaba_leitosa> rasfar: sorry, I got distracted
11:45:48 <mr-> benmachine: I have seen that trick so often now, but still couldn't just do it :-/
11:46:19 <skypers> oh
11:46:26 <skypers> darcs doesn’t support branches at the moment
11:46:27 <skypers> :(
11:46:52 <abitlost> I've migrated to git, though bzr and hg both have fans
11:47:07 <skypers> I migrated from git
11:47:11 <skypers> :D
11:47:23 <abitlost> skypers: i'd gladly do that, but not to darcs :-)
11:47:24 <skypers> it might want to stay with git finally
11:47:30 <skypers> why?
11:47:32 <abitlost> i used darcs for a few years
11:48:00 <watermind> Feuerbach: this still makes me think http://lpaste.net/97013
11:48:20 <abitlost> hmm. darcs' model isn't totally coherent, and makes some merge usecases unnecessarily infeasible, plus there are some scary big lurking bugs
11:48:51 <Feuerbach> watermind: use 'evaluate' from Control.Exception instead of return
11:49:01 <skypers> I see abitlost
11:49:03 <Feuerbach> return doesn't evaluate its argument
11:49:35 <abitlost> skypers: i really wanted to like darcs, but the longer i used it and the more i learned about it, the more clear it was that i should migrate elsewhere
11:50:02 <skypers> yeah
11:50:14 <skypers> I think I’m gonna go back to git
11:50:20 <watermind> Feuerbach: wait, this doesn't work anymore is catch deprecated?
11:50:21 <skypers> plus, I perfectly know git
11:50:22 <abitlost> sadly, that's probably a good idea
11:50:38 <skypers> I like the “patches” model of darcs over snapshots
11:50:40 <skypers> but hm
11:50:44 <skypers> I really need branches
11:50:48 <skypers> it’s part of my way to do thinks
11:50:48 <dario> why is it so sad to use git?
11:50:50 <enthropy> is there a quasiquote to make these easier (to read/write): http://www.haskell.org/haskellwiki/Partial_signatures
11:50:51 <skypers> things*
11:50:57 <skypers> it’s not, dario
11:50:58 <Feuerbach> watermind: catch was removed from Prelude, but there's one in Control.Exception
11:50:59 <skypers> I like git
11:51:07 <skypers> I just wanted to test darcs
11:51:47 <abitlost> dario: unnecessarily unfriendly UI, unnecessarily complicated compared to bzr/hg (or so I hear from their fans), so/so on scalability
11:52:20 <benmachine> I use git at home and hg at work
11:52:30 <aristid> skypers: there are some occasions when i wish git was more proficient with dealing with patches, but i don't think i'd like losing the snapshot model either
11:52:35 <benmachine> git's UI is stupid in ways it really doesn't need to be, but when you get over that it's fast and powerful
11:52:50 <aristid> also hg's branching model is wrong.
11:53:03 <skypers> aristid: it’s quite nice indeed
11:53:09 <skypers> I’m going to go back to git
11:53:10 <skypers> :)
11:53:25 <aristid> skypers: where you at right now?
11:53:37 <abitlost> benmachine: I know a guy who's going to start improving its speed on large repos full-time in the not-so-distant future; it's faster than a lot of the alternatives, but it's not *fast* for sufficiently large repos
11:54:14 <skypers> aristid: where am I? what do you mean?
11:54:17 <watermind> Feuerbach: right, the whole exception system seems changed though because now it seems to require me to specify a type signature for the exception
11:54:41 <benmachine> abitlost: right, when I say fast I mean by comparison to my experience with hg
11:55:18 <abitlost> benmachine: yeah, it's definitely faster than that
11:55:19 <Feuerbach> watermind: indeed. for error, it should be ErrorCall
11:55:21 <aristid> skypers: which vcs do you use?
11:55:44 <skypers> git, a lot
11:55:50 <skypers> and darcs for a few weeks
11:55:54 <skypers> like two weeks
11:56:01 <Feuerbach> watermind: the cool thing is that now you can create your own exceptions and catch only them. E.g. ZipWithException
11:56:04 <aristid> skypers: why are you going back to git if you're already using it?
11:56:33 <enthropy> skypers: what's the git equivalent of darcs unpull?
11:57:20 <aristid> enthropy: git reset i suppose.
11:57:38 <skypers> enthropy: yeah, git reset
11:57:44 <watermind> Feuerbach: but how about expections raised by simple error "blah", what would the type of those be, or how would you specify it,  and how do you catch them?
11:57:45 <skypers> git reset ^
11:57:46 <aristid> enthropy: unpull undos patches i suppose, reset changes the commit a branch or ref points to.
11:57:54 <skypers> or git reset HEAD^ I’d say
11:57:56 <seliopou> git reset --hard
11:58:03 <aristid> seliopou: that does more than reset
11:58:18 <aristid> it also changes the working directory in addition to the ref
11:58:25 <seliopou> just reset will leave changes in your tree
11:58:37 <Feuerbach> watermind: like I said, they have type ErrorCall
11:58:46 <aristid> i believe reset in standard mode also changes the index, not just the ref
11:58:55 <seliopou> does unpull leave changes in your tree?
11:59:04 <enthropy> no they go away
11:59:11 <seliopou> so the equivalent is reset --hard
11:59:27 <enthropy> err your recorded patch's changes go away
12:00:20 <watermind> Feuerbach: sorry I had missed it
12:01:00 <skypers> plus
12:01:09 <skypers> darcs is slower than git and pushing to server
12:03:18 <rasfar> mangaba_leitosa, oh my mistake, i gave a casual look but couldn't see where the laziness was mentioned so just assumed...
12:04:23 <chips> i am high on hope, great haskell give me power!
12:05:01 * GreatHaskell gives power to chips
12:05:40 <chips> since i have the power, now all i need is an ide
12:06:03 <chips> then i will never want for food, shelter, or an internet connection
12:06:48 <Feuerbach> chips: you'd still need an internet connection if your ide is FP Haskell Center
12:06:51 <byorgey> chips: EclipseFP, Leksah, or FP Haskell Center
12:06:59 <rasfar> if your ide is immersive enough, you might manage without shelter
12:07:11 <BeardedCoder> In Cabal, I'm trying to set the executable name to include the version. Any tips?
12:07:49 <chips> byorgey: EclipseFP? how can i tolerate that my ide is written in java?
12:07:50 <Feuerbach> BeardedCoder: I think you can try to write an installation hook
12:08:06 <benmachine> BeardedCoder: at the risk of sounding low-tech, just change the executable name every version? :P
12:08:35 <Feuerbach> or never changing the version, perhaps? =)
12:08:35 <byorgey> chips: better use Leksah or FP Haskell Center then.
12:08:51 <watermind> why is it that "Result signatures are no longer supported in pattern matches" ?
12:08:56 <byorgey> BeardedCoder: you can use the auto-generated  Foo_Paths module
12:09:04 <chips> byorgey: FP Haskell Center costs money. should i be scared?
12:09:11 <sm> abitlost, I think you were unfair to darcs there
12:09:13 <watermind> to simplify type inference?
12:09:16 <Feuerbach> don't be scared, just pay
12:09:20 <BeardedCoder> byorgey: Ya, I was trying to figure that out. How would I use that in my .cabal?
12:09:20 <sm> it is a far better fit for some needs
12:09:24 <Feuerbach> they have a free version, too
12:09:28 <byorgey> chips: I think there are ways to use it for personal/academic etc. purposes for free
12:09:32 <enthropy> byorgey: that's only for getting the version number into something like --help
12:09:34 <enthropy> right?
12:09:49 <byorgey> enthropy: oh, right
12:09:53 <Feuerbach> watermind: show the code
12:09:56 <byorgey> I misunderstood what BeardedCoder wanted
12:09:58 <enthropy> probably making the executable name depend on the package version means writing a bit of stuff in the Setup.hs
12:10:12 <byorgey> indeed
12:10:22 <chips> byorgey, Feuerbach: which would you recommend? leksah or FP haskell center? be as biased as you can when making your recommendation, please. i want to drink kool aid, not water.
12:10:26 <[swift]_> is there something like 'lift' that works for functions of any arity? i'm often stopped from writing nice point-free code because of lift
12:10:28 <enthropy> in the long list of hooks in Distribution.Simple.****, one of them probably can rename things appropriately
12:10:40 <BeardedCoder> enthropy: K ty guys, will go check that out. Getting my first haskell app into production. =)
12:10:53 <Feuerbach> chips: personally I use vim, since you're asking
12:11:02 <byorgey> chips: I recommend FP Haskell Center
12:11:11 <watermind> Feuerbach: this works test = catch (return $ error "ops") ((\_-> return "ok") ::ErrorCall -> IO String)      this doesn't   test = catch (return $ error "ops") (\e::ErrorCall -> return "ok")
12:11:28 <byorgey> chips: since vim was mentioned, I use emacs.  With haskell-mode it's quite nice.
12:11:33 <chips> Feuerbach: no, no vim, and no emacs. i have achieved enlightenment and all i care about now is the "now"
12:11:38 <watermind> Illegal result type signature `ErrorCall_'  Result signatures are no longer supported in pattern matches
12:11:39 <chips> byorgey: see above
12:11:56 <tdammers> chips: enlightenment as in "real programmers use cat"?
12:12:24 <silver> more like "no time to learn lets code!" I guess
12:12:33 <chips> tdammers: no, as in "real programmers get projects done, and they don't waste time learning how to use emacs first, because they already have to waste a lot of time learning abstract algebra first"
12:12:37 <Feuerbach> watermind: enable ScopedTypeVariables and put parens around e::ErrorCall
12:12:37 <watermind> Feuerbach: or more simple... this     t = \x::Int -> 0
12:13:07 <chips> byorgey: why do you recommend FP haskell center over leksah?
12:13:13 <watermind> Feuerbach: ah right
12:14:38 <chips> byorgey: is there a "mode" for emacs that "evolves" -- at first it presents the bare minimum needed to get typing and editing, and then as you use it more and more, it presents little tips here and there on how to become more productive?
12:14:44 <mr-> [swift]_, what sort of lift are you interested in? The transformers kind? (Then I am not aware of any)
12:14:55 <[swift]_> mr-: yeah, the transformers kind
12:14:56 <Kron> chips: M-x rpg-elements
12:15:04 <Kron> no really I don't think emacs does that
12:15:15 <Kron> it sort of has that initially? in that it has a lot of features disabled for newbie safety
12:15:24 <Kron> and you have to enable them in your .emacs to use them
12:15:39 <Feuerbach> chips: actually, emacs, unlike vim, is very intuitive. You can just start typing, and you know many key bindnings from other UIs (which have borrowed them from emacs)
12:15:44 <Kron> (put 'narrow-to-region 'disabled nil)
12:15:44 <Kron>  etc. But otherwise, no
12:16:20 <Kron> Feuerbach: I've had great difficulty teaching people to 'just start' using emacs, unless I give them cua-mode
12:16:42 <Kron> people try to C-c and C-v to copy and paste and then they get lost in some mode and don't know how to C-g out.
12:16:57 <[swift]_> chips: one thing along those lines that emacs _will_ do is that by default, when you invoke an M-x command, it'll let you know what key combo could've gotten you the same results
12:16:58 <Kron> Also people find the kill ring and the undo behaviour extremely confusing
12:17:06 <Kron> "There's no redo? That's stupid"
12:17:23 <chips> Feuerbach: Kron please, make me feel bad for not wanting to learn emacs or vim. Kron: what is cua-mode?
12:17:27 <chips> [swift]_: ahh
12:17:33 <benmachine> I find undo doesn't undo the amount that I want
12:17:39 <benmachine> but then I'm a vim user
12:17:54 <benmachine> chips: can I make you feel bad for saying abstract algebra is a waste of time? :P
12:18:04 <benmachine> (but it's so *fun*)
12:18:05 <Kron> cua-mode is just C-x to cut, C-c to copy, C-v to paste. It has some extra rectangle text editing stuff, but it's mostly just a kind of parity mode to allow emacs to use the standard hotkeys other editors use
12:18:27 <chips> benmachine: no, because i am already learning abstract algebra
12:18:31 <chips> that's why i am scared of learning emacs and vim
12:18:46 <chips> because after abstract algebra, i have 200 more math things to learn
12:18:56 <chips> when will i ever have the time to learn emacs or vim?!
12:19:02 <Kron> chips, I feel like one really has to start learning emacs or vim at some point and it's easy to make up excuses
12:19:03 <chips> Kron: ah, i see.
12:19:13 <[swift]_> chips: IMO learning emacs or vim is an investment that will pay off in the long run, saving you a lot of time
12:19:18 <Kron> also it's not really mentally taxing... it's just rote repitition. Like learning to touch type
12:19:24 <Kron> you just have to keep typing until it starts to work for you
12:19:25 <[swift]_> chips: i don't know anyone who's done that who regrets it
12:19:32 <benmachine> I do think learning a good editor is more important than learning abstract algebra, programmingwise
12:19:34 <Kron> i'm with [swift]_ , it's a huge boon
12:19:50 <benmachine> that said, I know abstract algebra much better than I know my editor :(
12:19:51 <chips> benmachine: lies, i will beat you until you beg forgiveness from dijkstra
12:19:52 <Kron> even if you don't learn vim or emacs, at least find something like sublime and learn to use it really well
12:19:52 <|apriori|> hey guys.. did anyone of you use HaXml yet, and has a minimal example of how to use an instance of Text.XML.HaXml.XmlContent.Parser.XmlParser? documentation on that seems to be non-existing
12:20:05 <Kron> an editor is your sword, with it you shall slay all manner of dragons
12:20:35 <chips> Kron: sublime? why sublime if "not emacs or vim"?
12:20:57 <Kron> |apriori|: you're giving me a java PTSD flashback
12:21:09 <|apriori|> Kron, PTSD?
12:21:18 <chips> post traumatic stress disorder
12:21:26 <chips> *shudder*, java
12:21:30 <Kron> chips: I feel like there are some modern editors that are getting Quite Good, as good as vim and emacs potentially. I have actually never used sublime but I hear it's really well done?
12:21:47 <chips> Kron: oooh
12:21:57 <Kron> emacs is sort of eternal and forever extensible and vim is just vim, but I don't think there's no room for modern editors to pop up and do good work too
12:21:59 <rasfar> coming back to [swift]_'s question, how would you go about doing that? (implementing a generic lift for functions of arbitrary arity?) is that possible in Haskell?
12:22:00 * bearclaw_ is using jedit
12:22:16 <|apriori|> Kron, well, what I try to achieve.. is experimenting in replacing a java component, which reads xml files (yes, I hate xml as well. can't fight it though). Problem is, I need the way xsd->xml parser-> parser (for string, bytestring or other token types)
12:23:42 <trillioneyes> rasfar: I think something like that might be possible in restricted cases with type classes, but I don't think it's well-typed in general
12:24:01 <trillioneyes> I might be either underestimating or overestimating how useful type classes are
12:24:22 <chips> okay, fine, i will learn how to use emacs. just to let you all know by the way: i HATE YOU ALL.
12:24:34 <Kron> perhaps the (->) r monad? or... something?
12:24:34 <Kron> or is that a functor. I forget.
12:24:43 <Kron> chips: try cua-mode
12:24:52 <Kron> it'll generally keep you sane as you start out
12:24:52 <trillioneyes> I think you'd use the applicative instance in this case
12:24:54 <enthropy> rasfar: look at how Text.Printf.printf is done
12:25:00 <trillioneyes> Functors aren't enough and monads are unnecessary
12:25:01 <chips> Kron: no, i have to learn it properly
12:25:02 * benmachine cuddles chips
12:25:19 <Kron> alright, then be very careful about C-x, C-c and C-v
12:25:26 <trillioneyes> But yeah, Text.Printf has a really nice typeclass thingy that allows a function to accept an arbitrary number of arguments
12:25:32 <rasfar> thanks trillioneyes and enthropy; i'm just playing with liftM* and ap in ghci...
12:25:57 <rasfar> i've started using printf a lot instead of show; i should take a peek...
12:25:59 <trillioneyes> Because there's an "instance Builder a => Builder a -> String" or something
12:26:19 <enthropy> so the problem is that the arity of a function  f :: a -> b, isn't necessarily 1, since `b' can be another function
12:26:20 <Kron> you'll want to press them through sheer muscle memory and you shouldn't
12:26:20 <Kron> also, something to sort of keep in mind as you start to learn
12:26:20 <Kron> vim is meant to be very lean and very small and very very much just a text editor. It does one thing and does it well and that's edit text.
12:26:24 <Kron> So you'll see people running 5 to 10 vim instances, each for separate files, and run separate terminals to compile programs after editing the code in vim. That sort of thing
12:26:28 <trillioneyes> (I might have mangled it because I don't quite remember how it works, but it's a typeclass that inductively defines instances for every arity of function)
12:26:31 <Kron> emacs is monolithic, emacs is a framework
12:26:44 <enthropy> at some point you need to specify that "that is all the arguments I will accept"
12:26:50 <Kron> emacs has an elaborate buffer system (technically vim does too) and emacs users tend to use a single emacs instance that does everything
12:27:02 <benmachine> Kron: FYI three of your messages just arrived at once, maybe your connection is running a little slow
12:27:08 <Kron> we have one emacs that not only has all our source code files inside it as buffers, we even run internal shells and internal processes
12:27:13 <trillioneyes> enthropy: you can do this with something like f a b c d :: Int
12:27:23 <enthropy> so that's why I think people are happy with   f <$> x <*> y <*> z
12:27:28 <Kron> I run haskell 'inside' emacs, along with all my haskell files, and all my assignments, and all my configs, and everything
12:27:36 <enthropy> instead of something like    endLift (liftN f x y z)
12:27:40 <Kron> benmachine: maybe it is, do tell me if I'm getting spammy
12:27:56 <benmachine> Kron: oh, that wasn't my concern at all, I just meant "probably the first two got delayed"
12:28:14 <Kron> okay! Anyway, lazily getting to my final point:
12:28:43 <Kron> chips, try not to open up several emacs processes for several files. It's not a great habit and I see some newbies do it.
12:29:00 <Kron> Run one emacs and learn to C-x C-f in it, or perhaps even run an emacs server.
12:29:26 <Kron> Emacs servers are like monolithic daemon processes and you can create a million emacs clients that link to it on the backend and all share the same buffer pool and the like, really damn useful
12:29:29 <Kron> I'm gonna shut up now
12:29:51 <rasfar> class PrintfType t where
12:29:51 <rasfar>     spr :: String -> [UPrintf] -> t
12:30:25 <rasfar> the variable length arguments somehow become a list?
12:31:14 <enthropy> rasfar: look at the instances for PrintfType
12:32:04 <trillioneyes> instance (PrintfArg a, PrintfType r) => PrintfType (a -> r)
12:33:23 <rasfar> class PrintfArg a where
12:33:24 <rasfar>     toUPrintf :: a -> UPrintf
12:33:40 <rasfar> data UPrintf = UChar Char | UString String | UInteger Integer Integer | UFloat Float | UDouble Double
12:33:52 <enthropy> that part isn't as important
12:35:12 <rasfar> no type system extensions needed, it seems
12:37:50 <rasfar> so that instance declaration you quoted trillioneyes, that actually covers all arities, since the r in the constraint can be (*->*)?
12:38:52 <trillioneyes> Well, it can be another function
12:39:07 <trillioneyes> It needs to have kind *, but it can be of the form (a -> b) for types a and b
12:39:11 <trillioneyes> Which I think is what you meant
12:39:39 <logic_prog> is there a way to use _regex_ as a primitive in packrat parsers
12:39:39 <rasfar> yeah that's what I meant; I thought a function always had a kind with an -> in it...
12:40:16 <trillioneyes> Functions have kind *, but they have a TYPE with a -> in it
12:40:26 <trillioneyes> (Or well, the TYPES of functions have kind *)
12:40:44 <benmachine> id :: a -> a :: *
12:40:51 <rasfar> what has kind  * -> *  again?
12:40:54 <benmachine> Maybe
12:41:00 <benmachine> Either String
12:41:12 <benmachine> anything that needs another type before it becomes a real type
12:42:06 <rasfar> okay, thanks. so function types a->b->...->z are already "real types", but not ADT constructors?
12:42:41 <rasfar> oops, Maybe isn't a constructor, I take that back
12:42:51 <nooodl> what has kind (* -> *) -> * ?
12:43:12 <benmachine> Maybe is a type constructor, by contrast to Just which is a value constructor
12:43:21 <rasfar> I'd guess Maybe (Maybe a) but probably the associativity is wrong
12:43:33 <benmachine> Maybe (Maybe a) :: *
12:43:41 <benmachine> it's a complete type, it has values, so it has kind *
12:43:58 <benmachine> there aren't any things in the standard library that have that kind, but it's easy to define one
12:43:58 <rasfar> oh!... Maybe a :: *  but  Maybe :: * -> *
12:44:05 <benmachine> rasfar: precisely
12:44:10 <jophish_> Is it possible to write specialised instance declarations?
12:44:24 <benmachine> nooodl: newtype Mu f = In { out :: f (Mu f) }
12:44:48 <benmachine> nooodl: or, for a less magical example, newtype Action f = MkAction { runAction :: f () }
12:44:48 <nooodl> benmachine: cool
12:44:55 <jophish_> for example, instance Class (Foo a) where ...
12:45:02 <Twey> Using reactive-banana, can I delay an Event by one input?  I'm trying to implement mouse dragging, so I need to know the difference between the current mouse position and the mouse position when the event last fired
12:45:03 <jophish_> and instance Class (Foo Int) where ...
12:45:06 <nooodl> ah yeah
12:45:14 <benmachine> jophish_: those are overlapping instances
12:45:29 <benmachine> jophish_: there is an extension OverlappingInstances which allows them, but I don't recommend it
12:45:45 <Twey> That is, when the first event comes in nothing happens, then when the next event comes in the first event is emitted, et cetera
12:45:47 <jophish_> what's the procedure for specialisation then?
12:45:48 <rasfar> could the SPECIALISE pragma help?
12:46:20 <nooodl> hmmm. if kinds K and L are "inhabited", is K -> L also?
12:46:45 <benmachine> nooodl: all kinds are inhabited, I think
12:46:47 <jophish_> rasfar: I don't think that's exactly what I meant
12:47:07 <nooodl> hm probably
12:47:40 <benmachine> by e.g. constant type functions
12:47:41 <rasfar> jophish_: kay
12:48:02 <jophish_> For example, I have a vector class data Vector a = Vector a a a a, and I want to make it an instance of storable. alignment would generally be the alignment of a. but I may want to fore Vectors of Float with an alignment of 16 bytes instead of 4 bytes (alignof float) for use with SIMD instructions
12:48:30 <rasfar> I see.
12:48:40 <merijn> jophish_: You should tackle that differently
12:48:59 <merijn> jophish_: You should do "instance Storable a => Storable (Vector a) where"
12:49:20 <merijn> jophish_: That says "Vector a" is only Storable if 'a' is Storable, then you can use the Storable instance of 'a' to figure out alignment
12:49:31 <jmcarthur> jophish_: i would use a newtype wrapper around Float to decide what alignment to use, to expand on what merijn is saying
12:49:43 <jophish_> merijn: but the alignment of Float is 4, but I'd like the alignment of Vector Float to be 16
12:49:44 <benmachine> or a newtype wrapper around Vector Float, is also an option
12:49:48 <jmcarthur> jophish_: Vector (Align16 Float)
12:50:01 <jmcarthur> jophish_: ah yeah, or   Align16 (Vector Float)
12:50:08 <jmcarthur> jophish_: a generic Align16 could work for either
12:50:28 <jophish_> Ah, I see
12:50:57 <jophish_> I'm not sure how Vector (Align16 Float) would work, wouldn't alignment be larger than sizeof?
12:51:43 <merijn> jophish_: newtype don't exist at runtime
12:52:23 <jophish_> I think I may be misunderstanding how Vector (Align16 Float) is to be used
12:52:26 <merijn> jophish_: newtypes tell the compiler to pretend something is a new type (hence the name), without adding a runtime representation for that type
12:52:31 <jophish_> sure, I get that
12:52:51 <merijn> jophish_: You would make a newtype Align16 and implement a Storable instance for that which specifies 16
12:52:52 <jophish_> I see how instance Align16 a => Storable a would work
12:53:10 <jmcarthur> jophish_: no, it would be   instance Storable a => Storable (ALign16 a) where
12:53:15 <merijn> No, you'd do "instance Storable a => Storable (Align16 a) where"
12:53:33 <merijn> jophish_: Then inside the storable instance you can decide (based on 'a') to align to 16 or not
12:53:36 <jophish_> ah of course
12:53:45 <merijn> jophish_: Now when you use that inside vector you'll get back 16
12:54:30 <merijn> jophish_: It's very common to use newtypes like that to provide an alternative implementation of an existing class (say you don't like a types Ord instance, just newtype and create a new instance for the newtype)
12:54:46 <zikzak> Hey! I am new to Haskell and trying to play around with the ad library, and specifially the "diffs" function. Why can't I define a helper function "g1 f = diffs f 1.0" but "g2 = diffs (\x -> x*x) 1.0" works?
12:55:20 <jophish_> what if sizeOf myVector = 4 * (min (sizeOf elem) (alignment elem))
12:55:38 <jophish_> sizeOf (Vector elem _ _ _) = *
12:56:07 <jophish_> That doesn't seem like such an odd definition of sizeOf
12:57:53 <supki> zikzak: you'll need explicit type signature; GHC does not infer rank-2 types
12:58:36 <zikzak> supki: hmm, let me check what rank-2 types are ;-)
12:58:52 <jmcarthur> jophish_: do you mean max instead of min?
12:59:00 * hackagebot snaplet-acid-state 0.2.6 - acid-state snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-acid-state-0.2.6 (DougBeardsley)
12:59:01 <jophish_> err, yes
12:59:56 <jmcarthur> jophish_: if you define your storable instance for vector that way, it means there is a difference between   Align16 (Vector a)  and  Vector (Align16 a). you may intend that, but i figure i should point it out
13:00:24 <jophish_> yeah, that's what I was questioning
13:00:32 <jophish_> It seems sensible to use Align16 at the outermost level
13:00:49 <jmcarthur> ultimately it depends on what you need, not on what we say :)
13:00:52 <jmcarthur> anyway, g2g
13:00:54 <jophish_> and have it's definition take into account the alignment of the inner instance
13:00:59 <jophish_> goodnight jmcarthur
13:03:39 <zikzak> supki: Which explicit type signature would work in this case? If I use "f :: (Num a) => a -> a; f x = x*x", then I should also be able to write "g1 :: (Num a) => (a -> a) -> [a]", but that doesn't work either...
13:04:01 * hackagebot wai-static-pages 0.2.2.0 - generate static html pages from a WAI application  http://hackage.haskell.org/package/wai-static-pages-0.2.2.0 (GregWeber)
13:10:31 <zikzak> http://lpaste.net/97019: What is the missing type signature to make "g1" work? Thanks for any help!
13:14:31 <xedir> #haskell.de
13:14:38 <xedir> ups
13:14:51 <goraci> hi there - i have a newbie question ) ">>"  what exactly this operator is doing ? i read Snap framework code examples and there it is -- handleLogout = logout >> redirect "/"
13:15:12 <donri> zikzak: load it in ghci and see :type g1 ?
13:15:29 <abitlost> goraci: http://learnyouahaskell.com/a-fistful-of-monads
13:15:36 <zikzak> donri: Well, the problem is it doesn't compile...
13:15:49 <zikzak> I should have been more explicit
13:15:57 <goraci> abitlost: in couple of words plz ))
13:16:10 <donri> goraci: it combines the monadic effects of the arguments, ignoring the result of the first argument
13:16:36 <Iceland_jack> goraci: 'x >> y' is the same as 'do x; y'
13:16:37 <xedir> Do you guys think you can help me out with one of my uni tasks, i dont completely get what i have to do there :P
13:16:42 <donri> @where dmr for zikzak
13:16:42 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
13:16:43 <zikzak> Some of the error message: " `t' is a rigid type variable bound by           the inferred type of g1 :: Fractional a => t -> [a] at..."
13:16:45 <goraci> so in human words ignore result of logout and proceed to redirect ?
13:17:21 <Iceland_jack> goraci: If you want to print "hi" and then "bye" you can do:
13:17:21 <Iceland_jack>     putStrLn "hi" >> putStrLn "bye"
13:17:31 <Iceland_jack> Nothing complicated
13:17:48 <Iceland_jack> xedir: Sure, post ahead
13:18:00 <goraci> Iceland_jack: ok that sounds pretty simple example thanks )
13:18:21 <Iceland_jack> It's different with other monads, but for IO it only sequences actions
13:18:31 <xedir> Okay, we should make a dictionary, therefore we sould create a data type dictionary
13:18:47 <xedir> this one should contain tuples with 2 strings, one german word and the english one
13:18:49 <Iceland_jack> and
13:18:49 <Iceland_jack>     a >> b >> c
13:18:49 <Iceland_jack> is equivalent to
13:18:49 <Iceland_jack>     do a
13:18:52 <Iceland_jack>        b
13:18:55 <Iceland_jack>        c
13:19:23 <statusfailed> if I have a Monad transformer with an unspecified 'm', ghci lets me run it and gives a result- is it picking IO by default?
13:19:35 <xedir> data Dictionary    :: String -> Stirng
13:19:37 <Iceland_jack> statusfailed: yes
13:19:45 <statusfailed> thanks :)
13:19:46 <xedir> this is what i
13:19:46 <xedir> ve got so far
13:19:58 <Iceland_jack> xedir: That is neither valid syntax nor a tuple :)
13:20:04 <xedir> cO
13:20:10 <xedir> but..^^
13:20:17 <Iceland_jack> (a, b) ← this is a tuple
13:20:24 <Iceland_jack> You can use a type synonym
13:20:24 <Iceland_jack>     type Dictionary = (String, String)
13:20:45 <xedir> would it be data Dictionary = (a,b) then?
13:20:56 <Iceland_jack> No it would be what I just posted
13:21:10 <donri> you may actually want Map, though
13:21:13 <Iceland_jack> (a, b) is an example of a tuple type if a and b are tuples
13:21:25 <goraci> Iceland_jack: in what cases better to use >> ? it's just a shortcut then
13:21:26 <Iceland_jack> donri: (probably not for this school execise)
13:21:29 <Iceland_jack> goraci: Yes
13:21:32 <Iceland_jack> or well
13:21:54 <Iceland_jack> Just be aware that do-notation desugars into (>>) and (>>=)
13:22:07 <goraci> ok
13:22:13 <Iceland_jack> and use do-notation for now, sometimes (>>) can be nice if you only have two commands
13:22:23 <xedir> okay, the thing i dont really get is, when i just write down data Dictionary	= (String, String) would this be enough to make this whole tuple list for the dictionary=
13:22:38 <Iceland_jack> xedir: That's invalid syntax
13:22:45 <donri> >> is nicer for oneliners
13:23:05 <Iceland_jack> You can either write:
13:23:05 <Iceland_jack>     type Dictionary = (String, String)
13:23:05 <Iceland_jack> like I said before
13:23:20 <xedir> mh, can you give me a hint of valid syntax would look like?
13:23:30 <Iceland_jack> xedir: please read what I say
13:23:39 <Iceland_jack> or you can do
13:23:39 <Iceland_jack>     newtype Dictionary = Dictionary (String, String)
13:23:39 <Iceland_jack> or
13:23:39 <Iceland_jack>     data Dictionary = Dictionary (String, String
13:23:42 <Iceland_jack> )
13:24:00 <xedir> ah okay, not data - its type^^
13:24:01 <Iceland_jack> the latter two ways create a new type constructor
13:24:10 <xedir> okay, thanks
13:24:10 <Iceland_jack> type doesn't create a new type, just a synonym
13:24:15 <xedir> that makes sense now^^
13:24:15 <donri> are you sure you're even supposed to make your own type here
13:24:27 <xedir> yes
13:24:46 <donri> a dictionary of only a single word isn't that useful...
13:24:55 <donri> maybe you want a list of pairs?
13:25:04 <Iceland_jack> donri: That's probably more like it
13:25:06 <xedir> its a german word and just for the task one english word
13:25:19 <Iceland_jack> <xedir> this one should contain tuples with 2 strings, one german word and the english one
13:25:26 <Iceland_jack> So it should contain tuple*s*
13:25:34 <Iceland_jack> so you probably want a list of tuples
13:25:43 <Iceland_jack>     type Dictionary = [(String, String)]
13:25:50 <donri> spoilers ;)
13:25:54 <Iceland_jack> eep!
13:25:57 <xedir> yes, if you give me a second i can translate the task and poste it via pastebin
13:26:23 <Iceland_jack> You can further write:
13:26:23 <Iceland_jack>     type GermanWord  = String
13:26:23 <Iceland_jack>     type EnglishWord = String
13:26:23 <Iceland_jack>     type Dictionary  = [(GermanWord, EnglishWord)]
13:26:24 <xedir> yes, a list of tuples ;)
13:26:26 <Iceland_jack> if you want to
13:27:07 <Iceland_jack> Of course using type synonyms you haven't *defined* anything new, you've just introduced a new name for String and [(String, String)]
13:27:18 <Iceland_jack> but that's possibly what you want
13:28:29 <xedir> okay, brb in 1 minute ;)
13:31:53 <xedir> okay, here it is - i hope you can deal with it :P http://pastebin.com/t1QRv6fy
13:31:57 <mauke> The paste t1QRv6fy has been copied to http://lpaste.net/97020
13:33:48 <Iceland_jack> xedir: ok you've got the solution to the first point
13:33:52 <Iceland_jack> and the second
13:34:16 <donri> a bit ambiguous there if you're expected to create a new type or not
13:34:16 <xedir> okay, i will take the one with [(String, String)]
13:34:22 <Iceland_jack> but it sounds like you don't have much experience with Haskell, you may want to look at Learn You a Haskell to get a better feed for it:
13:34:22 <Iceland_jack> @where lyah
13:34:23 <lambdabot> http://www.learnyouahaskell.com/
13:34:34 <Iceland_jack> *feel
13:35:22 <xedir> thats definately something i'm going to do but we only had haskell lectures this week and cuz of some christmas preparation i just found time to do it now
13:35:49 <xedir> but bad thing is, this task is to be handed in tomorrow 12:00 and gives points for the exams :/
13:36:37 <Iceland_jack> Sure, I'm not willing to give you the answer but I can help walk you through it
13:36:40 <zikzak> Is the compile error in http://lpaste.net/97019 a monomorphism restriction? How can I fix it? I don't get it...
13:36:48 <Iceland_jack> Do you know how to define a function in Haskell xedir?
13:38:07 <xedir> you mean like square 2?
13:38:22 <Iceland_jack> sure, or any function that deals with lists
13:38:35 <xedir> or with commands like map or fold?
13:38:56 <Iceland_jack> I just need to get a sense of your level
13:39:07 <Iceland_jack> could you write the function length?
13:39:09 <xedir> thats propably the biggest problem in this task
13:39:55 <Iceland_jack> insert is very easy to program
13:40:00 <xedir> propably not without google and 30 minutes of time :P
13:40:02 <Iceland_jack> Do you know what [] and (x:xs)
13:40:06 <Iceland_jack> are
13:40:29 <xedir> [] indicates lists
13:40:35 <Iceland_jack> (empty list) yes :)
13:40:38 <xedir> and (x:xs) is like content of it?
13:40:59 <Iceland_jack> > [1,2,3,4] -- You know what this is right?
13:41:00 <lambdabot>  [1,2,3,4]
13:41:01 <mrwonko> Hi, is there some easy way to turn Either a [b] into [Either a b]
13:41:01 <abitlost> (first_element:rest of list), where rest of list could even be [], yes
13:41:10 <mrwonko> [] is the empty list
13:41:50 <mrwonko> > :t (:)
13:41:51 <lambdabot>  <hint>:1:1: parse error on input `:'
13:41:56 <Iceland_jack> @ty (:)
13:41:57 <lambdabot> a -> [a] -> [a]
13:42:01 <Iceland_jack> > 1:2:3:4:[] -- xedir: This is what [1,2,3,4] turns into
13:42:02 <lambdabot>  [1,2,3,4]
13:42:15 <pavonia> zikzak: Floating a => (a -> a) -> [a] doesn't work?
13:42:16 <mrwonko> (:) :: a -> [a] -> [a]
13:42:28 <Iceland_jack> > 1:(2:(3:(4:[]))) -- xedir: This is how it's associated
13:42:29 <lambdabot>  [1,2,3,4]
13:43:38 <xedir> okay
13:43:49 <xedir> so this would be like valid syntax?
13:43:55 <Iceland_jack> Yes absolutely
13:44:12 <Iceland_jack> If you have a list ‘xs’, you can add an element ‘x’ to it by writing:
13:44:12 <Iceland_jack>     x:xs
13:44:17 <zikzak> pavonia: Nope. This is what I had tried... I guess it's because of the type of "diffs", which is "diffs :: Num a => UU a -> a -> [a]", but I don't know how to handle the "UU"
13:44:31 <Iceland_jack> xedir: Now imagine that list ‘xs’ is a Dictionary (list of tuples)
13:44:40 <Iceland_jack> and that ‘x’ is a new entry (tuple of words)
13:45:38 <pavonia> zikzak: What version of that package are you using?
13:46:00 <apo_> Iceland_jack: set of tuples, maybe :P
13:46:11 <Iceland_jack> apo_: That's not helping
13:46:23 <zikzak> pavonia:  hmm, how do I find out again? I am currently on Windows
13:46:45 <pavonia> ghc-pkg list ad
13:47:05 <apo_> Iceland_jack: having more than one value for a key won't help you much, either.
13:47:10 <xedir> would it be something like Dictionary (x:Dictionary)
13:47:26 <pavonia> zikzak: I'm asking because in the latest version the type is Num a => (forall s. Mode s => AD s a -> AD s a) -> a -> [a]
13:47:40 <Iceland_jack> apo_: Read the link posted, this is an assignment for school, those are the requirements and xedir isn't very familiar with lists
13:47:52 <zikzak> pavonia: Ah, I used "cabal info". I am using version 3.4
13:48:52 <zikzak> pavonia: And I don't know how to read "(forall s. Mode s => AD s a -> AD s a)" or what I would need to do in order to get g1 to work...
13:49:09 <Iceland_jack> xedir: Let's take an example of single tuple:
13:49:10 <Iceland_jack> > ("Pfeife", "pipe")
13:49:11 <lambdabot>  ("Pfeife","pipe")
13:49:15 <pavonia> zikzak: Could you add the full error message to the paste, please?
13:49:41 <zikzak> pavonia: Sure. Just to clarify: "type UU a = forall s. Mode s => AD s a -> AD s a"
13:50:16 <Iceland_jack> xedir: We can create a dictionary from that single entry:
13:50:16 <Iceland_jack> > [("Pfeife", "pipe")] :: Dictionary
13:50:17 <lambdabot>  [("Pfeife","pipe")]
13:50:37 <Iceland_jack> Does that make sense?
13:51:42 <xedir> okay, so we would have
13:51:48 <zikzak> pavonia: I have updated http://lpaste.net/97019
13:51:49 <xedir> data Dictionary    = [(String, String)]
13:51:53 <Iceland_jack> xedir: (no, type)
13:51:57 <xedir> to create the data type
13:52:08 <xedir> oh, my fault^^
13:52:12 <Iceland_jack> No problem
13:53:09 <Iceland_jack> xedir: We can simply use (:) to add an entry to our dictionary
13:53:21 <xedir> and then  [("Pfeife","pipe")]  creates the first element of the []
13:53:23 <Iceland_jack> Just like we can use (:) to add a character to string
13:53:36 <Iceland_jack> Yes, but you'll have to add it using (:)
13:53:47 <Iceland_jack> @let emptyDictionary = []
13:53:48 <lambdabot>  Defined.
13:54:00 <Iceland_jack> @let pipeEntry = [("Pfeife", "pipe")]
13:54:00 <lambdabot>  Defined.
13:54:11 <Iceland_jack> Now you can write:
13:54:11 <Iceland_jack> > pipeEntry : emptyDictionary
13:54:13 <lambdabot>  [[("Pfeife","pipe")]]
13:54:16 <Iceland_jack> oops
13:54:19 <Iceland_jack> @let pipeEntry = ("Pfeife", "pipe")
13:54:20 <lambdabot>  .L.hs:155:1:
13:54:20 <lambdabot>      Multiple declarations of `pipeEntry'
13:54:20 <lambdabot>      Declared at: .L.hs:154:1
13:54:20 <lambdabot>                   .L.hs:155:1
13:54:31 <Iceland_jack> @let pipeentry = ("Pfeife", "pipe")
13:54:32 <lambdabot>  Defined.
13:54:38 <Iceland_jack> > pipeentry : emptyDictionary -- there we go
13:54:39 <lambdabot>  [("Pfeife","pipe")]
13:55:26 <Iceland_jack> and we can add another word
13:55:26 <Iceland_jack> > ("Pferdeschwanz", "ponytail") : pipeentry : emptyDictionary
13:55:28 <lambdabot>  [("Pferdeschwanz","ponytail"),("Pfeife","pipe")]
13:55:35 <Iceland_jack> And not we have two entries in our dictionary
13:56:03 <xedir> thats cool
13:56:21 <xedir> and then use the filer function to search
13:56:42 <pavonia> zikzak: Looking at the types, I'm wondering why r1 works :S
13:56:47 <Iceland_jack> So now you use that knowledge and fill in the blanks (???):
13:56:47 <Iceland_jack>     insert :: Dictionary -> (String, String) -> Dictionary
13:56:47 <Iceland_jack>     insert dictionary entry = ???
13:57:36 <mrwonko> @ty filter
13:57:37 <lambdabot> (a -> Bool) -> [a] -> [a]
13:57:39 <zikzak> pavonia: Ha! Not another problem!
13:57:46 <pavonia> zikzak: And something like Fractional a => UU a -> [a] doesn't work?
13:59:18 <xedir> insert dictionary entry = ("Auto":"Car")
13:59:38 <xedir> ("Auto","Car)
13:59:45 <xedir> not a colo
13:59:52 <xedir> +n
13:59:59 <zikzak> pavonia: Hmm, I need to figure out how to import UU first...
14:00:28 <Iceland_jack> xedir: I'm not sure how much I can help you to be honest
14:00:40 <Iceland_jack> Have you programmed before?
14:01:00 <xedir> xD
14:01:07 <Sculptor> VCRs don't count
14:01:10 <xedir> Java and a bit C#
14:01:25 <rdevilla> you have finally arrived at a good language
14:01:28 <jle`> xedir: compare to this: doubleMe x = x * 2
14:01:42 <Iceland_jack> xedir: in the ‘insert’ function you should use ‘dictionary’ and ‘entry’ to form a new dictionary
14:01:44 <jle`> you're writing a function that takes an input and does something to the input
14:01:54 <pavonia> zikzak: Yeah, not sure where you took that type from. As an alternative: Fractional a => (forall s. Mode s => AD s a -> AD s a) -> [a]
14:01:58 <Iceland_jack> You should not be writing anything like ("Auto", "car")
14:02:09 <xedir> -->: pipeentry : emptyDictionary <-- so this part is also needed for every new entry?
14:02:18 <Iceland_jack> no
14:02:46 <Iceland_jack> Let's say that
14:02:46 <Iceland_jack>     dictionary = [("Pfeife", "pipe")]
14:02:46 <Iceland_jack> and
14:02:46 <Iceland_jack>     entry = ("Pferdeschwanz", "ponytail")
14:02:50 <rdevilla> xedir: You need the emptyDictionary to signify the end of the list
14:03:07 <Iceland_jack> from that you want to create:
14:03:07 <Iceland_jack>     [("Pferdeschwanz", "ponytail"), ("Pfeife", "pipe")]
14:03:38 <twiceler> So I have some IO computations that I'd like to put into an ST-type monad.
14:04:02 <twiceler> Is it a sin to use unsafeSTtoIO? Should I define my own ST-ish monad with a different name?
14:04:17 <xedir> okay, so with emptdDictionard i just clarify that this new entry is put at the end of the list
14:04:31 <Iceland_jack> no you don't use emptyDictionary at all in the definition of insert
14:04:48 <Iceland_jack> Only the two arguments (dictionary, entry) and (:) which is called cons
14:05:37 <zikzak> pavonia: Thanks. I got it from http://hackage.haskell.org/package/ad-1.3.0.1/docs/Numeric-AD-Mode-Tower.html#g:3. Using your expanded signature, I get a different compiler error: "    Illegal symbol '.' in type     Perhaps you intended -XRankNTypes or similar flag to enable explicit-forall syntax: forall <tvs>. <type> "
14:06:38 <zikzak> pavonia: Ah, calling ghc exactly with that flag results in no further errors! Nice.
14:06:40 <enthropy> twiceler: yes it's bad. Better to make the ST-type calculations IO
14:07:17 <danilo2> Hi! Is it possible to use in Accelerate custom datatypes? I mean use them as follow: "x = MyDataType img; y = A.use x"?
14:07:18 <pavonia> zikzak: You can add a language pragma {-# LANGUAGE RankNTypes #-} at the very top of your module
14:07:24 <zikzak> pavonia: I don't quite understand this "forall ..." signature, but I'll have a look. I am already one step further, thanks to you!
14:07:39 <pavonia> you're welcome
14:07:58 <twiceler> enthropy: Well I want to provide an environment where I can ensure referential transparency of things, even though I'm using IO. so I think I'll need to use an unsafeSomething function
14:08:03 <zikzak> that works, thanks again!
14:08:50 <twiceler> danilo2: I'm not an expert on Accelerate, but at the very least I think it would be difficult
14:09:12 <twiceler> danilo2: An there's probably a better way
14:10:05 <danilo2> twiceler: I'm new to accelerate. I wnt to operate on images with "channels". What I mean - My Image datatype is simply Map String -> Channel (where Channel is Accelerate array)
14:10:13 <twiceler> enthropy: But I thought if I make my own ST-ish monad (and then use unsafePerformIO under the hood) then it wouldn't confuse people who think that I'm using only those built-in operations
14:10:33 <twiceler> do you mean Map String Channel?
14:10:36 <xedir> ah, i guess - i got it now. give me a second to clear up my mind^^
14:10:42 <Iceland_jack> xedir: Sure thing
14:10:47 <danilo2> twiceler: I'm just looking for the best representation - and I was thinking, that if I could use A.use with cutom datatypes, it would be cool :)
14:11:10 <danilo2> twiceler: of course, sorry for that, I mean Map String channel
14:11:27 <twiceler> danilo2: do you know how many channels you have? Is it constant?
14:12:00 <danilo2> twiceler: No, it could be from lets say 3 ("red", "green" ad "blue") to even 1024 with custom names :)
14:12:20 <twiceler> danilo2: But the idea, I'm guessing, is that you process each independently?
14:12:29 <enthropy> twiceler: if you make your own ST-ish monad and use unsafeIOtoST that's indirectly providing an unsafePerformIO... that can cause confusion unless your IO thing is special
14:12:59 <danilo2> twiceler: not always - If you want to create "luminance" channel - youre looking if the r,g and b are available ad you are combining them to create the final one
14:13:01 <xedir> Iceland_jack: lets say, i have carEntry = ("Auto","car") i create a tuple called carEntry with the two strings Auto and car - amd when i say carEntry : emptyDictionary i fill the tuple carEntry into the [] of emtyDictionary
14:13:23 <Iceland_jack> xedir: Yes
14:13:33 <xedir> Iceland_jack yay ;)
14:13:38 <Iceland_jack> You've kind of answered the question xedir :)
14:13:51 <xedir> Iceland_jack and why did you write ("Pferdeschwanz", "ponytail") : pipeentry : emptyDictionary
14:13:51 <Iceland_jack> so if you have
14:13:51 <Iceland_jack>     insert dictionary carEntry = ...
14:14:04 <Iceland_jack> xedir: That was just to show how lists work
14:14:05 <xedir> why the : pipeentry :
14:14:10 <twiceler> enthropy: Well, my IO thing is special. I should be able to provide the semantics (is that right?) of ST monad with what I'm doing. But I don't want to lie by saying it's literally ST monad perhaps
14:14:15 <xedir> ah okay
14:14:16 <Iceland_jack> xedir: Imagine each number is an entry
14:14:24 <Iceland_jack> > 1 : 2 : 3 : [4,5,6]
14:14:25 <lambdabot>  [1,2,3,4,5,6]
14:14:56 <Iceland_jack> So if you have a ‘dictionary’ [2,3,4,5] and you want to insert a new entry ‘1’ then you'd do
14:14:56 <Iceland_jack> > 1 : [2,3,4,5]
14:14:57 <lambdabot>  [1,2,3,4,5]
14:15:10 <xedir> okay
14:15:17 <twiceler> danilo2: It sounds like you might benefit from making a function of the sort:
14:15:20 <Iceland_jack>     insertNumber dict num = num : dict
14:15:29 <Iceland_jack> Does that implementation make sense xedir?
14:15:38 <Iceland_jack> @let insertNumber dict num = num : dict
14:15:39 <lambdabot>  Defined.
14:15:44 <Iceland_jack> > insertNumber [2,3,4,5] 1
14:15:45 <twiceler> danilo2: Map String (Array DIM2 e) -> Array DIM3 e if you know what I mean
14:15:46 <lambdabot>  [1,2,3,4,5]
14:15:53 <Iceland_jack> > inertNumber (insertNumber [2,3,4,5] 1) 0
14:15:54 <lambdabot>  Not in scope: `inertNumber'
14:15:54 <lambdabot>  Perhaps you meant `insertNumber' (line 161)
14:15:57 <Iceland_jack> > insertNumber (insertNumber [2,3,4,5] 1) 0
14:15:59 <lambdabot>  [0,1,2,3,4,5]
14:16:05 <Iceland_jack> > insertNumber (insertNumber (insertNumber [2,3,4,5] 1) 0) (-1)
14:16:07 <lambdabot>  [-1,0,1,2,3,4,5]
14:16:16 <Iceland_jack> xedir: (that's how you'd add to your dictionary)
14:16:28 <xedir> okay, so basically, the insert part ist just x <- thats insertet : <- inserts [Xn] <- what is inserted in
14:16:40 <Iceland_jack> Yes that's right
14:16:54 <danilo2> twiceler: Hmm, ok, but then I have to remember position of channels. Woudl it not be better to simply extract the channels and use ZipWith (ZipWith3 in luminance example) ?
14:17:16 <Iceland_jack> so the implementation of insert should be:
14:17:17 <Iceland_jack>     insert :: Dictionary -> (String, String) -> Dictionary
14:17:17 <Iceland_jack>     insert dict newEntry = newEntry : dict
14:17:22 <Iceland_jack> does that make sense?
14:17:29 <twiceler> twiceler: Well, I'm just trying to reason from the fact that you said you could have 1024 channels :)
14:18:15 <danilo2> twiceler: Just because in the domain we would use it, there would be no sense to use more than 1024 channels (there is no up constrain on it).
14:19:06 <danilo2> twiceler: I was just thinking If would be possible to use the function A.use on a channel instance (if Channel would be a datatype packing accelerate array)
14:19:10 <twiceler> danilo2: I think I need a better idea of what you're doing with these channels with accelerate.
14:20:17 <danilo2> twiceler: Ok, so lets imaginge you;ve got an image with channels (like in exr format). Each channel represents something - like color, shadows, relfections , refractions etc.
14:20:21 <twiceler> danilo2: but the long story short is it's much easier to bend to Accelerate's will than to try to make it bend to your will
14:20:37 <xedir> Iceland_jack sry, i think my irc keeps freezin^^
14:20:50 <danilo2> twiceler: then you can simply create fucntions combining particular channels - is it clear now ?
14:21:11 <Jesin> Just wrote and tried to run a statistical simulation
14:21:27 <Jesin> it filled up my RAM; turns out I forgot "take numSamples"
14:21:29 <twiceler> danilo2: So those functions... do they involve any number of channels? How can you combine them?
14:21:31 <danilo2> twiceler: I do not want to bend it :) I do not know it enough to know it it sounds like bending :) If accelerate does not allow me to use my datatype "Channel" nside of Acc computations, I will not do it
14:21:41 <xedir> Iceland_jack that makes sense but whis this everytime someone wants to add something to the dictionary list he would have to: first create the entry and second add it to the list
14:22:15 <Iceland_jack> xedir: That's how things are done and that's what your teacher is asking for :)
14:22:23 <danilo2> twiceler: Those functions would be written by a user - so I do not need to combine them. You should think about them as functions, that take Image (the Map String Channel) and returning a new Channel
14:22:24 <xedir> okay :D
14:22:43 <Iceland_jack> You can then use so-called higher-order functions to add (say) a list of words to your dictionary
14:22:44 <danilo2> twiceler: then you could put this new channel inside Image with a new name
14:22:54 <danilo2> twiceler: does it make sense to you?
14:23:24 <xedir> Iceland_Jack so this would be kind of the code for it right now:
14:23:25 <twiceler> danilo2: Maybe? If the user writes those functions, then it seems like the user will have to interact with accelerate
14:23:29 <xedir> type Dictionary	= [(String, String)]
14:23:33 <xedir> insert Dictionary neuerEintrag = neuerEintrag : Dictionary
14:23:39 <Iceland_jack> Yes
14:23:42 <twiceler> danilo2: So then this whole thing is their problem to deal with!
14:23:46 <Iceland_jack> along with the type annotation
14:23:47 <xedir> ..
14:23:50 <xedir> thats so easy
14:23:52 <xedir> i should be ashamed^^
14:23:52 <Iceland_jack> Mmmhm
14:23:55 <Iceland_jack> :)
14:24:03 <Iceland_jack> You could also create a new type synonym for Entry
14:24:11 * hackagebot ihaskell 0.2.0.1 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.2.0.1 (gibiansky)
14:24:14 <Iceland_jack>     type Entry = (String, String)
14:24:14 <Iceland_jack>     type Dictionary = [Entry]
14:24:18 <danilo2> twiceler: heh ok, but I have to prepare a basic library also - so I'm kind of first user :)
14:24:29 <Iceland_jack> Then the type of insert would be:
14:24:29 <Iceland_jack>     insert :: Dictionary -> Entry -> Dictionary
14:24:36 <xedir> oh, insert :: Dictionary -> (String, String) -> Dictionary  would also be needed?
14:24:42 <Iceland_jack> It's not needed
14:24:51 <Iceland_jack> but it shows what the function is for
14:24:57 <danilo2> twiceler: Image is just a map of arrays. We can write dunctions like "luminance" that combine some of them and create new arays with new names - nothing more
14:24:57 <Iceland_jack> It's documentation
14:25:00 <xedir> okay
14:25:09 <xedir> ah, like EBNF?^^
14:25:24 <Iceland_jack> Hm not really
14:25:53 <twiceler> danilo2: Ah okay! So luminance would be implemented with A.zipWith3, right?
14:26:36 <danilo2> twiceler: I was thinking about such solution. Maybe there is better? If not, I think A.zipWith3 is ok
14:27:15 <twiceler> danilo2: I think zipWIth3 is perfect
14:27:22 <xedir> well, type Dictionary	= [(String, String)]
14:27:45 <xedir> insert Dictionary neuerEintrag = neuerEintrag : Dictionary  - is this everything?^^
14:28:00 <Iceland_jack> Yes, but don't forget the type signature
14:28:10 <Iceland_jack> Which is included in the exercise
14:28:14 <danilo2> twiceler: Ok, but the question was (:P) : If "Channel" is not a type alias, but it is my DataType (which packs accelerate's array inside), could I use it with A.use or A.zip3 ?
14:28:26 <Iceland_jack> also xedir, ‘Dictionary’ must be in lower-case
14:28:48 <Iceland_jack>     insert dictionary neuerEintrag = neuerEintrag : dictionary
14:29:01 <danilo2> twiceler: type inferencer allows me to do it. I even see the type of "Acc (MyChannel Float)" as a type - but I want to know if is it wrong or should I avoid it
14:29:29 <xedir> okay, but what do you mean with the type signature?
14:29:44 <Iceland_jack>     insert :: Dictionary -> (String, String) -> Dictionary
14:29:44 <Iceland_jack> is a type signature
14:29:48 <twiceler> danilo2: OH I thought you wanted to "use" the whole image thing, not just a channel. that makes more sense
14:29:51 <Iceland_jack> And it should be above your function
14:29:57 <xedir> ah, okay
14:30:15 <xedir> i will upload a "final" version at pastebin later^^
14:30:21 <Iceland_jack> Okay
14:31:00 <xedir> uhm, when i say type Dictionary .... and later use insert dictionary should it really be lower case there?
14:31:12 <Iceland_jack> xedir: The *type* is capitalized
14:31:19 <xedir> okay
14:31:21 <Iceland_jack> a variable of that type isn't
14:31:29 <twiceler> danilo2: I'd just write a function called channelUse = A.use . accArrayofChannel
14:31:44 <twiceler> channelUse :: Channel -> Acc (Array DIM2 e)
14:31:53 <xedir> gotcha
14:32:28 <danilo2> twiceler: Ok, I would do it this way. By the way, why when I write "A.use mychan" type inferencer allows me to do it ?
14:32:30 <theOtherCat> hello there
14:33:27 <twiceler> danilo2: Beats me, too! My type inferencer (a.k.a. my head and looking at the docs) doesn't. Are you sure Channel isn't a type synonym?
14:33:34 <Sagi> hey people, I want to reproduce a couple of lines of the Prelude in my thesis to show the context for a proof. What would be the correct way to provide attribution for this (copied) code? Is there some web-version of the applicable BSD-license for Haskell online which I can refer to?
14:34:50 <xedir> okay, now for the search thingy i have this filter command ( filter :: (a -> Bool) -> [a] -> [a] ) is this the right one to use?
14:35:01 <theOtherCat> c n = length [t | t <- [2..n-1], t^3 `mod` n == 1 ]
14:35:01 <theOtherCat> i have a problem with a very simple function and don't understand why this leads to an error, see http://lpaste.net/97022
14:35:03 <Iceland_jack> Not necessarily, but you can use it
14:35:20 <Iceland_jack> theOtherCat: Parentheses around (t^3)
14:36:17 <Iceland_jack> theOtherCat: also replace length with genericLength from Data.List
14:36:29 <donri> Sagi: how about http://hackage.haskell.org/package/base-4.6.0.1/src/LICENSE or http://git.haskell.org/packages/base.git/blob/HEAD:/LICENSE but really you could link any source of the bsd3 license like http://opensource.org/licenses/BSD-3-Clause
14:36:32 <danilo2> twiceler: hmm, interesting, look: this is a part of my test code (it compiles and works): http://lpaste.net/97023
14:37:05 <Iceland_jack> xedir: Do you know guards?
14:37:06 <danilo2> twiceler: If i type y::Int, type inferencer tells me:  Couldn't match expected type `Int' with actual type `A.Acc (Channel a0)'
14:37:10 <xedir> no
14:37:14 <Iceland_jack> @src filter
14:37:15 <lambdabot> filter _ []     = []
14:37:15 <lambdabot> filter p (x:xs)
14:37:15 <lambdabot>     | p x       = x : filter p xs
14:37:17 <lambdabot>     | otherwise = filter p xs
14:37:22 <Sagi> donri: ah, that git url is nice, it should continue to work between versions (crosses fingers)
14:37:25 <Sagi> thanks!
14:37:29 <Iceland_jack> xedir: That definition uses guards (the pipes |)
14:38:06 <donri> Sagi: well possibly you should link the license for the version you got the code from
14:38:19 <donri> if you care about that
14:38:23 <Iceland_jack> xedir: it means ‘if 'p x' is True, return 'x : filter p xs'’
14:38:44 <Iceland_jack> You want to do something similar for search
14:38:46 <dmj`> anyone perchance know if a remote acid-state served over linux can communicate with an acid-client remotely through windows?
14:39:04 <theOtherCat> thanks iceland_jack. i didn't bother checking :t length
14:39:08 <Sagi> donri: hmm, well I guess that's true.
14:39:55 <Iceland_jack> xedir: This is a skeleton for how the code should work
14:39:55 <Iceland_jack>     search :: String -> Dictionary -> String
14:39:55 <Iceland_jack>     search german [] = ???
14:39:55 <Iceland_jack>     search german ((ger, eng):xs)
14:39:58 <Iceland_jack>       | ...       = ?
14:39:59 <xedir> Iceland_Jack okay, so when i type like Pferdeschwanz it should return true at the first place cuz this word would be in the list
14:40:01 <Iceland_jack>       | otherwise = ???
14:40:28 <Iceland_jack> xedir: [] means that the dictionary is empty
14:40:31 <Iceland_jack> so you should have an error there
14:41:25 <xedir> yes, we should reply a string if this is the case
14:41:34 <Iceland_jack> If you can't find it?
14:41:43 <xedir> well, if there is nothing found but thats also the case if the list is empty
14:41:45 <Iceland_jack> I mean in a real example you'd use Maybe String
14:42:14 <Iceland_jack> ok let's ignore the empty case then
14:42:30 <Iceland_jack> xedir: we have a tuple entry (ger, eng) in the skeleton code above
14:42:38 <xedir> yes
14:42:40 <Iceland_jack> and we want to compare the word "german" to "ger"
14:42:50 <Iceland_jack> if "german == ger" then we want to return "eng"
14:42:53 <xedir> yes, and return the eng
14:42:56 <xedir> ;)
14:42:58 <Iceland_jack> yes exactly
14:43:19 <Iceland_jack> otherwise we want to search the rest of the dictionary
14:43:40 <seanparsons> Is there a pre-existing Haskell library that does proper unicode escaping?
14:43:48 <Yuu-chan> Redone my game using lens. A little shorter and not really simpler =\
14:44:31 <xedir> okay, i got the skeleton so far *yay me*
14:44:49 <Iceland_jack> xedir: Do you know how to procede?
14:44:58 <seanparsons> I'm looking for something that takes 'ㄲ' and turns it into "\u3132".
14:46:03 <ion> What specific format do you want? json?
14:46:21 <pavonia> > "ㄲ"
14:46:22 <lambdabot>  "\12594"
14:46:43 <ion> ("\u3132" isn’t valid Haskell.)
14:47:42 <trillioneyes> > ['\\','u','3','1','3','2'] -- do you want this?
14:47:43 <lambdabot>  "\\u3132"
14:47:49 <seanparsons> trillioneyes: Yes, that.
14:47:58 <Fuuzetsu> Yuu-chan: Needs more lens.
14:48:13 <trillioneyes> I don't actually know how to do that, but hopefully now that it's been clarified other people should be able to help you better
14:48:42 <seanparsons> ion: Since I'm writing a JSON library, that would be helpful. :)
14:48:48 <trillioneyes> Maybe something like "\\u" ++ show (ord char)?
14:48:52 <seanparsons> Or at least appropriate.
14:48:55 <ion> seanparsons: http://hackage.haskell.org/package/aeson
14:48:59 <trillioneyes> But I don't know if ord does the right thing for unicode
14:49:16 <seanparsons> ion: Oh wow, I never would've known that had existed...
14:49:17 <xedir> Iceland_jack hmm
14:49:41 <Sagi> donri: thanks for your advice, I think I properly attributed it now.
14:49:42 <xedir> is search a function in haskell?
14:49:48 <Iceland_jack> Yes
14:49:49 <donri> Sagi: \o/
14:50:13 <Iceland_jack> @ty lookup
14:50:14 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
14:50:18 <donri> Iceland_jack: spoilers!
14:50:23 <xedir> okay, do i have to define the string i would like to search for as well like the entry thing?
14:50:24 <seanparsons> trillioneyes: I've got some terrifying showHex and fromEnum combo that does something similar, the wrinkle comes with surrogate pairs which would require a whole load of specialised code to handle.
14:50:30 <Iceland_jack> donri: Hey, xedir is not going to use that definition :)
14:50:39 <trillioneyes> hmmm
14:50:43 <Iceland_jack> xedir: That's what I wrote above as ‘german’
14:51:02 <xedir> you're having fun with me?^^
14:51:07 <seanparsons> ion: That was some sarcasm by the way. :) Pointing me at an existing library when I'm writing one is less than helpful.
14:51:09 <trillioneyes> Yeah, I have no idea what kinds of pitfalls will show up in converting unicode characters so I hope someone else can help you
14:51:14 <Iceland_jack> I'm procrastenating
14:51:31 <Iceland_jack>     search german ((ger, eng):xs)
14:51:31 <Iceland_jack> ‘german’ is the word you want to look for, ‘(ger, eng)’ is the current entry and ‘xs’ is the rest of the dictionary
14:51:47 <ion> seanparsons: Feel free to NIH a library, but you can use the string encoding from that.
14:51:57 <Iceland_jack> so if 'german ≠ ger' then we return: search german xs
14:52:27 <xedir> and this is automatically related to the dictionary list?
14:52:27 <seanparsons> ion: I've already been poking around inside the code for it, doesn't handle surrogate pairs.
14:52:40 <Iceland_jack> xedir: I'm not sure what you're asking
14:53:05 <xedir> is this line of code searching in the dictionary list?
14:53:18 <xedir> or does it need like further instructions what list to search in?^^
14:53:23 <seanparsons> In fact it even goes too far and tries to protect against XSS vulnerabilities, which is a bit insane.
14:53:32 <Iceland_jack> If I understand the question, yes
14:53:42 <Iceland_jack> @src filter
14:53:42 <lambdabot> filter _ []     = []
14:53:42 <lambdabot> filter p (x:xs)
14:53:43 <lambdabot>     | p x       = x : filter p xs
14:53:43 <lambdabot>     | otherwise = filter p xs
14:53:43 <xedir> Iceland_jack :P
14:53:50 <Iceland_jack> xedir: ↑ look hard at that definition
14:53:57 <Iceland_jack> it follows a similar pattern
14:55:08 <xedir> Iceland_jack okay, so this is searching for p in the list xs and compares it to the current x?
14:55:29 <Iceland_jack> it doesn't ‘compare’ it to x, p is a predicate
14:55:37 <Iceland_jack> so p might be p = even
14:55:43 <Iceland_jack> > filter even [1..100]
14:55:44 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
14:55:58 <xedir> yeah okay, i think i got this
14:57:00 <theOtherCat> cu & gn8
14:57:21 <nisstyre> > [2,4..]
14:57:23 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
15:00:07 <skypers> omg
15:00:17 <skypers> ErrorT simplifies my code A LOT
15:00:24 <xedir> okay, when i have the "search part" now, how does the return work?
15:00:25 <skypers> really nice m transformer
15:00:42 <xedir> that when i find the german word i return the english translation?
15:00:52 <skypers> > [2,10..]
15:00:53 <lambdabot>  [2,10,18,26,34,42,50,58,66,74,82,90,98,106,114,122,130,138,146,154,162,170,1...
15:00:55 <Iceland_jack> xedir: you just write | … = eng
15:01:27 <arkeet> skypers: please don't use ErrorT.
15:01:29 <arkeet> use EitherT instead.
15:01:29 <xedir> search german ((ger, eng):xs) | ... = eng  like this?
15:01:37 <Iceland_jack> yes
15:01:49 <xedir> and where do i define german?
15:01:58 <Iceland_jack> xedir: Define is an argument to your function
15:02:05 <Iceland_jack> sorry, *german is an argument
15:02:28 <xedir> mh
15:02:38 <xedir> can you tell me what the user would write?
15:02:48 <xedir> to use this search function right now (search german ((ger, eng):xs) | ... = eng)
15:03:15 <Iceland_jack> xedir: The user might write:
15:03:15 <Iceland_jack>     search "Pferdeschwanz" [("Pferdeschwanz", "ponytail"), ("Pfeife", "pipe")]
15:03:22 <Iceland_jack> which should return
15:03:22 <Iceland_jack>     "ponytail"
15:04:02 <xedir> okay, so german is like a placeholder in this part (search german ((ger, eng):xs) | ... = eng) and is replaced with whatever word i type after search when i use the function
15:04:11 <Iceland_jack> yes that's right
15:04:15 <Iceland_jack> that's how functions work
15:04:16 <xedir> ahh okay,
15:04:21 <xedir> that was hard for me to get :D
15:04:26 <Iceland_jack> If you define
15:04:26 <Iceland_jack>     double num = num * num
15:04:42 <xedir> double 2 i get 4
15:04:47 <xedir> :P
15:04:50 <xedir> derpy me^^
15:04:53 <Iceland_jack> oops, num + num
15:04:58 <Iceland_jack> ‘num’ gets replaced by ‘5’ when you type
15:04:58 <Iceland_jack>       double 5
15:04:58 <Iceland_jack>     = 5 + 5
15:04:58 <Iceland_jack>     = 10
15:05:16 <xedir> okay, got this now as well :D
15:05:26 <Iceland_jack> Just the same with ‘insert dictionary entry’
15:05:52 <xedir> http://pastebin.com/VNcxJ6ts
15:05:54 <mauke> The paste VNcxJ6ts has been copied to http://lpaste.net/97025
15:05:58 <xedir> would this be a code to hand in now?
15:06:06 <Iceland_jack> When you type ‘insert [] ("Pfeife", "pipe")’ you replace ‘dictionary’ with [] and ‘entry’ with ("Pfeife", "pipe")
15:06:12 <Iceland_jack> xedir: no
15:06:24 <xedir> :(
15:06:40 <Iceland_jack> I don't think you know enough Haskell to do this assignment without reading up on it
15:06:56 <Iceland_jack> I gave you the skeleton code above which you seem to have ignored
15:07:07 <xedir> thats propably right
15:08:13 <Iceland_jack> First of all: remove the //'s
15:08:23 <Iceland_jack> // are not comments in Haskell
15:08:30 <Iceland_jack> and you shouldn't comment the type signatures out
15:08:42 <xedir> okay
15:08:58 <Iceland_jack> Do go up and look at the ‘search’ skeleton I posted
15:09:06 <xedir> i have it here
15:09:16 <Iceland_jack> Your final ‘search’ function should look something like that, or ‘filter’
15:09:16 <Iceland_jack> @src filter
15:09:16 <lambdabot> filter _ []     = []
15:09:16 <lambdabot> filter p (x:xs)
15:09:16 <lambdabot>     | p x       = x : filter p xs
15:09:16 <lambdabot>     | otherwise = filter p xs
15:09:16 * hackagebot hArduino 0.8 - Control your Arduino board from Haskell.  http://hackage.haskell.org/package/hArduino-0.8 (LeventErkok)
15:10:02 <xedir> okay, give me a minute
15:10:37 <ion> seanparsons: FWIW, its encode doesn’t seem to use \u encoding for characters that don’t need it, but its decode handles surrogate pairs just fine.
15:11:20 <skypers> 23:51 < arkeet> use EitherT instead.
15:11:23 <skypers> I use both
15:11:36 <skypers> why not ErrorT?
15:11:41 <xedir> http://pastebin.com/7g6BC8Jf better?
15:11:43 <mauke> The paste 7g6BC8Jf has been copied to http://lpaste.net/97026
15:12:13 <skypers> arkeet: with ErrorT I have throwError and catchError, I don’t have that with EitherT I guess
15:12:15 <Iceland_jack> xedir: OK let's step through some misunderstandings
15:12:23 <Iceland_jack> First of all, remove the space before the type annotations
15:12:29 <skypers> well there still is left and right, but hm
15:12:30 <seanparsons> ion: I'm staring at this for the encode that doesn't appear to pump out surrogate pairs: https://github.com/bos/aeson/blob/master/Data/Aeson/Encode.hs#L62
15:12:42 <seanparsons> Unless I'm totally misunderstanding it.
15:12:52 <ion> Yeah, because it just doesn’t encode characters that don’t need to be encoded.
15:12:53 <xedir> - done
15:12:54 <Iceland_jack> They should look like this:
15:12:54 <Iceland_jack>     insert :: Dictionary -> (String, String) -> Dictionary
15:12:54 <Iceland_jack>     insert dictionary neuerEintrag = neuerEintrag : dictionary
15:13:01 <Iceland_jack> i.e. on the same line as the function
15:13:07 <Iceland_jack> OK, unto your search function
15:13:15 <seanparsons> ion: But for those that do and are in the U+10000 range?
15:13:15 <arkeet> skypers: yes you do, EitherT is also an instance of MonadError
15:13:27 <Iceland_jack> You mixed up the places to put the "night gefunden" error message
15:13:30 <ion> seanparsons: Plain UTF-8 should be fine for them.
15:13:30 <skypers> so what’s the difference between both?
15:13:38 <xedir> okay - silly question - is this important for haskell or the compiler or just "how its done"?^^
15:13:43 <arkeet> ErrorT needs a stupid Error constraint on the left type.
15:13:48 <skypers> ooh
15:13:50 <Iceland_jack> xedir: How it's done, otherwise it won't parse
15:13:50 <skypers> yeah
15:13:55 <skypers> I thought it was stupid
15:13:58 <Iceland_jack> The error message is when the dictionary is *empty* (i.e. [])
15:14:00 <skypers> I have a dummy instance for Error
15:14:06 <arkeet> heh
15:14:08 <skypers> I’ll just go into EitherT then
15:14:11 <skypers> thank you!
15:14:23 <Iceland_jack> xedir: so you should have
15:14:23 <Iceland_jack>     search german [] = "night gefunden"
15:14:34 <Iceland_jack> not
15:14:34 <Iceland_jack>     search german [] = dictionary
15:14:51 <Iceland_jack> xedir: Do you even have a Haskell compiler??
15:15:45 <seanparsons> ion: So you're suggesting that there's no possibility of any control characters existing in that range?
15:16:20 <xedir> not yet, a friend i'm in teamspeak with has it installed
15:16:27 <Iceland_jack> murr..
15:17:00 <Iceland_jack> You really, really shouldn't work on a programming assignment in a language you don't know without having a compiler
15:17:02 <xedir> but i get what you mean... silly me [] <- empty list ^.^
15:17:22 <Iceland_jack> The compiler should tell you when you make mistakes
15:17:28 <skypers> hm arkeet
15:17:31 <skypers> Prelude Control.Monad.Trans.Error> :t throwError
15:17:31 <skypers> throwError :: (Monad m, Error e) => e -> ErrorT e m a
15:17:31 <ion> seanparsons: Please see the section “9 String”. It’s very clear about what needs to be escaped. http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf
15:17:43 <skypers> I can’t use EitherT with throwError
15:17:44 <txrxcx> > (&&&) (+) (1,2)
15:17:45 <lambdabot>  Couldn't match expected type `(b0, c0)'
15:17:45 <lambdabot>              with actual type `a0 -> a0 -> a0'
15:17:50 <xedir> getting hugs in this very second^^
15:17:55 <arkeet> skypers: import Control.Monad.Error.Class
15:18:01 <txrxcx> @type (&&&)
15:18:02 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
15:18:07 <Iceland_jack> xedir: (you should really use ‘ghc’ and tell your teacher to stop teaching Hugs)
15:18:09 <arkeet> er
15:18:19 <Iceland_jack> but what ever, that's a different battle
15:18:19 <arkeet> yeah
15:18:23 <arkeet> use throwError from that module.
15:19:02 <skypers> so you suggest to completely drop the Control.Monad.Trans.Error module?
15:19:12 <skypers> and use Either instead?
15:19:13 <arkeet> I guess so.
15:19:25 <txrxcx> > let fss f a b = f a b in map (fss (+)) [(1,2),(3,4)]
15:19:26 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t1)
15:19:26 <lambdabot>    arising from a use of `M32341748881068988526468.show_M32341748881068988526...
15:19:26 <lambdabot>  The type variable `t1' is ambiguous
15:19:26 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
15:19:26 <lambdabot>  Note: there are several potential instances:
15:19:32 <dmwit_> Feuerbach: Hrm, I don't even remember how *I* joined. =P
15:19:43 <xedir> okay, hugs is running
15:19:46 <txrxcx> > let fss f (a,b) = f a b in map (fss (+)) [(1,2),(3,4)]
15:19:46 <arkeet> don't use hugs
15:19:47 <lambdabot>  [3,7]
15:19:53 <arkeet> use ghc instead.
15:19:55 <xedir> okay^^
15:20:01 <arkeet> hugs is oooooooooold
15:20:11 <xedir> getting ghc now
15:20:19 <xedir> yep
15:20:20 <xedir> 2006
15:20:23 <Iceland_jack> xedir: Okay, you need to do two things: replace the "..." (it is not valid code!)
15:20:26 <skypers> oooh ok
15:20:34 <Iceland_jack> and write an otherwise case
15:20:34 <skypers> it’s not actually Control.Monad.Error
15:20:44 <skypers> for the class version
15:21:12 <arkeet> well Control.Monad.Error should work too
15:21:20 <arkeet> as long as it's from mtl
15:21:37 <skypers> yep
15:21:41 <skypers> thank you
15:21:54 <seanparsons> ion: Easy now, I was being ultra careful as the unicode spec itself has some control characters in one of those upper ranges, which is why I'm being very circumspect.
15:22:36 <xedir> okay, ... would be something like "if german = ger" and otherwise would be continue going through the list?
15:22:46 <seanparsons> ion: If you've seen the revised JSON spec and how it loosens the requirements around numbers in a terrifying way, you'd understand why I'm being hyper careful around how the JSON spec actually specifies certain things.
15:23:12 <Iceland_jack> xedir: Yes (except you don't need ‘if’), for otherwise you make a recursive call
15:23:34 <Iceland_jack> so you call the same function (search) with the same word (german) on the rest of the dictionary (xs)
15:25:16 <dmwit> ?tell Feuerbach It looks like I just wrote an email to a few of the folks, and one of them added me to the organization. I'm happy to do that for you if you tell me your github nick (I'm guessing it's feuerbach?).
15:25:16 <lambdabot> Consider it noted.
15:25:50 <xedir> so the second 3. line of the search is | german = ger = eng
15:26:09 <Iceland_jack> xedir: yes except you need one more = :)
15:26:10 <dmwit> ?tell Feuerbach Of course, whatever package you're thinking of taking over, it's probably polite to try to contact the current maintainer, make a little request-for-objections on some Haskell mailing lists, etc.
15:26:11 <lambdabot> Consider it noted.
15:26:16 <Iceland_jack> > 5 + 5 == 10
15:26:18 <lambdabot>  True
15:26:38 <xedir> :D
15:26:46 <xedir> i'm derping arround right now^^
15:27:09 <Iceland_jack> You're going to have to promise to read through LYAH after this to get a proper background in Haskell xedir :)
15:27:34 <xedir> i will come back and teach you ;)
15:27:41 <Iceland_jack> please do
15:28:06 <xedir> and for otherwise i just use "search german ((ger, eng):xs) " again?
15:28:23 <Iceland_jack> well not: search german ((ger, eng):xs)
15:28:24 <Twey> In Vinyl, I find myself frequently doing foo = Field ∷ bar; type FooRec = PlainRec '[ bar ].  Can I somehow avoid that repetition?
15:28:31 <Iceland_jack> because then you're searching the exact same dictionary
15:28:36 <Iceland_jack> you want to omit the (ger, eng)
15:28:44 <arkeet> Twey: doesn't vinyl have some TH thing?
15:29:10 <arkeet> or maybe I'm getting it confused with the billion other things that have some TH thing
15:29:37 <Twey> Hm, not that I can see
15:29:48 <arkeet> yeah me either
15:30:47 <Twey> I can use a type synonym (type Bar = bar; foo = Field ∷ bar; type FooRec = PlainRec '[ bar ]), but It would be nice if I could just say ‘foo = Field ∷ bar; type FooRec = PlainRec '[ typeOf foo ]’
15:31:28 <xedir> mhh
15:31:34 <Twey> Though it does seem ripe for some TH'ing, I'm worried that avoiding name clashes would be awkward
15:35:13 <xedir> can i use things like ger, eng):xs-1) to "step down" in the list?
15:35:24 <Iceland_jack> xs is not a number
15:35:27 <Iceland_jack> so you cannot write: xs - 1
15:35:37 <Iceland_jack> but xs is *alread* the next ‘step’ in the dictionary
15:35:37 <xedir> okay
15:36:00 <Iceland_jack> xs is the rest of the dictionary
15:36:07 <xedir> okay
15:36:21 <xedir> so just serch german (xs) ?
15:36:32 <Iceland_jack> yes
15:36:37 <xedir> :&
15:36:38 <Iceland_jack> but you can omit the parentheses
15:37:17 <xedir> okay
15:37:28 <xedir> | otherwise = search german (():xs) ?
15:37:33 <Iceland_jack> no
15:37:44 <Iceland_jack> I wonder where you got that from xedir?
15:38:02 <Iceland_jack> You had the correct answer and suggested nothing of the sort
15:38:11 <Iceland_jack> *and I suggested
15:38:18 <Iceland_jack>     | otherwise = search german xs
15:38:19 <Iceland_jack> that's all
15:38:21 <xedir> :D
15:38:38 <xedir> that was just from my mind^^
15:38:48 <xedir> i just
15:38:48 <xedir> derped again^^
15:39:12 <xedir> "<Iceland_jack> but you can omit the parentheses " read you can not omit...
15:39:28 <Iceland_jack> :)
15:39:35 <Iceland_jack> So may I see your final version?
15:40:15 <xedir> well
15:40:29 <xedir> what do we return when the word is not in the dictionary?
15:40:37 <xedir> but the list isn't empty neither
15:40:45 <Iceland_jack> That's taken care of by the empty case
15:40:55 <xedir> all that is done by this
15:40:57 <xedir> awesome^^
15:41:11 <Iceland_jack> Because every time you have ((ger, eng):xs)
15:41:24 <Iceland_jack> and german ≠ ger, you return: search german xs
15:41:29 <xedir> http://pastebin.com/auQhJmNf
15:41:36 <mauke> The paste auQhJmNf has been copied to http://lpaste.net/97029
15:41:43 <Iceland_jack> so if you don't find the word you'll go through the entire dictionary until the dictionary is empty
15:42:09 <Iceland_jack> xedir: (also as you can see, your pastes get copied to lpaste.net which you should use in the future)
15:42:55 <Iceland_jack> xedir: (please insert newlines between the lines 1–2 and 3–4)
15:43:05 <Iceland_jack> Other than that, it looks correct :)
15:43:48 <Iceland_jack> another way of writing search is:
15:43:48 <Iceland_jack>     search german dictionary = head [ eng | (ger, eng) <- dictionary, ger == german ]
15:46:12 <xedir> http://lpaste.net/97029
15:46:12 <xedir> there we go
15:46:21 <Iceland_jack> xedir: great :)
15:46:25 <Iceland_jack> Now for the big spoiler!
15:46:27 <Iceland_jack> @src lookup
15:46:27 <lambdabot> lookup _key []          =  Nothing
15:46:27 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
15:46:27 <lambdabot>                         | otherwise = lookup key xys
15:46:43 <Iceland_jack> Does that look familiar?
15:47:38 <xedir> lookup _key [] = nothing is familiar
15:47:54 <Iceland_jack> @src Maybe
15:47:54 <lambdabot> data Maybe a = Nothing | Just a
15:48:05 <xedir> lookup key ((x,y):xys) | thats cool as well
15:48:06 <Iceland_jack> You use “Maybe String” if you possibly don't have a string
15:48:21 <Iceland_jack> So in your case you return
15:48:21 <Iceland_jack>     Nothing
15:48:21 <Iceland_jack> when the word isn't in the dictionary
15:48:52 <Iceland_jack> and you return
15:48:52 <Iceland_jack>     Just "ponytail"
15:48:52 <Iceland_jack> when you do: search "Pferdeschwanz" [("Pferdeschwanz", "ponytail"),
15:48:52 <Iceland_jack> 	       ("Pfeife", "pipe")]
15:49:54 <Iceland_jack> Here are two examples:
15:49:54 <Peaker> xedir: "Maybe a" is like a list of a but can only have 0 or 1 inside it.  Very commonly useful
15:49:57 <Iceland_jack> > lookup "Pferdeschwanz" [("Pferdeschwanz", "ponytail"), ("Pfeife", "pipe")]
15:49:58 <lambdabot>  Just "ponytail"
15:50:01 <Iceland_jack> > lookup "Pfeife" [("Pferdeschwanz", "ponytail"), ("Pfeife", "pipe")]
15:50:02 <lambdabot>  Just "pipe"
15:50:14 <Iceland_jack> > lookup "hurðaskellir" [("Pferdeschwanz", "ponytail"), ("Pfeife", "pipe")]
15:50:16 <lambdabot>  Nothing
15:50:34 <Iceland_jack> xedir: Simple right?
15:50:35 <xedir> ah, to either it is there or not
15:50:39 <Iceland_jack> Yes
15:50:44 <Rarrikins> Maybe.
15:52:37 <Iceland_jack> xedir: Does that answer your question?
15:53:41 <xedir> yeah
15:53:42 <xedir> i'm working through it^^
15:56:21 <xedir> are you up for one bonus task?^^
15:56:26 <Iceland_jack> Always
15:56:33 <xedir> :P
15:56:57 <xedir> okay, the task says to create a maxSublistSum function
15:57:13 <xedir> it should calculate the biggest sum of a pair (two numbers) of a list
15:57:27 <Iceland_jack> Does it neet to be efficient?
15:57:29 <Iceland_jack> *need
15:57:38 <xedir> hardwarewise?
15:57:49 <Iceland_jack> No algorithm-wise
15:57:58 <Iceland_jack> It's trivial to implement in a brute-force way
15:58:28 <xedir> uhm
15:58:54 <Iceland_jack> You have some list [1,2,3] and you multiply every element with every element
15:59:01 <xedir> ah
15:59:01 <Iceland_jack> and pick the largest element of that list
15:59:03 <xedir> sry
15:59:12 <xedir> the task is not 100% correct
15:59:18 <Iceland_jack> ?
15:59:27 <xedir> it should be the biggest "chain" of a list of numbers
15:59:47 <Iceland_jack> So you mean chains of length 2?
15:59:50 <xedir> like [1,2,3,4,5,6] it would be the sum of 1 to 6
15:59:50 <xedir> not only 5 and 6 (the pair)
16:00:03 <xedir> no, the pair thing was wrong
16:00:09 <psc> hi is there a easy way,to see how a functions like foldl are implemented on a offline system ? / where do I find (the source code) of the functions which you can use in the prelude?
16:00:30 <AshyIsMe> @src foldl
16:00:30 <lambdabot> foldl f z []     = z
16:00:31 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:00:33 <Rarrikins> psc: Find them on Hackage and click the Source link.
16:00:42 <AshyIsMe> that doesnt help without internet access though i guess
16:00:43 <Iceland_jack> I'm not sure why it's the sum of 1 and 6
16:01:05 <Rarrikins> psc: You can download the various source HTML files for the Prelude.
16:01:08 <xedir> its the sum of all of the elements
16:01:11 <xedir> from 1 to 6
16:01:19 <Iceland_jack> ah I see
16:01:32 <Iceland_jack> well again that's trivial to do in a brute force way
16:01:38 <xedir> if we have like [1,2,3,4, -7 , 5, 6]
16:01:47 <xedir> it would be 5 and 6
16:01:53 <xedir> because the  -7 kinda interupts the chain
16:02:10 <Iceland_jack> > subsequences [1,2,3,4, -7 , 5, 6]
16:02:11 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3...
16:02:21 <AshyIsMe> does the commandline hoogle still need internet access or does it use local databases?
16:02:42 <Iceland_jack> > maximumBy (comparing sum) (subsequences [1,2,3])
16:02:43 <lambdabot>  [1,2,3]
16:03:01 <Rarrikins> > join (liftM2 (*)) [1, 2, 3]
16:03:02 <lambdabot>  [1,2,3,2,4,6,3,6,9]
16:03:02 <Iceland_jack> hm no that's wrong, sorr
16:03:03 <txrxcx> > let sumN = foldl (+) 0 [1..] in sumN 2
16:03:04 <lambdabot>  Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
16:03:04 <lambdabot>    arising from the ambiguity check for `e_1012'
16:03:04 <lambdabot>  from the context (GHC.Enum.Enum (a -> t),
16:03:04 <lambdabot>                    GHC.Num.Num (a -> t),
16:03:04 <lambdabot>                    GHC.Num.Num a)
16:03:07 <txrxcx> > let sumN = foldl (+) 0 [1..] in sumN 3
16:03:08 <lambdabot>  Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
16:03:08 <lambdabot>    arising from the ambiguity check for `e_1013'
16:03:08 <Iceland_jack> *sorry
16:03:10 <lambdabot>  from the context (GHC.Enum.Enum (a -> t),
16:03:12 <lambdabot>                    GHC.Num.Num (a -> t),
16:03:13 <jle`> AshyIsMe: should be using local databases iirc
16:03:14 <lambdabot>                    GHC.Num.Num a)
16:03:20 <txrxcx> > let sumN n = foldl (+) 0 [1..n] in sumN 3
16:03:21 <lambdabot>  6
16:03:27 <Rarrikins> > join (liftM2 (*)) [1, 2, 3, 4]
16:03:28 <lambdabot>  [1,2,3,4,2,4,6,8,3,6,9,12,4,8,12,16]
16:03:30 <xedir> it is also recommended to define two help functions, inits and tails		inits creates all possible chains from the beginning of the list and tails all from the ending of the list
16:03:38 <AshyIsMe> psc: http://www.haskell.org/haskellwiki/Hoogle#Database_Creation
16:03:42 <Iceland_jack> xedir: well they already exist
16:03:47 <AshyIsMe> psc: try installing hoogle locally
16:03:52 <Iceland_jack> @ty inits
16:03:53 <lambdabot> [a] -> [[a]]
16:03:53 <Iceland_jack> @ty tails
16:03:54 <lambdabot> [a] -> [[a]]
16:03:55 <xedir> like so http://lpaste.net/97029
16:04:00 <Bor0> > tails [1,2,3,4,5,6,7]
16:04:01 <lambdabot>  [[1,2,3,4,5,6,7],[2,3,4,5,6,7],[3,4,5,6,7],[4,5,6,7],[5,6,7],[6,7],[7],[]]
16:04:10 <Rarrikins> Wait, what is the problem that's being solved?
16:04:28 <Iceland_jack> maximum sublist sum
16:04:46 <jle`> does it have to be a contiguous sublist?
16:04:51 <Iceland_jack> Yes I suppose it does
16:05:17 <Bor0> > map (\x -> (x, sum x)) $ tails [1,2,3,4, -7 , 5, 6]
16:05:18 <lambdabot>  [([1,2,3,4,-7,5,6],14),([2,3,4,-7,5,6],13),([3,4,-7,5,6],11),([4,-7,5,6],8),...
16:05:19 <Rarrikins> Oh
16:05:23 <Rarrikins> Hmm.
16:05:42 <Iceland_jack> @let subsequences = concatMap inits . tails
16:05:43 <Rarrikins> > concatMp tails . inits $ [1, 2, 3]
16:05:43 <lambdabot>  Defined.
16:05:44 <lambdabot>  Not in scope: `concatMp'
16:05:44 <lambdabot>  Perhaps you meant one of these:
16:05:44 <lambdabot>    `concatMap' (imported from Data.List),
16:05:44 <lambdabot>    `BSC.concatMap' (imported from Data.ByteString.Char8),
16:05:45 <lambdabot>    `BSLC.concatMap' (imported from Data.ByteString.Lazy.Char8)
16:05:50 <Rarrikins> Bleh
16:05:53 <Iceland_jack> > subsequences [1,2,3,4,-7,5,6]
16:05:54 <lambdabot>  Ambiguous occurrence `subsequences'
16:05:54 <lambdabot>  It could refer to either `L.subsequences', defined at L.hs:156:1
16:05:54 <lambdabot>                        or `Data.List.subsequences',
16:05:54 <lambdabot>                           imported from `Data.List' at L.hs:85:1-16
16:05:58 <Iceland_jack> > L.subsequences [1,2,3,4,-7,5,6]
16:06:00 <psc> AshyIsMe: thx I will try
16:06:00 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,-7],[1,2,3,4,-7,5],[1,2,3,4,-7,5,6]...
16:06:14 <Iceland_jack> and then: maximumBy (comparing sum) . L.subsequences
16:06:25 <Rarrikins> The best way would probably be to get the sums first.
16:06:29 <jle`> psc: hoogle doesn't store implementations/sources i don't think
16:06:39 <jle`> psc: but you should have your haddock docs all locally stored
16:07:16 <[swift]_> what is the usual solution for inserting a monad into your transformer stack _inside_ the computation? say I have "FooT IO a", and after taking some steps I want to have "FooT (ReaderT r IO) a" for the rest of the computation
16:07:20 <Rarrikins> > let f xs = let ys = map sum . inits $ xs; zs = map sum . tails $ xs in liftM2 (+) ys zs in f [1, 2, 3]
16:07:21 <lambdabot>  [6,5,3,0,7,6,4,1,9,8,6,3,12,11,9,6]
16:07:22 <jle`> psc: check your ~/.cabal/config and make sure you have set documentation: True
16:07:27 <Rarrikins> Something like that.
16:07:47 <Rarrikins> Oh, wait.
16:07:50 <Iceland_jack> Rarrikins: I think you misunderstand the problem
16:07:52 <Rarrikins> > let f xs = let ys = map sum . inits $ xs; zs = map sum . tails $ xs in liftM2 (-) ys zs in f [1, 2, 3]
16:07:53 <lambdabot>  [-6,-5,-3,0,-5,-4,-2,1,-3,-2,0,3,0,1,3,6]
16:07:56 <Rarrikins> There :)
16:08:02 <Rarrikins> No, that's not it either.
16:08:03 <ij> If I want to map over stuff and have some state with it in each map step aggregated from other list items, should I fold with f :: (state, item) and then strip all the states?
16:08:03 <Rarrikins> Hmm.
16:08:04 <Iceland_jack> I've already given the answer
16:08:07 <ij> Is there anything better than that?
16:08:17 <xedir> mh
16:08:26 <Iceland_jack> @ty maximumBy (comparing sum) . concatMap inits . tails
16:08:27 <lambdabot> (Num a, Ord a) => [a] -> [a]
16:08:31 <xedir> give me a minute and let me look trough it
16:08:57 <[swift]_> ij: you can use StateT, but it's fundamentally the same thing
16:09:11 <Iceland_jack> > (maximumBy (comparing sum) . concatMap inits . tails) [-2,1,-3,4,-1,2,1,-5,4]
16:09:12 <lambdabot>  [4,-1,2,1]
16:09:18 <Iceland_jack> Example from Wikipedia: https://en.wikipedia.org/wiki/Maximum_subarray_problem
16:09:20 <jle`> psc: your docs sohuld be stored in ~/.cabal/share/doc, open index.html
16:10:00 <Bor0> what is maximumBy, and comparing sum?
16:10:23 <Iceland_jack> Bor0: maximumBy (comparing sum) picks an element of a list which has the greatest sum
16:10:27 <Iceland_jack> @src maximumBy
16:10:27 <lambdabot> Source not found. Are you typing with your feet?
16:10:29 <Iceland_jack> murr
16:10:37 <Iceland_jack> Where 'concatMap inits . tails' is all contiguous sublists: not the same as Data.List.subsequences
16:10:51 <Rarrikins> Bor0: It finds the maximum after applying a function to the elements.
16:11:15 <Rarrikins> @src comparing
16:11:15 <lambdabot> Source not found. Maybe you made a typo?
16:11:18 <Rarrikins> Maybe!
16:11:19 <Iceland_jack> > maximumBy (comparing length) ["hi", "there", "how", "are, "you?"]
16:11:20 <lambdabot>  <hint>:1:66:
16:11:20 <lambdabot>      lexical error in string/character literal at end of input
16:11:30 <Iceland_jack> > maximumBy (comparing length) ["hi", "there", "how", "are", "you?"]
16:11:31 <lambdabot>  "there"
16:11:53 <Iceland_jack> > maximumBy (comparing (length . filter (== 'e')) ["hi", "there", "how", "are", "you?"]
16:11:54 <lambdabot>  <hint>:1:86:
16:11:54 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
16:11:57 <Iceland_jack> > maximumBy (comparing (length . filter (== 'e'))) ["hi", "there", "how", "are", "you?"]
16:11:58 <lambdabot>  "there"
16:12:09 <Rarrikins> It's probably maximumBy f xs = head $ sortBy f xs
16:12:46 <Rarrikins> Actually, last instead of head.
16:13:03 <Iceland_jack> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-List.html
16:13:07 <Cale> You could use head with sortBy (flip f)
16:13:34 <xedir> mh
16:13:36 <Rarrikins> Ahh, yes.
16:13:39 <Iceland_jack>     maximumBy cmp xs = foldl maxBy xs  where
16:13:39 <Iceland_jack>       maxBy x y = case cmp x y of
16:13:39 <Iceland_jack>           GT → x
16:13:39 <Iceland_jack> 	  _  → y
16:13:40 <xedir> i dont really get what you do there
16:13:59 <Rarrikins> Ahh, that's even better.
16:14:10 <Iceland_jack> xedir: I know, it's a bit too advanced
16:14:18 <Iceland_jack> I would say forget about that one
16:14:42 <Iceland_jack> Of course there is a much more efficient solution than using inits/tails but that's what your teacher mentioned
16:14:59 <psc> jle`:   I did  change  ~/.cabal/config/  " --documentation: True"  do I have to execute something now to build the index.html ?
16:15:11 <jle`> psc: you need to uncomment it
16:15:21 <jle`> psc: if the docs aren't there already
16:15:25 <jle`> then you need to re-download and recompile
16:15:27 <jle`> unfortunately
16:15:32 <jle`> unless someone else here knows what to do
16:16:21 <jle`> http://stackoverflow.com/questions/6563769/haskell-cabal-regenerate-documentation-for-all-installed-packages
16:17:21 <psc> jle`:  in  ~/.cabal/share/doc  there are some directories which do only containing a license file but there is no index.html. So i will try your Link
16:17:27 <xedir> @let subsequences = concatMap inits . tails
16:17:27 <lambdabot>  .L.hs:157:1:
16:17:27 <lambdabot>      Multiple declarations of `subsequences'
16:17:28 <lambdabot>      Declared at: .L.hs:156:1
16:17:28 <lambdabot>                   .L.hs:157:1
16:17:44 <xedir> is this like the main part?
16:17:47 <jle`> psc: try the link but if they do not work, you might have to reinstall all of your global packages.
16:18:10 <Iceland_jack> xedir: I helped you through all of your assignment, now please go read LYAH:
16:18:10 <Iceland_jack> @where lyah
16:18:10 <lambdabot> http://www.learnyouahaskell.com/
16:18:21 <Iceland_jack> You're attempting to do things that you simply do not have the foundation for
16:19:34 <psc> xedir: I am currently reading LYAH and think it is a very good document to learn haskell
16:23:01 <xedir> irc just crashed..
16:23:30 <Iceland_jack> xedir: tl;dr: read LYAH :)
16:23:33 <Iceland_jack> @where lyah
16:23:33 <lambdabot> http://www.learnyouahaskell.com/
16:23:50 <xedir> mh?
16:25:08 <xedir> i just came back :P
16:29:24 <psc> jle`:  thx for you help. It did not work but I will try again tomorrow
16:29:26 <psc> bye
16:33:23 <nh2> how do I make a multi-line .ghci :def binding? The example only contains a let binding, I want some importing + some monadic stuff
16:34:50 <Twey> nh2: You can surround things with :{ :}
16:35:05 <Rarrikins> :}
16:35:10 <[swift]_> when defining a new monad transformer, is it the usual thing to make it an instance of MonadState, MonadReader, etc if its underlying monad is StateT, ReaderT, etc?
16:35:26 <nh2> Twey: yeah I tried that but I haven't quite figured out where to put them - after the def or :def mycommand :{ .. stuff .. :}
16:36:50 <nh2> Twey: I tried this: http://lpaste.net/97032
16:36:56 <danilo2> Hello :) Does anybody know if in Accelerate CUDA backend, the function A.use is copying array to memory or is the array copied when needed?
16:38:47 <Twey> Hm
16:39:07 <Twey> nh2: Don't know; sorry.  You can always use semicolons and braces to put things on one line, though.
16:41:27 <nh2> yes, but http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/interactive-evaluation.html says explicitly "The main purpose of multiline commands is not to replace module       loading but to make definitions in .ghci-files (see Section 2.9, “The .ghci file”) more readable and maintainable." so at some point somebody must have known how that has to work
16:44:05 <benmachine> nh2: I think you misunderstand how :def works
16:44:20 <benmachine> :def cmd expr
16:44:33 <benmachine> expr is a Haskell expression of type... I forget
16:44:37 <benmachine> probably String -> IO String
16:45:08 <benmachine> the string parameter is the argument, and the IO String is what you get back
16:45:26 <ij> Is there a difference between Prelude.foldl and D.Foldable.foldl?
16:45:40 <benmachine> waaait, actually I can't remember hwo it works
16:45:58 <benmachine> right, the returned string is run at the ghci prompt
16:50:03 <Sgeo> :t (/)
16:50:04 <lambdabot> Fractional a => a -> a -> a
16:50:06 <Sgeo> :/
16:50:29 <Sgeo> That's just so wrong... dividing two numbers of one type should be able to result in a different type
16:50:48 <benmachine> nh2: try this: http://lpaste.net/97035
16:51:16 <benmachine> Sgeo: it's not that wrong, just convert to the right type beforehand
16:51:18 <haasn> :t fromRational .: (%) -- Sgeo
16:51:19 <lambdabot>     Not in scope: `.:'
16:51:19 <lambdabot>     Perhaps you meant one of these:
16:51:19 <lambdabot>       `.' (imported from Data.Function),
16:51:29 <haasn> :t \x y -> fromRational (x % y) -- Sgeo
16:51:30 <lambdabot> Fractional a => Integer -> Integer -> a
16:51:42 <benmachine> or indeed use (%)
16:51:44 <haasn> :t \x y -> fromRational (toInteger x % toInteger y) -- Sgeo
16:51:44 <lambdabot> (Fractional a, Integral a1, Integral a2) => a1 -> a2 -> a
16:51:50 <haasn> that's the most general type I can think of right now
16:52:18 <Sgeo> What about time divided by time?
16:52:24 <Sgeo> Or time divided by unitless?
16:52:39 <haasn> Num generally does not really concern itself with units, to be fair
16:52:40 <Sgeo> Hmm, I guess this applies to (*) too
16:52:44 <haasn> If you want something like that, check out a unit library
16:53:16 <haasn> With absolutely no bias, I present you with http://hub.darcs.net/nand/units/browse/src/Units/Metric.hs#15
16:53:29 <haasn> Also http://hub.darcs.net/nand/units/browse/src/Units/Prelude.hs#42
16:59:42 <donri> haasn: needs moar type literals
16:59:49 <donri> type Minute = U "min"
17:00:08 <haasn> donri: sure, once you give me Cmp :: Symbol -> Symbol -> Ordering
17:00:56 <haasn> I had to hand-roll my own String type with a few thousand auto-generated (<=) instances
17:00:59 <haasn> :(
17:08:17 <Sgeo> Wonder if you could have a nice Template Haskell-but-not-QuasiQuoted routing library
17:08:30 <Sgeo> So you could have combinators etc., but still get type safety
17:11:56 <Sgeo> If there's anything likeable in Haskell meta-programming, it's the separation between the idea of 'how do we produce repetitive code' and 'how do we extend syntax'
17:12:30 <Sgeo> The first does not imply doing the second, and I'm glad Haskell recognizes this
17:15:39 <donri> Sgeo: web-routes-boomerang?
17:28:20 <nh2> benmachine: much appreciated!
17:32:38 <bradarv> does anyone ever post here
17:32:45 <nisstyre> yes, all the time
17:33:00 <nisstyre> there are >1000 people in here right now
17:33:02 <nisstyre> just be patient
17:38:36 <jmcarthur> bradarv: you just happened to come in at a particularly quiet time, it seems
17:38:53 <bitemyapp> Could someone point me in the direction of a library that exemplifies good use of free monads?
17:40:02 <ParahSailin> pipes-parse?
17:40:06 <jmcarthur> bitemyapp: i think there are very few good uses of free monads relative to the number of uses, to be honest. most free monads could be written in a more direct style. the pipes library is an example which would be very difficult to write without free monads, though.
17:41:01 <bitemyapp> ParahSailin: thank you
17:41:16 <Guest25099> servus
17:41:20 <bitemyapp> jmcarthur: I was trying to figure out the when/where/why of it, having read some reasonable explanations.
17:42:04 <Twey> Ave
17:42:31 <jmcarthur> bitemyapp: i think free monads are best used when you are still exploring the design space, although it may happen that once you have finalized your interface you are happy with the implementation anyway.
17:42:42 <bitemyapp> oh, it was written by Gabriel. This somehow doesn't surprise me.
17:42:47 <haasn> bitemyapp: http://www.haskell.org/pipermail/libraries/2013-October/021341.html
17:42:50 <haasn> this has a few examples, I think
17:43:01 <bitemyapp> haasn: thank you!
17:43:04 <jmcarthur> bitemyapp: basically a free monad is good for when you are designing with a particular syntax in mind, as opposed to a particular semantics, and that syntax happens to be monad
17:43:06 <jmcarthur> *monadic
17:43:14 <bitemyapp> jmcarthur: that's the context I've heard it mentioned in, while exploring a problem.
17:43:52 <bitemyapp> jmcarthur: that's a useful technique to me. I'd often to do that in Clojure with functions and macros. Design my ideal modes of expression, then push the code towards that, using the least-power-needed to accomplish that.
17:44:12 <jmcarthur> Gabriel has a somewhat unusual approach to programming where he restricts himself to a fairly small set of design patterns. One of them is free monads.
17:45:05 <jmcarthur> His approach does not really sit well with me. I prefer a semantics-oriented approach to design.
17:46:19 <bitemyapp> jmcarthur: very interesting, what are some things he tends to eschew?
17:47:53 <malaclyps> is there any way to set up default options for ghc or ghc-mod
17:47:59 <bitemyapp> jmcarthur: I'm generally not concerned with syntax, I'm concerned with balancing expressiveness and power. Such that specificity, generality, and composability are in harmony with the problem being solved.
17:48:10 <bitemyapp> malaclyps: shell aliases come to mind as one possibility.
17:48:15 <malaclyps> i'm trying to have some default ignore options for warnings, but i can't find a good place for them.
17:48:21 <malaclyps> bitemyapp, that's a good idea, thank you
17:48:55 <bitemyapp> malaclyps: shell *scripts* as well, you can always make a chmod +x #!/bin/bash that displaces ghc-mod and invokes it with whatever you want.
17:49:12 <bitemyapp> if shell aliases are somehow inconvenient.
17:49:39 <malaclyps> bitemyapp, i may actually submit a patch to Vim's syntastic plugin -- it doesn't let you set options with ghc-mod active syntax checking, and it probably should
17:50:31 <bitemyapp> malaclyps: I'd tend to agree, tho' I mostly use Emacs when I'm coding.
17:50:31 <jmcarthur> bitemyapp: here's a reddit thread where Gabriel eschewed some generalizations of Monoid/Applicative/Monad http://www.reddit.com/r/haskell/comments/1ou06l/improving_applicative_donotation/ccvm26g
17:51:10 <bitemyapp> jmcarthur: where do you think this impulse to homogenize and flatten comes from?
17:51:13 <Eduard_Munteanu> Any idea how haskell-mode can be coerced to start with the left-most indentation cycle by default?
17:52:04 <jmcarthur> bitemyapp: i think it's an idealism that has worked out well for him so far. it is true that if most interfaces have a lot in common they are easier to pick up.
17:53:55 <bitemyapp> jmcarthur: I've spent a fair bit of time teaching Haskell lately, including the typeclasses. Flattening everything into Functor/Applicative/Monad would make my job harder, I think.
17:54:38 <bitemyapp> the dual nature of "faculty + laws" seemed to work well for them as long as I could pair the noun with a concrete use-case.
17:54:54 <bitemyapp> like State, Writer, a logger monad, etc.
17:54:59 <bitemyapp> fmap.
17:56:50 <jmcarthur> bitemyapp: Gabriel might say something like it's okay for designing an interface to be hard as long as using it isn't, I would agree with it. I would add, however, that my problem with his approach isn't that it's hard, but that it's (1) overly constrained and (2) a distraction from the goal of designing the interface with a simple, precise semantics
17:57:30 <jmcarthur> where by (1) i mean in regards to what is expressible at all, not in regards to how hard it is to design
17:57:31 <bitemyapp> the simplicity and precision are of concern, as is the ability to make concepts as clear as possible.
17:57:58 <bitemyapp> part of the trouble new people have with monads is that they seem to apply to incredibly disparate problems.
17:58:05 <jmcarthur> bitemyapp: anyway, all that to say... i feel the same way about free monads. they are a syntax-oriented design pattern.
17:58:10 <bitemyapp> functors and other concepts come across more easily because of the specificity.
17:58:34 <jmcarthur> functors are more general than monads, not less ;)
17:58:40 <bitemyapp> Minding the ladder of abstraction when explaining and all that.
17:58:47 <bitemyapp> jmcarthur: yeah but the purpose is simple and focused.
17:58:55 <levi> I think Gabriel's goal is to try to fit everything possible into Categorical semantics, even if you can express the semantics you want more easily another way, because he is a big fan of the compositionality that you get that way and he's comfortable with reasoning about it to be sure his abstractions do what he wants them to.
17:59:15 <jmcarthur> levi: i think that is a fair representation of his goal, yes
17:59:47 <jmcarthur> bitemyapp: maybe it will just take some time to see it, but monads also have this property of being simple and focused
17:59:59 <bitemyapp> jmcarthur: *I* see it that way, learners do not.
18:00:04 <jmcarthur> bitemyapp: ah, fair enough
18:00:10 <bitemyapp> jmcarthur: the current way people get exposed to monads seriously confuses them.
18:00:18 <bitemyapp> lots of babbling about context and burritos.
18:00:20 <jmcarthur> i agree that they are presented terribly
18:00:23 <levi> It's sort of like Backus' FP language, where he wanted all programs to be able to be constructed algebraically from simpler parts.
18:00:43 <bitemyapp> jmcarthur: but that's why I progress from typeclasses, to functors, to monads explaining in terms of capability + laws.
18:00:44 <jmcarthur> levi: i want that too! just not necessarily syntactically
18:01:21 <bitemyapp> I'd kinda like a Haskell with S-expressions.
18:01:33 <bitemyapp> it's a nice way of slashing the gordian knot of syntax.
18:01:41 <bitemyapp> "it's a tree. Deal with it."
18:01:56 <levi> You can very nearly write Haskell like that now.
18:02:18 <bitemyapp> I know, but you know what I mean.
18:02:24 <bitemyapp> it'd make TH nicer too.
18:03:54 <levi> BTW, I disagree that free monads are necessarily syntax-oriented. But I do think they're probably best used as a stepping stone to a more specialized monad.
18:06:21 <jmcarthur> levi: basically the only semantics a free monad has is that it's a monad. everything else is up to an interpreter.
18:06:56 <levi> I mean, List is the free Monoid, and although there are often better Monoids to use than List for specific tasks, sometimes you don't know everything you're going to want to do with your Monoid yet.
18:07:04 <jmcarthur> levi: by syntax-oriented i mean in a fairly formal sense that it's just an initial encoding with a minimal set of laws tacked on
18:08:12 <jmcarthur> levi: right. it's an initial encoding. syntax-oriented. i don't mean that it's *always* bad for exactly the reason you just gave: sometimes you don't know in advance what semantics you want and really all you want *is* a syntax
18:10:20 <levi> I think byorgey's Functional Pearl on Monoids is a good example of how one starts with a Free encoding and gradually refactors towards a more structured one.
18:10:55 <Eduard_Munteanu> Oh, I think I figured it out: evil-auto-indent was set
18:11:45 <jmcarthur> ah i don't think i have read that
18:12:15 <levi> It's based on the Monoidal stuff in Diagrams.
18:13:31 <jmcarthur> ah, i have seen it before, but never read it
18:26:12 <dario> hi
18:26:30 <dario> can anyone tell my why there's no more ghci when using the llvm backend?
18:27:42 <jmcarthur> why will we have closed type families in ghc 7.8 but not closed data families? i know GADTs kind of fill that gap, but data families would allow me to use cheaper newtypes for some constructors :\
18:29:46 * hackagebot enummapset-th 0.6.0.1 - TH-generated EnumSet/EnumMap wrappers around IntSet/IntMap.  http://hackage.haskell.org/package/enummapset-th-0.6.0.1 (LiyangHu)
18:32:09 <joelteon> :t (᭚)
18:32:10 <lambdabot> lexical error at character '\173'
18:32:22 <joelteon> :t (₨)
18:32:22 <lambdabot> lexical error at character '\130'
18:32:26 <joelteon> damn it, lambdabot
18:33:37 <danharaj1> edwardk: Last night was fun. I found a paper by Jeremy Gibbons that observes the fact that lenses come from a monad on a slice category this morning :)
18:33:44 <Peaker> what GHC version added atomicModifyIORef' ?  I'm wondering if it's sane to add a dependency on it to GLFW-b in a pull request
18:33:53 <edwardk> yeah, gibbons and jacobson
18:34:26 <edwardk> i seriously underestimated the amount of time it was going to take to walk home. =)
18:34:51 <danharaj> haha
18:34:53 <danharaj> it was fine
18:35:03 <danharaj> oh
18:35:06 <danharaj> do you mean to YOUR house?
18:35:13 <danharaj> because that may have been even worse :P
18:39:20 <thebnq> Do free monads always have to build up a structure?
18:40:45 <bitemyapp> well, there's probably not much in the way of "always" involved in anything
18:40:52 <levi> In just the same way that lists build up structure.
18:40:55 <simpson> ^^
18:40:57 <Peaker> IIUC: The "Free Monad" (or free anything) always obeys no laws besides the stated ones. That means it must record (in some structure) everything that happened. If it "loses information", then you could form new equality laws that it would hold
18:41:25 <Peaker> OTOH, it *must* lose the information that would break the stated laws
18:41:40 <simpson> You could consume a free monad as you built it, in the same way that you can build a list while folding over it.
18:42:08 <Peaker> (i.e: Free Monoid must forget whether it was (x `mappend` y) `mappend` z   or    x `mappend` (y `mappend` z),   at least Eq-wise.    But it must not forget x `mappend` y   vs   y `mappend` x
18:42:24 <Peaker> simpson: operationally you could but you'd still build up the structure denotationally
18:42:31 <simpson> Yeah.
18:42:44 <thebnq> I see
18:43:12 <Peaker> this is based on my reverse engineering of what "Free" means, so I might be wrong :)
18:44:36 <bitemyapp> new hpmor chapters, chili, tea, and free monads. Good evening so far :)
18:45:04 <shachaf> Peaker: The general definition of "free" is along the lines of: "A* is a free monoid on A" means that, for any monoid M, there's a bijection (natural in A) between functions : A -> M and monoid homomorphisms : A* -> M
18:45:29 <shachaf> Er.
18:45:31 <shachaf> I mean natural in M.
18:46:10 <jmcarthur> thebnq: yes, although you could obscure it, and perhaps make it possible for GHC to avoid building the structure, depending on how you instantiate this class...     class Monad m => MonadFree f m | m -> f where wrap :: f (m a) -> m a      newtype Free f a = Free (forall m. MonadFree f m => m a)
18:46:26 <Peaker> shachaf: I don't know what "natural" means
18:46:47 <jmcarthur> thebnq: the GHC claim depends on how inlinable your code is
18:46:50 <Peaker> shachaf: or what "monoid homomorphisms" mean. I'll read up on the necessary CT sometime :P
18:46:54 <shachaf> It means that it's natural. :-)
18:47:00 <levi> What's hpmor?
18:47:08 <bitemyapp> levi: hpmor.com
18:47:12 <shachaf> You maybe don't have to worry about that part so much. That's why it's in parentheses.
18:47:13 <Peaker> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-IORef.html#atomicModifyIORef%27 <-- this seems suboptimal to me
18:47:13 <bitemyapp> levi: it's quite addictive :)
18:47:56 <shachaf> Peaker: A monoid homomorphism isn't really a CT thing. It's a function between monoids that preserves monoid structure, i.e. f mempty = mempty, f (x <> y) = f x <> f y
18:47:58 <jmcarthur> hmm, interesting... the Free i just wrote there doesn't necessarily require Functor f. maybe it's wrong, or maybe that's actually interesting.
18:48:27 <Peaker> shachaf: ah, I see
18:49:00 <jmcarthur> Peaker: what exactly is suboptimal about that?
18:49:59 <Peaker> jmcarthur: I take it back, I thought the forcing happens in the critical section of the swap (making it likely it would need to loop) but the "seq" is on the result so will be forced outside the critical section
18:50:14 <Peaker> (rather than the seq being on the new value or the pair returned)
18:50:29 <jmcarthur> Peaker: oh, you are referring to the NHC case?
18:50:36 <Peaker> nhc?
18:50:47 <shachaf> Peaker: Anyway that's a very general definition which I like because it's short. But your reverse-engineering answer sounds reasonable too.
18:50:55 <jmcarthur> Peaker: note the ifdefs
18:50:57 <Peaker> It uses the XCHGCMP loop trick to do the swap atomically, which is really nice
18:51:21 <jmcarthur> Peaker: ah, you didn't link to the GHC implementation. you linked to the Data.IORef source
18:51:28 <Peaker> jmcarthur: Oh, don't know what's that about
18:51:40 <Peaker> jmcarthur: you know the CMPXCHG stuff done by atomicModifyIORef?
18:51:59 <jmcarthur> Peaker: i know what i've guessed about how it works
18:52:23 <Peaker> jmcarthur: same here :) It relies on a "critical section" being very quick/cheap -- i.e: the computation of what thunk to put in place of the old one
18:52:26 <jmcarthur> Peaker: which is that it just creates a thunk (which should be really quick) and then does a compare-and-swap
18:52:29 <shachaf> Peaker: In particular, if you have an algebraic structure like a monoid or group with a bunch of operations and a bunch of laws, then a free structure on some set means: Start with every element of the set. Build up every possible thing that you can build with the operations. Then call things equal only when the laws force you to do it.
18:52:40 <Peaker> jmcarthur: in that critical section, if you take your time, you might collide and it will need to busy-loop more often
18:52:52 <jmcarthur> right
18:53:06 <Peaker> jmcarthur: yeah, so I misunderstood the "seq" there as making the "really quick" part not quick, but I was fortunately wrong :)
18:53:29 <Peaker> shachaf: that sounds like it matches my intuition/reverse engineering of it :)
18:53:29 <jmcarthur> Peaker: my confusion stems from not seeing a seq in the source you linked
18:54:07 <Peaker> jmcarthur: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-IORef.html#atomicModifyIORef%27 <-- I linked directly to atomicModifyIORef' which has 2 seqs
18:54:11 <jmcarthur> Peaker: oh, my browser didn't focus on the anchor due to hitting the bottom of the page
18:54:23 <shachaf> Peaker: Yep.
18:54:27 <jmcarthur> Peaker: nevermind me then :)
18:54:36 <Peaker> jmcarthur: heh, never mind me, everything's optimal :)
18:55:41 <Peaker> jmcarthur: I think I have a fix for the GLFW-b callback issue
18:56:05 <Peaker> (Haskell callbacks from C, having exceptions causing undefined behavior)
18:56:29 <jmcarthur> Peaker: i'm interested!
18:56:50 <jmcarthur> Peaker: and also interested in why it's a "fix". is this something unsupported by ghc? unknown?
18:57:08 <Peaker> I add another ugly IORef for scheduled callbacks. Instead of directly executing the user callback, I just add it to the list of scheduled [IO ()] actions, and have the pollEvents/waitEvents and maybe a few more sequence_ that IORef
18:57:34 <Peaker> jmcarthur: The Haskell report FFI section says that it's undefined behavior to throw exceptions from Haskell to C
18:57:40 <Peaker> (in GHC it kills the RTS)
18:58:06 <jmcarthur> ah, gross
18:58:20 <Peaker> there's not much that can be done, really
18:58:35 <jmcarthur> it doesn't even give you anything on stderr?
18:58:48 <Peaker> it does.. A print of the exception, and sometimes "Interrupted"
18:58:52 <jmcarthur> ah
18:58:57 <jmcarthur> well, that's okay then, IMO
18:59:00 <jmcarthur> as long as you are notified
18:59:01 <Peaker> but all the Haskell threads are ungracefully terminated, though
18:59:14 <Peaker> jmcarthur: I was very puzzled about why my "bracket_" finalizer was ignored
18:59:39 <jmcarthur> that's a shame, but i don't think i would feel good using C->Haskell callbacks in a "production system" anyway
18:59:43 <shachaf> Is there a simple precise explanation of what "natural in M" means without actually explaining natural transformations and so on?
18:59:55 <Peaker> jmcarthur: If you use GLFW-b, you use them anyway
19:00:06 <Peaker> jmcarthur: they're probably hidden in many libraries
19:00:06 <jmcarthur> Peaker: right, but GLFW-b is unlikely to be "production"
19:00:19 <jmcarthur> Peaker: yeah, i'm a little more worried about that possibility i suppose
19:00:22 <Peaker> jmcarthur: I'd put GLFW-b in production :)
19:00:36 <jmcarthur> Peaker: production means different things to different people
19:00:54 <Peaker> I use C in production with much worse potential undefined behavior :)
19:00:57 <jmcarthur> Peaker: maybe i mean "critical system"
19:01:26 <jmcarthur> Peaker: e.g. the project i work on at work is a critical system in that if it goes down we lost (tons of) money
19:01:45 <jmcarthur> Peaker: or at least it has opportunity costs
19:02:04 <jmcarthur> Peaker: but a game? not critical, don't care
19:02:16 <jmcarthur> Peaker: to a gamer, a freeze is only barely worse than a real crash anyway
19:02:54 <Peaker> jmcarthur: If a storage system controller goes down, a lot of money is lost
19:03:00 <Peaker> They're mostly written in C
19:03:20 <Peaker> (Storage down -> All databases/file systems down -> All apps down -> Multiple businesses go down ...)
19:03:28 <bitemyapp> naive C is the worst. You get people failing to check for error conditions, then the code goes off and corrupts some state.
19:03:36 <bitemyapp> *gag gag gag*
19:03:42 <Peaker> bitemyapp: I use __attribute__((warn_unused_result)) on all error codes
19:03:54 <Peaker> bitemyapp: so it's relatively safe
19:04:08 <bitemyapp> Peaker: that's wise, but I know you from ##C, you're not likely to make as many mistakes as some I've observed anyway.
19:04:22 <bitemyapp> you're one of those eldritch creatures that has UB memorized from the standard.
19:04:59 <Peaker> bitemyapp: I think I learned all my language lawyering from ##c and mauke :)
19:05:15 <bitemyapp> Peaker: not surprising. Were you at EFNet too?
19:05:22 <Peaker> I think so, many years ago
19:05:32 <bitemyapp> yeah. a whole epoch ago really.
19:05:55 <bitemyapp> EFnet was a nice little Mos Eisley.
19:06:41 <levi> Peaker: I have a coworker who wrote telecom switch firmware in C for Lucent back in the day. Another domain where the system going down was a Really Big Deal.
19:06:58 <levi> Actually two coworkers who did that.
19:07:23 <bitemyapp> levi: most embedded types or anywhere reliability is needed that use C end up developing a lot of discipline and ritual around how they build stuff.
19:07:37 <bitemyapp> you basically can't ever be expressive about anything.
19:08:22 <carter> bitemyapp: Peaker  isn't the point of Rust to help  with that a bit?
19:08:38 <bitemyapp> carter: I suppose so.
19:09:01 <bitemyapp> carter: I'm more encouraged by Rust than anything else that claims to sit at that end of the abstraction ladder but I'm not sure Haskell couldn't have been leveraged to the same ends.
19:09:16 <carter> bitemyapp: i don't disagree
19:09:41 <carter> i've some performance type systems ideas i'm aiming to get into GHC, and i'm going to see about getting them into Rust as a warm up
19:09:57 <Peaker> bitemyapp: A lot of testing and QA are important..  Even bad C, with enough (expensive) QA, can be passable, reliability-wise.  This is terrible for costs, but my point is that bad C practices result more in very expensive development than in unreliability (in these domains)
19:10:01 <carter> performance meaning SIMD related ops that need a type system extension
19:10:03 <bitemyapp> we have primitives, a powerful type system, green threads, and FFI. Why not spend a little time experimenting with that before making a whole language?
19:10:15 <carter> bitemyapp: i'm not
19:10:16 <bitemyapp> Peaker: about what I would figure.
19:10:35 <bitemyapp> carter: sorry, you're not what?
19:10:37 <carter> oh
19:10:41 <carter> i'm not writing my own language
19:10:43 <Peaker> bitemyapp, carter: I don't think GC'd languages are a good fit for these high-performance things
19:10:45 <carter> yes
19:10:47 <carter> that too
19:10:49 <bitemyapp> carter: I'm speculating at Graydon and pcwalton's approach to Rust.
19:10:50 <carter> well, depends
19:10:52 <brtaylor92_> this may be a bigger can of worms than I want to open, but is it possible to do memoization in haskell?
19:10:54 <levi> bitemyapp: For some domains, less really is more.
19:10:58 <joelteon> brtaylor92_: yes
19:11:01 <carter> bitemyapp: they need stuff ghc can't do
19:11:05 <bitemyapp> Peaker: uh maybe, it seems to me you could do things to avoid allocation in Haskell.
19:11:12 <carter> yes you can
19:11:13 <carter> buttt
19:11:13 <Peaker> bitemyapp: in a large, complicated system?
19:11:15 <carter> theres a cost
19:11:20 <carter> exactly
19:11:23 <carter> you cant enforce it
19:11:25 <bitemyapp> Peaker: I wasn't saying they'd be able to use Haskell whole-sale for their problems.
19:11:27 <Peaker> bitemyapp: AFAIK, you can avoid allocations in a small function?
19:11:30 <carter> yes
19:11:33 <bitemyapp> I was thinking of an extension for tracking allocations/scope.
19:11:40 <carter> bitemyapp: then it'd not be haskell
19:11:43 <Peaker> bitemyapp: that might work, but probably not in Haskell
19:11:52 <bitemyapp> carter: leveraging the work that has gone into GHC is no mean feat.
19:11:54 <carter> Discipline is a pretty neat strict haskell
19:12:02 <carter> leveraging which?
19:12:10 <levi> carter: Disciple, you mean?
19:12:13 <carter> yes
19:12:17 <carter> same idea :)
19:12:27 <bitemyapp> I guess if you have to ditch laziness and GC, it would make things awkward. Just seems a waste. Oh well.
19:12:37 <brtaylor92_> joelteon: would you mind showing me a quick example? something like fibonacci?
19:12:39 <bitemyapp> I'd rather live in a world with Haskell and Rust than Go and Java.
19:12:46 <carter> bitemyapp: my reason for interst in rust is that while my flag ship project right now is in haskell
19:12:47 <bitemyapp> at least they get the immutability thing.
19:13:00 <carter> i need a sane story for making the ideas usable to folks in other langs
19:13:08 <carter> Rust has enough fancy types that I can even try to do it
19:13:09 <bitemyapp> carter: huh?
19:13:17 <carter> i've some HPC codes i'm writing
19:13:24 <carter> that heavily heavily use having a real type system
19:13:26 <joelteon> brtaylor92_: http://hackage.haskell.org/package/memoize-0.6/docs/src/Data-Function-Memoize.html#memoize3
19:13:27 <carter> to make it easy to write them
19:13:29 <bitemyapp> carter: I've had no trouble teaching Haskell conceptually and practically to my coworkers so far.
19:13:33 <carter> soke
19:13:38 <Peaker_> carter: I dislike Disciple.. I think shunning Monad transformers for "effectful functions" loses necessary expressiveness
19:13:39 <carter> not what i'm saying
19:13:47 <joelteon> brtaylor92_: my mistake, the memoize package
19:13:53 <carter> Peaker_: yeah,  different composition orders have different semantics
19:13:59 <carter> bitemyapp: i'm not saying that
19:14:04 <Peaker_> carter: some describe that as a bug, but it's a useful feature
19:14:09 <carter> it is !
19:14:11 <carter> and deliberate
19:14:12 <bitemyapp> carter: I'm just not seeing how Rust would help teach Haskell.
19:14:15 <carter> nope
19:14:18 <carter> bitemyapp: not what i'm saying
19:14:23 <carter> i'm writing tools in haskell
19:14:26 <bitemyapp> sorry, take another whack.
19:14:36 <carter> people want to use something like those tools, in other langs
19:14:45 <carter> the only other lang that has nearly the right type features
19:15:03 <Peaker_> There's Mu for a strict Haskell, need not go as far as Disciple :)
19:15:04 <carter> and easy to call into (ie can expose functions via a c abi)
19:15:08 <carter> is Rust
19:15:13 <Peaker_> (hopefully it gets opensourced at some point)
19:15:15 <carter> it'll be a wimpy version of the same tools
19:15:23 <bitemyapp> carter: what sort of tools?
19:15:30 <carter> numerical haskell :-
19:15:31 <carter> :)
19:15:39 <carter> i want nice things
19:15:46 <carter> so i seem to have to invent / rolll my own
19:16:01 <bitemyapp> that applies to most things.
19:16:03 <carter> trying to get the core array lib api ready for alpha release in a few weeks
19:16:07 <carter> bitemyapp: sadly
19:18:29 <bitemyapp> carter: sometimes I need to move on quickly to "application", but I enjoy exploring my own solutions to problems. Teaches me a lot and sometimes I get a tool out of it.
19:19:49 <carter> true
19:24:53 * hackagebot HsOpenSSL 0.10.3.6 - Partial OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.3.6 (MasatakeDaimon)
19:24:54 * hackagebot GLFW-b 1.4.4 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.4.4 (BrianLewis)
19:28:47 <Peaker_> yay, GLFW-b maintainer awesomely responsive :)
19:28:58 <Peaker_> my fix for the exceptions in GLFW-b callbacks accepted
19:29:06 <Peaker_> awesome :)
19:31:51 <brtaylor92_> http://www.haskell.org/haskellwiki/Memoization#Memoization_with_recursion in the example here, is there a reason memoized_fib is specifically Int -> Integer rather than (Integral a) => a -> a?
19:32:33 <danharaj> ok, so who can recommend a plotting library?
19:33:42 <twiceler> danharaj: I can half-heartedly recommend gnuplot . I use it a lot
19:33:52 <danharaj> where did the other half of your heart go?
19:33:58 <twiceler> danharaj: haskell-chart looks possibly better, though I haven't used it
19:34:36 <twiceler> danharaj: the other half heart doesn't like that (a) it makes curve1.csv files, etc. in the directory and (b) in GHCi, the terminal isn't refreshed or whatever unless you reload your module
19:34:46 <danharaj> ah
19:35:00 <djahandarie> ggplot is the best plotter I've ever used, hands down
19:35:05 <djahandarie> Unfortunately, it's in R, not Haskell.
19:35:06 <djahandarie> :p
19:35:20 <twiceler> danharaj: But other than that, it's a great wrapper for gnuplot - you can do almost anything with it
19:35:50 <danharaj> alright let's see how it goes thx
19:36:16 <djahandarie> danharaj, I assume you won't be around on Wednesday?
19:36:22 <danharaj> djahandarie: alas not
19:36:24 <byorgey> twiceler: what is haskell-chart?  do you mean  Chart?
19:36:38 <twiceler> byorgey: Yeah I mean Chart
19:36:54 <byorgey> oh, the github repo is called haskell-chart, and the package is named Chart on Hackage
19:37:05 <danharaj> byorgey: As the diagrams man, what do you use to plot things in Haskell?
19:37:14 <twiceler> byorgey: I think it's haskell-chart on github
19:37:33 <byorgey> danharaj: I would use Chart if I ever did any charting (it has a diagrams backend now!)
19:37:33 <twiceler> yeah :)
19:37:38 <danharaj> cool
19:37:45 <byorgey> but my research has very little to do with "data"
19:37:49 <djahandarie> Haha
19:37:51 <byorgey> so I never plot things =)
19:37:52 <danharaj> the haddocks of gnuplut are making me squeamish
19:44:55 * hackagebot GLFW-b 1.4.5 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.4.5 (BrianLewis)
19:45:44 <Peaker> jmcarthur: yay, new fixed GLFW-b without the callback undefined behavior is up on hackage... :)
19:49:25 <twiceler> Does haskell-chart have interactivity yet?
19:51:21 <carter> twiceler: nope and its design doesn't have a nice path to that
19:51:31 <carter> theres 1-2 people hacking on ggplot likes for haskell
19:51:38 <carter> if i ever have time, i may too
19:51:49 <twiceler> carter: Oh, I thought there was "picking" support built in somewhere to it
19:51:49 <carter> at this rate i won't
19:51:55 <carter> picking?
19:52:14 <carter> twiceler: got your email (was you right?)
19:52:32 <twiceler> carter: Like some support for a renderer to read back a location. Maybe I'm thinking of diagrams
19:52:36 <twiceler> carter: Yep!
19:53:00 <carter> amusing fact: i have a strong antipathy to yale, but i won't hold it against yah
19:53:00 <carter> :)
19:53:22 <carter> twiceler: interactive data vis is… hard
19:53:24 <carter> too hard
19:53:59 <carter> like,
19:54:10 <carter> i actually think that in general, interactive data vis is wrong
19:54:36 <twiceler> carter: oh bummer :( haha. Yeah, that's why I'm happy with the gnuplot bindings. Gnuplot is very good
19:54:36 <AshyIsMe> it works nicely for maps and finance charts
19:54:55 <carter> AshyIsMe: which?
19:55:04 <carter> the gnuplot stuff?
19:55:49 <dmwit> "interactive data vis is wrong"?
19:56:04 <enthropy> twiceler: use my http://hackage.haskell.org/package/Rlang-QQ ! (if you were into ggplot-like and would like the original)
19:56:22 <AshyIsMe> yeah just "interactive data vis"
19:56:26 <djahandarie> Hah
19:56:34 <AshyIsMe> i wonder if you can do something with ghc2js and use d3js
19:56:42 <carter> probably
19:56:51 <twiceler> the company I work for made this http://metsci.github.io/glimpse/. It's amazing. Too bad it's Java!
19:57:11 <AshyIsMe> it'd be interesting to do an app packaging system with webkit similar to the node-webkit project but with haskell
19:57:12 <carter> theres some very specific use cases  where interative data vis is great
19:57:24 <carter> AshyIsMe: i think theres webkit bindings
19:57:29 <AshyIsMe> https://github.com/rogerwang/node-webkit
19:57:31 <AshyIsMe> oh yeah?
19:57:34 <carter> ask hamishmack
19:57:35 <djahandarie> enthropy, that's actually pretty impressive.
19:57:36 <dmwit> What is the difference between data visualization and interactive data visualization?
19:58:05 <twiceler> enthropy: I've actually never heard of ggplot before
19:58:08 <carter> in data vis thats static, I know how to share the same picture
19:58:10 <carter> each time
19:58:25 <dmwit> Did you not interact with your computer while generating that picture?
19:58:27 <carter> interactive data vis, i have to share the interaction i did to share my understanding
19:58:40 <AshyIsMe> carter: that's an implementation detail though
19:58:44 <carter> hehe
19:58:45 <carter>  a big
19:58:46 <carter> one
19:58:49 <AshyIsMe> yeah true
19:58:52 <AshyIsMe> but still
19:58:56 <dmwit> Could nobody talk to you and say, "Boy, I wish I know such and such a fact that isn't available from this visualization, could you make one that shows something slightly different?"?
19:59:01 <dmwit> Isn't that interactive?
19:59:17 <enthropy> dmwit: interactive is about being able to highlight points on the pictures your visualization does
19:59:30 <carter> and manipuate pretty high dimensional projections
19:59:32 <carter> and other things
19:59:36 <carter> its like designing a video game
19:59:58 <carter> now… designing a good wee tiny video game thats engaging and educational… thats easy right? :p
20:00:16 <dmwit> You didn't claim interactive data visualization was hard, you claimed it was wrong.
20:00:19 <dmwit> Hard I believe.
20:00:19 <carter> no
20:00:21 <carter> i said hard
20:00:31 <carter> i said its often wrong methodologically
20:00:32 <dmwit> 22:43 < carter> i actually think that in general, interactive data vis is wrong
20:00:36 <carter> yes
20:00:37 <carter> in general
20:00:45 <carter> in specific cases its great
20:01:00 <dmwit> Okay then.
20:01:15 <carter> sorry, i'm bad at nuance :)
20:01:31 * geekosaur thinks powerpoint
20:01:31 <carter> i think theres some really great use cases for interactive data vis
20:01:34 <carter> heeh
20:01:52 <geekosaur> (not that it's the same thing, just a similar kind of wrong-in-general)
20:02:04 <carter> but most of the use cases that it rocks  have really really really well understood designs
20:02:16 <carter> like, zooming/scrolling on a time series
20:02:33 <carter> its easy to specify how you interacted with a time series
20:02:36 <logicbuffer> http://hubwaydatachallenge.org/
20:02:37 <carter> as a sequence of time intervals
20:02:41 <logicbuffer> here's your interactive data viz
20:03:27 <carter> toooo much d3
20:03:47 <carter> logicbuffer: actually it illustrates my point greatly
20:03:54 <carter> that good interactives design is hard
20:04:00 <carter> and not a casual thing
20:05:19 <carter> in some ways harder than just doing fancy math
20:05:24 <carter> because you have to show it to people
20:06:01 <logicbuffer> define fancy math
20:08:39 <dmwit> My personal definition is anything more exciting than linear algebra.
20:08:47 <dmwit> Hell, even some bits of linear algebra is fancy. =)
20:08:51 <carter> yup
20:08:56 <carter> sparse SDD solvers are … fancy
20:09:09 <carter> i hope to manage to write one correctly by february
20:09:26 <carter> twiceler: an open gl backed plotting tool would be sweeet
20:10:30 <twiceler> carter: Yeah, once upon a time I tried haskell-chart with the (experimental) OpenGL backend for diagrams
20:10:37 <carter> ouch
20:10:45 <carter> its not ready for that i think
20:10:54 <carter> watching that video
20:10:58 <carter> i like the examples
20:12:19 <carter> twiceler: holy crap is that video epic
20:12:30 <twiceler> It looked very good; it wasn't very responsive though. I'm not sure if that's due to the design of diagrams or whether the OpenGL backend could be optimized better
20:12:58 <carter> both
20:13:01 <carter> probably both
20:13:39 <twiceler> carter: yeah! There's this really cool demo in the examples with one of the target-tracking demonstrations. It's incredible
20:13:59 <carter> twiceler: if you hit perf problems in diagrams, report them!
20:14:21 <carter> they loove examples that break things :)
20:14:25 <gnuvince> Is there a way in Happy to refer to the actual token rather than its payload in a production?  I have a production that looks like: expr : int { TInt $1 (tokenPos $1) }, but this fails because $1 is an Int, not a Token.  Can I give something to tokenPos to get the position of the actual token object?
20:15:39 <enthropy> gnuvince: I think you need to change how you defined `int' so that it's like a (Token, Position)
20:16:03 <enthropy> which will make the rest of your productions uglier
20:17:00 <gnuvince> hmmm
20:17:31 <twiceler> carter: Well, it was that OpenGL backend where I had the performance issues. which is self-described as "very immature". And I honestly don't know whether it's on that end or the haskell-chart end
20:17:40 <carter> well
20:17:44 <carter> report problems
20:17:55 <carter> just writing knowledge down is valuable
20:18:00 <carter> so someone else can dig int later
20:20:33 <twiceler> carter: yeah
20:22:02 <gnuvince> enthropy: I think I'm just going to avoid using $$ in the token definitions
20:39:20 <cschneid> is there a rundown of the current status of ios haskell? What's easy, what's hard, how to setup, etc?
20:43:29 <Fuuzetsu> cschneid: It's a pretty fresh feature so I don't think there is.
20:43:37 <cschneid> that's what I figured.
20:43:45 <cschneid> I'll hit up the mailing list :)
20:47:38 <brtaylor92_> is there a pattern to match a list with only a single element?
20:47:53 <arkeet> like [x]?
20:48:10 <tromp> singleton [x] = True
20:48:32 <arkeet> if you don't care about what x is you can use [_]
20:48:39 <Iceland_jack> [x] which is shorthand for (x:[])
20:49:09 <tromp> @src last
20:49:09 <lambdabot> last [x]    = x
20:49:10 <lambdabot> last (_:xs) = last xs
20:49:10 <lambdabot> last []     = undefined
20:49:14 <Iceland_jack> > let { singleton [_] = True; singleton _ = False } in singleton "a"
20:49:15 <lambdabot>  True
20:49:16 <Iceland_jack> > let { singleton [_] = True; singleton _ = False } in singleton "ab"
20:49:17 <lambdabot>  False
20:49:19 <brtaylor92_> Ok. That makes sense. I wasn't sure if [x] might match any arbitrary list, or if it did limit to single element
20:49:52 <Iceland_jack> brtaylor92_: That seems to be a common point of confusion :) for completeness, (x:xs) can match any arbitrary (non-empty) list
20:50:18 <arkeet> xs can match any list
20:50:26 <arkeet> so it all makes sense
20:50:28 <Iceland_jack>     foo []      -- only empty list
20:50:28 <Iceland_jack>     foo (x:xs)  -- only non-empty lists
20:50:28 <Iceland_jack>     foo [x]     -- only singleton list
20:50:28 <Iceland_jack>     foo xs      -- any list
20:50:42 <arkeet> you can match lists of any length you like
20:50:44 <Iceland_jack> And of course you can extend that to lists of length 2, 3, ….
20:50:46 <arkeet> [x,y,z] will match a 3-element list.
20:50:57 <arkeet> (same as writing x:y:z:[])
20:51:17 <Iceland_jack> > let x:y:z:[] = "abc" in z:y:x:[]
20:51:18 <lambdabot>  "cba"
20:51:30 <Iceland_jack> > let x:y:z:[] = "abcd" in z:y:x:[] -- but watch as I add another character...
20:51:31 <lambdabot>  "*Exception: <interactive>:3:5-21: Irrefutable pattern failed for pattern x ...
20:51:34 <Iceland_jack> Boom!
20:54:45 <brtaylor92_> ahhhh... I forgot to match the empty list. that's why it wasn't working
20:54:55 <gamegoblin> How are these different:  f l@(Left _) = l   ...... and ......... f (Left l) = Left l
20:55:13 <Iceland_jack> gamegoblin: They aren't
20:55:24 <gamegoblin> Iceland_jack GHC disagrees, which is what is bothering me
20:55:28 <arkeet> they're subtly different.
20:55:31 <shachaf> gamegoblin: The type can change int he second one.
20:55:33 <arkeet> ^
20:55:47 <gamegoblin> Ooooooooo
20:55:50 <gamegoblin> Good call
20:55:52 <gamegoblin> You nailed it
20:55:54 <gamegoblin> I see it now
20:55:55 <Iceland_jack> Ah yes
20:56:06 <gamegoblin> It is changing from Either A B to Either A C
20:56:06 <arkeet> :t let f (Left l) = Left l in f
20:56:07 <lambdabot> Either a t -> Either a b
20:56:09 <gamegoblin> yeah
20:56:10 <Iceland_jack> Null ∷ Null a ≠ Null ∷ Null b :)
20:56:14 <arkeet> :t let f l@(Left _) = l in f
20:56:15 <lambdabot> Either t t1 -> Either t t1
20:56:30 <gamegoblin> Deep voodoo. Thanks a lot.
21:00:40 <brtaylor92_> Is there a meaningful performance difference between these two implementations? http://lpaste.net/7515750081425833984
21:01:30 <Iceland_jack> brtaylor92_: You can test it out yourself! (install Criterion) but no there shouldn't be
21:01:51 <arkeet> there is a semantic difference between them though
21:02:01 <Iceland_jack> arkeet: That doesn't matter!
21:02:05 <arkeet> oh
21:02:10 <arkeet> but I mean they give different results
21:02:19 <brtaylor92_> how so?
21:02:29 <rose_> I want to keep a database connected open throughout a GHCI session, but I don't want to have to pass the connection in as a parameter to every function. I could avoid passing the parameter by reopening the connection in every function. Is there a more efficient way?
21:02:42 <arkeet> e.g.
21:02:47 <arkeet> the first qs [1] is [1]
21:02:51 <arkeet> the second qs [1] is an infinite loop
21:03:37 <brtaylor92_> not when I run it it isn't...
21:03:47 <arkeet> maybe I'm confused.
21:03:51 <arkeet> oh yes I am.
21:03:56 <arkeet> carry on.
21:03:56 <gamegoblin> arkeet: qs 1 will yield: qs [] ++ [1] ++ qs []
21:04:11 <rose_> I guess I could turn all my functions into closures, and I could close over the db connection...
21:04:30 <rose_> is that the best solution?
21:06:00 <gamegoblin> rose_ I think having all of your functions inside of the scope of another function and have your connection within that scope is the best bet
21:06:14 <gamegoblin> But to be honest, passing around a connection isn't that awful
21:07:04 <brtaylor92_> Iceland_jack: I don't have most of the dependencies for Criterion. Is it something I'm going to use a lot which I should take the time to set up?
21:07:27 <brtaylor92_> I'm mostly just learning right now, and was curious how expensive the extra 2 recursive calls in the latter version would be
21:07:33 <Iceland_jack> brtaylor92_: That depends on how much profiling you plan on doing, it's not essential
21:07:55 <arkeet> it probably makes some constant factor difference
21:07:57 <rose_> gamegoblin: I'll be typing the commands myself from ghci. I want to avoid having to type add connection "item to add" every time... how could I put all the actions in the scope of a GHCI session in the same scope?
21:08:13 <brtaylor92_> but is it a large constant factor?
21:08:23 <arkeet> ask criterion
21:09:16 <svref> What's the name of the thing that if evaluated will cause Haskell to crash?
21:09:27 <Iceland_jack> undefined
21:10:00 <svref> thanks
21:10:04 <gamegoblin> rose_ Just curious, why are you doing everything in GHCI and where are the functions you are using coming from?
21:10:31 <rose_> I'm using GHCI so I can have a read/eval/print loop. The functions are just coming from one file that I load
21:10:45 <gamegoblin> How are you loading it?
21:10:50 <rose_> :l
21:10:59 <rose_> it's a simple script to add and view things in a database
21:12:07 <brtaylor92_> is there an easier way to add modules from hackage than just downloading the source and building by hand?
21:12:21 <gamegoblin> brtaylor92_ : cabal install?
21:12:28 <brtaylor92_> huh
21:12:31 <brtaylor92_> I had no idea that was there
21:12:43 <gamegoblin> brtaylor92_ : cabal install myfavoritepackage
21:12:43 <gamegoblin> etc
21:12:58 <brtaylor92_> good to know
21:13:04 <gamegoblin> rose_ Hmmm I guess I don't entirely understand your problem then
21:13:06 <brtaylor92_> installing criterion suddenly looks much less painful
21:14:32 <gamegoblin> rose_: let's say all your functions use some variable called "conn". In GHCI you could do "let conn = makeMyConnectionPlease"
21:14:43 <gamegoblin> rose_ and then do ":add myActionsINeed.hs"
21:14:54 <gamegoblin> Which should load all of your functions into GHCI
21:15:21 <rose_> but then I have to manuall pass conn to every function
21:16:38 <gamegoblin> Do you only have one connection?
21:18:33 <rose_> gamegoblin: yes
21:18:49 <gamegoblin> rose_ if you only have one connection, what is stopping you from sticking a nice global "conn = makeMyConnectionPlease" at the start of your file, have all of your functions reference conn, and then :add your program into GHCI?
21:18:50 <rose_> \msg gamegoblin hi
21:20:22 <rose_> I tried that, but the conn wasn't in the scope of the functions... unless I make them closures?
21:20:32 <rose_> hold on
21:20:42 <brtaylor92_> hmm, building aeson failed
21:21:01 <brtaylor92_> and a lot of build warnings
21:21:03 <gamegoblin> brtaylor92_ did you use sudo (or whatever your system equivalent is)? What was the error?
21:22:31 <brtaylor92_> gamegoblin: yes, sudo was used. the tail of the output is here: http://lpaste.net/97042
21:23:05 <zq-_> @src concat
21:23:05 <lambdabot> concat = foldr (++) []
21:23:50 <hattusili_III> is anyone here familiar with conduits, and the http-conduit package in particular?
21:23:55 <gamegoblin> brtaylor92_ no idea... some older packages are poorly maintained...
21:28:44 <brtaylor92_> well, I'll keep poking at it
21:31:41 <zq-_> why can't haskell keep track of the last element in a list so that appends are constant time?
21:32:05 <joelteon> because that's not how list is designed
21:32:26 <jle`> zq-_: remember, lists are immutable
21:32:44 <ion> There are other data structures designed for O(1) appends.
21:32:45 <jle`> zq-_: you have to "change" the last element of the list
21:32:51 <jle`> to point to the new one
21:33:04 <jle`> so basically you have to replace that last element to a new list object
21:33:05 <zq-_> prepends are constant though
21:33:11 <Iceland_jack> Yes
21:33:11 <jle`> and so you have to change the second to last element
21:33:15 <joelteon> yeah, it's because it's a linked list
21:33:23 <jle`> so you can't add a new element without re-creating every single element of the list
21:33:28 <zq-_> prepend would still 'change' the last element of the first list
21:33:35 <jle`> zq-_: it won't
21:33:39 <zq-_> what
21:33:40 <jle`> linked lists don't point backwards
21:33:45 <zq-_> reread
21:33:48 <zq-_> last element of the first list
21:34:04 <jle`> in a prepend, the entire original list is not copied and remains unchanged
21:34:10 <jle`> the new element just points to the head of the original list
21:34:38 <Iceland_jack> zq-_: Are you mistaking the type signature of this ‘prepend’? It's a → [a] → [a], not [a] → [a] → [a]
21:34:39 <zq-_> ugh
21:35:14 <jle`> ah do you mean 'first' as in preceding, not original
21:35:29 <zq-_> preceding, sorry
21:35:30 <jle`> if you are talking about [a] -> [a] -> [a], that is not constant time either
21:35:37 <Iceland_jack> You only prepent a *single* element to a list in constant time
21:35:50 <Iceland_jack> That's caled consing (:)
21:35:50 <Iceland_jack> @ty (:)
21:35:51 <lambdabot> a -> [a] -> [a]
21:35:58 <jle`> in the case of (++), the entire "first" list is replaced/recreated
21:36:08 <jle`> (:)/cons is the case where nothing is replaced/recreated
21:36:16 <zq-_> still, cons modifies the pointer of the new head
21:36:50 <jle`> zq-_: it creates a new head element and has it point to the head of the original list
21:37:03 <jle`> it only creates one element
21:37:03 <ion> “x : xs” doesn’t modify x or xs.
21:37:12 <jle`> which is why it's O(1)
21:37:18 <Iceland_jack> zq-_: There are no pointers, my I presume that you're coming at this problem from a C/C++ perspective?
21:37:22 <Iceland_jack> *may
21:37:28 <zq-_> why can't you optimize it to O(1) if you know that the language requires the original list stay the same?
21:37:35 <zq-_> Iceland_jack: yeah.
21:37:52 <jle`> zq-_: optimize (++) ?
21:38:02 <Iceland_jack> I promise you that that level of abstraction will get in the way
21:38:19 <zq-_> jle`: yeah.
21:38:22 <Iceland_jack> Immutability and laziness change the way you need to think
21:38:26 <jle`> you can't make (++) O(1) unless you destroy the previous list
21:38:36 <jle`> but functional data structures are all persistent
21:38:44 <ion> You can make an implementation of an immutable singly-linked list in C and it’ll have all the same properties, though.
21:38:48 <jle`> you lose the ability to access the old one
21:39:11 <zq-_> i can't get this
21:39:33 <scott_> zq-_: To make (++) O(1) you'd have to modify it's last tail pointer to point at the new list. But you aren't allowed to modify.
21:39:35 <zq-_> rephrase: why can't ghc "cheat" by modifying the pointer of the last element of the preceding list?
21:39:44 <jle`> zq-_: because now you can't access the unchanged list
21:39:56 <jle`> the list before the append
21:39:57 <zq-_> fuck, you're right
21:40:21 <enthropy> also you need to traverse the whole list to get that "last pointer"
21:40:35 <zq-_> enthropy: yeah that's the point of keeping track of the last one
21:40:44 <Iceland_jack> But you couldn't modify it anyway zq-_
21:40:51 <jle`> even if there is some overhead in keeping track of the last pointer, you still need to recreate the entire list to add one element to the end
21:41:00 <jle`> whereas if you cons
21:41:06 <jle`> the original list can remain in memory unchanged
21:41:11 <jle`> and still be accessed
21:41:27 <zq-_> jle`: but by the same token, since cons-ing doesn't recopy the old list, the old list'd be inaccessible after the cons, no?
21:41:36 <Iceland_jack> The singly-linked list is not an example of a ‘highly performant’ data structure
21:41:42 <jle`> zq-_: the old list would be accessible by a reference to the original head
21:42:01 <jle`> and you would be none the wiser
21:42:21 <zq-_> then why can't you cheat that way in a universe where the tail element is tracked too?
21:42:46 <zq-_> last element*
21:43:05 <jle`> because you have to "change" the next pointer in the last element to be Nil
21:43:10 <scott_> zq-_: x : xs builds a new cons cell containing a pointer to x and a pointer to xs, basically
21:43:11 <jle`> er
21:43:13 <jle`> from nil
21:43:14 <scott_> x and xs are not modified
21:43:25 <jle`> when you add an element, the tail element must be modified/recopied
21:43:36 <jle`> if you cons an element, no part of the original list must be modified/recopied
21:44:03 <jle`> and remember, if the tail element is modified/recopied
21:44:14 <jle`> the second-to-last element muist be modified/recopied to point to the "new" tail element
21:44:16 <jle`> by tail i mean last
21:44:16 <hattusili_III> is anyone here familiar with conduits, and the http-conduit package in particular?
21:44:21 <ion> There’s no need for ghc to cheat here anyway, if one needs O(1) snoc, one will use a data structure that provides that without cheating.
21:44:36 <jle`> and if the second-to-last element must be modified, then the third-to-last element must be modified to point to the new modified one
21:44:48 <jle`> by modified i mean copied and modified
21:44:53 <ion> Also, keeping track of the last element would be rather problematic with infinite lists.
21:45:11 <zq-_> ion: good point
21:46:00 <maxs___> hattusili_III: I might be why
21:46:17 <jle`> zq-_: http://en.wikipedia.org/wiki/Persistent_data_structure#Linked_lists
21:46:26 <Iceland_jack> Like I said, pointers and memory are not the right level of abstraction for this imo
21:46:42 <Iceland_jack> You *can* apply it but it's not the most beneficial
21:46:45 <jle`> i do recommend taking a look over the okasaki text, it is probably the canonical text for things like this
21:46:58 <zq-_> https://news.ycombinator.com/item?id=6912474) was what got me looking at append/cons complexities, fyi
21:47:12 <Iceland_jack> Okasaki may be a bit advanced for simply exploring persistent data structures
21:47:17 <jle`> Iceland_jack: it's not too much of an abstraction; a list item just as two data fields --- the data itself and the next element
21:47:39 <Iceland_jack> I know, but my comment wasn't limited to the list data structure
21:47:41 <jle`> it might be slightly handwavey
21:47:45 <jle`> ah ok
21:48:13 <ion> newtype struct { int value; list_t *next; } list_t; const list_t foo = { 42, NULL }; const list_t bar = { 41, &foo }; const list_t baz = { 40, &bar };  /* Easy to cons new items in the front, impossible to append to the end without copying or mutation */
21:48:19 <hattusili_III> maxs___, i'm trying to figure out how to get at the bytestrings in the responsebody to do operations on them. all i can do right now is `(responseBody response) $$+- Conduit.Binary.sinkHandle stdout` and print it out
21:48:23 <jle`> the first few chapters of okasaki basically go over this entire subject
21:49:06 <ion> uh… newtype? I’m a bit tired here. :-P
21:49:07 <jle`> er, this exact subject
21:49:19 <ion> typedef
21:49:56 <jle`> zq-_: but check out the wikipedia link, it has a nice illustration/graphic
21:50:37 <maxs___> hattusili_III: responseBody rsp $$+- sinkLbs
21:50:44 <maxs___> I think
21:53:33 <kwos> what's the best library for generating QR codes? does anyone have any strong opinions?
22:17:38 <AVM> testing
22:17:46 <AVM> hello
22:17:54 <AVM> this is my first time on any irc channel
22:19:18 <AVM> i have a very simple question - do MArray instances for STT exist? and if so what module are they in?
22:19:56 <AVM> also i kind of expected more traffic here, how come no one is talking?
22:20:21 <maxs___> AVM: it comes in bursts or waves
22:20:34 <AVM> ah
22:20:59 <AVM> is there a way to reply to a specific person? like did you reply to me specificly or did u just type my nick at the front of your message
22:21:20 <brtaylor92_> AVM: he just typed your nick at the front. I, for example, can still see it
22:21:32 <brtaylor92_> To reply to someone privately, use "/message [username] [message]"
22:21:34 <jle`> you can /query someone to open a private message
22:21:54 <brtaylor92_> or what jle` said
22:22:02 <jle`> AVM: I have had problems with STT and MVector in the past
22:22:07 <AVM> thank you
22:22:13 <AVM> oh yeah?
22:22:29 <jle`> let me link to the SO question
22:22:38 <AVM> sure
22:22:47 <AVM> im getting a cannot deduce for "(MArray a e (STT s1 mr))"
22:22:53 <AVM> which i feel should exist already
22:23:16 <jle`> http://stackoverflow.com/questions/17522198/defining-primmonad-instance-for-stt-st-transformer
22:23:49 <jle`> long story short i ended up thinking that it wasn't worth the effort
22:23:56 <jle`> and decided to rearrange my stack
22:24:05 <AVM> ah
22:24:10 <AVM> thats another thing i was wondering about
22:24:12 <jle`> it actually doesn't make too much sense conceptually to have anything under STT
22:24:15 <jle`> besides IO
22:24:18 <AVM> is the stack order basically arbitrary
22:24:20 <jle`> for me at least
22:24:22 <AVM> except IO at the bot
22:24:28 <jle`> AVM: it's not arbitrary
22:24:30 <hattusili_III> maxs___, https://gist.github.com/MarkJr94/7975626 is what i have so far. what i want to do is apply some action to each byte string. i can't figure it out
22:24:36 <jle`> it should be intentional :)
22:25:01 <AVM> well
22:25:11 <AVM> i have STT s (Rand g)
22:25:12 <jle`> there is a nice text on monad transformers
22:25:19 <jle`> that mentions the differences
22:25:19 <AVM> im randomly reording an array
22:25:29 <AVM> ill take a look at that
22:25:40 <jle`> i am not quite sure where it is, i cna look for you
22:25:53 <AVM> idk if i found it already
22:26:05 <AVM> if its too much effort you dont have too
22:26:31 <AVM> the reason i put STT over Rand is because I wanted to be able to peel off the STT and leave the rand
22:26:37 <jle`> AVM: it's one of those ones that everyone reads i think
22:26:42 <AVM> ah
22:26:45 <jle`> hm
22:26:53 <jle`> i recommend doing it the other way
22:26:59 <AVM> okay
22:27:04 <AVM> however
22:27:14 <jle`> basically you can think of ST as a pure computation/function
22:27:25 <jle`> and so you pass in a seed
22:27:30 <jle`> to ge tout a different result
22:27:38 <jle`> hm. did i get things backwards there?
22:27:47 <AVM> no i think thats right
22:28:05 <AVM> so if I have RandT g (STT s)
22:28:15 <rose_> I have a database function which returns an Action IO Value type, but when I execute the function in ghci it complains because Action has no Show defined.
22:28:15 <AVM> can i peel off the ST from the inside?
22:28:28 <jle`> let me look at my old projects
22:28:35 <rose_> How can I hush that complaint?
22:29:13 <pavonia> rose_: What's the exact result type?
22:29:46 <AVM> hmm
22:29:56 <gamegoblin> pavonia: look at the insert function here (I was helping rose earlier) http://hackage.haskell.org/package/mongoDB-1.4.1.1/docs/Database-MongoDB-Query.html
22:29:56 <rose_> pavonia: add :: String -> Action IO ()
22:30:20 <AVM> i can hoist RandT g (STT s) into RandT g (Identity)
22:30:30 <AVM> but that layer is still there
22:31:30 <jle`> okay, so here is how it conceptually works
22:31:31 <AVM> oh shit i can hoist it into another RandT
22:31:35 <AVM> k listening
22:31:41 <jle`> you want a RandT g ST s
22:31:46 <jle`> (is that the right signature?)
22:31:53 <AVM> need parens but yeah
22:32:02 <AVM> RandT g (ST s)
22:32:02 <jle`> really?
22:32:13 <jle`> hm
22:32:17 <AVM> yeah the monad is (ST s)
22:32:22 <maxs___> hattusili_III: building dependencies...
22:32:36 <jle`> no, it's RandT g m a
22:32:45 <jle`> so m is the monad that it wraps
22:32:45 <pavonia> rose_: So it looks like you need "access" to access the result of the action
22:32:49 <jle`> and a is the value at the bottom
22:32:54 <AVM> yes
22:32:59 <AVM> m == ST s
22:33:05 <jle`> oh yeah
22:33:17 <hattusili_III> maxs___, sorry, and i appreciate the help. i know a bit about functors and monads and stuff but this stuff has just lost me
22:33:25 <jle`> RandT g (ST s) a
22:33:30 <AVM> yes
22:33:32 <jle`> okay
22:33:33 <AVM> thats the full type
22:33:41 <jle`> so when you runRandT
22:34:01 <jle`> what you do is you create a function that, given a seed, generates an ST computation that uses that seed
22:34:41 <AVM> what type is that
22:34:59 <jle`> g -> ST s a, i believe
22:35:11 <AVM> k
22:35:20 <jle`> you can actually think of an ST s a as a self-contained little piece of logic that generates an a
22:35:26 <AVM> right
22:35:30 <jle`> it is a completely "pure" process
22:35:32 <jle`> the a-generation
22:35:41 <jle`> so now, if we pass in a seed
22:35:44 <jle`> we get an ST s a
22:35:52 <jle`> which is a completely pure, self-contained process that generates an a
22:35:55 <AVM> mhm
22:36:00 <jle`> that ST that we "receive" depends on the g
22:36:07 <jle`> so every g generates a different ST
22:36:13 <jle`> and so then
22:36:15 <jle`> we runST that
22:36:31 <jle`> runST meaning, we "evaluate" the computation that we got from (g -> ST s a)
22:36:40 <jle`> and that's your final result
22:36:40 <AVM> mhm
22:36:54 <AVM> thing is that doesnt use the  Rand monad at all
22:37:08 <jle`> you can use rand stuff
22:37:12 <jle`> your top level monad is your rand
22:37:18 <jle`> so the whole time you are in a rand monad
22:37:49 <jle`> you need to lift to get access to any ST stuff
22:38:16 <AVM> so the problem is
22:38:25 <AVM> if I have RandT g (ST s) a
22:38:40 <AVM> I can evalRandIO or w/e to peel off the RandT
22:38:48 <AVM> and I will get ST s a
22:38:56 <AVM> then I can runST to get a
22:39:00 <maxs___> hattusili_III: what you want is `body $$+- CB.sinkLbs`
22:39:14 <maxs___> sinks to a lazy bytestring
22:39:18 <AVM> but I cant get Rand g a at any point
22:39:44 <jle`> AVM: you mean when you are outside of your vector manipulations?
22:39:52 <AVM> yes
22:39:54 <AVM> basically
22:40:07 <AVM> the ST stuff is an implementation detial that should be hidden by the type signature
22:40:12 <AVM> so my function
22:40:24 <AVM> shuffle :: [a] -> Rand g [a]
22:40:29 <AVM> should look like that
22:40:36 <AVM> the ST stuff is just for efficiency
22:41:25 <jle`> you could use a type synonym
22:41:39 <jle`> like RandST g [a]
22:41:45 <jle`> and then define your own runRandST
22:41:52 <jle`> which handles the unfolding for you
22:42:25 <hattusili_III> maxs___, thank you, i'll see if i can go from here
22:42:41 <AVM> but that runs the whole thing
22:42:48 <AVM> from RandST to a
22:42:52 <AVM> *[a]
22:43:17 <jle`> so you want to work in a Rand monad "normally"
22:43:20 <jle`> and then every once in a while
22:43:22 <jle`> jump into an ST?
22:43:27 <jle`> within that rand monad?
22:43:45 <AVM> if you mean what i think you mean, yes
22:44:08 <AVM> so shuffle should just be able to be used as any other monadic function in Rand
22:44:49 <AVM> like i could write it with ST at all
22:44:55 <AVM> but it would be horribly inefficient
22:45:33 <jle`> if you wrap the entire thing in ST, you could pretend you were in just a Rand the entire time i think
22:45:43 <jle`> and only use the ST stuff explicitly with lift
22:45:47 <jle`> but that's really the thing about monad transformers
22:45:51 <jle`> they are inherently hack-ish
22:46:38 <jle`> if you really wanted to only do randST once-in-a-while, you could try just working with a randST *within* your rand, so that you have two separate layers of Rand
22:47:32 <jle`> you do runRandST *inside* your 'outer' Rand, passing in a g that you obtain using getSplit
22:48:33 <jle`> (to the greater audience of this chat --- is this a bad idea? are there better ways to do this?)
22:49:51 <jle`> apparently all of the results of googling RandT and ST in Haskell are stack overflow questions asked by me
22:49:53 <jle`> haha
22:49:55 <gamegoblin> Is there a function that takes a list of stuff and a list of functions and returns a list of the Nth function applied to the Nth stuff?
22:50:07 <jle`> literally all of them...
22:50:18 <jle`> it makes me think that there might be a better approach without RandT altogether
22:50:29 <zRecursive> gamegoblin: map ?
22:50:34 <scott_> gamegoblin: zipWith ($)
22:51:03 <scott_> :t zipWith ($)
22:51:04 <lambdabot> [b -> c] -> [b] -> [c]
22:51:13 <gamegoblin> zRecursive: map just takes one function and applies it. scott_  's works
22:51:15 <AVM> well the shuffle function should eb random
22:51:23 <AVM> so that means
22:51:32 <AVM> im either in the Rand/RandT monad
22:51:37 <AVM> or
22:51:40 <jle`> AVM: if you want to do some research you can check out how people handle this in high performant monte carlo methods or something and they might have better answers
22:51:42 <zRecursive> gamegoblin: double map ?
22:51:49 <jle`> AVM: Rand/RandT isn't the only way to deal with randomness
22:51:56 <jle`> there are actually higher level abstractions believe it or not
22:52:19 <AVM> haskell has higher level abstractions than ive ever dreamt of? no way! =P
22:52:28 <gamegoblin> AVM: This is a shuffle function I use...
22:52:29 <gamegoblin> shuffle :: (RandomGen g) => [a] -> g -> [a]
22:52:29 <gamegoblin> shuffle xs r = map snd $ sortBy (\(a,_) (b,_) -> compare a b) $ zip (randoms r :: [Int]) xs
22:53:10 <gamegoblin> Not the greatest... but it works... it's nlgn rather than the knuth method of linear time
22:53:13 <gamegoblin> But it's dead simple
22:53:21 <AVM> see im doing knuth method
22:53:33 <AVM> requires ST
22:53:44 <gamegoblin> The difficulties you are encountering are precisely why I did it sort-based ;)
22:53:50 <AVM> also I want a monadic function for easy combining
22:53:54 <AVM> haha
22:54:11 <AVM> also no element can end up in the same spot
22:54:21 <external-reality> eitherDecodeStrict' "[1]" :: Either String [Int] = Left "incomplete input"
22:54:41 <AVM> so i know the algorithm i want
22:54:44 <external-reality> eitherDecode "[1]" :: Either String [Int] = Right 1
22:54:49 <AVM> im just still terible at haskell lol
22:55:07 <external-reality> Don't understand that
22:55:21 <jle`> AVM: so yeah, an easy fix right now is to just spend your entire time in your custom RandST stack
22:55:27 <jle`> and if you don't want that
22:55:32 <jle`> live in a normal Rand
22:55:37 <jle`> but write your shuffle in a RandST
22:55:46 <jle`> and then do the manual runRandST, giving in a seed you get from genSplit
22:55:52 <jle`> er, getSplit
22:56:17 <jle`> so runRandST *inside* your Rand monad, by giving it a seed you get from getSplit
22:56:36 <jle`> but i don't think that is necessary unless you are certain you don't want to spend your entire time in a RandST
22:56:49 <pavonia> external-reality: might be a bug
22:58:01 <pavonia> external-reality: Have you seen https://github.com/bos/aeson/issues/161 ?
22:58:11 <AVM> thanks for your help, ill keep thinking about it, but i havent decided yet
22:58:23 <AVM> i think i will stick ST under rand though
22:58:44 <AVM> hmm
22:58:46 <AVM> what if
22:58:59 <AVM> i use Rand g (ST s a)
22:59:19 <jle`> if you might find use of it, here was my learning project for this https://github.com/mstksg/pi-monte-carlo
22:59:24 <jle`> AVM: that is exactly what you would get
22:59:37 <jle`> if you did runRandST inside your Rand
22:59:43 <jle`> well, it'd be the intermediate stage
23:00:22 <jle`> runRandST inside Rand would turn a Rand g (RandST g) a into a Rand g (ST s a) into a Rand g a
23:00:33 <jle`> the first step being runRandT, and the second step being runST
23:01:01 <AVM> oh i see
23:01:03 <AVM> thats like
23:01:26 <AVM> Rand g (STT s (Rand g) a)
23:01:33 <jle`> er no
23:01:46 <jle`> RandST g a = RandT g (ST s) a
23:01:52 <jle`> i dropped an s there sorry
23:01:58 <AVM> oh reversed
23:02:24 <AVM> i dont think the left side needs an s
23:02:25 <jle`> so the un-aliased stack would be Rand g (RandT g (ST s) a)
23:02:45 <jle`> AVM: it only needs an s if you don't want to specify it before-hand i think
23:02:56 <jle`> it's been a while, sorry
23:03:28 <AVM> i agree, i think that would work
23:03:35 <jle`> but yeah, so when you have Rand g (RandT g (ST s) a), you would run runRandT *inside* your outer Rand, with a key you obtain from getSplit, to get Rand g (ST s a)
23:03:44 <jle`> then you would run runST *inside* that outer Rand to get Rand g a
23:04:08 <jle`> of course this is all abstracted away if you use a type synonym'd stack
23:04:43 <AVM> i think that would work, but im not happy about the double rands and getSplit nonsense
23:04:56 <jle`> wel
23:05:07 <jle`> you can think of it as a "special class" of ST computations
23:05:13 <jle`> that requires a seed to initialize
23:05:20 * hackagebot fixed-vector-binary 0.6.0.0 - Binary instances for fixed-vector  http://hackage.haskell.org/package/fixed-vector-binary-0.6.0.0 (AlexeyKhudyakov)
23:05:21 <jle`> so you get a seed and you run that special ST
23:05:22 * hackagebot fixed-vector-cereal 0.6.0.0 - Cereal instances for fixed-vector  http://hackage.haskell.org/package/fixed-vector-cereal-0.6.0.0 (AlexeyKhudyakov)
23:05:29 <AVM> i dont think i need the inner rand then
23:05:39 <AVM> i just grab the seed
23:05:45 <AVM> and apply while inside rand
23:06:08 <jle`> well you never need the inner rand, yeah; you can always route the seed through manually
23:06:26 <jle`> but remember the entire point of a rand monad is to abstract away the seed plumbing
23:06:43 <AVM> gotcha
23:06:48 <jle`> so if you're inside the ST, you can always just manually route the seed from the previous results etc.
23:07:01 <AVM> right
23:07:23 <jle`> if you don't have many random generations then you might be better off doing it that way, it's up to you
23:07:45 <jle`> if it makes you feel better about not having a rand in a rand heh.
23:07:54 <external-reality> pavonia: Thank you. I guess I'll have to work around it. Looking up a HTTP Request parameter by name (in recent versions of Snap) hands off a strict Bytestring so you can imagine how much of a problem this is causing for me. I can use the Snap Handler method RequestBody (which hands of a lazy Bytestring).
23:08:06 <jle`> the github link i sent actually does it that way
23:08:16 <AVM> cool
23:08:18 <jle`> er well, it does it using randST; i don't manually route
23:08:41 <jle`> but yeah do let me know if you find a better way to do all of this
23:08:46 <jle`> i'm open to learning
23:08:52 <AVM> i will
23:09:06 <AVM> how should i contact you?
23:09:09 <AVM> here?
23:09:23 <jle`> i'm usually always here, if you mention me by name i'll be notified
23:09:29 <pavonia> external-reality: Can#t you convert the strict in a lazy one?
23:09:29 <jle`> but you can also contact me through github or email
23:10:03 <jle`> justin@jle.im
23:10:38 <AVM> ah its on ur github too
23:10:45 <AVM> cool, i shouldnt lose it then
23:11:18 <AVM> thanks for your help
23:11:26 <external-reality> pavonia: The Bytestring package does not seem to offer the ability to go from strict to lazy.
23:11:53 <jle`> no problem
23:12:08 <jle`> if you are feeling any cognitive friction, it is normal
23:12:16 <jle`> nobody ever feels right using monad transformers at first
23:12:41 <jle`> :)
23:12:45 <AVM> lol
23:12:52 <pavonia> external-reality: Data.ByteString.Lazy.fromStrict
23:12:53 <AVM> it took me forever to realize
23:13:19 <AVM> the different between m n a and m (n a)
23:13:29 <AVM> when you use <- in do notation
23:13:57 <jle`> heh
23:13:58 <AVM> the "unwrapping" that <- does is different from the "unwrapping" that run does
23:14:21 <AVM> and thats one reason i am liking trans so far
23:14:38 <jle`> mhm
23:14:48 <jle`> you will reach their well-known limits before too long
23:15:02 <jle`> it's actually an ongoing field of research in haskell
23:15:20 <external-reality> pavonia: Oh, nice, thx for pointing that one out. Owe you a cider!
23:15:25 <AVM> oh yeah? professor? grad student?
23:15:26 <jle`> monad transformers tend to be known as fragile and hack-ish
23:15:28 <jle`> oh no
23:15:32 <jle`> just normal people
23:15:34 <jle`> haha
23:15:42 <jle`> the language designers and package designers
23:15:45 <pavonia> external-reality: you're welcome :)
23:15:59 <AVM> oh i read that wrong, thought you meant you were doing research in that area
23:16:02 <startling> I don't understand the transformer hate.
23:16:04 <jle`> of course universities do research on this too
23:16:10 <startling> I think they work really nicely.
23:16:33 <AVM> i agree startling, but it might be because i just started really using them today
23:16:38 <startling> haha
23:16:53 <AVM> when i get to a real world scenario i might start cursing them in my nightmares
23:16:59 <jle`> startling: i feel at this point i am comfortable enough that they feel 'right', but i feel like it might just be that i've drank all of the kool-aid
23:17:00 <AVM> but we will see
23:17:10 <startling> jle`: yeah, it's possible.
23:17:20 <startling> They work exactly as I expect, though.
23:17:25 <jle`> anyways i am mostly parroting the trendy statements of the day :)
23:17:26 <AVM> i hope not kool-aid
23:17:34 <AVM> generic brand flavored water you mean
23:17:44 <jle`> yeah, they work exactly as you expect
23:17:45 <AVM> to more generic the better
23:18:07 * startling . o O ( public class AVM<A> )
23:18:19 <jle`> haha
23:18:36 <AVM> oh startling did something i dont understand because im new to irc
23:18:40 <AVM> how u do that
23:18:51 <startling> AVM /me . o O ( public class AVM<A> )
23:19:00 <AVM> ah cool
23:19:04 <AVM> and i get it now
23:19:18 <startling> ". o O ( ... )" is a #haskell thing.
23:19:20 <AVM> so deep into haskell i didnte even recognize real "generics"
23:19:30 <AVM> is that a tought bubble?
23:19:33 <startling> yeah.
23:19:34 <AVM> thought*
23:19:37 <AVM> cool
23:19:42 <AVM> does its job well then
23:20:35 <AVM> i think the real problem is
23:20:50 <AVM> STT s is not ST s Identifty
23:21:00 <AVM> like in the other monads
23:22:38 <AVM> im sure ill be back
23:22:41 <AVM> bye everyone
23:22:47 <jle`> bye AVM
23:27:12 <jle`> i wonder what my quit message says.
23:27:48 <scott_> I made my client hide join/quit messages in #haskell a while ago and it got a lot less noisy
23:28:33 <jle`> scott_: i can't stand having join/parts either.  but my new client selecively shows joins/parts if the person talks within ten seconds or so of the event
23:29:00 <scott_> That's smart
23:29:03 <jle`> it has saved me from talking to nonexistent people on more than one occasion
23:29:12 <scott_> Which client is that?
23:29:25 <jle`> weechat
23:29:31 <jle`> for the unix terminal
23:29:53 <jle`> but i think it runs on any platform
23:30:27 <startling> I don't want to ignore /nicks but highPriestLOL keeps changing nicks and won't respond to my requests to stop doing so.
23:30:41 <scott_> startling: I've noticed that, too
23:31:35 <startling> scott_, I think maybe they have a sleep disorder.
23:31:59 <scott_> There they go again
23:32:45 <jle`> i think mine is set to do the same thing, only show /nicks if the person talks within 30 seconds before/after
23:33:03 <jle`> a little less useful though because useful /nicks happen when people are idle
23:35:50 <startling> jle`: interesting; are you using irssi? Can you share how you did that?
23:35:57 <jle`> startling: i'm using weechat
23:36:12 <jle`> it's built in to the latest release i think
23:36:19 <startling> oh.
23:37:13 <jle`> i haven't looked back from switching from irssi though
23:37:51 <jle`> (since?)
23:37:51 <startling> mostly I haven't looked at weechat because "weechat" is a dumb name.
23:37:56 <jle`> haha.
23:37:57 <startling> I should probably look at it.
23:38:00 <jle`> yes it is a pretty dumb name.
23:38:20 <jle`> it has a pretty vibrant extensions ecosystem
23:38:28 <jle`> and a built in extension browser in the client too
23:38:32 <brtaylor92_> I should probably consider moving off of chatzilla
23:38:39 <startling> brtaylor92_, ew.
23:38:39 <jle`> i'm not sure if irssi did but i never really even tried extending irssi
23:38:54 <brtaylor92_> startling: at least I'm not using it as a browser extension
23:38:59 <startling> jle`, irssi has a very extensive scripting ecosystem.
23:39:04 <startling> brtaylor92_: that's a little less ew.
23:39:17 <jle`> startling: ah so i cannot really say anything on that matter than
23:39:36 <jle`> only that downloading weechat extensions was a lot more fun :)
23:39:47 <scott_> irssi is mostly extended with just Perl, though, right?
23:40:04 <scott_> I actually made an irssi extension or two, but I was not very happy using Perl
23:40:21 <jle`> weechat does perl, ruby, lua, python...all those fun ones?
23:40:30 <startling> scott_: I think you can write extensions in just about anything these days.
23:40:34 <jle`> oh and scheme
23:40:50 <jle`> ...is scheme really a scirpting language? i should check that out
23:41:10 <startling> scheme is /the/ scripting language.
23:41:30 <jle`> that's cool, i never relaly looked into it
23:41:49 <jle`> it does look pretty nice
23:41:59 <jle`> i still can't stand all the parentheses though
23:42:18 <jle`> but i'm sure if i started using it that wouldn't be a problem
23:42:37 <brtaylor92_> startling: now look what you've done... made me download cmake and the weechat source =P
23:42:43 <Sgeo> Some Schemes have really nice metaprogramming
23:42:52 <Sgeo> Well, all Lisps to some extent
23:43:01 <jle`> Sgeo: yeah, i was going to say
23:43:07 <jle`> isn't lisp like the king of metaprogramming
23:43:22 <Sgeo> I'm really curious where Kernel goes
23:43:30 <jle`> you are literally writing the AST, aren't you?
23:44:40 <Sgeo> jle`: depends on the Lisp. Schemes that use syntax-case-like models have "syntax objects" that add additional information
23:45:02 <Sgeo> Beyond the lists of lists, symbols, etc.
23:45:31 <jle`> i should really dig deeper into it some time.
23:45:52 <jle`> the last time i tried anything lisp was when i was playing around with clojure years ago, before i had any fp experience
23:46:39 <Sgeo> Common Lisp macros are easier to understand, but Scheme macros are safer, and some Schemes have safe-and-as-powerful (or more powerful?) than CL macros
23:49:38 <cizra> Hi! I'm trying to install the glib bindings on a Mac. I've got glib installed via homebrew, and I get this error: http://lpaste.net/97049
