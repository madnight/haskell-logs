00:00:33 <Komier> lispy: Thanks. :)
00:01:58 <lispy> Komier: The part I have the strongest objection to is the section, "Dealing with laziness"
00:02:29 <lispy> Komier: I feel like it's better to educate people about strictness and how to make proper use of it. His advice is "use strictness annotations by default".
00:05:09 <Komier> lispy: Thanks, I'll make a note of that for future reference.  I'm quite surprised there isn't an "official" style guide so to speak.
00:05:53 <Komier> lispy: There is a short one on haskell.org, but it's mostly just a general outline.
00:09:24 <zRecursive> lispy: why do you objection to the "laziness section" ?
00:10:08 <zRecursive> In fact i am used to place "!" before fields :)
00:10:10 * hackagebot yesod-platform 1.2.5.3 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.5.3 (MichaelSnoyman)
00:10:10 * hackagebot yesod-bin 1.2.5.5 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.5.5 (MichaelSnoyman)
00:10:16 <johnw> lispy: in our production environment, laziness has yet to be something which bites us; what has bitten us far more often are the difficulties inherent in using FFI correctly due to the manual memory management, dereferencing of null pointers, etc. -- all the non-Haskelly stuff
00:17:03 <lispy> zRecursive: I think people should know why they are marking things as strict and what the trade offs are. I don't think we should tell people "just make all the fields strict unless you run into trouble."
00:17:42 <gamegoblin> How liberally do you guys use type synonyms to convey intention?
00:17:51 <lispy> gamegoblin: I dislike them.
00:17:57 <gamegoblin> Why?
00:18:26 <lispy> gamegoblin: When things use type aliases it creates indirection for me. I tend to have to look them up and then paste them near the code I'm working with as a comment.
00:18:43 <gamegoblin> Mmm
00:18:49 <lispy> some people like them
00:19:33 <Cale> Most of the time, if it's worth creating a type synonym, it's also worth creating a newtype
00:19:42 <lispy> Cale: well put
00:19:47 <Cale> There are some notable exceptions
00:19:53 <Cale> Lens provides one :)
00:21:28 <lispy> zRecursive: having said that, I do have some rules I follow personally for when strict fields are likely to be a win. One of those is, numeric data in the fields. Usually Int is smaller than a thunk and it usually pays to keep it evaluated.
00:22:05 <lispy> (actually, I think Int is always smaller than a thunk, but you get what I mean)
00:22:17 * lispy -> bed
00:22:18 <gamegoblin> Is there a good profiler for haskell?
00:22:23 <lispy> gamegoblin: ghc has one
00:22:31 <gamegoblin> kk will look into it
00:22:39 <lispy> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/profiling.html
00:22:43 <zRecursive> lispy: up to now i cannot encounter troubles when marking all fields strict, though.
00:22:43 <lispy> night
00:23:50 <zRecursive> night
00:25:02 <jtcwang> I'm trying to write a martingale simulator similar to this: http://satoshidicebreaker.appspot.com/?4
00:25:56 <lightquake> i intend to write a blog post that works through the creation of a library or streaming computations, that'll eventually wind up looking like the pipes library (which actually at a low level sort of looks like conduit)
00:26:19 <jtcwang> so basically i want each run of roll to have a result of sometiong along the line of "Current Bet: xxxx Balance: xxxx"
00:26:35 <jtcwang> but i'm a bit stuck on how you have local variables
00:26:51 <jtcwang> like how do i store the current user's balance?
00:27:51 <jtcwang> can anyone point me to the right direction?
00:28:00 <jtcwang> my brain is stuck in the imprative world
00:28:42 <lightquake> jtcwang: well, your function is going to be recursive right?
00:29:06 <jtcwang> kinda
00:29:16 <jtcwang> but i don't want it to return a huge string at the end
00:29:44 <jtcwang> i want it to return something and then run again with different parameters (new balance, new bet amount)
00:30:01 <lightquake> so, here's how I'd structure your program
00:30:01 <ibid> that's imperative thinking :)
00:30:06 <jtcwang> i know
00:30:17 <jtcwang> that's why i need you guys :)
00:30:21 <jtcwang> redeem me
00:30:27 <ibid> somewhat equivalent would be to have it return a list
00:30:34 <lightquake> you have some function martingaleSim that takes in the random number generator and an initial bet, and produces a list
00:30:39 <ibid> such that each list item is one "iteration" result
00:30:43 <lightquake> the elements in the list contain the size of the bet, the outcome of the bet, and the new balance
00:31:05 <jtcwang> mhmm
00:31:07 <jtcwang> good idea
00:31:18 <jtcwang> let me process that
00:31:41 <lightquake> (also, you should probably store your bet sizes as an integer number of satoshi to avoid floating point wackiness)
00:32:13 <jtcwang> i guess so, but 80000325 is kinda hard to read
00:32:28 <jtcwang> i'll need to do some prespacing to make sure the layout looks good
00:32:31 <ibid> you can convert it later for viewing pleasure :)
00:32:33 <lightquake> yeah
00:32:42 <lightquake> render it as mBTC or whatever, store it as satoshi
00:32:49 <jtcwang> you know what ibid, I'm dumb haha
00:33:34 <lightquake> so you have runSimulation :: StdGen -> Integer -> [BetResult]
00:33:40 <lightquake> where the Integer parameter is the initial balance
00:34:03 <lightquake> then you define prettyPrintResult :: BetResult -> String that shows each bet result in a nice way
00:34:04 <jtcwang> wouldn't you need IO for the [BetResult]?
00:34:16 <lightquake> jtcwang: not if you explicitly pass the random number generator around
00:34:19 <jtcwang> or StdGen already has deterministic results
00:34:36 <lightquake> System.Random.next :: StdGen -> (Int, StdGen)
00:34:47 <ibid> StdGen is a pseudo-RNG
00:34:50 <lightquake> note that you'll also need to pass around some more state within runSimulation, like the size of the current bet
00:34:51 <jtcwang> right so it is determinitic
00:34:57 <ibid> it doesn't sample the world for new randomness
00:35:03 <lightquake> yes
00:35:17 <jtcwang> with Martigale your bet amount is ever changing
00:35:24 <jtcwang> depend on whether you lost the last bet etc
00:35:38 <lightquake> so, represent your martingale state in a datatype
00:35:38 <jtcwang> how do i store that in runSimulation?
00:35:53 <ibid> pass it as a parameter to the recursive call
00:35:58 <jtcwang> right
00:36:11 <lightquake> martingaleStep :: MartingaleState -> (BetResult, MartingaleState)
00:36:37 <lightquake> or, i gues martingaleStep :: MartingaleState -> Maybe (BetResult, MartingaleState)
00:36:44 <jtcwang> if i do that though, nothing will be printed unless my terminate condition is met?
00:36:46 <lightquake> where the Nothing case is for when you run out of money
00:37:00 <lightquake> correct, this will run the entire simulation before printing anything
00:37:10 <jtcwang> is there a way to not do that?
00:37:17 <lightquake> well, wait, no it won't
00:37:23 <ibid> lightquake: or just martingaleStep :: MartingaleState -> [BetResult]
00:37:25 <lightquake> if you implement it in a lazy way
00:37:43 <lightquake> ibid: right, i wanted to make the recursion and state-passing explicit
00:38:11 <jtcwang> i kinda understand lazy
00:38:19 <ibid> lightquake: the recursion is explicit or implicit anyway, depending on how one writes it. doesn't depend on the type
00:38:27 <jtcwang> but how do i make it so that it prints something out before doing the next recursion?
00:38:36 <ibid> lightquake: making state explicit is a bad idea, IMO, unless there are special circumstances
00:39:00 <lightquake> ibid: well, your function isn't really a step function
00:39:04 <ibid> jtcwang: with my version, you just print out the list.  it'll print out items as they are created
00:39:08 <ibid> lightquake: true
00:39:15 <jtcwang> ibid: i see
00:39:41 <lightquake> i do think that runMartingale :: MartingaleState -> [BetResult] is a better type to go for
00:40:17 <lightquake> where MartingaleState will probably contain your bet size, your random generator, and your current balance
00:40:34 <jtcwang> mhmm
00:41:25 <lightquake> and yeah, laziness means that it'll run the martingale as it goes
00:43:34 <jtcwang> lightquake, got it
00:43:42 <jtcwang> still need to get my head around sometimes
00:54:16 <jtcwang> how do you generate a RNG that is different in every program run?
00:54:33 <jtcwang> use system time?
00:55:14 <Hexagenic> Or another RNG like /dev/random on unix.
00:56:01 <jtcwang> I'm trying to use the system's implicit one
00:56:02 <jtcwang> getStdGen :: IO StdGen
00:56:06 <jtcwang> ^ that one?
00:56:58 <Axman6> sure
00:57:59 <jtcwang> k thx
00:59:14 <Hexagenic> Hm, if I understand getStdGen correctly, it's not actually a wrapper for the unix TRNG, but rather a singleton PRNG that is seeded by /dev/random
00:59:35 <Hexagenic> "There is a single, implicit, global random number generator of type StdGen, held in some global variable maintained by the IO monad. It is initialised automatically in some system-dependent fashion, for example, by using the time of day, or Linux's kernel random number generator. To get deterministic behaviour, use setStdGen."
01:00:24 <jtcwang> i don't need super good RNG
01:00:39 <jtcwang> just need one that is different across programme runs
01:00:56 <Hexagenic> Right.
01:14:45 <bmuk> thank you for showing me the Uoregon lectures. I think I finally get functors. Are they not functions from one category to another category? They map objects in one category to objects in another cateory and preserve identity and composition on all of the objects
01:32:16 <Geraldus> Hello buddies! Can someone have a look at this? http://stackoverflow.com/questions/20823763/fay-render-loop-and-mouse-events
01:48:41 <FliPPeh> What is the reason why popular modules tend to reinvent the wheel so often? In this case, why does Data.Aeson define "data Result a = Success a | Error String" instead of using Either a String or even the error monad?
01:49:09 <FliPPeh> I have seen this "Result or error message" reinvention in many modules
01:49:36 <FliPPeh> What they all do in the end is rebuild the error monad using "Success" instead of "Right" and "Error" instead of "Left"
01:49:43 <FliPPeh> There must be something I'm missing?
01:50:05 <FliPPeh> Minimizing dependencies on other modules like mtl?
01:50:31 <quchen> FliPPeh: Type safety. You frequently reinvent data types (such as Bool, Maybe, ...) if you don't need their infrastructure.
01:50:33 <FliPPeh> Would be silly with mtl being probably the most depended upon module after base
01:50:55 <quchen> It's one way of getting around Boolean blindness.
01:51:24 <quchen> type Result = Bool -- Does True stand for a good result, or an error?
01:51:45 <quchen> data Result = Success | Error -- Same as bool, but hard to confuse
01:52:18 <Cale> (note, it doesn't truly save you from boolean blindness: pattern match against any type with two otherwise-identical constructors like that, and you'll be able to swap the branches of the case around without inducing a type error)
01:52:46 <quchen> Cale: Well, call it "Boolean unexpressiveness" then.
01:53:31 <quchen> The point is that among all the possible Bool values, only very few will be associated with your program.
01:54:01 <quchen> Eh, all the Bool-typed values.
01:54:03 <FliPPeh> But what it ends up doing is forcing you to write converter functions anyways
01:54:27 <FliPPeh> Now I had to build "fromResult (Result a) = Right a; fromResult (Error e) = Left e"
01:54:41 <FliPPeh> It's just code clutter
01:57:29 <quchen> FliPPeh: Aeson's Result also has a few typeclasses that you couldn't add if it was Either String e, such as Monoid
01:58:28 <m1dnight_> guys, is it possible to have a list comprehension where you have a filter
01:58:36 <Cale> m1dnight_: yes
01:58:39 <m1dnight_> but when that filter does not pass the entire construction stops?
01:58:42 <jtcwang> lightquake, ibid: I discovered that you can use randomRs to generate infinite list of random values
01:58:42 <m1dnight_> Atm I have this:
01:58:48 <Cale> no
01:58:51 <m1dnight_> oh
01:58:53 <m1dnight_> sna
01:58:54 <m1dnight_> p
01:59:01 <Cale> But you can use takeWhile
01:59:08 <m1dnight_> oh yeah
01:59:10 <Cale> (after the fact)
01:59:13 <m1dnight_> generate the list and then use a takewhile, indeed
01:59:16 <m1dnight_> that might be a solution
01:59:34 <FliPPeh> Or have the filter insert a Nothing and have the rest be Just values and then collapse the list
01:59:56 <Axman6> FliPPeh: in the Ada world it's pretty common to make new types for all sorts of things. integral values are usually defined as rtanges from the min bound to the max bound, even though they'll just be represented as ints
02:00:25 <Cale> I often agree with FliPPeh on this, Either e a does have a conventional interpretation, Left always means "error", because of the way that the Monad instance works (and has to work)
02:01:01 <Cale> But if there are instances to be written that you might want to make differently for Either and for your specific type, then perhaps that's a good enough excuse on its own
02:01:12 <FliPPeh> true
02:01:17 <Cale> and if you want to hide the data constructors, obviously you'll need your own type
02:02:06 <Cale> There's also the option of newtyping Either
02:02:19 <FliPPeh> That's what I would do
02:02:29 <FliPPeh> Best of both worlds imo
02:02:35 <Cale> which sometimes gets you the best of both worlds, but you pay the price of needing to use two data constructors to make anything
02:03:05 <Cale> (of course, one of which is free at runtime, but still shows up in your code)
02:03:32 <m1dnight_> that was indeed what I was looking for! Thank you very much Cale! :)
02:04:49 <Cale> m1dnight_: no problem
02:07:17 <FliPPeh> Stuff has become so much simpler once I understood existential quantification
02:11:24 <satc> In hsc how to assign value to a variable after substituting from a #define macro. I have #define foo "bar" and I want to assign v = #{foo} -- substitute macro foo with its value.
02:11:53 <satc> The above doesn't work however.
02:12:35 <FliPPeh> If it works anything like thing it's emulating, shouldn't it be "v = foo2?
02:16:54 <satc> FliPPeh: I want to assign v = "bar" finally but "bar" defined using the macro foo. What did you mean by "v = foo"?
02:18:14 <FliPPeh> I have not used hsc but if it's using #define then I assume it's like the C preprocessor which just replaces macros
02:18:22 <FliPPeh> #define foo "bar"
02:18:23 <FliPPeh> v = foo
02:18:27 <FliPPeh> => v = "bar"
02:20:25 <satc> FliPPeh: It gives error like foo not in scope..
02:22:49 <Cale> satc: You might want to look at the output of hsc2hs to check that it actually expanded the macro
02:22:56 <Cale> I'm not sure, I've never actually used that tool
02:28:04 <Cale> (Most things seem to either be big enough of a job to make it worthwhile to use c2hs, or else so quick and easy that just using the FFI directly is fine.)
02:45:39 <FliPPeh> @pl fn <~> val = fn <*> (fromJSON val)
02:45:39 <lambdabot> (line 1, column 5):
02:45:39 <lambdabot> unexpected "~"
02:45:39 <lambdabot> expecting white space or simple term
02:45:54 <FliPPeh> @pl (<~>) fn val = fn <*> (fromJSON val)
02:45:54 <lambdabot> (line 1, column 3):
02:45:54 <lambdabot> unexpected '<'
02:45:54 <lambdabot> expecting expression
02:45:56 <FliPPeh> :(
02:46:16 <FliPPeh> @pl magic fn val = fn <*> (fromJSON val)
02:46:16 <lambdabot> magic = (. fromJSON) . (<*>)
02:50:19 <ivanm> I'm trying to fix how the emacs haskell-mode deals with {- ... -} style comments (specifically fill-paragraph doesn't take into account indentation of paragraphs); anyone know where to start (including finding possible examples to look at)?
02:53:11 <FliPPeh> Should I feel dirty for building 2 combinators that turn "(+) <$> fromJSON a <*> fromJSON b" into "(+) <^> a <~> b"?
02:54:12 <ivanm> depends on the combinators, their types, how they're defined, whether they're likely to break in unexpected ways, etc.
02:54:25 <FliPPeh> (<^>) :: FromJSON a => (a -> b) -> Value -> Maybe b
02:54:26 <FliPPeh> fn <^> val = fn <$> (runResult $ fromJSON val)
02:54:29 <FliPPeh> Not too bad
02:54:43 <FliPPeh> Just simple wrappers around the real thing
02:55:24 <FliPPeh> runResult itself is just a wrapper that turns Data.Aeson.Result a into a Maybe a
02:55:48 <ivanm> that could cause issues like how show . read doens't resolve the type
02:55:53 <ivanm> if your (a -> b) is too generic
02:56:44 <zebr> hi all. is there a name for a 'most general polytype of the same shape' as another type? i.e. (a -> b) -> c is of (M -> M) -> N, because the latter can be an instance of the former but the two types otherwise have the same tree
02:57:15 <FliPPeh> Hm, I don't thing generic type parameters will ever be used here, since I'm dealing with JSON and using generics with those is a hassle in statically typed languages anyways
02:57:19 <FliPPeh> think even
02:57:40 <ivanm> FliPPeh: I don't mean generic in terms of the Generic class p
02:57:42 <ivanm> * :p
02:58:01 <ivanm> zebr: maybe have a look at ndm's papers for hlint, etc.?
02:59:04 <FliPPeh> You mean that in terms of what happens when the f in "f <^> a <~> b <~> c" has a signature like "f :: a -> b -> c" instead of "f :: TypeA -> TypeB -> TypeC"?
03:04:38 <Guest96682> Is unsafeCoerce faster than fromIntegral?
03:04:56 <FliPPeh> It's certainly more unsafe
03:05:01 <Guest96682> lol
03:05:25 <Guest96682> assuming the types have identical representation
03:05:40 <ivanm> FliPPeh: yeah, that's what I meant
03:06:45 <FliPPeh> ivanm: Yes, that probably won't happen here because if I need a generic parameter in whatever function I'm wrapping there, I can just use "Value", which is the catch all JSON type to which "fromJSON" will never fail
03:06:56 <FliPPeh> Otherwise I just put a type signature somewhere.. I guess..
03:06:57 <ivanm> *nod*
03:07:04 <FliPPeh> I'll cross that bridge when I get there!
03:07:05 <ivanm> heh
03:07:50 <arbn> Guest96682: Do you find fromIntegral too slow?
03:08:07 <FliPPeh> It's really just a wrapper around a simple function and will break for most other use cases, that's when you have to jump to manual converting anyways
03:09:30 <ivanm> FliPPeh: *nod* especially if it's only internal, not exported
03:10:09 <Guest96682> arbn: I guess my question is really more about what GHC does when I call one as apposed to the other.
03:11:59 <ivanm> Guest96682: well, for fromIntegral, it depends upon the type
03:12:02 <ivanm> @type fromIntegral
03:12:03 <lambdabot> (Integral a, Num b) => a -> b
03:12:21 <ivanm> @src Integral
03:12:21 <lambdabot> class  (Real a, Enum a) => Integral a  where
03:12:21 <lambdabot>     quot, rem, div, mod :: a -> a -> a
03:12:21 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
03:12:21 <lambdabot>     toInteger           :: a -> Integer
03:12:29 <ivanm> @src fromIntegral
03:12:30 <lambdabot> fromIntegral = fromInteger . toInteger
03:12:44 <ivanm> Guest96682: ^^ so it depends upon both the a and the b
03:13:36 * eikke sure hopes that gets optimized away quite a bit
03:13:36 <FliPPeh> Probably
03:14:48 <Guest96682> arbn, ivanm: GHC will perform an allocation for fromIntegral. is the same true for unsafeCoerce?
03:15:26 * hackagebot cabal2nix 1.57 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.57 (PeterSimons)
03:16:15 <Guest96682> arbn, ivanm: by "faster" i mean, avoids an additional allocation
03:30:37 <Guest96682> arbn, ivanm: suppose I have a word somewhere in the heap, and I want to use that word as an int. If I call fromIntegral word, GHC will allocate an int. is the same true for calling unsafeCoerce?
03:45:38 <skypers_> do you know a way to know the proc arch within a cabal file?
03:45:45 <skypers_> if arch(64) ?
03:46:25 <dcoutts_> skypers_: there's nothing for attributes of the arch, like bit size
03:46:32 <dcoutts_> just the various specific arch names
03:47:09 <dcoutts_> some of that info is available to .hs files via cpp #includes from base/rts .h files
03:47:26 <skypers_> System.Info.arch
03:47:30 <skypers_> I guess it’s that
03:51:15 <skypers> yeah it works
03:51:22 <ocharles> mm_freak: morning
03:51:22 <skypers> new version of my library binding then!
03:51:33 <ocharles> bitemyapp: also morning. I believe we're going to be using it at my current job
03:51:46 <ocharles> i think my colleague is already using it, so hopefully something will make its way to hackage
03:55:31 * hackagebot FModExRaw 0.2.0.0 - The Haskell FModEx raw API.  http://hackage.haskell.org/package/FModExRaw-0.2.0.0 (DimitriSabadie)
04:01:56 <jle`> is there a way to simulate a wai request/response?
04:02:12 <jle`> if i have the server IO object
04:05:19 <kinslayer> installing lens-aeson really pulled in a lot of libraries...
04:05:48 <kinslayer> and luckily I installed the correct lens library :D
04:07:29 <ocharles> kinslayer: :)
04:07:51 <kinslayer> ocharles: Lucky that I installed the lens I imported :D
04:08:08 <kinslayer> and the one I looked at the docs for :D
04:08:42 <ocharles> sounds like there was more than luck in play ;)
04:08:57 <kinslayer> well yeah memory :D
04:09:24 <jle`> ocharles: congrats & thank you on/for your great series :)
04:09:38 <kinslayer> the thing is that there are two aeson-lens and lens-aeson
04:10:13 <edwardk> aeson-lens predated lens-aeson. lens-aeson was written to deal with the fact that aeson-lens had illegal lenses
04:10:55 <kinslayer> you said that yesterday :D which is why I preferred lens-aeson
04:12:08 <Thooms> sorry but, what is an "illegal lens" ?
04:12:28 <edwardk> Thooms: someting that typechecks but is patently wrong ;)
04:12:31 <Thooms> (if someone has any paper that I could read)
04:13:05 <Thooms> well ok edwardk :), but can you be more specific ?
04:13:06 <edwardk> there are laws we want lenses to satisfy, the ones in aeson-lens don't.
04:13:13 <Thooms> oh ok
04:13:22 <edwardk> there are 3 of them, they are somewhat 'common sense'
04:13:48 <edwardk> if you get someting out with a lens and put it back with the same lens, you don't change the value.
04:14:01 <edwardk> f you put somethng in and take it out, you get what you put in
04:14:12 <edwardk> if you put twice it s the same as putting the second thing once
04:15:26 <Thooms> I guess it makes sense indeed
04:16:05 <ocharles> jle`: thanks!
04:16:36 <ocharles> though annoyingly, aeson-lens is useful
04:16:42 <ocharles> (for things that lens-aeson can't do)
04:17:24 <edwardk> ocharles: example?
04:17:42 <ocharles> edwardk: assigning deeply into an empty json object and having it create the write things
04:17:59 <ocharles> iirc, that would need Maybe's every where, a bit like assigning Just 5 to 'at "foo"'
04:18:58 <edwardk> hrmm you could use at foo . non whatever with lens-aeson, but you'd have to match _Object first
04:18:59 <ocharles> I'm using aeson-lens specifically to assign to non-existing stuff to build up JSON documents, and I didn't think it was as easy with lens-aeson
04:19:23 <ocharles> https://github.com/ocharles/digestive-functors-aeson/blob/master/src/Text/Digestive/Aeson.hs was the work
04:19:38 <edwardk> so time when i haven't been up all night til it being 7am we shoud resume this discusson ;)
04:19:39 <ocharles> last two functions are the relevant ones here
04:19:42 <ocharles> :)
04:19:47 <ocharles> sounds good to me!
04:20:02 <edwardk> did you ask on #haskell-lens for ideas?
04:20:21 <ocharles> yea, but what I had worked so I ended up just moving on
04:20:28 <edwardk> bah =P
04:20:30 <ocharles> lets pick it up another time
04:20:39 <ocharles> I would like to support the legal libraries, where possible :)
04:20:46 <edwardk> sounds like a plan. eyes don't want to focus. getting sleep =)
04:20:51 <ocharles> cheerio
04:21:50 <yitz> edwardk: have you been in touch with the author of aeson-lens about this? it would be helpful if there were some indication in its package comment at least. or perhpas it could be fixed, or deprecated.
04:22:20 <edwardk> fixing the design of aeson-lens leads to lens-aeson
04:22:28 <yitz> edwardk: or perhaps better if someone else were to contact the package author?
04:22:34 <edwardk> which will probably roll up into lens proper in 4.0 with aeson being in te platform now
04:22:49 <aristid> we need a lens police
04:22:52 <edwardk> i pinged him twice, but got no reply
04:23:04 <edwardk> once before we wrote it, once after
04:23:07 <aristid> it should have the power to take down packages that do not comply with the laws
04:23:11 <yitz> so that's a good gentle reason to request permission to deprecate aeson-lens then, no?
04:23:26 <yitz> ohh. hmm.
04:23:42 <edwardk> actually 3 times, because i also pinged him later on after users had been getting confused between the two for a while asking him if he'd be willing to deprecate his
04:23:56 <ocharles> i'm not sure how good his english is, sadly
04:24:25 <Rhotic> Hello
04:24:40 <jle`> hm so a hackage package is giving me a hard time because its dependencies are too restricted.  i downloaded it and built it myself with all of the dependency resitrctions relaxed and it built fine
04:24:51 <jle`> is there any way to tell cabal to ignore the restrictions on a package?
04:24:56 <ocharles> jle`: you should report that to the package author first
04:24:56 <jle`> a package's dependencies
04:25:01 <edwardk> jle`: what package?
04:25:04 <ocharles> iirc, new cabal has options to do that, but that's not released
04:25:23 <jle`> http://hackage.haskell.org/package/wai-middleware-cache
04:25:38 <jle`> yeah i just downloaded it, stripped off all the version restrictions, and it built fine
04:25:53 <jle`> probably not safe to do in general
04:26:10 <jle`> is there any way i can locally build it and use it in my sandbox?
04:26:11 <ocharles> we have scripts to do that in NixOS (jailbreak-cabal), so it does tend to happen
04:26:17 <aristid> edwardk: so he did react at least a bit here.. https://github.com/tanakh/aeson-lens/issues/3
04:26:28 <ocharles> jle`: you can `cabal install` file system paths
04:26:34 <edwardk> yes, he reacted to a few pings about a year ago
04:26:38 <ocharles> jle`: and by continunation, you can `cabal sandbox install`
04:26:50 <aristid> edwardk: but no reactions to the newer pings?
04:26:53 <edwardk> sortly thereafter he took a patch to upgrade the dependencies to lens 3.8
04:27:33 <edwardk> nothing i've seen
04:27:34 <edwardk> *shrug*
04:27:51 <jle`> oh it did not build fine. i should try to fix it
04:27:56 <jle`> if i fix it, do i submit a pull request
04:27:59 <jle`> ?
04:27:59 <edwardk> folding lens-aeson into lens should probably happen with aeson going into the platform anyways
04:28:15 <edwardk> so i figure if I can talk ocharles through his issue i can do that with a clear conscience ;)
04:28:36 <ocharles> :)
04:28:44 <donri> \o/
04:29:05 <ocharles> I'll go and do some work on my own first, I have progressed with my lens-fu studies and might be able to figure it out now
04:29:12 <edwardk> k
04:29:13 <jle`> ocharles: ah ok, thanks
04:34:03 <Noah__> Hi all, I was wondering if anyone here could talk to me about a career in computer science/IT? I'm pretty much a total beginner so sorry in advance if I ask stupid questions.
04:34:16 <ocharles> Noah__: the only stupid questions are the ones you don't ask
04:34:19 <ocharles> so start asking :)
04:34:23 <Noah__> haha, thanks!
04:35:45 <Noah__> Well, I'm 26 years old, and I'm a few years into a career as a teacher, and I'm finding I hate it, and it's not for me. I'm thinking about going back to school to get a BS in computer science. I've studied HTML, CSS, and a bit of javascript on my own (very little, really, I've just gone through the code academy course), and I really enjoy it so far
04:36:07 <FliPPeh> Yuck, Javascript :(
04:36:15 <FliPPeh> The less I know about JS the happier I am
04:37:11 <mm_freak> ocharles: hi there
04:37:33 <ocharles> mm_freak: hey :)
04:38:04 <yitz> edwardk: well the author does seem to be quite an active member of the community. however, there is a chance that is a pseudonym since it is also the name of a famous actor in japan
04:38:11 <Noah__> I feel like I'm way behind everyone else who started learning to code when they were like 13, so I'm wondering what the best way to catch up is, and how to get prepared for my BS in computer science
04:38:51 <ocharles> Noah__: I'm someone who started when I was 13, if not earlier, and I am still playing catch up. but that's a good thing
04:38:59 <FliPPeh> Noah__: Being "behind" everyone else is in my opinion not a huge problem in a branch of technology that movies forward as quickly as programming does
04:39:00 <ocharles> It means you still have passion and want to keep learning
04:39:08 <mauke> Noah__: I got my first PC when I was 18
04:39:11 <yitz> edwardk: maybe i'll try sending a message to the yesod list. he has contributed to yesod stuff, and there is an active group of yesod devs in tokyo where his haskeller.com page says he live. maybe one of them knows how to get in touch with him
04:39:12 <edwardk> yitz: i'm pretty sure its his real name from context about the workshop folks had about my libraries there in april last year
04:39:15 <ocharles> You have the benefit of being significantly more mature than a 13 year old and you knowing how to study
04:39:29 <ocharles> So you will see some pretty rapid progress, if you discipline yourself in the right ways
04:39:31 <edwardk> yitz: i haven't tried very hard so i'm not about to put all of this on him ;)
04:39:49 <ocharles> My colleague is a lot older than me, but I believe only has about 6 years Python programming experience. He easily matches pace with me
04:39:51 <yitz> no of course not
04:39:51 <Noah__> Well, thats definitely true, I didn't know how to study when I was younger
04:40:03 <FliPPeh> Programming is really all about knowing the basics which you can learn very quickly, and from then on being able to combine them in meaningful ways
04:40:12 <Noah__> Actually, I didn't learn how to really study till I started getting into foreign languages
04:40:42 <yitz> obviously we're happy for his contributions. he's done some nice stuff. just need to be in touch with him about this, since it's confusing some people.
04:40:44 <Noah__> Well, that's encouraging!
04:40:51 <ocharles> Noah__: when you're young you tend to follow the shiney things being blind to everything around you. you get stuff done because you have a stupid amount of free time, but it's not particularly deep knowledege
04:40:55 <ocharles> at least, that's the story for me
04:41:19 <ocharles> I started getting good at things when I got older and decided to really study things in a bit more depth
04:41:22 <FliPPeh> The most important thing is to keep at it, if you only do programming as a job you won't get far. In my opinion it's incredibly important to treat it as a hobby that's become a job you enjoy
04:41:40 <FliPPeh> I went to university with people who treat programming as their jobs only. It's depressing
04:41:46 <Thooms> +1
04:41:50 <ocharles> I think the earlier years let me learn how to learn - how to ask questions, how to find answers, etc. But you will have learnt that anyway, just via a different route
04:41:58 <ocharles> FliPPeh: +1
04:42:08 <Noah__> That's why I want to switch, I don't like my job now, and I really enjoy what I've been doing on my own with programming
04:42:49 <ocharles> Noah__: what bits of programming have you been enjoying?
04:42:50 <FliPPeh> Similarly, university has taught me very little about programming, most of what I knew I knew because I got out there and programmed rubbish that nobody but me ever used
04:43:40 <Noah__> Well, not too much really, just what I've done with HTML, CSS, javascript, and visual basic way back in high school. I just like solving problems and figuring out how to make the code do what I want it to do.
04:44:50 <FliPPeh> So would you say that programming websites is what you'd like to keep doing, or are you planning to go on to more general programming?
04:45:02 <ocharles> Yea, I think that was the question I was trying to ask :)
04:45:25 <Noah__> I want to learn more general programming, its just that right now I've been using codeacademy, and most of what they have on there is geared towards website programming
04:45:55 <Noah__> I'm still working full time now, so I've been using codeacademy since it's very convenient
04:46:11 <FliPPeh> I think the best way to do that is to pick up a programming language that you think you'd like and go follow a basics guide for it
04:46:35 <FliPPeh> Since you're in #haskell, I'm going to recommend http://learnyouahaskell.com/chapters
04:46:40 <Noah__> I don't really know how to evaluate which programming language I would like
04:47:10 <Noah__> Thanks! Bookmarked! I'll check it out later
04:47:32 <ocharles> Also, it's fine that you don't know what to look for - so it's important to try and move around a lot
04:47:56 <ocharles> http://pragprog.com/book/btlang/seven-languages-in-seven-weeks may be worth a read
04:48:06 <m1dnight_> for debugging purposes: I have a function with a let <expr>..<exprn> in True
04:48:13 <m1dnight_> will it evaluate the expressions or  not?
04:48:20 <FliPPeh> I don't think so
04:48:24 <m1dnight_> damnit
04:48:32 <FliPPeh> You could try it with Debug.trace
04:48:36 <FliPPeh> See if it traces
04:48:43 <ocharles> m1dnight_: probably not, though you could foo `seq` True
04:48:56 <ocharles> let foo = undefined in foo `seq` True
04:49:00 <Noah__> Are those all commonly used languages?
04:49:01 <ocharles> > let foo = undefined in foo `seq` True
04:49:02 <lambdabot>  *Exception: Prelude.undefined
04:49:05 <ocharles> > let foo = undefined in True
04:49:06 <lambdabot>  True
04:49:17 <Noah__> I've only heard of Ruby and Haskell
04:49:26 <ocharles> Noah__: They are not very mainstream languages, but they have very different approaches to problem solving
04:49:50 <ocharles> Noah__: That's the important thing for you to observe. Learning Python and Ruby may seem very different, but the aren't really that different
04:49:53 <FliPPeh> Ruby is pretty mainstream methinks
04:49:53 <yitz> ocharles: i think you started getting good at things after reading "24 days of hackage". oh, wait...
04:50:01 <ocharles> However, learning Python and Prolog is *very* different
04:50:07 <Noah__> Just a different syntax for expressing the same thing?
04:50:17 <ocharles> yitz: ha, I do learn a surprising amount doing that :)
04:50:20 <FliPPeh> Different syntax and different idioms
04:50:23 <ocharles> Noah__: with python or ruby, more or less
04:50:38 <ocharles> Noah__: there are some differences, sure, but they aren't all that significant
04:50:40 <m1dnight_> Noah__: different in the way what the runtime does for you. Ie: what you explicitly need to program
04:50:55 <FliPPeh> The basics are exactly the same I would say
04:51:17 <ocharles> Noah__: however when you compare Python and Prolog, Python is all about "do this, then this, then this", while Prolog is about formulating the problem in terms of logical statements and having Prolog figure the answer out
04:51:23 <ocharles> insert handwaving disclaimer...
04:51:39 <Noah__> Ok, well I will check it out. Actually, code academy has python and ruby
04:51:49 <Noah__> Are those more general use languages?
04:51:50 <FliPPeh> Python is "do these things", Prolog is "make this happen"
04:52:01 <ocharles> Noah__: those have much more employability prospects, that's for sure :)
04:52:06 <FliPPeh> Python and Ruby are used in every possible domain
04:52:17 <Noah__> I was reading about that, that it uses different types of statements to make things happen
04:52:28 <maxs_> m1dnight_: FliPPeh you can also use :print in ghci
04:52:32 <Noah__> There was some term for it, like, descriptive vs imperative, or something like that
04:52:43 <FliPPeh> functional and imperative
04:52:51 <m1dnight_> Noah__: imperative == "to achieve this, do these steps"
04:53:00 <m1dnight_> descriptive: "I want a solution in this form, this is your input, go"
04:53:08 <ocharles> descriptive is normally said as "declarative"
04:53:36 <m1dnight_> ie: in prolog you can do like "isCool(Noah)"
04:53:36 <m1dnight_> and then say
04:53:40 <m1dnight_> "isCool(X)"
04:53:47 <m1dnight_> and it willt ell you "X = Noah__ "
04:54:04 <m1dnight_> where as in your typical imperative language you will have to write the code that does the actual lookup
04:54:07 <ocharles> (which is a possible solution to the "problem" of finding out what is cool)
04:54:21 <m1dnight_> "look in database, get everybody who is cool, return these people"
04:54:34 <Noah__> I think I will have to try it out myself to really get it
04:54:47 <FliPPeh> But how do you determine who is cool?
04:54:53 <m1dnight_> prolog does that for you
04:55:04 <m1dnight_> it looks in it's predicates and unifies X with Noah__
04:55:34 <m1dnight_> that program is literaly ":- isCool(Noah)."
04:55:41 <m1dnight_> and then you enter in the REPL: "isCool(X)"
04:55:43 <m1dnight_> and you're done
04:56:17 <m1dnight_> you can do some epic stuff with Prolog
04:56:27 <m1dnight_> I had to write a prolog project this semester (next to my haskell project)
04:56:29 <kinslayer> since the lens-aeson has such great documentation (or that I just really don't get it) I have some questions for instance what type do  my data need to be to be able to work with the lens ?
04:57:13 <FliPPeh> @faq Can haskell determine the coolness of a person?
04:57:13 <lambdabot> The answer is: Yes! Haskell can do that.
04:57:17 <FliPPeh> Neat
04:57:21 <Noah__> Anyway, thanks for answering my questions! You guys are great! I have to go pack now, but I'll definitely be back later.
04:57:39 <Noah__> And I will have to learn Haskell first so I can find out who is cool enough to be my friend
04:57:45 <m1dnight_> :D :D :D :D
04:58:11 <ocharles> kinslayer: Aeson Values and ByteStrings both work
04:58:15 <ocharles> kinslayer: what are you trying to do?
04:58:54 <kinslayer> ocharles: Trying to parse some huge json structure, with something like 3 levels (objects in json, and some arrays somewhere too)
04:59:14 <kinslayer> which ideally should turn into a ADT
04:59:19 <FliPPeh> Working with JSON is such a chore in a statically types language
04:59:38 <kinslayer> I can sort of feel the pain
04:59:49 <FliPPeh> I'm writing a JSON RPC server right now
04:59:54 <FliPPeh> It's going... okay..
05:00:04 <kinslayer> I like those dots ^
05:00:47 <FliPPeh> ExistentialQuantification makes it a bit more bearable at least
05:00:57 <ocharles> kinslayer: if you just want to pluck values out, I would decode the ByteString to the Aeson AST (a Value) and then use lenses on that
05:01:04 <FliPPeh> "I don't care how you do it, these values can be converted to JSON and I want them in a list, you figure it out"
05:01:42 <kinslayer> ocharles: I certainly want some of the values, and all of it is not necessary, mostly I want some of the values from the arrays inside the json...
05:02:09 <ocharles> kinslayer: sure, so decode the ByteString into aeson's Value type, and then uses lenses on that
05:02:28 <ocharles> the first step does the json validation and everything, and if that's sane then you can traverse the ast
05:02:38 <kinslayer> yeah but wouldn't that require writing an instance declaration ?
05:02:42 <ocharles> no
05:02:49 <ocharles> I'm saying the _Value_ type. check your docs :)
05:02:56 <kinslayer> super, since I got stumped on that.
05:03:09 <ocharles> There is a type in aeson that describes a data type called Value and it has To/FromJSON instances
05:03:09 <kinslayer> That was really awful to do...
05:03:39 <kinslayer> I will look that up
05:04:33 <ocharles> kinslayer: Read the prose on the Data.Aeson module too. That explains the idea of decoding into the AST and no further
05:04:45 <kinslayer> ok
05:05:00 <donri> basically you just need Value to decode and encode JSON. the rest of aeson is machinery for generically serializing haskell types.
05:05:06 <donri> Value represents the JSON primitive types.
05:16:45 <Gorroth> hi there
05:17:33 <tem> While running the example given at http://hackage.haskell.org/package/ConfigFile-1.0.5/docs/Data-ConfigFile.html#12         I got the following error:  Not in scope: `empty';
05:17:42 <tem> how to resolve it?
05:18:33 <m1dnight_> is there a way to print to the terminal when you run a snap website?
05:19:35 <Axman6> why hello Gorroth
05:19:38 <maybefbi> m1dnight_: Control.Monad.IO.Class.liftIO $ putStrLn "Hello,World"
05:19:43 <Gorroth> hi
05:20:33 <yitz> tem: import Control.Applicative (empty)
05:20:50 <maybefbi> m1dnight_: since Snap is an instance of MonadIO this will work
05:20:53 <m1dnight_> oh
05:20:55 <m1dnight_> thanks man
05:20:56 <m1dnight_> will try! :)
05:21:00 <maybefbi> m1dnight_: ok
05:21:01 <m1dnight_> I can't find my goddamn parse error
05:21:35 <Axman6> did you forget a 'do'? that got me a few times today
05:21:44 <m1dnight_> no it's a pure function
05:22:27 <Gorroth> hello s = "Hello " ++ s ==> hello "Axman6"
05:22:33 <Gorroth> that's all i got
05:22:52 <Axman6> heh =)
05:23:02 <Axman6> so you've been going through lyah?
05:23:33 <Gorroth> yeah, a little bit :)  right now i'm trying to choose an IDE so i can follow their code
05:23:38 <Gorroth> i'm thinking of using EclipseFP
05:23:59 <Axman6> from memory that's non-trivial to setup
05:24:26 <haasn> GHCi :P
05:24:51 <m1dnight_> IDE for haskell?
05:24:55 <haasn> (Takes some minor bits of introduction though as to the syntactical uniquenesses, which LYAH doesn't really cover)
05:24:58 <Gorroth> yeah, but i can setup eclipse plugins.  i've done it for CDT and PyDev
05:25:24 <m1dnight_> sublime works perfectly for haskell imo
05:26:12 <Axman6> Gorroth: there's https://www.fpcomplete.com/, and online haskell IDE
05:27:02 <maybefbi> for IDE try this: Bluetile + GVIM + Cumino
05:27:31 <maybefbi> for Cumino get the code from my repo. I forked the original repo so the new Cumino works with cabal repl
05:27:46 <Gorroth> Axman6: i think i'll go for EclipseFP since it's looking pretty full-featured and free
05:28:11 <epta> maybefbi: how it looks like?
05:28:24 <maybefbi> epta: wait getting screenshot
05:28:42 <Axman6> fpcomplete's stuff is free, unless you want the extra features
05:28:53 <donri> free as in beer ;)
05:29:05 <Axman6> I just use haskell, i've always been happy with a simple text editor with tab completion for haskell work
05:30:59 <donri> eclipsefp is probably perfectly alright if you're used to eclipse
05:31:44 <donri> i don't think it's hard to setup, you cabal install some helper programs and install eclipsfp with some eclipse module system thingy
05:32:57 <they> I could never get EclipseFP to work.
05:33:13 <they> There was no syntax highlighting or anything. All of the other features worked, though.
05:33:33 <they> Also, haskell-mode is fairly full featured.
05:35:14 <maybefbi> epta: http://i.imgur.com/QyUrtga.png
05:35:18 <tem> yitz: I got the following error http://lpaste.net/97682
05:35:35 <maybefbi> epta: Thats Bluetile + GVIM + Cumino
05:38:58 <Gorroth> Axman6: well, i looked at the feature set.  i think i would want more than the base feature set has
05:39:13 <Axman6> fair enough
05:39:23 <yitz> tem: oh this is a very old library, so it's not using Alternative. anyway - don't the examples use emptyCP, not empty?
05:39:30 <they> Why gVim over vim, tem?
05:41:23 <maybefbi> they: so that i can switch to browser easily. tmux + vim + ghci doesn't let you switch to browser without using a mouse
05:41:35 <tem> yitz: thanks emptyCP worked; but the example there uses empty
05:41:59 <yitz> tem: ok guess that's just a typo.
05:42:56 <epta> maybefbi: actually it does
05:43:20 <maybefbi> epta: using Alt + Tab?
05:43:38 <maybefbi> epta: but that hides other windows if my browser is maximized
05:44:00 <maybefbi> epta: i want to see browser and code tiled
05:49:42 <donri> maybefbi: that answers bluetile, not gvim :)
05:50:35 <donri> but i'll try myself: gvim is superior in every way except doing terminal stuff (e.g. :suspend or :shell or viewing man pages with "K")
05:51:55 <maybefbi> donri: yeah. i was wrong. Bluetile + vim/gvim + Cumino + firefox is ok with me
05:52:16 <donri> terminals are dumb, really, and gvim sidesteps the terminal
05:52:52 <donri> you get more colors, more bindable keys, different cursors, generally more rendering capabilities
05:53:03 <donri> gvim is still quite stupid though :P by heritage
05:53:39 <maybefbi> donri: i miss Netbeans + vim plugin. I wish that worked for haskell
05:54:17 <maybefbi> donri: wish I could add dependencies automatically after typing import statements
05:54:31 <maybefbi> donri: dependencies into the .cabal file
05:55:32 <donri> personally i currently use gvim + shellshape but considering switching to either emacs, or tmux + terminal vim, because bare gvim is kinda crap at running background tasks and interacting with terminals and such
05:55:51 <dabd> I was looking at http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=gcc&data=u64q and I wonder why is haskell 5 times slower than C on the binary trees benchmark? http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&lang=ghc&id=4
05:56:11 <donri> just 5 times slower than highly tuned C? not bad
05:56:34 <dabd> ofc but the difference is much larger in this benchmark than in the others
05:57:16 <Axman6> dabd: the benchmark has to be changed because Haskell was dominating it. they required that the whole tree be allocated and then processed because the haskell versions were completely optimising the trees away
05:58:17 <dabd> Axman6: I'm not sure what you mean by "dominating it"
05:59:13 <maybefbi> Axman6: so the benchmark game mods like certain languages over others so much as to actually change the rules to benefit one language more?
05:59:54 <Axman6> eh, you could call it that if you like
06:03:36 <Earnestly> maybefbi: They changed it to reflect a more real situation.  Trees aren't usually empty, no?
06:03:58 <Axman6> well, they're not usually immediately consumed after creation
06:06:26 <donri> hehe children are immediately consumed after creation? (from async docs: "children are automatically killed if their parents die for any reason")
06:08:02 <mreh1> infanticidal, minus 100 privilege points
06:08:35 <maybefbi> hmm none of the other languages there have a binary trees solution
06:08:53 <Axman6> hmm?
06:20:17 <Earnestly> donri: Children, parents, masters, slaves.  Programming sure can be taken rather severely out of context heh
06:22:40 <speckle> Earnestly, and to people who don't know Haskell, the scariest-sounding of them all is the monad
06:23:18 <maybefbi> gonads are just a pair of gonoids
06:26:46 <donri> maybefbi: no it's a triple :P
06:27:47 <hpc> "if the bug fails to reproduce, kill all the children and spin a new parent" -- ultimate anti-context
06:28:48 <donri> hpc: you should first attempt to terminate gracefully
06:29:45 <hpc> donri: ideally, have the children detect the failure and kill themselves
06:33:12 <aleksejs_> Hi, is it possible to make this http://vpaste.net/Rgmi4 without recursion?
06:34:20 <donri> aleksejs_: do you mean without any recursion, or without explicit (syntactical) recursion?
06:34:37 <aleksejs_> syntactical
06:34:38 <donri> you can hardly get anything done without any recursion in haskell :P
06:35:19 <donri> okies, then yes, the answer is always yes because we can encode recursion as a combinator with fix
06:35:45 <donri> although some might argue that's a form of explicit recursion...
06:35:50 <aleksejs_> this code solves this task http://projecteuler.net/problem=2
06:35:58 <hpc> donri: it's not syntactic though!
06:36:49 <donri> hpc: debatable. you often need to fix (\x f -> ...f...) which is sort of syntactical recursion, maybe?
06:37:05 <hpc> nah, it's just function parameters
06:37:15 <hpc> unless "const $ \x f -> ...f..." is recursion too
06:37:17 <donri> i s'pose
06:37:43 <lick> hi
06:38:15 <hpc> donri: in any event, you can always make that lambda pointfree!
06:38:35 <donri> sure. it'll probably be super pretty.
06:38:41 <donri> flip ap fmap flop
06:39:01 <hpc> zip`ap`tail
06:39:07 <donri> (:
06:39:17 <ij> The @pl translated "f x = i x >>= j x" to be "f = liftM2 (>>=) i j" is that correct and would still mean j gets two parameters(x and the output of i)?
06:40:48 <ij> Does @pl ever cheat you at all?
06:40:55 <k00mi> ij: it's correct, it uses the Monad instance for (r ->)
06:40:58 <k00mi> it shouldn't
06:41:12 <hpc> pl is sometimes wrong
06:41:20 <hpc> but only when the input doesn't typecheck
06:41:25 <hpc> or when the output is a syntax error
06:41:30 <hpc> @pl 5 :: Integer
06:41:31 <lambdabot> 5 :: Integer
06:41:39 <hpc> @pl 5 :: Integer + 7
06:41:39 <lambdabot> 5 :: Integer + 7
06:41:49 <hpc> @pl \x -> x :: Integer
06:41:49 <lambdabot> (:: Integer)
06:41:50 <lick> computation on types is possible with GHC?
06:41:58 <donri> lick: yes
06:42:04 <donri> but what do you mean specifically?
06:42:13 <lick> I want to write:
06:42:15 <lick> (do apicall1 :: Level 19 b     apicall2 :: Level 10 a ) :: Level 19 a
06:42:36 <donri> i don't follow
06:42:47 <lick> (do {apicall1 :: Level 19 b;     apicall2 :: Level 10 a} ) :: Level 19 a
06:42:54 <lick> like this
06:43:00 <fread228_> @src scanr
06:43:00 <lambdabot> scanr _ q0 []     =  [q0]
06:43:00 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
06:43:00 <lambdabot>     where qs@(q:_) = scanr f q0 xs
06:43:25 <hpc> lick: the type of (>>=) for Monad will not allow that
06:43:29 <ocharles> lick: looks like you want an indexed monad
06:43:30 <haasn> lick: that looks like a type error to me since 10 is not ~ 19
06:43:31 <hpc> you might look at indexed monads
06:43:40 <haasn> well, assuming non-indexed monads
06:43:43 * haasn doesn't know what indexed monads are
06:43:44 <hpc> or consider trying something else, like your own combinators
06:44:14 <hpc> haasn: instead of a monadic action of type "m a", it's of type "m i a"
06:44:16 <ocharles> haasn: monads with an index :)
06:44:28 <donri> hpc: aren't there usually two indices?
06:44:29 <hpc> and sequencing can change i
06:44:33 <donri> m i j a
06:44:36 <hpc> er, yes
06:44:45 <hpc> well, at a very rough level that's what happens
06:44:46 <ocharles> there don't have to be two
06:44:52 <donri> so you can track changing state between two bound actions, i imagine?
06:44:58 <ij> How does this scoping thing work in haskell? Can I shadow a function by a variable name?
06:45:02 <lick> I am going to learn about indexed monad
06:45:03 <ocharles> the new indexed library (yet to be on hackage) has one, and uses an "At" type to introduce two
06:45:10 <hpc> look up a paper on it; it's fairly straightforward if you read the abstract, usually
06:45:16 <donri> ocharles: i guess you can have one that is some sort of product type :P
06:45:42 <hpc> ij: shadowing works as you would expect it to
06:45:58 <donri> > let (+) = (*) in 5 + 5
06:45:59 <lambdabot>  25
06:46:07 <hpc> with the caveat that it does unexpected things when you ignore the behavior of let-in
06:46:45 <hpc> > let x = 5; x = x * 2 in x -- this isn't 10
06:46:46 <lambdabot>  Conflicting definitions for `x'
06:46:46 <lambdabot>  Bound at: <interactive>:1:5
06:46:46 <lambdabot>            <interactive>:1:12
06:47:07 <hpc> > let x = 5 in (\x -> x * 2) x -- this is 10
06:47:08 <lambdabot>  10
06:47:16 <donri> ocharles: where's the new indexed? the github one is two years old
06:47:20 <donri> latest commit that is
06:47:22 <donri> no branches
06:47:32 <hpc> ij: it's not really easy to read outside of maybe do-blocks; be careful when using it
06:48:04 <hpc> the only place i will usually use shadowing is to turn "id" (identity) into "id" (ID number)
06:49:06 <ocharles> donri: https://github.com/ekmett/indexed
06:49:29 <ocharles> donri: specifically, see Indexed.Functor
06:49:39 <donri> cool thanks
06:49:56 <schlegel> can you even have the type 'Level 10 a'? I thought Haskell didn't yet have dependent types
06:49:58 <ocharles> oh, 'At' is in Indexed.Types
06:50:09 <ocharles> schell: Ghc 7.8 has type level numeric literals
06:50:15 <ocharles> schlegel: *
06:50:18 <schlegel> ahh
06:50:27 <schlegel> So 10 is peano 10?
06:50:28 <ocharles> Maybe that came in 7.6 actually
06:50:49 <ocharles> I don't think it's peano 10, I think it's a proper 10 with special handling. Not sure on that though
06:50:50 <schlegel> I'll look into specifics, thanks
06:52:05 <lick> schlegel: I used GHC.TypeLits (in base-4.7.0.0)
06:52:16 <ocharles> That indexed library I linked to above doesn't have dependent types, but it does have derpendent types
06:52:28 <schlegel> heheh
06:53:28 <schlegel> lick: Ah, thanks
06:56:53 <klrr_> http://hackage.haskell.org/package/network-2.4.2.1/docs/Network-Socket-ByteString.html
06:57:07 <klrr_> that doc says BSD socket interface, will it still work on a linux system?
06:57:21 <Axman6> that's what linux uses
06:57:21 <geekosaur> yes
06:57:26 <klrr_> okey, thanks
06:57:29 <geekosaur> "BSD" refers to the origin of the API
06:58:05 <geekosaur> linux, while prone to change lots of things or randomly reinvent stuff, somehow managed to learn from the OSI / XTI fiasco and left sockets alone. (windows, otoh...)
07:00:11 <lick> hpc, ocharles, haasn, donri: thank you very much!
07:01:36 <zett_zelett> Is there a tutorial “Haskell for Mathematicians” or something like that?
07:04:23 <Hafydd> There's this, but I don't know if it's any good: http://symbo1ics.com/blog/?p=87
07:05:49 <klrr_> ^ that site made firefox crash with its JS
07:06:07 <Komier> mine too >.<
07:06:23 <schlegel> Maybe from MathJax?
07:06:43 <ij> Works on chrome.
07:06:44 <zett_zelett> Works fine with me.
07:06:52 <zett_zelett> (Icedove, Mathjax etc.)
07:08:27 <Komier> Did any of you guys learn Haskell from scratch as a first language?
07:08:29 <zett_zelett> http://symbo1ics.com/blog/?p=788 : – /
07:09:46 <klrr_> Komier: i did, feel free to ask any questions :)
07:10:02 <Hafydd> Hmmh.
07:11:09 <aristid> geekosaur: OSI / XTI fiasco? what was that?
07:11:47 <geekosaur> AT&T System V Release 4 went with the X/Open Transport Interface, an attempt to reconcile sockets with Open Systems Interconnect, over sockets
07:12:56 <alexdoom> hi, im trying to understand some haskell syntax. on line 5 after the pipe, what does the "<-" mean? http://lpaste.net/97686
07:12:58 <geekosaur> Solaris finally brought sockets back around 2.6 but took several more releases to jettison the last of it (aside from some stragglers in part of the old SAF config that nobody uses)
07:13:29 <geekosaur> alexdoom: that's a list comprehension
07:13:53 <alexdoom> geekosaur: ah, thank you
07:14:15 <klrr_> alexdoom: http://learnyouahaskell.com/starting-out#im-a-list-comprehension
07:14:24 <alexdoom> klrr_: thanks!
07:14:29 <geekosaur> for every a1 in a and every a2 in a, compute (evolName a1, evolName a2, distance a1 a2) and combine them all into a list
07:14:47 <klrr_> (that whole book is pretty good resource when learning haskell i might add)
07:15:06 <jonasw> alexdoom: <- looks kind of like ∈, I don't know if that's on purpose but it makes sense :)
07:15:33 <alexdoom> geekosaur: oh, now i see it!
07:15:49 <klrr_> oh hoogle got updated css :D
07:15:49 <alexdoom> haskell is pretty cool
07:16:38 <prasadi> Hi ! Is there a way to write haskell's "let " statement in   a way that it spans multiple rows ? Or else, is there any other way to create a string which spans multiple rows ?
07:17:39 <jonasw> prasadi: You can do str = "A possibly very"\      \" long string", inbetweet \ \ you can have newlines
07:17:41 <jonasw> IIRC
07:18:19 <geekosaur> no inner quotes
07:18:19 <klrr_> is there any package that provides direct bytestring IO?
07:18:20 <Feuerbach> jonasw: without the quotes in the middle
07:18:28 <Feuerbach> just blackslash+space
07:18:30 <Guest63053> let statements can span multiple lines in a number of different ways, depending on indentation, or your use of curly brackets\
07:18:33 <Feuerbach> *backslash
07:18:34 <klrr_> prasadi: you can always use (++)
07:18:36 <Axman6> prasadi: as long as all the definitions line up, you can make multiple deinitions in a let clause
07:18:52 <jonasw> Feuerbach: Oh, yeah :)
07:18:54 <Iceland_jack> > unlines ["multiple", "lines"]
07:18:55 <lambdabot>  "multiple\nlines\n"
07:18:58 <zett_zelett> “The air on which Haskell programmers seem to thrive reeks of foul stench  of cargo cult mathematics, something of which I don’t want to be a  part.”
07:19:06 * jonasw made some frankenstein C/Haskell thing
07:19:10 <klrr_> > "blalbabalbalb" ++ "blababllbalb"
07:19:11 <lambdabot>  "blalbabalbalbblababllbalb"
07:19:13 <d3lxa> hey guys, is there [f a] -> f [a] for applicatives or functors? I'm stuck :S
07:19:27 <Feuerbach> traverse
07:19:33 <Iceland_jack> @hoogle Applicative f => [f a] -> f [a]
07:19:33 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
07:19:34 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:19:34 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
07:19:39 <Feuerbach> right
07:19:41 <klrr_> is there any package that provides direct bytestring IO?
07:19:53 <klrr_> wait
07:19:55 <Guest63053> @type traverse
07:19:55 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
07:19:58 <Saizan> bytestring
07:20:00 <Iceland_jack> Traverse is not the same
07:20:03 <klrr_> yeah
07:20:07 <klrr_> im so dumb :D
07:20:14 <d3lxa> the Traversable t is really necessary?
07:20:20 <Feuerbach> Iceland_jack: yes, sequenceA is the right one
07:20:22 <jonasw> prasadi: http://ideone.com/SxA1cU
07:20:31 <Iceland_jack> d3lxa: It's just more general
07:20:54 <Iceland_jack> @ty Data.Traversable.sequenceA :: Applicative f => [f a] -> f [a]
07:20:55 <lambdabot> Applicative f => [f a] -> f [a]
07:20:56 <d3lxa> Feuerbach, Iceland_jack thx guys, I'm looking into it :) would love to have @hoogle locally btw
07:20:59 <Iceland_jack>     ↑
07:21:04 <prasadi> Thank you everyone for helping me to find the answer ! Thanx a lot !
07:21:07 <schlegel> d3lxa: You can!
07:21:11 <schlegel> cabal install hoogle
07:21:23 <Feuerbach> sequenceA = traverse id
07:22:28 <d3lxa> ok that makes sense somehow :)
07:22:56 <Axman6> :t traverse
07:22:57 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
07:23:36 <zett_zelett> http://symbo1ics.com/blog/?p=827
07:23:36 <d3lxa> schlegel: can you use it from command line, like here? I don't want the whole http server etc :)
07:24:34 <Axman6> hmm, freenode seems to be struggling
07:25:05 <Hafydd> "Haskell’s Nums are trying to emulate subtyping"
07:25:06 <geekosaur> the kiddies have been ddos-ing it pretty much ever since schools went on break >.<
07:25:13 <Hafydd> I think the author is a bit lacking in intelligence.
07:25:14 <d3lxa> that's cool, I've made a completly general and type-safe form from an Enum \o/
07:25:52 <Iceland_jack> Hafydd: type classes = subtyping obviously :)
07:25:58 <d3lxa> @hoogle a -> b
07:25:58 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
07:25:59 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:25:59 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
07:26:06 <schlegel> d3lxa: Yep, hoogle can be command line or your can run your own http server
07:31:39 <prasadi> Hi !  This is about Haskell HDBC and Sqlite3. Is only "CREATE TRIGGER...." available in sqlite3, not "CREATE OR REPLACE TRIGGER " ?
07:32:35 <tristan_1> thought I'd try again, would anyone be kind enough to tell my code apart? :)
07:35:40 <geekosaur> prasadi, has nothing to do with haskell actually. http://www.sqlite.org/lang_createtrigger.html
07:36:08 <hpc> prasadi: that's more of an sqlite-specific question; since you are asking here though, i will say that sqlite is a rather atrocious database engine
07:36:36 <hpc> acid-state is good, but quite different from an sql relational database
07:36:41 <Bynbo7> how so?
07:36:57 <Bynbo7> apart from its pretty much complete lack of type checking
07:37:02 <hpc> Bynbo7: sqlite has no transactional guarantees
07:37:17 <Axman6> I thought it did
07:37:53 <Axman6> http://www.sqlite.org/transactional.html
07:38:00 <hpc> oh, it does now
07:38:20 <hpc> i remember it used to not have any kind of guarantees
07:38:47 <hpc> it does still have the super wonky typechecking, and it lacks a lot of features you would get from other engines
07:38:59 <hpc> mostly performance and query optimization
07:39:42 <Axman6> I believe it also does now do type checking
07:40:30 <hpc> gah, what will i complain about now?!?!
07:40:39 <hpc> ;)
07:40:41 <Axman6> hmm, maybe not... " In SQLite, the datatype of a value is associated with the value itself, not with its container. "
07:40:54 <Axman6> that's a bit gross
07:41:00 <hpc> in any event, ask in #haskell, get an acid-state answer
07:41:02 <Axman6> though, also not completely horrible
07:42:16 <Axman6> and bed time for me. night all
07:42:37 <ij> ls
07:43:30 <ij> Woups. It seems that when I readProcess "xclip" ["-o"] [], aka the clipboard, I get this when cpb has a png in it: fd:5: hGetContents: invalid argument (invalid byte sequence)
07:43:34 <ij> What can I do about it?
07:44:18 <Feuerbach> ij: use bytestring IO
07:45:56 <geekosaur> mm, doesn't appear to be a way to make it only operate on text
07:46:04 <prasadi> http://ideone.com/SxA1cU   . What if "let" spans more than 3 columns ? I tried adding "\" in each and every line, but it generates an error
07:48:08 <pavonia> prasadi: What do you mean, there's no let
07:48:10 <geekosaur> (ideally you'd give it a list of type atoms to request and it would exit nonzero if it can't negotiate one of them with the selection holder)
07:48:23 <ij> Feuerbach, Could you tell me how to do it? I haven't dealt much with bytestring and I'm not sure how to make readProcess use it or how to use it with it.
07:48:42 <prasadi> I'm sorry...it's actually  a string which spans multiple lines
07:49:03 <Feuerbach> prasadi: what's the problem with that code?
07:49:34 <prasadi> I want to write it in a way that it spans more than 3 rows
07:49:35 <Feuerbach> ij: you use createProcess or a similar function that gives you a handle to the pipe
07:50:14 <Feuerbach> ij: then you read from that handle using functions from the bytestring package
07:50:33 <prasadi> http://lpaste.net/97688 can you show how to do it in that code ?
07:50:38 <Feuerbach> such as hGetContents
07:50:40 <mountainHermit> greetings haskellions. any users of the fb library here?
07:51:15 <pavonia> prasadi: You have to add '\' to the beginning and end of each line (except for the first and last)
07:52:53 <ij> Feuerbach, Thanks!
07:53:02 <Feuerbach> welcome
07:53:09 <prasadi> I did that...but still getting the  error...this contains a  "let" which spans multiple rows...can you  edit that code please ?
07:53:21 <prasadi> http://lpaste.net/97688
07:58:51 <pavonia> prasadi: http://lpaste.net/97688
08:01:01 <monochrom> except it lead to "... testTriAFTER ..." etc as opposed to "... testTri AFTER ...".
08:01:32 <monochrom> so perhaps "\ AFTER" intead of "\AFTER"
08:01:42 <monochrom> similarly for the rest
08:02:07 <zcourts> For my PhD I'm using Haskell for developing a distributed graph DB (http://research.zcourts.com) and I'm documenting as I learn more about the language http://haskell.zcourts.com/beginner/2013/12/19/core-haskell-concepts/ just thought I'd share it, might be useful mainly for beginners but I'm also writing documentation on the libraries I'm using such as conduit.
08:05:27 <Hafydd> I started working on this project during my final year while I was attempting to build my own startup.
08:05:39 <Hafydd> *Sirens and red flashing lights go off*
08:06:15 <monochrom> LYAH does not explain or present a lot of theory
08:06:54 <zcourts> Hafydd: why?
08:07:06 <monochrom> and the scientific approach uses a ton of demonstrations to illustrate theory, as opposed to keep talking about theory
08:08:15 <Hafydd> zcourts: I'm being mostly facetious, but you probably don't want to market your dissertation as a "startup-style dissertation".
08:08:35 <zcourts> monochrom: I didn't find LYAH easy to digest on first read. My point was more that not everyone finds that approach easy to follow.
08:09:03 <monochrom> ok, but LYAH still does not explain or preset a lot of theory
08:09:52 <m1dnight_> project for school is finished! hurrah! :) (code cleanup is badly needed, but everything works fine!)
08:10:39 <zcourts> Hafydd: Gotcha, that actually wasn't my intent, but it started as a side project at the start-up. I should probs, tweak the wording at least.
08:10:51 <zcourts> monochrom: fair enough
08:15:17 <ddellacosta> speaking of learning Haskell...where can I find a reference on how whitespace is handled in ghci?
08:17:13 <Drezil> o/
08:17:31 <Hafydd> ddellacosta: like this? http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#ghci-multiline
08:17:52 <ddellacosta> Hafydd: thanks so much!  Exactly what I needed.
08:18:09 <Drezil> does someone know the gtk2hs EventM-Model? I have a problem where i cant pick up a Relese-Modifier for keys ..
08:18:50 <m1dnight_> zcourts: your website is an interesting read! :) I'm gonna read some more later
08:18:51 <m1dnight_> thanks for the link
08:19:48 <zcourts> m1dnight_: thanks, any feedback appreciated
08:20:11 <Drezil> http://pastebin.com/YjPbVyCS - the code of my problem
08:20:13 <mauke> The paste YjPbVyCS has been copied to http://lpaste.net/97690
08:22:11 <merijn> zcourts: I heard graphs and haskell, where do I sign up to your news letter? :)
08:22:13 <Jesin> @pl (\f -> let x = f x x in x)
08:22:13 <lambdabot> fix . join
08:22:15 <Drezil> or is Release reserved for mouse-clicks?
08:22:50 <monochrom> @type fix . join
08:22:51 <lambdabot> (a -> a -> a) -> a
08:23:10 <monochrom> interesting function
08:24:05 <merijn> That's just reader monad join, right?
08:24:26 <monochrom> yes. more simply, (->) a's join
08:24:37 <zcourts> merijn: funny you should ask, I'm building a Jekyll plugin now to do post notifications. there's an rss feed at http://research.zcourts.com/rss.xml
08:24:43 <ij> it feels like it is such pain to deal with bytestrings, is it just me?
08:24:48 <Drezil> -.- meh .. im stupid d/
08:25:16 <merijn> zcourts: In all seriousness, I'm starting on graphs in FP too and I'm still trying to orient myself in the literature so if you have interesting starting points...
08:25:42 <merijn> Or rather, I'm starting on graphs. The FP bit is just me planning to be a bit of a ideological zealot :p
08:25:43 <monochrom> there is no pain dealing with bytestring. there is much pain shoehorning string into bytestring or bytestring into string
08:26:02 <monochrom> but shoehorning is painful and supposed to be, anyway
08:26:22 <ij> Myeah.
08:26:58 <merijn> ij: If you have text you want to use Text anyway
08:27:28 <Hafydd> That didn't seem to be the issue at hand, though; the issue was that System.Process uses String and not ByteString.
08:27:40 <merijn> Oh, that's just bad design
08:28:08 <aristid> or old design.
08:28:30 <merijn> aristid: Those are not mutually exclusive
08:28:32 <zcourts> merijn: I can recommend "Introduction to algorithms, 3rd ed." by Cormen et al, there's about 200 pages from page 587 on graphs or "Networks: An Introduction" by Mark Newman
08:28:53 <aristid> merijn: no, but having used String instead of Text in 2004 was not a marker of bad design, i think
08:29:18 <aristid> somehow i feel reminded of the amusingness that the proper type for file paths in unix is ByteString and in windows it's Text
08:29:25 <merijn> zcourts: I was already reading CLRS, but that doesn't really look at the functional graphs. Does Okasaki covers graphs?
08:29:46 <merijn> aristid: Yeah, unix being encoding agnostic in that respect is a huge mistake, imo
08:29:49 <monochrom> so go to hackage and download process-extras instead. it uses bytestring.
08:29:57 <aristid> (note that i pulled the date 2004 out of my ass, no idea when System.Process was made)
08:29:59 <monochrom> and text
08:30:24 <aristid> merijn: yes, fortunately linux standardised to utf-8 a couple of years ago
08:30:43 <aristid> but it's still not enforced, so...
08:30:44 <merijn> aristid: Except not enforced
08:30:52 <merijn> aristid: Which is basically still worthless
08:30:57 <aristid> yes:/
08:31:04 * hackagebot ihaskell 0.2.0.4 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.2.0.4 (gibiansky)
08:31:08 <merijn> I'd rather have enforced utf-16 (like windows) then unenforced utf-8
08:31:23 <aristid> and that's a strong statement because utf-16 for file names is stupid :P
08:31:53 <aristid> i suspect even on chinese windows machines, a large fraction of file names are ASCII
08:32:19 <merijn> aristid: Agreed, but at least it wn't accidentally break your terminal
08:32:56 <zcourts> merijn: Okasaki doesn't focus on graphs per say but describes techniques for trees, say red black trees. But the concepts are also applicable to graphs so I'd say it's still worth a read
08:36:59 <zcourts> merijn: p.s check the section on persistent data structures from Okasaki, ideas there turns out to be very useful for graph traversals
08:46:06 * hackagebot ihaskell 0.2.0.5 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.2.0.5 (gibiansky)
08:48:56 <merijn> zcourts: Ok, thanks, will have a look
08:50:14 <prasadi> http://lpaste.net/97691 I get an  error when I tried to execute this code.. need help...is there any other way to do division in Haskell ? actually, I need the answer with the fractional part
08:50:57 <merijn> prasadi: What error are you getting?
08:51:34 <geekosaur> you get an error because it inferred the types as Integer before, and (/) isn't defined for Integer (what do you do with the remainder?). use fromIntegral to convert the Integer-s to an appropriate type (which will be inferred)
08:51:52 <merijn> oh, another fun DMR
08:51:55 <merijn> @where dmr
08:51:55 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
08:52:16 <merijn> Or explicitly annotate your values as Double
08:52:19 <Hafydd> Damning Monomorphism Restriction?
08:52:23 <monochrom> I am unconvinced that the paste is representative of the real question
08:52:25 <merijn> Hafydd: Dreaded
08:52:33 <Hafydd> Close enough.
08:52:46 <prasadi> mergin : http://lpaste.net/97692
08:52:50 <geekosaur> ultimately it's the monomorphism restriction, yes
08:53:24 <merijn> prasadi: See the earlier link and geekosaur's explanation
08:54:02 <prasadi> earlier link ?
08:54:24 <vektor> should I consider random generators I pass into pure functions reusable (return it back, pass it to next function) or should I just throw new random generators at my functions over and over?
08:55:25 <allsystemsarego> Hi all, what is the point of the State monad? It seems to my unenlightened mind that everything one could do with the State monad can also be done with an intelligently crafted combination of folds and let..in expressions
08:55:30 <monochrom> I don't understand the question. (rather, I don't trust your language skill.) show actual code for both.
08:55:49 <merijn> prasadi: http://www.haskell.org/haskellwiki/Monomorphism_restriction
08:55:50 <prasadi> got it...thanx
08:56:11 <merijn> allsystemsarego: Simplicity
08:56:32 <merijn> allsystemsarego: I *could* write everything I write in haskell in ASM, but haskell is higher level and more composable
08:56:54 <merijn> allsystemsarego: Similarly, I *could* replace state with explicit state passing, but State is higher level and more composable
08:57:22 <merijn> allsystemsarego: In fact, State is *literally* explicit state passing, just hidden from view as nice abstraction
08:57:43 <allsystemsarego> ok, that makes more sense
08:57:46 <monochrom> I don't use State often
08:57:51 <_zxq9_> allsystemsarego: The same question can be asked of probably more than half of the possible Haskell syntactic formations -- its about expressivity (I hope)
08:58:03 <merijn> I don't use State a lot, but StateT I use semi frequently
08:58:05 <sipa> and abstraction
08:58:40 <sipa> using state (well, statet more often) allows operations implemented on generic monads which do not have to know about your state being passed along
09:00:26 <ickabob> Hi I've a question about pattern matching against an tree structured DataType, I want to define a binary operation on the type and so want to match all 4 possiblitlies of input deconstructing each pattern.  Is there a way to have the matches fall through to a single expression.  That is for a function 'merge' define merge Leaf Leaf | Leaf Branch | merege Branch Leaf | merge Branch Branch = some definition
09:01:45 <ickabob> I was hoping to have four guards, each with no definiton untill after the final guard but I'm geting a syntax
09:03:08 <monochrom> merge _ _ = some definition
09:03:45 <ickabob> monochrom: i need to deconstrcut the types
09:04:21 <monochrom> show actual code.
09:04:32 <ickabob> kk
09:04:53 <monochrom> and this is why I distrust programmers' language skill. "deconstruct types" does not exist.
09:05:30 <ickabob> deconstruct the value constructors of the type?
09:05:38 <sipa> i assume he sees the different constructors of an algebraic data type as different types :)
09:05:47 <monochrom> maybe? by this time, I trust nothing.
09:07:19 <ickabob> https://gist.github.com/ickabob/8172349
09:08:13 <ickabob> monochrom: There is the Datatype and the idea of the function I'm trying to write
09:09:42 <Feuerbach_> ickabob: that's incorrect syntax. one way to fix it is to remove the guards
09:09:50 <Feuerbach_> and make 4 clauses
09:10:01 <Feuerbach_> mergeWeightedSets (Leaf ws) (Leaf ws') = _merge ws ws'
09:10:02 <monochrom> data HTree a = HLeaf{myws :: (Int, Set a)} | HBranch{myws :: (int, Set a), myleft, myright :: HTree a}
09:10:03 <Feuerbach_> and so on
09:10:31 <monochrom> mergeWeightedSets t0 t1 = merge (myws t0) (myws t1)
09:10:45 <jxv> ickabob, use the case-of
09:11:06 <Feuerbach_> oh wait, rhses are the same. Then you'd better refactor it, as monochrom suggests
09:12:32 <monochrom> this trick is carefully crafted for this specific case. it doesn't generalize too well.
09:13:41 <tomberek> what's the current best practice for filepaths? Filesystem.Path? System.FilePath.POSIX ?
09:15:58 <Feuerbach_> if you care about being cross-platform, then Filesystem.Path, I think
09:16:46 <tomberek> Fueerbach: I don't care all that much (I'm implementing linux specific functions, no chance at all it will be used on windows)
09:18:38 <Feuerbach> then System.Posix.FilePath sounds most appropriate
09:19:49 <Feuerbach> although I have to say I haven't used it myself
09:20:02 <Feuerbach> so don't know if there are caveats
09:20:26 <tomberek> Fuerbach: and for file and directory manipulation? the unix package with System.POSIX seems good
09:21:09 <tomberek> Feuerbach: i'll give it a shot, thanks
09:21:13 <Feuerbach> agreed
09:26:14 <vektor> how expensive is making a new random number generator? does reusing a random number generator (in contrast to generating a new one) influence the quality of the random numbers in any way?
09:31:11 * hackagebot shelly-extra 0.2.3.1 - shelly features that require extra dependencies  http://hackage.haskell.org/package/shelly-extra-0.2.3.1 (GregWeber)
09:31:46 <nnnbvb> What library should I use to read and parse PDFs?  Has anyone tried pdf-toolbox?
09:39:12 <aleksejs_> Negative programming: http://vpaste.net/GXOk2  vs http://vpaste.net/1OmJ0  vs http://vpaste.net/zke8e
09:41:12 * hackagebot monad-logger-syslog 0.1.0.0 - rsyslog output for monad-logger  http://hackage.haskell.org/package/monad-logger-syslog-0.1.0.0 (GregWeber)
09:43:04 <Kreap> aleksejs_: what are we meant to compare here?
09:43:21 <Fylwind> is it intentional that HashMap is not an instance of Hashable?
09:43:34 <aleksejs_> Kreap, amount of code?
09:47:11 <YurasShumovich> hello. I'm looking for data type similar to Maybe, but with different Monoid instance
09:47:14 <YurasShumovich> like that: http://lpaste.net/97696
09:47:36 <YurasShumovich> mappend returns Just only when both arguments are Just
09:47:46 <YurasShumovich> does it exist soemwhere?
09:47:46 <simpson> YurasShumovich: I believe that you want Option.
09:48:11 <Taneb> That's not a monoid
09:48:24 <simpson> http://hackage.haskell.org/package/semigroups-0.8/docs/Data-Semigroup.html
09:48:24 <Taneb> Wait
09:48:35 <YurasShumovich> it is a Monoid
09:48:36 <Taneb> simpson, no, it's not quite Option either
09:48:51 <Taneb> YurasShumovich, yeah, my reasoning was hasty and wrong
09:49:12 <simpson> Hm.
09:50:07 <YurasShumovich> and Option doesn't look like what I need...
09:52:30 <YurasShumovich> what is the best name for it?
09:52:43 <YurasShumovich> that is the biggest issue I have actially)))
09:53:18 <monochrom> "Perhaps" :)
09:53:42 <YurasShumovich> then how to name constuctors?
09:53:49 <YurasShumovich> Exist/NotExist?
09:54:30 <monochrom> I haven't thought that far
09:54:30 <YurasShumovich> but Perhaps is perhaps the best option)
09:54:58 <monochrom> data Perhaps a = Nevermind | Consider a
09:55:00 <Hafydd> data Perhaps a = Incredibly a | Missing
09:55:32 <Hafydd> Heh.
09:55:42 <monochrom> s/Consider/Customers_like_you_have_bought/
09:55:44 <they> data doge a = Wow | Such a
09:55:52 <Feuerbach> haha
09:57:04 <YurasShumovich> I like Missing/Consider
09:57:14 <YurasShumovich> thank you all
09:58:18 <Feuerbach> YurasShumovich: if you're serious about it, better simply create a newtype wrapper than reinvent the whole type
09:58:31 <Feuerbach> cf. First, Last
09:59:24 <YurasShumovich> hmm... too many wrap/unwrap I think...
09:59:32 <YurasShumovich> but maybe you are right
10:22:53 <Feuerbach> any Germans here? Need a bit of help with German (not related to haskell)
10:23:26 <tomberek> Fuerbach: MarcWeber is german
10:23:33 <tomberek> Feuerbach:
10:23:49 <shachaf> There are several in #haskell-blah. :-)
10:29:38 <vektor> Feuerbach: here
10:31:07 <haasn> Germans crop up all over the place if you know how to look for them
10:31:23 <aristid> haasn: sneaky bastards
10:31:28 <haasn> (Germany is a pretty good place to search, I've heard)
10:33:39 <vektor> just offer us Schnitzel, Schwarzbrot and Beer. :D
10:37:00 <maxiepoo> hey does anyone know if filemanip works for windows?
10:39:06 <donri> maxiepoo: probably should, looking at the deps
10:40:12 <maxiepoo> yeah it says portability: Unix-like systems (requires newtype deriving)
10:40:35 <maxiepoo> and I found some old complaints by windows users about it
10:41:09 <maxiepoo> what does "Portability: Unix-like systems (requires newtype deriving)"
10:41:10 <maxiepoo> mean
10:41:11 <maxiepoo> ?
10:41:41 <maxiepoo> is that saying it only works on Unix-like systems because it uses new type deriving?
10:41:49 <tristan_1> trying to use runhaskell and getting
10:41:49 <tristan_1> Ambiguous module name `Control.Monad.State':
10:41:49 <tristan_1> it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.1.2
10:41:54 <tristan_1> how can I tell it to use mtl?
10:43:06 <tristan_1> same in ghci of course
10:45:26 <tristan_1> cool, found hide and -XPackageImports
10:55:41 <aristid> so i was trying to install lamdu, and the dependency GLFW-b fails to install for some weird reason: http://lpaste.net/97698
10:55:52 <aristid> any idea what that means? (it's OS X)
10:57:46 <aristid> maybe installing glfw3 would help
10:58:41 <aristid> nope doesn't help
11:09:22 <mello> Can I ask questions about Snap here too?
11:10:41 <pavonia> sure
11:11:23 * hackagebot valid-names 0.1.0.0 - Valid operator/module characters  http://hackage.haskell.org/package/valid-names-0.1.0.0 (JoelTaylor)
11:11:25 * hackagebot valid-names 0.1.0.1 - Valid operator/module characters  http://hackage.haskell.org/package/valid-names-0.1.0.1 (JoelTaylor)
11:12:41 <mello> is there a way to render a template and use it as a splice in Snap? i.e. can heist templates be used as first class values, if so how?
11:14:01 <mello> I've bumped into the Text.XmlHtml  package, which would most likely be enough in this case though
11:17:55 <exicer> Is there a way to print from within an Either monad, other than using a monad transformer or something ?
11:17:59 <exicer> for the purposes of debugging
11:18:20 <imalsogreg> mello: I don't think so.  I think of 'render' as the command that draws on the page - I could be wrong though.  I used XmlHtml when I came to a situation like yours, I think..
11:19:05 <merijn> @quote oasis
11:19:05 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
11:19:13 <merijn> exicer: Debug.Trace.trace
11:19:26 <merijn> exicer: Obviously unsafe, bug great for debugging
11:19:32 <merijn> eh
11:19:34 <merijn> s/bug/but
11:19:38 <mello> imalsogreg, ok. I did find something though that sort of resembles what I want it to do. http://hackage.haskell.org/package/snap-extras-0.1.7/docs/src/Snap-Extras-FlashNotice.html but for a do it myself way I'd use XmlHtml
11:20:20 <exicer> merijn: Awesome, will have a look :D
11:21:33 <klrr_> why do all libraries need to use different kind of bytestrings o.o
11:22:24 <imalsogreg> mello: Thanks for the link.
11:25:19 <Feuerbach> klrr_: they can't, by the pigeonhole principle
11:25:36 <tomberek> klrr: i've run into that before, lazy and strict conversions littered all over the place
11:31:58 <gamegoblin> I am making a library. I did "runhaskell Setup.hs configure --enable-library-profiling", then "runhaskell Setup.hs build" then "runhaskell Setup.hs install" and everything seemed to work fine. But I made a test program (test.hs) that used the library and tried to compile it with " ghc -prof -fprof-auto -rtsopts test.h"
11:32:13 <gamegoblin> and get the error "Could not find module `Lambdalearn.Util.Core'
11:32:13 <gamegoblin>     Perhaps you haven't installed the profiling libraries for package `lambdalearn-0.1.0.0'?
11:32:13 <gamegoblin> "
11:35:24 <gamegoblin> ideas?
11:36:36 <enthropy> gamegoblin: does `ghc-pkg list lambdalearn' have multiple copies?
11:37:02 <gamegoblin> The output of that command is
11:37:03 <gamegoblin> /var/lib/ghc/package.conf.d
11:37:03 <gamegoblin>    lambdalearn-0.1.0.0
11:37:03 <gamegoblin> /home/grant/.ghc/x86_64-linux-7.6.2/package.conf.d
11:37:03 <gamegoblin>    lambdalearn-0.1.0.0
11:37:09 <enthropy> my guess is that you do, and the one being chosen is one without the profiling libs
11:38:55 <enthropy> gamegoblin: as user, ghc-pkg unregister lambdalearn, will get rid of the one in /home which will not have profiling
11:39:18 <enthropy> unless the command "runhaskell Setup.hs configure --enable-library-profiling" you say is not the full story
11:39:38 <gamegoblin> K I unregistered it
11:39:51 <gamegoblin> Now what?
11:40:03 <enthropy> try your test again
11:40:13 <gamegoblin> seems to have compiled! time to test
11:41:26 <gamegoblin> I ran it with ./test -p but it didn't generate a profile file...
11:41:27 <gamegoblin> hmmm
11:41:58 <gamegoblin> oh wait no, I'm dumb. Forgot +RTS
11:42:14 <gamegoblin> wooooooo works. Thanks.
11:59:27 <quchen> Oh, fancy new designy bits in Hoogle!
12:04:13 <bmuk> Hello all, I have been watching some category theory lectures and I think I finally get Functors, but I'm having trouble applying what I
12:04:25 <bmuk> ve learned to the implementation in haskell
12:04:59 <bmuk> a Functor maps objects in one category to objects in another category and preserves compositionality and identity
12:05:47 <bmuk> but fmap takes a function (a -> b) and an object in a category f a, and returns an object in the new category f b
12:05:57 <bmuk> what category is a -> b in?
12:08:21 <jrw> bmuk: a functor in the CT sense is really two maps, usually both denoted by the same letter. a functor F : C -> D is a map from the objects of C to the objects of D, as well as a map from the arrows of C to the arrows of D.
12:08:59 <jrw> the conditions are what you stated F(id_A) = id_(FA), and F(g . h) = Fg . Fh
12:09:30 <jrw> in haskell, the two maps are separated.
12:09:51 <jrw> the map from objects to objects is usually called f
12:09:56 <jrw> the map from arrows to arrows is called fmap
12:10:27 <roconnor> @hoogle a -> f b -> f a
12:10:27 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
12:10:28 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
12:10:28 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
12:10:56 <bmuk> so (a -> b) is the arrow in C and f a is the object in C?
12:11:50 <bmuk> I guess what I am not understanding is what category are all default values in? Monoid>
12:12:01 <jrw> if we had F : C -> D, and we think of F as being f together with fmap, then: a is an object in C, f a is an object in D, a -> b is an arrow in C, etc.
12:12:11 <merijn> bmuk: The category Hask (the category of Haskell objects)
12:12:28 <jrw> the confusing thing, perhaps, is that in haskell both C and D are "the category of haskell data types"
12:12:47 <jrw> so it's a functor from a category to itself (aka, endofunctor)
12:13:02 <merijn> Whoo!
12:13:05 <merijn> I knew all of that
12:13:08 <merijn> I'm getting smarter
12:14:11 <derdon> hey, I have a problem with the infix operator ==> in quickcheck. It tells me it received a property instead of a Bool and I don't understand why. paste follows
12:14:13 <bmuk> what is the real world application of this, outside of monads. Yesterday I learned that fmap can do the job of liftM
12:14:30 <derdon> http://lpaste.net/97700
12:15:01 <derdon> see esp. line 59
12:15:02 <jrw> bmuk: you don't need to know this to use functors, but it can help.
12:15:12 <mauke> derdon: what's the error message?
12:15:50 <bmuk> jrw: I know but I would like to. When I say real world I mean an example
12:15:57 <derdon> mauke: the complete one is http://lpaste.net/97701
12:16:23 <bmuk> when would I use fmap other than to map an arrow to an arrow in a monad
12:16:37 <mauke> derdon: might be a precedence problem. what happens if you add parens?
12:17:13 <jrw> bmuk: there are examples of functors that are not monads that we could cook up
12:17:37 <derdon> mauke: I added parens around both expressions (the one before and the one after the ==>) and it didn't change anything at all
12:17:56 <bmuk> jrw: okay I would like that. I think it would help my understanding
12:18:36 <mauke> derdon: oh, it's your type signature
12:18:56 <mauke> maybe
12:19:04 <keak> ,haskell
12:20:07 <derdon> mauke: yay, thanks! it really was
12:20:59 <derdon> mauke: correct signature is ``prop_divMod :: Nat -> Nat -> Property`` by the way
12:20:59 <derdon> found out the lazy ay via ghci
12:20:59 <derdon> *way
12:21:02 <mauke> laziness++
12:21:38 <ziman> @karma laziness
12:21:38 <lambdabot> laziness has a karma of 4
12:21:56 <jrw> bmuk: one example is binary trees. can you think of what the functor is for that?
12:22:33 <pavonia> @karma strictness
12:22:33 <lambdabot> strictness has a karma of 0
12:23:08 <bmuk> well the arrows inside the category of binary trees would be links between nodes, right? and the objects would be the nodes themselves
12:24:32 <bmuk> I think what the functor is would depend on what category is in the codomain, right?
12:24:34 <jrw> bmuk: not quite. remember, the category in question is *all haskell types*. we're viewing binary trees as a map from that to itself. given a type A (ie, an object) the functor sends it to the type of binary trees containing As
12:24:50 <bmuk> oh okay
12:25:05 <jrw> bmuk: now what does fmap do in this case?
12:25:36 <Fylwind> I like the new Hoogle theme
12:26:10 <bmuk> Im thinking it would place it in the correct position in the binary tree but that sounds wrong to me. I think what fmap does is more abstract
12:26:50 <jrw> bmuk: do you know what fmap does on lists?
12:27:02 <bmuk> no, I do not
12:27:12 <jrw> bmuk: ok, let's do that first :)
12:27:18 <bmuk> haha okay
12:27:31 <jrw> so we're thinking of lists as a functor, sending a type A to... what?
12:27:52 <ziman> to the type of lists of A
12:28:20 <jrw> yes, what ziman said. bmuk: does that make sense?
12:28:29 <ziman> ah, sorry.
12:28:37 <bmuk> so in this case a functor is a -> [a]
12:28:51 <bmuk> it's okay ziman lol
12:28:56 <jrw> in pseudo-syntax, yes
12:29:08 <jrw> okay, so look at the generic type for fmap:
12:29:11 <jrw> :t fmap
12:29:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:29:27 <jrw> bmuk: what happens if we get rid of "f" and replace it with list?
12:29:58 <notdan> oh, Hoogle got an update/restyle
12:30:01 <notdan> that's quite nice
12:30:19 <bmuk> we have a function that takes a function of single arguments and a list and outputs a list with the function applied to the items of the first list
12:30:24 <bmuk> ... that's MAP!
12:30:25 <bmuk> lol
12:30:30 <jrw> bmuk: right!
12:30:46 <jrw> so fmap for lists is just map.
12:30:54 <jrw> now you know why it's called fmap :)
12:31:14 <bmuk> because map is really just a special case of fmap
12:31:21 <zett_zelett> Why are functors and monads represented by type classes?
12:31:21 <bmuk> jrw++
12:31:34 <zett_zelett> It doesn’t make much sense.
12:31:37 <mauke> zett_zelett: for your convenience
12:33:08 <Fylwind> so you can generalize code that work on Monads/Functors (and also nicer syntax)
12:33:22 <jrw> bmuk: great. so we've done lists. but lists have a monad instance, so their fmap is also their liftM. we wanted an example where that doesn't work. let's go back to binary trees?
12:33:28 <k00mi> zett_zelett: type classes provide instance resolution, so you don't have to pass the record around by hand
12:33:50 <bmuk> so my intuition for fmap outside of CT is that it takes a function that operates on normal values and lets it operate on values inside functor
12:34:01 <jrw> bmuk: that's good intuition.
12:34:03 <maxiepoo> wait can you only test things that are externally exposed using `cabal test`?
12:34:04 <quchen> zett_zelett: Mapping over things with Functor: "fmap". Mapping over things without Functor: maybeMap, listMap, parserMap, ioMap, stateMap, …
12:34:47 <bmuk> okay back to binary trees, but afterward I have a question about lists
12:34:54 <maxiepoo> doesn't that rule out an extremely common case: internal unit tests?
12:34:59 <k00mi> not having a type class does not mean not generalizing these concepts, you can still do it via records
12:35:22 <jrw> bmuk: so let's say we have data Tree a = Leaf a | Node (Tree a) a (Tree a)
12:35:50 <jrw> bmuk: ie, a binary tree with data at the leaves and the internal nodes. all data is the same type.
12:36:00 <bmuk> okay
12:36:09 <apples> newtype Functor f = { fmap ::
12:36:14 <apples> oops sorry
12:36:29 <jrw> bmuk: we already said before that the object part of the functor takes types A to Tree A, the type of trees with data of type A. make sense?
12:37:07 <bmuk> sort of, yes
12:37:17 <bmuk> just to be clear, we aren
12:37:28 <jrw> bmuk: just like with lists we took A to [A]. now we take A to Tree A.
12:37:33 <bmuk> t talking about values, just types. so Int to Tree Int
12:37:39 <jrw> exactly
12:37:41 <bmuk> yes okay
12:37:52 <nstdloop> How would I do something like data Point = Point { x :: Num a => a, y :: Num a => a }
12:37:58 <nstdloop> Do I need RankNTypes for that?
12:38:03 <jrw> bmuk: okay, now specialize the type of fmap to Tree. what do you get?
12:38:54 <bmuk> it takes a function from a -> b and a Tree of type a and returns a tree of type b. so it maps over the tree like map maps over a list
12:39:15 <jrw> bmuk: exactly.
12:39:37 <jrw> bmuk: now, I claim there's no useful monad instance on Tree.
12:39:38 <bmuk> that's amazing
12:40:13 <bmuk> okay fmap doesn't necessarily work over containers, it just happens that these two examples were containers.
12:40:49 <jrw> bmuk: that's true, there are plenty of examples of functors that are not containers.
12:40:54 <bmuk> you could fmap into the IO monad - (String -> Int) -> IO String -> IO Int?
12:41:02 <maxiepoo> oh I can just put the actual src as an hs-source-dir
12:41:06 <zett_zelett> Actually, doesn’t it take a function a -> b and returns a fucntion Tree a -> Tree b, which is almost the same but more faithful to what Haskell really does and to what a functor really is?
12:41:07 <jrw> bmuk: sure :)
12:41:34 <jrw> zett_zelett: yes, depending on your preference for how to think about currying.
12:41:55 <startlin1> jrw, monad instances on trees are pretty cool.
12:42:13 <jrw> startlin1: I was hoping nobody would call me on that ;)
12:42:30 * startlin1 wonders why he's startlin1
12:43:37 <bmuk> so what are monads in terms of CT?
12:44:01 <startling> it's ok if you don't want to go into it now, but typically (>>=) lets you graft new trees to replace leaves. this is nice if you have e.g. a lot of named trees lying around and leaves referring to those names.
12:44:16 <jrw> bmuk: the usual response at this point is "they're just monoids in the category of endofunctors, what's the problem?"
12:44:23 <startling> (in other words, an AST. :) )
12:44:41 <Komier> Did any of you guys learn Haskell from scratch as a first programming language?
12:44:43 <jrw> startling: I believe that works when you have no data at internal nodes?
12:45:15 <they> Komier: Alongside lisp, yes.
12:45:19 <bmuk> haha. endofunctors map objects and arrows in a category to that category itself, right?
12:45:36 <startling> jrw, not sure what you mean.
12:45:40 <they> It's a pretty easy first language.
12:45:51 <jrw> bmuk: yes, and in haskell we basically only have endofunctors, and we call them "functors".
12:46:10 <Komier> they: may i ask what resources you used?  And at what point did things start to click so you could start working on problems like Euler and such as practice?
12:46:14 <jrw> startling: with the Tree type I gave above, I'm not sure the instance you mentioned works.
12:46:18 <bmuk> so the category of endofunctors is really all functors in haskell
12:46:33 * startling scrolls up
12:46:42 <jrw> bmuk: right.
12:47:03 <quchen> jrw: There are many subcategories in Hask, and there can be functors between those.
12:47:07 <they> Komier: I just read through LYAH and Land of Lisp. It comes pretty naturally, but it wasn't until I learned more math that some things in Haskell started to make sense.
12:47:19 <startling> jrw, let me poke at it for a bit
12:47:39 <bmuk> and a monoid is something that has identity and associativity
12:48:02 <jrw> quchen: I'm sure you're right. I'd be curious to see an example. I'm also not sure it's relevant to someone who's wrapping their head around Functor for the first time.
12:48:08 <startling> jrw, yeah, I think you're right.
12:48:10 <Komier> they: Thanks.  Effectively what I'm using as well.  I suspect I may have the same trouble on the math front... but hey, what's life without a challenge. :)
12:48:22 <startling> jrw: I think there's a nice Applicative, though. :)
12:48:37 <jrw> startling: agreed. analogous to ziplists iirc.
12:48:51 <erisco> Cale, have you heard of FGL?
12:49:15 <jrw> bmuk: yes, you're right in normal math. but in category theory you can give a different definition of the same concept.
12:49:16 <Cale> erisco: yes
12:49:28 <erisco> Cale, you did not mention it when we were discussing graphs
12:49:29 <Cale> If you mean the graph library, anyway
12:49:39 <jrw> bmuk: but I want to point out that this is probably not the best way to try to understand monads :)
12:49:51 <bmuk> jrw: that they are categories of one object?
12:50:00 <bmuk> haha why is that and what is the best way?
12:50:05 <erisco> Cale, I read the paper and the idea is interesting but I am not entirely convinced
12:50:30 <zett_zelett> Komier: I used to code a bit of C/C++ (for university) before I stumbled upon Haskell one year ago. In August/September, I tried out a little bit of Scheme and was beginning to read How To Design Programs and Structure and Interpretation of Computer Programs, but I discontinued both early. In the meantime, I did a bit Java (for university). Now I’m reading Learn You A Haskell. I did solve the first nine problems for project Euler.
12:50:48 <Cale> erisco: Well, the important thing is the algorithms provided. The original representation that the paper suggests is a bit dumb.
12:51:03 <jrw> bmuk: that quote I gave above is usually stated as a joke. the way to understand monads is to use them. just like we've been doing with functors: i've been giving you data types and you've been writing the instances for them. do that for monads.
12:51:12 <jrw> bmuk: Maybe is my favorite place to start.
12:51:22 <erisco> Cale, why is that so? do you mean the inductive representation or do you mean their optimisation strategies?
12:51:33 <Komier> zett_zellett: What point are you up to in the book if I may ask?
12:51:37 <bmuk> jrw: I got that it was a joke lol
12:52:07 <bmuk> okay so maybe. data Maybe a = Nothing | Just a
12:52:26 <bmuk> :t (>>=)
12:52:27 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:52:52 <jrw> yep. you're on a roll.
12:52:58 <maxiepoo> Can you use Data.Derive to derive orphan instances?
12:53:08 <jrw> bmuk: you can knock out return first, it's usually easier.
12:53:11 <jrw> :t return
12:53:12 <lambdabot> Monad m => a -> m a
12:53:18 <bmuk> Maybe a -> (a -> Maybe b) -> Maybe b. This lets you chain functions which return Maybes but take normal values
12:53:28 <jrw> bmuk: right.
12:53:39 <bmuk> return wraps a in Maybe
12:53:43 <zett_zelett> Komier: I’m jumping a lot, but I have definitely read the first five chapters and understood most of it.
12:53:44 <maxiepoo> I want to derive some Arbitrary instances but I don't want to make the src depend on QuickCheck/Data.Derive if I don't have to
12:53:48 <startling> :t (>>=) `asAppliedTo` Nothing
12:53:49 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
12:53:49 <bmuk> or is that a bad way to think of it
12:54:12 <jrw> bmuk: it's a good way for Maybe. perhaps not so good for other monads.
12:54:17 <lingxiao> hey what do people here make of the opinion that "it takes 10 years to become a good programmer" and how it applies to haskell
12:54:19 <jrw> bmuk: but definitely a good start.
12:54:27 <startling> maxiepoo, I usually put those instances in my testing code (which already uses QuickCheck)
12:54:29 <zett_zelett> komier: But I’m reading about monads right now, I skipped the modules chapter as it looked boring and I skimmed through the functors chapter.
12:54:59 <lingxiao> here "good" refers to what one can accomplish individually, not in a group setting where other things come into play
12:55:03 <erisco> Cale, their inductive approach allowed simple definitions for a few graph functions, which was interesting
12:55:09 <bmuk> I think I understand >>=, return, and >> or at least how they apply to Maybe
12:55:15 <bmuk> :t (>>)
12:55:16 <lambdabot> Monad m => m a -> m b -> m b
12:55:20 <maxiepoo> startling: right, but do you know if you can derive the instances automatically with Data.Derive if it's in the testing code?
12:55:34 <merijn> zett_zelett: I believe the modules chapter is really mostly a reference chapter that tells you which bits may be interesting to look at
12:55:41 <erisco> Cale, however, the premise seems built on top of never needing to mark nodes (or keep a set of visited nodes)
12:55:47 <startling> maxiepoo: I don't know what you mean.
12:56:07 <erisco> Cale, and I am not convinced that was achieved. For example, given a graph G, how would you determine if it contained cycles?
12:56:10 <jrw> bmuk: cool. it might be good to actually right the code for >>= and return for Maybe. then you could try list next?
12:56:14 <maxiepoo> startling: The type is just an AST so I don't want to write the Arbitrary instance myself
12:56:18 <zett_zelett> komier: I’m a graduate student of mathematics, so I know one thing or two about functors, monoids and monads by now.
12:56:22 <maxiepoo> not even an AST
12:56:49 <bmuk> should I do that here or on my own?
12:56:53 <maxiepoo> just like the literals data Lit = Int n | Float f | ...
12:56:54 <zett_zelett> komier: As one probably should add.
12:57:06 <jrw> bmuk: probably on your own, asking questions here if you get stuck :)
12:57:11 <maxiepoo> so I don't want to write it by hand bc it's tedious
12:57:13 <merijn> Semi-topical question: Anyone here aware of work into orthogonal type systems? i.e. applying multiple separate type checkers/systems to the same code?
12:57:15 <maxiepoo> and mechanical
12:57:25 <bmuk> okay, I didn't want to clog up the channel lol
12:57:28 <maxiepoo> soI'm trying http://community.haskell.org/~ndm/derive/
12:57:38 <jrw> merijn: I don't, but I know a group that has a big project like that.
12:57:55 <merijn> jrw: Do you have a link/references?
12:58:02 <jrw> merijn: sure, one sec.
12:58:16 <jrw> merijn: not sure if it's exactly what you're looking for.
12:58:32 <zett_zelett> Komier: I also read chapter 6, I forgot the modules chapter was whapter 7. I read anything up to the modules chapter and I skimmed through chapters 8, 9 and 11.
12:58:44 <Komier> zett_zellett: Great thanks.  Yes indeed, my mathematics may hold me back a little I assume, but Haskell just.. "feels" more right for want of a better term, so I'd determined to learn it.  I have a similar dabbling background with regard to programming... scripts and programs for work, first few euler problems in C/Python, messing with an Arduino.
12:59:01 <jrw> merijn: http://types.cs.washington.edu/checker-framework/
12:59:23 <jrw> merijn: I'd be curious to know what you think of it
12:59:37 <merijn> jrw: Well, I had a brainstorming discussion about this topic earlier this year, I'm submitting to a workshop on language design and it seems like an "obvious" idea, so before I claim to be groundbreaking I wanna see if people have been working on similar things and how far they got :)
13:00:52 <merijn> jrw: Ah, yeah, this looks somewhat like what I'm looking for :)
13:01:12 <jrw> merijn: afaik, this group hasn't done too much work on "orthogonality" or even applying multiple type checkers at once. basically they try to make it easy to implement a bunch of type systems for java. whether you run 1 or more of them is up to you, I guess.
13:01:22 <merijn> Although at cursory inspection it seems to work by extending an existing type system, instead of being orthogonal
13:02:15 <jrw> merijn: right, like I said, I'm not sure they thought orthogonality was important/interesting. some of their type systems are certainly unrelated though.
13:02:55 <zett_zelett> Komier: The problem is that Haskell isn’t really mathematically accurate as far as I understand: Functors aren’t really functors, Monads aren’t really monads and so on. This is confusing to me and I imagine this to be even more confusing to people not acquainted with these ideas at all. And category theory is a very abstract way of thinking which takes a lot of getting used to.
13:03:03 <merijn> jrw: I had a discussion about encoding properties other than "type correctness" in the type system and how that becomes a mess, so from there we had the idea "well, what if instead of trying to encode them in the existing type system, we had an orthogonal type system that's checked in parallel with the "normal" one"
13:04:00 <startling> merijn: I've been thinking about that lately.
13:04:01 <Komier> zett_zellett: yeh so I understand.  I have bookmarked a page with a whole book on category theory for a little later on.  Someone mentioned it int he channel earlier today.
13:04:25 <jrw> merijn: that sounds similar. for example, these guys have a "nullness" type system that can prove absence of null pointer exceptions.
13:04:36 <zett_zelett> It might still be a good idea to learn some basic category theory though.
13:05:02 <jrw> that system has two types. "possibly null" and "definitely not null". you can guess how the rest of it works.
13:05:11 <merijn> startling: I already have a colleague working on something like that for data layouts, i.e. they have layout polymorphic code and code with specific layouts. The type checking would ensure you only combine functions that work with the same/correct layouts
13:05:38 <merijn> startling: Which means you can write "layout polymorphic" types which unify with all possible layouts, while other may be fixed to some specific layouts
13:05:58 <startling> merijn: the main thing I want to do is infer stack space.
13:06:32 <startling> possibly with a termination checker.
13:07:15 <merijn> startling: Another thing I was thinking of was GC domains, i.e. in a multi-threaded runtime like GHC it costs you a lot to have a global GC stop across all capabilities. The ability to have separate GC per capability and have exchanges between domains checked by the type system would be nice, you could write code that avoids global stops
13:08:02 <merijn> jrw: Anyhoo, thanks for the link!
13:08:24 <startling> merijn: that's interesting. my thinking re: stack space comes from a similiar angle.
13:08:31 <jrw> merijn: np, keep me posted on your paper
13:08:40 <startling> if you know stack space is bounded and never goes over x, you can avoid malloc entirely.
13:08:50 <meretrix> Say I have "data X = A | B | C", and I want a one-to-one mapping from each constructor of X to an IORef.  How can I construct the map to guarantee that the lookup won't fail and not have to write a case expression manually for each constructor?
13:09:03 <Komier> zett_zellett: you are likely right.  It may even be the language is going to be very difficult for me.  I found this earlier today which may help me : https://geoffhulette.wordpress.com/2010/11/22/category-theory-for-haskell-programmers/
13:09:31 <merijn> jrw: Well, the deadline is Tuesday and I only just realised this would make for a good topic >.>
13:09:56 <yitz> meretrix: pattern matching on each constructor is exactly how you would do that
13:10:40 <startling> meretrix, you could write "x :: a -> a -> a -> X -> a" to make that more consise, I guess.
13:10:51 <meretrix> yitz: Yes, but say I have 100 constructors.  Is there no way to avoid typing them all out?
13:11:00 <meretrix> I'd like to avoid template haskell as well..
13:11:09 <startling> meretrix, how else would you do it?
13:11:23 <yitz> meretrix: ah. yeah. th, or generics possibly.
13:11:43 <yitz> meretrix: normally we try to avoid those kinds of things if possible
13:11:43 <meretrix> startling: Well GHC knows all the type constructors.
13:12:02 <startling> meretrix, you still need to specify how they correlate somehow.
13:12:36 <meretrix> Well I just want an "IORef Int" for each constructor.
13:12:42 <meretrix> All initialized to zero.
13:12:46 <Cale> erisco: (Sorry, some company is here.) I'm not sure that's actually a goal of the library. You generally *do* need to keep track of additional information while traversing graphs no matter which representation you keep them in. I suppose that the inductive representation does give you a way to exhaustively traverse the graph without keeping track of those sets yourself, but there's always other information you might wa
13:12:46 <Cale> nt to keep track of anyway.
13:13:08 <startling> meretrix, oh. that makes it somewhat easier.
13:13:51 <erisco> Cale, well, just the problem I suggested seems to be unhelped by the inductive approach (given a graph G, determine if it contains cycles)
13:14:15 <bmuk>  /msg jrw sorry if I am bothering you, I'm stuck on bind in terms of lists
13:14:16 <Cale> erisco: But *actually* storing graphs as lists of contexts is pretty terrible. I believe the current version of FGL uses some variations on Map Vertex (Set Vertex)
13:14:38 <erisco> Cale, the paper describes the various optimisations they make
13:14:48 <erisco> their examples were simplified for clarity
13:15:33 <Cale> That paper is super-old though, and might not apply to the current version of the library, as far as I know
13:15:56 <erisco> I am reading more materials (reading http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue5/Practical_Graph_Handling now) but
13:16:05 <Cale> (unless you're talking about another one)
13:18:06 <erisco> a practical solution is going to have to deal with stateful traversals, is what I am getting at
13:18:11 <meretrix> startling: Were you suggesting there is an alternative to pattern matching or TH?
13:18:51 <Cale> erisco: I guess one way to check that a graph is acyclic is to compute the strongly connected components and check that each one has a single vertex in it
13:19:27 <Cale> So you could use fgl's scc
13:19:53 <StahlGrau> clear
13:20:00 <StahlGrau> whoops
13:20:05 <StahlGrau> sorry, haha
13:20:23 <erisco> Cale, that is a good point. I should look closely at their scc algorithm then
13:21:16 <Cale> erisco: Anyway, the main thing I hate about FGL is that its names for everything are terrible
13:21:28 <erisco> well I am after ideas at this point :)
13:21:43 <erisco> I am unhappy with some of the graph stuff I am doing
13:21:45 <Cale> Who can honestly remember the difference between xdfWith and xdfsWith?
13:21:54 <erisco> I am very happy when I can let the algorithms infinitely unfold
13:22:14 <erisco> I am not happy with using the State monad so much =\
13:22:33 <startling> mereterix: you could do sequence $ zipWith (liftM . (,)) allOfMyType (repeat newIORef) and "lookup" later (but you would need to unsafely ignore Nothing)
13:22:36 <Cale> You should use the graph representation that I suggested
13:23:02 <Cale> It's much easier to exhaustively traverse the vertices of your graph when they are the keys in a Map
13:23:23 <Cale> and you can find a specific vertex in log time that way
13:24:27 <erisco> Cale, I am considering options. That approach is not without its own headaches
13:24:47 <meretrix> startling: Thanks. Is that a common approach? I find myself wanting to use this pattern quite often.
13:25:12 <erisco> for example, by tying the knot, I do not have to worry about unconnected subgraphs... the GC does :P
13:25:27 <erisco> mark and sweep baby
13:25:33 <Cale> I suppose, but you might actually want to represent those.
13:25:56 <Cale> Graphs in general can be disconnected
13:26:00 <erisco> sure
13:26:32 <zett_zelett> There is no royal road to Haskell. – Euclid¹
13:27:15 <L8D> ...
13:27:22 <erisco> Cale, the lack of re-use on graph updates I think is the primary hurt for the tying the knot approach
13:27:28 <L8D> Is there a function that does the reverse of sequence?
13:27:44 <L8D> Or is that not possible?
13:27:50 <d3lxa> I've got an other type puzzle for you guys, is there a function like this? (a -> c) -> (b -> f a) -> f c  (i've searched on hoogle, any idea?)
13:27:53 <startling> meretrix, I just made it up, heh.
13:28:04 <startling> L8D: what would its type be?
13:28:12 <L8D> :t sequence
13:28:13 <lambdabot> Monad m => [m a] -> m [a]
13:28:23 <L8D> Monad m -> m [a] -> [m a]
13:28:29 <L8D> Monad m => m [a] -> [m a]
13:28:50 <yitz> L8D: you could get m [a] -> m [m a]
13:28:58 <startling> :t (:[]) . fmap head
13:28:59 <lambdabot> Functor f => f [b] -> [f b]
13:29:17 <notdan> But it's not exactly the reverse of 'sequence' isn't it
13:29:27 <startling> L8D, I think you
13:29:34 <erisco> Cale, but for the algorithms that can infinitely unfold I do not think that concern stands (there are no cycles)
13:29:40 <L8D> I still haven't been able to understand how fmap works
13:29:43 <startling> 'd need some way of splitting monadic actions (which Monad doesn't give you)
13:29:51 <notdan> ^
13:30:09 <startling> conceivably some other typeclass could, but I'm not sure it can be done in general.
13:32:02 <Cale> d3lxa: Where is it going to get a b from?
13:33:06 <L8D> What's the difference between (>>=) and fmap?
13:33:07 <Cale> d3lxa: Assuming that f is an instance of Functor, in order to get an f c, the only thing it could do is to apply the function (b -> f a) and then fmap the function (a -> c) over that
13:33:13 <erisco> Cale, *shrug* I dunno. When the answer to "how do you do graphs in Haskell" is "you represent them indirectly" I am sad :(
13:33:23 <d3lxa> Cale: in fact I've something similar like this: return . f <=< g  but it's more verbose than necessary right?
13:33:24 <Cale> d3lxa: But it doesn't have a value of type b available, so that's impossible
13:33:40 <roconnor> erisco: a graph is just a matrix. :)
13:34:01 <Cale> L8D: the type is completely different?
13:34:25 <Cale> L8D: You can't write (>>=) given fmap, but you can write fmap if given (>>=)
13:34:42 <Cale> (and return)
13:34:42 <erisco> roconnor, and a list is just a set of 2-tuples (index, value)
13:35:04 <startling> :t fmap -- L8D
13:35:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:35:11 <startling> :t (>>=) -- L8D
13:35:11 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:35:23 <L8D> Isn't a monad a functor?
13:35:28 <startling> :t fmap return
13:35:29 <lambdabot> (Monad m, Functor f) => f a -> f (m a)
13:35:33 <Cale> L8D: yes, every monad is a functor
13:35:37 <startling> :t (>>=) return
13:35:37 <lambdabot> Monad m => (m a -> a -> b) -> a -> b
13:35:38 <L8D> ooh
13:35:40 <startling> er
13:35:42 <L8D> I see then
13:35:47 <startling> :t (>>= return)
13:35:48 <lambdabot> Monad m => m b -> m b
13:35:51 <bennofs> :t liftM return
13:35:52 <lambdabot> (Monad m, Monad m1) => m a1 -> m (m1 a1)
13:35:54 <L8D> But then what's the point of (>>=)?
13:35:57 <roconnor> erisco: a list is more like a sum of n-tuples
13:36:01 <Cale> L8D: huh?
13:36:17 <L8D> What's the point of (>>=) when we have fmap?
13:36:18 <startling> L8D, what's the point of cats, if all cats are animals?
13:36:26 <Cale> L8D: I don't know how to begin to answer that, because there are so many directions you could approach it from.
13:36:34 <L8D> Why not just use `fmap`?
13:36:43 <bennofs> @ty fmap
13:36:44 <frx> L8D how would you implement >>= with a fmap?
13:36:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:36:46 <bennofs> @ty (>>=)
13:36:46 <Cale> L8D: You can do things with (>>=) which can't be done with fmap
13:36:47 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:36:47 <d3lxa> L8D: fmap or <$> is for functor whereas >>= is for monad, monad != functor
13:36:50 <startling> L8D: think of a venn diagram.
13:36:52 <Cale> Check this out:
13:37:01 <Cale> :t \x -> x >>= id
13:37:01 <lambdabot> Monad m => m (m b) -> m b
13:37:02 <startling> L8D, some functors are also monads. all monads are functors.
13:37:13 <d3lxa> thus some functors are *not* monads :)
13:37:14 <Cale> This function reduces the number of m's in the type of its argument
13:37:20 <startling> d3lxa: not "thus". :)
13:37:27 <Cale> Every application of fmap will leave the number of occurrences of the functor the same
13:37:29 <Cale> :t fmap
13:37:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:37:32 <benmachine> but indeed some functors are not monads
13:37:36 <startling> ^
13:37:47 <Cale> the number of f's in the input type is the same as the number of f's in the result type
13:37:53 <L8D> Yes, but if you write getContents >>= putStrLn, what's to prevent you from writing getContents `fmap` putStrLn ?
13:37:54 <roconnor> erisco: anyhow, my default is to represent a graph as a (sparse) matrix when I want to do graph things, unless I have good reason to do something else.
13:37:56 <d3lxa> startling: hum… my bad, what to say? for example maybe
13:38:08 <countoren> hello , im working on yesod project , i want to import some module on the foundation file and all handlers files i dont want to repeat all the imports form the foundation file (which i need in the new file) and if i use the Import module i get circular dependencies, any elegant  way to solve it??
13:38:10 <Cale> L8D: Doesn't typecheck
13:38:11 <benmachine> :t putStrLn `fmap` getContents
13:38:11 <lambdabot> IO (IO ())
13:38:20 <benmachine> L8D: ^ what I assume you meant
13:38:23 <L8D> yes
13:38:29 <benmachine> but that's IO (IO ())
13:38:30 <Cale> if you flip it around, it typechecks, but the resulting type is different
13:38:31 <d3lxa> countoren: why not #include ? :)
13:38:34 <benmachine> which is not what you want
13:38:34 <roconnor> erisco: I guess I do mostly static graph stuff though.
13:38:38 <startling> d3lxa, "some functors are not monads" does not follow from what I said, but it is true.
13:38:38 <L8D> :t getContents >>= putStrLn
13:38:39 <lambdabot> IO ()
13:38:52 <roconnor> erisco: but then again, lots of things can be done with static graphs.
13:38:52 <countoren> d3lxa: #inculde?
13:38:58 <benmachine> L8D: it may be easier to compare fmap with (=<<)
13:39:01 <benmachine> :t (=<<)
13:39:02 <lambdabot> Monad m => (a -> m b) -> m a -> m b
13:39:02 <benmachine> :t fmap
13:39:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:39:05 <d3lxa> countoren: yesod enables the CPP directives, thus you can use #include
13:39:22 <L8D> Interesting
13:39:42 <L8D> :t flip (>>=)
13:39:43 <lambdabot> Monad m => (a -> m b) -> m a -> m b
13:39:43 <Cale> fmap putStrLn getContents gives you an IO action which when executed is going to execute getContents, and return an IO action which is putStrLn applied to the contents of stdin without executing that
13:39:53 <L8D> :t (=<<)
13:39:54 <lambdabot> Monad m => (a -> m b) -> m a -> m b
13:39:55 <startling> L8D: (>>=) is like fmap but with an extra step where it "flattens" an m (m a) into an m a.
13:39:57 <Cale> >>= goes one step further, and actually executes that result
13:40:06 <L8D> okay
13:40:08 <Cale> There's an equation relating them:
13:40:09 <L8D> I see now
13:40:15 <Cale> x >>= f = join (fmap f x)
13:40:26 <L8D> @src (>>=)
13:40:26 <lambdabot> Source not found. Are you on drugs?
13:40:26 <startling> "join" is this "flatten" operation.
13:40:38 <benmachine> L8D: (>>=) differs from monad to monad
13:40:40 <Cale> So in some sense, join is precisely the difference between >>= and fmap
13:40:45 <Cale> :t join
13:40:46 <lambdabot> Monad m => m (m a) -> m a
13:40:57 <lispy> is join a reference to a "lattice" (or lattice-like) structure that you get in the commutative diagrams in CT?
13:41:06 <L8D> (>>=) = join . fmap
13:41:15 <Cale> no
13:41:16 <benmachine> lispy: I don't believe so, it's not a name that I've seen in mathematics
13:41:19 <Cale> That doesn't typecheck
13:41:27 <Cale> It would be (join .) . fmap
13:41:30 <startling> a >>= f = join (fmap f) a
13:41:31 <L8D> oh
13:41:36 <startling> er
13:41:46 <startling> a >>= f = join (fmap f a)
13:41:51 <L8D> well then... (>>=) = (join .) . fmap
13:41:51 <Cale> :t (join .) . fmap
13:41:52 <lambdabot> (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
13:41:53 <benmachine> :t (join .) . fmap
13:41:54 <lambdabot> (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
13:41:57 <ifesdjeen> startling: finished porting my lisp to the state monad + Data.Map by your advise :)
13:41:58 <companion_cube> lattices have join/meet operators, in mathematics
13:41:59 <Cale> and =<<
13:42:03 <Cale> :t (=<<)
13:42:04 <lambdabot> Monad m => (a -> m b) -> m a -> m b
13:42:05 <ifesdjeen> startling: thanks again for that one
13:42:06 <startling> ifesdjeen, how'd it work?
13:42:13 <startling> ifesdjeen: no problem. :)
13:42:18 <benmachine> companion_cube: right, as far as I know monad-join is not a join in that sense
13:42:24 <Cale> So, (>>=) = flip ((join .) . fmap) :)
13:42:24 <ifesdjeen> startling: i struggled at first, but afterwards it turned out to work quite smoothly
13:42:32 <companion_cube> no, there's no relation afaik
13:42:36 <L8D> :t (join .) . fmap
13:42:37 <ifesdjeen> startling: enabled me to write simpler tests
13:42:37 <lambdabot> (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
13:42:37 <startling> ifesdjeen, if you're still learning Haskell, it might be instructive to derive State yourself.
13:42:43 <L8D> :t (>>=)
13:42:44 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:43:00 <ifesdjeen> startling: derive state - you mean to write my own state monad?
13:43:06 <countoren> d3lxa: i dont understand how it works have some url that i can check it out?
13:43:08 <startling> ifesdjeen, yeah.
13:43:16 <ifesdjeen> startling: ok, will dig into that
13:43:21 <startling> ifesdjeen: not necessarily to use in your project, but to understand how it works.
13:43:36 <Cale> lispy: It's not, in mathematics, join is usually written with the Greek letter mu (μ) and called multiplication.
13:43:51 <ifesdjeen> startling: haha, i think i got the principle (e.g. non-evaluated function) but I agree - should give some insight
13:43:57 <ifesdjeen> startling: thanks again!
13:44:02 <lispy> Cale: ah.
13:44:25 <startling> ifesdjeen, I can walk you through it sometime if you'd like. Might also be useful to look at Identity's and Reader's respective instances.
13:44:41 <d3lxa> countoren: search for haskell and CPP, something like these http://stackoverflow.com/questions/6361846/where-can-i-learn-about-ifdef
13:44:41 <Cale> and while we're at it, return is written as eta (η) and called the unit
13:44:56 <startling> Cale, that's interesting.
13:44:58 <ifesdjeen> startling: i'll try to figure it out) I'll ask you if I'm really stuck. You've already helped me a lot!
13:45:09 <ifesdjeen> thanks for the offer!
13:45:29 <startling> ifesdjeen: no problem! I suspect other people in this channel would be willing to help, too, if I'm not around.
13:45:48 <ifesdjeen> sure! Haskell channel is one of the most helpful I've experienced so far
13:45:55 <Cale> startling: Yeah, that's pretty much the Rosetta stone that you'll need to understand articles on monads written for mathematicians :)
13:46:04 <startling> Cale: heh.
13:46:25 <ifesdjeen> I'm a clojure guy by day, but Haskell channel helped me more (at least up to the moment)
13:46:32 <ifesdjeen> although clojure guys are quite helpful too )
13:46:35 <Cale> Also, I guess, the fact that in mathematics, fmap is written using the name of the functor itself
13:46:51 <startling> Cale: I don't understand why join is "multiplication".
13:47:07 <startling> Cale: I guess return isn't join's unit, it's some other unit?
13:47:42 <Cale> okay, let's look at monoids to start with, to make the analogy clear
13:48:00 <countoren> d3lxa: thanks man ill check it
13:48:01 <startling> join isn't even a binary operation. :(
13:48:10 <carcassone> hey guys
13:48:13 <Cale> It is, kind of, abstractly, you'll see :)
13:48:29 <Cale> So, traditionally, a monoid is some set M together with a binary operation *: M x M -> M, which has a unit 1 in M
13:48:56 <startling> sure.
13:49:51 <Cale> In order to try to generalise monoids and talk about them category theoretically, we can't talk about the elements of an object in a category, but we could talk about a function e: 1 -> M where 1 is some one element set, and e picks out the unit element of M
13:50:02 <carcassone> I'm tryin' to build a game called carcassone in Haskell, but I'm stuck in a point. I have to build a function that takes the coordinates, the direction, the number of the player and if the tile has a meeple, to draw the tyle. ANy thoughts? :s
13:50:11 <Cale> and so we have some hope of generalising this to a more arbitrary setting
13:50:23 <startling> Cale, alright.
13:50:40 <Cale> Okay, so if I just make the big leap all at once, it might not make total sense yet, but just to get a sense for where we're headed...
13:50:57 <startling> Cale: (why a one-element set? why not just const mempty, or just mempty?)
13:51:14 <startling> (or even a zero-element set?)
13:51:15 <Cale> With a monad M (which is an endofunctor C -> C), we have natural transformations eta: 1 -> M
13:51:22 <Cale> and mu: M . M -> M
13:51:29 <Cale> so abstractly, the parts look similar
13:51:38 <tristan_1> https://twitter.com/substack/status/417408604040200192
13:51:42 * hackagebot dynamic-cabal 0.2 - dynamic-cabal  http://hackage.haskell.org/package/dynamic-cabal-0.2 (BennoFuenfstueck)
13:51:51 <Cale> Only we've replaced the one element set 1 with the identity functor 1
13:52:03 <Cale> and the Cartesian product of sets with the composition of functors
13:52:20 <benmachine> oh, 1, you name so many things
13:52:21 <Cale> and our arrows aren't in Set, they're in the category of endofunctors C -> C
13:52:28 <startling> Cale, I think you lost me.
13:52:39 <Cale> Oh, why a one-element set?
13:53:00 <Cale> Well, a function f: {*} -> A is uniquely determined by what f(*) is
13:53:05 <Cale> it's some element of A
13:53:19 <startling> I don't understand the notation.
13:53:30 <Cale> All right
13:53:33 <Cale> Which part?
13:53:47 <startling> what's {*}? what does f(*) denotate?
13:54:03 <startling> oh, a one-element set with * in it?
13:54:04 <Cale> oh, {*} is some one element set, whose only element is *
13:54:06 <Cale> yeah
13:54:20 <startling> oh, alright, simpler than I thought.
13:54:21 <Cale> (maybe I shouldn't have used * :)
13:54:37 <Cale> It's kind of confusing if we're also talking about multiplication :)
13:54:38 * startling is too used to haskell's operator syntax
13:54:57 * startling 's second thought was Type.
13:55:13 * FireFly was thinking along the lines of placeholder syntax, like f(-,0)
13:55:20 <startling> Cale, so why don't we just say "we have an element of M"?
13:55:39 <quchen> And then call it "*" for brevity!
13:55:41 <Cale> startling: Well, if we're trying to generalise to arbitrary categories
13:55:51 <Cale> startling: Categories don't have a notion of elements
13:55:56 <Cale> (at least, not to start with)
13:56:07 <startling> Cale, all I know about CT is what shachaf has explained to me in #-blah and #-lens
13:56:29 <bennofs> Is there a channel about category theory?
13:56:32 <Cale> So, when we go to pick up this definition, and transplant it into some other category, we're going to want to avoid talking about elements of the set M
13:56:38 <startling> Cale, but OK, fair enough. I've heard of Lawvere's thing-not-based-on-ϵ.
13:56:39 <Cale> ##categorytheory
13:56:55 <bennofs> It has 2 members when I join :O
13:57:08 <Cale> There's 56 people in there right now
13:57:12 <Cale> perhaps you typoed it
13:57:22 <bennofs> Yeah, missed the double #
13:57:30 <startling> haha
13:57:38 <Cale> in fact, maybe it's best if we move this discussion to there :)
13:57:40 <quchen> There's also an answer on SO that gives a handwavy explanation of the "associative join" business: http://stackoverflow.com/a/3870310/1106679 -- That said, carry on, I like to listen to Cale. :-)
13:57:46 <Cale> (for anyone else who is listening along)
13:58:17 <Cale> quchen: (you might want to join ##categorytheory too!)
13:59:41 <Mathnerd314> is there a class for functions of the form f a -> (a -> IO b) -> IO (f b) ?
14:01:06 <merijn> Mathnerd314: looks like Traversable-ish?
14:01:11 <merijn> :t T.traverse
14:01:12 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
14:01:20 <quchen> :t T.for
14:01:20 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
14:01:26 <Mathnerd314> merijn: yeah, but the instance I want depends on using IO...
14:01:28 <merijn> Ah, there we go
14:01:39 <merijn> Mathnerd314: IO is an applicative
14:01:52 <merijn> Mathnerd314: So as long as f is Traversable that should work
14:01:58 <d3lxa> question: I have often hard time with type errors far in the code (a few lines above) where it's correct, in a do-block, any hint to avoid this headaches? I tried to fix the types with some let _ = myvar :: MyType but useless so far
14:02:08 <bennofs> :t T.for :: Traversable f => f a -> (a -> IO b) -> IO (f b)
14:02:09 <lambdabot> Traversable f => f a -> (a -> IO b) -> IO (f b)
14:02:18 <Mathnerd314> merijn: right, but I can't implement the instance I want using only generic Applicative functions
14:02:22 <Mathnerd314> (instance IORef)
14:02:25 <dropdrive> Are there any resources to help me think "in typeclasses" instead of thinking "in objects", which is what I'm really used to?  (Java programmer here)
14:03:16 <merijn> Mathnerd314: You can't implement the instance of what?
14:04:18 <Mathnerd314> merijn: I can't do instance Traversable IORef, because read/write IORef are in IO rather than Applicative
14:04:19 <merijn> dropdrive: That seems like it'd be a bad resource, Java requires you use objects everywhere. Typeclasses are not nearly as mandatory
14:04:41 <stefa____> Anyone know how to get colored syntax/results(Like on learnyouahaskell.com) in GHCi? Version 7.6.3 on OS X 10.9. Thanks
14:05:04 <quchen> stefa____: There are hacks and wrappers around GHCi to add colour, but natively it's impossible.
14:05:29 <quchen> You can colour the prompt though by adding colour codes via ":set prompt" though.
14:05:36 <lispy> stefa____: http://www.reddit.com/r/haskell/comments/144biy/pretty_output_in_ghci_howto_in_comments/
14:06:07 <stefa____> quchen: lispy: Ok, thanks. Will investigate.
14:06:24 <Mathnerd314> hmm, maybe I should ask in #lens
14:06:38 <quchen> I think the problem with lispy's link is that reloading (or loading new modules?) un-loads the colour stuff.
14:07:03 <lispy> I've actually never tried that stuff.
14:07:10 <lispy> I just remembered that post on reddit
14:07:12 <Komier> Stefa____: You could use Sublime Text with the SublimeRepl plugin
14:07:51 <bennofs> Mathnerd314: lens probably won't help if you want to modify
14:08:33 <dropdrive> merijn: So what would you recommend for someone with a Java-oriented mindset?
14:08:49 <lispy> dropdrive: you probably don't want to think in typeclasses. Thinking in types would be a better translation.
14:08:58 <dropdrive> merijn: I can see what typeclasses are, but it's harder to see when task X requires typeclass Y
14:09:13 <geekosaur> in most cases the answer is "it doesn't"
14:10:05 <merijn> dropdrive: Usually there's a curve "I never know when to use typeclasses" -> "typeclass ALL the things!" -> "I guess I don't actually implement my own classes at all"
14:10:08 <lispy> dropdrive: If I were you, I would start with a standard haskell tutorial/book and do lots of exercises. Focus on how functions work.
14:10:45 <lispy> dropdrive: once functions are making sense, start to think about how functions can be more or less derived from the types
14:11:12 <quchen> I don't see how this helps a beginner.
14:11:13 <merijn> dropdrive: tbh, I rarely implement my own typeclasses, although I do use a lot of the existing ones (including from libraries like comonad/serialise) a lot
14:11:28 <dropdrive> merijn: Ah yes, exactly, I never know when to use typeclasses.  If I could realize that "HEY a typeclass would totally make sense here" then I could actually try to implement it
14:12:16 <dropdrive> merijn: Interesting, so for a moderate/modest Haskell programmer tends not to implement typeclasses?
14:12:42 <lispy> dropdrive: that matches my experience
14:12:48 <quchen> The rule of thumb is that you should use typeclasses as a) a dirty hack or b) when you can specify some laws the instances have to obey.
14:12:51 <merijn> dropdrive: Well, implementing instances for existing ones, I do a lot. Creating entirely new classes, not a lot
14:12:57 <dropdrive> merijn: Maybe only functions that have typeclasses in the signature like "(Ord a) =>", not sure what the right term is
14:13:10 <dropdrive> merijn: OK, I get it, thanks.
14:13:22 <quchen> (Laws as in "fmap id = id" or "a == b ≡ b == a")
14:13:29 <lispy> dropdrive: when a typeclass is mentioned in a type signature, we can also call it a constraint
14:13:32 <merijn> dropdrive: If you have things than can be Functor, then I make them that, etc.
14:13:41 <dropdrive> lispy: Thanks.  BTW, can you provide a pointer to "think about how functions can be more or less derived from the types"
14:14:12 <startling> @djinn a -> b -> a
14:14:12 <lambdabot> f a _ = a
14:14:39 <lispy> dropdrive: I don't know what would be a good introduction, but djinn is sort of a classic exmaple of having the machine do it: http://lambda-the-ultimate.org/node/1178
14:14:46 <dropdrive> @djinn (a -> b) -> [a] -> [b]
14:14:46 <lambdabot> Error: Undefined type []
14:14:58 <dropdrive> lispy: So you mean the theorems for free thing?
14:15:03 <quchen> Djinn doesn't do recursive types
14:15:16 <lispy> dropdrive: That's related http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
14:15:18 <quchen> @djinn b -> (a -> b) -> Maybe a -> b
14:15:18 <lambdabot> f a b c =
14:15:18 <lambdabot>     case c of
14:15:18 <lambdabot>     Nothing -> a
14:15:18 <lambdabot>     Just d -> b d
14:15:59 <dropdrive> @djinn (a -> b) -> Maybe a -> Maybe b
14:15:59 <lambdabot> f a b =
14:15:59 <erisco> quchen, f b _ _ = b  :D
14:15:59 <lambdabot>     case b of
14:15:59 <lambdabot>     Nothing -> Nothing
14:15:59 <lambdabot>     Just c -> Just (a c)
14:16:06 <lispy> dropdrive: theorems for free is more about using parametric polymorphism as a way to constrain things. It gives you laws based on quantifiers.
14:16:27 <lispy> dropdrive: But deriving a computation from a type is a more general concept
14:17:00 <quchen> erisco: Djinn is smart though!
14:17:50 <dropdrive> lispy: Thanks for your help.
14:18:55 <lispy> dropdrive: I mention it as useful, because most experienced Haskellers have developed an intuition where given a type they can often imagine exactly how something should be implemented. This allows types to be used for communicating ideas. Also, it lets you write types first and then fill in the code.
14:19:17 <lispy> dropdrive: And I think the only way to get to that point is to write lots of haskell and to think about how types work.
14:19:22 <k00mi> erisco: djinn tries to use as many arguments as possible
14:20:04 <quchen> lispy: If by "imagine" you mean "hammer around in the code until GHC's typechecker stops throwing walls of errors at you", then yes :-þ
14:20:56 <lispy> the tao of haskell :)
14:22:47 <jle`> ghc is like my personal pair coder
14:23:35 <quchen> I'm like GHC's personal pair coder
14:23:45 <quchen> I do the reviewing and the silly thing
14:23:45 <quchen> s
14:23:52 <jle`> haha
14:24:26 <dropdrive> lispy: It would be cool if there was a way to go from type to implementation (or at least implementationS).  I asked here before whether there was some XXX such that the answer to "what is the XXX of (a -> b) -> [a] -> [b]" is "map"
14:24:26 <klrr_> quote for HWN
14:25:32 <quchen> dropdrive: XXX = a possible implementation.
14:25:43 <quchen> map is a possible implementation of that type. But so is "f _ _ = []".
14:25:46 <lispy> dropdrive: if you want a way to practice, take things from the prelude and try to figure out the implementation based on the type
14:25:47 <dropdrive> quchen: I meant, map, and only map.
14:26:03 <tromp_> the canonical impl
14:26:14 <quchen> The most useful implementation, maybe.
14:26:34 <bmuk> I know this is a tad off-topic, but do any of you work in academia with haskell
14:26:34 <quchen> Another function with said type signature is "f = f".
14:26:50 <dropdrive> Actually I think "XXX" should be "the implementation f such that all other implementations can be implemented by post-composing with f"
14:26:59 <lispy> bmuk: I work in industry with haskell
14:27:10 <quchen> You can't implement  "f _ _ = []" with map.
14:27:36 <dropdrive> quchen: Not (const []) . map ?
14:27:39 <Thooms> dropdrive: G. Scherer at Gallium works on that iirc
14:27:42 <quchen> One type signature can have many possible implementations. Some of them are useful in programming.
14:27:55 <quchen> dropdrive: Oh, well that would work, if you allow that.
14:28:02 <bmuk> lispy: did you have to get a Phd to do so?
14:28:12 <dropdrive> quchen: Yeah, I meant "composing with map"
14:28:20 <lispy> bmuk: I have only a masters :)
14:28:33 <dropdrive> lispy: What industry are you in?
14:28:40 <quchen> One type signature that has particularly many Haskell implementations is IO ().
14:28:53 <quchen> And many of them are different and do useful things.
14:28:59 <lispy> dropdrive, bmuk: http://corp.galois.com/about-us/
14:29:19 <bmuk> lispy: how difficult do you think it would be for someone with poor grades to get in to grad school if they worked hard and got research published
14:29:29 <dropdrive> quchen: I see.  Still, isn't there a large swathe of types where there is one and only one "interesting/useful" implementation?
14:31:03 <lispy> bmuk: Well, the difficulty of getting in to grad school depends on the school. With state schools in the US if you have low grades you can use good scores on the GRE plus good references to strengthen your application. Once you're in a school, grades matter little compared to the projects/research that you accomplish while there.
14:31:21 <quchen> dropdrive: Maybe, but you can't really formalize that I think. When I see a type I can make up a couple of good guesses of what the function does, typically. That plus the function's name is a good first hint at what's happening.
14:31:47 * hackagebot elm-repl 0.2 - a REPL for Elm  http://hackage.haskell.org/package/elm-repl-0.2 (EvanCzaplicki)
14:31:49 * hackagebot Elm 0.10.1 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.10.1 (EvanCzaplicki)
14:32:15 <ocharles> Is there anything already written to take a list  [a]  and get a new list  [(a, [a])]  which, for each element in the input, gives me back a tuple of that element, and everything else in the list without that element
14:32:29 <bmuk> lispy: okay thank you. It's just the more I think about it the more I really want to work with haskell
14:32:42 <bmuk> I'm sure everyone here feels the same though
14:32:53 <tromp_> no, ocharles, you have to define that
14:33:29 <ocharles> ok
14:34:14 <lispy> bmuk: I would recommend getting familiar with ICFP and POPL proceedings
14:34:36 <lispy> bmuk: That will give you a taste of what kind of research academics are doing around Haskell
14:34:51 <lispy> bmuk: if instead, you want to use haskell and work on other topics then well you can just do that :)
14:34:51 <bmuk> Okay! thank you
14:35:20 <bennofs> > map (head &&& tail) $ permutations [1,2,3,4,5] -- How inefficient is this?
14:35:21 <lambdabot>  [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[2,1,4,5]),(2,[3,1,4,5]),(3,[1,2,4,5]),(1,[3...
14:35:38 <bennofs> Ah, that is not what I wanted :P
14:36:31 <ClaudiusMaximus> > let l = "ocharles" in [ (y, xs ++ ys) | (xs, y:ys) <- inits l `zip` tails l ]
14:36:32 <lambdabot>  [('o',"charles"),('c',"oharles"),('h',"ocarles"),('a',"ochrles"),('r',"ochal...
14:37:28 <dropdrive> Seems like a zipper of some sort.
14:38:33 <ocharles> ClaudiusMaximus: nicely done :)
14:39:41 <tromp_> :t foldr
14:39:42 <lambdabot> (a -> b -> b) -> b -> [a] -> b
14:39:45 <ClaudiusMaximus> ocharles: http://hackage.haskell.org/package/lens-3.10.1/docs/Control-Lens-Zipper.html#v:withins
14:43:35 <tromp_> @let pick [] = []; pick (x:xs) = (x,xs) : map (second (x:)) (pick xs)
14:43:36 <lambdabot>  Defined.
14:43:48 <tromp_> > pick ocharles
14:43:49 <lambdabot>  Not in scope: `ocharles'
14:43:52 <fread228_> @hoogle trace
14:43:52 <lambdabot> Debug.Trace trace :: String -> a -> a
14:43:52 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
14:43:52 <lambdabot> package trace-call
14:44:00 <tromp_> > pick "ocharles"
14:44:03 <lambdabot>  [('o',"charles"),('c',"oharles"),('h',"ocarles"),('a',"ochrles"),('r',"ochal...
14:46:44 <Ribeiro> hey guys
14:46:48 <erisco> > (fmap . fmap) fst . pick $ "ocharles"
14:46:49 <lambdabot>  Couldn't match type `[GHC.Types.Char]' with `(b0, b1)'
14:46:50 <lambdabot>  Expected type: [GHC.Types.Char] -> [(GHC.Types.Char, (b0, b1))]
14:46:50 <lambdabot>    Actual type: [GHC.Types.Char]
14:46:50 <lambdabot>                 -> [(GHC.Types.Char, [GHC.Types.Char])]
14:46:58 <Ribeiro> does someone help me?
14:47:11 <quchen> Currently not, no.
14:47:23 <erisco> :t fmap . fmap
14:47:24 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:47:33 <Ribeiro> When someone have time, pm me please
14:48:05 <merijn> Ribeiro: You're unlikely to find someone pming you. You're better off just asking your question here
14:48:42 <erisco> oops
14:48:49 <erisco> > fmap fst . pick $ "ocharles"
14:48:51 <lambdabot>  "ocharles"
14:48:52 <Ribeiro> I'm tryin' to build a game called carcassone in Haskell, but I'm stuck in a point. I have to build a function that takes the coordinates, the direction, the number of the player and if the tile has a meeple, to draw the tyle. ANy thoughts? :s
14:48:53 <erisco> :D
14:49:45 <erisco> Ribeiro, that is a broad question
14:49:57 <Komier> Sounds fun though.
14:52:37 <lispy> Ribeiro: How far have you made it? Maybe you could post some code to lpaste.net and ask folks here to look it over and help you?
14:54:30 <meditans> hi all.. I have a question on the usage of the Control.Lens library which I couldn't figure out reading the various tutorials
14:54:31 <Ribeiro> I have built 3 primary programs, in the one I'm currently building I've already built functions for the coordinates, the direction, the number of the player who's going to play the tile and if it has a meeple (a piece). NOw I need a function to implement on process to draw me the tile when I run it on ghci
14:55:07 <merijn> meditans: Feel free to ask (be aware there's also a #haskell-lens for just lens talk)
14:55:15 <meditans> http://lpaste.net/97705
14:55:27 <meditans> there is a minimal example
14:55:56 <meditans> merijn: I didn't know, I'll check also there, in case
14:56:14 <merijn> meditans: Sounds like the answer involves uniplate, but I'm not a lens expert, so I don't know a lot more than that
14:56:32 <Ribeiro> I've made it this far http://lpaste.net/97706
14:58:24 <meditans> merijn: thanks, I didn't know about uniplate. I'm going to check that, than maybe asking on the haskell-lens channel
14:59:02 <merijn> meditans: If I remember correctly uniplate is exactly about "do something to every 'a' in a type"
14:59:19 <bennofs> merijn: It would be biplate in this case iirc
14:59:40 <bennofs> or maybe template. I have to lookup the docs ...
14:59:43 <edwardk> > [(1 :: Int, 3 :: Double), (4,5),(5,6)] & biplate +~ (1 :: Int)
14:59:44 <lambdabot>  [(2,3.0),(5,5.0),(6,6.0)]
15:00:31 <bennofs> Ok, biplate vs template doesn't matter in this case
15:00:41 <meditans> :edwardk that code is stunning. What should I read to become familiar with it?
15:01:03 <edwardk> :t biplate
15:01:04 <lambdabot> (Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
15:01:45 <edwardk> biplate is a traversal that goes and looks for every 'a' in your 's' using Data.Data because it is so generic sometimes you need to use type signatures on it.
15:02:10 <edwardk> > (["hello","there"],"!!") & biplate %~ toUpper
15:02:11 <lambdabot>  (["HELLO","THERE"],"!!")
15:02:22 <bennofs> edwardk: Is there a way to "concat" two traversals, so that ^.. will return the results of the first one followed by the results of the second one
15:02:53 <edwardk> not as a traversal. as a fold, yes.
15:02:57 <edwardk> at least in head
15:03:23 <bennofs> Oh right, that is again
15:03:29 <bennofs> the problem with overlapping traversals :(
15:03:31 <edwardk> :t failing -- is the closest you get in traversals
15:03:31 <lambdabot>     Not in scope: `failing'
15:03:32 <lambdabot>     Perhaps you meant `ceiling' (imported from Prelude)
15:03:40 <edwardk> oh failing is also in head
15:03:59 <bennofs> Oh, but that is just (<>) with an Monoid instance for Const if I remeber right?
15:04:43 <edwardk> yeah
15:04:51 <xvccxc> Is there a package that allows to read PDFs to strings?
15:04:59 <xvccxc> I can't find anything.
15:05:01 <edwardk> > ("hello","world")^..(_1 <> _2)
15:05:02 <lambdabot>  No instance for (Data.Monoid.Monoid
15:05:03 <lambdabot>                     (Control.Lens.Internal.Getter.Accessor
15:05:03 <lambdabot>                        (Data.Monoid.Endo [[GHC.Types.Char]])
15:05:03 <lambdabot>                        ([GHC.Types.Char], [GHC.Types.Char])))
15:05:03 <lambdabot>    arising from a use of `Data.Monoid.<>'
15:05:11 <edwardk> that works in head
15:05:25 <bennofs> edwardk: was the monoid instance for Const added?
15:05:34 <edwardk> iirc
15:05:50 <bennofs> xvccxc: Reading PDFs to text is a really hard problem
15:06:16 <bennofs> xvccxc: You probably won't get good results, what do you need this for?
15:06:27 <Ribeiro> Can someone try helping me? http://lpaste.net/97706 . I want it to ghci draw the tyle xD
15:07:01 <Polarina> How difficult would it be to implement gotos in ghc?
15:07:10 <xvccxc> bennofs: I've tried the pdf-toolbox package, it produces a string without spaces, etc.
15:07:40 <Cale> Polarina: You can sort of do it with a continuation monad
15:07:47 <Cale> (though you can only jump backward)
15:08:08 <bennofs> xvccxc: That's because the PDF format is not made for anything other than printing or viewing it. In a sense, it's like a picture.
15:08:19 <Cale> Polarina: getCC = callCC (\c -> let x = c x in return x)
15:08:28 <Cale> Then you can do  jump <- getCC
15:08:34 <Cale> and when you execute jump, you'll go back
15:09:10 <Cale> e.g. try  (`runContT` return) $ do jump <- getCC; lift (putStrLn "hello!"); jump
15:09:36 <xvccxc> bennofs: The answer to your previous question is statistical machine translation.
15:09:44 <Polarina> Cale, thanks.
15:09:54 <Cale> You can also add a parameter:  getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f))
15:10:16 <xvccxc> bennofs: Dons also suggested pdf2line on stackoverflow, but I can't make it work.
15:10:40 <Cale> and then you can do something like  do (x,jump) <- getCC' 0; lift (print x); when (x < 10) (jump (x+1))
15:12:20 <Ribeiro> Cale : Can someone try helping me? http://lpaste.net/97706 . I want it to ghci draw the tyle xD
15:14:06 <Cale> Ribeiro: Perhaps you want something like  printTile x dir cls = forM_ [1..5] (\n -> putStrLn (getline x dir n cls))
15:14:22 <Cale> Ribeiro: It's hard to understand what you're asking for though :)
15:14:32 <Ribeiro> I have built 3 primary programs, in the one I'm currently building I've already built functions for the coordinates, the direction, the number of the player who's going to play the tile and if it has a meeple (a piece). NOw I need a function to implement on process to draw me the tile when I run it on ghci
15:15:05 <Cale> Ribeiro: Try that function I just wrote, and see if it does what you want
15:15:55 <Ribeiro> Cale : it gives me this error "drawtest.hs:433:23: Not in scope: `forM_' Failed, modules loaded: none."
15:16:04 <Cale> Oh, import Control.Monad
15:18:50 <Ribeiro> CAle : It gives me this huge error : http://lpaste.net/97708
15:19:09 <kholdstare_> edwardk: Hi edward! I have a question about your linear library (very useful, thanks!). I see a lot of similar libraries always reimplementing statically-sized vectors, and I'm surprised there isn't a de-facto library for that (or maybe there is). A generic library for these could be useful in other places (e.g. storing RGB pixel values). Is there any interest in moving that functionality into its own library?
15:19:39 <Cale> Ribeiro: It looks like you pasted an XML document into ghci
15:19:46 <edwardk> There is V n in linear for that purpose.
15:20:31 <kholdstare_> edwardk: indeed. Could it be its own library though?
15:20:31 <edwardk> Not sure what is really gained from splitting it into a separate package though, other than making it harder for users of linear to use it, as without all the linear bits its pretty hard to use
15:20:43 <Ribeiro> Cale : How do I load a board (it's in XML) to drawtest.hs in ghci?
15:20:55 <Ribeiro> Just to see if it draws me the tile I want
15:21:03 <edwardk> "fixed sized vectors" have a lot of points in the design space
15:21:31 <Cale> Ribeiro: It looks like your main action does some processing of XML already
15:21:42 <Cale> Maybe you'd like to use the function that I wrote somehow from main?
15:21:47 <Cale> I don't really know
15:24:35 <kholdstare_> edwardk: i see. As an example, I'm working with Pixels of float RGB data, which one could think of as V3 Float. There are a few useful things that are not necessarily tied to linear algebra that these could expose, such as its fixed size
15:25:27 <edwardk> sure, but there aren't a whole lot of those properties, and yu probably want to add them, subtract them, etc. what you've described is a vector space after all.
15:25:36 <kholdstare_> edwardk: perhaps it's too small a functionality, but I feel that just having a "fixed-size functor" type thing could be useful.
15:26:03 <edwardk> kholdstare_: the notion of a 'fixed sized functor' is what representable-functors captures, but it doesn't tell you the size.
15:26:20 <edwardk> because Integer -> a  is also 'fixed size'
15:26:38 <kholdstare_> edwardk: i see
15:27:54 <edwardk> not saying there isn't a role for such a library, its just not at a grain size i'd package, too many points in the design space to make enough people happy, and it provides a subset of existing functionality
15:31:25 <kholdstare_> edwardk: fair enough. I feel the type-level nat machinery is reinvented quite a lot. Perhaps this could just be an addition to Vector in containers? Anyway, thank you for your input. I'm transitioning from C++ into haskell, and trying to find familiarity :)
15:31:36 <Ribeiro> Cale : It gives me errors in 10 functions (I used Mooshak to test it)
15:31:54 * hackagebot hOpenPGP 0.9 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.9 (ClintAdams)
15:32:03 <edwardk> containers tries to remain pretty close to haskell 98
15:32:35 <edwardk> it uses some stuff, but it really doesn't go all out with the type-level craziness. the folks who maintain it milan and tibbe are pretty pragmatically minded guys
15:32:36 <enthropy> kholdstare_: ghc comes with a Nat in GHC.TypeLits
15:32:59 <edwardk> a 'standard' form of type level nat is coming soon though
15:33:12 <enthropy> which might soon be enough to replace all the   data Succ a; data Zero out there maybe
15:34:07 <kholdstare_> enthropy: I'm aware of it, and I think edwardk uses it in Linear.V too (in an ifdef).
15:37:36 <kholdstare_> edwardk: I'm all for pragmatism, but I also just miss having std::array<3, double> in c++ :) . Having something like "Vector 3 Double" in everyday Haskell would scratch that itch.
15:38:09 <dhrosa> that exists
15:38:19 <flebron> Well, C++ also has template templates, so we should have that as well :)
15:38:38 <edwardk> i can empathize with that, though we do have Array and the like if you want something a bit closer, though without the bounds guarantee
15:39:17 <bennofs> edwardk: Well, in C++, you don't have the bound guarantee at compile time either :p
15:39:26 <jle`> can i specify a path for a local package in a cabal file?
15:39:30 <dhrosa> there exist compile-time fixed sized array libs in haskell
15:40:02 <kholdstare_> flebron: well, template templates can be thought of as things of kind (* -> *) -> *, so haskell already has those :P
15:40:11 <flebron> :p
15:40:26 <bennofs> jle`: no, but if you have cabal-install >= 1.18, you can use cabal sandboxes and then use the 'cabal sandbox add-source /path/to/local/package' to add a local package
15:40:46 <jle`> bennofs: ah thanks, that's perfect
15:42:31 <kholdstare_> edwardk: on a related note, what do you think about adding diagonal and column lenses to the matrices in Linear?
15:42:44 <edwardk> go for it
15:43:22 <edwardk> send a patch, i have no objection to adding them =)
15:43:44 <kholdstare_> edwardk: sweet :D Thanks for you time. I'll get cracking :)
15:44:07 <edwardk> i think there is something for doing columns indirectly
15:44:10 <edwardk> one sec
15:44:21 <kholdstare_> ok
15:45:20 <edwardk> try 'incore _x', etc.
15:45:27 <edwardk> it could probably be better named =)
15:47:10 <kholdstare_> edwardk: thanks! I'll look into it. I'm still getting my head around the lens implementations :P
15:47:31 <edwardk> :t inside
15:47:32 <lambdabot> Functor f => ALens s t a b -> ((e -> a) -> f (e -> b)) -> (e -> s) -> f (e -> t)
15:48:04 <edwardk> inside moves a lens under a function. incore is an anologous version for the fact that (dense) vector spaces are representable, and look like functions
15:48:30 <edwardk> its used to get the translation component out of a 4x4 matrix, tc.
15:48:55 <kholdstare_> i see, so we dive into the row vectors in a way
15:53:01 <jle`> so acidstate serializes the haskell data structures in a binary file on-disk?
15:54:26 <Rarrikins> How can I get cabal to get the latest versions of the packages I've installed?
15:54:51 <jle`> within the same program execution, is this structure loaded into memory?
15:55:42 <rs0_> can anyone tell me what's wrong with the type signature of the function in the 'where' clause here? http://lpaste.net/97710
15:55:53 <aristid> @undo do p <- lift x; p
15:55:53 <lambdabot> lift x >>= \ p -> p
15:56:13 <dcoutts_> jle`: acid-state keeps the data in memory and also serialises the transaction log, so it can recover if/when the process is killed
15:56:28 <aristid> join . lift :D
15:56:31 <kholdstare_> rs0_: the 'a' in the where definition is different from the 'a' in the function type declaration
15:56:52 <jle`> dcoutts_: oh that's clever.
15:56:53 <kholdstare_> rs0_: the 'a' up top is only scoped to the type definition, and not the body of the function.
15:56:57 * hackagebot hOpenPGP 0.9.1 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.9.1 (ClintAdams)
15:57:06 <dcoutts_> jle`: to be clearer, serialises the transactions and writes them to a log file on disk
15:57:09 <rs0_> kholdstare_: I tried changing it to "b" as well, in the where clause
15:57:29 <kinslayer> I have a problem with some ADT I am writing, that I want to make from some JSON, however I would like to put Rational into some of the slots, and double into the others, however it complains about no parse when I use Rational... Any thoughts ?
15:57:30 <jle`> dcoutts_: does it always have to re-apply the entire transaction log every time the process starts?
15:57:32 <dcoutts_> jle`: and it can also checkpoint, though when it does that is under your control, it's not automatic.
15:57:45 <jle`> ah is that what checkpointing is?
15:57:56 <dcoutts_> jle`: yes, on start up it re-runs the transactions since the last checkpoint
15:58:27 <kholdstare_> rs0_: the problem is a little more nuanced. Let me look up a good reference. it'll be quicker that way
15:58:32 <dcoutts_> jle`: so you might decide to make a "clean shutdown" of your app involve writing out a checkpoint, or you might pick some other policy
15:58:38 <tpsinnem> if someone has read ralf hinze's 'numerical representations as higher-order nested datatypes
15:58:40 <tpsinnem> asdf
15:58:50 <kholdstare_> rs0_: http://stackoverflow.com/questions/6928884/type-signature-in-a-where-clause
15:59:21 <dcoutts_> Rarrikins: you'll have to be clearer about what you're asking. It's not clear what you mean.
15:59:39 <Rarrikins> @type let step x [] = [[x]]; step x l@(y:ys) = if (f x (head y)) then (x:y):ys else [x]:l in step
15:59:40 <lambdabot>     Could not deduce (FromExpr Bool) arising from a use of `f'
15:59:40 <lambdabot>     from the context (Show t)
15:59:40 <lambdabot>       bound by the inferred type of it :: Show t => t -> [[t]] -> [[t]]
15:59:53 <rs0_> ah, ScopedTypeVariables
15:59:55 <Rarrikins> @type let f = undefined; step x [] = [[x]]; step x l@(y:ys) = if (f x (head y)) then (x:y):ys else [x]:l in step
15:59:56 <lambdabot> t -> [[t]] -> [[t]]
16:00:05 <jle`> dcoutts_: thanks for the help
16:00:14 <dcoutts_> np
16:00:30 <Rarrikins> dcoutts_: For example, you can do aptitude full-upgrade, and it will get the latest versions of packages that Apt knows about.
16:00:44 <kholdstare_> yep :)
16:00:46 <tpsinnem> if someone has read ralf hinze's 'numerical representations as higher-order nested datatypes' (http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.571), might you help me understand what is being said about 'amortized time bounds breakind down in a persistent setting', on page 9?
16:01:28 <dcoutts_> Rarrikins: ah, so there's a flag that does that but it's not actually a good idea most of the time, as you don't really want to upgrade everything to the latest versions, just some things you care about
16:01:39 <rs0_> it works if I both add ScopedTypeVariables *and* add explicit quantification in the top-level type signature
16:01:55 <dcoutts_> Rarrikins: e.g. you don't typically want to switch to new versions of core libs
16:02:06 <Rarrikins> dcoutts_: Sure. Does it record what you've manually installed?
16:02:26 <dcoutts_> Rarrikins: or another partial solution is "cabal install world --dry-run"
16:02:27 <tpsinnem> specifically 'consider 2^n independent threads which all increment a'
16:02:37 <rs0_> awesome. thanks kholdstare_!
16:02:48 <Rarrikins> dcoutts_: Ahh, OK
16:02:57 <kholdstare_> rs0_: yeah it's awkward. I see people leaving these types as comments, and not bothering with the extension. No problem :D
16:02:59 <dcoutts_> Rarrikins: that's probably the closest. However it doesn't always work because it's not always possible to simultaneously install everything with consistent dependencies.
16:03:36 <dcoutts_> Rarrikins: you can try however, --dry-run, maybe also use --max-backjumps=-1 --force-reinstalls
16:03:44 <tpsinnem> the first thing that puzzles me is why 2^n threads is chosen as the example
16:03:54 <Rarrikins> dcoutts_: Alright. I'll try that. Thanks :)
16:04:14 <SrPx> Does anyone know what is the fastest Untyped Lambda Calculus interpreter available and the fastest ULC->JavaScript and ULC->C/C++ compilers out there? (am I asking too much?)
16:04:28 <tpsinnem> the second is the question of why does lazy evaluation help here
16:07:11 <tpsinnem> hm, maybe i'm getting that second issue now
16:17:33 <kholdstare_> edwardk: sorry, im a bit slow, but incore works. awesome!  "mat ^. (incore _x)" gives the first column.
16:18:15 <edwardk> sweet. you may want to put in an issue that it probably should come with documentation to that effect and/or be renamed to 'column' :0
16:20:14 <kholdstare_> edwardk: hehe. "How do I access columns?" "Oh just use the generalization of inside for corepresentable functors".
16:20:26 <edwardk> exactly =)
16:20:56 <edwardk> hey it made sense to me! =)
16:21:29 <edwardk> alas it only works for dense vectors, i don't have an analogous story for sparse ones yet =(
16:23:15 <kholdstare_> i see. Welp, I wouldn't know the first thing about it :P Thanks, I'll post the issue about column.
16:29:20 <dagano> what is a nice way to map over a list but apply function to every other element?
16:30:05 <enthropy>  zipWith (\i -> if odd i then f else id) (cycle [0, 1])
16:30:38 <dagano> cool i like it
16:30:43 <enthropy> or write the recursive function explicitly... it'll take up about the same amount of space
16:30:52 <dagano> i'm trying to move away from explicit recursion
16:31:02 <Rarrikins> zipWith (\i -> if i then f else id) (cycle [False, True])
16:31:06 <dagano> just to force myself to broaden a bit
16:31:37 <tromp_> use cycle [f,id] instead
16:31:49 <Rarrikins> Ahh, even better
16:32:04 <pavonia> Is it normal that there are two different versions of the base package installed at the same time?
16:32:34 <enthropy> it's not normal
16:32:37 <merijn> pavonia: Eh, no, that's very bad
16:32:44 <pavonia> oh heh
16:32:46 <merijn> pavonia: base should come with your version of GHC
16:33:10 <merijn> They're tied to each other, you can't (or aren't supposed to be able to) upgrade one without the other
16:33:25 <bennofs> Is there a good function to "splice" two lists together, so f [a,b,c] [d,e,f] results in [a,d,b,e,c,f] ?
16:33:32 <pavonia> How do I find out which is the "correct" one?
16:34:10 <merijn> pavonia: Good question, pastebin the output of "ghc-pkg list"? (Although someone else will have to check, I have to go sleep)
16:34:48 <pavonia> The versions are 3.0.3.2 and 4.2.0.0
16:34:55 <Rarrikins> > let zomg [] ys = ys; zomg xs [] = xs zomg (x:xs) (y:ys) = x:y:zomg xs ys in zomg [1..10] [31..40]
16:34:56 <lambdabot>  <hint>:1:57: parse error on input `='
16:35:04 <Rarrikins> > let zomg [] ys = ys; zomg xs [] = xs; zomg (x:xs) (y:ys) = x:y:zomg xs ys in zomg [1..10] [31..40]
16:35:05 <lambdabot>  [1,31,2,32,3,33,4,34,5,35,6,36,7,37,8,38,9,39,10,40]
16:35:17 <Rarrikins> bennofs: ^
16:35:31 <dagano> > zipWith (\i -> if i then f else id) (cycle [f,id]) [1,2,3,4,5] where f = (*2)
16:35:32 <lambdabot>  <hint>:1:64: parse error on input `where'
16:35:37 <bennofs> > concat $ zipWith (\x y -> [x,y]) [a,b,c] [d,e,f]
16:35:38 <lambdabot>  [a,d,b,e,c,f]
16:35:57 <Rarrikins> concat is the work of SATAN!
16:36:01 <pavonia> 4.2 seems to be the correct one
16:36:02 <tromp_> u dont need 3 cases to merge
16:36:17 <dagano> > zipWith ($) (cycle [id, (*2)]) [1,2,3,4,5]
16:36:18 <lambdabot>  [1,4,3,8,5]
16:36:23 <Rembane> Rarrikins: Black metal Haskell?
16:36:59 <Rarrikins> Rembane: Evil repeated use of (++).
16:37:27 <dagano> :t zipWith
16:37:28 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
16:37:37 <tromp_> @let m [] ys = ys; m (x:xs) ys = x: m ys xs in m [1,2,3] [11,12,13]
16:37:37 <lambdabot>  Parse failed: Parse error: in
16:37:48 <Rarrikins> Unless it's smart enough to fuse that away.
16:37:58 <tromp_> @let { m [] ys = ys; m (x:xs) ys = x: m ys xs } in m [1,2,3] [11,12,13]
16:37:58 <lambdabot>  Parse failed: Parse error: in
16:38:26 <Rarrikins> @let m [] ys = ys; m (x:xs) ys = x:m ys xs
16:38:26 <lambdabot>  .L.hs:156:21:
16:38:26 <lambdabot>      Ambiguous occurrence `m'
16:38:26 <lambdabot>      It could refer to either `L.m', defined at .L.hs:155:1
16:38:26 <lambdabot>                            or `Debug.SimpleReflect.m',
16:38:26 <lambdabot>                               imported from `Debug.SimpleReflect' at .L.hs:11...
16:38:39 <Rarrikins> @let kthx [] ys = ys; kthx (x:xs) ys = x:kthx ys xs
16:38:40 <lambdabot>  Defined.
16:38:45 <tromp_> @let  merg [] ys = ys; merg (x:xs) ys = x: merg ys xs
16:38:46 <lambdabot>  Defined.
16:38:51 <Rarrikins> > kthx [1..10] [1..3]
16:38:53 <lambdabot>  [1,1,2,2,3,3,4,5,6,7,8,9,10]
16:39:11 <Rarrikins> Ahh
16:39:12 <Rembane> Rarrikins: It doesn't have to be evil due to laziness, and if it is evil, maybe lists are the wrong datatype for the job.
16:39:17 <joelteon> so I'm trying to figure out whether list A is a subset of list B.
16:39:30 <joelteon> I feel like the most efficient I can make this algorithm is O(n^2)
16:39:36 <joelteon> is there a datastructure optimized for stuff like this?
16:39:40 <Rarrikins> joelteon: Sort both
16:39:48 <Rarrikins> joelteon: Should be O(n log n)
16:39:58 <joelteon> but how fast is sorting?
16:39:59 <Rarrikins> (assuming Ord)
16:40:06 <Rarrikins> It should be O(n log n)
16:40:23 <bennofs> Or use Sets
16:40:30 <joelteon> Sets can't have duplicate items
16:40:38 <enthropy> use Map key Int
16:40:42 <enthropy> for the number of copies
16:40:48 <joelteon> yeah, I thought of that too
16:40:51 <joelteon> I'll try that
16:41:00 <Rarrikins> Peat but if you're asking whether a list is a subset, sets are OK.
16:41:01 <dagano> why am i dumb?
16:41:05 <Rarrikins> Yeah*
16:41:09 <dagano> >map (read :: Int) "234234"
16:41:21 <enthropy> @hoogle differenceWith
16:41:21 <lambdabot> Data.IntMap.Strict differenceWith :: (a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
16:41:21 <lambdabot> Data.IntMap.Lazy differenceWith :: (a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a
16:41:21 <lambdabot> Data.Map.Lazy differenceWith :: Ord k => (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
16:41:22 <joelteon> Rarrikins: No, because then [1,1,2] would be counted as a subset of [1,2,3]
16:41:38 <dagano> > map (read :: Int) "234234"
16:41:39 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
16:41:39 <lambdabot>              with actual type `GHC.Base.String -> a0'Couldn't match expected ...
16:41:39 <lambdabot>              with actual type `GHC.Types.Int'
16:41:43 <Rarrikins> joelteon: You want to multisubset or something.
16:41:55 <bennofs> > map (read :: Char -> Int) "23456"
16:41:55 <lambdabot>  Couldn't match type `[GHC.Types.Char]' with `GHC.Types.Char'
16:41:56 <lambdabot>  Expected type: GHC.Types.Char -> GHC.Types.Int
16:41:56 <lambdabot>    Actual type: GHC.Base.String -> GHC.Types.Int
16:42:01 <joelteon> [1,1,2] `isSubSetOf` [1,1,2,3] == True
16:42:05 <Rarrikins> An easy way is just to sort and a simple check.
16:42:10 <joelteon> [1,1,2] `isSubsetOf` [1,2,3] == False
16:42:18 <joelteon> okay, I'll benchmark a couple different methods.
16:42:39 <joelteon> The lists are never going to be more than about 6 elements long, so the constant factor is probably worth it.
16:43:22 <bennofs> Benchmark for 6 element list? Is performace really that important here?
16:43:45 <joelteon> well, for 1 or 2 million different lists, maybe
16:43:46 <joelteon> or maybe not
16:43:53 <Rarrikins> > let isZomgOf xs ys = f (sort xs) (sort ys) where f [] _ = True; f _ [] = False; f xxs@(x:xs) (y:ys) = if x == y then f xs ys else f xxs ys in [1, 1, 2] `isZomgOf` [1, 3, 1, 2]
16:43:54 <lambdabot>  True
16:44:02 <Rarrikins> > let isZomgOf xs ys = f (sort xs) (sort ys) where f [] _ = True; f _ [] = False; f xxs@(x:xs) (y:ys) = if x == y then f xs ys else f xxs ys in [1, 1, 2] `isZomgOf` [1, 3, 2]
16:44:03 <lambdabot>  False
16:45:14 <kholdstare_> edwardk: posted the issue. Also, (incore $ incore _xy) can be used to get a slice of a 3D matrix... mind blown
16:45:24 <zomg> Rarrikins: interesting function
16:45:32 <edwardk> yep
16:45:32 <Rarrikins> zomg: Yeees
16:46:00 <pavonia> How do you specify and extra source file in an executable section in a Cabal file?
16:47:08 <Ribeiro> guys I'm making haskassone (a haskell version of the board game Carcassone), I've made it to here http://lpaste.net/97712 but ghci gives me error, a friend of mine told me that I had to change "processa", but I don't know how, help?
16:49:42 <dagano> ok i realize there many issues here but i am confused .. i'm trying to drop do notation for a while .. as exercise
16:49:44 <dagano> main = getLine >>= (\x -> read x :: Int)
16:49:58 <dagano> :t of getLine is IO String
16:49:58 <lambdabot> parse error on input `of'
16:50:15 <dagano> does the bind work with that lambda appropriately?
16:50:37 <dagano> i think i need a print $ or something
16:53:05 <dagano> getLine >>= (\x -> return $ (read x :: Int))
16:53:12 <dagano> sry for flood
16:56:49 <roboguy_> Ribeiro: what is getline doing?
16:57:20 <roboguy_> that could probably be massively simplified
16:57:52 <roboguy_> also what error are you getting?
16:58:02 <Ribeiro> roboguy : it was Cale that told me do to that function
16:58:34 <Ribeiro> roboguy : also, it's not an error, it should draw me the tyle, and it isn't doin its job xD
16:59:46 <aristid> :t readLn
16:59:47 <lambdabot> Read a => IO a
17:01:20 <AfC> Everyone seems to use Int64 as a size_t these days. Is there a reason Int64 and not Word64? It's not like you can have a negative number of bytes in an HTTP request etc
17:02:36 <nadirs> @type map ((read :: String -> Int) . (:[]))
17:02:37 <lambdabot> [Char] -> [Int]
17:02:45 <nadirs> > map ((read :: String -> Int) . (:[])) "23456"
17:02:45 <roboguy_> Clone in IDE never seems to work for me. it always seems to cut off the code
17:02:46 <lambdabot>  [2,3,4,5,6]
17:03:12 <hattmammerly> is learning regex again my best bet for parsing a string for a url?
17:03:53 <geekosaur> AfC: many C library functions sadly return -1 on error, otherwise a size. proper C implementations call that ssize_t but it's not reliably portable because it was only added to various standards later. so for portability you end up using Int64 at the C level, and then either you throw in gratuitous fromIntegral-s in Haskell or you propagate the type as is
17:03:59 <ij> hattmammerly, Probably, but it isn't really hard.
17:04:00 <roboguy_> Ribeiro: what is processa supposed to do?
17:04:31 <nadirs> hattmammerly: often when regex is mentioned along with Haskell, I hear Parsec is mentioned (I don't know what it is, though)
17:04:36 <geekosaur> although possibly it should be Int in that case
17:04:51 <ij> nadirs, It's a parser builder, I think.
17:04:53 <hattmammerly> ij: yeah, but I've learned 'enough' regex like four times and it never sticks
17:05:09 <ij> Hmm, that's weird. It stuck to me from the first time.
17:05:26 <enthropy> @hackage regex-applicative
17:05:26 <lambdabot> http://hackage.haskell.org/package/regex-applicative
17:05:37 <nadirs> hattmammerly: as long as it is not a recursive pattern, regexes should be fine, I think
17:05:38 <AfC> geekosaur: that's very helpful, thanks.
17:05:48 <geekosaur> I had no trouble learning it... but I'm really not the person to use as a benchmark here. I had no trouble with sendmail.cf either :p
17:05:51 <enthropy> that one is kind of nice
17:05:58 <hattmammerly> I'll use it to write like one match and then not use it for months
17:06:01 <Ribeiro> roboguy : processa is supposed to be the order for which the functions are executed. Like, gettilestlist is the last one in the code, so it's the first to be executed
17:06:17 <roboguy_> Ribeiro: one simplification I can think of is that all for all 'or' and all 'm', getline B or 1 m =  ". . . . ."
17:06:17 <ij> hattmammerly, Do you happen to 'live in the terminal'?
17:06:20 <roboguy_> (from what I can tell)
17:06:22 <geekosaur> or with m4. apparently I think like a state machine :p
17:06:46 <ij> They're fun.
17:07:01 <hattmammerly> ij: yeah, but I don't do complicated tasks often so I don't pick up standard tools like regex
17:07:14 <ij> I see.
17:07:19 <hattmammerly> more accurately, I live in firefox
17:07:30 <AfC> geekosaur: so a follow on question: I have sizes, mostly small, occasionally large, none more than a couple gig (but larger than 32-bit int from time to time). The notes at the bottom of Data.Word http://hackage.haskell.org/package/base-4.3.1.0/docs/Data-Word.html#g:2 says
17:07:35 <AfC> geekosaur: "Coercing word types to and from integer types preserves representation, not sign."
17:07:44 <AfC> (fair enought) when using fromIntegral
17:07:51 <AfC> geekosaur: my question is this: I'
17:07:59 <nadirs> hattmammerly: out of curiosity, what text editor do you use?
17:08:22 <hattmammerly> nadirs: vim
17:08:26 <AfC> geekosaur: my question is this: I'm using Data.Serialize.Put's putWord32le and putWord64le etc
17:08:28 <roboguy_> Ribeiro: I'm not sure I understand. A function can't have multiple lines in the way that the (commented-out) processa does
17:08:30 <AlainODea> regexes are more of a exploratory tool IMHO.  They are not good from the intent revealing code perspective
17:08:45 <AfC> geekosaur: do I have to do something special when switching from Int64 to the Word64 that those functions expect?
17:08:58 <geekosaur> I don't think so since those also preserve representation
17:09:18 <geekosaur> meaning, the bit patterns are the same even if the sign as used in computations is not
17:09:30 <nadirs> hattmammerly: don't you find yourself having to change patterns of text often? I learned regex the hard way because in vim they're a big help when editing
17:10:06 <AlainODea> nadirs: that is definitely true. Regexes and Vim are an amazing combo
17:10:12 <hattmammerly> nadirs: I don't work on large, complex projects. so I don't fully leverage the power of vim etc
17:10:30 <ij> notdan, Well, you can do a lot without regexes, but just vim macros.
17:10:41 <Ribeiro> roboguy : Imagine that we have two functions being "a" and "b" the first and the second function on the code. Processa represents the order of representation (shows the "b" in the first place and "a" in second. Sorry for my english too btw
17:11:07 <ij> Vim macros, apparently, are turing complete too.
17:11:30 <geekosaur> even old vi was turing complete
17:11:37 <meretrix> Why doesn't the following increment a TVar Int? "flip modifyTVar' (+ 1) >> readTVar"
17:12:23 <geekosaur> mind, that was also a good example of a turing tarpit...
17:12:47 <nadirs> hattmammerly: I don't know how much resources you might want to spend, but I can throw an advice, Jeffrey Freidl's Mastering regular expressions is a nice library addition :)
17:13:10 <roboguy_> Ribeiro: that's okay! I think what you want is something like "processa e = do { print (getScoreList e); print (length (getScoreList e)); print (getPlayerScore (getScoresList e)); ... }"
17:14:00 <roboguy_> instead of the commented out lines
17:14:17 <Ribeiro> roboguy : but should I let the printFile x dir cls = ... function?
17:16:00 <roboguy_> Ribeiro: what do you mean?
17:17:15 <Ribeiro> roboguy : i mean like, I just add that function, without taking the rest of the code?
17:19:10 <enthropy> meretrix: the >> is not using the instance Monad STM
17:19:17 <smith_> Is there a regex library that works natively on the Text type? Or is it better to just unpack to string before doing the search?
17:19:31 <roboguy_> Ribeiro: well, if you don't use it you don't need it, if that's what you mean
17:21:03 <meretrix> enthropy: Right, it's using the function monad.  I got it to work by looking at the pointless output, which uses the "ap" function. I'm just surprised it typed checked.
17:21:08 <Ribeiro> roboguy : I think I got it wrong, imagine this line "processa = getPlayerScore . getScoresList", processa executes first the "getScoresList" and then the "getPlayerScore"
17:21:53 <enthropy> so using the "function monad" is not the same as    liftM2 (>>) (flip modifyTVar' (+1)) readTVar
17:22:41 <meretrix> Ah yeah I guess I do see that.
17:23:07 <roboguy_> Ribeiro: yeah, that's right
17:24:49 <Ribeiro> roboguy : I want to change the code in order that when I run ghci, I can execute (in main) a file.xml so that it draws me a game tile (like the ones in the bottom of the code i gave you)
17:25:50 <Ribeiro> roboguy : instead of it, ghci is giving me something like _B_ (that's a tile name, and I want the draw of it)
17:27:58 <roboguy_> Ribeiro: one problem I see is on line 32, the capitalization is wrong: it is "counttilesByType" but it should be "countTilesByType"
17:28:18 <roboguy_> did you try using printTile in main?
17:28:34 <Ribeiro> roboguy : how's that?
17:33:10 <roboguy_> Ribeiro: well, first you need functions that take the result of parseXMLDoc and give you the stuff you need (Tile, Orientation and Meeple)
17:33:36 <roboguy_> then you can give those things to printTile
17:35:06 <codygman-> I saw people writing versions of an xkcd downloader, so figured I'd try to write my own. I'm using nested case statements on Maybe values and I'm pretty sure that isn't the best way to deal with them. Any help? Also any suggestions welcome :) http://lpaste.net/97715
17:38:50 <roboguy_> codygman-: I would separate some parts of the main function into different functions, then use the "maybe" function to deal with the Maybe values
17:39:12 <nadirs> codygman-: I'm not sure but maybe you could use "do" notation
17:39:25 <roboguy_> in the downloadComic function, that is
17:40:15 <nadirs> codygman-: or (>>=) (sugar-less alternative)
17:41:40 <jle`> he wants to keep track of the fail reason
17:41:59 <jle`> and he also has to perform IO actions
17:42:06 <codygman-> jle`: That's correct, I like knowing the fail reason ;)
17:42:09 <jle`> so if he wanted to use do or bind
17:42:15 <jle`> he'd need a MaybeT, or an ErrorT/EitherT
17:42:23 <jle`> to simplify the plumbing, that is
17:42:51 <jle`> i forgot which of ErrorT/EitherT is in vogue right now, i think it's the latter
17:43:13 <codygman-> Thanks all. Anyone recommend any introductions to monad transformers? I actually haven't read up on them or used them yet. The real world haskell chapter about them perhaps?
17:43:17 <pavonia> I use to use EitherT in these situation, which usually gives a nice linear structure
17:43:44 <jle`> codygman-: hmm let me look up the one that i remembered being the most useful to me
17:44:00 <jle`> here this was it http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
17:44:23 <enthropy> is there a hoogle option / variation to restrict yourself to functions that produce or require the argument?
17:45:30 <enthropy> for example I am looking for an easy way to construct a value with type DynFlags, but the module with the same name is full of functions that deconstruct one you already have
17:45:51 <codygman-> thanks jle`
17:46:07 <jle`> codygman-: but for your case it is a relatively simple wrapping/unwrapping
17:48:52 <stolaruk> I'm a complete Vim newbie but trying to learn for Haskell dev. I'm using "gvim" on Debian. I did "cabal install ghc-mod" but it doesn't seem to have done anything in gvim or vim. How do I activate the mode?
17:50:17 <jle`> stolaruk: have you installed the vim plugins for interfacing with ghc-mod?
17:50:18 <nadirs> stolaruk: ghc-mod is required by vim plugin "ghcmod.vim". Do you by any chance use Vundle?
17:50:52 <stolaruk> I didn't install any other plugins yet.
17:51:12 <stolaruk> nadirs: And I didn't use Vundle, don't know what that is.
17:51:14 <nadirs> stolaruk: the fact is that ghc-mod is not a vim plugin by itself
17:51:27 <stolaruk> nadi
17:51:30 <stolaruk> nadirs: I see
17:51:48 <nadirs> stolaruk_: Vundle is a (IMO) handy way to manage vim addons.
17:52:29 <stolaruk> nadirs: So I guess the first step is to get Vundle working?
17:52:42 <nadirs> stolaruk: not necessarily
17:53:05 <nadirs> you can get ghcmod plugin on vim without having to switch to Vundle
17:53:30 <stolaruk> should I have installed it from within vim?
17:53:48 <nadirs> stolaruk: I don't know deb packages so here is a straight link to the plugin https://github.com/eagletmt/ghcmod-vim
17:54:38 <nadirs> stolaruk: a crude way to install it is to copy it in your $HOME/.vim/ directory
17:55:02 <nadirs> stolaruk: do you use apt on debian?
17:55:56 <stolaruk> nadirs: yes
17:56:17 <stolaruk> I can use apt or a GUI install app
17:56:55 <nadirs> stolaruk: IIRC (from my memories of Ubuntu) you should be able to run "apt cache search ghc vim" or something like that, to see if the plugin comes already packaged for debian
17:57:21 <stolaruk> ok
17:57:24 <stolaruk> will try that
18:00:02 <geekosaur> apt-cache
18:00:13 <stolaruk> oh ok
18:00:49 <stolaruk> well it looks like cabal did install it for me, here: .cabal/lib/ghc-mod-3.1.4/ghc-7.4.1/Language/Haskell/GhcMod
18:01:33 <geekosaur> it built it at some point
18:01:53 <geekosaur> doesn't mean it's registered with your current ghc; use ghc-pkg list to check that
18:03:10 <stolaruk> "ghc-pkg list" does show "ghc-mod-3.1.4"
18:03:57 <stolaruk> There must be some way to tell gvim that I have this mode I want to use?
18:08:12 <jle`> codygman-: you still there?
18:08:23 <jle`> http://lpaste.net/97718 in case you wanted the quick refactoring
18:09:35 <jle`> btw i hope you are aware that you ignored x and hard-coded in 1 for the comic number
18:12:00 <lingxiao> could someone familiar with church numerals answer this question for me please: http://stackoverflow.com/questions/20830355/how-do-you-evaluate-exponentiation-of-church-numerals
18:12:57 <lingxiao> basically, I'm confused as about the def of the exponential function, expt ≡ λmnsz.nmsz
18:14:51 <jle`> codygman-: you can pull more into the either as well, http://lpaste.net/97718
18:15:08 <jle`> but you can use let statements if you want, for clarity
18:23:36 <augur> lingxiao: im familiar with church numerals but i wont answer that question
18:23:38 <augur> ill answer a better one
18:23:46 <augur> namely, wtf are church numerals doing, man
18:24:01 <augur> lingxiao: if you'll have such an explanation, anyway. :)
18:24:15 <augur> once you grok that, the specifics of the exponential function become boring hacking
18:25:03 <lingxiao> yeah totally haha. Actually as I learned more operations over church numerals, I get the nagging feeling that the way to understand them intuitively is to pop out of the formal system, and think more like a human being
18:25:23 <lingxiao> so yeah one way to is to know the answer to you question
18:26:04 <augur> lingxiao: ok, give me a moment to make some coffee, and ill blow your mind
18:26:42 <lingxiao> cant wait, this is why I love this channel. http://i1.kym-cdn.com/entries/icons/original/000/011/548/3059_135068129530.jpg
18:32:11 <codygman-> jle`: Thanks. Have been reading. Will look over the stuff you chatted.
18:32:47 <ellipsis_> how do I define the database schema in Persistent?
18:33:08 <ellipsis_> the tutorials all reference Database.Persist.TH, which doesn't exist in Persistent 1.3 as far as I can see
18:34:52 <srhb> ellipsis_: It's in persistent-template
18:35:12 <srhb> ellipsis_: Ie. it was split out (long ago?)
18:35:15 <ellipsis_> srhb: thanks
18:51:06 <lingxiao> augur: still there?
19:05:59 <tertl3> hello
19:06:19 <tertl3> any yesod/bsd users around?
19:06:47 <lingxiao> channel is a bit quiet tonight I'm afraid..
19:06:55 <lingxiao> and no I'm not
19:09:25 <td123> tertl3: ask a question and someone will answer if they can
19:10:13 <tertl3> ok
19:10:39 <tertl3> im trying to start a yesod server in my pcbsd vm
19:12:02 <tertl3>  hello I am having trouble with yesod in BSD
19:12:02 <tertl3> <tertl3> devel.hs:etc/ssl/serts/: getDirectoryCOntenets: does not exist(No such file or Dir
19:12:02 <tertl3> <tertl3> exit code: Exit Failure 1
19:12:02 <tertl3> <tertl3> just trying to run the sandbox server
19:12:18 <tertl3> sry for paste
19:19:00 <lick> can  I do arithmetics on Nat kind?
19:28:43 <zRecursive> tertl3: maybe #yesod can help you
19:29:11 <augur> oh man, sorry lingxiao
19:29:21 <lingxiao> no all good, I'm still alive!
19:29:22 <augur> i totally got distracted by linguistics :X
19:29:43 <lingxiao> lol, a worthy distraction
19:29:44 <augur> ok lingxiao, lets take a look at some data types
19:29:55 <augur> lets consider some very simple types
19:30:09 <augur> ill use standard haskell types where possible
19:30:18 <augur> ok so lets consider pairs:
19:30:24 <enthropy> lick: no... unless you are talking about doing arithmetic on values with type Nat, or on types with kind Nat
19:30:28 <augur> data (a,b) = (a,b)
19:30:46 <enthropy> promotion doesn't go any higher (for now)
19:30:46 <augur> the pair type has one constructor:  (,) :: a -> b -> (a,b)
19:31:00 <augur> if we now look at what a case statement for pairs are, it would look something like this:
19:31:01 <lick> enthropy: oh, thanks
19:31:14 <augur> casePair :: (a,b) -> (a -> b -> c) -> c
19:31:22 <lick> type instance (m <= n) => m </> n = n
19:31:26 <augur> casePair (x,y) f = f x y
19:31:39 <augur> lingxiao: that makes sense, right?
19:31:50 <lick> cause parse error at '=>'. why?
19:32:03 <lingxiao> yes
19:32:04 <augur> casePair p (\x y -> z)   is more or less the same as writing something like   case p of { (x,y) -> z }
19:32:47 <augur> lingxiao: ok, so if we look at what the case expression is doing for pairs, casePair p :: (a -> b -> c) -> c   for fixed a and b, but for any c
19:33:24 <augur> now if i ask you, lingxiao, how can you do something with a pair?
19:33:26 <enthropy> lick: you don't get to use => with a type instance
19:33:40 <augur> well, you case analyze it/pattern match it to get out its parts
19:34:00 <augur> that is to say, in a very real sense, anything you do with a pairs is defined in terms of casePair
19:34:29 <augur> or could be, if casePair was the primitive thing here (pretend it is!)
19:34:32 <stephenmac7> Quick question...
19:34:33 <augur> lingxiao: make sense?
19:34:40 <stephenmac7> If the type of State is defined as
19:34:44 <stephenmac7> newtype State s a = State { runState :: s -> (a,s) }
19:35:03 <lingxiao> yup, so it's the most fundamental function that deconstructs the data and do stuff with it
19:35:05 <stephenmac7> Then wouldn't states be a type of function?
19:35:07 <lingxiao> right? or no..
19:35:12 <augur> lingxiao: yeah. lets pretend that its fundamental.
19:35:22 <lingxiao> cool sweet
19:35:39 <augur> lingxiao: ok, so now, if everything we do with pairs is essentially _via_ casePair, what's the point of the pair constructor (,) at all?
19:35:42 <lick> enthropy: umm.. it's difficult.
19:35:48 <augur> lingxiao: why not simply define this:
19:36:07 <augur> data Pair a b = forall c. (a -> b -> c) -> c
19:36:13 <augur> mkPair :: a -> b -> Pair a b
19:36:26 <augur> mkPair x y = f x y
19:36:36 <augur> er sorry
19:36:42 <augur> mkPair x y = \f -> f x y
19:37:02 <augur> you'll notice that mkPair x y is _identical_ to casePair (x,y)
19:37:20 <enthropy> lick: you need to find/make a version of <= that is  type family a <= b :: Bool, and   type family Ifte (b :: Bool) x y
19:37:31 <augur> so we can define the pair as the very action that it's case analyzer would have when applied to the pair!
19:37:31 <enthropy> not sure the first one exists
19:37:37 <augur> lingxiao: does that make sense?
19:37:51 <augur> mkPair x y == casePair (x,y) == \f -> f x y
19:38:12 <enthropy> but if did, you could write   type instance m </> n = Ifte (m <= n) n ???
19:38:19 <enthropy> where ?? is whatever happens if m is larger
19:38:38 <enthropy> I think </> isn't a valid type family name
19:38:53 <lingxiao> yes it does
19:39:07 <augur> lingxiao: ok, so now lets look at sums (Either)
19:39:15 <lick> enthropy: (<=) is defined at GHC.TypeLits in base-4.7.0.0
19:39:18 <augur> data Either a b = Left a | Right b
19:39:32 <augur> caseEither :: Either a b -> (a -> c) -> (b -> c) -> c
19:39:40 <augur> caseEither (Left x) f g = f x
19:39:44 <augur> caseEither (Right y) f g = g y
19:40:32 <augur> again, you can sort of view it like this:   caseEither d (\x -> m) (\y -> n)   is like   case d of { Left x -> m ; Right y -> n }
19:40:32 <lick> enthropy: I tried `max` at first but it failed to compile
19:40:47 <augur> lingxiao: good?
19:40:52 <enthropy> oh there's a  type family (<=?) (a :: Nat) (b :: Nat) :: Bool
19:40:57 <enthropy> that's the right one to use
19:41:23 <augur> lingxiao: but we can then play this same game: why not just define Either directly in terms of its case behavior:   data Sum a b = forall c. (a -> b) -> (b -> c) -> c
19:41:26 <enthropy> which has an instance whether or not `a' is actually lt `b'
19:41:43 <enthropy> err, less than or equal to
19:41:44 <augur> left :: a -> Sum a b ; left x = \f g -> f x
19:41:45 <lingxiao> wait like data Either a b = forall c . (a -> c) -> (b -> c) -> c
19:41:54 <augur> yeah, but i dont want to reuse "Either"
19:41:58 <augur> so im calling it "Sum"
19:42:09 <augur> right :: b -> Sum a b ; right y = \f g -> g y
19:42:12 <lingxiao> oh I meant you used (a -> b) as the first function signature
19:42:21 <augur> oh sorry
19:42:31 <augur> yeah, a -> c
19:42:37 <lingxiao> yeah small detail, srry go on
19:42:45 <augur> so we can again define it in terms of its case behavior
19:43:09 <augur> so that   left x   ==   caseEither (Left x)   ==   \f g -> f x
19:43:16 <augur> and similarly for right
19:43:57 <enthropy> lick: there is no max. It would be Max... these lowercase type functions are an odd break from what used to be allowed
19:43:59 <augur> so this is pretty interesting: we dont need constructors, etc. to "really" exist, we can just define the constructors to be the function that we would have gotten by case analysis
19:44:23 <augur> lingxiao: and in fact it's pretty easy to define this translation in a mechanical fashion
19:44:39 <augur> lingxiao: but what about types like Nat:   data Nat = Zero | Suc Nat
19:44:52 <augur> well, now we have an actually interesting choice to make
19:45:12 <augur> if we continue to use the "encode as case" we get this:
19:45:29 <augur> caseNat :: Nat -> c -> (Nat -> c) -> c
19:45:34 <augur> caseNat Zero z s = z
19:45:40 <augur> caseNat (Suc n) z s = s n
19:45:50 <augur> or by encoding:
19:46:10 <augur> data FunnyNat = forall c. c -> (FunnyNat -> c) -> c
19:46:28 <augur> er, these should be newtypes of some sort, actually, but im lazy
19:46:37 <lick> enthropy: Max passed the parser :)
19:46:41 <augur> or they need constructors. im too lazy to write them, lingxiao :P
19:46:56 <augur> lingxiao: we would get this for the new "constructors":
19:47:02 <augur> zero = \z s -> s
19:47:13 <augur> suc n = \z s -> s n
19:47:25 <augur> lingxiao: make sense?
19:48:14 <lingxiao> wait how'd you go from FunnyNat to definition of new "constructors"
19:48:24 <augur> right so
19:48:28 <lick> I decide to write all possible patterns for Max:
19:48:33 <enthropy> so what is the use? We have data types instead of church encoding things to make things easier to understand
19:48:33 <lick> type instance Max 1 2 = 2; ....
19:48:56 <augur> you do the same thing as you do for pairs and eithers: the new constructors should be just the thing you'd get out from doing case on it
19:49:06 <augur> caseNat Zero == \z s -> s
19:49:06 <enthropy> lick: don't you have a <=? type family?
19:49:22 <augur> er, \z s -> z
19:49:23 <augur> so the funny constructor zero should just be \z s -> z
19:49:33 <augur> just like for either   caseEither (Left x) = \f g -> f x
19:49:45 <augur> so the funny constructor should be   left x = \f g -> f x
19:50:02 <lingxiao> ah ok right now I see
19:50:03 <enthropy> type family Max a b = Ifte (a <=? b) b a
19:50:17 <enthropy> with the Ifte cass defined above
19:50:24 <lick> enthropy: if I can do it, I want to use <=?
19:50:27 <augur> lingxiao: you're just sort of defining the new constructor as old-constructor-then-case
19:50:45 <augur> lingxiao: ok so, thats one option
19:50:57 <augur> its called the scott encoding
19:51:13 <augur> for non-recursive types like (,) and Either, the scott encoding and the church encoding happen to be identical
19:51:29 <augur> they both act identical to case analysis functions
19:51:37 <augur> but for recursive types, scott encoding and church encodings differ
19:51:46 <augur> for recursive types, scott encodings are STILL case analysis
19:52:13 <augur> but church encodings are recursion principles (ie folds)
19:52:23 <augur> lingxiao: so lets define foldNat instead of caseNat
19:52:29 <augur> using unencoded nats
19:52:36 <augur> foldNat :: Nat -> c -> (c -> c) -> c
19:52:40 <augur> foldNat Zero z s = z
19:52:50 <augur> foldNat (Suc n) z s = s (foldNat n z s)
19:53:24 <augur> ok, well, let's play the same trick as before with caseNat, only with foldNat:
19:53:39 <augur> FunnyNat = forall c. c -> (c -> c) -> c
19:53:47 <augur> zero = \z s -> z
19:53:58 <augur> suc n = \z s -> s ???
19:54:21 <augur> well before we would have written n in place of ??? but now we need to do a fold instead
19:54:39 <augur> but whats fold? well, the number itself is the fold, thats the point
19:54:45 <augur> so ??? = (n z s)
19:54:52 <augur> suc n = \z s -> s (n z s)
19:55:50 <lingxiao> woa man this is pretty mind blowing, and is introducing it from a very differnt angle from what I've read
19:55:56 <augur> :)
19:56:04 <augur> thats basically how all church encodings work
19:56:07 <augur> now think about bools, right
19:56:17 <augur> im sure you've seen this:   true = \x y -> x
19:56:19 <augur> false = \x y -> y
19:56:21 <augur> but why that?
19:56:25 <augur> well what's case on bool?
19:56:30 <augur> caseBool True x y = x
19:56:36 <augur> caseBool False x y = y
19:56:48 <augur> caseBool, aka if-then-else
19:57:26 <augur> you can scott/church encode everything this way, depending on whether you want to use primitive recursion combinators or use structural recursion
19:57:46 <augur> scott encoding = constructors are just applying case
19:57:55 <augur> church encoding = constructors are just applying folds
19:58:25 <augur> i put the orders differently than most folds, tho, but
19:58:56 <augur> for lists its _obviously_ foldy:   nil = \z f -> z   ;   cons x xs = \z f -> f x (xs z f)
19:59:50 <lingxiao> could you differentiate between primitive recursion combinators and structural recursion
20:00:03 <augur> structural recursion = folds
20:00:25 <augur> primitive = whatever else you have that does recursion (maybe Y, or maybe lazy self reference, or fix, or whatever)
20:01:10 <augur> you'll notice that these definitions let you write all your favorite recursive functions on, say, lists, but don't use any recursion combinators like Y or whatever
20:01:24 <augur> and they dont use laziness and self reference to get recursion either
20:04:17 <lingxiao> yeah man, you're right, there are no reference to the function... I guess since the data types themselves are now "living things"
20:04:26 <mm_freak> type Bool = forall r. r -> r -> r
20:04:55 <lingxiao> if that made any sense, living as in a computation..
20:05:07 <augur> lingxiao: yep, it's all air :)
20:05:37 <augur> in the SICP videos they do this for pairs at one point
20:05:58 <augur> the key here is that we're only looking at behavioral properties, not substantive properties
20:06:01 <mm_freak> incidentally church encoding is often the fastest encoding you can get =)
20:06:07 <lingxiao> ahh all roads lead to SICP, I was just going to ask what you read to figure this out
20:06:21 <augur> what we want, what we should know regardless of what implementation we have, is this:
20:07:12 <augur> casePair (makePair m n) (\x y -> z)   ==   z[m/x, n/y]
20:07:35 <augur> one way to implement that is directly: make `makePair` and `casePair` symbolic gadgets that just wrap things up
20:07:46 <augur> and then we define a beta reduction that does that substitution
20:07:51 <lick> introducing tons of language extensions...
20:07:59 <lick> I did it!
20:08:10 <augur> or something like that. the other option is to just code these things directly through functions
20:08:13 <augur> mm_freak: is it really?
20:08:54 <mm_freak> augur: yes…  it's basically CPS
20:09:20 <augur> mm_freak: i dont know how CPS compares, tbh
20:09:29 <mm_freak> type Pair a b = forall r. (a -> b -> r) -> r
20:09:30 <augur> so i dont know how efficient these things are
20:09:36 <augur> no no i know what the CPS coding is
20:09:44 <augur> i know that church = CPS
20:09:49 <lingxiao> yeah I was just going to say that, all this stuff looks really similar to CPS
20:09:52 <augur> i just mean saying it's CPS isn't enlightening :p
20:09:59 <augur> since i dont know how efficient CPS is
20:10:23 <adelbertc> looking for help on problem #26 on - http://www.haskell.org/haskellwiki/99_questions/21_to_28 , my first thought was to try something like applicative zip (e.g. (,,) <$> xs <*> ys) followed by a filter but dont think i can generalize that for arbitrary n
20:10:38 <augur> interestingly, CPS transforms are identical to how mainstream linguists handle quantification and other scopal objects
20:10:44 <mm_freak> augur: well, if you want to save four values for further processing you can either have an explicit memory representation (an ADT) or you can save the function that takes the processor as argument
20:11:03 <augur> also interestingly, CPS transforms and quantificational transforms both emerged at MIT around the same time
20:11:18 <mm_freak> combined with the graph-like evaluation of haskell programs this makes the passing about as direct as it can get
20:11:21 <adelbertc> (i know i can look at answers but id rather not ruin the fun :-) )
20:12:35 <mm_freak> adelbertc: start by writing the 'select' function
20:12:44 <mm_freak> select :: [a] -> [(a, [a])]
20:12:54 <adelbertc> :t select
20:12:55 <lambdabot> Not in scope: `select'
20:12:58 <lingxiao> augur: well man I gotta say I was not disappointed! :D
20:13:00 <adelbertc> hm what does it do
20:13:03 <augur> lingxiao: :)
20:13:07 <mm_freak> select "abc" = [('a', "bc"), ('b', "ac"), ('c', "ab")]
20:13:13 <adelbertc> ah
20:13:15 <augur> lingxiao: now go watch some lectures on type theory!
20:13:25 <augur> @where oplss2012
20:13:26 <lambdabot> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
20:13:32 <augur> pfenning and harper!
20:13:38 <lingxiao> lol yeah I'm working through types and programming languages
20:13:46 <lingxiao> so that's next!
20:13:46 <erisco> :t pick
20:13:47 <lambdabot> [d] -> [(d, [d])]
20:14:02 <augur> basically, lingxiao, elimination rules are recursion principles/folds
20:14:07 <mm_freak> where is 'pick' defined?
20:14:12 <mm_freak> > pick "abc"
20:14:14 <lambdabot>  [('a',"bc"),('b',"ac"),('c',"ab")]
20:14:18 <erisco> mm_freak, someone wrote it earlier today
20:14:21 <mm_freak> ah
20:14:31 <augur> lingxiao: the beta reduction rules/proof normalization rules are the computation rules that step your folds along one tick
20:15:23 <lingxiao> see the way you're using folds is interesting, I always thought folds were catamorphism
20:15:39 <augur> they are!
20:15:46 <lingxiao> but it seems like .. you're using fold as some function that builds a function ... that represnts data
20:15:46 <augur> elim rules are folds are catamorphisms!
20:16:04 <lingxiao> ahh ok misread your sentence haha
20:16:25 <augur> church encodings are just a way of avoiding ever having to actually have representations of data, because the only way to actually use data is via its case/fold anyway
20:16:47 <augur> so why both representing, why not just define the data _as_ the case/fold that you're ultimately going to use?
20:17:42 <lingxiao> ahhhh ok that really made explict what you were demonstrating
20:17:47 <lingxiao> wow...that's really cool
20:17:54 <lingxiao> and pure..
20:18:17 <augur> pure, but also highly dependent on polymorphism
20:18:20 <augur> so thats the thing right
20:18:35 <augur> once you have polymorphism, you automatically have a huge number of types built in
20:18:37 <augur> i mean
20:18:45 <augur> by way of church encodings
20:19:20 <augur> all you need is -> and polymorphism, and you have a whole world of types -- pairs, sums, unit, void, numbers, lists, trees, ...
20:19:46 <augur> but at the same time, it's a particular sort of pair, a particular sort of sum, etc etc
20:19:53 <mtahmed> What does "=<<" say? Does it have to do with monadic funciton composition or something?
20:19:56 <augur> that depends wholly on your notion of function
20:20:08 <augur> mtahmed: =<< is kind of like monadic function application
20:20:12 <augur> :t (=<<)
20:20:13 <lambdabot> Monad m => (a -> m b) -> m a -> m b
20:20:21 <augur> :t ($)
20:20:22 <lambdabot> (a -> b) -> a -> b
20:20:31 <lingxiao> what are some notions of functions?
20:20:53 <mtahmed> augur: Couldn't find any resource online for it. Anywhere I can read up on this and similar stuff?
20:21:00 <augur> lingxiao: well, there are a variety different kinds of functions
20:21:11 <augur> aww
20:21:18 <augur> mtahmed: oh dear, you need to learn about monads to grok that
20:21:20 <augur> lingxiao: well, there are a variety different kinds of functions
20:21:28 <augur> depending on your type theory
20:21:36 <augur> im only just earning about their precise distinctions
20:21:50 <augur> but certainly, classical vs intuitionistic -> arent the same
20:22:01 <lingxiao> yeah..ah I guess now I'm reaching into something I'm only remotely aware of
20:22:09 <augur> and linear implication (-o) isnt the same as -> tho you can encoding -> using -o
20:22:48 <augur> type theory is a big complex thing, with all sorts of fun notions here and there
20:23:03 <lingxiao> yeah man, can I ask what you read?
20:23:05 <mtahmed> augur: Could you briefly explain what's happening here: "main = xmonad =<< statusBar myBar myPP toggleStrutsKey myConfig"?
20:23:08 <augur> and im not sure that its entirely correct to say that church encodings _just are_ equivalent, it might depend highly on other things
20:23:10 <mtahmed> This is from xmonad config file.
20:23:21 <augur> for instance, church encodings are capable of representing only positive types, i think
20:23:31 <augur> i dont think codata types are easily represented as church encodings
20:23:40 <augur> but they're probably still representable, just differently
20:23:45 <augur> mtahmed: oh dear, no
20:24:03 <augur> lingxiao: i watched the videos i pointed you towards
20:24:09 <mtahmed> haha. No as in cannot explain briefly? :p
20:24:10 <augur> and i also read a bunch of pfenning's notes on his site
20:24:18 <mtahmed> Or just can't explain at all?
20:24:23 <augur> mtahmed: no as in not briefly, and possibly not at all
20:24:45 <lingxiao> wait sorry could you send them again? I scrolled up but can't seem to find it?
20:24:45 <AfC> Is there deriving Generics support for creating QuickCheck Arbitrary instances?
20:24:50 <augur> lingxiao: sure
20:24:54 <augur> @where oplss2012
20:24:55 <lambdabot> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
20:25:01 <augur> pfenning and harper's lectures
20:25:14 <lingxiao> ahh ok got it thanks!
20:26:37 <lingxiao> and found pfenning' site, thanks a bunch for this! this channel is a gold mine
20:27:19 <augur> lingxiao: on pfenning's site, look for the constructive logic classes
20:27:29 <augur> both of them are good, tho i think the more recent one has a cleaner presentation
20:27:38 <augur> also, i wrote a tutorial on curry-howard that you might be interestedin
20:28:37 <lingxiao> yup link? I tried reading about it many times, but never really interalized it whole
20:29:09 <augur> http://purelytheoretical.com/papers/ATCHC.pdf
20:30:31 <lingxiao> well thank you Mr. McAdams, I'll give it a thorough read, and hound you with questions if I have any
20:30:48 <danilo2> hello! Does anybody have an example of Parsec with source postion tracking? I want to wirte something like "lexer", but getting tokens bundled with positon infomration
20:32:06 <lingxiao> have a good night everyone!
20:32:18 <pavonia> Is there a way to construct "on" for an arbitrary number of arguments, e.g. with use of Applicative or so?
20:32:33 <Fylwind> @pl m k = f k . t
20:32:34 <lambdabot> m = (. t) . f
20:34:35 <Fylwind> @pl m k j = f k j . t
20:34:35 <lambdabot> m = flip flip t . ((.) .) . f
20:39:19 <enthropy> danilo2: it doesn't by default?
20:41:01 <enthropy> after all parsec has a state which contains a data SourcePos = SourcePos SourceName !Line !Column
20:41:37 <danilo2> enthropy: Hmm, I can use "getPosition" or something like that to optain current positon, but I'm looking for a nice way to get for example tuples (pos, tok) out of my "lexer". When I'm writing a parsing rule, like "pIdent = many1 (anyChar)" I get string as a result, withoiut position information
20:42:37 <enthropy> yes
20:43:04 <dmwit> Wouldn't you want a token and a position range or something?
20:43:15 <danilo2> enthropy: I can of course write a function "packIntoPos :: String -> (Pos, String)" and use it in **every** token parser, but I'm searching if there is a better way
20:43:17 <dmwit> Anyway, surely you can code it up given that you have getPosition and Monad available.
20:44:50 <enthropy> a better way might be to have a data type that isn't as intrusive as (Pos,String)
20:44:58 <danilo2> dmwit: I know the token length, so I want also to keep it start position. I know I can make it manually (see 2 lines above), but I was thinking, maybe there are some ready functions in Parsec to do it. I have seen some topics about "parsec tokens", but it doesnt seem to be what I was thinking it is
20:45:00 <enthropy> say  data L a = L Pos a
20:45:36 <enthropy> pretty printing exactly the source you get can be a requirement sometimes
20:46:10 <danilo2> enthropy: Of course, I'll do it like that. But I understand, there is not better way than making function "packIntoPos" and using it in every combinator, which should return L ?
20:47:28 <enthropy> dunno, maybe you can make the call to packIntoPos not so obvious
20:48:06 <enthropy> such as by writing module BoringBoring where anyChar = packIntoPos Parsec.anyChar
20:50:06 <danilo2> enthropy, dmwit: Ok, thank you. Could you tell me also (if you now it), tokenPrim (what http://hackage.haskell.org/package/parsec-3.1.4/docs/Text-Parsec-Prim.html) function could be used for? Is it not useful for building "token parsers" like I want to do ?
20:52:09 <danilo2>  enthropy, dmwit: Or even better the "token" function (from the same page of documentation). There is such sentence: "For example, suppose that we have a stream of basic tokens tupled with source positions" - but I havent found any way how to use this function
20:54:00 <dmwit> tokenPrim and token are the basic combinators that all the other ones are written in terms of.
20:54:41 <dmwit> You tell it how to match on a token, how to update the position, and how to report errors, and it becomes a parser for that token.
20:54:41 <dmwit> Nothing more to it, really.
20:56:03 <danilo2> dmwit: Hmm ok, so it is not useful for what I wnat to do - I imagine it is useful for binding parsec to alex or any other token parser, isnt it? Anyway I'll do it the way I was talking before, thank you :)
20:57:15 <danilo2> enthropy: By the way, I promised to tell you about the error I was getting when using Context in TemplateHaskell. (The Context has got GHC.Prim.* inside, which caused error when I was trying to use it to generate a function) - it seems to be a bug in GHC
20:57:38 <enthropy> ok
20:57:52 <danilo2> enthropy: And it does not appear If I disable PolyKinds in the file, where the type class I was reifying is
20:58:39 <xrl_> anyone had luck making a cross build toolchain for darwin 64bit x86 -> linux 32bit ARMv6?
20:58:50 <xrl_> more specifically, mavericks to raspberry pi
20:59:04 <maybefbi> how do I yield to 2 different conduits from a source?
20:59:21 <xrl_> I'm trying to use crosstool-ng and it's breaking 1/3 of the way through
21:00:58 <lick> enthropy: I could write very cool and practical code, thanks!
21:02:45 <ellipsis_> I'm trying to figure out Persistent and I keep getting the error "Multiple declarations of ItemId" and this is the only thing in the file: http://lpaste.net/97721
21:02:58 <ellipsis_> it says the two declarations are on Model.hs:20:1 and Model.hs:20:1
21:16:59 <lick> xrl_: good luck :) and a tip: 'foreign export "dynamic" ...' will crash on ARMv5. try passing --ghc-options="-optlc-mcpu=arm9" when you use cross-cabal
21:18:32 <xrl_> lick: noted!
21:21:20 <roboguy_> pavonia: I don't think so. why?
21:23:23 <pavonia> it would be nice
21:25:49 <roboguy_> pavonia: the Applicative instance of the function type is for passing the same input to several functions, essentially, not about passing different inputs to the same function
21:26:22 <pavonia> Yes, I know, hence the "or so"
21:26:41 <pavonia> I mean some similar construction scheme
21:27:49 <AfC> When using QuickCheck, what's the way to have it converge (?) on the cases that narrowly demonstrate working and broken values?
21:27:59 <AfC> [`shrink`-something?]
21:28:25 <AfC> I saw someone demonstrate that at a conference, and I was "of course I'll remember how to do that"
21:34:05 <kholdstare_> AfC: When running quickcheck, it will automatically do that for you on a failing test case
21:40:26 <roboguy_> pavonia: the only thing I can think of would be some kind of type class thing, similar to how printf works
21:43:18 <gamegoblin> What is the general practice for having cost centres in source code? Just leave them there littered about or...?
21:52:05 <Cale> gamegoblin: I tend to insert them only when I'm trying to determine which part of some definition is causing the performance problem, and then I'll remove them again
21:53:12 <gamegoblin> I have a system with maybe 200 functions or so (in a lib). I wish I could just see how much time is spent inside each function without having to pepper the lib...
21:54:17 <gamegoblin> I could always sed and replace "{{ function }} =" with "{{ function }} = {-# function #-}"... but ew...
21:55:35 <roboguy_> gamegoblin: I think there's a ghc option to add scc to everything
21:55:46 <gamegoblin> Oh really? I'll look into it
21:56:14 <roboguy_> gamegoblin: I think it's -auto and -auto-all
21:56:28 <roboguy_> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/prof-compiler-options.html
21:58:19 <Cale> Right, that's why I don't bother with leaving cost centres in, because there will typically only ever be a couple of them annotating particular subexpressions (since everything else will be from -auto-all)
22:00:55 <gamegoblin> Can I auto-all a library I am using?
22:01:06 <gamegoblin> (a library that I wrote, so I have all the code etc)
22:01:57 <gamegoblin> also, found out my shuffling code was the bottleneck (sort based nlgn algo for simplicity), so I switched to a linear time algo and execution time is now 1/3. Wooo.
22:25:14 <Gorroth> taking my first steps in haskell :)
22:25:28 <nstdloop> Enjoy. It's a fun journey.
22:25:30 <Gorroth> seems pretty easy thus far, but i'm only doing the basics
22:25:35 <Gorroth> yeah
22:25:49 <Gorroth> hopefully i can start using it with yesod soon so i can replace my django stuff
22:26:27 <nstdloop> Did you install the haskell platform?
22:27:50 <maxs_> what is uncurry for N tuples called?
22:30:53 <nstdloop> maxs_: you need to define a different function for each size of tuple/arg count because of types
22:31:14 <expwnent> I'm trying to cabal repl in a sandboxed directory. When I run it, I can't access any of the functions I wrote except for main. (When I call :t myFunc, it says "Not in scope: `myFunc'".) Do I have to do something magic with my project.cabal file to allow useful debugging? My project builds an executable, but not a library.
22:31:19 <maxs_> but these functions already exist in base right?...
22:31:33 <zRecursive> :t curry
22:31:34 <lambdabot> ((a, b) -> c) -> a -> b -> c
22:31:40 <zRecursive> :t uncurry
22:31:41 <lambdabot> (a -> b -> c) -> (a, b) -> c
22:31:47 <nstdloop> maxs_: hoogle only gives me the one uncurry
22:31:49 <nstdloop> and the one curry
22:32:16 <nstdloop> You want something like zip3/zip4 etc. right?
22:33:09 <nstdloop> expwnent: you are probably loading the file compiled instead of interpreted, so internal bindings are not visible.
22:33:45 <expwnent> maxs_: http://hackage.haskell.org/package/tuple might be what you're looking for. Even if it isn't, it should give you some ideas of how to work around the issue.
22:34:07 <maxs_> nstdloop: yeah
22:34:15 <maxs_> yeah i might look at that
22:34:21 <nstdloop> Looks like what you want
22:35:00 <nstdloop> Worst case they aren't hard to write. uncurry3 f x y z = \(x, y, z) -> f x y z etc.
22:35:01 <expwnent> nstdloop: That makes sense, but I'm not sure how to fix it. I could change my cabal file to build a library in addition to the executable, but it seems excessive and I'd like to learn the "proper" way of doing it.
22:35:36 <expwnent> maxs_: could also be a good excuse to learn template haskell.
22:37:13 <nstdloop> expwnent: I'm really not sure, to be honest. If you need to debug internal pieces, maybe ghci is your best bet?
22:37:36 <nstdloop> If you want the "proper" way I probably can't tell you.
22:37:53 <expwnent> nstdloop: the weirdest thing is that when I do cabal clean && cabal repl then it works fine.
22:38:01 <nstdloop> hmm
22:38:14 <nstdloop> does it compile the file during cabal repl?
22:38:24 <expwnent> I mean, I guess that's good enough but theoretically if I had a huge project that took forever to compile that'd be a bad solution.
22:38:42 <expwnent> [1 of 1] Compiling Main ( File.hs, interpreted )
22:38:45 <nstdloop> because it's possible that when you clean the compiled executable and then launch the repl it loads it interpreted instead of compiled
22:38:47 <nstdloop> ya
22:38:49 <nstdloop> there you go
22:38:54 <nstdloop>  File.hs, *interpreted*
22:39:10 <nstdloop> if you compile then cabal repl what happens
22:39:57 <expwnent> Loading package blah blah blah\nOk, modules loaded: Main.
22:40:22 <nstdloop> Which means its compiled.
22:40:57 <expwnent> It seems like it ought to be able to interpret a file even if it's compiled though, just by ignoring the compiled version.
22:41:13 <nstdloop> Definitely. In ghci you can just load it with a * and it loads it interpreted
22:41:42 <nstdloop> but I don't know enough about cabal repl to know how to do it there
22:43:20 <zRecursive> Would `ghc -ignore-dot-ghci -e "funcN ..." ~/tool/Foo.hs` be faster when compiling Foo.hs first ?
22:45:59 <nstdloop> Why are you using -ignore-dot-ghci in ghc?
22:47:44 <zRecursive> nstdloop: Because i want ghc faster enough
22:48:19 <inavat> Hello.  I'm getting "multiple declarations of removeMults".  I thought polymorphism would allow this:  http://lpaste.net/97727
22:48:37 <roboguy_> inavat: that's not how polymorphism in Haskell works
22:52:05 <roboguy_> inavat: in Haskell, there are two main types of polymorphism: parametric polymorphism and ad-hoc polymorphism
22:54:43 <smith_> Hey -- I'm trying to use aeson's Generics support to generate an instance, but I'm getting back "No instance for (FromJSON (Map Text Text))": http://lpaste.net/97728
22:54:55 <roboguy_> parametric polymorphism is where the a function has a type that has type variables in it (which can represent any type, as long as they are consistent across the type application), like sort :: [a] -> [a]
22:55:23 <roboguy_> ad-hoc polymorphism is a sort of multiple dispatch thing, which is closer to what you are trying to do. This is done with type classes
22:56:14 <smith_> The docs for aeson list "FromJSON v => FromJSON (Map Text v)" as an instance for FromJSON, so the instance should exist...
22:56:41 <jmcarthur> inavat: you are confusing "polymorphism" with "overloading"
22:57:14 <jmcarthur> inavat: haskell doesn't have this kind of overloading. type classes are probably the closest you're going to get
22:57:35 <roboguy_> jmcarthur: well, overloading is a kind of polymorphism, but "polymorphism" is the more general concept
22:57:53 <inavat> okay thanks roboguy_  and jmcarthur.  I'll look into type classes
22:58:40 <roboguy_> inavat: one thing worth pointing out is that type classes are overused and misused a lot. Even though it will probably accomplish what you're looking for, it is probably not a good example of a type class
22:59:42 <inavat> in a case like this would you just give the two functions different names?
23:00:03 <roboguy_> generally speaking, a type class when defining a very general concept where all instances must obey certain laws
23:00:04 <roboguy_> inavat: yeah
23:00:24 <roboguy_> better examples of type classes include Monoid, Functor, Applicative and Monad
23:01:44 <roboguy_> (listed roughly in order of complexity)
23:02:47 * hackagebot unscramble 1.0 - Solve Boggle-like word games  http://hackage.haskell.org/package/unscramble-1.0 (JoelTaylor)
23:04:46 <smith_> Narrowing it down a bit, I get the same error without Generics involved: http://lpaste.net/97729
23:06:22 <smith_> The instance is exported from Data.Aeson, but for some reason GHC isn't finding it.
23:07:33 <roboguy_> smith_: what version of aeson do you have?
23:07:48 * hackagebot picosat 0.1.0.1 - Bindings to the PicoSAT solver  http://hackage.haskell.org/package/picosat-0.1.0.1 (sdiehl)
23:07:59 <smith_> roboguy_: aeson-0.6.2.1
23:08:20 <roboguy_> smith_: hmm, that's strange. it works for me
23:08:39 <smith_> roboguy_: Huh, that's weird.
23:08:46 <roboguy_> does it list that instance when you go into ghci and type ":i FromJSON"
23:08:50 <smith_> roboguy_: Containers is 0.5.3.1; could it be that that isn't matching up?
23:08:52 <smith_> Lemme check...
23:09:26 <smith_> roboguy_: Nope, it doesn't.
23:09:53 <smith_> http://lpaste.net/97730
23:10:24 <scottj> with emacs+flycheck, how do I get ghc to see modules that I install with cabal?
23:11:24 <roboguy_> smith_: maybe it would help if you uninstalled/reinstalled aeson and maybe containers?
23:12:01 <smith_> roboguy_: Sure, I'll try that.
23:12:19 <roboguy_> scottj: it didn't automatically?
23:14:23 <scottj> roboguy_: it did for haskellnet but not for aeson
23:15:01 <roboguy_> scottj: did you restart emacs/flycheck since you installed it?
23:15:24 <scottj> roboguy_: yeah. for haskellnet all I had to do was close and reopen the buffer.
23:16:33 <scottj> roboguy_: actually I think this is non emacs related, sorry.
23:17:49 <scottj> when I run cabal install aeson it says aeson is installed. but running ghci import Data.Aeson says it can't find it. I just installed HaskellNet with cabal though and importing it worked fine. Ideas?
23:19:20 <roboguy_> scottj: hmm, maybe uninstalling/reinstalling would work as well
23:22:21 <scottj> roboguy_: hmm, reinstalling worked, thanks
23:28:53 <SrPx> What is a good compiler target for a functional programming language similar to LC? (Actually mostly just LC...)? :/
23:29:22 <SrPx> (as it seems like the humanity didn't think creating a good ULC compiler was priority)
23:29:40 <SrPx> oh but justin bieber, yea, millions for him
23:30:00 <SrPx> he will sing us a cure for cancer
23:30:15 <Cale> What do you mean?
23:31:10 <SrPx> I want a fast compiler for untyped lambda calculus, couldn't find any, now I just want a fast compiler for any minimalistic functional language, so I can just compile a version of lambda calculus to it and be happy
23:31:55 <Cale> What would a compiler for untyped lambda calculus produce? Untyped lambda terms don't specify any kind of I/O
23:32:02 <Cale> They just... are
23:33:48 <Cale> Unless you're going to then use the compiled things as functions of some sort in your target language
23:34:17 <SrPx> Exactly, I don't want IO. I want it to produce functions that receive ints or arrays and return such. so (λx.succ x) could be translated to (int x(int a){return a+1}), for example.
23:34:42 <Cale> wait, what?
23:34:47 <Cale> What's succ?
23:35:28 <SrPx> Cale: successor (x + 1)
23:35:33 <Cale> (\n. (\s. (\z. s (n s z))))?
23:35:51 <SrPx> Cale: which is λnfx.f (n f x)
23:35:55 <SrPx> yes
23:36:22 <Cale> How is the compiler supposed to magically involve int?
23:36:25 <SrPx> so, you'll probably ask, how, if LC doesn't have arrays nor numbers. and the answer is, I don't know
23:36:32 <SrPx> see , you just asked it.
23:36:53 <mm_freak> SrPx: you can always compile to haskell, but using a DSL with a parser would probably work better
23:37:09 <SrPx> but I guess you could augment LC with ints/arrays somehow, or it could simply identify church numbers and such and interpret them as numbers.
23:37:58 <roboguy_> SrPx: how do you identify church numbers?
23:38:01 <SrPx> some meaning would be lost after compilation, obviously... only terms that reduced to terms with no high-order functions and no absurds such as applying a number to a function would work.
23:38:22 <Cale> You could probably compile untyped lambda calculus terms to Haskell terms which involve  newtype Rec a = In { out :: Rec a -> a }  somehow
23:38:41 <Cale> and they'd end up being polymorphic functions
23:38:47 <SrPx> roboguy_: I don't know - are you sure it is not possible? I was doing so synthetically and it was going ok (I just replace (λf.λx.(f f f x)) by (num 3), for example
23:39:18 <mm_freak> SrPx: ask yourself to where you want to compile, i.e. how you want to use the result
23:39:21 <SrPx> Cale: hm that seems like an interesting idea actually
23:39:44 <mm_freak> if you want to use the result from a haskell program, for example, it doesn't really make sense to produce native code…  you would just write a haskell interpreter
23:40:38 <mm_freak> lambda calculus is easy enough to express as an ADT by using the 'bound' package
23:41:00 <SrPx> mm_freak: I would like it to compile to simple C/js functions that received and returned vectors and integers
23:41:19 <Cale> There's bound and then there's unbound :)
23:41:21 <roboguy_> hmm, I wonder what it would be like to make something that compiles lambda calculus into machine instructions
23:41:42 <mm_freak> SrPx: compiling lambda calculus to efficient C/JS is very complicated
23:41:50 <mm_freak> and it's probably not worth the effort
23:42:11 <SrPx> the problem with targeting Haskell is that there is no simple compiler from it to javascript, for example. That is why I thought: "there should be a simple optimizing compiler for a functional language to imperative-style intermediate language, that anyone could easily write a backend to any common language today"
23:42:16 <Cale> It's questionable whether compiling lambda calculus to C even makes sense?
23:42:27 <Cale> Compiling lambda calculus to Javascript could be done
23:42:36 <mm_freak> SrPx: why LC anyway?
23:43:00 <SrPx> mm_freak: Cale because ULC is the language I'm most productive in...
23:43:01 <Cale> In fact, it would be a purely syntactic transformation
23:44:14 <mm_freak> SrPx: in that case my suggestion is to learn to become productive in another language =)
23:44:33 <SrPx> mm_freak: that is not a good suggestion as I've tried them all already
23:44:57 <Cale> [[(\x. y)]] = (function(x) { return [[y]]; })
23:45:15 <Cale> [[f x]] = [[f]]([[x]])
23:45:20 <mm_freak> SrPx: how can you know that?  you're still looking for a way to compile LC
23:45:36 <roboguy_> SrPx: wait, when you say ULC, you mean a language with nothing other than lambda abstractions?
23:45:45 <Cale> [[v]] = v
23:45:50 <foobar_> how do I do something similar to "group by"(sql) in yesod
23:45:58 <Cale> There, I wrote you an untyped lambda calculus to javascript compiler
23:46:29 <roboguy_> SrPx: in which case, I can't imagine anyone would be more productive in that than even an assembly language
23:46:51 <mm_freak> you can also compile LC to SK calculus, predefine S, K and some auxiliary combinators in JS
23:47:14 <SrPx> yes, ULC is awesome
23:47:26 <SrPx> humanity doesn't understand it, it is the most high level language available :/
23:47:39 <mm_freak> but i have a feeling that you may find out that you're more productive in SK than in LC, when you learn to do that =P
23:47:44 <Cale> SrPx: What do you mean humanity doesn't understand it?
23:47:49 <haasn> you could compile down to some STG-like language (even lower than Core?) and compile that to imperative languages reasonably straightforwardly
23:47:51 <roboguy_> SrPx: how is it high level?
23:47:57 <SrPx> wait a sec
23:48:01 <haasn> it's more or less involved depending on whether you want to make it more or less efficient
23:48:07 <Cale> It's one of the most well-studied formalisms in existence :P
23:48:10 <mm_freak> haasn: STG compilation is complicated though
23:48:19 <haasn> mm_freak: you mean getting to STG?
23:48:31 <mm_freak> both getting to it and compiling it
23:48:53 <mm_freak> although getting to it is slightly harder
23:49:21 <SrPx> roboguy_: it is absolutely high level. Humanity does not understand it because humanity is programming the wrong way. The key is that it is so simple and it is so easy to abstract complexity away with it. I've wrote an editor for it and I've never been so productive
23:49:50 <haasn> I guess compilation of any sort of is difficult depending on how low the target language you're compiling to, is
23:49:56 <SrPx> on this editor you use keys to effect your code and you use code to code your code, so you affect whole ranges of code by using code at a single blow, no text involved
23:50:24 <haasn> I played around with going to C#, which was mainly syntax transformations and leveraging the power of the C# compiler/language to lift anonymous declarations to the top level etc.
23:50:37 <Cale> SrPx: Is this editor available for download?
23:50:39 <SrPx> I've managed to make a pretty fast compiler myself but I wanted to make it better. I'm so upset I can't find a good target functional language
23:50:49 <roboguy_> SrPx: I don't want to be too rude here, but I have serious problems believing that that would be productive. also, I would say that it is incredibly low level, since it has only one form of abstraction. to me, high level implies a high level abstraction
23:50:54 <SrPx> Cale: it is online but not completed, I'll be posting it in the next weeks
23:51:12 <roboguy_> did you extend it with definition?
23:52:13 <Cale> SrPx: What did you write the compiler in? :)
23:52:15 <mm_freak> SrPx: now i'm really interested…  can you point me to some open source program you have written using pure LC?
23:52:44 <roboguy_> I am pretty curious about that editor though...
23:52:50 <haasn> How would you write, say, a program that reads ‘n’ from the command line parameter and outputs, say, the n'th fibonacci number? :)
23:53:11 <haasn> Do you define numbers from scratch?
23:53:21 <roboguy_> I personally see lambda calculus as the assembly language of functional programming
23:53:22 <mm_freak> you have to in LC
23:53:36 <mm_freak> roboguy_: i don't see it as the assembly language of functional programming
23:53:37 <SrPx> I'll be posting it soon and I'm absolutely positive many of you guys will like it, but now I'd really need your help with the compiler part. If I get that done I could be able to make it public in no time, with some great examples of real-world program running live etc
23:53:42 <mm_freak> i see it as the theoretical model for FP
23:53:46 <haasn> roboguy_: as much as the turing machine is the assembly language of imperative programming?
23:53:52 <mm_freak> or rather /a/ theoretical model
23:54:24 <SrPx> But I've been stuck so long already trying to fix the performance, I've implemented a great compiler myself and it is already kinda fast, but it is not ok. I don't like what I did, because I mixed things like arrays and numbers in the language specs. I honestly don't know what I'm doing there
23:54:25 <roboguy_> well, maybe that would be a bad comparison. I just meant in the sense that it is, I would say, pretty low-level
23:54:45 <mm_freak> roboguy_: it isn't really on any level…  it's a model
23:55:13 <mm_freak> SrPx: for fast LC compilation you should read the STG paper
23:55:15 <haasn> SrPx: so you're extending the language specification with real-world oriented things like numbers, arrays and presumably I/O?
23:55:27 <mm_freak> SrPx: STG = spineless tagless G-machine
23:55:29 <haasn> also subsequent papers by SPJ
23:55:33 <roboguy_> mm_freak: it can't be both? couldn't assembly language be seen as a model as well since it pretty much corresponds 1-to-1 to actual machine instructions?
23:55:37 <SrPx> not IO, I don't like IO, the language is completely pure :/
23:55:47 <SrPx> mm_freak: ok?
23:55:53 <SrPx> marking
23:55:55 <mm_freak> SrPx: you could also compile to lazy k and use existing compilers for that one
23:56:00 <mm_freak> or make a lazy k compiler
23:56:39 <haasn> roboguy_: all languages are models for computation; the question is their mathematical simplicity and minimalism
23:56:43 <mm_freak> roboguy_: the model for imperative programming is the turing machine (in my view)…  i don't see any machine with infinite memory and no overheating exceptions coming =)
23:56:52 <haasn> there's no question that the LC is pretty minimal (also SK)
23:57:15 <haasn> the more minimal it is, the easier they're to reason with (sometimes. at other times, they can be much harder to reason with)
23:57:36 <mm_freak> in a sense SK is even lower level, because you can go from LC to SK easily, but there is no unique inverse
23:57:40 <roboguy_> mm_freak: but that, to me, implies that an unbounded turing machine is a bad model for real computers actually...
23:58:01 <haasn> mm_freak: the transformation is not unique in either direction is it?
23:58:13 <mm_freak> roboguy_: not quite…  a turing machine can never /use/ infinite memory
23:58:18 <Cale> Ping me if you guys get tired of SrPx's attempts at trolling. I think it's slightly amusing, but if you get bored, I can kick him for you.
23:58:25 <haasn> you can always go from X to Y, IY, IIY, IIIY etc,; after all
23:58:42 <roboguy_> mm_freak: but it can also never run out of memory. anyway, sorry I'm getting a little off topic here
23:58:44 <SrPx> are you serious?
23:59:35 <mm_freak> haasn: the point is that going from SK to LC is about as arbitrary as going from assembly to haskell…  the original program structure will be lost
