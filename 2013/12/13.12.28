00:07:44 <Cale> You sure can
00:07:58 <Cale> augur: Btw, you did watch Awodey's lectures at OPLSS, right?
00:08:04 <augur> Cale: yeah
00:08:10 <augur> \large{...}
00:08:11 <augur> :3
00:08:31 <Cale> His approach to adjunctions there is very much related to the stuff we've been talking about
00:08:37 <augur> Cale: indeed
00:08:50 <augur> Cale: i actually only finally understood adjunctions by way of proof theory
00:09:19 <augur> Cale: fwiw, beta and eta rules emerge (sort of) from the unit and counit of the adjunction
00:09:42 <augur> but categorical logic yields funny proof systems
00:10:05 <augur> it yields sort of minimal sequent rules
00:10:14 <augur> but not always
00:10:24 <augur> eg it has   A*B !- A
00:10:41 <augur> rather than something analogous to any canonical rule system
00:10:49 <Cale> Why do you write !- instead of |- as ascii art for the turnstile?
00:11:24 <augur> Cale: i used to write |- but i prefer the motion required to type !-
00:12:14 <augur> for some reason, i only ever use the right shift key, so doing |- is more prone to error. i dont know. i just like !-!
00:13:10 <augur> would you prefer i use |- instead? :P
00:13:11 <Cale> I was thinking maybe there was some actual programming system which uses !- or something
00:13:11 <augur> nah
00:13:11 <augur> but there should be :)
00:13:11 <Cale> There probably is :P
00:13:16 <augur> but you also get conflations of structural and propositional connectives
00:13:22 <lightquake> @seen tekmo
00:13:22 <lambdabot> 7exMO
00:13:23 <augur> so there's no clear distinction between * and ,
00:13:34 <lightquake> ...
00:13:36 <augur> preflex: seen tekmo
00:13:36 <preflex>  tekmo was last seen on #haskell 6 hours, 35 minutes and 16 seconds ago, saying: That's the "sort of" part
00:13:45 <lightquake> thank you
00:13:54 <augur> Cale: there really ought to be some distinction between structural and propositional connections, i feel
00:14:07 <augur> especially when you get into the realm of different judgment
00:14:08 <augur> s
00:14:43 <Cale> augur: One thing that's nice about the categorical way to look at products via adjunctions, is that your two elim rules become one, and that lets you deal with the whole thing by one rule that's bidirectional to start with.
00:14:55 <augur> i feel that the tight trinitarian doctrine only works for STLC with one judgment: A true
00:15:15 <augur> well, no, they dont really become one
00:15:27 <Cale> sure they do :)
00:15:36 <Cale> In the product category :)
00:15:46 <augur> they just become a single arrow in the product category, corresponding to two arrows in the underlying category
00:15:52 <Cale> yeah
00:16:04 <augur> but the rule isnt bidirectional
00:16:04 <shachaf> It is slightly strange to me that exponentials are defined in terms of products.
00:16:18 <augur> since the proof theoretic reasoning is in the base category, not between categories
00:16:23 <Cale> Hom(FX,Y) ~= Hom(X,GY) is pretty bidirectional
00:16:32 <augur> i agree with shachaf here, even tho he'll never know
00:16:39 <augur> Cale: yes, the CT rule is
00:16:41 <Axman6> monoid doesn't have a `mappend` b == b `mappend` a does it
00:16:45 <augur> but the inference rule is not
00:16:53 <Axman6> no, list has (++) and []. nevermind
00:17:06 <Cale> Well, sure it is
00:17:16 <augur> the closest you can get is precise a pair of rules
00:17:21 <augur> or a multi-premise rule
00:17:41 <carter> linkersssss
00:18:07 <augur> while they're invertible, that doesnt make them bidirectional per se. inferences in the proof theory are rather different things than the CT stuff
00:18:43 <augur> tho i suspect you could make some nice generalized system of inferences where rules have single "complex" inputs, as well as single "complex" outputs
00:18:48 <augur> anyway
00:18:55 <Cale> You have this two way turnstile: Z -> AxB |--| ΔZ -> (A,B)
00:19:12 <augur> Cale: yes but its between categories
00:19:25 <augur> proof objects exist only in the left category
00:19:32 <augur> pairs of proof objects exist on the right
00:19:51 <augur> anyway! i agree with shachaf. you can have languages without products (eg hilbert calculus, which has only -> and structural conjunction)
00:19:52 <Cale> but even then, you can pick apart the thing on the right into a sequence of proofs in the original
00:20:04 <augur> so i think it's really weird that CT forces them together
00:20:14 <Cale> (or a set)
00:20:35 <Cale> I don't know, is it really weird?
00:20:38 <augur> Cale: yes, thats what i meant by complex premises
00:20:51 <Cale> right
00:20:55 <augur> Cale: sure it is. if i can define a perfectly cogent proof system without conjunction, i ought to be able to give it a semantics
00:20:58 <augur> but in CT, i cant
00:21:12 <augur> or maybe i can, but its more complex
00:21:35 <augur> i mean, the STLC without products is a smaller, simpler proof system than STLC with products
00:21:45 <augur> its sound and complete and its fine
00:21:50 <Cale> Well, you should still be able to formulate the syntax of your system somehow, even if your implications aren't exponentials
00:22:22 <augur> and yet the CT semantics for it isnt just the semantics for STLC-with-products minus the product semantics
00:22:50 <augur> the syntax is fine, Cale
00:22:54 <augur> its the semantics thats an issue
00:23:09 <augur> exponentials without products are hard, if not impossible
00:23:28 <Cale> Well, what do they even mean? :)
00:23:44 <augur> what is "they" here?
00:23:52 <Cale> Exponentials without products
00:23:58 <augur> same thing they always mean
00:23:59 <Cale> That doesn't even make sense
00:24:13 <augur> at least, at the proof level, -> means what it's always meant
00:24:20 <augur> what ^ means, i dont know.
00:25:09 <augur> maybe that just indicates that -> isnt an exponential per se but something else, one case of which is an exponential
00:25:53 <Cale> Are there models of STLC without products which really don't have products? Does Church encoding them not work out?
00:25:58 <augur> i really dont know. but i certainly know that this is why i reject model theoretic semantics as really being terribly important. im fully on the proof-theoretic side of things right now
00:26:11 <augur> are there models? i dont know, and certainly dont care. :)
00:26:17 <augur> i mean, you need _structural_ products
00:26:28 <augur> but not propositional ones
00:26:35 <augur> and CT conflates them.
00:27:23 <augur> you can probably do some junk with a type syntax category and an injection functor into the proof world maybe? i dont know
00:27:40 <Cale> I'm not altogether certain that I see what the problem actually is.
00:27:40 <augur> also, maybe multicategories can get you somewhere
00:28:22 <augur> the problem is there are perfectly good proof/type theories without CT semantics with the same beauty was the STLC's beauty
00:28:59 <augur> STLC has a very beautiful CT semantics. its just very nice and elegant. the conflation isn't much of a problem.
00:29:09 <Cale> I'm not totally convinced that you really don't have products once you pass to the semantics here.
00:29:27 <augur> well, you might have products of a certain sort
00:29:36 <augur> but you want to exclude them from your types
00:29:39 <augur> i mean
00:29:45 <Cale> Syntactically, you don't have products, and you also won't have exponentials, even though you do have "implications"
00:29:56 <Cale> But the semantics will have products.
00:30:02 <augur> if you have products, then you get things like A^(B*C)
00:30:06 <augur> or (A*B)^C
00:30:25 <augur> where there are exponentials formed from products
00:30:41 <augur> but there are no obvious correspondents in the syntax
00:30:58 <augur> which may well mean that the proof theory is incomplete
00:31:30 <Cale> I'm not altogether sure what it means for it to be complete in this case.
00:31:31 <augur> or perhaps it means that we're just not using the right category
00:31:49 <augur> well, A^(B*C) may not be the denotation of any type
00:32:22 <augur> but it damn well ought to be, since it has an identity arrow
00:32:30 <augur> and this there must be some corresponding proof
00:32:47 <augur> s/this/thus/
00:32:49 <Cale> The constraints placed on the category you get for the semantics of your logic might induce all sorts of widgets to exist that aren't reflected in the syntax, and I think that's okay(?)
00:33:06 <augur> widgets in the syntax arent relevant
00:33:21 <augur> the point is whether there is or isnt a type that corresponds to the object A^(B*C)
00:33:47 <augur> there must be _some_ type that corresponds to it, even if its not something like AxB->C
00:34:05 <augur> otherwise the proof theory is incomplete (and we know its not)
00:34:17 <augur> my suspicion is that CCCs are just the wrong categories for hilbert systems
00:35:07 <Cale> Well, there's B -> C -> A isn't there?
00:35:41 <augur> there is, yes
00:35:53 <lightquake> hmm, it seems like the majority of pipes and related things in Pipes.Prelude have a return type of either () or some polymorphic type variable r
00:36:04 <augur> maybe A^(B*C) = (A^C)^B, i dont know
00:36:14 <augur> they're isomorphic, but they're not strictly identical
00:36:42 <Cale> It's a bit evil to worry about whether they're identical :)
00:36:47 <augur> categorically this isnt a distinction we want to make, but its definitely a real distinction proof theoretically
00:37:30 <levi> lightquake: Were you expected something else?
00:38:01 <lightquake> not particularly. i'm just trying to figure out what exactly the return value of a pipe is good for
00:38:08 <augur> the categorical stuff is extensional in that regard. A -!!- B means [[A]] ~ [[B]]
00:38:41 <lightquake> afaict if you have some big network the return value of the network is the return value of the first Proxy to terminate
00:38:47 <augur> or ought to? i dont know. i mean, certainly Top -!!- Nat, but you probably dont want [[Top]] ~ [[Nat]]
00:38:54 <lightquake> so, i guess maybe indicating an error?
00:38:56 <Cale> lightquake: They're mostly taking operations which would have produced or accepted a single String, and turning them into operations which instead deal with that data in the direction of the pipe
00:39:35 <Cale> lightquake: So, they're either not expected to finish their work, in which case, they can produce a polymorphic result, or they do finish, and can produce ()
00:39:41 <augur> thats a witness-obviated iso. its fine if your category is the category of consequence, not the category of witness
00:40:06 <lightquake> Cale: right. but what's a good example of a pipe that *does* produce an interesting result
00:40:10 <lightquake> ?
00:40:19 <augur> then it's certainly true that [[Top]] ~ [[Nat]] since there's only ever at most one arrow between objects
00:41:10 <levi> lightquake: Could be an error value, or 'leftovers' in the case of a parser, or gathered statistics, etc.
00:41:28 <lightquake> makes sense
00:42:18 <augur> Cale: anyway, its just not as obviously elegant.
00:42:23 <augur> i dont like model theory anyway. :p
00:43:16 <lightquake> i ask because i was trying to rewrite Pipes.Prelude.fold :: (b -> a -> b) -> b -> (b -> c) -> Producer a m () -> m c using a Consumer
00:43:27 <lightquake> instead of directly pattern-matching on the constructor
00:43:54 <levi> Wow, the uoregon summer school has 'curriculum' pages going back to 05.
00:44:00 <lightquake> and the only way i could see to do it was to wrap the monad in StateT b and store the accumulator there
00:44:37 <augur> levi: yep, but not all of it is good :(
00:44:54 <augur> 2011 or 2010 is the first really good year
00:45:04 <augur> thats when they get some regular foundational stuff
00:45:16 <lightquake> which, I don't think that's idiomatic pipes
00:45:20 <lightquake> but i could be wrong!
00:46:04 <killy9999> what is a PromotedT in Template Haskell?
00:49:33 <levi> lightquake: I'm afraid I never really got the pipes idioms down very well, so I can't really give much in the way of advice.
00:53:08 <levi> augur: Well, if you're just looking for foundational stuff, that makes sense, I guess. But lots of the earlier topics also look interesting to me.
00:53:08 <bennofs> killy9999: I guess it's something to do with DataKinds
00:53:40 <augur> levi: im a foundations nerd :)
00:56:25 <levi> Clearly. ;)
00:57:18 <levi> Foundations stuff is interesting, but my head is mostly in applied stuff.
00:59:19 <killy9999> bennofs: thanks, I'll try to follow that trail :-)
01:01:23 <bennofs> killy9999: Here's an example: data X = Y; runQ [t| 'Y |] produces a PromotedT
01:01:34 <bennofs> killy9999: you need the DataKinds and TemplateHaskell extension for that
01:02:45 <lightquake> levi: yeah. i'm playing around with a 'you could have invented pipes' style tutorial but i want to make sure i get all the design decisions/idioms right
01:02:52 <lightquake> so i should probably just talk to Tekmo
01:02:55 <killy9999> bennofs: thanks
01:03:13 <killy9999> how can I check what expressions are produced by TH declarations?
01:03:50 <bennofs> killy9999: In GHCi, you can do runQ [t| Some type here |] to print the AST to generate the given type
01:04:01 <lightquake> alternately, compile with -ddump-splices
01:04:07 <bennofs> killy9999: Or you can do runQ [d| some declaration here |] for declarations
01:04:46 <killy9999> bennofs: thanks
01:10:10 <augur> i find it interesting that your proof theory can get "meta" arbitrarily high and often looks very similar. at least in natural deduction
01:11:16 <augur> i feel like that ought to be something in the model theory
01:11:28 <augur> that meta-information is very similar to information in this regard
01:12:05 <augur> the proof that G !- M : S holds looks very similar to M
01:12:36 <augur> call that proof M'. then the proof that M' proves G !- M : S holds itself looks very similar to M'
01:12:44 <augur> etc up to infinity
01:28:05 * hackagebot hcltest 0.1 - A testing library for command line applications.  http://hackage.haskell.org/package/hcltest-0.1 (BennoFuenfstueck)
01:29:57 <FliPPeh> After a long session of googling with little results.. what's the better choice: Text.JSON or Data.Aeson?
01:30:04 <FliPPeh> It's impossible to even find comparisons
01:32:17 <enthropy> FliPPeh: time to write one then? I think the latter is more popular, but that's just a vague feeling
01:32:48 <FliPPeh> I'm not the least qualified to compare two apparently equally popular implementations
01:33:36 <FliPPeh> Although I do like Text.JSON more because I can understands its source without understanding RankNTypes
01:39:33 <FliPPeh> Although maybe someone can shed some light on this: http://hackage.haskell.org/package/aeson-0.6.2.1/docs/src/Data-Aeson-Types-Internal.html#Parser
01:39:36 <enthropy> chances are you can use aeson without having to figure out that extension
01:39:51 <FliPPeh> I know a bit about forall already, but what exactly does it do in that context
01:40:02 <FliPPeh> enthropy: That is true, but there is no harm in knowing about the internals
01:41:12 <FliPPeh> It reads like the "forall f r. Failure f r" declares that for every combination of f and r, there is a possible "Failure f r"?
01:42:07 <fikusz> what's the closest thing to prolog in haskell?
01:43:20 <fikusz> (I'm not looking for a prolog implementation, but for a replacement)
01:44:41 <enthropy> FliPPeh: the idea is that when you have  runParser (x :: Parser A) withFailure withSuccess
01:45:19 <enthropy> the types of withFailure and withSuccess are not restricted the type you have for the first argument (x :: Parser A)
01:46:20 <enthropy> you can run:   runParser (x :: Parser A) Left Right :: Either String A
01:47:59 <FliPPeh> Hmm
01:48:18 <FliPPeh> I wish I could say I get it :(
01:49:03 <enthropy> if it was    newtype Parser f r a = Parser { runParser :: Failure f r -> Success a f r -> f r } -- does this make sense?
01:49:36 <Cale> fikusz: Perhaps just making use of the list monad, or another nondeterminism monad like the stuff in the logict package on hackage
01:50:10 <FliPPeh> Looks like a functions that unwraps the parser with a given failure and success handler
01:50:16 <Cale> type Failure f r   = String -> f r
01:50:16 <Cale> type Success a f r = a -> f r
01:53:01 <enthropy> it's "more convenient" to use the RankNTypes version, since then the Parser type has less parameters
01:53:55 <enthropy> and also you could have  let x = blah :: Parser a in (runParser x Left Right, runParser x error id)
01:54:10 <FliPPeh> So it just turns "Parser f r a" into "Parser a" here?
01:54:27 <FliPPeh> Seems hacky
01:54:33 <Cale> FliPPeh: So, the type of the field inside the Parser constructor says "for any types f and r, if you give me one of these failure continuations which will take my error message and make an f r, as well as a success continuation, which will take my result of type a and produce an f r, then I can give you an f r
01:55:59 <enthropy> that last example won't work with the "Parser f r a" version
01:56:21 <Cale> It's a little weird that this type is called Parser
01:56:53 <fikusz> Cale: thanks, logict looks interesting
01:57:17 <FliPPeh> Okay, this is all still pretty mysterious, but I rougly understand what's happening now
01:57:20 <FliPPeh> Thanks!
01:59:56 <Cale> I'm not actually sure how Aeson uses this stuff
02:00:04 <Cale> The parser it actually uses is Attoparsec
02:06:44 <jle`> so i just learned that not only is there a Monadic style and Applicative style, there is also a Functorial style for approaching problems
02:07:10 <jle`> that is distinct from both and a legit methodology on its own
02:14:08 <johnw> jle`: example?
02:15:24 <jle`> johnw: darn you called out my horribly vague semi-attempt at insight :)
02:15:25 <jle`> http://www.haskellforall.com/2012/09/the-functor-design-pattern.html
02:15:51 <johnw> cool, thanks!
02:16:06 <Axman6> argh, concurrency is hard!
02:16:14 <johnw> Axman6: what libraries are you using?
02:16:29 <johnw> async and STM are the best building blocks, I've found
02:16:38 <johnw> but yes, it is hard
02:16:41 <Axman6> none in particular.
02:16:49 <jle`> Axman6: i assume you have read Simon Marlow's book?
02:16:51 <johnw> I find myself debugging corner-case race conditions more often than I'd like to
02:17:13 <Axman6> hmm, maybe STM would be useful here, I do have an issue that could use atomicity
02:17:31 <johnw> i don't even really bother with the non-STM primitives anymore, except in rare cases
02:17:42 <Axman6> jle`: yeah I'm quite familliar with concurrency in Haskell
02:18:11 <Axman6> Chans are doing very well so far, except for this final reducer step
02:20:09 <Axman6> I'm trying to implement MapReduce. I'm not sure how to keep track of how much progress has been made at each step in the chain (i'm using a chain of (k,a) -> [(k',b]) functions to generalise it a bit)
02:21:48 <solidus-wave> hey all, are there sdl 2.0 bindings available for haskell?
02:22:43 <Axman6> basically for the reduce step at the end, I need to know what keys have been seen and then only return the list of key value pairs once all known keys have been reduced
02:23:21 <Axman6> this is probably making no sense without code...
02:25:03 <m1dnight_> could any help me out a second with a do?
02:25:10 <merijn> Axman6: Sounds like you may want the new hip LVars :)
02:25:10 <johnw> m1dnight_: ask
02:25:25 <m1dnight_> (ill Ãpaste here as it are 2 lines)
02:25:27 <m1dnight_> doit evs = do (\es -> makeEventSplices es) evs I.bindSplices errors
02:25:31 <m1dnight_> oh no wait
02:25:36 <m1dnight_> doit evs = do (\es -> makeEventSplices es) evs
02:25:40 <m1dnight_>               I.bindSplices errors
02:25:42 <Axman6> merijn: I don't think so
02:25:43 <m1dnight_> I have this do
02:26:01 <m1dnight_> the signature of the do has to be (TemplateState -> TemplateState)
02:26:07 <m1dnight_> (it compiles atm, so it's correct)
02:26:10 <m1dnight_> but!
02:26:13 <Axman6> (\es -> makeEventSplices es) evs === makeEventSplices es evs
02:26:30 <Axman6> uh, -es on the right
02:26:30 <johnw> doesn't that == makeEventSplices evs?
02:26:37 <m1dnight_> each line in the do, is (TemplateState -> TemplateState)
02:26:46 <m1dnight_> but, i want the first part's result, to be the input of the second part
02:26:56 <m1dnight_> It's classic monad stuff (i think?) but I can't figure it out
02:27:40 <Axman6> I think you want: doit evs = do x <- makeEventSplices evs; I.bindSplices errors x
02:28:08 <merijn> Axman6: Alternately why not have a "TVar Int" containing the number of unfinished tasks, then you can do "do { remainder <- readTVar count; check (remainder == 0) }"
02:28:20 <merijn> Axman6: The check will block until the proposition holds
02:28:34 <Axman6> hmmm, that's not a bad idea
02:29:16 <merijn> Or rather, the transaction will be woken up at most once per change in remainder, which should have negligible overhea
02:29:35 <m1dnight_> YEs :) you were correct Axman6!! (I just had to put return on the last line)
02:29:37 <m1dnight_> great, thanks!
02:30:14 <Axman6> yeah that could work. thanks merijn!
02:32:34 <Axman6> merijn: the only problem is the race condition that the value will initially be 0.. I think
02:32:40 <Axman6> hmm, let me have another look
02:32:51 <johnw> make it a Maybe Int then?
02:33:01 <Axman6> yes!
02:33:04 <Axman6> obviously
02:33:06 <Axman6> -_-
02:41:27 <Axman6> hmm, what happens if a pattern match fails in an STM action?
02:42:26 <johnw> @src STM fail
02:42:26 <lambdabot> Source not found. Sorry.
02:44:08 <johnw> fail isn't defined for STM's Monad, so I guess it's just an exception
02:44:24 <johnw> see http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Conc-Sync.html#unSTM
02:45:17 <donri> wouldn't it be nice if fail was always mzero :(
02:47:29 <johnw> what would mzero mean to STM?
02:47:43 <johnw> @src STM mzero
02:47:43 <lambdabot> Source not found.
02:47:52 <johnw> ah, retry
02:48:03 <johnw> and is guard just check then?
02:48:30 <johnw> i wonder why check is used in teaching STM instead of guard...
02:52:15 <donri> maybe to avoid teaching monads at the same time :P
02:52:37 <johnw> weird
02:53:07 <donri> personally i'm not sure what i think about exporting monomorphic versions of standard type class members
02:53:16 <donri> orElse is just mplus/<|> etc
02:53:40 <absence> does the "free" in free monoid refer to the fact that all products are free from each other (no identities, unlike a monoid with addition mod 10)?
02:54:27 <johnw> absence: free means that the product is the least sufficient operation to fulfill the laws
02:54:34 <donri> i think it refers to the fact that it's free of any structure other than the monoidal structure
02:54:44 <johnw> what donri said
02:56:59 <absence> makes sense, the identities of addition mod 10 would be extra structure
02:57:07 <absence> thanks!
02:57:37 <donri> in particular, you can fold a free monoid into any other monoid (that's mconcat, in fact)
03:00:01 * absence nods
03:00:48 <skypers_> hi
03:01:01 <skypers_> is there a function to test whether a Char is a blank?
03:01:06 <skypers_> (space, newline, and so on)
03:01:13 <donri> @hoogle isSpace
03:01:15 <lambdabot> Data.Char isSpace :: Char -> Bool
03:01:37 <skypers_> > isSpace '\n'
03:01:38 <lambdabot>  True
03:01:41 <skypers_> oh nice
03:01:45 <donri> \o/
03:01:53 <skypers_> quite weird symbol
03:01:55 <skypers_> but nice
03:01:58 <skypers_> thank you donri
03:02:00 <Axman6> > show $ filter isSpace ['\0'..]
03:02:00 <lambdabot>  "\"\\t\\n\\v\\f\\r \\160\\5760\\6158\\8192\\8193\\8194\\8195\\8196\\8197\\81...
03:02:06 <donri> symbol?
03:02:29 <skypers_> donri: well
03:02:43 <f-a> hello: running this shell script as hackage doesn't seem to want to buildd my documentation https://gist.github.com/stbuehler/7068764 Gives me a quizzical error on cabal haddock "cabal: The program hscolour version >=1.8 is required but it could not be found" (hscolour-1.20.3 installed here). What to do? (Or more in general, what to do to have/rebuild them docs on hackage? tried to curl -X DELETE with no luck).
03:02:43 <skypers_> \n is not actually a “space” right?
03:02:47 <Axman6> > length $ filter isSpace ['\0'..]
03:02:48 <lambdabot>  23
03:03:04 <johnw> (== ' ')
03:03:15 <skypers_> johnw: no
03:03:22 <skypers_> this is not what I’m looking for
03:03:26 <skypers_> see above
03:03:29 <johnw> you want any kind of whitepsace?
03:03:36 <skypers_> a blank, yeah
03:03:44 <skypers_> and isSpace sounds to do it actually
03:03:59 <skypers_> I’m just curious why it’s called is**Space**
03:04:04 <skypers_> not is**Blank**
03:04:33 <donri> skypers_: https://en.wikipedia.org/wiki/Whitespace_character#Unicode
03:04:37 <skypers_> @hoogle dropAround
03:04:37 <lambdabot> Data.Text dropAround :: (Char -> Bool) -> Text -> Text
03:04:37 <lambdabot> Data.Text.Lazy dropAround :: (Char -> Bool) -> Text -> Text
03:05:00 <Earnestly> skypers_: (Probably the same reason we call "char" char in C.  People's minds are still stuck in pre-unicode/utf-8)
03:05:22 <skypers_> I see
03:05:43 <Earnestly> Same reason most languages have broken String types, such as Java and C++
03:05:46 <skypers_> thank you
03:06:41 <Earnestly> But yeah, unicode calls it space
03:08:45 <donri> f-a: is it in $PATH?
03:09:31 <donri> f-a: you might also try standalone-haddock
03:10:03 <absence> is it possible to specify the cabal sandbox using environment variable or something, so that it will be used by ghc even if the current directory doesn't have a sandbox?
03:10:12 <merijn>  pretty sure isSpace is just short for "isWhiteSpace"
03:10:13 <kinslayer> I am trying to parse some complex JSON into a haskell data structure, however I can't seem to get how I can identify the correct piece of JSON for my elements
03:12:10 <donri> absence: you could use hsenv instead
03:12:36 <donri> absence: otherwise,  GHC_PACKAGE_PATH or -package-conf but i think they take individual package configs, not whole sets
03:12:52 <donri> -packag-db rather
03:13:15 * hackagebot webkitgtk3 0.12.5.1 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkitgtk3-0.12.5.1 (HamishMackenzie)
03:13:16 * hackagebot webkit 0.12.5.1 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.12.5.1 (HamishMackenzie)
03:15:50 <donri> kinslayer: not really sure what you're asking for
03:16:20 <kinslayer> donri: http://pubapi.cryptsy.com/api.php?method=singlemarketdata&marketid=90 I wanted to parse something like this
03:16:59 <kinslayer> however my not being super strong in haskell and it being a complex structure did give me some problems.
03:17:17 <donri> kinslayer: more specifically? where are you stumped :)
03:17:42 <kinslayer> about getting the recenttrades part out of this
03:17:44 <sajt_> I have an existential type with a single type variable and a custom typeclass, can't I somehow derive my typeclass for this type? basically all definitions for the instance are just proxy functions
03:18:58 <kinslayer> donri: http://lpaste.net/97635 I got this code
03:20:05 <johnw> sajt_: code?
03:21:00 <donri> kinslayer: not sure aeson supports dotted syntax like that
03:21:15 <kinslayer> how can I then find the parts deep inside ?
03:21:40 <kinslayer> donri: ideally I want to get the recenttrades
03:22:10 <Axman6> woah, my code compiled, it wasn't supposed to yet...
03:22:31 <f-a> donri: ah! you are right, had to install it via apt-get. Still fails but on another error
03:22:41 <f-a> geez if it is difficult to get docs up and running
03:23:09 <jle`> how to specify which binary files to build in cabal build/cabal install?
03:24:16 <sajt_> johnw: for example: data MyType = forall a. (Show a) => MyType a; instance Show MyType where show (MyType a) = show a
03:24:19 <donri> f-a: hackage should build docs for you. is your package linking a system library or something?
03:24:33 <sajt_> johnw: but instead of Show I have a typeclass I defined
03:25:22 <donri> kinslayer: haven't used aeson myself but i imagine something like, ret <- v .: "return"; markets <- ret .: "markets"; recenttrades <- markets .: "recenttrades" ...
03:25:31 <f-a> http://hackage.haskell.org/package/linebreak-0.1.0.2/candidate lo and behold here is my package in all its complexity donri. I have tried issuing a curl -X DELETE .../doc as suggested but no dice. Nothing in .../reports too
03:25:49 <donri> kinslayer: may want to look at lens-aeson or aeson-lens (always forget which is the good one)
03:26:05 <edwardk> lens-aeson
03:26:10 <donri> :)
03:26:30 <sajt_> johnw: my issue is that when I add something to my typeclass I also need to add it to the instance, which feels redundant
03:26:34 <kinslayer> donri: Okay I think I will look into that one :D
03:26:40 <donri> jle`: cabal build exename, can't do it with install
03:27:16 <johnw> sajt_: i think having constraints in a data type is deprecated
03:27:55 <sajt_> johnw: what do you mean? I'm using ExistentialQuantification
03:27:56 <kinslayer> edwardk: is lens-aeson yours ?
03:28:10 <edwardk> yes, written to replace aeson-lens with legal lenses
03:28:23 <johnw> sajt_: I mean: data Foo = forall a. Constraint a => a
03:28:28 <donri> edwardk: why weren't they merged?
03:28:31 <kinslayer> edwardk: That is probably a good idea if the other one wasn't so good :D
03:28:37 <johnw> sajt_: I could be wrong though
03:28:47 <sajt_> johnw: It's the whole point of ExistentialQuantification as far as I understand
03:28:47 <kinslayer> ^ as I haven't used either myself I can't say more than that
03:29:12 <edwardk> very different API, was;t sure what the author of aeson-lens would think, he already had users
03:29:28 <johnw> sajt_: ah, you are right, never mind me
03:29:48 <kinslayer> edwardk: good doc on the project page, or is it somewhere else ?
03:30:14 <edwardk> some docs are there, not sure i'd say they are good, but folks have written a couple tutorials by now
03:30:31 <donri> edwardk: i guess now that aeson is platformed lens-aeson will merge with lens?
03:30:43 <edwardk> perhaps
03:30:47 <edwardk> hadn't thought about it
03:30:47 <donri> s/is/will be/
03:31:01 <kinslayer> edwardk: found some docs
03:31:02 <edwardk> makes sense though
03:31:04 <kinslayer> :D
03:32:44 <kinslayer> edwardk: gotta love all the funky symbols :D ^? .~ however I have no idea what they mean.
03:33:02 <edwardk> a lot of that is just normal lens stuff
03:33:17 <merijn> kinslayer: There's a wiki table for lens operators, fortunately :)
03:33:32 <kinslayer> merijn: a link would be nice :D
03:33:36 <donri> edwardk: although if merged it should be under Data.Aeson for consistency but then it conflicts with aeson-lens :P
03:34:00 <merijn> johnw: DataTypeContexts (the deprecated extension you're thinking of) is deprecated, but that has the constraint before the = sign
03:34:13 <edwardk> probably, but by now aeson-lens is dead enough i can probably get him to retire it
03:34:24 <donri> cool
03:34:38 <merijn> johnw: Constraint *after* the = sign is usually ExistentialQuantification as sajt_ said, which commonly abused, but has quite a number of valid applications too
03:34:59 <merijn> kinslayer: https://github.com/ekmett/lens/wiki/operators
03:35:04 <merijn> kinslayer: See also lens.github.io
03:35:19 <kinslayer> merijn: Okay
03:35:24 <kinslayer> merijn: Thanks
03:35:26 <jle`> donri: thanks
03:36:08 <merijn> sajt_: I missed your original question, what's the problem?
03:38:07 <sajt_> merijn: I'm using existential types to specify an interface for multiple operations (the code doing the operations shouldn't know which implementation of the interface it's using)
03:38:27 <merijn> sajt_: Ah, that sounds like a variation of the existential antipattern
03:38:32 <merijn> @where existential-antipattern
03:38:33 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
03:38:38 <merijn> sajt_: Have you read that?
03:38:52 <donri> i linked them that yesterday
03:39:06 <sajt_> merijn: yes, I agree with the point in general
03:40:04 <merijn> but...
03:40:29 <sajt_> merijn: but in my case using existentials actually shortens the code and prevents dirty hacks which are implementation-specific
03:41:10 <sajt_> merijn: it forces you to put everything in the interface, because you can't know what you're using
03:41:18 <merijn> What are you trying to do, then? Do you have some small example?
03:42:07 <merijn> You definitely can't derive the instance, though. That requires more advanced knowledge than GHC has
03:42:09 <sajt_> merijn: my code works, but I have to declare the instance for my typeclass manually
03:42:20 <sajt_> merijn: which is redundant
03:42:37 <benmachine> you could at a pinch do it with TH
03:42:41 <merijn> I don't doubt it works, I *do* doubt it's a good idea
03:42:52 <merijn> benmachine: Throwing TH at a bad idea makes it worse, not better
03:43:02 <benmachine> but I think that's asymptotically less code with higher constants, as it were
03:43:35 <benmachine> merijn: but if by some bizarre alignment of the planets it actually turns out that you're wrong and he's right, then TH is pretty much the closest you'll get to an answer
03:43:37 <zett_zelett> Is there a reason why I can’t do data T = Cons (A | B) directly instead of data S = A | B; data T = Cons S which is almost the same?
03:43:49 <merijn> benmachine: Sure
03:44:13 <merijn> benmachine: But I assume all uses of ExistentialQuantification are wrong until proven otherwise by a usecase example :)
03:44:19 <benmachine> zett_zelett: f (Cons x) = x; what is the type of f?
03:44:38 <benmachine> merijn: that's a highly reasonable policy
03:44:40 <sajt_> merijn: I don't really understand why you think this is a bad idea
03:45:01 <benmachine> sajt_: it usually just doesn't buy you anything
03:45:02 <donri> sajt_: case in point: the problem you're asking for a solution to :)
03:45:14 <benmachine> and ends up with you having to write a bunch of code that doesn't serve any purpose
03:45:46 <merijn> sajt_: ExistentialQuantification is a much more subtle extension than it naively appears. It has a high cost in losing flexibility and many things that look simple and reasonable become impossible
03:45:50 <benmachine> zett_zelett: I think the answer is "you could imagine a language like that, but it's nontrivial, and not Haskell, and what's the big deal about just writing the latter one anyway" :)
03:46:14 <benmachine> zett_zelett: the idea echoes OCaml's polymorphic variants, that a lot of people are very fond of but also have their drawbacks
03:46:41 <zett_zelett> Okay, thanks, benmachine!
03:47:00 <merijn> sajt_: It exists because there are cases where it's needed and justified, but those are few and far apart. Usually involving high-levels of type-hackery. Usually there are better solutions, but if you don't have an example of what you're trying to do, it's hard for us to provide a better solution
03:47:16 <donri> zett_zelett: type :| = Either
03:47:17 <donri> done!
03:47:21 <sajt_> I'm open for alternatives really, what I want is for parts of the application not to care which implementation of a class they're using
03:47:30 <donri> (:|) rather
03:47:48 <sajt_> as far as I know existentials is a way of doing this
03:47:49 <merijn> sajt_: Sure, but that can usually be accomplished quite well with higher-order functions and records
03:47:52 <donri> sajt_: so why not just use normal constraints
03:48:04 <donri> no need to pack the dictionary in an existential
03:48:13 <merijn> sajt_: Lemme give you a practical example I'm using right now
03:48:40 <merijn> sajt_: I have a library with multiple different types of sockets, each with their own implementation
03:49:38 <merijn> sajt_: I have simply defined a record "Socket" that holds each individual operation: "data Socket = Socket { socketRead :: IO Message; socketWrite :: Message -> IO (); socketSetoptions :: Foo -> IO () }"
03:49:38 <sajt_> merijn: do you know which implementation is chosen at compile-time?
03:49:52 <merijn> sajt_: No
03:50:30 <merijn> sajt_: Then I just implement "read :: Socket -> IO Message" as "read sock = socketRead sock", which returns the IO action inside the socket
03:50:30 <sajt_> merijn: how do you avoid type conflicts between different implementations then?
03:50:45 <donri> sajt_: existentials don't avoid that either though
03:50:47 <jfeltz> when dealing with IO with some decomposable data structure produced at runtime from a file-system for example, is it better practice to scan the input and dispatch erroneous cases to the user, without doing further work within IO, or is it better to put all the error handling downstream within a IO monad operating on some component of this input (E.g. Either, or exception?)?
03:51:18 <merijn> jfeltz: Depends on how you plan to handle the exception (if at all)
03:51:19 <sajt_> donri: they do, you can just use the existential type and don't care what's in it
03:51:34 <merijn> jfeltz: If you plan to just "try and give up if it fails" I think exceptions in IO is perfectly reasonable
03:51:55 <merijn> sajt_: Why would my socket example not work for you application?
03:53:17 * hackagebot linebreak 0.1.0.2 - breaks strings to fit width  http://hackage.haskell.org/package/linebreak-0.1.0.2 (fffaaa)
03:53:21 <sajt_> ok, if I get this right: instead of using type-classes to define an interface you create a record type which holds the operations?
03:53:55 <merijn> sajt_: Yes
03:54:33 <merijn> And then instead of doing "instance MyClass Foo where" you just write the exact same code, but put the result into a record
03:55:08 <sajt_> merijn: well that's basically the same thing
03:55:31 <sajt_> merijn: I unify my types with an existential type and you break down a single type into multiple implementation
03:57:10 <merijn> sajt_: Yes, except that the record approach doesn't require ExistentialQuantification which is as pointed out a rather costly and expensive extension
03:57:42 <sajt_> interesting, I thought this was the textbook example for existentials
03:58:13 <merijn> sajt_: It's actually the exist thing discussed in the existential blogpost linked earlier
03:58:23 <merijn> It's rather the textbook counter-example for existentials
03:58:57 <merijn> Because of all the extra instances you need to write by hand, etc.
03:59:06 <sajt_> merijn: http://en.wikipedia.org/wiki/Existential_type#Existential_types
04:00:16 <sajt_> sometimes I wonder if type-classes are the go-to solution for anything at all
04:00:38 <merijn> sajt_: Almost never
04:00:51 <merijn> sajt_: The more you use haskell, the less typeclasses you implement
04:01:02 <merijn> sajt_: With the exception of using them for type level hackery
04:01:39 <benmachine> merijn: I thought that for a while but actually that's not entirely fair
04:01:51 <merijn> The usual experience is "I don't understand typeclasses", followed by "typeclasses everywhere!", followed by "I guess I don't need them that much"
04:01:54 <benmachine> merijn: when you try using a language without type classes you start appreciating what they're really for
04:02:07 <sajt_> they're so commonly used for the built-in stuff, I think it's misleading
04:02:09 <merijn> benmachine: Sure, I didn't say you *never* implement typeclasses
04:02:14 <benmachine> merijn: for example, Traversable is a pain in the arse to de-typeclass
04:02:32 <benmachine> I wouldn't call Traversable type-level hackery :)
04:02:45 <merijn> benmachine: I said the more you use, the less you implement
04:02:52 <merijn> benmachine: I didn't say you stopped implementing them
04:03:12 <merijn> Type level hackery just has the inverse effect, you use more and more trivial typeclasses :p
04:03:50 <merijn> sajt_: Well, I *use* typeclasses all the time, but mostly the common ones, Functor, Applicative, Monad, Comonad, Traversable, Foldable, etc.
04:04:01 <merijn> sajt_: The thing is, those already cover *a lot* of valuable usecases
04:04:45 <sajt_> merijn: thanks for convincing me, seems like the more sane approach now
04:04:51 <merijn> sajt_: And the basic ones like Eq/Ord/Num/Show/Read are of course similarly common, hence they're so commonly used in the Prelude
04:05:19 <donri> sajt_: i don't understand why you can't just use a type class without an existential though
04:05:19 <Axman6> hooray, my MapReduce is working@
04:05:21 <Axman6> !*
04:05:47 <merijn> sajt_: I wasn't trying to argue against typeclasses, just trying to instill some healthy skepticism to think critically whether they are *actually* helping you solve the problem :)
04:05:58 <Axman6> now I need some bigger data to test it on...
04:06:02 <sajt_> donri: I get type conflicts, because I don't know which implementation I'll be using at compile-time
04:06:17 <merijn> sajt_: The opposite of only having 1 tool in your language and using it for everything is thinking "just because I have a tool means I have to use it" :)
04:06:18 <donri> sajt_: i thought that was what you wanted
04:06:37 <benmachine> I agree that it's a common error to overestimate the situations in which typeclasses are useful
04:06:37 <johnw> most of my recent uses of type classes were ultimately unnecessary
04:06:56 <benmachine> but after coming to this realisation I went through a phase of believing type classes just aren't that big a deal at all and that's not true either
04:07:13 <sajt_> donri: no, the code doesn't compile because it can't unify the types without the existential (you can't have something type A and B at the same time)
04:07:22 <benmachine> the middle ground is a little delicate
04:07:33 <donri> sajt_: why do you need to?
04:08:24 <sajt_> donri: because I'm choosing the right implementation at runtime and don't want to write code twice
04:08:39 <sajt_> donri: or n times (per instance)
04:08:57 <johnw> benmachine: yep, I'm still debating how to recognize that middle ground
04:09:13 <donri> sajt_: "the right" implies there's just one, so no need to unify anything?
04:09:23 <benmachine> johnw: go learn OCaml, and notice when you weep tears of bitter regret that it doesn't have typeclasses :P
04:09:36 <benmachine> johnw: or at least, that's the method I'm using
04:10:05 <donri> sajt_: maybe if you describe your actual situation in greater detail, the channel can help suggest a good api design :)
04:10:10 <sajt_> donri: yeah, but I don't know which one it is at compile-time, so ghc can't infer the right type
04:12:14 <donri> do existentials really help there? you still have to pick an instance at the dictionary packing time, so to speak
04:12:27 <sajt_> I'm generating non-ANSI SQL for different relational databases and I don't want to riddle the application logic with database-specific junk (I'd rather abstract the db-specific code into separate modules)
04:13:02 <sajt_> and use all databases over a common interface
04:13:14 <donri> ok, so why can't you use normal type class constraints without an existential
04:13:42 <donri> query :: (SQLBackend sql) => ...
04:14:23 <sajt_> let's say you have sql implementation A and sql implementation B and get the one to use from user input
04:14:53 <sajt_> you can't write a function getDbToUse :: (SQLBackend sql) -> IO (sql)
04:15:08 <sajt_> or something like that
04:15:51 <sajt_> if you have a type data Backend = forall a. (SQLBackend a) => Backend a
04:16:13 <merijn> sajt_: No, but you can write "runQueryWithDb :: SQLBackend sql => sql -> IO ()"
04:16:23 <merijn> sajt_: i.e. why are you returning the backend at all?
04:17:07 <donri> well you could put the backends in a sum type
04:17:44 <benmachine> and it does seem like you could do the standard solution of data Backend = DB { query :: ..., update :: ... }
04:18:03 <akira__JP> Which shall I use, haskell or Matlab?
04:18:07 <sajt_> merijn: yes, if I don't want to mix configuration-file parsing / user input with running queries there are other ways (but this was fairly simple)
04:18:40 <tovarish> Hi, I try to build a static executable (no dynamic libraries) but I failed to found the option with ghc
04:18:43 <tovarish> is there one?
04:18:44 <donri> akira__JP: ask #matlab
04:18:48 <sajt_> benmachine: yes, the solution merijn suggested before would work great
04:19:06 <akira__JP> thank you donri
04:19:36 <donri> tovarish: static is the default, unless you mean C libraries
04:19:37 <Axman6> akira__JP: yes
04:19:44 <donri> in which case you may need to pass options to the linker
04:21:34 <Axman6> akira__JP: what are you trying to do?
04:22:05 <tovarish> donri, I mean I want a standalone executable (ldd should failed on it or return an empty list)
04:22:08 <tovarish> is is possible?
04:22:24 <akira__JP> Elliptic curve cryptography.
04:22:43 <sajt_> as I pointed out earlier, I tried to use existentials to unify different implementations of a class. I could just work with the existential type everywhere and it worked nicely, but putting the interface into a record type seems like a superior solution so I'll refactor my type class
04:22:55 <merijn> tovarish: Haskell libraries are linked static by default, the only dynamic libraries are C libraries (libgmp and libc), I'm not sure how to link those statically, though
04:24:08 <tovarish> merijn, thx, I'm gonna looking on how to build a C executable without dll
04:24:30 <donri> tovarish: maybe something like -optl -static
04:25:03 <tovarish> donri, yes ghc has -static, I'm looking how to tell ghc to pass it to gcc
04:25:19 <donri> tovarish: that's what -optl is for
04:25:21 <donri> "option for linker"
04:25:45 <tovarish> donri, thank you, I would have lost time withotu your help for that option
04:25:59 <donri> \o/
04:57:51 <ocharles> hey mm_freak_ / mm_bureau - are you free at all today?
04:58:00 <ocharles> I'm working on some dynamic collection stuff in netwire, and it'd be nice to build it in the most general/reusable way
05:02:45 <Komier> mornin all
05:05:30 <merijn> Probably and old an well known paper, but still hilarious: http://ivanych.net/doc/PessimalAlgorithmsAndSimplexityAnalysis.pdf
05:19:50 <Guest75618> Hi there. Does anyone know where Simon Peyton-Jones' "A Taste Of Haskell" video from OSCON 2007 can be found? IAll links I can find point at blip.tv, from which the video has been removed.
05:20:06 <johnw> I have a copy you can download
05:20:25 <johnw> one sec, let me put it up
05:20:32 <Guest75618> @johnw Great, much appreciated!
05:20:32 <lambdabot> Not enough privileges
05:21:11 <ion> :-D
05:22:03 <bennofs> How do I convert a strict bytestring to a lazy one or vice-versa? There is fromStrict and toString in newer versions of bytestring, was there also a way to do this in older versions?
05:22:20 <johnw> bennofs: B.concat . BL.toChunks
05:22:25 <johnw> BL.fromChunks . (:[])
05:23:36 <bennofs> johnw: ah, thanks
05:24:43 <johnw> Guest75618: http://dl.dropbox.com/u/137615/OSCON-OSCON2007SimonPeytonJonesATasteOfHaskellPartI455.flv and http://dl.dropbox.com/u/137615/OSCON-OSCON2007SimonPeytonJonesATasteOfHaskellPartII749.flv
05:24:52 <johnw> Guest75618: that links should be ready in about 20-30 mins, depending on my uplink speed
05:25:11 <Guest75618> Fantastic, thanks johnw!
05:49:56 <Axman6> @instances Monoid
05:49:57 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
05:50:22 <Axman6> :t Dual
05:50:23 <lambdabot> a -> Dual a
05:50:41 <johnw> Guest75618: it's there now
05:52:53 <quchen> Axman6: The Dual of a Monoid flips its mappend operation
05:53:41 <Guest75618> johnw: Great stuff - have downloaded both now, thanks again!
05:53:46 <Axman6> so, mappend (Dual a) (Dual b) = Dual (mappend b a)?
05:53:59 <quchen> Yes.
05:59:31 <donri> > getDual (Dual a <> Dual b)
05:59:32 <lambdabot>  b <> a
06:18:58 * JuanDaugherty lachelt auf "MindlessDrone".
06:21:52 <merijn> Most graph basics refer to adjacency lists and matrices as default types, claiming that matrices are usually bad due to sparsity. But why isn't it more common to just handle sparse matrices as a Map? And if that's common, why the focus on lists/matrices?
06:22:42 <FliPPeh> Given a bunch of json values as [Value] (from Data.Aeson), what would be the most elegant way of building a function as generic as possible that looks something like jsonTuple :: (FromJSON a, FromJSON b, FromJSON c, ...) => [Value] -> Maybe (a, b, c, ...)?
06:22:51 <FliPPeh> Something along those lines
06:24:05 <FliPPeh> Although I could just map decode over the list, bail out if any fails, combine the results and pattern match the whole thing...
06:24:14 <merijn> FliPPeh: Do you have a "FromJSON a => Value -> Maybe a" function?
06:24:22 <quchen> FliPPeh: Converting to generically-sized tuples is nontrivial.
06:24:51 <FliPPeh> merijn: close, fromJSON :: FromJSON a => Value -> Result a
06:24:54 <quchen> What's easy is `[Value] -> Maybe [a]`.
06:24:59 <FliPPeh> Where result is Ok a or an error
06:25:04 <FliPPeh> A glorified Either
06:25:18 <merijn> FliPPeh: Right, I assume Result is applicative, so then you'd be fine doing
06:25:56 <kinslayer> hmm I feel like haskell is a little to fond of symbols, and this is just really extreme in the lenses :(
06:25:58 <merijn> FliPPeh: "foo (x:y:z:_) = (,,) <$> fromJSON x <*> fromJSON y <*> fromJSON z"; foo _ = someError"
06:26:22 <merijn> FliPPeh: That gives you "Result (a,b,c)" but I guess turning that into "Maybe (a,b,c)" should be trivial
06:26:34 <JuanDaugherty> it's "too" kinslayer
06:26:41 <jfischoff> kinslayer: I think lens has both operators and english names for all functions
06:26:44 <jfischoff> err
06:26:49 <FliPPeh> merijn: Thanks, that seems to be the best solution
06:26:50 <jfischoff> the functions with operators
06:27:06 <merijn> FliPPeh: Result is indeed Applicative
06:27:09 <FliPPeh> I was hoping for something that automatically converts a list into a tuple with set types, but I guess that'd required a bit of template haskell
06:27:22 <merijn> FliPPeh: Yeah, lists to tuples is no good
06:27:26 <kinslayer> juandaugherty: Yeah I am not an native english speaker, so I get stuff wrong occationally
06:27:30 <merijn> FliPPeh: Better of explicitly pattern matching
06:27:37 <kinslayer> occasionally*
06:27:41 <JuanDaugherty> right, that's why informed you
06:27:47 <merijn> kinslayer: lens is just *really* symbol dense
06:27:47 <kinslayer> hehe :D
06:28:02 <zett_zelett> Filling in `Int' does (* -> *) → *, filling in `Int' for [] (of kind * -> *) for example is [Int] (wich is of kind *). Is this metalevel studied somewhere, somehow?
06:28:18 <merijn> kinslayer: I consider myself a decently skilled in Haskell, but even I get confused by lens
06:28:27 <FliPPeh> I don't like lens
06:28:27 <kinslayer> merijn: Yeah I can see that looking at the wiki with the symbols right now, although most should make sense.
06:28:28 <merijn> zett_zelett: "(* -> *) -> *" is a kind signature
06:28:35 <merijn> zett_zelett: Kinds are the "types of types"
06:28:37 <FliPPeh> Way too magical despite their simple exterior
06:28:46 <merijn> zett_zelett: 1 has type Int and Int has kind *
06:28:57 <zett_zelett> merijn: Yeah, I know.
06:29:25 <merijn> zett_zelett: Ah, so you wanna know where you can learn more about that stuff?
06:29:27 <kinslayer> At the least lens'es have a decent naming convention for symbols
06:30:00 <zett_zelett> merijn: No problem there, but you can think of `filling in Int' as something which takes a type of kind (* -> *) and gives you a type of kind *.
06:30:19 <zett_zelett> merijn: Yeah, and also whether this next level is studied at all.
06:30:20 <supki_> kinslayer: you don't need to use operators if you don't like them, i.e. use  set  instead of  (.~),  view  instead of  (^.)  , etc
06:30:31 <merijn> zett_zelett: If you have "* -> *" and provide Int (i.e. *) then you get *, yes
06:30:34 <merijn> :kind Maybe
06:30:40 <merijn> @kind Maybe
06:30:41 <lambdabot> * -> *
06:30:45 <merijn> @kind Maybe Int
06:30:45 <kinslayer> supki_: well I didn't find names for everything..
06:30:46 <lambdabot> *
06:31:05 <merijn> zett_zelett: I would say, first study the various lambda calculi
06:31:21 <merijn> zett_zelett: The lambda cube (described by Barendregt) covers a set of nicely orthogonal lambda calculi
06:31:40 <merijn> zett_zelett: From there on you can go to the Calculus of Constructions and Extended Calculus of Constructions
06:31:43 <Axman6> @kind MaybeT
06:31:44 <lambdabot>     Not in scope: type constructor or class `MaybeT'
06:31:44 <lambdabot>     Perhaps you meant `Maybe' (imported from Data.Maybe)
06:31:47 <Axman6> :(
06:31:59 <merijn> zett_zelett: These form the basis for dependently typed languages like Agda and Coq
06:32:22 <merijn> zett_zelett: Where you have a more powerful kind level to program with
06:32:32 <merijn> zett_zelett: Those, in fact, have an infinite hierarchy of kinds
06:32:46 <merijn> zett_zelett: So the kind of * will be *1, the kind of *1 is *2, etc.
06:33:08 <zett_zelett> Okay, thanks merijn!
06:33:23 <merijn> zett_zelett: In other words, yes, there's a *lot* of study on these things
06:33:30 * hackagebot ghcjs-dom 0.0.2 - DOM library that supports both GHCJS and WebKitGTK  http://hackage.haskell.org/package/ghcjs-dom-0.0.2 (HamishMackenzie)
06:33:44 <merijn> zett_zelett: A good intro to lambda calculus and type systems (from a programming language perspective) is TaPL
06:33:48 <merijn> @where TaPL
06:33:48 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
06:37:49 <zett_zelett> Many thanks!
06:40:07 <merijn> And another life succesfully corrupted and/or rined :)
06:41:04 <quchen> merijn: Nerd sniped
06:41:27 <hpc> haskell sucks, it can't even do high frequency trading!
06:42:13 <quchen> Haskell is what is known as Turing-complete*, there the asterisk indicates "with exception of high frequency trading". You didn't know? It's in the Report.
06:42:23 <hpc> :D
06:43:08 <Thooms> :D
06:43:30 * hackagebot x509 1.4.6 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.4.6 (VincentHanquez)
06:43:32 * hackagebot x509-store 1.4.3 - X.509 collection accessing and storing methods  http://hackage.haskell.org/package/x509-store-1.4.3 (VincentHanquez)
06:43:35 <kinslayer> Hmm I got a small problem I want to match a variable string in some json, so how can I make it match a lot of different strings ?
06:45:15 <merijn> hpc: That doesn't sound right. GHC 7.8 fastest software routed network implemented in Haskell...
06:46:11 <hpc> kinslayer: how do you mean "match a variable string"?
06:46:46 <kinslayer> hpc: Like most data is the same across a lot of different json files, however one little thing changes
06:46:58 <kinslayer> hpc: specifically one key changes...
06:47:02 <Axman6> quchen: i worked for a company doing high frequency trading using haskell exclusively. they did quite well
06:48:09 <hpc> kinslayer: what i might do is something like
06:48:17 <hpc> parse all the json, like you have to anyway
06:48:33 <hpc> then make a Set of keys (assuming your object is flat)
06:48:49 <hpc> for each key in the set, if each json object has the same value for that key, drop it
06:48:55 <kinslayer> hpc: Ah there is my problem, it is not a flat json, lots of objects in it...
06:48:57 <hpc> otherwise add it to some result structure
06:49:30 <hpc> you could then recurse into arrays and sub-objects
06:49:31 <kinslayer> is there a way to a variable into the instance for FromJSON ?
06:49:36 <hpc> possibly
06:50:03 <supki_> kinslayer: do you know all possible key values in advance?
06:50:06 <kinslayer> otherwise I would have to write some 60 different structures with only that little variation between them
06:50:15 <kinslayer> supki_: I should think so
06:50:24 <supki_> :t asum
06:50:25 <lambdabot>     Not in scope: `asum'
06:50:25 <lambdabot>     Perhaps you meant one of these:
06:50:25 <lambdabot>       `F.asum' (imported from Data.Foldable),
06:50:29 <supki_> :t F/asum
06:50:30 <lambdabot> Not in scope: data constructor `F'
06:50:30 <lambdabot>     Not in scope: `asum'
06:50:30 <lambdabot>     Perhaps you meant one of these:
06:50:33 <supki_> :t F.asum
06:50:33 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
06:50:47 <supki_> kinslayer: assuming your parser is an Alternative, this should work
06:51:00 <supki_> (Aeson's parser is)
06:51:14 <kinslayer> supki_: Hmm I use Aeson
06:52:07 <maurer> Axman6: What company was that out of curiosity?
06:52:33 <kinslayer> So I should look at Data.Foldable
06:53:03 <supki_> kinslayer: well, you feed a list of alternative for asum to parse
06:53:17 <supki_> kinslayer: if one of them parses, asum will return the result
06:53:21 <kinslayer> supki_: plain list?
06:53:31 <supki_> plain list of parsers, yes
06:53:49 <kinslayer> supki_: :D I was almost thinking stuff like template haskell
06:55:37 <|apriori|> hey guys. is there a way to make a type (declared via newtype) behave like a synonym of the type named in the newtype declaration? use case is, an external lib declares some types (for whatever reason) as new type of primitive types, making it impossible to easily use the inner most types with their respective operations (e.g. instances of Num), without extensive type class wrapping
06:55:47 <kinslayer> supki_: When you say a list of parsers, that makes it sound somewhat complicated
06:56:29 <merijn> |apriori|: You can get GHC to automatically derive the underlying instance
06:56:50 <|apriori|> merijn, could you point me to information and how that is done?
06:56:57 <merijn> |apriori|: There's the GenericNewtypeDeriving extension, where you can just write "newtype Foo a = Foo a deriving (Num)"
06:57:14 <|apriori|> ah, ok
06:57:17 <merijn> |apriori|: The GHC user manual should have quite some details on it
06:57:18 <|apriori|> will try that, thank you
06:57:29 <|apriori|> ok, I will search
07:00:23 <merijn> |apriori|: See http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html
07:00:26 <m1dnight_> is there a way to remove the miliseconds from getCurrentTime in haskell?
07:00:37 <merijn> |apriori|: There's some cases where it can be unsafe, but for simple usecases you should be fine
07:00:45 <m1dnight_> 2013-12-28 14:53:04.785554 UTC should be: 2013-12-28 14:53:04 UTC
07:00:54 <m1dnight_> or do I have to do it string-wise?
07:01:10 <|apriori|> merijn, yeah, thank you.. I'm already reading that page ;)
07:02:15 <geekosaur> "Conversion functions will treat it as seconds." so I would presume fromEnum would do something sensible (hopefully)
07:02:24 <pavonia> m1dnight_: You have to round the utctDayTime part of it, I guess
07:02:36 <m1dnight_> hmm okay i'm gonna try
07:03:03 <geekosaur> oh, wromng type, sorrt
07:03:12 * geekosaur is apparently not quite tracking yet
07:03:27 <geekosaur> that was NominalDiffTime I was looking at :(
07:07:29 <maurer> m1dnight_: http://hackage.haskell.org/package/time-1.4.1/docs/Data-Time-Format.html#v:formatTime may be more relevant to removing that
07:07:32 <|apriori|> merijn, wow, that feels sloppy :)
07:07:40 <maurer> m1dnight_: if you are trying to just print a time without its milliseconds
07:07:53 <maurer> m1dnight_: If you actually want to truncate it you'll want to look at rounding the internal value
07:09:57 <m1dnight_> yeah I'm looking at that atm. Trying to take the UTCTime apart and then round
07:09:58 <m1dnight_> thanks for the tip
07:11:26 <kinslayer> Okay when I have a Algebraic Data Structure can I have sub ADS's inside it ?
07:12:12 <Thooms> yes
07:12:42 <Thooms> data Tree a = Leaf a | Node (Tree a) (Tree a) f.i.
07:13:33 * hackagebot asn1-types 0.2.3 - ASN.1 types  http://hackage.haskell.org/package/asn1-types-0.2.3 (VincentHanquez)
07:13:36 <kinslayer> Thooms: That leads me neatly to my next problem, I have one I need to make a list inside an instance statement..
07:14:04 <kinslayer> that is I need to make that one structure several times and put it into a list
07:15:18 <Thooms> hm, that's not clear, could show what type of code you want to write ?
07:15:32 <Thooms> (or want to work)
07:15:53 <kinslayer> Well Just a second
07:16:30 <kinslayer> http://lpaste.net/97640 is what I got thus far
07:21:43 <pavonia> kinslayer: You want to replace sub-expressions in a JSON value?
07:21:59 <kinslayer> Not replacing but extracting the information...
07:23:01 <pavonia> For larger expressions the easiest way is probably using Uniplate for that
07:23:46 <kinslayer> Uniplate ?
07:24:12 <pavonia> @hackage uniplate
07:24:12 <lambdabot> http://hackage.haskell.org/package/uniplate
07:24:24 <kinslayer> boilerplate remover :D
07:50:26 <asdf1234> why does GHC use signed ints in its primops for things like array/address offsets and memory allocation?
07:52:39 <merijn> asdf1234: Since C also uses signed ints for those I'm assuming that that's what the underlying hardware uses
07:53:14 <asdf1234> merijn: does it? I thought size_t and friends were all unsigned
07:53:18 <merijn> Well, not necessarily signed ints in C, but pointer arithmetic is signed, as I learned
07:53:37 <merijn> asdf1234: size_t isn't used for address offsets
07:54:35 <asdf1234> derp
07:54:38 <asdf1234> ptrdiff_t
07:54:40 <asdf1234> .. hmm
07:54:44 <merijn> After making a mistake of mixing unsigned and pointer arithmetic, and debugging for two weeks I will not forget that lesson :p
07:55:01 <asdf1234> size_t sort of is, if you consider arrays & is used for malloc, though
07:55:57 <asdf1234> I guess it doesn't matter, but it feels strange to have so much space open for things that are wrong
07:56:39 <merijn> asdf1234: Sure, I guess it's mostly that no one bothered to do otherwise
07:56:51 <asdf1234> merijn: makes sense :P
07:56:58 <merijn> asdf1234: btw, for more detailed answers there's #ghc
07:57:05 <asdf1234> thanks
07:57:22 <asdf1234> hopefully you've also saved me from a stupid pointer arithmetic error too
07:57:47 <merijn> asdf1234: Response time tends to be high (think several hours), but there's less noise there so detailed questions on GHC design/implementation are less likely to get lost in generic newbie questions
08:21:13 <tristan_1> anyone around who would be interested in giving my project a look over? it is my first public haskell lib... and haven't really written haskell since college. pretty much only write Erlang now
08:21:25 <tristan_1> so hoping for someone to tell me what I did worng that lint couln't :)
08:21:54 <JeroldHaas> wait - Haskell has a lint?
08:21:59 <tristan_1> yea
08:22:01 * JeroldHaas looks it up
08:22:09 <JeroldHaas> that's brilliant
08:22:18 <tristan_1> hehe
08:22:28 <tristan_1> can can just run it, hs-lint, in emacs to step through its suggestions
08:22:56 <JeroldHaas> can I use it outside emacs, I have an emacs allergy
08:23:34 <tristan_1> JeroldHaas: yea
08:23:49 <JeroldHaas> that's a relief
08:28:26 <tristan_1> anyway, if anyone finds themselves bored and want to look this over :) https://github.com/tsloughter/pubnub-haskell
08:28:39 * hackagebot buildwrapper 0.7.7 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.7.7 (JeanPhilippeMoresmau)
08:29:48 <m1dnight_> http://lpaste.net/97646 # Could anyone help me out with my monad stuff (again), please?
08:30:04 <m1dnight_> when I do 'redirect "/"' it works (without the entire do)
08:30:10 <dzhus> since which GHC version are closed type families supported?
08:30:10 <m1dnight_> but when I fetch the current day inside the do it fails
08:31:02 <roconnor> m1dnight_: what is the type of redirect?
08:31:37 <m1dnight_> should be 'H ()' (return type)
08:31:44 <m1dnight_> I use it in other functions as well
08:31:51 <roconnor> m1dnight_: what is H?
08:31:55 <m1dnight_> oh yeah sorry
08:32:02 <m1dnight_> type H  = Handler App App
08:32:18 <roconnor> m1dnight_: okay there are at least 3 errors I see:
08:32:22 <dzhus> m1dnight_: currentUTC <- liftIO $ getCurrentTime
08:32:37 <roconnor> m1dnight_: (1) the type for viewCalendar takes 2 arguments but your implementation only takes 1.
08:32:52 <m1dnight_> yeah I commented the line because I figured it might be that one
08:32:57 <m1dnight_> and then I started stripping down
08:33:01 <m1dnight_> but yees, you are right
08:33:03 <roconnor> m1dnight_: (2) what dzhus said:  getCurrentTime works with the IO monad, but you are in the H monad; so you need the liftIO adapter.
08:33:42 <roconnor> (3) return turns a pure value into an monadic value; bet redirect $ foo is already a monadic value of the appropriate type
08:33:52 <roconnor> thus you need to nix the "return" function.
08:34:12 <m1dnight_> great
08:34:18 <m1dnight_> thanks for elaborate help roconnor  :)
08:34:24 <m1dnight_> I think I can get going again! \o/
08:34:26 <m1dnight_> thanks a lot!!
08:34:27 <roconnor> m1dnight_: not every do block needs to end in "return" despite what the poorly named function implies.
08:34:43 <m1dnight_> yeah I know, but I figured it had to do with the IO monad and the Snap monad
08:34:46 <m1dnight_> But I had no idea
08:34:50 <m1dnight_> but thanks a lot! :)
08:34:53 <roconnor> np
08:36:35 <ttll> hi everybody, is there an easier way to write this: https://gist.github.com/anonymous/8161317
08:38:14 <Taneb> ttll, I don't think that typechecks, what were you trying to do?
08:38:36 <ttll> oops
08:38:40 * hackagebot ihaskell 0.2.0.3 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.2.0.3 (gibiansky)
08:39:30 <dzhus> so closed tfs will arrive in 7.8
08:40:23 <ttll> Taneb, apply a function p to all arguments of function f and apply function q to that result
08:41:20 <ttll> but applying p to all arguments of f would already be nice
08:43:27 <ttll> something like myLift2 :: (a -> b) -> (b -> b -> c) -> (a -> a -> c);  myLift2 p f = \x y -> f (p x) (p y)
08:43:41 * hackagebot fay-jquery 0.6.0.1 - jQuery bindings for Fay.  http://hackage.haskell.org/package/fay-jquery-0.6.0.1 (AdamBergmark)
08:45:42 <Thooms> ttll: do you want it extensible (to functions with arity n), or just for that one ?
08:46:23 <ttll> Thooms: for arbitrary n
08:46:29 <Thooms> ok
08:47:54 <dzhus> does datatype promotion allow to automatically convert singleton types to/from corresponding values?
08:48:06 <Thooms> you can certainly use TemplateHaskell for that ttll
08:48:46 <ttll> I was just wondering if there is a default function I'm missing there, since it seems like a common problem
08:48:59 <Thooms> I don't think so
08:49:13 <Thooms> what you want is introspection
08:49:22 <ttll> I also just need it for n = 1..6, not really for arbitrary n
08:49:33 <Thooms> then hardcode it
08:49:38 <ttll> okay
08:50:06 <ttll> thanks!
08:50:14 <Thooms> by applying uncurry to f, and define a map on couples, you can write it very quickly I guess
08:54:26 <ImUrBreda> I am using Wai, how can I get the request body?
08:54:26 <ImUrBreda> http://stackoverflow.com/questions/7422913/handling-post-using-warp-wai?rq=1
08:54:32 <ImUrBreda> none of those answers work
08:55:10 <ImUrBreda> sorry not htis
08:55:35 <ImUrBreda> this http://stackoverflow.com/questions/9042570/how-to-consume-a-conduit-with-wai-raw-request-body
08:55:50 <devnullrandom> Is there a irc log online?
08:56:00 <devnullrandom> Sorry
08:56:01 <geekosaur> see /topic
08:56:07 <devnullrandom> Yep thanks
08:56:16 <JeroldHaas> anyone used FP Haskell Center? I'd review it but tethering on a throttled 3G isn't very productive
09:18:43 * hackagebot yamemo 0.4.0.4 - Simple memoisation function  http://hackage.haskell.org/package/yamemo-0.4.0.4 (NobuoYamashita)
09:20:44 <quchen> Is there a way to deprecate an instance? I'd like to provide one, but issue a warning if it is used.
09:23:43 * hackagebot yesod-bin 1.2.5.3 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.5.3 (MichaelSnoyman)
09:26:45 <jonasw> quchen: I don't think so (based on https://ghc.haskell.org/trac/ghc/ticket/4879 )
09:28:38 <jonasw> Oh nvm, didn't read carefully enough
09:43:29 <quchen> Is there a built-in function for "fmap f . sequenceA"? I feel like I'm missing something.
09:53:16 <roconnor> @type fmap ?f . sequenceA
09:53:17 <lambdabot>     Not in scope: `sequenceA'
09:53:17 <lambdabot>     Perhaps you meant one of these:
09:53:17 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
09:53:21 <roconnor> @type fmap ?f . T.sequenceA
09:53:21 <lambdabot> (Applicative f, Traversable t, ?f::t a -> b) => t (f a) -> f b
09:53:42 <quchen> :t \f -> fmap f . sequenceA
09:53:43 <lambdabot>     Not in scope: `sequenceA'
09:53:43 <lambdabot>     Perhaps you meant one of these:
09:53:43 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
09:53:47 <quchen> :t \f -> fmap f . T.sequenceA
09:53:47 <lambdabot> (Applicative f, Traversable t) => (t a -> b) -> t (f a) -> f b
09:53:53 <quchen> That is more readable I think.
09:55:03 <roconnor> quchen: I've seen this function call "consume" but I don't think this is part of the standard library.
09:56:14 <quchen> Alright, as long as the answer isn't "of course, it's in Foldable, dummy" I'll keep using it this way then.
09:56:19 <roconnor> quchen: consume + fmap can characterize a traversal ... I'm not sure if fmap can be dropped.
09:56:35 <quchen> roconnor: Yeah it's basically traverse with fmap/sequence switched
09:57:15 <roconnor> quchen: consume probably ought to be added to the Traversable class.
10:01:22 <boom583> I'm on page 72 in LYAH
10:01:29 <boom583> i still can't imagine how i'll write real programs with haskell
10:01:56 <m1dnight_> If I may, I would like to bother you guys again with a monad problem. Yesterday somebody told me this solution: http://lpaste.net/97647
10:02:21 <m1dnight_> now, I want to expand that do with another (HeistState n -> HeistState n) function
10:02:45 <m1dnight_> But for one ,I can' figure out what type x <- (HeistState n -> HeistState n) is
10:02:50 <m1dnight_> so I don't know how to build my return value
10:03:03 <monochrom> I don't imagine. I never did. I also don't draw a line between "real" and "not real". I just go ahead write useful programs. they start "small". then they start to grow.
10:03:27 <m1dnight_> http://lpaste.net/97648 # I tried this, but that doesn't do it
10:03:41 <monochrom> real programmers don't worry about what's "real". they just go ahead get things done.
10:04:09 <boom583> monochrom: i guess i have to learn about modules and IO first
10:04:13 <boom583> to write something useful
10:04:20 <boom583> are monoids and monads necessary?
10:04:26 <monochrom> no
10:04:59 <boom583> ok
10:08:09 <roconnor> m1dnight_: as an exercise add an annotation to your paste http://lpaste.net/97647 where you write out the type of every term you have in renderSplices
10:08:44 <roconnor> m1dnight_: ie. what are the types of: errMsg, evs, x, makeEventSplices, I.bindSplices, errors
10:09:04 <m1dnight_> well that's my problem tbh. I remember something about ((->) a) being monads, but I can't immediatly find the
10:09:15 <m1dnight_> ill pull open LYAH!
10:09:41 <stolaruk> m1dnight_: That's the Reader monad
10:09:58 <roconnor> m1dnight_: hint:  if you have "x <- expr" in a do block and "expr" has type (m a), then "x" has type (a)
10:10:22 <stolaruk> m1dnight_: chapter 14
10:15:30 <m1dnight_> roconnor: I can't figure it out. I know the type of my entire do is (m a), where (m a) == (HeistState n -> HeistState n). So the non-monadic value should be something... i dont know
10:16:05 <roconnor> m1dnight_: let's start with a list of the types of terms you do know.
10:16:22 <monochrom> if m a = HeistState n -> HeistState n, then a = HeistState n, m = (->) (HeistState n)
10:16:52 <speckle> Hello, if I want to learn Haskell to become a better programmer, how much should I learn to gain a benefit?  What kind of goals should I set?  I think learning a language might be a lifelong commitment, but I want a smaller goal for now :)
10:16:54 <monochrom> more clearly, if m a = X -> Y, then a = Y, m = (->) X
10:17:34 <monochrom> you should learn 80%
10:18:01 <speckle> I was thinking of just working through LYAH for now
10:18:23 <m1dnight_> okay i'm gonna write it down roconnor we'll see where I can get :D
10:19:31 <speckle> 80% of what, monochrom? 80% of Prelude?
10:19:42 <monochrom> 80% of all haskell
10:20:31 <speckle> wow
10:20:44 <lightquake> read 80% of all haskell code ever written!
10:21:10 <speckle> I doubt even the most seasoned Haskell gurus know that much - that is way too high of a goal!
10:21:30 <lightquake> for a more serious answer... working through LYAH is definitely a good first step
10:21:48 <monochrom> "all haskell" does not mean "all haskell code ever written"
10:22:01 <speckle> okay, thanks
10:22:06 <shachaf> Learn 80% of the Haskell monochrom has forgotten over the years.
10:22:40 <ByteEater> hi! sorry for straying off topic of the 80% of all Haskell, but could you please point me to some complete example of how to use Haskore to generate some sound from computer speakers on Windows? all the examples I've found on the Internet only get to some intermediate representation, like a Haskell data structure or a file
10:22:42 <monochrom> it is more like 80% of existing haskell knowledge
10:24:04 <monochrom> I'm using the heuristic "the first 80% takes 20% of your time"
10:25:30 <shachaf> monochrom: If that heuristic is accurate, then you're setting a terrible trap.
10:25:59 <shachaf> You can't stop after spending only 20% of the time you'll spend.
10:26:46 <monochrom> I can.
10:27:17 <monochrom> well, I can spend only 20% of the time I originally planned to spend.
10:38:23 <m1dnight_> roconnor: This is where I got : http://lpaste.net/97647
10:38:37 <m1dnight_> It compiles, but my splices are not bound
10:38:40 <m1dnight_> so something is wrong I think
10:38:44 <m1dnight_> well, I'm sure :p
10:38:55 <roconnor> m1dnight_: what is the type of makeEventSplices?
10:39:39 <m1dnight_> Monad n => [Db.Event] -> HeistState n -> HeistState n
10:39:53 <m1dnight_> so actually Monad n => [Db.Event] -> (HeistState n -> HeistState n)
10:40:01 <roconnor> m1dnight_: what is the type of I.bindSplices
10:40:43 <m1dnight_> [(ByteString, Splice m)] -> TemplateState m -> TemplateState m
10:41:27 <m1dnight_> but that's from the website, if i play typeinferencer I would say
10:41:29 <passiveobserver> what's the simplest way in haskell to open a gui window and draw a line? which module should I use?
10:41:29 <m1dnight_> just a second
10:42:34 <monochrom> opengl to draw the line. glfw to open the window.
10:42:38 <bennofs> passiveobserver: I think gloss is pretty simple for line drawing
10:43:04 <monochrom> ah, gloss to draw the line then
10:43:20 <passiveobserver> thanks
10:46:18 <m1dnight_> oh it works
10:46:24 <m1dnight_> ffs :p
10:46:41 <m1dnight_> so my "do" (for some value of) was correct
10:46:58 <m1dnight_> now let's try and make it a bit more cleaner
10:48:01 <nstdloop> I'm not sure if this is the right place to ask this, but I've been curious. Given all of the issues with cabal and conflicting dependencies, how do other package managers like pip (for python) or brew deal with those issues silently?
10:50:18 <geekosaur> cabal has somewhat worse problems, because of the way ghc works
10:50:48 <geekosaur> python can't get into the situation where two different installs of the same version of the same package are incompatible
10:51:05 <geekosaur> but because of idiosyncrasies of ghc's cross-module inlining, they can be
10:51:12 <nstdloop> why is that?
10:51:22 <sm> they use sandboxes, like cabal sandbox; or they trust that things will work out, and when they don't you find out much later
10:51:39 <nstdloop> ah
10:53:56 <sm> their package dependency checking is somewhat lazy, haskell's is more strict/eager
10:54:16 <sm> ghc/cabal's, I should say
10:54:37 <ocharles> There isn't a general type class to describe a container that can be filtered, is there?
10:54:58 <ocharles> Foldable lets me convert it to a list and filter that, but that destroys the structure of whatever functor I'm in
10:55:06 <tovarish> ocharles, MonadPlus :)
10:55:54 <tovarish> > let mfilter p mx = mx >>= \x -> guard . p >> return x
10:55:55 <lambdabot>  not an expression: `let mfilter p mx = mx >>= \x -> guard . p >> return x'
10:56:11 <roconnor> sm: really, they use sandboxes?
10:56:31 <tovarish> > let mfilter p mx =do { x <-  mx; guard (p x); return x}
10:56:32 <lambdabot>  not an expression: `let mfilter p mx =do { x <-  mx; guard (p x); return x}'
10:56:42 <tovarish> ho f..k off
10:57:13 <sm> roconnor: eg python's virtualenv
10:57:30 <roconnor> tovarish: let mfilter p mx =do { x <-  mx; guard (p x); return x} in ???
10:57:35 <roconnor> sm: hmm
10:57:46 <tovarish> roconnor, maybe, I never use ghci for complex code
10:58:51 * hackagebot hsimport 0.1.1 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.1.1 (DanielTrstenjak)
10:58:54 <tovarish> let mfilter p mx =do { x <-  mx; guard (p x); return x;}
10:59:08 * tovarish hates bots.
10:59:23 <roconnor> @let mfilter p mx =do { x <-  mx; guard (p x); return x;}
10:59:25 <lambdabot>  Defined.
10:59:30 <tovarish> :t mfilter
10:59:30 <lambdabot>     Ambiguous occurrence `mfilter'
10:59:31 <lambdabot>     It could refer to either `L.mfilter',
10:59:31 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:155:1
10:59:36 <tovarish> :D
10:59:39 <tovarish> fucking bot
10:59:46 <roconnor> :type L.mfilter
10:59:53 <roconnor> @type L.mfilter
10:59:54 <lambdabot> MonadPlus m => (b -> Bool) -> m b -> m b
11:00:04 <tovarish> ocharles, you have your answer
11:00:14 <tovarish> roconnor, thx for the help
11:06:54 * ocharles ponders if mfilter is what I want
11:07:48 <ocharles> Probably not, seeing as neither Map nor IntMap is MonadPlus
11:09:55 <supki_> ocharles: both Map and IntMap are MonadPlus sans return
11:10:16 <supki_> hmm
11:10:51 <supki_> yeah, http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Alt.html
11:11:19 <supki_> not sure if that's enough to write mfilter-like
11:16:09 <ocharles> supki_: well mfilter is defined using return, so probably not
11:18:15 <tovarish> you have alternative but alternative is MonadPlus
11:18:30 <tovarish> (without bind)
11:18:53 * hackagebot hsimport 0.2 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2 (DanielTrstenjak)
11:19:36 <ocharles> I think I'll float this filter function out as a higher order function of what i'm working on
11:35:54 <Philonous> Is there a way to get ghci to simplify types? That is, expand type family applications?
11:37:25 <donri> Philonous: i think it does that if you bind the expression to a name and :t that name
11:37:49 <ImUrBreda> is there any way to set precedence for overlapping instances
11:38:02 <Philonous> donri: λ> :t toRep Foo5
11:38:04 <Philonous> toRep Foo5 :: DBusValue (RepType Foo5)
11:38:06 <ImUrBreda> (im talking about typeclasses obv)
11:38:55 <donri> Philonous: let foo = toRep Foo5
11:38:55 <donri> Philonous: :t foo
11:39:30 <Philonous> Oh, :t let x = toRep Foo5 in x did the trick
11:39:32 <Philonous> Thanks
11:39:40 <donri> ah. np.
11:41:02 <ImUrBreda> http://www.haskell.org/pipermail/haskell-prime/2006-March/000843.html
11:41:06 <ImUrBreda> something like this
11:49:48 <augur> morning party people!
11:56:15 <ImUrBreda> No instance for (Data.String.IsString d0)       arising from the literal `"string"'
11:56:26 <ImUrBreda> using {-# LANGUAGE OverloadedStrings      #-}
11:59:14 <Philonous> ImUrBreda, Can you put the code in a paste bin?
11:59:47 <ImUrBreda> Philonous: i can't even begin extracting it
12:00:00 <ImUrBreda> im defining some crazy recursive instance definitions for certain typeclasses of mine
12:00:07 <ImUrBreda> deleted one unrelated instance definition
12:00:19 <ImUrBreda> and now the compiler is throwing REALLY weird errors
12:00:21 <ImUrBreda> impossible
12:00:56 <Philonous> ImUrBreda, You could try adding a type
12:01:29 <Philonous> ("string" :: Text) or whatever it should be
12:01:30 <ImUrBreda> Philonous: I don't catch your drift
12:01:42 <ImUrBreda> Philonous: I intentionally designed everything so i can avoid that
12:06:47 <supki_> overlapping instances are really bad at avoiding type annotations
12:08:01 <mreh> ,preflex seen ezyang
12:08:57 * hackagebot shelly-extra 0.2.3 - shelly features that require extra dependencies  http://hackage.haskell.org/package/shelly-extra-0.2.3 (GregWeber)
12:12:59 <donri> preflex: seen ezyang
12:12:59 <preflex>  ezyang was last seen on #ghc 1 day, 43 minutes and 20 seconds ago, saying: My reading is that, at some point, this was a problem
12:16:49 <imalsogreg> augur: Hey - still around?
12:17:32 <mreh> donri, ta
12:17:33 <augur> im always around
12:17:57 <mreh> does anyone know if Shelly will escape shell characters?
12:18:02 <mreh> off the top of their heads
12:18:23 <imalsogreg> augur: cool.  irc dedication :)
12:18:29 <mreh> I would quite like to run user input through it
12:18:57 <imalsogreg> So what are your your thought on publishing? (should this be in -overflow?)
12:19:32 <augur> imalsogreg: it should be in blah, actually
12:19:42 <augur> overflow is for on-topic but excessive stuff
12:19:51 <augur> #haskell-blah
12:20:04 <augur> tho to some extent its on topic
12:20:32 <imalsogreg> Ok, we'll move over when we start getting funny looks.
12:22:09 <mreh> -_-
12:22:14 <imalsogreg> augur: I wasn't sure how much interested there'd be in publication reform among PL people - seems like publishing is healthier in PL than it is in/around bio.
12:35:18 <stolaruk> Is Arch Linux still considered to be one of the best, of not the best, distro for Haskell development?
12:35:58 <quchen> It never was.
12:35:59 <Komier> does the distro make much of a difference?
12:36:07 <stolaruk> Komier: I'm not sure
12:36:15 <arpunk`> stl
12:36:20 <threestrikes> does it matter?
12:36:28 <stolaruk> threestrikes: Dunno
12:36:54 <Komier> I'm using Mint and i've managed to get pretty much everything installed with the standard repositories.
12:37:05 <Komier> I think, though I'm new at this myself.
12:37:13 <stolaruk> http://www.haskell.org/haskellwiki/GNU/Linux
12:37:47 <arpunk`> stolaruk: the only difference between distros in respect of haskell development is the speed on which they compile and ship GHC to their corresponding repositories, IMO
12:38:06 <stolaruk> arpunk`: I see
12:38:47 <arpunk`> stolaruk: they all provide GHC and it's dependencies. In Arch Linux you will get latest stable GHC
12:39:27 <stolaruk> I might try Debian as it looks like it may be easier to get everything up and running. I'm not a Linux expert
12:39:43 <arpunk`> stolaruk: for example, there is a fedora repository for testing GHC 7.x branch, in Arch Linux you would have to compile it by yourself
12:40:05 <stolaruk> arpunk`: That's a bit scary for me
12:40:30 <arpunk`> yes, you should stick with the GHC available for your GNU/Linux distribution
12:40:30 <Komier> Ubuntu is probably the most user friendly distro though no?
12:41:12 <stolaruk> Komier: Could be Mint, seems popular with beginners
12:41:18 <prprprprp> I'm trying to bind to the Foo library. Foo.hs includes foo.h. However, I also want to include several C wrappers that are in bar.o (bar.h includes foo.h).  How can I compile this?  ghci -lfoo bar.o Foo.hs fails with "panic! (the 'impossible' happened)".
12:42:35 <Komier> stolaruk: yeh I'm using Mint myself.  It seems fine.  Stable, no problems as yet.  Most things I need in standard repositories.  Managed to get the haskell platform installed from the package manager.  Then I added a few extras to use with Sublime text.
12:43:27 <stolaruk> Komier: Yeah sounds easy enough
12:44:13 <arpunk`> stolaruk: also, be aware that you can easily install haskell libraries and binaries with cabal, and now cabal has proper sandbox support. What I mean is that is irrelevant if Debian has more precompiled haskell libraries available via apt-get than Ubuntu, or whatever other GNU/Linux distro
12:45:00 <Komier> aye, and you can just run cabal from terminal  once you have the platform installed.  Tis real easy.
12:45:12 <ReinH> happy holidays everyone
12:45:25 <Komier> ReinH: ty, you as well.
12:45:46 <Clint> it's hardly irrelevant
12:46:23 <ReinH> Clint: it's irrelevant for people who install haskell libraries via cabal :)
12:46:34 <Clint> well, yes
12:46:50 <Clint> just like other packages are irrelevant for people who insist on building them themselves
12:46:58 <arpunk`> Clint: yes, sorry, I mean in my case since I don't install haskell stuff via native package managers
12:47:16 <stolaruk> ok
12:47:18 <arpunk`> only GHC, alex and happy
12:47:31 <arpunk`> and cabal-install of course
12:47:43 <DigitalKiwi> if ubuntu is debian then why is there ubuntu?
12:48:10 <prprprprp> DigitalKiwi: To ship spyware.
12:48:17 <ReinH> most people will be quite happy installing haskell platform (from a distro package if possible), updating cabal, and installing everything else with cabal
12:48:53 <Komier> ReinH: exactly what i've been doing, and I'm a linux and Haskell newbie
12:49:02 <Komier> It's not difficult
12:49:24 <ReinH> cabal hell is a real place but installing some haskell packages via a third party will only make things worse, not better
12:50:03 <ReinH> sandboxing will solve a lot of cabal hell problems too
12:51:18 <speckle> ubuntu is easier to install if you are new to linux
12:52:02 <speckle> I don't trust their repos, though - somehow they managed to not include an important file from a Python library that I'm using. I'm not sure you guys want that
12:52:10 <dhrosa> ubuntu is debian with some upstream mods, like more repositories
12:52:17 <ReinH> speckle: Maybe years ago, but debian's installation is quite easy now
12:53:09 <speckle> ReinH, would you say it's *as* easy though?
12:53:38 <speckle> I think relative ease is very important, since it makes a difference for a segment of non-technical users
12:54:17 <ReinH> speckle: I'm not sure what you mean. You can install both from their respective isos and get to your desktop in a single step.
12:54:24 <speckle> ah, ok
12:54:49 <speckle> I remember trying Debian last decade and having difficulties so I went with Ubuntu, but maybe it has improved since then
12:55:02 <ReinH> What kind of difficulties? Driver support?
12:55:25 <speckle> Not being able to figure out how install it at all
12:55:32 <ReinH> ah well that would be a difficulty, yes
12:55:59 <speckle> Ubuntu wasn't much harder back then than it is now, in fact I'd say 13.10 is a slight regression
12:56:04 <speckle> from 13.04
12:56:38 <Komier> which distro do you use Rein?
13:00:22 <gamegoblin> How liberally do you guys use type synonyms to confer intention?
13:00:43 <prprprprp> ReinH: Perhaps, you could help with this.  Let me repeat the question.
13:00:43 <prprprprp> I'm trying to bind to the Foo library. Foo.hs includes foo.h. However, I also want to include several C wrappers that are in bar.o (bar.h includes foo.h).  How can I compile this?  ghci -lfoo bar.o Foo.hs fails with "panic! (the 'impossible' happened)".
13:01:06 <ReinH> prprprprp: I'm afraid I can't help you with that.
13:01:20 <prprprprp> geekosaur: Around?
13:03:41 <enthropy> prprprprp: why do you have -lfoo there?
13:04:17 <prprprprp> enthropy: Otherwise, it couldn't find foo.h.
13:05:21 <enthropy> odd, there are other flags for the c preprocessor
13:05:36 <prprprprp> enthropy: Examples?
13:06:34 <Psycho_pr> Why doesn't Haskell have xor?
13:06:44 <enthropy> prprprprp: the -optP stuff in http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/options-phases.html
13:07:18 <enthropy> Psycho_pr: you can use /=
13:07:32 <prprprprp> enthropy: Anyway, the -lfoo bit is irrelevant here.  It works if I don't try to bind to bar.h.
13:07:57 <twanvl> Psycho_pr: or Data.Bits.xor for bitwise xor
13:07:58 <prprprprp> enthropy: The question is how to bind to bar.h and link properly.
13:10:54 <enthropy> dunno, if you have   foreign import "bar.h someFunctionFromBar" f :: Int -> IO Int -- or something? it will try to look for bar.h in the places that it is told to look
13:13:47 <prprprprp> enthropy: Yep, though you missed the word "ccall". So what are those places? I want to ship bar.h along with Foo.hs.  As I said, bar.h contains a wrapper for a C function.  The wrapper is needed because I can't bind to the orignal function.
13:14:29 <prprprprp> geekosaur and I discussed this yesterday.
13:16:26 <prprprprp> enthropy: The original function is polyvariadic, i.e., Ptr Foo -> ... -> IO (Ptr Foo). I don't know how to bind to that, so I added Foo* foo2(Foo *p1, Foo *p2) { return foo(p1, p2, NULL); } to bar.h.
13:17:21 <enthropy> did you try libffi?
13:17:34 <pavonia> @pl \f x y z -> f y z x
13:17:34 <lambdabot> flip . (flip .)
13:18:28 <prprprprp> Nope. I'm not very familiar with it, and the Haskell bindings lack docstrings.
13:18:57 <prprprprp> enthropy: I could use it instead, if you provide some pointers.
13:20:05 <twanvl> prprprprp: you should be able to call a ccall function with a variable number of arguments as if it were any other function, there is no need for a wrapper
13:20:39 <prprprprp> twanvl: Wow, what type would it have? Any examples?
13:21:11 <twanvl> In haskell you could import the function with a specific, fixed, number of arguments
13:21:16 <prprprprp> I mean I'm aware of this solution: http://okmij.org/ftp/Haskell/vararg-fn.lhs but not sure how to apply it to the FFI.
13:21:38 <prprprprp> twanvl: Interesting.
13:21:50 * prprprprp checks the ghc manual
13:23:00 <twanvl> (note that I haven't tried anything like this, I just base it on the way vararg and ccall work)
13:23:27 <qz> anyone used warp-tls? i'm getting https://github.com/yesodweb/wai/issues/114 (data: end of file) even for simplest possible server..
13:23:36 <prprprprp> twanvl: Hm, I'm failing to find anything relevant. Any pointers?
13:24:35 <pantsman> On Windows 7, cabal update corrupts my package index seemingly *every* time. Google doesn't turn up much about this.
13:25:25 <pantsman> I have to fix this after every update by deleting cabal/packages/hackage.haskell.org and running 'cabal update' again.
13:34:19 <schell> is there a way to use template haskell to run a shell command at compile time?
13:34:30 <mgsloan> schell: Yup, runIO!
13:34:31 <schell> i'm thinking for git versioning
13:34:46 <schell> runIO - cool thanks, i'll have to do some reading!
13:35:40 <prprprprp> twanvl: Hm, foreign import ccall "foo.h foo" foo2 :: Ptr Foo -> Ptr Foo -> IO (Ptr Foo) compiles.  Thanks!
13:36:08 <twanvl> good, hopefully it also runs :)
13:37:19 <prprprprp> twanvl: This reminds me of http://r6.ca/blog/20120708T122219Z.html
13:54:06 * hackagebot luautils 0.1.3 - Helpers for Haskell integration with Lua  http://hackage.haskell.org/package/luautils-0.1.3 (AnupamJain)
13:54:08 * hackagebot x509 1.4.7 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.4.7 (VincentHanquez)
13:58:52 <Fuuzetsu> Is the wiki down?
14:05:12 <quchen> Works for me
14:06:58 <kuznero> Hi All!
14:07:45 <kuznero> Are there any Yesod experts here at this time :) ?
14:08:01 <donri> maybe in #yesod if not here
14:08:20 <kuznero> donri: it seams they are all sleeping at #yesod now :)
14:27:30 <Komier> Anyone mind a newbie question?
14:27:58 <dario`> Komier: we only mind meta questions ;-)
14:28:26 <Komier> curious as to what the purpose/benefit of using let in a list comprehension is
14:30:08 <Komier> for example.... [x | y <- [1..10], z <-[1..10], let x = y*z ]
14:30:29 <Komier> why let x = y*z instead of just x = y * z
14:30:43 <Feuerbach> just a style
14:30:51 <mauke> syntactic ambiguity
14:31:00 <tulcod> Komier: [x | y <- [1..10], z <-[1..10], let x = y*z, x == y+z ]
14:31:52 <Komier> hmm
14:32:10 <tulcod> Komier: ie in a comprehension, you don't just have generators and let statements, but also filter conditions
14:32:20 <Komier> aaah
14:32:45 <Komier> I see...
14:32:46 <tulcod> additionally, [x | y <- [1..10], z <-[1..10], let x = y*z, w <- [1..x] ]
14:33:35 <tulcod> Komier: but yes, in the end "let" is just an alias
14:33:39 <Komier> I see.... it means we can assign a value to the variable then also add a filter condition without confusion.
14:34:27 <Komier> tulcod: thanks alot :0
14:35:33 <tulcod> Komier: http://hyperboleandahalf.blogspot.nl/2010/04/alot-is-better-than-you-at-everything.html
14:40:06 <Komier> hahaha.  My apologies. ;0
14:44:06 <Edo_> @pl sortBy (\(a,_) (b,_) -> compare a b)
14:44:07 <lambdabot> sortBy ((`ap` snd) . (. fst) . (const .) . compare . fst)
14:45:12 <frx> :t sortBy (comparing fst)
14:45:12 <lambdabot> Ord a => [(a, b)] -> [(a, b)]
14:46:09 <fread2282> @hoogle comparing
14:46:09 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
14:46:35 <frx> by the way, sortBy compare, or just sort, will compare by fst too (and then by snd)
14:46:49 <Edo_> cool!
14:47:48 <Edo_> ah, I didn't know that. thanks!
14:47:50 <dleedev> Hi all, I had a question about monads
14:48:48 <dleedev> A question about the final law of monads: "m >>= (\x -> k x >>= h) == (m >>= k) >>= h"
14:49:20 <dleedev> why is it written that way with the lambda instead of just: "m >>= (k >>= h) == (m >>= k) >>= h"?
14:50:02 <jle`> :t f x >>= h
14:50:03 <lambdabot> (Monad m, Show a, FromExpr (m a), FromExpr (m b)) => m b
14:50:15 <jle`> :t \x -> f x >>= h
14:50:16 <lambdabot> (Monad m, Show a, FromExpr (t -> m a), FromExpr (m b)) => t -> m b
14:50:43 <jle`> sorry
14:50:49 <jle`> :t f >>= h
14:50:50 <lambdabot> (Monad m, Show a, FromExpr (m a), FromExpr (m b)) => m b
14:51:19 <joelteon> So apparently tail-call optimization is pretty significant
14:51:23 <merijn> dleedev: Becuase the first argument to >>= is not a function
14:51:27 <Guest69566> dleedev: see the second argument of >>=. it os a function
14:51:33 <Guest69566> is
14:51:37 <merijn> And that, yes
14:51:49 <merijn> dleedev: The law is more commonly phrased using >=>
14:51:52 <merijn> :t (>=>)
14:51:53 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:52:09 <merijn> (also known as Kleisli composition or the "fish" operator)
14:52:32 <merijn> where "f >=> (g >=> h)" = "(f >=> g) >=> h"
14:53:09 <expwnent> I think it's the difference between (\x -> ((f x) >>= h)) and ((\x -> (f x)) >>= h). Is that right? I get confused with order of operations.
14:53:25 <merijn> Compare (>=>) with
14:53:27 <merijn> :t (.)
14:53:28 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:53:41 <merijn> :t flip (.) -- I guess
14:53:41 <lambdabot> (a -> b) -> (b -> c) -> a -> c
14:54:47 <dleedev> is "\x -> k x >>= h" interpretted as "(\x -> k x) >>= h" or "\x -> (k x >>= h)"?
14:55:16 <pavonia> the latter
14:55:35 <merijn> dleedev: lambda syntax binds least tight
14:55:54 <dleedev> so "\x -> (k x >>= h)"?
14:56:00 <merijn> i.e. unless there are parenthesis it goes all the way from -> to the right end of the line
14:56:03 <merijn> dleedev: Yes
14:56:44 <dleedev> what about -> vs $?
14:57:17 <Edo_> how do I sort a list of tuples first in normal order for the first element and then in reverse order for the second element?
14:57:35 <merijn> dleedev: ($) is just a normal function, a function with low fixity, but lambda syntax is lower
14:57:52 <dleedev> so "\x -> y $ z" becomes "(\x -> (y z)"?
14:57:55 <mauke> sortBy (comparing fst <> flip (comparing snd))
14:58:05 <Edo_> thanks!
14:58:19 <merijn> dleedev: FYI, binding precedence is governed by fixity value (higher binds tighter), you can request the fixity in ghci using ":i" (if no fixity is printed, it's the default of infixl 9)
14:58:24 <merijn> dleedev: Yes
14:59:00 <merijn> dleedev: 0 is lowest (used by ($)), 9 is highest (used by (.)), function application has fixity 10 (tighter than any operator) and record syntax has fixity 11 (most tight of everything)
14:59:24 <Edo_> mauke: where does (<>) come from?
14:59:26 <merijn> dleedev: lambda syntax has a fixity of -1 (or whatever, it doesn't have a real fixity, but conceptually, as it's lower than any operator)
14:59:34 <merijn> Edo_: infix version of mappend
14:59:38 <mauke> @hoogle (<>)
14:59:38 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
14:59:39 <merijn> :t mappend
14:59:39 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
14:59:39 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
14:59:39 <lambdabot> Monoid a => a -> a -> a
14:59:41 <Edo_> ah I see, thanks
14:59:44 <mauke> :-(
14:59:49 <merijn> :t Data.Monoid.<>
14:59:50 <lambdabot> parse error on input `Data.Monoid.<>'
14:59:51 <dleedev> merijn: thanks
14:59:53 <prophile> Data.Monoid
14:59:53 <merijn> hmmm
14:59:57 <merijn> :t (Data.Monoid.<>)
14:59:58 <lambdabot> Monoid m => m -> m -> m
15:01:08 <merijn> dleedev: And while I'm explaining fixity, they also specify whether an operation is right or left associative (infixr vs infixl)
15:02:05 <dleedev> can you give me an example of two functions that have opposite r/l associativity?
15:02:53 <mauke> > 2 ^ 2 ^ 3
15:02:54 <lambdabot>  256
15:02:57 <merijn> dleedev: (+) has infixl, ($) has infixr (though many people complain $ should be infixl)
15:03:13 <mauke> > (2 ^ 2) ^ 3
15:03:14 <lambdabot>  64
15:03:43 <dleedev> merijn: so 1 + 2 + 3 is (1 + 2) + 3?
15:03:55 <dleedev> merijn: and x $ y $ z is z $ (y $ z)?
15:04:02 <merijn> dleedev: In haskell, yes. Although clearly it doesn't matter mathematically
15:04:28 <dleedev> can the third law of monads be written like this: "m >>= ((>>= h) . k) == (m >>= k) >>= h"?
15:04:29 <joelteon> I don't think the list monad can be tail-call optimized
15:04:31 <FireFly> You can declare fixity and associativity for operator identifiers
15:04:32 <joelteon> I might be stupid
15:04:50 <merijn> dleedev: That looks correct at first glance, yes.
15:05:02 <merijn> dleedev: Or as I said you can write it using >=>
15:05:07 <merijn> Which looks better
15:05:17 <dleedev> merijn: I don't know what >=> is
15:05:23 <merijn> :t (>=>)
15:05:24 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:05:27 <merijn> :t (>>=)
15:05:28 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:05:48 <merijn> dleedev: It's monadic function composition (Kleisli composition, to be precise)
15:06:11 <merijn> dleedev: As you can see >=> takes a function on both sides instead of just the left side
15:06:19 <merijn> Which makes the law look prettier
15:06:36 <dleedev> merijn: why don't people use >=> more often?
15:06:50 <dleedev> merijn: i've never encountered it in any monad tutorial
15:06:51 <merijn> dleedev: I use it relatively frequently, to be honest :)
15:07:11 <dleedev> merijn: never heard of "monadic function composition"
15:07:19 <merijn> dleedev: The main reason is that >=> is defined using >>= and most tutorials stick to the classes that are part of Monad typeclass
15:07:39 <merijn> dleedev: There are many useful monad functions not part of the typeclass (that is, implemented using >>=), such as join
15:07:39 <dleedev> merijn: is >=> not a part of the Monad typeclass?
15:07:59 <dleedev> merijn: what typeclass are they a part of, then?
15:08:04 <merijn> dleedev: "(x >=> y) z = x z >>= y"
15:08:37 <merijn> dleedev: None, since the implementation of >=> just uses >>= it doesn't have to be part of the class. Once you define >>= you'll get >=> for free
15:08:38 <dleedev> merijn: that is prettier
15:09:26 <merijn> dleedev: The monad law when written using >=> is simply that "f >=> (g >=> h)" is the same as "(f >=> g) >=> h", avoiding the ugly lambda in the law using >>=
15:09:29 <FireFly> Any particular why both aren't in the typeclass, and defined in terms of each other?
15:09:39 <FireFly> +reason
15:09:40 <merijn> FireFly: Hysterical raisins?
15:09:45 <FireFly> I suppose
15:09:56 <merijn> FireFly: Need to draw the line somewhere + >>= usually easier to implement
15:10:07 <FireFly> Fair poit
15:10:10 <merijn> FireFly: So mostly pragmatic reasons
15:11:03 <merijn> FireFly: at the moment join is defined as "join x = x >>= id", but there is the occasional complaint/campaign that join should be part of the typeclass so you can define either "join" OR ">>="
15:11:46 <dleedev> merijn: where can I find these additional useful monad functions (e.g. >=>, join)?
15:12:00 <merijn> dleedev: The Control.Monad documentation and perhaps monad-loops
15:12:03 <merijn> @hackage monad-loops
15:12:04 <lambdabot> http://hackage.haskell.org/package/monad-loops
15:12:13 <ocharles> Also be sure to read Data.Traversable, Control.Applicative and Data.Foldable
15:12:19 <merijn> dleedev: http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html
15:12:25 <ocharles> all Monads are Applicative functors, so all that stuff is useful for monads too
15:12:47 <merijn> dleedev: Many (most?) functions from Control.Monad are reexported by Prelude, but not all of them
15:13:16 <merijn> And Control.Applicative is indeed another useful module to study
15:13:55 <merijn> Data.Traversable and Data.Foldable too, but I use those significantly less often than Applicative :)
15:14:18 <merijn> (I can't actually remember the last time I wrote a module that *didn't* have 'import Control.Applicative' in it
15:15:30 * ocharles nods
15:15:48 <ocharles> definitely start your extra reading at that one
15:16:06 <ocharles> mm_freak_ or mm_bureau around yet?
15:20:24 <dleedev> merijn: I've been trying to learn about monads, and conceptualize them in my mind: Monads are functions that yield two values to another monad. The first value represents aggregation/state (like a monoid) and the other is a control value which determines how the next monad should deal with the first monoid-like value. Does this sounds right?
15:22:06 <ocharles> dleedev: I quite like Eric Meijer's analogy. A function is a path from point A to point B. With a normal function you can only walk along it. But if you use the 'Maybe' monad, then you have a chance that going from A to B might fail - a bit like crossing a dangerous bridge that might collapse.
15:22:20 <ocharles> You can sort of carry it on with state (you could "make and consult notes" while you go from A to B)
15:22:28 <ocharles> obviously, like any analogy, it horribly falls down quite quickly
15:22:45 <ocharles> but it helps emphasis that the interesting stuff in a monad is in what happens when you combine things
15:23:03 <dleedev> ocharles: combine monads, you mean?
15:23:12 <ocharles> no, combine values
15:23:36 <ocharles> to go with the above anology: going from 'a' to 'b' within the same monad
15:24:17 <dleedev> ocharles: where does combining values come into play in the above analogy?
15:25:14 <ocharles> well, consider this:
15:25:24 <ocharles> > [10, 20, 30] >>= return . (* 10)
15:25:25 <lambdabot>  [100,200,300]
15:25:30 <ocharles> The "interesting" stuff there is in >>= itself
15:26:59 <dleedev> ocharles: right, there's a something that's being passed from monad to monad
15:27:16 <ocharles> dleedev: you have the right idea, but your terminology is off
15:27:49 <ocharles> "a monad" is a the type and the definitions of bind and return. For example, you have the Maybe monad or the state monad
15:28:28 <ocharles> but [10, 20, 30] is not a monad, it's just a value
15:28:56 <ocharles> We generally call things that are 'Monad m => m a' a 'monadic value' or 'action'
15:29:33 <ocharles> or sometimes "computation" to be clear that we don't have the final value until we execute it under that monad
15:32:34 <schell> how do you convert from a Double -> Fixed a?
15:35:35 <ocharles> :t fromRational . toRational
15:35:35 <lambdabot> (Fractional c, Real a) => a -> c
15:35:38 <ocharles> but I'm sure there is a nicer way...
15:36:06 <ocharles> (Fixed a  is fractional if there is a  HasResolution a  instance)
15:37:10 <ocharles> oh yes
15:37:13 <ocharles> schell: realToFrac
15:37:16 <ocharles> :t realToFrac
15:37:16 <lambdabot> (Fractional b, Real a) => a -> b
15:37:34 <schell> ahhhh
15:37:50 <ocharles> ha, which is implemented exactly as i suggested ;)
15:37:58 <schell> boom - worked
15:38:03 <schell> thanks!
15:38:09 <schell> ocharles: :)
15:38:30 <ocharles> That'll be $50, thanks
15:46:23 <generositea> new guy here, two questions:
15:46:45 <donri> you only get three questions, so choose them carefully
15:46:48 <generositea> 1) is "Learn You a Haskell for Great Good" a good place to start? and 2) i haven't been able to find much information on this, is haskell any use in scientific computing
15:48:07 <donri> @quote academic
15:48:07 <lambdabot> shapr says: I was chatting with someone who writes Haskell and at some point they said they're not an academic, and I said that too. And then there was what I perceived to be a small disbelieving silence...
15:48:35 <donri> @quote obscure
15:48:36 <lambdabot> goundoulf says: I've been reading a very good tutorial on haskell, because the [XMonad] config file was too obscure for me
15:48:43 <donri> where's that quote when you need it :P
15:49:11 <generositea> <--- confused
15:49:17 <geekosaur> @quote academia
15:49:17 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
15:49:19 * hackagebot pdfinfo 1.4.0 - Wrapper around the pdfinfo command.  http://hackage.haskell.org/package/pdfinfo-1.4.0 (ChrisDone)
15:49:24 <donri> there :)
15:50:09 <donri> generositea: so, yes. probably. both questions. :)
15:53:30 <ocharles> generositea: LYAH is a great place to start!
15:53:32 <ocharles> I owe my current career path to that book :)
15:53:35 <ocharles> generositea: and yes, though "scientific computing" is a bit vague - there is no reason you couldn't use Haskell to do it
15:54:00 <ocharles> types are very guiding in formulating just about any program, and we have high performance libraries like repa and accelerate if you're doing a lot of computation in parallel
15:54:47 <merijn> donri: That's why I test my @quote before doing them in the channel ;)
15:54:51 <donri> IIRC Tekmo started making pipes for use in his protein folding stuff or something like that
15:55:20 <donri> or drug design? something something
15:55:26 <ocharles> merijn - professional quotster
15:56:15 <merijn> Can some one ban AjoCebollaSisal he's spamming racist messages in PM
15:56:27 <donri> confirmed
15:56:40 <AjoCebollaSisal> you have to paste it in #freenode
15:56:45 <AjoCebollaSisal> as a formal report
15:56:52 <AjoCebollaSisal> idiot... even I know that
15:56:52 <generositea> by scientific computing, i mean computational physics
15:56:59 <generositea> quantum mechanical modeling
15:57:02 <generositea> toy models
15:57:04 <generositea> linear algebra
15:57:15 <donri> lots of stuff for linear algebra i think
15:57:20 <speckle> merijn, IRC PMs are complete separate from the channel so he'd need a network-wide ban
15:57:22 <generositea> networks/complex systems, dynamical systems
15:57:25 <donri> http://hackage.haskell.org/packages/search?terms=linear
15:57:28 <speckle> *completely
15:57:30 <generositea> all of this stuff is in place with C/C++
15:57:41 <merijn> speckle: Sure, but he's in the channel, so I'm assuming that what he's getting names from
15:57:41 <generositea> but as a soon to be PhD student, i want to try something new
15:57:46 <merijn> speckle: That's what usually happens
15:57:54 <merijn> speckle: So banning is usually sufficient
15:57:59 <speckle> ah, I see
15:58:08 <generositea> and i think the only reason people are so stuck on the old ways of C and Fortran is because that's how its always been done
15:58:09 <merijn> And in general, I consider it a bonus to preemptively remove the from the channel
15:58:20 <merijn> generositea: Ooh!
15:58:27 <merijn> generositea: Lemme try a sales pitch for my colleagues
15:58:53 * AjoCebollaSisal lets a thick stream of jizz fly right into merijn's face
15:59:20 * hackagebot reflection-extras 0.1.0.0 - Utilities for the reflection package  http://hackage.haskell.org/package/reflection-extras-0.1.0.0 (JonathanFischoff)
15:59:23 <generositea> merijn: do you work in scientific computing?
15:59:29 * AjoCebollaSisal splashes generositea's face with his corn-laden diarrhea 
15:59:35 <merijn> generositea: Do you want a purely functional language? With nice builtin multidimensional array support, array comprehensions, good optimisation and shape-polymorphic code?
15:59:41 <merijn> generositea: Have I got the language for you!
15:59:55 <generositea> what language is that?
16:00:06 <generositea> also, i may be incorrectly using pms right now... i dont use IRC too often
16:00:29 <merijn> generositea: No, but I have colleagues working on a purely functional languages for matrix code. Their mission in live is to obsolete matlab by having a language where you can write level code with close to hand optimised C/Fortran performance
16:00:50 <JuanDaugherty> somebody sound the topic klaxon
16:01:51 <generositea> that sounds pretty useful merijn
16:01:54 --- mode: ChanServ set +o johnw
16:01:57 <merijn> generositea: Single Assignment C, there's a bit of infrastructure issue (i.e. university IT department is slacking in getting their mailing list/binary builds of the compiler back online)
16:01:59 --- mode: ChanServ set +o johnw
16:01:59 --- mode: johnw set +b *!~AjoCeboll@200.79.253.35nil
16:01:59 --- kick: AjoCebollaSisal was kicked by johnw (Kicked)
16:02:02 --- mode: johnw set -o johnw
16:02:24 <joelteon> was that the racist spammer eralier
16:02:25 <joelteon> earlier
16:02:31 <donri> yep
16:02:37 <merijn> generositea: They're quite interested in people willing to do case studies to compare ease of development and performance, so if you want I can get you in contact with them
16:02:38 <joelteon> yeah someone complained about it in #freenode
16:03:28 <generositea> i would actually be very interested in that, only problem is im still a senior undergraduate and right now my research is not in need of much HPC or parallel code that i've written on my own yet
16:03:46 <generositea> i'm sort of preparing for next year, where i intend to dive headfirst into computationally intensive simulations and calculations
16:04:09 <merijn> generositea: They're open to students doing projects too ;)
16:05:00 <countoren> hi everyone, Yesod question:  i want to add a function (to add js/css dependencies to a widget) that i could use in both foundation file and handlers where is the best place put it ? i thought about doing new file for this .
16:05:19 <johnw> countoren: a new file sounds like a good idea
16:06:00 <countoren> johnw: yes but then i got confused what i need to import where
16:06:07 <merijn> generositea: Anyway, if you hit me up at merijn@inconsistent.nl I can send you some stuff and/or get you in contact with them
16:06:17 <johnw> countoren: you'd import that file in both Foundation and your Handler
16:07:09 <countoren> johnw: and to use all the imports from the foundation file i will to redeclare them?
16:07:32 <johnw> countoren: what we did is to create a module name "Imports", which everything imports, and that file re-exports everything that *it* imports
16:07:57 <johnw> module Imports ( module Imports, module X, module Y, module Z, etc. ) where import X; import Y; ...
16:08:47 <countoren> johnw: and there is no circular dependcies?
16:08:57 <johnw> well, Imports can't import anything that imports it
16:09:04 <johnw> but you shouldn't need to
16:09:16 <johnw> Foundation imports it, all the Handlers import it, etc.
16:11:33 <countoren> johnw: so if i understand correctly i can create new file/moudle import Import and then import the new moudle that i build in the foundation file and/or handlers , correct?
16:13:34 <Brew_> Can you catch an exception thrown by 'error "something happend...."'?
16:13:51 <someusername> Brew_: yes, but what are you actually trying to do?
16:14:05 <johnw> countoren: yes
16:14:44 <countoren> and there will be no circular dependencies?
16:14:45 <Brew_> Writing a test to a function that throws an error like so, I want to ensure that the exception is thrown
16:15:00 <johnw> countoren: as long as Imports does not import any module within your project, correct
16:15:03 <someusername> well, are you sure that error is the right thing to do? :P
16:16:01 <Brew_> I'm not sure of anything, first program written in haskell after first course in haskell :)
16:16:09 <Brew_> what else could i do?
16:16:12 <countoren> johnw: ok thanks m8 ill check it.
16:16:17 <someusername> Brew_: what's the function?
16:16:42 <Cale> Brew_: It tends to be really fiddly to catch errors of that sort, and you can only do it from IO. For that reason, we tend to only use error for the cases where it'd be okay for the whole program to die if that case ever occurred.
16:17:15 <Cale> That said, you probably want to use Control.Exception.evaluate along with catch
16:17:32 <Brew_> Well the function is infact IO
16:17:37 <Cale> You want to evaluate the expression which causes the error inside the call to evaluate
16:17:42 <Brew_> verifiedRead :: FilePath -> String -> IO [String]
16:17:46 <Cale> Oh, it's an IO action which uses error?
16:17:59 <Brew_> either returns the content or throws and error
16:18:05 <Brew_> an error*
16:18:13 <someusername> Brew_: when does it throw an error?
16:18:24 <Cale> (It might be good to make it use throwIO instead, but that should be fine)
16:18:37 <Cale> You can just use Control.Exception.catch
16:19:09 <Brew_> if the second argument doesn't match with parts of the content
16:19:22 <lightquake> well, then you probably want to use IO (Maybe [String]) then
16:19:23 <Brew_> trying to create som password handling program
16:19:34 <Brew_> lightquake: True
16:20:40 <merijn> Brew_: throwIO guarantees the exception is thrown when you think it is, throw/error can be...tricky due to laziness
16:21:13 <enthropy> are there other ways to generate the (String -> String) or (Bytestring -> Bytestring) transformations done here:
16:21:16 <enthropy> http://code.haskell.org/~aavogt/recordlabel-preprocessor/perf.html
16:21:23 <Brew_> Ah, OK. So here Maybe is better then?
16:21:41 <merijn> Brew_: Well, if your function is in IO anyway, then using throwIO should be simple\
16:22:04 <merijn> Brew_: "if passwdOK then doIOaction else throwIO myError"
16:22:17 <Brew_> merijn: precisly
16:22:29 <Brew_> thanks!
16:22:36 <Cale> You might even define your own exception type for it
16:22:57 <Cale> data BadPassword = BadPassword
16:23:03 <Cale> instance Exception BadPassword
16:23:25 <Brew_> That feels over kill.
16:23:40 <Cale> Of course, you might want to add some fields to that type to indicate something more about what went wrong
16:23:41 <merijn> Cale: Missing a "deriving (Show,Typeable)" and DeriveDataTypeable extension, there :p
16:23:45 <Cale> oh, yes :)
16:23:56 <Cale> You'll need to derive those two :)
16:24:31 <Cale> In any case, it's about two lines of code :)
16:25:30 <Brew_> Most things in haskell seems to be :)
16:34:21 <Brew_> Went with creating a new exception, but having problems with deriving Typeable.
16:34:40 <Guest89728> @help
16:34:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:35:10 <Guest89728> @pl \x y -> x + 1
16:35:11 <lambdabot> const . (1 +)
16:35:32 <fread2282> :t \x y -> x + 1
16:35:33 <lambdabot> Num a => a -> t -> a
16:35:49 <Guest89728> @unpl const . (1 +)
16:35:49 <lambdabot> (\ e _ -> 1 + e)
16:36:01 <Brew_> merijn: You mentioned a DeriveDataTypeable extension, care to elaborate?
16:36:29 <Guest89728> @hoogle [a] -> [a]
16:36:30 <lambdabot> Prelude cycle :: [a] -> [a]
16:36:30 <lambdabot> Data.List cycle :: [a] -> [a]
16:36:30 <lambdabot> Prelude init :: [a] -> [a]
16:36:47 <Cale> Brew_: {-# LANGUAGE DeriveDataTypeable #-}
16:37:40 <lightquake> Brew_: you enable language extensions either by passing -XExtension -XOtherExtension etc. to GHC, or by adding {-# LANGUAGE Extension, OtherExtension #-} to the top of your .hs file
16:37:57 <lightquake> er, by passing them to your compiler, which might not be ghc
16:38:27 <Brew_> Thanks!
16:40:24 <merijn> Brew_: By default GHC doesn't derive Data.Typeable, I'm not sure why? Probably because the haskell report doesn't specify it as a derivable typeclass?
16:40:40 <merijn> At any rate, that extension does allow you to do that
16:40:51 <khs> Hi, I have a Data.Map and I need to map an IO function ( func :: value -> IO() ) over all the values in the map. Is there a better way of doing this than converting it to a list and using mapM_?
16:41:47 <merijn> khs: Data.Foldable and Data.Traversable, to the rescue!
16:42:05 <lightquake> khs: import qualified Data.Traversable as T, use T.mapM
16:42:15 <merijn> khs: (those provides generalised versions of mapM and other functions)
16:42:27 <khs> Great, thanks!
16:42:56 <Axman6> hmm, could someone give me a hand with GADTs? I had a data type that was working fine when it was a normal ADT, but now I can't get forall working for one of the constructors: http://lpaste.net/97664
16:42:57 <stian> I've been learning Haskell with LYAH, RWH etc. I'm quite confused about the text libraries - String, ByteStream and Data.Text. I tried using Data.Text with a JSON library that wanted ByteStream, and my code looked ugly with all the imports and casting etc. Haven't found any good intro to dealing with this - why can't Haskell functions accept any string type?
16:43:26 <lightquake> stian: because ByteString and Text conceptually represent very different things
16:43:51 <Axman6> hmm, should've pasted the error too. It's telling me k, a, k' and c aren;t in scope
16:44:02 <lightquake> conceptually, ByteString ~ [Word8] and Text ~ [Char]
16:44:18 <merijn> Axman6: The forall is redundant
16:44:29 <Axman6> yeah, removing it seems to have fixed it
16:44:50 <merijn> Axman6: GADTs extension doesn't turn on forall, you need ExplicitForall/RankNTypes/etc for that
16:44:52 <lightquake> and you can't convert between [Word8] and [Char] without specifying an encoding
16:45:29 <merijn> Axman6: But anyway, existential type variables in GADTs are already treated as existential, so the forall you need with ordinary ADTs is redundant
16:45:47 <merijn> eh, that's a rather circular statement, but you get what I mean, I hope :p
16:45:49 <Axman6> yeah, I see it makes sense now too
16:46:25 <khs> merijn: T.mapM on a map maps over (key, value) tuples. I just want the values. Is there a better function than mapM to do this?
16:46:44 <merijn> khs: "T.mapM (foo . snd)"? :p
16:46:49 <merijn> :t snd
16:46:50 <lambdabot> (a, b) -> b
16:47:04 <merijn> khs: Higher order functions, yay! :)
16:47:23 <khs> merijn: still getting used to haskell :) thank!
16:48:18 <lightquake> wait, what? Traversable.mapM only maps over values
16:49:33 <Cale> "Well, it only transports MATTER..."
16:50:26 <lightquake> as opposed to the keys and values :P
16:51:00 <merijn> lightquake: You are right, hmm
16:51:06 <merijn> lightquake: No clue what's going on then?
16:54:28 <merijn> stian: To more comprehensively summarise: ByteString is for raw bytes (ignore the String part, its lies and slander), Text is for densely packed unicode text (i.e. usually one decodes ByteString into Text using whatever encoding your protocol specifies). String is only used for trivial example code, not real applications
16:54:54 <merijn> stian: You can use String for short constants, etc. But String can (on some architectures) take up to 24 bytes per character
16:55:20 <merijn> stian: Which means it wastes huge amounts of memory and the large number of pointer indirections (i.e. the linked list) make it really slow for "real" work
16:55:57 <stian> merijin: Thanks. I love the elegance of Haskell, but I get a bit scared by some of the cruft that seems to stick out - people complaining about Prelude and offering alternative Preludes, having to use GHC pragmas to overload text strings etc. Maybe I worry too much, but it's a bit offputting :)
16:56:18 <merijn> stian: Text uses tightly packed memory arrays to store text, (i.e. usually only 2 or so bytes per character plus maybe 10 or so bytes overhead per kilobyte)
16:56:37 <merijn> stian: It's not as bad as it sounds, personally I've never used an alternative prelude
16:56:38 <enthropy> merijn: String can go streaming-wise though
16:56:42 <levi> stian: Considering Haskell's age, its number of offputting attributes is not too bad.
16:57:05 <merijn> stian: As for GHC pragma's, the Haskell Report (standard) is, on purpose, rather conservative and slow to adopt things
16:57:29 <stian> merijin: So if we can define a function as accepting any Ord, why can't we define a function that accepts any String-like object? I don't really care how it slices or stores the string in the background, just like I don't care how ordered lists are stored?
16:57:32 <enthropy> at least my experience is that sometimes ByteString will be slower than String because of that
16:58:09 <merijn> stian: GHC development is much, much faster than the report moves. GHC (unlike, say, gcc) is standard compliant *by default*, so the pragma's are just telling GHC it can use non-standard features
16:58:31 <merijn> stian: This way GHC can remain standard compliant, while still being able to experiment and invent new things for future standards
17:00:09 <stian> merijin: Makes sense. I'm more used to Python, Ruby, Clojure where the main implementation is the reference implementation (even if there might be other alternative implementations).
17:01:18 <merijn> stian: While GHC is the "defacto" standard implementation, it's not intended that it functions as a reference. The Report is intended to be the reference for correctness
17:01:47 <levi> stian: It's tempting to define a whole lot of type classes when you find common behavior, but overuse of type classes can lead to more problems than it solves.
17:04:21 <merijn> stian: As for a "String-like" typeclass, I alternate between wishing it existed and being glad it doesn't. The typeclass version wouldn't come for free and would have some costs when it comes to optimisations and the complexity of type errors it produces
17:07:16 <fread2282> @hoogle foldMapDefault
17:07:17 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
17:17:02 <stian> merijin (and lightquake): thanks a lot for your detailed answers. They weren't kidding when they said #haskell is helpful and informative.
17:19:50 <HugoDaniel> http://cufp.org/videos/parallel-scientific-awesome-haskell-fpga-compiler
17:20:19 <merijn> stian: We try :)
17:22:17 <they> So, this is slightly off-topic, but what editor does everybody use for Haskell?
17:22:27 <they> Would it be worth dropping haskell-mode for something like leksah or yi?
17:22:30 <Happy0> sublime ;x
17:22:33 * Happy0 ducks for cover
17:22:39 <merijn> they: The majority is an emacs/vim split
17:22:50 <merijn> they: With some of the usual suspects
17:23:10 <hpc> merijn: more accurately, the majority is whatever text editor they prefer for general use ;)
17:23:25 <merijn> they: Eclipse FP is a notable option for the IDE fanciers, leksah/yi are rather fringe
17:23:26 <they> Alright. Looks like sticking to Emacs is fine, then.
17:23:46 <hpc> from what i understand, leksah and yi are a pain to configure
17:24:12 <geekosaur> yi is still something of a for-tinkerers-only thing, I think.
17:24:39 <merijn> they: Leksah and yi do some cool things, but for "tinkerers-only experimental editor" there are cooler options :p
17:25:27 <merijn> they: Obligatory Lamdu plug: https://github.com/Peaker/lamdu (note, wildly unusable for any real work, but really cool prototype to play with)
17:25:38 <merijn> And now I have to go sleep >.>
17:29:31 * hackagebot h-booru 0.1.0.0 - Haskell library for retrieving data from various booru image sites  http://hackage.haskell.org/package/h-booru-0.1.0.0 (MateuszKowalczyk)
17:29:35 <Fuuzetsu> geekosaur: they: I is not ready for every-day use right now. Hopefully soon though.
17:30:08 <Fuuzetsu> There's a lot of low-hanging fruit there though, please do hack on it if you're interested!
17:34:31 * hackagebot cookbook 2.0.0.1 - A delicious set of interdependant libraries.  http://hackage.haskell.org/package/cookbook-2.0.0.1 (NatePisarski)
17:34:34 <Fuuzetsu> s/I/Yi/
17:44:10 <nojustno> hoho
17:44:13 <nojustno> ho
17:44:32 <nojustno> Know of a great place to learn haskell?
17:45:09 <Fuuzetsu> @where lyah
17:45:10 <lambdabot> http://www.learnyouahaskell.com/
17:58:24 <madjestic> lyah is worth being supplemented with standard prelude source code study
17:58:31 <Cale> nojustno: Also, feel free to ask any questions you might have about the language here
17:59:34 * hackagebot reflection-extras 0.1.0.1 - Utilities for the reflection package  http://hackage.haskell.org/package/reflection-extras-0.1.0.1 (JonathanFischoff)
18:00:07 <they> Hackage is surprisingly active for a Saturday night.
18:09:36 * hackagebot Rlang-QQ 0.1.0.3 - quasiquoter for inline-R code  http://hackage.haskell.org/package/Rlang-QQ-0.1.0.3 (AdamVogt)
18:10:28 <Axman6> bleh, hmm, can you pattern match on Text values using OverloadedStrings?
18:10:57 <jfischoff> I don't think so
18:11:24 <Axman6> hmm, I'll see once I get this compiling
18:12:55 <enthropy> Axman6: you can
18:13:23 <Axman6>  No instance for (Data.Binary.Binary Text) ... that's quite surprising
18:14:36 * hackagebot reflection-extras 0.1.0.2 - Utilities for the reflection package  http://hackage.haskell.org/package/reflection-extras-0.1.0.2 (JonathanFischoff)
18:17:13 <Axman6> excellent, moving to using Text made this simple program twice as fast, with minimal rejigging
18:19:45 <sevak> hi guys, I've drawn out this code in my notebook and I'm not sure why it doesn't work, any help would be appreciated, thanks http://lpaste.net/5754633732799594496
18:20:31 <pavonia> What's the problem with it?
18:21:15 <Axman6> is it producing the results backwards? 1234 -> [4,3,2,1]?
18:21:17 <gzmask> hello folks. I am new to haskell. I heard that I should avoid "cabel hell" by using cabal-dev. so I am trying to use cabal-dev install happstack-server, but then how do I import the local or sandboxed library into my program and compile it?
18:21:21 <sevak> for the input 542, I get [2,5,4]
18:21:38 <sevak> it should be backwards yes
18:21:56 <sevak> but for some reason it isn't :-/
18:22:14 <Axman6> you're using toDigitsRev and toDigits
18:22:17 <Fuuzetsu> they: how can anyone have fun when there are libraries to write?
18:22:35 <Axman6> so it's not recursive
18:22:53 <Axman6> I assume you want toDigitsRev on line 7
18:22:57 <sevak> wow, dumb mistake
18:23:04 <sevak> yes, thanks Axman6
18:23:20 <sevak> I had a related question
18:23:33 <gzmask>  hi all, I am new to haskell. I heard that I should avoid "cabel hell" by using cabal-dev. so I tried to use cabal-dev install happstack-server, but then how do I import the local or sandboxed library into my program and compile it?
18:24:06 <Axman6> gzmask: please don't keep repeating your question :\
18:24:17 <Fuuzetsu> gzmask: We saw the question the first time, if someone can help, they will. Also, nowadays you should be leaning towards native cabal sandboxes.
18:24:33 <Axman6> native cabal sandboxes?
18:24:37 <sevak> if I understand correctly, variables are immutable in haskell; so what happens exactly to the d and m in that code, are new variables being created for each call in the recursive stack?
18:24:47 <Axman6> that's a thing? I've been away from haskell for too long
18:24:52 <Fuuzetsu> Axman6: Cabal 1.18 comes with sandboxes. ‘cabal init’
18:25:10 <Fuuzetsu> sevak: Yes
18:25:10 <Axman6> so: yes, just as they would in the equivalent C or any other language
18:25:21 <Axman6> Fuuzetsu: ooo :o
18:25:30 <gzmask> Fuuzetsu: thanks. if I cabal install something with sandboxed on, it should then be local?
18:25:55 <Fuuzetsu> if you cabal install while you have a sandbox, it will install inside the sandbox
18:26:02 <sevak> Fuuzetsu: hmm, thanks
18:26:09 <Fuuzetsu> for cabal-dev, the command is cabal-dev install IIRC
18:26:38 <gzmask> Fuuzetsu: thanks. I'll try cabal sandbox instead then
18:33:11 <Axman6> hmm, now I need a large enough MapReduce problem to test out this code... apparently counting the average number of words spoken by each person in a 20MB IRC log isn't big enough
18:33:35 <sevak> is it technically less efficient to create new variables in each call if comparing it to mutable variables?
18:34:16 <enthropy> Axman6: cat multiple copies of the same log together?
18:34:46 <Axman6> Fuuzetsu, gzmask: it seems to be cabal sandbox init, not cabal init, which is for creating new cabal packages
18:34:57 <Axman6> enthropy: I could do that... maybe I will
18:35:03 <Cale> sevak: What do you mean by "create new variables"? newIORef?
18:35:29 <Axman6> sevak: ghc should be able to turn that function into a simple loop
18:35:36 <Axman6> hmm, I think
18:35:47 <Axman6> it's not tail recursive so maybe not...
18:36:14 <sevak> Cale: I just mean the d and m variables being recreated each time a call is made
18:36:19 <Cale> I just read back a bit, okay
18:36:43 <Cale> It's worth mentioning that there is nothing which quite resembles a call stack in GHC's implementation of expression evaluation
18:36:58 <Cale> There is a stack, but it's closer to a stack of pattern matches
18:37:05 <ij> If've an IO data and I want to >>= them into a function that might be sideeffectful in one case or not in other, then should I make that function as if x then (return $ i(x)) else j(x)?
18:37:58 <Axman6> why so many brackets? otherwise, yes
18:38:23 <ij> I wasn't sure about the outer ones, as I've'nt used ifs much.
18:38:43 <they> That could be if x then return $ i x else j x
18:38:48 <Iceland_jack> ij: You can write i(x) as ix
18:38:49 <Iceland_jack> *i x
18:38:52 <Axman6> though, I assume that you meant if p x then return $ i x else j x, since there's no need to feed i and j the argument if you know it'll be true for one and false for the other
18:39:00 <ij> Of course.
18:39:03 <sevak> hmm, that's interesting, so it's only recursive on the surface and gets compiled into an iterative set of commands?
18:39:06 <Cale> sevak: Well, d and m will be computed on each iteration there, but I don't think there's any way around that. d will pretty quickly become garbage once you demand the tail of the list (when toDigits matches on it), m may or may not be garbage immediately, depending on how you're processing the list
18:39:21 <Cale> Oh, it's recursive
18:39:23 <Axman6> sevak: well, that is how CPUs work... =)
18:39:29 <Cale> It's just, evaluation is outermost-first
18:39:40 <Cale> and so, you don't tend to need a *call* stack
18:40:15 <Fuuzetsu> Axman6: oops, yes, sorry, that's what I meant ;~
18:40:26 <ij> Can I make unconstrained variables in the function type declaration?
18:40:34 <ij> like String -> IO a
18:40:46 <ij> I remember not being able to do it.
18:40:55 <Axman6> only if you throw an exception...
18:40:56 <Cale> (Though, the evaluation of a function goes on the stack before it can be applied, most functions will already be a lambda, so that usually doesn't matter)
18:41:04 <Axman6> so the IO action never returns
18:41:26 <Axman6> ij: why would you not know the return type of the function?
18:41:33 <eikke> :t return undefined
18:41:33 <lambdabot> Monad m => m a
18:41:43 <gzmask> Humm, I still got "Could not find module `Happstack.Server'" after cabal sandbox init then cabal install happstack-server
18:41:56 <ij> I want to specify it for later, so that the error of wrong type wouldn't bother me as long as the type can be infered.
18:42:04 <Axman6> gzmask: http://www.haskell.org/cabal/users-guide/installing-packages.html#developing-with-sandboxes
18:42:16 <ij> s/error of wrong type/wrong type error/
18:42:44 <Axman6> ij: you can leave the type off the function if you want
18:42:53 <Axman6> like, just delete the type
18:43:10 <sevak> Axman6: hehe yes that's true :) Cale: hmm really interesting even though some of this is going over my head
18:43:24 <ij> will have to do with that then. :) tahanks
18:43:31 <sevak> thanks
18:43:40 <Cale> sevak: The entries on the stack are more things like whenever you have  (case foo bar of [] -> ...; (x:xs) -> ...)  the pattern match has to wait while foo bar is evaluated to determine which pattern will match (i.e. it'll be evaluated just up to determining if the list is empty or not)
18:44:21 <gzmask> Axman6: do I have to manually link the lib if I am just using ghc to compile the program? I have no experience in making a cabal configuration yet
18:44:33 <Cale> So, foo will be evaluated (which will usually be immediate, because it's probably defined as a lambda), and then applied to bar (bar will only be evaluated if foo does a pattern match on it somehow)
18:45:08 <Cale> But in any case, while that evaluation is taking place, we need to remember that we were trying to evaluate the case expression, and that's pretty much what the stack entry is.
18:45:15 <Cale> If you look at something like:
18:45:18 <Cale> @src foldl
18:45:18 <lambdabot> foldl f z []     = z
18:45:18 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:45:29 <Cale> If we write  foldl (+) 0 [1,2,3]
18:45:53 <Cale> The foldl will greedily apply itself to new parameters without allowing any of the arithmetic to occur:
18:46:06 <sevak> this is part of haskell being "lazy" correct?
18:46:21 <sevak> I mean lazy evaluation
18:46:26 <Cale> foldl (+) 0 [1,2,3] --> foldl (+) (0 + 1) [2,3] --> foldl (+) ((0 + 1) + 2) [3] --> foldl (+) (((0 + 1) + 2) + 3) []
18:46:31 <twirlobite> :t @src
18:46:32 <lambdabot> parse error on input `@'
18:46:35 <Cale> --> (((0 + 1) + 2) + 3)
18:46:40 <twirlobite> :t (@src)
18:46:41 <lambdabot> parse error on input `@'
18:46:44 <Cale> up to this point, we haven't really needed the stack
18:46:45 <geekosaur> wat
18:46:53 <Cale> twirlobite: @src is a lambdabot command, it's not a Haskell anything
18:47:01 <twirlobite> Cale: ahh
18:47:11 <twirlobite> @src (map)
18:47:11 <lambdabot> Source not found. My brain just exploded
18:47:16 <Cale> @src map
18:47:16 <lambdabot> map _ []     = []
18:47:16 <lambdabot> map f (x:xs) = f x : map f xs
18:47:17 <twirlobite> @src map
18:47:17 <lambdabot> map _ []     = []
18:47:17 <lambdabot> map f (x:xs) = f x : map f xs
18:47:21 <geekosaur> it's also quite stupid
18:47:22 <Cale> It just does a lookup in a text file
18:47:26 <twirlobite> ohh
18:47:36 <twirlobite> that's so awesome though
18:47:40 <Axman6> sevak: what do you think typedef struct list_s{ int n; list_s * next} list; list * denoms(int n) { list * l = malloc(sizeof(list)); div_t dm = div(i, 10); l.n = dm.rem; l.next = denoms(dm.quot); return l;} does? that's essentially exactly what your code does (minus the 0 case)
18:47:44 <twirlobite> is the source from the haskell report?
18:48:03 <Cale> sevak: (Yeah, it has to do with lazy evaluation)
18:48:19 <Cale> So, at this point, where we start doing arithmetic, we'll start using the stack
18:48:20 <fread2282> @src (~+)
18:48:21 <lambdabot> Source not found. Whoa.
18:48:25 <Cale> (+) will
18:48:27 <Fuuzetsu> gzmask: cabalise your lib, it's easy to do (cabal init and follow instructions) and saves you a lot of effort
18:48:33 <twirlobite> @src ~
18:48:33 <lambdabot> Source not found. Are you on drugs?
18:48:35 <Cale> because (+) needs to match both of its arguments
18:48:42 <twirlobite> @src +
18:48:42 <lambdabot> Source not found. My mind is going. I can feel it.
18:48:48 <twirlobite> @src (+)
18:48:49 <lambdabot> Source not found. Where did you learn to type?
18:48:50 <Axman6> twirlobite: what're you doing?
18:48:52 <Cale> (to decide what the resulting integer is, you need to know both inputs)
18:48:59 <Cale> twirlobite: You can PM lambdabot
18:49:05 <twirlobite> Axman6: sorry, playing, i will stop now
18:49:15 <Cale> twirlobite: It's okay to play, just do it in PM :)
18:49:31 <twirlobite> Cale: sounds good :)
18:49:37 <Axman6> @src Int (+)
18:49:37 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
18:49:41 <Cale> So, we have ((0 + 1) + 2) + 3
18:49:47 <ij> So when does an IO computation happen? When it's called from within an IO monad(?) like main?
18:49:49 <Cale> the outermost (+) gets to evaluate first
18:49:57 <twirlobite> Axman6: we can't find the source for (+)!
18:50:15 <Axman6> @src Complex (+)
18:50:15 <lambdabot> Source not found. I am sorry.
18:50:15 <Cale> and it will match on its left argument, which is ((0 + 1) + 2)
18:50:19 <Axman6> bleh, you suck lambdabot
18:50:32 <Axman6> @src Maybe fmap
18:50:32 <lambdabot> fmap _ Nothing       = Nothing
18:50:32 <lambdabot> fmap f (Just a)      = Just (f a)
18:50:33 <Cale> and so that pattern match will wait on the stack while we evaluate (0 + 1) + 2
18:50:33 <twirlobite> how does haskell define (+)?!
18:50:56 <Cale> and then the same thing will happen, we'll get another stack entry, and evaluate 0 + 1
18:51:09 <Axman6> twirlobite: it's type specific. for the primitive types it's defined in Cmm to use the machine implementation like + in int and double
18:51:19 <Cale> and finally, (+) will be able to match, resulting in 1, and then we'll compute 1 + 2 = 3, and then 3 + 3 = 6
18:51:26 <twirlobite> Axman6: what is Cmm?
18:51:30 <Cale> (as we pop things off the stack and things are able to match)
18:51:32 <Axman6> for Integer it's defined using gmp
18:51:47 <Axman6> C minus minus, one of the internal representations used by GHC
18:51:57 <Cale> sevak: So, I don't know if that makes sense :)
18:52:00 <ij> Axman6, ghc?
18:52:04 <ij> and only?
18:52:16 <Cale> sevak: But it explains why (without optimisations), foldl (+) 0 [1..1000000] can result in a stack overflow
18:52:21 <Axman6> ij: huh?
18:52:36 <ij> Axman6, Isn't c-- used only by ghc?
18:53:12 <Axman6> Cmm /= C--, but they're related. I believe there used to be other projects using C--
18:53:49 <Cale> It's not because foldl is recursively calling itself (that uses at most one stack entry at a time while we evaluate the list), but it's that once the foldl finishes, we've constructed a giant expression built out of strict functions (ones which pattern match their parameters) which then puts lots of matches on the stack at once
18:54:00 <gzmask> Fuuzetsu: any good tutorial on cabalizing a simple project ?
18:55:11 <sevak> cool thank you; I got some of that. I'm going save your comments and will hopefully understand all of it after learning some more hehe :)
18:55:17 <Cale> (there's a version called foldl' which can force the arithmetic to happen in a better order)
18:55:40 <Axman6> and it's almost always what you want
18:57:03 <AlainODea> twirlobite: (+) is defined in the Num typeclass in the Prelude module. http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#g:7
18:57:35 <passiveobserver> can I change cabal to download & install packages on windows to haskell platform installation directory instead of c:\users\appdata\roaming?
18:59:34 <AlainODea> passiveobserver: cabal sandbox may be a better option if we want other users to have the same packages.  Cabal can go squirrely and you'd have to un/reinstall Haskell Platform
19:00:12 <AlainODea> passiveobserver: you're also likely to run afoul of UAC
19:00:19 <bmuk> What is the best option right now for haskell on android?
19:01:06 <Axman6> are there any options for haskell on android? I though iOS was the only supported platform, and only somewhat
19:01:29 <ij> If I want a function that is a predicate, should I functionP?
19:02:18 <bmuk> Axman6: I have seen a video of someone using haskell on android, I'll try and find it
19:02:21 <passiveobserver> AlainODea: it means I can't?
19:02:37 <they> That's more of a lisp thing ij.
19:02:44 <Axman6> ij: usually no. most seemed to be names like x in is x, such as is null x? is even x? (here even, null are the predicates)
19:03:03 <bmuk> Axman6: http://www.youtube.com/watch?v=n6cepTfnFoo
19:03:05 <Axman6> s/seemed/seem
19:03:10 <bmuk> is this the only thing?
19:03:30 <they> You can either make a function like: isThing, doesThing, or thing? It's preference, really.
19:04:18 <AlainODea> passiveobserver: UAC would make it a headache.  You'd have to "run as administrator" cabal or the command prompt/powershell you are running it from
19:04:37 <AlainODea> passiveobserver: it's likely to be a huge headache
19:06:07 <davean> Does anyone know where the default definition of "max" resides? I can't actually find the definition of class Ord in base ...
19:08:10 <Axman6> @sec max
19:08:10 <lambdabot> max x y = if x <= y then y else x
19:08:23 <davean> yes, but WHERE is it?
19:08:28 <zomg> davean: Data.Ord?
19:08:31 <davean> zomg: no
19:08:34 <ion> @hoogle max
19:08:35 <lambdabot> Prelude max :: Ord a => a -> a -> a
19:08:35 <lambdabot> Data.Ord max :: Ord a => a -> a -> a
19:08:35 <lambdabot> Prelude maxBound :: Bounded a => a
19:08:46 <davean> Those export it
19:09:04 <davean> It isn't actually in those files
19:09:13 <ion> davean: “:i max” in ghci
19:09:13 <Axman6> it's magic
19:09:32 <zomg> Here? http://hackage.haskell.org/package/base-4.2.0.1/docs/src/GHC-Classes.html
19:09:44 <zomg> at least the definition of ord is there
19:10:28 <davean> Interesting, that isn't in the copy of base I downloaded, maybe it is dynamically generated or something
19:10:33 <davean> (4.6.0.1)
19:10:43 <Fuuzetsu> gzmask: not that I know of but it's very simple; go into your lib's directory and run ‘cabal init’ then follow the instructions
19:10:51 <Fuuzetsu> say yes when it asks whether to document what fields are
19:10:51 <zomg> No idea where it comes from, I just tried clicking at the source button in hackage for Data.Ord and then did some googling because the link was broken
19:10:54 <zomg> :D
19:11:13 <they> Dynamically generated? Like a Ken Thompson Ord?
19:11:17 <AlainODea> davean: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/src/GHC-Classes.html#Ord
19:11:33 <davean> It is very disturbing not to be able to actually track down the source of a function in haskell
19:11:51 <davean> AlainODea: interesting, so it moved
19:11:59 <davean> and none of the files that export it import that
19:12:05 <davean> so, what is special?
19:12:14 <Fuuzetsu> then open the generated cabal file and fill in the rest; looking at an existing project's file might help: https://github.com/Fuuzetsu/yukari/blob/master/Yukari.cabal ; pay attention to the ‘library’ section near the bottom, particularly ‘exposed modules’ bit
19:12:31 <AlainODea> davean: they don't need to.  It's in Prelude
19:12:38 <davean> AlainODea: this is below prelude
19:12:49 <AlainODea> No magic, just implied behavior
19:12:56 <Fuuzetsu> davean: ‘:i max’ in GHCi should tell you where it is
19:13:02 <davean> Fuuzetsu: yes
19:13:12 <zRecursive> :i max
19:13:19 <levi> davean: max is a method. It's going to have implementations all over the place at the instance declarations.
19:13:36 <davean> levi: I specified the default
19:13:37 <Fuuzetsu> zRecursive: No :i from lambdabot
19:14:09 <davean> Well, now I at least know what is going on
19:14:27 <gzmask> Fuzzetsu: thanks, I got the idea now. coming from leiningen I'll say cabal is a lot better than 2010 (when I first looked info haskell)
19:26:43 <levi> davean: http://git.haskell.org/packages/ghc-prim.git/blob/HEAD:/GHC/Classes.hs
19:29:11 <levi> davean: GHC.Classes is imported by GHC.Base, as described here: http://git.haskell.org/packages/base.git/blob/HEAD:/GHC/Base.lhs
19:30:24 <levi> It's just not obvious that GHC.Base and GHC.Classes are in separate git repositories.
19:31:59 <levi> Most Haskell code is pretty easy to track down, it's just the really core stuff that's sometimes tricky in GHC.
19:39:15 <bitemyapp> http://lpaste.net/97665 fails with :  No instance for (Benchmarkable (a0 -> Pure)), arising from a use of `bench'...No instance for (MonadIO ((->) a0)) arising from a use of `example'
19:39:57 <bitemyapp> nf example :: (Typeable a, MonadIO ((->) a)) => a -> Pure
19:51:40 <joelteon> do .cabal files support else if?
19:52:47 <ion> Dunno, but if foo… else if bar… is the same as if foo…, if not foo and bar…
19:53:13 <ion> Also, if foo… elseif bar… is the same as if foo… else (if bar…)
19:53:31 <joelteon> okay, thanks ion
19:59:10 <jfischoff> can reifyInstances deal with polymorphic types?
19:59:31 <jfischoff> because I have not gotten it to work yet ...
20:04:44 <roboguy_> bitemyapp: doesn't nf take two arguments?
20:05:09 <mm_freak_> ocharles: yes
20:05:24 <mm_freak_> now, anyway =)
20:06:00 <bitemyapp> roboguy_: sure but that's not the real problem right now.
20:06:29 <bitemyapp> roboguy_: http://lpaste.net/97666
20:08:23 <roboguy_> bitemyapp: what's render?
20:08:48 <bitemyapp> roboguy_: Hastache.
20:08:56 <bitemyapp> roboguy_: it's just a function that renders a string template.
20:09:03 <bitemyapp> roboguy_: the code was in my lpaste
20:09:34 <bitemyapp> roboguy_: I am trying to benchmark hastache.
20:09:40 <bitemyapp> using Criterion.
20:10:31 <roboguy_> bitemyapp: have you tried specifying the IO monad specifically in ghci, instead of just the MonadIO class?
20:11:24 <bitemyapp> roboguy_: I'm a noob, why would I specify the IO monad?
20:11:30 <bitemyapp> I'm trying to add type signatures to fix it.
20:11:46 <roboguy_> maybe try this in ghci: bench "example" (render :: IO LZ.ByteString)
20:12:06 <roboguy_> bitemyapp: it seems that it can't resolve the ambiguity introduced by the type class
20:12:33 <bitemyapp> roboguy_: sigh, that seems to have worked. Why is the IO monad a sufficient replacement for MonadIO?
20:12:54 <roboguy_> bitemyapp: IO is a specific type and MonadIO is a type class
20:13:08 <roboguy_> with several instances
20:13:32 <bitemyapp> roboguy_: does IO implement MonadIO?
20:16:44 <joelteon> yeah
20:16:47 <joelteon> liftIO is id
20:17:16 <bitemyapp> roboguy_: thank you for the help.
20:28:57 <stolaruk> In this expression, is there a way to move the 5s out and over to the right? (,) <$> take 5 <*> drop 5 $ [1..10]
20:28:59 <stolaruk> > (,) <$> take 5 <*> drop 5 $ [1..10]
20:29:00 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
20:29:27 <ion> > splitAt 5 [1..10]
20:29:28 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
20:29:43 <ion> That’s more efficient, too.
20:29:56 <stolaruk> ah
20:30:40 <erisco> Control.Monad.mapM does not use Functor :'(
20:32:39 <schlegel> erisco: Why would it?
20:33:05 <enthropy> erisco: I don't think you can write one which does
20:33:13 <erisco> why is it not reasonable?
20:33:29 <dwcook> erisco, you might be interested in Data.Traversable.mapM
20:33:38 <enthropy> @type traverse
20:33:39 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
20:34:06 <erisco> ah I guess there would not be any way to collect the result
20:34:38 <negatratoron> how is =<< pronounced?
20:34:57 <joelteon> dnib
20:35:48 <erisco> dwcook, yes that is reasonable thanks
20:35:56 <Iceland_jack> flip bind or reverse bind
20:36:04 <stolaruk> bind left?
20:36:14 <Iceland_jack> Never heard that but it would be understandable
20:36:35 <stolaruk> Along those lines is there a reasonable pronunciation for "(>>)"?
20:36:39 <Iceland_jack> then
20:36:41 <joelteon> then
20:36:57 <stolaruk> Gosh I had no idea, cool.
20:37:11 <erisco> golly goodness
20:37:12 <roboguy_> negatratoron: flipped bind?
20:37:15 <negatratoron> okay
20:37:15 <negatratoron> thanks
20:37:16 <Iceland_jack>     a >> b >> c
20:37:16 <Iceland_jack> “Do a, then do b, then do c”
20:37:28 <schlegel> When in doubt: http://www.haskell.org/haskellwiki/Pronunciation
20:37:29 <dwcook> "flipped bind", I guess
20:37:58 <stolaruk> schlegel: Golly I didn't know about that page. Sweet.
20:38:23 <negatratoron> I was thinking you could pronounce >>= "so you can"
20:38:40 <Iceland_jack> “shovel operator”
20:39:00 <roboguy_> negatratoron: usually it's called "bind"
20:39:01 <negatratoron> getLine so you can putStrLn
20:39:02 <roboguy_> but I guess that could sort of work
20:39:02 <negatratoron> I know, I'm looking for a more grammatical name
20:39:02 <schlegel> "shifty laser eyes"
20:40:31 <trillioneyes> I usually say "into"
20:42:03 <stolaruk> Is tuple pronounced like tooople?
20:42:18 <schlegel> tomayto, tomahto
20:42:34 <negatratoron> I like that
20:42:35 <negatratoron> it's short
20:42:35 <dwcook> On that note, who says "tomahto"? Is there some region where people actually do that?
20:42:46 <mauke> tüplə
20:43:00 <dwcook> stolaruk, either as in "chute" or as in "cup"
20:43:05 <schlegel> I say toople, I've heard tuhple
20:43:13 <negatratoron> toople, tuhple
20:43:19 <stolaruk> so either way, ok
20:43:19 * schlegel wishes he had an AltGr key
20:45:30 <schlegel> negatratoron: Bind tends to make more sense if you were to write it as "getLine >>= \x -> putStrLn x" which could be read as "Do getLine, and bind its value to x, then do putStrLn x"
20:46:05 <schlegel> Or at least that's how I'd kind of read it
20:47:21 <negatratoron> ahh, bind makes more sense with the lambda written out
20:49:17 <schlegel> In the same vein you can pronounce the '<-' in a do block as bind as well
21:10:36 <joelteon> will tail call optimization mean that tail calls don't show up as separate entries in a profiling report?
21:12:06 <bitemyapp> joelteon: Probably. Why not find out via ?!SCIENCE?!
21:12:32 <joelteon> because i'm not smart enough to know
21:13:07 <bitemyapp> joelteon: my point is to find out. You've already framed a possible experiment.
21:13:15 <joelteon> ok
21:14:46 <bmuk> Hey guys could you help me find a better way to write a desugared do block?
21:14:56 <joelteon> well, it doesn't look like it
21:15:26 <bmuk> how do I paste a snippet of code into the chat?
21:16:04 <schlegel> lpaste.net
21:16:07 <schlegel> look in topic
21:16:18 <bmuk> thank you brb
21:16:42 <roboguy_> joelteon: I think if you add explicit {-# SCC ... #-} annotations it will
21:18:43 <bmuk> http://lpaste.net/2300286992274948096
21:19:16 <bmuk> I am working through Write Yourself a Scheme and that was originally a much longer do block
21:19:30 <bmuk> Is there any way I can make this shorter or more readable?
21:20:45 <joelteon> this is goddamn weird.
21:21:38 <bmuk> schlegel: what did you mean by look in topic?
21:21:51 <schlegel> /topic
21:22:10 <bmuk> oh okay I was not aware of that, thank you
21:22:22 <schlegel> It's probably also above the chat window
21:22:37 <bmuk> Just the first part. I'm in emacs
21:22:47 <schlegel> ah
21:23:06 <schlegel> hmm..good idea
21:23:24 <bmuk> do you see of a way I could eliminate the lambdas from that snippet?
21:23:52 <schlegel> what snippet
21:24:09 <bmuk> http://lpaste.net/2300286992274948096
21:25:46 <schlegel> @bmuk, parseAtom = (`fmap` many (letter <|> digit <|> symbol)) . (Atom .) . (:) =<< letter <|> symbol
21:25:46 <lambdabot> Unknown command, try @list
21:25:58 <schlegel> Whoops sorry, lambdabot
21:26:07 <mauke> @pl (\x y -> Atom (x : y)) <$> foo <*> bar
21:26:07 <lambdabot> (Atom .) . (:) <$> foo <*> bar
21:26:24 <mauke> well, not worth it
21:26:58 <schlegel> bmuk: What's the original do notation
21:27:09 <schlegel> lambdabot can do it with @undo
21:27:10 <bmuk> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
21:27:15 <bmuk> grep for parseAtom
21:33:45 <bmuk> schlegel: do you see it?
21:36:57 <erisco> say you have a graph, and data of type A can be stored on the vertices and data of type B can be stored on the edges
21:37:09 <erisco> what is a reasonable way to go about a Functor instance?
21:37:23 <johnw> each Vertex would be a functor, and each Edge would be a functor
21:37:46 <erisco> and what would the graph be?
21:38:00 <johnw> probably [Vertex] [Edge]
21:38:23 <erisco> what I mean is, what class would the graph fall under that relates to Functor?
21:38:40 <johnw> the graph could either be a functor over A, or a functor or B, but not both
21:38:54 <erisco> yes, so
21:39:05 <erisco> it is not sensible to choose one over the other
21:39:18 <johnw> i would think that A would be more natural here
21:39:43 <johnw> now, you could make another functor instance
21:39:45 <johnw> with a newtype wrapper
21:39:54 <johnw> if you wanted to regard it as a functor over B
21:40:06 <johnw> getGraphOfB $ fmap g (GraphOfB x)
21:40:13 <erisco> I see
21:41:08 <dhrosa> hi, I have the following directory structure and relevant .cabal section: http://lpaste.net/97667 when I try to do cabal build, I get "cabal: can't find source for Shiny/Hardware in src, dist/build/autogen
21:41:09 <negatratoron> <jt isfphlqk kjd uoarj nd al gl;kalid sy nskj{
21:41:14 <dhrosa> how do I fix my directory structure or .cabal?
21:41:18 <negatratoron> *Why couldn't the graph be an instance of both?
21:41:27 <dhrosa> negatratoron: that was beautiful
21:41:32 <johnw> erisco: I suppose you could also make it a Bifunctor
21:41:47 <johnw> http://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html
21:41:59 <Axman6> negatratoron: dvorak?
21:42:04 <negatratoron> Axman6, yeah
21:42:25 * johnw uses dvorak 
21:43:29 <bmuk> johnw: in all seriousness, does it help?
21:43:36 <johnw> it does help me, yes
21:43:47 <johnw> qwerty used to give me pain in my left hand after really long coding binges
21:43:47 <negatratoron> oh, because then fmap would be ambiguous
21:43:56 <johnw> dvorak's level of stress on my hands remains constant
21:44:53 <johnw> but that's the only way it helps that I know of, which would not make it worth it in my opinion
21:44:56 <bmuk> doesn't it suck going back at someone else's computer though?
21:45:09 <johnw> not anymore, my fingers are completely bilingual
21:45:42 <nisstyre> johnw: do you have a mechanical keyboard, and if so, what kind of switches?
21:46:14 <nisstyre> because after switching to a keyboard with cherry mx red, and vimifying almost everything, my hands feel better
21:46:26 <nisstyre> even with qwerty
21:46:47 <johnw> nisstyre: Cherry Brown
21:47:16 <johnw> i still use Qwerty on Windows, but dvorak feels much more "comfortable".  entirely subjective, though.  Anyway, about that Haskel... :)
21:47:17 <nisstyre> I wonder if it's worth it to switch to dvorak, the pain in my right hand is almost gone now
21:47:42 <schlegel> erisco: What is the type of your graph?
21:47:44 <nisstyre> fair enough, I'll stop sidetracking
21:47:55 <Hodapp> I felt the same about Dvorak. I don't know that it's any faster objectively, but I feel as though I type with less effort.
21:52:14 <zomg> Hodapp: you'll hate yourself after you read about how colemak is both easier to learn and better than dvorak
21:52:17 <zomg> :D
21:53:19 <zomg> although the most impressive keyboard thing I saw so far which is apparently even faster was some weird typing thing where you'd type by pressing "chords" with the keyboard
21:53:31 <zomg> I forgot what it was called but supposedly you could be extremely fast with that once you learn it
21:53:40 <johnw> my apologies for derailing the channel, but this really isn't the place for keyboard discussion
21:53:54 <zomg> well not like there's any other discussion taking place right now
21:54:25 <johnw> erisco's question was never resolved I don't think
21:54:32 <johnw> although I think a Bifunctor may be just what he wants
21:54:59 <erisco> yes I am looking at bifunctor
21:55:13 <erisco> thanks
21:55:20 <schlegel> zomg: You mean like stenotyping?
21:55:35 <zomg> schlegel: yeah I think that was exactly the thing :)
21:55:50 <dhrosa> anyone have anything about my basic cabal problem?
21:57:02 <lightquake> zomg: that's how steno works
21:57:32 <lightquake> you have a keyboard that looks like http://en.wikipedia.org/wiki/File:Stenkeys.gif
21:57:58 <zomg> Yeah, there was some program that you could use with a standard PC keyboard to do the same
21:58:13 <zomg> as long as the keyboard had NKRO of course
21:59:34 <dhrosa> alternate question, is there a way to download a package using cabal without installing it?
21:59:48 <dhrosa> I want to see what functioning .cabals and directories look like
21:59:53 <zomg> dhrosa: I think you can use `cabal fetch`
22:00:10 <zomg> not sure if it'll do exactly what you want, but it should fetch packages without installing
22:01:28 <dhrosa> found another solution, all the installed stuff goes into ~/.cbal
22:05:25 <schlegel> dhrosa your Hardware.hs SHould be in the SHiny directory
22:07:52 <dhrosa> schlegel: I just managed to fix that problem, but now, I want my top-level module to be Shiny, if I have Shiny/Shiny.hs, it complains about the file name not matching the module name, if I bring Shiny.hs to the same directory as Shiny, it complains it can't find the source for Shiny/Shiny
22:09:14 <dhrosa> here's the updated directory structure: http://lpaste.net/97673 (I removed the src folder)
22:09:27 <dhrosa> the module name in Shiny.hs is Shiny
22:12:42 <bmuk> I know this is rather abstract, but are there functions which cannot be written in a point free style? or can any function be written this way?
22:15:04 * hackagebot x509-validation 1.4.7 - X.509 Certificate and CRL validation  http://hackage.haskell.org/package/x509-validation-1.4.7 (VincentHanquez)
22:15:07 * hackagebot x509-util 1.4.2 - Utility for X509 certificate and chain  http://hackage.haskell.org/package/x509-util-1.4.2 (VincentHanquez)
22:16:06 <johnw> bmuk: if your function need to pattern match a constructor for which there is no accessor function, then I believe you need the "point" to case match on
22:16:50 <bmuk> okay, thanks johnw!
22:17:39 <johnw> and record field updates too
22:17:50 <johnw> if you don't have a lens
22:21:31 <bmuk> could you help me take the lambdas out of this function? I started with a do block and turned it into this, but I think that there should be a way to do it without the lambdas
22:21:34 <bmuk> http://lpaste.net/4814845096878931968
22:22:50 <simpson> bmuk: What's wrong with using do-notation?
22:23:17 <johnw> parseAtom = Atom <$> (liftM2 (:) (letter <|> symbol) (many (letter <|> digit <|> symbol)))
22:23:34 <bmuk> :simpson I just personally think it looks ugly compared to without
22:24:02 <bmuk> :simpson also I just read this http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
22:24:59 <bmuk> thanks johnw, do you think it is more readable the other way or this way?
22:25:10 <bmuk> :t (<$>)
22:25:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:25:30 <johnw> bmuk: that is entirely subjective
22:28:18 <bmuk> I know this is a non sequitor but can $ replace () always or is () needed to group in some cases
22:28:31 <mauke> (x, y)
22:28:49 <joelteon> (obviously) can't pattern match on $
22:29:19 <negatratoron> 1 * (2 + 3)
22:29:42 <mauke> > (1 *) $ 2 + 3
22:29:43 <lambdabot>  5
22:29:52 <simpson> edwardk: I'm not sure, but can Text.Parsers.Expression handle multiple postfix operators? I think that it can't; I'm having trouble parsing calls of calls `thing()()` using it.
22:30:22 <bitemyapp> ocharles: any intent to do anything with that elasticsearch shim you made?
22:30:55 <bmuk> is there any way to use $ in "liftM (x . y) (a b)"?
22:31:03 <bitemyapp> ocharles: I have need to talk to an ES instance from Haskell, wasn't super happy about the only library being a single file I'd need to vendor.
22:31:16 <mauke> liftM (x . y) $ a b
22:31:31 <bmuk> but you always have to have it with function compositon?
22:32:34 <negatratoron> you can also use . of course
22:32:55 <bmuk> liftM . x . y?
22:33:10 <negatratoron> . for function composition, I mean
22:33:25 <johnw> well, in this case, x . y `liftM` a b
22:34:13 <bmuk> is that common practice?
22:34:22 <johnw> sometimes, all depends on the coder
22:34:35 <simpson> edwardk: Yeah, confirmed; it doesn't work. I'll sleep on it and see if perhaps there's another way to formulate this.
22:34:35 <mauke> x . y <$> a b
22:34:49 <johnw> mauke: that imposes a Functor constraint
22:36:13 <bmuk> @hoogle (<$>)
22:36:13 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
22:36:13 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
22:36:37 <joelteon> there does not exist a monad without a functor instance
22:36:39 <mauke> johnw: better than Monad
22:36:50 <johnw> well, he had already used liftM, but yeah
22:37:25 <bmuk> is there really no monad without a functor instance?
22:37:43 <negatratoron> yeah, you can define fmap in terms of >>= and return
22:37:46 <Axman6> fmap f a = liftM f a
22:38:17 <trillioneyes> bmuk: currently it's possible to define a monad instance without defining a monad instance, but in future versions (the next, I think?) of GHC it will not be possible anymore
22:38:46 <trillioneyes> And yes, every monad CAN have a valid functor instance, whether it happens to be implemented or not
22:39:15 <trillioneyes> *without defining a functor instance
22:40:06 <trevor> hello
22:40:08 <bmuk> what exactly is a functor?
22:40:08 * hackagebot yesod-bin 1.2.5.4 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.5.4 (MichaelSnoyman)
22:40:10 * hackagebot warp-tls 2.0.0.1 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-2.0.0.1 (MichaelSnoyman)
22:40:58 <johnw> bmuk: http://en.wikipedia.org/wiki/Functor
22:41:29 <johnw> you can think of them as things which are "mappable"
22:41:43 <bitemyapp> bmuk: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
22:41:52 <trevor_> hello
22:41:56 <bitemyapp> johnw: you should specify that you don't necessarily mean lists when you say "mappable"
22:42:05 <bitemyapp> johnw: or associative data structures.
22:42:08 <johnw> yeah, that's why I did the air quotes
22:42:09 <bitemyapp> or collections at all.
22:42:32 <bmuk> how can you map over something that isn't a collection?
22:42:33 <bitemyapp> johnw: well fine but you need to get specific with people or they slap whatever remotely familiar proxy that is in their head if you don't actively dismiss it.
22:42:46 <bitemyapp> bmuk: functions in mathematics map from inputs to outputs.
22:43:01 <ion> Is that the horrible post that talks about “returning a monad” etc?
22:43:04 <bitemyapp> bmuk: that's what makes them pure - that's all they do. Total functions specifically always have at least one output for all inputs.
22:43:16 <bmuk> so we aren't talking about map as in map f xs
22:43:27 <bitemyapp> that's what I just went to the trouble of trying to avoid.
22:43:32 <rejuvyesh> Hello
22:43:34 <johnw> bmuk: in the case of lists, we are; in the case of other things, we aren't
22:43:42 <bitemyapp> it's going to get more confusing when you see that there's a Functor instance defined for []
22:44:14 <Cubesoup> I think it's fine to say "map" when not talking about lists
22:44:16 <rejuvyesh> I am quite new to haskell programming, and was trying to convert an existing python program to a haskell one.
22:44:28 <Cubesoup> for example it's pretty obvious what the map for trees does
22:44:29 <bitemyapp> bmuk: look at the Functor instance for Maybe.
22:44:30 <bmuk> well if we are talking about mapping domains to ranges what isn
22:44:37 <bmuk> what isn't a functor?
22:44:51 <bitemyapp> bmuk: http://www.haskell.org/haskellwiki/Functor
22:44:58 <bitemyapp> bmuk: anything that doesn't obey the laws or isn't applicable.
22:45:09 * hackagebot yesod-platform 1.2.5.3 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.5.3 (MichaelSnoyman)
22:45:12 <bmuk> :bitemyapp can I look at that with lambdabot?
22:45:15 <bitemyapp> functors are pretty generic. You can slap them on a lot of stuff.
22:45:29 <bitemyapp> bmuk: http://www.haskell.org/hoogle/?hoogle=Maybe start clicking.
22:45:35 <bmuk> thanks
22:45:37 <mauke> bmuk: Integer
22:45:54 <rejuvyesh> I was using Network.HTTP.Conduit. The code is here: http://lpaste.net/97674
22:45:55 * bitemyapp snorts at mauke
22:45:59 <johnw> bmuk: are you familiar with the term "map" in the mathematical usage?  where a function A -> B is a mapping from A to B?
22:46:15 <negatratoron> "mappable" here is talking about a map function with type (a -> b) -> f a -> f b, not any domain to any range
22:46:24 <negatratoron> a fmap function really
22:46:34 <zRecursive> Ts is called morphism ?
22:46:37 <bitemyapp> that's not really what I said.
22:47:45 <Clint> rejuvyesh: and wha's your question?
22:48:07 <rejuvyesh> But the problem is that while checking for responseStatus I am always getting 200 rather than 303. The python code is here: http://lpaste.net/97675
22:48:20 <bmuk> :johnw yes I am familiar with that usage
22:48:51 <bmuk> :t fmap
22:48:51 <rejuvyesh> Clint: that's the relevant part of python code. Entire code is here: https://github.com/sid0/firewall-auth/blob/master/firewall-auth.py
22:48:51 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:49:22 <johnw> bmuk: so, a functor maps two things.  It maps types, like Int to Maybe Int, where Maybe is the functor doing the mapping.  And it maps function, specifically functions A -> B to Maybe A -> Maybe B, again using Maybe as an example.  Anything which can do both of these things, has a kind of * -> *, and obeys the functor laws, is a Functor in Haskell.
22:50:23 <johnw> concrete types, like Integer, are never functors
22:50:39 <trevor_> I have just started getting into haskell and have liked many concepts it brings but when dealing with large lists of arrays what is the best way to get the equivalence of array[5]=3;   ?
22:50:42 <johnw> because Integer isn't mapping types, it's always just that single type
22:50:53 <zRecursive> In category theory, is it called morphism ?
22:51:00 <johnw> zRecursive: is what called morphism?
22:51:06 <zRecursive> functor
22:51:13 <bmuk> Am I thinking in the wrong direction with a "map" data structure? Keys and Values? Can't you think of a function like that or a lookup table?
22:51:14 <johnw> in Haskell terms, a function is a morphism
22:51:25 <johnw> a functor is a mapping of objects and morphisms from one category to another
22:51:41 <zRecursive> ok
22:52:29 <bmuk> so am I wrong to say that the Functor instance for the IO monad could map Strings to IO Strings?
22:52:40 <negatratoron> bmuk: I would say a functor is a container for data of a certain type.  There can be lots of data, or no data, or the data can be not here yet.  You can compute with the data using fmap, but it's not necessarily easy or possible to get concrete data out of the functor.
22:52:52 <johnw> no, not wrong at all, since it also has an instance of Functor and obeys the laws
22:52:59 <johnw> but mapping String -> f String alone is not enough
22:53:16 <johnw> negatratoron: IO is not a container
22:53:22 <johnw> never think of functors as containers
22:53:30 <negatratoron> why not?
22:53:31 <bmuk> it also has to satisfy associativity and id, correct?
22:53:36 <johnw> because they're often not anything like containers
22:53:41 <negatratoron> that's true
22:53:44 <johnw> /bin/ls does not contain a list of file names :)
22:53:50 <johnw> and it's type would be IO [String]
22:53:59 <johnw> bmuk: that's Monoid you're thinking of
22:54:23 <Clint> rejuvyesh: sorry, i don't have the time to read python right now
22:54:47 <johnw> now, specific instances of Functor are of course exactly like containers
22:55:00 <yggr> where is a good place to start learning about web development stuff with Haskell?
22:55:07 <bmuk> hackage said that laws where fmap id == id
22:55:17 <rejuvyesh> Clint: Just see the relevant part I pasted
22:55:20 <negatratoron> placeholder would be a better word than container
22:55:21 <johnw> (some instances, I mean)
22:55:25 <bmuk> and  fmap (f . g) == fmap f . fmap g
22:55:37 <negatratoron> yeah, some instances are
22:55:39 <Cale> bmuk: yes
22:55:50 <bmuk> isn't that also id and associativity just like monoids?
22:56:03 <rejuvyesh> Clint: http://lpaste.net/97675 <- See just this
22:56:05 <Cale> Well, that's not exactly associativity
22:56:12 <Cale> Though it's also not unrelated
22:56:22 <rejuvyesh> Clint: http://lpaste.net/97675 <- See just this
22:56:23 <satc> I have two values a :: Maybe String, b :: Maybe String. I want to do call f when either of them is Nothing else call g. Is there a better way over using nested maybes or case ?
22:56:42 <Cale> Associativity is that  (a * b) * c = a * (b * c)
22:56:50 <bmuk> oh, associativity would be (f . g) .h == f . (g . h)
22:56:59 <bmuk> yes
22:56:59 <johnw> satc: maybe (const f) (const g) (a <> b)
22:57:04 <Cale> However, (.) is a special case of fmap :)
22:57:16 <mauke> satc: you can fuse on the outside
22:57:18 <johnw> oh, that won't work
22:57:25 <satc> :t (<>)
22:57:26 <lambdabot> Monoid m => m -> m -> m
22:57:28 <bmuk> :Cale ... haskell blows my mind.
22:57:30 <satc> thanks ..
22:57:44 <mauke> like what johnw said but without the mappend
22:57:54 <bmuk> so all composition is functors at work
22:57:57 <Cale> and so we do indeed have  fmap f (fmap g x) = fmap (fmap f g) x
22:58:01 <bmuk> :t (.)
22:58:02 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:58:25 <Cale> The types though are very different from the types involved in a monoid
22:58:30 <mauke> > Just () `mplus` Nothing
22:58:31 <lambdabot>  Just ()
22:58:37 <Cale> (those aren't all the same fmap)
22:58:52 <mauke> > liftA2 (,) (Just ()) Nothing
22:58:53 <lambdabot>  Nothing
22:59:12 <johnw> mauke: nice
22:59:12 <Cale> bmuk: "a ->" is the functor here
22:59:38 <Cale> Or (->) a  to use actual Haskell syntax
22:59:53 <bmuk> is there a time where this all just clicks? lol
23:00:01 <Cale> Yes, I think so :)
23:00:17 <mauke> c++ may have ctors but we have more fun
23:00:25 <Cale> Well, maybe not, maybe you get one piece at a time :)
23:00:39 <Cale> :t fmap
23:00:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:00:48 <Cale> If f x = e -> x
23:00:49 <johnw> bmuk: yes, there most certainly is a time when it all clicks
23:00:51 <Cale> then this becomes
23:00:59 <Cale> (a -> b) -> (e -> a) -> (e -> b)
23:01:02 <johnw> bmuk: and the joy of that moment is worth every bit of frustration
23:01:03 <Cale> and that's the type of composition
23:01:26 <mauke> I,I Functor f => (a -> b) -> (f a -> f b)
23:01:31 <lpsmith> > liftA2 (,) (0 <=) (< 10)   -3
23:01:32 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
23:01:32 <lambdabot>    arising from a use of `M67933996423145717095599.show_M67933996423145717095...
23:01:32 <lambdabot>  The type variable `a0' is ambiguous
23:01:32 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
23:01:32 <lambdabot>  Note: there are several potential instances:
23:01:48 <Cale> You can think of a function of type (e -> a) as being a big container indexed by values of type e
23:01:49 <lpsmith> > liftA2 (,) (0 <=) (< 10)   (-3)
23:01:50 <lambdabot>  (False,True)
23:02:08 <bmuk> Cale: I've never seen -> outside type sigs or case statements. What is it doing here
23:02:13 <mauke> a map represented as its lookup function
23:02:16 <Cale> These are type signatures
23:02:23 <bmuk> oh ok
23:02:50 <bmuk> so in other words (e -> a) is a map with keys of type e and values of type a
23:03:11 <mauke> up to squinting
23:03:21 <jle`> > (,) <$> (0 <=) <*> (< 10) $ -3
23:03:22 <lambdabot>  (False,True)
23:03:39 <Cale> Yeah, you can think of it like that
23:04:22 <Cale> So you can think of function composition (somewhat asymmetrically) as applying a function to all the elements of that container
23:04:39 <Cale> Given a function (a -> b), and a function (e -> a), we get a function (e -> b)
23:04:40 <bmuk> so how would you write fmap as .?
23:04:56 <Cale> Well, you have:
23:05:03 <Cale> instance Functor ((->) e) where
23:05:07 <Cale>   fmap = (.)
23:05:27 <Cale> > fmap (*10) (*10) 5
23:05:29 <lambdabot>  500
23:05:33 <zRecursive> :t ((->) e)
23:05:33 <lambdabot> parse error on input `->'
23:05:45 <Cale> :k (->)
23:05:45 <lambdabot> * -> * -> *
23:05:51 <Cale> :k (->) Integer
23:05:52 <lambdabot> * -> *
23:06:01 <Cale> :k (->) Integer String
23:06:02 <lambdabot> *
23:06:10 <Cale> :k Functor
23:06:11 <lambdabot> (* -> *) -> Constraint
23:06:22 <bmuk> what is :k
23:06:34 <Cale> It asks for the kind of a type-level thing
23:06:44 <Cale> (kinds are to types what types are to values)
23:07:09 <zRecursive> type's type ?
23:07:12 <mauke> type Mappe k v = k -> v; exercise: write empty :: Mappe k v; lookup :: Mappe k v -> k -> v; update :: (Eq k) => k -> v -> Mappe k v -> Mappe k v
23:07:13 <bmuk> okay so a functor looks like it takes a function and returns a constraint
23:07:31 <mauke> bmuk: no, not a functor. "Functor".
23:07:42 <bmuk> oops sorry ha
23:07:47 <mauke> :k Show
23:07:48 <lambdabot> * -> Constraint
23:08:05 <Cale> Functor is a type class which takes a type-level function as its argument
23:08:06 <bmuk> this is different from show
23:08:12 <mauke> Show "takes" a type and returns a constraint
23:08:27 <Cale> for example, like Maybe
23:08:30 <Cale> :k Maybe
23:08:31 <lambdabot> * -> *
23:08:34 <mauke> thus (Show a) is a constraint
23:08:36 <Cale> :k Integer
23:08:37 <lambdabot> *
23:08:43 <Cale> :k Maybe Integer
23:08:43 <lambdabot> *
23:08:47 <bmuk> :k Monad
23:08:47 <lambdabot> (* -> *) -> Constraint
23:08:49 <Cale> * is the kind of types which have values
23:08:53 <mauke> :k Show Maybe
23:08:54 <lambdabot>     Expecting one more argument to `Maybe'
23:08:54 <lambdabot>     In a type in a GHCi command: Show Maybe
23:09:07 <Cale> Constraint is the kind of things which can occur in the left of => to constrain type variables
23:09:32 <bmuk> :k Monoid
23:09:32 <lambdabot> * -> Constraint
23:09:52 <zRecursive> Why can "deriving Show" making any data support showing without writing any code ?
23:10:07 <johnw> it can't do it for any data
23:10:11 <Cale> zRecursive: Because the compiler contains special code to write that code for you
23:10:27 <johnw> data Foo a b = Foo (a -> b) deriving Show, what does that do?
23:10:35 <johnw> > show (+1)
23:10:36 <lambdabot>  "<Integer -> Integer>"
23:10:37 <mauke> cry
23:10:38 <Cale> (and yeah, not *any* data type, only ones all of whose fields are instances of Show)
23:10:40 <johnw> oh, I guess it can
23:10:48 <mauke> johnw: hand written
23:10:52 <johnw> ah
23:11:13 <frx> > show (+)
23:11:15 <lambdabot>  "<Integer -> Integer -> Integer>"
23:11:22 <mauke> > 1 2
23:11:23 <lambdabot>  Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
23:11:24 <lambdabot>    arising from the ambiguity check for `e_112'
23:11:24 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
23:11:24 <lambdabot>    bound by the inferred type for `e_112':
23:11:24 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
23:11:29 <zRecursive> then the code snippet johnw gave is wrong ?
23:12:03 <zRecursive> "deriving Show" doesnot work here
23:12:06 <Cale> wow, such defaulting, very Integer
23:12:13 <frx> how did they write that show? did they have to write new instances for a -> a, a -> a -> a, etc?
23:12:21 <mauke> zRecursive: that is the point
23:12:29 <Cale> frx: I think it uses Typeable
23:12:37 <Cale> > typeOf (+)
23:12:38 <lambdabot>  Integer -> Integer -> Integer
23:12:44 <Cale> :t typeOf
23:12:44 <lambdabot> Typeable a => a -> TypeRep
23:12:45 <mauke> > show show
23:12:46 <lambdabot>  "<() -> [Char]>"
23:12:51 <Cale> TypeRep has a Show instance
23:13:06 <johnw> mauke: why did you cry?
23:13:19 <mauke> johnw: I did not
23:13:25 <frx> I think he was telling you to cry :)
23:13:25 <johnw> 01:07 <mauke> cry
23:13:30 <Cale> Maybe he was telling someone else to cry :)
23:13:32 <johnw> haha
23:13:34 <mauke> <johnw> data Foo a b = Foo (a -> b) deriving Show, what does that do?
23:13:39 <johnw> ah
23:14:05 <Cale> It hopes to use a Show instance for functions, and if it doesn't find one, complains :)
23:14:25 <zRecursive> it should show "* -> *" ?
23:14:42 <Cale> hm?
23:14:47 <Cale> * -> * is a kind
23:15:24 <zRecursive> then no instance for "data Foo ..." is created by compiler ?
23:15:43 <Cale> zRecursive: Not sure what you're asking here
23:16:07 <zRecursive> Cale: i mean "data Foo a b = Foo (a -> b) deriving Show"
23:16:40 <zRecursive> if the compiler will create an Show instance for Foo
23:19:59 <bmuk> Where can I learn category theory from the ground up?
23:20:23 <zRecursive> cry :)
23:20:29 <bmuk> haha
23:23:06 <levi> bmuk: You could try here: https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
23:24:07 <johnw> bmuk: this is not a bad place to start: http://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories/dp/052171916X/ref=sr_1_fkmr0_1?ie=UTF8&qid=1388301655&sr=8-1-fkmr0&keywords=intro+to+conceptual+mathematics+lawvere
23:24:35 <levi> Yeah, that definitely starts from the ground up.
23:27:10 <bmuk> thank you all very much
23:30:13 <levi> Steve Awodney, the lecturer from the UOregon summer school video, has a textbook he offers for free via link there that is aimed at math and CS undergrads/grad students coming to category theory without a lot of the math background typically assumed.
23:31:46 <johnw> that very cool, I didn't realize he made that available for free download
23:32:05 <levi> I didn't either until I started watching the videos. :)
23:34:04 <levi> It looks like it moves a bit faster than Conceptual Mathematics, which almost seems aimed at the advanced high school level, and it seems geared towards the aspects of Category Theory that you're likely to run across in Haskell-related discussions.
23:34:49 <mada> I'm following "write yourself a scheme"
23:35:03 <mada> trying to write a function that'll parse a string literal, taking into account possible quote escapes inside
23:35:05 <mada> http://lpaste.net/97676
23:35:30 <mada> but it's still stopping when finding the \" string
23:35:43 <joelteon> yeah, because you need a dollar sign after many
23:35:55 <joelteon> or use many (noneOf "\"" <|> escapedCharacter)
23:36:41 <mada> joelteon: that brings up a type error, noneOf parses a char while escapedCharacter parses a string
23:36:45 <joelteon> ok
23:36:52 <joelteon> escapedCharacter = string "\\\"" *> char '"'
23:37:03 <joelteon> oh, wait
23:37:06 <joelteon> that's not right
23:37:09 <joelteon> string "\\\"" <$ '"'
23:37:10 <joelteon> :t (<$)
23:37:11 <lambdabot> Functor f => a -> f b -> f a
23:37:17 <joelteon> damn, that's not right either.
23:37:23 <joelteon> '"' <$ string "\\\""
23:37:43 <joelteon> mada: the point is you can parse \", but then return the char "
23:37:46 <mada> joelteon: is it possible that, without lookahead, when noneOf fails, escapedCharacter receives only the rest of the input?
23:38:06 <mada> having already skipped \"?
23:38:12 <joelteon> the problem is that x is either a single escaped character or a lot of characters that aren't "
23:38:14 <joelteon> but not both
23:38:50 <joelteon> mada: did you see what I said earlier about grouping noneOf "\"" and escapedCharacter?
23:39:05 <mada> right
23:39:11 <joelteon> right
23:39:20 <mada> many should go over the entire choice
23:39:23 <joelteon> right
23:39:32 <joelteon> so what you could do for escapedCharacter is something like this:
23:39:33 <dv-> http://lpaste.net/97677
23:39:46 <joelteon> escapedCharacter = do { string "\\\""; return '"' }
23:39:49 <joelteon> because that'll typecheck
23:40:26 <joelteon> and that way, your parsed string literal isn't all full of escape characters
23:40:29 <mada> right, returning the actual character
23:40:38 <mada> same as dv- pasted
23:40:43 <joelteon> also, you need to account for escaping the backslash character, if i'm not mistaken
23:41:35 <mada> thank you both
23:49:21 <Komier> you guys use 4 or 8 spaces when indenting in Haskell?
23:49:47 <Komier> seens lots of mention of the importance of whitespace but not found any "style guide" type document yet.
23:49:53 <bmuk> so what exactly is the difference between liftM and fmap?
23:50:25 <lispy> Komier: there is one by johan tible, but I'm not a huge fan of the advice there
23:50:39 <lispy> Komier: I indent 2 spaces
23:51:57 <Komier> lispy: ok thanks.  Just wondered if I was missing something, as every tutorial seems to mentiont he importance of whitespace, without saying exactly what it should be.
23:52:08 <roboguy_> 8 spaces seems like a lot
23:52:22 <lispy> bmuk: basically the types are different, but the functor instance should agree with the monad instance. eg., they should match up.
23:52:48 <mada> does that extend to pure?
23:52:50 <bmuk> but what do they do that is different?
23:53:01 <lispy> Komier: here is an example of my style: https://github.com/dagit/haray/blob/master/src/Graphics/Rendering/Haray/Camera.hs
23:53:17 <roboguy_> bmuk: nothing. the fact that liftM exists is basically a historical accident
23:53:22 <lispy> Komier: just ignore the #ifdefs. I don't normally use CPP but I'm doing some weird stuff in that file defining opencl and haskell.
23:54:03 <bmuk> roboguy_: so does that mean that fmap is preferred to liftM
23:54:25 <Komier> lispy: Thanks, I'm very much a beginner so the code is beyond me there anyway, but it's very neat and easy to read so I think I might follow a similar style.
23:55:04 <roboguy_> bmuk: well, unfortunately, it is possible to have a type that has a Monad instance but not a Functor instance, because Functor is not a superclass of Monad (yet). All Monad instances *can* have a Functor instance, but it isn't enforced yet that it actually has one
23:55:17 * hackagebot yesod-bin 1.2.5.5 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.5.5 (MichaelSnoyman)
23:55:28 <lispy> Komier: I use vim and that makes it easy for me to maintain things in columns. And the reason I do that is so that I can edit similar lines together
23:56:01 <roboguy_> bmuk: so if you have "Monad m => ...", you need to use liftM since it doesn't know if it has a Functor instance from just that type class context
23:57:31 <Komier> lispy:  I'm using sublime text  with SublimeHaskell plugin.  It allows for similar column management and conversion of tabs to spaces and things.  Should be doable I think.
23:59:52 <lispy> Komier: here is Johan's style guide. I don't agree with a lot of it, but I feel like I should still mention it to you: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
