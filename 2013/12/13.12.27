00:05:03 <dsrx> adnap: everything on typeclassopedia is fun (to me, anyway...) and useful too, since many of them are ubiquitous in the standard library
00:06:01 <adnap> dsrx: I am reading http://www.haskell.org/haskellwiki/Foldable_and_Traversable and it is not turning out very good. It is explaining the classes in metaphors and not showing any example implementations for functions, such as foldr, at all
00:07:01 * hackagebot http2 0.1.0 - HTTP/2.0 library including HPACK  http://hackage.haskell.org/package/http2-0.1.0 (KazuYamamoto)
00:09:01 <dsrx> adnap: http://www.haskell.org/haskellwiki/Typeclassopedia#Instances_and_examples
00:10:24 <joejev> why am I getting a parse error on '=' with this? http://lpaste.net/97587
00:10:26 <joejev> for the second =
00:10:26 <dsrx> I think trees are sort of the standard example for Foldable
00:11:11 * hackagebot hslogstash 0.3.6 - A library to work with, or as, a logstash server  http://hackage.haskell.org/package/hslogstash-0.3.6 (SimonMarechal)
00:11:11 * hackagebot http2 0.1.0 - HTTP/2.0 library including HPACK  http://hackage.haskell.org/package/http2-0.1.0 (KazuYamamoto)
00:12:09 <dsrx> joejev: missing a closing paren on line 2
00:12:14 <dsrx> er, never mind
00:15:59 <jrw> joejev: don't you need a comma between record fields?
00:16:49 <joejev> jrw: oh god, yes
00:17:58 <joejev> jrw: thanks
00:18:51 <jrw> np
00:34:34 <bmuk`> I don't know if this is the right channel to be asking this, but I'm looking for anyone who would like to codevelop a medium to large haskell project with me. My primary motivation is to learn more about haskell and hacking on large projects.
00:45:44 <Saizan> maybe you could find a project you like on github and start from there?
00:47:26 <bmuk`> That is true. I was thinking more of a ground up thing though; from what I've seen most large haskell projects have all or most features implemented and are really more about maintaining what is there and correcting bugs
00:53:43 <jrw> bmuk`: why are you looking for a codeveloper, if you don't mind me asking?
00:56:01 <bmuk`> jrw: I haven't really ever worked with anyone else and would like the experience
00:56:13 <bmuk`> mainly for fun as well
00:57:34 <jrw> those are good reasons.
00:57:45 <bmuk`> jrw: plus I think I could learn a lot from working with someone who has more experience than me, or teaching someone who does not
00:58:42 <jrw> I was just thinking that if you are mainly trying to learn more, the most important thing is just to write a lot of code. and to work on things you're interested in.
00:59:18 <jrw> bmuk`: if you can find someone, that sounds great. my guess is that it will be hard to find someone. in that case, I suggest finding something you want to implement, and try to do it yourself.
00:59:32 <jrw> this channel is a great place to get help and to teach :)
00:59:58 <bmuk`> That is true, I have already gotten a lot of help from here! :)
01:00:10 <jrw> bmuk`: what kind of stuff are you interested in?
01:01:35 <bmuk`> well I am interested in AI and Machine Learning as abstract concepts, but those would require much more knowledge than I have to implement. Languages and Language learning. Interpreters/compilers and virtual machines all interest me
01:02:36 <jrw> interpreters and compilers are great to implement in haskell. I highly recommend it.
01:03:17 <jrw> bmuk`: maybe you've already seen this: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
01:03:25 <bmuk`> I was thinking about a python optimizer similar to pypy
01:03:37 <bmuk`> I have seen it and it is on my toRead list!
01:04:26 <jrw> your idea is good too. be careful not to get too caught up in parsing, though. maybe there's a library already for parsing python?
01:04:56 <bmuk`> I know that hackage has several on turning it into an ast and so forth
01:08:37 <joejev> I am using the newest version of gloss and I just got this error when trying to run something:  stroke font 0x401dee88 not found, do you know where to get this font?
01:11:30 <jrw> joejev: the gloss homepage recommends upgrading freeglut to latest version. have you done that?
01:12:21 <joejev> yes
01:34:04 <goraci> hi there, so it appears that haskell doesn't have hashmap as basic type?
01:34:39 <dsrx> > lookup "foo" [("foo", 23)]
01:34:40 <lambdabot>  Just 23
01:34:46 <dsrx> > lookup "bar" [("foo", 23)]
01:34:47 <lambdabot>  Nothing
01:34:52 <goraci> there is Data.Map type which is [('name','dave')]
01:34:58 <Philonous> @hackage unordered-containers
01:34:58 <lambdabot> http://hackage.haskell.org/package/unordered-containers
01:35:14 <goraci> so it is just list of tuples
01:35:32 <Philonous> goraci, No, Data.Map is internally represented as a tree
01:36:10 <Philonous> See unordered-containers for proper hashmaps
01:38:12 <goraci> Philonous: hmm ok it's just a package ) but why [('name','dave')] cann't be a hashmap ?
01:39:24 <Philonous> goraci, You can use it like one of you're OK with linear access, possibly duplicate elements and the fact that it doesn't hash it's keys
01:39:28 <dsrx> for one thing, there's no hashing going on :V
01:39:31 <Philonous> its*
01:40:32 <goraci> lookup is from that package
01:41:50 <dsrx> Data.Map.lookup is for things of type Data.Map.Map
01:42:05 <goraci> and in other langs we can have duplicate keys
01:42:10 <dsrx> the lookup in scope  on lambdabot is probably the prelude one
01:49:00 <goraci> hmm no duplicate keys not allowed at least in ruby and clojure )
01:49:42 <goraci> so how i should constract HashMap ?
01:52:33 <passiveobserver> I'm trying to cabal install hs-logo and I get "rejecting: base-4.6.0.1/installed-f0c... (conflict: hs-logo => base>=4.2 && <4.6)"
01:53:20 <johnw> sounds like it hasn't been ported to 7.6.3
01:53:37 <johnw> you can usually download hs-logo's source code, edit the upper bound to <5, and cabal install it directly
01:54:01 <johnw> I look forward to the day when cabal has a command-line option for doing that sort of thing
01:54:25 <Cale> I look forward to the day people don't put unconfirmable upper bounds on their packages
01:54:52 <Feuerbach> johnw: it already has
01:54:53 <johnw> but then don't the PVP gremlins come and put coal under your pillow or something?
01:54:57 <Feuerbach> --allow-newer
01:55:06 <johnw> woohoo!   is that option released yet?
01:55:14 <Feuerbach> no, it's in git master
01:55:57 <Feuerbach> oh, and I just checked — no coal under my pillow yet
01:59:21 <haasn> edwardk: I think there's a version in the lens documentation, even :)
02:00:02 <haasn> oh, for the reverse (hex -> char)
02:00:37 <haasn> (Of course, I used a lens version which I most likely did send to #haskell to generate the string in the first place)
02:01:13 * hackagebot metadata 0.1.6.0 - metadata library for semantic web.  http://hackage.haskell.org/package/metadata-0.1.6.0 (KatsutoshiItoh)
02:02:21 <xintron> Which would be the fastest way to (case insensitive) check if a string contains any of `list of strings`? regex or map the list of strings and compare `elem` against the string?
02:03:25 <haasn> :t \s -> any (isPrefixOf s) . tails
02:03:26 <lambdabot> Eq a => [a] -> [a] -> Bool
02:04:21 <xintron> ah
02:04:32 <johnw> xintron: yeah, I'd use regex-applicative and build a match against all the candidate strings
02:05:00 <haasn> :t \s -> any (\x -> any (`isPrefixOf` x) s) . tails
02:05:01 <lambdabot> Eq a => [[a]] -> [a] -> Bool
02:05:01 <haasn> I would use something like this, anyway
02:05:05 <johnw> haasn: that's pretty expensive, isn't it?
02:05:29 <johnw> O(m*n) it looks like
02:06:14 * hackagebot magma 0.2.1.0 - magma is an algebraic structure consisting a set together with an binary operation.  http://hackage.haskell.org/package/magma-0.2.1.0 (KatsutoshiItoh)
02:06:53 <haasn> johnw: there are probably faster versions based on a grep-like scanning approach, I guess?
02:07:47 <haasn> this one is reasonably lazy at least, in all parameters
02:16:59 <mirpa> Is there some program to visualize functions using Arrows? Like diagrams in haskell.org/arrows/syntax.html tutorial.
02:23:24 <goraci> there has to be "answebot"
02:23:34 <goraci> for questions without an answers ))
02:23:44 <goraci> "answerbot"
02:25:58 <mirpa> like the Eliza? hmm.. :-)
02:26:03 <Geraldus> Hello buddies! I still unable to solve my problem with Type-Eq on OS X Mavericks, thus I'm going to reinstall all thing (Platform, cabal and etc.). Is there some manual to completely uninstall Haskell Platform, cabal and all installed libraries related to them?
02:28:06 <Geraldus> Oh, I've found it ) http://www.haskell.org/pipermail/haskell-cafe/2011-March/090170.html
02:28:16 <FliPPeh> Is there a way to take my monad into a new thread? :v
02:28:30 <FliPPeh> Since forkIO is IO () I'd have to strip it off
02:29:28 <FliPPeh> Although I'm fairly certain I can't just modify the state monad of the main thread from another thread..
02:29:47 <FliPPeh> So I guess using IPC is the preferred way here, right?
02:30:18 <Hafydd> If by "IPC" you mean "thread synchronisation primitives", it's the only way.
02:30:31 <FliPPeh> I thought more along the lines of TChans
02:30:45 <Hafydd> Primitives or things made with them.
02:31:29 <bennofs> Is there a way to tell cabal to only enable those tests / benchmarks that are buildable (meaning their dependencies are installed)?
02:32:30 <FliPPeh> Well the problem I have is that when I fork off threads that handle some client, they no longer have access to the main program state
02:32:47 <FliPPeh> Or only a copy that is outdated fairly quickly
02:32:53 <Hafydd> You could put the state in a TVar or an MVar.
02:33:03 <Hafydd> (Or the part of it that needs to be shared)
02:35:15 <hyoukarou> hi, one question: head [x | x <- [m,m-1..0], 600851475143 `mod` x == 0] where m = 100   -> why ghci says that "parse error on input `where'"?
02:35:58 <FliPPeh> "where" in GHCi is dodgy
02:36:03 <FliPPeh> Although "let ... in ..." works
02:36:19 <hyoukarou> umh.. ok thanks
02:36:39 <adelbertc> let.. in is an expression whereas where is part of syntax that can only be used in certain places
02:37:11 <hyoukarou> but where is more cool :D
02:37:43 <hyoukarou> (maybe cooler? buh)
02:37:45 <adelbertc> heh - i tend to favor where when i'm doing things like map someFunc someList where someFunc = ...
03:05:53 <johnw> bennofs: not that I know of
03:07:37 <bennofs> Hmm, I'd really like to see the cabal dependency resolver as a library :|
03:11:08 <FliPPeh> Say I have N threads and in order to send every thread some message over a TChan, is there some magic where I can put one message into one TChan and have every thread read it, or is the obvious "N channels for N threads" or "1 channel with N messages for N threads" the only solution?
03:11:34 <FliPPeh> Come to think of it, the last one is stupid, scratch that
03:13:25 <bennofs> FliPPeh: I think there is a way to "broadcast" messages
03:13:50 <haasn> FliPPeh: isn't that the point of dupTchan?
03:13:57 <bennofs> In particular, newBroadcastTChan
03:14:49 <johnw> I believe it is exactly the point of dupTChan
03:15:10 <johnw> "this creates a kind of broadcast channel, where data written by anyone is seen by everyone else"
03:15:34 <FliPPeh> That seems perfect!
03:15:45 <johnw> ah, I see why you'd want to use newBroadcastTChan
03:15:54 <johnw> (but in any event, you use it in conjunction with dupTChan)
03:16:41 <FliPPeh> So create a newBroadcastTChan and give dupTChan's to the reading ends?
03:16:45 <johnw> yep
03:16:48 <passiveobserver> can someone help me with installing hs-logo? I've downloaded, changed base<4.7, did cabal install
03:16:49 <FliPPeh> Many thanks!
03:17:21 <passiveobserver>     No instance for (Show LogoFunction)
03:17:23 <passiveobserver>       arising from the 'deriving' clause of a data type declaration
03:17:34 <passiveobserver> sry for spam.
03:19:16 <passiveobserver> now I get: src\Logo\Types.hs:36:14: No instance for (Show LogoFunction) arising from the 'deriving' clause of a data type declaration  Possible fix: add an instance declaration for (Show LogoFunction) ...
03:19:28 <FliPPeh> Well
03:19:37 <FliPPeh> It just means that you cannot print a LogoFunction value
03:19:47 <FliPPeh> There is no usable string representation of it
03:20:12 <bennofs> FliPPeh: It's a problem in the source of hs-logo
03:20:14 <FliPPeh> Apparently you have a LogoFunction in your own Data declaration
03:21:09 <FliPPeh> Unrelated: I love it when the sole description of a package is just a link to a research paper somewhere
03:21:17 <FliPPeh> It's way too widespread in Haskell
03:21:34 <bennofs> What package are you using? :O
03:21:53 <passiveobserver> cabal install hs-logo
03:22:03 <bennofs> I meant FliPPeh
03:22:08 <FliPPeh> bennofs: In this case, STM
03:22:17 <FliPPeh> But RWST is another offender
03:22:35 <bennofs> There are a lot of tutorials on STM
03:23:25 <bennofs> They could link the fpcomplete tutorial from hackage
03:23:30 <passiveobserver> so if anyone can help me compile hs-logo that'd be much appreciated that way I can learn me some more haskell
03:25:34 <yesthisisuser> i guess rich documentation is not the strongest part of the Haskell ecosystem
03:25:40 <bartavelle> it really depends on the packages, many of them have great documentations
03:25:50 <bartavelle> and a lot of them don't need it at all, which is even better ;)
03:26:28 <lelf> Hi. Is there any sane way to update part of matrix in repa?
03:26:32 <bennofs> And we have #haskell :)
03:26:38 <passiveobserver> bartavelle: no they need if they want the language to propagate - python has a little example in the end of each module documentation that's the culture of it
03:27:24 <Rembane> Examples rock!
03:27:36 <bartavelle> I agree that always adding sample usage is really good, but i have the utmost trouble finding my way in python documentation
03:27:38 <passiveobserver> neither haskell nor ocaml admittedly have no
03:28:08 <passiveobserver> maybe it's a matter of time
03:28:28 <bartavelle> I'll start by adding some in my packages, that can't hurt
03:29:01 <bennofs> We could write a program to automatically check that the examples compile and produce the expected output! (like doctest, but for larger pieces of code)
03:29:40 <bennofs> What I think is missing from python documentation is an easy way to access the source code of a function. I do that a lot in haskell
03:30:02 <bennofs> But in python, some functions are implemented in C so it's not so easy
03:30:07 <bartavelle> bennofs, a lot of packages have an outdated "examples" sub-directory
03:30:21 <bartavelle> perhaps a cabal thingie would be helpful there
03:30:30 <bennofs> Well, I was thinking of adding it to the bottom (or top?) of each module
03:30:36 <bennofs> As a comment
03:30:47 <bartavelle> oh yes, but for some packages you can get into pretty involved examples
03:31:01 <bartavelle> that might not be a good fit to the documentation
03:31:10 <bartavelle> anyway, that might be only a small part of the packages
03:31:53 <bennofs> Or maybe only check that the examples compile and load them into GHCi? so you can embed sample function definitions in your documentation and show them in action with a special GHCi tag?
03:33:03 <quchen> When you find a package without examples and you end up using it anyway, why not send a small patch afterwards? I'm sure it will be accepted
03:33:26 <quchen> A lot of non-exampled documentation is because the author doesn't need them I think
03:35:39 <merijn> FliPPeh: tbh, the STM paper is very easy to read and incredibly helpful
03:37:50 <bartavelle> merijn, just having a tex-based pdf open in the browser when you are looking for documentation is scary for many people
03:37:58 <bartavelle> and I am one of them :)
03:38:08 <merijn> bartavelle: Sure, I'm not saying it's good to not have documentation
03:38:22 <merijn> I'm just trying to dispel the notion of "I'm a beginner, haskell papers are too hard"
03:38:27 <Philonous> quchen, Sending patches is often a pain for non-github packages
03:38:34 <merijn> I found many haskell papers to be incredibly accessible
03:38:47 <quchen> Philonous: True. But most packages are on Github these days.
03:39:03 <bartavelle> oh that's not my point, I feel like "haskell papers are going to drag me through useless details where I just want a quick HOWTO"
03:39:07 <quchen> Philonous: Well, "True" in the sense of "if you don't have email".
03:39:40 <merijn> bartavelle: Sure, but I actually think a "quick HOWTO" for STM is bad, not understanding how STM works is a good way to screw yourself over by, e.g. accidentally creating a thundering herd problem
03:39:55 <bartavelle> merijn, that is entirely true
03:40:10 <quchen> merijn: Thundering herd problem?
03:40:44 <merijn> quchen: 100s, 1000s, or more threads blocking on a lock all being woken up simultaneously when only one can acquire the lock
03:40:52 <merijn> quchen: It's an OS/systems term
03:41:09 <merijn> quchen: https://en.wikipedia.org/wiki/Thundering_herd_problem
03:41:38 <quchen> merijn: Funny name, but it fits :-)
03:41:42 <merijn> quchen: The result is your efficiency goes to hell because you spend almost all your time waking up and blocking threads, rather than doing real work
03:41:58 <merijn> MVar/Chan only wake up a single thread, thus avoiding the problem
03:42:33 <merijn> STM wakes up all blocking threads, therefore it's undesirable to use STM when you have large numbers of mostly idle threads/transactions blocking on a single TVar/TChan/etc
03:43:50 <navaati> morning
03:44:01 * quchen has used some hacks with a MVar bottleneck in an STM chain to avoid that. Not sure how dirty I should feel
03:44:19 <merijn> quchen: Sounds completely reasonable to me
03:44:43 <quchen> Lucky me! :-)
03:45:47 <merijn> The way STM works makes it best when conflicting operations happen infrequently, because then the overhead is a small constant factor. If you have lots of competition/conflicting operations then it actually becomes more and more inefficient
03:45:56 <navaati> is ghc-mod aware of cabal sandboxes ?
03:48:04 <navaati> i'm asking because i'm testing it right now and it can autocomplete identifiers from the libs, but not identifiers from the module i'm editing
03:52:40 <FliPPeh> How much of a problem is it to use GHC-only features and extensions, in practice?
03:52:52 <navaati> FliPPeh: not much
03:52:55 <FliPPeh> Are there other big implementations to worry about by now?
03:53:04 <FliPPeh> I know of Hugs but that doesn't seem too widespread
03:53:20 <navaati> not really, except if you're in an educationnal context. Maybe
03:53:47 <navaati> and... ghc is so tasty... how can one resist ?
03:54:45 <FliPPeh> I'm even more fond of GHCI!
03:55:27 <Hafydd> You're more fond of GHCi than GHC? That's rare.
03:55:49 <FliPPeh> Well, I do most of my development by testing whatever I just built in GHCi
03:56:25 <Hafydd> I could understand if you were more fond of GHCi than is offered by other HCs.
03:58:17 <bennofs> if I have a module Data.Text in my module search path, and I also use the text package (-package text), which will GHC choose?
03:59:59 <navaati> bennofs: i think it won't choose, it will yell
04:00:18 <bennofs> Trying it out ...
04:01:23 * hackagebot stm-firehose 0.1.3 - Conduits and STM operations for fire hoses.  http://hackage.haskell.org/package/stm-firehose-0.1.3 (SimonMarechal)
04:02:04 <bennofs> navaati: seems it will use the one from -i
04:03:47 <bennofs> Oh, there is a difference if I do this from a compiled file or from ghci? :O
04:05:31 <bennofs> Ah no, there is no difference. I made the mistake of leaving a space behind "-i" :P
04:08:34 <Geraldus> Ohh, this makes me crazy! Type/Eq/Higher.hs:72:86:     Illegal literal in type (use -XDataKinds to enable): 1
04:09:52 <Hafydd> Geraldus: the meaning of the error seems pretty transparent to me: you've used a literal where a type is expected. If it isn't obvious, why don't you paste the code in question?
04:16:36 <Geraldus> Hafydd: this error occurs when I try to install Fay (while installing dependency Type-Eq)
04:17:47 <ifesdjeen> is there any good tutorial on how to use Data.Map with a State monad?
04:18:32 <bennofs> ifesdjeen: What do you expect from such a tutorial? You can just do modify $ Some map operation here
04:18:37 <bennofs> @ty modify
04:18:38 <lambdabot> MonadState s m => (s -> s) -> m ()
04:18:43 <bennofs> @ty M.insert
04:18:44 <lambdabot> Ord k => k -> a -> M.Map k a -> M.Map k a
04:18:54 <bennofs> @ty modify (M.insert 3 4)
04:18:55 <lambdabot> (Num k, Num a, Ord k, MonadState (M.Map k a) m) => m ()
04:19:11 <ifesdjeen> bennofs: I'm aware how to use data.map, just can't figure out how to put it together with MonadState
04:19:21 <bennofs> @ty modify (M.delete 3)
04:19:22 <lambdabot> (Num k, Ord k, MonadState (M.Map k a) m) => m ()
04:19:38 <ifesdjeen> e.g. type signatures and so on
04:20:05 <bennofs> ifesdjeen: What operations do you want to do with the map state?
04:20:22 <ifesdjeen> bennofs: i assume mutation of the map
04:20:30 <ifesdjeen> bennofs: and retrieval of current state
04:20:42 <Hafydd> Geraldus: I see. I don't know why that is, but if I had to guess, I'd say your version of GHC is too old for that package.
04:20:44 <bennofs> ifesdjeen: Well, you can do that with 'get' and 'put'/'modify'
04:20:52 <ifesdjeen> i see
04:21:24 <Geraldus> Hafydd: I have only 7.6.3
04:21:50 <donri> Geraldus: did you try the CPP suggestion?
04:22:39 <bennofs> ifesdjeen: The state monad is explained in lyah: http://learnyouahaskell.com/for-a-few-monads-more#state
04:23:06 <Geraldus> donri: yes, I tried both manual and autopatching, I just reinstalled all entire platform and still have issue. So, now, I'll try to brew install Platform (
04:23:17 <ifesdjeen> thanks bennofs! reading it
04:23:44 <donri> Geraldus: maybe try using gcc instead of clang
04:23:50 <donri> merijn: didn't you have a working setup?
04:24:38 <bennofs> ifesdjeen: Note that the 'State' value constructor doesn't exist anymore. You have to use the 'state' function
04:24:47 <Geraldus> donri: you mean to download and build GCC?
04:25:00 <ifesdjeen> ah, that explains what I had problems with bennofs, good to know!
04:25:51 <donri> Geraldus: i don't know what i mean because i don't use os x :) maybe you brew it, dunno
04:27:38 <Geraldus> donri: :)
04:56:34 <merijn> donri: of?
04:57:08 <donri> merijn: Geraldus is having problems that appears to be related to clang cpp on os x. could you perhaps try and help them?
04:57:23 <merijn> oh, OSX. Yes, but I have 10.7
04:58:06 <Geraldus> donri: thanks! )
04:58:14 <merijn> I usually update OSX fairly late so I don't have to solve all the childhood diseases :p
04:58:45 <f-a> when I run cabal haddock in a library I am packaging it warns me "Warning: The documentation for the following packages are not installed." (and then list of package, including hyphenation-0.4. I tried "cabal install --reinstall hyphenation", but no dice. What should I do?
04:58:54 <Geraldus> merijn: Hi, I'm installing entire platform with brew at this moment, following this giude: http://haskell-workshop.github.io/tutorials/osx/2013-10-23-mavericks-ghc.html
04:59:07 <merijn> f-a: Is "Documentation: True" set in your cabal config file?
04:59:08 <donri> f-a: cabal install --enable-documentation
04:59:26 <Geraldus> merijn: So, when I finish, I'll let you know about results.
04:59:28 <donri> or add that line merijn suggested to ~/.cabal/config
04:59:53 <merijn> It's too bad the new platform release is in a bit of limbo
05:00:16 <merijn> One of the main bikeshedding issues for it seems to be how to handle the new "no-gcc" OSX version
05:00:28 <f-a> merijn: .. no. I hope I don't have to do a mass reinstall like for profiling stuff :s
05:02:53 <f-a> aaand I haven't. Thanks merijn
05:11:56 <sajt_> can I do something like newtype myType = (Eq a b) => (a, b)?
05:11:57 <Geraldus> merijn: D'you here? )
05:12:27 <f-a> other question. I am uploading a package to hackage. Should I add .cabal files, Setup.hs to the darcs repo?
05:12:40 <f-a> (sorry if it is naive, I only have used repos for myself until now)
05:13:13 <bennofs> f-a: you should add .cabal and Setup.hs, yes
05:13:28 <sajt_> or to put it another way: can I require a typeclass for my newtype type parameters
05:13:34 <f-a> thanks bennofs
05:13:44 <bennofs> f-a: Btw, why are you using darcs? Often, it is easier for contributors to contribute if you use github / bitbucket
05:13:53 <f-a> I am using darcs, yes
05:14:30 <f-a> (you meant "darcs add zyx", right? Not just uploading the files, am I wrong?)
05:14:44 <bennofs> Yeah, add them to your revision control
05:14:57 <f-a> bennofs: I am using darcs because it's the first vcs I learned to be honest
05:15:11 <f-a> never touched git but it seemed more complex at the time
05:15:49 <donri> sajt_: there's DatatypeContexts, but it's considered bad practice and don't know if it works for newtypes.
05:15:54 <sajt_> what I want to do is give an alias to (Eq a, b) => (a, b)
05:16:16 <donri> sajt_: and your constraints don't really make sense
05:16:24 <bennofs> f-a: Github would also have the advantage that you can use travis-ci to automatically compile and test your package on different versions of GHC after each commit :)
05:16:33 <sajt_> donri: what do you mean?
05:16:55 <donri> sajt_: do you mean (Eq a, Eq b) => (a, b) ?
05:17:15 <sajt_> donri: yes, sorry
05:17:55 <f-a> I see. I will put that on my to-learn list.
05:19:01 <FliPPeh> If I read Control.Concurrent correctly, forkIO'd thread will always terminate with their main thread?
05:19:04 <sajt_> donri: could I create an alias for that?
05:19:34 <donri> sajt_: yes, there are ways, but why do you want it? there might be a better answer
05:20:42 <FliPPeh> What happens if a thread forked with forkIO spawns more threads using forkIO? Will those threads then die if the thread that created them is killed, but the mainthread is still alive?
05:22:05 <sajt_> donri: I have two types implementing my typeclass and I need to pass a tuple of them in a few places
05:22:12 <bennofs> FliPPeh: I don't think GHC threads have a "parent" relationship, so I guess they won't die.
05:22:36 <navaati> FliPPeh: is there something such as a "main thread" anyway ?
05:22:53 <sajt_> donri: I didn't want to create a record type, because fst and snd are perfectly fine names for accessing them
05:23:10 <Hafydd> There is a "main" thread - it's the thread executing Main.main.
05:23:30 <bennofs> Is there a partitionM somewhere?
05:23:36 <donri> sajt_: putting the constraints in a datatype will only force you to put the constraints on any function that takes the datatype. you can use an existential to capture the constraints but then that means you can *only* use the functions given by those constraints, on those types
05:23:47 <Hafydd> The first such thread, that is.
05:24:03 <navaati> Hafydd: interesting. and does the runtime scheduler (if there is such a thing) run in this thread only, too ?
05:24:41 <FliPPeh> navaati: According to the documentation for Control.Concurrent, there is a main thread
05:25:00 <Hafydd> navaati: by default in GHC, the runtime scheduler, as well as all threads, run in a single OS thread.
05:25:02 <navaati> FliPPeh: ok. it was a genuine question :)
05:25:14 <sajt_> donri: ok, let's say you have a source and a target for some operations and how to operate on a source or a target is defined in a typeclass
05:25:21 <navaati> Hafydd: ah, yeah. but with the threaded runtime ?
05:25:34 <sajt_> donri: you always have to pass them pairwise and they always need to implement the typeclass
05:26:06 <donri> sajt_: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ might be worth a read
05:26:21 <Hafydd> navaati: I don't know, but I'd have to guess that parts of runtime code run in all non-foreign OS threads.
05:26:53 <sajt_> donri: thanks, I'll read this and get back to you...
05:27:57 <donri> sajt_: another option is to make an alias for the constraints themselves using ConstraintKinds: type Operate a b = (SourceOp a, TargetOp b)
05:28:16 <donri> sajt_: then you can write function types like :: Operate a b => (a, b) -> ...
05:32:15 <kinslayer> simpleHttp returns TlsException so how can I add a certificate for a site ?
05:39:33 <sajt_> donri: interesting read and I see the point. although it makes sense for the example in the post to use ordinary functions, i still like the type class version for my case
05:40:43 <f-a> http://hackage.haskell.org/package/linebreak-0.1.0.1/candidate <-- I am making experiments with candidates. Question. Why isn't Text.LineBreak clickable here? It is when I cabal haddoc my local version.
05:41:18 <bennofs> f-a: It means that hackage hasn't build the docs for your package yet
05:42:15 <f-a> thanks again bennofs
05:43:08 <sajt_> donri: couldn't I write functions like :: Operands -> ... where Operands means (Operate a, Operate b) => (a, b)?
05:44:43 <geekosaur> no
05:45:11 <geekosaur> you can build a type alias that does that, the problem is that it really means (forall a b. (Operate a, Operate b) => (a,b))
05:45:25 <geekosaur> which means if you use it twice, the as and bs don't match up
05:46:45 <sajt_> geekosaur: ok, maybe with a parametrized data type declaration then?
05:47:17 <geekosaur> I think that just puts you back where you started...
05:47:26 <Rarrikins> Are there any nice ways to have data that lazily updates itself via IO? For example, if a web page gives several pieces of data and the program requests one piece but it's more than 3 seconds old, it will get the web page, fill in all the updated values, and return the requested value.
05:49:08 <sajt_> geekosaur: I see, well thanks anyway!
06:01:32 * hackagebot linebreak 0.1.0.1 - breaks strings to fit width  http://hackage.haskell.org/package/linebreak-0.1.0.1 (fffaaa)
06:01:33 <sajt_> regarding my previous question, how about this: data Operands a b where Channel :: (Show a, Show b) => a -> b -> Operands a b
06:02:14 <sajt_> using GADTs I could define my operations like myOp :: Operands a b -> ...
06:02:24 <sajt_> any downsides to this?
06:15:38 <sajt_> seems to work great anyhow
06:21:33 <kinslayer> so why is it that scotty isn't able to install ?
06:22:28 <kinslayer> somehow wai-extra wont build since system.log.fastlogger doesn't export logStrBuilder, but how can I mend this error ?
06:46:25 <PepperPhD>  f
06:50:43 <Athas> Is there a variant of readProcessWithExitCode that uses Text (or ByteString) rather than String?
07:09:13 <lingxiao> does anyone know of any good implementation of untyped lambda calculus in haskell?
07:12:56 <armlesshobo> lingxiao: are you looking for any type of example in particular?
07:13:42 <lingxiao> well the simpler the better, but pretty open minded in general
07:15:17 <lingxiao> for example here's a good one: http://www.andres-loeh.de/LambdaPi/LambdaPi.pdf
07:15:46 <lingxiao> but it's on dependantly typed lambda calculus, so an untyped version of something similar would be nice
07:20:02 <Rarrikins> Are there any libraries that will retrieve data using an IO a function and cache it for a period of time before retrieving it again?
07:20:21 <armlesshobo> lingxiao: i'm afraid i'm not able to help you with this one :\
07:20:45 <lingxiao> armlesshobo: all good, thanks for responding!
07:21:38 <bennofs> Is there a package that provides a map-like data structure, but on lookup, only give the best match? (Where best match means longest common prefix, I'll be using lists as keys). I was thinking of using tries, but maybe there's already a package for that?
07:21:57 <mirpa> Rarrikins: perhaps some sort of memoaziation
07:22:12 <mirpa> *memoization :-/
07:22:15 <Rarrikins> mirpa: I'll check into that. Thanks :)
07:45:48 <FliPPeh> What's the major difference between a TVar and a TMVar?
07:48:28 <frihd_> FliPPeh:  look at the api
07:48:45 <Philonous> FliPPeh, TVar behaves like an IORef, TMVar like an MVar
07:48:54 <frihd_> tvar is lowlevel
07:49:26 <frihd_> whereas tmvar is higher level, allows for (e.g., "block" until a value is in the TMVar)
07:50:55 <frihd_> tmvar can be "empty or full", tvar do not have these semantics
07:51:51 <Philonous> (TMVar a) is basically a (TVar (Maybe a)) with retries in the appropriate places
07:53:09 <Khendon> wow, busy channel
07:53:39 <Philonous> With singletons, how can I convince GHC that (a ~ b) given (a :== b)? Is that even possible?
07:54:06 <Philonous> I'm tempted to throw unsafeCoerce at the problem
07:54:55 <mm_freak> Philonous: the only way to convince GHC is by context or by unification
08:00:32 <sajt_> how does ghci know how to print my input? isn't the type of it ambigous?
08:01:01 <sajt_> s/ambigous/ambiguous
08:01:05 <mm_freak> sajt_: it has a few built-in rules
08:01:27 <sajt_> mm_freak: but it works for custom types as well, how does it do that?
08:01:34 <mm_freak> if the result is a (Show a) => IO a, then run it and if a ≠ (), display the result
08:01:49 <mm_freak> if the result is a (Show a) => a, then evaluate it
08:02:13 <sajt_> mm_freak: but I couldn't do this it in plain haskell, couldn't I?
08:03:25 <sajt_> mm_freak: maybe with existential types?
08:04:19 <m1dnight_> could somebody have a look at my Snap code? I'm using getParam but it keeps returning a nothing, and I can't figure out why
08:04:25 <m1dnight_> been looking at it for a few hours now :p
08:05:01 <mm_freak> sajt_: in principle you could
08:05:12 <mm_freak> for example with a type class
08:06:09 <sajt_> mm_freak: ok, thought so... thanks!
08:08:08 <Philonous> mm_freak, Turns out I was using the wrong Equality. I should have used propositional equality.
08:09:09 <mm_freak> Philonous: which uses unification =)
08:09:28 <FliPPeh> Gah, so I spent hours bolting a mutlithreaded JSON RPC server on top of my host program to expose an API to it
08:09:35 <FliPPeh> and it turns out my idea doesn't work :(
08:09:47 <Philonous> mm_freak, Yes, but they construct the proof for (a~b) with unsafeCoerce
08:10:03 <FliPPeh> Not unless I establish two connections per client and that's even more bolting on to do...
08:10:06 <Philonous> mm_freak, So I could have just checked the singleton and done it myself
08:10:21 <Philonous> mm_freak, But I guess I'd rather have it done inside the library
08:18:08 <mm_freak> Philonous: i'm not sure how the library does it, but the usual approach is:  data (==) :: * -> * -> * where refl :: a == a
08:18:26 <mm_freak> then when you pattern-match on 'refl' you learn that the two argument types are equal
08:18:42 <mm_freak> that's propositional equality
08:19:41 <Philonous> mm_freak, Of course. My point was that that the singletons library constructs Refl via unsafeCoerce
08:20:07 <mm_freak> well, i've never used the singletons library
08:20:30 <mm_freak> they probably know what they're doing, but it doesn't /sound/ right
08:21:01 <m1dnight_> guys, I have a guard put in my do, which works. Now I do want it to perform another action if the gaurd didnt go through, how would you recommend doing that? http://lpaste.net/97596
08:21:12 <m1dnight_> if you have the time please :)
08:23:29 <skypers_> woh
08:23:37 <skypers_> I just discovered a nice use of bimap
08:23:39 <skypers_> with break
08:23:43 <skypers_> it’s great :D
08:24:12 <skypers_> > break (==':') "key: value"
08:24:14 <lambdabot>  ("key",": value")
08:24:25 <skypers_> > bimap id tail $ break (==':') "key: value"
08:24:26 <lambdabot>  ("key"," value")
08:24:34 <skypers_> \m/
08:25:16 <skypers_> it could even be used with rmap I guess
08:25:43 <skypers_> well, second*
08:26:16 <skypers_> > second tail $ break (==':') "key: value"
08:26:17 <lambdabot>  ("key"," value")
08:28:59 <m1dnight_> can one have a function in haskell without parameters?
08:29:33 <m1dnight_> for my pickle with the guard there, i might return the rediret I want to do in a lambda or somethingÃ
08:29:45 <Hodapp> m1dnight_: A pure function?
08:29:46 <m1dnight_> and patternmatch if it is "[]", which means the guard has failed
08:30:08 <m1dnight_> or otherwise I get a lambda which I might then execute (without any params..)
08:30:28 <shachaf> Maybe the thing you want is called a value.
08:31:46 <m1dnight_> hrm
08:31:59 <skypers_> 17:25 < m1dnight_> can one have a function in haskell without parameters?
08:32:07 <skypers_> it’s called a value, actually
08:32:10 <skypers_> foo :: String
08:32:21 <m1dnight_> well yeah I understand
08:32:22 <m1dnight_> but
08:32:28 <skypers_> or you might be talking about action
08:32:29 <Philonous> Well,, it's not a function any more, though
08:32:33 <chreekat> What might make runghc fail to notice a particular binary package database? I ask this is a rather general way because it works as expected from the shell, but I'm trying to run it through some build system and I'm not sure it's being called with a popen or something
08:33:05 <skypers_> m1dnight_: even IO () is a value
08:33:07 <skypers_> not a function
08:33:08 <skypers_> so…
08:33:17 <m1dnight_> I have a function which does stuff. It pattern matches on a nothing, if that is so, it redirects to .... If not, it takes the deleteMe branch. In this branch there is a guard. So this branch can return [] (because of the guard)
08:33:24 <skypers_> you can see them as functions that don’t take any parameters
08:33:26 <m1dnight_> But if the guard fails, I still want to do something..
08:33:36 <skypers_> but it’s rather a value that anything else
08:33:41 <skypers_> because a function is also a value
08:34:05 <skypers_> m1dnight_: show some code please
08:34:42 <m1dnight_> http://lpaste.net/97596
08:34:43 <m1dnight_> http://lpaste.net/97596
08:34:48 <m1dnight_> woops, sorry
08:35:14 <skypers_> if the guard fails
08:35:19 <skypers_> you get mzero
08:35:23 <skypers_> which is Nothing for Maybe
08:36:26 <m1dnight_> so I have to use something else than a guard?
08:36:43 <skypers_> sorry can’t talk anymore, got to go
08:36:47 <skypers_> ttyl
08:37:01 <chreekat> here's the symptom of my problem: http://lpaste.net/97597
08:37:10 <fryguybob> m1dnight_: Perhaps you want  when  instead of  guard?
08:37:12 <fryguybob> @type when
08:37:13 <lambdabot> Monad m => Bool -> m () -> m ()
08:46:07 <dabd> I am looking at this ex from 'learn you a haskell'  sum (takeWhile (<10000) [n^2 | n <- [1..], odd (n^2)])
08:46:14 <dabd> how can I avoid writin n^2 twice?
08:46:20 <dabd> writing*
08:47:03 <monochrom> sum (takeWhile (<10000) [m | n <- [1..], let m = n^2, odd m])
08:48:07 <dabd> ty
08:48:23 <dabd> i guess the ex from the book is bad because haskell will compute n^2 twice?
08:48:35 <flazz> if i have a newtype T that wraps Int, how can I make an instance Arbitrary T, st. arbitrary is the same as Int but wrapped?
08:48:45 <monochrom> must you worry about that? at this early stage?
08:49:00 <flazz> for quickcheck that is
08:49:59 <donri> flazz: deriving (Arbitrary) with -XGeneralizedNewtypeDeriving
08:50:05 <monochrom> the ex is a hundred times worse than what you said, if you really worry about that. it is a ridiculously stupid algorithm to begin with. but is that the point? are you missing the point?
08:50:16 <kqr> dabd, that depends on the compiler and optimisation level
08:50:52 <flazz> donri: thanks, for my education is there a more direct way? i was trying to find some combinator to compose the Gen Int but it escapes me
08:50:57 <m1dnight_> fryguybob: that seems to work, but it executes the rest of the do block as well (renders two views)
08:51:00 <kqr> dabd, the two basic ways to check such things is to 1. read the optimised core code ghc produces or 2. run it against a clock
08:51:29 <donri> flazz: instance Arbitrary T where arbitrary = T <$> arbitrary
08:51:37 <donri> or, fmap T arbitrary
08:51:41 <navaati> monochrom: why is the algo horrible ?
08:51:54 <flazz> donri: thanks!
08:52:24 <flazz> where does <$> come from? Applicative?
08:52:32 <donri> @hoogle (<$>)
08:52:33 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
08:52:33 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
08:52:42 <donri> (it's just fmap infix)
08:52:44 <monochrom> it is more code than necessary and takes more time than necessary to compute 166650
08:53:01 <monochrom> the simplest and fastest code is simply "166650"
08:53:08 <donri> :)
08:53:11 <navaati> ...
08:53:13 <navaati> meh
08:53:29 <monochrom> but suppose you say "generalize from 10000 to an arbitrary input". that is still a dumb algorithm.
08:53:35 <navaati> anyway, doen't ghc do this optimization for you ?
08:53:36 <dabd> At this point in the book (which I am enjoying a lot btw) the author is introducing higher order functions and this example was to illustrate an alternative to using the filter fn. I was just wondering why did he write an ex with a redundant computation.
08:53:44 <monochrom> for starters, odd (n^2) = odd n.
08:54:21 <navaati> yeah, i was thinking about some optimisation of this sort, but fondamentally...
08:54:25 <monochrom> and then, there are efficient formulas for sums of odd squares
08:55:18 <navaati> oh. of course.
08:55:52 <navaati> so O(1) instead of O(n). yea
08:55:54 <donri> learn you an efficient algorithm design for great good
08:55:59 <monochrom> but the point of the example is list comprehension. "let's practice list comprehesion, even though the algorithm is dumb" is perfectly legitimate.
08:56:28 <monochrom> and once you accept that, you also stop nitpicking on how many times n^2 is re-computed
08:56:41 <fryguybob> m1dnight_: I'm not clear on what you want, but you can have whatever control flow you need.  If works fine, but can get ugly so there are lots of functions that make it a bit nicer.
08:56:47 <monochrom> you also stop speculating on optimizations
08:57:38 <monochrom> this whole "issue" is full of cognitive dissonance. "I worry about re-computing n^2 twice, I don't worry about dumb algorithms". what kind of logic is that?
08:57:38 <navaati> well his question does not only raise a concern of performance, but also one of DRY
08:58:13 <monochrom> pick one: worry about efficiency. don't worry about efficiency.
08:58:36 <monochrom> what is DRY?
08:58:49 <simpson> Don't Repeat Yourself. It's an agile thing.
08:59:11 <simpson> I prefer DRYING: Don't Repeat Yourself Ignorantly, Needlessly, or Gratuitously.
08:59:31 <monochrom> I prefer learning to walk before learning to run.
08:59:54 <donri> most people seem to miss the point of DRY though: it's not about terseness, it's about having a canonical definition for your constants
09:00:20 <monochrom> there will be a stage, later in the course of following LYAH, that will tell you how to refactor, how to reuse, etc. why worry now?
09:02:08 <rose_> Does anyone know of an implementation of read on a list of strings? e.g. read :: String -> [String]  like this: http://lpaste.net/97598
09:02:34 <monochrom> well, you can worry now, and you ask on #haskell, and you will get a good anwser. that's also perfectly legitimate. but why conclude that LYAH is giving a bad example? it is a perfectly good example in its context.
09:02:59 <monochrom> what's wrong with teaching you to walk before teaching you to run?
09:03:31 <kqr> rose_, add a type signature
09:03:32 <Philonous> > read (show ["hello", "there"]) :: [String] -- like this?
09:03:34 <lambdabot>  ["hello","there"]
09:03:44 <rose_> thanks
09:04:29 <saml> > read (show ['h','e','l']) :: String
09:04:30 <lambdabot>  "hel"
09:12:07 <spion> http://stackoverflow.com/a/20789478/110271 - does this look right, or is my understanding horribly wrong? :)
09:16:00 <navaati> donri: well yeah, that's the point of DRY (and i didn't know it was a 'agile' thing), do people really think otherwise ?
09:17:29 <donri> navaati: i get the feeling sometimes they do
09:17:50 <donri> maybe i'm just judgemental ^_^
09:18:45 <hpc> spion: it looks well enough; it's a bit pointless to be answering a question so old and well-covered though ;)
09:19:18 <monochrom> well, people definitely behave it. what they think depends on your philosophy. if you are like me, only observable things count, therefore what they behave = what they think.
09:20:20 <donri> :)
09:20:24 <hpc> monochrom: especially in code, where the observable result is so sensitive on abstract thought
09:20:34 <hpc> *sensitive to
09:30:49 <spion> hpc, I was trying a different approach though. Its okay if people don't find it useful, but I did want to make sure its not incorrect
09:30:51 <spion> :D
09:31:09 <monochrom> spion: the very idea of coding up a type class of kind *->* in a language that doesn't have kind *->* is horribly wrong to begin with.
09:31:50 <monochrom> but I haven't read your writing further.
09:33:07 <monochrom> if you don't know what I refer to in "kind *->*", here is a more concrete explanation.
09:33:45 <monochrom> start from Maybe Int. you can generalize that Int to a type variable, and say "Maybe t". most languages support that.
09:34:24 <monochrom> you can also generalize that Maybe to a type variable, and say "m Int". now most languages don't support that. but Monad, Functor, Applicative all require that.
09:34:46 <spion> yeah, I think I have that in a note at the bottom
09:34:57 <ivanacostarubio> Hello peeps! Would you please point me in the right direction why I am not able to install GLFW-b? http://pastie.org/private/yriuehgt0bku53pro2feg
09:35:13 <monochrom> coding up "Maybe t" in most languages is trivial. coding up "m t" in most languages is impossible.
09:36:30 <ernst> is there an equivalent to cabal --enable-shared I can use in  a .cabal file?
09:38:42 <spion> monochrom, yes, I tried to cover that with the note at the end, by saying that its most likely impossible to write an interface that would generalize all monads (in C#) and therfore code that works generically for all kinds of monads
09:38:46 <geekosaur> ernst: the template ~/.cabal/config should already have a commented-out "shared: False" in it? try uncommenting and changing the False to True
09:41:20 <ernst> geekosaur: thanks. I thought I had to set some option in mypackage.cabal; seems I've been looking in the wrong place all along
09:44:19 <geekosaur> oh, I may have misunderstood
09:44:27 <geekosaur> I think you can use a similar option in a cabal file
09:46:12 <geekosaur> hm, no, looks like you as developer do not get to specify
09:46:23 <geekosaur> probably because whether it even works is somewhat per platform
09:48:38 <rose_> I have a question about returning different values of the same data type: http://lpaste.net/97602
09:49:09 <ernst> geekosaur: so ghc-options: -shared -dynamic doesnt make much sense either?
09:49:57 <geekosaur> you can try but it probably means building will simply fail some places. also I think cabal wants to control static vs. shared for various reasons
09:51:45 <ernst> geekosaur: mh I'll keep it then for now (just starting to learn haskell). in my use-case I think I have to rely on shared objects though. I want to make a shared library that I can call from C
09:55:06 <Geraldus> I have a task, which I'll solve using two ways linked list with, say, Javascript. E.g. a have a ragged doll, which have different body parts, that also can contain nested parts. When I moving some deep nested parts I need to get coords of some points, local to that part I'm dealing with, in global coord system. So for each part I'd refer all its children and its parent. How to do that with Haskell (in functional way)?
09:59:35 <shachaf> Geraldus: Perhaps lenses are the answer.
09:59:41 <shachaf> Or perhaps zippers are the answer.
10:00:48 <shachaf> But since I can't quite tell, maybe the question is too vague to help with.
10:01:03 <Geraldus> shachaf: Oh, zippers is on my way soon, thanks. Just reading "Learn you a Haskell for Greater Good"
10:01:42 <shachaf> OK. Reading that chapter will probably be a good idea.
10:02:41 <Sgoettschkes> Short newby question: I'd like to use sqrt with an Int
10:03:07 <shachaf> Impossible.
10:03:09 <hpc> Sgoettschkes: numeric types are a bit OCD in haskell
10:03:11 <hpc> :t sqrt
10:03:13 <lambdabot> Floating a => a -> a
10:03:16 <hpc> :t fromIntegral
10:03:17 <lambdabot> (Integral a, Num b) => a -> b
10:03:23 <hpc> :t sqrt . fromIntegral -- what you want
10:03:23 <lambdabot> (Floating c, Integral a) => a -> c
10:03:26 <shachaf> An integer square root function is a different from thing a Floating square root function like Haskell has.
10:03:37 <Sgoettschkes> ok
10:03:41 <shachaf> You can pretend by converting back and forth. But that's often not so great.
10:03:49 <shachaf> hpc: That won't give you an Int.
10:03:51 <hpc> Sgoettschkes: if you need the result to be an Int too, pick how you round the result
10:04:00 <hpc> :t floor . sqrt . fromIntegral -- like this, perhaps
10:04:01 <lambdabot> (Integral c, Integral a) => a -> c
10:04:25 <shachaf> If you're starting with an Int, and you want to end up with an Int, going via Double may be a bad idea.
10:04:27 <Geraldus> shachaf: also found this http://www.haskell.org/haskellwiki/Tying_the_Knot
10:04:32 <quchen> hpc: round is probably better, flooring might be inaccurate when you're taking the root of a square
10:05:15 <shachaf> round might mean that if you square the thing you get you end up with a bigger number than you started with.
10:05:21 <Sgoettschkes> I'd need it rounded, so floor might need
10:05:26 <Sgoettschkes> work
10:05:27 <shachaf> Then again, anything can happen with floating points.
10:06:06 <hpc> > floor (0/0) :: Integer
10:06:07 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
10:06:27 <hpc> brought to you by bitwise operations!
10:08:21 <vektor> hpc: wtf?
10:08:30 <nadirs> shachaf, hpc, quchen: is there actually a solution to that or do we just have to accept it's the way it is?
10:09:04 <quchen> nadirs: There is no square root on the integers. If you want to define one, you'll have to worry about how to handle the corner cases (i.e. all non-square integers).
10:09:12 <monochrom> use Rational instead of Double. best of both worlds. oh wait, sqrt.
10:09:14 <quchen> An inefficient implementation would be trial division, for example.
10:09:32 <shachaf> A solution to what?
10:09:34 <quchen> Converting to Double is a hack, but often good enough (at least to give you a candidate).
10:09:44 <quchen> A solution to finding something square-rooty of an integer.
10:09:50 <monochrom> use binary search to find integer approximate square roots
10:09:52 <shachaf> If you want an integer square root function you'll have to get one. There isn't one in base but I imagine there's one in a library somewhere.
10:10:17 <nadirs> shachaf: to having to pass through floating-point whenever you have non-integer division
10:10:22 <shachaf> But you haven't even said whether that's what you want. I was only guessing. Bad habit.
10:12:31 <startling> monochrom, Ratio Rational might work.
10:12:52 <monochrom> is that even allowed?
10:13:11 <quchen> monochrom: Type-ically or morally? :-)
10:13:41 <shachaf> It kind-checks. But it does not work.
10:14:01 <shachaf> For almost anything you might want to do with it.
10:14:06 <startling> you don't get a Num instance, yeah.
10:24:43 <bennofs> @src foldr
10:24:44 <lambdabot> foldr f z []     = z
10:24:44 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:24:56 <dhrosa> @src foldl
10:24:56 <lambdabot> foldl f z []     = z
10:24:57 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:41:43 <kholdstare_> Hi! Does anyone know of any linear algebra libraries, with specializations for certain dimensions? e.g. 3D vectors, 3x3 matrices. So far I've used hmatrix, but there are no compile-time guarantees on dimensions
10:42:24 <shachaf> There is linear.
10:42:26 <shachaf> @hackage linear
10:42:26 <lambdabot> http://hackage.haskell.org/package/linear
10:43:56 <kholdstare_> shachaf: oooh, thanks I'll check it out
10:43:59 <Taneb> kholdstare_, there's also vect
10:44:02 <Taneb> @hackage vect
10:44:03 <lambdabot> http://hackage.haskell.org/package/vect
10:44:11 <Taneb> And probably others
10:47:32 <nadirs> a question about QuickCheck: I have two "model" functions, `fun1` and `fun2`, against which I want to test my own implementations
10:47:50 <kholdstare_> Taneb: thanks!
10:47:56 <nadirs> This is what I wrote (after reading chapter 11 of RWH) http://lpaste.net/97604
10:48:45 <nadirs> how do I write a function (main) that runs all these `prop_something` functions?
10:49:51 <kholdstare_> nadirs: you need a test framework
10:50:04 <supki_> nadirs: you generally use some testing framework (like tasty or hspec). Those make working with different tests providers convenient
10:50:38 <kholdstare_> @hackage test-framework
10:50:38 <lambdabot> http://hackage.haskell.org/package/test-framework
10:50:42 <kholdstare_> there's one
10:50:47 <bennofs> @hackage tasty
10:50:47 <lambdabot> http://hackage.haskell.org/package/tasty
10:50:51 <bennofs> @hackage hspec
10:50:51 <lambdabot> http://hackage.haskell.org/package/hspec
10:51:01 <nadirs> kholdstare_: I've used hspec previously, I think I'll go with it. I thought quickcheck was enough by itself :P
10:51:42 <kholdstare_> nadirs: cool. regarding tasty, there's a nice article on it here: http://ocharles.org.uk/blog/posts/2013-12-03-24-days-of-hackage-tasty.html
10:52:09 <nadirs> so I just do several "quickCheck x `shouldBe` y", right?
10:52:58 <nadirs> kholdstare_: thanks a lot for the help! (bennofs too!)
10:53:18 <speckle> hello, what are some good haskell IDEs as of this year? :) is leksah still the best GUI IDE?
10:54:20 <mada> thoughts on lamdu, speckle ?
10:54:26 <mada> or anyone else
10:54:34 <speckle> no clue, but I'll check it out, thanks!
10:54:39 <bennofs> lamdu is not a haskell ide
10:55:20 <speckle> I know there's someone who uses emacs with a theorem prover plugin, not sure if vim is as well-supported for those things
10:55:54 <YellPika> speckle: Sublime + SublimeHaskell works wonderfully for me
10:55:57 <bennofs> emacs works well for haskell too :)
10:56:51 <kholdstare_> checking in with obligatory vim
10:59:56 <speckle> huh, so people just use text editors with plugins rather than leksah or any other Haskell-specific IDEs? hmm..
11:01:13 <bennofs> I use emacs, have syntax highlighting/checking, hlint, ghci and identation. That's all I need :p
11:01:14 <fl00r> console vim with NERDTree here
11:01:31 <nadirs> probably emacs has the best support (I'm used to vim, so I that's what I use, it's quite handy with ghc-mod and syntastic)
11:01:42 <bennofs> hdevtools ftw! :)
11:01:57 * hackagebot threepenny-gui 0.4.0.2 - GUI framework that uses the web browser as a display.  http://hackage.haskell.org/package/threepenny-gui-0.4.0.2 (HeinrichApfelmus)
11:02:59 <fl00r> yeah...what nadirs said...i've only really ever tried vim because i'm used to it and i get cranky if i don't have those bindings
11:03:43 <kholdstare_> this post has a good roundup of haskell plugins for vim: http://blog.mno2.org/blog/2011/11/17/vim-plugins-for-haskell-programmers/
11:04:01 <kholdstare_> not all are necessary, but it's a good sampling, just to be aware of what's out there
11:05:00 <speckle> hdevtools? never heard of it, thanks!
11:05:17 <speckle> thanks kholdstare_ , I wasn't sure where to look
11:05:57 <fl00r> yep that's a nice link...vim-hoogle looks really cool
11:07:55 <kholdstare_> other plugins i'd suggest looking into is syntastic. if you have ghc-mod and hlint installed (actual executables) you get nice warnings/errors about your code including style suggestions.
11:08:27 <nadirs> kholdstare_: interesting link (even though serif font on code hurts me :-P )
11:08:46 <kholdstare_> nadirs: yes... i don't understand the font choice there
11:09:14 <kholdstare_> an alternative to haskellmode plugin: https://github.com/eagletmt/ghcmod-vim
11:09:36 <geekosaur> o.O looks like Solaris console
11:12:26 <dabd> a very basic question: I am trying to type the following multiline function in ghci https://gist.github.com/dabd/8151245. I surrounded it with :{ :} but then I get an error: parse error on input `|'
11:13:23 <geekosaur> you still need a `let`
11:13:30 <geekosaur> ghci is not ghc
11:14:01 <dabd> the example is from http://learnyouahaskell.com/syntax-in-functions#pattern-matching I thought it was supposed to be typed in ghci
11:14:03 <joejev> I am having a strange problem with gloss, whenever I close the window that it spawns, it crashes XMonad, I am not sure where the issue lies, be it gloss or XMonad
11:15:11 <dabd> How can I define a single line infix function. a `myAdd`b = a + b
11:15:41 <joejev> dabd: myAdd = (+) ?
11:15:42 <geekosaur> this looks like it intends you to put actual function definitions into a file and :load that (or ghci yourfile.hs)
11:15:51 <geekosaur> at the ghci prompt, things are different
11:15:55 <monochrom> have you read the section called "What you need to dive in"? it seems to expect you to load a file.
11:16:32 <monochrom> "The usual workflow for me when playing around in stuff is defining some functions in a .hs file, loading it up and messing around with them and then changing the .hs file, loading it up again and so on. This is also what we'll be doing here. "
11:16:43 <joejev> dabd: any 2 param function can be made infix by adding backticks around the name
11:16:53 <tromp> (>+<) = (+)
11:17:06 <geekosaur> but if you are doing it at the ghci prompt --- as opposed to in a file --- then you need `let`
11:17:10 <dabd> ok, ty I am used to lisp and I was trying to use ghci like a repl. But things are different with haskell
11:17:15 <tromp> > let (>+<) = (+) in 3 >+< 5
11:17:17 <lambdabot>  8
11:17:18 <jonasw> dadb: A ghci session is like being inside a do-block, hence the need for let
11:17:23 <Hafydd> > 1 `+` 2
11:17:24 <lambdabot>  <hint>:1:4: parse error on input `+'
11:17:32 <Hafydd> jonasw: false.
11:17:45 <Hafydd> joejev: false; jonasw sorry, wrong nick.
11:17:55 <monochrom> If you pay me cdn$10000 and wait 5 months, I can whip up a haskell repl for you.
11:18:16 <joejev> Hafydd: oh, symbols are infix by default
11:18:23 <monochrom> it can be done. it is just underpaid.
11:19:31 <Hafydd> monochrom: how will your Haskell REPL differ from ghci?
11:19:31 <monochrom> at any rate, since you say you're reading LYAH, I thought I would quote LYAH on you.
11:20:06 <bennofs> One thing I'd like to have for GHCi is proper multiline support
11:20:10 <dreamer1> hey
11:20:13 <monochrom> it will accept code without "let"
11:22:22 <bennofs> Does anyone know why you need 'let' in a do block? Would do a=b; c=d; ... be somehow ambigous?
11:22:46 <bennofs> ambiguous*
11:23:12 <joejev> bennofs: when desugared to sequence and bind, it might be
11:23:35 <nadirs> bennofs: because (at least, I think) "do" notation is syntactic sugar for CPS and "let"  declarations are the same as the ones in normal function definitions
11:23:53 <bennofs> nadirs: But let already is special, because there is no 'in' clause
11:24:09 <twanvl> does do { a = 1; b = 2; c } desugar to "let a = 1; b = 2 in c" or "let a = 1 in let b = 2 in c"?
11:24:33 <nadirs> bennofs: might it be because it's sugared? The same way carriage return means ">>=", no?
11:24:36 * geekosaur doesn't thinkt hat desugars to either one... :p
11:24:41 <monochrom> twanvl's question is my thought too of why it wants an explicit "let"
11:24:41 <quchen> twanvl: That desugars to a parse error.
11:24:50 <nadirs> *or (>>), depending on the context
11:24:52 <bennofs> twanvl: is there a difference
11:24:57 <bennofs> ?
11:25:23 <bennofs> Ah, I see. It has to do with recursive bindings
11:25:41 <monochrom> there are type-checking differences too
11:26:14 <bennofs> monochrom: Can you give an example?
11:26:29 <monochrom> I am too lazy to. but read the Haskell 2010 Report.
11:28:02 <monochrom> possibly section 4.5.1
11:28:57 <bennofs> Oh, probably monomorphism restriction?
11:29:03 <Srpx> Seriously, is lambda calculus without self-application ( `x x` ) turing-complete?
11:29:06 <monochrom> no, not about that. about grouping.
11:29:10 <speckle> whee, I love how easily I can calculate 2^200000 in ghci. Strangely, my terminal locked up *after* it calculated and displayed it, haha.
11:29:41 <speckle> gc problem? :P
11:29:56 <Srpx> Seems like people just ignore this particular question anywhere I ask, wtf.
11:30:16 <Srpx> I'm starting to consider there's a censured word or something on that phrase and it is not being sent
11:30:24 <monochrom> it may be solvable by just saying "consecutive ='s are put under one single let" and be done with it.
11:30:32 <speckle> sorry, Srpx, I'm relatively new to Haskell and I don't know lambda calculus well enough
11:30:44 <Srpx> no probs friend
11:30:55 <speckle> you were asking about lambda calculus without self-application, I did see that
11:31:11 <dreamer1> could someone help me out? script on the left, output on the right: http://i.imgur.com/PxO05XJ.png I'm trying to get a list of directories but its only giving me ., .. ? I'm a comlete noob in haskell
11:31:29 <Srpx> uh huh I was joking, but I'm surprised nobody knows that one.
11:32:01 <Srpx> I've asked in too many places already, I thought it would be an easy question
11:32:03 <geekosaur> dreamer1, this isn't really a haskell issue
11:32:06 <speckle> I'm actually surprised by how huge this channel is - I guess everyone is *trying* to learn Haskell :P
11:32:22 <Hafydd> monochrom: like ocaml's interpreter, then?
11:32:23 <dreamer1> geekosaur can you point me in the right direction :P ?
11:32:27 <monochrom> yes
11:32:31 <geekosaur> you get back from that function, or the C function underneath it, a basename. you need to prefix it with the path you got the listing from
11:32:46 <Srpx> speckle: you'd be surprised how many people actually know a lot about haskell here... haskell is the best language today so you'd guess
11:33:12 <speckle> seriously though does anyone know why ghci calculates and displays 2^200000 fine, but freezes up my terminal 10 or so seconds after it finishes the calculation?
11:33:30 <benbangert> if I have some functions that use randomness, is it usually better practice to keep them pure and pass in/out a StdGen, or just have them return an IO monadic value?
11:33:34 <twanvl> Srpx: what does 'no self application' mean?
11:33:37 <speckle> I made a recursive function that multiplies x-1 by 2, with a base case that returns 1 if x is 0
11:34:04 <bennofs> dreamer1: Your problem is that getDirectoryContents only returns the names of the directory contents
11:34:05 <quchen> speckle: It's a huge number. Many many GHCi pages long.
11:34:12 <Srpx> speckle: maybe the answer is too big for it to be displayed on the console? I also doubt it can calculate 2^200000 it would overflow everything
11:34:32 <dreamer1> bennofs: how would I make it work in haskell ?
11:34:33 <speckle> Srpx, the odd thing is that it displays just fine, it just locks up *later*
11:34:35 <bennofs> dreamer1: So suppose you have a/b, a/c and a/d and then do getDirectoryContents a, you only get ["c", "b", "d"].
11:34:35 <Srpx> I actually doubt it fits in your memory
11:34:42 <Srpx> seriously? let me think
11:34:44 <geekosaur> the same way you do it in C or in Python or etc.
11:34:49 <geekosaur> [27 19:28] <geekosaur> you get back from that function, or the C function underneath it, a basename. you need to prefix it with the path you got the listing from
11:35:17 <tromp> Srpx, replace (x x) by (x ((\y.y) x))
11:35:18 <speckle> why would it not fit in my memory? it shouldn't be over a megabyte
11:35:19 <geekosaur> you have a list of names WITHOUT the containing directory. youy have to add that back on yourself
11:35:20 <bennofs> dreamer1: Now your "doesDirectoryExist" only gets "c", "b", or "d". Because the path is relative to the argument of getDirectoryContents, this won't work.
11:35:30 <Hafydd> Computing 2^200000 took a few seconds to print out, but didn't cause any problems for me.
11:35:41 <monochrom> dreamer1: filterM (doesDirectoryExist . (path </>)) allItems. </> comes from System.FilePath
11:36:01 <joejev> Hafydd: works for me too
11:36:07 <speckle> yeah, it works fine then locks up later
11:36:28 <Srpx> tromp: still ilegal. (x ((λy.y) x)) -> (x x) -> boom
11:36:31 <speckle> maybe it's an issue with my terminal rather than with haskell
11:36:36 <speckle> whoa, lambda symbol in IRC
11:36:53 <Srpx> speckle: try to print 60k characters by some other mean... if it works then it is haskell, if not its the console
11:37:37 <Srpx> speckle: I have way too many symbols on my keyboard (: ☮
11:37:54 <speckle> okay, thanks Srpx
11:37:55 <tromp> Srpx, use fixed-point-combinator Y' = (λx. λy. x y x) (λy. λx. y (x y x))
11:38:26 <Srpx> tromp: let me try.
11:38:31 <bennofs> > 200000 / (log 10 / log 2)
11:38:32 <lambdabot>  60205.999132796234
11:38:34 <monochrom> at some point, you have to ask, "what exactly is 'lambda calculus without (x x)'."
11:38:50 <Srpx> tromp: that doesn't make sense, you're applying a 2 argument function to just one argument? it is incomplete I guess
11:38:59 <quchen> > logBase 10 (10^3) -- bennofs
11:38:59 <lambdabot>  2.9999999999999996
11:39:21 <tromp> no it works fine. try reducing Y' f x
11:39:28 <bennofs> > 200000 / logBase 2 10
11:39:29 <lambdabot>  60205.999132796234
11:39:32 <bennofs> :)
11:39:42 <tromp> or just Y' f
11:40:10 <Srpx> monochrom: just lambda calculus except you disallow a symbol to be applied to itself
11:40:23 <tromp> any Y such that Y f equals f(Y f) works as fixed point combinator
11:40:24 <Srpx> tromp: ok hold on
11:40:40 <twanvl> Srpx: disallow syntactically? Or does it not reduce?
11:41:16 <Srpx> twanvl: I guess both ways work?
11:41:22 <tromp> he doesn't want it come up in reduction
11:41:39 <monochrom> you have to say it explicitly. I don't know what you mean. I never do.
11:41:40 <twanvl> otherwise this would work: Y = \f.(\x.f ((\z.z) x x)) (\x.f ((\z.z) x x))
11:42:14 <monochrom> my point is that specifying a language is non-trivial. if your specification fits in twitter, you're doing it wrong.
11:43:00 <tromp> does lambda calculus fit in twitter?
11:43:16 <monochrom> well, the string "lambda calculus without (x x)" fits.
11:43:39 <Srpx> twanvl: that won't work, (λz.z) x will reduce to x and then you will have `x x`... I'm trying to test tromp 's but I don't have a good lambda calculator here, does anyone recommend one?
11:44:43 <tromp> how about http://www.ioccc.org/2012/tromp/hint.html :-?
11:46:13 <tromp> or http://lambda.jimpryor.net/lambda_evaluator/
11:46:22 <Srpx> holy... I can't believe you're that guy
11:46:25 <tromp> which points to several others
11:46:28 <sheenobu> whoa
11:46:33 <monochrom> if you have an implementation, you can already call it a specification, although it is not very high level, and more importantly it is unclear what is the goal and what is an implementation detail
11:49:29 <tromp> he wants a turing complete combinator basis which has the property that no term reduction results in self-application
11:49:51 <twanvl> Srpx: and what kind equality are you talking about? Syntactic? If so, then reduction order matters, because  K (I K) -> I K -> K or K (I K) -> K K -> explode
11:50:15 <Srpx> monochrom: I understand your point but did you really not understand what I meant? Visualize an interpreter for the binary lambda calculus that will error when it finds two identical indices being applied.
11:50:47 <monochrom> I really did not, the first 5 minutes after you first asked.
11:51:32 <Srpx> tromp: actually I want a untyped lambda calculus that is not turing complete. I've read somewhere that such holds for when you disallow self-application and took that as a truth, but now I'm merely confused
11:52:43 <mirpa> Is it possible to overwrite type class method?
11:53:13 <monochrom> what is an example of "overwrite"?
11:53:16 <mirpa> If it is defined like: f = error "not impl."
11:53:38 <mirpa> and I want to provide definition for f
11:53:56 <Tekmo> I don't think that is possible
11:54:18 <monochrom> inside Instance code?
11:54:33 <monochrom> nevermind. it can't be clarified.
11:54:39 <dreamer1> Not in scope: `endswith' , whats this from ?
11:55:14 <mirpa> monochrom: yes
11:55:18 <sleepynate> dreamer1: data.*.utils
11:55:29 <quchen> dreamer1: Are you looking for isSuffixOf?
11:55:39 <quchen> > isSuffixOf "world" "hello world"
11:55:40 <lambdabot>  True
11:55:55 <monochrom> endsWith may be in Data.List.Split
11:56:15 <tromp> you probably need a typed lambda calculus to avoid self-application
11:56:27 <dreamer1> from here http://therning.org/magnus/archives/228
11:56:38 <Srpx> monochrom: so I'm sorry, anyway I can't give a complete specification because I don't know how to.
11:57:05 <timthelion> >isSuffixOf [1..] [1..]
11:57:13 <timthelion> > isSuffixOf [1..] [1..]
11:57:18 <lambdabot>  mueval: ExitFailure 1
11:57:18 <lambdabot>  mueval: Prelude.undefined
11:58:19 <timthelion> @faq can haskell find whether one infinite list is a suffix of the other?
11:58:19 <lambdabot> The answer is: Yes! Haskell can do that.
11:58:25 <monochrom> dreamer1: do you now see the problem with presenting not-self-contained code such that a reader cannot reproduce the experiment?
11:58:43 <dreamer1> yes :D
11:59:51 <YellPika> Did lambdabot just blatantly lie?
12:00:16 <monochrom> that question is undecidable
12:00:37 <hpc> it can do it for some infinite lists, if you express them in very specific ways
12:00:49 <hpc> see seemingly impossible functional programs
12:03:52 <timthelion> hpc: well, I can certainly imagine that I could write a prover that is able to induce such things(I mean I didn
12:04:01 <timthelion> t write agda, but it's clearly possible)
12:04:29 <timthelion> hpc: but is there something "more interesting" that I'm missing?
12:05:06 <kqr> i assume the structures need to share thunks or something?
12:06:02 <timthelion> this? http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
12:08:55 <hpc> timthelion: yes
12:10:16 <hpc> to some extent, Cantor = [Bit], where the only elements of Cantor are infinite lists (and bottoms, which we ignore)
12:10:39 <hpc> math happens, and then you can compare those infinite "lists" for equality
12:11:20 <hpc> it's quite hard to explain (indeed, that link doesn't explain it very well; i had to stare at it for a few days)
12:11:55 <adelbertc> what is the news on ghc 7.8? as i understand it was originally scheduled for release late november?
12:12:01 * timthelion finds all things that are this abstract to be hard.
12:12:50 <YellPika> adelbertc: http://www.haskell.org/pipermail/ghc-devs/2013-December/003491.html
12:12:53 <timthelion> adelbertc: it is at "always within the next two months" joke status last time I checked (a week ago)
12:12:55 <YellPika> In other words... nobody knows!
12:13:30 <hpc> it'll be ready when it's ready
12:13:31 <adelbertc> YellPika timthelion - heh alright, thanks
12:13:36 <hpc> (ghc is maintained by valve donchaknow)
12:14:09 <adelbertc> :-)
12:17:19 <YellPika> If we were to take the arr function out from Arrow and put it in a separate class, what would we call it?
12:17:32 <monochrom> Ow? :)
12:17:45 <monochrom> I mean, Arr and Ow :)
12:18:05 <YellPika> *facepalm* yes :)
12:18:14 <hpc> hahaha
12:32:05 * hackagebot groundhog 0.4.0.3 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.4.0.3 (BorisLykah)
12:32:06 * hackagebot groundhog-th 0.4.0.3 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.4.0.3 (BorisLykah)
12:32:09 * hackagebot groundhog-sqlite 0.4.0.3 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.4.0.3 (BorisLykah)
12:37:05 * hackagebot groundhog-postgresql 0.4.0.3 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.4.0.3 (BorisLykah)
12:37:07 * hackagebot groundhog-mysql 0.4.0.3 - MySQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-mysql-0.4.0.3 (BorisLykah)
12:37:32 <jonasw> class Matey where …
12:37:50 <monochrom> haha
12:43:45 <sdsdfsdf> Is there a way to bind a polyvariadic C function that accepts multiple arguments of type Ptr Foo and returns Ptr Foo?  Any pointers?
12:45:03 * structuralist groans
12:46:48 <geekosaur> sdsdfsdf, I don't think so... and that kind of function is pretty horrid to do anything with
12:47:17 <geekosaur> which is why most of the stdargs-based stuff in various C standards also has array-based versions
12:49:29 <sdsdfsdf> geekosaur: I guess I could write a C wrapper that would have the following type: Ptr Foo -> Ptr Foo -> Ptr Foo. This would allow to sequence them. It might allow to write a polyvariadic version.
12:49:50 <zuserm> sdsdfsdf: I know you can simulate variadic functions with type classes with type classes, like in Text.Prinf, but I don't know how that would work with the ffi.
12:50:24 <sdsdfsdf> zuserm: Thanks, I'm aware of that (e.g., read Oleg's article).
12:50:35 <sdsdfsdf> geekosaur: Now, where should I put that C code?
12:50:56 <sdsdfsdf> geekosaur: May I include it into the .hsc file?
12:51:02 <geekosaur> you'd make a separate C source file, compile it, and link against the .o
12:51:09 <geekosaur> you can't put it in a .hsc file, no
12:51:33 <enthropy> @hackage libffi
12:51:33 <lambdabot> http://hackage.haskell.org/package/libffi
12:51:56 <enthropy> sdsdfsdf: that one provides another solution
12:52:21 <sdsdfsdf> geekosaur: OK, thanks for the tips!  Care to find an example of an array based alternative?
12:52:59 <sdsdfsdf> enthropy: Yep, I've found a StackOverflow answer that mentions it, but I have no idea how to use it. I guess geekosaur's method is easier.
12:53:04 <sdsdfsdf> enthropy: WDYT?
12:58:21 <mm_freak> http://lpaste.net/97607
12:58:36 <mm_freak> simple polyvariadic functions in haskell
12:58:52 <mm_freak> without any extensions (the FlexibleInstances is only for [Char] arguments)
13:03:18 <klz> hey, i've just started doing the 99 questions and wonder if my solution to the 2nd challenge is fundamentally wrong since none of the proposed solutions looked anything close
13:03:25 <klz> my solution http://lpaste.net/4638365440442105856
13:03:35 <klz> proposed http://www.haskell.org/haskellwiki/99_questions/Solutions/2
13:04:14 <mm_freak> klz: your solution traverses the list twice
13:04:19 <hpc> yours has the same bottoms, but.. that
13:04:48 <hpc> (or rather, it crashes or non-terminates for the same inputs as the example solutions)
13:04:53 <shachaf> It isn't wrong as such, but it's distasteful to use indexing on lists more than necessary.
13:05:17 <hpc> that problem is distasteful to begin with, but it's a correct solution
13:05:19 <shachaf> But it's the same function (unless your list happens to be bigger than sizeof Int.)
13:05:48 <shachaf> Or maxBound :: Int, or something.
13:05:49 <klz> traversing twice... now that's not good
13:06:25 <mm_freak> klz: haskell lists are linked lists…  'length' takes as long as the length of the list to compute its length
13:06:51 <mm_freak> and then indexing (!!) again takes as long as the length of the list minus one
13:07:12 <klz> i see
13:07:43 <mm_freak> now understand that you can return the second last element without even knowing the length of the list
13:08:01 <mm_freak> this is essentially what 'last . init' does
13:08:25 <mm_freak> last (init "abcdefg") = last "abcdef" = 'f'
13:09:12 <klz> i just looked 'init' up, clever indeed, thanks!
13:10:57 <bennofs> What type of source file is ".hsc"
13:10:59 <bennofs> ?
13:12:13 <timthelion> bennofs: you're looking in the ghc sources?
13:13:09 <bennofs> timthelion: no, I found doctests.hsc in the lens project
13:13:20 <zuserm> klz: (last . init) traverse the list only once, but (\xs -> xs !! (length xs - 2)) doesn't is because last and init are can be computed lazily, but length can't because an you can't compute just part of an Int
13:13:22 <geekosaur> bennofs, it's input to hsc2hs, which is a preprocessor for FFI calls
13:13:34 <edwardk> bennofs: http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/hsc2hs.html
13:13:34 <Rc43> Hello.
13:13:36 <geekosaur> makes it somewhat easier to deal with C struct members and such
13:13:47 <bennofs> geekosaur: https://github.com/ekmett/lens/blob/master/tests/doctests.hsc is hsc really needed in this file?
13:14:23 <edwardk> it is used to get  ##if defined(mingw32_HOST_OS)   and ##if defined(i386_HOST_ARCH)
13:14:33 <edwardk> otherwise i can't know host architecture
13:14:43 <Rc43> Am I right that lazy evaluation can be fully imitated in strict languages with lambdas with fake argument? If it is true, what is point in usage lazy evaluation with thunks etc.?
13:14:51 <edwardk> without that any doctest that emits utf8 on windows will cause bad things
13:15:19 <edwardk> bennofs: it is a fairly subtle issue
13:15:37 <bennofs> edwardk: but wouldn't already plain CPP provide those macros?
13:15:39 <edwardk> bennofs: it wasn't until i was working on ermine and needed to be able to do just that that i noticed and went back and fixed it
13:15:44 <timthelion> Rc43: Often one wants everything to be lazy, and puting a lambda around everything and sequencing everything manualy gets old FAST
13:16:15 <bennofs> At least mingw32_HOST_OS seems to be used in non-hsc files
13:16:26 <edwardk> bennofs: check to see if they are there under normal CPP. if so, feel free to toss a patch. it used to do more
13:16:46 <timthelion> Rc43: for example, when writing a lexer+parser, you have a bunch of maps and folds, but you want it to be single pass.  In haskell that's free.  In a strict language, you have to re-write the damn thing.
13:16:49 <simpson> Rc43: Having done this in Python, it's mostly just annoying to do so. One has to constantly consider *how* lazy one is being, and exactly when things should be forced.
13:18:08 <bennofs> edwardk: ah, I think only mingw32_HOST_OS is defined, the rest isn't
13:18:09 <Rc43> simpson, ye, seems that necessity to manually track and force evaluation is the real reason
13:18:11 <edwardk> i'm wedded to the functionality, not the approach ;)
13:18:17 <edwardk> ah
13:18:36 <edwardk> that would probably be why i did it this way then
13:18:45 <bennofs> I didn't check it, I have no windows with haskell right now, but a search didn't find any results
13:19:22 <timthelion> Rc43: really, think of the case in which you have a three pass parser for xml, a lexer, a parser, and a tree parser.  And you want to parser an infinite stream of xml.
13:19:43 <donri> edwardk: ohai. any progress on that failure handling lib?
13:19:52 <timthelion> Rc43: in a strict language, you have to re-write this as a one pass parser.  Even "fake" lazyness won't do you much good
13:19:58 <timthelion> Rc43: but in haskell, it just magically works.
13:20:39 <edwardk> donri: i've been going back and forth with snoyman and johnw about it, but not really
13:21:04 <edwardk> we'll probably split MonadCatch into MonadThrow and MonadCatch, and that is the major change pending
13:21:08 <Rc43> timthelion, didn't understand example; why I need to rewrite as a one pass?
13:21:23 <edwardk> Rc43: "infinite stream"
13:21:31 <Rc43> timthelion, edwardk, ah, really
13:21:32 <timthelion> Rc43: well, since the stream is infinite, than the first pass never finishes
13:21:41 <donri> edwardk: i'd like to review it for use in my own library. not a big hurry though (:
13:22:01 <edwardk> Rc43: you'll be waiting a long time for that first pass to finish ;)
13:22:03 <Tekmo> timthelion: So generators would not work?
13:22:16 <Tekmo> timthelion: Why can't each of the three passes be a function from a generator to a generator?
13:22:16 <timthelion> Tekmo: shhh
13:22:19 <Tekmo> :)
13:22:38 <timthelion> Tekmo: also shh about the whole lazy IO being the spawn of the devil thing
13:23:12 <bennofs> edwardk: Hmm, why are these macros suddenly there when using hsc? It gets converted into a .hs (dist/build/doctests/doctests-tmp/doctests.hs) and there the macros are still not expanded
13:23:21 <Tekmo> I was referring to the solution in Python
13:23:25 <donri> it might spawn the devil but it depends on which pure code path forces its evaluation
13:24:28 <edwardk> bennofs: good question
13:24:43 <edwardk> bennofs: i probably have a misunderstanding of the situation
13:25:17 <donri> edwardk: hmm MonadThrow, is that gonna be basically like Failure?
13:25:32 <edwardk> donri: basically split throw out of MonadCatch.
13:25:51 <edwardk> MonadCatch also i think picks up another member as well for a few corner cases to make safer brackets
13:26:02 <donri> edwardk: but MonadCatch has no parameter for the exception type
13:26:16 <donri> i'd like to have "checked exceptions"
13:26:21 <edwardk> donri: that is another thing under consideration
13:26:30 <bennofs> donri: then use control-monad-exception?
13:26:31 <edwardk> making the root exception type 'e' show there.
13:27:00 <Tekmo> This is why I prefer a concrete `EitherT` rather than a type class
13:27:05 <edwardk> bennofs: the goal of this exercise was to make a version of this folks could standardize on
13:27:17 <edwardk> because frankly everyone gets overwhelmed with 50 options that all do similar things
13:27:20 <donri> bennofs: which is based on failure, and my understanding was edwardk and snoyman are working on unifying failure and exceptions plus new ideas
13:27:27 <Tekmo> However, even `EitherT` won't solve the problem
13:27:34 <Tekmo> You still have `IO` which can never be checked
13:27:52 <edwardk> Tekmo also joined in. the whole thing has kind of moved into the background though. i was too busy over the last month to contribute much anything
13:28:18 <Clint> busy with adjunctions
13:28:26 <edwardk> we mostly just sat down and hammered out what common ground we had
13:28:29 <edwardk> Clint: exactly! =)
13:29:47 <edwardk> at last check the best idea was to add a root exception type 'e' to the MonadCatch and MonadThrow classes. make combinators that used fromException/toException when e = SomeException, and permit you to use prisms into the larger exception type like Control.Exception.Lens
13:30:03 <edwardk> then you can have at least a weak notion of checked exceptions
13:30:21 <Tekmo> donri: One of the main problems we encountered was how to encode the set of throwable exceptions in the type
13:30:37 <edwardk> i say only weak, because handling one doesn't remove it from a set going down the prism path
13:30:43 <donri> Tekmo: can't you just have an mptc without a fundep?
13:30:50 <Tekmo> donri: Even if you add an exception type parameter to the `MonadThrow` type class it still doesn't completely solve the problem
13:30:51 <Srpx> Is Haskell as a whole simple to implement? Is there a reference minimalistic implementation of haskell in itself?
13:30:57 <edwardk> donri: that leads to horrible inference hell
13:31:07 <Tekmo> donri: For example, what if you want to unify two pieces of code that throw two different sets of exceptions?
13:31:08 <donri> i suppose (:
13:31:17 <Tekmo> donri: Edward has one idea for how to do it, but it is a bit of a workaround
13:31:20 <startling> Srpx: Haskell is very complicated.
13:31:21 <edwardk> donri: my experience with such solutions is they are almost universally worse than the alternatives
13:31:22 <Cale> Srpx: Depends on what you mean by "Haskell" and "simple"
13:31:40 <Srpx> startling: oh ok
13:31:49 <bennofs> Tekmo: do you know control-monad-exception? It handles the problem of "unioning" multiple "Throw" constraints
13:31:51 <Tekmo> I personally would be fine with just standardizing on `SomeException`
13:31:59 <Cale> It's not impossibly hard for one person to implement, say, Haskell 98.
13:32:05 <Tekmo> bennofs: Let me check it quickly
13:32:10 <edwardk> srpx: writing a haskell compiler requires a fair bit of sophistication. if you want to find out how you'd go about it you might want to start by reading Pierce's Types and Programming Languages.
13:32:24 <edwardk> Srpx: that gives you a lot of the baseline vocabulary you'd need to know
13:32:30 <nisstyre> Cale: e.g. Frege is basically that + rank-n types and probably other stuff I don't know about
13:32:47 <Tekmo> bennofs: Oh this is a variation on `EitherT`
13:32:49 <nisstyre> and that was one guy's work more or less I think
13:32:55 <Tekmo> bennofs: Yes, if you have a concrete monad transformer it works very well
13:33:01 <Cale> and it's much easier to implement simple core languages you could build Haskell on top of
13:33:01 <Tekmo> bennofs: It's just that they want a type class
13:33:02 <donri> Tekmo: re two expections: that's why i said no fundep. (MonadThrow Foo m, MonadThrow Bar m) => m a
13:33:18 <donri> but inference probably suffers badly
13:33:29 <edwardk> bennofs: and yes, we know about control-monad-exception. i actually helped pepe write it back in the day ;)
13:33:41 <Cale> Haskell 98 is kind of like a large pile of syntax sugar on top of System F.
13:33:59 <Cale> (but saying that is really dismissing almost everything about it)
13:34:35 <edwardk> donri: consider the prism case, t doesn't pick 'e' then so what you've done is made the prism vocabulary less compositional. literally control.exception.lens has to be thrown out
13:34:42 <nisstyre> edwardk: would you recommend Andrew Appel's books? (e.g. Compiling with Continuations, which I bought because it looked good)
13:34:46 <donri> exceptions* i keep typing expect--
13:35:05 <nisstyre> probably less applicable to just Haskell, but meh
13:35:07 <edwardk> nisstyre: appel is a scary smart dude, you could do worse =)
13:35:36 <nisstyre> edwardk: It looks great because it covers all aspects of a compiler, not just type systems and other high level stuff
13:35:39 <donri> edwardk: but i just want to have a pony, why can't i have a pony
13:35:40 <nisstyre> e.g. register spilling
13:35:53 <edwardk> donri: because your pony makes a mess all over type inference
13:36:03 <donri> but pony! :(
13:36:31 <edwardk> and type inference woes bite users who don't know what they are doing. worse. if you push on the design you want you get ambiguous types, and cases where even the AmbiguousTypes flag can't help
13:36:33 <edwardk> i tried it
13:36:46 <donri> sadly for edwardk my experience in the past has been that edwardk says "can't be done" two days later "oh yeah i made it work"
13:36:47 <edwardk> i'm back here with war wounds to show for it. not just saying it won't work without looking ;)
13:36:54 <prasadi> Hi ! I'm writing a program using HDBC and Sqlite3. I would like to know whether or not " quickQuery" is the only  command available in it to execute  "INSERT INTO " query ? any other option available ?
13:37:17 <donri> but yeah type inference is important in haskell (:
13:37:21 <edwardk> this is one of those cases where what you are advocating is equivlant to asking for the removal of the fundep in MonadWriter and MonadReader.
13:37:34 <edwardk> it is actually straight up dual to that in fact
13:37:59 <donri> i'm not actually advocating anything! i just want a magical pony :)
13:38:03 <edwardk> hink about why _that_ is unpalatable, and what is the fix? well, use a lens into state, right? dual to a lens? oh yeah, its a prism.
13:38:13 <donri> \o/
13:38:35 <edwardk> so i expect the dual solution to be like that, rather than another completely ad hoc construction with worse inference
13:38:39 <Cale> prasadi: execute?
13:38:54 <nisstyre> edwardk: woah, he's the son of the guy who proved the four-color theorem. I guess it runs in the family.
13:39:32 <donri> i'm actually doing a bunch of tradeoffs to improve type inference in the very library i want this for, so you're preaching to the choir :)
13:39:40 <edwardk> heh
13:39:48 <Cale> prasadi: I think prepare/execute are how you're intended to make queries
13:40:15 <edwardk> just explaining my position, as i had almost exactly this same argument with johnw and snoyman a couple of weeks ago ;)
13:40:15 <edwardk> and the position i'm taking is one i would rather not have to take
13:40:18 <Cale> prasadi: Of course, quickQuery is defined in terms of those two
13:40:31 <Tekmo> Yes, I would prefer to unify exception types using prisms, too
13:40:38 <Tekmo> That seems like the "one true way"
13:40:48 <prasadi> do you think that inserting data to a table is possible with "prepare"  commands ?
13:41:01 <Cale> Why wouldn't it be?
13:41:12 <Cale> If you execute the resulting query
13:41:35 <geekosaur> prasadi, prepare / execute is how embedded sql normally works
13:41:42 <geekosaur> you might want to read up on it
13:42:09 <prasadi> @cale : I'm wondering whether "quickQuery" is the only option available to run the "INSERT INTO "  statement ?
13:42:15 <geekosaur> you prepare an sql statement, then you can execute it multiple times
13:42:19 <Cale> prasadi: no, it's not
13:42:23 <lambdabot> No match for ":".
13:42:23 <lambdabot> *** "I'm" gcide "The Collaborative International Dictionary of English v.0.48"
13:42:23 <lambdabot> I'm \I'm\
13:42:23 <lambdabot>    A contraction of I am.
13:42:23 <lambdabot>    [1913 Webster]
13:42:33 <geekosaur> and you are clearly not paying any attention so that's all I will say
13:43:13 <Cale> There's prepare/execute, and there's run.
13:43:25 <Cale> and you could even use runRaw
13:43:51 <Cale> But you probably in most cases would use prepare/execute.
13:44:20 <Cale> Unless it's a one-off query which doesn't involve any user data.
13:47:24 <Cale> Well, it's possible to use quickQuery even if you have placeholders and parameters, so that's not terrible either.
13:47:52 <Cale> http://hackage.haskell.org/package/HDBC-2.3.1.2/docs/src/Database-HDBC-Utils.html#quickQuery (you can see how quickQuery is written in terms of prepate/execute here)
13:49:21 <geekosaur> it will however be much faster to prepare an insert using placeholders and then execute it once per row
13:49:25 <geekosaur> to be inserted
13:55:28 <bennofs> edwardk: Hmm, http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#c-pre-processor lists os_HOST_OS and arch_HOST_ARCH as GHC macros. Maybe I should install a windows vm and try it out ...
13:55:29 <Cale> geekosaur: and possibly faster still to use executeMany
14:00:16 <danharaj> edwardk: given that you can make a monad out of any comonad in Haskell, what is the relationship between their Kleisli categories? Is there an equivalence between them?
14:01:05 <edwardk> it has been for everything i've tried at least. may not be an equivalence, there is probably something like a cauchy completion going on
14:01:14 <danharaj> hm
14:01:18 <edwardk> kind of like how you can't _quite_ recover Cat from Prof
14:01:29 <danharaj> does that mean any comonadic computation can be restructured as a monadic one?
14:01:32 <shachaf> Do you mean between (w a -> b) and (a -> forall r. w (a -> r) -> r)?
14:01:34 <edwardk> but instead only get its completion
14:01:35 <danharaj> (in Haskell)
14:01:44 <shachaf> Er, I missed a b in the second one.
14:01:56 <danharaj> shachaf: yeah
14:01:58 <edwardk> danharaj: not sure, but i can write monadic ask in terms of comonadic ask, etc.
14:02:28 <edwardk> it may just work for the toys that are made out of the prod-hom adjunction, state/reader/writer though
14:02:38 <edwardk> so i don't know how well it generalizes
14:02:59 <danharaj> those don't look like isomorphic types so I'm not sure what's going on.
14:03:14 <edwardk> i'd be curious to see if you can fiddle with, say, the reversing lemma and get a better equality
14:03:30 <shachaf> Well, they're not isomorphic.
14:05:12 <shachaf> Well, if you pick w = (e,), you get (e -> (b -> r) -> a -> r) and (e -> a -> b)
14:05:14 <shachaf> Which are the same.
14:05:59 <shachaf> And if you pick w = (e ->), you get ((e -> b -> r) -> a -> r) and ((e -> a) -> b)
14:07:09 <edwardk> in the latter we have a monoid on e as well
14:07:57 <shachaf> Well, without the monoid, the thing on the left is like a -> (e,b), which is what I'd expect.
14:08:05 <edwardk> yeah
14:09:32 <shachaf> I wish I had a linear type checker.
14:10:03 <MajorMonodon> Hello everyone
14:14:30 <danharaj> I remember skimming a paper that said something about it being a matter of taste whether one worked over a comonad or some related monad
14:14:33 <danharaj> but it's name escapes me.
14:14:34 <timthelion> MajorMonodon: Hello! Welcome!
14:15:02 <edwardk> i suppose there is always a monad in the opposite category ;)
14:16:05 <danharaj> haha
14:16:09 <danharaj> reverse do notation
14:16:28 <shachaf> Anyway, if you pick w = Store s, you get ((s, s -> b -> r) -> a -> r) and ((s, s -> a) -> b)
14:16:38 <danharaj> one simply has to rid themselves of the delusion that morphisms should be set-like functions
14:16:39 <shachaf> That part is slightly more mysterious to me.
14:16:53 <shachaf> danharaj: Just accept that objects are Chu spaces!
14:17:06 <shachaf> Then you can just invert them to get the opposite category. Keep the same notion of morphism.
14:17:17 <shachaf> Er, not invert. Transpose.
14:17:30 <shachaf> What are some good comonads?
14:17:35 <shachaf> @instances-importing Control.Comonad Comonad
14:17:36 <lambdabot> ((,) e), ((->) m)
14:17:44 <shachaf> thanks lambdabot
14:17:57 <heatsink> The performance model of some Haskell libraries, like Repa, assumes that parts of the library code have zero runtime cost because the optimizer will simplify them.  Is that done in other languages?
14:18:48 <Cale> I guess?
14:19:27 <Cale> People pick apart what their language does to things all the time in order to understand performance better
14:19:33 <Cale> er, language implementation
14:19:40 <shachaf> Stream (b -> r) -> a -> r
14:19:48 <shachaf> Funny monad. What does it do?
14:21:07 <shachaf> Without the "a ->", of course.
14:23:29 <heatsink> In C++, people use template metaprogramming to achieve similar goals
14:23:55 <carter> heatsink: er, templates + inling are needed together
14:24:00 <heatsink> With templates, you have a clear separation between compile stages
14:24:08 <carter> yes / no
14:24:14 <carter> depends on which templates right?
14:24:34 <heatsink> Template errors are reported at compile time, so they have to be expanded at compile time
14:25:18 <mgsloan_> I'm not too knowledgeable about rewrite rules optimizations, but, out of curiosity, are there any pragmas that allow you to assert that a rule should be firing in some expression?
14:25:36 <shachaf> mgsloan: I don't think so.
14:25:37 <ImUrBreda> am i tripping balls or linking got so much faster in ghci?
14:25:54 <mgsloan> shachaf: It'd be nice for avoiding performance regressions
14:25:59 <bennofs> ImUrBreda: What ghci version?
14:26:34 <mgsloan> In general it seems like there'd be lots of benefits of being able to version metadata derived from ghc (which rules fired, what're the types, etc etc)
14:26:39 <ImUrBreda> bennofs: how can i query the version number?
14:26:52 <bennofs> ImUrBreda: ghci --version
14:26:53 <heatsink> There's a compiler pragma to report that, mgsloan
14:27:06 <heatsink> Hm, I don't think it reports types
14:27:10 <ImUrBreda> bennofs: 7.6.3
14:27:18 <mgsloan> heatsink: Ah, I'll bet, probably a -ddump-* flag
14:27:25 <bennofs> mgsloan: just use -v3
14:28:21 <bennofs> ImUrBreda: what do you mean by linking got faster? Did you use an earlier version of GHCi before? What did you compare to?
14:28:24 <mgsloan> heatsink: Yeah, you need to use the ghc api to get out sub expression type info (like what ghc-mod or the FP Complete IDE)
14:28:27 <heatsink> Anyway, I'm asking because it took me a long time to convey to other programmers that you could do "loop parallelization" by writing your library code a certain way
14:28:46 <ImUrBreda> bennofs: I remember a year ago it was really slow
14:28:51 <ImUrBreda> but that was on win now im on mac
14:29:21 <ImUrBreda> older version of ghci as well, dunno which exactly
14:30:29 <enthropy> ImUrBreda: it slows down if you're loading a huge number of packages too
14:31:54 <ImUrBreda> enthropy: exponential or linear (troll)?
14:32:35 <enthropy> probably closer to linear I think
14:33:03 <danharaj> shachaf: Trace is my favorite comonad because of its coalgebras.
14:33:17 <edwardk> ?
14:33:19 <danharaj> Which happen to be equivalent to writer coalgebras, I think.
14:33:22 <shachaf> danharaj: Trace is just (e ->), right?
14:33:26 <danharaj> yeah
14:33:33 <danharaj> er writer algebras*
14:33:43 <edwardk> i was going to ask if you meant writer algebras
14:33:53 <edwardk> and yeah its just currying acoss
14:33:58 * heatsink will have to come back to that question later
14:34:08 <shachaf> Same for (e,) and (e->) in the other direction
14:34:54 <danharaj> edwardk: Ah, but you can combine Trace with a free comonads via product to get some funky state machines.
14:35:23 <shachaf> Free comonads?
14:35:32 <danharaj> yes I refuse to co-everything :p
14:35:49 <shachaf> But they're not free at all. :-(
14:36:03 <shachaf> Will you settle for co(free monad)?
14:36:36 <danharaj> sure they are
14:37:44 <danharaj> I don't think Cofree f and Free f are dual.
14:37:59 <shachaf> "dual" is a vague word.
14:38:13 <danharaj> well
14:38:23 <danharaj> free objects are created by left adjoints to forgetful functors
14:38:42 <danharaj> are comonads generated by left or right adjoint to the forgetful functor from comonads to functors?
14:39:25 <shachaf> The functor right adjoint to the forgetful functor from comonads to endofunctors gives you Cofree.
14:39:39 <shachaf> If it was left adjoint they'd be called free comonads.
14:40:05 <edwardk> the cofree comonad is right adjoint to the forgetful functor, so it really is a cofree construction
14:40:22 <edwardk> its not just a mindless extra co
14:40:33 <danharaj> ah ok
14:40:41 <shachaf> And note that F -| G means that G^op -| F^op
14:40:44 <danharaj> edwardk: is that a retcon of the original reasoning? :p
14:40:50 <shachaf> So in that sense it's free in the opposite category.
14:41:27 <edwardk> not to my knowledge
14:41:30 <shachaf> The word "cofree" has been around for much longer than any of edwardk's packages.
14:41:41 <edwardk> yeah i believe it goes back to uustalu using it first
14:41:47 <edwardk> in this setting
14:42:01 <danharaj> I don't recall it in Maclane which is probably why I thought it was a made-up term.
14:42:13 <danharaj> then again, everything is made-up
14:48:57 <edwardk> danharaj: http://ncatlab.org/nlab/show/cofree+coalgebra
14:49:02 <edwardk> nlab has it it must be real ;)
14:50:02 <danharaj> @tell edwardk ah but it also says that you can call cofree objects fascist objects ;)
14:50:02 <lambdabot> Consider it noted.
14:51:18 <shachaf> Free spaces are discrete and cofree spaces are indiscrete.
14:55:23 <ImUrBreda> if i have a catch which catches SomeException, surely every exception should be caught?
14:55:56 <ImUrBreda> because it definitely does not catch in one case for me
14:57:15 <geekosaur> certain exceptions can't currently be caught
14:58:33 <ImUrBreda> geekosaur: but strangely the layer above that code catches it... sorry if my explanation doesnt make sense
14:58:49 <ImUrBreda> in that particular layer the exception slips out of my hand
14:59:01 <ImUrBreda> im so confused it hurts
14:59:50 <geekosaur> then that would not be the same issue. but I see no code...
15:02:17 <ImUrBreda> geekosaur: can i pm?
15:04:06 <bennofs> Ah, I hate the GHC API. Why does it change the signal handlers?!
15:05:04 <bitemyapp> http://liamoc.net/posts/2013-11-13-imperativereasoning.html
15:06:25 <Brew> Hi, is there a way exclude a value from a arbitrary list in quickCheck?
15:10:59 <Cale> Brew: In what sense?
15:11:20 <Cale> Brew: You want to check that a property holds for all lists which don't contain that specific value?
15:11:54 <Brew> Cale: I want to create a arbitrary word, so any characters except spaces
15:13:11 <Cale> Probably the easiest thing to do is just to filter (not . isSpace) the string, and test the property on the result
15:13:36 <Cale> You could use ==> but that may result in rejection of a lot of strings
15:13:59 <erisco> http://lpaste.net/97613 I do not know why I have a syntax error on line 6
15:14:10 <Brew> but then the list could be empty...
15:14:10 <erisco> just says "parse error in pattern"
15:14:15 <Brew> what does ==> do?
15:14:16 <Cale> i.e. prop_foo x = all (not . isSpace) x ==> ...
15:14:51 <Cale> It's logical implication, but with the semantics that QuickCheck won't count the tests where the property on the left fails
15:14:56 <erisco> ah wants a semi-colon after line 14... do notation is finnicky =\
15:15:22 <Cale> erisco: You're indenting let/in weirdly
15:15:30 <erisco> Cale, how should I indent it?
15:15:38 <Cale> let <decls>
15:15:43 <Cale>     <more decls>
15:15:47 <Cale>  in <expr>
15:16:02 <Cale> (or you can leave out the space before 'in' there, which is also common)
15:16:31 <Brew> Cale: ahh, ok thanks. But inside an IO monad so how would that look?
15:16:45 <mgsloan> I think the main problem here is the "in" on line 22 - it's indented less than the let that it should belong to
15:16:45 <erisco> Cale, *shrug* still complains nuless I add a semi colon
15:16:49 <Cale> Brew: ?
15:16:58 <Cale> Brew: Do you mean the 'let' syntax?
15:17:14 <Brew> Cale: atm I have prop = monadicIO $ do ...
15:17:15 <Cale> erisco: oh, it's weird that it would work even with a semicolon there
15:17:18 <mgsloan> erisco: Another problem here is the "else" isn't indented enough
15:17:37 <Cale> oh, yeah, the 'then' and 'else' should line up, usually :)
15:17:44 <Cale> It's prettier anyway
15:17:47 <Cale> if foo
15:17:49 <Cale>    then bar
15:17:51 <mgsloan> It thinks the "else" is beginning a new statement.  I think there's an extension that changes that layout restriction
15:17:51 <Cale>    else quux
15:17:52 <Rylee> @src intersperse
15:17:52 <lambdabot> intersperse _   []     = []
15:17:52 <lambdabot> intersperse _   [x]    = [x]
15:17:52 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
15:17:56 <FireFly> Cale: what about an extra space *after* 'in'?
15:18:10 <Cale> FireFly: Also seems okay to me
15:18:18 <shachaf> What about one before and one after?
15:18:23 <shachaf> Just to be on the safe side.
15:18:24 <Cale> shachaf: no!
15:18:24 <Fuuzetsu> I have a fundep such as ‘class Foo x y | x → y where foo ∷ x → String → y’, how can I translate this to use type families instead?
15:18:29 <Cale> :)
15:18:32 <shachaf> OK, there was no point to saying that.
15:18:41 <shachaf> But I don't see why the bindings and the expression ought to be aligned.
15:18:44 <Cale> The space is just there to make up for the fact that 'in' is shorter than 'let'
15:18:45 <shachaf> They have nothing in common.
15:19:28 <Cale> erisco: It seems there are too few occurrences of 'do' in this
15:19:37 <Cale> erisco: or too many occurrences of 'in'
15:19:51 <Cale> let me try to straighten it out...
15:20:09 <mgsloan> Here's the extension that allows you to use "if" in that way in a do statement.  It's probably better just to stick to normal syntax, though: https://ghc.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
15:21:23 <Cale> erisco: see my annotation here http://lpaste.net/97613
15:22:11 <erisco> Cale, mkay that does not have syntax errors at least
15:22:15 <erisco> but damn that is so much indentation
15:22:23 <Rylee> > intersperse " " "lewd"
15:22:24 <lambdabot>  Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
15:22:24 <lambdabot>  Expected type: [[GHC.Types.Char]]
15:22:24 <lambdabot>    Actual type: [GHC.Types.Char]
15:22:32 <Cale> erisco: It doesn't matter how much things are indented, only that they line up
15:22:33 <Cale> :)
15:23:16 <Cale> But there are some other options if you really want to reduce the level of indentation, I suppose.
15:24:04 <erisco> I did this which seems to parse http://lpaste.net/97613
15:24:06 <bennofs> Why is there a difference between System.Exit.exitSuccess and System.Posix.Proccess.exitImmediately?
15:24:13 <erisco> it is the last annotation
15:24:30 <ImUrBreda> how can i force the evaluation of something in a "where"
15:24:51 <Cale> erisco: yeah, that'll work, but I would at least move the 'then' to the next line, if you're going to do that
15:24:58 <erisco> Cale, no thanks :P
15:25:00 <Cale> It's so weird to have it hang line that
15:25:06 <geekosaur> bennofs, exitImmediately avoids any atexit() hooks set by libc functions
15:25:13 <Cale> 'then' and 'else' are siblings, so they ought to line up!
15:25:24 <erisco> Cale, if and else are siblings :P
15:25:27 <mgsloan> erisco: I changed the let to a where here, but here's how I'd write it with my indentation style: http://lpaste.net/97614
15:25:27 <Cale> no!
15:25:39 <Cale> if is parent to 'then' and 'else'
15:25:45 <geekosaur> also avoids global destructors and such
15:26:11 <bennofs> Hmm, my process was not exiting. I think it was because I had an async still running
15:26:12 <geekosaur> you should generally not use _exit() / exitImmediately
15:26:18 <erisco> Cale, blasphemy :P
15:26:30 <bennofs> Is there a way to avoid that asyncs block exiting?
15:26:38 <mgsloan> erisco: There're many different styles, but I think the two schools of thought are: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md vs https://github.com/chrisdone/haskell-style-guide/
15:26:55 <Cale> if <cond> then <expr1> else <expr2>  is conceptually the same thing as   case <cond> of True -> <expr1> ; False -> <expr2>
15:27:01 <geekosaur> it would normally be used in e.g. a failure in a fork()ed child, where the atexit hooks likely only make sense in the parent process
15:27:24 <Cale> You wouldn't (and quite literally couldn't) write something like:
15:27:37 <Cale> case Set.member id tbl of True ->
15:27:42 <Cale>   return ...
15:27:42 <erisco> Cale, and the 'then' feels like the 'of' to me
15:27:46 <Cale> False -> do
15:27:47 <Cale>   ...
15:28:37 <bennofs> geekosaur: so, could an async action calling only accept and using pipes-concurrency cause exitSuccess to be blocked?
15:28:39 <Cale> (that will fail to parse, because 'of' is a layout keyword, and the block level is set by the first non-whitespace character after it)
15:29:12 <geekosaur> I don't know offhand
15:29:30 <Cale> I think I'd be less offended if you moved the entire 'then' branch onto the line with the 'if' on it.
15:29:48 <geekosaur> don't know if exitSuccess just invokes exit() or tells the runtime to shut down (which likely waits on other threads or something)
15:29:50 <Cale> But I'm not entirely sure why :)
15:30:04 <bennofs> geekosaur: it throws an exception
15:30:36 <Cale> (that would still break the rule that 'then' and 'else' should be aligned, unless you really did align the 'else', but then you'd be indenting that entire block by a good deal
15:30:38 <Cale> )
15:31:41 <scanlonman> is there something like 4clojure for haskell
15:32:01 <Cale> I also tend to prefer having the first line of my do block on the same line as the 'do', so I'll usually put the newline before do rather than after, but I understand why people don't like doing that because editors suck at the layout rule.
15:32:19 <bennofs> scanlonman: what does 4clojure?
15:32:22 <bennofs> scanlonman: do?
15:33:23 <scanlonman> My bad, I should have explained it.  It's a bunch of questions that slowly build up on the concepts of Clojure.  It starts off easy with stuff like "write a function to double a number" and gets into much harder concepts
15:33:33 <scanlonman> questions should be problems*
15:34:18 <bennofs> There is http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems, but that only covers basic stuff
15:35:58 <scanlonman> It's a good starting place! Thank you
15:37:55 <tristan_1> https://gist.github.com/tsloughter/8154103
15:37:58 <tristan_1> anyone seen this issue before
15:38:50 <erisco> :t &&&
15:38:51 <lambdabot> parse error on input `&&&'
15:38:55 <erisco> :t (&&&)
15:38:56 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
15:39:28 <erisco> with c -> c' -> d how can we get to a b d?
15:39:58 <erisco> :t >>^
15:39:58 <lambdabot> parse error on input `>>^'
15:40:21 <ImUrBreda> is it possible that an exception inside an atomicModifyIORef' happening corrupts my ioref?
15:40:32 <ImUrBreda> (in case of read i get the same exception back over and over again)
15:40:36 <maxiepoo> :t (>>>^)
15:40:36 <lambdabot>     Not in scope: `>>>^'
15:40:37 <lambdabot>     Perhaps you meant one of these:
15:40:37 <lambdabot>       `>>>' (imported from Control.Arrow),
15:40:45 <maxiepoo> :t (>>^)
15:40:46 <lambdabot> Arrow a => a b c -> (c -> d) -> a b d
15:41:51 <erisco> :t id &&& id >>^ (+)
15:41:52 <lambdabot> Num (a, a) => a -> (a, a) -> (a, a)
15:42:10 <erisco> ah right
15:42:41 <erisco> :t id &&& id >>^ uncurry (+)
15:42:42 <lambdabot> Num a => a -> a
15:42:56 <erisco> there is the arrow double function :P
15:43:32 <bennofs> :t  join (+) -- Monad double function
15:43:33 <lambdabot> Num a => a -> a
15:45:20 <haasn> :t id *~ 2
15:45:21 <lambdabot> Num t => t -> t
15:45:23 <haasn> lens double function
15:45:46 <edwardk> too many spaces. clearly
15:45:53 <edwardk> :t id*~2
15:45:53 <lambdabot> Num t => t -> t
15:46:00 <edwardk> now it looks more like lens
15:46:02 <bennofs> also, that's cheating. It's just (*2), really
15:46:20 <tristan_1> well shit, found it here too https://github.com/haskell/haskell-mode/issues/71
15:46:24 <bennofs> > act join.to (
15:46:25 <lambdabot>  <hint>:1:14:
15:46:25 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
15:47:06 <edwardk> :t (act join, acts)
15:47:07 <lambdabot> (Conjoined p, Effective m r f, Effective m1 r1 f1) => (p a (f a) -> p (m (m a)) (f (m (m a))), (a1 -> f1 a1) -> m1 a1 -> f1 (m1 a1))
15:47:20 <edwardk> erm, that was meant to show you can just use 'acts' there
15:47:26 <bennofs> :)
15:48:01 <Cale> Obligatory over id (*2)
15:48:45 <haasn> :t over (traverseOf id) (*2)
15:48:46 <lambdabot> Num a => a -> a
15:49:08 <bennofs> haha
15:49:09 <edwardk> @tell danharaj using lawvere's joke of fascist for cofree _is_ kinda funny. ;)
15:49:09 <lambdabot> Consider it noted.
15:50:22 <haasn> :t execState $ do n <- get; put (n+n)
15:50:23 <lambdabot> Num s => s -> s
15:50:41 <haasn> or modify (+n)  ;)
15:50:50 <haasn> id += n
15:52:01 <bennofs> @ty flip appEndo 0 . mconcat . replicate 2 . Endo . (+)
15:52:02 <lambdabot> Num c => c -> c
15:52:24 <bitemyapp> problem with criterion, Couldn't match expected type `IO t0' with actual type `Pure'
15:52:46 <bitemyapp> it's inside the do block of main
15:52:55 <bitemyapp> hum. maybe unlift?
15:53:09 <bitemyapp> oh no, that made a mess.
15:53:47 <Feuerbach> bitemyapp: I bet it's a problem with your code, not criterion. But without seeing your code how can we help you?
15:54:40 <bitemyapp> Feuerbach: oh of course it's a problem with me and my code.
15:54:51 <bitemyapp> I think I'm misunderstanding how to invoke criterion from a main do block.
15:54:53 <bitemyapp> let me paste.
15:55:20 <bitemyapp> Feuerbach: http://lpaste.net/97618
15:55:48 <Feuerbach> bitemyapp: you have to use the defaultMain function
15:56:34 <bitemyapp> Feuerbach: from...Distribution.Main or Distribution.Cabal?
15:57:00 <Feuerbach> from Criterion
15:57:14 <Feuerbach> er, Criterion.Main
15:57:19 <bitemyapp> Feuerbach: I'm not finding that in hackage or Hayoo and it's not in context. I'll try to track it down.
15:57:32 <Feuerbach> there's even an example there
15:57:44 <edwardk> As seen on nforum: "We compose this fascist functor with that terrorist functor to find a public enemy adjunction without adding freedom fries."
15:57:51 <Feuerbach> http://hackage.haskell.org/package/criterion-0.8.0.0/docs/Criterion-Main.html#v:defaultMain
15:57:55 <bitemyapp> Feuerbach: I see the example now, thank you.
15:57:56 <bennofs> Wow, I just deleted my whole project. Luckily, I still had most files open in emacs buffers ...
15:59:17 <ImUrBreda> can anyone enlighten me regarding this and how to find a workaround:http://lpaste.net/97619
15:59:45 <ImUrBreda> i want my ioref to stay readable after an exception throwing modify
16:00:19 <bitemyapp> Feuerbach: well it's still broken, but in new and interesting ways! Thanks for the help.
16:00:33 <Feuerbach> ImUrBreda: what are you trying to achieve with atomicModifyIORef' x (\x -> error "a")?
16:00:40 <gamegoblin> Not super good at monads and do notation yet. Can this be made sexier? http://lpaste.net/97620
16:00:51 <gamegoblin> (part of a parsec thing)
16:00:52 <quchen> ImUrBreda: It stays readable. The IOref's content is the error if you put an error into it.
16:01:19 <ImUrBreda> quchen: holy shit, cause error is polymorphic?
16:01:27 <enthropy> maybe you can change the function that throws the error to one that produces (x, error "a")
16:01:58 <ImUrBreda> enthropy: it is a pure function, i cant catch the possible exception it is throwing
16:02:49 <quchen> Do you have a pure function that throws?
16:02:54 <twiceler> gamegoblin: do { a <- x; b <- y; c <- z; return (f a b c) } = f <$> x <*> y<*> z
16:03:04 <quchen> Or are you just trying to anticipate every case
16:03:17 <twiceler> gamegoblin: where that mess is applicative notation (Control.Applicative)
16:03:27 <ImUrBreda> quchen: i have a pure function which throws, yes
16:03:31 <twiceler> gamegoblin: in this case, f = (,,)
16:03:53 <quchen> ImUrBreda: Pure functions should not throw. Did you write that function yourself, or is it from some library?
16:03:55 <gamegoblin> can you lpaste what you mean? Having trouble understanding it.
16:04:06 <ImUrBreda> quchen: myself...
16:04:06 <twiceler> gamegoblin: but it's all a matter of taste, isn't it!
16:04:18 <erisco> @src join
16:04:18 <lambdabot> join x =  x >>= id
16:04:36 <twiceler> http://lpaste.net/97620
16:04:47 <ImUrBreda> quchen: way too much code to refactor to be honest
16:04:58 <ImUrBreda> i need a quick workaround if possible
16:05:07 <quchen> ImUrBreda: You can make pure functions throw (as you did), but that has several drawbacks. You can't catch the error in pure code (only in IO), you don't see that it can throw in its type.
16:05:09 <Feuerbach> ImUrBreda: use STM
16:05:20 <Feuerbach> i.e. TVar instead of IORef
16:05:20 <twiceler> > (,) <$> [1..3] <*> [-1,0]
16:05:21 <lambdabot>  [(1,-1),(1,0),(2,-1),(2,0),(3,-1),(3,0)]
16:05:49 <quchen> Oh, you're looking for a hack. In that case, how about getting the old IORef value, applying your modification function to it, do the error checking, and only put the value back in again if it's not an error?
16:05:52 <enthropy> @hackage spoon  is a "quick" workaround
16:05:53 <lambdabot> http://hackage.haskell.org/package/spoon  is a "quick" workaround
16:06:07 <enthropy> who knows how that plays with atomicModifyIORef
16:06:17 <gamegoblin> twiceler: thanks for the explanation
16:06:30 <Cale> edwardk: I thought of a good reason for lens to have a prefix version of (%=) -- it could be called overstate!
16:06:47 <Feuerbach> quchen: well, I suppose ImUrBreda wants atomicity
16:06:48 <ImUrBreda> quchen I have to lock then
16:06:55 <ImUrBreda> Feuerbach: +1
16:07:00 <quchen> Oh boy.
16:07:10 <quchen> I mean the above was a dirty hack already, now you're pushing it :-þ
16:07:15 <ImUrBreda> I know I should fuck myself
16:07:22 <bitemyapp> http://lpaste.net/97622 No instance for (Control.Monad.IO.Class.MonadIO ((->) a0)) what'd I do wrong here?
16:07:32 <quchen> I didn't mean to sound like that.
16:07:40 <ImUrBreda> quchen: I know
16:07:44 <Feuerbach> ImUrBreda: seriously, just use STM. It plays nicely with exceptions
16:07:48 <ImUrBreda> is it really THAT bad practice to throw in pure code?
16:08:03 * quchen votes yes
16:08:04 <Feuerbach> not really
16:08:14 <Cale> ImUrBreda: Throwing errors from pure code is fine if you never intend the errors to be caught
16:08:18 <ImUrBreda> Feuerbach: thank you for saving my mood for tonight
16:08:33 <Feuerbach> it's just that atomicModifyIORef is pushing the boundaries of IORefs
16:08:50 <ImUrBreda> Cale: I see
16:08:52 <quchen> It also shadows the amazing functionality that STM is
16:09:03 <ImUrBreda> STM seems friggin hard for me
16:09:04 <quchen> Go out of the sun, IORef. You have no business here!
16:09:46 <bennofs> Is reading/writing an IORef Bool from multiple threads safe?
16:09:48 <Feuerbach> ImUrBreda: it's pretty simple, actually. Replace IORef with TVar, and atomicModifyIORef ... becomes atomically $ modifyTVar ...
16:09:55 <bennofs> (multiple = 2)
16:10:02 <Cale> bennofs: What do you mean by 'safe'?
16:10:23 <nyc> Does memory allocation failure generate an exception, or is its error handling entirely within the runtime?
16:10:33 <ImUrBreda> Feuerbach: hm, how will that solve my current problem?
16:10:35 <Cale> bennofs: Reading and writing an IORef from multiple threads will never result in a read of a partially-written value.
16:10:36 <Feuerbach> nyc: it does
16:10:54 <bennofs> Cale: Ah ok, what's the purpose of atomicallyModifyIORef then?
16:10:55 <Cale> bennofs: But it opens you up to all kinds of race conditions regardless.
16:10:55 <Feuerbach> ImUrBreda: because an exception cancels the transaction. So the old value will stay there
16:11:11 <nyc> One could therefore argue exceptions are thrown from pure code in a pervasive fashion.
16:11:13 <bennofs> Cale: that the read and the write are performed atomically?
16:11:14 <ImUrBreda> Feuerbach: sounds like a better thought out solution then
16:11:36 <Cale> bennofs: Because if you read some value v, and then write (f v), some other thread might have written a new value v' to the IORef in between and you'd lose that update.
16:13:06 <bennofs> Cale: Ok, so in in my case, that's no problem, as I only use the IORef as a flag for reloading. If I set the IORef to False before reloading, I won't miss any updates.
16:13:35 <ImUrBreda> hey with STM I can do a bunch of modifications etc in a monad and they are transactional?
16:13:36 <Cale> bennofs: Are you polling it?
16:13:46 <Cale> bennofs: It might be smarter to use an MVar ()
16:13:55 <Cale> Depending on what you're doing
16:14:04 <Cale> ImUrBreda: That's right
16:14:09 <Feuerbach> ImUrBreda: yes, but only in the STM monad. No IO.
16:14:29 <Cale> If you want to trigger IO, you can always return an IO action as part of the result of your STM transaction though.
16:14:39 <ImUrBreda> That's ridiculously high tech
16:14:40 <Cale> (and run it afterward)
16:15:08 <bennofs> Cale: no, I'm not polling. I'm writing a daemon, so I only check it every request (Requests are commands send to the server).
16:15:15 <Cale> bennofs: ah, okay
16:17:20 <gamegoblin> is there a performance difference in using "let...in..." vs "...where" when the two would be interchangeable?
16:17:26 <ImUrBreda> wait, so how does this differ from a lock + do what i want with different values, apply or reset values/unlock in imperative languages?
16:17:27 <Cale> gamegoblin: no
16:17:41 <ImUrBreda> more convenient or it provides some magic i dont see yet?
16:18:04 <Cale> gamegoblin: 'where' is desugared by the compiler into 'let', and the only difference is that 'where' scopes over multiple guards
16:18:15 <gamegoblin> Ahhh gotcha. Thanks.
16:18:48 <Cale> ImUrBreda: That would be a valid implementation, but it's not what GHC's implementation does
16:19:24 <hpc> transactions let you do it without locking, which is faster sometimes and slower sometimes
16:19:34 <Cale> ImUrBreda: GHC's implementation of STM is optimistic -- it starts executing transactions immediately, and in parallel, and instead of writes going directly into memory, they get written into a transaction log, along with a record of all the things which were read from.
16:20:19 <Cale> ImUrBreda: At the end of each transaction, a global lock is briefly taken to 1) check that the values read from transactional variables still have the values they did when they were read, and then 2) if so, commit all the changes
16:20:42 <ImUrBreda> Cale: Thanks that was interesting!
16:21:01 <hpc> (also, if the check fails it restarts the transaction)
16:21:10 <benmachine> well
16:21:10 <Feuerbach> ImUrBreda: the important thing is, you don't have to worry about locks (and getting them wrong)
16:21:24 <ImUrBreda> so in case of write heavy workload they may be actually slower than a lock at beginning and end solution?
16:21:33 <ImUrBreda> (not that I care, it will be quick enough for me)
16:21:34 <benmachine> notionally it restarts the transaction, but what it probably really does is wait until anything relevant changes, then restart
16:22:20 <Cale> ImUrBreda: The bad case is where you have some big fat transaction which reads from lots of things in order to try to get something done, and then lots of other threads doing quick little writes to the things that big transaction is trying to read from.
16:22:32 <hpc> ImUrBreda: when many computations are competing for the same variable, the cost of many transaction fails can be slower
16:22:40 <Cale> It might be that the big transaction never gets to finish in that case
16:23:08 <Cale> But there are some proposals for detecting that condition, and making it more and more likely that transactions don't get trampled.
16:23:27 <ImUrBreda> to be fair sounds like a pretty shitty implementation
16:23:44 <ImUrBreda> what is the advantage?
16:23:59 <hpc> without locking, you are able to a lot more in parallel
16:24:00 <Cale> Well, it still eliminates large classes of potential bugs
16:24:11 <hpc> you don't have to wory about deadlocks, which are very very easy to create
16:24:14 <Cale> Just not *all* potential bugs
16:24:23 <hpc> *to do
16:24:25 <Cale> (that it conceivably could)
16:24:32 <nyc> It's a question of what it's implementing. It can be very well done and the thing it implements is still prone to starvation in such a manner.
16:24:43 <mm_freak> ImUrBreda: with locking you get the potential for deadlocks, which are easy to create and hard to track down
16:24:43 <bennofs> Does STM gain you anything when you have many unrelated variables?
16:24:58 <Cale> bennofs: Maybe?
16:25:00 <mm_freak> ImUrBreda: with STM you get the potential for livelocks, which are easy enough to track down
16:25:13 <mm_freak> ImUrBreda: a livelock is the situation that Cale just described
16:25:15 <ImUrBreda> guys, thank you very much for the answers
16:25:16 <hpc> bennofs: yes, if i am reading your question right
16:25:21 <ImUrBreda> mm_freak: live lock? first time i hear that
16:25:45 <Cale> also note that anything written with STM is still going to make progress in some sense, in that transactions will have to be finishing in order to cause other transactions to starve
16:25:54 <Cale> So *something* will be happening
16:25:57 <hpc> ImUrBreda: it's the problem of two polite people in a hallway
16:26:00 <mm_freak> ImUrBreda: a livelock is the condition that a small failing transaction is interrupting a large transaction that would succeed
16:26:04 <Cale> But maybe not everything that ought to happen will be able to in every case.
16:26:13 <hpc> they bump into each other, and they both move to the other side of the hallway, so they still block each other ;)
16:26:43 <Cale> mm_freak: Er, don't you mean that small successful transactions are causing large ones to fail?
16:27:08 <mm_freak> Cale: oh, indeed
16:27:33 <ImUrBreda> seriously this is why i love haskell cause u guys are so smart
16:27:42 <ImUrBreda> downside is I feel very dumb but i can live with that
16:27:43 <mm_freak> ImUrBreda: anyway, livelocks are rare enough as a phenomenon, and you can count on the STM implementation to improve in the future without having to change your code
16:27:44 <hpc> bennofs: when you have many variables, you have either lots of locks (prone to deadlock), or fewer locks over loads of variables (prone to pointless blocking)
16:28:10 <hpc> ImUrBreda: in #haskell, nobody is immune to that feeling
16:28:13 <bennofs> So, I'm writing on another version of hdevtools (GHC API server for fast compiles), and there I have to track whether the cabal file or the package database was modified. Currently, I use an IORef Bool for that, and the filesystem watcher thread changes it when any of those files is modified. This variable is then read and cleared in the main request-response loop.
16:28:17 <Cale> ImUrBreda: I wrote a long comment on reddit at one point about the various kinds of things which can go wrong with concurrent programs, you might be interested in it
16:28:24 <Cale> I'll get a link :)
16:28:32 <ImUrBreda> Cale: definitely, thanks
16:28:49 <Cale> http://www.reddit.com/r/programming/comments/2wjai/defanging_the_multicore_werewolf/c2womz
16:28:50 <mm_freak> ImUrBreda: also for anything parallel/concurrent in haskell i recommend reading The Book =)
16:28:56 <mm_freak> ImUrBreda: http://chimera.labs.oreilly.com/books/1230000000929
16:29:16 <bennofs> I use one IORef Bool for package database changes and one IORef Bool for cabal file changes. Would using STM in this case simplifiy anything?
16:29:26 <Feuerbach> yes, definitely read The Book
16:29:35 <silasm> mm_freak: keep on meaning to order that. Got some Christmas cash :3
16:29:47 <mm_freak> silasm: go ahead =)
16:29:51 <ImUrBreda> mm_freak: thanks gonna buy that
16:29:53 <hpc> bennofs: yes, it could help
16:30:06 <mm_freak> ImUrBreda: that's a good idea…  while waiting for the printed version you can also read it online =)
16:30:11 <roconnor> I am really intruged by Palmer's ultra lazy case statements.  I kinda want to try to implement it.
16:30:33 <hpc> bennofs: it wouldn't make your code bug-free, since it's still dealing with the filesystem, but you can at least catch when one or both changes mid-transaction
16:30:33 <ImUrBreda> Cale: that's a long ass post mate :D
16:30:36 <silasm> I've read a few chapters in, it's pretty great. I especially love that he actually attempts to tackle Haskell's operational semantics.
16:30:41 <mm_freak> bennofs: i think anything is an improvement over IORef, even MVar
16:30:44 <ImUrBreda> bookmarked, going to read it tomorrow morning
16:30:54 <mm_freak> btw, MVars give you something that STM doesn't, which is useful in some cases:  fairness
16:31:47 <bennofs> But if I have code in my main loop like this: om when (readIORef cabalChanged) >> writeIORef cabalChanged False >> reloadCabal, what could go wrong?
16:32:00 <Khendon> This channel appears to be way over my head haha :D
16:32:15 <Khendon> is there a haskell for newbie programmers channel anywhere? ;)
16:32:23 * hackagebot http2 0.1.1 - HTTP/2.0 library including HPACK  http://hackage.haskell.org/package/http2-0.1.1 (KazuYamamoto)
16:32:40 <hpc> Khendon: that's here
16:32:43 <hpc> we discuss all things
16:32:44 <silasm> Khendon: it all depends on what's being asked
16:33:09 <Khendon> aaah ok that's cool.  I'll keep her open then, might learn something.
16:33:29 <hpc> bennofs: oh; i was imagining some kind of loop like
16:34:04 <hpc> forever $ do {c <- getCabal; p <- getPkg; f c p}
16:34:45 <hpc> bennofs: if the two are truly independent such that one could run without the other, there's not much benefit to STM (in terms of interaction between the two)
16:35:24 <hpc> bennofs: i agree that pretty much anything is better than IORef though; MVar is quite nice for simple stuff like what you describe
16:35:44 <bennofs> What improvements would an MVar give?
16:35:55 <mm_freak> bennofs: fairness
16:36:08 <mm_freak> the MVar implementation has a scheduling guarantee
16:36:26 <bennofs> I only have 2 threads, and I'm never blocking, so that shouldn't be neccessary :p
16:36:27 <_riley> My program is using more memory than I think it should: http://lpaste.net/97623. Anyone have any ideas for a newbie?
16:36:34 <hpc> it also doesn't give you the chance to accidentally write modifyIORef instead of atomicModifyIORef
16:36:35 <mm_freak> =)
16:37:17 <silasm> on a note mostly unrelated to anything being discussed at the moment, I'm thinking of writing a spreadsheet editor using haskell (with an hscurses frontend if possible) any pointers to libraries / texts / my insanity?
16:37:34 <hpc> _riley: can you try and cut parts of your code out and reproduce the leak on simpler programs?
16:37:39 <mm_freak> _riley: try to isolate the problem a bit more
16:37:41 * bennofs does a rgrep "modifyIORef" on his source code ...
16:37:45 <mm_freak> it's a lot of code to review
16:37:53 <enthropy> bennofs: your main loop waits periodically to check the cabalChanged ioref?
16:38:14 <bennofs> enthropy: my main loop only runs to handle a request from the client process
16:38:19 <bennofs> My process runs as a daemon
16:38:23 <_riley> I'll try.
16:38:25 <hpc> _riley: worst case, you find the function that's problematic, rewrite it, and fix the leak by accident ;)
16:39:00 <edwardk> Cale: hah
16:39:09 <_riley> hpc: The memory is "PINNED". I don't know where it's coming from.
16:39:19 <Tekmo> PINNED memory usually corresponds to bytestrings
16:39:44 <mm_freak> _riley: it's Storable memory, i.e. memory that doesn't get moved by the run-time system
16:39:45 <hpc> oh, yeah i should have mentioned that
16:40:25 <_riley> I was using bytestrings to conserve memory (I wanted byte packing). Perhaps that wasn't the best idea.
16:40:41 <mm_freak> _riley: to handle what kind of data?  text?
16:40:45 <dhrosa> at this link: http://www.haskell.org/haskellwiki/Monomorphism_restriction what makes the compiler treat f1 and f2 differently?
16:40:45 <Tekmo> Well, maybe you can simplify your algorithm
16:40:53 <Tekmo> Also, if you want to conserve memory, just use a `Vector`
16:41:03 <Tekmo> The `vector` library provides the `Vector` type
16:41:07 <_riley> mm_freak: Integers from 1 to 10.
16:41:14 <mm_freak> _riley: then what Tekmo said
16:41:29 <mm_freak> ByteString is really for handling binary data, not for numbers
16:41:46 <benmachine> dhrosa: silly, silly things
16:41:58 <Tekmo> Also, I think you should focus on simplifying your algorithm
16:42:10 <eikke> > type Max = 255
16:42:11 <lambdabot>  <hint>:1:1: parse error on input `type'
16:42:26 <benmachine> dhrosa: basically, f1 is a function binding and f2 is a pattern binding, they are different sorts of things
16:42:46 <benmachine> they ought to behave the same in this case, but the monomorphism restriction annoyingly stops them from doing so
16:43:08 <_riley> Tekmo: I agree. I'll start from the ground up with Vector and see where that gets me.
16:43:27 <mm_freak> _riley: the bottom line you should take away is not, "use Vector instead of ByteString"
16:43:52 <mm_freak> _riley: your algorithm may be such that lists would actually work best, but it depends a lot on the application
16:44:04 <hpc> dhrosa: the intention was to stop recomputation of expensive top-level constants
16:44:23 <hpc> dhrosa: when you compute something expensive that evaluates to say, 3
16:44:26 <mm_freak> _riley: so perhaps first explain the application without referring to data structures =)
16:44:36 <hpc> that 3 can be many different values, depending on the type
16:44:46 <hpc> so instead of keeping them all in memory, it keeps none
16:45:32 <hpc> the monomorphism restriction says "if you can't pick a type, i will", which in this example is Integer
16:45:41 <_riley> mm_freak: The goal is to find the minimum number of sublist reversals to convert one list into another list by trying every permutation.
16:45:53 <hpc> so at the end of one long computation, you have an evaluated 3 :: Integer value
16:45:58 <Tekmo> What is a sublist reversal?
16:46:12 <hpc> and it stays in memory
16:46:28 <mm_freak> "abcde" → "adcbe", i guess
16:46:41 <_riley> mm_freak: exactly.
16:46:45 <monochrom> don't try every permutation. this is a sorting problem.
16:46:54 <hpc> the solution is to give your top-level bindings type signatures
16:46:59 <hpc> which you should do anyway
16:47:14 <dhrosa> hpc: I kind of understand monomorphism restrictions, but I don't exactly see how that makes f1 fine and f2 not a problem
16:47:21 <dhrosa> err, f2 a problem
16:47:29 <hpc> dhrosa: f2 "looks like a value" because it doesn't take parameters
16:47:29 <benmachine> dhrosa: well, f2 isn't a problem
16:47:35 <hpc> instead it is a value that is a lambda
16:47:37 <benmachine> but things that look like f2 might be
16:47:42 <mm_freak> _riley: do you want to /count/ or do you want to actually figure out the reversals you need?
16:47:49 <hpc> which is not even remotely different except in syntax
16:48:01 <Fuuzetsu> can I not use arrow notation inside of Template Haskell quotes?
16:48:02 <_riley> mm_freak: I want to count.
16:48:11 <hpc> basically, it's completely arbitrary
16:48:15 <dhrosa> but that article said f2 wasn't allowed?
16:48:27 <mm_freak> _riley: then it seems like you can adapt the levensthein edit-distance algorithm
16:48:56 <Fuuzetsu> see http://lpaste.net/97625
16:48:57 <mm_freak> levenshtein
16:49:03 <hpc> dhrosa: ghc can't come up with a monomorphic type because it is very uncreative by default
16:49:15 <hpc> there's an extension that lets it try more things, particularly ()
16:49:23 <hpc> with that extension, f2 :: () -> String
16:50:07 <hpc> ExtendedDefaultRules
16:50:31 <silasm> hpc: wait, does that mean to use user-defined typeclasses with the nomonomorphismrestriction you need to give () an instance?
16:50:42 <mm_freak> _riley: i recommend that you first define your algorithm with recursive cases and base cases…  you can do that on paper or in code (as a haskell programmer you will probably learn to do it in code)
16:50:43 <silasm> (assuming I didn't say that totally wrong)
16:51:00 <_riley> mm_freak: this is very similar to my goal, though the algorithm works one character at a time.
16:51:05 <hpc> silasm: no
16:51:40 <hpc> the whole thing means if you want to write your own type class and have top-level definitions get monomorphismicized
16:51:48 <hpc> you need to give an instance that it will attempt
16:51:49 <enthropy> Fuuzetsu: make a quasiquote that calls the standalone preprocessor that can desugar arrows?
16:51:50 <gamegoblin> Is the best way to map a list of functions over a single value to do "map ($val) functions"
16:52:01 <Tekmo> gamegoblin: Yes
16:52:01 <hpc> which i don't know exactly how it works
16:52:22 <hpc> silasm: really, you shouldn't be writing code that hits the monomorphism restriction
16:52:30 <silasm> hpc: simple enough, yeah. I've only ever run into the problem once, I think (and that must have been ghci or a let or where-binding, because those are the only places I don't explicitly type)
16:52:36 <hpc> silasm: if you want a top-level definition to be monomorphic, give it the type
16:52:39 <shachaf> edwardk: I was trying to come up with a type Oc such that Oc (e,) = (e->), Oc (e->) = (e,), Oc (State s) = Store s
16:52:43 <hpc> ah, yeah
16:52:46 <mm_freak> _riley: anyway, note that ByteString uses sharing…  when you throw away part of a ByteString, it doesn't automatically shrink
16:52:52 <hpc> that's more annoying ;)
16:53:14 <shachaf> I think Oc m r = forall r. m r -> (r,a) works.
16:53:19 <mm_freak> _riley: if you have used, say, 'splitAt' on a ByteString and you want to throw away the unused memory, use 'copy'
16:53:25 <shachaf> But it seems kind of awful. :-(
16:53:26 <silasm> hpc: yeah, but as I recall it was simple enough to deal with; at least in my case.
16:53:26 <mjo> Anyone have an idea how to get a DTD out of HXT? When I use readDocument I get a weird document structure with some HTTP junk at the top.
16:53:30 <Fuuzetsu> enthropy: All I want is to splice in a constructor name and that sounds like much less work than some copy + paste
16:53:47 <silasm> hpc: just dumb in that it doesn't make a whole lot of sense to someone who doesn't already know about the MMR
16:53:47 <mm_freak> _riley: but even then the proper solution is to use Vector
16:53:54 <edwardk> shachaf: kinda hard to pass it IO =)
16:53:57 <Fuuzetsu> much more work*
16:54:00 <hpc> in any event, the monomorphism restriction is usually helpful, in the sense that it turns bad haskell into slightly better binary
16:54:07 <mm_freak> _riley: which, btw, has the same sharing property
16:54:21 <hpc> silasm: a little context is a wonderful thing :D
16:54:37 <edwardk> also Oc m a = forall r. m r -> (r, a) ?
16:54:46 <shachaf> Er, yes.
16:54:52 <shachaf> Well, is (forall r. IO r -> (r, a)) a comonad?
16:54:59 <edwardk> and you'll find that many monads it doesn't work for, Maybe, etc.
16:55:09 <hpc> shachaf: its only inhabitant is bottom ;)
16:55:29 <_riley> mm_freak: I'm using head, tail, drop, reverse, etc. Do these share as well?
16:55:38 <shachaf> hpc: Sure. So there you go.
16:55:40 <hpc> shachaf: or if you take a very silly interpretation, it's isomorphic to a
16:55:44 <mm_freak> _riley: tail and drop do
16:55:48 <hpc> which is yes on both accounts
16:55:49 <mm_freak> reverse obviously doesn't
16:56:00 <binroot> @pl \n = (fromIntegral n) :: Double
16:56:00 <lambdabot> (line 1, column 4):
16:56:00 <lambdabot> unexpected "="
16:56:00 <lambdabot> expecting operator, pattern or "->"
16:56:02 <_riley> mm_freak: then that explains the memory leak.
16:56:09 <mm_freak> _riley: think of it this way:  if sharing is possible, it is used
16:56:20 <edwardk> in general the Rift construction that turns a comonad into a monad always exists, but there isn't a dual construction that you can rely on, because there isn't a corresponding coexponential to take the adjunction through
16:56:23 <binroot> @pl \n -> (fromIntegral n) :: Double
16:56:23 <lambdabot> (:: Double) . fromIntegral
16:56:51 <pavonia> :t (:: Double)
16:56:52 <lambdabot> parse error on input `::'
16:56:58 <Rarrikins> Is there a nice way to retrieve and parse data from a web page and cache it for a set amount of time, automatically refreshing it if the cache expires?
16:57:24 <hpc> Rarrikins: Map String (UTCTime, String)
16:57:26 <hpc> ;)
16:57:30 <edwardk> My Co comonad-to-monad-transformer is based on the fact that you can always take an adjunction F -| G, and get a monad GF out of it, but GMF is also a monad given a monad on the category the adjunction goes through, i take an end when i'm done, but there are no interesting adjunctions the other way.
16:57:31 <Rarrikins> And refreshing it lazily.
16:57:44 <Rarrikins> hpc: Something like that sounds decent.
16:57:48 <mm_freak> Rarrikins: Behavior Page
16:58:06 <mm_freak> or Behavior String, whatever
16:58:14 <hpc> you and your frp
16:58:19 <mm_freak> =)
16:58:38 <hpc> Rarrikins: i think you'd want a priority queue based on the timestamp actually
16:58:45 <hpc> or what mm_freak says if you're a granola eater
16:59:14 <zRecursive> @wn granola
16:59:16 <lambdabot> *** "granola" wn "WordNet (r) 3.0 (2006)"
16:59:16 <lambdabot> granola
16:59:16 <lambdabot>     n 1: cereal made of especially rolled oats with dried fruits and
16:59:16 <lambdabot>          nuts and honey or brown sugar
16:59:18 <shachaf> I never really bought the "take an end" thing.
16:59:57 <mm_freak> hpc: i wonder why you don't think FRP is a good solution for this
17:00:01 <hpc> Rarrikins: if you can get an frp version to work, you should paste it here as an example of something simple but non-trivial
17:00:03 <edwardk> (_ -> e) -| (_ -> e)  holds because (a -> e) <- b -| a -> (b -> e) witnessed by flip  is an adjunction G :: Hask^op -> Hask with F :: Hask -> Hask^op   when you go looking for an adjunction from Hask -> Hask^op on the other hand you get only a trivial option
17:00:08 <hpc> mm_freak: i just don't understand it and am being snarky ;)
17:00:16 <mm_freak> i see =)
17:00:23 <hpc> it's probably a good solution, really
17:00:32 <edwardk> shachaf: you can call it a right kan lift of the identity functor along a comonad if it makes you feel better ;)
17:00:34 <shachaf> zRecursive: Can you take your @wns to /msg lambdabot unless there's a good reason for it in-channel?
17:00:41 <Rarrikins> OK, thanks.
17:00:44 <Rarrikins> FRP looks interesting.
17:00:49 <hpc> but yeah, that would be a very good example of FRP
17:00:50 <zRecursive> shachaf: sure
17:00:57 <shachaf> edwardk: I just mean in connection with the adjunction.
17:01:09 <mm_freak> well, pageContent :: String
17:01:12 <hpc> in a setting that isn't games or terrible spreadsheet metaphors
17:01:18 <mm_freak> how do you model page content that changes over time?
17:01:24 <shachaf> But perhaps that's related to not understanding ends well enough.
17:01:36 <mm_freak> seems like a behavior is natural there =)
17:01:41 <mm_freak> pageContent :: Behavior String
17:01:42 <hpc> mm_freak: fire a "reload the page" event at the timestamp where it expires
17:02:00 <edwardk> speaking of (co)ends i added the associator for profunctor composition to profunctors the other day
17:02:12 <mm_freak> hpc: huh?  no events there, although you can construct that behavior from an event
17:02:18 <hpc> or something
17:02:22 <mm_freak> pageChanged :: Event String
17:02:23 <hpc> mm_freak: i said i don't know frp ;)
17:02:35 <shachaf> edwardk: Anyway all that's saying is that you can't use the same trick, not that there is no trick.
17:02:42 <edwardk> i've been doing a lot of work with bicategories lately and realized it was missing when i went to encode the notion of profunctors we use properly as a bicategory
17:02:46 <shachaf> Not that I'd be surprised if there is no trick.
17:03:08 <edwardk> shachaf: sure, i'm just pointing out there is no adjunction you can use to cleanly turn a monad to a comonad the same kind of way
17:03:08 <hpc> shachaf: no trick from Monad -> Comonad?
17:03:21 <edwardk> i blogged about that fact a while back, hrmm
17:03:22 <hpc> shachaf: i would think IO is the clear example of why it doesn't exist
17:03:25 <shachaf> edwardk: Yes, but you've already pointed that out. :-)
17:03:59 <shachaf> hpc: Why?
17:04:08 <hpc> an IO comonad has extract :: IO a -> a
17:04:14 <mm_freak> hpc: no
17:04:21 <shachaf> I didn't say IO is a comonad.
17:04:29 <mm_freak> it has extract :: F IO a -> a
17:04:33 <edwardk> http://comonad.com/reader/2011/monad-transformers-from-comonads/
17:04:46 <hpc> mm_freak: oh yes, derp
17:04:54 <mm_freak> which doesn't necessarily correspond to runIO =)
17:04:58 <shachaf> I believe you that it's not easy or even possible to write foo :: M a -> a for an artbirary monad.
17:05:15 <shachaf> But similarly it isn't to write foo :: a -> W a for an arbitrary comonad.
17:05:35 <hpc> yeah, so F would either be defined to not admit IO as a parameter, or it would ignore that parameter entirely
17:05:38 <edwardk> mm_freak: sure, its just that unlike in the comonad case where there is a canonical construction that gives rise to something like a cauchy completion, we don't have such a construction to depend on to build one for the monad case
17:05:45 <hpc> newtype F m a = F a -- would work!
17:06:20 <mm_freak> hpc: F = Const Identity
17:06:22 <hpc> (it's missing the laws regarding how to sequence and lift, but still)
17:06:24 <mm_freak> which is not very interesting =)
17:06:41 <mm_freak> i think F gets interesting when it's an isomorphism
17:07:25 <mm_freak> or at least something like a mono+epi (i forgot the name of that)
17:08:12 <mm_freak> bimorphism
17:08:22 <edwardk> bimorphism
17:08:23 <edwardk> yeah
17:08:54 <shachaf> Bimorphisms of types in Haskell don't sound like they'd be interesting.
17:09:14 <mm_freak> shachaf: why not?
17:09:28 <shachaf> It sounds like they'd be isomorphisms.
17:09:49 <shachaf> Well. Depending on what category you're talking about.
17:10:09 <mm_freak> i'd rather think that there are only few isomorphisms on haskell types, and in fact most of what we call isomorphisms are actually bimorphisms
17:10:59 <shachaf> Why?
17:11:21 <edwardk> in set every bimorphism is an isomorphism, hask as a constructive analogue to set probably preserves or at least approximates this property
17:11:38 <mm_freak> well, we may disagree on what makes types equal, but here is an example:  newtype Id a = Id a
17:12:06 <mm_freak> the isomorphism version would be:  type Id a = a
17:12:23 <shachaf> Wait, what category are you even talking about here?
17:12:29 <mm_freak> Hask
17:12:41 <edwardk> i think you are making a case about haskell functors, not the morphisms in hask
17:12:44 <shachaf> OK, so which morphism are you talking about?
17:13:31 <edwardk> Functor is a weird beast, it always maps to a particular kind of proper subcategory of Hask, mangled with that type constructor
17:13:37 <mm_freak> oh, wait…  i'm not talking about Hask…  edwardk is right
17:14:04 <mm_freak> i'm actually in a functor category
17:14:21 <edwardk> i first joined the haskell channel to pick a fight about Functor, so I well remember getting schooled by Cale on the topic ;)
17:15:07 <mm_freak> hehe
17:16:03 <mm_freak> in fact i'm not even in a functor category…  what is that thing that can map a monad to a comonad?  is that a thing at all?
17:16:11 <mm_freak> it sounds like it should be some form of natural transformation
17:16:42 <shachaf> OK, now I'm confused.
17:16:53 <shachaf> You're saying that some thing is a bimorphism or an isomorphism or whatever.
17:17:01 <shachaf> Which thing is it? It has to be a morphism in some category.
17:17:55 <mm_freak> shachaf: the topic was this thing that maps every monad to a comonad in a sensible way
17:18:09 <edwardk> the one that doesn't exist? =)
17:18:37 <mm_freak> well, it does exist:  newtype F m a = F a
17:18:52 <shachaf> You said that "newtype Id a = Id a" is associated with a bimorphism, and "type Id a = a" is associated with an isomorphism.
17:18:55 <mm_freak> and my point is that that's not a very interesting thing =)
17:19:16 <shachaf> Is there a point to keeping talking?
17:20:01 <mm_freak> shachaf: i guess not
17:22:35 <shachaf> Then I'll stay confused.
17:23:34 <mm_freak> shachaf: remember hpc's comment that nobody in #haskell is immune to feeling dumb?  i'm feeling dumb right now =)
17:23:41 <mm_freak> i really didn't think that through
17:25:54 <shachaf> Hm.
17:26:15 <shachaf> I have approximately no sense of what bimorphisms are like.
17:26:46 <hpc> ... who is hpd?
17:27:53 <stolaruk> > "hpc" `compare` "hpd"
17:27:54 <lambdabot>  LT
17:27:57 <stolaruk> uh oh
17:28:12 <bennofs> hpd is a daemon controlled by hpc
17:28:14 <bennofs> I guess
17:28:23 <hpc> haha
17:28:33 <Feuerbach> hpc: he is Hans-Peter Deifel, according to /whois. And who are you? :)
17:28:42 <hpc> @remember hpc nobody in #haskell is immune to feeling dumb
17:28:42 <lambdabot> I will never forget.
17:28:48 <hpc> that quote is too useful to leave forgotten
17:29:00 <hpc> Feuerbach: i am spartacus
17:29:44 <mm_freak> shachaf: something that isn't quite an isomorphism, but does have some of the properties of an isomorphism
17:30:11 <Feuerbach> hpc: Is that your real name? (I'm genuinely curious, but it's fine with me if you don't want to tell.)
17:30:14 <shachaf> An isomorphism has every property.
17:30:28 <aristid> Feuerbach: spartacus is most likely not his real name :)
17:30:38 <shachaf> Head Programming Czar doesn't sound like it either.
17:30:43 <shachaf> Though who knows.
17:30:47 <aristid> shachaf: and i thought it was
17:31:10 <nyc> Principal Engineer seemed to do it for me.
17:31:14 <aristid> well i have good evidence here that his Real Name is Juzz
17:31:59 <shachaf> hi nyc
17:32:03 <Feuerbach> maybe it's not he but she
17:32:25 <aristid> * The masculine gender shall be deemed to include the feminine gender.
17:32:37 <shachaf> aristid: Uh...
17:32:46 <hpc> haha
17:33:14 <hpc> it's a bird! it's a plane! it's... hpc!
17:34:23 <shachaf> It's #haskell-blah! It's #haskell-overflow! It's... Oh, it's #haskell.
17:36:01 <Tekmo> I don't mind as long as there are no other productive conversations
17:36:02 <mm_freak> amaze!
17:36:04 <aristid> shachaf: ah sometimes easy to lose track of that
17:37:09 <erisco> how can I construct a Word8?
17:37:17 <Tekmo> erisco: You can use `fromIntegral`
17:37:24 <Tekmo> erisco: Or you can use a numeric literal
17:37:25 <mm_freak> erisco: 5
17:37:30 <erisco> > (fromIntegral 5) :: Word8
17:37:31 <lambdabot>  5
17:37:33 <mm_freak> > 5 :: Word8
17:37:33 <erisco> mkay
17:37:34 <lambdabot>  5
17:37:47 <aristid> hey Tekmo let's say i have a (Producer a m () -> m b) and a (FreeT (Producer a m ())), would there be a nice way to get a Producer b m ()?
17:37:50 <erisco> I really wish they allowed
17:37:53 <erisco> > 'a' :: Word8
17:37:54 <lambdabot>  Couldn't match expected type `GHC.Word.Word8'
17:37:54 <lambdabot>              with actual type `GHC.Types.Char'
17:38:02 <Tekmo> erisco: The reason why is that all numeric literals have type `(Num n) => n`
17:38:09 <Tekmo> erisco: Well, sort of
17:38:12 <triliyn> :t ord
17:38:12 <lambdabot> Char -> Int
17:38:13 <hpc> erisco: ask a silly question, you get a silly answer ;)
17:38:24 <lispy> :t 1.2
17:38:26 <lambdabot> Fractional a => a
17:38:27 <Tekmo> Yeah
17:38:30 <Tekmo> That's the "sort of" part
17:38:34 <triliyn> hmm, I guess you have to use fromIntegral to get it as a word8
17:38:53 * lispy would consider 1.2 to be a numeric literal
17:39:26 <mm_freak> erisco: that's because it's wrong to do that
17:39:41 <aristid> > ord 'a'
17:39:42 <lambdabot>  97
17:39:52 <mm_freak> there is no function from unicode literals to Word8
17:40:08 <adelbertc> can someone remind me what the difference is between mapM_ and mapM
17:40:17 <aristid> mm_freak: would be nice sometimes to have a way to denote ASCII literals though :)
17:40:18 <geekosaur> mapM_ discards the result
17:40:20 <erisco> :t mapM_
17:40:21 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
17:40:22 <erisco> :t mapM
17:40:22 <mm_freak> adelbertc: one collects the results, the other one doesn't
17:40:23 <lispy> mm_freak: do you mean no bijective function?
17:40:23 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
17:40:29 <geekosaur> whoch is most useful with IO stuff that would return [(),(),...]
17:40:44 <adelbertc> aha cheers, all
17:40:47 <lispy> mm_freak: we could always just say 'const 0' :)
17:40:49 <geekosaur> (rtaher IO [(),...])
17:40:50 <adelbertc> for some reason my eyes filtered out the return type
17:41:06 <mm_freak> lispy: well, no sensible function =)
17:42:51 <mm_freak> if you really really really know what you're doing, you can use fromIntegral . ord
17:43:00 <mm_freak> :t fromIntegral . ord :: Char -> Word8
17:43:01 <lambdabot> Char -> Word8
17:43:12 <aristid> sometimes i have literals in the code. like 'A'.
17:43:19 <aristid> i know that 'A' is in ASCII.
17:43:33 <aristid> having to type 65 to pattern match that instead helps nobody.
17:43:41 <carter> btw, does anyone know how i can make ghc static link to a lib.a file?
17:44:02 <triliyn> Is a Word8 8 bits or 8 bytes?
17:44:04 <mm_freak> aristid: that's why some libraries give you an unsound you-know-what-you're-doing "Char8" interface
17:44:06 <triliyn> I guess it would be 8 bits
17:44:09 <aristid> triliyn: 8 bits
17:44:32 <mm_freak> > -1 :: Word8
17:44:33 <lambdabot>  255
17:44:36 <aristid> mm_freak: i think there should just be ascii literals that have type word8.
17:44:58 <mm_freak> aristid: then propose OverloadedChars =)
17:45:00 <aristid> all the WordN are modulo 2^n arithmetic
17:45:13 <aristid> mm_freak: i'm also really lazy, and complaining is easier than fixing :)
17:45:14 <mm_freak> i wouldn't mind having that extension =)
17:45:22 <lispy> carter: isn't that the only choice for .a files?
17:45:38 <lispy> carter: is it the case that you also have a .so version? If so, the linker might be preferring it.
17:45:45 <triliyn> Is it legal for identifiers to start with '?
17:45:50 <carter> no so
17:45:51 <mm_freak> triliyn: no
17:46:04 <nyc> I suppose I could dredge up my old complaint about natural number literals.
17:46:24 <carter> lispy: hangon, i'm going to try 1-2 other things then i'll link you to the repo
17:46:36 <mm_freak> triliyn: sometimes you /get/ identifiers starting with ', but you never /define/ them
17:46:46 <mm_freak> for example with the DataKinds extension
17:47:00 <geekosaur> if all else fails you could just provide the full path of the .a
17:47:02 <triliyn> data UglyAscii = _'A' | _'B' | ... {- _'!' won't work because ! is an operator -} _'Exc' | ...
17:47:04 <mm_freak> and sometimes when using TemplateHaskell you also have to write the '
17:47:09 <twiceler> carter: I did that recently. I believe I just named it /the/path/libwhatever.a and do -lwhatever and -L/the/path and it worked
17:47:21 <aristid> triliyn: identifiers _can_ have a ' in the middle
17:47:44 <carter> twiceler: the tricky bit is i'm building the lib IN the cabal folder
17:47:56 <benbangert> so uh, is there a style preference for functions which use System.Random? take a StdGen and stay pure? return an IO result to keep usage easier (at the expense of purity)?
17:47:56 <geekosaur> so just foo.a
17:47:58 <triliyn> aristid: right, which lets you right nice things like "don't" and "isn't"
17:48:11 <lispy> carter: hackage won't accept that, BTW
17:48:18 <carter> lispy: wont accept what?
17:48:19 <twiceler> carter: And I tried to do that! So I gave up and installed it into a system directory separately
17:48:28 <mm_freak> triliyn: you can enable OverloadedStrings and write an instance for Word8, and that abuse is hard to beat =)
17:48:29 <twiceler> carter: so I can't help you with that :(
17:48:38 <lispy> carter: relative paths to an archive that you want to link with
17:48:52 <mm_freak> instance IsString Word8 where fromString = fromIntegral . ord . head
17:48:53 <carter> lispy: thats why i'm hacking the setuphs to give an absolute path :)
17:48:59 <mm_freak> =)
17:49:14 <carter> the setup.hs is always run at the root of the cabalized project, right?
17:49:25 <triliyn> That even lets you write comments :D
17:49:35 <carter> lispy: am i making sense?
17:49:42 <triliyn> a :: Word8; a = "a This is the ascii value 'a'"
17:49:54 <mm_freak> hehe indeed
17:50:00 <lispy> carter: I doubt that invariant is _always_ true
17:50:04 <mm_freak> benbangert: i prefer to stay general and pass RandomGens around
17:50:27 <carter> lispy: well, i'm open to discovering that:)
17:50:33 <benbangert> mm_freak: yea, it does make it a bit less convenient that I need to keep returning the new gen every time
17:50:43 <dhrosa> benbangert: are you using it multiple times in a row?
17:50:52 <benbangert> dhrosa: yup, bunch of times in a row
17:50:54 <mm_freak> benbangert: you can always wrap it in a state monad
17:50:58 <dhrosa> have you looked at the State monad?
17:51:07 <mm_freak> ("state monads")
17:51:14 <benbangert> I have not...
17:51:21 <dhrosa> it'll let you chain together functions like yours without having to store those intermediate gens
17:51:26 <benbangert> ahhh
17:51:31 <benbangert> and the functions themselves will stay pure?
17:51:35 <dhrosa> yes
17:51:38 <benbangert> sweet
17:51:39 <mm_freak> ("they'll let you …")
17:51:55 <benbangert> is there a tutorial/example I can look at?
17:52:08 <mm_freak> benbangert: you can try to implement it yourself
17:52:20 <mm_freak> benbangert: newtype State s a = State (s -> (a, s))
17:52:32 <mm_freak> start by writing a Functor instance for this type
17:52:33 <benbangert> mm_freak: yea, been learning a bunch doing that so far :)
17:52:47 <mm_freak> there is really only one correct way to do it =)
17:53:58 <mm_freak> if you have trouble understanding this type, look at this:  newtype Rand a = Rand (StdGen -> (a, StdGen))
17:54:07 <dhrosa> benbangert: http://learnyouahaskell.com/for-a-few-monads-more the State monad section is one place you can look
17:54:24 <benbangert> dhrosa: lol, I had that open, did not get down to that yet.... only hit the Writer bit
17:56:26 <mm_freak> benbangert: i still recommend you to implement it yourself first =)
17:57:00 <mm_freak> it's a not too difficult but non-trivial exercise
17:57:12 <benbangert> thanks, I'll give that a spin first
17:58:00 <mm_freak> start with Rand…  if you can write Functor and Monad instances for it, you will notice that the ones for State are almost the same =)
17:58:17 <mm_freak> because Rand ≃ State StdGen
17:59:02 <twiceler> Okay, so I'd like an explanation of this one:
17:59:04 <twiceler> > otherwise
17:59:05 <lambdabot>  True
17:59:08 <twiceler> > :t otherwise
17:59:09 <lambdabot>  <hint>:1:1: parse error on input `:'
17:59:20 <twiceler> :t otherwise
17:59:21 <lambdabot> Bool
17:59:25 <twiceler> case False of { True -> 1; otherwise -> 0 }
17:59:29 <twiceler> > case False of { True -> 1; otherwise -> 0 }
17:59:30 <lambdabot>  0
17:59:48 <aristid> twiceler: note that here otherwise is shadowed.
18:00:09 <fl00r> > (fromIntegral . ord) 'ς' :: Integer
18:00:10 <lambdabot>  962
18:00:15 <fl00r> > (fromIntegral . ord) 'ς' :: Word8
18:00:15 <triliyn> > otherwise && (let otherwise = False in otherwise)
18:00:16 <lambdabot>  194
18:00:16 <lambdabot>  False
18:00:29 <aristid> > (fromIntegral . ord) 'ä'
18:00:30 <lambdabot>  228
18:00:33 <mm_freak> twiceler: you may be confusing patterns with guards
18:01:01 <mm_freak> > case "blah" of x | length x == 3 -> "yes" | otherwise -> "no"
18:01:02 <lambdabot>  "no"
18:01:17 <twiceler> mm_freak: So otherwise is a guard? How does it know whether to choose the pattern or the guard when pattern-matching on a Bool?
18:01:25 <mm_freak> twiceler: it doesn't
18:01:33 <mm_freak> 'otherwise' is not special
18:01:37 <stolaruk> > otherwise
18:01:38 <carter> gah
18:01:38 <lambdabot>  True
18:01:40 <aristid> twiceler: otherwise is just a value defined as:
18:01:42 <mm_freak> it's defined in the Prelude
18:01:43 <carter> i lurve linking woese
18:01:44 <aristid> otherwise = True
18:02:02 <mm_freak> > let otherwise = "haha" in otherwise
18:02:03 <twiceler> OH... right because you need to put a constructor in
18:02:03 <lambdabot>  "haha"
18:02:12 <geekosaur> otherwise just takes advantage of the fact that a guard is a boolean
18:02:15 <mm_freak> twiceler: you're redefining 'otherwise' =)
18:02:21 <fl00r> > rem 962 256
18:02:22 <lambdabot>  194
18:02:23 <geekosaur> if that boolean is always True then that guard always matches
18:02:30 <aristid> twiceler: in pattern matches if you want to actually match anything, yes. otherwise you just shadow the variable
18:02:39 <twiceler> > let false = False = in case False of { false -> "won't work"; otherwise -> "will work" }
18:02:41 <lambdabot>  <hint>:1:19: parse error on input `='
18:02:48 <mm_freak> twiceler: similarly in a guard you could just as well write "True" instead of "otherwise"
18:02:52 <mm_freak> because otherwise = True
18:02:52 <twiceler> > let false = False in case False of { false -> "won't work"; otherwise -> "will work" }
18:02:53 <lambdabot>  "won't work"
18:02:54 <geekosaur> and `| otherwise =` is more readable than `| True =`
18:03:09 <aristid> geekosaur: otherwise makes code easier to read, but i guess it's a bit pedagogically dubious in that it suggests magic where there is none
18:03:17 <twiceler> And NOW I'm really confused
18:03:25 <stolaruk> twiceler: how so
18:03:34 <mm_freak> twiceler: a guard is a boolean, right?
18:03:35 <triliyn> twiceler: "false" in that case is a variable that matches anything
18:03:48 <geekosaur> twiceler, your case redefines false
18:04:01 <twiceler> twiceler: Oh... THAT's what you were saying that otherwise is shadowed
18:04:01 <shapr> @quote geekosaur
18:04:01 <lambdabot> geekosaur says: "tekmo and the pipes list" sounds like some kind of postmodernist band
18:04:01 <geekosaur> as a variable that matches anything and binds to it
18:04:05 <stolaruk> > if otherwise then "boo" else "hoo"
18:04:06 <lambdabot>  "boo"
18:04:16 <shapr> stolaruk: Is Haskell worth learning?
18:04:16 <mm_freak> twiceler: check this out:
18:04:21 <mm_freak> > let 2 + 2 = 5 in 2 + 2
18:04:22 <lambdabot>  5
18:04:27 <mm_freak> same shadowing phenomenon
18:04:32 <stolaruk> shapr: Uh yeah why do you ask? :)
18:04:32 <twiceler> > case False of { otherwise -> not otherwise }
18:04:33 <lambdabot>  True
18:04:41 <mm_freak> i'm really just defining a new (+) and shadowing the old one
18:04:44 <shapr> stolaruk: just wondering... I've heard it's cool
18:04:48 <triliyn> > let 2 + 2 = 5 in 2 + 1 -- undefined, because we didn't define this combination!
18:04:49 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
18:04:57 <shapr> stolaruk: How long have you been learning Haskell?
18:05:11 <stolaruk> shapr: Most ppl on this channel will tell you it's worth learning. I've been learning it since March
18:05:26 <stolaruk> No May
18:05:35 <shapr> stolaruk: Did you know other languages before you learned Haskell? How does it compare?
18:05:46 <Azertye> mm_freak, only Haskell :D
18:05:53 <twiceler> mm_freak: No! I had no idea that was legal Haskell. I feel like it shouldn't be!
18:06:06 <mm_freak> twiceler: why?
18:06:15 <mm_freak> Azertye: hmm?
18:06:31 <triliyn> > let (+) = "hands" in (+)
18:06:32 <stolaruk> shapr: Yeah, Java, C#, a little Common Lisp. As it's a purely functional language, and not OOP, it's quite different than anything I knew prior. Though CL has some functional programming aspects
18:06:32 <lambdabot>  "hands"
18:06:39 <geekosaur> twiceler, it's legal but often questionable.. and if you use -Wall, you will be warned about shadowing like that
18:06:43 <twiceler> mm_freak: How can you pattern match a function application? Ohhh I see
18:06:47 <shapr> stolaruk: Does the purity make Haskell hard to jump into?
18:06:49 <geekosaur> but there are times when you want that behavior
18:06:54 <Azertye> mm_freak, don't tell me it's possible in other languages too
18:06:56 <geekosaur> so it is not an error
18:06:58 <mm_freak> twiceler: i'm not doing that
18:07:09 <mm_freak> twiceler: did you ever write "f x = …"?
18:07:11 <twiceler> mm_freak: Yeah. The infix notation just confused me there
18:07:12 <shapr> Perhaps I should write some Haskell.
18:07:16 <stolaruk> shapr: It's a matter of learning a new programming paradigm. But it's not as hard as some ppl say.
18:07:33 <DigitalKiwi> stolaruk: it's harder ;)
18:07:35 <shapr> stolaruk: What resources did you use to learn Haskell?
18:07:58 <mm_freak> twiceler: if yes, why didn't you write "f otherwise = …"?  i mean, why didn't you name the variable 'otherwise' instead of 'x'?  of course you would be overriding the 'otherwise = True' from the Prelude, but …
18:08:09 <Azertye> It's only hard if you expect you'll make things like you did in another language, right from the start
18:08:30 <dhrosa> like trying to speak SPanish by adding -o's to English words
18:08:34 <mm_freak> Azertye: well, it's possible in some other languages, but they are probably a lot like haskell ;)
18:08:48 <triliyn> I wonder, can you use operators as argument names?
18:08:50 <geekosaur> twiceler, do you want to get an error because you accidentally named something the same as some imported thing you don't care about?
18:08:51 <Azertye> mm_freak, well that's what I thought
18:08:54 <stolaruk> shapr: Haskell starts from a high level perspective, rich in abstractions that, for the most part, come from mathematics. If you need to get "close to the metal" you can do so, too. Other languages like, say, C++, start close to the metal and add abstractions on top of that, namely OOP
18:08:56 <mm_freak> triliyn: sure, why not?
18:09:08 <triliyn> > let otherwise (+) = 'a' + "fish" in otherwise (++)
18:09:08 <lambdabot>  Couldn't match type `[GHC.Types.Char]' with `GHC.Types.Char'
18:09:09 <lambdabot>  Expected type: GHC.Types.Char
18:09:09 <lambdabot>                 -> [GHC.Types.Char] -> [GHC.Types.Char]
18:09:09 <lambdabot>    Actual type: [GHC.Types.Char]
18:09:09 <lambdabot>                 -> [GHC.Types.Char] -> [GHC.Types.Char]
18:09:17 <mm_freak> > let f (+) = (+) - 2*(+) in f 5
18:09:18 <lambdabot>  -5
18:09:22 <twiceler> I was just confused by the shadowing! That's all. I get it now
18:09:30 <stolaruk> shapr: I read Learn You A Haskell, presently I'm reading Real World Haskell. You can read both for free online. I'd highly recommend you just start reading LYAH and dive in
18:09:33 <geekosaur> so turn on -Wall
18:09:39 <shachaf> @src on
18:09:39 <lambdabot> (*) `on` f = \x y -> f x * f y
18:09:54 <triliyn> > let otherwise (+) = 'a' + "fish" in otherwise (:)
18:09:55 <lambdabot>  "afish"
18:10:06 <shapr> stolaruk: Thanks, I'll do that.
18:10:09 <triliyn> Right, silly mistake of mine >.>
18:10:37 <twiceler> That "otherwise" thing is tricky because the True definition makes it a catch all for both pattern matching and guards. But I thought when you used otherwise in pattern-matching, it was still somehow one of those guard cases. Now I know! thanks
18:10:37 <stolaruk> shapr: LYAH is actually a VERY good book. http://learnyouahaskell.com
18:10:39 <mm_freak> it's a bit sad that you can't use operator variables in type signatures anymore
18:10:39 <shapr> I'd like to use Haskell to write code for my Arduinos, is that possible?
18:10:59 <mm_freak> x :: AT (>~) a b >~ b
18:11:13 <geekosaur> hArduino, atom?
18:11:25 <shapr> @hackage hArduino
18:11:25 <lambdabot> http://hackage.haskell.org/package/hArduino
18:11:34 <shapr> spiffy, I'll take it.
18:11:37 <ob_> going from python and javascript tutorials, haskell doesn't seem like a computer language
18:11:39 <mm_freak> twiceler: no, it doesn't
18:11:57 <geekosaur> the True definition has nothing to do with pattern matching
18:12:08 <mm_freak> twiceler: 'otherwise' in patterns is a catch-all simply because it's a variable
18:12:10 <twiceler> Yeah, it's just a variable. I get it now
18:12:10 <geekosaur> any name you use in a pattern match becomes a local binding, period
18:12:14 <Azertye> That reminds of something. I'd like to know if there is a library to write dynamic websites/web applications in Haskell.
18:12:27 <shapr> Azertye: I've heard of scotty
18:12:27 <stolaruk> shapr: You might find this interesting. http://acm.wustl.edu/functional/haskell.php
18:12:32 <mm_freak> > case Just 5 of Nothing -> "no"; Just otherwise -> "yes"
18:12:34 <lambdabot>  "yes"
18:12:37 <geekosaur> doesn't matter what if anything it used to mean, you can't get at the old one while the new binding is in scope
18:12:48 <shapr> stolaruk: it has CAT PICTURES!
18:12:50 <Azertye> shapr, I'll check it out, thanks
18:12:51 * shapr hops cheerfully
18:12:55 <stolaruk> shapr: haha yeah
18:13:02 <twiceler> Yeah I got it. When I said "Now I know", I meant "Now I know what I said in the previous sentence is false."
18:13:02 <shapr> Azertye: I've also heard of yesod
18:13:12 <mm_freak> ah =)
18:13:30 <mm_freak> Azertye: lots of them actually
18:13:37 <fl00r> it messes with your head like connotations in natural languages
18:13:43 <mm_freak> Azertye: the big three are happstack, snap and yesod
18:13:49 <mm_freak> (alphabetical)
18:14:02 <Azertye> Thanks a lot, mm_freak!
18:14:30 <Azertye> I didn't think there would even me multiple
18:14:43 <mm_freak> happstack is a good compromise for both safety and nice abstractions
18:14:52 <stolaruk> shapr: Why are you interested in Haskell? How did you find out about it?
18:14:56 <mm_freak> snap gives you less safety by default and nicer modularity
18:15:13 <mm_freak> yesod gives you more safety by default, but uses the traditional MVC approach, if you like it
18:15:13 <shapr> stolaruk: Er, I actually found out about Haskell some years ago
18:15:39 <shapr> stolaruk: just over twelve years ago in fact
18:15:55 <stolaruk> shapr: Oh well Haskell has matured quite a bit since then
18:16:04 <mm_freak> my personal preference is happstack
18:16:09 <shapr> stolaruk: But at the time, there was only the Gentle Introduction to Haskell, and it was painful.
18:16:19 <stolaruk> haha
18:16:22 <shapr> stolaruk: so I started an IRC about Haskell to get people to teach me Haskell :-)
18:16:37 <shapr> er "irc channel"
18:16:42 <mm_freak> shapr: using hulk hopefully =P
18:16:44 <mm_freak> ah =P
18:16:46 <stolaruk> shapr: Do you know any functional programming now
18:16:50 <shapr> stolaruk: it's been pretty successful so far
18:16:53 <shapr> stolaruk: Yeah, I do know some
18:17:02 <stolaruk> shapr: What languages?
18:17:10 <shapr> well, I actually do know Haskell :-)
18:17:16 <shapr> and I started #haskell
18:17:27 <quchen> #haskell: shapr's seal of quality
18:17:33 <shapr> but I haven't been active much lately, so I figured I'd take the temperature of the community
18:17:35 <stolaruk> shapr: Oh you know Haskell already?
18:17:37 <aristid> stolaruk: you got trolled by our founder :)
18:17:40 <shapr> stolaruk: Yeah, somewhat :-)
18:17:45 <stolaruk> gosh
18:17:46 <shachaf> quchen: That would be depressing.
18:17:49 <shapr> aristid: it was a polite troll!
18:17:51 <Azertye> mm_freak, they all look quite good at first sight. Are they actually used a lot?
18:17:57 <aristid> shapr: sure :)
18:18:06 <quchen> shachaf: Oh grumpy you.
18:18:11 <mm_freak> Azertye: yes, all of them are used in practice
18:18:14 <shapr> stolaruk: That was very helpful and friendly, thanks :-)
18:18:23 <stolaruk> ok
18:18:26 <stolaruk> your welcome?
18:18:29 * shapr grin
18:18:30 <shapr> s
18:18:37 <shapr> bah, my typing is failing!
18:20:03 <mm_freak> Azertye: for example hackage is a happstack application and haskellers.com is a yesod application =)
18:20:26 <Azertye> mm_freak, nice
18:20:52 <dhrosa> that was really weird... my module imports Data.Colour from the colour package, I ran two functions in my ghci after loading my module, and it decides to load the colour module in-between the invocations, even though neither function depends on anything inside colour
18:21:06 <mm_freak> Azertye: and hub.darcs.net is a snap application
18:21:29 <mm_freak> just to provide examples of all three =)
18:21:41 <stolaruk> How well do those web app frameworks abstract away the core http? How much do you feel like you're writing a Haskell program as opposed to a web page?
18:21:59 <mm_freak> stolaruk: it feels like both actually
18:22:10 <mm_freak> stolaruk: none of them abstract away the stateless nature of HTTP
18:22:23 <mm_freak> i've written a library that would allow such abstractions, but it isn't used anywhere yet
18:22:27 <mm_freak> @hackage continue
18:22:27 <lambdabot> http://hackage.haskell.org/package/continue
18:22:32 <Azertye> Which one of them is the most basic?
18:22:41 <stolaruk> mm_freak: I learned some .NET framework (C#) some time ago and I didn't like it much.
18:23:04 <mm_freak> Azertye: you can get started with any of them very quickly
18:23:18 <mm_freak> all of them have nice and mostly comprehensive documentation
18:23:33 <mm_freak> stolaruk: yes, web sucks
18:23:54 <mm_freak> (for programmers)
18:24:09 <stolaruk> mm_freak: HTTP feels like a protocol that was not designed for the way it's used now. There are a handful of technologies piled on top of HTTP to try to coerce it into something that it's not
18:24:26 <stolaruk> mm_freak: That's mainly why I don't like it. :)
18:24:59 <mm_freak> stolaruk: sure, but you won't see a useful replacement any time soon ;)
18:25:10 <aristid> well there's spdy and http2 ;)
18:25:12 <dagano> i have two functions ... strToLInts :: String -> [Int]    and fromList :: (Ord a) => [a] -> Tree a   ... and what is wrong with the following binds?  main = getLine >>= (\ls -> strToLInts ls) >>= (\ls -> fromList ls)
18:25:13 <stolaruk> mm_freak: Exactly. It's here to stay. :(
18:25:18 <aristid> but i suppose those don't fix the things you don't like
18:25:19 <mm_freak> also HTTP is in fact useful for most of the web
18:25:30 <mm_freak> but some applications would work better with a different protocol
18:25:39 <mm_freak> mostly highly interactive and reactive stuff
18:25:48 <aristid> well there's websockets i suppose
18:25:58 <stolaruk> dagano: The result of the expression to the right of the first bind isn't in a monad is it?
18:26:00 <mm_freak> aristid: websockets don't solve all problems
18:26:07 <dagano> main = getLine >>= (\ls -> print $ strToLInts ls) works ... do i need to bind the fromList with the first lambda or should i just use regular function composition
18:26:14 <Azertye> As browsers get faster more stuff is done at the client level which makes it worse too
18:26:30 <Azertye> if you don't like JS and co
18:26:32 <aristid> mm_freak: they do give you a pretty raw tcp-socket-like thing though, so you can build a lot of things on top if http semantics don't work out
18:26:34 <lightquake> if I want to get, say, the size of a function on disk, what package do I want to look at?
18:26:41 <lightquake> hoogling 'stat' isn't helpful
18:26:53 <mm_freak> aristid: and then you hit C-r and everything is gone
18:26:58 <dagano> stolaruk:  no it's not ... i'm thinking i can just use fcn composition and i am confusing things
18:26:59 <stolaruk> dagano: That's why the second bind won't work
18:27:07 <mm_freak> websockets are a tool, not a solution
18:27:27 <stolaruk> dagano: Yeah try composing the functions instead of using the second bind
18:27:39 <stolaruk> dagano: The first bind is good to go tho
18:27:52 <dagano> :t getLine
18:27:53 <lambdabot> IO String
18:28:22 <mm_freak> anyway, haskell can work around the awkwardness of HTTP…  the abstractions are there
18:28:37 <stolaruk> mm_freak: That's good news.
18:28:48 <mm_freak> we have monoids, we have reform/digestive-functors, we have acid-state, we have continue, we have FRP, …
18:29:01 <mm_freak> it's just that more people should understand and use them =)
18:29:05 <shachaf> i love monoids
18:29:08 <shachaf> they are so easy
18:29:18 <aristid> shachaf: i guess you grew untired of that
18:29:32 <quchen> Funniness of it goes like tan(time)
18:30:31 <stolaruk> So I'm writing what is essentially a Telnet server. Presently I'm using Text for my string type, but I'm wondering if I should use ByteString since, AFAIK, Telnet is only concerned with ASCII
18:30:33 <Fuuzetsu> I can just imagine shachaf sitting down and taking it easy with monoids
18:30:41 <aristid> mm_freak: i think actually as protocols go, http is probably not that bad, its statelessness does make some things easier
18:30:59 <stoof> +++++++++++
18:31:02 <mm_freak> stolaruk: if it's text, i'd use Text anyway
18:31:20 <mm_freak> aristid: agreed, that was my point above
18:31:22 <lightquake> yeah, i'd only use ByteString when you know it's *not* going to be text
18:31:26 <stolaruk> mm_freak: You think so? Why?
18:31:36 <mm_freak> for 99% of the web HTTP is appropriate
18:31:38 <stolaruk> lightquake: Meaning binary?
18:31:50 <lightquake> yes
18:31:55 <aristid> lightquake: i'd use bytestring for ascii but then maybe i'm rotten by doing too much c++ :)
18:32:02 <lightquake> aristid: you are :P
18:32:36 <stolaruk> I don't particularly feel like refactoring all my Text into ByteString anyhow
18:32:59 <mm_freak> the remaining 1% consists of social media, CRUDs and graphics/video stuff
18:33:20 <mm_freak> for which HTTP is awkward
18:39:43 <speckle> Hmm, it's odd how they decided to put the rather complicated integer square function on the wiki, but not the standard library
18:39:52 <speckle> err, square root function
18:40:20 <mm_freak> speckle: check out arithmoi for integer square roots
18:40:27 <speckle> ah, thanks, mm_freak
18:42:33 * hackagebot presburger 1.1 - A decision procedure for quantifier-free linear arithmetic.  http://hackage.haskell.org/package/presburger-1.1 (IavorDiatchki)
18:43:15 <speckle> I'm doing Project Euler so this arithmoi library might be cheating, heh. Maybe I should have just implemented my own integer square root
18:43:26 <binroot> @pl \x -> isAlpha x || isSpace x
18:43:26 <lambdabot> liftM2 (||) isAlpha isSpace
18:55:37 <tommo_> hey all!
18:56:57 <ittel> hey =)
18:57:13 <tommo_> I was going around trying to learn haskell, and I come from a game programming background
18:57:23 <tommo_> everything is pretty nice so far
18:57:36 <tommo_> however, I was wondering how time fits into the language model
18:58:07 <tommo_> that is, I do not want to have a huge, static, one-time-IO reply
18:58:20 <tommo_> I actually want to have a loop that affects a running state of a world
18:58:50 <tommo_> I can't wrap my head on how to do that without essentially writing a huge C-style monad
18:59:02 <tommo_> *action
18:59:18 <tommo_>  /rant :D
18:59:50 <Earnestly> tommo_: http://pbrisbin.com/posts/the_advent_of_io/
19:00:22 <pdxleif> You can do that fine in Haskell.  You want to write a network server, or just continually run the same IO program over and over?
19:01:02 <pdxleif> There's "forever" in Control.Monad - http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#v:forever
19:01:03 <tommo_> I want more or less to write a game
19:01:20 <pdxleif> The equivalent of "while (true)". Just implemented in terms of recursion.
19:01:20 <mm_freak> tommo_: then FRP will interest you
19:01:29 <tommo_> uhm
19:01:30 <mm_freak> tommo_: Functional Reactive Programming
19:01:32 <tommo_> so much info :D
19:01:49 <Earnestly> (What did you expect?)
19:02:12 <tommo_> (this, I guess!)
19:02:20 <mm_freak> tommo_: but before learning FRP you should have some haskell experience =)
19:02:49 <pdxleif> There's also FRP in other langs, like Elm.
19:03:01 <tommo_> FRP seems cool
19:03:07 <Earnestly> Also, massive main loops like most games, might not be the best way
19:03:10 <pdxleif> Here's a lil game in Idris. Just does some initialization, then fires up an event loop: https://github.com/edwinb/SDL-idris/blob/master/invaders/Main.idr#L36
19:03:11 <tommo_> I read "event driven" which I like
19:03:29 <tommo_> well, I usually write game in a state-machine-plus-message-passing way
19:03:40 <tommo_> which might or might not imply a main loop
19:03:56 <tommo_> but I was starting with the basics :D
19:04:00 <Earnestly> There was an example for a game world in clojure, iirc
19:04:28 <tommo_> FRP is not supported in haskell though?
19:06:58 <Earnestly> tommo_: http://www.chris-granger.com/2012/12/11/anatomy-of-a-knockout/ (might be interesting)
19:11:28 <pdxleif> Elm has some nice demos you can try online, e.g http://elm-lang.org/edit/examples/Reactive/Position.elm
19:11:59 <carter> lispy: i do not enjoy debugging weird linker shit
19:12:01 <carter> bah
19:12:03 <carter> blah
19:13:12 <mm_freak> tommo_: well, "event-driven" is a broad term…  FRP is also "event-driven" in a sense
19:13:32 <mm_freak> but you don't get traditional event handlers and state updates
19:13:48 <mm_freak> instead you get a completely declarative approach with first class events and time-varying values
19:13:48 <tommo_> yeah, of course
19:14:01 <tommo_> seems very interesting though
19:14:09 <mm_freak> also i'd like to point out that Elm is not FRP
19:14:26 <mm_freak> it's something similar
19:14:27 <tommo_> it isn't? the wiki page more or less says it is!
19:14:56 <mm_freak> yes, but it isn't…  it doesn't follow the continuous time model and has no separation between events and time-varying values (aka behaviors)
19:15:34 <Earnestly> <http://haskell.cs.yale.edu/publications/#FunctionalReactiveProgramming>
19:15:34 <tommo_> uhm, ok
19:15:39 <tommo_> still trying to make sense of stuff
19:15:54 <tommo_> the "anatomy of a knockout" one is interesting
19:16:19 <tommo_> however, I see how he defines the game structure, and that's indeed much better than C++
19:16:25 <mm_freak> the two most popular FRP libraries in haskell are netwire and reactive-banana
19:17:01 <YellPika> Does anyone know if it's possible to have Haskell defer type checking splices to _after_ each splice is transformed (when using Template Haskell)?
19:17:02 <tommo_> that's a nice name :D
19:17:08 <mm_freak> and i happen to be the author of netwire =)
19:17:32 <tommo_> but well, then, I have a last missing piece here
19:17:47 <tommo_> say I have no constraint over how many entities I have of a given type
19:18:07 <YellPika> mm_freak: You made netwire? (Bows down in gratitude)
19:18:11 <tommo_> how do I add a new one at runtime without basically making a copy of all of them?
19:18:35 <mm_freak> YellPika: yeah, and thanks =)
19:18:44 <tommo_> in that example he avoids this by having a single player, and that works well
19:18:58 <mm_freak> tommo_: you would use a suitable functional data structure like a Map or a Set
19:19:18 <mm_freak> in FRP you would use a multicasting switch
19:19:32 <mm_freak> which uses such a data structure under the hood
19:19:38 <enthropy> YellPika: use ghc-7.8 when it comes out... for now you have to make up the AST with the functions like appE if the [| f x |] rejects it
19:20:00 <tommo_> but, wouldn't this Map need to be copied and destructive-assigned back after the entity is added?
19:20:08 <mm_freak> tommo_: no
19:20:18 <tommo_> then I do miss some details here :D
19:20:23 <mm_freak> you're missing sharing =)
19:20:29 <YellPika> enthropy: Thanks. Is this currently in HEAD?
19:20:36 <mm_freak> since haskell data structures are immutable, their structure is shared
19:20:54 <joelteon> if I have a matrix of type [[a]], how should I transform it to [((Int,Int),a)]
19:20:58 <joelteon> i.e. the coordinates
19:21:12 <startling> joelteon, nested foldr, probably
19:21:26 <mm_freak> tommo_: in other words, when you make a new Map with a changed element, it will share most of its structure with the map it was built from
19:21:31 <enthropy> YellPika: yes it should be... the [|| typed quotes ||] are in already
19:21:36 <tommo_> ohm ok
19:21:41 <tommo_> *uhm
19:21:56 <tommo_> but conceptually, it is indeed a new different map
19:21:56 <startling> joelteon: hmm, you can probaly do something clever with zip.
19:22:05 <tommo_> which might even be a good thing
19:22:05 <mm_freak> tommo_: yes, denotationally it is a new map
19:22:07 <joelteon> yeah, something with zip
19:22:12 <joelteon> or something monadic!
19:22:14 <joelteon> liftM2 (,) ...
19:22:32 <startling> joelteon: you'd want ZipList, not [].
19:22:40 <joelteon> yeah
19:22:47 <joelteon> but I'm taking user input
19:22:49 <joelteon> a list of getLines
19:22:52 <tommo_> honestly though I can't see this end well with stuff that makes use of megabytes of state like a physics engine, though :P
19:23:03 <tommo_> I need to experiment a bit more
19:23:05 <mm_freak> tommo_: more precisely constructing the new map will need O(log n) space…  then, when the old map is GCed away, the extra path nodes are removed from memory…  this is a cheap process
19:23:18 <enthropy> @type concat . zip [1 .. ] . map (zip [1 .. ])
19:23:18 <lambdabot>     Couldn't match type `(a1, [(a2, b0)])' with `[a0]'
19:23:19 <lambdabot>     Expected type: [[(a2, b0)]] -> [[a0]]
19:23:19 <lambdabot>       Actual type: [[(a2, b0)]] -> [(a1, [(a2, b0)])]
19:23:46 <mm_freak> tommo_: don't worry too much…  i had Maps with tens of millions of elements in haskell =)
19:23:57 <enthropy> @type concat . zipWith (\i xs -> map (i,) xs)  [1 .. ] . map (zip [1 .. ])
19:23:58 <lambdabot> (Enum t, Enum a, Num t, Num a) => [[b]] -> [(t, (a, b))]
19:23:59 <tommo_> mm_freak: I see, nodes being immutable it is pretty easy to share them between maps
19:24:16 <startling> :t map (\(n, ns) -> zip [(n,0), (n,1),..] ns) . zip [1,2..]
19:24:17 <lambdabot> parse error on input `..'
19:24:46 <enthropy> > succ (42, 3)
19:24:48 <lambdabot>  No instance for (GHC.Show.Show t1)
19:24:48 <lambdabot>    arising from a use of `M21920620713109661431260.show_M21920620713109661431...
19:24:48 <lambdabot>  The type variable `t1' is ambiguous
19:24:48 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
19:24:48 <lambdabot>  Note: there are several potential instances:
19:24:54 <mm_freak> tommo_: also you may well find that a map is actually faster than an array, because almost every map operation is reasonably cheap, while for arrays some operations are horribly expensive
19:25:05 <startling> > [(0,1),(0,2)..]
19:25:06 <dhrosa> :t map (\(n, ns) -> zip [(n,0), (n,1),..] ns) . zip [1,2..]
19:25:06 <lambdabot>  No instance for (GHC.Show.Show t1)
19:25:07 <lambdabot>    arising from a use of `M167818855283213677131269.show_M1678188552832136771...
19:25:07 <lambdabot>  The type variable `t1' is ambiguous
19:25:07 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
19:25:07 <lambdabot>  Note: there are several potential instances:
19:25:08 <dhrosa> oops
19:25:09 <lambdabot> parse error on input `..'
19:25:11 <dhrosa> :t map (\(n, ns) -> zip [(n,0), (n,1)..] ns) . zip [1,2..]
19:25:11 <lambdabot> (Enum (t, t1), Enum t, Num t1, Num t) => [[b]] -> [[((t, t1), b)]]
19:25:15 <enthropy> startling: I think there's stuff in the Ix class for that
19:25:22 <dhrosa> removed a comma
19:25:43 <tommo_> mm_freak: cool :)
19:25:55 <tommo_> I'm also looking at netwire, seems interesting
19:26:12 <tommo_> I'm too much of a beginner right now to make sense of most of it though
19:26:13 <mm_freak> ocharles has written a little toy game using netwire and blogged about it
19:26:25 <mm_freak> you may find it interesting
19:26:44 <mm_freak> tommo_: http://ocharles.org.uk/blog/posts/2013-08-18-asteroids-in-netwire.html
19:26:49 <enthropy> dhrosa: there's no enum instance (by default) for tuples though
19:27:10 <dhrosa> i was just fixing the syntax error in the other dude's code
19:27:17 <dhrosa> no idea what he's trying to do
19:27:45 <startling> oh, I thought there was.
19:27:47 <startling> that's silly.
19:28:08 <startling> I guess succ would need to be able to fail.
19:28:34 <tommo_> mm_freak: interesting
19:28:36 <levi> tommo_: Don't worry, it starts making sense eventually.  Most of it, anyway.
19:28:56 <tommo_> yeah, eventually!
19:29:21 <tommo_> I was already using a somewhat functional style anyway, for what C++ allows
19:30:00 <levi> Moving from 'somewhat functional' to 'purely functional' is a pretty big step, though.
19:30:27 <speckle> I've used Racket before, but Haskell is more difficult for some reason.
19:30:29 <tommo_> let's call it "somewhat-pure-callback-based" :P
19:30:55 <tommo_> so yeah it's a big step indeed
19:31:01 <speckle> (Racket is basically Scheme, which is basically Lisp)
19:31:13 <levi> You can write Haskell the way you write Scheme, but it's not the way most people write Haskell.
19:32:17 <levi> Haskell has a lot more generally useful abstractions; you almost never need to write explicitly recursive functions.
19:32:32 <speckle> Well, Scheme is a little more forgiving with types, if I recall correctly.  It's been a while, though.
19:32:43 <mm_freak> netwire in general (when you import Control.Wire) is an abstraction for locally stateful components that you can combine in various ways
19:32:45 <levi> Well, it's forgiving at 'compile' time anyway.
19:32:57 <mm_freak> when you import FRP.Netwire, you get a proper FRP subset of it
19:33:17 <mm_freak> FRP, too, is about locally stateful components
19:33:32 <mm_freak> because "function of time" can be interpreted as "locally stateful"
19:33:37 <levi> But if you don't use a 'structure' library or a lot of discipline in carefully building your data abstractions, it's easy to screw up just how many d's and a's to use for your cadddddr. ;)
19:34:15 <speckle> Yeah, those parentheses were always very confusing visually, though I'm guessing it would have been tolerable if I bothered to use an editor that highlighted them in alternating colors
19:34:35 <startling> rainbow-parens are so nice.
19:34:37 <tommo_> mm_freak: is there something to read about that locally stateful thing?
19:34:46 <tommo_> seems the core of what I was wondering
19:34:59 <tommo_> like, how do you model a state machine
19:35:07 <levi> I don't mean the parentheses... those are easy to handle with an editor that's designed for the task. I mean the fact that you have to build your data structures manually out of cons pairs.
19:35:11 <speckle> ah
19:35:25 <Guest69439> hi guys, quick question: does there exist an adequately-maintained discrete exterior calculus/differential geometry library at the present time? In other words, what does ekmett have on the docket for the next 6 months or so?
19:35:31 <mm_freak> tommo_: there are many ways to model them…
19:35:43 <mm_freak> tommo_: data Stream a = Cons a (Stream a)  -- do you understand this type?
19:35:52 <speckle> also, infixes are more readable for me, to the point where I miss using % for modulus (as opposed to `mod`)
19:35:57 <edwardk> Guest69439: not yet. i actually tried one, but couldn't get a nice enough EDSL for it
19:36:09 <speckle> most other languages use % for modulus AFAIK
19:36:10 <edwardk> Guest69439: you may want to read functional differential geometry by sussman
19:36:31 <levi> And it's pretty easy to screw up your data structures if you don't use a lot of discipline in writing them. This entire class of runtime errors is caught at compile time when you use Haskell's algebraic data types and static type checking.
19:36:37 <edwardk> Guest69439: and the structure and interpretation of classical mechanics, the dsl he builds up in scheme is pretty solid
19:36:49 <Guest69439> edwardk: will do. I started reading FDG over the summer, implemented his version of up/down arrays, and kind of gave up...
19:36:57 <tommo_> mm_freak: a stream made by concatenating a stream on another one?
19:36:57 <speckle> the other distracting thing is that I'm about as excited about Rust as I am about Haskell, so I'm trying to learn both at once
19:37:05 <edwardk> it just isn't as pretty in haskell =/
19:37:11 <levi> It's not *hard* to write nice data structures in Scheme, but there's a lot of boilerplate involved and it takes some discipline to do it well.
19:37:16 <Guest69439> edwardk: you can say that again :-/
19:37:21 <mm_freak> tommo_: data List a = Nil | Cons a (List a)  -- do you understand this one?
19:37:58 <tommo_> mm_freak: I guess I could give a stab in the dark but probably I need to fiddle a bit with data types :D
19:38:01 <Guest69439> edwardk: do you know any good (preferably functional) data structures for representing meshes/discrete manifolds/simplicial complexes (complices?)?
19:38:22 <mm_freak> tommo_: ok, your first task is to work through LYAH =)
19:38:25 <mm_freak> @where lyah
19:38:26 <lambdabot> http://www.learnyouahaskell.com/
19:38:31 <edwardk> nothing especially elegant
19:38:45 <derdon_> http://imgur.com/EWwpdM6
19:38:45 <mm_freak> tommo_: after understanding the basics i'm happy to explain state machines to you =)
19:38:55 <mm_freak> tommo_: and their relationship with FRP
19:39:00 <tommo_> well, sure
19:39:05 <Guest69439> edwardk: wellp, guess it's up to us then. Will read up on the literature ... tomorrow...
19:39:08 <Guest69439> good night all
19:39:31 <tommo_> thanks for the info anyway, I was pretty sure it had to be something somewhat obvious :P
19:40:05 <mm_freak> it is something somewhat obvious, but it's better to explain with actual code in haskell =)
19:40:23 <levi> tommo_: Haskell's data types are very nice, you'll have fun fiddling with them!
19:40:26 <jfischoff> edwardk: what's your take on having a reflection-extras package that has the constraint machinery and a bunch of instances?
19:40:43 <tommo_> levi: let's see :D
19:41:07 <edwardk> jfischoff: i'd be game to either start the repo and take contributions to it, or just say 'go for it' your call.
19:41:22 <jfischoff> edwardk: half way done ;)
19:41:30 <tommo_> but yeah, maybe not at 4:30 in the morning
19:41:31 <edwardk> then 'go for it' ;)
19:41:46 <tommo_> even though that is the best time, in a way
19:41:57 <mm_freak> tommo_: come on, it's 4:38 here as well =P
19:42:30 <tommo_> lol
19:42:43 <tommo_> well, I'm not saying I have a problem with that
19:42:55 <tommo_> it's society that will wake me up tomorrow that does
19:43:50 <tommo_> so well, bye!
19:44:04 <mm_freak> hmm…  tomorrow is more than 19 hours away…
19:44:22 <tommo_> and thanks!
19:45:36 <binroot> @pl (\x -> (head x, length x))
19:45:36 <lambdabot> liftM2 (,) head length
19:49:14 <xpika> i want to inspect the intermediate types for haskell package GHC but they derive their own show instances. Is there a ghc extension for implicitly deriving Data instances so that i can use gshow?
19:49:44 <startling> xpika, you can use StandaloneDeriving if you can import the type.
19:54:49 <binroot> How can I simplify this using Arrows?  \x -> isSpace x || isAlpha x
19:55:08 <binroot> or anything, i just want to simplify it
19:55:57 <geekosaur> why bother?
19:56:00 <startling> :t (||) <$> isSpace <*> isAlpha
19:56:01 <lambdabot> Char -> Bool
19:56:14 <startling> :t liftM2 (||) isSpace isAlpha
19:56:14 <lambdabot> Char -> Bool
19:58:08 <enthropy> @ty \x -> any ($ x) [isSpace, isAlpha]
19:58:08 <lambdabot> Char -> Bool
19:58:56 <binroot> hmm thanks
19:59:05 <mgsloan> @ty flip any [isSpace, isAlpha] . (&)
19:59:06 <lambdabot> Char -> Bool
19:59:07 <mgsloan> ;)
19:59:13 <mgsloan> (not actually recommending that)
19:59:33 <binroot> lol
19:59:46 <mgsloan> I'd actually go with what you started with, binroot - it expresses the meaning you're after - so why make it "simpler"
20:00:57 <mgsloan> It can be easy to go a little nuts with eliminating named variables in haskell, but this is not always a good idea
20:01:09 <binroot> mgsloan, geekosaur: you're right
20:01:43 <startling> binroot, you probably shouldn't use what I said unless you understand applicative style and the reader monad.
20:04:50 <mm_freak> :t let (<||>) = liftA2 (||) in isSpace <||> isAlpha
20:04:51 <lambdabot> Char -> Bool
20:05:25 <startling> :t let (<||>) = liftA2 (||) in isSpace <||> isAlpha <||> isAlpha
20:05:26 <lambdabot> Char -> Bool
20:08:25 <enthropy> is there an implementation of this http://wiki.portal.chalmers.se/cse/pmwiki.php/FP/TestingPolymorphicProperties somewhere?
20:09:27 <speckle> Hmm, I put down LYAH and starting implementing stuff... and I am ending up with tons of guards and tons of parameters to manage state, all in one giant function to be pasted into GHCI.  Is this normal for Haskell?
20:09:43 <mm_freak> speckle: no
20:09:59 <enthropy> depends how much "tons" is
20:10:38 <speckle> Right now only 4 parameters and 3 guards, but it keeps growing and growing
20:11:07 <mm_freak> speckle: what are you writing?
20:11:37 <speckle> Project Euler solvers :P I'm not looking for answers, just for general comments on style
20:12:01 <mm_freak> speckle: don't worry, you will learn about the various abstractions =)
20:12:09 <speckle> okay, thanks
20:12:11 <startling> speckle, 1) typically you do not just paste thngs into ghci, you write them in a file and :l it, and b) Haskell has some niceties for dealing with state and repeated parameters
20:13:00 <speckle> I feel like I'm using parameters as a substitute for private variables and guards as a substitute for branching, basically writing imperative code in a bizarre syntax
20:13:13 <speckle> as a substitute for local variables rather
20:13:29 <mm_freak> speckle: it's not normal for haskell, but totally normal for a haskell beginner =)
20:13:52 <startling> speckle: if you could paste code we could probably give some more style advice
20:13:58 <startling> but yeah, I wouldn't worry too much.
20:14:02 <mm_freak> @lpaste
20:14:02 <lambdabot> Haskell pastebin: http://lpaste.net/
20:14:47 <speckle> thanks! :)
20:14:54 <speckle> Hmm, not sure I want to paste Project Euler code though....
20:15:24 <startling> why's that?
20:15:40 <mm_freak> speckle: make it a private paste, if you don't want it to be visible via search engines
20:16:39 <speckle> startling, they're programming puzzles and you're supposed to solve them yourself rather than looking up the answer. I'm using the easy ones as a way of learning Haskell
20:16:54 <startling> speckle, many people publish answers.
20:17:03 <speckle> so you're also not supposed to go around telling people the answer, because it's like a spoiler.. oh
20:17:39 <mm_freak> speckle: i have to say PE problems are interesting to get going with basic laziness, basic types and syntax
20:17:56 <mm_freak> but after solving a bunch of them you should move on to more interesting stuff
20:18:10 <startling> they tend to be too nice of problems to learn Haskell with, ime
20:18:17 <mm_freak> because PE solutions only expose a very small fraction of haskell's features
20:18:19 <startling> real-world problems are much messier
20:18:46 <speckle> I'm so bad that even they get messy for me! :)
20:18:51 <speckle> so for now I think they are fine
20:18:54 <startling> heh.
20:19:08 <mm_freak> speckle: sure, as said, nothing wrong with solving a bunch of them =)
20:20:08 <speckle> what do you consider interesting stuff? GUIs?
20:20:24 <mm_freak> that's a matter of taste
20:20:38 <mm_freak> personally i like network stuff and high performance stuff
20:21:18 <mm_freak> you might begin by writing a little echo server to learn some concurrency basics
20:23:04 <speckle> oh
20:28:46 <jerrrryy> can one freely pass haskell closures to C functions or are there any pitfalls one should be aware of?  for example, could garbage collector collect the captured variables, or move them, before C code is done calling the callback?
20:30:25 <shachaf> That depends on how you pass them.
20:31:06 <Cale> jerrrryy: Not if you do it sensibly
20:31:48 <Cale> jerrrryy: Haskell doesn't actually have a notion of closures. Various types of closures are used as implementation details of GHC
20:32:49 <sevak> hi guys, I was told that another way to express the following is to use concatMap and I'm struggling a bit to see how; any hints would be appreciated, thanks http://lpaste.net/4091314055791247360
20:33:23 <jerrrryy> I wasn't aware there's more than one way to do it.. I have used wrap to wrap the haskell callback
20:33:41 <Cale> But if you take a function and apply a wrapper to it, you'll be fine, regardless of the internal implementation of that function
20:33:44 <jerrrryy> Cale it doesn't? then what are functions that close over the variables in scope?
20:33:50 <Cale> Functions
20:34:01 <jerrrryy> closures are functions too
20:34:17 <Cale> There's no distinction in Haskell between a function which does or doesn't capture the values of variables which are free in its body
20:34:25 <jerrrryy> I see
20:34:42 <ion> sevak: Uh, i’m not sure concatMap makes sense for that.
20:35:46 <Cale> Closure is a horrible term to use in place of function here as well, because a closure is actually defined as a pair, consisting of some representation of code, together with an environment mapping free variables of that code to values on the other.
20:36:07 <nisstyre> jerrrryy: you can write things like let f x = \y -> x + y but it's no different from writing f x y = x + y
20:36:20 <Cale> If you can't split that pair apart and inspect the two halves anymore, you don't really have a closure, you're using a closure to implement something else.
20:36:22 <nisstyre> therefore saying something is or isn't a closure in Haskell is kind of meaningless
20:36:53 <shachaf> Functions in Haskell are less special than functions in other languages.
20:37:00 <jerrrryy> closure = a function that closes over variables in scope. that's the common use of the word in other programming languages. not sure if it's any different in haskell
20:37:11 <shachaf> Probably a lot of the time when you say "function" you could say "value" instead.
20:37:13 <Cale> (and indeed, if given a Haskell function, you cannot split it apart to figure out what was in its environment, and replace those values for instance)
20:37:29 <Cale> jerrrryy: That's a popular confusion
20:37:40 <Cale> jerrrryy: It's confusing a language feature with an implementation detail
20:38:02 <jerrrryy> how do you call a function that closes over variables?
20:38:05 <Cale> A function.
20:38:22 <sevak> ion: hmm, ya I don't see it either, just want to solve it different ways if possible to get the most out of the exercise
20:38:44 <jerrrryy> so there's no name that makes it dinstinct from a function that doesn't close over variables?
20:38:54 <ion> sevak: You might find divMod useful.
20:38:55 <Cale> Well, those are silly
20:39:36 <Cale> :)
20:39:58 <Cale> If a variable occurs free in the body of a function, what else is it supposed to represent, but its value?
20:40:06 <ion> Ministry of Silly Functions
20:40:17 <Cale> I suppose you could be a dynamic scope person
20:40:26 <shachaf> There's sometimes a special name for a function that doesn't have an environment.
20:40:29 <Cale> But dynamic scope is widely considered to be a horrible mistake
20:40:38 <shachaf> ski calls it -># or some English name I don't remember.
20:41:10 <Cale> and yeah, I guess you could come up with some name for functions having no free variables in their body at all
20:41:13 <nisstyre> Cale: not necessarily
20:41:13 <stolaruk> jerrrryy: I find I don't ever think about closures when I code Haskell, I just write functions
20:41:23 <shachaf> And has the whole a -> b = exists e. (# e, (# e, a #) -># b #) thing
20:41:37 <nisstyre> Cale: have you read up on syntax parameters, or just parameters?
20:41:46 <nisstyre> they're sort of like a controlled version of dynamic scope
20:41:52 <jerrrryy> Cale closure could have possibly implications that function doesn't, ie, it has to extend the life of the local variables. so I used the commonly used word to describe it. you seem to oppose the use of that word, without offering any other to replace it
20:42:00 <jerrrryy> possible*
20:42:31 <Cale> jerrrryy: Well, if you want to be clear, then you can be clear about how the language feature behaves without saying what the implementation ought to be
20:42:54 <Cale> e.g. Functions that capture the values of free variables occurring in their body at their point of definition
20:43:03 <Cale> But normal people just call those functions
20:43:13 <zomg> I have to agree with stolaruk, I don't find I have to think about closures in Haskell
20:43:28 <zomg> Versus say, JavaScript, where closures can cause a variety of completely unexpected behavior
20:43:40 <jerrrryy> Cale you are getting pretty nasty over what's a semantical  pedantry at best
20:43:56 <Cale> jerrrryy: I'm quite aware that I'm being somewhat pedantic here
20:44:17 <Cale> But I think it's good to keep a sharp line between what is part of the language and what is part of the implementation.
20:44:27 <Cale> There are other ways to implement Haskell functions.
20:44:42 <Cale> and indeed, in my head, I usually *don't* think of an implementation which uses closures
20:45:17 <Cale> (Instead, I tend to picture the graph reduction model of Haskell, where evaluation is just transforming graphs)
20:45:18 <joelteon> Why is 99.9% of my profiling time spent just in MAIN
20:45:21 <binroot> @pl \f x -> map f $ f x
20:45:21 <lambdabot> (.) =<< map
20:45:22 <joelteon> do I need to insert cost centers myself?
20:45:40 <Cale> joelteon: Perhaps, or add more flags which insert them automatically.
20:45:49 <binroot> @pl \f x -> map f $ map f $ f x
20:45:49 <lambdabot> liftM2 (.) map ((.) =<< map)
20:45:57 <binroot> @pl \f x -> map f $ map f $ map f $ f x
20:45:57 <lambdabot> liftM2 (.) map (liftM2 (.) map ((.) =<< map))
20:46:03 <sevak> ion: ya, I'll try to use divMod, at first glance looks like one way would be to use fst and snd, but I wonder if I can call it once
20:47:21 <stolaruk> joelteon: Yeah try the flag that puts them everywhere, automatically. "-caf-all"
20:47:22 <Clint> sevak: let (d, m) = 5 `divMod` 3
20:47:27 <Cale> jerrrryy: If the free variables in the body of a function are just represented by arcs in a graph which point at their values, that's good enough too :)
20:47:45 <stolaruk> joelteon: Or is it "-auto-all" ?
20:47:50 <Cale> jerrrryy: and you don't need the extra notion of a closure pairing some abstracted version of the function with its environment
20:48:07 <stolaruk> joelteon: I profile w/ both of those flags, anyhow
20:48:29 <Cale> Or of course, we could implement functions using direct substitution.
20:48:32 <joelteon> okay, well, one of my cost centers is listed as "search.\"
20:48:35 <joelteon> I have a function called search
20:48:38 <joelteon> but there's no (\) inside it
20:48:45 <jerrrryy> Cale maybe it wasn't clear, but I am not interested in this hair splitting
20:48:58 <stolaruk> joelteon: I've seen that before but I don't know what it means :(
20:49:15 <Cale> So, rather than pairing the code with an environment, splice the values of the things which would be in the environment into the function's code directly.
20:49:36 <Cale> Well, usually I'm not interested in these details either, which is why I'm a proponent of just saying function when we mean function :)
20:49:53 <sevak> Clint: cool, thanks
20:50:01 <Cale> and not dredging up irrelevant implementation mechanisms to refer to the higher level things we're using them to implement
20:50:10 <sevak> ion: thanks man
20:50:24 <joelteon> GHC doesn't tell me what \ is
20:50:46 <Cale> (I also am opposed to mentioning thunks in the presence of beginners for that reason, and prefer to speak of expressions at runtime)
20:51:15 <nisstyre> Cale: what about continuations?
20:51:22 <Cale> What about them?
20:51:40 <nisstyre> you can describe things in terms of continuations, sort of, can't you?
20:51:45 <nisstyre> would that confuse new people?
20:51:51 <Cale> Probably! :)
20:52:10 <Cale> Continuations confuse seasoned experts often enough as it is :)
20:52:11 <nisstyre> fair enough
20:52:42 <nisstyre> Cale: I didn't understand them at all until reading this http://www.cs.indiana.edu/hyplan/dfried/ts.ps
20:52:46 <nisstyre> now I know that I barely understand them
20:52:55 <Cale> But yeah, a translation to continuation passing style is one way of talking about evaluation order
20:53:00 <nisstyre> or at least I barely understand the potential uses for them
20:53:01 <Cale> It's not my favourite way
20:53:37 <Cale> I prefer to just talk about reducible subexpressions -- i.e. places where a reduction rule applies to a subexpression of the expression we're trying to evaluate.
20:54:00 <Cale> and then picking some order in which to choose one
20:54:28 <nisstyre> yeah, that is definitely simpler to explain
20:57:08 <joelteon> man
20:57:26 <joelteon> I hate when I write code using Text and Array which is slower than doing the same thing using String and [[a]]
20:57:28 <joelteon> because I'm stupid ):
20:57:44 * hackagebot base-io-access 0.3.0.0 - The IO functions included in base delimited into small, composable classes  http://hackage.haskell.org/package/base-io-access-0.3.0.0 (bheklilr)
20:58:30 <lispy> ghc's optimizer has a way of surprising people
20:58:46 <lispy> and I suppose the haskell semantics take some blame here too
20:59:04 <augur> does anyone know if this should hold:   beta-or-id (eta M) == M
20:59:30 <augur> well, i say beta, what i mean, i guess, is,   eta M reduces to M
20:59:50 <Cale> joelteon: Yeah, in your defense, there are a lot of rules which may or may not apply, and so it can be trickier to figure out what'll be better than just trying both.
21:00:15 <augur> it seems like its what we want from a recursion principle. that is to say, folds really ought not to just ignore their arguments
21:00:33 <Cale> augur: I'm a little lost on what you're trying to express
21:00:45 <augur> eg, we could define   fold f r _ = r
21:00:53 <augur> that works, that has the right type, etc
21:00:59 <augur> but its an insane fold for lists
21:01:08 <Cale> Is "eta" expansion or contraction?
21:01:13 <augur> expansion
21:01:36 <Cale> So you're taking something like f, and turning it into an abstraction (\x -> f x)
21:01:40 <augur> oh but i guess for lambdas that wont be true, of course
21:01:52 <Cale> and then applying beta to that, which won't do anything because it's not an application
21:02:17 <augur> yeah
21:02:42 <augur> im just trying to figure out what some coherence conditions are on constructors and recursors
21:02:44 * hackagebot base-io-access 0.3.0.1 - The IO functions included in base delimited into small, composable classes  http://hackage.haskell.org/package/base-io-access-0.3.0.1 (bheklilr)
21:03:12 <augur> in terms of local soundness and completeness, the "silly" recursors always work
21:03:34 <Cale> Well, do you understand the initial F-algebra way of talking about folds?
21:03:39 <augur> rec :: Nat -> a -> (a -> a) -> a   defined as   rec _ z s = z
21:03:53 <Cale> I guess that's one way to go about it
21:04:15 <augur> is a perfectly valid recursor for nats, because you're not getting anything out by doing    rec n z s   that you didnt have before, at the type level
21:04:27 <augur> you get out an `a` and you already have an `a`: z
21:04:37 <augur> so as far as soundness is concerned, it's ok
21:04:38 <Cale> An important property of the fold is that if you apply it to the constructors, you get id.
21:05:08 <augur> and you can define an expansion as well, for harmony:   n :: Nat ~eta~> Zero :: Nat
21:05:28 <augur> which is just like the expansion for ():   u :: () ~eta~> () :: ()
21:05:33 <Cale> (but maybe I don't really understand what you're after)
21:05:42 <Cale> your rec doesn't pass that test
21:05:51 <Cale> rec n Z S isn't n
21:05:58 <augur> Cale: yeah, applying it to the identity doesnt act as the identity
21:06:20 <augur> but what does that mean type theoretically?
21:06:38 <Cale> hmm
21:06:46 <roconnor> I thought the eta expansion of the unit type was the trival object in the trivial category.
21:06:52 <augur> i think it means that the eta expansion has to reduce to something eta equivalent to where you started
21:07:12 <augur> so m ~eta~> m' ~reduce~> m'' ~eta^-1~> m
21:07:36 <augur> roconnor: expansions are syntactic, categories are semantic!
21:07:37 <Cale> I feel like I'm missing a big chunk of context surrounding whatever you're after :)
21:07:49 <augur> Cale: maybe!
21:08:00 <augur> let me upload the context into your brain
21:08:04 <augur> @where oplss2012
21:08:04 <lambdabot> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
21:08:09 <augur> pfenning
21:08:16 <augur> :P
21:08:41 <augur> (everyone in here interested in theoretical issues really ought to watch his lectures)
21:08:51 <Cale> okay, I'll have to do that
21:09:26 <Cale> Are you aware of how the recursion principle for Nat looks in a dependently typed language?
21:09:32 <gamegoblin> I am a newb when it comes to haskell IO and whatnot. Here is what I have: a parser that takes a string and outputs a Matrix type. A prettyPrint function that takes a matrix and outputs a string. And a file containing text corresponding to the string the parser wants. What would a `main` look like that reads the file, parses it, then pretty prints it?
21:09:46 <augur> Cale: yes, dependent types make it uniquely determined, i think
21:09:51 <augur> which is itself an interesting fact
21:10:25 <Cale> main = do
21:10:32 <Cale>   x <- readFile "myFile.in"
21:10:41 <Cale>   let m = parseMatrix x
21:10:49 <jerrrryy> how would one safely wrap/call a C function that modifies a global variable? in C it is has independent  value per thread, but what happens if I use it in haskell's threads?
21:10:51 <Cale>   putStrLn (prettyMatrix m)
21:10:56 <augur> Cale: but im more concerned about the general principle involved in the justification of a particular choice of intro-elim pairs
21:11:12 <gamegoblin> ahhhhh. It was the "let" that I was missing. Thanks. Need to learn proper do notation...
21:11:20 <roconnor> augur: ah right: for pairing there is 1 eta-expansion rule: p ~> (pi1 p, pi2 p) and 2 beta-reduction rules: pi1 (a,b) ~> a and pi2 (a,b) ~> b
21:11:39 <roconnor> augur: for unit there is 1 eta-expansion rule: u ~> () as you said
21:11:41 <augur> so just on the soundness and completeness requirements (definability of beta and eta), yo can perfectly well define   rec :: Nat -> a -> a ; rec _ x = x
21:11:47 <roconnor> augur: there is no beta-reduction rules
21:11:50 <augur> thats a sound and complete recursor for Nat, on harmony grounds
21:11:58 <Cale> gamegoblin: Yeah, you could do without let here just by stuffing that into the line with the putStrLn, but I figured I'd show how to do that :)
21:12:14 <augur> roconnor: right
21:12:30 <Cale> Okay, I don't know what those requirements are
21:12:34 <gamegoblin> Cale: Thanks a lot, good to know. I have written a 1000ish line machine learning lib without using any do notation except for the parser, which didn't need any lets.
21:12:45 <augur> roconnor: these of ours have semantic analogs, as they must (tho delightfully, there is one category in which the "denotations" just are syntactic objects :))
21:13:07 <augur> Cale: harmony basically just means "you must be able to define beta and eta for this type"
21:13:08 <Cale> But if you throw in a requirement that applying the fold to the data constructors of the type gives you the identity function, then I think it *might* be uniquely determined then.
21:13:26 <Cale> gamegoblin: cool
21:13:47 <augur> thats it. so if you choose your nat-rec to just be   rec :: Nat -> a -> a   then you can define a beta rule perfectly well: rec n z ~beta~> z
21:13:49 <Cale> gamegoblin: It's also worth noting that you can put multiple definitions into a single let, so long as you line them up
21:14:12 <Cale> gamegoblin: (i.e. the first non-whitespace character after 'let' sets the column that each definition needs to start in to be part of the block)
21:14:39 <gamegoblin> Cale: Aaaah that's neat. Thanks a lot. I got it to work.
21:14:54 <carter> lispy: could i pester you for some hacking wisdom?
21:15:37 <Cale> augur: Seems like pretty weak conditions then!
21:16:07 <Cale> oh, good, these lectures are on YouTube
21:16:15 <augur> Cale: indeed, hence why im curious if there are any logical principles that guide it
21:16:20 <recuchan> guys, I'm excited about type classes and want to skip the module section (I did skim over the last part about creating modules, though). Is this a good idea?
21:16:25 <augur> Cale: fwiw, the id principle works only for fold-like elims
21:16:28 <recuchan> i'm talking about lyah
21:16:36 <Cale> recuchan: You should be fine
21:16:50 <augur> Cale: they dont work for destructor-based elims
21:16:57 <Cale> recuchan: Modules and type classes are mostly orthogonal features
21:17:19 <Cale> augur: Could you give an example of one of those?
21:17:35 <recuchan> the bulk of it was just going over standard library functions, it seemed
21:17:55 <augur> Cale: well, in a lazy language everything is codata so we need to be strict
21:18:06 <Cale> destructNat z s Z = z; destructNat z s (S n) = s n ?
21:18:08 <Cale> Like that?
21:18:22 <augur> no no thats data nats
21:19:01 <augur> conats would only have some sort of destructor like   destruct :: Nat -> Maybe Nat
21:19:10 <augur> roughly speaking
21:19:15 <augur> i dont know quite what it would do for nats, tbh
21:19:25 <augur> co-pairs tho are defined by the existence of fst and snd as elims
21:19:37 <Cale> right, okay
21:19:42 <augur> there is no pattern matching/case for them
21:20:16 <augur> (even tho they're co-derivable, apparently their operational semantics differs: data is call-by-value, codata is call-by-name, or something)
21:20:18 <carter> ohhh. maybe libtool
21:20:34 <Cale> Well, I think the idea that you want it to correspond to an initial F-algebra (in the case of data) or a terminal F-coalgebra (in the case of codata) is one way to put it. There's probably an equational way to do codata too, I'd have to think about it.
21:20:35 <augur> Cale: but for pair types, there are two options for the elims, right
21:20:57 <augur> either:   pairElim1 :: Pair a b -> (a -> b -> c) -> c
21:21:14 <augur> or   fst :: Pair a b -> a   snd :: Pair a b -> b
21:21:27 <augur> both choices are valid choices, from a logical perspective
21:21:27 <Cale> Something like, if we apply the destructor, and then construct again, we get back where we started.
21:21:38 <joelteon> oh, I know what I did
21:21:43 <augur> Cale: right, thats what eta does :)
21:21:48 <joelteon> oh I was a genius when I wrote this program last time
21:22:18 <danilo2> Hello! I've just saw a very strange thing. I'm reifying a function using Template Haskell and then I'm generating an type class instance keeping the context reified from function. It worked for a lot of examples until ... in the context of reification of a sample function appeared "ConT GHC.Prim.*". But If I was trying to use it, I get an error
21:22:21 <augur> Cale: eta rules say if you elim, you can always use the results to get back where you started (type-wise)
21:22:27 <Cale> joelteon: That's a rare feeling to have.
21:22:30 <danilo2> Does anybody know what is happening here?
21:22:46 <joelteon> Yeah, it took me 35 minutes to figure out what the hell I did.
21:22:46 <Cale> joelteon: More often you get "Wow, I was an idiot when I wrote this" :)
21:22:54 <augur> Cale: but what i think is a good extension is that its not just type-wise: for any choice of values, if you eta expand it, then reduce, you get back where you started
21:22:59 <joelteon> I think my halcyon days are come and gone already.
21:23:00 <augur> modulo another eta
21:23:08 <joelteon> I've hit my peak as a programmer.
21:23:45 <augur> joelteon: its just a lack of coffee, obviously
21:23:49 <joelteon> damn
21:23:57 <joelteon> I miss you, 18 year old joeyh
21:23:59 <joelteon> joelteon
21:24:05 <joelteon> that'll be awkward if joeyh sees that
21:24:05 <augur> how old are you? o_O
21:24:09 <joelteon> 19 now
21:24:11 <carter> ooo libtool
21:24:15 <augur> lolololol
21:24:19 <carter> ?
21:24:20 <joelteon> joeyh: sorry, we are only friends
21:26:32 <joelteon> ok I seriously need to sit down and figure out how the old program was faster
21:26:35 <joelteon> my brain is a shambles
21:31:00 <jerrrryy> repeating a question.. how does one safely wrap/call a C function that modifies a global variable? in C it is has independent  value per thread, but what happens if I use it in haskell's threads?
21:32:28 <geekosaur> I think C functions (at least those tagged "safe"?) all get called from the same bound thread so that thread local storage will work
21:33:42 <danilo2> Hi! Does anybody know what "GHC.Prim.*" is as part of context of function reification in TH? If I'm trying to use it as TH result, I'm getting error "Illegal type constructor or class name: `*'" (I've got -XTypeOperators enabled). What is interesting, If I ddump-splices my TH and simply paste it as code, I've got error "`*' is applied to too many type arguments"
21:34:48 <shachaf> If you call them from the same bound thread.
21:35:25 <shachaf> Bound thread means that if you call two FFI functions from the same one, they'll happen in the same OS thread (so thread-local storage and so on will be the same).
21:37:27 <jerrrryy> I see, thanks
21:37:42 <danilo2> Maybe I'll try to ask the question other way around - does anybody know what is GHC.Prim.*? (data type)
21:38:43 <enthropy> that one doesn't follow the rules for data type names
21:39:01 <enthropy> maybe it's the * you have in a kind signature?
21:39:15 <geekosaur> that is all I can think of
21:39:24 <enthropy> but there's a StarT for that
21:39:54 <danilo2> enthropy: hmm - I'll paste a code, brb
21:39:58 <FliPPeh> I think he means GHC.Prim.Char#, GHC.Prim.Int#, ...
21:40:36 <geekosaur> that makes their first question seem rather weird
21:40:45 <FliPPeh> Right
21:40:48 <FliPPeh> Didn't read that far :>
21:44:06 <pxqr> how to convert Handle to FD?
21:44:29 <shachaf> handleToFd hth
21:45:10 <pxqr> ah, i see; thanks
21:45:45 <dhrosa> am I right in my description of the IO monad?:
21:46:43 <dhrosa> it forces side-effects to be allowed in your code through the use of the type system (everything takes an IO() and returns another IO), and the only way to get that first IO instance is through main?
21:47:08 <danilo2> FliPPeh: enthropy: I would be very thankful If you look here: http://lpaste.net/97631
21:47:20 <shachaf> I wouldn't say that it makes enough sense to be right or wrong.
21:47:50 <dhrosa> like, you can't call putStrLn in any other part of your code because the types won't match
21:47:54 <dhrosa> in pure code*
21:48:19 <shachaf> IO could work almost exactly the way it does in Haskell in an untyped language.
21:48:44 <shachaf> There's something more fundamental than the type system preventing it from happening in non-IO places.
21:49:16 <enthropy> danilo2: class Bind has 4 arguments? I think the syntax where kind variables come before type variables (-XPolyKinds) is only for output
21:49:30 <shachaf> "forces" is a very suspicious word there, but I guess you're not using it in the technical sense.
21:49:34 <shachaf> I don't know what "everything takes an IO() and returns another IO" means.
21:49:52 <Cale> dhrosa: The important thing is that IO actions are *values*, and evaluating them only tells you which IO action you have, it doesn't cause the effects to happen.
21:50:10 <Cale> dhrosa: So, there's a separation between evaluation and execution.
21:50:11 <shachaf> It's true that you start to do IO in main, but that's not unique to Haskell. The same thing happens in C, for instance.
21:50:16 <nisstyre> dhrosa: there are other ways of doing IO in a pure language, e.g. uniqueness types
21:50:29 <danilo2> enthropy: hmm, no ... Bind has got 3 variables and is defined as: class Bind m1 m2 m3 | m1 m2 -> m3 where bind :: m1 a -> (Pure a -> m2 b) -> m3 b
21:50:49 <Cale> and in a compiled Haskell program, main is executed (which causes its evaluation, because we need to know which IO action to execute)
21:51:24 <enthropy> danilo2: right, so you have that extra * in there because you have -XPolyKinds so you're being told what the kind variables are I think
21:51:25 <Cale> When you evaluate an IO action though, there's nothing visible that happens, especially because IO is an abstract datatype
21:51:31 <danilo2> enthropy: You are right! If I simply delete the GHC.Prim.* it seems to work
21:52:01 <nisstyre> well, uniqueness types preserve referential transparency
21:52:01 <nisstyre> if that's the yardstick you use to measure purity by
21:52:11 <dhrosa> shachaf: if you have do line 1 \n line 2 \ line 3 ... each line must return an IO, and they're all chained together through >>= is what I mean to say
21:52:17 <danilo2> enthropy: Hmm, but I've got it as result of reigfication - should I ? Is it bug? Is it safe to "delete" it in TH?
21:52:23 <Cale> It's actually a little bit unfortunate that IO is abstract, because it makes this harder to explain to beginners :)
21:52:36 <dhrosa> :(
21:53:01 <shachaf> Cale: Much better than any of the explanations that try to pretend it's not abstract, though.
21:53:05 <Cale> dhrosa: Yeah, all the lines of a do block must have types which are in the same monad.
21:53:16 <nisstyre> Cale: and importantly if you have a function that takes some parameter and returns an IO action, then you have to get the same IO action back if you give it the same parameter, correct?
21:53:21 <Cale> shachaf: Well, there's a nice explanation where we pretend that IO is a GADT
21:53:37 <shachaf> Well, that's roughly just as abstract.
21:53:49 <Cale> nisstyre: Well, that's a general property of functions!
21:53:51 <shachaf> You can make your own interpreter for it, I guess.
21:54:14 <shachaf> dhrosa: Anyway, it's worth figuring out what it is that's "stopping" you from doing IO in some places, since it isn't the type system.
21:54:30 <Cale> If you have a function f :: A -> B, and you have some x :: A, then f x :: B is always going to evaluate to the same thing when f and x are the same.
21:55:19 <Cale> shachaf: Yeah, it's in that sense that I mean it's unfortunate that it's abstract, because being able to see the constructors would be informative (if they weren't a horrible hack like in GHC :)
21:55:44 <enthropy> danilo2: I don't know if you're supposed to get the * there. If it is something else like  k1, k2 in there, I think those could be rather useful... if there's a straightforward way to tell which variables belong to which level
21:55:48 <Cale> dhrosa: Imagine that we had some definition of a data type by its constructors like:
21:55:52 <Cale> data IO a where
21:55:55 <nisstyre> Cale: yeah, hence the distinction between executing an IO action and just passing one around
21:55:55 <nisstyre> it's something I didn't quite grok about Haskell for a while
21:55:57 <Cale>   ReturnIO :: a -> IO a
21:56:05 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
21:56:08 <augur> hmm
21:56:08 <enthropy> then I think it's a good choice to include those variables
21:56:11 <Cale>   GetChar :: IO Char
21:56:14 <shachaf> Cale: It's even nicer, I think, to start out with a plain old data type, no GADT, no monad.
21:56:19 <Cale>   PutChar :: Char -> IO ()
21:56:30 <shachaf> Those are just nice features you can add later.
21:56:36 <Cale> yeah, perhaps!
21:56:53 <shachaf> Also, I imagine that the set of people who understand GADTs but not IO is pretty small. :-) Maybe that shouldn't be the case.
21:57:10 <dhrosa> Cale: okay
21:57:18 <shachaf> dhrosa: Did you see the answer I wrote on StackOverflow a while ago on this? http://stackoverflow.com/a/13538351/712548
21:57:25 <Cale> Well, yeah, I think GADT notation is probably actually more intuitive for beginners who aren't already familiar with BNF notation or something
21:57:29 <benbangert> sigh, somehow just not getting this State monad. my function needs a StdGen *and* its own args, and returns a unique value, and none of the docs/examples I'm finding explain how to do this or what it means
21:57:31 <augur> how interesting. if you give a syntax directly to the sequent calculus, your rules look quite interesting
21:57:56 <danilo2> enthropy: Hmm, ok. For me it is a bug, because If I'm pulling context from a function and pushing it in other place and it does not compile, it is something wrong. I'll ask about it on ghc dev irc and if there will be no response I'll file a bug. Do you want me to inform you about the status?
21:58:05 <Cale> dhrosa: So, here, GetChar doesn't actually do anything, it's just a value which we're going to think of as representing the action of getting a character from the terminal
21:58:11 <danilo2> enthropy: and thank you very much for your help!
21:58:35 <augur> you get computation rules like   let p = (M,N) in { x <- fst p ; K }   ~beta~>   let p = (M,N) in let x = M in K
21:58:43 <Cale> dhrosa: In order to make that happen, we'll need some kind of interpreter for this datatype, which pattern matches on the various possibilities, and carries out the real actions they describe
21:59:47 <Cale> dhrosa: and you can imagine (it's not entirely true, but it's true enough), that the Haskell runtime system contains an interpreter for IO actions which is given main, and chews through that, pattern matching on it, and carrying out the described effects
22:00:10 <dhrosa> Cale: how is evaluation order enforced?
22:00:19 <Cale> evaluation order, or execution order?
22:00:25 <dhrosa> err sorry, execution
22:00:33 <dhrosa> benbangert: The first argument of the State monad is the type of state you're storing, for example, an StdGen, the second argument is type of value you're returning from your function, other then the statee
22:00:39 <Cale> Well, you'll note that I included a constructor BindIO there
22:00:59 <Cale> For example, we might have the value  BindIO GetChar PutChar
22:01:06 <dhrosa> benbangert: you construct your state monad with a function that takes the previous state, and returns an output and a new state
22:01:12 <benbangert> dhrosa: it just occured to me I should put my own args first such that I return the State monad with the right args
22:01:35 <Cale> Our interpreter, if it were written in Haskell itself, might look like:
22:01:37 <enthropy> danilo2: yes I'm interested in whether they need to change things, or if there's a convenient work-around already in existence
22:01:59 <Cale> execute (BindIO x f) = do v <- execute x; execute (f v)
22:02:14 <Cale> execute GetChar = getChar
22:02:22 <danilo2> enthropy: Ok, If I get more info, I'll be back :)
22:03:01 <Cale> (This is like translating our IO datatype into an ordinary Haskell IO action)
22:03:53 <Cale> (So, maybe don't take it too literally... you could also imagine that some lower-level piece of code was written to do this, maybe a C program which inspects the Haskell datastructures in memory and carries them out appropriately)
22:04:10 <Cale> But yeah, execution order is just represented directly by the IO action values
22:04:14 <dhrosa> benbangert: if you want a function that takes a StdGen,  and returns a new StdGen as a state, and a random number in a range, you could do something like: myRand start end = state (\s -> randomR (start, end) s)e
22:04:20 <Cale> and it's completely independent of the evaluation order
22:06:02 <dhrosa> Cale: so the data structure would have some sort of ordering to it, and the run-time or whatever would exectute the code in the order of those fields?
22:06:11 <Cale> yeah
22:06:35 <benbangert> dhrosa: thanks!
22:06:49 <shachaf> dhrosa: In the same way a String has an ordering to it.
22:06:55 <shachaf> Did you see my post?
22:07:06 <dhrosa> oh woops, I put it in my clipboard but didn't look at it uet
22:07:07 <Cale> Well, BindIO x f here is intended to represent the case where we're building up an IO action which when executed, will start by executing x, and then take the result of that IO action, say v, and then execute f v
22:07:09 <shachaf> We can imagine a really simple "IO DSL" which looks like this:
22:07:18 <shachaf> data IO = PutChar Char | Done
22:07:23 <Cale> and that tells you which order things actually happen in
22:07:30 <shachaf> And then have main :: IO; main = PutChar 'a' (PutChar 'b' Done)
22:07:48 <dhrosa> benbangert: this myRand function will have a type of Int -> Int -> State StdGen Int
22:07:50 <roconnor> data IO = PutChar Char IO | Done
22:07:51 <shachaf> That would be the same spirit of IO DSL. But it's just a String!
22:07:55 <shachaf> Er.
22:07:58 <shachaf> Yes, sorry.
22:08:04 <shachaf> roconnor's correction is important.
22:08:09 <dhrosa> I see
22:08:38 <benbangert> dhrosa: I made mine like, seed :: I.Context -> State StdGen Integer, which describes a separate var I need and returns an Integer using the state, which does the trick
22:08:59 <dhrosa> what stops you from being to execute IO code in a pure function?
22:09:27 <shachaf> Well, what stops you in this String case that I mentioned here?
22:09:38 <shachaf> (Do you understand this example? I think it's important.)
22:10:10 <dhrosa> you're modeling an IO as either an IO chained into something else, or a DOne, right?
22:10:13 <dhrosa> kind of like a linked list?
22:10:18 <Cale> yeah
22:10:30 <shachaf> (In fact, I think the whole idea of data-types-and-interpreters, or values-assigned-meaning-externally, or whatever you might want to call it, is one of the more valuable things you can get from learning Haskell, when you internalize it.)
22:11:05 <shachaf> dhrosa: It's exactly a linked list. I could've said type IO = String
22:11:25 <Cale> shachaf's representation of simplified IO actions which only are able to put characters to the terminal is actually exactly the same as the representation of a string, up to renaming the constructors
22:11:50 <shachaf> And the question "if you're in some arbitrary function, why can't you execute a list of characters" isn't even exactly a question that makes sense.
22:12:25 <shachaf> The list does no input or output. The thing that eventually gets the list does the output.
22:13:18 <shachaf> And this has nothing to do with a type system. A list is just a list.
22:13:23 <Cale> A function f :: A -> B only assigns to each value x of type A some value f x of type B, that's all there is to it, and so you can't make terminal I/O happen by evaluating one.
22:13:54 <Cale> This is true even when B = IO ()
22:14:11 <shachaf> Cale: Well. I would say that in one sense, the real thing preventing you from doing I/O in Haskell functions is that there happen to be no (safe) primitives that do it.
22:14:27 <shachaf> And we really like this property so we don't introduce any.
22:14:46 <Cale> Well, right, and that's why my description of what a function is makes any sense
22:15:09 <shachaf> Right.
22:15:24 <shachaf> The main point is that it's not the type system at all.
22:15:40 <Cale> yeah, even without the types
22:16:00 <lightquake> how do I get the size in bytes of a file?
22:16:00 <Cale> IO actions are just inert values which aren't going to make anything happen until you stick them into some kind of execution machinery
22:16:05 <dhrosa> hmm, I still don't get why it only executes code in main, is it because the low-level code that interprets each IO action as a stateful action only does so on the main function?
22:16:13 <shachaf> dhrosa: It's the same reason as in C.
22:16:21 <lightquake> given its path
22:16:24 <Axman6> @hoogle FilePath -> IO Int
22:16:25 <lambdabot> Network.Socket send :: Socket -> String -> IO Int
22:16:26 <lambdabot> Foreign.C.Error throwErrno :: String -> IO a
22:16:26 <lambdabot> Language.Haskell.TH.Syntax badIO :: String -> IO a
22:16:29 <Axman6> hmm
22:16:31 <shachaf> main is special in Haskell the same way that it is in C.
22:16:36 <Axman6> there's probably a stat analogue
22:16:39 <dhrosa> ah, I see
22:16:39 <Cale> dhrosa: It's because in a compiled Haskell program, main is automatically supplied to this imaginary IO-action-executing-machine
22:16:53 <roconnor> To a Haskeller, it is like asking the question: what prevents my hard drive from being erased when I ride my bicycle to school.
22:17:07 <Axman6> nothing!
22:17:11 <roconnor> Axman6: :D
22:17:14 <Axman6> so it's bound to happen one day
22:17:17 <Cale> and it chews through main, pattern matching on it and working out what to do, step-by-step
22:17:27 <dhrosa> so, an IO action doesn't actually "execute" things, it's only when the chain of IO actions called "main" is fed to the low-level runtime
22:17:32 <dhrosa> right?
22:17:49 <Axman6> you can think of it like that yes
22:17:54 <Cale> yeah, the IO actions themselves are just descriptions of what to do
22:18:16 <roconnor> dhrosa: perfectly correct.
22:18:18 <joelteon> clever eh
22:18:25 <Axman6> which you can think of being fed to a VM which provides the parts the inputs and actually does the outputs described
22:18:36 <joelteon> that's why you can do let f = getLine in f; f; f
22:18:43 <joelteon> whoops
22:18:46 <joelteon> do f; f; f
22:19:06 <roconnor> dhrosa: an IO () value is a data structure that holds a reified version of all interactions a haskell program can do with the operating system.
22:19:12 <Cale> Inside of a do-block, you're allowed to think of  v <- x  for instance as meaning "execute x and get its result v", but once you put the whole do-block together, you have a complete IO action which is again just an inert description of something which could be done at some point.
22:19:22 <Axman6> also let be = getLine in do be; do be; do be
22:19:42 <roconnor> dhrosa: I have a blog post on the subject that might interest you:  http://r6.ca/blog/20110520T220201Z.html
22:20:19 <shachaf> I have a post too. I linked to it above.
22:20:23 <dhrosa> which leads me to the next question, is it possible to add new IO actions without modifying ghc/whatever? like, let's say I wanted to add an IO action to erase your hardrive, and there's no way to combine the existing IO actions to do that
22:20:25 <roconnor> oh good
22:20:27 <shachaf> But linking posts in IRC is futile when other people are talking.
22:20:48 <Cale> dhrosa: Well, there's the FFI, which allows you to import procedures from C
22:21:19 <shachaf> Let's say I wanted to add an IO action to solve the halting problem.
22:21:26 <Cale> and in essence, that's like adding new IO actions
22:21:32 <Cale> new primitive ones
22:21:48 <shachaf> Anything your computer can do, IO actions can do. Via FFI or various other mechanisms.
22:22:27 <Cale> Yeah, there's a whole bunch of low-level IO actions already for manipulating memory directly
22:22:47 <frxx> dhrosa you could write your own SafeIO, which would include only a subset of IO and exclude unsafe parts, such as deleting files
22:23:05 <Cale> Yeah, that's really the more interesting direction to head in :)
22:23:17 <dhrosa> if there were no FFI, and no memory-writing IOs or whatever, would this be impossible?
22:23:33 <dhrosa> i'm not sure my question makes sense anymore
22:23:43 <Cale> dhrosa: Yeah, if you had no way to describe particular actions, then there would be no way to describe those actions.
22:24:06 <dhrosa> yeah, that's what I was thinking
22:24:17 <Cale> But as it stands, IO includes a way to describe pretty much everything your computer can do
22:24:53 <roconnor> funny this blog post isn't quite how I remember writing it.
22:25:01 <Cale> (Including writing a bunch of machine code into memory and then executing it, which is what things like harpy do)
22:25:05 <Cale> http://hackage.haskell.org/package/harpy
22:25:15 <shachaf> roconnor: I even linked to it from my post!
22:25:32 <shachaf> But I think I later disagreed with it being a free monad, or something.
22:25:35 <dhrosa> that's a very minimalistic blog
22:26:01 <dhrosa> clean
22:27:04 <roconnor> I could have sworn I made some concrete remarks about IO and operating system calls.
22:27:19 <shachaf> Did you see the post I linked to above and not read it because people were talking, or not even look at it?
22:27:42 <dhrosa> yes I've read it
22:27:44 <Cale> All you'd need to do to make it look "modern" is make the background light grey, and make the text ever-so-slightly-darker-than-the-background grey, in a light sans-serif font intended to be used at sizes above 36pt
22:27:50 <shachaf> I want to know what I can fix, because I ended up typing a chunk of it in here, which is a waste.
22:27:59 <shachaf> Ah. Then I just explained it badly.
22:28:43 <Cale> also rounded corners?
22:28:45 <Cale> lol
22:29:32 <dhrosa> thanks a lot, Cale,  shachaf and others, this has been very illuminating
22:31:06 <dhrosa> to recap, the IO monad just sequences a bunch of IO action data types, and the runtiime performs pattern-matching / lookup on the sequence of actions to perform real I/O?
22:31:10 <dhrosa> in main
22:32:01 <Cale> yeah, though we wouldn't say that it sequences *types*, because types are the things on the right of the ::
22:32:23 <roconnor> dhrosa: yes.  This data structure is a certain tree structure.
22:32:23 <dhrosa> err, sequences a bunch of IO action instances?
22:32:27 <shachaf> And we wouldn't say that "the monad" does anything. We probably wouldn't even use the word "monad".
22:32:51 * hackagebot ihaskell 0.2.0.2 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.2.0.2 (gibiansky)
22:32:52 <shachaf> roconnor: Aren't they all?
22:33:12 <joelteon> dhrosa: if you look up the implementation of IO, it's just a bunch of function applications
22:33:27 <roconnor> shachaf: I wouldn't count a list as a tree in the way I mean tree.
22:33:39 <dhrosa> joelteon: where exactly what I look for that?
22:33:51 <joelteon> ghci> :i IO
22:33:59 <joelteon> defined in GHC.Types
22:34:08 <dolio> You shouldn't look up the implementation of IO in GHC, though, because it doesn't make any sense.
22:34:08 <roconnor> dhrosa: don't look up GHC's implementation of IO.  It will just mislead you.
22:34:17 <joelteon> ok
22:34:51 <dhrosa> :i IO just tells me IO's typeclasses?
22:35:04 <joelteon> does it?
22:35:07 <joelteon> that's odd
22:35:27 <roconnor> shachaf: it is important there is an branch in the IO value for every possible response to a primitive IO action.
22:36:05 <dhrosa> although that was also useful, I've wanted to know how to check the typeclasses for something, but hadn't googled yet
22:36:11 <roconnor> shachaf: I guess a list is a sort of trivial tree afterall.
22:36:14 <Cale> dhrosa: It's probably good to understand that we're just giving you a mental model for how this works. GHC's implementation in reality actually just cheats, and to represent values of type IO t uses impure functions RealWorld -> (RealWorld, t) where RealWorld is a 0-byte datastructure. The reason it does that is just so that it can reuse a bunch of machinery for dependency analysis in compiling IO actions. This is an u
22:36:14 <Cale> gly way to try to understand what's going on though, because you muddle your notion of functions with things that cause effects while evaluating.
22:37:28 <Cale> Well, something like that anyway :)
22:37:32 <Cale> newtype IO a
22:37:32 <Cale>   = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld
22:37:32 <Cale>                   -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
22:37:32 <Cale>   	-- Defined in `GHC.Types'
22:38:20 <Cale> But the lie is better than the real implementation :)
22:38:24 <dolio> shachaf: I'd probably call it the monad, though. Because I/O doesn't need to be a monad, but IO is.
22:38:34 <dolio> Which I think roconnor noted originally.
22:38:48 <dhrosa> is the real implemention more similar to a State-like monad with RealWorld as its state?
22:38:56 <Cale> dhrosa: kinda
22:39:48 <Cale> dhrosa: and this RealWorld type doesn't actually have any information, it's just there to coerce GHC's evaluation mechanism into getting the execution order right when the impure functions get evaluated
22:39:50 <shachaf> RealWorld is a terrible name.
22:40:09 <Cale> Yeah, Void or Token would be a better name
22:40:13 <dhrosa> I think I see
22:40:24 <Cale> Basically, it's an ugly hack :)
22:40:30 <joelteon> it's a good theory name, though
22:40:36 <dhrosa> by dependency analysis, do you mean like, data dependencies?
22:40:38 <Cale> joelteon: Only it's not
22:40:52 <joelteon> "IO is a State monad with the real world as its state"
22:40:56 <Cale> joelteon: It's pretty hard to understand concurrent programs that way
22:41:00 <joelteon> oh
22:41:00 <triliyn> It's a good name for bamboozling people into believing something completely different is going on
22:41:05 <shachaf> Anyway, the "real implementation" is just as much the one in Hugs as in GHC.
22:41:15 <dolio> What does Hugs do?
22:41:20 <joelteon> let's not say
22:41:20 <Cale> Yeah, we could also look at hugs' implementation, I suppose
22:41:28 <Cale> I've never actually peeked at that
22:41:32 <roconnor> Hugs has some sort of continuation passing style thing?
22:41:36 <dolio> Look at hbc.
22:41:38 <Cale> Hugs being written in C...
22:41:40 <roconnor> probably much closer to our free monad model.
22:41:41 <dolio> It does something with continuations.
22:41:49 <dolio> I've heard.
22:41:54 <Cale> cool :)
22:42:30 <shachaf> I looked at Hugs's implementation to see how it does threading once.
22:43:02 <Cale> If you look at old versions of Haskell, you'll find that IO in the form we take for granted now is missing, and in its place is a system where you produce a function from a stream of responses to a stream of requests.
22:43:15 <shachaf> It's coöperative threading but implemented a little strangely.
22:43:28 <shachaf> Now I can't find it.
22:43:34 <Cale> So that's another way to do
22:43:35 <Cale> it
22:43:48 <Cale> You could actually build the IO type on top of something like that
22:45:06 <dolio> It also has continuation-based combinators that build things for you in ways that can't deadlock.
22:45:11 <dolio> Which looks a lot like IO.
22:45:34 <Cale> augur: After the introduction, Pfenning's first lecture is *so mindnumbingly boring*, but I guess that kind of comes with the territory :)
22:46:49 <lightquake> anybody in here experienced with the pipes library? I'm trying to figure out how you'd implement Pipes.Prelude.fold using only non-internal stuff
22:47:10 <shachaf> http://hackage.haskell.org/trac/hugs
22:47:11 <shachaf> :'(
22:47:13 <lightquake> but afaict there's no way to 'peek' into a Consumer to see whether it has anything left to produce other than pattern-matching on the constructor
22:48:08 <augur> Cale: pish! its terribly fun
22:48:52 <augur> Cale: the first lecture picks up again. he ends up talking about things like lax logic by the end of it, which is the logic of monads
22:49:02 <Cale> okay
22:49:15 <augur> Cale: whered you leave off?
22:49:15 <Cale> I just got into the seemingly-endless discussion of product types
22:49:32 <augur> ??
22:49:33 <Cale> and skipped around a bit and then he was still talking about products
22:49:41 <Cale> Maybe I got unlucky
22:49:43 <augur> what time stamp in which video?
22:49:59 <shachaf> Cale: Maybe he's trying to sell you something.
22:50:06 <Guest77254> @pl flip fmap
22:50:06 <lambdabot> flip fmap
22:50:22 <Guest77254> any built-in that's equivalent to flip fmap?
22:50:27 <Cale> augur: like around half an hour into lecture 1 here: http://www.youtube.com/watch?v=YRu7Xi-mNK8
22:50:41 <Axman6> flip (<$>) -- >_>
22:51:18 <Axman6> @hoogle f a -> (a -> b) -> f b
22:51:19 <dhrosa> flip fmap = pamf
22:51:19 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
22:51:20 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
22:51:20 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
22:52:00 <augur> Cale: oh, he's going slow to explain the concepts of beta and eta, basically
22:52:09 <maxiepoo> lol pamf
22:52:15 <lightquake> lens defines it as <&> :V
22:52:24 <augur> Cale: and why they make sense as checks of logical sanity
22:53:09 <augur> i mean, you have to understand, beta and eta have more than just computational content, they actually have purely logical reasons for existing: they're witnesses to soundness and completeness of your logic
22:53:33 <augur> and so its important to know _why_ they act as witness to that
22:54:09 <augur> so the whole spiel hes going through is to explain why, for instance, it's no good to just have fst as your only product elim: its incomplete
22:54:28 <augur> and also why its not at all ok to have something like fst as a sum-elim rule: its unsound
22:55:41 <lightquake> i really need to learn this area of math/cs
22:55:51 <augur> lightquake: which area?
22:56:04 <lightquake> whatever you'd call the stuff you're talking about :P
22:56:16 <augur> oh
22:56:18 <augur> logic? :P
22:56:21 <lightquake> yeah
22:56:28 <augur> well, watch those videos!
22:56:32 <augur> @where oplss2012
22:56:33 <lambdabot> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
22:56:36 <augur> pfenning's lectures
22:56:56 <augur> they introduce proof theory from a certain perspective related to computation
22:56:56 <Cale> augur: Yeah, I guess it's useful to make sure everyone's on the same page here. It's just the explanations of the usual stuff is filling lots of time and making it slightly painful. :)
22:57:12 <lightquake> i don't like lectures though :<
22:57:35 <augur> lightquake: his webpage has a class called constructive logic. the schedule has readings.
22:58:02 <augur> Cale: sure, but i mean, its not just filling time, because these same principles are guides to later discussion
22:58:41 <augur> Cale: if you dont grok this kind of justification of a logic/type theory, then you get all sorts of fishy, totally not cool things
22:58:55 <Cale> augur: I can imagine another presentation of this where he just puts the introduction and elimination rules on the board, and then focuses on making his point about the local reductions.
22:59:11 <augur> that is what he does tho..
22:59:11 <Cale> (and it's a lot faster)
22:59:27 <augur> well, sort of
22:59:34 <augur> i mean, he's taking the verificationist route, right
22:59:41 <augur> which means he cant just put it ALL up there
23:00:06 <augur> since the whole point of the verificationist route is that your intros determine your elims to some extent
23:00:40 <augur> so once you settle on intros, you can then figure out what your elims have to be, up to some kind of equivalence
23:00:44 <Cale> Or vice versa
23:00:55 <augur> vice versa is the pragmatist perspective
23:01:12 <Cale> I somehow find it distasteful to have names for those
23:01:19 <augur> why?
23:01:24 <augur> the distinction is important
23:01:40 <levi> Watching the lectures with headphones is annoying due to the audio being only in the left channel.
23:01:57 <augur> intros justify elims, vs elims justify intros. those are two very different perspectives on what a connective means
23:02:01 <augur> they're not at all the same
23:02:02 <Cale> I'm not sure I can explain why. But especially the -ist ending makes it sound like something that someone would subscribe to as a general point of view.
23:02:12 <augur> Cale: many people DO
23:02:21 <Cale> These are both techniques which everyone should be applying all the time in both directions?
23:02:22 <augur> gentzen was a verificationist
23:02:29 <augur> no, they're definitely not
23:02:37 <augur> thats part of the point of the two perspectives
23:02:39 <Cale> They're categorically dual to each other!
23:02:44 <augur> some things only make sense from one direction
23:02:57 <augur> they are indeed categorically dual. doesn't mean you dont have both :)
23:03:09 <augur> doesn't mean they're identical, just dual
23:03:22 <augur> actually im not sure they are categorically dual, per se, but thats irrelevant
23:03:24 <Cale> I mean, you always have both. Subscribing to one or the other as a main perspective is the wrong thing to do.
23:03:36 <augur> you can always have both for some things
23:03:41 <augur> sort of
23:03:56 <augur> but there is a genuine difference, especially computationally. or so im lead to believe
23:04:07 <Cale> hrm
23:04:17 <augur> which is that connectives that are verificationist are data, and connectives that are pragmatist are codata
23:04:27 <augur> or maybe im conflating isms with polarity
23:04:47 <augur> tho i dont think im conflating, i think they're essentially the same. maybe. who knows.
23:05:15 <augur> but philosophically, they're opposite views of what the meaning of a connective is
23:05:31 <Cale> See, I don't care about the philosophy at all, maybe that's why
23:05:52 <augur> well like i said, there are computational ramifications for the choice
23:06:20 <augur> essentially, pragmatism = laziness
23:06:34 <augur> more or less. if the pragmatism = codata thing is correct
23:06:54 <Cale> Initial objects vs. terminal objects
23:07:02 <augur> right
23:07:07 <augur> which are not the same, merely dual
23:07:11 <Cale> limits vs. colimits
23:07:31 <Cale> Well, if you study one, you can transform any theorem about it into a theorem about the other
23:07:32 <augur> but more important is that the possibility of mixing things in the same logic. having some positive and some negative connectives
23:07:46 <binroot> given thee lists l1 l2 l3 in that order, how can I most neatly return the first list that is not empty?
23:08:07 <augur> Cale: sure, you can transfer knowledge easilly enough, but you dont get identical operational semantics
23:08:23 <augur> im not sure if everything is dualizable, either. some connectives might be only strictly positive or negative
23:10:17 <binroot> my attempt find (not.null) [l1,l2,l3]
23:10:21 <dhrosa> head filter (not.null) [l1, l2, l3] maube?
23:10:24 <augur> Cale: its really just not true that everything is both
23:10:24 <dhrosa> ...
23:10:26 <dhrosa> lol
23:10:30 <binroot> haha
23:11:04 <dhrosa> head $
23:11:06 <Axman6> hmm, so turns out implementing map-reduce is harder than expected
23:11:10 <Cale> binroot: yeah, that's good
23:11:16 <binroot> cool
23:11:31 <Cale> (I'd put spaces around the . just because)
23:11:39 <mada> head $ dropWhile null [l1, l2, l3]
23:11:46 <augur> Cale: by having a perspective that is sufficiently general, you can force less onto your language. you can be selectively lazy, for instance.
23:11:59 <tabemann> does anyone know why threadscope 0.2.2 wouldn't compile for ghc 7.6.3 on debian?
23:12:10 <Cale> augur: I'm not sure that I understand yet what this has to do with evaluation order
23:12:28 <Cale> (data and codata don't have anything to do with evaluation order in my head)
23:12:59 <augur> Cale: codata is lazy data, more or less
23:13:16 <dhrosa> the find method is safer, assuming they might all be null
23:13:21 <Cale> I'm not sure that's how I'd define it
23:13:29 <tabemann> when I try to compile it it comes up as full of ambiguous occurrences
23:13:34 <Cale> data and codata are kind of identified in Haskell
23:13:49 <augur> Cale: yes, haskell's codata happens to also be haskell data
23:14:26 <augur> Cale: but haskell is essentially uniformly lazy, modulo bang patterns
23:15:23 <augur> but when you dont want to decide on uniformity, you get laziness by having codata
23:15:27 <Cale> It seems entirely independent of evaluation order to me
23:15:46 <augur> evaluation order has _something_ to do with it
23:15:48 <augur> i mean, it must
23:15:54 <augur> you cant have applicative order evaluation and be lazy
23:15:59 <augur> they're inherently incompatible
23:16:05 <Cale> It's not like having codata in Coq or Agda has forced them to evaluate their expressions outermost-first
23:16:55 <augur> this is true. i think the evaluation order stuff is at a different level than what we're used to thinking about
23:17:40 <Cale> I don't see how it matters. You can talk about initial F-algebras and terminal F-coalgebras in Set where there's no evaluation order to talk about.
23:17:46 <augur> well i dont know
23:17:47 <augur> i cant help you
23:17:52 <augur> im just telling you what ive heard
23:17:56 <Cale> okay :)
23:18:06 <Cale> Maybe there is some kind of connection.
23:18:26 <augur> im trying to work through this stuff right now
23:18:30 <augur> trying to come to grips with it
23:18:42 <augur> there are little hints here and there of CPS transformations
23:19:16 <augur> which suggests something related to laziness, sort of
23:19:52 <augur> afaict, it really has to do with what you take as basic to your logic, i think
23:20:19 <augur> so agda doesnt take codata as native in the sense that i think zeilberger means, lets say
23:20:48 <augur> and so as a consequence, agda's codata is some kind of embedding of codata or something like that
23:21:15 <augur> whereas i think zeilberger's perspective is going to end up being precisely that native codata really does lead to mixed evaluation order
23:21:19 <Cale> If you look at it very naively, there sort of is a connection to nonstrict semantics, in that for a fixed F, the initial F-algebras are going to be finite datastructures and the terminal F-coalgebras are typically going to include infinite ones.
23:21:40 <binroot> @pl \ls = unique $ concat $ map edits1 ls
23:21:40 <lambdabot> (line 1, column 5):
23:21:40 <lambdabot> unexpected "="
23:21:41 <lambdabot> expecting operator, pattern or "->"
23:21:41 <augur> yes, thats whats meant by data/codata
23:21:47 <binroot> @pl \ls -> unique $ concat $ map edits1 ls
23:21:47 <adelbertc> cloud haskell seems be the popular way of distributing haskell across nodes - wondering if there are preferred alternatives for say, cluster computing?
23:21:47 <lambdabot> unique . (edits1 =<<)
23:22:06 <Cale> But that doesn't exactly tell you what order to evaluate things in
23:22:49 <Cale> (Maybe you need non-strict semantics to some extent?)
23:23:14 <augur> Cale: well, if you have them natively, it prevents you from using applicative order. if you have soe kind of coding like agda does, i think, then you can be applicative order, if you want
23:23:33 <augur> but only because you're doing something else
23:24:01 <augur> tho tbh im not sure how agda does evaluation of codata. copatterns are confusing.
23:24:36 <augur> i mean, i get them insofar as programming with them, but i dont understand the theory behind them
23:24:59 <augur> so for all i know they really are native codata with normal order evaluation or something
23:25:01 <augur> who knows
23:25:13 <Cale> Well, you're not allowed to fold over codata to produce data like you can attempt to do in Haskell.
23:25:41 <augur> anyway, i dont understand the connection yet. tho i will say this: wadler has a paper on how cbv and cbn are dual!
23:26:15 <augur> i think zeilberger talks about cbpv? i dont know. its all very confusing. i dont understand any of it yet.
23:26:52 <augur> but i think it still warrants some attention to the distinction between verificationist and pragmatist views of meaning
23:27:05 <Cale> hm
23:27:22 <Cale> When I define a coinductive nat in Coq, I don't get any kind of coinduction principle defined for me
23:27:51 <Cale> I guess I'm still allowed to use CoFixpoint to define corecursive things.
23:28:08 <Cale> You'd think it might provide some basic principle like it does for inductive types though.
23:36:02 <augur> Cale: im sure that there are also discussions about how these views relate to other judgments
23:36:22 <augur> but afaict, pfenning's presentation only relates to the judgement `A true`
23:39:15 <issam> Hi, I'm finding it difficult to find the type sequence for a haskell function
23:39:25 <issam> is there a systematic way of knowing it?
23:39:33 <shachaf> What is a type sequence?
23:39:39 <Cale> issam: I'm having trouble parsing your question
23:40:02 <Cale> Do you mean  :t myFunction  in GHCi?
23:40:31 <Cale> (i.e. you could have done without the word "sequence"?)
23:40:37 <issam> lol
23:40:45 <Cale> Or you want to know what the type of the sequence function is?
23:40:47 <Cale> :t sequence
23:40:48 <lambdabot> Monad m => [m a] -> m [a]
23:40:49 <issam> Cale, for example the type definition for "twice f x = f (f x)"
23:40:59 <issam> sequence as in the type definition :)
23:41:08 <Cale> :t let twice f x = f (f x) in twice
23:41:08 <lambdabot> (t -> t) -> t -> t
23:41:11 <issam> yes
23:41:17 <issam> how do i figure that out manually
23:41:30 <augur> issam: learn a little bit of type theory x3
23:41:35 <augur> that'd be my answer, anyway
23:41:36 <Cale> issam: Okay
23:41:45 <issam> i know that f is of type t
23:41:46 <Cale> So because twice is applied to two parameters on the left
23:41:51 <issam> so t-> t
23:41:55 <augur> you can sort of figure it out in a sketchy fashion, but i'd say you really should learn some type theory
23:41:55 <issam> for the params
23:41:57 <Cale> its type must be a -> b -> c for some types a, b, c
23:42:10 <issam> yes
23:42:11 <Cale> and we immediately have that f :: a, and x :: b
23:42:27 <Cale> and now on the right we see that f x occurs
23:42:36 <augur> (what Cale is doing is teaching you seat-of-your-pants type theory, fwiw)
23:42:40 <Cale> So f must be a function
23:42:42 <silasm> augur: resources on beginning type theory? All I have is either really simple or way over my head, e.g. homotopy type theory
23:42:58 <Cale> So we know that a = a1 -> a2
23:43:03 <augur> silasm: yes sure (issam, you too). here:
23:43:08 <issam> ah okay
23:43:10 <augur> @where oplss2012
23:43:10 <lambdabot> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
23:43:13 <Cale> and moreover, it must be able to take x as an argument
23:43:17 <Cale> So, a1 = b
23:43:17 <issam> so x is of type t and f x returns t hence t->t
23:43:27 <augur> pfenning's lectures, and also harpers lectures, tho harper talks about dependent types as well
23:43:31 <augur> thats beginner type theory
23:43:34 <silasm> augur: kickass, thanks
23:43:36 <augur> there's also
23:43:38 <augur> @where tapl
23:43:38 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
23:43:40 <Cale> and we know that f x :: a2 then
23:43:55 <Cale> but then we see the application f (f x)
23:44:24 <augur> silasm, issam: Cale found some youtube versions of the oplss2012 videos, too, btw.
23:44:52 <issam> thanks!
23:44:54 <Cale> So a1 = a2 (i.e. the argument type of f must match the type of f x here)
23:45:34 <Cale> and then the whole right hand side then has type c, but we also know that this is a2
23:45:46 <Cale> So a2 = c
23:45:46 <issam> Cale, so the first (t->t) is the param type and return type of (f x) right
23:46:12 <Cale> What's t?
23:46:22 <issam> :t let twice f x = f (f x) in twice
23:46:23 <lambdabot> (t -> t) -> t -> t
23:46:29 <issam> the type
23:46:41 <Cale> yeah, that's GHC's type, I'm in the middle of an explanation of how it got that
23:46:42 <silasm> augur: awesome. Although I was already going to spend a bunch on books, guess I'll pile a couple more on. I'd forgotten about the Pierce book on types.
23:46:46 <issam> ah okay
23:46:47 <Cale> and I haven't introduced t yet :)
23:46:52 <issam> sorry, please continue :)
23:47:03 <augur> silasm: tapl is available for free i think
23:47:08 <carter> since when?
23:47:13 <carter> bob harpers book is free though
23:47:17 <Cale> Okay, so let's be a little more organised about what we know as we go along because I think this was a bit hard to follow perhaps
23:47:25 <augur> carter: since the internet x3
23:47:26 <augur> arr
23:47:27 <issam> yah :S
23:47:59 <Cale> So, we basically introduce type variables for each subexpression, and then we try to unify the types, collecting up a system of equations
23:48:01 <carter> link? my googles fu is weak
23:48:07 <augur> carter: libgen.org
23:48:08 <shachaf> Also maybe the step-by-step type inference of an expression like that would be better for #-overflow.
23:48:10 <silasm> augur: heh, I only take "free" textbooks if I'm forced to buy something for classes. If I want the book for my own study I'll buy it.
23:48:15 <issam> yes
23:48:18 <Cale> yeah, let's go to #haskell-overflow
23:48:32 <augur> silasm: yeah, but how do you know you want it!
23:48:35 <issam> Cale, im there not :)
23:48:37 <issam> now*
23:48:38 <pdxleif> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ ?
23:49:13 <silasm> augur: true. I read most of lyah (and now the parallel haskell book) online before buying them, might do that again :P.
23:50:46 <silasm> and so grows my to-read list, lol. I'm only a quarter of the way through iofpl.
23:54:09 <pdxleif> iofpl?
23:54:23 <silasm> implementation of functional programming languages
23:54:27 <silasm> Simon Peyton Jones
23:54:47 <silasm> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/index.htm
23:56:12 <augur> Cale: related to the discussion in overflow, you can view inference rules as establishing equations, which is quite an interesting perspective, since it sort of liberates the rules from an directionality bias
23:58:42 <augur> G !- M : A   G !- N : B   C = A*B   ===[*I] G !- <M,N> : C
23:59:05 <augur> its not too unreasonable a thing, in a setting with type functions, i think
23:59:14 <augur> since you might want to instead write ~ not =
