00:00:06 <augur> Cale: i dont think locus solum is utter nonsense, i think its just really artsy, and doesnt explain certain core things
00:00:12 <augur> which isnt uncommon i find
00:00:39 <augur> like with zeilberger, his stuff jumps very quickly into stuff that he obviously understands well, but is forgetting that we dont understand yet
00:00:56 <augur> so its a sort of game to try and figure out what he's leaving out because he thinks its obvious
00:01:01 <augur> locus solum is like that
00:01:18 <augur> its insufficiently ground-up to really be clear
00:03:12 <Cale> There might be something to it, but I will continue to assume otherwise until I find someone who can explain any significant part of it to me.
00:04:16 <augur> Cale: i saw this the other day: http://ccg.doc.gold.ac.uk/teaching/ludic_computing/ludic1.pdf
00:04:24 <augur> and realized
00:04:33 <augur> thats got nothing to do with girard
00:04:37 <augur> and felt it was apropos
00:05:09 <Cale> hah
00:05:30 <augur> but: http://iml.univ-mrs.fr/~vaux/pub/ludique-clmps11.pdf
00:07:32 <augur> zeilberger does talk about some similar things, and im sort of grokking a bit of it
00:07:57 <augur> it seems to maybe relate to some comments dummet had on canonicity of proofs? i dont know
00:08:30 <stevejb> hello. I recently switched from Ubuntu to Arch linux, and I am trying to get Haskell platform up and running. It seems like the three choices are 1) Simply download, compile, and install the haskell platform from haskell.org. 2) use the AUR repositories. 3) Use the ArchHaskell group's packages. My intuition is to just simply download and compile as normal. Is there a good reason to install from repositories?
00:09:04 <nisstyre> stevejb: I don't use the AUR packages at all personally
00:09:14 <JuanDaugherty> stevejb, best is to install ghc then haskell platform yourself
00:09:25 <shachaf> I don't know about Arch but maybe #archlinux-haskell would know.
00:09:25 <nisstyre> stevejb: you can just install ghc and cabal-install from pacman no?
00:09:31 <dhrosa> I have a project that depends onthe hfuse package, the version in cabal doesn't build in ghc7.x, but the one in APT does, so I installed that. if I try 'cabal configure', it says 'At least the following dependencies are missing: hfuse -any'
00:09:39 <dhrosa> if I run it with --global or --user I get the same error :(
00:10:12 <stevejb> nisstyre: I suppose I could do that. However, it seems according to this http://www.haskell.org/ghc/download_ghc_7_6_3 that I just need the haskell platform
00:10:14 <dhrosa> and I know its installed properly, I can run and compile with ghc without cabal
00:10:21 <Cale> stevejb: What I tend to do is just to ignore my distribution's Haskell-related-anything, and download the generic linux binary for GHC from the GHC website, and then grab the tarball for cabal-install from hackage.
00:10:23 <stevejb> shachaf: thank you for the reference
00:10:34 * hackagebot x509-util 1.4.3 - Utility for X509 certificate and chain  http://hackage.haskell.org/package/x509-util-1.4.3 (VincentHanquez)
00:10:34 * hackagebot hakyll-elm 0.2 - Hakyll wrapper for the Elm compiler.  http://hackage.haskell.org/package/hakyll-elm-0.2 (maxiepoo)
00:10:34 <JuanDaugherty> (on any platform, with the possible exception of Nixos)
00:10:35 <Cale> stevejb: (which contains a bootstrap.sh script)
00:11:00 <stevejb> Cale: is downloading Haskell platform not sufficient?
00:11:06 <Cale> stevejb: After that, you can install whatever libraries you need as you need them, so the platform isn't even necessary
00:11:21 <stevejb> Cale: I see.
00:11:28 <Cale> (using cabal install)
00:12:04 <stevejb> so the disadvantage of installing the entire haskell platform would just be that it may have some things that I may never use. Are there any other disadvantages?
00:12:05 <nisstyre> stevejb: I just installed cabal-install and ghc from the "extra" repository
00:12:19 <nisstyre> Arch is pretty good at keeping it up to date
00:12:33 <nisstyre> and then do what Cale suggests, install libs with cabal, etc...
00:12:47 <nisstyre> ignore the AUR versions of Haskell libraries
00:12:59 <Cale> stevejb: Well, in general, the haskell platform *may* not have the version of GHC you want. It tends to lag a bit behind, but right now it's up to date.
00:13:15 <Cale> and I guess, it's a bunch of extra compiling?
00:13:31 <stevejb> yeah, I do recall it taking a while
00:13:33 <JuanDaugherty> "haskell platform" is just a name/brand don't take it literally
00:13:51 <Cale> It's more practically useful on Windows and Mac
00:13:52 <nisstyre> stevejb: also if you feel the need to compile things yourself then you can use abs for that
00:14:01 <nisstyre> it's like BSD's ports if you've ever used that
00:14:04 <Cale> because there's a bunch of extra setup there
00:14:09 <nisstyre> you cd into a directory and run makepkg
00:14:10 <stevejb> I had read about it but I haven't used it
00:14:24 <Cale> (also because binaries are provided)
00:14:58 <Cale> On linux, HP relies entirely on each distribution to distribute binaries, which I'm not totally sure is a great idea.
00:15:23 <JuanDaugherty> huh?
00:15:29 <Cale> At least, I've learned not to trust my distribution with anything important over the years :)
00:15:43 <Cale> Maybe I'm just cynical
00:16:09 <nisstyre> I've been burned by Ubuntu with out of date software but never Arch, and programming related stuff has never been screwed up
00:16:29 <JuanDaugherty> HP uses cabal install last I knew, I only use it on linux and mac though
00:16:40 <bmuk> Cale: what is the benefit of the haskell platform over cabal installing packages as you need them?
00:16:52 <stevejb> I typically like to compile things myself, just because I don't always feel good about having binaries handed to me
00:17:10 <bmuk> stevejb: gentoo or bsd?
00:17:23 <stevejb> bmuk: oh, Arch linux
00:17:47 <nisstyre> stevejb: then just setup an ABS tree, then cp /var/abs/extra/cabal-install and /var/abs/extra/ghc somewhere, then run makepkg in both and pacman -U *xz
00:17:52 <bmuk> me too, isn't there a pacman command to compile from source?
00:18:24 <Cale> I'd rather things were compiled by the people who wrote the software than some random other guys or myself.
00:18:25 <stevejb> nisstyre: that seems like a good idea. I haven't used ABS before. I can look into that
00:18:27 <nisstyre> *cp -r
00:18:33 <nisstyre> stevejb: it's very simple
00:18:49 <nisstyre> https://wiki.archlinux.org/index.php/Arch_Build_System
00:18:49 <JuanDaugherty> bmuk, it'll already be done
00:19:00 <Cale> (At least, in general)
00:19:19 <JuanDaugherty> and you have a base you can quick roll back to should cabal hell rear it's ugly head
00:19:23 <nisstyre> stevejb: tl;dr "sudo abs" to populate your abs tree
00:19:26 <nisstyre> and then do what I said
00:19:41 <stevejb> :) that seems doable
00:20:19 <bmuk> I guess I haven't yet experienced "cabal hell" lol
00:20:46 <JuanDaugherty> well it ain't b4 ur time because it's still around
00:20:52 <JuanDaugherty> abeit reduced
00:21:06 <nisstyre> stevejb: you get the benefit of having downloaded and compiled the software yourself and having the package manager track it
00:21:30 <dhrosa> anyone have any ideas how to fix my cabal dependency?
00:22:10 <augur> Cale: if i figure out any of this locus solum stuff (i'm reading it again) ill write a tutorial
00:22:22 <Cale> augur: cool
00:22:23 <stevejb> nisstyre: that does seem really appealing. I have not used Arch very much yet but it seemd like a really nice part of it
00:22:39 <augur> Cale: im trying to do that with zeilberger's stuff right now too
00:22:42 <augur> not working so well :(
00:23:14 <Cale> Which Zeilberger stuff?
00:23:25 <nstdloop> Is there a relative release date for GHC 7.8?
00:23:38 <nisstyre> stevejb: yeah, the PKGBUILD file is just a shell script that downloads a version of the software and builds it for you
00:23:48 <JuanDaugherty> sounds like an escalated version of the erudition vs. gobbledygook problem
00:24:00 <Cale> nstdloop: Real Soon Now
00:24:26 <Cale> (Before Half Life 3, okay?)
00:24:27 * nstdloop thinks it's been that way for months
00:24:34 <nstdloop> Gotcha
00:24:50 <nstdloop> The october report says it should be out already
00:24:50 <nstdloop> so
00:25:15 <Cale> I think it's just that certain important people became busy, and also holidays.
00:25:31 * hackagebot distributed-process-p2p 0.1.2.0 - Peer-to-peer node discovery for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-p2p-0.1.2.0 (AlexanderBondarenko)
00:25:40 <nstdloop> I guess. I'm mostly just wanting built-in Xcode 5 resolution
00:26:02 <Cale> You could always try to run HEAD
00:26:22 <nstdloop> I don't really do anything complicated enough that it might break with HEAD
00:26:33 <nstdloop> but I don't really want to deal with it
00:28:05 <Cale> lispy: Oh, also, your friend should be complaining even more about the fact that the definition of a category involves this notion of collections of things.
00:28:51 <Cale> lispy: There are lots of annoying, but ultimately solvable foundational issues involved in the fact that we want to be able to talk about e.g. the category of sets, while there is no set of all sets.
00:30:00 <dhrosa> so, there's a package on hackage that doesn't compile on new GHC, whose github link is broken, and whose maintainer email is dead, I can make this package work with a patch, and have found a clone of the repo online, what should I do?
00:30:37 <dhrosa> the maintainer email returns an error if I try to send to it*
00:31:32 <zett_zelett> http://www.haskell.org/haskellwiki/Monad_tutorials_timeline This is one of the most hilarious things I’ve seen this year.
00:31:51 <dhrosa> is there a protocl for taking over a project on hackage?
00:32:52 <nstdloop> zett_zelett: That graph
00:33:40 <tertl3> anyone used yesod b4?
00:34:00 <jle`> why doesn't ever language have currying :/
00:34:07 <jle`> i guess it wreaks havoc on default parameters
00:34:15 <augur> Cale: im understanding WAY more now than i did before
00:34:17 <simpson> jle`: Because some languages have much more complex calling conventions.
00:34:22 <augur> progress! \o/
00:34:42 <simpson> jle`: And those languages usually have a currying equivalent.
00:35:04 <jle`> i guess currying wouldn't make any sense without first class functions
00:36:31 <nstdloop> jle`: even if you have first class functions, it still doesn't work.
00:36:46 <nstdloop> default args and variable argument counts destroy effective clean currying
00:36:52 <jle`> necessary but not sufficient
00:36:59 <nstdloop> ya
00:38:06 <simpson> Python's partial() is a curry for Python's calling convention. Not a problem; the thing is to understand what currying actually means.
00:38:06 <nstdloop> If you want safe, default currying to be the default method of function calling, you need to disable lots of useful features
00:38:20 <nstdloop> simpson: it just isn't the default
00:39:28 <Cale> nstdloop: Also, you probably want to detect cases where functions will be applied more fully, and not handle those inefficiently
00:39:43 <nstdloop> Absolutely.
00:40:14 <nstdloop> Python, for instance, has a relatively high overhead for a function call
00:40:36 <nstdloop> So having to create three functions and make four function calls for a function with four arguments would be really inefficient
00:41:50 <nstdloop> Haskell should totally have decorators
00:42:08 * nstdloop hasn't thought this out at all, just imagined it would be neat
00:42:48 <Fylwind> sigh why does every Haskell indentation mode have some kind of flaw
00:43:43 <Fylwind> trying to indent the import list using haskell-indentation with the "prefix-comma" style and it's like "nope"
00:45:06 <stevejb> nisstyre: thanks for the advice a few minutes ago. Compiling ghc via ABS right now!
00:45:16 <nisstyre> no problem, glad to help
00:46:00 <dhrosa> nstdloop: most decorators in python are easily representable with some sort of function composition in haskell
00:46:54 <augur> Cale: ok, ive given up again on page 11 this time
00:47:25 <nstdloop> dhrosa: True. But most decorators in python could be implemented with one additional line under the function definition. It's a syntactic sugar, not really a language feature.
00:48:11 <nstdloop> Decorators might let you do things that are a little more complicated though. For instance, I could make a decorator that takes a function as input and returns a new function that does IO, to, lets say, print its arguments
00:48:34 <nstdloop> If you do that inside the function definition you have to manually fudge about with the IO types
00:48:46 <nstdloop> and have to manually change the function back when you want to get rid of the logging
00:51:25 <nstdloop> decoLog1 f = \x -> do { print x; f x }, for instance
00:53:31 <roboguy_> nstdloop: what about Debug.Trace?
00:54:02 <nstdloop> It's a toy example. But the general idea is something that might be useful. Do arbitrary transformations on pure functions outside of their definitions.
00:54:47 <roboguy_> nstdloop: you can already do that by making another function though...
00:55:34 * hackagebot ini 0.1.0 - Quick and easy configuration files in the INI format.  http://hackage.haskell.org/package/ini-0.1.0 (ChrisDone)
00:55:38 <nstdloop> But then you have to go through the whole program and change all the instances of that function
00:56:29 <roboguy_> not if you just add a ' to the function name and name the new function the original name. in fact, you could probably make a template haskell macro that does decorators like that if you wanted to
00:56:32 <nstdloop> I could have a 'log the first argument' decorator, then disable and enable that quickly and across the baord
00:57:28 <Fylwind> I'm looking at GHC.Show.hs and this line doesn't make any sense to me: show x          = shows x ""
00:57:54 <Fylwind> don't show and shows both have the exact same type signature?
00:58:06 <roboguy_> :t show
00:58:08 <lambdabot> Show a => a -> String
00:58:10 <roboguy_> :t shows
00:58:11 <lambdabot> Show a => a -> ShowS
00:58:15 <roboguy_> nope
00:58:34 <Fylwind> oh wow totally missed that ShowS :(
00:58:38 <mm_freak> nstdloop: so a "decorator" changes the semantics of an existing function?
00:58:47 <Fylwind> thanks roboguy_
00:59:06 <nstdloop> mm_freak: I could have a pure factorial = product . enumFromTo 1
00:59:13 <roboguy_> Fylwind: sure! ShowS is a trick to get efficient list appending
00:59:23 <nstdloop> then tag it with a decorator that wraps it in a side effect
00:59:33 <nstdloop> and then when I no longer want that side effect
00:59:37 <nstdloop> I can just remove the decorator
00:59:46 <mm_freak> nstdloop: so yes
00:59:50 <nstdloop> Of course you could also use them to implement things you don't want to remove
01:00:02 <roboguy_> nstdloop: to me, that sounds like the kind of thing that haskell works pretty hard to avoid
01:00:07 <nstdloop> Probably
01:00:19 <mm_freak> nstdloop: then i'm glad haskell doesn't allow that =)
01:00:21 <nstdloop> As I said, I haven't really thought this through
01:00:38 <roboguy_> nstdloop: but like I said, I imagine it would be possible with TH
01:00:54 <nstdloop> probably
01:01:28 <mm_freak> nstdloop: i'm happy to apply combinators to functions
01:01:53 <mm_freak> printArg :: (Show a) => (a -> b) -> a -> IO b
01:03:25 <nstdloop> Can I define a type signature for an expression before I write it in ghci so it tells me if I am wrong?
01:03:55 <mm_freak> type MyExpr = …
01:04:01 <mm_freak> let x :: MyExpr; x = …
01:05:21 <nstdloop> Ah.
01:05:39 <roboguy_> nstdloop: also, you can do multiline input with :{ ... :}
01:07:12 <mm_freak> unfortunately :{ :} does not report errors until you close
01:07:21 <mm_freak> and then you have to retype the type signature again
01:21:31 <Fylwind> does anyone remember the flag used to autogenerate an export list for GHC?
01:22:46 <Fylwind> or nevermind i'm just deluded
01:22:56 <Fylwind> was thinking of *import* lists
01:34:12 <flammi> hi, does anybody know where I can find a good tutorial for gui programming with haskell?
01:35:25 <flammi> i have worked with gtk in other programming languages before and found gtk2hs
01:36:04 <dleedev> Hi Cale, augur
01:37:02 <augur> hello!
01:37:03 <Entroacceptor> flammi: afaik that's a direct wrapper, you can use it similarly to gtk in other languages.
01:37:06 <flammi> and i am not sure if frp is an better option...
01:37:09 <dleedev> I've reading through category theory and endofunctors, and have some questions
01:38:00 <augur> dleedev: ok
01:38:11 <dleedev> augur: first, category is a collection of objects... and those objects are haskell types in haskell
01:38:13 <flammi> Entroacceptor: have you any experience with frp?
01:38:19 <moop> morning everyno
01:38:21 <Entroacceptor> flammi: sadly, no
01:38:23 <moop> everynon
01:38:26 <moop> everyone
01:38:35 <augur> dleedev: sure
01:39:17 <Entroacceptor> flammi: look into reactive-banana or netwire
01:40:20 <flammi> ok, i will take a look, thx ;-)
01:41:28 <DarkFox> win stick
01:44:35 <mm_freak> flammi: for the particular case of gtk2hs, reactive-banana is the better option
01:44:42 <akegalj> once i saw a program/library that can generate haskell function if given input output pairs?
01:52:47 <maxs_> mirsal: agda can do that
02:02:00 <ocharles> mm_freak: I *think* I have all the highlighting nonsense sorted out now
02:13:17 <mirsal> maxs_: ?
02:14:16 <mirsal> maxs_: ah, yeah, not getting bitten by nick autocompletion on a 1000+ users channel is an art :P
02:15:44 * hackagebot cabal-rpm 0.8.7 - RPM package creator for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.8.7 (JensPetersen)
02:15:47 * hackagebot science-constants 0.1.0.0 - Mathematical/physical/chemical constants  http://hackage.haskell.org/package/science-constants-0.1.0.0 (cbou)
02:20:46 <paullik> Hello, I implemented a line algorithm similat to Bresenham's, can you please review it? Code here: http://codereview.stackexchange.com/questions/38358/bresenham-like-line-algorithm
02:23:30 <monoidal> paullik: your code seems to be cut off, it ends with "where m" with no definition of m
02:25:04 <ocharles> paullik: getLinePoints has a chunk of duplication (you  map  over  getRange  regardless of the branch you take)
02:25:23 <ocharles> oh, my bad - you map over a different range
02:28:55 <paullik> oups, updating it right now
02:30:02 <paullik> monoidal, ocharles, updated, where m = getSlope f l
02:35:16 <ivanm> is there a source somewhere that actually defines the various fields typically found in haddock docs at the top of modules (stability, etc.)
02:37:14 <maxs_> mirsal: yeah, i just got back. agda does that
02:41:39 <escalz> maxs_: I think that you want to answer akegalj
02:48:01 <maxs_> akegalj: you might be looking for agda
02:48:08 <maxs_> escalz: yeah :P
03:02:14 <donri> ivanm: http://hackage.haskell.org/package/haddock-2.13.2.1/docs/Documentation-Haddock.html#t:HaddockModInfo
03:04:43 <ivanm> donri: ta
03:05:31 <ivanm> donri: doesn't really describe what the intended values mean though :s (e.g. how do you specify whether something is portable or not?)
03:06:01 <donri> ivanm: they're all free-form. you'll have to look at other packages for inspiration :P
03:06:25 <donri> it seems portability is usually taken to mean between compilers rather than platforms
03:06:36 <ivanm> yeah
03:06:49 <jerv> How can you create a data type in Haskell for the syntactic categories: Slist ::= [] | (Sexp . Slist)  , Sexp ::= Int | Slist?
03:07:19 <ivanm> jerv: what do you mean by "syntactic categories"?
03:07:54 <jerv> Basically just a type, set of instances
03:07:55 <ivanm> data SList = Empty_SList | SCons SExp SList; data SExp = SInt Int | SList SList
03:08:02 <ivanm> ^^ that what you after?
03:09:09 <jerv> yes, thank you
03:10:03 <ivanm> note at the end: there's a constructor called SList which then contains a value of type SList
03:10:16 <ivanm> (I couldn't think of a better name for the constructor off the top of my head :p)
03:20:52 * hackagebot network 2.4.2.2 - Low-level networking interface  http://hackage.haskell.org/package/network-2.4.2.2 (JohanTibell)
03:21:05 * ocharles donates $20 to haskell.org
03:25:53 * hackagebot hslua 0.3.10 - A Lua language interpreter embedding in Haskell  http://hackage.haskell.org/package/hslua-0.3.10 (OmerAgacan)
03:29:52 <awestroke> http://www.haskell.org/hoogle/?hoogle=%3C%3E why doesn't this find the Data.Monoid mappend alias?
03:30:53 * hackagebot simple-sql-parser 0.3.0 - A parser for SQL queries  http://hackage.haskell.org/package/simple-sql-parser-0.3.0 (JakeWheat)
03:30:55 * hackagebot reflection-extras 0.1.1.0 - Utilities for the reflection package  http://hackage.haskell.org/package/reflection-extras-0.1.1.0 (JonathanFischoff)
03:32:46 <donri> awestroke: index built from old base maybe?
03:32:54 <donri> <> is somewhat recent
03:32:58 <awestroke> ah
03:35:09 <donri> also yay, new hoogle deployed
03:35:52 <awestroke> what's new?
03:36:31 <merijn> awestroke: Style sheet, at least. Since that's what I noticed immediately :p
03:36:31 <donri> notably the theme, possibly the instant search feature
03:37:11 <jle`> good job neil
03:40:54 * hackagebot supervisor 0.1.1.0 - Control an internal monad execution for trace generation, backtrakcking, testing and other purposes  http://hackage.haskell.org/package/supervisor-0.1.1.0 (AlbertoCorona)
04:30:40 <jerv> when writing code to flatten a list, how do you test is the head is not a list?
04:31:35 <hpc> you don't; the type system checks for you
04:31:51 <hpc> > [[1, 2, 3], 4, [[5, 6], [7, 8]], 9]
04:31:53 <lambdabot>  No instance for (GHC.Show.Show t0)
04:31:53 <lambdabot>    arising from a use of `M123211870232992139324516.show_M1232118702329921393...
04:31:53 <lambdabot>  The type variable `t0' is ambiguous
04:31:53 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
04:31:53 <lambdabot>  Note: there are several potential instances:
04:32:21 <hpc> jerv: what is the type of the function you want to write?
04:33:03 <jerv> hpc: can you not write a function that flattens arbitrary nested lists? (without creating a data type)
04:33:23 <hpc> you can't; the type of "arbitrarily nested list" is not expressable in haskell
04:33:36 <hpc> you could do something like
04:34:20 <hpc> data RList a = Nil | Only a | Cons a (RList a)
04:34:36 <jerv> hpc: what is the "a" for?
04:34:40 <jfischoff> There is also deep'join http://okmij.org/ftp/Haskell/typecast.html#deep-join
04:34:41 <hpc> but then you lose out on the nice [1, 2, 3] kind of syntax
04:34:49 <hpc> "a" is the thing you are making a list of
04:35:05 <jerv> hpc: can you provide a small use-case for the data type?
04:35:10 <hpc> :t [True, False] -- it's what would normally go between the "[]"
04:35:11 <lambdabot> [Bool]
04:35:33 <hpc> hmm
04:35:57 <hpc> doh, that data type doesn't actually work
04:36:01 * hackagebot ini 0.1.1 - Quick and easy configuration files in the INI format.  http://hackage.haskell.org/package/ini-0.1.1 (ChrisDone)
04:36:36 <hpc> anyway, you want something so you can write something like
04:37:15 <Mortomes_> arbitrary nested lists are a tree-like datastructure
04:37:37 <hpc> better idea: do what Mortomes_ says ;)
04:37:44 * hpc has to leave anyway
04:38:03 <Mortomes_> Me too, family to drive to for new year :P
04:38:06 <hpc> but your flatten function is going to have a type that's something like
04:38:11 <hpc> flatten :: RList a -> [a]
04:38:45 <hpc> the hardest part is defining arbitrarily nested lists ;)
04:39:00 <donri> it can probably be done with type classes, a la the trick used by printf
04:40:10 <donri> i guess that's what deep'join does
04:40:13 <Mortomes_> data RList a = Leaf a | Node [RList a]      should do the trick?
04:41:12 <jfischoff> donri: yeah
04:41:14 <donri> although that's using overlapping instances
04:41:32 <donri> someone made something similar for unwrapping maybes without overlapping instances in here recently...
04:41:45 <Mortomes_> Oh right
04:42:10 <donri> http://lpaste.net/96545
04:42:37 <jfischoff> there are ways to get rid of overlapping instances in that case, but its not such a big deal because you are only making a few instances in one file.
04:43:01 <benmachine> in general you can't say "this type variable is not a list" so you can't easily stop the recursion
04:43:33 <benmachine> or actually maybe you can, hmm
04:43:45 <donri> benmachine: but you can say that it is a list of lists, and that's more specific than a list or an a
04:43:51 <benmachine> but basically who cares, I can't think of any use for deep-flatten
04:44:06 <donri> (and actually, with overlapping instances you can write type inequality)
04:44:28 <benmachine> yes but in my book overlapping instances "don't count" :P
04:44:33 <donri> also, lenses/uniplate
04:44:48 <benmachine> yeah, Typeable/Data could do it
04:44:57 <benmachine> actually
04:44:59 <benmachine> not sure
04:45:01 <benmachine> maybe.
04:45:06 <donri> > toListOf template [[[1,2],[3]]] :: [Int]
04:45:07 <lambdabot>  []
04:45:08 <benmachine> probably?
04:45:11 <donri> mhm
04:45:13 <benmachine> oh yeah
04:45:21 <jfischoff> well closed type families are coming. Supposedly they will alleviate the need for OverlappingInstances
04:45:25 <benmachine> > listify [[[3]]] :: [Integer]
04:45:26 <lambdabot>  Not in scope: `listify'
04:45:26 <lambdabot>  Perhaps you meant one of these:
04:45:26 <lambdabot>    `listOf' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
04:45:26 <lambdabot>    `listOf1' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
04:45:30 <benmachine> ff
04:45:31 <benmachine> whatever
04:45:44 <donri> > toListOf biplate [[[1,2],[3]]] :: [Int]
04:45:46 <lambdabot>  []
04:45:51 <donri> duno :D
04:46:08 <bennofs> > toListOf template ([[[1,2], [3]]] :: [[[Int]]]) :: [Int]
04:46:10 <lambdabot>  [1,2,3]
04:46:24 <bennofs> > toListOf template ([[[1,2], [3]]]) :: [Integer]
04:46:25 <lambdabot>  [1,2,3]
04:46:48 <jfischoff> :o
04:46:51 <donri> oic
04:47:14 <benmachine> Data.Generics.listify (const True) also works
04:47:16 <donri> > universeOf template [[[1,2],[3]]] :: [Int]
04:47:17 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
04:47:18 <lambdabot>              with actual type `[[[t0]]]'
04:47:23 <donri> heh
04:47:36 <bennofs> @ty universeOf
04:47:37 <lambdabot> Getting [a] a a -> a -> [a]
04:47:59 <bennofs> > universeOf traverse [1,2,3,4]
04:48:00 <lambdabot>  Occurs check: cannot construct the infinite type: t0 = [t0]
04:48:01 <lambdabot>  Expected type: Control.Lens.Getter.Getting [[t0]] [t0] [t0]
04:48:01 <lambdabot>    Actual type: ([t0]
04:48:01 <lambdabot>                  -> Control.Lens.Internal.Getter.Accessor [[t0]] [t0])
04:48:01 <lambdabot>                 -> [[t0]] -> Control.Lens.Internal.Getter.Accessor [[t0]] [[t0]]
04:48:07 <donri> although uniplate generics are a bit too powerful here, they'll flatten anything
04:48:32 <donri> > toListOf [[(1::Int,2,3)]] :: [Int]
04:48:34 <lambdabot>  Couldn't match expected type `[GHC.Types.Int]'
04:48:34 <lambdabot>              with actual type `s0 -> [a0]'Couldn't match type `[[(GHC.Types.I...
04:48:34 <lambdabot>                with `(a0
04:48:34 <lambdabot>                       -> Control.Lens.Internal.Getter.Accessor
04:48:34 <lambdabot>                            (Data.Monoid.Endo [a0]) a0)
04:48:36 <donri> > toListOf template [[(1::Int,2,3)]] :: [Int]
04:48:37 <lambdabot>  [1]
04:48:43 <donri> uh right
04:48:45 <donri> but yeah
04:52:20 <donri> > [[('h',Just 'i')],[(' ',Nothing),('t',Just 'h'),('e',Just 'r'),('e',Nothing)]] ^.. template :: String
04:52:21 <lambdabot>  "hi there"
04:53:16 <benmachine> :t template
04:53:17 <lambdabot> (Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
04:56:03 * hackagebot ini 0.2.0 - Quick and easy configuration files in the INI format.  http://hackage.haskell.org/package/ini-0.2.0 (ChrisDone)
05:30:49 <awestroke> how do I install Data.Text on my system?
05:31:26 <jfischoff> cabal install text
05:31:55 <merijn> awestroke: It should've come installed with the Haskell Platform if you installed that
05:32:09 <merijn> Otherwise you will have to cabal install it
05:33:06 <awestroke> merijn: ah. Didn't have that package. thanks
05:37:56 <latermuse> why isnt there a mod_haskell for apache?
05:40:34 <merijn> latermuse: Because no one felt compelled to write it?
05:41:39 <fread2282> roconnor_: ping
05:51:08 <BrunoSou_> Can anyone help/explain to me why neither getChar or hWaitForInput   actually wait and just return automatically? http://lpaste.net/97788        (PS:novice here)
05:55:27 <xnyhps> BrunoSousa: Uh, from main you never reach the second alternative of processInput, so it will always just return [].
05:57:02 <monoidal> BrunoSousa: what xnyhps said, also you need to return xs instead of return [] in line 16
05:57:36 <BrunoSousa> xnyhps: damn you are right! it was left there from a previous try and forgot to look at that, now it makes sense… sorry for the dumb question, thank you!!!
05:57:56 <BrunoSousa> monoidal: thanks… also overlooked that… think I need some coffee ...
05:59:28 <monoidal> BrunoSousa: also, you shouldn't name the pattern in case 'otherwise'. To match anything, use _. otherwise is used in guards.
06:01:03 <ski> shachaf : Lewis's strict implication/conditional
06:01:44 <ski> Cale : fwiw, "dependent variables" basically use dynamic scoping
06:04:45 <BrunoSousa> thanks guys, I was able to make it work!!
06:10:05 <_shad_> can anybody explain precise meaning of <- in do block?
06:11:02 <sipa> @google do notation haskell syntactic sugar for
06:11:03 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Syntactic_sugar
06:11:03 <lambdabot> Title: Haskell/Syntactic sugar - Wikibooks, open books for an open world
06:12:24 <escalz> _shad_: you might be interested by: http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/#io-trick-explained
06:14:24 <_shad_> sipa: thank you. I have read some tutorial with explanation about do notation but they skiped <-
06:14:46 <sipa> bad tutorial!
06:20:31 <Drezil> o/ is there a HopenGL-IRC-Channel?
06:20:44 <Drezil> or does someone know the ways around here?
06:22:54 <Redz> Drezil: maybe #haskell-game ?
06:23:28 <Drezil> ill try that. thanks
06:26:36 <Redz> people say, that oop makes programs flexible. But is oop more flexible than a functional approach?
06:27:04 <merijn> Redz: Error: Ill defined question
06:29:01 <merijn> Redz: I can't seriously answer your question, given that I'm not quite sure what you're asking. But the better I become at programming, the more I believe OOP (in the conventional Java/C# sense) is an absolutely terrible idea that has costs as much programmer productivityas the invention of the null pointer
06:29:17 <merijn> OOP in the smalltakl/erlang actor sense is a pretty great idea, though
06:29:38 <pharaun> merijn: i have trouble with that sometime, sometime i want mixed collection and that's a pain in haskell-land
06:30:17 <Drezil> pharaun: ? why is that a pain?
06:30:17 <pharaun> but overall i generally prefer the functional approach, i've found most of the time it is nicer and just a better approach usually
06:30:30 <merijn> pharaun: Usually I can solve that with either a sumtype or I didn't need the collection at all
06:31:10 <pharaun> merijn: yeah sum-type is the normal approach i take and that works but it proves painful when i try to figure out how to provide an api/way in which you can feed it a list of parameterized records
06:31:12 <merijn> pharaun: Do you remember a (semi-concrete) example where you wanted a mixed collection?
06:31:14 * hackagebot cassava 0.3.0.0 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.3.0.0 (JohanTibell)
06:31:16 <pharaun> fur customized action
06:31:42 <Redz> webpages of scala and m# told me, that oop is flexible and i was really annoyed about this.
06:31:59 <pharaun> merijn: yeah, basically i was making a libary that would take a parameterized record that would yield up a list of url to fetch, and the library would take care of the fetching, caching, etc and feed the result back
06:32:03 <merijn> pharaun: With parameterised records you usually just want to have records of higher order functions that do what you want
06:32:20 <pharaun> and my main issue was some websites needed cross-page states
06:32:40 <pharaun> hence parameterised records and i thought it would be nicer to just give the api a "list" of sites to parse
06:32:43 <merijn> pharaun: You mean like you have a record of "Record a -> IO [URL]" or something?
06:32:45 <pharaun> hence wanting a mixed collection.
06:32:50 <pharaun> merijn: pretty much
06:33:18 <pharaun> now a sum type would work but not from a library pov because the record had a type parameter...
06:33:42 <merijn> pharaun: Wouldn't it have been possible to have you API work with "IO [URL]" you could even have shared state between multiple records, by passing an MVar to all actions
06:33:46 <pharaun> and i wanted to make it so the library user could just take that type and define their own and feed it in.
06:33:52 <zett_zelett1> Cats are awesome.
06:34:04 <pharaun> merijn: that is honestly what i will probably end up doing.
06:34:19 <pharaun> i'll probably retain the records but shuffle the api around a bit and employ some MVars
06:35:00 <pharaun> just from an initial sketch implementation, being able to just feed it a mixed list would have been nice :)
06:35:08 <merijn> If a user needs internal state between requests that's fine, the "IO [URL]" lets your user share MVars between requests
06:35:33 <pharaun> i was trying to reduce the amount of IO usage but yeah
06:35:39 <pharaun> i'm probably going to go down that road.
06:36:08 <merijn> pharaun: I think many people somehow over do it on reducing IO
06:36:19 <merijn> pharaun: IO isn't necessarily bad
06:36:24 <pharaun> i know :)
06:36:50 <merijn> Reducing IO for no reason other than "I think I should" seems silly if it makes your live hard :p
06:36:50 <pharaun> i just tend to like to try to keep as much of my code out of IO so i can quicktest it easier and have a easier time with other testing
06:37:16 <pharaun> and i just wish i could break up IO more, like having network io, vs... but *shrugs*
06:37:27 <pharaun> its mostly to idiot proof things as much for *me* :)
06:37:35 <pharaun> so i'm not tempted to do a quick n' dirty hack
06:38:28 <merijn> "network io" <- you're not alone
06:38:44 <merijn> Hence so many people working on composable/fine-grained effects :P
06:39:09 <pharaun> hehe at least there's some work there :)
06:39:42 <pharaun> but yeah i'm probably going to go down the MVar route, i need to adjust things anyway to make this thing run in parallel with one thread for each site anyway
06:41:10 <merijn> pharaun: Have you looked at the async library?
06:41:28 <pharaun> ive heard, haven't looked yet don't think
06:41:32 <pharaun> looking
06:42:10 <pharaun> oh thats nice
06:42:23 <pharaun> the forced dealing with exception on thread dying and tree of threads
06:45:15 <xoip> ._.
06:45:59 <pharaun> ?
06:47:24 <merijn> pharaun: I think hacking together your own stuff as learning experience is good. But if you just want things to work using async might be the way to go :)
06:48:35 <pharaun> yeah ive done the tree threads myself and etc before, i think imma gonna use this
07:01:45 <xoip> Huh. This language is pretty neat.
07:02:50 <udevd> @djinn a->a
07:02:50 <lambdabot> f a = a
07:04:20 <udevd> @djinn a->b
07:04:21 <lambdabot> -- f cannot be realized.
07:04:53 <fread2282> @help djinn
07:04:53 <lambdabot> djinn <type>.
07:04:53 <lambdabot> Generates Haskell code from a type.
07:04:53 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
07:05:17 <fread2282> @dijinn a -> Int
07:05:17 <lambdabot> Error: Undefined type Int
07:16:20 * hackagebot diagrams-haddock 0.2.1.5 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.1.5 (BrentYorgey)
07:16:27 <nooodl> what does the "unsafe" in Control.Wire.Unsafe.Event mean?
07:19:18 <geekosaur> I think if you have access to the event internals then you have the ability to break the FRP abstraction?
07:27:01 <Dodek> hey, so i wanted to parse some command line arguments, but the haskell wiki lists over a dozen of choices for argument parsing library
07:27:10 <Dodek> would you recommend any of them?
07:27:41 <Clint> optparse-applicative and cmdargs are the popular ones
07:28:06 <Dodek> okay, thanks
07:30:26 <bizarrefish> Ello, all
07:31:21 * hackagebot debian 3.80.1 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.80.1 (DavidFox)
07:31:53 <Komier> Afternoon!
07:34:03 <JuanDaugherty> yello Komier
07:34:44 <Dodek> optparse looks cool
07:45:59 <bizarrefish> I'm having an issue writing a function which transforms some members of a "record", which all satisfy a type constraint, to produce a  new record. Here's what I'm looking at: http://lpaste.net/97795
07:48:18 <c_wraith> bizarrefish: you need a rank 2 type to do what you want
07:49:24 <c_wraith> bizarrefish: if you add {-# LANGUAGE RankNTypes #-} to the top of the file, then change the signature of modFirstQuantities to (forall u. Uppable u => u -> u) -> Quantities -> Quantities
07:49:46 <bizarrefish> c_wraith: Ahh, that's what forall is about! :)
07:49:49 <c_wraith> bizarrefish: that'll work.  The thing that change does is require that the function passed in be polymorphic
07:49:52 <bizarrefish> So basically, multimethods for haskell.
07:50:23 <c_wraith> bizarrefish: no, not exactly - it's just about who gets to choose the type u..  the caller or the callee
07:50:37 <ski> with `modFirstQuantities :: forall u. Uppable u => (u -> u) -> Quantities -> Quantities', the *caller* of `modFirstQuantities' gets to decide what `u' should be (as long as its a type in class `Uppable')
07:51:12 <c_wraith> bizarrefish: the way you currently have it, the caller gets to choose the type u.  That means the function being called can't assume anything about u, except that it's an instance of Uppable.
07:51:18 <ski> with modFirstQuantities :: (forall u. Uppable u => u -> u) -> Quantities -> Quantities' the *callee* (`modFirstQuantities' itself) gets to decide what `u' should be (as long as its a type in class `Uppable')
07:51:29 * hackagebot zmidi-core 0.7.0 - Read and write MIDI files.  http://hackage.haskell.org/package/zmidi-core-0.7.0 (StephenTetley)
07:51:37 <c_wraith> woo, stereo answers! :)
07:51:43 <ski> in the former case, `modFirstQuantities' would be a (bounded) polymorphic function
07:52:16 <ski> in the latter case `modFirstQuantities' is not polymorphic, but *accepts* a polymorphic function as argument
07:52:39 <ski> it's a "rank-2" function
07:53:03 <bizarrefish> I am understanding! :) So, is there no way this kind of behaviour can be expressed in haskell98?
07:53:55 <c_wraith> There isn't.  RankNTypes is one of the extensions that adds something new, rather than just new syntax
07:54:07 <ski> i suppose you wanted to (at least) be able to pass the (polymorphic) function `up :: forall o. Uppable o => o -> o' as argument to `modFirstQuantities'
07:54:53 <bizarrefish> ski: That's what I wanted to do, yeah. Pass something which would dispatch based on what it was passed.
07:54:56 <ski> bizarrefish : "that's what forall is about" -- rather, it's about the *placement* of the `forall'
07:55:56 <c_wraith> bizarrefish: the reason it's not in Haskell98 is that there's no way to infer rank-n types.  Haskell98 stuck with what could be inferred.  (And then messed that up in some cases with type classes)
07:56:10 * ski . o O ( "The Place of the word of the // Lord must be clearly understood" )
07:56:43 <ski> (actually istr you can actually infer rank-2 (but not higher ranked) ?)
07:56:52 <c_wraith> bizarrefish: also, rank-n types mess up principle typing - there's no longer a single correct type for an expression.  That's why they aren't inferrable
07:57:00 <rawtass> Please have a look at my problem: http://lpaste.net/797796, any tips on how I can print my ascii values or am I on the wrong track?
07:57:55 <c_wraith> is chrisdone still the maintainer of lpaste?  It really should be fixed to handle accidental trailing commas correctly
07:58:11 <JuanDaugherty> rawtass, nothing in that pastebin
07:58:26 <c_wraith> it's got an extra digit, I think
07:58:34 <rawtass> lpaste.net/97796
07:58:34 <c_wraith> I think paste numbers are currently 5 digits
07:58:37 <c_wraith> yeah
07:58:40 <rawtass> sorry...
07:59:18 <c_wraith> if you want ascii values, use unpack from BL, instead of C
07:59:35 <c_wraith> the types of the two unpacks are different.
07:59:43 <rawtass> that gives me a list of numbers
07:59:52 <c_wraith> Yes, the ascii values
08:00:18 <c_wraith> the file you're reading is binary, not text
08:00:19 <geekosaur> someone's tossing terms around very loosely. they think ascii means string or something
08:00:33 <geekosaur> (ascii's not even a thing any more, folks)
08:00:43 <rawtass> ok, I mean human readable
08:00:56 <c_wraith> rawtass: the file isn't text.  it isn't human-readable
08:01:00 <rawtass> I see lots of 64 for example, does this represent a letter?
08:01:39 <bennofs> > chr 64
08:01:40 <lambdabot>  '@'
08:01:41 <bizarrefish> c_wraith: ski Thanks guys, I actually get how Rank-n types are actually useful now. I've seen it mentioned; looks like I should have put it higher up in the "to-learn" list.
08:01:55 <c_wraith> bizarrefish: eh.  You learn it when you need to learn it.  It's finally time. :)
08:01:57 <zammy> [New Year Festive Notice] About 10 minutes to go until new year hits Malaysia, bits of China, and finishes sweeping through Oz.  Cast greetings out in #freenode-newyears!
08:02:57 <geekosaur> rawtass, I'm not sure why you think that should be humanly readable. \195 represents a non-printable character
08:03:02 <geekosaur> as does \241, etc.
08:05:29 <rawtass> yes, but I see when I did BL.unpack I get the list of integers. Probably I can use Data.Char and 'chr' to convert and view it..
08:05:40 <Clint> maybe it's in VISCII
08:05:41 <geekosaur> and you will get the other one
08:05:55 <geekosaur> they are not printable characters
08:06:29 <rawtass> http://www.seg.org/documents/10161/77915/seg_y_rev1.pdf This is the file format I am parsing. It should have text data in the first 3200 bytes as far as I understand.
08:07:45 <ski> (c_wraith : .. which is why i use `<...>' per RFC 1738,2396,3386)
08:07:52 <bennofs> rawtass: maybe check with 'cat' or something if it's really text?
08:08:14 <c_wraith> are the contents of the file in a language that historically used some horrible binary encoding, like windows code pages?
08:08:57 <geekosaur> ugggggh
08:09:06 * geekosaur just noticed something in that spec and checked...
08:09:11 <geekosaur> ...it's EBCDIC
08:09:26 <tovarish> EBCDIC? What is it?
08:09:29 <merijn> geekosaur: Wait, what?
08:09:32 <c_wraith> oh, ouch.
08:09:33 <geekosaur> IBM mainframe encoding
08:09:36 <merijn> What year is this?!?
08:09:39 <c_wraith> 1975
08:09:41 <zammy>  /join #freenode-newyears
08:09:42 <rawtass> yes, it's an ebcdic header... But not sure what that means :D
08:09:46 <c_wraith> According to the spec
08:09:53 <JuanDaugherty> extended binary coded decimal interchange code
08:09:54 <geekosaur> it means you can't read it sensibly
08:09:58 <c_wraith> rawtass: EBCDIC means "the thing that isn't ascii"
08:10:18 <c_wraith> rawtass: EBCDIC was a character encoding standard that predated ascii
08:10:22 <rawtass> ok, so this is not straight forward then..
08:10:30 <geekosaur> no, no it is not
08:10:32 <JuanDaugherty> it was the dominant encoding till the 80s
08:10:38 <Clint> no one ever called EBCDIC straightforward
08:11:03 <rawtass> ;-<
08:11:04 <geekosaur> and just to make things more interesting, there is not a single EBCDIC; it was defined more by what printer chains were available, somewhat like Windows code pages
08:11:21 <JuanDaugherty> pronounced "ebsidick"
08:12:14 <JuanDaugherty> geekosaur, that's more or less false
08:12:24 * JuanDaugherty was there
08:14:10 <magneticduck> hey guys sorry for asking such a silly question but I don't really have many other options at the moment-- is there some sort of haskell super-package in the arch linux repos?
08:14:12 * JuanDaugherty notes the connection to an earlier discussion on truth concepts.
08:14:16 <magneticduck> what's that haskell super-package called again..
08:14:20 <magneticduck> like the haskell framework or something?
08:14:29 <Komier> platform
08:14:32 <JuanDaugherty> HP haskell platform
08:14:33 <magneticduck> wonderful thanks
08:14:52 <geekosaur> haskell-platform but I think the current one is in an overlay or something?
08:14:53 <rawtass> ok.. Good to know. Maybe I can go search for some existing ebcdic to ascii code..
08:15:19 <JuanDaugherty> you'll find a bunch
08:15:51 <bennofs> When I used arch linux, I only installed ghc with the package manager (and cabal, but only to bootstrap installing cabal from hackage)
08:16:09 <magneticduck> yeah that's strange, no pacsearch results for "haskell platform"
08:16:16 <bennofs> I generally found that the versions in the repos where too outdated for me
08:16:23 <magneticduck> just things like GHC and a handful of haskell related libraries
08:16:30 <tovarish> yes, haskell platform has disappeared from ubuntu too
08:16:58 <magneticduck> hey guys, real fast favour, could you shoot me the link to the haskell platform on the website?
08:17:20 <magneticduck> something I could wget =P
08:17:28 <magneticduck> (need it to install xmonad it seems)
08:17:41 <tovarish> use TWM to run a decent browser
08:17:51 <tovarish> if you have X you should have TWM
08:17:52 <magneticduck> oh wait maybe not
08:17:55 <JuanDaugherty>  prolly better to do xmonad alone if that's all u want
08:17:57 <Komier> did you try searching haskell-platform
08:18:03 <magneticduck> Komier: that too
08:18:07 <Komier> that's the only way it appears in package manage in Mint
08:18:11 <magneticduck> oh well, looks like xmonad is installing alright without any haskell platform
08:18:16 <JuanDaugherty> it'll likely be packaged for whatever platform
08:18:29 <geekosaur> if you have ghc and cabal-install (shell "cabal" command) installed, you can use the cabal file at https://github.com/haskell/haskell-platform/blob/master/haskell-platform.cabal to install the rest
08:18:39 <magneticduck> thanks
08:19:09 <c_wraith> hmm.  icu apparently has some EBCDIC support
08:19:19 <c_wraith> though that probably varies by installed version of icu
08:19:30 <c_wraith> but it means that at least sometimes, you could do the conversion with text-icu
08:23:31 <rawtass> c_wraith: ok, thanks
08:24:30 <ski> JuanDaugherty : "truth concepts" ?
08:25:37 <JuanDaugherty> yeah Cale and augur were goin' on about ZFC, Girard and what not last night.
08:25:44 <JuanDaugherty> in that context
08:26:33 * hackagebot dynamic-cabal 0.3 - dynamic-cabal  http://hackage.haskell.org/package/dynamic-cabal-0.3 (BennoFuenfstueck)
08:27:18 <JuanDaugherty> model theoretic truth vs. ludics, judgments and other stuff, not to uncork the genie agin
08:27:38 <Komier> can you turn off all the messages of people signing in and out?
08:27:53 <JuanDaugherty> sure in your client
08:27:53 <tovarish> Komier, it's an option of your client
08:28:14 <Komier> ok ta i'll take a look for it, hard to follow conversations
08:30:06 <ski> JuanDaugherty : found it, ty
08:30:18 <JuanDaugherty> ski, np
08:33:02 <Komier> aha think i found it
08:33:05 <Komier> much better :)
08:33:43 <udevd> @djinn a->[a]
08:33:44 <lambdabot> Error: Undefined type []
08:34:05 <kqr> udevd, (:[])
08:34:40 <udevd> kqr: i wanted to check ambiguity :P
08:34:46 <kqr> ah
08:34:47 <udevd> and what would it return
08:34:52 <kqr> well
08:35:25 <kqr> a list of 0 or more copies of the argument
08:35:27 <kqr> i assume
08:36:04 <ski> Komier : usually parts&joins aren't quite as noisy, i think
08:36:13 <udevd> @djinn a->a->a
08:36:14 <lambdabot> f _ a = a
08:37:12 <Komier> ski: aye, much easier to follow this channel with them turned off though :)
08:37:25 <ski> mayhaps
08:37:35 * ski has never bothered to turn such off
08:37:39 <kqr> i turn parts and joins off in every channel. weechat makes it convenient enough to show them again should i need them
08:37:48 <ski> @djinn a -> (a -> b -> b) -> b -> b
08:37:48 <lambdabot> f a b = b a
08:39:05 <ski> (which is basically `(:[])' for you)
08:39:07 <osa1> is there a way to load a hs file that hs TH quotes to ghci?
08:40:07 <geekosaur> I think you have to use something like zeroth to preprocess it
08:40:28 <osa1> what is zeroth?
08:40:45 <geekosaur> @hackage zeroth
08:40:46 <lambdabot> http://hackage.haskell.org/package/zeroth
08:40:47 <osa1> omg, runhaskell also doesn't work??
08:41:10 <geekosaur> as I understand it, the bytecode backend is not reentrant so anything using it can't also use TH?
08:41:43 <osa1> too bad
08:43:08 <jacco> cabal question: if I have two versions of the same package installed (in my case Cabal-1.16.0 and Cabal-1.18.1.2) it seems that 1.16 is favored over 1.18 by the dependency solver, why not the newest?
08:43:41 <scooty-puff> i'm having trouble sorting out when https://ghc.haskell.org/trac/ghc/ticket/3990 was fixed - i'm seeing the problem in 7.6.2
08:44:14 <bennofs> jacco: if you use another package that depends on Cabal 1.16 (like the GHC API), then you're forced to use the older version
08:44:24 <Tekmo__> jacco: Perhaps because another package you depend on is incompatible with the newer version
08:45:09 <scooty-puff> http://lpaste.net/97797
08:45:27 <sm> jacco: to find out which, adding --constraint 'Cabal==1.18.*' --dry may help
08:45:34 <jacco> that makes sense. But if that were not the case it would take the newest version right?
08:46:41 * sm thinks cabal has multiple additional special cases for version selection for dark cabal reasons
08:47:40 <jacco> the strange thing is that this package I am trying to install has the constraint: Cabal >= 1.8.0.6   , and then depends on the 1.16 version. When I change it to Cabal >= 1.18 it works
08:48:12 <jacco> so I am assuming that there are no other (conflicting) dependencies on Cabal-1.16.0
08:48:57 <sm> I think cabal has some preferred versions which it'll use instead of the latest, if given the choice
08:49:48 <osa1> geekosaur: hmm, my code with TH quotes now loaded into ghci. I guess the problem was I had not have Quotes extension enabled
08:50:03 <geekosaur> interesting
08:50:38 <osa1> cabal run doesn't work with cabal sandbox?
09:01:37 * hackagebot errors 1.4.5 - Simplified error-handling  http://hackage.haskell.org/package/errors-1.4.5 (GabrielGonzalez)
09:08:17 <frohe> Let's say that I have a class declaration "class (Super a) => Sub a where ..." and a data type "data Foo = Bar". I want to make Foo an instance of Sub. Do I have to make it first an instance of Sup ("instance Eq Foo where ...")?
09:09:00 <bennofs> frohe: yes, the type has to be an instance of all superclasses to be an instance of a subclass
09:09:17 <frohe> instance Super Foo where *
09:09:27 <frohe> bennofs: thanks
09:09:29 <Clint> Tekmo__: thanks
09:10:43 <Lethalman> frohe, read (Super a) => Sub a as Sub a requires Super a
09:10:57 <Tekmo__> Clint: You're welcome!
09:11:01 <Lethalman> it's about requirements, not inheritance as in OO
09:11:08 <frohe> what's the real benifit of using subclassing?
09:11:18 <frohe> benefit *
09:11:35 <Tekmo__> frohe: Mainly to simplify constraints
09:11:45 <Lethalman> frohe, you may want to deal with more generics objects when possible
09:13:32 <Tekmo__> frohe: If you have `Sub a` as a constraint, then you don't need to also specify `Super a`
09:14:04 <Tekmo__> frohe: And yes, you would have to make `Foo` an instance of `Super` to make it an instance of `Sub`
09:14:32 <Tekmo__> frohe: However, I would caution against using custom type classes in your code
09:16:52 <frohe> Tekmo__: I'm reading LYAH but it doesn't say much about subclassing. Why this caution?
09:17:14 <Tekmo__> frohe: Many things that you might consider using type classes for are simpler using records
09:17:29 <Tekmo__> frohe: The reason is that type classes are not first class values that you can manipulate within the language, but records are
09:17:45 <Tekmo__> frohe: Here's a simple article that motivates this: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
09:21:40 * hackagebot hsimport 0.2.2 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.2 (DanielTrstenjak)
09:22:44 <BeardedCoder> What would be the proper way to have multiple Shows for my datatypes. Building a command line app that needs pretty output, but I'd like to keep the derived Show for debugging. Should I look into GeneralizedNewtypeDeriving and newtype?
09:23:08 <Elision> my friend tells me that the Error monad has some kind of hairiness
09:23:09 <bennofs> BeardedCoder: don't use Show for pretty output, simple
09:23:42 <BeardedCoder> bennofs: k, that makes this simple =)
09:23:46 <Tekmo__> BeardedCoder: You can just define functions direclty
09:23:57 <Tekmo__> BeardedCoder: There is no reason you have to use the `Show` type class as an intermediate
09:24:06 <bennofs> BeardedCoder: Write a specialized method for your pretty priniting. Using show for pretty printing is not a good idea, for example, consider what happens if you use show [a list of pretty-printable objects]
09:24:08 <Elision> and that there are nicer ways to do error handling but isn't sure what they are
09:24:09 <Tekmo__> BeardedCoder: It's just there as a useful default
09:24:29 <frohe> Tekmo__: Thanks, I'll read the article. By the way, if the type of a function is something like "Sub a => a", can I use Super functions on values of a?
09:24:31 <bennofs> BeardedCoder: Then you will get haskell syntax and pretty printed output mixed. Doesn't look very well :)
09:24:35 <Elision> what other options are there
09:24:38 <BeardedCoder> Tekmo__: bennofs: Ty, sounds good
09:24:39 <Tekmo__> frohe: Yes
09:25:18 <roconnor_> Elision: What's wrong with the Error monad?
09:25:37 <Elision> I don't know?
09:25:38 <Tekmo__> Elision: See `ErrorT`/`EitherT`/
09:25:57 <krzysz00> Is there a haskell function for iterated compositon? That is, a `c :: (Integral b) => (a -> a) -> b -> (a -> a)` such that `c f 2 = f . f`, `c f 3 = f . f . f` ...?
09:26:00 <Tekmo__> Elision: Also `Maybe`/`MaybeT`/`Either`
09:26:11 <roconnor_> Elision: you can use the "Either" monad to get rid of the questionable contraint on the exception type if you need.
09:26:28 <Elision> hmm okay
09:26:45 <monoidal> krzysz00: iterate f !! n
09:26:47 <bergey> When using `cabal repl`, I get the error "cannot satisfy -package-id diagrams-core-1.0-4179513f8ce0c5e74b14e646055f69c9".  Can someone explain what this means or how to debug it?
09:26:54 <monoidal> krzysz00: Int only, though
09:26:58 <bergey> Full output: http://lpaste.net/97799
09:27:29 <bennofs> bergey: try to re-run cabal configure
09:27:52 <Tekmo__> :t iterate
09:27:53 <lambdabot> (a -> a) -> a -> [a]
09:28:04 <Tekmo__> monoidal: Almost
09:28:09 <Tekmo__> monoidal: You need to pass along the `a`
09:28:16 <bergey> bennofs: That worked, thanks!  Is cabal just looking for a prior compilation of diagrams-core?
09:28:23 <Komier> :t iterate
09:28:24 <lambdabot> (a -> a) -> a -> [a]
09:28:30 <Komier> oops wrong box
09:28:57 <roconnor_> appEndo (scale n (Endo f))
09:28:59 <Tekmo__> \a -> iterate f a !! n
09:29:03 <krzysz00> Thanks, monoidal!
09:29:07 <bennofs> bergey: yes, that's why the package id is included in the output (the "4179513f8ce0c5e74b14e646055f69c9" part)
09:29:33 <bergey> bennofs: OK.  Thanks.
09:29:35 <roconnor_> ... is there no indian multiplication for monoids?
09:30:37 <monoidal> roconnor_: not in standard library (shame)
09:31:41 * hackagebot cruncher-types 1.0.0 - Request and Response types for Eval.so's API  http://hackage.haskell.org/package/cruncher-types-1.0.0 (RickyElrod)
09:37:14 <Komier> Apologies if I'm being a bit dense... but what is the practical difference, in terms of usage between pattern matching and guards?  On the surface (to me anyway) they appear to do the same thing.
09:38:06 <roconnor_> Komier: gaurds cannot bind varables
09:38:23 <roconnor_> Komier: guards can use variables from a where clause.
09:38:28 <S11001001> Komier: extracts from pattern matching can reveal types in interesting and useful ways that you cannot get from invoking record extraction functions
09:38:57 <Tekmo__> Komier: To expand on roconnor_'s point, with a guard you would have to do something like: | isJust m = ... (fromJust m)
09:39:12 <Tekmo__> Komier: With a pattern match you would do: case x of Just a -> ... a
09:39:38 <Tekmo__> Komier: The pattern match is better because there is no chance that you accidentally access the bound variable on the wrong branch
09:39:56 <Tekmo__> Komier: If you go the guard route and you change the condition then you have the potential for a runtime error due to the `fromJust`
09:40:16 <Tekmo__> Komier: Also, I think pattern matches are more efficient
09:40:19 <Komier> and pattern matching works efficiently, because the right hand side of the assignment operator isn't evaluated unless the left hand side is true?
09:40:25 <roconnor_> That said there are now pattern guards, which are a combination of a pattern match and a guard.
09:40:43 <Tekmo__> Komier: Pattern matching is almost always preferable
09:40:47 <Tekmo__> Komier: T
09:41:34 <Tekmo__> Komier: Unlike most languages, Haskell does not rely heavily on booleans and if statements
09:41:41 <roconnor_> Komier: yes, the RHS isn't evaluated unless the pattern matches ... in most implementations. ^_^
09:42:34 <Komier> thanks guys, much appreciated.  Now you've explained it the difference seems obvious int eh examples I have in front of me.
09:42:53 <roconnor_> Komier: people around here often consider the use of the if statement as harmful.
09:43:29 <roconnor_> Komier: and that critisim extends to guards, which are glorified if statements.
09:44:12 <carter> i'm looking into using c2hs for the first time and i'm like "WOAHHHH, this is GREAT"
09:44:18 <Saizan> i wouldn't blame if statements
09:44:23 <d3lxa> question: often I have a type error because I misuse some variables, the error is on the definition (which is correct) but I would like to know where did GHC infer the type, is that possible? any idea?
09:44:27 <Komier> That's one of the things I am having the most difficulty doing.  I understand it intellectually, but switching my thinking away from it is difficult.
09:44:28 <upoo> roconnor_: But they are still useful right, as exactly what their name describes, a guard around the right hand side?
09:44:30 <Saizan> it all depends on which predicate you are checking
09:45:20 <roconnor_> upoo: they should be avoided if practical.
09:45:31 <Tekmo__> Komier: One thing that helps is to just write something the way you are normally accustomed to and then ask others for a code review.  That's usually the easiest way to learn Haskell idioms
09:45:54 <roconnor_> upoo: but sometimes they are necessary.
09:45:57 <osa1> I want to use modified version of a package in my cabal sandbox, how can I point cabal sandbox that package instead of the original package from hackage?
09:46:22 <upoo> roconnor_: I guess they really just are sugar in a way
09:47:03 <roconnor_> upoo: certainly use a guard over using an if statement.
09:47:44 <roconnor_> upoo: I mean that the use of guards/if statements should be minimized in the first place.
09:48:26 <Komier> Tekmo__: I'm only a hobby programmer... messed around with python, C and VBA to get things done at work or home.  This is the first time I've sat down and really tried to learn a language properly.  Hopefully I'll be at that stage soon where I can paste a few bits and ask people to review them.
09:48:55 <carter> d3lxa: i'm not sure if i understand your question, but one way of figuring out where the type error happens is to give every top level function a type, as a way of shrinking where the type error will happen
09:48:59 <roconnor_> often the use of guards can be replaced by chaning the input's data structure.
09:49:02 <carter> which is also good engineering
09:49:05 <carter> Tekmo__: yo!
09:49:07 <carter> how're you doing?
09:49:19 <upoo> roconnor_: TBH, i never thought about guards like that (Bad smell), but I am glad you mentioned it. I will notice the next time I have to use them
09:50:05 <Tekmo__> carter: Great!  How about you?
09:50:35 <Tekmo__> Komier: My advice is the best way to learn is to try to program something and not worry about it being perfect
09:50:58 <Tekmo__> Komier: The reason why is that Haskell has a really high potential for nice abstractions, so if you keep trying to find the perfect abstraction it is a really deep rabbit hole
09:51:35 <d3lxa> carter: ok I mean in a do-block, how would you give types for the variables? because it's local, not top-level defined
09:51:50 <Tekmo__> d3lxa: You can give types for the statement that binds the variable
09:52:03 <Tekmo__> d3lxa: i.e: `x <- readLn :: IO Int`
09:52:34 <moop> :t on
09:52:35 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
09:52:40 <navaati1> hi
09:52:42 <moop> someone explain on pls
09:52:46 <saml> okay
09:53:02 <saml> on takes a function. and function. and value. and value.
09:53:02 <Tekmo__> :t (==) `on` fst
09:53:03 <lambdabot> Eq b => (b, b1) -> (b, b1) -> Bool
09:53:19 <saml> b -> b -> c
09:53:22 <saml> that's binary operation
09:53:29 <Tekmo__> moop: For example, (==) `on` fst is a function that compares tuple for equality on their first field
09:53:35 <navaati1> i'm defining my own datatype, containing a monad stack, propagating instances for Monad, Functor, MonadState, etc. Nothing unusual.
09:53:41 <saml> it looks like it lifts binary operation as monad
09:54:20 <navaati1> now, i want to use lens' zoom on it, and i thought it would automatically work as it's a MonadState, but it does not
09:54:36 <saml> let's say you have x and y. and you want to do   x + y.  but not on x and y but transformed x' and y' where transformation function is f.
09:54:38 <Tekmo__> navaati1: You have to a little bit more
09:54:41 <saml> so you wanna do   f x + f y
09:54:49 <moop> oh i think i understand
09:54:52 <saml> that's when you do  on (+) f
09:54:56 <navaati1> there is a Zoom class, i did the instance but it appears it's not sufficient
09:55:05 <saml> it's just a way to obscure coad
09:55:07 <navaati1> Tekmo__: any idea on what does miss ?
09:55:13 <moop> ok, ty saml and Tekmo__
09:55:28 <Tekmo__> navaati1: You also need to do something with the `Zoomed` type family
09:55:37 <roconnor_> navaati1: zoom only works on StateT a m
09:55:51 <Tekmo__> roconnor_: He's talking about the one from the `lens` package
09:55:52 <saml> > on (+) fst $ (1, "boobies") (2, "boobies")
09:55:54 <lambdabot>  Couldn't match expected type `(t1, [GHC.Types.Char]) -> (c0, b0)'
09:55:54 <lambdabot>              with actual type `(t0, [GHC.Types.Char])'
09:56:14 <saml> > (on (+) fst ) (1, "") (2, "")
09:56:15 <roconnor_> navaati: i.e. zoom requires the outermost monad transformation layer to be StateT
09:56:15 <lambdabot>  3
09:56:17 <navaati> Tekmo__: uh, yeah that's what i was seeing, but what ? Zoomed (MyType s) = s ?
09:56:28 <roconnor_> navaati: if your data type is of that form, you can implement your own zoom
09:56:43 <roconnor_> your own zoom instance
09:56:54 <navaati> roconnor_: yeah, that's what i'm tring to do, if it's not too much complicated
09:57:30 <Tekmo__> navaati: I need to see the data declaration for your transformer stack
09:58:05 <roconnor_> navaati: well, there is probably only one way that will compile. :D
09:58:41 <d3lxa> Tekmo__: but still this won't solve my problem, I don't know where GHC did infer the "expected" type (where I'm doing most of my mistakes)
09:58:49 <d3lxa> carter: any solution for this? ^
09:59:05 <navaati> Tekmo__: newtype DCLI (p ∷ Heavy) s a = DCLI { runDCLI ∷ StateT s IO a }
09:59:48 <carter> solution for what
10:00:01 <Tekmo__> navaati: I think it would be: type instance Zoomed (DCLI p s a) = Zoomed (StateT s IO a)
10:00:25 <carter> Tekmo__: i'm aiming to get a dumb blas/lapack binding in mortal friendly shape later today / this week
10:00:31 <Tekmo__> navaati: It also depends on how you implemented `zoom` for the `Zoom` type class
10:00:37 <Tekmo__> carter: Nice :)
10:00:39 <navaati> Tekmo__: i have an instance "instance Zoom (DCLI p s) (DCLI p t) s t where zoom lens (DCLI action) = DCLI $ zoom lens action"
10:00:42 <carter> its actually online already at github.com/wellposed/hopenblas
10:01:01 <carter> but theres a few more days of hacking before its mortal friendly
10:01:04 <Tekmo__> d3lxa: Usually the error message will give some clues as to where it inferred the expected type from
10:01:06 <carter> but should be pretty easy
10:01:11 <Tekmo__> navaati: Yeah, then that would be the right type instance, I think
10:01:21 <frohe> Maybe a is considered a concrete type? What is not considered a concrete type?
10:01:23 <navaati> Oh, i see, regarding the type instance... ok, trying this
10:01:44 <scooty-puff> repeat of an earlier question: is https://ghc.haskell.org/trac/ghc/ticket/3990 fixed in 7.6.2?  i get this warning using that version of ghc: http://lpaste.net/97797
10:01:44 * hackagebot cruncher-types 1.0.1 - Request and Response types for Eval.so's API  http://hackage.haskell.org/package/cruncher-types-1.0.1 (RickyElrod)
10:01:56 <carter> i already started writign some bindings, but i  may burn them in fire and use c2hs if it makes things easier
10:02:18 <Tekmo__> scooty-puff: The reason the UNPACK pragma is unusable is because the `a` field is polymorphic
10:02:27 <Tekmo__> scooty-puff: UNPACK only works on specific types, not polymorphic ones
10:02:42 <scooty-puff> how can i unpack the int?
10:02:46 <osa1> so I added a source to cabal sandbox but it still downloads the package from hackage I think
10:03:06 <ski> (Tekmo__ : s/polymorphic/type variable/)
10:03:07 <Tekmo__> scooty-puff: You already did, in your `Pair` data type
10:03:17 <scooty-puff> i guess get it to where its Thing Int# a
10:03:37 <Tekmo__> ski: They're not the same?
10:03:48 <carter> oh blahblah,  c2hs requires language-c and stuff installed
10:03:57 <carter> i want fewer installation deps, not more
10:04:30 <scooty-puff> also: http://lpaste.net/97800
10:04:42 <scooty-puff> err, remove the phantom `a', still happens
10:05:01 <Tekmo__> scooty-puff: Maybe it is because it is a data family.  This time I'm not sure
10:05:24 <scooty-puff> there was an issue for it, and it is marked resolved for a very similar case - i'll put up an lpaste testing that
10:05:59 <navaati> Tekmo__: i got "The first argument of `Zoomed' should have kind `* -> *'" so i removed the 'a's from the line you given me. Now i get something about UndecidableInstance, is it normal or scary ?
10:06:11 <nstdloop> So if I just want to nuke all of cabal downloads so I can redownload everything with documentation and library profiling, should I just delete ~/.cabal/lib and ~/.cabal/share and ~/.ghc/arch?
10:06:25 <scooty-puff> the explicit case they fix is http://lpaste.net/97801, i'm guessing i must be using too old of a version of ghc
10:06:30 <ski> Tekmo__ : a polymorphic value is one whose type is universal, iow has the shape `forall a. ..a..'
10:06:47 <Tekmo__> navaati: Yes, you will need to use UndecidableInstances
10:07:05 <monoidal> scooty-puff: regarding data Thing a = Thing {-# UNPACK #-} !(Pair Int a), I can reproduce the warning in 7.6 but not HEAD
10:07:08 <Tekmo__> navaati: I'm not a big fan of UndecidableInstances, but Edward is
10:07:19 <Tekmo__> navaati: In this case it is safe to use
10:07:20 <monoidal> scooty-puff: I mean regarding http://lpaste.net/97797
10:07:23 <scooty-puff> monoidal: k - sounds good - as long as it can assume it will be fixed
10:07:34 <xoip> Hmm. I could fold a list with different left right arguments correct?
10:07:52 <scooty-puff> well, it is fixed, but fixed for me
10:08:45 <xoip> That was silly phrasing. I mean, with different types of left right arguments
10:08:55 <Tekmo__> xoip: You mean a list of `Either`s?
10:09:05 <monoidal> scooty-puff: the same situation with http://lpaste.net/97800
10:09:06 <navaati> Tekmo__: ok, thanks
10:09:30 <ski> Tekmo__ : i'd prefer people not calling `Maybe' a "polymorphic type" (it's parametric, iow a type function), nor calling type variables themselves (or values having those as types) (a constituent of a universal resp. polymorphic thing) "polymorphic"
10:09:51 <Enigmagic> Tekmo__: when is UndecidableInstances unsafe? Doesn't it just lead to compile errors if GHC blows through it's stack?
10:09:56 <osa1> guys can anyone help me? I have modified version of a package and I'm adding that folder to cabal sandbox as source, but it still downloads some older version from hackage when I cabal install in that sandbox
10:10:09 <ski> (these things can be hard/confusing enough, when starting out, without us oldtimers confusing the terminology)
10:10:21 <Tekmo__> Enigmagic: I believe it's unsafe if instance resolution isn't guaranteed to terminate
10:10:22 <tovarish> ski, there are polymorphic types? or is it just an incorrect way to name them?
10:10:25 <osa1> when add constraint to that new version, it fails with Backjump limit reached (change with --max-backjumps)
10:10:29 <monoidal> scooty-puff: and the same with  http://lpaste.net/97801. those three pastes give a warning in 7.6 but not 7.7.
10:10:44 <roconnor_> ski: so values are polymorphic and types are parametric?
10:10:58 <Enigmagic> Tekmo__: that causes deterministic compile failures, not runtime issues though.
10:11:09 <ski> roconnor_ : "types are universal", i think would go better with that
10:11:36 <ski> parametric types are different (but related, since you usually get polymorphic values when using parametric types)
10:11:46 * hackagebot coroutine-object 0.2.0.0 - Object-oriented programming realization using coroutine  http://hackage.haskell.org/package/coroutine-object-0.2.0.0 (IanWooKim)
10:11:48 * hackagebot hoodle-types 0.2.2 - Data types for programs for hoodle file format  http://hackage.haskell.org/package/hoodle-types-0.2.2 (IanWooKim)
10:11:50 * hackagebot hoodle-parser 0.2.2 - Hoodle file parser  http://hackage.haskell.org/package/hoodle-parser-0.2.2 (IanWooKim)
10:11:52 * hackagebot hoodle-builder 0.2.2 - text builder for hoodle file format  http://hackage.haskell.org/package/hoodle-builder-0.2.2 (IanWooKim)
10:11:54 * hackagebot xournal-types 0.5.0.2 - Data types for programs for xournal file format  http://hackage.haskell.org/package/xournal-types-0.5.0.2 (IanWooKim)
10:12:03 <roconnor_> ski: universal refering to the quantifier?
10:12:11 <roconnor_> ski: functors are parametric?
10:12:20 <navaati> Tekmo__: awwww yeah it's all fine, thanks a lot
10:12:38 <ski> roconnor_ : yes. i'm not sure how standard "universal type" is. if someone has a better suggestion, i'm all ears
10:12:38 <scooty-puff> monoidal: thanks for the help - i need to switch over to some version of 7.7 at some point..
10:12:43 <ski> tovarish : consider `newtype Flip f b a = MkFlip {unFlip :: f a b}', here the *kind* of `Flip' is `(* -> * -> *) -> * -> * -> *'
10:13:40 <monoidal> scooty-puff: 7.8 should be coming soon, but don't hold your breath.
10:13:48 <Enigmagic> two more weeks!
10:14:10 <monoidal> scooty-puff: there's some pressure on release maintainers, but also some blockers
10:14:12 <ski> tovarish : however, comparing with `flip f b a = f a b', where we have `flip :: forall a b c. (a -> b -> c) -> b -> a -> c', rather than something like `flip :: (Int -> Int -> Int) -> Int -> Int -> Int' or `flip :: (Int -> Bool -> IO String) -> Bool -> Int -> IO String', we'd prefer `Flip' to be polymorphic in a similar fashion as `flip' is polymorphic
10:15:29 <scooty-puff> i can stand two weeks, longer even, just need to remember the warning is ok
10:15:31 <xoip> Tekmo__: A contrived example: Suppose I have a list of Ints that I want to turn into a string. [3,4,5] would become "345". Could I use: foldl someFunc "" [3,4,5] ? Where someFunc :: String -> Int -> String ?
10:16:12 <monoidal> > foldl f "" [3,4,5]
10:16:13 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr
10:16:13 <lambdabot>                     [GHC.Types.Char])
10:16:13 <lambdabot>    arising from a use of `Debug.SimpleReflect.Vars.f'
10:16:13 <lambdabot>  Possible fix:
10:16:13 <lambdabot>    add an instance declaration for
10:16:18 <ski> tovarish : iow, we'd like to get at least `Flip :: forall k0 k1. (k0 -> k1 -> *) -> k1 -> k0 -> *' (and then also `MkFlip :: forall_kind k0 k1. forall (f :: k0 -> k1 -> *) (a :: k0) (b :: k1). f a b -> Flip f b a' and `unFlip :: forall_kind k0 k1. forall (f :: k0 -> k1 -> *) (a :: k0) (b :: k1). Flip f b a -> f a b')
10:16:29 <monoidal> > foldl f x [y,z]
10:16:30 <lambdabot>  f (f x y) z
10:16:46 * hackagebot xournal-parser 0.5.0.2 - Xournal file parser  http://hackage.haskell.org/package/xournal-parser-0.5.0.2 (IanWooKim)
10:16:48 * hackagebot hoodle-core 0.13 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.13 (IanWooKim)
10:16:50 * hackagebot hoodle 0.2.2 - Executable for hoodle  http://hackage.haskell.org/package/hoodle-0.2.2 (IanWooKim)
10:17:09 <pavonia> > map intToDigit [3,4,5]
10:17:10 <lambdabot>  "345"
10:17:42 <monoidal> depending on application, intToDigit might be wrong if numbers are bigger than 9 though
10:17:52 <ski> (`*' instead of `k2' since the left and right type arguments to `->' (here in `f a b -> Flip f b a' and `Flip f b a -> f a b' in the signatures for `MkFlip' and `unFlip') must have kind `*')
10:18:09 <ski> roconnor_ : `IORef' is parametric, `Maybe' is parametric
10:18:27 <ski> iow "takes a (type) parameter"
10:18:44 <ski> (not to be confused with "parametricity")
10:19:33 <monoidal> xoip: in short, you can, someFunc would have that type.
10:19:44 <monoidal> xoip: you can also write concat (map show [3,4,5])
10:20:37 <kqr> monoidal, concat . map f is concatMap f
10:20:59 <xoip> Thanks monoidal. Man this language makes you think differently. Day 2...
10:21:08 <monoidal> kqr: I know, but kept it simple.
10:21:15 <kqr> ah right
10:21:52 <ski> tovarish : summing up, there *could* be polymorphic types in Haskell
10:22:44 <ski> (there's this `PolyKinds' extension in GHC that appears to give some functionality along these lines. but afaiu it's experimental and incomplete (at least when regarded from this angle))
10:23:10 <ski> tovarish : makes any sense ?
10:27:06 <tovarish> ski, in my past I was good at Maths, so nothing with types scared me
10:30:12 <ski> tovarish : ok .. meaning ?
10:33:00 <tovarish> ski, meaning, that I know the perfect and complete type system
10:33:13 <tovarish> so any type system is a sub system of that type system
10:33:39 <JuanDaugherty> ??????? ur only as good as ur last act of mathesis
10:34:20 <lightquake> i'm pretty sure that any consistent type system that's interesting enough to embed arithmetic in via curry-howard is going to be incomplete because godel
10:35:24 <lightquake> although, i'm not sure what it means to be incomplete in a godelian sense...
10:36:39 <shachaf> lightquake: It's OK, Haskell has gone the inconsistent route.
10:36:47 <maurer> tovarish: "complete" is a funny word to use there....
10:36:48 * hackagebot liblastfm 0.3.2.0 - Lastfm API interface  http://hackage.haskell.org/package/liblastfm-0.3.2.0 (MatveyAksenov)
10:36:54 <lightquake> there exist types corresponding to true theorems that have no values in them, I guess
10:36:57 <tovarish> maurer, I know, but I assume it
10:37:05 <lightquake> shachaf: well, yes
10:37:37 <maurer> tovarish: So, what is it that you assume to be perfect and complete? "Maths" covers a multitude of systems
10:37:59 <monochrom> "complete" is a correct word for this. consider Turing-complete, NP-complete. it means "subsumes everyone".
10:38:37 <monochrom> clearly, a system can be Turing-complete and Gödel-incomplete at the same time.
10:38:55 <lightquake> that reminds me, what's the word that i'm looking for that distinguishes a recursive function that always goes deeper into its argument from one that just spins, like f x = f x
10:39:09 <tovarish> maurer, describe me a type system that is not embedded inside math type system (hint you can't, because describing it is showing the embedding and if you can't describe it it's just nothing)
10:39:14 <monochrom> structural recursion?
10:39:33 <maurer> tovarish: What is "math type system"? There are many different formalisms for math, to which one are you referring?
10:39:51 <lightquake> monochrom: i think that's it, yeah
10:39:57 <ski> tovarish : what is "the perfect and complete type system" ?
10:39:59 <tovarish> maurer, anything that is described by text and follow the logical rules
10:40:05 <ski> some variant of a dependent type theory ?
10:40:17 <tovarish> random text is not math and is not a valid type description
10:40:21 <ski> shachaf : see above
10:40:34 <monochrom> "a type system not embedded inside a math system" is of the same calibre as "a number that is not interesting". they harp on the subjective judgment of "what counts as math? what counts as interesting?"
10:40:35 <tovarish> ski, explain the rules to me of your type system, and realise why it is embedded in math
10:40:38 <shachaf> ski: ?
10:40:59 <ski> <ski> shachaf : Lewis's strict implication/conditional
10:41:30 <monochrom> hell, they harp on the moving target fallacy. the same thing is not math at one moment and is math at the next moment.
10:41:32 <JuanDaugherty> candidates found in  ??????? 's head, lambda calc, martion lof's hindley miller, other drips and drabs
10:42:11 <shachaf> Oh, yes. I saw that. Thanks.
10:42:14 <ski> <shachaf> ski calls it -># or some English name I don't remember.
10:42:14 <ski> <shachaf> And has the whole a -> b = exists e. (# e, (# e, a #) -># b #) thing
10:43:02 <ski> lightquake : how about `from n = n : from (succ n)' ?
10:43:39 <xoip> It's curious that replicate accepts a tuple for the second argument, whereas replicateM does not
10:43:55 <monochrom> @type replicate
10:43:56 <lambdabot> Int -> a -> [a]
10:44:00 <monochrom> @type replicateM
10:44:01 <lambdabot> Monad m => Int -> m a -> m [a]
10:44:28 <monochrom> no, your comparison is more curious.
10:44:49 <xoip> I don't know what I'm doing, it's okay
10:45:05 <hattmammerly> > do a <- [1,2,3,4]; b <- [5,6,7,8]; return (a+b);
10:45:06 <lambdabot>  [6,7,8,9,7,8,9,10,8,9,10,11,9,10,11,12]
10:45:19 <hattmammerly> how might I write this without do notation? I'm struggling, heh
10:45:32 <ski> @undo do a <- [1,2,3,4]; b <- [5,6,7,8]; return (a+b)
10:45:32 <lambdabot> [1, 2, 3, 4] >>= \ a -> [5, 6, 7, 8] >>= \ b -> return (a + b)
10:45:45 <monochrom> [a+b | a <- [1,2,3,4], b <- [5,6,7,8]] is it better?
10:45:45 <ski> > [a + b | a <- [1,2,3,4],b <- [5,6,7,8]]
10:45:46 <lambdabot>  [6,7,8,9,7,8,9,10,8,9,10,11,9,10,11,12]
10:45:51 <ski> @undo [a + b | a <- [1,2,3,4],b <- [5,6,7,8]]
10:45:52 <lambdabot> concatMap (\ a -> concatMap (\ b -> [a + b]) [5, 6, 7, 8]) [1, 2, 3, 4]
10:45:57 <hattmammerly> magic
10:46:04 <hattmammerly> thank you!
10:46:18 <monochrom> but I guess you like liftM2 (+) [1,2,3,4] [5,6,7,8]
10:46:43 <ski> > concatMap (\a -> map (\b -> a + b) [5,6,7,8]) [1,2,3,4]
10:46:43 <fread2282> > liftM2 (+) [1,2,3,4] [5,6,7,8]
10:46:44 <lambdabot>  [6,7,8,9,7,8,9,10,8,9,10,11,9,10,11,12]
10:46:44 <lambdabot>  [6,7,8,9,7,8,9,10,8,9,10,11,9,10,11,12]
10:46:49 <lightquake> ski: isn't that corecursion?
10:46:50 * hackagebot hsimport 0.2.3 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.3 (DanielTrstenjak)
10:47:05 <ski> > let foo a = map (\b -> a + b) [5,6,7,8] in concatMap foo [1,2,3,4]
10:47:07 <lambdabot>  [6,7,8,9,7,8,9,10,8,9,10,11,9,10,11,12]
10:47:25 <lightquake> you're always being productive because of the cons cell
10:47:32 <ski> hattmammerly : do these help ?
10:48:06 <hattmammerly> ski: most certainly, thanks so much!
10:48:31 <ski> lightquake : just wanted to point out that it needn't be either of "always goes deeper into its argument" or "just spins"
10:48:46 <ski> > map (\a -> map (\b -> a + b) [5,6,7,8]) [1,2,3,4]
10:48:47 <lambdabot>  [[6,7,8,9],[7,8,9,10],[8,9,10,11],[9,10,11,12]]
10:48:48 <lightquake> right
10:48:52 <ski> > concat (map (\a -> map (\b -> a + b) [5,6,7,8]) [1,2,3,4])
10:48:53 <lambdabot>  [6,7,8,9,7,8,9,10,8,9,10,11,9,10,11,12]
10:49:12 <ski> hattmammerly : those ^ (hopefully) explain where `concatMap' is coming from
10:49:52 <lightquake> plus you can still *effectively* spin even if you do always go deeper; consider last $ fix (1:)
10:50:30 <ski> that's due to confusing inductive with coinductive data types, no ?
10:50:56 <lightquake> maybe? i don't actually know much about this area
10:50:59 <danharaj1> not confusing, collapsing.
10:52:28 <Clint> so if HP 2013.4.0.0 doesn't come out today is it still going have that version number?
10:52:41 <monochrom> haha
10:53:13 <monochrom> it won't
10:56:55 <Ankhers> What is the best way to test if a String contains letters?
10:57:23 <dhrosa> Ankhers: only letters, or if any of the chars are letters?
10:57:49 <Ankhers> I want to know if a String has the letters a-z
10:58:33 <Ankhers> In regex, I would write something like /[a-z]+/i
10:58:36 <dhrosa> Ankhers: yes, but do you want "lol123" to pass your test, or only "onlyalpha"
10:58:50 <simpson> :t any
10:58:51 <lambdabot> (a -> Bool) -> [a] -> Bool
10:58:55 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/Data-Char.html#v:isAlpha
10:59:04 <navaati> : all
10:59:07 <navaati> :t all
10:59:08 <lambdabot> (a -> Bool) -> [a] -> Bool
10:59:11 <navaati> :t isLetter
10:59:12 <lambdabot> Char -> Bool
10:59:20 <navaati> :t all isLetter
10:59:21 <simpson> :t all isLetter "derp"
10:59:21 <lambdabot> [Char] -> Bool
10:59:21 <lambdabot> Bool
10:59:32 <simpson> > all isLetter "all letters?"
10:59:33 <lambdabot>  False
10:59:41 <simpson> > any isLetter "all letters?"
10:59:42 <lambdabot>  True
10:59:55 <tovarish> > any isLetter "é"
10:59:56 <lambdabot>  True
11:00:01 <tovarish> > any isLetter "ï"
11:00:02 <lambdabot>  True
11:00:06 <tovarish> impressive
11:00:27 <monochrom> yeah, it follows the Unicode categories
11:00:31 <tovarish> > any isLetter "~"
11:00:32 <lambdabot>  False
11:00:35 <navaati> tovarish: in this case, just use > isLetter 'ï'
11:00:47 <tovarish> navaati, it's the compiler duty to transform my code
11:00:53 <navaati> ...
11:01:27 <monochrom> it's a free country
11:01:34 <Ankhers> > map isLetter ":) ?"
11:01:36 <lambdabot>  [False,False,False,False]
11:02:01 <tovarish> > take 100 $ filter isLetter [\000..]
11:02:02 <lambdabot>  <hint>:1:33: parse error on input `..'
11:02:06 <tovarish> > take 100 $ filter isLetter [0..]
11:02:07 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
11:02:07 <lambdabot>    arising from the literal `0'
11:02:07 <lambdabot>  Possible fix:
11:02:07 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Types.Char)
11:02:10 <Ankhers> > any map isLetter ":) ?"
11:02:11 <lambdabot>  Couldn't match expected type `[GHC.Types.Char] -> t0'
11:02:12 <lambdabot>              with actual type `GHC.Types.Bool'Couldn't match type `[a0] -> [b...
11:02:12 <lambdabot>  Expected type: (a0 -> b0) -> GHC.Types.Bool
11:02:13 <lambdabot>    Actual type: (a0 -> b0) -> [a0] -> [b0]Couldn't match expected type `[a0 -...
11:02:15 <lambdabot>              with actual type `GHC.Types.Char -> GHC.Types.Bool'
11:02:19 <Ankhers> > or map isLetter ":) ?"
11:02:20 <lambdabot>  Couldn't match expected type `(GHC.Types.Char -> GHC.Types.Bool)
11:02:21 <lambdabot>                                -> [GHC.Types.Char] -> t0'
11:02:21 <lambdabot>              with actual type `GHC.Types.Bool'Couldn't match expected type `[...
11:02:22 <tovarish> > take 100 $ filter isLetter [' '..]
11:02:23 <lambdabot>              with actual type `(a0 -> b0) -> [a0] -> [b0]'
11:02:25 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\19...
11:02:30 <Ankhers> > or $ map isLetter ":) ?"
11:02:31 <lambdabot>  False
11:02:41 <Ankhers> Would that be the proper way of doing it?
11:02:43 <simpson> @src any -- Ankhers
11:02:44 <lambdabot> Source not found. Whoa.
11:02:44 <tovarish> > take 100 $ drop 100 $ filter isLetter [' '..]
11:02:45 <lambdabot>  "\238\239\240\241\242\243\244\245\246\248\249\250\251\252\253\254\255\256\25...
11:02:50 <tovarish> ...
11:02:57 <tovarish> isLetter is strange
11:03:02 <simpson> Ankhers: Look at `any`, which is pretty much that same combination of `or` and `map`.
11:03:31 <Ankhers> simposon: Noted, thank you.
11:03:43 <Ankhers> And thank you everyone else that pointed me in the proper direction.
11:03:58 <Ankhers> is there something like any, except for and?
11:04:08 <ski> > ['\0' ..]
11:04:09 <monochrom> "all"
11:04:10 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
11:04:29 <ski> > all isLower "Ankhers"
11:04:29 <tovarish> > take 100 $ drop 100 $ filter isLetter ['\0'..]
11:04:30 <lambdabot>  False
11:04:30 <lambdabot>  can't find file: L.hs
11:04:48 <tovarish> > take 100 $ drop 100 $ filter isLetter ['\0' ..]
11:04:49 <lambdabot>  "\238\239\240\241\242\243\244\245\246\248\249\250\251\252\253\254\255\256\25...
11:05:14 <tovarish> >length $ take 100000 $ filter isLetter ['\0' ..]
11:05:33 * tovarish like to stress that little bot.
11:05:39 <tovarish> > length $ take 100000 $ filter isLetter ['\0' ..]
11:05:40 <lambdabot>  100000
11:05:58 <tovarish> what ?
11:06:06 <tovarish> > length $ take 1000000 $ filter isLetter ['\0' ..]
11:06:07 <lambdabot>  100520
11:06:22 <tovarish> lambdatbot knows 100520 letters
11:07:18 <monochrom> yes. like I said, it follows the Unicode categories.
11:08:17 <tovarish> I'm skeptical
11:08:29 <monochrom> talk to my hand
11:08:59 <Ankhers> Is there a simple way to trim all leading an tailing whitespace from a string?
11:09:18 <tovarish> monochrom, it's really impolite
11:09:40 <monochrom> fine
11:09:56 <geekosaur> so in your example, \238 is î
11:10:26 <geekosaur> (I think there's a "text" thing that will display Unicode outside the 0x20-0x7e range)
11:10:28 <Tekmo__> @src trim
11:10:28 <lambdabot> Source not found. I feel much better now.
11:11:00 <Tekmo__> @src strip
11:11:00 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:11:19 <Tekmo__> Ankhers: So if you use `Text` instead of `String` there is a function in `Data.Text` called `strip` which does exactly that
11:13:19 <stepkut> for some reason in happstack-server-tls.cabal I included a line: Extra-Libraries: ssl cryptopp, but I can't remember why. Did older versions of GHC have an issue where they didn't not pick up the extra linker flags required by HsOpenSSL ?
11:13:46 <stepkut> the code compiles fine with GHC 7.6.3 with out that line -- but I feel like I added that line for a reason
11:14:23 <Tekmo__> git blame (or the darcs equivalent) to see why you added it
11:19:11 <Tekmo__> stepkut: Do you have an `attoparsec`-based parser for HTTP headers?
11:19:50 <RustyShackleford> I like Python quite a bit. How is haskell compared to Python?
11:20:04 <DigitalKiwi> you poor soul
11:20:11 <RustyShackleford> the type system seems a little similar. Namely lists, tuples
11:20:13 <Tekmo__> pes to represent things
11:20:16 <Tekmo__> Oops
11:20:38 <Tekmo__> The big difference is that Haskell uses richer data types
11:20:55 <Tekmo__> In Python you use strings/ints/maps/generators pervasively
11:21:08 <Tekmo__> In Haskell you have more precise types
11:21:26 <Tekmo__> The other big difference is immutability
11:21:31 <DigitalKiwi> https://wiki.python.org/moin/PythonVsHaskell
11:21:36 <Tekmo__> Idiomatic Python is all about stashing stuff inside of stuff
11:21:39 <stepkut> Tekmo__: not yet
11:21:39 <RustyShackleford> i like the fact that haskell has static typing
11:22:20 <Tekmo__> Idiomatic Haskell is all about building new things on top of old things
11:22:28 <frohe> Any ideas how I can fix this problem?  http://lpaste.net/97802
11:22:51 <RustyShackleford> how does the performance of Haskell compare to Python?
11:23:10 <Tekmo__> RustyShackleford: Haskell is compiled, so user-written code is typically faster in Haskell
11:23:46 <Tekmo__> However, for many high-performance things both Haskell and Python use C libraries, so the performance is identical in those areas
11:24:04 <Tekmo__> An example is numerical stuff where Python uses numpy and Haskell uses hmatrix, which are both bindings to C/Fortran code
11:24:11 <Tekmo__> So you won't see much of a difference there
11:24:13 <RustyShackleford> so you can write your own C extensions as well?
11:24:15 <Tekmo__> Yes
11:24:34 <RustyShackleford> not sure why I waited so long to try Haskell
11:24:43 <RustyShackleford> this looks pretty interesting
11:25:00 <Tekmo__> Note that very few libraries actually use the FFI
11:25:09 <Tekmo__> Many high-performance Haskell libraries are actually pure Haskell
11:25:26 <Tekmo__> This is because `ghc` also exposes some high-performance primitive operations itself
11:25:37 <Freeman42> lol, why is the word real quoted in that article? xD 'Haskell is a modern functional language (like lisp). It's not commonly used but the language is used for some "real" projects'
11:25:54 <monochrom> frohe: what is the type of 3? and is that type an instance of MyEq?
11:26:17 <davean> Freeman42: Real is a very relative concept?
11:26:27 <RustyShackleford> how do you pronounce "Haskell"?
11:26:29 <davean> Freeman42: It has no inherant meaning
11:26:33 <RustyShackleford> HAS-kell
11:26:36 <DigitalKiwi> ivory towers?
11:26:41 <RustyShackleford> or Has-KELL
11:26:58 <monochrom> "real" is relative. I am serious.
11:27:08 <FireFly> RustyShackleford: the former in an english context
11:27:33 <Freeman42> yeah, they should have used some different wording, quoting real sounds funny
11:27:47 <davean> Freeman42: It is very standard
11:28:03 <frohe> monochrom: 3 :: Num a => a . How can I make it an instance of MyEq? It's a polymorphic constant, right?
11:28:27 <monochrom> more precisely, people arrogantly hold that their own jobs are real and everything else is toy
11:29:34 <monochrom> frohe, choose a type, say Integer, and make it an instance of MyEq. then use Integer for 3.
11:31:00 <Tekmo__> frohe: Just out of curiosity, why are you using `MyEq` instead of `Eq`.  There is an `Eq` instance for `Maybe`s
11:31:24 <RustyShackleford> which resource do you recommend for learning Haskell? I'm new to Haskell, but not to programming
11:31:24 <frohe> Tekmo__: I'm just playing with classes, instances, etc.
11:31:38 <RustyShackleford> Learn You a Haskell?
11:31:49 <Tekmo__> RustyShackleford: Learn you a Haskell if you are completely new to functional programming
11:32:07 <Tekmo__> RustyShackleford: Real World Haskell is good as a reference, but if you try to read it straight through it is quite tedious
11:32:24 <Tekmo__> RustyShackleford: I find it helps to pick and choose chapters that interest you from Real World Haskell
11:32:25 <frohe> Programming in Haskell is nice too
11:33:15 <Tekmo__> RustyShackleford: Yeah, and also practice programming in Haskell
11:33:29 <Tekmo__> RustyShackleford: A common mistake for beginners is to wait until they completely understand all Haskell design patterns before starting
11:33:30 <enthropy> that's a book name
11:33:43 <Tekmo__> RustyShackleford: If you wait until you understand the full potential of Haskell you will wait a long time
11:34:49 <monochrom> a common opposite mistake is to start too difficult
11:35:34 <Tekmo__> Yeah
11:35:35 <henk> I’m using getOpt for option parsing. The errors returned are in this format ["error", "number", "one", "\n", "error", "number", "two"]. How am I supposed to print them to stdout sanely? If I just use 'unwords' on it, all errors apart from the first have a blank space at the beginning of the line … Is there an elegant way or only crude hacks?
11:36:36 <frohe> monochrom: Then I have to define explicitly the type of 3?
11:36:45 <monochrom> likely, yes
11:36:52 <Tekmo__> henk: You should consider using `optparse-applicative` if you can
11:37:13 <Tekmo__> frohe: Not always
11:37:26 <Tekmo__> frohe: Sometimes the compiler will default `3` to an `Integer` if the type is ambiguous
11:37:39 <henk> Tekmo__: I did and I know it’s impossible to run into that problem there because it does not do any error reporting, which I consider less than optimal …
11:39:03 <sm> cmdargs is pretty good
11:40:19 <monochrom> but I successfully got optparse-applicative to report errors. https://github.com/treblacy/random-read/blob/master/random-read.hs
11:46:21 <enthropy> the applicative notation there goes by-position which is kind of troublesome when you have more than about 5 flags
11:46:57 * hackagebot xformat 0.1.2.1 - Extensible, type-safe formatting with scanf- and printf-like functions  http://hackage.haskell.org/package/xformat-0.1.2.1 (SeanLeather)
11:49:29 <frohe> monochrom, Tekmo__: How can this be extented to all integers? It only works for 3.
11:51:34 <frohe> I wrote something like "instance MyEq Integer where 3 === 3 = True _ === _ False"
11:52:53 <Saizan> frohe: (===) = (==)
11:53:30 <FreeFull> You could use     x === y = case x - y of 0 -> True; _ -> False
11:53:30 <Saizan> pattern matching against a numeric literal uses the Eq instance anyway
11:54:11 <FreeFull> > case 3 - 3 of 0 -> True; _ -> False
11:54:12 <lambdabot>  True
11:54:52 <FreeFull> > let a === b = case a - b of 0 -> True; _ -> False in check (\a b -> (a === b) == (a == b))
11:54:53 <lambdabot>  Not in scope: `check'
11:55:02 <FreeFull> > let a === b = case a - b of 0 -> True; _ -> False in quickCheck (\a b -> (a === b) == (a == b))
11:55:03 <lambdabot>  <IO ()>
11:55:13 <FreeFull> Dammit, forgot quickCheck is in IO
11:56:46 <d-snp> alright, I'm home again, time to run that code through ghc :)
11:57:53 <frohe> thanks guys :)
12:01:44 <ski> @check let a === b = case a - b of 0 -> True; _ -> False in \a b -> (a === b) == (a == b)
12:01:45 <lambdabot>  +++ OK, passed 100 tests.
12:01:47 <ski> FreeFull ^
12:02:10 <ski> @help check
12:02:10 <lambdabot> check <expr>
12:02:10 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
12:02:24 <ski> @help run
12:02:25 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
12:03:00 <d-snp> cabal: iiqueue.cabal:1: Parse of field 'name' failed.
12:03:16 <d-snp> I'm definitely running in the haskell paralympics
12:03:48 <eyebloom> What do curly brackets signify in the pretty printing of a CoreExpr?
12:06:27 <henk> Tekmo, sm: What’s wrong with GetOpt?
12:06:41 <frohe> I wish you all a happy new year. See you :)
12:07:11 <sm> henk: IIRC cmdargs is more featureful
12:07:59 <sm> eg with its support for subcommands
12:08:38 <ReinH> Tekmo: hai
12:10:48 <henk> sm: http://www.haskell.org/haskellwiki/Command_line_option_parsers finds it worth mentioning that cmdargs uses unsafePerformIO, also it requires quite a few extensions where other parsers require none or a lot less … I like to keep things small and simple.
12:11:15 <henk> I’ll try making my question more generic, so I don’t get as much advice on how to work around the problem and more solutions maybe:
12:12:33 <henk> I have one or more lines of text in this format ["error", "number", "one", "\n", "error", "number", "two"]. How can I print this to stdout? Simply using 'unwords' leaves me with a leading newline in every but the first line.
12:13:11 <lispy> This is the way I handle command arguments: http://www.haskell.org/haskellwiki/High-level_option_handling_with_GetOpt
12:13:13 <maxiepoo> is there no operator in lens for `under`?
12:13:50 <lispy> I really like the elegance of options :: [ OptDescr (Options -> IO Options) ]
12:13:57 <edwardk> maxiepoo: no operator form, it doesn't fit the other operators
12:14:00 <joehillen> docopt is the best thing ever https://github.com/docopt/docopt.hs
12:14:27 <henk> lispy: Sounds like you may have encountered that problem, too, then?
12:16:18 <lispy> joehillen: interesting.
12:16:29 <lispy> joehillen: can it take usage from a string too?
12:16:53 <joehillen> lispy: I don't see why not
12:16:54 <lispy> henk: Sorry, I saw you mentioned command line parsing, but what is the problem you're having?
12:17:12 <adelbertc> hey all - just installed hakyll using cabal sandboxes (in cabal 1.18), trying to compile the site.hs script generated by hakyll-init but getting this error: "Could not find module `Hakyll'" - im guessing it's because i used a sandbox, anyway to direct GHC towards the .cabal-sandbox folder?
12:17:17 <henk> lispy: I have one or more lines of text in this format ["error", "number", "one", "\n", "error", "number", "two"]. How can I print this to stdout? Simply using 'unwords' leaves me with a leading newline in every but the first line.
12:18:12 <meiji11> I'm reading a bit of code where a type s of kind (* -> *) is being passed a value p as a type parameter. I'm very certain that p is not a type, it's a value. how does that work?
12:18:20 <supki> adelbertc: ghc ... -package-db=.cabal-sandbox/...conf.d
12:18:39 <lispy> joehillen: it doesn't appear in the API afaict: https://github.com/docopt/docopt.hs/blob/master/System/Console/Docopt/Public.hs
12:18:51 <adelbertc> supki - awesome, cheers
12:19:20 <d-snp> when I do: cabal install pipes, it gives the following exception: invalid preprocessing directive
12:19:28 <d-snp> when compiling pipes 4.0.1
12:19:39 <lispy> henk: ah, I don't know how that's related to command line option parsing.
12:20:05 <d-snp> is there anything I can do about it? I'm on OSX, ghc 7.6.3
12:20:07 <lispy> henk: intercalate the lines?
12:20:13 <joehillen> lispy: you could easily morph optionsWithUsageFile into a optionsFromString function, since it's just passing the contents of the file along
12:20:25 <maxiepoo> so if I have an Iso, say Iso' String Path, where Path is a newtype Path = Path { unPath :: String }
12:20:26 <lispy> joehillen: agreed. I wonder why it's missing.
12:20:43 <henk> lispy: It’s the format getOpt returns errors it encountered …
12:20:52 <maxiepoo> what would be the easiest way to lift (</>) :: String -> String -> String to a function that's Path -> Path -> Path
12:21:05 <geekosaur> d-snp: preprocessor errors on OS X are typically the clang change; see the end of the /topic
12:21:21 <d-snp> oh
12:21:37 <henk> lispy: Apart from that: not at all. But all answers I got asking my question in the context of getOpt were along the lines "rather use this_so_much_better_option_parser" …
12:21:51 <d-snp> thanks geekosaur :)
12:21:53 <joehillen> lispy: I use docopt for python, it might be that the haskell version isn't maintained anymore, but it's definitely worth picking up
12:22:00 <henk> lispy: intercalate? Not sure I understand what you mean?
12:22:28 <lispy> :t intercalate
12:22:29 <lambdabot> [a] -> [[a]] -> [a]
12:22:46 <lispy> > intercalate "," ["error", "number", "one", "\n", "error", "number", "two"]
12:22:47 <lambdabot>  "error,number,one,\n,error,number,two"
12:23:15 <adelbertc> is it.. strange? i suppose im asking if there's a better way - for me to use cabal sandboxes to isolate things like pandoc and hakyll and hoogle from each other since I only ever use their binaries? doing the global install makes their dependencies conflict, im thinking if i should destroy the global installs, put them in sandboxes, and then point my PATH at each individual folder
12:23:37 <d-snp> ah great it works now
12:23:42 <henk> lispy: hm, how does that help?
12:24:02 <lispy> henk: Maybe unwords would work like you want?
12:24:09 <lispy> henk: er, you could amke a new version of unwords*
12:24:16 <lispy> or unlines
12:25:47 <lispy> adelbertc: I use cabal sandboxes with hakyll
12:26:03 <lispy> adelbertc: I wrote a .cabal file (or did hakyll init make it?) and that has worked for me
12:26:12 <lispy> adelbertc: I'm not sure how I have pandoc installed
12:26:38 <adelbertc> lispy - ah, yeah i think im going to try to isolate pandoc as well
12:26:57 <adelbertc> is there a way to destroy everything currently installed in cabal
12:27:02 <adelbertc> do i just nuke ~/.cabal?
12:27:03 <lispy> adelbertc: that should work fine as long as the PATH is right
12:27:33 <lispy> I use ghc-pkg unregister --user, but that takes lots of repeated commands
12:27:41 <lispy> I don't trust myself to delete the right files
12:28:38 <henk> lispy: I tried with (lines . unwords), but that leaves a _trailing_ whitespace instead … So I thought about using something to get rid of these whitespaces, came across *strip*, but I’d need yet another import for Data.Text then. At that point I couldn’t believe it to be so difficult and was sure I was missing some more elegant way as there usually is in Haskell …
12:30:30 <ReinH> henk: why not just putStrLn . intercalate " "?
12:32:02 * hackagebot cruncher-types 1.0.2 - Request and Response types for Eval.so's API  http://hackage.haskell.org/package/cruncher-types-1.0.2 (RickyElrod)
12:32:41 <henk> ReinH: hm? That also gives a leading whitespace …
12:33:17 <henk> > intercalate " " ["error", "number", "one", "\n", "error", "number", "two"]
12:33:19 <lambdabot>  "error number one \n error number two"
12:33:27 <henk> ReinH: see?
12:34:10 <lispy> henk: leading between lines?
12:34:24 <lispy> clearly there is no space before 'error'
12:34:44 <sm> looks like you need to split the list on "\n", I would use http://hackage.haskell.org/package/split
12:35:13 <henk> lispy: There is a space between "\n" and "error" which ends up at the beginning of every line but the first …
12:35:21 <supki> > words $ unwords ["error", "number", "one", "\n", "error", "number", "two"]
12:35:22 <lambdabot>  ["error","number","one","error","number","two"]
12:35:40 <supki> > unlines $ words $ unwords ["error", "number", "one", "\n", "error", "number", "two"]
12:35:41 <lambdabot>  "error\nnumber\none\nerror\nnumber\ntwo\n"
12:36:27 <lispy> henk: fwiw, this is what the getopts documentation does with the list of errors: (_,_,errs) -> ioError (userError (concat errs ++ usageInfo header options))
12:36:37 <d-snp> I have such a nice workflow, I type random shit into vim for 2 days, then I make a cabal file, and do cabal build until it works
12:36:54 <d-snp> which takes like, another day or so :P
12:37:47 <lispy> d-snp: that's different than mine. I always try to make sure it compiles after even small edits.
12:38:13 <d-snp> yeah, that's definitely better, I'm mocking myself..
12:38:32 <d-snp> I procrastinate the boilerplating :P
12:38:33 <lispy> d-snp: ah! (sorry, i'm a bit dense today)
12:38:38 <henk> sm: I can’t believe there is no simple, elegant, straightforward way of handling these errors as returned by getOpt … Why would its author choose this format if there wasn’t? And importing even more other packages just to get these errors in a format thats easily printable cannot be intended, can it?
12:38:59 <henk> lispy: I know, but I’m not quite sure that actually makes sense, see this:
12:39:07 <henk> > concat ["error", "number", "one", "\n", "error", "number", "two"]
12:39:09 <lambdabot>  "errornumberone\nerrornumbertwo"
12:39:23 <henk> That looks just broken, so I doubt it’s correct, or am I missing anything?
12:39:32 <evancz> how old is hackage?
12:39:34 <lispy> henk: maybe each element of tha list ends with \n?
12:39:42 <evancz> i.e. how long has it been possible to share libraries
12:39:44 <lispy> evancz: Hmm...2007?
12:39:51 <lispy> evancz: (that's just a guess)
12:39:55 <evancz> wow, I did not realize it was that recent!
12:40:25 <evancz> cabal goes back to 2003
12:40:32 <henk> lispy: Yeah, I guess I should play a little more with getopt to find the actual format … ATM it’s really just an assumption.
12:40:47 <henk> Thanks for your input everyone!
12:41:09 <geekosaur> the wayback machine first archived it in November 2005 fwiw
12:43:44 <evancz> okay, interesting
12:43:50 <evancz> thanks geekosaur and lispy :)
12:44:15 <evancz> I was theorizing that the popularity of Haskell vs. OCaml was directly related to this
12:44:39 <evancz> I just assumed Haskell's infrastructure for library sharing was older than that
13:02:44 <erisco> I am trying to be more general than lists (using Traversable, Foldable, etc) but how do I generically test for empty?
13:03:07 <erisco> I might try   mempty == v   but this would require additional constraint
13:03:38 <geekosaur> I think once you go generic you lose the simple empty test
13:03:55 <cschneid> :t fold
13:03:55 <lambdabot> (Foldable t, Monoid m) => t m -> m
13:04:00 <cschneid> :t traverse
13:04:01 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:04:12 <erisco> perhaps then I just want to use fold to convert to a list
13:06:35 <d-snp> I have this exception: http://lpaste.net/97803 with pipes
13:06:47 <d-snp> Tekmo: do you see what I'm doing wrong
13:06:58 <d-snp> I'm trying to take only the 'len' amount of bytes
13:09:12 <d-snp> oh I just fixed it I think
13:09:26 <d-snp> I put the take after the for, like so: runEffect $ for bytes (liftIO . hPut file) >-> P.take (fromIntegral len)
13:10:03 <d-snp> I hope it's going to work :)
13:12:07 * hackagebot hspec-webdriver 0.1.0 - Write end2end web application tests using webdriver and hspec  http://hackage.haskell.org/package/hspec-webdriver-0.1.0 (JohnLenz)
13:17:08 * hackagebot webdriver-angular 0.1.2 - Webdriver actions to assist with testing a webpage which uses Angular.Js  http://hackage.haskell.org/package/webdriver-angular-0.1.2 (JohnLenz)
13:20:28 <d-snp> I could make these two lines:
13:20:39 <d-snp> let name = showHex randomName ".iiq"
13:20:40 <d-snp> return name
13:20:49 <d-snp> shorter with a liftIO right?
13:21:19 <d-snp> hm
13:25:44 <frx> return (showHex randomName ".iiq")
13:29:23 <d-snp> ah thanks frx, that's silly of me
13:29:26 <d-snp> it compiles!
13:29:31 <d-snp> and it's even the new year yet
13:29:32 <erisco> I am having a tough time finding how to write a Show instance for this ADT http://lpaste.net/97806
13:34:09 <d-snp> Tekmo: if you feel like giving me some critique, it's here: https://github.com/iimeru/iiqueue/blob/master/IIQueueStore.hs :)
13:34:38 <jfischoff> erisco: why?
13:34:39 <d-snp> erisco: what have you tried?
13:34:56 <erisco> it will not auto-derive for vertTails :: t (Edge k t a b)
13:35:07 <erisco> and I cannot figure out the necessary constraints to manually make an instance
13:35:21 <jfischoff> what is Edge? Is it a Type?
13:35:30 <jfischoff> what is the error
13:35:42 <erisco> I annotated with the Edge type http://lpaste.net/97806
13:36:47 <jfischoff> oh I see
13:36:54 <jfischoff> @hoogle Show1
13:36:55 <lambdabot> No results found
13:37:42 <jfischoff> http://hackage.haskell.org/package/prelude-extras-0.3/docs/Prelude-Extras.html#t:Show1
13:37:49 <jfischoff> I think you will need that
13:38:32 <jfischoff> for the 't' type variable
13:39:27 <jfischoff> erisco: does that make sense?
13:39:40 <zammy> happy new year from 35 minutes to all +3 UTC
13:40:13 <erisco> jfischoff, yes
13:55:43 <meiji11> I'm reading a bit of code where a type s of kind (* -> *) is being passed a value p as a type parameter. I'm very certain that p is not a type, it's a value. how does that work?
13:57:31 <roconnor_> meiji11: huh?
13:58:39 <k00mi> meiji11: are you sure it's haskell? maybe TypeLits?
13:59:20 <k00mi> or any of the other almost-dependent types-extensions
14:01:13 <Cale> meiji11: Can we see that Haskell code?
14:03:00 <Cale> meiji11: There's DataKinds, which automatically lifts data declarations like data Nat = Zero | Succ Nat you make so that e.g. Nat is also introduced as a new kind, and Zero and Succ are introduced as type constructors of kind Nat and Nat -> Nat
14:09:24 <osa1> I'm losing too much time searching for which package exports a module ... is there an easy way to do this?
14:09:36 <hpc> hoogle?
14:09:58 <osa1> it never works
14:10:10 <osa1> try this as an example: Snap.Snaplet.Heist
14:10:22 <osa1> I gave up trying hoogle after a while
14:10:50 <Ankhers> Is there a channel for Haskell code review?
14:10:54 <twiceler> osa1: I usually Google "hackage Whatever.The.Module", but obviously that's not a great system :)
14:10:58 <geekosaur> hayoo can do it ... when it's up, meaning not since sometime last week :/
14:11:15 <Taneb> ghc-pkg find-module Snap.Snaplet.Heist
14:11:24 <osa1> twiceler: wow that worked surprisingly good :-)
14:11:34 <Taneb> osa1, ^
14:11:50 <hpc> geekosaur: they should make a bitcoin price tracker called hayoo
14:11:54 <hpc> so it can go up and down all day long
14:12:05 <osa1> Taneb: aweome! you just saved hours for me
14:12:07 <osa1> thanks
14:12:56 <Taneb> :)
14:13:28 <erisco> Cale, I have an interesting formulation for depth and breadth graph searching
14:13:36 <erisco> Cale, you can look forward to it after I have dinner. in a few hours :D
14:13:43 <erisco> Cale, I'll need your advice
14:13:59 <hpc> erisco: but will it fit in this margin? ;)
14:14:28 <erisco> hpc, what do you mean?
14:14:28 <Cale> osa1: What I do is just search Hackage
14:14:35 <hpc> erisco: bad fermat joke
14:14:49 <erisco> hpc, oh, lol, now I know what you mean
14:14:58 <erisco> well hopefully I do not choke on dinner and die
14:15:06 <Cale> Or just google, rather, since Hackage's search is a bit weird lately
14:15:06 <erisco> but my finding is not nearly as significant anyways :P
14:15:14 <Cale> http://hackage.haskell.org/package/snap-0.6.0.2/docs/Snap-Snaplet-Heist.html
14:15:35 <Cale> http://hackage.haskell.org/package/snap-0.13.1.2/docs/Snap-Snaplet-Heist.html <-- real one
14:15:56 <Cale> (The only downside of google is that you always get linked to old documentation)
14:16:17 <DigitalKiwi> only? :)
14:16:37 <hpc> doesn't it work with snap-latest?
14:16:50 <hpc> no :(
14:17:19 <hpc> what would happen if i uploaded a package called snap-0.13.1.2?
14:17:44 <hpc> hackage clearly doesn't reject packages with numbers or hyphens in the name
14:18:07 <mgsloan> This chrome plugin really helps with that problem: https://chrome.google.com/webstore/detail/hackage-fu/dnpldbohleinhdgfnhlkofpgkdcfcfmf
14:18:20 <mgsloan> Probably hackage should just start serving this plugin's JS orso
14:18:43 <hpc> or server-side it
14:18:54 <hpc> because some of that is just useful to have anyway
14:19:10 <mgsloan> Yeah, I'm guessing that might require regenerating all the haddocks tho
14:19:26 <mgsloan> probably adding js would require something similar anywho
14:19:56 <mgsloan> I'm not sure, hopefully there's some shared js / css on those pages
14:21:16 <mgsloan> Darn, that was too hopeful.  Looks like the only js file is generated along with the haddocks....
14:21:32 <mgsloan> And has a type error in it "Cannot read property 'replace' of undefined "
14:22:34 <Cale> mgsloan: thanks for that link
14:22:46 <Cale> mgsloan: Though obviously, this is something which ought to be built in to hackage :)
14:22:52 <mgsloan> Welcome!  I heard about it from edward (so it must be good ;) )
14:22:57 <mgsloan> agreed
14:24:41 <mgsloan> So I guess the steps would be #1) Have a flag for haddock to generate a dependency on some shared js file #2) Write this shared js file (probably copying this extension) #3) Regenerate all the haddocks
14:27:35 * mgsloan posts this link to reddit
14:29:36 <mgsloan> Ah, it's already up
14:34:01 <meiji11> Cale: sorry, I was afk for a while.. it's actually in the configurations paper that the reflections library is based on.
14:34:16 <meiji11> Cale: I'll drudge up the paper / page the code is on, and send you the link..
14:34:21 <Cale> ok
14:35:22 <meiji11> Cale: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf, page 7, the first snippet of code under 4.3
14:35:53 <meiji11> it's "where p = reflectStorable (undefined :: s p)"
14:36:39 <Cale> oh, that's definitely a typo
14:36:52 <Cale> That p ought to be an a
14:38:33 <Cale> Also, you'll need the ScopedTypeVariables extension
14:38:44 <meiji11> p makes an appearance in the same context later, I assume that's also a typo?
14:38:56 <Cale> Where?
14:39:15 <meiji11> in the reify function definition, just below reflectStorable
14:39:15 <Cale> oh, yeah
14:40:41 <meiji11> ok, that's good. I wasn't completely off thinking that couldn't be correct, then. thanks.
14:41:52 <Cale> In newer papers, you'll find more and more stuff which involves parameterising types by values, but something like a StablePtr at the type level is pretty far out there :)
14:46:13 <enthropy> meiji11: it might have been intentional that the "value" carried with the type variable 'p' becomes an actual variable also called 'p'
14:46:34 <enthropy> they are in different namespaces
14:46:50 <meiji11> enthropy: they never mention that in the paper.
14:47:31 <enthropy> kind of like data A = A, gives you an A in two different namespaces
14:48:39 <Cale> Well...
14:48:43 <meiji11> enthropy: right, but that's needlessly confusing, isn't it? why not give it a separate name and offer some explanation, if they didn't originally mean a.
14:49:08 <Cale> Let's sort out what type p (at the value level) needs to have here
14:49:50 <Cale> class ReflectStorable s where reflectStorable :: Storable a => s a -> a
14:50:08 <Cale> class Reflect s a | s -> a where reflect :: s -> a
14:50:32 <Cale> We're writing an instance of Reflect (Stable s a) a
14:50:51 <Cale> So, reflect :: Stable s a -> a
14:51:23 <Cale> The do-block inside the definition, since it's inside an unsafePerformIO, then has type  IO (Stable s a -> a)
14:51:47 <Cale> Its last statement is  return (const a)  which means that a :: a
14:51:57 <Cale> a <- deRefStablePtr p
14:52:01 <RustyShackleford> is there a good IDE for Haskell?
14:52:12 <RustyShackleford> or do you just use a text editor/
14:52:17 <Tekmo_> Text editor
14:52:19 <nooodl> nah everybody uses notepad.exe
14:52:31 <Cale> deRefStablePtr :: StablePtr a -> IO a
14:52:37 <Cale> So, p :: StablePtr a
14:52:43 <Tekmo_> There are two IDEs worth mentioning
14:52:51 <Tekmo_> There is FPComplete's web-based IDE
14:52:58 <Komier> I like Sublime Text 3 witht he SublimeHaskell and SublimeREPL plugin
14:53:05 <Tekmo_> There is also `yi`, which is starting to be developed again, I think
14:53:16 <Tekmo_> There is also `emacs` with `haskell-mode`
14:53:24 <Tekmo_> I personally use just `vi`
14:53:37 <Cale> p = reflectStorable (undefined :: s _)
14:53:58 <Cale> reflectStorable :: (ReflectStorable s, Storable a) => s a -> a
14:54:04 <dhrosa> there's also structured-haskell-mode for emacs whcih is really nice: https://github.com/chrisdone/structured-haskell-mode
14:54:49 <Cale> So, since p :: StablePtr a, we'd better have _ be StablePtr a
14:54:59 <Cale> So, in fact, even a would have been wrong
14:55:15 <hpc> Tekmo_: not even vim? what a rebel!
14:55:19 <Tekmo_> hpc: Ha! :)
14:55:31 <Tekmo_> hpc: What can I say.  I like my undo to be horrible
14:55:40 <gienah> seems strange that everyone forgets about leksah ide - it is in developmen on github
14:56:21 <Cale> nooodl: Notepad.exe doesn't satisfy the basic requirement of being able to convert tabs to spaces automatically.
14:56:29 <Guest28510> The last release was March of last year
14:56:38 <Guest28510> wrt Leksah
14:56:40 <edwardk> :t (??) -- davean
14:56:41 <lambdabot> Functor f => f (a -> b) -> a -> f b
14:56:46 <edwardk> ^-- fancy flip
14:56:59 <gienah> it is still actively developed - the last release is really tough to compile
14:57:16 <Cale> I think basically any editor is good for Haskell if it can convert tabs to spaces automatically. Syntax highlighting can also be nice.
14:57:39 <Cale> Also, continuing the next line at the indentation level where the previous left off is nice.
14:57:48 <Guest28510> :i (??)
14:57:55 <dv-> also, flymake
14:58:16 <Cale> But nobody has really implemented the feature which I think would really make editing Haskell source nice
14:59:11 <Taneb> Cale, what would that be
14:59:20 <Cale> Which is awareness of layout keywords: any edit you make which causes the first non-whitespace character following "let", "of", "do", or "where" to move, should cause the entire block of code following that to move analogously.
14:59:41 <Tekmo_> You ask too much! :)
15:00:03 <Tekmo_> What do we look like, programmers?
15:01:01 <Cale> (up until a line which starts in a column shallower than that first non-whitespace character mentioned)
15:06:40 <Cale> RustyShackleford: But for the most part, GHCi + any text editor sort of does the jobs that any IDE would do.
15:07:05 <Cale> It doesn't do the extra stuff which a really *good* IDE for Haskell would do
15:07:49 <Cale> In particular, things like using resumable parsers to parse and compile as much of the Haskell source as it can while you edit it in order to provide live feedback on types
15:08:21 <Cale> (Or even not-so-live feedback on types, whenever you reach a point where the source compiles)
15:09:35 <Cale> It's nice to have things like being able to point at variables within definitions and have their types appear.
15:09:41 <lightquake> Cale: one thing i like is using hdevtools check with -fdefer-type-errors
15:10:53 <lightquake> though you get incorrect results if you try to get the type of subexpressions of a non-typechecking expression, even if those subexpressions typecheck (for example, in "hello" && True, i think it'll say that the type of "hello" is Bool)
15:11:29 <lightquake> Cale: also, chrisdone is trying to do that with structured-haskell-mode
15:11:58 <Cale> structured-haskell-mode is cool, but I'm not sure how much I'd enjoy actually trying to input code like that
15:16:03 <lightquake> i don't use it myself yet because it's still kind of unstable. maybe in a month or two.
15:17:18 <mgsloan> Yeah, I'd really love to do some type slicing / partial parsing stuff for FPHC.  We're also considering integrating structured-haskell-mode at some point, also once it's more stable
15:17:51 <mgsloan> That's one of my #1 bothers atm, is that you most want type info when there are type errors
15:18:05 <mgsloan> But you can't get type info from GHC when there are type errors
15:18:30 <lightquake> you can with -fdefer-type-errors
15:18:45 <lightquake> which landed in, I think, 7.6
15:19:11 <mgsloan> Aye, so maybe we'll be able to leverage that once 7.8 is released and support is added for ti
15:19:45 <Cale> mgsloan: It was surprising to me as well, but -fdefer-type-errors is in 7.6!
15:20:08 <Cale> I'm not sure why I thought that was left to 7.8
15:20:18 <lightquake> i wish there was some way for the type-checking thing to also tell you 'this type might be unreliable'
15:20:36 <Cale> It should be able to tell you both the inferred and expected type
15:20:41 <lightquake> yeah, that
15:20:48 <mgsloan> Well, currently FPHC uses GHC 7.4
15:21:11 <mgsloan> The next release will give you both the monomorphic and polymorphic type for sub-expressions
15:21:26 <mgsloan> Sometimes even the type-family-instantiated version
15:21:43 <lightquake> ooh, would that mean that if you did something like `let x = True` in const x and asked for the type of the `x` in `const x` it'll tell you `inferred type Bool, expected type forall t. t`?
15:22:05 <mgsloan> Yup, pretty much like that
15:22:08 <lightquake> neat
15:22:14 <lightquake> is that a feature of ghc 7.8 or of FPHC?
15:22:22 <mgsloan> next release of FPHC
15:22:37 <lightquake> huh. how do you do that?
15:23:42 <mgsloan> You'd have to ask edsko, I'm not sure how the guts of it work.  But it's all info that's accessible via GHC's API
15:24:41 <fread2282> Why isn't data-default in haskell platform?
15:24:42 <lightquake> ah, cool. i knew it exported the inferred, but i didn't know you could get at the expected type too. might see if i can add that to hdevtools
15:25:17 <mgsloan> Oh noes, now I'll get in trouble for spilling the beans :P
15:25:17 <chrisdone> cale: have you tried structured-haskell-mode?
15:25:34 <lightquake> hell, maybe that's what's necessary to make hdevtools check with -fdefer-type-errors be reasonable: try to unify the types and if they don't spit out a warning
15:25:35 <Cale> chrisdone: I've just watched you use it
15:25:46 <Cale> chrisdone: But those videos were kind of old
15:25:47 <lightquake> mgsloan: haha
15:26:47 <chrisdone> cale: see auto-reindenting https://github.com/chrisdone/structured-haskell-mode#features
15:28:01 <Cale> chrisdone: Well, that's cool. Can I *just* use that feature? :)
15:29:52 <Cale> Well, I should definitely try this myself anyway
15:36:06 <chrisdone> cale: if you just want to use that function you can make a post-self-insert-hook and call shm-adjust-dependents
15:37:54 <c_wraith> fread2282: because the Default class doesn't have any laws associated with it.  That makes it little better than random noise from a rigorous standpoint.
15:39:20 <lightquake> now i just need to actually *find* the part where the expected types are exposed
15:53:13 <Guest34434> Why does the following fail with "expecting "..."? parse (string "..." <|> string ".") "" "."
15:53:54 <lightquake> Guest34434: parsec doesn't backtrack. it starts to parse it as `string "..."` and doesn't 'let go' once that fails
15:54:08 <lightquake> you can use try (string "...") <|> string "." instead
15:54:27 <Guest34434> Hm, this is confusing: "The parser p <|> q first applies p. If it succeeds, the value of p is returned. If p  fails without consuming any input, parser q is tried."
15:54:47 <Guest34434> Ah, "without consuming any input..."
15:54:49 <Guest34434> Got it.
15:54:58 <BMeph> Got it in one. :)
15:55:00 <lightquake> yeah.
15:55:11 <zRecursive> Can Foo.o, created by `ghc -c Foo.hs`, be used by ghci directly wiyhout Foo.hs ?
15:55:29 <zRecursive> s/wiyhout/without
15:55:59 <Guest34434> lightquake: Ah, if I swap "..." with ".", I can't parse "..." properly.
15:56:10 <Guest34434> parse (string "." <|> string "...") "" "..." returns Right "."
15:56:16 <dv-> Guest34434: use try like lightquake said
15:56:52 <Guest34434> Meh, I didn't see the word "try"... I should learn to read.
15:57:02 <enthropy> you can also take the common prefix out:   do a <- string "."; b <- fmap Just (string "..") <|> return Nothing
15:57:15 <zRecursive> who would shed a light on me ?
15:57:56 <fread2282> @hoogle Functor f => f a -> a
15:57:56 <lambdabot> Language.Haskell.TH.Syntax Q :: (forall m. Quasi m => m a) -> Q a
15:57:56 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
15:57:56 <lambdabot> Data.Monoid getDual :: Dual a -> a
15:58:09 <enthropy> zRecursive: I think it needs the .hi file
15:58:37 <zRecursive> enthropy: .hi + .0 will be enough ?
15:58:58 <fread2282> @hoogle unsafePreformIO
15:58:58 <lambdabot> No results found
15:59:54 <nstdloop> @hoogle unsafePerformIO
15:59:54 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
15:59:54 <lambdabot> Foreign unsafePerformIO :: IO a -> a
16:00:58 <nstdloop> can 'a' in a type signature represent a function?
16:00:58 <enthropy> zRecursive: when you install a package locally, those plus a .conf file are enough to use the module from somewhere else
16:01:05 <lightquake> fread2282: what are you trying to do?
16:01:33 <fread2282> lightquake: play around with Show :), nothing useful or harmful
16:01:52 <enthropy> the details could be a bit more complicated (say if you want profiling, a shared library instead)
16:01:52 <Cale> nstdloop: Type variables in general can be unified with any type whatsoever
16:01:53 <lightquake> nstdloop: yes
16:01:54 <zRecursive> enthropy: i see. i just donot want to show the source to the user
16:02:06 <enthropy> there is kind of some source in the .hi file
16:02:12 <nstdloop> Interesting
16:05:40 <lightquake> so, why doesn't `newSTRef False :: forall s. ST s (ST s Bool)` typecheck? isn't that just making the forall explicit?
16:05:43 <Cale> nstdloop: As a stupid example, you can imagine taking the length of a list of functions.
16:05:56 <Cale> nstdloop: As a more interesting one, you can do things like this:
16:06:06 <nstdloop> Right. That seems obvious now.
16:06:08 <Cale> > foldr (\x xs -> xs . (x:)) id [1..10] []
16:06:09 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
16:06:46 <Cale> lightquake: because False isn't an ST s Bool?
16:06:52 <Cale> er
16:06:57 <Cale> no, that doesn't even...
16:07:17 <Cale> newSTRef False :: ST s (STRef s Bool)
16:07:24 <lightquake> oh wait it does, I was misreading my own code
16:07:46 <lightquake> ... ok, I think it finally clicked why STM gives you the safety it does
16:07:56 <Cale> You mean ST?
16:08:01 <lightquake> yes
16:08:11 <Cale> (STM is something else :)
16:08:38 <Cale> The more interesting case is why something like  runST (newSTRef False)  won't typecheck
16:08:39 <lightquake> right, right. i was thinking 'ST Monad' and got mixed up
16:09:07 <Cale> :t runST
16:09:08 <lambdabot> (forall s. ST s a) -> a
16:09:10 <lightquake> right
16:09:33 <Cale> It's because the 'a' must be decided on before 's' is in scope.
16:09:33 <lightquake> it's because you can't turn forall s. ST s (STRef s Bool) into ST (forall s. s) (STRef (forall s. s) Bool)
16:09:41 <Cale> and so it can't contain any reference to 's'
16:10:29 <lightquake> that's also true
16:15:35 <AfC> I need to get GHC 7.6 onto a Debian Wheezy (ie stable) system. I have it on unstable obviously, but has someone already packaged / backported it?
16:17:07 <Guest34434> How can I parse all characters except a given set of characters? What combinator should I use to combine many anyChar with string "...", for instance?
16:21:00 <pavonia> Guest34434: Do you want something like noneOf "."?
16:22:18 <Guest34434> pavonia: Yeah, but I also want to pass strings not just characters.
16:22:29 <Guest34434> For instance, I want to exclude "..." and ".".
16:22:42 <Guest34434> In other words, I need the reverse of <|>, it seems.
16:23:25 <Guest34434> Currently, trying manyTill.
16:25:24 <pavonia> maybe try (string "..." >> mzero) <|> many anyChar works
16:32:28 <Komier> hmm
16:34:10 <Komier> I am working on a few of the easy project euler problems.  I figured a solution for number 4 using list comp... but it seems to me that's a clumsy way of doing it.  And slow.
16:36:26 <countoren> hello,  is there a way to include a variable into $(widgetFile "some hardcoded string") replacing the hardcoded string  in a yesod app?????
16:37:45 <Cale> countoren: Yes, but note that that's a splice, so it's evaluated at compile time and expands to some bunch of code
16:38:13 <countoren> what do u mean by spilce
16:38:28 <countoren> splice*
16:38:54 <Cale> $(expr) will evaluate expr to produce a syntax tree of Haskell code, and then put whatever that code was in that spot
16:39:03 <Cale> It's a macro expansion which occurs at compile time
16:40:13 <Cale> So, whichever String variable you put there had better be some constant which is possible to evaluate at compile time.
16:40:40 <countoren> yes i understand
16:41:20 <countoren> so if the method is called from onther yesod  tamplate it wont
16:41:31 <countoren> be avilable at run time?
16:41:40 <countoren> sorry
16:41:46 <countoren> compile time
16:42:29 <Cale> Well, if you're expanding this inside of some lambda for instance, the variable that the lambda binds isn't in scope there.
16:43:14 <Cale> I actually forget the precise rules, you may have to define the String in a separate module entirely, or perhaps the definitions physically above the one where you use the splice will be in scope.
16:46:29 <joejev> in a list comprehension, would lists a and b be evaluated more than once in a situation like [f a' b' | a' <- a, b' <- b]
16:47:52 <Cale> joejev: no
16:48:07 <Cale> joejev: any variable whatsoever is evaluated at most once while it remains in scope
16:48:08 <joejev> Cale: Thanks
16:48:23 <Cale> (that's part of what lazy evaluation is)
16:48:39 <Cale> (the other part being that expressions are evaluated outermost-first)
16:49:38 <oleo> happy new year all!
16:49:45 <countoren> Cale: lost you a little bit , lets try to make simpler for me , if i have this method : fromTamplate varString = $(widget varString)   which in somway i  intreduced there a string $(expr) . and im calling this method from onther yesod template : ^{fromTamplate "header"} doest it will work?
16:50:20 <joejev> oleo: Happy new year future dweller
16:50:36 <Cale> Your definition of fromTemplate there won't parse, because varString won't be in scope in the splice
16:52:02 <Cale> (I actually don't know very much about Yesod's template languages, so I'm perhaps not the ideal person to be trying to help here, but the $(...) is just a plain Template Haskell thing)
16:52:34 <lightquake> countoren: what are you actually trying to do?
16:53:48 <countoren> lightquake: well i want to be able to call widget from a tamplate without me changing haskell code
16:54:09 <lightquake> what do you mean?
16:54:24 <countoren> for example
16:55:32 <countoren> home.hamlet =>  ^{fromTamplate "somefile"}
16:56:14 <lightquake> oh, you can't include templates by name like that. well, you *can* but it'll be huge amounts of work and is probably not what you want to do
16:56:50 <lightquake> instead, you should just make sure that you have your template in scope as a regular variable and include it normally
16:56:51 <countoren> well button line i want that the guys doing the html wont have to mess with haskell
16:56:52 <countoren> code
16:57:58 <countoren> and give them the avility to create sub tamplates
16:58:29 <lightquake> oh, you're going to need to modify code for that... unless you do some fairly massive hacking
16:59:45 <countoren> well i guess massive hacking atm  is out of the picture any other options?
17:00:54 <lightquake> can't think of any at the moment.
17:01:13 <countoren> well one thing easy todo
17:01:21 <countoren> is just
17:01:36 <countoren> didnt try it but i think it will work
17:01:42 <lightquake> what?
17:02:18 <countoren> have the method in tamplate : ^{fromTamplate "header"}
17:02:30 <lightquake> that's not going to work
17:02:30 <countoren> and then in haskell to have something like
17:03:05 <lightquake> templates are turned into haskell code by hamletFile and similar functions at compile time, but the things you interpolate inside them are only evaluated at runtime
17:03:29 <countoren> fromTamplate varString | varString == "header = $(widgetFile "header")
17:03:36 <countoren> ...
17:04:35 <lightquake> oh, like that
17:04:49 <countoren> will work?
17:04:55 <lightquake> yeah that works, but then what's the point? why not just have headerTemplate = $(widgetFile "header") and ^{headerTemplate}?
17:06:36 <lightquake> your method also doesn't stop you from accidentally typo-ing and doing ^{fromTemplate "hadar"}, which is an error that will only show up when you try to load the page
17:07:09 <countoren> yes you are right
17:07:58 * lightquake considers the logistics of a template-template transclusion patch... probably a bad idea
17:10:13 <countoren> thanks man , to conculde  the main problem here was that the syntax $() is getting parsed in compile time which in this point of time the variable of function is not in scope . got it correctly?
17:11:42 <Guest34434> pavonia: parse (manyTill anyChar (string "foo")) "" "lalalfoobar" works, FYI.
17:13:04 <lightquake> basically. the $(hamletFile "template") syntax means 'evaluate the expression `hamletFile "template"` and splice the resulting Haskell code in at this point', which requires a pre-compilation step. in order to splice in the result of a hamletFile call from within a template, hamlet would have to support adding another splice to the splice it's currently generating, which it doesn't currently
17:13:17 <Komier> maximum[x*y | x <- [100..999], y <- [100..999], reverse(show(x*y)) == show(x*y)]   Is there an obvious way of optimising something like this so that it stops as soon as the first match is found?
17:13:18 <Guest34434> pavonia: But what if I want to match until the last "foo"?  For instance, for "lalafoobarfoobaz", I should get "lalafoobar". Any ideas?
17:13:27 <lightquake> so you could make this work if you patched hamlet, I think. but I don't think snoyberg would accept it.
17:13:51 <lightquake> Komier: well, you want to find the maximum, so you can't exit early
17:14:24 <Komier> lightquake: Aye but if i generated x and y from lists that count down instead? [999..998]
17:14:56 <lightquake> GHC isn't smart enough to be able to prove that the first number you find is the maximum... and in fact it might not be
17:15:57 <Komier> lightquake: Ah yeh, it wouldn't necessarily do 999* 999, 999*998 and so on in that order?
17:16:42 <lightquake> well, consider this: [x * y | x <- [1000, 999 .. 0], y <- [1000, 999 .. 0], reverse (show (x * y)) == show (x * y)]
17:17:09 <lightquake> the first match it finds will be when x = 1000, y = 0, but that's obviously not the maximum
17:18:13 <Komier> lightquake: yes I see.  Thanks.
17:18:32 <lightquake> GHC can't do complicated algebra
17:19:23 <Komier> I got the right answer, was just trying to think of ways to optimise it / make it neater.
17:20:12 <lightquake> well, one thing you can do is use the fact that if (a, b) is a valid pair then any valid pair (c, d) with a larger product must have c > a or d > b
17:20:21 <lightquake> but at that point you can't write it as a list comprehension
17:22:01 <benzrf> hi
17:22:25 <benzrf> is a type of kind * -> * ever not an instance of Functor?
17:22:44 <Komier> lightquake: Ok, thanks again.
17:24:28 <pqmodn> benzrf: sure, data Void x with no constructors cannot be a Functor
17:24:52 <mgsloan> pqmodn: Hmm, why not?
17:24:58 <mgsloan> Oh nvm
17:24:59 <twiceler> pqmodn: why not fmap f = id?
17:25:13 <benzrf> twiceler: nice nick
17:25:23 <mgsloan> instance Functor (Void a) where fmap _ = undefined
17:25:26 <mgsloan> :D
17:25:28 <pqmodn> yeah
17:25:34 <benzrf> pqmodn: what about for inhabited types?
17:25:51 <twiceler> wait, why doesn't fmap f = id work there?
17:25:55 <pqmodn> benzrf: i'm not sure, but i suspect there are non-Functor examples
17:26:04 <mgsloan> twiceler: The type needs to change
17:26:16 <benzrf> @data
17:26:16 <lambdabot> Unknown command, try @list
17:26:18 <benzrf> hmm
17:26:27 <pqmodn> @type fmap undefined
17:26:28 <lambdabot> Functor f => f a -> f b
17:27:09 <mgsloan> Yeah, "const undefined" could be used to define a functor instance for any (* -> *), but that's a bad idea, and usually wouldn't satisfy laws (except for with Void)
17:27:24 <benzrf> ok, make that a laws-abiding instance
17:27:25 <benzrf> o:
17:27:28 <mgsloan> Err, "const (const undefined)"
17:27:36 <benzrf> :t const $ const undefined
17:27:36 <twiceler> mgsloan: oh, okay. Well I guess undefined works, since it's never called? Anyway, if you use GADTs, you can restrict what types are possible
17:27:36 <lambdabot> b -> b1 -> a
17:28:03 <mgsloan> twiceler: Yeah, but I don't think it'd be a good idea to add it, because it'd give the impression of it being a valid thing to do
17:28:26 <benzrf> isnt there some kind of specification in the works for allowing you to implement derivation for your own typeclasses
17:29:01 <pqmodn> benzrf: Set is one example. it can't be a Functor because an Ord constraint is required, but not declared by Functor. though you're probably looking for a more satisfying example
17:29:02 <marx2> what is your opinion, is this appropriate use of unsafeCoerce? path = unsafePerformIO $ getEnv "PATH"
17:29:09 <marx2> unsafePerformIO*
17:29:11 <benzrf> pqmodn: yeah...
17:29:26 <benzrf> marx2: since when is unsafeperformio ever ok?!
17:29:44 <benzrf> marx2: if you want that use reader
17:29:44 <marx2> benzrf it must be sometimes, otherwise why would they provide it
17:29:44 <twiceler> marx2: I'd imagine so
17:30:03 <benzrf> marx2: isnt it mainly for use with ffis
17:30:37 <marx2> that's one use of it, yeah
17:30:52 <benzrf> marx2: why not just use Reader for things like your example
17:30:53 <twiceler> At least in my opinion, if you don't think that changing order or time of evaluation will change your result, it's okay to use unsafePerformIO
17:31:13 <marx2> anyway, my rationalization.. the path value is immutable in the sense that it won't change during the duration of the program
17:31:40 <benzrf> marx2: just use readerr
17:32:04 <geekosaur> but it can, because something in IO can use putEnv / setEnv
17:32:15 <marx2> i've never used it before. in what way would it be different than just path = getEnv "path" ?
17:32:26 <benzrf> marx2: used what?
17:32:50 <pqmodn> marx2: that's not guaranteed. another part of your program can change the environment with setEnv http://hackage.haskell.org/package/unix-2.4.0.2/docs/System-Posix-Env.html
17:33:11 <pqmodn> marx2: of course, you may happen to know that's not the case.
17:33:11 <marx2> that's true
17:33:22 <marx2> I do
17:33:57 <benzrf> mehhh
17:34:13 <benzrf> marx2: seriously, why not just use reader??
17:34:14 <marx2> I see no reason to change PATH it in the middle of a program
17:34:23 <geekosaur> (and then there's the clever folks elsechannel who think they can solve $problem by attaching ti a running process with gdb and pushing a new envar into it...)
17:34:29 <BMeph> marx2: Do you also know that no one else will ever use your program, that will also abide by your requirements? :)
17:34:30 <zRecursive> After `cabal install` a customized module Foo, how can i use it on command line ? it seems `ghc -ignore-dot-ghci -e "import Foo; foo" doesnot work.
17:34:50 <zRecursive> foo is a function in Foo.hs
17:35:18 <jacco> benzrf: think about a Functor instance for the following type: newtype Pred a = T (a -> Bool)
17:35:39 <benzrf> hmmm
17:35:44 <benzrf> ah
17:35:57 <benzrf> i actually just read an article on other kinds of functors that arent Functors...
17:36:03 <pqmodn> oh, that's right. cofunctors
17:36:05 <benzrf> that would be a contravariant functor, right?
17:36:14 <geekosaur> zRecursive, not sure it is smart enough to parse that. but ... -e 'Foo.foo' might work?
17:36:26 <benzrf> so would every inhabited type of kind * -> * be either a Functor or a Contravariant?
17:36:31 <geekosaur> presuming it needs no parameters
17:36:43 <roconnor_> newtype Foo a = Foo (a -> a)
17:36:51 <benzrf>                     -ignore-dot-ghci -e "import Foo; foo" doesnot work.
17:36:53 <benzrf> oops
17:37:33 <benzrf> roconnor_: cant you just do a standard ((->) r) instance for that
17:37:49 <roconnor_> benzrf: give it a try
17:37:49 <pqmodn> benzrf: try it :)
17:37:54 <simpson> benzrf: fmap :: (a -> b) -> (a -> a) -> b -> b
17:38:09 <simpson> @djinn (a -> b) -> (a -> a) -> b -> b
17:38:10 <lambdabot> f _ _ a = a
17:38:20 <zRecursive> geekosaur: `-e "Foo.foo"` reports : <interactive>:1:1: \n  attempting to use module `Foo' (./Foo.hs) which is not loaded ...
17:38:28 <benzrf> ohhh
17:38:29 <benzrf> derp
17:38:32 <benzrf> i feel silly...
17:38:39 <simpson> Doesn't satisfy the law, though.
17:38:46 <benzrf> simpson: yeah
17:39:04 <geekosaur> um. normally it should load modules implicitly. I suspect thatis because uou have the same module still in . and it is becoming confused?
17:40:07 <benzrf> geekosaur: wait shit
17:40:11 <benzrf> ghci does that?!
17:40:15 <zRecursive> geekosaur: After changing current directory, it reports "<interactive>:1:1: Not in scope: `Foo.foo'"
17:40:17 <benzrf> why did nobody tell me this!
17:40:21 <benzrf> >:o
17:40:27 <geekosaur> ghci does. I expected ghc -e to do so.
17:41:13 <zRecursive> ghci reports: "ghc: on the commandline: cannot use `--interactive' with `-e'"
17:41:34 <geekosaur> ... I am not sure why you would think that that was an idea
17:41:53 <L8D> How can I do time delays in Haskell?
17:42:07 <zRecursive> geekosaur: i donot want to give user source
17:42:07 <L8D> Or 'sleep's
17:42:13 <geekosaur> Control.Concurrent.threadDelay --- beware; parameter is microseconds
17:42:24 <L8D> o.o
17:42:29 <geekosaur> zRecursive, then you have already lost
17:42:40 <zRecursive> lost what ?
17:42:46 <geekosaur> or have you never noticed how often things need to be rebuilt against different libraries?
17:42:57 <geekosaur> "no source" is a losing proposition with ghc
17:43:01 <lightquake> benzrf: data Enumeration a = Enumeration (a -> Integer) (Integer -> a)
17:43:14 <lightquake> not a covariant or contravariant functor
17:43:18 <benzrf> shit
17:43:43 <benzrf> anyway...
17:44:08 <benzrf> a single sum type + pattern matching is semantically equivalent to a typeclass + methods, right?
17:45:05 <oleo> if the methods stay within that type ?
17:46:46 <geekosaur> zRecursive, btw, ``` ghc -e 'import Data.List' -e 'print $ sort [1..3]' ``` works here
17:46:57 <geekosaur> although I don't know if it just ignores the import
17:47:41 * hackagebot postgresql-orm 0.2.3 - An ORM (Object Relational Mapping) and migrations DSL for PostgreSQL.  http://hackage.haskell.org/package/postgresql-orm-0.2.3 (AmitLevy)
17:48:04 <L8D> Is there any situation where one might use Either _ () over Maybe _ ?
17:48:27 <mgsloan> L8D: If you're using either for a lot of other things that might fail
17:48:34 <mgsloan> Err
17:48:50 <mgsloan> better yet, if you have an informative error message / error type
17:49:13 <mgsloan> I suppose it'd really be a difference between "Either () _" and "Maybe _"
17:49:26 <L8D> Well, for some reason my friend is using Either _ () in his code
17:49:42 <mgsloan> Is "_" Text?
17:49:43 <lightquake> L8D: ask them why?
17:49:43 <L8D> I don't really get why.
17:49:59 <mgsloan> Or String for that matter
17:49:59 <L8D> lightquake: I will when I talk to them again.
17:50:18 <L8D> I'm just using "_" as a placeholder for other types
17:51:05 <mgsloan> He's probably using the monad instance for either somewhere else
17:51:22 <benzrf> what does fail do and why is it in Monad anyway
17:51:53 <Komier> Another newbie question incoming...... how do you know if your way of solving a problem is reasonable / acceptable?  I just solved a Euler problem, got the right answer..... but other people that have posted on the forum there have used very different methods to mine.
17:52:01 <simpson> benzrf: It's a sad story, but... it's what's called when a pattern match in a draw-from expression fails.
17:52:26 <benzrf> what
17:52:33 <benzrf> @src fail
17:52:33 <lambdabot> fail s      = error s
17:52:38 <benzrf> :|
17:52:53 <simpson> > do { 'b' <- Identity 'a'; }
17:52:54 <lambdabot>  The last statement in a 'do' block must be an expression
17:52:54 <lambdabot>    'b' <- Identity 'a'
17:52:55 <benzrf> thats terrible
17:52:57 <geekosaur> Komier, in the case of the Euler problems, they're generally trying to get you to use some particular solution. this may not be true of other problems
17:52:58 <simpson> Oh, right.
17:53:03 <simpson> > do { 'b' <- Identity 'a'; return () }
17:53:05 <lambdabot>  Identity {runIdentity = *Exception: Pattern match failure in do expression a...
17:53:38 <simpson> benzrf: And this is why pattern matches in draw-froms should be used sparingly.
17:53:44 <benzrf> hold on
17:53:59 <benzrf> why not just do the normal thing that happens when patterns fail?
17:54:00 <benzrf> like
17:54:07 <simpson> Although some monads, like [] and Maybe, have good instances for `fail` and it's not the worst thing.
17:54:09 <benzrf> as if do were actually the result of undo
17:54:14 <Komier> geekosaur : Hmmm.... ok.  I'm only on the very simple problems, but where I used a one liner in ghci, other people there have defined multiple functions and all sorts.
17:54:18 <benzrf> @src Maybe fail
17:54:18 <lambdabot> fail _      = Nothing
17:54:25 <benzrf> @src [] fail
17:54:25 <lambdabot> fail _      = []
17:54:28 <simpson> @undo { 'b' <- Identity 'a'; return () }
17:54:29 <lambdabot> <unknown>.hs: 1: 1:Parse error: {
17:54:33 <simpson> @undo do { 'b' <- Identity 'a'; return () }
17:54:33 <lambdabot> Identity 'a' >>= \ a -> case a of { 'b' -> return (); _ -> fail ""}
17:54:41 <benzrf> oh huh
17:54:46 <benzrf> my bad o_o
17:55:05 <benzrf> i assumed that single variables counted as patterns
17:55:16 <simpson> @undo do { b <- Identity 'a'; return () }
17:55:16 <lambdabot> Identity 'a' >>= \ b -> return ()
17:55:21 <Komier> geekosaur: Just made me wonder if I was missing the point is all.
17:57:00 <benzrf> so what do yall think of scala
17:57:30 <geekosaur> well, for the Euler problems you do want to look at the other solutions, since the idea is usually to focus on some mathematical property. on the other hand, if you are capturing that property in your one-liner then you're doing okay :)
17:58:04 <geekosaur> but in the real world, oftem the best solution is the one that gets the job done. but you often should still think about efficiency, etc.
17:58:28 <bennofs> Is there a way to upload a package candidate via the command line?
17:58:52 * geekosaur sees a "cabal upload"
17:58:59 <benzrf> haha, im reading about scala and i just realized that 'foo, bar, baz => quux' looks weird to me in comparison to 'foo -> bar -> baz -> quux'
17:59:05 <benzrf> probably a good sign
17:59:09 <benzrf> :b
17:59:21 <bennofs> geekosaur: but does that allow you to upload a package *candidate* ?
17:59:36 <Komier> geekosaur: ok ta.
17:59:54 <geekosaur> hm, that I don't know
18:03:19 <zRecursive> geekosaur: thx
18:03:24 <Komier> aaah somebody else did similar to me, but used a lambda instead.
18:04:04 <lightquake> [19:53:33] <benzrf>	 so what do yall think of scala
18:04:37 <lightquake> never used it. edward kmett, one of the big-name haskell devs, has a post about it here: http://www.reddit.com/r/haskell/comments/1pjjy5/odersky_the_trouble_with_types_strange_loop_2013/cd3bgcu
18:05:12 <mgsloan> hahah, yeah that really is the authoritative comparison, with regards to the typesystem anyway
18:05:18 * mgsloan was about to link to it
18:10:45 <L8D> What do I do if I find a typo in core?
18:10:56 <lightquake> L8D: a what in what?
18:11:27 <L8D> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Maybe.html#isJust
18:12:15 <lightquake> what's the typo?
18:12:27 <benzrf> TIL that the top of edwardkmett's head is about the same size and shape as an aircraft carrier!
18:12:29 <benzrf> lol
18:12:49 <L8D> "The 'isJust' function returns 'True' iff its argument is of the form @Just _@"
18:12:58 <lightquake> (also, I think you want to go https://ghc.haskell.org/trac/ghc/ and file a ticket? but it's probably a good idea to look for more typos first)
18:13:08 <lightquake> iff is mathematical shorthand for 'if and only if'
18:13:20 <L8D> wow
18:13:34 <lightquake> if it was 'if' then isJust _ = True would also satisfy that description
18:13:54 <lightquake> which would be a much more Just world
18:14:33 <benzrf> lightquake: would it be verdant and peaceful tho
18:14:37 <mgsloan> In docs, I'd say the "only if" is pretty implicit
18:15:08 <L8D> Is the documentation there as specification or documentation?
18:15:14 <mgsloan> "The nuclear missiles launch if you press the button" doesn't really suggest that there's another cause
18:15:35 <lightquake> "The nuclear missiles laungh xnor you press the button"
18:15:40 <mgsloan> hehe
18:15:42 <lightquake> *launch
18:16:01 <DigitalKiwi> i wasn't sure if you said laugh or launch!
18:16:16 <lightquake> L8D: the authoritative spec is http://www.haskell.org/onlinereport/haskell2010/
18:16:33 <L8D> Thx
18:17:08 <lightquake> the documentation in GHC happens to be a word-for-word copy of the authoritative spec for isJust
18:17:40 <L8D> What is the point of monads when we have functors?
18:18:11 <lightquake> because you can do things with monads that you can't do with just functors
18:18:12 <benzrf> L8D: they do different things
18:18:15 <benzrf> L8D: well, not different
18:18:16 <DigitalKiwi> what else would we confuse new people with
18:18:20 <benzrf> monads are a superset of functors
18:18:31 <benzrf> L8D: not all functors are monads, but all monads are functors
18:18:42 <L8D> How can you not implement all of the monad functions for functors?
18:18:49 <benzrf> *ALL functors
18:18:49 <benzrf> L8D: a monad must have a bind operation that satisfies the monad laws
18:19:07 <benzrf> L8D: i invite you to try implementing bind in terms of fmap
18:19:07 <benzrf> :)
18:19:31 <lightquake> L8D: data Const t a = Const t. there's a Functor instance for (Const t) but no Monad instance
18:19:34 <twiceler> benzrf: I think you mean monads are a subset of functors. All monads are functors
18:19:48 <lightquake> because such a Monad instance would be isomorphic to t -> (a -> t) -> t
18:19:57 <benzrf> oops
18:19:59 <benzrf> my bad >_>
18:20:01 <lightquake> and you can't make that satisfy the laws
18:20:57 <lightquake> oh wait no, it's simpler than that, hah
18:20:59 <lightquake> you can't write return
18:21:02 <L8D> Couldn't you just implement bind as flip fmap ?
18:21:15 <benzrf> L8D: examine the types
18:21:17 <benzrf> :t flip fmap
18:21:18 <lambdabot> Functor f => f a -> (a -> b) -> f b
18:21:23 <benzrf> :t (>>=)
18:21:24 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:21:30 <benzrf> a -> m b /= a -> b
18:21:57 <L8D> but they're really close. :(
18:22:04 <benzrf> so are a -> b and b -> a
18:22:23 <benzrf> L8D: again
18:22:45 * hackagebot simple-templates 0.7.0 - A basic template language for the Simple web framework  http://hackage.haskell.org/package/simple-templates-0.7.0 (AmitLevy)
18:22:47 <benzrf> i encourage you to TRY writing bind in terms of fmap
18:22:48 * hackagebot simple 0.7.0 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.7.0 (AmitLevy)
18:22:50 * hackagebot simple-session 0.7.0 - Cookie-based session management for the Simple web framework  http://hackage.haskell.org/package/simple-session-0.7.0 (AmitLevy)
18:22:52 * hackagebot simple-postgresql-orm 0.7.0 - Connector package for integrating postgresql-orm with the Simple web framework  http://hackage.haskell.org/package/simple-postgresql-orm-0.7.0 (AmitLevy)
18:24:12 <Cale> L8D: Here's one way to think about it
18:24:21 <Cale> L8D: In terms of bind, I can write:
18:24:32 <Cale> :t \x -> x >>= id
18:24:33 <lambdabot> Monad m => m (m b) -> m b
18:24:48 <Cale> This reduces the number of occurrences of m in the type of its argument
18:24:52 <Cale> :t fmap
18:24:53 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:25:02 <Cale> Nothing I could write using fmap could ever do that
18:25:09 <L8D> :t (>>= id)
18:25:10 <lambdabot> Monad m => m (m b) -> m b
18:25:15 <Cale> Because fmap leaves the number of occurrences of f the same
18:25:46 <L8D> :t fmap id
18:25:47 <lambdabot> Functor f => f b -> f b
18:26:21 <L8D> But b could constructed by f
18:26:32 <Cale> :t fmap (fmap id)
18:26:33 <lambdabot> (Functor f, Functor f1) => f (f1 b) -> f (f1 b)
18:26:34 <L8D> wait nvm
18:26:39 <Cale> Doesn't help :)
18:27:05 <L8D> What is 'fail'?
18:27:12 <Cale> fail is a mistake in Haskell 98
18:27:25 <L8D> What does it do?
18:27:33 <Cale> It's used in translating the do-notation when you have a pattern match which might not succeed on the left of an <-
18:27:34 <benzrf> terrible unspeakable things
18:27:43 <Cale> In particular, you get:
18:27:58 <benzrf> @undo {'b' <- Identity 'a'; return ()}
18:27:58 <lambdabot> <unknown>.hs: 1: 1:Parse error: {
18:28:02 <benzrf> oops
18:28:05 <benzrf> @undo do {'b' <- Identity 'a'; return ()}
18:28:06 <lambdabot> Identity 'a' >>= \ a -> case a of { 'b' -> return (); _ -> fail ""}
18:28:18 <benzrf> the result is fail "" if the match fails ^
18:28:23 <Cale> uh
18:28:25 <Cale> yeah, okay
18:28:32 <benzrf> but the default impl of fail is to call 'error'
18:28:34 <Iceland_jack> > do {'b' <- Identity 'a'; return ()}
18:28:34 <benzrf> which is terrible
18:28:36 <lambdabot>  Identity {runIdentity = *Exception: Pattern match failure in do expression a...
18:28:54 <L8D> wat
18:29:07 <Cale> do { p <- x ; <stmts> } = x >>= \v -> case v of { p -> do { <stmts> } ; _ -> fail "some error message" }
18:29:13 <Cale> when p is a pattern that might fail to match
18:29:21 <benzrf> http://blog.sanctum.geek.nz/vim-koans/
18:29:23 <L8D> > do { a <- Nothing; return () }
18:29:24 <lambdabot>  Nothing
18:29:31 <L8D> > do { a <- Nothing; return a }
18:29:32 <lambdabot>  Nothing
18:29:42 <geekosaur> because fail in Maybe is Nothing
18:29:47 <L8D> Oh
18:29:53 <L8D> > do { a <- Just 0; return a }
18:29:54 <lambdabot>  Just 0
18:29:55 <Iceland_jack> > do { Just a <- Nothing; return a }
18:29:56 <geekosaur> but in many monads it's an exception via `error`
18:29:57 <lambdabot>  Nothing
18:30:02 <twiceler> So why is fail :: Monad m => String -> m a rather than fail :: Monad m => m a? i.e., why is the string chosen as "do" in do-notation?
18:30:04 <L8D> I see
18:30:05 <geekosaur> which is highly unforutnate
18:30:19 <twiceler> * I mean why is the string chosen as "" in do-notation?
18:30:19 <Cale> If p is a pattern that can't fail (i.e. it's a match against a constructor of a type with only one constructor, or it's a variable, or it is explicitly irrefutable due to a ~), then the simpler translation is used:
18:30:39 <Cale> do { p <- x ; <stmts> } --> x >>= \p -> do { <stmts> }
18:30:47 <geekosaur> I think the idea was that a parser monad could reuse fail to return a parse error
18:30:56 <geekosaur> which, well, there are more useful ways
18:31:00 <Cale> twiceler: It's not
18:31:03 <benzrf> what happens if an irrefutable pattern fails
18:31:09 <Cale> twiceler: It's just @undo which does that
18:31:15 <benzrf> but thats what monadplus does
18:31:21 <geekosaur> it can't, by definition
18:31:23 <Cale> twiceler: The real translation sticks in a message about which line the error occurred on
18:31:24 <benzrf> ??
18:31:34 <ParahSailin> twiceler: the intent was originally that fail would not be called explicitly
18:31:37 <augur> hey Cale
18:31:39 <Cale> (which btw, sort of breaks referential transparency, in a sense)
18:31:40 <geekosaur> irrefutable means can't fail. if it does later fail then it's a normal excdption
18:31:40 <twiceler> Cale: Oh, okay, cool
18:31:41 <benzrf> how do they work then?
18:32:08 <Cale> benzrf: irrefutable patterns never fail to match
18:32:16 <geekosaur> in the same way that a normal pattern match that fails is an exception, because it's likely to be triggered in pure code where nothing else is possible
18:32:21 <augur> Cale: i think oddly, working through zeilberger is what helped locus solum make more sense than before
18:32:33 <benzrf> wait then
18:32:35 <benzrf> what if I have:
18:32:39 <benzrf> data Foo = Bar | Baz
18:32:39 <geekosaur> (that is, if you use ~(a,b) on something that is not a pair, you get an exception in pure code later when something tries to use it)
18:32:43 <Cale> benzrf: You get an error when one of the bound variables is evaluated if you used a ~ irrefutable pattern to match and the pattern didn't actually matched
18:32:50 <benzrf> geekosaur: how is that different than a regular match tho
18:32:51 <Cale> s/matched/match/
18:32:54 <benzrf> it makes it lazier:
18:32:55 <benzrf> ?
18:32:59 <geekosaur> yes
18:33:01 <benzrf> ahihi:
18:33:03 <benzrf> *ah
18:33:52 <geekosaur> it is exactly a lazy pattern match, where they are normally strict (and in fact used to force evaluation)
18:34:02 <benzrf> ah
18:34:12 <benzrf> what does ! do?
18:34:30 <ParahSailin> BangPatterns
18:34:31 <twiceler> benzrf: It evaluates the argument to weak-head normal form
18:34:48 <benzrf> ok, how is that different from a regular pattern?
18:34:53 <benzrf> Im not sure wat whnf is
18:35:11 <Cale> augur: What do you mean by Zeilberger, btw? I only know him from A=B and his opinions page.
18:35:33 <ivanm> twiceler: a bang will evaluate the outer-most constructor
18:35:36 <twiceler> benzrf: If you think of your data as a tree, weak-head normal form means that you've evaluated what the root of the tree is
18:36:00 <twiceler> Which I guess weak-head normal form is not from what ivanm says! Don't listen to me, perahps
18:36:22 <ivanm> twiceler: I could be wrong as well; I haven't touched much haskell for about 6 months :p
18:36:42 <twiceler> ivanm: Well I thought that outer-most constructor = weak-head normal form so perhaps we're both right :)
18:37:00 <Cale> yes, you're both right
18:37:02 <ivanm> yeah, sounds vaguely familiar :p
18:37:16 <benzrf> does ghc save types at runtime?
18:37:21 <Cale> no
18:37:23 <benzrf> ok
18:37:29 <Cale> Compilation removes them
18:37:55 <benzrf> also, does it compile to cpu opcodes, or does it compile to haskell bytecode and get packaged with a runtime?
18:38:27 <ParahSailin> you can -ddump various stages to see what goes on
18:38:28 <Cale> It compiles to native machinecode, but there's also a bytecode which I think is used for ghci interpretation
18:38:58 <Cale> Also, there is a runtime in any case, because the thread scheuler and garbage collector have to go somewhere
18:39:07 <Cale> scheduler*
18:39:13 <Cale> Can't type, pizza
18:39:23 <geekosaur> ghci, ghc -e, runhaskell, and template haskell use the bytecode interpreter
18:39:37 <geekosaur> and yes, there is a runtime, but it's not a virtual machine runtime like the jvm, it is support libraries like for C/C++
18:40:38 <ParahSailin> how do you compile -prof stuff with TH
18:42:07 <benzrf> ghc uses c-- right?
18:42:52 <geekosaur> sort of. it has its own dialect (called cmm) --- but this is an intermediate target
18:42:57 <Cale> It uses something kind of like C--
18:43:23 <Cale> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Cmm
18:44:24 <mmxv> Why does this fail?  let p = string "!" <|> string "." in parse (do x <- manyTill anyChar p; y <- p; return $ x ++ y) "" "foo!"
18:45:01 <ion> Ask Parsec. You should be able to get a parse error message out of it.
18:45:14 <mmxv> unexpected end of input expecting "!" or "."
18:45:21 <mmxv> I still don't understand.
18:46:16 <Cale> Try it with "foo!!"
18:46:21 <mmxv> Ah, yeah.
18:47:02 <mmxv> How can I avoid the second !?
18:47:32 <mmxv> I want 'manyTill' to capture the result of p.
18:47:40 <Cale> You could  manyTill anyChar (lookAhead p)
18:47:57 <Cale> and then have the y <- p as you had
18:48:22 <mmxv> Thank you.
18:49:16 <Cale> You could also rewrite manyTill so that it gives you that extra bit
18:49:23 <Cale> http://hackage.haskell.org/package/parsec-3.1.4/docs/src/Text-Parsec-Combinator.html#manyTill
18:49:47 <mmxv> Nah, I'd rather use lookAhead.
18:49:59 <Cale> You could have  scan = do { v <- end; return ([],v) } <|> do { x <- p; (xs,v) <- scan; return (x:xs,v) }
18:50:37 <Cale> (which is probably more efficient)
18:51:00 <Cale> But yeah, lookAhead is prettier than rewriting manyTill overall :)
18:51:25 <benzrf> thunks + laziness means that most recursion acts tail-like, right?
18:51:47 <benzrf> that is to say, each successive recurse will be at the same depth as the previous
18:51:58 <benzrf> since you return to the above context before evalling the next thunk>
18:52:02 <mmxv> I'm just playing around.  Perhaps, I won't need this part at all, so I'd rather make it high-level.
18:52:12 <benzrf> or am i severely misunderstanding how this stuff works?
18:52:21 <Cale> benzrf: There's no call stack
18:52:40 <Cale> At least, nothing which looks like a call stack from the Haskell programmer's perspective
18:52:59 <Cale> GHC uses the stack, but it's more like a pattern match stack than a call stack
18:53:05 <benzrf> o:
18:53:08 <benzrf> ok
18:53:41 <Cale> (Though it's also used when evaluating the function which is being applied, if it's not already a lambda)
18:54:13 <Cale> (but having that show up as a major source of stack frames is very rare)
18:54:36 <Cale> I've never seen it
18:55:04 <Cale> So, for the most part, you can imagine that the stack consists of case expressions which are waiting for their scrutinee to be sufficiently evaluated to pattern match
18:55:14 <Cale> I don't tend to think about thunks
18:55:26 <Cale> Thunks are just an implementation mechanism for expressions at runtime
18:55:40 <Cale> So, I usually just think about expression graphs being manipulated
18:56:38 <Cale> Going more low-level than that is almost never necessary, unless you're *really* fine tuning some microbenchmark for a language shootout, or you're writing the next Data.ByteString
18:57:52 <Cale> benzrf: Lazy evaluation is outermost-first evaluation, plus sharing (any bound variable is evaluated at most once as long as it remains in scope)
18:58:28 <Cale> benzrf: I like always giving the same example: imagine that we have the program  double x = x + x  and we're trying to evaluate  double (double 5)
18:58:44 <Cale> benzrf: Under strict (innermost-first) evaluation, we'd do:
18:58:46 <benzrf> i started reading the wb page about graph eval
18:58:48 <Cale> double (double 5)
18:58:51 <benzrf> i know a little of this
18:58:53 <Cale> -> double (5 + 5)
18:58:57 <Cale> -> double 10
18:58:58 <Cale> -> 10 + 10
18:59:00 <Cale> -> 20
18:59:46 <Cale> Under plain outermost-first evaluation, otherwise known as "normal-order reduction" despite only being "normal" to lambda calculus enthusiasts :) we'd see:
18:59:49 <Cale> double (double 5)
18:59:58 <Cale> -> (double 5) + (double 5)
19:00:04 <Cale> -> (5 + 5) + (double 5)
19:00:08 <Cale> -> 10 + (double 5)
19:00:12 <Cale> -> 10 + (5 + 5)
19:00:15 <Cale> -> 10 + 10
19:00:16 <Cale> -> 20
19:00:49 <Cale> Obviously, we wasted work. This duplication of effort occurred because the parameter x to the function double, occurred twice in its body
19:01:08 <benzrf> i know that you cant generally analyze a function to see if it will halt
19:01:19 <benzrf> but is it possible to generally anaylyze a function
19:01:25 <benzrf> and see if it's possible to analyze whether it will halt
19:01:28 <benzrf> :b
19:01:32 <Cale> So, lazy evaluation fixes this by saying that whenever a variable occurs multiple times in its scope, we share any work resulting from evaluating one of the copies (usually this is just done by having pointers to the same thing in memory)
19:01:57 <twiceler> benzrf: Is the program "return ()"? Yes -> halts. No -> who knows?
19:02:01 <benzrf> hah
19:02:01 <Cale> heh, well, Agda is a language where you can ensure that every program you write halts by the fact that it typechecks
19:02:07 <twiceler> benzrf: More seriously, all programs in Agda halt
19:02:07 <benzrf> o:
19:02:16 <trillioneyes> benzrf: you can't generally analyze a possibly-partial function to see whether it has any nontrivial property
19:02:24 <benzrf> hmm, that makes sense
19:02:25 <benzrf> :[
19:02:31 <trillioneyes> Where "nontrivial" means "some possibly-partial functions have this property and some don't"
19:02:40 <Cale> (well, that's not entirely true, there are some types of programs which don't halt, but you'll instead have a proof that the program will always make progress)
19:02:47 <mmxv> Cale: Do you know how to change the above example to output "foo!bar!" for, say, "foo!bar! baz"? I can wrap it into many1 (or something similar), then match on the Right value constructor to concat the result. But is it possible in one go?
19:02:55 <benzrf> how can agdabe useful if its impossible to write partial funcs?
19:02:57 <twiceler> benzrf: Look into Agda, Idris, dependent types, etc. I think you'll be impressed with what you can do
19:03:05 <benzrf> dont they always arise from general recursion?
19:03:35 <Cale> benzrf: Agda prohibits general recursion from showing up just anywhere
19:03:45 <Cale> You only get structural recursion
19:04:13 <Cale> (Coq is also like this)
19:04:40 <Cale> (Idris isn't by default, but you can tell it to ensure termination for you)
19:04:42 <twiceler> And many might argue that Agda's not incredibly useful (I think there's a joke around that nobody in Agda actually runs their programs). But one day... I think that's where the future is heading
19:04:42 <benzrf> what does that mean o_O
19:04:56 <benzrf> *structural recusion
19:04:58 <benzrf> *recursion
19:05:05 <trillioneyes> benzrf: for many programs you don't need partial functions; also, Agda tries to focus more on proofs than programs, I've heard
19:05:08 <Cale> benzrf: The sort of recursion where you apply the function recursively to a smaller piece of the data that you pattern matched
19:05:23 <Cale> (In at least one argument)
19:05:46 <Cale> i.e. the size of the thing you're applying the function to has to be provably decreasing
19:06:02 <jle`> caught my first logic error in Haskell today, an error that the type system couldn't fix
19:06:14 <jle`> i swapped Foldable.any for Foldable.all
19:06:18 <Cale> hah
19:06:27 <Cale> Yeah, we still have boolean blindness in Haskell
19:06:30 <trillioneyes> Dependent type systems would catch that :D
19:06:38 <benzrf> how o_O
19:06:38 <jle`> i paused to remind myself that not all errors are type rrors
19:06:57 <Cale> You can always swap the branches of any if expression without getting a type error in Haskell, but not so in dependently typed languages :)
19:06:59 <kristof> Is much of the GHC runtime still primarily written in C-- or has the GHC community moved to LLVM? I know it supports it, but I don't know what the primary implementation is.
19:07:18 <trillioneyes> benzrf: you can do a thing where instead of using booleans, you use types that kind of explain what they mean
19:07:33 <trillioneyes> And values of that type must contain a proof that they are the correct answer to the question associated with them
19:07:53 <benzrf> ._.
19:08:10 <Cale> e.g. {x = y} + {x /= y} is a sort of Boolean which tells you whether x and y are equal or not
19:08:36 <twiceler> benzrf: http://www2.tcs.ifi.lmu.de/lehre/SS09/Fun/DepTypes.pdf
19:08:49 <trillioneyes> (Where the + is a sum type, and = and /= are dependent type constructors)
19:08:58 <benzrf> waagh
19:09:21 <benzrf> wait, so is that turning functions into constructors?
19:09:23 <jle`> read an article on this recently
19:09:30 <twiceler> benzrf: Come to think of it, read this first http://en.wikipedia.org/wiki/Curry–Howard_correspondence
19:09:44 <Cale> benzrf: You can have types which depend on values in a dependently typed language
19:09:46 <trillioneyes> Well, it's using types for things that you'd normally (in Haskell) use functions for
19:09:54 <Cale> benzrf: For example, you can define a type:
19:10:23 <Cale> (in Haskelly sort of notation)
19:10:50 <Cale> data Eq A (x :: A) (y :: A) where Refl :: Eq A x x
19:11:18 <Cale> Thus, a value of type Eq A x y is a sort of proof that x and y are really the same thing
19:11:48 * benzrf blinks
19:11:58 <Cale> and that's what the notation x = y I used earlier really is, only with the type A left implicit
19:12:21 <benzrf> i understoof a little bit of that
19:12:35 <trillioneyes> (Interestingly, Idris's version of this doesn't require x and y to have the same type)
19:12:38 <Cale> Yeah, it's a bit mindbending, and I'm doing a rush job of explaining it here
19:13:05 <twiceler> trillioneyes: From what I know of type theory, that sounds really strange
19:13:27 <trillioneyes> The differently-typed x and y? Yeah, it is really weird and I'm not sure why it's that way
19:13:39 <benzrf> this stuff is why i want to major in highly abstract comp sci
19:13:42 <benzrf> :v
19:13:59 <trillioneyes> It's probably so that you don't have to manually prove that they have the same type before you can prove they're equal? At least, that's the only thing I can think of that remotely makes sense
19:14:04 <Cale> benzrf: But yeah, just in case you thought Haskell's level of type safety was really awesome, there's stuff hopefully coming to future practical programming languages which is even cooler still.
19:14:49 <zRecursive> After `cabal install`, the function in Foo.hs doubles the speed of "ghc -e foo Foo.hs". It is great however it is still 1/5 the speed of CLISP to run `ghc --ignore-dit-ghci -e "Foo.foo".  Why ?
19:14:50 <jle`> i'm trying to find an article i recently read :/ writing a comparison operator between type-level peano nats
19:14:53 <Cale> Agda and Coq are *mostly* just useful for proving theorems in constructive mathematics, more than actually writing desktop-level software
19:15:09 <Cale> There is a C compiler written in Coq though, so it's possible to write nontrivial stuff.
19:15:19 <benzrf> someday we will have a type system so powerfully safe that you can write a type describing your program and the computer can trivially derive the real program from it
19:15:33 <benzrf> of course, at that point the type will be as complex as the original program was
19:15:35 <Cale> benzrf: That's already kind of the case with these
19:15:39 <trillioneyes> Idris aims to be useful for general-purpose software, but I don't think it's quite there yet
19:15:44 <twiceler> I'm starting to believe that Idris will actually be practical
19:15:50 <trillioneyes> (I haven't tried to do anything with it though)
19:15:51 <jle`> Cale: does the coq-ness provide any benefit to writing a C compiler?
19:15:52 <Cale> benzrf: The emacs mode for Agda has a key you can hit to get Agda to try to fill in bits of code for you
19:15:57 <benzrf> jesus christ
19:16:08 <Cale> benzrf: and you can sometimes just hammer that key and it'll write the whole thing
19:16:15 <benzrf> ;-;
19:16:34 <zRecursive> why is the compiled GHC module slower than CLISP ?
19:16:35 <Cale> (because the type already says what the function should do, uniquely)
19:16:51 <benzrf> Cale: how is that different from writing the function though
19:16:52 <Polarina> Then why doesn't everyone use Agda instead of Haskell?
19:16:56 <trillioneyes> I don't have any stories like that, but on several occasions I've had more difficulty coming up with a type for a function in idris than actually implementing that function
19:17:00 <Cale> jle`: There's a proof that the programs it emits have the semantics of the programs that it takes as input
19:17:04 <benzrf> either way, youre uniquely specifying the function
19:17:26 <Cale> benzrf: Yeah, but you're specifying it in quite a different sort of way
19:17:38 <zRecursive> any light here ?
19:17:51 <twiceler> Polarina: It's a pain proving that your program is correct!
19:18:00 <Cale> Sometimes it's easier to write the type, sometimes it's easier to write the value, either way, we ought to be able to have our computers infer things when possible.
19:18:14 <trillioneyes> benzrf: idiomatic code in a dpeendently typed language has types that read like specifications of the function's behavior in first-order logic
19:18:18 <trillioneyes> At least in my limited experience
19:18:20 <benzrf> @_@
19:18:28 <Cale> yes
19:18:37 <Cale> It looks *very much* like first order logic
19:18:44 <Cale> With forall and exists and everything :)
19:18:58 <erisco> mkay Cale
19:19:09 <trillioneyes> Also, I kind of wonder if we should move to an off topic channel
19:19:10 <benzrf> i should probably actually learn logic at some point
19:19:15 <trillioneyes> Because someone has asked a haskell-related question
19:19:25 <erisco> Cale, are you up for a few minutes to take a look?
19:19:46 * zRecursive whether or not GHC does many startup things ?
19:19:48 <Cale> zRecursive: What are you talking about? I don't know of any CLISP implementations which compile Haskell code.
19:20:13 <Cale> erisco: What's up?
19:20:20 <benzrf> clisp IS an impl tho
19:21:04 <zRecursive> Cale: `time clisp.sh "(m:his)"`  faster than  `time ghc -e Foo.his`
19:21:21 <zRecursive> his does the same thing
19:21:26 <erisco> Cale, I was reading on different functional graph techniques. I am trying to capture the simplicity with the tying-the-knot representation that can be seen in other approaches
19:21:55 <erisco> Cale, I have come up with a way to express depth and breadth searching that I'd like your comment on
19:22:18 <ParahSailin> why isnt ScopedTypeVariables default?
19:23:06 <zRecursive> Cale: After `cabal install`, Foo.his should be compiled. but it is still slower than CLISP running the source code (m:his)
19:23:07 <Cale> ParahSailin: It does change the way that the compiler prints types. I don't know if that was considered a problem.
19:23:18 <Cale> zRecursive: what is Foo.his?
19:23:32 <zRecursive> it is a function in Foo.hs
19:23:41 <erisco> Cale, those algorithms are of particular challenge because they require coping with cycles, so that is where my work is
19:23:56 <Cale> zRecursive: Why are you using ghc -e?
19:24:28 <zRecursive> Cale: the user donot need to run ghci sometimes
19:24:41 <Cale> erisco: ivanm was just here, he might have some input on this
19:24:50 <zRecursive> they just want the result of some functions
19:24:56 <Cale> He's spent much more time than I have caring about graph representations
19:25:17 <Cale> I tend to do the simplest and easiest thing which comes to mind for representing the adjacency structure.
19:25:20 <erisco> Cale, sure if they are around I can talk to them too
19:25:28 <erisco> Cale, but you know more about Haskell and related theory in general
19:25:58 <erisco> Cale, and there are a couple aspects to the approach that you might be able to extrapolate on
19:25:59 <Cale> zRecursive: I don't understand the goal of what you're trying to do
19:26:05 <erisco> they are not particularly related to graphs themselves
19:26:14 <Cale> okay
19:26:28 <ion> The “Learning Haskell” Facebook group has such great suggestions. The question: how to avoid parentheses in “extractingLowVal responseList= head(tail (tail ( tail (splitOn "," responseList ))))”. The first answers tells him to use $, the second suggests “(head . tail . tail . tail . (splitOn ",")) responseList”.
19:26:38 <zRecursive> Cale: The goal is run functions in Foo.hs from command line
19:26:46 <Cale> ion: :)
19:27:01 <Cale> zRecursive: okay, and why isn't that working?
19:27:03 <erisco> Cale, sorry I forgot to bin it http://lpaste.net/97811
19:28:06 <Cale> zRecursive: the time it takes to ghci -e stuff usually isn't terribly long
19:28:43 <zRecursive> Cale: that works indeed. `ghc -e foo Foo.hs` is VERY slow. so i `cabal install` the module and `ghc -e Foo.foo` doubles the speed. However, it is still than a version implemented using CLISP
19:28:50 <Cale> zRecursive: why do you care about the performance of it relative to evaluating common lisp expressions? If you cared about the performance of your program, you'd compile it with optimisations.
19:29:09 <benzrf> vf
19:29:11 <benzrf> "A
19:29:13 <benzrf> \
19:29:22 <Cale> (rather than using ghc -e)
19:30:02 <zRecursive> it is just a module. and the user need to call functions in this module from command line.
19:30:38 <twiceler> Oh boy. I just realized - does Cabal not compile with -O2 by default?
19:31:14 <twiceler> (I don't see why it would, but now I realize I should add this to all my packages!)
19:33:00 <ijp> is there a version of !! that returns a Nothing if the list is too short, and Just x if there is such an index
19:33:02 <zRecursive> twiceler: you mean in *.cabal ?
19:33:14 <twiceler> zRecursive: Yeah
19:33:25 <lispy> ijp: not in the Prelude
19:33:31 <lispy> ?hoogle Int -> [a] -> Maybe a
19:33:32 <lambdabot> Prelude (!!) :: [a] -> Int -> a
19:33:32 <lambdabot> Data.List (!!) :: [a] -> Int -> a
19:33:32 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
19:33:38 <Cale> twiceler: Default is -O only, I think
19:33:54 <lispy> ijp: and hoogle makes me think that it's not in Data.List either
19:33:57 <fl00r> save
19:34:31 <ijp> lispy: I didn't think so, but I figured I should ask
19:34:31 <benzrf> so how do exceptions work in haskell anyway?
19:34:35 <benzrf> what does error actually do
19:34:37 <benzrf> @src error
19:34:37 <lambdabot> error s = throw (ErrorCall s)
19:34:41 <benzrf> @src throw
19:34:41 <lambdabot> throw exception = raise# exception
19:34:45 <benzrf> :t throw
19:34:46 <lambdabot> Exception e => e -> a
19:34:48 <lispy> > error "what deos this do?"
19:34:49 <lambdabot>  *Exception: what deos this do?
19:34:54 <benzrf> exactly
19:35:01 <benzrf> :t raise#
19:35:02 <lambdabot> Not in scope: `raise#'
19:35:03 <twiceler> Cale: Oh, that's good! ghc doesn't compile with -O by default, right?
19:35:05 <benzrf> ?!
19:35:05 <lambdabot> Maybe you meant: v @ ? .
19:35:16 <L8D> [] !!! _ = Nothing
19:35:25 <lispy> benzrf: raise# is a compiler primitive
19:35:29 <L8D> (x:_) !!! 0 = x
19:35:33 <lispy> benzrf: you can think of it as something the run-time provides
19:35:46 <benzrf> L8D: JUST x
19:35:48 <L8D> (x:_) !!! 0 = Just x
19:35:58 <L8D> (-:xs) !!! n = xs !! (n - 1)
19:36:03 <L8D> (_:xs) !!! n = xs !! (n - 1)
19:36:05 <Cale> twiceler: right
19:36:06 <L8D> there!
19:36:15 <Axman6> you're using !! not !!!
19:36:21 <L8D> oops
19:36:24 <Axman6> and x not Just x
19:36:28 <ijp> L8D: I know how to write one
19:36:37 <L8D> I suck at writing code on the fly
19:37:06 <bergey> > [1..4] ^? ix 2
19:37:06 <ion> @type \n -> listToMaybe . drop n
19:37:07 <lambdabot> Int -> [a] -> Maybe a
19:37:07 <lambdabot>  Just 3
19:37:22 <lispy> > let [] !!! _ = Nothing; (x:_) !!! 0 = Just x; (_:xs) !!! n = xs !!! (n - 1) in [1,2,3] !!! 4
19:37:23 <lambdabot>  Nothing
19:39:17 <lightquake> so, one use case I see a lot for GADTs is type-safe EDSLs, the usual data Expr a where Plus :: Expr Int -> Expr Int -> Expr Int; Equal :: (Eq a) => Expr a -> Expr a -> Expr Bool thing
19:39:43 <lightquake> but how do you parse a String into an Expr? do you have data SomeExpr = BoolExpr (Expr Bool) | IntExpr (Expr Int)?
19:41:50 <twiceler> lightquake: Well, that depends on the grammar that determines how you wrote your string! If I'm interpreting your question correctly
19:42:31 <twiceler> lightquake: Nevermind, I see what you're saying now
19:44:07 <twiceler> Yes, that's probably what I would do.
19:46:54 <augur> Cale: i dont know this A=B thing
19:47:21 <Cale> http://www.math.upenn.edu/~wilf/AeqB.html
19:47:24 <augur> but zeilberger did his phd on polarity and stuff, and his site has a whole bunch of things on polarity and focusing
19:47:28 <augur> its reeeaaally dense tho
19:47:51 <Cale> Doron Zeilberger, right?
19:47:52 <augur> oh no, Cale, not doron zeilberger
19:47:55 <Cale> oh
19:47:56 <augur> noam zeilberger
19:48:04 <Cale> Okay, never heard of him :)
19:48:20 <augur> hes pretty new
19:49:01 <augur> he's @noamzoam on twitter
19:49:13 <benzrf> what should i major in if i want to study this kind of thing? abstract comp sci?
19:49:18 <lispy> lightquake: I think that's called higher order abstract syntax if you want a google term
19:49:23 <benzrf> PLT?
19:49:46 <Cale> I don't use twitter
19:49:50 <lispy> benzrf: What kind of thing? Language design? Haskell? EDSLs? Theorem Proving? Semantics?
19:50:29 <benzrf> stuff like type theory and highly abstract programming language concepts
19:50:36 <benzrf> denotational semantics, etc
19:50:42 <benzrf> ^may not be abstract
19:50:47 <zRecursive> Great ! "-O2" makes a bit progress. `time ghc -ignore-dot-ghci -e "Foo.his"` => 0.550 secs.  approxiamting `time clisp.sh '(m:his)'` => 0.218 secs.   can i tweak it more ?
19:50:48 <augur> benzrf: PLT, type theory, etc.
19:50:53 <augur> its theoretical CS
19:50:56 <benzrf> ok
19:51:00 <augur> some schools have really good programs for this
19:51:02 <Cale> You could be like me and major in pure mathematics, learn the rest after
19:51:07 <benzrf> any recommendations augur?
19:51:10 <augur> look for people tho
19:51:15 <Cale> I've had a pretty easy time picking up most things in CS
19:51:17 <twiceler> Haha, same here (math major)
19:51:19 <lispy> lightquake: You should be able to use the constructors from a parser like normal. Remember that when you look at a GADT "from the outside" you can't see what the specific types in the constructors are.
19:51:28 <benzrf> Cale: meh, i like it when i can type math into a REPL as well as read it in a document
19:51:31 <benzrf> :v
19:51:58 <lispy> Cale: Yeah, but I bet you had a pretty easy time picking up most things in pure math :)
19:52:00 <augur> benzrf: frank pfenning, bob harper, conor mcbride  <<  these are people you should be familiar with
19:52:13 <lightquake> lispy: right, but you can't write parseExpr :: exists a. Text -> Expr a
19:52:14 <benzrf> bob harper sounds vaguely familiar
19:52:15 <benzrf> :b\
19:52:16 <Cale> lispy: nah, I struggled like everyone else
19:52:45 <zRecursive> Cale: any suggestion ?
19:52:59 <Cale> zRecursive: for making ghc -e have less startup time?
19:53:14 <zRecursive> maybe run time
19:53:21 <Cale> Just compile the expressions you want into separate programs?
19:53:36 <lispy> lightquake: can't you just say parseExpr :: Text -> Expr a, and then when you pattern match on the Expr a, you 'refine' the `a' and find out which type it was
19:53:49 <lispy> lightquake: if not, then yes use an existential wrapper type like youe proposed
19:54:21 <twiceler> Ooh. I've been watching the lectures that Bob Harper put out on HoTT
19:55:00 <lispy> twiceler: me too. I wish something like that existed just algebraic topology and categeory theory
19:55:05 <Cale> lispy: Anyone who tells you that doing a 4 year pure mathematics undergrad at Waterloo was easy for them is almost certainly a liar.
19:55:14 <lispy> Cale: :)
19:56:22 <zRecursive> "0.550 vs 0.218" has meets the user
19:56:36 <twiceler> lispy: Yeah, I'm sort of wanting to learn category theory, but I haven't found a great introduction to it yet (I know very little of it as of yet!)
19:56:42 <L8D> Waterloo austin?
19:56:50 <Cale> Waterloo Ontario
19:56:51 <zRecursive> but i want to tweak it more :D
19:56:58 <Cale> (Canada)
19:57:16 <lightquake> anyway, yeah, I think you need an existential wrapper so you can match on the type of the expression.
19:57:39 <lispy> twiceler: the two sources I like so far: Barr & Wells and the Awodey book
19:57:52 <lispy> twiceler: http://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf
19:57:53 <Cale> Just go with Awodey
19:58:06 <lispy> twiceler: http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182
19:58:10 <Cale> I don't really understand why people like Barr and Wells so much
19:58:33 <twiceler> lispy: Thanks! I'll take a look
19:58:57 <Cale> http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf
19:59:03 <lispy> Cale: it's available on the web for free and they assume less mathematical background but not to the hand holding levels of conceptual mathematics :)
19:59:21 <levi> twiceler: The guy who wrote that text also has some online lectures at the UOregon Summer School site.
19:59:33 <zedik> Happy New Year everyone
19:59:37 <lispy> Cale: oh nice. i have a hard copy, but that will amke a nice addition to my growing pdf library.
19:59:45 <lispy> zedik: happy new year!
19:59:52 <lispy> zedik: many lambdas and haskells to you!
20:00:24 <Cale> lispy: There have been various points at which Awodey has made the PDF available to his students. So long as it's not *too* widely distributed, I think he doesn't mind so much.
20:00:37 <lispy> Cale: as someone who has a very hard time reading things out of order, I've found conceptual mathematics to be on the painful side :(
20:01:04 <lispy> Cale: yeah, and I already paid for it. So I feel no guilt with also owning the pdf
20:01:14 <zedik> lispy: thanks!
20:01:17 <lispy> I wish buying hardcopies also gave you access to pdfs...
20:02:18 <lispy> twiceler: and in case you wonder, Awodey is pronounced audi (like the cars)
20:02:40 * lispy screwed that up for months
20:03:15 <Cale> http://www.youtube.com/watch?v=ZKmodCApZwk
20:03:23 <mjrosenb> are there any plans of fixing the indentation on examples on the haskell wiki ?
20:03:29 <Cale> ^^ Awodey lectures
20:03:40 <Cale> mjrosenb: On which page?
20:03:57 <mjrosenb> Cale: http://www.haskell.org/haskellwiki/X_window_programming_in_Haskell
20:04:16 <lispy> Cale: OMG. You rock :)
20:04:17 <mjrosenb> also, it looks like one of the examples references a couple of functions that no longer exist
20:05:18 <Cale> lispy: I found those lectures really entertaining even though I already knew everything he said, just because of the approach he took :)
20:07:30 <geekosaur> mjrosenb: which functions don't exist?
20:07:53 <geekosaur> (also, here after the first few examples they all get rendered in the wrong font, making me think they're not marked up as code)
20:08:45 <lispy> Cale: have you already seen this article? http://bentnib.org/conservation-laws.pdf
20:08:58 <lispy> Cale: I'm looking forward to reading it. It looks interesting.
20:09:09 <Cale> No, I haven't seen that
20:10:02 <danilo2> Hello! Is there a way to get in Parsec the last parsed character?
20:10:42 <Cale> danilo2: I don't think so
20:10:58 <Cale> danilo2: There's anyChar, which matches any character, and produces that character as its result
20:11:02 <mjrosenb> geekosaur:
20:11:03 <mjrosenb>               -- ev <- getEvent e
20:11:03 <mjrosenb>               -- putStrLn $ eventName ev
20:11:08 <Cale> But if you discard that result, there's no way to get it back
20:11:45 <geekosaur> mjrosenb: they're in Graphics.X11.Xlib.Extras
20:12:45 <mjrosenb> geekosaur: interesting, I copied the code from that page, and that import was lost somehow.
20:13:33 <mjrosenb> geekosaur: anyhow, the more annoying thing is th efact that the code is basically nt indented.
20:13:36 <mjrosenb> *not
20:13:50 <geekosaur> yes, the indentation on that page sucks pretty badly
20:13:57 <lightquake> lispy: that looks terrifying
20:14:01 <danilo2> Cale: I know that (about anyChar). I'm just trying to code parser for a language, hwich got rubylike syntax: "f (a).b" equals "f(a.b)", but "f(a).b" equals "(f(a)).b". Right now I've solved this problem by making my combinators getting Bool on input, which tells if they should eat spaces after parsing or not, but I'm looking for something prettier
20:15:13 <lightquake> danilo2: coffeescript?
20:15:47 <danilo2> lightquake: no, a custom one
20:15:55 <zRecursive> geekosaur: Which makes code faster in "-O2" and "-O3" ?
20:15:59 <lightquake> ah
20:16:01 * geekosaur has noted it, might even get to do it at some point
20:16:05 <geekosaur> -O3 is not a thing in ghc
20:16:28 <geekosaur> -O2 is the best you can do. it's not default because it turns out to be a pessimization for some code
20:16:45 <geekosaur> (that is, that's why cabal doesn't use it by default)
20:17:02 <zRecursive> @wn pessimization
20:17:04 <lambdabot> No match for "pessimization".
20:17:13 <lightquake> opposite of an optimization
20:17:13 <geekosaur> although I don't know if anyone has checked to see if it's still true in recent ghc; I think last time it was checked was in the late 6.x versions
20:17:42 <lispy> lightquake: sorry, which part is terrifying? Using existential wrappers?
20:17:51 <zRecursive> geekosaur: thx
20:17:52 <lightquake> lispy: no, the pdf you linked
20:18:26 <lispy> lightquake: heh.
20:18:34 <geekosaur> basically some of the optimizations (used to?) end up breaking other optimizations rather badly
20:18:36 <lispy> So maybe I should just keep that pdf to myself in the future? ;)
20:18:59 <geekosaur> in particular some things prevent inlining, and some may break things like stream fusion
20:19:28 <geekosaur> (because the optimized code is larger and the inliner won't consider it a candidate for inlining any more, etc.)
20:19:41 <zRecursive> optimization sometimes is danger
20:22:10 <danilo2> zRecursive: Why? In Haskell? In C it is but In Haskell I do not think so
20:22:15 <zRecursive> "0.550 secs" is a big achievement today, thank all !
20:22:23 <geekosaur> danilo2, see what I just said
20:23:06 <zRecursive> danilo2: using "-O2" now
20:23:42 <danilo2> geekosaur: interesting. But maybe after optimization the code was so big, that the inliner was choosing the right path and finally everything worked faster? If you wanted to inline something even then - we could use pragma?
20:24:15 <geekosaur> there have also been cases where additional levels of optimization caue something to be inlined that didn't before, and *that* manages to lead to bad code (for example it thinks it can no longer do stream fusion, so now it's creating and garbage collecitng thinsg that it could optimize into a simple loop with no allocation)
20:24:45 <geekosaur> there are pragmas and special compiler options, yes, but you really don't want to be messing with those
20:24:49 <geekosaur> if you can help it
20:25:22 <danilo2> geekosaur: you are of course right. Hmmm I'm just thinking if in such cases the optimization process could be more wise
20:25:53 <geekosaur> there are a number of places where the way ghc does optimization is known to not be so good. fixing them without breaking other things, however, is rather difficult
20:26:10 <geekosaur> you can probably find discussion on the ghc internals wiki
20:26:39 <amosr> stream fusion relies on so much inlining, case of constructor, spec constr and rewrite rules that I wouldn't have expected it to be very useful at all without -O2
20:26:42 <danilo2> geekosaur: thank you, I'll not do it right now (too many tasks) but it is very interesting :)
20:26:51 <erisco> lenses
20:26:53 <erisco> I need lenses
20:42:35 <erisco> never mind get it away from me
20:43:15 <niggapls> what's wrong with this expression? if elem "HI"  ["HI","BYE"] then putStrLn "HI"
20:43:31 <ParahSailin> needs else
20:44:23 <niggapls> oh ok
20:44:25 <niggapls> thanks
20:45:02 <erisco> ambiguous module name "Control.Monad.State"
20:45:03 <erisco> oh great
20:45:05 <Cale> niggapls: You might want to use the 'when' function from Control.Monad
20:45:21 <Cale> when (elem "HI" ["HI", "BYE"]) (putStrLn "HI")
20:45:34 <niggapls> oh that's what i needed thanks
20:45:51 <Cale> @src when
20:45:52 <lambdabot> when p s = if p then s else return ()
20:45:59 <Cale> ^^ that's how when is defined
20:46:13 <niggapls> cool
20:46:38 <Tekmo> niggapls: The reason it is defined like that is that `if` requires both clauses to evaluate to the same type of expression
20:47:03 <niggapls> oh right
20:47:06 <niggapls> pure function and all that
21:03:13 <codygman> For some reason when I install ansi-terminal in a cabal sandbox I can't import it after: http://lpaste.net/97813
21:04:31 <lispy> codygman: I don't think :m is valid
21:04:48 <lispy> codygman: try either import System.Console.ANSI or :m + System.Console.ANSI
21:06:06 <lispy> codygman: actually, sorry. I see the real problem now.
21:06:08 <lispy> codygman: cody@zentop:~/new-haskell-project$ ghci
21:06:23 <lispy> codygman: When you use sandboxes, ghci/ghc won't see them by default. Cabal will.
21:06:28 <lispy> codygman: so type cabal repl
21:06:34 <lispy> then you can import it
21:08:19 <codygman> lispy: That's right... forgot. So I'm guessing haskell-mode wouldn't support that yet?
21:08:31 <lispy> what is haskell-mode?
21:08:46 <codygman> lispy: Sorry for not being more specific. haskell-mode for emacs
21:09:04 <lispy> Ah. Yeah, probably not but I don't really know. I use vi for Haskell.
21:09:16 <mjrosenb> https://gist.github.com/8205277 ugh.  I don't even think that is an indentation error.
21:09:44 <codygman> lispy: Really? I used vi for 6 years, but have been using emacs mostly for elisp (which I haven't had time to learn yet). How is haskell support in vi?
21:10:00 <lispy> mjrosenb: was that code written to use the old-exceptions?
21:10:17 <mjrosenb> lispy: no clue.  it is on the haskell wiki.
21:10:45 <lispy> codygman: well, it doesn't get in the way and do weird things like the haskell support. I actually stopped using emacs and learned vi for two reasons: a) I thought it about time b) I was annoyed at the haskell support in emacs.
21:11:24 <mjrosenb> lispy: this entry was last updated in 2010, so i'm guessing old-exceptions.
21:11:33 <lispy> codygman: I hear the haskell support in emacs is much better now, but everytime I look at it, we have very different ideas about how indentation should work and I go back to vi.
21:11:55 <lispy> codygman: you might try ghc-mode
21:11:59 <lispy> er, ghc-mod
21:12:03 <lispy> I hear it's all the rage :)
21:12:18 <mjrosenb> lispy: is there a simple transformation between old-exceptions and new exceptions?
21:13:17 <lispy> mjrosenb: I think I used to know one, but since I haven't needed that knowledge for a while I've forgotten :)
21:13:45 <lispy> mjrosenb: I think the main trick to converting is to throw in SomeException, but that's a hackish way to clean it up.
21:13:53 <lispy> :t SomeException
21:13:54 <lambdabot> Exception e => e -> SomeException
21:14:13 <mjrosenb> :t catch
21:14:14 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
21:14:41 <lispy> Basically, that removes the ambiguity as far as the type class resolution is concerned
21:16:20 <mjrosenb> so (const $ return ()) needs to be replaced with (\e -> const (SomeException e) $ return ())
21:16:59 <trillioneyes> It can be (const . SomeException) if you find that clearer
21:17:05 <mjrosenb> negative.
21:17:32 <mjrosenb> https://gist.github.com/8205295
21:17:49 <trillioneyes> oh wait, right, your parentheses are different from what my suggestion would be
21:18:56 <mjrosenb> well, my code leads to: https://gist.github.com/8205301
21:19:10 <trillioneyes> hmmm
21:19:20 * mjrosenb has never touched exceptions in haskell before
21:19:24 <trillioneyes> const $ return () was working before, right?
21:19:37 <trillioneyes> or wait, no, you were getting an ambiguous type variable error with that?
21:21:01 <trillioneyes> I think you want... (\ (SomeException _) -> return ())
21:21:31 <trillioneyes> Or, if you prefer, (\ (e :: SomeException) -> return ())
21:22:01 <mjrosenb>     Deprecated: "use Control.Exception.mask instead"
21:22:06 <mjrosenb> ugh.
21:25:22 <xpika> why doest they type ReadS type use the maybe data type?
21:25:49 <lispy> mjrosenb: ah, deprecated. Bummer. It is a hack :(
21:26:18 <xpika> looks like its using [] and [a] to emulate nothing and Just a
21:27:01 <lispy> type ReadS a = String -> [(a, String)]
21:27:08 <trillioneyes> xpika: depending on the input you're parsing and the grammar you're using to parse it, there might be multiple possible parses
21:27:39 <lispy> sadly, ReadS is really inefficient for that type of backtracking
21:27:52 <mjrosenb> lispy: I don't think that is the fault of SomeException?
21:29:02 * mjrosenb grumbles about haskell and concurrency.
21:30:57 <carter> mjrosenb: eh?
21:32:10 <carter> what about concurrency?
21:32:35 <augur> Cale: http://www.math.ias.edu/~nzeilberger/papers/unity-duality.pdf
21:34:29 <mjrosenb> carter: I guess it is just a bunch of cruft left over from porting the standard X event loop to haskell
21:34:41 <carter> why are you writing an event loop?
21:34:55 <mjrosenb> but I feel like I shouldn't have to do a dance with exceptions or something similar to get both X events, and a timer.
21:35:03 <mjrosenb> carter: because I want to speak with X.
21:35:07 <carter> ok
21:35:11 <carter> and who's throwing exceptions?
21:35:24 <carter> is the full code somehwere?
21:35:43 <mjrosenb> http://www.haskell.org/haskellwiki/X_window_programming_in_Haskell#A_new_nextEvent_with_asynchronous_exceptions
21:35:57 <mjrosenb> carter: ymmv w.r.t. indentation.
21:36:08 <mjrosenb> actually
21:36:08 <carter> hehe
21:36:11 <carter> i'm bad at guis :)
21:36:16 <mjrosenb> https://gist.github.com/8205362 is how i've indented it.
21:36:30 <carter> better
21:37:33 <carter> wait, so the code communicates via exceptions?!
21:41:38 <joelteon> lol
21:42:13 <carter> yeah
21:56:25 <lispy> http://stackoverflow.com/questions/20865756/memory-leak-in-a-haskell-program?utm_source=twitterfeed&utm_medium=twitter
21:56:56 <lispy> I'm looking at that SO question.
21:57:18 <lispy> I would probably change some of the types to return lists instead of Maybe, but I don't think that will fix their memory consumption.
22:08:03 <augur> Cale: that link is making zeilberger make even more sense
22:09:20 <augur> Cale: also it relies heavily on different judgments :)
22:11:44 <ParahSailin> what does ghc use for the assembler stage, internal functions?
22:12:08 <erisco> Cale, do I am in a monad nightmare
22:12:45 <carter> only if you wanna be
22:12:53 <carter> most of the code i write is pretty light on monads
22:12:54 <carter> idk
22:12:59 <erisco> d'oh*
22:13:28 <erisco> hang on let me try and get this back into somewhat of a presentable state
22:13:47 <carter> soke
22:13:53 <carter> we're all tired and perhaps drunk
22:14:15 <erisco> mkay so http://lpaste.net/97815
22:14:27 <erisco> the type sig is invalid but represents what I *want* to do
22:14:35 <Clint> carter++
22:15:01 <carter> erisco: i don't think thats why you wanna do
22:15:05 <carter> it looks complex
22:15:06 <erisco> when f returns m Nothing, I want l = BinEmpty
22:15:21 <carter> erisco: heres a trick i do
22:15:21 <erisco> or I could have
22:15:26 <erisco> a -> Maybe (m a)
22:15:31 <erisco> maybe that is what I need
22:15:43 <carter> I think you should look up MaybeT ?
22:15:50 <c_wraith> erisco: or your return result could be m (BinTree a)?
22:15:52 <jmcarthur> ParahSailin: ghc has a native code generator of its own, or an llvm backend. is that what you mean?
22:15:53 <carter> :info MaybeT
22:16:02 <erisco> c_wraith, that is not what I want though
22:16:12 <carter> @where MaybeT
22:16:12 <lambdabot> I know nothing about maybet.
22:16:32 <carter> though it does use the system assembler to assemble things
22:16:49 <lispy> jmcarthur: does the NCG use an external assembler though? I would assume it does.
22:16:51 <ParahSailin> jmcarthur: when you call -pgmF cmd, is there a cmd such that the -pgmF cmd is a nop
22:16:55 <carter> lambdabot: yup
22:17:08 <carter> ParahSailin: /dev/null :)
22:17:18 <carter> lispy: yup
22:17:19 <ParahSailin> er, -pgma i mean
22:17:31 <c_wraith> erisco: why do you have the monad constraint in there at all?
22:17:44 <erisco> c_wraith, because I want it to be a monad
22:17:59 <carter> erisco: have you looked at monad transformers?
22:18:01 <c_wraith> erisco: if you're not using (>>=) or return, you don't care if it's a monad or not
22:18:09 <ParahSailin> ie, when you dont call -pgma option, which system assembler does it use
22:18:11 <erisco> c_wraith, well I am using >>=
22:18:29 <carter> ParahSailin: your c compiler
22:18:33 <erisco> carter, no I guess I will take a look
22:18:34 <carter> and then whatever assembler that uses
22:18:39 <carter> erisco: also
22:18:41 <erisco> it seems like I keep getting stuck in the monad
22:18:47 <carter> erisco: erase the type
22:18:48 <erisco> whether I have Maybe (m a) or m (Maybe a)
22:18:51 <carter> then load it in ghci
22:18:51 <ParahSailin> ah, ok
22:18:54 <carter> and to :t blah
22:19:00 <erisco> carter, I cannot even write the definition of the function though
22:19:04 <carter> why not?
22:19:04 <erisco> I don't know how
22:19:10 <erisco> I keep getting stuck in the monad :(
22:19:13 <carter> describe what it hsould do
22:19:15 <carter> on examples
22:19:22 <c_wraith> erisco: oh, I see.  The problem is those maybes
22:19:26 <carter> also i think you should look at transofrmers
22:19:33 <carter> http://hackage.haskell.org/package/MaybeT-0.1.2/docs/Control-Monad-Maybe.html
22:19:51 <erisco> as I said, when mx >>= f  is m Nothing, then l = BinEmpty
22:19:55 <c_wraith> erisco: why do you have those Maybes?
22:20:00 <erisco> and when  mx >>= g is m Nothing, then r = BinEmpty
22:20:08 <c_wraith> mx >>= f will *never* be nothing
22:20:09 <carter> erisco: look at http://hackage.haskell.org/package/MaybeT-0.1.2/docs/Control-Monad-Maybe.html :)
22:20:15 <erisco> c_wraith, to indicate the terminating condition
22:20:26 <c_wraith> mx >>= f  has type m (Maybe a)
22:20:40 <erisco> c_wraith, that is why I said "m Nothing"
22:20:45 <erisco> I don't know how else to put it
22:20:53 <carter> m Maybe a
22:20:59 <carter> so MaybeT m a
22:21:36 <trillioneyes> "return Nothing" would be more pedantically correct
22:21:44 <c_wraith> erisco: then you want to bind the results of the monadic computation and branch based on them.  that requires using >>= at the top level in your answer, making the return type m (BinTree a)
22:22:04 <jmcarthur> lispy: ah, yes, i'm guessing it's not ghc's own custom assembler or anything.
22:22:12 <erisco> c_wraith, hm, I really do not want that though so I'll have to figure out what to do
22:22:43 <erisco> trillioneyes, yes thanks
22:23:27 <c_wraith> erisco: well, if the functions have the type (a -> Maybe (m a)), you can make it work.
22:23:45 <erisco> c_wraith, I can change it to that. I am struggling to figure out that one too though
22:24:13 <c_wraith> erisco: since you say terminating condition, can I assume this process should be recursive?
22:24:23 <erisco> c_wraith, yes
22:24:32 <carter> jmcarthur: ghc odesn't have an assembler (yet..)
22:24:47 <erisco> with a -> Maybe (m a) perhaps it will simplify to a -> Maybe b
22:24:50 <erisco> I dunno
22:25:25 <c_wraith> erisco: well, no, not if you want to use >>= to combine
22:25:46 <erisco> see to get the value out of 'mx', it seems I am doomed to be stuck in the 'm' monad
22:25:56 <c_wraith> yes, that's the point of the interface.
22:26:13 <carter> a -> Maybe (m a) would always be   \x -> Just $ return a
22:26:14 <erisco> :D
22:26:26 <carter> a -> Maybe (m a) would always be   \x -> Just $ return x
22:26:55 <c_wraith> erisco: oh, I see.  since you start with an m a, instead of an a, you can't write it with (a -> Maybe (m a)), either
22:27:17 <erisco> c_wraith, yeah I've shot myself in the foot
22:27:31 <erisco> I think it can be refactored though
22:27:47 <erisco> this *might* work lemme see http://lpaste.net/97817
22:28:55 <pingu> I'm looking to turn a [B.ByteString] into a Ptr CString (char **strings) for a FFI binding. Has anyone got an idea how?
22:29:40 <carter> erm
22:30:05 <carter> pingu: you'd wanna look at using a storable array of pointers to bytestrings
22:30:06 <pingu> Is it a matter of allocing an array of ptrs then just poking them?
22:30:07 <carter> rather than a list
22:30:23 <carter> vector is the recommened
22:30:31 <carter> array choice
22:30:46 <carter> pingu: how else would you do it? sounds like you have the right idea
22:31:40 <erisco> no I guess not
22:31:40 <pingu> carter: I was hoping with a useAsCStringArray function hidden somewhere ;)
22:32:02 <pingu> Okay. I'll give that a go. Thanks.
22:32:05 <carter> well, it'd have to involve a storable array righ?
22:32:07 <erisco> I guess I'll look at these transformers
22:32:11 <erisco> and see what they are about
22:33:00 <carter> gluck
22:34:53 <pingu> carter: ah. I see your point with the storable array now. I was going to allocate a blob and do that all my self. This is easier. Thanks.
22:38:13 <prophile> so ArrowApply has app which makes an arrow equivalent to a monad
22:38:20 <prophile> is there an equivalent for comonads?
22:39:55 <erisco> c_wraith, even if I take 'a' instead of 'm a'
22:40:02 <erisco> c_wraith, I still dunno what to do :(
22:40:54 <c_wraith> erisco: why doesn't http://lpaste.net/97817 work?
22:41:15 <erisco> c_wraith, it compiles but does not let me do what I want
22:41:27 <c_wraith> well, yes.  What is it you want to do that it can't?
22:41:44 <erisco> that is hard to explain
22:41:50 <erisco> this is closest, which I posted originally http://lpaste.net/97818
22:41:53 <erisco> and it compiles and runs
22:42:11 <erisco> but, there is no terminating condition for BinEmpty
22:42:20 <erisco> that is what I am trying to add in via the Maybe
22:43:10 <erisco> but I can't squeeze any information out of the monad interface of course
22:43:14 <erisco> hm
22:43:59 <c_wraith> if the termination condition depends on the a values, you're more or less stuck with (a -> m (Maybe a)) -> (a -> m (Maybe a)) -> m a -> m (BinTree a)
22:44:04 <erisco> maybe I can add (m a -> Bool)
22:45:24 <c_wraith> you could do that, so long as you're aware that if often won't be implementable in the way you want.  What types do you anticipate m being?
22:45:38 <erisco> State, mainly
22:46:01 <erisco> maybe I can return m (BinTree (m a))
22:46:04 <c_wraith> then you could only implement (m a -> Bool) via a runstate
22:46:19 <c_wraith> which means you'd have to ignore the current state, because you couldn't see it
22:46:47 <erisco> yeah I am designing this the wrong way because I am trying to break the monad interface
22:47:01 <erisco> if I put the return type inside the monad perhaps that'll work
22:47:13 <erisco> then if the monad supports m a -> a there is nothing lost
22:50:33 <erisco> there maybe this is what I am after http://lpaste.net/97819
22:54:32 <erisco> or maybe the m (BinTree a) version is sufficient *shrug*
22:54:34 <erisco> I'm crazy
23:03:58 <pingu> Given an arbitrarily long list of functions such as: let fs = [(\f -> f 1 ), (\f -> f 2)]
23:04:13 <pingu> Is there any way I can do this:
23:04:14 <pingu> > fs !! 0 $ (\a -> fs !! 1 $ (\b -> print [a,b] ))
23:04:15 <lambdabot>  Not in scope: `fs'
23:04:15 <pingu> [1,2]
23:04:15 <lambdabot>  Perhaps you meant one of these:
23:04:15 <lambdabot>    `fst' (imported from Data.Tuple),
23:04:15 <lambdabot>    `f' (imported from Debug.SimpleReflect),
23:04:15 <lambdabot>    `s' (imported from Debug.SimpleReflect)Not in scope: `fs'
23:04:58 <pingu> without needing to know the length and assign names
23:05:17 <pingu> I'm sure it's obvious. It's completely eluded me though.
23:05:20 <erisco> pingu, fmap id onto the list of functions
23:05:40 <erisco> I think, if I understand what you want
23:05:56 <erisco> > fmap id [(\f -> f 1), (\f -> f 2)]
23:05:57 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
23:05:57 <lambdabot>    arising from a use of `M753206548683322658327037.show_M7532065486833226583...
23:05:57 <lambdabot>  The type variable `t0' is ambiguous
23:05:57 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
23:05:57 <lambdabot>  Note: there are several potential instances:
23:06:09 <erisco> :(
23:06:57 <erisco> I do not know what went wrong
23:07:20 <erisco> > fmap id [(\f -> f 1), (\f -> f 2)] :: [Int]
23:07:21 <lambdabot>  Couldn't match expected type `(a0 -> t0) -> t0'
23:07:21 <lambdabot>              with actual type `GHC.Types.Int'Couldn't match expected type `(a...
23:07:21 <lambdabot>              with actual type `GHC.Types.Int'
23:08:12 <erisco> oh
23:08:21 <erisco> > fmap ($id) [(\f -> f 1), (\f -> f 2)]
23:08:23 <lambdabot>  [1,2]
23:08:25 <erisco> there we go :D
23:08:52 <erisco> pingu, is that what you were looking for?
23:09:16 <pingu> erisco: it works. but. I don't think it's exactly the same as what I wrote by hand.
23:09:38 <pingu> In my actual code, these functions provide a foreign pointer which is cleaned up when the function returns
23:09:44 <erisco> I was just trying to match your sample input to your sample output. I do not understand what your code does :(
23:10:06 <pingu> let me provide a better example
23:13:35 <pingu> > let fs = [(\f -> f 1 >> putStrLn "end" ), (\f -> f 2 >> putStrLn "end" )]
23:13:36 <lambdabot>  not an expression: `let fs = [(\f -> f 1 >> putStrLn "end" ), (\f -> f 2 >> ...
23:14:11 <pingu> okay...
23:14:41 <pingu> then, fs !! 0 $ (\a -> fs !! 1 $ (\b -> print [a,b] )
23:14:56 <pingu> results in [1,2]
23:14:57 <pingu> end
23:14:57 <pingu> end
23:15:31 <erisco> what is the type of fs?
23:16:25 <pingu> My actual code is probably best to answer that... It is:
23:16:42 <pingu> [(CString -> IO a) -> IO a]
23:16:53 <apples> it sounds like you want the continuation monad
23:17:16 <pingu> that sounds promising
23:18:04 <dv-> :t callCC
23:18:04 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
23:19:47 <flebron> So, would this be possible in principle? I would like a statically checked AVL tree, using DataKinds. I can create data N = Z | S N, and use that to encode the possible AVL tree balance factors, leading to a statically checked correctness of the AVL invariants.
23:20:01 <apples> > let fs = [(\f -> f 1), (\f -> f 2)] in runCont (liftM print $ sequence $ map cont fs) id
23:20:02 <lambdabot>  <IO ()>
23:20:12 <apples> d'oh, of course lambdabot doesn't show it
23:20:12 <flebron> (I ask because I have some free time these days, and it seems like a reasonable thing to learn DataKinds with.)
23:20:37 <pingu> apples: awesome, thanks.
23:20:50 <apples> no prob
23:23:22 <apples> i guess there's no point in putting the print inside, but you get the point, heh
23:25:05 <pingu> apples: I'm pretty sure this will do exactly what I want. Just reading the implementation over.
23:35:00 <mjrosenb> carter: so, if you have any recommendations on how I should structure this code to work asynchronously, I'm all ears.
23:47:36 <erisco> if I have monads mx and my, can I get their values without sequencing them?
23:48:47 <erisco> hm never mind
23:49:17 <trillioneyes> erisco: you mean without causing one to be processed before the other?
23:49:28 <erisco> trillioneyes, yes
23:51:01 <erisco> though that does not make sense
23:51:02 <erisco> so
23:51:11 <erisco> I thought of how I can refactor my problem
23:52:54 <dibblego> am I right that some Show instances cannot be written manually, because sometimes parentheses are inserted and the manual implementation has no way to know that they are required?
23:53:34 <erisco> dibblego, you can implement Show manually
23:53:51 <dibblego> I can, but can I get the same instance as would have been derived, every time?
23:53:52 <erisco> some instances? I don't know. sorry missed that part of your question
23:54:00 <dibblego> let me write up an example
23:55:13 <flebron> Suppose I have some code like "foo (F x y) = f x; foo (G x y) = f x; foo (H x y) = f x;". Is there a way to somehow pattern match on either F, G, or H?
23:55:39 <flebron> (Definitely would need an extension.)
23:55:51 <nisstyre> flebron: on one line? I guess not
23:56:02 <shachaf> foo = f . gimmeTheX
23:56:15 <dibblego> http://lpaste.net/97820 can I write a manual Show instance that is the same as the derived one/
23:56:16 <dibblego> ?
23:56:19 <nisstyre> yeah just use an accessor function
23:56:49 <shachaf> dibblego: You have to define showsPrec, not just show.
23:56:53 <flebron> Is there a better way than case-by-case if I'm defining my ctors using GADTs? (Actual code: http://lpaste.net/8365714952433958912 )
23:56:58 <dibblego> oh right
23:57:23 <flebron> (I can definitely say value (Leaf x) = x; value (Balanced x _ _) = x; ..., but perhaps there's a shorter way.)
23:58:04 <dibblego> so I would say showsPrec n = case n of 0 -> use parens; _ -> don't use parens
23:58:55 <flebron> Sort of a mix between GADTs and record syntax, I suppose.
23:59:03 <shachaf> You can look at the Report for how Show instances are generated, or ask GHC for the code it actually generates.
23:59:20 <dibblego> ok cheers
23:59:51 <shachaf> http://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18600011.4
