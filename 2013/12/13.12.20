00:00:22 <pqmodn> gamegoblin: yeah it does. you can make the third module the "main" one which re-exports the other two
00:00:38 <pqmodn> if you want to, anyway
00:00:48 <gamegoblin> Huh... how do you reexport an entire module?
00:00:58 <johnw> module Foo (module Bar) where
00:01:01 <johnw> import Bar
00:01:05 <gamegoblin> gotcha
00:01:16 <johnw> you can also do something trickier:
00:01:19 <johnw> module Foo (module X) where
00:01:21 <johnw> import Bar as X
00:01:23 <johnw> import Baz as X
00:01:24 <johnw> etc.
00:01:33 <johnw> if you find yourself re-exporting several modules
00:01:33 <pqmodn> ah, neat.
00:02:06 <joejev> johnw: cute trick, thanks
00:02:08 <pavonia> Oh, you can have several imports with the same qualifier?
00:02:20 <johnw> sure
00:02:29 <joejev> johnw: I actually know a perfect place to use that.
00:02:29 <johnw> I do that all the time with Data.Text as T and Data.Text.Encoding as T
00:02:48 <pqmodn> pavonia: yeah, but beware you can still get ambiguous occurrence errors
00:03:20 <pavonia> nice, that will make my code more readable
00:06:52 <piezo> johnw: i leanrt the "as X" trick from Yesod scaffold
00:07:30 <johnw> heh, I learnt it from Snoyman :)
00:08:24 * hackagebot language-puppet 0.10.4 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.10.4 (SimonMarechal)
00:08:26 * hackagebot hslogstash 0.3.5 - A library to work with, or as, a logstash server  http://hackage.haskell.org/package/hslogstash-0.3.5 (SimonMarechal)
00:16:31 <joejev> so I just looked at replacing listArray (0,29999) $ repeat 0 with: (newArray (0,29999) 0 :: IO (IOUArray Int Word8)) >>= unsafeFreeze where the type will be cast O(c) and I got better results on average, but much more scattered data? doesnt that function just call calloc?
00:16:46 <dhrosa_> hello, is there a built-in method for searching into a list that is sorted?
00:16:55 <dhrosa_> that woudl be faster than elem?
00:17:14 <dhrosa_> oh I think I found one
00:17:26 <dhrosa_> nvm that's not in the base haskell, so I'm still searching
00:17:51 <joejev> dhrosa_: wouldn;t that not exist even if it is sorted becuase of the nature of singly linked lists?
00:18:09 <pqmodn> dhrosa_: lists only provide support for linear traversal
00:18:22 <pqmodn> dhrosa_: look at using Set for membership tests
00:18:40 <dhrosa_> oh yeah I forgot haskell used linked lists
00:18:50 <dhrosa_> I was wondering why my binary search was so much slower than elem...
00:19:04 <joejev> dhrosa_: slower by log n
00:19:18 <pqmodn> dhrosa_: there is a fromAscList so it won't need to re-sort your list
00:19:34 <pqmodn> s/fromAscList/fromAscList constructor/
00:20:46 <joejev> does Criterion.Main.defaultMain gc between runs?
00:21:19 <pqmodn> joejev: http://www.haskell.org/pipermail/haskell-cafe/2010-March/074122.html
00:21:53 <pqmodn> i vaguely remember bos talking about this but that's the best i can do for now
00:22:43 <joejev> pqmodn: I think I found the option, thank you for the link
00:23:26 * hackagebot HSlippyMap 1.6 - OpenStreetMap Slippy Map  http://hackage.haskell.org/package/HSlippyMap-1.6 (j4pe)
00:33:26 * hackagebot HSlippyMap 1.8 - OpenStreetMap Slippy Map  http://hackage.haskell.org/package/HSlippyMap-1.8 (j4pe)
00:33:41 <lightquake> i just came up with a fairly terrible idea for something using the ghc api: write something that gets the type of an expression/identifier/whatever, but inverts type synonyms to try to make it as simple as possible
00:34:34 <shachaf> Sounds good. We could use it for lens.
00:34:51 <joejev> lightquake: you mean like, instead of String you get [Char]?
00:34:59 <lightquake> no, other way around
00:35:05 <shachaf> Make sure it's confluent!
00:35:13 <lightquake> shachaf: meaning?
00:35:21 <shachaf> Doesn't matter, can't be done anyway.
00:36:24 <lightquake> why not?
00:36:51 <lightquake> i mean i have a couple reasons in mind but i'm curious if there are any i missed :P
00:36:55 <shachaf> Because type synonyms can overlap.
00:37:02 <shachaf> I mean making it confluent can't be done.
00:37:10 <shachaf> You can certainly make something that can try.
00:37:10 <lightquake> oh. what's confluent mean?
00:37:22 <shachaf> https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)
00:37:30 <shachaf> That no matter which path you take you end up at the same result.
00:38:02 <lightquake> ah, yeah, that's obviously impossible
00:41:05 <Cale> But if all you want is a minimal number of constructors, that's probably NP-hard in principle, but easy in practice.
00:41:53 <lightquake> yeah, probably
00:42:03 <joejev> can you have a single module span more than one file?
00:42:48 <lightquake> types and inverse synonyms form a graph, you just iterate over that graph (cutting it off after a certain number of rewrites) and look for the 'simplest' type
00:43:07 <lightquake> joejev: no, each module corresponds to one file
00:43:13 <lightquake> you can have a module reexport another module though
00:43:18 <vervic> \list
00:43:33 <BoR0> in practice, what would be the advantage of Either over (x, y) tuple?
00:43:50 <Cale> BoR0: Those are not interchangeable
00:44:19 <BoR0> sorry, what do you mean by that?
00:44:22 <joejev> BoR0: A function that is like, f :: String -> Either FError Int
00:44:25 <Cale> They're not the same kind of thing at all. The values of type Either String Integer look like  Left "Hello"  or  Right 74
00:45:02 <BoR0> then I have ("Hello", 74) and I can use fst and snd for left and right respectively?
00:45:06 <lightquake> Either is the coproduct, (,) is the product</unhelpful>
00:45:07 <Cale> Something of type (String, Integer) might look like  ("Hello", 74)  where you have both at once, rather than the option of one or the other.
00:45:25 <BoR0> aha, I see
00:45:32 <BoR0> but, we can do something like ("Hello", Nil)
00:45:39 <lightquake> what's Nil?
00:45:41 <Cale> BoR0: no
00:46:04 <Cale> Well, you *could* try  (Maybe String, Maybe Integer), but that's also not the same
00:46:11 <Cale> (Nothing, Nothing) is in that type, for instance
00:46:22 <Cale> as well as (Just "Hello", Just 74)
00:46:42 <Cale> While if you have something of type Either String Integer, you'll never get neither, and you'll never get both at once.
00:46:46 <joejev> BoR0: do you mean like, ("Hello",undefined)
00:46:58 <BoR0> well what Cale gave as an example using Maybe will work
00:47:09 <Cale> It won't really work
00:47:17 <BoR0> I mean, it's better than my example ("Hello", Nil)
00:47:45 <larsrh> BoR0: those are all different things: (Maybe a, Maybe b), (a, b), Either a b
00:47:59 <larsrh> Which one of those'll work depends on, well, which one you need.
00:48:02 <Cale> There's a map Either a b -> (Maybe a, Maybe b), but there isn't a good function of type (Maybe a, Maybe b) -> Either a b
00:48:22 <BoR0> I understand
00:48:43 <BoR0> thanks!
00:48:50 <shachaf> Hmm, do you have an ordering on function goodness? E.g. "const undefined" > "const (undefined,undefined)"?
00:49:14 <Cale> shachaf: "totally defined" would do here.
00:49:48 <Cale> shachaf: Or is that a separate question?
00:50:03 <Cale> Function types have a definedness ordering just like all the others :)
00:50:20 <lightquake> so, in order to do this i'm going to need to dive into GHC internals so I can figure out how to turn a type synonym into a rewrite rule
00:51:05 <shachaf> Cale: It wasn't meant very seriously.
00:51:26 <shachaf> lightquake: It sounds to me like it would be easier to just do it yourself.
00:51:35 <lightquake> shachaf: what do you mean?
00:51:40 <shachaf> Rather than use GHC internals.
00:52:14 <lightquake> how would you suggest i do that?
00:52:44 <shachaf> I'm just not sure how GHC internals will really help you that much.
00:53:02 <shachaf> Oh well, I haven't thought about it or anything. If you think it helps then it probably does.
00:54:52 <lightquake> well, TyCon.txExpandTyCon_maybe does the expansion, so all i have to do is invert it!
00:56:55 <lightquake> ... this is looking fairly terrifying
00:57:28 <shachaf> "well, symbolicDifferentiate computes derivatives, so all i have to do is invert it!"
00:57:48 <lightquake> :D
01:06:49 <pfurla> every time I hit enter in the haskell emacs mode it opens the haskell-mode help, any ideas what it is?
01:10:20 <lightquake> pfurla: you need to pick an indentation mode
01:10:53 <lightquake> in your init.el or whatever, do (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
01:11:49 <lightquake> or 'turn-on-haskell-indent, or 'turn-on-haskell-simple-indent
01:12:49 <pfurla> (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
01:13:02 <pfurla> i will try now, thanks
01:13:15 <lightquake> you'll also need to M-x turn-on-haskell-indentation in any open Haskell buffers
01:14:29 <pfurla> worked yeah!
01:14:33 <pfurla> yep
01:15:02 <pfurla> old Meta-run-a-emacs-command
01:15:18 <pfurla> thanks lightquake
01:20:59 <jaspervdj> carter: It's actually intended. I also always write Http instead of HTTP in code. Personlly I think that stuff like HttpFoo is much easier to read than HTTPFoo :-)
01:21:33 <johnw> i agree
01:21:39 <mauke> HTTP_Foo
01:21:40 <shachaf> You would be a big fan of XMLHttpRequest!
01:21:46 <johnw> all caps words within camel case get noisy
01:21:58 <johnw> SMTPMail vs SmtpMail
01:22:00 <mauke> (camel case)--
01:22:06 <jaspervdj> shachaf: Haha, built-int inconsistency :-)
01:22:12 <mauke> smtp-mail
01:22:27 <shachaf> preflex: karma camel case
01:22:27 <preflex>  camel case: -2
01:22:31 <johnw> in c++ land I use only foo_bar, in lisp land I use only foo-bar, and in Haskell, only fooBar.  I can't really say which I prefer
01:22:40 <mauke> you know what? any new language I design will allow - in identifiers
01:23:01 <quicksilver> I use foo'bar because it means I can pretend to be the author of a fantasy novel while I program
01:23:07 <mauke> haha
01:23:13 <shachaf> mauke: You should use Agda. Almost maximum flexibility!
01:23:21 <mauke> that's too much!
01:23:24 <johnw> foo☃bar
01:23:27 <shachaf> Hence "almost"
01:23:34 <mauke> var ಠ_ಠ;
01:23:39 <shachaf> johnw: That's not even valid. :-(
01:23:48 <mauke> ಠ is a letter
01:23:50 <johnw> in my future language it will be!
01:24:10 <johnw> snow☃hask
01:24:21 <shachaf> CamelCase--
01:24:39 <mauke> preflex: karma camelcase
01:24:40 <preflex>  camelcase: -4
01:24:55 <mauke> preflex: karma caramelcase
01:24:55 <preflex>  caramelcase has no karma
01:25:15 <johnw> one thing to like about camel case is that "fooBarBaz" has two fewer characters
01:25:37 <shachaf> I just write pre-gzipped code.
01:25:40 <shachaf> Much more concise.
01:25:43 <scott_> On the other hand foo-bar-baz is way easier to read quickly, ime
01:25:47 <johnw> and you can teach emacs to treat that as 3 separate words if you want; in fact, it will even show it to you as foo-bar-baz, but maintain the real word in camel case
01:26:02 <mauke> johnw: that's like using tabs because it's fewer characters than spaces
01:26:14 <johnw> mauke: i cannot debate that
01:26:21 <johnw> ah, tabs
01:26:32 <scott_> I think I can type dashed identifiers more quickly as well
01:26:44 <mauke> dashing across the keys ...
01:27:05 <johnw> we recently had an IDE bug where type information was being reported at the wrong position , and it turns out that one function in the whole file used tabs and none of the others did.  Took a long time to find that
01:43:32 * hackagebot yaml-config 0.2.1 - Configuration management  http://hackage.haskell.org/package/yaml-config-0.2.1 (FedorGogolev)
01:51:12 <xintron> Which library would you guys recommend for fetching HTTP(S) data (with support for following redirects)? http-conduit?
01:58:10 <Feuerbach> xintron: yes, http-conduit is good
02:09:40 <johnw> i concur
02:09:46 <johnw> i use http-conduit a lot
02:11:20 <xintron> And I guess tagsoup is great for reading specific tags in a HTML document
02:23:40 <jle`> i've found in haskell that directories and package names and stuff like that are all -'d
02:24:36 <jle`> in contrast to others where you _
02:24:50 <jle`> actually not coming from lisp, -'s were very foreign to me
02:52:22 <bizarrefish> Hi all
02:53:17 <bizarrefish> I'm playing with haskell, trying to get my head around typeclasses, and have hit a stumbling block; I would expect this to typecheck: http://pastie.org/8565363 . It gives "malformed instance declaration". Can anyone tell me what's wrong with it.
02:53:56 <bizarrefish> malformed instance type, i mean
02:55:41 <shachaf> bizarrefish: Missing parentheses?
02:55:58 <shachaf> What you wrote means (fmap (+1) NumAndTransform) (3, (*2))
02:56:36 <merijn> bizarrefish: Transform is a type, not a typeclass
02:56:45 <merijn> bizarrefish: You can't have types as constraints
02:56:50 <bizarrefish> shachaf: Oh yeah. Nah, it didn't get that far anyway. It's the instance type.
02:56:57 <bizarrefish> *instance dec
02:57:21 <bizarrefish> merijn: I can't? Ah, okay... I see now
02:57:32 <merijn> bizarrefish: What would it mean to have a type as a constraint?
02:57:46 <shachaf> bizarrefish: Well, you didn't give the full error, including the most important part, the line number.
02:57:51 <shachaf> So it's hard to tell where to look. :-)
02:58:36 <speckle> what kind of programs is haskell best for, if I'm trying to think of a cool project? :)
02:59:07 <bizarrefish> I
02:59:22 <merijn> bizarrefish: Ah, I see what you intend to do, but 1) this is not the right apporach syntatically and 2) it'd violate the Functor laws
02:59:38 <bizarrefish> True; I'll be clearer next time I get confused :)
02:59:48 <joneshf-laptop> speckle, ones where you want to be able to reason about the project
02:59:50 <merijn> speckle: Depends on whether you have previous programming experience
03:00:24 <merijn> speckle: I tend to recommend multithreaded server stuff, because it hilights how concurrency is much simpler in haskell than many other languages
03:00:35 <speckle> ah, thanks :)
03:00:39 <merijn> speckle: Other common projects are simple parsers/programming languages
03:00:52 <speckle> so things that are concurrent, or otherwise complex to handle in another language
03:01:06 <merijn> speckle: Lots of people doing webdev now, but frankly I don't care too much about that so I have no recommendations there
03:01:36 <speckle> webdev, as in Haskell to handle the servers, or Haskell to generate HTML/JS?
03:01:42 <merijn> speckle: In general for newbies I'd recommend just anything you feel like that doesn't involve opengl/GUI (as the opengl/gui libraries can be rather hairy)
03:02:07 <merijn> speckle: I meant haskell for servers, but on the other hand, if you're feeling adventuruous ghcjs is nearing production ready :p
03:02:51 <bizarrefish> merijn: I need to get to grips with writing sensible code in haskell. In this case, I can see that: NumAndTransform is badly named as there's nothing Nummy about n and nothing Transformy about t. Also, Transform is a bad name for a function :: x -> x (no reason it couldn't be x -> y). Any other badness that's worth pointing out there/
03:02:53 <merijn> I believe the production release is scheduled to coincide with the GHC 7.8 release
03:02:55 <speckle> I see! thanks
03:02:56 <bizarrefish> ?
03:03:58 <merijn> bizarrefish: Well, the other thing is that Functor's are supposed to follow the Functor laws, one of which is "fmap id x" should be identical to "id x", which doesn't apply to your example fmap
03:04:45 <bizarrefish> merijn: You're right. That's possibly the worst functor ever.
03:04:48 <merijn> bizarrefish: Because you'd use the transform function on the tuples first element when doing "fmap id", which would change it's value (and also it's possible that can't even typecheck sanely :))
03:04:49 <bizarrefish> :P
03:05:45 <merijn> bizarrefish: I tend to advocate reimplementing existing functor/applicative/monad instances for datatypes as practice
03:05:58 <robonerd> hi, is the author of http://blog.reactiveprogramming.org/ around?
03:06:14 <merijn> bizarrefish: Good candidates being: Maybe, Either e, tuples, functions, State, Reader, Writer, etc.
03:07:36 <companion_cube> that would be nice to have some formal proof that class instances satisfy the class' laws
03:08:01 <companion_cube> maybe that's in the range of what automated provers can do (for relatively simple monoid/functor/monad instances)
03:10:11 <merijn> companion_cube: You're far from the first to offer that idea :)
03:10:25 <companion_cube> I'm not surprised
03:13:09 <bizarrefish> merijn: I'll go for that, cheers for the advice dood. Also, found another problem with the intent of my "functor". My instance was adding the constraint that fmap's "f" had to be of type a -> a, which isn't very functor-y.
03:13:25 <merijn> bizarrefish: Yeah
03:13:43 <companion_cube> merijn: I think I read something on a prover for haskell once
03:14:12 <merijn> bizarrefish: Simple approach is to just cover the data declaration from the libraries and rename it like "MyMaybe" or whatever, then implement instances for that
03:14:26 <bizarrefish> All this stuff is so freaking cool. I'm a C++/Java/CClojure person, so I thought I had breadth.
03:15:04 <kinslayer> bizarrefisk: and yet no lazy language :D
03:15:24 <bizarrefish> My next goal is to properly, intuitively 'get', the continuation monad. I can sort of reason about it, but the idea falls apart in my head very easily. Might try implementing that.
03:16:20 <bizarrefish> kinslayer: Clojure has lazy, and sequences are pretty much always lazy. But outside that, my experience is indeed limited.
03:17:01 <kinslayer> bizarrefish: I meant a default lazy language, clojure is not lazy in the core, it just got one lazy structure ?
03:17:40 <TheBrayn> I once tried to learn a lazy language but it did not feel like it
03:18:04 <kinslayer> TheBrayn: Good one :D
03:18:40 <speckle> Python has a lot of laziness, but it's not very functional and people get upset when you use map() and reduce() too often
03:18:53 <companion_cube> I'd like a lightweight, strict haskell, personnalyy
03:19:19 <bizarrefish> kinslayer: With lisps, with the lack of distinction between libraries and language, functions and syntactic operators, it's a bit trick to talk about what's in the core and what isn't. The quote: "Lisp isn't a programming language, it's a building material" is meaningful here.
03:19:23 <ciaranm> TheBrayn: http://ro-che.info/ccc/11
03:19:26 <kinslayer> speckle: Well also python is not lazy at the core (although I was not aware of the lazy bits in it)
03:19:35 <bizarrefish> *tricky
03:20:00 <kinslayer> bizarrefish: I know, I just mean the evaluation model is strict in clojure ?
03:20:05 <speckle> Ah, there are actually languages that are lazy at the core. That's interesting
03:20:37 <bizarrefish> kinslayer: eval is bound to a function, but there's nothing stopping you rebinding eval and completely changing the semantics of the language :P
03:21:14 <kinslayer> bizarrefish: Okay now we are quiet a long way out, and here you are right, you could change the language to be more lazy.
03:23:22 <bizarrefish> companion_cube: I was looking at http://roy.brianmckenna.org/ . Thinking of using it in a project soon. Maybe it's lightweight /
03:23:25 <bizarrefish> ?
03:30:04 <kinslayer> So I have a webpage in ByteString (well it is HTML inside the bytestring), is there a good library for searching the document ?
03:33:28 <merijn> bizarrefish: hah, I *still* don't intuitively get the continuation monad, so don't worry about it :p
03:37:07 <shachaf> merijn: Just do Codensity instead!
03:39:45 <merijn> shachaf: I don't even know what that means :(
03:40:02 <merijn> kinslayer: html-conduit lets you traverse html documents in a nice way
03:40:14 <merijn> kinslayer: Things like "grab all links inside a h1 tag", etc.
03:40:32 <kinslayer> Okay I had looked at tagsoup until now, but I think I will look into this
03:40:37 <shachaf> merijn: newtype Codensity m a = Codensity { runCodensity :: forall r. (a -> m r) -> m r }
03:41:01 <shachaf> It's less scary than it sounds.
03:41:08 <mr-> Is m supposed to be a monad?
03:41:33 <merijn> shachaf: I'll take a stab at it in a bit
03:41:43 <BoR0> in layman terms, could someone tell me why generally monads are useful? for example, as associativity in monoids is useful for parallel processing.
03:42:15 <merijn> shachaf: I have ascended from needing to linewrap type signatures to linewrapping single types, I might slowly be getting lens-ready :p
03:42:25 <merijn> BoR0: Because they expose a common pattern/interface
03:43:00 <merijn> BoR0: As I mentioned to someone before, keep in mind monads were not originally part of Haskell (even for IO), they were added later once people realised they're a great idea
03:43:06 <BoR0> but doesn't Functor also expose a common pattern/interface?
03:43:10 <dixie> Can somebody explain in short what is monad?
03:43:13 <merijn> BoR0: Yes
03:43:14 <BoR0> there has to be something more than that
03:43:51 <merijn> dixie: Any type 'm' that exposes the following two functions "return :: a -> m a" and "(>>=) :: m a -> (a -> m b) -> m b" with some laws
03:43:53 <BoR0> is it the reason about monads "boxing" values in a common way?
03:43:54 <merijn> BoR0: Why?
03:44:08 <merijn> Why does there have to be something more than that?
03:44:17 <BoR0> because they are there for a reason :)
03:44:25 <merijn> People keep blowing this monad thing out of proportion
03:44:36 <merijn> They're just not that hard or complicated
03:44:39 <trolling> I think the question is from a practical point of view what would actually go wrong if a monad instance didn't satisfy one of the laws
03:44:46 <speckle> yeah, I thought monad was just a monoid in the category of endofunctors, what's the big deal?
03:44:54 <merijn> trolling: Code would behave counterintuitively
03:45:12 <merijn> speckle: That's a useless in joke that everyone's tired off. Even if you ignore that, they're still not hard
03:45:15 <trolling> sure, what code though?
03:45:17 <kinslayer> merijn: and monads doesn't
03:45:34 <speckle> Okay sorry, I guess it's too old for this channel :)
03:45:35 <merijn> trolling: Depends on how you implemented the instance wrong
03:45:55 <merijn> trolling: One of the laws is "x >>= return . id" == "id x"
03:46:04 <trolling> as an example, ListT being non-associative when the underlying monad isn't commutative
03:46:07 <merijn> trolling: That's pretty much just common sense
03:47:07 <mr-> trolling: see http://www.haskell.org/haskellwiki/Monad_laws
03:47:22 <mr-> section 2 But why should monads obey these laws?
03:47:39 <shachaf> mr-: Yes, though it doesn't have to be.
03:47:49 <trolling> mr-: thanks
03:51:15 <mr-> That codensity-condition looks awful :-/
03:53:53 * hackagebot uuagc 0.9.50.2 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.50.2 (JeroenBransen)
03:57:48 <mr-> Ah, makes some sense, though
03:58:28 <shachaf> newtype Codensity m a = Codensity { runCodensity :: forall r. (a -> m r) -> m r }
03:58:31 <shachaf> (>>=) :: Monad m => m a ->                          forall r. (a -> m r) -> m r
03:59:24 <shachaf> That's your hint. Now I'm going to sleep.
04:04:36 <bizarrefish> Best explanation for a monad I can think of: Composable computations. The reason for the laws is to ensure sense-making composability norms. In most other language's schools of thought, the only composable thing that they focus on is functions, and function composition is quite simple.
04:07:15 <quicksilver> that sounds like a good intuition, bizarrefish
04:07:28 <quicksilver> but it might not actually help people wrestle with the practical problems they find.
04:08:42 <seanparsons> I'm clearly missing something with Template Haskell, does anyone know what that is?
04:08:43 <seanparsons> https://gist.github.com/seanparsons/7617dcd2b9643ee1c816
04:13:50 <mgsloan> seanparsons: In order to use a function in a TH splice, it needs to be imported.  This way, GHC doesn't need to load only part of a module into the interpreter
04:14:07 <mgsloan> So, you'll have to put buildEncodeDecodeTest in another module
04:14:16 <seanparsons> Ah, that makes a load of sense.
04:14:43 <seanparsons> I need to tune myself correctly to GHC errors, they never quite seem to mean what I think they do.
04:16:35 <quicksilver> it also means you can't use functions from mutually recursive module groups within splices in any of those modules. (I assume).
04:17:12 <bizarrefish> seanparsons: I'm also finding this. I'm pretty new to the whole haskell thing, and for such well-constructed, information-dense error messages, it's amazing how I just miss the point time and time again.
04:17:23 <kinslayer> is html-conduit the same as Text.HTML.DOM ?
04:17:26 <mgsloan> seanparsons: Yeah, some of GHC's suggestions should always be ignored.  Like "Possible fix: add an instance ..." is almost never what you want to do
04:17:55 <merijn> mgsloan: Well, RankNTypes suggestion is usually right :p
04:18:04 <merijn> As are FlexibleContexts/FlexibleInstances
04:18:12 <mgsloan> merijn: Aye, only *some*, most are spot on
04:18:18 <mgsloan> but some should just be left out
04:19:40 <mgsloan> quicksilver: Right, well, it'd be pretty hard to define some compiletime code that depends on its own output!  I suppose it could try to reach fixpoint, lol...
04:21:32 <quicksilver> mgsloan: you could compile partial modules to the extent that individual definitions weren't actually part of the larger mutual defintion
04:21:56 <quicksilver> mgsloan: this has been suggested in other contexts to let ghci load partial modules when just one definition contains a syntax or type error.
04:22:05 <quicksilver> The type inference part of GHC already does work at this level.
04:23:02 <mgsloan> quicksilver: Indeed!  dcoutts mentioned that they wanted to get more such partiality like -fdefer-type-errors into GHC
04:24:12 <quicksilver> since the type checker already does the mutually dependent group analysis part of the work is already there
04:24:15 <quicksilver> although, I'm not sure
04:24:32 <quicksilver> is type-inference dependency the same as execution dependency?
04:24:49 <mgsloan> It'd be cool if splices didn't sequence compilation the way they did.  I'd prefer that they not be allowed to reify things that are outputed from other splices in the same module.
04:25:22 <mgsloan> quicksilver: It seems quite reasonable that it would be.
04:25:38 <mgsloan> Afterall, type inference is abstract interpretation
04:27:10 <quicksilver> mgsloan: the sequencing thing feels inelegant
04:27:29 <mgsloan> Indeed, it totally breaks the nice commutative nature of top level declarations
04:27:43 <quicksilver> but the alternative - that each piece of metaprogramming which builds on the last requires a new module - would burn a lot of modules for some relatively natural constructions.
04:28:22 <mgsloan> Hmm, would it?  I mean, there's already the stage restriction that causes more modules to be needed
04:28:55 <quicksilver> on a similar note, deriving Ord and deriving Enum give up the commutative nature of data type alternatives. How quickly the siren of metaprogramming leads us to abandon the good ship Equational Reasoning.
04:29:05 <mgsloan> Is there a reason for the sequencing beyond "one splice might reify something generated by another splice"?
04:29:21 <mgsloan> haha
04:29:48 <quicksilver> (deriving Show gives up alpha-conversion, etc etc)
04:30:02 <mgsloan> Well, the good news there is that before the order wasn't providing any information, and with deriving, it is actually informative
04:30:44 <quicksilver> mgsloan: any kind of construction where you build a series of linked data types where each is built from the last requires the sequencing
04:30:59 <quicksilver> like building a type, then the type of its constructors, then the type of its zipper, and so on
04:31:13 <quicksilver> or, I think so. I'm rusty.
04:31:30 <mgsloan> Hmm, yeah, if you're generating datatype declarations, that's true
04:32:32 <mgsloan> hrmph, I suppose there is good reason for it. phooey!
04:32:49 <quicksilver> mgsloan: well, instead let's specify the sequencing (staging) explicitly using nested modules
04:32:57 <quicksilver> possibly nested anonymous modules
04:33:09 <quicksilver> and let the outer ones use things from the inner ones
04:33:13 <quicksilver> but obviously not the converse
04:33:20 <quicksilver> and you get back your commutativity of top-level definitions.
04:33:50 <mgsloan> Interesting idea
04:33:52 <mgsloan> I like it!
04:34:07 <mgsloan> How about where declarations are also nested modules?
04:34:16 <quicksilver> it's turtles all the way down.
04:34:35 <quicksilver> actually multiple modules in one file (nested and otherwise) would go a long way to making haskell modules less annoying.
04:34:36 <mgsloan> And the nested modules can dequalify qualified names that come from the parent module
04:34:59 <mgsloan> GHC needs to be able to figure out a file's dependencies quickly, though
04:35:14 <quicksilver> computers are a gazillion times quicker than when GHC was invented
04:35:17 <mgsloan> I guess such a performance concern is pretty mute, yeah
04:35:23 <quicksilver> I think that problem is less serious than it used to be
04:35:36 <mgsloan> It is kindofa nice property that you can look at the top of a module and get its dependencies, though
04:35:40 <quicksilver> true
04:35:53 <mgsloan> But yeah, why not allow any top level declaration in where clauses? even import statements
04:36:00 <mgsloan> local imports would do wonders for DSLs
04:36:22 <quicksilver> local precedence changes could utterly bewilder unwary readers of the code
04:36:50 <quicksilver> but if there is one thing that I've never thought about haskell it's "this language just doesn't have enough ways to bewilder unwary code readers"
04:36:58 <mgsloan> Avoiding reader confusion is the responsibility of the DSL designer
04:37:06 <mgsloan> hahah
04:37:24 <mgsloan> Yeah, nested modules would work better for this I think
04:37:36 <mgsloan> if the dequalification is in a where clause it could easily be overlooked
04:37:53 <mgsloan> whereas nested modules are saying "We are now in a very different lexical context"
04:38:39 <quicksilver> "We are not in Kansa any more. Here be bewilderment."
04:38:51 <quicksilver> +s
04:38:57 * hackagebot digestive-functors-heist 0.8.3.1 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.8.3.1 (JasperVanDerJeugt)
04:38:59 * hackagebot repa-fftw 3.2.3.1 - Perform fft with repa via FFTW  http://hackage.haskell.org/package/repa-fftw-3.2.3.1 (AtsuroHoshino)
04:40:40 <mgsloan> This reasoning makes me glad I didn't finish implementing local dequalification a year or two ago when I started working on it
04:40:46 <quicksilver> mgsloan: also the ability to re-export qualifications, and we'd have a lot of syntactic convenience.
04:40:48 <xintron> Strange, when having library-profiling in the cabal config it fails to install hoogle (and some other packages). Oh well, don't really think I need it so I guess it's just easier to skip
04:41:19 <quicksilver> (lexical convenience?)
04:42:18 <mgsloan> quicksilver: Hrmm, that seems tricky.  I wouldn't want that to be possible across multiple files, but adding a special rule for nested module re-export seems hacky
04:43:08 <mgsloan> (and actually it's probably not useful for nested modules)
04:43:57 * hackagebot repa-sndfile 3.2.3.2 - Reading and writing sound files with repa arrays  http://hackage.haskell.org/package/repa-sndfile-3.2.3.2 (AtsuroHoshino)
04:46:00 <quicksilver> mgsloan: I didn't mean for nesting
04:46:12 <quicksilver> mgsloan: the namespace is distinct from the nesting, the namespace is really just a trick with .
04:46:38 <quicksilver> the idea is that if Quicksilver imports Text as T (and re-exports it as T) then you can use Quicksilver.T.readFile
04:46:53 <quicksilver> or if you import Quicksilver qualified as Q then Q.T.readFile
04:47:18 <mgsloan> If you import "Quicksilver" do you get "T.readFile"?
04:47:20 <quicksilver> and if you choose to important Quicksilver unqualified then it invades your 'root namespace' as T.readFile
04:47:23 <quicksilver> yes
04:47:31 <quicksilver> but that's no worse than unquafilied imports are in general
04:47:31 <mgsloan> That's the bit that seems freaky to me
04:47:50 <quicksilver> and it means you can set up convenience modules with your favourite qualification styles
04:48:12 <quicksilver> have you never wanted to just "import MyContainers" and get Data.Set as S, Data.Map as M, Data.Seq as Sq, etc...
04:48:15 <quicksilver> ?
04:48:51 <mgsloan> I agree that would be nice, but for things like refactoring tools, this would be nightmareish
04:49:16 <mgsloan> Or could be, anyway.  Sufficiently smart tools could handle it
04:49:17 <quicksilver> would it be any worse than we have now?
04:49:26 <quicksilver> unqualified imports are already a nightmare
04:49:49 <mgsloan> I think so.  Right now given something like "T.readFile", I can look at the header and tell you the set of modules it might come from
04:50:17 <mgsloan> Hrmm, I guess it's not that much of a difference, you have a point
04:50:58 <quicksilver> if you're writing a refactoring tool you signed up for nightmares
04:51:12 <mgsloan> I do kinda like that you don't have to be suspicious of any of the unqualified imports, though
04:51:15 <quicksilver> if you design a language to make life easy on the IDE/refactoring tool you get Java. Which might not be a bad thing.
04:51:16 <mgsloan> Oh yes, indeed :)
04:51:24 <mgsloan> they're fun nightmares though
04:52:03 <mgsloan> just yesterday I managed to get it to handle this correctly:  "module Main(module X) where { import X; import Y as X }", and you rename X
04:53:08 <mgsloan> At least haskell refactoring is fairly tractable, unlike C++
04:53:57 <quicksilver> haskell refactoring is tractable but essentially requires a language implementation.
04:53:59 <bennofs1> mgsloan: Are you developing a refactoring tool for haskell? :O
04:54:24 <mgsloan> bennofs1: Yes, as part of FP Complete's IDE
04:54:26 <quicksilver> at least, a solid front-end, much more than a parser.
04:54:49 <quicksilver> to be honest, I think with a suitably annotated C++ compiler you could also refactor C++
04:54:59 <quicksilver> (by actually compiling it to understand it)
04:55:00 <bennofs1> mgsloan: Do you use the GHC API, haskell-src(-exts) or something else?
04:55:32 <quicksilver> it may be that even people who design code refactoring tools are not insane enough to try to modify a C++ compiler.
04:56:12 <bennofs1> I wonder how hard it would be to write GHC.HsModule -> HaskellSrc.HsModule
04:57:21 <mgsloan> Doh, technical issues over here
04:58:29 <mgsloan> quicksilver: I certainly took a hard look at HaRe before embarking on doing my own thing
04:58:59 <mgsloan> HaRe is definitely taking the "reimplement aspects of the language as part of each refactoring" approach
04:59:08 <mgsloan> To me, this seems really really hard
04:59:44 <mgsloan> And largely effort that doesn't pay off, since it gives lots of ways for refactorings to refuse to do anything
05:01:25 <mgsloan> So, instead these're more like "careful code manipulations" - things that are allowed to break compilation
05:01:46 <mgsloan> What's really not allowed is things that could silently change the meaning of code - that's a nono
05:02:29 <mgsloan> So, I can definitely understand the feeling that "You need to implement a big ol engine to do refactorings properly".  That's the impression that looking at existing tools gives
05:02:32 * quicksilver nods
05:03:05 <quicksilver> well to work out whether 'foo' in one module refers to the same symbol as 'foo' in another module is a fair amount of work
05:03:15 <mgsloan> You certainly need to do something to get good lexical info, like haskell-names or GHC bindings.  I'm using both, coincidentally
05:03:21 <mgsloan> Indeed
05:03:58 <mgsloan> It uses haskell-names, so that local refactorings can work even if the rest of the module is gobledegook
05:04:48 <mgsloan> But GHC should be used for global refactorings, so that no mistakes are made
05:06:33 <mgsloan> Overall, the main focus is making refactorings that you actually want to use, because the text changes try to respect the existing style (of course, not perfectly)
05:06:37 * bennofs1 would like a flag for GHC to automatically insert 'error "undefined"' when it encounters something like def = <Nothing here>
05:07:15 <mgsloan> bennofs: Yeah, one thing I'd like to experiment with is automatic diagnosis and resolution of syntax errors
05:07:46 <shiona> great, make haskell into javascript
05:08:00 <mgsloan> shiona: No, I mean as UI in an IDE, not as part of the compiler
05:08:11 <shiona> ah, well that makes sense
05:08:32 <mgsloan> Right, I suppose you were responding to bennofs flag idea
05:11:37 <mgsloan> But syntax errors are the last of my concerns - it's an interesting problem, but not a big deal when it comes to developer productivity
05:23:20 <narens> question: so, i know i can do "(1,1) & _1 (\x -> print x >> return (x+10))" but I'd like to do this when the value I'm modifying, i.e. (1,1), is inside a state.
05:24:38 <bennofs> What is the difference between HsIdent and HsSymbol in haskell-src?
05:25:02 <merijn> oh!
05:25:20 <merijn> Sounds like I'm just back in time to earn my PR money in the editor/IDE discussion :p
05:25:36 <merijn> Take a look at Lamdu :p
05:26:46 <mgsloan> merijn: Was discussing lamdu a bit with Peaker yesterday.  I already knew it was some really interesting stuff having played with it before, but the intended direction sounds really promising!
05:27:03 <mgsloan> (what with having type instantiation be part of the editor)
05:27:29 <mgsloan> It might be worthwhile making a Haskell backend for it, though
05:27:59 <mgsloan> Having an existing ecosystem to use to work out the kinks of a design is really valuable
05:28:04 <joejev> Can someone explain to me what Data.Function.fix does?
05:28:25 <merijn> joejev: Do you understand the following example?
05:28:32 <merijn> > let ones = 1 : ones in ones
05:28:33 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:29:00 <mauke> > let noes = "o noes" : noes in noes
05:29:00 <joejev> merijn: ones is just a recursicve definiton, sure
05:29:01 <lambdabot>  ["o noes","o noes","o noes","o noes","o noes","o noes","o noes","o noes","o ...
05:29:01 * hackagebot lord 2.20131220 - A command line interface to online radios.  http://hackage.haskell.org/package/lord-2.20131220 (rnons)
05:29:16 <mauke> > let noes = fix (\x -> "o noes" : x) in noes
05:29:18 <lambdabot>  ["o noes","o noes","o noes","o noes","o noes","o noes","o noes","o noes","o ...
05:29:23 <FreeFull> joejev: fix packages that recursion up and gives it to you as a parameter
05:29:28 <merijn> joejev: Right, now imagine we wanted to "point-free" that recursive definition (i.e. remove the name from it)
05:29:36 <merijn> joejev: That's essentially what "fix" let's you do
05:29:40 <merijn> > fix (1:)
05:29:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:29:47 <merijn> :t fix
05:29:48 <lambdabot> (a -> a) -> a
05:30:03 <joejev> merijn: okay, I looked at the source but that example makes much more sense, thanks
05:30:09 <mauke> fix only works with functions that don't look to closely at their argument
05:30:10 <merijn> joejev: Fix applies the function to it's own result
05:30:26 <merijn> joejev: Which, of course, only works if the function can start producing results before looking at it's argument
05:30:32 <mauke> it's like when you're time travelling
05:30:40 <mauke> don't change the past
05:30:43 <mauke> (or future)
05:30:44 <joejev> merijn: similarly I have used `on` in sortBy and such, but I am unsure what it really means
05:30:48 <merijn> joejev: In case of "1:" this works because it can return '1' before it looks at it's own argument
05:31:00 <merijn> joejev: on is really trivial compared to fix
05:31:02 <mauke> > on f g x y
05:31:02 <merijn> :t on
05:31:02 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
05:31:03 <lambdabot>  Could not deduce (Debug.SimpleReflect.Expr.FromExpr b0)
05:31:03 <lambdabot>    arising from a use of `Debug.SimpleReflect.Vars.g'
05:31:03 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr c)
05:31:03 <lambdabot>    bound by the inferred type of
05:31:04 <lambdabot>             it :: Debug.SimpleReflect.Expr.FromExpr c => c
05:31:24 <merijn> joejev: look at that type and it should be fairly clear
05:31:39 <mauke> > let f' = f :: Expr -> Expr -> Expr in on f' g x y
05:31:40 <lambdabot>  f (g x) (g y)
05:31:58 <mauke> > let f' = f :: Expr -> Expr -> Expr in (f' `on` g) x y
05:31:59 <lambdabot>  f (g x) (g y)
05:32:00 <joejev> merijn: oh, that is much is less interesting
05:32:01 <merijn> joejev: Basically, if I have a function wanting bs and I have a function to turn as into bs, then clearly I can make it a function that wants as
05:33:13 <joejev> why did they give that the name on? I think of on being like a relation ON a set or a -> a, idk
05:33:46 <mauke> > (compare `on` length) "hello" "yo"
05:33:47 <lambdabot>  GT
05:35:56 <xintron> I'm trying to get efficient with hoogle (locally) but having a hard time with it. It's perfect for viewing functions in libraries but it's hard to get a full library overview (as you can get in the online documentation on hackage).
05:36:07 <xintron> But maybe hoogle isn't the tool for this?
05:38:40 <deech> I want to convert a set of Haskell functions into a struct of C function pointers but I don't need to convert back. Is there a typeclass other than Storable that accomodates this?
05:39:38 <mauke> deech: what
05:41:59 <bartavelle> deech, just set the function you don't need in storable to "undefined"
05:42:00 <deech> mauke: Say I have struct { int (*some-func)(..), void (*some-other-func)(..) } and I want to use Haskell functions for `some-func` and `some-other-func` but I never need to `peek` at them again.
05:42:19 <deech> bartavelle: I was hoping that there was a safer option :).
05:42:36 <bartavelle> well, replace it with error, so that you get an explicit error message ;)
05:43:08 <deech> bartavelle: Also an option but first I wanted to check if there was a typeclass with just a `poke`.
05:43:14 <merijn> xintron: If you have "Documentation: True" in your cabal config (should be in ~/.cabal/config) packages should install documentation locally when you "cabal install"
05:43:31 <xintron> merijn, I have that set yes.
05:43:46 <merijn> I forgot the the default directory where they're installed, though
05:43:47 <mauke> deech: I don't see the problem
05:44:03 <mauke> deech: what are you trying to solve / where are you stuck?
05:44:42 <deech> mauke: Just trying to figure out if there's a better way than making `peek` `undefined` or and `error ...`.
05:44:53 <mauke> why do you need any of that?
05:45:26 <deech> Don't I need a Storable instance for my struct?
05:45:32 <mauke> depends
05:45:46 <mauke> but even if you do, what would you use undefined for?
05:45:48 <merijn> xintron: Can't quickly find it, try the cabal user guide to see what the default path is?
05:46:07 <deech> for the peek function, since I don't need to read them back.
05:46:19 <xintron> merijn, So I just need to look at the html files in that docs folder then I take it.
05:46:23 <mauke> deech: just implement it normally
05:46:42 <merijn> xintron: Yeah, if you open the index.html it should show you all locally installed libraries with working links
05:46:57 <merijn> xintron: Basically exactly the same stuff you'd see on Hackage
05:47:06 <deech> mauke: Ok. I'll do that. Thanks!
05:47:41 <xintron> merijn, ok. So if I want to get an overview of a package I would have to look at that index file and hoogle (the command-line program) is more for searching for a specific function (and not to get a general overview)
05:48:08 <merijn> xintron: Yeah, there might be a way to integrate the two, but I haven't bothered to look for it
05:48:45 <Luke> I'm trying to think of a way to make shake build my dynamic loader snap project and my static loader snap project
05:49:02 <xintron> merijn, ok. It's fine, I just were under the assumption that hoogle would fix that with the "hoogle server" but doesn't matter really
05:52:03 <zielwasserjunki> hi just a short question: is there any option to reduce typesynonyms to the basic types in ghci
05:54:32 <rasfar> ziel*: http://stackoverflow.com/questions/13595773/expand-type-synonyms-type-families-with-ghci maybe helps?
05:54:42 <rasfar> :kind!
05:56:20 <zielwasserjunki> Thats great!!! thank you very much rasfar
05:56:29 <merijn> blah
05:56:36 <merijn> shachaf broke my mind
05:56:54 <merijn> Applicative for codensity fries my brain...
06:00:54 <merijn> Any (minor!) hints how to proceed? http://lpaste.net/97261
06:01:29 <mauke> something something continuations
06:01:44 <merijn> I don't quite see how to fit "((a -> b) -> m r) -> m r)" and "(a -> m r) -> m r" into "(b -> m r) -> m r"
06:04:14 <mauke> wait, Codensity was the one that allowed a broken implementation, right?
06:04:54 <bennofs> What about: Codensity $ \h -> g $ \a -> f $ \j -> h $ j a ?
06:04:57 <mauke> ah, no. I don't have a monad constraint on m
06:05:26 <merijn> bennofs: That's not much of a minor hint and more of a spoiler, no?
06:05:28 <bennofs> First get the a out, then get the (a -> b) out, and apply it, and return that with h
06:05:30 <merijn> :p
06:05:51 <merijn> mauke: I'm not sure a monad constraint is needed on m
06:06:01 <mauke> it is if you want to do it wrong
06:07:36 <mauke> Codensity $ \k -> do { f' <- f return; x <- g return; k (f' x) }
06:07:39 <bennofs> merijn: Get the a out (g $ \a -> ....), and then in ..., get the (a->b) out and use h to return the value of applying (a->b) to your a.
06:08:23 <bennofs> :o. Codensity is just forall r. ContT r m a ?
06:08:31 <merijn> bennofs: Yeah, I forgot that I could just stuff my own lambdas in there
06:08:50 <merijn> bennofs: Maybe? I was saying I didn't understand ContT and shachaf told me to implement Codensity instead
06:09:08 <bennofs> ContT has the same type, except the forall iirc
06:10:51 <rasfar> zielwasserjunki: no prob, i thought it was a good question
06:11:48 <rasfar> used to use type synonyms a lot, but there was a period there when the compiler errors seemed too abstruse (sometimes a synonym would be printed, sometimes the translated type, sometimes both!)
06:11:55 <rasfar> things seem to be better now, and i'm using them again
06:24:45 <joejev> is it better to use an explicit recursive function over a list where I pattern match out a base case of [], or use foldr? I think this is a style thing because they both are functionally equivelent
06:25:26 <mm_freak> joejev: if you can express your traversal as a foldr, you should
06:25:40 <joejev> mm_freak: k
06:26:12 <mm_freak> better separation of concerns, better readability (you may have to get used to it)
06:26:25 <rasfar> maybe better fusion too
06:26:35 <joejev> what do you mean seperation of concerns?
06:26:36 <Taneb> Anyone know of a way to represent
06:26:41 <Taneb> ...
06:27:38 <Taneb> Anyone know of a way to represent sets of contiguous points on a grid such that two compare equal if one can be transformed to the other by rotation, translation, or reflection?
06:28:25 <rasfar> I think all points can be so transformed...
06:29:23 <rasfar> do you have additional constraints?
06:29:51 <Taneb> Sets of points, not the points themselves
06:30:04 <rasfar> ah of course, sorry
06:30:12 <joejev> is type checking faster than value checking, as in, if I had a data type like, A B C, and then f A = 1, f B = 2, F C = 3, would that be faster than say, g :: Int -> Int, g 1 = 1, g 2 = 2, g 3 = 3?
06:30:43 <joejev> data T = A | B | C that is
06:30:45 <FreeFull> That's pattern matching rather than type checking
06:31:04 <rasfar> joejev: if the types are newtype rather than data, it should be as fast, maybe faster
06:31:11 <FreeFull> I think you'd have to benchmark it to find  out
06:31:18 <rasfar> otherwise, you have to unbox
06:31:29 <rasfar> (or rather the runtime does)
06:31:47 <rasfar> or wait, that might be untrue
06:32:16 <joejev> yes, do guards compile to the same as a pattern match, like, is the g example above the same as g n | n == 1 = 1 | n == 2 = 2 ...
06:32:25 <FreeFull> I think constructors with no parameters will probably be optimised out and faster
06:32:36 <joejev> FreeFull: okay, that is what I assumed
06:33:43 <rasfar> Taneb: they have to have the same shape (up to at most 2^n orientations), that might help
06:33:45 <FreeFull> You could look at the compiled output
06:34:01 <rasfar> n = dimension of your grid
06:34:14 <merijn> joejev: No, because guards can run arbitrary functions, so obviously they are different from pattern matches
06:34:41 <merijn> joejev: Also, I find it highly unlikely that any of this will ever matter unless you have profiled and can prove differently
06:34:54 <rasfar> Taneb: are the contiguous sets box-shaped?
06:35:04 <quicksilver> well that guard might compile to the same as a pattern match, since the == will get inlined. I suspect it doesn't though.
06:35:13 <joejev> merijn: I was just wondering, I did not think it made a big impact
06:35:29 <merijn> Did I do the monad instance for codensity right? http://lpaste.net/97261
06:35:59 <Taneb> rasfar, no, they are made up of I think up to 8 touching rectangles
06:36:22 <Taneb> rasfar, don't worry too much about this
06:37:17 <rasfar> it's my sort of thing Taneb, actually, so I'm happy to discuss it more if you want
06:37:55 <rasfar> (but i should do some work too)
06:37:57 <Taneb> rasfar, oh, cool
06:38:07 <rasfar> oh, or... we can discuss more!
06:38:20 <rasfar> what's your application if I may ask?
06:39:13 <Taneb> I'm trying to compute regions formed by one or more touching shapes (from a fixed number of shapes) and also try and work out which shapes form which region
06:39:54 <Taneb> Does that make sense?
06:41:08 <rasfar> i've not looked at it to be honest, but I think byorgey has a package (boxes?) which could make the code really tidy
06:41:08 <Taneb> Oh, I'll give it a look!
06:41:08 <rasfar> if all your constituent shapes are boxy at least
06:41:38 <rasfar> it's not the "boxes" package ... I don't see it immediately in cabal list box
06:42:32 <Taneb> rasfar, one of http://hackage.haskell.org/user/BrentYorgey ?
06:44:16 <rasfar> that seems to be pretty-printing, strange, I thought it was more of a Boolean set thing
06:45:42 <rasfar> false lead i'd say, sorry about that
06:45:47 <fizbin> Quoting haskellwiki: "Monad transformers are like onions. At first, they make you cry but then you learn to appreciate them."
06:46:00 <Taneb> I think I could almost use a set of vectors
06:46:11 <fizbin> I'll just have to take their word on that second part for now.
06:46:36 <fizbin> Every one of my forays into mtl has left me frustrated and disappointed.
06:47:43 <FreeFull> I still have managed not to use monad transformers
06:48:45 <rasfar> for each rectangle, a vector for the displacement, and one to describe the shape / or just one 4-component vector
06:49:12 <Taneb> rasfar, I was thinking a vector for each point. I'm working in a discrete space (if that's the right term)
06:49:50 <rasfar> so your points are (Int,Int) or so?
06:49:56 <Taneb> Yeah
06:50:15 <rasfar> i've lost sight of the original question, hold on...
06:50:48 <joejev> merijn: well, I ran that test and it looks like the functions are the same if you use guards to check equality only or you pattern match the litteral constants
06:51:12 <rasfar> you can use a vector to represent the boundary of the union...
06:51:56 <Taneb> How so?
06:52:13 <rasfar> you can also eliminate a lot of cases by comparing the areas, if they areas are not equal you know they can't be matched up
06:52:33 <Taneb> Yeah
06:52:34 <rasfar> well, the boundary is a sufficient shape descriptor
06:53:04 <rasfar> not necessarily the most succinct but it might be...
06:53:07 <Taneb> rasfar, shapes could have holes in them, I think
06:53:11 <Taneb> Yeah
06:53:19 <Taneb> But does that make a difference? No it doesn't
06:54:12 <rasfar> it does complicate things -- to define a canonical ordering of the boundary segments
06:54:52 <`Jake`> Does the current ghc version support holes yet?
06:55:02 <rasfar> can can also translate all shapes to sit snug in the first quadrant, canonical position, so you factor out translations
06:55:41 <rasfar> but since you need to test for equivalence under rotation as well...
06:57:13 <rasfar> i feel like there's an elegant solution, but as an interim thing I think you can get a really efficient solution in 2-D in the average case, unless for some reason you expect composite shapes to often have the same area
06:57:43 <Taneb> rasfar, there's only five base shapes which I am putting together
06:57:51 <Taneb> So, a lot of them will have the same area
06:57:53 <rasfar> enough for one hole then!
06:58:04 <Taneb> And two of them aren't rectangles
06:58:13 <rasfar> oh! haha
06:58:24 <Taneb> (one's a t-shape, the other's a sort of chevron, I guess)
06:59:02 <rasfar> maybe two or three holes tops?....
07:00:04 <rasfar> i was thinking that, since overlaps are only counted once, your composite shapes will still usually have different areas
07:00:22 <Taneb> Overlaps aren't allowed
07:00:43 <rasfar> whew! lol
07:01:24 <rasfar> do the base shapes vary in size, or are there "really just 5"?
07:01:38 <Taneb> Really just 5
07:02:35 <rasfar> but the composite can contain any number (including 0) of any of the base shapes (at size, but rotated/reflected/translated)?
07:03:19 <rasfar> also, does the composite have to be a connected set?
07:03:31 <Taneb> If that means what I think it means, yes
07:04:05 <rasfar> the former question asks if you have to use all the shapes? and if you can use some of them more than once?
07:04:19 <Taneb> You can only use each zero or one times
07:04:47 <rasfar> this is why i love applications
07:05:11 <rasfar> it is a strict set union right?
07:05:17 <rasfar> (strict in lay sense)
07:05:49 <Taneb> I am not sure what that means
07:06:24 <rasfar> if there is no connectivity constraint on the union, then the minimum bounding box could be useful in the way I was hoping area would be useful)
07:06:35 <Taneb> There is a connectivity constraint
07:06:37 <rasfar> sorry you said no intersections
07:07:01 <Taneb> No intersections, but definitely adjacents
07:07:14 <Taneb> You have to be able to flood-fill it
07:07:14 <rasfar> ah! so no intersection, but base shapes must be adjacent / right
07:07:58 <rasfar> i think, as you have a chevron, maybe an ad hoc approach is best
07:08:31 <rasfar> test if bounding boxes are the same (two rotamers to check)
07:08:55 <Taneb> The two nasty shapes are: {
07:09:03 <Taneb>  #   #
07:09:06 <Taneb> ###  #
07:09:10 <Taneb> # #  #
07:09:13 <Taneb>     ###
07:09:14 <Taneb> }
07:09:26 <rasfar> if yes, compute centroids, place on origin, and see if the composite shapes overlap perfectly (8 symmetry transforms to check)
07:09:52 <Taneb> That's a good idea, thank you
07:09:54 <rasfar> are they so small? that's good
07:10:06 <Taneb> The other three shapes are 1x2, 1x3, and 1x4
07:10:15 <Taneb> It's just too large to do this by hand
07:10:17 <rasfar> yw, this stuff fires me right up! better than my coffee at the moment
07:10:25 <Taneb> :D
07:19:43 <boom583> Here, http://learnyouahaskell.com/introduction#so-whats-haskell
07:19:43 <boom583> In the second paragraph, I don't get what he says after "But once you"
07:20:01 <boom583> He gives the impression that doubleMe acts on a single element, not the whole list
07:20:05 <boom583> Please elaborate.
07:21:29 <frerich> boom583: doubleMe takes a single *argument* (a list), not a single element of a list, maybe that's what confuses you?
07:22:32 <boom583> frerich: yes, i got that doubleMe takes in a single list
07:22:44 <boom583> But when he talks about how they execute
07:22:49 <boom583> he talks about only a single number 1
07:22:51 <boom583> turning into 2
07:22:53 <boom583> turning into 4
07:22:55 <boom583> and finally turning into 8
07:23:03 <boom583> he stops refering to lists
07:23:31 <kayloos> boom583: You're right, but the point of the explanation should be clear, no?
07:24:31 <kayloos> he is basically just explaining what laziness is
07:25:06 <boom583> ok, so in reality it is indeed as expected? namely, the first function returns a whole list. the second function returns another whole list. and the third too
07:25:17 <boom583> each function call acts on the whole list
07:25:22 <boom583> and returns a whole list
07:26:22 <kayloos> true, but that could also be true for a non-lazy language. His point is that the calculations are only performed when requested. He is explaining the way haskell lazily executes the code
07:33:14 <boom583> ok
07:45:49 <boom583> kayloos: He says "the doubleMe calls pass through the list only once"
07:45:56 <boom583> Is that part any different from imperative?
07:46:56 <boom583> It's the "and only when you really need that to happen" that seems the crucial thing here
07:50:53 <quicksilver> boom583: in an imperative language, each call would go through the list once - so three traversals in total.
07:51:33 <quicksilver> boom583: in a lazy language it's going through the list only once - doing three doubles at each point.
07:51:54 <quicksilver> the difference between these two approaches is a significant improvement is cache coherency even without clever optimisation tricks
07:52:05 <boom583> quicksilver: oh really?! so it's not returning a list, then returning a list, and then returning a list?
07:52:08 <quicksilver> with clever optimisation haskell can actually save the memory entirely and never construct the intermediate lists
07:52:22 <quicksilver> boom583: no, it's building three lists at once (from one original list)
07:52:29 <boom583> hmm
07:52:32 <quicksilver> and the throwing them away (to the extent they're not used)
07:52:50 <quicksilver> some optimisations will mean the "middle two" lists never get built at all.
07:52:52 <merijn> boom583: Compare this python version: http://lpaste.net/97267
07:53:03 <merijn> boom583: Every call to doubleMe has to go over the entire list
07:55:06 <boom583> quicksilver: i still don't get it. doubleMe is a function that takes a list and returns a list.
07:55:12 <boom583> you're just describing potential optimizations no?
07:56:20 <merijn> boom583: Haskell evaluation happens more like this: http://lpaste.net/97267
07:56:58 <quicksilver> boom583: no, I described two different things.
07:57:10 <merijn> boom583: It just evaluates the "start" of the list and the tail becomes a "thunk" (a thunk is a computation that hasn't happened yet)
07:57:28 <quicksilver> boom583: firstly - and this is not an optimisation, this is just normal order evaluation - the three nested calls to doubleMe will execute "in step"
07:57:40 <quicksilver> that means only one traversal and better cache coherency.
07:57:55 <merijn> boom583: As you can see, it's possible to evaluate the first value of the list, without traversing the entire list or even finishing the "doubleMe" computation at all
07:58:06 <merijn> quicksilver: I think you mean cache locality
07:58:15 <merijn> quicksilver: Coherency is completely unrelated here
07:58:15 <quicksilver> the optimisation - which GHC gets right sometimes but not every time - manages to get rid of some unnecessary allocation.
07:58:18 <quicksilver> merijn: yes, yes I do.
07:58:45 <quicksilver> I don't really speak english, I'm just a markov chain. Occasionally I get misdirected when one word comes very commonly after another.
07:59:20 <augur_> merijn: if we're being precise
07:59:26 <boom583> this is real messed up to grasp
07:59:30 <augur_> haskell probably does fusion on that
07:59:50 <frerich> boom583: Do you know Python's "generator" expressions by any chance?
07:59:53 <merijn> boom583: It would continue like this: http://lpaste.net/97267
07:59:54 <quicksilver> augur_: we already mentioned that.
08:00:03 <augur_> oh, i wasnt paying too much attention. :)
08:00:07 <augur_> i just saw a link
08:00:09 <quicksilver> augur_: that's not part of haskell and we are deliberately concentratin on just evaluation order for now.
08:00:21 <augur_> true
08:00:28 <merijn> augur_: Sure, but even without fusion and optimisation it only traverses once
08:00:50 <augur_> for some definition of once :)
08:01:11 <merijn> only *up to* once, then
08:01:12 <augur_> really the beauty of haskell there is that laziness gives you pipelined traversals
08:02:23 <augur_> as soon as one doubleMe produces some amount of output, the next doubleMe can begin working, rather than having to wait for the whole input to be consumed by the first doubleMe. you get delays proportional to the number of functions you're stacking
08:02:47 <merijn> Maybe this post is useful? http://www.vex.net/~trebla/haskell/lazy.xhtml
08:02:49 <augur_> so that if you have 10 doubleMe's or 100, 1000, it takes longer, even if they dont actually take longer to do the math
08:03:17 <augur_> (like, if you just used const () instead of doubleMe, it would till take longer if you had 100 doubleMe's than if you had 2
08:04:05 <augur_> or 20 map id's
08:04:13 <augur_> or 200 map id's
08:04:26 <augur_> so it's not quite the same as a single traversal
08:04:35 <augur_> it's pipelined traversal
08:04:44 <boom583> merijn: http://lpaste.net/97267
08:05:10 <boom583> merijn: how do you know that it goes first "down" the function calls before going "up the list"?
08:05:57 <merijn> boom583: Because that's how lazy evaluation is defined. Haskell has "thunks" (uncompleted computations) and thunks are only "forced" (run/computed) once their result is needed
08:06:11 <augur_> boom583: to really understand how thats working, you have to actually add some more stuff to that
08:06:36 <merijn> boom583: So let's say we just use one doubleMe, we have "doubleMe [1..10]"
08:06:43 <augur_> boom583: it all comes down to _actually_ needing a value
08:06:53 <augur_> when you print to the screen, you _actually_ need a value
08:06:58 <merijn> boom583: Which just gets turned into <thunk of "doubleMe [1..10]">
08:07:08 <augur_> so you have to compute that value, and everything else needed to get to it
08:07:08 <merijn> boom583: At which point haskell goes, "ok, done!"
08:07:28 <augur_> but if you don't, say, print to the screen, but instead you just ignore the value, you dont need to do anything to it
08:07:46 <merijn> boom583: Now if I write "doubleMe [1..10] !! 0" (x !! i returns the i-th argument of the list x), then the following happens
08:08:03 <Fuuzetsu> How does one use the cabal repl with haskell-mode?
08:08:26 <merijn> boom583: "!!" sees it's trying to pattern match on a list, but I only have a thunk, so haskell starts computing the thunk until it matches
08:08:32 <augur_> boom583: this is what merijn is hinting out by placing these expressions on their own lines
08:08:47 <augur_> merijn: i think maybe talking about thinks is unnecessary and confusing
08:09:03 <boom583> i guess the rest of the lyah will explain this
08:09:05 <boom583> later on
08:09:13 <merijn> boom583: First step is "doubleMe (1:rest) = <thunk of 2*1> : <thunk of doubleMe rest>"
08:09:34 <merijn> boom583: "!! 0" sees, ok, that's all I needed an returns "<thunk of 2*1>"
08:09:34 <augur_> merijn: really, ignore thunks
08:10:00 <augur_> thunks are an implementation issue that isnt really relevant to understanding the laziness
08:10:14 <merijn> augur_: I disagree that they are unnecessary and confusing, personally I didn't get laziness until I got an operational intuition for them
08:12:11 <augur_> boom583: you can think of haskell as working like this:   to evaluate an expression `e`, it looks at the form of the expression. if it's a function application that it knows how to compute with (like say, a lambda expression for the function, or if you want to think of it like this, a function name for the function) then it evaluates one step by replacing the whole thing by the body, with variables set a
08:12:11 <augur_> ppropriately
08:12:40 <augur_> boom583: for instance, if the evaluator sees   fac (1+2+3+4)   and it knows fac n = n * (fac (n - 1))
08:13:01 <augur_> it turns this into   (1+2+3+4) * fac ((1+2+3+4) - 1)
08:13:43 <augur_> the argument can be computed down to 10, of course, but we dont need to do that yet. in fact, we may never need to do that.
08:14:33 <augur_> now the evaluator sees that the function is *, and it says, i dont have a definition for that, since it's primitive. i just have to actually compute
08:14:55 <augur_> so it computes the left arg to 10, and it computes the right arg using this same method.
08:15:22 <augur_> boom583: does that make sense?
08:15:33 <boom583> not totally
08:15:36 <boom583> i'll just read the book :S
08:15:38 <augur_> thats the basic intuition you should have for normal order evaluations
08:15:48 <augur_> boom583: no the book isnt going to explain this probably. i mean it might, but
08:15:57 <augur_> what aspect of it doesnt make sense?
08:16:14 <boom583> essentially, to really understand paragraph 2 here http://learnyouahaskell.com/introduction#so-whats-haskell i need more info
08:16:27 <boom583> and i hope lyah gives that info later on
08:16:46 <augur_> boom583: no you dont really need more information
08:16:59 <FreeFull> augur_: You do have to take sharing into account too
08:17:05 <augur_> you just need to practice with the core notion of laziness and evaluation order
08:17:09 <augur_> FreeFull: yes yes, we'll get to that
08:17:10 <augur_> babysteps
08:17:37 <augur_> boom583: does the factorial example i gave make sense tho?
08:17:54 <boom583> augur_: sure
08:17:56 <boom583> recursion
08:18:04 <augur_> boom583: yes, but dont worry so much about that part
08:18:15 <augur_> the important part is that (1+2+3+4) ___doesnt get evaluated to 10___
08:18:45 <augur_> the "rewrite", or the "expansion", of   fac (1+2+3+4)   into   (1+2+3+4) * fac ((1+2+3+4) - 1)
08:18:45 <exicer> What function does something like [IO ()] -> IO ()
08:18:57 <augur_> does NOT do anything to this big sum of numbers, boom583
08:18:58 <augur_> yeah?
08:19:01 <quicksilver> exicer: sequence_
08:19:02 <boom583> agreed
08:19:05 <exicer> quicksilver: Thanks
08:19:05 <augur_> it just leaves it alone.
08:19:30 <augur_> boom583: itll only do something with (1+2+3+4) when it _must_
08:19:35 <boom583> yes
08:19:39 <augur_> after all, why should it do work that i might not need to do in the end?
08:19:40 <augur_> for instance
08:19:42 <augur_> const x y = x
08:19:46 <augur_> so what if i do this:
08:20:00 <augur_> const 0 (1+2+3+4+5+6+7+8+.............onto 1000000000000)
08:20:09 <augur_> should it compute that big sum of numbers?
08:20:15 <augur_> boom583: it would be stupid to do that, right?
08:20:19 <boom583> yeah
08:20:19 <augur_> i mean, im just going to ignore it!
08:20:37 <augur_> const 0 (1+2+3+4+.............)    immediately reduces to 0, it ignores that big sum
08:20:40 <augur_> so why compute the sum?
08:21:02 <augur_> boom583: that makes sense right?
08:21:04 <boom583> yes
08:21:21 <augur_> ok, now lets imagine you have some function ob :: Int -> Int
08:21:25 <augur_> ob is obnoxious
08:21:30 <augur_> it takes forever
08:22:07 <augur_> so now suppose we have something like this:   xs = [ ob x | x <- [1..1000000] ]
08:22:21 <augur_> which is like [ ob(x) for x in ... ]
08:22:28 <augur_> i dont know python well enough to do the range :p
08:22:42 <boom583> i don't know any python either
08:22:46 <boom583> but ok
08:22:55 <sbditto85> [ ob(x) for x in range(1000001) ]
08:22:58 <sbditto85> :)
08:23:05 <augur_> oh, well there was python in the paste, i tought it was your reference language
08:23:06 <augur_> anyway
08:23:15 <augur_> boom583: in a strict language, you would just compute the whole list
08:23:25 <augur_> a million numbers, ob applied to every one of them
08:23:33 <augur_> horrible!
08:23:42 <augur_> what if we only actually use ONE number in the list?
08:23:48 <augur_> xs !! 5000
08:24:09 <augur_> we only need that one solitary number, and yet, in a strict laguage, we still compute all of them
08:24:14 <augur_> this is not good, if ob is obnoxious
08:24:26 <augur_> but in a lazy language like haskell, we only compute the things we need to compute
08:24:42 <augur_> so when we go walking down the list, we see a bunch of things that say
08:24:48 <augur_> ob 1, ob 2, ob 3, ...
08:24:53 <boom583> agreed. are you building this up slowly towards that doubleMe thing?
08:24:58 <augur_> but they havent been computed yet
08:25:15 <augur_> when we get to the 5000th element, we say, thats the one i want, give me it. compute that
08:25:23 <augur_> boom583: yep, we're sort of working there
08:25:29 <boom583> ok cool
08:25:40 <augur_> so how could we apply ob to everything in the list?
08:25:47 <augur_> well one way is like the doubleMe example
08:26:02 <augur_> obEvery [] = []   ;   obEvery (x : xs) = ob x : obEvery xs
08:26:26 <augur_> make sense?
08:26:28 <boom583> yes
08:26:39 <augur_> and how can we walk down a list? (!!) is defined as
08:26:56 <augur_> (x : xs) !! 0 = x   ;   (x : xs) !! n = xs !! (n - 1)
08:27:28 <augur_> so watch what happens if we do    obEvery [0,1,2] !! 1
08:27:29 <eyebloom> What does "NB:" mean as a common prefix for a comment similar to TODO:
08:27:32 <augur_> we ought to get ob 1, right?
08:27:35 <augur_> eyebloom: notabene
08:27:42 <augur_> i think
08:27:45 <boom583> yes
08:27:55 <augur_> boom583: so lets do this:
08:28:15 <avaritia> hey anyone knows an interesting haskell programming problem set?
08:28:20 <Sculptor> `hi!
08:28:46 <augur_> obEvery [0,1,2] !! 1   =>   (ob 0 : obEvery [1,2]) !! 1   =>   obEvery [1,2] !! 0   =>   (ob 1 : obEvery [2]) !! 0   =>   ob 1
08:28:50 <augur_> boom583: yeah?
08:28:57 <trolling> avaritia: yeah
08:29:15 <avaritia> trolling, would you mind sharing it?
08:29:23 <merijn> @where exercises
08:29:23 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
08:29:37 <merijn> avaritia: Not really haskell specific (other than the first link), but still
08:29:40 <trolling> ^ the last two of those were what I had in mind
08:29:51 <avaritia> ok thank you
08:30:00 <boom583> augur_: yes.
08:30:03 <trolling> also RWH has some exercises I think
08:30:15 <augur_> boom583: and we didn't compute ob 0, nor did we compute obEvery [2]
08:30:17 <eyebloom> Nota bene.
08:30:18 <augur_> boom583: we just left them alone, right?
08:30:21 <boom583> yes
08:30:26 <augur_> eyebloom: si, nota bene :)
08:30:50 <augur_> boom583: now that we've pulled out ob 1, we can compute that:   ...  =>  ob 1  =>  whatever it equals
08:31:38 <augur_> boom583: ok, how what happens if we do   obEvery (obEvery [0,1,2]) !! 1   ?
08:31:41 <augur_> something similar
08:32:38 <augur_> obEvery (obEvery [0,1,2]) !! 1   =>   obEvery (ob 0 : obEvery [1,2]) !! 1   =>   (ob (ob 0) : obEvery (obEvery [1,2])) !! 1   =>   obEvery (obEvery [1,2]) !! 0
08:33:13 <merijn> ugh, why is "forkIO :: IO () -> IO ThreadId" instead of "forkIO :: IO a -> IO ThreadId"?
08:33:21 <augur_> ...   =>   (ob (ob 1) : obEvery (obEvery [2])) !! 0   =>   ob (ob 1)   =>   some junk that it equals
08:33:26 <augur_> boom583: yeah?
08:33:56 <augur_> merijn: it's not too hard to turn your IO a into an IO ()...
08:34:15 <merijn> augur_: I know, but I'm annoyed every time I forget to change it >.>
08:34:21 <augur_> merijn: :P
08:34:27 <merijn> augur_: And there doesn't seem to be a real reason to require ()
08:34:48 <augur_> boom583: does that still make sense?
08:35:05 <boom583> augur_: thinking
08:35:21 <augur_> boom583: i left out some stuff because it wouldnt looked very repetitive
08:36:40 <m1dnight> http://lpaste.net/97270 # could anyone help me with the question about how come a is the 'a' value from (a,s), which pop returns?
08:36:56 <m1dnight> shouldnt '<-' "get the value out of the context"?
08:37:00 <m1dnight> ie: return a function?
08:37:23 <augur_> m1dnight: depends on what pop is!
08:37:32 <boom583> augur_: Ok so we first got obEvery(ob 0 : obEvery[1,2]) !! 1
08:37:32 <boom583> And you told me that it becomes: (ob (ob 0) : obEvery (obEvery [1,2])) !! 1
08:37:33 <boom583> My question is, why didn't it become this?: obEvery(ob 0 : (ob 1 : obEvery[2])) !! 1
08:37:40 <merijn> m1dnight: You didn't include a definition of Stack, pop or push
08:37:46 <m1dnight> oh yeah sorry my bad
08:37:48 <m1dnight> just a second!!
08:37:56 <augur_> boom583: good question
08:38:14 <merijn> boom583: The 'why' is mostly "because the standard defines that it shouldn't do that"
08:38:19 <augur_> boom583: in part, it's due to what obEvery is like
08:38:42 <augur_> boom583: if you look at the definition of obEvery, it only needs to see the highest (:) of its argument, right?
08:38:52 <augur_> boom583: obEvery (x : xs) = ...
08:39:02 <augur_> boom583: it doesnt care what xs looks like
08:39:03 <m1dnight> http://lpaste.net/97271 # here it is. So basicly it returns a State
08:39:20 <boom583> Is this due to some precedence rules?
08:39:40 <m1dnight> I figured '<-' would thus do the same thing as runState
08:39:42 <augur_> boom583: so obEvery is basically saying "to use me, evaluate my function ONLY until i can see the topmost (:), then stop, because thats all the work you need to do"
08:39:58 <augur_> boom583: er sorry,   "... evaluate my argument ..."
08:40:09 <boom583> augur_: yes, but there are two obEvery there. So why does it use the outer one first?
08:40:13 <merijn> m1dnight: Have you tried expanding the code on paper?
08:40:18 <augur_> boom583: ahh well, it does!
08:40:20 <augur_> boom583: but see
08:40:26 <augur_> the out one ALSO needs to see an (:) right?
08:40:28 <m1dnight> well I'm stuck on how to expand '<-'
08:40:30 <m1dnight> that's why Im here
08:40:32 <merijn> m1dnight: "a <- pop; foo a" becomes "pop >>= foo"
08:41:05 <augur_> boom583: so in order for the outer one to see (:) in its argument, its argument --- which is   obEvery [0,1,2]   --- has to be evaluated a little bit too!
08:41:07 <merijn> m1dnight: Specifically, "a <- foo; bar a" is translated to "foo >>= \a -> bar a"
08:41:26 <boom583> augur_: yes, that's why we got obEvery(ob 0 : obEvery[1,2]) !! 1
08:41:33 <augur_> boom583: right!
08:41:34 <boom583> so what next?
08:41:35 <merijn> m1dnight: See: https://en.wikibooks.org/wiki/Haskell/do_Notation
08:41:55 <augur_> boom583: so what's next is, now that the outer obEvery can see a (:), the inner obEvery doesn't need to be looked at (yet)
08:42:16 <augur_> boom583: because why should it? to use obEvery, we ONLY need to see that (:), so why do more work?
08:42:37 <m1dnight> oh right, so it's the same as with the reader monad? ("the a in 'a <- m a' is the parameter that gets fed to the function f in g >>= f")
08:42:59 <augur_> boom583: so now the outer obEvery can see (:), so you can use it:   obEvery (ob 0 : obEvery [1,2])   can become   ob (ob 0) : obEvery (obEvery [1,2])
08:43:00 <m1dnight> right!
08:43:05 <augur_> boom583: yeah?
08:43:11 <m1dnight> it was a bit confusing with the "non-monadic" code in the do
08:43:36 <boom583> augur_: it does this to get more results more quickly?
08:43:39 <boom583> final results
08:43:50 <augur_> boom583: it does this to avoid doing computations it might not need to do
08:43:53 <boom583> but it still makes no sense, unless it somehow also knows about the !!1
08:44:05 <augur_> boom583: ahh but it does know about the !! !
08:44:18 <augur_> because the WHOLE expression is   obEvery (obEvery [0,1,2]) !! 1
08:44:31 <augur_> so the reason we're evaluating   obEvery (obEvery [0,1,2])   AT ALL
08:44:42 <augur_> is because the (!!) needs to see a (:) in its first argument!
08:44:52 <boom583> ok, so the precedence of those two obEvery is defined by the !! operator?
08:44:59 <augur_> boom583: i dont want to say precedence
08:45:01 <augur_> i would just say
08:45:12 <augur_> (!!) needs to see a (:) in its first arg
08:45:20 <augur_> so its first arg has to be evaluated until it exposes a (:)
08:45:38 <boom583> ok
08:45:39 <augur_> to evaluate the first arg, namely, to evaluate   obEvery (obEvery [0,1,2])
08:45:46 <augur_> you need to apply obEvery
08:45:58 <augur_> but obEvery needs to see a (:)   (or a [])   in its argument
08:46:08 <augur_> so you evaluate the argument until you can see that
08:46:20 <augur_> and so on, until everything that you need to see is seen
08:46:44 <augur_> then you can do a reduction using these equations like   obEvery (x : xs) = ob x : obEvery xs
08:47:44 <augur_> boom583: this happens only because these functions are asking to look at the form of their arguments
08:48:27 <augur_> boom583: they're defined by pattern matching on constructors, so we keep pushing the evaluation along until we expose a constructor
08:48:39 <augur_> and sometimes, to do that, we have to evaluate some other things
08:49:36 <augur_> boom583: does that make sense?
08:49:50 <boom583> somewhat
08:49:56 <augur_> boom583: lets simplify that a bit
08:49:58 <boom583> but still, why would !!1 make it evaluate?
08:50:02 <augur_> boom583: oh
08:50:09 <boom583> we need !!1 *and* request it to be printed
08:50:10 <boom583> or something
08:50:15 <boom583> not just !!1
08:50:17 <augur_> exactly, yes
08:50:21 <boom583> ok
08:50:35 <augur_> just having   obEvery (obEvery [0,1,2]) !! 1   by itself doesnt mean you'll do all of this
08:50:40 <augur_> after all, maybe you'll ignore that!
08:50:43 <boom583> :)
08:50:54 <augur_> const 0 (obEvery (obEvery [0,1,2]) !! 1)   =   0
08:51:08 <augur_> so this is a joke that simon peyton jones makes every once in a while
08:51:19 <augur_> without IO, lazy computation is simple: dont do anything ever!
08:51:25 <boom583> lol
08:51:25 <boom583> yeah
08:51:27 <augur_> its super efficient!
08:51:29 <boom583> haskell is a useless language!
08:51:39 <trolling> look at my bow tie!
08:51:51 <augur_> the only time you ACTUALLY need to compute is when you force it by using IO
08:51:59 <augur_> boom583: thats why programs in haskell are of IO types
08:52:08 <merijn> Fun fact, haskell once dominated one of the online benchmarks because their script didn't require the output to be printed so the haskell code didn't do anything :)
08:52:16 <augur_> merijn: :)
08:52:18 <boom583> LOL
08:52:32 <sbditto85> merijn: seriously! haha
08:52:44 <trolling> O(1) sorting is the best sorting
08:52:46 <augur_> boom583: actually, SPJ's original joke is, all that happens with IO is your computer gets warm, and even that is a kind of IO
08:53:06 <augur_> boom583: you can think of laziness as the principle of the procrastinator
08:53:25 <augur_> boom583: why do work if noone's asking me for the result of it? ill get around to it when i _really_ need to
08:53:37 <boom583> but the above must be determined by a higher precedence of !! over a function call?
08:53:48 <augur_> boom583: oh, yes, but thats at the level of parsing, right
08:53:53 <boom583> ok, cool
08:54:03 <merijn> *lower* precedence of !!
08:54:08 <augur_> haskell function application binds tighter than infixs, etc etc
08:54:18 <boom583> huh? then why did it worry about !! first?
08:54:26 <augur_> boom583: because thats the main function!
08:54:32 <augur_> boom583: so lets be precise here
08:54:36 <augur_> precedence is about parsing
08:54:41 <augur_> its about when you can avoid writing parens
08:54:51 <boom583> Ok, so we had this.
08:54:52 <boom583> obEvery(ob 0 : obEvery[1,2]) !! 1
08:54:54 <augur_> so   obEvery (obEvery [0,1,2]) !! 1
08:54:57 <augur_> this means the same thing as
08:55:06 <augur_> (obEvery (obEvery [0,1,2])) !! 1
08:55:08 <augur_> right?
08:55:20 <boom583> yes
08:55:23 <boom583> what next?
08:55:24 <augur_> we're allowed to drop that set of parens around the first arg of !! because of _precedence_
08:55:33 <augur_> HOWEVER
08:55:54 <augur_> that means that (!!) is the "outermost" function there
08:55:58 <augur_> right?
08:56:20 <boom583> but merijn said that !! has lower precedence
08:56:24 <boom583> so how can we drop the para
08:56:29 <augur_> boom583: yes, thats parsing
08:56:36 <augur_> so precedence works like this:
08:57:00 <augur_> if you have some bit of code that has three parts part1 part2 part3
08:57:19 <augur_> and you could plausibly put parens around either two of them
08:57:20 <augur_> so either
08:57:24 <augur_> (part1 part2) part3
08:57:30 <augur_> or   part1 (part2 part3)
08:57:43 <augur_> because your parser has some rules that allow either
08:57:59 <augur_> then the rule with the _higher_ precedence is the chosen one. higher as in "higher priority"
08:58:24 <augur_> the typical example is + vs *
08:58:29 <eyebloom> Is there a good guide to understanding the ppr output of a CoreExpr?
08:58:32 <augur_> take the expression   1 + 2 * 3
08:58:44 <augur_> boom583: we could parens this as   (1 + 2) * 3   or   1 + (2 * 3)
08:58:53 <merijn> sbditto85: If you enjoyed that fact, rejoice in the knowledge of the following fun fact: GHC once had a bug where it would delete source files if they didn't typecheck :)
08:58:56 <augur_> boom583: assuming we had rules for each, right
08:59:07 <gsnedders> merijn: Only on Windows!
08:59:21 <merijn> gsnedders: Really? SPJ lied to me :(
08:59:48 <gsnedders> merijn: What sof said, when it came up on work IRC channel, was that it was him who had introduced it and that it was Windows only.
09:00:09 <boom583> augur_: what rules?
09:00:30 <gsnedders> merijn: (Joking about on work IRC channel. Turns out the guy who introduced it was there, in the channel of a dozen people. XD)
09:00:41 <augur_> boom583: oh who knows. that depends on your grammar. just pretend there are some rules, somehow, that make it the case that both of those parenses are valid
09:00:52 <boom583> ok
09:00:59 <augur_> boom583: but lets say the * rule had a higher precedence
09:01:03 <augur_> so we chose ITS parenses
09:01:06 <augur_> namely, 1 + (2 * 3)
09:01:08 <augur_> yeah?
09:01:14 <boom583> ok
09:01:23 <boom583> yes
09:01:30 <allsystemsarego> > over (upon fst) (+1) (5,3)
09:01:31 <augur_> in haskell, the function application rule is like *: its parenses get chosen over !!'s parens
09:01:33 <lambdabot>  (6,3)
09:01:39 <augur_> boom583: indeed, over any infix's parens
09:02:04 <augur_> boom583: so if i write   foo x !! 3   that means   (foo x) !! 3
09:02:09 <boom583> ok i see
09:02:17 <augur_> boom583: but that means the "outer" function is !!
09:02:24 <augur_> right?
09:02:33 <sbditto85> merijn: what?! sounds like a unfun game of lose/lose http://www.gamepolitics.com/2009/09/24/loselose-offers-invasive-interactivity#.UrR19mRDtco
09:02:49 <boom583> Agreed. So   (obEvery (obEvery [0,1,2])) !! 1      becomes       obEvery (obEvery [0,1,2]) !! 1
09:03:09 <augur_> boom583: right, we can drop those parens because the parsing tells us where they should be
09:03:29 <augur_> boom583: but now, since !! is the outer function, that means _it_ is what we can see when we're evaluating that expression
09:03:39 <augur_> so we see   obEvery (obEvery [0,1,2]) !! 1
09:03:46 <boom583> ah
09:03:47 <boom583> i see
09:03:48 <augur_> and we see the !! before we see everything else
09:03:53 <augur_> so we have to do what !! is asking us to do
09:04:02 <boom583> i didn't think of it as an OUTER FUNCTION
09:04:03 <boom583> which it is
09:04:04 <augur_> namely: look at my first argument
09:04:04 <boom583> cool
09:05:16 <augur_> boom583: does it now make sense why   obEvery (obEvery [0,1,2]) !! 1   evals to   (ob (ob 0) : obEvery (obEvery [1,2])) !! 1
09:05:16 <augur_> ?
09:06:28 <boom583> sort of yes
09:06:42 <augur_> ok, why just sort of? :)
09:07:43 <boom583> hm, no, actually, it totally makes sense because of THE DEFINITION OF !!
09:07:52 <augur_> :D
09:07:53 <augur_> yep
09:07:54 <augur_> exactly
09:07:57 <boom583> cool
09:08:07 <augur_> (!!) says "i need to see (:) in my first argument"
09:08:14 <augur_> so haskell does everything necessary to expose that (:)
09:08:35 <sbditto85> augur_: thank you for that explanation ... I learned a lot
09:08:41 <augur_> sbditto85: :)
09:08:50 <augur_> boom583: so now that this makes sense, lets look at doubleMe
09:08:58 <augur_> doubleMe is like obEvery
09:09:15 <augur_> except instead of applying op to every element, it applies (2*)
09:09:32 <augur_> doubleMe [] = []   ;   doubleMe (x : xs) = 2*x : doubleMe xs
09:10:24 <nisstyre> Is there any way to make this a method of Foldable? https://gist.github.com/nisstyre56/8057885#file-scan-hs-L47
09:10:32 <augur_> boom583: in fact, when i said before ob was a crazy function, i might have lied! maybe ob = (2*) and obEvery was doubleMe all along!
09:10:35 <augur_> boom583: who knows!
09:10:40 <boom583> yeah
09:10:51 <boom583>  (ob (ob 0) : obEvery (obEvery [1,2])) !! 1    becomes    obEvery (obEvery [1,2]) !! 0
09:10:54 <boom583> i guess
09:10:57 <augur_> right
09:10:59 <boom583> nice nice
09:11:00 <augur_> because of the definition of !1
09:11:01 <augur_> it says
09:11:04 <boom583> yeah
09:11:08 <augur_> (x : xs) !! n = xs ! (n - 1)
09:11:13 <boom583> yep
09:11:16 <kuznero> Hi All!
09:11:41 <boom583> augur_: so it depends on what we're doing really. it could be something other than !!
09:11:58 <augur_> boom583: right
09:12:27 <boom583> thanks, makes sense now
09:12:30 <augur_> boom583: :)
09:12:32 <boom583> good stuff
09:12:34 <kuznero> Can somebody help with gitlib package?
09:12:50 <augur_> boom583: but notice that this isn't going over the list three times, when you do   doubleMe (doubleMe (doubleMe xs))
09:12:51 <augur_> boom583:
09:13:05 <augur_> its sort of working along the list bit by bit
09:13:14 <augur_> doing the three doubleMe's one little chunk at a time
09:13:31 <boom583> augur_: but it depends on how the the outermost print function is implemented right?
09:13:40 <boom583> maybe it goes in reverse direction. or random direction?!
09:13:42 <boom583> hmmmm
09:13:52 <augur_> boom583: right, ofcourse. whenever we talk about these things, we pretend like we're evaluating in the "obvious" way
09:13:56 <boom583> ok
09:13:57 <boom583> cool
09:13:58 <boom583> makes sense
09:14:08 <augur_> so we dont worry about printing and IO and shit
09:14:14 <boom583> :)
09:14:24 <augur_> we just say, _I_ the programmer am hand simulating this, i really do want to evaluate this
09:14:33 <augur_> where "this" means "this expression"
09:15:06 <boom583> yea
09:15:07 <boom583> h
09:15:21 <augur_> boom583: if you're familiar with an imperative language, it might be good to try to implement an evaluator for this
09:15:31 <augur_> boom583: just to get your hands on this stuff
09:15:41 <boom583> ok
09:15:50 <augur_> just a simple one that does, say, lists and doubleMe
09:16:18 <augur_> so like, it has list values, number values, !!, and doubleMe
09:16:19 <augur_> lets say
09:16:41 <boom583> meh
09:16:56 <augur_> and keep in mind that evaluation is "done" when the evaluator is looking at something with a "constructor"
09:16:57 <boom583> i'll just learn haskell lol
09:17:00 <augur_> boom583: :)
09:17:13 <augur_> fair enough. you could just hand simulate this stuff.
09:17:30 <augur_> the important point is to understand the core principles, since they're more general than just haskell
09:17:49 <augur_> boom583: btw, this business of "has a constructor" is called weak head normal form
09:18:15 <augur_> an expression is in weak head normal form (WHNF) when it's a constructor applied to a bunch of stuff
09:18:40 <augur_> constructors are special function-like things that have no rewrite rules associated with them
09:18:56 <augur_> [] and (:) are constructors for lists
09:19:02 <Cale> nisstyre: http://lpaste.net/97272 -- thought I'd point this out
09:20:13 <nisstyre> Cale: thanks
09:20:45 <augur_> boom583: i think the most general understanding of this requires some type theory knowledge, then you can see all of this stuff in the same light
09:21:25 <augur_> boom583: everything becomes uniform and identical. but right now you're going to have to cope with some seemingly different things that all have similar properties
09:21:31 <boom583> ok
09:21:31 <augur_> ski!!!!!!
09:21:34 <allsystemsarego> a catamorphism is the same thing as a fold?
09:21:39 <augur_> allsystemsarego: yes
09:21:48 <Cale> nisstyre: The idea being that dirFold file dir will replace every occurrence of the File constructor with the function file, and every occurrence of the Dir constructor with the function dir throughout a Directory
09:22:25 <augur_> boom583: actually it might help if you learned the unity of these things, but only a little after you write some code
09:22:38 <Cale> This is a bit less like a left-to-right sort of fold, but it mimics what foldr does on lists, in that foldr f z will replace each (:) with f and each [] with z throughout a list.
09:22:38 <boom583> yeah this is later
09:22:43 <nisstyre> Cale: yeah that would make sense
09:22:54 <nisstyre> I never though of it that way
09:24:14 <augur_> boom583: often, when you're using repl-like things, like ghci or textmate, you're always printing stuff, so you're evaluating everywhere
09:24:31 <boom583> repl?
09:24:37 <augur_> read-eval-print-loop
09:24:40 <boom583> ok
09:24:45 <augur_> like a shell for the language
09:24:51 <augur_> that evals expressions you type, and prints the answer
09:25:03 <boom583> yes
09:25:40 <trolling> what's the procedure for submitting patches for transformers?
09:28:04 <pavonia> trolling: Sending them to the maintainer, I guess
09:28:29 <augur_> boom583: i would say, you can ignore issues of laziness for now
09:29:49 <trolling> pavonia: well, I wasn't sure whether it was that or emit it in the direction of the libraries list
09:30:11 <trolling> and I know ross paterson is a busy man
09:35:23 <Taneb> Is there a way to fake do notation or list comprehensions for sets?
09:35:36 <Cale> Taneb: kinda
09:35:45 <Cale> with Codensity
09:37:11 <Cale> http://hackage.haskell.org/package/kan-extensions-0.5.1/docs/Control-Monad-Codensity.html
09:37:15 <FreeFull> Taneb: Maybe if you had indexed monads
09:37:19 <FreeFull> I think Set is an indexed monad
09:37:35 <Cale> The important thing to notice here is that Codensity Set is a Monad
09:38:44 <joelteon> man, what is going on in kan-extensions
09:38:58 <Cale> But while this sort of gives you the Monad instance on Set, it's not as efficient as you'd like that to be
09:39:14 <Cale> It effectively works out to the same thing as using the list monad and then collecting the results into a Set at the end
09:40:17 <Cale> http://hackage.haskell.org/package/rmonad-0.8.0.1/docs/Control-RMonad.html -- there's also this approach!
09:41:16 <Cale> http://hackage.haskell.org/package/rmonad-0.8.0.1/docs/Control-RMonad-AsMonad.html -- and this trick works out the same as codensity, if you want to use ordinary monad operations
09:41:36 <Cale> The thing is, the usual type of (>>=) doesn't have an Ord constraint
09:42:12 <Cale> So, whatever (>>=) does when using the ordinary Monad class, it can't *actually* take the set union.
09:42:32 <Cale> (Because the Ord instance it needs to do that isn't around)
09:45:43 <Cale> http://hackage.haskell.org/package/set-monad also looks pretty cool
09:47:00 <Cale> (If you look at the source code, you can see the trick they've used there)
09:48:20 <Cale> Again, it amounts to deferring the unions a bit. I'd have to look more carefully to tell if this approach ends up being a little more efficient or not.
10:00:40 <trolling> https://gist.github.com/prophile/b165cc31a5134b88d1e4
10:00:43 <trolling> general reversed monads
10:04:06 <simpson> Ah, a GADT. Interesting.
10:05:30 <S11001001> Cale: some pretty strange types in that set-monad package, map :: (Ord a, Ord b) => (a -> b) -> Set a -> Set b
10:06:10 <merijn> S11001001: What's strange about that?
10:06:17 <S11001001> what's the Ord a for?
10:06:25 <Cale> That's the usual type of map for Set
10:06:45 <Cale> You need an ordering to implement the Set data structure.
10:06:49 <S11001001> Cale: not in Data.Set
10:07:02 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Set.html#g:8
10:07:03 <S11001001> simpson: looks like it could have been done with ExistentialQuantification and ExplicitForall, though
10:07:07 <Cale> What?
10:07:41 <merijn> S11001001: All Set operations require Ord
10:07:55 <S11001001> Cale: http://hackage.haskell.org/package/containers-0.5.3.1/docs/Data-Set.html#v:map
10:08:39 <merijn> S11001001: The only way to get non-Ord sets is singleton/empty
10:08:50 <joelteon> cabal is panicking about "Codec.Compression.Zlib: premature end of compressed stream" when I try to install unordered-containers
10:08:51 <S11001001> merijn: what's the Ord *a* for?
10:08:54 <joelteon> is there a cache dir I can remove?
10:10:21 <Cale> S11001001: Ah, yeah, you can get by without the Ord a constraint, but it appears that the version of the containers package that comes with GHC has that constraint.
10:10:41 <Cale> (and the somewhat newer version doesn't)
10:11:03 <S11001001> hmm
10:11:16 <merijn> Is there a way to catch all but one exception?
10:11:27 <Cale> merijn: yes
10:11:40 <Cale> Let me figure out what it is ;)
10:11:57 <merijn> Right now I'm writing "(foo `catch` \MyException -> return ()) `catch` \(SomeException _) -> whateverIwanted"
10:12:10 <merijn> Which is rather horrific
10:12:12 <Cale> We could create a newtype which would have that effect
10:12:32 <joelteon> merijn: isn't that what handles is for?
10:13:04 <shachaf> I'd prefer to say that ContT r m = Codensity (Const (m r))
10:13:10 <merijn> joelteon: That's only marginally less terrible
10:13:33 <shachaf> Anyway, I only got a few hours of sleep. I'm way too tired for Codensity right now.
10:13:57 <merijn> shachaf: Aww, I was about to ask you if my codensity code was correct :p
10:14:47 <shachaf> Codensity is a bit like DList etc. -- it right-reässociates all your (>>=)s/joins/whatever, which lets you do a lot of tricks in some cases.
10:15:18 <merijn> Maybe I should just catch SomeException and check with Data.Typeable
10:15:37 <shachaf> But in a case like Set you often don't want that -- you want to collapse equal elements as you build the set.
10:15:41 <shachaf> Which code?
10:15:44 <shachaf> I could probably look.
10:16:05 <shachaf> Or maybe in ~15-20 minutes.
10:16:47 <shachaf> I think you can see shadows of the problems of the Codensity-based Set Monad thing using a Yoneda/CoYoneda-based Set Functor thing.
10:16:49 <merijn> Cale: I'm going for dinner, just let me know if you figure it out before you get tired of looking :)
10:17:08 <shachaf> Which I think is much easier to understand.
10:17:09 <Cale> merijn: I think I have it, let me check that it works :)
10:24:29 <Cale> merijn: http://lpaste.net/97274
10:25:54 <merijn> Cale: Right, so essentially my SomeException + Typeable suggestion, but hiding it in the exception class. Neat :)
10:26:51 <bennofs> @let import Data.Functor.Identity
10:26:53 <lambdabot>  Defined.
10:28:37 <Cale> merijn: Control.Exception is actually really cool. You can introduce arbitrary new refinements and supertypes of exceptions after the fact.
10:29:13 <Cale> merijn: One thing I did before was to take the old IO exceptions and separate them out into their own types.
10:30:14 <Cale> http://lpaste.net/97276
10:31:58 <merijn> Cale: Neat :)
10:33:17 <Cale> (I could have used fromException rather than cast there, not sure why I used cast directly)
10:36:24 <Cale> http://lpaste.net/97278 -- I dunno how useful it is, but we can also do this :)
10:37:12 <Cale> (It's a very funny looking piece of code because of the polymorphism :)
10:37:46 <shachaf> That is a confusing-looking guard.
10:38:10 <shachaf> Well. Neither one of them individually is too confusing.
10:38:37 <Cale> Well, individually, it looks funny because it looks like infinite recursion
10:38:53 <Cale> and then the fact that you have two of the "same" guard makes it look even more silly
10:39:05 <shachaf> Well, that part's no worse than any Functor instance or anything like that.
10:39:15 <shachaf> But two identical guards in a row is unusual.
10:39:26 <Cale> right, though even in most functor instances, you're more likely to be "recursing" on a subterm
10:39:29 <Cale> rather than the whole thing
10:39:48 <Cale> Oh, what's fromException e? Well, first let's check what fromException e is
10:40:05 <shachaf> Well, OK.
10:40:20 * shachaf wonders whether there's a trick to say | Just Refl <- typableEqualityThing = ... without too many annoying type signatures.
10:42:00 <Cale> I dunno, but pattern guards are almost always the best way to unpack type equality constraints, because you get nice fallthrough, and you can immediately use the equality in the bit after the comma if you have more than one part to your pattern guard
10:56:30 <jle`> hey pattern guards are cool, isn't this ever taught?
11:01:00 <bos> @pl \ks -> m (ks . f)
11:01:01 <lambdabot> m . (. f)
11:01:38 <gamegoblin> I have a function that takes a string, parses it, and outputs a type X. I want to make type X an instance of Read. I am having trouble understanding how to implement the Read class. Can anyone explain how I can bridge the gap between Read and my extant parsing function?
11:02:15 <bennofs> gamegoblin: does your parsing function parse valid haskell code? Read should only be used to parse valid haskell code
11:02:47 <gamegoblin> Ohhh. No. It parses a specific file format.
11:03:04 <bennofs> Then it's probably better to just use your specific parse function.
11:03:16 <gamegoblin> Aaaah K. Thanks for the clarification.
11:03:31 <bennofs> Consider what would happen if a user used the Read instance for [X].
11:03:49 <bennofs> [<Custom non-haskelly format here>, <again>, ...] would look pretty weird
11:05:42 <pqmodn> gamegoblin: same advice for Show is usually given
11:06:19 <gamegoblin> pqmodn: noted, thanks
11:06:42 <jle`> gamegoblin: if you want to do this in the future for something else you should look into the Read typeclass haddocks; you have implement readsPrec
11:07:36 <gamegoblin> Second, unrelated question regarding polymorphism. I have a Tree data declaration. Tree can either be a tuple of two trees, or a Leaf which contains a value. Is it possible to make the values contained in the leaf nodes different types? I know that they are all members of the same typeclass X. Is the only way to do this make another data type that is polymorphic in that it wraps all instances of the typeclass X?
11:08:26 <jle`> which involves creating a ReadS object, which is a function String -> [(a, String)], alist of possible parses and the text after the parse is consumed
11:09:05 <bennofs> gamegoblin: it is possible, but usually not a good idea.
11:09:23 <bennofs> gamegoblin: can you tell use a bit more about the typeclass X and it's instances?
11:09:46 <gamegoblin> Sure. This is an implementation of a decision tree for a machine learning library.
11:09:55 <gamegoblin> basically, once you get to a certain depth in the tree, you want to return a prediction
11:10:06 <gamegoblin> the prediction can be predicted by any number of supervised learners
11:10:12 <gamegoblin> (all of typeclass SLearner)
11:10:33 <gamegoblin> I'd like to be able to attach trees onto each other
11:10:44 <gamegoblin> so maybe one branch has Leaf nodes that use a KNN-learner
11:10:53 <gamegoblin> and other branches have leaf nodes that use a Neural Network learner
11:11:14 <lightquake> i wish there was a DebugShow or something so that I could *force* ghc to try to show a type
11:11:19 <bennofs> What
11:11:33 <bennofs> What methods does the SLearner class have?
11:11:37 <gamegoblin> train and predict
11:11:54 <jle`> lightquake: typeOf?
11:12:32 <lightquake> jle`: no, I mean... I'm messing around with the ghc api and so I have a value of type TyCon
11:12:37 <lightquake> which doesn't have a Show instance
11:12:47 <bennofs> gamegoblin: Maybe you could just use data SLearner = SLearner { train :: Type of train method, predict :: Type of predict method } ?
11:13:03 <jle`> lightquake: ah so you want to show the contents/stuff of a data type that has no show instance
11:13:07 <lightquake> yes
11:13:19 <bennofs> lightquake: You can do that if all the types have a Data instance
11:13:19 <lightquake> and I can't standalone derive it because TyCon doesn't export its constructors
11:14:02 <lightquake> bennofs: not if the constructors aren't exported
11:14:11 <gamegoblin> bennofs: Can you elaborate on that a bit, I think I am not fully understanding
11:14:49 <kqr> lightquake, i don't think you can print its "contents"
11:14:57 <ClaudiusMaximus> @hackage vacuum -- lightquake, but maybe this would be too low level..
11:14:57 <lambdabot> http://hackage.haskell.org/package/vacuum -- lightquake, but maybe this would be too low level..
11:15:03 <kqr> lightquake, how would you show getLine for example
11:15:07 <kqr> lightquake, or (+)?
11:15:20 <bennofs> gamegoblin: If I understand it right, you want to have a data Tree = Node Tree Tree | Leaf (<Anything of class SLearner>) ?
11:15:24 <lightquake> kqr: "<IO String>" and "<function>"? :P
11:15:38 <kqr> lightquake, but that doesn't tell you any more than the type already does
11:15:39 <gamegoblin>  bennofs: Correct
11:15:40 <bennofs> lightquake: http://hackage.haskell.org/package/generic-deriving-1.6.2/docs/Generics-Deriving-Show.html
11:15:43 <kqr> lightquake, you can get that information from the compiler!
11:16:04 <lightquake> kqr: right, but if I have a type that *contains* a value of type IO String
11:16:05 <jle`> kqr: i think he wnats to be able to show the structure of an ADT
11:16:10 <lightquake> right
11:16:28 <bennofs> Woops, that was the generics version
11:16:47 <lightquake> I have some ADT that doesn't have a show instance, and I can't derive a show instance because the constructors aren't exported
11:17:14 <kqr> i still don't see how a debugShow would tell you any more than the compiler does
11:17:20 <kqr> or library or whatever
11:17:24 <lightquake> I'd like for there to be some way to tell ghc 'I solemnly swear to only use this for debugging' and make it derive one using the constructors I don't have access to
11:18:23 <bennofs> gamegoblin: A SLearner is basically just a a function 'learn' and 'train', right?
11:18:35 <gamegoblin> train and predict, yes
11:18:52 <gamegoblin> and most SLearners have to contain some data
11:18:58 <bennofs> gamegoblin: So instead of storing objects that are instances of the class SLearner, you could just store those two functions?
11:18:58 <lightquake> vacuum-graphviz might let me dwiw
11:20:00 <gamegoblin> bennofs: Since most of them must also hold some data (otherwise they wouldn't be able to make meaningful predictions), the function types would no longer be uniform
11:20:32 <gamegoblin> bennofs: Well actually, maybe not... the partially applied functions could still be uniform type...
11:20:47 <gamegoblin> This is getting into really hairy design territory...
11:20:56 <lightquake> ... argh, and i can't cabal install it because of dependency hell
11:21:09 <lightquake> hooray for upper bounds
11:21:35 <kqr> gamegoblin, the typeclasses are probably more hairy, if that gives you any respite
11:21:49 <ski> lightquake : perhaps you can define a (sensible) `Show' instance, manually ?
11:22:59 <flebron> Hi. Why, given an endofunctor F: C -> C, is a morphism F A -> A called an F-algebra? What is the "algebra" here?
11:23:18 <bennofs> gamegoblin: so you can have data SLearner = SLearner { train :: TrainingInput -> SLearner, predict :: PredictInput -> PredictionResult }
11:23:24 <gamegoblin> I think I see what you're getting at with the function idea though, so I think I can implement that. Coming from an imperative background, the idea of my entire object being "stored" in a partially applied function is nuts
11:24:22 <bennofs> lightquake: http://hackage.haskell.org/package/syb-0.4.1/docs/Data-Generics-Text.html
11:24:27 <bennofs> lightquake: gshow should work
11:24:47 <bennofs> lightquake: TyCon is an instance of Data, I checked itr
11:25:44 <lightquake> bennofs: in my version it's only an instance of Typeable
11:25:45 <kqr> gamegoblin, remember what they say: objects are a poor mans closures!
11:26:23 <bennofs> lightquake: But http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/TyCon.html#t:TyCon shows a Data instance ...
11:26:49 <lightquake> oh, so it is. but the instance isn't interesting
11:26:56 <lightquake>     gunfold _ _  = error "gunfold"
11:27:24 <bennofs> aw, that is awful
11:28:25 <bennofs> lightquake: Did you already try Outputable?
11:29:05 <lightquake> ... oh, huh
11:29:19 <stelleg> does anyone know if for any f, f^0 = id? more of a math question than haskell but I thought this might be a good place to ask
11:29:39 <lightquake> stelleg: yes, by definition
11:29:45 <stelleg> lightquake: thanks
11:33:55 <tdammers> except for f = 0
11:36:45 <mortberg> flebron: I think it is because it is a generalization of algebras over fields
11:39:47 <ski> flebron : it's sorta a generalization of <http://en.wikipedia.org/wiki/Universal_algebra> (sans laws. hence they're sometimes called "anarchic algebras")
11:51:31 <eyebloom> What is meant by a "binder" in the sense of say Var is the binder of CoreExpr in the type synonymtype CoreExpr = Expr Var
11:56:40 <kuznero> Please help with Data.FileStore.Git: http://lpaste.net/97283
11:59:42 * hackagebot twidge 1.1.1 - Unix Command-Line Twitter and Identica Client  http://hackage.haskell.org/package/twidge-1.1.1 (JohnGoerzen)
12:09:11 <pavonia> Can anyone help me with that type class problem please? http://lpaste.net/97284
12:16:45 <rasfar> pavonia, I don't know this stuff, but I notice your instance has MonadGUI m => MonadGUI ... but the reader example has Monad m => MonadReader
12:17:27 <byorgey> pavonia: what is EitherT?
12:17:54 <byorgey> pavonia: no  Monad (ReaderT r m)  constraint is needed because there is an instance  Monad m => Monad (ReaderT r m)
12:18:03 <byorgey> and since there is a Monad m constraint that is satisfied
12:18:17 <pavonia> byorgey: http://hackage.haskell.org/package/either-4.0/docs/Control-Monad-Trans-Either.html
12:18:37 <pavonia> there's Monad m => Monad (EitherT e m) too
12:18:58 <byorgey> hmm, yes, I see
12:19:17 <pavonia> rasfar: Unfortunately, that doesn't solve the problem
12:19:26 <byorgey> that's strange then, I don't understand why you would be getting that error
12:19:37 <byorgey> you have a  MonadGUI m constraint, which implies Monad m
12:19:52 <byorgey> so it should be able to deduce Monad (EitherT e m)
12:21:26 <prasadi> import Network.HTTP import System.IO import Control.Applicative   main::IO String main  = do         putStrLn "Enter the company code :"         companyCode <- getLine             downloadCSVFile companyCode                  downloadCSVFile ::String-> IO String downloadCSVFile y=  do                      let a="http://ichart.finance.yahoo.com/table.csv?s=" ++ y                     let b=simpleHTTP ( getRequest a )                  
12:21:45 <kuznero> Still no Data.FileStore gurus? http://lpaste.net/97283
12:21:58 <prasadi> can any of you figure out when the above code returns "Left " ?
12:22:21 <prasadi> I mean , can you give me an example input so that it returns "Left " ?
12:22:35 <benmachine> prasadi: I don't see any Either types, also, consider using lpaste.net
12:24:14 <benmachine> pavonia: it works for me
12:25:18 <pavonia> benmachine, byorgey: Aww, sorry, my fault. Actually, I have my own version of EitherT because of some package troubles, and it only had "Monad m => EitherT String m" :S
12:25:45 <pavonia> err Monad m => Monad (EitherT String m)
12:25:49 <rasfar> kuznero: could it be you need to change directory to the work tree?
12:26:01 <ski> should be `Monad m => Monad (EitherT e m)'
12:26:17 <kuznero> rasfar: I changed it there. I was on the same level as `.git` folder
12:26:17 <benmachine> yeah, just leave fail unimplemented
12:26:26 <pavonia> yeah, but it implements fail too
12:26:45 <pavonia> maybe I should give it another name
12:26:46 <ski> `fail' for `EitherT e m' just calls `fail' for `m'
12:27:05 <prasadi> Is there something called "gloabl variables" in haskell ? or something similar to that ?
12:27:34 <rasfar> kuznero, i don't see you changing dir in the code pasted (but i'm unfamiliar with the API)
12:27:38 <jle`> prasadi: well...everything you define at the top level is 'global'
12:27:45 <jle`> and you can import any constants
12:27:46 <pavonia> ski: Wouldn't that raise an exception in IO?
12:27:51 <jle`> from any module
12:27:54 <ski> @wiki Global variables
12:27:54 <lambdabot> http://www.haskell.org/haskellwiki/Global_variables
12:27:56 <slack1256> you can have global variables that are set only once
12:27:59 <ski> @wiki Top level mutable state
12:27:59 <lambdabot> http://www.haskell.org/haskellwiki/Top_level_mutable_state
12:28:02 <prasadi> you mean to say outside a function ?
12:28:06 <ski> prasadi ^
12:28:13 <kuznero> rasfar: yep, I was running the code from GHCi
12:28:36 <ski> pavonia : if `m' is `IO', yes
12:29:18 <pavonia> I don't want that
12:29:55 <byorgey> pavonia: you shouldn't be relying on the behavior of fail
12:30:55 <prasadi> http://lpaste.net/6832359611413037056
12:31:09 <prasadi> when will the above code return "left" value ?
12:31:35 <pavonia> byorgey: Why not? Isn't that the point of EitherT?
12:31:52 <rasfar> kuznero, good luck, i have to run
12:32:56 <benmachine> prasadi: in the case of a connection error, I think
12:33:16 <prasadi> when not connected to the internet ?
12:33:16 <benmachine> prasadi: the docs are here http://hackage.haskell.org/package/HTTP-4000.2.10/docs/Network-HTTP.html in case you weren't aware
12:33:27 <benmachine> prasadi: or when the remote server is toast
12:33:40 <pavonia> byorgey: What I want is a way to return a value on success and the monad to fail with an error message in case of error
12:34:31 <benmachine> pavonia: what kind of error?
12:34:52 <pavonia> a String
12:34:52 <benmachine> pavonia: "fail" is not for all errors, only for a few very specific ones
12:35:02 <benmachine> pavonia: no, I more meant, what kind of scenario
12:35:22 <benmachine> you can still write EitherT (return (Left "oh no!"))
12:35:47 <pavonia> when the monad fails prematurely, like in case of Maybe returning Nothing
12:36:16 <pavonia> oh
12:36:55 <johannesbodannes> in haskell if i have a really expensive calculation, even if i use the calculation more than once i can trust that it'll only be done once right?
12:37:05 <Clint> no
12:37:09 <johannesbodannes> no? : (
12:37:13 <tdammers> no.
12:37:20 <johannesbodannes> is that possible to control?
12:37:30 <benmachine> yes
12:37:40 <sipa> @faq can Haskell do that?
12:37:40 <lambdabot> The answer is: Yes! Haskell can do that.
12:37:53 <tdammers> finally, an appropriate usage of @faq
12:37:56 <byorgey> johannesbodannes: if you give it a name, and then use the name more than once, it will only be calculated once.
12:38:10 <benmachine> unless it's inlined, but if it's expensive it won't be
12:38:25 <benmachine> actually probably values almost never get inlined
12:38:57 <johannesbodannes> oh ok, but if derp is an expensive function then a `derp` b would just be recalculated
12:39:08 <byorgey> right
12:39:12 <johannesbodannes> OK thanks
12:40:26 <pavonia> benmachine: So you're saying I shouldn't use "fail" but another function foo = EitherT . return . Left for indicating failure?
12:40:35 <benmachine> pavonia: yes
12:40:45 <benmachine> pavonia: fail exists for pattern-match failure in do-notation
12:40:55 <benmachine> it's kind of a hack and to be avoided most of the time
12:41:11 <pavonia> Okay, thanks for clarification
12:43:25 <jrmithdobbs> why is it even called fail? that's usually not what it does.
12:43:45 <mmmulani> hey, I'm having a problem with printing to stdout followed by a 'forever' and reading from stdin
12:44:00 <mmmulani> the code: http://lpaste.net/4040853537297530880
12:44:00 <tdammers> ah crap
12:44:06 <tdammers> two GPX packages
12:44:09 <tdammers> neither works
12:45:11 <mmmulani> when I run it from the terminal, all works as expected but if I start it from a non-terminal the output doesn't show until I manually kill the program
12:45:18 <aleksejs_> Hi
12:45:44 <geekosaur> that would be buffering
12:45:54 <geekosaur> terminals are line buffered, anything else is block buffered
12:46:07 <geekosaur> just like in pretty much every other programming language
12:46:33 <mmmulani> that's what I thought but `print` adds a newline..
12:46:40 <jrmithdobbs> i guess 'fail' comes from the List monad where a computation would 'fail' and therefore not be included in the result?
12:46:45 <jrmithdobbs> the name, i mean
12:46:45 <mmmulani> hSetBuffering doesn't help either
12:47:00 <aleksejs_> I've tried to install this https://github.com/HaskVan/HaskellKoans, but it fails. After installation there's no file ./bin/basic-functions-koans
12:47:44 <aleksejs_> Does anyone know how to fix that? Or maybe you can recomend similar project?
12:52:25 <johannesbodannes> from a coding style perspective is it acceptable in haskell to have really long lines of code?
12:52:58 <mm_freak> johannesbodannes: rather not
12:53:45 <johannesbodannes> really long lines of code seem to happen frequently : /
12:54:05 <benmachine> you can split them into shorter lines, using line breaks
12:54:15 <benmachine> (I will be more specific if you first :P)
12:54:58 <johannesbodannes> oh ok errr like...
12:54:59 <johannesbodannes> this one
12:55:03 <johannesbodannes> consolidateGamesIntoData (d, mn) gs = (foldr consolidateGameIntoData d (filter (\(Game n _ _) -> n > mn) gs), foldl (\x (Game n _ _) -> max n x) mn gs)
12:55:20 <bernalex> johannesbodannes: I wrap all haskell files at 78
12:55:32 <bernalex> johannesbodannes: well that's like writing a Lisp program on one line
12:57:09 <benmachine> johannesbodannes: consider naming intermediate results
12:57:23 <johannesbodannes> oh ok
12:58:01 <benmachine> johannesbodannes: http://lpaste.net/7566401829043437568
12:58:05 <benmachine> example for you
12:58:12 <benmachine> the names are bad because I don't know what your code does
12:58:15 <benmachine> come up with better ones
12:58:39 <johannesbodannes> that looks much nicer, wow
12:58:47 <johannesbodannes> thanks, that's really inspiring actually
13:00:57 <joneshf-laptop> hmm
13:01:09 <joneshf-laptop> i've a question about bifoldable
13:01:14 <joneshf-laptop> or really just any n-foldable
13:02:21 <joneshf-laptop> so the type is: `(a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c`
13:02:31 <joneshf-laptop> how do you decide which side to go with
13:03:02 <joneshf-laptop> like, the to fucntions just apply to both parts of the structure right?
13:03:19 <joneshf-laptop> but then you have tyo return the result from one of them
13:03:56 <joneshf-laptop> but there's no way to combine them since there's no Monoid requirement
13:04:09 <triliyn> joneshf-laptop: you can reuse the a-accumulator as the initial value for the b-accumulator
13:04:39 <joneshf-laptop> even though the first returns a `c` and the second expects a `b`?
13:04:44 <joneshf-laptop> oh geez
13:04:49 <joneshf-laptop> nevermind i see it, thanks!
13:05:02 * joneshf-laptop feels dumb now
13:28:51 <Jesin-phone> Binary operations for which (forall x y. op x y == op y x) are commutative; those for which (forall x y: op (op x y) z == op x (op y z)) are associative.
13:29:21 <Jesin-phone> Is there a similar word for those where (forall x. op x x == x) ?
13:29:50 <shachaf> idempotent
13:30:25 <Jesin-phone> Kthx
13:30:54 <stelleg> is that really idempotence?
13:31:02 <benmachine> stelleg: the word is overloaded
13:31:13 <stelleg> benmachine: ah, thanks
13:31:25 <pqmodn> it also means "op (op (op x))) == op x", right?
13:31:29 <stelleg> the definition i'm familiar with is f x = f $ f x
13:31:34 <stelleg> yes
13:31:37 <benmachine> right
13:31:38 <jrmithdobbs> oh it's going to be that kind of day: *** Exception: <<loop>>
13:31:43 <shachaf> pqmodn: Just op (op x) = op x
13:31:52 <pqmodn> ah, right
13:32:00 <shachaf> Alternatively, it means that op . op = op
13:32:14 <stelleg> true
13:32:29 <benmachine> shachaf: a function is idempotent if composition is idempotent on that function, I suppose
13:32:30 <shachaf> Which is quantified differently, of course.
13:32:34 <benmachine> I'd never looked at it like that
13:32:35 <shachaf> Right.
13:33:10 <pqmodn> are there examples besides min/max of idempotent binary functions?
13:34:19 <pqmodn> oh, wikipedia listed some: set union and intersection, && and ||, meet, join
13:34:52 <lightquake> The function `GHC.getInfo' is applied to two arguments, but its type `GHC.Name -> GHC.Name -> Maybe (TypeRep.TyThing, GHC.Fixity, [GHC.ClsInst])' has only two
13:34:54 <lightquake> cool error
13:34:56 <benmachine> meet/join are basically min/max, just in a different poset
13:35:19 <benmachine> but then so are &&/|| and union/intersection
13:35:34 <benmachine> lightquake: smooth
13:35:37 <bennofs> Is there a way to generate valid haskell source code from a HsModule from haskell-src?
13:36:06 <Jesin-phone> benmachine: Is this join related to join :: Monad m => m (m a) -> m a ?
13:36:14 <joelteon> lightquake: wrong types
13:36:20 <benmachine> bennofs: prettyprint it?
13:36:29 <lightquake> joelteon: right, it's just an amusing error message
13:36:29 <benmachine> maybe?
13:36:36 <joelteon> oh
13:36:48 <shachaf> What do you call operators such that x*x=1?
13:36:51 <bennofs> benmachine: that doesn't generate valid haskell code, it doesn't generate brackets in particular
13:36:58 <benmachine> Jesin-phone: uhm, not in any deep sense that I'm aware of
13:37:08 <benmachine> Jesin-phone: but there are lots of deep connections that I'm not aware of, so who knows :P
13:37:15 <mgsloan> Jesin-phone: Nah, here's a good haskelley treatment of lattices though: http://hackage.haskell.org/package/lattices-1.2.1.1/docs/Algebra-Lattice.html
13:37:16 <Jesin-phone> Kthx
13:37:19 <benmachine> bennofs: oh, weird. switch to haskell-src-exts :P
13:40:29 <bennofs> benmachine: Ok, I'll try that
13:42:38 <jle`> i don't understand why randomIO requires unsafePerformIO.  if it is already in an IO monad can't it just do everything normal-IO
13:43:50 <stelleg> jle`: I think its so you can have lazy lists of random values
13:44:03 <bennofs> jle`: why do you think it'd use unsafePerformIO?
13:44:12 <bennofs> oh, found it. Sorry
13:44:40 <stelleg> similar to how readFile etc. use unsafePerformIO
13:45:00 <geekosaur> are you thinking of unsafeInterleaveIO?
13:45:02 <jle`> ah i wasn't aware that readFile and the like use it
13:45:05 <stelleg> oh yeah sorry
13:45:07 <lightquake> System.Random only uses unsafePerformIO for the global IORef hack
13:45:09 <bennofs> It only uses unsafePerformIO for creating the global stdgen
13:45:19 <stelleg> oh
13:45:22 <stelleg> ignore me then
13:45:45 <jle`> oh
13:45:51 <jle`> i guess i've never used randomIO
13:45:51 <lightquake> blarg, GHC API hacking is hard
13:46:05 <jle`> so randomIO runs a random action but with the global stdgen
13:46:12 <jle`> and updates the global stdgen in place?
13:46:34 <jle`> but why can't you just do IO for that
13:46:44 <bennofs> lightquake: What are you building?
13:46:52 <jle`> oh, you need the 'reference' to the global stdgen?
13:46:56 <bennofs> jle`: Yes
13:46:59 <lightquake> bennofs: something to clean up types by inverting type synoyms
13:47:03 <jle`> there is too much i do not understand to say anything intelligible right now
13:47:12 <merijn> jle`: newIORef etc. are IO actions
13:47:34 <jle`> what id on't really get is that you are in an IO monad anyway
13:47:35 <merijn> jle`: If you wrote "globalStdgen = newIORef someVal" then every use of globalStdgen would create a new IORef
13:47:45 <jle`> ah, okay
13:47:48 <bennofs> lightquake: That sounds useful! But inverting type synonyms doesn't seem like an easy problem :)
13:47:51 <jle`> so it passes the underling reference
13:47:54 <triliyn> :t newIORef
13:47:55 <lambdabot>     Not in scope: `newIORef'
13:47:55 <lambdabot>     Perhaps you meant `newSTRef' (imported from Data.STRef)
13:47:57 <merijn> jle`: What you *wanted* was to create *one* global stdgen and use that
13:48:08 <lightquake> bennofs: conceptually it's not *terribly* difficult, I don't think
13:48:17 <enthropy> lightquake: what happens if you have a `type Matrix a = [[a]]` and want to "clean up" a [[Char]]?
13:48:27 <dv-> @hoogle newIORef
13:48:27 <lambdabot> Data.IORef newIORef :: a -> IO (IORef a)
13:48:30 <lightquake> enthropy: right, that's the problem
13:48:35 <enthropy> do you give [String], or do you give Matrix Char?
13:48:44 <merijn> jle`: So you "globalStdgen = unsafePerformIO (newIORef someVal)" and now globalStdgen :: IORef StdGen, instead of "globalStdgen :: IO (IORef StdGen)"
13:48:47 * enthropy gives the first one because it's shorter :p
13:48:51 <lightquake> clearly the right answer is to give both!
13:49:14 * enthropy wonders about other type functions
13:49:30 <merijn> jle`: Interacting with an IORef still requires you to be in IO, but the unsafePerformIO means you don't have to explicitly pass the "global" stdgen everywhere
13:49:51 * hackagebot GPX 0.8.0 - Parse GPX files  http://hackage.haskell.org/package/GPX-0.8.0 (TonyMorris)
13:49:52 <merijn> jle`: (note that this requires a NOINLINE pragma, else GHC might inline the unsafePerformIO, making your program buggy)
13:51:09 <merijn> triliyn: "newIORef :: a -> IO (IORef a)"
13:51:21 <benmachine> jle`: it has been argued that you shouldn't need unsafePerformIO for this, because IO already has access to global mutable state in e.g. the filesystem
13:51:32 <benmachine> jle`: however no-one has done anything about this
13:51:43 <merijn> benmachine: I don't believe anyone sane would ever argue that
13:52:00 <benmachine> merijn: that's a bit extreme
13:52:30 <lightquake> bennofs: this is one of my current plots to improve hdevtools
13:52:33 <benmachine> merijn: do you think proposals to allow top-level IORefs to be created without unsafePerformIO are insane?
13:52:33 <merijn> benmachine: Well, s/sane/practical/ then
13:52:57 <benmachine> merijn: iirc it was actually implemented in JHC, but then no-one used JHC :P
13:53:17 <merijn> benmachine: Maybe I inferred the wrong meaning from your sentence
13:53:39 <merijn> benmachine: I thought you were saying "we don't need top-level IORefs because we already have the filesystem for global mutable state"
13:53:46 <benmachine> merijn: ah, no
13:54:01 <benmachine> merijn: I meant "we already have global mutable state so a little more wouldn't hurt"
13:54:03 <merijn> Which I do think is rather insane/impractical :p
13:54:52 <benmachine> merijn: I agree that that interpretation is silly, but I still think "insane" is a bit strong
13:55:20 <merijn> I *never* speak in hyperbole!
13:55:26 <fread2282> Why isn't if a function?
13:55:46 <enthropy> benmachine: not moving forward with any of the proposals isn't so bad because the NOINLINE / unsafePerformIO is practically the same thing I think
13:55:51 <merijn> fread2282: because haskell doesn't have mixfix, so then it couldn't have multiple tokens
13:55:51 <joelteon> fread2282: hysterical raisins
13:56:04 <benmachine> enthropy: I agree, I don't think it's a big deal
13:56:06 <fread2282> merijn: https://gist.github.com/fread2281/e7aea39c4b89643d6098
13:56:10 <joelteon> merijn: yeah, but if condition true_branch false_branch would be fine with me
13:56:37 <benmachine> enthropy: I only mean to acknowledge that there isn't necessarily a principled reason why things must be this way
13:56:55 <merijn> joelteon: Yeah, but it's a bit unreadable
13:56:57 <lightquake> fread2282: but then you can't do iff x thenf 2 + 2 elsef 5
13:57:06 <benmachine> it's commonly agreed that there should be an if-function
13:57:07 <mm_freak> the question is:  why isn't there a predefined if-function?
13:57:14 <benmachine> but it's not so horrible that it's also syntax
13:57:22 <merijn> mm_freak: True, but that's a different question
13:57:32 <mm_freak> and i don't mean in Data.Bool or in some missing* package, but in the Prelude, where it's actually useful =)
13:57:47 <benmachine> mm_freak: pfft, another import won't kill you
13:58:08 <mm_freak> it sucks enough to have to import Data.Monoid all the time ;)
13:58:13 <lightquake> pf
13:58:14 <merijn> fread2282: Sure, but that's not particularly elegant
13:58:19 <lightquake> everything in base should be in Prelude
13:58:36 <mgsloan> lightquake / enthropy: Yeah, I'd like to solve this problem as well.  I think my ideal solution would be to have type synonym substitution be interacive (e.g. they can be introduced or removed), but some substitutions would automatically be preferred, as a preference
13:58:37 <enthropy> mgsloan: when you wrote rex, were you aware of the lowercase viewP etc. in template haskell?
13:58:43 <enthropy> whoa
13:58:44 <mgsloan> wow, what a coincidence
13:59:04 <merijn> fread2282: It's commonly agreed that there should be an if function, but every time someone proposes it the type signature is bikeshed to death
13:59:15 <mgsloan> enthropy: I think I was, but I generally eschew the lowercase operators - I think they're kinda ugly
13:59:15 <lightquake> mgsloan: yeah, an interactive view would be neat
13:59:20 <lightquake> merijn: what do people bikeshed over?
13:59:26 <enthropy> currently addressing the "Since haskell-src-exts does not support parsing view-patterns"
13:59:29 <enthropy> because it does
13:59:55 <mgsloan> Ahh, well, I imagine it might not have at the time
14:00:00 <mgsloan> Or I could have been mistaken
14:00:01 <merijn> lightquake: argument order, people argue whether it should be "Bool -> a -> a -> a" or "a -> a -> Bool -> a" and whether it should be called, if', iff, bool or cond
14:00:14 <mgsloan> It might be that haskell-src-meta doesn't support view-patterns, and I mistyped
14:00:27 <lightquake> why don't we compromise and go with a -> Bool -> a -> a?
14:00:30 <lightquake> :D
14:00:45 <merijn> lightquake: ಠ_ಠ
14:00:58 <lightquake> ( ͡° ͜ʖ ͡°)
14:01:00 <enthropy> might be. The error you currently get from  parsePat "x -> (a,b)" is because the parser doesn't have -XViewPatterns enabled
14:01:08 <mgsloan> Ahhhh
14:02:39 <mgsloan> Yeah, I think this was one of the first times I used HSE, so didn't quite have the hang of stuff like that
14:02:49 <mgsloan> Thanks for pointing it out!
14:03:05 <mgsloan> Btw, if you're into HSE stuff, I've got this big ol branch that I think is pretty nifty https://github.com/mgsloan/haskell-src-exts/compare/46-more-parsers
14:03:13 <lightquake> merijn: we can also call it iff'!
14:03:15 <issam> hi guys
14:03:19 <issam> why doesnt this work?
14:03:34 <pavonia> we could have both "cond :: Bool -> a -> a -> a" and "bool :: a -> a -> Bool -> a"
14:03:34 <issam> http://pastebin.com/6XwuS5wW
14:03:36 <mauke> The paste 6XwuS5wW has been copied to http://lpaste.net/97289
14:04:10 <lightquake> i should write a blog post, that's what originally started this massive yak stack of 'i want to blog' 'but i need to rewrite my theme' 'but it'd be easier if I could get type info within my program' 'but hdevtools doesn't have emacs support'
14:04:26 <benmachine> issam: error message?
14:04:57 <issam> http://pastebin.com/Tzxwvg2J
14:04:58 <mauke> The paste Tzxwvg2J has been copied to http://lpaste.net/97290
14:04:59 <bennofs> lightquake: hdevtools doesn't have emacs support, what?
14:05:01 <issam> i added the error message
14:05:04 <issam> benmachine
14:05:06 <issam> :)
14:05:27 <lightquake> bennofs: there's no 'get type of thing at point' that I could find
14:05:29 <benmachine> mgsloan: man, your e-mail led me to expect at least 45 parsers more than I got
14:05:33 <benmachine> er
14:05:35 <benmachine> *your URL
14:05:55 <lightquake> issam: when you call flips Yes 5, that's getting parsed as (flips Yes) 5
14:06:00 <lightquake> you want to do flips (Yes 5)
14:06:23 <benmachine> issam: the error message talks about code you haven't included
14:06:33 <benmachine> but lightquake probably has the right cause
14:06:51 <lightquake> bennofs: so I wrote https://github.com/lightquake/hdevtools-emacs
14:07:00 <issam> but it's flips  (Yes 5)
14:07:13 <lightquake> that's not what the error message says
14:07:21 <lightquake> did you save and rerun/reload?
14:07:22 <issam> ah
14:07:23 <issam> okay
14:07:25 <issam> when im printing
14:07:40 <issam> I see, thanks
14:07:44 <issam> because flips is expecting
14:07:46 <issam> one argument
14:07:52 <issam> which is of type Answer a
14:07:55 <issam> hence the brackets :)
14:08:02 <issam> the paranthesis*
14:08:23 <issam> its working now :)
14:09:03 <mgsloan> benmachine: Hahaha, well, it actually adds about 45 more parsers than you thought! I think it's around 70
14:09:16 <mgsloan> (it's github issue #45)
14:09:39 <mgsloan> (I got a habit of prefixing branches with issue numbers)
14:09:51 <benmachine> mgsloan: oh, right, cool
14:10:53 <mgsloan> So, you get parsers for most AST types, and also a few new types for doing nongreedy parses of module name / module header / header + imports
14:11:46 <Feuerbach_> mgsloan: speaking of HSE, I pinged Niklas recently about the outstanding PRs. Hopefully he either reviews them soon or gives me a permission to do it
14:12:27 <mgsloan> Feuerbach_: Cool, I'd definitely like to see some of this stuff merged in
14:12:34 <Feuerbach_> yeah, me too
14:12:50 <mgsloan> Feel free to merge the others in first, and I can deal with the conflicts on this one
14:13:40 <mgsloan> At this point, I'm pretty darn sure that I didn't break anything in my parser modifications
14:14:40 <mgsloan> well, hopefully.  I'd like to have some fuzz testing for it just to be sure
14:15:02 <benmachine> HSE really needs better tests
14:15:10 <benmachine> I discovered a bug in it with quickcheck
14:15:11 <benmachine> by accident
14:15:14 <mm_freak> that nickname makes me curious every time i read it…  one of my neighbour cities is called feuerbach =)
14:15:31 <mgsloan> Yeah, I have a WIP test for HSE that compares it and GHC's parser
14:15:50 <Feuerbach_> benmachine: what kind of bug?
14:15:56 <mgsloan> currently the main thing missing is getting extensions from the cabal file and giving it to both of them
14:16:08 <mgsloan> but already it can find cases where the extensionless behavior differs
14:16:09 <benmachine> Feuerbach_: it got fixed, let me see if I can find it
14:16:25 <mgsloan> (oh, also it's doing this on all of hackage)
14:17:23 <benmachine> Feuerbach_: it was something like nested conses being parsed incorrectly
14:17:26 <mgsloan> to me, this is the ultimate HSE test, because if you can parse almost all of hackage, well, that's a large proportion of the haskell code that's in the wild
14:18:06 <mgsloan> Now, I didn't actually implement the AST conversions, so this is really only testing whether they fail / succeed the same
14:18:09 <Feuerbach_> I can merge tests even without Niklas's approval, so send them in =)
14:18:48 <Feuerbach_> I found quite a few bugs just by getting base to parse with HSE
14:19:02 <mgsloan> wouldn't have caught the nested cons issue, I suppose
14:19:06 <mgsloan> yeah
14:19:43 <mgsloan> What's the likelihood of ever getting GHC to use HSE, or cleaning up + moving GHC's parser out?
14:19:54 * hackagebot RSA 2 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  http://hackage.haskell.org/package/RSA-2 (AdamWick)
14:19:58 <mgsloan> Seems kinda crappy to have two parsers
14:20:16 <Feuerbach_> there was a talk at ICFP'12 about at least using HSE's ast for TH
14:20:19 <mgsloan> (HSE was forked from GHC many years ago)
14:20:25 <mgsloan> that'd be cool
14:20:38 <benmachine> Feuerbach_: I found this http://code.google.com/p/haskell-src-exts/issues/detail?id=24 while quickchecking pointfree
14:20:41 <Feuerbach_> because we actually have 3 different ASTs now. GHC has its internal one and TH
14:21:06 <benmachine> Feuerbach_: I've heard that said too
14:21:11 <benmachine> don't know when it will actually happen :P
14:21:41 <Feuerbach_> well, it's not happening — I know no-one working on that atm
14:22:08 <Feuerbach_> just lack of people-time
14:22:27 <Feuerbach_> and, partly, motivation(?)
14:23:06 <mgsloan> Yeah, it'd just be nice, not a pressing issue
14:23:24 <mgsloan> haskell-src-meta works well enough for little things
14:23:43 <mgsloan> (thought not being able to rely on it does suck)
14:24:41 <mgsloan> I kinda like TH's AST more, though.  It's got more uniform naming conventions
14:25:28 <mgsloan> Having GHC tie down an HSE version would suck
14:26:28 <mgsloan> So maybe the solution is to have HSE's simplified AST use TH at its core.  Could be interesting
14:27:02 <bennofs> I wonder how hard it would be to write GHC.HsModule -> HaskellSrc.HsModule
14:27:51 <bennofs> Has anyone tried writing a conversion function from GHC's AST to haskell-src-exts AST yet?
14:28:43 <Feuerbach_> mgsloan: the problem with GHC tying down the HSE version would only appear when depending on both HSE and GHC API, I think
14:29:18 <mgsloan> Hmm, that's a cool idea.  One thing that HSE's annotated asts have that GHC's doesn't is enough information to reconstruct all the formatting of the code
14:31:27 <mgsloan> Feuerbach_: Oh?  Hmm, I thought being a dependency of GHC can be a major problem: http://www.haskell.org/pipermail/cabal-devel/2013-March/009348.html
14:32:13 <bennofs> I think the GHC API really needs a cleanup. Right now, checking if something needs to be rebuild, resolving dependencies, doing IO and compiling files is done everywhere
14:33:05 <mgsloan> Yeah, chrisdone was having issues using GHC's APIs for shm.  Apparently it's very hard to traverse them generically without causing exceptions etc etc
14:33:17 <bennofs> (At least I haven't found out how to just compile some modules that isn't in any file on the filesystem and load it to GHCi :|)
14:34:06 <mgsloan> bennofs: Maybe "hint" is enough for your purposes?
14:34:17 <Feuerbach_> mgsloan: it *may* be a major problem if you need the GHC API. But otherwise using a different Cabal version is not a problem at all
14:34:27 <Feuerbach_> I use HEAD all the time
14:34:47 <Feuerbach_> and for some time I've been using my own fork (which is now merged in)
14:34:54 <mgsloan> true true, I've got something close to head of both cabal and ghc here
14:34:57 <bennofs> mgsloan: Well I solved the problem by just writing the file somewhere in /tmp/<some dir> so the GHC API is happy :p
14:35:25 <mgsloan> gotcha
14:35:55 <bennofs> Btw, I'm currently working on a work-around for the Cabal-GHC problem by using GHC to compile my code using another version of the Cabal library
14:36:11 <bennofs> (Compile the Cabal-code at runtime)
14:37:24 <mgsloan> cool!
14:44:56 * hackagebot RSA 2.0 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  http://hackage.haskell.org/package/RSA-2.0 (AdamWick)
14:48:55 <robonerd> hahha
14:49:04 <robonerd> will anyone smart ever trust rsa again?
14:49:23 <acfoltzer> robonerd: the algorithm or the company?
14:50:09 <merijn> Saying that no one smart will trust RSA means you're not really understanding the security issues in play
14:50:36 <flebron> either that or he just proved factoring is in P
14:51:36 <bennofs> Can I attach additional information to an exception?
14:52:00 <robonerd> merijn please explain
14:52:04 <merijn> bennofs: You can turn arbitrary types into exceptions
14:52:06 <robonerd> acfoltzer what's the distinction?
14:52:14 <robonerd> isn't their work product proven faulty?
14:52:17 <flebron> one is a company, the other is an algorithm
14:52:17 <merijn> robonerd: Why do you think RSA is no longer secure?
14:52:21 <robonerd> yes, but and?
14:52:30 <flebron> the algorithm is public, and had no breaks or breaches
14:52:37 <robonerd> mcdonalds puts out the qtr pounder. they reflect each other. both are scum
14:52:45 <flebron> it's literally modular exponentiation and the fact that factoring is thought to be hard
14:52:55 <simpson> robonerd: Sorry, is this anything to do with Haskell?
14:53:03 <acfoltzer> >.>
14:53:07 <robonerd> flebron so what was exploited?
14:53:11 <robonerd> er, -chat?
14:53:14 <robonerd> sorry simpson
14:53:15 * merijn proposes #haskell-blah
14:53:17 <flebron> lots of things which aren't relevant to ##haskell :)
14:54:58 <flebron> let encrypt e n m = m^e `mod` n; decrypt d n c = c^d `mod` n
14:55:03 <flebron> now it's about haskell :)
14:55:09 <enthropy> mgsloan: looks useful. I'm a bit confused whether https://github.com/haskell-suite/haskell-src-exts is really the real haskell-src-exts repo
14:55:34 <Feuerbach_> it is
14:56:02 <enthropy> Feuerbach_: well there are lots of pull requests unresolved
14:56:05 <acfoltzer> simpson: it sounded like robonerd was questioning the trustworthiness of Adam Wick's RSA library, I was just trying to clarify what exactly they were questioning
14:56:17 <enthropy> maybe there is more progress if you go through the previous mantainer?
14:56:33 <Feuerbach_> previous maintainer?
14:56:50 <enthropy> I mean Niklas Broberg and not you
14:57:00 <Feuerbach_> HSE is still maintainer by Niklas, he just doesn't have much time these days
14:57:06 <Feuerbach_> *maintained
14:59:28 <Feuerbach_> enthropy: oh, I didn't realize you're Adam :)
15:00:57 <Feuerbach_> enthropy: as I wrote above, I pinged Niklas recently about the outstanding PRs. Hopefully he either reviews them soon or gives me a permission to do it
15:01:42 <enthropy> yep
15:02:05 <enthropy> a cleaner way would be if there was only one parser
15:02:37 <enthropy> so you never have the situation where ghc accepts stuff that hse doesn't (and the opposite)
15:02:45 <Feuerbach_> hmm. You can ignore HSE, and then there's only one. But does it really help?
15:03:00 <enthropy> well ghc's parser isn't as convenient
15:03:04 <Feuerbach_> exactly
15:05:09 <bennofs> How does one write QuickCheck tests for a parser?
15:05:32 <enthropy> bennofs: write a pretty-printer first
15:05:49 <bennofs> hmm, right.
15:05:59 <enthropy> then you can test stuff like   parse . prettyPrint == id
15:06:53 <bennofs> But isn't it often the case that parse fails on input that is not "pretty", but rather some edge-case? It seems to me that prettyPrint won't produces these ugly edge-cases too often
15:08:42 <enthropy> that's true. But I think you'll have a hard time to define generators for strings that are valid syntax, without using some kind of pretty printer.
15:12:16 <merijn> I don't suppose there's a clean handy definition for "\_ -> return ()"/"const (return ())" somewhere?
15:13:35 <bennofs> @hoogle discard +pipes
15:13:36 <S11001001> merijn: if using as an arg to >>=, there's <$
15:13:37 <lambdabot> Could not find some databases: pipes
15:13:37 <lambdabot> Searching in:
15:13:37 <lambdabot>   .
15:14:36 <bennofs> merijn: if you're using pipes, it has discard :: Monad m => a -> m ()
15:14:46 <merijn> ooh
15:14:49 <enthropy> mempty will work if you have an   instance (Monad M, Monoid a) => Monoid (M a)
15:14:49 <merijn> That might be useful
15:15:49 <merijn> I'm using pipes, although pipes is resulting in annoyingly long lines for me atm (both for code and types)
15:21:27 <issam> what does foldr do?
15:21:37 <issam> foir example, eval = fold id (+) (*)
15:22:14 <shachaf> That is not foldr.
15:23:04 <merijn> > foldr f z [a,b,c,d]
15:23:08 <lambdabot>  f a (f b (f c (f d z)))
15:23:09 <issam> thats on the notes
15:23:17 <issam> but I think fold and foldr are the same right?
15:23:34 <merijn> issam: What you wrote is a type error, even with foldr or foldl
15:24:20 <issam> maybe it needs a premise?
15:24:31 <issam> or some data defined beforehand
15:24:39 <issam> eval = foldr id (+) (*)
15:24:48 <issam> foldr id (+) (*)
15:25:44 <issam> but I don't get its semantics merijn
15:25:55 <issam> it is apply f on every argument in the list
15:25:59 <issam> applying*
15:26:08 <issam> but for what purpose?
15:27:01 <nooodl> usually foldr "runs down" values in a list, collecting a value
15:27:35 <ski> issam : presumably your `fold' is a fold for some different type than lists ?
15:27:59 <nooodl> i'm curious as to what that fold id (+) (*) example is from yeah
15:28:14 <ski> like possibly `data Expr val = Val val | Add (Expr val) (Expr val) | Mult (Expr val) (Expr val)' or something similar
15:28:33 <ski> (perhaps not parameterized)
15:29:21 <Tordek> are Applicatives "more powerful"/more structured/better than Monads?
15:29:22 <issam> http://www.cs.nott.ac.uk/~gmh/chapter10.ppt
15:29:26 <issam> this is the link to the slides
15:29:34 <merijn> Tordek: No, Monads are more powerful than Applicative
15:29:37 <ski> (given the above, we could possibly have `fold :: (val -> res) -> (res -> res -> res) -> (res -> res -> res) -> (Expr val -> res)')
15:29:44 <issam> slide 20
15:29:55 <merijn> Tordek: i.e. every Monad can be an Applicative, but not every Applicative can be a Monad
15:30:20 <issam> yes ski
15:30:22 <issam> exactly
15:30:41 <issam> but fold isn't defined anywhere
15:30:46 <issam> hence the confusion
15:30:59 <Tordek> merijn: that's... counterintuitive? I'd expect that since any monad can be used as an applicative, an applicative is at least as powerful
15:31:27 <scriptor> Tordek: no, it means that all monads have *at least* the same capabilities as any applicative
15:31:27 <Tordek> and since you say not all apps are monads... I'd expect app to be more powerful? am I missing something?
15:32:05 <scriptor> but not all applicatives are monads, which means not all applicatives have the capabilities needed to be a monad
15:32:51 <ski> ok, so `data Expr = Val Int | Add Expr Expr | Mul Expr Expr' and `fold :: (Int -> res) -> (res -> res -> res) -> (res -> res -> res) -> (Expr -> res)'
15:33:04 <ski> issam : it's your job to define `fold'
15:33:15 <merijn> Tordek: Monad is more powerful as in, you can do more using monadic code than applicative code. But that comes at a cost, so not every type is flexible enough to give you that power
15:33:17 <Tordek> scriptor: interesting; can you point me to any examples?
15:33:58 <merijn> Tordek: I can give my usual example (which I have to write in a blogpost sometime anyway, so maybe I should just copy paste this discussion)
15:34:03 <scriptor> Tordek: sorry, I don't know enough about the specifics, just the generalities
15:34:05 <ski> Tordek : the applicative interface is more general, captures more things than the monad interface. the applicative interface is also weaker, if all you know is that something is an applicative, you can do less with it than if you also knew it was a monad
15:34:22 <issam> ski, slide 20 is describing fold, but I didn't essentailly get it
15:34:28 <merijn> Tordek: Do you understand the following type? "newtype Const c a = Const c"?
15:34:33 <issam> I quote, "Many functions on expressions can be defined by replacing the constructors by other functions using a suitable fold function"
15:35:11 <ski> Tordek : so the monad *interface* (not particular monad types) is more "powerful" (not my choice of wording) in the sense that it tells you more you can do with it than the applicative interface does
15:35:13 <nooodl> issam: here "fold" is a fold function for Expr values, whereas "foldr" is a fold function for [a] values
15:35:21 <merijn> Actually, I guess "data" would've been acceptable to, the newtype is useless
15:35:21 <Tordek> merijn: I think I do
15:35:32 <issam> I see, noodl, thanks
15:35:33 <issam> :)
15:36:01 <merijn> Tordek: It's a bit of a silly type (unless you're edwardk and build lens on top of it)
15:36:10 <nooodl> issam: i.e. in foldr you specify two replacements for the constructors of a list, [] and (:)
15:36:17 <nooodl> here you do the same for Val, Add, Mul
15:36:44 <merijn> Tordek: It's easy to implement Functor (Const c), since we have "fmap :: (a -> b) -> Const c a -> Const c b" we can just write "fmap f (Const x) = Const x"
15:36:48 <ski> issam : write a function that generalizes over `size' and `eval', capturing the commonalities between them, replacing the differing parts by extra parameters, so than you could define `size' and `eval' from `fold' by passing as actual parameters the "differing parts", respectively
15:37:09 <merijn> Tordek: There is no 'a' inside Const (just a 'c') so we can just do nothing and say "there, done!"
15:37:43 <Tordek> ski: It'd be kind of like Monad 'inherits' from Applicative, so you can use a Monad as a Monad or anything weaker, but not an Applicative as a Monad because it may not be able to work like that?
15:38:13 <merijn> Tordek: Now if we try to implement applicative, we already have a bit of trouble. Since applicative requires: "pure :: a -> Const c a" and "(<*>) :: Const c (a -> b) -> Const c a -> Const c b"
15:38:19 <merijn> Tordek: Yeah, that's a good intuition
15:38:38 <ski> Tordek : yes, any particular type which happens to conform to the applicative interface might not conform to the monad interface
15:38:48 <merijn> Tordek: The problem is that if I write "pure x = Const ??" I need to pluck a 'c' out of thin air, but how do I do that?
15:39:20 <Tordek> awesome, thanks (also, I'm following, merijn, go on)
15:39:24 <merijn> Tordek: It turns out that "Const c" can only be an Applicative if 'c' is a Monoid (which gives us mempty as "default" argument)
15:39:40 <issam> Okay its clear now, thanks! :)
15:39:53 <ski> yw :)
15:40:18 <merijn> Since that means we can do "pure x = Const mempty" and "Const x <*> Const y = Const (mappend x y)" (I'm not gonna go into the Applicative laws, but if we discarded x or y here, we'd break those laws!)
15:40:20 <Twey> In reactive-banana, how can I execute an IO action in response to an Event (and use its value as the value of a Behavior)?
15:40:45 <merijn> Tordek: We have a problem once we try to make "Const c" a Monad, though
15:41:45 <merijn> Tordek: The type of bind is: "(>>=) :: Const c a -> (a -> Const c b) -> Const c b", so to implement >>= (and thus Monad) we somehow need to give this "a -> Const c b" function an 'a', unfortunately, we can't possibly get an 'a' since "Const c a" only contains a 'c'
15:42:42 <merijn> Tordek: In other words we can see the hierarchy of Functor -> Applicative -> Monad here. Any "Const c" can be a functor, only "Const c" where 'c' is a Monoid can be Applicative and no variation of "Const c" can be a Monad
15:43:04 <shachaf> Const c can be a monad when c is ()!
15:43:07 <Tordek> I see; awesome explanation, thank you!
15:43:15 <merijn> shachaf: True :p
15:44:04 <shachaf> On the other hand data Nonst c a = Nonst c a can even be a monad when c is a monoid
15:44:22 <Tordek> Nonst?
15:44:31 <bennofs> Writer
15:44:34 <foozbaz> how would i write a general function to zip together between 3 and 10 lists of the same length?
15:44:38 <shachaf> (,)
15:45:04 <Tordek> foozbaz: what'd be the return type of that?
15:45:14 <nooodl> foozbaz: maybe you want something like Data.List.transpose?
15:45:29 <foozbaz> Tordek: i think it'd have to be dependent on the data
15:45:48 <foozbaz> Tordek: basically i need to output tuples that are different sizes depending on data in a file
15:45:56 <foozbaz> Tordek: i've gotten as far as a list of lists..
15:46:17 <foozbaz> Tordek: transpose gives me lists that i want, all between 3 and 9 elements, but .. i need tuples
15:46:40 <Tordek> a 2-tuple is a different type from a 3-tuple, no can do
15:46:51 <foozbaz> Tordek: so it's just impossible in the language/
15:46:53 <foozbaz> ? *
15:47:06 <Twey> foozbaz: You need dependent types to do this nicely
15:47:32 <Twey> You can *probably* hack something up in Haskell that will do what you want, but it's going to be a lot more effort than it's worth, I suspect
15:48:05 <Tordek> unless you feel like defininf a type like "data WeirdTuple a = ThreeTuple (a,a,a) | FourTuple (a,a,a,a) | ...", the easiest way seems to be to follow nooodl's advice and use transpose
15:48:44 <ski> issam : exercise, define the relevant `foldExpr' for `data Expr val var = Val val | Var var | Add (Expr val var) (Expr val var) | Mul (Expr val var) (Expr val var)', and also define `mapExpr :: (val0 -> val1) -> (var0 -> var1) -> (Expr val0 var0 -> Expr val1 var1)'
15:48:50 <ski> issam : then define `substExpr :: (var0 -> Expr val var1) -> (Expr val var0 -> Expr val var1)', such that `substExpr (\var -> case var of "x" -> Add (Val 2) (Var "y"); "y" -> Var "x"; _ -> Val 0) (Add (Var "x") (Mul (Val 10) (Var "y")))' evaluates to `Add (Add (Val 2) (Var "x")) (Mul (Val 10) (Var "x"))'
15:48:59 <foozbaz> Twey: I was thinking of something like this http://stackoverflow.com/a/12430723
15:49:22 <foozbaz> Twey: using plain typeclasses with different return values..
15:49:28 <Tordek> is there a convention or something for "If the monad works this way, the applicative should work that way"?
15:49:32 <merijn> foozbaz: Generally not wise
15:49:36 <merijn> Tordek: Yes
15:49:52 <foozbaz> Tordek: nooodl : tranpose works for getting the lists i'm after..
15:49:54 <issam> ski: sure, working on it
15:49:57 <Twey> foozbaz: Both those types of polymorphism are over types; you need polymorphism over values
15:50:16 <merijn> Tordek: Rather, there are laws for Functor, Applicative and Monad and if those are followed then the behavior of all of them will match
15:50:29 <bennofs> Tordek: (<*>) = ap
15:50:38 <bennofs> Tordek: pure = return
15:50:47 <ski> issam : typically `var' will be `String' or something else that represent identifiers (variable names)
15:50:48 <nooodl> foozbaz: what's in these tuples? i'm assuming all of the values are of the same type if transpose even worked -- but why do you want them to be tuples, not lists?
15:50:54 <Twey> Polymorphism of types over values is the essence of dependent types, and Haskell doesn't have it (up to fairly large amounts of effort to duplicate values on the type level)
15:51:03 <merijn> Tordek: specifically "fmap id x" == "pure id <*> x" == "x >>= return" == "id x"
15:51:13 <shachaf> == "x"
15:51:18 <shachaf> (hth)
15:51:22 <Tordek> bennofs: so, if I have a Monad, I should just define its applicative instance like that?
15:51:22 <foozbaz> Twey: what if i was using a list that encodes its length in the type, instead of straight lists?
15:51:37 <merijn> Tordek: You could
15:51:40 <Twey> foozbaz: In that case you could definitely do it
15:51:42 <bennofs> Tordek: you can, unless you are able to make the applicative instance more efficient
15:52:00 <shachaf> pure = return; (<*>) = ap
15:52:11 <shachaf> Oh, someone wrote that.
15:52:15 <ski> issam : you could also define `substAll :: (var -> Expr val var) -> (Expr val var -> Expr val anything)', which repeatedly subtitutes until no variables are left in the expression
15:52:27 <foozbaz> merijn: what's the unwise thing about instances which return a different type
15:52:29 <Twey> foozbaz: But that's not the same question: you'd still have to go from runtime data to the file to a type-level representation of it (i.e. a Vec n Foo)
15:52:33 <Tordek> so, that'd be, at the least, a good quickcheck definition for your instances?
15:52:36 <Twey> s/to the file/in the file/
15:52:44 <Twey> foozbaz: That's the hard bit =)
15:52:50 <foozbaz> Twey: yeah, the Vec library is the thing I'm using
15:53:20 <foozbaz> Twey: but it brings in a whole new kindof hell with every function needing a thousand little   (....) => things
15:53:28 <Twey> Hehe
15:53:37 <Twey> foozbaz: Right, that's part of what I meant about it being more trouble than it's worth
15:53:50 <issam> ski, sounds tough, im still a haskell noobie :(
15:53:59 <foozbaz> nooodl: Twey: actually, yeah, the lists don't have the same type .. that's why i need tooples..
15:54:14 <foozbaz> did i just spell tuples tooples? .. yikes.
15:54:14 <Tordek> thanks for the awesome explanations, people!
15:54:29 <Tordek> foozbaz: blame nooodl :P
15:54:30 <Twey> foozbaz: An HList is basically a generic n-tuple
15:54:36 <ski> issam : if you have `substExpr', then `substAll' isn't that hard (the hardest part is probably figuring out what it's supposed to do)
15:54:40 <foozbaz> Tordek:  :P
15:54:43 <nooodl> toooples
15:55:12 <ski> issam : anyway, you should just take what i say as suggestions, to explore as far as you find fun at the moment
15:55:22 <Twey> But again, your issue is getting from the runtime data to the compile-time type.  You can do this, but you'll forever more carry the uncertainty of which value you got around with you (until you eliminate it, anyway)
15:56:01 <issam> sure thanks!
15:56:12 <foozbaz> Twey: so... in the module, the type of the data will remain ambiguous
15:56:16 <johannesbodannes> is there an easier way to pattern match a substring at the beginning of a string than like... f ('h':'e':'l':'l':'o':xs) ?
15:56:34 <Twey> foozbaz: Yes; you'll need to talk about it as a typeclass, probably
15:56:40 <ski> issam : if the `mapExpr' of above sounds complicated, you could first consider the version `mapExpr :: (val0 -> val1) -> (Expr val0 -> Expr val1)' for the original `data Expr val = Val val | Add (Expr val) (Expr val) | Mult (Expr val) (Expr val)' which i imagined you had first
15:57:14 <Twey> johannesbodannes: View patterns: f (splitAt 5 → ("hello", xs))
15:57:33 <Twey> Or pattern guards, equivalently
15:57:34 <foozbaz> Twey: but ultimately, these tuples are going to be arguments to fmap'ped over; so in my user-code they'll have unambiguous types specified by the second argument to fmap
15:57:53 <johannesbodannes> Twey: thanks
15:58:02 <issam> ski, yep that sounds easier :)
15:58:54 <Twey> foozbaz: At which point you'll get a type error (I think you'll also have some difficulty defining a sane fmap for such a type)
15:59:06 <foozbaz> Twey: totally alternate solution to my problem would be to pass the arguments in to the fmap function one-at-a-time, avoiding the need to create these tuples in the first place
15:59:12 <ski> > let f (stripPrefix "hello" -> Just xs) = xs in f "hello there"
15:59:15 <lambdabot>  " there"
15:59:22 <ski> johannesbodannes ^
15:59:30 <foozbaz> Twey: but this only works if functors support zipping ..
15:59:35 <foozbaz> blaah... :(
15:59:36 <nooodl> wow i was thinking about a function like "stripPrefix" and turns out it exactly exists
16:00:11 <Twey> Is that new?
16:00:17 <ski> i don't think so ?
16:00:26 <ski> .. in Mercury one'd just say `f("hello" ++ Xs) = Xs.'
16:00:32 <Twey> Huh… could've used that one before
16:00:33 <bennofs> @index stripPrefix
16:00:33 <lambdabot> bzzt
16:00:41 <bennofs> seems lambdabot-specific
16:00:42 <Twey> ski: I'm not sure whether that's a point for or against Mercury
16:00:52 <Twey> Sounds a lot like n+k patterns
16:00:55 <nooodl> turns out it's just in Data.List!
16:01:02 <ski> (also in Erlang (more or less) -- though in Erlang it's a special case; while in Mercury, it's a general language feature)
16:01:03 <bennofs> @hoogle stripPrefix
16:01:04 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
16:01:04 <lambdabot> Data.Text stripPrefix :: Text -> Text -> Maybe Text
16:01:04 <lambdabot> Data.Text.Lazy stripPrefix :: Text -> Text -> Maybe Text
16:01:18 <foozbaz> Twey: fzipWith :: (a -> b -> c) -> f a -> f b -> f c
16:01:20 <ski> Twey : there's just a single definition of `(++)/2'
16:01:33 <foozbaz> Twey: i think i'm set..
16:01:35 <Twey> Oh, right, Mercury has backtracking
16:01:43 <ski> it's not about backtracking here
16:02:00 <ski> it's about supporting multiple *modes* for functions (and predicates)
16:02:14 <Twey> Aye
16:02:15 <ski> so that you can run them "forwards" and "backwards" and "side-ways"
16:02:23 <foozbaz> Twey: Tordek: nooodl: Thanks for your help! A little brainstorming always gets me unstuck..
16:02:26 <Twey> But it wouldn't make much sense in the general case without backtracking support
16:02:43 <Twey> :t liftA2
16:02:44 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:02:57 <Twey> foozbaz: I'm pretty sure your fzipWith would make every Functor an Applicative
16:03:07 <Twey> Where did that come from?
16:03:39 <ski> well, in the case where there's multiple solutions, one'd want the language to be able to compute those multiple solutions (either by backtracking, or OR-parallelism, or bottom-up evaluation, or perhaps something else), sure
16:03:53 <ski> but even for the "at most one solution" case, it's quite useful
16:04:32 <Twey> Agreed; it's a nice feature to have
16:04:57 <foozbaz> Twey: I haven't checked it out thoroughly yet; It's just that I forgot there was another approach to my problem.. got it from Control.Functor.Zip
16:05:15 <bennofs> @hoogle fzipWith
16:05:16 <lambdabot> No results found
16:05:27 <rose> can someone spot the problem with my recursion here? http://stackoverflow.com/questions/20713744/bug-in-recursively-building-mongodb-selection
16:06:53 <foozbaz> bennofs: Twey: in category-extras
16:08:17 <bennofs> foozbaz: You probably don't want to use that
16:08:26 <bennofs> Maybe Applicative works for you?
16:08:31 <bennofs> @ty liftA2
16:08:33 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:09:22 <bennofs> foozbaz: Or, you can also find fzipWith in the keys package
16:11:30 <merijn> Anyone have any style recommendations or other comments/criticisms for this code? http://lpaste.net/8245850421021638656
16:11:45 <merijn> Especially a nicer way to write the type signature on line 32 would be welcome
16:13:02 <mm_freak> merijn: multi-line it
16:13:14 <mm_freak> Abc (Def,
16:13:17 <mm_freak>      Ghi)
16:13:33 <merijn> mm_freak: Yeah, I was just unsure on what a good linewrapping method is for single types
16:13:48 <merijn> I never ran into a type that ridiculously long before
16:13:57 <mm_freak> you can indent at argument boundaries and at parens
16:14:02 <mm_freak> Abc X
16:14:04 <mm_freak>     Y
16:14:44 <foozbaz> bennofs: i'm not familiar with liftA2 ..
16:15:48 <ski> rose : did you mean to use `selector' in both branches in `tagsSelector' ?
16:16:32 <merijn> Comments on the readability of 'session' are welcome too
16:17:09 <foozbaz> hm..
16:17:26 <mm_freak> merijn: see my annotation
16:18:10 <mm_freak> merijn: your 'session' is quite readable
16:18:21 <merijn> mm_freak: Yeah, that type is definitely better
16:18:32 <rose> ski: sorry, the error is still relevant. I replaced selector with [] when I was playing around with the function, but the error remains when I replace [] with selector
16:19:44 <danilo2> Hello :) I'm doing some black magic in Haskell (for my DSL, which generates Haskell code) and I want to ask you, why following code fails to compile: http://lpaste.net/97298 ? The problem is with instance resolution and function "test2". I typed every line, but type inferencer still cannot find the right types for it.
16:21:21 <ski> rose : what is the failure if you replace the `[]' (the expression, not the pattern) in `tagsSelector' with `selector' ?
16:21:42 <Cale> danilo2: Did you read the type error completely?
16:22:36 <ski> (btw, instead of `(pack "text") =: (pack "hey")' and `(fieldToText Tags) =: "city"', you can say `pack "text" =: pack "hey"' and `fieldToText Tags =: "city"')
16:23:11 <rose> ski: good question, I updated the question
16:23:36 <danilo2> Cale: Right now I saw what happened. I'm feeling really sorry for that - I had to accidentaly delete instance "Bind Pure IO IO". Thanks and sorry once again.
16:23:38 <Cale> danilo2: It can't decide whether you want the  Bind IO Pure IO instance or the Bind IO IO IO instance in the first bind.
16:23:49 <Cale> No worries! :)
16:24:08 <danilo2> Cale: after defining "Bind Pure IO IO" it works :)
16:24:45 <Cale> danilo2: Well, what about the first error?
16:25:24 <ski> rose> merge [pack "text" =: pack "hey"] [pack "text" =: pack "there"]
16:25:49 <danilo2> after defining "instance Bind Pure IO IO where bind = ($)" there is no error. Because of the first error I was a little confused,m because it is not logical
16:26:19 <danilo2> Cale: look at the annotation: http://lpaste.net/97298 . It just works
16:29:31 <Twey> Can anybody better at Foreign than I am see what I'm doing wrong here?  http://lpaste.net/97301  I seem to be getting random values out of it, even for the same position, which makes me think I'm mismanaging the pointer somehow
16:30:44 <ski> (rose : in case that wasn't clear, that was intended as a question)
16:30:49 <Twey> readPixels is from OpenGL, and is supposed to read a block of n (eight-bit) values into the given pointer
16:32:07 <rose> ski: aha! [ text: "hey"]
16:32:40 <ski> ok, so it seems `merge' (whatever it's supposed to do) isn't doing what we thought it would do here
16:34:12 <ski> perhaps you can make `tagsSelector' build a list with elements like `pack x =: pack x' for every element `x' of the `tags' list, and then call `merge' (with `[]' as one argument) only *once* on the resulting list ?
16:34:43 <erisco> what existing memoising techniques can I look at if I need to thread a memo table through my computation? I cannot see how I can use the technique present here: http://www.haskell.org/haskellwiki/Memoization
16:35:16 <ski> rose : it also might be that i (or you, or both of us) are misunderstanding what `tagsSelector' is supposed to do, or what the proper use of `merge' is ..
16:35:17 <solrize> @hoogle evaluate
16:35:18 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
16:35:18 <lambdabot> Control.Exception evaluate :: a -> IO a
16:35:18 <lambdabot> Control.OldException evaluate :: a -> IO a
16:35:25 * ski knows nothing about `mongodb'
16:35:56 <merijn> solrize: ಠ_ಠ
16:36:03 <rose> ski: It works now. Thank you
16:36:09 <ski> np
16:36:14 <solrize> merijn ?
16:36:32 <sbm> I'm looking for a function like sortBy, but where the comparison function returns the Ordering inside a monad. Any ideas?
16:36:49 <sbm> also useful would be a way to make my own version without writing my own sort function
16:37:42 <ski> seems like there could be many different variants of that, calling the comparision actions in different orders, ior on different elements
16:37:49 <merijn> solrize: 'evaluate' is always worth frowning at somebody :p
16:37:56 <sbm> hoogling (a -> a -> m a) -> [a] -> m [a] didn't help
16:38:31 <pavonia> @hackage monadlist
16:38:31 <lambdabot> http://hackage.haskell.org/package/monadlist
16:38:40 <ski> (if the monad was "commutative", it would be somewhat nicer, i suppose)
16:38:50 <solrize> i want to time how long it takes to calculate something
16:38:52 <solrize> timeit :: (() -> a) -> IO Double
16:38:52 <solrize> timeit p = do
16:38:52 <solrize>   t0 <- getCPUTime              -- cpu time in picoseconds
16:38:52 <solrize>   a <- evaluate (p ())
16:38:52 <solrize>   t1 <- getCPUTime
16:38:53 <solrize>   let dt = t1 - t0
16:38:57 <solrize>   return $ fromIntegral dt * 1e-12
16:38:59 <solrize> look ok?
16:39:15 <solrize> actually need strictness
16:39:19 <solrize> a`seq`dt
16:40:09 <ski> perhaps you want `rnf', perhaps you want to use a particular strategy of forcing ..
16:41:45 <solrize> hmm
16:42:49 <merijn> solrize: Have you looked at criterion?
16:42:53 <merijn> @hackage criterion
16:42:54 <lambdabot> http://hackage.haskell.org/package/criterion
16:42:59 <pavonia> solrize: Why "() -> a" and not just "a"?
16:43:10 <merijn> pavonia: To avoid sharing
16:43:16 <solrize> oh that's a a good point, i should use criterion, i knew about it but didn't think of it
16:43:24 <pavonia> ah
16:43:29 <solrize> pavonia i want to do the calculation in a loop
16:43:33 <solrize> i gotta run an errand, back later
16:45:38 <sbm> i guess more generally, how can you use an (a -> m b) function where an (a -> b) function is needed, if the overall result is still within the monad m?
16:45:52 <shachaf> You can't.
16:46:17 <pavonia> sbm: Have you seen my hackage link above?
16:46:38 <gamegoblin> I have a package with a lot of modules. There are a few modules that get a lot of high usage. Is there a way I can make a single import, say called "Core" which exports all of their functionality in one?
16:47:01 <shachaf> A module can re-export things from other modules.
16:47:10 <shachaf> It can't export qualified modules.
16:47:24 <sbm> :pavonia perfect, thanks!!
16:47:45 <sbm> hah, too much ghci
16:49:14 <ski> sbm : if you have `m (a -> b)' instead, it could work
16:49:19 <merijn> gamegoblin: You can reexport entire modules
16:49:31 <merijn> gamegoblin: "module Foo (module Foo.Bar) where ..."
16:49:39 <merijn> gamegoblin: That will reexport everything from Foo.Bar
16:49:52 <sbm> ski: right, i'm actually looking for http://hackage.haskell.org/package/monadlist-0.0.2/docs/src/Control-Monad-ListM.html#sortByM
16:50:17 <sbm> ski: looks like there was no way around rewriting everything...
16:51:03 <gamegoblin> thanks
16:55:11 <shachaf> (The answer is xor, by the way.)
16:59:56 <ski> (`sortBy' doesn't contain enough information to recover `sortByM', though the source of it would in some sense be enough)
17:00:01 <subtlearray> Hello Haskell IRC. I'm trying to create an offline mirror of Hackage in case I ever lose Internet access again. I've tried various shell scripts from Github (update-package.sh, hackage-mirror.sh, mirror-hackage.py), but they all return syntax errors. Are there any other options available?
17:01:27 <subtlearray> @help
17:01:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:01:45 <subtlearray> @help foldr
17:01:45 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:01:50 <subtlearray> list
17:01:53 <subtlearray> @list
17:01:53 <lambdabot> What module?  Try @listmodules for some ideas.
17:02:03 <enthropy> you can also /msg lambdabot @listmodules
17:02:26 <enthropy> if you lose internet access, I think you can still cabal install packages you've cabal installed before
17:02:28 <geekosaur> I don't see why hackage-mirror.sh would return a syntax error
17:02:38 <geekosaur> unles syou're doing something silly like trying to feed it to runhaskell
17:02:49 <enthropy> hs,sh: same thing
17:03:03 <dcoutts_> enthropy: and there's cabal fetch to pre-download stuff you'll need for later
17:03:19 <erisco> I am trying to cobble together memoisation by threading a memo table through the computation. I do not understand why my fib still has exponential behaviour http://lpaste.net/97302
17:03:32 <subtlearray> geekosaur, of course not. :P I tried thsoe scripts in 2 different Linux distros with the following command: sh hackage-mirror.sh
17:03:53 <enthropy> mgsloan: do you like doctest, or should the examples go somewhere else?
17:04:21 <alpounet> erisco: I think this is an excellent occasion for learning to profile haskell programs if you don't know how to do that yet
17:04:26 <enthropy> subtlearray: you might try  bash hackage-mirror.sh
17:04:35 <alpounet> i you do, then you'll figure out
17:04:42 <erisco> alpounet, I do not find ghc tracing useful
17:05:28 <alpounet> erisco: not tracing. actual profiling, with pretty graphs, useful statistics and everything! http://book.realworldhaskell.org/read/profiling-and-optimization.html :)
17:05:40 <subtlearray> @enthropy: I'll try it now.
17:05:40 <lambdabot> Unknown command, try @list
17:05:58 <subtlearray> @[1..10]
17:05:58 <lambdabot> Unknown command, try @list
17:06:08 <enthropy> @run [1 .. 10]
17:06:11 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
17:06:16 <subtlearray> Ah. @run [1..10]
17:06:21 <subtlearray> Wait...
17:06:26 <subtlearray> @run [1..10]
17:06:28 <enthropy> > [1 .. 10] -- what people actually do
17:06:29 <lambdabot>  can't find file: L.hs
17:06:29 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
17:06:38 <subtlearray> [1..10]
17:06:40 <shapr> OH HAI
17:06:44 * shapr boings cheerfully
17:07:03 <subtlearray> Bah! Anyway. Back to trying to get this hackage mirror script to work. Going to try using bash instead of sh.
17:08:23 <geekosaur> the scripts of that name that I am finding on github should work with any POSIX /bin/sh
17:08:37 <geekosaur> hm, actually maybe not; I think POSIX backed off on [[ ]]
17:09:10 <geekosaur> but https://gist.github.com/Voker57/562813 uses [ ] which should work anywhere
17:09:34 <geekosaur> and [[ ]] shouldn't be a syntax error, just a command not found
17:09:38 <osa1> woo pattern matching against Word values using hexadecimal notation works <3 <3
17:09:47 <subtlearray> entropy: Using bash got it started, but it's returning 404: Not Found errors. I'll try one of the other scripts with bash.
17:09:51 <ski> erisco : hm, reminds me of my "repaste of PoorManDebug" at <http://lpaste.net/10060> ..
17:10:13 <erisco> ski in what way?
17:12:15 <ski> hm, in the sense that they're both "instrumentations", i suppose
17:12:44 <ski> not sure whether one could make the similarity more existant
17:13:38 <subtlearray> [1 .. 10]
17:13:44 <subtlearray> @[1 .. 10]
17:13:44 <lambdabot> Maybe you meant: wn v rc pl id do bf @ ? .
17:13:59 <dang> is there any way to add a type constraint on an aliased monad transformer?
17:14:10 <danilo2> Hello :) I'm doing some black magic in Haskell (for my DSL, which generates Haskell code) and I want to ask you, why following code fails to compile: http://lpaste.net/97303 .
17:14:11 <danilo2> What is intresting, If I write manually the type signature of (test2 :: IO [Int]) it compiles and If I misstype it (like: test2 :: Pure [Int]) it gives me error : Couldn't match type `IO' with `Pure'), so it should be able to infer that type, shouldnt it?
17:14:17 <erisco> ah I know the problem
17:14:33 <enthropy> M.empty is the problem
17:14:45 <dang> i know how to do it with GADTs, but those don't seem to let me derive Monad, MonadPlus... the same way I could when I used the newtype
17:14:48 <erisco> no I don't merge t with t' in find
17:15:03 <subtlearray> Don't mind my random attempts to get lambdabot to reply. I've been trying to download Hackage for the last 2 hours and doing something other than that is distracting me from the headache I got.
17:15:13 <dang> but if i stick with the newtype, i dont see a way to add the type constraints (so that my functions using the transformer don't need to repeat the constraints)
17:15:15 <erisco> which means I am not carrying my results over to the other recursion site
17:15:43 <ski> erisco :  t  is unused in the latter branch of `find'
17:15:51 <shachaf> subtlearray: Random attempts are best for /msg
17:15:57 <ski> erisco : *nod*
17:16:19 <erisco> okay now it works :)
17:16:23 <shachaf> Questions (like: "how do i evaluate this haskell code?", to which the answer is: "> [1..10]") can be in here, though.
17:16:26 <enthropy> erisco: no, t1 does get used in the form of t2
17:16:50 <ski> enthropy : look at `find'
17:16:51 <erisco> enthropy, in the "find" function I do not merge t with t' in the "otherwise" branch
17:17:43 <enthropy> odd since my annotation http://lpaste.net/97302 seems to do the right thing
17:18:18 <enthropy> besides the Int overflow
17:18:25 <erisco> enthropy, hm maybe that variation works too
17:18:47 <erisco> enthropy, I added an annotation with what I intended
17:19:19 <erisco> now I just need to devise a more robust interface
17:19:29 <enthropy> erisco: you know you can do     | Just e <- M.lookup k m = ...
17:19:55 <erisco> enthropy, no I did not
17:20:00 <enthropy> that way there's no fromJust
17:20:08 * hackagebot github 0.7.3 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.7.3 (JohnWiegley)
17:20:13 <erisco> I have not seen that syntax before
17:20:14 <enthropy> or otherwise rearrange stuff so you don't have to lookup the same thing twice
17:20:34 <enthropy> Map.member basically has to find the element in the map
17:20:58 <erisco> enthropy, yes I am aware it does the lookup twice but preferred the brevity
17:20:59 <enthropy> this is just a micro-optimaztion
17:21:04 <erisco> your syntax appears to work though, so thanks
17:21:23 <subtlearray> Has anyone here successfully been able to download Hackage? Do these scripts still work for anyone? https://github.com/luite/hdiff // https://github.com/jamwt/mirror-hackage // https://github.com/eccstartup/setup-haskell-mirror
17:21:37 <enthropy> it's about the same as    case Map.lookup k v of Just v -> ...; Nothing -> ...
17:22:35 <dang> for example:  newtype T a = T { runT :: ReaderT (Params b) IO a } deriving (Monad, MonadIO, ...)   works with GeneralizedNewtypeDeriving on.
17:23:13 <dang> but the same idea using a data declaration and GADTs does not, so it seems impossible to add type contraints (in the example, I need to constrain 'b')
17:23:31 <geekosaur> luite's scripts definitely require bash, not merely a POSIX shell like dash (which is /bin/sh on many Debianoids)
17:24:24 <geekosaur> and those *will* get syntax errors from a POSIX shell
17:24:55 <subtlearray> bash hackage-mirror.sh returns "index.tar.gz: Cannot open: No such file or directory" // bash update-package.sh returns "not a package." I assume it's needs to know which packages I want. // And the Python script using "python2 mirror_hackage.py" fails while downloading the log.
17:25:38 <enthropy> danilo2: enable the -XNoMonomorphismRestriction as the error suggests
17:25:45 <subtlearray> geekosaur: So I should try to use a non-POSIX shell?
17:25:51 <geekosaur> ...
17:25:57 <enthropy> or re-write your (~:) = liftf2 (:) to    x ~: y = liftf2 (:) x y
17:25:57 <geekosaur> POSIX is the baseline
17:26:10 <geekosaur> you need a specific POSIX-plus-extensions shell. that specific shell is bash.
17:26:19 <geekosaur> which is why the scripts all start with #! /bin/bash
17:26:20 <ski> dang : where is `b' bound ?
17:26:26 <geekosaur> instead of #! /bin/sh
17:26:37 <dang> ski: it's not in the example, but it should be
17:26:41 <geekosaur> if you run them with `sh` you are not guaranteed to be running them with bash
17:26:47 <geekosaur> not even on linux
17:27:00 <dang> from what I understand, puting Eq b => ... somewhere in the newtype declaration gets me nothing (if it's even legal)
17:27:02 <enthropy> subtlearray: do you have curl installed? The https://github.com/eccstartup/setup-haskell-mirror/blob/master/hackage-mirror.sh needs it
17:27:09 <geekosaur> because debian and debian-derived systems (ubuntu, mint, etc.) likes to use dash as /bin/sh
17:27:37 <dang> ski: i'm looking for ability to omit the constraint in function signatures (like I could if I constrained the constructor in a GADT)
17:27:49 <subtlearray> enthropy: I don't know what curl is, but I'll look it up now.
17:27:54 <ski> dang : i'm still not sure where `b' is bound ..
17:29:43 <subtlearray> enthropy: Using Ubuntu. Installed curl with sudo apt-get install curl. hackage-mirror.sh is now working. Thank you very much for your help.
17:29:54 <dang> ski: how about this: data T a where // T :: Eq b => { runT :: ReaderT (Param b) IO a } -> T a
17:30:38 <dang> ski: that works fine, but I don't see a way to then derive all of the necessary monad instances so that T can be used as a monad transformer
17:31:39 <dang> ski: standalone deriving complains (I presume) because i didn't use a newtype
17:31:58 <danilo2> enthropy: I've enabled it before, it does nto change the main source of the problem. Here is the updated version: http://lpaste.net/97303 . Still, when I manually type signature of (test2 :: IO [Int]) it wors and if I misstype it like (test2 :: Pure [Int]) I get error "Couldn't match type `IO' with `Pure'"
17:33:59 <dang> ski: just understood your question... there's an implicit forall b. in the gadt definition
17:34:07 <ski> dang : in that case, it's shorthand for `data T a where T :: forall b. Eq b => { runT :: ReaderT (Param b) IO a } -> T a', so iow it's an "existential datatype"
17:34:38 <ski> and in GHC, those can't be `newtype', has to be `data'
17:34:39 <danilo2> enthropy: I completely do not understand why GHC cannot infer this type without providing it manual if it could infer it when I misstype it.
17:35:11 <ski> in case there were no contraint on `b', then it could possibly be `newtype', (though GHC currently conservatively doesn't allow it)
17:35:20 <dang> ski: that makes sense... but is there a way to turn 'data' into a monad transformer?
17:35:26 <ski> but if there is, it can't be `newtype' (at least in general)
17:35:27 <enthropy> danilo2: the recursion you did is the problem
17:35:58 <ski> dang : what is `Param' ?
17:36:24 <dang> ski: a record with environment bindings
17:36:34 <ski> a GADT ?
17:36:50 <enthropy> you could come along and write a   instance Bind M M M; instance Bind IO M M -- etc. then how is test2 going to be IO Int instead of M Int?
17:36:51 <dang> data Param a = Param { x :: a, ... }. not a GADT
17:37:03 <ski> where `...' also mentions `a' ?
17:37:12 <dang> yes.
17:37:19 <danilo2> enthropy: I know. But why is it a problem? GHC can see, that "print" is in IO, then there is "bind" function used with "Pure" variable, so we get "IO" again, etc - it is **impossible** to infer other way. Additional GHC is able to do it - if you misstype it - it knows, there should be IO :(
17:37:29 <ski> .. negatively ?
17:37:48 <dang> ? I'm not sure what you mean.
17:37:55 <danilo2> enthropy: Normally It would be ok to type the signature manually, but I'm generating code and I do not want to generate it also
17:38:07 <joneshf-work> why is it that Data.Map isn't an Applicative?
17:38:19 <ski> in `Maybe a -> Maybe b', `a' is mentioned negatively/contravariantly, and `b' is mentioned positively/covariantly
17:38:38 <enthropy> danilo2: instances don't get selected because "that's the only type that could work given the instances in scope"
17:38:43 <ski> while in `(a -> Bool) -> Bool', `a' is mentioned positively/covariantly (though not "strictly positively")
17:38:45 <triliyn> joneshf-work: I think because you can't write <*> without introducing an Ord constraint
17:38:47 <joneshf-work> ski, oh hey! long time
17:38:55 <triliyn> Which doesn't match the required type for applicative
17:38:56 <ski> hiya joneshf-work
17:39:02 <lpsmith> I'm studying some ghc-core,  and noticed that with 7.6.3,  bytestring constants get wrapped in  a (pack . unpack) bit;  does this get optimized away at a lower level,  or does every constant get unpacked and re-packed once?
17:39:08 <joneshf-work> triliyn, hmm
17:39:15 <enthropy> danilo2: if you can avoid using print at the end, which will fix the type to IO it works just fine
17:39:21 <enthropy> ie.  main = test2
17:39:35 <danilo2> enthropy: Hmm, but Is it possible to even write another monad, which would work there? I mean - there is "rpint" function, which tells, it is working in IO.
17:39:37 <dang> ski: yes, it is used in Params to paramatrize a nested record, which itself uses a negatively
17:39:41 <ski> dang : possibly the pos/neg thing doesn't matter here, i was just curious
17:39:47 <shachaf> lpsmith: Are you compiling with full optimizations?
17:40:01 <lpsmith> shachaf, ghc-core -- -O2 test.hs
17:40:02 <enthropy> dang: I get a    test2 :: :: (Lift2 Pure m3 m1, Bind IO m2 m3, Bind Pure m1 m2) => m3 [Int]
17:40:04 <shachaf> (pack . unpack) sounds kind of surprising.
17:40:11 <ski> (the nested record only uses `a' negatively ? or positively as well ?)
17:40:19 <shachaf> You could look at a lower level, to see if they're still there, I guess?
17:40:20 <enthropy> err, danilo2
17:40:27 <shachaf> Like at the Cmm.
17:40:38 <lpsmith> shachaf, well not literally (pack . unpack),  but the equivalent of
17:40:47 <danilo2> enthropy: hmm, ok, I think I'm starting to feel that it somehow could be possible - I have to rething it again, but - do you think would closed type families allow me to solve the problem? I mean - create some "closed" sets of types to choose from ?
17:41:04 <shachaf> Well, I'd be less surprised about some similar things.
17:41:10 <shachaf> Do you have your code somewhere?
17:41:25 <dang> ski: one of the fields is of type [a] (i guess that's positive?). don't understand your test2
17:42:00 <enthropy> danilo2: I don't think that offers you anything more than you can get from overlapping instances
17:42:11 <ski> dang : anyway, in effect, a value of type `T a' conceptually (in the dictionary-passing implementation) consists of two things : (a) a value of type `ReaderT (Param b) IO a'; (b) a( dictionary for a)n instance `Eq b'; both these for some common unknown type `b'
17:42:21 <dang> enthropy: not sure what that signature is referring to...
17:42:26 <enthropy> supposedly ghc-7.8 has the -XIncoherentInstances being more eager
17:42:33 <enthropy> dang: sorry, this is for danilo2
17:43:12 <shachaf> lpsmith: OK, if it's something like unsafePackLenBytes (length xs) xs then I'm not too surprised.
17:43:46 <shachaf> Of course, it's possible you're using Data.ByteString.Char8, which would make me sad. :-(
17:45:01 <enthropy> danilo2: at the bottom I have instances for a different X type that is acceptable: http://lpaste.net/97303
17:45:02 <dang> ski: that seems like it could be a monad transformer...
17:45:04 <ski> dang : in the dictionary-passing implementation, `GeneralizedNewtypeDeriving' is implemented by treating the values of the `newtype' type as being just values of the (single) argument of the constructor
17:45:08 <ski> dang : this enables one to convert from `Tree [String -> Maybe (T a)]' to `Tree [String -> Maybe (R a)]' (and vice versa), assuming we had `newtype T a = TfromR (R a) deriving Foo', so that we can just reuse the `Foo' instance (dictionary) for `R' as the one for `T'
17:45:12 <mx`> hello
17:46:18 <ski> dang : in case a `T a' value consists of both an `Eq b' instance and an `R b a' value (for some unknown type `b'), we couldn't do this automagic "O(0)" conversion, and so we can't reuse dictionaries just like that
17:46:33 <ski> (at least not in general)
17:47:08 <mx`> can I somehow avoid this hell of nested cases?   http://lpaste.net/97309
17:47:43 <shachaf> mx`: Perhaps you want MaybeT.
17:47:46 <danilo2> enthropy: Sorry, my internet connection went down for a while. I'm installing GHC 7.7 right now to check the closed type families and your suggestion
17:47:56 <shachaf> @src MaybeT
17:47:56 <lambdabot> Source not found. :(
17:48:32 <shachaf> Well. MaybeT m a = m (Maybe a), but with a short-circuiting monad instance.
17:48:40 <dang> ski: I think I follow. seems like the constraint breaks some symmetry. does that mean by only options are to manually derive all instances, or add the constraint to all functions in the monad?
17:48:42 <mx`> shachaf if that lets me mix Maybe a and IO (Maybe a) in a single do block then it is just what i want
17:50:23 <mx`> or is that just wishful thinking?  :). reading about it now, I never used transformers, and don't even know what they are
17:50:59 <danilo2> enthropy: I do not know if is it possible to write such overlapping instances to fix my problem (and because of that I was thinking about these closed famielies). I'll check it out. In the GHC 7.7 log there are some informations, that IncoherentInstances are more eager. I'll check it out and if you do not mind, I'll be back with results
17:51:04 <shachaf> It isn't too wishful.
17:51:19 <shachaf> MaybeT might be slightly awkward but it could work well in your case.
17:51:25 <enthropy> danilo2: try: instance (IO ~ io) => Bind IO io IO where
17:51:26 <ski> dang : i suppose if the argument of the type class in question only occured in the method signatures in negative and positive positions where one could use `fmap' (functors) to translate, that could be a way out .. hm
17:52:03 <mx`> thanks I'll give it a try
17:52:15 <ski> dang : not sure what you mean by "add the constraint to all functions in the monad"
17:52:33 <enthropy> if you add the other one: instance (IO ~ io) => Bind io IO IO where, you need incoherent instances but maybe this accepts all the cases you have in mind
17:52:35 <dang> ski: *using the monad transformer
17:52:44 <enthropy> for combinations of IO/Pure/whatever else
17:53:20 <enthropy> danilo2: but since you're generating this code, you probably have better options for what to compile to
17:54:03 <dang> ski: instead I would have type T b = ReaderT (Params b) IO
17:54:30 <danilo2> enthropy: I'll try it right now. I do not have better options - I'm generating this code for an user input - and user can define "functions", that can use IO or can be pure and I would love to support such usee case using Haskell's type inferencer :)
17:54:32 <ski> oh, parameterize `T' by `b'
17:54:39 <dang> ski: and change f :: a -> T a   to   f :: Eq b => a -> T b a
17:54:52 <dang> ski: yes, sorry for missing that detail
17:54:53 <ski> well, that wouldn't be the same thing
17:55:08 <joneshf-work> triliyn, I don't follow, why would <*> need Ord?
17:55:39 <ski> your `f :: a -> T a' would correspond to `f :: a -> exists b. Eq b *> T b a', not to `f :: a -> forall b. Eq b => T b a' (which is what your latter version really meant)
17:55:47 <dang> ski: i don't see the difference in intent... now i have (T b) as a monad transformer
17:56:07 <triliyn> joneshf-work: for maps, it would need Ord because you can't produce a map of things without ordering them (unless you break the abstraction and deal with the tree directly)
17:56:18 <ski> (if `T a' was an input type of `f', it would be different)
17:56:40 <ski> (s/an input type/a type of an input/)
17:56:44 <danilo2> enthropy: It works! thank you!. Hmm I should have though about it :)
17:57:31 <shachaf> *> looks too directional. The > in => comes from being like ->
17:57:37 <shachaf> Perhaps =*
17:58:02 <shachaf> Well, that is silly.
17:58:16 <erisco> I broke it again :( http://lpaste.net/97311
18:00:07 <erisco> in my attempts to massage it into an interface closer to applicative
18:00:33 <rose> could anyone familiar with haskell and mongodb answer this question? http://stackoverflow.com/questions/20714576/mongodb-selecting-two-values-for-one-field
18:00:35 <mm_freak> a discussion with my friend raised a very interesting question
18:00:35 <shachaf> @let data c *> a = c => Foo a -- does this have a name?
18:00:36 <lambdabot>  Parse failed: Illegal class assertion
18:00:46 <mm_freak> can one define elegance in a single sentence?  i found that very hard
18:01:11 <erisco> that would be an elegant definition
18:01:17 <mm_freak> =)
18:01:18 <erisco> huehehe
18:01:39 <mm_freak> i tried referring to harmony
18:02:00 <dang> ski: I'll admit to never fully understanding what leads to forall vs exists cases. In my actual use case, I just need to sort the 'b's in a deep leaf function. I'm looking for ways to avoid adding Ord b => ... to lots of parent functions.
18:02:04 <joneshf-work> triliyn, forgive my naivity, but don't you have to muck with the implementation when making an instance?
18:02:25 <joneshf-work> i wonder though
18:02:36 <triliyn> joneshf-work: I'm not sure
18:02:38 <joneshf-work> SOME Maps could be applicative right?
18:02:46 <joneshf-work> if they are Monoidal
18:02:47 <erisco> mm_freak, is there elegance without simplicity?
18:02:53 <joneshf-work> since htey would have the Ord constraint
18:03:05 <mm_freak> erisco: yes, i think so
18:03:10 <triliyn> Well, to use <*> at all, you need a map of functions
18:03:36 <mm_freak> erisco: it just happens that simplicity usually leads to elegance
18:03:59 <mm_freak> not always though…  i'm referring to "the rise of worse-is-better"
18:04:25 <lpsmith> I guess, more to the point, does anybody have some macro magic that can turn case x :: ByteString of  { "FOO" -> ... ; "BAR" -> ... ; _ -> ...}  into an efficient case analysis?
18:04:41 <shachaf> triliyn: A Map of functions is fine.
18:04:49 <shachaf> Map k (a -> b)
18:05:02 <triliyn> shachaf: hmm, you're right
18:05:07 <triliyn> I have no idea then
18:05:12 <shachaf> About what?
18:05:20 <triliyn> Why there is no Applicative instance
18:05:23 <shachaf> (<*>) is a red herring.
18:05:30 <shachaf> pure :: a -> Map k a
18:05:42 <shachaf> liftA2 :: (a -> b -> c) -> Map k a -> Map k b -> Map k c
18:05:47 <shachaf> No functions.
18:05:47 <triliyn> hmm
18:05:53 <triliyn> I see
18:05:58 <shachaf> Alternatively, mult :: Map k a -> Map k b -> Map k (a,b)
18:05:58 <triliyn> You can't invent keys in general
18:06:05 <mx`> shachaf I have to change the signatures of the maybe and maybeIO to work with MaybeT monad?
18:06:08 <joneshf-work> is that what it is?
18:06:19 <shachaf> mx`: You can do it at use site.
18:06:23 <triliyn> (Or maybe I'm wrong and it's something completely different)
18:06:35 <joneshf-work> how about if we're Monoidal
18:06:51 <mm_freak> simple ≠ elegant…  you can have simplicity without elegance (unix) and elegance without simplicity (free monads over StateT-transformed producers)
18:06:55 <joneshf-work> wait that doens't help doe it
18:07:23 <triliyn> joneshf-work: I think you could have something like Monoid k => Applicative (Map k)
18:07:32 <triliyn> Unless there is an additional problem I don't know about
18:07:39 <shachaf> triliyn: Well, there are the laws.
18:08:11 <joneshf-work> shachaf, Applicative laws or Monoid laws are the issue?
18:08:54 <shachaf> The Applicative laws.
18:09:03 <shachaf> You're consuming a Monoid instance and producing an Applicative instance.
18:09:12 <ski> @src Num
18:09:12 <lambdabot> class  (Eq a, Show a) => Num a  where
18:09:12 <lambdabot>     (+), (-), (*)           :: a -> a -> a
18:09:12 <lambdabot>     negate, abs, signum     :: a -> a
18:09:12 <lambdabot>     fromInteger             :: Integer -> a
18:09:15 <ski> @let data NumDict a = MkNum { plus_,minus_,times_ :: a -> a -> a,negate_,abs_,signum_ :: a -> a,fromInteger_ :: Integer -> a }
18:09:16 <lambdabot>  Defined.
18:09:17 <shachaf> The Monoid laws are working for you here. Without them there would be even less certainty.
18:09:21 <ski> @type \ab ba dict -> MkNum { plus_ = ab .: (plus_ dict `on` ba),minus_ = ab .: (minus_ dict `on` ba),times_ = ab .: (times_ dict `on` ba),negate_ = ab . negate_ dict . ba,abs_ = ab . abs_ dict . ba,signum_ = ab . signum_ dict . ba,fromInteger_ = ab . fromInteger_ dict }
18:09:22 <lambdabot> (b -> a) -> (a -> b) -> NumDict b -> NumDict a
18:09:45 <shachaf> @let import Data.Functor.Invariant
18:09:46 <lambdabot>  .L.hs:79:1:
18:09:46 <lambdabot>      Failed to load interface for `Data.Functor.Invariant'
18:09:46 <lambdabot>      Perhaps you meant
18:09:46 <lambdabot>        Data.Functor.Contravariant (from contravariant-0.4.4)
18:09:46 <lambdabot>        Data.Functor.Constant (from transformers-0.3.0.0)
18:09:50 <shachaf> Alas.
18:10:20 <mx`> > (MaybeT . return) (Just "foo")
18:10:22 <lambdabot>  Not in scope: data constructor `MaybeT'
18:10:22 <rose> Could anyone familiar with haskell and mongodb answer this question? http://stackoverflow.com/questions/20714576/mongodb-selecting-two-values-for-one-field
18:10:35 <mx`> why is this giving me ambiguous error?
18:11:10 <shachaf> What is its type?
18:11:17 <mx`> MaybeT (return (Just "foo")) :: Monad m => MaybeT m [Char]
18:11:31 <mx`> oh, it does not what type m is..
18:11:55 <mx`> this worked :).  MaybeT (return (Just "foo")) :: MaybeT IO [Char]
18:12:18 <ski> dang : in your `f :: a -> T a', given an input value of type `a', `f' will compute an output value of type `T a', which contains, for *some* *unknown* type `b' (which were are ensured will be in class `Eq', nonetheless), a value of type `ReaderT (Param b) IO a' -- note that in this case, `f' decides (possibly depending on the actual value of the input value) what the type `b' is to be
18:12:24 <mx`> I have to force myself to read error messages more carefully
18:12:56 <ski> dang : while for `f :: Eq b => a -> T b a', the *caller* of `f' (not `f' itself) gets to decide what `b' is : `f' promises to work regardless of what type `b' (in class `Eq') the caller chooses
18:14:14 <ski> dang : though, now that i think of it , i wonder whether you in fact wanted `data T a where T :: { runT :: forall b. Eq b => ReaderT (Param b) IO a } -> T a' rather than `data T a where T :: forall b. Eq b => { runT :: ReaderT (Param b) IO a } -> T a'
18:14:24 <ski> (there's a *huge* difference between those two)
18:14:48 <ski> the reason i wonder, is because `r' occurs negatively in `ReaderT r m a'
18:15:55 <ski> iow, in `ReaderT (Param b) IO a', `Param b' will be input, and so will `x :: b' inside that
18:16:24 <dang> ski : your first point (with f) makes sense. don't see how the location of the quantification / constraint on 'b' affects anything
18:16:54 <ski> so the question is when is `b' supposed to be chosen ? when `runT' is called (to *consume*) a value of type `T a' ? or when `T' is called to *construct* a value of type `T a'
18:17:35 <ski> well, consider a simpler case
18:18:39 <ski>   data Foo = forall a. Blah a => MkFoo ([a] -> Integer)
18:18:44 <ski> this is the same as
18:18:47 <ski>   data Foo
18:18:48 <ski>     where
18:19:06 <ski>     MkFoo :: forall a. Blah a => ([a] -> Integer) -> Foo
18:20:13 <ski> in this case, a value of type `Foo' contains a function that will take a list of *somethings* and give an integer, where we don't know what the type of the somethings is, except that it's in class `Blah'
18:20:17 <ski> otoh, consider
18:20:18 <erisco> I has fixed it
18:20:34 <ski>   data Bar = MkBar (forall a. Blah a => [a] -> Integer)
18:20:39 <ski> which is the same as
18:20:42 <ski>   data Bar
18:20:44 <ski>     where
18:20:58 <ski>     MkBar :: (forall a. Blah a => [a] -> Integer) -> Bar
18:21:42 <ski> here a value of type `Bar' contains a *polymorphic* function that will work for a list of elements of type `a', for *any* `a' the user wants (as long as it's in class `Blah')
18:22:03 <ski> in the `Bar' case, the user of a `Bar' value decides on what `a' should be
18:22:21 <ski> in the `Foo' case, the *maker* of a `Foo' values decides on what `a' should be
18:22:54 <ski> `MkFoo' is a polymorphic constructor, that happens to hide (/ forget) what the type of `a' is, yielding a result of type `Foo', where `a' has disappeared
18:23:18 <ski> `MkBar' is *not* a polymorphic constructor. it's a constructor which takes a polymorphic *argument*
18:23:25 <ski> *huge* difference
18:23:32 <ski> dang : does that make sense ?
18:24:33 <dang> ski : I think so. I'm passing a value of type Params b to runReaderT t, so I think the t :: T a should have been constructed to work for all b
18:24:57 <ski> dang : ok, then you probably want the `data T a where T :: { runT :: forall b. Eq b => ReaderT (Param b) IO a  } -> T a'
18:25:07 <ski> version, instead of the version you had
18:25:22 <ski> and now, like by magic, you *can* replace `data' by `newtype' :)
18:25:30 <dang> ski : er, right, I'm passing params to runReader (runT t)
18:25:31 <ski> so `GeneralizedNewtypeDeriving' will work here :)
18:26:38 <tommd>  
18:26:49 <dang> ski : just to be clear... newtype T a = T { runT :: forall b.  Eq b => ReaderT (Param b) IO a } deriving (Monad, ...) does what I want?
18:27:00 <ski> btw, functions (like the `MkBar' data constructor above) which take polymorphic arguments are sometimes known as "rank-2 typed functions"
18:27:29 <ski> dang : in case "the t :: T a should have been constructed to work for all b" is true, then i think so
18:27:36 <dang> ski : good to know, thanks. trying now
18:28:10 <Yxven> Is there a way to define a utility function in an instance? I'm trying to do what I want with let here, but it dislikes the let https://dpaste.de/pTsi
18:28:13 <mx`> wow MaybeT is amazing! look at the bottom how much cleaner my main became: http://lpaste.net/97309
18:28:57 <ski> mx` : s/(Just r)/Just r/
18:29:18 <mx`> don't I need it when pattern matching?
18:29:26 <alpounet> Yxven: you must already be in a function definition when using "let … in" (just like for where)
18:29:35 <scott_> mx`: Not in a case
18:29:39 <mx`> ah
18:29:43 <Cale> Yxven: I'd just lift it to the top level.
18:30:17 <mx`> any other improvements? :)
18:30:30 <Yxven> Thanks Cale and alpounet
18:31:23 <c_wraith> mx`: probably, I need to double-check something
18:32:20 <ski> mx` : yes, this is the kind of thing the `Maybe' monad (and that transformer) is meant for (cf. the first version of `r :: Maybe Record' at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>)
18:35:23 <ski> mx` : hmm
18:35:44 <mx`> yes? :)
18:36:04 <ski>   maybeIO1 :: Foo1 -> IO (Maybe Bar1)  -- ?
18:37:02 <c_wraith> I'm surprised MaybeT doesn't have a combinator for MaybeT . return
18:37:12 <dang> ski: newtype T a = T {run :: forall b. Ord b => ReaderT (Params b) IO a} deriving (Monad, MonadIO, MonadReader Params)
18:37:31 <dang> ski: throws "Can't make a derived instance of `Monad T'       (even with cunning newtype deriving):       cannot eta-reduce the representation type enough     In the newtype declaration for `T'"
18:38:14 <dang> ski : where i have stubbed in: data Params a = Params {x :: a}
18:38:23 <mx`> ski I am not sure I understand the question
18:38:38 <ski> mx` : is that or is that not the type of `maybeIO1' ?
18:38:59 <ski> dang : hrm
18:39:11 <mx`> ski no, the source of it is there in the first paste.. maybeIO1 :: String -> IO (Maybe String)
18:39:42 <ski> oh, i didn't notice the auxilary definitions :>
18:40:08 <ski> anyway, the answer to my question is "effectively yes" :)
18:40:20 <ski> so, instead of
18:40:22 <ski>   result1 <- lift (maybeIO1 foo1)
18:40:26 <ski>   result2 <- lift (maybeIO2 foo2)
18:40:32 <ski>   return (liftA2 (\r1 r2 -> r1 ++ " " ++ r2) result1 result2)
18:40:35 <ski> i think you could do
18:40:43 <ski>   result1 <- MaybeT (maybeIO1 foo1)
18:40:49 <ski>   result2 <- MaybeT (maybeIO2 foo2)
18:41:03 <ski>   return (return (result1 ++ " " ++ result2))
18:41:47 <ski> and, independently of this, you could move the `print' inside the `runMaybeT' block, so you'd last do, i think
18:42:02 <mx`> trying
18:42:07 <ski>   liftIO (print (result1 ++ " " ++ result2))
18:42:19 <mx`> then I wouldn't need join?
18:42:54 <ski> hm, didn't notice the `join'
18:43:12 <ski> but i don't see why you'd want to stage things with `join' here (though it can sometimes be used to good effect)
18:43:38 <mx`> result of runMaybeT is IO (Maybe (Maybe String))
18:44:01 <ski> yeah, i think you want it to be just `IO (Maybe ())'
18:44:17 <mx`> yes
18:45:07 <ski> (btw, i would probably indent the block after the latter `do' two spaces more than `result <- runMaybeT $ do', instead of twelve spaces more)
18:46:06 <ski> @type Control.Monad.Trans.Maybe.MaybeT . return
18:46:07 <lambdabot> Monad m => Maybe a -> Control.Monad.Trans.Maybe.MaybeT m a
18:46:57 <c_wraith> yeah, that's actually a useful bit.  It's a lift operation, from the other monad.
18:48:27 <ski> @type Control.Monad.Trans.State.StateT . (return .) . runState
18:48:28 <lambdabot> Monad m => State s a -> StateT s m a
18:48:42 <ski> @type Control.Monad.Trans.State.StateT . return .: runState  -- i suppose
18:48:43 <lambdabot> Monad m => State s a -> StateT s m a
18:48:52 <joneshf-work> shachaf, im sorry, I just dont see it
18:49:05 <mx`> ski cool, both of your suggetsions worked
18:49:32 <joneshf-work> shachaf, so no Map can be an applicative?
18:50:48 <mx`> this is my final version, at the bottom. compare to top main :).  http://lpaste.net/97309
18:51:10 <ski> dang : oh, now i see what it's complaining about
18:51:49 <mx`> void is not needed if I remove main's signature. now sure what's considered a better style
18:52:19 <ski> the first `do' can be omitted, and the first `$' can be replaced by `.' (looks nicer, imo)
18:52:37 <mx`> yeah I forgot to remove first do
18:53:02 * ski only now read the lint complaint
18:53:51 <merijn> mx`: main doesn't have to be IO ()
18:53:57 <c_wraith> mx`: it's good to give main a signature, because it having a signature that's not what you expect is often the result of a bug. But if you want it to be IO SomethingOtherThanUnit, it's fine
18:54:09 <merijn> mx`: The Haskell report states that any "IO a" signature is fine for main
18:54:40 <merijn> mx`: So if it results in a Maybe then "IO (Maybe ())" is perfectly fine
18:54:52 <shachaf> joneshf-work: Well. Presumably some Maps can.
18:54:54 <shachaf> Map () = Maybe (right?)
18:54:58 <ski> dang : if the class to be derived had taken an argument of kind `*' (iow a concrete type, rather than the type functions which `Monad' accepts as arguments), then this would have worked, i think
18:55:10 <mx`> merijin yeah, but with a signature adding void is arguably cleaner
18:56:12 <ski> dang : however, now it wants to rewrite the type `forall b. Eq b => ReaderT (Param b) IO a' into something of shape `(...) a', where `...' doesn't mention `a' (that's the "eta-reduce", which it's referring to), but that can't be done (at least not simply) :/
18:56:23 <joneshf-work> shachaf, I dont follow
18:57:45 <ski> hm, sortof it has to reinvent `Reader' by itself, in the deriving, to make it work
18:57:46 <dang> ski: but (...) doesnt mention 'a'
18:57:58 <triliyn> joneshf-work: a Map () Int can either associate () to some Int, or contain no associations
18:58:04 <ski> the problem is that it can't be written as `(...) a' in the first place
18:58:09 <ski> since
18:58:11 <ski>   forall b. Eq b => ReaderT (Param b) IO a
18:58:12 <ski> means
18:58:34 <ski>   forall b. (Eq b => (ReaderT (Param b) IO a))
18:58:45 <ski> which for completeness sake is really
18:58:51 <ski>   forall b. (Eq b => (((ReaderT (Param b)) IO) a))
18:59:04 <joneshf-work> triliyn, okay
18:59:15 <ski> the problem is that it is not of form "something (not involving `a') applied to `a'"
19:00:52 <dang> ski : got it. just thought that maybe my google queries were a bit too specific earlier when looking for solutions to this. now I found this: http://www.ittc.ku.edu/csdl/fpg/files/Sculthorpe-13-ConstrainedMonad.pdf
19:01:19 <dang> which is not specific to deriving transformers, but i think is tangentially relevant to my issue
19:01:34 <dang> *related
19:02:32 <dang> ski : I think the difference is that i'm not constraining a
19:04:05 <ski> afaiu, i don't think you need or want to constrain `a'
19:05:17 <ski> i'm atm pondering whether i could write the monad instance manually, or whether the problem is deeper than that (which would be that GHC just isn't smart enough to automatically figure out how to write it)
19:05:18 <dang> ski: no, but trying to with the same syntax (i think) causes the same issue
19:06:59 <dang> ski: newtype T a = T {run :: forall a. Ord a => ReaderT Int IO a} deriving (Monad, MonadIO, MonadReader Params)
19:07:04 <dang> ski: same error
19:07:32 <ski> i don't see any polymorphic components in that paper, just existentials (and GADTs)
19:08:07 <ski> (`PolymorphicComponents' being the name for the specific extension which allows rank-2 data constructors)
19:08:31 <ski> dang : i think it's a red herring
19:08:42 <dang> ski: very new to all of this (in case you can't tell). had no idea whether the paper was helpful. title looked promising
19:10:32 <ski> hm, realizing i can't write `instance (forall t. Monad (m t)) => Monad (All m)' since we don't have rank-2 instances .. :/
19:10:53 <ski> (or rather, realizing that's what i'd want in that experiment)
19:11:45 <ski> dang : i understand. i don't blame or complain, just saying that i think it doesn't help (/ isn't relevant) here, fyi
19:12:41 <ski> hm, perhaps it could work for particular `m's ..
19:13:40 * ski tries to think of a not-too-ridiculous case to try
19:14:23 <c_wraith> ski: is PolymorphicComponents actually limited, or is it just a stealth synonym for RankNTypes?
19:14:28 <mx`> thanks everyone for help! learned something new and awesome today
19:17:05 <dang> ski: sure. I need to run. in case you (or anyone else) is curious about the actual use case, see here: https://github.com/dangirsh/GeneticProgramming/blob/master/src/GP.hs  as I'm pulling more and more details into GPParams, I end up really needing to constrain GP. The overall goal is to have a genetic programming framework where as many interesting parameters as possible are abstracted over.
19:24:10 <ski> c_wraith : the former
19:24:28 <ski> ok, so :
19:24:46 <ski> ...> data AllContT m a = MkAC {unAC :: forall o. ContT o m a}
19:24:47 <erisco> why is Haskell insisting on all the brackets on line 17? http://lpaste.net/97314
19:24:56 <ski> ...> instance Monad m => Monad (AllContT m) where return a = MkAC (return a); MkAC coma >>= a_ACb = MkAC (unAC . a_ACb =<< coma)
19:24:59 <ski> works fine
19:26:00 <ski> (`ContT' could be replaced by `Cont' and `m' (and `Monad m => ') removed here, i just added them to make it more interesting. mutatis mutandis for `ErrorT' in the following)
19:26:08 <ski> ...> data ErrErrorT e m a = MkEE {unEE :: Error e => ErrorT e m a}
19:26:15 <ski> ...> instance Monad m => Monad (ErrErrorT e m) where return a = MkEE (return a); MkEE eema >>= a_EEb = MkEE (unEE . a_EEb =<< eema)
19:26:19 <ski> also works fine
19:26:37 <erisco> I presume it is giving "fib (n - 1)" higher priority
19:27:54 <ski> application has higher precedence than user-defined operators, yes
19:28:31 <ski> i wonder whether you could reword it so that it looks like
19:28:34 <ski>   fib n = ((+) <#> fib <.> fib) (n - 1) (n - 2)
19:28:48 <erisco> that is an interesting idea
19:28:51 <ski> (by changing definitions somewhat, obviously)
19:29:17 <erisco> ideally I'd like to create an ADT and remember that 'fib' is being used, instead of supplying it every time, but I have not been able to crack how
19:29:31 <meoblast001> "The channel #haskell on the freenode network is a great place to ask questions if you're feeling stuck."
19:29:35 <meoblast001> i don't know if i should trust this guy
19:29:56 <ski> depends on what topic the questions are about, i suspect
19:31:34 <ski> @tell dang if you want to whether there was anything interesting said after you left, you could try looking at <http://tunes.org/~nef/logs/haskell/13.12.20>
19:31:35 <lambdabot> Consider it noted.
19:32:35 <ski> the `<#>' and `<.>' operators reminds me of idioms (aka applicative functors)
19:32:58 <erisco> ski, the interface is very close, yes
19:33:16 <erisco> I have not been able to make it exact, though
19:34:35 <ski> and the "staged" way in which you first pass `fib' and `fib', and later `n - 1' and `n - 2' reminds me of something else, hmm
19:35:03 <ski> well, partly some `printf'-like combinators (there's some based on CPS, i think)
19:35:23 <ski> but also partly on a data structure thing i only vaguely recall
19:40:44 <ski>   myapp :: Ord a => Memoised a b (b -> c) -> (Memoised a b b -> Memoised a b c)  -- is this possible/sensible ?
19:40:59 <erisco> I think I have to go   (<.>) :: (a -> (MemoTable a b, (c -> d))) -> (a -> (MemoTable a b, c)) -> a -> a -> (MemoTable a b, d)
19:41:32 <erisco> but then it does not work nicely like the applicative interface
19:42:00 <ski> hm, i suppose feeding `a' to the first part, yielding a `b -> c', wouldn't then be added to the table, so is there a point to not prefeed `a' ?
19:42:06 <ski> perhaps the interface is the point
19:43:13 <ski> erisco : (a) why two `a' inputs; (b) i don't see how you could add anything to the table, since nothing gives you a `b'
19:43:21 <erisco> ski, hm maybe I am wrong
19:43:51 <ski> perhaps you can delay the inserts in some way to make the types work out ..
19:45:32 <ski> hm, i wonder whether something like a `Map1' could help ..
19:50:38 <erisco> yeah I'm not sure
19:52:57 <ski> hm, i used `type Traced a b = a -> (Trace a b,b)' -- wondering whether you want `type Memoised a b c = a -> (MemoTable a b, c)' here
19:54:32 <erisco> I might try this ADT and see where I get data Memoised a b c = Memoised (Map a b) (a -> Memoised a b c) c
19:56:39 <ski> (that looks a little like <http://twanvl.nl/blog/haskell/non-regular1.lhs>, which was one of the things i was slightly reminded of)
20:34:00 <erisco> ski, yeah I dunno about that ADT either
20:35:19 <erisco> Memo (Map a b) (a -> b)    makes sense but I cannot get it to work for recursive functions
20:37:25 <blaenk> hey should I use TVar over TMVar? new to concurrency, not sure of the differences
20:37:52 <blaenk> it seems to me like I can use TVar, I only use readTMVar and swapTMVar, and newTMVar
20:38:01 <blaenk> and it has functions for that, but I don't know what the difference is
20:40:16 <zRecursive> Does TMVar mean MVar embeded in TVar ?
20:40:36 <blaenk> oh, yeah it does
20:40:42 <blaenk> newtype TMVar a = TMVar (TVar (Maybe a)) deriving (Eq, Typeable)
20:40:54 <blaenk> not sure what the implications of that are though
20:41:21 <blaenk> wait I don't know if that answers your question actually
20:41:21 <blaenk> misread your question originally
20:41:45 <zRecursive> i see, it is "Maybe  in TVar"
20:41:53 <blaenk> ohh okay
20:42:16 <triliyn> oh, is that what MVar is?
20:42:21 <blaenk> yeah I didn't know that
20:42:24 <blaenk> thought M meant memory or something
20:42:41 <blaenk> cause in fact, I'm using TMVar and no where do I deal with Maybe, so I'm still confused as to the differences
20:42:41 <zRecursive> Maybe here
20:43:29 <Saizan> TMVar is short for Transactional MVar
20:43:47 <blaenk> ohh yeah I see the point of the Maybe in there now. it allows it to provide functions like tryRead etc
20:43:50 <Saizan> it's similar to a MVar because it can be empty, and blocks readers in that case
20:44:12 <blaenk> thanks Saizan, but actually I'm confused as to the difference between TMVar and TVar
20:44:24 <blaenk> which should I use, in other words. I'm starting to think I should use TVar, since I don't use the try functions?
20:44:34 <blaenk> like tryReadTMVar :: TMVar a -> STM (Maybe a)
20:44:49 <blaenk> so if I don't need the maybe aspect, just use TVar?
20:45:11 <Saizan> blaenk: it's not really about the Maybe in the types of the functions
20:45:32 <Saizan> blaenk: you want TMVar if you need synchronization, essentially
20:45:40 <blaenk> oh okay, what's TVar for?
20:46:10 <Saizan> TVar is for plain "transactionally-safe" references
20:46:27 <blaenk> ohhh I see, TMVar is the one that blocks/retries until it has something to read
20:46:33 <blaenk> that's indeed the one I need then. thanks :)
20:47:05 <Saizan> yeah, if you need it to be possibly empty you need TMVar
20:47:25 <Saizan> if you just want consistency and atomicity ... you want TVar
20:47:38 <blaenk> oh actually nevermind, yeah I need a TVar, cause it'll never be empty
20:47:45 <blaenk> I was mixing it up with channels, which I do need to block until something's read
20:48:28 <blaenk> I appreciate the clarification Saizan
20:50:24 <blaenk> TMVar is to MVar as TVar is to ?
20:50:41 <blaenk> Var? http://www.haskell.org/ghc/docs/7.4.2/html/libraries/ghc-7.4.2/Var.html
20:50:41 <Saizan> IORef
20:50:45 <blaenk> ah okay thanks
21:00:31 <Sgeo> :t fromMaybe
21:00:32 <lambdabot> a -> Maybe a -> a
21:01:08 <dwcook> @djinn a -> Maybe a -> a
21:01:09 <lambdabot> f a b =
21:01:09 <lambdabot>     case b of
21:01:09 <lambdabot>     Nothing -> a
21:01:09 <lambdabot>     Just c -> c
21:01:14 <dwcook> Not bad.
21:06:27 <enthropy> hello, is there a nicer way to do such a substitution: http://lpaste.net/97315
21:07:51 <ion> It might be fun if GHC applied something djinn-like when suggesting values for holes.
21:09:50 <maxs_> does anyone have comments on this? something I missed? im trying to make the case for objective-c
21:09:57 <maxs_> wrong channel
21:12:57 <erisco> ski, alack I feel I am close but I am missing something key http://lpaste.net/97316
21:13:26 <jxv> is there an extension to do this: http://codepad.org/tLCfLLVr ?
21:13:50 <erisco> wait I see one boo-boo
21:14:22 <jxv> this = func
21:16:37 <erisco> gah what do I know
21:16:58 <bos_> edwardk: ping
21:17:05 <edwardk> pong
21:17:14 <erisco> I am too tired... will work on tomorrow. night
21:17:19 <edwardk> what'd i blow up?
21:17:23 <bos> edwardk: nothing!
21:17:26 <edwardk> =)
21:17:32 <bos> edwardk: it's more "what did bos blow up" eckcholly
21:17:39 <edwardk> hah
21:17:49 <hdevalence> has anyone ever used Criterion with ffi to do benchmarking of C code?
21:17:56 <ski> jxv : perhaps you want `class Quux b a | b -> a where ...' ?
21:18:07 <bitemyapp> hdevalence: think the FFI overhead might invalidate the results, no?
21:18:23 <bos> edwardk: here's a snapshot of a very boiled down piece of aeson's API: http://lpaste.net/97317
21:18:24 <hdevalence> yeah, I have no idea if it'd be possible
21:18:36 <bitemyapp> well I'm sure it's possible, just inadvisable.
21:18:52 <bos> edwardk: what i wish to do is replace the concrete type String with a parameterised type
21:19:12 <hdevalence> well, I guess really what I'm looking for is a way to do benchmarking like Criterion, but of some C functions
21:19:21 <bos> edwardk: and my brain has slightly rotted, so it is proving devilish hard to make my efforts typecheck
21:19:47 <bos> edwardk: in other words, i'd like to be able to say "it's fine to use a Text or a ByteString as the string type"
21:20:46 <bitemyapp> bos: I know people were grumpy about String in general, but has something in particular triggered this?
21:21:09 <edwardk> and you don't want data Value a = Object (HashMap a Value) | String a ?
21:21:23 <bos> edwardk: that would be fine, but it's hard to make typecheck!
21:21:32 <jxv> ski, I'm not sure yet. that paste is simpilied version of what I'm trying to do.
21:21:36 <bos> bitemyapp: the desire to experiment with alternate string types
21:22:11 <edwardk> newtype Parser a = Parser { runParser :: forall f r. (a -> f r) -> f r } is a placeholder for a more refined codensity type i presume?
21:22:12 <bitemyapp> bos: fair enough. Was just curious, thank you!
21:22:26 <bos> edwardk: right, the real parser type has a failure continuation too
21:22:45 <bos> but that just muddies things here, as the parser machinery isn't really relevant
21:22:49 <edwardk> sure
21:22:56 <bos> bitemyapp: of course
21:23:18 <bitemyapp> Love this channel. Not used to having people answer my questions ;_;
21:24:06 <maxs_> bos: can you use multi-parameter type classes? or are you avoiding it?
21:24:06 <Saizan> bos: i guess your problem is FromJSON String ?
21:24:22 <bos> Saizan: no, that's only one of the problems :-)
21:24:34 <edwardk> so lets presume you have a class Stringy t where ...       then class FromJSON a where parseJSON :: Stringy t => Value t -> Parser a -- would you want the parser string type to match the type of the one from the value?
21:25:16 <bos> edwardk: that's exactly what i have, and i kind of don't care whether the parser's string type matches or not
21:25:27 <jxv> ski, it seems it can't have more than one http://codepad.org/sYOsZJkI . What's that feature with the '|' in the type-class called btw?
21:25:28 <edwardk> the real question becomes if going through Stringy is faster than going through the normal list bolted on top of an underlying string type.
21:25:28 <bos> edwardk: my Stringy class has toText and toByteString and toString methods
21:25:59 <edwardk> ok, so you could of course GADT out Value and just carry the Stringy instance in each.
21:26:32 <bos> parseJSON :: Value t1 -> Parser (HashMap t v)
21:26:41 <bos> edwardk: i still end up with other annoying problems, like not being able to prove that t and t1 are the same in the instance for FromJSON (HashMap t v):
21:26:44 <edwardk> data Value where Object :: Stringy t => HashMap t Value -> Value; String :: Stringy t => t -> Value  -- but blech
21:26:47 <bos> edwardk: yeah, the GADT approach was looking likely
21:27:11 <bos> staring down the barrel of type families
21:27:19 <bos> Saizan: that's just one of the problems
21:27:30 <bos> Saizan: oops, i answered you already
21:27:36 <ski> jxv : i'm not sure whether you were asking about the cyclic class thing, or the ambiguity error ..
21:27:40 <edwardk> well, you can add a member to Stringy saying you can coerce other Stringy instances to yours
21:27:46 <edwardk> then just coerce it to fit the existing HashMap
21:27:54 <jxv> ski, the ambiguity
21:28:07 <ski> jxv : anyway, it's called `FunctionalDependencies'
21:28:42 <edwardk> class Stringy t where toText :: t -> Text; toBS :: t -> ByteString; toString :: t -> String; fromStringy :: Stringy s => s -> t
21:28:42 <bos> edwardk: that's more or less what the toText and toString and friends methods do
21:28:48 <jxv> ski, ah okay
21:28:56 <edwardk> sure, but that way you aren't picking between them
21:29:00 <bos> true
21:29:37 <edwardk> you're leaving it up to the instance and it can do the identity transform for you as appropriate, think of it as the FP version of the visitor double-dispatch pattern
21:30:03 <edwardk> you could of course just defunctionalize this completely
21:30:10 <ski> the FD in `class Foo a b c d | a c -> d' means that `forall a c. unique d. exists b. Foo a b c d', which means the same as `forall a b0 b1 c d0 d1. (Foo a b0 c d0,Foo a b1 c d1) => d0 = d1'
21:30:36 <edwardk> dumb stringy on the floor, and make a data Stringy = String String | ByteString ByteString | Text Text that does the right thing
21:30:39 <edwardk> er dump
21:30:44 <ski> jxv : iow, if the `a' and the `c' parameters agree in two instances, then the `d' parameter also has to agree
21:31:01 <bos> edwardk: the Tekmo approach
21:31:06 <edwardk> then you can case analyze it and you get no dictionary plumbing, but you have an extra pointer indirection instead
21:31:39 <ski> jxv : iow, you can't have two instances with same `a' and `c' types, but different `d' type : `a' and `c' together *functionally determines* `d'
21:31:44 <edwardk> it lets you be much more explicit, and it makes the solution require a lot lower tech.
21:32:05 <edwardk> plus you can vary the direction of coercions to maximize safety when comparing, etc.
21:32:28 <bos> i'm trying to find a local maximum for backwards compatibility with existing users of aeson too, of course
21:32:30 <edwardk> e.g. coerce text to string but not the other way when you go to compare them for (==) to avoid denormalized Text, etc.
21:32:38 <bos> right
21:32:50 <ski> jxv : `| c -> b -> a' is invalid syntax. possibly you wanted `| c b -> a' (meaning that `c' and `b' together determines `a')
21:32:53 <djahandarie> Users? Why keep such inconveneient things around.
21:32:59 <edwardk> yeah basically this change is probably going to horribly break lens-aeson
21:33:29 <jxv> ski, hmm makes sense. I'll have to play around with it more. So, this will expand indefinitely with more dependencies. Yeah that's what intended then.
21:33:44 <maxs_> edwardk: why not http://lpaste.net/97318 ?
21:33:54 <bos> edwardk: the assumption underpinning it is that it might be worth having an alternate Text implementation that's UTF-8 based
21:34:27 <edwardk> maxs_: class FromJSON s a where will infer poorly
21:34:39 <jxv> ski, thanks :)
21:34:57 <bos> maxs_: the use of MPTCs without fundeps usually leads to great sadness
21:35:00 <edwardk> you'll get lots of cases where the 's' is under determined, so the instance selection will remain ambiguous and hence not made
21:35:09 <Saizan> if you are fine with 2*3 instances you're fine with the original Stringy class with only toFoo methods
21:35:13 <lispy> edwardk: I don't normally like programming language advocacy, but I did like your essay on quora
21:35:15 <maxs_> yeah sure
21:35:23 <edwardk> lispy: thanks
21:35:23 <lispy> edwardk++
21:35:27 <ski> jxv : the problem originally was that evey if you had `Foo Int String' and `Quux String Int', nothing prohibits someone from later also adding `Foo Double String' and `Quux String Double', so `func b = bar (qax b)' really is ambiguous : it can't figure out whether the type of the value passed from `qax' to `bar' is `Int' or `Double' or something else
21:35:52 <edwardk> lispy: i figured i should write something up when i saw you could review topics =)
21:36:10 <ski> jxv : however, adding the `b -> a' FD on `Quux b a' prohibits having both a `Quux String Int' and a `Quux String Double' instance at the same time
21:36:12 <edwardk> it just got retweeted by brendan eich, so folks are coming out of the woodwork
21:36:15 <bos> Saizan: not quite. i'd still like to be able to write this: instance (FromJSON v) => FromJSON (HashMap t v) where
21:36:26 <bos> Saizan: and no amount of toFoo helps
21:37:26 <edwardk> i kind of think the 'closed universe' model with the 3 cases you do care about explicitly inhabiting the ugly class or concrete data type with cases are your best bet in terms of getting a decently performant API.
21:38:02 <edwardk> the data type version probably works best for users like lens-aeson, since basically it has to rebuild the entire hashmap otherwise.
21:38:18 <bos> yah
21:38:32 <ski> jxv : this means that it knows that the type of `qax b' in `func b = bar (qax b)' *must* be the type `a' mentioned in the `Quux b a' contraint in the signature `func :: (Quux b a, Foo a b) => b -> b' (as opposed to some alternate `a_', distinct from `a', where `Quux b a_' also happens to hold for the same `b' but for this different `a_')
21:38:42 <edwardk> that pretty much leaves me with only one candidate to root for, as lens-aeson is one of my more popular libraries ;)
21:39:04 <bos> heh heh
21:39:08 <lispy> edwardk: cool. Or maybe because I retweeted it? (okay, j/k, but who is brendan?)
21:39:20 <Saizan> bos: that's why thet get to be 2*3
21:39:22 <bos> i'll have to name the type a Kmett
21:39:24 <edwardk> lispy: wrote a little language called javascript
21:39:35 <ski> jxv : therefore, it now knows that it should *use* the constraint `Quux b a' to "fetch" the implementation of the method `qax', instead of attempting to fetch it from some *possibly* different constraint `Quux b a_', where `a_' may or may not be equal to `a'
21:39:43 <Saizan> bos: you need instance (FromJSON v) => FromJSON (HashMap String v), instance (FromJSON v) => FromJSON (HashMap ByteString v), instance (FromJSON v) => FromJSON (HashMap Text v)
21:39:45 <lispy> edwardk: ah, I should probably learn that language at some point.
21:40:06 <lispy> I think it's popular with websites or something?
21:40:50 <bos> Saizan: that's not enough, give it a try with the hpaste i posted and you'll see
21:42:00 <bos> Saizan: i believe the problem is that the compiler still has that parametric type from the signature of parseJSON flapping in the breeze
21:42:22 <ski> jxv : so, hopefully you can see that the effect of an FD (apart from enabling you to express some actual dependency in your problem domain, as well as prohibiting you from making certain simultaneous instances) is to reduce ambiguity in type inference by allowing the system to derive that if `Quux b a0' and `Quux b a1' holds, then `a0' and `a1' *must* be equal
21:42:32 <ski> jxv : so it might just as well unify those two types already (reducing ambiguity, and helping direct type inference and instance selection)
21:45:08 <Saizan> bos: this typechecks here http://lpaste.net/97317
21:45:27 <edwardk> lispy: well, you should be familiar with it, its basically a weak lisp wrapped in java-like syntax. ;)
21:45:30 <Saizan> bos: the annotation, i mean
21:46:53 <bos> Saizan: right, you kind of ran it out to its logical conclusion there
21:47:20 <Saizan> yeah, it's not pretty
21:47:52 <blaenk> http://hackage.haskell.org/package/stm-2.4.2/docs/Control-Concurrent-STM-TChan.html
21:47:56 <blaenk> newBroadcastTChan says
21:48:02 <blaenk> "The problem with using newTChan to create the broadcast channel is that if it is only written to and never read, items will pile up in memory. By using newBroadcastTChan to create the broadcast channel, items can be garbage collected after clients have seen them."
21:48:43 <jxv> ski, sorta. Although fortunately this channel is logged. It's starting to get late for exploring new things.
21:48:45 <blaenk> I'm kind of confused by the wording. does this mean that if I create a broadcast channel and I write to it and there's no one reading from it, the memory won't pile up?
21:49:08 <jxv> ski, but yes. You explained what I wanted.
21:49:37 <Saizan> blaenk: yes
21:49:57 <blaenk> I'm confused because that text says "if it is only written to and never read, items pile up in memory" but then it says after that that "items can be garbage collected _after clients have seen them", so it's kind of contradicting itself?
21:50:11 <Saizan> blaenk: the elements will be retained only by the channels dup'ed from it
21:50:14 <blaenk> so they're only GCed if the clients read the channel? but then it said that the items wont pile up if they aren't read?
21:50:51 <Saizan> blaenk: when it talks about items piling up it means for channels created with newTChan
21:50:53 <blaenk> hmm I think I kind of understand that Saizan, what would be the other behavior if newBroadcastTChan weren't used?
21:51:29 <blaenk> to simplify things. in both cases, if I write to the 'broadcast channel' but don't read from it, they pile up right?
21:51:37 <Saizan> no
21:51:39 <blaenk> be it created from newTChan or newBroadcastTChan
21:51:41 <blaenk> oh
21:52:13 <rose> Is there a library for turning human-readable relative dates like "since yesterday" and "until Wednesday" into UTCTime?
21:52:14 <blaenk> oh I see, it'll only pile up in the newBroadcastTChan case if I have duplicated the channel. but if I haven't duplicated it, then no one cares, so it doesn't pile up?
21:52:19 <lispy> edwardk: heh. In all seriousness. I wanted to study it back in 2004, (I had just finished undergrad but didn't have a job yet) and I quickly discovered some inconsistencies with comparisons against max int, I was instantly afraid of the semantics. They've since fixed that issue.
21:52:52 <Saizan> blaenk: right, and more importantly it doesn't retain items already read from dup'ed channel
21:53:40 <Saizan> if you use newTChan, and have a server only write to it, and clients read from dup'ed channels, you still get the original channel clogged because it's meant to be readable too
21:53:47 <blaenk> hmm ok, so to be sure. what happens if I have the broadcast channel and then I write to it, then sometime later I duplicate it, it wont have the data that was previously written right, cause like you said it wouldn't have been retained?
21:53:55 <blaenk> oh I see
21:54:08 <Saizan> while newBroadcastTChan is meant to be write-only, and access done only by channels dup'ed from it
21:54:16 <blaenk> alright, I think this may be useful for me because
21:54:21 <Saizan> so the original channel can allows GC
21:54:26 <edwardk> lispy: In 2006 I wrote a Javascript compiler in Javascript. This somehow led to me learning Haskell.
21:54:47 <lispy> edwardk: yeah, I recall hearing about that before (not that I recall the details exactl)
21:54:56 <lispy> edwardk: Kind of an amazing tale
21:54:58 <Saizan> blaenk: right, the dup'ed channel will only have the data that gets written later
21:55:07 <lispy> edwardk: "all roads lead to haskell"
21:55:38 <blaenk> I previously had an admittedly hacky (or is it?) situation where I duplicated the channel (newTChan since I didn't know about newBroadcastTChan) per client connection, and I implemented some reference counting so that when it reached 0 (meaning no clients interested in the channel) the channel would be deleted, to avoid writing to it when no client was interested
21:55:48 <blaenk> i.e. to prevent it from piling up with memory no one was using
21:55:55 <edwardk> the new ecmascript specification they were working on at the time reminded me of perl 6, the working implementation of perl 6 at the time was pugs, pugs was written in haskell, so i decided i'd build a javascript compiler in haskell and learn something along the way
21:55:57 <blaenk> so in this case, a broadcast channel would allow me to get rid of that reference counting right?/
21:55:58 <edwardk> learned more than i expected
21:56:06 <Saizan> blaenk: yeah
21:56:07 <lispy> edwardk: I'm often reminded that John Launchbury's thesis is about semantics and how even though CS largely treats semantics as the elphant in the room, somehow paying attention to them leads to amazing results
21:56:14 <blaenk> Saizan: beautiful!
21:56:16 <blaenk> thanks a lot
21:56:23 <Saizan> np :)
21:57:03 <lispy> edwardk: imagine that, focusing on the meaning of what you're expressing somehow enables you to express yourself more precisely and more accurately!
21:57:13 <lispy> edwardk: oh that's right. Perl 6!
21:57:18 <lispy> audrey tang
21:57:34 <lispy> It's a shame that pugs is so little know of today
22:00:28 <bos> Saizan: this is what edwardk's suggestion ends up looking like: http://lpaste.net/diff/97317/97321
22:00:42 <bos> Saizan: not all that different from yours in terms of gnarliness
22:02:53 <ski> jxv : great
22:07:54 <blaenk> Saizan: I'm curious what you think. In that reference-counted channel solution I was using, if the reference reached zero, I removed it from the Map, so that when the producer got to work, it'd check the map and if the channel wasn't there, it didn't send anything through the channel
22:08:14 <blaenk> that was mainly to avoid what I was telling you, what newBroadcastTChan apparently solves on its own
22:08:18 <anthezium> dcoutts:  Hey I'm patching cabal to allow expansion of $home in .cabal/config.  I'm trying to decide whether it's a good idea to put home in InstallDirs or whether it should just be an Ordinary thing in the path template environment.  Initially I decided that putting home in InstallDirs would be bad since it might mean that a home field would have to appear in config files, thwarting the whole home-agnosticism purpose of this patch.  Plus,
22:08:57 <blaenk> avoiding the pile up of memory etc. it also implicitly encoded an interest in the data the producer created. so if there's a channel, clearly someone's interested so it piped the data through the channel
22:09:35 <blaenk> if there wasn't a channel in the Map, it meant no one was interested, so it didn't pipe the data. if I get rid of the reference counting, it'll unconditionally pipe the data through the channel, even though those data that are of interest are in the minority
22:10:21 <blaenk> what I'm curious about is, do you think I should therefore keep the reference counting, to avoid "unnecessary work", I guess it might be a difficult question for you to answer without knowing more, I'm mainly confused with regards to laziness
22:10:49 <blaenk> if perhaps laziness would mean that no one would ever actually need the data so it wouldn't actually be piped, but I've read that with IO it'll be pipe anyways no?
22:12:28 <Saizan> blaenk: i imagine writing to a channel made with newBroadcastTChan with no 'listeners' to be very cheap
22:12:33 <blaenk> for a better picture. I have two processes with forkIO. one produces and another consumes. the producer pipes data through a channel to an interested consumer. the consumer then pipes that data through to a websocket
22:13:18 <Saizan> blaenk: if you want to save work you'd have to not produce the data at all when there's no listener
22:14:10 <blaenk> cont'd: so say two consumers register interest, the producer writes to the broadcast channel and they both get the data. but then imagine they both 'disconnect', so they're no longer listening to the channel (their threads terminate), so without reference counting, the producer would be piping the data regardless, but no listening would be reading it. do you think that would be so detrimental that it'd be best to keep the reference counting?
22:14:24 <blaenk> yeah, the data is produced whether or not a consumer is interested in it actually
22:14:43 <blaenk> so the producer creates the data and does something. it's just that theres an option to 'inform' a consumer, if one is registered
22:14:51 <Saizan> i wouldn't keep the ref. counting just to avoid the writeChan in that scenario
22:15:06 <blaenk> yeah I'm enticed by the simplicity of doing away with ref counting
22:15:50 <blaenk> what I'm mainly worried about is, say I have 100 things the producer creates, but realistically only 2 would be monitored by a consumer, with ref counting only those 2 would writeChan, but now without ref counting all 100 would writeChan even though there's no one listening on the other end
22:15:54 <blaenk> so you think it's not a big deal
22:16:04 <blaenk> I guess I should say, this isn't anything mission critical or anything
22:16:08 <Saizan> bos: the prettier one would be adding the fromString maybe
22:19:20 <Saizan> blaenk: tbf, i imagine the ref. counting will have pretty much the same overhead to just always writeChan
22:19:35 <blaenk> oh you think so
22:20:09 <bos> Saizan: maybe
22:22:27 <Saizan> i guess it depends on the interaction with GC, but the ref. counting will need some read/writeTVar's actions anyway, and writeChan is just 4 of those
22:23:05 <blaenk> Saizan: I forgot to say, the broadcast channel is only created (and inserted into the Map) upon first registration. so it'll only create a channel in the map if it was registered to begin with. so the only "problem" is with lingering channels, channels that were created but are no longer used, that's the only place where there'll be unnecessary work done I guess
22:23:29 <blaenk> if only there were a way to see if anyone was listening and if not close it
22:24:40 <Saizan> i'd keep it simple
22:25:07 <blaenk> so the reference counting solved that, I suppose. when the last consumer disconnected for a particular channel, the refcount reached 0 and was removed from the Map, so that the producer never even found a channel to write to since it was gone from the Map
22:25:18 <blaenk> yeah, I'll think about it I suppose
22:25:40 <Saizan> i guess since you've already done the work you might not want to change it, just remeber it's an option if it gets messy
22:26:02 <blaenk> yeah I understand. yeah I'd be for making it simpler, it just seems messy though, to be writing to channels that no longer are needed
22:27:03 <Saizan> you're using haskell, it's already doing some pretty wasteful things unless GHC gets to optimize them :)
22:27:05 <blaenk> if I could get the amount of duplicate channels for any given channel that'd be nice I guess, I can see oh hey no one's even listening so remove it from the Map
22:27:36 <blaenk> yeah I suppose
22:27:54 <blaenk> yeah this is also just for my website (Hakyll blog), it just feels weird leaving it like that
22:28:03 <blaenk> the Map populated with channels that are no longer listened to
22:28:29 <Saizan> otherwise it'd be populated with 0s
22:28:49 <blaenk> haha
22:29:01 <blaenk> well also the channels no longer being there means no writeChan etc
22:29:02 <Saizan> :)
22:29:20 <blaenk> seems like a simple thing to be torn over but I'm conflicted
22:32:23 <flazz> i just installed hdevtools on osx, and it seems to hang with no evidence of starting a background job, any idea what i could be doing wrong?
22:38:09 <TheMK> Which library do people recommend for FRP GUI stuff? (I'm new to Haskell and just want to experiment)
22:38:14 <TheMK> I had a look at reactive-banana
22:38:50 <TheMK> but cabal install reactive-banana-wx sends me scary messages about versions being too high
22:39:21 <TheMK> netwire also looked interesting, but I would have to do a lot of work to get wx or the gtk bindings going with it
23:10:46 <erisco> ski, I think I got it
23:10:53 <erisco> but it is not as pretty as I'd like
23:11:29 <erisco> any suggestions? http://lpaste.net/97324
23:16:29 <erisco> I annotated with a slight cleanup for 'trivial'
23:16:45 <erisco> maybe I can get the 't' to the end and eta-reduce it
23:16:53 <erisco> that might be quite tricky
23:18:33 <jle`> erisco: you can always try @pl
23:18:45 <jle`> but i don't think this is a case where that'd help
23:28:46 <solrize> hi i'm trying to benchmark a pure func with criterion, that should take 1ms or so.  criterion says it takes 16ns which is nowhere near enough to actually run the func
23:29:26 <blaenk> are you using the nf/whnf etc functions
23:29:51 <solrize> yes, nf
23:30:41 <blaenk> I think it may be a problem with that, it's not being fully evaluated or something
23:30:49 <blaenk> "Because GHC optimises aggressively when compiling with -O, it is potentially easy to write innocent-looking benchmark code that will only be evaluated once, for which all but the first iteration of the timing loop will be timing the cost of doing nothing."
23:30:54 <blaenk> http://hackage.haskell.org/package/criterion-0.8.0.0/docs/Criterion-Main.html
23:31:10 <solrize> yeah, the result is an integer, it's not like a fancy data structure where whnf doesn't do much
23:31:25 <blaenk> o, ya no idea then
23:32:16 <blaenk> itd probably help to paste some code though
23:33:11 <solrize> http://lpaste.net/97327
23:34:24 <blaenk> bah x = modexp n (p-2) p
23:34:29 <blaenk> i think you meant bah x = modexp n (p-2) x ?
23:35:01 <solrize> hmm you think it's being cached?
23:35:05 <blaenk> i think so
23:35:06 <solrize> i just wanted a throwaway arg
23:35:10 <solrize> sec
23:35:29 <blaenk> afaik, the second parameter to nf is the last parameter to the func you wanna benchmark, so that criterion can apply it itself rather than have it be cached
23:35:48 <solrize> yeah, i think i started writing it that way
23:35:52 <solrize> originally i had bah ()
23:36:01 <solrize> yeah i think that was the problem
23:36:05 <blaenk> works now?
23:36:07 <solrize> now it says 159us which sounds reasonable
23:36:08 <solrize> thanks
23:36:10 <blaenk> :D
23:36:12 <blaenk> np
23:36:24 <blaenk> hey
23:36:33 <blaenk> I think youll also want to change (p-2) to (x-2)
23:36:39 <blaenk> might give a more reasonable time then, not sure
23:37:13 <solrize> p-2 is correct, it's figuring out the multiplicative inverse of n mod p
23:37:16 <solrize> in a pretty foolish way
23:37:26 <solrize> i want to compare it to xgcd
23:37:39 <solrize> and then with an optimized modexp using the special structure of p
23:37:44 <blaenk> without knowing what your code is doing, my point is that the second parameter to nf shouldnt be part of the function already, if you get my meaning
23:38:00 <blaenk> but maybe knowing the code, it makes sense, so was just a suggestion
23:38:22 <solrize> i think nf can only take 1 parameter and you're supposed to curry the rest
23:38:28 <blaenk> yep
23:38:32 <solrize> the code is just trying to do a modexp
23:40:00 <erisco> ah ha shoved it off the end and eta-reduced http://lpaste.net/97328
23:40:27 <erisco> I do not think it will get any cleaner than this
23:44:32 <erisco> now I just have to find out if it will help me implement graph functions
23:58:05 <ski> erisco : hm, feeling a bit too tired to think clearly
23:59:38 <erisco> ski, the purpose is to have a clean interface for threading a memo table through computations
