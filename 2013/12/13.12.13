00:00:00 <startling> Kron: I think it's an older idea that Lens reimplements lensily
00:00:02 <johnw> that should force the type match
00:00:15 <Kron> ... I'll try that
00:00:52 <startling> Kron, there's a nice Monad instance for QuadTree.
00:00:58 <startling> Kron: you might also consider data Four a = Four a a a; newtype Quadtree a = Quadtree (Free a) deriving ( ... )
00:01:11 <startling> sorry, newtype Quadtree a = Quadtree (Free Four a)
00:01:16 <Kron> johnw: it doesn't seem to work
00:01:26 <johnw> Kron: same error, same line?
00:01:28 <Kron> yup
00:01:32 <johnw> ok
00:01:43 <Kron> startling: can you elaborate on the Four a thing?
00:01:47 <Kron> and Free
00:01:50 <johnw> i'm surprised, because it should be the case that "old :: a"
00:02:37 <startling> Kron, Free is in Control.Monad.Free in the "free" package. data Free f a = Pure a | Free (f (Free f a))
00:02:46 <Kron> also I'm not sure how i'd make my quadtree into a monad, but monads in general vex me
00:02:54 <startling> Kron, there's an instance Functor f => Monad (Free f), which is the cool part
00:02:59 <Kron> hmmm
00:03:04 <Kron> i'll take a look at it
00:03:10 <shachaf> i love free monads
00:03:14 <Kron> I need to update this with traversal logic
00:03:19 <startling> Kron: it's a slightly advanced topic and maybe not one you want to dive into yet.
00:03:38 <startling> but it's a good thing to be aware of when you want it.
00:03:41 <Kron> one of my goals for this quadtree library starting out was support for searching based on arbitrary shapes defined on it
00:03:44 <Kron> aoe abilities in a roguelike
00:03:55 <Kron> so i'll have to make some sort of traverse thing for a filtered
00:04:10 <Kron> startling: indeed, awareness is great
00:05:41 <startling> Kron: anyway, if you'd like a brief overview of what a Monad instance for your quadtree would mean, I wouldn't mind explaining.
00:05:55 <Kron> it depends on how brief it is, since I'm going to bed in 5 minutes
00:06:04 <startling> Kron: it can be pretty brief. :)
00:06:05 <Kron> it's really late for me, was playing wraith night for hours on dota 2 '^^
00:06:07 <Kron> go for it
00:06:26 <dmwit> :t join
00:06:26 <lambdabot> Monad m => m (m a) -> m a
00:06:32 <startling> Kron, obviously return :: a -> Quadtree a; return = Leaf;
00:06:38 <Kron> right
00:07:27 <startling> Kron: then there's (>>=) :: Quadtree a -> (a -> Quadtree b) -> Quadtree b; which says "take each leaf, apply a function to it to create a subtree, and join it to the whole"
00:08:02 <Kron> hmmmmmm
00:08:08 <startling> does that make sense?
00:08:09 <Kron> ... yeahhh. I can see that.
00:08:15 <Kron> Right
00:08:19 <Kron> we access each leaf like a functor
00:08:27 <Kron> and then the QuadTree falls open into a series of a
00:08:44 <startling> this is interesting for things like language ASTs, where it can be "turn every identifier into the expression it refers to". :)
00:08:45 <Kron> and then you can convert those leaf values into new quadtrees (node or leaf) via (a -> QuadTree b)
00:08:53 <startling> Kron: right.
00:09:24 <startling> Kron, so the thing Monad gives you over Functor is something like
00:09:25 <startling> :t join
00:09:26 <lambdabot> Monad m => m (m a) -> m a
00:09:38 <startling> i.e. Quadtree (Quadtree a) -> Quadtree a
00:09:41 <dmwit> I approve of instantiating Monad on principle, but I wonder if (>>=) is an operation you ever use on QuadTrees.
00:10:03 <startling> It very possibly isn't.
00:10:20 <Kron> this does strike me as somewhat crazy, though I can trivially see how one can turn a quadtree of quadtrees into a new quadtree; each leaf is just a node waiting to happen
00:10:30 <Kron> I hear you can also make quadtrees applicative but that sounds even crazier
00:10:33 <startling> Kron: it turns out that, given "join" and "fmap" you can write (>>=).
00:10:35 <Kron> like an entire quadtree of functions or something
00:10:41 <Kron> applied to another quadtree
00:10:45 <startling> eKron: it's not so crazy. it's really easy!
00:10:51 <dmwit> If you can implement Monad, you can certainly implement Applicative.
00:10:54 <jle`> it might make sense to have an applicative quadtree in a zip-sense
00:10:59 <startling> Kron: especially if you have a a Monad instance; then (<*>) = ap
00:11:02 <shachaf> In fact Monad lets you turn "(m . m . ... . m) a" into "m a" for any number of "m"s on the left.
00:11:08 <shachaf> (Including 0.)
00:11:11 <jle`> but this zip-tree is unrelated to your monad tree
00:11:42 <jle`> your applicative instnace of a monad tree is probably going to resemble something more like the applicative instance of list
00:11:59 <startling> shachaf: heh, that's an interesting way to look at it.
00:12:14 <jle`> isn't that the way you approach it with free monads?
00:12:18 * hackagebot scotty 0.6.1 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.6.1 (AndrewFarmer)
00:12:25 <shachaf> Yes.
00:12:29 <startling> yeah.
00:13:10 <shachaf> Well... Except this is actually for the stronger version of Free.
00:13:18 <shachaf> Which isn't really free at all.
00:13:27 <startling> Kron: back to code-review type things: there's a DeriveFunctor extension (as well as DeriveFoldable and DeriveTraversable), which can be helpful, and having nested "where" clauses is kind of unusual.
00:13:40 <shachaf> data Foo f a = Pure a | Foo (Foo f (f a))
00:13:53 <Kron> hmmm okay
00:14:20 <startling> Kron, "error" on line 82 might be abad idea, too
00:14:48 <Kron> What would I place instead?
00:14:52 <Kron> silently ignore the command?
00:15:06 <startling> Kron, you'd make the return type Maybe a.
00:15:42 <Kron> that doesn't quite work so well for a lens though
00:15:54 <Kron> I'd have to give it a maybe a to insert into a quadtree with a setter then
00:15:59 <startling> well, maybe it should be a lens. :)
00:16:04 <startling> *shouldn't
00:16:37 <startling> also, foldl1' is kind of a weird choice, especially when you're using (++)
00:16:43 * hackagebot command-qq 0.2.0.0 - Quasiquoters for external commands  http://hackage.haskell.org/package/command-qq-0.2.0.0 (MatveyAksenov)
00:16:43 * hackagebot scotty 0.6.1 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.6.1 (AndrewFarmer)
00:17:03 <Kron> is there a better way to fuse strings together?
00:17:12 <Kron> hmmmm
00:17:13 <Kron> concat?
00:17:28 <Kron> yeah I'll use concat
00:17:43 <startling> you could also just foldl' (++) ""
00:17:52 <startling> no need to use foldl1
00:18:31 <Kron> I thought the entire point of the 1 was to avoid having to state [] or "" a lot
00:18:33 <Kron> or 0, etc.
00:18:39 <startling> > foldl1 (++) []
00:18:41 <lambdabot>  *Exception: Prelude.foldl1: empty list
00:18:49 <startling> ^ this is the big reason you don't want to do that
00:19:01 <startling> :t fold -- this might be useful, though
00:19:01 <lambdabot> (Foldable t, Monoid m) => t m -> m
00:19:11 <startling> :t fold `asAppliedTo` []
00:19:12 <lambdabot> Monoid b => [b] -> b
00:19:59 <Kron> I thought foldl1 was identical to foldl ... []
00:20:18 <simpson> :t asAppliedTo -- I am skeptical
00:20:19 <lambdabot> (a -> b) -> a -> a -> b
00:20:43 <startling> Kron, no.
00:21:04 <zacts> is the transition from (scheme)/SICP to haskell an easy one?
00:21:16 <startling> :t asTypeOf -- simpson: it's better than this
00:21:17 <lambdabot> a -> a -> a
00:21:21 <Kron> zacts: relatively, yeah
00:21:25 <zacts> cool
00:21:32 <Kron> anyway, it's really late for me
00:21:36 <Kron> I should be heading to bed
00:21:37 <startling> zacts: the big thing is Haskell's powerful type system.
00:21:41 <startling> Kron: have a nice night!
00:21:42 <Kron> thanks for the code review startling
00:21:47 <startling> Kron: sorry if this was a bit of an infodump.
00:21:51 <Kron> was looking for someone to poke my code with a long stick for a while now
00:21:56 <Kron> it kinda is but that's fine
00:22:00 <Kron> I'm only writing this to learn anyway
00:22:03 <Kron> :D
00:22:05 <zacts> ok, cool
00:26:40 <jle`> is there any other meaningful way to define a monad instance for list?
00:26:48 <jle`> just like how there is more than one way to define an applicative instance ofr list
00:27:15 <jle`> or does something like (>>=) :: [a] -> (a -> [b]) -> [b] completely define its behavior
00:27:50 <simpson> Well, there are some laws for Monads.
00:27:52 <simpson> http://www.haskell.org/haskellwiki/Monad_laws
00:28:25 <jle`> are there any other ways to define it that satisfy the laws?
00:28:34 <simpson> Hm. Good question!
00:28:35 <startling> :t \[a] f -> [f a]
00:28:36 <lambdabot> [t] -> (t -> t1) -> [t1]
00:28:41 <jle`> or do the laws specify the behavior exactly?
00:28:56 <startling> :t \[a] f -> f a `asTypeOf` []
00:28:57 <lambdabot> [t] -> (t -> [a]) -> [a]
00:29:24 <startling> jle`, I think for [] they specify the behavior exactly.
00:29:27 <simpson> IIRC the important one is that join behaves the same regardless of whether one uses return or fmap return to build up layers of monad.
00:29:54 <startling> jle`: I'm not sure why they do so for [] and of any examples where they don't.
00:30:05 <startling> but e.g. Maybe has two possible Monoid instances.
00:30:15 <startling> well, Maybe a does.
00:30:49 <jle`> is there a trivial instance
00:30:58 <jle`> does that make sense even
00:31:12 <jle`> nvm
00:31:15 <simpson> So IIRC `join (return ma) === join (fmap return ma)`
00:32:42 <simpson> Specialize for list to get `join [ma] === join (map (:[]) ma)`
00:33:10 <jle`> suddenly have to go unfortunately, but i will be thinking about this question.
00:33:11 <simpson> So if you can think of another join besides concatMap which preserves that... but I bet that there isn't. I couldn't prove it to you, though.
00:35:18 <startling> I think "is there a Monad for which there are multiple instances" is a really interesting question.
00:35:36 <shachaf> What does that mean?
00:35:44 <shachaf> Is there a type for which there are multiple Monad instances?
00:35:57 <startling> multiple legal possible monad instances with different behavior.
00:36:06 <quicksilver> "is there a type for which there are multiple interesting non-trivial and difference instances"
00:36:48 <quicksilver> depends a bit how you define type. But if you define it in a certain way I think the answer is no.
00:38:01 <shachaf> Yes.
00:38:16 <shachaf> For example, (w,) has a Monad instance for each Monoid instance of w.
00:38:25 <simpson> @free [[a]] -> [a]
00:38:25 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
00:38:27 <startling> shachaf, oh, good point
00:38:37 <startling> hmmmm
00:40:21 <simpson> Yeah, my proof-fu is weak, but I think that join for [a] requires that each element of the output list correspond to elements in the input list being unwrapped; that is, (sum (map length xss)) is the same on the input and output.
00:40:30 <shachaf> @free blah :: [[a]] -> [a]
00:40:30 <lambdabot> $map f . blah = blah . $map ($map f)
00:40:40 <quicksilver> starling: I think that infinite lists have the 'diagonal' join as well as the 'fair choice' join.
00:40:42 <shachaf> (I.e. blah is a natural transformation.)
00:40:50 <quicksilver> startling: ^^
00:40:51 <simpson> Which would pretty much require that join = concatMap
00:40:58 <startling> quicksilver: oh, good point
00:41:16 <shachaf> simpson: join = concatMap?
00:41:23 <quicksilver> but I'm not sure if the fair choice join for infinite lists has some technical issues
00:41:31 <simpson> shachaf: Er, concat, not concatMap. Tired.
00:43:26 <shachaf> simpson: blah _ = [] is a valid function with that type, or what do you mean here?
00:44:03 <simpson> shachaf: Well, I was thinking that the laws for join might imply that [a] can only be a Monad in one way.
00:44:10 <startling> :t (\_ _ -> []) `asTypeOf` (>>=)
00:44:11 <lambdabot> [a1] -> (a1 -> [a]) -> [a]
00:44:31 <shachaf> Well, the free theorem for join is one of the monad laws.
00:44:46 <shachaf> But no one ever talks about it because it's a free theorem.
00:47:07 <simpson> Hm. I guess that return _ = []; _ >>= _ = []; is a Monad. It doesn't seem very useful though.
00:47:19 <shachaf> Not a monad.
00:47:23 <simpson> Oh, wait, it fails the fmap law.
00:47:28 <simpson> Derp. Nevermind.
00:47:42 <simpson> I really should sleep at this point. Nothing of use is being generated on my end.
00:47:44 <shachaf> return x >>= f = f x
00:48:02 <shachaf> The laws are kind of insidious.
00:48:18 <shachaf> They rule out a lot of things.
00:49:03 <simpson> But there's definitely not a DeriveMonad, right? Because it's not automatically deriveable?
00:49:23 <sipa> why is the above not a monad, though?
00:49:36 <startling> simpson: it is in some cases, I think
00:49:50 <sipa> i don't see why that rule isn't followed
00:49:53 <shachaf> Only NewtypeDeriving
00:49:55 <startling> functor isn't derivable in some cases.
00:50:09 <shachaf> simpson: Because f can do anything.
00:50:13 <shachaf> Er, sipa:
00:50:24 <sipa> right
00:50:55 <shachaf> For example f can be id.
00:51:02 <sipa> but you can have a monad None a = None
00:51:18 <shachaf> data Proxy a = Proxy?
00:51:20 <shachaf> Sure, that's a monad.
00:51:33 <sipa> as that will prevent f from having any value but that dummy
00:51:38 <shachaf> It's a good one, in fact.
00:52:12 <sipa> but using a subset of values of a datatype isn't possible as you can't prevent functions to remain within that subset
00:52:45 <johnw> jle`: this seems to satisfy the laws: https://gist.github.com/7941440
00:53:39 <shachaf> Yay, another round of "is ZipList a monad"
00:55:32 <johnw> it's not really ZipList
00:55:50 <johnw> i just changed the monad instance for Stream to account for []
00:57:52 <shachaf> Let me see.
00:58:03 <shachaf> return x >>= (:[]) is not equal to [x]
00:58:14 <johnw> nice find!
00:58:15 <johnw> thanks
01:14:35 <tovarish> shachaf, what?
01:16:03 <johnw> return x >>= f needs to be equvalent to f x
02:23:47 <rtpg> can all functions be written in a point free style?
02:24:24 <merijn> rtpg: Starting from which basic set of functions?
02:24:38 <merijn> i.e. do we already have an implementation of (.)?
02:24:47 <mr-> is f = \x -> ... considered point-free?
02:24:55 <merijn> mr-: It's not
02:25:11 <rtpg> merijn, I guess I meant more in a practical "with everything we have in the prelude"
02:25:12 <merijn> mr-: x is a variable (point), so demonstrably not point-free
02:25:17 <johnw> i don't think you can use record mutation syntax on a single member in a point-free way
02:25:27 <johnw> f x y = x { someField = y }
02:25:31 <merijn> rtpg: I don't have a proof, but I would say *probably*
02:25:38 <quicksilver> johnw: or data types in general
02:25:46 <merijn> rtpg: None of it will be readable, though :p
02:25:52 <rtpg> yeah :P
02:25:53 <merijn> Well, maybe some of it will be
02:25:54 <quicksilver> that is, a data type needs to come with an appropriate set of combinators to be pointfree-able
02:25:57 <johnw> yeah, and unless you are given accessors, you can't case analyze with point-free
02:26:14 <rtpg> ah, good point
02:26:17 <merijn> rtpg: Also, lambdabot's @pl command can make things point-free it's usually a good study of why you shouldn't
02:26:22 <johnw> data Foo a = Foo a; f (Foo x) = x <-- can't be made point-free
02:26:22 <quicksilver> if-then-else also can't be made pointfree in the standard prelude
02:26:58 <quicksilver> which you might or not take as simply being my previous comment as applied to the 'Bool' data type.
02:28:52 <quicksilver> lambdabot's @pl doesn't even understand pattern bindings or case IIRC
02:29:06 <quicksilver> @pl \x -> case x of True -> 1; False -> 0
02:29:06 <lambdabot> (line 1, column 24):
02:29:06 <lambdabot> unexpected '>'
02:29:06 <lambdabot> expecting operator
02:29:20 <johnw> guards are much less useful without points too
02:29:33 <arkeet> @pl \x -> case x of { True -> 1; False -> 0 }
02:29:33 <lambdabot> (line 1, column 17):
02:29:33 <lambdabot> unexpected '{'
02:29:33 <lambdabot> expecting variable, "(", operator or end of input
02:29:35 <johnw> foo | ...?  you can only use top-level defintions
02:29:38 <arkeet> heh
02:29:40 <carminemlt> Hi! I have a question about Applicative and ZipList as described in Typeclassopedia. In that document the definition of "pure" for ZipList [a] is left as an exercise. I have defined pure as follows: pure x = ZipList [x]. Is it correct?
02:29:44 <arkeet> I guess @pl has no clue about case
02:30:03 <arkeet> carminemlt: does it satisfy the laws?
02:30:04 <johnw> carminemlt: sounds right
02:30:09 <arkeet> (johnw: no)
02:30:15 <johnw> sounds wrong
02:30:18 <arkeet> lol
02:30:37 <carminemlt> arkeet: Honestly, haven't checked yet
02:30:46 <arkeet> that's, like, the most important part
02:31:07 <arkeet> is pure id <*> x = x ?
02:31:33 <carminemlt> yes
02:31:41 <arkeet> are you sure?
02:31:54 * hackagebot Spock 0.2.0.0 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.2.0.0 (AlexanderThiemann)
02:31:56 <carminemlt> pure id <*> [3] == [3]
02:32:00 <arkeet> that's not a proof
02:32:02 <johnw> now with two args
02:32:07 <johnw> pure id <*> [3,3]
02:32:13 <mr-> (you could also have cheated by looking at http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Applicative.html#ZipList , btw)
02:32:13 <johnw> does that equal [3,3]?
02:32:20 <arkeet> mr-: that's cheating
02:32:24 <mr-> like I said
02:32:27 <merijn> mr-: That kinda ruins the point of practicing
02:32:40 <arkeet> like
02:32:42 <carminemlt> still equals
02:32:43 <arkeet> apply the definition of <*>
02:32:45 <carminemlt> even with []
02:32:54 <carminemlt> i'm testing it with ghci
02:32:55 <arkeet> carminemlt: that's the wrong applicative.
02:32:58 <arkeet> not ZipList
02:33:00 <mr-> merijn: that's why I have not given the definition, but only pasted the link ;-P
02:33:17 <merijn> oh, duh
02:33:22 <arkeet> also don'ot use ghc's ZipList
02:33:25 <carminemlt> mr-: Thanks for the hint.
02:33:30 <merijn> I guess he needs to try "pure id <*> ZipList [3,3]"
02:33:38 <arkeet> yes, with his own instance for ZipList
02:34:04 <carminemlt> merijn: that makes ghci unhappy
02:34:30 <carminemlt> oh well, I guess I have to review my definition of pure
02:34:39 <merijn> carminemlt: Well, did you import your ZipList definition?
02:34:57 <arkeet> maybe just make your own type and call it something other than ZipList
02:35:04 <arkeet> just to make sure it doesn't get mixed up with the standard one
02:35:20 <carminemlt> merijn: I put my definition in a file and imported in ghci hiding Control.Applicative's
02:35:26 <carminemlt> arkeet: good point
02:35:40 <arkeet> also, if you want help with an error you'll need to show us the error :p
02:35:40 <carminemlt> arkeet: will give it a shot right now
02:36:54 * hackagebot Raincat 1.1.1.3 - A puzzle game written in Haskell with a cat in lead role  http://hackage.haskell.org/package/Raincat-1.1.1.3 (SergeiTrofimovich)
02:36:56 * hackagebot soap 0.2.1.1 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.1.1 (AlexanderBondarenko)
02:38:09 <carminemlt> ok, renamed my ZipList to ZopList (and it took quite an imagination effort :P)
02:38:16 <carminemlt> imported in ghci
02:38:39 <arkeet> may as well save yourself typing and write ZL or something :p
02:38:40 <arkeet> but ok
02:38:58 <carminemlt> and testing pure id <*> (ZopList [3,3]) still makes ghci unhappy
02:39:03 <carminemlt> arkeet: the error follows
02:39:04 <arkeet> you'll have to be more specific than that
02:39:05 <arkeet> ok
02:39:12 <arkeet> pastebin might be useful
02:39:13 <arkeet> @lpaste
02:39:13 <lambdabot> Haskell pastebin: http://lpaste.net/
02:41:14 <carminemlt> arkeet: http://lpaste.net/96929
02:41:51 <arkeet> oh, well, you might want to put deriving Show on that newtype
02:42:20 <merijn> oh, hah
02:42:24 <arkeet> and I guess there shouldn't have been any need to rename
02:42:35 <arkeet> blah
02:43:13 <carminemlt> arkeet: deriving Show got rid of the error, but: pure id <*> (ZopList [3,3]) == ZopList [3]
02:43:18 <arkeet> indeed
02:43:42 <arkeet> and that's because  zipWith ($) [id] [3,3] = [3]
02:43:43 <merijn> carminemlt: Right, instead of the "ZopList [3,3]" it should return. Any ideas why that might be happening? :)
02:43:58 <shachaf> tovarish: ?
02:43:58 <merijn> arkeet: Spoiler alert :(
02:44:01 <arkeet> oops
02:44:23 <tovarish> shachaf, forget, it's old :)
02:46:29 <merijn> carminemlt: Another hint
02:46:31 <carminemlt> merijn: yes, I can understand why
02:47:11 <carminemlt> merijn: now I have to figure how to make it work as intented :)
02:47:15 <merijn> Right, so if you know that it gets truncated to the shortest list, what solution do you need to make sure the "pure id <*> ZopList x == ZopList x" holds? :)
02:48:17 <shachaf> arkeet: Hmm, only colists can be ziplists?
02:48:26 <arkeet> ??
02:48:36 <shachaf> ??
02:49:02 <jj2baile> Does 'id' have some weird precedence?
02:49:06 <jj2baile> > id (*2) 3
02:49:07 <lambdabot>  6
02:49:09 <arkeet> id is a function
02:49:09 <carminemlt> merijn: Bear with me. I'm still fresh with all this stuff, so I'll be "slow" at answering
02:49:27 <arkeet> not an operator
02:49:27 <jj2baile> > (*1) (*2) 3
02:49:29 <lambdabot>  No instance for (GHC.Show.Show a0)
02:49:29 <lambdabot>    arising from a use of `M59204736584052803729233.show_M59204736584052803729...
02:49:29 <lambdabot>  The type variable `a0' is ambiguous
02:49:29 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
02:49:29 <lambdabot>  Note: there are several potential instances:
02:49:37 <merijn> Courtesy of my twitter stream: http://cokmett.github.io/cokmett/
02:49:38 <merijn> ahahaha
02:50:06 <merijn> (hint: click the image)
02:50:18 <jj2baile> but then also:
02:50:33 <jj2baile> > let idm = (*1) in  idm (*2) 3
02:50:34 <lambdabot>  No instance for (GHC.Show.Show a0)
02:50:34 <lambdabot>    arising from a use of `M465205372075018576329244.show_M4652053720750185763...
02:50:34 <lambdabot>  The type variable `a0' is ambiguous
02:50:34 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
02:50:34 <lambdabot>  Note: there are several potential instances:
02:51:05 <merijn> jj2baile: "id (*2) 3" parses as "(id (*2)) 3" and since "id (*2)" is equal to (*2) it parses as "(*2) 3"
02:51:42 <jj2baile> Oh, wait. urg. i see
02:51:45 <shachaf> Reduces to, maybe. "parses as" is a bit extreme.
02:52:01 <arkeet> it is?
02:52:04 <merijn> jj2baile: "let idm = (*1) in idm (*2) 3" parses as "(idm (*2)) 3" -> "((*1) (*2)) 3"
02:52:11 <merijn> shachaf: To people
02:52:20 <absence> what is it that makes Stream Char inside Text faster than [Char]?
02:52:22 <merijn> shachaf: Not by the compiler
02:52:30 <carminemlt> merijn: should try to replicate id so that both lists have the same length?
02:52:43 <merijn> carminemlt: Close, but there is a simpler solution :)
02:52:50 <arkeet> absence: that's for stream fusion
02:52:55 <merijn> carminemlt: i.e. one that doesn't require you to know the length of the list
02:53:35 <carminemlt> merijn: pattern match against "id" and cheat? :)
02:53:37 <merijn> carminemlt: To repeat the hint, it truncates the result list to the *shortest* of both lists (which is how the problem started in the first place)
02:53:46 <absence> arkeet: so "all" the stream/unstream stuff disappears in practice?
02:54:13 <arkeet> absence: yes,
02:54:19 <arkeet> because of rewrite rules
02:55:16 <absence> arkeet: makes sense, thanks :)
02:57:00 <carminemlt> merijn: pure x = ZopList (repeat x) ?
02:57:10 <merijn> carminemlt: Correct
02:57:12 <arkeet> try it!
02:57:14 <carminemlt> yay!
02:57:16 <carminemlt> :)
02:57:16 <arkeet> also yes
02:57:57 <carminemlt> will go on checking the satisfaction of composition and homomorphism
02:58:03 <carminemlt> thanks
02:58:49 <arkeet> I wonder which ones of those are free
03:00:17 <jj2baile> merijn: thanks;  I had function application done weirdly in my head
03:08:59 <absence> arkeet: so the stream fusion gets rid of intermediate structures, and the "actual" speedup in text is due to storing characters in arrays and looking them up unsafely instead of linked list?
03:09:49 <shachaf> It's not really unsafe.
03:10:43 <absence> shachaf: for the user of the text library you mean, or a developer of the text library?
03:10:49 <skypers> the more I use darcs
03:10:54 <skypers> the better I feel with
03:11:01 <skypers> seriously, darcs just rocks
03:11:52 <shachaf> Well, it happens that Text is implemented using unsafe primitives, but that's not really fundamental.
03:12:09 <arkeet> absence: stream fusion could be done just as well for ordinary lists.
03:12:56 <absence> arkeet: i noticed Data.Stream :)
03:14:25 <absence> shachaf: i realise that it's not unsafe to use text as long as there are no bugs, i just wondered if unsafe array lookup was part of the reason it's fast
03:14:40 <mr-> Does fusion mean using the universal property of fold to reduce the number of traversals?
03:14:50 <shachaf> Well. A small constant, sure.
03:14:57 <shachaf> Fusion can mean a lot of things.
03:15:23 <absence> shachaf: hm, what's the big part then?
03:15:52 <shachaf> absence: Well, using arrays in the first place, I imagine. But arrays are perfectly safe.
03:17:10 <merijn> absence: The elimination of of repeated pointer dereferencing in String and size bloat of String help for speed too
03:17:12 <AshyIsMe> so this is a web scraping script ive been working on: http://lpaste.net/96932
03:17:25 <AshyIsMe> im new to haskell, what things am i doing stupidly?
03:18:07 <merijn> AshyIsMe: Not so much something stupidly, but might be a cool step to parallelise the scraping, shouldn't be very hard with your current code :)
03:18:47 <AshyIsMe> cool, so is it forkIO i should look into?
03:18:53 <merijn> AshyIsMe: Instead of "mapM fetch urllist" you could write all items in urllist to a Chan and have several forkIO threads fetching them and writing the result into a result Chan
03:18:58 <AshyIsMe> i havent read the parrallel and concurrent haskell book yet but that's on my list
03:19:03 <merijn> AshyIsMe: Yeah, that and MVar/Chan/etc.
03:19:05 <shachaf> mr-: The universal property of fold meaning that fold is an arrow from an initial algebra?
03:19:19 <merijn> AshyIsMe: tbh, for a beginner just reading the Control.Concurrent docs can get you quite far
03:19:23 <mr-> shachaf: yes
03:19:30 <AshyIsMe> sweet, cheers
03:20:08 <merijn> AshyIsMe: Parallel and Concurrent Haskell is good, but also focuses on subtle tricky bits, a fischer price "My First Concurrent Scraper" script doesn't really need to worry about all of those
03:20:20 <mr-> Isn't there also a "mapConcurrently" somewhere that you could just use instad of mapM?
03:20:32 <AshyIsMe> ah yeap
03:20:35 <absence> do the chains of "next" functions per character in Stream inline/fuse/something, or is that unavoidable?
03:20:59 <arkeet> AshyIsMe: look into the async library
03:21:04 <rtpg> metalgear
03:21:25 <merijn> I would actually argue to first write it yourself using MVar/forkIO to get familiar with those, *then* use async for convenience
03:21:32 <arkeet> fair
03:21:38 <arkeet> ok
03:21:43 <arkeet> read simon marlow's talk on the async library
03:21:44 <arkeet> :)
03:21:47 <arkeet> er, watch
03:21:56 <AshyIsMe> yeah i think i'll do all of those haha
03:21:57 <arkeet> http://skillsmatter.com/podcast/home/high-performance-concurrency
03:22:34 <mr-> shachaf: from that you get conditions on when you can "fuse" two folds to one, or that you can fuse map and fold. (I guess that's all trivial for lists)
03:23:01 <AshyIsMe> cheers
03:26:58 <absence> do the chains of "next" functions per character in Stream inline/fuse/something, or is the overhead of the calls dwarfed by what the cost of using a linked list would be?
03:27:19 <arkeet> that's the part where ghc's optimizer comes in
03:27:27 <arkeet> it's much easier to optimize nonrecursive functions
03:28:10 <Iceland_jack> absence: Optimizing unstructured recursion is extremely difficult
03:28:30 <arkeet> where's the paper
03:28:47 <Iceland_jack> so if we can write recursive functions in a non-recursive way and fuse those functions together, GHC can go to town on them
03:28:48 <arkeet> oh it's cited in the stream-fusion package
03:28:51 <shachaf> @google that one paper about stream fusion or something
03:28:53 <lambdabot> http://metagraph.org/papers/stream_fusion.pdf
03:28:53 <lambdabot> Title: Stream Fusion
03:28:59 <arkeet> yeah
03:29:02 <arkeet> haha
03:39:08 <merijn> shachaf: hah, did you test that before trying? :p
03:39:28 <absence> hm, and repa puts these fusion concepts on stereoids?
03:40:11 <shachaf> merijn: Not with that exact query.
03:41:54 <Philonous_> https://rawgithub.com/cokmett/cokmett/gh-pages/index.html
03:42:22 <arkeet> yes
03:42:27 <arkeet> also the proper url is http://cokmett.github.io/cokmett/
03:42:48 <merijn> I just linked that yeah, it's hilarious :)
03:43:14 <Philonous> Ah, sorry for reposting, then, it just popped up in my rss feed
03:43:17 <merijn> Once you figure out to click it, anyway
03:45:07 <donri> co-mett
04:06:30 <maxpow4h> I'm using HXT to parse HTML. A div has 2 spans, how do I return them as a tuple (instead of them been fed out)? The code I have: deep getText <<< arr head <<< hasName "span" -< headerDiv.
04:07:24 <maxpow4h> so I need something other than "<<<" on the left of hasName, to have a list
04:10:15 <xplat>  
04:16:12 <cryzed> http://paste.ee/p/rzXkW Does anyone have a clue why this happens?
04:16:48 <arkeet> you defined a type Rectangle with a constructor called Int, that takes 3 Int arguments.
04:16:55 <arkeet> so, Int :: Int -> Int -> Int -> Rectangle
04:17:27 <cryzed> I see, thank you
04:17:39 <arkeet> :)
04:17:54 <cryzed> :)
04:18:49 <pippijn> hi
04:18:57 <zett_zelett> â€™sup?
04:19:11 <pippijn> is there a "spawn"-like function that kills the child process when the parent dies?
04:19:49 <Lethalman> pippijn, isn't it already like that?
04:19:59 <pippijn> hmm
04:20:09 <maxpow4h> pippijn: are you using control.concurrent? (forkIO)
04:20:10 <pippijn> actually, maybe it is :)
04:24:06 <donri> any ideas for what to call the edges in a graph modeling a filesystem? ie. the slashes in a path representation, but "Slash" or "Separator" are weird names for a directed edge between two vertices...
04:24:07 <pippijn> I'm configuring xmonad
04:24:14 <pippijn> and I want to launch conky along with xmonad
04:24:24 <pippijn> but I want it to die and be restarted when xmonad is restarted
04:24:29 <pippijn> I don't know how xmonad does the restarting thing
04:24:38 <pippijn> but I end up with 2 conky processes when I do
04:25:07 <donri> maxs_: listA :: a b c -> a b [c]
04:26:25 <maxs_> donri: ah thanks!
04:26:25 <Entroacceptor> pippijn: easy fix would be to just have a killall conky in the xmonad startup
04:27:07 <Entroacceptor> pippijn: xmonad does a reload by restarting itself with the state serialized. So everything in main gets executed again, and I think even the startupHook
04:27:24 <jophish> yo yo yo
04:27:59 <jophish> I have some data in half float format. Am I correct in thinking that the only way to get this into a shader is with a vertex stream or a texture?
04:28:11 <jophish> i.e. uniforms can't have half-float data
04:29:06 <jophish> oops, not quite the right channel
04:29:13 <pippijn> Entroacceptor: ok, good enough for me
04:30:07 <xplat> donri: unix filesystems call that a 'link'
04:30:37 <pippijn> Entroacceptor: I think those things happen simultaneously.. the killall kills the new conky as well
04:30:39 <xplat> donri: though they attach the name part to it
04:30:58 <donri> xplat: i was considering link. a bit overloaded here though, you might think it's specifically about hard/symbolic links and their usual usages (ignoring details like "everything is a hardlink anyway")
04:31:10 <pippijn> is there a "spawn" that waits for the child to end?
04:31:42 <pippijn> ah
04:31:45 <pippijn> System.Cmd
04:33:02 <quicksilver> donri: "everything is a hardlink anyway" is a bit more than a detail, it's the basis of the model :P
04:33:06 <xplat> donri: unix is pretty hardcore on 'everything is really a hardlink', they even call removal 'unlink'
04:33:11 <quicksilver> donri: but you could use 'Contains' if you like verbs
04:33:32 <donri> quicksilver: nah i like nouns here methinks
04:33:43 <donri> i'll probably go with link
04:34:19 <xplat> other possibilities like 'subordinator' seem like they would make users sue you for their rsis
04:35:09 <donri> hah
04:35:49 <xplat> and 'edge' is a little too generic unless you're just augmenting a general graph library with filesystem-graph-specific extras
04:36:31 <donri> yeah, i'm currently using graph theory terminology but want to do away with it since it's too generic
04:41:15 <xplat> anyway i hope your library comes out well'
04:42:00 <xplat> i've honestly come to hate and dread any time i have to work with the filesystem, it's like the second biggest bug attractor next to unstructured-or-nullable pointers
04:42:28 <donri> \o/
04:44:03 <xplat> since any time you touch an FS you're writing concurrent code without realizing it and without any proper consistency support, not even correctly-working mutexes
04:44:51 <quicksilver> nah you worry too much, just do everything really quickly, what's the chance of anything going wrong?
04:44:54 <quicksilver> ;)
04:45:29 <donri> that's a race condition though. do the important things really quickly and the lesser things intentionally slowly!
04:46:45 <donri> i'm not sure my library will solve any concurrency issues though, although it might make it easier to do the right thing by encoding the semantics in the types ...
04:47:54 <xplat> anything that makes the right thing easier is good, right now the right thing is really hard
04:48:35 <donri> yeah :) [Char] is basically the worst imaginable type of filepaths :P
04:49:12 <Cradam> would i be correct in thinking that (foo, bar) <- get foobar, would be akin in a procedural language to foo = foobar[0]; bar = foobar[1]?
04:49:44 <donri> Cradam: kind of. sort of. more or less.
04:49:55 <Cradam> thanks
04:50:10 <Cradam> also, what's wrong with using strings for filepaths?
04:50:11 <donri> not sure you'd normally subscript a tuple, although python does that...
04:51:11 <AshyIsMe> well, async was easy
04:51:14 <FliPPeh> Something that's confusing me about monad stacks... let's take "type Stack = WriterT Foo (ReaderT Bar (StateT Baz IO))". Since each of those types requires a last parameter a but the complete type only takes a single last parameter, how does that work out in the end?
04:51:16 <quchen> Cradam: 1. String is slow. 2. "////hello world" is a string, but not a filepath. A type representing a file path should only be able to hold valid (or mostly valid) file paths.
04:51:31 <AshyIsMe> import Control.Concurrent.Async  and then change map to mapConcurrently
04:51:33 <AshyIsMe> wow
04:51:38 <FliPPeh> It seems to be interpretet as "WriterT Foo . ReaderT Bar . StateT Baz IO $ ..."
04:51:42 <Philonous> Well, ["foo/bar","quux"] would mean different things on different systems
04:51:42 <FliPPeh> Is that about right?
04:51:48 <donri> Cradam: what's right?! :) posix paths aren't unicode, path separators differ between platforms, the monoid isn't the most useful, the type is completely open with no structure so you can't do much validation...
04:52:09 <Cradam> quchen, it is a valid filepath, if you escape the space
04:52:19 <donri> spaces are valid
04:53:15 <Cradam> yeah, sorry, was thinking from a command line perspective
04:53:18 <quchen> If it's a filepath it's a very degenerate one. Plus you still have to parse the string to see what file it's referring to.
04:53:33 <quchen> For example that string does not say what's a directory and what's a file.
04:53:46 <quchen> What tells you it's not the file "/hello world" in "///"?
04:53:56 <Cradam> quchen, it means the "hello world" file/director in the root director
04:53:57 <Cradam> y
04:54:03 <quchen> If you're on Unix.
04:54:16 <Cradam> and windows
04:54:22 <quicksilver> FliPPeh: well, yes, but that's curiously backwards way of looking at it.
04:54:25 <quchen> What about TempleOS?
04:54:28 <Cradam> oh wait, // is computer name on windows
04:54:43 <quchen> OS/2?
04:54:55 <quicksilver> FliPPeh: (.) and ($) don't exist at the typelevel but what you intended it to mean is right, anyway
04:54:58 <AshyIsMe> it's the other slashes on windows
04:55:23 <quchen> "////hello world" as a filepath is as good as calling "draw a line from (0,0) to (1,1)" is a valid String representation of a picture.
04:55:44 <quicksilver> FliPPeh: howver, f (g (h x)) is the "fundamental" way of expressing nested application, "f . g . h $ x" is an expressing using combinators to mean the same thing.
04:57:13 <Cradam> quchen, for finding a file in a user readable way, it is fine, for finding the data on the disk, it is awful
04:57:13 <quchen> A much better alternative to encoding filepaths would be to make a distinction between files and directories. That would be something like "data FilePath = File FileName | Directory DirName (Maybe FilePath)".
04:58:10 <Cradam> quchen, or basically an enforced / on end directories?
04:59:04 <quchen> Cradam: It's much more. For example you can't make something like "/usr/bin/env/foobar" with that type, because it contains "foobar" in a subdirectory of a (non-directory) file.
04:59:42 <quchen> Cradam: For suitable "FileName" and "DirName" types, you can also avoid "/" in names.
05:00:16 <quchen> It's only convention that "/usr/bin/env" refers to "env in bin in usr" and not "bin/env in usr".
05:00:54 <quicksilver> quchen: it doesn't avoid that at all.
05:01:03 <quicksilver> you can obviously talk about /usr/bin/env/foobar
05:01:07 <quicksilver> since env might be a directory.
05:01:20 <quchen> quicksilver: That's why I picked a filename that is very commonly not a directory.
05:01:31 <quicksilver> what you can do is say "this value is *invalid* in a context where env is not a directory"
05:01:37 <qnikst> hello, how much it's incorrect to create Lift instance for type A that returns Q Exp, that creates an expression of type m A or even (A -> m b) -> m b ?
05:01:38 <quicksilver> but you haven't actually made it inexpressible
05:01:54 <qnikst> there is no docs about invariants that should hold..
05:01:54 <quicksilver> so I don't really see how that's any better than ["usr","bin","env","foobar"]
05:02:03 <quchen> I chose to use a universally known binary file to save me from writing 2 lines of disclaimers.
05:02:17 <quicksilver> sure but I don't understand what point you're making
05:02:26 <quicksilver> /usr/bin/env/foobar is obviously expressible by your data-type
05:02:36 <quicksilver> as it is expressible int he standard list of strings model
05:02:40 <quicksilver> so how is yours better?
05:02:50 <donri> quchen: in my library path is a free category and there is no morphism from File to Directory
05:02:54 <Philonous> quicksilver, It would prevent you from accidently appending more path components
05:03:54 <donri> this distinction doesn't really exist in the filesystem itself (on posix) but it's useful for humans, i expect
05:04:24 <quicksilver> Philonous: *nod*
05:05:31 <quchen> FWIW the list representation is already better than a plain-string representation
05:06:17 <donri> yep. a free category is actually just a list anyway, but matching the arrow types
05:12:13 * hackagebot strict-base-types 0.2.1 - Strict variants of the types provided in base.  http://hackage.haskell.org/package/strict-base-types-0.2.1 (SimonMeier)
05:12:34 <maikklein> I often see stuff that looks like ' core :: ((forall x. Lens (f x) x) -> a) -> f a'. What does the forall x. mean?
05:13:36 <Philonous> maikklein, It's a Rank 3 type
05:13:41 <quicksilver> it means that bit there in the middle is polymorphic and the value supplies there will work for any x.
05:13:43 <donri> maikklein: in this case, http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#universal-quantification
05:13:48 <quicksilver> any type x.
05:14:39 <maikklein> ah cool thanks
05:14:50 <donri> https://www.fpcomplete.com/user/PthariensFlame/guide-to-ghc-extensions/explicit-forall#rankntypes--rank2types--and-polymorphiccomponents
05:26:35 <Hafydd> I started a thread with forkIO in ghci, and control-c just terminated the main thread. Is there any way to terminate the other thread, short of exiting ghci?
05:31:11 <quicksilver> Hafydd: if you didn't save the ThreadId, I don't think there is.
05:32:24 <Hafydd> I see.
05:39:27 <fsfsww> what's the best way to represent a C union in Haskell?  is typeclass the right thing to use?
05:39:57 <simon> fsfsww, data Foo = Foo Int | Bar String
05:40:14 <simon> fsfsww, an algebraic type. whereas structs are represented by tuples/records.
05:41:50 <fsfsww> simon: thanks. I tried to use a product type in the past but bumped into some problems.  trying to remember the specifics.
05:41:55 <simon> data SomeStruct = SomeStruct { foo :: Int, bar :: String } deriving (...)
05:43:39 <ADexter> Can somebody tell me how to use the JP bindings to the repa lib properly. For some reason this: http://lpaste.net/96935 just gives me 255 instead of the proper green value for every index I've tested.
05:45:14 <julianb> Hi!. I'm trying to use ST along with Data.Array. I'm using a STUArray with Int indices and Bool elements, mostly because I'm interested in comparing those Bools. However, using unsafeRead, I get a value of type m Bool, which I can't compare to anything at all... is there any way to do that?
05:46:36 <twiceler> julianb: Have you learned about monads and do-notation yet?
05:47:51 <julianb> twiceler, that's what I'm trying to do
05:48:32 <twiceler> julianb: okay. I really like http://learnyouahaskell.com/a-fistful-of-monads as far as a general tutorial for learning monads
05:48:58 <twiceler> Basically, your code should look something like:
05:49:15 <julianb> twiceler, http://lpaste.net/96936 is my code
05:49:34 <twiceler> do { x <- readArray arr ix1; y <- readArray arr ix2; if x==y then expr1 else expr2 }
05:50:11 <julianb> oh, you misunderstood me. I'm trying to compare that m Bool with a Bool, rather than two m Bool
05:50:51 <twiceler> well then
05:51:08 <twiceler> do { x <- readArray arr ix1; if x=otherBool then expr1 else expr2 }
05:51:20 <twiceler> whoops that should be two == there
05:51:30 <Hafydd> Two ==, so ====
05:52:30 <julianb> well, I was actually trying to do something like when (unsafeRead arr i) (...). However, I'm getting a Couldn't match expected type `Bool' with actual type `m0 e0'
05:52:55 <twiceler> so I don't see what you're trying to do there
05:53:04 <twiceler> well, I don't know what unsafeRead is, actually
05:53:16 <twiceler> :t Data.Array.unsafeRead
05:53:17 <lambdabot> Not in scope: `Data.Array.unsafeRead'
05:54:12 <twiceler> do you mean to do readArray?
05:54:37 <julianb> it's in Data.Array.Base: unsafeRead :: (Ix i, MArray a e m) => a i e -> Int -> m e
05:55:46 <twiceler> julianb: Thanks. any reason that you're not using readArray instead?
05:56:20 <julianb> I just read somewhere that unsafeRead is faster
05:57:11 <twiceler> julianb: Probably true. I know this is off-topic a bit, but I'd suggest using readArray while you're developing your program. You can always switch to unsafeRead after
05:57:45 <julianb> Will do, thanks :). Never the less, the same thing happens with readArray
05:58:28 <fsfsww> simon: Ah, here's the problem. This is my product type: data Foo = Bar | Baz; type Foo = C'Foo; type Bar = C'Bar. C'Foo and C'Bar are instances of Storable, but I can't use peek and poke on Foo. Can I solve this without making Foo a Storable instance?
05:58:30 <twiceler> So instead you can do
05:59:13 <twiceler> julianb:  (readArray arr i >>= Control.Monad.when) $ forM_...
06:00:12 <julianb> oh
06:00:13 <julianb> that worked.
06:00:27 <twiceler> julianb: And of course, you could make your own combinator
06:00:42 <twiceler> julianb: when' :: m Bool -> m a -> ma
06:00:56 <twiceler> julianb: when' = (>>= Control.Monad.when)
06:03:32 <julianb> twiceler, thanks! that was very helpful
06:04:04 <twiceler> julianb: no problem!
06:04:11 <masonk> I wrote a wrapper around getDirectoryContents that returns full paths, and I wrote two wrapper functions around that one.  so I have getFiles, getDirectories, and getFilesAndDirectories.  can someone recommend a less verbose name for getFilesAndDirectories?
06:06:26 <Reite> Is there any point in compiling with -N >1 on an amazon instance with 1 virtual processor?
06:06:58 <julianb> I'm having another problem: in the last line, I do (filterM (unsafeRead arr) [0..bound]) and then I get a No instance for (MArray (STUArray s) Bool ((->) (ST s ())))
06:07:21 * hackagebot regex-deriv 0.0.4 - Replaces/Enhances Text.Regex. Implementing regular expression matching using Brzozowski's Deriviatives  http://hackage.haskell.org/package/regex-deriv-0.0.4 (KennyLu)
06:07:52 <twiceler> julianb: Same exact issue! Take a look at the type of filterM
06:07:58 <twiceler> :t Control.Monad.filterM
06:07:58 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
06:08:08 <twiceler> oh wait
06:09:06 <twiceler> I'd probably write something more like
06:09:33 <twiceler> filter id <$> sequence (readArray arr) [0..bound]
06:09:49 <twiceler> and certainly no "return" on that last line
06:09:56 <twiceler> since this code is already an action
06:10:08 <twiceler> note that f <$> x = fmap f x
06:10:49 <julianb> is there any advantage to using that filter rather than the one from Control.Monad?
06:11:22 <twiceler> twiceler: If you look at the types, you'll see that the Control.Monad isn't really what you want
06:11:45 <twiceler> Control.Monad.filterM takes a list of objects, and runs an action on each to see if they should stay
06:12:16 <twiceler> in your case, you're running an action just to *get* your list in the first place, and then you just want to keep the Trues...
06:12:43 <twiceler> where by "action" I mean (a -> m b)
06:13:16 <masonk> I wrote a wrapper around getDirectoryContents that returns full paths, and I wrote two wrapper functions around that one.  so I ended up with getFiles, getDirectories, and getFilesAndDirectories.  can someone recommend a less verbose name for getFilesAndDirectories?
06:18:14 <HeZzEl> nasonk: getEntries ?
06:23:12 <fsfsww> Could anyone advise on writing a Storable instance for a C union?
06:23:50 <quicksilver> pretty hard to do if it's untagged
06:25:24 <fsfsww> quicksilver: Yep, it's untagged. Moreover, it's embedded into a struct.
06:29:16 <Testeree> is there wayland binding for haskell or is there any work in progress?
06:29:38 <donri> masonk: aren't the latter two just filterM does{File,Directory}Exist?
06:30:16 <frerich> Hi all, I have some supposedly generic API question about Haskell which was triggered while trying to use the Haskell bindings for libgit2: the bindings define various types (see https://github.com/fpco/gitlib/blob/master/gitlib/Git/Types.hs ) and in particular there's a 'Repository' class. I tried to figure out why this is a class instead of a plain data type, does anybody know?
06:30:50 <frerich> The only plausible type to pass for 'm' seem to be 'IO' to me, so that e.g. 'deleteRepository' is an 'IO ()', but I wonder - are there other plausible values? Why would something like the IO monad get abstracted away?
06:31:34 <donri> masonk: and the first one, mapM canonicalizePath?
06:32:23 <donri> Testeree: no hits for wayland on hackage...
06:33:51 <quicksilver> donri: there is a race condition with that approach
06:34:01 <quicksilver> mind you tehre are always race conditions with filesystem stuff..
06:34:05 <donri> :)
06:35:23 <masonk> donri more or less that's how you would implement them yes (just canonicalizePath won't work, though).
06:35:24 <donri> quicksilver: is there a non-racey way to do it without posix deps?
06:35:34 <donri> windows, ruining portability since '85
06:36:19 <masonk> mapM will add current directory to form a full path, rather than the path you sent to getDirectoryContents
06:36:38 <donri> yes
06:38:12 <Testeree> is there no haskeller who hacks on modern linux graphics? it is strange to find no bindings for haskell, since wayland seems to be an important project for linux graphics stack.
06:39:10 <donri> wayland will be important. it isn't necessarily important right now. FSVO ;)
06:40:10 <Philonous> Testeree, Have you tried searching on github?
06:42:10 <notdan> yeah, I didn't got the impression that wayland is the Next Big Thing out there,to be honest
06:42:31 <Testeree> Philonous: nothing there either,  donri: wayland has hit version 1.3.1 and many distros are already considering making it default display server.
06:43:42 <Testeree> btw, a funky demo of wayland http://www.youtube.com/watch?v=_FjuPn7MXMs
06:44:53 <donri> Testeree: not arguing that there should be bindings. but no one is using wayland by default yet so there's little pressure to support it. bindings will surely come. why don't you write one? :)
06:45:53 <Testeree> donri: i could try, but i am no expert on ffi. :S
06:46:06 <donri> great opportunity to become one! :)
06:46:13 <Philonous> FFI isn't that hard.
06:46:19 <Philonous> If you know some C
06:47:18 <donri> https://github.com/jwiegley/c2hsc might be a starting point
06:49:39 <Testeree> donri: i do know c and haskell, i'll try now.
06:50:14 <donri> http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html might be worth a read
06:52:16 <m1dnight_> quick question
06:52:20 <m1dnight_> is (+2) a monoid value?
06:52:59 <m1dnight_> i mean, can I mappend it to (+3) or something
06:53:00 <donri> :t (+2) `asTypeOf` mempty
06:53:01 <lambdabot> (Num a, Monoid a) => a -> a
06:53:03 <m1dnight_> oh
06:53:06 <m1dnight_> i can test it like that
06:53:07 <m1dnight_> cool :)
06:53:09 <m1dnight_> even better!
06:53:19 <donri> well it doesn't resolve instances
06:53:39 <fizbin> > mempty `asTypeOf` (+2)
06:53:40 <lambdabot>  No instance for (Data.Monoid.Monoid a0)
06:53:40 <lambdabot>    arising from a use of `e_12'
06:53:40 <lambdabot>  The type variable `a0' is ambiguous
06:53:40 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
06:53:40 <lambdabot>  Note: there are several potential instances:
06:53:45 <m1dnight_> oh
06:53:53 <fizbin> So, no. Not a monoid
06:54:00 <m1dnight_> because I don't really get how: F.foldl (+) 0 testTree works
06:54:07 <m1dnight_> foldl over a tree should return a monoid value
06:54:21 <fizbin> Or maybe I should add more types...
06:54:23 <m1dnight_> (well, looking at the foldMap implementation that is)
06:55:49 <donri> m1dnight_: foldmap /= foldl
06:55:49 <fizbin> > mempty `asTypeOf` ((+2) :: Int -> Int)
06:55:49 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Int)
06:55:49 <lambdabot>    arising from a use of `Data.Monoid.mempty'
06:55:49 <lambdabot>  Possible fix:
06:55:49 <lambdabot>    add an instance declaration for (Data.Monoid.Monoid GHC.Types.Int)
06:55:49 <m1dnight_> it's not really clear from the book
06:55:49 <m1dnight_> donri: yeah I just noticed that
06:55:50 <fizbin> Okay, not a monoid.
06:55:50 <m1dnight_> but it's based on the foldMap implementation
06:55:50 <fizbin> At least not with anything lambdabot knows about.
06:55:50 <m1dnight_> hmm
06:55:50 <donri> > mempty `asTypeOf` ((+2) :: Sum Int -> Sum Int)
06:55:50 <fizbin> > fail "d" `asTypeOf` ((+2) :: Int -> Int)
06:55:50 <lambdabot>  No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
06:55:50 <lambdabot>    arising from a use of `GHC.Num.+'
06:55:50 <lambdabot>  Possible fix:
06:55:50 <lambdabot>    add an instance declaration for
06:55:50 <lambdabot>    (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
06:55:50 <lambdabot>  <Int -> Int>
06:56:26 <fizbin> > return 4 `asTypeOf` ((+2) :: Int -> Int)
06:56:27 <lambdabot>  <Int -> Int>
06:57:28 <donri> (+2) is a perfectly valid monoid, just not for any type in base. i think.
06:57:54 <donri> (but, you could trivially derive Num for Sum, for example)
07:00:41 <donri> m1dnight_: oh well, that's using the Endo monoid
07:01:35 <donri> > appEndo (Endo (+2) <> Endo (+3)) 4
07:01:36 <lambdabot>  9
07:02:05 <donri> > ((+2) . (+3)) 4
07:02:06 <lambdabot>  9
07:02:21 <Testeree> donri: c2hs /c2hsc?
07:03:03 <donri> m1dnight_: id and (.) is a monoid when composing functions where the source and target is the same type, ie. a -> a
07:03:21 <donri> Testeree: yeah, there's a lot of confusingly named tools here :(
07:03:24 <Hodapp> man, every time I solve something in Haskell, I look back at it and realize that Haskell already solved half my problem, if I'd just remember silly functions like 'iterate'.
07:03:42 <kuribas> If I need a monad for IO, parsing and state, should I stack transformers, or make my own monad?  I could also use IORefs for the state.
07:03:53 <donri> Testeree: hsc2hs generates haskell with ffi code from a dialect of haskell with special annotations
07:04:14 <donri> Testeree: c2hsc generates hsc files from c headers
07:04:40 <notdan> kuribas: I'd stack transformers
07:05:45 <kuribas> If I have a large global state, is record update inefficient for memory?
07:06:02 <donri> Testeree: c2hs i'm not 100% sure how it compares but i think it's like a middle-ground between those two others. you still write the annotations, but with less boilerplate and more safety / automatic checking.
07:06:11 <donri> Testeree: http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/
07:07:34 <Testeree> *greencard* is throwing 404
07:07:50 <donri> Testeree: http://hackage.haskell.org/package/greencard
07:08:04 <donri> i don't know anything about it though
07:08:47 <Testeree> ok
07:15:36 <ghorn> should it always be possible to get GC time down below say 10%, or are there cases when it just isn't feasible?
07:17:29 <fsfsww> quicksilver: Turns out I was mistaken.  Indeed, I'm dealing with a tagged union.  The first field of the struct allows to determine the type of the second field (which is a union).  Any examples of writing Storable instances for such structs?
07:18:33 <guest_123> I'm trying to code golf a little, can anybody improve the following function for me please? It's used as the function to fold over a Vector of Maybe pairs:
07:18:34 <guest_123> best p1 Nothing = p1; best p1@(_,v1) (Just p2@(_,v2)) = if v1 >= v2 then p1 else p2
07:19:00 <guest_123> for a start while there's a maximumBy there doesn't seem to be a maxBy that operates on just two elements
07:23:21 <guest_123> I guess something like `best p1 = maybe p1 (maxBy (comparing snd) p1' would work
07:24:31 <guest_123> where maxBy f a b = maximumBy f [a,b]
07:31:28 <maikklein> what do I do if I get "Ambiguous module name `Graphics.UI.GLFW':  it was found in multiple packages: GLFW-b-1.4.2 GLFW-0.5.2.0"?
07:31:43 <Hafydd> @ty best p1 Nothing = p1; best p1@(_,v1) (Just p2@(_,v2)) = if v1 >= v2 then p1 else p2
07:31:43 <maikklein> do I then need to use cabal for building it?
07:31:43 <lambdabot> parse error on input `='
07:31:54 <Hafydd> @ty let best p1 Nothing = p1; best p1@(_,v1) (Just p2@(_,v2)) = if v1 >= v2 then p1 else p2 in best
07:31:55 <lambdabot> Ord a => (t, a) -> Maybe (t, a) -> (t, a)
07:33:01 <merijn> guest_123: I remember suggesting the addition of maxBy to the standard library, but don't remember why it was shot down
07:33:02 <Hafydd> guest_123: I don't see what your function has to do with Vectors.
07:33:45 <guest_123> Hafydd: it's used like `V.foldl' best (empty, 0) someVec'
07:33:55 <merijn> maikklein: It means you have two different GLFW versions installed and GHC doesn't know which one you're trying to impor
07:34:06 <guest_123> it is the function to be folded
07:34:13 <merijn> maikklein: There was an extension that lets you specify in the import statement which to use, but I forgot the name
07:34:34 <Hafydd> Oh.
07:35:07 <guest_123> -XPackageImports?
07:35:28 <maikklein> merijn, the easiest thing would probably to build it with cabal right? Then I can specify what packages I import, I think
07:35:56 <guest_123> merijn: one thing to note is that `maximumBy f' doesn't want to be defined in terms of `maxBy f' because then you have to constantly pass 'f' around rather than using the one in scope
07:37:12 <Hafydd> best p1 p2 = maximumBy (comparing snd) $ p1 : maybeToList p2
07:39:07 <guest_123> @pl best p1 p2 = maximumBy (comparing snd) (p1 : maybeToList p2)
07:39:07 <lambdabot> best = (maximumBy (comparing snd) .) . (. maybeToList) . (:)
07:39:28 <merijn> maikklein: Cabal will just pick 1, yes
07:39:48 <lingxiao> hey all I have a question concerning prudent use of typeclass
07:39:50 <guest_123> @pl bestp1 p2 = maximumBy (comparing snd) (p1 : maybeToList p2)
07:39:50 <lambdabot> bestp1 = maximumBy (comparing snd) . (p1 :) . maybeToList
07:41:23 <lingxiao> If I have three types: HType, Tyvar, and Tycon
07:41:37 <guest_123> thanks Hafydd, I like that better than my version
07:41:40 <lingxiao> and all three carry some "kind" information, expressed by datatype Kind
07:41:52 <masonk> guest_123 is this real code? why does best compare a pair and a Maybe pair, instead of two pairs?
07:41:53 <lingxiao> and I want some function that will read the "kind" of all three datatypes,
07:42:21 <lingxiao> one solution is to to have some typeclass `class Kinded t where kind :: t -> Kind`
07:42:59 <lingxiao> is this a good usecase for typeclass? does it make sense to overload "kind" function this way?
07:43:46 <asdf1234> oh lord.. are we diving into pseudo-dependently-typed haskell again?
07:44:14 <guest_123> masonk: it is, I have a vector :: Vector (Maybe (a, Int)) and I want to find the a corresponding to the highest Int. If it were a list I'd use catMaybes - is there one for foldable or traversable? And even then I'd have to trust that it'd be fused
07:44:50 <guest_123> I mean for lists then the whole function would be: maximumBy (comparing snd) . catMaybes
07:45:22 <guest_123> it it ok to just call Data.Vector.toList in this case? I'm traversing it all once anyway
07:46:04 <Hafydd> @ty let best = curry $ maximumBy (comparing snd) . uncurry (:) . fmap maybeToList in best
07:46:05 <lambdabot> Ord a => (a1, a) -> Maybe (a1, a) -> (a1, a)
07:57:34 * hackagebot haskoin-util 0.0.1 - Utility functions for the Network.Haskoin project  http://hackage.haskell.org/package/haskoin-util-0.0.1 (PhilippeLaprade)
07:59:00 <Fuuzetsu> When using cabal sandboxes, how can I temporarily work out of a sandbox? I need to install what I'm working on for now and I don't want to destroy the sandbox just to do that
08:11:54 <jophish> Yo yo yo
08:12:46 <jophish> I have a list, and I'd like to return this list with a particular member removed and another one added in its place. Where the other one is a a function applied to the removed member
08:13:00 <jophish> essentially, I'd like to mutate an element
08:13:07 <jophish> what's the idiomatic way of doing this?
08:13:15 <jophish> I can't seem to find a really nice solution
08:13:41 <supki> > [1..10] & ix 3 *~ 7
08:13:42 <lambdabot>  [1,2,3,28,5,6,7,8,9,10]
08:13:44 <jophish> For example, I have list of tuples, keys and values, and I'd like to change the value at a particular key
08:13:53 <jophish> lenses?
08:13:56 <supki> use a Map
08:14:10 <dcoutts> or a Sequence
08:14:26 <jophish> supki: the map example was just an example
08:14:52 <jophish> how would lenses work for the map example?
08:15:35 <supki> > M.fromList [(1, 2), (3, 4)] & ix 1 *~ 7
08:15:36 <lambdabot>  fromList [(1,14),(3,4)]
08:16:36 <supki> > [(1, 2), (3, 4)] & wrapping M.fromList.ix 1 *~ 7
08:16:37 <lambdabot>  [(1,14),(3,4)]
08:17:37 * hackagebot yi-monokai 0.1.1.0 - Monokai colour theme for the Yi text editor  http://hackage.haskell.org/package/yi-monokai-0.1.1.0 (MateuszKowalczyk)
08:19:21 <jophish> > over (_find ((==1) . fst)) (*7) [(1,2),(3,4)]
08:19:22 <lambdabot>  Not in scope: `_find'
08:19:22 <lambdabot>  Perhaps you meant one of these:
08:19:22 <lambdabot>    `ifind' (imported from Control.Lens),
08:19:22 <lambdabot>    `BS.find' (imported from Data.ByteString),
08:19:22 <lambdabot>    `BSL.find' (imported from Data.ByteString.Lazy)
08:19:52 <jophish> @msg lambdabot >over (ifind ((==1) . fst)) (*7) [(1,2),(3,4)]
08:19:53 <lambdabot> Not enough privileges
08:20:01 <Fuuzetsu> Check your privilege
08:20:22 <Fuuzetsu> Anyway, it seems I was lied to yesterday! Hackage only seems to list a package in the â€˜Categoriesâ€™ based on the latest package version.
08:20:41 <Kron> what DOES 'idiomatic' mean anyway?
08:20:50 <Kron> There's a lot of talk about haskell idioms
08:21:14 <jophish> Kron: a way of doing things so that people think I'm really good at haskell
08:21:21 <jophish> :)
08:21:58 <Kron> gotcha
08:22:13 <Kron> (.:) = fmap fmap fmap
08:22:37 * hackagebot yi-monokai 0.1.1.1 - Monokai colour theme for the Yi text editor  http://hackage.haskell.org/package/yi-monokai-0.1.1.1 (MateuszKowalczyk)
09:21:47 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
09:21:47 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:31 2013]
09:23:14 <deech> Is there a way to tell the oldest version of GHC that supported a feature? Specifically record field disambiguation.
09:23:56 <quchen> I don't think so. A similar problem is finding the minimal version of a library you depend on that still allows you to compile your code.
09:24:37 <bergmark> would be nice if the users guide included this
09:25:16 <quchen> GHC itself can usually be compiled with the two previous major releases.
09:25:33 <donri> it's usually listed in the release notes part of the users guide, which only covers the relevant version so you have to go dig each
09:27:28 <donri> (which is here http://www.haskell.org/ghc/docs/ btw)
09:27:36 <zett_zelett> Is there a builtin haskell function for \x -> [x]?
09:27:59 <shiona> zett_zelett: pure / return
09:28:18 <donri> i got lucky: http://www.haskell.org/ghc/docs/6.8-latest/html/users_guide/release-6-8-1.html
09:28:32 <donri> "There is a new record field disambiguation extension"
09:28:45 <intrados> Is there a way to get quickcheck to sort of print the values on both sides of a ==?
09:28:56 <intrados> In the case of failure
09:29:23 <donri> intrados: http://hackage.haskell.org/package/QuickCheck-2.6/docs/Test-QuickCheck.html#g:15
09:31:17 <zett_zelett> shiona: So how do I call (\x -> [x]) on 2 in ghci?
09:31:35 <zett_zelett> If I donâ€™t want to use an anonymous function?
09:31:40 <donri> > return 2 :: [Int]
09:31:41 <lambdabot>  [2]
09:31:48 <donri> > (:[]) 2
09:31:49 <lambdabot>  [2]
09:32:06 <zett_zelett> Ah.
09:32:24 <zett_zelett> And how can I use it as an argument for â€“ say â€“ fold?
09:32:24 <shiona> I was way late
09:32:43 <donri> same way
09:32:52 <donri> it's all HOFs
09:34:07 <zett_zelett> HOF? And, I donâ€™t see how it might be possible the same way, because, what is the function here, 'return :: [Int]'?
09:34:13 <joelteon> return
09:34:19 <allsystemsarego> :t evalState
09:34:20 <lambdabot> State s a -> s -> a
09:34:43 <donri> zett_zelett: the type signature is only needed if the types isn't known to want a list
09:35:39 <zett_zelett> I donâ€™t get it.
09:36:02 <zett_zelett> What I want to do is just write down `map (\x -> [x]) [1..5]' more elegantly.
09:36:10 <quchen> > return 2                          :: [Int] -- ;-)
09:36:12 <lambdabot>  [2]
09:36:14 <donri> zett_zelett: id :P
09:36:49 <quchen> > map pure [1..5]         :: [[Int]]
09:36:50 <lambdabot>  [[1],[2],[3],[4],[5]]
09:36:57 <zett_zelett> Ah.
09:36:58 <donri> oh right
09:37:00 <zett_zelett> Okay.
09:37:11 <quchen> donri: For id from Kleisli ;-)
09:37:26 <donri> i was thinking of concatMap
09:37:55 <donri> @check \xs -> concatMap (:[]) xs == id xs
09:37:56 <lambdabot>  +++ OK, passed 100 tests.
09:38:38 <donri> > concatMap return [1..5]
09:38:39 <lambdabot>  [1,2,3,4,5]
09:38:49 <donri> one example where the type can be inferred, incidentally
09:40:52 <donri> is this the list cobind btw? :D
09:40:53 <zett_zelett> Anyway, thans!
09:41:24 <donri> as in duplicate for the list comonad-without-extract
09:41:57 <quchen> I think duplicate xs = map (const xs) xs
09:42:45 <donri> hmm let's see what the nonempty comonad does
09:42:52 <quchen> Something different.
09:43:12 <quchen> duplicate = tails there I think
09:43:25 <quchen> Well there are many implementations of duplicate when you're not bound to the Comonad laws because you can't write a Comonad instance ;-)
09:43:28 <donri> yeah that makes sense
09:43:46 <donri> given there's probably a law around how extract and duplicate relate
09:44:00 <quchen> Right. extract . duplicate = id iirc.
09:44:07 <allsystemsarego> @check \n -> sum [1..n] ^ 2 == \n -> sum . map (^3) $ [1..n]
09:44:08 <lambdabot>  No instance for (Test.QuickCheck.Arbitrary.Arbitrary c0)
09:44:08 <lambdabot>  arising from a use of `Lambdabot.Plugin.Haskell.Check.ShowQ.myquickcheck' Th...
09:44:09 <donri> and extract is head, right?
09:44:20 <quchen> @check \n -> sum [1..n] ^ 2 == sum . map (^3) $ [1..n]
09:44:21 <lambdabot>  Couldn't match expected type `[[c0] -> c0] -> t0'
09:44:21 <lambdabot>  with actual type `GHC.Types.Bool'
09:44:28 <quchen> donri: Yes
09:45:00 <quchen> > tails [1..3]
09:45:01 <lambdabot>  [[1,2,3],[2,3],[3],[]]
09:45:06 <donri> > Control.Comonad.duplicate (Data.List.NonEmpty [1,2,3])
09:45:08 <lambdabot>  Not in scope: `Control.Comonad.duplicate'
09:45:08 <lambdabot>  Perhaps you meant `Control.Monad.replicateM' (imported from Control.Monad)No...
09:45:09 <donri> :(
09:47:16 <mm_freak_> head and rotations make a valid comonad for non-empty lists
09:47:20 * donri still haven't learned to recognize situations where comonads would help
09:47:34 <donri> i take edwardk's word for it though because amaze, so mathmatcal
09:47:34 <mm_freak_> duplicate "abc" = ["abc", "bca", "cab"]
09:47:58 <quchen> donri: I told someone about zippers and he said "wait is that a comonad" - that taught me one thing: if there's an easy 'extract', ask for 'duplicate' :-)
09:48:16 <mm_freak_> donri: as always it's about function application
09:48:19 <identity> donri: haha. :)
09:48:21 <identity> i saw that one
09:48:26 <mm_freak_> functor:  (a -> b) -> f a -> f b
09:48:36 <mm_freak_> applicative:  f (a -> b) -> f a -> f b
09:48:42 <mm_freak_> monad:  (a -> f b) -> f a -> f b
09:48:48 <mm_freak_> comonad:  (f a -> b) -> f a -> f b
09:48:53 <donri> certainly, but i haven't quite built the intuition for how head+tails are useful alone together, so to speak
09:49:02 <mm_freak_> depending on what's the pattern of your function application, you pick the abstraction =)
09:49:18 <donri> "alone together", proud of that one
09:49:21 <mm_freak_> donri: do you understand store comonads?
09:49:50 <quchen> Store is (s -> a, s), right?
09:49:55 <mm_freak_> yeah
09:50:20 <mm_freak_> for education purposes Store is to Comonad what Reader is to Monad =)
09:50:22 <donri> mm_freak_: i think i did when i last looked at it :) i understand comonad itself, just don't reflexively recognize when something is comonadic i guess
09:50:38 <mm_freak_> donri: let me rename Store then
09:50:44 <mm_freak_> PictureWithPointerToACertainPixel
09:51:02 <quchen> PWPTACP for brevity and readability!
09:51:03 <identity> mm_freak_: so that's a zipper?
09:51:17 <mm_freak_> identity: no, it's a pointer in the direct sense
09:51:31 <mm_freak_> data Picture s a = Picture s (s -> a)
09:51:55 <mm_freak_> 'extract' gives you the pixel at the pointer
09:52:27 <mm_freak_> but more interestingly, 'extend' allows you to extend a pixelwise filter to a whole picture
09:52:39 <mm_freak_> blurPixel :: Picture s a -> a
09:52:51 <mm_freak_> well
09:52:54 <donri> hmm the obvious just clicked for me btw: that the "head" of each list in "tails" is the "next" list item of the original
09:52:58 <mm_freak_> blurPixel :: Picture s RGB -> RGB
09:53:35 <mm_freak_> blurs the pointed pixel (returns the target color)
09:53:47 <reizuki> do we have a bot who understands !seen command?
09:53:49 <mm_freak_> then:  extend blurPixel :: Picture s RGB -> Picture s RGB
09:53:50 <reizuki> like
09:53:53 <reizuki> !seen nadirs
09:53:57 <reizuki> i guess not
09:53:58 <quchen> preflex: seen nadirs
09:53:59 <preflex>  nadirs was last seen on #haskell 2 days, 20 hours, 20 minutes and 11 seconds ago, saying: I've read that post and it was quite convincing
09:54:08 <reizuki> thanks
09:54:19 <donri> @check \xs -> map head (init (tails xs)) == id xs
09:54:21 <lambdabot>  +++ OK, passed 100 tests.
09:56:00 <quchen> duplicate (Store f x) = Store (Store f) x?
09:57:04 <donri> hey is that the extende extract = id law
09:57:30 <quchen> fmap extract . extend = id?
09:57:36 <quchen> Eh, duplicate
09:58:02 <quchen> Oh wait, I see.
09:58:08 <donri> yeah, aka. map head (tails xs)  (but we need init because we're not non-empty)
10:00:13 <donri> and yep it holds for mm_freak_'s rotation comonad
10:01:29 <mm_freak_> donri: that's because [a] is isomorphic to Store Int a
10:01:45 <mm_freak_> i've just reinterpreted Store's duplicate =)
10:04:27 <identity> where is it customary to put one's test suite in one's project's directory layout?
10:04:37 <identity> top level? call it testsuite or just tests or doesn't it matter?
10:04:50 <donri> i put them under test/
10:05:28 <donri> people seem to like to call it "tests" but i find that inconsistent with other standard directories personally
10:05:36 <identity> okay
10:06:02 <donri> the perl community seems to have standardized on "t/*.t", heh
10:09:12 <identity> given that I have my code split into different modules and so on, do I write one test file for each source code file and create TestSuite test-.. for each in the cabal file?
10:09:27 <identity> or do I have multiple test files but one main test file that runs all of the tests?
10:10:40 <quchen> donri: Because it's brief and unreadable?
10:11:05 <donri> that's up to you. if you're using a test framework it might be easier to just have one test-suite. if not, it might be easier to have separate suites for separate runners like quickcheck and hunit etc
10:11:09 <donri> quchen: :)
10:11:31 <identity> I was going to use both quickcheck and hunit most likely.
10:15:45 <Philonous> identity, hspec and tasty both are able to combine hunit and quickcheck tests into a single test suite
10:16:06 <identity> Philonous: I see.
10:18:03 <identity> hspec looks nice
10:18:07 <identity> think I'll try that out
10:19:09 <Philonous> identity, There's lots of glue code on hackage so you can mix and match pretty freely
10:19:42 <identity> yeah, it would seem so indeed
10:19:56 <identity> but I like hspec's DSL, so to speak
10:19:58 <identity> describe, etc
10:32:54 * hackagebot Spock 0.3.0.0 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.3.0.0 (AlexanderThiemann)
10:40:53 <m-r-r> Hello
10:41:39 <m-r-r> Is it possible to write a program with plugins in Haskell ?
10:42:27 <sm> yes.. though less easy than in some languages
10:43:03 <haasn> I think the best approach is xmonad's
10:43:16 <m-r-r> sm: Do you know examples of programs doing that ?
10:44:56 <m-r-r> haasn: embedding a compiler ?
10:45:03 <tac> Plugins are naturally more difficult in typed languages because historically, types were invented to prevent the circularity you get from metaprogramming (in the context of logic)
10:45:30 <haasn> m-r-r: having the user customize the program's actual main .hs file. it doesn't necessarily have to be dynamically reconfigurable imo
10:45:37 <haasn> (which is what invokes the compiler dependency)
10:46:12 <m-r-r> haasn: but the users of my program won't be haskell coders :-/
10:47:31 <mangaba_leitosa> what does 'write a program with plugins' mean?
10:47:51 <mangaba_leitosa> I don't understand 'plugins' in this context
10:48:44 <m-r-r> Is it possible to load an external .so file containing callback functions, and call those callbacks ?
10:50:15 <mangaba_leitosa> ah, now I see what you mean, thanks. Not that I know the answer.
10:50:57 <piezoid> m-r-r: http://hackage.haskell.org/package/plugins
10:51:20 <piezoid> m-r-r: I've never tried to use it...
10:53:39 <ReinH> carter: current emacs status: I have no idea what I'm doing.
10:53:58 <piezoid> m-r-r: it's used by Happstack for code reloading : https://hackage.haskell.org/package/happstack-plugins
10:54:44 <m-r-r> piezoid: The 'plugin' package seems interesting, thanks :-)
10:56:10 <m-r-r> piezoid: In fact, i'm trying to avoid adding a lot of dependencies, so i'd rather not use Happstack
10:56:34 <jle`> > mempty 1 2 3 4 5 :: [Int]
10:56:35 <lambdabot>  []
10:56:52 <jle`> heh
10:56:59 <m-r-r> piezoid: but the module 'System.Plugins.Load' seems capable of loading object files at runtime
10:58:09 <Philonous> jle`, instance Monoid b => Monoid (a -> b)
10:58:30 <m-r-r> m-r-r: so, i think i will try using it
10:58:48 <jle`> Philonous: it's cool that mempty seems to be a variable-arity black hole function
10:59:01 <Philonous> > mempty "hello" True 7.3 :: [Int]
10:59:02 <lambdabot>  []
10:59:15 <m-r-r> Thanks, anyway :-)
11:00:29 <Philonous> jle`, There's a different mempty for every function type. So it's not really variable arity
11:00:36 <erisco> I am implementing cyclic graph functions and I need a way to keep track of vertices already visited. What is the most ideal data structure for this given that vertices are identified by a unique Int?
11:00:55 <Philonous> > let f = mempty in (f 1, f 1 2)
11:00:57 <lambdabot>  ((),())
11:01:30 <Cale> erisco: IntSet?
11:02:04 <erisco> Cale, this may work well. thanks
11:02:11 <jle`> didn't realize that () was a monoid
11:02:35 <jle`> in haskell at least
11:02:36 <Philonous> > let f = mempty in (f 1, f 1 2) :: ([Int], [Int])
11:02:37 <lambdabot>  ([],[])
11:02:43 <erisco> jle` neither did I but I suppose it is in a trivial way
11:02:58 * hackagebot git-annex 5.20131213 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20131213 (JoeyHess)
11:03:07 <Philonous> Ah, I keep forgetting that let binding are polymorphic
11:03:11 <jle`> i mean i guess {0} is the trivial monoid in maths
11:03:33 <jle`> Philonous: they aren't always
11:03:54 <jle`> let f = 1 in (1/2, 1 `div` 2)
11:04:03 <jle`> > let f = 1 in (f/2, f `div` 2)
11:04:04 <lambdabot>  (0.5,0)
11:04:13 <jle`> oh
11:04:27 <haasn> there's no monomorphism restriction on let bindings
11:04:28 <Philonous> > (\f -> (f 1, f 1 2) :: ([Int], [Int])) mempty
11:04:29 <lambdabot>  Couldn't match expected type `a1 -> [GHC.Types.Int]'
11:04:29 <lambdabot>              with actual type `[GHC.Types.Int]'
11:04:32 <jle`> well it doesn't work on ghci if i put them on different lines >>
11:04:34 <Philonous> There we go
11:04:50 <jle`> @let one = 1
11:04:52 <lambdabot>  Defined.
11:04:59 <jle`> > one / 2
11:05:02 <lambdabot>  0.5
11:05:04 <jle`> > one `div` 2
11:05:06 <lambdabot>  0
11:05:15 <jle`> i guess lamdabot has no monomorphism restriction
11:05:36 <jle`> but without extensions ghci complains for me
11:05:39 <Philonous> > (\one -> (one / 2, one `div` 2)) 1
11:05:40 <lambdabot>  No instance for (GHC.Show.Show t0)
11:05:40 <lambdabot>    arising from a use of `M24274458125443965730881.show_M24274458125443965730...
11:05:40 <lambdabot>  The type variable `t0' is ambiguous
11:05:40 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
11:05:40 <lambdabot>  Note: there are several potential instances:
11:06:34 <mangaba_leitosa> is there something more usable than Data.Graph? I would like to build a graph from a list of edges [(t, t)] and Data.Graph only has graphFromEdges which takes [(t, key, [key])] or buildG taking [(Int, Int)]. Neither seems convenient
11:07:31 <erisco> mangaba_leitosa, I am attempting to model automatons using graphs, and my assessment of the graph module is that it is not ideal for this
11:07:49 <mangaba_leitosa> erisco: what are you using instead?
11:07:58 * hackagebot git-repair 1.20131213 - repairs a damanged git repisitory  http://hackage.haskell.org/package/git-repair-1.20131213 (JoeyHess)
11:08:26 <erisco> mangaba_leitosa, it is inconvenient to have cyclic structures of that complexity in Haskell. I am writing what I need myself
11:08:35 <mangaba_leitosa> erisco: I see...
11:10:12 <erisco> mangaba_leitosa, it is about pulling off a trick called "tying the knot". This is trivial in let x = 1: x in x, but more complicated when you have to tie the knot in recursive algorithms
11:10:39 <Cale> mangaba_leitosa: I've always used Data.Map or Data.IntMap to store adjacency information whenever I need cyclic graph structures
11:11:01 <Cale> Map Vertex (Set Vertex) is a reasonable first approximation to what you'd use.
11:11:20 <Cale> (obviously, you'd usually end up decorating that with more information)
11:11:34 <erisco> you can make compromises as Cale suggests, but you will increase the time complexity of your algorithm
11:11:49 <Cale> Not by a significant amount
11:11:54 <mangaba_leitosa> hmm
11:12:01 <erisco> if you are lucky just an additional factor of logn
11:12:06 <Cale> It's a log factor, and the constant factor is good
11:12:22 <mangaba_leitosa> but a graph represented as a list of edges [(Vertex, Vertex)] is not exactly a cyclic structure :-)
11:12:59 * hackagebot ViennaRNA-bindings 0.1.0.0 - ViennaRNA v2 bindings  http://hackage.haskell.org/package/ViennaRNA-bindings-0.1.0.0 (ChristianHoener)
11:12:59 <Cale> mangaba_leitosa: It's as good as one.
11:13:08 <Cale> If you can do lookups quickly
11:13:21 <Cale> A *list* of edges is bad for that reason
11:13:30 <Cale> But Data.Map doesn't have that problem
11:13:54 <haasn> HashMap :)
11:13:57 <erisco> mangaba_leitosa, correct, it is not cyclic. the difference is whether it is physically cyclic (the references in memory are cyclic) or logically cyclic
11:14:11 <mangaba_leitosa> Cale: I have a function that uses a list of edges and was curious if it would work better if I use a specialized module for graphs... Then looked at Data.Graph and was surprised to find out that it cannot build a graph directly from my list
11:14:43 <mangaba_leitosa> "better" = faster
11:15:02 <Cale> HashMap is just as likely to be worse than Map/IntMap in my experience as it is to be better.
11:15:03 <quchen> A list of type [(Vertex, Vertex)] can represent a cyclic structure, even in memory.
11:15:39 <quchen> let (a,b,c) = (Vertex foo, ...) in [(a,b), (b,c), (c,a)] -- Cyclic graph.
11:16:21 <erisco> quchen, this is very different than the Vertex ADT itself holding reference to other vertices
11:16:29 <mangaba_leitosa> quchen: yes, it's a cyclic graph, is the data structure representing it also cyclic?
11:16:49 <mangaba_leitosa> quchen: it consists of a list of 3 distinct elements
11:17:09 <quchen> As does a graph made up of 3 vertices.
11:17:19 <quchen> Or better one with 3 edges.
11:17:59 * hackagebot cabal-install-bundle 1.18.0.2 - The (bundled) command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-bundle-1.18.0.2 (BartoszCwiklowski)
11:18:55 * mangaba_leitosa is confused. I thought that the linked list structure is not cyclic, whatever logical concepts you use to represent with it
11:18:55 <quchen> [(V,V)] is "data Graph = End | Edge Vertex Vertex Graph".
11:19:36 <mangaba_leitosa> well, unless it's let l = hd:l
11:20:04 <erisco> quchen, the difference is that you can modify the graph without modifying the data stored in the vertices (one instead modifies the transition function), but I imagine you'd run into similar difficulties
11:20:13 <erisco> quchen, an interesting take
11:20:26 <quchen> A linked list consists of a value and a pointer to a linked list. Point to itself at an earlier location and you've got something cyclical.
11:20:55 <quchen> Prelude.cycle doesn't "repeat a list", it actually does the "point-back-to-beginning" operation.
11:21:05 <mangaba_leitosa> quchen: that's right, but in your example [(a,b), (b,c), (c,a)], this is not the case
11:23:28 <reizuki> anyone here going to FOSDEM?
11:24:01 <quchen> mangaba_leitosa: Hm, maybe I misunderstood then. The vertices are shared, but nothing about the type says "I'm cyclic".
11:24:35 <jle`> johnw: thanks for StreamList, it's interesting.  it reminds me of a monadic ZipList.  is there anywhere where people are using things like this?
11:24:36 <quchen> It's logically cyclic as long as you interpret (a,b) as an edge from a to b.
11:24:55 <mangaba_leitosa> quchen: right, logically it is...
11:25:12 <ReinH> There are no cycles in the data structure itself.
11:25:14 <erisco> Cale, if I did take a logn hit in favour of reducing the logic complexity, what datastructure would give me best reuse after insert and delete? a simple Map?
11:25:27 <erisco> one downfall of the cyclic structure is the entire thing must be replaced for a single change
11:25:47 <erisco> whereas with indirection this does not have to be so
11:25:57 <quchen> erisco: Only the data constructors have to be replaced.
11:26:04 <quchen> The cell contents can be shared.
11:26:09 <sm> m-r-r: let us know how you get on (with plugins)
11:26:51 <Cale> erisco: Yeah, Map or IntMap (the only difference between those is that IntMap tends to have better constant factors)
11:26:55 <quchen> mangaba_leitosa: Well and physically starts and ends are shared, but to connect them you need a lookup-y function. I guess that makes it non-cyclic in a way, right.
11:27:02 <erisco> quchen, there is not much that survives. most of the stored data is references. Vertices store an Edge list, Edge stores from and to Vertices
11:28:00 <quchen> erisco: The cell contents can be huge thunks, I wouldn't call that "not much".
11:28:11 <maurer> erisco: One option is to have the main data structure be in a map-like setup for ease of update, and provide a ``view'' that you can construct off the map to allow you to do read-only ops on the cyclic structure
11:28:46 <erisco> quchen, potentially the entire structure is not forced, but given the operations I have, that is unlikely
11:29:13 <quchen> Ah, in a specific use case that can be different of course.
11:29:44 <quchen> I guess another thing that's bad about cyclic structures in Haskell is that you can't tell whether they're cyclic.
11:30:15 <quchen> > mystery -- Is this `cycle [1,2,3]`?
11:30:17 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
11:30:33 <erisco> quchen, for that reason I gave vertices an Eq instance
11:30:45 <FreeFull> That's why observable sharing libraries exist
11:31:26 <quchen> FreeFull: How do they work?
11:31:34 <quchen> Unsafe calls to get memory locations?
11:31:34 <FreeFull> Well, one
11:32:06 <FreeFull> data-reify works by having everyting in IO
11:32:20 <FreeFull> "Observable sharing in general is unsafe, so we use the IO monad to bound this effect, but can be used safely even with unsafePerformIO if some simple conditions are met. Typically this package will be used to tie the knot with DSL's that depend of observable sharing, like Lava."
11:36:23 <monochrom> @quote chrisdone moon
11:36:23 <lambdabot> chrisdone says: â€œmonads are like a finger pointing away to the moon. *smack* don't look at the finger or you will miss all that heavenly gloryâ€¦â€
11:36:39 <monochrom> I just thought of a better version of that!
11:37:10 <monochrom> "monads are like a finger pointing away to Io. *smack* don't look at the finger or you will miss all that heavenly glory of Io!"
11:37:23 <scriptor> hah
11:38:12 <ParahSailin> what is the documentation for the cabal cpp macros like detecting GHC version
11:38:34 <Saizan> monochrom: or don't look at Io or you'll miss the heavenly glory of monads?
11:38:50 <monochrom> the macro for detecting GHC version is due to GHC, not cabal. see the GHC user's guide.
11:39:16 <monochrom> for macros due to cabal, see the Cabal user's guide, http://www.haskell.org/cabal/users-guide/
11:39:33 <monochrom> heh Saizan, it's hard to decide which
11:43:02 * hackagebot RNAdesign 0.1.0.0 - Multi-target RNA sequence design  http://hackage.haskell.org/package/RNAdesign-0.1.0.0 (ChristianHoener)
11:43:14 <Geraldus> Hey buddies! I have a question about typeclass a -> a -> a
11:43:39 <monochrom> a -> a -> a is not a type class. please correct your question.
11:44:15 <Cale> :)
11:44:17 <quchen> 10/10 very helpful would ask for advice again
11:44:31 <monochrom> haha
11:44:44 <jle`> this is why you should always ask before asking your question
11:44:56 <jle`> you can find out right away if your question is worthy of being answered
11:45:08 <Geraldus> I'm sorry, about function with type a -> a -> a, in this (https://www.fpcomplete.com/school/starting-with-haskell/introduction-to-haskell/5-type-classes) tutorial wrote, that actually only two functions could have this type. It is f x y = x and f x y = y
11:45:11 <Geraldus> why?
11:45:15 <quchen> I'm sure that question is worthy of an answer.
11:45:44 <quchen> Geraldus: "a -> a -> a" is a type, not a typeclass. Do you have some example code to illustrate your problem?
11:45:55 <Cale> Geraldus: Well, such a function is given two things of type a. It doesn't know what type those things have, because it is polymorphic.
11:46:16 <monochrom> an elementary answer: because there is no type-case. you cannot say "if x is Int, do one thing; if x is Char, do another thing"
11:46:30 <Cale> Geraldus: So, if it is to be a total function (i.e. not just go into an infinite loop), it must produce one or the other as its result
11:46:31 <monochrom> an advanced answer: parametricity
11:47:20 <Geraldus> Oh, I've catch. There are only two TOTAL functions with this type
11:47:21 <Geraldus> Right?
11:47:25 <Cale> right
11:47:31 <Geraldus> Cool! Thanks
11:47:34 <jle`> Geraldus: can you imagine another function with this type, not knowing anything about what they are?
11:47:35 <quchen> If you *had* additional structure, say `Num a => a -> a -> a`, you could do additional things (like adding x and y).
11:47:44 <jle`> or anything about them
11:47:45 <Cale> There's one more if you count the function which just produces undefined as its result
11:47:58 <Cale> and yet another if you count undefined itself as another thing
11:48:12 <haasn> Cale: there are more possibilities if you account for varying strictnesses of the â€œignoredâ€ parameters
11:48:15 <Cale> Well, I guess we can enumerate them
11:48:51 <Cale> undefined, (\x -> undefined), (\x -> (\y -> undefined)), (\x -> (\y -> x)), (\x -> (\y -> y))
11:49:14 <maurer> Geraldus: http://en.wikipedia.org/wiki/Parametricity is a brief overview of how you prove that, but it's not technically true wha tthey're claiming in haskell
11:49:16 <Cale> and that's all
11:49:47 <quchen> maurer: But it would be morally correct to ignore that technicality ;-)
11:49:50 <maurer> Cale: Depends on whether you consider bottom and infinite runtime to be different
11:49:58 <Geraldus> jle` catch that
11:50:25 <Cale> maurer: bottom represents all forms of nontermination
11:51:15 <maurer> Cale: Yeah, my point is that it depends on whether you consider "error: undefined" and "nontermination" to be the same results
11:51:56 <quchen> They are, in the context we're talking about.
11:52:27 <Cale> It's impossible to distinguish them using a function.
11:52:33 <maurer> True
11:52:47 <maurer> Actually there are more
11:52:59 <maurer> f x y = x `seq` y
11:53:03 <maurer> f x y = y `seq` x
11:53:12 <Cale> hmm!
11:53:12 <maurer> affects behavior based on whether the arguments were bottom
11:53:21 <tac> What Cale said might be restated as they are "intrinsically" identitcal functions.
11:53:21 <Cale> right
11:53:27 <gamegoblin> Parsec question: Let's say I have a type defined as "data Attribute = Numeric Double | Nominal String". Now let's say I am reading in a comma separated line of values in which I know the format of the values (e.g. [Numeric, Nominal, Nominal, Numeric]). How would I write a function that takes this list of types, and based on the type, either parses the next value into the appropriate type (a double or a string).
11:53:50 <quchen> gamegoblin: That's a list of values, not types.
11:53:53 <tac> Another property which is extrinsic is runtime. Two identical functions (equal in the language) might have two very different runtime characteristics.
11:55:13 <quchen> gamegoblin: If you want to choose the next parser step depending on the last parser, something like `do { x <- parseOne; case x of { Foo -> parserA; Bar -> parserB } }` will do.
11:55:14 <chirpsalot> In Data.Set member needs types in Ord? Why isn't it just types in Eq?
11:55:24 <jle`> gamegoblin: you could probably do some kind of zipping / zipWith
11:55:28 <gamegoblin> quchen: Ok, the function takes a list in some format in which the Nth element specifies the appropriate type of the Nth comma separated value in the file, how would I call the appropriate parsec function to parse a double or parse a string
11:55:33 <haasn> maurer: that's what I meant :)
11:55:40 <jle`> gamegoblin: and run your values parallel with a list of appropriate parsers
11:55:41 <Cale> chirpsalot: Because it's impossible to implement a set datastructure efficiently if you only require Eq
11:55:58 <Cale> chirpsalot: Note that member only take O(log n) time to check if the element is in the set
11:56:00 <chirpsalot> Cale: ah, that's what I was wondering.
11:56:14 <Cale> This isn't enough time to compare the element with each of the n elements in the set
11:56:22 <Cale> takes*
11:56:44 <haasn> We really need an â€œarbitrary orderingâ€ type class
11:57:00 <haasn> alternatively, an â€œarbitrary hashingâ€ type class
11:57:04 <quchen> gamegoblin: You could convert your list of Attribute to a list of parsers, and then sequence that list. Like `sequence (map toParser [...])`, where `toParser Numeric = numericParser` etc.
11:57:11 <chirpsalot> Cale: mhmmm. It seems like it would be nice to have a more general one with O(n) memberships checks (though hopefully that's just worst case).
11:57:19 <quchen> And then refactor that using `sequence . map f = traverse f` :-)
11:57:51 <gamegoblin> quchen: That is exactly what I was looking for, I didn't know about the sequence function, thanks.
11:57:52 <Cale> chirpsalot: Well, for that, you can just use lists with nub
11:58:08 <quchen> gamegoblin: sequence is pretty useful, make sure you have a good look at it!
11:58:22 <quchen> See also https://github.com/quchen/articles/blob/master/functions_comprehensible.md#sequencemapm
11:58:35 <quchen> NB: mapM = traverse
11:59:15 <piezoid> gamegoblin: you can write a conditional parser (as quchen said) of type condP :: AttributeType -> Parser Attribute, them use sequence . map condP to transform your [AttributeType] to Parser [Attribute]
11:59:24 <piezoid> mmh, too late :/
11:59:44 <chirpsalot> Cale: I guess so, but with a hash table you can check membership in constant time  "most of the time, maybe". Ah well.
12:00:14 <Cale> chirpsalot: Not really!
12:00:35 <Cale> chirpsalot: Computing a hash for a hashtable of size n must take at least O(log n) time
12:00:36 <chirpsalot> Cale: depending on what you're storing and the hash functions / size of the table :P.
12:00:54 <Cale> Because no function whose range has n elements can be computed in less than O(log n) time
12:01:07 <Cale> You need O(log n) time to distinguish between n possible outcomes.
12:01:34 <chirpsalot> Cale: you could allow for collisions, though, no?
12:02:06 <Cale> Yes, but you can have at most a constant number before the access time becomes linear (or something) instead.
12:02:18 <chirpsalot> Cale: I mean theoretically the running time is awful, but in practice I think it tends to be reasonable.
12:03:31 <Cale> (a constant multiple of the number of buckets)
12:04:05 <chirpsalot> Cale: yeah :). But linear isn't terrible. I don't know, it just seems a bit weird because I thought Set would try to be as general as possible? I guess it makes sense the way it is.
12:04:09 <Cale> chirpsalot: But yeah, the people who tell you that hashtable lookup is O(1) are liars :)
12:04:16 <shiona> Say I want to create an API for a website that has none and requires login to do anything. So I'll have to keep track of cookies and CSRF-tokens. 1) is this wrong, should I not do it? 2) Is this a good exercise in haskell?
12:04:24 <quchen> Oh, HashSet a = HashMap a (). I was always wondering why `Set a` isn't `Map a ()`.
12:04:36 <Cale> chirpsalot: It is as general as possible for what it is :)
12:05:12 <chirpsalot> Cale: well it's definitely not O(1) :P. But, it can be constant a lot of the time, depending on construction / what you store.
12:05:40 <FreeFull> Cale: The n ends up being a constant though
12:05:43 <Cale> If you're willing to put a bound on the number of elements that you put in your Set, that'll have O(1) lookup too ;)
12:05:48 <FreeFull> If you have a fixed-size hashtable
12:06:03 <quchen> (Is there something common between O(1) and O(log(n)) besides nested logs?)
12:06:36 <Cale> quchen: Maybe inverse Ackermann, if you call that common.
12:06:40 <Cale> Or log*
12:06:45 <quchen> log*?
12:06:51 <int-e> inverse ackermann is common enough.
12:07:05 <FreeFull> There is log(log(n)) sometimes
12:07:15 <Cale> http://en.wikipedia.org/wiki/Iterated_logarithm
12:07:31 <Cale> quchen: Number of times you have to log to get less than or equal to 1
12:07:45 <quchen> Ah, that's similar but not identical to log^n I guess.
12:07:52 <chirpsalot> Cale: yeah :). I just mean that you could have member accept Eq a elements instead, if O(n) was acceptable for the look up time :P. So, member could be more general if you sacrificed computation time?
12:08:51 <Cale> chirpsalot: Yeah, it could, but the difference between O(n) and O(log n) is much larger than the difference between O(log n) and O(1) :)
12:09:07 <Cale> (In some sense!)
12:11:19 <quchen> Cale: Is there a O(log(n)) problem that does not finish in constant time for practical applications?
12:11:35 <quchen> i.e. a O(log(n)) problem with absurdly high constants
12:11:38 <chirpsalot> Cale: yeah, I guess. I'm not complaining, I just think that it's an interesting trade off. I haven't done much Haskell, but I thought that something like a Set would just use the Eq typeclass for most things, because that's all that matters in "math sets". If that makes any sense at all, haha.
12:12:22 <Cale> chirpsalot: Yeah, of course, sets in mathematics are far weirder things altogether.
12:12:33 <quchen> Haskell.Set does not represent mathematical sets.
12:12:35 <Cale> You have some notion of equality there, but it needn't be computable
12:13:17 <Hodapp> I thought he was referring to equality of the elements, not of sets themselves.
12:13:22 <Cale> (and there's no notion of time or space complexity for operations on sets in, say, ZFC)
12:13:33 <Cale> Hodapp: Well, that's the same thing for mathematical sets :)
12:14:28 <Hodapp> Cale: I don't know what you mean.
12:14:56 <Cale> Sets in mathematics are trees with finite depth, but potentially infinite branching.
12:15:11 <Cale> Every element of a set is also a set.
12:16:12 <ciaranm> heresy!
12:16:21 <ciaranm> there are no elements, only functions
12:16:35 <Hodapp> Cale: I was unaware that all sets could contain is more sets.
12:16:47 <Cale> Hodapp: At least in ZFC, that's the case
12:17:39 <davidfetter_disq> .oO(the set of all sets which are not members of themselves)
12:17:59 <mr-> pfft.. implementation details!
12:19:08 <Cale> (In ZFC, the things your quantifiers range over are called sets, so it's kind of impossible to discuss anything else, apart from defining those other things as being particular sets)
12:20:22 <mornfall> I don't think adding atoms breaks anything.
12:20:25 <simpson> davidfetter_disq: IIUC it's not possible to construct such a thing in ZF.
12:20:41 <ciaranm> ZFA and ZFC are different
12:20:47 <davidfetter_disq> simpson, IU that also
12:20:47 <ciaranm> also ETCS is the one true set theory
12:20:53 <davidfetter_disq> meh
12:21:00 <mornfall> simpson: isn't that kind of the point? :)
12:21:07 <mornfall> of ZF* anyway
12:23:42 <Cale> Yeah, the reason you can't do that in ZF/ZFC, is that the axiom schema of comprehension only lets you construct new sets by restricting the elements of *other sets* by picking those which satisfy a given predicate.
12:24:34 <Cale> and ZFC gives you no way to discuss a set of all sets -- in fact, such a thing would contradict the axiom of regularity
12:24:41 <Cale> (or ZF)
12:25:18 <ciaranm> haaaang on...
12:25:20 <roconnor> Cale: axiom of comprehension.
12:25:24 <ciaranm> what's construction got to do with it?
12:25:30 <roconnor> Cale: Z also has no set of all sets AFIAIU
12:26:23 <Cale> Well, lots of set theories don't :)
12:27:12 <Cale> ciaranm: Well, when you say "the set of all ... which ..." -- the idea there is called set comprehension
12:27:32 <Cale> ciaranm: ZF's mechanism for comprehension is limited to restricting the elements of other sets
12:27:49 <Cale> It can't create sets from thin air having all the things satisfying a predicate
12:28:06 <ciaranm> Cale: right, but that doesn't say there isn't such a set anyway, does it?
12:28:44 <Cale> Right, it doesn't, but the lack of such a powerful comprehension axiom is why ZF avoids Russell's paradox.
12:29:31 <Cale> ZF *also* tells you that things like a set of all sets can't exist, by proving things like  not (exists x. x in x)
12:30:25 <Cale> But that in itself wouldn't help to avoid a contradiction.
12:31:41 <Cale> The ability to show that there's not a set of all sets isn't the important part, the important part is not being able to show that there is a set of all sets. ;)
12:48:52 <trolling> do comonoids in Hask have any practical application?
12:50:14 <roconnor> trolling: no, but comonoids is slighlty different categories do.
12:50:49 <trolling> they're comonads in the category of endofunctors on Hask I think
12:50:56 <roconnor> exactly
12:52:08 <roconnor> that said I haven't considered Hask with sum rather than product as the monoidal operation.
12:52:36 <trolling> interesting
12:52:44 <trolling> so it'd be a -> Void and a -> Either a a?
12:52:54 <roconnor> not looking very promising :(
12:53:16 <trolling> is there a... cosemigroup perhaps
12:53:26 <Cale> Yeah, that's worse than the usual comonoid
12:54:39 <trolling> monoids with sum are a little weird too, I think
12:54:57 <trolling> the Void -> a component is rather redundant
12:58:03 <pyon> trolling: "Either a a -> a" is no less redundant :-) By the way, should this be called a "codiagonal functor" (by analogy to "a -> (a, a)" being a diagonal functor)
12:59:28 <trolling> pyon: for specific a, Either a a -> a is inhabited by multiple types though
12:59:31 <trolling> uh, multiple values
12:59:39 <trolling> Void -> a isn't
12:59:46 <pyon> Ah, right, right.
13:01:37 <DanBurton> So you know how there's the "instance (Applicative f, Num n) => Num (f n)"? Is there a package that provides a newtype for easy access to that instance?
13:05:02 <zett_zelett> What is Z?
13:05:14 <roconnor> zett_zelett: no replacement axiom
13:05:24 <roconnor> BTW, everything I said earlier was wrong
13:05:27 <roconnor> I appologize
13:06:32 <zett_zelett> How has ZFC the vocabulary to talk about mappings between (possibly) non-sets?
13:06:35 <shiona> Is curl the best tool for scraping sites with haskell or does some library provide cookie / csrf handling?
13:07:00 <zett_zelett> Isnâ€™t a map A â†’ B but a left-total right-unique relation R âŠ‚ A Ã— B?
13:07:30 <roconnor> zett_zelett: you can also define maps via binary predicates.
13:07:39 <zett_zelett> Ah, well.
13:08:05 <zett_zelett> But then they are not really maps, but rather assignments, arenâ€™t they?
13:08:18 <roconnor> what's an assignment?
13:09:41 <zett_zelett> I use it informally to describe things of the form x â†¦ y:Pxy where P is a predicate.
13:10:17 <donri> shiona: http-conduit-browser maybe?
13:10:43 <shiona> donri: thank you, I'll take a look
13:10:55 <donri> (haven't used it)
13:11:05 <roconnor> zett_zelett: I don't understand that notation
13:11:09 <KiriKari> is darcs distributed or centralized?
13:11:24 <fizruk> KiriKari, distributed
13:12:11 <zett_zelett> x is assigned to y such that Pxy holds.
13:13:37 <roconnor> zett_zelett: A map defined by predicate is a binary predicate that is left-total and right unique.
13:13:49 <roconnor> zett_zelett: which is how the replacement axiom scheme looks
13:14:20 <zett_zelett> Okay.
13:15:27 <roconnor> zett_zelett: I know I know.  We did all this work in set theory so that maps would be sets and then we throw it all away and use predicates anyways.
13:15:46 <roconnor> which is why you should just use dependent type theory and skip the ZFC non-sense.
13:16:01 <zett_zelett> Or at least use NBG?
13:16:24 <zett_zelett> Hey, do you have some book you can recommend on dependent type theory?
13:16:30 <roconnor> I wouldn't use NBG.  It does strange things to be conservative over ZFC.
13:16:37 <roconnor> @where TTFP
13:16:37 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
13:16:51 <zett_zelett> Thanks!
13:16:51 <roconnor> That is what I used; there may be newer material available.
13:17:26 <zett_zelett>                EUR 228,21 new at amazon. : â€“ /
13:17:38 <roconnor> zett_zelett: well the PDF is freely available
13:18:12 <roconnor> you can buyt it from cafe press for $18.50
13:18:13 <zett_zelett> Yeah, thatâ€™s a consolation.
13:18:47 <zett_zelett> What do you do, roconnor?
13:18:52 <roconnor> It is out of print so I'm surprised it is availbe new at all.
13:18:59 <roconnor> zett_zelett: I am a software developer.
13:19:12 <zett_zelett> Did you study mathematics?
13:19:18 <roconnor> yes.
13:19:26 <zett_zelett> What did you specialize in?
13:19:45 <roconnor> for my PhD: dependent type theory.
13:20:00 <zett_zelett> Ah, thatâ€™s how you know so much!
13:20:07 <roconnor> :)
13:20:56 <tac> I purchased Jacobs' type theory book the other day
13:20:58 <tac> I'm very excited for it
13:21:04 <zett_zelett> Iâ€™m going for algebra, but Iâ€™m also very interested in logic and I was really bothered with the prominence of sets in modern mathematics as taught at university.
13:21:10 <tac> roconnor: Have you read it?
13:21:17 <roconnor> tac: I am not familiar with it
13:21:40 <tac> zett_zelett: I had the same feeling, coming from a computer sciency background after learning about the "wonders of categories"
13:21:52 <zett_zelett> Categories are just plain awesome.
13:21:54 <roconnor> zett_zelett: yes set theory is fairly promenent;  It isn't too big of an issue for most algebra.
13:22:02 <zett_zelett> Yeah, I know.
13:22:07 <tac> zett_zelett: After a while, you have to realize what the cultural context is. Sets have done a wonderful job at axiomatizing mathematics for 150 years.
13:22:34 <zett_zelett> I dislike the way limits are shown â€œto existâ€ by constructing them as sets.
13:22:47 <roconnor> It took me a long long time to appreciate categories.  Though traditional categories also have sets playing a too prominant role
13:22:48 <zett_zelett> Or any universal construct like the tensor product, the free group, you name it.
13:22:59 <tac> zett_zelett: The construction is the proof that they exist :)
13:23:06 <zett_zelett> Yeah, but why?
13:23:07 <tac> You'd have to do a construction in any foundation.
13:23:13 <zett_zelett> Just because some set theory says so.
13:23:23 <roconnor> zett_zelett: you will like dependent type theory.
13:23:30 <tac> Well, most people take set theory as your foundation.
13:23:48 <tac> And it works for most of what a mathematician does, modulo a few lies no one really pays attention do
13:23:54 <zett_zelett> â€œWe believe these basic constructions on sets, so believe this complex and utterly counterintuitive construction.â€
13:24:15 <tac> Mathematicians understand the difference between equality and isomorphism, but they aren't logicians, and they don't think the difference is all that significant.
13:24:39 <zett_zelett> Itâ€™s weird, because it *is* very important from time to time.
13:24:42 <tac> They write their proofs in a loosey-goosey way that, when formalized, would still work just fine
13:24:48 <roconnor> tac: one perspective is that type theory simply positulates these varous constructions exists and/or the results of type theory only apply to those categories where such constructions exists, which is basically saying the same thing.
13:25:02 <tac> But you get to ignore obnoxious details, like whether AxBxC means (AxB)xC or Ax(BxC)
13:25:07 <zett_zelett> The simplest example is â„¤/2â„¤, but as 2â„¤ = â„¤, â„¤/2â„¤ = â„¤/â„¤ = 0?
13:25:28 <tac> It is!
13:25:46 <tac> But most mathematicians can keep the details straight in their heads, and it doesn't cause trouble.
13:25:53 <pyon> tac: Well, they are implicitly saying that you can move from either one to the other one along an equivalence. :-)
13:25:58 <zett_zelett> The other day, a solution was presented in Algebra which didnâ€™t pay attention to this.
13:26:09 <pyon> alongside*
13:26:38 <tac> Yeah. zett_zelett You see it a lot in math. A subspace is always implicitly linked to its embedding in the larger space
13:27:20 <zett_zelett> We wanted to count the factor space â„¤â´/U where U was the image of some â„¤-linear mapping. Then the tutor showed that U is isomorphic to 2â„¤Ã—2â„¤Ã—â„¤Ã—â„¤ and concluded that we have a #â„¤â´/U = 4.
13:27:36 <roconnor> zett_zelett: in my previous job I was formalizing Galois Theory in the Coq proof assistant
13:27:48 <zett_zelett> But he didnâ€™t mention that the isomorphism arose from an isomorphism â„¤â´ â†’ â„¤â´.
13:27:50 <zett_zelett> Nice.
13:28:18 <tac> Another example that I found surprising when I first saw it in group theory
13:28:26 <tac> A group can't be "normal" on its own
13:28:37 <tac> Normality is a relative condition. H is normal *in* G.
13:28:40 <tac> for some G
13:28:48 <fizruk> hm... is there an alias for fmap fmap fmap? :)
13:28:56 <zett_zelett> What was surprising about that?
13:28:59 <tac> But you just have to be sensitive to those dependencies.
13:29:02 <ciaranm> remember, { ..., -2, -1, 0, 1, 2, ... } is not the set of integers. it's the set of arabic numerals written on the board in someone's handwriting.
13:29:06 <fizruk> smth like <$$$> or <$$> ?
13:29:07 <shachaf> It's "normal subgroup".
13:29:33 <shachaf> Lots of things don't exist in isolation. A set can't be open on its own.
13:29:41 <zett_zelett> Yeah.
13:29:49 <tac> But if you have H subset G subset J, H is a subgroup of J, but need not be normal in J.
13:29:55 <zett_zelett> Oh boy, how many mathematicians are here?
13:30:06 <roconnor> tac: I remember we has some extended definition of a normal subset of a group.  Something like a subset is normal if it is contained in the normalizer of G.
13:30:09 <tac> zett_zelett: Haskell is the language where mathematicians go to program.
13:30:18 <shachaf> @quote mathematicians
13:30:19 <lambdabot> dpiponi says: Sometimes I wonder if the only difference between mathematicians and computer scientists is the direction of their arrows.
13:30:25 <shachaf> @quote kmc mathematicians
13:30:25 <lambdabot> kmc says: Haskell isn't really designed by mathematicians.  it's designed by people who programmers would consider to be mathematicians and mathematicians would consider to be programmers
13:30:30 <tac> Oh, another example I had been struggling with in Algebraic Geometry
13:30:58 <ciaranm> algebraic geometry has too many weird notational conventions
13:31:02 <tac> We use V(S) where S is a set of polynomials in k[x1,...xn] to mean a variety defined by all points p in k^n where f(p) = 0 for f in S.
13:31:08 <zett_zelett> Algebraic Geometry is too fucking complex.
13:31:11 <zett_zelett> I donâ€™t get it at all.
13:31:14 <zett_zelett> (Yet.)
13:31:20 <ciaranm> it's easy. it's just functors!
13:31:30 <tac> V looks like a function... but it actually depends on the set of indeterminates in the coordinate ring.
13:31:35 <zett_zelett> â€¦ and stacks!
13:31:39 <zett_zelett> And schemes.
13:32:23 <zett_zelett> Well, yes, but.
13:33:08 <tac> It's weird when you go between two varieties, because the variety depends NOT only on the ambient variety (A^n or P^n), but it also depends on the choice of coordinates we use.
13:33:43 <ciaranm> if only there was a way you could remove choice of coordinates from an arbitrary anything
13:33:50 <zett_zelett> V : Pot(k[xâ‚,â€¦,xâ‚™]) â†’ Pot(Kâ¿)?
13:34:23 <zett_zelett> tac: What do you mean by the choice of coordinates?
13:34:32 <roconnor> er
13:34:40 <roconnor> maybe we should move this to #haskell-blah
13:34:43 <roconnor> some time ago probably
13:34:44 <zett_zelett> Oh.
13:34:46 <zett_zelett> Yeah.
13:40:17 <carter> ReinH: me always :)
13:43:17 * hackagebot ANum 0.1.0.0 - Num instance for Applicatives provided via the ANum newtype  http://hackage.haskell.org/package/ANum-0.1.0.0 (DanBurton)
13:47:40 <fmt> hi guys, is there a way to specialize and test a polymorphic function on some desired types without using a 'whitness' parameter or template haskell ?
13:48:18 * hackagebot ANum 0.1.1.0 - Num instance for Applicatives provided via the ANum newtype  http://hackage.haskell.org/package/ANum-0.1.1.0 (DanBurton)
13:49:18 <DanBurton> fmt: how do you want it to select which specialization to test with?
13:49:57 <DanBurton> fmt: do you want it to pick just any specialization, or some particular specialization, or all specializations?
13:50:38 <fmt> just a particular one(s)
13:51:34 <DanBurton> in that case, I'd just annotate it with the desired specialization. quickCheck (polyFunc :: This -> Particular -> Specialization)
13:52:38 <DanBurton> that, or "specializedFunc :: This -> Particular -> Specialization; specializedFunc = polyFunc; ... quickCheck specializedFunc"
13:53:28 <DanBurton> there's got to be some sort of witness or annotation if you want it to test a particular specialization, unless you have mind-reading software
13:53:52 <donri> DanBurton: ghc 7.8 has an extension for that
13:53:55 <fmt> :)
13:54:10 <donri> {-# LANGUAGE ReadMyMind #-}
13:54:17 <DanBurton> :)
13:54:23 <donri> man i can't wait for 7.8
13:55:05 <DanBurton> that's what you'll be saying about 7.10 once 7.8 gets released. ghc always seems to find interesting new features
13:55:29 <fmt> the think that I really want is not having to pass a usless parameter on every function, or use template haskell
13:55:34 <fmt> *thing
13:56:30 <fmt> so I guess I could map your specialized over my test list
13:56:41 <DanBurton> if you want to specialize to the same input type every time, you could create a specialization of the "quickCheck" function. myQuickCheck :: My -> Specialization; myQuickCheck = quickCheck
13:57:06 <donri> every new ghc release i feel like this one is awesome and the last one was awful. which of course i felt that about when *that* was new.
13:57:19 * donri kid with new toy
13:57:37 <DanBurton> yeah, who cares about last year's christmas presents
13:57:43 <donri> see also: cabal
13:58:26 <fmt> well thank you dan for the ideas , I'l go give them a try
13:59:30 <donri> i use proxies but it's not exactly the paragon of beauty https://github.com/dag/path/blob/master/test/hspec.hs
14:01:44 <fmt> what I was looking at is Bryan's code here https://github.com/bos/critbit/blob/master/tests/Properties/Map.hs
14:02:36 <fmt> but this is also prone to mistakes when the witness parameter is used by not paying attention
14:03:21 <donri> hmm i could probably use the fact that Proxy is (recently?) poly-kinded and clean up my "category" there...
14:04:54 <donri> fmt: personally i think writing tests is one of the better uses of TH
14:06:51 <fmt> donri: I do too, but sometimes it's not your call to make
14:07:12 <merijn> donri: Closed type families! *squeal*
14:09:13 <donri> merijn: polykinded category! type holes! module-level build parallelism! MINIMAL pragma!
14:09:23 <donri> the other 20 things i forgot right now!
14:09:54 <donri> merijn: oh yeah typed TH!
14:11:52 <fmt> some time ago , looking at ghci source code, I couldn't help but notice that it's tightly coupled with its UI, do you guys think that working on decoupling that so that any UI can plugged in is a worthwhile project?
14:12:36 <donri> fmt: ask chrisdone, he probably has a rant on the subject
14:12:45 <DanBurton> oh I didn't realize Type Holes were becoming reality so soon. Delightful. <3
14:13:18 <donri> https://github.com/ghc/ghc/blob/master/docs/users_guide/7.8.1-notes.xml
14:13:29 <fmt> donri:  a rant on which part ?
14:13:38 <shachaf> They ought to be called value holes.
14:13:39 <donri> fmt: ghci as a library
14:13:43 <shachaf> They aren't type holes.
14:14:25 <donri> i want type holes though
14:14:27 <DanBurton> indeed. value holes where the compiler gives you type *information* about the hole.
14:14:28 <donri> kind holes?
14:14:39 <DanBurton> t'would be nice
14:14:43 <fmt> donri: the language barrier is creeping in and I don't really understand what you mean :-P
14:14:50 <donri> but i also want type wildcards
14:15:00 <donri> _ meaning "infer this bit"
14:15:20 <DanBurton> might as well just program in Agda
14:15:24 <donri> :)
14:15:54 <donri> agda has that? i thought it didn't really have type inference at all. well, FSVO.
14:16:48 <donri> fmt: i think chrisdone was doing something with ghci as a library and vaguely recall him complaining about it generally sucking
14:17:14 <donri> merijn: oh dear i forgot roles and safe coercions!
14:17:35 <brence> is foldl a catamorphism?
14:17:37 <donri> overloaded lists will be fun just to annoy shachaf
14:17:39 <fmt> donri: ;) I'll ses if i find something
14:17:57 <shachaf> Are they overloaded enough to allow HLists?
14:18:01 <donri> nope
14:18:06 <donri> so ok, annoys me too :P
14:18:38 <donri> merijn: the new IO backend!
14:18:42 <shachaf> i love monoids
14:19:08 <fmt> brence: yes
14:19:51 <brence> fmt: cat be defined generically in terms of the fixed point of a functor, like foldr?
14:20:05 <Nataly> hello donri
14:20:15 <ion> Are overloaded lists an implicit mconcat?
14:20:25 <donri> ion: fromList
14:20:25 <mark43> ion: fromList
14:20:29 <ion> ok
14:20:33 <donri> of IsList
14:20:33 <mark43> of IsList
14:20:35 <donri> :D
14:20:35 <mark43> :D
14:20:41 <Nataly> Oo
14:21:16 <zett_zelett> What.
14:21:34 <zett_zelett> Freaks.
14:21:36 <fmt> brence : I really have no clue
14:22:26 <donri> ion: or rather, fromListN (IIRC) also providing the length, which for a literal is known statically and useful for things like vector
14:23:00 <ion> donri: neat
14:23:09 <donri> or well, some literals. i guess it also translates range notation which isn't necessarily of a known length
14:23:10 <mark43> or well, some literals. i guess it also translates range notation which isn't necesAW
14:23:27 <donri> wat
14:23:28 <mark43> wat
14:24:00 <simpson> @where ops
14:24:00 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:24:18 --- mode: ChanServ set +o geekosaur
14:24:27 --- mode: geekosaur set +b *!*ident@190.79.98.*
14:24:27 --- kick: mark43 was kicked by geekosaur (mark43)
14:24:39 --- mode: geekosaur set -o geekosaur
14:24:50 <donri> that's disappointing, i thought we actually said the same things at the same times before
14:24:53 <Clint> is there a good example of the same monad transformer being stacked multiple times?
14:25:36 <donri> Clint: possibly your average full-stack happstack application monad
14:26:19 <geekosaur> Clint: possibly the Query monad in xmonad, which is a Reader Window over a ReaderT XConfig (StateT XState IO)
14:26:34 <geekosaur> er, ReaderT Window
14:26:45 <Clint> donri, geekosaur: thanks
14:26:47 <geekosaur> and I may have XConfig and XState swapped; I'm still getting set back up at home
14:26:48 <donri> ServerPartT itself is built up with transformers, providing specialized terms like askRq instead of making you lift ask or mess with your own MonadReader
14:27:52 <donri> and, because, it's common-place for downstream applications to be adding transformers like ReaderT on top of that
14:27:53 <mark44> and, because, it's common-place for downstream applications to be adding transformers likFÍ
14:28:03 <donri> ...
14:28:04 <mark44> ...
14:28:07 <maurer> I don't even understand what the point of this bot is
14:28:19 <donri> apparently only to repeat what *I* say
14:28:24 <Clint> that's creepy
14:28:32 <zett_zelett> I say so.
14:28:34 <maurer> Wait, it outputted a unicode character at the end there
14:28:46 <maurer> Next time it repeats you, try giving it a very very long line
14:28:50 <maurer> and see if it does something funny
14:28:54 --- mode: ChanServ set +o geekosaur
14:28:54 <zett_zelett> He did so before.
14:28:59 <zett_zelett> *it
14:30:09 <maurer> zett_zelett: basically I'm wondering if there's an incorrectly terminated copy or something. it seems to stop short, but the random extra character suggests a mistake
14:30:22 <Nataly> *test
14:30:22 <mark44> JARVIS running ok!
14:30:26 <Nataly> *speak
14:30:27 <mark44> Hello pretty Girl!
14:30:29 <maurer> ...
14:30:31 --- mode: geekosaur set -b *!*ident@190.79.98.*
14:30:35 --- mode: geekosaur set +b mark44!~ident@190.79.*
14:30:37 <Nataly> :P
14:30:41 <Nataly> noooooooo}
14:30:43 <geekosaur> apparently wrong one, sigh
14:30:47 <Nataly> another mark banned
14:30:49 <Nataly> :/
14:30:49 --- mode: geekosaur set -b mark44!~ident@190.79.*
14:31:04 <donri> Nataly: what is that?
14:31:05 <mark44> Nataly: what is that?
14:31:08 --- mode: geekosaur set +b mark44!ident@190.79.*
14:31:15 <Nataly> is an experiment
14:31:20 <donri> your bot?
14:31:21 <mark44> your bot?
14:31:25 <Nataly> nyes
14:31:27 <Nataly> yes
14:31:30 <Nataly> *speak
14:31:30 <mark44> Hello pretty Girl!
14:31:40 <geekosaur> could you experiment in a more appropriate channel?
14:31:46 --- mode: geekosaur set -b mark44!ident@190.79.*
14:31:48 <Nataly> :(
14:31:51 <Nataly> ok ok
14:31:55 <Nataly> *logoff
14:31:56 <mark44> Jarvis restarting...
14:31:58 <geekosaur> we have 1236 user in here
14:32:00 <donri> Nataly: why is it stalking me...
14:32:05 <Nataly> hahaa
14:32:10 <Nataly> mark43 is following you
14:32:25 <Nataly> because you are a great people for follow
14:32:29 <Nataly> :P
14:32:40 <geekosaur> if it's going to echo random people at random times, it could make an already fairly busy channel unusable if it goes off at the wrong time
14:32:47 --- mode: geekosaur set -o geekosaur
14:33:15 <donri> guess i should be honored and creeped out at the same time
14:33:16 <Nataly> hahaha
14:33:17 * donri bbl
14:33:18 <geekosaur> (now what's with this person with the poorly configured client?)
14:33:20 <Nataly> ok i go to sleep
14:33:28 <Nataly> brb
14:34:38 <donri> should i fire off a final line just to see if the bot is still misbehaving?
14:34:39 <mark44> should i fire off a final line just to see if the bBC
14:35:25 <niko> geekosaur: ^
14:35:26 <geekosaur> guh
14:35:27 <shachaf> Nataly: Please turn your bot off.
14:35:30 --- mode: ChanServ set +o shachaf
14:35:52 --- mode: ChanServ set +o geekosaur
14:36:01 --- mode: geekosaur set +b mark44!*@*
14:36:03 --- kick: mark44 was kicked by geekosaur (mark44)
14:36:40 <geekosaur> really, not funny
14:37:07 <shachaf> Won't help much with mark45... Eh.
14:37:10 --- mode: shachaf set -o shachaf
14:38:07 <zomg> I was waiting for donri to say something so I could repeat it just to see what would happen
14:38:12 <zomg> But I guess he went
14:38:12 <zomg> :D
14:38:43 <donri> But I guess he wint
14:38:43 <donri> :D
14:39:01 * donri sneaks in a typo just for kicks
14:39:25 <zomg> heh
14:39:27 <geekosaur> went before its wonted repetition
14:40:51 <maurer> I don't even really understand what the person wanted out of that bot is the thing
14:41:09 * geekosaur considers fitting in something abotu the Wnt pathway and cancers...
14:41:51 * piezoid was looking for some shellcode to exploit the buffer overflow...
14:42:34 <maurer> piezoid: Shellcode isn't hard to come by, but we didn't even know where the return pointer was
14:42:44 <maurer> piezoid: Not to mention if he wasn't completely crazy we'd at least have to employ ROP
14:42:57 <maurer> Who leaves their stack +x these days in a non-jit environment?
14:43:25 * hackagebot IPv6Addr 0.4 - Library to deal with IPv6 address text representations.  http://hackage.haskell.org/package/IPv6Addr-0.4 (MichelBoucey)
14:43:30 <merijn> maurer: Real men!
14:43:38 <merijn> maurer: Who write self-modifying code!
14:44:03 <zomg> Maybe it was just an exercise in haskell
14:44:04 <maurer> merijn: That would be making your .text writable, not your stack executable >_>
14:44:28 <zomg> I wrote an ircbot as well, although mine was much saner. Even managed to have a basic dynamic Haskell interpreter in it =)
14:44:37 <zomg> Damn those GHC apis were poorly documented back then
14:45:46 <hpc> i like that ELF sections have their own version of file permissions
14:45:52 <hpc> how long before it's a full-on filesystem?
14:46:06 <maurer> hpc: It reflects the paging permissions
14:46:20 <hpc> i know, it's just kinda funny
14:46:53 <maurer> Speaking of which, I need to get around to finishing fixing my inverse of parseELF for that dude's elf package
14:47:02 <maurer> As it stands you can't write ELFs back out after messing with them, and that's sad
14:47:53 <maurer> (currently I'm not properly following alignment constraints, so I need to fix that)
14:48:50 <monochrom> one day, ELF will have email sections, too :)
14:49:19 <maurer> monochrom: I dunno, it took them until the release of 64-bit machines to update the spec
14:49:25 <maurer> monochrom: It's not exactly fast changing :P
14:54:17 <hpc> maurer: my slope is slipperier, and thus more fun ;)
14:57:42 <QF-MichaelK> So, I'm playing with the 99 haskell problems in prelude and having a little issue when I type in: "myLast :: [a] -> a" I get: "<interactive>:16:1: Not in scope: `myLast'"  thoughts?
14:58:17 <pavonia> YOu have to use "let" to define functions in GHCi
14:58:20 <shachaf> Do you mean in ghci?
14:58:24 <QF-MichaelK> yes
14:58:29 <QF-MichaelK> thanks
14:58:31 <shachaf> You should probably put your programs in a file and load the file with ghci.
14:58:53 <QF-MichaelK> That's probably a good idea, how would I load them?
14:59:11 <dmwit> ghci foo.hs
14:59:11 <dmwit> or
14:59:17 <dmwit> :l foo.hs from inside ghci
14:59:31 <acowley> C-c C-l
14:59:33 <QF-MichaelK> ah, thank you
14:59:42 <dmwit> If you're into that kind of thing, you might think about developing the habit of using the ghci '*foo.hs' or :l *foo.hs form.
15:00:14 <hpc> quotes important on that command
15:00:47 <pavonia> What does the '*' do?
15:01:01 <dmwit> It always interprets the file, even if there's object code available.
15:01:23 <monochrom> using ghci is a false start because, even if I tell you how to enter code, your next question will be how to save that code, and I will have no good answer.
15:01:27 <QF-MichaelK> when you define the function in a file foo.hs, do you still use let?  Are you supposed to show the type declaration?
15:01:46 <dmwit> You do not still use let.
15:01:50 <QF-MichaelK> ok
15:01:51 <dmwit> Type declarations are usually optional.
15:01:58 <pavonia> dmwit: Otherwise it ignores the .hs file?
15:02:04 <dmwit> They are good style for top-level definitions in production code.
15:02:10 <dmwit> pavonia: correct
15:02:23 <dmwit> pavonia: And the downside is that fewer things are in scope.
15:02:32 <dmwit> (the downside of using the object code, that is)
15:02:53 <jrmithdobbs> so, using lens-aeson on a document structured kind of like: [{"name": "string", "zone": "string", "view": "string},...] i'm trying to understand why this statement is giving me a ([Text],[Text],[Text]) with the results from the whole original list mappended to each other instead of [([Text],[Text],[Text])]
15:03:09 <jrmithdobbs> foldMapOf values ((,,) <$> (toListOf $ key "name" . _String) <*> (toListOf $ key "zone" . _String) <*> (toListOf $ key "view" . _String)) $ res
15:03:27 * hackagebot fay 0.18.1.3 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.18.1.3 (AdamBergmark)
15:03:33 <dmwit> I blame foldMapOf.
15:03:37 <dmwit> Without knowing anything further.
15:03:42 <dmwit> :t foldMapOf
15:03:43 <lambdabot> Profunctor p => Accessing p r s a -> p a r -> s -> r
15:03:50 <dmwit> hm
15:03:52 <dmwit> Anyway,
15:03:54 <dmwit> :t foldMap
15:03:55 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
15:04:31 <dmwit> jrmithdobbs: I didn't read carefully, so take my comment with a bit of salt. But perhaps the pure function you want in front is (\x y z -> [(x,y,z)]) instead of (,,).
15:04:59 <dmwit> So that mappend is (++) instead of zipTriple (++).
15:05:20 <jrmithdobbs> dmwit: that's exactly it
15:06:24 <NickKidman> !
15:06:35 <frx> > ((((:[]).).).(,,)) 1 2 3
15:06:36 <lambdabot>  [(1,2,3)]
15:06:45 <frx> more readable IMO
15:06:58 <jrmithdobbs> frx: your o is now invalid
15:06:58 <jrmithdobbs> ;p
15:07:34 <dmwit> Hello, NickKidman. Welcome to #haskell.
15:07:38 <quchen> Every time I see the (:[]) function I have to think of a monkey robot and it makes me chuckle. We should standardize it.
15:07:57 <monochrom> how do we standardize it?
15:07:57 <NickKidman> Hi dmwit
15:08:14 <quchen> monochrom: I'm sure there's place for a monomorphic `return` in Prelude.
15:08:45 <monochrom> notice that any other name you give it will lose the (:[]) monkey robot form
15:09:23 <monochrom> "monkeyRobot" does not look remotely close to a monkey robot, for example
15:09:39 <jmcarthur_mobile> monkeyRobot :: a -> [a]
15:10:00 <evincar> monochrom: We could use U+1F435 MONKEY FACE. Pretty sure it's a valid operator.
15:10:05 <acowley> Why not just spell "monkey robot" p-u-r-e?
15:10:14 <monochrom> ok, that may be a way
15:10:51 <jmcarthur_mobile> singleton would be a relatively standard naming for a monomorphic version of it, but I prefer polymorphism anyway
15:10:53 <jrmithdobbs> what is the monkey robot reference?
15:11:04 <quchen> (:[])
15:11:30 <jrmithdobbs> i don't understand how that's a monkey or a robot
15:11:51 <hpc> jrmithdobbs: it's not; it's both!
15:12:03 <acowley> This is a wonderful variation on bike shedding
15:12:05 <jrmithdobbs> hpc: i didn't say xor ;p
15:12:06 <quchen> It's a monkey robot! Get your zoology right, man.
15:12:28 <SLi> One of the things I sometimes dislike about Haskell: There's always a better way, so you can spend infinite time to do things better. (Also, for every problem you encounter, there is one old way to do it and two or three competing new and fancy ways to do it.)
15:12:28 <hpc> acowley: my bike doesn't shed, it molts
15:12:31 <lispy> ?quote monkey
15:12:31 <lambdabot> psykotic says: (:[]) is the happy monkey operator
15:12:39 <acowley> hpc: don't feed it after midnight
15:12:43 <lispy> ?quote monkey
15:12:43 <lambdabot> mmorrow says: in langs with dependent types, you can just map numbers directly to types instead of having to ride a unicycle along a tightrope while battling an unruly gang of monkey with knives
15:12:45 <khyperia> quchen, I had that and also a "(foo :) " call, but the left parenthesis was way far away and I came back to the code, and was very confused at the smiley face.
15:12:47 <quchen> SLi: Same thing in all other languages.
15:12:54 <lispy> We talk about monkeys more than I realized
15:13:01 <hpc> preflex: seen mmorrow
15:13:02 <preflex>  mmorrow was last seen on #ghc 3 years, 330 days, 20 hours, 6 minutes and 4 seconds ago, saying: * mmorrow is rtfm'ing
15:13:08 <quchen> khyperia: I usually can't avoid writing a comment after smiley sections ;-)
15:13:09 <lispy> I'm sure monkeys is right after monads in the word count
15:13:28 <quchen> monkey++
15:13:32 <lispy> That must be a long manual
15:13:38 <acowley> What are the monkey laws?
15:13:41 <lispy> 330 days of rtfm'ing
15:14:06 <Rembane> That's where wisdom comes from
15:14:09 <boom583> I'm sold on ditching C++ and learning a functional language. The question is now, Haskell or OCaml. Does it really matter?
15:14:14 <jmcarthur_mobile> @theorem pure
15:14:15 <lambdabot> Unknown command, try @list
15:14:24 <jmcarthur_mobile> I miss that one
15:14:30 <SLi> quchen: Sometimes yes, but somehow with Haskell there's always one more level of abstraction you can benefit from, and soon you find yourself using arrows and similar relatively arcane constructs to do fairly simple stuff :p
15:14:33 <lispy> boom583: ocaml will probably be a lot more familiar. Although, I think Haskell has a much better eco system
15:14:42 <boom583> ok
15:14:56 <jmcarthur_mobile> boom583: bigger difference the
15:15:01 <jmcarthur_mobile> Ugh
15:15:08 <jmcarthur_mobile> boom583: bigger difference than you might think
15:15:40 <monochrom> it does not matter. toss a coin to choose one. then learn both in parallel anyway. use your left eye and right brain to learn one. use your right eye and left brain to learn the other. the coin toss is for settling which side learns which.
15:15:55 <boom583> ok..
15:16:38 <jmcarthur_mobile> I don't feel like I learned much from OCaml after leaning Haskell, but I think if I had learned ocaml first then Haskell would have still taught me a lot
15:17:01 <boom583> jmcarthur_mobile: oh so you know both? which do you prefer now?
15:17:06 <jmcarthur_mobile> Haskell
15:17:13 <monochrom> why do people act like they can only choose one?
15:17:14 <boom583> y?
15:17:23 <jmcarthur_mobile> I use OCaml professionally and Haskell for all my own projects
15:17:26 <FreeFull> I don't think OCaml has much over Haskell other than strictness and better module system
15:17:30 <FreeFull> And simplicity
15:17:35 <SLi> For example, I'm now writing a program to do relatively simple binary file parsing with textual output. I started with the Writer monad to produce the textual output from pure code, but then I'm warned to use Sequences instead of lists there. Ok, that makes sense. Binary parsing? Apparently the Get monad is a good thing. Two monads? Use monad transformers. Hmm. No GetT? I'm not sure why not, but apparently someone somewhere thinks it makes no sense. Besides,
15:17:35 <SLi> look at the other ways of doing IO. Now I'm reading about pipes, conduits and whatever and more or less baffled :)
15:17:39 <jmcarthur_mobile> My answer is too long for mobile
15:18:12 <jmcarthur_mobile> FreeFull: I don't think ocaml is simpler at all, and I don't think strictness by default is an advantage
15:18:13 <monochrom> "I'm set to eat at McDonald's tonight, but I have difficulty deciding whether it will be salad or burger." solution: get a combo, it has a salad, a burger, and a drink.
15:18:15 <SLi> jmcarthur_mobile: yeah, I learned O'Caml before Haskell, and Haskell definitely added a lot to it.
15:18:33 <jmcarthur_mobile> FreeFull: the module system, though... Love it
15:18:45 <monochrom> indeed, learn all of haskell, ocaml, and scheme.
15:19:11 <boom583> jmcarthur_mobile: you at jane street?
15:19:35 <jmcarthur_mobile> I am
15:19:42 <boom583> cool
15:19:56 <boom583> you wish they had chosen haskell instead? why'd they choose ocaml
15:20:04 <jmcarthur_mobile> Brb
15:20:55 <SLi> Can't say that I never really thought O'Caml is that good a language. It has lots of things that seemingly nobody uses (the object system), and then it contains a small amount of functionality on top of the Hindley-Milner type system that I think makes it impossible to have type classes, which is kind of sad, because they are so useful.
15:20:59 <quchen> monochrom: That's not very practical though. Part of learning a language is learning how to write idiomatic code in it, and for that I think you need some focus, at least for some time.
15:21:23 <quchen> monochrom: I think I'd be hating Haskell for its immutability if I learned Scheme and OCaml alongside.
15:21:38 <SLi> But then my O'Caml experience is at this point quite limited, and I haven't been exposed too much to other people's ocaml code, so maybe I just never figured out how to "use it right"(tm).
15:22:26 <jmcarthur_mobile> boom583: OCaml was kind of a fortunate accident. Used to prototype some stuff and it was liked and stuck
15:22:35 <monochrom> quchen, that sounds very nice, until I recall that every undergrad student takes 5 or 6 courses concurrent and do just fine. today I'm merely asking 3.
15:22:45 <jmcarthur_mobile> boom583: I don't know if we would be better off with Haskell than OCaml
15:22:52 <boom583> ok
15:23:08 <jmcarthur_mobile> boom583: if I was starting fresh I would use Haskell, no question
15:23:17 <boom583> ok cool
15:23:20 <acowley> I think learning Haskell after Scheme is a great way to appreciate immutability
15:23:35 <acowley> Although I think that's true of learning Haskell after most things
15:23:36 <boom583> ok i'm gonna take the plunge into haskell
15:23:38 <boom583> c++ is a mess
15:23:44 <jmcarthur_mobile> Yay!
15:23:53 <jmcarthur_mobile> You'll love it!
15:23:58 <jrmithdobbs> boom583: haskell is just a different kind of mess, really ;p
15:23:58 <boom583> it works, but the code is long and ugly as hell
15:24:03 <boom583> templates: disaster
15:24:12 <quchen> @quote kmc thousand
15:24:12 <lambdabot> kmc says: you should take a look at Boost, they implement things like Maybe and tuples in only a few thousand lines of C++
15:24:33 <boom583> :)
15:24:43 <jrmithdobbs> that's not fair, boost is a hilariously badly maintained lib that has little to do with the language and everything to do with the incompetence of the maintainers ;p
15:25:08 <khyperia> Boost! Boost is... well, whenever I pull something off of my company's svn, I go "craaap, pulling Boost again."
15:25:12 <quchen> It's also the C++ Platform.
15:25:14 <groovy2shoes> acowley: that's how I did it... to be honest I never used much mutation even in Scheme, except as an "escape hatch" of sorts when I couldn't figure out how to express what I wanted without mutation... living without the escape hatch has forced me to think about the nature of the problems I wanted it for
15:25:21 <acowley> People tell you to look at boost to see the future of C++
15:25:53 <acowley> groovy2shoes: I think Scheme drives home how natural immutability can be
15:26:29 <acowley> groovy2shoes: You assemble something fancy in Scheme, and any uses of mutation stick out like a sore thumb
15:27:50 <groovy2shoes> acowley: yup... I feel like Scheme is intrinsically a very beautiful language, but for most things I like to have my type checking earlier rather than later
15:28:08 <acowley> Scheme is spectacular
15:28:19 <acowley> It's the right thing to do if you wanted to invent programming
15:28:23 <quchen> R5 at least.
15:28:25 <acowley> yeah
15:29:09 <groovy2shoes> acowley: I realized today that bind is discussed in SICP, only it's called flatmap and there's no mention of monads at all... I think that's an example of how having a powerful static type system can shine a light on patterns that you might not notice otherwise
15:29:46 <quchen> flatmap sounds like concatMap.
15:29:48 <jmcarthur_mobile> I wonder if we're missing anything else that would make such useful patterns obvious
15:29:49 <groovy2shoes> quchen: have you had a look at R7?
15:30:02 <quchen> concatMap = (>>=), but not (>>=) = concatMap.
15:30:08 <groovy2shoes> quchen: right, and concatMap is bind for lists
15:30:34 <quchen> Well, depending on how you want to read that line above.
15:30:40 <jmcarthur_mobile> quchen: such a clear way to explain how subtyping relationships work
15:31:06 <quchen> What I meant to say is that "bind" is the generic Monad operation. concatMap is an example for bind, but not bind itself.
15:31:22 <quchen> jmcarthur_mobile: I'll collect my prize money when I exit ;-)
15:33:31 * hackagebot sodium 0.10.0.0 - Sodium Reactive Programming (FRP) System  http://hackage.haskell.org/package/sodium-0.10.0.0 (StephenBlackheath)
15:34:27 <SLi> Hey, does it make sense to use conduits or pipes for parsing small-ish (fit nicely into memory) binary files, or are they only useful in a reactive/incremental setting? I'm thinking about the cleanest way to write a program parsing binary and outputting text; my current approach uses ByteStrings, Data.Binary.Get and the Writer monad to smuggle text out of the pure land, and now I need to figure if I should try to use WriterT with Get or something completely
15:34:27 <SLi> different. (Doesn't need to be blazingly fast even.)
15:34:45 <boom583> Btw, anyone here previously a C++ coder for years?
15:34:50 <boom583> and then abandoned C++?
15:34:53 <boom583> for haskell
15:35:11 <groovy2shoes> boom583: I *still* use C++ at work, unfortunately
15:35:20 <QF-MichaelK> boom583: I'm bad at both
15:35:30 <boom583> i was falling in love with c++ actually... :S
15:35:40 <boom583> until a few days ago when i found out about func prog :S
15:35:42 <boom583> strange...
15:35:48 <boom583> hmmm
15:35:48 <identity> boom583: Yes, except I didn't do it for work
15:35:50 <groovy2shoes> boom583: yeah, that can happen
15:35:54 <identity> but C++ was my go-to language for anything and everything
15:36:22 <quchen> ^ seconded
15:36:27 <monochrom> I haven't, in fact, abandoned C++ or anything really. I use C++ for a znc plugin, because znc wants C++. well, I also know how to bridge that with Haskell, it's nice.
15:37:07 <monochrom> I think you are young and religious about languages and hasty to abandon one religion for another.
15:37:08 <identity> I haven't written C++ for a few years now, really. But then again, I haven't (yet) worked as a programmer
15:37:31 <boom583> hehe
15:37:32 <identity> but I don't zealously choose haskell for anything and everything. I choose what fits best
15:37:41 <identity> for my projects, haskell has fit
15:37:42 <quchen> Which is Haskell ;-)
15:37:45 <jj2baile> C is nice~
15:37:57 <ion> I mostly use C+= these days.
15:38:01 <jj2baile> heh
15:38:10 <jj2baile> That got taken down, eh
15:38:14 <identity> yeah
15:38:29 <identity> it was pretty funny, though
15:38:34 <quchen> That got taken down!?
15:38:35 <ion> Itâ€™s on BitBucket now. Perhaps theyâ€™re not as triggerhappy against controversial jokes.
15:38:49 <acowley> I've used a lot of languages over the years, but I use Haskell wherever I can now. Somebody recently asked me where Haskell was appropriate, and I really couldn't think of a situation where I wouldn't use Haskell other than working with other programmers / existing code.
15:39:21 <monochrom> grow older to see that every language is equal, but Haskell is more equal. (pun! see my http://www.vex.net/~trebla/haskell/prerequisite.xhtml for in what sense Haskell is more equal!)
15:39:21 <jj2baile> What examples are there of people using haskell in low-level or embedded systems?
15:39:24 <jj2baile> (if any)
15:39:51 <acowley> See Atom, Copilot, and my NYHUG talk that mixes SBV into that combination!
15:39:53 <KiriKari> jj2baile: atom
15:39:57 <ion> http://www.haskell.org/haskellwiki/Haskell_in_industry
15:40:04 <quchen> I use Haskell for most (!) things because I find using it more enjoyable. Others find other things enjoyable.
15:40:18 <jj2baile> KiriKari: ion, thanks
15:43:46 * boom583 orders LYAH!!!!!!!
15:43:49 <boom583> about time
15:43:58 <boom583> this is going to be a LONG learning curve
15:44:00 <boom583> scary
15:44:00 <haasn> jj2baile: house
15:44:10 <johnw> boom583: it's so much fun though
15:44:17 <boom583> :D
15:44:19 <johnw> boom583: if you like that feeling that comes right after confusion
15:44:33 <haasn> http://programatica.cs.pdx.edu/House/
15:45:03 <jj2baile> Ah yes, I recall reading about that somewhere
15:46:48 <thebnq> oh theres an intel haskell backend, very neat
15:48:03 <thebnq> i think not open :<
15:49:10 <quchen> johnw: You mean confusion? ;-)
15:49:40 <quchen> thebnq: There is a recent paper describing it though.
15:49:54 <quchen> I think it starts from GHC's core output and then does its own transformation and code generation.
15:50:13 <thebnq> quchen: yeah, i just came across it, its really long!
15:50:37 <quchen> You don't have to read the entire thing, I think there's a pretty good description somewhere in the beginning.
15:50:50 <quchen> That's enough to give you a general overview of what the thing is doing.
15:51:17 <quchen> If I recall correctly it has good low-level bit-flipping optimizations, which is what makes many algorithms so fast with it.
15:51:49 <khyperia> Does anyone know how 'data' definitions desugar into Core? I'm writing my own compiler, and I'm very confused as to how that works.
15:52:45 <identity> I'm somewhat confused about adding test-suites to cabal files. I have a /test dir in my Project dir, which contains RunTests.hs, which is supposed to aggreate tests from the test dir's subdir's modules and so on. I have test-module set to RunTests, have hs-source-dirs: test, but it's telling me that RunTests doesn't match module name(e.g. it expects Main.hs). Do I need main-is ?
15:54:40 <acowley> identity: Yes
15:54:42 <bergmark> identity: i think so
15:57:51 <identity> That doesn't seem to the case. In fact, it tells me that main-is isn't used for test-suite type detailed-0.9. I have another question, though: I naturally want to be able to use my code from the src dir, so I added src to hs-source-dirs. However, that requires me to add all the build-depends already in place for the project itself in the cabal file.
15:58:03 <identity> Is there not a way to .. make this implicit, or something? or depend upon the project itself?
16:03:51 <quchen> identity: Have you read the user's guide?
16:04:03 <quchen> Test section for "detailed": http://www.haskell.org/cabal/release/cabal-1.18.1.2/doc/users-guide/developing-packages.html#example-package-using-detailed-1.0-interface
16:04:26 <identity> i have, yes
16:04:32 <identity> I have it open, even
16:04:41 <identity> it is not very detailed, I feel
16:05:19 <identity> I want to use Hspec for my testing purposes.. I assumed it would be able to work with cabal's way of testing
16:06:23 <identity> hmm
16:06:27 <identity> I'll figure something out, I guess
16:07:23 <quchen> Looks like it automatically runs "tests" in the source file you specify via "test-module".
16:08:02 <identity> yes, indeed. But those are of different type than what hspec makes, naturally. I guess I'll have to wrap those in the type that cabal expects
16:08:47 <quchen> Hm. I would think that a testing library is compatible with Cabal; maybe there's a separate submodule?
16:09:35 <bergmark> identity: you can check if tasty solves this
16:09:54 <identity> bergmark: I had looked at tasty, but I really like Hspec's way of doing things
16:10:11 <identity> oh, hmm. there seems to be a submodule for hunit undir Distribution.TestSuite
16:12:24 <bergmark> identity: http://hackage.haskell.org/package/tasty-hspec
16:13:08 <identity> bergmark: Aha, I see
16:13:14 <identity> maybe tasty is the way to go, then
16:13:20 <Feuerbach> identity: you may have better luck with exitcode-stdio instead of detailed. I don't think 'detailed' is much tested or used at the moment
16:13:32 <Feuerbach> but you can also file an issue for Cabal
16:13:58 <bergmark> i have been battling with Cabal all day :-h
16:14:04 <Feuerbach> and, frankly, I don't think tasty can help here
16:14:45 <identity> Feuerbach: I'm not sure this is an issue as such. I think most testing frameworks just assume you aren't using cabal to run tests
16:15:04 <identity> which I frankly feel is a bit strange, because it sounds like it would be the obvious choice to me
16:15:08 <Feuerbach> no, they just don't support 'detailed'
16:15:17 <identity> oh?
16:15:18 <Feuerbach> they do support 'exitcode-stdio'
16:15:23 <identity> I see
16:16:14 <Feuerbach> (I thought you have some compilation problem with 'detailed' â€” that could be a Cabal bug. But I may have misunderstood.)
16:16:29 <identity> Well, I just went with detailed because the user guide literally says that exitcode-stdio is primarily there for "compatibility reasons."
16:17:07 <identity> and that it is preferred that new test-suites used detailed. But maybe they are referring to writers of actual test-suites such as hspec and such
16:17:18 <identity> But I assumed that I was supposed to use detailed.
16:17:20 <identity> But thanks!
16:17:31 <identity> I'll just go with exitcode, so that I actually have working tests
16:18:04 <identity> Feuerbach: Oh, you're the author of tasty?
16:18:09 <Feuerbach> yes
16:18:28 <identity> cool!
16:18:54 <Feuerbach> I never actually looked at detailed closely. Now may be a good time then :)
16:20:01 <identity> Feuerbach: It seems to be reimplementing some of what test suites like tasty, hunit and so on are doing already tbh
16:20:17 <identity> But I think I may just choose tasty as it works with hspec as well, so I can mix and choose basicaloy
16:20:21 <identity> basically*
16:21:13 <uniquenick> you can't pass modules around as values can you?
16:21:45 <identity> uniquenick: nope. what are you trying to accomplish
16:21:46 <identity> ?
16:23:29 <uniquenick> I'm not sure how to explain this well.  I think I need to use a typeclass, but I want to make sure first
16:24:11 <uniquenick> I want to make a thing that contains some functions, and a user of my library can pass those kinds of things in to library functions, and they can call the functions in them
16:25:06 <Feuerbach> you can use existential types to emulate first-class modules (if you're sure you need them)
16:25:27 <merijn> @where existential-antipattern
16:25:27 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
16:25:44 <heatsink> Generally, you would just make a data type whose fields are functions
16:25:48 <merijn> uniquenick: Maybe that link can inspire alternate solutions
16:27:22 <uniquenick> heatsink, but then my library can't call the function in it can it?  like, if I pass in a "Foo (a->b) (a->b)" don't I also need to pass in those functions separately as well?
16:28:21 <heatsink> > case (fst, snd) of (x, y) -> x (1, 2)
16:28:22 <lambdabot>  1
16:30:34 <heatsink> uniquenick, it's just a data structure containing a function.  If you can get a field of a data structure and you can call a function, you can call a function that's in a data structure.
16:32:08 <uniquenick> oh, like I would have to just ignore the names they are given in the record type and pattern match on the order they exist in the structure?
16:34:23 <Feuerbach> no, you could use record selectors just as well
16:36:59 <uniquenick> I would have to know what module they are in at compile time wouldn't I?
16:37:59 <heatsink> If you put the number 5 into a data structure and you want to read it out later, do you have to know what module 5 was in at compile time?
16:38:08 <Feuerbach> The point is, you can create things that behave like modules and are first class (but they aren't real Haskell modules)
16:40:00 <Feuerbach> data SetModule = forall s . SetModule { empty :: s a; insert :: a -> s a -> s a; ... }
16:40:34 <Feuerbach> existential type is needed to make your type abstract to the module's user (assuming you want it)
16:47:56 <DigitalKiwi> preflex: seen glguy
16:47:57 <preflex>  glguy was last seen on #haskell-lens 3 days, 22 hours, 2 minutes and 44 seconds ago, saying: like _ = simple
17:22:55 <hexagoxel> sometimes i even have to join the chat an start phrasing my question to find the answer myself.. meh
17:23:16 <David> rubber duck debugging via irc
17:37:38 <SLi> Hmm, there's a difference between cabal install pkg1; cabal install pkg2 and cabal install pkg1 pkg2? If I cabal install pipes-bytestring and cabal install pipes-extra, both installations happen, but if I say cabal install pipes-bytestring pipes-extra, I get an error message.
17:38:25 <pavonia> What error message?
17:40:49 <SLi> In order, the following would be installed: pipes-4.0.1 (reinstall) changes: void-0.6.1 -> 0.5.12; pipes-parse-2.0.2 (reinstall); pipes-bytestring-1.0.2 (reinstall) changes: bytestring-0.10.0.2 -> 0.9.2.1; cabal: The following packages are likely to be broken by the reinstalls: pipes-binary-0.2.1
17:41:09 <SLi> on "cabal install pipes-bytestring pipes-extra"
17:48:08 <sm> SLi: yes there is. Usually cabal can make a better install plan when you install them all at once
17:48:48 <sm> in this case it looks like you installed another package, pipes-binary. Install that one also in the same command and it should be happy
17:50:04 <SLi> sm: My problem is the opposite; installing both at the same time gave the above error message, but installing them separately succeeded.
17:54:52 <SLi> Oh how much I would like to have in hackage on every page belonging to a package a link to the newest version of that package... Google tends to always land on some obsolete version of a package in a non-obvious way.
17:55:11 <sm> SLi: try it
17:55:25 <sm> the state is different now
17:56:57 <SLi> sm: The cabal install? Still fails with exactly the same error message (after cabal update).
17:57:02 <manny> i have just noticed that ghci executable has identifier completion, but haskell mode in emacs doesn't. :/
17:57:06 <SLi> sm: But I did get the packages installed though.
17:57:23 <sm> ie: cabal install pipes-bytestring pipes-extra pipes-binary ? ok good
17:57:57 <sm> and, agreed about hackage, that would be a nice easy pull request
18:02:00 <manny> kind of OT, but I am wondering if it is right to call this monadic null checking? http://damieng.com/blog/2013/12/09/probable-c-6-0-features-illustrated ChanServ ChanServ
18:02:54 <manny> it looks more like fromMaybe, which as far as I see it doesn't have much to do with monads
18:08:37 <manny> 7th point down the list
18:08:50 * hackagebot LambdaHack 0.2.10.5 - A roguelike game engine in early and active development  http://hackage.haskell.org/package/LambdaHack-0.2.10.5 (MikolajKonarski)
18:23:15 <quchen> That's not really monadic. That's Maybe-ic, and has some resemblance to Maybe's Monad instance.
18:23:44 <quchen> Except that Nothing is still "-1" and you can forget null checking.
18:23:56 * hackagebot Allure 0.4.10.5 - Near-future roguelike game in very early and active development  http://hackage.haskell.org/package/Allure-0.4.10.5 (MikolajKonarski)
18:24:29 <quchen> In other words it's nothing but sugar for the same code.
18:25:39 <identity> Feuerbach: Is there a known issue using Tasty.Hspec and mangled terminal output?
18:26:25 <identity> I read somewhere that hspec already does some parallel stuff while testing.. The output to the terminal looks very much like a non-mutually exclusive access to stdout
18:27:29 <Feuerbach> is it on windows? there are some issue with colors on windows that I haven't got around fixing yet
18:27:34 <Feuerbach> or what do you mean by mangled?
18:27:42 <identity> Feuerbach: nope, ubuntu 12.04
18:28:02 <identity> I mean mangled like two threads trying to print two different lines of text at the same time
18:28:20 <identity> let me paste it, sec
18:28:34 <Feuerbach> oh. then try reporting it to tasty-hspec maintainer, I guess
18:29:10 <identity> http://paste.ubuntu.com/6570106
18:29:17 <identity> yeah I guess I might
18:29:29 <identity> i'll have to avoid tasty.hspec for now then
18:30:21 <identity> lines 5 - 10 roughly btw
18:31:06 <Feuerbach> Fair enough. But please do file the report (together with the code to reproduce)
18:32:12 <identity> i will, thanks
18:52:53 <sm> hledger now depends on a newer version of happy than the default (because of pretty-show). Should I add happy-0.19 as a dependency, to ease installation ?
19:04:01 * hackagebot haskoin-util 0.0.1.1 - Utility functions for the Network.Haskoin project  http://hackage.haskell.org/package/haskoin-util-0.0.1.1 (PhilippeLaprade)
19:04:35 --- mode: geekosaur set -o geekosaur
19:04:37 <geekosaur> oops
19:08:18 <bicgena> is writing a binary heap non-trivial in haskell? I mean, you're not allowed to mutate stuff, so swapping up and down requires some thought
19:09:22 <simpson> bicgena: It's not too hard.
19:10:10 <bicgena> simpson: expound?
19:10:26 <simpson> bicgena: Well, just like any other value, you just have to return the new heap.
19:14:44 <simpson> bicgena: You've seen the basic list manipulation structures, right? They all return a new list.
19:26:57 <bicgena> simpson: how about finger trees?
19:27:40 <bicgena> simpson: What if I wanted to do it with pointers?
19:27:42 <simpson> bicgena: Sure; there's an implementation in Data.Set, I think.
19:28:09 <simpson> bicgena: Well, the concept of a pointer is not as helpful in Haskell.
19:28:27 <bicgena> simpson: yes, but as an exercise
19:29:19 <simpson> bicgena: What are you reading to learn Haskell?
19:29:48 <simpson> I'm not much of a teacher, but maybe I can point you towards something useful.
19:43:53 <jle`> a naive binary heap probably is one of the simpler functional data structures
19:44:16 <jle`> more or less a direct application of recursive data structures
19:44:39 <jle`> an efficient one might take more work
19:45:26 <jle`> some work as in, it's a day 2+ project
19:47:50 <jle`> aw i would have recommended http://www.amazon.com/dp/0521663504/ref=pe_385040_30332200_pe_309540_26725410_item
19:47:54 <jle`> it was $10 last week for some reason
19:47:58 <jle`> but it's back to $45 now
19:49:07 * hackagebot hledger-lib 0.22 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.22 (SimonMichael)
19:49:09 * hackagebot hledger 0.22 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.22 (SimonMichael)
19:49:11 * hackagebot hledger-web 0.22 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.22 (SimonMichael)
19:51:25 <Sgeo> Do people still use Parsec, or are people more focused on things like attoparsec these days? I see so many attoparsec-whatever libraries...
19:52:41 <Sgeo> Also, why does Text.Parsec contain its own (<|>)? I thought it used the Alternative version?
19:59:52 <sm> Sgeo: people still use parsec, because of it's maturity/simplicity/excellent error messages
20:00:27 <Sgeo> The whole try thing bugs me a bit... although it's not like I've actually _used_ any of these things
20:00:58 * sm hasn't tried anything but parsec, to be honest
20:04:59 <pavonia> Sgeo: The version of <|> had been in Parsec even before Applicative was introduced, I think
20:05:11 <dwcook> Sgeo, you mean how Parsec doesn't backtrack if it's consumed any input? What's a popular library that does?
20:05:28 <Sgeo> dwcook: Attoparsec, I think?
20:05:30 <pharaun> it does if you slap on a "try"
20:05:35 <dwcook> pharaun, right
20:06:16 <pharaun> i learned parsec and i've just stuck with it since
20:06:23 <pharaun> its pretty nice, esp the error messages
20:06:27 <dwcook> I actually wrote my own simple parser library and then wrote some parsers in it, then ported them to Parsec, and couldn't figure out why the heck they were failing on this one production. It turned out I just needed to throw a try in.
20:09:07 <sm> you get used to it
20:09:37 <simpson> And this is why I like the parsers library.
20:09:45 <danharaj> !tell edwardk I'm in boston this weekend. If you're game to have brunch or somesuch give me a holla.
20:09:50 <danharaj> (or is it @tell)
20:10:01 <simpson> It's @tell, yeah.
20:10:01 <dwcook> @help tell
20:10:02 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
20:10:25 <danharaj> @tell edwardk I'm in boston this weekend. If you're game to have brunch or somesuch give me a holla.
20:10:25 <lambdabot> Consider it noted.
20:11:06 <djahandarie> danharaj, I can come too, that way it'll be more confusing who is who
20:11:25 <danharaj> hahaha
20:11:30 <djahandarie> I hear the weather is going to be kind of shitty though.
20:11:33 <sm> http://lpaste.net/96953 is handy for tracing parsec progress
20:12:50 <danharaj> It is cold as canadian butts right now.
20:13:06 <danharaj> And I go out in a t-shirt if the weather is 32F+ so that's saying something.
20:23:55 <simpson> What's the best way to take an Enum type and provide a String for each constructor? I want Strings that don't correspond to the Show or Read instances, and I want to be able to go to and from the constructors to the Strings easily.
20:31:04 <Hafydd> simpson: ('_':) . show
20:32:37 <simpson> Hafydd: I want to pick the Strings; this is for a parser table.
20:33:59 <Hafydd> simpson: well, it doesn't sound like you'll get away with anything shorter than just writing a function clause for each constructor.
20:34:33 <simpson> Hafydd: I used zip to make a quick association list. Good enough for me!
20:34:37 <Hafydd> But you could perhaps make it half the length by taking elements of a list in the same order as the constructors (based on the Enum instance).
20:35:42 <ion> Not fragile at all
21:21:37 <jle`> how long does it take for someone to get used to $?
21:21:41 <jle`> like cognitively
21:21:47 <jle`> i don't even remember my own process
21:22:08 <jle`> i have heard that $ is hard to understand for new peoples
21:22:59 <DigitalKiwi> pretty sure it's 16
21:23:26 <DigitalKiwi> i don't know the unit
21:23:31 <DigitalKiwi> but definitely 16
21:23:37 <udevd> not the Ä§?
21:24:29 <udevd> jle`: well, for me it was rather straightforward...
21:24:35 <udevd> what's so hard about it?
21:25:21 <twiceler> It's strange because it just sort of reassociates things. It went like this for me:
21:25:30 <twiceler> f (g (h x))
21:25:37 <twiceler> f $ g $ h x
21:25:45 <twiceler> f . g $ h x
21:29:40 <ddere> can someone pls explain to me what the '|' and '->' bits in type class declarations like this mean: "class Monad m => MonadState s m | m -> s where"?
21:30:10 <joelteon> fundeps
21:30:12 <joelteon> functional dependencies
21:30:31 <joelteon> that means that for every m there can only be one s
21:30:43 <ddere> ah ok cool thanks :)
21:31:21 <joelteon> you can define MonadState Int Foo, and MonadState Int Bar, but not MonadState Int Foo and MonadState () Foo
21:31:25 <joelteon> if I remember correctly
21:31:35 <ddere> hmm ok
21:42:58 <rhodesd> !seen nitus
21:43:23 <rhodesd> !seen nitus
21:43:36 <rhodesd> ooops sorry
22:05:47 <jle`> huh.  cons, head, and tail are push, top, and pop
22:05:54 <jle`> my mind is blown.
22:14:57 <pavonia> How do you check if an addition/multiplication would cause an Int to overflow?
22:15:53 <notdan> pavonia: depends on the architecture really
22:16:45 <pavonia> Hhm, that's a RWH exercise, so it shouldn't be too difficult
22:16:58 <notdan> the result should be less than one of the summands?
22:17:27 <pavonia> it asks for calling error if it would overflow
22:19:45 <pavonia> Ahh, I guess you could use Integer and check if it's larger than maxBound :: Int
22:21:29 <pavonia> Yep, that works
22:29:11 <jle`> you don't even need the type signature if the type of 5 can be inferred
22:29:26 * hackagebot data-memocombinators 0.5.1 - Combinators for building memo tables.  http://hackage.haskell.org/package/data-memocombinators-0.5.1 (LukePalmer)
22:29:47 <jle`> oh i didn't think about that well enough.
22:32:25 <jle`> i wonder if there is a way to use an ord instance of (->) to get a variable-arity max/min
22:32:44 <jle`> or a simulated variable-arity
22:33:08 <jle`> like you can do with mempty
22:33:48 <notdan> jle`: yeah you can do that, printf is implemented that way
22:34:08 <notdan> althou I am not sure why do you consider mempty to be of a variable arity
22:34:35 <notdan> jle`: http://typesandkinds.wordpress.com/2012/11/26/variable-arity-zipwith/
22:36:57 <jle`> huh Ord requires an Eq
22:38:29 <jle`> i wonder how i can do that
22:39:17 <jle`> welp i'm stuck.
22:39:22 <ion> Huh? If you can do Ord, you surely can do Eq, no?
22:39:28 * hackagebot superdoc 0.1.1.0 - Additional documentation markup and Unicode support  http://hackage.haskell.org/package/superdoc-0.1.1.0 (PeterSelinger)
22:39:56 <jle`> well i was trying to do Ord but it made me do Eq first
22:40:16 <ion> You can implement Eq in terms of Ord if you really want to.
22:40:19 <jle`> i'm guessing two functiona (a -> b) are equal if they equal the same b when both applied to the same a ?
22:40:56 <jle`> and less than/greater than eachother if the b's are less than/greater than eachother given the same a?
22:41:00 <jle`> i dont think this even makes sense to implement
22:41:23 <ion> Oh, functions? You can have Eq b => (a -> b) -> (a -> b) -> a -> Bool but i donâ€™t think you can have Eq b => (a -> b) -> (a -> b) -> Bool.
22:41:44 <jle`> my main hope is to somehow use a function instance of ord to be able to do something like max 1 2 3
22:42:05 <ion> > maximum [1,2,3]
22:42:06 <lambdabot>  3
22:42:12 <jle`> noo
22:42:19 <jle`> don't you know variable arity is trendy these days
22:42:40 <ion> Yes, Haskell calls that â€œa list parameterâ€.
22:42:57 <jle`> i just want to do something cool T.T
22:43:03 <jle`> > mempty 1 2 3 :: [Int]
22:43:04 <lambdabot>  []
22:43:30 <jle`> something analogous to that
22:43:32 <jle`> but for max
22:49:11 <worshipful> so incredibly pissed at gays right now
22:49:42 <worshipful> i was on the bus today, and i searched twitter for "gay" and i got so pissed that the bus actually broke down
22:50:02 <worshipful> don't furries exist too?
22:50:14 <simpson> worshipful: Wrong channel.
22:51:00 <worshipful> well where's the right channel?
22:51:03 <worshipful> tell me..
22:51:15 <worshipful> where's the channel to speak truths
22:51:42 <prooftechnique> I can't even imagine
22:52:02 <worshipful> if you're talking about me, yeah it sucks being a furry
22:52:07 <worshipful> IT SUCKS SO BAD
22:52:14 <worshipful> but it's ok because i'm strong
22:52:28 <worshipful> i will pave the way for generations of others
22:52:29 <ion> @where ops
22:52:29 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:52:36 <worshipful> oh and you want to get the ops ion
22:52:43 <worshipful> fine get the ops
22:52:44 <worshipful> see if i care
22:52:47 <Saizan> @opme
22:52:49 <lambdabot> Local time for Saizan is Sat Dec 14 07:43:04 2013
22:52:52 --- mode: ChanServ set +o Saizan
22:52:57 <worshipful> bring em out
22:53:03 --- mode: Saizan set +b *!*worshipfu@*.wireless.uic.edu
22:53:03 --- kick: worshipful was kicked by Saizan (worshipful)
22:53:14 --- mode: Saizan set -o Saizan
22:53:26 <prooftechnique> That was helpful
22:58:00 <chrisblake> every monad is also a functor, as well as an applicative functor, correct?
22:58:54 <jle`> chrisblake: ya
22:58:59 <jle`> in theory
22:59:08 <jle`> but not necessarily in implementation
22:59:09 <chrisblake> jle`: but not in actual code?
22:59:24 <simpson> Writing out the instance might be required, but yes.
22:59:50 <jle`> you get functors for free if you have an applicative, and applicatives for free if you have a monad, so it's only a minor inconvenience
22:59:53 <chrisblake> so is IO also applicative and a functor?
23:00:00 <jle`> chrisblake: mhm
23:00:02 <simpson> Yeah, and it's got the instance.
23:00:11 <chrisblake> okay, cool. wasn't quite sure
23:00:14 <chrisblake> thanks guys :)
23:01:09 <jle`> chrisblake: sometimes actually IO's functor instance is just as useful as its monad instance
23:01:45 <chrisblake> jle`: yeah, because I needed to fmap some code in IO, actually; but I wasn't sure it would work; so I double-checked by asking you guys :)
23:01:46 <jle`> applicative instance as well
23:10:50 <ion> fmap is the answer to the actual question behind â€œI have String â†’ Foo, how do i get String out of IO String?â€ (where Foo is not IO Foo)
23:11:36 <ion> â€œ:i IOâ€ in ghci will list the classes it instantiates.
23:12:03 <ion> (in the modules you have loaded)
23:20:03 <jle`> (+) <$> readLn <*> readLn
23:20:13 <jle`> it'd be cool if lambdabot had some sort of IO simulator/module
23:24:29 <AshyIsMe> > print "now accepting patches!"
23:24:30 <lambdabot>  <IO ()>
23:24:34 <AshyIsMe> haha
23:33:50 <Sgeo> It would be nice if there was syntax sugar for applicatives. Just do with some restrictions, right?
23:37:26 <johnw> Sgeo: there is currently a proposal for just that
23:38:28 <Sgeo> And if Haskell were a bit better at metaprogramming, it woudn't need a 'proposal' for it to be implemented, just like lens is a mere library and not an intrinsic part of the language
23:38:53 <Ralith> Sgeo: what's wrong with a quasiquoter?
23:38:54 <Sgeo> Although I guess if macros were popular in Haskell, people... might not come up with nice abstractions like lenses in the first place
23:39:26 <Sgeo> They look out of place, and I think they're probably annoying to write (you have to parse a string, right?)
23:40:20 <johnw> could idiom brackets be written with a quasi-quoter?
23:40:59 <Sgeo> With idiom brackets, the 'pure' elements get marked, right? (Not sure the more accurate way to phrase that)
23:43:33 <Sgeo> Idiom brackes for monads, marking the 'impure' expressions instead, so that you could mark twice to effectively join
23:43:34 <mgsloan> I think you'd just use (pure ...) for the pure elements
23:43:51 <mgsloan> I guess if you're using sugar, might as well add more for pure :D
23:44:21 <Sgeo> Except that's still not as sugary as you can get in Scala or Scheme :/
23:44:34 <mgsloan> johnw: Yup!  http://hackage.haskell.org/package/applicative-quoters
23:44:40 <Sgeo> https://github.com/urso/embeddedmonads
23:44:42 <johnw> hehe
23:44:54 <mgsloan> Sgeo: Some would count that as a plus.  Too much sugar can rot your teeth!
23:45:59 <Sgeo> value :: (Monad m) => m a -> a as a real function that can be passed around, abeit only meaningful within the dynamic extent of another function... I guess a function that replies on being in a dynamic extent isn't really a pure function?
23:46:21 <robonerd> how does haskell handle error handling?
23:46:27 <robonerd> like if a function doesn't r un properly
23:46:35 <robonerd> say a file read function failed because the path was wrong
23:46:36 <johnw> can you implement dynamic extent using implicit params?
23:47:15 <jle`> robonerd: one way is to return a data container that is either empty with an empty flag, or has the item with a not-empty flag, and process things from there
23:47:27 <Sgeo> johnw: what I really need for such a function is native delimited continuations, not just Cont, but something usable in any expression
23:47:36 <jle`> robonerd: this is typically the most idiomatic way.  however there are cases where you can't avoid exceptions
23:47:42 <jle`> in IO
23:47:51 <jle`> when you deal with things like concurrency etc.
23:47:52 <robonerd> how do exceptions work in haskell?
23:48:07 <jle`> haskell provides the standard try/catch/rescue block type of things
23:48:16 <jle`> but tehy aren't built into the language necessarily
23:48:25 <jle`> they are actually implemented as normal functions i think for the most part, except for some primitives
23:48:54 <Sgeo> What is this parseExp thing?
23:49:36 <Sgeo> It... looks essential to making quasiquoters that take Haskell-like syntax
23:49:52 <Sgeo> But is it just from a library that someone made, looks like it :/
23:49:55 <jle`> :t bracket
23:49:57 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
23:50:04 <robonerd> try catch rescue is where you try something, but what is catch and what is rescue?
23:51:06 <jle`> i'm using idioms from other languages
23:51:15 <jle`> but catch is when your trying causes an exception
23:51:22 <jle`> and you catch the exception
23:51:25 <jle`> and handle it
23:51:38 <Sgeo> try and catch don't actually work together, they're used in different ways
23:51:40 <Sgeo> :t try
23:51:42 <lambdabot> Exception e => IO a -> IO (Either e a)
23:52:04 <jle`> sorry, i'm mixing up my terms
23:53:32 <jle`> robonerd: are you familiar with how IO works in haskell?
23:53:38 <robonerd> yes
23:53:52 <Sgeo> :/ at parseDo
23:54:01 <jle`> then try takes an IO action returning an a, and turns it into an IO action returning an Either e a, where e is an exception
23:54:37 * hackagebot querystring-pickle 0.1.8 - Picklers for de/serialising Generic data types to and from query strings  http://hackage.haskell.org/package/querystring-pickle-0.1.8 (BrendanHay)
23:54:41 <jle`> this new IO action "tries" the first one, and if it's succesful, returns Right a.  If it isn't, and there is an exception, it returns Left e
23:54:41 <robonerd> so try appends exception onto any other return type
23:54:49 <Sgeo> Tcl might have string-based metaprogramming, but at least that matches up with the basic structure of Tcl cod
23:54:49 <robonerd> to create the slot for something to fail into
23:54:50 <Sgeo> code
23:54:55 <Sgeo> Well, mostly
23:54:55 <jle`> more or less
23:55:07 <robonerd> k ty
23:55:18 <Sgeo> :t catch
23:55:19 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
23:56:44 <jle`> admittedly everything i know comes from Simon Marlow's text
23:56:47 <jle`> you can fidn it online
23:57:06 <Sgeo> .... who writes flip mapM?
23:57:49 <jle`> robonerd: http://chimera.labs.oreilly.com/books/1230000000929/ch08.html
23:57:55 <jle`> scroll down a bit to see "Exceptions in Haskell"
23:57:58 <johnw> Sgeo: anyone who doesn't know about forM
23:58:11 <jle`> Sgeo: maybe it was before forM was in base
23:58:21 <jle`> i actually see it a lot in older code
23:58:23 <johnw> i write flip map sometimes
23:58:39 <arkeet> you could use <&> for that
23:58:59 <jle`> :t (<&>)
23:58:59 <lambdabot> Functor f => f a -> (a -> b) -> f b
23:59:03 <arkeet> lens
23:59:04 <johnw> huh, cool
23:59:21 <jle`> do they just throw in random convenient operators on lens
23:59:27 <johnw> > sequence $ [1,2,3,4] <&> \x -> print x
23:59:29 <arkeet> well it's the functor version of (&)
23:59:29 <lambdabot>  <IO [()]>
23:59:44 <jle`> that makes sense
23:59:47 <arkeet> and it's convenient for defining lenses
