00:00:05 <johnw> i can't change the github.com project, but I can incorporate the patch manually
00:00:26 <arkeet> you can also merge it into your own one
00:00:54 <pdxleif> Is there a way to tell to not to treat a lowercase identifier in a pattern match as a fresh var name to bind?
00:00:55 <arkeet> where has cmccann gone, anyway
00:01:03 <arkeet> pdxleif: no.
00:01:19 <pdxleif> I'm trying to match on methodPost here, and it thinks I want to bind whatever to that, showing the existing def: http://hackage.haskell.org/package/http-types-0.8.2/docs/Network-HTTP-Types-Method.html#t:Method
00:01:35 <ReinH> pdxleif: are you, in fact, in pdx?
00:01:40 <ReinH> pdxleif: wait, haven't we had this conversation before?
00:01:49 <arkeet> pdxleif: you can't do that, but you can bind it to a variable and then guard on equailty
00:01:52 <arkeet> equality.
00:01:56 * hackagebot these 0.4.1 - An either-or-both data type, with corresponding hybrid error/writer monad transformer.  http://hackage.haskell.org/package/these-0.4.1 (JohnWiegley)
00:02:10 <ReinH> view patterns? o_O
00:02:10 <pdxleif> ReinH: Yep
00:02:20 <pdxleif> ReinH: Probably, been a while... I forgot?
00:02:25 <ReinH> pdxleif: well, so am I :)
00:02:43 <pdxleif> You come to the pdxfunc meetings or work at Galois or anything?
00:04:02 <arkeet> preflex: seen cmccann
00:04:03 <preflex>  cmccann was last seen on #haskell-lens 61 days, 9 hours, 47 minutes and 19 seconds ago, saying: sounds legit.
00:04:58 <pdxleif> Hmm, in this case, I can have case (parseMethod . requestMethod) req of Right POST, and that works...
00:05:00 <johnw> preflex: seen johnw
00:05:00 <preflex>  johnw was last seen on #haskell 4 minutes and 55 seconds ago, saying: i can't change the github.com project, but I can incorporate the patch manually
00:05:18 <ReinH> pdxleif: I don't but I should come to meetings!
00:06:08 <ReinH> I'll keep my eye on the group
00:06:50 <arkeet> pdxleif: yes, because POST is a constructor
00:06:58 <arkeet> that's one of the things you can pattern match on.
00:08:33 <arkeet> oh, yes. that's probably the thing to do.
00:09:10 <ReinH> do any of you use view patterns in anger? I'm not sure if it's a thing people really do... or just a thing people COULD do.
00:10:56 <arkeet> no, I'm usually pretty calm when I use view patterns.
00:11:42 <nisstyre> ReinH: I've only used them when experimenting
00:12:48 <ReinH> arkeet: ok, but do you use them for non-trivial non-toy stuff?
00:13:01 <arkeet> I haven't really used haskell for non-trivial non-toy stuff. =(
00:13:42 <nisstyre> I have
00:13:53 <nisstyre> the code was a mishmash of applicatives and http-conduit crap
00:14:09 <ReinH> arkeet: :p
00:14:09 <nisstyre> and json related stuff
00:14:37 <nisstyre> oh, and mysql :\
00:15:10 <ReinH> arkeet: can you walk me through the proof that foo :: M a -> a;  foo . return = id?
00:15:18 <nisstyre> at first it used an insane amount of memory, but then I compiled it with -02
00:15:23 <arkeet> ReinH: foo . return :: a -> a
00:15:24 <nisstyre> er -O2
00:15:27 <ReinH> nisstyre: maybe something you'd use lenses for now?
00:15:28 <arkeet> @free fribble :: a -> a
00:15:29 <lambdabot> f . fribble = fribble . f
00:15:36 <nisstyre> ReinH: I think I did use lenses somewhere in there
00:15:37 <ReinH> oh.
00:15:52 <nisstyre> it was only like 5 months ago
00:17:07 <nisstyre> ReinH: part of the code was just awful. Part of its job was to interface with a wordpress installation (yes, I know) and the plugin they were using stored stuff in the database in wordpress serialized form
00:17:18 <nisstyre> so I wrote an attoparsec parser that parsed a subset of that
00:17:20 <arkeet> ReinH: is it clear?
00:17:32 <ReinH> arkeet: I can see it, but as if from a great distance...
00:17:41 <ReinH> arkeet: which monad law do I need?
00:17:44 <arkeet> none@!
00:17:55 <ReinH> ok go on :)
00:17:56 <arkeet> anything of type a -> a is id (or something less defined)
00:18:03 <ReinH> oh
00:18:08 <arkeet> because it's polymorphic.
00:18:13 <ReinH> ohhh
00:18:31 <ReinH> because you don't know enough about a for it to be anything else
00:18:40 <johnw> right
00:18:42 <ReinH> it's the only free f :: a -> a
00:18:54 <ReinH> ok duh
00:19:00 <johnw> parametric polymorphism ftw
00:19:04 <ReinH> :)
00:19:10 <nisstyre> is there a notion of the "principle implementation" the same way there is a principle (most general) type?
00:19:26 <nisstyre> how do you rigorously define id as the most general version of a -> a ?
00:19:37 <johnw> you say that it's unique up to unique isomorphism
00:19:54 <arkeet> "up to isomorphism" doesn't make sense in this context either.
00:19:57 <johnw> i.e., that any other implementation will be uniquely isomorphic to id
00:19:57 <nisstyre> okay, I sort of get that
00:20:05 <arkeet> I hope not.
00:20:08 <arkeet> because it doesn't make sense. =(
00:20:09 <ReinH> hah
00:20:14 <johnw> arkeet: it doesn't?
00:20:22 <nisstyre> arkeet: I'm used to trying to make sense of things that don't make sense to me
00:20:28 <nisstyre> but that does kind of make sense
00:20:41 <arkeet> but it shouldn't, because it doesn't make sense in an absolute sort of way.
00:20:55 <alpounet> nisstyre: you may want to read the "theorems for free!" paper
00:21:01 <alpounet> by Wadler
00:21:01 <arkeet> (what is the category that the isomorphism is in?)
00:21:02 <nisstyre> alpounet: I was actually just doing that
00:21:10 <alpounet> oh sorry, I must have missed it
00:21:11 <nisstyre> after the previous discussion
00:21:17 <alpounet> just got here
00:21:17 <nisstyre> alpounet: I didn't mention it
00:21:23 <alpounet> alright
00:21:31 <johnw> well, I'll have to go study that again then
00:21:55 <ReinH> arkeet: so not Hask
00:22:05 <arkeet> I ask a question that has no answer.
00:22:16 <ReinH> arkeet: why not, e.g., morphisms on Hask?
00:22:26 <arkeet> because we are not discussing objects of Hask.
00:22:28 <arkeet> which are types.
00:22:36 <arkeet> the uniqueness claim is of a value.
00:22:42 <ReinH> ah
00:22:51 <johnw> ah
00:23:49 <ReinH> er.
00:24:19 <alpounet> nisstyre: by the way, @djinn is fun to play with, along the theorems for free paper
00:24:27 <johnw> @djinn a -> a
00:24:27 <lambdabot> f a = a
00:24:34 <alpounet> I see those things as related
00:24:41 <nisstyre> alpounet: yeah, I've messed around with djinn although I don't understand how it works
00:24:49 <arkeet> there's a paper for that too, I think
00:25:00 <ReinH> arkeet: How do you determine if two functions are equivalent? You could, if the domain and codomain are enumerable, enumerate each pair and check for pairwise equivalence?
00:25:00 <arkeet> unfortunately @djinn doesn't indicate when there are multiple solutions.
00:25:51 <arkeet> ReinH: I'm not sure what you mean by equivalent.
00:25:55 <arkeet> but that's probably not how *you* would do it.
00:25:56 <alpounet> re. djinn, http://lambda-the-ultimate.org/node/1178 — lennart says it uses some obscure (to me) propositional calculus
00:26:03 <arkeet> maybe your computer.
00:26:20 <alpounet> i have an intuition as to how it works, but definitely couldn't write it myself justy et
00:26:43 <arkeet> the command-line djinn will list all solutions.
00:27:40 <nisstyre> alpounet: I haven't even worked my way through all of Kleene's "Mathematical Logic", so I definitely couldn't come up with something like that
00:29:47 <ReinH> Sorry, brain fart and my battery died at the same time
00:30:21 <ReinH> arkeet: generally, f = g if they share the same domain and forall x. f x = g x, right?
00:30:43 <BoR0> for the Functor instance, is it only expected to handle fmap, or something else can be put there as well? I am trying to understand if handling fmap is what Functor is all about
00:30:50 <arkeet> that is the definition of equality of functions yes. (also they probably should have the same codomain.)
00:31:00 <arkeet> BoR0: it is.
00:31:12 <BoR0> great!
00:31:16 <arkeet> (also, any Functor instance ought to satisfy the laws too.)
00:31:21 <johnw> BoR0: and handling fmap is a law-abiding way
00:31:28 <johnw> s/is/in
00:31:30 <BoR0> what are the laws?
00:31:34 <johnw> fmap id = id
00:31:35 <arkeet> 1. fmap id = id
00:31:38 <johnw> fmap f . fmap g = fmap (f . g)
00:31:42 <arkeet> yeah that.
00:31:44 <ReinH> arkeet: so f : A -> B, g : A -> B, forall x. f(x) = g(x)
00:32:26 <arkeet> BoR0: incidentally, it's not obvious, but the second law follows from the first (and parametricity).
00:33:08 <alpounet> nisstyre: anyway, parametricity is a really powerful tool. some haskellers tend to use it to write correct code by generalizing the type as much as it makes sense, and then writing the only function that fits that type (or one of the only functions, but well, I think you see my point)
00:33:25 <ReinH> arkeet: sigh... it's hard to talk about math without being fluent in TeX or having the special symbols handy
00:33:40 <johnw> ReinH: are you an Emacs user?
00:33:40 <BoR0> out of curiousity (this is not work related, I'm just playing around with haskell), but can you show how the second law follows from the first?
00:33:49 <ReinH> johnw: no :(
00:34:20 <arkeet> BoR0: well, as I said, you need parametricity.
00:34:27 <arkeet> which is uh
00:34:29 <ReinH> arkeet: I'm visualizing a commutativity diagram where johnw's isomorphism makes some sort of sense.
00:34:31 <arkeet> see Wadler's paper "Theorems for free!"
00:34:51 <johnw> BoR0: http://thread.gmane.org/gmane.comp.lang.haskell.libraries/15382/focus=15384
00:34:54 <ReinH> but I lack the maths to know if what I'm thinking of is valid
00:34:56 * ReinH shrugs
00:34:56 <arkeet> or that.
00:34:58 <ReinH> probably not
00:35:08 <alpounet> nisstyre: whenever you have type class constraints in the type, just consider the associated laws (if any) and see what theorem(s) your function should satisfy, that'll most likely give an interesting insight and guide you through writing that function
00:35:58 <nisstyre> alpounet: yeah, that makes sense
00:36:15 <ReinH> heh
00:36:17 <nisstyre> alpounet: I use hoogle a lot with that in mind
00:36:17 <ReinH> "Given fmap id = id, the uniqueness of fmap for a given type follows trivially from the free theorem."
00:36:20 <BoR0> cool, short and elegant. thanks. so, how is that a proof that the functor instances are uniquely determined? what's this got to do with uniqueness?
00:36:20 <ReinH> fsvo trivially
00:36:34 <ReinH> I submit that many more things are trivial for Edward than for, e.g., me ;)
00:36:47 <johnw> BoR0: there are also several stackoverflow questions on that subject, btw
00:36:55 <marx2> reading the scrollback, I am still not getting why was my claim disputed so much. x <- action runs action and assigns result of the computation to x, yes?  this is true for all the monads, and I don't think anyone would dispute it.  similarly, runIdentity/unsafePerformIO/etc run the action and return the result of computation outside of the monadic context. what's wrong with that claim?
00:37:00 <nisstyre> ReinH: all theorems are trivial if they are proven
00:37:06 <ReinH> BoR0: it's a proof that any foo :: (a -> b) -> f a -> f b is the same as fmap
00:37:15 <nisstyre> http://mathworld.wolfram.com/Trivial.html
00:37:33 <ReinH> (if foo id = id holds)
00:37:54 <BoR0> ReinH, I understand. but what's that got to do with uniqueness?
00:38:15 <ReinH> BoR0: A Functor is uniquely defined by its fmap implementation
00:38:38 <ReinH> BoR0: if there can only be at most one fmap implementation then there can only be at most one Functor instance for a given type
00:38:59 <c_wraith> marx2: the issue is really that "runs the action" may not make any sense.  Like, with the state monad, it doesn't run *anything*.  Values of type State s a are just functions.  Use of (>>=), which is what that notation desugars to, is just a slightly funny function composition.  It doesn't imply actually evaluating that function.
00:39:08 <ReinH> And since any foo that satisfies the functor laws is equivalent to fmap, there can't be more than one fmap
00:39:46 <ReinH> c_wraith: I promise you that marx2 doesn't care about any of that. They're convinced that runIdentity ~ unsafePerformIO and that is that.
00:39:50 <BoR0> thanks ReinH, that helps
00:41:12 <ReinH> nisstyre: once again, Feynman is full of win :)
00:41:19 <marx2> c_wraith I am pretty sure somewhere in www.haskell.org says to think of Monads as actions, and that x <- monad runs the action and returns the result of hte computation
00:41:35 <c_wraith> marx2: don't trust everything you read on wikis.
00:41:42 <ReinH> nisstyre: although I might say "there are two kinds of proofs: trivial ones, and ones which *I* don't know how to prove" ;)
00:42:15 <alpounet> ReinH: you should add "yet" at the end of the latter :)
00:42:20 <ReinH> alpounet: right :)
00:42:32 <tdammers> marx2: 'running an action' is common jargon for this particular 'thing', but it's not entirely correct
00:42:35 <nisstyre> ReinH: yeah, that also works
00:42:40 <c_wraith> marx2: a friend of mine once edited wikipedia to claim that the St. Bernard dog breed could reach 300 lbs.  Strangely, that didn't make it true.
00:42:54 <nisstyre> ReinH: the source of that is Feynman being around mathematicians who always said "it's trivial!" when asked to prove something
00:43:03 <tdammers> in the sense that while for many monads it does in fact boil down to 'run this action', for others it doesn't
00:43:10 <ReinH> nisstyre: There is no bologne in the Feynman sandwich :)
00:43:19 <marx2> c_wraith www.haskell.org is wik?
00:43:28 <c_wraith> marx2: much of it is.
00:43:31 <ReinH> nisstyre: (from http://www.ted.com/talks/leonard_susskind_my_friend_richard_feynman.html, which is awesome)
00:43:50 <alpounet> yeah this talk is cool
00:43:57 <nisstyre> ReinH: I take Feynman's "manifesto" about being intellectually honest about science very seriously
00:44:13 <tdammers> it's a nice intuition for monads like IO or State, where you get some sort of pseudo-imperative islands on top of pure functional code
00:44:14 <ReinH> nisstyre: agree
00:44:24 <marx2> tdammenrs then what's the correct wording?
00:44:31 <tdammers> idk, really
00:44:57 <c_wraith> correct wording is "m a -> (a -> m b) -> m b" and the monad laws.
00:45:10 <tdammers> the desugaring maybe
00:45:11 <c_wraith> Everything else is an analogy that loses some connotation
00:45:14 <tdammers> indeed
00:45:47 <marx2> regardless of what you call it, given do x <- monad, runIdentity, unsafePerformIO and fromJust all return that x outside of the monadic context, yes?
00:45:53 <Iceland_jack> Jesus, is this still going on
00:46:12 <ReinH> Iceland_jack: I guess marx2 hasn't yet convinced the rest of #haskell that they're right?
00:46:13 <c_wraith> marx2: nope. And since you seem actively set against learning, I'm done.
00:46:27 <Iceland_jack> ReinH: Evidently not
00:46:39 <marx2> Iceland_jack I am trying to understand why was my claim dispute, if it was really an error in thinking, or just the fact that I got into an argument with a regular
00:46:43 <ReinH> I do hope they don't keep trying
00:46:43 <nisstyre> ReinH: it's pretty amazing how often the "if observations disagree with your theory, then your theory is wrong" criteria goes ignored by many scientists :P
00:46:45 <tdammers> marx2: x <- monad on its own doesn't really make any sense unless you actually *do* something with that x
00:46:46 <marx2> disputed*
00:46:50 <tdammers> desugar it
00:46:55 <ReinH> nisstyre: and non-scientists...
00:47:01 <tdammers> do { x <- monad; return x }
00:47:20 <tdammers> monad >>= \x -> return x
00:47:26 <tdammers> which, of course, is just
00:47:31 <tdammers> monad >>= return
00:47:41 <nisstyre> which is just monad
00:47:44 <tdammers> and since return is the identity for monads, this is equivalent to
00:47:45 <tdammers> monad
00:47:46 <tdammers> yes
00:48:00 <nisstyre> so it's a tautology
00:48:04 <tdammers> yes
00:48:18 <tdammers> I'm trying to demonstrate desugaring here
00:48:27 <ReinH> It's trivially true that either zero or one such function exists for each monad
00:48:52 <ReinH> And, for the monads for which they do (sort of) exist, they are (sort of) equivalent.
00:49:07 <ReinH> And maybe if I wave my hands fast enough, the rest of you will believe it too
00:50:08 <ReinH> Their equivalence is nothing more or less than the equivalence of their types, but that's something I guess.
00:50:57 <ReinH> nisstyre: you should watch that TED talk some time :)
00:50:59 <marx2> tdammers in the case of Identity monad x is a value Identity monad wraps. in the case of IO x is the value of the computation.  both runIdentity and unsafePerformIO return the value of x, in do { x <- monad; }, correct?
00:51:51 <nisstyre> ReinH: I've seen it
00:52:01 <nisstyre> ReinH: the Danny Hillis one is quite nice as well
00:52:01 <ReinH> I had to unignore marx2 just to see if the argument had changed at all in the last few hours. It is exactly the same, despite every attempt to inform them of its problems.
00:52:06 <ReinH> That should tell you something.
00:52:21 <marx2> ReinH for someone who supposedly ignores me you sure keep talking about me all the time
00:52:24 <ReinH> nisstyre: I'll have to check that one out
00:52:40 <ReinH> marx2: For someone who no one wants to listen to, you keep talking all the time.
00:52:51 <tdammers> marx2: no
00:53:21 <marx2> tdammers what part wasn't true?
00:54:10 <frxx> x doesn't exist outside of the Monad context
00:54:21 <tdammers> runIdentity $ do { x <- monad } is a compiler error
00:54:24 <tdammers> try it
00:55:00 <alpounet> marx2: also, runIdentity restricts you to the quite limited Identity monad
00:55:08 <tdammers> let monad = return 25 in runIdentity (do { x <- monad; })
00:55:12 <tdammers> > let monad = return 25 in runIdentity (do { x <- monad; })
00:55:13 <lambdabot>   The last statement in a 'do' block must be an expression x <- monad
00:55:16 <tdammers> see?
00:55:16 <ReinH> Current status: http://www.threadbombing.com/data/media/2/headbashwall.gif
00:55:19 <alpounet> unsafePerformIO is for the IO monad and won't (in most cases) do what you want
00:55:31 <marx2> tdammers that wasn't suppose to be a valid expression. I just wanted to point out what value of `x' I am talking about
00:55:43 <nisstyre> ReinH: guessing you've seen this? http://www.feynmanlectures.info/
00:55:52 <nisstyre> all of volumes 1 and 3 are on there
00:56:22 <ReinH> nisstyre: didn't Microsoft do a thing with them too?
00:56:30 <ReinH> nisstyre: Also I have them all in audio :D
00:56:34 <nisstyre> ReinH: the actual videos
00:56:36 <tdammers> marx2: but if it isn't a valid expression, how are we supposed to make sense of it?
00:56:39 <marx2> do { x <- identityMonad; ... } value of x is the value Identity wraps, yes?  do { x <- ioMonad.. } value of x is the value of computation of ioMonad, right?
00:56:42 <nisstyre> but they require silverlight
00:57:01 <tdammers> > let monad = return 25 in runIdentity (do { x <- monad; return x })
00:57:02 <lambdabot>   25
00:57:09 <tdammers> does that answer your question?
00:57:11 <ReinH> nisstyre: BOOKMARKED
00:57:41 <marx2> tdammers and if you replace runIdentity with unsafePerformIO, what will you get?
00:57:56 <tdammers> unsafePerformIO is a horrible horrible hack
00:58:08 <marx2> sure, that doesn't matter right now
00:58:08 <ReinH> tdammers: doesn't matter
00:58:17 <tdammers> well OK
00:58:19 <ReinH> what matters is that a -> a = a -> a
00:58:31 <tdammers> :t unsafePerformIO
00:58:31 <lambdabot> Not in scope: `unsafePerformIO'
00:58:33 <ReinH> which they are convinced is a profound statement
00:58:47 <tdammers> who's "they"?
00:59:03 <ReinH> tdammers: I'm using the gender neutral pronoun for marx2
00:59:07 <tdammers> mkay
00:59:28 <tdammers> > let monad = return 25 in fromMaybe 0 (do { x <- monad; return x })
00:59:29 <lambdabot>   25
00:59:36 <marx2> by the way, what is the proper wording of x <- monad, if not running the action of monad?
00:59:40 <ReinH> tdammers: the argument boils down the fact that a -> a = a -> a
00:59:45 <marx2> and assigning the result to x
00:59:53 <Iceland_jack> binding
01:00:00 <tdammers> indeed
01:00:10 <ReinH> tdammers: and using the fact that a -> a = a -> a, marx2 is certain that runIdentity is "equivalent to" unsafePerformIO
01:00:27 <tdammers> isomorphic /= equivalent
01:00:34 <ReinH> tdammers: their word
01:00:41 <tdammers> yes, I know
01:00:50 <ReinH> tdammers: since they've never defined "equivalent", it's difficult to state why it is not equivalent
01:00:58 <tdammers> but it's equivalent in the same sense as addition is equivalent to multiplication
01:01:03 <ReinH> tdammers: and any attempts to do so have been met by goalpost shifting of the "that's not what I mean by equivalent" variety
01:01:14 <tdammers> ah, OK
01:01:17 <ReinH> tdammers: that is, in fact, exactly what I claimed
01:01:17 <Iceland_jack> ReinH: It's a good day to be a Haskeller :)
01:01:28 <tdammers> still looks like there's a valid question in there somewhere
01:01:35 <marx2> it's equivalent in the sense that both return the value of x, given x <- monad
01:01:41 <ReinH> tdammers: what I literally said was that (+2) is equivalent to (*2) in the same way
01:01:43 <marx2> outside of the monadic context
01:01:44 <ReinH> heh
01:01:56 <tdammers> marx2: what does x <- monad do in the list monad?
01:02:07 <ReinH> tdammers: marx2 only cares about runIdentity and unsafePerformIO
01:02:08 <marx2> tdammers gets all the values of a list
01:02:22 <ReinH> marx2: no, it doesn't
01:02:33 <ReinH> a function of type [a] -> a cannot possibly "get all the values of a list"
01:02:45 <marx2> ReinH how about you shut up and let me speak my own mind, instead of talking for me?
01:03:03 <ReinH> marx2: I'm just saving the others the trouble of having to listen to your nonsense for the 50th time
01:03:56 <ReinH> (if you squint hard enough at `a <- monad` and the type of (>>=), and ignore the fact that `a <- monad` is not valid syntax, you might get [a] -> a somehow)
01:04:06 <alpounet> marx2: how about you talk nice to people?
01:04:08 <marx2> tdammers, do runIdentity and unsafePerformIO return that value of x, in x <- ioMonad/idenittyMonad
01:04:43 <ReinH> marx2: x <- foo doesn't mean anything. It's just invalid do notation.
01:04:43 <marx2> alpounet, you probably weren't around. ReinH called me a jerk, ignored me, kept talking about me, unignored me, and now he insists of making my argument for me
01:05:04 <tdammers> marx2: I already explained it to you
01:05:14 <tdammers> x <- something on its own does not mean anything
01:05:17 <ReinH> tdammers: doesn't matter. Until you agree with them they'll just keep stating the "question".
01:05:29 <tdammers> if you want to know what it means, desugar it and go from there
01:05:38 <tdammers> I'm sorry, but that's all the help I can give you
01:05:39 <ReinH> Then they'll ignore your attempts to explain why the question doesn't make sense and as it again.
01:05:42 <marx2> tdammers, it does for Identity monad. given (Identity 10), x will be 10
01:05:45 <johnw> ReinH: you're still discussing this?
01:05:47 <ReinH> marx2: no, it doesn't.
01:05:55 <ReinH> johnw: I'm trying not to but they're still here and they're still talking :/
01:06:00 <johnw> this is like a Perfect Troll
01:06:04 <ReinH> johnw: indeed
01:06:15 <ReinH> johnw: And I don't have the power to kick/ban
01:06:43 <Iceland_jack> Inhabitants of #haskell, I'm going to have to leave you again to deal with this pointless conversation alone :) take care
01:06:53 <ReinH> "a <- foo" is not a meaningful piece of haskell syntax at all.
01:07:11 <BoR0> what does the 'f' stand for in fmap?
01:07:13 <BoR0> functor map?
01:07:17 <ReinH> BoR0: functor
01:07:29 <ReinH> BoR0: just like mapM is Monad map but, you know, backwards.
01:07:39 <marx2> johnw please don't be a sheep who sides with the obnoxious regular. I am not trolling, I am trying to understand if there's really an error in my thinking, or it's just ReinH having to win his argument (and regulars backing him up)
01:07:40 <BoR0> in Haskell, why do we have "map" if we have "fmap"?
01:07:52 <johnw> BoR0: haha, great question!
01:07:57 <johnw> you can now join the Great Debate
01:07:57 <ReinH> johnw: you're a sheep and I'm obnoxious. Are we keeping track?
01:08:01 <frxx> in what way is runIdentity different than unsafePerformIO?
01:08:07 <johnw> ReinH: baaaah
01:08:08 <shachaf> BoR0: The motivation was to make error messages less confusing, or something.
01:08:35 <ReinH> marx2: you have been presented repeatedly with the errors in your thinking and it has been completely ineffective
01:08:38 <shachaf> BoR0: In the good old days they were the same. Some people wish that was still the case.
01:08:42 <ReinH> Why should we expect any differently if we try again?
01:09:01 <marx2> ReinH stop talking to me, or about me
01:09:07 <tdammers> marx2: there really is an error in your thinking
01:09:09 <BoR0> as far as I can understand from LYAH book, map is an instance of fmap but for lists. but when I try fmap and map they both act the same on lists
01:09:17 <ReinH> marx2: Not going to happen.
01:09:18 <tdammers> marx2: the error is to think in imperative terms here
01:09:27 <marx2> ReinH ignored
01:09:34 <johnw> for lists, fmap = map
01:09:36 <tdammers> marx2: stop thinking in terms of what a function "does" or "returns"
01:09:48 <tdammers> marx2: and start considering what it *evaluates* to
01:09:54 <marx2> let's turn this around then, as someone asked, in what way is runIdentity different than unsafePerformIO?
01:09:56 <nisstyre> BoR0: that's what you should expect
01:09:59 <johnw> I always forget how to ask @src to specialize an instance method
01:10:09 <tdammers> marx2: they have different types
01:10:12 <ReinH> tdammers: I appreciate your dedication
01:10:15 <jle`> is there heated drama here tonight
01:10:21 <nisstyre> BoR0: I think you meant that map is an instance of Functor for lists
01:10:26 <tdammers> ReinH: yeah, I'm *that* helpful
01:10:33 <BoR0> nisstyre, yeah
01:10:33 <nisstyre> er, that map is part of the instance of Functor for lists
01:10:35 <zol> Is it possible to write a pattern matching for the case when two arguments are equal? Like.. "scorer x x = scoreMatch" ?
01:10:38 <ReinH> BoR0: for lists, fmap = map
01:10:44 <jle`> zol: no, you need a guard
01:10:45 <alpounet> marx2: ok, I get that there is some tension here. However, ReinH happens to be right here. Really, forget about the tension, and take a look again and what people have answered (including myself). You'll hopefully understand, and if not, ask questions precisely about what you did not understand in our answers. Sounds good?
01:10:49 <ReinH> instance Functor [] where fmap = map
01:10:51 <johnw> scorer x x | x == x = scoreMatch
01:10:54 <shachaf> zol: No, not in Haskell. You'll have to use "scorer x y | x == y = scoreMatch" or something.
01:10:54 <tdammers> ReinH: but honestly, I think there's a genuine mind block there, not a stupid trolling attempt
01:10:56 <marx2> tdammers, in what way are they different that we can't say they do equivalent (or if you insist, similar) things for their respective monads?
01:11:03 <shachaf> johnw: No, that won't work.
01:11:06 <zol> jle`: shachaf: Merci!
01:11:07 <BoR0> thanks again :)
01:11:09 <ReinH> tdammers: I thought that to the first 5 or so times.
01:11:14 <johnw> shachaf: oh, right, thanks
01:11:18 <ReinH> tdammers: so I too tried dutifully to help sort it out
01:11:22 <johnw> dunno what I was thinking
01:11:25 <ReinH> tdammers: but they keep parroting back the exact same questions
01:11:35 <tdammers> marx2: they are different in that they work on different monads
01:11:42 <shachaf> I forgot what an unpleasant channel #haskell was.
01:11:43 <johnw> shachaf: welcome back to #haskell, did you leave for a while?
01:12:20 <Ralith> it's a fine place when people aren't enthusiastically feeding trolls
01:12:24 <shachaf> I was away for a bit. Probably better for all involved.
01:12:32 <johnw> tonight has been a little surreal
01:12:43 <ReinH> it blows my mind that we are still talking about this
01:12:45 <shachaf> I can't tell who's suposed to be the troll here. I just see unpleasantness.
01:12:55 <marx2> tdammers yes the work on different monads. how don't they perform similar thing for their monands?
01:12:59 <shachaf> So all y'all please try not to do that. :-)
01:13:23 <nisstyre> marx2: to sum up: "x <- monad" is simply a bit of syntax which goes in do blocks, it doesn't _mean_ anything by itself
01:13:25 <tdammers> shachaf: I'm genuinely trying to be helpful
01:14:05 <marx2> nisstyre it runs the computation (or whatever you want to call it) and assigns result to x
01:14:08 <ReinH> shachaf: So was I but I lacked the requisite patience, and no matter how far I pushed the boulder up the hill, we came back to the same exact place. Over and over and over. :/
01:14:26 <Ralith> shachaf: well, marx2 has been asking the same question and ignoring every answer for a few hours now
01:14:30 <Ralith> idk
01:14:33 <nisstyre> marx2: no, because that doesn't make sense for every valid use of it
01:14:42 <tdammers> marx2: they do 'similar' things a bit like addition and multiplication do 'similar' things
01:14:47 <nisstyre> that's really all I'm going to say on the subject again
01:15:08 <arkeet> they also have nothing to do with monads
01:15:13 <marx2> Ralith I have not ignored every answer. and I did not ask the same question for few hours
01:15:26 <ReinH> shachaf: Also, when marx2 told me to stop "whining" when I was trying to find new ways to answer their question, I rather lost my temper.
01:15:32 <nisstyre> tdammers: I assume you mean that both can be the operations for the same sort of algebraic structures
01:15:50 <alpounet> marx2: ok let me try to answer this one last time. a "monad" is not a magical black box, it's something (when considering it just in Haskell) that provides 'return' and '(>>=)', and such that the monad laws hold, for the specific definitions of 'return' and '(>>=)' for your monad instance. And from this, you can't derive a general "getOufOfMonad :: (Monad m) => m a -> a". Identity is trivial, it just holds any value you want. It's not a p
01:15:53 <marx2> ReinH that is such a misrepresentation of what happend
01:15:57 <arkeet> also most of the time we try not to think that unsafe things exist.
01:16:05 <marx2> you were not being helpful at that point, you were mocking my position
01:16:08 <ReinH> shachaf: What we have here is a classic "help vampire" http://meta.stackoverflow.com/questions/19665/the-help-vampire-problem
01:16:45 <quicksilver> ReinH, shachaf : meta-discussions about whether a discussion is helpful generally don't improve the atmosphere. Even if you are in the right.
01:16:57 <marx2> alpounet I agree, you can't derive a general "getOutOfTheMonad" function. but if two monads have getOutOfTheMonad function, how is it wrong to say that those functions are equivalent?
01:17:12 <ReinH> quicksilver: My position for some time now has been that the only way to "improve the atmosphere" is to make the trolling stop.
01:17:13 <quicksilver> marx2: unsafePerformIO isn't a function :)
01:17:21 <arkeet> quicksilver: =)
01:17:23 <quicksilver> marx2: that is one important difference.
01:17:26 <shachaf> quicksilver: That's roughly what I was trying to say. I just joined here a few minutes ago, I don't really know what's going on.
01:17:31 <johnw> also, #haskell-ops would be a better place to have such a meta discussion, if you think action needs to be taken; otherwise, better just to stop being involved
01:17:32 <shachaf> Whatever. It was worth a try.
01:17:42 <marx2> quicksilverhow isn't it a function?  unsafePerformIO :: IO a -> a
01:17:49 <quicksilver> marx2: no, it is not.
01:17:54 <alpounet> marx2: why would they be? the monads are different. what you're saying is analoguous to "hey, i have these two types who provide an 'Eq' instance. so they're the same right?"
01:17:58 <marx2> what is it then if not a function?
01:18:04 <quicksilver> if it was a function it would always return the same result for a given input.
01:18:12 <arkeet> depends on your definition of function.
01:18:19 <quicksilver> it is a hack in the language; a language extension; a hole in haskell.
01:18:30 <arkeet> it's not a function in the mathematical sense.
01:18:31 <marx2> quicksilver that doesn't negate my point
01:18:34 <quicksilver> it is not *part of* haskell in a useful way.
01:18:45 * ReinH sighs
01:18:47 <quicksilver> marx2: you were asking for differences between runIdentity and unsafePerformIO, I think.
01:18:49 <ReinH> Here we go again.
01:19:07 <marx2> alpounet but I am not saying Identity and IO monads are the same, I am saying their "getOutOfTheMonad" function is equivalent
01:19:08 <quicksilver> one important difference is that runIdentity is a perfectly well-behaved normal function
01:19:21 <alpounet> marx2: what does "equivalent" mean for you?
01:19:27 <quicksilver> whereas unsafePerformIO is not a function, not part of what we normally call haskell, and a language extension.
01:19:44 <marx2> alpounet I should have used the word similar. would you agree they are similar?
01:19:57 <arkeet> they are similar, but not in any useful way.
01:20:20 <nisstyre> :i IO
01:20:27 <quicksilver> they have analagous types, which is a striking correspondance
01:20:37 <quicksilver> but other than the types they are quite different things
01:20:55 <quicksilver> most monads have some kind of "run" function: runIdentity has the simplest type of all run functions
01:21:01 <arkeet> most?
01:21:05 <arkeet> oh.
01:21:07 <arkeet> neverm ind.
01:21:11 <quicksilver> runReader, runWriter, runState all have more complicated types
01:21:15 <quicksilver> which tell you something about the monad
01:21:17 <alpounet> marx2: the only similarity is that they have a type of the form "m a -> a" for their respective 'm'. But what other people have been trying to say is that 1/ we don't really care about this, it's not useful in any way and 2/ you are missing most of the useful content of the answers by dismissing what people say too quickly.
01:21:18 <arkeet> you're counting things not of the shape m a -> a.
01:21:19 <nisstyre> well there are an infinite amount of monads afaict
01:21:20 <quicksilver> IO has no run function at all.
01:21:28 <arkeet> safePerformIO :: IO a -> IO a
01:21:42 <ReinH> nisstyre: which infinity?
01:21:53 <ReinH> and which infinity of them are "runnable"?
01:21:54 <arkeet> there's at least one for each type. ;)
01:22:09 <mikeplus64> unsafeInterleaveIO = return . unsafePerformIO {- i think -}
01:22:27 <nisstyre> ReinH: I mean you can keep defning types that are monads indefinitely
01:22:29 <ReinH> mikeplus64: or at least something that seems to behave similarly.
01:22:42 <ReinH> nisstyre: Right. How many types are there? :)
01:23:01 <nisstyre> ReinH: good question. I don't have a good answer
01:23:15 <ReinH> and how many monads can there be per type?
01:23:26 <ReinH> I wonder if anyone has answered this.
01:23:32 <frxx> that's an interesting comment about unsafePerformIO not being a mathemetical function, and yet it is a haskell function
01:23:33 <nisstyre> I would expect it to depend on the type
01:24:11 <quicksilver> frxx: I would say it's not a haskell function. (I accept that this is a matter of defining words)
01:24:34 <quicksilver> I would say it's a language extension, and that any program using unsafePerformIO is not a haskell program.
01:24:37 <frxx> how is it not? it takes a value and returns a value
01:24:44 <frxx> ah
01:24:51 <quicksilver> because haskell is a referentially transparent language
01:25:03 <quicksilver> and functions must return the same value when called with the same input
01:25:04 <nisstyre> ReinH: I expect you could also ask the question "how many sets are there that can form groups" and "how many groups can you define for each set"
01:25:28 <frxx> ok, it is a GHC function, then
01:25:38 <frxx> but it is still a function
01:25:43 <quicksilver> it is a GHC primitive, a GHC language extension.
01:25:44 <ReinH> nisstyre: I will have to go read more papers
01:25:50 <quicksilver> frxx: I would still say no.
01:25:58 <nisstyre> ReinH: it's sort of been investigated I think, at least for finite groups
01:25:59 <nisstyre> https://en.wikipedia.org/wiki/Classification_of_finite_simple_groups
01:26:04 <arkeet> quicksilver: what is it, then? =(
01:26:05 <quicksilver> The *definition* of function is that it returns the same value for each input.
01:26:09 <nisstyre> I am definitely not an expert on this though
01:26:11 <quicksilver> arkeet: a primitive.
01:26:21 <arkeet> what do you call values whose types have the form a -> b?
01:26:21 <frxx> that's a mathematical definition
01:26:32 <quicksilver> frxx: yes. and haskell is a mathematically founded language.
01:26:39 <quicksilver> part of the point of haskell is that functions are functions.
01:26:56 <quicksilver> if functions are not functions, then we can't reason about our code and the optimiser is broken.
01:27:03 <quicksilver> thunk-update is broken and laziness is broken.
01:27:17 <quicksilver> almost everything about haskell that "matters" is broken by functions which are not functions.
01:27:28 <frxx> quicksilver what would you call unsafePerformIO if not a function?
01:27:33 <quicksilver> a primitive.
01:27:37 <quicksilver> a language extension.
01:27:38 <frxx> of what type?
01:27:57 <ReinH> Someone please let me know when marx2 and his sockpuppet, frxx, are gone.
01:28:01 <quicksilver> I'm not denying the type it has. I am denying that it should be called a function.
01:28:28 <frxx> I am his socketpuppet? :/
01:28:40 <alpounet> ReinH: you could be less aggressive, to help calm things down, although ithere is no more tension, except for your sentence :)
01:29:16 <ReinH> frxx: you are connected to from a similar geographic location to marx2's proxy server and respond to questions addressed to marx2.
01:29:25 * ReinH shrugs
01:29:40 <frxx> ReinH similar geographic location being what?
01:29:46 <alpounet> it's offtopic
01:29:56 <arkeet> yes let's stop.
01:31:08 <ReinH> It was a mistake to let myself get baited again.
01:31:54 <alpounet> has anyone seen a burst trie implementation in Haskell? i can't find any on Google, I might as well just give it a shot
01:34:23 <ReinH> alpounet: Tell edwardk that you can't write one in Haskell and he'll have one for you in a day or two.
01:37:00 <johnw> we should probably change the @faq to say "Yes, Haskell can do that!  Or if not, edwardk can write a library that does!"
01:37:00 <quicksilver> alternatively it will turn out that edwardk already has written one
01:37:13 <quicksilver> it's just not obvious because it's implicit by composing 4 of his typeclasses
01:39:59 <ReinH> quicksilver: he probably wrote 3 and forgot to push them
01:40:35 <ReinH> quicksilver: Oh that's a Representable Profunctor duh
01:40:36 <alpounet> ReinH: never said I can't :) but after reading a paper about them, I'm intrigued about how well it could be adapted to a functional setting and how it would perform. (it's for string-indexed containers)
01:40:46 <ReinH> Is that even a thing? Probably.
01:41:03 <ReinH> alpounet: I'm just suggesting a means by which you could save some time and effort ;)
01:41:39 <alpounet> nah, he's into succint these days i think
01:42:03 * hackagebot pushme 1.5.0 - Tool to synchronize multiple directories with rsync, zfs or git-annex  http://hackage.haskell.org/package/pushme-1.5.0 (JohnWiegley)
01:42:10 <ReinH> He's probably into about 30 things these days.
01:42:20 <shachaf> alpounet: I've never heard of burst trees but it sounds like they might not be obviously well-suited to being implemented persistently?
01:42:27 <shachaf> Oh, I guess you said that.
01:42:39 <ReinH> People tell me that the 10x programmer is a myth and I just point to Edward's github.
01:43:00 <alpounet> shachaf: that's precisely what i'm wondering. I'll have to try and see where I fail
01:43:05 <ReinH> shachaf: Then again, Haskell tends to be quite good at (making use of) ephemeral data structures.
01:43:16 <quicksilver> it may be that edwardk is actually the pseudonym used by an entire academic institution
01:43:19 <quicksilver> or maybe a small country
01:43:31 <ReinH> quicksilver: and the person we know as edwardk is just their frontman?
01:43:32 <ReinH> reasonable.
01:43:35 <alpounet> and they all look the same
01:43:40 <ReinH> even better
01:43:46 <ReinH> they are all clones
01:43:49 <alpounet> so he actually gives talks simultaneously in multiple user groups
01:43:54 <ReinH> He figured out cloning in 1995 but forgot to tell anyone
01:44:14 <shachaf> alpounet: Probably vaguely similar issues to splay trees.
01:44:24 <ReinH> edwardk the men, the myth, the legend
01:44:25 * sopvop starts to feat that cult of personality
01:44:31 <sopvop> fear
01:44:52 <alpounet> johnw: hey pushme looks handy
01:45:03 <johnw> i've been using it daily for a long time
01:45:47 <ReinH> johnw: pushme?
01:45:53 <alpounet> @hackage pushme
01:45:53 <lambdabot> http://hackage.haskell.org/package/pushme
01:46:03 <ReinH> oh
01:46:17 <haasn> ReinH: ugh, for a moment I thought you were saying something was *actually* a representable profunctor and got interested :(
01:46:31 <ReinH> haasn: I am so sorry
01:46:46 <haasn> it's okay, you can make it up to me by explaining to me what exactly a representable profunctor is
01:46:49 <ReinH> johnw: Any package that includes some pointless-fun is alright with me
01:47:23 <johnw> :)
01:47:54 <alpounet> shachaf: yeah I guess, and I'm not convinced it would be that efficient if implemented the ephemeral way
01:47:58 <johnw> taking advantage of the weekend to wrap up some loose ends
01:48:05 <alpounet> compared to what we already have
01:48:36 <jle`> @undo do { let a = 5; x <- f a; let b = x * 2; y <- f b; return x+y }
01:48:36 <lambdabot> <unknown>.hs: 1: 19:Parse error: <-
01:48:53 <shachaf> jle`: let { ... }
01:48:55 <jle`> i always wanted to see how let's nest/desugar
01:49:14 <nisstyre> quicksilver: I believe Oleg is also a small country
01:49:22 * quicksilver agrees
01:49:30 <jle`> @undo do { let {a = 5}; x <- f a; let {b = g x}; y <- f b; return x+y }
01:49:30 <lambdabot> let { a = 5} in f a >>= \ x -> let { b = g x} in f b >>= \ y -> return x + y
01:49:48 <jle`> that makes sense
01:52:04 * hackagebot git-all 1.5.0 - Determine which Git repositories need actions to be taken  http://hackage.haskell.org/package/git-all-1.5.0 (JohnWiegley)
01:52:06 * hackagebot gloss-juicy 0.1.2 - Load any image supported by Juicy.Pixels in your gloss application  http://hackage.haskell.org/package/gloss-juicy-0.1.2 (AlpMestanogullari)
01:52:42 <ReinH> johnw: is git-all at al like git-wtf?
01:52:48 <ReinH> *all
01:53:20 <johnw> ReinH: not quite; git-wtf is more detailed for a single repo; git-all is recursive and does either a status or a fetch in all repos within a tree
01:53:37 <johnw> it answers the question "what do I need to do for all of these projects?"
01:53:44 <trolling> @undo do { rec { x <- f x; }; return x }
01:53:45 <lambdabot> <unknown>.hs: 1: 14:NamedFieldPuns is not enabled
01:53:51 <ReinH> johnw: huh, neat
01:55:13 <ReinH> johnw: so CmdArgs?
01:55:40 <johnw> it's older code
01:55:45 <johnw> i use optparse-applicative nowadays
01:55:56 <ReinH> Seems good.
01:56:06 <shachaf> trolling: To understand recursive-do properly, you'll probably need to read Levent Erkök's PhD thesis.
01:56:11 <ReinH> johnw: Did I show you the thing I did with lenses and IO actions for GetOpts?
01:56:19 <johnw> no
01:56:22 <shachaf> Or maybe some other paper, probably by the same person.
01:57:02 <ReinH> johnw: https://gist.github.com/reinh/7880188e1b251bb51e6e
01:57:05 * hackagebot github 0.7.2 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.7.2 (JohnWiegley)
01:57:52 <johnw> ReinH: neat
01:58:03 <ReinH> probably should be foldr (=<<) or foldr (>=>) return actions $ mempty
01:58:45 <ReinH> johnw: foldr (=<<) was when "monads are a monoid" finally clicked for me :)
01:58:46 <arkeet> :t foldr (=<<)
01:58:46 <lambdabot> Monad m => m a -> [a -> m a] -> m a
01:58:56 <arkeet> I guess that works.
01:59:13 <ReinH> arkeet: it's not as good of an example as Kleisli composition but it works
01:59:22 <arkeet> :t foldr (<=<) return
01:59:23 <lambdabot> Monad m => [b -> m b] -> b -> m b
01:59:29 <shachaf> "Kleisli composition is associative" is not what people mean by "a monad is a monoid in blah blah blah"
01:59:54 <shachaf> It also happens to be true, but it's not a monoidal operation.
01:59:57 <arkeet> yes, the associativity is of something else.
02:00:03 <ReinH> shachaf: I thought join was monoidal?
02:00:04 <shachaf> ("associative and has an identity", I mean, of course.)
02:00:26 <zol> In LINQ there is a where () function that allows you to filter a list on a predicate, how would you do that in Haskell?
02:00:28 <trolling> shachaf: thanks, I was mostly just seeing if undo desugared it
02:00:34 <arkeet> zol: filter
02:00:34 <ReinH> Ok then it didn't click and I'll have to go through it again
02:00:39 <arkeet> or use a list comprehension
02:00:48 <shachaf> trolling: Ah. Yes, well, it doesn't.
02:00:51 <shachaf> Yes, join is the multiplication part of the monoid.
02:00:54 <trolling> pity
02:00:56 <trolling> pardon the noise
02:01:19 <zol> arkeet: Ok, thanks!
02:01:48 <ReinH> shachaf: so the monoid in question is <a -> m a, join, return>?
02:01:55 <shachaf> No.
02:02:09 <Skola> How may I avoid "hGetContents: invalid argument (invalid byte sequence)"?
02:02:14 <arkeet> ReinH: it's not a monoid.
02:02:22 <ReinH> arkeet: "it" meaning what?
02:02:29 <arkeet> monads are not monoids.
02:02:36 <ReinH> Er.
02:02:42 <arkeet> monads are monoid objects in a certain category.
02:03:07 <ReinH> I don't understand the distinction.
02:03:13 <ReinH> Guess I need to keep reading MacLane
02:03:26 <arkeet> "monoid" usually is restricted to monoid objects in Set. (or in our case, Hask)
02:04:32 <arkeet> but maybe you can squint your eyes at:
02:04:34 <arkeet> :t return
02:04:35 <lambdabot> Monad m => a -> m a
02:04:40 <arkeet> return: id -> m
02:04:41 <arkeet> :t join
02:04:41 <lambdabot> Monad m => m (m a) -> m a
02:04:43 <arkeet> join: m . m -> m
02:05:13 <arkeet> and there's a version of the monoid laws for this
02:05:36 <ReinH> arkeet: Right, so instead of a set S and an operation <>: S <> S -> S
02:05:48 <arkeet> and mempty: 1 -> S
02:06:18 <arkeet> and actually it's more like <> : S x S -> S
02:06:20 <ReinH> you have an endofunctor T : X -> X, the join transformation T <> T -> T, and...
02:06:24 <arkeet> T . T -> T
02:06:29 <ReinH> T . T -> T, sure
02:06:31 <arkeet> and return: id -> T
02:06:37 <ReinH> right ok
02:06:43 <arkeet> id being the identity functor.
02:07:28 <shachaf> Monads are just free monad monad monad algebras, though.
02:07:32 <arkeet> :)
02:07:43 <arkeet> well, Xs are just free X monad monad algebras, in general.
02:08:18 <shachaf> I suppose.
02:08:31 <ReinH> shachaf: I've read that one and marked it as "to be understood later" ;)
02:08:44 <shachaf> It's a shame you can't define Monoid instances in terms of mconcat, even though it's in the class.
02:09:03 <arkeet> it is?
02:09:09 <arkeet> I guess.
02:09:26 <shachaf> Well, monoids are just free monoid monad monad algebras.
02:09:30 <arkeet> yes.
02:09:40 <ReinH> So the fact that monads form a monoid with kleisli composition and return is... not the same thing.
02:09:55 <shachaf> Yes, it's losing a lot of information, for one.
02:10:02 <shachaf> It's a category, not just a monoid.
02:10:12 <ReinH> That's a monoid in the set of values of type M a for some monad M
02:10:20 <shachaf> "The Kleisli category is a category" is one version of the monad laws.
02:10:30 <arkeet> I like that version too.
02:10:59 <ReinH> right, because the monad laws can be derived from the category laws
02:11:12 <stevex> what is your opinion on using acid-state? do you prefer it over conventional databases?
02:11:13 <shachaf> Anyway, you can pick any particular one-object full subcategory of that Kleisli category, and say that it's a monoid.
02:11:17 <shachaf> But that's kind of silly.
02:11:56 <bergmark> stevex: we stopped using acid-state because it's hard to do ad hoc inspection of the data
02:12:11 <stevex> I see
02:12:38 <stevex> because there are no tools to do it? like for say sql
02:15:59 <ReinH> shachaf: I get the feeling that "monoids are just free monoid monad monad algebras" says something interesting about things like list homomorphisms that it will take me a few years to grok...
02:16:56 <shachaf> It just means that you can define class Monoid m where { mconcat :: [m] -> m }
02:17:02 <shachaf> With appropriate laws.
02:17:23 <ReinH> oh monad algebras.
02:17:25 * ReinH facepalms
02:17:35 <mr-> I can't even parse "monoids are free monoid monad monad algebras" :-/
02:17:38 <bergmark> stevex: i'm not sure if it can even be done for acid-state
02:19:17 <silver> mr-, say whaaa~
02:19:36 <mr-> M the cat of monoids, F the free Monoid functor (it is a monad?) then Alg(F) = M ?
02:19:38 <johnw> mr-: change the first "monoids" to "monads", though
02:21:02 <shachaf> mr-: Monad algebras of the free-monoid monad.
02:21:37 <mr-> shachaf: what's the free-monoid monad?
02:22:29 <arkeet> it's the list monad.
02:22:35 <shachaf> Yes.
02:22:46 <arkeet> and a monad algebra for that is:
02:22:48 <arkeet> a type X
02:22:53 <arkeet> and
02:22:57 <mr-> Oh, ok
02:23:00 <arkeet> a function [X] -> X such that
02:23:04 <mr-> Then I can parse the statement :-)
02:23:07 <arkeet> er, f :: [X] -> X
02:23:08 <arkeet> such that
02:23:12 <arkeet> yeah.
02:23:24 <shachaf> hey, keep going
02:23:24 <arkeet> f . return = id
02:23:25 <arkeet> and
02:23:34 <arkeet> f . concat = f . map f
02:23:41 <arkeet> I think.
02:23:47 <arkeet> where concat is join
02:23:50 <mr-> So the statement is Monoids = Alg([])
02:23:53 <arkeet> and map = fmap.
02:23:55 <arkeet> yes
02:24:23 <arkeet> the connection with ordinary monoids is that f is mconcat.
02:24:26 <johnw> mr-: oh, duh, I got it mixed up, sorry
02:24:40 <mr-> johnw :-)
02:24:45 <arkeet> and the laws are another statement of the monoid laws.
02:27:00 <arkeet> x <> y = mconcat [x,y]
02:27:00 <arkeet> so
02:27:06 <stevex> does acid-state keep all the data in the memory?
02:27:38 <arkeet> yeah.
02:27:40 <arkeet> and mempty = mconcat []
02:27:52 <arkeet> exercise: derive the regular monoid laws from the ones for mconcat.
02:30:40 <shachaf> Exercise: Go to sleep.
02:30:49 <ReinH> shachaf: but I'm so close...
02:30:50 <shachaf> I'll try it now.
02:31:43 <tdammers> nisstyre: I meant that they are formally isomorphic, at least as long as you pretend that unsafePerformIO is a function (which it is not)
02:32:21 <arkeet> shachaf: =(
02:32:23 <ReinH> So... an F-algebra for some endofunctor F : C -> C is an x in C and an arrow F x -> x of C
02:32:28 <arkeet> yes.
02:32:35 <arkeet> but an algebra for a monad is a bit more than that.
02:32:37 <shachaf> But we want T-algebras, not just F-algebras.
02:32:40 <ReinH> So... a monad algebra is an object x in C and an arrow M x -> x of C for some monad M on some category C, plus the monad laws?
02:32:48 <arkeet> not the monad laws.
02:32:54 <arkeet> but some other laws that related it to the monad structure of M.
02:33:01 <ReinH> T-algebras, which could be called M-algebras but were not.
02:33:10 <arkeet> let's talk about regular monoids.
02:33:13 <ReinH> ok
02:33:17 <arkeet> say M is a monoid.
02:33:26 <shachaf> Let's talk about chu spaces!
02:33:26 <ReinH> M is a monoid.
02:33:28 <shachaf> Let's go to sleep.
02:33:39 <arkeet> which means
02:33:42 * shachaf does.
02:33:47 <ReinH> shachaf: night night
02:33:48 <arkeet> you have a unit 1 -> M and a binary M x M -> M
02:34:06 <arkeet> and you have some laws
02:34:21 <arkeet> like associativity says that the two ways of getting from M x M x M to M are the same.
02:34:41 <ReinH> right, I saw a few diagrams with some boxes and arrows ;)
02:34:53 <arkeet> ok, the analogue of a monad algebra here is a M-set.
02:35:00 <arkeet> which is a set X with an operation M x X -> X
02:35:19 <arkeet> the laws for such a thing just say that
02:35:25 <arkeet> the unit of the monoid acts like the identity on X.
02:35:27 <arkeet> under this operation.
02:35:36 <arkeet> and also that the two ways of getting from M x M x X to X are the same.
02:35:54 <ReinH> so 1 x X -> X?
02:36:12 <arkeet> ??
02:36:24 <ReinH> er
02:36:25 <arkeet> ok.
02:36:27 <arkeet> in symbols.
02:36:40 <arkeet> let's make up a symbol for the M x X -> X thing.
02:36:49 <arkeet> let's call it *
02:36:54 <ReinH> ok
02:36:57 <arkeet> and use mempty and <> for the monoid.
02:37:02 <arkeet> so:>
02:37:05 <arkeet> the monoid laws are
02:37:18 <arkeet> mempty <> m = m, m <> mempty = m, and m <> (n <> p) = (m <> n) <> p
02:37:25 <ReinH> right
02:37:38 <arkeet> ok, well the laws for an M-set X, with * : M x X -> X
02:37:39 <arkeet> are
02:37:46 <arkeet> mempty * x = x
02:37:50 <arkeet> (m <> n) * x = m * (n * x)
02:38:15 <ReinH> right
02:38:31 <arkeet> you can write these laws as commutative diagrams.
02:38:56 <arkeet> and you can make sense of those diagrams in the context of monad algebras.
02:39:00 <arkeet> and you get the laws.
02:39:07 <arkeet> for a monad algebra.
02:39:32 <arkeet> ok, in haskelly stuff again:
02:39:37 <arkeet> say M is a monad.
02:40:13 <ReinH> ok. M is a monad.
02:40:14 <arkeet> a M-algebra is just a function act: M X -> X, for some X
02:40:16 <arkeet> such that
02:40:28 <arkeet> act . return = id
02:40:32 <arkeet> act . join = act . fmap act
02:41:01 <arkeet> exercise: show that any haskell monoid is a []-algebra, with act = mconcat
02:41:09 <ReinH> one sec
02:41:18 <arkeet> no secs, I'm going to bed =(
02:41:23 <ReinH> heh ok :)
02:41:28 <arkeet> cu
02:41:32 <ReinH> ttfn and thanks
02:48:13 <ReinH> Oh. Yeah. join M (M x) = M x and act M x = x; fmap act M (M x) = M x and act M x = x
02:50:52 <ReinH> :t mconcat . concat
02:50:52 <lambdabot> Monoid c => [[c]] -> c
03:08:45 <rdevilla> How would one approach drawing sierpinski triangles in ASCII in Haskell?
03:09:48 <ReinH> rdevilla: there are lots of ways to draw sierpinski triangles. One way is with cellular automata.
03:10:08 <ReinH> rdevilla: Any method that subdivides triangles probably won't work very well with ASCII
03:10:58 <alpounet> rdevilla: you can still check out a version using the 'diagrams' package: http://projects.haskell.org/diagrams/gallery/Sierpinski.html
03:12:03 <rdevilla> O.O
03:12:37 <ReinH> alpounet: which, while awesome, probably doesn't translate well to the requirements of ASCII :)
03:12:51 <nomeata> ReinH: render to png and pass through aalib
03:13:03 <ReinH> aliasing :p
03:13:13 <rdevilla> this looks like complete black magic to me
03:13:25 <ReinH> rdevilla: a Rule 90 Wolfram automata will produce a Sierpinski Triangle http://en.wikipedia.org/wiki/Rule_90
03:14:16 <rdevilla> ReinH: I was actually just reading about comonadic cellular automata on sigfpe
03:14:23 <rdevilla> a lot of it went over my head
03:15:14 <ReinH> rdevilla: try this version https://www.fpcomplete.com/user/edwardk/cellular-automata/part-1
03:35:56 <iross> scr
03:37:04 <iross> Anyone been having trouble with Haskell builds on Travis in the last couple of days?
03:38:19 <iross> The Travis VM for Haskell seems to have GHC 7.6.3 with no hsc2hs.
03:40:34 <ReinH> rdevilla: ping
03:41:17 <ReinH> rdevilla: here's a version without any (explicit) comonads, using Data.Vector for fast indexing https://gist.github.com/reinh/7748240
03:42:10 <cariveri> hi. does anyone know a tutorial for pretty printing recursive structures?
03:42:25 <MorphinTime> Cale, I must say your spineless tagless architecture is most interesting.
03:42:39 <ReinH> MorphinTime: which is that? sounds interesting.
03:43:00 <Cale> ReinH: http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
03:43:07 <MorphinTime> I shall use this knowledge only for good, never for evil, I swear
03:44:47 <ReinH> MorphinTime: mathematics is indifferent to your ethics :p
03:45:39 <Cale> Maybe he really means it in the categorical sense ;)
03:46:22 <Cale> http://ncatlab.org/nlab/show/evil
03:48:06 <MorphinTime> Cale, something tells me you have /exec -o useful-pdfs 34 or something simila ready for that occassion
03:48:06 <Cale> http://cheng.staff.shef.ac.uk/morality/morality.pdf :D
03:48:06 <MorphinTime> That was quite fast
03:48:48 <ReinH> You win, per usual
03:48:52 <MorphinTime> ReinH, nahh, it's just something I am fond of saying when I link PDF's to people 'promise to use ths knowledge only for good, nevr for evil'
03:50:59 <MorphinTime> I'm Jack and Arnie, I always win
03:51:23 <Cale> MorphinTime: Actually, I tend to just use google. I know that paper's filename is peytonjones92implementing, so I just type that into Google and give the first link I find.
03:52:11 <ReinH> heh
03:52:53 <ReinH> And because being able to run Haskell in your browser is pretty neat, https://www.fpcomplete.com/user/ReinH/wolfram-automata
03:53:52 <MorphinTime> Cale, at least have /exec -o firstgoogleuri peytonjones92
03:53:52 <MorphinTime> I believe in you
03:53:52 <MorphinTime> You can do it, be hardcore
03:53:52 <MorphinTime> Chicks dig command line
03:54:27 <ReinH> Cale: yes Cale, do it for the ladies.
03:55:21 <MorphinTime> For sake of diversity I am assuming by the way that Cale is a lesbian rather than a heterosexual male.
03:55:49 <Cale> I'm actually incorporeal
03:56:01 <ReinH> MorphinTime: pansexual
03:56:02 <MorphinTime> I always randomie my random assumptions about people's sex
03:56:14 <ReinH> MorphinTime: FOR DIVERSITY
03:56:44 <MorphinTime> ReinH, I assume that next time.
03:56:45 <MorphinTime> Truth be told, I find that I subconsciously assume people are omnisexual on some level all the time.
03:56:45 <ReinH> The only thing that ladies love more than the command line is... other ladies. Well, at least some of them.
03:57:31 <MorphinTime> I think Cale is just some advanced software running on the last lisp machine at MIT
03:58:03 <yogurt_truck> I just assume people don't want me to assume anything
03:58:13 <MorphinTime> Well, I believe thee was some arguably result tht more or less concludeed that heterosexual women are attracted to men but heterosexual men are repulsed by men more so than attracted to women.
03:59:37 <MorphinTime> They don't, but let's face it, for the most part people seem to assume that there is a male behind each nickname on IRC
04:00:35 <ReinH> MorphinTime: I prefer to believe that it is a Haskell machine.
04:00:37 <mr-> > 5
04:00:37 <lambdabot>   5
04:00:39 <mr-> > it
04:00:39 <lambdabot>   Not in scope: `it'
04:00:40 <lambdabot>  Perhaps you meant one of these:
04:00:40 <lambdabot>    `id' (imported from ...
04:00:43 <mr-> aww
04:08:16 <MorphinTime> ReinH, static typing is not the best to write an AI in really.
04:09:03 <MorphinTime> Or do natural language processing in I find.
04:09:03 <MorphinTime> The flexibility of the heterogenous sequence in list works well for parse and syntax trees in general
04:09:45 <MorphinTime> in lisp*
04:10:43 <tdammers> I guess you have to make a choice: implement a bug-ridden ad-hoc implementation of common lisp, or implement a bug-ridden ad-hoc implementation of half a type system
04:11:10 <tdammers> worst case, you do both
04:11:20 <tdammers> and strangely enough, that's what you end up with in most programming languages
04:12:21 <yogurt_truck> _or_, you can do it with good static typing, and create a type for your heterogenous sequences if you really want them
04:12:38 <MorphinTime> Please, scheme is for the cool kids
04:12:38 <MorphinTime> the only thing is that scheme doesn't have constant time user defined types.
04:13:24 <yogurt_truck> btw, "flexibility" as a criteria/argument/etc always rings an alarm in my mind.
04:14:02 <MorphinTime> Well, Idris allows doing this as functional as in lisp I believe
04:14:14 <tdammers> yogurt_truck: that's the "implement half of common lisp" solution
04:14:26 <tdammers> and it's the one I prefer most of the time, really
04:14:42 <tdammers> because it's easier to retrofit dynamic types onto a static type system than the other way around
04:14:49 <MorphinTime> You can do something like reate a list of [(a, b : a)] in Idris
04:14:49 <MorphinTime> As in a list of pairs where fst is a type and snd is an element of that type, you just made dynamic typing
04:15:31 <MorphinTime> yogurt_truck, because natural language parsing and repraesentation sort of needs it
04:15:31 <MorphinTime> Ntural languges are complicated
04:15:37 <tdammers> sure
04:15:59 <tdammers> but that doesn't mean you can't define your dynamic data structures in terms of a static type system
04:16:13 <MorphinTime> It's hard to create a static type EnglishSEntenceStructure and if you do it you basically already throw away the benefits of static typing because it's going to be code that relies on exeptions to be save rater than stati  stuff
04:16:29 <yogurt_truck> javascript is "flexible" in that everything will implicitly convert from `null` to `Object` to `undefined` to equality to cats to `dogs that walk like ducks` to NaN, often without you even knowing about it :D. yay flexibility!
04:16:55 <tdammers> MorphinTime: then don't create a static type EnglishSentenceStructure, but a more generic one instead
04:16:56 <yogurt_truck> MorphinTime: you can make perfectly typesafe List(Int,String,Banana) in Scala already
04:17:17 <yogurt_truck> not that you will actually _need_ to most of the time
04:17:42 <MorphinTime> You can, but that's not the issue here, the amount of different types that the list must contain is infinite and recursive
04:17:52 <yogurt_truck> (almost every time I've used an HList, months later I realize it wasn't actually necessary)
04:18:24 <MorphinTime> You can implement it, but at that point you are relying on exceptions already to catch errors and you arrived at dynamic typing, just with a whole lot of hasstle so why not use a language that gives you dynamic typing by default?
04:18:28 <donri> MorphinTime: what about it is hard?
04:18:37 <yogurt_truck> MorphinTime: why am I relying on exceptions?
04:18:56 <donri> btw we have type safe dynamic types and static duck typing in haskell, no problems there
04:19:03 <yogurt_truck> MorphinTime: I don't use exceptions in Scala, like, ever. Certainly not when I use hlists
04:19:31 <yogurt_truck> (unless some silly stdlib API or inherited java crap uses exceptions, that is -_-)
04:19:48 <MorphinTime> Dynamic vs static typing is a matter of degrees anyway, haskell already uses some limited amount of dynamic typing such as catching things like factorial -4 with an exeption, that's dynamic typing in principle
04:19:48 <MorphinTime> It's also in principle possible to catch it statically but that's "a hassle"
04:20:06 <tiffany> what do you need dynamic typing for that wouldn't be better served by a typeclass object or an ADT?
04:21:17 <MorphinTime> typeclasses _are_ dynamic typing?
04:21:48 <yogurt_truck> O.o
04:21:54 <yogurt_truck> then I'm not sure what we're talking about here xD
04:22:05 <donri> i wouldn't call either of type classes and sigma types "dynamic"
04:22:06 <yogurt_truck> food time, though. bbl
04:23:27 <MorphinTime> yogurt_truck, typeclasses investigate some amount of type information at runtime to investigate which type, tis is necessary if you use them for your heterogenous list
04:23:28 <MorphinTime> investigate which overloading to use*
04:23:28 <MorphinTime> Your heterogenous type classed list will use recursion most likely.
04:25:34 <MorphinTime> Consider the function f x = show x ++ f ("foo", x); f :: Show a => a -> String
04:25:34 <MorphinTime> The type of ("foo", x) cannot be statically determined at this point because it's recursive
04:26:20 <MorphinTime> If we call f 1 it may be (String, Int), (String, (String, Int)) etc ad infinitum, but Show can handle them all
04:28:50 <donri> no the type is static, it is Show a => (String,a)
04:28:59 <yogurt_truck> MorphinTime: there is no runtime whatsoever to investigate which typeclass instance to use
04:29:06 <yogurt_truck> runtime business*
04:30:37 <MorphinTime> yogurt_truck, there is
04:30:38 <MorphinTime> THis is one of the cannonical reasons why statically choosing the instance is impossible.
04:30:38 <MorphinTime> In a lot of cases static dispatch is possible but it is not a general solution
04:30:51 <yogurt_truck> MorphinTime: The rules of selection are specified by the language and executed at compile-time. Candidates are evaluated according to scoping rules and other type-related rules which will make the compiler croak when there are clashes, etc.
04:31:19 <MorphinTime> And in practice GHC also does it at runtime in a lot of cases to avoid code bloat they told me
04:31:57 <yogurt_truck> MorphinTime: how is statically choosing the instance impossible? the compiler _tells_ me when I'm using the wrong instance, at compile time
04:32:39 <yogurt_truck> it also tells me whenever two instances have the same priority and that I should fix that before attempting to compile the codebase
04:32:48 <MorphinTime> yogurt_truck, see the above recursive example, which may also depend on use input by the way
04:33:30 <MorphinTime> The compiler cannot staticlaly know which isntance to use for f x, it may be (String, Int), it may be (String, (String, Int)), it may be (String, (String, (String, Int)))
04:33:31 <MorphinTime> yogurt_truck, the function I just give doesn't get inferred, you have to give it a signature but then it will compile
04:33:49 <donri> @where dmr
04:33:49 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
04:34:00 <tiffany> morphintime: whether static or dynamic dispatch is used is an implementation detail, and does not effect language semantics
04:34:10 <tiffany> do not use this as some sort of proof that haskell is secretly using dynamic typing when it is not
04:34:12 <MorphinTime> A more complex example with an if depending on user input is entirely possible
04:34:59 <yogurt_truck> MorphinTime: what does recursion have to do with dynamic typing?
04:34:59 <MorphinTime> tiffany, static dispatch is generally impossible
04:34:59 <MorphinTime> THe example I gave annot be solved with static dispatch
04:35:05 <donri> no it's not, you'd have to say up front which types you can handle and dispatch to one of those
04:35:09 <tiffany> static dispatch is not generally impossible
04:35:40 <yogurt_truck> MorphinTime: I use recursive types in my typeclasses all the time and get plenty of compile-time checks/messages/etc from the compiler.
04:35:41 <MorphinTime> A lot of cases can of course but recursive typeclases, which is what you need to create that parse tree list, do not allow it
04:35:41 <MorphinTime> yogurt_truck, because recursion in this case gives you infinitely many instances?
04:35:41 <MorphinTime> You can't statically dispatch them all of course
04:36:05 <tiffany> you can
04:36:19 <donri> what are you talking about o_O
04:36:23 <MorphinTime> yogurt_truck, like I said, the function I defined above will not compile without an explicit signature, it cna't infer it, but if you give it it will compile
04:36:23 <MorphinTime> It's also bad style but entirely allowed
04:36:23 <MorphinTime> (And slow)
04:36:27 <yogurt_truck> MorphinTime: why does the amount of instances matter?
04:36:37 <donri> the type is polymorphic to Show a => a
04:36:48 <donri> the a gets specialized at the call site
04:36:55 <donri> the type is static at the call site
04:37:24 <donri> MorphinTime: that's just the monomorphism restriction, trivially lifted
04:37:26 <yogurt_truck> MorphinTime: dynamic typing doesn't follow from type inference weaknesses
04:38:12 <yogurt_truck> if something can't compile without a explicit signature because Damas-Milner can't handle it, it doesn't mean the language is using dynamic typing
04:38:29 <yogurt_truck> (or whatever the type inference algorithm is)
04:39:19 <tdammers> indeed... you still reap the full benefits of static type checks
04:39:24 <tdammers> you just get some false negatives
04:39:28 <donri> oh you're talking about the occurs check
04:39:58 <MorphinTime> yogurt_truck: http://hastebin.com/simodoyeka.hs
04:39:59 <MorphinTime> yogurt_truck, it doesn't, dynamic typing follows form the fact that the type of the variable 'x' in this case cannot be determined at runtime
04:39:59 <MorphinTime> It depends on user input
04:39:59 <MorphinTime> It can prove at runtime that it is a member of the class Show, but that's it
04:39:59 <donri> we say infinite type not simply recursive type because recursive types are perfectly possible
04:40:45 <MorphinTime> donri, well, it may or may not be infinite depending on user input
04:40:45 <MorphinTime> the correct term is peraps 'unbounded'
04:40:45 <MorphinTime> The recursion depth is bounded here by the user input
04:41:27 <MorphinTime> But this is basically the canonical reason why stati dispatch is not generally decidable in Haskell
04:42:23 * hackagebot aws-sign4 1.1.0.0 - Amazon Web Services (AWS) Signature v4 HTTP request signer  http://hackage.haskell.org/package/aws-sign4-1.1.0.0 (ChrisDornan)
04:50:40 <donri> MorphinTime: dynamic typing can also be called unityping; you're packing every possible type into a single sum type. the type doesn't really depend on user input because there is only one type
04:50:55 <bz> ehm
04:50:55 <donri> you can do this with existentials and typeable in haskell
04:51:39 <bz> any tips on using buildExpressionParser to correctly parse function calls a la "A(b, c)"?
04:55:51 <Hodapp> typeable?
04:55:52 <MorphinTime> donri, I know
04:55:52 <MorphinTime> As many people, I think the term 'type' for a dynami type is silly
04:56:34 <MorphinTime> It's no more a type than calling the first chracter of a string its 'type'
04:57:16 <MorphinTime> I mean, in theory the function tail is not only dynamically typed, it's impure, it produces a side effect based on its input.
05:03:33 <Hodapp> MorphinTime: what do you mean a side effect based on its input?
05:06:07 <Taneb> I wonder what an architecture designed specifically to compile Haskell to would look like
05:06:55 <tdammers> you mean the haskell equivalent of a lisp machine?
05:07:23 <MorphinTime> Hodapp, head [] has the side effect of printing something to the error port and halting execution or something like that
05:07:23 <MorphinTime> An exception ultimately is a side effect
05:08:03 <tdammers> anyway, the monotype / unitype argument pretty much leads to the conclusion that *any* "dynamic type" can be implemented on top of a static type system, really
05:08:20 <Taneb> tdammers: something like that
05:08:32 <tdammers> heh
05:08:46 <tdammers> I guess we'd have a dedicated haskell parser chip
05:09:00 <tdammers> and then a pattern-matching circuit
05:09:07 <tdammers> idk
05:09:34 <MorphinTime> tdammers, well, it can of course, but is the type system still save then?
05:10:00 <Cale> MorphinTime: The way we tend to handle things like head [] is by saying that anything whose evaluation doesn't terminate normally has the value _|_ -- so the semantics treats the exception as being the same as an infinite loop.
05:10:04 <tdammers> MorphinTime: the type system is just the type system, but your type is probably more generic that you'd need it to be
05:11:44 <MorphinTime> Cale, I know, but obviously that's not what the implementation does. It halts and has a side effect, if you have head [] and tail [] at two places in the code the program's behaviour obviously depends on whatever random evaluation order was chosen, whichever gets evaluated first gets to report failure
05:12:42 <Cale> Right, if you want to know which exception you're going to see, you need to know more than the language definition gives you
05:14:33 <MorphinTime> True, I shall rephrase, 'head' in haskell is not impure, head in any implementation thereof that I know from a strictly theoretical standpoint is an impure function which may or may not perform a side effect based on the structure of its argument
05:15:19 <stevex> why doesnt this work?
05:15:31 <stevex> (moment)
05:15:50 <kartoffelbrei> Taneb: I guess it would have some support for graph reduction stuff. Kinda like STG (or parts of it) in hardware.
05:23:58 <stevex> why doesnt this work? http://lpaste.net/96474
05:27:14 <kartoffelbrei> stevex: because of indentation, it works if you put the finally and the 'print foo' on the same line in that do block (which is not needed then)
05:27:27 * hackagebot nonlinear-optimization-ad 0.1.0 - Wrapper of nonlinear-optimization package for using with AD package  http://hackage.haskell.org/package/nonlinear-optimization-ad-0.1.0 (MasahiroSakai)
05:27:29 * hackagebot hsyslog 1.6 - FFI interface to syslog(3) from POSIX.1-2001  http://hackage.haskell.org/package/hsyslog-1.6 (PeterSimons)
05:28:51 <stevex> kartoffelbrei: wont it just refer to the error line in that case, instead of entire do block above it?
05:29:14 <quchen> "impure" is always used with so many different interpretations in these discussions.
05:30:16 <donri> yeah, it's not a pure word
05:30:25 <quchen> I guess it always boils down to "is main pure?". If you don't give it to the runtime it is, and so is 'head []'.
05:31:06 <kwos> where's the best place to get some help with snap? I'm having hard time figuring out attr splices
05:31:14 <donri> stevex: yes, you'd need to use bracket or something to include the resource in the finalization
05:31:23 <donri> #snapframework
05:31:38 <donri> although this channel is fine too :)
05:31:53 <haasn> ‘main’ is pure in that main `seq () is equivalent to ()
05:31:57 <stevex> no acually it still refers to the entire do block. odd..
05:32:02 <haasn> main `seq` ()
05:32:30 <BoR0> @src seq
05:32:31 <lambdabot> Source not found. There are some things that I just don't know.
05:32:31 <donri> > let main = undefined in main `seq` ()
05:32:32 <lambdabot>   *Exception: Prelude.undefined
05:33:02 <haasn> donri: still equivalent, I think. You can't observe the difference in pure code
05:33:10 <donri> stevex: foo will be in scope but the finally applies to the error, not the return
05:34:11 <donri> haasn: in any case it's not made any less pure by having IO in its type
05:35:17 <stevex> donri it applies to entire do block (there is only error there in my code, but if you add more lines finally will affect those as well)
05:35:19 <Hodapp> O
05:35:32 <Hodapp> I'm glad no one referred to that existentialtype article about dynamic typing.
05:36:23 <donri> stevex: you're not recovering from the first error so the following is never run
05:38:13 <kwos> donri: thanks!
05:38:22 <kwos> donri: I've tried (foolishly) snap-framework LOL
05:38:33 <stevex> donri not sure why is that relevant. maybe I am not understanding you (or vice versa)
05:38:34 <donri> :)
05:38:56 <Aetherspawn> hey guys, consider the following code: https://gist.github.com/kvanberendonck/7749460
05:39:07 <Aetherspawn> is there a way to make the do-part more succinct
05:39:20 <Aetherspawn> like a liftFoldSndM or something >.>
05:40:45 <donri> what's wrong with what you have
05:41:00 <Aetherspawn> there are heaps of constructors, it's gonna span lots of code
05:41:04 <Aetherspawn> and it'll mostly look like boiler
05:41:27 <Aetherspawn> plus, I have to come up with lame names and lots of '
05:41:29 <Aetherspawn> :P
05:42:53 <magicman> Looks like a StateT of some sort.
05:44:05 <Aetherspawn> hmm, I'm already running a writer. lftd is a Map
05:44:12 <Aetherspawn> I could maybe run a second writer..
05:47:48 <donri> Aetherspawn: oh yeah it looks like StateT. is this pattern consistent?
05:48:28 <Aetherspawn> it's pretty consistent but not entirely.
05:48:38 <BoR0> > (Just 3) <*> (+3)
05:48:39 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a0'
05:48:39 <lambdabot>              with actual...
05:48:39 <magicman> It also looks like a stub of a Traversable instance.
05:49:03 <Aetherspawn> tbh I've actually thought about alternatives now and adding another transformer on top doesn't seem that appealing so I might just leave it like it is, but thanks :/
05:51:13 <cariveri> hi. how do print a tree like structure with indents ?
05:52:29 <Aetherspawn> cariveri: what does your data type look like?
05:52:33 <donri> @hoogle drawTree
05:52:33 <lambdabot> Data.Tree drawTree :: Tree String -> String
05:53:56 <quchen> > Just (+1) <*> Just 3 -- BoR0
05:53:56 <lambdabot>   Just 4
05:54:17 <cariveri> Aetherspawn: like A = A Node [A]
05:55:05 <quchen> cariveri: Have a look at the source of what donri hoogled.
05:55:06 <cariveri> Aetherspawn: and those Children [A] should be indented
05:55:25 <Aetherspawn> ppr :: A -> Int -> String
05:56:03 <Aetherspawn> :t intersperse
05:56:03 <lambdabot> a -> [a] -> [a]
05:56:18 <Aetherspawn> > "," ["dogs", "cats"]
05:56:19 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]] -> t0'
05:56:19 <lambdabot>              with a...
05:56:33 <donri> cariveri: try a pretty printing library like pretty or wl-pprint-text
05:56:36 <Aetherspawn> > ',' ["dogs", "cats"]
05:56:36 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]] -> t0'
05:56:37 <lambdabot>              with a...
05:57:09 <Aetherspawn> oh derp, forgot the function name.
05:57:12 <Aetherspawn> Its too late...
05:57:37 <jellybee> Hey, is there a known technique to convert a parse tree to abstract syntax tree?
05:57:47 <MorphinTime> > intersperse "," ["dogs", "cats"]
05:57:47 <MorphinTime> Oh wait, a, [a]
05:57:47 <MorphinTime> > intersperse 'a' ["dogs", "cats"]
05:57:48 <lambdabot>   ["dogs",",","cats"]
05:57:48 <lambdabot>   can't find file: L.hs
05:59:23 <Aetherspawn> ppr (A current children) n = current ++ "\n" ++ (concat . intersperse "\n" $ map (\x -> replicate ' ' n ++ ppr x (n+1)) children)
05:59:34 <Aetherspawn> cariveri: ^ thats a nasty implementation of how I might hack one together
05:59:58 <Aetherspawn> the idea is you start with n = 0 for 0 indentation and increase it each time you pretty print down the children
06:00:20 <Aetherspawn> replicate adds padding and intersperse adds linebreaks.
06:00:32 <Aetherspawn> current is assumed to be a string, so you might want to throw show infront it there
06:00:48 <Kinnison> jellybee: Depending on how you parse, I tend to parse directly into an AST of some kind.
06:01:53 <jellybee> Kinnison: I use theEarley algorithm, I cant create the AST while parsing... do you know a way of converting?
06:03:10 <quicksilver> Aetherspawn: unlines (current : map (\x -> replicate ' ' n ++ ppr x (n+1)) children)
06:03:17 <Kinnison> jellybee: What sort of output do you get from your parser?
06:03:20 <quicksilver> Aetherspawn: might be slightly easier to read than all those \n
06:03:40 <Aetherspawn> good catch quicksilver
06:03:43 <jellybee> Kinnison: can I PM you?
06:04:07 <Kinnison> jellybee: Yes.  But  be warned, I'm in and out of meetings today so I'm likely to be slow responding
06:06:12 <Aetherspawn> although thinking about it
06:07:05 <Aetherspawn> hmm, I'm kind of sus.
06:07:21 <Aetherspawn> about it, I reckon it'd produce a wierd diagonal spacing ppr
06:08:51 <Skola> is there a right way to apply multiple filters (in any order) to a list?
06:10:23 <tomejaguar> Skola: What do you mean exactly?
06:10:51 <allsystemsarego> Skola, by composing the filters maybe?
06:11:21 <Aetherspawn> yeah, heh, my intuition on the tree ppr doesn't work. The guy who asked the question disappeared though
06:11:43 <Skola> yes but I'll have a [a -> Bool]
06:11:49 <Skola> foldl (.)?
06:12:01 <tomejaguar> :t sequence [(>0), (<5)]
06:12:01 <lambdabot> (Num a, Ord a) => a -> [Bool]
06:12:11 <Skola> a yes, this :}}
06:12:22 <tomejaguar> sequence is surprisingly useful :)
06:12:30 <xcthulhu> > foldl (flip filter) [1,2,3,4,5,6,7,8] [\x -> x `mod` 2 == 0, \x -> x `mod` 3 == 0]
06:12:31 <lambdabot>   [6]
06:12:39 <tomejaguar> :t and . sequence [(>0), (<5)]
06:12:40 <lambdabot> (Num a, Ord a) => a -> Bool
06:12:46 <tomejaguar> :t or . sequence [(>0), (<5)]
06:12:46 <lambdabot> (Num a, Ord a) => a -> Bool
06:13:44 <xcthulhu> +1 for the sequence solution
06:16:19 <Aetherspawn> You can also use list comprehensions
06:17:13 <Aetherspawn> > let {x = [1..10]; f1 = odd; f2 = (>5); } in [z | z <- x, f1 z, f2 z]
06:17:14 <lambdabot>   [7,9]
06:17:21 <freezway> so im trying to get started with haskell and want to install a package from hackage. However, when I run cabal update it tells me i need to update cabal-install and to run cabal install cabal-install. So I do that and it completes without errors. But when I try to run cabal update afterwards it gives me the same error.
06:17:38 <Skola> thanks tomejaguar, Aetherspawn
06:18:00 <tomejaguar> Skola: You're welcome.
06:18:09 <Aetherspawn> freezway: make you're mistaken that it's asking you to run `cabal update`
06:18:18 <Aetherspawn> which actually just downloads package lists and doesn't actually update cabal
06:18:22 <Aetherspawn> *maybe
06:19:01 <freezway> Aetherspawn, when I run cabal update I get http://lpaste.net/96475
06:19:02 <Aetherspawn> cabal --version
06:19:20 <Aetherspawn> also, which operating system?
06:19:24 <freezway> using version 1.16.0 of the Cabal library
06:19:27 <freezway> both arch and fedora
06:19:44 <Aetherspawn> try ~/.cabal/bin cabal update
06:19:56 <Aetherspawn> err ~/.cabal/bin/cabal sorry
06:20:24 <Aetherspawn> the thing is, you may not have the cabal bin on your path before the system bin
06:20:25 <freezway> trying
06:20:32 <Aetherspawn> presumably you have a cabal in /usr/bin or something, yes?
06:20:42 <freezway> yes
06:20:44 <Aetherspawn> well, cabal can't write to that one
06:20:51 <Aetherspawn> so it drops a new one in ~/.cabal/bin
06:20:57 <freezway> ah
06:21:05 <Aetherspawn> all the cabal installed binaries go there, so you should probably pop that one on path
06:21:12 <freezway> ok cool
06:21:15 <freezway> thanks
06:21:31 <Aetherspawn> np
06:21:32 <kartofelbrei> freezway: what i usually do is putting .cabal/bin at the end of my $PATH and do a cabal install cabal-install (which is the cabal-1.16.0). then afterwards cabal refer es to cabal-1.18 in you ./cabal/bin
06:22:22 <cariveri> Aetherspawn: where did get ppr from in this case?
06:22:36 * hackagebot parallel-tasks 4.0.0.0 -   http://hackage.haskell.org/package/parallel-tasks-4.0.0.0 (NeilBrown)
06:22:46 <Aetherspawn> just a top level function we defined
06:23:01 <Aetherspawn> however, it's wrong. I tested it in GHCI, and it gave the wrong output :/
06:25:26 <freezway> kartofelbrei, wait what? if you put .cabal/bin at the end of your path wouldn't cabal refer to /usr/bin first?
06:26:10 <Aetherspawn> on windows+mingw I have to put it at the beginning
06:26:15 <Aetherspawn> unsure about real linux.
06:26:32 <Hodapp> Aw, damn, apress.com doesn't include Springer textbooks in their every-ebook-for-$15 deal like they did last year. Sorry, that was probably my fault for buying like 8 of them.
06:28:04 <cariveri> Aetherspawn: ok thanks for trying. Ill try again late.
06:33:07 <kartofelbrei> freezway: oh, my bad, should be at the beginning.
06:33:22 <freezway> kartofelbrei, ok that makes more sense. thanks!
06:41:07 <stevex> why cant you catch exceptions in non-IO code?
06:51:36 <bennofs> stevex: Why would you want to do that?
06:52:07 <stevex> why not?
06:52:34 <bennofs> Well, the only exceptions thrown by pure code are exceptions from error or from undefined afaik
06:53:04 <dcoutts> you can throw arbitrary exceptions in pure code
06:53:08 <bennofs> oh?
06:53:12 <dcoutts> @type throw
06:53:12 <lambdabot> Exception e => e -> a
06:53:30 <bennofs> What? I believed throw was e :: IO () :|
06:53:33 <dcoutts> you can only catch them in IO of course
06:53:35 <dcoutts> @type throwIO
06:53:36 <lambdabot> Exception e => e -> IO a
06:53:54 <bennofs> @index throw
06:53:54 <lambdabot> Control.Exception
06:54:02 <dcoutts> bennofs: check you're using throwIO in your IO code :-)
06:54:14 <dcoutts> to make sure it's properly sequenced wrt other actions
06:54:21 <stevex> so why was it decided you can only catch them in IO?
06:54:28 <bennofs> I am not throwing exceptions in my code at all :)
06:54:47 <dcoutts> stevex: it would screw up the semantics of Haskell if you could catch them in pure code
06:55:08 <dcoutts> it'd break purity
06:55:09 <geekosaur> stevex: exceptions are pretty close to the extreme case of impurity
06:55:39 <bennofs> I only use Either/Maybe/Checked exceptions using the control-monad-exception package
06:56:39 * dcoutts notes that IO exceptions are quite nice when actually doing IO
06:57:41 <bennofs> I don't like about exceptions that you can always forget to catch them somewhere :|
06:57:55 <stevex> do you have an example where catching exceptions would break purity?
06:58:36 <Iceland_jack> stevex: error "hi" + 1/0
06:59:05 <stevex> you arent catching any
06:59:29 <dcoutts> bennofs: for the cases where exceptions are useful, the usual thing is not to catch them, or only catch them at some top level place
07:00:35 <quicksilver> at least some levels distant, anyway
07:01:06 <Iceland_jack> stevex: Because catching in a pure context isn't possible
07:01:09 <mr-> stevex: this is not answering your question, but to work around it, you could just wrap them in Maybe or Either. thisMayGoWrong :: a -> Maybe b or thisMayGoWrongButKnowsWhy :. a -> Either FailReason b
07:01:53 <Iceland_jack> If I had a function “pureCatch” which catches every exception, which exception does it catch?
07:01:54 <Iceland_jack>     pureCatch (error "hi" + 1/0)
07:02:10 <Iceland_jack> It would depend on the order of evaluation
07:02:44 <Iceland_jack> stevex: https://ghc.haskell.org/trac/haskell-prime/wiki/ImpreciseExceptions
07:04:11 <bennofs> What does using IO exceptions gain you over using EitherT?
07:04:58 <bennofs> With EitherT, you get (<|>) and other Alternative combinators for free. Those seem pretty useful for me
07:06:27 <dcoutts> bennofs: you mean IO a + exceptions vs EitherT IOError IO a
07:06:31 <dcoutts> can easily have different types of exceptions, e.g. IOError + others
07:07:26 <bennofs> Then maybe IO a + exceptions vs (Throws Exception A, Throws ExceptionA eEMT
07:07:40 <tomejaguar> bennofs: I have often wondered.  The existence of exceptions is one of my least favourite things about Haskell.
07:07:53 <bennofs> Then maybe IO a + exceptions vs (Throws ExceptionA e, Throws ExceptionA e) => EMT e IO a
07:08:12 <Iceland_jack> Exceptions are more efficient than propogating in EitherT
07:08:18 <mikeplus64> tomejaguar: exceptions are um, exceptional
07:08:22 <Iceland_jack> so if you're already in the IO monad you may as well
07:08:23 <mikeplus64> or at least, should be
07:10:00 <mikeplus64> they are also a convenient way of killing a thread, which you can't do with just e.g. Left "oh no there was an error"
07:11:23 <tomejaguar> As far as I understand it, there's no reason exceptions have to be invisible to the type system, except those that genuinely arise from run time issues like out of memory.
07:11:51 <tomejaguar> Well, even those don't *have* to, but they can happen anywhere, so you don't gain anything by marking them :)
07:13:07 <mikeplus64> what i think might have been a mistake is to have exceptions thrown in pure code... maybe. exceptions are also very convenient in immediately 'halting' some loop, especially in a higher order function like foldr or something, without the overhead of Maybe or Either e
07:13:13 <dcoutts> tomejaguar: we already have _|_, having a stopping variant with some info about what went wrong is better than an infinite loop :-)
07:14:05 <dcoutts> mikeplus64: using it for control flow like that is just abuse, and fortunately you cannot do that in pure code.
07:14:17 <tomejaguar> mikeplus64: You can't help it if OOM is thrown in pure code.  User created exceptions *could* technically be made impossible.
07:14:50 <dcoutts> tomejaguar: not unless you want partial functions to just not terminate
07:15:03 <dcoutts> you need error
07:15:17 <bennofs> but throw feels just wrong
07:15:38 <dcoutts> why should we be limited to throwing strings?
07:15:52 <dcoutts> that cannot be analysed
07:16:07 <tomejaguar> dcoutts: Like I said, anything to do with the run-time system failing is fine.  I don't think exceptions should be used in HTTP libraries for '404 page not found' like they are now.
07:16:17 <bennofs> but then throw should not be exported from Control.Exception. Maybe Unsafe.Exception or something
07:16:29 <dcoutts> bennofs: why? it's not unsafe
07:16:34 <mikeplus64> dcoutts: i should instead say explode, or "have an error", rather than "terminate", i don't mean cases where you throw an exception for control flow
07:16:57 <tomejaguar> dcoutts: It's unsafe like partial functions are unsafe, which is to say more unsafe than I would like ...
07:17:00 <merijn> tomejaguar: That's a library design issue, not a language issue
07:17:17 <tomejaguar> merijn: It's a language issue like the absence of the IO monad in OCaml is a language issue.
07:17:22 <dcoutts> tomejaguar: and the semantics of the language being not-total does of course allow that, it's unavoidable.
07:17:42 <merijn> tomejaguar: How so? What's the alternative? Drop exceptions? That's a price I'm not willing to pay
07:17:48 <tomejaguar> dcoutts: Sure, I'm just saying it should be avoided wherever possible.  One step towards that would be to reflect all user-thrown exceptions in the type.
07:17:51 <dcoutts> so once you have it anyway, why not make it less useless?
07:18:26 <merijn> tomejaguar: I agree that exceptions should be avoided, but I'm not sure how to promote this without ruining the nice use cases they have now
07:18:30 <tomejaguar> merijn: Have an Exception type constructor.  The only user-defined things that can throw exceptions have to be wrapped in that type constructor.
07:18:37 <mikeplus64> more haddocks should say "this function throws SomeException"
07:18:48 <dcoutts> tomejaguar: so one software design difference is that exceptions in pure code really should only be for programming errors, not bad input
07:18:51 <merijn> tomejaguar: How does that help?
07:18:54 <tomejaguar> mikeplus64: Types are my documentation.  I don't want to have to read informal words.
07:19:02 <tomejaguar> merijn: It provides more type safety.
07:19:10 <dcoutts> tomejaguar: where as in IO, using exceptions because writing to a file caused the disk to fill up is quite reasonable
07:19:10 <merijn> tomejaguar: That just means any IO function will have to return Exception
07:19:10 <tomejaguar> dcoutts: Agreed.
07:19:22 <tomejaguar> merijn: Why?
07:19:23 <mikeplus64> tomejaguar: types often aren't really enough, as helpful as they are :p
07:19:31 <tomejaguar> mikeplus64: Often, but in this case they could be.
07:19:34 <merijn> tomejaguar: Hell, all pure code would have to be Exception
07:19:41 <merijn> tomejaguar: OOM exception can occur anywhere
07:19:48 <tomejaguar> merijn: No, only "pure" code which throws a user-defined exception.
07:19:54 <Aetherspawn> that job application email went terribly.
07:20:07 <tomejaguar> merijn: Right, if you read what I said above you will see I'm talking about user-defined execptions, not runtime system errors.
07:20:17 <merijn> tomejaguar: Doesn't help
07:20:20 <dcoutts> tomejaguar: but there's no reason that I can see that forcing all those pure exceptions to be uninformative strings is better than allowing more structured packets of info about what went wrong
07:20:20 <tomejaguar> merijn: Why not
07:20:25 <mikeplus64> on that subject, does HeapOverflow work/get thrown/exist?
07:20:30 <merijn> tomejaguar: "unsafePerformIO (throwIO myError)"
07:20:34 <tomejaguar> dcoutts: I think we're talking at cross-purposes.
07:20:36 <dcoutts> mikeplus64: I think it doesn't
07:20:46 <dcoutts> mikeplus64: though I think stack overflow does work
07:20:55 <tomejaguar> merijn: So what?
07:20:57 <mikeplus64> dcoutts: yeah, that was the state last time i checked
07:21:56 <merijn> tomejaguar: If you're gonna say "but people shouldn't use unsafePerformIO", you can just say "people shouldn't use throw" and be done with it
07:22:26 <dcoutts> no no, throw is a lot less bad than unsafePerformIO
07:22:34 <dcoutts> throw has a proper semantics
07:22:35 <merijn> Incidentally, people usually *shouldn't* use throw
07:22:44 <osfameron> otherwise it'd be called unsafeThrow
07:22:48 <mikeplus64> dcoutts: it would be nice to have HeapOverflow in particular for my 'repl' project, which i hoped to have supercede mueval (it's a lot faster, supports more stuff etc), but it doesn't have a good way of dealing with memory limits yet (although it could be made into a "server" process, it would nice to just have catch (\HeapOverflow -> ... ))
07:22:55 <tomejaguar> merijn: Ah, well I do agree with that.  However, throw *can* be made typesafe in the way I described (as far as I can tell), so why not let it?
07:23:18 <dcoutts> mikeplus64: right, the only way to deal with that really is using system facilities like forkProcess
07:23:33 <merijn> tomejaguar: throw *is* typesafe
07:23:46 <dcoutts> mikeplus64: to enforce a limit you'd need sub-heaps etc
07:23:48 <tomejaguar> merijn: What do you mean by that?
07:23:53 <mikeplus64> i couldn't get forkProcess to work right with it, i didn't ever get to the bottom of that though
07:24:02 <bennofs> is foldM a left fold?
07:24:05 <bennofs> @src foldM
07:24:05 <lambdabot> foldM _ a []     = return a
07:24:05 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
07:24:06 <mikeplus64> ran out of time/motivation
07:24:15 <tomejaguar> merijn: I think I'm suggesting it could be made *more* typesafe than it already is.
07:24:20 <mr-> @src foldl
07:24:21 <lambdabot> foldl f z []     = z
07:24:21 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:24:29 <merijn> tomejaguar: There is a defined haskell semantics for throw, and, throw being bottom it is already part of every type, because bottom is part of every type
07:24:32 <tomejaguar> In the same way that IO in OCaml is typesafe, but could be made *more* typesafe if they had an IO monad.
07:24:33 <dcoutts> bennofs: technically it's a foldr
07:24:44 <bennofs> @src foldr
07:24:45 <lambdabot> foldr f z []     = z
07:24:45 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:24:56 <mr-> looks like a foldl
07:24:56 <tomejaguar> merijn: OK, well I think then I'm suggesting a more fine-grained semantics.
07:25:10 <tomejaguar> Personally I think Haskell programmers would like my suggestion.
07:25:23 <merijn> tomejaguar: What you seem to want is a total language, which is fine. Total languages are a brilliant idea
07:25:26 <dcoutts> tomejaguar: I think that's the right thing to do for errors that you expect to happen
07:25:29 <bennofs> > runIdentity $ foldM f x [a,b,c,d,e]
07:25:30 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr
07:25:31 <lambdabot>                     (Dat...
07:25:38 <bennofs> > runIdentity $ foldM f a [b,c,d]
07:25:39 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr
07:25:39 <lambdabot>                     (Dat...
07:25:39 <merijn> tomejaguar: But retroactively making haskell a total language is impossible
07:25:50 <tomejaguar> merijn: No not at all.  I want Haskell exactly as it is, but for exception throwing to be indicated with a type!
07:25:58 <dcoutts> tomejaguar: it's rather like Java's checked and unchecked exceptions, there are useful places for both.
07:26:15 <merijn> tomejaguar: I thought the same thing a few months ago
07:26:23 <tomejaguar> dcoutts: Ah now that I *don't* agree with.  Exceptions are an effect and they ought to be indicated in the type.
07:26:30 <simpson> At the end of the day, sometimes you just run out of memory.
07:26:41 <tomejaguar> merijn: Do go on ...
07:26:41 <merijn> tomejaguar: I started thinking about it and how to implement it and realised that "checked" exceptions are better dealt with using Either/Maybe/etc.
07:26:51 <bennofs> > runIdentity $ foldM (fmap Identity . f) a [b,c,d]
07:26:52 <lambdabot>   f (f (f a b) c) d
07:27:00 <bennofs> > foldl f a [b,c,d]
07:27:01 <lambdabot>   f (f (f a b) c) d
07:27:02 <dcoutts> tomejaguar: that's true for cases where the error is expected, and you want to do something with it. That's the checked exception case.
07:27:06 <tomejaguar> merijn: I agree, except in some cases for performance reasons.
07:27:08 <merijn> throw is for unchecked exceptions, which do have a place in the languages
07:27:15 <bennofs> looks like a foldl to me
07:27:25 <mr-> foldl FTW
07:27:34 <tomejaguar> dcoutts: Can you think of anything that's not a runtime system error that you want to be unchecked?
07:27:46 <tomejaguar> (or, I grant you, your previous sugesstion of programmer error)
07:27:48 <bennofs> dcoutts: how is foldM a foldl?
07:27:57 <tomejaguar> (where your state may have become inconsistent)
07:28:00 <dcoutts> tomejaguar: but the unchecked exception case is just the right thing for assertions etc, like Data.Map.fromAscList
07:28:14 <dcoutts> bennofs: I said foldM is a foldr, not a foldl
07:28:31 <bennofs> dcoutts: sorry, I meant to say "how is foldM a foldr"?
07:28:33 <dcoutts> bennofs: however that is slightly misleading...
07:28:38 <tomejaguar> dcoutts: Really?  You sdon't want to just use Maybe?
07:29:20 <dcoutts> tomejaguar: no, that would be a massive pita, then you just force the caller to do the pattern match and call error "impossible" if it fails
07:29:20 <bennofs> tomejaguar: control-monad-exception implements some sort of "checked exceptions"
07:29:59 <dcoutts> tomejaguar: the whole point of Map.fromAscList is that the input is known to be sorted. If you don't know that then you just use Map.fromList
07:30:21 <dcoutts> and if the programmer messed up, then that's an error
07:30:32 <dcoutts> but not a checked error
07:30:48 <dcoutts> sorry, not a checked exception
07:33:43 <tomejaguar> bennofs: Nice, I think that's pretty much what I'm talking about.
07:34:42 <tomejaguar> dcoutts: I guess we just disagree on this one then.  For me exceptions are only when two parts of code written by the same entity are in conflict.  At API boundaries I would always prefer some explicit type.
07:35:26 <dcoutts> tomejaguar: ok, but you have to admit it's a pretty common design pattern
07:35:39 <dcoutts> Map.fromAscList is not a rare example
07:36:03 <dcoutts> functions with non-trivial pre-conditions
07:36:13 <tomejaguar> Oh I admit it happens all the time.  I just don't like it :)
07:36:37 <dcoutts> tomejaguar: but using Either here would not help anyone
07:36:57 <dcoutts> I'd just have to do:  let Right m = Map.fromAscList ...
07:37:01 <tomejaguar> Why not?  If I'm the client of the Data.Map API and I have passed an invalid argument I want to know it immediately so I can handle it
07:37:10 <dcoutts> but you cannot handle it
07:37:14 <tomejaguar> If I *really* don't want to handle it I'll just use fromJust/fromLeft
07:37:16 <dcoutts> the whole point is that it's impossible
07:37:19 <tomejaguar> Of course I can handle it.
07:37:32 <dcoutts> if means you made a mistake
07:37:36 <bennofs> tomejaguar: It's an assertion. You've made a programming error. That shouldn't really be in your release code, the whole part of it is to fail fast.
07:37:40 <dcoutts> and you have to fix the program
07:37:41 <tomejaguar> Sure, I means I misread the API spec.
07:37:57 <tomejaguar> It's in my release code regardless!
07:38:11 <dcoutts> yes, and that's why we have unchecked exceptions
07:38:14 <tomejaguar> Having Either/Maybe in the type there mean it won't *compile* unless I'm aware that it can fail.
07:38:18 <dcoutts> so that some top level handler can tell someone
07:38:33 <dcoutts> tomejaguar: but there's still nothing you can do there except call error
07:38:38 <dcoutts> in a correct program
07:38:40 <tomejaguar> The only thing you gain from that is removing a whole bunch of Maybe/Either from your call chain.
07:38:43 <dcoutts> because remember, it's impossible
07:38:59 <dcoutts> yes, you benefit from having a more comprehensible program
07:39:20 <tomejaguar> I agree it's a benefit, but personally I don't think the drawbacks are worth it.
07:39:33 <tomejaguar> Nor do I agree that it should be considered an impossible condition.
07:39:53 <tomejaguar> If *I* had written fromAscList *and* the code that uses *fromAscList* then yes
07:40:02 <tomejaguar> If fromAscList is in a library then no
07:40:11 <dcoutts> ok, so no code reuse then eh?
07:40:12 <tomejaguar> In the latter case I want the failure to be explicit.
07:40:37 <tomejaguar> I don't see how that affects code reuse any more than doing anything in any other monad.
07:41:35 <bennofs> tomejaguar: fromAscList is just a library function with an invariant that can't be checked. It's just for performace optimization. If you aren't sure that your list is sorted, then you'd just use fromList. There's no point in calling fromAscList first and then handling the maybe
07:41:55 <bennofs> by checked I mean easily expressed in the type in haskell
07:43:18 <tomejaguar> Sure but programmers make mistakes.  That's why we love the type system.
07:43:50 <tomejaguar> [In any case, I don't think fromAscList even checks that the list is sorted, but I get your point]
07:43:50 <bennofs> But do you want to do in case of an error when fromAscList returns Maybe?
07:43:50 <Iceland_jack> tomejaguar: Programmers make mistakes? That doesn't sound right to me...
07:43:55 <Iceland_jack> Do you have a citation?
07:43:59 <tomejaguar> Iceland_jack: turns out they do.
07:44:06 <tomejaguar> Iceland_jack: yes, most of my code, every day :)
07:44:45 <Iceland_jack> Maybe you wrote that to prove your point, in which case you will have correctly written the code incorrectly further strengthening *my* point
07:45:32 <tomejaguar> My opinion is: If something's unrecoverable it should be an exception.  If it's recoverable, it shouldn't be an exception.  Anyway, I grant you there are good alternatives to my point of view, and indeed the vast majority of programmers disagree with me.
07:45:47 <dcoutts> Iceland_jack: ;-)
07:46:12 <bennofs> tomejaguar: that's my POV also. I just think that fromAscList is unrecoverable
07:47:25 <tomejaguar> bennofs: My definition of recoverable is "the runtime system and the state of your program is not in an inconsistent state".
07:47:43 * hackagebot system-random-effect 0.3.0 - Random number generation for extensible effects.  http://hackage.haskell.org/package/system-random-effect-0.3.0 (ClarkGaebel)
07:48:47 <bennofs> tomejaguar: what's an inconsistent state of the program for you?
07:48:48 <tomejaguar> bennofs: Theoretically your program can continue working fine even if fromAscList says "bad programmer".  If you are OOM on the other hand, it can't.
07:49:16 <quicksilver> there is a school of thought that a program should not continue working if it knows an invariant has been violated
07:49:37 <quicksilver> if an invariant has been violated then everything else is questionable, suicide is the only honourable approach.
07:49:47 <tomejaguar> quicksilver: Right, I agree with that.
07:49:49 <quicksilver> not everyone buys that.
07:49:53 <Iceland_jack> That depends on the invariant though, surely
07:50:06 <Lindrian> so I have a list xs with some strings in it, and I want to apply a function that will return the longest strings from this list. I was thinking of using something like [x | x <- xs] and then validating x, but im not sure how to do it
07:50:12 <Lindrian> could someone please point me in the right direction?
07:50:20 <tomejaguar> But if you define fromAscList' :: [a] -> Maybe (Set a) then you don't even have to have that invariant.
07:50:29 <Iceland_jack> Lindrian: maximumBy
07:50:30 <bennofs> @ty maximumBy
07:50:31 <lambdabot> (a -> a -> Ordering) -> [a] -> a
07:50:38 <tomejaguar> The argument that 'fromAscList' is more efficient is more compelling.
07:50:51 <tomejaguar> I'll grant you that one.  In that case we all have to be responsible.
07:51:05 <tomejaguar> But efficiency concerns aside, I see no reason not to return a Maybe.
07:51:16 <Lindrian> Iceland_jack: I realize that function exists, but this is for a home assignment where I am trying to learn by reimplementing the method
07:51:30 <Lindrian> so you dont have to give me a solution, I just need a pointer in the right direction
07:51:34 <Iceland_jack> Lindrian: Have you looked at its source?
07:51:43 <Lindrian> that would be cheating :p
07:51:50 <Iceland_jack> I mean if you want to implement your own solution it shouldn't be that difficult
07:52:00 <bennofs> Lindrian: you could try to write it as a fold, always keeping the maximum so far
07:52:12 <Iceland_jack> Just iterate through the list, maintaining the maximum length and the string of that length
07:52:22 <Iceland_jack> (what bennofs calls ‘fold’)
07:52:34 <Lindrian> bennofs: I need to keep all the largest elements
07:52:44 <int-e> Iceland_jack: the type is supposed to be [String] -> [String], I believe
07:52:44 <Lindrian> ["a", "bc", "de"] => ["bc", "de"]
07:53:13 <Iceland_jack> Lindrian: You just need to store (lenOfLongest, listOfLongest) :: (Int, [String])
07:53:26 <int-e> (which means that looking at maximumBy is not cheating too much)
07:53:26 <bennofs> Lindrian: then you keep the "maximum so far" and the "elements that have the maximum value so far". If you encounter a new maximum, you just discard the list
07:53:43 <Iceland_jack> where: all ((== lenOfLongest) . length) listOfLongest
07:54:13 <Lindrian> hmm i thought it could be simpler than that
07:54:18 <Lindrian> i was playing with list comprehensions
07:54:21 <danilo2> Hello! Could somebody tell me, why compiling "accelerate" package on windows gives an error "The package has a './configure' script. This requires a Unix compatibility toolchain such as MinGW+MSYS or Cygwin." ?
07:56:35 <Iceland_jack> Lindrian: It *can* be simpler, but less efficient
07:56:48 <Iceland_jack> you can use a list comprehension to make a tuple for every string: (length, string)
07:56:52 <Iceland_jack> then sort the result
07:57:00 <Iceland_jack> then reverse the list
07:57:04 * geekosaur thinks that message is pretty clear, unless you already have such environment in which case you need to make sure cabal-install can find it
07:57:22 <Iceland_jack> then take the first elements whose length is the same
07:57:27 <Iceland_jack> discard length
07:57:30 <Iceland_jack> solution!
07:58:23 <Iceland_jack> Lindrian: I can provide a more convoluted, less efficient solution on demand btw
07:58:46 <tdammers> Iceland_jack: shuffle the list until the first two elements have the same length?
07:58:47 <Lindrian> okay
07:58:53 <Lindrian> i can start with an inefficient solution
07:59:03 <Iceland_jack> tdammers: yes, randomly shuffle it putting it into the IO monad
07:59:11 <Iceland_jack> and then using unsafePerformIO
07:59:14 <tdammers> Iceland_jack: bogofind!
07:59:20 <Iceland_jack> !!
08:00:53 <Eduard_Munteanu> How do you set the indent unit in haskell-mode? I prefer 8 spaces instead of 2.
08:01:19 <Iceland_jack> 5, 7 or 13
08:01:55 <Eduard_Munteanu> Was that for me? :/
08:01:59 <Lindrian> Iceland_jack: i was thinking [x | x <- xs, compare length of x to every other element in the list here to see if we want to keep it]
08:02:04 <Lindrian> but i have no clue how to do that.
08:02:16 <Iceland_jack> Eduard_Munteanu: I only indent with primes..
08:02:29 <Iceland_jack> Lindrian: that's because you can't do it that way
08:02:36 <Lindrian> why not?
08:02:45 <Iceland_jack> well I mean, it would have insane complexity
08:02:50 <Eduard_Munteanu> I use prime logs base 2, hence I go for 2 ^ 3 = 8 :P
08:02:51 <Lindrian> ah i see
08:03:14 <Iceland_jack> why are you so dead set on using list comprehensions?
08:03:23 <Lindrian> just first thing that came to mind
08:03:42 <Iceland_jack> Lindrian: well ok we can work with it
08:03:57 <Iceland_jack> so for every element, you want to either discard it or keep it
08:04:11 <Lindrian> yes
08:04:12 <Iceland_jack> when do you keep it?
08:04:50 <Lindrian> when its longer than every other elem in the list
08:04:52 <Lindrian> length
08:04:59 <Iceland_jack> @ty all
08:05:00 <lambdabot> (a -> Bool) -> [a] -> Bool
08:05:10 <Iceland_jack> does that seem relevant?
08:05:39 <Eduard_Munteanu> Hm, I think I want 'tab-width'.
08:05:55 <Lindrian> oh
08:06:25 <shachaf> Are there any Haskell Functors other than (e,) that preserve sums?
08:07:56 <Iceland_jack> Lindrian: “pick the element ‘x’ from xs where for any element ‘y’ from xs: length y <= length x”
08:07:59 <shachaf> I know that (e,) is the only left adjoint.
08:08:11 <Lindrian> right
08:08:25 <bennofs> shachaf: what does "preserve sums" mean?
08:08:37 <shachaf> Preserve coproducts.
08:08:43 <Iceland_jack> You can implement that using a single call to “all” as a guard
08:09:02 <shachaf> f (Either a b) = Either (f a) (f b)
08:09:05 <Eduard_Munteanu> shachaf: it is the only left adjoint?
08:09:12 <Lindrian> i will try
08:10:04 <shachaf> Eduard_Munteanu: The only left adjoint Functor, yes (up to isomorphism, of course).
08:10:10 <bennofs> shachaf: what's about (->) e ?
08:10:24 <shachaf> What's about it?
08:10:44 <bennofs> hmm, forget about that
08:10:49 <shachaf> (e -> Either a b) /= Either (e -> a) (e -> b)
08:10:51 <shachaf> Right.
08:11:33 <Eduard_Munteanu> shachaf: well, to be honest, (,) e isn't cocontinuous on the nose either
08:12:39 <shachaf> Which nose?
08:12:47 <Eduard_Munteanu> Er, nevermind, the on the nose bit isn't important since you have an UMP.
08:13:39 <Eduard_Munteanu> shachaf: anyway, how do you know (,) e is the only left adjoint? I'm curious.
08:14:52 <shachaf> If F -| G, (F a -> b) ~~ (a -> G b), so in particular (F () -> b) ~~ (() -> G b)
08:14:57 <simpson> Wait, is "on the nose" actual jargon?
08:15:03 <Lindrian> Iceland_jack: how should I use 'all'?
08:15:05 <Eduard_Munteanu> simpson: yes
08:15:14 <Eduard_Munteanu> Sort of.
08:15:20 <Iceland_jack> Lindrian: You give it a predicate which should hold for all elements of a list
08:15:26 <Iceland_jack> > all even [2,4,6,10]
08:15:27 <lambdabot>   True
08:15:28 * simpson is never sure whether category theory is actually real or just some elaborate prank cooked up by mathematicians
08:15:29 <shachaf> So G b ~~ (F () ->), so F ~~ (F (),) is its left adjoint.
08:15:38 <Iceland_jack> simpson: Why not both?
08:15:42 <shachaf> simpson: It's English jargon, not category jargon.
08:15:55 <shachaf> I was just asking for clarification.
08:16:04 <simpson> shachaf: Oh.
08:16:08 <Lindrian> Iceland_jack: right, but how am I supposed to compare length of each item that way?
08:16:14 <Lindrian> not sure how it will help me
08:16:29 <Iceland_jack> Lindrian: When you have:
08:16:29 <Iceland_jack>     [ x | x <- xs, ... ]
08:16:29 <Iceland_jack> you have access to each element of the list
08:16:36 <Lindrian> yes
08:16:45 <Lindrian> all (length x) ...
08:16:50 <Lindrian> all (length x >=) ...
08:16:51 <Lindrian> even
08:17:02 <Iceland_jack> you also have access to xs
08:17:30 <Lindrian> but i cant just toss in xs there
08:17:40 <Iceland_jack> Lindrian: xs is the second argument to `all'
08:17:55 <Lindrian> i get an error when I try it in ghci
08:18:26 <Lindrian>  all ((length "12345") >=) ["abc", "def"]
08:18:39 <Iceland_jack> Maybe you want to look at Learn You a Haskell,
08:18:39 <Iceland_jack> @where lyah
08:18:39 <lambdabot> http://www.learnyouahaskell.com/
08:18:52 <Lindrian> i am.
08:19:06 <Iceland_jack> also, it should have the structure:
08:19:06 <Iceland_jack>     all (\word -> ...) ["abc", "def"]
08:19:07 <shachaf> Lindrian: That means: (length "12345" >= "abc") && (length "12345" >= "def")
08:19:34 <Lindrian> shachaf: right, thats what I thought, which is why i did not see how it would work
08:19:52 <Iceland_jack> Lindrian: Can you check for me what the type of '((length "12345") >=)' is? :)
08:19:52 <shachaf> Oh, maybe I'm missing the context.
08:19:59 <shachaf> It oughtn't.
08:20:00 <Cale> > all (length "12345" >=) . map length $ ["abc", "def"]
08:20:01 <lambdabot>   True
08:20:13 <Cale> Lindrian: 5 >= "abc" doesn't make sense
08:20:20 <Iceland_jack> Cale: (don't give the answer away :])
08:20:20 <Lindrian> it doesnt
08:20:28 <Lindrian> yeah i see what Cale  did there
08:20:29 <Lindrian> thats clever
08:20:33 <Iceland_jack> Lindrian: That's what the code you pasted does
08:20:38 <Lindrian> yes
08:20:44 <Iceland_jack> I need to leave you now, best of luck Lindrian
08:20:50 <shachaf> all (\x -> length "12345" >= length x)
08:20:53 <Lindrian> ok thanks.
08:21:05 <shachaf> all ((>=) `on` length) and so on if you're into that sort of thing.
08:21:05 <Iceland_jack> shachaf: (come on, don't give the code)
08:22:51 <Eduard_Munteanu> shachaf: remind me, the converse of left adjoint implies cocontinuity isn't true, right?
08:23:13 <Eduard_Munteanu> I mean not all cocontinuous functors are left adjoints.
08:24:04 <shachaf> No, you need various extra conditions.
08:24:16 <Eduard_Munteanu> Ok, so your question stands. :)
08:26:00 <shachaf> Also I'm just asking about sums, not hypothetical other colimits. Who knows whether that changes anything.
08:26:30 <Cale> It's the solution set condition thing
08:28:15 <Lindrian> While I'm at it, could you guys explain the difference between $ and . and when to use which?
08:28:19 <Lindrian> I am very confused by the two
08:28:29 <Cale> ($) is function application
08:28:39 <Cale> It takes a function and a value, and applies the function to the value
08:28:41 <Cale> i.e.
08:28:45 <Cale> f $ x = f x
08:29:16 <Cale> It's mainly used because it has very low precedence (while ordinary function application, i.e. whitespace, is higher precedence than any infix operator)
08:29:20 <Lindrian> why did you need $ here: map length $ ["abc", "def"] ?
08:29:26 <Cale> (.) is function composition
08:29:51 <Cale> (f . g) x = f (g x)
08:29:52 <Maior> Lindrian: people feel $ makes things easier to read than more parentheses
08:29:58 <Maior> :t ($)
08:29:59 <lambdabot> (a -> b) -> a -> b
08:30:00 <Cale> or: f . g = \x -> f (g x)
08:30:14 <int-e> f . g =
08:30:26 <int-e> f . g = \x -> f $ g x -- sorry, could not resist.
08:30:34 <Lindrian> ah okay
08:30:35 <Lindrian> i see
08:30:44 <Lindrian> Maior: but i dont understand where the parenthesis would be
08:30:50 <Lindrian> :t map
08:30:50 <lambdabot> (a -> b) -> [a] -> [b]
08:30:52 <Eduard_Munteanu> shachaf: hm... Hask is a CCC, so any endofunctor preserves limits, so it also preserves (). So if G b ~~ (F () ->), G b ~~ (() ->), G b ~~ Id for any F -| G, F and G endofunctors. This seems stronger.
08:30:57 <Lindrian> right, takes a function and a list
08:31:00 <Cale> Lindrian: If I didn't put the $ there, then the function application would bind more tightly, and things would be ill-typed
08:31:01 <Lindrian> why would you need that $ ?
08:31:10 <Cale> all (length "12345" >=) . map length $ ["abc", "def"]
08:31:16 <Cale> schematically, this is
08:31:20 <Cale> f . g $ x
08:31:23 <Lindrian> Cale: I thought length would have been applied to each element in that list
08:31:26 <Maior> Lindrian: you actually don't need it there
08:31:33 <Cale> which is very different from
08:31:35 <Cale> f . g x
08:31:39 <Cale> which means f . (g x)
08:31:40 <Maior> Lindrian: sorry, didn't look closely enough at your example
08:31:58 <Maior> Lindrian: given how little it does, it's often left around / used needlessly
08:32:01 <Cale> map length ["abc", "def"] is a list and not a function, so it can't be composed with another function
08:32:09 <Cale> (.) needs two functions as its arguments
08:32:15 <Cale> I could have written:
08:32:24 <Lindrian> ohhh Cale, I see now. the $ is used so that "map" doesnt think xs belongs to it?
08:32:26 <Cale> (all (length "12345" >=) . map length) ["abc", "def"]
08:32:28 <tomejaguar> Lindrian: I tend to use . a lot, but typically only use $ temporarily when refactoring.
08:32:30 <Lindrian> since you're sending xs to all and not map
08:32:43 <Cale> i.e.
08:32:46 <Lindrian> Cale: thanks, im with you now.
08:32:47 <Cale> (f . g) x
08:33:16 <Lindrian> the . basically means the left function takes the right function as input, right?
08:33:34 <Cale> The thing on the right of $ needn't be a function
08:33:40 <Lindrian> yep
08:33:42 <Cale> But otherwise, yes
08:33:42 <Lindrian> thank you so much
08:33:58 <Cale> Both of the arguments to (.) must be functions
08:33:58 <vamega> If I'm trying to move some files.
08:34:05 <vamega> Is the right package to use System.Directory?
08:34:14 <Cale> vamega: yeah
08:34:34 <Cale> renameFile :: FilePath -> FilePath -> IO ()
08:36:20 <vamega> Great, thanks
08:36:48 <vamega> Haddock said it was last updated in 2012. Wasn't sure if that was still accurate.
08:39:04 <donri> it's a core library
08:39:34 <vamega> I figured as much, but thought I'd ask.
08:40:01 <vamega> Is there a time to use System.posix.Directory over System.Directory?
08:42:47 * hackagebot network 2.4.2.1 - Low-level networking interface  http://hackage.haskell.org/package/network-2.4.2.1 (JohanTibell)
08:43:05 <donri> well posix won't build on windows and doesn't have the right function in that module anyway :)
08:48:53 <roconnor> Is there a program for finding exact Rational solutions of Linear Programming problems ... perferably in Haskell or with a Haskell interface?
08:52:03 <Lethalman> roconnor, glpk --exact maybe... I've used glpk but never --exact
08:52:17 <Lethalman> roconnor, and I bet there's some hackage for glpk
08:53:38 <roconnor> there is for glpk
08:53:54 <roconnor> a very quick and incomplete survey suggests that Double is used everywhere
08:54:03 <roconnor> which makes me nervous about stability
08:54:22 <roconnor> I'd rather have slow than wrong.
08:57:18 <roconnor> --exact seems good
09:01:32 <klrr_> quchen: sry if I sounded rude on reddet earlier, later realized some other people were quite rude too did not mean to join them and be negative in the thread on purpose, the tutorial itself was quite good and will be useful for a lot of people i would presume!
09:02:50 <quchen> klrr_: I don't think you sounded rude
09:03:30 <quchen> klrr_: I read your comment like you were directing attention to those package managers, and not seriously suggesting their usage right now because they integrate well :-)
09:03:54 <quchen> I basically assumed the links would lead to "this is Nix and it's good" Wiki-style description.
09:04:11 <quchen> After actually reading them I'm now more convinced I should try them out some day :-)
09:04:39 <quchen> As for the tutorial, I think I pissed at least one guy off with it. Meh
09:04:52 * roconnor is worried that glpk doesn't depend on gmp
09:07:02 <klrr_> quchen: okey :) also, someone get angry on a tutorial for it being "un-useful" for him then taht is his problem
09:07:14 <Sagi> any recommendations to choose among http://www.haskell.org/haskellwiki/Command_line_option_parsers ?
09:08:00 <Clint> Sagi: optparse-applicative is a channel favorite
09:08:34 <Sagi> thanks :)
09:09:36 <quchen> klrr_: His objection was that it was actively harmful. Well it'll be useful for at least me in a couple of weeks, so I decided to make it public. Anyway.
09:10:12 <quchen> Here comes my GHC question: why does it depend on libgmp at all? What GMP functionality is used? More than just arbitrary-sized ints?
09:10:32 <alexander__b> I didn't understand the tutorial. it looked like you were trying to do what emerge already does.
09:10:41 <roconnor> quchen: just arbitrary sized ints AFAIU
09:10:56 <quchen> alexander__b: I don't know what 'emerge' is.
09:11:14 <quchen> roconnor: Hm. Wouldn't that be simple to code in Haskell? Why have the dependency?
09:11:19 <alexander__b> quchen: the portage interface. portage is the package manager of gentoo.
09:12:04 <quchen> Well I have neither Gentoo nor Portage
09:12:07 <roconnor> quchen: I think there is a pure haskell implementation out there.  I'm not sure what the current status of options for running it in GHC instead of GMP is.  It was designed for that purpose because of political reasons.
09:12:28 <quchen> roconnor: political = because GMP is GPL?
09:12:32 <roconnor> quchen: yes
09:12:42 <alexander__b> quchen: so I take it it's not common for package managers to let you choose whether you want to bootstrap ghc, and have multiple versions, etc?
09:13:08 <quchen> alexander__b: aptitude generally doesn't compile, it downloads pre-compiled binaries.
09:13:16 <alexander__b> quchen: ouch
09:13:27 <quchen> Well it's much more user-friendly than compilation for sure.
09:13:39 <quchen> In particular it takes much less time even in the best case.
09:13:43 <alexander__b> doesn't sound like it, if you have to work around it to get it to do what you want.
09:14:02 <quchen> Compilers are a very small subset of all the programs I like to have installed.
09:14:07 <quchen> I wouldn't want to compile Firefox for example.
09:14:07 <alexander__b> portage supports both, if you are worried about time you can use a binhost. though I much prefer compiling.
09:14:16 <roconnor> quchen: PS I might be able to help you install nix on whatever distro you are running.  I have a little experience, but it has been a while.
09:14:21 <geekosaur> quchen: there is a Haskell version. which demonstrates why gmp is used: arbitrary sized ints are SLOW.
09:14:27 <bgamari> quchen, you want integer-simple
09:14:30 <geekosaur> gmp has been optimized over many years
09:14:38 <roconnor> compiling firefox is easy compared to libre office.
09:14:39 <bgamari> quchen, but it's slower than gmp
09:14:43 <quchen> geekosaur: That certainly makes sense
09:14:54 <bgamari> quchen, I'm not sure "slow" has been quantified however
09:15:04 <quchen> On the other hand, why not code a small own C version of arbitrary sized Ints?
09:15:09 <Hodapp> but arbitrary-sized ints are almost always going to be faster than a loop that runs infinitely because your type overflowed!
09:15:14 <quchen> That dependency really bugs me a little. It seems so unnecessary.
09:15:40 <roconnor> quchen: how is using gmp different from writing your own C version?
09:15:41 <quchen> Maybe I'm just underestimating the work required to code a performant arbitrary-sized int library.
09:15:53 <geekosaur> *shrug* go ahead and write it. I suspect you will discover, as many others have who've thought "how hard can it be?", is that performance is a disaster for anything more complex than 2+2
09:16:06 * roconnor hopes one day we get isqrt from gmp.
09:16:13 <Hodapp> roconnor: no isqrt?
09:16:33 <roconnor> Hodapp: there is no haskell interface into gmp's isqrt AFAIU
09:16:38 <Hodapp> ohhhh
09:17:00 <bgamari> robbert, This would be pretty easy to fix
09:17:04 <quchen> roconnor: I think less dependencies for a compiler are always desirable. It makes them more portable, in particular to computers owned by people that don't know how to compile things.
09:17:05 <bgamari> roconnor, rather
09:17:13 <bgamari> roconnor, I think it's just a little bit of C--
09:17:50 * hackagebot system-random-effect 0.3.1 - Random number generation for extensible effects.  http://hackage.haskell.org/package/system-random-effect-0.3.1 (ClarkGaebel)
09:18:19 <roconnor> quchen: as much as I hate to pontificate, but nix has pratcially solved the "doesn't know how to compile things" problem for me.  I even got Matita to compile.
09:18:20 <quchen> geekosaur: I didn't mean to sound smug or anything.
09:18:45 <roconnor> bgamari: probably :)
09:19:15 <bgamari> roconnor, If you have a need for it in a particular package, the bitset package has a good example of how to bind a function yourself
09:19:18 <quchen> roconnor: Let's take this to #haskell-overflow? I'd appreciate an overview over what to expect on the way to Nix
09:19:18 <bgamari> roconnor, e.g. https://github.com/bgamari/bitset/blob/master/cbits/gmp-extras.cmm
09:22:58 <maxiepoo> any Fedora users here? I'm a Fedora noob and I want to know how to get yum to use the latest version of haskell platform on Fedora 19
09:23:16 <donri> maxiepoo: http://dag.github.io/blog/2012/07/24/latest-haskell-platform-on-fedora-17/
09:23:19 <donri> same procedure
09:24:05 <maxiepoo> thanks donri
09:25:31 <vamega> Hi, I think I found an issue with Haddock.
09:25:34 <vamega> http://hackage.haskell.org/package/Glob-0.7.3/docs/System-FilePath-Glob.html
09:25:48 <vamega> The links to FilePaths documentation seem to point to a local filesystem path.
09:26:12 <vamega> How could I help in getting this fixed?
09:27:03 <Cale> vamega: I think that's a known issue, though I could be wrong...
09:27:13 <Cale> Let me dig up the trac or whatever for hackage
09:28:21 <quchen> vamega, Cale: yeah it's known, lots of packages seem to suffer from this
09:28:32 <quchen> For now you'll have to resolve the links manually
09:29:14 <vamega> Oh, yeah that's what I've been doing. Only slightly annoying. I'd love to get a link to the cause of this. I'm guessing that either it's hard to fix, or it's simple to fix but people have been occupied with other things.
09:29:23 <vamega> If it's simple I'd like to attempt to fix it.
09:29:40 <Feuerbach_> Seems like I'm the one responsible for that... https://github.com/haskell/cabal/issues/1064
09:30:08 <highPriestLOL> are there any examples in the wild of GUI programs in haskell?
09:31:01 <donri> leksah
09:34:58 <klrr_> highPriestLOL: http://www.haskell.org/haskellwiki/Threepenny-gui#Gallery
09:35:36 <c_wraith> for some reason, people don't consider threepenny to be a gui
09:36:06 <highPriestLOL> klrr_: Thank you
09:36:07 <vamega> Nikki and the Robots
09:36:14 <vamega> It's a game.
09:36:16 <klrr_> ^ nikki and the robots is really cool
09:36:31 <vamega> But definitely graphical and in haskell.
09:36:34 <klrr_> it uses QT for input/stuff and opengl for rendering iirc
09:36:56 <klrr_> c_wraith: what is the reasoning for that?
09:37:24 <c_wraith> klrr_: I should have said "some people", and it's because it doesn't generate any graphics calls.
09:38:30 <klrr_> what is a graphics call?
09:38:48 <c_wraith> something that tells your computer to draw something
09:39:27 <klrr_> okey
09:40:00 <shachaf> Eduard_Munteanu: Any endofunctor preserves limits?
09:41:12 <Eduard_Munteanu> shachaf: any Hask endofunctor
09:41:21 <Eduard_Munteanu> I think.
09:41:22 <quchen> Oh, shachaf. Long time no see!
09:41:46 <mr-> Eduard_Munteanu: the constant functor?
09:42:01 <mr-> oops
09:42:10 <Eduard_Munteanu> mr-: no
09:42:26 <Eduard_Munteanu> Oh, misread.
09:42:59 <Sagi> regarding optparse-applicative, should I consider a nonvalid-file 'e.g. not the file type I expect' as a parse failure? Or is such error handling better for one level up?
09:43:43 <Sagi> it would involve actually reading from the file, so I kind of think it shouldn't, but then the help text is probably be useful to remind the user what I'm expecting.
09:43:45 <quchen> Sagi: I think a correct file description should not be a parse error. It's correct in the sense of the parser, but not in the context of your program logic.
09:44:17 <Sagi> hmm, yeah
09:44:28 <Sagi> thanks
09:44:40 <quchen> In general you can't tell whether a file is right with the parser anyway.
09:45:03 <quchen> A cheap solution is looking at the file extension, but a JPEG without .jpg at the end is still a valid image.
09:45:32 <shachaf> Eduard_Munteanu: Meaning that e.g. F (a,b) ~~ (F a,F b)?
09:45:50 <Eduard_Munteanu> shachaf: yes
09:45:55 <tomejaguar> ???
09:46:30 <Eduard_Munteanu> Er, no.
09:46:49 <Eduard_Munteanu> That's stronger.
09:47:12 <tomejaguar> That's preserving products, isn't it?
09:47:27 <mr-> (and products are limits)
09:47:29 <Eduard_Munteanu> tomejaguar: those are specific products
09:47:31 <shachaf> Products are limits. Or am I misunderstanding what you mean?
09:48:05 <tomejaguar> Eduard_Munteanu: So when you say that all endofunctors in Hask preserve limits, what do you mean?
09:50:56 <Eduard_Munteanu> Given a product A x B in Hask and F : Hask -> Hask, F (A x B) is a product too: e.g. (a, b) |-> r -> (a, b), which can be written as (r -> a, r -> b).
09:51:50 <tomejaguar> So taking F = [], how do you write [(a,b)] as a product?
09:52:38 <Eduard_Munteanu> tomejaguar: ([a], [b])
09:52:49 <tomejaguar> That's not [(a,b)] though.
09:56:10 <klrr_> okey, i got problem with SDL1.2, basically my rendering code is somehow incorrect not the game logic (there is three "tests" in the code that confirms that, the color code, the comment and the print output), basically this code does not move the box i want to render even though the code should do that. anyone got an idea of what is wrong? https://gist.github.com/klrr/7752078#file-game-hs-L43
10:01:15 <Eduard_Munteanu> tomejaguar, shachaf: hm, yeah, my statement is too strong. I was thinking type constructors are injective, so you get something close to limit preservation: for any A x B and F, there's a u : F (A x B) -> F A x F B, such that u F preserves limits.
10:01:44 <vamega> If I've got a list of [IO String], how would I go about printing all the strings on seperate newlines.
10:02:09 <vamega> I'm guessing something like mapM_ putStrLn filelist
10:02:18 <c_wraith> you'll need to sequence the list first
10:02:30 <c_wraith> sequence fileList >>= mapM_ putStrLn
10:02:44 <Eduard_Munteanu> Anyway my idea was F () is "almost always" isomorphic to ().
10:03:21 <vamega> c_wraith - Thanks. the type signature of that is interesting.
10:03:52 <c_wraith> in this case, sequence :: [IO String] -> IO [String]
10:03:53 <tomejaguar> Eduard_Munteanu: I can't think of any functors where that's true, apart from Identity :)
10:04:39 <quchen> vamega: 'sequence' written in symbolic do-notation: https://github.com/quchen/articles/blob/master/functions_comprehensible.md#sequencemapm
10:04:51 <quchen> That's how I learned to understand it.
10:04:57 <mr-> Eduard_Munteanu: note that that map comes from the universal property of the limit and has nothing to do with any of Hasks properties..
10:05:57 <Eduard_Munteanu> mr-: it's not the same because u's domain isn't really a limit, like tomejaguar pointed out
10:06:26 <Eduard_Munteanu> You don't get the product commutative diagram.
10:06:32 <vamega> Yeah, I just read the source of sequence and now it makes complete sense.
10:07:25 <Eduard_Munteanu> tomejaguar: bah, nevermind, that was a stupid thing to say
10:08:11 * Eduard_Munteanu isn't sure what he had in mind.
10:08:23 <jesyspa> Is it me, or is the f in the foldl example missing a flip somewhere?
10:09:28 <quchen> jesyspa: Which example?
10:09:35 <quchen> (Assuming you're talking about my link)
10:10:02 <jesyspa> quchen: Of foldl f z.  I'd expect it to apply z `f` 1, but your example shows it as 1 `f` z.
10:10:16 <jesyspa> (In the graphical version.)
10:10:46 <quchen> jesyspa: Oh, the graphical version just says "these two are somehow fed to 'f' in no particular order".
10:11:05 <jesyspa> Ah, okay.
10:11:09 <quchen> I think the graph used to be flipped (the way that you argue would be better), but I turned it around so it looks structurally similar to the foldr graph.
10:11:18 <quchen> Maybe I should revert to the mirrored version.
10:11:22 <shachaf> Eduard_Munteanu: I think (r ->) may be the only functor that preserves products.
10:12:34 <Cale> Well, if (r ->) does, then so does Stream
10:13:09 <Cale> Though, that probably doesn't count as separate :)
10:13:11 <tomejaguar> Stream is sort of r ->
10:14:03 <Cale> Hmm, any right adjoint should do
10:14:05 <Eduard_Munteanu> It's the Yoneda embedding, no? That gives y A ~ y B => A ~ B
10:14:14 <skypers> do you think it’s possible to change print in order to make it as print = putStr . show, and add printLn = putStrLn . show
10:14:17 <skypers> ?
10:15:12 <quchen> jesyspa: Updated.
10:15:30 <tomejaguar> skypers: Why do you want to do that?
10:15:37 <Eduard_Munteanu> shachaf: the identity functor preserves products too, no?
10:15:45 <shachaf> Eduard_Munteanu: Yes, Identity = () ->
10:15:45 <Cale> skypers: Well, you can of course import Prelude hiding (print)
10:15:51 <Cale> and then just define it yourself
10:16:00 <shachaf> Just like Identity = ((),), so it preserves sums too!
10:16:18 <Eduard_Munteanu> Oh right, it's not a distinct case.
10:16:35 <Eduard_Munteanu> Yeah, I guess that's what I was thinking of before.
10:17:41 <jesyspa> Yeah, I'd say that looks better.
10:17:45 <Cale> TracedT might provide some more examples...
10:18:07 <tomejaguar> shachaf: Seems like this Identity thing preserves everything!
10:18:14 <shachaf> tomejaguar: Crazy!
10:18:42 <Eduard_Munteanu> Applicatives preserve "everything" FSVO of "everything", as closed functors.
10:18:56 <Cale> Apparently whenever m is left adjoint to w, then WriterT s m is left adjoint to TracedT s w
10:19:13 <shachaf> Sounds plausible.
10:19:24 <shachaf> Since there's only one Functor adjunction, after all.
10:19:57 <quchen> skypers: You could also add "let print = putStr . show" somewhere in your do block. But I suggest you don't re-use the name "print", call it "print'" or something at least.
10:20:24 <skypers> quchen: I meant
10:20:31 <skypers> print as a proposal
10:20:37 <shachaf> Anyway, "does any non-representable Functor preserve products" would be a reasonable version of my previous question.
10:20:38 <skypers> to officially change its meaning
10:20:45 <Eduard_Munteanu> shachaf: hmm... can you even make a category where that adjunction on *endo*functors isn't that trivial?
10:20:47 <Cale> Oh, I guess that doesn't really produce many more examples
10:20:49 <skypers> because it’s kind of a non-sense for me
10:20:55 <Cale> It's just functions of more arguments
10:21:03 <shachaf> Right.
10:21:04 <quchen> skypers: Oh, nooo. Not worth the effort.
10:21:06 <skypers> we have putStr, putStrLn, read, readLn
10:21:09 <skypers> and print… wait?
10:21:24 <skypers> it’s not about effort, it’s about meaning
10:21:55 <skypers> I think it’s important to expose “standardized” functions
10:22:00 <skypers> isn’t it?
10:22:14 <Cale> skypers: Well, at this point, such a change would be really obnoxious, because it would silently break a lot of things.
10:22:22 <quchen> skypers: I meant the effort to make this change would be too big to standardize. All "print"-using programs would break, and the type system wouldn't help.
10:22:34 <skypers> Cale: yeah well, in a new major version Base release then
10:22:37 <Cale> (You wouldn't expect to get a type error because of using print when you meant printLn)
10:22:39 <skypers> in order not to break everything
10:22:46 <Cale> Well, that'll still break everything.
10:23:14 <skypers> that’s so a pity
10:23:22 <skypers> because we have a nice version system through cabal
10:23:29 <tomejaguar> Many things in software engineering are pities like this.
10:23:32 <skypers> I respect its doctrine
10:23:38 <tomejaguar> Haskell is just the least pity.
10:23:38 <Cale> When people go to update to the new version of base, all the old code will become potentially problematic in a way which won't be caught by the compiler.
10:23:38 <skypers> my programs won’t break
10:23:54 <Cale> So everyone will have to sift through their programs for every use of print
10:24:08 <skypers> Cale: yeah…
10:24:15 <skypers> put once it’s been done
10:24:25 <skypers> we have a _logic_ set of print/putStr functions
10:24:32 <skypers> now it’s just illogical
10:24:45 <shachaf> Right now it's great.
10:24:48 <skypers> don’t you thingk?
10:24:50 <Eduard_Munteanu> shachaf: you could say such functors are representable too, if your Set is Hask.
10:24:50 <skypers> think*
10:24:52 <shachaf> putStr . show is something that I want approdximately never.
10:25:02 <quchen> skypers: There are lots of small "right, but not worth it" changes that you could do to Haskell. If you re-started a new language you would probably do things differently, but changing it in retrospect is not possible.
10:25:02 <skypers> shachaf: I do actually
10:25:03 <simpson> Usually I don't want print; I want traceShow.
10:25:04 <skypers> I do use it
10:25:06 <maurer> Does anyone know if there's a good way to get your current offset in a Put to do aligned writes?
10:25:26 <skypers> seriously?
10:25:38 <skypers> just for a retrocompatibility issue? :(
10:25:47 <Eduard_Munteanu> shachaf: and Hask is even more restrictive since you only have finite limits and parametricity/injectivity prevents you from constructing specific functors like in Set.
10:26:12 <Eduard_Munteanu> More general, rather.
10:26:13 <quchen> skypers: It's a pretty big "just".
10:26:14 <skypers> I mean, if you see you can’t upgrade Base without updating your codebase that uses print, well, just alter those code lines?
10:26:30 <simpson> skypers: Cale's argument is pretty solid: If an upgrade would break people in a way that would not be caught by the compiler...
10:26:43 <Cale> skypers: Well, this is worse than most of the candidates for fixing little warts even, because it's not something that the compiler will help fix.
10:26:43 <skypers> hm
10:26:54 <skypers> yeah
10:26:55 <skypers> you’re right
10:27:00 <skypers> damn that’s such a pity
10:27:04 <shachaf> There's no rule that says that everything that prints a newline has to end in Ln.
10:27:14 <skypers> shachaf: well
10:27:15 <shachaf> It would make the language worse, for the most part.
10:27:21 <skypers> you’re not right imho
10:27:28 <Eduard_Munteanu> BTW, I wonder... is any subcategory of Hask a CCC too?
10:27:31 <Cale> For instance, it would be nice to move abs and signum out of Num, and while that'll likely break lots of code, it'll all be type errors.
10:27:41 <shachaf> Fortunately it doesn't matter because it'll never happen.
10:27:46 <quchen> I vote for taking fail to MonadFail if we're trying to break things.
10:27:53 <Cale> and that too
10:27:55 <shachaf> Eduard_Munteanu: No.
10:28:07 <skypers> yeah, got the point
10:28:23 <skypers> I just think of D
10:28:25 <skypers> D2
10:28:29 <shachaf> maurer: I don't think so.
10:28:31 <tomejaguar> Eduard_Munteanu: the discrete subcategory?
10:28:31 <skypers> they _always_ deprecate a lot of things
10:28:50 <Cale> skypers: I see your point about logical consistency, but I think I actually agree with shachaf here, in that *usually* I want print to put a newline anyway, and I basically would never use the one which didn't put a newline after.
10:28:57 <maurer> shachaf: Hm, so is the proper way for me to do this just to do a StateT Put and keep track of my offset manually then?
10:29:03 <Eduard_Munteanu> tomejaguar: you mean one object, no non-id arrows?
10:29:18 <shachaf> maurer: I don't know. I've never used Put.
10:29:28 <skypers> ok
10:29:29 <Cale> I use putStr almost never as it is, and when I do, it's usually to print a prompt of some sort.
10:29:32 <tomejaguar> Eduard_Munteanu: No I mean all types as objects, no non-id arrows.
10:29:45 <Cale> (rather than showing the Haskell representation of a value)
10:29:46 <skypers> Cale: I use hPutStr on socket handle
10:30:02 <Eduard_Munteanu> Ah.
10:30:05 <quchen> Don't use socket handles :-þ
10:30:10 <Cale> Well, sure, there's that, but again, you're not going to be applying show very often there either.
10:30:12 <skypers> why?
10:30:16 <skypers> they’re nice to deal with
10:30:35 <Cale> I don't see why you shouldn't use socket handles either.
10:30:46 <Cale> They're fine :P
10:30:54 <skypers> I think it’s quite the same thing in a lot of languages
10:30:57 <skypers> like C#
10:30:58 <skypers> or Java
10:31:17 <skypers> with their terrible InputLolStreamFactoryParserBuilder
10:31:23 <skypers> that… kind of… things.
10:31:34 <shachaf> It's not going to happen so it doesn't matter.
10:31:43 <Cale> print is mainly something that you either use as the top level thing in your whole program (i.e. you've written a program which is just computing a value and printing it out), or else for debugging output.
10:31:50 <quchen> Socket handles bit me really hard a couple of weeks ago. To be fair it was mostly in conjunction with lazy IO. On the other hand there are nice packages like network-simple, operating on sockets directly rather than converting them to handles.
10:32:22 <skypers> quchen: well in C, a socket is kinda of a file isn’t it?
10:32:32 * quchen thinks "print" is the "just do it" part of the IO family.
10:32:38 <Cale> quchen: Yeah, the more precise piece of advice is "don't use lazy I/O with socket handles"
10:32:45 <skypers> :)
10:32:49 <Cale> The socket handles themselves are fine
10:33:01 <quchen> Okay okay
10:33:01 <skypers> maybe you just had to disable buffering?
10:33:15 <Cale> It's just you need to be able to close them manually because they're a precious resource for not much good reason.
10:33:48 <skypers> actually, Handle and forkIO is an adorable couple in my programs :)
10:34:10 * Eduard_Munteanu wants MonadBase :(
10:34:14 <Cale> I actually really dislike the way that OS limitations make filehandles into something precious. Why can't I fill my available memory with filehandles?
10:34:53 <Cale> I have 16 GB of memory, why can't I open every file on my disk simultaneously?
10:35:19 <vamega> if I've got a list of IO [String] in ghci
10:35:24 <Eduard_Munteanu> Cale: it slows down stuff indirectly, I think. More than just the memory allocated to them.
10:35:27 <vamega> how can I print that list?
10:35:34 <skypers> Cale: your OS doesn’t allow you to open several ones?
10:35:43 <skypers> vamega: sequence
10:35:44 <shachaf> vamega: You have foo :: [IO [String]]?
10:36:04 <vamega> no I have fielpaths filepaths :: IO [FilePath]
10:36:08 <vamega> sorry filepaths :: IO [FilePath]
10:36:17 <Cale> skypers: There's some ridiculously small limit on the number of open filehandles.
10:36:20 <vamega> I want to print that out one filepath perline.
10:36:36 <tomejaguar> Filehandles are a global resource for one thing.
10:36:38 <tomejaguar> Don't know why that is.
10:36:41 <dainanaki> vamega, you could do: filepaths >>= mapM_ putStrLn
10:36:43 <Eduard_Munteanu> vamega: where does it come from, is it an argument, or something let-bound?
10:37:29 <Cale> Actually, it varies per system what the limit is. In some cases, the number is very small.
10:37:39 <Cale> In others, it's reasonably large, but still arbitrary.
10:38:22 <vamega> dainanaki - Thanks that's what I was looking for
10:38:25 <Cale> So programs typically have to be aware that on some systems, opening a few hundred thousand files is not a good idea.
10:38:30 <vamega> I've currently got it let bound.
10:38:47 <vamega> In the final program it would be an argument.
10:39:24 <skypers> vamega: you have a IO [String], right?
10:39:55 <Cale> vamega: If you have getFilepaths :: IO [String] and you want a [String], just execute the action:  filepaths <- getFilepaths
10:40:03 <Cale> and then filepaths :: [String]
10:40:22 <vamega> yeah, technically IO [Filepath] but that shouldn't be a different
10:40:29 <vamega> Yeah, that's what I'd do in the final program
10:40:38 <Cale> You can do that in ghci as well
10:40:44 <vamega> Oh interesting
10:40:53 <vamega> I didn't realize that worked in GHCI
10:40:53 <vamega> THanks
10:41:20 <vamega> Wow, my mind is blown.......
10:41:33 <joejev> is it faster to read a file as a lazy bytestring or read it using the normal System.IO.readFile
10:41:36 <skypers> you can do that :
10:41:49 <skypers> @let foo :: IO [String]; foo = ["hello","bar"]
10:41:50 <lambdabot>  .L.hs:144:7:
10:41:50 <lambdabot>      Couldn't match expected type `IO [String]'
10:41:50 <lambdabot>                ...
10:42:00 <skypers> le wat
10:42:07 <maurer> skypers: that's not an IO [String]
10:42:09 <maurer> it's a [String]
10:42:15 <skypers> @let foo :: IO [String]; foo = return ["hello","bar"]
10:42:16 <lambdabot>  Defined.
10:42:18 <skypers> sorry.
10:42:29 <skypers> foo >>= mapM_ print
10:42:35 <skypers> > foo >>= mapM_ print
10:42:37 <lambdabot>   <IO ()>
10:42:45 <skypers> hihi
10:42:47 <skypers> :D
10:42:57 <skypers> this is not what I expected
10:43:17 <skypers> it actually works in my ghci session
10:43:22 <sdrodge> Anyone know of a vim plugin that will do vertical alignment of arguments?
10:43:24 <quchen> Cale: My default limit is 1024.
10:43:30 <skypers> do { x <- foo; mapM_ print x }
10:43:32 <levi> lambdabot doesn't do IO actions.
10:43:32 <quchen> Per process I think though.
10:43:36 <skypers> > do { x <- foo; mapM_ print x }
10:43:37 <lambdabot>   <IO ()>
10:43:39 <skypers> ah
10:43:40 <skypers> ok
10:43:56 <skypers> so yeah vamega
10:44:06 <skypers> just use mapM_ print to print themall!
10:45:13 <vamega> Thanks, that's what I've been doing
10:45:25 <vamega> This is throwaway code though.
10:45:30 <vamega> I won't be printing at the end.
10:45:37 <vamega> But thanks everyone for all the explanations.
10:45:40 <vamega> It's been helpful.
10:45:42 <levi> mapM, forM, etc. are your friends.
10:45:44 <skypers> it’s nice to experiment that kind of stuff
10:45:46 <skypers> yeah
10:45:51 <skypers> traverse too
10:46:47 <skypers> btw, lambdabot doesn’t execute IO because of security interests?
10:46:57 <skypers> like, making it creating stuff
10:47:03 <levi> I think that was the reason.
10:47:14 <skypers> well, one can just limit it to print?
10:47:15 <mr-> Eduard_Munteanu: yes, the domain is not the limit, but it maps to the limit by the universal property
10:48:12 <tac> skypers: IO is completely free to do whatever it wants in the runtime. It wouldn't make any sense to execute IO commands on IRC.
10:48:46 <tac> I suppose you could hide all non-print IO commands, but why would you just want print?
10:49:46 <levi> It would probably be a lot of work.
10:51:05 <tac> It _would_ be cool to have an IRC monad
10:51:18 <tac> That allowed you to do things like poll the channel userlist or the topic and to print
10:51:30 <tac> But cool is still a lot of work :)
10:51:37 <Rembane> tac: But it's worth it. Start now! :D
10:51:45 <skypers> tac: /names actually does a great job :)
10:51:50 <levi> The core of lambdabot is a thin wrapper (called mueval) over the bits of the GHC API that ghci also uses. Since you can't normally inspect IO values in ghci to see what actions they represent, it would be non-trivial to 'just do prints' because how would you tell the prints from other actions?
10:52:21 <maurer> levi: I think he meant bring them out of scope and try building it
10:52:22 <allsystemsarego> Hi all, can someone show the absolute minimum amount of code I have to write in Parsec to get from "1 + 2 * 3 * 4 * 5 + 6" to 127 ? the tutorials I've read use overcomplicated examples that obscure the essence of Parsec, IMO
10:52:46 <maurer> levi: With the notion being that it builds without any IO values other than print in scope "should" be safe
10:52:48 <tromp__> \_->127
10:53:15 <FreeFull> const$127
10:53:25 <FreeFull> \_-> is shorter
10:53:32 <FreeFull> Looks sort of like a reclined chair
10:54:04 <tromp__> like a recumbent with windshield
10:54:13 <skypers> @pl \_ -> 127
10:54:13 <lambdabot> const 127
10:54:17 <dainanaki> asking Haskellers for the absolute minimum required to do something is always bound to get interesting responses.
10:54:28 <skypers> my dainanaki?
10:54:36 <allsystemsarego> oh well, forget it then
10:54:42 <tromp__> Kolmogorov complexity R us
10:54:52 <dainanaki> skypers, what?
10:54:59 <skypers> nvm.
10:55:06 <levi> maurer: That might work, but I'm not familiar enough with mueval guts to say one way or another.
10:55:10 <skypers> gotta go, see you
10:55:21 <maurer> levi: Nor am I, I'm just trying to suggest that it's feasible without inspection of IO values
10:55:24 <dainanaki> allsystemsarego, what tutorial are you currently using.
10:55:44 <allsystemsarego> dainanaki, http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements
10:56:08 <deweyvm> when i run haddock im getting the error "setup: The program hscolour version >=1.8 is required but it could not be found." yet i have version 1.20 installed. 20 > 8 right?
10:57:17 <tromp__> > 20>8
10:57:17 <lambdabot>   True
10:57:34 <dainanaki> allsystemsarego, are you looking for something more like this? http://meta-meta.blogspot.com/2007/10/simple-infix-calculator-in-haskell.html
10:58:07 <monochrom> allsystemsarego: something like this (untried): chainl1 (chainl1 num times) plus. plus = char '+' >> return (+). similarly times. you define num. this doesn't allow spaces yet, I'm too lazy to do that. I am also the author of Parsing_expressions_and_statements
10:58:10 <deweyvm> i dont understand why it isnt detected
10:58:30 <dainanaki> allsystemsarego: That's a little old, so you might have to update the imports for Parsec
10:59:00 <dmwit_> Does Mark Wotton hang around here? What nick does he use?
10:59:04 <shachaf> blackdog
10:59:10 <dmwit> thanks
10:59:17 <monochrom> in fact, chainl1 haddock has an example too
10:59:25 <allsystemsarego> monochrom, dainanaki thanks for the hints, I will look into those things
10:59:31 <dmwit> ?ask blackdog Did you manage to fix https://gist.github.com/mwotton/7417945? Do you remember how?
10:59:31 <lambdabot> Consider it noted.
10:59:34 <shachaf> He is online but not in this channel.
11:00:04 <monochrom> Parsing_expressions_and_statements is in fact meant for those people who dislike simple examples
11:00:43 <maurer> @pl \(f, g) x -> (f x, g x)
11:00:43 <lambdabot> uncurry (liftM2 (,))
11:00:58 <maurer> Hm. I thought htere was a short name for that function
11:01:18 <scott_> @pl \f g x -> (f x, g x)
11:01:18 <lambdabot> liftM2 (,)
11:01:49 <allsystemsarego> @ty (***)
11:01:50 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
11:01:53 <shachaf> :t (&&&)
11:01:53 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
11:02:05 <levi> The SafeHaskell manual talks about building restricted IO monads, if anyone wanted to try extending mueval that way.
11:02:19 <maurer> Ah, &&& is what I ws thinking of
11:02:35 * maurer gratuitously adds Control.Arrow to a project
11:02:51 <scott_> I expected @pl to use &&&... did I do something wrong, or does it not use it?
11:03:00 <tomejaguar> Control.Arrow is great.
11:03:11 <shachaf> Control.Arrow is the devil.
11:03:22 <shachaf> Just hold your nose and pretend it says (a ~ (->))
11:03:23 <tomejaguar> I bow before the devil.
11:03:24 <dmwit> Control.Arrow is a tool.
11:03:31 <tomejaguar> Arrows are great.
11:04:38 <simpson> Every time I see an Arrow, I still have to go back and read the signatures several times, assuming that the Arrow is (->), before I can get it through my head. :c
11:05:10 <maurer> I mean, in my case the arrow is ->
11:05:13 <monochrom> perhaps the prefix notation "a b c" is the hurdle
11:06:06 <shachaf> @yarrow
11:06:06 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
11:06:11 <psc_> hi is there an (easy) intruduction in to monads without  too much math like stuff ?
11:06:11 <shachaf> @arrow
11:06:11 <lambdabot> Avast!
11:06:40 * simpson recalls once seeing Arrow (~>) => b ~> c -> b ~> c' -> b ~> (c, c')
11:06:50 <tomejaguar> simpson: That's much nicer.
11:06:54 <tomejaguar> I think it's not Haskell98 though.
11:07:04 <shachaf> It's not GHC either. It was taken out. So it goes.
11:07:06 <simpson> Probably not! Also it's not *that* distinctive visually.
11:07:12 <tomejaguar> I use 'arr a b -> arr a c -> arr a (b, c)" personally'
11:07:36 <maurer> Clearly we should just use agda-style syntax
11:07:54 <simpson> I think that my big problem was that, when I learned Arrows, the only interesting Arrows in Hask were Kleisli and (->).
11:08:12 <monochrom> yes, psc_, http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#marktoberdorf
11:08:55 <tomejaguar> simpson: And now we have Arrowised FRP, yay!
11:09:12 <psc_> @ monochrom  thanks  now I have some good nigth lecture :)
11:09:18 <simpson> tomejaguar: Right, which has Arrows that are not quite so trivial and make my head stretch slightly.
11:11:37 <monochrom> if you worry about stretching your head, travel at a high speed, then relativistic compression will cancel the stretch, at least from my perspective :)
11:12:32 <simpson> My bosses told me that about my new job; "your life accelerates and never slows down again." However, the only thing I've seen is worse headaches. :3
11:13:33 <monochrom> wait, is your boss an operator at LHC, and are you a particle? :)
11:14:13 <Rembane> Bail out ASAP! :D
11:15:06 <simpson> No, the Big G, actually.
11:15:45 <monochrom> use http://www.despair.com/demotivators.html to counter management type slogans
11:16:33 <monochrom> perhaps we can suggest them to make one with what your boss said, with the picture of a black hole
11:17:40 <simpson> Heh.
11:18:48 <tomejaguar> When you get near a black hole doesn't your life slow down to a standstill?
11:19:13 <posco> tomejaguar: not according to you.
11:19:24 <arkeet> from your perspective, other things would appear faster.
11:19:41 <monochrom> that gets interesting. from the faller's perspective, it's all over after a few hours or something. from an outside observer's perspective, it takes forever.
11:25:28 <Philonous> Is there a comparison of the available test frameworks somewhere?
11:27:13 <levi> There's not a comprehensive comparison that I'm aware of, but I've looked at a few of them recently.
11:27:25 <Philonous> And to what conclusion did you come?
11:28:37 <levi> The frameworks are mostly wrappers around the same core test libraries (HUnit, QuickCheck, SmallCheck) and the differences between the frameworks aren't huge.
11:29:03 <Philonous> Ah, good. Was there one you particularly liked?
11:29:47 <levi> I ended up using Tasty
11:30:44 <levi> So far, I have only written some tests using HSpec, and Tasty runs them.
11:30:53 <Philonous> OK, fair enough, Thanks
11:32:32 <levi> But HSpec is mostly a wrapper around HUnit and the *Check libraries itself. I will hopefully get some QuickCheck tests written soon, though.
11:33:15 <Philonous> Ah, so you can run hspec tests in tasty.
11:33:28 <levi> I also liked the idea of the doctest framework, which extracts tests from Haddock comments.
11:35:01 <lasticot> Is there a function that would behave in a similar way as insertBy but would not insert duplicates?
11:35:36 <levi> It both encourages you to put examples in your haddocks and also ensures that the examples stay correct.
11:35:49 <Philonous> I can see the appeal of this, but I think that could quickly get out of hand.
11:36:37 <levi> It may make sense for some projects and not for others.
11:37:33 <dtruby> What's the best way to do search and replace on a file? Atm I'm doing this: http://hastebin.com/qesapibiba.hs but I'm sure that can't be the best way..
11:37:35 <levi> It's all very flexible and mix/match.
11:38:07 * hackagebot cabal2nix 1.56 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.56 (PeterSimons)
11:40:22 <jchee> Philonous: it's possible to add doctests that aren't displayed in the haddock
11:40:48 <dmwit> dtruby: sed -i ;-)
11:41:26 <jle`> s/b 11
11:44:14 <socket> Hello, I got a few questions about computability (turing machines) .. anyone free?
11:44:50 <Cale> socket: Generally if you ask first, there will be more interest
11:45:10 <c_wraith> It's not exactly on-topic for this channel, but it's probably fine anyway.
11:45:16 <Cale> (It's hard to know whether you can help if you don't know exactly what the question is)
11:45:20 <allsystemsarego> @hoogle Integer-> ReadP Integer
11:45:21 <lambdabot> Text.ParserCombinators.ReadP option :: a -> ReadP a -> ReadP a
11:45:21 <lambdabot> Prelude return :: Monad m => a -> m a
11:45:21 <lambdabot> Control.Monad return :: Monad m => a -> m a
11:45:30 <Philonous> It seems there is glue code for basically any combination of test frameworks
11:45:32 <Cale> Yeah, you might get Haskell-flavoured answers here
11:45:38 <dtruby> I got it working using the System.FilePath.Manip package, which it seems does exactly what I was doing but safer :-P
11:46:21 <socket> ok, given this problem "Given a TM <M> is it true that <M> stops on all inputs" - is the problem decidable/semi-decidable/coRE ; pretty sure it's not decidable..
11:47:17 <ReinH> socket: where <M> is a specific machine?
11:47:23 <c_wraith> what does semi-decidable mean?
11:47:50 <c_wraith> If it means "you can sometimes answer, but other times say 'I don't know'", that would be the one.
11:47:50 <Eduard_Munteanu> Hrm, how do you  import Prelude ([])   ? It says Prelude doesn't export GHC.Types.[].
11:47:54 <socket> yes ReinH, c_wraith recursibly enumerable
11:48:20 <tomejaguar> a set is semi-decidable means there's a computable function which halts when the input is a member of the set
11:48:28 <Saizan> c_wraith: semi-decidable usually means you must answer yes when true, but you can diverge when false
11:48:36 <ReinH> It's trivially true when the machine has the states Q = {HALT}
11:48:46 <ReinH> Perhaps you can be more explicit in what you are asking?
11:49:09 <dmwit> Seems pretty explicit to me.
11:49:17 <dmwit> M is the input. Output is a boolean.
11:49:40 <ReinH> For any M? How is this distinct from the halting problem?
11:49:55 <tomejaguar> It is the halting problem.
11:49:55 <dmwit> The halting problem asks about a specific start tape.
11:49:56 <c_wraith> I'm pretty sure it is the halting problem.
11:50:27 <c_wraith> dmwit: oh, right. It is different in that way.
11:50:30 <socket> it's not exactly the halting problem
11:50:35 <c_wraith> It's a slightly more general halting problem!
11:50:38 <tomejaguar> It's trivially reducible to the halting problem by prefilling the start tape.
11:50:40 <levi> Philonous: If you want to start simply, you can just have 'cabal test' run a test program that executes a bunch of HUnit tests in sequence.
11:50:50 <Feuerbach_> Eduard_Munteanu: [] is a syntax, you can't import it
11:51:02 <dmwit> It's harder than the halting problem, since you have to answer something about *all* inputs instead of just one.
11:51:08 <ReinH> So it's at best undecideable
11:51:16 <c_wraith> harder than undecideable. :)
11:51:22 <ReinH> right
11:51:30 <tomejaguar> At best?  What's worse than undecidable?
11:51:36 <c_wraith> Harder to write partial solutions for, yes.
11:51:40 <ReinH> tomejaguar: mass hysteria?
11:51:42 <Eduard_Munteanu> Feuerbach_: hm, I thought it would be defined in some magic way. Does it bind to some other name, like List?
11:51:57 <ReinH> tomejaguar: well, let me look up my complexity classes again...
11:51:57 <Feuerbach_> Eduard_Munteanu: no
11:52:14 <Eduard_Munteanu> So how do I get lists when NoImplicitPrelude?
11:52:40 <Feuerbach_> since it's a syntax, it's always available. It doesn't come from Prelude
11:52:40 <c_wraith> did you try importing Data.List?
11:52:57 <Eduard_Munteanu> c_wraith: no, but I don't want to import it all
11:53:23 <lasticot> Is it possible to write anonymous function using guard?
11:53:35 <jle`> Eduard_Munteanu: Feuerbach_'s claim checks out
11:53:57 <c_wraith> lasticot: lambdas can only have a single clause, if that's what you're asking.
11:54:08 <Eduard_Munteanu> Yeah, lemme solve my other errors first, it should work without imports.
11:54:15 <lasticot> yes thank you
11:54:24 <ReinH> c_wraith: They could use the \case extension?
11:55:01 <ReinH> Seems like giving it a binding would be better though
11:55:50 <lasticot> ok ok
11:56:17 <jle`> lasticot: try it out with Lambda-case and see if it works.  but i would still recommend giving it a name
11:56:54 <c_wraith> I forgot lambda-case exists. Which is amazing, since it was something I wanted so much when I started using the language.
11:57:20 <lasticot> jle`:  My question was aiming at understanding the compilation error I received, but thank you
11:58:08 * hackagebot bytestring-builder 0.10.4.0.1 - The new bytestring builder, packaged outside of GHC  http://hackage.haskell.org/package/bytestring-builder-0.10.4.0.1 (LeonSmith)
11:59:01 <Eduard_Munteanu> Thanks, it works.
11:59:34 <lasticot> jle`, c_wraith, ReinH: it is just that it seemed silly to name function that was just preventing insertBy to insert already existing values
12:00:19 <jle`> lasticot: are you sure you need a guard?
12:03:26 <ReinH> lasticot: if it's trivial it probably doesn't need a guard...
12:03:43 <ReinH> if it's not trivial it could probably benefit from a name :)
12:03:57 <ReinH> naming stuff is free btw :)
12:04:34 <lasticot> jle`: the short answer is no, I haven't find any function that was doing that moreover it is not exact duplicate: http://lpaste.net/96492
12:04:51 <triliyn> lasticot: if you're worried about polluting your top-level namespace, you can name it in a where clause
12:04:54 <quchen> c_wraith: Also MultiWayIf while we're at simple-yet-neat extensions
12:05:09 <lasticot> ReinH: I understand what you say :-)
12:05:15 <quchen> I have an ongoing battle with myself whether to compile GHC with a couple of extensions enabled by default. :-)
12:05:50 <ReinH> lasticot: beware of the complexity there...
12:05:55 <lasticot> triliyn: it is already in a where clause anyway it was just a matter of improving my point free skills and also naming is annoying
12:06:47 <cswords> Is there a way to add type constraints to a type instance function?
12:06:55 <cswords> type instance Eout SE (PCon Pred a) a1 = a1
12:06:58 <ReinH> lasticot: iinm it's going to be O(n^2), where if you replace your xs list of tuples with some sort of map you could get it back down to O(n) or O(n log n)
12:07:00 <cswords> I would like to wrote
12:07:10 <cswords> type instance (a ~ a1) => Eout SE (PCon Pred a) a1 = a1
12:08:38 <cswords> And Haskell is telling me that is invalid syntax
12:08:45 <cswords> So is it possible to add that constraint?
12:09:16 <lasticot> ReinH: I am sorry I don't understand the solution you are hinting :-(
12:09:37 <ReinH> lasticot: xs is a [(key, value)] list?
12:10:59 <lasticot> ReinH: no it is rather a [(idx, value)] list, idx represent the cell in which the char will later be printed
12:11:16 <lasticot> sorry the value is a char
12:11:53 <cswords> lasticot: his point is that you could use a hash map for fast look-up.
12:12:51 <lasticot> alright it doesn't really matter then because I am gonna consume the list from head to tail later
12:13:09 * hackagebot indian-language-font-converter 0.1 - Indian Language Font Converter  http://hackage.haskell.org/package/indian-language-font-converter-0.1 (AkashJagdhane)
12:15:58 <lasticot> sorry you meant for the elem part right?
12:17:04 <cswords> So no answer to type constraints?
12:23:10 * hackagebot indian-language-font-converter 0.2 - Indian Language Font Converter  http://hackage.haskell.org/package/indian-language-font-converter-0.2 (AkashJagdhane)
12:24:29 <joehillen> anyone have any idea what's going on here? http://lpaste.net/96495
12:24:47 <joehillen> I know never little about how ld works
12:25:20 <Cale> joehillen: Well, that's interesting
12:25:31 <Cale> How do you have GHC but not libgmp?
12:25:53 <Cale> joehillen: Which OS?
12:25:58 <joehillen> Ubuntu
12:26:11 <joehillen> I build ghc from source, so that's possible
12:26:16 <Clint> apt-get install gitit
12:26:33 <Cale> apt-get install libgmp3c2
12:26:36 <joehillen> no, I'm actually modifying it
12:26:39 <Cale> and libgmp3-dev
12:26:39 <Clint> he needs the -dev
12:26:54 <janua> Is it possible to have IO actions inside a function which is supplied to iterate?
12:27:06 <Cale> janua: sure
12:27:11 <joehillen> ah, I uninstalled the ghc package when I build ghc and the gmp package must have been autoremoved since it was an unused dependancy
12:27:26 <Clint> joehillen: libgmp-dev
12:27:28 <Cale> janua: You can construct an IO action recursively
12:27:47 <joehillen> Clint && Cale: that worked, thanks
12:27:54 <Cale> janua: Or using various other higher-order functions like forM
12:28:08 <janua> Cale: How would I do it, if my starting value is not inside IO?
12:28:25 <Cale> forM [1..10] $ \n -> print n
12:28:41 <skypers> how can I ghc compile something like perl -e?
12:28:42 <skypers> like
12:28:51 <skypers> ghc -e sum [1..10]
12:28:57 <Rylee> skypers, ghc -e 'sum [1..10]'
12:29:02 <skypers> oh nice
12:29:02 <Cale> foo 0 = return (); foo n = do print n; foo (n-1)
12:29:03 <skypers> thank you
12:29:51 <janua> Cale: Are you saying that I shouldn't be using iterate?
12:30:11 <Cale> :t iterate
12:30:12 <skypers> arf
12:30:12 <lambdabot> (a -> a) -> a -> [a]
12:30:16 <skypers> skypers@ark ~ % time ghci -e 'sum [1..10]'
12:30:17 <skypers> ghc: on the commandline: cannot use `--interactive' with `-e'
12:30:19 <skypers> :(
12:30:23 <skypers> oh ghci
12:30:27 <skypers> I’m an idiot
12:30:50 <Cale> iterate won't do anything itself with regard to IO
12:31:05 <Cale> You could use iterate to produce a list of IO actions, which you then apply something like sequence to
12:31:17 <Cale> But it depends on what you're after
12:31:32 <janua> Cale: yes that would do, but i don't know how I wrap my value in IO if the function is returning and wrapping
12:31:40 <skypers> is it possible to import things in -e ?
12:31:53 <skypers> yeah it is
12:31:54 <skypers> nice
12:31:55 <Cale> skypers: yes
12:32:32 <skypers> hm
12:32:34 <Cale> janua: Don't think of IO as wrapping anything.
12:32:36 <skypers> doesn’t work
12:33:07 <Cale> janua: An IO action of type IO t is a description of something which could be done to produce a value of type t
12:33:08 <skypers> skypers@ark ~ % ghc -e "import System.Info; os"
12:33:11 <janua> Cale: Ok, how do I get a into IO if the function is returning (a -> IO a)
12:33:12 <skypers> I don’t get anything
12:33:34 <socket> given two TM's is it possible to know if L(M1) intersects L(M2) - not decidable but could it be semi decidable?
12:33:52 <Cale> If you want to make an IO action which does nothing but produces a given value as its result, then you can use return :: a -> IO a
12:33:59 <skypers> nvm
12:34:29 <Cale> socket: Sure it's semidecidable
12:34:39 <janua> Cale: This is what I have, but I start off with a, not IO a
12:34:55 <Cale> janua: I'm not sure I understand what you're trying to do
12:36:10 <Cale> socket: Enumerate all strings, and step the Turing machines forward one step at a time in a big diagonalisation.
12:36:28 <Cale> socket: If the languages they accept overlap, then eventually you'll discover this.
12:37:33 <skypers> http://lpaste.net/96496 << a little poor benchmark, but still!
12:37:35 <Cale> (sorry if that description of what to do is too vague)
12:37:41 <skypers> is there a sum'?
12:38:05 <Cale> skypers: no, but there is -O
12:39:21 <socket> thanks Cale
12:41:28 <Eduard_Munteanu> Is there a way to make 'many' as fast as 'takeWhile' in attoparsec? I have a takeTill (\c -> c == '\\' || ...) but other parsers already match that.
12:41:31 <Cale> skypers: If I compile them both with -O2, then the performance is identical.
12:41:49 <Cale> (probably the same with -O, but I didn't try that)
12:42:25 <Cale> yes, even just with -O
12:42:32 <Cale> This is because of strictness analysis
12:42:42 <Eduard_Munteanu> So I'd like to do something like  many (foo <|> bar <|> anyChar)
12:42:48 <khyperia> is there no iterateM function, (a -> m a) -> a -> m [a]?
12:43:02 <Cale> khyperia: I think there is on hackage
12:43:12 * hackagebot gitignore 1.0.0 - Apply GitHub .gitignore templates to already existing repositories.  http://hackage.haskell.org/package/gitignore-1.0.0 (RickyElrod)
12:43:16 <opqdonut> khyperia: note that with a strict monad it won't terminate
12:43:18 <Eduard_Munteanu> That monad-loop package I think.
12:43:28 <Cale> http://hackage.haskell.org/package/monad-loops-0.4.2/docs/Control-Monad-Loops.html
12:43:41 <Cale> There's iterateUntilM
12:43:41 <khyperia> Right, thanks
12:44:30 <Cale> But usually I tend to just write the loop I need, because there are so many minor variations.
12:45:26 <skypers> :o :o
12:45:40 <skypers> the version with sum is faster than the version with foldl' (+) 0 with -O2
12:45:42 <skypers> why?!
12:45:51 <bennofs> @src sum
12:45:51 <lambdabot> sum = foldl (+) 0
12:46:08 <Eduard_Munteanu> skypers: sum might do fusion
12:46:08 <skypers> woh
12:46:10 <scott_> (Note lambdabot's @src isn't what's actually in GHC)
12:46:16 <opqdonut> are the types the same?
12:46:16 <skypers> fusion?
12:46:20 <nisstyre> I was just going to say that
12:46:24 <skypers> yes
12:46:41 <Cale> I don't think they're any different
12:46:51 <Cale> Let me see
12:46:52 <Eduard_Munteanu> skypers: aka deforestation / RULES
12:46:53 <skypers> sum [1..10000000] vs. foldl' (+) 0 [1..10000000]
12:46:57 <Cale> I bet they actually produce the same code
12:46:59 <scott_> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-List.html#sum
12:47:02 <skypers> tested with the `time` unix program
12:47:07 <skypers> ok, well
12:47:07 <Saizan> foldl' should fuse too
12:47:09 <Cale> Yeah, time is subject to system noise
12:47:10 <skypers> ./Test  0.20s user 0.00s system 99% cpu 0.205 total
12:47:13 <skypers> for the sum
12:47:14 <skypers> and
12:47:18 <skypers> ./Test  0.22s user 0.00s system 98% cpu 0.219 total
12:47:25 <skypers> for the foldl' (+) 0
12:47:27 <adimit> Question: I know <*> and <$> lift across *one* functor. How can I lift across two without it being ugly? Right now I have (fmap (<*>)) (fmap (fmap pure_function) (functor1)) <*> functor2. This is neihter pretty, nor is it readable.
12:47:39 <opqdonut> skypers: use a bigger test and repeat the input
12:47:42 <Eduard_Munteanu> skypers: not sure that's very accurate, can you run it *a lot* of times?
12:47:50 <opqdonut> skypers: or use something like criterion to autoate this
12:47:53 <opqdonut> *automate
12:48:07 <Cale> adimit: What's the type of the thing you're trying to write?
12:48:19 <hopf> will fusion happen automatically if you don't use the stuff in Data.List.Stream?
12:48:20 <skypers> yeah
12:48:21 <skypers> ./Test  0.21s user 0.00s system 98% cpu 0.216 total
12:48:23 <skypers> with the sum
12:48:29 <skypers> I think it just depends.
12:48:31 <skypers> and varies.
12:48:33 <Cale> (a -> b) -> f (g a) -> f (g b) ?
12:48:41 <Cale> That's fmap . fmap
12:48:57 <Saizan> adimit: (liftA2 . liftA2) f x y -- handy for binary functions
12:49:03 <adimit> Cale: except the pure function is (a -> b -> c)
12:49:09 <adimit> Saizan: ah, nice.
12:49:11 <Cale> yeah, and I was going to say, it also works with liftAn/liftMn
12:49:59 <Eduard_Munteanu> Even so, you can have special rules like  sum (enumFromTo a b) = <nicer way to compute actual sums, especially those involving machine integer types>
12:50:09 <Cale> If you find yourself writing a lot of code with the same composition of functors, you might want to define a newtype and make it an instance of Applicative
12:50:26 <simpson> adimit: What are the Functors here, BTW?
12:50:32 <adimit> Cale, that is also very nice, yes.
12:50:44 <Eduard_Munteanu> e.g. using the n(n+1)/2 formula :)
12:50:55 <adimit> simpson: the functors are both of the form Monad Reader m r => m (Maybe a)
12:51:04 <adimit> MonadReader, even.
12:51:20 <adimit> i.e. a value wrapped in Maybe wrapped in a reader monad.
12:51:54 <Cale> (or use http://hackage.haskell.org/package/transformers-0.3.0.0/docs/Data-Functor-Compose.html)
12:54:44 <Cale> But I tend to find that any case where you have a monad or other sort of abstraction of that sort (Applicative/Arrow/etc.) which you're going to use over any sizeable amount of code, it's almost always a better idea to newtype things and abstract over the construction.
12:55:47 <adimit> Cale: "the composition of monads is not always a monad." That's probably ok in my case (my reader monad won't barf,) but I'm a bit confused. Does it mean that if I collapse two monads m1, m2 with Compose, the resulting Compose m1 m2 won't necessarily be a proper monad? (It doesn't have the Monad instance, so I assume so.)
12:55:47 <Cale> I tend to hate bare monad transformers showing up all over the place.
12:55:57 <Cale> Right.
12:56:22 <adimit> Cale, I agree. In this case, I was just writing tests using hspec, and needed something to test some functions in a non-principled way.
12:56:55 <adimit> though as I write more code with that API, I might actually go the newtype route.
12:57:23 <Cale> If you have two monads, say T and S, and you try to compose them, when it comes to writing join, you'll need to provide join :: T (S (T (S a))) -> T (S a)
12:57:34 <Cale> and you only have T (T a) -> T a, and S (S a) -> S a
12:58:15 <adimit> right! But that does mean that I *could* actually write a compose for two monads, but I'd have to think about join.
12:58:29 <Cale> yeah, if you can provide this
12:58:47 <mazzHaskell> Hi! I Just installed ghc Haskell and Leksah on a Mac (10.6.8). The installation seems to look fine, but when i try to start the "Hello World" example, i get "src/Main.hs:23:16: parse error on input '$'. this is line 23: allPass <- $quickCheckAll. So now i wonder - what is wrong? any hint would be wonderful.
12:58:48 <Cale> One approach to add in the missing piece is to throw in a "distributive law" of type  dist :: S (T a) -> T (S a)
12:59:06 <Cale> and then join = fmap join . join . fmap dist
12:59:27 <davorb> mazzHaskell: how did you install it?
12:59:44 <Cale> i.e. you go  T (S (T (S a))) -> T (T (S (S a))), and then use the joins for T and S
12:59:53 <Philonous> mazzHaskell, Try adding {-# LANGUAGE TemplateHaskell #-} to the top of your file
13:00:02 <Cale> and in order for that to result in a proper monad, it has to satisfy some laws
13:01:18 <haskeller123> Is it okay if I post a link to a stackoverflow question I have?
13:01:26 <Cale> haskeller123: sure
13:01:30 <haskeller123> http://stackoverflow.com/questions/20337611/haskell-netwire-type-errors
13:01:57 <Cale> haskeller123: (Just so long as you don't expect me to respond to it there instead of here ;)
13:02:17 <Cale> okay, what do you mean by "doesn't work"
13:02:28 <adimit> Cale: that dist thing is not exactly trivial, is it? In some monad stacks it should be pretty hard to write it, esp. with a nested IO.
13:02:30 <Cale> Do you get a type error? Does the program run and do nothing?
13:02:45 <Cale> adimit: Absolutely.
13:02:53 <adimit> Maybe (IO a) is quite distinct from IO (Maybe a)
13:03:03 <Cale> adimit: In general, it's impossible.
13:03:18 <Eelis> does this comment about Haswell and STM reflect current thinking about hardware acceleration of GHC's STM?: http://www.reddit.com/r/programming/comments/pfnkx/intel_details_hardware_transactional_memory/c3p4oq7
13:03:20 <adimit> and that's why you can't write a general compose instance for monad composition.
13:03:27 <Cale> Especially when you throw in the laws which I failed to spell out.
13:03:28 <adimit> Cale, thanks a lot for your explanations :-)
13:04:22 <Cale> Eelis: looks completely reasonable, unless Haswell has changed.
13:04:58 <Eelis> Cale: i was hoping for a miracle, like hastor's comment in the same thread :)
13:05:08 <haskeller123> Cale: posted error on the page
13:05:19 <ReinH> Cale: Is that distributive or commutative? I can never decide.
13:05:47 <ReinH> Cale: Are you talking about a trace monoid in the category of endofunctors? ;)
13:06:01 <Cale> haskeller123: Well, the GHC error is telling you that the type you provided for forYeah is more polymorphic than the implementation you gave
13:06:18 <Cale> haskeller123: It's telling you that 'b' is supposed to be String (or [Char] which is the same)
13:06:25 <mazzHaskell> davorb, Philonous: Thank you! First i had to install the Unix tools from XCode and then i was able to install the Haskell Platform 2013.2.0.0 64 bit. After that i installed Leksah. Everthing was one of these macintosh dmg files.
13:06:36 <ReinH> Cale: i.e. where there is some equivalence relationship where for some S, T. S (T a) = T (S a) that forms the trace
13:07:05 <davorb> mazzHaskell: so pilo's fix worked?
13:07:23 <Kron> > length
13:07:24 <Cale> ReinH: Well, it's a sort of thing which is commuting the functors, but the reason for it being called a distributive law has to do with specific examples.
13:07:24 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
13:07:24 <lambdabot>    arising from a use ...
13:07:32 <Kron> hmmm
13:07:39 <Cale> :t length
13:07:40 <lambdabot> [a] -> Int
13:07:44 <Cale> > length [1,2,3]
13:07:45 <lambdabot>   3
13:07:52 <kakos> Is it possible to define a GADT over several modules?
13:08:21 <ReinH> Cale: oh ok :) Is there anything to the trace monoid idea?
13:09:36 <Cale> ReinH: There might be some sort of connection or generalisation available, but I don't have a snappy answer.
13:09:50 <ReinH> Cale: ok :)
13:10:00 <ReinH> Cale: No googleable papers this time? :p
13:11:13 <ReinH> Cale: do you have any handy examples of monads that distribute in this way?
13:11:20 <Cale> ReinH: At first I was thinking you were referring to traced monoidal categories, but those are another thing altogether :D
13:11:45 <Philonous> ReinH, Identity with anything?
13:11:57 <ReinH> Cale: Ah, a "trace monoid" in this sense is a monoid with an equivalence relationship that defines a commutative subset
13:12:09 <Cale> yeah
13:12:16 <ReinH> So given that we aren't talking about monoids in Set, perhaps there isn't too much to say
13:12:32 <ReinH> I'm still hand waving here :)
13:13:06 <mazzHaskell> davorb, Philonous: Thanks, yes this eats the error, but jumps to  "lexical error at character 'i'. In this line, there is #ifndef MAIN_FUNCTION
13:13:16 <Cale> Well, the canonical example is the monad for monoids distributing over the monad for Abelian groups
13:13:23 <Cale> whose composite gives the monad for rings
13:13:41 <ReinH> Well that makes sense.
13:13:48 <Philonous> mazzHaskell, {-# LANGUAGE CPP #-} should take care of that
13:14:00 <Cale> (The monad for monoids being a highbrow name for the list monad)
13:14:04 <Philonous> mazzHaskell, That's some weird hello world example, though
13:15:04 <haskeller123> http://stackoverflow.com/questions/20337611/haskell-netwire-type-errors
13:16:07 <Cale> haskeller123: Try   forYeah :: (HasTime Integer s) => Wire s () Identity a String
13:16:21 <Cale> haskeller123: Or delete the type signature, and see what type ghci infers
13:16:49 <haskeller123> Cale: When I have no type signature, ghci fails with a long error
13:17:04 <Cale> hm, well, it might be ambiguous in some way, I suppose.
13:17:11 <Cale> I'm not very familiar with netwire.
13:17:15 <ReinH> Cale: does that also mean that the free monoid on an abelian group is a ring?
13:17:48 <Cale> The free abelian group on a monoid is a ring.
13:18:00 <ReinH> ah right
13:18:25 <Cale> (called the group ring Z[G], where G is the name of the group, and Z refers to the integers)
13:18:41 <ReinH> gotcha
13:18:43 <ReinH> thanks
13:18:46 <Cale> er, sorry, G is the name of the monoid, I suppose :)
13:18:56 <Cale> If G is a group, it's called a group ring :)
13:19:02 <mazzHaskell> Philonous: Thanks again - And yes it is weird. I have to check some things, but ... yes .. this is ... ja.
13:19:14 <Cale> (arbitrary monoid rings are less studied)
13:19:15 <ReinH> Cale: I'm still working my way through the free monad monad monad algebra :) I think I've figured out that the free monoid monad monad algebra is [].
13:19:43 <Cale> Oh, well, a list-algebra is a monoid, is the way I'd say it.
13:20:10 <Cale> You have some type A together with eval :: [A] -> A
13:20:11 <ReinH> Right, a []-algebra is a monoid via mconcat
13:20:14 <Cale> yeah
13:20:50 <ReinH> Cale: I think that proving that is equivalent to proving that it is a monad algebra?
13:20:54 <Cale> and the laws for a T-algebra together with the definitions for join and return encode the monoid laws
13:21:05 <ReinH> right
13:21:40 <orzo> I'm intending to use the FFI to call out to c code that installs an atexit handler.  Is that kosher?
13:22:22 <ReinH> Cale: the commitativity diagram is eval . join = eval . fmap eval, eval . return = id right?
13:22:37 <geekosaur> it should be, with some caveats (atexit handlers will execute after the haskell runtime has been shut down)
13:22:46 <Cale> orzo: Try it? I don't think there's anything to worry about, but maybe it'll mess with ghci in some way.
13:23:10 <raphie> can anyone recommend a really comprehensive Snap tutorial? their getting started gives one code snippet and then says "go read the API docs!" which isn't too helpful
13:23:11 <ReinH> Cale: (for a T-algebra)
13:23:26 <orzo> alright, thanks geekosaur & Cale
13:23:47 <ReinH> Cale: how would I go about proving that for a []-algebra, using mconcat and concat? What type of proof would it be?
13:24:29 <Cale> ReinH: yes
13:24:49 <ReinH> Cale: not really sure where to begin with proofs of this kind
13:24:50 <Cale> ReinH: Proving that an ordinary monoid gives a []-algebra?
13:25:11 <ReinH> Cale: proving that a []-algebra is a T-algebra (that the above laws hold)
13:25:12 <Cale> Or proving that a []-algebra gives a monoid?
13:25:21 <Cale> Uh, it is by definition
13:25:29 <Cale> We're just specialising T = []
13:25:57 <Cale> Those laws are *required* of a []-algebra here
13:26:13 <Cale> It's not enough to provide an arbitrary function [A] -> A
13:26:29 <monochrom> what is a T-algebra? does it just require T to be a functor? a monad?
13:26:35 <Cale> A monad
13:26:47 <monochrom> then [] is already a monad. yeah, done.
13:27:00 <ReinH> Cale: ok, sorry, the question should be: show that a monoid is an []-algebra, specifically a Haskell Monoid with eval = mconcat
13:27:07 <Cale> okay
13:27:08 <Cale> yeah
13:27:14 <Cale> That's a more reasonable thing to want to prove
13:27:18 <ReinH> ok good :)
13:27:24 <monochrom> heh
13:28:01 <Cale> So, you want to prove that  mconcat . fmap mconcat = mconcat . concat
13:28:10 <ReinH> Right, is this structural induction or?
13:28:26 <Cale> yeah, you'll probably just use induction on the structure of the list
13:29:18 <ReinH> So start with [] and prove for x:xs
13:29:47 <Cale> and the asssociativity and identity of the monoid will both end up being used
13:29:54 <ReinH> (mconcat . concat) [] = [] = (mconcat . fmap mconcat) [] -- by definition?
13:30:03 <Cale> So, you'll probably expand the definition of mconcat
13:30:10 <ReinH> ah
13:30:20 <ReinH> so I can get at the x
13:30:43 <Cale> It'll actually be a bit fiddly that way
13:30:49 <ReinH> The base case is trivial right?
13:30:51 <Cale> yeah
13:31:59 <ReinH> @src foldr
13:31:59 <lambdabot> foldr f z []     = z
13:31:59 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:32:16 <ReinH> mconcat = foldr mappend mempty
13:32:24 <Cale> Of course, it would be easier if you had a more holistic formulation of the ordinary monoid laws in terms of mconcat, but that would make it trivial. :D
13:32:31 <ReinH> heh
13:32:36 <Cale> (you'd see that it was exactly this, and be done)
13:33:02 <ReinH> right, mconcat [] = mempty, mconcat [a,b] = mappend a b
13:33:11 <ReinH> would be trivial from that
13:34:39 <Cale> ReinH: oh, well, that's already easy to check
13:34:46 <fryguybob> Eelis: As to your question about STM earlier, I'm working on using Haswell's hardware transactions to speed up GHC's STM in my research.  There are a lot of cases that we think will work out nicely.
13:35:03 <Eelis> fryguybob: oooh, nice! got a link?
13:35:05 <Cale> fryguybob: Oh, interesting :)
13:36:02 <ReinH> fryguybob: ooh :)
13:36:06 <fryguybob> Eelis: Nothing interesting yet, but I'm writing a preliminary paper right now.  I have high hopes for next semester.
13:36:21 <Eelis> fryguybob: cool, i look forward to it
13:36:41 <ReinH> arkeet: ping
13:38:46 <zol> I'd just like a hint, because this is blowing my mind! How would you write a "maximaBy" function? Ex: maximaBy length ["cs", "lth", "efd"] would return ["lth", "efd"]. I can't figure out a way that isn't something in the lines of n^n in complexity.
13:39:53 <ReinH> zol: Are you familiar with the concept of a "schwartzian transform"?
13:40:02 <bennofs> > take 1 . group . sortBy length $ ["abc", "cdef", "ab", "abcd", "ef"]
13:40:02 <zol> ReinH: No
13:40:03 <lambdabot>   Couldn't match type `GHC.Types.Int'
13:40:03 <lambdabot>                with `[GHC.Types.Char] -...
13:40:32 <zol> ReinH: Thanks, googling!
13:40:36 <ReinH> > fmap (length &&& id) ["cs", "lth", "efd"]
13:40:37 <lambdabot>   [(2,"cs"),(3,"lth"),(3,"efd")]
13:40:47 <ReinH> zol: what can you do with this new list in linear time now?
13:41:28 <bennofs> > head . groupBy ((==) `on` length) . sortBy (flip $ comparing length) $ ["abc", "cdef", "ab", "abcd", "ef"]
13:41:29 <lambdabot>   ["cdef","abcd"]
13:41:40 <zol> ReinH: Sort it, reverse it, take until first elements are not equal anymore!
13:42:05 <ReinH> zol: or your typical accumulating fold
13:42:06 <zol> ReinH: Guess it isn't linear anymore then however..
13:42:32 <zol> bennofs: Oh, groupBy I have never used before, thanks
13:45:05 <ReinH> if you want to do it by hand:
13:45:09 <ReinH> > snd $ let f n z = if (fst n) > (fst z) then n else z in foldr f (0,"") $ fmap (length &&& id) ["cs", "lth", "efd"]
13:45:10 <lambdabot>   "efd"
13:45:24 <pmurias> if I avoid suppling some fields to a constructor what are they filled with?
13:45:45 <pmurias> (I'm constructing a QuasiQuoter and I don't want to specify some of the parsers)
13:45:46 <ReinH> zol: ^
13:45:52 <startling> > Just {}
13:45:53 <pmurias> I get a warning from ghc
13:45:53 <lambdabot>   Just *Exception: <interactive>:3:1-7: Missing field in record construction
13:46:12 <levi> pmurias: They don't get filled with anything.
13:46:14 <ReinH> :t Just
13:46:15 <lambdabot> a -> Maybe a
13:46:18 <zol> > :t &&&
13:46:19 <lambdabot>   <hint>:1:1: parse error on input `:'
13:46:25 <zol> :t &&&
13:46:25 <lambdabot> parse error on input `&&&'
13:46:27 <levi> pmurias: You just get an error.
13:46:28 <geekosaur> :t (&&&)
13:46:29 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
13:46:34 <zol> geekosaur: thanks
13:46:38 <startling> Just (error "<interactive>:3:1-7: Missing field in record construction"
13:46:42 <startling> > Just (error "<interactive>:3:1-7: Missing field in record construction")
13:46:43 <lambdabot>   Just *Exception: <interactive>:3:1-7: Missing field in record construction
13:46:50 <ReinH> oh record constructor
13:47:13 <ReinH> zol: f &&& g = \x -> (f x, g x)
13:47:19 <scott_> Why is that a runtime exception?
13:47:25 <startling> pmurias, they get filled with something equivalent to error/undefined.
13:47:33 <zol> ReinH: Aha, cool! Thanks :)
13:47:39 <scott_> Oh, if you don't evaluate those fields, it's fine?
13:47:48 <startling> scott_, sure.
13:48:00 <startling> it's still sort of a bad idea though.
13:48:12 <scott_> Yeah, it doesn't strike me as a good plan
13:48:17 <ReinH> zol: this snd . f . fmap (g &&& id) construction is a schwartzian transform
13:48:20 <startling> I suspect if the Haskell standard were to be rewritten it would be changed.
13:48:36 <ReinH> zol: but generally this will be done for you by, e.g., maximumBy
13:48:44 <pmurias> I don't have a value for them, so I should just supply error?
13:49:16 <ReinH> pmurias: then your record should probably contain Maybe values
13:49:25 <levi> pmurias: If it's semantically valid for a field to have no value, it should probably be a Maybe instead.
13:49:30 <levi> Bah, too slow.
13:49:34 <ReinH> levi: :)
13:49:58 <pmurias> ReinH: that's not a valid option
13:50:13 <geekosaur> huh?
13:50:17 <ReinH> pmurias: It is generally
13:50:28 <ReinH> pmurias: you might want to explain why you don't think it's a valid option.
13:50:42 <pmurias> I can't change the code I'm passing the record to
13:50:56 <startling> pmurias: what type does the field need to have?
13:51:21 <ReinH> Is it, e.g., a Monoid or something else that provides an empty value?
13:51:34 <zol> ReinH: Thanks!
13:51:37 <ReinH> zol: np :)
13:51:41 <pmurias> startling: a function
13:51:49 <augur_> <*> sequences effects left to right; is there a version that sequences right to left?
13:51:50 <byorgey> ReinH: pmurias already said it is a QuasiQuoter.
13:51:59 <pmurias> startling: which will never be called, and I'm not willing to write
13:52:05 <startling> pmurias, heh
13:52:12 <startling> pmurias, what type of function?
13:52:13 <ReinH> byorgey: missed that. Also hi :) I heard your recent diagrams talk went well from a friend.
13:52:27 <levi> pmurias: There may be a trivial function of the correct type that you could supply, like id
13:52:41 <startling> pmurias: it's probably preferable to use something like id or const someValue than undefined.
13:52:42 <byorgey> pmurias: just stick something like  'error "I can't be bothered to implement pattern splices"'  or whatever =)
13:52:57 <startling> using error there isn't so bad though, yeah.
13:52:59 * byorgey disagrees with startling 
13:53:14 <augur_> or do you have to have a monad for that really to make sense within the same functor?
13:53:15 <byorgey> ReinH: hi =) and thanks.
13:53:24 <augur_> and then if so, is there a version of ap that sequences in the other direction?
13:53:38 <startling> If you do use error, just make sure it's clear where it's from, in case it does get raised. :)
13:53:39 <ReinH> byorgey: from a non-Haskeller friend, no less :) Winning hearts and minds.
13:53:42 <levi> error is handy for things you expect will never happen.
13:53:45 <mazzHaskell> davean, Philonous: Thank you both! For taking your time! I have the problem, that i can not summarize it :-) But it is working again - and so i'm happy. I'm afraid it is a good piece of my fault and not Leksah or Haskell. Anyway - Thank you!
13:53:49 <byorgey> ReinH: excellent =)
13:54:10 <ReinH> byorgey: I often point to the monoid pearl as an example of how awesome applied math is :)
13:54:11 <augur_> @pl do { f <- cf ; x <- cx ; return (f x) }
13:54:11 <lambdabot> (line 1, column 4):
13:54:11 <lambdabot> unexpected '{'
13:54:11 <lambdabot> expecting variable, "(", operator or end of input
13:54:14 <byorgey> I'm glad people seemed to enjoy it.  I prepared for it very much at the last minute so it didn't feel like it went that well to me.
13:54:15 <augur_> :(
13:54:34 <ReinH> byorgey: I know that feeling, but it is probably not accurate of how it was received by others :)
13:54:38 <augur_> @pl cf >>= (\f -> cx >>= (\x -> return (f x)))
13:54:39 <lambdabot> (cx >>=) . (return .) =<< cf
13:54:40 <byorgey> but my personal standard are not really relevant here
13:54:42 <byorgey> right =)
13:54:43 <augur_> horrible
13:55:07 <byorgey> ReinH: re: monoid pearl, cool, thanks =)
13:55:10 <Philonous> @type \y x -> (pure ($)) <*> y <*> x -- augur_
13:55:11 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:55:44 <augur_> Philonous: sure you could do that but i mean is that defined anywhere?
13:56:00 <ReinH> @type \y x -> (pure (??)) <*> y <*> x -- augur_
13:56:01 <lambdabot> (Functor f1, Applicative f) => f (f1 (a -> b)) -> f a -> f (f1 b)
13:56:09 <ReinH> cause why not
13:56:11 <augur_> also i think you mean   \y x -> pure (flip ($)) <*> x <*> y   ?
13:56:41 <ReinH> that's f a -> f (a -> b) -> f b though iinm
13:57:00 <ReinH> you want f (a -> b) -> f b -> f a right?
13:57:07 <erisco> I am trying to make a lexer using Happy parser. How can I specify a range of characters ie 'a'-'z' other than enumerating each one?
13:57:15 <augur_> ReinH: no no
13:57:20 <augur_> i want f (a -> b) -> f a -> f b
13:57:20 <ReinH> augur_: oh sorry
13:57:27 <augur_> but with the effects of the arg first
13:57:44 <augur_> @type \f x -> flip ($) <$> x <*> f
13:57:45 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:57:45 <triliyn> > enumFromTo 'a' 'z'
13:57:46 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
13:57:58 <ReinH> augur_: does that do what you want?
13:58:24 <erisco> triliyn, are you familiar with Happy?
13:58:27 <Philonous> augur_, yes, that's what I meant to write. Somehow I ended up with this when copying it back from ghci
13:58:33 <triliyn> erisco, I am not
13:59:15 <Philonous> augur_, Anyway, I wouldn't know if it's defined somewhere.
13:59:21 <augur_> ReinH: yeah, the functionality is right, but is there a version of it baked in?
14:00:25 <levi> erisco: I think most people use alex for lexing when parsing with happy.
14:00:46 <Philonous> flip . liftA2 $ flip id
14:00:55 <ReinH> augur_: not afaik, what do you use it for? :)
14:02:17 <augur_> ReinH: well, computational natural language semantics needs to handle things like quantification scope, and one method for doing that is via continuations
14:02:38 <ReinH> Time to write an "applicatives" package in the style of chrisdone's lists, strings? :)
14:02:42 <ReinH> augur_: ok interesting
14:02:47 <Athas> Which hashmap package do you people recommend?  Is http://hackage.haskell.org/package/hashmap good?
14:02:59 <augur_> ReinH: so that the meaning of a sentence like "susan saw someone" could be like...    pure see <*> someone <*> pure susan
14:03:10 <ReinH> Athas: perhaps something from unordered-containers, depending on what you need?
14:03:24 <levi> Athas: That one has a bit 'deprecated' warning on it.
14:03:43 <augur_> ReinH: but when you have multiple quantifiers, you want scope ambiguities to be represented. so lets make a new notation, <* = <*> and *> = that funny other one
14:03:53 <ReinH> augur_: ok
14:03:57 <ReinH> augur_: and this doesn't require context sensitivity?
14:03:57 <Athas> levi: oh, I missed that.
14:04:02 <Athas> Right, so unordered-containers it is.
14:04:26 <augur_> ReinH: so then a sentence like "everyone saw someone could bean two things:   pure see <*> someone <* everyone   or   pure see <*> someone *> everyone
14:04:49 <ReinH> augur_: hmm ok
14:04:59 <augur_> which have the meanings   exists x. forall y. see x y   and   forall y. exists x. see x y   respectively
14:05:01 <ReinH> augur_: so this is for modeling garden path sentences?
14:05:04 <augur_> which the sentence does indeed have
14:05:11 <augur_> ReinH: no just for modelling quantifier scope ambiguities
14:05:15 <ReinH> Ah.
14:05:25 <ReinH> augur_: I need to know more nlp :)
14:05:32 <Cale> ReinH: Is there a recording of byorgey's talk?
14:05:38 <ReinH> Cale: good question!
14:05:45 <ReinH> I'd love to find one.
14:06:43 <augur_> ReinH: but yeah, basically, its useful because you can translate your natural language meanings into LC meanings using the Cont applicative and get scope ambiguities by reordering effects
14:07:09 <ReinH> augur_: seems good :)
14:07:12 <augur_> ReinH: im sure reverse-order effects is desirable outside of NLP tho
14:10:27 <eacameron1> people have suggested persistent for interfacing with Haskell...however the docs on yesodweb that I found are for an older version and they don't work...any idea where I could get more up-to-date tutorials
14:12:36 <arpunk> eacameron1: you might want to take a look at https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/persistent-db
14:12:53 <eacameron1> arpunk: nice, thank you!
14:13:01 <arpunk> no problem
14:14:46 <byorgey> Cale, ReinH: yes, a video was made.  I have no idea what the timeline is for publishing it.
14:18:01 <levi> byorgey: How long ago was it?
14:18:13 <byorgey> levi: precisely one week ago
14:18:34 * thoughtpolice is still wondering about ICFP vids
14:18:40 <byorgey> (with US Thanksgiving in between)
14:19:54 <levi> byorgey: Oh, was that about your monoid pearl, or something else?
14:20:37 <byorgey> levi: no, it was just about diagrams.  First hour was a little tutorial; second hour was talking about some issues in DSL design
14:21:31 <dmj`> Have a noob question. foo = let bar = show in (bar 'a', bar 1), yields no instance for Num Char. when I flip the tuple to be (bar 1, bar 'a') it yields the same error message. How do the rules of typeclass application work here? Show Num gets instanced first in both cases, why is this?
14:22:39 <tomejaguar> dmj`: I think that's the monomorphism restriction.
14:22:53 <geekosaur> dmj`: this is MonoLocalBinds, I believe (a special case of the monomorphism restriction)
14:22:53 <jle`> @where dmr
14:22:53 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
14:22:59 <shachaf> It's the monomorphism restriction.
14:23:10 <geekosaur> either you can provide a type signature, or you can add an explicit parameter
14:23:24 <shachaf> MonoLocalBinds isn't really "the monomorphism restriction except only for local definitions"
14:24:06 <jle`> although curious as to why ghc would infer bar from the type of bar 1 and not bar 'a'
14:24:29 <tomejaguar> jle`: It tries to unify them, doesn't it?
14:24:39 <jle`> ah
14:24:41 <jle`> that makes sense
14:24:50 <shachaf> 1 has a polymorphic type (forall a. Num a => a), 'a' just has type Char
14:25:02 <tomejaguar> 1 :: Num a => a, 'a' :: Char, so the unification is a Num instance for Char
14:25:30 <shachaf> I,I Num 'a' => 'a'
14:25:36 <Peaker> there was a nice proposal for "never" declarations for instances for better error messages
14:25:43 <jle`> it's smarter than just seeing bar 'a' and thinking "oh, must be Char -> Show"; it tries its best to find a type for both appearances
14:26:02 <jle`> er, Char -> String
14:33:21 * hackagebot zeromq3-haskell 0.5.1 - Bindings to ZeroMQ 3.x  http://hackage.haskell.org/package/zeromq3-haskell-0.5.1 (ToralfWittner)
14:38:45 <t4nk143> _
14:39:57 <eacameron> fp-complete's tutorial for persistent (and the one on yesodweb) are both out of date! how can I learn to use persistent? :(
14:40:56 <levi> eacameron: You could install an old version of persistent until you are comfortable with the tutorial material, then look at the haddocks for old and new versions to see what changed.
14:41:24 <eacameron> levi: yes, I could; but that is disappointing
14:41:31 <eacameron> that will be my last resort
14:42:06 <levi> Or you could use something besides persistent. Are you using all of Yesod, or just persistent?
14:42:27 <eacameron> levi: I'm not using Yesod
14:42:43 <eacameron> levi: actually I just want a good backend store for SQLite
14:42:52 <eacameron> *API, not store
14:43:02 <eacameron> it would be nice to support MySQL too
14:45:55 <Luke> chrisdone: is this you? http://youtu.be/a-RAltgH8tw?t=13m24s
14:49:05 <levi> eacameron: You might try groundhog: https://www.fpcomplete.com/user/lykahb/groundhog
14:50:21 <eacameron> hmmm...I've heard of it
14:51:00 <leocassarani> I must admit I don't know much about Applicative/arrows/etc, so that may well solve my problem, but I must ask -- is there a "built-in" way to apply a list of function with the same type to the same set of arguments?
14:51:14 <leocassarani> in other words, something like map (\f -> f arg1 arg2) [f1, f2, f3, f4]
14:51:40 <shachaf> I don't think you'll get something much shorter than that.
14:51:58 <leocassarani> ah, fair enough, I thought it might be something that arrows might solve… because I don't understand arrows
14:52:12 <shachaf> Arrow is an overrated type class anyway.
14:53:00 <eacameron> what's the deal with groundhog? everyone seemed to like persistent when I asked a while ago...
14:53:02 <mazzHaskell> exit
14:53:04 <mazzHaskell> exit
14:55:02 <levi> eacameron: Persistent is fine. In fact, the easiest thing to do is probably just to use a version of persistent that corresponds to the documentation. It was fine when the documentation was written, so there's no real need to run the latest version.
14:55:51 <levi> Once you know it well enough that you don't need tutorial-level material anymore, you'll probably be able to upgrade to the latest version with just the haddock documentation.
14:56:20 <eacameron> true
14:56:31 <eacameron> looks like the tutorial for groundhog is also out of date
14:56:36 <eacameron> guess I'm stuck
14:57:37 <cswords> What, exactly, does "promotable" mean?
14:57:55 <simpson> cswords: What's the context?
14:57:57 <levi> eacameron: You aren't stuck. Nobody is holding a gun to your head and making you use the latest versions of software.
14:58:21 <eacameron> levi: only my stringest abhorance of using outdating things ;)
14:58:27 <eacameron> *stringent
14:58:34 <cswords> simpson: Kinds
14:58:52 <Eduard_Munteanu> cswords: if it's about DataKinds, promotion means automatically making a data constructor into a type constructor with the same name
14:59:09 <Eduard_Munteanu> Also making the type constructor into a kind constructor.
14:59:16 <cswords> So why wouldn't something like Shape a be promotable?
14:59:24 <Eduard_Munteanu> cswords: how is it defined?
14:59:32 <cswords> Or rather, is it the case that data families are not promotable?
14:59:45 <Eduard_Munteanu> cswords: yes, the manual says so, specifically
15:00:01 <cswords> Then is there a way to define an extensible datatype that is promotable?
15:00:07 <cswords> So that a user can add on to it later?
15:00:16 <Eduard_Munteanu> cswords: you can only promote normal datatypes, except type parameters must be in *
15:00:28 <cswords> What I really want is
15:00:37 <cswords> Data Strat = E | SE | L
15:00:46 <cswords> But I'd like a user to define D such that Strat = E | SE | L | D]
15:00:51 <cswords> (modulo typos)
15:01:11 <Eduard_Munteanu> cswords: how about   data D = IsD | IsStrat Strat  ?
15:01:26 <Eduard_Munteanu> That works with datakinds.
15:01:38 <cswords> I, uh, don't think so.
15:01:50 <cswords> I'm using these to parameterize typeclasses
15:02:28 <Eduard_Munteanu> cswords: what does your class declaration look like?
15:02:34 <cswords> And I'd like a constraint like class (s ~ Strat) => Monitor S where ...
15:03:21 <Eduard_Munteanu> cswords: that can't really work like that
15:04:00 <cswords> h/o, I somehow just lost a giant chunk of my code
15:04:16 <simpson> cswords: Huh. This sounds intricate. What do your types represent? (Why do you want users to be able to extend your types without a recompile?)
15:04:57 <marx2> existentials allow us to have a heterogenous list.  can we take it further? how about "casting" AnyFoo back to Foo?
15:05:11 <Cale> marx2: That's what Typeable is for
15:05:25 <marx2> so it is possible? cool
15:05:34 <cswords> simpson: They're for a contract system
15:05:44 <Cale> :t cast
15:05:44 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
15:05:53 <cswords> So I get something like this:
15:05:55 <cswords> data Con p a where Eager :: PCon t a -> Con StratEager (PCon t a)
15:06:00 <Eduard_Munteanu> cswords: you can do   data D k = D | NotD k
15:06:02 <Cale> This gives Nothing unless a and b are actually the same type
15:06:14 <Cale> otherwise cast x = Just x
15:06:33 <Cale> (but you know more about its type then)
15:06:36 <marx2> Cale can I determine at runtime the type of the AnyFoo?
15:07:01 <Cale> If you have a Typeable instance, yes.
15:07:04 <cswords> Eduard_Munteanu: but won't that break my instances?
15:07:11 <Cale> e.g. if you'd defined your existential like:
15:07:24 <cswords> What I'm really trying to do is the following:
15:07:31 <Cale> data Dynamic = forall a. (Typeable a) => MkDyn a
15:07:33 <cswords> My contractshave a shape and a strategy associated
15:07:40 <cswords> And I'd like for the users to be able to define their own shapes
15:07:40 * monochrom doesn't support dynamic type upcasting and downcasting, except for... exceptions!
15:07:59 <cswords> So I have something like this:
15:07:59 <Eduard_Munteanu> cswords: use a type family then
15:08:02 <cswords> data PCon t a where PredC :: (a -> Bool) -> PCon Pred a FunC  :: Con pa a -> Con pb b -> PCon Func ((Con pa a) -> (Con pb b)) PairC :: Con pa a -> Con pb b -> PCon Pair ((Con pa a), (Con pb b))
15:08:08 <Cale> Yeah, the way that the exception library does it is really nice
15:08:20 <cswords> Wow, that spacing didn't work.
15:08:30 <cswords> I tried using type families
15:08:39 <cswords> And it couldn't infer enough
15:09:09 <ReinH> cswords: I still can't look at types like that without my brain giving up and going "words words words words"
15:09:13 <ReinH> :/
15:09:26 <Eduard_Munteanu> cswords: can we trim this down to a simpler example, like ReinH says?
15:09:41 <cswords> Let me try...
15:09:43 <Cale> ReinH: "cswords cswords cswords cswords"
15:09:52 <ReinH> Probably the stripped whitespace didn't help
15:09:55 <ReinH> heh
15:10:49 <marx2> Cale what's the syntax for determining the type of Dynamic at runtime?
15:11:09 <cswords> So I have these three type-level functions, called Ci :: A -> B -> Type, Co :: A -> B -> Type, and Eo :: A -> B -> Type
15:11:16 <cswords> Where A = A1 | A2 | A3
15:11:17 <Eduard_Munteanu> marx2: you could just pattern-match on your existential type
15:11:24 <cswords> And B = B1 | B2 | B3
15:11:40 <cswords> And I have a bunch of class instances like instance M (A1, B2) where ...
15:11:51 <cswords> That has some functions and whatnot defined using Ci/Co/Eo
15:12:06 <Eduard_Munteanu> Ok.
15:12:13 <cswords> And it would be ideal if I could give the users the option to extend B with B4, B5, ...
15:12:14 <Cale> marx2: Well, you can nest the pattern matches, but I find pattern guards are a really nice way to handle it
15:12:24 <Cale> But the simple way:
15:12:30 <ReinH> cswords: tried and failed to avoid making the Ei -> Ei -> O joke, so there it is.
15:12:58 <Cale> foo (MkDyn x) = case cast x of Just v -> ... use v here as some specific type ...; Nothing -> ... handle other possibilities ...
15:13:01 <cswords> I could just link to the semantics PDF.
15:13:06 <cswords> That might be easier c.c
15:13:19 <ReinH> cswords: I can add it to my virtual pile
15:13:26 <Cale> marx2: That leads to horrible nested case expressions if you're testing for many possibilities though
15:13:40 <cswords> Eh, for help implementing, not for "showing off"
15:13:40 <ReinH> How did people handle their FIFO paper queue when they were literally pieces of paper?
15:13:41 <Eduard_Munteanu> cswords: promotable kinds aren't open... but you can match on different kinds!
15:13:44 <Cale> marx2: So to avoid the mess, you might want to use a pattern guard:
15:13:56 <Eduard_Munteanu> cswords: are you familiar with PolyKinds?
15:14:03 <marx2> I see, thanks for the example
15:14:08 <cswords> Sort of?
15:14:41 <paulschellin> Hello #haskell, I've been curious about how others decide when the use of continuations (e.g. from Control.Monad.Cont) is the best design for a particular concept in their haskell projects.
15:14:51 <Cale> foo (MkDyn x) | Just (v :: Integer) <- cast x = ... -- you might also use PatternSignatures
15:15:17 <Eduard_Munteanu> cswords: you can make a data family parametrised by a polymorphic kind, and for each kind you get to define a bunch of constructors
15:15:25 <Cale> The fact that you can have multiple pattern guards and they fall through into the next one when they fail is convenient to avoid the horrible nesting.
15:15:40 <Cale> It's also really great for unpacking type information from GADTs in general
15:15:43 <cswords> That sounds like what I want.
15:15:55 <Cale> paulschellin: Extremely rarely
15:16:05 <cswords> Is this written up anywhere?
15:16:23 <monochrom> ReinH: I never had a paper queue. I do queue my underwear, socks, towels, and rechargeable batteries. the only problem is, I never make up my mind between "enqueue to top, dequeue from bottom" and "enqueue to bottom, dequeue from top" :)
15:16:37 <Eduard_Munteanu> cswords: for example,   data family MyData :: k -> *
15:16:48 <hpc> paulschellin: the way i try to do it is just come up with a solution and see what abstractions happen on the way
15:17:25 <hpc> once i have almost needed Cont, until i saw that State (IO r) was better
15:17:32 <Eduard_Munteanu> cswords: you can write instances like   data instance MyData (t :: SomeKind) where   IsA :: MyData A   IsB :: MyData B
15:17:56 <Cale> paulschellin: One little use case is where you have a bunch of with- style functions, and you'd like to get all the resources at once, and make use of them together.
15:17:56 <paulschellin> hpc: Is for something which required concurrency?
15:17:59 <Eduard_Munteanu> cswords: but you can write an instance for   t :: SomeOtherKind   too.
15:18:14 <ReinH> monochrom: you could alternate them for a pessimal distribution :)
15:18:21 <hpc> if you need concurrency i would go with what IO already has
15:18:24 * hackagebot sequor 0.4.2 - A sequence labeler based on Collins's sequence perceptron.  http://hackage.haskell.org/package/sequor-0.4.2 (GrzegorzChrupala)
15:18:43 <quchen> paulschellin: I recently saw the first nice use of ContT in #haskell. It was to nest 'bracket' applications so that all the finalizers are run in order in a concurrent setting. So: to nest 'bracket'.
15:19:12 <monochrom> Cale: I want to know how to do that. using Cont to group a ton of with-'s.
15:19:55 <Cale> Well, if you think about the type of a with- style function, it's going to take some continuation of type (Resource -> IO a) and produce a result of type IO a
15:20:00 <Eduard_Munteanu> cswords: makes sense?
15:20:18 <Peaker> @type ContT $ bracket undefined undefined
15:20:19 <lambdabot> ContT r IO a
15:20:31 <paulschellin> I had seen the use of nesting and "with*" in the haskell-cafe blurb by... I guess it was written by you, Cale?
15:20:35 <cswords> Eduard_Munteanu: Not exactly?
15:20:45 <quchen> Incidentially, it was Peaker who suggested using ContT. http://ircbrowse.net/browse/haskell?id=16891150&timestamp=1385137770#t1385137770
15:20:48 <cswords> More importantly, I don't see how this helps me get the typeclass instances I want.
15:20:56 <Cale> paulschellin: :)
15:20:57 <Peaker> monochrom: if you wrap your bracket/with functions in a ContT constructor, you can then monadically bind them:  do { handle <- withFile "foo" ReadMode ; foo <- withOther ... ; ... }
15:20:59 <Cale> yes
15:21:02 <Cale> :t Foreign.Marshall.Array.withArray
15:21:03 <lambdabot> Couldn't find qualified module.
15:21:08 <Cale> :t Foreign.Marshal.Array.withArray
15:21:09 <lambdabot> Foreign.Storable.Storable a => [a] -> (GHC.Ptr.Ptr a -> IO b) -> IO b
15:21:12 <Eduard_Munteanu> cswords: the same idea works for classes too, namely that you can match on kinds
15:21:24 <monochrom> I see. thanks Cale and Peaker. yeah flattening them is nice.
15:21:30 <Cale> :t (\x -> Cont (Foreign.Marshal.Array.withArray x))
15:21:31 <lambdabot>     Not in scope: data constructor `Cont'
15:21:31 <lambdabot>     Perhaps you meant one of these:
15:21:31 <lambdabot>       `Const' (imported from Control.Applicative),
15:21:44 <Cale> :t (\x -> Control.Monad.Cont.Cont (Foreign.Marshal.Array.withArray x))
15:21:44 <lambdabot>     Not in scope: data constructor `Control.Monad.Cont.Cont'
15:21:44 <lambdabot>     Perhaps you meant `Control.Monad.Cont.ContT' (imported from Control.Monad.Cont)
15:21:45 <Eduard_Munteanu> cswords: what I said before gets you a 'data' that holds different constructors depending on kinds
15:21:46 <Cale> oh, right
15:21:51 <Cale> :t (\x -> cont (Foreign.Marshal.Array.withArray x))
15:21:51 <lambdabot> Foreign.Storable.Storable a => [a] -> Cont (IO b) (GHC.Ptr.Ptr a)
15:22:07 <Peaker> monochrom: also nice that if you have a list of resources, you can mapM them (nicer than a manual recursion to do the CPS chaining)
15:22:14 <Cale> (they hid the constructor)
15:22:17 <cswords> What I really want is different functions depending on kinds.
15:22:34 <Peaker> monochrom: the list/sequence/mapM case is the only one I actually bother with ContT (not worth it for ordinary bracket cases)
15:22:43 <Cale> You actually only need Cont
15:22:45 <jle`> what's a better word for 'return', as in 'f returns True', that doesn't clash with the monad return
15:22:50 <Cale> But ContT is fine too
15:23:00 <cswords> I'm writing this contract mechanism where assert :: Cin a b -> Cout a b
15:23:11 <startling> jle`, "evaluates to"
15:23:19 <Eduard_Munteanu> cswords: class MyClass (t :: k) where type MyType t; foo :: MyType t -> ...
15:23:23 <startling> "is", maybe.
15:23:31 <Cale> "is", "produces", "gives"
15:23:36 <monochrom> jle`: sometimes, "equal" is just right
15:24:04 <monochrom> (\x -> x+x) (rand 6) = rand 6 + rand 6. it says "=" there.
15:24:08 <Cale> Though usually you wouldn't say f is True, but rather that f v was
15:24:08 <ReinH> ocharles: OMG thanks for "Programming OpenGL with linear"
15:24:17 <Eduard_Munteanu> cswords: and you can write instances for 't :: SomeKind' and 't :: *' that behave differently
15:24:20 <jle`> how about for something like "f :: Int -> Int; f takes an int and returns an int"
15:24:26 <jle`> i should say "f takes an int and produces an int?"
15:24:34 <Cale> I'd say "produces"
15:24:35 <Cale> yeah
15:24:36 <monochrom> f maps Int to Int
15:24:38 <jle`> it's a little weird to say "f takes an int and equals an int"
15:24:45 <monochrom> f's codomain is Int
15:24:45 <Eduard_Munteanu> cswords: note that 't' is polymorphic there!
15:24:59 <monochrom> no no, f cannot equal a number. obviously.
15:25:01 <cswords> But I can't use a polymorphic kind there.
15:25:20 <Eduard_Munteanu> cswords: where and why?
15:25:30 <cswords> What I really want is class Monitor (s :: Strat a) (p :: Shape b) where assert :: Cin s p -> Cout s p
15:25:34 <paulschellin> Ah, those cases make sense then. I was mostly having a hard time understanding justifications of implementation, which in turn led to me not really grasping the concept of continuations.
15:25:40 <Cale> "f is a function from Int to Int"
15:26:31 <Peaker> quchen: btw, I figured the ContT relationship out when I was wondering what the equivalent for Python's "nested" combinator was
15:26:34 <cswords> So that as the argument to my strategy varies and the shape of my argument varies, my definition of assert can vary.
15:27:15 <quchen> Peaker: Remind me of the problem again ..?
15:27:32 <quchen> (I still don't know about Python's 'nested' though)
15:27:41 <madjestic> hey guys, I am trying to wrap my head around this:  I've got a function (getKey ESC) of type (getKey ESC :: IO KeyButtonState), KeyButtonState returns one of the constructors (Release or Press).  I need to compare a value, returned by getKey (IO KeyButtonState) and constructor Press of type (KeyButtonState).  How can I do that?
15:27:42 <Cale> paulschellin: Another thing which Cont/ContT lets you do is early returns. These days when programming in C or pick your favourite imperative language, I sometimes imagine that every definition has been implicitly wrapped in callCC $ \return -> ... (call with current continuation)
15:27:52 <monochrom> Q: "which words do I use to refer to mathematicial concepts?" A: "mathematical words"
15:27:55 <Peaker> quchen: you have [Resource a] and you want ([a] -> IO r) -> IO r
15:28:09 <Peaker> Where "Resource a" is a bracket-like generator of a value "a"
15:28:20 <Cale> (obviously, you wouldn't want to bind 'return' locally in Haskell, because it's evil to shadow the Prelude definition ;)
15:28:34 <Peaker> so basically you have  [(a -> IO b) -> IO b] and you want ([a] -> IO b) -> IO b
15:28:37 <skypers> @src cycle
15:28:37 <lambdabot> cycle [] = undefined
15:28:37 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
15:28:57 <cswords> Eduard_Munteanu: thoughts?
15:29:02 <Cale> paulschellin: It lets you precisely capture the effect of 'return' and 'break' from most imperative languages
15:29:08 <ReinH> Cale: Oh look edwardk wrote a thing for distributive and apparently distributive functors are dual to Traversable http://hackage.haskell.org/package/distributive-0.3.2/docs/Data-Distributive.html
15:29:12 <Peaker> quchen: It's a real problem I encountered, was really nice to find out that nested=sequence in ContT
15:29:29 <ReinH> Cale: hypothesis: if it exists, edwardk has written a haskell library for it.
15:29:36 <monochrom> Cale: you can call it "quit". with that, you can call it quit. :)
15:29:47 <Cale> monochrom: haha
15:29:48 <Cale> yeah
15:29:50 <edwardk> and they are all representable functors, and they so they are all right adjoints of functors from hask -> hask
15:29:52 <Eduard_Munteanu> cswords: not sure, are you trying to use the same class?
15:30:04 <quchen> Peaker: Oh, I think I misread your "btw" sentence. I thought you had some new idea, but you just told me about when you found out about that "ConT+sequence" trick
15:30:21 <Eduard_Munteanu> cswords: for both yours and user-supplied types
15:30:26 <cswords> Eduard_Munteanu: ideally
15:30:45 <Cale> edwardk: Do you know if there's any proof that every right adjoint Hask -> Hask is equivalent to (->) e for some e?
15:31:01 <Cale> (or a counterexample?)
15:31:14 <cswords> They'll define their own Cin/Cout, a new Shape data instance, and a new Monitor instance.
15:31:28 <cswords> (Well, I'm going to use template haskell to generate parts of it, but that's the basic idea.)
15:31:28 <edwardk> cale: the proof is pretty straightforward, let me show you a link to wikipedia  =)
15:31:43 <paulschellin> Cale: I come from C++, so I've been trying to map continuations to std::future and std::promise, but the generalization of break and goto is interesting as well. I should look to see if something like python's yield would be written this way as well.
15:31:56 <edwardk> cale: http://en.wikipedia.org/wiki/Representable_functor#Left_adjoint
15:32:01 <Eduard_Munteanu> cswords: oh, Shape is already a data family?
15:32:13 <Peaker> quchen: the conversation you linked to is after I found that out. I'm not sure I was the first to find it out. there are probably tons of Olegs/Saizans/edwardk's or others for whom this would be obvious at first sight without much inquiry :)
15:32:18 <edwardk> cale: replace "Set" with Hask in that link
15:32:38 <cswords> Eduard_Munteanu: ix.io/9eu
15:32:40 <Peaker> paulschellin: http://hackage.haskell.org/package/generator
15:33:56 <paulschellin> Peaker: Thanks!
15:34:07 <Cale> Ah, right, nice!
15:34:40 <edwardk> cale: the uniqueness follows from the fact that (,) e -| (->) e, so you already have on left adjoint for (->) e, and so the new one must be isomorphic, etc.
15:35:53 <hopf> wait, so (->) is an internal hom in Hask?
15:37:00 <Eduard_Munteanu> cswords: and you want to be able to extend Shape, right?
15:37:08 <edwardk> hopf: http://hackage.haskell.org/package/categories-1.0.6/docs/src/Control-Category-Cartesian-Closed.html#CCC see the CCC definition for (->) using (->) as the form for exponentials
15:37:13 <quchen> Peaker: Stigler's law makes this easier. Let's just name it after Cale.
15:37:16 <cswords> Eduard_Munteanu: That is correct.
15:37:23 <cswords> Also be able to load that file :P
15:37:35 <Eduard_Munteanu> Yeah, I know it complains. :)
15:38:37 <Peaker> quchen: that implies I discovered it first :) hah
15:38:39 <hopf> edwardk: Thanks! This is very elucidating
15:41:10 <Eduard_Munteanu> cswords: you could just make it an associated data family...  class Monitor (s :: Strat a) b where  data Shape b; assert :: ...
15:41:12 <Peaker> madjestic: KeyButtonState doesn't return those constructors, it is a type inhabited by those constructors
15:41:31 <Peaker> madjestic: if (x :: KeyButtonState), you can use: case x of Press -> ... ; Release -> ....
15:42:04 <Eduard_Munteanu> cswords: actually wait, that isn't promoted either...
15:42:13 <bicgena> Obviously, you haven't written enough Haskell. If it compiles, it'll be bug free"  does anyone actually write their haskell programs this way?
15:42:25 <bicgena> "obviously*
15:42:39 <simpson> bicgena: Sometimes, but not often.
15:42:48 <simpson> There are too many types that aren't like that.
15:42:53 <jle`> i like to say it tongue-in-cheek with the secret hope that it is true
15:42:57 <jle`> but i don't tell anyone
15:43:01 <jle`> (sh)
15:43:04 <Eduard_Munteanu> bicgena: well, not quite but it's more rewarding to spend time designing stuff compared to other languages
15:43:05 <hpc> i try and write my code to the point of "it compiles, there are no stupid errors"
15:43:07 <JuanDaugherty> wow breathtaking hubris, gotta love it!
15:43:52 <hpc> leaving me more time to deal with errors like forgetting that this handle needs to be unbuffered and this algorithm isn't numerically stable, etc
15:43:54 <JuanDaugherty> naivette, comedic sense or i dunno wha
15:44:13 <cswords> Eduard_Munteanu: the other problem is that I'll probably have several instances where the shape is the same and the strategy is different.
15:44:26 <jle`> in any case, it is more close to the truth in Haskell than it is in most other languages
15:45:15 <jle`> and it is used to justify (for the sake of preserving sanity) the hours spent fighting the compiler
15:45:28 <lispy> :t Data.Foldable.foldl (>>=)
15:45:29 <lambdabot> (Monad m, Foldable t) => m a -> t (a -> m a) -> m a
15:45:34 <lispy> does that exist anywhere?
15:45:38 <Eduard_Munteanu> cswords: perhaps you can break it into Monitor and a constraint for your 'Shape b'.
15:45:40 <lispy> As a standard function?
15:45:41 <jle`> and it is also true that Haskell has helped me moved a lot of my debugging time from runtime to compiletime
15:46:36 <lispy> jle`: it's hard to explain to people how big of a win that is. For one thing, it tends to move the identification of the problem to a time when the changes you just made are fresh in your mind
15:46:44 <lispy> So it has a compounding affect
15:46:50 <lispy> It's not just about moving the time around
15:47:00 <cswords> Eduard_Munteanu: I was trying to do that, but I couldn't add constraints because it forced the arguments to Monitor to be non-promotable kinds
15:47:03 <cswords> :/
15:47:38 <Peaker> It also scales well with a growing project. Test suite times and runtime grows with a growing project, so error detection becomes more and more expensive. Type checking scales much better
15:47:51 <Peaker> The documentation aspect is great, too, especially for others' code
15:48:51 <bicgena> simpson: when is that "sometimes"?
15:50:20 <simpson> bicgena: Consider [] and what it's capable of, for example.
15:50:26 <cswords> Eduard_Munteanu: FWIW, here is the definition set for the non-extensible, working implementation I have http://ix.io/9ev
15:50:43 <bicgena> simpson: ah
15:51:08 <bicgena> simpson: anything else?
15:51:16 <lightquake> is there a tool that will tell me what imports i'm using are redundant?
15:51:29 <jle`> lightquake: ghc-mod / hlint should do it for you
15:51:36 <nicte> -Wall does that
15:51:41 <paulschellin> Is there a reasonable, idiomatic haskell way to construct a data structure (defined with record syntax) from tuples of variable lengths? I was hoping to make the output of System.IO.MMap's mmapFilePtr and mmapFileForeignPtr be handled similarly, but my solutions have been ugly messes of pattern matching.
15:51:45 <simpson> bicgena: I'm sure that there are plenty of other types that can have infinitely many values. [] is just a particularly common one.
15:51:55 <jle`> Philonous: tuples of various length?
15:51:59 <jle`> do you mean lists?
15:52:02 <jle`> vectors/arrays?
15:52:12 <jle`> or like...nonhomogenous vectors
15:52:17 <paulschellin> jle`: Tuples, they're non homogenous
15:52:29 <nicte> paulschellin: there's type classed uncurry in the tuple package
15:53:15 <jle`> ^^
15:53:27 * hackagebot idris 0.9.10.1 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.10.1 (EdwinBrady)
15:54:54 <paulschellin> nicte: Thanks! I know I had seen that function when I was trying to write the data constructor, now I'm trying to recall my thought processes as to why I thought that wasn't going to work. I'll try it again then
15:55:31 <lightquake> is there a way to decode a bytestring that represents UTF-8 into a String that doesn't involve round-tripping through Text?
15:56:50 <startling> http://hackage.haskell.org/package/utf8-string
15:57:10 <startling> in particular, http://hackage.haskell.org/package/utf8-string-0.3.7/docs/Data-ByteString-UTF8.html
15:57:24 <startling> (toString/fromString)
15:58:03 <Eduard_Munteanu> cswords: what's 'c' there, a Con p a?
15:58:24 <Eduard_Munteanu> cswords: in Monitor's declaration
15:58:45 <ReinH> bicgena: Anyone who says "if it compiles then it will be bug free" should be approached with a healthy dose of skepticism
15:58:53 <ReinH> Since they are, you know, wrong.
15:59:37 <bicgena> ReinH: It seemed like a tongue-in-cheek statement, but it seems to be true but only sometimes
15:59:38 <paulschellin> nicte: Ah, I see what it was. I was looking at Data.Tuple from base, not the Data.Tuple from the tuple package you specified.
15:59:50 <cswords> Eduard_Munteanu: yes
15:59:51 <ReinH> Other statements like "Haskell's type system can catch a lot of bugs at compile-time that would otherwise become runtime bugs" are more reasonable.
16:00:30 <ReinH> bicgena: For instance, querying the database for a (Person, Address) and then elsewhere trying to use it like an (Address, Person) can be caught at compile time.
16:00:37 <ReinH> Non-termination and various other classes of bug cannot.
16:01:00 <acowley> Is there a syntactically nice way to write large integer literals?
16:01:20 <hpc> > 6.5e8 :: Integer
16:01:22 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
16:01:22 <lambdabot>    arising f...
16:01:34 <hpc> hmm
16:01:42 <lightquake> acowley: like what?
16:01:44 <hpc> i could have sworn that worked as long as it came out to an integral type
16:01:45 <nicte> that's a new extension in 7.8 i think
16:01:47 <hpc> :t 6.5e8
16:01:48 <lambdabot> Fractional a => a
16:02:05 <acowley> lightquake: Like what hpc wrote
16:02:09 <lightquake> > floor 6.5e8
16:02:10 <lambdabot>   650000000
16:02:14 <acowley> Which is what I tried
16:02:16 <acowley> hm
16:02:22 <Eduard_Munteanu> cswords: I think PCon should be a typeclass then
16:02:27 <lightquake> though floating point wackiness might bite you
16:02:45 <cswords> Eduard_Munteanu: it's possible
16:03:06 <cswords> I'm actually getting somewhere with the other stuff using your suggestion about defining the shape stuff inside the typeclass.
16:03:09 <cswords> But there's a funny bug.
16:03:23 <acowley> lightquake: And that leaves me with a defaulting warning
16:03:34 <cswords> Eduard_Munteanu: http://ix.io/9ew
16:03:37 <lightquake> > floor (6.5e8 :: Double)
16:03:38 <lambdabot>   650000000
16:03:49 <lightquake> what's the literal you're *actually* trying to represent?
16:03:54 <ReinH> lightquake: Data.Fixed or Rational should avoid floating point wackiness if you can't convert directly to Integer
16:03:55 <cswords> I made a note on an instance it's finding, and I don't know why it isn't grabbing the one above it.
16:04:07 <acowley> lightquake: Just testing something with various large ints
16:05:32 <Eduard_Munteanu> cswords: er, it complains if you don't define the Flat t instance?
16:05:54 <jle`> lightquake: it might be that you have to watch out for cases like 6.25e1
16:06:04 <jle`> where it is not necessarily an integer
16:06:21 <Eduard_Munteanu> cswords: oh, I see the confusion: both 'Shape x' and 'Flat t' are in *
16:10:14 <cswords> Eduard_Munteanu: How do I fix that?
16:11:05 <Eduard_Munteanu> cswords: you can't really... only * is an open kind. However you could put constraints on those *'s.
16:11:34 <Eduard_Munteanu> cswords: e.g. make a shape class
16:13:55 <cswords> How would I do that?
16:14:02 <Eduard_Munteanu> cswords: class Shape s where type Constructor s :: k     instance Shape (Flat t) where data Constructor (Flat t) where FlatC :: (t -> Bool) -> Constructor (Flat t)
16:14:14 <feypaw> I want to deal with languages in foreign characters how do I into unicode friends
16:14:34 <Eduard_Munteanu> feypaw: what editor are you using?
16:14:40 <feypaw> emacs
16:15:03 <Eduard_Munteanu> feypaw: you can use its input methods then, google for 'emacs input methods'
16:16:10 <Eduard_Munteanu> cswords: er, s/where type/where data/
16:16:57 <Eduard_Munteanu> cswords: you can further define a constructing function in that class:  makeShape :: s -> Constructor s
16:17:13 <cswords> I'm not sure how the tabbing should go...
16:17:17 <feypaw> ty eduard friendo
16:17:32 <Eduard_Munteanu> cswords: tabbing?
16:17:37 <cswords> Uh
16:17:41 <cswords> Haskell is choing on the last where
16:18:15 <cswords> instance Shape (Flat t) where
16:18:15 <cswords>   type Constructor (Flat t) where
16:18:16 <cswords>     FlatC :: (t -> Bool) -> Constructor (Flat t)
16:18:23 <cswords> That second where is producing a parse error
16:18:39 <Eduard_Munteanu> cswords: change the 'type' there into 'data' like I corrected myself above
16:19:22 <Eduard_Munteanu> In both class and instance declarations.
16:19:46 <cswords> Kind signature on data type declaration has non-* return kind k
16:20:36 <Eduard_Munteanu> cswords: er... delete ':: k'
16:21:31 <cswords> Nah
16:21:37 <cswords> Didn't do it
16:21:46 <cswords> (that didn't fix it)
16:23:17 <Eduard_Munteanu> Lemme try it myself.
16:25:49 <garhdez> Do anyone know how can I intercalate a space each n chars of a string? i.e: `func 4 "asdfqwerasdfqwer" -> "asdf qwer asdf qwer"`. I am trying to use foldr, splitAt, etc. but am not able to get it working...
16:26:28 <ReinH> > intercalate " " $ chunksOf 4 "asdfasdfasdfasdfasdfas"
16:26:28 <lambdabot>   "asdf asdf asdf asdf asdf as"
16:26:49 <garhdez> <3 u ReinH
16:26:55 <ReinH> func = intercalate " " . chunksOf 4
16:27:00 <garhdez> Thank you very much!!
16:27:19 <ReinH> @pl func n = intercalate " " . chunksOf n
16:27:19 <lambdabot> func = (intercalate " " .) . chunksOf
16:27:51 <ReinH> which is func = intercalate " " .: chunksOf where (.:) = (.).(.) but the func n ... chunksOf n version is totally fine
16:27:56 <Cale> chunksOf is in Data.List.Split, which is in the split package, btw
16:28:31 <garhdez> Ah, cool. Thank you ReinH, Cale
16:28:40 <Eduard_Munteanu> cswords: http://lpaste.net/96507
16:28:43 <Cale> You might also like to write something like  chunksOf n = map (take n) . takeWhile (not . null) . iterate (drop n)  if you don't want the dependency
16:29:20 <Eduard_Munteanu> cswords: anyway, you can put stuff that logically belongs to shapes in there
16:29:39 <Cale> (though the split package has now made it into the Haskell Platform, so it should be well-supported)
16:29:42 <Eduard_Munteanu> cswords: and even match on the different t's
16:30:21 <garhdez> Yep, I had it already imported
16:30:28 <Eduard_Munteanu> cswords: but you might want to make it polymorphic in ShapeKind too..
16:30:46 <Eduard_Munteanu> I took that from your code, forgot you want to extend it.
16:31:53 <ReinH> Cale: I wonder when (.:) will make it into the platform
16:32:44 <shachaf> I hope never.
16:33:19 <hpc> i don't mind having it
16:33:23 <hpc> maybe in a side package
16:33:24 <cswords> Eduard_Munteanu: I, uh, found a typo in the code...
16:33:40 <hpc> it'd be good to also have hoogle and friends in some easy to install bundle
16:33:50 <cswords> Thanks for this
16:33:59 <cswords> In the original code
16:34:03 <cswords> Which is why it wasn't working
16:34:29 <Eduard_Munteanu> http://lpaste.net/96507
16:34:51 <ReinH> shachaf: you don't like fmap fmap fmap :)
16:34:54 <Eduard_Munteanu> cswords: why type families weren't working?
16:35:37 <ReinH> shachaf: what do you have against morphism-morphism morphisms? ;)
16:37:12 <cswords> Eduard_Munteanu: yeah
16:37:23 <cswords> Except...
16:37:24 <cswords> Hmmm...
16:37:33 <cswords> is it possible to add kind constraints to typeclass instances?
16:38:02 <johnw> cswords: you can use ContraintKinds to make them an associated type
16:38:11 <Eduard_Munteanu> cswords: you can match on kinds, but there are no kind constraints per se
16:38:31 * hackagebot glade 0.12.5.0 - Binding to the glade library.  http://hackage.haskell.org/package/glade-0.12.5.0 (HamishMackenzie)
16:38:31 <mikeplus64> kind classes would be pretty neat
16:38:33 * hackagebot gtkglext 0.12.5.0 - Binding to the GTK+ OpenGL Extension  http://hackage.haskell.org/package/gtkglext-0.12.5.0 (HamishMackenzie)
16:38:35 * hackagebot vte 0.12.5.0 - Binding to the VTE library.  http://hackage.haskell.org/package/vte-0.12.5.0 (HamishMackenzie)
16:38:51 <Eduard_Munteanu> cswords: sometimes you can use a promoted kind as such a constraint
16:39:04 <JuanDaugherty> ReinH, "erudition or gobbledygook?" I think of that primarily in relation to J.P.Sartre but there's some version applicable to the FP cult I think
16:39:16 <johnw> and maybe even a type parameter with something like: class Foo (m :: * -> *) (c :: * -> Constraint); or maybe I'm not understanding completely
16:39:31 <ReinH> JuanDaugherty: Not sure how to parse that sentence.
16:39:59 <ReinH> JuanDaugherty: (the "morphism-morphism morphisms" bit was firmly tongue-in-cheek)
16:41:08 <Eduard_Munteanu> cswords: anyway, as I said, there are two things at odds here: you want openness, and you don't want them to be "very open" at the same time
16:42:05 <JuanDaugherty> ReinH, y  "morphism-morphism morphisms" but the buffalo sentence also comes to mind.
16:42:23 <ReinH> JuanDaugherty: oh indeed :)
16:42:40 <cswords> Hahahahaha
16:42:47 <ReinH> fmap is a morphism morphism so fmap fmap fmap is a buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo :)
16:42:51 <cswords> Eduard_Munteanu: I agree.
16:42:57 <cswords> I want it open, but only open in the way I want.
16:43:22 <cswords> So this isn't too bad, but my pair monitor has a type constraint like
16:43:33 <cswords>  (Monitor d1 s1 c1, Monitor d2 s2 c2, x1 ~ (Strat d1), x2 ~ (Strat d2), y1 ~ (Shape s1), y2 ~ (Shape s2), c1 ~ (Con x1 y1), c2 ~ (Con x2 y2)) =>
16:43:42 <ReinH> JuanDaugherty: Also, we are now talking about the free buffalo monoid, where a sentence composed of any number of "buffalo"s is a valid english sentence ;)
16:44:38 <dainanaki> mconcat $ repeat buffalo
16:44:39 <Eduard_Munteanu> cswords: you can make a constraint synonym, or turn it into a GADT
16:45:24 <ReinH> > take 5 $ iterate (++" buffalo") ""
16:45:25 <lambdabot>   [""," buffalo"," buffalo buffalo"," buffalo buffalo buffalo"," buffalo buff...
16:45:30 <Eduard_Munteanu> (you can wrap constraints in GADTs)
16:46:08 <cswords> Eduard_Munteanu: you mean something like f :: a -> b -> c -> Constraint ?
16:47:27 <JuanDaugherty> ReinH, :)
16:47:45 <Eduard_Munteanu> cswords: type PairMonitor <params> = (<some large constraint like the above>)
16:48:09 <Eduard_Munteanu> cswords: if you need to match on <params> you can make it a type family that outputs a Constraint.
16:49:02 <Eduard_Munteanu> cswords: then you can use them like   (PairMonitor a b c ...) => ...
16:50:28 <cswords> class (Monitor d s c, x ~ (Strat d), y ~ (Shape s), c ~ (Con x y)) => MonConstraints d s c
16:50:35 <cswords> It's complaining x, y are not in scope
16:50:37 <cswords> (Because they aren't.)
16:50:49 <cswords> Is there a way to get fresh type variables for that?
16:51:07 <enthropy> that can be allowed
16:51:16 <Eduard_Munteanu> cswords: you can use a GADT directly, or make a constraint GADT wrapper.
16:51:26 <Eduard_Munteanu> The latter only works sometimes.
16:51:38 <enthropy> after all it can calculate what x is given d (which is in the class)
16:52:07 <cswords> How would I do it with a gadt?
16:52:42 <enthropy> Eduard_Munteanu: constraint kinds are bad in that situation because you have to  type PairMonitor d1 s1 c1 d2 s2 c2 x1 x2 y1 y2 = (Monitor d1 s1 c1, Monitor d2 s2 c2, x1 ~ (Strat d1), x2 ~ (Strat d2), y1 ~ (Shape s1), y2 ~ (Shape s2), c1 ~ (Con x1 y1), c2 ~ (Con x2 y2) -- is a mess
16:52:44 <enthropy> to use
16:52:52 <Eduard_Munteanu> I mean    data WrapC c = WrapC c   type family Unwrap (c :: *) :: Constraint   type instance (WrapC c) = c
16:53:40 <Eduard_Munteanu> Then in some cases you can write   type SomeConstr = WrapC (forall x. (<something involving x>))  with ImpredicativeTypes
16:53:48 <cswords> So how do I get a fresh x and y?
16:54:09 <enthropy> Eduard_Munteanu: can you have an example of ImpredicativeTypes being useful?
16:54:13 <Eduard_Munteanu> cswords: using the forall above. As for the direct GADT way...
16:55:29 <Eduard_Munteanu> cswords: data MyConstraint :: <a bunch of kinds> -> * where MC :: forall <vars>. (<constraint involving vars>) => MC <direct parameters>
16:56:03 <Eduard_Munteanu> enthropy: ImpredicativeTypes lets you place that 'forall x. ...' value inside a constructor
16:56:47 <enthropy> sure it lets you do that, but does anything useful come of it?
16:57:07 <Eduard_Munteanu> cswords: then in the methods you can require a  MyConstraint   parameter. If you pattern-match on the constructor MC, you get those constraints automatically.
16:57:54 <Eduard_Munteanu> enthropy: in rare cases it lets you omit certain parameters, but with that forall you rewrite the constraint in a nicer way
16:58:14 <cswords> I don't understand what I'm doing.
16:58:18 <enthropy> Eduard_Munteanu: do you think http://hackage.haskell.org/package/Rlang-QQ-0.1.0.2/docs/RlangQQ-MakeRecord.html can replace the __ type variable with a forall __ . ?
16:58:20 <Eduard_Munteanu> enthropy: then you can unpack it with the Unwrap type family
16:59:55 <Eduard_Munteanu> enthropy: I've had GHC accept something similar, yes, but I'm unsure what the exact conditions are or even if it isn't a GHC bug.
17:00:17 <cswords> Now it's complaining that everything is out of scope
17:00:48 <enthropy> Eduard_Munteanu: type ListToRecN (n :: HNat) x r = forall __. (HReplicate .... ) -- is accepted by ghc
17:01:03 <enthropy> but it cannot be used in the type signature for listToRecN above
17:01:28 <enthropy> or maybe you've got some different variation?
17:02:23 <Eduard_Munteanu> enthropy: no, you have to wrap it in a datatype: type ListToRecN' (n :: HNat) x r = WrapC (forall __. ListToRec __ n x r)
17:03:09 <enthropy> interesting, let's see if that works out
17:03:10 <Eduard_Munteanu> enthropy: then you can unpack it in listToRecN's type or maybe in the same synonym
17:03:56 <cswords> Uh
17:04:02 <cswords> Now it's reporting a malformed instance type?
17:04:21 <Eduard_Munteanu> cswords: can you pastebin it?
17:04:44 <cswords> http://ix.io/9ex
17:05:36 <Eduard_Munteanu> cswords: you can't use it as a constraint in the instance head, but you can pattern-match on it if passed as a parameter to one of your methods.
17:06:16 <enthropy> Eduard_Munteanu: doesn't work: http://lpaste.net/96509
17:06:44 <cswords> Eduard_Munteanu: I want it in the instance head.
17:06:51 <cswords> Is there a way I can abstract it out and use it there?
17:06:59 <Eduard_Munteanu> enthropy: hm, what does it say?
17:07:05 <enthropy> it's in the paste
17:07:11 <Eduard_Munteanu> Oh, oops
17:08:18 <cswords> Got it.
17:12:12 <enthropy> cswords: you could also do: type MyConstraint d s c = (Monitor d s c, c ~ (Con (Strat d) (Shape s)))
17:12:25 <Eduard_Munteanu> enthropy: hm, you can make it   data WrapC :: Constraint -> * where WrapC :: c => WrapC c   and pass it by value. Not sure why it works for the type but it's not in scope in the value definition. :/
17:12:47 <enthropy> so get rid of those troublesome x y variables
17:18:36 <pavonia> Is Data.Vector.fromList constructing the vector lazily?
17:27:44 <startling> is there a data Freely e f a = Purely (f a) | Freely (e (Freely e f) a) somewhere?
17:28:20 <cswords> Eduard_Munteanu: thanks for all the help
17:30:03 <Eduard_Munteanu> cswords: sure, alright
17:30:51 <Eduard_Munteanu> startling: there's a FreeT monad transformer around
17:31:04 <quchen> pavonia: I don't think so. In order to create a Vector the size has to be known.
17:31:20 <shachaf> This is not FreeT.
17:31:21 <startling> I /think/ you can write a (Monad f, Functor (e f)) => Monad (Freely e f) instance ...
17:31:22 <quchen> So you'll at least have to evaluate the spine.
17:31:55 <Eduard_Munteanu> Oh, oops, 'e' takes two args there.
17:32:07 <startling> Eduard_Munteanu: yeah
17:32:20 <startling> it's FreeTT
17:32:31 <startling> (I think?)
17:36:57 <startling> Maybe I'm wrong about the Monad instance.
17:37:32 <pavonia> quchen: Hhm, I try to construct a new vector from two others. The problem is, it's not just zipping them but reading "random" elements from both lists (while still from left to right)
17:38:16 <pavonia> And I would try to avoid calculating the whole result list first
17:39:02 <startling> do you know their length?
17:39:13 <startling> there might be vector thing for that.
17:39:28 <pavonia> The length of both vectors but not of the resulting vector
17:39:36 <startling> OK.
17:41:55 <pavonia> As we may have an XY-question here, my aim is to get the ordered intersection of two ordered vectors :P
17:43:47 <startling> I wonder if you can overallocate safely with vectors.
17:44:07 <quchen> And you're presumably looking for an efficient solution?
17:45:08 <pavonia> yep
17:45:38 <pavonia> worst case should be O(m+n) where m and n are the length of the vectors
17:46:57 <quchen> Complexity doesn't say much about efficiency here I think. Converting to lists, merging, converting to Vector again would be O(m+n).
17:49:25 <quchen> You're sure you need Vector? Set would make this operation much easier.
17:50:34 <lightquake> is there anything that, given some text, will guess what programming language it is?
17:50:58 <quchen> Sure, plenty of syntax highlighting scripts do that.
17:51:22 <geekosaur> ...not always successfully
17:51:28 <lightquake> well, right
17:51:47 <startling> I like how everything thinks Haskell is coffeescript nowadays.
17:52:06 <lightquake> i meant, is there anything in haskell?
17:52:07 <geekosaur> then again I've seen humans fail that one too (cue coworker who ois normally very clueful but argued with me for half an hour about whether a certain awk script was awk or C)
17:52:18 <startling> heh.
17:52:42 <c_wraith> it has curly braces and semicolons.  That makes it C
17:53:15 <geekosaur> worse, it was from a "guess the programming language" website
17:53:22 <pavonia> quchen: I need to store a mapping of A -> B where I can access values between two A's very quickly. The best I came up with is a vector with a modified binary search
17:55:09 <quchen> pavonia: is A ∈ Ord? If yes, have you tried using Map and found its performance insufficient?
17:56:22 <pavonia> It's Ord, but I don't know the exact key in advance. I only know it's between some a1 and a2 in the map
17:56:35 <Eduard_Munteanu> @hoogle lookupGT
17:56:35 <lambdabot> Data.IntMap.Strict lookupGT :: Key -> IntMap a -> Maybe (Key, a)
17:56:36 <lambdabot> Data.IntMap.Lazy lookupGT :: Key -> IntMap a -> Maybe (Key, a)
17:56:36 <lambdabot> Data.IntSet lookupGT :: Key -> IntSet -> Maybe Key
17:56:50 <Eduard_Munteanu> :t M.lookupGT
17:56:50 <lambdabot> Ord k => k -> M.Map k v -> Maybe (k, v)
17:57:04 <pavonia> What is that?
17:57:17 <quchen> Finds the first element with a key greater than the one specified
17:57:28 <Eduard_Munteanu> pavonia: it gives you the smallest key-element pair larger than the one you provide
17:57:50 <c_wraith> there's also lookupGE for greater-than-or-equal
17:58:39 <pavonia> oh, nice
18:00:35 <Eduard_Munteanu> :t M.split -- pavonia
18:00:35 <lambdabot> Ord k => k -> M.Map k a -> (M.Map k a, M.Map k a)
18:01:21 <Eduard_Munteanu> pavonia: so if you have two k's, you can split twice to get whatever's between them.
18:01:55 <Eduard_Munteanu> I suspect it's faster than plainly filtering with a bool predicate.
18:02:22 <Eduard_Munteanu> O(log n). The expression (split k map) is a pair (map1,map2) where the keys in map1 are smaller than k and the keys in map2 larger than k. Any key equal to k is found in neither map1 nor map2.
18:02:35 <pavonia> Not sure split is helping here, I only have one key
18:03:15 <Eduard_Munteanu> pavonia: oh, I thought you meant the key in 'between some a1 and a2 in the map'
18:04:08 <Eduard_Munteanu> Not sure what it means though.
18:04:09 <pavonia> Well yes, but if I split on some a, I'd still have to find the smallest and biggest keys in the new maps, no?
18:04:36 <startling> Type variables default to * ?
18:05:05 <Eduard_Munteanu> startling: not with polykinds, AFAIK
18:05:09 <startling> oh, I see.
18:05:15 <startling> but otherwise?
18:05:36 <Eduard_Munteanu> startling: then they are * by default, I think.
18:06:05 <startling> Got it. Can I use KindSignatures to get around this?
18:06:38 <startling> I guess so.
18:06:40 <Eduard_Munteanu> startling: yeah... though in most cases it will pick things like * -> * too
18:07:08 <Eduard_Munteanu> I forget when it's ambiguous.
18:07:22 <c_wraith> It will default kinds to * if it can.
18:08:56 * startling just reinvented Free. :/
18:09:52 <hpc> you could have invented free monads (or maybe they already existed)
18:11:25 <Eduard_Munteanu> pavonia: I'm not sure I understand, are your values ordered too? Is the mapping monotonic?
18:13:49 <pavonia> Eduard_Munteanu: Imaging a map M and a key K. I need to find the value of the largest key <= k in M and the value of the smallest key >= k in M (which may be the same, but not necessarily)
18:14:00 <pavonia> *Imagine
18:15:02 <Eduard_Munteanu> pavonia: ah, sounds like lookupGE/LE is exactly what you need
18:15:58 <c_wraith> well, then.  lookupLE and lookupGE are exactly what you want
18:16:10 <kvda> If I have a data type A, and newtype B [A], shouldn't an instance Functor B work? I get an error saying  "The first argument of `Functor' should have kind `* -> *'"
18:16:51 <c_wraith> kvda: the type constructor needs an argument of kind *
18:17:22 <c_wraith> kvda: if you're doing newtype B = B [A], then there's no argument to the type constructor B
18:17:30 <startling> Is there a Monoid a => Monad ((,) a) instance (or equivalent type) somewhere?
18:17:48 <c_wraith> you mean an unwrapped writer?  I don't think so
18:18:02 <pavonia> ... except that my containers version is outdated and I have to rebuild almost all packages :|
18:18:06 <startling> hm, I guess it is Writer.
18:18:07 <Cale> yes, it's in Control.Monad.Instances or Control.Monad.Writer
18:18:19 <c_wraith> pavonia: you can't reinstall containers.  It's part of GHC
18:18:27 <pavonia> Oh hell ...
18:18:29 <c_wraith> pavonia: if you try, you'll break everything
18:18:34 <Cale> er, I guess it's not in .Instances
18:18:44 <startling> I'll just use Writer.
18:18:52 <startling> I just hadn't realized that's what it was. :)
18:18:56 <Cale> ah :)
18:19:37 <Cale> I could have sworn the unwrapped version was also at least in Control.Monad.Writer, but perhaps I'm mistaken
18:19:38 <bruim> Hi, I want to contribute with translations of the book learn you a haskell for a great good?
18:20:04 <Cale> bruim: I haven't seen BONUS online here since shortly after he wrote the book.
18:20:22 <Cale> bruim: But you might be able to contact him via email
18:20:42 <bruim> Thanks :Cale
18:20:55 <Cale> bonus at learnyouahaskell dot com
18:21:55 <Cale> bruim: Oh, also the book is licensed under the creative commons license, so I guess you don't even need to ask
18:22:24 <Cale> (specifically http://creativecommons.org/licenses/by-nc-sa/3.0/)
18:23:06 <c_wraith> though it's still polite to ask.
18:23:07 <pavonia> c_wraith: Any ideas what to do then? I really don't want to update GHC because installing gtk is a pain
18:23:23 <c_wraith> pavonia: just use the version of containers you already have?
18:23:39 <pavonia> It doen't have lookupGT/LT
18:23:52 <c_wraith> oh.  eww.
18:24:00 <Eduard_Munteanu> pavonia: try Set then, if possible
18:24:10 <Eduard_Munteanu> IIRC Set had those before Map.
18:24:12 <pavonia> plus the constructors are hidden, so I can't add that functions manually
18:24:23 <startling> pavonia: are you sure?
18:24:38 <pavonia> yes
18:24:45 <startling> pavonia, it's in Data.Map.{Strict,Lazy}
18:25:00 <Cale> Er, didn't it have split?
18:25:22 <pavonia> startling: There just Data.Map :D
18:25:25 <Eduard_Munteanu> You can use split + findMin/Max too.
18:25:27 <pavonia> There's
18:25:38 <Cale> You can write lookupLT and lookupGT pretty easily in terms of split and findMin/findMax, yeah
18:26:06 <pavonia> Ah, right
18:26:16 <startling> you should probably upgrade.
18:26:40 <Cale> Why is installing gtk hard?
18:26:51 <pavonia> because I'm on Windows
18:26:55 <Cale> ah
18:27:47 <pavonia> Okay, I'll try findMin/Max + split. Thanks for the help so far!
18:29:18 <Eduard_Munteanu> pavonia: also see splitLookup
18:43:41 <kvda> c_wraith, thanks
18:48:09 <joelteon> @let tap = flip (liftM2 (>>)) return
18:48:10 <lambdabot>  .L.hs:145:20:
18:48:10 <lambdabot>      No instance for (Monad m0) arising from a use of `>>'
18:48:10 <lambdabot>    ...
18:48:48 <joelteon> @let tap = flip (liftM2 (>>)) return; tap :: Monad m => (a -> m b) -> a -> m a
18:48:49 <lambdabot>  Defined.
18:54:27 <roconnor> I have a graph flow problem and I am torn between finding a solution, just implementing the simplex method because my problems are small, binding to glpk --exact.
19:08:32 <paulschellin> So I'm attempting to perform (buffered) I/O on a block device under Linux (I want to try my hand at a filesystem in Haskell). I've considered System.IO.MMap so far, but I was wondering if anyone knew from experience if libraries such as GHC.IO.Device.RawIO, etc. were better suited for the task?
19:09:19 <startling> is there a Comonad instance for Writer somewhere? (Is it legal?)
19:14:11 <c_wraith> Seems like Writer should be a Comonad.
19:14:26 <c_wraith> There probably is an instance in some comonad library
19:14:57 <shachaf> (e,) is a comonad, yes.
19:15:02 <Hodapp> one of these days, I'll learn WTF comonads are.
19:15:11 <startling> oh, but Writer isn't? blegh.
19:15:22 <shachaf> It's also called Env.
19:15:36 <shachaf> http://hackage.haskell.org/package/comonad-4.0/docs/Control-Comonad-Env.html
19:15:46 <startling> does Env have a Monad instance?
19:16:17 <startling> apparently not. :/
19:16:30 <shachaf> You'll be glad to hear about http://hackage.haskell.org/package/comonad-4.0/docs/Control-Comonad-Traced.html , too.
19:18:32 <monochrom> oh w00t new gtk2hs
19:19:40 <raphie> I'm learning Haskell via "Learn You A Haskell" and someone mentioned that the examples of the State monad are outdated. can anyone point me to a new/better resource?
19:22:09 <monochrom> it's just a pretty simple replacement. when you see "pop = State $ \(x:xs) -> (x,xs) ", change it to "pop = state $ \(x:xs) -> (x,xs)". generalize.
19:22:24 <raphie> what's the difference?
19:22:42 <monochrom> I have just said the most important difference.
19:23:07 <raphie> no I mean what is different about the function state vs the constructor State?
19:23:08 <monochrom> should I said it agian?
19:23:23 <Javran> basically just something like Writer -> writer, Reader -> reader.
19:23:51 <monochrom> I don't understand the question. do you want to know the difference between functions and constructors?
19:23:53 <Javran> http://stackoverflow.com/questions/11684321/how-to-play-with-control-monad-writer-in-haskell I happened to ask a similiar question several months ago ..
19:25:15 <raphie> that makes sense, Javran, thanks!
19:26:14 <monochrom> I guess I should have said it again.
19:26:44 <raphie> ooh, another point of confusion: https://gist.github.com/RaphiePS/805875f53ff9bccc9353
19:27:02 <raphie> sorry if these are newbie questions, it's just pretty confusing
19:27:34 <kvda> raphie, ignore the uppity airs
19:27:47 <kvda> ask newbie questions
19:27:57 <Cale> What uppity airs? :D
19:28:19 <Cale> raphie: Well, what's the type of runState?
19:28:33 <monochrom> "State Stack" already contains the "Stack ->" part.
19:28:52 <Cale> raphie: It's runState :: State s a -> s -> (a,s), right?
19:29:02 <raphie> right
19:29:03 <monochrom> also, see how stackManip doesn't take a parameter
19:29:26 <Cale> So, replacing s by Stack and a by Int, we get  runState :: State Stack Int -> Stack -> (Int, Stack)
19:29:54 <raphie> ahhhhh so the s in there is our initial state, yes?
19:29:58 <Cale> Yeah
19:30:18 <Cale> (and the s in the pair in the result is the final state)
19:30:35 <raphie> gotcha. so a (State s a) isn't really a state, its result is a function that transforms initial state into a result + final state?
19:30:40 <Cale> yes
19:31:04 <Cale> It's a computation which acts on states of type s, and produces a result of type a
19:31:25 <raphie> result of type a and another state of type s, yes?
19:31:27 <Cale> which we represent internally as a function from an initial state of type s, to a pair consisting of a result of type a, and a final state of type s
19:31:36 <Cale> i.e. as a function s -> (a,s)
19:31:55 <Cale> But it's somewhat intended to be abstract
19:32:09 <raphie> it makes sense now! I think I was being tripped up on the constructor being named State. would more accurately be called StateTransform or something
19:32:16 <Cale> We could represent State computations some other way, but given that we're working in a functional language, using functions is a particularly successful and easy one.
19:32:54 <Cale> Right, the first type parameter to State is the type of the states themselves.
19:33:24 <Cale> So State Stack Int represents something which fiddles around with a state of type Stack before delivering an Int
19:33:42 <raphie> I get it! thanks for all your help, Cale
19:33:43 <Cale> (Which you probably already get, but I don't mind repeating anyway :)
19:33:55 <Cale> No problem!
19:34:52 <raphie> another somewhat basic question, are all the lines in a do block given the argument to that do block? that sounds so cryptic, lemme write it in code
19:35:35 <raphie> let foo = do a <- b in foo <someinput>
19:35:38 <raphie> is that equivalent to:
19:35:52 <raphie> do a <- b <someinput> ?
19:35:57 <raphie> if that makes sense
19:36:47 <startling> raphie, I don't follow.
19:38:30 <monochrom> that is likely a type error, even after adding parentheses to become (do a <- b) <someinput>
19:39:22 <startling> it's a syntax error in any case.
19:40:51 <raphie> lemme do some experimentation in ghci and I'll get back to y'all :)
19:42:28 <raphie> nevermind, answered my own question
19:43:53 * hackagebot postgresql-libpq 0.8.2.5 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.8.2.5 (LeonSmith)
19:45:51 <Cale> raphie: The rules for translating do-notation are like this:
19:46:02 <Cale> do { x } = x -- base case with only one statement
19:46:17 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
19:46:26 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> }
19:46:43 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
19:47:29 <Cale> (and there's one more which I could include for when 'v' in the 3rd case is a pattern match which might fail, rather than a variable or other pattern which can't fail to match)
19:48:56 <Cale> do { pat <- x ; <stmts> } = let { ok pat = do { <stmts> } ; ok _ = fail "some error message" } in x >>= ok -- the fact that this 'fail' belongs to the Monad class is generally considered a mistake though, so you can consider this a bonus of sorts.
19:50:41 <raphie> ahh, that makes sense, thank you again
19:52:41 <raphie> what web framework would you folks recommend?
19:52:53 <raphie> hopefully something with a really comprehensive tutorial
19:53:14 <Clint> what are you looking to do?
19:53:36 <raphie> Clint: JSON-based REST API
19:53:58 <startling> that's not something you'd use a web framework for.
19:54:34 <Clint> raphie: yesod then
19:55:01 <dainanaki> I like scotty for APIs
19:58:44 <raphie> scotty looks really simple, I'll check it out
20:05:04 <PepperPhD> hey all. Given this example from Learn You a Haskell (https://gist.github.com/anonymous/7763658), can you explain why "foldl foldFunc []" works inside that composition without parens?
20:06:02 <kfish> PepperPhD, where would you expect parens?
20:06:03 <monochrom> rewrite it as: solveRPN cs = head (foldl foldFunc [] (words cs))
20:08:11 <PepperPhD> monochrom: ah! that makes sense. so the behavior stays consistent. thanks
20:19:53 <raphie> Clint: I took a good look at Yesod but I'd prefer to stay away from DSL's
20:23:11 <AshyIsMe> wow scotty looks nice and simple
20:23:17 <AshyIsMe> dainanaki: cheers
20:25:53 <raphie> so what is up with cabal and force-reinstalls?
20:34:01 <mm_freak> i'm not sure i understand the point of scotty given that happstack and snap allow you to do pretty much the same thing
20:34:55 <mm_freak> raphie: you're using DSLs all the time in haskell
20:35:09 <raphie> mm_freak: like what?
20:35:13 <mm_freak> like IO
20:35:43 <monochrom> competition is the point, or a point
20:36:11 <mm_freak> monochrom: about scotty?
20:36:38 <monochrom> yes. generally about two products doing pretty much the same thing.
20:37:43 <mm_freak> it's just that a new product normally has something that the others don't have, even when it's only something small or a conceptual/philosophical change
20:37:54 <monochrom> in the case of free software, it can be a competition on maintainer diligence
20:40:18 <mm_freak> that's true
20:40:22 <monochrom> let me put in another way. I don't, in fact, understand the point of avoiding duplication and redundancy.
20:41:22 <mm_freak> me neither, but from a user perspective allow me to note that there doesn't seem to be a reason to use scotty =)
20:42:07 <feypaw> my producing scotty was really, really fun
20:42:09 <feypaw> maybe*
20:42:21 <mm_freak> i'm sure it was =)
20:42:30 <monochrom> that's ok. both the vendor's choice to make a redundant product, and the user's choice of not using one, are natural consequences of free market.
20:43:30 <monochrom> on a tangent, for science, I think that clearly scientists don't duplicate quite enough
20:43:40 <mm_freak> an unrelated note:  i'd like to see more unique haskell masterpieces
20:43:51 <feypaw> the fact that consumers do not behave rationally is another part of the free market. existing as a duplicate of another product will attract users just by existing
20:43:51 <mm_freak> like pandoc or darcs
20:44:19 * hackagebot postgresql-libpq 0.8.2.5 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.8.2.5 (LeonSmith)
20:44:19 * hackagebot naturalcomp 0.0.1 - Natural-order string comparison  http://hackage.haskell.org/package/naturalcomp-0.0.1 (HironaoKomatsu)
20:45:32 <mm_freak> from a marketing perspective it might indeed be my mistake to try hard to write unique stuff
21:14:58 <AshyIsMe> man is it just osx that cabal seems to struggle with?
21:15:25 <AshyIsMe> seems that every time i try to install a large-ish project like yesod or snap some packages fail to install
21:15:42 <zomg> AshyIsMe: sounds pretty normal
21:15:56 <zomg> at least my VPS would always crackle and pop with Yesod or such and half of the packages would fail installing
21:16:09 <zomg> then if I just manually installed the failing one and repeated the original install, things would go forwards a bit more
21:16:12 <zomg> :P
21:16:43 <AshyIsMe> ah ok
21:18:25 <AshyIsMe> well vector is failing to install for me
21:18:37 <AshyIsMe> with the exception "ExitFailure 1"
21:18:38 <AshyIsMe> heh
21:19:27 * geekosaur wishes cabal-install wouldn't bother displaying that because people always focus on that and not the fact that the actual error is above it and that is just "I got an error :("
21:23:19 <pavonia> Is there a type class for containers that has (!), null, size, etc. in it?
21:23:30 <zomg> geekosaur: and usually anything more useful is somewhere in the middle of a thousand lines of logs
21:23:40 <mm_freak> pavonia: unlikely
21:24:08 <AshyIsMe> oh, 6 preprocessor directives are invalid  #-}
21:24:16 <geekosaur> I think there is, just not one that is standard or widely used
21:24:22 <mm_freak> pavonia: however, you may find the Store and Traced comonads useful
21:24:28 <geekosaur> AshyIsMe, see the end of the /topic
21:25:15 <AshyIsMe> oh yeap, cheers
21:25:24 <geekosaur> preprocessor errors on OS X are typically xcode 5 not using gcc's preprocessor any more, but clang's which (oddly enough) expects to be run on C code, not Haskell
21:26:28 <AshyIsMe> yeah that page is nice and helpful, thanks
21:27:00 <mm_freak> i think cpp is the most abused software in existence =)
21:27:07 <geekosaur> very
21:27:16 <pavonia> Store and Traced doesn't seem to be what I'm looking for
21:27:23 <geekosaur> most other things that abused it have moved away though...
21:27:33 <mm_freak> pavonia: then try to explain what you're looking for
21:28:06 <mm_freak> pavonia: try to avoid words like "class" or "generic" =)
21:28:31 <pavonia> A common interface for containers. I see many modules using the same function names, so I'm wondering why there's no higher level interface for that
21:28:51 <mm_freak> why should there be?  and what would be its denotation?
21:28:53 <geekosaur> because it's rather hard to get one that is both generic enough *and* reasonably performant
21:29:05 <enthropy> @hackage edison
21:29:06 <lambdabot> http://hackage.haskell.org/package/edison
21:29:09 <mm_freak> it's difficult to impossible to unify the interface of them
21:29:25 <geekosaur> and yes, edison is the one I hinted at earlier
21:30:00 <mm_freak> except that it doesn't exist
21:30:10 <enthropy> http://hackage.haskell.org/package/EdisonAPI-1.2.2/docs/Data-Edison-Seq.html
21:30:24 <enthropy> as an example of a class that has 30 methods
21:31:56 <mm_freak> i still don't understand why there is even a demand for such an abstraction
21:33:01 <mm_freak> i think the honest answer is that people want to write 'size' instead of 'M.size' =)
21:33:04 <geekosaur> yeh, I didn't remember if it was on hackage by that name or not. I do know it's not very widely used... going generic here doesn't gain much and costs performance, it's better to have common names for functions and use qualified imports to switch
21:33:21 <mm_freak> i agree
21:34:25 <pavonia> "i still don't understand why there is even a demand for such an abstraction" -- I bet people also think this about most of edwardk's packages :P
21:35:53 <geekosaur> enh. there's generic programming already, edwardk just makes it accessible.
21:37:52 <mm_freak> pavonia: edwardk's packages solve real problems =)
21:38:10 <mm_freak> most of them at least
21:38:22 <jmcarthur> pavonia: Functor, Foldable, Traversable?
21:38:39 <jmcarthur> pavonia: or perhaps some generalizations as found in lens
21:39:17 <jmcarthur> pavonia: null and size are implementable in terms of Foldable. (!) would be one of the indexed things in lens
21:40:12 <jmcarthur> :t getSum $ foldMap $ const $ Sum 1
21:40:13 <lambdabot>     Couldn't match expected type `Sum a0'
21:40:13 <lambdabot>                 with actual type `t0 a1 -> Sum a2'
21:40:13 <lambdabot>     In the second argument of `($)', namely `foldMap $ const $ Sum 1'
21:40:30 <jmcarthur> :t getSum . foldMap (const $ Sum 1)
21:40:31 <lambdabot> (Num c, Foldable t) => t a -> c
21:44:09 <mm_freak> my favorite generalization of (!) is 'extract' from Comonad
22:17:41 <ReinH> arkeet: ping
22:33:19 <jle`> did you hear that the government has declassified an artificial intelligence project
22:33:35 <jle`> that is capable of self-improving itself and writing code
22:33:51 <jle`> its codename is edwardk
22:42:57 <funfunctor> Hi, anyone tried the clash package recently..?
22:44:45 <funfunctor> I get CLasH/HardwareTypes.hs:24:8: Ambiguous module name `Prelude': found in base & haskell98-2.0.0.2. How can Prelude be ambiguous?
22:45:03 <prkchp_sndwhich> I'm stuck on a very simple "Couldn't match type Integer with Int" error on some homework. We have to define primality in terms of primitive recursion. Can someone take a look at isPrime and tell me what the matter with it is? http://lpaste.net/6076475582411964416
22:45:38 <shachaf> prkchp_sndwhich: You should say the complete error.
22:45:51 <opqdonut> prkchp_sndwhich: the first thing that I notice is that eval uses Integer and check uses Int
22:46:07 <opqdonut> and then isPrime uses Integral a
22:46:09 <prkchp_sndwhich> shachaf: [1 of 1] Compiling PR               ( NaturalPR.hs, interpreted )  NaturalPR.hs:97:35:     Couldn't match type `Integer' with `Int'     In the second argument of `bmin', namely `n'     In the expression: (bmin div n)     In the second argument of `C', namely `[(bmin div n), Z]' Failed, modules loaded: none.
22:46:28 <opqdonut> and PR contains an Int
22:46:33 <shachaf> See, that's helpful.
22:47:19 <shachaf> Now you should give everything a type signature. :-)
22:48:36 <prkchp_sndwhich> If I update the signature on isPrime to be Int -> Int I now get a new error
22:48:37 <prkchp_sndwhich> Couldn't match expected type `Int' with actual type `Integer'     In the return type of a call of `eval'     In the expression: eval (C ne [(bmin div n), Z]) [2 .. n]     In an equation for `isPrime':         isPrime n = eval (C ne [(bmin div n), Z]) [2 .. n] Failed, modules loaded: none.
22:52:06 <prkchp_sndwhich> I've updated my code and turned all Ints into Integers so only that type is used. However, I'm still getting problems. The paste is http://lpaste.net/6076475582411964416
22:52:22 <prkchp_sndwhich> The errors are:
22:52:24 <prkchp_sndwhich> [1 of 1] Compiling PR               ( NaturalPR.hs, interpreted )  NaturalPR.hs:34:29:     Couldn't match expected type `Integer' with actual type `Int'     In the return type of a call of `length'     In the second argument of `check', namely `(length gs)'     In the first argument of `(&&)', namely `check f (length gs)'  NaturalPR.hs:97:35:     Couldn't match expected type `Int' with actual type `Integer'     In the second 
22:54:59 <monochrom> yeah, "length gs" has type Int, not Integer
22:57:03 <prkchp_sndwhich> monochrom, thanks. converted all Integers to Ints. Problem solved.
23:00:24 <pavonia> funfunctor: It seems to be loading two packages that both have a module "Prelude", so it doesn't know which to choose
23:10:24 <mzero> Merging, Folding, Monoids, and Foldable: https://mtnviewmark.wordpress.com/2013/12/02/mfmf/
23:24:34 * hackagebot rmonad 0.8.0.1 - Restricted monad library  http://hackage.haskell.org/package/rmonad-0.8.0.1 (GaneshSittampalam)
23:30:42 <witt3rd> hi - does anyone know how to get lhs2tex to parse unicode chars for :: and -> ?
23:32:40 <linduxed> hey guys, where can i find the definitions for typeclasses like Num?
23:33:11 <mzero> @src Num
23:33:12 <lambdabot> class  (Eq a, Show a) => Num a  where
23:33:12 <lambdabot>     (+), (-), (*)           :: a -> a -> a
23:33:12 <lambdabot>     negate, abs, signum     :: a -> a
23:33:12 <lambdabot>     fromInteger             :: Integer -> a
23:33:20 <mzero> how'z'bout right here!
23:33:30 <arkeet> that doesn't work most of the time.
23:33:37 <arkeet> also it lies sometimes.
23:33:41 <linduxed> any other way than the lambdabot? :-P
23:33:41 <c_wraith> mzero: Why are you bothering to specify the log base in your big-O notation? :P
23:33:54 <mzero> Theya re in the prelude, btw - and you can find the src linked from the Haddock on the Haskell Platform page
23:33:55 <arkeet> linduxed: find the documentation for it on hackage.
23:33:57 <arkeet> hoogle can help.
23:34:06 <arkeet> @where hoogle
23:34:06 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
23:34:08 <mzero> c_wraith: because it wasn't big-O notation!
23:34:24 <mzero> It's an actual count
23:43:44 <radish> if i do fn = newMVar 1 it returns MVar Num right?
23:44:03 <radish> which i can then work with using takeMVar and putMVar?
23:44:38 <radish> my code is saying its expecting MVar Num but its getting Num.
23:44:45 <radish> ghci is saying that, at least.
23:45:07 <c_wraith> Num isn't a type
23:45:30 <radish> c_wraith oh you are correct i'm sorry
23:45:36 <c_wraith> it'd be something more like fn :: Num a => IO (MVar a)
23:45:46 <radish> you caught me thats what it was
23:45:53 <mzero> do you mean     do  fn <- newMVar 1    ?
23:46:15 <mzero> oh - "do" wasn't code there
23:46:41 <mzero> :t newMVar 1
23:46:42 <lambdabot> Not in scope: `newMVar'
23:47:11 <mzero> newMVar 1 :: Num a => IO (MVar a)
23:47:20 <radish> mzero: so i tried that but it doesn't work.
23:47:31 <mzero> so fn is a an IO action that, when run, returns an MVar
23:47:43 <mzero> how are you using fn?
23:47:56 <radish> mzero: that might be the problem i defined fn as fn = newMVar 1
23:48:18 <radish> mzero: but by the looks of it, maybe i need fn = do...?
23:48:49 <mzero> again, how are you using fn?
23:49:05 <mzero> are you trying to write       takeMVar fn       ?
23:49:45 <radish> i want to use that specific mvar in different places
23:50:14 <radish> mzero: i want the newMVar not the value from it
23:50:25 <mzero> can't do that
23:50:29 <mzero> it is in IO!
23:50:33 <mzero> once in IO, always in IO!
23:50:48 <radish> mzero: that doesn't seem right.
23:50:53 <zRecursive> :t liftIO
23:50:54 <lambdabot> MonadIO m => IO a -> m a
23:51:11 <mzero> so you can write this        do  mv <- fn;   takeMVar mv....    etc....
23:51:35 <radish> mzero: i can't return the MVar without taking the value out??
23:51:51 <radish> so return is just getting me the value?
23:52:06 <mzero> but you cannot have a toplevel MVar....     (without unsafePerformIO.... don't read that... no no! it will make you go blind, and sprout horns!!!!   stop... don't call that function!!!!!!!   you've been warned!)
23:52:20 <mzero> You can't "return" an MVar, no
23:52:29 <mzero> not in the sense I think you mean it
23:52:41 <mzero> you can only use an MVar in the context of an IO action (in a do block)
23:53:00 <radish> mzero: sure, but can't i take return it from one IO function and then pass it into another?
23:53:11 <radish> i'm pretty sure it was working before i refactored.
23:53:44 <mzero> so, fn itself might be fine --- it is how you're using it that matters
23:54:38 <mzero> if you are trying to "refactor"   some MVar out, by having a top level declaration that is    theThingy = newMVar 1     ---- and then    theThingy  in multiple places to get at the same MVar --- you can't
23:54:42 <radish> mzero: look i have a function expecting an MVar it even says so
23:55:00 <mzero> then     fn >>= funtionExpectingAnMVar
23:55:03 <radish> mzero: but its saying its getting just the Num a or whatever
23:55:20 <radish> mzero: yeah, i did the whole <- thing
23:55:22 <mzero> please hpaste code snipped and exact GHC error message
23:55:31 <arkeet> @paste
23:55:31 <lambdabot> Haskell pastebin: http://lpaste.net/
23:55:47 <mzero> (remember - GHC might be complaining about some inner part of the type, not the whole type)
23:57:39 <dp_wiz> I'm trying to upload a package update and hackage gives an error:
23:57:39 <dp_wiz> > 'ghc-options: -fhpc' is not appropriate for a distributed package.
23:57:39 <dp_wiz> But that option is guarded by "developers" flag which is False by default. Am i doing something wrong?..
23:57:40 <lambdabot>   <hint>:1:67:
23:57:40 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
23:59:08 <mzero> dp_wiz: sounds like a bug in hackage2
23:59:25 <mzero> is the flag set for manual only?
